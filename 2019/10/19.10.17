00:07:56 <trcc> I have an issue where a file is deleted before it is processed, and I expect it has something to do with laziness. Is there a way to avoid this? https://gist.github.com/CThuleHansen/efb42699dd1f933d9c0776a1e0db1af8
00:12:07 <hololeap> trcc: i don't think that createProcess blocks. you need to use waitForProcess too, or just use readProcess instead
00:12:52 <trcc> hololeap: well the function does not return before I have the output. Is that because it blocks when I use the result value in the return?
00:13:53 <s0da> ok sry i disappeared on u guys. health issue.
00:15:24 <s0da> maerwald, tabeman, and welkin: thank you very much for the enlightening convo.
00:15:43 <trcc> hololeap: it works!
00:15:46 <trcc> with readprocess
00:17:27 <s0da> right now, ive got a 100 of firefox tabs open simultaneously, reading about "mission critical programming languages" and similar subject matters.
00:18:39 * s0da drinks himself
00:20:04 <hololeap> trcc, you should probably be handling errors with Control.Exception.bracket as well. also, consider learning about conduit if you plan on doing anything like processing the file on the fly
00:21:13 <trcc> hololeap: Thank you! I will add it to my feedback list!! Great with some feedback. I am more than interested in more! (https://www.reddit.com/r/haskell/comments/dhvfmy/feedback_first_noncriticalatall_haskell_scotty/)
00:21:20 <trcc> Added (https://github.com/INTO-CPS-Association/utilities_backend/issues/8)!
00:23:17 <maerwald> s0da: heh
00:24:02 <maerwald> s0da: https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118059.html this thread is also interesting
00:24:46 <maerwald> tl;dr: crypto in haskell is controversial and hard
00:25:40 <maerwald> https://project-everest.github.io is much more on the right track
00:32:50 <Axman6> I'm surprised to not see Galois on that list, this is definitely their area
00:34:50 <s0da> maerwald: im mainly interested in programming my own online computer games. but im also interested in eventually branching out into more "serious bussiness apps, etc."
00:35:29 <s0da> and you guys advised haskell and erlang as 2 of the best languages for a beginner to "enforce good habits" on himself from the start.
00:35:42 <maerwald> Axman6: last time I had a conversation with someone about haskell-tor security, the response was rather disappointing
00:36:15 <maerwald> I'm not aware that they're doing full-verified (high and low level) crypto
00:36:36 <s0da> what about Ruby, Python, and Blitz BASIC? (WRT to enforcing "Good Habits" on oneself from the beginning?)
00:37:07 <s0da> (Ruby, Python, and Blitz Basic are considered "easy/beginner" game design languages for the tyes of games if like to design)
00:37:23 <s0da> *id like to design
00:38:13 <s0da> would Ruby/Python/BlitzBAsic be likely to enforce BAD habits on me? or perhaps just NOT enforce Good ones as much as haskell and erlang would?
00:38:41 <maerwald> python is the best for getting started quickly and building up programming knowledge/experience in general
00:38:56 <maerwald> doesn't enforce anything, except indenting, though :P
00:39:15 <Athas> Finally all my dependencies support GHC 8.8!
00:39:39 <tdammers> IMO it doesn't matter an awful lot which language you start with, as long as you keep your eyes open and try others too
00:39:58 <s0da> (note i only have experience with: BASIC, Visual BASIC, Blitz BASIC, and C++. BUt i'd like to branch out into other territory, and eventually (hopefully sooner rather than later), begi adopting -- and making a *habit* of -- "Best Practices".)
00:40:13 <tdammers> I'd compile a list of a few candidates, and just roll with the one whose "Hello World" example intuitively makes the most sense to you
00:40:29 <Athas> s0da: it's much more tempting to do ugly things in those languages than in Haskell, but if you have a good written source that lays out advice, and the discipline to follow the advice, then you'll be fine.
00:40:32 <tdammers> (provided that you succeed in setting up the toolchain)
00:40:35 <s0da> tdammers: ok
00:41:18 <tdammers> I wouldn't worry too much about "enforcing good habits from the beginning"; that's approaching the horse from the back
00:41:39 <tdammers> good habits are a solution to a problem, but you will only get them right if you have felt the pain
00:42:06 <tdammers> if you haven't, you'll just go through the moves without understanding why, i.e., you'll be cargo-culting things that may or may not be useful
00:42:19 <s0da> tdammers: roger that on the subject of horse! lol. and roger that on the "need" to learn lessons the hard way!  (on a tangential note, i downloaded and installed from source the "hello world" program by GNU. It's like a Trillion lines of code.))
00:42:47 <tdammers> well, hello world in haskell is basically: main = putStrLn "Hello, world!"
00:43:01 <s0da> tdammers: SOLD!   :D
00:43:02 <tdammers> (in Python, it's print("Hello, world!"), so basically on par)
00:43:14 <s0da> SOLD again!   :D
00:43:18 <tdammers> (JavaScript: console.log("Hello, world!"); )
00:43:26 <s0da> SOLD again!   :D
00:43:36 <Athas> GNU Hello World is explicitly overengineered to show off all the infrastructure.
00:43:48 <s0da> I FIGURED THAT! LOL. 
00:43:55 <tdammers> #include <iostream>
00:43:59 <s0da> they made it highly "configurable"
00:44:09 <s0da> with extensibility
00:44:16 <s0da> and multi-language support
00:44:21 <tdammers> int main(int argc, const char** argc) { std::cout << "Hello, world!" << std::endl; }
00:44:28 <s0da> lol. indeed
00:44:30 <trcc> Is it possible to supress "Defined but not used" warning for a given function?
00:44:40 <tdammers> (I'm not hearing "sold" on the C++...)
00:44:47 <s0da> :p
00:45:10 <s0da> i actually have experience in c++, but your above point DRIVES HOME he point very well
00:45:17 <s0da> *the
00:45:46 <Maxdamantus> const char(*(* argc))
00:46:03 <s0da> would it make sense for me to switch from c++ to python/java/haskell?
00:46:30 <tdammers> why switch? who says you can only know one language at a time?
00:46:39 <tdammers> just learn the basics of all 3 and see what happens
00:46:42 <s0da> i mean as a FOCUS point
00:46:50 <s0da> perhaps those are suerior in certai areas?
00:46:56 <s0da> *certain
00:47:03 <s0da> *superior
00:47:03 <merijn> "I'm a polyglot programmer, I write in all languages!" I say, as I wrote any code I can get away with in Haskell...
00:47:06 <tdammers> they are, but in order to make an educated decision, I'd first learn the basics of those languages
00:47:12 <tdammers> merijn: same here
00:47:23 <s0da> how about hello world in erlang?
00:47:30 <merijn> trcc: For just a single function? I don't think so
00:47:37 <trcc> merijn: ok thanks
00:47:38 <tdammers> merijn: although I opted to roll with "vanilla JavaScript" for a recent project, and I don't regret it a bit
00:47:42 <trcc> yes for a single function was the indentation
00:47:45 <trcc> intention*
00:47:49 <merijn> trcc: Seems like an oddly specific thing to want, though?
00:47:53 <tdammers> s0da: I don't speak Erlang, but I'm sure you'll be able to dig something up
00:48:30 <s0da> ok. but do you know if it is on approx. the same level of "straightforwardness" as the other 3 examples you showed me?
00:48:54 <trcc> merijn: well i have a wai logger that is almost working, except that it only works for the first request. Afterwards it returns the error openFile: Resource busy (file is locked). So I want to fix it, not remove it.
00:49:06 <trcc> I just do not know how yet. Sort of work in progress
00:49:49 <merijn> trcc: In that case I'd just, you know, ignore the warning? :p
00:49:58 <trcc> hehe I am 
00:50:07 <trcc> but ignoring warnings is a slippery slope :P
00:50:16 <trcc> so is suppressing them I guess hehe
00:50:43 <s0da> tdammers: imma open firefox tab to research erlang, and add it to the mess of tabs i have open. im sure i can dig something up, as you said
00:51:10 <s0da> tu 4 the above examples, tdammers
00:51:25 <tdammers> s0da: YW
00:51:37 * s0da drinks self, and relaxes...
00:52:21 <tdammers> btw., https://github.com/leachim6/hello-world is a thing
00:52:30 <merijn> Single line hello world programs aren't particularly great examples to base language choices on, tbh
00:52:54 <Athas> Some languages can't even express hello world!
00:53:10 <merijn> Athas: Futhark? ;)
00:53:19 <Athas> As a coincidental example.
00:53:23 <merijn> Athas: I'm sure it can
00:54:01 <merijn> Athas: You'll just have to do some voodoo to turn into something that can be called from OpenGL and write it as a shader rendering hello world
00:54:19 <Athas> Sure!  But you need something on the outside to turn the crank.
00:54:36 <merijn> If you make it work you've got a guaranteed SIGBOVIK publication right there
00:55:54 <Squarism> I have this default.nix file. I wonder if theres some way I could 1. be able to compile "server" (excluding client) from nix-shell. 2. reach a repl/ghci from nix shell for "server" build. 
00:56:21 <merijn> Athas: By that logic none of the Piet/brainfuck/etc. "hello world" program count either
00:56:34 <Athas> merijn: Brainfuck has the . instruction for printing.
00:56:40 <Athas> Not sure about Piet.
00:56:56 <Squarism> (im super green on nix, just barely managed to get this working default.nix file - that does what its supposed to do for building artifacts) 
01:00:47 <Squarism> oh .. and heres the default.nix file https://paste.ofcode.org/4p66CsZ8tWbJkehVQcCmnK
01:02:13 <trcc> If someone happens to be a wai-logger expert I have an issue with a file being locked: https://github.com/kazu-yamamoto/logger/issues/183
01:07:58 <Squarism> I have this default.nix file. I wonder if theres some way I could 1. be able to compile "server" (excluding client) from nix-shell. 2. reach a repl/ghci from nix shell for "server" build.  https://paste.ofcode.org/4p66CsZ8tWbJkehVQcCmnK
01:10:03 <Athas> Is there a way to indicate in a .cabal file that you need a specific GHC version?
01:10:38 <hololeap> trcc, never used it but i might have a hint. take a look at the source for Network.Wai.Logger.withStdoutLogger
01:10:39 <maerwald> Athas: in cabal.project as: with-compiler: ghc-8.6.5
01:10:40 <hololeap> https://hackage.haskell.org/package/wai-logger-2.3.6/docs/src/Network.Wai.Logger.html#withStdoutLogger
01:10:45 <merijn> Athas: Define indicate and need?
01:11:01 <merijn> Athas: You can constrain GHC via constraints on base, you can advertise via tested-with?
01:11:38 <Athas> merijn: I want cabal to fail with an error saying "you need GHC x.y.z to build this thing".
01:11:53 <Athas> My audience is not Haskell programmers.  The error message must be clear.
01:12:15 <Athas> Is cabal.project automatically picked up by cabal 3 and newer?
01:12:15 <merijn> Athas: Oh, you could experiment with setting "buildable" false depending on the GHC version, but I'm not sure what kinda error that produces
01:13:21 <trcc_> hololeap: thanks, but I am not interested in withstdoutlogger, I need it to store in a file
01:13:23 <Athas> The missing piece I need is for cabal to also automatically install the appropriate GHC version.  That's pretty much the only thing I need from stack anymore.
01:13:29 <merijn> Athas: It's automatically picked up by v2-*, so 3.x picks it by default, yes. That doesn't really have any fancy errors, though
01:13:59 <merijn> Athas: ghcup? That assumes some commandline knowledge, but nothing Haskell specific
01:16:08 <hololeap> trcc_: try using the same code but replacing LogStdout with LogFile
01:16:10 <Athas> Yeah, ghcup has all the moving parts for sure.
01:16:17 <Athas> I just like the integration into a single command.
01:16:32 <lush> hey there! Has anyone here tried to use haskell on a chromebook through the new Linux-beta feature?
01:16:58 <lush> I tried installing hakyll through stack but the installation crashes,,,
01:17:15 <Athas> How much memory does the Chromebook have?
01:17:24 <hololeap> (and note that it is using `bracket` ...)
01:17:29 <Athas> How do you install hakyll?
01:17:38 <trcc> hololeap: sorry, I had to switch offices
01:17:41 <lush> ram or like actual free storage?
01:17:41 <trcc> hope I did not miss anything
01:17:43 <Athas> I haven't tried it on a Chromebook, but I do have a little Haskell-on-ARM experience.
01:17:58 <lush> @Athas: I tried "stack install hakyll"
01:17:58 <lambdabot> Unknown command, try @list
01:18:01 <Athas> RAM.  The stuff you get to fill up before the OOM killer starts terminating ghc.
01:19:05 <Athas> You likely need at least 8GiB to compile hakyll.  You can try 'stack install --fast -j1 hakyll', which will disable parallel builds and optimisations.
01:19:08 <hololeap> trcc: i said to try using the code for withStdoutLogger but use LogFile instead of LogStderr. also note that the code for withStdoutLogger uses bracket.
01:19:23 <Athas> Alternatively, you need to set up a swap file.  It'll be slow to build, but it will work.
01:19:32 <lush> AesonException "Error in $['system-info']: failed to parse field system-info: key \"os\" not present"
01:19:34 <lush> Thats the error
01:19:43 <lush> I'll look for the amount of ram in a second
01:19:46 <Athas> Uh, okay, that's not about RAM.
01:19:56 <Athas> I have no idea what that is, actually.
01:20:42 <lush> yeah thought so..
01:20:57 <lush> maybe I should try installing it with cabal, but I guess it'll be the same error
01:21:09 <trcc> hololeap: I will try
01:21:14 <trcc> Thank you
01:22:07 <lush> mhm
01:22:34 <lush> I'd really like to try setting up a webpage with hakyll. But I'm currently on a student exchange and only have got my chromebook with me
01:22:37 <lush> If I won
01:22:54 <lush> *If I won't be able to get it running I might need to use some non-haskell solution
01:26:25 <Athas> lush: this is an ARM Chromebook, right?
01:26:39 <Athas> Does 'stack repl' work?
01:26:53 <Athas> Last I tried, stack could not automatically install GHC on ARM.  It was quite painful.
01:27:03 <lush> yeah its a lenovo c330. Has some mediatek chip I think
01:27:15 <lush> I'll try, 1 sec
01:27:33 <lush> ah actually cabal is still busy resolving dependencies for hakyll lmao
01:27:38 <s0da> wow. theres LOTS of haskell channels on irc! o_o
01:27:55 <s0da> o_o more like O_O
01:28:11 <tdammers> haskellers love irc
01:28:44 <lush> segmentation fault lmao
01:28:49 <s0da> is haskell taking the world by storm right now?
01:28:54 <tdammers> no
01:28:55 <svipal> lol
01:29:00 <Athas> lush: in case it helps, last time I had to compile a large-ish Haskell program on an ARM system, I wrote these notes: https://futhark-lang.org/blog/2019-06-22-futhark-on-nvidia-jetson.html#compiling-the-futhark-compiler-on-the-jetson
01:29:01 <Athas> I had to use Nix to get a working GHC, which kind of sucks.
01:29:09 <tdammers> it has seen a surge of popularity in certain niches recently though
01:29:11 <Athas> lush: the segmentation fault is possibly an out-of-memory issue.
01:29:13 <lush> Athas: stack repl gives the same error actually!
01:29:34 <tdammers> "Haskell in industry" has gone from completely exotic to a sustainable niche over the past 10 years or so
01:30:56 <lush> thanks Athas, will check it out!
01:31:00 <s0da> is it (haskell) good for retro game design? (in comparison to Erlang/Ruby/Python/C++/BlitzBASIC?)
01:31:23 <maerwald> you mean the ecosystem? probably not
01:35:09 <sshine> Athas, I similarly had to enable a swapfile to compile stuff on my 1GB RAM VPS.
01:35:51 <tdammers> it can be done, and there are certain unique advantages, but you will also be in mostly uncharted terrain, and the vast amount of tutorials, libraries, frameworks, etc., out there won't work, at least not without jumping through some hoops
01:47:12 <Athas> Ware the "redundant import" warnings in GHC 8.8 known to be buggy?
01:56:02 <maerwald> I thought they are more correct and catch more cases
01:56:05 <maerwald> what do you mean?
01:56:11 <lavalike> Athas: that's neat, I'm getting an ARM laptop soon
01:57:01 <Athas> maerwald: I'm getting warnings about redundant imports that are not redundant at all.
01:57:17 <Athas> Not even complex cases.  Just importing some function that I definitely use.
01:57:40 <Athas> lavalike: I hope you get enough memory!
01:57:48 <lavalike> 4GB I believe
01:57:51 <maerwald> Athas: and if you remove the import, does it still compile?
01:57:55 <s0da> ok i found oher channels that are focused more on the type of thing im asking about. sry to be so off-topic. bye
01:57:59 <Athas> maerwald: nope.
01:57:59 <s0da> *other
01:58:05 <maerwald> Athas: please share example
01:59:19 <Athas> maerwald: it says that the import of 'SemVer, prettySemVer' is redundant here: https://github.com/diku-dk/futhark/blob/master/src/Futhark/Pkg/Info.hs#L36
02:00:34 <Athas> Hm.  Actually, it looks like Data.Versions is re-exported by Futhark.Pkg.Types.  Wonder why it doesn't build, then.
02:01:17 <Taneb> Athas: semVer and the constructors of SemVer are not on that list of what's redundant
02:01:21 <Taneb> *semver
02:01:49 <Athas> Ah, I think it's because the module re-export was less I thought.
02:02:17 <trcc> hololeap: so what I find wrong about the withStdoutLogger implementation at https://hackage.haskell.org/package/wai-logger-2.3.6/docs/src/Network.Wai.Logger.html#withStdoutLogger seems like it is for the entire app, and not every individual request
02:02:44 * hackage ghcflags 1.0.0 - Dump the ghc flags during compilation  https://hackage.haskell.org/package/ghcflags-1.0.0 (tseenshe)
02:31:14 * hackage hprox 0.1.1 - a lightweight HTTP proxy server, and more  https://hackage.haskell.org/package/hprox-0.1.1 (BinJin)
02:33:14 * hackage hsinspect 0.0.6 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.6 (tseenshe)
03:07:42 <bwe> Hi, if I have an API that may return {"attr1": "value1", ...} or {"error": "msg"}, can I use  Either ErrorMsg ValidElement  with FromJSON in Aeson?
03:15:27 <Boomerang> Yes! You might have to wrap the ErrorMsg in a type with the `error` key if you don't want to write the instance by hand
03:15:54 <Boomerang> type ErrorMsg = String; newtype Error = Error { error :: ErrorMsg }
03:19:52 <bwe> Boomerang: cool, thanks. I'll try that out later.
03:20:14 * hackage clash-prelude 1.0.1 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.0.1 (QBayLogic)
03:21:14 * hackage clash-ghc 1.0.1, clash-lib 1.0.1 (QBayLogic): https://qbin.io/urge-glad-ylsg
03:22:30 <Boomerang> Ah wait, the default instances might expect a tag for Either :/ I think it's still possible but you might need to write the instance by hand
03:23:59 <Boomerang> You can change the `defaultOptions` and use a different `sumEncoding`: https://hackage.haskell.org/package/aeson-1.4.5.0/docs/Data-Aeson.html#v:sumEncoding
03:24:28 <Boomerang> `UntaggedValue` is most likely what you're after
04:11:14 * hackage mmsyn3 0.1.0.0 - A small library to deal with executable endings  https://hackage.haskell.org/package/mmsyn3-0.1.0.0 (OleksandrZhabenko)
04:40:44 * hackage shh 0.7.0.7 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.7 (lukec)
04:53:25 <tom_> Which operator do I want if I want to two IO (Either a b) computations and return either the first Left or the last Right?
04:54:10 <ski> i don't understand the question
04:54:44 <ski> can you elaborate on what the inputs are, and what you want to do with them ?
04:55:39 <ski> do you have one, or two, input `IO'-actions, having type `IO (Either a b)' ?
04:56:05 <brnzz> I suspsect something like race, from the async package
04:56:27 <ski> i assume you want to execute `IO'-actions, two times (either the same one, twice, or else each one of the two, once)
04:56:56 <ski> if so, then you have two `Either a b's .. what exactly do you want to do with them, then ?
04:56:57 <tom_> https://pastebin.com/UJZGKDPj
04:57:22 <ski> (or, perhaps i'm wildly off the mark in my guesswork here, in which case you need to elaborate even more)
04:57:40 <tom_> I only really care if there is a failure in either one as I essentially ignore the Right results
04:58:04 <tom_> But the second action depends on the first not in terms of inputs but order
04:58:14 <ski> hmm
04:58:53 <ski> so you want short-circuiting behaviour, in terms of `Stripe.Error' ?
04:58:57 <kaol> runExceptT $ ExceptT actionA >> ExceptT actionB
04:59:08 <tom_> ski: yeah
04:59:11 <ski> as soon as you get a `Stripe.Error', you abort the other ones ?
04:59:14 <ski> then what kaol said
04:59:25 <ski> well
04:59:53 <ski> it also depends on what you want to do with the two `Value's. if you just want to throw away the first one, and keep the second one, then what kaol said
05:00:35 <ski> if you want to say combine them, you can still use `ExcepT Stripe.Error IO Value'
05:01:11 <tom_> Awesome thanks Kaol and Ski!
05:01:41 <ski>   runExcept $ do
05:01:51 <ski>     val0 <- ExceptT (attachPaymentMethod k cId pmId)
05:02:02 <ski>     val1 <- ExceptT (makeDefaultPaymentMethod k cId pmId)
05:02:10 <ski>     ..val0..val1..
05:02:24 <ski> (possibly using `return' in the last command in the `do' there)
05:03:08 <tom_> Thats neat thanks
05:03:20 <tom_> Will put it in my notes as I am sure it will come in handy
05:03:28 <kaol> runExceptT $ (,) <$> ExceptT actionA <*> ExceptT actionB
05:03:56 <ski> tom_ : of course, if `newDefaultPaymentMethod' will itself be called from places calling other actions of type `IO (Either Stripe.Error Blah)' (or performing an action of such a type), you'd probably skip the `runExcept' at this point
05:04:27 <ski> yea, if `..val0..val1..' is `return (val0,val1)', then what kaol said
05:04:44 <ski> and if it is `return (f val0 val1)', then you replace `(,)' by `f'
05:05:08 <ski> (that's using idiomatic combinators)
05:06:06 <ski> (oh, and s/runExcept/runExceptT/)
05:07:42 <maralorn> Is it allowed/encouraged to subscribe on the ghc-steering-comitee list? The archive is public. But I‘d be curious to follow the discussion.
05:10:54 <zincy_> ski: Not sure I follow how you would skip the runExceptT in that case
05:11:15 <zincy_> ski: Do you mean use it further up and add in the other IO actions of that type into the sequence
05:11:38 <maralorn> I am not even sure that mailman supports read-only subscribers.
05:14:55 <zincy_> sorry my name updated from tom_
05:18:25 <ski> zincy_ : yes
05:18:54 <ski>   newDefaultPaymentMethod :: Stripe.ApiSecretKey -> Stripe.CustomerId -> Stripe.PaymentMethodId -> ExceptT Stripe.Error IO Value
05:19:18 <zincy_> understood thanks :)
05:19:50 <ski> of course, you could put `ExceptT Stripe.Error IO' into the type sigs of `attachPaymentMethod' and `makeDefaultPaymentMethod' as well, moving the `ExceptT' data constructors into those two defininitions
05:20:00 <ski> (i'd probably do that, in any case)
05:21:15 <ski> (unless, maybe, if `attachPaymentMethod',`makeDefaultPaymentMethod' are also called from somewhere else, where it'd, for some (curious ?) reason it'd be more handy to have it `IO (Either Stripe.Error Value)', rather than `ExceptT Stripe.Error IO Value')
05:21:31 <ski> zincy_ ^
05:24:00 <ski> maralorn : i dunno, maybe you could also try asking in #haskell-infrastructure, or #ghc ?
05:25:11 <zincy_> ski: Yeah that is a good idea, thanks
05:39:11 <purelazy> Nobody cares that much that "=" and "==" are two syntactic tokens to they?
05:40:07 <purelazy> And that " " means function application 
05:41:21 <purelazy> I was thinking could "  " (the syntax of two spaces)  represent " $ ".
05:42:10 <ski> i relatively often insert extra spaces, for lining up things
05:42:31 <purelazy> Oh year
05:42:35 <purelazy> Oh yeah
05:42:47 <purelazy> damn
05:43:06 <ski> `=' and `==' are very different things. it annoys me when people state laws, using `==' (or `===' or some other monstruosity), instead of plain `='
05:43:10 <purelazy> Idea destoyed
05:43:39 <ski> (e.g. `fmap id == id' .. this is nonsense, there is no generic equality checking on functions)
05:44:13 <ski> in other news, there's (thankfully) fewer and fewer places where i need/want to use `$'
05:44:27 <purelazy> As a noob, I never understood "$"
05:44:31 * ski . o O ( `BlockArguments' )
05:44:34 <purelazy> Then I did
05:44:39 <ski> be thankful for that
05:44:52 <ski> it's used way too much, imho
05:45:15 <purelazy> I'm still a noob, so care to explain?
05:45:16 <lyxia> also good luck trying to spot " " vs "  " when a typo causes a bug and you don't know where it is.
05:45:41 <ski> i almost always prefer writing `(foo . bar . baz) x' over `foo . bar . baz $ x' (and both of those are definitely to be preferred over `foo $ bar $ baz $ x')
05:46:33 <ski> if `$' was left-associative instead, it might have a few more uses (together with `$!')
05:46:49 <yushyin> or mixing $ and & for much more confusion!
05:46:54 <purelazy> Does anyone know where foo bar baz comes from?
05:47:18 <yushyin> purelazy: https://en.wikipedia.org/wiki/Foobar wikipedia knows
05:47:27 <ski> purelazy : <http://catb.org/jargon/html/M/metasyntactic-variable.html>
05:47:46 <tdammers> https://en.wikipedia.org/wiki/List_of_military_slang_terms#FUBAR
05:47:56 <lyxia> purelazy: $ is an operator like * and +   when you write  3 + 2 * 1  it means 3 + (2 * 1) because there are rules that say that * has higher precedence than +
05:48:34 <lyxia> purelazy: $ has lower precendence than most other operators, so   3 $ 2 . 1  means  3 $ (2 . 1)
05:48:37 <ski> (also, <http://catb.org/jargon/html/F/foobar.html> is not to be confused with <http://catb.org/jargon/html/F/FUBAR.html>)
05:48:54 <purelazy> FUBAR and foo bar baz are not related
05:49:01 <ski> right
05:49:16 <tdammers> wikipedia seems to think they are
05:49:24 <tdammers> but I'll take the jargon file over wikipedia
05:50:04 <MarcelineVQ> the visiblility of " " can only be measured by examining the sorroundings, there's something a little monstrous about different meanings for different counts of " " due to that relativity of measurement :>
05:50:54 <MarcelineVQ> but kind of interesting, like it'd make a good obfuscation metric
05:51:18 <MarcelineVQ> Why is this text file just " ", how is this a program
05:51:53 <purelazy> What does the BAR symbol mean in math?
05:52:00 <lyxia> https://en.wikipedia.org/wiki/Whitespace_%28programming_language%29
05:52:33 <lyxia> hahaha "developed by Edwin Brady and Chris Morris" now I recognize one of these names
05:52:34 * ski . o O ( <https://esolangs.org/wiki/Whitespace> )
05:52:39 <MarcelineVQ> of course it would be edwin
05:52:44 * hackage mmsyn4 0.1.0.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.1.0.0 (OleksandrZhabenko)
05:52:45 * ski low fours lyxia
05:53:03 * lyxia high sixes ski
05:53:08 <ski> purelazy : where have you seen it in math ?
05:53:37 <purelazy> Over boolean variables
05:53:58 <ski> do you mean the three letters "BAR", or do you mean a line/bar ?
05:54:30 <purelazy> Does it means not, over booleans?
05:54:36 <ski> sometimes, yes
05:54:49 <ski> (if you mean the latter)
05:55:19 <ski> in statistics, it can mean average/mean
05:55:38 <purelazy> And one of the early languages was BASIC
05:55:43 <purelazy> .bas
05:55:44 * hackage replace-attoparsec 1.0.3.0 - Find, replace, and edit text patterns with Attoparsec parsers  https://hackage.haskell.org/package/replace-attoparsec-1.0.3.0 (JamesBrock)
05:55:44 <ski> hm, i think sometimes it's used for vectors, or for lines, relating to geometry ?
05:55:59 <yushyin> ski: yes
05:56:26 <purelazy> and bas got corrupted to baz
05:56:48 <purelazy> That leaves FOO
05:56:56 <ski> hm, i wonder how early that `.bas' was used
05:57:08 <ski> didn't 8.3 come from CP/M, or something ?
05:57:47 <ski> (on Commodore 64, it was `PRG', not `bas')
05:59:19 <purelazy> FOO.bas referred to a BASIC file that was for test only - For Once Only
06:00:15 <purelazy> FOOBAR.bas was for a program that was to be kept forever
06:00:20 <ski> on which system ?
06:00:41 <purelazy> Any system using BASIC I guess
06:00:56 <ski> definitely not
06:01:20 <purelazy> FOO BAR = Not For Once Only
06:02:06 <purelazy> FOO BAR.BAS = A BASIC program not to be deleted
06:03:03 <purelazy> FOO.BAS = could be deleted
06:03:52 <purelazy> More importantly I have a Haskell Program I cannot understand
06:04:55 <purelazy> I was kind of given it
06:05:18 <purelazy> It's "Hangman"
06:05:33 <purelazy> It uses monoid
06:06:32 <purelazy> Is there anyone here that knows the hangman using monoid game?
06:07:29 <samhh> what's the best way to handle dependencies? I have one dep, it's a Maybe. at the moment I'm checking in main if it's Just, and if so passing it down the entire stack, but that means virtually every fn in my app is taking this dep as an argument, which seems a bit silly. at the same time, because it's optional and I want the app to bail early if it's not present, I'm unsure if a Reader would help at all. anyone more experienced than I know what I should 
06:07:29 <samhh> do? :-)
06:09:46 <EvanR> really, every function in your app will need this dep? Must be a pretty simple app
06:10:42 <EvanR> if you are also using StateT over IO or something like an App monad, you can put this dep in that context
06:10:57 <EvanR> if not, just passing it to where it needs to go sounds the simplest
06:12:26 <EvanR> surely it's not Maybe in all those locations, because you are going to bail early if not present
06:12:55 <EvanR> i.e. doesn't sound optional at all
06:14:24 <samhh> EvanR it's Maybe at the top level, and then the inner value is what's passed around. it's used by at least half the fns in the app. it's a fairly simple app yh, a small lambda
06:15:36 <EvanR> are all those functions IO functions?
06:16:02 <samhh> yep
06:16:38 <EvanR> since you're already using monad style probably, you could put the dep in the ReaderT over IO environment
06:17:15 <EvanR> then to do IO you liftIO it, to use the dep you ask or asks it
06:17:51 <samhh> would you say that ceremony is worth it for just one dep? probably more useful 2+?
06:18:09 <EvanR> i mean, if you had 2+ and they were in a record
06:18:24 <EvanR> i still am not sure there is much of a difference
06:19:09 <EvanR> your type sig won't be smaller, you now *must* pass this to all your functions even if they don't use the dep
06:19:40 <EvanR> the only convenience you will get is not having to explicitly pass the 1 argument
06:20:00 <samhh> hmm. I wonder if I could introduce some unsafety where this is globally accessible as if it's there, but I just add a check at the start of main to bail if it's not. I know, not very haskell-y haha
06:20:14 * hackage replace-megaparsec 1.1.5.0 - Find, replace, and edit text patterns with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.1.5.0 (JamesBrock)
06:20:25 <EvanR> i don't really recommend that. You will find it won't really solve much
06:21:33 <EvanR> the ReaderT over IO will make your code look the same without having the usual issues with globals
06:21:45 * ski . o O ( implicit parameters )
06:22:18 <EvanR> you can try implicit parameters and i'd be interested to see your reaction
06:23:33 <samhh> no can do, I'm actually using PureScript which is a fixed sort-of Haskell derivative. but they're so similar I can ask for stuff with Haskellers :)
06:23:55 <hyperisco> Asking PS questions in #haskell tsk tsk
06:24:20 <samhh> heh heh
06:24:34 <EvanR> i feel cheated
06:24:42 <rotaerk> lol
06:24:48 <boxscape> hyperisco thought you meant powershell at first
06:25:04 <samhh>  /evil laugh
06:25:34 <EvanR> did you ask #purescript
06:26:02 <samhh> that'll be my next destination
06:26:36 <samhh> tbf the PS I'm writing is very agnostic between the two, PS is just easier to use with AWS lambdas, and our code is mostly JS/TS so the possibility of interop is handy
06:27:27 <EvanR> all this craziness further drives me toward the "just pass a parameter" 
06:28:08 <EvanR> we know it works, how it works
06:28:17 <EvanR> no hidden fees
06:28:24 <samhh> that's how it is atm, it's working fine. just annoying that most fns are now: myFn x
06:28:37 <EvanR> um.. as opposed to what
06:28:39 <samhh> you know, that itch when you see a pattern and want a magical abstraction
06:28:59 <samhh> there isn't necessarily a better way, but thought I'd ask. I'm still new to haskell/similar
06:29:03 <EvanR> i want no magic in my abstractions
06:29:29 <EvanR> myFn with no arg is not a function... i'd hope this is true in "pure"script
06:29:53 <samhh> nah, I mean there are other args after, but I have to add that extra x everywhere in composition etc
06:30:10 <EvanR> at least you're putting it first?
06:30:16 <EvanR> not last
06:30:16 <samhh> yep
06:30:18 <samhh> for sure
06:30:45 <samhh> I've been writing light fp in JS/TS for ages so at least that much was intuitive
06:32:29 <EvanR> changing <crazy mechanism X> to "pass a parameter" is one of the most common improvements i've made to ruby code
06:33:29 <EvanR> it's not always appreciated but it always fixes issues
06:33:47 <ski> occasionally, one may use locally defined operations, using `x' non-locally
06:37:06 <perrier-jouet> hi all
06:37:33 <perrier-jouet> is it ok to install packages with stack install ?
06:38:00 <Geekingfrog> perrier-jouet, yes ofc
06:40:06 <boxscape> perrier-jouet OTOH, this post says "You almost certainly do not want to use stack install.", so consider if it's really what you want 
06:40:08 <MarcelineVQ> samhh: https://miro.medium.com/max/500/1*gh9POXppzNAgtncJj17K9w.jpeg
06:40:12 <boxscape> https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/
06:40:25 <EvanR> 2018, ancient
06:40:26 <MarcelineVQ> that linked post is accurate
06:40:32 <MarcelineVQ> stack install doesn't install packages. it builds a package, copies any executables that package might happen to have to ~/.local/bin and incidentally makes that package avaailable to the resolver that's currently in scope, either your project's or the global projec.
06:40:46 <MarcelineVQ> If you don't understand resolvers stack install is basically lying to you.
06:40:50 <samhh> MarcelineVQ hahaha
06:41:24 <perrier-jouet> I am confused on the archlinux wiki about static linking 
06:42:04 <perrier-jouet> does someone here uses archlinux ? how did you setup your haskell environement ?
06:43:34 <boxscape> perrier-jouet it's been a while since I've used it but when I did, I didn't do anything special, I just used stack
06:43:42 <MarcelineVQ> if you're wanting to using stack you can basically ignore archlinux's haskell packages. get a stack binary either via stack-bin from the aur or getting a stack binary elsewhere, add ~/.local/bin to your path and run the "stack upgrade" with the stak bin you have
06:45:19 <MarcelineVQ> this'll get the latest bin and put it in ~/.local/bin meaning there's no system-wide install or cleanup to do, if you want to remove it later you just delete that executable and ~/.stack/
06:46:15 <perrier-jouet> is this the way to initialize stack ? stack setup --system-ghc ?
06:46:21 <barrucadu> I've seen a lot of hate online for `stack install` and `cabal install` - but don't they do basically the same thing as `make install`?  Build and copy build artefacts somewhere.
06:46:30 <perrier-jouet> I want packages to be available globaly
06:47:07 <boxscape> why do you want packages to be available globally?
06:47:44 * hackage small-bytearray-builder 0.3.0.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/small-bytearray-builder-0.3.0.0 (andrewthad)
06:47:48 <boxscape> barrucadu yes, but apparently people get confused because something like "npm install" looks similar but does something different
06:48:58 <perrier-jouet> boxscape:I am not ready to create haskell projects just learning and I want to experiment with packages without creating a project, that why I want packages be available globally
06:49:01 <lyxia> perrier-jouet: I am on Arch and I use stack mainly, I also have a ghc-pristine on the side when I just want to use system dependencies.
06:49:26 <MarcelineVQ> perrier-jouet: you should read the stack docs at this point
06:49:47 <MarcelineVQ> barrucadu: stack install only makes the thing you built available for the resolver that's in scope when you ran stack install, which if a person doesn't understand resolvers and projects will cause confusion when that package stops being available all of a sudden
06:50:15 <lyxia> That doesn't sound like a reason for packages to be available globally...
06:50:32 <Boomerang> I would only use stack install / cabal install to install executables, not libraries
06:50:34 <lyxia> I do experiments without creating projects all the time with stack ghc
06:50:45 <MarcelineVQ> *only makes the thing (other than executables) you built available for the resolver that's in scope
06:51:04 <perrier-jouet> lyxia:what is the steps to have a haskell environement ? pacman -S ghc or ghc-static ?
06:51:42 <lyxia> pacman -S stack?
06:51:54 <perrier-jouet> your version of ghc 
06:52:19 <boxscape> perrier-jouet stack will download ghc for you, you don
06:52:24 <boxscape> 't need to install it via pacman
06:52:43 <perrier-jouet> ok
06:52:45 <boxscape> (However, pacman -S stack won't work because stack isn't in the official repository)
06:52:47 <MarcelineVQ> perrier-jouet: you should read the stack docs at this point
06:53:11 <lyxia> boxscape: ah I was afraid that was the case
06:53:13 <perrier-jouet> boxscape: lyxia pacman -S stack-bin ?
06:53:14 <Boomerang> If you want to experiment with Haskell libraries without setting up a project you can do: stack ghc --package some-package
06:53:27 <MarcelineVQ> boxscape: yes it is
06:53:40 <MarcelineVQ> But it'll pull in a bunch of shit so getting a binary is nicer
06:53:40 <boxscape> oh oops
06:53:43 <boxscape> I misread the wiki
06:53:46 <lyxia> perrier-jouet: yeah I got stack-bin
06:54:00 <lyxia> it's also on aur though
06:54:06 <perrier-jouet> then stack install ghc ?
06:54:12 <MarcelineVQ> perrier-jouet: you should read the stack docs at this point
06:54:20 <lyxia> then you read the stack docs
06:55:32 <lyxia> maybe stack setup, I'm not sure.
06:56:52 <boxscape> pretty sure stack install ghc would be wrong
06:57:17 <perrier-jouet>  pwd
06:57:19 <perrier-jouet> /home/perrierjouet/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.5/bin
06:57:55 <perrier-jouet> you said stack install's ghc , 
06:58:06 <perrier-jouet> boxscape: why stack install ghc will be wrong ?
06:58:28 <tdammers> the command "stack install ghc" would be wrong
06:58:37 <tdammers> because GHC itself cannot currently be installed using stack
06:58:41 <tdammers> (or cabal, for that matter)
06:59:07 <perrier-jouet> tdammers:so I install with my package manager 
06:59:11 <perrier-jouet> pacman -S ghc
06:59:15 <tdammers> that is one option, yes
06:59:16 <MarcelineVQ> the fuck
06:59:43 <perrier-jouet> am confused because two minutes a go I was told stack installs ghc
06:59:49 <tdammers> yes, it does
06:59:58 <boxscape> perrier-jouet try stack setup, or ideally read https://docs.haskellstack.org/en/stable/README/
06:59:58 <tdammers> but it does that implicitly, as needed
07:00:22 <tdammers> i.e., it will install its own GHC when you ask it to set up and build a package
07:00:38 <EvanR> something must be wrong with "GHC itself cannot currently be installed using stack"
07:00:57 <MarcelineVQ> I can see how that'd be confusing, "<tdammers> because GHC itself cannot currently be installed using stack" literally means you can't write "stack install ghc" not that stack can't get ghc for you
07:00:58 <tdammers> EvanR: well, GHC cannot be installed as a package using stack
07:01:25 <tdammers> GHC can be installed by stack, as part of the stack setup command (and probably a few others, I've lost track of stack a bit)
07:01:30 <perrier-jouet> the safest bet is pacman -S ghc then stack install packages ?
07:01:49 <boxscape> there's no reason to use pacman -S ghc if you use stack
07:01:51 <merijn> perrier-jouet: Not on Arch, because the Arch GHC is broken
07:02:11 <perrier-jouet> dear lord
07:02:28 <boxscape> perrier-jouet if you run stack upgrade and stack setup you should have ghc installed
07:02:35 <boxscape> IIRC
07:02:56 <merijn> perrier-jouet: As people said before if you install stack and just build with stack it will already install GHC for you so you don't have to ever manually install ghc when using stack
07:03:16 <perrier-jouet> boxscape: merijn stack setup --system-ghc or without system-ghc ?
07:03:25 <merijn> Without system-ghc
07:03:36 <boxscape> after that you can run ghc via the command "stack ghc"
07:04:13 <perrier-jouet> if I put the path I can't use ghc only ?
07:04:42 <boxscape> perrier-jouet you can make an alias in your .bashrc
07:05:26 <perrier-jouet> boxscape:sorry to disturb you why stack ghc instead of only ghc ?
07:06:04 <perrier-jouet> stack ghc or ghc gives me no input files 
07:06:05 <boxscape> perrier-jouet no worries, the reason is that stack might install multiple ghc versions if you have different packages that require different versions, so "stack ghc" will automatically select the correct one
07:06:17 <boxscape> perrier-jouet try "stack ghci" if you want the interactive REPL
07:06:24 <boxscape> that doesn't need input filed
07:06:53 <perrier-jouet> it worked
07:06:54 <boxscape> s/filed/file
07:06:55 <boxscape> good
07:07:26 <Dunce> Hello again 
07:07:33 <boxscape> hi
07:08:07 <perrier-jouet> boxscape: now I can install packages with stack install --system-ghc package ?
07:08:08 <Boomerang> perrier-jouet: Now earlier you were talking about experimenting with library, for example if you want the `text` libary you could do: stack ghci --package text
07:08:57 <boxscape> perrier-jouet Not sure, I've never used stack install for anything. I recommend you do what Boomerang suggested and use "stack ghc --package some-package" if you want to experiment with a package
07:09:11 <perrier-jouet> Boomerang: I want to install the most common and usefull packages to be available for future projects
07:09:21 <MarcelineVQ> That's not hows stack works.
07:09:23 <MarcelineVQ> perrier-jouet: you should read the stack docs at this point
07:09:48 <perrier-jouet> how about cabal-install ?
07:10:05 <Boomerang> Worry about your future project dependencies when you start those projects. Don't install libraries globaly
07:10:29 <boxscape> that copies executables as well, it's not for making packages available, perrier-jouet
07:10:34 <MarcelineVQ> modern cabal is similar, afaik, in that it's project-centric and caches packages between projects
07:11:04 <merijn> MarcelineVQ: Well, main difference is that it also works implicitly, so you don't have to define anything for it
07:11:05 <MarcelineVQ> the thing is packages come in many versions, so just installing common ones especially useful
07:11:25 <boxscape> perrier-jouet typically you specify the dependencies for each project separately and stack will take care of downloading and building them, and making them available to the right projects
07:11:26 <MarcelineVQ> *ones isn't especially useful
07:13:30 <perrier-jouet> boxscape: MarcelineVQ for exemple I want to connect to a postgresql database, if I install hasql it will be available for Project1 Porject2 etc, but you suggest I install hasql for each project ?
07:14:04 <perrier-jouet> MarcelineVQ: thanks a lot now I got it 
07:14:10 <boxscape> perrier-jouet no, each project has a small config file that says that it depends on hasql, and stack will install it once and make it available to all of them
07:14:22 <boxscape> (assuming they all need the same version of hasql)
07:14:30 <MarcelineVQ> whether hasql is available for reach project depends on the resolver the project uses. but if each project specificies that it requires hasql it will automatically get the appropriate version for that project
07:14:45 <perrier-jouet> alright now I got the purpose of stack
07:15:06 <nshepperd2> I find installing packages globally to be very useful
07:15:09 <MarcelineVQ> *whether getting hasql once makes it available for each project depends on the resolvers the projects each use.
07:15:28 <nshepperd2> In that it's more convenient for randomly opening ghci
07:16:36 <MarcelineVQ> nshepperd2: as long as you understand how it works it's not really a big deal but people asking about "stack install foo" aren't, typically, already understanding the stack model
07:16:48 <perrier-jouet> MarcelineVQ: once a packages is installed, if another project needs that package does it mean I will two version of the packages ?
07:17:10 <MarcelineVQ> Only if they require different versions, otherwise it's shared
07:17:34 <MarcelineVQ> different versions as in foo-1.2 vs foo-1.0
07:18:18 <perrier-jouet> nshepperd2:to install globally you do stack install --system-ghc package ?
07:20:30 <nshepperd2> perrier-jouet: "stack build package". And i'd recommend not using --system-ghc
07:22:21 <nshepperd2> (the difference between 'build' and 'install' iirc is that 'install' also puts any programs included in the package into ~/.stack/bin)
07:22:43 <mpickering> How do I understand this error?
07:22:48 <mpickering> https://www.irccloud.com/pastebin/t0qG82jv/
07:23:13 <mpickering> Is this kind of dependent quantification allowed in Haskell?
07:24:08 <boxscape> mpickering I keep getting confused by this but it looks to me like you need visible dependent quantification here, i.e. forall (s :: Stage) ->
07:24:20 <mpickering> Is that in 8.8?
07:24:29 <boxscape> for kinds, yes
07:24:32 <boxscape> I think
07:24:45 <mpickering> What language extension is it?
07:25:29 <boxscape> mpickering ah, actually it's 8.10
07:25:53 <boxscape> mpickering but I think you should be able to omit the kind signature, and ghc can infer it?
07:26:01 <mpickering> errr really?
07:26:02 <mpickering> let's tryu
07:26:07 <mpickering> also, surely not
07:26:47 <boxscape> % data T k (a :: k) -- this is an example of visible dependent quantification that ghc can infer
07:26:47 <yahb> boxscape: ; <interactive>:36:18: error: lexical error at character '\STX'
07:26:51 <boxscape> okay well
07:26:56 <boxscape> didn't work
07:27:30 <mpickering> It seems to have inferred something
07:27:52 <mpickering>  47 data Expr (s :: Stage) (ty :: Ty s) where
07:27:55 <mpickering> That seems to have done something 
07:28:01 <boxscape> try :k Expr?
07:28:11 <mpickering> doesn't compile yet
07:28:13 <boxscape> ah
07:29:15 <mpickering> things seem to get typechecked in a very strange order
07:30:27 <mpickering> ok that worked
07:30:39 <mpickering> https://www.irccloud.com/pastebin/Gj1NtnwH/
07:31:29 <boxscape> I think :k should already show forall s -> syntax
07:31:29 <geekosaur> boxscape, yours didn't work because you cut and pasted with bold which is the \STX
07:31:42 <geekosaur> so that's just before the comment starts and breaks parsing
07:31:43 <boxscape> oh, thanks geekosaur
07:31:52 <mpickering> So is what I wrote the first time somehow different?
07:31:54 <boxscape> % data T k (a :: k)
07:31:54 <yahb> boxscape: 
07:32:00 <boxscape> :k T
07:32:01 <lambdabot> * -> *
07:32:03 <boxscape> % :k T
07:32:03 <yahb> boxscape: T :: forall k -> k -> *
07:32:11 <boxscape> mpickering yeah, you're missing the forall
07:32:35 <mpickering> I don't have 8.109
07:32:38 <mpickering> *8.10
07:32:46 <mpickering> well I do, have lots of copies of it, but I am not using them
07:32:50 <mpickering> I am using 8.8
07:32:53 <boxscape> mpickering indeed, you can't write the kind signature pre-8.10
07:32:57 <boxscape> but ghc can still infer it
07:33:15 <mpickering> well I wrote it, if you see above
07:33:45 <boxscape> this? data Expr (s :: Stage) (ty :: Ty s) where-- :: (s :: Stage) -> Ty s -> Type
07:33:53 <mpickering> If I don't write the type signature then it fails
07:34:17 <mpickering> I can remove the `s :: Stage` signature
07:34:20 <mpickering> but not the second one
07:34:29 <boxscape> mpickering to make sure I'm not completely barking up the wrong tree here can you try :k Expr at this point?
07:34:41 <mpickering> `Expr :: forall (s :: Stage) -> Ty s -> *`
07:35:22 <boxscape> okay, so yeah, I was right, I suppose - If you want to write the kind signature for Expr as a whole rather than for individual parameters, you need visible dependent quantification
07:35:49 <boxscape> Though maybe it's not right to say it can infer it if you still need signatures on individual parameters
07:37:03 <mpickering> thanks for suggesting the other way
07:37:10 <mpickering> I am not used to writing programs like this
07:37:31 <Dunce> ok sorry I had some internet problems.
07:37:50 <niko> /70/10
07:38:18 <Dunce> So I have a huffman Tree structure that I can encode,  I have a snippet that can take the encoding and turn it into a string 
07:38:33 <Dunce> The issue I have realized is my functions are not generic for any encoding
07:38:38 <Dunce> https://gist.githubusercontent.com/FreezeSnail/13ec34d23aef295bbdd1db393fb82379/raw/647803ce4d50d7d773f784cefb9af0d09f6e179d/gistfile1.txt
07:38:43 <Dunce> Thats an example of an encoding
07:40:09 <Dunce> my code to encode spits out a list in this format; [('x',"0"),('y',"10"),('z',"11")]
07:40:43 <Dunce> So what I want to do is somehow make my decoding function's cases be generated based on that output
07:40:50 <Dunce> if that makes sense
07:47:37 <perrier-jouet> some packages can't be installed with stack ?
07:48:06 <perrier-jouet> nshepperd2:to can we mix stack build and cabal build ?
07:48:09 <Boomerang> Which package are you trying to install? Is it on https://www.stackage.org/ ?
07:48:13 <evelyn> perrier-jouet: not all of hackage is in stackage
07:48:16 <dsal> pie__: What can't be installed with stack?
07:48:19 <MarcelineVQ> they can but they need to be added to stack.yaml extra-deps section if they're not within the current resolver you're using
07:48:20 <dsal> er, perrier-jouet
07:48:32 <perrier-jouet> nshepperd2:I wanted to install http://hackage.haskell.org/package/hoopl this
07:48:53 <evelyn> https://www.stackage.org/package/hoopl
07:49:04 <evelyn> it's not in the latest LTS snapshot, that page suggests.
07:49:29 <evelyn> You can [try] adding it to extra-deps but there's no guarantee it will work well or at all
07:49:49 <evelyn> if you add it to your cabal file, stack will tell you how to add it to extra-deps
07:50:05 <perrier-jouet> dsal: nshepperd2 stack build error https://imgur.com/a/Hrn80uU
07:50:45 <boxscape> mpickering btw the actual reason you got the error in the first place is because (->) :: Type -> Type -> Type, whereas in your case the first argument to this operator had kind Stage
07:53:36 <Dunce> Ok I think I need to take each tuple I have, Take out its bit pattern, and then compair that to my bitstring starting from the tail of the touple list and working backwards, then if theres a match, advance the list that much and call the function again.  Does that seem reasonable?
07:53:45 <perrier-jouet> boxscape: https://imgur.com/a/Hrn80uU can you tell me why I have this error please
07:54:17 <boxscape> perrier-jouet since it's an older package you need to tell stack to use an older resolver with an older version of ghc. the syntax for that is "stack ghci --resolver " followed by the resolver. Let me check if I can tell you a resolver to use here
07:54:58 <boxscape> perrier-jouet try "stack ghci --resolver lts-12.26 --package hoopl"
07:55:53 <boxscape> perrier-jouet btw if you click on the link evelyn posted you'll see that it mentions this resolver, so that's where I got it from
07:56:45 <boxscape> perrier-jouet also "resolver" basically means a collection of a particular version of ghc and particular package versions, which all are supposed to work well together, so stack knows which versions to pick
07:57:05 <perrier-jouet> boxscape: when I will want to update all the package install I do how ?
07:57:16 <mpickering> Is there a dependent map type where I can map `Var s a`to `Expr s a` (note the two type parameters)
07:57:35 <boxscape> perrier-jouet What exactly do you mean by install in this context?
07:58:00 <evelyn> boxscape: is it necessarily desirable to use such an old resolver? IMO whether to use the older resolver or pin the version from package may depend on the project
07:58:09 <perrier-jouet> I meant sorry update the builds in the future
07:58:24 <perrier-jouet> thanks all for your time
07:58:42 <boxscape> evelyn that's fair, but it needs to be old enough at least to have base 4.11, so it needs ghc 8.4.4, I believe
07:59:59 <boxscape> perrier-jouet I haven't used globally installed packages but they should be independent from whatever you do when you use "stack --resolver". There's a stack.yaml file somewhere where you can set the global resolver
08:01:46 <lyxia> mpickering: you could use typerep-map to make maps from pairs '(s, a) to maps (Var s a -> Expr s a)
08:02:21 <mpickering> I have a dependent pair though
08:02:30 <mpickering> So I imagine I can't use `(,)`?
08:03:03 <MarcelineVQ> mpickering: seen https://hackage.haskell.org/package/dependent-map-0.3/docs/Data-Dependent-Map.html#t:DMap ? idk if that fits, just in case tho
08:03:08 <lyxia> I guess you'll have to replace that
08:03:59 <mpickering> MarcelineVQ: I am using that for my old single index
08:05:15 <heatsink> Hey, that's just what I wanted a while ago
08:05:24 <lyxia> maybe you can use the type (Var s a) as your dependent pair for indexing
08:05:39 <heatsink> I didn't find it because I searched for "type indexed"
08:06:31 <mpickering> I'm not sure how it would work though.. because I currently have `data Var a = ..` `DMap Var Expr`
08:06:43 <mpickering> so you need to use a tuple, perhaps it just works..
08:06:45 <mpickering> lemme see
08:07:42 <mpickering> tupling these things does add lots more boilerplate everywhere else
08:09:30 <lyxia> data SomeVar t where SomeVar :: Var s a -> SomeVar (Var s a) ; same thing with Expr,  DMap SomeVar SomeExpr...
08:14:27 <Dunce> ok say I have the deffinition matchBitString :: [(a, [Bool])] -> [Bool] -> a
08:16:34 <Dunce> is this right matchBitString ((a, xs):zs) ys = syntax wise
08:17:28 <heatsink> The syntax in the pattern is correct
08:17:50 <mpickering> lyxia: This appears to have worked, thanks
08:22:36 <Dunce> ok 
08:22:42 <z0> i've just implemented foldr and foldl in javascript and foldr outperforms foldl by a _huge_ margin. I wonder why that is
08:22:47 <Dunce> I think theres just one part left
08:23:37 <Dunce> I match a bit String, I just need to recurse and do it again.  I'm not sure how to increment along my bitstring thought the propper ammount of indicies
08:24:56 <c_wraith> z0: well, if foldr is outperforming, it's either a bug or a special case in the function being folded
08:25:25 <c_wraith> z0: in a strict language like javascript, the performance should be basically identical.
08:25:44 <cocreature> it also depends on which data structure you are folding over
08:25:54 <cocreature> arrays, a custom list implementation, …
08:26:35 <heatsink> It may depend on what operator you're using in the fold
08:26:59 <heatsink> If it has performance like linked list append, folding in one direction will be slower
08:28:02 <heatsink> a ++ (b ++ (c ++ d)) is faster than ((a ++ b) ++ c) ++ d
08:28:27 <cocreature> heatsink: note the “in javascript” part of Dunce’s question :)
08:28:54 <heatsink> I noticed.  I just don't know if linked lists are used in javascript
08:32:10 <Dunce> is there an easy way to take the indicies of a list [1,2,3,4,5,..n] and get [1+x, 2+x, ...n] where x is the indicie I want to start the sublist at
08:32:38 <Dunce> or should I jsut do some function y:ys x times and return what I get
08:33:19 <Taneb> :t take -- Is this what you're after, Dunce?
08:33:20 <lambdabot> Int -> [a] -> [a]
08:33:21 <int-e> > drop 3 [1..10] -- not sure what you're asking
08:33:24 <lambdabot>  [4,5,6,7,8,9,10]
08:33:28 <Dunce> no I want the oppisite of take
08:33:29 <Taneb> ^
08:33:34 <Dunce> drop?
08:33:37 <Taneb> Yeah
08:33:41 <Dunce> I think thats what I want
08:33:51 <Taneb> (also, the singular of "indicies" is "index")
08:33:55 <Dunce> Oh yes it was right above take on the wiki sorry 
08:33:56 <int-e> > splitAt 3 [1..10] -- drop and take combined
08:33:58 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
08:34:10 <Dunce> drop is what I need thank you
08:40:57 <Dunce> I think I'm very close to sloving thins
08:41:00 <Dunce> thanks as always
08:42:20 <orthogonality> any tower of hanoi examples in haskell?
08:43:45 <lavalike> there's one on the wiki
08:44:26 <orthogonality> ooooooooh
08:44:45 <lavalike> I can't find it!! I'm sure there is it is an example somewhere...
08:44:53 <orthogonality> yeah I cannot fin dit
08:44:55 <orthogonality> find it*
08:45:11 <lavalike> in the meanwhile https://rosettacode.org/wiki/Towers_of_Hanoi#Haskell
08:46:04 <lavalike> here https://wiki.haskell.org/Common_Misunderstandings#Iterating_Over_a_List
08:46:15 <lavalike> it's not what I remembered tho, maybe it was deleted, or maybe I was thinking sudoku
08:47:17 <orthogonality> ty
08:58:44 * hackage unagi-chan 0.4.1.3 - Fast concurrent queues with a Chan-like API, and more  https://hackage.haskell.org/package/unagi-chan-0.4.1.3 (BrandonSimmons)
09:05:09 <evelyn> I feel like they might have benefitted from showing us what they'd done already
09:44:57 <dignissimus> I made a programme to generate the collatz sequence for a number, how could I improve it? https://paste.debian.net/1107740/
09:46:45 * hackage agum 2.8 - Unification and Matching in an Abelian Group  https://hackage.haskell.org/package/agum-2.8 (JohnRamsdell)
09:47:44 * hackage cmu 1.12 - Unification in a Commutative Monoid  https://hackage.haskell.org/package/cmu-1.12 (JohnRamsdell)
10:00:14 * hackage language-ats 1.7.6.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.6.0 (vmchale)
10:04:35 <lyxia> dignissimus: it would be more modular to produce an infinite list and use 'take'
10:05:10 <lyxia> oh wait no that's not what it is doing
10:05:29 <lyxia> you can use takeWhile though
10:05:43 <dsal> I think I'd do the arg handling a bit differently.
10:07:49 <lyxia> dignissimus:   intercalate ", " $ (map show . collatzSequence) number   is   (intercalate ", " . map show . collatzSequence) number
10:08:06 <dsal> I don't exactly know what number type type is being used here.
10:08:56 <dsal> You can do something like      args <- traverse maybeRead <$> getArgs
10:09:32 <dsal> But you might need to specify the type.  That would give you a   Maybe [WhateverType]
10:10:26 <dsal> Then you could, you know,   (fmap.fmap) collatzSequence args
10:10:32 <dsal> (does fmap.fmap have a name?)
10:12:09 <lyxia> nope, that's its name.
10:12:15 <dsal> i.e., it's pretty easy to get rid of the nested cases.  One by just allowing an arbitrary number of arguments and the other by just using the functor.  I guess you could also use maybe.
10:13:15 <lyxia> if you want good error messages you have to go through the layers anyway, so the functor doesn't really help much.
10:15:05 <dsal> readEither almost slightly helps.
10:15:47 <dsal> It really doesn't.  That's unfortunate.
10:17:26 <dsal> If you really want to make sure there's exactly one argument, you could    `args <- map readMaybe <$> getArgs`   and then use when to fail.  That'd be clearer, and you could use stderr.
10:20:24 <bugblebudabey> if I want to add a type constraint to a record in a data declaration, how would I go about that?
10:21:37 <geekosaur> you don't, generally, unless it's a GADT. you expose the type in the data declaration and constrain it in the functions where it's used, normally
10:21:44 * hackage lens-regex-pcre 1.0.0.1 - A lensy interface to regular expressions  https://hackage.haskell.org/package/lens-regex-pcre-1.0.0.1 (ChrisPenner)
10:28:24 <dsal> Why is Alternative Applicative?
10:29:49 <geekosaur> because it's the Applicative induced by a Monoid, iirc?
10:30:23 <geekosaur> Typeclassopedia may be instructive here
10:30:46 <ski> example of a type that you'd like to be `Alternative', but which isn't idiomatic ?
10:32:38 <dsal> I guess I want Alt, but I built something kind of like Maybe and was using <|> to choose between two things .  Alternative itself is OK, there's a sensible empty, but Applicative was weird because I didn't see myself putting a function in this particular thing.
10:33:04 <dsal> It's not impossible, it's just weird things to think about when I really just want to be able to do <|>
10:33:23 <ski> how about `liftA2', could you see yourself using that ?
10:34:14 * hackage shake-ats 1.10.2.3 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.10.2.3 (vmchale)
10:35:55 <dsal> Hmm...  Maybe.
10:36:25 <phadej> one can think that Applicative is "multiplying", and Alternative is "adding"; more things are applicatives, than alternatives, thus they hierarchy is that way Applicative => Alternative
10:36:46 <phadej> if they weren't connected, it would be a mess
10:37:06 <phadej> but yes, there are situations where this setup is non-optimal
10:38:47 <dsal> Data.Functor.Alt from semigroupoids seems closer to what I want.  Maybe Alternative is too large.
10:40:02 <phadej> I have written one thing which is Applicative + Alt, but not Applicative yes. (it was a parser, which "cannot" fail)
10:41:34 <phadej> quotes because it can actually, but you couldn't say "this or fail", you had to say just "this"
10:42:02 <phadej> which helped generating better failure-case diagnostics
10:42:07 <phadej> but that's somewhat obscure
10:42:22 <phadej> but maybe all Alt-use cases are, I don't know :P
10:48:23 <dignissimus> My code now looks like this, I'm not entirely sure how I should make the sequence generater return an infinite list https://paste.debian.net/hidden/df957af2/
10:48:47 <cocreature> is the use of existial datatypes (or rankntypes if you change the encoding) essential for free applicatives or is there a formulation that does not rely on them?
10:50:57 <dsal> dignissimus: That do on line 16 isn't 'do'ing anything.  :)
10:52:07 <dsal> Though you could use it to get the prog name and do the particular error message in there to avoid the distraction of doing it at the top when it isn't typically needed.
10:52:54 <dsal> dignissimus: Generating an infinite list is pretty easy.  You're basically doing it already.
10:53:44 <dmwit> dignissimus: I guess something like `collatzSequence n | n < 1 = error "..." | otherwise = iterate collatzFunction n`.
10:53:52 <dmwit> dignissimus: I'm not really sure that's better, though.
10:54:12 <dmwit> dignissimus: Since presumably then you'll want some top-level thing that cuts it off at 1 anyway.
10:56:08 <dmwit> dignissimus: For argument handling, consider `args <- map readMaybe <$> getArgs; case args of [Just number] -> (putStrLn ...) number; [_] -> exitWithError "Invalid number"; _ -> exitWithError usageError`. I think this is more explicit, and finding ways to avoid length and (!!) is a good habit to be in.
10:57:19 <phadej> cocreature: I think so
10:57:43 <phadej> cocreature: i.e. I haven't seen an encoding without existentials
10:59:29 <cocreature> phadej: is there some deep insight as to why existentials are necessary here or am I looking for something that just doesn’t exist (tbf, I’m not even sure what I’m looking for :))
11:00:22 <phadej> cocreature: I don't if it's deep or no, but for Compose (Monad) you don't need existential, but for Day (Applicative) you do, and I don't think there's way around that
11:01:07 <cocreature> phadej: ah that sounds useful and gives me something to think about, thanks!
11:02:01 <phadej> (IIRC all variants of Day need existential)
11:08:14 <dignissimus> The code looks like this now: https://paste.debian.net/1107763/
11:15:44 * hackage ghc-source-gen 0.3.0.0 - Constructs Haskell syntax trees for the GHC API.  https://hackage.haskell.org/package/ghc-source-gen-0.3.0.0 (JudahJacobson)
11:25:41 <dmwit> dignissimus: Looks nice!
11:26:45 <dmwit> dignissimus: Oh, hey, did you know about System.Exit.die?
11:26:59 <dmwit> It's newish, so maybe not available in the GHC you have, not sure.
11:27:05 <dmwit> But it does just what your exitWithError does.
11:50:22 <sicklorkin> ... and then there's error
11:56:33 <kronicmage30> hey folks, anyone here have epxerience setting up hie?i've gotten it working for the most part, but i'm getting a wierd thing on some haskell files where ghc and ghcid compile it just fine, but hie complains about missing importsI installed the module in question using pacman (on arch linux), but I installed hie from source - this is probably the
11:56:33 <kronicmage30> causeanyone know how I can resolve this?
11:56:51 <kronicmage30> oops sorry my newlines died somehow
11:57:12 <EvanR> sicklorkin: though error is not an IO action and so doesn't automatically do what die does without extra help
11:58:25 <crestfallen> https://termbin.com/d7bp  hi I'm looking at the bit at the end about the forgetful functor. any explanation appreciated..
11:59:33 <crestfallen> it says the monoid category is projected down to earth: set : monoid -> U(m)
12:00:09 <crestfallen> in advance this is a bartosz milewski lecture
12:00:45 <EvanR> which part is not clear?
12:03:40 <crestfallen> the whole section starting at 'But we need...' I mean, any abstract algebraic structure needs to start with a set, so I'm wondering why he presents it that way and how it is expressed in haskell
12:04:19 <crestfallen> "project to a down to earth set'   ?
12:04:27 <crestfallen> sorry projected
12:05:27 <EvanR> U is a functor
12:06:01 <EvanR> it maps any monoid to the underlying set of the monoid
12:08:22 <EvanR> it maps monoid homomorphisms to just functions between U(m1) and U(m2)
12:09:40 <crestfallen> ok thank you so he is just reiterated the above into notational form EvanR 
12:09:52 <crestfallen> the above of the paste
12:10:02 <crestfallen> reiterating
12:11:39 <crestfallen> so that is just whiteboard notation, but can you see that in a type signature or instance declaration?
12:11:56 <EvanR> see what
12:13:13 <crestfallen> so the set in a type signature would be in the type constraint?
12:13:40 <EvanR> from what is given here there is no haskell
12:14:21 <crestfallen> right, so generally the set is implicit in the type. a type is a set in all cases, right?
12:14:29 <EvanR> no
12:14:55 <EvanR> but in the case of category Mon you are told that each monoid is built on some set
12:15:04 <EvanR> so it's trivial to extract it
12:21:09 <crestfallen> so the set in CT is just a point in the diagram. we are only concerned with the homomorphisms that indicate what the set is like, in the parlance of CT EvanR I suppose
12:21:43 <EvanR> points in a diagram are objects
12:22:02 <dmwit> This paragraph seems confused and/or backwards. The forgetful functor from monoids to sets is not used to solve the problem of "we need a set to define a monoid".
12:22:19 <EvanR> yep i feel like there is more text not shown
12:22:47 <crestfallen> kindly help me rewrite it. also if you could illustrate what you mean by extract
12:23:03 <EvanR> you wrote this based on a video lecture?
12:23:11 <crestfallen> those are my transcribed notes, yes
12:23:19 <EvanR> that explains a few things
12:23:46 <EvanR> "explain my notes to me" 
12:24:47 <crestfallen> well, yeah. I was trying to get the lecture and trying to write good notes
12:25:17 <EvanR> crestfallen: as simple as something like, if a monoid is a tuple like (m,e,+,law1,law2) then U (m,e,+,law1,law2) = m
12:25:31 <EvanR> and U f = f
12:26:41 <crestfallen> ok yeah, law1,law2 are the 2 monoid laws
12:27:01 <EvanR> well evidence that m e and + satisfy laws
12:30:42 <EvanR> "to have a monoid you have to have a set" is a reason why the forgetful functor makes sense
12:30:48 <EvanR> at least
12:32:08 <crestfallen> its name is curious. is it obvious why its forgetful?
12:32:32 <EvanR> it's obviously forgetting 4 things in the process
12:32:42 <EvanR> of mapping the objects
12:32:53 <EvanR> it's also forgetting aspects of the homomorphism
12:33:11 <EvanR> the fact that its a monoid homomorphism and not just a random function
12:34:15 <dmwit> U (f, proofId, proofMappend) = f -- might be more explicit
12:34:34 <EvanR> yeah
12:35:42 <trcc> If there is a wai expert out there, I could use some help on wai-logger as wai-middleware: https://stackoverflow.com/questions/58429399/wai-logger-filelogspec-as-scotty-middleware-reporting-openfile-resource-busy-f
12:35:44 <EvanR> a total of 6 things are being forgetted
12:35:52 <crestfallen> right, so generally in CT if you look at a morphism, you can see that the set contains elements that are mappend-able, and that are unaltered by identity
12:36:10 <crestfallen> I mean the monoid is mappend-able
12:36:17 <crestfallen> the monoid case
12:37:09 <crestfallen> so i.e. you can guess what elements are in the set
12:37:26 <crestfallen> what type of elements
12:37:48 <sicklorkin> trcc: make sure you havn't accidentally opened the logger twice
12:38:08 <sicklorkin> s/opened/started.. you can tonly have one reference to the logger
12:38:49 <trcc> sicklorkin: will take another look, sec
12:41:04 <trcc> Does not seem to be the case. I have added how I use it to https://stackoverflow.com/questions/58429399/wai-logger-filelogspec-as-scotty-middleware-reporting-openfile-resource-busy-f
12:41:46 <sicklorkin> can you pass in the logger?
12:42:03 <trcc> so initialize it before scotty 3000 and pass it in?
12:42:07 <sicklorkin> yes..
12:42:13 <trcc> I could definitely try
12:42:31 <sicklorkin> that's what I ended up having to do - had similar issues in my testing framwork
12:45:57 <crestfallen> dmwit, could you show me how to rewrite the last part, where you say it is backwards, etc?
12:46:35 <crestfallen> so at least in the future I have a chance ..
12:46:41 <trcc> oh god sicklorkin you are brilliant! 
12:47:15 <trcc> Can you post it as answer on stackoverflow? Otherwise i'll do it...
12:48:47 <sicklorkin> trcc: my hands are tied, please go ahead
12:49:01 <trcc> you are pretty good writing with your tongue then :P
12:49:28 <sicklorkin> ;)
12:53:23 <EvanR> brilliantlorkin
12:53:29 <MarcelineVQ> p. sick
12:57:18 <dignissimus> I've noticed that when lists are defined over multiple lines, the commas go at the start of lines, is this convention? If so why/where did it come from and how come other languages have come to do lay things out differently?
13:10:15 <trcc> Is there some particular way to execute a binary file from shell instead of bash? I keep getting file not found when using sh
13:10:33 <trcc> hmm no
13:11:57 <MarcelineVQ> dignissimus: just some people's preference, some people say it makes for cleaner git diff's but I don't know really
13:12:16 <MarcelineVQ> I just happen to like to line up the [ and ,
13:12:24 <evelyn> trcc: you may need to make the file executable.
13:13:32 <trcc> evelyn: it is really weird. I am trying to use it in a docker container, and here is ls -Al from the docker container: -rwxr-xr-x    1 root     root      14605792 Oct 17 19:59 HsBeFMI-exe. Yet when I run it with "    /bin/sh -c './application/HsBeFMI-exe'" it states file not found 
13:14:38 <evelyn> I would use the full path
13:15:33 <trcc> same thing
13:16:27 <trcc> maybe alpine docker image is too basic
13:18:05 <wildtrees> trcc is /bin/sh available? like is that the correct path to sh and is it in your $PATH? 
13:18:23 <trcc> wildtrees: it is in the docker container yes
13:19:48 <pikajude> `ldd application/HsBeFMI-exe` and check if it's referencing an ld that doesn't exist
13:19:54 <pikajude> that's the other thing that can happen
13:21:03 <trcc> ahh pikajude
13:21:13 <trcc> lots of symbols that it cannot find
13:21:29 <pikajude> er maybe you can just run `file` for that actually
13:22:04 <trcc> i.e. Error loading shared library libgmp.so.10: No such file or directory (needed by /application/HsBeFMI-exe)
13:22:06 <trcc> thanks for that
13:30:37 <ba-macadam[m]> Hi, I'm looking for advice from anyone who has set up Haskell Stack in a lab environment. Is there any way to prevent user accounts from downloading their own sandboxed compiler + libraries, and to rather use a central repository? My students have been bumping up against their storage quotas trying to build stack projects.
13:40:03 <z0> i've compared a foldr and foldl implementation in javascript and got surprising results, foldl being _very_ unperformant. first I thought it was due to the lack of TCO but it doesn't seem like it
13:40:36 <z0> is there a reason foldr outperforms foldl in other languages?
13:40:41 <z0> by so much?
13:41:09 <z0> https://jsperf.com/foldr-vs-foldl
13:41:58 <z0> (it might not seem like it but this is really haskell question)
13:43:11 <MarcelineVQ> ba-macadam[m]: no idea there but most of stack's space is from storage of compilers and snapshots in ~/.stack so it may be useful to have their ~/.stack be a symlink to some network location. it might even work out for them to all be using the same remote .stack dir
13:44:09 <jle`> z0: have you uh tried benching it with non-function accumulators like numbers?
13:44:43 <ba-macadam[m]> <MarcelineVQ "ba-macadam: no idea there but mo"> I've been thinking the same thing, but I can't find any documentation or examples of anyone setting up a similar environment.
13:45:32 <lyxia> oh yeah foldl is probably quadratic because it keeps iterating succ x times where x is the accumulator.
13:46:52 <jle`> yeah it this case it might just be something as simple as x + (y + (z + a)) being more or less expensive than ((x + y) + z) + a
13:46:59 <jle`> hence r vs l
13:49:41 <MarcelineVQ> ba-macadam[m]: there's some other options at https://docs.haskellstack.org/en/stable/pantry/ but none of them seem very ergonomic. This might be a good question for the makers since they should have an interest in stack in education. idk the best route to contact them, I guess through fpcomplete since idk if it's proper to make a 'git issue' about it, maybe you could couch it as a feature request
13:50:22 <MarcelineVQ> There is a stack channel but idk if it's active
13:51:56 <MarcelineVQ> #haskell-stack
14:00:58 <kiwi_21> hey all, i'm trying out memory profiling for haskell for the first time and I'm trying to see if the memory usage is "normal", as in no long trails of thunks or memory leaks. would anyone be willing to look at a .ps/.pdf file showing an image of the heap activity to confirm?
14:01:03 <z0> well that wat it. with numbers foldl actually outperforms foldr
14:03:16 <kiwi_21> Uploaded file: https://uploads.kiwiirc.com/files/e4ca9e417bf098b4b08eeb416fe65ee6/Screen%20Shot%202019-10-17%20at%205.02.32%20PM.png
14:03:33 <EvanR> z0: foldl not prime?
14:03:36 <kiwi_21> was able to do a png instead
14:04:03 <z0> EvanR: javascript is not lazy
14:04:47 <EvanR> er, foldl in an eager language would amount to a straight loop accumulation
14:04:57 <pikajude> you can make it lazy if you wrap everything in function(){} :D
14:05:10 <EvanR> and foldr would be a big recursion stack
14:05:19 <EvanR> so it seems clear foldl would win
14:06:00 <z0> yeah i guess
14:06:07 <EvanR> and that foldl corresponds to foldl' in haskell
14:07:02 <z0> well, while i'm at it why not implement a lazy foldl
14:07:08 <z0> brb with results
14:07:16 <EvanR> it's not obvious to me whether foldr or foldl wins in haskell :) (for doing sums i guess)
14:07:44 * hackage esqueleto 3.1.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.1.1 (parsonsmatt)
14:09:51 <pertl> what do real haskellers think of purescript?
14:10:24 <phadej> are there real haskellers? :)
14:10:46 <pertl> "Maybe"
14:11:31 <EvanR> what do pure haskellers think of realscript
14:11:38 <phadej> :)
14:12:02 <phadej> my friend is miserable because purescript isn't non-strict
14:12:33 <phadej> but otoh, he's happy because there are row-types
14:12:44 <phadej> so "dunno"
14:13:08 <pertl> so no infinite streams :-(
14:13:13 <z0> that's one argument too many for a pure something
14:13:53 <EvanR> it means you have to implement thunks using  () -> wrapper
14:14:05 <EvanR> which is so gross at this point, using haskell so long
14:14:06 <edmundnoble> Yeah I definitely hate strictness
14:14:28 <edmundnoble> Also don't have a good impression of the purescript optimizer
14:14:51 <paf31_> There’s no such thing as the purescript optimizer :)
14:15:03 <edmundnoble> :D
14:16:22 <paf31_> Strictness can definitely be a pain in some cases but the lazy list library does a decent job with infinite streams and you rarely need to bother manually thunking things
14:16:37 <paf31_> Unless you’re doing explicit value recursion
14:17:42 <paf31_> But if you want lazy fp for the web, use ghcjs instead
14:18:09 <pertl> never heard about it, thanks
14:19:48 <jle`> z0: (strict) foldl should be faster with than foldr in the non-lazy situation i think
14:19:57 <jle`> non-lazy as in the containers
14:20:24 <jle`> strict as in accumulator
14:23:09 <lyxia> Is purescript somehow lighter than GHCJS
14:23:26 <lyxia> that's the feeling I get but I never tried GHCJS
14:26:31 <edmundnoble> Yes, there's no runtime IIRC
14:26:40 <edmundnoble> Though as paf31_ said, there's also no optimizer
14:26:49 <c_wraith> yes, it doesn't need to map haskell semantics in javascript.  It's javascript semantics with a reasonable type system
14:29:59 <z0> jle': foldl is barely faster
14:30:49 <EvanR> still we're talking about js
14:31:04 <z0> lol yeah sorry my fault
14:32:48 <z0> back to hs, is it me or :set +s in ghci takes into account the time it takes to print to the terminal?
14:33:13 <wildtrees> I saw a trick like this in an Oleg paper, newtype Wrapped = Wrapped (forall a. Show a => a) , but how can I show a wrapped if I standalone derived its show instance in ghci and also how can I wrap a string? 
14:33:27 <EvanR> normally the printing is interleaved with the crunching
14:34:28 <EvanR> so i wonder what sort of time metric can decomplect the two
14:36:35 <shyguy> hi, IT people :)
14:38:44 <z0> EvanR: well my problem was that one test case printed "lazily" and the other has to finish calculating the whole thing before printing. I remember noticing it because they all took roughly the same ammount of time, but it was due to the printing
14:40:44 <EvanR> right
14:42:41 <z0> what do we use these days to quickly benchmark interpreted haskell programs?
14:43:17 <z0> isnt there a convenient tool like hsperf?
14:43:29 <boj> not sure about interpreted, but criterion is a nice library
14:45:07 <c_wraith> if you want very rough numbers that don't represent what optimizations give you, you can use ":set +s" in ghci
14:46:04 <c_wraith> But don't underestimate what you can get from optimizations.  It can be a 1000x speedup on one function, and also a 1% speedup on another.
14:46:25 <c_wraith> so benchmarking interpreted code isn't a great way to judge compiled performance
14:46:55 <z0> c_wraith: yeah I guess it's pretty useless
14:53:32 <Nevoic> Hey, I had some complex Haskell code that I wrote: https://pastebin.com/SBjefBNg and I noticed it would probably be prety hard to follow for someone not familiar with my code. I decided to write it up in Python as a reference: https://pastebin.com/nTNtKS1F and figured I might just be missing something that could simply my Haskell.
14:53:59 <Nevoic> I don't think there's anything inherent about Haskell that would make it so my code has to be complex, it just seems to be the library (wreq) returning a Vector Value.
14:54:29 <Nevoic> Also my messages seem grayish on my irc client, are they coming through?
14:54:45 <MarcelineVQ> yes
14:54:57 <Nevoic> cool
14:55:19 <EvanR> yep that haskell code could use some better formatting
14:55:42 <EvanR> mixing <$> and <&> really... really...
14:56:04 <EvanR> you used a where clause, put more in the where clause
14:56:51 <EvanR> is the quasiquoter for string interpolation really necessary
14:57:23 <Nevoic> I made a version that expanded it out in a `do` so I didn't need to `toList . fmap toText <$>`, and instead could pull out the `response` from the second bit. I can write up an alternative version that tries to fix some of these problems, but I'd like to move closer to that Python code, not really towards having 6 or 7 lines of code.
14:57:28 <Nevoic> But I'll give it a go and see how it turns out.
14:57:32 <EvanR> [i|#{base}/get_chats?token=#{token}|] ... esc base ++ "/get_chats?token=" ++ esc token
14:59:22 <EvanR> the python code seems to be just applying 3 functions to the result of the string interpolation
15:00:05 <Dunce> Hello, I'm trying to understand the concept of there being no null right now.  
15:00:14 <Nevoic> Here's an alternative https://pastebin.com/LF3WdTKW
15:00:37 <wildtrees> Dunce are you familar with Maybe (or Either)? 
15:00:43 <Dunce> I have a list of tuples (Char a) and a list of a
15:00:48 <Dunce> Maybe broke everything lol
15:01:20 <EvanR> Nevoic: so is the only real difference the haskell code must also do a conversion, whereas in python you used the list directly
15:01:23 <wildtrees> Char a ? do you have code Dunce? 
15:01:34 <Dunce> basically I want to check each tuple and if one of them matches return the char 
15:01:51 <Dunce> i can link a gist 
15:01:51 <Nevoic> Yeah, since the Haskell (wreq specifically) returns a Vector Value, I can't use it when I expect a [Text].
15:02:06 <siraben> What paper is the polysemy library based on?
15:02:07 <wildtrees> Dunce, yea link the code :) 
15:02:12 <Nevoic> I know sometimes the type system can get pretty intelligent (with say `read` for example) and can infer how to convert a value based on type annotations.
15:02:20 <Dunce> https://gist.githubusercontent.com/FreezeSnail/3a600adab84cf0d67b62978917ac3f54/raw/4ff5fef4b2b429da0d1c60b864eeca526d4febc8/gistfile1.txt
15:02:33 <Nevoic> Is there anything similar with wreq? Where I could pull out a [Text] instead of Vector Value and skip the explicit conversion?
15:02:38 <Dunce> basically my issue is if theres a hanging bit at the end it all goes to hell
15:03:49 <Nevoic> I want to mention I do prefer Haskell over Python, I just used it as a reference since I knew what I wanted to represent could be simply represented in Python from my professional experience doing Python.
15:03:55 <Nevoic> And I was having issues doing it simply in Haskell.
15:04:04 <EvanR> not only that your conversion may fail
15:04:06 <Dunce> actually regardless of any left over bits it breaks
15:04:19 <EvanR> something people don't think about in python
15:04:21 <jle`> wildtrees: the standalone deriving version probably isn't gooing to be very helpful here
15:04:48 <EvanR> (how could conversion fail when you don't have to do any)
15:04:57 <jle`> wildtrees: not sure if you noticed this, but that data type has no possible values other than _|_
15:05:09 <Nevoic> Yeah, I mean that's sort of cool, but all I'm doing in the case of the conversion in Haskell is failing on the pattern matching.
15:05:12 <Dunce> A OOP languge I would just return null and it would be over
15:05:34 <jle`> wildtrees: did you perhaps mean forall a. Show a => Wrapped a ?
15:05:34 <Dunce> tbh I think this whole thing is moot since I had to constrain my method signature and idk if I'm allowed to do that
15:05:40 <Nevoic> I could add more code I suppose to not fail, but I could also try/except the Python code for failures (although those semantics are much more limited to be fair).
15:05:49 <wildtrees> jle`, I did not notice that! , though I did get a wrapper for the show function working 
15:06:07 <wildtrees> no the forall was wrapped in something like that in the Oleg paper on tagless final
15:06:30 <wildtrees> Dunce, if you need it to fail return a (Maybe YourOldReturnType here) 
15:06:37 <wildtrees> and wrap the correct answer with Just 
15:06:51 <wildtrees> and no answer or failure just pass back Nothing 
15:06:56 <EvanR> Nevoic: yeah i'm saying waiting for patterns to fail is not great in production
15:07:39 <Dunce> what do you mean by just
15:07:51 <MarcelineVQ> :t Just
15:07:53 <lambdabot> a -> Maybe a
15:07:54 <EvanR> Nevoic: this code seems to fit into the "parser" pattern where the input is raw json and the output is ultimately Either Problem MyThing
15:08:05 <Dunce> do I need just
15:08:06 <Nevoic> Yeah I'm not disagreeing with you, but all I would really be doing is wrapping this value in a maybe and failing on the GUI when it's already failing to the extent I want it to if the API isn't doing what I expect.
15:08:10 <EvanR> which would benefit from an Applicative interface rather than raw programming like this
15:08:34 <EvanR> actions like, get from field, convert, 
15:08:39 <EvanR> all of which could fail
15:09:10 <Nevoic> I was kind of pushed towards lenses/wreq for this type of programming. Do you disagree with this?
15:09:46 <Nevoic> (mainly wreq actually but they heavily use lenses)
15:09:49 <EvanR> not really talking about the wreq part which consists entirely of "get" here.. heh
15:10:05 <EvanR> but you may be able to do what i said with more lens fu
15:10:09 <Nevoic> No, wreq also has to do with the `(^. responseBody . key "data" .  _Array).
15:10:16 <Nevoic> At least all the wreq tutorials have that type of code.
15:10:18 <EvanR> these look like just lenses
15:10:36 <EvanR> prisms?
15:10:50 <Nevoic> `responseBody` is a wreq lens.
15:11:03 <EvanR> sure
15:11:11 <Nevoic> `key`/`_Array are just more general lenses.
15:11:12 <EvanR> where ever they come from... 
15:11:44 <EvanR> you may be able to do the rest of the work there with more lenses
15:12:09 <Nevoic> Okay. I haven't found any comprehensive source on how to discover these lenses, other than by word of mouth.
15:12:23 <Nevoic> I don't really know what types to search on Hoogle because I'm not familiar enough with lenses yet.
15:12:31 <EvanR> when in doubt, write your own :)
15:12:46 <Nevoic> That's what I did, except I didn't write a lens because I have no idea how to.
15:12:48 <EvanR> put them somewhere, refactor your code, then don't tell anyone about the support code
15:12:58 <EvanR> you look like a genius
15:13:14 <Nevoic> What?
15:13:26 <Nevoic> I can't tell if that's just a sarcastic insult because I'm coming off as retarded or something or what lol
15:13:33 <EvanR> no
15:14:05 <Dunce> I feel like I was so close but in reality completely wrong rn
15:14:07 <Dunce> https://gist.githubusercontent.com/FreezeSnail/3a600adab84cf0d67b62978917ac3f54/raw/e5701b9fcc556c3b46d6ea2351d992064bf43e75/gistfile1.txt
15:14:11 <Dunce> thats the whole thing
15:14:16 <MarcelineVQ> *you will look like genius
15:14:21 <EvanR> the remaining two operations in your latest paste bit is to do a conversion to Text and a conversion from Vector to List, these can be done with more lenses. Somehow
15:14:24 <Dunce> I think its too invovled to talk about the parts individually at this point
15:14:47 <EvanR> do them and you won't need to break stride in your dot chain
15:14:53 <Nevoic> I mean I can't imagine a vector to list conversion being much simpler than `toList`.
15:15:02 <EvanR> well right
15:15:05 <Nevoic> Even if I build my own custom lens (which at best is an entire line of code by itself)
15:15:06 <EvanR> it's just not in your chain
15:15:29 <Nevoic> My chain is a path down a json structure, I don't want to muddy that with more type conversions (unless it's instead of `_Array`.
15:15:50 <EvanR> conversions and lookups (that may or may not fail) is all your doing here
15:16:08 <EvanR> the toText thing ought to be a prism
15:16:14 <EvanR> at least
15:16:30 <Nevoic> Sadly I wasn't born with the knowledge of how to build a `∀ t. AsValue t => Prism' t ([Value])` instead of a `∀t. AsValue t => Prism' t (Vector Value)` (_Array)
15:16:59 <EvanR> i suspect that expands to something as simple as a function involving Maybe
15:17:13 <EvanR> which might already be provided?
15:17:39 <Nevoic> Well I know what `_Array` already "expands" into in my code. It's `(Vector Value -> Const (Vector Value) (Vector Value)) -> Value -> Const (Vector Value) Value`
15:17:42 <Nevoic> Which isn't any simpler imo
15:17:57 <Nevoic> But it might just be because I'm stupid tbh.
15:17:59 <EvanR> well. we are talking about the code rather than the types
15:18:10 <EvanR> try to get nice code at the expense of types
15:18:14 * hackage mmsyn3 0.1.1.0 - A small library to deal with executable endings  https://hackage.haskell.org/package/mmsyn3-0.1.1.0 (OleksandrZhabenko)
15:18:53 <EvanR> you can also revolt and rewrite this all without any lens
15:20:00 <EvanR> but itll be like 3 lines not 1
15:20:02 <Nevoic> I'm not really looking to have a philosophical battle on what the right way is to do this, or to build an entirely new system of parsing json structure. I was hoping someone would look at my code and say something like "oh instead of doing _Array + toList .fmap toChat at the start you can just do ` _List` and then explicitly annotate the type and t
15:20:02 <Nevoic> he lens will determine the conversion).
15:20:25 <Nevoic> So far all that's been achieved is a slight increase in readability at the cost of going from 2 lines of code to 7.
15:20:35 <Nevoic> And we're talking about expanding the code even further.
15:20:55 <sicklorkin> EvanR: I'm not the only one to use error in place of die etc.. checkout mmsyn3 hackage package just a few lines above ;)
15:21:00 <Nevoic> When I apply these learnings to the other similar 5 functions, my 10 lines of code will probably turn into ~120 lines.
15:21:02 <Nevoic> At the rate we're going.
15:21:15 <EvanR> not if you factor out the common conversions
15:21:24 <Nevoic> I mean lets just say 60 lines then.
15:21:27 <Nevoic> Still not sure it's worth it.
15:23:44 * hackage git-annex 7.20191017 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20191017 (JoeyHess)
15:24:07 <EvanR> well, getChats = toList . fmap toText <$> (get [i|#{base}/get_chats?token=#{token}|] <&> (^. responseBody . key "data" . _Array)) where toText (String s) = s it is then...
15:24:08 <Dunce> ok, Is there an easy way to find where my infinite loop is in ghci lol
15:24:38 <sicklorkin> Dunce: profilign with -xc.. or if you use stack then --trace
15:25:26 <Dunce> um
15:25:29 <Nevoic> I mean that's obviously not ideal, which is why I asked in the first place. But we've already expanded it into 7 lines of code, and I know you mentioned expanding it further (1 -> 3) which would result in 9 lines. So we've practically increased the code size by a factor of 3 or 4 while the alternative I showed in another language has half as many c
15:25:29 <Nevoic> haracters as the original.
15:25:33 <Dunce> sorry im not sure what you mean 
15:25:47 <EvanR> Nevoic: on the subject of toList adding noise, function programming common sense would suggest changing whatever function returned a Vector to return a list... since you'll be using it a lot
15:25:48 <Dunce> what is stack in this context
15:25:56 <EvanR> functional programming*
15:26:05 <sicklorkin> stack is a build framework
15:26:17 <Dunce> so instead of ghci I use stack ghci --trace?
15:26:31 <EvanR> is _Array causing the introduction of a Vector o
15:26:36 <Nevoic> Yup.
15:26:42 <Nevoic> And I didn't build that function.
15:26:43 <EvanR> so use a different conversion?
15:27:09 <Nevoic> `Data-Aeson-Lens` uses Array, not `[]`.
15:27:17 <Nevoic> Array being a Vector.
15:27:31 <sicklorkin> Dunce: I don't rememer what the opts are but yes, ghci will def have something to produce a backtrace
15:27:34 <EvanR> i mean... you can compose toList with that lens and viola...
15:27:40 <EvanR> no more Vector in your main code
15:28:21 <Dunce> ok I need to install stack seperately
15:28:24 <Dunce> ill report back
15:28:26 <Nevoic> I wish it was that simple, but `_Array` can't be composed because it doesn't take a value, it just returns a Prism.
15:28:34 <Nevoic> At least I have no idea how to compose that value.
15:28:43 <EvanR> i don't either but i'm sure its possible
15:28:55 <Nevoic> my understanding of function composition is `(b -> c) -> (a -> b) -> (a -> c)`
15:28:57 <EvanR> and if its an entire line of code, you just have to do it somewhere once
15:29:08 <Nevoic> Yeah, but do what? Neither of us know.
15:29:11 <sicklorkin> Dunce: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#stack-traces-in-ghci
15:29:13 <Nevoic> So I don't see how that helps.
15:29:14 <EvanR> try Category composition?
15:29:22 <EvanR> it works on more than just functions
15:29:31 <Nevoic> my composition is already generalized to category composition because I'm using a custom prelude.
15:29:34 <Nevoic> I don't think it works for this though.
15:29:50 <Dunce> I use arch so I just have to install the package lol
15:29:53 <EvanR> i could look up specifics for all the ideas i've had
15:29:57 <EvanR> or you could
15:30:12 <EvanR> or we both could
15:30:27 <EvanR> but it'd be silly for neither of us to do it
15:30:57 <Dunce> oh sorry I thought that was just an install guide thabnks
15:31:55 <Nevoic> `toList . _Array` does produce a valid type but it's not usable in place of `_Array`.
15:32:08 <EvanR> yah i didn't think it'd be that simple
15:32:36 <Nevoic> why? I don't know. "Couldn't match type Vector Value with [Value]", so something about my code requires a Vector, even though I took out the `toList` that converts the vector. I'm `fmapping` but that's generalized over functors so that should be fine.
15:32:37 <EvanR> try fmap toList _Array
15:32:58 <EvanR> or fmap (fmap toList) _Array
15:33:22 <Nevoic> Neither of those type check (the function does but using it doesn't)
15:33:29 <Nevoic> And really is that any more readable than my original?
15:33:33 <Nevoic> `fmap (fmap toList) _Array`?
15:34:22 <EvanR> what i was saying was... you define this version of the _Array lens (called _FriedChicken or whatever you want) that does the exact same thing but returns a list. Because it uses a toList internally. Then you put _FriedChicken throughout your code and that elimiates toList, at least there's that
15:34:34 <EvanR> so doesn't really matter whether it's as ugly as fmap (fmap toList) _Array
15:34:42 <Nevoic> I do want to mention I use this twice, out of 5 times.
15:34:42 <pikajude> so what would a _FriedChicken lens do?
15:34:47 <jle`> wildtrees: yeah, you can write a Show instance for that that would reflect the non-inhabitedness of it
15:34:58 <EvanR> _Array but returns a list
15:35:10 <jle`> wildtrees: instance Show Wrapped where show (Wrapped x) = absurd x
15:35:32 <jle`> wildtrees: absurd from Data.Void, absurd :: Void -> a
15:35:39 <EvanR> if none of this makes sense and it's literally a lifetime maximum of 2 places in the code, nevermind
15:35:49 <Nevoic> I understood the point you were getting at, but neither of us are wizardly enough to know how to use lenses properly enough to construct a Lens that constructs a prism that converts some arbitrary lens path to a List.
15:36:01 <EvanR> point taken
15:36:11 <wildtrees> jle`, would newtype Wrapped = Wrapped (forall a . SomeClassHere a => a)   would that 'a' b uninhabited for all of SomeClassHere , for all typeclasses? 
15:36:23 <jle`> wildtrees: since Void is an instance of Show, then you should be able to use a (forall a. Show a => a) as a Void 
15:36:30 <jle`> wildtrees: it depends on SomeClassHere
15:36:44 <jle`> wildtrees: the main thing is that if any methods of SomeClassHere return a value of type 'a'
15:36:52 <jle`> if it does, then you have non-bottom inhabitants
15:36:58 <wildtrees> jle`, Ahhh 
15:37:08 <jle`> for example newtype Wrapped = Wrapped (forall a. Num a => a)
15:37:22 <jle`> then you can have inhabitants like Wrapped 1, Wrapped 2, etc.
15:37:32 <jle`> or newtype Wrapped = Wrapped (forall a. Monoid a => a)
15:37:34 <Nevoic> Like I'm all for type safety, and pretty much everything Haskell stands for, I'm often in a Python channel talking about how Python is unityped and unsafe and how Haskell can often be more readable, safer, and faster. And yet Haskell definitely has some weak points, or at least some unnecessarily complex bits.
15:38:07 <EvanR> well this particular case is about the look of the code
15:38:08 <wildtrees> jle`, the oleg paper was saying this was some sort of hack in lieu of true "first-class" polymorphism 
15:38:10 <jle`> wildtrees: this has one inhabitant, `Wrapped mempty`.  it technically also has `Wrapped (mempty <> mempty)`, but cause of the monoid laws etc etc
15:38:28 <EvanR> the activity the code is doing is braindead simple
15:38:36 <EvanR> as far as i can tell
15:38:40 <Nevoic> It's not just about look. This is a standardization issue that Haskell has in many areas.
15:38:45 <EvanR> it's just ugly as hell
15:38:49 <jle`> wroathe: hm, i might have to see more of the context to understand
15:38:51 <Nevoic> Since Haskell is very open about what types you can use, people use different types.
15:39:11 <jle`> * wildtrees 
15:39:17 <EvanR> heh the dreaded There's More Than One Way To Do It
15:39:26 <Nevoic> This code is using `String, Text, ByteString.Strict and ByteString.Lazy`. The same Python code would just be using `str`.
15:39:37 <EvanR> it does suck when the way we pick involves lens and we don't know lens
15:39:45 <Nevoic> Similarly, Python is just using arrays, while Haskell has Vector, `[]`, etc.
15:39:45 <EvanR> i've def seen people get bit by that
15:39:47 <sicklorkin> but the types you choose should'nt be a stylistic choice
15:39:54 <jle`> well, it does make sense to have a different type for Text and a different type for ByteString
15:39:59 <jle`> those two are semantically completely different
15:40:02 <jle`> it's String that is weird
15:40:13 <wildtrees> jle`, it was 3/4 the page down on page 10 here http://okmij.org/ftp/tagless-final/course/lecture.pdf 
15:40:14 <EvanR> agreed String sucks
15:40:19 <jle`> i would hope that python has a different type for text and a different type for bytestring
15:40:24 <jle`> ...there would be a loooot of problems if there weren't
15:40:27 <wildtrees> jle`, thank you for your help it is starting to make some sense to me 
15:40:37 <Nevoic> The thing is Python doesn't have OverloadedStrings, so I've *never* come across bytestring.
15:40:37 <EvanR> jle`: small `if' there
15:40:40 <jle`> but then in haskell we have lazy vs strict, which sort of adds an extra complication, yes
15:40:54 <Nevoic> or at least I've never noticed it.
15:41:09 <EvanR> python has one of those overnegineer bytestring + encoding thingies
15:41:29 <Nevoic> The fact that this language has 4 string types that I need to manage + multiple list types can make these kinds of conversions painful.
15:41:38 <jle`> Nevoic: python does -- but you don't use it for strings
15:41:45 <jle`> likewise you aren't really supposed to use ByteString for strings
15:41:49 <jle`> so that's a problem there
15:41:50 <EvanR> i like conversions, at least i know where my performance is going down the drain
15:42:14 <EvanR> the . chain of 4 conversions
15:42:15 <jle`> if a library is using bytestrings to represent text, then they are potentialyl overcomplicating things, yeah
15:42:17 <Nevoic> Haskell is supposedly a high level language though. I'd agree with you if I was writing C code.
15:42:31 <Nevoic> But when I'm making a request to an API I don't want to worry about bytestring -> Text conversions.
15:42:37 <Nevoic> And I never have had to.
15:42:38 <Nevoic> Except in Haskell.
15:42:43 <Nevoic> shrug
15:42:45 <jle`> i think ideally you wouldn't
15:42:53 <jle`> most libraries that expose API shouldn't be giving you raw bytestring or text
15:42:54 <EvanR> i've definitely run into that in ruby, since many APIs deliver broken Text
15:43:00 <jle`> or expecting raw bytestring at least
15:43:07 <Nevoic> Well I've used scotty and wreq, both of which heavily use ByteString and require me to often convert it to Text.
15:43:10 <jle`> you would be sending and receiving ADTs or actual data types
15:43:14 <jle`> ah, whoops
15:43:30 <Nevoic> Maybe I'm just choosing shitty libraries, but my impression was wreq was widely used.
15:43:40 <Nevoic> I'm entirely willing to swap to a library that doesn't use bytestrings and just uses Text.
15:43:40 <pikajude> it is
15:43:46 <Nevoic> I'll rewrite all my code if you guys can point me to one.
15:43:48 <pikajude> don't think there is one, at least for URL requests
15:44:01 <EvanR> i think when your chosen lib is embracing lens, it means you'll need to bite the bullet and learn lens "or else"
15:44:07 <jle`> well, you should *expect* a bytestring if the server is responding with bytestrings
15:44:16 <jle`> for example that server could be sending you an image file or something
15:44:27 <jle`> or some other binary blob
15:44:50 <jle`> so 'converting to text' isn't really text conversion, it's actually parsing a binary blob as text, which is not always a striaghtforward thing
15:45:06 <Nevoic> The library doesn't know at compile time what type the API is going to return?
15:45:20 <pikajude> if it's someone else's API?
15:45:22 <jle`> so i think of bytestring->text no different than, say, bytestring->Image File, etc.
15:45:24 <EvanR> that would require a crystal ball to be actually accurate
15:45:25 <Nevoic> It's my API.
15:45:37 <sicklorkin> servant deal w/this very well
15:45:42 <sicklorkin> *deals*
15:45:50 <pikajude> you can just write your own Response lens that produces a textual Body
15:45:53 <jle`> Nevoic: well, a raw API over the HTTP, if you do'nt know anything about it, you can only talk about the least common denominator
15:45:54 <Nevoic> I never mess with files, I'm just sending json back and forth.
15:45:56 <Nevoic> And yet I have bytestrings.
15:46:01 <Nevoic> I only ever use `get/post`.
15:46:15 <sicklorkin> Nevoir then just send as json
15:46:19 <Nevoic> I do.
15:46:23 <EvanR> after you figure out the ByteString stuff, now you figure out the JSON stuff :)
15:46:24 <Nevoic> the content type at least.
15:46:25 <jle`> Nevoic: right, that's because wreq can't possibly know that your API is sending JSON...because it's meant to work for all HTTP
15:46:27 <EvanR> same issue
15:46:39 <EvanR> really you want to be sending well typed values
15:46:42 <pikajude> are you using HTTP?
15:46:50 <Nevoic> Yes.
15:46:56 <pikajude> then you're using bytestrings
15:47:07 <Nevoic> Okay, well thank God that Haskell is giving me bytestrings then.
15:47:16 <Nevoic> No wonder all my Kotlin/Python code just works when accessing this API.
15:47:24 <Nevoic> I only ever get back their standard string types
15:47:24 <Nevoic> lol
15:47:30 <jle`> Nevoic: 'servant' is a library that abstracts over this well, because it gives you well-typed API accessors that automatically parse the bytestring into the type you expect
15:47:33 <jle`> Int or JSON Value or w/e
15:47:49 <Nevoic> That sounds like what I was looking for earlier.
15:47:51 <Nevoic> I'll check it out, thanks.
15:47:52 <EvanR> yeah. Python gives you a bytestirng too
15:48:00 <EvanR> they just call it a string
15:48:05 <Dunce> is there a way to use a returned value in too places in a function
15:48:07 <jle`> ...does python have a type for text?
15:48:17 <pikajude> it's string
15:48:22 <jle`> does python have a type for binary blobs?
15:48:22 <pikajude> does python not have a bytes type?
15:48:25 <pikajude> i know rust does
15:48:31 <Nevoic> Python is a unityped language, all I know is it gives me back a type that behaves exactly like "potato".
15:48:33 <jle`> Text = text, ByteString = binary blob
15:48:35 <pikajude> right
15:48:40 <Nevoic> You can call it whatever you want but it's behaviorally quite different from haskell.
15:48:40 <pikajude> well you can always go back to python
15:48:41 <wildtrees> Nevoic, I did some not so fancy json api client programming once, I used some off the shelf http client library that wasn't too fancy and a small bit of Aeson I believe to do the json parsing for me 
15:48:43 <Dunce> like fizz = fuzz + fuzz except without calling the function twice
15:48:44 <Nevoic> I don't like PYthon.
15:48:45 <EvanR> in many languages Text = binary blob
15:48:48 <Nevoic> I actually hate Python.
15:48:58 <pikajude> the way haskell is designed doesn't really allow users to conflate text and bytestrings
15:48:59 <pikajude> by design
15:49:08 <Nevoic> Seems like a design flaw.
15:49:09 <Dunce> like let maybe
15:49:18 <Nevoic> Or at least like it's bad for the type of work I do.
15:49:18 <pikajude> haskell doesn't let you dereference null pointers, either
15:49:20 <EvanR> def requires a change in worldview
15:49:22 <pikajude> yeah
15:49:37 <EvanR> but i have definitely had my system crash due to ruby thinking bytestring = text
15:49:37 <jle`> hm, i feel like i would want a different type for binary blob and a different type for text
15:49:40 <pikajude> python is definitely easier to use to whip up quick scripts that move files and stuff
15:49:49 <Nevoic> I don't like thinking about things that are irrelevant to the work I do.
15:49:53 <pikajude> it's just not the kind of thing you want to rely on when your system demands any level of correctness
15:49:53 <Nevoic> Nulls are irrelevant to the work I do.
15:49:55 <Nevoic> So are bytestrings.
15:50:00 <pikajude> nice
15:50:00 <Nevoic> All I care about is receiving text from a server.
15:50:02 <pikajude> that's pretty lucky
15:50:04 <EvanR> badly encoded text is irrelevant to the wor.. oh wait
15:50:08 <pikajude> servers cannot send text, unfortunately, only bytes
15:50:12 <jle`> Nevoic: right, in that case you would have to abstract over wreq
15:50:13 <pikajude> although i am a little out of the loop
15:50:20 <pikajude> why can't you use aeson's decode function? it takes a bytestring input
15:50:28 <pikajude> you said you were transferring json back and forth
15:50:43 <Nevoic> Luckily I'm using a language that's higher level than Assembly, so there can be abstractions that make it so I don't have to think about these pointless details.
15:50:44 <jle`> Nevoic: i think you will have a lot more problems in the long run if you use 'binary blob' as text
15:50:50 <EvanR> pikajude: we're far from the original topic, we were talking about converting json arrays to Vector or list
15:50:54 <pikajude> oh, okay
15:50:58 <sicklorkin> Nevoic: https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
15:50:58 <Nevoic> I know because I've used systems that don't have the problems I'm running into now, even if you want to claim at a theoretical level that all frameworks have this issue.
15:51:00 <pikajude> but there are already instances for that
15:51:03 <jle`> Nevoic: considering the difference between binary blob and well-formatted text *is* a high-level concern, I think
15:51:10 <EvanR> pikajude: i know...
15:51:22 <pikajude> so why would you need to manually convert? you can even use fromJSON on a Value
15:51:25 <jle`> Nevoic: for example you want to be able to do things like: (1) get the first character in a Text, in a reliable way, unless it's empty
15:51:37 <jle`> Nevoic: if you only have a type for "binary blob", this is not possible
15:51:48 <EvanR> pikajude: exhibit B https://pastebin.com/SBjefBNg
15:51:53 <pikajude> sure, but when has anyone ever needed to get the first character of a string?
15:51:55 <jle`> "binary blob", you can't reliably get the first character for a non-empty binary blob
15:52:06 <pikajude> oh yeah, i see EvanR
15:52:17 <jle`> heh, then maybe i can say something more practical: displaying text.
15:52:24 <jle`> you can't reliably 'display as text' a binary blob
15:52:36 <jle`> but you can do it for a type that can only contain well-formatted text
15:52:39 <EvanR> jle`: elixir manages to do exactly this and they love it :)
15:52:49 <EvanR> text = binary blob, and you can print it out
15:52:57 <jle`> so differentiating between 'binary blob' and 'text' ... is a high-level concern, to me
15:53:03 <jle`> becuase there are operations on TExt that i want to expect to work
15:53:11 <pikajude> it's not a big deal if you can guarantee that everyone everywhere is using utf8
15:53:11 <jle`> that can't work if it's just amorphous structureless binary blob
15:53:22 <EvanR> printable characters are displayed as characters, other wise as bytes
15:53:26 <Nevoic> Are you guys honestly convinced that managing the conversion between a "binary blob" and properly formatted text is at the same level of abstraction as printing "hello world"?
15:53:26 <jle`> pikajude: it's a big deal because it could be aribtrary binary, like say, a jpeg file
15:53:29 <pikajude> although that's left as an exercise to the user
15:53:43 <pikajude> well I personally am not since I just got here
15:53:44 <Nevoic> Because if so then I suppose we just have a fundamental philosophical disagreement.
15:53:46 <pikajude> i'm wondering why you don't want to use typeclasses
15:53:56 <jle`> Nevoic: it only matters if you are receiving something from a binary blob channel
15:53:58 <pikajude> or decodeUtf8, or Data.Aeson.decode, or...
15:54:06 <jle`> Nevoic: it wouldn't matter internally if your types are normally correct, and you can hello world your own strings
15:54:09 <pikajude> but i am lacking context of course
15:54:11 <Nevoic> I'm accessing a REST api that I build that only ever returns json.
15:54:19 <Nevoic> built
15:54:19 <pikajude> ok
15:54:23 <pikajude> :t Data.Aeson.decode
15:54:25 <lambdabot> aeson-1.4.4.0:Data.Aeson.Types.FromJSON.FromJSON a => BSLC.ByteString -> Maybe a
15:54:26 <jle`> Nevoic: but if you ever receive input from a channel that binary blobs, then that's something you would have to worry about
15:54:31 <jle`> Nevoic: in that case yeah, wreq is a bit too low level
15:54:34 <Nevoic> Yeah I use `fromJust . decode` already.
15:54:38 <pikajude> neat
15:54:46 <jle`> Nevoic: wreq gives you "binary blob stream" access
15:54:48 <pikajude> can i see the paste then, for clarity?
15:55:04 <jle`> bit if you want "text access", you would need to abstract over its binary blob stream access
15:55:07 <jle`> *but
15:55:12 <jle`> libraries like servant let you do that
15:55:20 <pikajude> i mean, even outside all this, you can just stack the _JSON prism onto the end of your lens
15:55:22 <jle`> they give you "text access", "json value access", "Int/Bool/MyType access"
15:55:26 <pikajude> which will convert to whatever type is relevant for the callsite
15:55:39 <EvanR> there are many ways to stream line this code with lens
15:55:41 <Nevoic> jle`okay that's great to hear, if wreq is too low level for accessing rest APIs that's awesome.
15:55:44 <pikajude> resp ^? responseBody . _JSON :: Maybe MyAwesomeType
15:55:46 <Nevoic> I know you mentioned servant, is that an alternative?
15:55:47 <EvanR> i just couldn't tell Nevoic exactly how
15:55:53 <pikajude> i haven't seen the original code
15:55:56 <jle`> Nevoic: wreq is at the level of receiving binary blobs from rest APIs
15:56:01 <EvanR> pikajude: exhibit B
15:56:03 <pikajude> the one evan pasted doesn't show fromJust decode
15:56:08 <pikajude> so i'm looking for the original one
15:56:09 <jle`> Nevoic: yeah, servant is a good alternative I believe
15:56:13 <EvanR> ah
15:56:15 <Nevoic> https://pastebin.com/SBjefBNg or https://pastebin.com/LF3WdTKW
15:56:20 <pikajude> ok
15:56:22 <Nevoic> pikajude
15:56:24 <pikajude> and you want a string of text
15:56:25 <jle`> it's even better if you have control over both your server and your client
15:56:33 <Nevoic> I want a `[Text].
15:56:37 <Nevoic> Not a `Vector Value`.
15:56:38 <pikajude> yeah, that's what i meant, sorry
15:56:41 <pikajude> ok
15:56:41 <Nevoic> Whic his what _Array` returns.
15:56:49 <pikajude> remove toList . fmap toText <$>
15:56:52 <pikajude> and replace _Array with _JSON
15:56:58 <pikajude> may have to add a type annotation though
15:57:13 <Nevoic> that's fine, in my actual code I do have a type annotation.
15:57:15 <pikajude> ok
15:57:22 <jle`> you can write this in servant with something like...
15:57:38 <pikajude> wreq has fewer dependencies though and it's like 10 extra characters to do the conversion inline
15:57:42 <pikajude> so i would prefer it honestly
15:57:43 <Nevoic> holy shit it type checks.
15:57:49 <EvanR> right
15:57:59 <Nevoic> This is literally exactly what I asked for earlier =o except I thought it would be called `_List` not `_JSON`.
15:58:06 <Nevoic> But I literally articulated exactly what I was hoping to get and this was it
15:58:07 <Nevoic> lol
15:58:10 <Nevoic> thanks
15:58:14 <pikajude> _JSON is a lens that converts a number of different input types to any FromJSON output type
15:58:26 <pikajude> https://hackage.haskell.org/package/lens-aeson-1.0.2/docs/Data-Aeson-Lens.html#v:_JSON
15:58:27 <Nevoic> jle`I'll still check out servant though
15:58:44 <pikajude> anytime you don't want to deal directly with aeson's JSON structure primitives, you should just use that lens
15:58:51 <Nevoic> pikajude okay that's epic, thanks mate.
15:59:10 <EvanR> so wreq wasn't really to blame after all
15:59:22 <pikajude> if wreq actually returned Text instead of ByteString response bodies that would be a serious problem
15:59:50 <EvanR> why?
15:59:54 <jle`> type MyAPI = "get_chats" :> QueryParams "token" Text :> Get '[JSON] ListOfThings
15:59:56 <pikajude> it would have to assume an encoding
16:00:02 <jle`> EvanR: well, it would fail for non-text bytestring
16:00:08 <jle`> EvanR: let's say you wanted to request a jpeg file over an API
16:00:14 <jle`> and it gave you that jpeg file as Text ...
16:00:16 <EvanR> well for the case of json
16:00:24 <EvanR> i think most people think of json as Text
16:00:28 <EvanR> the encoded form
16:00:35 <jle`> yeah, that's why it's a good thing that the raw thing it gives you is ByteString.  and then from there, you can process it however you want
16:00:45 <pikajude> decoding it does the conversion anyway
16:00:52 <jle`> decoding it *is* the conversion
16:00:54 <Nevoic> jle` I don't follow that code. `type` is a keyword in Haskell, but you can't assign a type to a value right? (seems like a dependently typed hting)
16:01:04 <jle`> Nevoic: yeah, in servant, API's are types
16:01:10 <pikajude> :> is a type constructor
16:01:10 <EvanR> does aeson not work at all if you have json in Text form?
16:01:16 <jle`> you can then create request functions from yoru API types
16:01:20 <pikajude> i think it has decodeText or something like that
16:01:23 <EvanR> ah good
16:01:37 <pikajude> but i don't think json is meant to be assumed to be utf-8, i think it depends on the server
16:01:39 <pikajude> or file encoding
16:01:46 <jle`> Nevoic: so if you were to generate request functions from that API, you'd generate a single function, `Text -> IO ListOfThings`, essentially
16:01:50 <EvanR> luckily Text isn't utf8 :) jk
16:01:58 <jle`> Nevoic: which takes a Text token and returns a ListOfThings
16:02:01 <pikajude> aeson doing bytestring to text is utf8 though
16:02:14 <jle`> it would handle the encoding of the text and the parsing of ListOfThings for you
16:02:16 <EvanR> oh it's built in
16:02:24 <pikajude> yeah...
16:02:26 <EvanR> kinda gross
16:02:28 <Nevoic> jle' huh, that seems interesting.
16:02:29 <pikajude> `decode` takes a bytestring
16:02:35 <pikajude> and Text has a FromJSON instance
16:02:45 <pikajude> actually you know what, now that you mention it
16:02:54 <pikajude> json *only* has a text type, to get a bytestring you'd just need a Word8 vector
16:03:04 <pikajude> so that is a bit weird
16:03:08 <EvanR> that's not what i meant
16:03:14 <jle`> Nevoic: for example if i had a type `MyAPI = ("foo" :> QueryParams "p" Int :> Get '[JSON] Bool) :<|> ("bar" :> Get '[JSON] MyVal)
16:03:22 <jle`> Nevoic: servant would provide you with two functions:
16:03:33 <jle`> one of type Int -> IO Bool, and the other of type IO MyVal
16:03:39 <EvanR> like can aeson serialize to Text instead of ByteString, for the whole object
16:03:42 <jle`> (essentially. not exactly IO i think but yeah)
16:03:47 <EvanR> or decode from
16:04:05 <pikajude> there's a module that exports a function to encode to text builder
16:04:08 <jle`> Nevoic: the first one wouild send a request to the "foo" route with parameter "p" to that Int, and the second would send a request to the "bar" route with no parameters
16:04:21 <jle`> and they wouild both expect JSON responses and parse them as Bool and MyVal, respectively
16:04:23 <EvanR> yeah that's the easy direction
16:04:26 <pikajude> doesn't look like there's a decode equivalent of Text though
16:04:30 <EvanR> mmhmm
16:04:35 <pikajude> so you just decode . encodeUtf8
16:04:45 <EvanR> and pay a cost
16:05:01 <pikajude> yeah, might take down the whole company
16:05:29 <pikajude> i wonder if bos could be convinced to add a function to aeson `decodeText` that is defined as `decode . encodeUtf8`
16:05:32 <pikajude> so people would be satisfied :)
16:05:34 <Nevoic> jle` MyVal being a type with a fromJSON instance?
16:05:53 <EvanR> do you mean decodeUtf8
16:06:04 <EvanR> oh
16:06:06 <pikajude> no
16:06:07 <pikajude> sure don't
16:06:12 <jle`> Nevoic: yeah
16:06:13 <EvanR> nvm
16:06:31 <pikajude> i think the performance gains that come from writing the parser to operate on Word8 input
16:06:40 <pikajude> probably counterbalances the inconvenience of needing to encode in the first place
16:06:45 <jle`> Nevoic: if you really wanted to get Text from your API you would do Get '[PlainText] Text or something like that I believe
16:06:46 <pikajude> i mean, realistically, the parser *still* has to do that
16:06:47 <EvanR> dunno
16:06:51 <jle`> then it would take the raw bytestring and parse it as Text
16:07:05 <jle`> (and if it's not a text bytestring, it would error)
16:07:14 <pikajude> text is still a contiguous block of memory in utf16 isn't it?
16:07:42 <EvanR> non-lazy text yes
16:07:43 <jle`> Nevoic: the nice thing about this is that servant can also be used to make rest servers as well
16:07:54 <jle`> and handle the parsing of requests and encoding of responses
16:07:56 <EvanR> but it still has to scan through because of surrogates
16:07:56 <pikajude> so either way, you have to do work at some point in order to determine which parts of the input constitute which symbols in the JSON grammar
16:08:25 <EvanR> the json symbols are 1 element in either case
16:08:41 <EvanR> one Word8 or 1 Utf16 codepoint
16:08:43 <pikajude> yeah but it's 2 bytes instead of 1
16:08:54 <pikajude> word8 vs word16
16:09:15 <EvanR> i would hope the code is munging Word64 in any case :)
16:10:04 <Dunce> can someone read over this snippet for me
16:10:15 <Dunce> I'm getting nowhere and the debugger didnt help lol
16:10:24 <EvanR> also decoding to Value's String (Text) field could be just verified not converted
16:10:52 <pikajude> indeed
16:11:05 <pikajude> well, except not really, because you have to process escape sequences
16:11:14 <pikajude> json doesn't have barewords
16:13:37 <MarcelineVQ> Dunce: you gotta link a snippet when you say that
16:13:39 <EvanR> drat
16:13:44 * hackage mmsyn4 0.1.1.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.1.1.0 (OleksandrZhabenko)
16:14:11 <Dunce> https://gist.githubusercontent.com/FreezeSnail/3a600adab84cf0d67b62978917ac3f54/raw/22d413270dd004d26f1d9dbb36fd72d8fd1a5a82/gistfile1.txt
16:14:28 <Dunce> I was goign to wait for someone to offer instead of spamming a link
16:14:47 <Dunce> its getting stuck in a loop on a base case and I cant figure out wich one
16:17:39 <Dunce> normally I would just put a few print statements to find where its stuck but I can't in this language lol
16:17:51 <EvanR> actually you can
16:17:57 <EvanR> Debug.Trace
16:18:02 <Axman6> Dunce: not sharing the lisk is like asking to ask, don't do it :)
16:18:10 <Dunce> I can just throw that in a line
16:18:26 <EvanR> you throw it around an expression
16:20:24 <Dunce> like Debug.Trace( map (x:) (stuff) )
16:20:25 <Dunce> ?
16:20:53 <EvanR> :t trace
16:20:55 <lambdabot> error: Variable not in scope: trace
16:20:59 <EvanR> :t Debug.Trace.trace
16:21:01 <lambdabot> String -> a -> a
16:21:02 <monochrom> No, "Debug.Trace" is the name of a module you import.  See its doc for what you can use.
16:21:04 <EvanR> :t Debug.Trace.traceShow
16:21:05 <lambdabot> Show a => a -> b -> b
16:21:47 <EvanR> incidentally neither of these are how i use Debug.Trace
16:22:59 <rotaerk> how do you use Debug.Trace
16:23:07 <Dunce> <interactive>:17:4: error:    Not in scope: data constructor ‘Debug.Trace’    No module named ‘Debug’ is imported.
16:23:22 <Dunce> Do I need to install another package or is that part of stack
16:23:45 <EvanR> friedChick x = trace (show x) x, so friedChicken :: Show a => a -> a
16:23:51 <EvanR> friedChicken*
16:24:19 <rotaerk> ..
16:24:21 <wildtrees> Dunce are you in ghci? :m +Debug.Trace . in regular source try import Debug.Trace 
16:24:22 <Dunce> I'm sorry I'm so incompetant at this lol idk why I'm struggling so much
16:25:10 <Dunce> I imported it in my file and tried that but its the same issue
16:25:11 <MarcelineVQ> wildtrees: you can type import Foo in ghci as well
16:25:43 <Dunce> ok wait now it worked lol thank you
16:26:41 <EvanR> and that function friedChicken also works great in javascript, i found
16:26:55 <Dunce> Ok I was correct in my assumption of my error
16:30:21 <Dunce> https://gist.githubusercontent.com/FreezeSnail/3a600adab84cf0d67b62978917ac3f54/raw/6fb6e3d05979c78f42a3e5e552059196c35cf751/gistfile1.txt
16:30:26 <Dunce> so I'm stuck in a loop here
16:30:37 <Dunce> I'm not sure why my base case is failling
16:31:15 <wildtrees> Dunce, which function is looping, or which one do you think is looping?
16:31:23 <EvanR> if your first arg doesn't get smaller, you will never do anything but the first clause
16:31:30 <Dunce> its the one I linked
16:31:42 <Dunce> wait
16:31:51 <Dunce> oh man I see whats wrong now lol
16:32:13 <EvanR> and ys never gets smaller, that seems clear
16:32:13 <Dunce> wait no I dont lol
16:32:34 <EvanR> the last 3 equations only work when ys = []
16:32:37 <EvanR> but ys never gets smaller
16:32:44 <Dunce> ((a, xs):zs) I have this as an input and the recursive call is 
16:32:46 <Dunce> ( matchBitString (zs) (ys))
16:33:09 <Dunce> those are for if the function gets an empty string
16:33:14 <MarcelineVQ> EvanR: the last one is [] ys
16:33:19 <MarcelineVQ> is this the only place you have a trace?
16:33:21 <EvanR> oh
16:34:45 <EvanR> do you see infinite "tears" ?
16:34:57 <wildtrees> Dunce is the first argument to matchBitString possibly an infinite list? 
16:34:57 <Dunce> :') 
16:35:02 <Dunce> no
16:35:06 <Dunce> I generate that list
16:35:10 <Dunce> its 3 members
16:35:13 <EvanR> do you see nothing? 1 "years" ?
16:35:16 <MarcelineVQ> mapBit is more suspicious than matchBitString
16:35:35 <MarcelineVQ> and then decode next suspicious after that, since we don't know what codes looks like
16:36:53 <EvanR> since the loop must be in the sub routines, i'm guess you don't see all these tears
16:37:04 <Dunce> so
16:37:15 <MarcelineVQ> mapBit ((a, xs):zs) ys =  (matchBitString (reverse ((a, xs):zs)) ys) ++ mapBit (reverse ((a, xs):zs)) ...
16:37:27 <Dunce> the weird part is it works as expected until the last segment of the bitstring
16:39:02 <Dunce> https://gist.githubusercontent.com/FreezeSnail/13ec34d23aef295bbdd1db393fb82379/raw/757c6ca5c7a07ce88861c71be1316e4deb0e2f98/gistfile1.txt
16:39:05 <Dunce> thats everything
16:40:14 * hackage rattletrap 9.0.3 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.3 (fozworth)
16:40:25 <Dunce> my idea was match the bitstring, then recurse with the bitstring list trimmed based on what it matched too
16:40:49 <EvanR> i would give Dunce's left liver for a totality checker :)
16:40:59 <Dunce> whats that lol
16:41:10 <MarcelineVQ> A thing that would complain about: mapBit ((a, xs):zs) ys =  ... mapBit (reverse ((a, xs):zs)) ...
16:41:13 <EvanR> so much recursion here
16:41:21 <Dunce> I think everyday more of brain dies
16:41:32 <Dunce> I promis my c code isn't anywhere near this awful lol
16:42:18 <EvanR> recursion is great when it's obviously terminating
16:42:27 <Dunce> I cant think of another way to do this because the input is a huffman tree so I have to generate an encoding list and then use that for everything
16:42:29 <MarcelineVQ> % foo xs = foo (reverse xs)
16:42:30 <yahb> MarcelineVQ: 
16:42:36 <MarcelineVQ> % foo [1,2,3]
16:42:41 <yahb> MarcelineVQ: [Timed out]
16:42:51 <s0da> ok gaiz.ive done quite a bit of soul searching (and web searching), and ive come to the conclusion that....
16:42:55 <MarcelineVQ> foo (foo (foo (foo (foo ...
16:43:00 <EvanR> MarcelineVQ: ([1,2,3] + [3,2,1])/sqrt(2)
16:43:45 <Dunce> I flipped the list because the longest bitstrings that are encoded are at the end since 
16:43:51 <Dunce> actually I dont think that matters 
16:44:09 <EvanR> you can flip a list but you can't recurse on it, since it's still the same length
16:44:16 <s0da> what i was looking for was indeed NOT a "programming language" AT ALL, but rather: an open-source game-engine. (iow,  was asking the wrong question, and therefore getting the wrong answer.) again, sry for flooding the channel with r3t4rd-level questions yesterday
16:44:26 <wildtrees> Dunce, your list might be getting longer and longer cause you dont seem to be decreasing the the lists you are passing to mapBit 
16:44:28 <s0da> cya
16:44:56 <Dunce> get incremented list should return a shorter ys
16:45:00 <Dunce> it does
16:45:02 <Dunce> actually
16:45:04 <EvanR> > let f (x:xs) = f (reverse xs); f [] = "i'm alive!" in f [1,2,3]
16:45:07 <lambdabot>  "i'm alive!"
16:45:08 <Dunce> else i wouldnt get the right decodes
16:45:25 <Dunce> becuase like for "decode xyz_code [True,False,True,True,True,False,False,True,False]"
16:45:46 <Dunce> my output is "yzyx
16:46:02 <Dunce> and then it loops forver instead of giving me the last y
16:46:21 <Dunce> so the list is for sure being decreased
16:47:39 <Dunce> I'm very open to completely starting over if theres a suggesting for a better way to do this lol
16:48:11 <EvanR> for every function involving recursion, all recursive calls need to be on at least 1 decreasing argument
16:48:21 <EvanR> not just some of the recursive calls
16:48:26 <Dunce> they are
16:48:32 <Dunce> to my understanding
16:48:47 <EvanR> my attempt to untrace your code https://paste.ofcode.org/fFNqmZFJg3wXv7W43nZ7F5
16:49:06 <EvanR> line 2 seems to be badly (mutually) recursive
16:49:26 <Dunce> I actually tried to indent like that but it stopped compiling 
16:49:50 <Dunce> whats wrong with that
16:50:39 <Dunce> thats just calling my function that checks each string in my list of codes against the list
16:50:40 <EvanR> nevermind, that doesn't actually come back to call mapBit i don't think
16:50:47 <Dunce> no it doesnt
16:51:09 <wildtrees> you have a base case and you stop, and you have a recursive case, and most of the time you want your recursive case to make the arguments structurally smaller on pattern matchin for when you call the function again
16:51:36 <wildtrees> you are getting smaller via pattern matching, but then you are just gluing it back together to the same size it looks like in certain cases 
16:51:53 <Dunce> well
16:52:05 <Dunce> ys is the only thing that should decrease
16:52:13 <wildtrees> the recursive calls need to get be structurally smaller call after call for most recursive functions to terminate 
16:53:01 <EvanR> i'm not imagining how gluing results after recursive call could stop termination
16:53:11 <EvanR> gluing arguments to the recursive call yeah
16:54:03 <EvanR> i can't even really read the entirety of mapBit at this point so i'll take a break
16:54:15 <Dunce> I'm sorry its so awful
16:54:23 <Dunce> im not sure how to express my appreciation
16:56:52 <wildtrees> Dunce, I think I figured it out 
16:57:06 <wildtrees> getIncrementedList xs ys = ( drop (length xs) ys)
16:57:16 <wildtrees> will matchin on []
16:57:27 <wildtrees> you should put your base cases/terminating cases first 
16:57:36 <wildtrees> so it is matching on [] for xs 
16:57:40 <wildtrees> and drop 0 from ys 
16:57:44 <wildtrees> dropping 0 from ys
16:58:04 <wildtrees> so when xs hits 0 it is never making the answer smaller 
16:58:17 <wildtrees> the order of pattern matching matters in haskell, Dunce 
16:58:22 <Dunce> this explains a lot
16:59:01 <Dunce> though I broke something else along the way
16:59:06 <Dunce> that no longer loops forever tho
16:59:21 <Dunce> now i just need to figure out why it isnt mathcing any strings any more lol
17:00:19 <wildtrees> Dunce, I gotta go, glad I could help you a bit, have a good one and good luck on your debugging! 
17:01:41 <EvanR> Dunce: something like this https://paste.ofcode.org/35cmPyAVp7XUy6eYyyRZzwL
17:03:06 <EvanR> actually the pattern wasn't even used
17:03:47 <EvanR> https://paste.ofcode.org/334NUE3xNPgPNtrjfznhpFW
17:04:05 <Dunce> ok
17:04:06 <EvanR> at least it has 4 parenthese now not 50
17:04:07 <Dunce> ill
17:04:10 <Dunce> use that later
17:04:18 <Dunce> after brain can process
17:04:32 <Dunce> cant figure out why this is always returning an empty list lol
17:11:27 <Dunce> compareBitString ('x', [False]) [False]False
17:11:32 <koz_> EvanR: You asked recently about someone combining arrays and dependent typing, right?
17:11:32 <Dunce> :') 
17:11:38 <koz_> I remember something like this vaguely.
17:13:42 <koz_> Also, could someone please tell me how Ptr, ForeignPtr and StablePtr are different?
17:14:13 <phadej> have you read the docs?
17:15:42 <Dunce> it works
17:15:45 <Dunce> thank you all
17:15:47 <Dunce> so much
17:16:36 <koz_> phadej: I have, but I'm still not completely clear. ForeignPtr and StablePtr in particular I don't quite get the difference between, specifically in terms of use.
17:16:54 <EvanR> koz_: yes countless examples of tantalizingly named Vect which is really a list
17:17:16 <koz_> EvanR: Have you read the paper 'APL-icative programming with Naperian functors'?
17:17:21 <EvanR> yeah
17:17:34 <EvanR> forgot about that one
17:17:52 <koz_> Figured I'd mention it - I discovered it recently and it's been interesting.
17:19:17 <phadej> koz_: ForeignPtr - The type ForeignPtr represents references to objects that are maintained in a foreign language,
17:19:23 <phadej> koz_: StablePtr - A stable pointer is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection
17:19:35 <phadej> foreign language vs. Haskell expression
17:20:16 <koz_> Why would we not use a StablePtr in cases where a ForeignPtr would be used, then? Surely you wouldn't want the garbage collector touching stuff that's maintained in a foreign language?
17:20:28 <koz_> Is one like a superset of the capabilities of the other or something?
17:20:42 <EvanR> actually you do
17:20:50 <EvanR> because ForeignPtr can have a finalizer
17:21:16 <phadej> ForeingPtr memory is allocated by foreign language (some library allocates memory using malloc or whatever), and you attach finalizers (which will call free/...)
17:21:24 <EvanR> when you forget about it, you can have it released in the foreign system
17:21:30 <phadej> StablePtr OTOH is allocated by GHC RTS
17:21:46 <phadej> again: foreing constructr vs. haskell value
17:22:11 <phadej> ForeignPtr OpenGLHandle vs. StablePtr (Maybe Bool)
17:22:33 <EvanR> there's yet something else, StableName
17:22:41 <koz_> phadej: In what circumstance would we want StablePtr then?
17:22:43 <EvanR> also Weak
17:23:30 <koz_> EvanR: Weak?
17:23:42 <phadej> EvanR: don't throw everything at once at already confused people
17:24:32 <EvanR> heh
17:24:39 <EvanR> now i can't find the docs
17:24:40 <phadej> koz_: I don't know, when you are calling into C which will call you back, with context. So you'll give StablePtr as a context
17:24:58 <phadej> koz_: if you don't understand that, you don't need it
17:25:13 <koz_> phadej: Oh, OK, I think I get it. ForeignPtr is when I want Haskell messing with non-Haskell things. StablePtr is when I want non-Haskell messing with Haskell things?
17:25:20 <phadej> koz_: yes
17:25:26 <koz_> OK, that makes perfect sense, thank yoU!
17:25:31 <phadej> koz_: cheers
17:25:45 <koz_> ... then what's Ptr for?
17:26:11 <phadej> Ptr is just a pointer
17:27:12 <koz_> But what would I need it for that isn't covered by ForeignPtr or StablePtr?
17:27:12 <EvanR> System.Mem.Weak
17:27:35 <phadej> koz_: in C++ speak, ForeignPtr is "smart pointer", Ptr is dummy one
17:27:41 <koz_> Ah.
17:28:13 <koz_> (I hear them referred to as 'raw' pointers, which makes smart ones 'cooked', lol?)
17:28:23 <koz_> OK, that now makes sense to me, thank you.
17:29:05 <phadej> e.g. Ptr: https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-C-String.html
17:29:29 <phadej> to call C-stuff you'll probably use withCStringLen
17:29:48 <EvanR> baked
17:30:14 <koz_> EvanR: Fried.
17:30:32 <EvanR> raw (dead) vs living
17:30:59 <EvanR> pointer to live object, pointer to inanimate bytes
17:31:33 <koz_> Well, this has, as ever, been enlightening, thanks!
17:31:36 <EvanR> if it's not gonna be accurate at least it should be evocative
17:31:54 <koz_> EvanR: I think 'cooked pointer' is pretty evocative.
17:32:27 <phadej> "cured"
17:32:37 <EvanR> toasty
17:32:53 <koz_> phadej: Lol.
17:33:02 <phadej> as in https://en.wikipedia.org/wiki/Curing_(food_preservation)
17:33:12 <koz_> phadej: Yeah, I gathered. 'Fermented' would also work.
17:33:45 <monochrom> Pointer stew.
17:33:57 <EvanR> so Ptr is a wrapper for Addr# ?
17:34:05 <EvanR> that pretty much explains it all
17:34:16 <koz_> monochrom: Typical C code confirmed?
17:34:19 <phadej> EvanR: yes, naked ptr
17:34:27 <monochrom> Stir-fried addresses.
17:34:46 <phadej> can be on Haskell heap, or not. You don't know from the type.
17:35:04 <phadej> (often you also don't care)
17:35:56 <phadej> not using FFI is a bliss
17:36:02 <Dunce> can you use trace to print a list variable by any chance?
17:36:32 <EvanR> f x = trace (show x) x
17:36:41 <EvanR> > show [1,2,3]
17:36:44 <lambdabot>  "[1,2,3]"
17:36:53 <EvanR> works (as long as x is Show able)
17:37:24 <Dunce> oh show
17:37:25 <Dunce> thank you
17:37:55 <phadej> > traceShow 'x'
17:37:58 <lambdabot>  error:
17:37:58 <lambdabot>      Variable not in scope: traceShow :: Char -> t
17:38:00 <phadej> > traceShowId 'x'
17:38:03 <lambdabot>  error:
17:38:03 <lambdabot>      Variable not in scope: traceShowId :: Char -> t
17:38:09 <phadej> %% traceShowId 'x'
17:38:10 <yahb> phadej: http://qp.mniip.com/y/16
17:38:11 <phadej> % traceShowId 'x'
17:38:11 <yahb> phadej: 'x'; 'x'
17:41:36 <koz_> I wonder why writing something to a Ptr is 'poking'
17:41:39 <monochrom> Yeah traceShowId is EvanR's fried chicken (EFC)
17:41:48 <devalot> Is it possible to write a Functor instance for this?  newtype F a = F (a -> Maybe a).  I think I would need a second type argument to make this work but I'm not sure.
17:42:06 <koz_> devalot: No, it's not, because F is invariant in a.
17:42:18 <monochrom> koz_: I only know the history from BASIC, "poke" to write a byte, "peek" to read.
17:42:24 <koz_> monochrom: Ah, I see.
17:42:33 <koz_> 'Peek' I get, but 'poke' not so much.
17:42:37 <devalot> koz_: That's what I was thinking.  Thanks.
17:42:37 <monochrom> Me too.
17:43:12 <monochrom> I kind of get the unarticulable feeling.
17:43:52 <monochrom> But more likely someone was just looking for a word to form a limerick with "peek".
17:44:13 <EvanR> if a pointer is like the magnetic tape head hovering above a memory location
17:44:32 <EvanR> poke turns the magnet to 11 and obliterates whatever is there
17:44:50 <monochrom> then Magneto is a Real Programmer  >:D
17:45:16 <shachaf> A limerick?
17:45:19 <koz_> Magneto doesn't care for your memory safety - he just flips the bits directly.
17:45:59 <monochrom> <CS student> Real Programmers use a piece of magnet to change hard disk files hahahaha.  <Magneto> What's so funny with that?
17:46:16 <EvanR> if memory was a paper card poke may very be literal, though irreversible
17:46:40 <koz_> unsafePerformWhatever :: Magneto -> a
17:46:40 <monochrom> shachaf: like "peeky pokey"
17:46:48 <monochrom> peeky pokey okey dokey
17:49:34 <koz_> I wonder why all the stuff in Foreign is listed as 'Portability: portable'...
17:50:35 <Dunce> ok so I know x:xs lets you opperate on the head of the list
17:50:42 <Dunce> is there the same thing for the tail
17:50:52 <monochrom> xs is that tail.
17:50:55 <Dunce> like xs:x basically 
17:50:57 <dmwit> monochrom: I think I know what you mean, but "limerick" is almost certainly the wrong word to use.
17:51:09 <Dunce> by tail I mean the very last member
17:51:15 <boj> :t reverse
17:51:16 <dmwit> Dunce: Nope. You can use the `last` function.
17:51:17 <lambdabot> [a] -> [a]
17:51:18 <monochrom> Then no.
17:51:19 <dmwit> It is expensive.
17:51:36 <koz_> You gotta tear through the entire list to get to it.
17:51:52 <Dunce> so I have (a, x):xs, theres no way to use the tail in that format?
17:51:52 <monochrom> The way I understand Huffman tree homework, if you want the last item of a list you've already lost.
17:51:56 <Dunce> ok
17:52:19 <koz_> In general, arbitrary indexing into a list is a losing proposition.
17:52:35 <Dunce> I cant think of a less dumb way to do this lol
17:52:36 <koz_> If you want that, call digging tools digging tools and use a Vector or something.
17:53:31 <Dunce> ill just pull the last memeber and pass it
17:53:42 <sim590> I am trying to parse parentheses in a String using Text.Parsec.String's Parser monad https://paste.debian.net/1107850/. I managed to write something that parses expressions of the form "(xx..(yy..(...)ww..)zz..)", but now I'm trying to modify this to support expressions like "(x(y)z(a)b)". Notice that once a parenthesis closes, it can befollowed by another opening parenthesis. I'm not really
17:53:43 <sim590> understanding how I can do that with Monads and such. I'm thinking about repeat and msum or similar ideas, but I can't find something that works.
17:54:27 <monochrom> Consider "many".
17:55:17 <sim590> I tried using many, but when I tried it with a nested many that would let empty expressions to be matched, it didn't like it. I understand that it would create infinite loop.
17:55:24 <monochrom> Also consider writing the grammar in EBNF and with as little of your own recursion as possible. Then it is easier to see where you need "many". Or "some".
17:55:36 <monochrom> Ok then "some".
17:55:48 <monochrom> They are Siamese twins.
17:56:00 <monochrom> They are entwined. Literally.
17:57:43 <sim590> OK. I'm looking into this.
18:02:37 <sim590> monochrom: some is not in parsec package though. Is it compatible with Text.Parsec.String ?
18:03:35 <sim590> It seems to be part of parser-combinators though. Is that the one?
18:03:53 <monochrom> "some" is a method of Applicative. Parsec is an instance of Applicative.
18:05:09 <koz_> :t some
18:05:10 <lambdabot> Alternative f => f a -> f [a]
18:05:11 <c_wraith> Alternative
18:07:36 <sim590> It may not be defined for the instance Parsec and just later be defined in another auxiliary package, no? Since `some` is not part of the minimal implementation of Alternative. It's just weird that it is not documented in http://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec.html.
18:08:06 <sim590> While `many` which is also part of Alternative is documented.
18:08:28 <c_wraith> The docs clearly say there's an Alternative instance, though.
18:08:37 <sim590> Yes. That's true.
18:09:29 <c_wraith> Instance lists are the easiest thing to overlook in haddocks.  Which is unfortunate, given how important they are.
18:09:41 <c_wraith> They're what describe how you interoperate with the rest of the ecosystem.
18:09:42 <sim590> But just importing Text.Parsec is not sufficient. I need to import Control.Applicative.Combinators.NonEmpty if I'm not mistaken.
18:10:22 <EvanR> Control.Applicative right
18:11:09 <sim590> I don't understand yet why some documentation page write longer nesting of "modules", but the module to import is just smaller prefix of it..
18:12:22 <c_wraith> those just list what modules are explicitly re-exported.  The re-export can be limited by only importing part of the module.
18:13:52 <sim590> How would you write it for this page then? https://hackage.haskell.org/package/parser-combinators-1.2.0/docs/Control-Applicative-Combinators-NonEmpty.html
18:14:49 <Dunce> https://gist.githubusercontent.com/FreezeSnail/13ec34d23aef295bbdd1db393fb82379/raw/73ac7d93dc305126b3be4e8c9408be0c2de1a59b/gistfile1.txt 
18:14:51 <c_wraith> that's an awkward module because it intentionally has name collisions with Control.Applicative
18:15:03 <Dunce> any Ideas why this says non-exhaustive patterns
18:15:12 <Dunce> its not recursive
18:15:51 <c_wraith> could you at least give us a hint as to what binding it says is non-exhaustive?
18:16:05 <c_wraith> oh, I see.  It's the last one.
18:16:08 <Dunce> oh sorry I thought I typed combine
18:16:20 <c_wraith> it's because [(a, xs)] only matches lists of length exactly 1
18:16:34 <Dunce> yea
18:16:36 <c_wraith> So you have an infinite number of cases not handled
18:16:43 <Dunce> I just realized I used the wrong syntax
18:17:43 <c_wraith> I suspect you probably want to just bind that whole list to a single name
18:18:02 <c_wraith> but maybe I'm misunderstanding your goal there
18:18:07 <jusss> why I followd the docs and I always got errors...  https://paste.ubuntu.com/p/RHRdpq8XKY/
18:18:40 <jusss> or this one line implement https://rosettacode.org/wiki/Sockets#Haskell
18:18:54 <jusss> ghc-8.6.5
18:19:10 <rotaerk> I initially read that domain as rottentomatoes, and was like "wait, they're reviewing haskell now?"
18:19:50 <c_wraith> jusss: AF_INET and Stream should be separate arguments
18:20:56 <c_wraith> jusss: see https://hackage.haskell.org/package/network-3.1.1.0/docs/Network-Socket.html#v:socket
18:20:56 <jusss> c_wraith: ok, I changed it, but error 2 is still
18:21:28 <jusss> c_wraith: SocketServer.hs:8:20: error:    * Data constructor not in scope: 
18:22:21 <c_wraith> that looks like a typo.  It's SockAddrInet, not SockAddrInt
18:22:38 <jusss> ...
18:22:51 <Dunce> well, it appears I cant constrain the method with (Eq a) =>
18:23:06 <Dunce> brutal
18:23:09 <Dunce> it works too
18:23:52 <EvanR> rotaerk: 39% A tired and uninspired generics based romp through an algorithm that has more in common with hashing than compression. Avoid at all costs
18:24:19 <jusss> c_wraith: that one line code in https://rosettacode.org/wiki/Sockets#Haskell, can it work on ghc 8.6.5?
18:24:41 <Dunce> So anyone have an idea on how I could replace my method that finds how far to index so It doesnt use the constraint
18:25:17 <MarcelineVQ> You need to link, and name, your thing when you ask about it
18:25:42 <rotaerk> heh
18:26:41 <MarcelineVQ> you being Dunce
18:31:46 <Dunce> oh
18:31:52 <c_wraith> jusss: I don't know.  The version of the network package is more important than the version of ghc.
18:31:54 <Dunce> well I've been talking about it for like 3 hours lol
18:33:03 <MarcelineVQ> Which it? "my method" is pretty vague
18:33:31 <MarcelineVQ> People, that were here, could look up what happened earlier but if you want help it's best to make it easy for people :>
18:33:52 <Dunce> its ok I think I just have to do this one myself now else I'm never going to learn
18:42:23 <remexre> should I be able to hoogle for instances?
18:43:33 <Dunce> The lack of null is brutal lol
18:44:33 <MarcelineVQ> > null []
18:44:35 <lambdabot>  True
18:44:49 <jellostahps> `stack run` in the project folder will run my front end. But `stack ghci run` does not run the program and has the following compiler errors :https://pastebin.com/aRgbDbRu . `stack ghci` seems to get me into ghci (even though I have installed stack but not ghci), but once inside ghci, I don't know how to 'run' to get my front end up again
18:45:29 <jellostahps> IDK what all these different mdoes r, I just wanna be able to both run and debug my program.
18:45:44 <Dunce> well
18:45:45 <Dunce> I
18:45:52 <Dunce> got full points on my grader 
18:46:01 <Dunce> I'm going away now until nexttime
18:46:15 <Dunce> Can I donate to the server host or something I'm in debt
18:46:34 <EvanR> lack of lack of null is brutal
18:48:20 <MarcelineVQ> jellostahps: you can use :main or :run in ghci to run something, it's not quite what stack run does though which is to compile your program and then execute it
18:49:12 <MarcelineVQ> ghci is just ghc --interactive so you have it because stack fetches ghc for you if you need it
18:49:12 <jellostahps> MarcelineVQ: What does 'stack ghci' do? Just compile it?
18:49:21 <MarcelineVQ> stack ghci loads your project into ghci
18:50:09 <jellostahps> And then once it is loaded into ghci, I can run it with :main or :run?
18:50:28 <MarcelineVQ> if you want to do things from ghci that's the way yes
18:51:04 <jellostahps> Why does stack ghci run` from the project folder cause the compiler message I posted instead of running the program?
18:51:10 <jellostahps> `stack ghci run`
18:51:55 <Dunce> EvanR I thought there was no NULL only the maybe, Nothing :') 
18:52:08 <EvanR> :t nullPtr
18:52:09 <lambdabot> error: Variable not in scope: nullPtr
18:52:19 <EvanR> Ptr a
18:52:22 <Dunce> This language hurts my brain, who thinks c is hard compaired to this
18:52:28 <MarcelineVQ> You're telling it to load a package called 'run' when you say that
18:52:31 * EvanR raises hand
18:52:50 <MarcelineVQ> stack ghci --help      Usage: stack ghci [TARGET/FILE]
18:53:27 <MarcelineVQ> "  TARGET/FILE              If none specified, use all local packages. See https://docs.haskellstack.org/en/stable/build_command/#target-syntax "
18:53:39 <Dunce> Thanks again everyone, I'll try and be less inept next time
18:53:58 <jellostahps> okay ty for help
18:54:41 <jellostahps> lastly, is there a keyboard command to exit out of front end once I am in it?
18:55:45 <MarcelineVQ> if you don't have a way built into your program to quit/finish you can use  ctrl + c
18:56:07 <MarcelineVQ> if you just want to exit ghci you'd type :q
18:56:40 <ChaiTRex> Ctrl-D might also exit ghci
18:56:51 <jellostahps> sadly, neither works. I guess the programmer didn't code for it
18:57:08 <MarcelineVQ> ChaiTRex: ye
19:02:47 <jusss> if we want to program some network socket code, should we use Network.Socket in haskell?  in python, they don't suggest to use low-level stuff
19:03:10 <jusss> python provides lots of frames and libraries
19:03:27 <jusss> twisted, tornado, blablablah
19:05:23 <EvanR> many network libs exist mainly to do concurrency for you
19:07:23 <jusss> EvanR: I wonder how haskell to do concurrency, coroutine or multi-threads?
19:07:45 <jusss> I heard a term `task' before
19:08:13 <EvanR> threads
19:09:09 <jusss> EvanR: does haskell have select function or epoll stuff to do async?
19:09:14 <EvanR> see docs for forkIO, `async' library, and the book Parallel and Concurrent Programming in Haskell
19:09:37 <EvanR> no select function, the I/O system does it for you
19:10:25 <jusss> EvanR: what? haskell can do async easier than others?
19:10:43 <EvanR> yeah
19:12:06 <jusss> EvanR: haskell has GUI libraries?
19:12:16 <EvanR> kinda not really
19:12:26 <jusss> EvanR: ...
19:12:52 <EvanR> you can use bindings 
19:13:17 <jusss> yeah... C++ or C bindings? qt or gtk?
19:13:55 <jusss> I wonder how haskell work with C's pointers?
19:14:59 <EvanR> https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Ptr.html
19:25:32 <koz_> Something something deja vu.
19:26:15 <MarcelineVQ> deva vu just means you've been looking at irc too often in one day
19:27:22 <koz_> MarcelineVQ: I very much doubt that. I think it's more 'being awake at 5am and having to review student tests today'.
19:27:31 <koz_> (which involved C code)
19:42:44 * hackage rattletrap 9.0.4 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.4 (fozworth)
19:43:13 <sim590> This doc http://hackage.haskell.org/package/Stack-0.4.0/docs/Data-Stack.html#t:Stack doesn't list Stack as Monad, but when I use it inside do block, ghc expects the return type Stack. What's going on? Am I using the wrong documentation page?
19:43:29 <sim590> I did import Data.Stack.
19:46:34 <sim590> How can I tell inside ghci if some type is a monad or not. I don't want to look into hoogle as it says wrong things apparently.
19:46:42 <koz_> sim590: What's your code?
19:46:56 <MarcelineVQ> :info SomeTyoe
19:47:41 <MarcelineVQ> Should only tell you about instances that are currently in scope though
19:47:57 <sim590> koz_: https://paste.debian.net/1107873/ Some things are commented because of the issue I'm having. Also, I did try to force the type of stackNew in the return line that should not be as it is. It's for debugging.
19:49:25 <koz_> Why are you using >>= here? Stack is, as you claim, very much not a monad.
19:49:47 <sim590> koz_: I'm in the Maybe (Stack a) monad.
19:50:59 <koz_> stackPush has type Stack a -> a -> Stack a. Even flipped, I don't see how you can reconcile this with returning a Maybe _anything_.
19:50:59 <jusss> is anyone using haskell-mode on emacs? why it always auto indent for 2 space after press enter?
19:54:30 <sim590> koz_: OK, yeah. I did forget the return.
20:31:34 <dsal> jusss: I use haskell-mode. I don't use electric indent, though.
20:33:38 <jusss> dsal: the autoindentation, in the first line, I press tab it takes 4 spaces, and in the seconds , it takes 8 spaces, in the thirds it take 12 spaces, why?
20:34:15 <jusss> it's really feel not good on emacs...
20:34:17 <dsal> I'm not sure what you mean... that's how it normally works.
20:34:31 <dsal> What would you prefer it do?
20:34:53 <dsal> You can configure it to do anything if you don't like the normal behavior.
20:35:39 <jusss> dsal: this autoindentation is ok for you? https://paste.ubuntu.com/p/j6nkbfFwMv/
20:36:22 <jusss> dsal: it shouldn't be the same indentation among 4th,5th and 6th?
20:36:33 <jusss> line
20:38:15 <jusss> dsal:  this code is ok, but when I use ghc --make this.hs, it will report an error:     Parse error in pattern: putStr    Possibly caused by a missing 'do'?  |4 |          putStr "Give me some input: "
20:39:04 <jusss> haskell do pay attention on indent?
20:39:08 <dsal> I don't know.  It behaves the way I'd expect.
20:39:19 <jusss> wrong indent will cause errors?
20:39:41 <jusss> python does that, does haskell?
20:39:53 <dsal> Yes.  Indentation matters.  That's why there's not one correct answer.   There are incorrect answers, but there's not a complete haskell interpreter in emacs.
20:40:50 <jusss> dsal: I run it will runghc, not 
20:42:05 <jusss> dsal: I found haskell is hard to learn, now I found it's even hard to write...
20:42:50 <jusss> the indentations, why there's not a good tool for haskell
20:43:02 <dsal> emacs is pretty good.
20:43:02 <jusss> IDE or editor whatever
20:43:13 <jusss> dsal: but hasekll-mode not good
20:43:25 <dsal> I think it's pretty good.
20:43:42 <jusss> dsal: then why it cause this indentation error?
20:44:03 <jusss> dsal: do you see any syntax error on this code？
20:44:06 <dsal> You're the d river.
20:45:17 <dsal> I don't know, dude.  It's unsurprising to an emacs user.  If you're not an experienced emacs user, then you may find it a little surprising.
20:46:17 <jusss> fine
20:46:37 <jusss> I hate to change the default mode config
20:46:51 <jusss> it supposes to work well, 
20:50:44 <dsal> I don't use electric indent., but different modes have different "power" in tab.  In python, for example, it's very ambiguous, so it just cycles  through some possibilities.  Haskell does a similar thing.  In C, there's typically one right place, so it generally does the right thing.  In javascript, I often do some indentation that isn't lexically interesting, but does some semantic differentiation.
20:52:00 <jusss> dsal: I changed the indentation space in the code, and there's no error, I really don't know why hasekll take indentation as syntax like python
20:53:02 <dsal> If you're just learning, there are probably a lot of things you don't know about haskell.  heh
20:53:48 <jusss> dsal: but the hasekll-mode came from emacs, which is default don't have a correct configuration for haskell code
20:54:14 <dsal> It works quite well.
20:54:30 <jusss> dsal: not on my emacs, heh
20:54:54 <dsal> To some degree, you are responsible for the code you write.  If you indent something in a nonsense way, it won't work.  Emacs won't stop you from doing that.
20:56:08 <jusss> to be clear, I didn't write hasekll-mode
20:58:00 <dsal> I wasn't accusing you.  haskell-mode does a pretty good job helping me write haskell code.  It doesn't write the code for me, though.
20:59:02 <dsal> Some people like haskell-ide-engine.  In theory, it's far superior.  I wasn't able to get it working last time I tried, though.
20:59:18 <jusss> I never wish it can write the code for me, I just hope it can help me with the code indentation
21:00:10 <jusss> fine, I may just disable its indentation
21:00:17 <jusss> just need to disable
21:01:20 <jusss> on my opinion, it's just not worl well on my emacs like python-mode 
21:49:39 <macroprep> is argmax computable
21:50:47 <heatsink> Not in general.  It could be computable for specific types.
22:00:07 <sim590> Why does ghc tells me my left stack is Stack Int. It's clearly Stack Char... https://paste.debian.net/1107891/ ???
22:00:56 <sim590> relevant functionL: evalExpr
22:01:20 <sim590> I just changed terminal emulator and had issue with copying URL so I made a mistake in the pastebin.
22:01:59 <sim590> I keep getting Couldn't match expected type ‘Char’ with actual type ‘Int’
22:02:15 <heatsink> on which expression?
22:02:27 <sim590> `stackUp (ops', stackPush vs' $ compute op' x y) c`
22:02:39 <sim590> I'm implementing a calculator.
22:03:23 <Axman6> I don't see that code in your paste
22:03:24 <heatsink> If you write a type annotation for stackUp, you might get a more helpful error message
22:03:31 <heatsink> Axman6: line 61
22:03:39 <Axman6> ah thanks
22:04:10 <heatsink> I think you want stackUp :: (Stack Char, Stack Int) -> Char -> Maybe Int
22:04:18 <heatsink> is that right?
22:05:26 <sim590> Yeah
22:05:55 <sim590> huh
22:06:18 <sim590> No. I need to pass the stacks at each step in the foldM.
22:06:25 <Axman6> step #1 in resollving type errors is adding the types you think you have
22:06:53 <sim590> I want stackUp :: (Stack Char, Stack Int) -> Char -> Maybe (Stack Char, Stack Int)
22:07:16 * koz_ smells a two-stack automaton.
22:07:31 <sim590> The result is then found in the second stack at the end.
22:07:37 * Axman6 didn't even know we had a Data.Stack
22:08:18 <heatsink> Try writing that type.  It can go in the same `let` where you have defined stackUp
22:08:41 <sim590> I thought you had to put it out of the let?
22:09:07 <heatsink> > let {f :: Int -> Int; f x = x * x} in f 5
22:09:10 <lambdabot>  25
22:10:05 <heatsink> The syntax for type signatures in `let` or `where` is the same as the syntax for top-level definitions
22:11:15 <sim590> OK. Now messages are better ... Really, when I inconsistent error messages, that drives me nuts.
22:11:20 <sim590> And I'm being polite.
22:11:50 <heatsink> Without a type signature, GHC infers the type based on the part of the code that it analyzes first.
22:12:03 <heatsink> If it analyzes the part of the code that's wrong, it will infer the wrong type
22:12:15 <heatsink> Then when it looks at the part of the code that's correct, it'll tell you that it found an error
22:13:43 * jackdk is a bit put off by the Semigroup instance for Data.Stack.Stack...
22:13:54 <sim590> I will have to think about it in the future. Thank your for your generous assistance. I might be ADHD and I frustrate quickly about things.
22:16:13 <Axman6> sim590: did you solve the problem?
22:16:50 <EvanR> implementing useful error messages in a compiler is more daunting to me than the actual... compiling
22:16:59 <sim590> Axman6: Yes. It was about the comparaion with opTopPrec which needed be passed in opPrec. Actually, I have to change that name.
22:17:48 <heatsink> EvanR: The first step to a good error message is to figure out what the user actually wanted
22:18:14 * hackage net-mqtt 0.6.0.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.0.1 (dustin)
22:19:01 <EvanR> heatsink: ok... ? heh
22:21:22 <koz_> EvanR: Also, make sure all error messages are in doge.
22:21:58 <EvanR> oh hell no
22:22:23 * koz_ imagines Haskell output in doge.
22:22:27 <koz_> s/Haskell/GHC/
22:22:45 <koz_> 'wow, much hole, very (Alternative f, Num a) => f a'
22:23:01 <heatsink> I mean, usually, most of the code that is involved in the error is written correctly, and one part is wrong
22:23:15 <koz_> heatsink: Unless you are a programming student.
22:23:19 <heatsink> hah
22:23:21 <koz_> In which case it's more like the opposite. :P
22:23:50 <EvanR> that explains a few things about programming class
22:24:15 <heatsink> In that case, maybe it should be a success message instead of an error message
22:24:18 <EvanR> and the utility of the C error msgs
22:24:30 <koz_> EvanR: Especially C _linker_ messages.
22:24:32 <jusss> why this code, run in the ghci, it print "Give me some input: " first, then take your input, but when I use ghc --make a.hs to a.exe on windows, or a.bin on linux , then a.exe just doesn't print the prompt, it needs input first, why
22:24:35 <heatsink> Line 10: this use of foldr is correct
22:24:36 <jusss> https://paste.ubuntu.com/p/j6nkbfFwMv/
22:24:36 <koz_> Those are grossly cryptic.
22:25:21 <jusss> is there a buffer stuff it needs to flush?
22:28:26 <heatsink> jusss: Try turning off line buffering
22:28:49 <jusss> heatsink: how?
22:28:50 <heatsink> It uses functions from System.IO
22:28:57 <heatsink> hSetBuffering stdout NoBuffering
22:30:58 <koz_> Why are buffers 'flushed'? They're not toilets.
22:31:07 <EvanR> haha
22:31:16 <EvanR> they sort of are
22:31:31 <heatsink> They're like a series of tubes
22:31:47 <EvanR> your program is... dumping... data into the buffer
22:31:50 <jusss> heatsink: put this `hSetBuffering stdout NoBuffering' into where?
22:32:00 <dsal> emacs!
22:32:00 <koz_> EvanR: I guess with _certain_ inputs, a buffer would be much like a toilet.
22:32:03 <EvanR> no one knows until they flush
22:32:48 <EvanR> indeed
22:32:49 <heatsink> jusss: It's an IO action.  Put it in main so it executes before the loop
22:33:14 <heatsink> Are you familiar with using `do` for IO?
22:33:23 <jusss> heatsink: not really
22:33:24 <EvanR> if the buffer is full... blocking 
22:33:48 <jusss> heatsink: but I know the do sugar syntax for monads
22:33:51 <EvanR> gotta hold it
22:33:57 <jusss> monadic actions
22:34:27 <heatsink> That's what I'm talking about
22:35:36 <heatsink> main should disable buffering of stdout, then execute the loop
22:36:13 <heatsink> To do those things in sequence, use `do`, followed by those statements on separate lines
22:36:45 <jusss> heatsink: this way？ https://paste.ubuntu.com/p/22WzGtBqqN/
22:36:57 <heatsink> ys
22:37:13 <jusss> heatsink: yeah, it works
22:37:31 <jusss> heatsink: which tool you use to edit your haskell code?
22:37:36 <heatsink> I use emacs
22:38:05 <jusss> heatsink: haskell-mode/
22:38:12 <heatsink> yes
22:38:31 <jusss> heatsink: did your autoindentation work properly?
22:38:51 <heatsink> It works for me
22:39:08 <jusss> heatsink: with the defualt prefix config?
22:39:21 <heatsink> I don't know what that means
22:39:38 <heatsink> If you're used to bracket languages like C, indentation works a little differently for Haskell
22:39:49 <jusss> heatsink: sorry for my bad English, I mean you didn't change anything in the emacs configu for that haskell-mode?
22:40:30 <heatsink> I installed it a long time ago, so I don't remember if I changed the configuration 
22:40:41 <jusss> heatsink: yeah, I found that haskell need proper indentation like python, otherwise it will cause errors
22:41:04 <heatsink> haskell-mode has a readme describing configuration options
22:41:31 <jusss> the autoindentation, I have met, see this code https://paste.ubuntu.com/p/j6nkbfFwMv/
22:41:47 <jusss> heatsink: I just press one tab, and it has that indentation
22:42:02 <jusss> heatsink: that's totally wrong
22:42:10 <heatsink> In Haskell, like Python, there are multiple valid indentation levels and the editor will choose one
22:42:25 <heatsink> press tab repeatedly to go through all valid indentation levles
22:42:26 <jusss> that 4th, 5th, and 6th indentation, 
22:43:17 <jusss> heatsink: I just press once tab, and it shows its indentation as that way, which is improper
22:43:35 <heatsink> It is proper if you want to continue the same statement
22:43:41 <jusss> I really don't know what's wrong with my haskell-mode or emacs
22:44:06 <jusss> heatsink: ghc wouldn't think that
22:44:12 <jusss> ghc think that's wrong
22:45:54 <heatsink> It is wrong in this case because the `<-` isn't valid
22:46:03 -heatsink(~heatsink@2600:1700:bef1:5e10:ec7e:a4f6:13d8:3656)- But consider for example
22:46:16 <heatsink> hPutStr stdout
22:46:21 <heatsink>       "Message"
22:47:00 <heatsink> Because the string is indented, it is part of the previous statement.  It is not a new statement.
22:47:26 <jusss> heatsink: you mean I have the wrong indentation style?
22:47:33 <heatsink> No
22:48:36 <heatsink> I mean that the editor supports this kind of indentation because it is useful sometimes.
22:48:59 <jusss> heatsink: I don't get it, string should get a single line?
22:49:15 <heatsink> In that paste where line 5's indentation is wrong, go to line 5 and press *tab* *tab* *tab* *tab*
22:49:37 <heatsink> Does the editor change to different indentation levels?
22:49:51 <jusss> heatsink: yeah, it changed its position
22:49:58 <heatsink> One of those levels is aligned with the previous line, right?
22:50:08 <jusss> heatsink: but I don't get it, it should be at the right place at first?
22:50:17 <jusss> shoudn't
22:50:34 <jusss> heatsink: yeah, aligned
22:50:38 <ski> (how can it know what's the right place, for what you intend to write ? it can't read your mind)
22:50:51 <heatsink> The first option is the right place to continue the previous statement.  The second option is the right place to start a new statement.
22:52:03 <ski> (also, it's not informed by types of things, so it doesn't know whether all arguments have been supplied to the command started on the previous line yet)
22:52:27 <jusss> ski: heatsink I found that I need to press twice tab to get 5th and 6th line to get the right place
22:52:43 <dminuoso> ski: I suppose the notion of "all arguments" is deeply troubled from a type system point of view anyhow.
22:52:44 <ski> sounds plausible
22:52:56 <jusss> heatsink: can I reverse that?
22:53:08 <jusss> new statement first, continue second
22:53:19 <jusss> I hated every line to press twice tabs
22:53:23 <ski> dminuoso : the Alfa structural editor for Agda1 could do "something like this"
22:53:23 <jusss> that's insane!
22:53:31 <heatsink> I don't know of a way to change that
22:53:51 <jusss> heatsink: so you always press twice tabs?
22:54:01 <jusss> or more?
22:54:03 <heatsink> I checked.  My editor doesn't do that
22:54:16 <heatsink> sorry, I don't know the reason
22:54:31 <dminuoso> Is there a way to override an INLINE pragma?
22:55:22 <dminuoso> In particular I have a library that grossly overuses INLINE to the point of exploding compile time to 50s, and I sort of want to use some primitive without it being INLINEd. I can live with slow runtime performance.
22:55:33 <heatsink> Could you define a NOINLINE wrapper around the inline function?
22:55:47 <dminuoso> Interesting
22:56:02 <ski> dminuoso : if you were standing on a hole of type `List Nat', and pressed say `"ae"' (say current disambiguation completion for `append'), it'd fill in the hole with application of `append' to three arguments (the type `Nat', and two new fresh holes)
22:57:08 <zzing> What would be a typical approach to taking writing [Maybe a] -> Maybe [a]  such that if any items in the list are Nothing, then whole thing becomes Nothing, otherwise it becomes Just the list without the inner Justs?
22:57:19 <dminuoso> heatsink: Curious, not working.
22:57:46 <MarcelineVQ> zzing: are you wanting to make that or want something that does that?
22:57:47 <dminuoso> heatsink: But perhaps I have to move it into a separate module at least?
22:57:59 <ski> dminuoso : only operations whose return type would fit the type of the hole would be listed in the current list of things to insert / refine with (and the disambiguation characters would be computed on the fly from what's currently in the list. one could also click on the option one wanted)
22:58:13 <zzing> MarcelineVQ, something that does it so I can look at it would be great. I tried hoogle already :P
22:58:30 <MarcelineVQ> it's called sequence
22:59:10 <dminuoso> ski: Ah that's rather interesting.
22:59:13 <heatsink> dminuoso, you could try.  I'm not so familiar with how the inliner will handle that
22:59:57 <heatsink> looking at sequence might be mystifying rather than enlightening
23:00:00 <ski> dminuoso : in some ways, i preferred Alfa, to the current Emacs mode
23:00:01 <zzing> MarcelineVQ, sequence looks like it dealing with Monad. 
23:00:21 <zzing> SequenceA perhaps? 
23:00:33 <ski> zzing : `sequenceA' is the same thing
23:00:48 <ski> zzing : `Maybe' is both an instance of `Applicative', and of `Monad'
23:00:52 <MarcelineVQ> Either way, Maybe is Applicave and Monad
23:00:54 <zzing> oh I see that now
23:01:10 <zzing> It definitely is mystifying :-)
23:01:26 <ski> `sequence' exists because of hysterical raisins
23:01:49 <zzing> What is the general theory of operationn of this?
23:02:39 <ski> zzing : `sequence' will compute a new `Maybe'-action that when run, will run all the `Maybe'-actions in the list, collecting all the individual results into a new list
23:02:46 <dminuoso> % :t sequence
23:02:46 <yahb> dminuoso: (Traversable t, Monad m) => t (m a) -> m (t a)
23:02:51 <dminuoso> % :t sequenceA
23:02:51 <yahb> dminuoso: (Traversable t, Applicative f) => t (f a) -> f (t a)
23:03:46 <ski> zzing : in the case of `Maybe', "running" means checking that you get `Just x' (`x' being the "monadic result"), rather than `Nothing'. if you get the latter at any point, you short-circuit the execution of the actions, aborting, yielding `Nothing' as result from the whole thing
23:03:54 <jusss> heatsink: I found the reason, haskell-indent-mode is not t
23:04:08 <jusss> heatsink: it's nill default
23:04:37 <ski> and `[]' (the type "list of") is an instancce of `Traversable'. one can also `sequence'/`sequenceA' through other traversable collections than lists
23:04:40 <dminuoso> zzing: sequenceA was just introduced as an after thought. Ideally you could imagine `sequenceA` was named `sequence`, and the original `sequence` tossed away.
23:04:42 <heatsink> oh, I see
23:05:03 <dminuoso> zzing: The reason this wasn't actually done was subtle performance concerns. :)
23:07:01 <MarcelineVQ> jusss: t?
23:07:40 <ski> (`t' is the standard value for true, in Emacs Lisp)
23:07:55 <MarcelineVQ> oh good, was worried it was short for tab
23:08:55 <ski> (i think, sometimes, settings use `nil' ("false") and `t' ("true") for settings, but also other options are allowed. a bit like `data Bool = False | True | FileNotFound', perhaps)
23:10:08 <heatsink> juss: Since you mention it, I found the documentation page suggests to add a command to .emacs
23:10:21 <heatsink> jusss: http://haskell.github.io/haskell-mode/manual/latest/Indentation.html#Indentation
23:10:22 <jusss> MarcelineVQ: true
23:10:32 <zzing> Thanks for the insight
23:11:37 <jusss> heatsink: that haskell-indent-mode is better than haskell-indentation-mode, why people choose that as default?
23:12:01 <heatsink> I don't know
23:14:10 <jusss> heatsink: after put this line `(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)' into my .emacs, it finally works as I want
23:15:05 <heatsink> excellent
23:16:44 <jusss> heatsink: and I think electric-indent-mode works well too
23:17:14 <jusss> heatsink: I needn't to press tab and it will auto just to the right place with electric-indent-mode
23:17:21 <jusss> jump
