00:04:52 <jusss> how to call main in main?
00:04:59 <jusss> main = do ... main?
00:05:40 <jusss> like if I input abc then print abc, exit until I input nil
00:07:40 <kaol> How about this: main = forever $ do ...
00:10:28 <jusss> kaol: then how to exit?
00:10:28 <kaol> And stop with exitSuccess.
00:11:13 <koz_> main :: IO ()
00:11:14 <koz_> main = main
00:11:17 <koz_> :D
00:26:38 <jle`> jusss: all bindings in haskell are recursive
00:26:41 <jle`> so you can refer to main in main
00:26:49 <jle`> just like how you can do `ones = 1 : ones`
00:26:56 <jle`> @let ones = 1 : ones
00:26:58 <lambdabot>  Defined.
00:26:59 <jle`> > ones
00:27:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:28:17 <ariakenom> main = do {print 1; main}
00:29:59 <dminuoso> jusss: In principle you could do `main = do ... if x then main else pure ()`, but exitSuccess would instantly abort the program without you having to hoist the end of the program up into main.
00:30:13 <jle`> main = do
00:30:17 <jle`>   abc <- getLine
00:30:22 <jle`>   putStrLn abc
00:30:31 <jle`>   when (not (null abc)) main
00:30:53 <jle`> (to translate what the original question directly)
00:31:30 <jle`> hm i guess i didn't really implement 'exit until i input nil'; this part i don't really understand
00:31:40 <trcc> So I was suggested to use text instead of string, but whenever I write "something" I get strings. Additionally, i.e. http://hackage.haskell.org/package/process-1.6.6.0/docs/System-Process.html#v:readProcessWithExitCode returns string. Is there some easy way of using Data.Text.Lazy.Text that I am missing?
00:32:00 <jle`> trcc: yeah, you can use Text with string literals if you turn on -XOverloadedStrings
00:32:16 <dminuoso> trcc: T.pack can be used to glue with code that returns String instead.
00:32:23 <trcc> jle`: thanks!
00:32:27 <jle`> {-# LANGUAGE OverloadedStrings #-} at the top of your file or something
00:32:40 <trcc> dminuoso: does that not make it less efficient if I pack my code with T.pack?
00:32:41 <jle`> but yeah, this would only affect literals. you can use T.pack to convert a String into a Text
00:32:53 <jle`> trcc: less efficient than one?
00:32:56 <jle`> *than what
00:33:07 <trcc> than just keeping the string. I do not perform much processing
00:33:08 <dminuoso> trcc: You dont have much choice really. If libraries expose String interfaces you are a slave to GHC optimizations.
00:33:24 <jle`> you can keep the string if you want, but you can't give it to a function that expects Text unless it's a string
00:33:35 <jle`> er, unless it's a Text
00:33:48 <jle`> trcc: so "just keeping the string" won't even compile/doesn't work :)
00:33:53 <jle`> so technically it is infinitely less efficient
00:34:23 <dminuoso> jle`: Presumably you'd get the same behavior from using `T.pack` rather than overloaded strings, right?
00:34:24 <ariakenom> (an overloaded literal is the same as T.pack)
00:34:38 <jle`> we're not comparing overloaded strings with text here
00:34:38 <ariakenom> (eh perf wise)
00:34:46 <jle`> we're comparing packing a string vs. keeping it as String
00:34:46 <dminuoso> ariakenom: Note that we're dicussing two different things. One is about string literals, the other is about interfacing with library functions.
00:34:54 <trcc> yes I am asking both :D
00:34:57 <jle`> keeping it as String isn't even an option
00:35:09 <ariakenom> interact (unlines . takeWhile (not.null) . lines)
00:35:12 <jle`> so it wouldn't really be 'more efficient'
00:35:36 <dminuoso> Are there any parser combinator libraries that can operate on text?
00:35:42 <jle`> most of them do i think
00:35:46 <trcc> jle`: I am trying in general to understand the text / string thing. I.e. if I just need to print something to the screen that I get from http://hackage.haskell.org/package/process-1.6.6.0/docs/System-Process.html#v:readProcessWithExitCode, is it then worth doing t.pack?
00:36:00 <jle`> trcc: it's only worth it if you use the Text
00:36:02 <dminuoso> jle`: At least megaparsec cant out of the box?
00:36:12 <jle`> trcc: if you never use the Text, then it's not worth it
00:36:17 <jle`> trcc: if you use the Text, then it's worth it :)
00:36:37 <trcc> and use the text means: processing or passing it to functions only operating on Text?
00:36:54 <jle`> dminuoso: megaparsec should be able to i think? there's an instance of Stream for Text
00:36:59 <jle`> trcc: yeah
00:37:09 <trcc> okay thank you. That clarified stuff. 
00:37:16 <trcc> thank you both :)
00:37:16 <jle`> if you just use T.pack and then throw away the result, it's definitely not worht it :)
00:37:21 <trcc> hehe
00:37:22 <jle`> but if you use the result, i'd say it's worth it
00:37:29 <trcc> I jsut print it
00:37:32 <trcc> with putStrLn so
00:37:41 <jle`> ah, putStrLn from prelude doesn't even take Text, it takes String
00:37:43 <dminuoso> jle`: Mmm, what's the underlying token type for that? :o
00:37:55 <jle`> so converting it would do no good if you're using Prelude.putStrLn
00:38:14 <jle`> trcc: however Data.Text.IO has putStrLn :: Text -> IO (), which can be useful if you already have Text and you're in the world of Text
00:38:27 <dminuoso> Ah it makes sense, it'd be Char.
00:38:50 <dminuoso> Though I guess at that point you dont get much benefit from Text over String.
00:38:52 <trcc> I will have to get into the world of text later on
00:39:04 <trcc> thank you
00:39:12 <jle`> trcc: yeah, things usually work smoothly if you're just using Text only and never String, etc.
00:39:29 <jle`> it's just when libraries expect different types that you have to deal with conversion, which can admittedly be pretty annoying
00:39:33 <trcc> so data text io or data text lazy io?
00:39:40 <trcc> yes I will have to do that, i.e. for the functino I said
00:39:48 <jle`> the fact that String exists and proliferates the ecosystem so widely is definitely a wart in haskell ecosystem
00:39:57 <dminuoso> jle`: And then you have to handroll a Ppr class or end up with `showT = T.pack . show` and use it all over your code. :P
00:40:16 <jle`> trcc: the first one works for "strict Text" and the second one works for "lazy text"
00:40:32 <jle`> which are also two different types that you may end up having to manually convert between, which is kind of annoying too
00:41:01 <koz_> Haskell: Where it is good to be lazy.
00:41:10 <koz_> Also, hi jle`!
00:41:14 <jle`> hi :)
00:41:31 <dminuoso> koz_: I think some of the lazyness is ill placed.
00:41:45 <jle`> s/is good/can be good
00:41:52 <jusss> dminuoso: jle` about do syntax, why we always put actions into it?
00:42:10 <dminuoso> koz_: Lazy evaluation is a great feature, but types with lazy semantics like lazy text frequently feels like a mismatch (conduit and friends are better streaming abstractions)
00:42:19 <jle`> jusss: are you asking why the only thing we put in it are actions
00:42:30 <jle`> jusss: or are you asking why, if we have actions, we tend to put them in do blocks
00:42:35 <koz_> dminuoso: Yeah, agreed.
00:42:37 <jusss> jle`: both
00:42:43 <jle`> the first one: because only 'm a's are allowed as lines of a do block
00:42:50 <jle`> the second one: because it is convenient/cleaner to read
00:43:05 <jusss> jle`: but something are not actions, main is an action?
00:43:17 <jle`> we consider main an IO action, yeah
00:43:18 <jle`> main :: IO ()
00:43:30 <dminuoso> jusss: do-notation is just syntax sugar for Monad, and we tend to think of Monads as modelling effects, so values of some type `m a` for some choice of M can usually be thought of as actions.
00:43:46 <jle`> action is not a formal term, but in this context we refer to it as a value of type `m a` for some m and a
00:43:50 <jusss> jle`: aha, so it means, we can only put monadic actions into do-block?
00:43:57 <dminuoso> jusss: Sure. You could say that.
00:44:05 <jusss> dminuoso: ok
00:44:06 <trcc> Well scotty uses text lazy, so that is what i'll do. Thanks
00:44:07 <jle`> jusss: in a single-line do block, not necessarily
00:44:17 <jle`> jusss: but as soon as you have more than one line, you need >> or >>=
00:44:25 <jle`> which requires a Monad instance, and to have type 'm a'
00:44:35 <jle`> that's because `do x` is desugared as `x`
00:44:38 <dminuoso> Well the way the question was phrased "we can only put monadic actions into do-block?" juss is right.
00:44:47 <jle`> but `do x; y` is desugared as `x >> y`
00:44:50 <dminuoso> You cannot put non-monad things into do-blocks (unless you enable ApplicativeDo).
00:44:54 <jle`> > do True
00:44:56 <lambdabot>  True
00:45:04 <dminuoso> Oh.
00:45:12 <dminuoso> TIL.
00:45:17 <dminuoso> I did not expect that. :-)
00:45:27 <jle`> do blocks can contain anything, but as soon as you string multiple lines together, you connect them with >> or >>=, so that's when the 'monadic action requirement' starts happening
00:45:40 <jle`> dminuoso: back in the day we used to use this trick to get rid of $'s or parentheses :)
00:46:04 <jle`> > 1 * do 3 + 4
00:46:06 <lambdabot>  7
00:46:13 <jle`> whoops, bad example
00:46:21 <jle`> > 2 * do 3 + 4
00:46:23 <lambdabot>  14
00:46:31 <jusss> dminuoso: can we think putStrLn return an action, and that action will be executed? all the actions will be executed immediately when it shows up?
00:46:48 <jusss> % :t putStrLn
00:46:48 <yahb> jusss: String -> IO ()
00:46:56 <jle`> jusss: actions aren't really "executed" in Haskell evaluation of values, we just define them
00:47:10 <jle`> jusss: saying `main = putStrLn "hi"` means that we are defining 'main' as the IO action that puts "hi"
00:47:17 <jle`> we're *describing* an IO action
00:47:42 <jle`> then later when we compile the code, we are really compiling an IO action into bytestring, like an IO () -> Binary code
00:47:45 <jle`> *function
00:48:10 <jle`> GHC takes the IO action that describe and name 'main', and translates it into bytecode
00:48:26 <jle`> *the IO action that you describe, that is named 'main'
00:48:33 <jusss> jle`: oh, I forget that, actions only be executed when put them into `main'
00:48:40 <ariakenom> jle`: I dont really care for this perspective
00:48:51 <jle`> jusss: so note if you had a file like `main = putStrLn "hi"; myOtherThing = putStrLn "bye"`, if you compile it, GHC will compile 'putStrLn "hi"`, the IO action
00:49:09 <jle`> it has to pick one action to compile, so it uses the one you name 'main', arbitrarily
00:49:33 <ariakenom> oh no sorry I misunderstood the convo again
00:49:36 <jle`> you really could imagine that it could turn main into your binary, or it could turn myOtherThing into your binary. it just chooses main because that's what we agree upon
00:49:41 <ariakenom> let me go get some coffe ...
00:49:46 <jusss> jle`: but if we put those actions into do-block, we pass main = do ... we can run more actions?
00:49:54 <jle`> ariakenom: feel free to elaborate after coffee :)
00:50:04 <jle`> jusss: not quite; main is always a single IO action
00:50:15 <jle`> but, we can use the IO API in ghc to create complex IO actions out of simpler ones
00:50:21 <jle`> for example, (>>) :: IO a -> IO b -> IO b
00:50:29 <jle`> (>>) takes two IO actions and returns a new one
00:50:44 <jle`> so it would take `putStrLn "hi"` and `putStrLn "bye"`, and it would return `putStrLn "hi\nbye"`
00:51:24 <jle`> so main is a single IO action, but we can 'construct' IO actions by combining them using the functions ghc gives us
00:51:26 <jusss> jle`: will `do' notation combine them to one?
00:51:34 <jle`> jusss: `do x; y` is sugar for x >> y
00:51:47 <jle`> yes, essentially. it combines them into one single IO action, which is all of its lines done sequentially
00:52:11 <jle`> so it's like myList = [1,2,3] ++ [4,5,6].  myList is a single list, but we can construct myList by appending together several simpler lists
00:52:28 <jusss> jle`: then what `sequence' is used for?
00:52:32 <jle`> main is a single IO action, but we can construct that IO action by 'appending' (or 'sequencing') together several simpler IO actions
00:52:41 <jle`> jusss: sequence [x,y,z] = x >> y >> z
00:52:44 * hackage mmsyn3 0.1.1.1 - A small library to deal with executable endings  https://hackage.haskell.org/package/mmsyn3-0.1.1.1 (OleksandrZhabenko)
00:52:56 <jle`> so it can be convenient if you have a list of IO actions, and you want to turn it into one big IO action
00:52:59 <koz_> So basically we get one gigantic IO action, which main will execute.
00:53:03 <jle`> sequence :: [IO ()] -> IO ()
00:53:15 <jusss> jle`: `sequence' can combine actions into one like `do' ?
00:53:21 <jle`> actually that's one of the benefits of IO-as-data, I think.  because you can think of many ways you could write [IO ()] -> IO ()
00:53:36 <jle`> you could create a new action that does all of the items in a sequence
00:53:43 <jle`> or you could create one that does them all in parallel
00:53:52 <jle`> jusss: yeah, in the end the main mechanism is (>>)
00:53:58 <jle`> do x; y; z  == x >> y >> z
00:54:05 <jle`> sequence_ [x,y,z]  == x >> y >> z
00:54:10 <jle`> both are basically wrapping around usage of >>
00:55:17 <jle`> but do blocks are a bit more powerful because you can do more than just >> with them
00:55:20 <ariakenom> jle`: no no. I agree with you, I just failed reading :p
00:56:11 <jusss> jle`: is that all the actions are monadic actions? which means all the actions contain monad?
00:56:27 <jle`> well it just means that they have an instance of Monad m
00:56:29 <jle`> because:
00:56:32 <jle`> :t (>>)
00:56:33 <lambdabot> Monad m => m a -> m b -> m b
00:56:56 <jle`> so you could technically write do True; False; True, but then that would desugar to True >> False >> True, and that's a type error
00:57:10 <jle`> so it's really just back to normal typechecking rules, nothing super special
00:57:14 * hackage mmsyn4 0.1.1.1 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.1.1.1 (OleksandrZhabenko)
00:57:41 <jle`> the main 'monad' restriction is in the type of (>>), the glue between the lines
00:58:02 <jusss> jle`: this >> is look like const
00:58:06 <jusss> :t const
00:58:07 <lambdabot> a -> b -> a
00:58:13 <jle`> indeed the type is similar
00:58:27 <jle`> but because we have some constraints, we get some more interesting functions
00:58:35 <jle`> > Just 3 *> Just 10
00:58:38 <lambdabot>  Just 10
00:58:43 <jle`> > Nothing *> Just 10
00:58:45 <lambdabot>  Nothing
00:58:58 <jle`> but yeah, (>>) can be defined as `liftA2 (flip const)`
00:59:04 <jle`> so that's the similarity you are seeing
00:59:07 <jle`> :t liftA2 const
00:59:09 <lambdabot> Applicative f => f c -> f b -> f c
00:59:10 <jle`> :t liftA2 (flip const)
00:59:12 <lambdabot> Applicative f => f b -> f c -> f c
00:59:17 <jusss> jle`: what its name of >> ?
00:59:39 <jle`> some people like to call it 'andThen' or 'then'
00:59:53 <jle`> maybe you can say 'sequenced with'
00:59:57 <jusss> my mother language is not English, I don't understand why there're so many same functional names in haskell
01:00:11 <jle`> historical reasons, mostly
01:00:20 <jle`> if we were to start over from scratch today, it would be a little cleaner
01:00:33 <jle`> but we have thirty years of baggage to drag us down :'(
01:00:38 <koz_> Very much this.
01:00:48 * koz_ evil eyes String.
01:01:05 <jle`> actually we are nearing the 30th birthday of Haskell
01:01:13 <jle`> i wonder if anyone has anything fun planned
01:01:25 <jusss> jle`: is there  big changes those years?
01:01:42 <jle`> some big changes but mostly many small changes that add up
01:01:51 <jusss> jle`: I'm at the same age with haskell :)
01:01:53 <jle`> ah, 166 days until Haskell turns 30
01:02:03 <jle`> quick, someone plan a surprise party
01:02:12 <jle`> jusss: hah :) we are about the same age then
01:02:22 <jusss> jle`: wow :)
01:02:27 <koz_> I'm a bit older than Haskell then.
01:02:39 <jle`> haskell is a little older than me and a little younger than taylor swift
01:02:58 <jusss> jle`: there're lots of things happen in 1990
01:03:37 <jle`> indeed
01:03:38 <jusss> and 1989
01:04:39 <jusss> jle`: do you speak other langues?
01:04:48 <jusss> or code :)
01:04:59 <jle`> of natural languages, mostly just english and vietnamese
01:05:56 <jusss> wow, cool
01:19:04 <dminuoso> Mmm, with megaparsec I want to do `x <- ident; case x of "foo" -> ..; "bar" -> ..; _ -> fail "unknown bar"` - but that reports the error at the wrong position (because the thing Im reporting on is already consumed). How do I handle this correctly?
01:20:29 <Rembane> dminuoso: Can you look into the future, see if you can fail and then fail, otherwise do the right thing? 
01:21:12 <dminuoso> Rembane: Are you suggesting I should wrap this with try?
01:24:30 <jle`> dminuoso: (.. <$ string "foo") <|> (.. <$ string "bar") <|> ... , maybe?
01:24:35 <jle`> or 'choice'
01:25:24 <dminuoso> jle`: megaparsec is filled so much with INLINE, that this destroys compilerperformance.
01:25:37 <Rembane> dminuoso: Yes, I was thinking there was another lookahead-operator, but I can't remember it right now
01:25:59 <merijn> Pretty sure there is a lookahead, yes
01:27:42 <dminuoso> jle`: With the number of branches I have, the most minimalistic example of that style takes about 50 seconds to compile alone.
01:27:55 <dminuoso> (Which admittely is just a bug in megaparsec, but that doesnt really help me)
01:29:12 <merijn> dminuoso: Time to rewrite using alex and happy ;)
01:31:50 <Lears> dminuoso: Rather than prioritising compile speed over run-time speed in your code, it seems like something you should control by giving ghc flags to disable/reduce optimisations?
01:33:37 <merijn> Lears: Easy to say when your compiles aren't soulsucking
01:36:15 <dminuoso> Lears: Heh its funny I didn't even think of that. osa1 even said my problem doesn't exihibit on other optimization levels, but I didn't manage to think of that.
01:37:52 <merijn> Actually, speaking of soulsucking compiles
01:38:11 <merijn> Is there a way to parallelise compilation within a package?
01:38:54 <merijn> Building my dependencies is actually less frustrating than my own code, because at least I can parallelise that >.>
01:38:59 <Taneb> cabal build -j?
01:39:28 <merijn> Taneb: No
01:39:36 <merijn> Taneb: That builds *packages* in parallel
01:39:39 <MarcelineVQ> merijn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--j[⟨n⟩] but dependency caveat, so idk
01:40:05 <merijn> I'm already building with "cabal -j24", but that doesn't help for rebuilding just my code
01:40:46 <dminuoso> merijn: You could split your code into more packages! :D
01:41:02 <ariakenom> upgrade your ILP! :D
01:41:04 <merijn> dminuoso: Can't really do that
01:42:38 <merijn> hmm, let's see if adding "ghc-options: -j" has any benefits
01:43:06 <dcoutts> one day we'll get cabal doing module level parallelism, as well as across package components
01:43:14 <merijn> Hah
01:43:39 <merijn> With "ghc-options: -j" GHC's CPU usage in top jumps to 1000%, so it's doing something :p
01:44:10 <merijn> Not sure how much gain it actually produces in the end
01:44:11 <dcoutts> probably not worth going over --ghcoptions=-j4 or so
01:44:23 <dcoutts> erm --ghc-options=-j4
01:45:02 <merijn> dcoutts: How so?
01:46:13 <merijn> -O0 build takes 4m3s, with ghc-options -j it takes 4m7s, so that's not really very useful >.> 
01:48:48 <MarcelineVQ> if you edit a file and there's rebuilding to do it's probably due to a dependency chain, so there's not a lot to para, maybe
01:51:31 <merijn> MarcelineVQ: There's quite a lot of independent modules in the middle. So I have a few core modules almost everything depends on, and then a large number of almost completely orthogonal ones that could easily be built in parallel
01:51:44 <merijn> -j4 seems to cut compile time to 2m
01:52:02 <merijn> So it seems more likely that GHC's parallel build implementation is just dumb
01:52:56 <MarcelineVQ> and yet these are the guys that wrote builds systems a la carte!​ :>
01:53:37 <merijn> GHC uses none of that, so...
02:09:30 <Taneb> Is there anything made for lazy parsing of formats with skippable components?
02:10:11 <merijn> Taneb: What do you mean by "lazy parsing" you mean just skipping over them?
02:10:35 <Taneb> merijn: only parsing part of the data structure when it's actually needed
02:11:02 <merijn> I don't think there's anything to retro-actively do that in an existing parser, no.
02:11:12 <Taneb> Hmm
02:12:24 <ski> hm, i suppose that would require knowing how many tokens/whatever belongs to a particular substructure
02:12:51 * ski . o O ( <https://en.wikipedia.org/wiki/Interchange_File_Format> )
02:14:03 <Boomerang> Taneb: If you have some tokens that help you split your components maybe something like this could help https://haskell-works.github.io/posts/2018-08-01-introduction-to-rank-select-bit-string.html
02:15:48 <Taneb> Boomerang: I've read that before, I might have had it somewhere in my subconscious
02:16:46 <ski> hm, now i'm reminded of wanting intersection (and difference) for regexen, and parsers
02:17:00 <ski> (also "division / derivative")
02:22:08 <ariakenom> ski: I seeing a paper a paper about that
02:30:41 <ariakenom> ski: finally found the one I was thinking about https://www.cs.kent.ac.uk/people/staff/sao/documents/jfp09.pdf
02:31:15 <ariakenom> and https://hackage.haskell.org/package/kleene-0.1
02:31:54 <ski> interesting, ty
02:32:32 <ski> one can also divide by an arbitrary regex, not just by a single token
02:32:49 <ski> (and this is an adjunction)
02:34:01 <ski> hm, i remember seeing somewhere, how one can use derivatives, to (re)derive a finite state automaton, from a regex description
02:34:18 * ski doesn't remember details, though :/
02:34:57 <ski> ah, perhaps this paper goes into that
02:35:44 <ariakenom> ski: yes. unless my memory fails me
02:38:33 * ski idly wonders whether one might use some techniques used to more efficiently implement Lolli (a linear logic programming language), in order to achieve efficient matching/parsing implementations of intersection, difference, "derivative", division
04:02:01 <jpe> Anyone know if theres a command in ghci that will let me see everything I defined so far? So if I just open ghci and I do a bunch of (f = blah) it'll print them so I can save them somewhere?
04:03:03 <merijn> jpe: hmm, not that I'm aware of? You can have a look through the GHC user guide if there's anything in there
04:03:07 <jpe> oh wait it's ":show bindings"
04:03:29 <jpe> well that doens't give me everything
04:03:32 <merijn> jpe: That seems to only show names and types, though. Not implementations
04:04:25 <jpe> I can just ":print" everything now because it's not that much
04:04:58 <merijn> Does that do what you want? Because when I try it here that doesn't seem like what you want
04:05:30 <jpe> oh that still just only shows the type
04:11:02 <boxscape> jpe not an ideal solution but I think the best you can do is using the ghci history file somehow
04:15:49 <dminuoso> jpe: You could tap into TemplateHaskell I suppose.
04:17:53 <dminuoso> Ah mmm reifyModule only seems to give you imports
04:22:25 <boxscape> % module M () where data T = T -- hm, apparently you can do this in ghci, but the "module M () where" part has zero effect on what this declaration means, I think
04:22:25 <yahb> boxscape: 
04:22:29 <boxscape> % T
04:22:29 <yahb> boxscape: ; <interactive>:13:1: error:; * No instance for (Show T) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
04:22:51 <boxscape> % M.T
04:22:51 <yahb> boxscape: ; <interactive>:14:1: error:; Not in scope: data constructor `M.T'; No module named `M' is imported.
04:27:38 <boxscape> % magicDict @Bool
04:27:38 <yahb> boxscape: ghc: ^^ Could not load 'ghczmprim_GHCziPrim_magicDict_closure', dependency unresolved. See top entry above.; ByteCodeLink.lookupCE; During interactive linking, GHCi couldn't find the following symbol:; ghczmprim_GHCziPrim_magicDict_closure; This may be due to you not asking GHCi to load extra object files,; archives or DLLs needed by your current session. Restart GHCi, specifying; the missing libra
04:29:55 <boxscape> Is that supposed to happen? I actually have no idea what magicDict does, ghc just suggested it to me in a typed hole
04:31:23 <boxscape> "magicDict [...] is a special identifier which does not exist at runtime." sounds like it's expected behavior then
04:32:42 <hpc> it's just not magic enough ;)
04:33:30 <boxscape> indeed
04:40:56 <hpc> there isn't a whole lot of documentation on what magicDict does
04:41:00 <hpc> that i could find, anyway
04:46:25 <boxscape> I'm sure there's a "Note" somewhere in the ghc source code
04:48:48 <boxscape> yup https://gitlab.haskell.org/ghc/ghc/blob/0dad81ca5fd1f63bf8a3b6ad09787559e8bd05c0/compiler/basicTypes/MkId.hs#L1630
04:52:14 <hpc> nice
04:54:14 <Guest_64> I can't install Haskell on my Mac. I get the following error: Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed! Can you help me?
04:54:33 <Guest_64> I am completely new to Haskell btw
05:00:40 <ariakenom> Does merijn think passing an array of floats to opengl to be easy in haskell?
05:04:14 <merijn> ariakenom: I've never used opengl, tbh
05:04:36 <merijn> ariakenom: on the other hand, the opengl API is (afaik) fairly similar to OpenCL, so shouldn't be too hard
05:07:23 <ariakenom> merijn: I just saw a reddit post where tdammers said it was cumbersome. But I vaguely remembered you saying working with C interfacs being easy
05:08:08 <merijn> ariakenom: The Open* interfaces are (themselves) utterly cumbersome, yes
05:08:21 <merijn> Like...utter trash that no sane human wants to use directly
05:08:39 <merijn> However, making Haskell interact with those interfaces is fairly straightforward
05:08:58 <merijn> That just doesn't remove any of the "suck" until you build a higher level API on top of it :p
05:09:24 <ariakenom> the argument  was that it was more cumbersome in hs than in C. 
05:11:34 <Guest_19> Hallo, I have a question
05:13:00 <Guest_19> I have a MacBook Pro and want to Install Haskell. I followed the instructions in the Terminal and no I am told: Detected ~/.bash_profile on your system...
05:13:50 <Guest_19> what exactly does that mean? 
05:14:12 <brnzz> Guest_19: instructions from where?
05:14:54 <MarcelineVQ> it's ghcup and that's only part of the massage
05:15:33 <MarcelineVQ> there's a weird influx of mac users stuck on being able to google 'bash profile' or 'path'
05:17:22 <Guest_72> Hallo, I just asked a question and than accidentally left.. 
05:17:37 <Guest_72> Can you See the question anyways?
05:18:54 <ski> <brnzz> Guest_19: instructions from where?
05:18:57 <ski> <MarcelineVQ> it's ghcup and that's only part of the massage
05:19:00 <ski> <MarcelineVQ> there's a weird influx of mac users stuck on being able to google 'bash profile' or 'path'
05:19:03 <ski> Guest_72 ^
05:20:23 <MarcelineVQ> You didn't paste the whole output but iirc it says do you want to add "source .ghcup/env/" or something to your bash_profile. afaik you do want to
05:20:37 <MarcelineVQ> but I don't have ghcup so I can't confirm
05:36:08 <tdammers> my experience with OpenGL on Haskell is indeed that it is more cumbersome that straight-up talking to OpenGL from C
05:37:23 <tdammers> it's not just the fact that you need to figure out how to coerce Haskell into giving you a stable memory location, and managing the lifecycle of that somehow (which I find easier in C++, somehow)
05:37:58 <tdammers> it's also that the types you get on the Haskell side aren't compatible between bindings to libraries that *are* compatible on the C side
05:38:15 <tdammers> (then again, this isn't so much about OpenGL itself, but more about everything around it)
05:50:05 <LCRERGO> Hi is it possible to do file processing with ghci?
05:51:28 <phadej> yes
05:51:35 <svipal> o/
05:51:42 <phadej> input <- readFile "myfile.txt"
05:51:49 <phadej> and then only sky is the limit
06:16:47 <merijn> tdammers: What's wrong with just ForeignPtr?
06:17:26 <literallyCrevice> In aeson, I can do x .: "key" to get x["key. How can I get x["key"]["
06:17:42 <literallyCrevice> Hol up, once again: In aeson, I can do x .: "key" to get x["key"]. How can I get x["key"]["key2"]?
06:18:13 <tdammers> merijn: I don't remember, hah
06:18:45 <tdammers> I think the problem was not so much getting a ForeignPtr and passing it to OpenGL, but to efficiently move data from more convenient Haskell data structures into that
06:19:09 <merijn> tdammers: Sure, but something like "an array of float" like the original question was is pretty trivial :)
06:19:36 <tdammers> yeah, but if I'm going to write C in Haskell, might as well just go for C
06:21:08 <merijn> cocreature: Ping? I'm doing another attempt to see if I can get ghcide to play somewhat nicely with my TH containing project, so I was wondering if it's likely to work (for the non-TH modules) if I can coax it into using -fobject-code
06:21:57 <merijn> I guess that'd involve pointing it to the object/.hi files somehow
06:27:14 <c_wraith> literallyCrevice: that's not a use case aeson's interface makes easy.  There's no approach that's really better than binding the result of x .: "key" and then using something like withObject
06:28:03 <lyxia> There's a lens package for aeson that might be useful for this
06:29:41 <cocreature> merijn: no idea if -fobject-code works, I wouldn’t be surprised if it doesn’t.
06:29:42 <c_wraith> I assumed someone using (.:) is writing a FromJSON instance, where lenses won't help as much
06:30:10 <cocreature> merijn: splitting the TH code into a separate package seems more likely to work
06:31:35 <merijn> cocreature: hmm, actually, would it work to move it to a separate component? Or would it really have to be a separate package?
06:31:53 <cocreature> merijn: given that we don’t load multiple components at once atm, that should be sufficient
06:32:45 <merijn> Actually, I guess it isn't sufficient because a bunch of stuff in different components also didn't load because it dependend on modules with TH
06:32:58 <literallyCrevice> c_wraith: Well, that sucks. I'll go for Data.Aeson.Lens I guess
06:33:38 <merijn> But I have to first rollback my ghcide version, 'cause master is broken
06:34:16 <cocreature> master shouldn’t be broken, if it is open an issue
06:34:43 <merijn> cocreature: It's broken in the sense that it depends on unreleased dependencies (I'm guessing, it complains about a missing export from haskell-lsp-types)
06:35:09 <cocreature> ah right
06:35:16 <cocreature> haskell-lsp should have another release soon
06:36:52 <boxscape> % type Test -- is there an extension or something that allows you to do this? After all, you can have empty data decls, and empty closed nullary type families
06:36:52 <yahb> boxscape: ; <interactive>:17:157: error: parse error (possibly incorrect indentation or mismatched brackets)
06:37:23 <merijn> boxscape: What would that even mean?
06:37:39 <boxscape> % type family Test where
06:37:39 <yahb> boxscape: 
06:37:41 <boxscape> merijn taht
06:37:46 <boxscape> s/taht/that
06:38:00 <merijn> boxscape: Well, no, because "type" is different from "type family"
06:38:05 <boxscape> hm, okay
06:38:49 <merijn> boxscape: type is just for introducing aliases for existing types, the fact that "type family" reuses that keyword is fairly unrelated
06:39:15 <boxscape> isovector seems to be using empty type synonyms in his new book draft but maybe it's supposed to be pseudo-y code
06:40:15 <boxscape> merijn I was under the impression that "type Test a = Maybe a" and "type family Test a where Test a = Maybe a" are fairly similar
06:40:54 <merijn> cocreature: I just tested, but with an explicit cradle setup you can't even load modules from other components that depend on the TH modules
06:41:35 <merijn> cocreature: And without the explicit cradle setup I'm back to square one of my initial issue: How would you even use ghcide if you have more than one component in your package
06:42:11 <merijn> (Probably because the -i results in it trying to always load everything from source)
06:42:36 <cocreature> with the -i setup you don’t have multiple components
06:45:02 <merijn> cocreature: This basically all boils down to my initial issue about multi-cradle support (because there's no multi-component support), to which neil said that that's not important because you can just define a single cradle. So I'm once again convinced my argument of "for now we should just suck it up and launch a different cradle per component" is the right one
06:45:41 <cocreature> that wouldn’t help as long as you launch a cradle for the TH support that explodes
06:46:03 <merijn> cocreature: I'm ok with the TH files not working for now
06:46:26 <cocreature> then put them in a separate package and load that as a package instead of via sources
06:47:07 <merijn> I'm considering it, but it's an annoying huge amount of refactoring to split it off as package :\
06:47:59 <cocreature> sure, I agree that the current state is bad. but fixing it needs someone to put in the time and effort to make things better :)
06:49:19 <cocreature> hint: we’re hiring ;) https://digitalasset.com/careerone/?job_id=978901&job_title=language-engineer
06:50:41 <merijn> I saw that, but it's US only
06:51:26 <cocreature> merijn: if you’re interested, send me your CV. atm we would prefer US but it’s definitely not US only
06:52:33 <merijn> cocreature: I'm tempted ;) But I made a personal rule of "no jobs switches until this thesis nonsense is done"
06:52:56 <cocreature> merijn: that’s fair, feel free to ping me once you’re finished :)
06:53:08 <merijn> In other news, if anyone expects to need new Haskellers in, say, 6-12 months, you've been warned ;)
06:54:07 <MarcelineVQ> you're having twins?
06:56:27 <merijn> cocreature: I was mostly trying again because the discussion this morning had me timing my build and it was 4 minutes (well, 2minutes now with ghc -j) in -O0 (don't get me started on -O2...), so I figured it was worth another shot, because for my single component projects ghcide is crazy fast. But a massive refactoring to make it work isn't worth it if the expected refactor time is bigger than the time I 
06:56:33 <merijn> expect it to save
07:01:57 <svipal> can you define an apomorphism as a specialized futumorphism ?
07:03:04 <svipal> also
07:06:16 <svipal> I'm following https://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/ and I try to make my definition for the functions before reading the solution. My solution for the change function using the histomorphism is thus : https://pastebin.com/qFtkkYcn
07:06:36 <svipal> I tried it and it works
07:06:52 <svipal> but  I don't understand how the "lookup" function is equivalent to the post's function (also in the link)
07:11:41 <svipal> another gripe with the post... part 3 this time (https://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/)
07:12:44 * hackage json-tools 0.5.1 - A collection of JSON tools  https://hackage.haskell.org/package/json-tools-0.5.1 (NicolasPouillard)
07:14:50 <svipal> https://pastebin.com/Qnceq2yy
07:15:02 <svipal> oh god the highlighting is horrendous, sorry for this
07:16:46 <svipal> but basically I think there is an error in the post, the first term for a paramorphism is a Term f, so you have to unroll it correctly, don't you ?
07:16:52 <lavalike> svipal: https://pastebin.com/raw/Qnceq2yy
07:57:28 <svipal> it was written in the same article that you *can* express an apomorphism as a futumorphism
07:57:36 * svipal facepalms
07:57:47 <svipal> This stuff is kind of wrecking my brain
07:58:10 <merijn> svipal: tbh, I tried reading the recursion-schemes paper twice and then I decided I had better things to do with my life >.>
08:01:30 <dminuoso> If I have some enum type `data Tag = T1 | T2 | T3 | T4 ...` and I want to enrichen it with statically known data in the form of `tagWithExtra t@T1 = TagInfo { aboutTag = t, tagStuff = "foo", tagStiff = "bar" }` - is it more sensible to start tagging with TagInfo?
08:01:51 <svipal> merijn: Hahahaha
08:03:42 <dminuoso> I mean, this sort of "tagWithExtra" where you attach more information to some tag feels like a useless task
08:08:59 <lyxia> svipal: your version is not equivalent to the post
08:10:51 <svipal> that's what I had thought - how come it works ?
08:11:15 <lyxia> svipal: lookup cache n  from the post finds the n-th element from the top of the cache, yours finds the n-th element from the bottom of the cache (you return x when the cache has size n)
08:11:53 <lyxia> svipal: your version says there are three ways of making 7 cents from coins of 1 and 5 cents.
08:12:40 <svipal> thanks a lot for this
08:14:11 <svipal> I understand why I thought it was correct
08:15:39 <literallyCrevice> What's a command I can launch at the terminal to launch stack's ghci with a module loaded? (I know about --package, but I want to have behaviour similar to + Module automatically)
08:16:35 <svipal> advanced levels of mental fatige
08:17:01 <MarcelineVQ> literallyCrevice: try stack exec -- ghci path/to/Module.hs
08:17:29 <literallyCrevice> Oh, I didn't explain correctly. The module is not something I wrote, specifically it's Protolude.
08:18:22 <MarcelineVQ> ah, hmm
08:18:50 <literallyCrevice> I guess I can pipe over ":m + Protolude" and keep stdin open, but that's kind of an ugly solution
08:19:04 <lyxia> you can put commands to run in a file to be run at startup
08:19:21 <lyxia> $HOME/.ghci is the default but you can tell it on the command line too.
08:20:17 <svipal> ..it might not be that but I feel like my function returns the number of unique ways you can make up the value from coins
08:21:15 <lyxia> that's the goal of the exercise, so I can imagine why you feel that way :)
08:21:47 <svipal> wait
08:22:02 <svipal> ok, please bear with me for a while
08:22:05 <literallyCrevice> lyxia: Oh, awesome. Just one thing bothers me, even though I have :!clear at the end of .ghci I still get "Loaded GHCi configuration from ..." messages at the prompt
08:22:15 <svipal> how many configurations do you believe 7 should return ?
08:22:38 <svipal> I see 1 x 7 , 1-5-1, 5-2
08:22:54 <svipal> for 8, 1x8, 1- 5 -2, 3- 5
08:23:08 <lyxia> I was testing with 1 and 5 cent coins.
08:24:51 <lyxia> you can try writing a loop to test that your function produces the same result as the one in the post for many values of cents.
08:25:18 <svipal> it doesn't produce the same result. the reason I was able to fool myself was that
08:25:28 <svipal> I thought 1 5 1 and 5 2 were different
08:25:52 <svipal> if I try using my function and testing along this pattern, it works up to 12 at least
08:26:14 <tabaqui1> someone is trying to solve backpack problem with haskell?
08:26:33 <lyxia> coin change actually
08:26:42 <svipal> (pattern where 2 -5 - 1 and 1 - 5 - 2 are the same - but not 2 - 5 - 1 and 5 - 3 for instance)
08:26:49 <svipal> so I was like yeah this is it lol
08:26:57 <tabaqui1> I guess, it is isomoprhical
08:27:45 <svipal> by the way you have a nice exe Lyxia, I just noticed I forgot to change the nomenclature for my own function to match the post
08:27:59 <lyxia> svipal: 2 5 1 is not the same as 5 3 though?
08:28:29 <svipal> according to the post's function, it is 
08:29:03 <svipal> (by 2  5 1 I mean 2x1, 1x5, 1x1)
08:30:01 <lyxia> ah I thought you meant something else.
08:30:16 <lyxia> right, coin order doesn't matter
08:31:58 <uglyoldbob> is it possible to use the IO monad inside a Cairo Render event?
08:32:19 <literallyCrevice> Is there a way to tell `stack ghci` to run in global mode even when $CWD is a stack project?
08:33:50 <tabaqui1> literallyCrevice: stack --stack-root $HOME/.stack ghci
08:34:09 <tabaqui1> hmm, local root, probably
08:34:55 <tabaqui1> nope, nevermind
08:36:13 <literallyCrevice> tabaqui1: no dice
08:37:08 <dminuoso> Im starting to love Writer! It's so superb if you dont care about how leaky it is. :-)
08:37:38 <EvanR> uglyoldbob: see that Render is an instance of MonadIO
08:37:56 <dminuoso> uglyoldbob: Is that Render event documented with haddock anywhere?
08:38:18 <EvanR> https://hackage.haskell.org/package/cairo-0.13.5.0/docs/Graphics-Rendering-Cairo.html#t:Render
08:38:27 <dminuoso> Strange, didn't see it. :)
08:38:31 <dminuoso> uglyoldbob: ^- do you see the MonadIO instance?
08:38:39 <geekosaur> EvanR, sadly that's not an event, it's a rendering context
08:39:04 <cocreature> dminuoso: get yourself a writer-cps-transformers and you don’t even have to feel about about it being leaky :)
08:39:10 <EvanR> ... event, event...
08:39:17 <geekosaur> but I expect the render event also has MonadIO since it'd kinda need to or else you can't actually render anything
08:39:27 <EvanR> bar... bar...
08:39:28 <geekosaur> so liftIO should work
08:39:56 <geekosaur> it's been aa while since I did gtk2hs but this should be correct
08:40:11 <dminuoso> cocreature: Strange, there's no haddock on that.
08:40:11 <EvanR> glad to see cairo bindings as a separate package these days. At some point it was integrated with gtk
08:40:26 <dminuoso> cocreature: I mean no module documentations mmm.
08:40:32 <geekosaur> gtk2hs was split into a bunch of packages with 0.10
08:40:33 <cocreature> dminuoso: huh that’s weird, older versions seem to have it
08:40:46 <dminuoso> cocreature: Ohh, "NOTE: From version 0.5.6.0 on the modules provided by this package went upstream to transformers."
08:40:54 <dminuoso> I guess I already have that then! :)
08:41:02 <uglyoldbob> thank you, liftIO is what I needed
08:41:21 <cocreature> dminuoso: oh nice, it looks like they are in separate modules though
08:43:04 <dminuoso> cocreature: Strange, this looks just like a State beneath.
08:43:44 <cocreature> dminuoso: yep
08:44:09 <dminuoso> Presumably the sprinkling of !/~/seq is just different, and its not fully exposed then
08:44:19 <dminuoso> Its a neat trick
08:48:08 <cocreature> dminuoso: https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Writer.CPS.html#writer
08:49:24 <EvanR> so Writer.CPS is efficient as far as monoid-ing goes
08:50:07 <EvanR> now what monoid do you use for appending to a running log
08:51:39 <cocreature> you use conduit/pipes/… to stream the results directly to the log
08:51:41 <dminuoso> EvanR: Im just writing a tool to generate some thousands lines of Haskell code for me. So the output buffer is my log. :)
08:52:01 <dminuoso> I want something simple, I dont care about performance characteristics really.
08:52:07 <EvanR> yeah so Writer is not really helping?
08:52:23 <dminuoso> Why not?
08:52:38 <EvanR> is the monoid IO () ?
08:52:48 <dminuoso> No, it's just `Writer String` for me.
08:53:05 <dminuoso> Im generating haskell modules, so its basically file content.
08:53:11 <cocreature> if your monoid grows in size then making it strict doesn’t help all that much
08:54:07 <EvanR> in fact you might want it to be lazy in that case
08:54:27 <EvanR> so you chew on it as it's being generated and forget it
08:55:36 <dminuoso> Perhaps yeah.. I mean I dont care either way really as its a one-shot tool to generate boilerplate before it lands on hackage.
09:45:26 <uglyoldbob> what does the type IO (bla bla bla) mean?
09:46:43 <nil> `IO a` is the type of an IO action returning/computing a value of type `a`
09:48:09 <fimmind> @pl \l r -> l ++ ' ' : r
09:48:09 <lambdabot> (. (' ' :)) . (++)
09:48:52 <fimmind> @pl \l r -> r ++ ' ' : l
09:48:52 <lambdabot> flip (++) . (' ' :)
09:52:01 <uglyoldbob> I cant figure out what to do with the ConnectId in the signals for gtk spinbuttons (http://hackage.haskell.org/package/gtk3-0.15.0/docs/Graphics-UI-Gtk-Entry-SpinButton.html)
09:53:19 <nil> the documentation for that type says: "The type of signal handler ids. If you ever need to disconnect a signal handler then you will need to retain the ConnectId you got when you registered it."
09:53:38 <nil> if you don't need to disconnect signal handlers, you can simply ignore it
09:55:36 <uglyoldbob> it doesnt like this -> G.on num_bins_spinner G.afterValueSpinned $ G.widgetQueueDraw canvas
09:55:44 <uglyoldbob> it says Probable cause: ‘G.afterValueSpinned’ is applied to too few arguments
09:57:22 <EvanR> i wrote this monad in response to the apparent inability of Writer family to efficiently log
09:57:36 <EvanR> https://paste.ofcode.org/3ummWHgsLUip8Z3yAtUCtG is it just an instance of pipes or
09:57:58 <pikajude> how should I randomly generate 3 numbers such that they add up to some sum
09:59:57 <dsal> Generate two and subtract them from the sum for the third?
10:01:07 <pikajude> yeah, that might be a good idea
10:01:12 <EvanR> or is this some form of ListT
10:01:24 <pikajude> in the range of (0, n] i suppose
10:02:39 <dsal> You could do it quickcheck style.
10:02:39 <dsal> @check \f a b c -> (a + b + c == (50::Int)) ==> True
10:02:43 <lambdabot>  *** Gave up! Passed only 2 tests.
10:02:47 <dsal> It worked twice!
10:02:47 <pikajude> ooh, brute forcing
10:02:50 <pikajude> that's pretty smart
10:02:56 <pikajude> i wonder what the big-O for that function is
10:03:04 <EvanR> generating 2 carefully is smarter
10:03:04 <dsal> Very big O.
10:03:18 <EvanR> generating 2 uncarefully is easier
10:04:57 <uglyoldbob> oh i just needed to do "G.afterValueSpinned num_bins_spinner (G.widgetQueueDraw canvas)"
10:35:33 <dmwit> pikajude: Even for the range thing, generating two numbers and their sum will be better than brute force.
10:35:44 <pikajude> i know
10:35:49 <pikajude> i wasn't actually planning on doing brute force
10:36:30 <dmwit> EvanR: Is... that actually efficient?
10:36:42 <dmwit> EvanR: It looks like n log writes takes O(n^2) time...?
10:37:13 <M0b10s> hey, cna someone help me in a comprehension list?
10:37:30 <EvanR> dmwit: huh
10:37:44 <EvanR> to do what
10:37:53 <dmwit> each bind traverses all the yields
10:38:01 <dmwit> O(n) binds doing O(n) work each
10:38:18 <EvanR> what in the
10:38:47 <EvanR> each bind does 1 work, move the Yield up 1
10:39:07 <dmwit> no? it recursively calls (>>=)
10:39:25 <EvanR> it moves the >>= down 1
10:39:50 <EvanR> we lose 1 >>= and gain 1
10:40:23 <EvanR> total number of >>= remains the same as you foldYield
10:42:08 <dmwit> EvanR: If you don't believe my first-principles analysis, perhaps you'll be convinced by this empirical analysis: https://gist.github.com/dmwit/71ad9c2bc7f060c14056f207ebd4df98
10:42:09 <EvanR> if you ignore the Yield x, the definition of bind looks like sub >>= f = sub >>= f, identity monad
10:42:11 <dmwit> it's quadratic
10:43:32 <dmwit> M0b10s: You gotta give us more to work with than that.
10:44:29 <dmwit> EvanR: sub >>= f = sub >>= f isn't the identity monad. The identity monad is sub >>= f = f sub
10:44:36 <M0b10s> so... the list "[[1 | y <- [1..x]] | x <- [1..5]]" replicates 1 for "x" times
10:44:52 <M0b10s> i just don't understand how x)
10:45:31 <dmwit> M0b10s: Let's start simpler. Do you understand [x+10 | x <- [1..5]]?
10:45:42 <M0b10s> yes
10:45:53 <EvanR> i'm sorry, i'm lost on many levels here. How are you numbers showing quadratic
10:45:54 <dmwit> Cool. Do you understand [1 | y <- [1..3]]?
10:45:55 <M0b10s> [11,12,13,14,15]
10:45:57 <pikajude> i think generating (N-1) random numbers and then subtracting the last one will almost always result in a really small number for N won't it
10:46:00 <pikajude> or rather, the Nth item
10:46:30 <dmwit> EvanR: If you multiply the number of yields by n, you multiply the time the calculation takes by ~0.8n^2.
10:46:46 <EvanR> i tried to see that using osx calculator and your output
10:48:19 <M0b10s> that's what strange to me... "y" isn't doing anything near the "1"
10:48:21 <dmwit> pikajude: Seems like that depends a lot on what distributions you use for generating your random numbers.
10:48:33 <pikajude> stackoverflow says it's not uniform by default
10:48:40 <pikajude> you have to do some clever stuff for it
10:48:50 <dmwit> M0b10s: Okay. Do you understand [1 + 0*y | y <- [1..3]]?
10:50:31 <M0b10s> yes...constant 1, 3 times?
10:50:51 <dmwit> M0b10s: Right! Okay, so, do you agree that 0*y is always the same as 0?
10:51:44 * hackage haskell-lsp-types 0.17.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.17.0.0 (luke_)
10:51:59 <M0b10s> yes, so if i declare a "y" but even if i don't use in the first declaration of the list, it will be used in the creating of the list?
10:52:03 <nitrix> Is there an ML similar to Haskell whose implementation doesn't try to do memory sharing and the GC shenanigans that comes with it as a result?
10:52:59 <dmwit> M0b10s: right
10:53:14 * hackage haskell-lsp 0.17.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.17.0.0 (luke_)
10:54:34 <dmwit> M0b10s: (Does this get you to the point where your original question is answered, or is there still some points of confusion left?)
10:54:45 <M0b10s> tnk u so much dmwit!! i wasn't really understanding how it was being generated without using some sort of operation! once again, ty u!
10:54:53 <dmwit> ^_^
10:56:14 <dmwit> EvanR: ...and did OSX calculator compute the same answer ghci did, or...?
10:56:23 <EvanR> i have no idea
10:56:40 <EvanR> your report is less than illuminating to me for whatever reason, but i am investigating on my own
11:00:19 <dmwit> length [] = 0; length (x:xs) = 1 + length xs -- this is linear-time in the number of (:)s
11:00:50 <dmwit> bind (Done x f) = ...; bind (Yield x sub) f = ... (bind sub f) -- this is linear-time in the number of Yields
11:01:43 <EvanR> yes ?
11:01:46 <dmwit> s/(Done x f)/(Done x) f/
11:02:05 <dmwit> Okay. So (>>=) is linear-time in the number of yields.
11:02:32 <EvanR> now were back to this, and i'm still trying to observe a quadratic amount of time
11:02:35 <EvanR> which i can't
11:02:36 <dmwit> Now if I want to do n yields, I have n calls to bind, each operating on a value with (on average) n/2 yields in it.
11:03:18 <dmwit> What do your timing numbers for `last . runYield . flip replicateM_ (yield ()) $ n` look like for various values of n?
11:03:36 <EvanR> i didn't try replicateM_ yet
11:03:42 <EvanR> i tried getting the last of this program
11:04:10 <dmwit> (Which program is "this program"?)
11:04:28 <EvanR> take 1000000 (runYield (let inf = do{ yield (); inf } in inf) )
11:04:41 <EvanR> which i'm guessing uses >>=
11:05:04 <EvanR> i tried 1 million, 2 million, 3 million , and 4 millino
11:05:05 <dmwit> Ah! That is indeed very different.
11:05:14 * hackage lsp-test 0.8.0.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.8.0.0 (luke_)
11:05:30 <dmwit> Because of sharing, much less work is done.
11:06:05 <EvanR> i tried to look at lambdabot implementations of replicateM_ and see if it introduces anything crazy
11:07:19 <EvanR> sequence_ = foldr (>>) (return ())
11:08:36 <dmwit> Oh. It isn't sharing that matters.
11:08:52 <dmwit> let inf = do { inf; yield () } in inf -- nothing fun terminates here
11:09:11 <EvanR> hmm?
11:09:17 <dmwit> yieldNTimes 0 = pure (); yieldNTimes x = yieldNTimes (x-1) >> yield () -- problematic
11:09:27 <EvanR> did you reverse the recursion on purpose
11:09:38 <dmwit> fastYieldNTimes 0 = pure (); fastYieldNTimes x = yield () >> fastYieldNTimes (x-1) -- not problematic
11:09:45 <dmwit> Yes, see my last two lines for why.
11:10:41 <dmwit> (And this is exactly the refactoring that you need to do to make Writer-y things work well, too: re-associating the writes correctly.)
11:10:46 <EvanR> what does this have to do with replicateM_
11:11:22 <dmwit> replicateM_ does the first one, not the second.
11:11:43 <dmwit> And the first one is quadratic, the second linear.
11:12:48 <EvanR> now we can see why i am confused, beacuse the data structure itself and sane use cases for it don't seem at all inefficient to me, esp because lazy evaluation
11:12:57 <EvanR> but add the monad library and it sucks?
11:13:16 <EvanR> out of now where "the data structure is quadratic"
11:13:22 <dmwit> You don't think it's a problem that I, the user, have to constantly be thinking about whether my writes have been associated correctly?
11:13:30 <dmwit> There's no monad library involved in yieldNTimes.
11:13:38 <EvanR> yeah that function is terrible :)
11:13:50 <dmwit> It means I can't just write a function that yields something and use it elsewhere without thinking.
11:14:01 <dixie_> Do you know if there is some method how to attach to exe some icon? I found only this article, but I'm not able to replicate it with my stack/cabal program: https://wiki.haskell.org/Setting_an_executable_icon
11:14:09 <EvanR> you can't do that in haskell in general
11:14:14 <dmwit> Because now when I use it elsewhere, if I use it before something else that writes, I've got my yields associated the wrong way.
11:14:24 <dmwit> EvanR: You can with AccumT.
11:14:48 <dmwit> EvanR: The write performance is the same whether you refactor to name a sub-chunk of your monadic Writer-y code or not.
11:15:54 <EvanR> i dare say that if i tried to "log" with any sort of writer, i would run into performance issues and then have to do this analysis to understand why. Now i wrote this code with all these issues in mind, and it seems to solve it. Now dmwit comes along and does some other task with Yield and gets a performance issue and must delve into why. Of course it all seems obvious to me who wrote the original code
11:16:23 <dmwit> eh?
11:16:41 <dmwit> This has the *exact same performance issue* that Writer has: the user has to think about how writes are associated.
11:16:42 <EvanR> i also daresay that Yield isn't "quadatic" in an intrinsic sense, only depending on what you do with it.
11:16:55 <EvanR> there is no way you could do this with Writer that isn't slow
11:17:03 <EvanR> associated left or right
11:17:06 <dmwit> Saying "i wrote this code and it seems to solve it" is just... not correct.
11:17:30 <EvanR> i can't like, traverse a tree structure and yield things as i go with this?
11:18:38 <dmwit> "there is no way you could do this with Writer that isn't slow" is not correct.
11:18:59 <EvanR> please tell me how writer can accomplish this task
11:19:00 <dmwit> last . execWriter . flip replicateM_ (tell [()]) $ n -- is O(n) with Control.Monad.Writer
11:19:37 <dmwit> (and the analog of fastYieldNTimes above is quadratic)
11:19:48 <EvanR> i'm not sure i believe this
11:19:55 <dmwit> Try it yourself and see!
11:19:56 <dmwit> I just did.
11:20:30 <EvanR> telling a [()] over and over, how is that not >linear regardless of associativity
11:20:58 <EvanR> ok... youre prepending [()] each time?
11:21:08 <M0b10s> (is there a noob chanel for haskell?) i was trying to create a compreension expression for "[1,2,6,24,120,720]" and i got the pattern, but i don't know how to multiply the element that will result in the expression itself (exp: 1 * 2 [1,2] ++ 2*3 -> [1,2,6] ++ 6 * 4 -> [1,2,6,24] etc...could anyone help the noob? ;D 
11:21:17 <EvanR> and this gives you a reversed log
11:21:40 <EvanR> i was trying to get a non-reversed log
11:22:43 <glguy> the issue isn't reversed vs non-reversed if the topic is using (Writer [Entry]) to compute a log list of Entries
11:22:52 <dmwit> Okay. It is linear with C.M.Writer with both associativities. So now you're in an even worse spot: the base Writer gets linear runtime both ways, and yours doesn't.
11:23:16 <c_wraith> M0b10s: this is a good channel for that kind of question. that's an odd use case for a list comprehension, though. 
11:23:32 <EvanR> i started this investigation because of how infuriating Writer has been to me
11:23:49 <dmwit> ya
11:23:58 <c_wraith> M0b10s: that's a common use case for something like unfoldr or scanl
11:24:03 <dmwit> 's why AccumT exists now =)
11:24:09 <M0b10s> c_wraith: university likes to complicate things ;)
11:24:10 <glguy> If you want to avoid worrying about the internal associativity of operations like replicateM vs replicateM_ use (Writer (Endo [Entry]))
11:24:25 <EvanR> sure
11:24:40 <EvanR> endo build is part of the confusion
11:25:14 <EvanR> does endo builder let you stream the log as it is generated?
11:25:19 <glguy> yeah
11:25:32 <c_wraith> M0b10s: the only reasonable way to do that as a comprehension is to write a separate factorial function and then use a comprehension to apply it to the numbers [1..]
11:25:33 <EvanR> is it backwards? 
11:25:36 <glguy> no
11:26:11 <glguy> unless you want it to be
11:26:13 <EvanR> really...
11:27:20 <EvanR> dmwit says that (Yield x foo) >>= f = Yield x (foo >>= f)   "is quadratic"
11:27:24 <EvanR> why
11:27:27 <dmwit> No, I say it's linear.
11:27:38 <M0b10s> c_wraith: can i use "let" or "where" in this lists?
11:27:44 <dmwit> I say yielding n times is quadratic, if the binds are associated the wrong way.
11:27:53 <EvanR> linear makes sense to me
11:28:06 <c_wraith> M0b10s: you can use a let inside a list comprehension.
11:28:20 <EvanR> do you really have a choice if your thing has binds associated the wrong way?
11:28:50 <EvanR> and why are the monad functions associating binds the wrong way
11:29:01 <dmwit> There is no way that's right for all monads.
11:29:14 <c_wraith> > [ y * x | x <- [1..10], let y = 11 - x] -- M0b10s 
11:29:16 <lambdabot>  [10,18,24,28,30,30,28,24,18,10]
11:29:28 <dmwit> Yes, in this case you have a choice. Both glguy and I have given you choices.
11:30:22 <M0b10s> c_wraith, i'll keep hitting the keys then! ty for the help =) i'll come back wen i find the solution for that one =)
11:32:05 <EvanR> ok yes, you have a choice because monad laws
11:33:11 <EvanR> and is it just me or is x >>= (\_ -> y >>= (\_ -> z >>=...  always better?
11:34:03 <EvanR> where x y z are "atomic"
11:40:01 <dmwit> (I see your message, but didn't answer because I don't know.)
11:40:18 <dmwit> (My gut says no. But my gut is often wrong.)
11:40:21 <EvanR> it might not make sense since you can't really re arrange that
11:40:54 <EvanR> now i will try to stream something out of an endo-buildered logger
11:48:15 <uglyoldbob> how would I go about running a function f on a list [1,2,3,4,5] such that i get (f 1 2), (f 2 3), (f 3 4), (f 4 5), etc
11:48:34 <merijn> @quote azted.god
11:48:35 <lambdabot> No quotes match. It can only be attributed to human error.
11:48:39 <merijn> @quote aztec.god
11:48:39 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
11:49:11 <adamCS> uglyoldbob: Yeah. zip and tail are your friends here...
11:49:12 <merijn> > map (uncurry (+)) . zip`ap`tail $ [1..5]
11:49:13 <lambdabot>  error:
11:49:14 <lambdabot>      Precedence parsing error
11:49:14 <lambdabot>          cannot mix ‘.’ [infixr 9] and ‘ap’ [infixl 9] in the same infix expr...
11:49:24 <merijn> > map (uncurry (+)) $ zip`ap`tail [1..5]
11:49:26 <lambdabot>  error:
11:49:26 <lambdabot>      • Couldn't match expected type ‘[Integer -> (b, b)]’
11:49:26 <lambdabot>                    with actual type ‘[a0] -> [b0] -> [(a0, b0)]’
11:49:29 <merijn> aww
11:49:33 <merijn> Third time's the charm, right?
11:49:45 <merijn> > map (uncurry (+)) . (zip`ap`tail) [1..5]
11:49:48 <lambdabot>  error:
11:49:48 <lambdabot>      • Couldn't match type ‘[(Integer, Integer)]’ with ‘a -> [(b, b)]’
11:49:48 <lambdabot>        Expected type: [Integer] -> a -> [(b, b)]
11:49:52 <merijn> And I forget the $
11:49:59 <merijn> > map (uncurry (+)) . (zip`ap`tail) $ [1..5]
11:50:02 <lambdabot>  [3,5,7,9]
11:50:05 <merijn> There we go
11:50:36 <merijn> See, I can actually program
11:51:06 <merijn> (I would probably not write that as such :p)
11:51:23 <merijn> This is probably better: "\l -> zipWith f l (tail l)"
11:51:54 <merijn> > (\l -> zipWith (,) l (tail l)) [1..5]
11:51:56 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
11:54:04 <uglyoldbob> merijn awesome thanks
11:55:01 <merijn> uglyoldbob: This is also how the fancy lazy fibonacci thing works :)
11:55:22 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
11:55:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:55:50 <NemesisD> sort of a half-baked question here: if i've got a record data Foo f = Foo { bar :: f Bar, baz :: f Baz} and a typeclass that can give me a function that via a typeclass can give me f :: SomeF Bar -> String and f :: SomeF Baz -> String, is there a way to generically go from Foo SomeF -> [String], in other words can i generically fold over an arbitrary record where all the fields have the same shape
11:56:43 <merijn> NemesisD: Depends, how high your tolerance for things like Generic
11:56:46 <merijn> +is
11:57:03 <merijn> I mean, it's certainly possible, the real question is "are you willing to pay the price?"
11:59:38 <NemesisD> merijn: i can tolerate it. to take a step back i'm trying to figure out a pattern that allows for a single user-defined record that for different values of `f` can be used to represent an instance of the record (`f ~ Identity`), a schema for an external datasource (`f ~ SchemaInfo` where SchemaInfo contains the external database's field name and type)
12:00:22 <NemesisD> so ultimately i could take a `Foo SchemaInfo` and give you back a `Foo Identity` after building a query that is schema-aware and executing it
12:00:56 <koz_> NemesisD: That looks like https://reasonablypolymorphic.com/blog/higher-kinded-data/
12:00:56 <NemesisD> i'm willing to use generic, singletons and if i must, vinyl to do it
12:02:48 <NemesisD> i should really finish reading Sandy's book. if only i could do it on the clock lol
12:03:31 <wildtrees> NemesisD, Thinking in Types? 
12:03:47 <NemesisD> wildtrees: yeah. i think i'm maybe 1/4 of the way through it
12:03:57 <wildtrees> NemesisD, is it good? 
12:04:01 <koz_> I've read it a few times already - it is very good.
12:04:21 <wildtrees> might check it out, I just heard about it yesterday through some searching 
12:04:23 <koz_> (disclaimer: I bought it on release and am a big fan of Sandy's work in general)
12:04:25 <NemesisD> i agree. definitely targeted towards intermediate and above haskell developers, but with that it is quite approachable
12:05:12 <EvanR> dmwit: based on the supposed foldr (>>) based implementation of sequence_ and so replicateM_ i was expecting not-quadratic performance of anything. And now i get around to trying it and i get this https://paste.ofcode.org/n4TcSgCVKrbqkay4kRyURx
12:05:38 <EvanR> .8 .16 .24 .32...
12:07:35 <EvanR> scrolling back to see what the difference is
12:09:05 <M0b10s> c_wraith, so...i finnally know another way to get the pattern [1,2,6,24,120,720] as simple as [(product x) | x <- [1..6]] but i get an error? dunnu what i'm doing wrong there...
12:10:23 <svipal> Look at the error 
12:10:24 <EvanR> the action of replicateM_ should be to yield () >> (foldr (>>) (return ()) (one less thing))
12:10:29 <NemesisD> koz_: that link seems to be very much the direction i'm headed in. i'll chew on this for a bit. thanks!
12:10:39 <EvanR> i.e. associate the sane way
12:12:21 <M0b10s> svipal, i did... "Ambiguous type variables ‘t0’, ‘a0’ arising from the literal ‘1’" but i can't make much sense of it....
12:12:37 <svipal> :t product
12:12:38 <lambdabot> (Foldable t, Num a) => t a -> a
12:13:46 <dminuoso> Mmm, is there a simple way to hoist something like prettyprinter into the State monad?
12:14:02 <dmwit> EvanR: Weird. This does not match what I see.
12:14:18 <merijn> dminuoso: hoist how?
12:14:45 <EvanR> maybe you were experiencing some transient memory management issues, but your numbers were much lower 
12:14:55 <svipal> if you want to get rid of the "ambiguous type variables" message you should specify a type for the statement
12:15:00 <svipal> expression*
12:15:20 <svipal> but, even if you do, you're calling product on a number here if I got your intent right 
12:15:31 <svipal> but product takes a foldable
12:17:16 <M0b10s> svipal, (asking things to Dr. Google brb =D ) 
12:17:17 <dminuoso> merijn: Oh wait, I think what I want is just some `Writer (Doc ann)`!
12:19:21 <merijn> "(<:>) = liftA2 (:)" <- well I just made my life a bunch cleaner for composing lists applicatively :p
12:20:33 <koz_> I'm trying to use bootstrap.sh to build cabal-install on ARMv7. However, network-uri segfaults during the config step: http://paste.debian.net/1108095/
12:20:56 <dminuoso> merijn: liftA2 <insertOperatorHere> is really a really cool thing with local bindings. :)
12:21:16 <dminuoso> It just gets messy if you start using this globally.
12:31:11 <M0b10s> svipal, thnk for the patience! SOLVED one of comprehension expressions for "[1,2,6,24,120,720]" is "[product [1..x] | x <- [1..6]]" ty for all the help =)
12:31:56 <svipal> np ! I barely helped haha
12:32:12 <int-e> > scanl(*)1[2..6]
12:32:14 <lambdabot>  [1,2,6,24,120,720]
12:33:40 <M0b10s> ty, but i really had to use a comprehension list ;D
12:34:10 <M0b10s> the pattern was making me confused...that was the problem 
13:10:16 <dminuoso>     • Can't make a derived instance of ‘MonadReader VSADict Z’ (even with cunning GeneralizedNewtypeDeriving): cannot eta-reduce the representation type enough
13:10:24 <dminuoso> Funny diagnostic.
13:22:16 <Orbstheorem> Hello, is there any way to access the `data-files` declared in package.yaml from the code?
13:22:55 <merijn> Orbstheorem: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
13:30:28 <ibloom> Is there a reason why Data.Sequence module doesn't have a `head` method? Is this in a typeclass instance?
13:31:09 <merijn> I think you want the ViewL and ViewR things?
13:31:32 <ibloom> Ah
13:31:42 <ibloom> Ok thank you.
13:32:02 <merijn> ibloom: And possible the pattern synonyms: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Sequence.html#v::-60--124-
13:32:55 <dignissimus> Is it possible to create vim plugins in haskell?
13:33:12 <merijn> dignissimus: Yes-ish
13:33:47 <merijn> dignissimus: At one point I looked into this. Vimscript supports FFI to C, so that (in theory) is sufficient to call Haskell code
13:34:15 <srid> Is there a version of `Data.Tree` that uses a map, instead of lists, for the chlidren type (the 'Forest')
13:34:21 <merijn> Things are never that trivial, but I didn't see anything that lead me to believe it isn't possible
13:35:20 <merijn> srid: "Map k" is a functor, so you could use Free
13:35:51 <merijn> I don't think there's a pre-existing one, though
13:36:23 <srid> How is `Free` relevant? My tree is dynamic (contents are fetched from an API).
13:37:09 <merijn> srid: Free turns an arbitrary functo in to a "infinitely nested" version with leafs. Sounds exactly like what "a tree of maps" sounds like
13:38:09 <srid> How would you define it? I have trouble visualizing what this would look like.
13:38:27 <srid> In my tree, each node is defined by an unique ID and some text content.
13:38:44 <srid> And each node has a bunch of children, each retrievable in O(1) using its ID.
13:39:19 <srid> `Data.Tree` works, except specific child retrieval is O(k) instead of O(1).
13:40:51 <merijn> srid: "Free (Map YourKey) LeafValue"
13:41:21 <merijn> hmm, that's not what you want, then, I guess
13:41:49 <srid> IIUC, Free monad requires your tree to be defined ahead; and not arbitrary.
13:42:18 <merijn> srid: What? No it doesn't
13:42:33 <merijn> Why would it require that?
13:42:58 <srid> Well, then how would you use Free to represent a dynamic tree as above?
13:44:02 <merijn> Like I just said? "Free (Map KeyType) ValueType" that can nest as many levels as you want?
13:44:03 <srid> Precisely, how can Free be used to represent a tree datastructure where children of each node is a map (to satisfy the O(1) retrieval requirement)
13:44:34 <merijn> Well, that you can't, but you only mentioned that requirement a few seconds ago :p
13:44:57 <srid> I mean I'm happy with `Data.Tree` - it does everything but that O(1) requirement.
13:45:25 <glguy> Maps don't offer O(1) lookup. If your child keys are zero-indexed you could use: Free Vector
13:45:39 <dsal> merijn: ekg looks kind of neat.  I'd seen someone mention it here, but didn't know what it did.  I've got a few servers I run stuff on and have some ad-hoc stats I might be able to make more generally useful.
13:45:41 <merijn> Technically vector isn't O(1) either in the real world :p
13:45:45 <srid> they are O(1) amortized, are they not
13:45:57 <merijn> srid: No
13:46:04 <merijn> srid: They're O(log n)
13:46:22 <dsal> They can be approximately O(1) if you have sufficiently few items.
13:46:24 <geekosaur> we tend to ignore little things like what's actually going on in the hardware, cpu caches, etc.
13:46:33 <srid> oh right
13:46:59 <srid> maybe i should qsort the children, and then do a binary search during lookups. ugh
13:47:09 <dminuoso> merijn: Why O(log n)?
13:47:24 <srid> https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#g:9
13:47:27 <dminuoso> dsal: Honestly this idea of "if you have sufficiently few items" defeats the idea of complexity analysis..
13:47:45 <geekosaur> caching generally does, at whatever level
13:47:54 <merijn> dminuoso: That was referring to Map
13:47:59 * srid drops the idea citing 'premature optimization'
13:48:01 <dsal> dminuoso: Yeah, that's a good point.
13:48:42 <dminuoso> merijn: Ah. I thought it was with respect to vector.
13:53:33 <EvanR> srid: for posterity, how big are these nodes? (how many children typically)
13:53:44 <srid> Its coming form a text outliner. So not big.
13:53:51 <EvanR> got it
13:54:03 <srid> Though if I stick to it for journaling it could grow huge after a decade or two. 
13:54:39 <EvanR> so all nodes in sight might grow from avg 10 to avg 100 
13:56:09 <geekosaur> in a decade you'll have rewritten in whatever idris has evolved into. or whatever haskell has evolved into :)
13:56:27 <EvanR> i'm gonna go with dumb-as-a-brick List if it's like 10. And the issue is indexing past the end rather than the performance
13:56:30 <EvanR> and yeah that
14:00:16 <Orbstheorem> Thanks merijn 
14:00:19 <djanatyn> i have a haskell library that wraps Ansible in an EDSL. i'd like to automatically generate types for Ansible modules from the python source or from the documentation. i've seen similar patterns in libraries like amazonka, for example
14:01:14 <djanatyn> https://github.com/brendanhay/amazonka/tree/develop/gen -- for that library, they used a code generation binary, which seems like a good approach for covering all of the modules in Ansible. are there any other libraries that serve as good examples for that pattern (programatically generating types for a moving target like amazon APIs or Ansible modules?)
14:04:09 <djanatyn> https://github.com/citycontext/sansible -- this is a similar attempt in Scala, where they used a ruby script and a scala macro to generate case classes
14:07:02 <geekosaur> gtk2hs similarly generates API on the fly from the installed gtk libs, btw
14:08:03 <EvanR> OpenGL and gl both do it i think
14:08:19 <djanatyn> i'll take a look at those libraries, thank you
14:10:16 <dminuoso> djanatyn: Why would you wrap Ansible in an EDSL using Haskell, when you could just write Haskell code instead..
14:11:57 <dminuoso> Its beyond me how people still celebrate Ansible as something novel, when in truth Ansible is just a simplistic basic imperative programming language with terrible and unclear semantics.
14:12:08 <djanatyn> dminuoso: my job uses Ansible heavily for deployment, configuration management, and image builds. i have to write Ansible, but the language doesn't have very good facilities or well-known design patterns for documenting and structuring code (there is no way to describe what variables a role takes, for example)
14:14:12 <dignissimus> Ok, as a quick haskell project I want to create a tictactoe game with a good AI, the scariest part for me is displaying the board, any ideas as to how I can do this? Curses maybe?
14:14:21 <djanatyn> being able to write Haskell that renders Ansible lets me build my own abstractions on top of it, to add some guarantees i find tricky to enforce by hand (variables for roles are documented, out of scope variables are type errors, looping constructs are used consistently)
14:14:43 <dminuoso> djanatyn: At that point you are likely to generate unmaintainable ansible code, so you might as well dodge ansible entirely.
14:14:51 <EvanR> dignissimus: perhaps try https://hackage.haskell.org/package/threepenny-gui
14:15:12 <dignissimus> Thanks! I'll check it out
14:15:22 <djanatyn> dminuoso: my Ansible source code is human-readable and looks exactly like the code my coworkers are writing, but with more documentation and fewer runtime errors
14:15:44 * hackage config-value-getopt 0.1.1.1 - Interface between config-value and System.GetOpt  https://hackage.haskell.org/package/config-value-getopt-0.1.1.1 (EricMertens)
14:16:02 <svipal> dignissimus, the easiest way is gloss
14:16:04 <svipal> imho
14:16:23 <djanatyn> I use Aeson and Data.YAML with orderings defined using Data.YAML.Pretty
14:17:09 <djanatyn> I can't parse Ansible yet, but being able to do so would help me perform static analysis and code transformations
14:17:31 <djanatyn> the language is simple enough that it isn't to complex to write FromJSON instances
14:17:34 <dminuoso> Im a bit baffled how you can even ponder of investing that much work into ansible and not just push for say dhall+nix..
14:18:29 <dminuoso> djanatyn: How do you want to talk about python modules in general?
14:18:37 <EvanR> ok yeah gloss also works
14:18:50 <djanatyn> my organization wouldn't support dhall and nix. I use Dhall for configuring some internal utilities I write, and I use nix to manage my own packages, but I work for an established company that has years worth of Ansible code that is in production and can't just be replaced
14:18:50 <EvanR> it even has mouse clicking
14:19:38 <EvanR> but it is limited in terms of fonts
14:19:50 <djanatyn> dminuoso: either by parsing the documentation of Ansible modules (which are structured enough to support ansible-doc) or by hooking into different versions of Ansible with Python to list all modules and generate the metadata I need to create my data types
14:20:40 <djanatyn> i'm not in a position where i can just stop using Ansible, and I've gotten exhausted writing Ansible over the past few years. I enjoy writing Haskell and I want to encode the design patterns we use in our code base in a library so I don't have to make so many mechanical changes
14:21:14 * hackage optics-core 0.2 - Optics as an abstract interface: core definitions  https://hackage.haskell.org/package/optics-core-0.2 (AdamGundry)
14:21:51 <djanatyn> i'm also not in a position where i can justify to my coworkers why they should learn haskell or Nix - I don't think they would get much out of it at all
14:22:14 * hackage optics-vl 0.2, optics-th 0.2, optics-extra 0.2 (AdamGundry)
14:22:45 <djanatyn> the unclear semantics you mentioned is exactly why i'd like to have a better interface to the code i maintain and write and collaborate on
14:23:14 * hackage optics 0.2 - Optics as an abstract interface  https://hackage.haskell.org/package/optics-0.2 (AdamGundry)
14:24:14 * hackage context-free-art 0.2.0.1 - Generate art from context-free grammars  https://hackage.haskell.org/package/context-free-art-0.2.0.1 (414owen)
14:28:58 <djanatyn> in my EDSL, I have separate types for AnsibleVars, ModuleConfig, ModuleInvocations, Tasks, Roles, Plays, and Playbooks. I can't represent each module as a type because there are too many, so I'm forced to use strings. I'd strongly prefer if I could create a separate type for each module based on the arguments it requires - at that point, Ansible runtime errors become Haskell compile-time errors
14:29:24 <geekosaur> Symbol?
14:29:32 <geekosaur> (type-level strings)
14:29:50 <djanatyn> i was looking at that today, I'm still reading the paper on DataKinds, but that seems like a direction I'd want to go in
14:30:46 <djanatyn> i'd also like to pair this with an ansible-runner module mostly for my own purposes, so that I can execute Haskell types representing Ansible playbooks and log all the output in a way that can be inspected during the runtime of my Haskell program
14:31:11 <djanatyn> then I can start using Ansible as a convenient mechanism for inspecting servers in my Haskell code
14:31:59 <djanatyn> while the Ansible language has a lot of problems, the ecosystem of Ansible modules is very powerful, along with the work that's been put into the transport mechanism and the Ansible inventory semantics
14:34:11 <djanatyn> if there's a better way for me to write a Haskell script that runs across hundreds of servers to inspect some file permissions and identify which servers are out of spec, i'd be curious - i know propellor does some similar things. i also understand that these issues don't occur as much with an immutable infrastructure, but my company isn't there yet
14:44:31 <koz_> I'm submitting a PR to cabal for a spelling mistake in an issue template. In the PR template, they say that 'If the change is docs-only, `[ci skip]` is used to avoid triggering the build bots.'. What is [ci skip] and how do I use it?
14:45:14 * hackage futhark 0.12.2 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.12.2 (TroelsHenriksen)
14:52:32 <sm[m]> koz_: it means for small safe changes, you should write that anywhere in the commit message, so it can skip CI and save a bunch of carbon emissions
14:53:02 <sm[m]> CI being "continuous integration", ie automatically building a whole bunch of stuff on each commit
14:53:43 <koz_> sm[m]: Ah, thanks.
15:11:27 <kleisli> can someone explain why this function diverges when called on positive numbers?
15:11:29 <kleisli> https://paste.ee/p/3qhYt
15:11:55 <koz_> kleisli: How large a number did you try?
15:12:03 <merijn> Oh, I know
15:12:10 <merijn> kleisli: 10 dollar says you defined this in ghci
15:12:19 <kleisli> merijn: indeed i did
15:12:24 * koz_ is now intrigued.
15:12:29 <merijn> kleisli: The second line redefines and shadows the first
15:12:33 <kleisli> ahh
15:12:35 <kleisli> thank you
15:12:49 <koz_> And here I was thinking it was an overflow problem or something.
15:12:53 <merijn> multi-line input in ghci is pretty much an afterthought and I'd just avoid it :)
15:13:22 <jle`> if +m is on then it might at least give a warning sign that something is wrong
15:13:24 <jle`> as long as you use 'let'
15:13:26 <merijn> kleisli: I'd recommend just writing in your favourite editor and then loading/reloading into ghci via ":load" and ":reload"
15:13:31 <jle`> let f 0 = 1
15:13:38 <jle`>  ... then ghci will pause to let you know it's waiting for new input
15:13:38 <merijn> (or ":l" and ":r" for the lazy)
15:13:56 <jle`> but if you don't use let then ghci will be happy enough to let you go on your merry way, which is a bit dangeorus
15:14:14 * hackage hjsmin 0.2.0.4 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.2.0.4 (ErikDeCastroLopo)
15:14:19 <kleisli> alright, thanks
15:17:18 <EvanR> oh really. Wow so the "don't need let" feature in ghci actually added something odd
15:17:49 <merijn> tbh, I think making ghci more like proper Haskell may have just increased beginner confusion :p
15:17:58 <merijn> Although, being able to use import is nice
15:22:12 <evelyn> hasn't that been possible for quite a few years?
15:22:44 * hackage viewprof 0.0.0.32 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.32 (MitsutoshiAoe)
15:22:46 <merijn> evelyn: Yes
15:22:58 <merijn> evelyn: That's not gonna stop me from calling it newfangled changes, though!
15:23:11 <evelyn> I find it weird to see tutorials use :m now\
15:23:29 <evelyn> import is so much more intuitive and clear
15:31:21 <glguy> :m is worth learning as it can add and remove modules, handle multiple modules at the same time, and open the namespace inside a module
15:39:03 <koz_> Also, who was the person earlier asking about higher-kinded data? If you're still around, you may find this useful: https://github.com/i-am-tom/higgledy
17:31:44 * hackage refined 0.4.4 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.4.4 (chessai)
19:59:40 <docmerlin> hello, which standard library should I use?
19:59:54 <docmerlin> I'm brand new to haskell.
20:00:08 <suzu> what do you mean by standard library?
20:00:53 <docmerlin> I was told not to not use the built in prelude
20:00:56 <pikajude> i would recommend `base` :{
20:00:58 <pikajude> :)*
20:00:58 <docmerlin> but to use a different library
20:01:05 <pikajude> for what exactly
20:01:41 <docmerlin> if I wanted to build stuff? I don't know,
20:01:53 <suzu> you can use prelude
20:02:02 <pikajude> you're gonna have a hard time getting anything done without base
20:02:02 <suzu> but it has some warts
20:02:06 <pikajude> not saying it's impossible, just difficult
20:02:10 <suzu> so many people switch it out
20:02:13 <docmerlin> like I said, complete newbie to the language.  I just got my environment set up and haskero working, etc
20:02:18 <pikajude> not the entire prelude
20:02:19 <pikajude> just bits of it
20:02:21 <ski> i think attempting to avoid the `Prelude', as a newbie, is probably not much point to
20:02:21 <pikajude> String for example
20:02:27 <suzu> just use the prelude
20:02:30 <suzu> it doesnt matter right now
20:02:33 <pikajude> or the functions that operate on [a] instead of Functor or Foldable
20:02:39 <suzu> just start learning the language
20:02:45 <suzu> no need to get overwhelmed by all this right now
20:02:59 <docmerlin> what do you folks use?
20:02:59 * ski agrees with suzu
20:03:06 <docmerlin> thanks suzu
20:03:09 <pikajude> i use prelude for a ton of stuff, it's very useful
20:03:33 <suzu> everyone has differing opinions on what to do about prelude with different drawbacks and stuff
20:03:41 <suzu> but that's for later
20:04:14 <suzu> so don't worry about that stuff right now
20:29:04 <DigitalKiwi> doesn't Safe have alternatives for a bunch of the partial functions that are one of the things to avoid
20:30:25 <DigitalKiwi> though a lot of them aren't that hard, and probably a good exercise would be to write replacements for the partial functions that are safe
20:37:44 * hackage hmp3-ng 2.5.1 - A 2019 fork of an ncurses mp3 player written in Haskell  https://hackage.haskell.org/package/hmp3-ng-2.5.1 (galen)
20:47:14 * hackage rank2classes 1.3.1.2 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.3.1.2 (MarioBlazevic)
21:08:57 <dmj`> I'm getting some strange behavior when trying to resolve a shared library (.dylib) on OSX in ghci
21:12:06 <dmj`> anyone ever seen this before
21:12:08 <dmj`> 2019-10-19 00:10:11.949 ghc[40040:630099] *** Assertion failure in +[NSUndoManager _endTopLevelGroupings], /BuildRoot/Library/Caches/com.apple.xbs/Sources/Foundation/Foundation-1575.22/Foundation/Misc.subproj/NSUndoManager.m:361
21:33:59 <docmerlin> How many spaces should I use for indentation?
21:37:45 <rotaerk> I like using 2
21:38:40 * DigitalKiwi likes whatever hindent does
21:39:53 <pikajude> yeah, i like whatever the project is configured for
21:43:13 <jle`> i start with 4 and then do 2 from there on
21:49:45 <pavonia> jle`: Which editor supports that?
21:58:44 <jle`> i just set my editor to two spaces and then tab twice for the first level heh
21:59:28 <ullbeking> jle`: that level of committed personality is hot
21:59:37 <jle`> i try
21:59:51 <ullbeking> you sizzle
22:00:00 <ullbeking> ok, good night
22:05:20 <wejetheman> is there a better / more preferred method of getting at the data in my custom data type than a lambda like this? http://codepad.org/2CLg1yBY
22:08:53 <heatsink> You have a Show instance for Time, so you can print it
22:08:57 <heatsink> no need to convert it to a list
22:14:42 <wejetheman> no i know, i was just trying to abstract the problem out of a much bigger problem
22:15:03 <wejetheman> instead of making you guys look at the whole big mess
22:15:22 <noobiehaskeller> May I ask a noobie haskel question if you guys have time?
22:16:27 <wejetheman> i need to parse the the data type into a string with particular characteristics i.e. if its a single digit it needs to have a 0 in front 9:00 -> 09:00
22:16:48 <wejetheman> ask ill answer if i know but im a noob too
22:16:57 <noobiehaskeller> -- Following worksaarray = [[1, 2, 3, 4], [5, 4, 3, 2, 1]]headarraya = head aarrayheadarrayaa = head headarraya-- Following does not workaarray = [[1, 2, 3, 4], [5, 4, 3, 2, 1]]headarraya = head head aarray
22:17:28 <noobiehaskeller> lol, looks like you cant paste beutifully on the web
22:17:33 <noobiehaskeller> i will paste one by one
22:17:34 <wejetheman> use this http://codepad.org/MQx9Ka2e
22:17:41 <noobiehaskeller> -- Following works
22:17:48 <noobiehaskeller> aarray = [[1, 2, 3, 4], [5, 4, 3, 2, 1]]
22:17:54 <noobiehaskeller> headarraya = head aarray
22:18:00 <noobiehaskeller> headarrayaa = head headarraya
22:18:07 <noobiehaskeller> -- Following does not work
22:18:13 <noobiehaskeller> aarray = [[1, 2, 3, 4], [5, 4, 3, 2, 1]]
22:18:19 <noobiehaskeller> headarraya = head head aarray
22:18:38 <noobiehaskeller> any ideas why?
22:18:51 <Lears> `f x y` is `(f x) y`, not `f (x y)`.
22:19:29 <noobiehaskeller> I see
22:19:36 <wejetheman> gotta love those perfectly correct but always cryptic answers
22:20:00 <noobiehaskeller> it is left to right, so i am calling head of a head and the later part is never even executed :D
22:20:14 <noobiehaskeller> Am i right?
22:20:28 <wejetheman> headarraya = head (head aarray)
22:20:33 <noobiehaskeller> yup
22:20:44 <noobiehaskeller> Thanks :D
22:21:55 <heatsink> wejetheman, do you want a way to get one of the fields of a Clock without using a lambda?
22:22:05 <wejetheman> yes please 
22:22:46 <heatsink> There are several ways
22:22:55 <heatsink> You can write helper functions
22:23:04 <heatsink> hours (Time h _) = h
22:23:22 <heatsink> Then, call (hours t) to get the first item from t
22:23:31 <wejetheman> ya i reduced one of those into my lambda to figure out how to write it
22:24:25 <heatsink> You can also use pattern matching with let, case, or where.  main = let Time h _ = t in print h
22:27:22 <heatsink> If you're not familiar with the different ways of writing it, I'd recommend using let for now.
22:27:27 <wejetheman> but basically you have to write all of your own functions for your own data types... no built in fst() or snd() because all of the functions like that are domain specific to the built in data types
22:28:10 <heatsink> Another way is to define the type using record syntax.
22:28:18 <heatsink> data Clock = Time { hours :: Int, minutes :: Int}
22:28:49 <heatsink> Then you can access the hours with (hours t), and you can copy-and-modify the minutes with (t { minutes = 0})
22:29:25 <wejetheman> that's exactly the sort of thing i was looking for
22:31:06 <wejetheman> thanks 
22:31:11 <heatsink> you're welcome
22:39:43 <koz_> :t sequenceA
22:39:44 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
22:45:17 <wejetheman> one more time before i sign off, you rock heatsink, thats such a cool solution
22:49:18 <koz_> I keep (re-)discovering how awesome foldMap really is.
22:51:03 <heatsink> It's much better than crumpling maps into a ball.
22:51:15 <koz_> heatsink: militaryFoldMap.
23:37:14 * hackage named 0.3.0.1 - Named parameters (keyword arguments) for Haskell  https://hackage.haskell.org/package/named-0.3.0.1 (Artyom)
