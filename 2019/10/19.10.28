00:05:09 <jackdk> I'm trying to link to specific functions in the description of a cabal file by writing 'A.B.C.f', and it formats a monospaced `f`, but doesn't link it. Am I trying to do something that's not possible?
00:25:59 <jusss```> do we have `cons' in haskell? like scheme?
00:26:31 <jusss```> (cons 1 '(1 2)) == (1 (1 2))
00:26:45 <jusss```> :t cons
00:26:47 <lambdabot> Cons s s a a => a -> s -> s
00:27:29 <ChaiTRex> jusss```: 
00:27:34 <ChaiTRex> jusss```: Yeah, it's :
00:27:46 <yushyin> > 1 : []
00:27:49 <lambdabot>  [1]
00:27:52 <ChaiTRex> > 1:[1,2]
00:27:54 <lambdabot>  [1,1,2]
00:28:05 <jusss```> ChaiTRex: and car , cdr?
00:28:53 <ChaiTRex> jusss```: Pattern matching or head and tail.
00:29:23 <ChaiTRex> > let (carValue : cdrValue) = [1, 1, 2] in (carValue, cdrValue)
00:29:26 <lambdabot>  (1,[1,2])
00:29:26 <jusss```> ok
00:30:29 <ChaiTRex> > (head [1, 1, 2], tail [1, 1, 2])
00:30:32 <lambdabot>  (1,[1,2])
00:31:05 <jusss```> > tail [1,2,3]
00:31:07 <lambdabot>  [2,3]
00:31:51 <sicklorkin> jusss```: if you use head or tail you need to make sure your list ins't empty..
00:31:59 <sicklorkin> > tail []
00:31:59 <dminuoso> Yeah you will get slapped if you use head or tail.
00:32:02 <lambdabot>  *Exception: Prelude.tail: empty list
00:32:04 <dminuoso> Use pattern matching.
00:32:17 <sicklorkin> or take and drop
00:33:01 <sicklorkin> > fmap tail <$> listToMaybe []
00:33:05 <lambdabot>  error:
00:33:05 <lambdabot>      • Ambiguous type variables ‘f0’,
00:33:05 <lambdabot>                                 ‘a0’ arising from a use of ‘show_M58064902666...
00:33:11 <jusss```> ok
00:33:24 <sicklorkin> whoops.. no need for fmap
00:33:44 <sicklorkin> jusss```: isgnore listToMaybe that's just wrong
00:33:51 <sicklorkin> works for head
00:45:06 <jusss```> https://paste.ubuntu.com/p/SCCRBH34yN/
00:45:21 <jusss```> 1 | splitWithList = \(alist blist before n) ->  is not ok?
00:46:11 <ChaiTRex> jusss```: Don't surround all the lambda args with a set of parentheses
00:46:21 <ChaiTRex> jusss```: Just \ arg1 arg2 arg3 ->
00:47:21 <jusss```> ChaiTRex: ok
00:47:46 <jusss```> :t print
00:47:47 <lambdabot> Show a => a -> IO ()
00:48:42 <jusss```>  main =       print $ splitListWithList [1,2,3,4,5] [2,3]
00:48:56 <jusss```>     parse error on input ‘=’    Perhaps you need a 'let' in a 'do' block?    e.g. 'let x = 5' instead of 'x = 5'
00:51:30 <jusss```> https://paste.ubuntu.com/p/Rj9rTCmyCR/
00:52:15 <MarcelineVQ> you've put a space in front of main
00:53:02 <jusss```> MarcelineVQ: wow, you're right, but it's auto indent with haskell-mode
00:53:14 <jusss```> I don't know why it auto indent one space
00:59:12 <jusss```> https://paste.ubuntu.com/p/V4Nxq8jxfX/
00:59:24 <jusss```> another primitive issue...
01:00:16 <MarcelineVQ> the error suggests how to fix that
01:00:20 <jusss```> why haskell use /= not !=
01:00:38 <ChaiTRex> jusss```: == checks each elemeent of the two lists, so each element has to be checkable for equality (Eq)
01:00:50 <ChaiTRex> jusss```: To check for list emptiness, try null.
01:00:54 <ChaiTRex> > null []
01:00:57 <lambdabot>  True
01:02:03 <ChaiTRex> jusss```: Alternatively, you can restrict your function to work only on lists of types that implement Eq.
01:02:09 <MarcelineVQ> "add (Eq a) to the context of the type signature" means to write lengthN :: Eq a => [a] -> Int -> Int    it only requires this because == for lists needs to compare elements. ChaiTRex's fix avoids this
01:02:37 <jusss```> lengthN :: (Eq a) => [a] -> Int -> Int
01:03:04 <MarcelineVQ> alternatively you can pattern match the list, which is something you should learn about because writing head and tail all  the time isn't much fun
01:03:12 <ChaiTRex> jusss```: That restricts your lengthN function to working only on certain lists rather than all lists.
01:04:51 <ChaiTRex> jusss```: a, the type of the list elements, is now required to support equality checks (Eq a constraint).
01:05:18 <jusss```> ChaiTRex: why there's not List type... 
01:05:19 <koz_> +1 to pattern matching - it's a very useful thing, and is all over the place in Haskell for a reason.
01:05:22 <jusss```> and [] :: [a]
01:05:39 <ChaiTRex> jusss```: [] is of type [a].
01:06:01 <ChaiTRex> jusss```: It's just that if you want to use (==) on things of type [a], you need a to support (==).
01:06:36 <ChaiTRex> jusss```: If you skip past using (==) to use something like null or pattern matching, you won't need that restriction and your function will work on all lists.
01:07:40 <ChaiTRex> jusss```: null doesn't require checking any elements for equality, so the element type wouldn't need to support that anymore.
01:07:57 <jusss```> ChaiTRex: ok, I should use null
01:09:27 <jusss```> this is used to replace a string with a string
01:09:55 <jusss```> I wrote it with scheme, then transform to haskell...
01:10:20 <jusss```> Data.ByteString.breakSubstring has poor function...
01:14:18 <remexre> is there a way to interleave two conduit operations?
01:16:27 <remexre> i.e. I have foo :: ConduitT Void Void M a, bar :: ConduitT Void Void M b, and I want to get a single ConduitT Void Void M (Either a b) that polls/checks foo and baralternately
01:16:33 <remexre> bar alternately*
01:17:45 <ChaiTRex> jusss```: Here's something quite similar to your lengthN function but with pattern matching instead: https://ideone.com/6EkIyA
01:19:16 <jusss```> ChaiTRex: this is my version now https://paste.ubuntu.com/p/hBHdYbKgXm/
01:19:30 <jusss```> ChaiTRex: I can't visit your link...
01:19:46 <jusss```> it may be blocked on my country...
01:21:44 <jusss```> ok I saw it
01:22:42 <jusss```> let ... in I'm familiar, but `where' not yet...
01:23:24 <ChaiTRex> jusss```: x where y is like let y in x
01:23:55 <ChaiTRex> jusss```: let puts the definitions ahead of where you use them, where after where you use them.
01:25:18 <jusss```> ChaiTRex: ok, but I still think `where' is not easy to read as `let .. in'
01:26:15 <jusss```> one put definition before the expression, another one put definitions after the expression
01:26:29 <ammar2> it depends, sometimes it's nicer to have the "logic" of a function up front and let the intermediate values used be defined after
01:28:05 <ChaiTRex> jusss```: Yeah, tastes can vary.
01:28:45 <ChaiTRex> jusss```: You see how on f, there are two cases. One where you have empty list and one where you have a head and a tail of a list. Since those are the only possibilities for a list, it handles any list.
01:29:34 <ChaiTRex> jusss```: It also does it the way you did it with a separate incremented counter variable.
01:30:36 <ChaiTRex> jusss```: (the n variable in function f)
01:31:15 <jusss```> ChaiTRex: yeah
01:36:58 <svipal> Is it ever possible to do a type application for a parametrized type
01:38:15 <svipal> for instance in a function f :: ParamType b ; f= doStuffWith.(read @b)
01:38:51 <svipal> well the types are wrong, because there' s read
01:39:57 <ariakenom> svipal: do you want ScopedTypeVariables?
01:40:11 <svipal> sure I do
01:41:57 <ariakenom> svipal: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ScopedTypeVariables
01:43:23 <svipal> I know about STV, is it the only way ?
01:45:09 <jusss```> why `x where x=3' is wrong?
01:45:20 <jusss```> but `let x=3 in x' is right
01:46:15 <Ariakenom> svipal: there's asTypeOf
01:46:58 <svipal> juss ?
01:47:10 <svipal> >a = x where x = 4
01:47:19 <svipal> works fine on my ghci
01:47:30 <svipal> Ariakenom : STV it is then hahaha
01:47:50 <Ariakenom> jusss```: where is not part of an expression. like let is
01:51:02 <yushyin> jusss```: https://wiki.haskell.org/Let_vs._Where
02:00:36 <jusss```> yushyin: " because where refers to the pattern matching f =, where no x is in scope. " I don't get it
02:00:51 <jusss```> \x -> y where y = x is not righ?
02:12:51 <yushyin> jusss```: you will get a 'x not in scope' error. 'where' doesn't see the function body but for example the pattern matching in front of '='. f x = y where y = x would work just fine.
02:15:08 <jusss````> yushyin: I see, so `where' need to see the function body, but `let..in' needn't?
02:16:17 <jusss````> but f = State $ \x -> y   where y = ... x ...  this f = State $ \x -> y isn't a function body?
02:21:06 <yushyin> jusss````: yeah the that's a non-working example, the website says so 'will not work,'
02:21:24 <yushyin> -the
02:23:20 <jusss````> " Things in the where clause can refer only to the parameters of the function f (there are none) and things in outer scopes." from https://stackoverflow.com/questions/4362328/haskell-where-vs-let
02:23:23 <jusss````> this is right?
02:27:01 <yushyin> yes
02:27:04 <jusss````> ok
02:32:21 <Unhammer> TIL I can do `data Foo = Int|Bool|Maybe`
02:32:25 <Unhammer> λ> Maybe
02:32:27 <Unhammer> Maybe :: Foo
02:32:46 <merijn> Unhammer: Well, yes, that's why "data Foo = Foo" works :)
02:33:15 <Unhammer> (I'm not sure I should though =P)
02:35:25 <deepgroud> what is the diff between :   data Farmhouse = Product Int Int    and  data Farmhouse = Farmhouse Int Int 
02:35:51 <Unhammer> nothing?
02:36:23 <yushyin> constructor name is different
02:36:54 <deepgroud> so effect is the same
02:40:11 * hackage plugins-multistage 0.6.2 - Dynamic linking for embedded DSLs with staged compilation  https://hackage.haskell.org/package/plugins-multistage-0.6.2 (AndersPersson)
02:46:19 <merijn> deepgroud: Basically, yes
03:42:46 <Orbstheorem> How can I have stack exec pass a specific envvar to the program?
03:48:56 <sshine> doesn't FOO=bar stack exec work?
03:49:47 <Orbstheorem> No :(
03:50:24 <merijn> You need to export variables for them to be visible to anything other than the process you're running
03:50:34 <merijn> They're not transitively visible by default
03:50:45 <sshine> » cat tmp/wat.sh
03:50:45 <sshine> #!/bin/sh
03:50:46 <sshine> echo $WAT
03:50:52 <sshine> » WAT=42 tmp/wat.sh  
03:50:52 <sshine> 42
03:51:07 <sshine> » WAT=42 stack exec tmp/wat.sh
03:51:07 <sshine> 42
03:51:50 <Orbstheorem> For some reason that's not working either
03:52:03 <Orbstheorem> This works, but it's horrible :( `stack build --file-watch --exec "env DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS taffybar"`
03:52:05 <sshine> I copy-pasted from my prompt, I didn't make it up.
03:52:32 <Orbstheorem> sshine: I'm not saying you made it up, maybe my config has something differnt
03:52:48 <Orbstheorem> I'm using nix, could that be an issue?
03:52:57 <sshine> is taffybar an xmonad-related thing?
03:53:33 <sshine> Orbstheorem, I think the answer to "I'm using nix, could that be an issue?" is universally true regardless of the context. ;-D
03:53:33 <Orbstheorem> It's a status bar written in haskell (à la xmonad), but they have no co-dependence between them
03:53:42 <yushyin> stack exec env -- FOO="bar" CMD
03:54:16 <tdammers> sshine: according to the nix crowd, the issue in such cases is that everyone else is doing everything wrong, and if only everyone were to use nix, everything would be fine
03:54:17 <Orbstheorem> sshine: :D
03:54:40 <Orbstheorem> agree with the nix crowd ^^
03:54:51 <sshine> tdammers, if only everyone knew the source of the problem, and how to fix it, it wouldn't be a problem!
03:54:59 <tdammers> sshine: that too.
03:55:51 <Orbstheorem> Oh, also, is there any way to have `stack build --file-watch --exec ...` kill when executed thing when a change has been detected?
03:57:06 <sshine> Orbstheorem, maybe if the exec command does the killing?
03:57:56 <sshine> Orbstheorem, I don't know if it's possible, but you could try to have --exec kill ... --exec ...
03:58:21 <Orbstheorem> Oh, you mean exec fork and kill
03:58:37 <Orbstheorem> --exec `sh -c 'pkill dodo; dodo`
03:58:46 <Orbstheorem> works for me
04:00:51 <Orbstheorem> Horrible, but works: `stack build --file-watch --exec "sh -c \"/run/current-system/sw/bin/pkill taffybar; env DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS taffybar&\""`
04:06:12 <sm[m]> also maybe: ls * | entr -r stack build —exec ... or ghcid -c ‘stack repl’ —test GHCICMD..
04:10:31 <Orbstheorem> sm[m]: Oh, I didn't know entr
04:10:35 <Orbstheorem> Cool ^^
04:11:07 <sm[m]> an excellent tool
04:14:19 <sm[m]> if you can do your thing from ghci (eg —test ‘:main ARGS..’), you can iterate much faster
04:21:33 <Cotton> test
04:36:30 <dignissimus> Would anybody recommend any libraries for working with sound in Haskell? I'm not working with music, I just need to emit sounds at certain frequencies and receive them
04:37:03 <yushyin> sm[m]: why do you use those unicode em-dashes for --? Some kind of auto-ligature mechanism from your client?
04:40:52 <sm[m]> yushyin: I wasn’t aware, thanks for pointing that out. Yes it seems to be a Riot IOS thing, will try to fix
04:41:39 <yushyin> yw!
04:43:30 <sm[m]> ah, just an IOS thing, fixable in keyboard settings. --  👍🏻
04:46:30 <mniip> ``---''
04:50:21 <hpc> dignissimus: there's a few packages floating around
04:50:37 <hpc> i tried synthesizer-core and synthesizer-alsa for just long enough to find out i am not very good at it
04:50:42 <hpc> could be what you need
04:51:03 <hpc> dunno about receiving sounds though
04:53:20 <kuribas> why does binary search only work on mutable arrays?  http://hackage.haskell.org/package/vector-algorithms-0.8.0.1/docs/Data-Vector-Algorithms-Search.html
05:05:12 * hackage concurrent-hashtable 0.1.8 - Thread-safe hash tables for multi-cores!  https://hackage.haskell.org/package/concurrent-hashtable-0.1.8 (PeterRobinson)
05:05:52 <Ariakenom> kuribas: :D
05:09:51 <Philonous> I'm trying to get a better understanding of property based testing and to that end I'm looking into property combinators. One example that keeps being mentioned is testing an equivalence relation. And I see how testing reflexivity is simple enough, just generate a value, check that it's equal to itself. But symmetry and transitivity require 2 or even 3 values that happen to be equivalent in the antecedent, otherwise the property succeeds 
05:09:51 <Philonous> trivially. And even with probabilities of generating equivalent values as high as 10% (unrealistically high) we would generate meaningful tests only in 1% or even 0.1% of cases. To me this would seem fatal the approach. What am I missing?
05:11:48 <merijn> Philonous: quickcheck (and presumably others) allow you to adjust/modify generators to generate values matching a certain predicate
05:14:16 <merijn> Philonous: For example: https://stackoverflow.com/questions/12884927/conditional-quickcheck-properties
05:14:47 <merijn> Philonous: And also: https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck-Modifiers.html
05:15:41 * hackage lightstep-haskell 0.1.4 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.1.4 (DmitryIvanov)
05:19:23 <Philonous> merijn, How does that solve the problem? All it does is discard test cases where the antecedent doesn't hold - we'd still need to e.g. generate ~65k triples of Word8 (a particularly small type) just to find a valid antecendent for transitivity. Admittedly, that's only the case if we're naively recreating all three values, but that seems to be the approach that's chosen. Does QuickCheck even support holding on to some of the generated values 
05:19:24 <Philonous> and just regenerating a third until a property is satisfied?
05:19:46 <lyxia> You would typically have to write a generator by hand to generate equivalent values
05:20:21 <merijn> Philonous: You can create your own generators also note that Gen is a functor
05:20:38 <merijn> Philonous: So you can also write a function that creates something that upholds the precondition from a random value
05:20:46 <lyxia> "typically" being conditional to "wanting to test equivalence relations", which is rare.
05:21:01 <Philonous> lyxia, Yes. And then you'd have to be _really_ careful not to accidentally undermine your test with something that's equivalent to \x -> (x == x && x == x) ==> (x==x) 
05:22:02 <lyxia> I would say that's just a part of the challenge we have to accept.
05:22:03 <merijn> Testing is hard, yeah
05:25:22 <Philonous> That's all fair, but what that means is that just having (\x y z -> (x == y) && (y == z) ==> x == z) actually _is_ fatally flawed and I'm not just missing something?
05:26:31 <Philonous> I'm asking because unless I'm misreading it articles like https://www.fpcomplete.com/blog/quickcheck-hedgehog-validity and the genvalidity-property library seem to be following exactly that approach 
05:26:42 <Philonous> Also, leancheck seems to implement it like that
05:27:33 <ggole> You can't really rely on randomly finding choices of values which have arbitrary relations to other values. That's just not something random generation is going to solve for you.
05:28:10 <Philonous> ggole, That's what I was thinking. Hence my surprise when I read the article 
05:29:08 <ggole> For some problems you can use bounded exhaustive checking, but that has its own limitations
05:29:40 <Ariakenom> bounded exhaustive?
05:30:03 <ggole> Like in smallcheck
05:30:22 <ggole> Generates every combination of values up to a given 'depth', basically
05:30:25 <Philonous> If your types are small enough or you choose a small enough subset you could just try all combinations
05:32:23 <Ariakenom> ok
05:33:04 <Ariakenom> (bounded exhaustive seems like a bad name for it)
05:50:01 <fendor> maralorn, if you are interested, now I cheated around it with: (addTrailingPathSeparator "src" `stripPrefix` "src/Lib/Lib.hs") ==> Just "Lib/Lib.hs"
06:09:35 <jzyamateur> So doing a `bind` with an list, results in subsequent function being executed for each value of the list.?
06:09:58 <jzyamateur> e.g.`["1","2","3","4"] >>= \x -> "0" ++ x` results in `"01020304"`
06:10:34 <merijn> jzyamateur: Yes, bind for list is basically concatMap with different argument order
06:10:35 <Philonous> (>>=) on lists is concatMap, e.g. the function is applied to each value, resulting in a list of lists which is then flattened
06:10:37 <jzyamateur> the order of execution is same as order of items in the list?
06:12:20 <c_wraith> "order of execution" is a loaded phrase in a non-strict language.
06:12:41 <c_wraith> But the order of the output list is determined by the order of the input list
06:12:42 <Philonous> Functions don't have side effects, so you can't observe the order in which they are evaluated anyway 
06:13:31 <c_wraith> and that's required by the monad laws.
06:13:38 <c_wraith> > [1..10] >>= return
06:13:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:13:52 <c_wraith> that list *has* to be in that order
06:15:24 <Philonous> I'd like to point out there's possible confusion between "order of execution" (whatever that means) and "order of elements in the result" 
06:15:57 <greymalkin> What is the GHC extension to use a type in the function's type signature inside the function and have it be explicitly be the same type; I thought it was ScopedTypeVariables, but that's not compiling for me.
06:16:19 <c_wraith> greymalkin: that's correct - what's the error?
06:16:31 <greymalkin> Type `a0` is ambiguous.
06:16:38 <merijn> greymalkin: It is, but you need to explicitly opt-in
06:16:47 <merijn> greymalkin: Use "forall a ." in the signature of your function
06:17:00 <c_wraith> And to be able to use a signature, you also need a separate extension
06:17:27 <c_wraith> InstanceSigs?  Something like that.
06:17:42 <c_wraith> Oh, you never said "in an instance".  sorry.
06:17:47 <merijn> c_wraith: That's for typeclasses?
06:17:48 <greymalkin> https://pastebin.com/n4krjfeF
06:17:51 <c_wraith> i'm apparently not awake yet
06:18:21 <merijn> greymalkin: "parseKey :: Key a => ..." -> "parseKey :: forall a . Key a => ..."
06:18:41 <greymalkin> Yup... 
06:18:44 <merijn> greymalkin: Unrelatedly: I'd recommend replacing the if/then/else with guards
06:18:45 <greymalkin> forall a .
06:19:22 <merijn> greymalkin: The explicit opt-in is to avoid accidentally broken functions where the types in the where clause are, in fact, unrelated
06:19:27 <greymalkin> merijn: This is the first draft, so yes; it's going to be a split-to-tuple case statement soon.
06:33:11 * hackage rewrite-inspector 0.1.0.11 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.11 (omelkonian)
06:37:23 <deepgroud> it just not work ,help! https://pastebin.com/s7kqEEx0
06:38:13 <merijn> deepgroud: You typoed BigFarmmhouses it has an 'm' too much and an 's'
06:38:36 <merijn> deepgroud: Also, ":t" only works on values, but BigFarmHouse is a type (alias), not a value
07:14:35 <fendor> are there some tips on how to remember haddock? I constantly forget which symbols have meaning, etc...
07:26:59 <merijn> fendor: tbh, 90% of my haddock usage consists of like 4 or so symbols, anything else I have to look up :p
07:27:47 <fendor> merijn, yeah, same, but it really breaks the flow when writing documentation and I have to look up examples for lists, code examples, what 'T' actually menas and how hyperlink work
07:28:34 <merijn> fendor: '' is for names, " is for modules, @ is for fixed width/code font and that's basically all I remember off the top of my head :p
07:28:50 <fendor> so, what if I just want to quote stuff? 
07:29:07 <fendor> can I refer to variable names?
07:29:30 <fendor> can I refer somehow to some type of the function definition?
07:29:32 <merijn> fendor: ' refers to both type names and variable names, and \ works as an escape (like in any civilised text format)
07:34:16 <fendor> what about inline code?
07:35:00 <merijn> That's just @
07:37:00 <fendor> could I use [@foo@] to explain the parameter foo?
07:37:42 <merijn> fendor: You know that you can add haddocks to individual function arguments?
07:38:45 <fendor> merijn, yes, but sometimes I want to explain how these parameters work together. Moreover, the Formatting is often very awkward in function arguments
07:39:25 <merijn> fendor: Do you have an example?
07:40:40 <heatsink> Oh, like in doxygen you can write "Returns an array of size \p length" so that "length" refers to the parameter named "length"
07:41:11 <fendor> merijn, https://gist.github.com/fendor/8e95ce2873c5df1d83459b84c4e2cc11 when the explanation of function arguments gets long, I need multiple lines. If I dont want to exceed 80 characters per line, this gets tedious
07:41:46 <merijn> fendor: You can just give a short descript/name and refer to that in the function documentation's text?
07:42:12 <fendor> merijn, but there is not built-in support in haddock, right? So, no goto function gets generated?
07:42:17 <fendor> heatsink, yeah, roughly
07:42:27 <merijn> fendor: Also, what can help with that is indenting your signature less and starting the comments for them on the next line
07:43:26 <merijn> fendor: i.e. when linewrapping signatures I always move the :: to the next line and indent it 4 spaces, so your signatures aren't so far right like your example
07:43:28 <fendor> merijn, but my formatter is doing that :'(
07:43:58 <merijn> (Although, apparently I didn't start comments on the next line in the example I was looking at)
07:44:17 <merijn> I don't believe in autoformatters, *especially not* for Haskell
07:44:26 <merijn> Readability > consistency
07:45:05 <fendor> yeah, but consistency may help readability. Moreover, I dont want to manually format stuff. Or at least, avoid it in most cases
07:46:00 <merijn> fendor: I do try and keep consistent in a way that avoids making formatting much manual work
07:46:33 <heatsink> How do you do that?
07:46:49 <merijn> fendor: So I'd wrap like this: https://github.com/merijn/paramtree/blob/master/ParamTree.hs#L196-L206 (although looking at it now, I'd probably move every argument comment to it's own line following the argument, instead of bunched up at the end of the line
07:46:53 <fendor> and formatting may change depending on the line length, e.g. when I decide, that this function should be in a where block of another function
07:48:03 <fendor> merijn, yeah, this tries to avoid the problem. However, interestingly, I find it very helpful, if the function name is on the same line as (::). Makes it easier to actually find a function definition in a code base :D 
07:48:16 <merijn> I guess
07:48:28 <fendor> but on the other hand, it looks weird and is terrible to minimize git diffs
07:48:46 <merijn> fendor: Also means reindenting if you rename functions
07:48:59 <fendor> yeah, exactly
07:49:11 <fendor> that's what I meant with the git diffs
07:49:36 <merijn> fendor: This style means that indenting a function to a where block is just trivially indenting the signature too. So generally the only change I make when I move function to a where block is that I sometimes have to linewrap long signatures (if they no longer fit), but that's fairly little effort
07:51:01 <fendor> yeah, I think that style is viable. 
07:51:23 <fendor> we can also use the ormolu style :D then we are all unhappy
08:04:06 <dmwit> FWIW I would put all the delimiters in the exact opposite spot.
08:04:46 <dmwit> function ::\n  forall vars.\n  Context =>\n  Arg ->\n  Result
08:05:05 <merijn> dmwit: Heresy!
08:05:22 <dmwit> I like it. It means all arguments have a consistent formatting.
08:05:29 <dmwit> So it's easy to swap them around, delete any of them, insert new ones, etc.
08:05:43 <dmwit> Whereas in your version, the first one is "special".
08:06:09 <dmwit> It also makes certain searches easier, as fendor mentioned.
08:06:12 <merijn> dmwit: My biggest gripe is that the . for 'forall' is only a single character and the rest is all double :p
08:06:18 <dmwit> I can find all the things that return a specific thing with a simple grep, e.g.
08:07:43 <dmwit> merijn: Oh, well, I don't align the delimiters at all. So you don't notice that they're different sizes because they're not visually near each other. =P
08:09:35 <dmwit> Here we go, took me a bit to find an example. https://github.com/dmwit/nurse-sveta/blob/master/src/Dr/Mario/Sveta/MCTS.hs#L91-L95
08:10:53 <fendor> dmwit, yeah, that is the ormolu formatting, right?
08:11:14 <dmwit> No idea. I've never heard the term "ormolu" before that question.
08:13:29 <fendor> dmwit, https://github.com/tweag/ormolu
08:13:31 <fendor> new formatter
08:13:53 <fendor> https://www.tweag.io/posts/2019-10-11-ormolu-first-release.html
08:27:56 <merijn> I feel like I'm missing an abstraction
08:29:12 <merijn> I have several records I need to initialise whose values either come from a "Parser" (with some validation in a specific Monad) or can be produced by actions in said Monad if they're missing. I feel like there should be some easy way to write this, but I can't figure out how
08:30:35 <merijn> I basically have "Compose Parser MyMonad a" where I basically modify my parsers via "Compose $ fmap validationFunc myParser", but once this becomes more than 1 or 2 inputs it becomes unwieldy...
08:31:46 <dmwit> Neither your parser nor your monad offer a transformer version?
08:32:23 <merijn> dmwit: The parser doesn't (it's just optparse) and wrapping my monad around the parser makes no sense
08:32:36 <merijn> I dunno what the semantics of that would be, but they'd definitely be wrong
08:33:17 <dmwit> Okay. My next proposal is higher-order functors.
08:34:48 <merijn> dmwit: Basically, I have "Foo -> Bar -> Baz -> Quux", for each of those values I have an optparse parser + some validation function and just a direct action and I want to end up with something like "Parser (MyMonad Quux)" which fills in any available values via optparse and falls back to the MyMonad action to obtain any missing ones. It feels like this should be possible, but I can't seem to formulate how
08:36:18 <dmwit> I propose instead having MM Foo -> MM Bar -> MM Baz -> Quux MM. Then Parser (Quux MM) is easy to cook up; and there's a nice transformation Quux MM -> MM (Quux Identity).
08:36:33 <dmwit> If necessary, you can also offer freeze :: Quux Identity -> RealQuux.
08:36:48 <dmwit> (MM = MyMonad everywhere)
08:37:05 <merijn> dmwit: That's what I considered yes
08:38:22 <dmwit> ...but?
08:38:36 <merijn> dmwit: I haven't figured out how to make that fit nicely
08:39:43 <dmwit> Which part is "that"?
08:39:51 <dmwit> What's getting in your way?
08:40:59 <merijn> dmwit: Actually, in your example what's the added value of having "Quux MM" as opposed to just returning "MM Quux"?
08:42:22 <dmwit> No Compose+fmap noise. Nothing more.
08:42:54 <dmwit> In edge cases, where the Monad-ness of MM is needed rather than just the Applicative-ness, the other benefit is that it is possible rather than impossible to write.
08:43:26 <dmwit> But it doesn't really sound to me like that is the case here.
08:44:51 <merijn> dmwit: But if you had "MM Foo -> MM Bar -> MM Baz -> MM Quux" then you'd effectively have the same thing as "Quux MM" in that if you applicatively go through Parser you get Parser (MM Quux) which seems basically the same as "Quux MM" + "Quux m -> m (Quux Identity)"?
08:46:02 <dmwit> As I said: it doesn't really sound to me like that is the case here. The benefit is nothing more than less noise.
08:46:45 <dmwit> But given that the problem statement is "too much noise", perhaps that is enough.
08:49:59 <merijn> I need to go play with this some more to figure out if/where this breaks down. I already had a bunch of code that works basically like what you suggest, but I'm not particularly happy with, but maybe it's just a matter of lifting the function out of the parser and having it take "MM"-based arguments
09:00:11 * hackage persistent-template 2.7.3 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.7.3 (parsonsmatt)
09:01:12 * hackage persistent 2.10.3, persistent-mysql 2.10.2 (parsonsmatt): https://qbin.io/ranch-newbie-64z5
09:02:11 * hackage context-free-art 0.3.0.0 - Generate art from context-free grammars  https://hackage.haskell.org/package/context-free-art-0.3.0.0 (414owen)
09:57:48 <kuribas> I found out catch and throw in the continuation monad are just callCC and id
09:57:53 <kuribas> :t callCC
09:57:54 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
09:58:11 <kuribas> I wonder why nobody ever uses it?
10:00:48 <kindaro> kuribas, well, turns out continuation is equivalent to any monad: https://blog.poisson.chat/posts/2019-10-27-continuation-submonads.html
10:01:27 <kuribas> kindaro: I read that one, but I can't see that conclusion
10:01:45 <kuribas> it just looks like lift is bind in the continuation monad
10:01:53 <kuribas> which is another claim
10:02:41 * hackage symantic-document 1.5.1.20191028 - Document symantics.  https://hackage.haskell.org/package/symantic-document-1.5.1.20191028 (julm)
10:03:04 <kuribas> it doesn't seem that interesting
10:03:42 * hackage hjugement-protocol 0.0.8.20191027, symantic-cli 2.4.2.20190806 (julm): https://qbin.io/float-refer-gqsw
10:04:41 * hackage hjugement-cli 0.0.0.20191028 - Majority Judgment and Helios-C command line tool  https://hackage.haskell.org/package/hjugement-cli-0.0.0.20191028 (julm)
10:06:41 * hackage websockets 0.12.6.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.6.0 (JasperVanDerJeugt)
10:12:08 <kindaro> kuribas, as I understand, it means that using an unrestricted continuation is the same as using an arbitrarily large monad transformer stack. It removes all the restrictions, hence all the safety.
10:13:10 <kuribas> how does a continuation remove restrictions?
10:14:10 <kuribas> I don't think it's possible to bypass a transformer stack's restrictions
10:14:42 <kuribas> One of the uses I see for continuation is for example adding non-local exits to parsers.
10:14:52 <kindaro> kuribas, as I see it, if you have an interface with a continuation monad, the user may, with ingenuity, create any effect from any monad whatsoever.
10:15:29 <kindaro> With transformer stacks, it is the entire point that the effects are limited, but with continuation, they are limitless.
10:18:00 <kindaro> kuribas, makes any sense?
10:18:19 <kindaro> Oh, they left...
10:18:27 <hololeap> i'm looking at the vinyl docs and i hit this for ReifyConstraint: Surely given ∀x:u.φ(x) we should be able to recover x:u ⊢ φ(x)!
10:18:48 <hololeap> would anyone be kind enough to try to explain what that means to me?
10:19:40 <nshepperd2> You can do anything with ContT... Your only limit is yourself...
10:31:42 * hackage ats-pkg 3.3.0.1 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.3.0.1 (vmchale)
10:34:20 <nshepperd1> hololeap: given that all items in the record satisfy a constraint, you should be able to deduce that a particular item satisfies the constraint, knowing only that it's in the record
10:43:51 <hololeap> nshepperd1: so, is that some sort of lambda calculus?
10:48:11 <nshepperd1> It's mathematical logic notation
10:50:08 <nshepperd1> "x:u ⊢ φ(x)" means that given x is in the set u you can prove φ(x)
11:00:12 * hackage esqueleto 3.1.3 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.1.3 (parsonsmatt)
11:01:20 <hololeap> but what is phi in this case?
11:01:56 <dminuoso> nshepperd1: We should try and encode TardisT in terms of ContT then.
11:02:01 <dminuoso> Would make for a wonderful excercise.
11:02:34 <nshepperd1> hololeap: some predicate
11:03:19 <nshepperd1> hololeap: in haskell x would be a type and φ would be a typeclass
11:03:35 <hololeap> oh, ok. that makes sense. thanks!
11:04:38 <fendor> @type head
11:04:39 <lambdabot> [a] -> a
11:15:57 <dminuoso> Is there an Alternative instance Im not seeing that encodes First for `f (Maybe t)` in the sense of `(<|>) :: Alternative f => f (Maybe t) -> f (Maybe t) -> f (Maybe t)` returning the first Just, Nothing otherwise?
11:28:42 <lyxia> Monad f => Alternative (MaybeT f)
11:29:46 <dminuoso> lyxia: Ah cheers.
11:30:12 <bobajett> Howdy folks. I noobie question about <*> and >>=. I translated a function from ReasonML to Haskell, but it's still very OCaml-y and not Haskell-ish. Need help in writing it in more idiomatic Haskell: https://gist.github.com/marai2/ecb58216e285b077a83a89f7a07e4c41
11:30:39 <dminuoso> bobajett: Drop |>, replace with (.)
11:31:00 <dminuoso> bobajett: next, use pattern matching for `reciprocal`
11:31:17 <hololeap> dminuoso: Alternative f => Ap f (Maybe (Data.Semigroup.First a))
11:31:31 <dminuoso> hololeap: Oh heh! I should have seen that bingo.
11:31:44 <dminuoso> Ap is a wonderful thing. :)
11:31:55 <hololeap> yeah, it wasn't straightforward to find :)
11:32:24 <dminuoso> hololeap: Though... does that do the right thing?
11:32:43 <hololeap> > Ap [Nothing] <> Ap [Just (Data.Semigroup.First 4)] <> Ap [Nothing]
11:32:46 <lambdabot>  error:
11:32:46 <lambdabot>      Not in scope: data constructor ‘Data.Semigroup.First’
11:32:46 <lambdabot>      Perhaps you meant variable ‘Data.Semigroup.stimes’ (imported from Data.S...
11:33:04 <hololeap> > Ap [Nothing] <> Ap [Just (First 4)] <> Ap [Nothing]
11:33:06 <lambdabot>  error:
11:33:06 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_14’
11:33:06 <lambdabot>      • In the expression: e_14
11:33:23 <hololeap> eh, try it in ghci
11:33:45 <dminuoso> hololeap: I thought First and Maybe should be flipped around.
11:34:00 <hololeap> not for the Semigroup version of First
11:34:08 <bobajett> dminuoso: when I tried - due to precedence of the different operators, I was getting a weird non-intuitive composition like: report $ (digits 2) <*>) cube <*> ((toDouble str) >>= reciprocal) -- which isn't either all strictly left-to-right like ReasonML or right-to-left with (.)
11:34:47 <dminuoso> bobajett: Id decompose into multiple bindings
11:35:01 <bobajett> dminuoso: sorry what does that mean?
11:35:10 <dminuoso> bobajett: Are you familiar with let and where?
11:35:13 <bobajett> yes
11:37:03 <hololeap> dminuoso: it seems to work as you intended, but it does get funky unless the Applicative instance of f is pretty trivial
11:37:12 <hololeap> Ap [Nothing,Nothing] <> Ap [Just (Data.Semigroup.First True)]
11:37:19 <hololeap> Ap {getAp = [Just (First {getFirst = True}),Just (First {getFirst = True})]}
11:37:26 <dminuoso> Heh
11:37:41 <dminuoso> That makes sense, even.
11:38:48 <dminuoso> hololeap: I dont think its funky.
11:38:54 <dminuoso> hololeap: This is what I would have expected it to.
11:40:00 <dminuoso> hololeap: If you wanted the "other obvious behavior" then you would pick ZipList.
11:41:03 <slack1256> I got a haskell binary and the git repo of such program. I would like to know what git revision the binary is based on. Does cabal include that information somewhere?
11:42:32 <dminuoso> hololeap: (I suppose in part the "problem" is that list has more structure than set)
11:44:48 <hololeap> eh, i'm not sure what i was expecting. i haven't really used Ap before
11:53:51 <hololeap> i see, it basically just does `liftA2 (<>)`
12:15:31 <MarcelineVQ> let wNewlines = 0x0a0a0a0a0a0a0a0aL :: Word64   https://haskell-works.github.io/posts/2018-08-08-data-parallel-rank-select-bit-string-construction.html  What is this L at the end of the literal? I don't see L in the haskell report. Is it an actual thing or is it meaning (L)ittle endian or something?
12:16:51 <opqdonut> MarcelineVQ: I'm guessing L for Long just like C, but I don
12:16:52 <opqdonut> 't know
12:19:14 <ChaiTRex> MarcelineVQ: My guess is a typo.
12:19:52 <MarcelineVQ> Could be, I don't see any mention of L in ghc extentions, and the code this post results in doesn't have L anywhere that I saw
12:20:41 <lyxia> data L = L   then make an instance   Num (L -> Word64) ? :P
12:21:49 <lyxia> but I agree it's probably a typo
12:24:22 <hololeap> what would be a good way to write a data type with GADTs that can extrapolate Either to use N terms instead of 2?
12:25:41 <hololeap> (a while back, someone told me that `Rec Maybe` is equivalent to what i want, but i still don't understand why that would be the case)
12:27:19 <lyxia> "extrapolate"?
12:28:19 <lyxia> does this look reasonable    data Sum (xs :: [Type]) where Here :: x -> Sum (x ': xs) ; There :: Sum xs -> Sum (x ': xs)
12:30:31 <hololeap> lyxia: yeah that seems about right
12:31:57 <hololeap> i guess the only thing i would add would be SumNil :: Sum '[]
12:32:52 <lyxia> that wouldn't be much of a sum anymore
12:33:13 <hololeap> a sum with 0 terms?
12:33:35 <hololeap> that part isn't important...
12:34:05 <hololeap> lyxia: can you comment on if this is equivalent to `Rec Maybe`?
12:34:16 <lyxia> Rec being the vinyl thing?
12:34:19 <hololeap> yeah
12:34:28 <lyxia> no it's not
12:34:48 <lyxia> Rec Maybe [x, y, z]  is   (Maybe x, Maybe y, Maybe z)
12:34:59 <hololeap> oh, so it's a product type
12:35:10 <lyxia> There's a CoRec Maybe [x, y z] that would be (Maybe x + Maybe y + Maybe z)
12:35:27 <lyxia> Although if you really want the sum of x y z that's CoRec Identity
12:36:06 <lyxia> yeah I guess it's "Rec" for "Record", which are indeed products
12:36:30 <lyxia> Oh yeah, vinyl records.
12:36:58 <hololeap> :)
12:37:00 <hololeap> i just started looking at vinyl after learning some more about type level programming, and i still don't know what a "record" is supposed to be
12:37:53 <lyxia> I would start with 'a "record" is a tuple where every component has a name'.
12:38:57 <hololeap> oh, i feel like this is getting into dependent map territory
12:39:59 <lyxia> data Pair a b = Pair { fst :: a, snd :: b }   that's a record
12:44:59 <myname_> exit
12:45:35 <lyxia> every language has some form of "record", so if you have a particular language in mind it refers to a specific construct, except that in Haskell 1) records suck 2) people like to reinvent the wheel, so "record" can also refer to one of the numerous encodings people have come up with.
12:56:30 <wroathe> Taking my first foray into Haskell FFI. I've got a C set data structure I'm going to test with quickcheck. My set datatype has the standard set operations like union and difference that take two sets and then allocate a third set as part of the computation. Should routines in C that call malloc/free always oeprate in IO?
12:57:06 <wroathe> i.e. should my union type be union :: Ptr Set -> Ptr Set -> IO (Ptr Set) or is it correct just to do Ptr Set -> Ptr Set -> Ptr Set?
12:57:25 <dminuoso> 20:27:56       lyxia | does this look reasonable    data Sum (xs :: [Type]) where Here :: x -> Sum (x ': xs) ; There :: Sum xs -> Sum (x ': xs)
12:57:32 <dminuoso> lyxia: Where does the `x` type variable come from in There?
12:58:25 <dminuoso> Or was that supposed to be `There :: Sum xs -> Sum xs` ?
13:00:28 <hololeap> lyxia: the reason why i thought of dependent maps was because a record seems essentially like (Map String), except that each element is also implicitly keyed by its type
13:00:34 <wroathe> The rationale behind this question is that "pure" functions in Haskell also require memory allocation (albeit handled by the runtime system), but we still consider them to be pure. In addition to union/intersection my set data type has an init function and a free function that call malloc/free respecitvely
13:01:40 <dminuoso> wroathe: A Ptr is just a pointer, so unless your function `union` is doing pointer arithmatic, I dont think you can avoid IO
13:02:04 <wroathe> dminuoso: The question here is whether malloc/free should be considered "IO"?
13:02:32 <wroathe> My understanding of the FFI from the docs is that the IO designation is technically optional
13:02:47 <wroathe> Because there's no real way for Haskell to know whether the function it's importing does IO or not
13:04:06 <lyxia> dminuoso: there is an implicit forall in front of each constructor's "::", like toplevel definitions
13:04:29 <lyxia> dminuoso: the xs at the left of the "where" is actually unrelated to the others
13:04:54 <lyxia> data Sum (_ :: [Type]) where Here :: forall x xs. x -> Sum (x ': xs) ; ...    is equivalent.
13:04:55 <rotaerk> memory allocation generated by the compiler to implement the program you wrote is different from memory allocation your program explicitly requested
13:05:14 <rotaerk> the latter should definitely be IO
13:05:18 <dminuoso> lyxia: Ah I see.
13:05:49 <wroathe> rotaerk: It does seem like that's the convention I'm seeing for memory allocation routines I'm seeing in Foreign
13:07:06 <rotaerk> you *can* use unsafe* to do it in a pure expression, but it's your responsibility to ensure it effectively behaves purely
13:07:51 <paulasdf> anyone know where I can find how Haskell ADTs are represented in memory? 
13:07:53 <wroathe> rotaerk: I'd somehow have to link it up to the garbage collector for that to be true then, right?
13:08:45 <wroathe> rotaerk: Just by virtue of the fact that I'll need to keep track of the Ptr from Haskell to be later freed means that it can't be "pure" as it's defined in Haskell
13:09:17 <rotaerk> as I understand it, you can use a ForeignPtr to wrap a Ptr and give it a finalizer
13:09:27 <c_wraith> it could be, if you were sufficiently careful.  but it's a lot of work.
13:10:01 <monochrom> paulasdf: https://github.com/takenobu-hs/haskell-ghc-illustrated
13:10:14 <rotaerk> wroathe, there's actually mallocForeignPtr
13:10:18 <rotaerk> which already handles that for you
13:10:38 <wroathe> Oh, I didn't know about ForeignPtr
13:11:23 <paulasdf> thanks monochrom
13:11:36 <wroathe> With ForeignPtr you could then technically make an argument that union :: ForeignPtr Set -> ForeignPtr Set -> ForeignPtr Set is more correct than the IO version, right?
13:12:22 <wroathe> As long as you abstract the calling code from having to deal with the details of how memory is tracked and freed
13:13:28 <c_wraith> foreignPtr has its own issues
13:13:51 <c_wraith> it tends to collect things *too early* unless you're careful.
13:14:13 <rotaerk> how does that work?
13:14:14 <c_wraith> and being careful generally means "using IO" in the end.
13:14:48 <c_wraith> the weak reference is on the ForeignPtr, not the Ptr itself.
13:15:00 <merijn> "IO all the things!"
13:16:20 <dmwit> ...and any references the other language has kept to that Ptr of course won't be known by the Haskell memory manager.
13:17:15 <wroathe> Well, beyond the more general cases that would lead to problems with this my set data type in C seems like a good candidate for this foreign pointer stuff
13:17:19 <merijn> Is it "Let's write C in Haskell!"-o' clock? :)
13:17:22 <dmwit> (For example, does this library of yours let you construct a set of sets? If so, you might be in trouble.)
13:17:27 <wroathe> I'm not storing any static or global references in C
13:17:58 <dmwit> (It doesn't need to be static or global -- just invisible to Haskell.)
13:18:33 <dmwit> (i.e. it could be a data structure which you are keeping a reference to on the Haskell side, but which GHC's garbage collector doesn't know how to traverse to witness references kept inside.)
13:18:47 <wroathe> Don't judge me, it's a heavy divergence from what this repo is supposed to be about :P https://github.com/JustinChristensen/compilers-notes/blob/master/libs/base/intset.c
13:18:59 <wroathe> The goal is to quickcheck this for correctness
13:18:59 <c_wraith> there's a magic primitive for ForeignPtr, toichForeignPtr. it has the unique effect of holding on to a reference to the ForeignPtr until it is executed, despite being a no-op otherwise.
13:19:16 <c_wraith> *touchForeignPtr
13:19:39 <c_wraith> but sequencing that execution correctly requires IO
13:19:46 <dmwit> I don't believe anybody was passing judgments. I think we are all just trying to help you make the best call you can, and part of that process is informing you of common pitfalls.
13:20:11 <merijn> wroathe: There's property testing libraries that can handle IO, though?
13:20:19 <merijn> wroathe: Why not look into those
13:20:30 <dmwit> ...QuickCheck, for example. ^_^
13:21:11 <wroathe> Right now I'm just deciding what the FFI API should look like, merijn, I was assuming Quickcheck will be able to handle whatever I throw at it with this
13:21:44 <merijn> wroathe: I'm inclinced to agree with everyone else that a non-IO based FFI API will lead to sadness
13:22:25 <wroathe> Then IO it is
13:22:51 <c_wraith> I keep wanting to experiment with an ST-based binding. I know I could do it (externally) safely, but there are challenges.
13:23:04 <merijn> wroathe: And I say this as someone who gleefully MagicHashes all over the place :)
13:23:41 <merijn> Can't spell "data FunPtr a" without Fun!
13:25:29 <wroathe> There are a few C implementations of Quickcheck, but I don't see the reason they exist when it's as straightforward as it is to bind your C routines to Haskell and just use QuickCheck
13:27:01 <ibloom> Is there a version of sequenceA that just does in order combination. Basically zip but more general. I have a function :: Linear.V2 (Data.Vector a) -> Data.Vector (Linear.V2 a) and I want to make it polymorphic across different vector types but sequenceA generates every combination of pairs.
13:30:29 <dmwit> You still want sequenceA, you just want a different Applicative instance for your vectors.
13:30:54 <dmwit> Well. Hm.
13:31:08 <dmwit> May not be possible to write `pure` for a hypothetical ZipVector.
13:36:59 <ibloom> Yeah, I guess I have to provide the zip Function.
13:37:12 <dmwit> One moment. I've got something I think you'll like.
13:38:06 <ibloom> :)
13:39:05 <dmwit> ibloom: https://gist.github.com/dmwit/791f05023c4f88114efadfdb903e88c3
13:39:44 <dmwit> traverse V :: V2 (Vector a) -> Zip Vector (V2 a)
13:40:33 <ibloom> Cool is that in hackage?
13:40:40 <dmwit> Nah, I just made it up.
13:40:45 <dmwit> There might be something somewhere.
13:40:47 <dmwit> I dunno.
13:41:08 <dmwit> I disclaim copyright. If you want it, take it.
13:41:38 <dmwit> Not suitable for any use, etc. etc.
13:41:58 <merijn> "WARRANTY VOID WHERE"...
13:42:02 <monochrom> But MonadZip probably comes from hackage.
13:42:09 <dmwit> MonadZip is in base!
13:42:15 <ibloom> Ok thank you. Was thinking there might be a library. Basically I'm shuffling multiple vectors and then combining the shuffled vectors into a vector of pairs or triples or etc.
13:42:16 <dmwit> That one surprised me a little.
13:42:16 <nshepperd2> I normally use unsafePerformIO and withForeignPtr when doing stuff with ForeignPtrs
13:42:24 <monochrom> Oh!
13:42:34 <merijn> nshepperd2: Ah, so you enjoy being unhappy? :D
13:43:05 <dsal> :t unhappyPerformIO
13:43:07 <lambdabot> error: Variable not in scope: unhappyPerformIO
13:43:08 <monochrom> You never know, maybe some people are happier with unsafePerformIO.
13:43:49 <merijn> @quote simonSays
13:43:49 <lambdabot> pikhq says: <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
13:43:50 <monochrom> Like you know how smoking and vaping and drug abuse are totally unsafe but people do it for total happiness?
13:43:52 <nshepperd2> Start with a Ptr/IO based interface, wrap it in unsafePerformIO . withForeignPtr p to turn it into a pure ForeignPtr based interface
13:44:22 <merijn> nshepperd2: I hope to god you're referring to something read-only...
13:44:30 <merijn> If not...
13:44:32 <merijn> @quote not.a.bug
13:44:33 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
13:44:55 <dmwit> Well... not a compiler bug, anyway.
13:45:03 <nshepperd2> Heh
13:45:35 <nshepperd2> Mutating things stay in IO, yeah
13:46:04 <merijn> nshepperd2: If I want a pure read-only interface to ForeignPtr I just use storable Vector
13:46:55 <merijn> Storable Vector is my performance MVP :p
13:47:02 <nshepperd2> Storable vectors can't create gpu memobjects :)
13:47:05 <dmwit> Why is the zip that shortens the longer argument so much more popular than the zip that lengthens the shorter argument?
13:47:18 <deepgroud>  for example  :    type BigFarmhouse =Product NumPig NumSheep        .And  I have   aa = BigFarmhouse b c .  How can I get b and c from aa? 
13:47:19 <merijn> dmwit: I know, right!
13:47:28 <merijn> dmwit: I really need a better way of handling that
13:47:33 <dmwit> Perhaps just because there's only one way to shorten but many sensible ways to lengthen...?
13:47:59 <int-e> :t zipWith
13:48:01 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:48:21 <dmwit> deepgroud: I challenge the claim that you have `aa = BigFarmhouse b c`, under the assumption that "have" includes "and the compiler accepts it".
13:48:44 <int-e> the lengthening version should really have type (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c] and special cases for the case where you pass in identity functions...
13:48:54 <monochrom> zip_lengthening :: (Default a, Default b) => [a] -> [b] -> [(a,b)]  -- would you like Default? >:)
13:49:18 <dmwit> monochrom: That would be fine. Or repeating the last element would be fine.
13:49:42 <ChaiTRex> deepgroud: case aa of (BigFarmhouse b c) -> something with b and c here
13:50:38 <dmwit> Actually, Default is not fine for what I want.
13:50:45 <ChaiTRex> deepgroud: Or rather, whatever the patterns are for the type.
13:50:57 <dmwit> Same to int-e: your proposal doesn't make it possible to implement the "repeat the last element" strategy.
13:51:00 <k0ral> is it expected that `let (Sum a, Sum b) = mconcat [(Sum x, Sum y) | (x, y) <- someList]` is significantly slower than `let (a, b) = foldr (\(x,y) (x',y') -> (x+x',y+y')) (0, 0) somList` ?
13:51:02 <ChaiTRex> deepgroud: Looks like Product b c?
13:51:18 <dmwit> And so I guess this probably answers my original question. There is no lengthening version because there are too many lengthening versions.
13:51:33 <dmwit> Similar to why the split package exists. =P
13:52:04 <[Leary]> I've used `(a -> c) -> (b -> c) -> (a -> b -> c) -> [a] -> [b] -> [c]`
13:52:28 <[Leary]> Don't see a better option.
13:52:37 <deepgroud> ChaiTRex, I try it again
13:52:54 <nshepperd2> Anyway, the point is the "trick" is to never operate on Ptrs in pure code. Do it all strictly in IO and then use unsafePerformIO to say it's pure *after* you're back in ForeignPtr land. Then you never have sequencing issues
13:54:39 <int-e> [Leary]: there is this function in a similar design space: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Lazy.html#v:mergeWithKey ... the idea being that one can pass in 'map f' or 'id' depending on whether one wants to modify the list elements or merely keep them...
13:57:50 <merijn> k0ral: Define expected
13:57:58 <merijn> k0ral: I'm not entirely surprised, no
13:58:21 <dmwit> (forall v. [v] -> Stream (Either v a)) -> (forall v. [v] -> Stream (Either v b)) -> (a -> b -> c) -> [a] -> [b] -> [c]
13:58:25 <merijn> k0ral: I'm betting the latter is pretty easy for the strictness analyser to figure out
13:58:52 <merijn> In general I'm very unhappy with how lazy mappend is in the context of foldMap/mconcat
13:59:20 * dmwit tries to cook up the one true lengthening zip
14:00:24 <hololeap> lyxia: what if i wanted a GADT that behaved more like a power-set? something, where at its third level would look like: data T a b c = T3 a b c | T2A a b | T2B a c | T2C b c | T1A a | T1B b | T1C c
14:00:26 <k0ral> merijn: "expected" as in "yeah, this is trivially a situation where the strictness analyser fails to optimise away thunks"
14:01:05 <merijn> k0ral: I don't think it's obvious the strictness analyser fails to optimise, but I'm also not entirely surprised
14:01:33 <k0ral> merijn: another way of phrasing my question could have been "is there any reason to think this would NOT be related to strictness vs laziness ?"
14:02:05 <merijn> k0ral: Then no, this is definitely strictness vs laziness
14:02:24 <ibloom> Hey dmwit, here's my attempt to use that code. <script src="https://gist.github.com/ianmbloom/eb0e7feebb77635e82e3be45c19bb497.js"></script> Unfortunately I don't quite have it type checking yet.
14:03:02 <ibloom> Link sorry: https://gist.github.com/ianmbloom/eb0e7feebb77635e82e3be45c19bb497
14:04:04 <k0ral> merijn: okay, thanks, now I know where I should focus my efforts :)
14:04:22 <hololeap> i can actually see how `Rec Maybe` would encode this...
14:05:02 <hololeap> is there a way to check the length of a type-level list?
14:05:41 <merijn> hololeap: *a* way, sure. A way that's not painful? Doubtful :p
14:09:31 <k0ral> merijn: is there a way to force strictness inside mconcat, without resorting to reimplement it myself ?
14:09:58 <k0ral> merijn: I have added bang patterns everywhere, and it's better but still not on par with foldr
14:11:02 <merijn> k0ral: Life-hack I've used in the past: "newtype Strict a = Strict a" "instance Monoid a => Monoid (Strict a) where mappend (Strict !x) (Strict !y) = Strict $! mappend x y; mempty = Strict mempty"
14:12:04 <hololeap> merijn: https://gist.github.com/hololeap/82589876ec9240aec82873c85c40926f ?
14:12:54 <merijn> hololeap: Presumably you meant '+' instead of '-', but yeah
14:12:59 <hololeap> oops, that was supposed to be a +
14:13:04 <merijn> hololeap: Now try and make GHC do something useful with that Nat... :p
14:19:47 <monochrom> merijn: I wonder if "Strict (mappend x y)" suffices and doesn't need $!, since "Strict" doesn't exist after compilation.
14:20:16 <merijn> monochrom: It doesn't
14:20:36 <merijn> monochrom: Oh, because of the bangpatterns, on x and y you mean?
14:20:44 <merijn> Perhaps, but I'm paranoid ;)
14:21:47 <monochrom> To a large extent we're looking at "seq x x"
14:22:11 <monochrom> aka "id $! x"
14:22:30 <monochrom> But maybe I should look at the generated code
14:22:38 <hololeap> merijn: i came up with this  https://gist.github.com/hololeap/82589876ec9240aec82873c85c40926f
14:23:25 <hololeap> eh, stupid '-'
14:23:53 <hololeap> https://gist.github.com/hololeap/82589876ec9240aec82873c85c40926f
14:29:48 <joaogui1> Hi
14:29:49 <joaogui1> o/
14:30:17 <joaogui1> How can I use enviroment variables in a .cabal file?
14:31:10 <joaogui1> I wanted to pass the path to a library in ghc-options, but I wanted the user to be able of setting that path himself, and changing it if needed
14:31:39 <merijn> joaogui1: You can't and you should almost certainly not do it this way
14:32:04 <merijn> joaogui1: cabal understand pkg-config, so you probably want to use that to find, for example, C libraries
14:35:48 <joaogui1> sorry, merijn I'm not familiar with pkg-config, how would I go about using it?
14:35:59 <joaogui1> can you point me to some examples please?
14:36:15 <monochrom> merijn: Core shows no difference :)
14:36:23 <merijn> joaogui1: pkg-config is a commandline tool for finding (usually C) libraries
14:36:44 <merijn> joaogui1: on linux if you install a C library via, say, apt-get it'd usually install pkg-config info too
14:37:20 <merijn> joaogui1: Try running "pkg-config --list-all" and see if 1) it's installed and 2) it knows about the library you need
14:38:44 <joaogui1> oooh, got it
14:39:36 <joaogui1> don't think it would help, the idea is that the make file compiles a library (foo.so) and then ghc uses it 
14:39:58 <joaogui1> right now i have ghc-options libs/foo.so
14:40:22 <wroathe> Hmm, if valgrind is to be trusted it seems that ghc 8.6.5 has a memory leak (of 80 bytes, but still) https://gist.github.com/JustinChristensen/1e8e53bcc64780ab2a75b32e9be75fec
14:40:30 <joaogui1> but then if i try to use the file anywhere else it gives an error because there's no libs/foo.so
14:42:50 <remexre> Can I get a type signature like unpackReq :: Req res -> (RequestBody, Prism' ResponseBody res) to typecheck?
14:48:11 <seba88seba> > take 5 [1..10]
14:48:14 <lambdabot>  [1,2,3,4,5]
14:52:15 <necro> yo
14:54:48 <koz_> necro: Hiya!
15:04:06 <wroathe> Ah, they fixed it in a later release: https://gitlab.haskell.org/ghc/ghc/commit/f862963b6cdd217730e4f36f07ad52ac9f7be7f3
15:07:00 <shapr> does hackage have the correct base for ghci 8.8 ?
15:07:08 <shapr> I guess I could just set ghcup to 8.8 and see if it works?
15:07:13 <merijn> shapr: not yet (at least last I heard)
15:08:07 <shapr> oh, too bad
15:11:18 <Kyuxbix> hi
15:11:22 <Kyuxbix> i want to work for haskell
15:12:04 <wildtrees> @let convert [] = id ; convert (x:xs) = (x:) . convert xs
15:12:07 <lambdabot>  Defined.
15:12:19 <wildtrees> @let run action = action [] 
15:12:21 <lambdabot>  Defined.
15:12:42 <wroathe> You know, I can't count the number of times I've used some sort of random test data generator to write unit tests in a corporate context. I didn't know at the time that QuickCheck is what I really wanted.
15:12:58 <wildtrees> > run $ convert "hello" . convert " to the" . convert "world" 
15:13:00 <lambdabot>  "hello to theworld"
15:13:34 <wildtrees> does doing string appending this way with convert and (.) make long series of appens O(n) instead of O(n^2) ? 
15:14:00 <wildtrees> string appends, even 
15:14:01 <merijn> wroathe: :)
15:14:51 <merijn> wildtrees: depends on how accurate you want to be
15:14:58 <merijn> wildtrees: But it is much more efficient, yes
15:15:11 <merijn> wildtrees: This trick is usually know as DList
15:15:17 <merijn> wildtrees: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
15:15:52 <merijn> wildtrees: If you've ever heard people throw around "codensity transform" as a word, then that's just fancy-pants speak for "generalised DList"
15:16:11 <wildtrees> yea I was referred to difference lists the other day, I watched a video link dlists and codensity transformer, but the transfomration I saw was using convert string = (string ++) 
15:16:38 <wildtrees> I had heard of dlists years ago, I think from real world haskell, but they didn't really click and settle in 
15:16:41 * hackage hapistrano 0.3.9.4 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.9.4 (juanpaucar)
15:16:44 <merijn> wildtrees: That's basically the same thing
15:23:05 <Kyuxbix> give job
16:15:01 * Axman6 holds up his Will Worf for Haskell sign by the traffic lights
16:15:35 <Axman6> hmm, also Work, but Worf is fine too
16:15:41 <Clint> strange image
16:21:08 <pikajude> Worf
16:21:11 <hololeap> is there any way to go from something of kind (Maybe a) to something of kind Type with the type (Maybe a)
16:21:50 <Axman6> singletons?
16:22:16 <koz_> Yeah, singletons is the best we have for something of that nature.
16:22:27 * koz_ points at jle`'s Introduction to Singletons.
16:23:03 * Axman6 also points at jle`'s introduction, all the time, because it's great. My arm hurts
16:24:38 <hololeap> well the first kind would actually be (Maybe Type), but i'll assume the singletons suggestion still stands
16:25:05 <koz_> hololeap: If you need to 'pull down' kinds into types, you need singletons, because GHC won't do it for you, unless it's Nat.
16:25:37 <koz_> s/kinds into types/types into values/ but close enough. :P
16:25:55 * koz_ mumbles something about Dependent Haskell not being a thing.
16:29:09 <merijn> hololeap: Word of warning, there's a reason the singletons paper was called Hasochism ;)
16:29:12 <remexre> is there something obviously wrong with the use of STM in lines 51-55 of https://foundry.remexre.xyz/projects/flubber/blob/HEAD/src/Network/Flubber/Plugins/Worker.hs ?
16:29:39 <koz_> Yeah, it's a bit of a learning curve. Only do this if you _really_ need that kinda thing.
16:29:48 <koz_> (spoken as someone who loves dependent typing dearly)
16:30:17 <merijn> remexre: Yes :p
16:30:23 <Axman6> remexre: looks like you could be building up some pretty big thunks if you're doing that a lot
16:30:38 <merijn> Axman6: More crucially, it won't ever succeed
16:30:47 <remexre> yeah, the not succeeding is what I meant
16:30:49 <merijn> remexre: readTMVar doesn't *empty* the TMVar
16:30:57 <merijn> remexre: So the putTMVar blocks forever
16:30:58 <remexre> once it worksish I'm gonna slap !'s everywhere :P
16:31:13 <Axman6> ah, that too
16:31:19 <merijn> remexre: Also, TMVar suffers from thundering herd issues
16:31:34 <Axman6> I missed it was a TMVar - if it's only read and written in the same transaction, surely a TVar would be fine?
16:31:35 <koz_> merijn: Thundering herd?
16:31:42 * hackage esqueleto 3.2.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.2.0 (parsonsmatt)
16:31:44 <pikajude> i thought that was a GNU thing
16:31:51 <remexre> oh, right, I'm still not used to (T)MVars versus OCaml box-es :P
16:32:11 <merijn> remexre: Also, TMVar doesn't seem relevant since you don't actually use the potential emptiness
16:32:17 <merijn> remexre: Don't you just want TVar?
16:32:22 <Axman6> @hoogle TMVar a -> STM a
16:32:22 <lambdabot> Control.Concurrent.STM.TMVar takeTMVar :: TMVar a -> STM a
16:32:22 <lambdabot> Control.Concurrent.STM.TMVar readTMVar :: TMVar a -> STM a
16:32:23 <lambdabot> UnliftIO.STM takeTMVar :: () => TMVar a -> STM a
16:32:44 <merijn> koz_: That's when an action wakes up a large herd of threads all waiting on some condition and they stampede all over your scheduler
16:32:54 <Axman6> takeTMvar would be the correct function to use if you're using putTMvar, but then it's just the same as a TVar
16:32:58 <merijn> koz_: https://en.wikipedia.org/wiki/Thundering_herd_problem
16:33:37 <merijn> remexre: If you just want to atomically overwrite the value in a mutable variable TVar will do and be more efficient
16:33:43 <koz_> merijn: Thanks, will read.
16:33:52 <remexre> merijn: huh, okay
16:33:53 <MarcelineVQ> @where parconc
16:33:53 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
16:33:59 <Axman6> remexre: I would make the fields of State strict, and use Data.Map.Strict to avoid building up large thunks
16:34:04 <MarcelineVQ> covers the difference between mvar and tvar in scheduling
16:34:28 <merijn> koz_: Basically, MVar's are "single wakeup" so if 10k threads are all blocked on reading from a single MVar and you write to it only *one* of those 10k will be woken up
16:34:28 <remexre> Axman6: yeah, I'm doing all that once this thing minimally works
16:34:43 <remexre> though I've been inconsistent on Map vs Map.Strict, yeah...
16:34:48 <merijn> koz_: With TVar *all* 10k threads wake up, are scheduled and then 9,999 of them block immediately again
16:34:58 <merijn> koz_: So you end up wasting a whole bunch of CPU
16:35:09 <merijn> On context switches and the likes
16:35:57 <merijn> remexre: TMVar is really only useful if you want you variable to have a notion of "empty" or "absent", which you don't seem to need. TVar just gives you read/write and atomically already guarantees, well, atomicity :)
16:37:08 <remexre> merijn: okay, yeah; I'm using TMVar where I /do/ need emptiness elsewhere
16:43:42 <wildtrees> how does instance Someclass r => Ctx -> r where .... work? is that making Someclass (Ctx -> r) ? 
16:44:14 <Axman6> is there something missing there? that doesn't look valid
16:47:50 <Axman6> wildtrees: did you mean instance Someclass r => Someclass (Ctx -> r) where?
16:48:31 <wildtrees> no 
16:48:34 <wildtrees> let me try it again 
16:48:42 * hackage ghc-events 0.11.0 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.11.0 (MitsutoshiAoe)
16:50:47 <wildtrees> Axman6, I guess you are correct! I must have misread it the other day 
17:32:16 <remexre> are Handles like, absurdly buffered?
17:34:05 <dmwit> I don't think it's absurd.
17:34:10 <Axman6> what problem are you having?
17:34:15 <remexre> I mean like a 1GB buffer or smth
17:34:20 <remexre> not that buffering is absurd
17:34:20 <Axman6> they're line buffered usually
17:34:22 <dmwit> You can choose between unbuffered, line-buffered, and block-buffered at your choice of size, as usual for handles in most languages.
17:34:42 <dmwit> I think the default block-buffering size on most systems is in the 4K-8K range.
17:35:18 <remexre> hm, ok
17:36:02 <remexre> time to dig into typed-process for its buffering, ig
17:36:49 <remexre> the issue is writing to tee foo through a conduit nevers shows up
17:42:35 <Axman6> is there something reading the output from tee?
17:42:53 <remexre> yeah, but nothing's showing up from it doing so
17:43:02 <remexre> i.e. it looks like tee's also not outputting to stdout
17:43:10 <remexre> I can swap tee for cat >
17:43:34 <remexre> yeah, ditto
17:44:23 <Axman6> want to share some code?
17:44:55 <remexre> sure, I'll push again
17:45:52 <remexre> https://foundry.remexre.xyz/projects/flubber/blob/HEAD/src/Network/Flubber/Plugins/Worker.hs
17:46:37 <remexre> inputThread there should be doing the writing
17:48:02 <remexre> inputThread is conduitToJSON here: https://foundry.remexre.xyz/projects/flubber/blob/HEAD/src/Network/Flubber/Utils.hs
17:48:14 <remexre> before a sinkHandle to a handle gotten from typed-process
17:49:22 <dmwit> That looks complicated enough that it might be worth spending some time minimizing before you dig too much.
17:49:32 <remexre> yeah... :(
17:50:22 <remexre> idk, is there a good way to debug conduit stuff? I guess mapC traceShowId
17:55:59 <remexre> huh, mapC traceShowId in the pipeline to sinkHandle does print the value that should be put there... time to minimize
17:59:37 <dsal> remexre: I had bugs in conduit code that went away when I tried to prove conduit wrong.  Then I fixed them.  Then I couldn't understand why I thought I was right.
18:00:16 <remexre> hot take: that makes conduit a bad abstraction :P
18:01:05 <dsal> Nah.  I think it's pretty good. I just did dumb things with it once or twice.
18:01:42 <remexre> maybe I'm doing the same, but I don't think so :P
18:02:42 <MarcelineVQ> bugs that appear and dissapear when you try to expose them smack of strictness issues
18:02:58 <remexre> bug's never disappeared tho
18:07:22 <remexre> https://p.acm.umn.edu/W4VDS0158AA=
18:07:27 <remexre> okay, this reproduces
18:09:23 <remexre> this is with OverloadedStrings btw
18:11:02 <remexre> https://p.acm.umn.edu/W4VEG0PLEAI= for .cabal file, if it matters
18:13:37 <remexre> oh, wait, if I hClose the handle it works, implying that buffering is the issue...
18:17:21 <dmwit> But "foo" is nowhere near large enough to hit any sane buffer size.
18:17:38 <dmwit> And doesn't contain a newline so wouldn't hit the line-buffering reason to flush.
18:17:59 <dmwit> So why were you asking about gigabyte-sized buffers?
18:19:07 <remexre> because in my real program I sent what should've been well over 4k of output
18:19:28 <dmwit> Then you should make your reproducing example send well over 4k of output.
18:19:32 <remexre> and after removing buffering only the first value ends up in the file...
18:19:53 <dmwit> What does "removing buffering" mean?
18:20:00 <remexre> hSetBuffering _ NoBuffering
18:20:07 <dmwit> cat will have its own buffer, of course.
18:20:55 <dmwit> Maybe bash will too, though it's probably written carefully enough that it won't matter.
18:22:44 <dmwit> I would be interested to see the one-step-more-complicated example that is supposed to dump a ton of stuff but only dumps one stuff.
18:23:04 <dmwit> This example here doesn't seem interesting to me. Just behaving as expected TBH
18:24:50 <remexre> I've got a channel that generates biggish jsons from things received over a TMChan
18:25:08 <remexre> and now mapC traceShowId is only printing the first, so I think it's on that side
18:25:59 <dmwit> ...and this is why you minimize starting with the thing that actually isn't working, instead of starting from scratch and trying to build back to it.
18:26:03 <dmwit> =P
18:27:15 <remexre> I mean, I'm wasn't sure what wasn't working
18:27:51 <dmwit> I'm confident of that. If you did know what wasn't working, you would have just fixed it.
18:28:21 <remexre> lol
18:29:28 <dmwit> Wise tautology #4: Every inexplicable problem is caused by something you don't think is the cause. http://www.vex.net/~trebla/humour/tautologies.html
18:30:56 <remexre> actually, now that I'm thinking of it, is there anything that implements a more erlangy thread model to haskell? Main thing being exit signals ig
18:31:47 <dmwit> I don't know what "more erlangy" means.
18:31:55 <remexre> has the same abstractions erlang does
18:32:01 <dmwit> That doesn't help me.
18:32:44 <maralorn> Was erlang the one with the actor modell?
18:32:48 <remexre> I'll google later ig :P there's a bunch of them
18:32:49 <remexre> yeah
18:33:02 <remexre> but there are some stdlib things that're nice for having "trees of processes"
18:38:04 <remexre> wait, why does reading an MVar time out when there (ought to be) a live handle to it elsewhere
18:38:20 <remexre> sigh, nvm, too annoyed to keep working on this tonight
18:38:29 <remexre> back to compilers, where everything is a pure function :P
18:39:00 <dmwit> Reading an MVar never times out. It can throw an exception if there's no writer.
18:39:32 <remexre> the writer should still exist in a map that may eventually be written to
18:40:12 <remexre> (it isn't, but that's b/c I never give it the input via the subprocess that it needs in order to)
18:41:10 <dmwit> I challenge your claim that there are live handles to it that are not either all readers or all writers. I want to see evidence of this fact before I believe it.
18:41:53 <remexre> "should"
18:42:23 * dmwit grins
18:42:50 <remexre> that's why I was asking abt erlang
18:43:45 <remexre> in erlang, if you're managing a "subthread," when it dies non-normally, it kills you too
18:44:03 <remexre> by default, this is changable with 1 LoC, etc
18:44:37 <remexre> but it's p. convenient for detecting when things go wrong
18:44:50 <dmwit> Seems fairly easy to write in Haskell.
18:45:17 <dmwit> You can make a forkIO wrapper that calls `catch` and, on an exception, throws an asynchronous exception to the forking thread.
18:45:23 <remexre> sure, I'm wondering if anyone has :P
18:45:41 <remexre> also if you get async-exception'd during your catch handler, doesn't that not work?
18:46:16 <dmwit> You would have to mask exceptions in the handler. Standard fare for exception handling.
18:47:17 <dmwit> You might look at the async package. I haven't used it myself but everyone else seems nuts about it. I believe it has a way of either being told about or thrown exceptions -- though probably only once you wait on the asynchronous result, so maybe not fine-grained enough for you.
18:47:27 <dmwit> Anyway may be worth a look given how excited other folks seem to be.
18:47:31 <remexre> huh, ok
18:48:19 <remexre> it goes on my "next time I feel like I have enough energy to work on things that aren't pure code" :P
18:48:31 <remexre> er, code" list* :P
18:59:18 <fresheyeball> yo Haskell folks
18:59:28 <fresheyeball> how can I preview the haddocks for the libary I am coding?
18:59:34 <fresheyeball> I gots to make this shit look nice
18:59:48 <pikajude> cabal haddock?
18:59:55 <fresheyeball> is it that easy?
18:59:57 <fresheyeball> damn
19:03:15 <fresheyeball> pikajude++
19:03:18 <fresheyeball> it was just that easy
19:03:21 <fresheyeball> thank you
19:03:52 <pikajude> speaking as a programmer, if it wasn't that easy, i would never build docs
19:06:35 <pacak> Tsuru Capital is hiring a full time haskeller: https://www.reddit.com/r/haskell/comments/dojcer/tsuru_capital_is_hiring_a_full_time_position/
19:06:57 <pikajude> oo, japan
19:07:12 <pacak> Tokyo
19:47:49 <Kyuxbix> hey
19:47:53 <Kyuxbix> who is the CEO of Haskell
19:49:17 <ammar2> Kyuxbix: https://wiki.haskell.org/Haskell_Governance
19:50:24 <Kyuxbix> i want to talk with the first in charge
19:50:33 <justsomeguy> The living god SPJ governs these lands. Some say Paul Hudak whispers to him from the heavens on high.
19:51:03 <justsomeguy> :^P
19:51:45 <maerwald> He's not on IRC I think
19:51:56 <maerwald> Email or LinkedIn is probably the way to go
20:04:36 <badzergling> the ceo of haskell posts on twitter occasionally.  I'm not sure you'll like it though https://twitter.com/haskellceo?lang=en
20:11:42 <maerwald> hilarious
20:12:22 <laudecay> me too
20:16:33 <sm[m]> lol
20:22:11 * hackage reflex-backend-socket 0.2.0.0 - Reflex bindings for TCP sockets  https://hackage.haskell.org/package/reflex-backend-socket-0.2.0.0 (qfpl)
20:46:40 <jusss``> what's the login operator in hasekll? like `and' `or' and `not'?
20:47:24 <heatsink> > (False && undefined) || not True
20:47:26 <lambdabot>  False
20:47:45 <jusss``> ok
20:48:40 <jusss``> heatsink: the identifier naming rule, can we use symbol like ? and !
20:48:48 <jusss``> isConn?
20:49:41 <heatsink> You can only use symbols as infix operators
20:50:05 <jusss``> ok
20:50:31 <heatsink> The ! symbol has a special meaning
20:50:56 <heatsink> So you can define an operator like (x ? y)
20:52:57 <jusss``> but I'd like to define an identifier of value like isConn?
20:54:16 <heatsink> "isConn?" isn't a variable name in haskell
20:54:36 <dibblego> no, you cannot have the trailing ?
20:55:03 <sicklorkin> > let maybe? = Just 2 in maybe?
20:55:05 <lambdabot>  <hint>:1:12: error:
20:55:05 <lambdabot>      parse error on input ‘=’
20:55:05 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
20:55:48 <sicklorkin> >  let maybe?2 = Nothing in maybe?2   
20:55:50 <lambdabot>  Nothing
20:56:42 <sicklorkin> > let '?maybe = Nothing in '?maybe
20:56:44 <lambdabot>  <hint>:1:6: error: parse error on input ‘?maybe’
20:57:23 <rustacean> hi
21:02:21 * dmwit waves
21:06:12 * hackage list-transformer 1.0.6 - List monad transformer  https://hackage.haskell.org/package/list-transformer-1.0.6 (GabrielGonzalez)
21:14:44 <Axman6> how corrodes it rustacean
21:38:12 * hackage b9 0.5.68.4 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.68.4 (SvenHeyll)
22:32:45 <wejetheman> this code is for an exercise im working on http://codepad.org/1bYkPYnn supposing that this was part of a larger project, and toBinary was only used once in that project, is it considered more standard or more recommended to put it inside of the while or leave it at top level
22:33:03 <wejetheman> sorry i meant toBinary was only used in that one function
22:33:34 <wejetheman> i never know whether to put code inside my whiles or not
22:36:22 <ski> wejetheman : depends on whether you think `toBinary' could have indendent use or not
22:36:50 <ski> i suppose it could possobly have
22:36:50 <Axman6> I assume you mean `where` and not `while`?
22:37:10 <ski> presumably
22:37:15 <wejetheman> yes sorry where
22:37:37 <ski> also, `toBinary' and `f' probably shouldn't keep adding stuff to the end of lists, since that is needlessly inefficient
22:39:05 <wejetheman> i didnt know adding things to the end of a list is inefficient 
22:39:10 <sicklorkin> wejetheman: see https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/lists.pdf
22:39:21 <wejetheman> should i be attempting to add things to the beginning instead?
22:39:35 <ski> (matters less for `f', i suppose, since it only looks at at most four elements of the list)
22:39:41 <javbit[m]> Yeah, cons is O(1)
22:41:13 <ski> wejetheman : the problem is that while `as ++ (bs ++ (cs ++ ds))' takes as many steps as there is elements in `as' (say `m'), in `bs' (say `n'), in `cs' (say `o') combined (so `m + (n + o)')
22:42:01 <ski> wejetheman : `((as ++ bs) ++ cs) ++ ds' will take `(m + (m + n)) + (m + n + o)' steps
22:42:45 <wejetheman> i was rather proud of that solution too... the toBinary
22:43:24 <ski> first `as' is traversed (making a copy, with the tail (the empty list) being replavced by `bs'. then this list is traversed, (traversing essentially `as' again. and then traversing `bs'). then `as' is traversed again, and `bs' again, finally traversing `cs'
22:43:39 <ski> wejetheman : it's fine, as a first attempt :)
22:43:54 <wejetheman> lol you dont want to see my first attempt
22:44:11 <sicklorkin> :)
22:44:39 <ski> however, when you see `toBinary (...) = toBinary (...) ++ (...)', then this is going to produce something like `((as ++ bs) ++ cs) ++ ds', rather than something like `as ++ (bs ++ (cs ++ ds))'
22:45:35 <ski> it's not that `(++)' is inefficient. it's that *repeteadly* adding to the end of a list, is *unexpectedly* inefficient (quadratic, rather than linear)
22:46:01 <wejetheman> is reverse inefficient? because its easy to solve it by appending left then reverse at the end
22:46:12 * hackage quokka 0.1.0.0 - Test helpers which help generate data for projects that use postgresql.  https://hackage.haskell.org/package/quokka-0.1.0.0 (shirren)
22:46:17 <wejetheman> i should say if i can reverse at the end
22:46:40 <dibblego> that would be O(n^2)
22:46:49 <dibblego> it can be done in O(n)
22:46:57 <Axman6> wejetheman: remember that (++) has to iterate over every item in the first list you give it. so if you have ((as ++ bs) ++ cs) ++ ds then every item in as has to be be iterated over to produce as ++ bs, every element of as and bs then has to be iterated over (again) to crteate (as ++ bs) ++ cs etc
22:47:26 <wejetheman> so as a general rule : instead of ++ and ill be good
22:47:52 <Axman6> well, sort of, but only if you understand why
22:49:32 <wejetheman> okay well maybe ill try to figure it out tomorrow but by 2 am i cant think abstractly any more, thanks for the pointers
22:50:42 * hackage reflex-basic-host 0.2.0.1 - A basic Reflex host for backend work  https://hackage.haskell.org/package/reflex-basic-host-0.2.0.1 (qfpl)
22:51:28 <ski> wejetheman : `++' is fine, if you repeated add to the start
22:51:55 <wejetheman> "remember that (++) has to iterate over every item in the first list you give it" makes sense to me
22:52:12 * hackage quokka 0.1.1 - Test helpers which help generate data for projects that use postgresql.  https://hackage.haskell.org/package/quokka-0.1.1 (shirren)
22:52:35 <ski> wejetheman : <https://en.wikipedia.org/wiki/Joel_Spolsky#Schlemiel_the_Painter's_algorithm>
22:52:37 <wejetheman> i understand what i need to avoid, i just cant go and make a better toBinary right now is all
22:54:03 <nshepperd> building lists backwards then reversing them afterwards is something i do sometimes
22:57:16 <nshepperd> i guess proper difflists would probably be more performant
23:08:51 <dminuoso> ski: Would you happen to have a good introductory read into logic similar in detail and accuracy to the terms being used to Per Martin-Loef's "ON  THE  MEANINGS OF  THE  LOGICAL CONSTANTS  AND  THE  JUSTIFICATIONS OF  THE  LOGICAL  LAWS"?
23:23:11 * hackage core-text 0.2.2.1 - A rope type based on a finger tree over UTF-8 fragments  https://hackage.haskell.org/package/core-text-0.2.2.1 (AndrewCowie)
23:25:12 * hackage core-data 0.2.1.0 - Convenience wrappers around common data structures and encodings  https://hackage.haskell.org/package/core-data-0.2.1.0 (AndrewCowie)
23:28:12 * hackage core-program 0.2.2.0 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/core-program-0.2.2.0 (AndrewCowie)
23:38:54 <jackdk> is there an easy way to tell when a package uploaded to hackage will get its documentation built (or has failed?)
23:41:06 <koz_> @unmtl ReaderT i (State s a)
23:41:06 <lambdabot> Plugin `unmtl' failed with: `ReaderT i (s -> (a, s))' is not applied to enough arguments.
23:41:24 <koz_> @unmtl ReaderT i (State s) a
23:41:24 <lambdabot> i -> s -> (a, s)
23:42:54 <dminuoso> @unmtl ReaderT T (State S A)
23:42:54 <lambdabot> Plugin `unmtl' failed with: `ReaderT T (S -> (A, S))' is not applied to enough arguments.
23:43:11 <dminuoso> Oh.
23:44:03 <koz_> That's so very handy.
