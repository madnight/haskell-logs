00:00:17 * koz_ mumbles something about Dhall.
00:06:26 <sim590> can one stack more than two monads in a transformer? :D
00:07:15 <Ariakenom> sim590: you can have more than 2 transformers in a monad transformer stack, yes.
00:08:01 <sim590> Ariakenom: So I would have like A transformer of a (Transformer) (Monad3) sort of?
00:08:18 <Ariakenom> (a monad is not a monad transformer)
00:09:15 <Ariakenom> sim590: I don't undestand the question. but I dont know much about tranformers so maybe thats why
00:09:38 <sim590> Let me be more clear. I could have like `MaybeT (ReaderT Int (State StdGen) SomeType) Bool` Sort of?
00:10:11 <Ariakenom> as far as I know that looks correct
00:11:05 <__dingbat__> Now I am facing runtime error --> HelloWorldApp: AesonException "Error in $.trustedPeers[0]: key \"getPeer\" not present"
00:11:30 <__dingbat__> I have changed the config file to JSON (updated on the link)
00:12:04 <Ariakenom> sim590: try typing it
00:12:04 <koz_> sim590: You can build your stack as high as you like.
00:12:38 <koz_> You can have StateT Int (StateT Char (StateT String (StateT Float Identity))) a if you need.
00:13:16 <koz_> If you squint a bit, you can view a transformer stack as a linked list of effects.
00:21:45 <sim590> Yeah. I see that. That's useful to avoid writing case thing of ; Just -> return $ ... ; Nothing -> return Nothing everywhere.
00:22:41 <maerwald> it reminds me of OOP, tbh
00:23:08 <dminuoso> sim590: It's even more than that.
00:24:19 <maerwald> instead of a declarative API, you're dealing with details and ordering of effects, lifting, unlifting, behavior inside behavior... basically OOP
00:24:23 <koz_> Transformer stacking is necessary to combine monadic effects due to the unfortunate problem that (Monad f, Monad g) => Monad (Compose f g) isn't in general a thing. :(
00:24:25 <dminuoso> sim590: The boilerplate in the respective Monad instance for your transformer is hidden away, and that can be more than just plain case of.
00:25:12 <dminuoso> sim590: At the end a transformer can be thought of as a type-level function that takes a monad, and returns a new monad with (usually) effects of a third monad embedded.
00:25:22 <koz_> (if only)
00:25:50 <bahamas> has anyone installed ghcide with nix lately? the version for ghc 8.4 seems to be building everything. I'm curious what version is already built
00:26:02 <dminuoso> sim590: So it allows you to imbue some monad with effects of another.
00:30:24 <syd> Hi Peeps
00:30:32 <syd> I have a difficult-to-debug problem
00:30:44 <syd> I'm getting this error in a test where two clients concurrently call a server:
00:30:52 <syd> >  /dev/null: hDuplicateTo: resource busy (Device or resource busy)
00:30:54 <lambdabot>  <hint>:1:1: error: parse error on input â€˜/â€™
00:30:58 <syd> the error message is not very helpful
00:31:11 <syd> How would you go about debugging such a thing?
00:31:22 <dminuoso> syd: Where is it thrown from?
00:31:34 <syd> no idea :p
00:31:37 <syd> how would I find that out?
00:32:10 <syd> I'm running both clients _and_ the server from the same test
00:32:20 <dminuoso> syd: You could recompile with profiling and run with `+RTS -xc`
00:33:33 <Ariakenom> I always forget the name of compare. can we rename it to order? kthx
00:36:24 <Ariakenom> syd: dminuoso's suggestion will get you a stack trace
00:38:40 <syd> found the culprit
00:38:57 <syd> http://hackage.haskell.org/package/persistent-2.10.1/docs/Database-Persist-Sql.html#v:runMigrationSilent
00:39:09 <syd> this uses `hSilence` from `silently`
00:39:12 <syd> and that's not thread-safe
00:39:59 <Ariakenom> (500 :: Double) `asBoundedBy` (undefined :: Word8) = (255 :: Double) -- this looks useful
00:40:47 <dminuoso> Perhaps a unified namespace really would do us well.
00:40:59 <Ariakenom> :
00:41:02 <Ariakenom> :)
00:41:13 <dminuoso> (500 :: Double) `asBoundedBy` Word8
00:41:16 <dminuoso> This would read nicely :)
00:41:34 <syd> you can use `asBoundedBy @Word8 (500::Double)`
00:41:34 <__dingbat__> Any help on my last question please?
00:41:49 <syd> __dingbat__ could you repeate it?
00:42:18 <Ariakenom> boundBy @Word8 (500 :: Double)
00:42:32 <dminuoso> syd: That's still not the same namespace.
00:42:55 <Ariakenom> dont think you can type apply to infix 
00:43:01 <dminuoso> syd: We already have the other way around, you can refer to term-level things in the type system.
00:43:39 <Ariakenom> oh syd beat me to it :)
00:43:51 <dminuoso> % :k Const Int True
00:43:52 <yahb> dminuoso: Const Int True :: *
00:44:39 <Ariakenom> for a nice implementation you need type variables at term level too
00:45:02 <dminuoso> Ariakenom: That's what I was saying. :)
00:45:06 <syd> __dingbat__ it seems that your json file is missing a key
00:45:13 <__dingbat__> syd , https://www.codepile.net/pile/5yjd2Rvm
00:45:42 <syd> in the first element of the list
00:45:48 <syd> there's a key called `getPeer` missing
00:45:58 <syd> can I see your code for your `Peer` type?
00:46:24 <__dingbat__> the Peer type is defined on line 11 of the link
00:47:07 <__dingbat__> it doesn't make sense to add getPeer as a key in the json file
00:47:10 <syd> on line 31
00:47:23 <syd> you're asking, in the fromjson instance of `Peer` 
00:47:35 <syd> to read a _list_ of objects
00:47:51 <__dingbat__> yes
00:47:52 <syd> but there's already an instance of `FromJSON a => FromJSON [a]`
00:48:19 <__dingbat__> ok..
00:48:27 <syd> Try just this instead `Peer <$> ((,) <$> v .: "nodeID" <*> v .: "endPoint")`
00:49:53 <__dingbat__> you mean like this -
00:49:54 <__dingbat__> instance FromJSON Peer where
00:49:56 <__dingbat__>     parseJSON  (Object v) = Peer <$>
00:49:57 <__dingbat__>                             v .: "nodeID" <*>
00:49:59 <__dingbat__>                             v .: "endPoint" 
00:50:00 <__dingbat__>     parseJSON _ = error "Can't parse Peer"
00:50:03 <syd> yes
00:50:12 <syd> and see if that does what you want
00:50:47 <syd> I find it a tad weird that you use a newtype over a tuple instead of just a record, but that's a seperate question
00:51:49 <__dingbat__> I tried this ->
00:51:50 <__dingbat__> instance FromJSON Peer where
00:51:52 <__dingbat__>     parseJSON  (Object v) = Peer <$> ((,) <$> v .: "nodeID" <*> v .: "endPoint")
00:51:53 <__dingbat__>     parseJSON _ = error "Can't parse Peer"
00:52:04 <__dingbat__> gave the same error - HelloWorldApp: AesonException "Error in $.trustedPeers[0]: key \"getPeer\" not present"
00:52:26 <syd> and you're sure that you recompiled?
00:52:34 <syd> hold on, why is it looking for `getPeer` :hmm:
00:52:45 <__dingbat__> yes, recompiled
00:53:01 <syd> something is going wrong
00:53:08 <[exa]> is there something in the program called 'getPeer' ?
00:53:09 <syd> because `getPeer` is what the generated `FromJSON` would ask for
00:53:18 <syd> but you have your own `FromJSON` instance
00:53:31 <syd> so how does it want to use the `Generic` instance? 
00:55:58 <__dingbat__> If i just use "instance FromJSON Peer " without custom parsing code
00:56:05 <__dingbat__> I still get the same error 
00:56:11 <syd> yeah that's to be expected
00:56:14 <syd> what if you remove it?
00:56:40 <syd> it shouldn't compile
00:56:48 <__dingbat__> remove "instance FromJSON Peer " ? then doesnt compile
00:57:56 <syd> ok good
00:58:02 <syd> is it missing that instance?
00:58:30 <__dingbat__> yes
00:58:36 <syd> good
00:59:32 <syd> can you show the call to `Data.Aeson.decode` and the json instances of the other types
00:59:44 <syd> I suspect you used `decodeGeneric` or something
00:59:48 <syd> and that's wrong in this case
01:01:16 <__dingbat__> readConfig :: FilePath -> IO Config
01:01:18 <__dingbat__> readConfig path = do
01:01:19 <__dingbat__>     config <- decodeFileEither path :: IO (Either ParseException Config)
01:01:21 <__dingbat__>     case config of
01:01:22 <__dingbat__>         Left e    -> throw e
01:01:24 <__dingbat__>         Right con -> return con
01:01:26 <__dingbat__> did you mean this part?
01:02:04 <dminuoso> Naming things is so hard. I have two functions, one that wraps thrown IOException in MyIOException, and one that wraps IOException in OtherIOException and MyIOException back to IOException.
01:02:09 <dminuoso> What would you name them? :>
01:03:00 <syd> you shouldn't have to use them :)
01:03:12 <syd> but you can use german naming convention
01:03:21 <syd> and just make a really long name
01:03:24 <dminuoso> syd: Well yeah, some libraries just *like* to throw IOExceptions
01:03:26 <dminuoso> Heh.
01:04:24 <dminuoso> And once you are in a spot where you have some `withRes :: MonadUnliftIO m => (Res -> m a) -> m a` you can't separate the IOExceptions between withRes and your continuation.
01:05:21 <merijn> Every library should wrap all it's exception into a library specific superclass so you can catch all of them in one go
01:06:26 <__dingbat__> syd: can you see my question plz?
01:06:28 <dminuoso> merijn: I suppose I could write a wrapper function for withRes too..
01:07:31 <merijn> dminuoso: Is withRes based on ResourceT?
01:08:49 <merijn> dminuoso: Because with ResourceT you can (with a bit of manual wrapping) detect early vs normal vs exceptional termination and distinguish between them
01:11:04 <syd> __dingbat__ about to go into a meeting
01:11:05 <syd> hold on
01:11:12 <syd> yeah that's the call I meant
01:11:22 <syd> where is your instance of `FromJSON Config`?
01:12:14 <__dingbat__> syd: its just - instance FromJSON Config
01:12:47 <syd> so that uses the generic instance
01:12:58 <syd> but that doesn't explain why `Peer` uses the generic instance
01:13:24 <syd> I don't understand what's happening, but you _could_ try to evade the problem by turning Peer into a record type instead of a newytpe
01:14:11 <__dingbat__> ok.. that would affect other parts of my code i guess
01:15:02 <syd> probably
01:15:11 <syd> I mean, you probably want to do that anyway
01:15:16 <__dingbat__> thanks will try it out
01:15:23 <syd> but I don't see another way to debug your problem without screensharing
01:24:25 <syd> __dingbat__ let me know how that goes
01:30:52 <__dingbat__> syd: thanks for your help, will let u know, will take a bit longer though
01:31:16 <syd> take your time
01:31:22 <syd> you can also email me if you have any more questions
01:32:34 <sim590> Here: https://paste.debian.net/1105006/ in twoDiffRcells, I do `areNotNeighbors <- join $ lift $ liftM2 areNeighbors cell cell'` and it works, but I'm not sure why. It feels not right to use join and lift ...
01:33:39 <koz_> sim590: What is twoDiffRcells meant to do?
01:33:52 <koz_> (aka 'why does your stack keep growing for questionable reasons')
01:35:55 <sim590> koz_: It keeps growing so I can take advantage of effects of the monads, no? :D For instance, in areNeighbors, I want to take advantage of `guard`, so I use MaybeT. It's possible that I cannot say that both cells are not neighbors if one of the cells is not in the required bounding box, so I communicate this with `Nothing`.
01:36:33 <koz_> I'm not sure I understand what twoDiffRcells is meant to do, though.
01:37:06 <sim590> twoDiffRCells is supposed to give two different random cells on the grid (configured with LConf) that are neighbors.
01:37:25 <koz_> So then why the maybeT?
01:37:31 <trcc> Hi. I have a Scotty backend that returns a file, and after it has returned the file, I am interested in the folder it resides in is deleted. I am thinking of using: http://hackage.haskell.org/package/temporary-1.3/docs/System-IO-Temp.html#v:withTempDirectory but I am afraid that it will delete the folder before my files has been sent to the user. Any input on this / other ideas?
01:37:45 <koz_> If you give two random cells which are neighbours, why is there a chance that this would fail?
01:37:49 <sim590> koz_: It's possible that areNeighbors cannot answer the question if the cells are ill-made.
01:38:02 <koz_> sim590: What do you mean by 'ill-made'?
01:38:37 <sim590> koz_: Indeed, you are right. If both cells are made with randomCell, then they should be fine.
01:38:51 <sim590> But areNeighbors is not garanteed that.
01:39:17 <koz_> sim590: I still don't quite understand what you're getting at.
01:39:22 <sim590> areNeighbors could be asked about two cells that were made in a bad manner. For instance, I could manually pass this function bad cells.
01:39:38 <koz_> Why would you expose an API that permits this?
01:39:40 <sim590> (out of the bounding box).
01:40:06 <koz_> Or, perhaps, what is the advantage of such an API?
01:40:21 <koz_> Plus, twoDiffRcells takes no arguments.
01:40:33 <koz_> It's not 'passed' any Cells in any case.
01:40:44 <sim590> well, it's just that areNeighbors is a general function that can be used outside of the module. It's safe inside, but if used outside, I want to provide a mechanism for sayin that there's something wrong.
01:41:20 <sim590> koz_: I meant to talk about areNeighbors which I could pass two bad cells.
01:41:46 <koz_> Ah, OK, that makes sense now.
01:42:40 <koz_> I still claim areNeighbours shouldn't use MaybeT - the type, to me, should be 'Cell -> Cell -> ReaderT LConf (State StdGen) (Maybe Bool)'.
01:43:03 <koz_> The idea is that you can return one of three results - with your current stack, failure destroys the StdGen.
01:43:14 <koz_> (and the LConf too, but hey, who's counting)
01:43:16 <sim590> koz_: I had that before, but I needed then to do case's of Just and Nothing and I didn't like that.
01:43:56 <dminuoso> sim590: Do you have this `ReaderT LConf (State StdGen)` in multiple places?
01:44:18 <sim590> dminuoso: Yes. Everywhere.
01:44:37 <sim590> The whole code: https://paste.debian.net/1105008/ (100 lines).
01:46:10 <koz_> Also, if you don't like case splitting, you _can_ use 'maybe'.
01:46:12 <koz_> :t maybe
01:46:13 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:47:44 <sim590> Good to know. Thanks! But, I'm really puzzeled as to why `areNotNeighbors <- join $ lift $ liftM2 areNeighbors cell cell'` works.
01:48:57 <sim590> And why I could not simply do `areNotNeighbors <- liftM2 areNeighbors cell cell'`. I'm a bit lost in the types. I must say and yes it is consistent with your remark about the growing stack, but still I'm experiencing.
01:49:09 <dminuoso> sim590: Lets pretend for a second you newtyped that `ReaderT LConf (State StdGen)`
01:49:24 <dminuoso> Say `newtype App a = ReaderT LConf (State StdGen) a`
01:49:49 <dminuoso> `areNeighbours :: Cell -> Cell -> MaybeT App Bool`
01:49:50 <sim590> Yes. Yes. That's a good Idea.
01:50:14 <koz_> Because 'let cell = randomCell' gives you a Sim590Stack Cell, which you have to resort to because the stack randomCell uses is 'shallower' than the one you're currently in.
01:50:47 <dminuoso> sim590: I think you are overusing lift. You can probably get rid of *all* of them.
01:51:17 <sim590> dminuoso: that would be nice.
01:51:55 <dminuoso> `areTheSame <- lift $ liftM2 (==) cell cell'` <- that lift is not necessary
01:52:10 <koz_> This is why I question the MaybeT - it's not like 'my whole computation can break at any point'; it's 'I have a function which potentially returns a result saying 'nope''.
01:52:10 <dminuoso> sim590: In fact, the entire liftM2 is silly
01:52:17 <sim590> koz_: :D
01:52:26 <sim590> :D
01:53:18 <sim590> dminuoso: in `areTheSame` definition?
01:53:58 <dminuoso> sim590: What I would do is: do `{ c1 <- randomCell; c2 <- randomCell; areNotNeighbours <- areNeighbours c1 c2; ... }`
01:54:21 <sim590> Oh. So the issue is that I'm using let
01:54:27 <dminuoso> sim590: Also, this might even be more important, the way you use `cell` and `cell'` it smells like you are re-generating random numbers.
01:54:38 <dminuoso> Since you are re-running the randomCell effect
01:55:25 <dminuoso> sim590: So `areTheSame <- lift $ liftM2 (==) cell cell'` creates two random cells and tests if they are the same, and then the next line generates *new* numbers and tells if they are neighbours.
01:55:36 <dminuoso> sim590: And then to top it all off, you generate *fresh* random cells as the answer.
01:56:07 <dminuoso> There's quite a bit of wrongness buried there.
01:56:54 <sim590> Oh. I thought they were fixed, but they are rerun.
01:57:03 <sim590> So I have to pay attention to let inside a monad.
01:57:29 <sim590> But I do have to use `cell  <- lift randomCell` otherwise it doesn't type check.
01:57:46 <koz_> sim590: ReaderT LConf (State StdGen) a is basically LConf -> StdGen -> (a, StdGen)
01:58:24 <koz_> And yes, because your stack is 'deeper' at the moment due to that extra MaybeT layer, whereas randomCell's stack lacks it.
01:58:44 <dminuoso> sim590: In fact, I would probably move the random cell generation out of that..
01:58:44 <koz_> So you have to specify 'hey function, I don't really care about the MaybeT layer, just lift me over it bro'.
01:59:05 <sim590> It's now nicer https://paste.debian.net/1105010/
01:59:56 <sim590> dminuoso: out of what?
02:00:13 <dminuoso> sim590: Make it a simple function:
02:00:20 <dminuoso> `suitable :: Cell -> Cell -> Bool`
02:00:57 <sim590> but it needs to know about the context of LConf.
02:01:20 <sim590> It needs to call isInBound.
02:05:36 <sim590> I tried `newtype LConf a = ReaderT LDim (State StdGen) a` to make everything simpler, but I got `Expecting one more argument to â€˜State StdGenâ€™`.
02:05:50 <sim590> And LConf became LDim.
02:06:48 <merijn> sim590: Eh, you're defining a new constructor ReaderT there that takes 3 arguments (LDim, State StdGen, and 'a')
02:07:06 <merijn> sim590: You probably want to add an LConf constructor and some parentheses :)
02:08:06 <sim590> Ah. yeah. OK. Good idea.
02:09:08 <syd> sim590 I'd suggest you just add an extra argument for the bounds checking
02:09:16 <syd> using a ReaderT for that may be overly complex
02:09:27 <syd> it also makes testing easier :)
02:10:28 <sim590> dminuoso: I fi make a newtype, I do have to redefine all of the class instances, right?
02:11:15 <syd> sim590 yes, but you can derive them with GeneralizedNewtypeDeriving
02:11:47 <sim590> syd: oh cool.
02:12:05 <syd> let's see if I can find an example for you
02:12:32 <sim590> syd: about using extra args, I didn't like "poluting" the signatures with extra "wdith" et "height" arguments (Integer -> Integer).
02:12:54 <syd> sim590, the same pollution happens using a ReaderT
02:13:12 <syd> You can always have two seperate functions. One that uses extra arguments and one that takes them out of the readerT and puts them into the first
02:14:58 <syd> fact is that your function needs those arguments somehow
02:16:05 <syd> https://github.com/NorfairKing/mergeful/blob/94debf1d576aaeaa3f99faab4062941ad3a94447/genvalidity-mergeful/test/Data/Mergeful/CollectionSpec.hs#L581-L585
02:16:17 <syd> this is an example of the `newtype` + `GeneralizedNewtypeDeriving` trick
02:16:56 <syd> also uses a `StdGen`, coincidentally :)
02:25:18 <sim590> I think that I did it correctly with `deriving (Functor, Applicative, Monad, MonadReader LDim, MonadState StdGen)`. But now I get Couldn't match expected type â€˜ReaderT LDim (StateT StdGen Data.Functor.Identity.Identity) a0â€™ with actual type â€˜LConf Labyrinthâ€™. hmmm
02:26:08 <merijn> sim590: newtype creates a *new* type. You can't use them interchangeably with "ReaderT LDim (State StdGen) a" because they are not the same type
02:26:09 <sim590> My newtype is: newtype LConf a = LConf (ReaderT LDim (State StdGen) a)
02:26:18 <sim590> merijn: Oh
02:26:28 <merijn> You need to wrap them with an LConf constructor
02:26:30 <sim590> Then. I need to make a function that changes the type?
02:26:44 <merijn> sim590: You already have that function, "LConf" :p
02:26:50 <sim590> Oh :p
02:28:22 <stobix> Hi. I would want to do something like defining a function `foo = 2 + fromEnum maxBound` for any Bounded Enum. Is this possible or is my thinking broken?
02:29:33 <merijn> stobix: The problem is that there's no way to infer which enum you're expecting to use there :)
02:29:51 <merijn> stobix: Easiest solution is probably to add a dummy argument or Proxy
02:32:28 <boxscape> % let f :: forall e . (Enum e, Bounded e) => Int; f = 2 + fromEnum (maxBound :: e) in f @Bool
02:32:28 <yahb> boxscape: 3
02:32:35 <boxscape> works if you have a few extensions turned on
02:33:07 <ski> % let f :: forall e. (Enum e,Bounded e) => Int; f = 2 + fromEnum (maxBound @e) in f @()
02:33:07 <stobix> merijn: hm. This was my first attempt, but ghci still can't "deduce (Bounded a0) from the context (Enum a, Bounded a)": `foo :: (Bounded a, Enum a) => a -> Int; foo _ = 2 + fromEnum maxBound`
02:33:07 <yahb> ski: 2
02:33:14 <boxscape> (most importantly ScopedTypeVariables)
02:33:40 <merijn> stobix: You probably want "foo x = 2 + fromEnum (maxBound `asTypeOf` x)"
02:33:51 <stobix> oooh
02:33:51 <merijn> :t asTypeOf
02:33:52 <lambdabot> a -> a -> a
02:33:59 <merijn> > maxBound `asTypeOf` True
02:34:00 <sim590> merijn: I'm not sure what I'm doing wrong. Is it not what you meant `runReaderT (LConf makeLabyrinth) (LDim 3 3)` ?
02:34:00 <ski> @src asTypeOf
02:34:00 <lambdabot> asTypeOf = const
02:34:01 <lambdabot>  True
02:34:41 <stobix> that is one meta function thing that sounds really usefu... and of course it is just the same as const. Because Haskell is friggin magic.
02:34:46 <merijn> stobix: In the initial version GHC has no way of knowing you wanted maxBound and the argument to be the same thing :)
02:35:10 <merijn> stobix: Well, it's not the same as const, because of the type signature, but yeah :p
02:35:52 <ski> is the same as a specialization of `const' :)
02:36:18 <stobix> hmm, so what does forall do, boxscape ?
02:36:24 <merijn> stobix: Same thing powering the lambdabot voodoo that is:
02:36:30 <Ariakenom> ski: it is a specialization of const :)
02:36:54 <merijn> :t (+) `asAppliedTo` (undefined :: Int)
02:36:55 <lambdabot> Int -> Int -> Int
02:37:17 <ski> stobix : universally quantifies type variables, to express the type of a polymorphic operation
02:37:24 <boxscape> stobix if you type a type signature like `id :: a -> a`, ghc will implicitly convert it into `id :: forall a . a -> a`, which basically means a isn't any particular type, this functions works for all possibletypes
02:37:37 <ski> stobix : in this case, it also makes the type variable available in the definition
02:37:39 <merijn> stobix: Honestly, I would advice against boxscape's solution as it needlessly requires a bunch of extensions >.>
02:38:11 <merijn> In fact, I would in general advice against using TypeApplications *at all* except for playing around in ghci
02:38:58 <quasker32> Does anyone know of a *static* FRP framework for Haskell? E.g. I'm looking for one where we can statically analyze the event network.
02:39:07 <stobix> boxscape: ah, good to know
02:39:30 <ski> merijn : i have mixed feelings about it, too ..
02:39:50 <stobix> I guess there is no therexistsatleastone? ;)
02:39:56 <Ariakenom> stobix: You might be interested in this function that I showed before. If you're playing around with Bounded.
02:40:00 <Ariakenom> (500 :: Double) `asBoundedBy` (undefined :: Word8) = (255 :: Double)
02:40:07 <boxscape> stobix no, but you can convert existentials into foralls
02:40:11 <merijn> ski: I've seen at least two things break due to use of it
02:40:38 <ski> stobix : there is, conceptually, but there's no keyword (currently) for it, in Haskell
02:40:59 <ski> stobix : however, you can encode it (in two different ways, even), when you need it
02:41:24 <sim590> merijn: OK. I understood. I had to use the constructor in pattern matching. I can't use it directly in a line of code.
02:42:12 <ski> stobix : if you ever want to "store multiple things of different types, sharing the same interface, in a container". then "existential types" might be what you want. however, it can often be overkill, it may well suffice to use a record of operations, or to use a plain algebraic data type with multiple alternatives
02:42:21 <stobix> heh, I actually cannot think of any way I'd use it in a function definition... Maybe âˆƒ!, but not âˆƒ itself.
02:42:48 <merijn> sim590: You can also define LConf as "newtype LConf a = LConf { runLConf :: ReaderT LDim (State StdGen) a }" then you can use runLConf to unwrap :)
02:42:54 <ski> stobix : sometimes, you want to type of a result (or type of part of the result) depend on run-time inputs
02:43:30 <sim590> merijn: oh yesssssssssssssssssss
02:43:47 <ski> stobix : one example could be `typeCheck :: UntypedExpr -> Maybe (exists typ. TypedExpr typ)'
02:44:26 <stobix> ski: Oh, so iff the type exists at runtime, we won't get a Nothing?
02:45:04 <merijn> sim590: That's the main reason people tend to define newtypes with record syntax like that so you get an easy "unwrap" function
02:45:51 <ski> stobix : something like that, yea
02:48:44 <ski> stobix : things like `[exists a. Widget a *> Map ID a]' could also happen. a list of finite maps, each one mapping identifiers to values of some type `a' (of which nothing is known, except that it is known to be an instance of `Widget'). all the values in a map have the same type, but different maps in the list can (and must be assume to) have different value types
02:50:41 <stobix> ski: huh, interesting
02:50:54 <stobix> Well, anyways, off to work now. Thanks for the help yall.
02:50:59 <ski> (`*>' is related to, but not the same as `=>')
02:51:05 <ski> have fun
02:54:12 <boxscape> ski what is =>?
02:55:20 <boxscape> oh like in Show a => or something like that?
02:56:27 <boxscape> (I was thinking of operators after the comparison with *>)
02:58:59 <ski> yes
02:59:23 <boxscape> ok
03:09:09 <trcc> If someone is bored :) https://www.reddit.com/r/haskell/comments/deh8v4/scotty_delete_folder_after_http_request_return/
03:37:30 * hackage ghc-heap-view 0.6.1 - Extract the heap representation of Haskell values and thunks  https://hackage.haskell.org/package/ghc-heap-view-0.6.1 (JoachimBreitner)
03:52:07 <boxscape> % data Test = Test Type
03:52:07 <yahb> boxscape: 
03:52:43 <boxscape> would Test Int be a valid value of this type, if only we could reference the typelevel namespace on a term level?
03:52:58 <boxscape> % Test Int
03:52:58 <yahb> boxscape: ; <interactive>:76:6: error:; * Data constructor not in scope: Int :: *; * Perhaps you meant variable `int' (imported from Text.PrettyPrint.HughesPJ)
03:53:16 <ski> % :type Test
03:53:16 <yahb> ski: * -> Test
03:53:38 <ski> % :kind Test
03:53:38 <yahb> ski: Test :: *
03:53:42 <ski> % :kind 'Test
03:53:42 <yahb> ski: 'Test :: * -> Test
03:54:09 <ski> % :kind 'Test Int
03:54:09 <yahb> ski: 'Test Int :: Test
03:54:27 <boxscape> hm, that suggests yes, doesn't it?
03:54:30 <EvanR> isn't type level namespace on a term level = TypeRep
03:54:41 <ski> `Int' is not a vale
03:54:47 <ski> s/vale/value/
03:54:49 <EvanR> 'Test Int is a type not a value
03:54:57 <EvanR> DataKinds
03:55:32 <boxscape> this distinction gets confusing with the unification of types and kinds, I find
03:56:48 <EvanR> type-in-type is supposed to simplify something....
03:56:55 <EvanR> not sure exactly what
03:57:36 <EvanR> :t typeOf 'c'
03:57:37 <lambdabot> TypeRep
03:57:48 <EvanR> > typeOf 'c'
03:57:50 <lambdabot>  Char
03:58:40 <EvanR> > typeOf id
03:58:42 <lambdabot>  error:
03:58:42 <lambdabot>      â€¢ No instance for (Typeable a0) arising from a use of â€˜typeOfâ€™
03:58:42 <lambdabot>      â€¢ In the expression: typeOf id
03:59:01 <ski> > typeOf (id `asTypeOf` not)
03:59:03 <lambdabot>  Bool -> Bool
04:00:49 <EvanR> so TypeReps exist at runtime but are limited
04:03:16 <boxscape> % data Test2 :: Type -> Type where Testing2 :: forall a . Test2 a
04:03:16 <yahb> boxscape: 
04:03:22 <boxscape> % Proxy @(Testing2 @Int)
04:03:22 <yahb> boxscape: ; <interactive>:95:18: error: parse error on input `@'
04:03:37 <boxscape> oh
04:03:39 <ski> i think in Clean, you can match on `Dynamic's
04:03:43 <boxscape> do I need visible kind application for this?
04:04:03 <ski>   dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
04:04:26 <ski>   dynApply (Dyn (f :: a -> b)) (Dyn (x :: a)) = Dyn (f x)
04:04:46 <ski>   dynApply  _                   _             = Nothing
04:05:01 <ski> something like that (oops, missed the `Just' in the first defining equation)
04:05:02 <boxscape> neat
04:05:51 <ski> @type dynApply
04:05:52 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
04:06:30 <EvanR> Dynamic is like Haskell having a dream of being PHP or something
04:06:39 <boxscape> (btw I checked, it works with 8.8.1, so yes, I do need visible kind application)
04:06:40 <EvanR> nightmare?
04:06:42 <merijn> EvanR: Pretty much
04:07:06 <merijn> EvanR: That's why people who say they "need" dynamic languages is BS, you can write imperative and dynamic code just fine in Haskell :)
04:08:23 <tdammers> Dynamic isn't like PHP though
04:08:34 <merijn> tdammers: It's better behaved you mean? :p
04:08:37 <tdammers> much
04:08:55 <tdammers> but also more limited, in that it doesn't provide "tag polymorphism"
04:09:10 <merijn> tdammers: You could build that on top of it
04:09:21 <ski> (waht do you mean by "tag polymorphism" ?)
04:09:55 <tdammers> by "tag polymorphism", I mean this thing where you operate on some value, and depending on its tag ("runtime type"), one thing or another happens
04:10:40 <EvanR> TypeRep does have ==
04:10:52 <tdammers> so say you want to add two numbers
04:11:13 <tdammers> but if you stuff them into Dynamics, then you have to decide on some numeric type - Int, Integer, Double, whatever
04:11:49 <tdammers> you can't just take two Dynamics and say "apply the (+) operator from Num to these, using whichever instance is available"
04:11:58 <boxscape> % data Test2 :: forall k (b :: k) . b -> Type -- Why can't I do this :/
04:11:58 <yahb> boxscape: ; <interactive>:97:35: error:; * Expected a type, but `b' has kind `k'; * In the kind `forall k (b :: k). b -> Type'
04:12:08 <tdammers> not in a straightforward way anyway
04:12:18 <EvanR> ok so there is no Dynamic version of Num
04:12:30 * hackage mollie-api-haskell 2.0.0.0 - Mollie API client for Haskell http://www.mollie.com  https://hackage.haskell.org/package/mollie-api-haskell-2.0.0.0 (tolgapaksoy)
04:12:54 <ski> boxscape : `->' wants something of kind `*' as left operand
04:13:07 <boxscape> :k (->)
04:13:08 <lambdabot> * -> * -> *
04:13:11 <boxscape> okay
04:13:20 <tdammers> "Dynamic version of Num"? What would that even look like?
04:13:47 <EvanR> to do what you want, a function that takes TypeRep and outputs a Num instance
04:14:02 <tdammers> ah, hmm
04:14:19 <EvanR> or Nothing
04:14:29 <tdammers> right, that could actually work, sort of
04:14:55 * EvanR wonders if that exists somehow
04:17:46 <boxscape> so something like TypeRep -> Maybe (Dict (Num a))? But I'm not sure how to quantify a
04:18:13 <EvanR> existential
04:19:11 <EvanR> dynAdd :: DynConstraint => Dynamic -> Dynamic -> Dynamic -- hehehe
04:19:33 <ski>   forall a. TypeRep a -> Maybe (Dict (Num a))
04:19:57 <ski>   (exists a. TypeRep a) -> Maybe (exists a. Dict (Num a))
04:22:59 <EvanR> that looks so weird
04:27:36 <nshepperd1> Typeable a => Maybe (Dict (Num a))
04:28:12 <nshepperd1> You'd have to implement it by explicitly enumerating a list of types to check against
04:33:06 <ski> throw in some `IO'
04:33:24 <boxscape> and get the Num instance via ftp
04:34:13 <ski> sounds like a plan
04:34:44 <EvanR> dynAdd :: DynInstance "ftp://..." => Dynamic -> Dynamic -> Dynamic
04:34:46 <nshepperd1> Hah
04:38:03 <EvanR> url in the type
04:38:17 <EvanR> w variety of protocols supported
04:38:43 <hpc> still too limiting
04:38:47 <EvanR> though would be kind of useless if you couldn't string interpolate
04:38:54 <hpc> DynInstance "curl blah.com | sudo sh" is where it's at
04:39:20 <EvanR> it's too early for this
04:39:20 <nshepperd1> Lookup the url from the name of the type, compile the result, load with ghc plugins api...
04:40:13 <EvanR> i can't believe this doesn't already exist what was haskell committee thinking
04:40:33 <merijn> You guys should submit a pull request to acme-php
04:42:16 <boxscape> data Bool = TRUE | FALSE | FILE_NOT_FOUND
04:42:17 <boxscape> heh
04:42:39 <boxscape> (from acme-php)
04:43:46 <merijn> boxscape: You should really read the source if you're looking at the haddocks. The Num instances are a thing of wonder
04:44:04 <boxscape> yeah I'm doing that
04:45:10 <tdammers> you can always use Template Haskell for that
04:45:14 <EvanR> is T_PAAMAYIM_NEKUDOTAYIM in there?
04:45:51 <boxscape> no, but you'll find plenty of double colons
04:49:40 <EvanR> i want to know what a acme-haskell in npm would look like
04:50:05 <EvanR> lazy I/O maybe
04:52:40 <jgt> perhaps acme-haskell in npm is indistinguishable from npm as it is
04:52:55 <jgt> maybe just more things depending on the is-thirteen package
04:53:50 <EvanR> ok npm was a bad example, perl's package repo
04:54:53 <jgt> indistinguishable from a regex snippet repository
05:01:30 <Ariakenom> in dhall your type can be a URL. Or include a URL (afaik)
05:01:44 <merijn> Ariakenom: You can import from URLs, that much I know
05:02:52 <Ariakenom> and an import is just a value
05:03:22 <Ariakenom> (or type because dependent types)
05:04:01 <Ariakenom> like nix. but nix doesnt type much
05:07:53 <Ariakenom> ... wasn't there yaml as a dhall-type somewhere ...
05:10:20 <Ariakenom> ah. "The Cabal file format encoded as a Dhall type " https://gist.github.com/Gabriel439/81855ec23c679e23e556a3cdad7757cd
05:14:02 <merijn> Speaking of horrible Dynamic hacks...
05:14:27 <merijn> Is it possible to, given a Typeable constraint, determine whether that type is an instance of a class?
05:15:50 <Ariakenom> you can just use that url as the type afaik
05:17:18 <Ariakenom> (well the plaintext version, "raw", of the link)
05:18:14 <Ariakenom> merijn: I don't think so, no.
05:18:24 <Ariakenom> You can have a class dictionary as a value with it I'd suppose.
05:18:54 <merijn> I'd want to magic the dictionary (if it exists) without affecting the external constraint
05:20:07 <Ariakenom> maybe you can include a list of dictionaries and search through it.
05:20:42 <merijn> Ariakenom: huh?
05:21:30 * hackage haskoin-store 0.18.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.0 (xenog)
05:22:43 <Ariakenom> merijn: Something with Dict https://hackage.haskell.org/package/constraints-0.11.2/docs/Data-Constraint.html#t:Dict
05:36:04 <cheater> how does one add dependencies to a stack project? i tried following this guide, but there isn't actually a package.yaml anywhere. https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
05:39:10 <dminuoso> cheater: Just add it to your cabal file?
05:39:30 * hackage haskoin-store 0.18.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.1 (xenog)
05:39:48 <dminuoso> cheater: The package.yaml is not really necessary. Some stack users like to use hpack which, taking some package.yaml, generates your cabal file for you. It's rather inconsequential and you can use stack without hpack just fine.
05:39:53 <dminuoso> And some stack users even prefer to avoid hpack.
05:48:34 <cheater> stack new haskell-simple-utxo-api simple --resolver lts-13.11 - i'm not sure if that uses hpack?
05:48:56 <cheater> i'll add to the cabal file then, thanks.
05:49:16 <cheater> i wasn't sure which file was the "original": cabal, package.yaml, or stack.yaml.
05:56:36 <dminuoso> cheater: package.yaml is a file hpack uses to synthesize a cabal file from.
05:56:45 <dminuoso> cheater: stack.yaml is the stack-specific magic bits
05:57:13 <dminuoso> You can use hpack with package.yaml without stack, or stack without hpack/package.yaml - if that makes sense
06:02:00 * hackage multipart 0.2.0 - Parsers for the HTTP multipart format  https://hackage.haskell.org/package/multipart-0.2.0 (ErikHesselink)
06:33:00 * hackage vec 0.2 - Vec: length-indexed (sized) list  https://hackage.haskell.org/package/vec-0.2 (phadej)
06:34:28 <dmwit> Seems like it might be nice to have a Foldable-generic unlines/unwords.
06:35:01 <Taneb> un{lines,words} :: Foldable f => f String -> String?
06:35:06 <dmwit> yep
06:35:18 <Taneb> Yeah, I'd agree with that
06:36:03 <Rembane> +1
06:36:24 <boxscape> Is the "Monads are Monoids in the category of endofunctors" thing actually encoded somewhere in base? I tried doing `instance Monad m => Monoid (a -> a m)`, and it works, but only with OVERLAPS.
06:36:29 <ski> a traversal ?
06:36:44 <merijn> boxscape: You can't encode it's meaning in Haskell
06:36:48 <boxscape> I see
06:36:58 <merijn> Or maybe you can with lots of abuse
06:37:09 <ski> `Monad m => Monoid (a -> a m)' has nothing to do with that quote
06:37:16 <boxscape> heh, alright
06:37:35 * hyperisco 's eye twitches
06:38:02 <merijn> :t join
06:38:03 <lambdabot> Monad m => m (m a) -> m a
06:38:51 <merijn> boxscape: 'm' is the endofunctor, and the mappend operation is just turn two (nested) 'm' into one (i.e. join)
06:39:05 <boxscape> okay
06:39:26 <merijn> And even then it only works as explanation if you handwave a bunch of math
06:39:42 <merijn> (like I just did :p)
06:39:42 <phadej> you don't need to handwave anything, it works.
06:40:14 <merijn> phadej: Well, you need to assume a type level mappend which we don't really have at the moment
06:40:19 <tabaqui1> No new extensions in ghc-8.8, what a shame
06:40:55 <phadej> merijn: well, you shouldn't try to understand that expression through Haskell anyway. IMHO Haskell is only in the way there.
06:41:04 <phadej> TL;DR really not that important
06:41:06 <merijn> phadej: Well yes, that was my point :)
06:41:07 <boxscape> ah so I think I got a bit confused by this when I first heard about it - does that mean a monad is a monoid object but not a traditional monoid (i.e. monoid object in Set)?
06:41:39 <phadej> yes
06:41:42 <boxscape> okay
06:41:45 <Taneb> boxscape: yes. It's a monoid object in the catetory of endofunctors equipped with the tensor product of compositio
06:41:46 <Taneb> n
06:42:00 <boxscape> I see
06:42:09 <tabaqui1> consider (<>) as (>=>) and zero as (>>= return)
06:42:28 <tabaqui1> not exactly
06:42:53 <boxscape> tabaqui1 at least 8.10 has StandaloneKindSignatures which you can already use in HEAD
06:43:30 * hackage ron 0.10 - RON  https://hackage.haskell.org/package/ron-0.10 (cblp)
06:44:36 <tabaqui1> boxscape: it seems usefull
06:44:51 <tabaqui1> identation in long type declarations always confuses me
06:45:30 <boxscape> I used it yesterday when, for the first time, I came across a situation where CUSKs made things really confusing, and SAKs are the replacement for CUSKs
06:45:52 <boxscape> (SAKs being standalonekindsignatures)
06:49:18 <phadej> SAKSs ?
06:49:51 <boxscape> there was some sentiment against that in the github proposal discussion due to potential for plural confusion
06:49:52 <phadej> (cusk is iirc completely user specified kinds, which is a huge hack as the name sounds already)
06:53:27 <boxscape> the worst part is that ghc doesn't tell you when a missing CUSK is the problem, from my experience
06:55:23 <phadej> imho the problem is that if you "just write out all the kinds", things behave differently from them something was implicit. I.e. one **have** to rely on inference
06:56:09 <phadej> kind of the same problem ScopedTypeVariables solved, there were type-signatures you couldn't write
06:57:15 <boxscape> hm, interesting, I haven't come across that situation
07:00:23 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables
07:14:30 * hackage describe 0.2.0.5 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.5 (riuga)
07:15:55 <dminuoso> 15:36:22         merijn | boxscape: You can't encode it's meaning in Haskell
07:15:57 <dminuoso> Sure you can.
07:16:52 <dminuoso> merijn, boxscape: https://gist.github.com/dminuoso/014736584d893ddff39cca9955089b7c
07:17:48 <dminuoso> class Functor f => EFMonoid t i f where join :: f `t` f ~> f; unit :: i ~> f
07:17:54 <fendor> looks lovely
07:17:57 <dminuoso> (You can add fundeps if you like)
07:18:47 <dminuoso> You can also go more general and encode it ontop of Category
07:19:52 <merijn> dminuoso: Well, a little later I said you could if you abused enough extensions :p
07:19:56 <merijn> dminuoso: Arguably that code isn't Haskell :p
07:19:59 <ski> 12whee !
07:20:00 * hackage debian-build 0.10.2.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.10.2.0 (KeiHibino)
07:24:01 <dminuoso> merijn: You dont need much abuse. You can get away with MPTC and fundeps. :)
07:25:05 <dminuoso> And you can probably get rid of those too if you use newtypes.
07:30:05 <dminuoso> Or just Monad is that encoding, really.
07:30:13 <dminuoso> % :t pure
07:30:13 <yahb> dminuoso: Applicative f => a -> f a
07:30:30 <dminuoso> Could be understood as `pure :: Applicative f => Identity ~> f`
07:31:11 <dminuoso> And if we pretend that Monad had join as a minimal class method we could equivalently state: join :: Monad m => m `Compose m ~> m
07:31:31 <dminuoso> Err, join :: Monad m => m `Compose` m ~> m
07:39:26 <hello34> quit
07:40:55 <cheater> dminuoso: thanks!
07:47:57 <hoppfull> Is there a way to verify that a configuration file is valid at compile time?
07:48:20 <hoppfull> In rust for example we can run rust code at compile time. In F# we have type providers.
07:48:28 <ski> read it with TH, i suppose
07:48:39 <hoppfull> Like run some haskell code at compile time
07:48:49 <dminuoso> hoppfull: Yes.
07:48:53 <ski> @where TH
07:48:53 <lambdabot> http://www.haskell.org/th
07:49:05 <dminuoso> hoppfull: Or equivalently, encode your config as code.
07:49:38 <dminuoso> (Especially by using correct-by-construction idioms)
07:49:53 <hoppfull> TH is template haskell? The link gave 404
07:50:00 <dminuoso> hoppfull: Yes.
07:50:31 <ski> hmm
07:50:35 <ski> @wiki Template Haskell
07:50:35 <lambdabot> https://wiki.haskell.org/Template_Haskell
07:50:45 <hoppfull> Thanks
07:51:36 <hoppfull> I may be wrong but a problem right now is that we're encoding a lot of data in code and it causes problems. I want to force my team mates to think abstractly.
07:52:55 <hoppfull> Anyway, thanks
07:52:56 <dminuoso> hoppfull: What kind of problems are you experiencing?
07:53:18 <merijn> hoppfull: Template Haskell can run completely arbitrary code at compile so yeah, validating a file is certainly possible :p
07:53:29 <merijn> hoppfull: Is this like a configuration file or a Haskell source file?
07:55:17 <hoppfull> dminuoso: My boss is thinking in F# and we've got sum types all over the code base modelling "legal states" but it's not giving us the safety he thinks it is and the complexity is actually causing more bugs.
07:55:41 <hoppfull> Fundamentally we're building a small typed DSL and I want to build it from simple principles.
07:56:04 <hoppfull> My team mates are eager to think abstractly but they need to get the shortcuts taken away from them.
07:56:24 <dminuoso> hoppfull: So far, encoding the possible states (like US states?) does not sound fundamentally wrong.
07:56:30 <dminuoso> using ADTs I mean.
07:56:43 <hoppfull> dminuoso: states as in program states.
07:57:02 <dminuoso> hoppfull: In what sense?
07:58:27 <hoppfull> dminuoso: Sorry, I feel bad for bringing this up only to say I can't explain it. My head is spinning because I've been working all day. I feel like I've gotten a very helpful response from you guys. Sorry to leave with this hanging.
08:08:30 * hackage hsdev 0.3.3.5 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.3.5 (AlexandrRuchkin)
08:22:07 <inkbottle> In the process of having HIE working with emacs; at the moment I have "â€˜spinner-1.7.3â€™ is unavailable" when trying to install lsp-mode...
08:26:49 <renatofdds> Hello! How can i wrap a monadic functions with a variable number of args with another function ? Suppose i have (funA :: a -> m b) and (funB :: x -> y -> m z) and i want to compose them with another function (wrap :: ???) such that i can have some computation done before funA or funB, e.g. (wrap f = \k a -> someComputation k >> f a) and (wrap2 f = \k x y -> someComputation k >> f x y). Do i really need to declare wrappers for each
08:26:49 <renatofdds> number of arguments or is there some way i can generalize ?
08:30:22 <sicklork1n> inkbottle: which method are you using to build HIE?
08:30:53 <lyxia> renatofdds: writing the lambda explicitly is one way to generalize
08:30:56 <inkbottle> sicklork1n: That is "done" (meaning not tested); I've used nixos
08:31:04 <sicklork1n> inkbottle: i've recently only succeeded building with stack
08:31:31 <inkbottle> sicklork1n: did you integrate it with emacs?
08:33:04 <renatofdds> lyxia: ty, but how so ?
08:33:11 <sicklork1n> inkbottle: nope.. and never used the nix pkg either.
08:33:13 <lyxia> renatofdds: just how you did here
08:34:19 <renatofdds> lyxia: yes, but that's the question, the i did here was writing the lambdas for each number of args, i wonder if there is any way i can generalize it to any number of args for the inner function
08:34:35 <renatofdds> the way i did here*
08:36:30 * hackage http-conduit 2.3.7.2 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.7.2 (MichaelSnoyman)
08:38:30 <renatofdds> something like a function that would "patch" another function consuming one new prefixed argument  
08:38:53 <lyxia> renatofdds: so you want to just write "wrap funA", "wrap funB"
08:39:02 <renatofdds> if you are familiar with elisp, it would be kinda like defadvice :before
08:39:07 <renatofdds> yes!
08:39:33 <renatofdds> instead of wrap funA , wrap2 funB, etc.
08:39:42 <geekosaur> I suspect the best you do here is something like ap
08:40:41 <geekosaur> except I'm not sure you can make it work here. like there's no general liftAn, but liftA2, liftA3, etc. (no liftA1, that is fmap)
08:41:56 <renatofdds> geekosaur: exactly, i wonder if we could construct some kind of general wrapAn.
08:42:40 <lyxia> there are tricks with type classes to do variadic functions but it's really a lot of complexity for a little convenience.
08:42:46 <geekosaur> ^
08:42:56 <geekosaur> which is why I started by saying 
08:43:03 <geekosaur> "I suspect the best you do hereâ€¦"
08:43:30 <geekosaur> haskell went for a different kind of expressiveness with function application, which interferes with trying to do "apply" a la Lisp
08:44:01 <geekosaur> and the workarounds are cumbersome at best (see PrintfType, or as mentioned earlier ap / <*> as a different approach)
08:45:50 <renatofdds> that is exactly the problem.. i just wondered if there was something i was not seeing 
08:45:53 <lyxia> consider simplifying your design in other ways, such as restricting to unary functions, uncurrying where necessary.
08:52:25 <Ariakenom_> when running nix-shell -p ghc --run "ghci". I'm getting "libz.so: No such file or directory"
08:53:02 <fendor> Ariakenom_, you can add zlib, e.g. `nix-shell -p ghc zlib --run "ghci"`
08:53:27 <ski> (there is a `liftA')
08:54:01 <Ariakenom_> fendor: same error
08:54:12 <renatofdds> the problem with ap in this situation is that i have to apply the wrapped function with applicative arguments, meaning (Applicative f => wrappedCurriedFun <*> (f a) <*> (f b)), if only there was a way to get the wrappedCurriedFun to accept (a b ...). I was thinking something like a new bind' so that i could compose the beforeFun with (`bind'` f) 
08:55:42 <geekosaur> renatofdds, that was actually what I meant. *like* ap, not ap itself
08:56:10 <fendor> Ariakenom_, does nix-shell -p ghc work in general? Can you execute ghci in the new shell? 
08:56:54 <renatofdds> geekosaur: yes, thank you
08:57:29 <renatofdds> geekosaur: im looking into Printftype implementation and it looks really close, thank you very much!
08:58:17 <geekosaur> but I think you run into problems when doing this with bind, because Monad should be able to inspect the result of each one whereas Applicative blindly combines. this is more or less the difference between Applicative and Monad
08:58:44 <geekosaur> (yes, ap is based on Monad, but that's because it predates Applicative and we more or less backformed Applicative from ap)
08:59:33 <geekosaur> likewise having to reinvent fmap as liftM with old Monad, which has since been fixed
09:00:07 <ski> (`liftM' (and `liftA') can still be useful, as default implementations of `fmap')
09:04:30 * hackage seonbi 0.1.1 - SmartyPants for Korean language  https://hackage.haskell.org/package/seonbi-0.1.1 (hongminhee)
09:12:26 <kuribas> I find that when I am writing in other languages, it's not haskell that I miss, but the ability to write composable programs.
09:12:58 <kuribas> For example iterators in java are so not composable
09:18:30 * hackage haskoin-store 0.18.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.2 (xenog)
09:18:46 <EvanR> kuribas: let's start the list of things to be missed... sum types
09:19:07 <EvanR> defining functions with not much syntax
09:19:43 <kuribas> EvanR: well, you can kind-of work around them
09:20:11 <EvanR> yeah in ways that are awkard and people yell at you for
09:21:26 <kuribas> in java you need to create a subclass
09:21:33 <EvanR> next, solving embarassingly recursive problems easily
09:22:02 <EvanR> can you do a checkable case on all the subclasses?
09:23:26 <kuribas> nope
09:23:35 <EvanR> i implemented a sum differently in ruby, instead of subclasses you used an eliminator
09:23:47 <EvanR> pass a lambda for each case
09:24:06 <EvanR> of course it's awkward and people yell at you for it
09:24:35 <kuribas> I got yelled at when coding python for suggesting that avoid exceptions is a good idea
09:24:49 <EvanR> exceptions as control flow
09:25:00 <EvanR> how could you live without it
09:25:16 <kuribas> I mean avoiding exceptions when you can avoid them
09:25:27 <kuribas> like using a simple if statement with a test
09:25:39 <kuribas> of course for non-local jumps exceptions are fine
09:25:55 <kuribas> that's where you have to use them
09:26:17 <heatsink> EvanR: I had someone tell me that using an eliminator is a misuse of the visitor pattern, and I should read the GoF book so I learn how to do it correctly
09:27:26 <monochrom> Reconcile with your coworkers, use a simple if statement with a test to throw an exception.
09:30:04 <EvanR> next thing to miss, the async library
09:30:10 <EvanR> STM
09:30:37 <maerwald> kuribas: why avoid exceptions if they are well designed? ;)
09:30:44 <maerwald> but most languages don't
09:31:36 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
09:32:24 <kuribas> monochrom: I got fired from that job :)
09:32:51 <heatsink> I miss the interoperability of stream and sequence data structures.  The Haskell ecosystem consistently uses strict/lazy bytestrings, text, and lists so that I/O libraries tend to interoperate without much fuss
09:33:12 <maerwald> kuribas: lol wat
09:33:52 <heatsink> Other ecosystems have similar things, but they expect you to write your own glue code to connect parts together
09:34:03 <kuribas> I told them that I thought the way they were solving performance issues was wrong, and they took offense in that.
09:34:27 <maerwald> Well, why would you work for them? 
09:34:35 <kuribas> maerwald: at that time money
09:34:44 <maerwald> Good riddance
09:34:51 <EvanR> the team building events
09:36:10 <monochrom> This is the first time I hear someone says the multitude of Haskell's {non-lazy, lazy}x{list, bytestring, text} helps interoperability rather than hurts.  (Just ask Welkin.)
09:37:44 <EvanR> also bytestring vs unboxed vectors vs storable vectors
09:37:56 <EvanR> that don't talk to each other
09:37:57 <kuribas> monochrom: I find that the comparison with strings in other language is wrong, they also have streams, bytebuffers, etc...
09:38:14 <kuribas> with the need to do conversions etc...
09:38:18 <heatsink> The thing is, you can convert between those things in one or two library calls in Haskell
09:38:54 <monochrom> Yeah I agree, those people are hypocritic and have double standards.
09:39:07 <kuribas> streaming pure things is far the easiest in haskell
09:39:20 <heatsink> In Scala, you have Scala streams, Java generic streams, Java arrays, Scala array wrappers, and several Java byte-stream or text-stream classes that I can't recall now
09:39:30 <voyons_osti> kuribas, i was actually just thinking about that exact thing in python today, preventing exceptions or catching them. the question was `x = input(); if not x.isdigit(): retry();; int(x)` vs `x = input(); try: int(x); except ValueError: retry()`
09:39:34 <monochrom> Well except those who come from tcl.  That one really is consistent with strings throughout.
09:40:14 <EvanR> also elixir, strings and bytearray are combined
09:40:23 <kuribas> voyons_osti: indeed, that's the kind of insanity I was speaking of
09:40:24 <EvanR> in a way that kind of makes sense
09:40:56 <nshepperd1> Tcl is stringly typed
09:41:43 <heatsink> In Go, strings have array-of-byte behavior.  There's a helper library for handling multi-byte characters, and a lot of responsibility for that still belongs to the user.
09:42:10 <monochrom> I could chalk up "f not x.isdigit(): retry();; int(x)" as boolean blindness.
09:42:20 <EvanR> that's much better than a lof languages
09:42:27 <EvanR> lot of
09:42:46 <EvanR> where they went gonzo trying to adapt the bytearray with encoding support
09:42:56 <EvanR> and doing it wrong
09:43:03 <heatsink> hmm, that does sound like a bad idea
09:43:14 <monochrom> The use of exceptions in other languages is really ADTs in disfigured form.
09:45:20 <voyons_osti> monochrom, boolean blindness? 
09:45:57 <monochrom> "if isNothing m then ... else ... fromJust m ..."
09:46:59 <monochrom> err let me rephrase.
09:47:14 <monochrom> "if isNothing m then retry else let x = fromJust m in ..."
09:47:29 <monochrom> -> "maybe m retry (\x -> ...)"
09:48:02 <maerwald> monochrom: careful with bashing other languages exception system, when you're sitting in #haskell :P
09:48:37 <monochrom> -> "try x <- m; except: retry; ..."
09:48:45 <monochrom> No I'm defending them!
09:48:53 <voyons_osti> monochrom, what type should `str.isdigit()` return? 
09:49:12 <voyons_osti> i'm familiar with the concept of boolean blindness, but i don't understand what you're saying 
09:49:21 <monochrom> It should return bool.  But my point is you shouldn't need it.
09:50:04 <monochrom> My point is you don't need a pair of functions, "would it parse?" and "parse".
09:50:53 <monochrom> Addendum. My point is you don't need a pair of functions, "would it parse? :: String -> Bool" and "parse :: String -> T".
09:51:09 <monochrom> You need one function "parse :: String -> Either E T"
09:51:16 <voyons_osti> ah, you would prefer a function of type String -> maybe t 
09:51:28 <voyons_osti> or that, sure
09:51:59 <monochrom> Other languages converted Either to exception because they don't do ADTs.
09:52:45 <maerwald> well, all that breaks down in haskell when you have IO :)
09:52:51 <voyons_osti> that's essentially what the `int()` call does
09:53:05 <voyons_osti> either returning an int or raising ValueError
09:53:18 <maerwald> you don't even know what exceptions can occur... so
09:53:54 <EvanR> you're supposed to catch the specific parse exception and continue. But if you do it wrong you catch all exceptions and then I yell at you
09:54:20 <EvanR> because i can't figure out wtf is going on
09:54:52 <voyons_osti> that's true, functions don't give you any information about whether and which exceptions can be raised 
09:55:11 <voyons_osti> you could reasonably claim that exceptions are dynamically-typed, like the rest of the language
09:55:30 <saml> exceptions are purely functional 
09:57:03 <EvanR> so haskell's stdlib and runtime and network lib may throw many different exceptions, but it's not documented. You might say, better not document it and then not be allowed to change that behavior later. Ok so the problem is even worse, the exceptions are unknown and subject to change
09:57:15 <hyperisco> voyons_osti, "Boolean blindness" means what is true is forgotten, and all you have is True or False. It gets a special name because it is a common methodological mistake.
09:58:01 <hyperisco> voyons_osti, in a language such as TypeScript, for example, you can overcome this with type guards.
09:58:23 <voyons_osti> hyperisco, you might have missed the part where i said <voyons_osti> i'm familiar with the concept of boolean blindness
09:59:14 <hyperisco> I wasn't totally happy with the response given to "boolean blindness?", so I am chiming in.
09:59:59 <hyperisco> The matrix servers must be back up!
10:01:19 <EvanR> i'm still not happy with all the responses to boolean blindness
10:01:41 <EvanR> but what'm i gonna do about it
10:03:07 <hyperisco> All case analysis is blind in the same way. I think Boolean gets a bad rap.
10:04:06 <EvanR> do you mean non-dependently typed case analysis
10:04:36 <EvanR> even then, when your ADT has different cargo on different cases, that really helps
10:04:54 <hyperisco> There is nothing special about the Boolean ADT that makes it more or less blind than other ADTs.
10:05:02 <EvanR> (going all the way back to how to arrange for this in a language that doesn't have sums)
10:05:29 <EvanR> hyperisco: Just x vs Nothing... it's hard to reverse these when you need the x
10:06:18 <hyperisco> It is just incidentally involved in a common malpractice. It is the thinking that is wrong, and not if/then/else or Boolean. That's all I want to emphasise.
10:17:00 <boxscape> has there been any proposals or haskell prime pages or anything like that on the topic of named typeclass instances, which you would provide yourself instead of relying on the solver?
10:19:23 <ski> hm, i wonder how hard it would be to ensure one never used more than one instance, for any given type (and type class), with something like that
10:19:42 <EvanR> i am rewatching type classes vs the world to see arguments against what boxscape said
10:20:05 <boxscape> I guess I might watch that too
10:20:48 * ski never heard of it
10:21:12 <EvanR> it's like 2 hrs long so i stopped telling people to watch it :)
10:21:12 <hyperisco> The idea of passing an instance by name defeats the concept of type classes
10:21:47 <hyperisco> You may as well just have a record of definitions and pass that. See "Scrap Your Type Classes".
10:21:50 <boxscape> isn't that what we're already kind of doing though with Sum newtypes and such?
10:22:09 <hyperisco> I haven't played with Backpack but afaik it is something similar to ML modules. Might be relevant.
10:22:27 <EvanR> modules comes up in that video
10:22:41 <EvanR> among other non-typeclass things
10:23:48 <hyperisco> boxscape, no. You say the type in Sum, and you can say what *the* instance for Sum is, but you cannot pass any instance for Sum.
10:23:55 <hyperisco> the type is Sum*
10:24:58 <boxscape> hmm
10:25:08 <EvanR> the instance chosen depends on types and not values basically
10:25:46 <boxscape> it just seems like it should be a fairly small step considering instances are explicitly passed in Core anyway
10:25:59 <EvanR> where as implicits, modules, type classes in idris and agda, are basically waht you said. You can just pick the instance
10:26:00 <parsley-dev> it's also required so that constraints form a category, if I understood type classes vs the world correctly
10:26:01 <hyperisco> It isn't a technical challenge
10:26:32 <hyperisco> It is designed this way on purpose. The fact that there is just one instance (or none) for a type is what it is all about.
10:26:56 <hyperisco> That lets you, for example, union two Sets of Int.
10:29:15 <hyperisco> You may be interested in implicit parameters instead.
10:29:48 <EvanR> i should have said, instance is determined by types
10:30:10 <boxscape> I haven't looked at implicit parameters much because I got the impression that they're not really widely used or liked
10:32:23 <hyperisco> Probably true. But, most people just wait to be told what to do and what to like. So, if it works for you, give it a go.
10:32:55 <boxscape> I might take a look at them
10:33:08 * hyperisco says in #haskell
10:33:24 <hyperisco> I know most of you got into Haskell because all your friends were doing it. Don't deny it!
10:33:38 <boxscape> I got into haskell because I saw a youtube comment about how it's better than Java
10:33:52 <parsley-dev> I liked the logo
10:34:00 * hackage schemas 0.2.0.2 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.2.0.2 (PepeIborra)
10:35:03 * ski . o O ( <https://web.archive.org/web/20001011102107im_/http://www.cs.chalmers.se/Cs/Research/Functional/Pictures/logo.gif> )
10:35:32 <hyperisco> Also relevant to implicit paramsâ€¦ reader.
10:36:28 <ski> three hours and twenty minutes
10:37:10 <EvanR> i got https://www.youtube.com/watch?v=hIZxTQP1ifo which is 1:42
10:42:58 <parsley-dev> after perusing Gabriel's counter-argument I'd say type classes work very well for categorical constructs and that their merits are debatable otherwise
10:43:52 <EvanR> does the basic need for + to work in different situations fall under categorical
10:44:39 <parsley-dev> like Sum vs Product?
10:45:05 <parsley-dev> or the Num operator +
10:45:10 <EvanR> arithmetic
10:45:18 <EvanR> Num
10:46:22 <EvanR> ok so check out this possibility when you upgrade access to type classes: f :: Num a => Num a => a -> a -> a
10:46:35 <boxscape> what does that mean
10:46:57 <EvanR> imagine you are about to write a function that takes two Nums for a single type
10:47:04 <boxscape> % f :: Num a => Num a => a -> a -> a; f = undefined
10:47:04 <yahb> boxscape: 
10:47:07 <boxscape> (valid haskell btw)
10:47:23 <EvanR> right now it doesn't matter how the two Num dictionaries are used among the algorithm
10:47:48 <EvanR> since according to ideal understanding, there is only 1 Num for any give type
10:48:07 <EvanR> but with implicits or explicit instance passing you could pass two, and then it would matter in the code where hey are used
10:48:15 <EvanR> and right now you can't even say how they are used
10:48:44 <EvanR> i guess part of the explicit feature would also be to access the dict directly and apply the methods to arguments
10:49:00 <EvanR> so f would likely look ugly AF
10:49:03 <boxscape> it does kind of bug me that we have a visibility override for some of the invisible quantifiers (like `forall a .` now and `foreach a .`in the future) but not for =>
10:49:26 <boxscape> then again, there's a proposal that's been I think accepted to write `forall {a} .` which would prevent you from overriding the visibility
10:49:34 <parsley-dev> afaik nums could be built from categories like group and ring, but it's a maybe more hassle
10:50:54 <EvanR> parsley-dev: besides that, i was wondering if practically we want different + on the same type, but nevermind me
10:52:38 <parsley-dev> I'd say definitely not
10:53:02 <EvanR> yeah it's an inconsequential question i think
10:55:47 <EvanR> so kmett might be saying we're not smart enough to juggle a bunch of instances (the relevant instance and the ones they depend on) in a coherent way
10:56:06 <EvanR> and we wouldn't want to me, since it could be significant code
10:57:01 <ski> perhaps there should be a way to distinguish between different categories
10:57:39 * ski isn't sure how that'd work, though
11:00:00 <EvanR>  so self contained systems of type classes?
11:00:27 <EvanR> which would have no currency in the greater world
11:01:22 <parsley-dev> for example, in "scrap your type classes" one argument is that type classes are unsafe: you stick brackets around an argument and get the list monoid behavior rather than the one you wanted
11:02:01 <parsley-dev> to me that isn't a problem for monoid: I plugged in the wrong category and got a result which I can reason about and see where I went wrong
11:03:15 <parsley-dev> like I wouldn't want the type checker to complain in that case
11:13:52 <pikajude> what's the easiest way to make an Integer newtype with specific bounds?
11:14:05 <pikajude> i can define my own Bounded instance but the Num instance won't respect it
11:14:26 <EvanR> you want it to wrap around?
11:14:50 <pikajude> i'd like to error if the number is outside the bounds, but if i can't control the overflow behavior, wrapping is fine too
11:14:55 <ski> manually declare the `Num' instance ?
11:15:04 <pikajude> yeah
11:15:06 <pikajude> i guess so
11:15:28 <ski> `Bounded' is unrelated to `Num'
11:15:35 <pikajude> no, i know
11:15:46 <pikajude> i was just wondering if there was some secret clever way to enforce bounds in Num that i was unaware of
11:22:13 <boxscape> what would `:k Show` show before Data.Kind.Constraint existed?
11:22:31 * hackage cgi 3001.5.0.0 - A library for writing CGI programs  https://hackage.haskell.org/package/cgi-3001.5.0.0 (PeterSimons)
11:25:54 <lyxia> I don't know, but maybe it was simply not allowed
11:26:31 <boxscape> yeah that sounds plausible
11:36:38 <EvanR> at 1:14 in the video there is a diamond diagram about interaction between Eq, Ord and list. Seems interesting
11:37:06 <parsley-dev> yeah it's a natural transformation in the category of constraints
11:42:00 <mrfincher> Hello, how does this work here? can i just ask a question here?
11:42:29 <lyxia> yes
11:42:39 <mrfincher> ``
11:43:19 <mrfincher> is there a better way to write this? :D
11:43:19 <mrfincher> ``
11:43:22 <mrfincher> damn
11:43:26 <mrfincher> you get the idea :D
11:43:41 <hyperisco> Actually, I have no idea
11:44:00 <boj> mrfincher: if you are trying to post code, you will want to use a pastebin link
11:44:02 <mrfincher> i love haskell but this is ridiculous :D
11:44:16 <mrfincher> ah ok thanks boj
11:46:37 <kderme> Hey guys, I'm looking for a topic for my master thesis, related to Haskell/ghc. Anyone has any idea he would like to share?
11:47:29 <coldpress> which part of haskell are you interested in?
11:47:34 <hyperisco> kderme, see all conal's work and help him please
11:48:49 <hyperisco> kderme, that's Conal Elliott
11:49:22 <hyperisco> kderme, particularly with concat and lately his work on ML
11:49:57 <kderme> maybe runtime/parallelism/distributed or anything related to parsing/dsl/interpreters
11:51:01 <hyperisco> His research is all over the latter
11:53:21 <coldpress> kderme: you've seen Harper?
11:53:57 <kderme> hyperisco do you know if he has any software projects related to his publications? I think I'm better at hands on stuff :)
11:55:31 <[exa]> kderme: convert imgui to lenses and serious monads (just an idea)
11:56:01 <hyperisco> kderme, https://github.com/conal/concat
12:04:26 <coldpress> kderme: i've always wanted to rewrite pandoc, but using bijective transformations
12:05:16 <parsley-dev> coldpress: I was thinking something similar!
12:05:47 <parsley-dev> parsing to a native language is not very "functional" the more I think about it
12:06:09 <ski> @where gf
12:06:10 <lambdabot> Grammatical Framework, dependently typed FPL, categorial grammar formalism, supporting multilingual grammar applications for e.g. natural language processing, at <http://www.grammaticalframework.org/
12:06:10 <lambdabot> >. (An old `Alfa' interface is at <http://web.archive.org/web/*/http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>)
12:06:39 <hyperisco> I have a suspicion that pandoc isn't about perfection
12:07:05 <hyperisco> I thought it was more about "I don't care, just give me a dot what I need"
12:07:16 <parsley-dev> no, and the least common denominator approach is actually very nice in many ways
12:09:26 <parsley-dev> but I also think an ecosystem of X->Y document converters is important, rather than readers and writers
12:10:04 <parsley-dev> (to and from the same native format)
12:10:53 <coldpress> updating a reader and then its corresponding writer is a chore
12:10:54 <kderme> thanks guys. Do you think editor support for Haskell is a good topic? I know a lot of work needs to be done there, but would it have any academic interest at all, or just bug hunting etc?
12:11:18 <coldpress> i'm just not sure whether the syntactic baggage of BX is better or worse
12:11:42 <coldpress> kderme: you're aware of emac's Haskell mode?
12:11:56 <fendor> kderme, also, there is haskell-ide-engine and ghcide
12:12:48 <parsley-dev> coldpress: to clarify, you mean bijective in the sense of unifying each reader to its writer?
12:13:18 <kderme> I use haskell-ide-engine and recently heard about ghcide (I had also used ghcid in the past)
12:13:22 <dmwit> If I have `class Foo a where method :: a -> b -> C`, how can I bring type `b` into scope in the body of `method`?
12:13:40 <dmwit> I tried ScopedTypeVariables and writing `method :: forall b. a -> b -> C`, which seems not to have done the trick.
12:14:08 <phadej> InstanceSigs ?
12:14:17 <dmwit> Ah, thanks!
12:14:55 <fendor> ghcide and ghcid are not really related 
12:15:07 <dmwit> That seems to bring it into scope, yep.
12:15:45 <fendor> or not in the same ballpark
12:15:59 <cocreature> fendor: the relation is Neil :)
12:16:15 <fendor> cocreature, obviously
12:16:47 <parsley-dev> to me what would be more appealing than another haskell IDE is a simple, general-purpose editor written in haskell
12:18:28 <dmwit> Heh. GHC is not able to check that `forall o. F o` is a more general instance signature than the method signature `forall o. F o`. (`F` is a type family.)
12:18:33 <dmwit> drat
12:18:57 <coldpress> parsley-dev: yes, in the sense of https://www.informatik.uni-marburg.de/~rendel/unparse/
12:19:36 <parsley-dev> this is very relevant to my interests thank you!
12:20:05 <merijn> Hah, I saw "unparse" and I though "hey, I know a relevant paper!" but then the link was already about that paper :p
12:20:53 <coldpress> any other recommendations on bx? It's a small field, so I don't know many recommendations
12:27:59 <parsley-dev> when looking into the bijections package I found http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.153.9383 which also involves a parser/pretty-printer
12:30:33 <mozzarella> where should I learn haskell
12:31:47 <evelyn> mozzarella: https://wiki.haskell.org/Tutorials
12:31:59 <lyxia> parsley-dev: I think boomerang is the most elegant solution in Haskell in this area.
12:32:02 <evelyn> mozzarella: http://haskellbook.com/
12:34:53 <fendor> My ~/.stack and ~/.cabal folder take up over 100GB of space
12:35:06 <merijn> fendor: Have you gone through multiple GHC versions?
12:35:17 <fendor> yeah. 
12:35:19 <merijn> fendor: I'm guessing you have a crapload of outdated junk in there
12:35:31 <fendor> probably, but there is no collect garbage command :/
12:35:57 <merijn> fendor: Do you use v2-build with cabal?
12:36:20 <fendor> yes
12:36:26 <merijn> fendor: If yes then under ~/.cabal/store there should be different subdirs for each GHC version
12:36:29 <Digit> hi, &, sorry haskell
12:36:39 <merijn> fendor: Just nuke whichever GHC versions you're (no longer) using
12:36:41 <Digit> i just called haskell wacky, in another chan.  :3
12:36:47 <fendor> oh yeah, makes sense
12:37:12 <merijn> fendor: Alternatively, I just nuke all of ~/.cabal and ~/.ghc once or twice a year :p
12:37:31 <fendor> yeah, I want to do that soon
12:37:32 <merijn> fendor: There is, incidentally some experimental work on a v2-build GC, but it's unclear what the right UI should be
12:38:15 <merijn> fendor: https://github.com/haskell/cabal/issues/3333 there's also a link to an experimental GC tool for v2-build stores
12:39:24 <fendor> three years old. but it is good if there is any progress
12:40:22 <fendor> thanks for the issue!
13:00:37 <mozzarella> evelyn: that's a bit expensive
13:02:23 <evelyn> mozzarella: Then look at the other tutorials.
13:02:28 <evelyn> or pay for the book
13:04:08 <mozzarella> where can I download it illegaly?
13:07:01 <evelyn> That's not reasonable at all
13:07:43 <evelyn> You're going to find it hard for anyone to care to help you from now on.
13:10:50 <monochrom> Wait, is someone asking where to download GHC illegally?!
13:11:23 <koz_> monochrom: Haskell book.
13:11:45 <MarcelineVQ> mozzarella: https://en.wikibooks.org/wiki/Haskell isn't too bad though it lacks exercises
13:12:58 <MarcelineVQ> mozzarella: and people often reccomend https://www.seas.upenn.edu/~cis194/spring13/lectures.html where you're doing fairly challenging exercises right off the bat
13:15:06 <cheater> hi
13:15:20 <cheater> what is the latest resolver for stack that doesn't get broken due to new cabal?
13:15:40 <cheater> i use lts-13.11
13:17:19 <wildtrees> cheater, I upgraded my haskell platform the other day to get stack to work again after along hiatus from using stack 
13:17:47 <cheater> what resolver do you use?
13:18:32 <wildtrees> i needed an older package, so I ended up using lts-12.26, but I believe lts-14.7 is the latest resolver 
13:18:43 <wildtrees> 12.26 used ghc-8.4.4 iirc 
13:23:06 <cheater> right. thanks
13:23:22 <cheater> hey, is there a function in the classes, like pure, but creates an empty list?
13:23:38 <cheater> mempty i guess?
13:24:19 <MarcelineVQ> sure or [] directly
13:24:31 <cheater> thanks
13:28:00 * hackage hierarchical-clustering-diagrams 0.4 - Draw diagrams of dendrograms made by hierarchical-clustering.  https://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.4 (FelipeLessa)
13:50:03 <dmwit> :t empty
13:50:04 <lambdabot> Alternative f => f a
13:50:06 <dmwit> cheater: ^
13:53:43 <koz_> I need something of signature (a -> Maybe a) -> a -> [a], which basically repeatedly applies the function until it hits a Nothing, and gives me back all the contents of the Justs it got along the way, in the same order.
13:53:50 <koz_> Is there something built-in I can use for this?
13:56:01 <merijn> :t unfold -- ?
13:56:02 <lambdabot> error:
13:56:02 <lambdabot>     â€¢ Variable not in scope: unfold
13:56:02 <lambdabot>     â€¢ Perhaps you meant one of these:
13:56:03 <MarcelineVQ> unfoldr
13:56:06 <merijn> :t unfoldr -- ?
13:56:07 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:56:20 <koz_> Yeah, that might work, thanks.
14:00:33 <MarcelineVQ> > (\f -> unfoldr (fmap (join (,)) . f)) (\x -> if x > 3 then Nothing else Just (x+1)) 0 -- you can finally use one of cute uses of join
14:00:35 <lambdabot>  [1,2,3,4]
14:02:34 <purelazy> MarcelineVQ hi
14:02:55 <MarcelineVQ> hello
14:03:32 <purelazy> how are you?
14:05:21 <MarcelineVQ> I'm good, you writing haskell? :>
14:06:18 <purelazy> I saw you type > (\f -> unfoldr (fmap (join (,)) . f)) (\x -> if x > 3 then Nothing else Just (x+1)) 0 -- you can finally use one of cute uses of join
14:07:18 <purelazy> I wondered what it was about
14:07:34 <MarcelineVQ> yeah that was for koz_ who asked: <koz_> I need something of signature (a -> Maybe a) -> a -> [a], which basically repeatedly applies the function until it hits a Nothing, and gives me back all the contents of the Justs it got along the way, in the same order.
14:08:00 <MarcelineVQ> :t unfoldr -- is a close match to that requirement
14:08:01 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:08:50 <MarcelineVQ> So we just need to massage the function you give unfoldr a bit by making it be a -> Maybe (a,a) instead of just a -> Maybe a
14:10:31 <MarcelineVQ> :t join -- the cute use of join is when m is (r ->) we get (r -> a) -> (r -> r -> a)
14:10:32 <lambdabot> Monad m => m (m a) -> m a
14:10:39 <Guest_62> If you want ghcup to automatically fix your ~/.bash_profile to include the required PATH variableanswer with YES and press ENTER (at your own risk).
14:10:42 <Guest_62> ???
14:10:48 <MarcelineVQ> oop, (r -> r -> a) -> (r -> a)
14:11:21 <purelazy> MarcelineVQ -  can you explain the problem to beginner?
14:11:39 <knightseq> does anyone have any experience running recursion-schemes with Control.Parallel and has a resource to point to?
14:12:21 <glguy> Guest_62: What's your question?
14:12:43 <Guest_62> trying t install haskell on my mac and I got this in the terminal. --> If you want ghcup to automatically fix your ~/.bash_profile to include the required PATH variableanswer with YES and press ENTER (at your own risk).
14:12:49 <Guest_62> don't know what it means 
14:12:57 <glguy> Which part?
14:13:43 <Guest_62> And then I got this before that --->  In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/   /.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
14:14:36 <glguy> If you ask a question like "What is GHC?" we can answer it.
14:14:52 <dminuoso> purelazy: If you ever see "why did they use <insert method name here> here", just figure out what instance is being used, and think of how that method is implemented for that instance.
14:16:15 <Guest_62> GHC is a haskell compiler I believe 
14:16:47 <purelazy> dminuoso - Are you talking to me?
14:17:00 <dminuoso> purelazy: Yes.
14:17:18 <dansho> Guest_62: i haven't installed haskell on a mac, but i would just answer 'yes' there
14:17:38 <purelazy> dminuoso - Stop
14:19:30 * hackage hslogger 1.3.1.0 - Versatile logging framework  https://hackage.haskell.org/package/hslogger-1.3.1.0 (HerbertValerioRiedel)
14:20:49 <dansho> is it possible to implement Generic or does it have to be derived?
14:21:00 <koz_> knightseq: I'm not sure recursion-schemes has support for par and seq in it. What are you trying to do?
14:21:05 <koz_> dansho: It's possible, yes.
14:21:12 <koz_> Not usually worthwhile though.
14:26:28 <knightseq> koz_ the goal was to create parallel anamorphisms and catamorphism for a proof-of-concept genetic algorithm -- making an ana for the initial population and the cata for the creation of the next generation
14:27:44 <koz_> I think you'd likely have to roll your own. I'd also say that (given my experience in such things) you're probably better off working with a parallel array framework here.
14:28:15 <koz_> Unless you need a structure that's non-trivially richer than an array to house your population.
14:28:35 <dansho> koz_: is it possible to get something like a type parameter into a datatype and still be able to derive generic?
14:29:01 <koz_> dansho: What do you mean by that? You can derive Generic for something like [a] perfectly fine, and that has a type parameter in it.
14:29:05 <purelazy> anamorphism  catamorphism - what do these words mean
14:29:27 <koz_> purelazy: https://maartenfokkinga.github.io/utwente/mmf91m.pdf
14:29:31 <dansho> koz_: oh, i guess its the datatype context specifically (the type parameter has a class constraint)
14:29:35 <koz_> It explains it in a lot of detail.
14:29:50 <koz_> dansho: Datatype contexts as in the Haskell2010/98 idea?
14:30:21 <koz_> Or are you using a GADT?
14:30:27 <purelazy> what do these words mean in a sentence
14:30:34 <merijn> dansho: Datatype contexts are Haskell98, they were removed in 2010
14:30:37 <merijn> eh
14:30:41 <merijn> s/dansho/koz_
14:30:43 <koz_> purelazy: Read that paper, and if you have specific questions, we'd be happy to explain.
14:30:43 <dansho> https://paste.ee/p/A9YWe
14:30:47 <koz_> merijn: Thanks.
14:30:53 <knightseq> purelazy the ELI5 of it is that anamorphisms construct something (using a co-algebra, which is just a function), and catamorphisms destruct something (using an algebra, which is just a function)
14:31:04 <merijn> For good reason, because datatype contexts are useless
14:31:11 <dansho> " Parameters must not have a datatype context" is the error i get
14:31:20 <koz_> dansho: That doesn't tell me very much - could you also give me the definition of the thing you're trying to derive Generic for?
14:31:21 <merijn> dansho: Delete the datatype context
14:31:27 <merijn> dansho: You don't want datatype contexts
14:31:34 <merijn> You think you do, but you don't
14:31:38 <koz_> Yeah, they don't do what you think they do.
14:31:49 <merijn> They do nothing useful and there's a reason they were removed in Haskell2010
14:31:53 <koz_> If you want something like 'I can't put anything in here which doesn't fit that constraint' you want a GADT.
14:32:23 <merijn> koz_: Actually, the GADT does something else again, which is turn it into an existential which most people also don't really want :p
14:32:38 <purelazy> can none of you explain anything?
14:32:39 <merijn> But at least existentials *have* a use, albeit niche
14:32:49 <koz_> merijn: Yes, but I haven't see the definition or the use case, so I'm just guessing. :P
14:33:11 <koz_> purelazy: knightseq just gave you a simple explanation. If you want detail, I have provided you with a starting point.
14:34:27 <dansho> koz_, merijn: the code section looks like this: https://paste.ee/p/7XbmE
14:34:45 <purelazy> I see none of you can explain. Just like Monads.
14:34:58 <koz_> dansho: Yeah, that's a datatype context. You don't want those.
14:35:28 <merijn> dansho: Remove everything between "data" and "Parameters"
14:35:36 <koz_> Is your goal here something like 'Parameters can only store things which fit the Generic and Generator constraints'?
14:36:06 <koz_> purelazy: I don't quite understand what the issue is. knightseq gave you an ELI5. Do you have further questions - if so, please say what they are.
14:36:06 <dansho> yes
14:36:14 <koz_> dansho: Datatype contexts don't do that.
14:36:21 <merijn> koz_: Well, they do
14:36:26 <merijn> It's just that that's not useful
14:37:01 <merijn> Because what most people *really* want is "if I tell the compiler everything in this must be an instance of Foo, then I don't have to add "Foo" typeclass constraints on every function using it"
14:37:09 <merijn> And they don't do *that*
14:37:18 <koz_> Yeah, that's a better explanation, thanks.
14:37:52 <dminuoso> purelazy: Have you ever felt the need to take a list, and combine it into a single thing? Say taking the sum from a list of integers?
14:39:02 <purelazy> dminuoso - don't make it personal
14:39:47 <koz_> purelazy: What's your goal?
14:40:47 <purelazy> people find this stuff hard - it should be easy
14:41:11 <purelazy> my goal - making it easy
14:41:17 <dminuoso> Making what easy, exactly?
14:41:56 <purelazy> monads for starters
14:42:09 <purelazy> 100000000000 tutorials
14:43:54 <dminuoso> purelazy: Monad is a tricky case because it's an abstract pattern that itself cannot be easily explained. There's a fairly good article describing why there are so many tutorials, and why they rae bad.
14:44:03 <dminuoso> purelazy: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
14:44:59 <koz_> I would also say that the Typeclassopedia is worth reading, from the beginning, as it helps get you there.
14:45:07 <purelazy> Monad is a tricky case because no-one can teach it
14:45:14 <dminuoso> Sure it can be taught.
14:45:19 <koz_> Of course it can be taught.
14:45:31 <dminuoso> And it can also be easily explained, but probably you won't find the explanation satisfactory or helpful.
14:45:36 <koz_> It requires scaffolding though.
14:45:51 <rom1504> purelazy: are you pure lazy ?
14:47:02 <purelazy> rom1504 - i don't do anything unless I have to.
14:47:30 <dminuoso> purelazy: My opinion on Monad is, you don't need to understand the idea in order to use it. And once you begin using it, you automatically start understanding it.
14:47:47 <koz_> Also, @pl is smarter than I thought.
14:47:59 <koz_> @pl \x -> [toFinite x ..]
14:47:59 <lambdabot> enumFrom . toFinite
14:47:59 <dminuoso> I think one of the most effective ways of teaching Monad, is showing how you don't need to understand it at all in order to use any of its instances.
14:48:09 <dminuoso> And have you build up intuition on your own.
14:50:38 <purelazy> There should be 1 Monad tutorial
14:51:42 <purelazy> To which all understanders should subscribe
14:52:03 <boj> then we would have 1000 + 1 monad tutorials
14:52:05 <dminuoso> purelazy: The understanding of Monad comes from within, not from something you read.
14:52:39 <dminuoso> purelazy: Its sort of like...
14:52:43 <purelazy> Within - within what?
14:52:46 <dminuoso> Its hard to explain what porn is, it takes watching porn to build up an intuition to recognize it.
14:52:54 <boj> purelazy: your own mind/intuition
14:53:12 <MarcelineVQ> purelazy: haha that's a neat double entendre :>
14:54:05 <purelazy> I do not get Monads
14:54:28 <purelazy> It means nothing to me
14:54:33 <boj> i am with koz_ though, and wish my earlier self understood this - read Typeclassopedia, and then keep reading it once per month until you finally understand it. at that point, you will realize you intuit monads
14:54:37 <dminuoso> purelazy: Great, its not supposed to either.
14:54:37 <MarcelineVQ> "<purelazy> There should be 1 Monad tutorial" "<purelazy> To which all understanders should subscribe" That's funny because of https://en.wikipedia.org/wiki/Monad_(philosophy) an entirely different Monad than what we refer to here
14:54:38 <purelazy> Explain it
14:54:47 <dminuoso> purelazy: Monad is an interface consisting of two functions. Nothing more.
14:54:55 <purelazy> I will record your answers
14:55:05 <purelazy> For 1000000000000 years
14:55:14 <dminuoso> purelazy: Anything more is useless nonsense that requires intuition and mind models.
14:55:17 <purelazy> Shoot
14:55:27 <boj> no one has the time to humor you
14:55:39 <wildtrees> @type join 
14:55:41 <lambdabot> Monad m => m (m a) -> m a
14:55:50 <wildtrees> @type fmap 
14:55:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:56:04 <wildtrees> now purelazy have you ever joined after using an fmap? 
14:56:30 <mozzarella> what's an fmap?
14:56:44 <dminuoso> mozzarella: an fmap is sort of like a wrench
14:56:52 <wildtrees> > fmap (+2) (Just 2) 
14:56:53 <lambdabot>  Just 4
14:56:58 <wildtrees> > fmap (+2) Nothing 
14:57:00 <lambdabot>  Nothing
14:57:01 <EvanR> whatta
14:57:04 <dminuoso> mozzarella: Except its made for Mexican food.
14:57:05 <purelazy> Stop went everyone gets it
14:57:14 <purelazy> when
14:57:26 * boj snickers at dminuoso
14:57:31 <wildtrees> > fmap (+2) [1,2,3] 
14:57:33 <lambdabot>  [3,4,5]
14:58:08 <mozzarella> > fmap (+2) [1, Just 2, 3]
14:58:10 <lambdabot>  error:
14:58:10 <lambdabot>      â€¢ No instance for (Num (Maybe Integer))
14:58:10 <lambdabot>          arising from a use of â€˜e_12123â€™
14:59:13 <boj> how to come up with how to focus the student on the example, not the underlying concept
14:59:20 <purelazy> Sorry. 
14:59:41 <wildtrees> > fmap (fmap (+2)) [(Just 1),Nothing,(Just 3)]
14:59:42 <lambdabot>  [Just 3,Nothing,Just 5]
15:00:08 <wildtrees> mozzarella, Just 2 and 1 are different types , and lists have to all be the same type in haskell 
15:00:19 <purelazy> I am a guy who has struggled with Monads for years
15:00:33 <merijn> wildtrees: Just 2 and 1 *might* be different types :p
15:00:49 <purelazy> painfully not understanding them
15:00:59 <ysangkok> merijn: what are you alluding to?
15:01:06 <wildtrees> merijn, how could they be the same type? and I think you mispelled your name 
15:01:06 <dminuoso> merijn: Wouldn't that require impredicative types?
15:01:12 <merijn> dminuoso: Why?
15:01:19 <wildtrees> purelazy, do you understand fmap? 
15:01:33 <dminuoso> merijn: Oh wait I can see where yo uare getting at.
15:01:35 <merijn> ysangkok: If you define an instance "Num a => Num (Maybe a)"
15:01:45 <merijn> Which, tbh, is a totally reasonable instance
15:01:45 <purelazy> i get map
15:02:15 <merijn> wildtrees: eh...misspelled my name? what?
15:02:39 <wildtrees> thought it was normally merjin 
15:02:50 <boj> purelazy: ok, so running with that, map is just fmap specialized to lists
15:03:13 <merijn> As does literally all of the English speaking world, doesn't make them any less wrong everytime they mangle my name
15:03:32 <wildtrees> oh 
15:03:50 <MarcelineVQ> merijn: I also insert an extra i. in my head you're merijin
15:04:01 <purelazy> I'm talking about the 1000000000000 monad tutiorials
15:04:18 <boj> purelazy: rule #1, don't read monad tutorials
15:04:21 <purelazy> Let's have 1
15:04:42 <boj> purelazy: have you read Typeclassopedia yet?
15:05:12 <merijn> MarcelineVQ: Same thing with all the crazy people insisting my name has 6 letters. It has 5, dammit! And has had 5 for the past 33 years! I refuse to capitulate to the ASCII hegemony imposed by nonsense anglo-phones >.<
15:05:16 <boj> you should start there (or re-start), and let it stew for awhile
15:05:49 <MarcelineVQ> merijn: uh
15:05:54 <purelazy> I want a "This is the Monad Tutorial"
15:06:04 <boj> ok, i am bored now
15:06:32 <wildtrees> @type (join . fmap) 
15:06:32 <purelazy> To save millions of people searching
15:06:33 <lambdabot> error:
15:06:33 <lambdabot>     â€¢ Occurs check: cannot construct the infinite type: m ~ (->) (m a)
15:06:33 <lambdabot>       Expected type: (a -> a1) -> m (m a1)
15:06:46 <EvanR> % try (return (1 `div1 0))
15:06:46 <yahb> EvanR: ; <interactive>:109:22: error: parse error on input `0'
15:06:51 <EvanR> % try (return (1 `div` 0))
15:06:51 <yahb> EvanR: ; <interactive>:110:1: error:; * No instance for (Show (IO (Either e0 Integer))) arising from a use of `print'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
15:07:00 <EvanR> % try (return (1 `div` 0)) :: IO Int
15:07:00 <yahb> EvanR: ; <interactive>:111:1: error:; * Couldn't match type `Either e0 Integer' with `Int'; Expected type: IO Int; Actual type: IO (Either e0 Integer); * In the expression: try (return (1 `div` 0)) :: IO Int; In an equation for `it': it = try (return (1 `div` 0)) :: IO Int
15:07:05 <EvanR> nevermind!
15:08:49 <purelazy> Who on this channel understands Monads 100%
15:09:11 <fendor> % try (return (1 `div` 0)) :: IO (Either SomeException Int)
15:09:11 <yahb> fendor: Right *** Exception: divide by zero
15:09:38 <EvanR> heh
15:09:45 <EvanR> % mapM (try . evaluate) [3 `div` 0, minBound `div` (-1)] :: IO [Either SomeException Int]
15:09:45 <yahb> EvanR: [Left divide by zero,Left arithmetic overflow]
15:09:49 <fendor> % try (return $ evaluate (1 `div` 0)) :: IO (Either SomeException Int)
15:09:49 <yahb> fendor: ; <interactive>:122:1: error:; * Couldn't match type `IO Integer' with `Int'; Expected type: IO (Either SomeException Int); Actual type: IO (Either SomeException (IO Integer)); * In the expression: try (return $ evaluate (1 `div` 0)) :: IO (Either SomeException Int); In an equation for `it': it = try (return $ evaluate (1 `div` 0)) :: IO (Either SomeException Int)
15:10:19 <MarcelineVQ> No one one this channel, I expect, would say they understand any single thing 100% but that's just the kind of crowd it is. Typeclassopedia is the "This is the Monad Tutorial", but only for haskell.
15:10:26 <purelazy> And can explain the idea
15:10:46 <purelazy> To the average person
15:10:50 <boj> purelazy: so, one final time: have you read Typeclassopedia?
15:11:04 <EvanR> explaining monads is easy, as evidenced by the population of monad tutorials
15:11:20 <purelazy> boj yes
15:12:01 <dminuoso> It seems to me as if purelazy is just trying to sabotage this channel, rather than spending his time learning about the marvelous mysterious of monads.
15:12:06 <MarcelineVQ> purelazy: That's very good, then can you say which part you did not understand?
15:12:23 <MarcelineVQ> Because being specific is how you gain understanding
15:12:51 <MarcelineVQ> dminuoso: could be but it's monday, so
15:12:58 <dminuoso> merijn: 5 letters? How so?
15:13:17 <MarcelineVQ> dminuoso: my man we handled that one already
15:13:39 <wildtrees> purelazy, this helped me
15:13:42 <fendor> @type evaluate
15:13:43 <lambdabot> a -> IO a
15:13:44 <wildtrees> % :t (\item f -> join (fmap f item)) 
15:13:44 <yahb> wildtrees: Monad m => m a1 -> (a1 -> m a2) -> m a2
15:13:51 <wildtrees> % :t (>>=) 
15:13:51 <yahb> wildtrees: Monad m => m a -> (a -> m b) -> m b
15:13:55 <fendor> % try (evaluate (1 `div` 0)) :: IO (Either SomeException Int)
15:13:55 <yahb> fendor: Left divide by zero
15:14:11 <wildtrees> purelazy, see how they are about the same type? 
15:14:35 <wildtrees> so just understand fmap first, then figure out join, then you can figure out bind/(>>=) 
15:14:48 <wildtrees> return is usually pretty easy by itself and I suspect you understand it 
15:17:09 <purelazy> It is a fact, as a joke, that on-one explains Monads
15:17:24 <purelazy> as = and
15:17:57 <wildtrees> purelazy, understand return , join and fmap 
15:18:22 <wildtrees> join with fmap makes (>>=) which is called bind 
15:18:22 <purelazy> A teaching = A Joke
15:19:05 <lavalike> :t (>>=)
15:19:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:19:10 <boj> purelazy: hopefully you understand that no one here is intentionally trying to be difficult, we truly are trying to be helpful
15:19:12 <lavalike> :t flip ((join .) . fmap)
15:19:13 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a2
15:19:57 <boj> purelazy: if there is a dictionary-style definition that you seem to be seeking though, it has not been discovered
15:19:58 <purelazy> boj = I am still stupid
15:20:26 <dminuoso> boj: Sure it has.
15:20:45 <dminuoso> A monad is just a monoid in the monoidal category of endofunctors, equipped with endofunctor composition as its tensor and the Identity functor as its unit.
15:20:55 <boj> :>
15:20:56 <MarcelineVQ> purelazy: Which monad are you trying to learn about? if it's haskell's then the typeclassopedia is the answer, if you don't understand what the typeclasopedia said, ask about _that_
15:21:41 <parsley-dev> monad is program composition
15:22:01 <dminuoso> parsley-dev: I think at its very core, the best fitting attribute to monads is sequentiality.
15:22:02 <parsley-dev> where a program is a stateful computation
15:22:05 <dminuoso> Not compositionality.
15:22:21 <dminuoso> But that attribute is deep and quite orthogonal to how one might think
15:22:37 <parsley-dev> explain?
15:22:48 <wildtrees> purelazy, the associativty laws for monads made more sense to me using (>=>) instead of (>>=)
15:22:54 <wildtrees> @type (>=>) 
15:22:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:23:00 <dminuoso> parsley-dev: Do you want the categorical or some superficial explanation?
15:23:07 <parsley-dev> @type (flip .)
15:23:08 <lambdabot> (a1 -> a2 -> b -> c) -> a1 -> b -> a2 -> c
15:23:14 <parsley-dev> oops
15:23:39 <parsley-dev> wait wat
15:23:52 <parsley-dev> dminuoso: categorical
15:24:00 <dminuoso> parsley-dev: Are you familiar with the joke I said above?
15:24:26 <purelazy> Just 1 website which explains the concept of monad
15:24:33 <parsley-dev> I guess not?
15:24:56 <purelazy> Just 1 website which explains the concept of monad
15:25:02 <dminuoso> parsley-dev: How good is your CT? Do you know what a monoid is (in a monoidal category)?
15:25:06 <parsley-dev> @type flip (.)
15:25:06 <lambdabot> (a -> b) -> (b -> c) -> a -> c
15:25:07 <boj> parsley-dev: it's technically correcet, but does not explain monads in a way that us laymen can follow :)
15:25:12 <parsley-dev> @type (>=>)
15:25:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:25:34 <purelazy> Can anyone make Just 1 website which explains the concept of monad
15:25:47 <parsley-dev> dminuoso: oh I guess not lemme think about that lol
15:25:47 <dminuoso> parsley-dev: I can give you some comparison.
15:25:50 <purelazy> yes or no
15:25:53 <boj> no
15:26:06 <boj> congrats, you won the conversation
15:26:16 <MarcelineVQ> purelazy: yes, for haskell.
15:26:18 <dminuoso> parsley-dev: Would you agree, that (.) is about sequentiality of things in some sense?
15:26:40 <dminuoso> parsley-dev: In the sense that (.) is somehow about data going from one place into another... "first this function, then that"
15:26:56 <parsley-dev> yes
15:26:59 <purelazy> no???????????????
15:27:13 <dminuoso> purelazy: We have the exact same construct on the type level, its called :.:. We can compose two functors like `Maybe :.: Either Int`
15:27:17 <dminuoso> Err parsley-dev  ^-
15:27:36 <purelazy> Can anyone make Just 1 website which explains the concept of monad
15:27:41 <dsal> purelazy: monads are really easy to understand, unless you don't understand the stuff they're made of.
15:27:43 <fendor> purelazy, how about https://github.com/dbrattli/oslash/wiki/Functors,-Applicatives,-And-Monads-In-Pictures ?
15:27:51 <dminuoso> parsley-dev: It's semantically equivalent to function composition, so `(Maybe :.: Either Int) Bool` is isomorphic to `Maybe (Either Int Bool)`
15:27:54 <dminuoso> parsley-dev: Does this make sense?
15:28:02 <parsley-dev> yes
15:28:20 <dsal> It's like asking someone to explain the weak nuclear force in isolation without making me understand any other science or math junk.
15:28:49 <dminuoso> parsley-dev: Great. Are you also fine with imagining that Monad could be defined in terms of join rather than (>>=)? (The fact it cant right now is technical limitations that are irrelevant to this discussion)
15:28:58 <purelazy> parsley-dev I look forward to it
15:29:03 <parsley-dev> yeah definitely
15:29:14 <parsley-dev> join made more sense to me learning monads, same with cojoin and comonads
15:29:26 <dminuoso> parsley-dev: join :: Monad m => m :.: m ~> m
15:29:33 <Logio> Here's an idea: "choose your-own adventure" webpage/text adventure for monads
15:29:48 <parsley-dev> define ~>
15:30:04 <dminuoso> type (~>) m n = forall a. m a -> n a
15:30:19 <dminuoso> parsley-dev: It's just a little syntax sugar trick to show we dont care about the `a`
15:30:26 <dminuoso> It's really about the "other stuff"
15:30:29 <boj> dminuoso: that is a natural transformation, yeah?
15:30:31 <dminuoso> boj: Yes.
15:30:49 <parsley-dev> oh right
15:31:02 <parsley-dev> yeah so it demonstrates the monad commuting diagrams
15:31:06 <parsley-dev> or one of them
15:31:13 <purelazy> parsley-dev - you can make monads understandable?
15:31:22 <dminuoso> parsley-dev: So Monad is about consuming these "composition" layers really. And composition is somehow about sequentiality. This can be observed in (>>=) quite well when you think about type dependencies.
15:31:36 <parsley-dev> dminuoso: right this is making sense now
15:31:53 <wildtrees> purelazy, have you tried learning specific monads, like IO , Maybe, and List ? how about the Identity monad? 
15:32:10 <parsley-dev> dminuoso: the best one-liner I've read is "monads consume values to produce state, comonads consume state to produce values"
15:32:20 <MarcelineVQ> wildtrees: it's pretty clear at this point he's not tried anything since he's asking for things already given
15:32:36 <dminuoso> parsley-dev: It's just false, really.
15:32:36 <wildtrees> said he has spent years trying to understand monads 
15:32:37 <dsal> parsley-dev: monads are wax on?
15:32:45 <dminuoso> parsley-dev: Monad is not about any particular use case.
15:32:53 <dminuoso> Its why grokking it is so hard.
15:33:07 <dminuoso> parsley-dev: I can think of at least 3 monad instances that completely defy that notion you just named.
15:33:12 <boj> yeah, good point. it's an abstraction, not a particular thing
15:33:13 <parsley-dev> dminuoso: I disagree sort of, they're about a meta-use case at least, in programming
15:33:57 <dminuoso> parsley-dev: They are about a raw pattern that just magically emerges on its own.
15:34:07 <parsley-dev> dminuoso: in CT yes
15:34:11 <dminuoso> parsley-dev: Even in programming.
15:34:21 <dminuoso> parsley-dev: For example: Look at the list monad, its not about state - it models non-determinism.
15:34:24 <parsley-dev> dminuoso: they emerge magically because programmers are doing particular things
15:34:31 <dminuoso> parsley-dev: Consider ContT. Consider Tardis. Consider reverse state.
15:35:01 <parsley-dev> dminuoso: List and Cont are not really state, true
15:35:35 <fendor> side question, what is reverse state?
15:35:45 <dminuoso> fendor: with modify you can modify past state..
15:35:48 <dminuoso> fendor: Need I say more?
15:36:07 <dminuoso> fendor: with reverse state you can manipulate future state backwards..
15:36:36 <parsley-dev> I don't know how I got into this debate lol, down the monad rabbit hole as always
15:36:46 <boj> and you can do both with the tardis monad!
15:36:48 <dminuoso> (and tardis is the combination of both, such that you can manipulate forwards, backwards, read from the past, read from the future)
15:39:40 <dminuoso> The more I think of it, the more monads I can see that are really not about state
15:39:57 <fendor> ok, i see. thanks!
15:45:30 * hackage setdown 0.1.1.0 - Treating files as sets to perform rapid set manipulation.  https://hackage.haskell.org/package/setdown-0.1.1.0 (RobertMassaioli)
15:51:50 <Squarism> Anyone know if its possible to list what classes a type has instances for at runtime? Using reflection or some other "trick"?
15:55:56 <Squarism> And let me add it has to in some generic context like : deserialize :: TypeableOrSoemthingElse a => String -> a 
16:01:17 <EvanR> https://stackoverflow.com/questions/29284765/haskell-instanceof-analogue
16:09:24 <sshine> that's a pretty good Q&A.
16:13:42 <Squarism> EvanR, thanks. I know this is doubtful but I cannot seem to find a better approach atm
16:28:02 <koz_> dminuoso: What library is Tardis from?
16:30:12 <ByteEater> quick question: what does Rdr stand for in RdrName?
16:30:54 <koz_> ByteEater: Reader, judging by the docs.
16:32:50 <ChaiTRex> koz_: Think it's the tardis package. https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html
16:33:32 <ByteEater> koz_, have you got a link handy?
16:34:10 <ByteEater> I can't find any reference to Reader in https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/rdr-name-type or other places
16:34:30 <koz_> ByteEater: https://hackage.haskell.org/package/ghc-8.6.5/docs/GHC.html#t:RdrName
16:34:34 <koz_> ChaiTRex: Oh, thanks!
16:35:05 <ByteEater> thanks, koz_!
17:15:30 * hackage antiope-sns 7.4.4 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-sns-7.4.4 (arbornetworks)
17:16:31 * hackage antiope-athena 7.4.4, antiope-sqs 7.4.4, antiope-dynamodb 7.4.4, antiope-s3 7.4.4, antiope-contract 7.4.4, antiope-messages 7.4.4, antiope-swf 7.4.4, antiope-optparse-applicative 7.4.4, antiope-core 7.4.4, antiope-shell 7.4.4 (arbornetworks)
17:38:36 <dansho> is it possible to do something like this?: https://hastebin.com/inabiyebef
17:38:56 <cheater> is there a formulation of Maybe where Just is an error and Nothing continues computation?
17:39:03 <cheater> i.e. search for stuff until you find something.
17:39:16 <cheater> i'd like to write a do block that yields the first Just that it finds.
17:40:26 <hpc> look at the Alternative instance for Maybe
17:42:59 <cheater> so basically if i have a bunch of functions that return Maybe a, called f, g, h, I can do myX = f <|> g <|> h ?
17:43:08 <cheater> i remember now, thanks
18:03:34 <lyxia> dansho: enable ScopedTypeVariables
18:10:08 <koz_> What's the deal with MonadZip? I'm not sure why it needs a Monad superclass - couldn't it be done with Applicative?
18:13:34 <inkbottle> HIE (+emacs): "Main.hs is not part of any project. Select action:  "
18:14:54 <inkbottle> Well it seems I've been able to skip that step.
18:15:19 <dansho> lyxia: ty!
18:22:00 <MarcelineVQ> koz_: seems like it, all the instances can at least
18:23:33 <koz_> That was why I was wondering.
18:23:55 <koz_> Are there any Applicatives that can't be ApplicativeZips?
18:35:17 <dibblego> No.
18:36:39 <koz_> I'm guessing hysterical raisins for the Monad superclass then.
18:45:25 <inkbottle> Why do we need to add "spock" to "extra-deps" in "stack.yaml" when "spock" is present in Stackage?
18:45:38 <inkbottle> https://www.spock.li/tutorials/getting-started
18:46:41 <inkbottle> I've tried stack build spock
18:50:07 <MarcelineVQ> probably because it's not present in recent resolvers
18:51:22 <MarcelineVQ> it's Spock however, capitalised, this'll matter in cabal and stack files
18:54:54 <inkbottle> MarcelineVQ: good points, the 2 of them. (the second was already fixed)
18:58:39 <inkbottle> How do I see the latest resolver Spock is in? (https://www.stackage.org/package/Spock)
18:59:01 <inkbottle> found
18:59:05 <inkbottle> 12.26
19:14:30 * hackage websockets-simple-extra 0.0.0 -   https://hackage.haskell.org/package/websockets-simple-extra-0.0.0 (athanclark)
19:29:34 <badzergling> should `instance Monoid (f (g a)) => Monoid (Data.Functor.Compose f g a)` exist?  is there an orphans package somewhere that has it?
19:49:44 <lyxia> badzergling: this email on the Haskell libraries mailing list sounds relevant https://mail.haskell.org/pipermail/libraries/2018-February/028571.html
20:11:55 <rocket_man> so I was going to ask a question about how to make my code better
20:12:07 <rocket_man> but while making a simpler example I got a compiler panic lol
20:13:54 <rocket_man> I have an old version of GHC though going to try with > 8.2
20:26:38 <rocket_man> yep upgrading fixed it
20:26:56 <rocket_man> wow ubuntu lags behind a lot, I had 8.0.2 and the newest version is 8.8
20:28:08 <dsal> It's a little early for 8.8, IME
20:29:46 <koz_> Quite a few bits of the ecosystem still have issues with 8.8.
20:29:47 <monochrom> Yeah, go for 8.6 for now. But still, 8.0 is way behind.
20:29:50 * koz_ mumbles mumbles.
20:30:28 <monochrom> Just use ghcup and use what it recommends (its default).
20:32:06 <rocket_man> ehh, I don't really care about the exact versions
20:32:22 <rocket_man> as long as I'm not hitting bugs from 2009 lol
20:36:30 * dsal loves modern bugs
20:38:40 <rocket_man> what's the behavior of `fromInteger i` where i > the max value of Int? does it throw an exception?
20:39:33 <monochrom> No. It wraps around.
20:40:20 <rocket_man> oh cool, so I can just check if `fromInteger i < i` to see if it wrapped
20:40:57 <rocket_man> or I guess that would have to be `toInteger fromInteger i < i` because haskell is strict about numeric types
20:47:54 <dsal> > fromInteger 290 :: Int8
20:47:55 <lambdabot>  34
20:49:15 <dsal> > 290 > toInteger (maxBound :: Int8) -- rocket_man 
20:49:16 <lambdabot>  True
20:49:41 <rocket_man> ah that's simpler, thanks :)
20:51:20 <rocket_man> why can't I call `elem` on a tuple of more than two elements?
20:51:24 <rocket_man> > 1 `elem` (1,2,3)
20:51:26 <lambdabot>  error:
20:51:26 <lambdabot>      â€¢ No instance for (Foldable ((,,) Integer Integer))
20:51:26 <lambdabot>          arising from a use of â€˜elemâ€™
20:51:48 <Axman6> because there isn'ty an instance for Foldable for tuples larger than 2
20:52:13 <Axman6> > elem 1 (1,2) -- just FYI, this doesn't do what you expect
20:52:15 <lambdabot>  False
20:52:22 <Axman6> :t elem
20:52:23 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
20:52:35 <rocket_man> what is it doing?
20:52:59 <iqubic> It's using "instance Foldable ((,) a) where..."
20:53:02 <Axman6> it's seeing if any of the a's in some Foldable f is equal to the given value
20:53:15 <Axman6> and t gere is ((,) b)
20:53:18 <Cale> The first component of a pair should be thought of like an additional tag, the last component is the one that things like fmap and Foldable's stuff interacts with
20:53:18 <Axman6> here*
20:53:33 <iqubic> for tuples, the foldable instance is only about to look at the second element.
20:53:37 <rocket_man> > 1 `elem` (2, 1)
20:53:39 <lambdabot>  True
20:53:39 <Cale> > length (1,2)
20:53:41 <lambdabot>  1
20:53:43 <rocket_man> oh that's so weird
20:53:48 <iqubic> :t length
20:53:49 <lambdabot> Foldable t => t a -> Int
20:53:56 <Axman6> it's not weird at all if you understand Foldabe
20:54:07 <Cale> It makes a lot of sense if you think of Data.Map as being a collection of pairs :)
20:54:15 <iqubic> @check (\x y -> length (x, y) == 1)
20:54:17 <Axman6> and the only possible instance that (,) b can have
20:54:17 <lambdabot>  +++ OK, passed 100 tests.
20:54:24 <iqubic> Yeah, that's a weird thing.
20:54:54 <Cale> A single pair of type (k,v) is like a Map k v with exactly one element
20:54:54 <rocket_man> hmm, so `Foldable` returns a series of tuples of (index, value), like `enumerate` in python?
20:54:54 <iqubic> That length thing for tuples is silly and dumb.
20:55:07 <iqubic> No.
20:55:28 <Axman6> no...
20:55:44 <Cale> Foldable does a bunch of stuff, but perhaps the most primitive thing that it has is foldMap (everything else can be defined in terms of that)
20:55:46 <Cale> :t foldMap
20:55:47 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:55:48 <Axman6> foldable is about comfining all the a's in some t a
20:55:52 <iqubic> Foldable on its own is just a constraint, like Eq or Ord or Bounded or Enum.
20:56:00 <dmj`> iqubic: the FTP (foldable / traversable proposal) were some dark days in haskell, people left the community over it
20:56:05 <Cale> So, if t a = (k,a)
20:56:21 <iqubic> FTP?
20:56:43 <Cale> Then this extracts the one value of type a that's available, and applies the function to it to obtain an element of type m
20:56:43 <Axman6> combining*
20:56:53 <dmj`> iqubic: https://wiki.haskell.org/Foldable_Traversable_In_Prelude
20:57:00 <Cale> and then simply produces that
20:57:03 <iqubic> dmj`: People don't like foldable or traversable in Prelude? Why?
20:57:29 <dmj`> iqubic: for the reason you just cited w/ length on tuple.
20:57:51 <dmj`> too much polymorphism can make it difficult to learn for beginners
20:58:12 <rocket_man> but why does the implementation of Foldable for tuple only return the 2nd element instead of both elements?
20:58:31 <Cale> Because the first element might have some completely different type, for one
20:59:09 <Axman6> rocket_man: because that's the only a in (c,a)
20:59:10 <Cale> But moreover, if you think about the types of these things, it becomes clear that it shouldn't even have access to that other element in the case that it *does* have the same type.
20:59:13 <iqubic> Because Foldable is a single parameter type class. It can only really access one of the two elements.
20:59:59 <rocket_man> so why implement for two elements? why doesn't this work:
21:00:00 <rocket_man> > 1 `elem` (1,)
21:00:02 <lambdabot>  error:
21:00:02 <lambdabot>      â€¢ No instance for (Num (Integer, ())) arising from the literal â€˜1â€™
21:00:02 <lambdabot>      â€¢ In the first argument of â€˜elemâ€™, namely â€˜1â€™
21:00:32 <iqubic> 1 `elem` (True,'a',1)
21:00:44 <iqubic> > 1 `elem` (True,'a',1)
21:00:45 <lambdabot>  error:
21:00:45 <lambdabot>      â€¢ No instance for (Foldable ((,,) Bool Char))
21:00:45 <lambdabot>          arising from a use of â€˜elemâ€™
21:00:50 <iqubic> Oh?!?!
21:01:03 <iqubic> We don't have a foldable instance for (,,)?
21:02:35 <Axman6> it's mostly because of the Traversable instance for ((,) c), where the first element is seen as a tag to the a, which is combined with ither (c,a)'s bu using the Monoid instrance for c
21:03:00 <macroprep> https://i.imgur.com/PIqwDRE.jpg is this what a vector space R^3 would somewhat look like (im not sure if the 3rd vector is dependent of 1st and 2nd or not)
21:03:29 <Axman6> it doesn't make much sense to have instances for larger tuples, since you can have ((a,b),c) instead of (a,b,c), with a and b being instances on Monid
21:04:08 <rocket_man> I'm not sure what you mean by 'a tag to the a'
21:05:02 <Axman6> the first element of the tuple is an annotation ofor the second, so maybe a count of how many times that a's been seen in some dataset, or all the log messages which went into producing that a
21:06:16 <rocket_man> hmm .. because all values in haskell are immutable, so the only use for tuples is heterogeneous types 
21:06:36 <rocket_man> ok I think I see, so anything like (1, 2, 3) would look strange and should be an array instead?
21:07:08 <Axman6> sure, in a list or an vector, or something else which is a container for values of a single type. 
21:08:09 <Axman6> tuples are not inductive types, you can't iterate over the elements of a tuple - (a,b,c) is somplertely distinct from (b,c), there's no constructor which takes an (b,c) and an a and gives you a (a,b,c) without pulling apart the (b,c)
21:08:32 <Axman6> lists on the other hand are either empty or a value of type a and another list of a's
21:10:20 <maerwald> well, (1,2) has a Functor instance, but you might be surprised :>
21:10:37 <rocket_man> gotcha. I'm used to python where the _only_ way to have an immutable container is to use a tuple
21:10:52 <crestfallen> hi on ghci 8.4.4 this program works fine. on my work machine I updated cabal but the program returns an error, something like : No instance of Semigroup ... Is there a quick fix ? sorry the machine is not in front of me.     https://termbin.com/6o31
21:26:37 <maerwald> crestfallen: define Semigroup instance where (<>) = mappend
21:27:19 <maerwald> basically move mappend to (<>) of semigroup
21:27:26 <maerwald> and omit mappend in Monoid
21:33:50 <crestfallen> maerwald, sorry move mappend to (X>) of semigroup ?
21:33:58 <crestfallen> (<>)*
21:36:56 <maerwald> yeah, mappend is deprecated and is now (<>) in Semigroup
21:37:49 <MarcelineVQ> crestfallen: "<maerwald> crestfallen: define Semigroup instance where (<>) = mappend" is the quick fix. the other way is to define <> for Semigroup in the same way you defined mappend and then not define mappend for Monoid, because by default mappend = <>
21:41:16 <crestfallen> maerwald, MarcelineVQ thanks I'll see if I can get it to work on the machine with 8.4.4.
21:41:19 <MarcelineVQ> Monoid wasn't defined in terms of Semigroup when the book was written. So unfortunately Monoid is introduced before Semigroup and you might get errors like you got
21:42:39 <crestfallen> ok so monoid is now a subgroup of semigroup
21:42:43 <crestfallen> ?
21:44:52 <MarcelineVQ> The terminology you're likely to see is that Semigroup is a superclass of Monoid, I'm not sure if that means Monoid is a subclass of Semigroup because I don't know 100% what superclass/subclass mean.
21:45:34 <crestfallen> ok yeah not a cakewalk thanks MarcelineVQ 
21:55:13 <crestfallen> I don't really understand the instructions so far MarcelineVQ . this is what I have so far:     https://termbin.com/wjky
21:55:20 <ski> `Monoid' is subclass of `Semigroup', yes
21:56:48 <crestfallen> so I guess I'm far off
21:57:32 <crestfallen> hold on trying something else..
22:00:05 <crestfallen> nah
22:03:25 <MarcelineVQ> You chose to try both fixes instead of just one, that's not going to work out. mempty and mappend are not members of Semigroup they're memebers of Monoid. https://gist.github.com/MarcelineVQ/13468b3cad3fbd280f753db15e920d77
22:04:31 <crestfallen> weird thanks MarcelineVQ I thought I tried exactly what you have for the first one.
22:06:10 <MarcelineVQ> ah right, you'd need instance Monoid a => Semigroup (Optional a) where ... to use mappend in Semigroup
22:14:22 <crestfallen> nah can't get it to work dangit
22:16:16 <crestfallen> this is what I have MarcelineVQ    https://termbin.com/up27
22:17:34 <MarcelineVQ> https://gist.github.com/MarcelineVQ/13468b3cad3fbd280f753db15e920d77
22:23:27 <crestfallen> so fix 1 is exactly what you have up to line 11, with import Data.Monoid ; import Data.Semigroup    ? MarcelineVQ 
22:24:31 <crestfallen> I'm getting ambiguous occurence error
22:24:36 <crestfallen> for <>
22:25:47 <crestfallen> from this    https://termbin.com/an91
22:27:23 <crestfallen> so this is on 8.4.4 where the initial program I pasted works fine   :)
22:29:05 <crestfallen> thanks ski btw
22:29:05 <MarcelineVQ> lemme get 8.4.4 and see
22:29:11 <crestfallen> thanks!
22:29:56 <MarcelineVQ> hmm, no issues here. When you get an error you need to share the code, the error, and what you did to get the error, such as compiling or typing into ghci.
22:30:33 <crestfallen> I loaded into ghci, hold on I'll try to compile it
22:30:43 <crestfallen> the error is ...
22:30:45 <MarcelineVQ> Especially since your code doesn't give me any errors as given
22:34:57 <crestfallen> https://termbin.com/2be9
22:36:43 <MarcelineVQ> Then I think you're not on ghc 8.4.4, that's an error I get with 8.2.2
22:37:49 <EvanR> either way, you should be able to hide the offending <> during import
22:37:53 <crestfallen> dang now I'm getting IO errors
22:38:13 <EvanR> import Whatever hiding (<>)
22:39:09 <crestfallen> on both imported modules?
22:39:34 <crestfallen> its definitely 8.4.4
22:39:58 <EvanR> the one you don't want
22:41:30 <crestfallen> I don't understand based on how both instances are written
22:41:36 <MarcelineVQ> It would save a lot of pain to just use a little older ghc and work with what works for the book
22:42:53 <crestfallen> ok I'll do that and take a shower now that I've broken a sweat :)     thanks MarcelineVQ EvanR 
22:58:16 <maerwald> always shower before switching ghc version
22:58:39 <MarcelineVQ> These are words of wisdom.
23:00:13 <monochrom> haha
23:00:13 <EvanR> wait... people do haskell outside the shower?
23:00:43 <c_wraith> well, what does a bathtub count as?
23:00:44 <monochrom> Take a flu shot before switching ghc version. :)
23:00:55 <monochrom> bathtub ide
23:01:09 <monochrom> emacs bathtub mode
23:01:15 <MarcelineVQ> c_wraith: hedonism
23:01:38 <MarcelineVQ> but you gotta say it as baaahhhhth for it to be hedonism+
23:02:11 <monochrom> haha
23:02:37 <monochrom> And include champaign.
23:03:39 <MarcelineVQ> champaiggggn toweeers for everyoneee
23:03:43 <monochrom> Both in a glass and in the baaahhhth tub.
23:04:04 <monochrom> err s/glass/tower/, yes haha
23:05:23 <EvanR> escape from the ivory bathtub
23:19:25 <crestfallen> you people are funny :)
23:20:57 <koz_> #include <champagne.h>
23:21:10 <koz_> Or, given where we are, import Control.Monad.Champaigne
23:22:05 <iqubic> What does the Champaigne monad do?
23:23:19 <koz_> iqubic: return adds champagne to the provided value.
23:23:54 <koz_> Bind takes a value with champagne, and a way of adding champagne to something while performing a pure function, and gives you a value with twice as much champagne.
23:23:59 <EvanR> event bubbling
23:24:22 <koz_> (with the function applied naturally)
23:24:25 <iqubic> return provides a glass full of campaigne, with your value floating in the glass.
23:25:11 <iqubic> This is too good.
23:25:51 <EvanR> someone gonna point out its really somehow a comonad
23:26:06 <koz_> EvanR: You can always get some champagne out. :P
23:26:24 <iqubic> How is it a comonad?
23:26:46 <EvanR> koz_ described dublicate
23:26:59 <koz_> EvanR: You mean extract right?
23:27:10 <EvanR> earlier
23:27:20 <iqubic> If you have a value floating in a champainge glass, you can just dump out he champaign and get the original value.
23:27:25 <iqubic> That is extract.
23:27:46 <EvanR> what is the value doing in my drink
23:27:59 <EvanR> looks like the backstroke
23:28:25 <crestfallen> I don't drink. maybe that's why I'm horrible at haskell
23:28:30 <iqubic> Well, you see, the champaign (co)monad gives you pure values soaked in champaign.
23:28:35 <iqubic> That's what it is.
23:29:04 <iqubic> It's a way of passing around values that preserves their alcoholic content.
23:46:14 <dminuoso> 08:44:59       EvanR | [06:23:36] event bubbling
23:46:35 <dminuoso> Can we express the amount of bubbles in terms of KnownNat?
23:48:09 <jsomedon> foldr folds from right to left, so if I foldr on a really large list, then the whole list needs to be evaluated before processed by foldr?
23:48:28 <dminuoso> jsomedon: I think "folding from right to left" is misleading.
23:48:57 <dminuoso> And not really true
23:49:15 <dminuoso> jsomedon: https://www.joachim-breitner.de/blog/753-Drawing_foldl_and_foldr this is a good visual indicator
23:49:49 <EvanR> the fact that the whole list DOESN'T need to be evaluated proves folding from right to left is misleading
23:50:21 <EvanR> if you can evaluate haskell step by step, that would come in handy now
23:51:12 <dminuoso> jsomedon: I find that the most useful definition of foldr on lists, is by imaginging that `foldr f z` replaces (:) with `f` and [] with z
23:51:24 <dminuoso> (Well this is not as much a definition, as it is a mental bridge)
23:51:47 <EvanR> i do 1 or 2 steps using the @src definition
23:51:51 <EvanR> @src foldr
23:51:52 <lambdabot> foldr f z []     = z
23:51:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:53:00 <EvanR> > foldr (\x rest -> x+1) '0' "hello"
23:53:01 <lambdabot>  error:
23:53:02 <lambdabot>      â€¢ No instance for (Num Char) arising from a use of â€˜+â€™
23:53:02 <lambdabot>      â€¢ In the expression: x + 1
23:53:08 <EvanR> > foldr (\x rest -> succ x) '0' "hello"
23:53:10 <lambdabot>  'i'
23:53:17 <EvanR> > foldr (\x rest -> succ x) '0' (cycle "hello")
23:53:19 <lambdabot>  'i'
23:54:18 <EvanR> rest represents continuing, an option you don't have to take
23:55:05 <jsomedon> so they both are left to right but for L: this iteration's result is accumulator for next iteration, but for R: next iteration's result will be this iteration's accumulator
23:55:39 <EvanR> i understand foldl using the @src definition, it recurses to the end of the list before doing anything
23:55:42 <EvanR> @src foldl
23:55:43 <lambdabot> foldl f z []     = z
23:55:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:56:30 * hackage describe 0.2.0.6 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.2.0.6 (riuga)
