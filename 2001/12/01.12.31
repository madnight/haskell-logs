00:03:04 --- topic: 'spooky. quiet. | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo'
00:03:04 --- topic: set by shapr on [Sun Dec 30 06:56:21 2001]
00:03:04 --- names: list (clog teek dennisb smklsmkl jlb pHa xbill sjanes71)
00:23:23 <julien> hi all
00:40:34 <julien> Hi shapr
00:40:42 <shapr> hi julien!
00:40:43 <shapr> what's up?
00:41:10 <julien> I compiled my first Haskell program with ghc :-)
00:41:15 <shapr> yay!
00:41:27 <julien> (I was missing the -package option for 2 weeks ...)
00:41:56 <julien> No I'm ready to try serious things
00:42:06 <shapr> yah, I'm still finding lots of stuff myself
00:42:33 --- topic: set to 'spooky. quiet. | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | shapr is a white belt!' by shapr
00:42:51 <shapr> sounds like you're up to white belt also!
00:43:08 <julien> yes :-)
00:43:11 --- topic: set to 'spooky. quiet. | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | julien and shapr are up to white belt!' by shapr
00:43:23 <julien> :-)
00:44:11 <shapr> I've been working on cleaning up a very old example program
00:44:13 <shapr> a haskell shell
00:44:32 <julien> hmm, is it usable ?
00:44:50 <shapr> http://kungens.kemi.fi/~shae/Hsh4.hs
00:45:53 <shapr> I converted the direct word to word changes, and dennisb and xbill helped me with the stuff I had no clue about.
00:46:02 <shapr> it works, but it doesn't *do* anything yet
00:46:10 <julien> :)
00:46:50 <julien> There is a lot to learn from that (for me at least ...)
00:47:20 <shapr> http://kungens.kemi.fi/~shae/Hsh.hs
00:47:26 <shapr> ok, that's the latest version
00:48:15 <shapr> yah, lots to learn for me also
00:51:11 <shapr> hey, I was having fun experimenting in ghci
00:51:20 <shapr> have you found the [1..5] notation?
00:52:10 <julien> Yes, but I don't remember where ...
00:52:26 <shapr> it just turns into [1,2,3,4,5]
00:52:30 <julien> an example like fac n = product [1..n] or sth like that
00:52:30 <shapr> you can also do [1..]
00:52:37 <shapr> and that gives you all integers
00:52:38 <shapr> right
00:52:41 <julien> that where it becomes funny :)
00:53:02 <julien> I love lazy evaluation
00:53:09 <shapr> yah, me too
00:54:45 <shapr> so I did:
00:54:59 <shapr> map (+1) [1..5]
00:55:14 <shapr> filter (>3) [1..5]
00:55:29 <shapr> let x = map (+1) . filter (>3)
00:55:34 <shapr> x [1..5]
00:55:43 <julien> :)
00:55:49 <shapr> map (+1) . filter (>3) [1..5]
00:55:58 <julien> you can play a long time like that
00:56:03 <shapr> and that last line exploded
00:56:10 <shapr> I found out that I have to do:
00:56:17 <shapr> map (+1) . filter (>3) $ [1..5]
00:57:11 <shapr> I remembered that function application is the tightest binding operation
00:57:19 <shapr> yah, ghci is fun
01:13:05 * shapr reads Simon Thompson's book
01:15:45 <shapr> hm, I bet I could change my Mandelbrot.hs to use iterate
01:26:23 <shapr> I wonder how I could build iterateWhile
01:39:43 <shapr> hrrrm
01:39:46 <shapr> what am I doing wrong?
01:39:51 <shapr> until (>5) iterate (+1) $ [1]
01:40:33 <shapr> oh!
01:40:39 <shapr> aha
01:40:49 <shapr> iterate returns an infinite list of repeated applications
01:40:50 <shapr> duh
01:42:41 <shapr> hm
01:42:48 <dennisb> what do you want to do?
01:43:38 <shapr> I'm trying to build an iterateWhile 
01:43:47 <shapr> and I know I should be able to do this :)
01:44:01 <dennisb> well, the iterate gives a list of results
01:44:04 <shapr> I think I shouldn't be using iterate
01:44:22 <shapr> I just want to keep re-applying a function to its own result until a condition is true
01:44:28 <dennisb> maybe it's just until you want?
01:44:28 <shapr> which I am doing in Mandelbrot.hs
01:44:33 <shapr> maybe so
01:44:45 <dennisb> until (>4000) (*2) 2
01:45:00 <shapr> I thought there might be some kind of apply until
01:45:25 <shapr> how would I do something like "until length (>6) take [1..10]"
01:45:30 <dennisb> until performs the function on the argument util the first predicate returns true
01:46:06 <dennisb> shapr: I don't understand myself what the result would be
01:46:27 <shapr> I was hoping to do something until the returned list is longer than 6
01:46:33 <shapr> hi teek
01:47:45 <dennisb> i'm not sure how..
01:48:25 <shapr> nor am I
01:48:27 <dennisb> take is not something you can just apply many times on the list
01:48:41 <shapr> oh
01:49:35 <shapr> hm
01:49:42 <shapr> until ((>6 ) . length )  iterate (+1) 1
01:49:45 <shapr> hmm
01:49:57 <dennisb> the function to iterate must have type a->a, so you can call it over and over again
01:50:05 <shapr> oh
01:50:19 <shapr> so it should be (+)
01:50:30 <dennisb> plus takes two arguments
01:50:36 <dennisb> (+1) is okay
01:50:47 <dennisb> takes a number, gives a number
01:51:21 <shapr> iterate (+1) 1
01:51:23 <shapr> that works
01:51:25 <dennisb> iterate (+1) 1 woule run the plus one function over and over again starting on the 1
01:51:27 <shapr> very quickly ;)
01:51:38 <shapr> yah, 30523 before I could interrupt it
01:51:44 <dennisb> that's the list of all numbers starting from one
01:51:49 <shapr> right
01:51:56 <shapr> so I want to do that until a condition is met
01:52:08 <dennisb> then use dropWhile
01:52:31 <dennisb> (might even be better functions, I don't rember them all)
01:52:38 <shapr> dropWhile (length < 6) iterate (+1) 1
01:53:07 <dennisb> no
01:53:17 <dennisb> look at the type (use :t drowWhile)
01:53:22 <dennisb> (use :t dropWhile)
01:53:30 <shapr> hm
01:54:00 <dennisb> it looks on each element in the list and drops as long as the predicate says yes
01:54:01 <shapr> ohhh
01:54:21 <shapr> *each element* not *the entire list*
01:54:25 <shapr> that's what I was missing
01:54:29 <dennisb> lenght < 6 is something strange
01:54:42 <shapr> well,  I thought it was operating on the returned list
01:55:08 <dennisb> the entire list is just simple, take 5 [1..] will take the first five elements
01:56:04 <dennisb> for fractals I guess you want se how many iterations until it's below a special number or something?
01:56:08 <shapr> right
01:56:22 <shapr> I have a function oneIter
01:56:33 <dennisb> so, iterate the function on the start value, that will give you the list of all intermediate values
01:56:48 <shapr> I want to do that function on the result of the last time I ran that function, until something happens
01:57:05 <dennisb> yes, sounds like iterate
01:57:21 <dennisb> iterate oneIter start
01:57:48 <shapr> but after I've done one point, I only want to know how many times it iterated
01:58:44 <dennisb> iterate oneIter start, that should give the infinite list of all the values in the serie
01:58:56 <dennisb> then you just do takeWhile followed by length
01:59:06 <shapr> oh
01:59:17 <shapr> that sounds much more elegant than what I've been using, thanks!
01:59:32 <teek> lazy lists are great... 
01:59:51 <shapr> hi teek!
01:59:53 <dennisb> but maybe there is even better ways
02:00:17 <teek> hi, I just popped in, and saw you talking
02:00:30 <shapr> yah, we're here and learning :)
02:00:35 <shapr> I'm up to while belt!
02:02:29 <teek> dennisb, you meant something like: length . takeWhile pred $ iterate oneIter start
02:02:53 <teek> did you ?
02:02:54 <dennisb> something like that
02:03:28 <dennisb> if it works, that's what I meant :-)
02:03:34 * shapr grins
02:03:52 <dennisb> findIndex might work fine to
02:04:00 <shapr> never heard of that one
02:04:06 <teek> shapr, what are you trying to do ? 
02:04:24 <shapr> I'm still not completely comfortable with using the . and $ operators
02:04:29 <shapr> I think I realize what they do
02:04:35 <dennisb> findIndex pred (iterate oneIter start)
02:04:51 <dennisb> gives the index where the predicate is true
02:04:54 <shapr> teek: I'm trying to clean up this code I wrote: http://kungens.kemi.fi/~shae/Mandelbrot.hs
02:05:15 <dennisb> or rather, maybe gives an index
02:06:46 <dennisb> what you want to make sure is that the list is not built up by the compiler, it should run in constant space
02:07:47 * shapr blinks
02:07:54 <dennisb> but it probably will do that in this case. But this is where the biggest problem with lazy evaluation is, it's hard to know when things are done
02:08:02 <shapr> hi Verbed!
02:08:07 <Verbed> Hi!
02:08:20 <shapr> welcome to the #haskell channel, have you been here before?
02:08:26 <Verbed> Nope, first time.
02:08:35 <shapr> cool!
02:09:05 <shapr> are you learning Haskell? Or maybe a long-time user?
02:09:14 <teek> dennisb, what do you mean by "list is not build up by the compiler"
02:09:31 <shapr> dennisb: yah, is there some way to figure out when the list gets built?
02:09:45 <Verbed> shapr: Actually, I've really only glanced at it's specifications, but I've had a recent fascination with functional languages in general
02:09:55 <Verbed> I'm just hear, hopin' to eavesdrop on an interesting conversation..
02:10:11 <Verbed> s/hear/here
02:10:22 <shapr> Verbed: have you done much procedural or other programming before?
02:10:25 <Verbed> Although, that WAS a pre-emptive pun.
02:10:32 <shapr> heh :)
02:11:16 <Verbed> My tool of choice has always been C, and recently, a Python mix.
02:11:26 <Verbed> I have to admit, I really didn't know anything else existed
02:11:34 <shapr> I've been using Python for several years
02:11:35 <Verbed> Until I stumbled upon O'Caml
02:11:37 <Verbed> How about you?
02:12:27 <dennisb> teek: it really should trow away the first part of the list as soon as it have computed the next number, you don't want to build the list and keep all the old ones in memory until you find what you want and then free the whole list so far
02:12:34 <dennisb> s/trow/throw
02:12:36 <shapr> I do Java professionally, though I mostly design and prototype in Jython
02:12:51 <shapr> I find Python much saner than any other procedural language
02:13:02 <shapr> dennisb: ah, that's what you meant
02:13:15 <shapr> right, because memoization is not needed in this case
02:13:17 <teek> dennisb: ok, but is that possible, i.e. if i take composition of length and takeWhile ? 
02:13:21 <dennisb> but it's hard to know such things since compiler optimization can make a difference
02:14:00 <teek> dennisb, do you mean that compiler _should_ figure out that, or that ghc or whatever actually does that ?
02:14:11 <dennisb> but usually, if you make sure that you don't keep a reference to the whole list, for example to do some more calculations afterward it usually works fine
02:14:13 <shapr> Verbed: I realized that functional programming existed, but only recently did I choose to learn it.
02:14:44 <shapr> Verbed: so far, I've written a Mandelbrot.hs, and I've persuaded other people on #haskell to help me clean up a very old bit of example code, Hsh.hs
02:15:15 <shapr> http://kungens.kemi.fi/~shae/Mandelbrot.hs and http://kungens.kemi.fi/~shae/Hsh.hs
02:15:18 <teek> oh yes, so no memoization, and it works that way. Finally something from Persistent Data Structures seminar pops in my mind 
02:15:30 <shapr> I should probably make a haskell folder...
02:15:41 <shapr> whoa, I want to have that seminar
02:15:53 <Verbed> shapr: Hrmm, I'm googling on Mandelbrot
02:15:54 <dennisb> if you for example also do the iterate bla bla and get a list in xs, then if you do y = sum (take 6 xs) as well as the normal takeWhile the system will keep the xs list in memory
02:16:04 <shapr> Verbed: it's just the most basic fractal
02:16:29 <shapr> if you look at the code, it has a text graph at the top
02:16:30 <dennisb> if you need the y later it will start calculating the sum, that means the list must be kept
02:16:36 <shapr> I'm sure it will look familiar
02:16:59 <dennisb> but it will not start calculating until you need y since it's lazy, so it will keep xs for a long time
02:17:49 <dennisb> this is what is called a memory leak in haskell, you will keep maybe a long list xs just so you can calculate that sum in the future, if you calculate it now it can then throw away the list
02:18:08 <shapr> Verbed: you'll probably find much of the Mandelbrot.hs readable, even if you've not read much at all about Haskell
02:18:11 <teek> dennisb, yep, now i start to remember. 
02:18:16 * dennisb is not explaining well now
02:18:50 <shapr> right now my code is passing around IterationCount
02:18:55 <dennisb> in our case I think it will work, but very small changes can make a big difference on the space usage
02:19:00 <shapr> so the last calculation isn't saved at all
02:19:49 <dennisb> in cases like this you usually force the evaluation of the sum using a seq and then the y will be a single number and the xs is not needed more
02:20:09 <dennisb> lazy evaluation is tricky
02:20:14 <shapr> can you give an example?
02:20:23 <shapr> even something trivial showing the difference would help me
02:20:28 <dennisb> yes
02:20:32 <dennisb> let me think
02:20:34 <shapr> for example, I demonstrated $ to myself with:
02:20:44 <shapr> map (+1) [1..5]
02:20:51 <shapr> filter (>3) [1..5]
02:21:04 <teek> dennisb: yep, you can prototype quickly with lazy evaluation, but have to spend time with optimization 
02:21:19 <shapr> let myfunc = map (+1) . filter (>3)
02:21:25 <shapr> myfunc [1..5]
02:21:34 <shapr> but I noticed I have to use:
02:21:36 <dennisb> teek: exactly, but I don't think it's that much harder then to debug other programs
02:21:45 <shapr> map (+1) . filter (>3) $ [1..5]
02:21:51 <shapr> Verbed: do you have a ghci running?
02:21:58 <teek> dennisb, yep, i think it's much better this way. 
02:22:05 <dennisb> let xs = iterate (+1) 1
02:22:06 <dennisb>     y = sum (take 5 xs)
02:22:06 <dennisb> in do print (drop 10000 xs)
02:22:06 <dennisb>       print y
02:22:14 <dennisb> (i think this will show it)
02:22:27 <dennisb> xs is an infinite list, y is a number depending on xs
02:22:50 <dennisb> it's lazy so y will not be calculated until the end where it is printed
02:23:18 <Verbed> shapr: I shall compile it when I am finished with Hugs.  I joined expecting an idle channel :)
02:23:19 <dennisb> (hmm, the first print is wrong, should be head also)
02:23:49 <dennisb> but the first print drops elements in the list, but we must still keep the beginning of the list since it's needed by y
02:24:18 <dennisb> it it was not needed by y when we do the drop, the system can throw away the beginning of the list
02:24:31 <teek> yeah, I understand, and if we calculated it immediately, we could throw away elements while dropping 
02:24:40 <dennisb> so, since eval of y is lazy we must keep xs
02:24:40 <shapr> Verbed: well, whichever one works for you.. hugs or ghc
02:24:52 <dennisb> yes, forcing y would do that
02:25:02 <shapr> Verbed: hugs is probably better for learning
02:25:16 <teek> how forcing is done ? 
02:25:22 <dennisb> (now the compiler might optimize and do that anyway, but)
02:25:30 <dennisb> teek: using the seq function
02:26:06 <dennisb> but this is the most tricky part about haskell as I see it
02:26:38 <shapr> part of the power of haskell is that normally you don't enforce order of operations
02:26:50 <shapr> so the compiler/runtime has more opportunities to optimize it
02:27:09 <shapr> so when you have to order things, it's harder...
02:27:15 <shapr> at least, this is how I see it so far
02:29:55 <dennisb> yes, for most thing it works okay anyway, and if it dont you analyse and fixes leaks like this
02:30:19 <dennisb> usually you can use the heap profiler to see how the memory is used
02:31:08 <teek> I looked at http://www.haskell.org/onlinereport/basic.html#sect6.2 about seq 
02:31:42 <dennisb> teek: okay
02:31:45 <teek> but don't get it properly. How should I use it in our case 
02:32:02 <teek> a = sum (take 5 xs) 
02:32:07 <teek> y = seq a a 
02:32:09 <teek> or what ?
02:32:20 <teek> why there's two parameters 
02:32:49 <dennisb> you can change the first print to seq y (print (head (drop 10000 xs)))
02:33:03 <dennisb> it will force the y to an integer and perform the print
02:33:38 <dennisb> if yu hide the seq inside of y it will not be done until you use y anyway
02:34:36 <teek> okay, so it's kind of "dummy" function that enforces the first parameter to be evaluated and returns second
02:34:40 <dennisb> yes
02:34:46 <dennisb> exactly
02:37:39 <dennisb> I always seems to get into talking about seq, it probably because I don't like people trying to hide hard parts and instead I sort of always talks about the hard part... :-)
02:37:54 <teek> and if I wanted, i could write y = sum $! take 5 xs and take 5 xs would be evaluated.
02:38:12 <teek> oops. no. because y isn't used yet
02:38:31 <dennisb> yes, y is not used and needs not to be evaluated
02:38:37 <Verbed> Well, I'm going to idle for a bit, but it's nice to know this channel is somewhat active
02:38:47 <Verbed> How often is it like this?
02:38:53 <dennisb> Verbed: once a day or something :-)
02:39:11 <dennisb> you got here in the exact right moment
02:39:25 <Verbed> Well, it was certainly surprising :P
02:39:50 <dennisb> now it's probably another 24h of silence...
02:39:54 <teek> Verbed, i'm first time chatting here although i been lurking for some days  
02:40:07 <dennisb> but I just keep this channel open, just in case
02:40:57 <teek> #ocaml seems to be silent also, even more than #haskell
02:41:39 <dennisb> well, we are not that many that chat here either, it's mostly shapr that keeps it up
02:41:48 <shapr> heh, thanks :)
02:41:55 <shapr> I try
02:42:04 <shapr> I figure if I talk enough I can jumpstart this channel.
02:42:31 <shapr> with the help of everyone else of course
02:42:58 <teek> shapr, that's seems to be the only way. All interesting channels that I have looked lately are about as dead as stone 
02:43:08 <shapr> #python is pretty awesome
02:43:16 <teek> lively ?
02:43:27 <shapr> but that's happened from the effort of me and several other people who really worked at it
02:43:43 <shapr> I try hard to keep #emacs, #haskell, and #python worth joining
02:44:11 <Verbed> I'm afriad I'm a dirty Vim user :P
02:44:17 <Verbed> s/afriad/afraid
02:44:22 <teek> i'll check it out... althought I'm moving my scripting from python to ocaml 
02:44:54 --- topic: set to 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | julien and shapr are up to white belt!' by shapr
02:45:24 <shapr> teek: if you use Debian Linux, you may also want to check out #debian-fi
02:45:40 <shapr> though my suomi is bad enough that I don't talk much there
02:49:39 <shapr> I have a strong suspicion I'll be able to edit several chunks of #haskell logs into examples for the Haskell Tutorial
02:50:12 <shapr> I wish emacs had a better ghci interaction mode
02:50:59 <shapr> how does the heap profiler work?
02:51:50 <shapr> I'd like to see the heap profiler showing what dennisb was saying about a 'memory leak'
02:55:24 * shapr plays with dropWhile
02:56:46 <shapr> ack
02:57:29 <shapr> is ocaml simpler than haskell?
02:58:37 <shapr> hm, three from .fi on #haskell :)
03:00:15 * shapr figures out how to use dropWhile in Mandelbrot.hs
03:06:12 <teek> shapr, Haskell is a way more elegant, and in some simple toy-programs I've written, I've found it easier
03:06:58 <teek> shapr, However, if you like to do imperative programming, in Ocaml it's easy. 
03:07:38 <teek> I started with Haskell after Functional Programming seminar (not course, not here in Uni of Helsinki, damn it) 
03:07:46 <shapr> where was the seminar?
03:08:20 <teek> I meant that seminar was in Uni of Helsinki, but we don't have any courses on functional languages 
03:09:07 <shapr> oh
03:09:09 <shapr> that sucks
03:09:31 <teek> However, I'm going to start implementing one of my pet projects, and I decided to use ocaml instead of Haskell 
03:09:31 <shapr> not that I can take courses there unless they were online
03:09:37 <shapr> what's the project?
03:09:48 <teek> ai client for freeciv
03:09:54 <shapr> oh, nifty!
03:10:03 <dennisb> I compiled:
03:10:04 <dennisb> main = let xs = iterate (*2) 2
03:10:04 <dennisb> 	   y = sum (take 5 xs)
03:10:04 <dennisb>        in do print (head (drop 10000 xs))
03:10:04 <dennisb> 	     print y
03:10:12 <dennisb> with and without the seq
03:10:28 <dennisb> the leaky one used 6M of memory, the other 100K
03:10:33 <shapr> wow
03:10:34 <shapr> cool!
03:10:44 <dennisb> and there was a speed difference as well of course..
03:11:22 <dennisb> http://www.zigo.dhs.org/~dennis/leak1.ps
03:11:24 <dennisb> http://www.zigo.dhs.org/~dennis/leak2.ps
03:11:27 <dennisb> is the profiles
03:11:54 <teek> dennisb, have you done some real programming on haskell ? Do you encounter many situations where you have to force evaluations to get acceptable performance ?
03:12:16 <dennisb> teek: Yes I have, and no there are not that many situations
03:12:46 <shapr> which situations did require it?
03:12:51 <dennisb> usually the performence is just fine, when you have problems you look in to it
03:13:01 <shapr> also, how did you get those cool graphs so quickly? :)
03:13:05 <dennisb> ghc
03:13:19 <dennisb> it has tools for it
03:13:30 <shapr> are you using debian?
03:13:36 <dennisb> just compile with -prof
03:13:37 <dennisb> no
03:13:41 <shapr> oh
03:13:42 <dennisb> but it's probably there
03:14:02 <dennisb> then you run the program with +RTS -h
03:14:11 <dennisb> then you get a .prof file
03:14:24 <dennisb> that is converted to postscript using hp2ps
03:14:39 * shapr tries that
03:15:11 <dennisb> but you need a program that runs longer then 0.0001 seconds, so I had to change the program to iterate (*2) 2
03:15:27 <teek> man, irc is really fastest way to learn nifty tricks...
03:16:40 <shapr> yah, totally
03:16:52 <shapr> I need to start HaskellNiftyTricks on HaskellWiki
03:17:38 <shapr> I've been collecting stuff for months on EmacsNiftyTricks
03:17:58 <shapr> http://emacswiki.org/cgi-bin/wiki.pl?EmacsNiftyTricks
03:18:28 <dennisb> you can easily see that the first program does not run in constant space so you have a space leak. Usually the programmer knows he want something that is for example going to run in constant space, and if it doesn't you start to look for leaks
03:18:55 <dennisb> if the programmer has no clue, then it's hard (in any language)
03:19:53 <shapr> that's true 
03:21:26 <dennisb> Someone could try to write that program in C and get a fast result out :-)
03:21:47 <dennisb> s/fast/faster
03:22:22 <dennisb> (but that is just because you don't have big numbers in C)
03:25:45 <shapr> so the haskell program would be more flexible, right?
03:25:52 <dennisb> but no matter what, it will be a big program in C, probably with different loops for the two parts, one for y and one for the printing
03:26:07 <dennisb> you don't want to make a list of numbers in C
03:27:12 <teek> dennisb, yeah, i've been hacking some c for freeciv lately and boy I miss good standard data structures from Ocaml
03:27:37 <shapr> rewrite freeciv in Haskell ;)
03:27:40 * shapr is joking
03:27:43 <dennisb> that is what I also miss, but I like and have write much C in my life as well
03:27:51 <dennisb> s/write/written
03:28:46 <teek> I've done mainly c++/stl lately in my work
03:29:15 <shapr> I've never done any C past reading the White Book
03:30:12 <shapr> hm, I can't get any profiling info from Hsh.hs
03:30:18 <shapr> and Mandelbrot.hs won't compile with ghc >:(
03:34:24 <shapr> shae@raven:~/src/haskell$> ghc -prof -o mandel Mandelbrot.hs
03:34:24 <shapr> /usr/lib/ghc-5.02/libHSstd_p.a(PrelMain__1.p_o): In function `__stginit_PrelMain':
03:34:24 <shapr> PrelMain__1.p_o(.text+0x83): undefined reference to `__stginit_Main'
03:34:24 <shapr> /usr/lib/ghc-5.02/libHSstd_p.a(PrelMain__2.p_o)(.text+0x24): undefined reference to `Main_main_closure'
03:34:24 <shapr> /usr/lib/ghc-5.02/libHSstd_p.a(PrelMain__2.p_o): In function `PrelMain_mainIO_fast1':
03:34:24 <shapr> PrelMain__2.p_o(.text+0x65): undefined reference to `Main_main_closure'
03:34:26 <shapr> collect2: ld returned 1 exit status
03:34:28 <shapr> hmmm
03:34:39 <shapr> linker problems?
03:38:12 <shapr> any ideas?
03:39:00 <shapr> it works when I use :load Mandelbrot.hs
03:39:04 <shapr> but not when I compile... hmm
03:41:55 <dennisb> Where is the Mandelbrot.hs
03:42:14 <shapr> http://kungens.kemi.fi/~shae/Mandelbrot.hs
03:42:18 * dennisb has just got out from the shower
03:43:06 <teek> if i remember correctly, i compiled my toy-programs with ghc --make Mandelbrot.hs . same results ? 
03:43:13 <shapr> oh, let me try that
03:43:24 <dennisb> you need to call the module Main i think
03:43:52 <shapr> ?
03:44:07 <dennisb> it does not find the main function when it is hidden in a module Mandelbrot
03:44:16 <shapr> oh, I need to export it?
03:44:32 <shapr> module Mandelbrot (main)
03:44:33 <shapr> ?
03:44:38 <dennisb> module Main where
03:44:54 <dennisb> or have another module Main where the main function is
03:45:01 <shapr> oh!!
03:45:18 <dennisb> (or no module at all)
03:45:28 <shapr> aha!!
03:45:33 <shapr> module Main (main) works
03:45:35 <shapr> thanks!
03:45:44 <dennisb> It does not try Mandelbrot.main as the main function
03:46:09 <dennisb> thats why the linker says: undefined reference to `Main_main_closure'
03:46:20 <dennisb> I read that as somthing: Main.main
03:46:36 <shapr> I see!
03:47:48 <shapr> shae@raven:~/src/haskell$> ghc -prof -o mandel Mandelbrot.hs && ./mandel +RTS -hC
03:47:48 <shapr> Segmentation fault
03:48:04 <dennisb> it worked here
03:48:10 <dennisb> you program uses constant memory
03:48:15 <shapr> wow
03:48:19 <shapr> I'm surprised :)
03:48:21 <dennisb> I didn't use -hC though
03:48:32 <dennisb> I just ran +RTS -h
03:48:34 <shapr> just -h ?
03:48:42 <dennisb> don't know if it makes a difference
03:48:55 <dennisb> ooh, you have to delete the .o file first
03:49:03 <shapr> oh!
03:49:05 <dennisb> that's probably it
03:49:23 <dennisb> it doesn't understand it have to rebuild it...
03:49:24 <shapr> urf
03:49:57 <teek> i think that ghc --make will take care of such things 
03:50:16 <dennisb> teek: maybe, probably
03:50:41 <shapr> still segfaulting...
03:50:52 <dennisb> what version of ghc
03:50:58 <dennisb> I use 5.02.1
03:51:17 <shapr> oh
03:51:18 <dennisb> 5.00 have been a bit buggy, as almost all .0 programs
03:51:20 <shapr> I think I found it
03:51:28 <shapr> I think it's my ghc itself
03:51:45 <dennisb> ?
03:53:04 <shapr> I'm using 5.02-1
03:53:39 <dennisb> okay, almost as new then
03:53:50 <shapr> right, 5.02.00
03:55:10 <shapr> hmm
03:55:58 <dennisb> is it the compiler that seg faults?
03:56:55 <shapr> no, it's the rts
03:57:08 <shapr> at one point I got "ghc not built for -prof"
03:57:21 <dennisb> well, it's ghc:s fault anyway :-)
03:57:42 <dennisb> aha, did you upgrade then or what?
03:58:04 <dennisb> if it's not built for -prof one can understand you have problems..
03:58:11 <shapr> yah, I think that's it :)
03:58:52 <dennisb> it's the debian maintainer you have to talk with then (or just upgrade if it have been fixed)
03:59:01 <shapr> yah, I agree
03:59:14 <shapr> I'll email him
03:59:19 <dennisb> xbill did it for hugs? Is it he who build ghc to?
03:59:23 <shapr> I asked him for gtk and HOpenGL support recently :)
03:59:29 <shapr> nah, it's someone else I think
03:59:41 <shapr> I've tried to build my own ghc before, it's not easy :(
03:59:42 <dennisb> ok
03:59:54 <dennisb> I agree, it takes some tome
03:59:55 <dennisb> time
04:00:04 <shapr> gotta go shopping, I'll be back later....
04:00:48 <dennisb> http://www.zigo.dhs.org/~dennis/shapr.ps
04:00:53 <dennisb> that's the profile
07:23:30 <shapr> wheeeee
18:14:12 --- topic: 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | julien and shapr are up to white belt!'
18:14:12 --- topic: set by shapr on [Mon Dec 31 02:44:54 2001]
18:14:12 --- names: list (clog sjanes71 smklsmkl dennisb jlb pHa xbill)
