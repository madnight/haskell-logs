02:31:27 * shapr reawakens
02:32:29 <xbill> heh
02:32:52 * shapr blinks
02:33:06 * shapr ingests caffeine and methylphenidate
04:00:55 <shapr> hey, I just listed the ghc5 debian package, and I found this file listed:
04:00:59 <shapr> /usr/lib/ghc-5.02/imports/posix/Posix.hi
04:01:06 <shapr> so how do I actually import that?
04:02:39 <shapr> doing "import Posix" doesn't seem to do that
04:10:18 * shapr wonders
04:14:41 <shapr> aha
04:14:57 <shapr> it seems that everything in the "std" directory is automatically in the module 'path'
04:27:14 * shapr looks through Thompson's book
05:10:27 <shapr> aha
05:11:06 <shapr> ghc -c -i/usr/lib/ghc-5.02/imports/posix Foo.hs
05:13:04 <xbill> -package posix =)
05:13:19 <shapr> bah, too easy
05:13:21 <shapr> :)
05:13:52 <shapr> actually, that's much simpler, I admit.
05:15:05 * shapr is trying to get Hsh to work: http://www.informatik.uni-bonn.de/~ralf/software/examples/Hsh.html
05:26:11 <shapr> aha
05:26:19 <shapr> http://www.haskell.org/ghc/docs/2.10/users_guide/user_8.html
05:26:32 <shapr> seems that dupChannelTo became dupTo in ghc 2.1
05:26:35 <shapr> er, 2.10
05:26:48 <shapr> it seems it's been awhile since anyone updated the Hsh.hs example
05:36:27 <shapr> current problems:
05:36:32 <shapr> Variable not in scope: `failWith'
05:36:34 <shapr> Data constructor not in scope: `UserError'
05:36:34 <shapr> Variable not in scope: `handle'
05:36:34 <shapr> Variable not in scope: `isSpace'
05:36:34 <shapr> Variable not in scope: `try'
05:36:34 <shapr> Data constructor not in scope: `EOF'
05:36:52 <shapr> I'd guess handle should be Fd or something
05:42:32 <shapr> hmm
05:43:10 <shapr> isSpace appears to be in package text
05:43:30 <shapr> but -package text doesn't work
05:47:41 <shapr> hmm
05:47:54 <dennisb> isSpace is in module Char
05:48:51 <shapr> aha!
05:48:54 <shapr> thanks :)
05:50:41 <shapr> ok, so now I'm down to missing [failWith UserError handle try EOF]
05:50:54 <dennisb> the other things i'm notr sure abour. The try and handle seems to be some sort of exception things, i don't think they are in the standard?
05:51:25 <dennisb> well, that's harder
05:52:07 <shapr> several of the changes I've had to make were updating from pre-ghc2.10
05:52:14 <shapr> so this code must be quite ancient :)
05:52:26 <shapr> I could just email the author I guess, but this is a much better way to learn
05:52:32 <dennisb> in newer haskell you can use `catch` to catch exceptions in the IO monad
05:52:45 <shapr> hm
05:52:48 <dennisb> I guess that is what handle do, the try is probably a noop, like id
05:53:04 <shapr> ah, good thought!
05:53:15 <dennisb> but I'm just guessing like mad here..
05:53:45 <shapr> strangely, try and handle are used in entirely separate places
05:54:00 <dennisb> UserError might be what is called IOError now
05:54:13 <shapr> hm, I'll try that
05:54:29 <shapr> failWith (UserError "redirect"))
05:54:39 <xbill> the exception stuff is kind of nasty
05:55:21 <dennisb> xbill: in general or in this example?
05:56:02 <shapr> which package is IOError in?
05:56:07 <shapr> uh
05:56:11 <shapr> maybe IO? :)
05:56:19 <dennisb> Yes, and try is there to
05:56:28 <shapr> hmmm
05:56:33 <shapr> import IO didn't fix it
05:56:34 <dennisb> try catches an exception and transforms to an Either
05:58:12 <shapr> aha! import IO did fix the missing definition of 'try'
05:58:13 <dennisb> Try userError that creates an IOError from a string
05:58:39 <dennisb> I guess they just hid the implementation of UserError
05:59:24 <shapr> I'm down to missing these: [EOF,failWith,handle,IOError]
05:59:38 <dennisb> IOError should be solved bu using userError?
05:59:38 <shapr> ok, I'll replace the original UserError with userError
05:59:51 <dennisb> handle is probably catch
06:00:19 <shapr> cool, userError works
06:00:56 <shapr> excellent!
06:01:01 <shapr> now just failWith and EOF
06:01:23 <dennisb> failWith = ioError
06:01:35 <shapr> ok, will do
06:02:13 <shapr> awesome :)
06:02:16 <shapr> only EOF is missing
06:02:41 <dennisb> isEOFError
06:02:55 <shapr> ok, will try
06:02:55 <dennisb> isEOFError :: IOError -> Bool
06:02:58 <xbill> I should send my Hawk diffs to Koen Classen
06:03:04 <dennisb> could probably be used instead
06:03:07 <shapr> yah, send 'em :)
06:03:27 <shapr> If I can get this working, I'll post my version
06:03:32 <xbill> just makes it compile with ghc5
06:03:40 <shapr> and mention it on one of the haskell lists
06:03:46 <shapr> xbill: sounds worthwhile to me
06:04:36 <shapr> hrm, now that all the names exist, it gives scary compile errors
06:04:52 <xbill> ghc dumped core?
06:04:55 <dennisb> Hmm, type errors?
06:04:59 <shapr> nah, just complaining
06:05:07 <dennisb> You cant just throw in isEOFError instead of EOF
06:05:14 <shapr> oh?
06:05:17 <dennisb> case err of
06:05:17 <dennisb>                   EOF -> return ()
06:05:17 <dennisb>                   _ -> dieHorribly
06:05:32 <dennisb> if isEOFError err then return () else dieHorribly
06:06:40 <dennisb> Once again it looks like they hid the implementation (that is the actual constructor)
06:07:22 <shapr> Here's what I have at the moment: http://kungens.kemi.fi/~shae/Hsh2.hs
06:07:27 <dennisb> Then I would transform the whole file to use the do-notation also, just to make it look nicer
06:08:21 <shapr> since I only vaguely understand do notation, I'll have to read up on it.
06:11:44 * shapr includes the isEOFError change in the online version
06:13:56 <dennisb> It compiles with just some more changes
06:14:04 <dennisb> myStdin = intToFd 16 :: Fd
06:14:04 <dennisb> myStdout = intToFd 17 :: Fd
06:14:04 <dennisb> myStderr = intToFd 18 :: Fd
06:14:20 <xbill> it already compiles for me too
06:14:24 <shapr> ohhh
06:14:31 <dennisb> and on line 130 something:  try (openFd x ReadOnly Nothing (OpenFileFlags False False False False False))
06:15:05 <dennisb> but if it works is another thing :-) but why shouldn't it...
06:15:13 <xbill> it works
06:15:55 <dennisb> yes, it does
06:16:08 <shapr> xbill: no dcc in this elisp irc client, sorry
06:16:18 <shapr> email to shae@webwitches.com ?
06:16:48 <xbill> this code is a wreck
06:17:05 <shapr> so part of my learning project is to clean it up :)
06:17:08 <dennisb> shapr: http://www.zigo.dhs.org/~dennis/Hsh2.hs
06:17:39 * shapr bounces merrily
06:17:44 <shapr> wow! this is cooool!
06:18:14 <shapr> awesome :)
06:18:32 <dennisb> yes, it's fun
06:19:16 <shapr> ok, so your suggested changes are to change it to do notation, anything else?
06:19:36 <xbill> cmdline editing =)
06:19:41 <dennisb> well, I don't think the code looks that bad
06:19:52 * shapr envisions readline.hs
06:20:22 <xbill> ew
06:20:22 <dennisb> readline is already there to use in ghc
06:20:32 <xbill> readline blows
06:20:45 <xbill> zsh-style cmdline editing would be nicer =)
06:20:51 <shapr> this is very cool! thanks for the help!
06:20:51 * shapr bounces
06:20:51 <shapr> ok, first do notation
06:21:14 <shapr> hm, I don't know how that works, but I'll look it up.
06:21:21 <dennisb> do notation is just some syntactic suger for >>= and >>
06:22:07 <dennisb> instead of chaining commands with cmd1 >> cmd2 you can use do { cmd1; cmd2 }
06:22:12 <dennisb> or rather
06:22:14 <dennisb> do cmd1
06:22:17 <dennisb>    cmd2
06:22:25 <shapr> hm
06:23:02 <shapr> sounds simple enough
06:23:16 <dennisb> and if it says "cmd1 >>= \ x -> cmd2" you write "do { x <- cmd1; cmd2 }"
06:23:44 <dennisb> it's just simple suger, but I think it's important with suger
06:23:52 <shapr> looks vaguely similar to list comps
06:24:14 <shapr> cool, I'll fix it :)
06:24:17 <dennisb> yes, but you don't want to use the {;} version
06:24:31 <dennisb> use indentation instead
06:25:10 <dennisb> but it really is just a syntactic thing, you can define your own >>= operator and use the do-notation on that one
06:25:11 <shapr> ok, I'll see if "Craft.." talks about it
06:28:45 <shapr> aha, page 387... do notation
06:28:51 <dennisb> good
06:29:03 <dennisb> I don't have that book, but it's good they say
06:29:18 <shapr> it is
06:30:19 <shapr> lots of nifty stuff in it
06:30:35 <shapr> I was unable to teach myself Haskell from the online docs, but from this book, I can do it.
06:31:03 <shapr> and the #haskell channel helps a lot as well :)
07:08:22 <nephrael> shapr: ok i almost have the C->Java interface domne !
07:08:31 <shapr> cool :)
07:08:58 * shapr continues exploring do notation
07:09:19 <shapr> replacing "cmd1 >> cmd2" is easy enough
07:09:26 <nephrael> so i leave it up to you guys to make the Haskell->C
07:09:45 <shapr> but I'm still trying to figure out exactly how to do "cmd1 >>= cmd2"
07:10:18 <nephrael> i am not good at haskell yet.. its just the next lasnguage i will learn
07:10:33 <shapr> I'm going for mercury after Haskell
07:11:05 <nephrael> i been working with EcLipSE .. i am not sure mercury will offer anything over it
07:11:30 <shapr> isn't EcLipSE an ide?
07:11:45 <nephrael> its a versitile CLP system
07:11:58 <shapr> command line parsing? :)
07:11:58 <nephrael> 1/2 prolog 1/2 its opwn thing
07:12:08 <nephrael> Constraint Logic Programming 
07:12:24 <shapr> ah
07:12:54 <nephrael> I wouldn't know what to do with Mercury except Constraint Logic Programming
07:13:15 <nephrael> so i kinda see then in paralell
07:13:37 <nephrael> but i dont know that much about mercury yet
07:13:39 <dennisb> shapr: it's easy with >>= also
07:13:39 <shapr> I know almost zero about logic programming, and the same for CLP
07:15:33 <shapr> I'm off to a social at the moment, the latest is up as http://kungens.kemi.fi/~shae/Hsh3.hs
07:15:48 <dennisb> on the right hand side of >>= you have a function, something like \x -> ...
07:16:19 <dennisb> with do the binding is:
07:16:24 <dennisb> do x <- cmd1
07:16:26 <dennisb>    cmd2
07:16:34 <dennisb> and in cmd2 you can use x
07:16:43 <shapr> oh
07:16:46 <shapr> wild
07:16:53 <dennisb> it's the same as cmd1 >>= \x -> cmd2
07:17:06 <shapr> I'll think about that :)
07:17:15 <shapr> oh!
07:17:16 <shapr> I get it!
07:17:45 <shapr> well, I'll be back tonite hopefully
07:17:45 <dennisb> the compiler transforms the do-notation to >>= and compiles the as usual
07:18:02 <shapr> thanks for the info :)
07:18:16 * shapr goes off to a party
18:04:58 <fscked> hi all, anyone awake? :)
18:06:00 <xbill> just fscking around
18:06:08 <fscked> heh
18:06:49 <fscked> well, i've got a kind of trouble around here.. it's like with all this new year/xmas stuff I'm hitting the deadline for an assignment
18:06:53 <fscked> it's to write a minesweeper game in haskell
18:07:07 <fscked> I was wondering if by any wicked chance
18:07:19 <fscked> one of you could provide with code for that, or at least a good pointer to it
