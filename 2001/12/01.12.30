03:19:16 --- topic: 'spooky. quiet. | we be loggin' http://tunes.org/~nef/logs/haskell/'
03:19:16 --- topic: set by shapr on [Wed Dec 19 05:04:11 2001]
03:19:16 --- names: list (clog dennisb shapr smklsmkl jlb pHa xbill sjanes71)
03:49:26 * shapr wakes up
05:58:22 * shapr fiddles with do notation
06:42:38 * shapr continues parroting the example given by dennisb
06:43:01 <shapr> some of this stuff I really don't know how to turn into do notation
06:43:38 <xbill> not that bad
06:43:45 <shapr> ?
06:43:51 <xbill> email again?
06:43:58 <shapr> sure!
06:43:58 <dennisb> shapr: hi
06:44:02 <shapr> hi dennisb!
06:44:10 <shapr> I've done some of the do notation stuff
06:44:13 <shapr> it's up as Hsh3.hs
06:44:23 <shapr> er http://kungens.kemi.fi/~shae/Hsh3.hs
06:44:25 <dennisb> what's the full adress
06:44:27 <dennisb> yes
06:45:04 <shapr> some of the functions like commandLoop and processCommand
06:45:11 <shapr> I'm really not sure how to change those
06:45:13 <dennisb> processCommand s =
06:45:13 <dennisb>     parseCommand s                              >>= \ words ->
06:45:13 <dennisb> parseRedire
06:45:22 <dennisb> (and more)
06:45:40 <dennisb> the first line becomes: words <- parseCommand a
06:45:54 <shapr> right
06:46:14 <dennisb> run "parseCommand a" and put result in "words"
06:46:25 <dennisb> then you run the next command on the next line
06:47:18 <shapr> ok
06:47:33 <dennisb> commandLoop is a little bit different since there he does not have a lambda-notation-function on the right hand side of >>=
06:48:42 <dennisb> there is a function, either that takes 3 arguments, but he gives it 2. So it really is a function on the right hand side of >>=, but not in the same format as the rest
06:49:27 <dennisb> you can ofcourse bind the result to a variable and explicity call either with this third argument, or you can just leave that (for now)
06:50:14 <shapr> processCommand s 
06:50:14 <shapr>     = do words <- parseCommand s
06:50:14 <shapr> 	 do (inFile, outFile, words) <- parseRedirection words
06:50:14 <shapr> 	    performRedirections inFile outFile
06:50:18 <shapr> does that look sane so far?
06:50:28 <shapr> er, the tabs are being pasted wrong :(
06:50:46 <shapr> the second do should be indented to 'words' on the line above
06:50:49 <dennisb> yes, but just one do
06:50:57 <shapr> ?
06:51:06 <dennisb> wait, i'll show
06:51:09 <shapr> ok
06:52:06 <dennisb> http://www.zigo.dhs.org/~dennis/Hsh3.hs
06:52:18 <dennisb> I changed the three first lines of processCommand
06:53:39 <shapr> ooooohhh
06:53:40 <shapr> I get it!
06:54:00 <shapr> putting 'do' at the beginning of the function is like saying "the rest of this function is flowing the other direction"
06:54:01 <dennisb> yes, it's not really anything hard about it
06:54:14 <shapr> once you've gotten there ;)
06:54:31 <dennisb> puting the do is like saying, transform these things to >>= before you compile
06:54:53 <shapr> but I thought do only worked for the next line
06:55:03 <shapr> so I expected nested do statements
06:55:37 <dennisb> exacytly how it works depends on how the >>= works, you can make strange definitions of >>= to run the commands in reverse or do any kind of cool stuff
06:56:03 <shapr> my haskell-fu is not advanced enough to even consider such things
06:56:07 <shapr> I'm still a white-belt
06:56:21 --- topic: set to 'spooky. quiet. | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo' by shapr
06:57:09 <shapr> one day, I will understand!!
06:57:56 <dennisb> i'm sure you will
06:58:08 <shapr> yah, I just gotta keep workin at it
06:58:11 <shapr> how long did it take you?
06:58:27 <dennisb> it's hard to say, i'm still learning
06:58:51 <shapr> how long have you been learning Haskell?
06:59:15 <dennisb> 4 years maybe
06:59:18 <shapr> oh
06:59:18 <shapr> wow
06:59:28 <shapr> do you actually make money with it?
06:59:38 <dennisb> no
06:59:50 <shapr> does anyone here make money with Haskell?
06:59:58 <shapr> I'd like to think of some way I can apply it at work
07:00:02 <shapr> but I haven't thought of anything yet
07:00:02 <dennisb> I'm not sure. But I know people that do
07:07:56 <shapr> Can you think of things that are done better or faster in Haskell over Java for example?
07:10:46 <dennisb> Actually, all kinds of advanced programs are done better in haskell
07:10:53 <shapr> like what?
07:11:06 <dennisb> especially if you want to experiment a lot with the code
07:11:16 <dennisb> embedded languages
07:11:49 <dennisb> a couple of weeks I saw a library to generate and handle dynamic webpages
07:12:11 <shapr> I'd like to play with HaXml
07:12:37 <shapr> so far it looks to me like haskell has a notation that can get more concise than Perl and yet still remain readable
07:13:13 <shapr> functional programming seems to allow the compiler to do more optimisation because you're asking for what you want, rather than telling how to do something
07:14:11 <dennisb> for the web-thing you write som haskellprogram and had something like do { txt <- text_entry; putString txt } and the system created the cgi-page, took care of everything and you just write programs like that, i'll look for an example
07:14:27 <shapr> oh, I'd like that
07:14:28 <dennisb> shapr: well, it's not that easy to optimise actually
07:14:59 <shapr> but the optimisation seems somewhat moved from the programmer to the compiler writer
07:15:10 <dennisb> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
07:15:19 <dennisb> some cool examples there
07:16:38 <dennisb> shapr: there is a lot left for the programmer also to get good speed, but you have a little less control then for example C, but on the other hand, the C programs are usually 10 times as big and buggy
07:19:51 <shapr> the tradeoff I see now is speed of development versus speed of execution
07:19:58 <shapr> I can write the same program in Python or in C
07:20:16 <dennisb> yes, you can always do that
07:20:39 <shapr> so far, Haskell seems to have the development speed of Python with the the execution speed of C
07:21:13 <dennisb> but some complex programs might not ever be written if you need to do a lot of experimentation in C that can take years
07:22:26 <dennisb> but you can always write every program in assembler and get something faster
07:22:36 <shapr> true enough
07:23:05 <shapr> currently at work I'm writing my programs in Jython and then porting them to Java
07:23:29 <dennisb> My experience is that programs in haskell have fewer bugs, but that might be because most people don't write haskell programs
07:23:34 <shapr> this gives the benefits of prototyping and still lets me evolve the prototype directly into the real app
07:23:37 <shapr> heh
07:23:37 <dennisb> but I think it would be true anyway
07:24:31 <dennisb> the biggest problem I have with haskell is that there is not enough bindings to other packages
07:24:42 <shapr> that's true
07:24:49 <shapr> and it's a pain to use the ones that exist
07:24:55 <dennisb> if you write in C you know that no matter what, things always work with C
07:24:56 <shapr> I really want to play with HOpenGL
07:25:04 <shapr> but it's too much trouble to build it myself
07:25:15 <shapr> I'd also like to get better gtk support in Haskell
07:25:25 <shapr> yah, C is the lowest common denominator
07:26:46 <dennisb> I'm planning to write a small program that uses gtk+2, and that can run in both windows and unix. I don't think I can use haskell for that even if I would like to..
07:28:52 <dennisb> (I have written parts of if that uses freetype, I wouldn't want to do that with haskell, it's to much work to create a binding first)
07:28:57 <shapr> hm
07:29:08 <shapr> so Haskell needs something like SWIG
07:29:23 <shapr> with SWIG it's *less* trouble to make a binding than to do it manually.
07:29:27 <dennisb> it needs more people that bind stuff :-)
07:29:55 <shapr> in that case
07:30:03 <shapr> the Haskell Tutorial project will help
07:30:12 <shapr> because I'm finding Haskell difficult to learn
07:30:30 <shapr> I suspect I would have given up in frustration already if it weren't for #haskell
07:30:31 <dennisb> there is a project to bind gtk+ that uses tools to parse the c header files to do great things
07:38:53 * shapr looks at WASH
07:39:43 <dennisb> the code doesn't look that readable maybe, bit it's advanced stuf going on there. The calculator looks fun
07:39:45 <shapr> btw, changing processCommand to do notation gives: Hsh3.hs:130: The last statement in a 'do' construct must be an expression
07:39:59 <dennisb> probably somthing about indention??
07:40:34 <dennisb> the items in the do-construct must be indented at the same level
07:41:02 * shapr tries that
07:41:31 <shapr> hmm
07:41:33 <shapr> nope
07:41:43 <dennisb> or show it and I can point on the error
07:41:58 <shapr> processCommand s = do
07:41:58 <shapr>     words <- parseCommand s
07:41:58 <shapr>     (inFile, outFile, words) <- parseRedirection words
07:41:58 <shapr>     performRedirections inFile outFile
07:41:58 <shapr>     let
07:41:58 <shapr>         cmd = head words
07:42:00 <shapr>         args = tail words
07:42:12 <dennisb> that's not all..
07:42:22 <shapr>     in
07:42:22 <shapr>         case builtin cmd of
07:42:22 <shapr> 	  Just f ->
07:42:22 <shapr> 	      do f args
07:42:22 <shapr> 		 fdClose stdInput
07:42:23 <shapr> 		 fdClose stdOutput
07:42:25 <shapr> 	  Nothing -> 
07:42:27 <shapr> 	      exec cmd args
07:42:45 <dennisb> should work if the indention is correct..
07:42:59 <dennisb> can you put it up as ex 4?
07:43:10 <shapr> sure
07:43:53 <shapr> ok, it's up
07:44:23 <shapr> http://kungens.kemi.fi/~shae/Hsh4.hs
07:44:29 <shapr> though I'm having trouble getting to it
07:44:54 <shapr> ah there it is
07:45:27 <dennisb> hmm, the let is a bit special in do also
07:45:33 <shapr> how so?
07:45:39 <dennisb> if one put the let in () then it works
07:46:06 <shapr> from beginning of let to the end of "exec cmd args" ?
07:46:13 <dennisb> yes
07:46:20 <dennisb> and indent the in so it's correct again
07:46:50 <shapr> wow, spiffy
07:47:08 <dennisb> http://www.zigo.dhs.org/~dennis/Hsh3.hs
07:47:22 <dennisb> I changed my copy to use the let in another way
07:47:29 <dennisb> (that only works in do-notation)
07:49:32 * shapr fails to understand
07:49:37 <shapr> I don't see a difference
07:49:56 <dennisb> hmm, didn't I put it up..
07:50:02 <shapr> whew :)
07:50:12 <dennisb> yes, the let does not have an in after
07:50:42 <dennisb> in a do-construct, when you do let, the in part is automatically the rest of the do-construct
07:51:20 <shapr> did you put it up?
07:51:23 <dennisb> yes
07:51:29 <dennisb> let cmd = head words
07:51:29 <dennisb>     let args = tail words
07:51:29 <dennisb>     case builtin cmd of
07:51:45 <dennisb> (as always the wrong idention here)
07:52:00 * shapr tries that
07:52:04 <dennisb> before there was one let, and then an in after
07:53:56 <shapr> wow, cool
07:54:00 <shapr> awesome
07:54:55 <dennisb> The translation is in the standard: http://www.haskell.org/onlinereport/exps.html#sect3.14
07:54:59 <dennisb> but it might be hard to read
07:57:07 <shapr> yah, I think it is
08:12:05 <shapr> your before and after examples worked better for me
08:21:21 <shapr> I should probably stick them into the tutorial
08:29:18 * shapr blows a fuse reading about the 'either' function
08:31:08 <dennisb> just look at the type and it's simple
08:31:29 <dennisb> You know about the Either type?
08:32:26 <shapr> nope, now looking
08:32:36 <dennisb> You know about Maybe?
08:33:03 <dennisb> data Either a b = Left a | Right b
08:33:17 <dennisb> it's just like maybe but you save data in both cases
08:37:33 <shapr> whoa, Schönfinkeling... what a name
08:54:24 <shapr> wow, I can't find Jim Mattson's email address at all.
08:56:54 <shapr> well, bbl
