00:08:37 <DocKlobi> dsal: now I am scared again
00:10:50 <Axman6> :t sans
00:10:52 <lambdabot> At m => Index m -> m -> m
00:11:41 <Axman6> :t foldM (. sans)
00:11:43 <lambdabot> error:
00:11:44 <lambdabot>     â€¢ Occurs check: cannot construct the infinite type:
00:11:44 <lambdabot>         b ~ (m -> m) -> m1 b
00:11:48 <Axman6> :t foldMap (. sans)
00:11:50 <lambdabot> (Foldable t, Monoid c, At m) => t ((m -> m) -> c) -> Index m -> c
00:12:39 <Axman6> :t mconcat . map sans ["abc"]
00:12:41 <lambdabot> error:
00:12:41 <lambdabot>     â€¢ Couldn't match expected type â€˜a -> [c]â€™
00:12:41 <lambdabot>                   with actual type â€˜[m0 -> m0]â€™
00:13:13 <Axman6> :t mconcat . map (Endo . sans) ["abc"]
00:13:16 <lambdabot> error:
00:13:16 <lambdabot>     â€¢ Couldn't match expected type â€˜a -> [c]â€™
00:13:16 <lambdabot>                   with actual type â€˜[Endo a0]â€™
00:13:39 <p0a> Hello why can't I do something like (42 :: Int) :: Double and what are the alternatives?
00:15:08 <siraben> p0a:  When you do (42 :: Int), then 42 has type Int, which is not of type Double.
00:15:28 <siraben> p0a:  You could do  fromIntegral 42 :: Double
00:16:19 <monochrom> use fromIntegral for conversion.  ":: T" is neither "cast" nor conversion.  ":: T" is only clarification.
00:16:23 <p0a> siraben: what if I'm using a library?
00:16:25 <siraben> note that :: is not a function, but rather a type annotation, foo :: Bar tells Haskell "this expression foo has type Bar", which can be useful when there could be multiple correct types.
00:16:30 <siraben> p0a:  What do you mean?
00:16:38 <p0a> so I'm using hmatrix for example
00:16:49 <monochrom> also realToFrac
00:16:51 <p0a> it has R which stands for real 
00:16:52 <siraben> p0a:  Could you do a paste?
00:17:02 <monochrom> hmatrix's R is Double
00:17:31 <p0a> siraben: [vector ([i,j] :: [R]) | i <- [0..n], j <- [0..n]]
00:17:33 <siraben> Ah, looks like R is an alias for double
00:18:13 <p0a> vector takes an [R] to a "vector". I added the ::[R] in hopes it'd fix the issue. The real fix is to add 0..(n::R) (i.e. to take n to be R)
00:18:26 <monochrom> if n :: Int then i :: Int too.  use fromIntegral or realToFrac to convert to Double.  convert, not "cast". There is no "cast".
00:18:28 <p0a> Yeah, so R is an alias for double; but how would I know that? How would I know to convert from R to Int etc
00:18:51 <monochrom> By learning from the great monochrom
00:18:53 <siraben> right, because n doesn't have type R.
00:19:12 <monochrom> @quote monochrom Int.*Double
00:19:12 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
00:19:33 <monochrom> Also all good textbooks teach it.
00:19:38 <p0a> I would perhaps know to do that if I knew that R was Double
00:19:58 <monochrom> That's in hmatrix's doc.  (How else would I know?)
00:20:04 <siraben> p0a:  It can be helpful to lookup documentation: https://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/Numeric-LinearAlgebra-Data.html#t:R
00:20:04 <p0a> I am asking what does one usually do when confronted with such issues with a type from code they didn't write
00:20:17 <siraben> Also, typing :info R can help see how it's defined.
00:20:22 <monochrom> read the doc. look for conversion functions.
00:20:36 <monochrom> Above all, accept that there is no "cast".
00:20:43 <p0a> I'm cool with that mono
00:21:05 <p0a> I actually understand that subtlety :P
00:21:59 <siraben> Coercible has entered the chat
00:22:16 <monochrom> /kickban Coercible
00:23:00 <p0a> Okay but how do you know 
00:23:04 <p0a> that fromIntegral will work in the future?
00:23:18 <p0a> If the authors decide to redefine type R into something else
00:23:22 <monochrom> Study fromIntegral's type and a good book.
00:23:42 <monochrom> I think it's too late for them to change now.
00:23:57 <p0a> I guess sometimes I'm afraid that I may be looking at internals that I am not supposed to
00:24:22 <siraben> p0a:  Usually, "internals" will not be exposed at all to the module toplevel.
00:24:31 <p0a> ah
00:24:35 <monochrom> That is unnecessary paranoia when library authors also change externals at a whim all the time.
00:24:52 <p0a> unnecessary paranoia is my motto
00:25:31 <monochrom> carpe diem
00:25:52 <siraben> How is monochrom 's words being bolded, are you inserting unicode?
00:26:11 <siraben> s/is/are
00:26:15 <siraben> foo
00:26:30 <monochrom> No, it's most clients' convention that some control characters have font meanings.
00:26:43 <monochrom> It predates unicode.
00:26:52 <p0a> crashed irc clients too
00:26:53 <siraben> Ah I see. What client are you using?
00:26:56 <monochrom> There are colour codes too.
00:27:01 <monochrom> hexchat
00:27:19 <monochrom> But I think mirc was among the first to invent this convention.
00:27:31 <siraben> Interesting. Matrix bridge here, so Riot.
00:28:29 <p0a> Another hmatrix question 
00:28:35 <monochrom> Most library authors respect the PVP.  Watch version numbers to see whether or when they break compatibility.
00:28:40 <p0a> One thing I'm interested in is modular arithmetic 
00:28:53 <p0a> monochrom: yeah and in fact stack will guarantee I'm using the right version anyway
00:29:25 <p0a> I was overly paranoid but the answer came from siraben who explained the `toplevel' thing, i.e. whatever symbols are being exported (or w/e the terminology is)
00:29:34 <siraben> monochrom:  PVP?
00:29:59 <p0a> There's an example in hmatrix: (12*7 :: I ./. 15)
00:30:00 <maerwald> @hackage policeman
00:30:01 <lambdabot> http://hackage.haskell.org/package/policeman
00:30:40 <monochrom> https://pvp.haskell.org/
00:30:56 <siraben> Ah, package versioning policy, I thought it meant player vs. player, heh.
00:31:11 <p0a> What I'd like to do is define a vector of integers modulo 15, but I am not sure how to do that 
00:31:52 <siraben> p0a:  you could do vector [0..14], I think.
00:31:59 <siraben> with appropriate conversions as needed
00:32:18 <p0a> I think I would have to define the interface myself
00:32:37 <p0a> I think hmatrix offers finite fields. I can see that 12*7 :: I ./. 15 evaluates to 9 for example
00:33:05 <siraben> Oh, type level numbers?
00:33:16 * siraben has not used hmatrix
00:33:46 <p0a> Well maybe I can write the interface of modular arithmetic myself
00:35:18 <Axman6> it definitely alreeady has modular arithmetic
00:35:28 <p0a> I am having trouble using it Axman6 
00:35:42 <p0a> Do you know how to make vectors of mod n numbers for variable n?
00:36:09 <Axman6> what do you mean for variable n?
00:36:26 <Axman6> and what numbers do you eant in the vector?
00:37:04 <Axman6> like vector [1..10] :: Vector (Mod 23 Z) should work fine
00:37:31 <Axman6> assuming you have the correct language pragmas turned on. you haven't shared any code or error messages so we're more in the dark than you are in trying to help you
00:37:36 <siraben> they probably want vector [0..n-1] :: (Mod n z)
00:37:45 <p0a> I had to :set XDataKinds sure 
00:37:52 <siraben> Oops, Vector (Mod n z0
00:37:56 <p0a> now there's a clash between Chart's Vector and hmatrix's
00:38:12 <Axman6> then you'll need to import one of them qualified
00:38:18 <siraben> p0a:  You're importing both?
00:38:23 <p0a> I wrote Numeric.LinearAlgebra.Vector, does that work?
00:38:50 <Axman6> import qualified Data.Chart as Chart; ... foo :: Vector (Mod n Z) -> Chart.Vector Int64
00:38:52 <p0a> siraben: yeah I was hoping to use Chart as well; my expectations changed (due to the nature of the problem) and now I don't need it 
00:39:05 <siraben> import qualified Numeric.LinearAlgebra.Vector as LV
00:39:17 <siraben> then when you use a function from that package, put LV. in front of the na,e.
00:39:20 <siraben> name
00:39:42 <siraben> p0a:  ok, then you could remove the import.
00:39:47 <p0a> I get "Couldn't get type 'Dobule' with 'Mod 23 Z'" when I try your code Axman6 
00:39:53 <siraben> p0a: What's the program going to do/
00:40:12 <Axman6> my code doesn't mention Double so that's not the error you got
00:40:16 <p0a> siraben: Basically some computations on a graph that "loops around" in more than one way
00:40:33 <Axman6> p0a: just. share. some. code. and. the. errors. please
00:40:39 <p0a> okay
00:41:07 <p0a> https://pastebin.com/ed5hv86b
00:41:29 <p0a> siraben: I need modular arithmetic and even embeddings Z_m -> Z_n for m < n
00:43:05 <Axman6> well it has Integral so you can convert between mduluses
00:43:11 <Axman6> anyway, I have to go . good luck
00:43:27 <p0a> thank you Axman6 
00:43:47 <siraben> Hm, I'm not a hmatrix expert.
00:48:53 <p0a> no worrie s
01:01:03 <jchia> What exactly do people mean when they talk about packages that are "locally installed"? E.g. which directories are involved in "locally installed"? https://github.com/bgamari/hoogle-index
01:02:22 <jchia> And then there are other magical tools like haddock and hoogle. I can't tell from a simple reading of the introductory documentation what magic directory paths or environment variables are important. Is there a place where these things are explained?
01:02:46 <jchia> These tools read and write special files somewhere. I can't tell how they decide where.
01:02:48 <p0a> use `stack path'
01:03:04 <p0a> to see where the docs are you can use `stack path --local-doc-root'
01:03:26 <jchia> p0o: Thanks. I'll start looking from there.
01:08:29 <opqdonut> I just read docs (haddocks) on the web
01:08:46 <maerwald> requires a web browser
01:09:49 <merijn> opqdonut: I do too, but mostly because v2-build doesn't really have a convenient way to access docs yet. In the past I used local docs a lot, because then you're sure the docs match the version you're building with
01:10:19 <maerwald> there's no IDE tool that works correctly with online docs
01:10:52 <merijn> maerwald: Is there one that works correctly with offline docs, then? ;)
01:11:07 <maerwald> I didn't say that :P
01:11:13 <maerwald> But yeah, ish
01:11:33 <merijn> To be fair, ghcide works pretty good for all my simple stuff, just not for the stuff I need it most for yet xD
01:12:05 <maerwald> Most tools don't scale on larger codebases. The standard tools should test themselves against should be the GHC codebase
01:13:41 <jchia> I'm trying to generate local docs to use on a web browser. That's why I'm now trying to understand magic directories used by haddock, hoogle, etc.
01:14:31 <merijn> maerwald: mpickering is dogfooding ghcide on GHC, I think
01:15:05 <merijn> jchia: Generating local docs is easy (with cabal-install), the tricky bit is finding where it left them xD
01:15:28 <jchia> merijn: Does that include both the document generation (haddock) and index generation (hoogle)?
01:15:44 <jchia> I mean local docs for libraries I'm interested in using.
01:16:05 <jchia> Because Internet is sometimes slow or broken.
01:16:17 <merijn> jchia: Those two things are independent. But iirc there's also a flag to generate hoogle output in cabal-install, but I don't remember how to feed those into your local hoogle database
01:16:50 <jchia> merijn: hoogle requires special .txt files. I thought haddock generates those. Am I mistaken?
01:17:28 <merijn> jchia: If you open ~/.cabal/config there's fields in there for "documentation" (which ensures haddock gets called) and the haddock section has a "hoogle" field
01:18:04 <merijn> jchia: I know the "documentation: True" is all you need to generate docs and I think simply setting "hoogle: True" gets you the right text files for Hoogle
01:18:22 <merijn> The next steps are figuring out: 1) where does v2-build leave these? and 2) how to feed the files to hoogle
01:18:26 <jchia> merijn: I see a haddock section with a hoogle item. I wonder if it means something I'm looking for.
01:18:37 <jchia> OK
01:18:40 <jchia> strace
01:18:43 <jchia> maybe
01:18:58 <jchia> it's a rabbit hole
01:19:04 <merijn> jchia: I'd start looking in ~/.cabal/store/ghc-x.y.z/
01:19:15 <merijn> I suspect they get put in the relevant library dir
01:20:36 <jchia> Don't hoogle indexes end with '.hoo'? Shouldn't they be easy to find?
01:20:58 <merijn> No clue, you're on your own from here ;)
01:21:52 <jchia> merijn: Do you know the magic cabal incantation for generating the docs?
01:22:40 <merijn> jchia: If you set "documentation: True" it should do that whenever you run "cabal build"
01:22:57 <jchia> OK, I'll try that for a start.
01:23:33 <merijn> jchia: There's also "cabal haddock --haddock-for-hackage" which builds a docs tarball intended to upload to hackage, but that's not very useful for local ;)
01:23:50 <merijn> jchia: But presumably the help for "cabal haddock" should help
01:24:11 <jchia> Is there a tool to simplify/cleanup cabal project files? I'm trying to migrate from stack to cabal and there are autogenerated .cabal files that I want to clean up. I'm in the process of migrating from stack to cabal and I probably should do that first.
01:25:00 <maerwald> jchia: what?
01:25:08 <merijn> jchia: Terminology nitpick: cabal project files and .cabal files are rather different things and probably don't wanna mix up those terms :)
01:25:09 <maerwald> why would you deleted them
01:25:36 <merijn> maerwald: I think he means clean up the autogenerated fields in the cabal files
01:25:38 <jchia> package.yaml -> ___.cabal
01:25:46 <maerwald> yes, you need that .cabal file
01:25:56 <merijn> maerwald: He's not talking about deleting them
01:26:09 <jchia> there's a tool called hpack that does the conversion. i want to cleanup the .cabal files it generates
01:26:12 <maerwald> Ok, then I have no idea what clean up means
01:26:14 <merijn> maerwald: He's talking about deleting the hpack junk in them
01:26:16 <jchia> make them easier to read
01:26:38 <jchia> e.g. factor out common parts that can become global
01:26:51 <maerwald> global?
01:26:52 <jchia> or whatever else to make it nicer to read
01:27:00 <maerwald> you mean common stanza?
01:27:03 <jchia> yes
01:27:18 <merijn> jchia: You can't really share things across multiple cabal files (although you can deduplicate things within a single cabal file)
01:27:25 <maerwald> https://github.com/phadej/cabal-fmt might be a start
01:28:10 <merijn> jchia: Note that in v2-build there's cabal.project files so when you can "cabal project files" most people will assume you're referring to those
01:28:55 <maerwald> you can call .cabal "cabal package files" I guess
01:29:06 <jchia> merijn: So it's just cabal file, right?
01:29:08 <merijn> Yeah, although I'd just say "cabal file" :)
01:30:02 <merijn> jchia: The cabal docs have a reference on all the syntax and the different versions, see: https://cabal.readthedocs.io/en/latest/file-format-changelog.html
01:30:37 <merijn> jchia: Note that for common stanzas you need to use "cabal-version: 2.2" minimum
01:31:54 <jchia> merijn, maerwald: Thanks
01:33:19 <merijn> jchia: The v2-build intro is also a good thing to read https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:33:55 <merijn> (If you have cabal-install 3.0 or later v2- is the default for every command)
01:39:47 <jchia> OK
02:11:14 * hackage mollie-api-haskell 0.2.0.3 - Mollie API client for Haskell http://www.mollie.com  https://hackage.haskell.org/package/mollie-api-haskell-0.2.0.3 (matsrietdijk)
02:24:12 <gentauro> `stack` + `.cabal` files is such a horrible experience :(
02:24:40 <gentauro> I'm guess it's time to move back to `package.yaml` (I gave it a try though)
02:28:26 <Uniaika> gentauro: what do you mean by "horrible experience"?
02:31:06 <maerwald> gentauro: what do you use package.yaml for?
03:25:17 <DigitalKiwi> have you considered not using stack
03:30:06 <srk> or yaml!
03:30:22 <DanS_> https://www.irccloud.com/pastebin/v9oywSGw/
03:30:28 <DanS_> ^ looking for some guidance with some DataKinds - I'll try to post the code as it will quickly explain what I'm trying to do. Any pointers will be kindly appreciated! :)
03:48:44 * hackage ridley 0.3.1.4 - Quick metrics to grow your app strong.  https://hackage.haskell.org/package/ridley-0.3.1.4 (ChrisDornan)
04:01:45 <DanS_> is this the right channel to ask about this sort of thing?
04:12:28 <pgiarrusso> DanS_: yes right channel
04:15:31 <pgiarrusso> DanS_:  in your example, you might want to make `Universe` an injective type family to help type inference (not sure if it fixes the problem already) â€” can you also do that in your real code?
04:16:44 <pgiarrusso> I think the syntax is `type family Universe a = r | r -> a where`
04:20:10 <pgiarrusso> DanS_: here is a fixed version https://www.irccloud.com/pastebin/ROlwLN7Y/fixed.hs
04:21:13 <pgiarrusso> and next time, to help people answering, you might wat make the example actually self-contained ;-) it takes longer to make it self-contained it than to fix it
04:26:21 <pgiarrusso> the _other_ possible fix (if `Universe` is not injective) is to use explicit type application to help inference
04:26:29 <pgiarrusso> https://www.irccloud.com/pastebin/rVvRBI7Z/fixed2.hs
04:26:32 <pgiarrusso> DanS_: ^^
05:06:14 * hackage haskoin-store 0.21.7 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.21.7 (jprupp)
05:07:39 <DanS_> pgiarrusso: I don't think I can make it injective, because I want to define a mapping from Foo1 -> Bar1, and also from Foo1 -> Bar2. If I made it injective, then Foo1 could _only_ be mapped to a single Bar, from my understanding
05:08:13 <DanS_> > you might wat make the example actually self-contained
05:08:13 <DanS_> yep noted, sorry about the extra work! :)
05:08:16 <lambdabot>  error:
05:08:16 <lambdabot>      Variable not in scope:
05:08:16 <lambdabot>        you :: t0 -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> aerror:
05:10:43 <DanS_> is a type family even the right tool to use for the thing I'm trying to achieve? I'm cognizant that I might just be reaching for a more difficult tool than necessary as I'm unaware of others
05:19:35 <lyxia> What are you trying to achieve? That's not clear from your code.
05:49:25 <DanS_> I am trying to define things that have the same shape of data, but belong to different universes (so are incompatible directly at the type level), and a method to convert between things of different universes. Further, I'm trying to split the universes in two disjoint sets, such that you can only convert from (universe of type a) to (universe of type b), but not the other way
05:50:27 <DanS_> to be more specific, the universes are things like stock exchanges (think LSE, NYSE, NASDAQ) and brokers (google finance, yahoo finance etc), and the things are ticker symbols (text) for various stocks
05:51:42 <DanS_> for instance, the ticker "VOD" in LSE, or London Stock Exchange, would be identified in yahoo finance as "VOD.L" but in google finance as "LON:VOD"
05:52:07 <DanS_> I just want  a type safe way of declaring these mappings from real exchanges to APIs that i can query for these tickers
05:53:45 * hackage rattletrap 9.1.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.1.1 (fozworth)
05:57:36 <mniip> in a surprise to no one, my handwritten radix tree is an order of magnitude slower than Set
05:58:02 <merijn> mniip: 0wned :p
06:08:31 <merijn> What's the cheapest data structure to collect an (unknown, but bounded) number of values from N threads in a concurrent setting? "IORef (Set a)"? TVar? Something else?
06:11:57 <DanS_> pgiarrusso: tried the fix2.hs but it didn't like the type application. Should it work on ghc 8.6.5 or do I need 8.8? https://www.irccloud.com/pastebin/ITnAr9TC/
06:13:11 <pgiarrusso> DanS_: uh, I tried that on 8.8.3 so not sure
06:13:36 <DanS_> alright, I will try that too, thanks!
06:14:27 <pgiarrusso> DanS_: re "can't make injective" your reasoning makes sense to me; you can also just try what you describe and GHC will complain
06:39:20 <tomjaguarpaw> Is it just me or is `hashWithSalt salt (hashWithSalt s (0 :: Int)) == 0` very surprising (Data.Hashable)
06:40:25 <zincy_> tomjaguarpaw: How can hashing a 0 give a 0?
06:41:02 <zincy_> DanS_: Are you familiar with typefamilies and datakinds?
06:41:24 <tomjaguarpaw> Data.Hashable.hash (0 :: Int) == 0, which I find surprising.  What's even more surprising is that even if you have a salt then applying it twice preserves 0.
06:41:50 <zincy_> Interesting.
06:42:19 <zincy_> By the way it is Tom here. We had an email exchange a while back about masters and research careers etc. :)
06:42:26 <merijn> Why is that surprising?
06:42:46 <merijn> hash for Int is id
06:43:31 <zincy_> How can id be a hash function?
06:43:49 <merijn> zincy_: I think you're thinking of cryptographic hashes instead?
06:43:55 <zincy_> Yes I am :)
06:43:59 <merijn> Hashable is not a cryptographic hash
06:44:04 <merijn> It's for indexing into hashmaps
06:44:15 <merijn> So it just needs to map values to integers
06:44:21 <turion> That's my favourite Haskell fun fact for today
06:44:35 <merijn> Why bother wasting compute for Int if you already have one
06:44:41 <tomjaguarpaw> zincy_: Hi!
06:44:47 <zincy_> :D
06:45:04 <tomjaguarpaw> Surely for good hash map performance the hash should be pseudo-random?
06:45:13 <tomjaguarpaw> Otherwise collisions are much more likely.
06:45:38 <merijn> tomjaguarpaw: How can two integers collide without being the same?
06:45:40 <tomjaguarpaw> Admittedly I haven't thought about this very hard, but I am finding a lot of collisions in my particular usage.
06:45:58 <tomjaguarpaw> Well, it's not the Int instance that's the problem, but things derived from it
06:46:15 <merijn> That's a problem with those derived instances, then :)
06:46:41 <tomjaguarpaw> Perhaps
06:46:55 <merijn> cryptonite has a bunch of cryptographic hashes
06:47:10 <merijn> But, is obviously much more expensive to compute
06:47:12 <merijn> https://hackage.haskell.org/package/cryptonite-0.26/docs/Crypto-Hash.html
06:47:36 <merijn> And wants ByteString as input
06:48:00 <merijn> tomjaguarpaw: any derived instance should probably use hashWithSalt for subfields if those fields are integers
06:48:24 <tomjaguarpaw> Yes, but even hashWithSalt has the problem I described above
06:48:34 <merijn> What are you hashing for? HashMap access?
06:48:57 <tomjaguarpaw> No, for approximate eqeuality
06:48:59 <merijn> If yes: Have you considered simply not using a hashmap?
06:49:09 <merijn> hmm
07:11:17 <frdg> I think I at least somewhat understand how `pure` works but I don't understand why it is called "pure".
07:12:21 <tdammers> because on some level, monad/applicative/functor are used to represent effectful computations, a.k.a. "impure"
07:12:45 <tomjaguarpaw> merijn: This is what I'm talking about https://gist.github.com/tomjaguarpaw/db25dfde19ae97558ec6e6b46a139d5b
07:12:47 <tdammers> the "pure" function, then, takes a pure expression and lifts it into an "impure" computation
07:13:05 <frdg> tdammers: ok I understand thank you!
07:13:08 <tomjaguarpaw> I guess I'll have to look how the Generic instance for Hashable actually works and copy that.
07:13:11 <MarcelineVQ> and because noop (no op) looks weirder :>
07:13:43 <tdammers> it's a bit weird in that the name of the function states a fact about its argument, rather than being descriptive of the function itself, or its return value
07:13:45 * hackage push-notify-apn 0.1.2.0 - Send push notifications to mobile iOS devices  https://hackage.haskell.org/package/push-notify-apn-0.1.2.0 (hc)
07:14:08 <MarcelineVQ> lift is a fine name too, fitting into lift0,lift1,lift2 etc
07:14:23 <frdg> tdammers: thats actually a great way for me to think about it!
07:15:01 <tdammers> frdg: glad to help :)
07:18:19 <jophish> Yo tomjaguarpaw, how's things?\
07:18:53 <tomjaguarpaw> Hey jophish! Good, how are you?
07:19:01 <o1lo01ol1o> What options exist for "rendering" a literate haskell file to html?  
07:21:43 <reactormonk> Is there a function in Hedgehog to deterministically generate a value via `sample`?
07:22:52 <tomjaguarpaw> I see there is some subtlety in how to combine hashes, e.g. https://hackage.haskell.org/package/hashable-1.3.0.0/docs/src/Data.Hashable.Class.html#line-617
07:35:26 <jchia_> Is there a way to fold a Control.Foldl.Fold (foldl package) over a Streaming.Stream (streaming package)?
07:51:52 <infandum> I'm trying to install a package using nix. I'm running into an issue of "Encountered missing dependencies: ForestStructures ==0.0.0.*". I put that in my default.nix as   forestStructures = pkgs.haskellPackages.callHackage "ForestStructures" "0.0.0.2" {}; and put that into the callCabal2nix function, but I'm getting the same error. Any ideas?
07:51:52 <infandum>  
07:54:12 <jusss> what is unsafePerformIO? and when should I use it?
07:54:46 <kuribas> jusss: never
07:54:52 <infandum> jusss: It's a way to go from IO a -> a, and you should avoid it
07:55:05 <infandum> It's there for mostly debugging purposes I would assume
07:55:27 <kuribas> infandum: nah, you use Debug.Trace
07:55:28 <c_wraith> unsafePerformIO is exactly what its type says.  You should use it when it's correct to do so.  That's approximately "when using the FFI for pure operations" and "when doing weird internal stuff"
07:55:29 <lyxia> jchia_: that doesn't seem too hard to do by recursion
07:56:39 <jchia_> lyxia: Could you elaborate? E.g. what's the type signature of the recursive function?
07:56:59 <c_wraith> If you use unsafePerformIO incorrectly, you will break your program.  Sometimes in incredibly subtle ways like slow memory corruption
07:57:14 <c_wraith> In fact, if it crashes immediately, you got lucky.
07:58:01 <jusss> I don't like C....
07:58:18 <jusss> but it seems all FFI stuff are related to C or C++
07:58:32 <c_wraith> just C
07:58:45 <c_wraith> that's the only language the FFI interface speaks.
07:59:09 <jusss> but I saw there are some C++ .so
07:59:13 <c_wraith> Use with other languages requires an intermediate C layer
07:59:16 <jusss> in other languages
07:59:35 <jchia_> jusss: As an example, I have a read-only in-memory sqlite DB that I query with a function that returns IO something. I could use unsafePerformIO so that I can get query results while outside IO.
08:00:31 <jchia_> The function is IO because probably it calls into some C sqlite library.
08:01:59 <jusss> jchia_ is it easy to do FFI in haskell?
08:03:01 <mniip> hm
08:03:12 <mniip> if I intersperse my tree code with reallyUnsafePtrEquality checks
08:03:14 <jchia_> jusss: Not sure. What do you need to call into?
08:03:18 <mniip> am I losing deforestation opportunities
08:03:37 <oats> #haskellworldproblems: googling "brittany gadt" and being surprised when google tries to find you people named "Brittany Gadt"
08:04:14 <jchia_> oats: sometimes searching for haskell gets you haskell, TX
08:04:59 <jusss> jchia_ some C libraries about time, I need to write a timer to countdown
08:05:14 <DanS_> zincy_: I'm not entirely familiar with typefamilies, though I understand the concept behind datakinds as I had implemented a solution with a single universe before. Got stuck when trying to make a universe take two different "shapes" (the Foo and Bar in my case) and refer to all universes of each "shape" via a type, but also wanted a type I can use t orefer to all universes regardless of shape 
08:05:25 <[exa]> jusss: you can probably do better just with the haskell time functions
08:05:32 <int-e> o1lo01ol1o: so add "haskell" as a keyword, and hope no person by that names shows up
08:05:53 <oats> that is an awful nick and I love it
08:05:56 <jusss> [exa]: which one library?
08:06:00 <[exa]> jusss: (if your timer isn't totally exotic and would require specific C-style tools)
08:06:17 <int-e> . o O ( Brittany & Haskell Gadt, 25th wedding anniversary. )
08:06:31 <[exa]> jusss: see here https://hoogle.haskell.org/?hoogle=clock
08:06:41 <oats> incidentally, does brittany format GADT decls weirdly for anyone else?
08:06:46 <lyxia> jchia_: Fold a b -> Stream (Of a) m c -> m (b, c)
08:06:49 <oats> data Log m a where
08:06:51 <oats>   LogInfo ::String -> Log m ()
08:07:05 <int-e> Hmm, how old are GADTs, actually.
08:07:08 <[exa]> this is called "brittany format"? O_O
08:07:50 <lyxia> jchia_: I find using inspect would be easier for this but streamFold  would also work
08:08:10 <int-e> 1994?
08:13:02 <hexagoxel> oats: I think I have noticed that. We broke that when we introduced support for formatting data-decls, and did not have gadts in mind. I don't know if there is an issue in the tracker yet, one sec.
08:15:10 <jchia_> lyxia: I see, a replacement for fold that works on a Stream instead of a Foldable.
08:17:34 <jchia_> lyxia: streamFold's type signature looks as complicated as the one for Lens. Looks like a really general function that the other ones in the library can be built on.
08:18:39 <JoeCordingley> Hi I have some noob questions for Lens, but it would take a few steps to explain them. Is this the right forum for those?
08:19:47 <yushyin> sure
08:25:36 <oats> JoeCordingley: welcome :)
08:28:54 <JoeCordingley> thanks, I have been messing with creating lenses or fold1's for arbitrary data structures to see how I would use the tools to do tasks:
08:29:16 <JoeCordingley> lets say I have a data structure 
08:29:22 <JoeCordingley> data Three a = Three a a a 
08:29:54 <JoeCordingley> I can make a fold1 for it like this
08:29:56 <JoeCordingley> threeFold f (Three a b c) = Three <$> f a <.> f b <.> f c 
08:30:37 <JoeCordingley> and I can use that to do things like for a Three (a, b) give me the as for the max bs
08:30:43 <JoeCordingley> threeFold f (Three a b c) = Three <$> f a <.> f b <.> f c 
08:30:48 <JoeCordingley> oops
08:30:51 <JoeCordingley> maxKeys three = toListOf (threeFold . filtered hasMax . _1) three
08:30:51 <JoeCordingley>   where 
08:30:51 <JoeCordingley>     hasMax (_, b) = b == max
08:30:53 <JoeCordingley>     max = maximum1Of (threeFold . _2) three
08:31:35 <JoeCordingley> but if I wanted to make this code work for any data structure that's where I fall down
08:32:16 <JoeCordingley> maxKeys f three = toListOf (f . filtered hasMax . _1) three
08:32:16 <JoeCordingley>   where 
08:32:16 <JoeCordingley>     hasMax (_, b) = b == max
08:32:18 <JoeCordingley>     max = maximum1Of (f . _2) three
08:32:53 <JoeCordingley> this kind of thing the compiler can't find a valid type for f even though there must be one.
08:33:05 <JoeCordingley> as demonstrated above
08:36:33 <JoeCordingley> Is there a type signature for the above function that will be a valid type but still be general enough to work on many data structures?
08:38:03 <JoeCordingley> sorry type declaration I guess
08:43:27 <lyxia> maxKeys :: Fold s (a, b) -> s -> [a]    something along those lines
08:43:37 <compro> Hi there
08:44:11 <compro> How do I check if an object in haskell was contructed using a specific constructor?
08:44:39 <lyxia> JoeCordingley: the problem is that Fold uses a quantifier, functions whose arguments are polymorphic function must be explicitly annotated.
08:44:58 <compro> data Typ = Myint Integer | Myotherint Integer
08:45:21 <compro> How do I check if I used Myint or Myotherint to contruct an object of Typ?
08:46:49 <compro> So, what I want is a boolean expression that can do this task
08:48:14 <JoeCordingley> lyxia: does that mean i have to put 'forall's ?
08:48:20 <ptrcmd> compro: just pattern match it?
08:48:26 <lyxia> JoeCordingley: no they are hidden in Fold
08:49:11 <JoeCordingley> the reason I didn't think I had to is I don't technically use Fold anywhere
08:49:47 <JoeCordingley> Oh I suppose I do, when I use maximum1Of
08:50:57 <JoeCordingley> it's ok with it if bring in two arguments, f and g. I could do that I guess
08:51:20 <lyxia> that works too
08:51:52 <compro> ptrcmd, What I want to do is: `func x | x == Myint || x == Myotherint`.
08:52:06 <compro> In this case I would have to write two patterns
08:52:44 <compro> I know that isn't valid haskell. What I wan't is something similar to that
08:55:00 <JoeCordingley> compro: isn't that always true? But is this what you want?
08:55:12 <JoeCordingley> func Myint _ = true
08:55:12 <JoeCordingley> func Myotherint _ = true
08:55:16 <dumptruckman> Hey
08:56:01 <dumptruckman> Can someone explain to me how I do a conditional expression on an ArrowXml type?
08:56:10 <JoeCordingley> sorry, I got that wrong
08:56:23 <dumptruckman> I want to get one attribute value if it's not empty otherwise get a different one
08:56:32 <JoeCordingley> func (Myint _) = True
08:56:32 <JoeCordingley> func (Myotherint _) = True
08:57:56 <dumptruckman> I don't really understand how any of this arrow stuff works
08:57:56 <ptrcmd> compro: what JoeCordingley said. perhaps you oversimplified your problem?
08:58:03 <dumptruckman> and I just want to make a seemingly simple PR on this repo
08:58:05 <dumptruckman> https://pastebin.com/tWxDpPp9
08:58:17 <compro> JoeCording, I didn't make it clear enough. Let me try again.
08:58:19 <dumptruckman> what is the this \> doing?
08:58:30 <dumptruckman> er, this />
08:58:55 <compro> func x | (x == Myint || x == Myotherint) = (...)
08:59:23 <compro> The set in first parens wont work. What I want is something similar to that.
08:59:47 <dmwit> func Myint{} = ...
08:59:50 <dmwit> func Myotherint{} = ...
09:00:07 <dmwit> You don't have to like that this is the way to do it. But this is the way to do it.
09:00:31 <dmwit> (It has close neighbors, like `func (Myint _) = ...` instead of `func Myint{} = ...`. But they are morally identical.)
09:00:48 <compro> I want to execute the (...) body if x matches any of those. If I use pattern matching as you mentioned, the (...) body will be repeated.
09:00:57 <JoeCordingley> i would just extract the guard into a where to make the pattern matching possible and reference it in the guard. If you don't want to repeat yourself
09:01:05 <dmwit> compro: correct
09:01:28 <dmwit> Again: you don't have to like it, nobody can force you to do that.
09:02:05 <compro> My version of program has more number of constructors and I want to match only some of them.
09:02:19 * dmwit nods agreeably
09:02:34 <JoeCordingley> func x | isOneOfTheTwoTypes x = (..)
09:02:34 <JoeCordingley>   where
09:02:34 <JoeCordingley>     isOneOfTheTwoTypes (MyInt _) = True
09:02:36 <JoeCordingley>     isOneOfTheTwoTypes (Myotherint _) = True
09:02:52 <dmwit> Your other choice is to refactor your data type, to coalesce the constructors that behave the same.
09:02:53 <JoeCordingley> would that work?
09:03:06 <compro> That is good. But I thought there might be an easier way.
09:03:09 <dmwit> Yes, it would work. It is exactly what I suggested.
09:03:18 <compro> I mean simpler way
09:03:19 <JoeCordingley> sorry :D
09:03:51 <dumptruckman> What does this mean? />
09:04:07 <compro> Thanks for the help.
09:04:23 <dmwit> dumptruckman: It will be a library-defined function. You can find the source in the library you're hacking on (or maybe one of its dependencies).
09:04:45 <frdg> Im looking for summer classes and Ive found many different discreet math courses that seem to be teaching different things. Note that Ive completed Calc 2. Since you guys are all really good computer scientists, I'd like your insight into what I should be looking for in a math course. I would love to learn stuff I can directly apply to Haskell.
09:04:45 <compro> I am trying to write a simple expression parser. Any suggestions would be good.
09:05:27 <maerwald> frdg: you don't need any maths in haskell
09:05:37 <maerwald> unless the domain you're coding in requires so
09:06:16 <frdg> maerwald: the domain im interested in does require math I believe (security)
09:06:21 <maerwald> if you want to improve your theoretical knowledge, I think there are generally two options: category theory or type theory
09:06:27 <maerwald> frdg: partly yes
09:06:42 <maerwald> More cryptography than security. Security is very banal :)
09:07:22 <frdg> maerwald: ok thanks!
09:10:38 <amf> any recommendation on a library (even just "use bracket") for making writing daemons easier? i have to do some acquire/run/release like behavior
09:15:59 <hseg> two months of on and off struggle later, the code typechecks!
09:16:16 <hseg> now just need to make sure i didn't make any semantic errors
09:16:18 <amf> doh! i totally forgot resourcet exists, looks like thats what i want
09:21:10 <_d0t> ohai! Quick question. What the url for hackage db snapshots?
09:21:15 <_d0t> Can't find it anywhere :(
09:23:30 <_d0t> oh wait, gotit
09:23:32 <_d0t> nvm
09:24:00 <maerwald> _d0t: https://hackage.haskell.org/api
09:27:14 * hackage WEditorHyphen 0.1.0.4 - Language-specific hyphenation policies for WEditor.  https://hackage.haskell.org/package/WEditorHyphen-0.1.0.4 (ta0kira)
09:31:19 <_d0t> maerwald: thx, just googled it
09:31:35 <_d0t> is there a way to get index.tar.gz for a specific date?
09:34:05 <JoeCordingley> lyxia: thanks for your help before by the way!
09:35:51 <lyxia> JoeCordingley: you're welcome
09:38:28 <maerwald> _d0t: why
09:39:08 <maerwald> _d0t: the way this works is that the index knows which version was added at which date. When you tell cabal-install to freeze index state, it will ignore entries with later dates, it won't re-download a different tarball.
09:39:16 <_d0t> maerwald: I wanna create a nix derivation for hackage db, and I need a constant hash for this.
09:40:12 <maerwald> I think you'll have to host your own
09:40:36 <_d0t> maerwald: roger
09:45:37 <hexagoxel> oats: I have opened https://github.com/lspitzner/brittany/issues/298. Please report a separate issue if your problem does not fit.
09:46:35 <oats> oh, part of a bigger bug
09:46:50 <oats> hexagoxel: thanks! tiny thing though, don't want to cause too much fuss
09:47:21 <oats> oh, you're the main dev
09:47:25 <oats> thanks for such a lovely tool :)
09:47:41 <oats> it's nice not having to fret over formatting
09:50:13 <maerwald> hexagoxel: did you find the bug from my paste last time?
09:50:56 <hexagoxel> maerwald: the fix for that is not yet on master, but passed CI.
09:51:08 <maerwald> Cool, how is CPP support going :P
09:51:47 <hexagoxel> no further support of CPP is planned. Or possible.
09:52:20 <hexagoxel> and by "further" I mean the non-official support that is gated behind config.
09:54:27 <maerwald> What config
09:55:12 <maerwald> https://github.com/lspitzner/brittany/blob/fad9db8fd8b138c19a3bceb260bca0fd652a2b73/src/Language/Haskell/Brittany/Internal/Config/Types.hs#L330 ?
09:56:25 <hexagoxel> yeah, and https://github.com/lspitzner/brittany/blob/fad9db8fd8b138c19a3bceb260bca0fd652a2b73/src/Language/Haskell/Brittany/Internal/Config/Types.hs#L178
09:57:11 <hexagoxel> which makes it ignore `#include`s instead of choking on them, nothing more.
09:57:35 <maerwald> I still can't make it format a file with CPP: http://dpaste.com/2DA9QZF
10:02:14 * hackage cardano-transactions 1.0.0 - Library utilities for constructing and signing Cardano transactions.  https://hackage.haskell.org/package/cardano-transactions-1.0.0 (KtorZ)
10:04:32 <hexagoxel> maerwald: yeah, the macro is not defined. You can put a `#define MIN_VERSION_ghc(a,b,c) 1` in there and remove it afterwards.
10:04:50 <hexagoxel> and a `#define MIN_VERSION_ghc(a,b,c) 0`, run it one more time..
10:06:09 <sm[m]> excuse my naivete, but is there no haskell source formatter that will just do something useful on files containing CPP ?
10:06:17 <sm[m]> ie, real world haskell source ?
10:06:52 <sm[m]> I see the same limitation in ormolu's readme
10:11:10 <hexagoxel> I guess one could scan the input for `MIN_VERSION_([^(]+)` to capture the list of expected macro defs, for each one prepend the `#define` I had above, then (because the GHC API does not support running CPP on arbitary input) write that into a temp file, parse that via GHC API and pass the formatter frontend, remove the `#define`s, repeat for the inverted define, done
10:12:56 <maerwald> I wouldn't even mind if it skipped if-endif sections completely
10:13:09 <sm[m]> this obviously must be harder than I realise, but it seems bizarre to think any sign of CPP means it's ok to just give up 
10:13:27 <hexagoxel> that would make it work presuming that you only have #ifs on MIN_VERSIONs. It would do then #then and #else branches.
10:13:35 <sm[m]> probably like most folks, my CPP is very simple - #if #else #endif to support multiple GHC versions
10:13:59 <monochrom> No, I think it is more lack of interest than technical difficulty.
10:14:03 <maerwald> yeah, I have a few more complex if-else sections for features, but I don't mind formatting them manually
10:14:44 <maerwald> And, with a little effort, big if-else sections can be factored out into a file that delegates to another file
10:15:06 <hexagoxel> (the fact that the GHC API does not expose a CPP-capable parser that accepts an input Text instead of a file name is a technical difficulty, imo)
10:15:18 <hexagoxel> (you _can_ work around it, probably)
10:17:35 <dumptruckman> So, I'm trying to use this getAttrValue function to get the value of the "customName" attribute but if it doens't have that attribute, I want to return the value of the "name" attribute. Unfortunately, I have almost no idea what I'm doing or how to fix this. Can anyone help? https://pastebin.com/GhXg2eZH
10:19:15 <sm[m]> that aside, thank you for britanny hexagoxel - does that source link mean there's some command line flag in current release that I could use to ignore CPP ?
10:20:16 <sm[m]> also, does it not yet support GHC >8.6 ?
10:20:30 <hseg> why does newtype T a = T (F a) deriving newtype C not add a C (F a) constraint to the context?
10:21:21 <hseg> ... need to go, will reask later
10:22:00 <hexagoxel> sm[m]: yeh, it is high time I make a new release. Master supports 8.8
10:22:43 <dmwit> hseg: I guess it would add whatever the context for the C (F a) instance was (including, if that's the case, no context).
10:24:17 <hexagoxel> regarding CPP, unfortunately no. It can ignore some very specific CPP constructs, and only if you give brittany a path and not use stdin.
10:25:00 <sm[m]> how do I do that ?
10:28:30 <hexagoxel> sm[m]: what kind of CPP do you use?
10:29:27 <sm[m]> #if #else #endif to support multiple GHC versions
10:30:55 <hexagoxel> no, sorry, not yet supported
10:31:21 <sm[m]> ok, thanks
10:32:32 <hexagoxel> I got an idea though.. maybe passing the right `-D` flag to ghc and hardcoding a few often-branched-on macros would fix 90% of the cases where people run into CPP/formatting problems. I'll investigate this.
10:33:23 <sm[m]> ormolu docs do a good job of explaining why CPP support is problematic, but I still want a tool to 1. format the stuff not affected by CPP and 2. maybe attempt to format stuff affected by CPP, acknowledging that it may alter the meaning and it's my responsibility to review it and maybe mark it to be left alone next time
10:50:15 * hackage encoding 0.8.3 - A library for various character encodings  https://hackage.haskell.org/package/encoding-0.8.3 (swamp_agr)
11:10:45 * hackage contracheck-applicative 0.1.2 - Validation types/typeclass based on the contravariance.  https://hackage.haskell.org/package/contracheck-applicative-0.1.2 (Birkmann)
11:11:45 * hackage serialise-uuid 0.1 - Encode and decode UUID values in CBOR using uuid-types, cborg and serialise.  https://hackage.haskell.org/package/serialise-uuid-0.1 (RenzoCarbonara)
11:15:14 * hackage WEditor 0.2.1.1 - Generic text-editor logic for use with fixed-width fonts.  https://hackage.haskell.org/package/WEditor-0.2.1.1 (ta0kira)
11:27:09 <mniip> I did end up writing my own prefix tree that is more efficient than Set!
11:27:16 <mniip> observe https://gist.github.com/mniip/51f39b6f9d65e27ee3aa299b29030ad7
11:28:11 <Uniaika> mniip: sweet mother of god, just enable -XStrictData and be done with it :P
11:28:38 <Uniaika> (but yeah, good job!)
11:30:38 <[exa]> mniip: can this be generated by a bash script?
11:31:08 <[exa]> or any script
11:32:14 <mniip> it was generated semi-manually using a lot of vim tricks
11:32:32 <mniip> like sed and block copy/paste
11:32:48 <maerwald> Why not generate via TH?
11:33:44 <Uniaika> maerwald: portability? :D
11:33:49 <mniip> actually I wonder how it would compare to
11:33:57 <maerwald> Uniaika: what is that :)
11:34:32 <Uniaika> maerwald: :D
11:34:33 <mniip> data QSet = QTip | Q (# (# #) | QSet #) (# (# #) | QSet #) (# (# #) | QSet #) (# (# #) | QSet #)
11:34:49 <Uniaika> mniip: love the QTip consructor, btw
11:35:03 <mniip> coincidence
11:35:18 <monochrom> You've got to first prototype this and make sure this is right, before you can meaningfully THize it.
11:35:34 <mniip> quickcheck says OK 100 tests passed
11:35:36 <mniip> must be right
11:35:42 <mniip> :^)
11:35:51 <monochrom> I have no problem with that.
11:35:52 <maerwald> quickcheck...
11:36:17 <monochrom> I just mean, if you used TH from the onset, if you had a bug, it would be hard to find.
11:36:39 <maerwald> you can run quickcheck on the TH code at compile time
11:36:58 <monochrom> Yes I don't mean it is hard to know you have a bug somewhere.
11:37:19 <monochrom> It is hard to know what causes it, what mistake you made.
11:38:07 <mniip> I'm still spending 69% of the time in qUnion :/
11:38:11 <mniip> but at least it's faster now
11:38:14 <monochrom> And IME 90% chance the mistake is so fundamental you have to rewrite the own thing from a new angle.
11:39:10 <monochrom> Whereas if you hand-code the tedious long thing first, the whole thing is in plain sight to you, not hiding behind some black box generator.
11:39:59 <monochrom> After that, you now know what your TH should generate.  Not before.
11:40:44 <monochrom> Especially since TH is an order of magnitude more obfuscating than Scheme macros.
11:41:11 <maerwald> Sounds like you could write an interactive IDE that generates TH code, that generates haskell code...
11:42:04 <Uniaika> sounds like you should write a template engine that takes Scheme macros and outputs haskell!
11:42:59 <maerwald> and the template engine would be written in elisp?
11:43:10 <ChaiTRex> Sounds like you could write a TH function that writes Scheme macros that output Haskell.
11:43:29 <monochrom> sounds like a GHC plugin
11:43:35 <maerwald> lolo
11:44:11 <monochrom> Let's all combine our ideas together. The GHC plugin calls Scheme...
11:45:03 <mniip> who needs TH when you can generate haskell source text, load GHC as a library, and dynamically compile it
11:45:19 <Uniaika> maerwald: in Typed Racket :P
11:45:26 <Uniaika> or even Hackett
11:45:36 <Cale> mniip: That still doesn't let you reify
11:46:08 <Cale> mniip: Though I guess if you're going that far, you can load the modules that you would have reified, and inspect the results of the typechecker, which is possibly better.
11:46:49 <mniip> you wouldn't reify any declarations yes, but you can reify computationally meaningful content
11:46:59 <mniip> HValues and stuff
11:47:12 <Cale> The only thing I ever reify are data declarations for the most part
11:47:20 <monochrom> Please don't take it seriously! :)
11:47:24 <Cale> because all the TH I write generates instances :)
11:48:01 <Cale> (I might be missing a bunch of context in this conversation)
11:48:47 <monochrom> It all started with mniip's https://gist.github.com/mniip/51f39b6f9d65e27ee3aa299b29030ad7
11:49:10 <monochrom> So everyone was like how to automate this tedium chore.
11:49:47 <Cale> I really wish I had a way to ask GHC for the type of a context during TH.
11:49:49 <monochrom> Then it escalated to jokes.
11:50:01 <Cale> Or even just for the inferred type of an expression
11:53:06 <mniip> Cale, I have a TH type family solver
11:53:11 <mniip> that's like halfway there
11:55:56 <Cale> Yeah, a lot of the TH code I write boils down to reimplementing whatever fraction of the typechecker is required to decide what the constraints on my generated instance ought to be
12:18:37 <maerwald> How do I call my main function from ghci with "arguments"?
12:18:59 <solonarv> maerwald: use :main
12:19:11 <maerwald> Works
12:19:12 <solonarv> and then just put the args after it like you would at the shell
12:19:32 <maerwald> Never done that before, alway did cabal run :P
12:19:43 <maerwald> But it is a little faster this way
12:20:27 <dsal> I hope I someday get out of the level of lens where I can kind of use it, but I don't understand the magic.
12:20:46 <dsal> fetchVariantsSansURLs :: (HasGoProAuth m, MonadIO m) => MediumID -> m (Maybe Value)
12:20:46 <dsal> fetchVariantsSansURLs = fmap (_Just . deep  values . _Object %~ sans "url" . sans "head" . sans "heads" . sans "urls") . retrieve
12:21:21 <MarcelineVQ> :t sans
12:21:23 <lambdabot> At m => Index m -> m -> m
12:21:23 <dsal> Get the latest list of artifacts for the given medium, parse it as a JSON Value, then recursively remove all of the URLs from the structure.
12:21:31 <dsal> It's in .At
12:21:41 <dsal> It's "deep" that feels magical.
12:22:14 <maerwald> mhh, now I cabal repl'ed the executable, but :r doesn't rebuild when I change the library part
12:22:26 <dsal> The structure isn't uniform... there are like, three or four different types of structures returned.  This works with any of them.
12:24:47 <solonarv> maerwald: I think this is what ghcid is for.
12:24:57 <maerwald> solonarv: ?
12:25:04 <maerwald> I don't want to auto-reload anything
12:25:08 <dsal> ghcid == ghci &
12:25:13 <solonarv> ah, nevermind then
12:25:30 <maerwald> I want to do :r and then have it rebuild the library
12:25:32 <maerwald> but it doesn't
12:28:01 <maerwald> the only way is repling the library and then :l app/Main.hs manually, but then it can't find the Main.hs dependencies
12:28:09 <maerwald> Then I have to add a lot of --build-depends
12:28:12 <maerwald> quite unergonomic
12:29:10 <MarcelineVQ> too bad you can't pick two targets at once, afaik
12:29:16 <maerwald> Yeah, it refuses to
12:29:50 <monochrom> ghci cannot refresh its in-memory package db. you really have to restart it.
12:30:07 <monochrom> This affects some prospective use cases of GHC API as well.
12:30:25 <sm[m]> there's a package to make it do that actually
12:30:49 <sm[m]> (maybe ? it keeps some stuff in memory across reloads anyhow)
12:31:07 <monochrom> Ah, I think I vaguely remember that one.
12:31:15 <monochrom> Pretty cringy and fragile though.
12:32:20 <monochrom> as long as cabal/stack repl still just calls ghci, you're stuck with ghci limitations. wrappers cannot change intrinsic natures.
12:39:45 * hackage maquinitas-tidal 0.2.3 - library for MIDI control of hardware  https://hackage.haskell.org/package/maquinitas-tidal-0.2.3 (montoyamoraga)
12:51:48 <tdammers> dae find it disturbing that there are four tools whose names are prefixes of one another, but only two of them are actually closely related?
12:52:47 <merijn> ghci, ghcid, and ghcide?
12:52:52 <merijn> oh, ghc?
12:52:54 <tdammers> yeah
12:53:17 <tdammers> it's only a matter of time before someone comes up with ghcidefghij
12:53:24 <merijn> ghcide was initially called differently, but renamed because it was funny >.>
12:58:01 <daphnis> is there any reason why `cabal update` would say "Downloading ..." and then just hang?
12:58:54 <merijn> Are you behind a proxy?
12:59:02 <MarcelineVQ> hang or take a long time? the index is fairly large
12:59:35 <aveltras> i'd like to have a static files registry for a web application. This would use some type like the following: data StaticFiles files = StaticFiles [(Text, Text)], i'd like the "files" parameter to be a type level witness of the list content in order to be able to guarantee that some file exist but i don't know how to make this compile
12:59:42 <merijn> And did you ctrl-c a previous run?
13:00:08 <maerwald> daphnis: cabal uses curl or wget... if you can use curl and wget to download the tarball manually, then it should be fine
13:00:19 <aveltras> ideally, i would use a Symbol representing the file name to add some file in the registry at app initilization and then a type application / proxy with the symbol to access data about the file
13:01:47 <daphnis> maerwald: thanks
13:02:23 <maerwald> https://hackage.haskell.org/01-index.tar.gz
13:03:49 <aveltras> the usage would be lik the static function here https://github.com/obsidiansystems/obelisk/blob/master/skeleton/frontend/src/Frontend.hs#L30 but without template haskell machinery, if at all possible, any pointer here ?
13:07:23 <monochrom> I have already come up with "ghcicide" >:)
13:08:01 <merijn> aveltras: Sounds like a recipe for pain
13:08:03 <monochrom> j : java : javascript :: ghci : ghcid : ghcide
13:08:29 <hseg> trying to clean http://ix.io/2iZd up -- is there a way I can reduce the boilerplate?
13:09:41 <sm[m]> aveltras: file-embed ?
13:10:07 <hseg> ideally, would want to say sth like deriving via WrapUnit instance Unital (Sum a); deriving via (NonZero Q) instance Unital Q
13:10:27 <Tuplanolla> Are there any characters that are removed by Pandoc's `auto_identifiers` yet are still valid HTML?
13:10:42 <aveltras> i want to avoid th for this
13:11:34 <hseg> but if that is impossible, at least being able to make the Unit (Sum a) instances' derivation look like the Unit Q instances would be useful
13:11:58 <merijn> aveltras: How would that even work without TH?
13:12:09 <merijn> aveltras: you need to embed the file at compile time *somehow*
13:12:41 <merijn> You can use dirty linker tricks, which will probably be faster than using TH in terms of compilation time, but will make your life hard in lots of other fun ways :p
13:14:56 <aveltras> what i have in mind is that for example, the app would have a registry setup with symbols like '["style.css", "script.js", "sprite.svg"] for example. the main function would build this registry by applying a function on the registry with a symbol representing the filename, that function should look for the file in the filesystem and output a hashed named like "style.zqdqz7766.css" for example
13:14:57 <Tuplanolla> I guess you cannot use `id` at all in Pandoc templates, because they may clash with generated ones.
13:15:15 * hackage maquinitas-tidal 0.2.4 - library for MIDI control of hardware  https://hackage.haskell.org/package/maquinitas-tidal-0.2.4 (montoyamoraga)
13:15:42 <aveltras> i can then reference the "style.css" file just by its base name in the app but the registry knows the hashed name
13:16:07 <aveltras> the main function should fail if something's not ok (file absent or anything else)
13:16:24 <aveltras> the point of this is to just have to restart the server in case an asset changes
13:16:27 <aveltras> not recompiling
13:16:55 <aveltras> i could do this with a record with fixed accessors for each asset but i'd like to have a portable solution for this
13:17:57 <aveltras> my problem here is im not sure how to have type level witness for those symbols representing file names
13:18:05 <merijn> Just...you know, check for the presence of said files at the start of main?
13:19:11 <aveltras> yes but how can i get it anywhere in the app, i can do this with a map but i'd like type safety for this, the map has to unwrap the maybe given by lookup
13:19:45 <aveltras> i need more than the base filename, i need the hash to in order to update the public links
13:20:10 <aveltras> doing so, i can set unlimited max age for the headers
13:20:53 <aveltras> and the hash should be calculated in the main function
13:28:15 * hackage dobutokO2 0.34.0.0 - A program and a library to create experimental music from a file and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.34.0.0 (OleksandrZhabenko)
13:35:15 * hackage WEditorHyphen 0.1.0.5 - Language-specific hyphenation policies for WEditor.  https://hackage.haskell.org/package/WEditorHyphen-0.1.0.5 (ta0kira)
13:37:34 <hseg> ... why doesn't Prelude export a default ifThenElse for those using RebindableSyntax?
13:37:52 <hseg> usually, you only want to rebind part of the syntax
13:38:16 <hseg> and i don't think i've had a situation yet where i'd want to rebind the if statement
14:16:26 <buggymcbugfix> Any opinions on shell scripting libraries? shelly and turtle seem decent options.
14:18:08 <buggymcbugfix> But ssh also looks interesting
14:19:08 <dsal> shell scripting?
14:19:12 <dsal> You can use the shell.
14:19:56 <Uniaika> buggymcbugfix: try 'em out! :D
14:19:56 <CptCaptain> Is there an alternative to the unmaintained http-proxy? I want a library to implement a simple forward proxy where I can do stuff on the data in transit
14:26:35 <CptCaptain> Haxy is also unmaintained
14:31:18 <maerwald> buggymcbugfix: I wouldn't bother
14:31:26 <maerwald> so yeah, just use the real shell
14:31:30 <maerwald> Or do proper haskell :P
14:31:45 * hackage git-brunch 1.3.1.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.3.1.0 (andys8)
14:33:21 <maerwald> if you wanna invoke processes etc, check the process package. Although I don't like it, it's the standard: https://hackage.haskell.org/package/process-1.6.8.2/docs/System-Process.html#v:shell
14:34:24 <maerwald> (look at all those "on windows, this does something else" comments)
14:35:24 <buggymcbugfix> maerwald: yeah, I'm not a fan of process
14:35:38 <maerwald> Well, then go full unix!
14:36:00 <maerwald> Windows users will be sad, but I think they're sad anyway
14:38:52 <buggymcbugfix> better off using Python than bash imho
14:39:01 <sm[m]> I like the cmd library that's part of shake. But it comes with shake.
14:39:16 <maerwald> sm[m]: yes, not too bad
14:40:18 <maerwald> buggymcbugfix: well, not that much more portable than bash imo
14:40:24 <maerwald> a little though
15:58:30 <freeman42x[m]> this should be of interest to a lot of people, so sharing here - streaming about why learning Haskell is a very good idea: https://twitter.com/razvan_panda/status/1252701767256748033
16:04:21 <wroathe> look mom, I'm on TV
16:25:27 <koz_> wroathe: _Twitch_.TV at that.
16:25:43 * Uniaika twitches
16:26:44 <DigitalKiwi> quick get a spoon! Uniaika is having a seizure
16:29:14 * MarcelineVQ eats Uniaika?
16:32:21 <Uniaika> :D
16:32:31 <Uniaika> (not into vore but I appreciate the attention)
16:32:58 <Uniaika> MarcelineVQ: how are you, btw?
16:33:20 * MarcelineVQ drops spoon
16:39:18 <MarcelineVQ> never knew how to answer that one :> the wheel turns
16:43:09 <DigitalKiwi> https://xkcd.com/222/
16:44:17 <Uniaika> :D
16:49:38 <evelyn> that cartoon is stupid, sometimes people do actually care about how someone has been whether it's good or bad
16:50:31 <DigitalKiwi> it's a cartoon don't think too much into it
16:50:39 <slack1256> take the gist of it
16:51:06 <DigitalKiwi> can't github is down
16:51:21 <slack1256> Slower... not down
16:51:23 <wroathe> MarcelineVQ: the wheel weaves as the wheel wills
16:51:39 <slack1256> But if this continues, people are gonna take notice they can use git without github... what a wild concept!
16:51:53 <wroathe> slack1256: I don't believe you
16:52:10 <DigitalKiwi> saw earlier "github is down send patches via email" or something along that lines
16:52:45 <MarcelineVQ> gist at least isn't down
16:53:07 <slack1256> Yeah, it imposible to use git without github, I mean sending patchset via emails? what am I? a Finnish student on minix?
16:53:54 <Uniaika> yeah, western US has had quite the fibercut
16:54:38 <monochrom> What are you? 24601!
16:55:03 <MarcelineVQ> did you just assume my number
16:55:36 <slack1256> signs are social constructs
16:55:39 <monochrom> "Let them have gitlab" :)
16:56:01 <hpc> rcs 4 life
16:56:11 <monochrom> sccs
16:56:21 <Uniaika> source code in dropbox foreva
16:56:35 <Uniaika> (don't laugh, a friend of mine told me his former company used that)
16:56:50 <slack1256> *-final , *-final-final , *-final-forreal 
16:57:11 <justsomeguy> Ever tried fossil-scm? It's actually good. Like git, but has a built in tiny web server and wiki.
16:57:43 <justsomeguy> It does discourage rebasing, though, which I'm not sure how to feel about.
16:57:43 <monochrom> um please don't ruin our jokes by providing real information :)
16:57:57 <justsomeguy> lol, sorry
16:58:49 <monochrom> nice
16:59:04 <MarcelineVQ> now you get your yellow ticket of leave
17:00:55 <hpc> i am not really a fan of rebasing either, merging is the way to go
17:02:03 <hpc> darcs' whole thing was having a really good merging algorithm
17:02:35 <Uniaika> I prefer rebasing
17:02:41 <Uniaika> (in git)
17:02:54 <maerwald> rebasing is amazing
17:03:07 <maerwald> But only your own changes, lol
17:03:09 <Uniaika> (I have no opinion about other source-code versioning software)
17:03:56 <hpc> Uniaika: http://bensbargains.net/thecheckout/wp-content/uploads/2013/06/neutral-futurama-propaganda-poster.jpg
17:04:22 <slack1256> Without rebase, how can do you make readable patchsets? I can't make them at first try.
17:12:19 <Uniaika> hpc: :D
17:16:59 <DigitalKiwi> justsomeguy: that's the one for sqlite ?
17:17:48 <jchia_> What does it mean when cabal says "constraint from project config TODO requires" as an explanation for why package version constraints cannot be satisfied? What is a "project config TODO"?
17:18:21 <justsomeguy> DigitalKiwi: Yeah, that's the one. fossil-scm.org
17:25:00 <maerwald> jchia_: do you hve a freeze file?
17:26:09 <jchia_> maerwald: yes, but i get a similar error from running both cabal build and cabal freeze
17:26:18 <maerwald> delete the freeze file
17:26:32 <maerwald> then run cabal freeze again
17:27:43 <jchia_> maerwald: OK, now the error message is different. thanks
17:50:27 <pie_[bnc]> random questoin, is graph reduction equivalent to evaluation with memoization?
17:50:40 <pie_[bnc]> (might have to be lazy or strict evaluation with memoization, idk)
17:58:17 <solonarv> pie_[bnc]: some specific form of graph reduction, yes (after all that is how GHC Haskell is evaluated); I don't know whether this extends to more forms of graph reduction
18:03:01 <pie_[bnc]> solonarv: ok thanks
18:04:10 <pie_[bnc]> ok one more, is it not more correct to say hashes are fast inequality checks as opposed to fast equality checks?
18:04:42 <solonarv> the thing GHC uses is called "spineless tagless G-machine", or STG for short - please don't ask me to explain it, I remember very little besides the name
18:04:57 <solonarv> hm, yes, you could talk about hashes that way
18:05:07 <pie_[bnc]> hehe
18:05:36 <pie_[bnc]> though statistically theyre an equality check so maye its pointless to need to diverge a subthread on why you are saying what youre saying
18:05:49 <pie_[bnc]> s/you are/one is/
18:14:40 <jchia> Why does hackage show the latest version of base to be 4.12.0.0 when there is 4.13.0. already? https://hackage.haskell.org/package/base
18:15:40 <solonarv> there is even 4.14, in fact
18:15:57 <solonarv> I think there are some issues that prevent it from being uploaded to hackage
18:16:43 <solonarv> don t remember exactly what they are, people in #hackage can probably answer you
18:18:19 <jchia> Is a particular version of GHC married to a particular version of base?
18:18:53 <jchia> I'm not sure because I see cabal freeze saying it's rejecting different versions of base as if there are actually multiple options.
18:19:49 <jchia> E.g. ghc-8.10.1 comes with base-4.14.0.0 but can it be used with base-4.13?
18:20:42 <sm[m]> jchia, no they are married
18:21:15 <sm[m]> see eg https://www.fosskers.ca/en/blog/base#orgafee86
18:21:49 <sm[m]> or https://wiki.haskell.org/Base_package#Versions when you forget the above
18:22:47 <jchia> It appears my cabal is being confused by the hackage base version problem because it's considering only up to base-4.12.0.0.
18:22:59 <solonarv> note that that wiki page lists the *first* ghc version that had a given base version
18:23:10 <solonarv> for example all the 8.8.* versions come with base-4.13.0.0
18:26:44 <jchia> How can I specify in my cabal.project to use a candidate release of a hackage package, e.g. https://hackage.haskell.org/package/protolude-0.3.0/candidate ?
18:26:48 <sm[m]> jchia: if in doubt, remember to do a cabal update
18:28:15 <sm[m]> because having stale info about available packages certainly adds to the confusion
18:30:48 <oats> what would be considered the most "mature" extensible effects library at the moment, polysemy?
18:30:57 <slack1256> Yep
18:31:05 <slack1256> next year, who knows
18:31:24 <oats> hehe
18:31:28 <oats> things are moving fast
18:32:00 <slack1256> Yeah, but being serious, polysemy is neat
18:32:19 <oats> the documentation is pretty nice
18:32:40 <oats> I figured I'd get in on the free bandwagon and give a polysemy tutorial I saw a shot
18:51:15 * hackage prim 0.1.0.3 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.3 (dailectic)
18:58:15 * hackage hanabi-dealer 0.9.0.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.9.0.0 (SusumuKatayama)
20:05:50 <jackdk> I am keeping an eye on eff also, but the "requires changes to GHC RTS" means it's not usable right now
20:15:14 * hackage serverless-haskell 0.10.4 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.10.4 (AlexeyKotlyarov)
21:43:35 <pacak> haskell threads that sit in a loop without allocation can't be killed by throwTo. What is the cheapest/easiest way to trigger allocation code from within a loop such that ghc won't optimize it away?
21:44:19 <dsal> http://xyproblem.info/
21:45:40 <c_wraith> pacak: -fno-omit-yields
21:47:40 <pacak> c_wraith: Hmm... They are enabled by default, no?
21:48:30 <koz_> Suppose I have i :: Int. What's the most elegant way to say 'next multiple of 64 >= i'?
21:48:39 <koz_> s/next/next highest/
21:48:46 <koz_> Assume i is non-negative.
21:51:16 <pacak> also specifying yield is not helping. putStr "" helps.
21:52:24 <pacak> Hmm... putStr "." works, putStr "" does not.
21:53:59 <monochrom> koz_: ((i + 63) `div` 64)*64
21:54:15 <siraben> Integer division FTW
21:54:28 <koz_> monochrom: Legit.
21:54:43 <siraben> Does that work because we are essentially doing floor(i/64)*64
21:54:57 <siraben> oops i mean ceil
21:55:18 <monochrom> Yes.
21:55:31 <siraben> Nice.
21:55:51 <siraben> Knuth in Concrete Mathematics gives one of the best treatments of floor and ceiling I've ever seen.
21:55:59 <koz_> siraben: Yeah, I recall that chapter.
21:56:01 <siraben> All sorts of tricks.
21:56:01 <monochrom> More efficient: let j = i+63 in j - (j `mod` 64)
21:56:13 <siraben> koz_:  Ah, have you read all of CM?
21:56:28 <siraben> I'm thinking about taking another go starting from the number theory chapter.
21:56:39 <koz_> siraben: Some. It's not exactly light reading.
21:56:45 <koz_> (as Knuth works tend to be)
21:56:45 <siraben> Right.
21:57:05 <siraben> Heh, the problems range from easy to research level.
21:57:29 <monochrom> Highest efficient by exploting 64 = 2^6:  (i+63) .&. (bitneg 63)
21:57:50 <siraben> If Iverson can create a companion book to CM in J, someone could do it in Haskell, hm. https://www.jsoftware.com/books/pdf/cmc.pdf
21:58:41 <koz_> siraben: Sure, go ahead. :P
21:58:51 <koz_> monochrom: Bitneg is what again?
21:59:08 <siraben> koz_:  :P tempting1
21:59:11 <monochrom> bitwise negation. I forgot the real name in Data.Bits
21:59:18 <siraben> tempting!* (darn shift key)
21:59:37 <siraben> complement?
21:59:47 <koz_> monochrom: You mean 'flip all bits'?
21:59:52 <koz_> Or twos-comp?
21:59:54 <siraben> :t Data.Bits.complement
21:59:55 <lambdabot> Bits a => a -> a
22:00:09 <monochrom> 1s complement
22:00:16 <siraben> :doc Data.Bits.complement
22:00:21 <monochrom> I'm making a bitmask to mask the lower 6 bits.
22:00:34 <siraben> Well the doc says "Reverse all the bits in the argument "
22:00:43 <siraben> Shouldn't it be 'invert'?
22:00:54 <koz_> monochrom: So complement.
22:01:10 <monochrom> Consider "set complement"
22:01:22 <koz_> Thanks, will use.
22:02:20 <siraben> koz_:  Do you need this for some high-performance reasons? heh
22:02:27 <koz_> siraben: Not really.
22:02:35 <koz_> I'm monkeying about with something I read in a research paper.
22:02:41 <koz_> And figured I'd ask for a clever solution.
22:02:49 <koz_> (because I'm strange)
22:02:56 <koz_> monochrom's solution is indeed clever.
22:03:49 <siraben> Haha
22:03:50 <siraben> koz_:  Which paper?
22:04:38 <koz_> siraben: https://www.usenix.org/system/files/conference/atc18/atc18-pekhimenko.pdf
22:04:45 <koz_> (technically one of its references)
22:04:49 <koz_> (but that's where it started)
22:06:37 <siraben> Interesting paper.
22:06:59 <koz_> I agree, though as usual, it's _shockingly_ low on implementation detail.
22:09:52 <monochrom> w00t I've met Gennady Pekhimenko.
22:10:31 <siraben> monochrom:  Are you a researcher?
22:10:39 <monochrom> No, but I teach courses.
22:10:45 <koz_> monochrom: Oh damn.
22:10:48 <siraben> o.O so many academics in #haskell
22:10:54 <monochrom> He teaches a code optimization course in our department.
22:10:57 <koz_> Wait, were you the person who linked me to that compiler optimization course?
22:11:09 <monochrom> I think yes
22:11:15 <koz_> Wow, small world lol.
22:11:28 <koz_> I thought I recognized the name.
22:11:50 <koz_> siraben: I've not met any Haskellers in-person yet.
22:11:58 <koz_> (hope to change that one day)
22:12:07 <siraben> Wow, really?
22:12:10 <koz_> siraben: Yep!
22:13:02 * siraben imagines koz_ traversing the vast plains in search of a Haskeller
22:13:19 <siraben> First time I met one was last semester in university, heh
22:15:50 <siraben> koz_:  What languages did people primarily use?
22:16:05 <koz_> siraben: What do you mean by 'did'?
22:16:20 <koz_> I'm unsure of which people you're referring to.
22:16:37 <siraben> Ah, when you said you didn't meet a haskeller, what languages were they using instead?
22:16:54 <koz_> I mean, I taught at a university which was basically a Microsoft shop.
22:17:03 <koz_> Met a few C++ folks.
22:17:18 <koz_> One person I kinda hang out with sometimes uses TypeScript.
22:18:29 <siraben> Ah I see.
22:18:51 <koz_> IRL I don't hang out with many devs, or even tech folks.
22:19:12 <koz_> Heck, closest thing I have to a best friend is a receptionist at the university's counselling service.
22:19:29 <koz_> (same one I used to teach at)
22:20:40 <siraben> Ah.
22:26:44 * hackage hid-examples 0.5 - Examples to accompany the book "Haskell in Depth"  https://hackage.haskell.org/package/hid-examples-0.5 (bravit)
23:15:33 <koz_> Am I right in my understanding that Ptr (as per http://hackage.haskell.org/package/primitive-0.7.0.0/docs/Data-Primitive-Ptr.html#t:Ptr) has a phantom type role for its parameter?
23:21:32 <c_wraith> did you check with :info?  > :i Ptr\ntype role Ptr phantom
23:22:11 <koz_> Oh, cool.
23:23:45 * hackage deriving-aeson 0.2.4 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2.4 (FumiakiKinoshita)
23:29:15 * hackage ip2location 8.2.1 - IP2Location Haskell package for IP geolocation.  https://hackage.haskell.org/package/ip2location-8.2.1 (ip2location)
23:42:45 * hackage ip2proxy 2.2.1 - IP2Proxy Haskell package for proxy detection.  https://hackage.haskell.org/package/ip2proxy-2.2.1 (ip2location)
23:56:10 <remexre> ugh, tips if ghcide can't find some of my imports?
23:56:23 <remexre> can't pick up hedgehog in one project, fused-effects in the other
23:59:26 <siers> is dependency injection like passing a function to another function?
23:59:45 * hackage serverless-haskell 0.10.5 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.10.5 (AlexeyKotlyarov)
