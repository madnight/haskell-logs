00:10:50 <haskMeAQuestion> hello?
00:11:14 <koz_> haskMeAQuestion: Sup?
00:11:31 <haskMeAQuestion> Just seems kinda empty
00:11:49 <koz_> haskMeAQuestion: It's a quiet period. If you have a question, ask away - someone will get to you eventually.
00:14:14 <maerwald> Life is empty
00:14:25 <haskMeAQuestion> I'm trying to get started with Yesod. Is it possible to get going just by installing things using stack or must you use the templates? I tried the former but no luck.
00:14:43 <haskMeAQuestion> Not sure if empty or just covid
00:15:18 <koz_> maerwald: What Alternative is life?
00:15:24 <jgt> haskMeAQuestion: It's possible to get going without the templates
00:15:35 <jgt> haskMeAQuestion: the templates are just a starting point
00:16:45 <jgt> haskMeAQuestion: although, I always start with the templates. I'm not a very good programmer, and I find it easier to start with yesod-postgres and remove things I don't need, rather than starting with nothing and carefully piecing things together
00:16:46 <haskMeAQuestion> Ideally, I'd write a single file and build up from there. I'm not even sure which package to install.
00:17:47 <haskMeAQuestion> (I was able to get things up and running with the templates but the Yesod book starts with a single file and I was trying to get that to run)
00:18:02 <jgt> haskMeAQuestion: there's a simple example here: https://www.yesodweb.com/book/basics
00:18:10 <jgt> I think you only need the yesod package to run this
00:21:26 <haskMeAQuestion> Just to sanity check, I'll try it again. Probably takes a good 20 minutes on this macbook though. Thanks.
00:22:52 <jgt> fwiw, I do all my Haskell work on a late 2017 MacBook Air with 8GB RAM
00:23:30 <jgt> I have the occasional super long compile time if I need to rebuild a non-trivial project, but that's a good excuse to go make some coffee
00:43:32 <AlyRocks> la
00:43:55 <AlyRocks> ddd
00:44:09 <AlyRocks> sorry,,, wrong window
00:44:39 <haskMeAQuestion> Say I want to get the basic yesod example from the book running. (it's a single hs file)
00:45:00 <haskMeAQuestion> Which package actually gets you the yesod module. So far all I've seen are templates
00:47:22 <haskMeAQuestion> Oh, it looks like you need to be in a stack generated project to start nvm
01:01:31 <haskMeAQuestion> I'm trying to follow the example from yesodweb.com/book/basics - they seem to require more than just making a single .hs file and running `runhaskell`
01:04:23 <jgt> haskMeAQuestion: for which example?
01:05:41 <haskMeAQuestion> The Helloworld example here: https://www.yesodweb.com/book/basics
01:06:35 <jgt> haskMeAQuestion: why do you think it requires more than a single file?
01:06:54 <jgt> haskMeAQuestion: do you mean it requires other .hs files? Or that it requires a cabal file?
01:08:54 <haskMeAQuestion> If I make the `helloworld.hs` file and type `runhaskell hellowlrld.hs` I get that the Yesod module is missing
01:09:34 <jgt> haskMeAQuestion: if you _really_ don't want to use a cabal file, and you just want a single file which declares package dependencies and includes the code, you can use a Stack script
01:09:38 <jgt> like this: https://github.com/commercialhaskell/stack/wiki/Script-interpreter
01:10:24 <jgt> haskMeAQuestion: yeah, it will say that the Yesod module is missing if you haven't declared it as a dependency in your cabal file
01:10:26 <haskMeAQuestion> Maybe I actually want a cabal file? If I use stack to make a new empty project then it's unclear where exactly the helloworld.hs file should go
01:10:37 <jgt> haskMeAQuestion: yes, you do want a cabal file
01:13:43 <haskMeAQuestion> It seems like stack comes with lots of extra project structure. I'm sort of wishing for something that just puts packages in folders. Whatever the analog of npm or yarn is you know?
01:14:00 <haskMeAQuestion> I'll try cabal
01:17:08 <jgt> haskMeAQuestion: stack doesn't work exactly the same way as npm or yarn
01:17:20 <jgt> haskMeAQuestion: please quickly read the part about Stack here: https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/
01:21:45 <haskMeAQuestion> OK so we're to use `stack install` for CLI type things? (I think for a while yesod had one)
01:23:26 <jgt> personally I don't use yesod's CLI tool
01:23:34 <jgt> also I don't use yesod-devel, because it is too slow
01:25:02 <haskMeAQuestion> For sake of argument (and because I don't have cabal installed) it looks like if you wanted to run this example, you would do:
01:25:19 <jgt> this might now be a bit of rabbit hole, so maybe it's better to stick with stack for now, but personally I'm doing everything with nix and ghci
01:25:51 <haskMeAQuestion> `stack new test-yesod` cd into it, past the code from the example into `app/Main.hs` and then do the usual stack methods to run things
01:26:10 <haskMeAQuestion> Is that ghci or ghcid?
01:26:16 <jgt> ghci
01:26:36 <jgt> ghci is Glasgow Haskell Compiler — Interactive
01:27:13 <jgt> I believe stack repl and cabal repl are just wrappers around this
01:27:20 <haskMeAQuestion> I have seen people starting to use nix but it's unclear how it differs from both cabal and stack. (I just haven't gotten around to it)
01:27:51 <jgt> yeah there's a significant learning curve with nix
01:28:13 <haskMeAQuestion> I was just surprised that it wasn't nix and ghc, but the interactive version
01:29:06 <jgt> well, under the hood Nix is using GHC to compile my projects when I'm deploying something
01:29:17 <jgt> but while I'm developing things, I use GHCi
01:29:57 <jgt> building from scratch every time I make a change would be incredibly tedious
01:30:14 <haskMeAQuestion> I think of web stuff as just always being rebuilt and running again but I suppose doing it in ghci lets you poke at it
01:30:14 <jgt> but since I'm using GHCi, I have fast incremental builds
01:30:20 <haskMeAQuestion> ahh ok
01:30:38 <haskMeAQuestion> You're still loading a main module and running a main function again each time?
01:31:19 <haskMeAQuestion> Maybe nix has a learning curve but if the documentation is good "where b6gvzjyb2pg0… is a unique identifier for the package that captures all its dependencies" seems like a worthwhile feature
01:31:26 <jgt> during development, I'm actually loading DevelMain.update
01:31:45 <jgt> you'll find this DevelMain module included in a scaffolded yesod project, like yesod-postgres
01:32:15 <haskMeAQuestion> What's your alternative to ` yesod-devel`?
01:32:29 <haskMeAQuestion> Ah ok
01:32:29 <jgt> GHCi
01:33:36 <haskMeAQuestion> This seems to have more information along these lines: https://www.reddit.com/r/haskell/comments/3d9i9q/why_is_yesod_so_slow/
01:34:05 <jgt> yes, that's exactly it
01:34:17 <jgt> if it's helpful, here is the GHCi configuration that I use: http://ix.io/2hHo
01:34:53 <jgt> if I understand correctly, ghcid is basically a formalised version of GHCi plus the flags I'm using there
01:35:53 <haskMeAQuestion> Are you saying with enough flags it essentially checks your program and reports back like ghcid?
01:36:44 <jgt> I believe so, though I haven't actually used ghcid
01:36:46 <haskMeAQuestion> One thing I've not done is make a default config file for my ghci
01:37:01 <haskMeAQuestion> I keep this on hand though thank you
01:37:08 <jgt> but I have this belief because I spoke with Neil Mitchell about exactly this
01:42:29 <jgt> also, see this note: https://chrisdone.com/posts/making-ghci-fast/
01:45:48 <haskMeAQuestion> So I can put the basic helloworld code into the main module in a blank stack project and run `stack build` but it finds a syntax error (maybe an indentation issue?) That's a shame for the moment
01:46:31 <jgt> I can't guess what the error is without seeing the code
01:47:16 <haskMeAQuestion> I see you have added the notes setup to your config. 
01:47:20 <haskMeAQuestion> I'm working with this:
01:47:25 <haskMeAQuestion> {-# LANGUAGE OverloadedStrings     #-}
01:47:28 <haskMeAQuestion> [whamlet|Hello World!|]
01:47:38 <haskMeAQuestion> https://www.yesodweb.com/book/basics
01:48:50 <haskMeAQuestion> "parse error ... " line 12 / HomeR GET
01:51:03 <jgt> haskMeAQuestion: did you add the right language pragmas?
01:51:29 <jgt> you will need QuasiQuotes enabled for that
01:51:36 <Uniaika> yep'
01:52:44 <haskMeAQuestion> I had them below "module Main where", putting them at the actual top then just gives the error that Yesod is missing. Which is solvable but takes a bit
01:53:13 <haskMeAQuestion> That's my mistake
01:54:21 <Uniaika> yeah, never put your pragmas below the module declaration :)
01:55:09 <haskMeAQuestion> I feel like I've done this before but it should be `stack ??? yesod` and off to the races
01:56:27 <haskMeAQuestion> It looks like we have to manually add packages to the yaml file. So be it.
01:58:43 <haskMeAQuestion> OK it works as expected thank you @jgt et. al.
02:00:18 <jgt> np :)
02:31:10 <phadej> monochrom: I do agree with "the" Oleg. Böhm and Berarducci showed how to do transformation systematically.
02:51:03 <[exa]> jmnoz: btw did you get the pandoc thing working? I had to afk yesterday
03:12:50 <MoodMojo> Hi question about lookup function
03:12:57 <Rembane> Shoot! 
03:13:32 <MoodMojo> If I use a function as f (x:xs) to parse the elements how do I pass lookup over the whole list as part of the function
03:14:04 <MoodMojo> Something like f (x:xs) = lookup x but here I want it to lookup over the whole list, not just the first
03:14:28 <Rembane> MoodMojo: You can use the function map for that. 
03:15:28 <MoodMojo> It doesn't seem to do the trick, or maybe I'm using it wrong. Mind if I show the question I got at hand?
03:15:51 <Rembane> MoodMojo: Go ahead. 
03:20:35 <MoodMojo> https://docdro.id/eOuMKRu
03:22:24 <MoodMojo> I figured out the function to evaluate expressions, but I can't figure out how to process previous values at all
03:22:31 <MoodMojo> Been at it for over a week now
03:27:16 <polyphem> MoodMojo: is your f (x:xs) recursive , and where do you want to lookup x ?
03:27:33 <polyphem> :t lookup
03:27:35 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
03:30:04 <polyphem> MoodMojo: what are your elements "xs" ? (String,ExprV) ?
03:34:56 <Eduard_Munteanu> You probably want something like    foldAndPropagateConstants xss = go initialState xss   where go s (PATTERN:xs) = evaluatedExpression : go newState xs
03:35:40 <Eduard_Munteanu> I.e. a fold instead of map
03:38:12 <Eduard_Munteanu> Where the state is a dictionary of previously seen values.
03:49:35 <MoodMojo> polyphem it is recursive yes, I want lookup to, well, look up the value of an already evaluated variable.
03:50:56 <MoodMojo> f takes a list and each cell contains a variable name and an expression. Once the expression is evaluated, it is assigned to the variable. An expression can contain a variable in it so if that variable does exist, I want to replace it with its value
03:51:26 <MoodMojo> Eduard_Munteanu mind if you elaborate on that? I'm a beginner in this
03:56:53 <polyphem> MoodMojo: you could use mapAccumL to work over all "cells" carring the environment of fully evaluated (String,ExprV)s a accumulator on that you can do the lookup
04:03:48 <MoodMojo> polyphem I see how this would help with evaluation of expressions, but how will that substitute variables with their values?
04:05:11 <polyphem> MoodMojo: mapAccumL (\dict assignmentCell -> (updateddict,evaluatedAssignmentCell)) startingDict [assignmentCell]
04:06:08 <MoodMojo> Dictionary would be the starting input?
04:06:22 <polyphem> MoodMojo: in the function passed to mapAccumL you have tu use the accumulator and eveluate the current expression 
04:08:38 <polyphem> MoodMojo: right Dictionary would be empty at start , its the accumulator of mapAccumL and each itteration gives back a new dict with the evaluated cell added , to be used in the next itteration
04:10:35 <MoodMojo> polyphem ok I think I get this part, but when I evaluate I will need to replace Variables with their respective values. My guess would be lookup in this case?
04:12:33 <polyphem> MoodMojo: you need an evaluation function that takes a dictonary (the accumulated one of the mapAccumL) 
04:12:59 <MoodMojo> Yeah that's what I thought
04:14:04 <MoodMojo> polyphem ok so what about the main function, foldAndpropagate? It will need to recursively call mapAccumL right?
04:14:17 <polyphem> eval dict (Var x) = if x in dict -> Const xFromDict else Var x
04:16:25 <polyphem> MoodMojo: no foldAndPropagate calls mapAccumL once on its input , and add the end discards the accumulator  of mapAccumL returning only the processed list of cells
04:17:01 <MoodMojo> Discards?
04:18:06 <polyphem> you only need the dict while processing ... the type of foldAndPropagate doesnt give a dict back , right ?
04:18:56 <MoodMojo> Nope only processed list
04:19:05 <MoodMojo> So you mean just return that, ok
04:19:26 <MoodMojo> I (think) I got it. I'll try to apply it now. Thanks a lot
04:22:01 <hexagoxel> there is a generalisation of find/delete/firstJust on lists, with a signature like `extract :: (a -> Maybe b) -> [a] -> Maybe ([a], b)`. Does this exist somewhere / am I overlooking an existing variant of that idea?
04:24:09 <hexagoxel> firstJust f l = fmap snd (extract f l)
04:24:29 <hexagoxel> delete x l = fmap fst (extract (guard (x==)) l)
04:26:10 <hexagoxel> find f l = fmap snd (extract (\x -> [x | f x] l)
05:37:42 <juri_> > zipWith3 (\x y z -> x+2*y+3*z) [1..5][5..10][10..15] 
05:37:44 <lambdabot>  [41,47,53,59,65]
06:16:51 <hseg> ok, i'm back. trying to debug a derivation error. sketching the types and instances involved, http://ix.io/2hIN gives a "Could not deduce G (U (P r)) arising from the 'deriving clause' from the context S r" error, whereas http://ix.io/2hIO compiles fine
06:16:59 <hseg> unclear why these differ
06:18:33 <hseg> (these are sketches, can work out mwe if necessary)
06:19:44 <c_my_nick> is there a difference between the cabal v2-* and new-* commands?
06:27:44 <lyxia> no
06:28:17 <maerwald> new-* might be removed at some point I guess
06:28:20 <maerwald> as alias
06:28:37 <lyxia> hseg: It would be nice to have complete examples
06:28:50 <hseg> ok, will get to it
06:33:27 <vaibhavsagar> is there a way to use the new-* commands on Nix without Cabal insisting on installing and rebuilding everything?
06:34:02 <srk> yes you just need a shell with all the deps
06:34:02 <maerwald> it doesn't rebuild everything
06:34:11 <vaibhavsagar> hmm
06:34:11 <srk> it does if you don't have deps available
06:34:16 <vaibhavsagar> might be an issue with my setup then
06:34:41 <srk> check with ghc-pkg list
06:35:00 <vaibhavsagar> I do remember it wanting to build all my deps from source when I did v2-build and not needing to do that when I did v1-build
06:37:12 <c_my_nick> ok, thanks
06:38:55 * legowheels[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/DhDotzSXToQLDsEAZXDEhJVg >
06:40:13 <maerwald> vaibhavsagar: you want to mix v1 and v2 or what?
06:40:17 <maerwald> it's not clear what you expect
06:40:35 <maerwald> v2 doesn't reinstall things, unless you changed configuration
06:41:23 <vaibhavsagar> maerwald: I would like to use v2 only
06:41:35 <maerwald> then do that
06:41:38 <vaibhavsagar> but nix-shell seems to set things up in a way that only lets me use v1
06:41:51 <srk> vaibhavsagar: post your default/shell.nix 
06:42:03 <srk> vaibhavsagar: also do you have cabal.project?
06:42:07 <hseg> hrm. having trouble reproducing
06:42:46 <vaibhavsagar> oh, hmm, it doesn't seem to be doing that now
06:43:34 <srk> I'm using v2 with nix for a while now, can build with v1 as well
06:43:34 <vaibhavsagar> https://gist.github.com/vaibhavsagar/11b135faa1f95cd483b26e34e8752000
06:43:44 <vaibhavsagar> I'm trying to make a change to pandoc
06:45:11 <vaibhavsagar> aha
06:45:13 <srk> complex!
06:45:24 <srk> you can do something like nix-shell -p haskellPackages.pandoc.env.nativeBuildInputs to get deps for pandoc as well
06:45:29 <srk> not all of them tho
06:45:35 <vaibhavsagar> it's `cabal configure` that's wanting to download and build everything
06:45:58 <vaibhavsagar> srk: this is for the current `master` of Pandoc on NixOS 19.09, hence the overrides
06:46:07 <srk> ok!
06:47:38 <vaibhavsagar> should I just not use `cabal configure`?
06:47:50 <vaibhavsagar> IIRC it's unnecessary with the new workflow
06:47:50 <srk> possible, never used that one :)
06:48:40 <vaibhavsagar> cool, thanks for helping me debug this :)
06:48:51 <srk> yw! :)
06:59:02 <Profpatsch> RecordDotSyntax doesn’t make assignment possible, does it? (https://github.com/ghc-proposals/ghc-proposals/pull/282)
06:59:27 <Profpatsch> Because I’m wondering how it’s better than just using (&) = flip ($)
07:14:24 <siraben> Has anyone else had a project where they build algebraic abstractions over a C FFI?
07:15:06 <siraben> Using OpenGL's raw C bindings and abstracting over that is quite fun, IMO, also a good way to use Conal Elliot's philosophy of "denotational design".
07:23:30 <vaibhavsagar> xmonad maybe?
07:53:32 <maerwald> any mac users here, who can help me test a haskell binary?
07:56:08 <polyphem> siraben: there is this talk "Haskell SpriteKit- a Purely Functional API by Manuel Chakravarty at FnConf17" at https://www.youtube.com/watch?v=kd8mlbN0Mws
07:57:52 <polyphem> siraben: where the talker describes all sorts of concerns af api mapping between statefull objectiveC API to Haskell purly functional API
08:00:04 <Flonk> Is a natural transformation from the identity functor just a functor?
08:03:13 <phadej> no
08:03:24 <phadej> natural transformation is natural
08:03:41 <phadej> (natural transformations are also functors, in own category)
08:04:21 <dmwit> Flonk: Which functor are you proposing that it is?
08:04:45 <dmwit> There's a lot of things your question could mean. If you expand on the details a bit it will be easier to answer.
08:06:29 <Flonk> I bought Saunders Mac Lane's book a while ago (which is frankly above me but I am learning a lot and I have nothing to do anyway). He gives some examples of natural transformations, and this specific one goes from Identity on Grp to the factor-commutator functor (Grp -> Ab)
08:06:50 <dmwit> (For example, one way the answer could be "no": if the question is 'does a natural transformation n : (Id : C -> C) -> F induce a functor on C?', because the natural transformation won't specify what the "induced" functor does to arrows.)
08:06:53 <Flonk> I've just never seen a natural transformation from the identity functor before, is all
08:07:45 <Flonk> dmwit, oh yeah that makes sense.
08:08:51 <phadej> dmwit: doesn't it? is the naturality condition specify how "diagrams in Id C = C" would transform to "diagrams in F C" ?
08:09:36 <dmwit> The naturality condition say that if f : X -> Y, then f;nY = nX;Ff.
08:09:41 <dmwit> Take for example also F = Id
08:10:01 <mrt1> could anyone recommend where to start with haskell?
08:10:27 <dmwit> Then the naturality condition says only that f;nY = nX;f, so any functor that is the identity on objects could be "induced" by this condition.
08:10:45 <dmwit> It doesn't say at all what should happen to the arrows under this n mapping, only that objects should stay fixed.
08:11:00 <phadej> dmwit: I see, thanks.
08:11:34 <phadej> wait, doesn't the composition of arrows should be preserved?
08:11:56 <phadej> it maybe different arrows, but it somehow they mapping of arrows cannot be comletely arbitrary however
08:12:24 <dsal> mrt1: it mostly depends on where you are, but I really liked Haskellbook.com
08:12:26 <dmwit> Sure. But all you need is an automorphism on every object, say, and there can easily be more than one choice for each.
08:13:30 <dmwit> (And id is an automorphism, so you are guaranteed at least one choice for each.)
08:14:52 <mrt1> dsal: i've worked with C# for ~2 years, went through half of SICP to get the hang of functional programming, other than that not much experience
08:15:55 <dsal> mrt1: good, not too much to unlearn. :)
08:16:18 <dmwit> phadej: Let's get even more concrete. Take the Bool/(/=) monoid category (one object, one arrow each for True and False, id=False, True;True = False;False = False).
08:16:54 <Flonk> so I was thinking nX takes X to G(X) just like G(X) does but they mustn't be the same morphisms
08:17:00 <Flonk> don't have to be I mean
08:17:06 <Flonk> I see I see
08:17:07 <dsal>  mrt1: HPFFP is a big book.  It's a slow path, which is, IMO, the fastest way to get comfortable.
08:17:11 <dmwit> phadej: Then the distinguished natural transformation F : Bool -> Bool can be associated with either functor id or not.
08:18:00 <dmwit> phadej: *the distinguished natural transformation F : Id_Bool -> Id_Bool
08:19:53 <dmwit> errr... no, not is not a functor. whoops
08:20:30 <dmwit> Make that "can be associated with either functor id or const False".
08:23:14 <mrt1> dsal: thanks for the recommendation, will definitely check it out. i've always struggled a bit to make something practical apart from toy programs in functional languages
08:23:31 <ski> @where HPFFP
08:23:31 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
08:24:13 <dsal> mrt1: I write all my real world, useful programs in Haskell lately
08:24:37 <ski> mrt1 : i'd suggest a textbook, at least
08:25:08 <ski> (i learned from "Haskell: The Craft of Functional Programing" by Simon Thompson)
08:25:19 <ski> people also often suggest e.g.
08:25:23 <ski> @where PIH
08:25:23 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
08:26:08 <ski> @where SoE
08:26:09 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
08:26:27 <ski> if you want some exercises, you can try
08:26:40 <ski> @where CIS194
08:26:40 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
08:29:01 <mrt1> ski: thank you for the links
08:29:37 <ski> there's probably more sensible starting points, but that's at least some
08:41:10 <siraben> polyphem:  Thanks, sounds like a great talk.
09:44:24 <sshine> haddock question: sometimes, haddock isn't available on hackage. how do I generate haddock docs for my dependencies locally?
09:54:13 <sm[m]> mrt1, a few more: What I Wish I Knew When Starting Haskell, State of Haskell, FP Complete's Applied Haskell Syllabus, and
09:54:15 <sm[m]> @where HTAC
09:54:16 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
10:23:58 <dsal> sshine: stack haddock  ?
10:38:01 <hugs> so I just watched the 2-hour-long Lens talk by ekmett
10:38:09 <hugs> and I am now convinced he is a wizard
10:38:32 <maerwald> xD
10:38:48 <maerwald> That's really all I got from the talk (and the vacuum cleaner in the background)
10:41:14 <hugs> I didn't get all of the nitty-gritty details, there's a lot of time spent deriving some heady stuff
10:41:27 <hugs> but the examples were very informative
10:44:01 <dsal> lens is one of those things that often works the way you expect it to if you don't know a lot about it.  If you know a little about it, it's very confusing.
10:44:22 <Rembane> And if it stops working the brain turns inside out.
10:46:32 <maerwald> optics is a littler stricter
10:46:35 <monochrom> And when it works, it turns data structures inside out.
10:47:03 <maerwald> you could say it's a dynamically typed DSL
10:47:19 <maerwald> from the look and feel, not in terms of theory
10:53:31 <phadej> sufficently polymorphic feels like dynamic
10:55:06 <Rembane> But it goes boom at compile time rather than runtime which is a very nice feature of lenses. Or it behaves in ways I didn't anticipate even though it typechecks.
10:55:44 <phadej> > length ('x', 'y')
10:55:46 <lambdabot>  1
10:55:55 <hugs> uh
10:56:01 <hugs> :t length
10:56:03 <lambdabot> Foldable t => t a -> Int
10:56:07 <phadej> same issue, "sufficiently polymorphic"
10:56:13 <geekosaur> a tuple does not have a dynamic length
10:56:16 <hugs> oh right, because (,) is foldable :P
10:56:33 <hugs> I'm amazed that lens stuff is polymorphic over different tuple sizes
10:56:38 <solonarv> no, it isn't (kind error)
10:56:45 <solonarv> however ((,) a) is foldable
10:56:58 <hugs> solonarv: ah, thanks for the correction :)
10:57:06 <phadej> :t each
10:57:07 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
10:57:13 <hugs> s t a b
10:57:21 <phadej> is just more fancy class, than Traversable
10:57:30 <solonarv> yes, great choice of variable names :>
10:57:33 <phadej> > lengthOf each ('x', 'y')
10:57:35 <lambdabot>  2
10:57:42 <phadej> > lengthOf each ('x', True)
10:57:42 <solonarv> % :t each @(_,_)
10:57:43 <yahb> solonarv: forall {f :: * -> *} {w} {b'}. Applicative f => (w -> f b') -> (w, w) -> f (b', b')
10:57:45 <lambdabot>  error:
10:57:45 <lambdabot>      • Couldn't match type ‘Char’ with ‘Bool’
10:57:45 <lambdabot>          arising from a use of ‘each’
10:58:14 <phadej> an elephant arse: (_,_)
10:58:26 <solonarv> haha
10:58:56 <phadej> or hippopotamus
11:00:38 <Boarders_> Does anyone know if I have a newtype around a list whether the rules for list fusion will or will not fire?
11:00:48 <Boarders_> or if rules will never fire for a newtype?
11:01:25 <phadej> if the coercions go away, than they may fire
11:01:33 <solonarv> if your functions get inlined and simplified, then it's possible for the list operations to be directly plugged into each other
11:02:16 <solonarv> e.g. if you define mymap f (Wrap xs) = Wrap (map f xs); myfoldr f z (Wrap xs) = foldr f z xs
11:03:12 <solonarv> then if you write something like: myfoldr f z (mymap g xs) -- there is a good chance that mymap and myfoldr get inlined, the intermediate Wrap's go away, and you get fusion
11:04:18 <hugs> :t each
11:04:21 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
11:04:48 <Boarders_> ah ok, thank you. In particular if I have a wrapped enumFromTo and I have a newtype derived foldable instance then it is plausible that I may get shortcut fusion from that?
11:05:06 <Boarders_> obviously in practice I would check which rules fired
11:05:10 <solonarv> probably
11:05:23 <solonarv> slap an INLINE pragma on your wrapped enumFromTo if you haven't already
11:06:04 <solonarv> oh, and you can check the generated Core or STG with -ddump-{simpl,prep,stg} to see if fusion happened
11:10:23 <Boarders_> thanks, that is helpful
11:13:21 <heath> does anyone have a copy of "a new view on guards" by spj?
11:14:52 <heath> here's the bibtex: https://scholar.googleusercontent.com/scholar.bib?q=info:i9TBzvQa3A0J:scholar.google.com/&output=citation&scisdr=CgXJyw9qEMnr13pZkrs:AAGBfm0AAAAAXpNciruECxn0ghEurdoOruRGpprKiumo&scisig=AAGBfm0AAAAAXpNcinoMLXqRoeawS30cDiMk6dWu0kiB&scisf=4&ct=citation&cd=-1&hl=en
11:14:57 <phadej> the paper from 97?
11:15:02 <heath> phadej: yeah
11:15:54 <phadej> doesn't seem to be on https://www.microsoft.com/en-us/research/people/simonpj/publications/ list :/
11:17:20 <phadej> So I guess it's lost, except if SPJ himself has it somewhere. I'd send him an email if you really need that
11:17:50 <jota191> I have a library using a lot of type level programming that took a time to compile exponential in the size of a type. I fixed it, but I want to understand what Type Families were the ones taking so much resources when resolving. is there a way to profile compilation? 
11:19:37 <phadej> heath: archive,org seems to have it still though
11:19:37 <phadej> https://web.archive.org/web/20070607195923/http://research.microsoft.com/Users/simonpj/Haskell/guards.html
11:21:05 <heath> oh nice, I didn't get that when I pasted the link in the way back machine
11:21:07 <heath> thanks phadej 
11:21:52 <phadej> you are welcome
11:28:18 <amerigo> what is the difference between () and []?
11:28:52 <monochrom> They have different types altogether.  Exercise: In ghci use the :type command to ask about their types.
11:30:13 <geekosaur> tuples are fixed size but can contain things of different types. lists are variably sized and can only contain things of the same type.
11:36:32 <dsal> Is () considered a tuple?
11:36:59 <monochrom> There are reasons for both yes and no.
11:37:29 <monochrom> But it seems that my students are the happiest with the narrative "yes, it's the 0-tuple".
11:37:36 <Uniaika> dsal: no, the comma is the tuple operator
11:37:45 <Rembane> Is there a -1 tuple?
11:37:52 <dsal> But you can't have a tuple without () can you?
11:38:19 <Uniaika> you cannot indeed
11:38:31 <monochrom> Because wording "the unit type" never really flied with me.
11:38:35 <monochrom> err, s/me/them/
11:38:51 <dsal> Tuples feels all kinds of weird special here.
11:38:55 <monochrom> Haskell doesn't have a 1-tuple.
11:39:05 <geekosaur> syntactically they are
11:39:08 <hpc> i would say Identity counts
11:39:24 <yushyin> dsal: well, () is defined in GHC.Tuple ...
11:39:31 <hpc> it follows the pattern, the only difference is syntax
11:39:32 <Uniaika> erlang, however, has 1-tupled
11:39:34 <Uniaika> *-tuple
11:40:01 <monochrom> I don't think this needs a unique "right answer".
11:40:33 <monochrom> The important things are laws, not wordings.
11:41:18 <dsal> Void, (), {missing link}, (,)
11:41:41 <monochrom> Wordings are only useful to the point that some common words induce people to imagine some common laws.
11:45:51 <yushyin> too bad that we often call () the unit type and there is a 'Unit a' in GHC.Tuple ^^
11:48:38 <monochrom> Haha the plot thickens!
11:48:45 <ski> should be "unituple" or something
11:49:04 <monochrom> There are too many ones.
11:49:33 <ski> @type (# False #)
11:49:35 <amerigo> i don't know any Haskell im sorry. I asked becasue in the paper i am reading  a function building empty parse tree should return () for an empty string and [] for a kleene star
11:49:35 <lambdabot> (# Bool #)
11:49:51 <dmwit> monochrom: http://hackage.haskell.org/package/OneTuple
11:50:09 <dmwit> dsal, Uniaika: Of course you can have tuples without ().
11:50:14 <amerigo> thats where my confusion came from
11:51:10 <dmwit> amerigo: () is a type that has only one value, specifically, () (yes, they are named the same, and that can be a bit confusing, but there are two different entities named (), one each at the computation and type level).
11:51:24 <monochrom> () and [] are of incompatible types. You can't possibly be talking about one single function.
11:51:39 * ski . o O ( GADT )
11:51:54 <koz_> amerigo: Link or title?
11:51:58 <dmwit> amerigo: [] is a type former. When applied to another type, say, Bool, it produces a type that has lots of different values, including the empty list [], one-element lists like [False], [True], two element-lists, like [False, False], [False, True], [True, False], [True, True], and so on.
11:52:15 <amerigo> POSIX Regular Expression Parsing with Derivatives
11:52:25 <amerigo> page 8
11:52:26 <ski> dsal : `Void' don't seem to fit with those others ..
11:52:46 <dmwit> (And yes, we see the same thing with lists that we saw with unit: [] is a name at both the computation and type levels, with different meanings in each.)
11:52:52 <dsal> Why is that?  Isn't Void the type with no inhabitants?
11:53:00 <ski> it is
11:53:29 <amerigo> Sulzmann and Lu
11:53:38 <dmwit> dsal: in your chain, I would expect it to go (), OneTuple, (,), (,,), (,,,), etc.
11:54:17 <dmwit> dsal: The guiding principle there being that (a, ()) is isomorphic (up to bottoms) to OneTuple a; and (a, OneTuple b) is isomorphic to (a, b); and (a, (b,c)) is isomorphic to (a,b,c), etc.
11:54:26 <koz_> amerigo: Figure 3 isn't valid Haskell.
11:54:32 <dmwit> dsal: Void doesn't extend that property in the other direction: (a, Void) is not isomorphic to ().
11:54:36 <koz_> It's what academics like to call a 'sketch' and what I like to call 'needlessly confusing'.
11:54:44 * ski . o O ( unicycling )
11:54:59 <koz_> mkEps isn't mean to be one function, hence the different subscripts.
11:55:19 <Uniaika> oh hi koz_ o/
11:55:31 <koz_> Uniaika: Wazzup!
11:55:51 <Uniaika> koz_: shitposting about Uncle Bob! What about you? :D
11:56:12 <koz_> Uniaika: Resharing said shitposting while I wait for work to start. DST is killin' me. :(
11:56:20 <dmwit> ski: (Please object if I'm misrepresenting what you felt made Void not seem to fit.)
11:56:25 <koz_> (have to start at 7am to have any hope of sharing at least some work time with my colleagues)
11:56:48 <Rembane> koz_, Uniaika: What has he done now? :O
11:57:10 <koz_> Rembane: It's more of a shitpost regarding his general take on everything.
11:57:28 <koz_> You can follow one (or both!) of us for the details.
11:57:32 <ski> (well, `Void' doesn't take negative one parameters, either. but you're fine)
11:57:39 <Rembane> koz_: Oh. Got it. 
11:58:15 <dmwit> heh
11:58:39 <ski> dsal : otoh, `Void',`UniChoice',`Either',`Either3',...
11:58:49 <koz_> ski: Something taking negative one parameters sounds like a C implementation detail. :P
11:58:59 * ski grins
11:59:15 <dmwit> `x :: Void; x = undefined` error: Expected kind *, but Void has kind -> *
11:59:22 <Uniaika> Rembane: subscribe and like to my channel https://twitter.com/TechnoEmpress/status/1249378246782791680
11:59:32 <koz_> Uniaika: Don't forget the bell button! :P
11:59:56 <Rembane> Uniaika: That one's legendary! Already done, just didn't connect you with you. :)
12:00:07 <dmwit> ski: Is UniChoice actually the same as OneTuple? I think maybe yes?
12:00:14 <koz_> Not all of us are a variant of something everywhere.
12:00:20 <ski> would seem so, yes
12:00:20 <koz_> (I try to be where possible)
12:00:28 <Uniaika> Rembane: glad to know I have an audience!
12:00:34 <dmwit> neat
12:00:45 <ski> hm, i wonder whether `Identity' would be appropriate ?
12:01:04 <Rembane> Uniaika: ^^
12:01:07 <dmwit> I think Either has 2 constructors, Void has 0, and perhaps this suggests that UniChoice should have 1.
12:01:22 <ski> yes, of course
12:01:48 <Uniaika> I promise between two shitposts I'm trying to get shit done with the haskell docs
12:02:09 <Uniaika> (however you may view my most glorious ones in my medias, between two #haskelldocs updates :P)
12:06:30 <amerigo> I found the code  and its   mkeps Phi = Nil  and mkeps (Star r) = List []
12:06:55 <ski> looks ok
12:07:26 <geekosaur> those look wrapped in constructors for a type which can contain multiple things
12:08:12 <amerigo> yes, its data U where Nil :: U
12:08:54 <ski> hm, just `GADTSyntax'
12:09:22 <monochrom> I bet the paper already explains why this distinction.  I wouldn't do it justice to guess.
12:09:44 <monochrom> Unless I go read it but why would I.
12:19:28 <ski> % :t ES . ES . EZ
12:19:28 <yahb> ski: forall {p :: Nat -> *}. Compose (Compose p 'S) 'S 'Z -> ExistsNat p
12:19:31 <ski> % :t EN . Inc . Inc . With
12:19:31 <yahb> ski: forall {p :: Nat -> *}. p ('S ('S 'Z)) -> ExistsNat' p
12:26:03 <svipal> Is it possible to use a funPtr without registering a c function ?
12:26:19 <koz_> svipal: What are you trying to do?
12:29:31 <svipal> quickly testing a funPtr made from an inline-C block
12:32:49 <svipal> in the end my goal is to allow the user to write C functions that I would use inside, so I'll eventually be able to register them using something like TH
12:32:55 <svipal> but I wonder if there is not another way
12:36:14 <svipal> (user would be a dev)
12:40:36 <kiwi_42> Hi peeps! I'm an advanced haskeller but this is the first time I'm having this problem
12:40:46 <kiwi_42> I'm trying to make a literal 20# 
12:40:52 <kiwi_42> but a Word# instead of an Int#
12:41:50 <svipal> I ended up just using inline C
12:42:08 <solonarv> hm, this is a guess but perhaps 20## is a Word literal?
12:42:09 <svipal> and doing something really horrible, casting a void ptr to a function pointer and bacl
12:42:14 <solonarv> or is it a Double#
12:42:24 <solonarv> % :t 20#
12:42:24 <yahb> solonarv: Int#
12:42:26 <solonarv> % :t 20##
12:42:27 <yahb> solonarv: Word#
12:42:29 <solonarv> aha!
12:42:40 <kiwi_42> you were right that works!
12:42:45 <kiwi_42> now similar question
12:42:50 <kiwi_42> is there a <# for word?
12:42:53 <kiwi_42> I guess <##
12:43:04 <solonarv> that's as good a guess as any at the name
12:43:11 <koz_> solonarv: TIL.
12:43:13 <solonarv> you can always look through ghc-prim
12:44:01 <solonarv> ah, looks like there is no operator but there is ltWord# and friends
12:44:08 <solonarv> % :t ltWord#
12:44:08 <yahb> solonarv: Word# -> Word# -> Int#
12:44:32 <solonarv> % 20## `ltWord#` 42##
12:44:32 <yahb> solonarv: ; <interactive>:34:1: error:; * Couldn't match a lifted type with an unlifted type; When matching types; () :: *; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
12:44:37 <solonarv> oops
12:44:45 <solonarv> % I# (20## `ltWord#` 42##)
12:44:45 <yahb> solonarv: 1
12:44:55 <solonarv> % I# (20## `ltWord#` 11##)
12:44:55 <yahb> solonarv: 0
12:44:58 <kiwi_42> % :i ltWord#
12:44:59 <yahb> kiwi_42: ltWord# :: Word# -> Word# -> Int# -- Defined in `GHC.Prim'
12:45:02 <koz_> solonarv: How to write CHaskell. :P
12:45:03 <kiwi_42> aha in Prim
12:45:19 <solonarv> I think you can also import all these from GHC.Exts in base
12:45:30 <svipal> my god inline C is mazing
12:46:01 <solonarv> I have never had to use it, but it sure seems great
12:46:04 <svipal> does it have performance issues compared to just calling C functions from FFI ? because gunklediggun
12:46:12 <koz_> svipal: Wait till you see inline-asm lol.
12:46:17 <kiwi_42> Why is ltWord# not exposed in GHC.Word?
12:46:26 * solonarv shrugs
12:46:30 <solonarv> I don't know
12:46:38 <svipal> i-is that a thing ?
12:46:44 <solonarv> when I want to muck with primitives I just go directly to importing GHC.Exists
12:46:52 <solonarv> erm, oops, I mean GHC.Exts of course
12:47:01 <svipal> I was really puzzled for a moment
12:47:27 <solonarv> haha
12:47:56 <kiwi_42> what's the difference between GHC.Exts and GHC.Prim
12:48:59 <phadej> if you are not sure, use GHC.Exts
12:49:07 <svipal> what the f# inline-asm is a thing
12:49:09 <kiwi_42> ok but why :P
12:49:28 <phadej> kiwi_42: because GHC.Exts is in `base`, GHC.Prim is in another package
12:49:35 <kiwi_42> ah that's what I was looking for, thanks!
12:53:11 <kiwi_42> phadej: What's in a Word32 on ghcjs for example?
12:53:16 <kiwi_42> I think my library will stop working there
12:53:24 <kiwi_42> which is fine, I guess, but I'm just curious
12:55:41 <phadej> Word32 IIRC is represented by JS number (as it has 32bits in it)
12:55:51 <phadej> Word64 is array of two numbers
12:55:59 <phadej> (and is quite slow to do stuff on)
12:56:17 <phadej> but if you don't care too much, they "just work".
12:57:11 <kiwi_42> ok, so my library will definitely break on that
12:57:18 <svipal> what kind of asm is it btw ?
12:57:29 <kiwi_42> My colleague nerd-sniped me by saying that Word32 contains a Word# 
12:57:39 <kiwi_42> same with Word8 and Word16
12:57:44 <kiwi_42> which means Word8 goes up to 2^64
12:59:28 <maerwald> SIGABRT is not an async exception?
12:59:45 <monochrom> Out of alignment concerns and too lazy to tighten it, Word8 takes a machine word.
13:00:04 <kiwi_42> monochrom: exactly so that means that a Word8 is not trivially valid
13:00:11 <kiwi_42> it's only valid if the containing Word# is within bounds
13:00:28 <monochrom> In fact to be more precise, two machine words: one for the constructor, one for the value.
13:00:37 <monochrom> Yes.
13:00:57 <kiwi_42> so libraries like cborg
13:01:06 <kiwi_42> _could_ theoretically create invalid WordXs
13:01:11 <kiwi_42> but there's no way to test for it
13:01:13 <kiwi_42> _UNTIL NOW_ :p
13:01:19 <monochrom> But I bet GHC inserts asm code at various places that trims it down.
13:01:46 <solonarv> there are even primops to narrow Word# / Int#
13:01:52 <monochrom> Of course I also bet that it's imperfect, so yes if you go too low-level you can troll it.
13:01:59 <solonarv> which presumably do get called occasionally
13:04:09 <monochrom> I think yes. GHC.Prim has things like "pext8# :: Word# -> Word# -> Word#    Extract bits from lower 8 bits of a word at locations specified by a mask."
13:04:26 <solonarv> also a bunch of 'narrowWordX#'
13:07:14 <kiwi_42> % :i W32#
13:07:14 <yahb> kiwi_42: data Word32 = W32# Word# -- Defined in `GHC.Word'
13:07:21 <kiwi_42> %:t W32#
13:07:33 <kiwi_42> Hm, why can't I use W32# as a function?
13:07:48 <ski> % :t W32#
13:07:48 <yahb> ski: Word# -> Word32
13:08:07 <ski> % W32# 20##
13:08:08 <yahb> ski: 20
13:08:19 <monochrom> If you use it as a function, you have to watch out for kinds.  W32# does not have kind *
13:09:05 <kiwi_42> aha it looks like it does work
13:09:06 <monochrom> If you dig deeper, at some point you run into "levity".
13:09:11 <kiwi_42> I'm writing
13:09:19 <kiwi_42> `genUncheckedInt :: (Int# -> a) -> Gen a
13:11:27 <kiwi_42> Now I'm getting `Not in scope: data constructor ‘Int#’`
13:11:29 <kiwi_42> strange
13:11:46 <kiwi_42> I even have `import GHC.Exts (Int#(..))`
13:11:55 <monochrom> Also turn on MagicHash
13:11:59 <kiwi_42> and `import GHC.Int (Int(..))`
13:12:06 <kiwi_42> I have MagicHash already
13:12:29 <kiwi_42> oh, doh
13:12:32 <kiwi_42> it's called `I#`
13:12:35 <monochrom> Yeah
13:17:33 <monochrom> OK it looks like GHC inserts narrowing whenever it really matters.
13:18:00 <sm[m]> oh, that's a nice list of haskell-using companies: https://haskellcosm.com
13:18:43 <solonarv> monochrom: is "GHC inserts" really the right phrasing here? surely this is just a matter of the base library being written correctly.
13:19:30 <monochrom> Err no, I was wrong, it doesn't!
13:20:29 <kiwi_42> I'm running into the kind problem
13:20:48 <kiwi_42> https://pastebin.com/XAphhq6S
13:20:57 <kiwi_42> oh wait no
13:21:00 <kiwi_42> that's just a type error
13:21:13 <monochrom> I call it "inserts narrowing" iff I see "narrow8Word#" in Core.
13:21:46 <kiwi_42> https://pastebin.com/uu78vHat
13:21:49 <kiwi_42> NOW I'm running into it
13:22:33 <frdg> https://pastebin.com/NYAr179x need some help dissecting a newtype
13:22:42 <ski> kiwi_42 : eta-expand ?
13:22:58 <kiwi_42> I tried that
13:23:06 <kiwi_42> ```shrinkUncheckedInt fromInt# toInt# i = fmap fromInt# ( shrink ( toInt# i))```
13:23:12 <kiwi_42> same error
13:23:13 <ski> what's the type of `shrink' here ?
13:23:21 <kiwi_42> `a -> [a]`
13:23:27 <ski> frdg : understanding what it means ?
13:23:33 <ski> kiwi_42 : `a' constrained ?
13:23:37 <frdg> ski: right
13:23:39 <kiwi_42> oh wait I need to add another layer
13:23:40 <kiwi_42> one moment
13:24:15 <ski> frdg : a value of type `Mem s a' is represented by a function of type `s -> (a,s)'
13:24:17 <monochrom> [Word#] is not going to fly.  [a] presupposes a :: *
13:25:02 <ski> frdg : `Mem' is a data constructor, of type `(s -> (a,s)) -> Mem s a'. `runMem' extracts the representation, has type `Mem s a -> (s -> (a,s))'
13:26:15 <monochrom> frdg: In general you can also check out "record syntax".
13:26:27 <ski> frdg : you could have defined it as `newtype Mem s a = MkMem (s -> (a,s))' and then `runMem :: Mem s a -> s -> (a,s)); runMem (MkMem f) = f'
13:26:54 <frdg> ski: Why do we need to specify the Type constructor as `Mem s a`? To me it seems like you wouldn't need to specify the `a` part of it, only the `s`.
13:26:57 <kiwi_42> frdg: I got it by going via int instead of int#
13:27:04 <monochrom> For this reason I don't actually use record syntax on my students.
13:27:14 <ski> frdg : both `s' and `a' are type parameters
13:27:33 <c_wraith> yeah, record syntax adds really confusing typed expressions, compared to what you write.
13:27:39 <monochrom> "s -> (a,s)" what do you propose to replace "a" there by?
13:27:52 <c_wraith> For extra confusion, did you know you can use record syntax with GADT syntax?
13:28:18 <frdg> monochrom, ski: I think im beginning to understand, one moment so I can think of a useful question
13:28:23 <ski> frdg : you need to bind the type variables `a' and `s', used in the type expression `s -> (a,s)', somewhere. the most straightforward way, and presumably what you want here, is to pass them as parameters to `Mem'
13:28:28 <monochrom> For bonus confusion, do you know how to add haddock comments to GADT syntax with record syntax? >:)
13:28:49 <c_wraith> I could probably figure it out with referring to docs
13:29:11 <ski> frdg : an alternative would be to replace one (or both) of them with some specific type. e.g. replacing `a' by `Int' or `Maybe s', or whatever you prefer
13:29:12 <monochrom> My impression is it's a bit self-inconsistent. But only a little bit.
13:29:14 <c_wraith> Though it might involve some wrong guesses
13:29:48 <monochrom> Eventually I decided that I cannot memorize it reliably, so I wrote a cheat sheet.
13:30:00 <ski> c_wraith : yea .. record selector functions shouldn't just be the name of the field, imho
13:30:43 <solonarv> monochrom: "add haddock comments to GADT syntax with record syntax" - oh no
13:30:48 <ski> kiwi_42 : mhm .. i was thinking perhaps you could CPS it
13:31:03 <kiwi_42> it's ok. Performance doesn't matter much here
13:32:10 <ski> well, i mean to reexpress `Int# -> [Int#]' as `forall o. Int# -> (Int# -> o -> o) -> o -> o', or something
13:32:39 <kiwi_42> ski: that doesn't sound clearer .. :shrug:
13:33:21 <ski> heh, nah. (raw) CPS rarely makes things clearer, i think
13:33:49 <solonarv> kiwi_42: note that forall x. (a -> x -> x) -> x -> x is isomorphic to [a]
13:34:06 <frdg> https://pastebin.com/UbFHzDfZ follow up question
13:34:08 <kiwi_42> wait what really
13:34:10 <kiwi_42> why?
13:34:15 <kiwi_42> or rather
13:34:16 <monochrom> solonarv: "to complete your training" >:)
13:34:19 <kiwi_42> how can I convince myself of that?
13:34:38 <solonarv> you can go one way with (\bld -> bld (:) []) and the other way with (\xs -> \f z -> foldr f z xs)
13:34:58 <kiwi_42> interesting!
13:35:11 <ski> kiwi_42 : you need to produce an `x' as output. you could directly use the `x' argument. or you could pass it to the callback function, with an `a'. possibly more than once. so, you need to have a sequence of `a's to do that
13:35:18 <monochrom> kiwi_42: Basically [] hates Int# but -> is OK with it so let's do church encoding.
13:35:28 <ski> @type GHC.Exts.build
13:35:31 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
13:35:48 <monochrom> and basically church encoding is converting [] to foldr
13:35:56 <kiwi_42> aha that explains the cryptic type that I used to see for (->)
13:36:00 <solonarv> @type GHC.Exts.build (:) [] -- overcomplicated identity function
13:36:01 <lambdabot> error:
13:36:01 <lambdabot>     • Couldn't match expected type ‘[a0] -> t’ with actual type ‘[a1]’
13:36:01 <lambdabot>     • The function ‘GHC.Base.build’ is applied to two arguments,
13:36:07 <kiwi_42> % :t (->)
13:36:08 <yahb> kiwi_42: ; <interactive>:1:2: error: parse error on input `->'
13:36:11 <solonarv> oops
13:36:14 <ski> there's a fusion rule, saying `foldr f z (build g) = g f z'
13:36:16 <solonarv> % :k (->)
13:36:16 <yahb> solonarv: (->) :: * -> * -> *
13:36:21 <solonarv> boo!
13:36:27 <ski> oh, and `build' is defined as `build g = g (:) []'
13:36:42 <solonarv> can't remember what the flag is to make it show the full kind
13:37:38 <ski> kiwi_42 : it's called "Church encoding". or maybe "Böhm-Berarducci encoding"
13:37:52 <kiwi_42> ski: thanks!
13:38:12 <solonarv> % :set -fprint-explicit-runtime-reps -fprint-explicit-foralls
13:38:13 <yahb> solonarv: 
13:38:18 <solonarv> % :kind (->)
13:38:19 <yahb> solonarv: (->) :: forall {q :: RuntimeRep} {r :: RuntimeRep}. TYPE q -> TYPE r -> *
13:38:39 <kiwi_42> yeah that's the one!
13:38:44 <ski> @type either
13:38:45 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:39:08 <ski> `forall o. (a -> o) -> (b -> o) -> o' is the Church encoding of `Either a b'
13:39:18 <frdg> https://pastebin.com/2g0Uuqq7 follow up question
13:40:19 <ski>   f' :: Num s => Mem s String
13:41:13 <ski> frdg : you can think of a value of type `Mem s a' as a "state-update", given an input state of type `s', it produces an output state of type `s'. it also produces a result of type `a'
13:41:49 <ski> in this case, the state is incremented, and you also get back a particular `String' as result
13:42:39 <ski> given a "state-update", you can feed it an initial state, and it'll produce a final state for you, together with an auxilary result
13:43:17 <ski> note that when you've gotten a `Mem s a', no state-updates have happened yet, since you haven't fed it the initial state to start it off with
13:43:21 <ski> frdg : does this help ?
13:43:48 <frdg> ski: ohhh, so we completely get to decide `a` when we create our function that is wrapped in Mem. So all Mem is a wrapper for a function that gives you a tuple `(Num s) => (s, whateverYouWant)
13:45:26 <ski> no, `Mem' knows nothing about `Num'
13:45:48 <ski> a `Mem s a' value is a wrapper for a ("state-update") function, of type `s -> (a,s)'
13:46:11 <ski> both `s' and `a' could be anything you want
13:46:23 <ski> e.g.
13:47:05 <oa> oh god CPS
13:47:08 <ski>   tickTock :: Mem Integer Bool
13:47:15 <oa> CPS never made sense to me
13:47:22 <ski>   tickTock = Mem (\n -> (even n,n+1))
13:47:53 <frdg> ski: I get it!!!
13:48:16 <frdg> im gonna go back to what you initially said to make sure
13:48:48 <ski> note, btw, that the (non-state part of the) result here depends on the state (unlike the example in your paste)
13:48:53 <frdg> we need to bind the variables when we create the function that were gonna wrap in Mem
13:56:10 <ski> frdg : well, you need to make a function that takes the input state (the "previous" state, before the update), and pass it to the data constructor
13:56:37 <ski> one way of doing that is by writing a function abstraction expression, a lambda expression
13:59:58 <maerwald> is SIGABRT an async exception? Is it documented somewhere what signals are? So far I know SIGINT and SIGTERM are
14:05:35 <solonarv> maerwald: looks like it's not
14:06:24 <solonarv> investigated by sending SIGABRT to what's basically (threadDelay 10000000 `catch` print)
14:09:38 <solonarv> perhaps you can install a custom signal handler that throws an exception
14:10:45 <maerwald> the question is if I should ;)
14:19:15 <monochrom> In System.Posix.Signals.installHandler, I'm reading its source code.  If I read it correctly, it doesn't take a look at its Maybe SignalSet parameter at all.   ???!!!
14:20:26 <monochrom> More than doesn't take a look.  It's completely unused.
14:22:17 <monochrom> hahaha and it has a comment "mask is pointless, so leave it NULL"
14:22:36 <monochrom> WHAT IS GOING ON??????
14:23:00 <maerwald> "Don't change this line"
14:23:04 <maerwald> Sth like that
14:23:05 <[exa]> well, mask is pointless
14:23:36 <Cale> monochrom: https://www.youtube.com/watch?v=7LNrGH-81aE
14:24:49 <ddellacosta> I can't read that word without thinking of the key and peele sketch now
14:25:10 <ddellacosta> sorry, was referring to Cale's yt link
15:16:37 <maralorn> I am looking for a secure standard, with Haskell support for, generating and verifying salted-and-hashed passworts.
15:18:29 <ddellacosta> may be helpful to you maralorn , I came upon a link to this person's packages the other day from a reddit post on dependencies: https://hackage.haskell.org/user/VincentHanquez
15:19:07 <ddellacosta> maybe https://hackage.haskell.org/package/cryptonite in particular?
15:20:41 <ddellacosta> however, I'm not a security person so take my recommendations with a grain of salt (ha)
15:21:09 <phadej> I'd use https://hackage.haskell.org/package/crypt-sha512-0/docs/System-POSIX-Crypt-SHA512.html
15:21:18 <phadej> "obviously"
15:22:48 <Eduard_Munteanu> maralorn, https://hackage.haskell.org/package/argon2
15:24:12 <phadej> oh, that's good one too
15:24:35 <heath> I was playing with pattern guards and realized there are going to be cases where I want specific errors to be propagated instead of relying on a generic error that i'd pass in the otherwise guard. tips on how I might do that?
15:25:08 <phadej> but argon2 binds to C libargon, which may or may not be a problem
15:26:21 <heath> this gist is silly and does a poor job of illustrating what I want, but I'd like to receive "foo: did not receive a 1" if the first argument is incorrect: https://gist.github.com/heath/721045247400eefe88abcebde67335ff i'd like to
15:26:33 <Eduard_Munteanu> phadej, I think it's included in the package, so it won't be an external dependency.
15:28:18 <phadej> Eduard_Munteanu: true, it's still C-code :)
15:28:41 <phadej> (though crypt-sha512 also relies on C implementation of sha512, so ...)
15:29:24 <phadej> heath: you might want try if https://github.com/futurice/haskell-futurice-prelude/blob/master/src/Futurice/Exit.hs abstraction works for you, then you'd have
15:30:12 <phadej> one <- exitIfLeft (foo n) $ \e -> modifyError e; two <- exitIFLeft (bar one) $ \e -> modifySecondError e ; ...
15:30:54 <phadej> or if you don't need to modify errors, than just use `Either` as a monad directly.
15:31:31 <phadej> do { one <- foo n; two <- bar one; three <- baz two; return (one + two + three) }
15:32:04 <phadej> (That exit pattern is useful if you want such short-cirtuing on top of IO e.g.)
15:32:12 <phadej> circuiting*
15:35:52 <heath> perfect 👌 thanks phadej 
15:36:50 <Eduard_Munteanu> Anyway, argon2 is probably much better than iterated SHA-512 or whatever the glibc guys pulled off.
15:37:37 <phadej> Eduard_Munteanu: yes, I needed specifically crypt-sha512 for compat reasons
15:38:54 <phadej> good to know it exists
15:38:56 <Eduard_Munteanu> C implementation is usually a bonus for crypto, since it's small and fast.
15:39:38 <phadej> and buggy
15:39:51 <phadej> (especially for bundled C-code)
15:40:22 <Eduard_Munteanu> phadej, less likely for something like a hash, they're usually small and thoroughly reviewed.
15:40:35 <phadej> This version provides bindings to the "20171227" release of the Argon2 
15:40:45 <phadej> latest release: 20190702
15:40:58 <phadej> not saying that latest is better, but still two years of stuff...
15:41:25 <phadej> (though, looks like no changes since 20171227)
15:42:15 <phadej> at least no entry in changelog...
15:42:23 <phadej> why I even looked there...
15:42:29 <Eduard_Munteanu> If the ABI didn't change, I guess you can use the use-system-library flag or replace it with the latest version yourself.
15:43:57 <phadej> my system version 0~20161029-1.1 is even older :(
15:44:23 <Eduard_Munteanu> I suspect most changes occurred to the command line tool rather than the actual algorithm.
15:44:28 <phadej> I guess it's not one of libraries for which distro (Ubuntu) maintainers make backports
15:44:33 <phadej> probably yes
15:45:24 <Eduard_Munteanu> I don't expect side-channel attacks to be an issue for things like these, but I'm a bit wary about Haskell implementations of TLS and stuff like that.
15:46:44 <Eduard_Munteanu> (though even for Argon2 it's good to make sure you do constant-time compares of hashes)
15:48:16 <Eduard_Munteanu> And a pure Haskell implementation may be slower and thus you'll work with reduced parameters. Not sure it's a really big deal, though.
15:49:11 <maralorn> phadej: Thank you. I realized that your lib is very useful because it is compatible to the mkpasswd utility that I was already using anyway.
15:49:45 <maralorn> Also your API looks like I can use it really easily.
15:51:58 <maralorn> otoh bcrypt sounds cool, too.
15:52:24 <maralorn> I am confused by an abundance of options. /o\
15:52:47 <koz_> Is there something 'fromMaybe mempty'?
15:53:22 <koz_> Yep, in relude. :P
15:54:20 <Eduard_Munteanu> maralorn, PBKDF2 < bcrypt < scrypt < Argon2... hard to say where crypt-SHA512 fits.
15:54:59 <Eduard_Munteanu> The old crypt algos were crap.
15:55:15 <phadej> i'd say it might be between bcrypt and scrypt
15:58:12 <solonarv> koz_: fromMaybe mempty = fold @Maybe
15:59:02 <koz_> solonarv: Oooh, neat!
16:07:23 <maralorn> fold @Maybe is nice!
16:09:52 <maralorn> Eduard_Munteanu: phadej: Will we are at it. After I have verified the user-pw against the argon2 hash I want to give them a token to save the authentication on the client. People recommended me jwt, I am considering https://hackage.haskell.org/package/fernet. Any better ideas?
16:38:41 <solonarv> I think if you are storing the token serverside you can just use a long-ish random string (from a good-quality RNG)
16:39:29 <solonarv> JWT is for when you want to store data *in* the token
17:36:32 <d34df00d> I always thought JWT is Java Widget Toolkit.
17:40:07 <xe4> I'm creating an instance of ToJSON where I return an object [...]; each element in the list looks like this:  "myKey" .= fmap MyObject (foo hasFoo)  ; is there a cleaner way of doing this?
17:40:51 <xe4> to be clearer: instance ToJSON (MyObject MyConstructor) where toJSON (MyObject myConst) = object [ ... ]
17:42:14 <xe4> object ["myKey1" .= fmap MyObject (foo myConst), "myKey2" .= fmap MyObject (bar myConst), ...etc.]
17:43:56 <koz_> :t all
17:43:58 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:49:59 <iphy> in wl-pprint, how would you undo all indentation/nesting for one line? I'm pretty-printing C code, and I'd like the "#define" and other preprocessor directives to start in the first column, regardless of nesting level
18:22:52 <koz_> :t for
18:22:54 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
18:22:59 <koz_> :t for_
18:23:01 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
18:26:59 <koz_> % :info for_
18:27:00 <yahb> koz_: for_ :: forall (t :: * -> *) (f :: * -> *) a b. (Foldable t, Applicative f) => t a -> (a -> f b) -> f () -- Defined in `Data.Foldable'
18:32:13 <freeman42x> doing a code review and run into this: https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/pull/62/files/e19ae29e5da8664dfe71df7d5c45dd1846c47c79#r407279369
18:32:58 <freeman42x> what would be a solution to that issue? what he is trying to do I think is to avoid repeating `/n` for each newline.
18:34:02 <Rembane> freeman42x: unlines maybe? Which line are you thinking about? 
18:34:51 <freeman42x> Rembane, check the link, it has example near my comment
18:35:55 <Rembane> freeman42x: Okay, intercalate works too, especially if it's Text you're working with 
18:36:21 <Rembane> freeman42x: Text has an unlines too, so that's nice. 
18:37:49 <freeman42x> Rembane, the issue is that his solution is more vebose than just using multiline strings + /n
18:38:19 <freeman42x> so I am looking for a solution based on his intention but that is less verbose than using multiline strings + /n
18:40:18 <jota191> Hi. Is there a way to profile compilation? I have a type level program that takes exponential time in the size of the input type to compile. I'd like to know what type families are the ones taking so much time to resolve
18:41:17 <Rembane> freeman42x: FWIW there's also mapM_ putStrLn 
18:44:33 <freeman42x> Rembane, how would that help avoid new lines?
18:45:10 <dsal> % mapM_ putStrLn ["just", "like", "this"]
18:45:10 <yahb> dsal: just; like; this
18:45:50 <dsal> (';' is is yahb for '\n')
18:51:43 <BobSacamano> Hello all. Sorry if this is too off-topic, figured this might interest some of you as I assume a bunch of you enjoy complexity theory. A friend of mine made a claim that he's adamant is true, but I'm skeptical. However, I cannot seem to prove it one way or the other.
18:52:16 <BobSacamano> He says that if a turing machine can take two CNFs and determine the satisfiability of them in polynomial time given 1 oracle query to SAT, then P=NP.
18:52:36 <nitrix> Vouching for BobSacamano if anyone someone has time, or knows a guy who knows a guy. Thanks :)
18:52:47 * BobSacamano bows down to nitrix
18:54:18 <BobSacamano> Right now, I'm trying to show that you can split up a CNF into two sub-CNFs, each over O(n) variables. Then if you pass these to the aforementioned turing machine, it must determine SAT over O(n) variables in polynomial time, and then you can easily decide satisfiability of the original CNF in polynomial time
19:00:32 <fishooter> hi, I'm writing a TCP server and I need to maintain some server state that is changed based on messages received from clients in various threads. What is the recommended way to go about this? Software transactional memory ?
19:02:15 <koz_> fishooter: I'm guessing the server state is global, not per-client?
19:02:30 <fishooter> yes, the state is global
19:02:48 <koz_> Then STM is probably a good place to start.
19:03:20 <fishooter> koz_: thanks :) If you know about some nice examples that do what I described I would appreciate that a lot :)
19:03:51 <koz_> fishooter: Have you looked at Simon Marlow's book?
19:03:57 <koz_> He talks about STM at quite some length, with examples.
19:04:43 <fishooter> nope, I'll have a look
19:05:11 <fishooter> I'm familiar with concurrent programming in other languages, I figured I would pick it up quickly in haskell just from specific examples :)
19:05:30 <koz_> fishooter: I... would suggest being a bit more thorough. Haskell solves these problems in a much more principled way.
19:05:36 <koz_> (specifically where concurrency is concerned)
19:06:05 <fishooter> :-)
19:06:19 <fishooter> I found this, seems quite nice
19:06:20 <fishooter> https://github.com/simonmar/parconc-examples/blob/master/distrib-chat/chat.hs
19:08:01 <fishooter> ideally I'd like to make some code that can also be mocked, i.e. to make an alternative implementation of the server where you give it a list of messages sent from clients, and it would set itself to the correct state
19:09:26 <fishooter> something like a Monad-mock :) https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/
19:11:06 <fishooter> I guess it's better to start writing code with this in mind
19:11:42 <fishooter> from the beginning, rather then implementing it for IO and then rewriting bunch of signatures to retrofit it for mocking
19:13:04 <koz_> If you're gonna be doing stuff async, you're in IO, like it or not.
19:13:14 <ddellacosta> fishooter: I'd highly recommend the book that goes along with that repo btw
19:13:26 <koz_> ... and what I mentioned is one of the reasons why.
19:13:39 <koz_> Haskell isn't a language where you can just randomly chuck stuff together based on examples and expect it to work.
19:15:06 <fishooter> koz_: that's exactly how I'm learning Haskell and so far it kind of works :)
19:15:20 <koz_> fishooter: You're in a for a _painful_ readjustment period.
19:15:35 <koz_> That 'kind of' will become less and less valid over time.
19:15:47 <fishooter> :-)
19:16:19 <ski> @where PCPH
19:16:20 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
19:16:20 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
19:16:39 <fishooter> how long do you think it would take to go through that book?
19:17:07 <fishooter> to the point that I could put this together?
19:17:18 <koz_> fishooter: How long is a piece of string?
19:17:26 <koz_> I have no idea what you understand about the problem domain or Haskell.
19:17:31 <fishooter> :)
19:17:32 <fishooter> Basically, the way how I imagine this to work is that 
19:17:36 <koz_> I don't know how well you learn in this format, from this book, etc etc etc.
19:17:39 <ddellacosta> fishooter: I'd start with the first chapter of the concurrency half of the book and see what you think. I think you'd find yourself satisfied
19:17:51 <koz_> I'd have difficulty answering such a question for _myself_, much less someone else.
19:18:39 <fishooter> the individual threads produce messages that get put into a consumer queue, and once the server completes them it will send it back to the threads
19:18:43 <fishooter> kind of like RabbitMQ
19:19:24 <fishooter> sometimes it may happen that the messages may be invalid state transitions, so it will just say to the client it doesn't accept it
19:20:29 <koz_> fishooter: You could do it this way.
19:21:00 <koz_> In fact, this is kinda the story the concurrency chapter develops, while showing several ways of dealing with it, and what problems arise from each one.
19:21:30 <koz_> s/chapter/section/
19:23:09 <fishooter> and can you mock this how I described?
19:23:29 <koz_> No, because you're in async, which means IO or go home.
19:23:36 <koz_> (at least not in the way you described)
19:23:56 <koz_> (and that section explains why, in pendantic and full detail)
19:24:55 <fishooter> even what I referred to before? https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/
19:25:53 <fishooter> I think it must be possible to design somehow to make it work, the question is just how cumbersome it will be :) 
19:26:08 <koz_> fishooter: How well do you understand extensible effects, specifically their difficulties with bracket and async?
19:26:25 <koz_> If the answer is 'not enough to write at least as much as Alexis King has on the subject intelligibly', the answer is 'no and don't even bother'.
19:27:07 <koz_> You're literally describing (roughly) the equivalent of using a flamethrower to kill an ant.
19:27:25 <fishooter> :-))
19:27:36 <koz_> Once again, _read_ _Simon's_ _book_.
19:27:46 <fishooter> yep, I'm on it :)
19:27:50 <fishooter> thanks for the advice
19:28:04 <koz_> Because had you done so by now instead of trying to convince yourself that you can just hack random stuff together, you would have seen how complex it all is, and how you can't just glue random stuff together and expect it to work in this case.
19:28:07 <fishooter> and for caring to not stray off the path :)
19:28:23 <koz_> Ehh, I'm a principled tentacle horror.
19:28:56 <fishooter> not sure if I get the reference :)
19:29:23 <koz_> fishooter: It's just me being strange, not a reference.
19:34:45 <fishooter> just a quick question -- do I need to have intimate undestanding of monad transformers / lenses for this?
19:34:58 <fishooter> for the material in the book
19:35:04 <koz_> fishooter: Lenses no, monad transformers maybe - I forget if they're used anyplace.
19:35:11 <fishooter> ok
20:42:22 <average> hi
20:42:25 <average> i don't want monads
20:47:55 <MarcelineVQ> average: https://imgflip.com/i/3wfeno
20:48:15 <average> MarcelineVQ: https://www.youtube.com/watch?v=ZbYwfpQTOPw#t=3m28s
20:48:41 <average> MarcelineVQ: that meme you just made..
20:48:48 <average> MarcelineVQ: you really think it's funny?
20:48:53 <MarcelineVQ> yes
20:49:11 <MarcelineVQ> You have to believe in your jokes or they can't survive.
20:49:29 <average> MarcelineVQ: tell me more jokes
20:50:47 <MarcelineVQ> Why didn't the pencil pass the test?
20:51:07 <MarcelineVQ> It wasn't sharp enough.
20:51:19 <average> not bad, not bad
20:51:22 <average> let's see more
20:54:39 <MarcelineVQ> That's all I got, it was all a sham
20:56:06 <average> MarcelineVQ: bruh.. it's not a sham, it's ok
20:56:29 <MarcelineVQ> Thank you for your support in this trying time.
21:04:58 <ski> @quote rules.of.Go
21:04:58 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
21:51:44 <freeman42x> got a Miso question: https://paste2.org/jZENcFvW
21:59:50 <dmj`> by far the most bizarre paste site I've ever seen
22:01:36 <freeman42x> dmj`, aight, let's try again: https://gist.github.com/razvan-flavius-panda/1a33fb4a5725a5d409bc56e816e35b31
22:07:04 <dmj`> freeman42x: you define them just as you have done. Is there a type error from doing that?
22:07:49 <freeman42x> dmj`, if I'd knew how to define them... why do you think I am asking the question?
22:12:23 <dmj`> freeman42x: updateModel Install          model  and updateModel (Append text)    model
22:12:29 <dmj`> those are two definitions, that you gave
22:14:13 <freeman42x> dmj`, I do not understand what you are saying. I hope it's not cause of some misinterpretation
22:15:07 <dmj`> freeman42x: what have you tried
22:15:54 <freeman42x> dmj`, I tried figuring out what to do... it did not work. Your question is not very useful since I would have mentioned anything I tried in the description.
22:17:11 <freeman42x> dmj`, what I am trying to do is basic Miso usage and I can't find any example of it
22:30:39 <dmj`> freeman42x: updateModel (Append text)    model = noEff m {  _log = _log model <> text }
22:31:12 <dmj`> freeman42x: appending Text isn't something that I should have to explain how to do
22:32:42 <dmj`> freeman42x:  updateModel Install model = effectSub model nixOsAtom
22:41:05 <freeman42x> dmj`, thank you. If `noEff model` gives a `Effect Action Model` what does this part `{  _log = _log model <> appendText }` do? I recall that `{}` can be used like code blocks in other languages but it's not clear what it does here
22:41:38 <dmj`> freeman42x: this is how you update a record in Haskell
22:42:03 <dmj`> freeman42x: noEff model {  _log = _log model <> text }, updates the model record's _log field 
22:42:34 <freeman42x> dmj`, woah, that is very cool. Is that a somewhat new feature? like last years or something
22:42:47 <ski> no
22:42:54 <dmj`> freeman42x: it's been in Haskell since the early days, maybe 90s ?
22:43:16 <dmj`> freeman42x: I recommend reading learn you a haskell, it will really help when using miso
22:43:40 <freeman42x> I read LYAH and many other Haskell books, but I forgot stuff over the years
22:44:03 <freeman42x> #notAFulltimeHaskellDev
22:44:07 <dmj`> freeman42x: You should definitely brush up on it. Things will make much more sense
22:44:14 <ski> @where tutorial
22:44:14 <lambdabot> http://www.haskell.org/tutorial/
22:44:28 <ski> might perhaps work as a refresher ?
22:44:40 <freeman42x> dmj`, based on what I already know it would be better to learn as I do. Would probably want to use lenses over that I think
22:45:40 <dmj`> freeman42x: suit yourself, but remember google is your friend. Something this brief might even be beneficial, https://learnxinyminutes.com/docs/haskell/
22:46:02 <freeman42x> dmj`, ah yeah, love that site, very good to refresh stuff
22:47:44 <freeman42x> pretty sure I went through that site quite recently, didn't realise I forgot that part. Unkown unknown
22:53:47 <freeman42x> dmj`, I don't understand how to fix so that the types match here: https://i.imgur.com/qtYDESe.png
22:58:59 <dmj`> freeman42x: effectSub model (liftIO nixOsAtom)
22:59:14 <dmj`> effectSub model (liftIO . nixOsAtom) *
23:02:37 <kozmicluis> Hi there, I remember there was an arrow monoid operation to simplify this idiom: zip xs (tail xs)
23:02:43 <kozmicluis> into something like zip <> tail or idk
23:02:50 <kozmicluis> does anyone know?
23:03:18 <c_wraith> :t zip <*> tail
23:03:20 <lambdabot> [a] -> [(a, a)]
23:03:27 <ski> @quote aztec
23:03:27 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
23:04:02 <kozmicluis> oh right, it works!
23:04:07 <kozmicluis> does it have a name?
23:04:24 <kozmicluis> I want to convert the idiom to JS and give it a name
23:04:39 <kozmicluis> something like juxt, converge, etc
23:04:43 <c_wraith> In this particular case, it's the S combinator
23:04:51 <kozmicluis> nice, tysm
23:05:23 <ski> @where 21-days
23:05:24 <lambdabot> "Teach Yourself Programming .." by Peter Norvig at <https://www.norvig.com/21-days.html>
23:06:12 <dmj`> ski: that is a great article
23:07:16 <monochrom> The comic is great.
23:08:21 <monochrom> All of you who think you can do dive-in projects: No, you will only do recreational programming for at least 2 years.  After that you may be ready for projects, but only under guidance from others.
23:08:23 <average> an article titled "Haskell made me $0" would be great
23:08:29 <average> The Truth hurts..
23:09:08 <average> "Monads/Lenses gained me -$10k in time spent not getting clients/contracts"
23:09:15 <average> The Truth hurts..
23:10:13 <average> or.. if you prefer a positive twist..  "I made way more money writing Bash than writing Haskell"
23:12:09 <monochrom> I make more money teaching haskell than writing haskell. >:)
23:12:43 <Welkin> monochrom: you make money teaching?
23:12:52 <monochrom> Yes.
23:12:54 <Welkin> I think you mean you make money writing research papers
23:13:01 <average> monochrom: you're basically taking money from students
23:13:07 <average> monochrom: that's why all these students broke..
23:13:50 <Welkin> monochrom: do you force students to buy your unedited, non-proofread, error-filled, rambling, spiral bound $200 "textbook"?
23:14:07 <Welkin> I have a professor like that
23:14:10 <Welkin> in electrical engineering
23:14:14 <Welkin> had*
23:14:25 <monochrom> Yes and no. This is Canada. I take more money from the government than from the students. Still, you can be right that students don't have a lot, so taking a little is still taking a lot.
23:15:06 <monochrom> Fortunately(!), since this is Canada again, it is not a lot of money I gain.
23:15:30 <monochrom> No, they buy nothing.
23:16:11 <average> they buy the monochrom experience
23:16:29 <average> "You muh studenz! yo check out dis monad here!"
23:17:12 <monochrom> Yes, I give them my own monad tutorial. At no charge.
23:17:18 <average> honestly, what would you say Haskell is for? like.. seriously..
23:17:53 <Welkin> average: are you new here?
23:18:17 <average> Welkin: in a way yes..
23:18:21 <Welkin> I think you joined a couple nights ago and asked an incredibly stupid question
23:18:26 <Welkin> leading me to believe you are a troll
23:18:26 <dmj`> average: it's a general purpose programming language, so similar to java / python or something. 
23:18:38 <Welkin> "what's the point of FP" or something
23:18:43 <dmj`> average: in regards to what you can do
23:18:54 <monochrom> I say it's good for almost all programming.  There are a few exceptions and only because of { no one bothered to make a good library, high performance, low level }
23:18:58 <dmj`> average: you're only bounded by your own imagination.
23:19:29 <average> no but.. as a professional, I kindof have a feeling what mainstream languages are good/bad at..
23:19:36 <average> but when I look at Haskell.. I'm totally confused
23:19:42 <average> ok, it's FP..
23:19:54 <monochrom> I have an automarking system I wrote in Haskell and I use for running tests on student homework and entering marks into a marks file.
23:20:02 <average> so.. when would I pick Haskell?
23:20:26 <average> saying "Oh, let me tell you, you can use Haskell for everything". No, that's not the kind of answer I'm looking for
23:20:39 <c_wraith> What would you use java for?
23:20:41 <Welkin> we get a lot of trolls like you
23:20:44 <Welkin> it's not uncommon
23:20:45 <c_wraith> All the same things.
23:21:18 <freeman42x[m]> average: you can use Haskell for everything, just need to use a typesafe DSL on top of C and stuff like that xD
23:21:21 <average> c_wraith: Java tends to be used for web apps written by large teams
23:21:50 <average> that's a very pragmatic, down-to-earth assessment
23:21:57 <average> can I ask you what Haskell would be used for?
23:22:03 <Welkin> programming
23:22:04 <average> or is it too much to ask?
23:22:14 <monochrom> If you're looking for such shallow stereotypes, I'm not going to give you one.
23:22:19 <Welkin> I use it for web servers mostly
23:22:27 <Welkin> a lot of people use it to write compilers
23:22:36 <Welkin> facebook uses it for spam detection
23:22:38 <average> Welkin: there is a web server, it's called nginx. have you heard of it?
23:22:47 <Welkin> Standard Chartered uses it for building banking systems
23:22:53 <average> Welkin: FB has 1 person working in Haskell on spam detection
23:22:55 <Welkin> okay
23:23:06 <average> 1 person
23:23:06 <Welkin> confirmed troll here
23:23:11 <monochrom> Still, I did say there are a few things Haskell won't be suitable for.  I know its weaknesses.  There are only a few.
23:23:12 <Welkin> average: goodbye
23:23:18 <Welkin> don't let the door hit you on the way out
23:23:32 <Welkin> don't engage with this person any longer
23:23:34 <average> Welkin: I was asking a serious question
23:23:45 <c_wraith> then why were you so wrong about facebook?
23:24:40 <average> 06:22 < Welkin> a lot of people use it to write compilers
23:24:44 <average> that might actually be true
23:24:50 <Welkin> I am putting you on ignore now
23:25:10 <average> Welkin: you are a troll, not me
23:26:07 <dmj`> Welkin: let it go man
23:26:56 <Welkin> I don't have patience for trolls these days
23:27:52 <average> "I use it for web servers mostly" ..
23:27:59 <average> like.. really.. 
23:28:04 <dmj`> average: Haskell is used for a lot of things, static analysis tools, compilers, databases, web servers, data analysis, statistical learning.
23:28:09 <average> nginx..apache.. hello..?! ..
23:28:34 <dmj`> I used nginx as a reverse proxy for a haskell web server
23:28:41 <dmj`> to a*
23:28:42 <average> dmj`: static analysis tools yes, I've seen a few and it does well in that area
23:28:55 <average> compilers, one or two, but mostly prototypes that faded away
23:29:12 <average> dbs/web_servers/data_analysis/stats_learning .. uhm no
23:29:18 <average> those i haven't seen it used for
23:31:00 <dmj`> average: yes, a DBMS has many compilery aspects to it, haskell is great for lexing / parsing, but then also AST traversals, compiler optimizations and code gen. Companies do do that yes.
23:31:16 <monochrom> Other people have seen more than you have, even done more than you have seen.  This is the whole point why you asked.  Tell me this is true.
23:31:24 <freeman42x[m]> average: do you think that since nothing significant has been created in those areas it means Haskell is not useful or can't be used for that or what do you think? You know it is a general-purpose programming language
23:31:34 <dmj`> average: I've used Haskell for statistical learning with hmatrix, anything with a C API, Haskell does /very/ well with.
23:33:00 <dmj`> average: It's hard to believe, but everything you've heard about Haskell is a lie, and I'm asking you to take the red pill and continue with me down the rabbit hole. Otherwise, you can take the blue pill, and wake up tomorrow and remember none of this.
23:33:10 <monochrom> Tell me your logic is not "if you use haskell for web servers you should stop immediately and switch to apache so that my self-fulfilling prophesy 'haskell not for web servers' is true"
23:33:14 <average> I'm a firm believer that certain languages have constructs to allow one to write in a short amount of time something..
23:33:17 <average> Perl is great for parsing logs
23:33:18 <freeman42x[m]> average: there are only 2 things I can think of that limit Haskell usage somewhat yet have solutions also: garbage collection delays and generally not being as performant as C
23:33:26 <average> that's an example
23:33:35 <monochrom> Your firm belief is wrong.  Relax it.
23:35:22 <freeman42x[m]> average: Haskell is more about writing correct, maintainable, non-duplicated code (cause of lack of powerful abstractions) than getting started with a project quickly. And once you have everything set up on your computer starting new projects does not take that much
23:35:28 <dmj`> average: the haskell spam team at FB shows GHC handling a million requests a second. https://engineering.fb.com/security/fighting-spam-with-haskell/
23:35:47 <dmj`> average: "The Haskell-powered Sigma now runs in production, serving more than one million requests per second."
23:36:00 <dmj`> I don't think they're lying about that
23:36:02 <average> freeman42x[m]: but is this really a problem? non-duplicated code was avoided since advent of the function..
23:36:51 <average> dmj`: is FB really an authority in fighting spam..
23:37:00 <monochrom> It is a real problem if the language makes it hard to do higher-order functions or local functions.
23:37:03 <average> dmj`: like.. literally nobody takes any news on FB seriously..
23:37:13 <average> dmj`: or anything they read on there. it's mostly memes..
23:37:33 <monochrom> For example C functions are a joke.
23:37:47 <monochrom> Even Algol 60 is better than that.
23:37:55 <average> dmj`: like.. you have a guy called Zuck who wrote some app to share photos, and now it's world-wide.. and people share cat pics and memes
23:38:01 <freeman42x[m]> average:  do you know how polymorphism, higher kinded types, dependent types, etc. reduce code duplication and technical debt? languages that do not have those features are basically forced to write the same code over and over again or use some terrible hack
23:38:06 <average> dmj`: and FB sells ads and user data
23:38:16 <average> dmj`: where's the need for spam detection.. you tell me..
23:38:21 <average> cause i don't know..
23:39:19 <dmj`> average: if you watch facebook's engineering conference videos they go into great detail about how spammers in southeast asia attempt to get FB users to DDOS themselves, and how they use Sigma to attempt to detect requests that look like self-XSS, among other things, to keep people from accidentally propagating ads on their feeds.
23:39:32 <dmj`> er, to XSS themselves**
23:39:49 <dmj`> average: to go facebook.com on chrome and hit ctrl+shift+j and you'll see it
23:41:50 <freeman42x[m]> dmj`: the code compiles but it does not update the textbox, I'll try to figure out why not. Could I DM you something?
23:42:06 <dmj`> freeman42x[m]: you can post it here
23:43:07 <freeman42x[m]> dmj`: no, I can't needs to be DM. That is why I asked for permission
23:43:29 <dmj`> freeman42x[m]: why does it need to be a DM?
23:44:10 <dmj`> freeman42x[m]: just post it here, someone else might be able to help you
23:44:31 <freeman42x[m]> dmj`: why is sending you a DM such a big issue? I'd rather we not spamm about that this channel too much. No, it's not a question. As I said, it's something I want to say to you in DM
23:44:48 <dmj`> freeman42x[m]: this channel is designed to help people who have questions about haskell programming
23:45:16 <freeman42x[m]> dmj`: ^ `No, it's not a question. `
23:46:22 <average> dmj`: http://multicore.doc.ic.ac.uk/iPr0gram/slides/2015-2016/Marlow-fighting-spam.pdf
23:46:30 <average> dmj`: i hear you, but.. it's not even OSS..
23:46:37 <monochrom> perhaps it is not even about haskell?  perhaps it's a discussion on something best done in private, such as "could we both work together to secretly donate money to monochrom? I love him!"
23:47:35 <freeman42x[m]> yeah, I don't get why someone would have issues with understanding that I have something to tell him in DM which is not something that should be in a haskell channel since it is not on topic and it is for him only
23:48:38 <dmj`> freeman42x[m]: whatever you think you need to say to me in private, you can say to me in public. And if you plan on giving bitcoin to monochrom, I think others would like to know this fact as well.
23:49:11 <average> monochrom: you must be getting so much money from these IRC people
23:49:14 * ski isn't sure why one wouldn't just PM ..
23:49:29 <freeman42x[m]> dmj`: `whatever you think you need to say to me in private, you can say to me in public.` No I can't say it here since it is OFFTOPIC. Why is this so hard to understand?
23:49:36 <average> ski: it's considered "rude" and also not nettiquette
23:49:41 <MarcelineVQ> pms are lame because only one person benefits from them
23:49:59 <MarcelineVQ> And no one can help assist
23:50:00 <ski> not really heard that before, on this network, average
23:50:09 <average> ski: i've heard it a lot of times
23:50:19 <monochrom> This is such a Mexican standoff.
23:50:42 <freeman42x[m]> monochrom: the fact that you knew what I was going to DM him (secretly donate money to monochrom) makes me think that you found another usage for Haskell in mind reading machines
23:50:46 <ski> but yes, if people ask me questions in PM that would better be served asked on the channel, i typically say so, and then don't respond in particular to the question in PM
23:51:03 <monochrom> :)
23:51:51 <dmj`> freeman42x[m]: I don't want to talk to you about offtopic things in a DM, I'd rather have you post your Haskell questions here so we can all help you. I sense this is a bait and switch so, I'm just going to call you out on it :) 
23:54:02 <jeetu> If somebody does not want to be part of DM transaction, I think that we should not to try persude him/her to. 
23:54:48 <average> jeetu: but that takes away the freedom of freeman42x[m] , who should be free to ask to slide into someone's DMs
23:55:02 <average> jeetu: i mean why shouldn't he slide into dmj` 's DMs..
23:55:17 <average> jeetu: is dmj` so special to not receive unsolicited DMs ?
23:55:23 <freeman42x[m]> dmj`:  What I want to say to you in DM is not on topic for haskell but of probably of interest to you. I have no Haskell question to DM you... why do you keep dwelling on something I said I will not do? I have a good understanding that technical questions are best asked in public so more can benefit. So stop repeating that - it's wrong. No idea what you mean I am baiting and switching you about... Seems like you are
23:55:23 <freeman42x[m]> illogically assuming I am using some dishonest tactics - which I know I am not. This is my last message regarding me DM-ing you. I won't reply further since this is basically OFFTOPIC spamm in this channel which could have been averted with a simple yes or no from you
23:55:45 <MarcelineVQ> regardless of other considerations, there is no person more suited to helping with miso than dmj` so it'd be a good idea to follow the protocol being requested by dmj` if you want help with miso.
23:56:07 <average> MarcelineVQ: what's miso?
23:56:29 <monochrom> It makes me hungry. I miss going out to Japanese restaurants.
23:56:33 <MarcelineVQ> a system for inventing and compiling single page webapps entirely in haskell
23:56:42 <maerwald> using ghcjs
23:56:42 <koz_> monochrom: Hear hear.
23:56:54 <average> MarcelineVQ: we need SPAs in Haskell sooo much..
23:56:54 <dmj`> monochrom: me too
23:57:00 <average> MarcelineVQ: i bet everyone's been waiting for that
23:57:12 <MarcelineVQ> average: well sure, why not? maybe they can finally be done right here :>
23:57:12 <jeetu> average: one's liberty should not restrict others'. Thats the axiom in the liberty universe.
23:57:24 <average> jeetu: yes it is, also in law
23:57:29 <dmj`> average: well, a lot of people seem to be ditching Elm for it these days so, there's some demand, albeit not much. Big tech rules the roost.
23:57:31 <maerwald> The less web, the better. I don't see myself writing anything web-related except when someone pays a lot of bucks
23:57:44 <MarcelineVQ> I'd be doing it in idris myself but ghc is so damn good and there's so many libraries on hackage
23:57:58 <MarcelineVQ> So it's a no brained to prefer haskell for most things
23:58:05 <MarcelineVQ> no brainer :>
23:58:05 <average> dmj`: but why does big tech rule the roost?
23:58:14 <average> dmj`: perhaps.. because it's better at it?
23:58:20 <Welkin> I'd like to use miso, but ghcjs is the major blocker, sadly
23:58:22 <freeman42x[m]> MarcelineVQ: is dmj` the same as David Johnson / dmjio ? if he is then... we been already DMing eachother on Slack lol
23:58:24 <zincy_> Obvious troll is obvious.
23:58:31 <Welkin> can't install it without nix, can't install nix without some major workarounds
23:58:41 <Welkin> I hope this improves
23:59:07 <Welkin> bucklescript/reasonml (the ocaml -> js compiler) is dead simple to install: npm install bsb-platform
23:59:09 <dmj`> average: the big fish eats the small fish until they're so big nothing can eat them.
23:59:16 <average> dmj`: you're soo.. wanted by these ppl who want to DM you
23:59:20 <average> dmj`: teach me how to be like you
23:59:25 <average> I want people to DM me
23:59:29 <freeman42x[m]> dmj`: haha, that comparison with fish sounds like agari.io
23:59:43 <maerwald> Welkin: probably not
23:59:58 <MarcelineVQ> freeman42x[m]: with 99% sureity
