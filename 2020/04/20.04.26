00:00:45 <c_wraith> but line 69 is actually providing values of a rigid type, which can't unify with the second rigid type.
00:01:16 <c_wraith> Hmm, that feels a bit sketchy.  I'd be happier if both were rejected, given that impredicative instantiation isn't really supported.
00:02:18 <c_wraith> Oh, maybe I'm looking at it backwards, and the lack of impredicative instantiation is why it works.
00:02:55 <c_wraith> It checks the expression against the type ascription, sees that it's properly polymorphic, and then monomorphizes it when it's an arugment to >>=
01:01:14 * hackage autoapply 0.1.0.0 - Template Haskell to automatically pass values to functions  https://hackage.haskell.org/package/autoapply-0.1.0.0 (jophish)
01:02:21 <jophish> Every time I publish a package the notification on IRC makes me excited that someone noticed and said something
01:04:08 <koz_> jophish: Do you want a senpai to notice you?
01:05:04 <jophish> doesn't have to be a senpai
01:55:00 <merijn> jophish: If you're using cabal-install, you can use "cabal haddock --haddock-for-hackage" to generate the docs and upload them with "cabal upload --documentation" so you don't have to wait for the documentation builder to fire
02:32:00 <jophish> merijn: oh, I did that for the candidate, but perhaps forgot to publish them
02:32:56 <merijn> jophish: Yeah, you need to publish the docs separately from the source
02:33:36 <jophish> hmm, as it happens I can't generate hackage compatible docs at the moment. I can't compile below 8.8 and hackage doens't have base 4.13
02:33:51 <merijn> ah...bah
02:35:48 <jophish> merijn: published, the only link to base is `String` so I probably shouldn't be too worried https://hackage.haskell.org/package/autoapply-0.1.0.0/docs/AutoApply.html
02:41:57 <mpickering> What is the recommended package for a queue?
02:42:24 <merijn> mpickering: What sorta behaviour are you looking for?
02:43:35 <mpickering> I want something which has O(1) uncons but also checks for duplicates on inserts
02:43:50 <mpickering> The current implementation uses an IntSet with `minView`
02:44:03 <mpickering> I don't actually car what order the things come out though
02:44:16 <merijn> ah, so priority queue
02:44:22 <mpickering> Ideally I would use `HashSet` but that doesn't implement `minView`
02:44:45 <__monty__> @hackage pqueue
02:44:45 <lambdabot> http://hackage.haskell.org/package/pqueue
02:44:54 <__monty__> That's what I settled on before.
02:44:57 <mpickering> but I don't care about the order
02:45:29 <__monty__> Then why does HashSet's lack of minView matter?
02:45:43 <merijn> __monty__: No O(1) uncons, I guess?
02:46:14 <koz_> minView is O(log(n)) anyways.
02:46:22 <koz_> Anything analogous that could exist for HashSet would be too.
02:46:30 <mpickering> log n uncons is also fine
02:46:33 <merijn> koz_: Get outta here with your logic!
02:46:45 <koz_> merijn: Asymptotic analysis of data structures, actually. :P
02:46:53 <mpickering> but I want to replace an `IntSet` with something like a `HashSet` so I don't have to use ints as keys 
02:47:25 <koz_> mpickering: I kinda miss the notion of 'choose :: HashSet a -> Maybe (a, HashSet a)'
02:47:29 <koz_> I wish it existed.
02:49:44 <mpickering> perhaps I just keep a `[k]` and then check if they are in the hashmap as they get processed
02:56:55 <__monty__> mpickering: Actually, can't you use toList on a HashSet if that'd be ok?
02:57:12 <__monty__> It's produced lazily so accessing a single element should be "O(1)"?
02:58:13 <__monty__> I'd assume it's no slower than keeping an additional list and checking membership but I don't have any numbers of course.
02:59:29 <koz_> Also, would being a member of Enum be enough?
02:59:37 <koz_> Because if so, you could use an IntMap.
03:01:08 <__monty__> I guess all you really need is *a* hash from your values to an Int. You can just store the value at that key, right?
03:05:14 <mpickering> keys are filepaths so no
03:07:44 <__monty__> Ah, and you're using IO to normalize the paths?
03:07:56 <mpickering> No they are already normalised
03:07:59 <mpickering> and also store the hash
03:08:17 <mpickering> I am doing what I suggested with the list
03:08:46 <__monty__> Why not toList?
03:08:47 <jchia_> stack question: How can I build a 'full' stack-build docker image, i.e. one containing packages so that I don't need to download from hackage when I stack build? The fpco/stack-build image at docker hub (https://hub.docker.com/r/fpco/stack-build) is for building only, and the associated Dockerfile does not define how to build a full image.
03:10:07 <__monty__> Oh, I guess you'd be constructing a new list every time you switch from deleting to inserting.
03:10:53 <mpickering> ^
03:12:13 <__monty__> jchia_: I'm curious, what's the use-case for such a multi-GB container that'll only remain current for a relatively brief period?
03:12:34 <jchia_> __monty__: Being robust against lousy Internet.
03:12:54 <jchia_> When Internet is down, i still need to do full builds
03:13:26 <__monty__> Stack isn't able to use cached packages in such a case?
03:13:34 <jchia_> What's "brief" for you? I changed the resolver once every few months only.
03:13:52 <__monty__> How often do you add a dependency?
03:14:06 <jchia_> __monty__: .stack is opaque. What I want a new temp user to do a full build?
03:14:13 <jchia_> I can't just copy .stack from one user to another
03:14:46 <jchia_> __monty__: Maybe once a month? But it doesn't matter as long as I have every package from the resolver in the image.
03:15:05 <jchia_> Or at least a subset that covers the vast majority of what I will need
03:15:09 <__monty__> Oh, you want an image with all of stackage?
03:15:28 <jchia_> or a subset that covers the vast majority of what i'll need
03:16:03 <jchia_> I can't just copy. stack from user to user.
03:16:36 <__monty__> Fwiw, Nix makes this kinda possible. (Don't tell merijn I mentioned it though ðŸ¤«)
03:16:41 <jchia_> if i had a stack-build image that had packages in it, then i won't have to download packages when a new user needs to build
03:17:04 <jchia_> I've hard of nix. Seems complicated. I don't have time to invest in it right now.
03:17:09 <jchia_> "heard"
03:21:32 <maerwald> yes, you don't "just" switch to nix
03:23:42 <__monty__> True, you get a taste and then you're hooked ; ) It's useful as a way to optimize docker containers too though.
03:24:16 <maerwald> or: you get a taste and decide no thanks :)
03:25:41 <maerwald> @hackage acme-everything
03:25:41 <lambdabot> http://hackage.haskell.org/package/acme-everything
03:25:43 <maerwald> :P
04:10:34 <Arahael> My problme with nix is that Apple seems really hostile to it. :(
04:12:58 <Uniaika> Arahael: because Catalina will prevent from mouting /nix ?
04:13:27 <Arahael> Uniaika: Amongst other irritations.
04:13:53 <Arahael> Eg, no sandboxing.
04:14:34 <DigitalKiwi> nixos replaced macos on my mbp (:
04:14:42 <Arahael> And the inability to say, develop an iOS app with nix - I imagine it's _possible_, but one update to xcode, and it'll all probably break.
04:14:57 <Arahael> DigitalKiwi: Very nice. :)
04:17:19 * DigitalKiwi wonders if this works https://github.com/reflex-frp/reflex-platform
04:18:05 <maerwald> Arahael: that's what you get with opinionated tools that make a lot of assumptions
04:19:02 <maerwald> sometimes these assumptions break, likely because they aren't even part of any standard (and even then, they might)
04:19:03 <Arahael> maerwald: Would love to agree with that, but I think it's more that Apple is insisting that it's their way only.  Eg, Go is arguably even more "opiniated", yet would work just fine in nix.
04:19:27 <maerwald> Arahael: well, it's not just apple. There are huge assumptions about build systems as well. And if one doesn't comply, it needs heavy patching.
04:19:54 <Arahael> maerwald: It wouldn't neccessarily surprise me if in 10 years Apple were to simply ban all these alternative build systems if one wishes to write apps for their phones.
04:19:57 <maerwald> But that "compliance" isn't really part of FHS, or any other standard
04:20:57 <Orbstheorem> I have a question regarding netwire: Are wires asynchonous? Can I "spawn" a wire that's polling network events in a separate thread so that when I run stepSession every so often I will receive network events in order?
04:23:07 <Arahael>  I still need to properly learn nix, it's hard learning a whole new systme when it's so different.  Been running it on nixos for a while now.
04:25:05 <maerwald> Arahael: there's no structured way to learn it, just stuff you come across while fixing problems
04:25:13 <Orbstheorem> DigitalKiwi: I got reflex-platform working on Nixos, but I couldn't add reflex as a lib to my project because it's broken on nixpkgs.
04:26:23 <Arahael> maerwald: Right.  So a big dive right into nixos while doing a million other tasks is a bit...  Difficult. :)
04:27:11 <Orbstheorem> Arahael: I allocated a weekend and a checklist of things I needed running when I switched from debian :)
04:27:39 <Orbstheorem> (I had been toying with it in a VM before)
04:27:53 <maerwald> a weekend? :o
04:28:05 <Orbstheorem> Well, More like two half days ^^
04:28:20 <Orbstheorem> But yeah, I told myself, this weekend I'll get NixOS working
04:28:30 <Orbstheorem> Installing is pretty straight forward
04:28:48 <maerwald> Gl setting up your vim
04:28:49 <sushi57> hello, i am trying to create a search space for my assignment. I need to generate search space like this [1], [1,2], [1,3],[1,2,3], [1,3,2],[2],[2,1], [2,3]... Do you guys have some idea how should I approach this?
04:28:50 <Arahael> Orbstheorem: Ah, that's relatively easy.  Trouble is, I'm a bit of a polyglot dev and I tend to nearly randomly jump into various languages...  And it turns out that the ecosystems for each language aren't completely unified, ie, it's one way of doing things for python, another for haskell, another for Go, another for C, another for... You get my drift?
04:29:10 <Arahael> Orbstheorem: And all along it, it insists on using bash for my shell. *cries*.
04:30:02 <Arahael> But yeah, installing nix itself and setting up services is relatively easy.  I did that in the same weekend, myself.  You can even do that much without learning any Nix.
04:30:03 <Orbstheorem> Arahael: Yeah, but nix-shell work surprisingly well. The only thing you cannot do is `sudo make install` or `sudo pip install` or ...
04:30:45 <Arahael> Orbstheorem: Try the likes of cython with cgo.
04:30:46 <Orbstheorem> That said I used to keep a debian chroot around, which I don't use anymore...
04:30:56 <Arahael> Hmm.  A debian chroot, now that's a great idea.
04:31:12 * Orbstheorem misses schroot & sbuild
04:31:24 * Orbstheorem started packaging it but got distracted
04:31:42 <Orbstheorem> Netwire, anybody? :(
04:32:32 <DigitalKiwi> why would you sudo make install sudo pip install anyway that's crazy talk
04:32:38 <Orbstheorem> sushi57: Can you state your problem in a set of rules? Maybe by looking at your set of rules you'd get some insight about the solution.
04:33:04 <Orbstheorem> DigitalKiwi: Agree, but most READMEs in the internet do unfortunatelly not :(
04:33:18 <Orbstheorem> The internet is a horrible place :(
04:33:24 <sushi57> Orbstheorem: I am solving Modified Postâ€™s Correspondence Problem.
04:33:42 <cyris212> Why does Semigroup's sconcat require a NonEmpty list?
04:34:40 <cyris212> And is there an alternative implementation which works with a regular list?
04:34:41 <Orbstheorem> sushi57: start with the trivial implementation and refine from it?
04:36:00 <sushi57> Orbstheorem: My current approach is try to generate all possible arrays of sizes 1 to N of indexes.
04:36:18 <Orbstheorem> I don't understand what you're asking for: Are you asking how to create an infinite list in haskell? (i.e. syntax), how to decompose your problem in functionnal structures or how to optimise it particularly for haskell?
04:39:22 <sushi57> Orbstheorem: Yes, I am asking how to create this search space in Haskell. It's basically a search space for backtracking algorithm but I am having hard time implementing it in Haskell.
04:41:53 <sushi57> Orbstheorem: basically I want to create a function `successor :: [Int] -> [[Int]]` and if I use successor [1] I get [[2], [1,2]] or something similiar
05:29:29 <sheepfleece> It is not exactly Haskell related, but still. How do you keep your modules straight (i.e. without cyclic dependencies)? I have a bunch of functions which retrieve data from DB and store it in a specific type, but those functions should be called from a module this type we are retrieving is defined in! And this happens all the time.
05:29:58 <sheepfleece> I guess I can have `Model.hs` module or something, but then everything will be defined in different places, which is not nice either.
05:32:09 <hpc> what works for me is don't try to "alphabetize your code", so to speak
05:32:48 <hpc> instead of sorting your code into "all my types in this file", "all my db functions in this file", find some logical unit of code that's more like "this code handles users"
05:33:08 <hpc> think of what the api for users is, and expose that in Users.hs
05:33:20 <hpc> and it has all the types and functions that logically relate to it
05:33:48 <hpc> then it becomes a matter of looking a level up, at what your code is meant to do in the first place, and making sure that logic doesn't have any loops
05:33:53 <hpc> which i find is much easier
05:34:44 <sheepfleece> That should work, thank you! Though I would need to write modules like Database.Generic which will expose some common API for all those logical modules.
05:35:46 <merijn> tbh, the need to keep module dependencies aclycic is just a flaw in GHC
05:36:45 <merijn> sheepfleece: Incidentally, "a Model.hs with everything defined in other modules" is exactly how I have things set up right now
05:39:50 <maerwald> GHC itself uses quite a lot of boot files
05:40:01 <maerwald> I don't understand why people don't like them
05:40:23 <merijn> maerwald: Because they're super fiddly to get working
05:40:25 <maerwald> it marks a module cycle and I can see what exactly
05:40:36 <maerwald> merijn: dunno about that
05:41:03 <merijn> maerwald: I've tried using them 5 times. Each time I was unable to get my code to build succesfully despite spending about an hour each time
05:42:22 <maerwald> weird, it took me 5 minutes, but it was only 1 or 2 functions that were cycloic
05:45:02 <hpc> i am kind of the opposite
05:45:18 <hpc> in other languages when i encounter cyclic imports, it takes me a lot longer to figure out the intent of the code
05:45:28 <merijn> hpc: It Depends
05:45:33 <merijn> (TM)
05:45:34 <hpc> because i can't read through it as linearly as i could with haskell
05:45:37 <hpc> nice pun
05:47:19 <maerwald> hpc: I like tree-like structure of modules, but even in haskell, you rarely get that
05:47:39 <merijn> hpc: So, concrete example, at one point I was working on a pure Haskell ZeroMQ implementation. I had one module dealing with connection authorisation and one module dealing with the initial handshake, but these refer to each other a lot. So I ended up having to have one module that had all the authorisation datatypes and the handshake ones, because they referred to each other. Rather than being able to 
05:47:39 <maerwald> something from Foo.Bar.Baz should never reach out to anything from Foo.*
05:47:45 <merijn> simply keep the authorisation datatypes in the Auth module and the handshake stuff in the handshake module
06:15:14 * hackage dobutokO2 0.36.3.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.36.3.0 (OleksandrZhabenko)
06:16:28 <maerwald> This package gets a LOT of updates every day
06:16:33 * merijn resets his sign. "It has been 0 days since I had to try filter in ghci to remember which way it goes"
06:16:46 <merijn> maerwald: Yes, I've complained about it before, he's uploading even non-compiling versions
06:16:53 <merijn> I think it's a gross misuse of hackage
06:17:07 <maerwald> ah, like travis CI
06:17:15 <merijn> But so far none of the Hackage admins have apparently contact him to knock it off
06:17:43 <merijn> maerwald: Just click to his profile, he has like 10 packages, each with 10s of minor releases and the changelog suggest half of them are minor refactors
06:17:55 <merijn> Or fixing non-compiling code
06:18:59 <merijn> "Seventh version revised D. Fixed issue with being not compiled because of the syntactic error."
06:19:25 <maerwald> The code is interesting
06:19:58 <maerwald> Check out Functional.hs
06:26:44 <hpc> merijn: filter = grep
06:27:38 <merijn> hpc: Yeah, but if I'd remember that, then I'd remember the direction too :p
06:28:12 <merijn> I always end up doing "filter even [1..10]" in ghci to remember >.>
06:28:18 <yushyin> xD
06:30:13 <sushi57> do you use some formatting tool? I am getting parse error due to indentation
06:30:47 <merijn> sushi57: I just do it manually, but usually the problem is mixing tabs and spaces or insufficient indentation in layout blocks
06:36:08 <sushi57> merijn: i am tryign to format https://pastebin.com/dWKD92Sr, but i keep getting  parse error (possibly incorrect indentation or mismatched brackets)   |13 |     | is_empty s = []   |     ^
06:38:36 <merijn> sushi57: Your guards are indented less "search s"
06:39:15 <sushi57> they should be on same level as where?
06:39:23 <merijn> sushi57: See also https://en.wikibooks.org/wiki/Haskell/Indentation (mandatory reading imo)
06:39:44 <merijn> sushi57: No, they should be *at least* as far as the 's' of 'search' line 2
06:39:59 <merijn> sushi57: So they should be indented *at least* 5 more spaces
06:44:02 <sushi57> merijn: oh yeah, thanks, now i only need to import the Stack module :)  thanks
06:44:38 <merijn> sushi57: This, incidentally is why most people put a newline after "where" it reduces how much you need to indent
06:45:10 <maerwald> only savages don't newline after where
06:45:30 <maerwald> a reason to break up with someone
06:46:43 <yushyin> sounds like you had some bad experiences first hand
06:48:45 <sushi57> merijn: thanks for advice, could you please tell me how would I use Data.Stack in my project? I have to install it with Stack first?
06:49:04 <merijn> That would depend on what package Data.Stack comes from :)
06:50:05 <sushi57> merijn: https://hackage.haskell.org/package/Stack-0.4.0/docs/Data-Stack.html i found this but can't really seem to figure out how to install it to be able to use it
06:51:20 <merijn> sushi57: With stack it depends on whether that package is part of the resolver you're using
06:51:37 <merijn> But I don't use stack, so I'm the wrong person to ask :)
06:52:31 <maerwald> Wait, you want to install Stack via stack?
06:53:05 <merijn> maerwald: No, Stack appears to be a package for stacks (i.e. the data structure)
06:53:10 <maerwald> Yes
06:53:28 <maerwald> it is not there
06:53:46 <maerwald> Use cabal, move on with your life.
06:54:09 <maerwald> Or start appending stuff to extra-deps until you grow grey hair
07:22:15 * hackage latex-svg-hakyll 0.2 - Use actual LaTeX to render formulae inside Hakyll pages  https://hackage.haskell.org/package/latex-svg-hakyll-0.2 (phadej)
07:23:15 * hackage latex-svg-pandoc 0.2, latex-svg-image 0.2 (phadej): https://qbin.io/jp-smoke-85qs
07:23:18 <sm[m]> sushi57: step 1, you add the package (Stack) to build-depends in your package.yaml or .cabal file. Step 2, if stack build complains, add the line it suggests to extra-deps in stack.yaml
07:23:38 <sheepfleece> Can I use polysemy or other effect libraries with Scotty? 
07:24:35 <sheepfleece> I'm just not sure how I would represent route matching and Wai functions with it. 
07:28:12 <sheepfleece> Also there is a nice key-value store effect in polysemy. How would I go about representing db connections with it? One big GADT with lots of selects, inserts, etc. inside of it? http://hackage.haskell.org/package/polysemy-zoo-0.6.0.0/docs/Polysemy-KVStore.html
07:48:11 <ivegotasthma> HOLY FUCKING SHIT I LOVE HASKELL
07:48:20 <ivegotasthma> OH MY GOD I CANT BELIEVE IT WORKED ON THE FIRST TRY
07:48:34 <ivegotasthma> I AM GONNA SHIT MY PANTS THIS FEELING IS SO GOOD WHAT THE ACTUAL FUCK
07:48:57 <ivegotasthma> I HAVENT FELT THIS GOOD SINCE I STARTED PROGRAMMING 7 YEARS AGO AAAAAAA
07:51:08 <maerwald> that's ... great
07:51:32 <heatsink> Who needs caffeine when you have haskell
07:55:39 <DigitalKiwi> that's a funny way of spelling amphetamines
08:00:20 <merijn> DigitalKiwi: Worked for Erdos
08:01:13 <DigitalKiwi> isn't he proof that you do need amphetamines
08:03:31 <merijn> DigitalKiwi: I was referring to amphetamins working for him ;)
08:04:39 <DigitalKiwi> https://en.wikipedia.org/wiki/Paul_Erd%C5%91s#Personality second paragraph lol
08:14:43 <merijn> It has been... 0 days since I had a bug due to an embarassing boolean inversion >.>
08:17:26 <DigitalKiwi> how many days was it before that
08:17:37 <hpc> [Object object] days
08:17:41 <merijn> ;)
08:17:48 <merijn> No comment >.>
08:18:02 <DigitalKiwi> how many days has it been zero :D
08:18:24 <merijn> Any day involving not-Haskell
08:18:53 <merijn> Even now it was just due to SQL not supporting ADTs :p
08:19:07 <merijn> I use an ADT on the Haskell-side, boolean blindness and all
08:19:21 <merijn> But I screwed up the conversion to boolean in SQL >.>
08:21:05 <jchia_> Is there a type-level ($)?
08:21:24 <jchia_> Just for brevity of notation by saving paretheses
08:21:34 <Uniaika> jchia_: pretty sure there isn't :/
08:23:07 <Philonous> Is there a "most idiomatic" way of writing a client for a (json-based) web api? Servant-client perhaps? 
08:24:11 <Uniaika> Philonous: I personally love servant-client
08:25:13 <Philonous> OK, I'll try it out then :)
09:07:58 <Uniaika> I feel bad
09:08:05 <Uniaika> I have written orphan Show instances
09:08:25 <Uniaika> ðŸ˜¢
09:11:45 * hackage hsendxmpp 0.1.0.0 - sendxmpp clone, sending XMPP messages via CLI  https://hackage.haskell.org/package/hsendxmpp-0.1.0.0 (SergeyAlirzaev)
09:12:06 <Uniaika> that being said maybe I could write a newtype and try to make stuff simple for the library consumersâ€¦
09:12:35 <Philonous> {-# GHC_OPTIONS -fno-warn-orphans -#} problem solved ;) 
09:14:08 <maerwald> Why?
09:14:16 <maerwald> Let the warning be
09:14:49 <Uniaika> yeah honestly it's like ghosting your friends telling you when you have a drinking problem :P
09:15:02 <Uniaika> clearly this needs solving.
09:15:29 <maerwald> writing orphan instances is fine. Having the warning during compile time is also fine, so your users may notice it
09:15:43 <Philonous> MOre seriously, I wish there was a way to disable the orphan instance warning for a single instance declaration
09:38:33 <Uniaika> maerwald: yeah probably but this is also in conjunction with another problem: I provide the user with a pair of (Unagi) chans to speak to a background worker
09:39:01 <Uniaika> and the pair is needed by all the functions I expose
09:40:07 <merijn> Philonous: I proposed an ADOPT pragma, but it was shot down in favour of more general granular warning control at the source level
09:40:51 <merijn> But I don't know if anyone's working on that
09:41:40 <merijn> (I just liked the brilliant name I came up with for the pragma :( )
09:43:33 <Uniaika> can someone remind me if the docs are lying when they say that -Weverything turns on every single warning supported by the compiler?
09:44:04 <Uniaika> I remember that GCC's behaviour is actually "backward-compatible", whatever that means, but is it the case of GHC?
09:58:05 <mmaruseacph2> backward-compatible means that code written in an old version of the compiler will still compile (API compatibility) or be able to be linked against (ABI compatibility) with newer compilers
09:58:48 <mmaruseacph2> GHC has had some breaking changes (burning bridges proposal, AMP, etc.) but afaik it's fairly backwards compatible
10:00:32 <dmwit> -Weverything does not turn on all the warnings, no.
10:02:08 <dmwit> Whoops, I might be misremembering a complaint about -Wall vs -Wcompat. I take back my claim; I don't know the answer to your question.
10:04:00 <dmwit> https://gitlab.haskell.org/ghc/ghc/issues/14794 looks relevant. It claims, in part, "`-Weverything` can have fewer warnings than `-Wall`".
10:06:16 <Uniaika> okay so the docs are lying. :)
10:06:18 <Uniaika> thanks!
10:13:02 <dsal> I really want to do something like    data Thing = ThingA { .. } | ThingB { .. }
10:14:11 <monochrom> Isn't that record syntax?  Unless you literally mean ".."
10:14:26 <dsal> Wait, I can do that?
10:14:40 <monochrom> Yes but you also have to give field names to fields.
10:14:51 <dsal> For some reason, I thought I couldn't do that.  heh
10:15:21 <Uniaika> dsal: you mean, having multiple records in a sum type?
10:15:22 <monochrom> data Thing = ThingA{field1 :: Int, field2, field3 :: Bool} | ThingB{field1 :: Int, field4 :: Char}
10:15:26 <Uniaika> yeah it's possible
10:15:39 <dsal> I should just try things I want to work like I always tell other people to do.
10:15:45 <monochrom> :)
10:16:14 * hackage hsendxmpp 0.1.1.0 - sendxmpp clone, sending XMPP messages via CLI  https://hackage.haskell.org/package/hsendxmpp-0.1.1.0 (SergeyAlirzaev)
10:17:42 <monochrom> field selectors become partial functions. this may be one of the unhappy points.  e.g., field4 (ThingA ...) = bottom
10:18:44 <monochrom> You can even use record syntax for GADTs
10:20:27 <monochrom> This is why I like Haskell compared to mainstream languages.
10:21:21 <monochrom> Features are orthogonal or close enough. No artificial restrictions just because the designers and average programmers haven't thought of using two features together.
10:21:41 <dsal> This prism is kind of blowing my m ind.
10:22:03 <tdammers> or, worse, because the designers think that average programmers aren't smart enough to be trusted with those features
10:23:22 <dsal> Weird, I figured if I could make this work, I'd see if I could get a prism, and then figure out how to get data back out, but it seems to just do the thing I wanted.  Which I guess makes sense.
10:25:04 <solonarv> should be a(n affine) traversal, not a prism
10:25:22 <solonarv> at least if you are talking about the lensy field accessors for this sort of data type
10:27:12 <dsal> I'm working on my Tesla API and implementing more than just cars.  I have   ProductCar {Text,Text} | ProductSolar {Text}    and an old `vehicles` action that returns `m (Map Text Text)` (name of vehicle -> internal ID).  That's now   `fmap (Map.fromList . toListOf (folded . _ProductCar . to swap)) . products`
10:27:35 <dsal> I guess I could just do name and then ID and not have to swap.
10:33:40 <maerwald> tdammers: well, if you trust everyone with everything, then you end up with Scala :P
10:43:49 <rsoeldner> Hi, has someone experience with using imalsogreg/servant-reflex ? If the resource is not reachable (ie. server offline) I would have expected a `RequestFailure :: ReqResult` or something. What is the way to handle such cases ?
10:49:22 <ta3dot142> Hi, can anyone suggest a link for tutorial/guide to best practice to learn haskell in nixos? how to manage project and dependencies. FYI, I am using nixos for quiet some time, and now start to try learn haskell maybe start by convert a small bash script to haskell.
10:57:24 <evelyn> Well, both stack and cabal have nix integration, so you can learn Haskell using many of the tutorials and books you might have come across already
10:58:48 <evelyn> there are also ways of managing haskell environments using nix, I don't remember the name of the tool though (it's a bit like stack)
11:00:49 <sm[m]> wow dsal are you automating all the things ??
11:01:07 <sm[m]> you seem rather productive!
11:01:27 <sm[m]> I would read your blog
11:01:28 <dsal> heh, just learning things with useful results.
11:01:36 <dsal> I've not posted to my blog in years.  :(
11:01:49 <sm[m]> same
11:03:01 <dsal> Wow.  Apparently five of them  I'm pretty far behind.
11:06:07 <dsal> I really should do a post about this GoPro stuff, though.  I figured out how to use their APIs to do stuff with my tools that you can't do with any of their tools, but I'd think people would generally want to do.
11:16:12 <sm[m]> +1
11:16:25 <ski> -1
11:17:52 <sm[m]> ski is GoPro CEO... ?
11:18:09 <ski> no idea what "GoPro" is
11:18:55 <sm[m]> I was upvoting dsal's "I really should do a post about this GoPro stuff". It's a popular brand of outdoor video camera.
11:19:04 <ski> oh, okay
11:19:22 <[exa]> dsal: what specific stuff? (/me curious)
11:20:34 <dsal> [exa]: e.g., I was doing a time lapse video.  The camera will automatically split the video into chunks of a few gigs.  Then the battery died.  I replaced the battery and resumed the video.  I can upload all of these chunks across multiple files as a single TimeLapseVideo for GoPro plus.
11:25:13 <ta3dot142> Thanks evelyn, I am try to follow tutorial in old ebook, but have problem to detect library that already install with nix. The same library failed when I try to install using cabal. I am also quite confuse of how integration of haskell tooling.
11:31:28 <evelyn> ta3dot142: https://www.haskell.org/cabal/users-guide/nix-integration.html
11:37:12 <ColonelJ> I believe I'm due to have an interview soon for a Haskell based job, anyone got any tips or stuff I should know?
11:38:36 <dsal> ColonelJ: Have you written any haskell code before?
11:39:22 <ColonelJ> dsal: sure, but not a great lot
11:40:01 <dsal> I suspect different sites have different things they're going to care about.
11:40:29 <ColonelJ> I find it difficult to see exactly what sort of thing I'd be doing until I get to talk to them more
11:40:50 <koz_> ColonelJ: If my job is anything to go by, I wasn't evne that sure _after_ the interview.
11:42:20 <maerwald> ColonelJ: try to figure out: 1. how many haskell devs (otherwise you might be surprised you're the only one), 2. what kind of project that is (LOC, is it mostly maintenance or new stuff), 3. if there is micro-management involved in the engineering workflow
11:42:34 <maerwald> 3. is hard to figure out, unless you know what questions to ask
11:43:15 <ColonelJ> for 2. it says both brownfield and greenfield, and 'at enterprise level' whatever that means
11:43:34 <maerwald> ask them if they have opensource libs, check their code
11:44:07 <ColonelJ> maerwald: that's a good question to ask, thanks
11:44:25 <owlscientist> you can also check out their github. quite a few places have stuff there.
11:44:32 <Rembane> maerwald: How do you find out number three?
11:44:53 <maerwald> Rembane: asking a lot of questions about workflow
11:45:21 <Rembane> maerwald: What answers are red flags? 
11:46:45 <maerwald> Doing scrum, but not having a proper release management :P
11:47:05 <maerwald> So you get monitored all the time, but have no effective goal to work towards
11:47:31 <ta3dot142> evelyn, thanks. Also an example with best practise workflow would be nice.
11:48:29 <ColonelJ> owlscientist: I found their github, everything shown seems to be forks of other random stuff... and there are no public members shown
11:48:37 <Rembane> maerwald: :D 
11:50:58 <ColonelJ> maerwald: AWS was mentioned in my initial chat which I don't have any experience with, should I be worried about that?
11:51:31 <maerwald> They want you for devops too or what? :P
11:51:37 <maerwald> Ask for double salary
11:51:51 <ColonelJ> haha, yeah I don't know
11:52:45 <Clint> do a pair of undergrads want you to do all the work for their exciting new startup?
11:52:48 <maerwald> I dunno. Most ppl are worried about their or others knowledge, but few ppl are worried about the ability to learn.
11:52:52 <maerwald> It's weird
11:53:14 <maerwald> Like, you hire a guy who know AWS, but they don't want to learn anything new. Now what? :)
11:53:42 <berndl> You hire another guy.
11:53:46 <maerwald> heh
11:54:05 <maerwald> Interviews are most of the time about knowledge
11:55:24 <ColonelJ> I found it weird how they separately asked about my functional programming experience after asking about Haskell...
11:56:20 <rotaerk> makes sense if it's a recruiter who doesn't know what these terms mean
11:56:37 <monochrom> Don't you know? Haskell isn't a functional language any more.  It's a type-level language now. :)
11:56:41 <berndl> Maybe they wanted to know if you did functional programming in another language.
11:57:20 <maerwald> clojure :P
11:57:33 <maerwald> Or: say JavaScript
11:57:56 <ColonelJ> monochrom: I've done a bit of Coq before https://github.com/ColonelJ/coq_fft_proof
11:57:59 <monochrom> They asked about your term-level functional programming experience.
11:58:33 <peutri> even if they didn't know it
11:59:31 <maerwald> I can't find the repo where your program runs in the GHC type checker
11:59:56 <ColonelJ> maerwald: :(
12:00:38 <Rembane> This is also relevant: https://aphyr.com/posts/342-typing-the-technical-interview
12:03:25 <ColonelJ> is it good to ask which GHC language extensions they have turned on for their code? :P
12:03:46 <monochrom> Yes.
12:03:47 <Rembane> ColonelJ: I think it's a fun question. Do it! :D
12:04:03 <monochrom> It is always good to treat the interview as you interviewing them.
12:04:25 <monochrom> "the sentiment is mutual"
12:05:17 <monochrom> Good employers also ask "do you have questions about us? do you want me to show you what we do?"
12:05:27 <quiet_laika[m]> any nix users around? when do people feel it's appropriate/necessary to use haskell.nix instead of the stock nixpkgs haskell infrastructure?
12:05:42 <monochrom> meaning they also understand that you are choosing them
12:06:09 <ColonelJ> monochrom: yeah I usually get a question like that at some point, but it's usually at the end
12:07:18 <rotaerk> quiet_laika[m], I'm not familiar with haskell.nix, but I don't recommend building haskell projects with nix
12:07:26 <maerwald> monochrom: A good employer also asks what you want to work on and what you're excited about. A poor employer just checks your skills. 
12:07:39 <rotaerk> just use nix to setup a shell (using nix-shell) to provide you your tools and native libraries
12:07:55 <rotaerk> and then use cabal/stack (preferably cabal *cough*) to do your building
12:08:30 <quiet_laika[m]> yeah i use cabal or stack or whatever for incremental builds
12:08:44 <quiet_laika[m]> im prematurely optimizing here but im more considering the case when i want to have a reproducible build for the "finished" project
12:08:57 <rotaerk> cabal is good at solving the right combination of versions of packages.  nixpkgs not so much.  it just uses the latest version of everything, and if they're incompatible so be it
12:09:25 <rotaerk> you're then forced to modify your nix expression to explicitly pull in particular versions to override that behavior, and that can be a nightmare of tedium
12:09:53 <quiet_laika[m]> yeah i think that's the basic idea haskell.nix is trying to solve... so to piggyback off you and answer my own question, ill just use stock nixpkgs for now while im developing, and maybe look back into using haskell.nix when im closer to having something to publish
12:11:24 <rotaerk> well, even without the manual-version-solving hell, I also found that nix-build was simply slower than running cabal
12:11:50 <maerwald> rotaerk: it needs to resolve all those symlinks first *chunkle*
12:11:51 <rotaerk> it seemed to do a poorer job (or no job at all) of building only the modules that needed building
12:12:06 <maerwald> But I can confirm that it's slower. I experienced it in CI
12:12:44 <maerwald> cabal-cache from S3 + cabal build was a lot faster than nix-build
12:13:24 <rotaerk> nix isn't actually all that great at reproducible builds
12:13:49 <Rembane> rotaerk: Where does it fail?
12:13:51 <rotaerk> at least, if you're dependent on some things that are core to the OS, like graphics drivers
12:14:14 <maerwald> yep or virtualisation/kernel
12:14:24 <maerwald> nixops failed on some machines, because of kernel stuff afair
12:14:34 <maerwald> Could never test anything locally
12:14:43 <Rembane> Got it! 
12:15:11 <maerwald> I even remember some java stuff involved 
12:15:25 <maerwald> which just wouldn't build on some machines
12:15:55 <rotaerk> every time I upgrade my nixos, I'm gambling on whether my nix-shell will still work, because I define it in terms of whatever my global <nixpkgs> is rather than tying it to a specific nixpkgs version
12:16:30 <rotaerk> but I used to try tying to a specific nixpkgs version, to be immune to that, and that didn't work either, because the specific nixpkgs version would end up incompatible with some core OS things (like drivers)
12:16:30 <maerwald> ah, this also opens the security question =)
12:16:55 <maerwald> now you devopsed everything with nix, but you can't update anything, because it might break your entire config
12:17:16 <rotaerk> it just means i upgrade infrequently, and then fix my project as needed when I do
12:18:14 <maerwald> I prefer a system where it's hard to write a broken config, even if it isn't strictly reproducible.
12:19:21 <rotaerk> broken in what way?
12:19:28 <fabianhjr> rotaerk: well, but the expressions are in function of the packages given, you can always rebuild with a specific version. (Tough you might need to build some of the odd versioned things if they aren't cached)
12:19:36 <maerwald> rotaerk: runtime
12:19:38 <rotaerk> like, do you just mean static typing unlike what nix does?
12:19:58 <maerwald> with nix, you get reproducible errors
12:20:06 <maerwald> but that doesn't mean your config is working
12:21:05 <maerwald> rotaerk: types usually don't even help in config :)
12:21:11 <maerwald> So I'm not a fan of e.g. propellor
12:21:43 <rotaerk> I'm just having trouble imagining a way in which the config would be broken that a better system would make hard
12:23:28 <maerwald> rotaerk: for once, something that isn't turing complete
12:23:33 <maerwald> and an actual config language
12:23:55 <rotaerk> heh
12:27:52 <rotaerk> quiet_laika[m], oh another reason not to use nix to actually build your project:  not portable
12:28:19 <rotaerk> use nix on linux to resolve your tools and native libraries, but on, say, Windows, you might use some other tool to do so
12:28:34 <rotaerk> but your *build* tools would be the same on both (e.g. cabal)
12:29:04 <rotaerk> (chocolatey on Windows perhaps)
12:29:25 <maerwald> does nix work on FreeBSD?
12:31:15 <dsal> nix works on macosx with a lot of effort.
12:54:32 <Jason30> I've got a quick question about closures from the wiki example, could anyone spare me a minute? :)
12:54:44 <dsal> Jason30: begin with question.  :)
12:55:12 <Jason30> How would you run a closure like this: f x = (\y -> x + y)
12:55:27 <Jason30> This is taken from the wiki: https://wiki.haskell.org/Closure
12:59:17 * [exa] raises eyebrow
12:59:34 <[exa]> oh noes, he quit
12:59:39 <koz_> Would someone be able to look over this and tell me if the reasoning vis-a-vis Semigroup here is OK? https://github.com/composewell/streamly/issues/513
12:59:45 <koz_> It seems reasonable to me, but I have no idea what I'm doing.
13:02:21 <solonarv> koz_: your reasoning seems alright to me
13:03:22 <solonarv> I also disagree with the commenter who says that it's fine because = isn't exactly defined. This is true, but usually one expects something like substitutivity, and converting to a list shows that this fails to hold.
13:07:50 <koz_> solonarv: Said commenter is the project head.
13:08:11 <solonarv> then I guess I disagree with the project head :p
13:08:19 <solonarv> simply removing the Eq instance is not good enough.
13:09:20 <[exa]> +1
13:09:20 <solonarv> just to check, you had example code that used some sort of 'toList' to demonstrate the difference
13:09:23 <solonarv> right?
13:10:01 <solonarv> if these are supposed to be unordered streams, then they shouldn't have a toList-alike that exposes the internal ordering
13:10:41 <koz_> solonarv: The exact source of my woes: http://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly.html#t:WSerialT
13:11:37 <koz_> That's what caused me to report this as a bug.
13:11:56 <solonarv> oh right, you linked this before
13:12:53 <koz_> Just not sure what to think honestly.
13:12:57 <solonarv> actually another solution would be to remove the Semigroup instance, and instead just export an operator that people don't expect to be associative
13:13:13 <koz_> I would argue that this is much more principled.
13:13:26 <koz_> In this setting, it would have to be a type class though.
13:13:39 <koz_> (because there's a lot of different [type-of-stream]Ts)
13:14:36 <solonarv> it could even be given a 'infix 6 ><' declaration, so that it's not possible to write 'x >< y >< z' and it must be parenthesized
13:14:49 <solonarv> (using >< as an example name, of course)
13:14:56 <solonarv> sure, it could be a typeclass
13:15:31 <koz_> Would you mind chiming into the thread with this exact take?
13:16:07 <solonarv> I actually would, because I don't have a dog in this fight and don't want to drop in out of the blue
13:16:16 <solonarv> but you are free to reuse my arguments
13:54:34 <maerwald> koz_: did you try the cross branch? I think I'm finished. But I can only compile with -j1, so my testing is slow
14:01:23 <MarcelineVQ> koz_ is already on to the furious branch
14:12:40 <koz_> solonarv: OK, thanks.
14:12:52 <koz_> maerwald: I'll give it a whirl as soon as I can.
14:12:56 <koz_> I have -j12 at my disposal.
14:13:15 <maerwald> I got linker errors and dunno I think my ram blew up
14:15:08 <koz_> maerwald: I'll do a test-drive as soon as I can.
14:19:33 <koz_> solonarv: Duly reused. :P
14:23:30 <koz_> maerwald: What do I need set up in addition to the branch's build of ghcup?
14:23:36 <koz_> Guess a cross-comp toolchain?
14:24:10 <maerwald> koz_: maybe talk in #ghc?
14:24:15 <koz_> maerwald: Sure.
15:03:45 * hackage reflex-test-host 0.1.0.0 - reflex host methods for testing without external events  https://hackage.haskell.org/package/reflex-test-host-0.1.0.0 (pdlla)
15:06:44 * hackage reflex-dynamic-containers 0.1.0.0 - various dynamic containers for Reflex  https://hackage.haskell.org/package/reflex-dynamic-containers-0.1.0.0 (pdlla)
15:15:07 <brsy4> hi
15:15:15 <dmwit> sup
15:16:20 <brsy4> i learnI want to learn haskell
15:16:23 <mr_sm1th> 'cabal init' is not generating a .cabal file somehow...
15:16:31 <brsy4> I'm writing php right now
15:16:54 <dmwit> Well, there's certainly no shortage of tutorials.
15:16:56 <dmwit> ?where tutorials
15:16:56 <lambdabot> http://haskell.org/haskellwiki/Tutorials
15:24:46 <ColonelJ> Is there anything for Haskell kind of like what K&R is to C?  Where you can breeze through it if you already know the concepts?
15:25:18 <mr_sm1th> Programming in Haskell from Hutton
15:33:49 <mr_sm1th> Looks like I found a cabal bug. When you do 'cabal init' inside a directory named 'cabal', no .cabal file is generated.
15:35:16 <r3dnaz[m]> ColonelJ: https://www.haskell.org/tutorial/
15:37:34 <solonarv> mr_sm1th: huh, now that is indeed odd.
15:38:17 <solonarv> mr_sm1th: do you also get "Error: no package name provided" ?
15:39:00 <mr_sm1th> Yep
15:39:33 <mr_sm1th> https://github.com/haskell/cabal/issues/6236
15:40:14 * hackage base16 0.2.1.0 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.2.1.0 (topos)
15:40:33 <topos> davean ^
15:41:21 <solonarv> aha, seems to only happen in non-interactive mode
15:41:40 <solonarv> cabal init -i still throws up a warning with an "are you sure? y/n"
15:45:25 <ColonelJ> Thanks r3dnaz[m] shame there isn't an updated version of it for 2010 (if one is warranted)
15:48:57 <davean> topos: !!!
16:06:08 <monochrom> This is what's wrong with making --interactive non-default.
16:07:01 <monochrom> Simplicity is hard to do. So people do the easier thing: head-in-sand.
16:09:58 <MarcelineVQ> even then it'll ask if you're sure you want to do interactive when you -i  :/
16:10:23 <MarcelineVQ> it's like, bro, I just told you
16:11:15 <MarcelineVQ> Just means the interactivity starts a step sooner than expected I guess :>
16:38:32 <gbd_628> Is it possible to promote higher-order data constructors in a defunctionalized way? When using singletons, `map` gets promoted to `Map :: (a ~> b) -> [a] -> [b]`, but that doesn't work for something like `MkEndo :: (a -> a) -> Endo a`. Is it possible to make it work?
16:38:34 <gbd_628>  Elaborated example: https://gist.github.com/greatBigDot/06f5bf85e01689e4132d48cb95ab593c
16:48:19 <Guest0> Would anyone mind helping with a (slightly less than beginner) question? Or is there a better channel for that?
16:48:28 <koz_> Guest0: Ask away.
16:49:19 <Guest0> So I have a bunch of datatypes which extend each other, and I want to be able to convert from complex ones to simple ones
16:49:50 <Guest0> I thought a slick way to do this would be to have a typeclass that encapsulates "can convert to blah"
16:50:20 <Guest0> So a minimal example might be three datatypes A B C, with typeclasses ConvertToA and ConvertToB
16:50:24 <dsal> What does it mean for a type to extend another type?
16:50:50 <dsal> Are you doing OO?
16:51:11 <Guest0> dsal: Say you have binary trees with internal nodes and empty, or binary trees with internal nodes, empty, and leafs
16:51:19 <Guest0> no - that would be a sin ;)
16:51:38 <Guest0> I'm writing a program that evalutes "extension by definition" in first order logic
16:52:12 <Guest0> As an example, the fundamental theorem of calculus can (in theory) be written using nothing but logical symbols and the membership relation
16:52:43 <Guest0> I'm implementing an AST with only membership, as well as a family of ASTs which are more and more expressive
16:52:51 <Guest0> think of it as compiling a high level language to a low level one
16:53:43 <Guest0> The end goal is to compile something very high level to very low level, but it seems wasteful to write all that code more than once. If I can compile each AST to the AST one step down the chain, then I should be able to just compose everything and be done
16:54:24 <dsal> Is it infeasible to have a type that can store all the things you need?
16:54:25 <solonarv> you could actually use the same datatype for all of these ASTs!
16:54:39 <solonarv> that is what GHC itself (the primary Haskell compiler) does
16:55:09 <wroathe> solonarv: It's actually a very nifty approach
16:55:13 <solonarv> yeah!
16:55:56 <wroathe> solonarv: I'm doing the same thing with my first parser generator in C. The grammar spec's AST is Parsed -> Checked -> Packed
16:58:03 <Guest0> How would you use the same AST for all of them?
16:59:11 <Guest0> The error I'm currently getting isn't making much sense to me, though, and I'm interested in understanding it either way
16:59:40 <solonarv> you have parameters that determine which "sub-type" you have / which nodes are allowed
16:59:48 <Guest0> If I have classes ConvertToA and ConvertToB, and I know B is an instance of ConvertToA and C is an instance of ConvertToB
17:00:06 <Guest0> Then I should be able to infer an instance of ConvertToA for C by composing
17:00:40 <Guest0> but "instance (ConvertToB a) => ConvertToA a where convertToA = convertToA . convertToB"
17:01:22 <Guest0> is telling me it needs flexible instances, then undecidable instances, and finally that I have an overlapping instances error...
17:01:37 <Guest0> solonarv: that's a really clever use of phantom types
17:01:58 <solonarv> they're not actually phantom
17:02:27 <solonarv> well, they're "phantom" in the sense that there's no value of that type in the data, but "phantom" has a specific meaning in GHC Haskell
17:02:59 <Guest0> huh - I didn't know that
17:03:31 <solonarv> anyway, the errors about needing flexible/undecidable instances boil down to "the Haskell report is pretty restrictive when it comes to type classes, you need these extensions to use the - perfectly/mostly sound - fanciness"
17:04:17 <solonarv> UndecidableInstances theoretically allows instance resolution to loop forever (imagine if you also had 'instance ConvertToA a => ConvertToB b'!)
17:04:34 <solonarv> but there is a depth limit, so it won't actually loop forever
17:04:50 <wroathe> Good to see the GHC Gitlab instance is still ridiculously slow
17:04:56 <solonarv> alright, now on to the overlap thing!
17:04:59 <Guest0> I figured that was why undecidable instances was necessary - I can imagine loops like that
17:05:07 <Guest0> Thanks!
17:05:15 <Guest0> What's causing the overlap thing?
17:05:23 <solonarv> when GHC tries to find a typeclass instance, it only looks at the instance *head* - the part to the right of the =>
17:05:53 <solonarv> so in 'instance ConvertToB a => ConvertToA a', the head is 'ConvertToA a'
17:06:34 <solonarv> if it's possible for multiple of these heads to match at the same time, you've got a problem: which instance should be used?
17:07:05 <solonarv> so GHC complains that there is an overlap.
17:07:14 <Guest0> Is that possible in my case? There's only one instance of ConvertToA B, and only one of ConvertToA C
17:07:24 <Guest0> I could see the issue if I had a ConvertToB B instance, say given by id
17:07:58 <solonarv> yes, you can put a marker on the instance(s) to say which one should "win"
17:08:08 <solonarv> one sec, just going to link the relevant section of the GHC manual
17:08:17 <Guest0> thanks ^_^
17:09:05 <solonarv> here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-overlap
17:10:36 <Guest0> now it's my turn to brb - reading the linked doc
17:18:31 <Guest0> solonarv: Thanks! I'll try working with the stuff in those docs. I'm about to eat dinner, but i might be back later tonight
17:18:38 <Guest0> Thanks again, everyone ^_^
17:20:44 * hackage di-polysemy 0.1.1.2 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.1.1.2 (nitros12)
17:25:03 <remexre> the writer space leak doesn't apply for e.g. the Bool monoids, right?
17:25:42 <remexre> or, wait
17:25:43 <remexre> hm
17:29:07 <remexre> I guess for a version of Data.Monoid.All that short-circuits on the right, it'd be nonleaky?
17:30:53 <mniip> no?
17:32:16 <remexre> shouldn't that make it be able to throw away all the previous thunks once it hits a False?
17:32:22 <remexre> or wait, that's time, not space
17:32:37 <mniip> why would it throw away thunks
17:33:13 <remexre> because once it does the (x && False = False), the x thunks can be GC'd w/out needing to be eval'd
17:33:16 <remexre> was my thinking
17:34:30 <mniip> and when does x && = False "fire"?
17:34:38 <mniip> when you evaluate the answer
17:36:29 <remexre> is there any reason other than backwards compatibility to keep WriterT around, then?
17:37:19 <mniip> bottom correctness?
17:38:27 <remexre> wdym
17:38:55 <mniip> if there's an early computation that gets written to the monoid that is expensive or throws an error
17:39:19 <mniip> and then a latter computation is such that <> can ignore the LHS
17:39:37 <mniip> a strict writer will still compute the LHS, taking either time or throwing an error
17:40:11 <remexre> oh, does Control.Monad.Writer.Strict not have the leak? that nuance was lost on me
17:41:41 <mniip> ah hm
17:42:10 <mniip> I'm not quite sure what the strict writer is strict in
17:45:58 <mr_sm1th> I've been trying to install a simple dependency for three hours.
17:46:03 <mr_sm1th> The latest error is "libz.so.1: cannot open shared object file: No such file or directory"
17:46:17 <remexre> and zlib / libz is installed, right?
17:46:44 <mr_sm1th> yes
17:46:58 <mr_sm1th> I'm trying to install wreq
17:47:22 <mr_sm1th> I'll try a full system upgrade
17:48:02 <mniip> ahhh I see
17:48:07 <mniip> strict writer is strict in the tuple
17:48:16 <mniip> yeah that doesn't help with mappends at all
17:48:37 <yushyin> mr_sm1th: what distribution? can you check that libz.so.1 exists?
17:48:38 <remexre> okay, so I should just wrap StateT and not expose the get function
17:48:45 <mniip> but what it does help with is....
17:49:00 <yushyin> mr_sm1th: does this return something? pkg-config --modversion zlib
17:49:02 <mniip> > runWriter (undefined >>= const (tell "hi"))
17:49:04 <lambdabot>  ((),"*Exception: Prelude.undefined
17:49:13 <mniip> er, not quite
17:49:30 <remexre> for strict writer that'd be fully undefined then, right?
17:49:54 <mniip> > runWriter (undefined >>= const (tell (Dual "hi")))
17:49:56 <lambdabot>  ((),Dual {getDual = "hi*Exception: Prelude.undefined
17:50:16 <remexre> > Control.Monad.Writer.Strict.runWriter (undefined >>= const (tell "hi"))
17:50:19 <lambdabot>  error:
17:50:19 <lambdabot>      Not in scope: â€˜Control.Monad.Writer.Strict.runWriterâ€™
17:50:19 <lambdabot>      Perhaps you meant one of these:
17:50:21 <mr_sm1th> Arch Linux, yes it exists: /usr/lib/libz.so.1
17:50:29 <mniip> yeah
17:50:41 <mr_sm1th> $ pkg-config --modversion zlib
17:50:44 <mr_sm1th> returns 1.2.11
17:50:51 <mniip> the >>= would pattern match on () in undefined
17:50:54 <mniip> which obviously throws
17:50:58 <remexre> mr_sm1th: is ghc installed from repos, stack, ghcup, or something else?
17:51:31 <mr_sm1th> I installed it with Nix. Maybe that's the problem?
17:52:32 <mniip> 1587948491 [03:48:11] <remexre> okay, so I should just wrap StateT and not expose the get function
17:52:37 <mniip> Writer.CPS does exactly that
17:53:11 <mr_sm1th> remexre, when I install ghc with pacman I get the following error: output of /usr/bin/ghc: hGetContents: invalid argument (invalid byte sequence)
17:53:20 <mr_sm1th> I mean, when I install wreq
17:53:24 <remexre> mr_sm1th: is your locale something weird?
17:53:38 <remexre> mniip: ah, okay
17:54:48 <yushyin> mr_sm1th: if you installed ghc with nix, you should also install zlib with nix, right?
17:55:19 <mr_sm1th> LC_TIME=nl_NL.UTF-8, rest is en_US
17:56:47 <remexre> assuming en_US == en_US.UTF-8, "ought to be fine" (I'm out of troubleshooting questions at this point, though)
17:57:31 <remexre> I guess, you've put those in /etc/locale.gen and run locale-gen?
18:01:37 <mr_sm1th> yes
18:11:10 <xcmw> How can I install https://github.com/cocreature/diagrams-miso with nix? I have miso get up and a have a default.nix that calls cabal2nix but how do I tell it to install diagrams-miso?
18:12:26 <xcmw> diagrams-miso is not on hackage so some how I have to tell nix to fetch it from github
18:23:15 * hackage string-interpolate 0.2.0.3 - Haskell string/text/bytestring interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.2.0.3 (williamyaoh)
18:58:01 <mr_sm1th> I solved my problem by using Stack.
18:58:41 <Welkin>   -- said no one ever
18:58:42 <Welkin> :D
19:05:07 <sm[m]> not true Welkin
19:07:15 * hackage calamity 0.1.2.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.2.0 (nitros12)
19:16:45 <jajajalacala> Hello
19:17:43 <Welkin> hello brazil person
19:26:36 <mr_sm1th> Is req the most user friendly library for making HTTP requests?
19:32:39 <MarcelineVQ> req and http-conduit are pretty good, I'd rank req higher on my niceness scale
19:37:04 <remexre> suggestions for how to do comments w/ trifecta / the parsers library?
19:37:31 <MarcelineVQ> do comments?
19:37:51 <remexre> it almost seems like I'd want to override the whiteSpace combinator in Text.Parser.Token, but it's not a class method
19:37:55 <remexre> like parse a language w/ comments
19:38:19 <remexre> and having a wrapper for the parsing monad feels questionable
19:38:35 <mr_sm1th> MarcelineVQ, thanks! :)
19:42:34 <monochrom> remexre: If you are writing an instance of the TokenParsing class, the method for both whitespace and comments is someSpace.
19:42:55 <monochrom> I haven't used trifecta, just skimming the doc right now.
19:45:06 <remexre> monochrom: ah, I missed that
19:52:02 <remexre> okay, https://p.acm.umn.edu/XG5iwim7gAM= works
20:08:18 <monochrom> yeah, nice
20:13:44 * hackage bitwise-enum 1.0.0.1 - Bitwise operations on bounded enumerations  https://hackage.haskell.org/package/bitwise-enum-1.0.0.1 (jnbooth)
20:46:26 <Desmond373> so whats everyone working on?
20:47:23 <fabianhjr> Doing a store on haskell with obelisk
20:47:26 <fabianhjr> Has been fun
20:53:03 <MarcelineVQ> hey that's pretty cool
21:01:00 <dsal> I did some work on interfacing with Tesla today to get more data out of Solar, but it doesn't seem to work very well.  I guess that's why the documentation was so poor.  If my batteries ever get installed, I'll see if that works any better.  *shrug*
22:09:15 * hackage calamity 0.1.3.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.3.0 (nitros12)
22:13:44 * hackage tempi 1.0.2.0 - For representing musical tempi  https://hackage.haskell.org/package/tempi-1.0.2.0 (dktr0)
22:43:08 <Desmond373> im trying to figure out how many items the permutation function will give me given N values. Its just N! right
22:49:39 <iqubic> Correct.
22:50:17 <Welkin> [] = []; [1] = [], [1]; [1,2] = [], [1], [1,2], [2], [2,1];
22:50:40 <Welkin> if you count the empty case
22:51:11 <Welkin> oh, but you want permutations
22:51:36 <Welkin> I forgot what this is called, set enumerations? Something
22:52:58 <Desmond373> powerset i think
22:53:02 <Welkin> yes
22:53:20 <Desmond373> which is all subsets
22:54:25 <Desmond373> see i wanted to do all permutations of a matrix row with 2 options set out in a specific way but it looks like its still 668! possibilitys
22:54:36 <Desmond373> so thats gonna be a nah from me
22:55:59 <Desmond373> 4.5*10^1598
22:59:57 <Welkin> why permutations? Can you use combinations instead?
23:00:09 <Welkin> put them all in a set
