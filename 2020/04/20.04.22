00:26:34 <random_> hey guys, anyone familiar with TH?
00:26:57 <random_> I'm trying to replace code "in-place" using a Name
00:27:22 <random_> e.g. ($(showName someTypeName)Id)
00:27:34 <random_> to get SomeTypeId written in code
00:29:35 <random_> ah, I just needed `liftString` :)
00:31:20 <koz_> @quote next
00:31:20 <lambdabot> accel says: next time I'll read a few research papers before I start trolling hakell
00:31:28 <koz_> ... not the one I wanted...
00:31:53 * koz_ was after 'Another satisfied customer!' or something like it.
00:33:04 <ziman> @quote customer
00:33:04 <lambdabot> monochrom says: "customers who used == also liked: foldr, map, Ord, continuation passing style"
00:33:30 <koz_> @quote satisfied
00:33:31 <lambdabot> No quotes match. Are you on drugs?
00:33:40 <koz_> ... I feel seen/personally attacked. :P
00:33:46 <ziman> :D
00:37:29 <tdammers> lambdabot isn't interested in your feelings.
00:37:54 <koz_> tdammers: Lol.
00:45:17 <remexre> hm, what's the right way to do logging w/ fused-effects? there's not a fused-effects-katip I can see; is there something better than me rolling my own?
00:46:37 <remexre> I guess I basically just want log levels though, so rolling my own shouldn't be too bad
01:18:50 <freeside> er, i need hxt help. I'm trying to get a `traceValue` to print an `xshow` of the current node, but i'm helplessly lost in the arrow types.
01:21:53 <freeside> I can do a "show" inside a processChildren $ isElem >>> traceValue 1 show, but i can't replace `show` with anything else
01:22:57 <freeside> i need it to be an (XmlTree -> String), but all the functions i see under hxt seem to run inside the arrow context ... or maybe i haven't looked hard enough through the contents of https://hackage.haskell.org/package/hxt-9.3.1.18
01:25:58 <jchia> Any library recommendation for talking to mysql? mysql-haskell looks unmaintained and mysql-simple was updated very long ago. opaleye?
01:27:07 <freeside> http://book.realworldhaskell.org/read/using-databases.html
01:27:46 <freeside> https://hackage.haskell.org/package/HDBC-odbc
01:28:06 <merijn> jchia: opaleye only supports postgres
01:28:09 <[exa]> jchia: side note -- if you can switch database to non-mysql, do switch
02:00:24 <random_> hey guys
02:00:30 <random_> given some type family
02:01:01 <random_> class SomeFamily a where data AType a :: *
02:01:09 <random_> is there some hack to force AType to be a newtype?
02:01:51 <random_> can you have any constraints on AType, really?
02:02:32 <merijn> random_: You have a typeclass and a data family in that example, but no type family
02:03:10 <random_> merijn: pardon my ignorance, I'm not really an expert in that field
02:03:47 <random_> merijn: what change should be made in order for this to be categorized as a type family
02:03:55 <merijn> random_: A data family maps a type to a data type, a type family maps a type to a type
02:04:15 <Taneb> With a data family you define a new type for each instance
02:04:20 <merijn> (i.e. type families are essentially type level functions taking types and returning types)
02:04:25 <Taneb> For a type family you use a pre-existing type
02:04:30 <merijn> You can define newtype data families
02:04:41 <merijn> The GHC user's guide has examples of that
02:04:47 <random_> thank you guys
02:04:51 <random_> I'll google newtype data families
02:06:15 <merijn> random_: I highly recommend just googling for the GHC user's guide, it's quite good :)
02:06:36 <random_> merijn: I'm onto it
02:54:45 * hackage protolude 0.3.0 - A small prelude.  https://hackage.haskell.org/package/protolude-0.3.0 (sdiehl)
03:35:22 <zincy_> When I say to someone "Lets not do this computation in IO and try and keep as much of the code pure as possible" 
03:35:27 <zincy_> The little pedant in me dies.
03:35:44 <zincy_> What is the word I should be using since IO is pure.
03:51:39 <phadej> say non-IO :)
03:53:17 <Uniaika> (wait, IO is pure now?)
03:53:23 <Uniaika> (I didn't get the memo!)
03:53:55 <maerwald> Yes it is
03:54:26 <int-e> Computing IO actions (monadic values) is pure. Performing IO actions is not.
03:54:49 <maerwald> Performing anything isn't pure, so to speak, including evaluating pure expressions
03:55:37 <maerwald> :t evaluate
03:55:39 <lambdabot> a -> IO a
03:55:45 <Uniaika> Are you making the distinction between `main = pure $ 1 + 2 :: IO Int` and `main = launchMissiles :: IO ðŸ’€`?
03:55:57 <maerwald> no
03:56:31 <maerwald> I really wish this was added to the fbut FAQ: https://github.com/quchen/articles/blob/master/fbut.md
03:58:18 <maerwald> Uniaika: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
03:58:58 <maerwald> If you say IO is impure, then haskell is impure too.
03:59:47 <maerwald> What is impure is unsafePerformIO, because the results depend on the evaluation strategy.
04:06:13 <merijn> IO being pure is the entire reason for having IO in the first place >.>
04:06:34 <maerwald> Yeah
04:07:04 <int-e> You can think of Haskell (minus unsafePerformIO and related things) as a pure language, but a Haskell *program* comes with an interpreter for IO values that runs the IO value produced by main.
04:07:15 <maerwald> merijn: https://github.com/quchen/articles/issues/24 
04:07:43 <Uniaika> int-e: is this interpreter the RTS? Or is it more conceptual?
04:08:38 <int-e> Uniaika: It's a lie (to children) if you look at how ghc actually works.
04:08:54 <merijn> Uniaika: It's important to distinguish the meaning/semantics of code and how those semantics are achieved
04:09:17 <Uniaika> ðŸ˜­
04:09:19 <Uniaika> okay
04:09:30 <Uniaika> I'll read the paper, thanks maerwald, merijn and int-e 
04:10:13 <merijn> Uniaika: Conceptually, the meaning is pure evaluation leads to an IO () value that gets interpreted/run by the RTS. But that's a stupid way to compile things
04:10:15 <int-e> Uniaika: Because ghc's IO world is embedded in the functional world that embraces side effects; the ghc RTS is largely support code for the *pure* language semantics (garbage collection etc.), though IO isn't absent (thread support, synchronization primitives are also part of the RTS).
04:10:31 <maerwald> Uniaika: from the paper: "A language is purely functional if 1. it is a conservative extension of the simply typed lambda-calculus, 2. it has well-defined call-by-value, call-by-need and call-by-name ealuation functions (implementations) and 3. all three evaluation functions (implementations) are weakly equivalent" (see chapter about weak equivalence)
04:10:36 <merijn> So realistically those things are interleaved, and in GHC there isn't even a hard boundary, just shades of gray
04:11:01 <zincy_> It is isn't a "lie" to say IO is pure.
04:11:15 * hackage popkey 0.0.0.1 - Static key-value storage backed by poppy  https://hackage.haskell.org/package/popkey-0.0.0.1 (identicalsnowflake)
04:11:15 <zincy_> It using a conceptual model that separates evaluation from execution
04:11:27 <merijn> Uniaika: Ad hoc example: Pure function means "same input = same output with no observable side-effects", yes?
04:11:28 <zincy_> Is it a lie to say there is a Heap and a Stack
04:11:30 <int-e> Uniaika: (that also explains how a function like unsafePerformIO can exist). But conceptually, the outside interpreter that is responsible for the effects is very clean and nice.
04:12:04 <Uniaika> merijn: yes!
04:12:19 <merijn> Uniaika: Now consider "what does 'putStrLn "foo"' evaluate too?"
04:12:22 <int-e> (tweak: outside -> external)
04:12:26 <zincy_> Purity isnt enforced in Haskell
04:12:32 <zincy_> Rather it was never added in!
04:12:35 <merijn> Uniaika: It doesn't evaluate to printing something on the screen
04:12:50 <zincy_> *impurity wasn't added in
04:13:08 <merijn> Uniaika: You can see this by simply doing "deepseq (map print [1..10])" (deepseq fully evaluates everything) that will not print to the screen
04:13:15 * hackage cache-polysemy 0.1.1 - cached hashmaps  https://hackage.haskell.org/package/cache-polysemy-0.1.1 (Poscat)
04:13:25 <merijn> It will just produces IO values that, when tied into "main" print to the screen
04:13:40 <int-e> > print "123" `seq` ()
04:13:42 <lambdabot>  ()
04:13:48 <Uniaika> merijn: does it evaluate to ()?
04:14:11 <maerwald> and IO values have no NFData instance, so you can't deepseq them :P
04:14:14 <merijn> Uniaika: So, if I evaluate 'putStrLn "foo"' at 10 different places, I will get an 'IO ()' each time, and that IO action will be "the same" (it does the same thing
04:14:27 <merijn> Uniaika: No, they evaluate to "IO ()"
04:14:40 <mniip> that's because IO is a function and those don't have normal forms
04:15:00 <Uniaika> oh, okay
04:15:09 <merijn> mniip: GHC specific detail that drags in needless implementation details (aka lies!) into things
04:15:27 <mniip> I sure love my lies
04:15:34 <merijn> Uniaika: "IO ()" is "just a value" in the same way "Maybe ()" is
04:15:40 <Uniaika> okay
04:15:57 <Uniaika> yeah it's sometimes difficult to get rid of the idea that IO is a special snowflake
04:15:58 <merijn> mniip: Sure, glorious GHC implementation details are great, but not when discussing (non-operational) semantics of Haskell code
04:16:01 <int-e> lies to children (that is, simplified and idealized explanations for teaching) are the best lies.
04:16:08 <mniip> Uniaika, it could be not that way
04:16:21 <Uniaika> well, it *is* a little bit special, but it's still something that has a Monad instance, an Applicative instanceâ€¦
04:16:29 <mniip> it could be a free monad over FFI calls
04:16:40 <merijn> Uniaika: There are several (fairly straightforward) ways to implement IO without magic
04:16:41 <mniip> which would be a very regular haskell value with no GHC magic at all
04:16:44 <mniip> inspectable even
04:16:50 <merijn> Uniaika: They'd have *abysmal* performance, though ;)
04:17:08 <Uniaika> :D
04:17:50 <zincy_> int-e: Lie, in the same sense that the heap and the stack is a lie.
04:18:14 <merijn> Uniaika: The trick of IO is that, because it's internals are unobservable during evaluation (since you can't get anything out), evaluation cannot ever depend on the internals/effects of IO directly
04:18:21 <mniip> here's an IO powered by lists of requests and responses a-la early haskell https://gist.github.com/mniip/1c49b715cd00be865e54f669883e2b92
04:18:34 <int-e> zincy_: Do you think RAM is a lie, too?
04:19:24 <zincy_> If IO is a *lie* then anything based on a conceptual model is a lie.
04:19:26 <merijn> Uniaika: Therefore Haskell evaluation is pure (since evaluation cannot be affected by IO). Now, you need a second step to make "IO ()" do anything useful and in that step the results of IO are observable, but at that point the *haskell* parts are fixed
04:19:37 <int-e> zincy_: The nice thing about terms like "heap" and "stack" is that you can make them as concrete as necessary.
04:19:55 <Uniaika> okay, hence the sentence "Haskell *evaluation* is pure"
04:20:00 <Uniaika> because its execution isn't
04:20:01 <zincy_> int-e: Always mental models though
04:20:08 <Uniaika> but the two are clearly separated
04:20:20 <int-e> zincy_: Well that's human nature.
04:20:22 <zincy_> Where in the hardware is the separation enforced?
04:20:52 <merijn> Uniaika: Right, but the logic bits are all in the pure/evaluation part :)
04:21:00 <int-e> zincy_: In the CPU by executing the right bits from your program that ensure the separation.
04:21:15 <Uniaika> merijn: which make it easier to reason about, right?
04:21:18 <int-e> Plus... the RAM abstraction which tells you that there's no aliasing.
04:21:21 <Uniaika> since it's pure
04:21:23 <merijn> Uniaika: So the reason about code you only have to reason about the pure bits (well, up to some level, digging into gory GHC internals can be fun :))
04:21:26 <merijn> Uniaika: Right
04:21:43 <zincy_> int-e: Right so to the cpu it just sees bits for memory addresses
04:21:44 <int-e> zincy_: It's a rabbit hole, obviously.
04:21:52 <zincy_> It has know concept of the heap or the stack.
04:22:07 <Uniaika> I don't think I've understood all the fine details of this discussion but I get the gist.
04:22:07 <zincy_> int-e: Exactly the rabbit hole is called layers of abstraction.
04:22:12 <zincy_> Its how computer science works
04:22:18 <Uniaika> (then again, I'd need to properly read the paper, like several times)
04:22:22 <int-e> s/computer //
04:22:30 <merijn> Uniaika: Which paper (I missed that)?
04:22:33 <zincy_> Yes, thanks :D
04:22:39 <zincy_> Science!
04:22:41 <int-e> Anyway, this is drifting too far into philosophy :)
04:23:01 <zincy_> Your initial point was philosophical
04:23:05 <zincy_> :)
04:23:16 <Uniaika> merijn: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
04:23:18 <int-e> Though, let me add one more quip: It's abstractions all the way down.
04:23:29 <zincy_> int-e: I totally agree!
04:23:34 <zincy_> But they are useful right
04:23:55 <int-e> They are useful because you never unfold all of them.
04:24:32 <zincy_> Yeah but it sure is fun to try!
04:25:27 <merijn> Uniaika: Some other nice (and accessible) papers are Wadler's "Monads for Functional Programming" and the STG paper (on how to compile lazy functional languages to real hardware) and "Lazy Functional State Threads" which covers both the gory details of how IO is implemented in GHC and how ST works
04:25:32 <merijn> @where stg
04:25:32 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
04:26:45 <zincy_> This is a good read.
04:26:45 <zincy_> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf
04:26:47 <Uniaika> I'm going to have to add them to my list :D
04:27:40 <zincy_> Uniaika: I have one of those lists :)
04:28:40 <Uniaika> zincy_: I'm already trying to finish the selective applicative functers paper :P
04:29:29 <zincy_> Hehe
04:32:36 <merijn> Uniaika: That one is considerably harder than the ones I mentioned ;)
04:33:40 <kaol> What's the state of aarch64 support in GHC? Is it production ready?
04:33:57 <merijn> Define "production ready" :)
04:34:31 <merijn> Everything is production ready if you're brave enough :p
04:34:43 <maerwald> Uniaika: https://hackage.haskell.org/package/selective-0.4.1/docs/Control-Selective.html#v:branch check the exercise in the documentation, I found it enlightening
04:34:45 <Uniaika> merijn: oh!
04:34:53 <Uniaika> maerwald: thanks <3
04:35:00 <maerwald> implement branch in terms of select
04:35:11 <maerwald> A little mind bending at first
04:36:48 <kaol> What's the first version that had official support? 8.6?
04:38:55 <kaol> 8.2's release notes call it "still a bit experimental".
04:39:36 <merijn> kaol: I think it's going to be "a bit experimental in all versions" :p
04:44:22 <maerwald> kaol: you messing with cross compilation?
04:44:56 <maerwald> I'm currently preparing my toolchain to build a cross-compiling GHC for arm/aarch
04:49:26 <kaol> I'm not messing with anything yet. I'm considering a job offer. I would be in a position to say that we'd use Haskell.
04:49:40 <maerwald> There's also work of adding bindists for arm/aarch for cabal/GHC: https://github.com/haskell/cabal/issues/6616#issuecomment-615913991
04:52:10 <siraben> maerwald: Currently compiling a heck of a lot of things on Nix to cross-compile to ARM.
04:52:25 <maerwald> Thank god I don't need nix for this :)
04:52:29 <siraben> Using siraben: https://github.com/input-output-hk/haskell.nix does have some arm support wired in https://github.com/input-output-hk/haskell.nix/blob/master/overlays/armv6l-linux.nix
04:52:38 <siraben> Oops that's pasted from #ghc heh
04:52:42 <maerwald> My distro has native cross support, luckily
04:53:05 <siraben> Haha nice
04:53:11 <siraben> Which distro?
04:53:15 <maerwald> exherbo
04:53:24 <siraben> I'm on NixOS, so it's Nix or Nix, take your pick!
04:53:27 <siraben> Ah.
04:53:48 <siraben> What's the compilation target?
04:54:03 <maerwald> I'm building for: x86_64-pc-linux-gnu armv7-unknown-linux-gnueabihf aarch64-unknown-linux-gnueabi i686-pc-linux-gnu
04:54:43 <maerwald> And then I'll see if I can add cross-compile support to ghcup
04:54:56 <maerwald> But not sure that makes too much sense, since your gcc etc needs that anyway
04:55:09 <siraben> I see.
04:55:17 <maerwald> Don't know the state of affairs in debian etc.
04:59:44 * siraben contemplates just getting cabal on the ARM target
05:00:03 <siraben> Poor 1 GHz ARM v9 would not handle it, I suppose.
05:04:07 <typetetris> What character encoding is assumed by aeson for json data? I can't find any conlusive documentation on that.
05:04:53 <siraben> I would guess UTF-8?
05:05:26 <Uniaika> yes, UTF-8
05:06:32 <tdammers> technically, parsing ByteStrings into JSON is invalid
05:07:15 <quintasan> Am I a dummy for trying to install Ormolu in my Haskell project using Stack? I'm not sure how does one deal with linters. I'm used to saying `group :development; gem "rubocop" end` in my Gemfile and bam I have a linter installed for my Ruby project. Is there an equivalent option for Haskell?
05:07:42 <tdammers> the standard says "A  JSON  text  is  a  sequence  of  tokens  formed  from  Unicode  code  points  that  conforms  to  the  JSON  value grammar."
05:08:04 <tdammers> a ByteString isn't Unicode code points; the appropriate data types for that would be [Char] or Text
05:08:05 <olavx200> Can someone explain what the colon syntax means in this LOC: repeat' x = x:repeat' x  
05:08:23 <tdammers> IMO that's a design mistake in Aeson
05:10:05 <int-e> olavx200: the colon is one of the constructors of the list type; [] is the empty list; x : xs is the list with head x and tail xs.
05:10:07 <maerwald> tdammers: you mean the "decode" function?
05:10:08 <dramforever> > 123 : [3, 4, 5, 6, 7]
05:10:10 <lambdabot>  [123,3,4,5,6,7]
05:10:34 <tdammers> maerwald: among other things, yes. the general decision to represent JSON source as ByteString
05:10:35 <merijn> tdammers: I know right!
05:10:48 <merijn> tdammers: The lack of Text support for JSON is a huge eyesore
05:10:59 <olavx200> Thanks int-e and dramforever. Cool bot btw
05:11:02 <tdammers> merijn: not just that, it's just plain out incorrect
05:11:07 <merijn> I know
05:11:19 <merijn> And it'll never get fixed :(
05:11:25 <maerwald> tdammers: but decode will fail if there's invalid input, no?
05:11:41 <merijn> maerwald: How can it determine that?
05:11:46 <merijn> maerwald: It blindly assumes utf-8
05:11:49 <maerwald> Does it?
05:11:54 <merijn> maerwald: But JSON isn't utf-8
05:11:54 <tdammers> maerwald: that's not the point. the point is that decode assumed UTF-8, so it will also fail on valid but non-UTF-8 input
05:14:09 <Uniaika> I've got a ghcide question: I've installed ghcide with stack build --copy-compiler-tool (so that it's available only when to the compiler it's been build for)
05:14:39 <Uniaika> now, is there an equivalent for the (I think) HIE helper that selected the proper ghcide version for each project?
05:14:59 <merijn> maerwald: aeson doesn't provide anyway to specify the encoding, so whatever it's doing must be wrong
05:15:17 <maerwald> Ah, you mean that
05:15:31 <maerwald> Yeah sure
05:16:06 <merijn> maerwald: The bigger issue being is that there isn't even any ambiguity or engineering justification. JSON is *explicitly* specified in terms of "unicode text"
05:16:26 <sm[m]> quintasan: no
05:16:41 <maerwald> So you're basically obliged to convert your bytestring yourself into something unicode-ish
05:16:49 <tdammers> merijn: the RFC is, but the original "spec" as published on json.org is vague about it
05:17:15 <merijn> maerwald: Yes. Any reasonablye JSON parser in Haskell should take Text
05:17:41 <maerwald> I guess it must have been "laziness", because most of the networking libs use ByteString, I guess
05:17:41 <tdammers> or, alternatively, ByteString plus an explicit encoding specifier
05:17:53 <merijn> maerwald: Because only the user can know where bytestring comes from and thus how it should be decoded
05:18:01 <maerwald> Yes
05:18:01 <merijn> tdammers: Sure
05:18:04 <tdammers> if you insist on parsing directly from the raw encoded text for performance reasons or whatever
05:18:51 <tdammers> or at the very very least make it clear that it has to be UTF8, e.g. by renaming the decode function to decodeFromUtf8 or some such
05:20:15 <maerwald> waargonaut has decodeFromText, decodeFromString and decodeFromByteString
05:21:14 <maerwald> ouch, it uses decodeUtf8 xDD
05:21:27 <maerwald> https://hackage.haskell.org/package/waargonaut-0.8.0.1/docs/src/Waargonaut.Decode.Runners.html#decodeFromText
05:21:43 <maerwald> boom, decodeUtf8 errors out unatchable on bad input
05:23:17 <tdammers> oh dear...it looks like Warp + WAI isn't honest about rawQueryString
05:23:34 <lyxia> "and it'll never get fixed"    This seems trivial to fix by adding a Text -> Maybe Value function?
05:23:39 <quintasan> sm[m]: So the only reasonable choice is to install ormolu globally and usign that?
05:24:46 <tdammers> if I request http://localhost:7000/?foo=%2B+ and capture the HTTP request with netcat, it faithfully reproduces the percent encoding in the query string
05:25:20 <tdammers> but when I read the rawQueryString from the WAI Request, it shows ?foo=++
05:25:51 <maerwald> I hope uri-bytestring doesn't do that
05:27:11 <tdammers> oof
05:27:30 <tdammers> this is bad, and worse yet I don't know which package to blame
05:29:50 <maerwald> with uri-bytestring I get http://localhost:7000/?foo=%2B%20 afer (serialize . deserialize)
05:32:21 <merijn> Naming poll: I have a function that detects the number of times changes occur in a sequence/stream of data (i.e. [1,1,1,2,2,2,3,4] would produce 4 (since the transition from no data to 1 is counted)). What'd be a good name? I've got "count_transitions" atm, but that feels like an awkward name
05:33:11 <siraben> merijn: Ooh I recall something like this in SICP
05:33:23 <tdammers> maerwald: ig dear
05:33:24 <Arahael> merijn: I recall this pre-existing in haskell.
05:33:39 <tdammers> s/ig/oh/
05:33:46 <merijn> Arahael: This is secretly not in the Haskell bit of my codebase, so that doesn't help ;)
05:34:42 <merijn> (Actually, I guess that depends on whether SQL embedded in my Haskell counts as part of the Haskell?)
05:34:54 <tdammers> what's strange though is that this only happens when feeding WAI requests through http-reverse-proxy's waiProxyTo; running the proxied application standalone works fine
05:34:56 <Arahael> merijn: Heh, actually I can't recall what the function name is in haskell, but I was hoping to imply that you could give it the same name. :)
05:38:39 <merijn> Time for Data.List archaeology
05:39:35 <siraben> Anyone know what happened: http://ix.io/2j4A ?
05:39:37 <merijn> I don't think I've ever seen anything like that, though?
05:39:59 <merijn> siraben: Wrong GHC version
05:40:05 <siraben> merijn:  SICP called this "zero crossings"
05:40:11 <merijn> siraben: [__1] rejecting: base-4.12.0.0/installed-4.1... (conflict: haskell-on-arm =>
05:40:14 <merijn> base>=4.13 && <4.14)
05:40:20 <siraben> You may want to call it, countCrossings or something
05:40:21 <siraben> Ah
05:40:22 <siraben> Hm.
05:40:33 <merijn> haskell-on-arm depends on base 4.13 and your GHC version has base 4.12
05:40:56 <merijn> 4.13 is 8.8
05:41:29 <siraben> Ok so I'll change the cabal file
05:41:32 <siraben> Yay it work
05:41:36 <siraben> works
05:42:47 <maerwald> merijn: https://git.io/JfkSo :P
05:43:22 <maerwald> constantly looking that up in the GHC doc was annoying me too
05:43:45 <merijn> maerwald: https://wiki.haskell.org/Base_package :p
05:43:53 <siraben> So is there even a reason to keep the lower in my cabal file?
05:44:02 <siraben> When would I want it to have a least version?
05:44:13 <merijn> siraben: When it doesn't compile/work with older versions
05:44:46 <merijn> siraben: If you know your package only works with GHC 8.0 or later, you put in a lower bound on base so people don't bother trying to build with older versions
05:45:00 <siraben> Ah.
05:45:59 <merijn> I guess instead of crossings (which seems wrong) I could consider them edges...
05:46:13 <merijn> (as in edge vs level triggered)
05:46:34 <siraben> Right.
05:46:36 <siraben> countEdges, then?
05:46:49 <siraben> Crossings would be against a baseline, there isn't one here
05:50:07 <maerwald> merijn: that isn't even uptodate!
05:50:23 <maerwald> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history is
05:56:23 <merijn> maerwald: Be the change you wanna see in the world! ;)
06:20:13 <frdg> Im confused on why we need to make a distinction between a Map data structure and a list of tuples. Is this because we can have Map structures of many different forms?
06:24:06 <nshepperd> because... they're different?
06:24:35 <merijn> frdg: Map is many, many times more efficient
06:24:37 <nshepperd> Map is a tree of some kind, which is more efficient than a list
06:24:56 <jchia_> How can I convert a value of a type of the class IsString into a String value?
06:24:56 <frdg> ok thanks
06:25:03 <merijn> frdg: Looking up something in a list of tuples is O(N), looking up something in a map is O(N log N)
06:25:19 <jchia_> There is fromString to do the conversion in the opposite direction.
06:25:23 <merijn> jchia_: You can't
06:25:28 <merijn> jchia_: At least, not via that class
06:25:35 <jchia_> OK
06:25:37 <merijn> And not in a general way
06:25:44 <frdg> ok so fromList turns the list into a tree?
06:25:52 <merijn> frdg: Yes
06:25:57 <frdg> ok thanks
06:26:01 <jchia_> I have pack and unpack littered all over my codebase and I was hoping to write some general functions that can deal with both String and Text.
06:26:47 <merijn> frdg: fromList and toList just exist because sometimes it's convenient to provide/get everything as a list (for further processing), but that's not how Map works internally
06:33:15 <jchia_> Can someone help me understand this redundant constraint warning under GHC 8.8? https://gist.github.com/jchia/6cc92e686dda4a422832dcb191a2c2b5
06:47:40 <sm[m]> quintasan: I meant no, you're not a dummy for wanting that. You can do stack install ormolu inside or outside your project; in either case the executable will be installed "globally", ie in ~/.local/bin. Sometimes it's worth doing in your active project to take advantage of the "warm" resolver that's configured there, ie you have lots of deps built for it. There is some tool dependency list you can use in your .cabal or
06:47:40 <sm[m]> package.yaml file. I think it's not often used for this, perhaps for fear of making things more fragile
06:51:45 * hackage data-category 0.7.2 - Category theory  https://hackage.haskell.org/package/data-category-0.7.2 (SjoerdVisscher)
06:54:56 <sm[m]> https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-build-tool-depends
06:55:20 <oats> silly question, but does anyone have a memory shortcut for the directionality of "<$"?
06:55:35 <oats> > 5 $> Maybe ()
06:55:38 <lambdabot>  error:
06:55:38 <lambdabot>      â€¢ Variable not in scope: ($>) :: Integer -> t0 -> t
06:55:39 <lambdabot>      â€¢ Perhaps you meant one of these:
06:55:45 <oats> :<
06:55:52 <oats> > 5 <$ Maybe ()
06:55:54 <lambdabot>  error:
06:55:54 <lambdabot>      â€¢ Data constructor not in scope: Maybe :: () -> f b0
06:55:54 <lambdabot>      â€¢ Perhaps you meant variable â€˜maybeâ€™ (imported from Data.Maybe)
06:56:09 <oats> oh, I'm just dumb
06:56:13 <oats> > 5 <$ Just ()
06:56:15 <lambdabot>  Just 5
06:56:33 <oats> I keep thinking that it's like "injecting" a value into a context, but that's not correct
06:58:16 * sm[m] wonders what's the use case for build-tool-depends: thispackage:myexecutable
07:00:10 <daphnis> was just trying to enter the first recursive function in hutton:   sm [] = 0    /    sm (n:ns) = n + sm ns        /        but am told Exception: .. Non-exhaustive patterns in function sm
07:00:11 <sm[m]> yikes.. Planet Haskell feed thinks it has 58 new posts
07:02:34 <merijn> sm[m]: Which part of that?
07:03:35 <sm[m]> merijn: pardon ?
07:03:51 <merijn> sm[m]: The use case of which part of that?
07:04:21 <merijn> "build-tool-depends"? "thispackage:foo"? some other decomposition?
07:04:41 <sm[m]> I mean when would you put an executable from the current package in build-tool-depends
07:04:57 <merijn> sm[m]: When you depend on it to build?
07:05:26 <merijn> sm[m]: Suppose you have library foo which requires special preprocessing and said preprocessor executable is defined in the same package
07:05:40 <sm[m]> I
07:05:41 <merijn> You can't build the library until the executable has been built
07:06:00 <sm[m]> and I can't add that executable to build-depends ?
07:06:25 <merijn> sm[m]: build-depends is for packages (libraries, really) that Setup.hs depends on
07:06:38 <daphnis> it's supposed to be possible to define a summing function (sum) by entering those two lines into ghci, so i tried it with sm instead of sum, but it didn't work
07:06:49 <merijn> sm[m]: build-tool-depends is for, well, build tools that are required (and must thus be on the path while running the build)
07:06:50 <sm[m]> so build-depends is for libs and build-tool-depends is for exes.. I see
07:06:58 <daphnis> oh, is sm something else?
07:07:39 <merijn> sm[m]: https://cabal.readthedocs.io/en/latest/cabal-package.html?highlight=build-tool-depends#pkg-field-build-tool-depends
07:07:46 <daphnis> oh, sorry, one of you is sm and you're talking about something else :)
07:08:30 <sm[m]> merijn yes I've been reading that
07:29:33 <sm[m]> oh, a new book to suggest: https://www.amazon.com/Haskell-Very-Beginning-John-Whitington/dp/095767113X/
07:32:52 * ski idly recalls the "mean bird" Haskell book
07:33:35 <jophish> What's a nice way to check the inferred type of an expression in a haskell testsuite?
07:33:49 <jophish> I'm sure I've seen some nice implementation of this somewhere
07:40:07 <sm[m]> if you're running ghcid, or an ide.. give it some bogus type signature ?
07:44:42 <jophish> sm[m]: I meant as part of an automated test suite
07:44:48 <jophish> I think doctest and ':t' could work well
07:45:15 <sm[m]> ah
07:46:04 <sm[m]> so testing a compile-time attribute at run time.. ? I guess no harm in it
07:55:11 <kuribas> I think people from other language who say monads aren't useful just aren't used to thinking about edge cases.
07:57:17 <tdammers> saying that monads aren't useful is like saying that gravity isn't useful
07:57:23 <tdammers> that may be the case, but they still exist
07:57:36 <tdammers> the question is whether *formalizing* them is useful, and the answer to that varies
07:58:00 <tdammers> in Haskell, it is very useful, because the language, due to its typed foundations, can make a lot of use of the abstraction
07:58:20 <tdammers> likewise, having a formal model of gravity is very useful when you're trying to launch rockets into a low earth orbit
07:58:50 <tdammers> but if your language can't make much use of the abstraction, then it doesn't make as much sense to formalize the monad pattern into a first-class language construct
07:58:53 <kuribas> I mean how the maybe monad makes you handle all failing cases in one way or the other.
07:59:13 <tdammers> yes, and that's only possible because we have this type checker that forces you to handle all the cases
07:59:16 <kuribas> tdammers: perhaps not, but I still feel these languages are missing out.
08:00:00 <tdammers> you can write a Monad abstraction and an implementation for Maybe semantics for it in JavaScript, but it's not going to be very useful in practice
08:00:37 <tdammers> they are missing out, but not so much on monads, but on a more general notion of abstracting such patterns and having the compiler guard your back
08:04:31 <kuribas> lisp when-let is like monadic do I suppose
08:34:02 <jchia_> Why is there no MonadFail instance for Either String?
08:34:33 <johnw> more fun with unlawful traversals:
08:34:34 <jchia_> fail can be just defined as Left
08:34:35 <johnw> > [('a',1 :: Int),('b',2),('c',3),('d',4)] & partsOf (each.filtered (even.snd)._2) %~ reverse
08:34:37 <lambdabot>  [('a',1),('b',4),('c',3),('d',2)]
08:34:58 <jophish> Is it possible to get ghci to not print automatically?
08:36:03 <jchia_> Someone ask the same question. I'm going to read the discussion. https://gitlab.haskell.org/ghc/ghc/issues/12160
08:37:14 <siraben> johnw:  Why would one want unlawful traversals?
08:37:55 <johnw> because I know in my case that it works
08:38:24 <johnw> here's the actual snippet I'm using: https://gist.github.com/jwiegley/3b33dcf7bb85c78285576dd172b82508
08:38:47 <johnw> without partsOf and filtered, this just requires a noisy mix of lens, map and if
08:39:27 <johnw> in fact, I might not even need partsOf here, since the input is a list
08:39:31 <siraben> Hm.
08:39:34 * siraben has yet to learn lenses
08:39:59 <siraben> Rather, the specific combinators in use.
08:40:17 <johnw> ah yes, I only need: put $ evs & each.filtered (\e -> e^.plKind == WashLoss) %~ ...
08:40:37 <siraben> :t (%~)
08:40:39 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
08:40:42 <johnw> i.e., modify the list by applying the given function to each element matching the predicate
08:40:52 <siraben> I see.
08:40:55 <johnw> selective map
08:41:05 <siraben> What's the larger program here?
08:41:22 <siraben> Ah, so I can see how lenses would be useful in perform a selective map.
08:41:26 <johnw> it implements the US IRS' "wash sale rule" as a Haskell function
08:41:28 <siraben> s/perform/performing
08:42:00 <johnw> I use lenses because I find them the most compact way to manipulate state, maps and lists of structures
08:42:05 <siraben> Heh
08:42:25 <johnw> https://github.com/jwiegley/thinkorswim/blob/master/src/ThinkOrSwim/Wash.hs
08:42:33 <siraben> Without this selective map, what would the Haskell way to do it be? (\x -> if p x then f else id) <$> ls?
08:42:36 <oats> the lens state operators are really fun
08:42:45 <siraben> Oops, I mean
08:42:47 <oats> s t a b
08:42:53 <johnw> map (\x -> if p x then f x else x) xs
08:42:56 <siraben> (\x -> if p x then f x else x) <$> ls
08:43:02 <siraben> Right
08:43:53 <siraben> In your experience, how useful is it to know the why of lenses, i.e. their laws, categorical meaning, etc. as opposed to how to use them?
08:44:16 <oats> > (1, 2) & both %~ succ
08:44:18 <lambdabot>  (2,3)
08:44:34 <oats> embrace the succ
08:44:38 <johnw> I find it quite useful because I write new lenses/traversals/prisms as often as I use them, and it's helpful to know when they are lawful and when they are not
08:44:40 <siraben> > bimap succ (1,2)
08:44:43 <lambdabot>  error:
08:44:43 <lambdabot>      â€¢ Couldn't match expected type â€˜c -> dâ€™
08:44:43 <lambdabot>                    with actual type â€˜(Integer, Integer)â€™
08:45:18 <johnw> as for Bartosz's discovery that lenses relate to the Yoneda lemma in the category of functors, that's not quite as necessary ;-)
08:45:28 <siraben>  > bimap succ succ (1,2)
08:45:38 <siraben> I see.
08:45:39 <oats> > [["hello", "world"], ["!!!"]] & traverse.traverse %~ length
08:45:42 <lambdabot>  [[5,5],[3]]
08:45:42 <jchia_> If I have "foo :: MonadFail m => m a", how can I concisely write a "bar :: MonadFail m => m a -> Either String a"? Is there a library function to use? foo is some kind of parser (e.g. the result of calling parseTimeM https://www.stackage.org/haddock/lts-15.9/time-1.9.3/Data-Time-Format.html#v:parseTimeM) and I want to get Left if there's an error and Right if parsing succeeds.
08:46:08 <jchia_> Basically, I want to convert the fail to a Left.
08:46:25 <siraben> Does anyone have examples of papers using lenses in a calculational setting?
08:47:05 <siraben> e.g. Algebra of Programming style, Bird-Merteens sort of thing.
08:47:54 <oats> > execState (do both %= succ) (3, 4)
08:47:56 <lambdabot>  (4,5)
08:48:14 <oats> guess that doesn't need the do
08:52:44 * hackage quarantimer 1.20200422 - Coronavirus quarantine timer web app for your things  https://hackage.haskell.org/package/quarantimer-1.20200422 (JoeyHess)
08:53:00 <dsal> > execState (both %+ 1) (3, 4)
08:53:03 <lambdabot>  error:
08:53:03 <lambdabot>      â€¢ Variable not in scope:
08:53:03 <lambdabot>          (%+)
08:53:17 <dsal> Phone Haskell fail
08:55:44 * hackage dobutokO2 0.35.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.35.0.0 (OleksandrZhabenko)
08:55:46 <dsal> > execState (both += 1) (3, 4)
08:55:48 <lambdabot>  (4,5)
08:59:21 <johnw>  (3, 4) &~ both += 1
08:59:25 <johnw> >  (3, 4) &~ both += 1
08:59:27 <lambdabot>  (4,5)
08:59:51 <johnw> The "... &~ do ..." pattern is extremely handy
09:01:00 <[exa]> johnw: 'do' ? how?
09:01:22 <merijn> [exa]: How what?
09:01:39 <merijn> [exa]: You can put do in lots of places
09:01:43 <johnw> >  (3, 4) &~ do both += 1; both += 2
09:01:45 <lambdabot>  (6,7)
09:02:13 <johnw> it can be nicer than chaining &
09:02:18 <[exa]> oooh it combines like this, cool
09:02:46 <johnw> especially when the target needs Maybe, and so the 'do' puts you into the Maybe monad
09:03:00 <merijn> [exa]: do just desugar into some expression involving >> and >>= do you can use it anywhere those expressions are valid (modulo proper layout)
09:03:15 <johnw> at "foo" &~ do res <- someMaybeAction; guard (res > 2); pure res
09:03:39 <[exa]> yes, understood. I just didn't know what monad to put in there so it makes any sense
09:05:12 <[exa]> oh &~ implies State. good. :]
09:05:27 <johnw> oh, true, I"m not sure how that interacts with Maybe
09:07:27 <sm[m]> wow, do both += 1; both += 2 is equivalent to do {both += 1; both += 2} ?
09:09:06 <monochrom> the same way "let x=1;y=2 in 4" enjoys automatic {} insertion
09:09:20 <sm[m]> TIL!
09:09:54 <sm[m]> I have been using >>, ie  both +=1 >> both += 2 ?
09:10:08 <sm[m]> eh, without the question mark
09:10:38 <monochrom> The trouble begins when you rely on both: do let x=1; print x.  Automatic {} insertion is do { let { x=1; print x} }, which surprises intuitive humans.
09:13:06 <sm[m]> monochrom: I can see it would. That confirms my feeling that ; might hurt readability, since it's not used much
09:14:07 <monochrom> Yeah, use all of {;} or none.
09:14:59 <jchia_> Is there a MonadFail instance other than IO in a commonly-used library where the String argument to fail is not simply discarded? (In IO, the String gets put into a IOError that gets thrown.)
09:16:09 <oats> huh, MonadFail doesn't have a whole lot of instances in base
09:16:36 <oats> jchia_: ExceptT?
09:17:35 <jchia_> oats: ExceptT's MonadFail instance requires the wrapped monad to have a MonadFail instance.
09:18:00 <jchia_> The MonadFail instance is not "provided by" the ExceptT directly.
09:18:13 <oats> ah
09:18:17 <Uniaika> MonadError and runExceptT are The Wayâ„¢ !
09:18:19 <jchia_> The problem is this function: https://www.stackage.org/haddock/lts-15.9/time-1.9.3/Data-Time-Format.html#v:parseTimeM
09:18:27 <jchia_> I'm trying to recover the fail string without using IO.
09:18:33 <oats> Uniaika: what do you mean?
09:20:00 <monochrom> perhaps make your own newtype E a = E (Either String a)
09:20:01 <Uniaika> oats: MonadFail was a mistake, and I'm just banging pans in the street preaching for something better :P
09:20:25 <oats> Uniaika: ah, you mean MonadError should be used in place of MonadFail :)
09:20:55 <sm[m]> jchia_: I had a similar problem recently, and didn't find a good way other than catch the IOException 
09:21:14 <sm[m]> or IOError, whateveritis
09:22:35 <Uniaika> oats: yes :)
09:23:11 <sm[m]> Uniaika: can you say briefly why MonadFail was a mistake ?
09:23:23 <oats> Uniaika: how do you feel about MonadThrow/Catch?
09:25:54 <maerwald> MonadThrow with MonadIO turns into exceptions
09:26:15 <Uniaika> oats: if IO Exceptions belong to your error model, I mean why not
09:26:22 <monochrom> There is no reason for parseTimeM to be polymorphic in the monad, apart from a historical mistake.  Either X t is all it needs, where X is a suitable error type.  Even Maybe t, since few people actually care about the error information, and it's a whole another bikeshedding on what error information is right.
09:26:31 <Uniaika> sm[m]: yeah I've badly worded what I wanted to say
09:26:38 <maerwald> it's easy to do things wrong with MonadThrow, because once you're in IO, you think yeah well, it typechecks
09:26:58 <Uniaika> MonadFail as a solution to extract fail from Monad wasâ€¦ eh, better than leaving it there
09:27:40 <sm[m]> I definitely often want some kind of error information, and wish for an Either
09:27:59 <Uniaika> runExceptT is very nice to used with Either
09:28:04 <monochrom> To wit, recall that 2 decades ago "Data.Map.lookup :: (Ord k, Monad m) => k -> Map k v -> m v".  (Also recall that Monad included MonadFail.)
09:28:09 <Uniaika> I was introduced to it in a work codease
09:28:10 <sm[m]> but things are often More Complicated
09:29:05 <jchia_> monochrom: I'm not hopeful that they will change parseTimeM to use Either instead of requiring MonadFail. I'm probably going to need to make that Either newtype.
09:30:00 <monochrom> If someone uses String for error information, you can tell they are not serious about it.
09:30:36 <monochrom> Even unix syscalls don't just give you a string.
09:31:22 <jchia_> monochrom: Sometimes all you need to do is to relay the error with explanation to the human being.
09:31:24 <monochrom> Even java gives you exception subclasses, not just strings.
09:31:44 <jchia_> In that case String is simple and enough.
09:32:28 <monochrom> The problem is you are not the author of the string in this case. Now you have no control over the message quality.
09:32:44 <maerwald> Uniaika: ExceptT is awful, because errors don't combine :)
09:32:48 <maerwald> Same with Either
09:33:00 <dmwit> "awful" seems a bit strong
09:33:01 <Uniaika> Well you need Validation then
09:33:11 <Uniaika> yeah honestly it works just fine for a bunch of usecases
09:33:14 <monochrom> You don't even have control over the language.
09:33:20 <maerwald> dmwit: well, unless you want a master Error type for your entire codebase
09:33:33 <maerwald> rust solves it with heavy macro abuse
09:33:34 <Uniaika> monochrom: real programmers return .po translation keys in their errors
09:33:56 <Uniaika> maerwald: hey in fact you don't need to have that
09:34:09 <maerwald> String
09:34:21 <Uniaika> well, you should be running different `runExceptT` for DB and API calls
09:34:50 <maerwald> That's basically just rewrapping errors
09:35:54 <dsal> We could avoid so many arguments if we just didn't insist on having errors in our code.
09:36:03 <maerwald> lol
09:36:51 <maerwald> start with fixing malloc, so it can't fail... then fix networking to never error
09:38:24 <dsal> I've been on systems where malloc never fails.
09:38:37 <dsal> I'm not even sure it fails on linux most of the time.
09:41:15 <Uniaika> dsal: how can malloc not fail?
09:41:25 <Uniaika> wait, and what do we mean by fail?
09:41:40 <ChaiTRex> Uniaika: They mean that it pretends to succeed when it fails.
09:41:56 <Uniaika> ah *this*
09:43:16 <maerwald> You just don't set errno
09:43:34 <dsal> Uniaika: memory isn't real
09:44:12 <dsal> malloc, for the most part, just gives you an address you can start writing such that it should segfault if you go further past that address than you meant to.
09:44:23 <dsal> It typically doesn't "allocate" anything at all.
09:44:46 <dsal> It's all just debt.
09:45:22 <dsal> Because most programs take out loans and don't necessarily try to access all the resources they were granted.
09:45:48 <dsal> Any given haskell process on my computers is claiming to have allocated 1TB of RAM.  Like, on my 4GB chromebook. heh
09:46:46 <ChaiTRex> That's a horrible design. What happens if your program ends up needing 2TB?
09:47:52 <dmwit> It, or some poor collateral civilian, gets killed.
09:48:00 <dsal> 1TB ought to be enough for anybody.
09:48:02 <dmwit> Maybe both! Who knows.
09:57:47 <nshepperd2> turns out malloc is actually just for allocating address space
10:08:17 <Chousuke> I suppose that depends on the OS, but Linux does it that way because applications don't generally behave well if malloc fails.
10:08:55 <dsal> s/if malloc fails//
10:09:39 <monochrom> Heh linux malloc overbooking is a glorious overbooking story.
10:09:50 <Chousuke> well, yeah. Most applications assume they get a pony and that not getting a pony is not possible.
10:09:55 <monochrom> malloc doesn't fail.  writing to memory does.  >:)
10:10:39 <monochrom> Actually it's even more subtle.  Writing to memory may cause your process or some unrelated process to fail.  Spooky OOM at a distance.
10:11:14 <monochrom> Now recalling airline overbooking >:)
10:12:09 <monochrom> Buying tickets doesn't fail.  Ah when you actually go board the plane... you may be turned away, or someone already boarded will be unboarded to make room for you!
10:12:47 <[exa]> luckily airlines did the statistical testing
10:13:00 <[exa]> OSes did not
10:13:15 * hackage reflex-fsnotify 0.2.1.0 - reflex-frp interface for watching files  https://hackage.haskell.org/package/reflex-fsnotify-0.2.1.0 (abrar)
10:13:31 <monochrom> Yeah basically every profession acts more responsibly and maturely than programmers.
10:13:43 <Chousuke> well, to be fair, what's the OS supposed to do? everyone's going to blame the OS if they can't run their applications on it and it works elsewhere
10:13:44 <maerwald> monochrom: the manpage says malloc can fail with ENOMEM
10:14:27 <monochrom> the manpage further adds that on linux, under suitable kernal compile-time options (probably even default), malloc won't fail.
10:15:00 <monochrom> To be sure, for portability, you should still check.  Portability.  What do you think of that? >:)
10:15:13 <maerwald> I only do POSIX ofc!
10:15:26 <Chousuke> too bad POSIX is often pretty dumb :P
10:16:01 <maerwald> Tbf, it's hard to write something like POSIX
10:16:32 <Chousuke> it is. The real world often disagrees with attempts to standardize it :P
10:17:07 <Chousuke> and many standards are just "this is how it's been done previously so let's keep doing it"
10:17:29 <maerwald> Yes, so you don't break legacy implementations
10:18:06 <maerwald> Even many specs happen that way
10:18:21 <maerwald> E.g. rust will be like that, if it ever gets a spec.
10:18:30 <maerwald> "This is what we did"
10:18:43 <maerwald> Even if half of it was a bad idea :P
10:19:13 <maerwald> Or be like haskell: have a spec, but no compiler that implements it
10:19:15 <Chousuke> to be honest, it's not a bad way to do things. It's really hard to predict the future
10:20:08 <Chousuke> you'll want to standardize things to prevent unnecessary interoperability issues but if the standards prevents you from solving a problem then you bet people are going to ignore it.
10:20:16 <Chousuke> standard*
10:22:21 <monochrom> Even the haskell community did not think up Applicative, Alternative, and Monoid until recently.
10:25:17 <solonarv> Monoid? don't you mean Semigroup?
10:25:52 <monochrom> I'm an old geezer.  Monoid is new-fangled to me.
10:26:16 <monochrom> MonadFail? Never heard of that. >:)
10:26:43 <monochrom> MonadZero? That's the one I heard of from the generation before mine!
10:27:28 <maerwald> I abuse MonadFail sometimes: (Right v) <- pure $ someThingReturnsEither
10:27:31 <maerwald> So nice
10:28:30 <monochrom> That's not an abuse. That's what MonadFail is for.
10:28:48 <solonarv> well, wrapping it only to immediately unwrap it is a bit unsightly
10:28:58 <maerwald> yeah
10:29:17 <monochrom> The community's complaint was not against MonadFail, but against previously including it in Monad, inflicting it on all instances.
10:29:35 <maerwald> I don't mind using MonadFail for things that really *should not fail regularly*
10:29:48 <solonarv> yes, including those that don't have a sensible implementation
10:29:55 <solonarv> that's really the reason it was moved out
10:29:55 <monochrom> Oh! I see, you mean given the "pure" part.  Yeah.
10:30:19 <maerwald> It's MonadThrow for the poor
10:32:59 <monochrom> I sometimes (not often) do this in list comprehension: [ ... | ... , Right v <- [someThingReturnsEither], ... ], so I am more inclined to be OK with the do-notation equivalent :)
10:35:20 <monochrom> To a large extent it is a good balance between not-cumbersome and least-evil.
10:35:34 <monochrom> Like, would you rather play with fromRight? >:)
10:40:15 * hackage ribbit 1.1.0.1 - Type-level Relational DB combinators.  https://hackage.haskell.org/package/ribbit-1.1.0.1 (taphu)
11:03:13 <mr_sm1th> I can't wrap my mind around function composition. 
11:03:29 <mr_sm1th> How do I mentally read 'f . g'
11:03:35 <dmj`> mr_sm1th: let's look at the signature
11:03:37 <dmj`> :t (.)
11:03:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:03:45 <mr_sm1th> Yes I've been staring at it. :)
11:04:11 <dmj`> (f :: b -> c) (g :: a -> b) (x :: a) :: c
11:04:16 <mr_sm1th> "A function g whose output can be put into f.", resulting in a function that when given an input for g returns the output of f.
11:04:29 <dmj`> mr_sm1th: ok so here's the definition
11:04:31 <mr_sm1th> This is the most concice thing I can come up with to read that
11:04:31 <dmj`> @src (.)
11:04:31 <lambdabot> (f . g) x = f (g x)
11:04:37 <dmj`> let's make it more verbose with types
11:05:02 <dmj`> (.) f g x = (f :: b -> c) ((g :: a -> b) (x :: a))
11:05:30 <dmj`> so parens take highest precedence, ((g :: a -> b) (x :: a)) will get evaluated first, applying g to x
11:05:52 <dmj`> mr_sm1th: do you see how a -> b when given an 'a' produces a 'b'
11:06:09 <bor0> there are several ways to reason about it. probably the most intuitive one is to just say "g is applied first, then f is applied on the result", so (f . g) x = f (g x) as you saw by that `@src`. the other way to reason it is through types as dmj` is demonstrating
11:06:33 <mr_sm1th> dmj`, yes
11:07:01 <mr_sm1th> I feel like I'm getting it a bit more.
11:07:09 <mr_sm1th> :t fmap . fmap
11:07:11 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
11:07:15 <maerwald> Function composition is like minigolf
11:07:19 <mr_sm1th> Still struggeling with this a bit though. Let me take a look.
11:07:22 <maerwald> The ball goes from right to left
11:07:37 <bor0> :t fmap
11:07:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:08:16 <dmj`> mr_sm1th: Functor on (->) is (.)
11:09:55 <sm[m]> "after"
11:10:01 <sm[m]> oops
11:11:36 <mr_sm1th> I think my problem is that I try to read code out loud in my mind too much.
11:11:55 <mr_sm1th> That just doesn't work anymore at some point.
11:12:17 <sm[m]> f . g, "f after g". Works for me
11:12:27 <dmj`> mr_sm1th: that's ok, you probably have to do that to establish the neural pathways, eventually you'll write haskell via instinct without thinking, but the initial process to get there is important
11:12:37 <koz_> I agree with dmj` on this.
11:12:59 <koz_> At this point, I'm used to reading composition pipelines right-to-left.
11:13:05 <maerwald> minigolf :D
11:13:29 <koz_> maerwald: Or Hebrew.
11:13:33 <dmj`> thinking too hard when writing haskell means you're either learning haskell or you're trying to figure someone's bad use of types / type level programming
11:14:03 <maerwald> basically: whenever reading any library code
11:14:25 <sm[m]> or a good use that's beyond your current comfort level ?
11:14:49 <sm[m]> you can't tell which it is, of course
11:15:30 <dmj`> yea, it's a grey area
11:19:11 <mr_sm1th> Can I think of fmap as a function that takes a (a -> b) and returns a (f a -> f b)?
11:19:28 <koz_> mr_sm1th: Yeah. I found that super helpful.
11:20:03 <bor0> :t fmap -- it's exactly that. first argument is of type (a -> b)
11:20:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:20:23 <koz_> That point of view is especially fun when you consider liftA2 and pure.
11:20:29 <koz_> :t liftA2
11:20:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:20:33 <koz_> :t pure
11:20:35 <lambdabot> Applicative f => a -> f a
11:20:38 <koz_> :t fmap
11:20:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:20:42 <dmj`> mr_sm1th: you can also think of that as a homomorphism, (a -> b) -> (f a -> f b)
11:21:16 * koz_ . o O (pure is liftA0, fmap is liftA1)
11:25:19 <bor0> personally, I found abstractions to be useful only after I am familiar (or build intuition) with some concrete examples first, so I would suggest to keep playing with `.` and `fmap` first
11:27:11 <maerwald> Start without `.`, then realise you're writing lisp. Throw it all away and use `.`.
11:27:28 <mr_sm1th> Hehe.
11:27:36 <mr_sm1th> Alright.
11:32:52 <oats> (.) lets you make conveyer belts out of functions :D
11:33:16 <oats> or gluing together small functions to make bigger functions
11:33:27 <oats> (except you gotta read the flow right to left)
11:33:40 <oats> which my brain doesn't like so much all the time, but you get used to it
11:33:44 <maerwald> function composition should have been left to right
11:34:18 <tomjaguarpaw> so should function application!
11:34:25 <monochrom> and function application, argument on the left, function on the right, to go with it.
11:34:26 <berndl> That's why we have (<<<) and (>>>).
11:34:28 <oats> careful, that's how you get forth
11:34:41 <monochrom> Group theory textbooks do this.
11:34:56 <sm[m]> there's &
11:35:07 <maerwald> berndl: too many chars
11:35:12 <sm[m]> which I wish was in Prelude
11:35:47 <maerwald> sm[m]: that's the flipped $
11:35:50 <berndl> monochrom: The only one I know is Herstein's
11:35:51 <monochrom> If ; were not reserved, it would be great for left-to-right function composition.
11:36:01 <oats> heh
11:37:40 <monochrom> [1..] & (map (* 2); filter (\x -> x `mod` 3 == 0); take 10)
11:38:44 <solonarv> with the sledgehammer of RebindableSyntax, you can do this!
11:38:53 <solonarv> % :set -XRebindableSyntax
11:38:54 <yahb> solonarv: 
11:39:11 <maerwald> monochrom: coconut uses `..`
11:39:17 <maerwald> https://coconut.readthedocs.io/en/master/HELP.html#function-composition
11:39:23 <maerwald> but also reserved I guess
11:39:28 <solonarv> % let (>>) = flip (.) in [1..] & do map (*2); filter (\x -> x `mod` 3 == 0); take 10
11:39:29 <yahb> solonarv: [6,12,18,24,30,36,42,48,54,60]
11:39:58 <solonarv> but this is a terrible example because all of these functions commute!
11:40:18 <maerwald> And it has pipeline style composition via |>, but we use that for Alternative
11:40:35 <monochrom> > let fï¼›g = g . f in [1..] & (map (* 2)ï¼›take 10)
11:40:38 <solonarv> maerwald: Alternative is <|>, |> on its own isn't used for anything
11:40:38 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
11:40:44 * hackage birch-beer 0.2.4.2 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.4.2 (GregorySchwartz)
11:40:49 <monochrom> CJK semicolon saves the day :)
11:40:59 <solonarv> ah I was wondering which one that was
11:41:00 <oats> solonarv: I also use chainsaws to cut my butter
11:41:04 <maerwald> solonarv: oh right, it's just that every other lib defines it
11:41:04 <oats> like a civilized person
11:41:45 <koz_> oats: Love the taste of machine grease in my cow grease!
11:41:53 <koz_> Really heightens the flavour of my morning toast.
11:42:23 <solonarv> bah, if you use a correct amount of butter (read: lots) it will be diluted so much you won't notice :>
11:42:39 <koz_> solonarv: So basically, if you're Boris from Life of Boris. Or French.
11:43:08 <solonarv> I happen to be french, but I don't have a chainsaw
11:43:11 <solonarv> what do?
11:43:27 <koz_> solonarv: I don't have an answer for everything.
11:43:49 <koz_> (also, what's 'chainsaw' in French?)
11:44:08 <maerwald> koz_: my cross toolchain is working.... just cross compiling a few more C libs
11:44:27 <koz_> maerwald: So does this mean ghcup-hs is getting cross-comp support?
11:44:39 <maerwald> Well, I still dunno... how do you cross compile your toolchain?
11:44:41 <maerwald> gcc etc
11:44:46 <maerwald> that's a requirement
11:45:01 <maerwald> Does debian provide that stuff?
11:45:02 <koz_> I can build a C cross comp toolchain with little trouble.
11:45:05 <koz_> (I've done it before)
11:45:10 <koz_> Debian I have no clue.
11:45:15 <monochrom> When I was a kid, butter was so rigid, I would gladly use a chainsaw yes, anything less was not remotely half adequate.
11:45:29 <maerwald> koz_: well, the question is how would a user use it... without knowing those intricacies
11:45:41 <koz_> maerwald: Yeah, it's a question.
11:46:52 <solonarv> koz_: I had to look it up, but: tronÃ§onneuse
11:47:06 <koz_> TIL.
11:47:30 <maerwald> https://wiki.debian.org/CrossCompiling
11:48:15 <maerwald> I dunno, that documentation is confusing
11:48:26 <koz_> maerwald: Building cross-comp toolchains be that way.
11:48:32 <koz_> Debian docs _also_ be that way.
11:54:54 <olavx200> Hello. https://bpaste.net/XI2A Could I get some help with this?
11:55:54 <maerwald> koz_: I think it would be interesting to set up docker images that have full toolchain for cross-compiling GHC programs. Otherwise: the usualy suspects like nix.
11:56:17 <koz_> Nix can do cross-comp toolchains?
11:56:42 <maerwald> :t (!!)
11:56:44 <lambdabot> [a] -> Int -> a
11:56:44 <monochrom> olavx200: Perhaps simply a misunderstand of syntax?  fib (x-1) ?
11:56:57 <maerwald> olavx200: ^
11:57:58 <Uniaika> bummer, apparently I need to configure IPv6 to send an email to the hackage trustees for my account.
11:58:03 <olavx200> I don't understand. What should I change?
11:58:31 <monochrom> from "fib x - 1" to "fib (x - 1)", if this is what you have in mind.
11:59:27 <olavx200> Hmm that did not change the error.
12:01:14 <monochrom> Ah, maerwald's is a point too.  You get no guarantee that x is Int, but !! wants Int.
12:02:01 <monochrom> You're really better off with Num a => Int -> [a]
12:02:19 <olavx200> Okay so I need to change fib :: (Num a, Eq a) => a -> [a]?
12:06:27 <sm[m]> speaking of nix, would anyone know if it's practical on mac catalina yet ?
12:07:22 <maerwald> you mean after the /nix not writable escapade?
12:07:29 <olavx200> The signature was a part of the exercise so I will just remove the signature for now.
12:07:45 <maerwald> sm[m]: https://github.com/NixOS/nix/issues/2925
12:07:57 <sm[m]> maerwald: yes, last time I checked there was a big open issue - thanks!
12:08:31 <sm[m]> still open but they have a shiny new release advertising mac install, so let's see...
12:10:15 <sm[m]> no.
12:10:40 <maerwald> sm[m]: well, that's what happens with assumptions :P
12:11:49 <maerwald> And ofc, mac is gonna be an*l about it. The notarization is just another of those
12:14:10 <tabaqui1> Is it true that for any sum type, pattern matching will check patterns from left to right?
12:14:30 <merijn> tabaqui1: Yes, no, maybe, it depends
12:15:05 <tabaqui1> merijn: where can I find explanation?
12:15:33 <Darwin226> If  I have a traversal, is there a lens combinator similar to ^? but that lets me provide a default value instead of returning a maybe?
12:15:34 <tabaqui1> google "haskell pattern matching order"?
12:15:45 <merijn> tabaqui1: There is no haskell pattern matching order
12:15:54 <Darwin226> or better yet, some way I could write a ^. maybeMissingField . orDefault 0
12:16:07 <merijn> tabaqui1: It's not specified and compilers aren't even required to consistently use the same approach for every data type
12:16:57 <koz_> What does 'pattern matching order' even mean?
12:17:01 <tabaqui1> "The matching process itself occurs "top-down, left-to-right." "
12:17:05 <tabaqui1> https://www.haskell.org/tutorial/patterns.html
12:17:14 <tabaqui1> Is this statement still actual?
12:17:25 <merijn> tabaqui1: That refers to multiple patterns within a single function
12:17:37 <tabaqui1> ok
12:18:15 <merijn> So, if you have 3 lines of function "foo" it will only match line 2 or 3 if line 1 doesn't match
12:18:29 <tabaqui1> koz_: for example "case Foo False (factorial 10000000) of { Foo True 0 -> 1; _ -> 2 }" should return 1 in split-second
12:18:40 <tabaqui1> koz_: or probably not
12:19:43 <tabaqui1> merijn: allright, I will be considering that
12:19:44 <tabaqui1> thanks
12:20:22 <iqubic> tabaqui1: That's not going to work because the second line has a different number of expected parameters. You'll need a second underscore. But that's going to be returning 2, and never evaluate factorial 1000000.
12:20:53 <merijn> iqubic: Pedant mode: That's not specified either :p
12:20:54 <tabaqui1> iqubic: right, it should return 2, but I don't need second underscore, of course
12:21:24 <iqubic> merijn: You don't need a second underscore? Why not?
12:22:03 <tabaqui1> iqubic: why should I? case-expression always works with single datum
12:22:20 <merijn> iqubic: No, you need a second underscore. "factorial 1000000" never being evaluated isn't specified
12:22:26 <tabaqui1> "Foo anything anything" matches _
12:22:46 <tabaqui1> Foo is data constructor
12:23:35 <tabaqui1> ah, if you mean to avoid evaluation at all - then yes, I should underscore it
12:24:27 <tabaqui1> actually, I want to match something like "case (canIEvaluateThis :: Bool, evaluate this) of { (True, result) -> result; (False, _) -> other }"
12:24:36 <tabaqui1> and I can't switch lines because of multiple checks
12:25:09 <tabaqui1> which aren't booleans
12:27:58 <monochrom> olavx200: Then perhaps the exercise does not want you to use !! at all.
12:29:56 <sm[m]> maerwald: nevertheless, I'm pressing on.. I simply must have those powers of the dark side at last
12:32:17 <monochrom> If you want to switch to the dark side... Start a company, call it NPComplete, and compete with FPComplete. >:)
12:33:21 <monochrom> And your toolchain is called "queue".
12:33:35 <bgamari> hah
12:34:27 <koz_> monochrom: Aiming a bit low, aren't we? PSPACEComplete amirite?
12:34:40 <koz_> And call your toolchain 'qbf'.
12:35:27 <c_wraith> wow.  "ob run" the first time resulted in fetching several hundred files from the nix cache.  one at a time.  That took like half an hour.
12:35:30 <monochrom> That is also a good candidate!
12:36:51 <koz_> (although maybe it should be 'dequeue')
12:37:01 <koz_> (or is it 'deque'?)
12:37:37 <monochrom> If you take a thing out of the queue, it's dequeue.  If you have a double-ended queue, it is abbreviated deque.
12:37:48 <koz_> monochrom: Yeah, that sounds right.
12:37:51 <koz_> Thanks!
12:41:46 <monochrom> In Hong Kong, if you have an unelected, appointed, low rank clerk to make a biased, subjective, suck-up-to-the-communist-party decision to remove a democratically elected member of the legislature from the legislature, it is called Disqualify, abbreviated DQ.
12:43:09 <koz_> So we need a bot, which constructs [name-of-complexity-class]Complete and [name-of-linear-data-structure
12:43:10 <dmwit> And if Dairy Queen breaks the rules and is therefore banned from removing people from the line forming at their drivethrough, it's a DQ drivethrough deque dequeue DQ.
12:43:11 <koz_> ]
12:43:19 <koz_> dmwit: Rofl.
12:43:19 * monochrom has covered all cases of d.*q.* and is now dq-complete.
12:43:50 <tabaqui1> dq-grammar?
12:57:46 <sm[m]> maerwald: nix catalina success! https://github.com/NixOS/nix/issues/2925#issuecomment-604501661 made it straightforward
12:58:31 <maerwald> all seems to have non-trivial downsides
13:00:12 <sm[m]> heck, I'm happy I escaped without hot pincers
13:07:14 * hackage souffle-haskell 0.2.0 - Souffle Datalog bindings for Haskell  https://hackage.haskell.org/package/souffle-haskell-0.2.0 (luc_tielen)
13:13:14 * hackage fusion-plugin 0.2.1 - GHC plugin to make stream fusion more predictable.  https://hackage.haskell.org/package/fusion-plugin-0.2.1 (pranaysashank)
13:15:19 <johnw> is there a shorthand for concat $ fmap sequence $ xs?
13:15:49 <johnw> I'm turning [(a, [b])] into [(a, b)]
13:16:36 <merijn> concatMap sequence? :p
13:16:53 <johnw> thanks!
13:17:26 <johnw> i guess I really want concatTraverse
13:17:48 <johnw> or maybe not
13:17:50 <johnw> n/m
13:18:45 * hackage dobutokO2 0.35.1.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.35.1.0 (OleksandrZhabenko)
14:17:44 * hackage prim 0.1.0.4 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.4 (dailectic)
14:20:44 <hpc> that package could have been called prim-and-proper
14:22:57 <mniip> >(eventually), a comprehensive home for documentation on ghc magic.
14:23:02 <mniip> don't get your hopes up :P
14:33:45 * hackage prim 0.1.0.5 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.5 (dailectic)
14:51:45 * hackage dobutokO2 0.35.2.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.35.2.0 (OleksandrZhabenko)
14:53:15 * hackage di-polysemy 0.1.0.0 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.1.0.0 (nitros12)
14:59:13 <hseg> whatever happened to the 2015 "Implementing Version Comparison for Cabal Packages" gsoc by Craig Roche
14:59:14 <hseg> ?
15:06:46 * hackage wreq-patchable 1.0.0.0 - An easy-to-use HTTP client library.  https://hackage.haskell.org/package/wreq-patchable-1.0.0.0 (nitros12)
15:13:45 * hackage prim 0.1.0.6 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.6 (dailectic)
15:22:18 <maerwald> hseg: what does it do?
15:23:36 <hseg> basically, idea was to generate a toc for packages, which would permit automatic pvp version bumping calculations
15:23:45 <hseg> afaict from the hiw talk
15:24:09 <maerwald> @hackage policeman
15:24:09 <lambdabot> http://hackage.haskell.org/package/policeman
15:24:13 <maerwald> did you check that?
15:25:15 * hackage sak 0.1.2.4 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.2.4 (vmchale)
15:25:31 <hseg> nice. good enough to give the search up for
15:26:19 <maerwald> and maybe cabal-diff from https://github.com/phadej/cabal-extras
15:27:14 <hseg> ty
15:27:21 <hseg> will give it a look
15:36:14 * hackage calamity 0.1.0.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.0.0 (nitros12)
16:17:39 <aviD> bytestring Builder it is then
16:29:17 <xe4> I would like to rewrite genBars: https://gist.github.com/xe-4/bdaf5ea3f19de2c611e7c57d7b3a5484 Can someone help?
16:30:09 <xe4> I want to map doFoos over a [Foo] to produce a Bar
16:35:03 <xe4> sorry, I mean doFoo
16:35:28 <c_wraith> That looks like pseudocode that has lost some important details
16:36:04 <c_wraith> You *probably* want mapM, but I'm not sure because your code doesn't make sense as described
16:38:35 <c_wraith> maybe Bar is a type alias for like Something ()
16:38:48 <c_wraith> In which case, I guess you'd want mapM_
16:39:21 <c_wraith> But you get much better answers if your question code looks like it has the right kinds without guessing games
16:41:46 <monochrom> The question is very unclear.
16:42:18 <xe4> I'm sorry, I will try to clean it up and come back 
16:44:11 <zeta_0> i added some keybindings for switch work spaces in xmonad, but for some reason the | character is not working? https://dpaste.org/uaNO
16:44:33 <monochrom> I'm on the verge of writing a blog post to generally criticize the programmer habit of asking "high-level" open-ended questions when they already have actual code and a concrete task.
16:44:51 <c_wraith> zeta_0: you mean on like lines 21 and 22?
16:45:10 <aviD> `haskell
16:45:46 <zeta_0> c_wraith: yes
16:46:18 <c_wraith> what kind of keyboard are you using?  on a US keyboard, | is S-\
16:46:18 * aviD sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/GsEarUwKsoGQYraftBcXLRMX >
16:46:42 <c_wraith> or is S super?
16:47:17 <c_wraith> after looking at more of those bindings, my observation looks... wrong.
16:47:21 <zeta_0> c_wraith: S means shift in that context
16:47:54 <c_wraith> Oh, it does?  Well, are you sure you have a key that reports as |  ?
16:48:51 <zeta_0> i saw an example that when you want to add a single character like dbl quote you need to add a \ symbol right before it, but i'm not sure if | is done the same way?
16:49:02 <monochrom> aviD: I think it's OK.
16:49:27 <zeta_0> all the other keybindings work, i just need get the | character working
16:49:44 <c_wraith> zeta_0: seriously, what locale keyboard do you have?
16:50:24 <zeta_0> c_wraith: i have a custom keyboard layout, so i have characters in weird places
16:50:36 <aviD> I'm surprised I can't find version of this function in aeson.
16:50:51 <c_wraith> Do you have a | key that doesn't require shift to type?
16:51:13 <monochrom> Because generally JSON doesn't require anal newline formatting.
16:51:43 <monochrom> Perhaps s/anal/meticulous/
16:51:54 <c_wraith> In fact, JSON generally is formatted without newlines at all...
16:53:20 <zeta_0> i don't know, add ! as a keybinding works fine, i have no idea why | is not working?
16:53:48 <zeta_0> i was hoping someone here ran into this same issue
16:53:59 <c_wraith> I am a bit curious about (char8 '\n' <>) rather than (<> char8 '\n').  You want to prepend a newline to each entry, rather than append?
16:55:15 <c_wraith> zeta_0: eh, that's all on how xmonad parses those into x event sequences.  I really don't know whether there's something strange going on with parsing, with the event sequence for that keypress, or something in the combination
16:56:36 <zeta_0> c_wraith: ok, i'm going to ask this same question in #xmonad, not sure if that channel is dead though
16:57:16 <c_wraith> zeta_0: have you at least investigated with xev to see if there's anything weird about the input event sequence?
16:58:50 <zeta_0> c_wraith: i searched the internet for while and could not find a useful explanation
17:01:16 <c_wraith> zeta_0: xev tells me that with my keyboard, the \ key resolves to the "\" character view XLookupString and XmbLookupString.  S-\ resolves to "|" with XLookupString and XmbLookupString.  
17:01:38 <c_wraith> zeta_0: does xev tell you anything interesting?
17:03:10 <zeta_0> c_wraith: ok, i'll give that a try: https://dpaste.org/uXz6
17:03:34 <c_wraith> zeta_0: that's not going to do anything
17:03:35 <zeta_0> the \ is a different color than the String so i'm not sure if it will work
17:03:41 <c_wraith> > "\|"
17:03:43 <lambdabot>  <hint>:1:3: error:
17:03:43 <lambdabot>      lexical error in string/character literal at character '|'
17:04:05 <zeta_0> well, then i have no idea?
17:04:08 <c_wraith> zeta_0: backslash is the escape character in string literals
17:05:09 <zeta_0> c_wraith: so then what is the correct way to do this?
17:05:11 <monochrom> xev is an important tool for debugging and discovering these thing.
17:05:19 <zeta_0> i'm confused
17:05:21 <monochrom> things!
17:05:39 <c_wraith> Then ask a question to help clarify!  Perhaps you want to ask "what is xev?"
17:06:05 <c_wraith> Or maybe "how do I use xev?"
17:08:49 <zeta_0> i tried xev, but it returned too much stuff, i'm not sure what's going on
17:11:04 <monochrom> I approached xev as an unsupervised (no clue from a mentor) scientist: merely looking for correlations between what "noise" it makes and what I do.
17:11:25 <monochrom> within a minute or two I noticed patterns and the gist of it.
17:11:30 <c_wraith> xev is also a lot less noisy if you don't touch your mouse :)
17:12:37 <monochrom> It helps to keep in mind the name "xev" means "X events"
17:13:11 <MarcelineVQ> it's also a pretty cool name for your band's frontman
17:13:13 <zeta_0> ehh i give up, there's probably an explanation buried somewhere in the xmonad documentation, but i don't want to stay stuck looking for hours
17:13:26 <monochrom> Anyway after 5 minutes I confirmed all my hypotheses to 5 sigma.
17:17:28 <zeta_0> maybe something like this? https://dpaste.org/W52t
17:18:16 <monochrom> I don't think | needs escaping in Haskell string literals.
17:18:18 <monochrom> > "|"
17:18:21 <lambdabot>  "|"
17:18:23 <monochrom> > ">|"
17:18:25 <monochrom> err
17:18:25 <lambdabot>  ">|"
17:18:27 <monochrom> > "\|"
17:18:29 <lambdabot>  <hint>:1:3: error:
17:18:29 <lambdabot>      lexical error in string/character literal at character '|'
17:19:37 <zeta_0> monochrom: adding ! into the keybinding works fine, it's strange that | is not working:https://dpaste.org/ZiG0
17:24:19 <monochrom> It is possible that there is no | key, only shift-\
17:25:34 <zeta_0> i'm sure geekosaur could help, but he rarely ever gets on irc anymore
17:25:45 <Welkin> why not? D:
17:25:58 <Welkin> you scared him off
17:26:19 <Welkin> I rarely come on here anymore either, mostly because I am on slack all day for work
17:27:34 <zeta_0> no, once this corona virus epidemic hit, he hardly gets on anymore
17:33:24 <zeta_0> someone on #xmonad said to try: <KP_Separator> , what does that mean?
17:47:25 <remexre> hm, what's the fastest way to do Foldable t => (a -> b) -> t a -> Vector b ? It seems like this should be O(n), but if I fold over the foldable w/ vector cons, that's O(n*2); if I unfold + use nth on the foldable, that's still O(n*2)
17:47:46 <koz_> remexre: Via toList.
17:47:55 <koz_> Fusion should handle you.
17:48:09 <remexre> oh, huh; somehow that totally slipped my mind
17:48:17 <koz_> (key word here being _should_)
17:48:39 <remexre> it should still be O(n) even if it doesn't fuse, right?
17:48:46 <remexre> just a slower O(n)
17:48:47 <koz_> Yeah, just wasteful. :P
17:49:20 <koz_> I would be curious to see if it fuses.
17:49:20 <remexre> okay, thanks!
17:49:33 <dmj`> \f -> V.map f . V.fromList
17:50:32 <koz_> dmj`: ??
17:51:21 <jchia> Don't you just need 2 passes over the list? One to see how many items so that you know how big of a Vector to make first before you can fill the Vector in a second pass.
17:51:31 <koz_> jchia: Yes.
17:52:57 <remexre> jchia: though I think you always need two passes for Foldables in general
17:53:55 <jchia> remexre: You can avoid 2 passes if you can get the length immediately without going through the elements
17:54:18 <remexre> jchia: sure, but you can't do that for Foldables in general
17:54:19 <jchia> list doesn't allow that. IDK what does
17:55:40 <remexre> though it is a method on Foldable, so assuming there's a rule (length . fmap f = length), t = Vector should fuse to skip the pass?
17:55:55 <remexre> though, not sure if that's actually directly implied by the Foldable laws; the length law is phrased differentyl
17:56:51 <dmj`> what if you just constructed a Bundle directly
17:57:27 <solonarv> remexre: it isn't implied by the Foldable laws because Functor isn't a superclass of Foldable, so they can't
17:57:36 <solonarv> however it is implied by the Traversable laws
17:57:44 <remexre> ah
17:58:34 <remexre> dmj`: I'm still needing to do a (fromList . toList), no?
17:59:34 <solonarv> you can construct that rule by observing: length = foldMap (const (Sum 1)) = getConst . traverse (const (Const (Sum 1)))
18:00:19 <remexre> would that mean I get the optimized behavior for any Foldable that's also a Traversable, or would I need to strengthen the bound?
18:00:20 <solonarv> and fmap f = runIdentity . traverse (Identity . f)
18:00:30 <dmj`> remexre: ah, yea you would need the toList first. 
18:00:34 <solonarv> and applying the various traversable laws from there
18:00:55 <solonarv> V.fromList . toList is probably fun in practice
18:00:59 <solonarv> s/fun/fine/
18:01:23 <koz_> solonarv: Fun too.
18:01:33 <solonarv> or fromListN (length xs) (toList xs), perhaps
18:02:17 <Axman6> yeah I was going to say if there's a version which takes a size hint that would be good
18:03:17 <remexre> okay, I'll do that then
18:21:34 <zeta_0> ok the | symbol now works in the keybinding, it turns out that xmonad.hs was not recompiling do to a build error caused by something else
18:33:41 <sleblanc> always something else, causing xmonad.hs recompiling issuesâ€¦ tsk tsk
18:35:39 <Axman6> bloody something else
18:35:59 <koz_> Something else - the cause of all woes.
18:45:46 <MarcelineVQ> @beer gdgdf234
18:45:46 <lambdabot> 9D9Dph234
18:47:20 <dmwit> That's a very misleading command name you picked. Well done.
18:47:46 <MarcelineVQ> My one skill at work
18:58:21 <remexre> ugh, ormolu autoformats Vector.(!) to Vector . (!)
18:58:45 <remexre> er wait, that's 'cause it's (Vector.!), innit
19:07:08 <koz_> remexre: Yep, it is.
19:20:44 * hackage aur 7.0.0 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-7.0.0 (fosskers)
19:24:45 * hackage aura 2.3.0 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-2.3.0 (fosskers)
20:03:38 <remexre> [wrt fused-effects] ugh, why can't Exception e => Algebra (Throw e :+: Lift IO) IO
20:04:01 <remexre> I guess you'd want to push the forall in somewhat
20:18:03 <remexre> hm, even with a newtype around IO, this breaks the functional dependency:
20:18:05 <remexre> (Algebra sig m, Exception e, MonadIO m) => Algebra (Throw e :+: sig) (ExceptionC m)
20:18:11 <remexre> tbh never bothered to learn how those work
20:20:24 <glguy> help
20:20:31 <glguy> <_< this isn't a pico 8 terminal
20:20:48 <oats> lol
20:21:00 <MarcelineVQ> one day
20:21:10 <Axman6> HOW CAN WE BE OF ASSISTANCE GLGUY
20:21:47 <Axman6> also, I love that glirc highlights the caps version of your nick, nice work GLGUY
20:22:42 <glguy> ^_^
20:27:11 <justinba1010> Hi, I know it's very rude to put homework assignments and such here, but my university decided to "try out" teaching Compilers in a Functional Language. I leaped at the chance. I'm almost done, my only issue, is of course I/O, as I come from a Ocaml background and we can have side effects there. I've spent the entire day trying to figure out a good
20:27:12 <justinba1010> way to get around this.
20:27:16 <justinba1010> So I just have two questions, 
20:29:29 <justinba1010> 1. Why does `unsafePerformIO` not execute at all. I know it's impure, but I can't imagine GHCI invoking it, saying nothing yet, and skipping, especially for `putStr`, and 2. Does anyone have any references for how to retrofit a program, where I pass my normal monad, and am able to use IO functions? I've tried some reading, but cannot get my mind
20:29:30 <justinba1010> around Monad composition nor Monad transformations.
20:29:32 * Axman6 attempts to lazily evaluate the two questions...
20:29:48 <Axman6> justinba1010: if you're using unsafePerformIO you're doing it wrong
20:30:17 <justinba1010> I understand, I just gave it a shot, to see if I can just get by for now.
20:30:30 <Axman6> why do you believe yoiu need to perform IO in the middle of compilation?
20:30:40 <justinba1010> Just part of the assignment.
20:30:44 <justinba1010> Lol
20:30:54 <justinba1010> I wrote the entire thing, without this in mind.
20:31:50 <slack1256> The general idea is that you can *lift* pure values to an IO environment where you can actually print stuff. But you can't do that backwards.
20:32:59 <slack1256> So instead of having a function that computes and then print stuff, you take the value produced by your function, lift that up to and environment where you can do IO, and do you printing there.
20:33:18 <johnw> slack1256: this is a good plan :)
20:34:24 <justinba1010> Do you have any examples by any chance. I was thinking of passing an IO Monad down through all of my compilation phases, but that got sticky quickly. And very much appreciated!
20:34:51 <slack1256> justinba1010: Yeah, I could give you an example, give me a sec
20:34:59 <justinba1010> Thank you so much!
20:35:20 <justinba1010> I live mostly in the Ocaml world, but my school was trying out a Haskell Compilers course, and I had to jump at it.
20:36:43 <slack1256> Mmmm they waited to the last class to explain that you can't have arbitrary side-effects?
20:37:08 <justinba1010> I didn't know we had to do I/O lol.
20:37:31 <johnw> I would suggest that another take-away isn't about IO and side-effects, but a distinction between syntax and semantics.
20:38:22 <Axman6> johnw: do you need to do anything more than reading a file, compiling it and printing r writing the output to disk?
20:38:45 <Axman6> uh, justinba1010
20:38:51 <johnw> phew
20:38:57 <johnw> I was struggling to understand the humor...
20:39:43 <Axman6> because something as simepla as: main = do { (fileName:_) <- getArgs; fileContent <- readFile fileNAme; let result = compile fileContent; print result} might be enough
20:39:48 <justinba1010> Sorry, I've been up for a while.
20:39:57 <justinba1010> I've got the compiler finished.
20:40:05 <justinba1010> The interpretter, is where I'm at
20:40:25 <justinba1010> Sorry I've been pulling no sleep since I realized we had to write an interpretter.
20:40:48 <Axman6> what's the type of the top level function in your compiler? is it something like String -> String? String -> CompiledProgram?
20:41:06 <slack1256> justinba1010: https://pastebin.com/Z2rCWgHE
20:41:17 <Axman6> justinba1010: quit making excuses and give us answers :P
20:41:37 <justinba1010> One second lol
20:42:25 <justinba1010> Technically I have a few functions
20:42:45 <johnw> "A Fist Full of Functions"
20:43:02 <justinba1010> main is `IO b`
20:43:35 <justinba1010> But I use a few `do` blocks to get to `pProgram` which is the AST
20:44:07 <Axman6> what is the type of pProgram
20:44:31 <justinba1010> I wrap that in a monad `Env`, and pass that around each step of interpretation, and compilation(but the compilation just has a different structure, where I have a stack of low level code)
20:45:03 <slack1256> I have to go, sorry mate.
20:45:10 <Axman6> I'll say it again: what is the type of pProgram?
20:45:21 <Axman6> HAskell, not english
20:46:03 <justinba1010> ```data Program = PDefs [Def]  deriving (Eq, Ord, Show, Read)```
20:46:17 <Axman6> that's not the type of pProgram
20:46:23 <Axman6> pProgram :: ???
20:46:30 <justinba1010> Typo
20:46:45 <Axman6> uh, ok, what is the type of the function which returns a Program
20:47:18 <justinba1010> `[Token] -> Err Program`
20:47:20 <Axman6> I assume you have something which takes in a String and returns something? possible a Program or an Either String Program?
20:47:26 <Axman6> what is Err?
20:47:43 <justinba1010> A monad the book gives us
20:48:00 <Axman6> is it data Erro a = Error String | Ok a (roughly?
20:48:06 <justinba1010> Exactly
20:48:31 <justinba1010> Sorry, I'm completely sleep deprived
20:48:46 <justinba1010> I had no idea we were supposed to even work on an interpretter.
20:49:01 <Axman6> ok. and where do you get a [Token] from? what function returns that?
20:49:22 <justinba1010> `lexer :: String -> [Token]`
20:49:33 <justinba1010> I lift the string out when I read the file
20:50:07 <justinba1010> ```main = do  args <- getArgs  if (length args > 0) then do    s <- readFile $ args !! 0``` work with s after
20:50:49 <slack1256> I came back from the (infinite recursion) death.
20:51:45 * hackage stylist 2.0.0.0 - Apply CSS styles to a document tree.  https://hackage.haskell.org/package/stylist-2.0.0.0 (alcinnz)
20:51:48 <justinba1010> What I understand, is it's probably best to pass the IO Monad down, such as, https://mmhaskell.com/blog/2017/3/6/making-sense-of-multiple-monads, 
20:51:59 <Axman6> justinba1010: does the interpreter need to do anything other than take in a string and produce the program? I assume it doesn't need to hold onto any state like previous definitons or something?
20:52:12 <justinba1010> It does, it's a C interpretter.
20:52:30 <Axman6> I don't think you need to do anything that compicated unless you need to hold onto some state
20:52:37 <oats> https://byorgey.wordpress.com/2018/05/06/conversations-with-a-six-year-old-on-functional-programming/
20:52:40 <justinba1010> Yes, I'
20:52:41 * glguy clutches his state
20:52:42 <oats> well this is super freakin cute
20:53:02 <justinba1010> 've been holding onto function signatures, and local/global variables.
20:53:29 <Axman6> ok. you said you've got an Env monad or something somewhere?
20:54:25 <justinba1010> Yes, ```type Env = (FunctionTable, [Context])type FunctionTable = Map.Map Id (Type, [Arg], [Stm])type Context = Map.Map Id Value```
20:54:42 <justinba1010> The Arg, Stm, are all part of the Tree structure
20:54:59 <justinba1010> And is quite long, so I don't want to spam the chat, as I am doing anyway
20:56:24 <justinba1010> I'm wondering, it's probably best that I pass something like, `IO (Err Env)`, which I'm assuming is the Haskell-esque way to do so.
20:57:22 <Axman6> orget IO
20:57:25 <Axman6> forget*
20:58:00 <Axman6> write a function that can take an Env and a String and give you back a (Program, Env) where the Env is the updated environment  from pasring the string
20:58:28 <Axman6> interpret :: Env -> String -> Err (Program, Env)
20:59:29 <justinba1010> With the evaluations on the environment?
21:00:20 <Axman6> yes
21:01:02 <justinba1010> The only issue is, when there's a `int x = readInt(); x++; return x;`
21:01:40 <justinba1010> What should my environment be there?
21:03:07 <Axman6> initially it will be the empty environment, but when you interpret new code you'll use the upodated Env with each new input
21:03:21 <Axman6> but one step at a time, can you write that function?
21:03:41 <justinba1010> I see
21:03:58 <justinba1010> Not ideally with my current set up.
21:06:15 <Axman6> you said you have a function of type [Token] -> Err Program - can you make a version of that which as type Env -> [Token] -> Err (Program, Env), and then rewrite the function which has type [Token] -> Err Program to call this new function, pass in an empty environment and ignore the resulting Env?
21:10:30 <justinba1010> ```interpret :: Env -> [Token] -> Err (Program, Env)interpret env tokens =  case pProgram tokens of    Ok program -> Ok (program, emptyEnv)    Bad error -> Bad error ```
21:10:37 <justinba1010> Like this?
21:12:36 <Axman6> well, that matches the type I asked for but isn't useful. pProgram will also need to return the Env that exists once it has finished processing the tokens. I assume that pProgram passes in an emptyEnv to some other function, which passes around that Env and updates it as it parses things?
21:13:13 <justinba1010> `pProgram` is just the parser.
21:13:30 <justinba1010> I actually did not write the parser.
21:13:33 <justinba1010> Just the grammar.
21:13:59 <justinba1010> Or the lexer for that matter.
21:14:55 <Axman6> ok... how is Env used
21:15:22 <Axman6> where do you get an Env from, where do you use emptyEnv in your program
21:16:29 <justinba1010> In the interpretter part, I start with an empty `Env` which is just keeping track of function signatures, local, and global variables, and as I go through the tree, I update the `Env`.
21:17:17 <justinba1010> Originally it was a compiler part, but then I was told an interpretter is due tomorrow, and started the interpretter a few days ago. It works well, but no I/O at all.
21:19:12 <Axman6> right, I understand that
21:33:10 <justinba1010> No worries, I'm gonna give a few people some calls, because I think there's definitely a better way to do this. But I 100% appreciate the help Axman6, Hopefully this summer I'll be a true Haskeller.
22:05:15 * hackage friendly 0.1.0.1 - Attempt to pretty-print any input  https://hackage.haskell.org/package/friendly-0.1.0.1 (EdskoDeVries)
23:19:32 <dibblego> does this function exist? f EQ = EQ; f LT = GT; f GT = LT
23:21:02 <DocKlobi> haskell 
23:22:46 <siraben> dibblego: Yes it does, you just defined it!
23:22:57 <dibblego> yeah, but you know, does it already have a name?
23:23:15 <siraben> > pred EQ
23:23:17 <lambdabot>  LT
23:23:24 <siraben> Hm, what does f do semantically? Seems quite specific.
23:23:36 <dibblego> mirrors around EQ
23:23:53 <iqubic> Well depending on what you are doing with the Ord, you can get away with using the Down newtype wrapper.
23:24:25 <iqubic> If you are using this for sorting, then the Down newtype wrapper will do the mirroring for you.
23:25:07 <dibblego> ok yeah cheers
23:28:30 <iqubic> Since I don't know what you're planning on doing, I'm just suggesting a general purpose solution.
23:32:02 <Axman6> :t compare `on` Down
23:32:04 <lambdabot> Ord a => a -> a -> Ordering
23:32:15 <Axman6> > compare `on` Down $ LT
23:32:17 <lambdabot>  error:
23:32:17 <lambdabot>      Precedence parsing error
23:32:17 <lambdabot>          cannot mix â€˜onâ€™ [infixl 0] and â€˜$â€™ [infixr 0] in the same infix expr...
23:32:24 <Axman6> > (compare `on` Down) LT
23:32:26 <lambdabot>  <Ordering -> Ordering>
23:32:37 <Axman6> > (compare `on` Down) LT GT
23:32:39 <lambdabot>  GT
23:32:51 <iqubic> compare LT GT
23:33:01 <iqubic> > compare LT GT
23:33:04 <lambdabot>  LT
23:33:10 <dibblego> comparing = \x -> compare `on` x
23:33:23 <iqubic> Yeah. That's correct.
23:33:24 <Axman6> yeah, so comparing Down
23:34:22 <Axman6> > map (comparing Down EQ) [LT,EQ,GT]
23:34:24 <lambdabot>  [LT,EQ,GT]
23:34:51 <Axman6> > map (flip compare EQ) [LT,EQ,GT]
23:34:53 <lambdabot>  [LT,EQ,GT]
23:34:58 <Axman6> I'm bad at this
23:37:36 <iqubic> Axman6: What are you trying to do?
23:38:12 <dibblego> > (`compare` (Down EQ)) . Down <$> [LT, EQ, GT] -- prolly this
23:38:14 <lambdabot>  [GT,EQ,LT]
23:38:34 <iqubic> Yeah. I guess.
23:42:59 <dsal> Tonight's quick hack:  https://gist.github.com/dustin/19b2139fce384f0e86b710b544681635  -- Shoving text into xmobar from MQTT messages.  I think I need to make this a lot fancier to be useful, but in the meantime, I've got it updating covid19 cases as numbers update with a simple text template.
23:44:01 <dsal> Though there's a thing I don't like in that parser... How do I parse everything up to "{{" easily?  I found gross ways to do that, but I figured I'd just not put a { in my template in the meantime...
23:49:27 <tdammers> welcome to 2020, people feel a need for a death toll counter in their status bars
23:51:32 <koz_> Truly the best decade.
23:53:15 * hackage xml-conduit-stylist 1.2.0.0 - Bridge between xml-conduit/html-conduit and stylist  https://hackage.haskell.org/package/xml-conduit-stylist-1.2.0.0 (alcinnz)
23:53:22 <tdammers> We have the best decade in the world. It's true.
23:56:53 <koz_> Very fine decade.
23:58:40 <dsal> My original goal was network status, but I don't think that part's ready on the other end. Almost is. I've got some LEDs lighting up to tell me when I'm dropping packets.
23:59:25 <dsal> Actually, I think I need more template language features for that... I'll have to think about how that will work.
