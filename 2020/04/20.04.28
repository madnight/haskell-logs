00:04:14 * hackage prim 0.1.0.9 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.9 (dailectic)
00:23:11 <sid`> Hi! I had a question regarding GHC.TypeLits.Nat numbers, sorry if it's a noob question I'm a bit new to type level programming
00:24:09 <sid`> I'm trying to write a function to append a list of Vectors, so for example append :: [Vector (a :: Nat)] -> Vector (b :: Nat)
00:25:06 <sid`> In this case I want b to be the sum of all of the a's in the list, say if I called append [Vec 3 [..], Vec 2 [..] Vec 1 [..]] I should get a Vec 6
00:25:16 <sid`> Does anyone know how I could do this? Thanks a lot!
00:26:15 * hackage microbase 4.14.0.0.6 - A minimal base to work around GHC bugs.  https://hackage.haskell.org/package/microbase-4.14.0.0.6 (dailectic)
00:29:35 <Axman6> sid`: I doubt it can be done with the standard list type, since those vectore have different types, so creating the list in the first place isn't going to work
00:31:16 <Axman6> if you need to do that you probably need to use something like a HList to contain all the vectors, and then do some type level stuff to say that given (ExtractAndAddAllLengths tys ~ n, AllAreVectors tys) => HList tys -> Vector n a
00:33:33 <Axman6> where HList is somewthing like data HList (xs :: [Type]) where HNil :: HList '[]; HCons :: a -> HList xs -> HList (a ': xs) (of which there are plenty of implementations aroundf the place, with HList being the first I believe)
00:35:32 <Axman6> and ExtractAndAddAllLengths is something like: type family ExtractAndAddAllLengths (xs :: [Type]) :: Nat where ExtractAndAddAllLengths '[] = 0; ExtractAndAddAllLengths (Vector n a ': xs) = n + ExtractAndAddAllLengths xs
00:36:06 <Axman6> probably needs something to ensure all the vectore contain the same type too
00:36:36 <sid`> Thank you Axman6! I'll look into it
01:14:23 <jluttine> why hoogle doesn't give any results (e.g., distribute) for a search: "f (g a) -> g (f a)"
01:16:09 <jluttine> nor with this one: "f (g a) -> g (f a) -is:exact"
01:57:14 * hackage rio 0.1.15.1 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.15.1 (MichaelSnoyman)
02:25:45 * hackage odd-jobs 0.1.0 - A full-featured PostgreSQL-backed job queue (with an admin UI)  https://hackage.haskell.org/package/odd-jobs-0.1.0 (saurabhnanda)
03:32:15 * hackage simple-affine-space 0.1.1 - A simple library for affine and vector spaces.  https://hackage.haskell.org/package/simple-affine-space-0.1.1 (IvanPerez)
04:11:44 * hackage data-category 0.8.2 - Category theory  https://hackage.haskell.org/package/data-category-0.8.2 (SjoerdVisscher)
04:15:44 * hackage mu-graphql 0.3.0.0 - GraphQL support for Mu  https://hackage.haskell.org/package/mu-graphql-0.3.0.0 (FlavioCorpa)
04:20:45 * hackage mu-avro 0.3.0.0 - Avro serialization support for Mu microservices  https://hackage.haskell.org/package/mu-avro-0.3.0.0 (FlavioCorpa)
04:35:38 <ski> dsal : hm, use `@tell' ?
04:44:45 * hackage mu-protobuf 0.3.0.0 - Protocol Buffers serialization and gRPC schema import for Mu microservices  https://hackage.haskell.org/package/mu-protobuf-0.3.0.0 (FlavioCorpa)
04:55:15 * hackage mu-schema 0.3.0.0 - Format-independent schemas for serialization  https://hackage.haskell.org/package/mu-schema-0.3.0.0 (FlavioCorpa)
04:57:14 * hackage mu-rpc 0.3.0.0 - Protocol-independent declaration of services and servers.  https://hackage.haskell.org/package/mu-rpc-0.3.0.0 (FlavioCorpa)
04:58:15 * hackage mu-optics 0.3.0.0 - Optics for @mu-schema@ terms  https://hackage.haskell.org/package/mu-optics-0.3.0.0 (FlavioCorpa)
05:00:45 * hackage mu-persistent 0.3.0.0 - Utilities for interoperation between Mu and Persistent  https://hackage.haskell.org/package/mu-persistent-0.3.0.0 (FlavioCorpa)
05:03:45 * hackage mu-kafka 0.3.0.0 - Utilities for interoperation between Mu and Kafka  https://hackage.haskell.org/package/mu-kafka-0.3.0.0 (FlavioCorpa)
05:06:37 <timCF> Hello! Any Katip (logger) users here? I tried to add logging to my tests like this https://github.com/coingaming/lnd-client/blob/0a0d5f44548812aa73bd71fd60d24ad6ae890414/test/LndClient/RPCSpec.hs#L189-L200 
05:07:02 <timCF> But it's not working for some reason, I can see only Hspec output about tests themselves
05:09:14 * hackage mu-grpc-common 0.3.0.0 - gRPC for Mu, common modules for client and server  https://hackage.haskell.org/package/mu-grpc-common-0.3.0.0 (FlavioCorpa)
05:10:45 * hackage mu-grpc-client 0.3.0.0 - gRPC clients from Mu definitions  https://hackage.haskell.org/package/mu-grpc-client-0.3.0.0 (FlavioCorpa)
05:11:44 * hackage mu-grpc-server 0.3.0.0 - gRPC servers for Mu definitions  https://hackage.haskell.org/package/mu-grpc-server-0.3.0.0 (FlavioCorpa)
05:50:28 <nh2> What is the equivalent to `stack path` in cabal-v3? I cannot figure out how to get cabal to print me the relevant path component to `dist-newstyle/build/x86_64-linux/ghcjs-8.6.0.1/myproject-0.1.0.0/x/myproject/build/myproject/myproject.jsexe/all.js`
05:50:47 <phadej> there isn't.
05:51:01 <phadej> cabal-plan list-bin is the best we have atm
05:51:13 <phadej> (list-bin hopefully will be in cabal-install-3.4)
05:53:36 <nh2> phadej: thanks; `v1-build` should continue to work as before though, right?
05:54:26 <phadej> there you have to "hardcode" path too, don't you?
05:54:51 <phadej> but v1-build is not going yet anywhere. Sandboxes are though.
06:07:42 <nh2> phadej: That's fine for my use case in my ghcjs nix build. What I don't want to hardcode is the ghcjs version in the pat, so `v1-build` does it
06:20:44 * hackage schemas 0.4.0.2 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.4.0.2 (PepeIborra)
06:22:19 <sm[m]> jchia: you can recompile that code I assume ? then maybe https://www.stackage.org/haddock/nightly-2020-04-28/base-4.13.0.0/Debug-Trace.html#v:traceStack
06:23:26 <sm[m]> however I thought in recent GHCs you can get a stack trace without -prof.. try https://www.stackage.org/haddock/lts-15.10/base-4.13.0.0/Prelude.html#v:error as well
06:24:49 <disconsis> Hey people
06:25:06 <disconsis> I'm trying to write a function of the type `Monad m => (a -> m b) -> m (a -> b)`
06:25:15 <sm[m]> & to save confusion: there are about three different flavours of stack trace that GHC programs can produce in different circumstances
06:25:23 <disconsis> Seems to me like this should be possible, but I can't figure out how
06:28:32 <remexre> oh, got a new error from ghcide this morning: "ModBreaks.modBreaks_array not initialised" from compiler/ghci/ByteCodeTypes.hd:173:24 in ghc:ByteCodeTypes
06:31:43 <ski> disconsis : not possible
06:33:32 <disconsis> ski: really? Could it be possible with some additional constraints on `m`?
06:33:50 <remexre> with Comonad m, Monad m it's just foo f = pure (extract . f)
06:35:19 <disconsis> hmm, never came across Comonad before. Lemme look at that
06:35:30 <disconsis> :i Comonad
06:35:45 <remexre> and I suppose that weakens to Copointed m, Applicative m (tho copointed may be considered harmful?)
06:35:45 <ski> probably not what you want
06:36:30 <remexre> many useful monads are at least Copointed /shrug
06:36:30 <ski> hm, i guess if `m' is representable, it's possible ?
06:37:43 <remexre> where "many" may be 2, now that I put my glasses on
06:37:51 <ski> perhaps disconsis wanted a retraction of `strength :: Functor f => f (a -> b) -> (a -> f b)'
06:39:41 <disconsis> ski: what do you mean by "representable"?
06:42:39 <disconsis> remexre: the `m` I have in mind is definitely not a comonad
06:43:15 <disconsis> hmm.. I'm not really getting an intuition of why this is not possible
06:43:53 <ski> disconsis :  <https://hackage.haskell.org/package/representable-functors-2.1/docs/Data-Functor-Representable.html>
06:44:30 <hyperisco> (a -> m b) -> m (a -> m b)  by pure
06:44:31 <ski> disconsis : in `a -> m b', the resulting action may depend on the input of type `a'. in `m (a -> b)', it can't depend on that
06:45:19 <ski> consider e.g. `putStrLn :: String -> IO ()' .. how are you going to get this to `IO (String -> ())' ?
06:46:00 <disconsis> >  in `a -> m b', the resulting action may depend on the input of type `a'. in `m (a -> b)', it can't depend on that
06:46:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘in’
06:46:12 <ski> or, take `listToMaybe :: [a] -> Maybe a', how could `Maybe ([a] -> a)' work ?
06:46:47 <disconsis> hmm.. the putStrLn example makes sense to me
06:47:05 <hyperisco> and past  m (a -> m b)  there doesn't seem to be a way to get closer… bind just gets you back to  a -> m b
06:47:07 <ski> it can't decide whether to be a `Nothing' or a `Just', before it's got to see the list, to check whether it's empty or not
06:47:40 <hyperisco> you can contravariantly map  a  in  a -> m b  but it is already where it needs to be
06:47:57 <hyperisco> you can covariantly map  m b  in  a -> m b  but there is no  m b -> b
06:48:03 <ski> in the `putStrLn' case, you can't have it do I/O (print a `String'), before it's gotten to see the `String' to print
06:49:46 <hyperisco> if you had an  x :: a  then you could make it work, but then that is hardly exciting
06:50:35 <hyperisco> I'm giving an argument that is based on what tools we have available to rewrite the type
06:50:51 <ski> at one point, `flip :: Functor f => f (a -> b) -> (a -> f b)' was in lambdabot
06:51:15 <ski> (also `(.) :: Functor f => (a -> b) -> (f a -> f b)')
06:51:35 <disconsis> ah well that sucks
06:51:39 <disconsis> back to the drawing board then
06:51:51 <disconsis> thanks for the help :)
06:53:09 <disconsis> Ok I thought about it a little bit more - let `a -> b = t b`
06:53:34 <disconsis> then `(a -> m b) -> m (a -> b)` is `t (m b) -> m (t b)`
06:54:03 <disconsis> which looks like a monad transformer to me if I squint hard enough
06:54:28 <hyperisco> that's sequence
06:54:40 <disconsis> :t sequence
06:54:42 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
06:55:04 <disconsis> Well `t` is a monad here instead of a traversable
06:55:21 <hyperisco> Traversables are Foldable Functors
06:56:23 <hyperisco> See if you can find a connection through Functor
06:56:36 <ski> hm, `a' need to be finite for `t' to be `Traversable', yes ?
06:56:53 <ski> hmm
06:56:58 <hyperisco> Why?
06:57:08 <disconsis> `m` is basically IO for my purposes, so I think that's out of the question
06:59:28 <ski> i guess it can still make sense, for "non-strict" monads
07:00:25 <ski> consider `Stream (m a) -> m (Stream a)', for `Stream' a type of infinite streams
07:01:15 * hackage twitter-conduit 0.5.0 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.5.0 (TakahiroHimura)
07:01:25 <aveltras> I'd like to have some kind of "request environment" for a servant server, which would be the base environment provided when starting the server + request specific environement like session handle. Any idea how i can implement the "transform" function here to go from a "RIO Env a" context to a "RIO Ctx a" for all my handlers ?
07:01:31 <aveltras> https://www.irccloud.com/pastebin/wRWVNOxf/
07:02:03 * olavx200 uploaded an image: image.png (94KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/AvtbaZJpKSSyxJyhaeZekzmb >
07:02:17 <olavx200> I'm having a problem with installation
07:05:34 <aveltras> olavx200: seems the ghc ppa is not yet up to date with the latest ubuntu release
07:06:14 * hackage dirtree 0.1.2 - A small library for working with directories.  https://hackage.haskell.org/package/dirtree-0.1.2 (kalhauge)
07:06:40 <olavx200> > fossegrim: seems the ghc ppa is not yet up to date with the latest ubuntu release
07:06:40 <olavx200> Alright. How can I get it working though?
07:06:43 <lambdabot>  error: Variable not in scope: fossegrimerror:
07:06:43 <lambdabot>      Variable not in scope:
07:06:43 <lambdabot>        seems
07:08:46 <aveltras> olavx200: you may try something like this https://askubuntu.com/questions/293203/how-can-i-add-a-ppa-from-a-previous-release, not sure that's a good idea though
07:10:30 <justsomeguy> olavx200: One way is to install GHC with stack, instead. https://docs.haskellstack.org/en/stable/README/
07:11:27 <olavx200> justsomeguy: I will try that.
07:12:05 <ja> olavx200: i switched from hvr's ppa to ghcup, works great!
07:12:30 <ja> olavx200: ghcup does install cabal too, if you were doubting
07:14:54 <olavx200> Thanks I will try that
07:17:29 <sm[m]> G'day all... here are the haskell projects with >10k github stars: https://github.com/search?o=desc&q=language%3AHaskell+stars%3A%3E=10000&ref=searchresults&s=stars&type=Repositories . 
07:17:51 <sm[m]> https://github.com/hasura/graphql-engine has 16.3k but is not included - any idea why ? Is it because it has more javascript than haskell ?
07:18:14 * hackage haskoin-store 0.23.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.1 (jprupp)
07:20:09 <compro> Hi there
07:20:14 <sm[m]> I guess so
07:20:21 <compro> I am trying to do the following:
07:20:23 <compro> convertToFloat :: Token -> Token
07:20:23 <compro> convertToFloat token =
07:20:23 <compro>   case token of
07:20:23 <compro>     TokenInteger value -> TokenFloat (value :: Double)
07:20:26 <compro>     TokenFloat value -> token
07:20:29 <compro>     TokenIdentifier _ -> error "Not implemented yet"
07:20:33 <compro>     _ -> error ("Unable to convert '" ++ show token ++ "' to float.")
07:20:38 <compro>  
07:20:59 <compro> I am actually trying to typecast from integer to double
07:21:06 <compro> Its throwing error
07:21:37 <c_wraith> that's because Haskell doesn't have type casting
07:21:57 <c_wraith> that syntax means "this value *is* a Double"
07:22:06 <c_wraith> which is obviously false, so you get an error.
07:22:07 <ja> but it does have fromInteger.toInteger ;)
07:22:21 <ja> and coerce
07:22:41 <c_wraith> fromInteger is most likely what's desired here
07:22:45 * hackage dirtree 0.1.3 - A small library for working with directories.  https://hackage.haskell.org/package/dirtree-0.1.3 (kalhauge)
07:27:06 <pie_[bnc]> excuse me what  xDhttps://journal.infinitenegativeutility.com/haskell-type-equality-constraints#fn:1
07:33:41 <infandum> Is there a way to derive an instance for a newtype without the missing-methods warning (without turning off the warning)?
07:34:10 <compro> ja, That worked. Thanks.
07:34:29 <infandum> Like, newtype Dollar = Dollar Int deriving (Eq, Ord, Num), but without the missing +, *, etc. warning?
07:34:52 <infandum> No explicit implementation warning
07:37:49 <lyxia> infandum: have you enabled GeneralizedNewtypeDeriving
07:38:49 <infandum> lyxia: I remember removing it because it conflicting with another one
07:39:00 <infandum> DeriveAnyClass or DeriveGeneric
07:39:01 <infandum> one of those
07:39:41 <lyxia> yes it conflicts with DeriveAnyClass, but if you use both the solution is DerivingStrategies to annotate deriving clauses explicitly.
07:41:33 <infandum> lyxia: I see, thank you!
07:50:40 <pie_[bnc]> I'm confused why people dont usually use equality constraints instead of making variables in a type the same, if it makes type inference better
07:59:00 <Cale> pie_[bnc]: One case where you might want this is in instance declarations
07:59:18 <Cale> pie_[bnc]: Constraints are always ignored for the purpose of selecting instances
08:00:07 <Cale> pie_[bnc]: So, by moving parts of the type over into type equality constraints, the compiler will more easily select the instance, and only afterward discover that the type equalities have to hold
08:00:21 <Cale> which can help with inference in some cases
08:00:48 <Cale> It's not a good thing to do generally, but every once in a blue moon, it's a nice trick to have.
08:01:22 <pie_[bnc]> i think thats what this article is explaining
08:01:32 <pie_[bnc]> errr
08:01:44 <pie_[bnc]> this article https://journal.infinitenegativeutility.com/haskell-type-equality-constraints
08:02:10 <pie_[bnc]> well thats what im wondering about, 1) how am i going to know ahead of time if i need the instance selection one, 2) why not just do this generally
08:02:20 <pie_[bnc]> at least i think thats my question
08:02:39 <Cale> Well, why not just do this generally is that it will make the instances apply too often
08:02:53 <Cale> If the instance matches, and then the type equality constraint doesn't hold, you just get an error
08:03:37 <Cale> In the example provided, an instance for C a b would match anything at all, and so that has to be the only instance in existence
08:04:24 <Cale> Mildly less contrived example -- https://hackage.haskell.org/package/category-printf-0.1.1.0/docs/src/Control-Category-Printf.html#instance%20IsString%20(Cokleisli%20((-%3E)%20s)%20a%20b)
08:04:37 <Cale> (this whole package is a contrivance, and is half-joking though)
08:06:00 <Cale> But this instance of IsString here will apply in *any* case where we need a Cokleisli ((->) s) a b, and only after it matches will we learn that a and b actually have to be the same
08:06:43 <infandum> lyxia: What about something like "instance Generic Double"? Is it possible to avoid the missing-methods warning for that?
08:07:25 <Cale> This is some fancy bullshit that probably should never go into production, but the gist of it is that we're using Cokleisli ((->) s) a b as the type of printf formatters which will "change the type of the printf from a to b"
08:07:48 <Cale> and plain bits of strings won't change the type of the printf
08:08:43 <Cale> but if we wrote the instance for Cokleisli ((->) s) a a, then the IsString instance would only *apply* in cases where we already knew that the thing wouldn't change the type
08:09:08 <Cale> and you'd get annoying type errors saying that it couldn't find an IsString instance at all
08:10:14 <Cale> This is one of very few times I've ever run into a need for this trick in a couple decades of programming in Haskell
08:11:29 <Profpatsch> Is (forall a. a) -> b the same as forall a. a -> b?
08:11:35 <Cale> no
08:11:41 <Profpatsch> Okay, good.
08:11:47 <Cale> The former is a function which demands its argument be polymorphic
08:12:06 <Cale> i.e. that function gets to choose the type, not whoever is using the function
08:13:12 <ski> `(exists a. ..a..) -> ...' is the same as `forall a. (..a.. -> ...)', though
08:13:12 <Cale> You can think of the "forall a." as being like an additional function parameter which is invisible and where you'd provide the type that a gets specialised to
08:13:59 <Cale> So it's like  ((a :: Type) -> a) -> b  vs.  (a :: Type) -> (a -> b)
08:14:47 <Cale> (you can't actually write either of those)
08:15:10 <Profpatsch> pie_[bnc]: ^
08:16:07 <pie_[bnc]> uhuh
08:25:53 <pie_[bnc]> apparently gadts are syntactic sugar over type equalities
08:27:06 <lyxia> infandum: note that the warning really means that you are getting the wrong instance.
08:28:02 <tomjaguarpaw> Does Data.Set.Set have a mapMaybe equivalent?  (Hoogle suggests not https://www.stackage.org/lts-13.8/hoogle?q=%28a+-%3E+Maybe+b%29+-%3E+Set+a+-%3E+Set+b)
08:28:25 <Cale> pie_[bnc]: Yeah, whenever you have a constructor with a type like ... -> Foo A, you can replace it with one whose type is like  (a ~ A) => ... -> Foo a
08:28:36 <lyxia> infandum: enable DeriveGeneric and the corresponding strategy is "stock" (i.e., it's built into GHC, ad-hoc for this class (and a fixed number of others))
08:28:54 <peutri> tomjaguarpaw: I suppose because then it would need to define which Just is kept in case of collision
08:36:35 <infandum> lyxia: I have the newtype instances working fine, it's for other instances with Generic for types that already exist in other packages.
08:37:46 <infandum> Oh I see, it's working
08:37:50 <infandum> thanks!
08:40:45 * hackage haskoin-store 0.23.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.2 (jprupp)
08:40:50 <lyxia> infandum: are you using newtype deriving for Generic? (because that sounds like the wrong thing to do if you got there by "how do I disable this warning" rather than knowing upfront that's what you want)
08:41:38 <infandum> lyxia: I do both
08:41:55 <infandum> Generic for newtypes I write, and instance Generic for ones I don't (like Double)
08:42:50 <infandum> Although it's not working for Generic (Vector a), because Vector's constructors aren't all in scope (even though I imported with Vector (..)
08:43:25 <lyxia> Vector being Generic is extremely wrong though, it just doesn't make sense.
08:44:27 <lyxia> also Double
08:45:10 <infandum> I needed it for a NFData instance
08:45:58 <lyxia> I doubt you really do. That's entirely an XY problem.
08:46:56 <infandum> But If I have a type `X a` which I want to force, don't I need NFData for both X and a?
08:47:04 <infandum> that is, a and X a
08:48:40 <n_> hi
08:49:00 <lyxia> infandum: If you have newtype X a = MkX (F a) then you need an instance of NFData for (F a) and an instance of Generic for (X a), and "instance of Generic" always means "instance of Generic derived with the 'stock' strategy"
08:50:14 <lyxia> infandum:  there are already NFData instances for Double and Vector
08:51:14 <lyxia> and for newtypes you don't even need the Generic instance.   newtype X a = MkX (F a) deriving newtype NFData
08:51:54 <infandum> lyxia: The newtypes I defined are fine, the issue now is from other dependencies
08:52:42 <n_> \SET nick = nick
08:52:51 <infandum> Oh yeah, you're right, I don't need generic for NFData, I wonder why I originally did that. Might have been legacy
08:53:56 <lyxia> it looks like you're switching extensions on and off without understanding what they do.
08:54:31 <infandum> lyxia: Most likely
08:54:40 <lyxia> When you didn't have GeneralizedNewtypeDeriving but only DeriveAnyClass, you're going to get the strategy that asks for Generic.
08:54:51 <infandum> More like a misunderstanding of the intracacies
08:55:13 <infandum> ah
08:56:16 <lyxia> How can you get any confidence in your code if you're deriving functionality without knowing what you're getting?
08:58:20 <infandum> lyxia: The force isn't exactly necessary, so it's not that important of a base
09:01:10 <n_> ls
09:02:22 <kamek> I'm thinking of introducing Haskell at some point in my company (~5 dev startup), would it make sense to use something like protolude as a team of newbies ?
09:02:44 <kamek> trying to avoid some common pitfalls
09:03:56 <fabianhjr> If you are already onboard microservices or a message queue I would skip that and focus on nice monadic implementations.
09:04:23 <fabianhjr> I haven't done MQ stuff but at least persistent is love <3
09:04:39 <Uniaika> kamek: I think a nice lightweight prelude that makes you avoid some pitfalls is relude
09:04:42 <Cale> kamek: I would normally avoid custom preludes.
09:04:50 <Uniaika> but don't go with something like RIO
09:04:50 <fabianhjr> Using constraints to only have SQL actions in scope and creating tests that use sqlite-mem
09:06:40 <dsal> kamek: what kinds of things are you wanting to do with Haskell?
09:07:10 <dsal> I don't quite understand the point of a custom prelude.  Seems to just make things a bit less standard.
09:07:27 <kamek> your average backend stuff I guess, a few http services, some stream processing
09:08:24 <Uniaika> dsal: standards shouldn't be cargo-culted.
09:08:26 <Cale> Where I work (Obsidian Systems), we get quite a lot of benefit from using Haskell to build entire web applications. Especially the part about sharing types and serialisation code between the frontend and backend.
09:08:42 <dsal> I'm not sure prelude will have that much of an impact on such things.  I mostly pull in the web framework I'm using, encoding bits, amazonka or something, my DB thing and probably lens.  There's not much of prelude I end up caring about.
09:09:00 <Uniaika> I'm very much in favour of using relude to avod stuff like partial functions and silly restrictions, and noisy imports
09:09:10 <dsal> Uniaika: I agree, but introducing something by first making it different from any introductory documentation one might find seems like it'd slow people down a bit.
09:09:14 <kamek> Cale: interesting, what are you using on the frontend ?
09:09:27 <Uniaika> dsal: hmm yeah okay I see
09:09:52 <kamek> dsal: it's for a team of people with no experience with haskell, I'd like to avoid common accidents, like calling head on an empty list
09:10:01 <Uniaika> kamek: hlint
09:10:05 <Uniaika> hlint is your friend on this one
09:10:11 <kamek> oh
09:10:23 <Cale> kamek: We use ghcjs to compile our frontends to javascript, and ghc to compile them to ARM for iOS and Android devices. There's an abstraction layer called jsaddle/ghcjs-dom
09:10:23 <kamek> can it warn for all partial functions ?
09:10:56 <Uniaika> kamek: … It can't know about them 🙃
09:11:03 <Cale> We use reflex-dom to build the actual frontend UIs
09:11:08 <Uniaika> but I think you can specify a list of function that hlint prohibits
09:11:11 <Uniaika> with their equivalents
09:11:22 <Uniaika> (like, head :: NonEmpty a -> a)
09:11:22 <dsal> To some degree, I'd think you'd want a bit of code review to show people better ways to do things.  e.g., instead of `head` maybe you should use `listToMaybe` or `toListOf` or something. 
09:11:25 <Cale> https://github.com/obsidiansystems/obelisk is our application framework :)
09:12:02 <dsal> I'm using elm in a frontend.  Look at this glorious, relevant error:  https://usercontent.irccloud-cdn.com/file/1ThMJzVn/elmerr.png
09:12:41 <glguy> Can you turn that off?
09:12:47 <pie_[bnc]> Cale: can you link any stuff you guys built?
09:12:56 <pie_[bnc]> didntknow yo uwork for obsidian, neato
09:14:41 <gentauro> if anybody is interested in "Type inference by example" -> https://www.twitch.tv/jahnfelt
09:14:44 <gentauro> :)
09:15:11 <dsal> glguy: the elm error?  AFAICT, it won't compile an incomplete pattern match.
09:15:27 <glguy> dsal: No, the overly verbose messages
09:15:38 <dsal> Oh, I don't think so.  You can't even turn off color.  :/
09:15:52 <gentauro> live stream going on now
09:16:13 <glguy> I like how Rust gives you a hint how to get more information about an error but doesn't blast your screen with tutorial content every time you have the same problem
09:16:55 <dsal> This does that, too...  it's just that the short version is pretty long.
09:18:10 <Cale> pie_[bnc]: Our marketing site has a bunch of links to our clients I think... https://obsidian.systems/
09:18:36 <Cale> (also that site itself is built in Haskell)
09:18:42 <tdammers> it's particularly idiotic because that error message says to make the return type of the List.head function more specific, which you can't, because it's from the List module, and you can't write your own NonEmptyList type that implements the same typeclasses as the List type, because Elm doesn't allow users to write their own typeclass instances
09:19:09 <maerwald> wait, what?
09:19:23 <maerwald> "doesn't allow users to write their own typeclass instances" O.o
09:19:35 <tdammers> well, Elm doesn't really have typeclasses
09:19:35 <monochrom> "interesting" solution to the problems of orphan instances and overlapping instances :)
09:20:01 <fendor> it has a single one, `comparable`, that Strings, Ints and Floats implement, afaict
09:20:22 <ski> hm, sounds like equality type variables, in the MLs ?
09:20:26 <tdammers> there is similar built-in magic for numeric operations IIRC
09:20:32 <Cale> Oy, all the blockchain nonsense we've been involved in... haha
09:20:32 <monochrom> Hey speaking of which, Oleg showed that one single MPTC is all you need :)
09:21:06 <tdammers> but in general, for a typed language, Elm is pretty crippled as far as user-defined types go
09:21:29 <monochrom> that's like the worst of both world.
09:21:44 <monochrom> like why don't I simply go back to BASIC
09:22:00 <maerwald> I guess you have to cripple your language in fear of horrible misuse when your target audience is JavaScript developers?
09:22:09 <monochrom> hehe
09:22:28 <tdammers> I don't know what the reasoning is, but I sure hope this is it
09:22:33 <tdammers> because the alternative is worse
09:23:21 <ski> @quote mentally.mutilated
09:23:21 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
09:23:21 <lambdabot> regeneration."
09:23:23 <dsal> tdammers: I didn't read it as "make List.head" more specific, but whatever you're pattern matching against more specific.  If List.head doesn't do exactly what you want, then use something else.
09:23:28 <dsal> maerwald: elm isn't haskell
09:23:40 <ski> (should there be a modern-day Javascript equivalent of that ?)
09:23:50 <tdammers> dsal: yes, but what would that "something else" be?
09:23:52 <monochrom> Yes, it's called PHP :)
09:24:13 <maerwald> dsal: erm, yes
09:24:14 <Cale> ski: I wonder what languages Dijkstra himself was programming in when he said/wrote that
09:24:16 <dsal> tdammers: `headOfListOrThisDefaultValue`
09:24:24 <Cale> and how mentally mutilating they were
09:24:35 <ski> apparently Dijkstra did look at Lisp, and also Haskell, at some point
09:24:37 <tdammers> dsal: but that's not what's needed here. what the author probably wants is "head of non-empty list"
09:24:56 <tdammers> as in, "I know this list will never be empty, so there will always be a head"
09:25:04 <unsupervised> js at least allows a lot of fp and abstraction... unlike many other langauges. Don't understand the hate
09:25:31 <monochrom> there is no hate
09:25:34 <tdammers> the *proper* way of expressing this is to use a dedicated NonEmptyList data type, but AFAIK Elm doesn't come with one, and implementing your own is awkward, because you cannot make it behave like a normal list where that is reasonable
09:26:27 <Cale> unsupervised: Javascript is kind of a weird compiler target language :)
09:26:32 <tdammers> unsupervised: if anything, people are taking stabs at JS *culture*, not the language itself
09:26:35 <dsal> tdammers: Well, in reality, I probably wasn't sure it was always non-empty and was being lazy.
09:26:58 <Cale> and yeah, most of the problems with JS come from the culture of its use
09:27:09 <unsupervised> JS culture has react, redux, rxjs..
09:27:36 <unsupervised> seems to be heading more functional and sane, not less
09:27:45 <tdammers> dsal: I think it is correct behavior on Elm's side to slap you with an error here; it's just that the error message is a bit unhelpful
09:27:46 <Cale> For some reason, there are tons of tiny libraries with few maintainers that other packages freely depend on
09:27:53 <monochrom> <-- don't understand what's there to defend
09:28:24 <Cale> and this makes for an enormous amount of surface area for someone to hide sneaky code in
09:28:29 <dsal> tdammers: I found the error useful.  I agree more language features would be better and that's occasionally annoying in elm.  On the other hand, it's such a leap from javascript that I found it quite delightful.  :)
09:29:01 <tdammers> dsal: me too, until I ran into its nonsense tarpit
09:29:15 <tdammers> "no, you cannot compile your own local package unless you lie to me about it being on github"
09:30:04 <tdammers> "no, you cannot abstract over container types; if you want to change something from lists to arrays, you have to change all the code that touches them"
09:30:40 <tdammers> "no, you cannot go back to an older version of the compiler from before the breaking changes we introduced, instead you must now change all your code before it compiles again"
09:30:41 <maerwald> unsupervised: It's a very "unstructured" language with so many pitfalls that people program it basically like shell, which is part of the reason for the poor culture. TypeScript is quite bearable though.
09:30:52 <dsal> Not being able to have something be orderable was the closest thing to "your language is lacking" I've run into.
09:31:08 <Cale> unsupervised: I've looked at some of these and did not come away thinking that they were particularly functional or sane. It's more like *you* have to be able to impose more type system restrictions on yourself in order to be able to use those libraries correctly, which the javascript implementation won't help you with.
09:31:23 <dsal> I try to be open about tooling...  The amount of work I had to put into getting websockets working in elm was quite surprising.
09:31:30 <maerwald> You can't look at 200 LOC javascript code and tell what it does, without running it.
09:31:37 <tdammers> dsal: surprisingly little, or surprisingly much?
09:31:44 * ski . o O ( "To the Budget Council (concerning Haskell)" by Edsger Wybe Dijkstra in 2001-04-12 at <http://www.cs.utexas.edu/users/EWD/transcriptions/OtherDocs/Haskell.html> )
09:31:45 <unsupervised> I said more* functional and sane
09:31:49 <maerwald> (in every browser)
09:32:12 <dsal> tdammers: It took a lot of work.  It wasn't natively supported and someone had built a pretty heavy framework that required a bunch of javascript stuff to get it working.
09:32:31 <tdammers> huh, yeah
09:32:46 <operand> Elm has a lot of weird stuff, like negative numbers not being allowed in pattern matches
09:32:47 <dsal> This felt like the "you have one job" category.
09:33:03 <operand> And *only* supporting GitHub for packages
09:33:15 <Cale> unsupervised: I do a lot of functional reactive programming in Haskell, and a lot of the ideas and abstractions don't really work in the face of being able to cause uncontrolled effects anywhere. A lot of things would be total nightmares in the presence of unrestricted effects, because the control flow is extremely hard to reason about.
09:34:02 <maerwald> operand: what the...?
09:34:04 <dsal> I expected elm to be less nice that haskell, but better than javascript.  It fit.  I suppose I need to figure out how much pain getting ghcjs will be.
09:34:24 <tdammers> operand: the github thing is even worse - it insists on having a github url even for packages that you never intend to share with anyone. not having a well-formed github url is a compiler error, even though the compiler never touches github. a fake URL works; a non-github URL doesn't.
09:34:54 <tdammers> dsal: ghcjs is painful, but I've heard success stories. have you considered purescript?
09:35:04 <maerwald> There's miso
09:35:14 <Cale> The impression I get from most of these "reactive" frameworks in Javascript and other imperative languages with unrestricted effects is that they force you to shoehorn the structure of your entire application into this antimodular framework where you pile all the state of your application together into a single giant ball that every part of the application can potentially affect.
09:35:17 <dsal> I might look at miso.  I haven't looked at purescript.
09:35:40 <maerwald> tdammers: I still have nightmares from the last time they completely changed how they do effects
09:35:49 <Cale> and well, they make some provision for restricting your view to just parts of that ball, but it becomes really hard to build things once and reuse them
09:35:57 <maerwald> Like, you're half way in with 20k LOC purescript code and they decide to do something like that again
09:35:59 <maerwald> now what?
09:36:08 <Cale> There are these "component" things that don't really compose very nicely
09:36:47 <maerwald> https://purescript-resources.readthedocs.io/en/latest/eff-to-effect.html
09:36:48 <tdammers> Cale: yes, that is my experience too. You start with a nice architecture: a state type, an event type, an update function of Event -> State -> State, and a small imperative core that maintains a state var and feeds events through the update function. but then you look into modularizing the thing into components or whatever, and you're in hell.
09:37:30 <Cale> yep
09:37:41 <tdammers> the best solution I've seen in this field so far is purescript-halogen, but even that isn't particularly awesome, and it requires quite a bit of type-level boilerplate and coupling that feels unnecessary
09:38:35 <unsupervised> yea by my point is: as a popular career language it's heading in the right direction and doesn't deserve the derision. I guess it's easier to critique it for trying since you can directly criticize its poorer execution of some principles, but most other popular career languages lack an FP ecosystem entirely. React and redux inspired by Elm help
09:38:35 <unsupervised> popularize the FP direction; it shouldn't be mocked. The more FP that people are familiar with, the more likely widespread adoption of haskell or a haskell like language becomes
09:39:20 <maerwald> don't think I want haskell to be widely adopted.
09:39:44 <maerwald> Seeing how widely adopted languages turn out
09:39:48 <tdammers> unsupervised: frankly, I don't have a reason to wish for FP to become immediately more popular than it is now. Haskell is a niche language, and that has quite some advantages; and there's enough Haskell work out there to pay my bills, at least for the time being
09:42:17 <Cale> I'm a bit torn -- Haskell's acceptance obviously helps the company I work for get clients, but also I see it as growing more quickly than the community can really keep up with.
09:42:20 <dsal> effect management is only a small part of the problem in javascript.  It's often quite difficult to know the type or scope of anything, much less where it can be modified.
09:43:07 <Cale> The communication channels where people talk about Haskell have also been getting much more fractured lately
09:43:55 <dsal> I'm not young enough to enjoy the vast number of slack tabs you have to keep open to fractal down to topics in particular projects.
09:44:49 <maerwald> Cale: you mean not enough people working on the core?
09:46:00 <Cale> maerwald: I mean, there's a kind of cultural problem where people write blog posts about the newest shiniest features of GHC which really if you were being sensible would only see use in 1% of cases, and then you have lots of new programmers and they see these blog posts and develop a style of programming which is just absurd.
09:46:18 <maerwald> Oh that
09:46:28 <maerwald> Hype driven development
09:47:01 <peutri> Blog driven development
09:47:05 <Cale> and the communication mechanisms which would let beginners absorb good style from older programmers are getting more and more split up and so they're less useful for that
09:47:11 <peutri> bdd in those circles
09:48:16 <maerwald> Cale: The design space is, partly, just too big. Even picking a way to represent application state can be done in so many ways
09:48:44 <maerwald> Error handling, no one agrees over
09:49:07 <Cale> Well, that's fair, but also, when you go ahead and use the type system to guarantee something, you should make sure that what you're guaranteeing is actually a property that you care about.
09:49:12 <maerwald> I think we agree on how to do parsing =)
09:49:52 <Cale> I've seen a ton of nonsense singletons bullshit that accomplished no actual goal whatsoever, apart from making maintenance of a codebase almost completely intolerable
09:49:58 <fendor> arent there like 5 different big parsing libs? And base has its own simplistic parsing module?
09:50:13 <maerwald> fendor: yes, the base parsing thing is really really weird
09:50:23 <maerwald> but apart from that, all parser libs follow the same mental model
09:50:29 <Cale> I actually really like ReadP :P
09:50:44 <fendor> I also used ReadP, could be worse. At least it isnt over the top
09:51:10 <maerwald> every time I come across it, I forgot how to use it -.-
09:51:14 <fendor> it also has the same problem/advantage as everything else: there are many ways to do it.
09:51:24 <peutri> same as maerwald 
09:51:36 <peutri> it could use a bit of documentation love, I suppose
09:51:36 <Cale> It's not good for larger scale things, but if you just have to write a small parser, the fact that it has symmetric choice is very comfortable.
09:52:25 <Cale> I'm okay with there being a lot of ways to accomplish things, my worry is when fancy tools are used to accomplish essentially nothing.
09:52:31 <maerwald> I think the bigger problem is that a lot of core libs are completely unattended and GHC is struggling with lack of contributors as well, no?
09:52:49 <Cale> When there's a much more basic way of expressing something, but someone goes ahead and uses type families for nothing.
09:53:06 <fendor> which core libs are unattended?
09:53:10 <maerwald> And I would expect big companies to assign resources to that
09:53:15 <maerwald> fendor: not "core" as in "core"
09:53:22 <fendor> Cale, to be fair, if it looks cool, I have to try it as well :)
09:53:28 <maerwald> but there's a lot of bitrot, even for libs with 30k+ DLs
09:53:30 <Cale> I'm on the CLC, so if there's something you want done, I can prod some people :)
09:54:21 <maerwald> Cale: 'tar' was one thing. It isn't really a core lib, but very popular, although it can't even unpack a GHC bindist, because of 3+ bugs
09:54:30 <maerwald> and lack of GNU extensions
09:54:48 <Cale> maerwald: ah, okay, maybe something like that *should* be a core library
09:55:14 <maerwald> I had to basically fork it to make it work, because I can't wait 6 months for all the PRs to be eventually merged :P
09:55:41 <Cale> Yeah, where I work, we just fork things and ask questions later, it's the only sensible thing to do
09:56:17 <Cale> (We try and get things upstreamed, but never hold anything up on it)
09:57:31 <maerwald> Cale: yeah. And core libs like 'unix' also move very very slow. And I don't mean "release cycle", but "someone commented a year later on a PR"
09:58:09 <dsal> What's this 'unix' thing?  Does it have pread?
09:58:15 * dsal has a really horrible workaround for the lack of pread.
09:58:30 <fendor> ok, fair. I remember being stuck on unix before
09:58:57 <tomjaguarpaw> peutri: If there's a collision then they're equal so it doesn't matter.  You might as well say the same thing about map, which does exist!
09:59:13 <peutri> tomjaguarpaw: yes, but that would change the structure
09:59:29 <peutri> like, break the functor law
10:00:18 <maerwald> fendor: I provided a PR once. It was merged 2 YEARS later
10:00:44 <maerwald> it doesn't even have `fdopendir` and the PR that wants to add it is stale
10:00:53 <peutri> tomjaguarpaw: (and they're not necessarily equal if there's a collision, that would require the function to be injective)
10:01:17 <fendor> nice. 
10:01:47 <maerwald> You shouldn't be surprised that numbers of contributors is convergint to 0, when you need 2 years to review/approve a PR.
10:02:20 <fendor> yeah fair enough.
10:02:33 <maerwald> 'directory' package was a bit more responsive, but my experience with core libraries so far isn't very good.
10:03:25 <maerwald> Ppl should loudly shout for help if they don't have enough time, so there's enough eyes on projects
10:04:16 <monochrom> yeah, ekmett does it right, empower volunteers
10:06:45 <Cale> maerwald: What's your PR?
10:07:13 <maerwald> Cale: it's been merged, it's fine :>
10:07:39 <maerwald> the fdopendir one is more important to move forward
10:07:55 <maerwald> https://github.com/haskell/unix/pull/110
10:08:05 <maerwald> which is also 2 years old :P
10:08:13 <fendor> Who maintains these core packages? 
10:08:15 * hackage pairing 1.1.0 - Bilinear pairings  https://hackage.haskell.org/package/pairing-1.1.0 (sdiehl)
10:08:26 <fendor> or such core/very important packageS?
10:08:56 <monochrom> I wouldn't be surprised if the answer were "the cabal. btw, there is no cabal" :)
10:09:27 <incertia> is there any idiomatic way to filter a traversable based on the constructor given?
10:10:04 <fendor> very transparent :)
10:10:13 <incertia> using prisms you get the constructor arguments out but that's not always what i want
10:10:14 <Cale> A bunch of different people -- you can look at who has commits on any given package
10:10:39 <Cale> (as a decent approximation of who has the ability to commit to the repo)
10:11:07 <Cale> hmm, though I guess github isn't going to say who actually merged the changes
10:11:20 <Cale> (well, it will, but there will be lots of commits from other people)
10:11:25 <maerwald> But these things can be reasonably fixed with improving communication, collaboration structure etc. GHCs future is maybe more worriesome?
10:12:27 <Cale> I think the main difficulty with GHC right now is that people are dragging it in multiple directions that don't seem entirely compatible with each other, and the main thing it probably ought to be doing is sitting still for a while (in terms of its external interface), and getting tidied up.
10:12:35 <sheepfle1ce> Is there a way to turn a type of kind `Type` into a `Symbol` and compare them? 
10:12:54 <maerwald> Cale: do you know how many full-time devs GHC has?
10:13:28 <sheepfle1ce> I just need to define an ordering inside of a type list, so manually supplied signatures do not conflict with inferred ones.
10:13:44 <Cale> I've been struggling to understand various aspects of the typechecker and other parts of the compiler lately, and ... I can't say I've been pleased with the convention of naming variables by taking a sentence which describes them and then deleting 80% of the letters and all the spaces from it
10:13:56 <Lycurgus> is there a significance to 3 versions being listed on the ghc home page or is it just recent 3, i know there was a feature fork a while back
10:14:30 <Cale> maerwald: I'm not sure, but that's not so much the problem as the fact that everyone is spending all their time rebasing everything
10:14:52 <Cale> I just spent like an entire week rebasing a trivial refactor over and over before it could get merged
10:15:29 <Cale> and the situation with submodules is also kind of painful
10:16:40 <Cale> The CI fails randomly and is inconsistent about its results. Often retrying a job that failed will cause it to succeed
10:16:50 <maerwald> :o
10:17:21 <pgiarrusso> 7:12 PM <maerwald> Cale: do you know how many full-time devs GHC has?
10:17:28 <Cale> I don't actually know
10:17:32 <pgiarrusso> maerwald: IIUC 0
10:17:42 <pgiarrusso> Which surprises me honestly
10:17:45 <Cale> Well, I'm kind of a full time dev who is working on GHC?
10:17:54 <Cale> But I'm also a beginner
10:18:02 <Cale> and I'm doing random stuff I don't care about for a client
10:18:15 <Cale> So, it's a bit weird
10:18:44 <pgiarrusso> Cale: I read the question as “people who are paid to spend all their working time on GHC”
10:18:48 <maerwald> yes
10:18:54 <Cale> Yes, I fit that description at the moment
10:19:18 <pgiarrusso> Oh. I’m confused by the part re the client, but okay :-)
10:19:20 <Cale> I'm working for Obsidian Systems, who is paying me to work full time for MIRI, who has us working on GHC :)
10:19:37 <pgiarrusso> the artificial intelligence/LessWrong MIRI?
10:19:41 <Cale> yeah
10:19:44 <pgiarrusso> Cool
10:21:37 <Cale> I suspect various other people are in similar situations, where they're not directly paid by Haskell.org or something, but instead are working for another company who has them working on GHC full time.
10:21:46 <Cale> But I don't really know
10:22:04 <pgiarrusso> anyway, the bigger point that people made to me is that, unlike I assumed, even SPJ does _not_ fit the description.
10:22:37 <pgiarrusso> because he’s still a researcher, and maybe for more reasons.
10:22:43 <Cale> Yeah, I'm not sure if that's more out of choice than anything though. I'm sure that if SPJ wanted to be paid to work full time on GHC, he could be.
10:22:51 <pgiarrusso> (I forget how much of that is my guess or actual fact)
10:23:45 * hackage pontarius-xmpp-extras 0.1.0.0 - XEPs implementation on top of pontarius-xmpp  https://hackage.haskell.org/package/pontarius-xmpp-extras-0.1.0.0 (SergeyAlirzaev)
10:23:57 <pgiarrusso> well, if he’s only writing GHC code and papers (and I don’t know that’s the case), that’s probably ideal.
10:24:42 <pgiarrusso> I don’t know if there’s consensus on this, but I think “everything in GHC has been vetted in a paper” is a major factor in the quality of its design.
10:24:53 <pgiarrusso> (_almost_ everything).
10:25:12 <pgiarrusso> and I don’t mean that everything is perfect, mind you.
10:25:35 <pie_[bnc]> :P yeah like 90% of that page <Cale> Oy, all the blockchain nonsense we've been involved in... haha
10:26:07 <pgiarrusso> but this hasn’t happened in either of Scala or Coq, and it shows. I can’t judge either OCaml or Agda on this front.
10:27:30 <dsal> maerwald: Your link to that unix package led me to the bug someone filed for a lack of pread which pointed me to a package that has one.  Hopefully this helps me.
10:30:05 <pie_[bnc]> Cale: though I was wondering about some nontrivial thing built on ghcjs i could poke at
10:30:12 <pie_[bnc]> as in poke the frontend of
10:30:17 <maerwald> dsal: yeah, and unix-bytestring has no issue tracker :>
10:30:24 <pie_[bnc]> like, id like to see a seriough haskell web frontend
10:31:09 <dsal> pie_[bnc]: https://github.com/dmjio/miso ?
10:31:12 <pie_[bnc]> oh huh. sounds sensible. <pgiarrusso> I don’t know if there’s consensus on this, but I think “everything in GHC has been vetted in a paper” is a major factor in the quality of its design.
10:31:32 <pie_[bnc]> dsal: i mean an actual product or sometihng
10:32:22 <monochrom> IMO "vetted in a paper" is a proxy for "very intelligently designed and also very good oversight"
10:34:21 <pie_[bnc]> too bad not everyone gets to be ghc :)
10:35:27 <dsal> I take pride in my paperless office.
10:36:05 <pie_[bnc]> unrelated question, given that type level programming in haskell i ssome dynamic language, has anyone written a better frontend for type level programming ? P:
10:36:09 <monochrom> PDF = paper distribution format, don't you know? :)
10:36:46 <monochrom> I think it's called Agda :)
10:37:12 <pie_[bnc]> um
10:37:24 <monochrom> Also I think type-level Haskell has a static kind system so it is not quite dynamic.
10:37:50 <pie_[bnc]> basically is it possible for type level programming to be a bit friendlier
10:38:20 <monochrom> IMO "friendlier" is barking up the wrong tree.
10:38:37 <monochrom> Logic has never been friendly.  Cold hard calculating unforgiving logic.
10:39:02 <monochrom> Instead, you change yourself to become more friendly to logic.
10:39:29 <monochrom> When that happens, Agda or Coq or basically any theorem-proving language isn't too bad.
10:40:00 <monochrom> And then you can talk about adding some convenience helper functions or syntax sugars.
10:44:14 * hackage herf-time 0.3.1 - haskell time manipulation in a 'kerf like' style.  https://hackage.haskell.org/package/herf-time-0.3.1 (scottmurphy09)
10:48:52 <pie_[bnc]> sure
10:54:45 * hackage pontarius-xmpp-extras 0.1.0.1 - XEPs implementation on top of pontarius-xmpp  https://hackage.haskell.org/package/pontarius-xmpp-extras-0.1.0.1 (SergeyAlirzaev)
10:55:11 <DigitalKiwi> is that pgiarrusso that is Blaisorblade
10:57:44 * hackage hsendxmpp 0.1.2.0 - sendxmpp clone, sending XMPP messages via CLI  https://hackage.haskell.org/package/hsendxmpp-0.1.2.0 (SergeyAlirzaev)
11:11:45 * hackage dobutokO2 0.37.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.37.0.0 (OleksandrZhabenko)
11:41:26 <solonarv> pie_[bnc]: the modern approach to type-level haskell is not "dynamic" by any reasonable definition
12:31:51 <pgiarrusso> DigitalKiwi: you discovered my (non-)secret :-)
12:35:47 <DigitalKiwi> pgiarrusso: are you still doing scala or have you moved on
12:38:14 * hackage dobutokO2 0.37.1.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.37.1.0 (OleksandrZhabenko)
12:38:41 <pgiarrusso> DigitalKiwi: currently doing Scala in Coq ;-) https://iris-project.org/pdfs/2020-dot-submission.pdf
12:40:39 <sm[m]> reading Cales comment, I think: it sure would be nice to have a year of only cleanup/polish for all things haskell
12:41:14 <sm[m]> even years for cleanup, odd years for features..
12:41:21 <Cale> haha
12:41:54 <maerwald> this surely is rather an odd year ;)
12:41:55 <sm[m]> if you can't help yourself creating features, you must keep it to yourself until the right year!
12:42:51 <sm[m]> re full time GHC people, is bgamari not one ?
12:43:07 <DigitalKiwi> at first i read that as idris instead of iris and was even more confused about what you were doing :D
12:44:45 <koz_> sm[m]: Technically yes, but I believe it's because someone's paying his employer.
12:44:52 <koz_> Kinda similar to Cale's situation.
12:46:43 <DigitalKiwi> Cale: someone was talking about ios and nix the other day (night in your tz i think) so i couldn't ask you but isn't that a thing your work does
12:47:04 <Cale> Yep, that's one of the things we do
12:47:05 <DigitalKiwi> Cale: building ios apps with nix i guess
12:47:14 <maerwald> and blockchain
12:47:17 <Cale> yeah, see reflex-platform and Obelisk on github
12:47:44 <Cale> Yeah, we also do a lot of silly blockchain shenanigans, though I try to avoid that
12:47:52 <maerwald> big data too?
12:48:39 <DigitalKiwi> do you have to be on a mac to build the ios apps still (i'd assume so but *shrug* i can dream right)
12:50:15 <Cale> Yeah, you need to have a mac at least -- nix can use a mac remote builder
12:50:23 <dsal> github will build on macs
12:50:46 <dsal> I don't know if github will work with nix on macs, though.  It's a bit of a pain to install.
12:51:58 <dsal> I wish github had arm builders handy.  That would be super useful to me.
12:52:42 <DigitalKiwi> https://github.com/nix-community/aarch64-build-box
12:53:11 <DigitalKiwi> are you on that
12:53:40 <dsal> No, I mean like https://github.com/dustin/gopro/actions/runs/87396799 <-- github uses github resources to build my project and provide artifacts for linux and mac.
12:54:08 <dsal> Or can I link this into the github thing?
12:54:24 <maerwald> dsal: I can build for arm :P
12:54:34 <maerwald> You can build a cross GHC for arm too
12:54:49 <dsal> I *can* build for ARM, it's just a bit of a pain.  I use AWS or docker or something when I need.
12:55:20 <dsal> The platforms I get artifacts for from github for free just happen to be the ones that it's easiest to build on.
12:55:41 <DigitalKiwi> <DigitalKiwi> https://myfriendshate.me/files/2020-01-07-075516_2880x1800_scrot.png global warming you say? i'm doing my part
12:56:22 <dsal> Nice.  What is that?
12:57:50 <DigitalKiwi> that's the box for that github link. i was git bisecting nixpkgs. most people use it as a remote builder i think. depending on what you want to do and how well you're known it might be useful and appropriate to you
12:58:24 <bgamari> DigitalKiwi, yikes, system time looks pretty rough
12:58:28 <DigitalKiwi> ask graham
12:58:59 <dsal> Oh neat.  github has a way to hook external builders into their workflows thing for CI.
13:00:01 <DigitalKiwi> bgamari: which system time the load average?
13:00:33 <bgamari> DigitalKiwi, just looking at how much red there are in the bar graphs
13:00:42 <bgamari> IIRC that is kernel time
13:01:07 <DigitalKiwi> well I was building an entire OS essentially ;)
13:01:40 <DigitalKiwi> a lot of it was cached but...a few times it wasn't
13:03:44 <DigitalKiwi> https://github.com/NixOS/nixpkgs/pull/77348 i think this is the one i was tracking down
13:04:34 <DigitalKiwi> it uh might have taken quite a few hours :)
13:04:59 <DigitalKiwi> probably would have taken days if i had to do it on my computer...
13:08:18 <bgamari> DigitalKiwi, what I mean to say is that it looks like much of your CPU time is being spent in the kernel, not user-land
13:08:45 <bgamari> DigitalKiwi, perhaps you are I/O bound or there is some configuration issue?
13:09:27 <DigitalKiwi> hmm idk
13:11:45 <dsal> 64 cores attack one spindle.
13:13:12 <DigitalKiwi> is 1-2GB/s fast
13:13:52 <DigitalKiwi> time dd if=/dev/zero of=~/zeros.txt bs=10M count=1000 conv=sync
13:13:52 <DigitalKiwi> 1000+0 records in
13:13:52 <DigitalKiwi> 1000+0 records out
13:13:53 <DigitalKiwi> 10485760000 bytes (10 GB, 9.8 GiB) copied, 5.41433 s, 1.9 GB/s
13:14:49 <bgamari> DigitalKiwi, well, your laptop probably has several dozen GB/s of memory bandwidth
13:15:07 <DigitalKiwi> that's on that arm server
13:15:37 <DigitalKiwi> my understanding is the cpus aren't that great but there are a lot of them
13:15:45 <bgamari> s/several/a few/
13:16:37 <bgamari> DigitalKiwi, I'm not sure dd'ing from /dev/zero is going to tell you much of use TBH
13:17:10 * DigitalKiwi tries to remember what disk tests there are that don't require root
13:17:22 <bgamari> I guess the fact that you passed conv=sync might make this somewhat of a I/O bandwidth test
13:18:51 <dsal> Also, dd dumping zeros sequentially to a file isn't quite the same as 64 cores demanding seeks.
13:19:43 <DigitalKiwi> iomelt https://dpaste.org/wrwE
13:21:32 <DigitalKiwi> my laptop https://dpaste.org/QPpJ (1G instead of 10G)
13:24:47 <frdg> are monads basically just fancy function composition?
13:24:59 <frdg> at least the Maybe monad
13:26:06 <Uniaika> frdg: the Maybe and Either monads are very useful for "fancy function composition" yes
13:26:40 <frdg> hmm ok, I think im beginning to understand. Thanks
13:27:04 <dsal> "are monads basically just" is probably going to end with a generalization that is right for some things, but not generally right.
13:28:22 <Uniaika> frdg: Moronuki and Martin's /Finding Success with Haskell/ is a very good book that explores this aspect of monads
13:30:52 <rawles> Uniaika: Would you recommend this book for general study, or just this aspect?
13:31:42 <dsal> Haskell has this neat thing where you can use pretty obscure abstractions without understanding them very well.  Understanding helps, but you can do a lot of monading without understanding what a monad truly is.
13:31:51 <dsal> Monads are basically just the sound of one hand clapping.
13:32:54 <Uniaika> rawles: considering that branching (either, maybe) composition is the subject of the book, I'd say it falls in the "general study" category as well :)
13:33:35 <DigitalKiwi> if i ever find someone that implements their password checker example though ...
13:33:42 <DigitalKiwi> (in production i mean)
13:34:16 <DigitalKiwi> i haven't finished the book yet but it's not bad
13:42:25 <Uniaika> and as you can see, our resident kiwi has some Strong Opinions™ about this book, but loves it anyway
13:43:10 <rawles> Hehe, well I'll try to check it out. Thanks.
13:47:15 * hackage gi-poppler 0.18.22 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.22 (inaki)
13:49:05 <monochrom> frdg: No, "M a -> (a -> M b) -> M b" looks more like application than composition.  For composition, look at >=> instead.
13:50:09 <monochrom> This is what's wrong with "basically". Basically, it's wrong.
13:50:42 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #0
13:51:45 * hackage discord-haskell 1.5.1 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.5.1 (Aquarial)
13:51:56 <maerwald> 6. is my favorite
13:52:10 <monochrom> :)
13:53:38 <ja> monochrom: the link in #10 is broken. but it is available on webarchive: https://web.archive.org/web/20200104173415/http://cowbirdsinlove.com/43
13:55:26 <ja> that is actually a kind deep thing about language :O you can never know for sure if you have the right interpretation or everything just seems to fit by 'accident' :O
13:57:52 <dsal> The more I know, the less complete I feel my knowledge is.
13:59:31 <hpc> #4 is by far the most useful tautology for me
13:59:49 <ja> dsal: that makes so much sense too. if you knew nothing, there could be no inconsistencies :P
14:00:19 <olavx200> > The more I know, the less complete I feel my knowledge is.
14:00:19 <olavx200> That's the donning kruger effect for you.
14:00:21 <lambdabot>  <hint>:1:16: error: parse error on input ‘,’
14:00:38 <justsomeguy> I like books. What book are you reading, DigitalKiwi? What makes it good?
14:01:22 <olavx200> I should stop using Matrix quotes. The bot doesn't like that apparently.
14:02:14 <DigitalKiwi> justsomeguy: https://leanpub.com/finding-success-in-haskell it's short enough i can actually read it
14:04:44 <justsomeguy> Oh, It's by Julie. I'm reading HPFP right now, around ch 12, just about where they introduce Maybe and Either. That book almost seems like a hands-on recap of what I've been reading.
14:05:16 <justsomeguy> Seems neat.
14:06:04 <justsomeguy> Oh, it covers monads and applicatives, too.
14:06:13 <justsomeguy> Or am I misreading..
14:08:19 <koz_> Can someone link me to an explanation of why, due to parametricity, Functor has at most one lawful definition for a data type?
14:12:06 <dsal> koz_: hmm...  How could there be more than one?
14:12:52 <koz_> dsal: There has to be an explanation somewhere, right? I need it to stuff as a reference into a thing I'm writing.
14:13:10 <koz_> Also, a link to the whole 'sum of products is canonical rep for ADT' would be lovely.
14:16:42 <dsal> > let isid id = True; isid _ = False in isid not
14:16:44 <lambdabot>  True
14:18:06 <dsal> There goes my attempt to be a Haskell attorney.
14:23:41 <koz_> Also, is there a name for the style of function definition that goes something like 'foo (Bar x) = ...\nfoo (Baz q v e) = ...\nfoo Quux = ...'?
14:24:14 <dsal> I've seen it referred to as having multiple heads.
14:25:34 <justsomeguy> Oh, weird, I see that in JavaScript a lot.
14:25:57 <dsal> Which?
14:28:08 <justsomeguy> Functions with multiple heads. Let me try to find an example.
14:29:30 <xcmw> How could I represent something similar to this image in haskell? https://shorturl.at/ipuCF I get how algebraic data types work but I don't see how to make a graph like data structure with them. 
14:29:33 <lyxia> koz_: https://mail.haskell.org/pipermail/libraries/2011-February/015964.html somehow it's hard to track down a good source, seems like it's just a folklore corollary from Wadler's Theorems for Free!
14:30:04 <koz_> lyxia: Thank you! There's a reason why I couldn't find it.
14:30:11 <lyxia> https://www.schoolofhaskell.com/user/edwardk/snippets/fmap
14:30:40 <koz_> lyxia: I think I'll go for the second one. Partly because Edward, partly because it has actual code and my audience are Haskellers.
14:33:49 <justsomeguy> dsal: You know, I think I was mistaken. It was just currying. This book uses nested arrow functions a lot.  https://leanpub.com/javascriptallongesix/read#flip
14:35:15 <lyxia> dsal: you can't write isid in Haskell because you can't tell whether a function parameter is the identity function.
14:36:03 <justsomeguy> dsal: Or maybe that is equivalent?
14:36:59 <dsal> justsomeguy: nah, this is effectively multiple function declarations, pattern matching on their inputs.
14:37:13 <dmwit> ?tell xcmw Your link doesn't work for me, but you might like https://stackoverflow.com/q/9732084/791604
14:37:13 <lambdabot> Consider it noted.
14:37:16 <dsal> lyxia: But why is that true?
14:38:28 <dmwit> lyxia: isid :: (forall a. a -> a) -> Bool; isid f = f `seq` f () `seq` True -- ;-)
14:38:53 <dmwit> A dash of unsafePerformIO will even let you return False sometimes.
14:40:03 <koz_> dmwit: unsafePerformIO - the ghost pepper sauce of Haskell.
14:41:35 <dmwit> spice take
14:43:30 <monochrom> Given the type "forall a. a -> a", you can narrow it down to id, bottom, and a few intermediate levels in between for various strictness.
14:43:51 <monochrom> However, to distinguish between them, you will run into the halting problem.
14:44:23 <dsal> @hackage halting
14:44:23 <lambdabot> http://hackage.haskell.org/package/halting
14:44:33 <dsal> Argh.  Package not found.
14:45:00 <monochrom> The @hackage command is a simple \x -> url_prefix ++ x
14:45:34 <monochrom> Now that's an example of a pure, effectless, identity function :)
14:46:22 <dsal> Yeah, sure.  I just wanted a package that solved the halting problem so I don't have to think about it.
14:46:53 <lyxia> dsal: I linked to a proof above.
14:46:55 <monochrom> I take a more relaxed stance. Give up, so I don't have to think about it. :)
14:48:07 <solonarv> % import GHC.Exts
14:48:07 <yahb> solonarv: 
14:48:44 <solonarv> % isid :: (forall a. a -> a) -> Bool; isid x = isTrue# (reallyUnsafePtrEquality# x Prelude.id)
14:48:44 <yahb> solonarv: 
14:48:47 <solonarv> isid id
14:48:49 <solonarv> % isid id
14:48:50 <yahb> solonarv: True
14:48:59 <solonarv> % isid (\x -> x) -- but...
14:49:00 <yahb> solonarv: False
14:49:08 <akasha> if I have a pattern (x:y:[]) and another pattern (y:ys), is (y:ys) going to catch what could otherwise be matched by (x:y:[])?
14:49:42 <lyxia> The proof assumes parametricity, and sadly, AFAICT there is no accessible explanation of parametricity, much less in Haskell. If you don't have the ability to read the Theorems for free! paper, it boils down to "here's something for free, trust me it's a theorem".
14:49:52 <solonarv> akasha: yes, because (x:y:[]) is really (x:(y:[]))
14:50:06 <solonarv> which is substitution instance of (y:ys)
14:50:14 <akasha> thanks
14:54:06 <dsal> solonarv: your honor, the functor law is written with respect to `id` not things that behave like `id`
14:55:08 <monochrom> Free theorems implies natural transformations.  The latter are what lambdabot's @free command really gives.  For most purposes, natural transformationness seems to be enough.
14:55:57 <monochrom> The upside is that natural transformations are easier to learn and use, and you can find many more explanations of what the heck "natural tranformation" looks like.
14:56:29 <MarcelineVQ> natural transformations ought to be enough for anyone, as the saying goes
14:56:46 <solonarv> oh! I have a better one!
14:57:47 <koz_> lyxia: Mostly the boat I'm in!
14:57:55 <monochrom> The free theorems themselves require you to imagine simulation relations between pairs of types. They are necessarily harder to state and use. When every relation is a function (and probably some further restrictions), you get the natural tranformations.
14:58:24 <MarcelineVQ> solonarv: https://www.youtube.com/watch?v=ce-LjCpserA
15:00:13 <solonarv> % isid :: (forall a. a -> a) -> Bool; isid f = let !test = 0xCAFEBABE :: Int in unsafePerformIO $ do try (evaluate (f test)) >>= \case Left exc -> pure False; Right !x -> pure $ isTrue# (reallyUnsafePtrEquality# test x)
15:00:14 <yahb> solonarv: ; <interactive>:12:100: error:; * Ambiguous type variable `e0' arising from a use of `try'; prevents the constraint `(Exception e0)' from being solved.; Probable fix: use a type annotation to specify what `e0' should be.; These potential instances exist:; instance Exception NestedAtomically -- Defined in `Control.Exception.Base'; instance Exception NoMethodError -- D
15:01:21 <pgiarrusso> 11:53 PM <dsal> solonarv: your honor, the functor law is written with respect to `id` not things that behave like `id`
15:01:46 <solonarv> % isid :: (forall a. a -> a) -> Bool; isid f = let !test = 0xCAFEBABE :: Int in unsafePerformIO $ do try (evaluate (f test)) >>= \case Left (exc :: SomeException) -> pure False; Right !x -> pure $ isTrue# (reallyUnsafePtrEquality# test x)
15:01:46 <yahb> solonarv: 
15:01:56 <solonarv> % isid (\x -> x)
15:01:56 <yahb> solonarv: True
15:02:00 <solonarv> hahaha!
15:02:10 <pgiarrusso> dsal: I think that won’t make much difference
15:02:26 <pgiarrusso> % isid (\ x -> undefined)
15:02:26 <yahb> pgiarrusso: False
15:02:40 <monochrom> pure False
15:02:51 <solonarv> % isid (unsafeCoerce . succ @Int . unsafeCoerce)
15:02:52 <yahb> solonarv: False
15:03:09 <monochrom> @quote monochrom unsafeCoerce
15:03:09 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
15:04:34 <pgiarrusso> I think the attitude in Haskell is that isId is either unsafe or buggy, not a violation of parametricity.
15:04:50 <solonarv> indeed
15:04:54 <monochrom> I think we were all joking.
15:04:57 <solonarv> this one is both unsafe *and* buggy!
15:05:00 <pgiarrusso> Better rename it to unsafeIsId
15:05:23 <solonarv> (if that 'try' catches an async excecption, bad things will happen)
15:05:49 <pgiarrusso> Cool we agree, I guessed somebody might have wondered
15:06:20 <pgiarrusso> Not that i get how it works...
15:07:28 <pgiarrusso> % isid (\x -> 0xCAFEBABE)
15:07:28 <yahb> pgiarrusso: ; <interactive>:17:13: error:; * No instance for (Num a) arising from the literal `0xCAFEBABE'; Possible fix:; add (Num a) to the context of; a type expected by the context:; forall a. a -> a; * In the expression: 0xCAFEBABE; In the first argument of `isid', namely `(\ x -> 0xCAFEBABE)'; In the expression: isid (\ x -> 0xCAFEBABE)
15:07:54 <pgiarrusso> % isid (\x -> 0xCAFEBABE :: Int)
15:07:54 <yahb> pgiarrusso: ; <interactive>:18:13: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. a -> a; at <interactive>:18:6-30; * In the expression: 0xCAFEBABE :: Int; In the first argument of `isid', namely `(\ x -> 0xCAFEBABE :: Int)'; In the expression: isid (\ x -> 0xCAFEBAB
15:07:54 <solonarv> no, you must pass a function of type 'forall a. a -> a'
15:08:12 <solonarv> not 'forall a. a -> Int'
15:08:29 <solonarv> (that's why I needed the unsafeCoerce's  around 'succ @Int')
15:08:48 <solonarv> but you are right, that is a way to defeat this isid
15:09:11 <solonarv> % isid (\x -> unsafeCoerce (0xCAFEBABE :: Int))
15:09:11 <yahb> solonarv: False
15:09:17 <solonarv> eh?
15:09:18 <solonarv> oh!
15:09:28 <solonarv> I already accounted for that!
15:10:02 <pgiarrusso> Ooh, it compares the result by thunk pointer!
15:10:07 <solonarv> yes!
15:11:02 <pgiarrusso> Okay, I suspect I can imagine half a proof of correctness for this bit by “parametricity” for effectful languages
15:11:48 <pgiarrusso> Rather — the point is that a pointer to “test” is “private”
15:12:17 <solonarv> yes, and 'test' is created anew on each 'isid' call
15:12:27 <pgiarrusso> And I think we can now do proofs exploiting such reasoning...
15:12:45 <pgiarrusso> Oh right, that’s also important, lest you try to save a pointer.
15:12:54 <solonarv> honestly, I'm not sure the primitives I used are defined rigorously-enough to write proofs about them
15:13:14 <solonarv> I'm doing THREE different unsafe things! in one function!
15:13:26 <solonarv> (the third unsafe thing is catching SomeException)
15:13:26 <pgiarrusso> I retract the claim anyway because I’m not sure about attempts to save pointers.
15:13:26 <monochrom> Me too :)
15:14:15 <pgiarrusso> solonarv: yeah being able to write such proofs is a research project, but for unsafe Rust we can do that in Coq (with RustBelt)
15:14:25 <lyxia> you are crazy people.
15:14:26 <pgiarrusso> And there was a paper applying similar techniques to Haskell’s runST
15:15:01 <pgiarrusso> here it is https://iris-project.org/pdfs/2018-popl-runST-final.pdf
15:15:41 <pgiarrusso> I don’t know if that’d handle this sort of thing, that wasn’t their point and nobody cares, _but maybe_ :-)
15:16:06 <pgiarrusso> lyxia: anything against separation logic?
15:16:09 <pgiarrusso> :-)
15:17:12 <pgiarrusso> okay, okay, Haskell’s entire point is to eschew the need for it, but that’s just a detail 😈
15:17:35 <MarcelineVQ> pgiarrusso: this is a neat paper just from being informative about ST, let alone the proofs
15:26:59 <peutri> 17
15:27:13 <peutri> ...sorry wrong window
15:27:28 * peutri changes all passwords preemptively
15:27:40 <mlugg> Hi, I'm looking at implementing a simple Haskell-like language. I'm reading up on type checking and inference, and I've been able to implement basic HM-ey stuff, where type checking and inference are equivalent, but am having trouble finding resources on things like System F. I know that type inference is undecidable in general for SysF - I assume
15:27:40 <mlugg> that Haskell just tries inference using the HM algorithm (?) - but I can't find anything on how to implement type checking in that kind of type system. Does anyone have any pointers to things I could look at? Thanks :)
15:28:02 <MarcelineVQ> *password changed to '18'* there, that's better
15:28:42 <peutri> ;)
15:29:46 <DigitalKiwi> irssi user spotted?
15:30:15 <peutri> like, mIRC is at 16, irssi at 17?
15:30:50 <DigitalKiwi> usually random numbers in wrong windows are from irssi users because it's used to switch buffers
15:31:05 <Uniaika> IRSSI USER SPOTTED!1§!
15:31:20 <peutri> this one was me trying to get to the line in error
15:31:30 <peutri> i'm afraid it was prety client-agnostic
15:31:39 <DigitalKiwi> vim user spotted?
15:31:58 <peutri> missing the :
15:32:23 <DigitalKiwi> well that wouldn't be the only mistake you made
15:32:31 <peutri> indeed
15:32:38 <peutri> error cause was in another file
15:34:32 <lyxia> mlugg: this recent paper is exactly about that https://www.microsoft.com/en-us/research/publication/guarded-impredicative-polymorphism/
15:34:36 <pgiarrusso> mlugg: just to understand, you don’t want just a typechecker for System F without inference, right?
15:35:53 <mlugg> pgiarrusso: no, but I'm not entirely sure how inference works on System F (and friends). I know it's undecidable in the general case; so I wasn't sure if you just try inference using HM, or if there are specific ways of attempting it in SysF
15:36:15 <pgiarrusso> I was thinking of the work they use for inference on rank-n types, but lyxia’s link is also relevant for going beyond that IIRC
15:36:37 <pgiarrusso> in any case, it’s not just “use HM and hope for the best”
15:37:40 <pgiarrusso> I think Haskell still has decidable inference, in 99% of variants (except ImpredicativeQuantification or however is it called, but maybe now even there with that link?)
15:37:59 <pgiarrusso> so it either restricts the language or requires more type annotations
15:38:56 <pgiarrusso> mlugg: the paper I had in mind was https://www.cambridge.org/core/journals/journal-of-functional-programming/article/practical-type-inference-for-arbitraryrank-types/5339FB9DAB968768874D4C20FA6F8CB6
15:40:16 <pgiarrusso> but IIRC the basic approach in Haskell is the one described in https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/
15:42:00 <mlugg> So (sorry if stupid question) is the process of type checking in general just "infer every [sub]expression and see if it makes sense?"
15:49:35 <pgiarrusso> mlugg: IIUC, not necessarily; in some typechecking algorithms, for some expressions you take an expected type as input
15:50:03 <pgiarrusso> that’s called “bidirectional typechecking”, and AFAIK the 2007 paper I linked uses it in some cases
15:51:35 <pgiarrusso> Hindley-Milner instead is not bidirectional (you could call it “monodirectional”) — you take expressions and typing contexts as input, and output a type and some unification constraints to solve later — or in some variants you solve them immediately
15:55:25 <mlugg> pgiarrusso: okay, that makes sense. So that's one possible algorithm, but there are cleverer ways (I have seen the words bidirectional typechecking around, just had no clue what it meant) that more directly use expected types, e.g. those given through type annotations?
15:58:47 <pgiarrusso> mlugg: “take expected types as inputs” is the general idea — and those types come from type annotations but not only
15:59:15 <mlugg> where else would they come from? stuff in recursive calls I'm guessing?
15:59:25 <pgiarrusso> after defining top-level function foo, foo’s type can be used when typing the lambda in `foo (\x → t)`
16:00:17 <pgiarrusso> here’s a tutorial http://davidchristiansen.dk/tutorials/bidirectional.pdf and here’s a more advanced paper on a fancy variant https://www.cl.cam.ac.uk/~nk480/bidir.pdf
16:00:50 <pgiarrusso> (the latter is _not_ what Haskell does, just an important example)
16:01:00 <pgiarrusso> (example of bidi. typechecking
16:06:42 <koz_> Suppose I have 'data Foo = Bar Int String', and 'baz = Bar 10 "quux"'. What are the names for '10' and "quux" in this case? Data elements?
16:06:49 <koz_> Data members?
16:06:53 <koz_> Something else?
16:07:58 <monochrom> I use "field values" very informally.
16:08:11 <koz_> monochrom: I guess 'field values' is as good a name as any other.
16:08:22 <koz_> Just wondering if there was a mandated/common name.
16:10:04 <monochrom> The Haskell Report uses "components" informally.
16:10:15 <koz_> I think I can go with that then.
16:10:34 <monochrom> I don't use it because too many things are called components.
16:14:30 <mlugg> pgiarrusso, does "monodirectional" checking have to annotate the type of every sub-expression, or only the top level?
16:16:57 <pgiarrusso> the only “monodirectional” algorithm I know well is Hindley-Milner — in fact, to be clear, “monodirectional” isn’t a standard term
16:17:50 <pgiarrusso> mlugg: and “the type of every subexpression” is unrealistically heavy and unnecessary.
16:18:11 <mlugg> Yeah, I assumed so
16:18:22 <mlugg> Okay, looks like I've got some reading to do :p
16:18:26 <mlugg> Thanks for all the help!
16:18:34 <pgiarrusso> For system F, in the worst-case, you need 2 things:
16:18:37 <pgiarrusso> - type arguments
16:18:51 <pgiarrusso> - type annotations for arguments of lambdas
16:19:01 <pgiarrusso> - make type abstractions and applications explicit
16:27:45 * hackage zeolite-lang 0.1.2.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.0 (ta0kira)
16:28:05 * ski would probably say "component", or maybe "constructor argument"
16:34:46 <koz_> Also, does someone have a good descriptive link for property-based testing?
16:34:50 <koz_> (like, saying what it is)
16:43:45 * hackage discord-haskell 1.5.2 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.5.2 (Aquarial)
16:45:31 <lyxia> koz_: if it's for a citation there's the original QuickCheck paper
16:46:12 <justsomeguy> The paper is here, by the way. https://github.com/pushcx/hpffp-resources/tree/master/Chapter%2014 The link on QuickChecks official website is broken, and points to a postscript document.
16:47:51 <lyxia> It's on ACM's site too https://dl.acm.org/doi/abs/10.1145/1988042.1988046
16:49:49 <koz_> lyxia: Thanks, that's ideal.
17:03:54 <justsomeguy> Are you writing a paper, koz_? What about?
17:04:09 <koz_> justsomeguy: Nope. It's an internal document to justify various decisions.
17:04:21 * koz_ has written papers before, but never got any publications, sigh.
17:04:22 <justsomeguy> Ah, those sound harder.
17:04:28 <koz_> justsomeguy: Yes, they are.
17:58:44 * hackage zeolite-lang 0.1.2.1 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.1 (ta0kira)
18:51:45 * hackage zeolite-lang 0.1.2.2 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.2 (ta0kira)
19:18:47 <dsal> My brain does not enjoy implementing unliftio for some reason.
19:23:15 <wroathe> dsal: Why are you implementing something that already exists? Just learning?
19:23:33 <dsal> I need to provide an instance for my type.
19:24:01 <wroathe> dsal: Ah, an instance.
19:24:01 <dsal> It won't derive for a dumb reason so I'm just trying to tell it what I want.
19:31:39 <koz_> dsal: What dumb reason?
19:32:55 <dsal> It complains that it can't assume the role of my contained monad for coercion.
19:33:27 <koz_> Ah, _that_ problem.
19:33:48 <koz_> What's your stack?
19:35:44 <dsal> newtype Car m a = Car { runCarM :: ReaderT CarEnv m a }   -- It's complaining abou tm.
19:36:12 <koz_> What derivation? Are you like, doing 'deriving newtype ..' or something?
19:37:15 <dsal> Just doing normal deriving.
19:37:55 <koz_> dsal: Have you tried a standalone specifying that MonadIO m?
19:38:08 <koz_> (ideally specifying a newtype derivation explicitly?)
19:38:13 * dsal forgot how to use StandaloneDeriving
19:38:29 <koz_> I have to look it up all the itme as well.
19:38:45 <dsal> Yeah, it's complaining about the role of m.  I'll see if I can hack that up with a role annotation and StandaloneDeriving
19:39:16 <dsal> My internet connection is not cooperating.
19:40:07 <koz_> It's rocking the table while you're operating!
19:41:16 <dsal> Weird.  I got the same error.
19:41:19 <dsal> haha
19:41:22 <koz_> Can you paste me?
19:42:18 <dsal> so, this is github.com/dustin/tesla -- Car.hs.
19:42:26 <dsal> https://www.irccloud.com/pastebin/SjByoSnQ/errors
19:42:36 <koz_> Ah, this is the infamous Car monad.
19:42:38 <dsal> That's with StandaloneDeriving and an explicit role
19:42:46 <koz_> So now it's a Car transformer.
19:42:51 <koz_> (a CarT?)
19:43:42 <dsal> ha.  It's https://github.com/dustin/tesla/blob/master/src/Tesla/Car.hs#L80  <-  I just want MonadUnliftIO there, but it's playing hard to get.
19:44:49 <koz_> Hmm. You could try a via (ReaderT CarEnv m)?
19:45:03 <dsal> I don't know that one.  This is a good chance to learn, I suppose.  :)
19:45:36 <koz_> I dunno if it'll work, but I think it ought to, especially if you standalone derive it and specify the same constraints the ReaderT instance of MonadUnliftIO requires.
19:51:39 <dsal> standalone deriving via is like standalone deriving, but in a most confusing way.
19:51:54 <koz_> Yeah, it threw me something awful when I first tried it.
19:52:35 <dsal> What even is the form?
19:52:44 <koz_> dsal: Clearly this: https://i.imgflip.com/3ynpzc.jpg
19:52:48 <koz_> (more serious answer incoming)
19:53:17 <koz_> https://stackoverflow.com/a/53404233/2629787
19:53:26 <dsal> Heh, I have that up.
19:53:47 <koz_> deriving via (ThingIAmStealingFrom) instance (PrerequisiteTypeClass a) => InstanceTypeClass a
19:54:31 <koz_> I should prod Uniaika with this as an example of 'plz make documentation friendlier'. :P
19:54:54 <dsal> I think I got it right because it gave me the representation error again.
19:55:03 <koz_> So how did you spell it?
19:55:23 <dsal> deriving via (ReaderT CarEnv m) instance MonadUnliftIO m => MonadUnliftIO (Car m)
19:55:40 <koz_> Got the role annot on Car?
19:55:42 <dsal> Which you could also see here, I guess:  https://www.irccloud.com/pastebin/R8LoDlp1/error
19:56:05 <dsal> Yeah, type role Car representational nominal
19:56:13 <koz_> Yeah, I guess there's no escaping this one.
19:56:24 <dsal> I guess things aren't happening at the right time.
19:56:51 <dsal> At least I kind of understand DerivingVia a little more.  I've been wondering about thta.
19:57:03 <koz_> I suspect that rank > 1 thingo going on in withRunInIO is causing issues.
19:57:26 <dsal> Yeah.  This feels like one of those fairly simple problems that always trips me up.
19:57:35 <koz_> Oh, this is far from simple lol.
19:57:41 <koz_> Your target type is something like
19:57:57 <koz_> ((forall a. Car m a -> IO a) -> IO b) -> m b
19:58:05 <koz_> And the only thing you have at your disposal is the equivalent of
19:58:19 <koz_> ((forall a . ReaderT m a -> IO a) -> IO b) -> m b
19:58:42 <koz_> So there's gonna be a _lot_ of continuation-related mind-bending involved.
20:01:20 <dsal> Yeah.  I've got something really close.  But like, crypto close.
20:01:36 <koz_> I'm afraid I'm not good at continuation mind-bending.
20:01:49 <koz_> I only wrote ContT's Functor instance with _substantial_ amounts of assistance.
20:14:10 <dsal> I have something that typechecks, but I'm curious how it could work...
20:15:25 <chew2> dsal: what is it?
20:15:30 <dsal> I'll try it.  There are only two possibilities here.
20:15:55 <chew2> I just joined and probably missed what you were talking about lol
20:16:13 <dsal> I'm trying to implement a MonadUnliftIO instance for my thing./
20:17:07 <dsal> It seems to work.
20:17:18 <dsal> I just did hole-oriented programming and the right thing happened.
20:18:13 <solonarv> dsal: try this: deriving newtype instance (MonadUnliftIO m, forall a a'. Coercible a a' => Coercible (m a) (m a')) => MonadUnliftIO (CarT m)
20:18:25 <chew2> yeah I haven't written things that way very often but when I do it makes me question how much I really understood
20:18:58 <solonarv> the trick is that this instance can only be derived when 'type role m representational' or 'type role m phantom', which is that that quantified constraint expresses
20:19:14 <dsal> `instance MonadUnliftIO m => MonadUnliftIO (Car m) where withRunInIO inner = Car $ withRunInIO $ \run -> inner (run . runCarM . id)` <-- That works
20:19:54 <dsal> solonarv: What's `newtype` there?
20:19:57 <solonarv> what's that '. id' for?
20:20:04 <solonarv> dsal: 'newtype' is the deriving strategy
20:20:14 <dsal> _ said to put . id there.  :/
20:20:25 <solonarv> how odd
20:20:26 <chew2> does it not work without?
20:20:30 <solonarv> does it still work if you remove it?
20:20:42 <chew2> what's the type of id in that context otherwise?
20:20:43 <dsal> Oh.  Yeah, OK.  I see what I did.  heh
20:20:51 <dsal> I was doing `. _`
20:20:58 <solonarv> aha :D
20:21:08 <dsal> That makes a little more sense.
20:21:31 <solonarv> can you indulge me and try my magic instance?
20:21:36 <dsal> trying
20:21:57 <remexre> is there a (good) way to print a table with wl-pprint/prettyprinter/etc's combinators?
20:22:22 <dsal> I figured I had a 50% chance of getting the Coercible import wrong.
20:22:38 <solonarv> oh yeah I get that wrong all the time too
20:22:49 <solonarv> is it Data.Coerce or Data.Coercible ? who knows!
20:23:18 <dsal> Your thing also seems to work.
20:23:22 <dsal> (where work == compilel)
20:23:25 <dsal> wait, no, it fails later.
20:23:27 <solonarv> \o/
20:23:54 <solonarv> huh? oh, that quantified constraint on 'm' probably ends up propagating all over the place
20:24:05 <solonarv> that's unfortunate, I hadn't thought of that
20:24:17 <dsal> The library compiles, but the usage fails. heh
20:24:36 <solonarv> is the usage polymorphic over 'm' ?
20:24:47 <ski> @type Control.Monad.IO.Unlift.withRunInIO
20:24:49 <lambdabot> Control.Monad.IO.Unlift.MonadUnliftIO m => ((forall a. m a -> IO a) -> IO b) -> m b
20:26:09 <ski> dsal : that instance looks right
20:26:40 <dsal> ski: Thanks.  It appears to work as well.  I don't know why this kind of thing seems so hard.
20:26:47 <dsal> (especially when I'm done).
20:27:09 <dsal> I've done this three or four times now and each time it's hard until it's done and there's not enough stuff left to be confused about.
20:31:51 <solonarv> I'm pushing through a different sort of pain ATM
20:31:59 <solonarv> trying to use OpenGL
20:33:33 <ski>   ((forall a. Car            m a -> IO a) -> IO b) -> Car            m b
20:33:36 <ski>            ↓  ↓                     ↑        ↓        ↑
20:33:39 <ski>   ((forall a. ReaderT CarEnv m a -> IO a) -> IO b) -> ReaderT CarEnv m b
20:34:04 <ski> dsal : ^ displays direction of flow of information
20:34:52 <ski> (between the "outer" and the "inner" `withRunInIO', the outer being implemented in terms of the inner)
20:39:46 * ski . o O ( `withRunInIO ={((forall a. ⌞runCarM⌟ -> IO a) -> IO b) -> ⌞Car⌟}= withRunInIO' )
20:40:05 <dsal> ski: 75% of my problem is "I don't actually want to understand this, I just want it to compile"
20:40:30 <dsal> Understanding generally saves time, but this was a bit of a yak shave.
20:40:30 <solonarv> type tetris / fill-in-the-holes works reasonably well for that
20:40:51 <dsal> Yeah, I even tried avoiding that for a while. Heh
20:41:12 <dsal> I waste a lot of time trying to take shortcuts.
20:43:10 <ski> @quote follow.the.types
20:43:11 <lambdabot> NeilDeGrasseTypson says: "Follow the types, wherever they lead you."
20:43:34 * ski . o O ( "Follow the Types where they Lead. / Follow the Types where they Lead. / Follow, follow, follow, follow, / Follow the Types where they Lead." )
20:56:54 <koz_> solonarv: Why OpenGL and not Vulkan?
21:07:29 <koz_> Also, for a function like withFile (as per here: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:withFile), what's stopping someone 'clever' from passing 'pure' for its function argument to get out a Handle which already got closed?
21:07:47 <dmwit> Nothing but social contract.
21:08:17 <koz_> dmwit: Yeah, I thought as much. It doesn't have the 'defense mechanism' that runST uses.
21:08:18 <dmwit> The documentation says not to do that, and the type system doesn't help.
21:08:34 <dmwit> You could imagine doing an ST-style thing, but I think the thought is that this is going to be too painful.
21:08:54 <koz_> dmwit: What would that (conceptually) look like?
21:09:03 <koz_> Considering you can't redefine Handle. Or IO.
21:09:06 <dmwit> newtype Handle' s = Handle' Handle
21:09:17 <dmwit> and a whole new API that accepts Handle''s instead of Handle's
21:09:39 <dmwit> And then `withFile :: FilePath -> IOMode -> (forall s. Handle s -> IO r) -> IO r`
21:09:45 <dmwit> err
21:09:47 <koz_> Ah, I see.
21:09:51 <dmwit> Handle', of course
21:09:54 <koz_> Makes sense.
21:10:11 <koz_> So basically, we gotta tag the 'input' thing with a runST-style token?
21:10:50 <dmwit> I think yes?
21:10:57 <koz_> OK, thanks.
21:11:05 <koz_> I can kinda see why that would be annoying af.
21:47:09 <sheepfleece> Hello, how can I make a type-level set? I need this property to hold for arbitrary types '[ a, b ] == '[ b, a ]
21:47:17 <sheepfleece> The problem with type lists is that compiler might infer types in different order compared to provided type signature. 
21:47:36 <sheepfleece> And it would result in a type error, which is unfortunate.
21:47:59 <iqubic> Perhaps this package will help you: https://hackage.haskell.org/package/type-level-sets
21:48:37 <sheepfleece> I saw it, but it asks you to define ordering, which I can't. Or maybe I missed something I'll check one more time.
21:48:51 <iqubic> Why can't you define an ordering?
21:49:08 <sheepfleece> It can be anything of kind `Type`.
21:49:47 <iqubic> What are you trying to do specifically? What do you need a type level set for?
21:50:32 <sheepfleece> Well, I wrote a small library, checked-exceptions, which uses something similar to indexed monads to force you to catch all exceptions you throw.
21:51:23 <sheepfleece> It works, but it's annoying to deal with the order in which I add exceptions to a type level list.
21:51:29 <iqubic> Right.
21:51:50 <Axman6> I wonder if you could use something super hacky to define an ordering over all types, using the custom type errors stuff - all you need is ord a b = ord (ShowType a) (ShowType b)
21:51:53 <iqubic> What is the kind of the elements you are putting into this type level list?
21:52:42 <sheepfleece> Anything of a kind `Type` could go in there, but in general those all also have Exception e constraint.
21:53:03 <iqubic> sheepfleece: I think you only need to define an ordering if you are using the type level maps, and not for the type level sets.
21:53:48 <sheepfleece> I think you can compare `KnownSymbols` but then the question is how can I convert `Type` to it.
21:54:42 <iqubic> Looks like there isn't a good way of doing that.
21:55:22 <iqubic> @hoogle Type -> KnownSymbol
21:55:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:55:23 <lambdabot> GHC.Exts unsafeCoerce# :: () => a -> b
21:55:23 <lambdabot> GHC.Prim unsafeCoerce# :: a -> b
21:57:10 <d34df00d> "The compiler's way of saying `you messed up`"
22:01:04 <sheepfleece> I can force an ordering by defining a type level list of tuples '(Type, Bool) and then simply flipping a flag to `True` when an exception is presented.
22:01:30 <sheepfleece> But it would complicate already shaky interface and errors should also become horrendous.
22:19:39 <sheepfleece> I think I've done something I shouldn't have, but it doesn't work so whatever https://paste.debian.net/1143663/
22:19:56 <isovector1> how does new code make it into the base package?
22:20:07 <isovector1> do you just send a PR somewhere? or write an email on the mailing list? or what?
22:23:08 <Desmond373> you would likely need to be well recieved on package managers first and then you could write a proposal to add it to Prelude
22:23:31 <Desmond373> thats generally what happens in free software
22:25:28 <iqubic> sheepfleece: Just saying, "it doesn't work" isn't very useful at all. If you want help then you need to give us relevent information; What exactly isn't working? Are you getting compiler errors? If so, can you show those to use.
22:25:46 <sheepfleece> I need an actual type level `unsafeCoerce` and not this `Any` imposter
22:26:30 <sheepfleece> Here is an error. https://paste.debian.net/1143664/
22:26:47 <sheepfleece> I wanted to see one of my custom errors instead. 
22:27:14 <sheepfleece> Also `:kind!` does not work either.
22:27:20 <iqubic> How are you running your code?
22:27:29 <iqubic> are you using ghci?
22:27:32 <sheepfleece> Yes.
22:27:51 <iqubic> Alright, what did you tell ghci to do?
22:28:21 <sheepfleece> `fun`. Which is here https://paste.debian.net/1143663/
22:29:08 <iqubic> Does your code actually compile?
22:29:22 <sheepfleece> Yes, why shouldn't it though?
22:29:49 <sheepfleece> Oh, yes, it shouldn't compile too, it should show a custom error message.
22:30:51 <iqubic> Yes. If you are using TypeError, then it shouldn't compile at all.
22:31:45 <iqubic> I'm not sure what's going on here, and I'm not clever enough to help you sorry.
22:32:18 <sheepfleece> It's fine. Thank you!
22:33:13 <iqubic> What imports do you have in that file?
22:33:50 <sheepfleece> GHC.Exts, GHC.TypeLits and Data.Kind
22:35:45 * hackage dialogflow-fulfillment 0.1.1.0 - A Dialogflow Fulfillment library for Haskell.  https://hackage.haskell.org/package/dialogflow-fulfillment-0.1.1.0 (mauriciofierrom)
22:37:22 <iqubic> Weird. I have no idea why that compiles.
22:38:06 <EvanR> doesn't undefined satisfy any type
22:38:48 <iqubic> Oh, yeah. It does.
22:39:54 <sheepfleece> But it shouldn't really matter, typefamilies with any do not reduce. Which is reasonable.
22:40:01 <sheepfleece> *`Any`
22:41:59 <sheepfleece> Though I now found this, which is even more than I wanted. https://gitlab.haskell.org/ghc/ghc/issues/10886#note_107029
22:44:54 <EvanR> this poem is awesome
22:46:50 <iqubic> I wish Standalone Kind Signatures were a thing already.
22:48:27 <iqubic> I want GHC 8.10.x to release.
22:49:04 <koz_> iqubic: ...
22:49:10 <koz_> It's been released for quite some time.
22:49:16 <iqubic> Turns out I'm behind the curve.
23:49:45 * hackage tesla 0.2.0.0 - Tesla API client.  https://hackage.haskell.org/package/tesla-0.2.0.0 (dustin)
23:50:11 <flux77> Why do people bother with Haskell if every line of code requires you to think so hard?
23:50:25 <koz_> flux77: Because in most cases, it actually doesn't.
23:50:40 <koz_> The compiler helps you a damn sight more in Haskell than in basically any other language to write your code.
23:51:21 <flux77> koz_: Haskell looks like the kind of language where one has to think more than one types.
23:51:35 <flux77> Like Prolog or SQL.
23:51:39 <EvanR> it's worse, when you return to seat-of-your pants languages, every line of code will require you to think very hard
23:51:42 <koz_> flux77: And you base this reasoned assessment on? 
23:51:52 <dsal> Thinking more than typing is a good idea in general.
23:51:53 <koz_> Prolog and SQL don't actually resemble Haskell all that much.
23:51:54 <dibblego> guys, pack it up, we have been busted
23:52:15 <koz_> dibblego: Yes, we are chronically lazy non-thinkers about our code.
23:52:21 <koz_> Because I'd rather GHC did it for me. :P
23:53:07 <flux77> koz_: I'm just an amateur. It's just my opinion. Just wondering if others feel the same. Apparently not. :)
23:53:22 <dsal> Haskell is consistently the easiest language I work in.
23:53:26 <koz_> flux77: We gathered as much. :P
23:53:33 <dsal> Even though I do get caught up in a few dumb things now and then.
23:53:36 <juri_> flux77: it makes you think about problems, not your code. subtle difference. :)
23:53:40 <koz_> dsal: Agreed, on _both_ counts.
23:53:58 <dramforever> flux77: Maybe because you are familiar with what you already know?
23:54:03 <dramforever> And not familiar with Haskell
23:54:04 <flux77> koz_: Prolog and SQL aren't similar to Haskell in terms of syntax, but they do make you think more about the problem than the code.
23:54:07 <EvanR> when you get used to programs working so well because the abstract pegs fit exactly in their holes, you realize how difficult it is to pull off without compiler helping you
23:54:32 <EvanR> and thinking greatly increases
23:54:52 <koz_> flux77: I wasn't referring to syntax, but sure, I can sorta see your logic there.
23:55:08 <koz_> Frankly, I just miss traverse in every other language.
23:55:28 <dsal> erlang looks a bit like prolog.  And speaking of weird, erlang ends sentences with periods...
23:55:28 <koz_> traverse truly does solve everything.
23:55:45 <iqubic> :t traverse
23:55:47 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:55:48 <koz_> dsal: There was a cute trend at one time of making proglangs look like natlangs.
23:55:55 <koz_> SQL is more or less its culmination.
23:56:01 <iqubic> Traverse is excellent. I love it so much.
23:56:03 <koz_> Thankfully, this is no longer considered a positive.
23:56:05 <dsal> I wrote applescript a couple of times.
23:56:15 <dsal> read-only language
23:56:18 <EvanR> i thought the culmination of that was intercal
23:56:19 <dramforever> flux77: Like, you don't really 'need' Haskell, but I hope you can agree that learning new things is not as easy as doing what you already know
23:56:20 <flux77> I use OCaml. What is a good way to get into Haskell?
23:56:33 <koz_> EvanR: I don't consider trolling a proglang. :P
23:56:46 <koz_> flux77: If you want a textbook, everyone sings the praises of Hutton.
23:56:47 <Axman6> flux77: I see having to think about code before writing it as a massive win, and luckily Haskell is two languages in one, and the second one, the type system, gives us a way to think very precisely about programs. It means a lot of silly mistakes get caught in your head before you even write a single character
23:56:50 <juri_> flux77: I have a pile of ocaml i need converted to haskell.. :)
23:56:55 <dsal> I used to program in ocaml years ago.  It's pretty weird.
23:57:15 <dramforever> You use OCaml? That sounds great. Welcome to the bright side
23:57:15 <flux77> dsal: I like the compiler errors.
23:57:54 <flux77> koz_: I've actually read 80% of Hutton. Anything else I should look at?
23:58:10 <dsal> It's been so long since I've written any ocaml that I don't even remember what the compiler looks like.
23:58:21 <koz_> flux77: If you've read (and understood) 80% of Hutton, you probably want something a bit more specific. Is there an area or a thing you wanna know more about?
23:58:22 <suppi> flux77, consider trying my haskell-study-plan https://github.com/soupi/haskell-study-plan/ and also cs240h www.scs.stanford.edu/16wi-cs240h/
23:58:25 <dibblego> flux77: solve these problems: https://github.com/system-f/fp-course
23:59:01 <Axman6> the System-F FP course is the best FP course
23:59:09 <Axman6> You heard it here first folks
