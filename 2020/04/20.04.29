00:00:07 <flux77> koz_: Practical applications. I'm currently learning theory too, but in other languages. If Haskell has practical applications, it might be a gigantic motivation for me to learn it more deeply in the future.
00:00:15 <dsal> koz_: I need to traverse harder.  I don't solve too much stuff with it.
00:00:16 <dramforever> flux77: I wonder if you are still thinking about the 'every line of code requires you to think so hard' thing
00:00:33 <dsal> flux77: I only work on practical applications.
00:00:35 <koz_> flux77: 'Practical applications' is too broad to be a useful filtering criterion.
00:00:41 <dsal> (For some version of practical)
00:00:42 <koz_> Can you give me a domain? Or a task? Or something?
00:00:55 <koz_> dsal: It's very cute how well it fits into a lot of places.
00:00:55 <flux77> koz_: Command line tools, web apps.
00:01:03 <koz_> flux77: Web apps you're spoiled for choice.
00:01:10 <dsal> The thing I just pushed is a commandline tool *and* web app.
00:01:13 <koz_> There's a _lot_ of web stuff in Haskell I am informed is very good.
00:01:18 <koz_> (I wouldn't know)
00:01:21 <Axman6> flux77: I've been paid to write practical application for about 5 years now
00:01:27 <koz_> (I have made a conscious choice to remain as ignorant of web anything as possible)
00:01:32 <koz_> (in every language)
00:01:55 <koz_> flux77: While not as cool as Axman6, I too get paid actual dollars to write Haskell, and have been for nearly 3 months now.
00:01:55 <dsal> When I got MonadLogger duplicating structured messages to the browser via websocket, that was pretty neat.
00:02:07 <flux77> If I have already understood most of Hutton, will I be able to start doing practical things?
00:02:11 <Axman6> Haskell, and in particular the servant ecosystem, makes writing web APIs an absolute dream
00:02:19 <koz_> flux77: Depends on what you mean by 'practical'. And 'things'.
00:02:26 * Axman6 highfives koz_
00:02:33 * koz_ high-fives back.
00:02:35 <suppi> flux77, I wrote this blog post yesterday, I think it might answer your question https://gilmi.me/blog/post/2020/04/28/consider-haskell
00:02:47 <Axman6> been meaning to read that
00:03:05 <flux77> koz_: Like web apps.
00:03:05 <dramforever> flux77: Please pardon my way of putting it, but every time I hear 'practical things' it's an excuse of avoiding something new
00:03:12 <dramforever> Sure can do
00:03:13 * Axman6 highfives suppi for contributing relevant content to the community, what a champ
00:03:20 <dsal> suppi: Oh, I saw that today.  I was offended by your date format.  :p
00:03:31 <suppi> thanks friend
00:03:46 <koz_> dramforever: Every time I hear a 'practical things'-style line, I want to shoot something.
00:03:48 <suppi> dsal don't be offended you know it makes sense
00:03:58 <dsal> suppi: (that's my only feedback, otherwise seemed fine)
00:04:04 <koz_> dsal: Was it month-day-year or something?
00:04:08 <dramforever> You say: 
00:04:13 <dramforever> 'I want to do practical things'
00:04:15 <suppi> koz_ no @_@
00:04:18 <dsal> Yeah, completely backwards.
00:04:37 <dsal> oh, day month year.  I don't know.  Little endian, I guess.
00:04:40 <flux77> If I am interested in compiler construction, where should I look?
00:04:41 <suppi> what? it's year-month-day in the url and day-month-year in the post
00:04:54 <koz_> flux77: Someone did a whole 'write a Scheme in Haskell' thingo.
00:04:57 <koz_> I forget the link.
00:05:07 <flux77> I finished that book.
00:05:09 <dramforever> (cont'd) You actually mean: 'I don't want to learn this new thing'
00:05:13 <suppi> flux77, I wrote this slides a while ago https://github.com/soupi/rfc/blob/master/compilers-and-haskell.md
00:05:17 <suppi> I'm on fire today
00:05:19 <koz_> flux77: So you wrote a Scheme in Haskell?
00:05:23 <flux77> Yes
00:05:30 <Axman6> dramforever: what planet do you live on with 28 months? :P
00:05:35 <Axman6> uh, dsal
00:05:36 <flux77> I need something more than that.
00:05:36 <koz_> suppi: I guess you put 'aggressive' in 'aggressive self-promotion'. :P
00:05:57 <koz_> flux77: More as in? You wanna write an optimizing compiler? That's not a Haskell-specific problem.
00:06:00 <dsal> Axman6: I forgot how time works.  It's been a rough couple months.
00:06:09 <Axman6> fair
00:06:10 <koz_> You wanna know about some libraries useful for compiler-writing? There's a few I can suggest.
00:06:11 <suppi> koz_ I really don't mean to lol, but I feel like I have relevant answers to the questions
00:06:13 <koz_> Along with some others.
00:06:26 <dramforever> The easiest way is probably just do whatever a compiler textbook would say, but in Haskell
00:06:34 <koz_> suppi: It's all good. Aggressive self-promotions is a-OK by me. I'm just in a silly mood.
00:06:44 <dsal> flux77: Just make the thing you want.  Sometimes I start a project just by writing a thing in a language I want to express, then build a thing to parse that language and do the things I want.
00:07:00 <dsal> You don't need anyone's permission.
00:07:10 <dsal> At least, I assume not, or I'm in a lot of trouble.
00:07:23 <suppi> Yeah I know. I really don't want to come out as aggressive self-promoter though. I'll shut up now.
00:07:26 <koz_> dsal: SM Haskell. :P
00:07:37 <koz_> suppi: It's totally fine. Don't let me discourage you.
00:07:46 <koz_> Aggressive self-promotion is how I learn about cool new things.
00:08:03 <flux77> Okay. Thank you for the advice. Sorry about the "practical things" part. I was just trying to figure out whether or not I could fit Haskell into my existing "practical" work.
00:08:15 <koz_> dsal: (or should that have been BDSML? :P)
00:08:19 <dsal> haha
00:08:27 <Axman6> ;)
00:09:00 <koz_> inb4 someone actually wrote a language with that acronym.
00:09:09 <dsal> flux77: haskell is the first tool I reach for when building anything of interest.  It's generally pretty easy and productive.  And when I mess up, I can make large changes easily.  But you shouldn't expect to find a lot of haskell haters here.
00:09:19 <koz_> flux77: What _is_ your existing "practical" work?
00:09:46 <Axman6> isovector1: did you get an answer to you base PR question?
00:10:12 <dramforever> dsal: having deja vu on IRC, eh?
00:11:10 <Axman6> "Compilers" and "practical" rarely go into the same sentense in my experience :P
00:11:18 <Axman6> luckily Haskell is excellent for both
00:11:26 <flux77> koz_: Web applications. As opposed to other things I do purely for interest e.g. compilers.
00:11:28 <Axman6> but takes time to learn
00:11:35 <dsal> dramforever: Actually, kind of.  I should be asleep instead of arguing that the things I do in haskell aren't possible in haskell.
00:12:00 <dramforever> But in the days in between I worked on a toy compiler. Many big changes (like, changes straight to core types)
00:12:03 <Axman6> flux77: what do you want these web applications to go?
00:12:07 <Axman6> do*
00:12:09 <koz_> flux77: Someone mentioned servant. I hear it is good.
00:12:18 <dsal> flux77: the elm compiler is written in haskell, so you can do both at the same time.
00:12:24 <dramforever> Every one of them is like, I change a type, and fix all the type errors by replacing the parts that no longer fit
00:12:27 <koz_> Considering how many folks get paid to write web stuff in Haskell, I imagine there's plenty more where that came from.
00:12:52 <mpiechotka> Hi. I have problem with building - when I run cabal build it succeeds but when I run cabal install it tries to rebuild in /tmp and fails.
00:13:12 <mpiechotka> Is it possible to just install what I built?
00:13:22 <Axman6> dsal: such productivity
00:13:52 <dsal> I need to go to bed.  Most of my "programming" tonight was yaml github actions stuff.  Change yaml.  Push.  Wait, get dumb runtime failure.  Repeat.
00:14:15 <koz_> mpiechotka: Are you on an old cabal version or something?
00:14:22 <timCF> Hi guys! Any Lens package users there? Need help with this https://gist.github.com/tim2CF/8688bff51440a8ce667ec395d2ba6039
00:14:41 <Axman6> <3 lens
00:14:43 <mpiechotka> koz_: No. But I have the Arch no-static libraries thingy
00:15:07 <koz_> mpiechotka: Are you building stuff gainst Arch's dynamic libs Haskell?
00:15:10 <koz_> Yeah... not advised.
00:15:35 <koz_> Axman6: As we know, the 'L' in APL stands for 'lens', amirite?
00:15:38 <Axman6> timCF: x ?^ foo . _Just . bar . _Just . buz
00:15:44 <dsal> timCF: _Just is a prism for Maybe
00:15:53 <Axman6> koz_: yes
00:16:06 <Axman6> but unironically
00:16:08 <mpiechotka> koz_: Yeah. The problem is that Agda is not stackized
00:16:21 <Axman6> uh, that should be ^? not ?^
00:16:47 <dsal> ...but protolens should give you `foo . bar` or something -- the `maybe'` shouldn't be necessary.
00:16:55 <koz_> mpiechotka: I'm pretty sure if you used cabal new-install it'd work.
00:16:56 <dsal> But also, I've not worked on protolens in a few weeks.
00:17:00 <koz_> (as I did it in very recent memory)
00:17:03 <dsal> (and I should be asleep)
00:17:08 <koz_> This is why I asked if you were on old cabal.
00:17:25 <mpiechotka> koz_:  I am using cabal new-install
00:17:48 <koz_> mpiechotka: OK, and you're saying it fails to build. What's the error?
00:17:53 <MarcelineVQ> stackized?
00:18:09 <koz_> MarcelineVQ: Builds with that tool a lot of people love to hate named after a linear data structure.
00:18:12 <timCF> dsal Axman6 thanks!
00:18:17 <Axman6> MarcelineVQ: stackled in Brittish English
00:18:24 * dramforever should abandon stack one day
00:18:44 <dramforever> for my uses it not like it's super
00:18:52 <timCF> dsal but what is the purpose of `maybe'*` accessors? ProtoLens provides them for some reason
00:18:53 <dramforever> beneficial anymore
00:18:54 <dsal> timCF: Or something like     `accessBuf = preview (foo . bar . buz)` 
00:19:15 <dsal> timCF: I've used them when constructing values when I want to specify Nothing conditionally, I think.
00:19:24 * dsal pulls up code instead of sleeping
00:19:38 <koz_> dsal: Future you won't be happy with current you.
00:19:41 <dramforever> given that now we have cabal v2-*
00:20:16 <dsal> koz_: "When people tell me I'll regret that in the morning, I sleep 'til noon."
00:20:26 <koz_> dsal: Technicality at its finest.
00:21:11 <mpiechotka> koz_: NM. It's agda error
00:21:12 <Axman6> I shall regret that at the time of my own choosing thankyou very much
00:21:17 <MarcelineVQ> mpiechotka: newer  cabal install  makes an sdist and installs from that, so no afaik, without copying bins yourself it's going to go through /tmp to unpack the sdist. Make sure your /tmp isn't full, which happens t me all the time
00:21:37 <dsal> timCF: yeah, I without the `maybe'` you get a `Just`.  So I only use the `maybe'` types during a `set` when I might want a `Nothing`
00:21:41 <koz_> MarcelineVQ: More common on Arch because it stuffs tmpfs into RAM by default.
00:21:47 <MarcelineVQ> mpiechotka: what does stackized mean? if it means buildable with stack, adga is buildable with stack
00:21:51 <koz_> Caught me out once or twice doing AUR builds of something like LLVM.
00:21:55 <mpiechotka> MarcelineVQ: That's really annoying... It takes a long time to do it
00:22:01 <mpiechotka> MarcelineVQ: How to do it?
00:22:11 <mpiechotka> stack init doesn't work
00:22:25 * mpiechotka wishes things would just work...
00:22:29 <dsal> timCF: So, I'd expect you could just write the thing I did above:   `accessBuf = preview (foo . bar . buz)`
00:22:35 <MarcelineVQ> stack init where?
00:22:48 <MarcelineVQ> well regarldess, no stack init is not the proper way to go
00:24:27 <srk> mpiechotka: I've managed to build agda and agda-mode with Nix recently 
00:25:00 <srk> had to use git checkout and disable tests tho
00:25:40 <mpiechotka> MacelineVQ: Ok. Figured it out (stack install --stack-yaml stack-8.4.4.yaml)
00:25:45 <MarcelineVQ> mpiechotka: looing at the Makefile you should be able to rename one of the stack-*.yaml files to stack.yaml and just run  make install
00:26:26 <MarcelineVQ> depending on how you're getting agda in the first place I suppose, I'd be looking here https://github.com/agda/agda
00:26:27 <mpiechotka> Sorry 8.8.3 - was looking at agda-stdlib
00:27:06 <MarcelineVQ> There's also an agda bin on pacman fwiw
00:27:29 <mpiechotka> MarcelineVQ: That one doesn't work currently
00:27:44 <mpiechotka> It tries to create directory in /usr as user
00:27:59 <mpiechotka> (the pacman's one)
00:28:09 <timCF> dsal thanks, version with `preview` compiles, I hope it will work as expected, will test it. Oh my god, lens are so complicated for amateurs like me)
00:32:10 <dsal> timCF: protolens adds a bit of magic.  I had to work on the compiler to add even more magic for a project at work. :(
00:32:42 <dsal> timCF: but if your code compiles, it's definitely correct and you don't have to worry about it sooner m anymore.
00:33:24 * dsal stops autocorrecting into irc and sleeps
00:38:11 <sheepfleece> How can I load a test module with cabal? 
00:39:11 <Axman6> I don't know what that means
00:39:15 * hackage dom-events 0.0.0.1 - DOM Events expressed as Haskell types  https://hackage.haskell.org/package/dom-events-0.0.0.1 (mikesol)
00:39:47 <sheepfleece> Well, you can use `cabal repl` and load a library or executable module.
00:39:52 <koz_> As opposed to SUB events.
00:39:52 <sheepfleece> If it is exposed.
00:40:08 <sheepfleece> But you can't do the same thing with tests.
00:40:30 <dramforever> Try something like cabal repl test:test-name
00:40:37 <timCF> dsal actually preview version behaves differently, for `defMessage :: Foo` it returns `Just Buf`, but original version with bind returns `Nothing` 😐
00:40:41 <dramforever> where test-name is the name for the test suite
00:41:02 <maerwald> I wish I could move a branch pointer during interactive rebase
00:41:25 <Axman6> koz_: you seem fun. let's never meet
00:41:28 <Axman6> :P
00:41:43 <koz_> Axman6: My sense of humour is rather bad, I agree.
00:41:52 <dramforever> timCF: What's defMessage like?
00:41:53 <koz_> Never meeting me is probably the right call.
00:42:40 <timCF> it's from proto-lens package https://www.stackage.org/haddock/lts-15.10/proto-lens-0.6.0.0/Data-ProtoLens-Message.html#v:defMessage
00:42:52 <sheepfleece> dramforever: Huh, that's new https://paste.debian.net/1143677/
00:43:33 <timCF> dramforever similar to `Default` type class `def` function
00:44:37 <sheepfleece> Ah, it is just `cabal repl Simple`. Thank you!
00:44:41 <dramforever> uhh, that's going to be a bit hard for me since i don't know protobuf or protobuf-lens
00:45:37 <dramforever> sheepfleece: Yeah glad you got it. I use stack so I don't really know how that thing works, but I'm sure they are similar in this regard
00:47:13 <dramforever> timCF: Can you try getting all the intermediate steps?
00:47:47 <dramforever> Maybe foo isn't maybe'foo . _Just
00:51:31 <sheepfleece> Yay, the first approximation of my first library is ready! 
00:51:34 <sheepfleece> https://github.com/sheepfleece/checked-exceptions/blob/master/examples/Simple.hs
00:51:51 <sheepfleece> There are still lots of rough corners though.
00:53:42 <timCF> dramforever good point! With `maybe'* . _Just` it worked as I expected
00:59:45 <sheepfleece> (so how is it?)
01:06:04 <Axman6> sheepfleece: ages ago I wrote something similar: https://gist.github.com/axman6/19adc08a809d919a2efb
01:10:01 <sheepfleece> Looks similar! Have you tried to use it? 
01:10:16 <Axman6> nope, just a brainspurt of an idea
01:11:54 <sheepfleece> I have a simple project in the university so I would try to use mine there. 
01:12:36 <Axman6> It'll be interesting to see what you learn - my experience from writing that is that not  having type level sets made life painful
01:12:42 <sheepfleece> I wish there were a type level set though. It's a pain dealing with an explicit ordering.
01:12:47 <sheepfleece> Yeah :D
01:16:35 <Axman6> I have a feeling going the type class route gets you mich closer to type level sets - look at how polysemy manages effects, Member (State Foo) r => Sem r a
01:17:10 <Axman6> though, also do your university work if you should be doing that first :P
01:26:15 * hackage jvm-binary 0.9.0 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.9.0 (kalhauge)
01:31:15 * hackage haskoin-store 0.23.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.3 (jprupp)
01:52:18 <kaol> How low can Haskell go? Is 256MB enough memory to use it comfortably?
01:52:48 <phadej> compileer no. Programs, maybe.
01:52:50 <Axman6> to compile it, almost certainly no
01:53:24 <Lycurgus> maybe some ghcjs
01:53:49 <kaol> For running programs, no compiling.
01:54:08 <Axman6> for running programs it completely depends on the app
01:54:22 <Uniaika> kaol: you can restrict the amount of memory available to the RTS in ghci (and I thik also as an argument to the program)
01:54:31 <Uniaika> so you can check :)
01:54:42 <merijn> My data analysis stuff chews through several GB of data with a whopping ~5 MB residency ;)
01:54:51 <merijn> Conduit \o/
01:55:08 <Uniaika> merijn: nice 
01:55:30 <Axman6> yeah it's not particularly difficult to write streaming code which runs in just a few megs
01:56:34 <kaol> Embedded-like stuff. Reading inputs, sending data and maybe setting up some VPN stuff. Nothing too intensive.
01:56:54 <Axman6> should be fine, unless you mess up badly
01:57:50 <ziman> you could also look at something else than ghc
01:58:36 <merijn> kaol: For embedded stuff the biggest issue is probably "do you need to cross compile?" running a program in 256MB is certainly easy/doable (depending on the program, obviously), but compiling will be essentially impossible, so you'll have to build on another machine
01:58:54 <merijn> (GHC really needs like ~1 GB minimum to compile stuff reasonably)
01:59:40 <kaol> Yeah, I'd need to do cross compiling.
02:00:05 <merijn> cross-compiling can be a bit of a PITA depending on the exact platform
02:00:51 <kaol> My target would be arm.
02:01:16 <maerwald> kaol: https://gitlab.haskell.org/ghc/ghc/-/wikis/building/cross-compiling#tools-to-install
02:01:31 <maerwald> I've successfully built a cross GHC for arm
02:01:57 <maerwald> The main thing is getting your toolchain right (gcc, llvm, libs)
02:05:35 <vaibhavsagar> does anyone know why stack might be creating multiple package databases under .stack-work/install?
02:05:38 <kaol> Ok, thanks. My second choice would have been to learn Rust but I guess I'm fine with Haskell for what I'd be doing. 256MB is certainly less than what GHC devs had when they started.
02:05:40 <tobiasBora> Hello,
02:05:53 <vaibhavsagar> it's breaking my tests and I want there to be only one package database
02:06:36 <merijn> kaol: Rust would certainly be reasonable
02:07:09 <merijn> vaibhavsagar: stack makes one database per resolver (at least, that's what I'm guessing based on the intended functionality)
02:07:28 <vaibhavsagar> hmm, I'm pretty sure there's only one resolver
02:07:34 <merijn> kaol: But GHC cross-compilation can always use more guinea pigs^H^H^H^H^H^testers :)
02:07:40 <merijn> vaibhavsagar: On your entire system?
02:07:44 * hackage dom-events 0.0.0.2 - DOM Events expressed as Haskell types  https://hackage.haskell.org/package/dom-events-0.0.0.2 (mikesol)
02:08:17 <vaibhavsagar> this project is failing in CI, so yes
02:09:15 <merijn> CI cache? I dunno?
02:09:15 <vaibhavsagar> observe: https://travis-ci.org/github/gibiansky/IHaskell/jobs/680827022
02:10:06 <vaibhavsagar> yeah, it might be some weird caching thing
02:11:24 <vaibhavsagar> let me try nuking it and rerunning
02:11:49 <vaibhavsagar> i've been trying to make this change for ~6 months
02:13:03 <tobiasBora> In Cabal, how can you specify that an executable should use the same build-depends as the library? Here is the code I use for now http://paste.debian.net/1143690
02:13:20 <tobiasBora> but I don't like this copy/paste of containers between library and executable
02:13:50 <yushyin> tobiasBora: https://www.haskell.org/cabal/users-guide/developing-packages.html#common-stanzas
02:14:02 <merijn> tobiasBora: Use a common stanza
02:14:44 <merijn> tobiasBora: fyi, using the same src dir for a library and executable will needlessly recompile stuff
02:14:55 <merijn> and probably not do what you intended
02:15:24 <merijn> tobiasBora: It will cause GHC to reload and recompile the modules from your library when building the executable, rather than linking against your library
02:21:44 * hackage dom-events 0.0.0.3 - DOM Events expressed as Haskell types  https://hackage.haskell.org/package/dom-events-0.0.0.3 (mikesol)
02:30:37 <tobiasBora> yushyin: ok thanks!
02:30:59 <tobiasBora> merijn: hum... So I should create a folder src/exec and src/lib?
02:31:31 <yushyin> you also often see ./src and ./app
02:31:50 <merijn> I usually just do src/ and exe/ or something like that
02:32:41 <tobiasBora> ok... and just changing the folder is enough?
02:33:13 <merijn> tobiasBora: Basically, GHC will look for imports and only consult the package database when it can't find them, so when you import modules from your library in the executable in the same directory GHC will find them and use them, without checking "hold on, maybe I should get this from a library"
02:37:26 <tobiasBora> merijn: yushyin hum... And then how am I supposed to link the lib and the executable? 
02:38:58 <tobiasBora> I tried this, but it cannot even find prelude http://paste.debian.net/1143694
02:39:50 <merijn> tobiasBora: oh, you need to add a build-depends on your own package to the executable :)
02:40:12 <merijn> so "build-depends: myprog" in your executable
02:40:50 <tobiasBora> I tried but it does not help
02:42:10 <merijn> tobiasBora: Can you pastebin the entire cabal file? including change?
02:42:15 <tobiasBora> merijn: https://paste.debian.net/1143696/
02:43:08 <merijn> tobiasBora: oh, I see you have Myprog listed under other-modules of the executable, but that's not necessary
02:43:15 <merijn> It's already part of the library
02:43:37 <merijn> Also, I think common stanza imports need to be at the top of a block?
02:44:18 <tobiasBora> merijn: I removed it, but still the same error. What do you mean with the stanza imports?
02:44:38 <tobiasBora> oh you mean the import: line
02:44:45 <tobiasBora> let me try
02:44:50 <merijn> tobiasBora: Does it work like this? https://paste.debian.net/1143697/
02:45:37 <merijn> tobiasBora: I checked and yeah the cabal docs say "import must be the first field in a section."
02:48:49 <tobiasBora> merijn: I need to go, I'm back in half an hour, thanks for the help
02:52:44 * hackage dom-events 0.0.0.4 - DOM Events expressed as Haskell types  https://hackage.haskell.org/package/dom-events-0.0.0.4 (mikesol)
03:44:41 <tobiasBora> merijn: great, the problem is solved, issue was coming from the version of cabal which needs to be >=2.2, and the syntax that changed https://github.com/haskell/cabal/issues/4899#issuecomment-497502080
03:44:47 <tobiasBora> thanks merijn !
06:09:44 * hackage darcs 2.14.4 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.14.4 (bfrk)
07:54:39 <kamek> is there something like this out there : https://docs.rs/sqlx/0.3.4/sqlx/macro.query_file_as.html ?
07:54:51 <kamek> compiled time checked raw sql queries in external files
07:55:40 <merijn> I'm not aware of it, but it'd definitely be possible to implement something like that
07:56:16 <kamek> https://hackage.haskell.org/package/postgresql-typed
07:56:21 <kamek> this looks pretty close
08:29:57 <sm[m]> sm
08:47:16 <remexre> hm, w/ the prettyprinter package, is there something that expands to a given Text/Doc when there's room, or a newline if there's not?
08:47:32 <remexre> or, I guess, *n* spaces when there's room?
08:47:39 <remexre> for n>1
08:49:03 <remexre> ah wait never mind, flatAlt
09:12:12 <dsal> @tell timCF protobuffers in general have default values, so the difference between `maybe'x` and `x` is that the latter will give you the default value if there's no specified value.  If you want Nothing, you could `preview (foo . bar . maybe'buz . _Just)` or something.  Protobuffers is a little weird.
09:12:13 <lambdabot> Consider it noted.
09:55:24 <remexre> how do I convince https://p.acm.umn.edu/XHG3Hbov8AE= that the a in [a] is the same as in Foo a
09:56:14 * hackage data-category 0.9 - Category theory  https://hackage.haskell.org/package/data-category-0.9 (SjoerdVisscher)
09:59:36 <enthropy> remexre, easiest is probably to enable -XScopedTypeVariables
10:00:39 <remexre> oh, the Foo acts as a forall implicitly? ok cool
10:00:54 <remexre> tried slapping the forall onto the foo method, but that made it break
10:02:15 <enthropy> no foralls, you want it to be the same 'a' as you have in "class Foo a"
10:03:48 <enthropy> foo x = bar (constant ( undefined `asTypeOf` [x] ) ) x -- without extensions
10:08:19 <bogdan_> Hi folks! I hope asking for help in this channel is appropriate. If not, please point me in the right direction. I'm essentially trying to wrap my head about ADTs in haskell and how to use them. Specifically, nesting ADTs is something I've been attempting and failing at so far. See the snippet here: https://gist.github.com/tfbogdan/6144cf899fa1567f6f855c13a8579e79
10:08:46 <bogdan_> Is it a case of my approaching the problem from the wrong angle or is it just an insufficient understanding of Haskells type system? 
10:09:24 <pgiarrusso> bogdan_: replace SweetFruit by SweetFruit SweetFruit in the ADT definition, ditto in the other branch...
10:09:53 <pgiarrusso> data Fruit = SweetFruit SweetFruit | SavoryFruit SavoryFruit
10:10:42 <pgiarrusso> Or, with other names:
10:10:43 <bogdan_> amazing.. I suppose I need to spend more time looking at type signatures (and actually understand them) to find out where my comprehension failed me. Thanks! 
10:11:25 <pgiarrusso> bogdan_: the same name can appear both as a data constructor and as a type constructor, but those uses are unrelated.
10:11:52 <pgiarrusso> So your Fruit had two constructors that took no arguments.
10:12:31 <bogdan_> So it kind of worked like an enum of sorts. 
10:12:36 <pgiarrusso> Exactly
10:12:58 <pgiarrusso> And probably the names I’ve used are not great — let’s say `data Fruit = Foo SweetFruit | Bar SavoryFruit`, I’ll let you find names.
10:13:24 <bogdan_> Aha! That actually clarified things a bit! 
10:13:30 <pgiarrusso> But what I wrote first cannot confuse GHC (it can confuse you) — whenever you use a name, GHC knows if it expects a type or a value
10:14:27 <pgiarrusso> Yeah sorry, I wanted to preserve the constructor names, but also point out why SweetFruit wasn’t referring to the type you had defined.
10:15:06 <bogdan_> No no you built up on my initial snippet. I led you to it. 
11:04:45 * hackage calamity 0.1.4.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.4.1 (nitros12)
11:07:54 <sm[m]> vaibhavsagar: solved your CI issue ? Sounds like deleting all travis caches would help
11:10:14 * hackage headroom 0.2.1.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.2.1.0 (xwinus)
11:16:45 * hackage stack 2.3.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-2.3.1 (borsboom)
11:19:24 <sm[m]> \o/
11:51:30 <boxscape> > () :: () => (() => (() => ()))
11:51:32 <lambdabot>  ()
11:51:43 <boxscape> I didn't know you could use constraints in kinds
11:51:53 <boxscape> I guess it makes sense
11:51:58 <boxscape> seeing as their just types
11:52:34 <boxscape> though anything more complex doesn't work, sadly
11:52:53 <boxscape> > () :: (() :: ((), ()) => ())
11:52:57 <lambdabot>  error:
11:52:57 <lambdabot>      • Illegal constraint in a kind: () :: Constraint
11:52:57 <lambdabot>      • In an expression type signature: (() :: ((), ()) => ())
11:53:15 <boxscape> s/their/they're
12:21:46 <Tuplanolla> > (1 % 2) ^ (- 2)
12:21:49 <lambdabot>  *Exception: Negative exponent
12:21:57 <Tuplanolla> Why?
12:23:01 <Tuplanolla> > (1 / (1 % 2)) ^ 2
12:23:04 <lambdabot>  4 % 1
12:26:43 <boxscape> > (1 % 2) ^^ (-2)
12:26:45 <lambdabot>  4 % 1
12:26:55 <boxscape> Tuplanolla you have to use ^^ for negative arguments
12:27:11 <boxscape> negative exponents, rather
12:27:14 <Tuplanolla> Ah, I forgot there's this one too.
12:27:19 <Tuplanolla> Thanks for the reminder.
12:29:20 <boxscape> @src (^^)
12:29:21 <lambdabot> x ^^ n = if n >= 0 then x^n else recip (x^(negate n))
12:55:50 <merijn> What's the correct way of writing options involving quotes in a cabal files' ghc-options?
12:56:19 <merijn> I thought I could just write them using quotes, but I see some warnings suggesting cabal is messing them up
12:59:21 <[exa]> merijn: you might need to dodge yaml
12:59:34 <merijn> [exa]: I'm not talking about yaml
12:59:41 <merijn> I avoid yaml like the plague
12:59:56 <[exa]> oh okay
13:00:17 <[exa]> (first guess)
13:01:08 <[exa]> I'm not happy to suggest to quote the quotes
13:01:24 <[exa]> btw any specific example of error?
13:02:45 <merijn> I'm passing '-with-rtsopts="-p -l-au"' which triggers a warning about not using -l in ghc-options and using extra-libraries
13:02:56 <merijn> Except that's a bogus warning, because I'm not using the -l linker flag
13:03:44 <maerwald> optimistic parser :P
13:04:28 <maerwald> the same proble persists in ghcid
13:04:34 <merijn> I dunno whether I'm getting the syntax wrong or the warning uses a naive parser to produce the warning
13:14:19 <MarcelineVQ> merijn: what about  ghc-options: -threaded -rtsopts "-with-rtsopts=-p -l-au"
13:15:29 <MarcelineVQ> I should try that first actually ehe, it dind't complain in build but that doesn't mean the executable won't
13:18:43 <MarcelineVQ> seeems to work
13:26:26 <merijn> MarcelineVQ: I tried -with-rtsopts=-p -with-rtsopts=-l-au
13:26:34 <merijn> Compiles without complaints, no clue if it works :p
13:27:23 <MarcelineVQ> that's another method I've seen so it should, in particular package.yaml seems to prefer that form iirc
13:28:46 <merijn> That...does not seem to work
13:29:00 <merijn> It complains my profiles are empty, at least
13:30:23 <juri_> ok, i'm having a brain-o. i need to fold N times, and keep the result of each fold.
13:30:42 <merijn> hmmm
13:30:45 <merijn> That's not right
13:31:40 <juri_> i told you my brain wasn't working.
13:32:07 <merijn> MarcelineVQ: Yours doesn't work either
13:32:13 <merijn> MarcelineVQ: Produces an empty eventlog too
13:32:35 <merijn> I'll bug people in #hackage or mpickering tomorrow to figure out what's going
13:33:03 <juri_> i have a function that takes an input and gives an output. i need to call it N times, chaining the output of the first to the input of the second... to the Nth function. and i need to return the intermediaries and the last output as a list together..
13:33:08 <MarcelineVQ> empty log? sounds like something extra is going on
13:33:22 <merijn> MarcelineVQ: If I manually use "+RTS -p -l-au" then it works fine
13:33:26 <mpickering> merijn: Multiple -with-rtsopts cancel each other out
13:33:43 <mpickering> So you are not passing `-p` 
13:34:02 <merijn> mpickering: My last attempt was to have "-with-rtsopts=-p -l-au" (including quotes) in the cabal file
13:34:10 <merijn> That doesn't work either
13:34:41 <merijn> Also, I guess that means I also need to duplicate any rtsopts from the non-profiling config to the profiling one if they cancel eachother
13:40:20 <merijn> ok, a mystery for another day, clearly
14:08:31 <dmwit> juri_: iterate ?
14:08:35 <dmwit> > iterate f x
14:08:37 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
14:14:49 <juri_> dmwit: i don't think so, i think i have a handle on it. it's a strange one.
14:16:55 <dmwit> Okay. Well, I'll be interested to see what you come up with.
14:26:05 <dsal> % take 7 $ iterate (show.succ.read @Int) "0"
14:26:06 <yahb> dsal: ["0","1","2","3","4","5","6"]
14:26:31 <dsal> juri_: are you describing something different?
14:30:31 <juri_> hmm. that might be right, but it gets COMPLICATED, because i've got to allow that each stage MAY fork. let me get the types / glue together, and i'll share it.
14:31:52 <malsyned> hey y'all, I have questions about exceptions. First being: is there a more up-to-date tutorial with examples than Real World Haskell ch. 19? Its information is about 12 years out of date, since the API changed in GHC 6.10.1 (base-4.0.0.0)
14:41:27 <koz_> I have a project managed with Stack, which requires an SSH clone of a Bitbucket repo. My key is not in the default place git looks (different name), and for the main repo it works. However, when stack tries to clone the submodule, it blows up.
14:41:40 <koz_> Is there a way I can tell Stack 'please use this key' without having to stuff it into stack.yaml?
14:41:46 <koz_> (or for that matter, at all?)
14:43:30 <maerwald> shouldn't that be in your ssh config?
14:48:23 <dsal> juri_: The trick is to keep it from getting complicated.  :)
14:50:01 <juri_> dsal: yeah, good luck with that. first, i'll make it handle the simple cases...
14:52:46 <dmwit> malsyned: Well, Control.Exception is not very big. I don't know of any tutorial material, but as reference material it's not hard to make it through the entire module in one sitting.
14:52:51 <dsal> juri_: I don't know what you're doing, but that's basically what programming is.  :)
14:53:08 <dmwit> malsyned: You can easily ignore the definitions of all the types that are just there to be intsances of the Exception class without losing much.
14:55:02 <malsyned> dmwit, I have been doing that some. One question I have after reading the docs and some of the code for Control.Exception is, the docs say "we recommend using try rather than catch for ordinary exception recovery" but I don't see a 'try' equivalent to 'catches' for catching multiple classes of exception. What am I missing?
14:58:06 <dmwit> Nothing, there is no analog in there.
14:58:59 <malsyned> dmwit, so how do I check for more than one kind of exception? Is there a way? Or do I then have to go against the advice of the module and use 'catch'?
14:59:33 <dmwit> try is a good alternative to catch. There is no similar to catches.
14:59:45 <dmwit> I don't see either of these statements as being "against the advice of the module".
15:00:01 <dmwit> *no similar alternative
15:01:03 <dmwit> I don't even see the advice you're talking about.
15:01:11 <dmwit> Where does it say to use try over catch?
15:01:34 <malsyned> "it is possible to accidentally stay inside the implicit mask by tail-calling rather than returning from the handler, which is why we recommend using try rather than catch for ordinary exception recovery" from https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#g:3
15:02:02 <dmwit> Just found that, yup.
15:02:06 <dmwit> Let me ponder that for a bit.
15:02:10 <malsyned> thank you!
15:04:09 <dmwit> Okay. It is tricky but possible to implement a `tries`-alike in terms of `catches`, I think.
15:04:21 <dmwit> You need some extensions.
15:04:43 <dmj`> does anybody have the lambda cats photo gallery link? need it for something really important.
15:04:58 <dmwit> But I think the main value is in making it obvious that the handlers don't do much computation. If you just... don't do much computation in your handlers, I think it will probably be simpler to use `catches` directly.
15:06:00 <dmwit> https://lambdacats.github.io/
15:06:37 <dmj`> dmwit: you're the best thanks
15:08:06 * dmwit is google
15:08:58 <dmj`> I tried google lambda cat and got nothin'
15:09:06 <dmj`> Naturally assumed a deep state conspiracy and moved on
15:09:20 <dmwit> works better without the space =)
15:09:33 <malsyned> So 'catches' does something like blocking asynchronous signals for the duration of the handler, so making sure not to stay in the handler forever after is the only caveat to using it?
15:10:57 <dmwit> That pretty much sums it up, yeah.
15:14:43 <dmj`> dmwit: that space killed me
15:20:00 <koz_> maerwald: I had to do that in the end, but it seems weird that it has to be handled _there_, as opposed to locally.
15:20:15 <maerwald> locally?
15:20:43 <koz_> As in, per-project.
15:20:52 <koz_> But if I have to have it in my ssh config so be it.
15:21:11 <koz_> Also, has anyone else hit the DEPRECATED thing Stack spews now if you try to pull down a project without a cabal file?
15:21:12 <maerwald> different keys for the same host?
15:21:15 <koz_> Is there a way to go around it?
15:26:26 <malsyned> dmwit, I don't understand how the type signatures given to exceptions are enabling dispatch to different handlers. I get a distinctly "not Haskell98" vibe off of whatever is happening. Can you give me some keywords to search to achieve enlightenment?
15:27:09 <electricityZZZZ> i don't have much experience writing async/multithreaded code,... in the "real world" once you start burdening your system significantly do you end up needing custom scheduling or otherwise allocating dev time to the limitations of the green thread abstraction?
15:28:46 <ferd> @help
15:28:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:28:53 <ferd> @help list
15:28:53 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
15:29:26 <ferd> ??list
15:29:44 * hackage haskoin-store 0.23.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.4 (jprupp)
15:30:37 <ferd> @list
15:30:37 <lambdabot> What module?  Try @listmodules for some ideas.
15:37:02 <ferd> @type foldr
15:37:03 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:52:45 <ferd> @pf \f l b -> foldr f b l
15:52:45 <lambdabot> Maybe you meant: pl bf
15:52:52 <ferd> @pl \f l b -> foldr f b l
15:52:52 <lambdabot> flip . foldr
15:54:30 <remexre> is there a better way than split+lookupMin to find the largest key less than the given value w/ Data.Map?
15:55:28 <remexre> in this case, k=Word64, so if there are any things that'd only work there, they'd be fair game
16:00:23 <MarcelineVQ> remexre: lookupLT
16:02:58 <remexre> MarcelineVQ: ah, thanks
16:03:12 <ferd> @pl \f l b -> foldl f b l
16:03:12 <lambdabot> flip . foldl
16:04:07 <justsomeguy> It seems like lambdabot can do a lot of cool things.
16:06:54 <justsomeguy> It's better at haskell than me.
16:12:06 <koz_> justsomeguy: Wait till you discover @unmtl.
16:12:59 <hpc> the unmtl command is pretty simple
16:13:02 <hpc> the real magic is @free
16:13:17 <koz_> hpc: It is simple, but _very_ useful.
16:13:18 <hpc> which i still haven't fully figured out how to use correctly
16:13:56 <koz_> @unmtl ErrorT e (State s) a
16:13:56 <lambdabot> s -> (Either e a, s)
16:14:04 <koz_> @unmtl StateT s (Error e) a
16:14:04 <lambdabot> s -> Error e (a, s)
16:14:09 <koz_> .... argh.
16:14:14 <koz_> @unmtl StateT s (ErrorT Identity e) a
16:14:14 <lambdabot> s -> e (Either Identity (a, s))
16:14:32 <koz_> The whole Error/Except thing is a bit of an annoyance, but it gets the point across well enough.
16:14:48 <koz_> @unmtl StateT s (ErrorT e Identity) a
16:14:48 <lambdabot> s -> Either e (a, s)
16:14:51 <koz_> Whoops.
16:15:45 * hackage extended-containers-lens 0.1.0.0 - lens instances for extended-containers  https://hackage.haskell.org/package/extended-containers-lens-0.1.0.0 (konsumlamm)
16:18:14 * hackage matrix-sized 0.1.0 - Haskell matrix library with interface to C++ linear algebra libraries.  https://hackage.haskell.org/package/matrix-sized-0.1.0 (kaizhang)
16:19:44 * hackage haskoin-store 0.23.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.5 (jprupp)
16:23:46 <vaibhavsagar> sm (@simonmic:matrix.org): clearing the caches didn't fix my issue
16:38:26 <claire81> i'm getting a parsing error on a class lab that I have due tonight. It is on lists (probably simple for y'all). 
16:38:49 <claire81> :{remainder :: Integral a => a -> a -> aremainder x y = rem x y:}
16:39:21 <claire81> Imagine that it's split onto different lines. I am getting a parsing error on that first :{
16:40:14 <claire81> If anyone could help out, that would be awesome. Keep in mind that I am a complete newbie
16:41:36 <MarcelineVQ> what do you do with that to then get a parsing error?
16:42:30 <claire81> I'm simply doing :l <filename.hs>
16:42:34 <claire81> to compile
16:42:51 <MarcelineVQ> ok   :{  :}  are ghci commands so they are only valid to type into ghci, not have in a source file
16:43:07 <claire81> ohhhh. That helps a lot. Thanks!
16:43:09 <MarcelineVQ> in a source file you'd just put things on multiple lines directly
16:43:13 <claire81> I figured it was a simple fix
16:43:35 <MarcelineVQ> You can see the avaialble commands in ghci with  :?  if you're curious about them
16:43:43 <claire81> so if I am writing up a file, I don't have to have any :
16:44:29 <MarcelineVQ> It depends since : itself is valid in other places, but you wouldn't be starting any line with : at least
16:45:26 <claire81> I'm using learn you a haskell, and the chapters we have covered are really only typing expressions into terminal... 
16:45:33 <claire81> which is not super helpful atm
16:46:16 <MarcelineVQ> It's not a great resource, insofar as there aren't any exercises in it, but if your teacher has exercises/homework about it that's not so bad
16:46:34 <claire81> do you have any suggestions for better resources?
16:47:30 <sm[m]> @where htac
16:47:30 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
16:47:53 <MarcelineVQ> I'm not sure, it's been awhile since I've looked into what's readily avaialble (as in free) but I recall https://en.wikibooks.org/wiki/Haskell being not too bad, though it lacks exercises as well
16:52:38 <hpc> claire81: https://www.haskell.org/documentation/ has a big list of resources
16:54:31 <hpc> i like that this page is a thing now
16:55:11 <hpc> it used to be you'd have to look at the wiki, which was using some weird software i had never heard of before and navigating it didn't really make much sense
16:55:17 <hpc> or you'd just have to google for things
16:56:04 <hpc> but now it's linked right from the language homepage under the same link as all the standards and such
17:02:45 * hackage haskoin-store 0.23.6 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.6 (jprupp)
17:07:09 <sm[m]> vaibhavsagar: what problem do you see ?
17:42:11 <vaibhavsagar> sm: the GHC_PACKAGE_PATH that `stack env` provides is different from the one that it uses for `stack build`
17:43:19 <vaibhavsagar> e.g. https://travis-ci.org/github/gibiansky/IHaskell/jobs/680937723
17:44:20 <vaibhavsagar> the result of `stack build` is "Installing library in /home/travis/build/gibiansky/IHaskell/.stack-work/install/x86_64-linux/984e3230c6a..."
17:45:10 <vaibhavsagar> but the result of `stack exec -- env | grep GHC_PACKAGE_PATH` is "/home/travis/build/gibiansky/IHaskell/.stack-work/install/x86_64-linux/6c485e86d..."
17:45:38 <vaibhavsagar> the hashes are different and I don't understand why
17:45:47 <vaibhavsagar>  * sm: the GHC_PACKAGE_PATH that `stack exec -- env` provides is different from the one that it uses for `stack build`
18:02:10 <vaibhavsagar> also this only seems to happen on Travis, I don't get this behaviour when running locally
18:03:03 <kamek> trying to pick a code style, this seems fine: https://kowainik.github.io/posts/2019-02-06-style-guide
18:03:20 <kamek> is any of the existing formatters complete enough to enforce this ?
18:04:44 * hackage zeolite-lang 0.1.2.3 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.3 (ta0kira)
18:09:06 <dsal> kamek: Not really.  Do what suits you.  I don't like long names in general.  There are a few things in there about that.  It specifically says not to name something par.  heh
18:09:06 <dsal> :t pr
18:09:08 <dsal> :t par
18:09:08 <lambdabot> error:
18:09:08 <lambdabot>     • Variable not in scope: pr
18:09:08 <lambdabot>     • Perhaps you meant one of these:
18:09:09 <lambdabot> error:
18:09:09 <lambdabot>     • Variable not in scope: par
18:09:10 <lambdabot>     • Perhaps you meant one of these:
18:09:14 * dsal has a broken a key
18:09:18 <dsal> damn, no par
18:09:20 <dsal> % :t par
18:09:21 <yahb> dsal: ; <interactive>:1:1: error:; * Variable not in scope: par; * Perhaps you meant one of these: `par#' (imported from GHC.Prim), `Sym.var' (imported from Data.Number.Symbolic), `para' (imported from Data.Functor.Foldable)
18:09:25 <dsal> well then.
18:12:15 * hackage tasty-json 0.1.0.0 - JSON reporter for the tasty testing framework  https://hackage.haskell.org/package/tasty-json-0.1.0.0 (larsk)
18:12:26 <kamek> yeah I don't really mind the naming conventions, I don't think a formatter should tell you how to do any of that stuff anyway
18:13:28 <kamek> not being able to enforce formatting rules is a bummer tho, I know people on my team aren't rigorous enough to stick with a guide correctly
18:13:30 <kamek> oh well
18:13:35 <dsal> They suggest un instead of run.
18:13:38 <dsal> Overall, it doesn't seem to bad.
18:13:42 <dsal> s/to/too/
18:13:49 <dsal> I use stylish-haskell and it's mostly fine.
18:14:10 <kamek> I'll check it out u.u
18:16:04 <dsal> Some of it is just code review.  e.g., I used to like `import X`.  Now I don't mind it as much for my own project's code, but as much of a pain it is to be explicit about imports, it's *so* much less than listing everything.
18:16:13 <dsal> Except for stuff like Lens, though I end up having to use hiding sometimes.
18:17:31 <dsal> It mostly seems reasonable to me.
18:19:53 <dsal> I kind of wish there were a way to document generated code.  That bug will eventually find itself drunk crying in an alley, though.
18:47:13 <martin290> new here to haskell. what types of things are built with haskell?
18:49:07 <lyxia> IO ()
18:51:39 <martin290> IO? input output?
18:53:02 <Axman6> programs, generally
18:54:06 <martin290> like GUI programs? script tasks?
18:54:08 <Axman6> it's a general purpose programming language, so literally anything. I have used it for writing quite a few web APIs, lots of data processing, curtrently using it for microservices and lambda functions on AWS Lambda
18:54:19 <martin290> nice!!
18:54:23 <jackdk> martin290: Haskell is a general purpose programming language. So you could in principle build anything with it. Because of where the tooling and libraries, it's great for backends and data processing stuff
18:54:42 <dsal> martin290: I just did a blog post on one of my recent projects:  http://dustin.sallings.org/2020/04/29/gopro-plus.html
18:54:53 <Axman6> GUI programming is probably one of the areas it's not so great, but it is definitely possible - people tend to just make web apps instead these days because it's much easier to make those cross platform
18:54:54 <martin290> i have deep sql knowledge and i was looking to get into something else, but i haven't found the "thing" yet
18:55:25 <dsal> Axman6: I ended up using javascript for lambda in this project.  :(  getting the stupid thing to start building was taking too much time and the yak was nearly bald at this point.
18:55:32 <jackdk> there's a bunch of people who build web frontends in it, by compiling to JS. There's a few libraries that solve the gui problem in different ways. some are quite imperative, others are more functional, and others are quite galaxybrained
18:55:33 <Axman6> we have our own cottage industry of SQL libraries
18:56:04 <martin290> what do the sql libraries do? like ORM's?
18:56:52 <dsal> I've spent so long trying to avoid ORMs heh.
18:57:02 <dsal> But sqlite-simple kind of feels like it one now and then.
18:57:10 <Axman6> dsal: sad :( we reduced our build times quite alot using cache-s3 to cache all the stack stuff. Nix would be ideal with a nix cache but none of us know nix and every time ~jackdk has tried to show me how it works~ I've tried to figure out how it works it's failed miserably
18:57:16 <martin290> dsal looking over your article now. much of that code doesn't make sense to me right now
18:57:31 <martin290> dsal sqlite is an awesome dbms
18:57:43 <Axman6> I wouldn;t cvall sqlite a dbms
18:57:56 <Axman6> i would like  to learn how to type one day though
18:58:12 <dsal> martin290: It's more meant to answer your actual question, "what types of things are built with haskell?"  Not look at all the magical stuff I can do with a line of lens (though I've got one of those in there), but just like, I needed a thing and I used this tool.
18:58:46 <martin290> Axman6 well it's just a database, without the ability to create things like stored procedures, jobs, etc
18:58:46 <dsal> People keep thinking haskell is some useless academic language.  I find it to be consistently the easiest language I work in (from a relatively long list).
18:59:16 <dsal> the pain points are always pretty local.  Just like, the unliftio thing last night.  The big picture is always easier, and that's just pleasant.
18:59:34 <dsal> I like sqlite a lot.  :)  It works very well for this problem, and many similar problems I've got.
18:59:45 <jackdk> martin290: on the database interface front, you have the *-simple libraries, which ask you to write SQL and translate placeholders and results. And you have libraries like opaleye which try to construct a totally typesafe representation of the data. https://github.com/Gabriel439/post-rfc/blob/master/sotu.md is pretty good reading to get a sense of what libs are out there
18:59:55 <martin290> dsal makes sense, thanks! i've started doing some python because i'm interested in predictive analytics. i'd like to try and predict the stock market
19:00:03 <Axman6> don't get me wrong, I love sqlite to bits, but dmbs implies some kind of management, and sqlite doesn't really have "management"
19:00:33 <martin290> Axman6 agreed, there is no management about it, it's really just a database
19:00:48 <Axman6> dsal: yeah I find that when you get through small pain points like your unliftio thing the payoff is unusually big
19:00:55 <martin290> jackdk is that kind of like dataframes in python =?
19:01:27 <martin290> jackdk thanks for sending that over!
19:01:45 <Axman6> I need to add sqlite support to my ghetot web app I'm currently working on
19:01:48 <jackdk> martin290: I don't know dataframes so I can't say
19:02:01 <martin290> jackdk think of a table in a database
19:02:15 <martin290> columns with data types and you can "query" it, kind of like sql
19:02:27 <Axman6> the haskell Frames library is probably the closest to python data frames, thoug aimed more at CSV based data (hopefully they've fixed the parser, it used to do stupid things)
19:02:41 <martin290> Axman6 nice!
19:03:34 <Axman6> oh nice, there's now a Frames-dav using newhoggy's super awesome insanely fast, vectorised csv parsing library!
19:03:56 <Axman6> newhoggy is such a champ <3
19:04:37 <newhoggy> Oh wow
19:13:02 <jackdk> martin290: http://dev.stephendiehl.com/hask/ is also good value
19:14:22 <martin290> jackdk wow that's a lot of content. thanks for sending that over
19:17:15 * hackage zeolite-lang 0.1.2.4 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.4 (ta0kira)
19:40:45 * hackage zeolite-lang 0.1.2.5 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.5 (ta0kira)
19:58:45 * hackage zeolite-lang 0.1.2.6 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.6 (ta0kira)
20:06:45 <Silent_Alex> s
20:07:15 * hackage zeolite-lang 0.1.2.7 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.7 (ta0kira)
20:15:07 <dsal> zeolite seems to have a git push -> hackage trigger
20:24:45 * hackage zeolite-lang 0.1.2.8 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.8 (ta0kira)
20:44:45 * hackage zeolite-lang 0.1.2.9 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.2.9 (ta0kira)
21:10:42 <jackdk> I hope not.
21:11:29 <koz_> Otherwise they'll get a nice visit from the resident phadej.
21:44:25 <sm[m]> vaibhavsagar: --profile is one thing that can cause those hashes to differ. If you're not using that anywhere, maybe paste both full commands, maybe there's something else like that
22:43:49 <vaibhavsagar> sm: I'm using `stack build --fast`, would that make a difference?
23:19:45 <scasc> .
23:21:00 <scasc> Anyone ever used Pijul (https://pijul.org) and compared it to Darcs and Git?
23:22:15 * hackage gopro-plus 0.3.1.1 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.3.1.1 (dustin)
23:22:32 * srk would like to know as well :)
23:25:20 <phadej> koz_: indeed that doesn't look good
23:42:15 * hackage souffle-haskell 0.2.2 - Souffle Datalog bindings for Haskell  https://hackage.haskell.org/package/souffle-haskell-0.2.2 (luc_tielen)
23:45:57 <phadej> scasc: pijul's UI is very spartanic, it works differently from git; sadly I haven't ever actually used darcs (more than clone and record single patch) to compare these too
23:48:45 <phadej> there were some tweets from the author that pijul internals are being rewritten to be fast enough for big projects.
23:49:09 <phadej> otoh I'm avoiding pijul myself to not get into rabbit hole of improving the UI (it's Rust, so not as fun to work with)
