00:09:20 <maerwald> freeman42x[m]: hello my friend
00:10:29 <maerwald> where is this post from the picture
00:10:44 <maerwald> It sounds like something I would write, but I didn't
02:20:00 <maerwald> 'unix' package doesn't work when I have it as a subpackage in cabal.project. The autotools hooks don't run.
02:42:11 <phadej> maerwald: you have to run autoreconf -i manually
02:42:20 <phadej> or what you mean?
02:42:38 <maerwald> https://github.com/haskell/cabal/issues/4903
02:43:05 <phadej> yes, you should run `autoreconf -i` manually.
02:43:14 <maerwald> That's quite unergonomic
02:43:19 <maerwald> cabal should do that
02:43:42 <maerwald> hvr noted that should be in cabal-install
02:43:52 <maerwald> the discussion was just about Cabal vs cabal-install
02:44:05 <phadej> I think something more general like: https://github.com/haskell/cabal/issues/6664
02:44:08 <phadej> should be there
02:44:13 <phadej> as autoreconf -i is just a special case
02:44:21 <phadej> "just"
02:44:23 <maerwald> sdist isn't used there
02:44:29 <maerwald> when you run cabal v2-build
02:44:58 <phadej> as hvr says
02:44:58 <phadej> That being said, I had been loooking into adding support for the messy logic needed to properly handle autoreconf into cabal-install in order to support the upcoming Git repo dependencies,
02:45:03 <phadej> not e _git_ repo dependencies
02:45:09 <phadej> they will go though sdist
02:45:28 <merijn> phadej: I think he has a local checkout and referring to a local path in cabal.project?
02:45:44 <phadej> if there is local checkout, than just `autoreconf -i` there.
02:45:58 <phadej> again as hvr says, And in general I think it's better to educate the user than to magically do things behind his back.
02:45:59 <maerwald> I'm building it on remote machines
02:46:18 <maerwald> I don't think I should git commit those files
02:46:31 <maerwald> I'm well educated about autotools :)
02:46:44 <maerwald> That's why I don't commit them files
02:46:48 <phadej> no, but e.g. haskell-ci generates `autoreconf -i` in the .travis.yml; it's really not a problem
02:47:08 <phadej> you try to push functionality into cabal-install, i try to push everything which could be elsewhere.. elsewhere
02:47:24 <maerwald> well, this basically makes source-repository-package awful to use.
02:47:48 <maerwald> or rather: impossible
02:47:50 <phadej> as I said, git repo dependencies *will* use sdist and when 6664 is solved it would be generic solution
02:48:52 <phadej> I understand local checkout as someone doing manually "git clone" (or git submodule update)
02:49:32 <phadej> if you want to help, make hvr comment on 6664 :)
02:49:39 <maerwald> he's awol I think
02:52:15 <phadej> He just responded on issue yesterday: https://github.com/haskell/parsec/pull/113 wouldn't call that AWOL
02:54:10 <maerwald> So he's ignoring me then :P
02:54:35 <maerwald> or IRC
02:54:40 <phadej> he weren't on IRC afaik during easter holidays...
02:54:57 <phadej> Really, people on the internet have to get used to people having holidays
02:55:04 <phadej> sometimes even MONTHS long holidays
02:56:01 <phadej> and the fact that internet is not something where I'd shout "I'm away on holidays, go robe my house" in too open forums
02:56:14 <maerwald> And I thought holidays is were everyone starts coding :>
02:57:07 <phadej> I realised that if I code recreationally, I better leave the results to myself
02:57:30 <maerwald> why so
02:58:45 <phadej> If I make a music song, I might not want to also provide the sheet music and maybe even offer private teaching how to play it...
02:58:59 <phadej> private yet free.
02:59:20 <maerwald> yeah, opensource expectations :)
03:03:04 <phadej> ... which would be quite difficult, given one "provides sheet music and teaching in the day job"
03:04:16 <maerwald> quit the job :>
03:08:18 <phadej> thanks for advice, I'll consider that.
03:08:43 <phadej> (fwiw, part of my job is maintaining Cabal)
03:08:53 <maerwald> Don't quit your job :)
03:11:22 <maerwald> uhmm, hspec fails to link with a bundled unix, lol: https://travis-ci.org/github/hasufell/hpath/jobs/674779869#L1562
03:23:09 <phadej> I guess some CPP/configure magic is off by one, as there isn't execvpe on macOS https://stackoverflow.com/questions/59922661/why-doesnt-unistd-h-execvpe-work-on-macos
03:23:51 <phadej> and `unix` code has foreign import ccall unsafe "__hsunix_execvpe"
03:24:42 <phadej> https://hackage.haskell.org/package/unix-2.7.2.2/src/cbits/execvpe.c <- I guess your system configures with HAVE_EXECVPE - but why, you have to find out yourself
03:25:24 <maerwald> Yeah, I'm trying to find a bug where on unix dirent is screwed and the path name is missing the first char
03:25:31 <maerwald> s/unix/mac/
03:33:12 <arahael> maerwald: sounds awfully like an edge case nvolving case insensitity yet case preserving semantics?
03:33:20 <arahael> *involving
03:33:53 <maerwald> I'm assuming it's a memory bug or something wrong with the linker
03:35:10 <maerwald> not having access to a mac host and doing debugging via travis doesn't help
03:35:40 <arahael> sounds painful!
03:35:50 <maerwald> Yes, I'm already on painkillers
03:37:07 <arahael> not good.  i dont recommend using amphetamine or caffiene at the same time! :)   (bad pun: those are both anti-sleep apps for macbooks)
03:37:31 <maerwald> I don't do caffeine
03:38:41 <arahael> i do.  but i make the laptop do amphetamine ;)
03:40:29 <phadej> oh, galaxy brain, put ~/.cabal/store on tmpfs
03:40:43 <phadej> for super fast builds, kinda
03:41:41 <maerwald> You mean when the store isn't populated yet?
03:46:06 <phadej> it would be cool if there were a tmpfs variant which you could snapshot to disk manually
03:46:38 <phadej> (with proper snapshot, not some lousy `rsync` kind of solution)
03:55:22 <arahael> phadej: doesnt linux do some rather aggressive ram caching unless you sync mtimes or something?
03:56:41 <phadej> arahael: well, maybe for cabal/store it's fine as it's append-only mostly
03:57:05 <phadej> but for some development work I don't really care that all the rebuild artifacts (which are Gigs) are synced to physical disk at all
03:58:14 <phadej> i.e. I guess I would like a file system where `dist-newstyle` is kept in tmpfs :)
03:58:31 <phadej> folders*
03:59:04 <maerwald> you seem to have a lot of excess ram?
03:59:18 <maerwald> I'm already happy when I don't get OOMed
03:59:39 <yushyin> ohh me too, me too :(
03:59:49 * arahael has lots of excess ram.
04:00:07 <phadej> currently 10/62GB (and there's about 30GB used for io caches)
04:00:08 <merijn> arahael: High five!
04:00:37 <yushyin> 8GB is just not enough nowadays :(
04:00:50 <arahael> phadej: 32GB, in my case, with 25 GB free.  but havent done haskell dev for a while, sadly.  been baking bread instead.
04:00:57 <merijn> The upside of building on uni machines (compared to the downside of "everything sucks to install") is "enough RAM for everything, wheeeeeeee!"
04:01:23 <merijn> Just alias make to make -j48 and cabal to -j24 and watch it go!
04:01:42 <arahael> in four slots i think.
04:02:14 <phadej> yes, my board could in theory take 128GB, but I have no idea what I would do with that extra memory
04:02:21 <arahael> techniclaly i could double to 64GB on this board but that requires "double height" rma sticks, apparently, which are rare.
04:02:58 <phadej> I have occasionally went to swap even on this machine, but well, human stupidity has no limits
04:03:21 <arahael> my laptop had a 50 GB vim swapfile, somehow, at one point!
04:03:39 <arahael> was trying to figure out where the heck my ssd space went!
04:03:52 <arahael> didnt even think vim had swapfiles.
04:04:43 <merijn> arahael: vim's .swp files have nothing to do with swap space
04:05:16 <merijn> arahael: They're just autosave files in case your editor crashes
04:05:47 <merijn> Which makes me wonder how the hell you got one that's 50GB >.>
04:06:29 <arahael> merijn: right!
04:09:45 <Maxdamantus> 10000000p
04:10:28 <arahael> lately i have been hacking about in swift in iOS.  leaves a lot to be desired. :(  i should look into figurig out how to develop a haskell static lib or something that links into ios.
04:10:38 <arahael> ios apps, anyway.
04:11:26 <phadej> that's possible but very not easy
04:13:16 <maerwald> merijn: are you aware of weird issues with fdopendir on mac?
04:13:35 <maerwald> except that it was introduced very late
04:14:37 <arahael> phadej: yes, thats the problem.  its getting to the point where, for simple apps, it is best to simply write them again in whatever the native languag eis.
04:15:01 <arahael> which, for ios, means swift.
04:16:07 <merijn> maerwald: No, but I don't do weird things, so that's probably not saying much :p
04:18:09 <maerwald> merijn: d_name gets the first char cut off, I'm using 'readDirStream' from unix package, but I open the dirstream via fdopendir ccall. Either fdopendir is broken, or... readDirStream (which I doubt)
04:18:50 <maerwald> or unsafeCoerce from 'Ptr CDir' to 'newtype DirStream = DirStream (Ptr CDir)' is broken
04:19:28 <maerwald> I think there would be more users complaining if unix was broken, no?
04:19:42 <merijn> maerwald: And nothing else uses the Fd after fdopendir?
04:20:15 <maerwald> merijn: correct
04:20:43 <merijn> No clue, then
04:23:44 <arahael> as a completely uneducated guess, what would happen if you were to open the directory, but the directory on disk had a different name (differing only by case, typically the first character?)
04:26:07 <maerwald> Well, if someone can review/test https://github.com/haskell/unix/pull/110#issuecomment-613384845
04:26:16 <hseg> i'm back. to recap - http://ix.io/2hUU errors out on the C (M n) instance, saying it can't find a Show (Vector n Char) instance
04:26:17 <maerwald> it's possible my bug will occur there too
04:27:12 <maerwald> But I don't have a mac, so this is annoying to debug
04:28:23 <hseg> interestingly, replacing Vector by newtype Tagged (n::Nat) a = T a with the obvious instance doesn't cause an error
04:29:42 <maerwald> arahael: https://travis-ci.org/github/hasufell/hpath/jobs/674795844#L1167-L1168
04:29:51 <maerwald> no idea, seems caseless?
04:31:03 <merijn> ooh!
04:31:18 <merijn> Encoding issues maybe?
04:32:00 <hseg> ok, seems the case analysis on n in the Show (Vector n a) instance may be to blame here
04:35:10 <arahael> maerwald: seems strange, but yeah.  did a bit of googling myself, that particular api seems weird.  seems there are special 64-bit versions as well when linking?
04:35:48 <arahael> maerwald: but the issues i see are linking issues,this looks different, its obviously linking.
04:36:16 <hseg> ok, so it seems having instances at T (Z::Nat) a and T n a => T (S n) a in scope is not enough for ghc to discharge a constraint at T n a?
04:40:53 <hseg> did i make a mistake with my inductive instances?
04:41:38 <hseg> ... ah. https://www.reddit.com/r/haskell/comments/eisvlf/inductive_instances/fctfhyu/
04:42:59 <hseg> ok, now to check that's actually what went wrong in my original example
04:48:25 <hseg> correct me if i'm wrong, but newtype N a = N (T a) deriving C; will generate instance C (T a) => C (N a), where all methods are implemented using coercions, correct? 
04:50:44 <hseg> ah. so my problem is elsewhere
04:51:22 <hseg> my inductive instances were a red herring
04:51:52 <maerwald> arahel: so it links to some wrong crap? 
04:54:28 <hseg> what's actually going on is i have module C { class G t => S t } module P { data P; deriving via W instance ctx => S P } module T { newtype T = T P deriving instance S }, where ctx suffices for derivingvia to produce a G P instance, but that instance somehow doesn't reach the T module
04:54:32 <arahael> maerwald: well, there was a go issue where it apparently did or something, and consequently got rejected from the mac app store.  let me see if i can find it again...  but i dont think it is the issue youre having.
04:54:47 <hseg> ... lemme pastebin that
04:55:01 <arahael> maerwald: https://github.com/golang/go/issues/31447
04:55:04 <hseg> also, lemme confirm that's actually what's happening
05:37:31 <lyxia> hseg: It looks like you've been making progress with your issue (sorry I haven't been following since last time)
05:37:45 <hseg> some. only to find it was a red herring
05:37:53 <hseg> restarting minimization
05:38:24 <dramforever> I just found out about hoopl and it's amazing, but everything about it looks kinda... old? Is there more information or anything else I might be interested in?
05:40:26 <hseg> success!
05:40:40 <hseg> ok, so i have the essence of the error mostly isolated
05:41:07 <hseg> http://ix.io/2i0e
05:41:32 <hseg> gives error 'No instance for (G (U (T a)))'
05:41:43 <hseg> when i try to compile T.hs
05:42:32 <hseg> ... dammit, still a red herring
05:42:55 <hseg> this bug is turning out to be as frustrating as my actual research
05:46:58 <hseg> have a wild idea where the error is from
05:47:25 <hseg> however, to test hypothesis need to be able to write instance C (TF T) in a .hsig file
05:47:30 <hseg> where TF is a type family
05:49:47 <hseg> ... unless declaring in a module signature that instance S P for class G (U P) => S P implicitly also declares that instance G (U P)
05:49:58 <hseg> but i don't think constraints work that way
06:24:28 <hseg> dammit. can't reproduce. have to go now, will try again tomorrow
06:36:05 <Taneb> Does anyone know if recursion-scheme's TH supports cyclically defined data structures
06:44:15 <lyxia> it doesn't
06:45:42 <Taneb> :(
06:45:47 <Taneb> lyxia: thanks
07:28:13 <Roey> oh.
07:28:17 <Roey> this is still a thing, I see.
07:41:34 <gorkemkrdmn> Hello, I have a coding problem that I already solved but I need to increase its efficiency can anyone help me ? 
08:20:26 <aveltras> I'd like to setup "pluggable" servant modules. I'm facing a problem where i'd want to be able to generate typesafe links in those modules since the root api is unknown. Has anyone ever tried something similar ? I'm aware of the IsElem constraint
09:21:46 <molossus_spondee> https://repl.it/repls/EveryDeadStructures the if node isn't possible to implement with applicative right?
09:22:04 <molossus_spondee> I mean you can but it'll run both effects
09:22:54 <c_wraith> you are correct
09:24:18 <molossus_spondee> Thanks. Could I work around it by lowering twice?
09:24:43 <molossus_spondee> A toApplicative step that then lowers to toMonad?
09:25:59 <c_wraith> I'm not sure what you're asking there.  
09:29:49 <molossus_spondee> Okay so the context is I'm compiling an expression tree to the operational monad
09:30:19 <molossus_spondee> But I was thinking it would be better to compile to an applicative functor
09:30:33 <molossus_spondee> But I can't do if there
09:30:52 <edmundnoble> You control the compilation process
09:31:15 <edmundnoble> You can compile it to a monad and *also* use operations other than monadic bind during compilation
09:31:16 <molossus_spondee> I think I'll need to try it out myself and show later
09:33:42 <maerwald> What is the difference of 'foreign import ccall unsafe "foo"' vs 'foreign import ccall unsafe "__foo"', where the former is a libc function and the latter a local function from cbits wrapping the libc function?
09:34:25 <maerwald> basically: void __foo() { foo() ; }
09:45:10 <oats> I've been thinking a bit about teaching and communicating haskell lately, is this a not-too-far-off-the-mark high-level description of functor/applicative/monad, with respect to "effects": Functor: for when you need to map over the result of an effect, Applicative, for when you need to chain together (and maybe accumulate) the results of effects, and Monad: for when you need effects to depend on
09:45:13 <oats> the result of previous effects
09:45:40 <dmwit> Hm.
09:46:01 <dmwit> I'm not sure I like "map over the result of an effect". fmap doesn't change what effect happens at all.
09:46:23 <oats> hmm, did I imply altering the effect somehow? that wasn't my intention
09:46:52 <solonarv> for applicative I'd use the word "combine"
09:46:57 <solonarv> monad looks pretty much spot on
09:47:08 <solonarv> that's exactly the additional power you get from going applicative -> monad
09:47:09 <dmwit> I guess if I treat "result of an effect" as a technical term requiring some definition and distinct from "effect", then I'm okay with it.
09:47:22 <dmwit> "it" being the whole paragraph, in this case.
09:47:28 <oats> sure
09:47:34 <maerwald> oats: monad doesn't depend on the previous effect, but the value of the previous effect
09:48:11 <oats> maerwald: that's what I was trying to say by "result of previous effects"
09:48:25 <maerwald> right
09:48:26 <oats> how would you phrase it?
09:48:32 <maerwald> I would say value
09:48:34 <dmwit> But: I worry that choosing "result of an effect" as the term you choose to attach that definition to could be confusing.
09:48:47 <maerwald> m a -> (a -> m b) -> m b
09:48:49 <maerwald> a is the value
09:48:54 <dmwit> I think of "result" and "effect" as two intertwined parts of an action.
09:48:55 <maerwald> but yeah, semantics
09:49:35 <dmwit> The "effect" being all the extra computation that goes on in a hidden way, and the "result" being the value that's carried around for doing pure computation on.
09:50:02 <oats> do you not see `a` above as the result?
09:50:06 <oats> I guess I'm a little confused :P
09:50:18 <maerwald> Also, you missed Selective
09:50:24 <dmwit> So, for example: in `put 3 >> get`, then "effect" is updating the state (only), the "result" is 3 (only), the action does does the effect and produces the result.
09:50:26 <maerwald> pls add that between applicative and monad
09:50:28 <oats> huh, I actually haven't heard of selective
09:50:32 <maerwald> you should!
09:50:41 <maerwald> https://hackage.haskell.org/package/selective
09:50:56 <maerwald> https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf
09:51:13 <solonarv> argument against adding it is, of course, that it isn't in base and very little code out there uses it
09:51:14 <oats> is it in the platform?
09:51:24 <dmwit> Others may bring that intuition into the discussion as well (or might not!). And if they do, "the result of the effect" will be a strange thought, because the result of the effect "update the state" is "there's a new state", not "we returned the value 3".
09:51:30 <dmwit> If that makes sense.
09:51:34 <maerwald> and here: https://neilmitchell.blogspot.com/2019/10/monads-as-graphs.html
09:51:38 <maerwald> also talks about selective
09:51:39 <solonarv> no, I don't think it's in the haskell platform either
09:51:46 <maerwald> Doesn't matter :)
09:51:49 <dmwit> e.g. in `put 3 >> return 4` the result of the effect is that the new state is 3; the result of the action is 4.
09:52:06 <maerwald> It's a crucial concept imo for understanding the differences
09:52:12 <maerwald> even if you don't use it
09:52:19 <maerwald> It shows what's between applicative and monad
09:52:29 <oats> dmwit: ahh, so are you thinking of "result" as describing what the effect did?
09:52:35 <dmwit> right
09:52:39 <oats> gotcha
09:52:47 <dmwit> well
09:52:48 <oats> like "the disk was written to"
09:52:59 <dmwit> I am thinking of "the result of the effect" as describing what the effect did. =)
09:53:13 <maerwald> yeah, the value might just be some informative "lol" string
09:53:16 <dmwit> If you say "result" alone I think of what pure value the action returned. =)
09:53:24 <oats> and I was thinking of "result of the effect" as the `a` in `m a` :P
09:53:26 <dmwit> Which is what spawned my initial objection.
09:53:30 <oats> finally we understand each other
09:55:07 <oats> maerwald: huh
09:55:15 <oats> so it's like monad but only "if ... else ... "
09:55:47 <dmwit> Anyway, if you're clear about the definition you have in mind before-hand it should be okay; and it might be possible to pick a different jargon to use to avoid the particular confusion I had. Some mix of those two solutions would probably work well.
09:55:48 <oats> actually, maybe only the `if` bit?
09:56:01 <maerwald> You can choose effects, but not freely depending on the value, but on an Either
09:56:06 <maerwald> select :: f (Either a b) -> f (a -> b) -> f b 
09:56:14 <Ariakenom> I thought result was clear. more than value because IO a is a value.
09:56:26 <maerwald> This allows static analyzing of possible effect trees, while still allowing flexibility. Not as powerful as monad, but
09:56:36 <oats> dmwit: I feel pretty comfortable with these ideas, but I've been chatting with some friends about this stuff lately, and I remember feeling the confusing and exasperation I see in their faces :P
09:56:57 <Ariakenom> sounds like you want a clear term to tell m a from the m
09:58:36 <solonarv> maerwald: the laws are also pretty important
09:58:50 <solonarv> because otherwise this is just <*> in a trenchcoat
09:58:55 <Ariakenom> I agree that going over what to call the parts of an action/effect/monadic value first seems important
09:59:53 <solonarv> laws: select (Left <$> x) f = liftA2 (flip ($)) x f; select (Right <$> x) f = x
10:00:21 <solonarv> the second law is the important one that makes this more powerful than Applicative
10:00:56 <dmwit> Ariakenom: Actually, my objection isn't to "result" but to "effect".
10:01:19 <dmwit> Ariakenom: "effect" is a specific part of an action for me. If the whole thing had been "result of an action" it would also have made complete sense for me.
10:01:57 <dmwit> Ariakenom: But again, that's partly me bringing my own understanding of the terms that make up the phrase to the table. If I treat the phrase as its own thing, unrelated to the meanings of its parts, then I agree the paragraph is sensible.
10:02:40 <Ariakenom> maerwald was the one objecting to result. I understood and shared your distinction
10:02:51 <maerwald> solonarv: I think the second one was controversial
10:03:11 <dmwit> heck!
10:03:23 <dmwit> Talking is hard. Thanks for hanging in there with me as I misunderstood you.
10:05:40 <oats> I also want to be careful not to accidentally tie the idea of monads and effects too closely together, though :P
10:06:01 <Ariakenom> oats: I think thats the first time I've heard a good explanation following a phrase like "is this a not-too-far-off-the-mark high-level description of functor/applicative/monad"
10:06:03 <Ariakenom> :D
10:06:58 <solonarv> maerwald: I remember it being controversial, yes
10:07:14 <solonarv> but isn't it the whole point of Selective?
10:07:17 <maerwald> and I don't think the "may skip effect" is what makes it more powerful
10:07:36 <maerwald> the idea was it *should* skip the effect
10:08:10 <Ariakenom> oats: its not uncommon and I was ready to say no but you surprised me. :))
10:08:12 <solonarv> otherwise you can just write an instance for every Applicative: select = liftA2 (\v f -> case v of Left a -> f a; Right b -> b)
10:11:46 <maerwald> solonarv: yes
10:12:29 <maerwald> "maybe skip the effect" is so wobbly
10:12:41 <maerwald> "Maybe I wrote to the file... maybe not"
10:13:33 <monochrom> Maybe the force with you
10:16:02 <nshepperd1> the idea is that it should skip the effect when you're actually running the thing, but not when enumerating the effect tree
10:17:24 <monochrom> That happens all the time.  Also, free monads make this explicit.
10:18:04 <monochrom> In fact, the whole point of effect, now that I think about it.
10:18:23 <nshepperd1> free monads don't provide a way to enumerate effects without running them
10:19:25 <monochrom> That probably just chalks up to: your "run" is different from mine.
10:20:13 <nshepperd1> that's why selective is based on applicative, not monad
10:20:19 <monochrom> But if the outcome of a program is completely pre-ordained, then it is a mathematical function or value by definition.
10:22:28 <monochrom> So the whole point of effect is "maybe the outcome is 5, maybe it's 6".  Note that this means maybe an output bit is 1, maybe it's not.
10:25:08 <monochrom> If the effect of outputting 1 in that bit position happens, that means the effect of outputting 0 in that bit position is skipped.
10:25:42 <nshepperd1> if the effect is downloading a file from the internet, you cannot determine what the next effect will be without downloading the file
10:25:43 <monochrom> Or even going back to the level of integers: If outputting 5 happens, then outputting 6 is skipped.
10:25:48 <nshepperd1> in a monadic framework
10:28:30 <oats> Ariakenom: hah, I hope it was a pleasant one
10:28:56 <Ariakenom> Sure was!
10:29:38 <monochrom> Downloading a file can be modelled by this highly-mathematical-style free monad: data D a = Pure a | GNB (Bool -> D a).  GNB = get next bit.
10:29:50 <monochrom> So this is a huge binary tree.
10:31:17 <monochrom> You are saying: One needs a big brain to comprehend such a big tree. One way may be walking down just one path of this tree, but then at each step someone has to say "go left" or "go right".
10:32:17 <monochrom> I'm saying: The whole tree exists mathematically, platonically, it's already there, "run" just means receiving external input to choose one path.
10:32:41 <monochrom> Similarly for the probability monad(s).
10:33:35 <nshepperd1> that seems pretty useless
10:33:41 <molossus_spondee> https://repl.it/repls/EveryDeadStructures so I think what I might want is a sort of compiler ir based on free applicatives, selectives etc does this make sense?
10:33:54 <monochrom> If you have a randomized algorithm, one view is you have to keep tossing coins at each crossroad.  But another view is a decision tree mapping out all possibilities, complete with probabilities.
10:34:13 <monochrom> Yes, tell people "decision trees are pretty useless".  Good luck with that.
10:34:35 <monochrom> Tell mathematicians "platonic existence is pretty useless".
10:35:47 <monochrom> The whole reason we benefit from mathematicians working out monads so we can use them is because they started with "monads exist platonically, even before you run anything".
10:37:51 <maerwald> monochrom: but the nodes of every subtree are as big as the domain of the value
10:38:00 <monochrom> I agree that comprehending a huge tree like this is hard and boils down to needing huge computational resource, be it a wet brain or a silicon computer.
10:39:21 <monochrom> But one can still prove some theorems about one particular tree, some theorems about a large class of trees, etc., and all these proofs are smaller than the trees.
10:39:42 <maerwald> maybe, but not that useful for GHC to push optimizations through, is it?
10:39:55 <monochrom> The proofs cannot possibly "run" the trees because the proof sizes are so much smaller.
10:40:29 <monochrom> I don't know why you bring up code optimizations, or why anyone always bring up code optimizations.
10:40:43 <nshepperd1> it's useless because the exponential explosion of branches means those computational resources would be better spent mining bitcoins
10:41:01 <monochrom> or bitcoins.
10:42:13 <monochrom> If someone discusses quantum computing and I chime in and say "did you know recently it is proved QIP = RE", people are suddenly going to say "so we can use it for code optimization right? and bitcoins right?".  They don't even need to know what's "QIP = RE".
10:43:56 <monochrom> With each program there are two things you always do.  One is to run it.  Another is you prove its input-output relation so you know why you're running it.
10:44:13 <nshepperd1> we were talking about writing actual Haskell programs that make an actual literal list of the effects that a thing will cause when executed
10:45:02 <monochrom> The tree form is one model that can inform both.  I don't say it's the only informative form, but it's one, and it brings to light one perspective.
10:45:34 <monochrom> Free monds, even my toy example, are used to write actual Haskell programs.
10:46:04 <nshepperd1> now read the second half of my sentence
10:49:40 <monochrom> I already know that.  I even said that myself, just using "big brain" for wording.
10:50:23 <oats> unrelated, are there any other neat monadic dualities out there, like how the Reader monad and the ((->) r) monad are two ways of looking at the same thing?
10:50:46 <monochrom> That one is equality, not duality.
10:51:09 <oats> please pardon my mathematically unrigorous speech :P
10:51:28 <monochrom> Stripping away Reader's data constructor, it's r->a again.
10:52:33 <monochrom> Duality is, for one example but it's pretty broad, when you compare (->)r and (,)r
10:53:13 <monochrom> Another example is when comparing covariant functor and contravariant functor
10:53:23 <oats> hmm
10:54:40 <maerwald> Ok, so: mac throws a different Error constructor than linux on some libc calls. What's the canonical way to unify?
10:54:51 <monochrom> "duality" is an informal word, but usually you have imagine (or contrive) some kind of flipping upside down, or leftsize right, or inside out, to call it a duality.
10:56:08 <maerwald> Like, I get PermissionDenied on mac and InappropriateType on linux
10:56:09 <maerwald> now what
10:58:16 <monochrom> I did prophesize a couple of days ago that one day you will have to make the difficult choice of giving up one of mac or linux. >:)
11:01:27 <maerwald> Nooo
11:01:45 <maerwald> Mac is the most difficult thing to support
11:02:10 <monochrom> More seriously, I chalk it up to the difference between linux and bsd, and these things are poorly documented or obscuredly.  I would bite the bullet and say empirically I've found that permission denied and inappropriate type are two possibilities, I'll handle both.
11:02:33 <monochrom> But take it with a grain of salt.  I haven't investigated or practiced this.
11:02:52 <maerwald> I'm actually unit testing all exceptions of my library :) so that's why I noticed
11:03:05 <maerwald> bc my pov is that a user might very well rely on that exception type
11:03:11 <monochrom> The closest I've come to is teaching a unix course that includes making some syscalls in C programs.
11:03:23 <maerwald> so now I put into my documentation "oh, on mac... it does this" :o
11:03:38 <monochrom> Oh! Yours is a library, is it?
11:03:49 <maerwald> Yes, the problematic piece currently is a library
11:04:10 <maerwald> Where mac started blowing up with memory errors on ffing to fdopendir
11:04:19 <monochrom> Then you document that your function is forced to have these two possibilities.
11:04:37 <monochrom> OK no one will read your doc so it's only an academic answer.
11:04:55 <maerwald> Ah. I think it would be good to say "may throw either this or this" without saying on what platform. So ppl just assume they must handle both at lal times.
11:05:11 <monochrom> Ah! Yes let them have cake.
11:05:13 <maerwald> monochrom: yes, I know... it's more about my OCD than about my users
11:05:19 <maerwald> :D
11:05:35 <maerwald> (what users...)
11:05:42 <monochrom> Or maybe you define your own exception type, and you do the translation.
11:05:50 <monochrom> haha
11:06:01 <maerwald> Yeah, but then I feel I should go all the way and not use any ghc/base exception types
11:06:04 <maerwald> And map everything
11:06:15 <monochrom> Oops.
11:06:32 <monochrom> (I opened a whole can of pandora worms.)
11:06:55 <maerwald> This will be a lot of work, I better get started.
11:07:04 <monochrom> And more pungently Haskell IO types don't list exception types.
11:07:24 <maerwald> monochrom: oh, I'll convert everything to open variants! haha
11:07:33 <monochrom> To a large extent we wouldn't be in this mess if Haskell were Java.  </heretic>
11:07:49 <maerwald> I like Javas exception system
11:07:54 <maerwald> It's just how ppl use it makes it trash
11:08:14 <monochrom> How dare you, are you talking about mine???!!!!!
11:08:34 <maerwald> "Oh, doesn't compile, lemme add an empty try catch"
11:08:40 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java
11:09:10 <monochrom> That one is a human problem, a PEBKAC.
11:09:25 <monochrom> The reason why I resist "we need more people converted to haskell".
11:09:28 <maerwald> I get cognitive overload from reading Java. Maybe I'm dumb.
11:09:43 <monochrom> mediocre people ruin everything, this explains the Java scene.
11:09:45 <maerwald> or just reading it wrong
11:09:48 <Rembane> maerwald: Then we can be dumb together 
11:10:22 <maerwald> Rembane: you taking me out or what? lol
11:10:42 * maerwald needs a break from macos madness
11:10:54 <monochrom> OK my url is TLDR I have a Nil 0-ary exception and a Cons 2-ary exception.  I use Java's catch for pattern matching.  I get a lazy list library going.
11:11:37 <monochrom> well, not library I guess, I've only coded up "map".
11:12:09 <Rembane> maerwald: Sure thing! :D
11:12:27 <Rembane> maerwald: We can stare at Java code and eat nachos. 
11:12:58 <monochrom> I also have an explanation why people (the intelligent kind this time) are inclined to just add an empty catch block.
11:13:34 <monochrom> Am I the only one who finds it's silly for "close file/handle/whatever" to throw a force-you-to-check exception?
11:13:53 <Rembane> Isn't that how Java is designed? 
11:14:05 <opqdonut> > Oh, doesn't compile, lemme add an empty try catch
11:14:06 <monochrom> 99% of my empty catch blocks are for just that.  I'm a good kid.
11:14:07 <lambdabot>  <hint>:1:3: error: parse error on input ‘,’
11:14:10 <opqdonut> psshh, as if anyone runs a compiler
11:14:21 <opqdonut> you just hit the autocomplete button on your IDE until there is no more red
11:14:42 <Rembane> That sounds like my experience with Agda. Proof by auto <3
11:14:47 <maerwald> I did that... it usually ends up in a circle at some point.
11:14:55 <monochrom> close-file is one of those things that 99% of the time it's OK to fail and you don't care.  For the 1% of the time someone cares, use a boolean return value already.
11:15:08 <monochrom> in fact, s/fail/"fail"/
11:15:12 <maerwald> bug2 -> auto fix bug2 -> bug1 -> autofix bug1 -> bug2
11:15:30 <Rembane> Then you can abstract that 
11:16:00 <Rembane> let bug3 = (bug2 -> auto fix bug2 -> bug1 -> autofix bug1 -> bug2) in bug3 -> ...
11:16:19 <monochrom> Rembane: Yes and no.  Java's exception system is designed to force you, yes.  But nothing says close must use the exception system.
11:16:42 <monochrom> I agree with the exception system.  I disagree with close using it.
11:16:45 <maerwald> hideAllErrors is a useful function
11:16:56 <Rembane> monochrom: Well, if you have a hammer, why not use it on everything? 
11:17:26 <monochrom> Hell if fact everything says close must not use the exception system.
11:17:59 <maerwald> monochrom: you mean a return value? You're aware there are almost none in Java?
11:18:13 <maerwald> You'd rather create a class and send the result via message passing to it
11:18:19 <maerwald> then have it piped through some setters
11:18:27 <monochrom> hahaha
11:18:50 <Rembane> class FileCloseStatus ...
11:18:58 <maerwald> omg stop
11:19:06 <monochrom> You started it :)
11:19:29 <[exa]> ClosedFileFactoryInterface
11:20:35 <maerwald> Not abstract enough, I want generics
11:20:50 <maerwald> class CloseStatus<StatusSource> ...
11:20:53 <maerwald> I forgot the syntax
11:21:07 <Rembane> We're just writing pseudo Java anyway 
11:21:21 <maerwald> My IDE will fix it
11:21:25 <maerwald> don't need to know syntax
11:21:28 <monochrom> Wow you even have generics going!
11:21:53 <monochrom> But you need to one-up the level.
11:22:04 <monochrom> class CS<SS extends CS<SS>>
11:22:38 <monochrom> (How do you like my extreme recursion?)
11:23:08 <maerwald> is that the type-level programming equivalent of java?
11:23:51 <monochrom> I think no such thing exists.
11:24:22 <maerwald> class Info<InfoType extends <InfoSource>>
11:24:29 <maerwald> I think I'm getting better
11:29:43 <monochrom> But recall "interface Comparable<T extends Comparable<T>>"
11:31:15 <monochrom> I might be making that up.
11:31:33 <maerwald> 🤮
11:35:27 <monochrom> Hrm!  I have an idea about indexed monads (I hope I'm using that term right).  Because I am thinking another representation of the probability monad(s).
11:36:46 <monochrom> You don't have to use a decision tree.  You can use [(Rational, a)] (or any fractional number type instead of Rational).  The intention is you list out the outcomes (of type "a") and respective probabilities.
11:37:49 <monochrom> What sucks is that some programs will give you [(0.5, 'x'), (0.3, 'x'), (0.2, 'x')] and in the long run it piles up and lead to gross inefficency.
11:39:44 <monochrom> The natural response is: let's foresake the standard monad class, go with mybind :: (Ord a, Ord b) => P a -> (a -> P b) -> P b.  So mybind has the tools for consolidation.
11:40:43 <monochrom> My idea is we can stay with the standard monad class, and don't impose the Ord constraint on >>=.  Instead...
11:41:02 <monochrom> Add an external function: consolidate :: Ord a => P a -> P a.
11:41:51 <monochrom> So instead of coding "foo `mybind` k", you code "consolidate foo >>= k".  (And in practice k is a big expression in which you use consolidate more times.)
11:42:03 <Cale> I've often done that...
11:42:13 <Cale> I have an example or two I can dig up...
11:42:32 <monochrom> So basically I have factored out an indexed monad into an ordinary monad and a normalization function.
11:42:34 <Cale> https://cale.l5.ca/Demos/Armory/Armory.hs
11:42:39 <monochrom> Can we do that to all indexed monads?
11:43:02 <Cale> hmm
11:43:34 <Cale> Well... you can always treat an indexed monad as a family of related monads
11:44:32 <Cale> Maybe you're only interested in restricted monads though
11:44:42 <Cale> ?
11:44:50 <monochrom> Oh!  Perhaps the correct term is restricted monads.
11:45:02 <monochrom> Can we do that to all restricted monads? :)
11:45:06 <Cale> Indexed monads are the ones where bind changes the type of the monad
11:45:15 <monochrom> Ah right. Yeah.
11:45:52 <Cale> It seems somewhat plausible that the answer is "yes" via Codensity
11:46:02 <monochrom> Neat.
11:47:29 <Cale> newtype Codensity f a = MkCodensity (forall b. (a -> m b) -> m b)
11:47:32 <Cale> oops
11:47:36 <Cale> newtype Codensity f a = MkCodensity (forall b. (a -> f b) -> f b)
11:47:47 <Cale> This is a monad whenever f is a functor
11:47:53 <Cale> hmm
11:48:45 <Cale> However, maybe you need some weirder restrictions just to make your thing into a functor in the first place
11:49:28 <Cale> It does seem likely that you can always just encode what you were planning to do using an unrestricted free monad (or a freer monad than the restricted one you were planning to use)
11:49:54 <Cale> and then implement some sort of thing that imposes the restriction in order to actually run the thing
11:50:14 <monochrom> Yeah, so far all the use cases are factorable as "mybind = bind then simplify"
12:08:51 <monochrom> Cale: It's very insightful of you to observe [(Rational, a)] = WriterT (Product Rational) [] a  :)
12:18:16 <Cale> monochrom: Yeah, it's nice :)
13:45:33 <hexagoxel> ah, a type alias of a polykinded type gets monokinded without polykinds in the module containing the alias.
13:45:56 <hexagoxel> s/without polykinds/without -XPolyKinds/
13:46:27 * hexagoxel puts one more rule to the rulebook of deciphering ghc error messages
13:49:37 <koz_> GHC's error messages are surprisingly clear and informative _if_ you know how to read them.
13:49:46 <koz_> (although I guess my only basis for comparison is GCC/Clang)
14:04:46 <sm[m]> indeed. And they often get a lot better if you add more type signatures
14:05:23 <sm[m]> but there's always room for improvement 
14:09:43 <yushyin> a 'how to read ghc error messages as a beginner' would be such a good resource for newcomers
14:10:41 <sm[m]> google finds some stuff for that
14:14:08 <hpc> a lot of ghc error messages is just human readability, ironically
14:14:23 <hpc> the bits you really care about are the line and column number which are right at the start
14:14:30 <hpc> then the expected/got blocks in the middle
14:14:32 <solonarv> there's that new ghc proposal to add error codes, like rustc has
14:16:39 <hpc> my first thought on error codes is "that's a good idea", but my second thought is "... but why? i would never use them"
14:17:10 <hpc> i guess so you can have an exhaustive list of possible errors for documentation or whatever
14:17:28 <yushyin> they are very easy to google!
14:18:07 <sm[m]> yes, or to communicate in support conversations
14:18:29 <fendor> rustc also has extensive explanations of each error code
14:18:39 <sm[m]> also useful for analysing error frequency, organising docs, etc.
14:18:44 <fendor> with examples and ascii art illustration
14:19:32 <merijn> hpc: The main argument was for tools, it's easier to handle error codes than (possibly changing) textual strings
14:20:15 <merijn> In fact, the main point was adding error codes to the GHC API, not even necessarily to the actual messages
14:26:15 <solonarv> it's easy enough to add them to error messages, and they increase "googlability" SO MUCH
14:35:19 <hexagoxel> First error »Expected kind ‘* -> *’, but ‘P n Identity’ has kind ‘*’« second error »Expected a type, but ‘Identity’ has kind ‘* -> *’«
14:36:12 <hexagoxel> There are a few steps from there to the constructive »type alias P is defined without -XPolyKinds, maybe change that?«.
14:37:02 <hololeap> I'm looking for any opinions on lucid vs blaze-html
14:37:02 <hexagoxel> (to be clear, I am not at all complaining about the quality of the error message. But it _is_ tricky, unless you have the right mental triggers.
14:37:05 <hexagoxel> )
14:41:49 <dmwit> Could be better. But to be fair to the GHC devs, PolyKinds may very well not have existed at the time that error message was first crafted.
14:42:33 <hexagoxel> it would be really nice if there was a warning on the type alias itself. The code/context where this problem surfaces is not that important
14:43:34 <hexagoxel> »warning: RHS is polykinded, but you type alias is monokinded. Either enable PolyKinds or put an explicit kind signature«
15:00:50 <koz_> What's the cool kids' Text-based pretty-printing library these days?
15:03:00 <phadej> prettyprint
15:03:02 <phadej> er
15:03:40 <Uniaika> I use Text.Pretty.Simple.pPrint in my REPL
15:03:54 <Uniaika> stack ghci --ghci-options "-interactive-print=Text.Pretty.Simple.pPrint -fobject-code" --package pretty-simple
15:03:57 <Uniaika> quite useful
15:04:08 <koz_> phadej: This one here? http://hackage.haskell.org/package/prettyprinter
15:04:30 <phadej> koz_: yeah
15:05:06 <maerwald> hmm, can I tell cabal freeze to not freeze flag constraints?
15:05:17 <koz_> phadej: Thanks! Uniaika - I guess you're _not_ suggesting that one?
15:05:34 <maerwald> I build my package once without a flag and once with
15:05:45 <maerwald> Don't want two freeze files
15:05:53 <Uniaika> koz_: as a matter of fact I do suggest that one
15:06:00 <koz_> Uniaika: Oh, awesome. Will use then.
15:06:02 <Uniaika> (if by one you mean pretty-simple)
15:06:25 <koz_> Uniaika: I was checking out phadej's suggestion, which is prettyprinter. Will look at pretty-simple.
15:06:41 <Uniaika> check out both of them
15:06:45 <Uniaika> :)
15:07:46 <phadej> oh those are different
15:08:00 <phadej> pretty-simple is to output Haskell types, prettyprinter is to output "stuff"
15:08:16 <koz_> phadej: "stuff" is exactly my use case.
15:14:06 <koz_> Is there a 'downcasing' function for Data.Text.Prettyprint.Doc.Doc?
15:15:23 <monochrom> Are you thinking of getting a string?  Maybe the Show instance already does it?
15:16:16 <koz_> monochrom: The default 'pretty' for Bool gives 'True' or 'False'; I want it to be 'true' and 'false'.
15:17:22 <koz_> I guess I could pattern match and pretty a Text or something, but it seems.. a bit silly.
15:21:09 <dsal> Just run your program through tr
15:21:24 <koz_> dsal: Rofl.
15:24:20 <dmwit> Pattern matching doesn't seem silly to me.
15:24:41 <dmwit> It is like 30% of what makes the language great.
15:29:32 <svipal> is using pattern matching on text actually ok ?
15:29:38 <svipal> performance wise
15:29:46 <svipal> *I don't know how OverloadedStrings work
15:29:52 <peutri> by test you mean String?
15:30:02 <svipal> I mean Text
15:30:13 <svipal> from Data.Text
15:30:24 <peutri> i suppose it's fine if you figure out how to do it then
15:30:26 * Uniaika misses pattern-matching on binaries from Erlang
15:30:46 <monochrom> koz_: Oops! My confusing answer is explained by: I misread "casing" as "casting".
15:31:21 <koz_> monochrom: Lol, don't worry about it.
15:31:49 <Uniaika> koz_: if you're operating on JSON there's this neat library that allows you to define type-level transformers to ToJSON instances
15:31:54 <monochrom> "Can I change the case?"  "Yes, you can convert between types."  "Thanks... wait, what?"
15:31:56 <Uniaika> is that what you're looking for?
15:32:45 <koz_> Uniaika: Nope. I just want 'pretty' to turn Bools into all-lowercase instead of capital-case. I just did it by pattern matching, no big.
15:33:46 <Uniaika> yeah I guess it's the best way to do it right now :)
15:35:21 <pie_[bnc]> whats a fully saturated typeclass?
15:35:39 <pie_[bnc]> Im guessing a typeclass with its parameters filled
15:37:59 <koz_> pie_[bnc]: In what context?
15:38:04 <monochrom> Yes but unsaturated type class has never been allowed, I think.
15:38:59 <monochrom> Oh wait, it is now. Nevermind.
15:40:43 <Chorhizo> I can't seem to figure out why I'm getting a compiler error here. I was following/copying from the websockets example server (https://github.com/jaspervdj/websockets/blob/master/example/server.lhs), but I'm getting a variable not in scope for `conn` in my where clause. I'd assume this is obvious, I'm just a bit lost. Here's the snippet:
15:40:43 <Chorhizo> https://gist.github.com/PotterJam/b8205659c3f7c6f7a83a2e77d3bcd7af
15:41:16 <pie_[bnc]> koz_: ```Constraint Kinds
15:41:16 <pie_[bnc]> However, kinds apply to everything at the type-level, not just the things we traditionally think of as “types.” For example, the type of show is Show a => a -> String . This Show thing exists as part of the type signature, even though it’s clearly not a TYPE . Does Show a also have a kind? Yes! Its kind is CONSTRAINT . More generally, CONSTRAINT is the kind of any fully-saturated typeclass.```
15:42:00 <koz_> pie_[bnc]: Ah, Sandy's book.
15:42:09 <koz_> Yeah, that's exactly right then.
15:42:17 <koz_> Similar language gets used for type families later as well.
15:42:45 <monochrom> Chorhizo: It's true, your "where" is attached to "application state pending =", not part of the stuff after.  It doesn't see "conn".  You can't use "where" like this.
15:43:09 <monochrom> Moroever, IMO whoever indents "where" this way is criminal.  It's totally misleading.
15:43:56 <Chorhizo> monochrom: I thought it would be something like that. But I'm wondering why in the example project they show it like that? Is that something to do with .LHS files?
15:44:13 <monochrom> No, .lhs doesn't change this.
15:45:57 <monochrom> Instead, they have a "case ... of" that you don't.
15:46:42 <Chorhizo> I just noticed that, thanks! Are there specific things I should be looking for to know where a where block will be scoped?
15:46:53 <monochrom> It's true, "case ... of { Just x -> y where y=x+1 ; ... }" is allowed and "y=x+1" sees that x.
15:47:33 <Chorhizo> I think it's just confusing me because of the lack of braces
15:47:48 <monochrom> If every programmer were not criminal, all indentations would be helpful and you could just tell by indentation.
15:48:17 <Chorhizo> Haha, to trust every programmer is a dangerous game
15:48:40 <monochrom> But most programmers are criminal.  You have to know the syntax inside out, and then you have to read very carefully, a Hamming distance of 1 can break everything.
15:49:04 <monochrom> If you read my code you will never be betrayed.
15:49:25 <monochrom> But it's me alone against reckless inconsiderate humanity.
15:49:44 <svipal> If you read my code you will never be betrayed, because I will warn you in advance it's trying to kill you.
15:49:59 <svipal> actively. With every choice of implementation.
15:50:52 <Chorhizo> Me and you both, svipal
15:51:04 <monochrom> I think by that point you say "implements". >:)
15:52:17 <monochrom> Let's play Clue over Zoom or something!
15:55:07 <infinity0> i'm writing some toy code and need to lift an unlifted type, how do i do that?
15:55:29 <maerwald> merijn: there are two fdopendirs https://opensource.apple.com/source/Libc/Libc-1244.1.7/include/dirent.h.auto.html
15:55:31 <maerwald> :>
15:55:39 <maerwald> one crashes, one doesn't
15:55:44 <solonarv> infinity0: wrap it in a 'data' type
15:56:08 <monochrom> Yeah. Example: "data Int = I# Int#".  Int# is the unlifted type there.  Int is lifted.
15:56:15 <infinity0> ah ok, thanks
15:56:35 <solonarv> data FooBox = FooBox Foo -- now FooBox :: TYPE 'Lifted, but Foo :: TYPE q and q can be anything
15:56:58 <maerwald> when you use ccall it ends up doing a syscall to fdopendir it seems, so you gotta use the capi instead
16:03:00 <infinity0> cool, here we go: https://github.com/mstksg/mutable/issues/2#issuecomment-613722561
16:03:14 <svipal> peutri :
16:03:20 <svipal> I didn't understand your question
16:03:25 <svipal> your remark*
16:03:37 <svipal> you can pattern match on Text just fine with OverloadedStrings enabled
16:03:46 <svipal> you made me worried for a minute so I checked
16:04:14 <svipal> so yeah; reasking : is it ok in terms of performance to do it a lot in a program ?
16:11:44 <monochrom> infinity0: I don't fully understand, but it looks evil :)
16:17:17 <infinity0> monochrom: it's just a demonstration that mutable references are lens can concretely be represented as each other
16:17:31 <infinity0> i think people generally understood they were sort of the same thing but i didn't see a concrete conversion in code yet
16:17:56 <monochrom> Ah, yes.
16:18:18 <infinity0> so for example IORef can be represented as an actual Lens, and probably STVar etc too
16:18:25 <infinity0> er, TVars etc
16:18:26 <monochrom> One way people explain lens is "first-class reference".
16:23:16 <solonarv> oh, this is neat
16:31:25 <infinity0> yeah, one downside about hiding all these details of IO is people can't develop their own abstractions on top, in an ideal world we could work towards unifying lens and references
16:31:48 <infinity0> i mean, abstractions that integrate properly with IO as a state-monad
16:43:57 <d34df00d> Hi!
16:44:06 <d34df00d> I think this is the right place to ask a sort of CT question.
16:44:18 <yushyin> maybe
16:45:30 <d34df00d> So I know that fibered product of f : X → Z, g : Y → Z in Set is a subset of cartesian product, namely, { (x, y) | f(x) = g(y) }.
16:46:02 <d34df00d> But first time I did an exercise on "what is a fibered product in Set" this rather dawned on me, while I'd like to know if there is a systematic way of deriving this.
16:46:04 <d34df00d> So, is there one?
16:52:20 <ja> is there something preventing library authors from making a revision with fixed base bounds, and then when they make the next release, they accidentally revert to old base bounds because revision changes don't go into the source code?
17:07:38 <monochrom> Data.Sequence takes up a lot of space.  I have Seq Int.  Basically n*100 bytes on 64-bit.
17:08:24 <monochrom> For example I did fromList [1..5000000] and it's 500MB
17:08:30 <monochrom> 499MB but meh
17:10:21 <monochrom> ja: Right, no, but I hope that authors revise it in-place on hackage because they already change it in their own source tree.
17:11:38 <svipal> what's the sequential data structure that takes the least space ?
17:12:19 <solonarv> Vector, probably
17:12:22 <solonarv> or something like it
17:12:24 <monochrom> Vector.Unbox, IUArray, GHC primitives.
17:13:04 <monochrom> I am investigating Data.Sequence because I have a FIFO case.
17:13:11 <svipal> IUArray ? ..
17:13:58 <monochrom> Err, UArray.  Look for Data.Array.Unboxed.
17:14:28 <solonarv> basically the same as Data.Vector.Unboxed over in vector
17:14:56 <solonarv> just with a much smaller API in return for slightly fancier indexing that you hardly ever need anyway
17:15:01 <ja> monochrom: indeed Snoyberg and Löh did both do that, so I guess it's all right. But would be interesting to automate this since it would probably almost always be an error to have a subsequent version downgrade the base version
17:18:37 <monochrom> By chance, do you know what's changed between cabal-install 3.0 and 3.2?  Or where can I read it?
17:19:47 <int-e> monochrom: Hmm, that's a bit larger than I'd expect; the Seq data structure itself should take 300 to 320 MB (plus 80 MB for the boxed Int values).
17:20:43 <ja> monochrom: If you're asking me, no, I really don't. But you can't specify version 3.2 in a cabal file using cabal-install 3.2, so at least the syntax didn't change :P
17:21:25 <int-e> But yes, that's almost 3x more overhead than with a plain list, unless there's a lot of sharing.
17:23:27 <monochrom> Err I made the same mistake again!  I do not know that Seq Int is n*100 bytes.  I only know that the RTS allocates n*100 bytes.
17:24:24 <monochrom> The irony is that I also know that GC uses double-buffering so in all likelihood it's n*50 bytes in active use.
17:25:04 <int-e> But my math is wrong too. I should have had 100MB to 160MB, plus 80MB.
17:25:28 <monochrom> Int is n*16, not n*8, actually, on 64-bit.
17:25:41 <int-e> monochrom: yes?
17:25:48 <int-e> you had 5M elements.
17:25:51 <monochrom> "data Int = I# {- 8 -} Int# {- 8 -}
17:25:58 <monochrom> Oh! OK you're right.
17:26:29 <monochrom> Bah next time I'll do 10 million so I'm not tricked.
17:29:52 <monochrom> Haha [Int] is n*(8+8+8+8+8) so it is not exactly much better.
17:31:29 <monochrom> Handwritten "data L = N | C !Int {-# unpack #-} L" can get it down to 8+8+8.  It is not clear whether I should bother.
17:34:11 <monochrom> I have a cunning plan!  Run virtualbox; inside, run a 32-bit linux and 32-bit GHC.  This accomplishes s/8/4/
17:38:32 <int-e> monochrom: If the goal is to conserve memory, storing chunks in an UArray should work decently well (so something like ([Int], Seq (UArray Int Int), [Int]), where the inital list is what you're currently consuming, and the last list is what you're accumulating, and you'd create a new item in the Seq when the latter list reaches a predetermined size.
17:38:57 <int-e> monochrom: you can even use Int32 elements then, if that's all you need.
17:39:14 <monochrom> Oh! That's smart, yeah.
17:41:05 <int-e> (Possibly replace UArray by Vector)
17:42:03 <monochrom> To a large extent ([Int], [Vector], [Vector], [Int]) is close enough :)
17:44:25 <monochrom> yo dawg you heard I love functional FIFO so you put a coarse-level functional FIFO in my fine-level functional FIFO
17:59:14 <freeman42x[m]> the chars here: `[32m✓[39m` around the `✓` seem to be for the purpose of coloring. any idea if there is any Haskell function that would filter out any coloring applied to a Text ?
17:59:50 <Axman6> monochrom: https://hackage.haskell.org/package/unpacked-containers might be useful, though currently there's no Seq alternative, it could be added relatively easily
18:00:21 <hpc> freeman42x[m]: are you mirc color codes or shell color codes?
18:00:24 <hpc> *detecting
18:01:24 <freeman42x[m]> hpc: they are outputted by `apm` (atom package manager), so shell color codes
18:01:51 <hpc> hmm
18:03:32 <hpc> some casual hoogling isn't finding anything
18:04:21 <koz_> hpc: 'Casual hoogling' sounds hilarious in any other context.
18:05:45 <freeman42x[m]> this might be it: https://gist.github.com/nkpart/5915408
18:06:44 <hpc> that looks close, i think it's missing a bit
18:07:18 <hpc> [0-9] should at least be [0-9;]
18:08:14 <Axman6> monochrom: also, not pure, but https://hackage.haskell.org/package/unagi-chan-0.4.1.3/docs/Control-Concurrent-Chan-Unagi-Unboxed.html might also be useful
18:09:46 <ski> s/shell/terminal/
18:11:25 <freeman42x[m]> they are ANSI color codes from what I could find
18:13:16 <Axman6> I'm surprised to not find a Vector backed queue of some form - I wonder if there's a sensible way to implement Data.Seq backed by unboxed vectors of the contained type (and with less indirection, though that would probably mean more copying))
18:16:41 <koz_> Axman6: You could, at the risk of not being a Functor and friends.
18:17:03 <koz_> You may or may not care about that.
18:17:25 <Axman6> I feel like this talk was also very relevant: https://www.youtube.com/watch?v=6nh6LpcXGsI
18:17:52 <freeman42x[m]> yeah, so they are here: https://gist.github.com/AHaymond/e96f00ed0ba64a9af419296bf852c5bb#regular-colors
18:17:52 <freeman42x[m]> 32m makes the tick mark green and 39m is gray which is original shell color
18:22:54 <pie_[bnc]> hot take: functional programming is not programming but actually just encodings gymnastcs
18:23:48 <koz_> pie_[bnc]: That's a lukewarm take at best.
18:24:00 <koz_> _All_ programming is just encoding gymnastics really.
18:27:00 <pie_[bnc]> disclaimer, im not being particularly serious;
18:27:11 <pie_[bnc]> take as an example that classical programmers dont use inductive lists 
18:27:43 <pie_[bnc]> or peano nats
18:27:46 <koz_> pie_[bnc]: ... considering linked lists are inductive by their very definition, that's a pretty big claim.
18:27:52 <pie_[bnc]> (i forgot what its called, is that what its called?)
18:27:54 <koz_> I guess you meant ADTs.
18:28:09 <pie_[bnc]> nah ok, ive never written a linked list
18:28:25 <koz_> Good, because it's singularly not fun using pointer manipulation.
18:28:31 <pie_[bnc]> im self-taught-programming-illiterate
18:28:42 <Axman6> the linux kernel is full of them, they've got a pretty cool header only library for working with them IIRC
18:28:46 <pie_[bnc]> im imperatively illiterate
18:29:02 <nshepperd2> classical programmers don't use linked lists
18:29:16 <nshepperd2> a sure example of quantum supremacy!
18:29:16 <pie_[bnc]> compass and straightedge represent
18:29:20 <yushyin> Axman6: oh yeah kernel linked list is a nice one
18:30:06 <koz_> nshepperd2: Are you parodying a certain occasional visitor?
18:30:41 <pie_[bnc]> xD
18:30:48 <Axman6> https://kernelnewbies.org/FAQ/LinkedLists for anyone interested
18:31:35 <pie_[bnc]> > , to encounter redundant code managing classical data structures
18:31:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘,’
18:31:41 <pie_[bnc]> wow
18:32:34 <pie_[bnc]> i guess the greeks did know a thing or two
18:38:51 <dmwit> Peano nats are trash anyway. Most functional programmers don't use them either.
18:39:11 <nshepperd2> there's something really impressive yet tragic about the amount of programming expertise involved in producing a halfway passable workaround for not having generics
18:40:08 <dmwit> freeman42x[m]: The best is for the program that's emitting them to not do that.
18:40:20 <dmwit> freeman42x[m]: Most command-line applications have a flag to avoid colors.
18:40:34 <dmwit> freeman42x[m]: Perhaps you should do a bit of searching in the apm documentation.
18:42:07 <dmwit> freeman42x[m]: ...and then, if you find something, consider adding what you found to https://no-color.org/ =)
18:42:12 <freeman42x[m]> dmwit: I crown you XY Problem King and thank you for such a simple solution
18:43:33 <dmwit> ^_^
18:53:01 <pie_[bnc]> i ocasionally have the reverse problem of trying to figure out how to enable the colors when piping to less
20:05:00 <hololeap> has anyone else noticed how easy it is to integrate beam and servant?
20:10:18 <pie_[bnc]> beam?
20:10:37 <pie_[bnc]> oh
20:11:05 <Axman6> I hadn't noticed beam being particularly easy to do much with, as much as I like it
20:13:31 <hololeap> yeah, check out this example: http://dpaste.com/1XGRW3G
20:13:49 <hololeap> i'ts a WIP but if i run it and query /users, it pulls it from my postgresql db
20:16:43 <Axman6> yuo definitely want to make a single connection object and share that with all your calls to the database
20:17:23 <Axman6> doesn't really look like there's much interaction between the DB and web side of things
20:18:25 <pie_[bnc]> woah thats weird xD https://a.uguu.se/DNYKuskUuUns.png
20:19:23 <hololeap> here, i cleaned it up a bit: http://dpaste.com/0C17DR4
20:20:12 <hololeap> the UserAPI class defines the API and `server` is what hooks it to beam
20:20:20 <pie_[bnc]> i dont suppose anyone has implemented something that preprocesses a haskell file and only shows you type information, as a sort of terser thing for a quick skim of a file?
20:20:33 <pie_[bnc]> s/pre//
20:20:50 <hololeap> i guess it's too early in my learning to say much, but it seems like they fit together really well
20:21:24 <hololeap> *UserAPI type
20:22:37 <hololeap> i can take the type needed for beam and make a ToJSON instance for it, and it just plugs into servant
20:42:04 <sm[m]> pie_[bnc]: I did, a sort of fancy grep of type signatures. I dropped it pretty soon
20:42:51 <sm[m]> Your editor probably has a search/grep feature that’ll work well
20:48:03 <nitrix> Hi. I'm back. After nearly three years away from Haskell, I just realised that I'm craving a really good type system, controlling effects and writing in a declarative style.
20:52:10 <Axman6> Welcome back to the fold my son/daughter/non-familial-progeny
20:55:24 <pavonia> Haskell – the Hotel California of programming langauges
20:55:35 <nitrix> I think I had to go full circle to truely appreciate the language for what it is.
20:56:05 <nitrix> Let's hope I did not forget too much and that I can start contributing to the community again soon :)
20:56:19 <Axman6> pie_[bnc]: there's :browse in ghci
20:56:39 <sm[m]> welcome back! Enjoy improved tooling
20:57:26 <Axman6> Can't tell if that was a joke or not
20:58:24 <sm[m]> Axman6 me neither. Inner conflict as I typed it :) nitrix: maybe not quite as improved as you hoped
20:59:10 <nitrix> Well, what changed? Is cabal and stack still competing?
20:59:29 <sm[m]> but if it has been a few years, well we sort of fixed cabal hell mostly. Yes they are
21:00:00 <nitrix> Have some of the GHC extensions made it to the language or it's still the old Haskell 2010 report?
21:00:23 <Poscat[m]> Hi, my email request for Hackage uploading permissions got rejected by the mail server, what should I do?
21:00:31 <Poscat[m]> It says "rejected: Message rejected due to: SPF fail - not authorized"
21:01:20 <sclv> send from a different account?
21:01:38 <Axman6> you could try asking in #hackage or #haskell-infrastructure
21:01:45 <ja> Poscat[m]: try sending from a webmail account like hotmail or gmail, they usually have their SPF records in order
21:02:09 <ja> Poscat[m]: SPF is a filter on which IP addresses that can send from a domain
21:02:21 <nitrix> sm[m]: I saw someone use new cabal commands. I'll have to see what that's about. Seems a bit confusing to me to have two set of commands.
21:02:39 <Poscat[m]> k thanks, I'll try to use gmail then
21:03:01 <sm[m]> It is. Read the manual so you don’t get confused
21:03:40 <Axman6> When I moved my email to fastmail and my own domain, I was very happy with how easy they made the instructions for setting up things like SPF properly. Didn't stop Google blocking my emails occasionally though
21:04:17 <sm[m]> cabal has picked up some stacklike features. Stack is still good. Ghcid is better. There’s a string of “ide” components that make in editor type hints work for some people
21:05:19 <nitrix> There's an LSP server, neat.
21:09:49 <pie_[bnc]> nitrix: want to waste^Wspend a couple months on Nix(OS)? :D
21:11:00 <pie_[bnc]> yeah the ide stuff seems to have taken off a bit (recently?) I wonder what happened ther
21:12:45 <MarcelineVQ> ghcid is the bees knees for nonintrusive help
21:15:09 <pie_[bnc]> MarcelineVQ: srs bzns
21:15:53 <MarcelineVQ> :browse will show you type info for a module fwiw
21:16:08 <MarcelineVQ> I ​don't find it so readable in my terminal tho
21:17:08 <sm[m]> nitrix: how long have you been away ?
21:17:13 <MarcelineVQ> but on a wider one it's probably fine
21:17:20 <nitrix> MarcelineVQ: Hello o/
21:17:24 <MarcelineVQ> h
21:18:48 <nitrix> sm[m]: About four years. Enough to forget some of the basics.
21:20:36 <sm[m]> kind of hard to say what else has changed. Just a general upswell on all fronts but I’m not thinking of anything dramatic .. anyone else ?
21:21:40 <nitrix> Oh I'm fine with the language staying what it was, don't worry :)
21:22:16 <nitrix> Actually, I wonder if...
21:22:19 <nitrix> :t map
21:22:21 <lambdabot> (a -> b) -> [a] -> [b]
21:22:22 <sm[m]> lots more type level programming features I guess
21:22:51 <nitrix> Myeah, no, still the specialized one :P
21:54:36 <crestfallen> http://ix.io/2i6X   Hi in this program I'm getting the following error (under comment line) : semiGroup.hs:22:3: error: Parse error in pattern: mappend
21:55:39 <crestfallen> the line mappend _ <> other = other
21:57:01 <crestfallen> any ideas?
21:58:25 <MarcelineVQ> What is the difference between that line and the previous one which did not have an error?
21:59:49 <crestfallen> well yeah the <> operator is not used
22:00:26 <MarcelineVQ> So now do you have any ideas?
22:01:36 <crestfallen> It was an example that seemed to be received well on reddit, so I thought it was something deprecated due to the post's age (4 years) thanks MarcelineVQ 
22:01:56 <crestfallen> I'm trying it now..
22:06:13 <nitrix> :t mappend undefined undefined undefined undefined undefined undefined
22:06:14 <lambdabot> Monoid t => t
22:06:37 <nitrix> Is that because of the Monoid (a -> b) instance?
22:09:02 <MarcelineVQ> afaict yeah, and there's a lot going on each step there really, you can write  :t mappend `asAppliedTo` undefined   and keep stacking undefined's on the left if you want to see a bit of it
22:10:36 <MarcelineVQ> Monoid b => Monid (a -> b)  is also why accidenlty applying mempty to something can catch people too
22:10:38 <crestfallen> still having trouble ... :
22:11:47 <crestfallen> http://ix.io/2i70   this also fails with the error:
22:12:11 <crestfallen> No instance for (Semigroup (FirstExisting a))  arising from the superclasses of an instance declaration    In the instance declaration for ‘Monoid (FirstExisting a)’
22:14:06 <MarcelineVQ> That means your ghc/base is new enough that Semigroup has been split off from Monoid, so you need to define Semigroup and Monoid separately for FirstExisting. iirc this means defining <> for Semigroup _instead of mappend for Monoid_ and then just definining mempty for Monoid
22:16:35 <MarcelineVQ> hmm I think alternatively you can define Monoid as you have, and define <> for Semigroup as (<>) = mappend
22:17:49 <crestfallen> I commented the mempty and it compiled...
22:18:35 <crestfallen> but that wouldn't need a unit value?
22:24:55 <MarcelineVQ> If you have a question you'll need to show the code you have now since I don't know what changes you've made
22:30:22 <crestfallen> thanks one sec I'm having a rough time
22:41:18 <crestfallen> MarcelineVQ, so there's no unit, there's only the case FirstExisting Nothing <> _ = FirstExisting Nothing      as in: http://ix.io/2i74
22:42:40 <crestfallen> if that's true, I don't know what they were trying to do with (<>) _ other = other
22:47:37 <crestfallen> it looks wrong but it works I guess
22:52:14 <crestfallen> no comment MarcelineVQ ?
23:00:00 <crestfallen> THANKS good night
23:03:27 <MarcelineVQ> was havin dinner
23:43:30 <anonymous123> hi everybody... supposing there is a class "class Documentation m where doc :: String -> m"
23:43:39 <anonymous123> and there are 2 monads M1 and M2
23:44:16 <anonymous123> I'm trying to make 'doc' callable for both M1 and M2 by providing instances: "instance Documentation (M1 ()) where doc = ..." and the same for M2
23:45:00 <anonymous123> however I'm getting an "Ambiguous type variable ‘a3’" error message when doc is used in a do block
23:45:28 <anonymous123> is there any example of this that i can find online?
23:48:38 <[exa]> anonymous123: can you paste a minimal (non)working example of this?
23:58:24 <anonymous123> [exa] thanks for the reply... I'm working on it :)
