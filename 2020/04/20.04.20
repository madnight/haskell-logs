00:26:23 <earthy> slight corrections: it was based on graph rewriting rather than term rewriting, and when it was 'just' a back-end it was still called lean, as in 'Language of East-Anglia and Nijmegen'.
00:28:42 <random__> hey guys, could anyone tell if what I'm trying to do is possible?
00:28:44 <random__> https://pastebin.com/GKXacUsG
00:29:19 <random__> it compiles fine, but then I get an ambiguous type error when defining an instance of SomeClass
00:29:39 <random__> I have no idea how to specify a type parameter for a default signature, though
00:32:18 <ziman> can you make a minimal example and paste the exact error message?
00:32:29 <ziman> this looks like it should work
00:32:57 <random__> yes, just a moment
00:33:16 <earthy> nitrix: you might want to look into e.g. https://nms.kcl.ac.uk/maribel.fernandez/TERMGRAPH.html 
00:33:33 <earthy> and the work by e.g. https://www.cs.vu.nl/~femke/
00:44:21 <random__> @ziman: here's a minimal repro
00:44:21 <lambdabot> Unknown command, try @list
00:44:25 <random__> https://pastebin.com/sGMuWUqK
00:44:43 <random__> ziman: ^
00:45:06 <random__> hopefully the naming is not too confusing lol
00:51:14 <random__> and if this isn't possible, why does GHC allow it
00:58:39 <pavonia> random__: What type should be applied to the default instance?
00:58:58 <random__> pavonia: SomeId
00:59:54 <pavonia> Ah
01:00:45 <random__> yeah that's what confusing me
01:01:01 <random__> you're allowed to have a `forall whateverType` in the default signature
01:01:05 <random__> but it appears you can't use it
01:01:34 <pavonia> I don't think this would work without having the first type "stored" somewhere. What should it be if there's e.g. another instance "AnotherClass AnotherId SomeEntity"
01:01:45 <random__> exactly
01:01:59 <random__> so there should be a way of explicitly specifying the `b` type
01:02:46 <random__> I mean, the obvious "hack" would be to just separate the default definition and use TypeApplications
01:03:07 <random__> but then you kind of lose the whole "this is what's you're supposed to use for a default"
01:06:07 <dramforever> random__: Haven't tried, maybe put this outside: aFuncDefault :: forall b. ...; aFuncDefault = getSomething @b 
01:06:17 <dramforever> and have aFunc = aFuncDefault
01:08:10 <dramforever> https://pastebin.com/sGMuWUqK it compiles fine for me on 8.8.3
01:08:33 <dramforever> (after I add a module header to stop complaints about 'main')
01:08:36 <random__> yeah
01:08:44 <random__> that's what I commonly use
01:08:55 <dramforever> It compiles fine
01:09:02 <random__> yeah that works but I was wondering
01:09:06 <random__> if you can compile the default one
01:09:09 <random__> can you actually use it
01:09:16 <dramforever> No no no
01:09:23 <random__> sadly it appears so
01:09:25 <dramforever> wait
01:09:37 <dramforever> This paste: https://pastebin.com/sGMuWUqK
01:09:43 <dramforever> You want to get it to work, right?
01:09:56 <random__> yes but with DefaultSignatures
01:10:19 <random__> the question is
01:10:25 <random__> is it possible to make it work with DefaultSignatures
01:11:07 <dramforever> It seems that yes with GHC 8.8.3
01:11:13 <random__> oh
01:11:17 <random__> I'm on 8.6.5
01:11:28 <dramforever> I didn't change anything other than putting a module X where
01:11:38 <random__> but did you uncomment the last line
01:11:54 <random__> I don't think it's logical for it to work because if there were multiple instances of AnotherClass
01:11:58 <dramforever> Ah
01:11:58 <random__> it couldn't know which one to use
01:12:15 <dramforever> Oops didn't notice that it was Haskell code :P
01:12:26 <dramforever> Yeah should have read the whole thing
01:12:42 <dramforever> I thought you were complaining that line 13-14 wasn't working
01:12:56 <remexre> huh, ghcide just stopped being able to find Hedgehog in my library... (not test-suite, already saw that bug)
01:13:02 <random__> nah I'm just wondering
01:13:09 <remexre> cabal v2-build shows no problems
01:13:32 <random__> dramforever: just out of curiosity, what language did you think it was
01:13:57 <dramforever> I thought it was more English following line 33
01:14:15 <random__> ah
01:14:19 <random__> yeah sorry about that lol
01:14:57 <ziman> random__: if I add a fundep a->b to AnotherClass, it works
01:15:21 <random__> ziman: hm, I haven't really used functional dependencies
01:15:26 <random__> ziman: can you paste a snippet?
01:16:17 <ziman> https://gist.github.com/ziman/367854fef76711140c6ec9b82f2fd0ea
01:16:25 <ziman> the only change is on line 15
01:16:33 <ziman> (plus pragma on line 6)
01:16:56 <random__> haha shit, Haskell is so much fun
01:17:06 <ziman> your names (Id, Entity) suggest that there might be a functional dependency between them
01:17:24 <random__> yeah it seems I'll have to read up on that
01:17:28 <random__> no idea what a functional dependency is
01:17:31 <random__> which is kind of sad
01:17:39 <ziman> in which case you might consider using associated types for that
01:19:33 <random__> thank you! I'll definitely look into that a bit more
01:24:34 <random__> ziman: this appears to compile in the actual codebase
01:24:49 <random__> ziman: thanks man, your solution is going live this friday lol
01:33:40 <siraben> Can I cross-compile to ARM?
01:34:37 <siraben> It's possible, but I was wondering what people are using these days?
01:35:57 <merijn> siraben: You might have a bit more luck on #ghc (lower traffic and higher likelihood of someone who's worked with cross-compilation seeing it) :)
01:36:27 <siraben> merijn:  Thanks!
02:34:10 <maerwald> siraben: you can compile a cross-compiling GHC, but you need a distro that has the appropriate toolchain (cross-gcc etc)
02:48:15 * hackage telegram-types 0.3.0 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.3.0 (Poscat)
02:55:55 <ph88> good book for when you want to know more about types http://thinkingwithtype.com/ 
02:58:46 <Lycurgus> not what I expected
02:59:13 <merijn> I have that book already :p
02:59:27 <ph88> xD
03:00:31 <DigitalKiwi> troll in the dungeon
03:03:05 <koz_> Yes, thinking with Type, not *.
03:06:48 <dmj`> merijn: how do you like that book?
03:07:36 <merijn> dmj`: It's been quite a while since I've read it, it was interesting, but I don't have any more accurate opinion on it from just memory
03:07:59 <DigitalKiwi> good video about early type systems https://www.youtube.com/watch?v=EzilaRwoMus
03:09:48 <DigitalKiwi> https://archive.org/details/Typesett1960_2
03:46:26 <DocKlobi> I will restart learning with "Thinking functionally with Haskell" by Richard Bird
03:46:26 <DocKlobi> I quote "functional application binds tighter than multiplication"
03:46:26 <DocKlobi> "*" is not a function??? What then? Just an operator? What distinguishes them?
03:47:55 <phadej> syntax
03:47:59 <phadej> f x * g y
03:48:04 <phadej> is (f x) * (g y)
03:48:08 <phadej> not f (x * g) y
03:49:22 <merijn> DocKlobi: People have a tendency to distinguish "functions" and "operators", but that's just sloppy terminology
03:50:03 <merijn> DocKlobi: Operators are just "functions that have operator names and are written infix" as opposed to stuff like "map" which is not an operator and written prefix
03:52:57 <ph88> nice video DigitalKiwi 
03:54:05 <DocKlobi> merijn: how do I recognise the tightness then?
03:55:23 <DocKlobi> operators are those fancy things starting with fancy characters?
03:55:52 <DocKlobi> or do I have to know the fixity?
03:56:07 <merijn> DocKlobi: You have to know the fixity of each operator, yes
03:56:45 <DocKlobi> than that quote is misleading
03:56:57 <DigitalKiwi> you can check in ghci `:info *`
03:57:09 <merijn> DocKlobi: prefix function application has higher fixity than operators
03:57:24 <merijn> DocKlobi: That's what that quote is saying
03:57:50 <merijn> i.e. "f x * g y" always parses as "(f x) * (g y)" (for all operators)
03:58:30 <DocKlobi> independently from fixity?
03:58:41 <merijn> operators can have fixity 0-9, prefix function application has (implicit) fixity 10
03:58:49 <merijn> (and record syntax has implicit fixity 11)
03:59:16 <DocKlobi> ahhh
03:59:29 <merijn> DocKlobi: Thus fixity only applies when mixing operators in one expression
04:01:44 * hackage telegram-types 0.3.1 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.3.1 (Poscat)
04:05:45 * hackage ngx-export-tools-extra 0.4.1.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.4.1.1 (lyokha)
04:40:55 <DocKlobi> >:i (.)
04:49:17 <opqdonut> @info (.)
04:49:17 <lambdabot> (.)
04:49:26 <opqdonut> lambdabot doesn't really have a proper @info
04:52:15 * hackage haskoin-store 0.21.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.21.3 (jprupp)
05:32:48 <dmj`> I wonder how people deal with FFI'ing into C functions that take variadic arguments
05:33:48 <merijn> dmj`: C side wrapper
05:34:38 <merijn> variadic functions don't exist in the C ABI, so can't be portably called
06:02:14 * hackage overloaded 0.2.1 - Overloaded pragmas as a plugin  https://hackage.haskell.org/package/overloaded-0.2.1 (phadej)
06:06:26 <z16> Hello, is this the right place to ask about setting up Haskell with VS Code? I'm a first time Haskell user and followed some advice online to install Haskero, but ran into some issues, mainly related to intero (which is no longer maintained from what I can gather)
06:07:19 <Uniaika> z16: yeah, switch to HIE or Ghcide
06:07:33 <Uniaika> also -> ghcid 
06:08:07 <z16> Uniaika Thanks, do you know how? I only found this guide for Haskero: https://gitlab.com/vannnns/haskero/blob/master/client/doc/installation.md
06:08:45 <Uniaika> z16: HIE and ghcide are LSP servers
06:09:21 <Uniaika> z16: https://github.com/haskell/haskell-ide-engine#using-hie-with-vs-code
06:11:52 <zincy_> I can't put my finger on exactly why. But this feels like a terrible way of reducing boilerplate.
06:12:08 <zincy_> Imagine you have lots of typeclass instances to derive for your newtype.
06:12:13 <zincy_> You write this https://pastebin.com/NHBJx3KN
06:12:21 <zincy_> Why is this terrible?
06:13:22 <merijn> zincy_: TH is super slow to compile, that's one reason :)
06:17:44 <maerwald> TH can delete your code during compilation :P
06:17:53 <maerwald> (although, GHC could too)
06:21:27 <zincy_> Yeah the Q monad can do arbitrary IO 
06:29:07 <dmj`> merijn: this api has a function that takes a list of objects as void * , so yay
06:29:16 <dmj`> merijn: just didn't see it immediately
06:31:10 <frobnicator> earthy: Yes, GRS can be seen as an extension to TRS. However, it was already called Clean when it still was an intermediate language
06:31:44 * hackage blaze-markup 0.8.2.5 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.8.2.5 (JasperVanDerJeugt)
06:33:49 <frobnicator> earthy: at least this was stated in Brus et al. 1987
06:37:14 * hackage haskoin-store 0.21.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.21.4 (jprupp)
06:38:55 <o1lo01ol1o> Does cabal have anything like template support?  I've got a project setup that I have to make every so often and I'd prefer to just have it done for me.
06:39:14 <o1lo01ol1o> (ie, cabal init thisThingAgain)
06:40:05 <earthy> frobnicator: yeah, I later realized that the c at that point was the concurrent bit for stuff on the transputer
06:41:20 <frobnicator> earthy: I'm 99% sure they really regret the naming
06:41:23 <earthy> but if I understood Marko and Rinus correctly the clean flavor of the language was very *very* quickly upgraded with syntactic sugar to become a full-fledged language in its own right
06:42:08 <frobnicator> I know it was in 1990, but what happened between 1987 and 1990 I don't
06:42:14 <earthy> it seemed to have no miranda requirements in '94 that I could discern. ;)
06:42:15 <frobnicator> Not that I was there...
06:42:16 <DigitalKiwi> maerwald: it used to
06:42:51 <DigitalKiwi> maerwald: i can't remember which exact talk but SPJ mentioned a GHC feature that deleted source files if they were not well typed
06:43:05 <DigitalKiwi> 'feature'
06:43:33 <frobnicator> John said it was used both as an intermediate and a regular language in 90
06:43:43 <frobnicator> in his 1990 msc thesis
06:44:38 <tdammers> I think that was tongue-in-cheek... it was a bug, but it's funny to think of it as an intentional feature
06:46:41 <earthy> frobnicator: I wasn't too interested in clean back then, so couldn't know. did try my hand at analysing the functional graph reduction strategy that clean uses back in the late '90's.
06:46:50 <earthy> (and failed miserably)
06:47:15 <boxscape> So, as far as I know, `exists n . P n` can be encoded as `forall r . (forall n . P n -> r) -> r`. Yet, when I take `exists (v :: Void) . ()` - which, if you look at it as a dependent pair, clearly shouldn't exist, I think - it gets encoded to `forall r . (forall (v :: Void) . () -> r) -> r`, which can be implemented very easily, basically a
06:47:15 <boxscape> convoluted identity function. What gives?
06:47:26 <boxscape> (this encoding is among other things in the ghosts of departed proofs paper)
06:47:42 <DigitalKiwi> tdammers: yes
06:49:53 <kenran> When I want to start using HIE, I can choose "the GHC version": what does this mean exactly? Suppose I have 3 project, all of which use a different ghc to build (also, one uses stack, and the other two are "nixified", that is get their ghc from nixpkgs and build inside a nix-shell). How does the GHC version I build HIE (with? for?) relate to that?
06:49:53 <ski> boxscape : `/\r. \k. k ? ()' ?
06:50:41 <boxscape> ski I'm not sure how to interpret those question marks
06:50:42 <merijn> kenran: HIE uses GHC (the library) to compile your code, so it needs to know which version of GHC to use
06:50:58 <ski> boxscape : what to pass as first argument of `k' ?
06:51:35 <boxscape> ah, yes, I passed ()
06:53:33 <kenran> merijn: so for HIE to work in all my projects, I would need to have a hie-x.y.z for every version I use? How would I go about it in a nixified project?
06:53:40 <merijn> kenran: Yes
06:54:00 <merijn> You'd have to ask the Nix people?
06:55:12 <kenran> Hum, yeah, I should do that :) But I suppose I should just make sure the hie process starts/run inside the nix-shell then as well to get its correct environment (that is, find ghc). That's probably something I can configure or use direnv for.
06:55:16 <kenran> thanks!
06:55:26 <kenran> (same goes for `ghcide` as well I guess?)
07:00:45 <boxscape> I thought maybe the encoding doesn't work if it's not actually dependent, but it still works fine if I try to encode "exists (v :: Void) . v :~: v", which seems wrong. I guess one could say the encoding doesn't preserve type annotations or something along those lines?
07:01:31 <boxscape> ("it works fine" meaning one can still write an element of the encoding of that type)
07:01:49 <ski> boxscape : well, `()' doesn't have type `Void' ..
07:04:06 <boxscape> ski I don't think I said anything that implies that it does?
07:04:58 <ski> `k' has type `forall (v : Void). () -> r' here. first argument should have type `Void', second should have type `()'
07:05:23 <boxscape> oh, the invisible argument?
07:05:31 <ski> yes
07:05:32 <boxscape> hm
07:05:52 <ski> (i'm talking about something like System F, btw)
07:08:21 <boxscape> ski: I... guess maybe ghc passes Any?
07:08:33 <ski> i'm not sure what GHC does, here
07:08:46 <jchia_> I'm merging a sorted list of "data A" with a sorted list of "data B" and I define a way to compare A with B. I also define data CompareRec = ARec A | BRec B. I use a merging function that does the merging of two [CompareRec] for me, and the function naturally requires Ord for CompareRec or a comparison function from me. The problem is there are impossible cases that I shouldn't entertain, comparing ARec with ARec or BRec with BRec. When
07:08:46 <jchia_>  I define this function, how can I deal with impossible cases? It's pointless to define it well.
07:09:20 <ski> although, if it type-checks, the issue appears similar to, in a typed logic programming language, reporting a solution which includes some uninstantiated variable, having empty type
07:09:21 <jchia_> I mean it's pointless to define the useless cases well.
07:10:00 <sm[m]>  suzu_: I agree with your overall point yesterday. I think it might be less clearcut than you think though: 1. maybe you're not acccounting for familiarity with the ecosystem, eg yours with ruby and dsal's with haskell, and 2. maybe you shot yourself in the foot by discounting yesod because "TH bad!" - it is our rails and can implement those things you mentioned pretty quick when you know it (though obviously less prettily
07:10:00 <sm[m]> than rails)
07:10:02 <boxscape> ski: if it does Any I suppose it makes sense that it works in ghc even though the proposition sounds wrong, seeing as Any is more or less a type-level bottom as far as I understand
07:10:10 <boxscape> s/does Any/does pass Any
07:12:03 <ski> hm. i don't know that much about the details of the choice of `Any', but the way that SML and O'Caml does this (?) appears to me to be more attractive
07:13:30 <ski> well, hm. at least it's SML/NJ. perhaps also some other implementation, i don't recall. anyway, what it does is it constructs a new abstract data type, a skolem basically, in an unknown module, not equal to any other type. and each such situation generates a new skolem (rather than reusing the same `Any' everytime)
07:14:30 <ski> otoh, in O'Caml, it introduces a bare meta- (/logic) variable in the type. then, when you use the operation, fixing that metavar, it'll get instantiated so that the type signature is "back-patched"
07:15:19 <boxscape> (-ddump-simpl confirms use of Any)
07:16:39 <ski> imagine if you defined `globalIORef = unsafePerformIO (newIORef [])' you'd get not `globalIORef :: forall a. IORef a', but `globalIORef :: IORef _a', for a fresh metavar `_a'
07:18:08 <ski> er, sorry, should be : not `globalIORef :: forall a. IORef [a]', but `globalIORef :: IORef [_a]', for a fresh metavar `_a'
07:18:49 <frdg> Im a bit confused about what "lifting" exactly means in regards to Functors and applicatives. I understand that when we use `(fmap . fmap)` were "lifting" over two structures. I am able to use fmap just fine and I believe I understand it pretty well but the term "lifting" is kinda confusing me
07:18:53 <ski> then, when you did `modifyIORef globalIORef (False:)', that'd unify the `_a' with `Bool' so that now you actually have `globalIORef :: IORef [Bool]'. so that you couldn't then also do `modifyIORef globalIORef ("True":)'
07:19:29 <boxscape> that sounds reasonable
07:19:45 <ski> frdg : "lifting" in general is a sortof fuzzy term, can mean different things in different contexts. i'd suggest to try to focus on each context as a separate thing (more or less)
07:21:21 <frdg> ski: ok that makes sense. Basically don't try to come up with an over-arching definition but instead try to understand what is going in in each individual example.
07:21:25 <ski> boxscape : now, this happens in the MLs, not because of `unsafePerformIO' (since they have side-effects), or because of the DMR, but because of the Monomorphism Restriction (which is sortof a little bit similar to DMR, but motivated by complications with mixing polymorphism with side-effects, which would allow exactly something like `globalIORef' above, if not controlled)
07:22:03 <operand> Hi, does anyone know if there is a paper about the Alternative typeclass? 
07:22:08 <boxscape> I see
07:23:53 <operand> Ah, nevermind, I seem to have found it
07:24:45 <ski> frdg : in the case of `Functor's, it means one thing. in the case of `Applicative' it means a generalization of that, one could say. it's not so clear whether there's a `Monad'-specific sense to the term. for `MonadTrans', however, it means something not so related (although you might compare `lift' with `pure'/`return', and then wonder whether there's a `MonadTrans'-like analogue of `fmap'/`(<$>)'/`liftA'`/`liftM', and then maybe also for `liftA2'/`liftM2'
07:25:16 <operand> The paper was even co-authored by my bachelor thesis supervisor, lol :p
07:25:19 <ski> (hrm, end of that was ".., and then maybe also for `liftA2'/`liftM2' and so on)")
07:26:27 <merijn> frdg: A lift goes from one level to another, so "lifting" generally means taking something from one level to another, but what exactly that means is, as ski says, context dependent
07:26:39 <ski> frdg : perhaps one could describe going from `T -> M U' to `M T -> M U' (via `(=<<)') as "lifting" in some sense. but i'm not sure i've ever seen/heard it ever called that. this operation tends to be known as "(monadic) extension"
07:27:31 <frdg> merijn,ski: ok, I think I understand. I have a mental image of a crane deciding where to drop the function...that I believe is actually pretty accurate
07:27:59 <maerwald> a... crane?
07:28:16 <frdg> haha...yes a crane
07:28:34 <kenran> (I've heard "lifting" used even for `pure`, in that it lifts a value into the Applicative/Monad; is this common usage too?)
07:29:48 <frdg> as in the crane is deciding if it should apply the function onto the list portion of the structure, or into the Maybe portion, etc
07:30:00 <kenran> oh wait, yeah, probably because it's basically fmap0, with fmap1 = fmap, ...
07:34:46 <maerwald> I'm seeting the next blog post: monads as cranes :)
07:36:54 <tdammers> lifting and hoisting and oh my
07:44:22 <ski> heh, okay, frdg. if that image works for you :)
07:46:41 <tdammers> analogies are like bad metaphors
07:47:39 <ski> @quote bad.explanations
07:47:40 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
07:48:04 <tdammers> that one made my day
07:48:28 <merijn> @quote metaphor
07:48:28 <lambdabot> sorear says: I find it very amusing how Church's abstract nonsense turned out to make for better programming than Turing's real-world metaphors.
07:48:39 <merijn> ah, wrong one
07:48:50 <merijn> @quote a.metaphor
07:48:50 <lambdabot> tensorpudding says: A monad metaphor is like a metaphor, but less helpful.
07:49:06 <merijn> lambdabot, stop making me work for my quotes!
07:49:16 <boxscape> @quote lambdabot
07:49:17 <lambdabot> lambdabot says: Exception: I'm a moron
07:50:05 <ski> @quote this.metaphor
07:50:05 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
07:50:07 <hseg> so i'm adding type applications everywhere to resolve tyfam ambiguity, and GHC basically complains that (coerce @_ @(F r) val) :: forall r. F r doesn't match, since the r is ambiguous
07:50:21 <ski> @ghc
07:50:21 <lambdabot> parse error on input
07:50:30 <ski> @ghc
07:50:30 <lambdabot> GHC error in desugarer lookup
07:50:53 <hseg> specifically, http://ix.io/2iPb where assertUnit :: Unital a => a -> Unit a
07:51:28 <hseg> (and we have instance (KnownNat n, Field f) => Unital (TrigPoly n f))
07:51:52 <merijn> I only have unhelpful contributions
07:51:58 <merijn> Like "dear god, why?!"
07:52:14 <merijn> And "maybe you should reevaluate writing this in Haskell" >.>
07:54:41 <tdammers> personally, I think one shouldn't study metaphors before having a firm grasp on phors
07:55:21 <suzu_> sm[m]: yeah yesod is the rails of haskell so i can't exactly discount it, you're right on that
07:56:11 <suzu_> i can't discount TH when it's the best analog there is of all that ruby on rails implicit magic
07:56:30 <merijn> I would argue that "implicit magic" is inherently evil >.>
07:57:55 <hseg> merijn: please tell me you're not talking about my code?
07:58:14 <merijn> hseg: I was
07:58:42 <hseg> although judging by the stuff i'm bumping into, i really should have gone for a deptype language
07:58:48 <sm[m]> TH is simply a labour saver, like macros in lisp. It can generate more code than you realised, but that doesn't make it bad
07:59:37 <merijn> hseg: I mean, I have seem the type of questions you've asked over the past days/weeks and these kinda things are just not possible to do in Haskell without extreme amounts of pain (as you've probably noticed by now :p)
07:59:56 <sm[m]> in the context of yesod, at least. Obviously it's unsafe and complicated to create your own TH etc. etc.
08:00:52 <hseg> yeah. but am in so deep i'm scared of rewriting the project in idris/agda
08:01:03 <hseg> to say nothing of the fact that i have no experience in them
08:01:39 <maerwald> now you got an excuse to learn Agda!
08:02:49 <merijn> hseg: Idris is specifically designed for "people coming from Haskell"
08:03:38 <hseg> ok... am 2kloc into the project though, and it feels like if i can just make this bit compile i should be done
08:03:40 <boxscape> also Idris is designed for programming, Agda is designed for theroem proving
08:03:59 <hseg> (this is the only bit that really heavily uses type level stuff)
08:04:08 <hseg> rest of the code is isolated from it
08:05:22 <maerwald> and then you're halfway into Idris and want to actually build something, when you realise... there is no ecosystem :P
08:06:34 <hseg> :D
08:08:02 <hseg> using some pretty tame type-level stuff: length-indexed lists, maps (finite, finite) -> Nat, reflection/reification
08:08:17 <hseg> and the latest bit: constructing the group of units of a ring
08:08:46 <hseg> (which i'm cheating with by encoding it as an assoc type with exception-throwing coercions)
08:11:08 <pdlla> e
08:14:51 <jchia_> Is there a function to reverse Ordering? I.e. LT gets mapped to GT and vice versa
08:15:30 <hseg> merijn, maerwald: to get an idea of what it'd involve to move to idris, how long would you estimate a conversion of ~700loc of that level of type hackery into idris, assuming no knowledge of idris (so also factoring in getting up to speed in idris, setting up the toolchain, etc)?
08:17:04 <ski> > sortOn Down [0 .. 7]  -- jchia_ ?
08:17:07 <lambdabot>  [7,6,5,4,3,2,1,0]
08:17:49 <hseg> jchia_: in general, wrapping/unwrapping Down will do the trick
08:18:54 <boxscape> > sortOn Up [0 .. 7]
08:18:56 <lambdabot>  error:
08:18:57 <lambdabot>      • Data constructor not in scope: Up :: a -> ()
08:18:57 <lambdabot>      • Perhaps you meant one of these:
08:18:58 <boxscape> disappointing
08:20:07 <merijn> hseg: I don't have much experience with that sorta thing, so hard to guess.
08:20:18 <hseg> ok...
08:20:42 <hseg> will try to devote some time to learning idris in parallel with trying to get this to work, then
08:20:44 <Uniaika> > :t Down
08:20:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
08:20:52 <boxscape> :t Down
08:20:54 <lambdabot> a -> Down a
08:20:57 <Uniaika> ah, thanks
08:21:01 <Uniaika> :t Up
08:21:02 <lambdabot> error:
08:21:02 <lambdabot>     • Data constructor not in scope: Up
08:21:02 <lambdabot>     • Perhaps you meant one of these:
08:21:05 <Uniaika> okay
08:21:08 <Uniaika> hmm
08:21:17 <merijn> hseg: Brian McKenna had a nice demo of implementing type-safe printf in Idris, it's only 12 minutes or so, maybe watching that will give you a feel for how difficult learning idris might be vs how much simpler the type level stuff becomes
08:21:27 <merijn> hseg: https://www.youtube.com/watch?v=fVBck2Zngjo
08:23:03 <boxscape> if you allow unsafePerformIO in instances you could even do something ilke "sortOn Random [0 .. 7]" to get a permutation
08:24:02 <boxscape> (not that I'm suggesting that that's a good idea)
08:24:44 <jchia_> ski, hseg: Thanks. I've used Down before, but I forgot. I wonder what else I'm forgetting
08:25:46 <hseg> hrm. big sell would be if idris can express the type {x:a | exists y:a. x * y == 1}, to use liquidhaskell syntax
08:26:00 <carbolymer> I've got a dumb question... how can I install hasktags? can I use stack for that?
08:26:37 <tdammers> probably, yes
08:26:37 <hseg> and especially {f:a->b | f (a*b)=f a * f b} -> Unit a -> Unit b
08:26:40 <ski> @type getDual . foldMap Dual
08:26:41 <lambdabot> (Foldable t, Monoid c) => t c -> c
08:26:52 <ski> jchia_ : `Dual' is "sortof similar"
08:27:03 <hseg> because i don't see anything like that in the docs
08:27:35 <ski> (and isn't there some `newtype' for switching the order of an idiom ?)
08:27:57 <jchia_> ski, hseg: What if I just need to explicitly invert Ord? E.g. I'm calling sortBy and providing my own comparison function f on "data Foo = Bar x | Baz y" and I only want to explicitly define "f (Bar _) (Baz _)" but "f (Baz _) (Bar _)" as the inverse of the opposite comparison?
08:28:18 <ski> boxscape : yea, i'd forgotten it was called `Down'. i was trying some other things like `Op' and `Opposite', first
08:28:21 <sm[m]> carbolymer: sure
08:28:31 <hseg> jchia_: derivingvia, maybe?
08:28:55 <hseg> seems like agda might be a better fit, in that case
08:29:09 <carbolymer> sm[m], how can I do that?
08:29:39 <ski> boxscape : or use `unsafeInterleaveST', and get a result where the order in the list depends on which element you access first ;p (first accessed element is always the least, say)
08:29:46 <sm[m]> Have you tried: stack install hasktags
08:30:06 <carbolymer> sm[m], yeah, I'm gettin an error
08:30:23 <boxscape> ski hmm.. nice idea
08:30:38 <ski> btdt :)
08:31:16 <hseg> ok, https://www.idris-lang.org/docs/current/contrib_doc/docs/Classes.Verified.html seems to suggest idris does support some proving
08:31:26 <hseg> but no homomorphisms in stdlib...
08:31:57 <boxscape> can you have a dependently typed language without supporting proving, given Curry-Howard?
08:32:39 <ski> @hoogle Ordering -> Ordering
08:32:40 <lambdabot> Text.Regex.TDFA.Common flipOrder :: Ordering -> Ordering
08:32:40 <lambdabot> Prelude id :: a -> a
08:32:40 <lambdabot> Data.Function id :: a -> a
08:32:43 <ski> hm
08:32:54 <sm[m]> carbolymer: ok, would you like help interpreting it ?
08:33:10 <ski> boxscape : i was thinking you could do `foo x y = flipOrder (foo y x)' as a catch-all case at the end
08:33:35 <carbolymer> sm[m], just a sec, my vim just shat itself, so I'm trying to fix that first :)
08:33:59 <ski> however, `flipOrder' should probably be in `Data.Ord' ?
08:34:00 <hseg> boxscape: can you have any language that doesn't support proofs, given CH?
08:34:30 <hseg> srsly, tho, you're right - deplangs seem to have stronger internal logics
08:34:38 <ski> what does "without supporting proving" mean, in context of CH ?
08:35:08 <boxscape> I was basing it on hsegs phrasing of "idris does support some proving"
08:35:35 <ski> under CH, programming is proving
08:37:59 <hseg> ski: meant being able to manipulate proofs in code
08:38:12 <hseg> esp re type-level stuff
08:38:19 <ski> manipulate, in which sense ?
08:38:44 <ski> being able to talk about proofs (and not just value), in types ?
08:39:15 <hseg> yeah
08:39:44 * hackage haskoin-store 0.21.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.21.5 (jprupp)
08:39:54 <hseg> so e.g. being able to write (x : Unit a) -> (y : Unit a) -> (x*y : Unit a)
08:40:22 <ski> under CH, proofs and values are unified, so they'd be the same
08:41:30 <ski> (however, one might perhaps also mean being able to analyze/manipulate the structure of proofs, like not just the "proof value", but the particular construction .. that's be meta-programming, or perhaps it'd be called meta-proving ?)
08:42:08 <hseg> yes, but there's a difference between being able to give that interpretation externally, and being able to use such a proof to show that inv (product units) is well-typed
08:42:09 <boxscape> so.. sort of like template haskell?
08:42:34 <ski> i suppose .. maybe
08:42:52 <ski> or you could just have a datatype of proofs
08:43:19 <hseg> right...
08:43:43 <ski> hm, now i wonder whether this is what LCF did, in ML
08:43:48 <hseg> but reproving a good chunk of elementary commutative algebra is not my idea of fun
08:44:05 <hseg> would rather make what i have work
08:44:23 * ski . o O ( <https://en.wikipedia.org/wiki/Logic_for_Computable_Functions>,<https://en.wikipedia.org/wiki/ML_(programming_language)> )
08:44:32 * ski nods
08:44:45 <solonarv> ski: Backwards switches the order of Applicative operations, its Applicative instance is liftA2 @(Backwards f) = flip . liftA2 @f . flip -- after stripping away newtype wrappers of course
08:45:07 <hseg> merijn: ok, sure, that type safe printf thing shows reflection/reification is _very_ easy
08:45:12 <solonarv> it's defined in transformers, which actually does not only contain *monad* transformers
08:45:22 <ski> oh, it was `Backwards'. i thought i'd seen it before
08:45:53 <hseg> but how would you write multinom_sub :: Vector n Int -> Vector n (Unit a) -> Unit a ? 
08:45:58 <ski> hm .. is there something like that for `MonadFix' ?
08:46:28 * ski idly wonders what this `Unit' thing is
08:46:59 <hseg> Unit a = {x:a | exists y:a. x * y == 1}
08:47:02 <solonarv> ski: if 'a' is a ring, then 'Unit a' is that ring's group of units
08:47:04 <ski> ah, ok
08:47:41 <hseg> so morally, i'd want Unit a to be a refinement type of a
08:47:45 <merijn> hseg: Keep in mind that in Idris you can always just call regular functions at the type level directly without any encoding using type families/whatever
08:47:50 <ski> why "sub" ?
08:48:28 <hseg> basically i'm substituting units into a multinomial expression like x^ky^lz^m where k,l,m::Int
08:48:41 * ski isn't quite sure why, when people say "refinement type", they always seem to mean a (subset) type of form `{x : T | ..x..}'
08:48:58 <hseg> because that's the low-hanging fruit
08:49:34 <ski> isn't that more like exponentiating a tuple of subunits to a tuple of integer exponents ?
08:50:11 <hseg> yes ("subunits"?)
08:50:45 <ski> (yes, divisors of `1'. if i say "unit", i tend to mean something that's a neutral element)
08:51:06 <hseg> ah. and zero-divisors would be subzeros?
08:51:32 <ski> well, including zero itself, then, as an improper one
08:52:05 <hseg> anyway, since haskell doesn't have refinement types i'm encoding this setup as class Group (Unit a) => Unital a where { type Unit a; injU :: Unit a -> a; assU :: a -> Maybe (Unit a); }
08:52:08 <ski> hmm
08:52:22 <hseg> except that is noninjective, therefore not fun
08:52:39 <ski> i guess we'd want something more. since everything is a divisor of zero ..
08:52:39 <hseg> and replacing it with a data family breaks GND
08:52:53 <solonarv> oh! fundeps should work
08:52:56 <ski> (but i'm not particularly fond of the term "zero divisor", either ..)
08:52:58 <ski> )
08:53:00 <hseg> solonarv: ?
08:53:19 <hseg> ski: ok, "proper zero divisor"
08:53:26 <ski> maybe
08:53:40 <hseg> ski: with "proper" being elided since everything is an improper zero divisor as noted
08:53:42 <solonarv> class Group u => Unital r u | u -> r, r -> u where injU :: u -> r; assU :: r -> Maybe u
08:53:50 <ski> "proper" usually means something like "nontrivial", but what does "trivial" mean ?
08:54:05 <solonarv> then you can use GND by newtyping both the 'u' and 'r' parameters at once
08:54:25 <hseg> solonarv: oh? sample please?
08:54:58 <solonarv> oops, swap u and r I think
08:55:06 <hseg> have atm instances (Eq a, Field a) => Unital (NonZero a); (Eq a, Ring a) => Unital (PlusMinus1 a)
08:55:24 <hseg> how would you write them supporting GND?
08:55:48 <hseg> ski: triviality here being the fact that the decomposition _*0=0 is always valid
08:55:52 <solonarv> then you get: newtype R' = Wrap R deriving (Unital U') via R
08:56:03 <solonarv> hm, no, that still doesn't work
08:56:14 <solonarv> hmm, GND/DerivingVia doesn't interact very well with MPTC
08:56:28 <hseg> GND only applicable to final class param
08:57:16 <solonarv> however it should be reasonably easy to write some template haskell to write an instance full of coerces, I think
08:57:25 <solonarv> (what a mouthful of a sentence)
08:57:32 <hseg> :-/ ok
08:57:35 <hseg> if that's what it takes
08:58:01 <hseg> the thing with this assoc type encoding is that it also interacts poorly with backpack
08:58:07 <ski> hseg : mm .. i'd just like a more general framework, capturing at least some of the important common examples
08:58:34 <hseg> since while i can assert Unital (P n r), i cannot assert Group (Unit (P n r))
08:58:50 <hseg> ski: fair, but cf "regular" "normal" "nice"
08:58:55 <ski> hseg : perhaps one could say something about what's derivable in the general theory (of a single group, a single ring, or whatever)
08:59:40 <solonarv> usage might look something like: coerceInstance ''Unital [ ([t| MyRing |], [t| UnitForMyRing |]), ([t| WrappedRing |], [t| WrappedUnit |])]
08:59:50 <solonarv> back in a bit
09:00:04 <hseg> same
09:06:04 <oats> are those idiom brackets?
09:06:07 <oats> those are cool
09:06:13 <oats> really wish haskell had 'em
09:06:45 <ski> TH
09:07:18 <ski> @hackage applicative-quoters
09:07:18 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
09:07:21 <ski> oats ^
09:07:40 <oats> mmmmm
09:07:45 * hackage birch-beer 0.2.4.1 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.4.1 (GregorySchwartz)
09:08:26 <solonarv> [t| |] is the builtin quasiquoter for haskell types
09:08:57 <solonarv> % runQ [t| [Int] |]
09:08:57 <yahb> solonarv: ; <interactive>:124:17: error: parse error on input `]'
09:09:04 <solonarv> % :set -XTemplateHaskell
09:09:04 <yahb> solonarv: 
09:09:06 <solonarv> % runQ [t| [Int] |]
09:09:06 <yahb> solonarv: ; <interactive>:126:1: error: Variable not in scope: runQ :: Language.Haskell.TH.Lib.Internal.TypeQ -> t
09:09:14 <solonarv> % import Language.Haskell.TH
09:09:15 <yahb> solonarv: 
09:09:17 <solonarv> % runQ [t| [Int] |]
09:09:17 <yahb> solonarv: AppT ListT (ConT GHC.Types.Int)
09:10:09 <ski> % runQ [t| forall a. a |]
09:10:09 <yahb> ski: ForallT [PlainTV a_0] [] (VarT a_0)
09:14:41 <monochrom> "ListT done right" :)
09:15:55 <cjay> can cabal pass build flags to the code without CPP? I suppose it might be able to generate a module with some Bool constants.
09:16:07 <ski> hah, monochrom :)
09:16:24 <enthropy> ski, https://github.com/bmillwood/applicative-quoters/issues/8 . That's a proposal that "[i| (f,g) |] = liftA2 (,) f g /= pure (f,g)". Is it too ad-hoc?
09:16:57 <monochrom> Use CPP on the module that defines and exports some Bool constants.
09:17:34 <ski> enthropy : i'm not too fond of idiom brackets, anyway. i have my own sketch of a system (inspired by it, and some other things) .. it might be nice, if i ever could get around to implementing it
09:17:37 <cjay> yeah that's what I just did, and it made me wonder :)
09:18:10 <cjay> that way CPP is constrained to only one module, I like that
09:18:40 <enthropy> ski, is it written up somewhere?
09:18:43 <ski> (and my system doesn't that kind of issue that you mentioned)
09:18:59 <ski> only as scribbles on paper
09:19:13 <ski> i've talked about it, now and then, on IRC
09:19:41 <ski> there's still some things i'd like to figure out how to do / fit into it, in a satisfactory way
09:20:49 <ski> i've called it "reflective effect syntax", in the past
09:24:36 <enthropy> looks like chrisdone's ircbrowse.net is down. So the /topic Logs will have to do
09:25:37 <ski> yea, it's been down for some while. can't recall how long
09:34:26 <sm[m]> years, don't think it's coming back
09:34:29 <z16> Do you often encounter long file paths with Haskell and its infrastructure/dependencies? I see HIE recommends cloning to `C:\hie` and Stack uses `C:\sr` and I'm not even sure if I can change it, sure didn't ask me about it <_<
09:35:28 <sm[m]> yes, paths can get pretty long z16 - you won't see them but tools will, and it has often been an issue on windows
09:36:06 <sm[m]> but if things are working, I wouldn't worry about it
09:36:21 <solonarv> although I think there is some way to disable max path length on recent windows
09:36:35 <z16> Well, having a folder on `C:\` is worrisome to me
09:36:38 <solonarv> might even be that way by default; idk, I don't program on windows anymore
09:37:01 <solonarv> is there a reason it's more worrisome than having the folder buried deeper?
09:37:13 <z16> Idk about the OS itself, I know when using its C API the `MAX_PATH` variable is set to 260
09:37:53 <z16> But that has been the case for many years, maybe decades, and Idk how well it reflects actual OS limitations
09:37:55 <solonarv> yes, that is exactly the issue you'd run into if you used a longer path as the root
09:38:05 <monochrom> hie : c:\hie :: nix : /nix  >:)
09:38:33 <solonarv> I don't recall needing admin access/UAC to create a folder in C:\
09:38:39 <solonarv> but maybe my memory is just bad
09:39:11 <z16> I don't like polluting my `C:\` drive, and it doesn't integrate well with other OS mechanics, such as program statistics (size estimations) and user-local programs (since `C:\` is a global folder on my machine)
09:39:33 <z16> You don't need admin privileges
09:39:51 <solonarv> ah, fair enough
09:40:16 <monochrom> Doesn't most windows installers ask you to choose prefix and respect it?
09:40:31 <solonarv> perhaps you can put the actual folder somewhere else and make C:\sr a symlink pointing there? that at least helps with some of the issues you brought up
09:40:33 <z16> I'll put it under `C:\Code\` anyway, so not an issue, just a bit bummed that Stack didn't ask me about it
09:40:50 <solonarv> oh huh, that is surprising (stack not asking)
09:41:09 <z16> It only asked if it should define `%STACK_ROOT%` to point to `C:\sr`
09:41:32 <z16> Anyway, not a major issue, just a little annoying
09:41:51 <monochrom> Another instance of stack presumptive attitude, conflating head-in-sand with simplicity.
09:41:52 <solonarv> C:\code\ is fine, it's just that the default used to be %APPDATA%\stack which is typically much longer ( C:\Users\YourUserName\AppData\Roaming\stack )
09:42:04 <sm[m]> stack devs got fed up dealing with debugging those issues I guess
09:42:59 <sm[m]> solonarv: and that path can vary too, depending on windows version/I don't know what, right ?
09:43:49 <solonarv> I don't know, actually
09:44:07 <solonarv> that is/was the path on win7 and win8, and I think win10 kept it as well (but I never used win10)
09:44:13 <sm[m]> I think so. It's always a pain for docs and support
09:45:32 <sm[m]> I guess stack using \SR doesn't change that, you still have to explain how to add %APPDATA%/.../bin to PATH
09:45:43 <solonarv> yes, that's always been a pain on windows
09:46:06 <solonarv> gotta click through like 4 menus and then you have the value in a tiny text box
09:47:16 <monochrom> echo %appdata%
09:47:38 <solonarv> that doesn't help if you want to *edit* it
09:48:02 <monochrom> Oh, that. But it is a bad idea to change it.
09:48:11 <solonarv> I usually ended up copy-pasting from the tiny text field into notepad, editing there, then copy-pasting back
09:48:21 <solonarv> (to clarify: this is for editing %PATH%)
09:48:33 <monochrom> Ah OK!
09:49:07 <monochrom> Windows presumptuous attitude. Conflating head-in-sand with simplicity.  >:)
09:49:46 <monochrom> Did you know that the Windows embrace-extend-extinguish guy joined fpcomplete? >:)
09:49:52 <sm[m]> to its great credit, stack shows where executables have been installed and warns you if it's not in PATH. But fixing that for you is too hard alas
09:50:43 <sm[m]> on unix too
09:50:55 <sm[m]> PATH is a pain, basically
09:56:23 <Uniaika> 🍞 trail 
09:56:44 <maerwald> monochrom: yeah, nix and windows share some common philosophy
09:57:22 <maerwald> Ok, that was low-effort :P
10:34:14 * hackage crypto-classical 0.3.0 - An educational tool for studying classical cryptography schemes.  https://hackage.haskell.org/package/crypto-classical-0.3.0 (fosskers)
10:43:16 <hseg> ski: with "proper" being elided since everything is an improper zero divisor as noted
10:43:19 <hseg> oops
10:43:21 <hseg> sorry
10:43:43 <hseg> solonarv: had any ideas while we were on break?
10:45:26 <solonarv> hseg: nothing particularly concrete, no
10:47:09 <hseg> have an idea. does class a b | b -> a mean i need uniqueness of instances, or that a must be inferrable from b?
10:47:26 <hseg> that should be class C a b | b -> a
10:48:16 <hseg> e.g. is instance C Int (Tagged "PM1" Int) legal?
10:48:31 <hseg> (where newtype Tagged t x = Tag x)
10:48:55 <monochrom> a is inferrable from b. Also (or equivalent), for each b, at most one a.
10:49:19 <hseg> ok. so this C Int (Tagged "PM1" Int) instance is legal?
10:50:06 <ski> hseg : the FD there means `forall b. unique a. C a b', which means `forall a0 a1 b. (C a0 b,C a1 b) => a0 = a1'
10:50:09 <monochrom> Cannot be determined.  It is plurality co-existence that can be illegal.
10:50:52 <monochrom> The following co-existence is an illegal example.  "C Int Char", "C Bool Char".
10:50:55 <hseg> ok, so in the absence of more instances this is legal?
10:51:00 <monochrom> Yes.
10:51:03 <ski> hseg : what do you mean by "a must be inferrable from b" ?
10:51:35 <solonarv> a single fundep like class C a b | b -> a is more or less the same as an associated tyfam, class C b where type A b
10:51:54 <ski> `a' doesn't have to be a "part" of `b', if you mean something like that
10:52:06 <solonarv> but fundeps can go both ways, so with class C a b | a -> b, b -> a you get something like injectivity
10:52:06 <hseg> ski: right, bogus thought
10:52:47 <hseg> wait... that simplifies things even more
10:54:23 <hseg> class Unital t r | r -> t; instance Unital "PM1" Int; instance Unital "NZ" Rational 
10:54:41 <hseg> this ordering permits GND on r
10:54:52 <hseg> unless i'm very much mistaken
10:55:44 <dmwit> tyfams can go both ways, too
10:55:45 <ski> you can do `deriving Unital "PM1"', i'd guess, yes
10:56:49 <hseg> excellent. so instead of my current deriving via (PM1 Int) instance Unital Int, i'd have deriving newtype Unital "PM1" Int
10:56:52 <dmwit> class C a b | a -> b, b -> a is something like type family F a; type family G a; class (F (G a) ~ a) => C a
10:58:30 <hseg> ... wait, no. would be using derivingvia, GND is only relevant here in determining where derivingvia is legal
11:00:20 <hseg> so deriving via (PM1 Int) instance Unital "PM1" Int
11:00:21 <hseg> where instance Unital "PM1" (PM1 a) gives the model Unital instance of template PM1
11:00:21 <hseg> ok, think i have my design, here's hoping it works
11:01:46 <hseg> basically, idea is to replace my tyfam Unit by a parameter u to Unital, and add a fundep | r -> u
11:04:43 <hseg> even better! i can keep Unit around, with default implementation Unit r = u
11:15:04 <hseg> ... things are not quite lining up -- the model instances (so Unital f (f a)) should have methods with type signatures inj :: f a -> a; ass :: a -> f a
11:15:46 <hseg> but as written, this resolves to inj :: f (f a) -> f a; ass :: f a -> f (f a)
11:17:34 <hseg> having the model instances be Unital Id (f a) breaks my GND
11:18:35 <hseg> and type family Strip f t where { Strip f (f t) = t; strip _ t = t } is clearly noninjective
11:19:36 <hseg> (unless i can smh enforce that t is not of form f (non-f x))
11:19:41 <hseg> which is a nonstarter
11:25:17 <hseg> ... and my idea to keep Unit around fails
11:25:59 <hseg> unless i require all instances to define Unit r = u
11:27:10 <hseg> hrm. also problematic: class C a b => D a is forbidden, even when class C a b | a -> b
11:27:38 <hseg> ideas?
11:28:04 <monochrom> In that case, type families eliminates that problem.
11:30:40 <hseg> right, but the natural way of requiring Unital instances to define a Unit tyfam instance is by making it an associated type
11:31:03 <hseg> but the only legal definition of that assoc type by the way i've set things up is Unit r = u
11:31:10 <hseg> (for Unital u r)
11:34:54 <Phyx-> 17:47:15 < solonarv> that doesn't help if you want to *edit* it
11:35:13 <Phyx-> well, there's 'setx'. no gui needed to globally edit it.
11:35:55 <monochrom> neat
11:36:31 <Phyx-> z16: anyway, we're working very hard to remove the MAX_PATH limitation. it's gone from GHC and Haskell programs already and GHC 8.10 can deal with it in GCC and binutils for the common operations as well.
11:36:36 <hseg> oh wait. that should be type Unit r = u r. let's see if that changes anything
11:37:52 <Phyx-> z16: but it's hard to turn the ship overnight. there's a lot of code to update to not use these pseudo-POSIX apis.
11:37:57 <Phyx-> oh, he left
11:53:38 <sm[m]> Phyx++, we appreciate this work
11:54:14 <sm[m]> which windows versions / command environments will setx work in ?
11:57:22 <sm[m]> https://stackoverflow.com/questions/19287379/how-do-i-add-to-the-windows-path-variable-using-setx-having-weird-problems scares me
11:58:24 <hseg> dammit. how do i elide functionally dependent in contexts? eg instance C a b => D a for class C a b | a -> b
11:58:55 <hseg> instance C a (B a) => D a is forbidden 
11:59:27 <hseg> ... well, not forbidden, just broken for b of kind differing from *
12:00:00 <hseg> ... no, that's not it either, frustration is impairing my reasoning
12:01:40 <monochrom> Yikes, windows is hard.
12:04:10 <hseg> btw, only way of constraining inputs to tyfam to be instances of a class is by capturing a Dict, right?
12:04:49 <hseg> ... makes sense in my case -- worst case scenario, the tyfam will fail to reduce
12:08:04 <hseg> ... makes sense in my case -- worst case scenario, the tyfam will fail to reduce
12:10:01 <hseg> is there some way of getting the list of superclasses ghc expects of an instance (in debugging "could not deduce ... arising from superclasses of instance decl")
12:10:29 <hseg> ah, nm, found it
12:11:08 <hseg> and it's the same problem as before...
12:11:41 <hseg> my model instances are forced to have Unit r = u (u r) instead of of u r as i'd want them
12:12:41 <hseg> back to the drawing board it is
12:14:15 <zincy_> I want to do an educational project to learn more about compilers. I have written a brainfuck to web assembly compiler and a lambda calculus interpreter.
12:14:28 <zincy_> What would a next good project be?
12:15:10 <hseg> to recap: my wants are: class HU ... r where {U :: * -> *, injU :: U r -> r; assU :: r -> Maybe (U r)} that won't bite me re noninjectivity
12:15:17 <zincy_> Was thinking a compiler for generating some simple imperative language to LC3M virtual machine instructions
12:15:34 <hseg> and that supports derivingvia-style deriving
12:15:55 <hseg> so that i can write down the three different templates i have for how to give an instance
12:16:05 <hseg> and have derivingvia do the copy/paste for me
12:16:47 <zincy_> Hmm or maybe even better I could write a compiler for the 6502 breadboard computer I am building
12:17:12 <hseg> for the former want, can do class HU u r | u -> r, r -> u
12:17:46 <monochrom> Compiling Haskell to 6502? :)
12:17:46 <hseg> for the latter want, can do class HU r (DV is strong enough to figure out assoc types)
12:18:54 <zincy_> monochrom: Maybe that would be interesting
12:19:34 <zincy_> Could be pretty tough project for learning about compilers no?
12:19:58 <hseg> .. one more thing - need G (U r) => HU r ...
12:20:03 <koala_man> I'm working on debugger integration. It's something a lot of people neglect
12:20:40 <dmwit> zincy_: Have you done any optimizations? Could be a fun next phase for your existing compiler.
12:20:54 <dmwit> zincy_: Compiling to 6502 will give you experience with register allocation. Sort of. =P
12:21:03 <hseg> new approach: data family U r; templates give the G (U r) instance, use GND to derive it
12:21:10 <zincy_> dmwit: Actually I haven't. That is an idea :)
12:21:12 <dmwit> (Why sort of? Well, there's so few registers, that maybe you don't get to see any actually interesting register allocation problems...)
12:21:14 <zincy_> Could play with Uniplate too
12:21:34 <hseg> U uncoupled from HU, but aside from that should be ok
12:22:00 <sm[m]> koala_man: nice, which debugger ?
12:22:05 <zincy_> dmwit: Maybe 6502 being so different makes it a bad compilation target for learning purposes?
12:22:23 <dmwit> So different from what?
12:23:10 <hseg> might even be able to define HU instances for the template and GND that as well
12:23:22 <zincy_> Modern computer architecture
12:23:39 <zincy_> "Writing a good compiler to target the 6502 is difficult, because the CPU is so unlike modern hardware (8-bit with 16-bit addressing, only one register that isn't crippled, zero page, no arbitrary shift amounts, no multiply, weird addressing modes, etc. etc.) I'm always impressed when anyone gets something working :)"
12:23:40 <dmwit> Hm. Maybe.
12:23:46 <koala_man> sm[m]: currently targeting Chrome DevTools as the frontend, plus other debuggers using the same protocol
12:24:12 <sm[m]> sounds rather interesting
12:24:56 <sm[m]> it’ll step like ghci debugger ?
12:25:12 <koala_man> I didn't even know ghci had a debugger
12:25:53 <koala_man> but yeah, breakpoints, source maps, evaluation, inspection, stepping, all that
12:26:54 <koala_man> I'm no longer annoyed when other debuggers fail to symbolicate things or trigger breakpoints. Instead I'm amazed that it ever actually works as well as it does
12:27:23 <sm[m]> You’re making this sound.. easy and ready soon :)
12:39:24 <koz_> I need to learn the GHCi debugger one of these days lol.
12:39:30 <koz_> I was also surprised to find out it exists.
12:40:34 <Uniaika> (likewise)
12:41:02 <p0a> Hello I get a message "Stack has not been tested with GHC versions above 8.6" do I need to upgrade my stack?
12:41:08 <p0a> similar message for the cabal version
12:42:14 <dsal> I get that om the latest version. WFM
12:42:43 <p0a> thank you 
12:44:02 <sm[m]> as far as I know no person has ever used the ghci debugger, including its developers
12:44:28 <p0a> I'm interested in installing the gnuplot wrapper but the installation instructions and use are for cabal and I use stack 
12:44:43 <p0a> should I also learn cabal or is it simple to translate the instructions for stack?
12:45:01 <sm[m]> p0a: you can ignore that or stack upgrade —git to see it less often
12:45:28 <p0a> sm[m]: thank you I will ignore it for now 
12:45:42 <p0a> Might run this command at the end of the day 
12:47:17 <p0a> I tried doing the simple thing of adding `gnuplot' to dependencies in packages.yaml, let's see if the build works 
12:48:03 <sm[m]> trial and error is pretty unlikely to work with haskell installs, I must tell you :)
12:48:16 <p0a> This time it worked so there was trial and sucess I think
12:48:38 <sm[m]> Hurrah ! 😎
12:50:43 <p0a> So stack creates src/ and app/, but I am not sure what their distinction is 
12:51:05 <p0a> I want to try to play around with some gnuplot examples, should I put them in src/ and call them from app/Main.hs or should I put them in Main.hs?
12:51:55 <p0a> I'm asking because wherever I put them I will have to import modules (the gnuplot stuff) so I am not sure where those lines belong
12:53:47 <maerwald> p0a: it's worthwhile to understand both tools
12:54:09 <maerwald> In the end, the underyling stuff is the same (.cabal file)
12:54:31 <p0a> While I do agree I operate on limited time, grey cells and stamina
12:54:51 <p0a> my end goal is not to get a programming job but do the thing :P
12:55:00 <frdg> if a monoids give us a way of combining structures, and functors are structures we can map over, is an applicative a thing we can combine and map at the same time?
12:55:10 <maerwald> p0a: then do whatever you do... ;)
12:55:24 <hseg> is there some way i can derive a Monoid instance for data instance F T = N M, where M is a Monoid?
12:55:39 <maerwald> not much value switching tools when all you want is getting something done
12:55:55 <hseg> GND fails since it's not a newtype, derivingvia complains the representation differs
12:56:05 <solonarv> frdg: yes, there is some relationship there
12:56:15 <hseg> even though the rhs is literally N M and i'm trying to derive via M
12:56:18 <p0a> maerwald: there's surprising tradeoffs though
12:56:37 <hseg> and Monoid isn't stock and has no generic instance, so cannot be derived those ways
12:56:46 <solonarv> hseg: you can also write 'newtype instance' and that will make an instance that's a newtype rather than a data type
12:56:46 <p0a> maerwald: I write the fastest in lisp; I encountered compiler bugs that prevented me from doing what I wanted; I wrote it in haskell; too slow. I wrote it in C++, worked but I was exhausted
12:56:50 <frdg> solonarv: ok im at least on the right track then!
12:57:16 <p0a> maerwald: this is a previous project, but an example. Recently I've been a lot more interested in haskell because one day I'd like to write some interesting stuff I have in my head in it
12:57:24 <hseg> solonarv: ty
12:57:34 <solonarv> frdg: notably, if (mempty, (<>)) is a monoid, then (pure mempty, liftA2 (<>)) is also a monoid
12:57:49 <sm[m]> p0a: similar constraints here and I use stack for that reason. Others here feel the opposite
12:57:51 <hseg> and that does point out i needed to expand the context anyway, so here comes standalonederiving
12:57:53 <Uniaika> p0a: regarding src/ and app/, src/ contains the library, app/ contains the executable
12:58:05 <p0a> Uniaika: thank you 
12:58:07 <Uniaika> they have different stanzas in Cabal / Stack's package.yaml
12:58:55 <frdg> solonarv: hmm, ok I'll keep that in mind as I continue learning about applicatatives. Thanks!
12:59:36 <maerwald> koz_: I'm setting up my cross toolchain *sunglasses on*
12:59:46 <maerwald> takes so long to build
13:00:29 <solonarv> frdg: also, there is a more abstract sense in which "F is an Applicative" means that F is a specific sort of monoid
13:00:45 <solonarv> and if you squint a bunch, the applicative laws look like monoid laws
13:01:48 <hseg> a la the infamous "monads are just monoids in the category of endofunctors, what's the problem?"
13:01:57 <merijn> Not really
13:02:05 <solonarv> yes, I was wondering whether to bring that up
13:02:25 <solonarv> merijn: yes really, in exactly the same sense (but with a different tensor product)
13:02:37 <solonarv> for Monad, the tensor product is composition; for Applicative it's Day convolutio
13:02:58 <solonarv> n
13:03:21 <p0a> does anyone have any experience with the gnuplot wrapper?
13:03:23 <merijn> solonarv: I mean "not really" in the sense that the monoid instances for any applicative are straightforward and expressible in Haskell
13:03:28 <p0a> I just ran the example file but nothing happened 
13:03:44 * hackage dobutokO2 0.33.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.33.0.0 (OleksandrZhabenko)
13:03:49 <merijn> solonarv: Unlike the "monoid in the category of endofunctors" which is not directly expressible in Haskell at all
13:03:50 <solonarv> merijn: oh, that's what you meant
13:03:55 <sm[m]> you should probably provide a link to what that is
13:04:24 <solonarv> I even mentioned that above , I just didn't name it as such
13:04:34 <hseg> ah. and the (pure mempty, liftA2 (<>)) monoid is not the day monoid, as well, unless i'm mistaken 
13:04:41 <merijn> p0a: I looked at it once, realised it was a Thielemann package and gave up ahead of time >.>
13:05:22 <p0a> merijn: not familiar with Thielemann, too hard?
13:05:48 <p0a> merijn: do you think easyplot will do?
13:06:10 <solonarv> day convolution can be defined in haskell as such: data Day f g a where Day :: forall f g a x y. (x -> y -> a) -> f x -> g y -> Day f g a
13:06:11 <merijn> p0a: He believes in "all imports should be qualified" which also means he believes "meaningful names for types and classes are pointless"
13:06:24 <merijn> p0a: So all his types are called T, all his classes are called C, etc.
13:06:59 <p0a> merijn: sounds like a lone cowoby
13:07:00 <p0a> cowboy*
13:07:07 <p0a> lol
13:07:26 <solonarv> one can show that this is a functor if f and g are, and it's associative (up to isomorphism), and Identity is an identity for it (again up to iso)
13:08:06 <solonarv> you can then define: class Applicative f where pure :: Identity ~> f; liftA2 :: Day f f ~> f
13:08:33 <solonarv> and 'type f ~ g = forall x. f x -> g x' is the type of natural transformations
13:09:09 <p0a> merijn: I don't have gnuplot installed that's why it doesn't work. I switch systems often and I forget
13:09:13 <solonarv> expanding the type of pure: forall a. Identity a -> f a; but Identity a is the same as a, so this is just the usual a -> f a
13:09:24 <p0a> merijn: now that you mention it I do see the .T in the sourcecode a lot, hehe
13:09:38 <merijn> p0a: Try looking at the docs >.>
13:10:41 <solonarv> we can also expand the type of liftA2: Day f f a is the same as (exists x y. (x -> y -> a, f x, f y)), so liftA2 :: forall a x y. (x -> y -> a) -> f x -> f y -> f a
13:19:39 <p0a> merijn: I will not use that project because I dont' know why it doesn't work (no error either)
13:20:08 <p0a> merijn: someone recommended haskell-chart but it says it's not interactive. I'd like something I can use from the REPL, I'll try easyplots next
13:20:12 <p0a> (appealing name)
13:21:50 <merijn> I wish I had a haskell plotting library to recommend, but I'm not too impressed by any of them
13:24:00 <p0a> I'm sure your bar is higher than mine
13:25:40 <sm[m]> Chart is going to be the most mature I expect
13:26:17 <sm[m]> and hvega is probably the most powerful/productive
13:27:18 <p0a> I am told to add - easyplot-1.0@sha256:3fec6ccf425b370ab668eb342bc4cd92777880653e27a982db7b225fd007cb2b,1936 to my stack.yaml but then there's an error about ``could not find expected ':' while scanning a simple key''. What does that mean?
13:28:15 <p0a> ah okay I had to remove the package.yaml line for `easyplot' after adding the above line to stack.yaml
13:28:35 <sm[m]> I usually don't bother with the @... part. Too ugly.
13:28:47 <p0a> out of sight out of mind
13:31:14 * hackage WEditorHyphen 0.1.0.0 - Language-specific hyphenation policies for WEditor.  https://hackage.haskell.org/package/WEditorHyphen-0.1.0.0 (ta0kira)
13:33:23 <p0a> so I added easyplot to my stack.yaml and now the project builds but how do I import Graphics.EasyPlot? The module is not found from stack ghci
13:35:13 <sm[m]> p0a: did you add it to yourpackage.cabal build-depends also ?
13:35:24 <p0a> oh no 
13:35:32 * p0a didn't know this was necessary
13:36:10 <maerwald> p0a: foo.cabal files are the primary source of truth about how a package is to be built
13:36:20 <maerwald> no matter if you use stack, cabal or nix
13:36:27 <sm[m]> yep.. and usually in the other order. It's required in .cabal to be importable, and it may be required in stack.yaml if it's not part of the stackage snapshot
13:37:02 <p0a> so what do I do?
13:37:14 <p0a> add easyplot-1.0 in build-depends:
13:37:17 <sm[m]> you need it in both places
13:37:44 <p0a> on all of library, executable and test?
13:38:44 <sm[m]> p0a: possibly.. try one and see
13:39:11 <p0a> of course now it complains that easyplot-1.0 is wrong and easyplot should be used
13:39:16 <p0a> god computers sometimes feel like mysticism
13:39:35 <p0a> ah! success, thank you very much 
13:42:06 <sm[m]> hooray! That is a rare example of a 7 year old haskell package just working (though it probably didn't feel like it :)
13:42:37 <koz_> maerwald: Yay! Hope it all works. :D
13:42:49 <maerwald> koz_: no, gcc failed to compile xD
13:43:20 <koz_> maerwald: Compiling GCC is a fun task, lol.
13:43:32 <maerwald> I'm on a source distro
13:43:39 <maerwald> but there's a problem with mpfr it seems
13:44:10 <maerwald> gcc needs a cross-compiled mpfr lib already, but I can't build one without a cross gcc
13:44:20 <maerwald> gg
13:45:16 <p0a> dont cross gcc
13:46:33 <koz_> maerwald: Yeah, it's true of a bunch of things.
13:46:40 <koz_> Including glibc, which is its own kind of fun.
13:57:20 <p0a> What's a vector library for haskell?
13:57:32 <p0a> Doing things like addition of vectors, dot products and other basic geometry
13:57:51 <monochrom> I use hmatrix. But not a heavy user.
13:58:18 <monochrom> And not a type-level statically check bounds kind of guy.
13:59:00 <p0a> looks nice
14:00:31 <solonarv> p0a: for basic linear algebra, there is a library unimaginatively named 'linear'
14:01:30 <p0a> "Types and combinators for linear algebra on free vector spaces"
14:01:35 <p0a> nerdiest possible description
14:03:23 <solonarv> well, it's accurate :>
14:03:33 <p0a> solonarv: what's V1,V2,V3,V4,V0 ?
14:03:44 <p0a> I think V2 is a plane vector. Is V0 an arbitrary vector?
14:04:03 <p0a> nevemrind, it's V n a for arbitrary vector 
14:04:36 <p0a> yeah linear looks good too, but hmatrix looks a little more like what I want, because I /may/ use matrices as well
14:05:21 <p0a> (which linear emulates with vectors of vectors; but matrices are not vectors of vectors; they're covectors of vectors, etc)
14:06:31 <solonarv> eh, those are pretty much the same thing in linear's representation
14:06:57 <solonarv> it's probably not very good if you want to do more coordinate-/basis-independent stuff
14:07:10 <p0a> Well if you go for some type correctness, why not implement tensors?
14:07:18 <p0a> I think that's what linear's focus is
14:07:27 <p0a> (btw haskell noob here but I know some math)
14:08:49 <solonarv> I think linear is mostly used for, uh, straightforward practical applications
14:09:05 <solonarv> like "I have a game where objects are positioned in 3D space" sort of practical application
14:11:50 <p0a> You're right I'm just missing the point
14:12:38 <p0a> sure enough though, there's the unimaginative `tensor' for tensors :P
14:13:52 <Phyx-> sm[m]: it works all the way back to nt4, those "problems" are really only with PATH because environment variables on Windows are multiscoped. PATH is the only recursive one. the problem isn't really setx, it's how you get only the entries for a single scope
14:16:09 <p0a> solonarv: interestingly `tensor' doesn't seem to make a distinction between vector and covector either (i.e. upper/lower indices)
14:20:35 <p0a> hTensor seems to have all the features I am mentioning
14:23:44 * hackage WEditor 0.2.0.2 - Generic text-editor logic for use with fixed-width fonts.  https://hackage.haskell.org/package/WEditor-0.2.0.2 (ta0kira)
14:25:04 <p0a> When I get that <> clashes from Prelude and Numeric.LinearAlgebra what should I do to make sure that <> is used from the latter?
14:25:14 * hackage WEditorBrick 0.2.0.1 - Text-editor widget with dynamic line-wrapping for use with Brick.  https://hackage.haskell.org/package/WEditorBrick-0.2.0.1 (ta0kira)
14:25:20 <ziman> import Prelude hiding ((<>))
14:25:25 <p0a> thank you ziman 
14:25:45 <ziman> you may also want to import qualified Prelude in case you need it, too
14:26:15 * hackage WEditorHyphen 0.1.0.1 - Language-specific hyphenation policies for WEditor.  https://hackage.haskell.org/package/WEditorHyphen-0.1.0.1 (ta0kira)
14:29:46 <frdg> `<*>` reminds me of `zipWith`. Do these functions somewhat do similar things? 
14:33:26 <hexagoxel> frdg: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:ZipList
14:35:10 <hexagoxel> That is, you can define an Applicative on lists that gives zipWith behaviour. The "normal" list instance is a different one though.
14:35:53 <frdg> hexagonal: cool! so they are similar in way
14:36:39 <merijn> That Applicative is already defined for you :p
14:37:13 <hexagoxel> > (*) <$> [2,3] <*> [5,7]
14:37:15 <lambdabot>  [10,14,15,21]
14:37:19 <merijn> frdg: The "problem" with the zip-like Applicative is that there is no lawful Monad with the same behaviour
14:37:21 <hexagoxel> > (*) <$> ZipList [2,3] <*> ZipList [5,7]
14:37:24 <lambdabot>  ZipList {getZipList = [10,21]}
14:37:25 * p0a is going to try to use Chart and is almost ready to write some nice code with Chart & hmatrix!
14:37:43 <merijn> frdg: And for sanity and consistency's sake the Applicative and Monad for a type should be compatible
14:37:53 <frdg> hexagoxel: I see the difference! thanks
14:38:31 <frdg> merijn: ok ill remember that. Thank you
14:43:14 * hackage haskoin-store 0.21.6 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.21.6 (jprupp)
14:51:15 * hackage snappy-lazy 0.1.0.0 - Lazy bytestring compression and decompression  https://hackage.haskell.org/package/snappy-lazy-0.1.0.0 (vmchale)
15:05:15 * hackage WEditor 0.2.1.0 - Generic text-editor logic for use with fixed-width fonts.  https://hackage.haskell.org/package/WEditor-0.2.1.0 (ta0kira)
15:06:15 * hackage WEditorHyphen 0.1.0.2 - Language-specific hyphenation policies for WEditor.  https://hackage.haskell.org/package/WEditorHyphen-0.1.0.2 (ta0kira)
15:38:50 <p0a> I'm a bit confused on how I go about using Chart 
15:39:05 <p0a> the instructions https://github.com/timbod7/haskell-chart/wiki/Getting-started start from an empty stack.yaml file
15:39:12 <p0a> but I'd like to incorporate Chart to a project I already have 
15:40:11 <slack1256> Why don't you add Chart as a dependency then?
15:41:34 <sm[m]> yup.. step 1, get it building as part of your project
15:42:04 <sm[m]> you'll need both the Chart and Chart-diagrams packages, I suppose
15:42:11 <p0a> this is what I get adding -chart to package.yaml https://pastebin.com/PgGcSJjV
15:42:32 <sm[m]> it's Chart
15:43:00 <p0a> okay 
15:43:28 <p0a> great, thank you 
15:44:52 * slack1256 never learned stack ;_;
15:45:34 <p0a> can't say I've learned anything really I can't operate it without external help
15:45:44 <monochrom> But did you learn slack? :)
15:46:15 <sm[m]> like cabal, it's got a good manual, but I know that's considered cheating :)
15:47:09 <slack1256> monochrom: yep 
15:47:17 <slack1256> it's all a lazy thunk on my head.
15:47:44 <monochrom> That's literally slacking off haha
15:48:14 <slack1256> I don't know if I was a slacker before or the name influence my personality until I became "slack1256" for real.
15:53:23 <koz_> TIL Vector UNPACKs.
15:57:55 <p0a> sm[m]: thank you, I also needed Chart-diagrams 
16:09:44 * hackage tempi 1.0.1.1 - For representing musical tempi  https://hackage.haskell.org/package/tempi-1.0.1.1 (dktr0)
16:18:22 <p0a> instead of package-exe is there a way to name the executable that `stack build' produces?
16:18:34 <p0a> I may just write a renaming bash script
16:21:48 <mniip> how come Set doesn't have a mapMaybe
16:22:14 * hackage with-utf8 1.0.1.0 - Get your IO right on the first try  https://hackage.haskell.org/package/with-utf8-1.0.1.0 (kirelagin)
16:25:48 <slack1256> mniip: I always thought mapMaybe didn't belong just to Data.Maybe.
16:27:43 <mniip> slack1256, well Set isn't a functor so it's hard to make a specialization of some generic function for it
16:27:51 <mniip> but the specific function is pretty clear and useful
16:28:13 <slack1256> You maybe can me a generic function via Foldable, which Set is part of.
16:29:38 <slack1256> mapMaybe f set = foldr (\accSet val -> case f val { Just realVal -> insert realVal acc ; Nothing -> acc }) empty set
16:29:46 <slack1256> Something along the lines.
16:32:49 <mniip> that sounds super inefficient
16:32:58 <mniip> not respecting the tree structure at all
16:34:04 <p0a> if you're worried about efficiency won't you have to do it from inside the implementation of Set?
16:34:42 <p0a> Maybe the answer to your question is that Set is inefficient by design :P Is it not?
16:36:16 <slack1256> mniip: Folds for tree-like structures are weird (there isn't not a by construction order on them as in list) and you are right, we lose a lot of sharing this way.
16:37:09 <slack1256> In fact there is a post on ezyang blog about a space caused by the lack of sharing when updating a IntMap via a `map` like function, which reconstructed the tree each time.
16:37:28 <slack1256> a space leak
16:37:45 <mniip> it's not about sharing
16:38:15 <mniip> I'm talking like
16:38:25 <mniip> if you don't remove any keys you don't have to do rebalancing at all
16:39:08 <slack1256> I wonder if Set has an `alter` function la Data.Map
16:43:10 <slack1256> Well, if `Set` had an `alter` function as Data.Map, you could preserve the balance of the set when removing elements with a `mapMaybe` function.
16:43:31 <solonarv> no, you could not: Set a is structurally the same as Map a ()
16:43:45 * hackage shake-bindist 1.1.0.0 - Rules for binary distributions  https://hackage.haskell.org/package/shake-bindist-1.1.0.0 (vmchale)
16:44:00 <solonarv> so the type of alter would be: a -> (Maybe () -> f (Maybe ())) -> f (Set a)
16:44:17 <solonarv> erm, oops, a -> (Maybe () -> Maybe ()) -> Set a
16:49:52 <slack1256> alter-like then?
16:50:15 <solonarv> the equivalent would be changing the key of a Map entry as well
16:50:38 <solonarv> k -> (Maybe (k, v) -> Maybe (k, v)) -> Map k v
16:50:52 <solonarv> which is clearly possible, but there's no reason to expect that it should be efficient
17:00:45 <dmwit> mniip: I guess if you want efficiency it would have to at least be mapMonotonicMaybe.
17:01:05 <mniip> sure
17:01:20 <mniip> in an odd coincidence of events I'm doing a monotonic operation
17:01:21 <dmwit> And then I guess the question is: would that really be more efficient than fromAscList . mapMaybe . toAscList ?
17:01:31 <dmwit> Probably not?
17:01:35 <mniip> in another odd coincidence of events my operation actually decomposes into a map and a filter actually
17:01:53 <mniip> but I expect that would not happen in general
17:02:20 <dmwit> I expect that it decomposes into a filter then a map in general.
17:02:30 <dmwit> Hard to imagine how it could be otherwise.
17:04:21 <p0a> a filter/map transverses twice whereas apply function and filter in place transverses once
17:04:57 <p0a> I suppose that is not so important in terms of efficiency. Probably a Set is not huge anyway
17:11:08 <slack1256> For the bang patterns on Data.Set.filter, yeah, it seem you have to traverse twice.
17:11:18 <slack1256> it seems
17:16:25 <monochrom> "map . filter" is both "map and filter" and "filter then map". :)
17:17:39 <monochrom> both are foldr's. Some fusion is in order.
17:20:21 <solonarv> on Set, though?
17:20:50 <monochrom> Oh, then I don't know! Nevermind me!
17:20:51 <slack1256> I don't think you can express a Set as a `build` which maintains a balance invariant. But this is an argument by lack-of-imagination :-) .
17:22:26 <solonarv> indeed after chasing definitions I can confidently say that there is no fusion framework for Set in containers
17:23:07 <solonarv> (I looked at 0.6.0.1 to be precise)
17:25:02 <slack1256> Which give me the idea that if you have a long fusable-pipeline with lots of map, filte and else, you could pass from Set a -> [ a ] , do your fusable pipeline work here and the [ a ] -> Set a .
17:25:17 <slack1256> It would be probably more efficient that the native Set operations.
17:26:15 <solonarv> actually, perhaps multiple subsequent 'map' calls do fuse with 'fromList . toList = id' rules
17:26:18 <solonarv> I don't know.
17:26:50 <solonarv> oh! there is some fusion!
17:27:58 <slack1256> solonarv: Can you provide a link?
17:28:12 <solonarv> starts here: https://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Set.Internal.html#foldrFB
17:28:23 <solonarv> scroll up a few lines for comments
17:28:30 <slack1256> Duh, the internal module, obviously
18:01:45 * hackage WEditorHyphen 0.1.0.3 - Language-specific hyphenation policies for WEditor.  https://hackage.haskell.org/package/WEditorHyphen-0.1.0.3 (ta0kira)
18:35:08 <p0a> Hello say point is a struct {int x,y;} and I want to have a function f(point p)
18:35:22 <p0a> but instead I'd like to destructure p so that I have something like f(point {x,y}). Is that possible?
18:35:37 <p0a> (in the function definition)
18:35:57 <Axman6> that doesn't look like haskell to me
18:36:16 <p0a> Yeah wrong channel, thank you 
18:36:22 <Axman6> rust?
18:36:25 <p0a> C++
19:30:39 <johnw> is there an optic that lets you address two locations at once? I.e.,  (1 :: Int, 2 :: Int) & pairing _1 _2 .~ (3, 4)  ==>  (3,4)
19:32:07 <johnw> I guess what I want is vertical composition of lenses
19:33:39 <solonarv> johnw: yes, but it's unsafe (for lenses)
19:33:53 <johnw> https://stackoverflow.com/questions/48466752/horizontal-composition-of-lenses answers it
19:34:02 <solonarv> the reason it's unsafe is that you don't know that the targets don't overlap; and if they overlap and you use the lens to set, you get weird results
19:34:56 <solonarv> if they are actually just getters/folds then you can do it
19:35:20 <solonarv> there's probably an operator for that somewhere in lens, too
19:37:03 <johnw> I know it's safe in my use case, if it already exists
19:37:07 <solonarv> for some uses the Applicative (or Monoid, etc) instance for functions actually does what you want
19:37:29 <solonarv> if you're not just getting then you have to use the unsafe combinator
19:37:40 <solonarv> it's in lens, but I can't remember what it's called
19:38:07 <johnw> I have a function, two prisms into different places, and a function a -> b -> (c, d) that I'd like to apply to those two places
19:38:12 <johnw> s/function/structure
19:39:26 <solonarv> there's alongside which was mentioned in that SO answer, and there is Control.Lens.Unsound.lensProduct
19:39:42 <solonarv> oh you have prisms, not lenses? hm, then I don't know
19:46:30 <johnw> actually, they are Traversal'
19:47:40 <johnw> thanks
19:50:17 <johnw> alongside isn't quite it
19:50:27 <johnw> it assumes that your structure is already a tuple
20:03:04 <rotaerk> is there a way to force cabal to rebuild a hackage package
20:03:39 <p0a> In my stack project if I add something like `data Point = Point Int Int' in my src/Lib.hs and then run ghci with `stack ghci' can I do something like `:t Point 1 2' ?
20:03:41 <rotaerk> something I have in my build-depends, that is
20:04:57 <MarcelineVQ> p0a: That's quite an easy thing to determine yourself, are you having trouble?
20:05:06 <p0a> MarcelineVQ: yeah 
20:05:16 <p0a> MarcelineVQ: `Data constructor not in scope' ..
20:05:32 <p0a> OHHH... I need to build the project again
20:06:04 <p0a> Nope, not that. I am not sure what's wrong
20:06:40 <MarcelineVQ> does your Lib module have an export list at the top that Point isn't in?
20:06:57 <p0a> indeed, thank you... I am not thinking
20:06:59 <rotaerk> hmm nm; I think I can just move it out of .cabal/store
20:07:01 <MarcelineVQ> iirc a stack project has an explicit export list in the Lib modules, I'd remove the explicit list myself
20:07:09 <MarcelineVQ> *module
20:07:59 <p0a> thank you
20:12:02 <mniip> I need a really efficient Set Integer (not Int)
20:12:05 <mniip> any ideas?
20:12:25 <mniip> (the Integers are bitmasks)
20:14:19 <mniip> actually, make that Natural
20:16:04 <p0a> mniip: what's the bottleneck?
20:17:19 <mniip> my program is spending 47% time and 36% alloc on a line that does a S.mapMonotonic and S.filter
20:17:44 <p0a> Do you know why?
20:18:50 <mniip> because these are sets of a fair size
20:19:17 <mniip> hundreds of thousands of integers no more than 2 limbs in size
20:19:46 <p0a> Does it matter how large the integers are though? Isn't it purely the set size?
20:20:06 <mniip> well the mapMonotonic does an allocation
20:20:15 <mniip> because it outputs a different integer than the input
20:20:27 <p0a> I guess I am asking if by changing the integers to smaller integers you see an improvement 
20:20:35 <mniip> ah
20:21:58 <mniip> marginal improvement
20:22:18 <mniip> let me check how IntSet behaves here
20:22:44 * hackage maquinitas-tidal 0.2.2 - library for MIDI control of hardware  https://hackage.haskell.org/package/maquinitas-tidal-0.2.2 (montoyamoraga)
20:23:11 <mniip> IntSet does not have mapMonotonic...
20:23:53 <p0a> My own question is this: I want to use hmatrix for my project; I want to define a `data Edge = Edge Vector Vector' where Vector is a hmatrix vector; I am not sure what the type of hmatrix's vector is; if I do `:t vector [1,2,3]' I get Numeric.LinearAlgebra.Vector R
20:25:02 <slack1256> p0a: That's hmatric vector type
20:25:07 <slack1256> hmatrix
20:25:18 <p0a> slack1256: so I'd have data Edge = Num....Vector R Num...Vector R?
20:25:24 <p0a> I mean with the constructor that I forgot
20:25:35 <mniip> haha seems like I've been having similar problems a couple years ago https://github.com/mniip/nibble-trie/blob/master/src/Data/Trie/Nibble/Internal.hs
20:25:39 <mniip> shame I didn't finish it
20:25:57 <slack1256> p0a: Sound right.
20:26:00 <p0a> slack1256: thank you 
20:26:16 <rotaerk> hmm when building bindings-GLFW, it tries to do a #include <GL/gl.h> ... what drives where it will look for these headers?
20:26:24 <p0a> slack1256: but with parentheses? There's a space between .Vector and R
20:26:47 <slack1256> hmatrix Vector is parametrised by a numeric field, which there are readily available, Real numbers (R) and complex number (C).
20:26:52 <Axman6> data Edge = Edge (Vector R) (Vector R)
20:27:12 <slack1256> The inner product, which is a function on hmatrix, changes it's definition depending on the field.
20:27:14 <Axman6> assuming you have imported Numeric.LinearAlgebra
20:27:27 <p0a> thank you Axman6 
20:27:58 <p0a> slack1256: gotcha 
20:28:08 <p0a> I didn't know that's what R stood for, I assumed something else
20:28:19 <slack1256> type R = Double 
20:28:20 <p0a> I would also like to use it with finite fields, say Z_3. Do you know how to do that?
20:29:30 <slack1256> Mmm sadly no out of the box. I just used it over R and C.
20:29:35 <p0a> okay, thank you 
20:29:42 <Axman6> looks like hmatrix works on types which are in the Numeric class: https://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/Numeric-LinearAlgebra.html#t:Numeric
20:29:43 <p0a> ther'es some stuff in the tutorial I will check it out later 
20:30:17 <slack1256> p0a: https://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/Numeric-LinearAlgebra.html#t:Numeric
20:30:27 <Axman6> and that includes MKnownNat => Mona m I and Z (CInt and Int64)
20:30:39 <slack1256> Like Axman6 says.
20:30:46 <p0a> mniip: I don't know what the benefit of using Set is; I suspect that using a different data structure and only turn it into a Set at the very last step would be faster
20:30:48 <Axman6> KnownNat m => Mod m Z
20:31:04 <p0a> Axman6: nice, thank you. Is that standard Haskell?
20:31:13 <mniip> well the mathematical object I'm working with is a set
20:31:47 <p0a> mniip: I guess what I'm saying is this: If you have a set {1,2,3} and decide to add 1 million elements to it; it's better to do it to a list and then turn it into a set at the end
20:32:03 <Axman6> what is standard haskell?
20:32:04 <slack1256> p0a: It is defined on hmatrix, so at least plays well with the rest of the library.
20:32:09 <mniip> like I said the bottleneck is in mapMonotonic and filter
20:32:10 <p0a> slack1256: okay, thank you
20:32:17 <mniip> very specific functions in Data.Set
20:32:36 <Axman6> mniip: could you perhaps just use a sorted vector?
20:32:41 <slack1256> It seems (Mod n) is just a newtype over Int with a restriction to safe operations Z/nZ .
20:32:50 <mniip> actually
20:32:53 <p0a> mniip: I don't know what mapMonotonic and filter do exactly because I don't know the internals of Set
20:32:55 <mniip> maybe I don't need the full power of filter
20:32:59 <Axman6> if you're not inserting much, then a map and filter might be pretty fast
20:33:02 <mniip> rather some sort of partition-twice
20:33:13 <p0a> slack1256: thank you 
20:35:01 <mniip> Axman6, I don't insert at all
20:35:21 <mniip> but I do union a lot
20:35:37 <mniip> and I'm not sure how small the "building blocks" can be
20:36:05 * slack1256 really hopes union is not implemented as a series of inserts.
20:36:21 <mniip> it isn't
20:36:49 <mniip> hedge-union or something
20:37:01 <Axman6> if you know the size of the values, then https://hackage.haskell.org/package/wide-word plus using unboxed vectors might be quite useful
20:38:21 <mniip> hmm
20:38:33 <mniip> I do have an upper bound on the resulting thing's size
20:38:57 <mniip> so many I could allocate that and then shrinkMutableByteArray or something
20:39:05 <p0a> you can also try this
20:39:05 <mniip> but I would still need to deduplicate the data
20:39:06 <Axman6> though merging wouldn't be a fast
20:39:10 <mniip> yeah
20:39:14 <p0a> pretend you didn't care it's a set and try the same algorithm with duplicates
20:39:18 <p0a> see if that speeds up things
20:39:34 <mniip> definitely not
20:40:16 <p0a> why not?
20:40:54 <mniip> the deduplication is crucial
20:41:07 <mniip> I'm essentially doing dynamic programming with these sets
20:41:27 <mniip> like you would do with a Map
20:41:42 <mniip> but here the keys actually already contain the data that would be in the "values" of the Map
20:42:15 <p0a> Do you need to deduplicate at every step? That's what Set does as far as I understand it but I may be wrong
20:43:42 <mniip> kinda yeah
20:47:22 <p0a> then I guess the question is "What are the best results for handling Sets and does Haskell implement them?" and I don't know the answer to neither, I'm sorry 
20:48:30 <Axman6> if there's some kind of sparse bit set, then you could use that. merging is just or, and filter would probably be pretty efficient too
20:51:54 <mniip> eh?
20:54:46 <p0a> well basically if they're already disjoint you're fine
20:57:23 <p0a> so [vector [i,j] | i <- [0..3], j<-[0..3]] works in ghci but not in my code. I tried i::Double, j::Double as well; it still complains
20:57:42 <p0a> there's some type mismatch but I don't understand it; Definitely i::Int fails in both the REPL and my code with the same error
20:58:51 <p0a> I tried replacing it with ::R as well ,that didn't work 
20:59:11 <Axman6> well, sharing the error with us might help
23:08:26 <dsal> Is there a better way to write this?   (_Just . deep  values . _Object %~ (sans "url" . sans "head" . sans "heads" . sans "urls"))
23:08:51 <dsal> I've got some chunk of JSON that has a bunch of ephemeral URLs nested in it and I want to delete them.
23:11:52 <tdammers> as far as lens syntax goes, I'm pretty convinced it doesn't get better than that
23:12:08 <tdammers> modulo parens
23:13:51 <dsal> Oh, huh.  I thought I'd need those inner ones some.
23:14:01 <dsal> The outer ones are because of how I was using it in testing, but that's also dumb.
23:14:30 <sheepfleece> Hello, I remember somebody announced a path library which uses `Text` instead of `String`. It was a couple of months ago. But I can't find it :c
23:14:51 <dsal> I was kind of hoping for a sanses kind of thing.  I could write it, but I just have this one function...
23:15:08 <dsal> This compiles, though:   stripURLs = _Just . deep  values . _Object %~ sans "url" . sans "head" . sans "heads" . sans "urls"
23:15:46 <dsal> Thanks, tdammers.  Now I can sleep...
23:20:01 <tdammers> I think . has higher precedence than %~
23:24:40 <c_wraith> . has precedence 9
23:24:55 <c_wraith> So it usually has higher precedence than other operators
23:25:24 <nitrix> %~ is infixr 4
23:28:16 <sheepfleece> Oh, I found it! It uses `ByteString` instead of `Text` though. https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.6/docs/System-FilePath-Posix-ByteString.html
23:28:18 <tdammers> yeah. so that's why you don't need the parens
23:54:14 * hackage codeworld-api 0.5.0 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.5.0 (ChrisSmith)
