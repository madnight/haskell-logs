01:28:14 * hackage cache-polysemy 0.1.0 - cached hashmap  https://hackage.haskell.org/package/cache-polysemy-0.1.0 (Poscat)
02:27:03 <asheshambasta> when does it make sense to have version bounds this strict? https://github.com/zohl/servant-auth-cookie/blob/v0.6.0.3/servant-auth-cookie.cabal
02:27:42 <asheshambasta> and wouldn't not having an upper version bound cause build errors anyway? Why are they required?
02:27:54 <asheshambasta> (in case of incompats)
03:00:06 <asheshambasta> and, are there alternatives to servant-cookie-auth at the moment for cookie based auth. in Servant?
03:10:14 * hackage taskwarrior 0.1.2.4 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.1.2.4 (maralorn)
03:17:50 <dmj`> asheshambasta: servant-auth should have cookies in it
03:18:24 <dmj`> asheshambasta: not too hard to just use type API = "foo" :> Header "Cookie" Text :> Get [JSON] Thing
03:19:43 <maerwald> What is ~/.cabal/store/roots
03:21:06 <dmj`> maerwald: es verboten
03:30:19 <isovector1> is there a solution to GND for traverse yet?
03:30:47 <isovector1> running into an equivalent problem attempting to derive via a bitraverse instance
03:47:37 <haasn> When was Applicative added to Prelude?
03:48:51 <haasn> Seems to have been in base 4.8
04:43:42 <kuribas> hi, in SBV, how do you know the operations are exactly the same as the ones you prove?  
04:44:04 <kuribas> For example, addition on SWord64, vs addition on Word64
04:44:10 <kuribas> is there a proof they are identical?
04:45:31 <kuribas> Or does it have a test suite to test this?
05:00:49 <int-e> kuribas: There are some tests checking that the SMT encoding produces the type (_ BitVec 64) for them, I believe. Otoh, it doesn't look as if signed addition is treated differently from unsigned addition at all, see  https://github.com/LeventErkok/sbv/blob/master/Data/SBV/SMT/SMTLib2.hs#L894 ff.
05:02:13 <kuribas> int-e: because bvadd works on signed and unsigned?
05:02:15 <int-e> kuribas: (Though that's not fully conclusive; it's possible in principle that it generates side conditions elsewhere. I don't know.)
05:03:05 <int-e> kuribas: Well the only reason to treat them differently would be to capture undefined behavior as, say, specified in C.
05:03:52 <kuribas> are overflow on integers undefined in C?
05:04:06 <int-e> overflows of *signed* integer types are undefined.
05:04:18 <aveltras> is there a simple way to get the current package root directory at compile time ? 
05:04:26 <int-e> overflows of unsigned integer types work modulo 2^<word size>
05:04:51 <int-e> I forgot what Haskell specifies here...
05:05:35 <int-e> "All arithmetic is performed modulo 2^n, where n is the number of bits in the type."
05:05:53 <int-e> So that use of bvadd is perfectly fine in that context.
05:06:54 <int-e> (The odd thing Haskell does is that allows Int to have as few as 30 bits.)
05:07:58 <int-e> Odd coming from C, that is. If you're coming from ML, for example, it's not so strange.
05:09:37 <kuribas> int-e: 29 no?
05:09:47 <kuribas> int-e: to allow tags perhaps?
05:10:01 <kuribas> although that makes more sense in lisp than in haskell
05:10:42 <int-e> kuribas: -2^29 to 2^29-1 is 2^30 values
05:10:53 <kuribas> ah right :)
05:17:04 <EvilPyro> how can i intercalate two objects of the same type in an infinite list? It seems intercalate Machine [Player..]  being Machine and Player of the same type does not work
05:17:36 <merijn> > cycle [0,3]
05:17:37 <lambdabot>  [0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3...
05:17:42 <EvilPyro> oh nice
05:21:01 <maerwald> those damn thunks
05:25:18 <int-e> maerwald: a lazy bunch, all of them
05:36:36 <dramforever> > intersperse 123 [0..]
05:36:38 <lambdabot>  [0,123,1,123,2,123,3,123,4,123,5,123,6,123,7,123,8,123,9,123,10,123,11,123,1...
05:37:05 <dramforever> EvilPyro: Did you mean ^
05:38:00 <EvilPyro> no, cycle works with objects
05:38:54 <dramforever> @let data Side = Machine | Player deriving (Show)
05:38:56 <lambdabot>  Defined.
05:39:22 <dramforever> @let deriving instance Enum Side
05:39:25 <lambdabot>  Defined.
05:39:44 <dramforever> > intersperse Machine [Player..] -- This does have the correct type
05:39:47 <lambdabot>  <hint>:1:30: error: parse error on input ‘]’
05:39:53 <dramforever> > intersperse Machine [Player ..] -- This does have the correct type
05:39:56 <lambdabot>  [Player]
05:40:00 <dramforever> Not sure what you wanted though
05:40:13 <merijn> dramforever: He just wanted cycle like above?
05:40:30 <dramforever> Oh
05:40:42 <EvilPyro> > cycle [Machine, Player]
05:40:44 <dramforever> yeah, guess I put too much emphasis on 'intercalate'
05:40:44 <lambdabot>  [Machine,Player,Machine,Player,Machine,Player,Machine,Player,Machine,Player,...
05:40:49 <EvilPyro> that
05:41:16 <dramforever> whatever, glad you solve it one way or the other
05:55:56 <frdg>  How should I think about errors like this? "Couldn't match type ‘a’ with ‘b’ ‘a’ is a rigid type variable bound by the type signature for: "
05:57:15 <frdg> is a rigid type variable a variable where the compiler has completely decided its type?
05:58:30 <dramforever> :t let f :: a; f = 'x' in f
05:58:32 <lambdabot> error:
05:58:32 <lambdabot>     • Couldn't match expected type ‘a1’ with actual type ‘Char’
05:58:32 <lambdabot>       ‘a1’ is a rigid type variable bound by
05:59:36 <frdg> so a rigid type variable is the opposite of how I described it?
06:00:06 <dramforever> Actually it's completely decided
06:00:15 <dramforever> you just don't know what it is
06:00:21 <dramforever> An analogy would be:
06:00:29 <dramforever> > let f x = x in 3
06:00:33 <lambdabot>  3
06:00:51 <dramforever> Here in the function body, although x is a variable, you don't get to decide what it is
06:01:12 <dramforever> The caller specifies it for you. It's actually more of a constant for you
06:02:03 <dramforever> Similarly, when we have a polymorphic function:
06:02:18 <dramforever> > let f :: a -> a; f x = x in f 'x'
06:02:21 <lambdabot>  'x'
06:02:45 <dramforever> What actually happens is that f takes a type that the caller specifies
06:02:47 <frdg> im a bit unsure of the variables role in these examples
06:02:59 <dramforever> > let f :: forall a. a -> a; f x = x in f @Char 'x'
06:03:01 <lambdabot>  error:
06:03:01 <lambdabot>      Pattern syntax in expression context: f@Char
06:03:01 <lambdabot>      Did you mean to enable TypeApplications?
06:03:06 <dramforever> YES!
06:03:12 <dramforever> can i?
06:03:26 <EvilPyro> this fragment its producing an error but ghci doesent tell nothing more than possible indentation error: https://pastebin.com/ZRkADe0v Help, I dont know whats wrong (the play function its defined, I just dont include it for simplicity)
06:03:58 <merijn> EvilPyro: Ghci's support for multiline definitions is...primitive at best
06:04:11 <dramforever> EvilPyro: you're mixing tabs and spaces
06:04:18 <merijn> EvilPyro: I would recommend simply editing a text file and using ":load" to load the source
06:04:48 <merijn> dramforever: That seems less likely than "entering this as is doesn't work in ghci, because ghci doesn't support that" ;)
06:04:48 <dramforever> AFAIK GHC has tabstops at 8 characters and it doesn't know about wide characters
06:05:15 <merijn> dramforever: Unless you see actual evidence of tabs that affect this code? Which seems unlikely
06:05:29 <dramforever> I actually pasted the text into my editor which shows spaces
06:06:00 <dramforever> after main = do there are 6 space-indented lines, 1 tab-indented, 2 space-indented, 2 tab-indented
06:06:07 <merijn> dramforever: If I paste it into my editor I don't see any tabs, though?
06:06:28 <dramforever> frdg: imagine a language where you can do this:
06:06:34 <frdg> ok yes im here
06:06:36 <EvilPyro> so the solution is to change tabs to spaces?
06:06:38 <merijn> oh, I need to use "raw" maybe
06:06:49 <EvilPyro> I use tabs
06:07:16 <merijn> EvilPyro: Clearly not just tabs, as that raw paste includes both spaces and tabs :)
06:07:41 <dramforever> f (a :: Type) (x :: a) = x
06:07:47 <dramforever> Then when you call it
06:07:52 <dramforever> f Char 'x'
06:07:55 <dramforever> it returns 'x'
06:08:10 <dramforever> Can you see the similar role of a and x?
06:08:31 <EvilPyro> okay solved the issue configuring my ide properly and converting to tabs
06:08:40 <frdg> yes, a decides the type and x is the thing you want to return
06:09:02 <dramforever> I mean, how they are things specified by the caller
06:09:22 <merijn> frdg: The question is *who* decides what 'a' is? :)
06:09:44 <dramforever> In 'let v1 = a + b in ...', and 'f v2 = ...', v1 and v2 are different
06:09:46 <frdg> I think I see, so in Haskell we do both of these things at the same time
06:09:48 <merijn> frdg: Normally the *caller* of a function gets to pick what every type variable is, but this doesn't always work
06:10:30 <frdg> just to be clear, im the caller?
06:11:04 <dramforever> depends on which code you're in
06:11:19 <merijn> frdg: the caller is "the piece of code that contains the call"
06:11:30 <frdg> ok I see
06:12:11 <merijn> frdg: It might be useful to show an example where the caller does *not* pick the type for contrast. (Although this involves RankN types, so if you just get more confused by this example, just ignore it and pretend I didn't write it ;)
06:12:25 <merijn> frdg: https://gist.github.com/merijn/77e3fa9757658e59b01d
06:13:17 <merijn> frdg: Here's code where the caller *can't* decide what the type should be, because it doesn't have enough information. The Rank2 type changes the meaning so that the callee (i.e. function being called) is allowed to pick the type
06:13:35 <dramforever> I think the best way is just ignore the names and think why it doesn't match
06:14:05 <dramforever> > let f :: a; f = 'x' in f
06:14:07 <lambdabot>  error:
06:14:07 <lambdabot>      • Couldn't match expected type ‘a1’ with actual type ‘Char’
06:14:07 <lambdabot>        ‘a1’ is a rigid type variable bound by
06:14:45 <dramforever> f can be any type here, so if I specify it to be type Int, it would require Int to match with Char
06:15:40 <dramforever> so the type system is catching this
06:15:53 <frdg> ok I understand the problem with merijns code
06:16:16 <frdg> but im still not understanding the very simple examples 
06:17:26 <merijn> frdg: With "f :: a" says "'f' has whatever type the code using 'f' wants"
06:17:38 <merijn> frdg: but "f = 'x'" says "f has type Char"
06:17:49 <merijn> frdg: These things are, naturally, contradictory
06:18:32 <frdg> ohhhh ok I am very close to understanding. I think an explanation of where this question stems from will solidify it. One moment while I pastebin
06:21:05 <frdg> https://pastebin.com/wDQUYgYm
06:27:34 <frdg> merijn, dramforever: I understand now! thanks so much for your patience.
06:28:38 <merijn> frdg: Fun extra homework: Try and define Applicative and Monad too. Can you do so lawfully? If so, do you need any constraints?
06:30:44 <frdg> merijn: ill write this one down to try in the near future...next two chapters are Applicative and Monad!
07:17:14 * hackage telegram-types 0.2.0 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.2.0 (Poscat)
07:23:15 * hackage minizinc-process 0.1.0.0 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.0.0 (LucasDiCioccio)
07:41:00 <amx> Is there a library for serializing to Text using a writer monad, something like Data.Serialize or Data.Binary is for ByteStrings?
07:41:38 <merijn> amx: What do you mean "serialising to text"? Isn't that just pretty printing?
07:46:51 <amx> hmm, I suppose it is. Didn't think of it that way, because I am writing data exports to legacy file formats. I'll take a look.
07:49:36 <merijn> amx: Text also has a Builder module for efficient appending
07:49:57 <merijn> amx: How big is the data you wanna serialise? Are we talking KB, MB, GB?
07:50:26 <amx> KB
07:50:41 <merijn> amx: prettyprinter maybe?
07:51:17 <merijn> It's not super fast, so probably bad for large data. But for stuff measured in KB it might be nice. Good for getting pretty looking formatting too, if that's relevant
07:53:44 <jophish> Is there any package which could tell me if one L.H.TH.Type subsumes another?
07:54:12 <jophish> Obviously this isn't possible everywhere, but just the trivial cases would be useful
08:00:34 <amx> merijn: No no, it's just about not going crazy writing instances for countless data types. The result will look like CSV without the commas and instead have fixed offsets.
08:01:35 <amx> (This is how they roll in payroll)
08:07:30 <merijn> amx: Honestly, just using Builder might be simplest then
08:14:21 <ivegotasthma> hello, can someone tell me why ghci freezes here? It's a 3 liner that I'm doing for university and I'm trying to construct new elements from the last element of the list https://dpaste.org/A14o/raw
08:15:11 <merijn> ivegotasthma: 'st' is infinite, therefore 'lists' is infinite, therefore 'last lists' never returns
08:15:22 <ivegotasthma> if I index it it's fine
08:16:24 <ivegotasthma> ah, I get it, last waits for the whole list to be constructed
08:16:30 <ivegotasthma> and indexing stops that
08:16:57 <ivegotasthma> merijn: is there an alternative route I can take? I'm writing a number generator and as a beginner I'm confused where to get started with
08:17:20 <ivegotasthma> This is where I got the idea from https://wiki.haskell.org/The_Fibonacci_sequence#Using_the_infinite_list_of_Fibonacci_numbers
08:17:36 <dmwit> :t iterate --ivegotasthma
08:17:38 <lambdabot> (a -> a) -> a -> [a]
08:18:19 <dmwit> > iterate (\v -> [1] ++ v ++ [1]) [10] -- e.g., trying not to give too much away
08:18:21 <lambdabot>  [[10],[1,10,1],[1,1,10,1,1],[1,1,1,10,1,1,1],[1,1,1,1,10,1,1,1,1],[1,1,1,1,1...
08:19:01 <ivegotasthma> dmwit: thanks!
08:27:29 <halogenandtoast> Is there a nicer/cleaner way to get these sort of instances https://gist.github.com/halogenandtoast/7fc3e714c13e1854b27944136f0efeff
08:27:49 <halogenandtoast> I can't find anything regarding SumEncoding that looks like it will do this
08:29:01 <halogenandtoast> TaggedObject wants to do "tag", "contents", but I want everything that would be inside "contents" to be at the same level as "tag"
08:31:05 <c_wraith> Isn't that what ObjectWithSingleField does?  Or am I misreading that?
08:32:41 <c_wraith> Oh, I am.  I see.
08:34:43 <halogenandtoast> Yeah that does {"TagName":{...contents...}}
08:36:58 <halogenandtoast> This might just be the nicest/cleanest way to handle this, but I was hoping someone had maybe encountered this before and came up with something different.
08:37:20 <c_wraith> there is a very weird note in TaggedObject.
08:40:44 <c_wraith> huh.  yes, ok.  If you define your data type with record syntax, TaggedObject does what you want
08:41:13 <c_wraith> You just have the nightmare of dealing with a sum type defined with record syntax
08:41:15 <halogenandtoast> You mean a sum type of record constructors
08:41:24 <c_wraith> yep
08:41:32 <halogenandtoast> O_o
08:43:24 <halogenandtoast> Yeah I would probably not want to venture down that route, I'll just stick with the instances I've defined.
08:43:38 <c_wraith> after some short experimentation, I see why it does that.
08:44:03 <c_wraith> if you don't use record syntax, it doesn't have labels available, so it encodes the value as an array rather than an object
08:44:17 <c_wraith> so it can't add a tag field to an array
08:47:31 <lyxia> there's nothing out-of-the-box in aeson for this. If you have many types to encode you could define your own generic deriving provided the encoding scheme is sufficiently well-defined. 
08:52:50 <halogenandtoast> lyxia: thanks lyxia and c_wraith 
09:13:46 <dyeplexer> Defining the nth fibonacci number in GHCi as "fib n | n == 0 = 0 | n == 1 = 1 | otherwise = fib(n - 1) + fib(n - 2)" works as expected. However defining it in terms of pattern matching (fib 0 = ... fib 1 = ... fib n = ...) makes my system hang most likely due to to this function. Is it going into some sort of infinite recursion?
09:15:45 * hackage co-log-concurrent 0.4.0.0 - Asynchronous backend for co-log library  https://hackage.haskell.org/package/co-log-concurrent-0.4.0.0 (AlexanderVershilov)
09:16:27 <dyeplexer> This does not happen when the program is compiled, though
09:17:10 <halogen64> dyeplexer: it is likely GHCI is overwriting the definition if you are defining it on multiple lines
09:17:21 <halogen64> Try writing the definition between :{ :
09:17:26 <halogen64> err
09:17:50 <halogen64> :{ ... :}
09:18:46 <solonarv> or on one line and use semicolons to separate
09:19:00 <dyeplexer> Ah yes, that works. Thanks
09:23:43 <ivegotasthma> dmwit: I have a slight problem
09:24:25 <ivegotasthma> before I can use iterate I have 2 basecases I've hardcoded. is it possible to prepend these to the iteration on the last element?
09:24:38 <ivegotasthma> a map would would very well too
10:00:10 <dsal> ivegotasthma: that's what : does.
10:00:18 <halogenandtoast> circling back to https://gist.github.com/halogenandtoast/7fc3e714c13e1854b27944136f0efeff is there any way to use reflection to generalize this, I know I can get the constructor name to put in tag via toConstr, but I don't know how to generically get the wrapped value
10:00:39 <tabaqui1> Type.Reflection sucks, never use Type.Reflection
10:00:48 <tabaqui1> singletons rule
10:01:35 <halogenandtoast> I mean in this case, I am happy to use whatever works
10:01:39 <monochrom> I would do what lyxia said.
10:01:55 <tabaqui1> uhm, it doesn't relate with your case :)
10:02:03 <tabaqui1> it just my opinion after the last night :)
10:02:21 <tabaqui1> off-topic
10:03:16 <halogenandtoast> monochrom: I think that is what I am trying to do, but I was trying to figure out how to make it generic, which is to say if I have a sum type of C1 a | cC2 b I want to convert a or b to json and then add the correct tag field
10:03:59 <halogenandtoast> Which is to also say I'd like it to handle cases C1 a | C2 b | C3 c | ... where a,b,c,... have ToJSON instances
10:05:50 <halogenandtoast> I feel like Aeson itself has to be doing something similar to this with how it's handling TaggedObject, but I can't discern what exactly it is doing.
10:05:56 <monochrom> I would steal ideas from genericToJSON etc.
10:06:42 <MarcelineVQ> re json parsing my experience with waargonaut was painless fwiw
10:07:06 <monochrom> What does the "wa" part stand for?
10:07:30 <MarcelineVQ> waaagh
10:07:38 <monochrom> haha
10:08:14 * hackage scalpel-core 0.6.2 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-core-0.6.2 (fimad)
10:09:14 * hackage scalpel 0.6.2 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.6.2 (fimad)
10:16:45 * hackage dunai 0.7.0 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.7.0 (IvanPerez)
10:17:45 * hackage dunai-test 0.7.0 - Testing library for Dunai  https://hackage.haskell.org/package/dunai-test-0.7.0 (IvanPerez)
10:18:23 <EvilPyro> how can i know when a string that its passed to read is invalid? For example a char when its expecting an Int
10:19:56 <monochrom> import Text.Read, use readMaybe
10:20:37 <EvilPyro> hmm I may not be allowed to use that, I'll ask on next class
10:21:36 <monochrom> If Prelude only, use reads.  http://www.vex.net/~trebla/haskell/reads.xhtml
10:21:48 <monochrom> There is no other way.
10:21:56 <maerwald> ah, these arbitrary homework restrictions of "don't use libraries" :)
10:22:25 <tabaqui1> showsPrec is a method of Show
10:22:40 <tabaqui1> it returns you a list of possible readed values with unused chunks
10:23:04 <tabaqui1> ifk, show just checks that the list contains exactly one element and the chunk is empty
10:23:26 <tabaqui1> *iirc
10:24:09 <tabaqui1> s/readed/read
10:24:54 <EvilPyro> I'll ask on the next class, i'm not sure it its prelude only
10:25:08 <monochrom> tabaqui1, I think you have mixed up read and show, Read and Show.
10:25:12 <maerwald> EvilPyro: in that case also ask which prelude :)
10:25:34 <tabaqui1> ah, sorry
10:25:57 <tabaqui1> readsPrec do the same :)
10:26:08 <tabaqui1> *does
10:26:12 <zincy_> How is logging usually done with a Servant API. Wai middleware?
10:30:42 <solonarv> maerwald: it is not even "don't use libraries", because Text.Read is in base!
10:31:01 <maerwald> oh right, I forgot it has nothing to do with Text
10:31:18 <maerwald> Text... Data.Text...
10:31:27 <monochrom> I flip it around.  Text has nothing to do with Text. :)
10:31:30 <maerwald> lol
10:33:04 <solonarv> module names are made up and meaningless :>
10:33:15 <monochrom> All names.
10:33:28 <monochrom> Mnemonics. Not meaningful.
10:33:49 <maerwald> I like qualified package imports
10:34:05 <maerwald> Stop prefixing your stuff, just let it all in
10:34:11 <monochrom> The great thing about standards is there are so many to choose from.  The great thing about meaningful identifiers is there are so many meanings to choose from.
10:38:09 <solonarv> maerwald: yes!
10:38:32 <maerwald> I don't even mind "Prelude" as module name!
10:38:43 <monochrom> Wait a second, qualified package imports requires prefixing everything
10:39:39 <maerwald> Only if there's a clash :)
10:41:18 <monochrom> "import qualified Control.Monad.State" requires me to say "Control.Monad.State.StateT", not "StateT".
10:42:29 <maerwald> No no, I mean the PackageImports extension
10:42:48 <maerwald> import "unix"    System.Posix.IO.ByteString
10:43:10 <maerwald> import "unix-bytestring" System.Posix.IO.ByteString
10:43:59 <monochrom> That may be the way to go in retrospect.
10:44:10 <monochrom> But "package" was a new invention.
10:48:14 * hackage bearriver 0.13.1.2 - FRP Yampa replacement implemented with Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.13.1.2 (IvanPerez)
10:56:35 <EvilPyro> has anyone coded a minimax function before? I've been stuck for hours and tried several implementations without success :c
10:57:10 <maerwald> EvilPyro: Yes, in Java
10:57:15 <maerwald> I don't remember.
10:57:19 <maerwald> No: I don't want to remember.
10:58:33 <maerwald> Oh wait, I actually wrote it in haskell too
10:58:52 <maerwald> EvilPyro: is this homework?
10:59:05 <EvilPyro> https://pastebin.com/MZ2urp69 If you want to take a look, its the function at the very end. You can play the game too xD all the other AIs work in ghci
10:59:21 <maerwald> so much code...
11:00:04 <EvilPyro> maerwald, not sure, I've been told to choose a project and do it in haskell, the teacher evaluates the quality of my code in the context of what he've teached to us
11:01:15 <maerwald> EvilPyro: https://git.io/JfJjO 
11:01:21 <maerwald> I have no idea what any of that does
11:02:10 <EvilPyro> maerwald, I do a 2 line spacing per function and comment every func so yes there are a lot of lines, its a finished project too, I'm only having trouble with that func
11:03:49 <EvilPyro> maerwald, me neither xD I've been searching google for examples all afternoon
11:07:08 <zincy_> maerwald: Looks like homework to me.
11:07:44 <maerwald> Yes, and the primary thing to learn during homework is: who do you ask for help.
11:07:49 <maerwald> The rest is trivial
11:09:08 <dimsuz> Hi! I've these definitions:
11:09:12 <dimsuz> Hi! I've these definitions:
11:09:50 <zincy_> Please say it is the same homework assignment :D
11:09:56 <dsal> Recursion is hard.
11:10:03 <zincy_> haha
11:10:15 <zincy_> :D
11:10:42 <EvilPyro> doing a whole project as homework.. cmon. I've been told to do a game in haskell and I've chosen connect 4. The only restrinctions were that I should code at least 2 AIs for the game. If you want to recomend me another AI instead of minimax then that'll be as useful as helping me with minimax.
11:10:54 <dimsuz> Sorry tried pressing "Shift enter" for a multiline :)
11:11:07 <dsal> dimsuz: no pastebin here.
11:11:16 <dsal> (unless your irc client supports it... mine does)
11:11:37 <dimsuz> I've trouble with random. Linear.V3 has listed as implementing an instance of Random, but I've these definitions and an error: https://gist.github.com/dimsuz/4d5dad68296df381821584935165b81f
11:11:57 <dimsuz> Can't figure out why ghc doesn't see that instance
11:12:04 <koz_> dimsuz: Where's V3 from?
11:12:29 <dimsuz> koz_: https://hackage.haskell.org/package/linear-1.21/docs/Linear-V3.html
11:13:14 <halogenandtoast> I can't figure out why this won't work (dealing with generics, and this sort of code works in GHCI but won't compile): https://gist.github.com/halogenandtoast/24d2787e95f2011a92e381615fff5e8d
11:13:51 <halogenandtoast> The innerJSON part works, just not the tag/connName'
11:14:11 <slack1256> Is the `leaky` package the goto alternative to leakeage check or have other alternatives taken the lead?
11:19:44 * hackage rattletrap 9.1.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.1.0 (fozworth)
11:20:44 * hackage slist 0.1.1.0 - Sized list  https://hackage.haskell.org/package/slist-0.1.1.0 (vrom911)
11:21:44 * hackage type-errors-pretty 0.0.1.1 - Combinators for writing pretty type errors easily  https://hackage.haskell.org/package/type-errors-pretty-0.0.1.1 (shersh)
11:28:00 <halogenandtoast> EvilPyro: If you can get a copy of "Programming in Haskell" by Graham Hutton, there is an example of minimax for tic tac toe in there
11:30:13 <EvilPyro> halogenandtoast, thanks  :D
11:30:26 <halogenandtoast> EvilPyro: https://imgur.com/a/XIcdgGV
11:35:30 <slack1256> How is +RTS -c --RTS different from the new mark-and-sweep garbage collector? The docs says it uses a compaction strategy for the oldest generation.
11:54:14 * hackage typerep-map 0.3.3.0 - Efficient implementation of a dependent map with types as keys  https://hackage.haskell.org/package/typerep-map-0.3.3.0 (vrom911)
12:01:50 <e1fa> is fromRight in Data.Either?
12:02:11 <ChaiTRex> @hoogle fromRight
12:02:12 <lambdabot> Data.Either fromRight :: b -> Either a b -> b
12:02:12 <lambdabot> Data.Either.Combinators fromRight :: b -> Either a b -> b
12:02:12 <lambdabot> Data.Either.Utils fromRight :: Either a b -> b
12:02:33 <e1fa> I'm getting an error that says fromRight isn't in scope
12:03:19 <ChaiTRex> e1fa: What import line are you using?
12:03:20 <Uniaika> e1fa: how does your import line look like?
12:03:21 <koz_> e1fa: How did you import Data.Either?
12:03:30 <koz_> Wow, lotsa sodas from me today!
12:03:53 <monochrom> Very interesting question.
12:04:40 <e1fa> just `import Data.Either`
12:04:49 <Uniaika> weird
12:04:58 <Uniaika> e1fa: can you specify fromRight?
12:05:05 <Uniaika> `import Data.Either (fromRight)`
12:05:16 <Uniaika> and check if the compiler says something about that
12:06:09 <e1fa> Uniaika: that's why I was asking, it doesn't look like `Data.Either` is exporting fromRight
12:06:16 <e1fa> ```
12:06:23 <e1fa> `ghci> import Data.Either (fromRight)<interactive>:1:21: error:    Module ‘Data.Either’ does not export ‘fromRight’`
12:07:01 <Uniaika> e1fa: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Either.html#fromRight
12:07:04 <Uniaika> look at the top of the module
12:07:08 <Uniaika> fromRight is exported
12:07:21 <koz_> What version of base are you on?
12:07:26 <Uniaika> do you run an older GHC?
12:07:38 <e1fa> it's version 8.0.2
12:07:48 <koz_> Yah... that's a _very_ old GHC.
12:07:49 <Uniaika> fromRight was added in 4.10.0.0
12:07:53 <Uniaika> e1fa: holy shit hahaha
12:08:05 <Uniaika> then you know why :)
12:08:24 <e1fa> isn't 8.0.2 > 4.10.0?
12:08:45 <c_wraith> ghc versions and base versions aren't the same
12:09:01 <koz_> There's a base corresponding to each GHC.
12:09:08 <koz_> The numbers don't match exactly.
12:09:30 <e1fa> that's the one in my package manager - where's the newest one?
12:09:34 <c_wraith> base 4.10.0 was in ghc 8.2.1
12:09:39 <koz_> e1fa: 8.10 is newest-newest.
12:09:40 <ChaiTRex> e1fa: That uses base-4.9.1.0
12:09:41 <c_wraith> base comes with ghc
12:09:51 <c_wraith> you can't upgraded it
12:09:52 <koz_> 8.8 is probably better to use right now, as a lot of stuff still doesn't build with 8.10.
12:10:00 <c_wraith> You can only use a different version of ghc
12:10:03 <koz_> e1fa: Are you on Debian or something?
12:10:08 <e1fa> ubuntu
12:10:17 <ChaiTRex> e1fa: What version of Ubuntu?
12:10:22 <c_wraith> yeah, don't ever use the ubuntu ghc packages for develop haskell software
12:10:22 <e1fa> 18.04
12:10:41 <c_wraith> they're only for supporting ubuntu-packaged software that needs ghc
12:10:42 <koz_> c_wraith: I think we can safely extend that to 'distro ghc packages in general'.
12:10:53 <koz_> For all values of distro.
12:12:03 <Uniaika> e1fa: use something else than your package manager to build haskell projects. Stack is quite useful for that task
12:12:04 <ChaiTRex> e1fa: You can use this PPA to install ghc-8.3.3: https://launchpad.net/~hvr/+archive/ubuntu/ghc?field.series_filter=bionic
12:12:13 <Uniaika> (I can't remember if Cabal can bootstrap its own compiler)
12:12:14 * hackage stripe-concepts 1.0.2.2 - Types for the Stripe API  https://hackage.haskell.org/package/stripe-concepts-1.0.2.2 (chris_martin)
12:12:21 <Uniaika> but yeah the PPA is also very good
12:12:52 <koz_> Uniaika: Cabal can't, but we have ghcup for a reason.
12:13:15 * hackage stripe-wreq 1.0.1.2, stripe-scotty 1.0.0.2, stripe-signature 1.0.0.2 (chris_martin)
12:14:30 <e1fa> i'm working on a project that uses cabal
12:14:50 <c_wraith> ghcup is good
12:14:57 <e1fa> still learning the build managers and everything - should i just install a newer version of ghc?
12:14:59 <Uniaika> use ghcup then
12:15:05 <c_wraith> https://www.haskell.org/ghcup/
12:15:06 <Uniaika> e1fa: no, you must. :)
12:15:23 <Uniaika> you're depriving yourself of a bunch of bugfixes, optimisations and features
12:16:52 <zzz> does anyone foresee any problems in using trace like this?: https://gist.github.com/jrvieira/8198eacdc7be472f490fd1d5c641e3e8
12:17:23 <e1fa> when it says "ghcup installs only into the following directory" do i need to add that dir to my path?
12:17:27 <Uniaika> zzz: other than the usual trace problems? no
12:17:46 <Uniaika> maerwald to the rescue!
12:17:48 <zzz> Uniaika: what are the usual trace problems?
12:17:51 <e1fa> ok ghcup did it for me nvm
12:18:01 <maerwald> :D
12:18:13 <maerwald> First person reading the output of the script
12:18:47 <c_wraith> Huh, yeah.  That's never been done before.
12:18:52 <c_wraith> elfa: congratulations!  you win!
12:19:11 <e1fa> what's the prize?
12:19:18 <e1fa> knowing my system?
12:19:24 <Uniaika> zzz: it's not referentially transparent, and lazy
12:19:47 <ChaiTRex> e1fa: Learning a bit about how to use ghcup
12:19:53 <e1fa> nice
12:20:10 <Uniaika> but judgding how you use trace, zzz, I don't think you should run into unexpected problems
12:20:17 <Uniaika> (I can be wrong, that being said)
12:20:40 <e1fa> now that i'm on a roll, why does ghci say this: `*** WARNING: .ghci is writable by someone else, IGNORING!`
12:20:58 <maerwald> e1fa: that's a security feature
12:21:03 <e1fa> esp. because the permissions on my `~/.ghci` file are `-rw-r--r--`
12:21:06 <zzz> e1fa: you need to change your .ghci permissions
12:21:12 <zzz> they are too open
12:21:24 <c_wraith> I think it means the .ghci file in your current directory
12:21:35 <e1fa> oh
12:22:05 <e1fa> glad i asked, it was driving me crazy since I knew that it wasn't my `~/.ghci` file
12:22:14 <int-e> it's ironic to have this check but pick up .ghci files from random directories :-/
12:22:15 <Uniaika> my own ~/.ghci is -rwxr-xr--
12:24:33 <dsal> WEird.
12:25:22 <e1fa> it's still doing it
12:25:48 <dsal> e1fa: What are the directory permissions on all the directories up from it?
12:26:01 <c_wraith> int-e: if it didn't pick up .ghci files from random directories, the warning would be far less necessary
12:26:23 <dsal> Uniaika: why 754?  That's quite unusual.
12:26:31 <Uniaika> dsal: no idea
12:26:57 <e1fa> dsal: every directory above it?
12:27:14 <e1fa> like all the way up to my disk root?
12:27:15 <int-e> c_wraith: somewhat true, but the attack vector I'd worry about is cloning a git repo or unpacking a source tar file and then running ghci, and the permissions check hardly protects against that.
12:27:39 <dsal> e1fa: Sure, if I can write to /home, I can write to your file.
12:27:44 <c_wraith> well, that's true.  The warning's no help there.
12:27:48 <maerwald> it should simply be interactive
12:28:01 <maerwald> no one uses ghci in scripts, just ask the user
12:28:09 <maerwald> it's by definition *interactive*
12:29:14 <monochrom> A decade ago I complained against "need to lock down .ghc" too.
12:29:24 <int-e> c_wraith: I actually have alias  ghci='ghci -ignore-dot-ghci' ... but I should figure out how to give the .ghc.environment stuff the same treatment
12:29:39 <e1fa> i guess `git clone` creates globally writeable dirs
12:29:45 <e1fa> didn't realize that
12:29:50 <dsal> if we could alias flags, I'd alias `-ignore-dot-ghci` to `-ignore-dat-ghci`
12:30:00 <monochrom> err, "need to lock down .ghci"
12:30:09 <dsal> e1fa: It should create directories at 777.  Your umask should remove bits you don't want.
12:30:11 <maerwald> .ghci under curfew?
12:31:10 <dsal> e1fa: In general, directories should be created 777 and files should be created 666 (or 777 if they need to be executable).  People tend to get this wrong and generally nobody notices until it's incorrect and affects you.
12:34:04 <e1fa> i'm learning so much more than i thought 
12:34:13 <int-e> If anybody cares, `-package-env -` achieves the effect of not picking up package environments.
12:36:05 <int-e> (well, since ghc-8.6)
12:37:16 <frdg> https://pastebin.com/0hbwd22Z could use help understanding this type
12:37:57 <dsal> You could unwrap it?
12:38:25 <int-e> frdg: f is a type constructor, like Maybe.
12:38:37 <int-e> frdg: So you can have  Wrap Maybe ()
12:38:59 <int-e> With Wrap (Just ()) as a value.
12:39:50 <frdg> int-e: oh that makes sense. It still though doesn't make sense why I can say `x = Wrap ((+2) 7)` though
12:39:53 <int-e> So there is something like a function here, but on the type level. (Maybe has kind * -> *)
12:40:51 <monochrom> Haha found it.
12:41:01 <int-e> frdg: Well, (+2) 7 = 9 (in a law-abiding Num instance)... that x will have a weird type though, Num (f a) => Wrap f a, I think.
12:41:16 <monochrom> Oh wait, I still need to locate it on the public haskell-cafe archives so you can see it.  It's witty!
12:41:54 <int-e> "it"
12:41:56 <dsal> *monochrom remembers that time someone was wrong on the internet*
12:42:04 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2010-December/087112.html
12:42:33 <dsal> arbitrary?
12:42:42 <monochrom> Actually maybe start with this first: https://mail.haskell.org/pipermail/haskell-cafe/2010-December/087110.html
12:42:44 <dsal> I only run properly vetted code that's on hackage.
12:43:13 <monochrom> Or maybe I should just recap right here. It's just 3 sentences.
12:43:56 <int-e> monochrom: I habitually invoke ghci as a calculator without looking which directory I'm in.
12:43:57 <dsal> Oh, is it upset if the ghci is group writable?  There are systems that put you in your own group with a umask of 2... nobody else is in my group, but the write bit is set in case I decide it's a good idea to do so.
12:44:07 * dsal goes back in time to join the argument
12:44:08 <jle`> 'law abiding Num instance'
12:44:19 <int-e> monochrom: So it's a bit more arbitrary than the Haskell code I load or run.
12:44:40 <monochrom> <me> Perhaps ghc should ignore group-writable *.hs (etc) too.  <someone else> .ghci is run if you start ghci  <me> Haskell developers run arbitrary haskell code too.
12:45:44 <int-e> monochrom: Though I guess people can get me by putting a Prelude.hs file there which uses TemplateHaskell shenenigans
12:46:03 <int-e> It's just awful software from a security perspective.
12:50:24 <monochrom> I can sympathize with rejecting other-writable and not mock it.
12:50:40 <monochrom> But group-writable?  That's total paranoia.
12:51:30 <monochrom> Everyone downloads and runs arbitrary shell scripts and exes uploaded by snoyman and maerwald.  Do you say you trust them more than trust your group members? Seriously?
12:51:45 <maerwald> >:)
12:54:18 * MarcelineVQ surreptitiously high fives maerwald 
12:54:33 * maerwald turns around
12:54:57 <monochrom> And some of my opponents, those who raise "but I read the *.hs files", is missing the point.
12:56:03 <monochrom> The point is if a group memeber changes your .ghci after you review it, they can also change your *.hs files after you review them.  And there are way more *.hs files to hide their change.
13:00:34 <int-e> The upshot is, ghc(i) is not secure.
13:00:51 <int-e> And that one permissions check is a drop in the desert.
13:01:30 <maerwald> maybe that was the intention... to inspire us thinking about how useless it is
13:01:51 <monochrom> That's a wrong analogy. The point is it has a cost too.
13:04:28 <monochrom> How many lives has it saved?
13:04:53 <monochrom> I say none because attacks don't come from groups.
13:05:13 <monochrom> I have no data so you can object to my claim.
13:06:27 <monochrom> Analogies.  Now that's something you really should never trust.
13:11:44 <dsal> Modern software installation is just `curl http://pastebin.whatever | dd of=/dev/hda` anyway.
13:12:43 <merijn> dsal: :(
13:13:44 * hackage co-log-core 0.2.1.1 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-core-0.2.1.1 (shersh)
13:16:45 * hackage co-log 0.4.0.1 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-0.4.0.1 (shersh)
13:19:40 <maerwald> dsal: it's semi-funny, because you could probably have ~50% of users execute whatever, right there for them to see. And they still would copy paste.
13:20:14 * hackage unicode-tricks 0.6.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.6.0.0 (wvanonsem90)
13:20:28 <dsal> Yeah, old irc hacks. "Hey, run this command real quick."
13:20:46 <maerwald> dsal: you could even tell them what it does, it doesn't matter
13:21:13 <maerwald> "THIS WILL DESTROY YOUR HARD DRIVE" -- "yeah, need a clean up nyway"
13:21:14 * hackage co-log-polysemy 0.0.1.2 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-polysemy-0.0.1.2 (vrom911)
13:21:16 <monochrom> Hey why didn't you help the person yesterday to discover dd? >:)
13:21:31 <monochrom> That person who had trouble with directories.
13:21:34 <maerwald> He got kicked and never rejoined.
13:21:39 <maerwald> for spamming
13:21:47 <monochrom> Yeah I mean before :)
13:21:49 <maerwald> I missed my window
13:22:09 <monochrom> "dd means directory dump"
13:22:29 <MarcelineVQ> you boys
13:23:13 <monochrom> I think people are inspired by The Little Mermaid too much.
13:23:43 <monochrom> "This command will give you legs and take away your value."  "THANKS!"
13:24:23 <maerwald> What I found interesting is that they executed only half of the command I suggested.
13:24:51 <maerwald> That makes remote code execution a bit trickier
13:25:12 <monochrom> Hrm, perhaps they didn't know that "|" is part of the command.
13:25:24 <maerwald> Is there a language where | denotes comment?
13:25:59 <monochrom> No, but web page designs use | to separate both manual sequential composition and choice.
13:26:42 <monochrom> If you say "x | y", the audience has reason to guess that "|" is informal, guess that you want them to enter x, then enter y
13:27:58 <monochrom> P(guess wrong what "|" stands for | not know the notion of directories) = very high
13:33:16 <kolu> hey guys
13:33:26 <kolu> how can I write a list on multiple lines?
13:33:41 <monochrom> Just do it?
13:33:52 <mjrosenb> mapM_ print
13:34:21 <monochrom> If you get a syntax error, you will have to post the complete code so we can see what goes wrong.
13:35:04 <kolu> https://pastebin.com/8UpNEVBD
13:35:27 <monochrom> OK lines 2-11 need indentation. That's it.
13:36:23 <kolu> ah, easy
13:36:25 <kolu> thank you
13:46:19 <halogen64> Still fighting with generics, I made a method that did what I wanted for sum types with only 2 constructors, but I bet there is a nicer way to write this signature and I am wondering if there is an easy way to make it work with an arbitrary number of data constructors: https://gist.github.com/halogenandtoast/24d2787e95f2011a92e381615fff5e8d
13:49:25 <monochrom> Don't do this at the :+: level.  Do this at the M1 C level.
13:50:40 <monochrom> Eventually you will also need to make it a method of a class of your own design, rather than a function.
13:50:45 <lyxia> halogen64: https://dpaste.org/NeHWhttps://dpaste.org/NeHW
13:51:41 <halogen64> lyxia: I'll take a look at that, thanks!
13:52:20 <halogen64> monochrom: Thanks as well, I am not sure how to do something at the M1 C level yet
13:52:28 <halogen64> but I'll try to figure out examples
13:52:53 <monochrom> It means your contraint is "M1 C stuff", not "stuff :+: stuff".
13:55:59 <halogen64> but there are two "different" kinds of stuff
13:56:53 <monochrom> conName works for all of them.
14:00:44 * hackage binary-io 0.0.1 - Read and write values of types that implement Binary from and to Handles  https://hackage.haskell.org/package/binary-io-0.0.1 (vapourismo)
14:02:17 <monochrom> vapourismo vapourizes all your binary io bits :)
14:02:32 <mouse008[m]> Even if you're the only user of the machine, directories should be created with at most 755, and files - with 644. Allowing just anybody to have complete control over all of your files doesn't make a lot of sense, at least to me in general.
14:02:32 <mouse008[m]> I can imagine exceptions - but wouldn't post an advice like that even as a joke (assuming it *was* a joke).
14:03:33 <monochrom> No one is advocating others-writable
14:03:54 <monochrom> This is not even strawman argument.
14:06:16 <halogen64> monochrom: I guess I just don't know what M1 C is or ow I can use it in a constraint
14:10:32 <jle`> halogen64: try using :kind! Rep on a type you know about
14:10:42 <jle`> then you will see what exactly that type turns into
14:11:35 <jle`> hm, i suppose that is tricky because M1 is usually hidden behind a type synonym
14:22:55 <monochrom> Suppose you have "data T = A X | B Y"
14:23:26 <monochrom> Basically you have (M1 C ... this is for A ...) :+: (M1 C ... this is for B ...)
14:24:04 <monochrom> There is an outer M1 D wrapping around the whole thing, of course, I think you already know.
14:24:39 <monochrom> Yeah type synonyms.  D1 = M1 D.  C1 = M1 C.  S1 = M1 S.
14:25:12 <monochrom> I recommend the haddock of GHC.Generics. It is actually a good tutorial.
14:25:21 <halogen64> I think I am actually making some progress here
14:25:56 <monochrom> Or rather, it begins with an actually good tutorial, before the dry reference manual.
14:27:13 <monochrom> Its short-coming is it doesn't show when/where is the best place to use conName for conName-dependent things.
14:28:14 <monochrom> Still, figuring out D1 C1 S1 K1 U1 V1 takes enough time for now already, and for these the tutorial is great.
14:28:37 <monochrom> Also the general style of setting up a class.
14:30:44 * hackage mpi-hs 0.7.1.2 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.7.1.2 (eschnett)
14:36:25 <halogen64> lyxia: what you provided helped a lot, I was able to get it working with that, thanks!
14:42:14 * hackage timezone-olson 0.2.0 - A pure Haskell parser and renderer for binary Olson timezone files  https://hackage.haskell.org/package/timezone-olson-0.2.0 (YitzGale)
14:44:45 * hackage mpi-hs-binary 0.1.0.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-binary-0.1.0.0 (eschnett)
14:50:14 * hackage gi-gtk 3.0.33 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.33 (inaki)
14:53:44 * hackage mpi-hs-binary 0.1.1.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-binary-0.1.1.0 (eschnett)
15:06:14 * hackage mpi-hs-cereal 0.1.0.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-cereal-0.1.0.0 (eschnett)
15:30:15 * hackage mpi-hs-store 0.1.0.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-store-0.1.0.0 (eschnett)
15:30:28 <cjay-> I have the impression that there is a lack of (actually maintained) resource management libraries. Am I missing something?
15:30:38 <Uniaika> what do you mean by resource management?
15:31:07 <cjay-> the only popular one seems to be resourcet, which has certain design decisions..
15:31:26 <cjay-> I mean RAII style cretaing and destroying of stuff
15:32:04 <cjay-> there is ContT, which is nice, but it CPSes the entire thing, which is not desireable
15:32:24 <cjay-> regions looks very promising https://github.com/basvandijk/regions/
15:32:30 <cjay-> but it seems abandoned
15:33:05 <cjay-> it's based on http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
15:33:37 <Uniaika> I don't know if it's abandonned, but since it's based on a paper, looks like it has implemented the paper and nothing more
15:33:44 <cjay-> this also looks nice http://hackage.haskell.org/package/io-region but seems abandoned too
15:34:19 <koz_> cjay-: What's your use case?
15:34:41 <koz_> I'm guessing that your use case, or your concern case, doesn't fit well with ResourceT - how come?
15:34:47 <cjay-> koz_: vulkan create and destroy functions. I want RAII style deallocation.
15:34:54 <lyxia> Yeah somehow people seem content with resourceT even though it's very coarse grained
15:34:59 <cjay-> ResourceT does a IntMap insertion/deletion for every allocation
15:35:04 <cjay-> that's ridiculoas
15:35:07 <cjay-> s/a/u
15:35:12 <koz_> cjay-: Why?
15:35:27 <cjay-> because I almost never need early destruction
15:35:38 <cjay-> a list of destructors in the background is enough, by far
15:35:50 <koz_> cjay-: So your code can never throw exceptions?
15:35:54 <koz_> EVER EVER EVER EVER?
15:36:04 <cjay-> of cause it can. no intmap needed for that
15:36:21 <cjay-> list of destructors in an IORef or similar can do it
15:36:52 <koz_> So what was the design decision motivating the IntMap?
15:36:59 <koz_> Like, I'm not saying you're wrong.
15:37:05 <koz_> I simply find it hard to believe that the IntMap isn't needed.
15:37:09 <koz_> (in general)
15:37:41 <cjay-> ResourceT seems to be designed to allow total liberty in the destruction order
15:38:12 <cjay-> what's also very weird, is that ResourceT has no allocation funciton that doesn't spit out a ReleaseKey
15:38:33 <cjay-> early destruction should not be the norm
15:39:03 <cjay-> it's just so weird
15:39:05 <koz_> My guess is 'they're aiming for the most general-purpose design possible'.
15:39:12 <cjay-> yeah probably
15:39:13 <koz_> (again, not an expert on ResourceT)
15:39:22 <koz_> Is this causing you lost sleep or measurable lost performance?
15:39:24 <cjay-> and it's certainly fine for stuff like open files
15:40:06 <cjay-> I want good performance, and vulkan objects get created and destroyed a lot
15:40:13 <koz_> cjay-: Have you measured?
15:40:16 <cjay-> nope
15:40:18 <koz_> What is 'good' in this context?
15:40:21 <koz_> Then this is a moot discussion.
15:40:28 <koz_> It's quite likely that there won't be a measurable difference.
15:40:50 <koz_> (I can't really say either, since I've not measured either)
15:41:00 <koz_> (but _assuming_ bad outcomes without measuring seems a bit premature)
15:41:08 <cjay-> the discussion is valid regardless of my specific use case
15:41:30 <cjay-> you can easily imagine something allocating and destorying shitloads of small resources
15:41:47 <cjay-> resourcet is not designed for that, I'm certain
15:41:51 <koz_> But that's assuming that the ResourceT-IntMap-based approach will be bad in this context, or an actual bottleneck.
15:41:56 <koz_> _That_ is what I have issue with.
15:42:42 <cjay-> the thing is, it does clearly more work than necessary
15:42:59 <koz_> Saving cycles isn't the be-all and end-all of performance.
15:43:05 <koz_> Nor is saving allocations.
15:43:28 <koz_> I mean, try and see?
15:43:32 <koz_> You may be surprised.
15:43:49 <koz_> (I certainly had a similar situation recently, when I discovered that unordered-containers is _faster_ than a hashtable in IO)
15:43:53 <koz_> (by a _very_ non-trivial amount)
15:47:05 <cjay-> to find out if it slows down the program, I'd still need an alternative to compare performance
15:47:41 <koz_> You can still check if that bottlenecks you or not.
15:47:47 <cjay-> and I need to fit both into the same wrapper api
15:47:50 <cjay-> hmm
15:47:57 <cjay-> I don't trust profiling output
15:48:42 <koz_> cjay-: Then I'm afraid you and I have _very_ different understandings of what 'performance' means.
15:49:00 <koz_> How do you find bottlenecks then?
15:50:00 <cjay-> by profiling. but if something else is really faster, you will only find out by trying.
15:50:30 <koz_> So do you trust profiling output or not?
15:50:41 <koz_> I'm not sure I understand how you reconcile you two previous sentences.
15:51:18 <cjay-> in my experience profiling doesn't capture everything, it can be misleading
15:51:25 <cjay-> so it's more like a guideline
15:51:29 <cjay-> not the total truth
15:51:47 <koz_> Sure. But surely a guideline is better than 'nothing at all', right?
15:51:52 <cjay-> true
15:51:59 <koz_> So what's the harm in checking?
15:52:16 <koz_> If it's indeed a bottleneck, you're right, and you can now win fame and success by implement CJayResourceTDoneRight.
15:52:25 <koz_> If it's not, that's one less reason to worry about it.
15:52:29 <koz_> Both in general, and in your specific case.
15:52:32 <koz_> You win either way.
15:53:17 <cjay-> yeah maybe I should just benchmark it. I still find the general case interesting, regardless of my usecase, though
15:53:29 <koz_> Oh, sure - on that I agree.
15:54:38 <koz_> But I would be very interested to hear what you discover in your particular context.
15:54:47 <koz_> Since I have non-trivial interest in GPU compute, which is _very_ adjacent.
15:55:24 <cjay-> I'll let you know when I have results :)
15:55:34 <cjay-> what do you use for compute, OpenCL?
15:55:47 <koz_> Futhark. :P
15:55:52 <cjay-> ah
15:55:58 <koz_> Which can target CUDA or OpenCL.
15:56:04 <koz_> I don't have any CUDA hardware currently though.
16:40:31 <dmj`> cjay-: arrayfire can target CUDA or OpenCL or CPU
16:40:38 <dmj`> @package arrayfire
16:40:38 <lambdabot> http://hackage.haskell.org/package/arrayfire
16:40:45 * hackage telegram-types 0.2.1 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.2.1 (Poscat)
16:53:14 * hackage unicode-tricks 0.6.1.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.6.1.0 (wvanonsem90)
17:14:58 <koz_> Is this the right place to ask about ghcup?
17:15:15 <dmwit> I think it's on okay plac.
17:15:20 <koz_> I'm mostly curious whether ghcup can build a cross-compiler (so, runs on my machine arch, targets another arch).
17:18:06 <koz_> Also, I just had ghcup blow up with a pile of linker errors for some reason.
17:18:53 <koz_> Every single error is something like '/usr/bin/ld: cannot find -lHSmtl-2.2.2-ghc8.6.5', except the library is different each time.
17:19:37 <koz_> The invocation was 'ghcup compile ghc --version 8.6.5 --bootstrap-ghc /home/koz/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.5/bin/ghc --jobs 11
17:19:39 <koz_> '
17:22:13 <Uniaika> maerwald: ^
17:22:15 <monochrom> There is no ghcup channel yet, so this channel is as good as it gets.
17:22:20 <koz_> monochrom: Noted.
17:23:15 <monochrom> "--jobs 11" looks cringey
17:24:09 <koz_> monochrom: I keep one hyperthread free so that I don't get random lock-ups.
17:24:22 <koz_> (it happens rather more often than I'd like, even with linux-ck)
17:25:02 <monochrom> Hrm, I mean it's too many!  I would allow only 2 threads, maybe even just 1.
17:25:15 <koz_> monochrom: I had no problem saturating that throughout most of the process.
17:25:25 <koz_> (like, I think I dipped to 50% load in some places)
17:25:32 <koz_> (but most of it was full load)
17:25:49 <koz_> I paid for this parallelism, and boy am I gonna use it.
17:26:24 <notbot> @lambdabot 1 + 2
17:26:25 <lambdabot> Unknown command, try @list
17:26:30 <notbot> @lambdabot @list
17:26:31 <lambdabot> Unknown command, try @list
17:26:33 <notbot> @list
17:26:34 <lambdabot> What module?  Try @listmodules for some ideas.
17:26:37 <koz_> > 1 + 2
17:26:39 <lambdabot>  3
17:26:44 <koz_> % 1 + 2 -- also works
17:26:45 <yahb> koz_: 3
17:26:54 <Uniaika> koz_: 20 bucks parallelism is the root cause of the problem
17:26:58 <notbot> > foldr (\x y -> 2*x + y) o [a,b,c,d]
17:27:01 <lambdabot>  2 * a + (2 * b + (2 * c + (2 * d + o)))
17:27:03 <koz_> Uniaika: That doesn't make it any less a bug.
17:27:11 <notbot> thanks
17:27:16 <koz_> (and I'm skeptical that this causes _linker errors_)
17:27:30 <koz_> But I'll try!
17:27:52 <ja> :t a
17:27:53 <lambdabot> Expr
17:27:53 <Uniaika> oh I would say it causes the whole thing to misbehave, preparing the terrain for linker errors
17:28:02 <Uniaika> but indeed, it's a bug
17:28:06 <koz_> Uniaika: I guess so, but that _still_ doesn't make it any less a bug!
17:28:13 <koz_> It's 2020, we can do better. :D
17:28:40 <Uniaika> 2020 is the Year of COBOL
17:28:53 <monochrom> suspected race condition bug is also why I cringed at so many jobs.
17:29:18 <koz_> monochrom: Luckily I haven't hit that in mine, yet.
17:29:44 <monochrom> OTOH I acknowledge that the GHC devs actually tested and use the build script/process, if there is a race condition they'd have known and fixed by now.
17:30:11 <koz_> monochrom: Do they use per-build parallelism though? As opposed to parallelizing across builds?
17:30:16 <Uniaika> (shit I need to work on the FreeBSD build)
17:30:36 <monochrom> dunno
17:36:43 <koz_> Well, let's hope this attracts the Relevant Authorities.
17:36:49 <koz_> (or that non-parallelism works)
17:36:53 <koz_> (which would be more sadface)
17:44:23 <monochrom> Is /home/koz/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.5/bin/ghc a shell script? (It should be, and pretty short at that.)
17:45:09 <koz_> Wow, yes.
17:45:22 <koz_> Am I missing something about where Stack puts GHCs?
17:45:35 <monochrom> No, just checking. It's normal.
17:46:05 <koz_> TIL.
17:46:56 <monochrom> Just paranoia that stack might circumvent standard GHC convention.  It does not.
17:47:17 <koz_> Nope, single-job build blew up in exactly the same way.
17:47:22 <koz_> So it's not a parallelism issue.
17:47:40 <koz_> I can pastebin logs if it helps?
17:48:02 <monochrom> I think an important bit of information is which stage the linking error occurs, stage 1 or stage 2.
17:48:27 <monochrom> because stage 1 is when using the bootstrap GHC, stage 2 is using the built GHC.
17:49:21 <monochrom> Although, "-lHSmtl-2.2.2-ghc8.6.5" sounds like stage 2
17:50:19 <koz_> What would be a definitive line that would tell us?
17:51:02 <monochrom> I don't know.  Haven't built GHC for a long time, forgot what the output messages look like.
17:51:06 <koz_> The logs are huge and I dunno what I'm looking for.
17:51:17 <koz_> OK, I'll stick the log in a paste for maerwald or whoever else to find.
17:52:02 <koz_> Lol, seems it's a bit too big for that paste service.
17:52:25 <monochrom> upload a gzipped version...
17:52:43 <koz_> Yep, doing that.
17:56:51 <koz_> monochrom: Where do you suggest uploading?
17:57:04 <koz_> My usual 'stick files for people to fetch' service seems to be being hit by a tornado.
17:57:14 <monochrom> I was kidding about gzipping!  I don't know.
17:58:17 <koz_> OK, here's the (gzipped) link: http://ix.io/2iBZ
18:12:45 <slack1256> Should haskell programs not leak with -O0 or that is unrealistic?
18:13:21 <monochrom> Also "leak" is ill-defined.
18:13:32 <slack1256> space-leak
18:13:42 <monochrom> Yes, "space-leak" is ill-defind.
18:14:45 <slack1256> Using ezyang definition of space-leak, jesus.
18:15:05 <monochrom> OK I don't know of that one. Where can I find it?
18:15:20 <monochrom> Why are you so easily agitated?
18:22:56 <slack1256> monochrom: You're right, I am sorry.
18:28:22 <koz_> slack1256: I am still curious what the Edward Z Yang definition of space leak is.
18:28:31 <koz_> I also haven't heard of that one.
18:31:45 * hackage telegram-types 0.2.2 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.2.2 (Poscat)
18:35:57 <slack1256> koz_ monochrom: It's not a definition, but it is a description http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/ 
18:37:11 <slack1256> A memory leak has a graph that keeps growing and growing. A space leak has more like a inverted parabola form which consumes a lot of memory on the middle but which could tentatively be more flat with strictness in the right places. that blog post analysis the common case of thunk leaks which are space leaks.
18:37:42 <koz_> slack1256: In that case, I don't think -O0 would prevent it necessarily.
18:38:07 <koz_> In fact, it might even _cause_ it, because the strictness analyzer might miss opportunities it would otherwise take to be strict and avoid building these things up.
18:39:38 <slack1256> Yeah, it won't prevent it, but the question I am dealing is ¿Should it space-leak free even with -O0?
18:40:06 <koz_> And I think I answered it.
18:40:23 <koz_> Unless I'm misunderstanding something.
18:40:28 <monochrom> Is the strictness analyzer even run when -O0?
18:40:49 <koz_> monochrom: That's kind of the point - if it's not, then you could accumulate thunks where you otherwise wouldn't.
18:40:51 <slack1256> koz_: You're right, I read wrong
18:41:03 <koz_> So -O0 doesn't necessarily prevent 'space leaks' of the kind described in the link.
18:41:09 <koz_> Unless I misunderstood something somewhere.
18:41:26 <slack1256> koz_: No no, what I mean is backwards
18:41:50 <slack1256> Should haskell code, without optimizations and stricness analyzer, be written in such way there is no memory leaks? (inserting seq manually) ?
18:42:16 <monochrom> IMO yes. Don't take optimizations for granted.
18:42:40 <slack1256> I also think yes, I like thinking the code is robust.
18:42:42 <koz_> Generally speaking yes. A lot of optimizations are heuristic in nature, and so if you're _sure_ something needs forcing, better do it yourself.
18:42:49 <monochrom> Or rather, take constant-multiplier optimizations for granted. Don't take asymptotic optimizations for granted.
18:42:55 <koz_> You know what your code is doing far better than any compiler.
18:43:04 <koz_> Because compilers don't typically understand what problem you are trying to solve.
18:43:14 <slack1256> monochrom: Well said.
18:43:19 <slack1256> ...
18:43:29 <slack1256> It's hard to know where to fit the seq...
18:43:56 <slack1256> Even with +RTS -xc -p -hc --RTS I have a hard time.
18:44:02 <monochrom> In fact I even oppose optimizing the poster-child foldl (+) [1..n] to constant-space.  Lazy semantics says it's Omega(n) space.
18:44:14 <monochrom> To accept it is a slippery slope.
18:44:46 <koz_> monochrom: So what you're saying is 'if the user asked for foldl and not foldl', don't rewrite for them'?
18:44:54 <monochrom> Right.
18:45:08 <monochrom> And if the user codes up bubble sort, don't optimize it to n log n sort.
18:46:50 <koz_> Maybe I should try build GHC from source myself?
18:48:01 <monochrom> -O1 also has another optimization that increases laziness and sharing, saving time but spending more space.
18:48:47 <monochrom> It's called "full laziness".  Oleg complained about it.
18:49:10 <koz_> monochrom: Kiselyov? Or Grenrus?
18:49:18 <monochrom> Kiselyov
18:49:29 <koz_> I have to clarify.
18:50:04 <monochrom> https://stackoverflow.com/questions/3190098/space-leak-in-list-program
18:50:27 <monochrom> (That one isn't Oleg's post, but it's the same phenomenon)
18:58:53 <dmj`> yea, but what does he know
19:03:34 <slack1256> What happened to lpaste ?
19:04:24 <monochrom> The person who ran it stopped running it (and paying for it etc)
19:04:46 <slack1256> Oh...
19:04:46 <monochrom> It won't come back.
19:05:33 <c_wraith> I believe his statement was that fighting spam was too much effort and he wasn't willing to run a site he couldn't effectively moderate
19:05:39 <slack1256> https://pastebin.com/t19V17Z9 has a leak, I think it's the readFile (it is lazy io) but calling length on the contents should be enough to avoid leaks right?
19:06:38 <c_wraith> lazy IO would cause a file handle leak
19:06:54 <c_wraith> If you're running into a space leak, that's a different problem.  Probably too much strictness.
19:07:41 <c_wraith> (or more precisely, being strict in the wrong thing)
19:08:01 <monochrom> Calling length and seqing its answer causes reading the whole file into memory at once and spending the space to store it.  How big is the file?
19:08:38 <slack1256> It's /proc/net/dev 
19:09:03 <c_wraith> honestly, I'd be suspicious of parseDevNet
19:09:08 <monochrom> OK it's pretty small. This one doesn't matter.
19:09:44 * hackage ejdb2-binding 0.2.0.0 - Binding to EJDB2 C library, an embedded JSON noSQL database  https://hackage.haskell.org/package/ejdb2-binding-0.2.0.0 (buro)
19:09:50 <slack1256> c_wraith: Back in june I fixed a leak on parseDevNet already.
19:10:24 <slack1256> Well I don't know if I fixed, it changed the bar on the graph generated by hp2pretty.
19:12:04 <c_wraith> It's the only thing in there that I can't tell is doing a reasonable amount of allocaiton
19:12:07 <c_wraith> *allocation
19:12:23 <slack1256> I will post it, give me a sec
19:12:27 <monochrom> Since /proc/net/dev is pretty small, like Theta(# of network adaptors, how many could you have anyway?), map (mkSample (parseDevNet that)) cannot possibly be so large as to be called any kind of leak.  Like, unless parseDevNet takes exponential space.
19:13:28 <c_wraith> if parseDevNet isn't the problem, getDeviceSamples isn't the problem
19:14:28 <slack1256> https://pastebin.com/vDG3EcQU
19:15:38 <c_wraith> Oh, I missed something.  what's handleFailure?
19:16:16 <slack1256> Give me another second to post it
19:18:00 <halogen64> I have the following where I add a tag (the haskell type) and type (the data constructor) to a json payload via ToJSON, I am trying to now reverse this with FromJSON and I am a bit lost how to get the type or constructor into the parse
19:18:04 <slack1256> https://pastebin.com/HG6FkM29
19:18:10 <halogen64> https://gist.github.com/halogenandtoast/24d2787e95f2011a92e381615fff5e8d
19:20:20 <c_wraith> slack1256: are you sure this is the real problem?  Things in there look maybe like they'll have a bit of overhead, but nothing that has a serious impact
19:21:03 <monochrom> getDeviceSamples looks like O(1)-time.
19:21:45 * hackage base16 0.2.0.1 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.2.0.1 (topos)
19:21:54 <slack1256> I guess the stack trace could have gone wrong this time reporting handleFailure as the culprit. I got a loop reporting the rss size of taffybar and it keeps growing (slowly). I will run it again with -xc and see what breaks it.
19:23:10 <monochrom> I would impeach foreverWithVariableDelay.  It promises epic recursion.
19:23:31 <monochrom> Or rather, the name promises epic recursion.
19:23:57 <monochrom> epic recursion can take O(1) space or Omega(n) space depending on how careful you are.
19:26:38 <c_wraith> slack1256: if you have a heap profile that shows too much memory being allocated by getDeviceSamples, I would interpret that as "the values returned by getDeviceSamples are being held too long"
19:30:12 <slack1256> monochrom: There is some epic recursion on there, you're probably right. There are some old references kept around to calculate the diference in output speed. But I thought I had fixed it.
19:31:14 <slack1256> I guess I will put cost centres by hand and see the biographical profiler
20:01:39 <koz_> monochrom: I'm getting similar issues building GHC from source.
20:01:43 <koz_> I don't think ghcup is at fault here.
20:01:49 <koz_> I'll ask in #ghc.
20:01:53 <monochrom> yikes. yeah.
20:03:47 <koz_> I get the strong suspicion that using a Stack-downloaded GHC may be the cause of my woes.
20:04:04 <monochrom> :)
20:04:48 <koz_> Also, I don't think I can build GHC 8.6.5 with GHC 8.8.2, right?
20:05:22 <koz_> Or 8.8.whatever.
20:08:08 <monochrom> I haven't heard of problems with that direction.
20:08:16 <koz_> monochrom: Guess I'm just lucky.
20:08:46 <monochrom> If it may take too long to find out, ask #ghc
20:08:57 <koz_> Ehh, I can try one more test.
20:10:37 <monochrom> I finally understand pattern guard syntax!
20:10:48 <koz_> monochrom: Which syntax is that?
20:11:18 <monochrom> f x | Just y <- g x = ...   (Assume g :: X -> Maybe Y)
20:11:25 <koz_> Oh, that one.
20:11:31 <koz_> Yeah, I kinda co-learned it with pattern synonyms.
20:11:32 <monochrom> generally: f x | pattern <- expr = ...
20:12:17 <monochrom> What I didn't understand is why not the other way: expr -> pattern.  And how the hell am I ever going to remember it.
20:12:33 <monochrom> (I always misremember it.)
20:13:15 <koz_> Yeah, it's a bit odd.
20:13:21 <koz_> I think it threw me for a loop a lot.
20:13:27 <monochrom> Today I discover why.  Consider:  case xs of (x:xt) | g x -> Just y -> y
20:13:28 <koz_> Finally clicked about a week ago.
20:13:43 <koz_> Oh, I never thought of that.
20:13:45 <koz_> Huh, clever.
20:14:04 <monochrom> That looks very ambiguous, right?  How can the computer tell that the first -> is not part of the standard case ->?
20:14:16 <monochrom> So this is why the designer was forced to flip it.
20:14:37 <monochrom> Now I have a very reliable mnemonic! Because the other direction sucks. :)
20:16:21 <solonarv> % case 1 of odd -> True -> "yes"
20:16:21 <yahb> solonarv: ; <interactive>:87:23: error: parse error on input `->'
20:16:36 <solonarv> aha, no ViewPatterns in case
20:16:53 <solonarv> % case 1 of (odd -> True) -> "yes"
20:16:53 <yahb> solonarv: "yes"
20:17:00 <solonarv> oh! you can!
20:17:09 <monochrom> view pattern has protective syntax
20:17:18 <solonarv> that makes sense, yes
20:17:40 <monochrom> Wear masks!
20:17:58 <monochrom> "Please wash your hands after using view patterns."
20:18:13 * solonarv ( ^_^ ) -- masks = parentheses?
20:18:18 <monochrom> yeah!
21:05:20 <koz_> monochrom: OK, apparently, Stack GHC doesn't work for Reasons. I decided I'd get a binary from ghcup, and try and use _that_ to build a GHC.
21:05:22 <koz_> Wish me luck.
21:05:32 <koz_> Surely _that_ has to work.
21:05:47 <koz_> maerwald: I am still curious about whether ghcup can build me a cross-compiler.
22:41:19 <ja> it says on the readme that it is a thin wrapper around the build system, and the focus is on downloading... so it would be very impressive if such an edge case such as cross-compilation was working
22:42:02 <koz_> ja: It can already compile a GHC.
22:42:05 <koz_> And Cabal.
22:42:21 <koz_> 'Thin wrapper around downloading' was left behind ten miles ago.
22:42:58 <koz_> Also, which README? ghcup-hs doesn't seem to say that.
22:45:09 <koz_> It seems like the answer is 'no', though - might ask for it to be implemented.
22:45:11 <koz_> Would be nice.
