00:24:08 <tom__> Is it idiomatic Haskell to shorten function signatures with type synonyms?
00:25:14 * hackage darcs 2.14.3 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.14.3 (bfrk)
00:31:30 <phadej> tom__: not really. Maybe if the function type represents some domain concept. But maybe then you'd rather use newtype
00:33:06 <tom__> phadel: Thanks
00:33:13 <tom__> I am just a bit confused
00:33:37 <opqdonut> type synonyms can make type errors harder to read
00:33:46 <tom__> Someone is saying well everything to the left of = is just an alias for the RHS
00:33:52 <opqdonut> especially if the docs & type signatures use NiceType
00:34:12 <opqdonut> but NiceType is really Very -> Complex (Type a)
00:34:38 <opqdonut> and then you get errors like "expected Very, got String"
00:34:48 <koz_> Yeah... type synonyms are nope for me.
00:35:00 <koz_> If you need to name something, you probably need different semantics.
00:35:07 <koz_> If so, newtype's the way.
00:35:22 <koz_> Since you _will_ want to alter the behaviour of whatever you're wrapping eventually, in my experience.
00:35:27 <koz_> (usually sooner, not later)
00:35:38 <koz_> s/name/rename/
00:36:06 <phadej> common misconception is that Haskell is boilerplate free language. Wrong, we just have different kind of boilerplate :)
00:36:49 * koz_ knows this all too well. :(
00:37:39 <tom__> Yeah
00:37:51 <tom__> People have this expectation that there should be no boiler plate 
00:37:57 <tom__> and then they do weird things with TH
00:38:14 <tom__> Boilerplate is a necessity it isn't inherently evil right?
00:38:50 <koz_> It's not a _necessity_ - it's an inevitability./
00:38:52 <koz_> Not the same thing.
00:38:53 <opqdonut> especially if the alternative is magic
00:39:12 <tom__> koz_: Yeah
00:39:15 <opqdonut> when I first started working with aeson I preferred to write my ToJSON and FromJSON instances by hand
00:39:26 <opqdonut> because I didn't want TH magic
00:39:40 <koz_> opqdonut: Aeson uses Generics magic.
00:39:50 <opqdonut> these days yeah, but not back in the day?
00:40:16 <opqdonut> I definitely prefer Generics magic to TH magic, but I'm not allergic to TH magic either any more
00:40:19 <opqdonut> it has its place
00:40:32 <tom__> When should it be used if you can generalise?
00:40:47 <koz_> tom__: Can't decide this in a vacuum.
00:40:50 <koz_> Everything has a cost.
00:40:53 <koz_> Nothing is free.
00:41:01 <koz_> Rule #1 is being aware of what this cost is.
00:41:07 <opqdonut> in clojure projects we have this joke / rule of thumb that you get 1 macro for each 10-fold increase in codebase size
00:41:20 <opqdonut> I think something similar might apply to TH :)
00:42:43 <tom__> I like that
00:43:15 <tom__> It is like the boring vs fancy haskell debate
00:43:21 <tom__> Why the polarisation?
00:43:31 <tom__> 80/20
00:47:01 <maerwald> You don't want to newtype functions
00:47:33 <phadej> maerwald: ReaderT/StateT/... are newtyped functions
00:47:57 <phadej> thus: sometimes you want (or forced to)
00:48:34 <maerwald> yes, but now you gotta run them :P
00:49:42 <maerwald> https://hackage.haskell.org/package/wai-3.2.2.1/docs/Network-Wai.html#t:Application
00:50:25 <phadej> I'd newtype that
00:50:41 <koz_> A lot of things are newtyped functions, lol.
00:51:16 <phadej> (not Middleware though)
00:51:19 <maerwald> Yeah, I'm not a newtype fan, unless I add instances
00:52:34 <phadej> and probably defined `newtype Application = Application { runApplication :: forall r. Request -> (Response -> IO r) -> IO r }
00:52:48 <phadej> instead of using opaque ResponseReceived type
00:56:51 <koz_> phadej: Isn't that some flavour of Cont?
00:57:40 <phadej> it is
00:58:00 <koz_> @unmtl ContT r IO Response
00:58:00 <lambdabot> (Response -> IO r) -> IO r
00:58:15 <koz_> Well, nearly.
00:58:18 <koz_> It's like
00:58:27 <koz_> @unmtl ReaderT Request (ContT r IO) Response
00:58:27 <lambdabot> Request -> (Response -> IO r) -> IO r
00:58:35 <phadej> it's Request -> Codensity IO Response
00:58:42 <phadej> but that really odesn't help you
00:58:56 <koz_> Not what I got?
00:59:06 <phadej> Codensity has forall r.
00:59:12 <koz_> Oh right.
01:32:15 <SourOatMilk> I am a bit lost with crypto libraries... Which one can do equivalent to PHP `hash_hmac('sha1', $message, $key, true);`?
01:36:44 * hackage compound-types 0.1.4.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.4.1 (NikitaVolkov)
01:36:59 <phadej> `cryptonite` most likely. also https://hackage.haskell.org/package/cryptohash-sha1-0.11.100.1/docs/Crypto-Hash-SHA1.html#g:3 probably (which is lighter dependency)
01:39:09 <SourOatMilk> @phadej thanks! I did take a look at cryptonite earlier, but it looked quite difficult.
01:39:09 <lambdabot> Unknown command, try @list
01:40:17 <phadej> well, instead of 'sha1' argument there is a bit of type-class machinery
01:42:01 <SourOatMilk> I'll try to wrap my head around it. Worth to learn anyway I suppose.
01:45:48 <phadej> I'd use cryptohash-sha1
01:46:31 <phadej> cryptonite pays off when you need bigger part of cryptosuite
01:46:44 <phadej> just for sha1-hmac, it's imho not a good library choice
01:46:58 <phadej> (except if it's already pulled by something else)
01:47:10 <SourOatMilk> Just as I thought. :) Checking out cryptohash-sha1 first.
02:30:14 * hackage elynx-tools 0.2.1 - Tools for ELynx  https://hackage.haskell.org/package/elynx-tools-0.2.1 (dschrempf)
02:35:15 * hackage elynx-seq 0.2.1 - Handle molecular sequences  https://hackage.haskell.org/package/elynx-seq-0.2.1 (dschrempf)
02:36:15 * hackage elynx-markov 0.2.1, elynx-tree 0.2.1 (dschrempf): https://qbin.io/jc-single-5z6e
02:37:15 * hackage elynx 0.2.1, tlynx 0.2.1, slynx 0.2.1 (dschrempf)
02:52:15 * hackage shakebook 0.1.5.0 - Shake-based markdown/latex webbook.  https://hackage.haskell.org/package/shakebook-0.1.5.0 (locallycompact)
02:54:44 * hackage shakebook 0.1.5.1 - Shake-based technical documentation generator.  https://hackage.haskell.org/package/shakebook-0.1.5.1 (locallycompact)
02:57:44 * hackage hadolint 1.17.6 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.17.6 (lorenzo)
03:01:01 <srk> is there a way to have attoparsec parsers for both text and bytestring.(char8) without duplicating code?
03:03:59 <tom__> What you can have typeclass instances for synonyms?
03:04:03 <tom__> Surely this is a bad ideqa
03:04:31 <tom__> *idea
03:05:37 <__monty__> tom__: Not really? First of all you have to enable an extension. And even then you can't have an instance for both Path and String?
03:07:04 <tom__> Oh its not a bad idea?
03:07:09 <tom__> Which extension is it
03:07:41 <__monty__> TypeSynonymInstances
03:07:41 <ski> `TypeSynonymInstances' ?
03:08:26 <tom__> ah thanks
03:09:20 <__monty__> tom__: Note that this answer gives a good idea of why it's not enabled by default: https://stackoverflow.com/a/13116641
03:46:14 <tom__> Interesting
03:46:21 <tom__> __monty__: Thanks
03:46:56 <tom__> So if i define a function called add which takes two ints and then I define a type syonym and use it for the type sig 
03:47:04 <tom__> then I can never partially apply add?
03:47:54 <__monty__> No, a type synonym means exactly the same thing as its RHS.
03:48:10 <tom__> Ah 
03:48:44 <tom__> You don't get a data constructor so hence you have nothing to partially apple
03:48:47 <tom__> *apply
04:30:14 * hackage zsdd 0.1.0.0 - Zero-suppressed decision diagrams  https://hackage.haskell.org/package/zsdd-0.1.0.0 (eddiejones)
04:41:01 <jumper149> Hi, I have a problem on NixOS20.03. I want to use cabal build in a nix-shell, but it doesnt use the dependencies provided by nix and instead tries to get them from hackage itself.
04:41:58 <srk> jumper149: you need to satisfy all the deps for the project
04:42:14 <srk> jumper149: then it won't try to download things from hackage
04:43:11 <jumper149> srk: The derivation builds with nix-build. All dependencies are provided.
04:43:44 <merijn> does nix require v1-build, maybe?
04:44:19 <srk> cabal build defaults to v2-build for me now
04:44:29 <srk> jumper149: you can check with ghc-pkg list
04:44:46 <jumper149> I can try that. I didn't have the problem before when on NixOS19.09.
04:45:34 <srk> jumper149: maybe your shell expression is wrong, there's also shellFor now btw
04:46:34 <jumper149> v1-build atleast doesnt fail the same way as before! looks like its compiling
04:46:54 <merijn> v1-build prefers using the currently installed versions of packages for its build plans
04:47:08 <merijn> v2-build computes build plans without regards for what's installed
04:47:43 <jumper149> I'll still try nuking my cabal config file to see if that was at fault :)
04:47:54 <jumper149> oh wait
04:48:21 <jumper149> It does still look like I'm missing a dependency
04:52:16 <jumper149> I think the problem is that cabal uses newest ghc but the project uses pinned nixpkgs with ghc-8.6.5...
04:53:18 <srk> unpin, fix problems for ghc-8.8.1.. :)
04:53:27 <srk> profit
04:54:40 <merijn> We're on 8.10 :p
04:54:46 <jumper149> Well I still havent resolved it. It's pinned for ghcjs :p
04:55:19 <merijn> srk: fixing for 8.10 isn't much harder than 8.8 and with 8.10 you get speedscope \o/
04:56:37 <srk> merijn: yeah, I'm mostly using where default haskellPackages are pointing, I've tried to switch one codebase to ghc8101 like a month ago but looked too early :)
04:56:46 <srk> speedscope, that's new!
04:56:57 <merijn> srk: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
04:57:10 <srk> ty!
04:57:21 <merijn> srk: It's glorious \o/
04:57:35 <srk> oh wow
04:57:35 <srk> it is
05:00:43 <jumper149> sigh... the problem was: I forgot to use .env x)  cabal and nix work still fine 
05:01:59 <disconsis> Hey guys, just starting to use monad transformers. I'm having to write a lot of `MaybeT` to change from `IO (Maybe a)` to `MaybeT (IO a)` and it doesn't seem very idiomatic to mention the name of the transformer outside the type
05:02:10 <disconsis> is there a function that does this generically
05:02:26 <merijn> disconsis: That's wrong parenthesised, tbh :)
05:02:39 <merijn> "MaybeT IO a" = "(MaybeT IO) a"
05:03:15 <disconsis> Oh yeah D:
05:03:26 <merijn> disconsis: Hence, "monad transformer". MaybeT takes a type that's a monad as argument and produces a new type that's a monad
05:05:54 <disconsis> merijn: That makes sense. Looking back on my code, I didn't make that mistake lol
05:05:56 <merijn> disconsis: Which also explains why the transformers are on "the outside" a Monad has to have kind "* -> *" (i.e. takes a type argument). "IO :: * -> *" if you wanted MaybeT somewhere else than "outside", where would you put it? "(IO MaybeT) a" doesn't work (since that'd require 'IO' to have a different kind) and "IO (MaybeT a)" doesn't work, because how could MaybeT ever affect IO's behaviour?
05:07:13 <jumper149> disconsis: One goal of the monad transformer is to group monads into a single monad
05:07:15 <merijn> I mean, I suppose you could do something like "type (&) m t = t m" to write "(IO & MaybeT) a", but at that point I doubt you're making anything *more* idiomatic/simple ;)
05:08:37 <disconsis> merijn: I think I didn't phrase my intent correctly
05:08:53 <disconsis> I'm not trying to write the type signature differently, that's fine
05:09:08 <disconsis> Well, I'll just paste the code I am writing
05:09:16 <disconsis> `focusCursor :: MaybeT X ()focusCursor = do  pos <- MaybeT $ reader mousePosition  workspace <- W.tag . W.workspace <$> MaybeT (uncurry pointScreen pos)  lift $ windows $ W.view workspace`
05:09:22 <disconsis> Oh shit
05:09:51 <jumper149> no multiline pastes in irc pls :p
05:10:13 <disconsis> lol sure
05:10:39 <disconsis> just seemed a waste to create a pastebin for 3 lines :P
05:10:51 <merijn> disconsis: Ah, the MaybeT there isn't the type
05:10:57 <merijn> disconsis: It's the constructor
05:11:13 <disconsis> Yeah, that's what I was trying to say
05:11:36 <disconsis> Writing the constructor out each time didn't seem terribly idiomatic
05:12:49 <merijn> disconsis: Well, usually you'd move the constructor into some separate binding and then use that everywhere
05:13:18 <jumper149> I think you could make MaybeT an instance of MonadLift and then use lift instead of MaybeT
05:13:19 <disconsis> The pastebin, just in case anyone wants to take a look : https://pastebin.com/AFSk689C
05:13:40 <merijn> disconsis: Like, importing pointScreen qualified and then using "pointScreen pos = MaybeT $ uncurry (XMonad.pointScreen pos)" or something and then use that
05:14:30 <merijn> Of course, that's only worth it if you're gonna use it a bunch of times
05:14:37 <disconsis> Hmm there isn't any one function calling all that often
05:14:48 <disconsis> I was wondering more about the general pattern
05:15:16 <disconsis> Is there in there that you would simplify/improve?
05:15:59 <disconsis> I guess it's a bit simpler if a lot of your functions are in the same monad
05:17:47 <merijn> disconsis: That snippet is just in the "inconvenient valley" where it's not really big enough for MaybeT to pay off, but also not small enough that working directly with "IO (Maybe a)" isn't feeling a bit cumbersome
05:18:54 <disconsis> merijn: that makes a ton of sense
05:19:11 <disconsis> thanks!
05:19:21 <merijn> disconsis: tbh, I might just write it with a case on "pos" :)
05:19:33 <jumper149> Btw I was talking nonsense, forget that^^
05:19:57 <disconsis> jumper149: no worries XD
05:20:02 <merijn> "traverse (uncurry pointScreen)" maybe? :)
05:20:38 <merijn> :t traverse (undefined :: a -> IO (Maybe Bool))
05:20:41 <lambdabot> Traversable t => t a -> IO (t (Maybe Bool))
05:20:49 <merijn> ah, not quite
05:20:50 <disconsis> merijn: ok that's going to take me a second to parse
05:21:09 <merijn> :t traverse
05:21:10 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:21:14 * hackage elynx-markov 0.2.2 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.2.2 (dschrempf)
05:21:19 <merijn> disconsis: "Maybe" is Traversable :)
05:21:29 <merijn> But honestly that doesn't quite work out
05:21:59 <merijn> You'd have to do "join <$> traverse (uncurry pointScreen) pos" (where "pos :: Maybe a")
05:22:09 <merijn> Which really isn't better :p
05:22:14 * hackage elynx 0.2.2, tlynx 0.2.2, slynx 0.2.2, elynx-tree 0.2.2, elynx-tools 0.2.2 (dschrempf)
05:22:23 <disconsis> Some of the Maybe instances always trip me up - like Foldable, Traversable
05:22:43 <jumper149> :t traverse (undefined :: a -> IO Bool)
05:22:45 <lambdabot> Traversable t => t a -> IO (t Bool)
05:22:51 <merijn> disconsis: Just think of Maybe as a list of 0-1 elements ;)
05:23:15 <disconsis> I think I've just never grokked `traverse` properly
05:23:29 <merijn> disconsis: You know "mapM"?
05:23:38 <disconsis> Yeah
05:23:45 <disconsis> Aaaah
05:23:48 <merijn> disconsis: traverse is just "mapM" generalised to an Applicative effect and things other than list
05:24:14 <disconsis> shit that makes sense
05:24:15 * hackage elynx-seq 0.2.2 - Handle molecular sequences  https://hackage.haskell.org/package/elynx-seq-0.2.2 (dschrempf)
05:24:17 <disconsis> wait
05:24:21 <merijn> disconsis: You're, well, traversing a data structure performing an effectful map :)
05:24:27 <disconsis> is it related to `sequence`?
05:24:42 <merijn> :t traverse return
05:24:44 <lambdabot> (Traversable t, Monad f) => t b -> f (t b)
05:24:54 <disconsis> :t sequence
05:24:56 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
05:25:00 <merijn> :)
05:25:11 <merijn> I guess it's
05:25:15 <merijn> :t traverse id
05:25:16 <lambdabot> (Traversable t, Applicative f) => t (f b) -> f (t b)
05:25:55 <disconsis> aaaah
05:26:11 <merijn> disconsis: "traverse_" (which is, confusingly, from Foldable) is "traverse a datastructure performing an effectful map, but don't bother building the resulting data structure"
05:26:46 <disconsis> Wait, so is mapM literally traverse?
05:26:48 <disconsis> :t mapM
05:26:49 <merijn> disconsis: traverse_ and traverse obsolete *lots* of historical functions
05:26:49 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:26:54 <disconsis> :t traverse
05:26:55 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:26:56 <merijn> disconsis: Yes
05:27:10 <merijn> disconsis: Except with stricter Monad constraint for hysterical raisins
05:27:21 <merijn> traverse makes mapM entirely redundant
05:27:40 <disconsis> Damn those hysterical raisins XD
05:28:57 <disconsis> I quite like the redundant functions - they provide a nice learning curve
05:29:11 <disconsis> Welp, never using mapM again though
05:30:36 <disconsis> merijn: thank you! this has been educational :)
05:30:41 <merijn> \o/
06:27:51 <jumper149> Does anyone know how to turn a path relative to the location of the binary into an absolute FilePath?
06:28:18 <merijn> jumper149: "prefix the path of the binary"? :p
06:29:06 <jumper149> path is in nix-store^^
06:29:28 <jumper149> oh wait
06:29:45 <maerwald> that's what binreloc is for
06:29:48 <jumper149> were u making fun of me or was that an actual answer
06:29:56 <merijn> jumper149: That's the answer
06:30:01 <maerwald> but not sure there is a haskell binreloc library
06:30:37 <merijn> jumper149: The entire point of relative paths is that you can just stick them on some prefix and get an absolute path
06:32:04 <hakko> I ran "stack init" in an empty folder and now stack is started and hanging after each shell command
06:32:10 <maerwald> :D
06:32:10 <jumper149> Hmm I will just use a command line argument and let nix handle the rest. Seems a lot better :p
06:32:33 <maerwald> merijn: you should also use a proper path library :P
06:32:56 <merijn> maerwald: I said nothing about how to do those things
06:33:04 <maerwald> I'm just advertising
06:33:30 <hakko> can anyone help me exorcise this haunting stack
06:33:32 <merijn> jumper149: What file are you trying to find relative to your binary?
06:33:48 <maerwald> hakko: do you need stack?
06:34:23 <hakko> I wanted to try out streamly so I figured stack is a good starting place
06:34:36 <maerwald> why?
06:35:07 <jumper149> merijn: where the javascript stuff from ghcjs and my static files are
06:35:18 <hakko> that's besides the point now, why is stack running after every shell command
06:35:33 <maerwald> well, hard to help you if I don't know what you need
06:35:40 <merijn> jumper149: FYI, Cabal has support for finding static datafiles of your package
06:36:10 <hakko> I need to get stack to stop running after every shell command
06:36:17 <merijn> jumper149: https://cabal.readthedocs.io/en/latest/cabal-package.html?highlight=getDataDir#accessing-data-files-from-package-code
06:36:55 <jumper149> merijn: That could work! cabal wraps my whole project.
06:37:08 <maerwald> hakko: you don't need stack for trying out streamly, so I have no idea why you choose to fight problems of a tool that is meant for semi-reproducible builds
06:37:53 <merijn> jumper149: data-files means that "where packagers put your static files" and "how your code finds those files" become independent, so it's the robust way to handle static files
06:38:37 <maerwald> it might be there are network issues with stack downloading some json it needs to find GHC tarballs, stackage snapshots etc
06:39:13 <maerwald> debugging stack is a bit involved, because it does so many things
06:39:40 <hakko> I only did a stack init in an empty folder
06:40:11 <hakko> I didn't even start with any code or config
06:40:32 <maerwald> Yes, stack will first want to download GHC 
06:40:44 <maerwald> and for that it needs to download meta info
06:41:05 <hakko> it did that fine, but it just hang afterwards
06:41:14 <hakko> and now it is hanging after every shell command
06:41:39 <hakko> I don't even know why it starts running after every shell command
06:42:43 <maerwald> lol
06:43:07 <hakko> lol ikr
06:43:18 <hakko> i'm thoroughly confused
06:43:33 <maerwald> maybe try cabal instead
06:46:49 <hakko> okay it's fine as soon as I deleted stack.yaml and stack.yaml.lock
06:46:55 <hakko> let me try cabal instead
06:59:28 <haskellGyan> Hello everyone
07:00:59 <haskellGyan> I am having issues while using Stack, My project uses a subdirectory package, earlier everything was working well but when I changed the dependency package my main packages gives this error ```Standard error:ghc-pkg: cannot find package gameEngineProgress 1/2````
07:01:14 <haskellGyan> can someone please help ?
07:02:43 <haskellGyan> ```packages:- '.'- './gameEngine' ```
07:03:06 <frdg> is it correct to say that a monad is an applicative that can alter structure? If so how does this relate to this quote: "monads, in a way, are a generalization of concatenation" ?
07:03:53 <Cale> frdg: Any characterisation beyond the definition is of limited usefulness.
07:04:03 <merijn> frdg: Not really alter structure, because there's not really a structure
07:04:36 <merijn> frdg: The key insight is that: with monads, which "effect" gets run can depend on the result of previous "effects". With Applicative, this can't happen
07:05:06 <merijn> frdg: Consider the simplest case of "selecting" an effect: \b -> if b then effectA else effectB
07:05:36 <frdg> merijn: I see
07:05:38 <merijn> frdg: With the monad interface we can, have the selected effect depend on previous effects simply by using >>=
07:06:04 <Cale> ^^ yeah, I'd say that's the important thing. Literally, you have bind, vs. you only have operations which let you run multiple things and then let you combine their results after the fact.
07:06:08 <merijn> frdg: As an exercise, try and apply that lambda to the result of a previous effect using only Applicative
07:06:18 <merijn> :t (<*>)
07:06:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:06:41 <merijn> Cale: And then Selective comes along and confuses everything ;)
07:07:01 <frdg> ok thanks guys, I think it'll become more clear if I just keep reading.
07:07:16 <merijn> frdg: Alternatively a really great exercise is the following
07:07:38 <merijn> frdg: Take "data Const k a = Const k", now try and define lawful Functor, Applicative and Monad instances
07:07:55 <merijn> frdg: Which (lawful!) instances can you define? Do you need any further restrictions for those instances?
07:08:13 <frdg> merijn: ill try that right now
07:08:15 <Cale> frdg: Focus on picking up examples of these things. Also, if you're a beginner, feel free to just ignore the fact that Applicative is distinct from Monad altogether. The number of cases in which it's an important distinction in real code are pretty small.
07:08:16 <merijn> I think that exercises truly made the distinction between Applicative and Monad click for me :)
07:09:22 <Cale> Almost all the time in practical settings, if you have an Applicative, it also happens to be an instance of Monad.
07:11:59 <maerwald> difference of applicative vs monad is interesting when you try to implement `ifM` in both
07:12:46 <maerwald> https://stackoverflow.com/a/17412969
07:15:41 <HaskellGyan> any help with this stack error message ? `Standard error:ghc-pkg: cannot find package gameEngine`
07:16:33 <merijn> Can I put cost centers on foreign imports?
07:18:53 <HaskellGyan> earlier all was working well but when I changed the dependency package `gameEngine` now I am getting this error with no clue why
07:18:56 <Cale> HaskellGyan: I'm not sure I can offer too much support, I haven't used stack all that much. Where do you expect the gameEngine package to be coming from?
07:19:37 <HaskellGyan> its a sub directory in my main package, I have made it as a dependency in stack.yaml
07:19:51 <HaskellGyan> Cale: ^^
07:20:27 <maerwald> HaskellGyan: do you have a repo to share?
07:20:37 <maerwald> it's hard to guess problems with config if we can't see the config
07:36:15 <HaskellGyan> maerwald : yeah but two different repos `https://github.com/DeepakKapiswe/gameEngine`  `https://github.com/DeepakKapiswe/gameClientServer` , Game Client Server is the main package
07:38:56 <roconnor> @paste
07:38:56 <lambdabot> Haskell pastebin: http://lpaste.net/
07:39:12 <roconnor> :/
07:40:57 <maerwald> Can't test stack, it fails to download itself
07:41:38 <HaskellGyan> roconnor: it requires to login which I don't have
07:44:49 <roconnor> Question about strictness:  Do I need to make the arguments to mappend here strict to have foldl' mempty mappend work properly here?  I think the answer is no because the fields of Stats are already marked as strict, however I'm not entirely sure I'm correct.
07:44:58 <roconnor> https://pastebin.com/FugXMTie
07:48:10 <merijn> roconnor: If you have a new enough GHC there's a strict foldMap so you don't have to worry about that question ;)
07:58:55 <c_wraith> roconnor: the thing to remember about strict fields is that the create an evaluation dependency. When the constructor is evaluated, the fields will be too.
07:59:59 <c_wraith> No more, no less.
08:01:55 <Cale> roconnor: Looks correct to me as is -- max on Int will force both its arguments and then the field extractors will force a and b
08:02:25 <LCRERGO> Hi I have a list like ["3.0","4.0","5.2"], is it possible to map it to "read :: Double" to convert to [Double]?
08:02:57 <Cale> > map (\x -> read x :: Double) ["3.0","4.0","5.2"]
08:03:00 <lambdabot>  [3.0,4.0,5.2]
08:03:18 <c_wraith> or (read :: String -> Double)
08:03:54 <c_wraith> or just let inference do the job...
08:04:04 <Cale> yeah
08:04:13 <Cale> > map read ["3.0","4.0","5.2"] :: [Double
08:04:13 <c_wraith> > map read ["3.0", "3.5"] :: [Double]
08:04:15 <Cale> oops
08:04:15 <LCRERGO> hm... I'm not sure I understand the need of lambda in that case
08:04:15 <lambdabot>  <hint>:1:40: error:
08:04:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:04:15 <lambdabot>  [3.0,3.5]
08:04:37 <Cale> LCRERGO: It just gave a convenient place to give the type of the result
08:05:29 <Cale> Often you wouldn't need any annotation -- if you're taking the resulting list and applying a function to it which definitely requires a [Double] you won't need to say which type you're trying to parse
08:08:39 <LCRERGO> I think I understand, thx
08:24:04 <sm> hakko: if you still care, I'll help you exorcise your haunting stack
08:24:31 <hakko> lol thanks sm I dealt with it
08:24:58 <sm> holy water ?
08:28:44 * hackage hoauth2 1.12.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.12.0 (HaishengWu)
08:30:47 <sm> rotaerk, maerwald: I was starting to plan on nixos for managing some new work machines, but your chat yesterday makes me rethink
08:31:05 <sm> rotaerk: have you tried guix ? Any better ?
08:31:18 <rotaerk> sm, why rethink?
08:31:20 <sm> maerwald: what don't you like about propellor ? That's what I used last time to worked on this
08:31:39 <rotaerk> I like nixos, I just wouldn't use nix-build as a *build* system
08:32:13 <rotaerk> probably should take this to #haskell-blah though
08:32:14 <sm> rotaerk: it looked like you were pointing out some ways in which I wouldn't get the reproducibility/repeatability/convenience/freedom from hassles that I'm hoping for. I might have misunderstood
08:32:20 <sm> alright.. no worries
08:32:40 <sm> (you're righ)
08:33:23 <rotaerk> gonna join? :P
08:33:40 <rotaerk> alternatively, #haskell-offtopic
08:34:15 * hackage qrcode-core 0.9.3 - QR code library in pure Haskell  https://hackage.haskell.org/package/qrcode-core-0.9.3 (alexkazik)
08:35:15 * hackage qrcode-juicypixels 0.8.1 - Converts a qrcode-core image to JuicyPixels  https://hackage.haskell.org/package/qrcode-juicypixels-0.8.1 (alexkazik)
09:06:44 * hackage hasql-migration 0.3.0 - PostgreSQL Schema Migrations  https://hackage.haskell.org/package/hasql-migration-0.3.0 (TvH)
09:33:37 <dsal> Is there a lensy way to do something like preview, but with default?  I've got  bunch of   `maybe [...] . preview`   kinds of things that feel weird.
09:45:42 --- mode: kornbluth.freenode.net set +o ChanServ
09:45:59 <Orbstheorem> Hi. Why do I have to specify internal modules in a package.yaml?
09:58:56 <dsal> Orbstheorem: what do you mean?
10:01:16 <Orbstheorem> dsal: When writing an app, I have to add all of my modules to my package.yaml (under library.other-modules), else I get an error from hie's bios "Could not obtain flags for: src/Foo.hs"
10:02:49 <dsal> I have library.source-dirs and a toplevel dependencies entry of my package but that's it.  Can you show me your package.yaml?
10:05:10 <srk> dsal: do the gopro blog post, I'm interested :) used python for that before
10:05:33 <dsal> srk: Thanks.  Yeah, I'll get on that.  I have a lot of interesting findings, I think.
10:05:46 <Guest_54> hey, i have a trouble with downloading this app. Anyone could help? Thank you so much
10:05:50 <dsal> Just uploaded 10 new things today with a bunch of parallelism.  :)
10:05:53 <srk> dsal: cool :)
10:08:21 <infandum> does minimumBy repeat calculations? Looking at the code I would say yes, but does minimumBy (compare `on` bigCalc) repeat bigCalc for an element more than once? 
10:10:32 <dsal> It's hard to know that kind of thing given a sufficiently advanced compiler.
10:10:42 <dmwit> infandum: Yes, it repeats. Use minimumOn instead.
10:10:59 <dmwit> ...now if we could just have minimumOn in the standard library. =P
10:11:25 <dmwit> :t let minimumOn f = fst . minimumBy snd . map (id &&& f) in minimumOn
10:11:27 <lambdabot> error:
10:11:27 <lambdabot>     • Occurs check: cannot construct the infinite type:
10:11:27 <lambdabot>         b1 ~ (a1, b1) -> Ordering
10:11:29 <monochrom> How is minimumOn implemented, such that it doesn't recompute this?
10:11:40 <dmwit> :t let minimumOn f = fst . minimumBy (comparing snd) . map (id &&& f) in minimumOn
10:11:42 <lambdabot> Ord b => (a -> b) -> [a] -> a
10:11:42 <monochrom> Ah, I see OK.
10:12:05 <monochrom> once again a time-space tradeoff!
10:12:07 <dmwit> A more efficient implementation is possible -- to avoid constructing and deconstructing tuples repeatedly.
10:12:28 <dmwit> Well, yes, but also no: minimumOn does not take more space than minimumBy.
10:13:09 <dmwit> Hm. Well. It might, depending on what the Ord instance for b looks like, I guess.
10:13:11 <monochrom> Oops nevermind, right, I had sorting in mind.
10:13:18 <dsal> A Schwartzian transform?
10:14:28 <dmwit> Like maybe if the Ord instance is lazy in a weird way, then minimumOn forces multiple paths through the b data structure but minimumBy recomputes b a lot and so only keeps one "path" through the structure in memory at a time.
10:14:36 <dmwit> Okay! So a complicated time-space tradeoff. What do you know.
10:14:38 <dmwit> dsal: yes
10:14:46 <monochrom> Yeah don't worry about Ord's cost.
10:15:17 <dsal> Ord's Cost sounds like a fantasy novel.
10:16:26 <monochrom> "Event Horizon: Ord's Cost"
10:16:58 <monochrom> That's a whole franchise of novels, movies, video games, card games, and action figures right there. >:)
10:17:12 <dsal> A journey through time and space.
10:17:16 <dmwit> The more efficient implementation: `minimumOn f (x:xs) = go (f x) x xs where go fx x [] = x; go fx x (x':xs) = let fx' = f x' in if fx' < fx then go fx' x' xs else go fx x xs`
10:18:18 <dmwit> By the way, if I were to choose to use minimumBy instead of minimumOn because of the above space considerations, I'd be writing a very detailed comment about it, because that's pretty subtle.
10:19:58 <shachaf> OK, but what if, for my type, you can compute min but can't compute <?
10:20:31 <monochrom> Can I compute == ?
10:20:46 <shachaf> No.
10:21:19 <shachaf> An example type with this property is Stream Bool.
10:21:24 <dmwit> I'm not sure what's interesting about this question. Neither minimumBy nor minimumOn work in that circumstance, so it's not really a differentiator.
10:22:29 <shachaf> Well, not the Prelude minimum, I suppose, or anything that uses Ord.
10:23:03 <dmwit> But we're not doing minimum in this conversation so far.
10:23:51 <dmwit> I think I agree that if you want to compute a different function you should use a different algorithm.
10:24:01 <monochrom> Then it's a fold over min.
10:24:29 <shachaf> I would prefer to use the same algorithm to compute a different function.
10:25:05 <monochrom> Then re-implement the standard minimum, minimumBy, and minimumOn to be folds over min, too.
10:25:24 <dmwit> minimumBy and minimumOn can't be folds over min, I don't think.
10:25:26 <monochrom> And maybe propose to library@haskell.org to make this change world-wide.
10:25:43 <dmwit> I'm pretty sure it's not possible to compute something like minimumBy or minimumOn if all you get is min on the codomain type.
10:25:53 <monochrom> Oh oops, right.
10:26:33 <shachaf> Oh, that's a good point. You can implement sort but not sortBy.
10:26:36 <monochrom> Darn how to do this?  It has mildly bothered me in the past.
10:27:30 <dmwit> I think not decidable. Stream Bool is a good example -- if `3` and `5` both map to `const True`, you can never decide whether you should answer `3` or `5`.
10:28:13 <dmwit> Or, to say even more precisely: if you ever decide to spit out either `3` or `5`, I will produce a slightly different mapping on which you are forced to produce the wrong answer.
10:30:09 <monochrom> Is it do-able if the mapping is injective?
10:30:46 <dmwit> I think if the mapping is injective, then your previous question of "can I compute ==" is "yes": always answer False from ==.
10:30:49 <dmwit> =)
10:31:20 <dmwit> err
10:31:20 <dmwit> hm
10:32:03 <dmwit> I guess that's not true. You can only answer == if the domain type can answer == and both codomain values are outputs of the function.
10:32:12 <dmwit> Which won't be the case once it's an output of min.
10:32:13 <dmwit> whoops
10:33:56 <dmwit> May I compute things in parallel?
10:35:35 <dmwit> If so, perhaps I can construct f x < f y = ((min (f x) (f y) == f x) ==> True) | ((min (f x) (f y) == f y) ==> False)
10:36:09 <dmwit> Here I assume both injectivity and a semidecidable (==).
10:36:22 <dmwit> (Stream Bool offers the latter.)
10:39:16 <dmwit> Whoops. Needs a `x /= y && ...` term, I guess.
10:39:31 <dmwit> This is getting complicated.
10:40:51 <monochrom> math is too hard
10:42:25 --- mode: kornbluth.freenode.net set +o ChanServ
11:18:19 <dsal> rerun of my lens question from earlier.  Is there a way to do this in a lensier fashion?
11:18:20 <dsal> > fromMaybe 'a' $ Nothing ^? _Just
11:18:23 <lambdabot>  'a'
11:19:31 <dsal> e.g., I have something that takes some JSON and returns True if it determines a thing within it is true.
11:20:44 <dsal> That's also maybe not a good example because it starts with Nothing.  Or it's a good example because it starts with Nothing.
11:44:12 <viluon> hello, I'm looking for GHC devs knowledgeable about GHCi internals. I have a few questions: 1) how up-to-date are docs/ghci/ghci.tex and docs/rts/rts.tex (are constructors still handled in machine code only)? 2) does bytecode interpretation ever create thunks, or do BCOs essentially replace those? 3) what is the ghc-heap library and where is it
11:44:12 <viluon> documented?
11:51:00 <xsperry> is there a library for passing haskell data over the network?
11:52:35 <Philippa> viluon: #ghc exists
11:53:07 <viluon> thanks Philippa
11:53:24 <Philippa> xsperry: it depends a bit on what you mean by "haskell data". There's no One True Solution for serialisation because Haskell effectively reserves the right to talk about things you can't serialise
11:53:59 <Philippa> there's a bunch of options on Hackage, but you'll want input from someone who's actually used them
11:55:45 <maerwald> we don't have something cool like serde, but I guess you could argue Generics are that
11:55:58 <Philippa> they're certainly one way to build it, yeah
11:56:09 <Uniaika> xsperry: yes, haskell-cloud
11:56:12 <maerwald> But serde is really cool
11:56:18 <Uniaika> this is a library (or set of library) that can do that
11:56:23 <Uniaika> (more-or-less)
11:56:37 <Uniaika> (your kilometrage may vary)
11:56:47 <Philippa> Uniaika: mostly my own fault but it's been years since I last saw anything on it - how'd it turn out?
11:56:54 <maerwald> Uniaika: last activity was in 2016 :)
11:56:56 <Philippa> (I think I was at a Fun in the Afternoon)
11:57:13 <Uniaika> Philippa: still decomposing, as one would expect from a dead body
11:57:15 <Philippa> maerwald: given the pace of GHC extensions that doesn't bode wonderfully
11:57:27 <solonarv> the main obstacle is that in Haskell, we tend to use closures a lot more than other languages do, and it's generally hard to serialize those
11:57:37 <maerwald> There was a huge push for cloud-haskell once, probably comany-backed
11:57:43 <maerwald> But now I don't see much traction
11:57:53 <Uniaika> yeah it even appears in Marlow's book
11:57:53 <Philippa> solonarv: yeah. Though there's a reasonable definition of "data" that doesn't do that and you can write a typeclass for
11:58:04 <Uniaika> I never knew who was behind Cloud-Haskell
11:58:12 <maerwald> smart dudes
11:58:19 <Philippa> "code is data is code" is only true up to isomorphism etc etc
11:58:28 <frdg> why can't I ask for the type of `<-` ?
11:58:32 <Uniaika> most certainly, maerwald 
11:58:39 <Uniaika> but smartness can only bring you so far
11:58:42 <solonarv> because '<-' is a piece of syntax that has no meaning of its own
11:58:47 <Philippa> frdg: because it's not an operator, it's a reserved word
11:58:49 <maerwald> they all got promoted and now there's no one left to code :D
11:58:56 <solonarv> asking for its type is like asking for the type of '=' or '::'
11:59:11 <frdg> solonarv,Philippa: I see thanks
11:59:19 <solonarv> or to extend this to keywords, it is like asking for the type of 'where' or 'case'
11:59:21 <Uniaika> frdg: `m a -> a` is its type :P
11:59:28 <Uniaika> (that's terribly false)
11:59:31 <Uniaika> (don't listen to me)
11:59:47 <Philippa> if you're trying to get your head around do notation, you'll want to look up how do desugars and the types of >>= and return
12:00:17 <Philippa> (in do notation, <- gets translated into something where >>= does most of the work)
12:00:37 <frdg> Philippa: ok will do thanks
12:00:51 <dsal> @undo do { v <- a; print a }
12:00:51 <lambdabot> a >>= \ v -> print a
12:01:01 <Philippa> dsal: good shout
12:01:21 <dsal> Er, maybe not print a...  I'm confused if that can even work now.
12:01:23 <dsal> @undo do { v <- a; print v }
12:01:23 <lambdabot> a >>= \ v -> print v
12:01:31 <dsal> @do a >>= print
12:01:32 <lambdabot> do { b <- a; print b}
12:01:43 <Uniaika> frdg: yes, please be certain to understand how sequencing actions with monads work before using do-notation, you'll avoid a great deal of head scratching and this will remove pretty much all of the "magic" that you may feel is present when using 'do'
12:02:38 <Philippa> Uniaika: eh. Taking either approach works depending on who you are. And I can back that up all the way to the category theory
12:02:53 <Philippa> "do notation is the internal language of Monad", basically
12:03:17 <Philippa> give-or-take, it's even in Moggi's original paper
12:04:16 <Philippa> (also: "sequencing" is only for a pretty loose value of the word, lazy monads very much exist and I once accidentally wrote a monadic eager interpreter that behaved lazily because the Reader monad'd become one while I was away)
12:04:28 <Uniaika> Philippa: I'm an advocate for understanding the inner workings of `do` notation
12:04:47 <Uniaika> (which aren't that hard, since it's barely desugaring)
12:05:01 <dsal> @undo a >> b
12:05:01 <lambdabot> a >> b
12:05:05 <dsal> @do a >> b
12:05:05 <Uniaika> ah well, maybe sequencing wasn't the right word indeed
12:05:05 <lambdabot> do { a; b}
12:05:18 <solonarv> yes, the desugaring of 'do' notation is very straightforward
12:05:21 <dsal> @do print =<< a
12:05:21 <lambdabot> print =<< a
12:05:22 <Philippa> Uniaika: which I'm not against, but it's a good idea to let people see what gets traction for them first. I'd go further: I tend to teach ANF and the classic desugaring of "simple let" en route
12:05:31 <solonarv> well, with one exception (<- bindings with a pattern that can fail)
12:05:53 <solonarv> those are a tad more complicated
12:05:53 <Philippa> but I do it responsively - telling people the right order for them to learn when things are mutually reinforcing is a bad idea
12:06:18 <Philippa> solonarv: yeah, long-known wart :/
12:08:35 <maerwald> Just x <- pure $ something -- my favorite abuse of MonadFail =)
12:09:32 <dsal> What's special about patterns that fail?
12:09:40 <dsal> @undo Just x <- pure $ something
12:09:41 <lambdabot> <unknown>.hs:1:8:Parse error: <-
12:09:41 <Philippa> frdg: sorry we kinda showered you in extra info there
12:09:46 <dsal> @undo do { Just x <- pure $ something }
12:09:47 <lambdabot> <unknown>.hs:1:34:Parse error: Last statement in a do-block must be an expression
12:09:58 <dsal> @undo do { Just x <- pure $ something; print x }
12:09:58 <lambdabot> pure $ something >>= \ a -> case a of { Just x -> print x; _ -> fail ""}
12:10:02 <dsal> oh
12:10:03 <Philippa> dsal: what's special is that a monad isn't enough structure to desugar them in do notation
12:10:15 <Philippa> fail being in Monad was always a wary
12:10:17 <Philippa> *wart
12:10:49 <dsal> It's not now, though, so that's nice.
12:11:06 <monochrom> I have stopped telling my students about do-notation.  I teach them >>= only, and my sample code and homework solutions all stick to >>= (and Applicative methods, fmap, etc)
12:11:34 <monochrom> To be sure, if they discover do-notation on their own and use it in homework, I don't mind.
12:11:58 <monochrom> I didn't make this decision on my own.  I consulted past students.  They recommended this.
12:12:01 <maerwald> monochrom: my exam back then was full with tasks of desugaring and resugaring this and that. Seems a popular thing to annoy students with
12:12:10 <monochrom> heh
12:12:22 <int-e> > do 42
12:12:23 <lambdabot>  42
12:12:36 <dsal> Can 42 be undone?
12:12:36 <Philippa> monochrom: makes sense. It's a useful thing, but it's confusing to start off with and doesn't necessarily belong in a single module - especially in a post-Applicative world
12:12:51 <int-e> dsal: only if you don't use "do".
12:12:57 <dsal> @undo 42
12:12:57 <lambdabot> 42
12:13:00 <Philippa> :t do 42
12:13:01 <lambdabot> Num p => p
12:13:12 <dsal> 42 is a fixed point
12:13:15 * hackage calamity 0.1.3.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.3.1 (nitros12)
12:13:24 <Philippa> say hello to a weird consequence of do being syntactic sugar
12:13:38 <int-e> Philippa: isn't it glorious
12:13:44 <Philippa> a single non-binding statement can have any type you like
12:13:50 <int-e> Haskell is such a SWEET language.
12:14:08 <monochrom> > do not False
12:14:09 <Philippa> int-e: it's the sort of thing I'd make an elaborator rap you on the knuckles for, tbh
12:14:10 <dsal> I kind of don't understand `do 42` at this point.  Maybe I just don't understand `do`
12:14:11 <lambdabot>  True
12:14:38 <Philippa> dsal: the last statement in do notation is just left "as is" by the translation
12:14:49 <dsal> Philippa: Oh.  That makes sense.
12:15:39 <int-e> Philippa: Pah. It's useful to know corner cases. It's bad to exploit them, except for entertainment.
12:16:19 <dsal> I mostly accidentally exploit that particular case, in that I'll start something that eventually reduces to `do f` and then hlint tells me I have an extra do.
12:17:06 <Philippa> int-e: and it's the sort of thing you can rule out in languages that treat syntax in a type-aware manner, yeah. Haskell and do notation originate from a time when that was a really silly implementation strategy if you didn't need it
12:17:15 * hackage haskoin-store 0.23.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.0 (jprupp)
12:17:19 <Philippa> monochrom: 'sfunny, I spend ages away and some things never change
12:18:07 <monochrom> fail has changed though.  It's now in MonadFail.  "Right x <- ..." also incurs MonadFail.  Monad is now pristine.
12:18:22 <dsal> ...almost pure
12:18:24 <int-e> Philippa: yeah who would ever have thought that people want good error messages so type checking would happen on fully sugared code
12:18:44 <int-e> (and inference. never forget inference.)
12:19:05 <dsal> Isn't there a proposal to get rid of `return`?  I'm not sure how serious such a thing could be, but I like the idea.
12:19:21 <monochrom> Yeah. That one will take decades :)
12:19:27 <dsal> Ah, of course: https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/monad-of-no-return
12:19:31 <Philippa> dsal: by way of using pure instead, yeah. I think you'd need return = pure somewhere for a long time in practice
12:20:03 <dsal> Yeah, makes sense.  I dislike `return` for lots of reasons.
12:20:31 <monochrom> I support "pure", but only because "return" is a bad name.  I don't care whether Monad has a redundant method.
12:20:33 <Philippa> it's a lot easier to explain what pure "really does", yeah
12:21:01 <maerwald> yes, no return and next milestone will be replacing Monad class with Supermonads
12:21:14 <maerwald> You'll see
12:21:22 <int-e> . o O ( "pure" takes a pure value and soils it. )
12:21:33 <dsal> Is supermonad a thing?
12:21:38 <monochrom> Yes.
12:21:47 <maerwald> @hackage supermonad
12:21:48 <lambdabot> http://hackage.haskell.org/package/supermonad
12:21:58 <monochrom> TLDR generalizing to a MPTC
12:22:02 <dsal> Does this have something to do with lambdaman?
12:23:02 <maerwald> I'm looking at generics-sop and am trying to figure out what the motivation behind is. I only see lots of technical details.
12:23:38 <frdg> is the way that (>>) works on lists and Maybe at all relevant to how it works with IO ?
12:24:13 <Philippa> frdg: "this happens but ignore the result". Sometimes ignoring the result means nothing meaningful happens
12:24:49 <Philippa> and sometimes it means the only meaningful thing that can happen is "something goes wrong"
12:25:27 <Philippa> (Maybe effectively gives you errors you know nothing about, and Either gives you ones you do - put the error info on the Left)
12:25:34 <solonarv> maerwald: it is useful for the same things GHC's generics are, but it just uses a different representation
12:25:55 <frdg> Philippa: ok thank you
12:26:02 <solonarv> namely, n-ary sums/producs rather than balanced trees of binary sum/product
12:26:44 <Philippa> frdg: lists kinda give you nondeterminism, you get n results where n could be 0
12:27:55 <dsal> @undo do { print "hi"; getLine } -- frdg 
12:27:55 <lambdabot> print "hi" >> getLine
12:30:05 <frdg> hmm ok. I think Im gonna go back to reading for a bit and come back with better questions. thanks guys
12:32:46 <dsal> I guess io feels a little different because there's not really a logical short circuit there 
12:33:46 <dsal> > Left "x" >> Right "y" -- we can have a thing that fails and know we don't need to keep going.
12:33:48 <lambdabot>  Left "x"
12:36:46 <monochrom> "x >> y" in IO can short-circuit if x throws an exception. This is the aspect that's similar to "Nothing >> y" and "[] >> y".
12:37:04 <dsal> Yeah, exceptions just feel a little different
12:37:37 <monochrom> Also consider "fail "hi" >> y" for all of IO, Maybe, []. >:)
12:38:09 <dsal> I don't use fail that much.  I'm starting to think I should.
12:40:42 <monochrom> Don't use it directly.  Use patterns.  do { ... Right x <- foo ... }
12:40:48 <dsal> > fail "wtf" :: Either String ()
12:40:50 <lambdabot>  *Exception: wtf
12:40:59 <dsal> That doesn't do what I expect.
12:41:22 <monochrom> Because it needs to do the same thing when Either Int ()
12:41:46 <Uniaika> (MonadError ftw)
12:41:47 <monochrom> It is unclear what Int to give to "Left ???"
12:41:57 <maerwald> monochrom: can we not jug a monoid in there somehow via a type family?
12:42:03 <dsal> I figured it'd be `Either String`
12:42:09 <maerwald> and then mempty the error :P
12:42:41 <monochrom> Please send your regards to library@haskell.org and watch the debate ensue >:)
12:42:54 * dsal is Haskelling on the phone
12:43:04 <monochrom> I have a feeling it has happened before and it will happen again.
12:43:14 <Philippa> fail is rarely a good way to handle proper errors because stringly-typed errors are a pain
12:43:33 <Philippa> monochrom: it's even led to library changes on occasion, but I doubt this time would
12:43:49 <Philippa> Either needs to behave itself with other things that come from Haskell2020
12:45:32 <solonarv> monochrom: the actual reason is just that lambdabot is not fully up to date, I think
12:45:39 <solonarv> % fail "wtf" :: Either String ()
12:45:40 <yahb> solonarv: ; <interactive>:1:1: error:; * No instance for (MonadFail (Either String)) arising from a use of `fail'; * In the expression: fail "wtf" :: Either String (); In an equation for `it': it = fail "wtf" :: Either String ()
12:46:11 <solonarv> % System.Info.compilerVersion
12:46:11 <yahb> solonarv: Version {versionBranch = [8,10], versionTags = []}
12:46:13 <maerwald> I'm starting to form an unpopular opinion. The most important thing about a programming language isn't its type system or paradigm, but how it enables me to deal with errors.
12:46:18 <solonarv> > System.Info.compilerVersion
12:46:21 <lambdabot>  error:
12:46:21 <lambdabot>      Not in scope: ‘System.Info.compilerVersion’
12:46:21 <lambdabot>      No module named ‘System.Info’ is imported.
12:46:30 <solonarv> @let import System.Info
12:46:32 <lambdabot>  Defined.
12:46:36 <solonarv> > System.Info.compilerVersion
12:46:38 <lambdabot>  Version {versionBranch = [8,6], versionTags = []}
12:46:59 <Philippa> maerwald: give-or-take whether it's "the most important thing" or a high-ranked criterion I don't think that's particularly controversial tbh
12:47:34 <Philippa> generalise it to "instrumentation" and it's something I actively look for
12:47:38 <maerwald> Philippa: my point is... you should design your language around it :)
12:47:53 <maerwald> not think about it 20 years later and retro-fit intelligent hacks onto it
12:48:12 <maerwald> a new paradigm
12:48:16 <maerwald> error-driven programming
12:48:22 <Philippa> haskell 1.0 wasn't ever intended to end up in the range of roles Haskell occupies in 2020
12:48:40 <Philippa> its first two goals were research and teaching-of-languages-like-itself
12:49:13 <Philippa> that said: I'm in favour of treating error handling as part of the wider problem of effect handling
12:49:14 <maerwald> What do we want? 1. checked exceptions, 2. an effects system that is statically checked and not part of the ordinary type system
12:49:45 <Philippa> "not part" or "not embedded into"? Big difference
12:50:33 <maerwald> there'll always be some overlap
12:50:45 <maerwald> like with rusts borrow checker
12:51:09 <Philippa> we mostly experience the borrow checker that way because it's a big pile of inference on top of a more explicit language though
12:51:43 <maerwald> but I don't want to touch the types of my values and functions just because I'm messing with exceptions and errors
12:51:52 <maerwald> Those are two different things, imo
12:52:11 <maerwald> So yes, just have two signatures for your functions
12:52:23 <Philippa> if you're not okay with "I'll ask the compiler to figure this bit out" as the way you're not touching it, you miss out on a lot of things
12:56:14 * hackage zeolite-lang 0.1.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.0.0 (ta0kira)
13:30:15 * hackage Frames 0.6.3 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.6.3 (AnthonyCowley)
13:31:57 <tabaqui1> I found strange behavior of GHC with PatternSynonyms + RecordWildCards
13:31:59 <tabaqui1> https://gist.github.com/boris-stepanov/40c5d5c6a02d0fd7cfd3470329c9dfe8
13:32:14 * hackage tasty-golden 2.3.3.2 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.3.2 (RomanCheplyaka)
13:32:18 <tabaqui1> It warns me about name shadowing, but still make correct program
13:32:44 <merijn> tabaqui1: Why wouldn't it?
13:33:01 <koz_> Name shadowing is a warning for a reason - GHC still understands perfectly fine.
13:33:05 <koz_> (you might not, though!)
13:33:15 <tabaqui1> merijn: I don't expect warnings here
13:33:38 <tabaqui1> I mean, what's the difference between a pattern synonym and a regular record?
13:34:45 <tabaqui1> data Point = Point { x :: Int }; foo Point{..} = x  -- OK!
13:35:02 <tabaqui1> pattern Point{x} = x; foo Point{..} = x   -- Warning, but OK
13:35:19 <Cale> The weird thing I guess is that the shadowing is in both directions.
13:35:45 <Cale> Oh, no I'm wrong, it's not, you just have two examples of it
13:36:03 <ArthurStrong> Hi all. What other PLs has monads? JavaScript? And..? Just wondering.
13:36:03 <Cale> Your pattern synonym introduces a top-level definition of x
13:36:29 <Cale> ArthurStrong: Idris, Coq (somewhat -- at least, you can use them), Agda
13:36:35 <ArthurStrong> Cale: thanks
13:36:39 <tabaqui1> Cale: right, but a common data declaration introdeces them too
13:36:51 <tabaqui1> *introduces
13:36:58 <Cale> ArthurStrong: You basically need some approximation of type classes to make the monad abstraction usable
13:37:59 <tabaqui1> well
13:37:59 <Cale> ArthurStrong: So most mainstream languages don't really produce an acceptable approximation of it. Even though you might theoretically be able to implement the abstraction in Javascript, it would involve awkwardly passing extra dictionary arguments everywhere and making sure you're using the right ones all the time.
13:38:13 <tabaqui1> should I report this on the ghc bug tracker?
13:38:20 <merijn> Cale: Maybe C++ if you can live with A LOT of painful boilerplate :p
13:38:40 <Cale> tabaqui: Ah, I guess usually RWCs suppresses that warning
13:39:01 <Cale> tabaqui: Perhaps!
13:39:19 <tabaqui1> Cale: I'm sorry, what is RWC?
13:39:26 <Cale> RecordWildCards
13:39:45 <tabaqui1> ah, I've enabled it
13:40:12 <Cale> You're technically shadowing a bunch of stuff *every* time you use RWCs, and somehow that warning isn't being disabled for RWCs that use pattern synonyms
13:40:29 <tabaqui1> right
13:47:09 <tabaqui1> https://gitlab.haskell.org/ghc/ghc/issues/18107
13:50:00 <tabaqui1> oops, duplicate
13:51:14 * hackage hspec-tables 0.0.1 - Table-driven (by-example) HSpec tests  https://hackage.haskell.org/package/hspec-tables-0.0.1 (rzeznik)
13:59:55 <jakalx> Philippa:55702`4902
14:00:15 * hackage zeolite-lang 0.1.1.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.1.1.0 (ta0kira)
14:00:35 <jakalx> sorry, phone did stuff
14:17:02 <frdg> is it reasonable to read (>>) as "then"
14:18:00 <koz_> frdg: Yeah, I'd say so.
14:18:21 <rawles> frdg: Yes, that's what they call it in the Haskell Wikibook: https://en.wikibooks.org/wiki/Haskell/Understanding_monads#Type_class
14:18:42 <frdg> thanks thats great to hear that im on the right track
14:25:05 <koz_> Is there a thing I can pass to stack which says 'turn warnings into errors'?
14:25:49 <lyxia> --ghc-options="-Werror" ?
14:26:26 <sm[m]> or stack build --pedantic
14:27:09 <koz_> sm[m]: --pedantic is much stronger.
14:27:16 <koz_> It also enables a lot of additional warnings.
14:27:21 <sm[m]> yup
14:27:25 <maerwald> --Werror --pedantic --ocd
14:27:29 <koz_> lyxia: Thanks!
14:28:24 <sm[m]> I think --pedantic is a bad name. I build that way, and I'm not a pedant!
14:28:36 <koz_> sm[m]: I would too, but unfortunately it's not in my hands (yet).
14:28:42 <koz_> IT WILL BE THOUGH
14:28:46 <Rembane> It's history... 
14:29:09 <sm[m]> ...am I ?
14:30:44 * hackage calamity 0.1.4.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.4.0 (nitros12)
14:30:53 <maerwald> sm[m]: first step is accepting that you are :P
14:31:08 <koz_> Haskell's naming game is hilarious.
14:31:10 <maerwald> join the support group
14:31:20 <Kaiepi> what sort of reading should i do to better understand how to use the recursion-schemes library?
14:31:24 <koz_> maerwald: Working on that cross toolchain.
14:31:32 <Kaiepi> there's the paper it mentions in the readme but i'm having trouble reading it
14:31:41 <koz_> Kaiepi: https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html
14:31:44 <koz_> Start here.
14:32:10 <Kaiepi> thanks
14:32:24 <koz_> That's a 5-blogpost series, and covers basically all of it.
14:32:33 <koz_> (aside from some of the more exotic ones, I think)
14:32:52 <merijn> Kaiepi: Is that the bananas and barbed wire paper?
14:33:35 <Kaiepi> yeah
14:33:40 <merijn> Yeah...
14:34:06 <merijn> Not being able to read that is a sign of a terminal case of "being a normal person" :p
14:34:21 <koz_> I would agree with merijn - that stuff is _dense af_.
14:34:43 <koz_> maerwald: Workin' on that cross-comp toolchain as we speak.
14:34:51 <koz_> Should be able to test ghcup-hs's new capabilities today.
14:35:22 <merijn> Honestly, I wanna like recursion schemes
14:35:30 <merijn> But I just can't be arsed
14:35:39 <Rembane> Why can't you be arsed?
14:36:03 <merijn> Rembane: See koz_'s comment :p
14:36:15 <koz_> And I actually get them!
14:36:19 <merijn> It's like smacking your head into a dense brick of abstraction :p
14:36:23 <koz_> (well, programmatically, not theoretically)
14:36:28 <koz_> (theoretically I don't even _pretend_ to)
14:36:55 <Rembane> merijn: Yeah, but isn't the most of Haskell that?
14:37:03 <merijn> Naah
14:37:06 <koz_> Rembane: I don't think so at all.
14:37:41 <merijn> A lot of the abstraction are pretty straightforward and also, directly useful
14:37:46 <koz_> Monad transformers, for example, are _way_ less obtuse than recursion schemes.
14:37:49 <hseg> is quickcheck's forAllShow *supposed* to strip newlines from the pretty-printed counterexample?
14:38:03 <merijn> Recursion schemes are all "by not doing the recursion manually you can't screw it up!"
14:38:03 <koz_> hseg: I'm not sure. Is that the behaviour you're seeing?
14:38:18 <hseg> unless i'm misunderstanding what i did, yes
14:38:27 <merijn> But then actually using recursion schemes is almost always way more confusing than just writing the manual recursion correctly
14:38:29 <crestfallen> http://ix.io/2jPX  hi I thought this example would work exactly like bind. Not sure what's going on. error message included
14:38:52 <koz_> crestfallen: !> isn't bind, it's fish.
14:38:56 <koz_> :t (>=>)
14:38:58 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:39:25 <hseg> my property is basically prop_impls_consistent impls = forAllShow genInput (pretty . (id &&& results impls)) (consistent (results impls))
14:39:39 <koz_> hseg: forAllShow is not forAll.
14:39:45 <koz_> There, there might be some newline stripping.
14:39:59 <hseg> *facepalm*
14:40:11 <koz_> I dunno for sure though - never been an issue for me.
14:40:25 <crestfallen> koz_, isn't |> the fish here?
14:40:28 <koz_> You might wanna check the source for forAllShow and see if there's any munging of the output being done here.
14:40:42 <koz_> crestfallen: Look at the type of you !>, versus the type I just had lambdabot spew.
14:40:49 <koz_> You will notice a great degree of similarity.
14:41:00 <koz_> s/you !>/your !>/
14:42:00 <hseg> ... quickcheck seems to have some extensive plumbing
14:42:14 <hseg> why does it do explicit terminal management?
14:42:21 <koz_> hseg: That I can't tell you.
14:42:48 <merijn> Pretty printing results
14:42:58 <merijn> (presumably)
14:43:45 <lyxia> yeah, showing progress + colors.
14:43:53 <hseg> ... ok
14:45:15 <Kaiepi> yeah, after working my way through the typeclassopedia i don't find most of haskell's typeclasses very confusing
14:45:21 <Kaiepi> they make my code much simpler!
14:45:25 <Kaiepi> recursion schemes though...
14:45:57 <crestfallen> koz_, the tutorial ends with this:     Well, assuming you understood the constraints required to make m komposable, and the laws for well-defined komposition, then you know what monads are. m will always be a monad whenever these constraints are satisfied.
14:46:13 <crestfallen> https://www.schoolofhaskell.com/user/Lkey/kleisli
14:46:33 <hseg> seems to be the fault of one of the callees of https://hackage.haskell.org/package/QuickCheck-2.14/docs/src/Test.QuickCheck.Text.html#putLine
14:46:46 <crestfallen> I thought I understood this tutorial, dang it.
14:46:52 <koz_> crestfallen: ... wut?
14:46:57 <koz_> Oh right, sorry.
14:47:07 <koz_> I dunno anything about said tutorial. Just answering what you wrote.
14:47:29 <hseg> though i still don't see what's wrong there
14:49:39 <crestfallen> koz_, I thought he was building up another way to implement bind
14:50:42 <padraic>  
14:51:04 <crestfallen> could you give me an example of how !> would be used? koz_  
14:51:31 <koz_> crestfallen: You use (.) to compose things of type a -> b.
14:51:46 <brj> I was playing around in GHCi when this happened https://git.io/JfqdO
14:51:55 <koz_> Likewise, (<=<) and (>=>) are used to compose things of type 'a -> m b', where m is a Monad instance.
14:52:12 <padraic> Was told here would be better to ask this but has anyone ran into nix issues with zlib?
14:52:26 <sm[m]> brj: ouch.. #ghc might be interested
14:52:58 <brj> sm[m]: alright will ping there
14:54:27 <lyxia> hseg: is it really a quickcheck issue? a simple test prints multiline strings fine.
14:55:03 <crestfallen> >>=  >>  >=>  <=<  |>  !>   just in a quagmire right now
14:55:52 <hseg> well, checked that forAllShow gen (const "\nhello\nworld\n") (const True) stripped the newlines
14:56:31 <hseg> am trying forAll gen (counterexample "\nhello\nworld\n" . const False), just a moment
14:56:37 <brj> hmm that happens whenever I press tab after typing import
14:56:59 <koz_> crestfallen: Number 1 rule - follow the types.
14:57:03 <koz_> They will tell you everything.
14:58:56 <hseg> yeah. both error out
15:00:49 <crestfallen> how to implement (a -> m b) , (b -> m c) ? stuck again. I was trying to use return
15:00:56 <crestfallen> to no avail
15:01:45 <lyxia> hseg: https://dpaste.org/BVLu I see newlines here
15:02:16 <koz_> crestfallen: You don't actually need return here.
15:02:21 <koz_> You can implement fish using bind.
15:02:27 <hseg> ... oh wait, maybe the fact that i'm using quickcheck through cabal-test-quickcheck is to blame?
15:02:30 <koz_> (in fact, I encourage you to try exactly that)
15:03:04 <crestfallen> which one is fish though, or which fish? I thought |> was fish, no clue
15:04:36 <dsal> : (>=>)
15:04:40 <koz_> :t (>=>)
15:04:40 <dsal> :t (>=>)
15:04:42 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:04:42 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:04:45 <koz_> Also :t (<=<)
15:04:47 <koz_> They're both fish.
15:05:36 <koz_> Implement whichever directionally-facing fish you want.
15:07:30 <crestfallen> the tutorial says ... "then you know what monads *are*. But what does he mean by that; what is he trying to teach in that exercise?
15:08:02 <crestfallen> I lost the meaning of the exercise
15:08:03 <koz_> crestfallen: My opinion of monad tutorials closely mirrors that of the Typeclassopedia. What exactly is it that you wanna know about them that led you to this tutorial in the first place?
15:10:20 <dsal> : (|>)
15:10:29 <dsal> why do I keep doing that?
15:10:31 <dsal> :t (|>)
15:10:33 <lambdabot> Snoc s s a a => s -> a -> s
15:10:38 <koz_> dsal: Your 't' key is broken.
15:10:48 <dsal> My a key is broken.  Maybe it's contagious.
15:10:48 <koz_> Also, this tutorial defines (|>) to be something else.
15:10:53 <crestfallen> I'm annoyed with myself .. I followed the tutorial to the end and thought I finally understood monads.
15:11:13 <dsal> The thing about operators is that there are many of them and they are useful when you're using them in context, but distracting when you're trying to learn stuff.
15:11:24 <dsal> crestfallen: I learned monads by just using them a bunch.
15:11:50 <koz_> http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
15:11:57 <dsal> There are lots to choose from, too, which is nice.
15:13:02 <crestfallen> but I found the tutorial interesting; but I need help understanding why it leads to knowing "what monads *are* 
15:13:36 <koz_> crestfallen: The 'what monads *ARE*' thing is a bit weird to me. A monad _is_ its exact definition, which in Haskell, is the type class plus its laws.
15:18:21 <crestfallen> koz_, dsal would you explain the reasoning he's using, i.e. what he is trying to teach?
15:18:43 <koz_> crestfallen: I have no idea. I haven't read the tutorial, and to be honest, I'm kinda too busy to.
15:18:53 <dsal> I'm not sure what you're looking at, but in general, I don't understand things that way.
15:18:55 <crestfallen> thanks
15:19:19 <crestfallen> dsal, thanks I'm looking at ..... :
15:19:27 <crestfallen> https://www.schoolofhaskell.com/user/Lkey/kleisli
15:19:40 <dsal> If it's not obvious to me what something is trying to teach, I get what I can and move on.
15:20:15 <dsal> crestfallen: Did you learn anything from thata?
15:20:27 <koz_> And more importantly, _what_?
15:24:46 <Nilgeist> I'm still learning, but when I stopped looking at definitions, and looked at some examples of them in use (starting with the list monad), I found it a bit more 'grounded' in my mind on how they are used as abstractions. Not sure if that's the right way to learn it though.
15:25:24 <dsal> The right way is what works for you.  I try to assemble things and then go back and read the manual.
15:25:24 <hseg> ok, so it's definitely the cabal-test-quickcheck interface that's to blame
15:26:13 <hseg> what easy way is there to wrap up quickcheck properties in a test case runner?
15:26:29 <dsal> I use tasty-quickcheck
15:28:21 <crestfallen> I learned alot from the section where he attempted to lined= up the types, and fmap was needed. then where join was needed where we had m(m c)
15:28:29 <crestfallen> line*
15:29:13 <crestfallen> so I thought with fmap and join, essential we had what is under the hood of bind. is that correct?
15:29:24 <dsal> :t join
15:29:26 <lambdabot> Monad m => m (m a) -> m a
15:29:28 <dsal> @src join
15:29:28 <lambdabot> join x = x >>= id
15:30:45 <Rembane> crestfallen: You can implement fmap and join in terms of bind and errr... the other one and vice versa. 
15:30:56 <Rembane> crestfallen: ...if that's what you mean.
15:31:00 <koz_> hseg: I'm fond of hspec for this.
15:31:27 <crestfallen> @src join
15:31:27 <lambdabot> join x = x >>= id
15:31:31 <dsal> Monad defines >>= -- you don't implement >>= with join, but join is implemented using >>=
15:32:27 <crestfallen> so in m (m a) , which is x there dsal ?
15:32:51 <dsal> :t join
15:32:53 <lambdabot> Monad m => m (m a) -> m a
15:32:56 <ski> `x' has type `m (m a)', in that definition of `join'
15:33:09 <crestfallen> I understand it is flattening
15:33:54 <dsal> in `m (m a)` the that is the x for join.
15:35:55 <ski> `x >>= id' is the same as `x >>= \y -> y'. `y' here would have type `m a'
15:36:13 <dsal> >  let mma = Just (Just 1) in  join mma
15:36:15 <lambdabot>  Just 1
15:36:18 <ski> another way to write it would be `join x = do y <- x; y'
15:37:02 <dsal> >  let mma = Just (Just 1) in    mma >>= \x -> x
15:37:05 <lambdabot>  Just 1
15:37:15 <dsal> >  let mma = Just (Just 1) in   do { x <- mma; x }
15:37:17 <lambdabot>  Just 1
15:37:25 <ski> s/x/ma/
15:37:32 <dsal> I don't know that I've actually used `join` in a program.
15:37:45 <dsal> Oh yeah, ma would be a good name.
15:37:53 <dsal> >  let mma = Just (Just 1) in   do { ma <- mma; ma }
15:37:55 <ski> > let mma = Just (Just 1) in   do {ma <- mma; ma}
15:37:55 <lambdabot>  Just 1
15:37:57 <lambdabot>  Just 1
15:38:02 <ski> > let mma = Just (Just 1) in   do {ma <- mma; a <- ma; return a}
15:38:05 <lambdabot>  Just 1
15:38:48 <crestfallen> one sec pls thanks
15:39:02 <dsal> crestfallen: does any of this make sense?  One thing to consider is you only really need to understand some types and (>>=)
15:39:31 * ski . o O ( "Lively Linear Lisp -- 'Look Ma, No Garbage!'" by Henry G. Baker ion 1992-08 at <http://home.pipeline.com/~hbaker1/LinearLisp.html> )
15:41:34 <koz_> ski: Did they name it L3?
15:42:09 <ski> dunno
15:43:13 <crestfallen> ski you wrote   `x' has type `m (m a)', in that definition of `join'
15:43:41 <ski> yes
15:45:52 <crestfallen> so is id choosing (m a) and not m , so to speak?
15:47:38 <ski> ìd' is being passed the monadic result, having type `m a', resulting from executing the action `x', of type `m (m a)'
15:48:13 <ski> (that's what `>>=', when `x >>= id' is executed (not evaluated))
15:55:28 <crestfallen> ski if you do m (m a) >>= id , how does that do the flattening of m (m a) ?
15:56:21 <solonarv> hseg: you were trying to define some stuff related to ring and their group of units and ran into issues at the intersection of GeneralizedNewtypeDeriving/DerivingVia and type family injectivity, right?
15:57:48 <ski> crestfallen, consider
15:58:08 <ski>   (>>=) :: Monad m => m b -> (b -> m c) -> m c
15:58:56 <ski> if you pass `x', of type `m (m a)', as left operand, that means `m (m a)' must match `m b', that is `b = m a'. so, then you have
15:59:05 <ski>   (>>=) :: Monad m => m (m a) -> (m a -> m c) -> m c
15:59:14 <ski> for that particular use of `>>='
15:59:51 <ski> then, passing `id' as right operand, `m a -> m c' must be equal to the type of `id', say `d -> d'. so `d = m a = m c'. so `a = c'. so we have
15:59:56 <ski>   (>>=) :: Monad m => m (m a) -> (m a -> m a) -> m a
16:00:08 <ski> so, `x >>= id' will have type `m a'
16:01:41 <dsal> :t (>>= id)
16:01:43 <lambdabot> Monad m => m (m b) -> m b
16:02:07 <ski> crestfallen : anyway, that only explains the types
16:03:44 <crestfallen> trying to understand,,, thanks so much ...
16:05:23 <ski> crestfallen : another explanation is that, to execute `act >>= kont', we first execute `act' (of type `m a') (also `kont' has type `a -> m b'), getting a(n intermediate) result, call it `res0', of type `a'. then we execute `kont res', of type `m b', getting a ("final") result, call it `res1' of type `b'. this will be the final result of executing the whole composite `act >>= kont' action
16:06:45 <crestfallen> ski not your last post, but the one above, are you doing type unification there?
16:06:58 <ski> crestfallen : so, if we have `x >>= id', where `x' has type `m (m a)', to execute the whole action, we first execute `x', getting an intermediate result, say `y', of type `m a'. then we execute `id y', that is just `y', of type `m a', getting a "final" result, say `z', of type `a', which is the result of executing the whole thing
16:07:18 <ski> > let x = Just (Just 1) in   do {y <- x; y}
16:07:20 <lambdabot>  Just 1
16:07:26 <ski> > let x = Just (Just 1) in   do {y <- x; z <- y; return z}
16:07:28 <lambdabot>  Just 1
16:07:36 <ski> > let x = Just (Just 1) in   x >>= id
16:07:38 <lambdabot>  Just 1
16:07:44 * hackage nix-derivation 1.1.0 - Parse and render *.drv files  https://hackage.haskell.org/package/nix-derivation-1.1.0 (GabrielGonzalez)
16:07:51 <ski> crestfallen : "are you doing type unification there?" -- yes
16:09:25 <ski> (what "execute" really means, depends on the monad in question)
16:11:10 <crestfallen> ski thanks .. the part where you're doing unification I'm making progress with that. hold on please
16:15:20 <crestfallen> ski dsal thanks so much hacking through that. I do understand the substitutions you're using in unifying types
16:16:02 <ski> good :)
17:45:22 <pie_[bnc]> are there constraint stacks for things other than monads?
17:46:30 <Axman6> monoids perhaps? a tuple of monoidal values is also monoidal, for example
17:46:39 <koz_> Applicatives?
17:46:54 <Axman6> F-F-F-Functors!
17:47:01 <koz_> They compose more easily than monads, so you can get (Applicative f, Applicative g) => Applicative (Compose f g).
17:47:39 <Axman6> as opposed to (Monad f, Monad g) => Maybe (Monad (Compose f g)) :)
17:48:02 <koz_> Axman6: Lol.
17:52:00 <crestfallen> so ski et al , join is being applied in the following with the (<-), right?
17:52:03 <crestfallen> > let x = Just (Just 1) in   do {y <- x; y}
17:52:05 <lambdabot>  Just 1
17:52:56 <Axman6> I can't see any join there
17:53:23 <Axman6> that's the same as let x = Just (Just 1) in x >>= \y -> y
17:53:37 <Axman6> (Which happens to also be the definition of join)
17:54:17 <crestfallen> > :t (>>= id)
17:54:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
17:54:53 <crestfallen> @t (>>= id)
17:54:53 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
17:55:04 <Axman6> :t (>>= id)
17:55:06 <lambdabot> Monad m => m (m b) -> m b
17:55:12 <crestfallen> sorry yeah
17:56:43 <crestfallen> > let x = Just (Just 1) in x >>= id
17:56:45 <lambdabot>  Just 1
17:58:00 <crestfallen> so isn't that equivalent Axman6 to the do notation?
17:58:09 <Axman6> yes
17:58:23 <Axman6> it is exactly the desugaring of tat do notation expression
17:58:27 <Axman6> that*
17:59:53 <crestfallen> earlier member was helping me with this. we were looking at      m (m a) >>= id
18:00:43 <Axman6> :t id `asAppliedTo` (undefined :: Monad m => m (m a)) >>=)
18:00:45 <lambdabot> error: parse error on input ‘)’
18:00:52 <Axman6> :t id `asAppliedTo` ((undefined :: Monad m => m (m a)) >>=)
18:00:54 <lambdabot> Monad m => ((m a -> m b) -> m b) -> (m a -> m b) -> m b
18:01:20 <Axman6> :t id `asAppliedTo` (\id' -> (undefined :: Monad m => m (m a)) >>= id')
18:01:22 <lambdabot> Monad m => ((m a -> m b) -> m b) -> (m a -> m b) -> m b
18:01:29 <Axman6> o.O
18:01:44 <crestfallen> sorry huh?
18:02:05 <Axman6> uh, I have it backwards 
18:02:40 <solonarv> easier with holes
18:03:02 <Axman6> good idea
18:03:10 <crestfallen> lost ya
18:03:17 <solonarv> % :t _k >>= _id
18:03:20 <yahb> solonarv: ; <interactive>:1:1: error:; * Found hole: _k :: m a0; Where: `a0' is an ambiguous type variable; `m' is a rigid type variable bound by; the inferred type of it :: Monad m => m b; at <interactive>:1:1; Or perhaps `_k' is mis-spelled, or not in scope; * In the first argument of `(>>=)', namely `_k'; In the expression: _k >>= _id; * Cons
18:03:30 <solonarv> oops
18:04:13 <solonarv> % :t (undefined :: Monad m => m (m a)) >>= (id :: _)
18:04:13 <yahb> solonarv: ; <interactive>:1:46: error:; * Found type wildcard `_' standing for `a -> a'; Where: `a' is a rigid type variable bound by; the inferred type of <expression> :: a -> a; at <interactive>:1:46; To use the inferred type, enable PartialTypeSignatures; * In an expression type signature: _; In the second argument of `(>>=)', namely `(id :: _)'; In th
18:04:22 <solonarv> ffs
18:04:46 <solonarv> I give up ¯\_(ツ)_/¯
18:05:33 <monochrom> This is a cluster-facepalm.
18:05:54 <Axman6> :t ($ id) `asAppliedTo` (\id' -> (undefined :: Monad m => m (m a)) >>= id')
18:05:55 <lambdabot> Monad m => ((m b -> m b) -> m b) -> m b
18:06:03 <Axman6> so clear...
18:06:05 <crestfallen> http://ix.io/2jQU  if I may ask it differently. I essentially understand this paste, with the unification. but I'm trying to get more insight into monad with this exercise. any hints appreciated.
18:06:19 <MarcelineVQ> :t (=<<) `asAppliedTo` id -- you boys
18:06:21 <lambdabot> Monad m => (m b -> m b) -> m (m b) -> m b
18:07:14 <solonarv> oh, that's better
18:07:36 <MarcelineVQ> crestfallen: you need to include a question in your questions
18:07:44 <solonarv> @let let { asUsedIn :: a -> (a -> b) -> a; asUsedIn = const }
18:07:45 <lambdabot>  Parse failed: Parse error: EOF
18:07:48 <crestfallen> oh no
18:07:55 <solonarv> wtf!
18:08:03 <solonarv> @let asUsedIn :: a -> (a -> b) -> a; asUsedIn = const
18:08:04 <lambdabot>  Defined.
18:08:06 <Axman6> too much let
18:08:12 <MarcelineVQ> let us pray
18:08:20 <Axman6> lettus spray
18:08:24 <solonarv> :t id `asUsedIn` (=<<)
18:08:26 <MarcelineVQ> blessrng
18:08:26 <lambdabot> Monad m => m b -> m b
18:08:31 <solonarv> success!
18:08:46 <MarcelineVQ> solonarv: what are you doing
18:08:58 <crestfallen> ??
18:09:29 <Axman6> ? does not a question make
18:10:53 <crestfallen> join is what takes m(m a) and I guess a chain of those like m (m (m a)  etc and flattens them to give bind's return value, right?
18:11:07 <Axman6> crestfallen: I can't see in that paste what you don't understand, it looks like you have it all figured out
18:11:24 <solonarv> MarcelineVQ: honestly, I'm not even sure anymore
18:11:28 <crestfallen> I certainly like that paste
18:13:11 <crestfallen> Axman6, when it gets down to the last 2 let statements, their relationship is foggy. how they are equivalent
18:13:51 <crestfallen> or the first 3 let statements related to the last one
18:15:47 <Axman6> it's a monad law that ma >>= return === ma
18:16:58 <solonarv> or in do notation, 'y <- x; return y' is the same as 'x'
18:17:19 <crestfallen> hmm
18:18:33 <crestfallen> Axman6, do you mean m(m a) >>= return === m a   ?
18:19:10 <Axman6> no, based on what I said, m (m a) >>= return === m (m a)
18:19:39 <crestfallen> ok thanks working..
18:28:29 <solonarv> % :set -XPartialTypeSignatures
18:28:29 <yahb> solonarv: 
18:28:43 <crestfallen> sorry yes Axman6 ma is just the entire argument right? return is the unit value..
18:28:43 <solonarv> % :t (undefined :: _m (_m _a)) >>= return
18:28:44 <yahb> solonarv: Monad m => m (m _a)
18:28:51 <solonarv> haha, it worked!
18:30:06 <crestfallen> no sorry I don't think return is the unit value
18:41:58 <crestfallen> > let x = Just (Just 1) in do {y <- x; z <- y; return z}  -- so here, which action is taking (Just 1) out of the nested Just (Just 1)   ?
18:42:00 <lambdabot>  Just 1
18:43:18 <solonarv> the first statement, 'y <- x'
18:43:23 <solonarv> (y is 'Just 1')
18:44:28 <crestfallen> thanks solonarv that mechanism is confusing me a bit. is it the same as (>>= id) essentially?
18:45:19 <solonarv> no. let's start by desugaring that do block:
18:45:28 <solonarv> @undo do { y <- x; z <- y; return z }
18:45:29 <lambdabot> x >>= \ y -> y >>= \ z -> return z
18:46:42 <solonarv> so, because we know what 'x' is (and we know which Monad instance is being used), we can figure out that the '\ y -> ...' function will be called once, with an argument 'Just 1'
18:46:50 <solonarv> so in the body, y will be 'Just 1'
18:49:09 <crestfallen> so in the earlier case, x = m(m a)
18:49:36 <crestfallen> correct?
18:51:40 <solonarv> no, but x :: m (m a) is correct
18:52:06 <solonarv> it's best to be careful about what's a type and what's a value, that tends to prevent confusion later on
18:52:55 <crestfallen> ok yeah one sec
18:54:00 <crestfallen> so with Just (Just 1)  ..
18:57:32 <crestfallen> so solonarv in some respect (>>= id) is being used in the do notation, to pull (Just 1) out from Just (Just 1) ..
18:58:15 <solonarv> only in the sense that you can define (>>=) using (>>= id)
18:59:31 <crestfallen> you nailed it! excellent thanks got it solonarv
18:59:51 <koz_> Also solonarv - it seems your argument was not persuasive to the Streamly maintainer, sads.
19:04:56 <crestfallen> solonarv, so when ghc sees the Just (Just 1), it opts to interpret it with ((>>=) id) ; ghc does the unification to accommodate the type m(m a)     correct?
19:07:37 <dsal> crestfallen: I've not been following the thread much, but you seem to imply that `join` is some kind of fundamental.  It's just a library function.
19:10:44 <dsal> % :i Monad
19:10:44 <yahb> dsal: type Monad :: (* -> *) -> Constraint; class Applicative m => Monad m where; (>>=) :: m a -> (a -> m b) -> m b; (>>) :: m a -> m b -> m b; return :: a -> m a; {-# MINIMAL (>>=) #-}; -- Defined in `GHC.Base'; instance [safe] Monad Q.Gen -- Defined in `Test.QuickCheck.Gen'; instance Monad STM -- Defined in `GHC.Conc.Sync'; instance [safe] forall k (r :: k) (m :: k -> *). Monad (ContT r m) -- Define
19:11:16 <dsal> Oh, I was mildly confused for a moment as to why minimal is (>>=)
19:15:06 <crestfallen> dsal what I understand is that join is what removes the outer m in m (m a), so if you're chaining (>>=)'s , it gets rid of redundancies.
19:16:25 <dsal> But it's just a library function.  It's not part of the definition of Monad and you don't need it at all.  i.e., you might have an easier time ignoring that it exists.
19:16:32 <crestfallen> so {y <- x);y  must do that if the result of the actions is m(m a)
19:16:52 <dsal> Or you could just not write that code to begin with.
19:17:07 <crestfallen> not write that code?
19:17:19 <monochrom> Don't use do-notation. Use >>=
19:18:06 <crestfallen> monochrom, it's an exercise: http://ix.io/2jQU
19:18:48 <dsal> It looks like it's teaching you how to make join.
19:20:58 <dsal> I've got about 15k lines of haskell in projects I've been working on recently...  I've not used join in any of it because if I see myself having a  `m (m a)` I back up a bit and try to avoid making that.
19:21:49 <monochrom> I have used join intentionally. It was really cute.
19:23:07 <crestfallen> dsal, it started here if you hadn't seen this:  https://www.schoolofhaskell.com/user/Lkey/kleisli
19:23:07 <monochrom> join (atomically ( (foo >> return (print x)) `orElse` (bar >> return (print y)) ) )
19:23:45 * hackage purebred-email 0.4.1 - types and parser for email messages (including MIME)  https://hackage.haskell.org/package/purebred-email-0.4.1 (frasertweedale)
19:23:48 <monochrom> (In reality, replace "print x" and "print y" by another pair of IO actions different enough that there is no better way to factor out.)
19:24:27 <monochrom> However!  That's basically my use case of join.  It is rare.
19:25:02 <dsal> crestfallen: Yeah, I think I'd rather just avoid building up such a thing than to think about what to do once you get there.
19:25:46 <dsal> Like, how'd you end up with a `Maybe (Maybe Bool)`?
19:26:11 <koz_> dsal: A lookup into a Map full of Maybes?
19:26:34 <dsal> We have known knowns, known unknowns, etc...
19:26:42 <koz_> Something something Dick Cheney.
19:27:05 <koz_> More weird is like, Either e (Either e a)
19:27:08 <monochrom> If you really need Map K (Maybe X), I doubt that your intention is to just use join on lookup results.
19:27:16 <koz_> monochrom: Indeed.
19:27:41 <dsal> It's too hypothetical for me.  I figured I'd just use `findWithDefault` in that case.
19:27:53 <dsal> (since that's often what I use anyway)
19:28:05 <dsal> But it is a thing that'd do it without being excessively weird.  heh
19:29:06 <crestfallen> ok thanks well I'm getting better intuition for Monad, I believe. really appreciate it
19:29:16 * dsal forgot to count test/ -- closer to 30k lines
19:29:59 <dsal> I thought that for a bit, and I still write code and occasionally something becomes real that should've been super obvious and I knew all along.
19:30:38 <crestfallen> dsal its that part where bartosz calls it "smashing doubles." it was informative
19:30:44 <dsal> e.g., the Maybe monad is a basic one I learned about long ago, but it always just seemed like a hypothetical abstraction until that one day I was like, "I'll just use a maybe monad here"  That's just the next level of understanding.
19:31:10 <dsal> "smashing doubles" is fine and all, but in practice, I just don't make doubles.
19:33:23 <crestfallen> the way he lines up the types, where they don't line up, it was helpful. but one last thing, if you DO end up with m (m a) , would the interpreter use (>>= id) instead of plain >>=  ?  dsal 
19:35:07 <dsal> I don't understand.  If you did end up with it, you'd ask why you ended up with it and kill baby hitler.
19:35:59 <crestfallen> pardon?
19:37:59 <dsal> I don't know what "the interpreter" is here, or why we have this case.
19:39:17 <crestfallen> thanks I need to bail. appreciate it dsal take it easy
19:39:30 <dsal> Happy bailing.
19:57:15 * hackage dbus 1.2.14 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.14 (blaze)
20:26:09 <User160> Hello, I am new to programming. I came across this website on the Haskell main page. Looking for some advice for someone new that has never programmed before
20:28:15 * hackage jose 0.8.2.1 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.8.2.1 (frasertweedale)
20:41:43 <dsal> @advise User160 to expect humans to be slower than computers on average at responding.
20:41:44 <lambdabot> Unknown command, try @list
20:55:44 * hackage dom-events 0.0.0.0 - DOM Events expressed as Haskell types  https://hackage.haskell.org/package/dom-events-0.0.0.0 (mikesol)
22:08:44 * hackage prim 0.1.0.7 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.7 (dailectic)
22:21:15 * hackage prim 0.1.0.8 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.8 (dailectic)
22:28:58 <jchia> In some software that I'm running that I didn't write, a function foo is suspected of being called with inappropropriate arguments (a wrong path is given). There is a function bar that calls foo indirectly. (There's a function call chain from bar to foo that I'm not tracing by poring over the source code.) To help me debug, is there an easy way to dump the call stack with arguments to help me trace where the inappropriate argument first
22:28:58 <jchia>  appeared, like what I might do using gdb on a C++ program? If not, what simple thing could I do to debug?
22:30:54 <jchia> Concretely, hie is calling something in GHC and I suspect GHC is running gcc with a wrong path for one of the input files.
