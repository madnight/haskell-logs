00:01:10 <Axman6> how is that not a thing
00:01:50 <mniip> :t alaf Ap foldMap
00:01:52 <lambdabot> forall k2 (t :: * -> *) (g :: k2 -> *) (b :: k2) a. (Foldable t, Monoid (Ap g b)) => (a -> g b) -> t a -> g b
00:02:18 <mniip> (Applicative f, Monoid a) => Monoid (Ap f a)
00:02:23 <mniip> not sure why that constraint is not reducing
00:02:50 <mniip> ah
00:02:53 <mniip> because polykinded
00:08:01 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:08:01 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
00:09:54 <hseg> ghc complains Class ‘Coercible’ does not support user-specified instances
00:09:55 <koz_> hseg: Yes, and that's for good reason.
00:09:55 <koz_> Coercible can only be inferred in specific situations.
00:09:55 <koz_> (newtypes being one)
00:10:39 <hseg> ah. so i need to eg export the constructor, not the instance
00:12:52 <hseg> ... problem is that i want to declare newtype instance U (P a) = UP a in one module and then be able to coerce a -> U (P a) in a different module
00:12:57 <Axman6> yeah the Coercible instance is only visible if you could construct the value using its constructor
00:13:24 <hseg> not clear how to do that
00:13:25 <Axman6> stops you getting a back door into a type which has a newtype to maintain some invariant
00:13:55 <hseg> right
00:14:36 <Axman6> newtype NonEmptyText = NET Text; coerce @Text @NonEmptyText "" would be bad
00:15:07 <hseg> right
00:15:51 <Axman6> (though that exact code would probably work, but imagine the coerce was in another module and NET wasn't exported)
00:17:45 <hseg> problem is i have a situation class C a where { injU :: U a -> a; assU :: a -> Maybe (U a); } for U a data family. Have newtype instance U (W a), instance C (W a), instance U T, and want to derive instance C T via (W T)
00:18:12 <hseg> and ghc complains it can't coerce T -> U (W T)
00:19:05 <mniip> newtype NonEmptyText = NonEmptyText (# Char#, Text #)
00:19:06 <mniip> :P
00:19:34 <hseg> :)
00:20:22 <hseg> so basically need to export the data family instance *with its constructor*
00:21:47 <hseg> ah: https://stackoverflow.com/q/19089039
00:26:47 <hseg> Success! q: any nice way of cutting http://ix.io/2jiW down further?
00:34:27 <hseg> different line of refactoring: how do i give my quickcheck property custom output for success/failure?
00:34:59 <hseg> i see i can construct Result values, but don't see simple constructors for it
00:35:37 <hseg> (a lot of the parameters i don't think i should even have to know how to construct
00:36:06 <koz_> http://hackage.haskell.org/package/QuickCheck-2.14/docs/Test-QuickCheck.html#v:counterexample <-- that kinda lets you customize failure
00:37:03 <hseg> ok, looks good enough
00:37:15 * hackage push-notify-apn 0.2.0.1 - Send push notifications to mobile iOS devices  https://hackage.haskell.org/package/push-notify-apn-0.2.0.1 (hc)
00:39:44 <hseg> hrm - unclear how to use it. basically want to test whether the result of a function satisfies a predicate, and have a pretty version of the result printed on failure
00:41:07 <hseg> so i have my result :: a, predicate a -> Bool and pretty-printer a -> String, how do I combine them into a prop for Testable prop ?
00:42:17 <vilpan> hi guys, I'm trying to get the basics right and something caught my attention: what does the author mean by "note the point-free notation there" in https://stackoverflow.com/questions/6824255/whats-the-point-of-map-in-haskell-when-there-is-fmap/45289276#45289276 ? I would think point-free style would be `fmap = map` in that case.
01:06:46 <hseg> v
01:10:50 <mniip> % System.Info.compilerVersion
01:10:50 <yahb> mniip: Version {versionBranch = [8,10], versionTags = []}
01:10:54 <mniip> new GHC \o/
01:11:02 <mniip> also now we have :doc for everything
01:11:47 <hseg> neat
01:15:13 <cdunklau> .win 16
01:16:44 * hackage ghc-check 0.2.0.0 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.2.0.0 (PepeIborra)
01:18:22 <koz_> hseg: There is a forAllShow that might work?
01:20:12 <hseg> i think what i want is to replace forAll p by forAll $ \x -> counterexample (pretty x) (p x)
01:22:23 <koz_> hseg: Yep, and you can use forAllShow, because it lets you pass your own a -> String.
01:23:00 <hseg> ooh, nice
01:23:52 <hseg> so here would be forAllShow gen (pretty . f) (p .f) ?
01:24:07 <hseg> (if i wanted to test the result of f)
01:24:51 <koz_> I guess?
01:52:15 * hackage cache-polysemy 0.1.2 - cached hashmaps  https://hackage.haskell.org/package/cache-polysemy-0.1.2 (Poscat)
01:53:18 <__monty__> Hmm, not the clearest name for a package of hashmaps.
02:00:37 <phadej> nope
02:02:05 <phadej> or rather the synopsis is not that good
02:03:49 <sheepfleece> Hello, how can I store ByteString in a persistent table. It screams at me that there is no instance for FromJSON when I try to generate a table with a ByteString field.
02:04:50 <sheepfleece> I think I can encode everything in Base64 or something and store it as a Text, but that sound awful.
02:05:02 <sheepfleece> *sounds
02:05:17 <[exa]> sheepfleece: you probably want to encode it with UTF8
02:05:27 <merijn> You can't store ByteString in JSON
02:05:40 <merijn> JSON is, per the RFC, unicode text
02:06:00 <sheepfleece> I want to store binary data there. And I don't really need JSON! TH is generating it for some reason.
02:06:06 <merijn> So yeah, Base64 is the only correct option if you need to transmit arbitrary ByteString via JSON
02:06:41 <sheepfleece> Oh, I see. I won't use Persistent then. 
02:06:46 <[exa]> sheepfleece: what's the wider context then? (TH suddenly :] )
02:06:48 <merijn> oh, you're probably using the wrong TH function then?
02:06:58 <merijn> I'm storing ByteString in persistent data just fine
02:07:10 <merijn> Granted, I would probably still recommend not using persistent >.>
02:07:24 <sheepfleece> I'm using `share` with classy-prelude-yesod
02:07:28 <sheepfleece> Why? 
02:08:43 <merijn> The available API is rather limited compared to just SQL and I think that, in hindsight, a lot of my project would've been easier if I'd just used one of the sqlite-simple/postgres-simple/etc. libraries and written the SQL myself
02:08:52 <sheepfleece> My code pretty much looks like the first example here but with a ByteString field. https://www.yesodweb.com/book/persistent
02:09:45 <sheepfleece> Oh, I see, thank you. I think I'll do it this way then. I actually already use sqlite-simple, I just wanted to try out alternatives.
02:13:05 <merijn> It feels like saving a lot of time when you create the initial schema, but if you (inevitably) want doing custom SQL stuff it's tricky to fit that into persistent
02:40:45 * hackage ghc-heap-view 0.6.2 - Extract the heap representation of Haskell values and thunks  https://hackage.haskell.org/package/ghc-heap-view-0.6.2 (JoachimBreitner)
02:43:11 <tdammers> personally, I think that persistent's paradigm is at odds with relational thinking
03:02:45 * hackage haskoin-store 0.22.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.22.2 (jprupp)
03:22:11 <nerdypepper> what does the fmap of the Functor instance of Data.Map look like? i have looked here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.14.0.0/src/GHC-Base.html#fmap but i cant seem to find it
03:22:36 <Tuplanolla> It's in the `containers` package, nerdypepper.
03:22:57 <nerdypepper> i see, thanks Tuplanolla!
03:23:03 <Tuplanolla> You'll most likely find a derived sized tree traversal.
03:41:45 * hackage openapi-typed 0.0.0.0 - Types for OpenAPI  https://hackage.haskell.org/package/openapi-typed-0.0.0.0 (mikesol)
03:51:14 * hackage openapi-typed 0.0.0.1 - Types for OpenAPI  https://hackage.haskell.org/package/openapi-typed-0.0.0.1 (mikesol)
04:02:41 <Piedro> Hello, fellow haskellers!
04:04:00 <Piedro> Is there a way in haskell to unescape utf-8 text from strings like "\uXXXX\uXXXX\uXXXX \uXXXX\uXXXX \uXXXX\uXXXX\uXXXX"?
04:06:31 <hpc> Piedro: you're using show?
04:12:54 <pingiun> I know that Haskell has a lot of possibilities to extend the language, but would it be possible to change the syntax for type declarations? like could I have anInt : Int instead of ::?
04:13:36 <pingiun> probably not right?
04:14:06 <Uniaika> pingiun: that's a change in the parser
04:14:17 <Uniaika> I think other GHC extensions implement parser changes
04:14:24 <Uniaika> so uh, yeah I think it should be possible?
04:14:31 <pingiun> so a new GHC extension could do it? interesting
04:14:44 <pingiun> I was just thinking about switching around : and ::, like Elm
04:20:03 <merijn> pingiun: new GHC extensions can theoretically do anything you can imagine
04:20:17 <merijn> Realistically, such an extension will never make it in GHC
04:22:41 <pingiun> merijn: are GHC extensions just part of the compiler or can they be inserted dynamically?
04:22:52 <pingiun> I know very little about the compiler implementation
04:23:15 <merijn> There are plugins, that you can load dynamically, but they can't affect parsing, afaik
04:23:26 <merijn> extensions are just compiler options
04:25:01 <pingiun> makes sense, thanks
04:42:16 <tdammers> yeah, the name "extension" refers to them extending the language, not the compiler
04:42:25 <tdammers> as far as the compiler is concerned, they're just flags
05:06:15 * hackage ghc-check 0.3.0.0 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.3.0.0 (PepeIborra)
05:55:26 <sheepfleece> Where can I find the smallest working example with a monad transformer? For now I just want to add Reader environment to a ScottyT, but I'm hopelessly lost.
05:56:45 <sheepfleece> I'm also not sure how should I derive MonadReader from my newtype. It seems I need to use mtl, not transformers for that. 
05:57:27 <Axman6> yes, MonadReader comes from mtl
05:59:46 <merijn> sheepfleece: MonadReader is a typeclass that tries to capture "the reader API", whereas ReaderT is the actual transformer
06:00:06 <merijn> You can implement MonadReader without using a transformer at all
06:00:43 <sheepfleece> Yes, I know, but I want to do it with a Reader.
06:01:17 <sheepfleece> So I guess I need both? mtl to derive Reader instance and transformers to work with it? 
06:01:32 <merijn> mtl re-exports most/all of transformers
06:03:08 <sheepfleece> I tried to write something like this https://paste.debian.net/hidden/bc0fab3c/ but even this doesn't work.
06:03:30 <sheepfleece> First there are two ask functions, and if I hide either one I still get an error.
06:05:22 <sheepfleece> Ah, it works if I use Control.Monad.Reader sans Trans.
06:05:25 <Axman6> you should only need the first import I think
06:05:51 <Axman6> I don't think I've imported anything firectly from transformers for a long time
06:05:52 <sheepfleece> what is a relationship between mtl and transformers? Which one should I use? Or both? 
06:05:54 <Axman6> directly*
06:06:29 <Axman6> mtl extends transformers with the mtl-style typeclasses - MonadReader, MonadState etc all come from mtl
06:06:48 <Axman6> and its modules IIRC export all the necessary things from transformers
06:07:15 <sheepfleece> I see, thank you. That means I don't need to use transformers at all then.
06:07:25 <Axman6> probably not, no
06:09:22 <sheepfleece> How can I embed my stack into ScottyT transformer now?
06:12:03 <tdammers> ScottyT takes a "transformee" argument, m
06:12:08 <tdammers> this is where your stack goes
06:12:12 <Axman6> I've never used Scotty, but it looks like you make your actions run ActionT e App
06:12:25 <tdammers> and that same m argument also goes in ActionT
06:12:55 <tdammers> oh, and in case this isn't obvious, that stack needs to have IO at the bottom, because most of Scotty wants MonadIO
06:13:07 <sheepfleece> https://paste.debian.net/1142766/ that is the way I did it, however ghc screams at me that there is no reader instance.
06:13:15 <sheepfleece> I guess I should use lift?
06:13:26 <Axman6> ActionT doesn't have instances for MonadReader m => MonadReader (ActionT e m) sadly, so you'll need to use lift ask
06:13:27 <sheepfleece> Nope, it didn't work either.
06:13:58 <Axman6> what does ghc say whe you use lift ask?
06:14:05 <sheepfleece> Now it says there is no instance for MonadTrans for ScottyT, that's strange.
06:14:41 <Axman6> I'm pretty sure you should be using ActionT not ScottyT
06:15:03 <Axman6> notice get's type: get :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()
06:15:40 <sheepfleece> Yes, but I want to get this RoutePattern from a config.
06:15:58 <Axman6> so your app will look something like: get "/foo" $ do {env <- lift ask; liftIO $ print env; }
06:16:19 <Axman6> I don't think that's going to work
06:17:11 <sheepfleece> Oh, okay, I'll just hardcode it in there. Should work at least for now!
06:17:29 <Axman6> I think you'll need a static RoutePattern and use param to get the value that's in the path
06:17:44 <Axman6> see the addroute example https://hackage.haskell.org/package/scotty-0.11.5/docs/Web-Scotty-Trans.html#v:addroute
06:17:45 * hackage recursion-schemes-ix 0.1.0.0 - Recursion schemes over indexed Functors  https://hackage.haskell.org/package/recursion-schemes-ix-0.1.0.0 (SkyeSoss)
06:19:37 <sheepfleece> Oh, now it is not exactly what I want, I just want to be able to configure static routes from a config file, something akin to what XMonad does. 
06:21:21 <Axman6> you can generate a ScottyT at runtime, but you won't be able to do it be reading from the Reader your app is running in. you just need a function which has type Config -> ScottyT e App ()
06:22:24 <sheepfleece> I see, this should work. Thank you.
06:28:09 <amf> any good libraries that can show the differences in data structure values? something like `let a = X 1 "x"; let b = X 2 "x"; diff a b`
06:28:36 <amf> i could probably do it myself if i knew how to arbitarily traverse data structures, so i guess thats my second question :)
06:28:51 <Axman6> something definitely exists
06:32:22 <Axman6> jackdk: if you're around, does semialign do some kind of data structure diff?
06:32:49 <Axman6> looks like https://hackage.haskell.org/package/semialign-extras-0.1.0.0/docs/Data-Semialign-Diff.html does...
06:36:31 <Axman6> amf: https://hackage.haskell.org/package/gdiff-1.1 also exists, from 2014
06:37:09 <amf> Axman6: wow, these look pretty good
06:37:45 <Axman6> ... looks like a lot of work to use :)
06:39:03 <Axman6> but relatively mechanical
06:40:14 <amf> yeah may use these as "extra credit" for my work project. trying to show them theres a better world outside of python
07:09:35 <hseg> how would you cleanly write [(a,b)] -> [([a],b)] (grouping by equal snd 's)
07:10:31 <Axman6> :t groupBy snd
07:10:32 <lambdabot> error:
07:10:32 <lambdabot>     • Occurs check: cannot construct the infinite type:
07:10:32 <lambdabot>         a ~ (a0, a -> Bool)
07:10:41 <Axman6> :t groupBy
07:10:43 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:10:58 <Axman6> :t groupBy ((==) `on` snd)
07:10:59 <hseg> :t groupBy ((==) `on` snd)
07:10:59 <lambdabot> Eq a1 => [(a2, a1)] -> [[(a2, a1)]]
07:11:00 <lambdabot> Eq a1 => [(a2, a1)] -> [[(a2, a1)]]
07:11:41 <hseg> which doesn't make use of the fact that the snd's are constant
07:11:47 <Axman6> :t (map fst &&& head . map snd)
07:11:48 <lambdabot> [(b1, b2)] -> ([b1], b2)
07:11:58 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
07:12:00 <lambdabot>  Defined.
07:12:16 <ski> @type map (map fst &&& snd . head) . groupBy (equating snd)
07:12:17 <lambdabot> Eq b => [(a, b)] -> [([a], b)]
07:12:21 <Axman6> :t map (map fst &&& head . map snd) . groupBy (equating snd)
07:12:23 <lambdabot> Eq b => [(a, b)] -> [([a], b)]
07:12:32 <Axman6> I'm going to call that a team effort
07:12:37 <hseg> ... ok, that *works*
07:12:48 <hseg> not really elegant, though, is it?
07:12:51 <Axman6> but also, keep in mind that that will only group consequtive b's
07:13:28 <hseg> ok, can slap a sortBy (equating snd) there
07:13:39 <Axman6> well, the usual convention would be to have the 'key' as the first argument, if you do that and you can use ORd then you can easily use Data.Map and fromListWith
07:14:36 <hseg> can do that
07:14:42 <Axman6> :t Map.fromListWith (++)
07:14:44 <lambdabot> error:
07:14:44 <lambdabot>     Not in scope: ‘Map.fromListWith’
07:14:44 <lambdabot>     Perhaps you meant one of these:
07:14:48 <Axman6> :t M.fromListWith (++)
07:14:50 <lambdabot> Ord k => [(k, [a])] -> M.Map k [a]
07:15:42 <hseg> so i'd want sth like
07:16:05 <hseg> :t M.fromListWith (++) . map (second (:[]) . flip)
07:16:07 <lambdabot> error:
07:16:07 <lambdabot>     • Couldn't match type ‘(k, a1)’ with ‘b -> a -> c’
07:16:07 <lambdabot>       Expected type: (b -> a -> c) -> (k, [a1])
07:16:27 <hseg> ...
07:16:33 <hseg> :t M.fromListWith (++) . map (second (:[]) . \(x,y) -> (y,x))
07:16:35 <lambdabot> Ord a => [(b, a)] -> M.Map a [b]
07:16:56 <hseg> :t M.toList . M.fromListWith (++) . map (second (:[]) . \(x,y) -> (y,x))
07:16:57 <lambdabot> Ord a => [(b, a)] -> [(a, [b])]
07:17:18 <Axman6> there's also probably a cool way to do it with SQL style list comprehensions
07:17:27 <hseg> :t map (\(x,y) -> (y,x)) . M.toList . M.fromListWith (++) . map (second (:[]) . \(x,y) -> (y,x))
07:17:30 <lambdabot> Ord a => [(b, a)] -> [([b], a)]
07:17:35 <hseg> ok, sure
07:17:54 <Axman6> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-sql-like-list-comprehensions
07:18:05 <hseg> though there should be some monoid underlying this, unless i'm mistaken
07:19:07 <hseg> knew i had this problem before!
07:19:22 <hseg> :t NE.groupBy (equating snd)
07:19:23 <lambdabot> error:
07:19:24 <lambdabot>     Not in scope: ‘NE.groupBy’
07:19:24 <lambdabot>     Perhaps you meant one of these:
07:19:40 <hseg> :t Data.List.NonEmpty.groupBy (equating snd)
07:19:42 <lambdabot> (Foldable f, Eq b) => f (a, b) -> [GHC.Base.NonEmpty (a, b)]
07:20:11 <Axman6> for extra fun, have alook at Ed Kmett's discrimination package - I can do solve this problem in O(n) time
07:20:25 <Axman6> with full laziness
07:20:47 <hseg> :t coerce . fold1 @NonEmpty @(Const [], Data.Semigroup.First) . Data.List.NonEmpty.groupBy (equating snd)
07:20:49 <lambdabot> error: parse error on input ‘@’
07:20:56 <hseg> :(
07:21:19 <Axman6> %  :t coerce . fold1 @NonEmpty @(Const [], Data.Semigroup.First) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:21:19 <yahb> Axman6: ; <interactive>:1:17: error:; Not in scope: type constructor or class `NonEmpty'; Perhaps you meant `NonEmptyF' (imported from Data.Functor.Base)
07:21:36 <Axman6> %  :t coerce . fold1 @Data.List.NonEmpty.NonEmpty @(Const [], Data.Semigroup.First) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:21:36 <yahb> Axman6: ; <interactive>:1:10: error:; * Variable not in scope: fold1; * Perhaps you meant one of these: `S.foldr' (imported from Data.Set), `IS.foldr' (imported from Data.IntSet), `foldr' (imported from Prelude)
07:22:30 <hseg> %  :t coerce . Data.Semigroup.Foldable.fold1 @Data.List.NonEmpty.NonEmpty @(Const [], Data.Semigroup.First) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:22:31 <yahb> hseg: ; <interactive>:1:71: error:; * Expecting one more argument to `Const []'; Expected a type, but `Const []' has kind `k0 -> *'; * In the type `(Const [], Data.Semigroup.First)'; In the first argument of `(.)', namely `Data.Semigroup.Foldable.Class.fold1 @GHC.Base.NonEmpty @(Const [], Data.Semigroup.First)'; In the second argument of `(.)', namely `Data.Semigroup.Foldable.Class.f
07:23:12 <hseg> %  :t coerce . Data.Semigroup.Foldable.fold1 @Data.List.NonEmpty.NonEmpty @(Const [] (), Data.Semigroup.First) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:23:13 <yahb> hseg: ; <interactive>:1:77: error:; * Expecting one more argument to `[]'; Expected a type, but `[]' has kind `* -> *'; * In the first argument of `Const', namely `[]'; In the type `(Const [] (), Data.Semigroup.First)'; In the first argument of `(.)', namely `Data.Semigroup.Foldable.Class.fold1 @GHC.Base.NonEmpty @(Const [] (), Data.Semigroup.First)'; <interactive>:1:84: error:; *
07:23:26 <hseg> %  :t coerce . Data.Semigroup.Foldable.fold1 @Data.List.NonEmpty.NonEmpty @(Const [a] (), Data.Semigroup.First) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:23:26 <yahb> hseg: ; <interactive>:1:78: error: Not in scope: type variable `a'
07:23:33 <hseg> %  :t coerce . Data.Semigroup.Foldable.fold1 @Data.List.NonEmpty.NonEmpty @(Const [Int] (), Data.Semigroup.First) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:23:33 <yahb> hseg: ; <interactive>:1:87: error:; * Expecting one more argument to `Data.Semigroup.First'; Expected a type, but `Data.Semigroup.First' has kind `* -> *'; * In the type `(Const [Int] (), Data.Semigroup.First)'; In the first argument of `(.)', namely `Data.Semigroup.Foldable.Class.fold1 @GHC.Base.NonEmpty @(Const [Int] (), Data.Semigroup.First)'; In the second argument of `(.)', name
07:23:41 <hseg> %  :t coerce . Data.Semigroup.Foldable.fold1 @Data.List.NonEmpty.NonEmpty @(Const [Int] (), Data.Semigroup.First Char) . Data.List.NonEmpty.groupBy ((==) `on` snd)
07:23:42 <yahb> hseg: ; <interactive>:1:116: error:; * Couldn't match type `[GHC.Base.NonEmpty (a, a1)]' with `GHC.Base.NonEmpty (Const [Int] (), Data.Semigroup.First Char)'; Expected type: f (a, a1) -> GHC.Base.NonEmpty (Const [Int] (), Data.Semigroup.First Char); Actual type: f (a, a1) -> [GHC.Base.NonEmpty (a, a1)]; * In the second argument of `(.)', namely `Data.List.NonEmpty.groupBy ((==) `on` snd
07:24:00 <oats> uhhhh
07:24:06 <oats> wanna take that to a private repl? :P
07:24:14 <hseg> ... sorry, you're right
07:24:24 <oats> lol cheers
07:24:27 <hseg> but this is definitely the approach i'm taking
07:25:56 <ski> % let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
07:25:57 <yahb> ski: 
07:26:03 <ski> % :set -XTransformListComp
07:26:03 <yahb> ski: 
07:26:14 <ski> % :t \xys -> [(x,head y) | (x,y) <- xys, then group by y using groupBy . equating]
07:26:15 <yahb> ski: Eq b => [(a, b)] -> [([a], b)]
07:26:24 <ski> % import GHC.Exts (the,groupWith)
07:26:24 <yahb> ski: 
07:26:31 <ski> % :t \xys -> [(x,the y) | (x,y) <- xys, then group by y using groupWith]
07:26:31 <yahb> ski: Ord b => [(a, b)] -> [([a], b)]
07:27:10 <Axman6> definitely look at discrimination though, it's mindblowing - it boils down to a function [(a,b)] -> [[b]] - where each b in a list had the same a. btu the amazing thing is if you just pick one of those lists, its values will be lazily produced as the whole input list is processed. means you can have productive parallelism over the [[b]]
07:27:21 <ski> hseg : `groupWith' sorts
07:27:49 <hseg> ski: wait wait what's that?
07:27:52 <ski> Axman6 ^
07:27:55 <hseg> Axman6: nice
07:28:14 <Axman6> that's the SQL style list comprehensions
07:28:14 * ski thinks the `the' thing is a bit silly ..
07:28:41 <ski> % :t groupBy . equating
07:28:42 <yahb> ski: Eq b => (a -> b) -> [a] -> [[a]]
07:28:45 <ski> % :t groupWith
07:28:45 <yahb> ski: Ord b => (a -> b) -> [a] -> [[a]]
07:28:48 <ski> % :t the
07:28:48 <yahb> ski: Eq a => [a] -> a
07:30:17 <ski> @hackage discrimination
07:30:18 <lambdabot> http://hackage.haskell.org/package/discrimination
07:30:43 <hseg> which is why i prefer the fold1 @NonEmpty @(First, ...) method
07:35:22 <jchia_> cabal question: There are a few packages that are not very actively maintained on hackage that I'm using in my project by getting the source code from github by specifying source-repository-package. The trouble is that the builds for them are not stored in the global store at ~/.cabal/store. So every time I git clone my project and a clean build of project, these github packages need to be built from scratch along with my project. Is th
07:35:22 <jchia_> ere a trick to avoid having to rebuild them whenever I do a project clean build?
07:37:23 <maerwald> jchia_: I don't know of any
07:37:43 <maerwald> but cabal maintainers are aware of that problem, afaik
07:38:02 <jchia_> OK
07:39:30 <jchia_> Any idea whether NIX builds suffer from the same problem?
07:39:49 <jchia_> Nix
07:41:53 <srk> jchia_: it doesn't. nix will build what's needed and store stuff in /nix/store so it can be reused by other projects
07:41:55 <evelyn> nix won't rebuild dependencies which are already built
07:42:10 <jchia_> How does nix deal with garbage over time?
07:42:24 <evelyn> there are generations, and you can remove generations
07:42:28 <evelyn> (or not)
07:42:29 <jchia_> OK
07:42:34 <srk> not quite, there's nix-collect-garbage 
07:42:46 <evelyn> nix-collect-garbage will remove unused generations and build artifacts
07:42:48 <srk> which can also delete older generations but also all the stuff that's not gc rooted
07:53:26 <sheepfleece> Oh, oh. How can I `try` a monad stack? `try` only works in IO it seems.
07:55:19 <Axman6> Look at MonadThrow and MonadCatch... I can't remember the module they're in
07:56:27 <jchia_> exceptions package
08:02:28 <sheepfleece> Sorry, my modem desided to stop working! I looked into exceptions - I think it should work. Thank you.
08:13:45 * hackage iso-deriving 0.0.8 - Deriving via arbitrary isomorphisms.  https://hackage.haskell.org/package/iso-deriving-0.0.8 (HansHoglund)
08:38:15 <JoeCordingley> hi is there a type class for just mempty, or maybe a type class for an Ord with a minimum value?
08:39:22 <Axman6> well, the Ord instance for Maybe basically does that
08:39:40 <Axman6> > sort [Just 3, Just 2, Nothing, Just 1]
08:39:42 <lambdabot>  [Nothing,Just 1,Just 2,Just 3]
08:43:41 <JoeCordingley> hmm, I think I would need to enable FlexibleInstances then
08:44:25 <JoeCordingley> data MaxBid players bid = MaxBid
08:44:25 <JoeCordingley>   { bid :: bid
08:44:25 <JoeCordingley>   , players :: players
08:44:27 <JoeCordingley>   }
08:44:34 <JoeCordingley> instance (Monoid players, Ord bid) => Monoid (MaxBid players (Maybe bid)) where
08:44:34 <JoeCordingley>   mempty = MaxBid mempty Nothing
08:47:12 <merijn> JoeCordingley: Ord with a minimum value that'd be "Ord a, Bounded a"
08:47:17 <merijn> > minBound :: Int
08:47:20 <lambdabot>  -9223372036854775808
08:47:40 <merijn> JoeCordingley: What would mappend be for that instance?
08:48:07 <JoeCordingley> the semigroup is like this: 
08:48:13 <JoeCordingley> instance (Ord bid, Semigroup players) => Semigroup (MaxBid players bid) where
08:48:13 <JoeCordingley>   MaxBid bidA playersA <> MaxBid bidB playersB = case compare bidA bidB of
08:48:13 <JoeCordingley>     GT -> MaxBid bidA playersA
08:48:15 <JoeCordingley>     LT -> MaxBid bidB playersB
08:48:17 <JoeCordingley>     EQ -> MaxBid bidA (playersA <> playersB)
08:49:06 <JoeCordingley> so if I also want a Monoid for this pattern, I need to provide the zero bid
08:50:09 <JoeCordingley> I could just make my own typeclass
09:01:12 <nowhere_man> I don't understand why a transformation from do notation to point-free doesn't work:
09:01:55 <nowhere_man> I have `elems <- getElems array ; return $ concat $ map reverse elems`
09:02:15 <nowhere_man> I thought I could replace this with `fmap ((map reverse) . concat) $ getElems array`
09:02:35 <merijn> Eh, you want "concat . map reverse" :)
09:02:46 <maerwald> merijn: you were 1.5s faster :(
09:02:56 <merijn> You can clean it up further and write it as "concat . map reverse <$> getElems array"
09:03:06 <merijn> (<$> being infix fmap)
09:03:14 <Axman6> :t foldMap reverse
09:03:16 <lambdabot> Foldable t => t [a] -> [a]
09:03:35 <merijn> Wait
09:03:41 <nowhere_man> *facepalm*
09:03:42 <Axman6> foldMap reverse <$> getElems array
09:03:45 <merijn> "concatMap reverse <$> getElems array" :p
09:04:01 <merijn> Axman6: Mine is more intuitively named ;)
09:04:13 <Axman6> why that's just (reverse =<<) <$> getElems array!
09:04:43 <maerwald> let the golfing begin... until you wish it was still do-notation :P
09:05:14 * hackage nvim-hs 2.1.0.3 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-2.1.0.3 (saep)
09:07:51 <solonarv> concat . map f = concatMap f
09:08:13 <solonarv> which makes the solution: concatMap reverse <$> getElems array
09:08:19 <solonarv> seems pretty unobjectionable to me
09:09:10 <sheepfleece> Does anyone use nix for development? How do you pin a stackage snapshot then? Because now my default.nix simply passes packages from a current snapshot, and it might break in the future.
09:10:27 <funnybunny2> I read that GHC is implemented in C. Is it possible to interpret machine instructions in a functional way so that Haskell can be converted directly to assembly?
09:10:46 <funnybunny2> Would this make Haskell code faster?
09:10:57 <dmwit> GHC is mostly not implemented in C.
09:11:01 <dmwit> GHC mostly does not compile via C.
09:11:19 <sheepfleece> Considering there are at least two intermediate languages between machine code and Haskell - you can't
09:11:33 <maerwald> funnybunny2: not sure what you're asking. But I remember SPJ talking about "functional hardware", which just couldn't compete with the imperative models.
09:11:35 <dmwit> Haskell is definitely not currently converted directly to assembly -- there are many intermediate representations, including linted/type-checked Haskell, Haskell Core, Cmm, and possibly llvm if you go via that route.
09:11:46 <Axman6> GHC produces assembly directly
09:12:21 <dmwit> I do not believe it's reasonable to expect to go directly from Haskell to assembly and still have a tool that humans could understand and modify, which would almost certainly adversely affect the speed of the produced executables. So I think the direct answer to "Would this make Haskell code faster?" is "no".
09:12:23 <nowhere_man> funnybunny2: GHC already produces machine code directly, it's a compiler after all
09:12:50 <Axman6> (by which I mean ghc takes Haskell files and produces assembly via the steps dmwit has outlined above, despite it sounding like we're contradicting each other)
09:12:51 <merijn> nowhere_man: It can produce LLVM IR too
09:13:04 <merijn> funnybunny2: GHC has never been implemented in C
09:13:04 <funnybunny2> I guess computer architecture is imperitive so an imperitive language produce more efficient assembly
09:13:15 * hackage extended-containers 0.1.0.0 - Heap and Vector container types  https://hackage.haskell.org/package/extended-containers-0.1.0.0 (konsumlamm)
09:13:16 <dmwit> [citation needed]
09:13:27 <Axman6> funnybunny2: that doesn't make any sense
09:13:28 <merijn> funnybunny2: At one point it did compile *to* C, but that backend has been disabled in release builds for years
09:13:40 <merijn> It's only around for bootstrapping on new architectures
09:13:45 <dmwit> Back when dons was active on the great language shootout, the Haskell programs were competitive with C, sometimes even faster.
09:13:54 <nowhere_man> funnybunny2: actually, intermediate languages used to compile and optimize impeartive languages have functional aspects, like no rebinding
09:13:54 <funnybunny2> I mean the abstraction of C over hardware is thinnner
09:14:07 <Axman6> the only C parts left in GHC are (parts of?) the runtime ststem, which deals with interacting with the OS and garbage collection.
09:14:14 <dmwit> The abstraction of C over hardware is thicker these days than you might imagine.
09:14:18 <merijn> nowhere_man: SSA is imperative poor man's CPS ;)
09:14:26 <dmwit> Hell, the abstraction of assembly over hardware is thicker these days than you might imagine at first blush.
09:14:28 <nowhere_man> LOL
09:14:38 <merijn> Axman6: GHC itself was always in Haskell
09:14:42 <solonarv> on top of that, humans aren't all that great at writing close-to-the-metal code (especially on modern hardware)
09:14:47 <merijn> Axman6: (not counting the RTS)
09:14:51 <merijn> Axman6: It's never been C
09:15:06 <funnybunny2> When I looked at Haskell language shootout stuff, it was never idiomatic Haskell.
09:15:08 <dmwit> Anyway, all of this is too abstract. Show us a program that's too slow and let's get you on your way to making it acceptably fast.
09:15:19 <funnybunny2> It was this crazy stuff you would never write
09:15:20 <Axman6> right, that's is what I meant, but it's also 2:15 AM here :)
09:15:45 <funnybunny2> I don't think you should have to have intimate knowledge of GHC to write fast Haskell
09:15:53 <Axman6> funnybunny2: that's mostly because they kept changing the rules because Haskell was doing so well
09:16:07 <dmwit> Well, I don't think you should have to have intimate knowledge of gcc to write fast C. But you do, so what the heck.
09:16:13 <dmwit> The world isn't always as it should be.
09:16:27 <Axman6> there are restrictions that are purely there because Haskell out performed other languages with very obvious and idomatic programs
09:16:29 <funnybunny2> You can write pretty fast C without intimate knowledge of GCC
09:16:39 <dmwit> You can write pretty fast Haskell without knowledge of GHC.
09:16:45 <dmwit> So I don't really know what your point is.
09:17:05 <dmwit> You seem to have some kind of misconception that Haskell is super slow.
09:17:07 <Axman6> like the restrictions on the binary tree benchmark are because GHC was smart enough to completely remove the need for the intermediate trees at all.
09:17:17 <dmwit> I don't know where it's coming from. Hence my demand that you show us your slow program.
09:17:25 <solonarv> Axman6: oh that's hilarious, is this summed up somewhere?
09:17:49 <maerwald> naive C code is probably 10x faster than naive haskell code
09:17:54 <Axman6> also, the multithreading benchmark became a joke when they started allowing non-native "threading" libraries, all the C ones are not doing threading at all. GHC used to win that benchmark
09:17:54 <maerwald> and also has 10x more bugs :P
09:18:08 <funnybunny2> https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/mandelbrot-ghc-3.html
09:18:12 <funnybunny2> This is crazy
09:18:26 <dmwit> I don't know about that. My rule of thumb has been about 2x for idiomatic Haskell vs. idiomatic C.
09:18:35 <Axman6> solonarv: no, I just used to work on a lot of the benchmarks - trying to make dons' code faster is how I learn all the cargo cult Haskell performance knowledge
09:18:44 <maerwald> dmwit: 2x is when you optimise both versions 
09:18:54 <maerwald> then C is still twice as fast 
09:19:25 <Axman6> funnybunny2: these days we should be able to write much more idomatic code than that, but that code ensures the compiler does exactly what the author wants
09:19:54 <funnybunny2> This one is pretty nice looking https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/binarytrees-ghc-6.html
09:20:00 <dmwit> No, I usually get parity with C when I optimize both.
09:20:23 <Axman6> funnybunny2: the other reason that code is so insane is that GHC doesn't have a great way of exposing vector types (as in, SSE, AVX etc)
09:20:24 <funnybunny2> What debuggers or tools do you use to optimize and debug Haskell?
09:20:38 <dmwit> I agree that vectorization is currently not a strong point.
09:20:48 <funnybunny2> Are there step through debuggers with breakpoints?
09:20:59 <maerwald> funnybunny2: GHC profiling, enabling Strict(Data), randomly trying different data types
09:21:11 <dmwit> Yes. Though stepping with lazy code is tricky to follow.
09:21:44 <monochrom> I use Debug.Trace.  Even in C, I am now convinced that debugging printf's are better.
09:21:47 <Axman6> funnybunny2: the first thing you need when wanting to optimnise something is a slow program, and that doesn't happen that often for me when I write Haskell
09:22:03 <solonarv> funnybunny2: GHCi has a step-through debugger, but it's not something that is used much
09:22:26 <dmwit> (N.B. I don't consider "beginner Haskell" to be idiomatic. Perhaps this is where the difference between maerwald's 10x and my 2x comes from.)
09:22:28 <maerwald> Axman6: happens easily when you write algorithmic code, but most of the time, someone else wrote (and optimised it) for you
09:22:43 <funnybunny2> In my past experience with Haskell, it was difficult to debug or reason about optimization. However, I didn't try to hard because I was just having fun programming at a higher level. I've since gone back to writing mostly C since many libraries are written in C and bindings usually are not up to date or nonexistent
09:22:50 <Cale> I can't remember a single instance in which the GHCi debugger actually got me closer to figuring out an actual bug (though mostly, I haven't tried)
09:22:52 <maerwald> dmwit: I didn't say idiomatic, I said "naive"
09:23:05 <dmwit> Okay. Then that is almost certainly where the difference comes from.
09:23:07 <monochrom> Or rather, I have always preferred debugging printf's, but I couldn't articulate why, and Learn C The Hard Way articulates my sentiment.
09:23:29 <dmwit> I don't worry myself about naive code being slow. I feel confident I can write naive, slow programs in any language.
09:23:31 <Cale> The primary strategy is to use the repl to evaluate expressions and try to break down their definitions until you find the part which is giving an incorrect result
09:24:04 <funnybunny2> One frequent issue I recall was the accumulation of "thunks"
09:24:07 <Cale> and you might use Debug.Trace at the start if the arguments to the functions which are involved are not obvious
09:24:21 <monochrom> And yeah, bottom-up unit testing, with very small unit, like a line or two.
09:24:49 <maerwald> funnybunny2: yep and it can be very hard to profile, because it might not really show up in your cost centres
09:25:31 <funnybunny2> Can you recognize your Haskell code from the assembly output?
09:25:50 <Axman6> depends on the code
09:25:56 <Cale> funnybunny2: In order to write Haskell code which performs well, it's important to get some intuition about how graph reduction proceeds. There are a couple of models of how evaluation works that are higher level than the actual story and which usually help before you get to the point of needing to think about thunks.
09:26:09 <maerwald> Yes, I can see the assembly code in my head while writing haskell, *chuckle*
09:26:17 <funnybunny2> How is this not intimate knowledge of GHC?
09:26:28 <Cale> First, I'll think about lazy evaluation in terms of rewriting expressions
09:26:29 <funnybunny2> "Graph reduction"? Does that have anything to do with GHC?
09:26:40 <Cale> Specifically, expression trees
09:26:42 <Axman6> if it's numerical computation heavy sure, but haskell code tends to have a lot of jumps and a pretty foreign control flow. confuses the hell out of binary analysis tools
09:27:10 <maerwald> Cale: is there a blog post about that?
09:27:30 <funnybunny2> Aren't jumps bad for performance since a wrong branch prediction is bad?
09:27:31 <Axman6> haskell is all case statements, all the way down
09:27:47 <monochrom> http://www.vex.net/~trebla/haskell/lazy.xhtml  this is mine
09:27:50 <Axman6> funnybunny2: not of they're to known addresses
09:27:55 <Axman6> if*
09:28:00 <Cale> and then if that's insufficient, I will think about expression graphs, which gives a better idea about the space usage than expression trees will
09:28:05 <funnybunny2> What about cache locality?
09:28:12 <monochrom> https://apfelmus.nfshost.com/articles/lazy-eval.html  this is apfelmus's
09:28:19 <Cale> and only if that doesn't suffice will I begin to think about anything lower level
09:28:28 <Axman6> caches are big, if you have a hot piece of code, it'll all be in the cache
09:28:57 <funnybunny2> Someone needs to make a AAA game in Haskell before I will believe it is fast
09:29:22 <Axman6> give me $300m and I'll be happy to
09:29:27 <sm[m]> that's fair
09:29:30 <monochrom> I don't believe it's fast. Don't hold your breath.
09:29:48 <Axman6> meanwhile, how about we settle for Facebook using it for all their spam filtering of all posted content on the platform
09:30:48 <Axman6> handling 2m requests per second, as of a few years ago, and reducing their hardware needs by half for spam filtering sounds pretty impressive to me
09:30:51 <monochrom> What's with these "me, me, me" attitude?
09:32:16 <maerwald> funnybunny2: why a game? That's just a very specialized industry that has little interest in Haskell. Doesn't mean there are no high-performance things done in haskell 
09:33:20 <funnybunny2> maerwald: Games are difficult to program and some of the most complex programs
09:33:37 <maerwald> Ok, I'll write an AAA game just to win this argument.....
09:33:39 <dmwit> Follow-up question: is it important that funnybunny2 believes Haskell is fast? Perhaps it is on them, and not us, to evaluate whether Haskell meets their needs and whether they should spend time de-risking their initially-uninformed estimates.
09:33:41 <Axman6> John Carmac gave a talk oHAskell a few years ago didn;t he?
09:34:03 <maerwald> Axman6: that's pretty much the only attention it ever got and he lost interest quickly.
09:34:21 <nowhere_man> funnybunny2: I'd guess many distributed systems are way more complex than any AAA game
09:34:36 <WilliamHamilton> hey, I have a question on `cabal test` behavior. I wrote a test that has a main thread, and forks a thread that is never killed. If I compile this test and execute it directly, the program will exit (of course leaving the forked thread still alive), while if I do `cabal test`, the program will finish but the cabal test suite never will. Is there
09:34:37 <WilliamHamilton> anything in particular that causes this difference in behavior? 
09:34:49 <nowhere_man> AAA games are huge codebases, for sure, but not necessarily extraordinarily complex
09:35:12 <funnybunny2> AAA games also squeeze every drop out of the hardware
09:35:21 <Axman6> particularly these days with the high quality game engines which exist
09:35:31 <maerwald> funnybunny2: ???
09:35:33 <Axman6> funnybunny2: so?
09:35:33 <maerwald> no.
09:35:44 <maerwald> absolutely false. I buy new hardware every year to play AAA titles.
09:35:53 <maerwald> They waste hardware
09:36:03 <funnybunny2> Yeah, and AAA games keep getting more technically impressive
09:36:43 <Axman6> funnybunny2: and Minecraft is written in Java, right? what's your point
09:37:08 <funnybunny2> Minecraft is not technically impressive
09:37:25 <Axman6> so?
09:37:29 <funnybunny2> It uses way too much RAM and has very poor graphics and draw distance
09:37:34 <Axman6> it makes a lot of money
09:38:22 <sm[m]> https://wiki.haskell.org/Frag is usually the game cited as proof that haskell can make such things. But it's ancient. maerwald++ for committing to write one!
09:38:23 <funnybunny2> My point is a technically impressive AAA game is a good test of a language
09:38:37 <maerwald> sm[m]: yeah, I've played frag
09:38:40 <Axman6> ok, so we shouldn't ever use python then
09:38:44 <Taneb> How many languages pass that test other than C++
09:39:07 <sm[m]> maerwald: was it fast, smooth, fun ?
09:39:11 <funnybunny2> None, but people are arguing Haskell is as faster or faster than C. So it should be possible to write such games
09:39:16 <Axman6> yeah, clearly you just want justification to learn C++, so go ahead
09:39:19 <maerwald> funnybunny2: no, because writing games isn't about the language, it's about ecosystem and knowledge
09:39:34 <maerwald> Why would you ever abandon all the stuff the C++ community has built around it
09:39:35 <Axman6> no, you're asking if it is and claiming it's a poor language because it isn't
09:39:44 <dmwit> WilliamHamilton: Hm. Under normal circumstances, when the main thread exits, the whole program exits. Do you mean that you are forking a process (rather than a thread)?
09:39:57 <funnybunny2> An example would quickly dismiss any doubt.
09:40:07 <funnybunny2> So far there isn't one
09:40:09 <dmwit> WilliamHamilton: If so, perhaps cabal is waiting on the process group it spawns rather than just the process. (I do not know; this is speculation, not knowledge of the cabal codebase speaking.)
09:40:21 <Axman6> funnybunny2: what evidence do you need?
09:40:26 <sm[m]> funnybunny2: we agree on this, so what next ?
09:40:33 <funnybunny2> A game?
09:40:35 <Axman6> I used to work in high frequency trading, and the system was all Haskell
09:40:41 <funnybunny2> Like way better than Frag
09:40:50 <Axman6> performance there matters _a lot_ more than a AAA game
09:41:01 <funnybunny2> Not arguing Haskell isn't a useful language
09:41:04 <sm[m]> would you like to work on it ? A lot of folks try it, and they hang out in #haskell-game
09:41:07 <Axman6> yes, you are
09:41:14 <dmwit> I would like to point out that "X should be possible" and "X has not been done" can both be true at once.
09:41:27 <funnybunny2> No, just saying I don't believe Haskell is fast and game would convince me
09:41:33 <maerwald> ok
09:41:54 <funnybunny2> Yes, it might be possible
09:41:59 <funnybunny2> Too bad it hasn't been proven
09:42:08 <maerwald> funnybunny2: Why do you think it's possible? I don't think it is
09:42:11 <Axman6> because you keep repeating that the only important thing for a language is if it can be used for an extremely small, specialised use
09:42:44 <Axman6> funnybunny2: do you think Facebook would build their entire spam filtering system on HAskell if it weren't fast enough?
09:42:50 <funnybunny2> maerwald: I don't think it is. I'm more so than not doubting it's possible, but not certain it isn't possible
09:42:54 <Cale> funnybunny2: A number of years back I worked on an action RPG in Haskell that was targeted at running on minimally iPhone 3 -- we didn't actually get to the point of releasing it before running out of funds, but it wasn't so much due to technical issues, as the fact that perhaps we bit off a bit more than we could chew content-wise. We had a dynamically loaded 3D open world (diablo-esque view), touch controls, and some melee and ranged 
09:42:54 <Cale> combat AIs with collision detection that all used our custom arrow-based FRP system.
09:43:05 <funnybunny2> After all, people in this channel who know Haskell way better than me are saying Haskell is very fast
09:43:41 <Cale> It was working reasonably well, we were starting to think that the plan of using a small C++ graphics/animation core that would be directed by the Haskell program might not be necessary
09:44:08 <funnybunny2> Cale: Do you have experience writing games in C or C++? Were you more productive in Haskell?
09:44:13 <Cale> (It wasn't necessary on desktop, on mobile it helped to avoid the garbage collector pauses)
09:44:13 <Axman6> funnybunny2: no we're not, we're saying it's adequately fast to be more than useful
09:45:23 <solonarv> sm[m]: you know, I had forgotten #haskell-game was a thing and didn't re-join it when changing clients
09:45:27 <solonarv> thanks for the reminder!
09:45:46 <Axman6> funnybunny2: you're the one who came in here and claimed Haskell is slow, and that that matters. Neither of those things are objectively true
09:46:06 <funnybunny2> dmwit> No, I usually get parity with C when I optimize both.
09:46:07 <Cale> I don't have much experience writing games in C or C++ -- I did a bit of it when I was quite young... I wrote a networked tetris game in C++ when I was in highschool. I wasn't very productive though, it took forever to do anything, but I wasn't extremely familiar with the language either.
09:46:25 <funnybunny2> dmwit argues that Haskell is as fast as C when properly optimized
09:46:38 <sm[m]> solonarv: np!
09:46:42 <Axman6> I would agree with that, for certain programs
09:46:58 <maerwald> I would think it's more of an exception, when it happens
09:46:59 <Axman6> I would also argue that HAskell programs are faster than C, for certain programs
09:47:13 <Axman6> and of course, the opposite is also true
09:47:16 <funnybunny2> What programs?
09:47:19 <maerwald> But you don't need to be as fast as C to be useful.
09:47:28 <maerwald> Even for high-performance things
09:47:41 <Axman6> anything multuthreaded for a start, without a lot of effort optimising the C code
09:47:42 <funnybunny2> You need to be as fast as C to write a modern AAA game since that is always a moving target
09:47:52 <maerwald> I don't think so
09:48:12 <maerwald> Prove it
09:48:19 <funnybunny2> I read the chat log again and ppl were saying parity with C, 2x C, and 10x C
09:48:41 <Axman6> I think you would be surprised to see how little C++ is written to make AAA games these days
09:49:07 <maerwald> They use C# :)
09:49:08 <funnybunny2> Anyway, I came in here not to complain about how Haskell is slow, but becaues I was thinking about why it is slow and does it have to do with computer architecture
09:49:11 <maerwald> And the stuff is slow af
09:49:21 <maerwald> The GC is leaking and causing networking problems
09:49:46 <Axman6> funnybunny2: would you expect anything different when comparing two language implementations where one has had two to three orders of magnitude more investment in them? there's is nothing in herently fast about C. 
09:49:50 <funnybunny2> I think it is a cool idea to write computable math as people who write Haskell seem to be doing
09:50:12 <funnybunny2> But is there not a math for efficient machines
09:50:17 <funnybunny2> Kind of what I was wondering
09:50:43 <Cale> funnybunny2: There are a couple of factors: one is that Haskell puts you a bit farther from the actual machine model than either C or C++ -- this results in a very decent boost in programmer productivity, but also makes it somewhat harder to understand performance.
09:51:00 <Axman6> if we had the investment C has had, we would have hardware which is optimised for Haskell's, and there's definitely been research into making that hardware
09:51:17 <funnybunny2> Axman6: Well, my intuition was that C is more similar to modern computer architectures, but maybe it's not
09:51:43 <Axman6> funnybunny2: it certainly is. no commercial CPU has specific hardware for graph reduction
09:51:47 <Cale> funnybunny2: Another is that most beginners in Haskell have exactly backwards intuitions about performance due to lazy evaluation -- it's not really the fault of lazy evaluation, but rather that people are expecting performance characteristics to be what they would be under eager evaluation and getting surprised.
09:51:51 <Axman6> but it is possible
09:52:41 <funnybunny2> Is writing code that gets evaluated quickly in Haskell similar to writing nonblocking code that maximizes throughput?
09:52:53 <Cale> Kind of, sometimes
09:53:03 <Axman6> I guess?
09:53:16 <funnybunny2> Where you don't build up a lot of unevaluated expressions that are blocking on others
09:53:26 <Cale> You often care about how soon a function will be able to produce the first part of its result
09:53:35 <Axman6> GHC's IO system takes care of all the non blocking, asynchronous nonsense that other languages make very painful (looking at you JS)
09:53:54 <funnybunny2> I don't mean blocking in the literal sense, but a metaphor
09:54:08 <Cale> A good little microcosm of it is to look at the difference between foldr and foldl(') and consider in what situations each is better than the other.
09:54:17 <Cale> @src foldr
09:54:17 <lambdabot> foldr f z []     = z
09:54:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:54:22 <Axman6> funnybunny2: when you've been programming Haskell for a while, you don't write code that does that very often. the optimisations happen at a much higher level than thunks, they happen at the level of threads
09:54:23 <funnybunny2> Like unevaluated expressions "blocking" on other unevaluated expressions. Is this what a "thunk" is?
09:55:00 <Cale> foldr, in the recursive case, passes control to f which is then able to decide whether and when the computation proceeds further, based on when the second argument to f gets pattern matched (causing evaluation)
09:55:34 <Cale> This allows foldr to terminate early, and stream its results in the case that the result is some recursive data structure
09:55:41 <Cale> @src foldl
09:55:41 <lambdabot> foldl f z []     = z
09:55:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:55:57 <Cale> By contrast, foldl greedily passes control to itself until it reaches the end of the list
09:56:17 <funnybunny2> So what happens here? Does the compiler just build up foldl up to a certain limit?
09:56:18 <Cale> and so it cannot ever produce any part of its result until it gets all the way through the list
09:56:27 <funnybunny2> It can't be actually infinite right
09:56:52 <funnybunny2> Oh
09:56:53 <Cale> Now, if we consider the case where f needs both of its arguments in order to do any work at all, suddenly foldl has a distinct advantage over foldr
09:57:49 <Cale> In that we have the option of possibly evaluating f z x there (innermost-first, eager evaluation) before proceeding. It's not what plain lazy evaluation would do, but GHC will do this automatically for you if optimisations are turned on, and if you want to be more sure about it, use foldl'
09:57:52 <Cale> @src foldl'
09:57:52 <lambdabot> foldl' f a []     = a
09:57:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:58:10 <Cale> ^^ this contains a hint to the compiler that we may wish to evaluate a' early
09:58:17 <solonarv> "it can't be actually infinite right" - it sure can, here is an infinite list: [1..]. foldl applied to this will run forever. foldr might nit (depending on what f is).
09:58:41 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
09:58:41 <funnybunny2> I mean the compiler is not using infinite memory
09:58:43 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
09:59:09 <solonarv> oh no, the compiler isn't. but the runtime tries to, until it runs into whatever limit is in place.
09:59:10 <Cale> In this case, it's going to run in constant space so long as you don't hold on to the entire result
09:59:14 <Axman6> why must we need infinite memory to work with infinite things?
09:59:59 <funnybunny2> < Cale> Now, if we consider the case where f needs both of its arguments in order to do any work at all, suddenly foldl has a distinct advantage over foldr
10:00:07 <funnybunny2> I don't understand this
10:00:58 <Cale> okay
10:01:09 <Cale> Let's look at foldr again
10:01:11 <Cale> @src foldr
10:01:12 <lambdabot> foldr f z []     = z
10:01:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:01:33 <Cale> The advantage here is that f receives as its arguments x and (foldr f z xs) -- as yet unevaluated
10:01:37 <funnybunny2> How do you make the bot show the type of a function?
10:01:47 <Cale> and f gets to decide if it wants to proceed to evaluate the recursive foldr
10:01:53 <Cale> :t foldr
10:01:55 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:02:07 <Cale> oh, that's more general than the @src one :)
10:02:11 <Axman6> read t a as [a]
10:02:16 <Cale> yeah
10:02:34 <funnybunny2> How do you evaluate something?
10:02:44 <Cale> Primarily by pattern matching on it
10:03:03 <funnybunny2> With the bot I mean
10:03:13 <Axman6> > 1+2
10:03:15 <Cale> oh, prefix an expression with "> "
10:03:15 <lambdabot>  3
10:03:28 <funnybunny2> > foldr (+2) 0 [1, 2, 3]
10:03:32 <lambdabot>  error:
10:03:32 <lambdabot>      • No instance for (Num (Integer -> Integer))
10:03:32 <lambdabot>          arising from a use of ‘e_120123’
10:03:38 <Cale> > foldr (+) 0 [1,2,3]
10:03:40 <lambdabot>  6
10:03:46 <funnybunny2> Oops
10:03:51 <funnybunny2> OK
10:03:52 <Cale> > foldr (\x xs -> x+2 : xs) [] [1,2,3]
10:03:55 <lambdabot>  [3,4,5]
10:04:29 <ski> > foldr ((:) . (+ 2)) [] [2,3,5,7]
10:04:32 <lambdabot>  [4,5,7,9]
10:04:33 <Cale> So, (+) is an example of a function argument to foldr which wouldn't usually be great
10:04:48 <funnybunny2> foldr (+) 0 [1, 2 3] = (+) 1 (foldr (+) 0 [2, 3]
10:04:53 <Axman6> > foldr (+) 0 [1..]
10:04:58 <Cale> Usually (+) needs to know both of its arguments to do any work -- at least this is always true for the basic numeric types
10:05:01 <lambdabot>  mueval-core: Time limit exceeded
10:05:06 <ski> > foldr ((:) . (+ 2)) [] [2,3,5,7]  :: [Expr]
10:05:08 <lambdabot>  [2 + 2,3 + 2,5 + 2,7 + 2]
10:05:18 <ski> > foldr (+) 0 [2,3,5,7]  :: [Expr]
10:05:20 <ski> > foldr (+) 0 [2,3,5,7]  :: Expr
10:05:21 <lambdabot>  error:
10:05:21 <lambdabot>      • No instance for (Num [Expr]) arising from a use of ‘+’
10:05:21 <lambdabot>      • In the first argument of ‘foldr’, namely ‘(+)’
10:05:23 <lambdabot>  2 + (3 + (5 + (7 + 0)))
10:05:28 <funnybunny2> Ahhh. What is going on
10:06:58 <Cale> Since (+) forces the evaluation of both its arguments, deferring the evaluation of the foldr over the rest of the list (1) doesn't buy us anything at all, and (2) results in the pattern match inside the implementation of (+) waiting on the stack while the rest of the foldr completes
10:07:41 <Cale> Now, if we're using plain lazy evaluation, foldl isn't actually too much better here:
10:07:42 <funnybunny2> Are you saying foldl is better when both args are needed because foldl will be able to evaluate f expressions fater?
10:07:43 <Cale> @src foldl
10:07:44 <lambdabot> foldl f z []     = z
10:07:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:07:50 <funnybunny2> *faster
10:07:55 <funnybunny2> Like that (f z x) there
10:08:12 <Cale> The f z x will end up being deferred until later if we're evaluating outermost-first, as lazy evaluation tells us to do
10:08:39 <funnybunny2> So I still don't get why foldl has an advantage
10:08:49 <Cale> and so foldl will race through the list, building up a giant expression like (((...(0 + 1) + 2... )+99)+100)
10:09:29 <Cale> and then the outermost (+) will force the evaluation of its first argument, that pattern match will wait on the stack, and you'll still get a stack overflow, and you've wasted a bunch of memory on big expressions
10:09:34 <Cale> But!
10:09:45 <Cale> The trick is that Haskell is not specified as being lazily evaluated
10:10:05 <Cale> It simply has the same *termination behaviour and result* as if it were lazily evaluated
10:10:30 <Cale> So a compiler is free to discover that f z x is going to be needed eventually, and evaluate it sooner
10:10:40 <Axman6> foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) 1 [2,3] -> foldl (+) (1+2) [3] -> foldl (+) 3 [3] -> ...
10:10:46 <Cale> ^^ like that
10:10:50 <funnybunny2> Cale: So is what I was saying correct?
10:10:55 <Cale> right
10:11:30 <Cale> So, by evaluating f z x sooner -- more innermost-first / eager than full lazy evaluation, foldl can get better performance
10:11:44 <funnybunny2> Is foldl faster in this case or just use less memory?
10:11:49 <Cale> *in those cases where the f is going to need both its arguments*
10:11:58 <Cale> Well, it will be faster because it allocates less
10:12:22 <Cale> and also makes the garbage collector work less
10:12:27 <funnybunny2> Well, doesn't the compiler allocate a lot of memory up front to avoid the penalty of allocating on the fly?
10:12:57 <funnybunny2> I guess in a very long list there will still be more allocations
10:13:24 <Cale> Even if it already owns the memory, creating data structures representing unevaluated expressions in memory is a waste of time
10:13:33 <Axman6> when we run the NICTA course, foldl was always explained as: foldl is just the following for loop: foldl f init xs = tmp = init; for (x in xs) { tmp = f tmp x}; return tmp
10:13:38 <Cale> and then it still needs to do internal memory management to clean them up
10:13:57 <funnybunny2> OK
10:13:57 <Cale> (even if it doesn't involve claiming new memory from the OS, or releasing memory back to the operating system)
10:14:40 <funnybunny2> How can you reason about cache performance in Haskell? Like I guess there are bit types but... can you do it easily?
10:14:49 <Cale> It's not easy
10:14:55 <funnybunny2> Like if you want your data to fit neatly into cache lines
10:15:20 <Axman6> it depends, like in all programming languages, what data structures you choose
10:15:31 <Cale> The cache *can* have an influence on things -- lazy ByteStrings for example, are generally best if their chunk size is tuned to a cache line
10:15:46 <Cale> But it's not something you can easily reason about without experimentation
10:15:53 <Axman6> we have access to pointers, malloc and free if we want, we also have safe interfaces above those which perform very well like vectors
10:16:01 <Cale> Yeah, that's also true
10:16:01 <funnybunny2> Well, I just don't know if any of the machinery of the compiler is going to require additional things in the cache besides my data
10:16:31 <Axman6> it's all your data, whether you write it or not
10:16:53 <funnybunny2> Plus if the assembly doesn't resemble my program I can't see what's going wrong
10:17:03 <Cale> The thing is, it usually will, and you have poor control over that, so you're just not going to be able to care. If you really must care, then you usually have to pass to writing your program in a lower-level way, either in Haskell, or by writing parts of it in C or assembly and making FFI calls.
10:17:19 <funnybunny2> OK
10:17:49 <Cale> Haskell's pretty good at being a high-level glue language between low-level pieces too though
10:18:18 <funnybunny2> I dunno. Trying to write bindings was really hard for me
10:18:26 <funnybunny2> Harder than just using the library in C
10:18:53 <Cale> It's a bunch of work initially to make the equivalent of a C header file
10:19:05 <funnybunny2> Why is it not completely automatic?
10:19:18 <Cale> There are some tools to help with that, but usually they result in something which you still need to tweak a bunch to really make it usable
10:19:25 <funnybunny2> Like can't you just have a type for every C type?
10:19:31 <Cale> There are actually
10:19:37 <funnybunny2> Yeah, I thought so
10:19:49 <funnybunny2> So you should at least be able to get an automatic translation into C types
10:20:12 <Cale> https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
10:20:33 <funnybunny2> I guess the issue is more that big projects are not structured so that whatever generates bindings can find how things fit together?
10:20:52 <funnybunny2> And the thing is not smart enough to understand interdependent C files?
10:20:57 <Cale> I highly recommend just reading the FFI section of the language report if you haven't already -- it's more tutorial in nature than the rest of the report and clarifies a bunch of stuff about how to do low-level things
10:21:08 <funnybunny2> I did try to read it once
10:21:10 <funnybunny2> It was really hard
10:21:23 <funnybunny2> Way harder than reading how to use a C library
10:21:36 <monochrom> It is pretty dry and organized for reference not teaching, yes.
10:21:37 <Cale> I guess that's true
10:21:40 <monochrom> But it's complete.
10:21:56 <monochrom> Just not in teaching order.
10:21:56 <funnybunny2> Yeah, well my point was that writing bindings is harder than just using the native library
10:22:18 <Cale> If all you're doing is making calls to the library, I probably agree
10:22:21 <funnybunny2> Which mitigates a lot of the benefit of using a higher level language
10:22:40 <funnybunny2> If what you are seeking is time savings
10:22:42 <Cale> Usually your program does some more stuff apart from external calls though
10:22:54 <funnybunny2> And not just using beautiful abstractions
10:22:59 <dsal> If your goal is to write a C program against a C library, but using Haskell for the C program, then it's not very helpful.
10:23:02 <monochrom> That means even more work, Cale :)
10:23:16 <monochrom> But perhaps only then the investment is worthwhile.
10:23:23 <dsal> When I've used FFI, it's been to provide high level access to a library and then write a high level application on top of it.
10:23:54 <Darwin226> Hey guys. Is there a tool that could analize one of my modules and tell me which parts I can separate in other modules without dependency cycles?
10:23:58 <Cale> funnybunny2: I would usually prefer to write the better part of my program in Haskell, and only pass to writing innermost loops in C if I was forced to in order to hit a performance goal.
10:24:29 <Cale> (or maybe brute-force-scheduled assembly if we're going that far...)
10:24:32 <funnybunny2> But if your program uses like ffmpeg...
10:24:32 <monochrom> Don't forget that crossing the FFI boundary has overhead too.
10:24:40 <dmwit> Darwin226: Hey, neat idea! I think GHC already has this analysis -- they have to find minimally recursive groups of bindings -- though I don't know of a way to ask GHC to print this information.
10:24:42 <dsal> My program forks to use ffmpeg.  heh
10:25:10 <monochrom> Anyway what haskell code have you written recently?
10:25:10 <funnybunny2> Why can't bindings be generated automatically?
10:25:12 <dsal> I considered using a library, but the ones I found were a bit of a mess and dealing with C libraries is generally harder than just running a program.
10:25:17 <Darwin226> dmwit I know there was a project, haskell indexer, something like that
10:25:38 <Cale> funnybunny2: There are some tools for that
10:25:44 <funnybunny2> I haven't written any Haskell code recently? Just had a random thought about a functional computer architecture and thought I'd come in here
10:25:56 <dsal> funnybunny2: an automatic binding wouldn't be very useful in general.
10:25:56 <Cale> funnybunny2: It depends on what kind of machine-readable API specifications you have
10:25:57 <Darwin226> I have a vague recollection that it tracked dependencies between functions but I don't know if it could do what I want
10:26:15 <funnybunny2> I did write a global illumination renderer in Haskell once
10:26:20 <funnybunny2> It was really slow
10:26:28 <monochrom> That explains all the speculative questions.  And how the speed of asking exceeds the speed of answering.
10:26:30 <Axman6> you probably had thunks :)
10:26:50 <Cale> funnybunny2: You might enjoy talking with edwardk about that kind of thing :)
10:26:51 <Axman6> I'm pretty sure Ed had a real time raytracer in Haskell
10:26:57 <Cale> he did
10:27:05 <dsal> I also don't necessarily believe C == faster.  The last time I tried making some haskell code faster, I went as far as to write the part I thought was slow in C and it benchmarked a *little* faster sometimes, but it was a lot of work.  Turns out, my entire problem was that I wasn't compiling with optimization on.  *sigh*
10:27:05 <monochrom> Haskell is not going to be fast.  But it is not going to be slow.  Compared with PHP and Python it's pretty favourable.
10:27:21 <funnybunny2> I also used this lib called GPipe which was supposed to be a functional representation of the graphics pipeline, and it turned out to be a toy project that was doing something stupid like recompiling shaders like every frame
10:28:14 <funnybunny2> I have since learned to trust almost no libraries
10:28:26 <Cale> funnybunny2: Yeah, because Haskell hasn't been as extensively used by industry, a lot of the projects you'll find online are people's weekend projects and it takes some discernment to tell if they're going to really be useful.
10:28:51 <monochrom> Speaking of which, would you like to hear an Aesop fable?
10:28:51 <Cale> Often they're a good start, but you'll have to do a bunch of work on them to really make them practical.
10:28:57 <solonarv> for the moment I don't believe in nice idiomatic/high-level wrappers over OpenGL/Vulkan/whatever. I will just buckle up and use the raw bindings.
10:29:13 <Axman6> see ed's gl package then
10:29:30 <funnybunny2> Yeah, and I don't believe in programs in Haskell. I just buckle up and write in C :)
10:29:40 <solonarv> your loss :p
10:29:55 <Axman6> how're those threads going?
10:30:07 <funnybunny2> I'm pretty good at using pthreads
10:30:26 <dsal> I find most people believe they are.  :)
10:30:28 <Uniaika> haha
10:30:41 <funnybunny2> I also use select/poll when I can
10:30:45 <Axman6> ew
10:31:00 <Axman6> get some decent event handling!
10:31:10 <Axman6> libev, kpoll etc
10:31:16 <Axman6> we get that for free in Haskell
10:31:24 <Cale> C might be fine in those cases where your program doesn't do anything interesting, but even then it can be pretty annoying. I tend to think of it as being at a kind of awkward point in the design space for languages -- I'd rather use LLVM for most of the things I think C would be good at.
10:31:28 <dsal> We also get free monads.
10:31:29 <funnybunny2> I dunno what those are but probably not POSIX
10:31:42 <Axman6> which is why I've never worried about how to make something multithreaded, only whether I've made it too multithreaded
10:32:02 <monochrom> dsal: Here is one way gcc generates faster code than ghc (all else being equal).  Suppose you do mod-7 for Int.  ghc generates the honest-to-god divmod instruction.  gcc generates a multiplication and a bitshift that's equivalent to mod-7 for int-size int.
10:32:52 <dsal> monochrom: Is that just the "we've spent more time on this" problem?
10:33:01 <funnybunny2> A big reason for using C is as I said it's easier to interface with libraries
10:33:24 <monochrom> This is one reason why I say that Haskell is not going to be fast. But I also say I don't care, this is a micro benchmark.
10:33:25 <dsal> Axman6: I do this a lot in my current project:  `mapConcurrentlyLimited :: (MonadMask m, MonadUnliftIO m, Traversable f, Foldable f) => Int -> (a -> m b) -> f a -> m (f b)`
10:33:26 <merijn> funnybunny2: Haskell has an extremely easy and good API for FFI-ing to C, so...
10:33:27 <Axman6> it's easier to interface with C libraries
10:33:39 <Cale> funnybunny2: I think for most real projects, the time spent working on FFI is going to be a trivial part of the cost of production.
10:33:39 <funnybunny2> Where is the Haskell ffmpeg library?
10:33:42 <solonarv> monochrom: what if you use ghc -fllvm ? perhaps the LLVM optimizer catches this sort of thing.
10:33:42 <Axman6> dsal: yeah we need more of that
10:34:07 <solonarv> dsal: (Traversable f, Foldable f) ? for shame! that's redundant!
10:34:10 <Axman6> funnybunny2: here? https://hackage.haskell.org/package/ffmpeg-light
10:34:19 <funnybunny2> That's not even close to what ffmpeg offers
10:34:22 <Cale> funnybunny2: But I'll admit it's not very fun sometimes -- it's kind of boring and does impose a barrier on very small projects.
10:34:24 <dsal> solonarv: Hmm...  How did I get there?
10:34:36 <solonarv> funnybunny2: have you tried using the search function? https://hackage.haskell.org/packages/search?terms=ffmpeg
10:34:37 <merijn> funnybunny2: The fact that no one has made bindings yet doesn't mean it's hard...
10:35:01 <solonarv> it does seem like there are no up-to-date complete bindings
10:35:04 <dsal> TBH, I looked through them as I needed ffmpeg in my current project.  In the end, forking was far easier for my needs.
10:35:08 <solonarv> but this is most likely due to a lack of interest
10:35:11 <funnybunny2> No, but I've tried to make bindings and it is hard
10:35:19 <funnybunny2> Not specifically for ffmpeg though
10:35:21 <Axman6> for you
10:35:31 <funnybunny2> But I just found trying to understand the Haskell FFI hard
10:35:35 <funnybunny2> Yes, for me
10:35:36 <dsal> This is my ffmpeg library:  https://github.com/dustin/gopro/blob/master/src/FFMPeg.hs
10:35:37 <Axman6> someone who isn';t familiar with how to do it
10:35:51 <monochrom> dsal: Absolutely!  When I was young and brave, I already observed it.  Actually it is probably even more impressive if you look at the ratio of (gain)/(how many people-hours spent)
10:35:54 <Axman6> oh yeah, I forgot you were doing GoPro stuff
10:36:15 <Cale> I've mostly found the FFI in Haskell to be rather pleasant. It can be somewhat time-consuming making a really polished and complete binding, but just binding the stuff you need is usually pretty quick and not too bad.
10:36:25 <dsal> I learned FFI for a couple projects recently and it was pretty good.  I never did get around to signaling errors well, though.
10:36:25 <funnybunny2> dsal: That is just calling the ffmpeg program wtf. I guess you were joking
10:36:31 <monochrom> https://groups.google.com/forum/#!topic/comp.lang.functional/i3QXHvEzDoc%5B51-75%5D
10:36:55 <funnybunny2> I would actually expect my user to have a standalone binary
10:36:57 <dsal> funnybunny2: Yeah.  It solves my particular problem quite well, though.
10:37:04 <dsal> funnybunny2: would you?
10:37:13 <dsal> You wouldn't expect them to have ffmpeg libraries installed?
10:37:13 <funnybunny2> Yeah...
10:37:16 <Cale> funnybunny2: I don't think dsal was joking -- just that it was a practical approach to the problem they were trying to solve.
10:37:18 <funnybunny2> No
10:37:23 <Axman6> said user is still p[robably going to have to install ffmpeg
10:37:23 <funnybunny2> Especially not on Windows
10:37:36 <Axman6> ew
10:38:05 <funnybunny2> It is high quality in terms of presentation to produce a standalone binary
10:38:14 <dsal> I'd expect anything using an ffmpeg library would have to have ffmpeg libraries installed on the system and runtime available to my program.  Getting the ffmpeg program in its place is easier for my case.
10:38:25 <dsal> Linking against the library is only half the problem.
10:38:40 <monochrom> I'm under the impression that for most users the instruction "install ffmpeg exe" is way easier than "install ffmpeg lib".
10:38:46 <Axman6> funnybunny2: you have some very odd ideas about software development
10:38:54 <funnybunny2> A program that you just double click or run is the highest quality
10:39:12 <funnybunny2> I guess Linux nerds would like to compile from source though
10:39:14 <monochrom> Like, most users don't even know there is such a thing as "lib" and it's independent of the "program".
10:39:25 <dsal> Unless you mean you'd expect a haskell module to statically link ffmpeg.a into the final program.
10:39:25 <funnybunny2> But that's like 1% of users
10:39:25 <monochrom> Hell, s/program/app/
10:39:27 <Axman6> that's like, so far far from something I've ever thought about when writing a program
10:39:48 <Axman6> people don't touch my apps though, Amazon does
10:40:01 <Axman6> lambdas on Lambda
10:40:04 <funnybunny2> I would expect a good program to statically link everything
10:40:05 <monochrom> Double click you say?
10:40:14 <maerwald> funnybunny2: including ssl? :)
10:40:14 <Axman6> I woudn't
10:40:18 <funnybunny2> From a usability perspective
10:40:18 <monochrom> That's only second highest quality.
10:40:38 <monochrom> The highest quality is you just speak to the ambient air "alexa/siri/OK google"
10:40:39 <dsal> It's worth noting, that ffmpeg requires all this stuff on my system:  https://www.irccloud.com/pastebin/shZRqTf6/ffmpeg
10:40:44 <funnybunny2> And it should also have an automated build process that produces such executables
10:41:07 <monochrom> No that's still 2nd highest quality.  The highest quality is telepathic.  You just have to think.
10:41:17 <Axman6> maerwald: pls no
10:41:18 <monochrom> ("But you have to think in Russian")
10:41:26 <funnybunny2> And that build process should be just like ./build
10:41:49 <Axman6> my build process is just git push
10:42:17 <dmwit> Darwin226: -ddump-simpl shows recursive groups in its output. But it can be tough to connect the members of those recursive groups back to the identifiers in your original source that gave rise to them in an automated way.
10:42:19 <Axman6> which builds, tests, packages and deploys
10:42:20 <monochrom> dsal: it comes up empty. is that intended?
10:42:22 <maerwald> Axman6: bad news: you can't do partially static linking with cabal at least
10:42:40 <sm[m]> funnybunny2: that's how I do it for my windows app.. embed files in the exe, download & double click to run. Embedding ffmpeg sounds a bit harder
10:42:41 <dsal> I just saw jle`'s article yesterday about github actions.  That's how I found them.  I need to figure out to get artifacts to drop out.
10:42:42 <dmwit> Darwin226: Usually it's pretty possible to do with some human guesses about which names/source code correspond with what things in the original though.
10:42:54 <dsal> monochrom: That link?  It should be a list of 42 dynamic libraries.
10:43:09 <funnybunny2> It might actually be illegal to statically link ffmpeg unless your program is GPL. Not sure
10:43:30 <sm[m]> not ffmpeg, but JuicyPixels is our image-munging lib
10:43:32 <Axman6> that's the reason we don't statically link GMP
10:43:33 <funnybunny2> But if so, the next best thing is a libffmpeg.dll alongside your .exe
10:43:51 <dsal> I don't use windows, so that just sounds weird to me.
10:44:05 <funnybunny2> Or .so whatever
10:44:24 <Axman6> man, Windows is still such a ghetto. Apple have their shit together with .apps
10:44:28 <dsal> "Here's a small program and an OS to go along with it."
10:44:43 <Axman6> there's no install, just drag and drop
10:44:50 <Axman6> dsal: heh
10:44:51 <dsal> I guess that's docker, though.
10:44:56 <Axman6> docker--
10:45:05 <Axman6> @karma docker
10:45:05 <lambdabot> docker has a karma of 0
10:45:10 <Axman6> too high
10:45:33 <funnybunny2> I want my programs to run on Windows, Linux, and Mac. I probably care about Windows the most though since that's what most people use, but I like Linux so I want it to run on Linux
10:46:23 <funnybunny2> Anyway, just realized this is not Haskell related at all
10:47:09 <funnybunny2> Oh yeah, I was also thinking about using Haskell again to prototype solving a pure math problem
10:47:17 <solonarv> but there is a Haskell-related answer to this:
10:47:40 <funnybunny2> Haskell is probably the best language I know. Does anyone prefer Mathematica to Haskell?
10:47:44 <Axman6> what's the problem?
10:47:52 <solonarv> haskell is pretty good at being source-compatible between different operating systems (like most high-level languages), but unfortunately is not great at cross compiling.
10:48:12 <solonarv> th easiest way by far to produce a binary for $PLATFORM is to compile on $PLATFORM
10:48:23 <funnybunny2> It's similar to the vehicle routing problem
10:48:25 <Axman6> mathematica is just lisp with weird syntax (though there's a lot of very powerful stuff implemented in it)
10:48:53 <dmwit> The amazing thing about mathematica is its standard library, not the language itself.
10:49:04 <monochrom> "Here's a small program and an OS to go along with it." ->  https://mail.haskell.org/pipermail/glasgow-haskell-users/2007-April/012422.html
10:49:10 <monochrom> tee hee hee!
10:49:24 <funnybunny2> Is that a joke about Docker?
10:49:51 <solonarv> sure sounds like one to me :>
10:50:38 <Axman6> from 2007, very prophetic
10:50:58 <funnybunny2> Like, my program is a virtualbox image
10:51:13 <monochrom> When I was young and brave, I was funny and insightful and prophetic and more, yes. >:)
10:51:56 <funnybunny2> https://mail.haskell.org/pipermail/glasgow-haskell-users/2007-April/012422.html
10:52:02 <funnybunny2> This guy is joking right?
10:52:03 <Axman6> I've made pretty tiny docker images before, 8MB including all the C libs needed for the app, but it wasn't fun
10:52:04 <dmwit> That makes me think of the Prairie Home Companion joke about everyone being above average.
10:52:12 <monochrom> You wanna hear my molecular-level STG based on Campbell soup?  XD
10:52:18 <dmwit> But, you know, although not everybody can be above average, all but one can be.
10:52:19 <solonarv> funnybunny2: yes, definitely joking
10:56:30 <monochrom> G-machine in Campbell soup: https://mail.haskell.org/pipermail/haskell-cafe/2007-May/025503.html
10:56:43 <monochrom> "2007. That was a good vintage year." :)
10:58:53 <dmwit> You do a damn good crackpot impression.
10:59:25 <enthropy> $(tupE [|1|]) -- this has type Unit which is not in scope according to :info... shouldn't it print Somewhere.GHC.DefinedIt.Unit?
10:59:43 <dmwit> However, you do not say "but for some reason nobody will listen to me" enough to be an authentic crackpot. =P
10:59:44 <enthropy> oops, I mean  $(tupE [ [| 1 |] ])
10:59:57 <monochrom> haha
11:02:38 <solonarv> % :set -XTemplateHaskell
11:02:38 <yahb> solonarv: 
11:02:46 <solonarv> % import Language.Haskell.TH
11:02:47 <yahb> solonarv: 
11:03:01 <solonarv> % :t $(tupE [ [| 1 |] ])
11:03:02 <yahb> solonarv: Num a => Unit a
11:03:14 <solonarv> hmm.
11:05:54 <enthropy> it's not defined in the template-haskell library
11:06:26 <solonarv> I wouldn't expect it to be defined there. Hmm, perhaps it's in GHC.Tuple or something.
11:06:46 <solonarv> ha! hole in one!
11:06:51 <solonarv> % :i GHC.Tuple.Unit
11:06:52 <yahb> solonarv: type GHC.Tuple.Unit :: * -> *; data GHC.Tuple.Unit a = GHC.Tuple.Unit a; -- Defined in `GHC.Tuple'
11:07:14 <solonarv> % $(tupE [ [| 1 |] ]) :: GHC.Tuple.Unit Int
11:07:15 <yahb> solonarv: ; <interactive>:47:3: error:; * Couldn't match expected type `GHC.Tuple.Unit Int'; with actual type `Unit a0'; NB: `Unit' is defined in `GHC.Tuple'; `GHC.Tuple.Unit' is defined in `GHC.Tuple'; * In the expression: (Unit 1) :: GHC.Tuple.Unit Int; In an equation for `it': it = (Unit 1) :: GHC.Tuple.Unit Int
11:07:27 <solonarv> ...eh?
11:07:50 <monochrom> my mouth is wide open too
11:08:01 <solonarv> perhaps this is just template haskell weirdness.
11:08:27 <solonarv> % let { justone :: GHC.Tuple.Unit Int; justone = $(tupE [ [| 1 |] ]) }
11:08:27 <yahb> solonarv: ; <interactive>:48:50: error:; * Couldn't match expected type `GHC.Tuple.Unit Int'; with actual type `Unit a0'; NB: `Unit' is defined in `GHC.Tuple'; `GHC.Tuple.Unit' is defined in `GHC.Tuple'; * In the expression: (Unit 1); In an equation for `justone': justone = (Unit 1)
11:08:39 <solonarv> well, that doesn't fix it. I don't know.
11:09:03 <monochrom> Is it just because a0 vs Int?
11:09:22 <solonarv> % :set -XPartialTypeSignatures
11:09:23 <yahb> solonarv: 
11:09:24 <monochrom> Ah no, nevermind.
11:09:25 <mniip> %% $(tupE [ [| 1 |] ]) :: GHC.Tuple.Unit Int
11:09:25 <yahb> mniip: http://qp.mniip.com/y/30
11:09:34 <solonarv> % let { justone :: GHC.Tuple.Unit _; justone = $(tupE [ [| 1 |] ]) }
11:09:34 <yahb> solonarv: ; <interactive>:51:48: error:; * Couldn't match expected type `GHC.Tuple.Unit _'; with actual type `Unit a0'; NB: `Unit' is defined in `GHC.Tuple'; `GHC.Tuple.Unit' is defined in `GHC.Tuple'; * In the expression: (Unit 1); In an equation for `justone': justone = (Unit 1); * Relevant bindings include justone :: GHC.Tuple.Unit _ (bound at <interactive>:51:
11:12:05 <mniip> I think it might be a TH bug
11:12:58 <mniip> ghc-prim:GHC.Tuple.Unit{(w) tc 42}  versus  ghc-prim:GHC.Tuple.Unit{tc rdRN}
11:14:39 <mniip> (w) indicating the wired in id (likely the name from the type sig)
11:22:03 <mniip> yea
11:22:10 <mniip> looks like a TH/renamer bug
11:22:34 <mniip> enthropy, ^
11:22:56 <enthropy> thanks for looking into it mniip
11:24:22 <mniip> if you'd like to file a bug please attach the output with -ddump-splices -dppr-debug -fprint-explicit-*
11:25:25 <jchia_> Nix question: Stack has curated package versions. cabal-install has a solver to help the user select his own package versions. What does Nix allow to be easily done, the Stack way or the cabal-install way?
11:25:51 <jchia_> Nix for building haskell projects
11:26:42 <solonarv> IIRC nixpkgs has curated sets of haskell packages, and they are stackage snapshots
11:27:15 * hackage ormolu 0.0.5.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.0.5.0 (mrkkrp)
11:33:07 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2007-March/023552.html  (summary to follow)
11:33:53 <monochrom> Strategy to learn haskell:  0. read tutorials  1. ask #haskell if stuck  2. learn haskell
11:35:22 <maerwald> ~/.ghcup/ghc/8.8.3/lib/ghc-8.8.3/settings: openFile: does not exist (No such file or directory)
11:35:22 <sm[m]> “Added experimental support for simple CPP” - excellent
11:35:29 <maerwald> when invoking brittany
11:35:46 <maerwald> what is hardcoding ghc locations?
11:36:25 <monochrom> Does it literally use "~"?
11:37:10 <sm[m]> From the “google engagement” project. Sounds like google funded some ormolu work, nice
11:37:36 <maerwald> monochrom: no
11:38:08 <maerwald> sm[m]: I'm starting to consider trying that too
11:43:04 <sheepfleece> I have a bunch of `throw`s in pure code which end up inside a list and leak out out of `catch`. Should I just simply deepseq the list? Or maybe there is a better way.
11:44:14 <jchia_> If I want to use nixpkgs not with its curated hackage-packages.nix but with my cabal.project.freeze, is there a reasonably simple way?
11:44:20 <monochrom> I hate the phrase "code smell" but I think it applies to your case.
11:46:17 <monochrom> But I can be non-judgmental and say: Yeah that's the price of using throw.  Now if you want to control the control flow, you have to go out of your way to micro-manage evaluation order such as using evaluate (from Control.Exception) and seq and deepseq etc.
11:47:27 <monochrom> If you use a Maybe type or an Either type instead of throw, you can get much more elegant and robust detection and handling of errors.
11:47:52 <Axman6> exceptions and pure code do not go together
11:47:52 <monochrom> or even your own algebraic data type
11:47:53 <sheepfleece> Library returns an opaque type I need to pattern match on to get things out. If the thing is not exactly what I want there is nothing I can do but to throw an exception. Well, I can use Maybe, but it complicates things a lot. Especially considering these pattern matching functions are only called from an impure code.
11:48:18 <sheepfleece> Maybe I should just put them inside IO? It may work actually.
11:48:25 <Axman6> no...
11:48:41 <monochrom> Maybe and Either complicate things one way.  throw complicates things the other way, you're experiencing it right now.
11:48:44 <Axman6> just make a [Either String Foo] instead of [Fpp
11:48:50 <Axman6> [Foo]*
11:49:07 <Axman6> throwing exceptions is definitely the more complicated option
11:49:19 <monochrom> I would still go the the lesser evil: Maybe or Either or my algebraic data type.
11:49:55 <monochrom> The reason why, the only reason why, this looks "more" complicated is only because you didn't think it up.
11:50:08 <monochrom> not-invented-here is a very strong emotion.
11:50:29 <monochrom> not-invented-here leads to fear. fear leads to anger.
11:50:49 <maerwald> it also leads to socializing with similarly angry people
11:51:06 <sheepfleece> But I already have to catch the same exception from an impure part of my code. So I would have to do both then. 
11:51:06 <sheepfleece> And those functions are only used there.. Is it really not an option to put them inside IO? 
11:51:06 <sheepfleece> And then use something like `traverse`.
11:52:11 <monochrom> It's your code.
11:52:22 <koz_> sheepfleece: You can write everything with unsafePerformIO if you want.
11:52:26 <koz_> Doesn't make it a good plan.
11:52:27 <Axman6> of course its an option it's just not a good one IMO
11:53:18 <monochrom> koz_: I just saw an article that says "start with that, restrict later". Not sure what you make of it. :)  It's listed in the Haskell Weekly News yesterday.
11:53:33 <koz_> Wait wat.
11:53:41 <koz_> Also I just realized I missed Haskell Weekly this week.
11:53:43 <koz_> Bad me.
11:53:56 <mniip> start with ___ improve never
11:54:24 <monochrom> Here: https://williamyaoh.com/posts/2020-04-19-permissive-vs-restrictive.html
11:54:25 <sheepfleece> Okay, I will use Maybe. :3
11:55:11 <monochrom> Hell, I am not even sure what I make of it.
11:56:40 <merijn> tbh, I don't disagree
11:57:24 <merijn> I kinda like starting out with "ReaderT EntireProgramConfig IO" and people complain that "that's just as bad as global mutable state!"
11:57:44 <monochrom> Although, it only says "start with IO" for the most part.  The mention of unsafePerformIO is only for "unsafePerformIO (newIORef ...)" to obtain a global variable (but you will re-do it properly lateer)
11:57:52 <merijn> Which, first of: bollocks, second of all, it makes it easy to change how the inner-most code works without having to propagate those changes through 8 layers of code
11:58:27 <merijn> It's much easier to make a nicer API when the core has started crystallising a bit and Haskell being easy to refactor is like one of the reasons why liked this stuff!
11:59:16 <monochrom> Yeah. Basically: For people who will actually throw away prototypes and re-do properly after learning from prototypes, I recommend prototyping (and being relaxed during it).
11:59:29 <monochrom> But most programmers are too afraid to delete code.
11:59:47 <monochrom> Perhaps we should just delete those programmers.
12:00:28 <Axman6> I'm literally writing a web server at the moment which has ReaderT (IORef SharedAppState) IO as its core. eventually it'll use a database but for now it's nice to test things in servant for read
12:02:47 <merijn> monochrom: It also depends a bit, but for stuff like "your database interaction" I think it's useful to start off overly permissive as you probably will use that all over the code and updating everything *every* time you change how you work the database when you're starting out wastes a lot of time
12:03:23 <merijn> monochrom: The broader the use over your code, the more permissive your initial version has to be if you wanna get anything done and not spend 80% refactoring boilerplate
12:09:33 <solonarv> sheepfleece: if you have exceptions-from-pure-code squirreled away inside a data structure, yes deepseq is the way to make sure they are all actually thrown.
12:09:44 * hackage par-traverse 0.2.1.0 - Traverse a directory in parallel  https://hackage.haskell.org/package/par-traverse-0.2.1.0 (vmchale)
12:09:52 <solonarv> combine with 'evaluate' to turn them into IO exceptions that you can 'catch' normally.
12:10:13 <solonarv> oops, was scrolled up
12:11:14 * hackage perceptual-hash 0.1.3.5 - Find duplicate images  https://hackage.haskell.org/package/perceptual-hash-0.1.3.5 (vmchale)
12:19:51 <koz_> I was looking at https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle-FD.html#v:mkHandleFromFD - what exactly is FD here? Is that just a synonym for CInt, or is there more to it?
12:22:15 <Zero96> hello
12:22:20 <dsal> koz_: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.FD.html
12:22:33 <ski> hello Zero96
12:23:09 <koz_> dsal: Is that module exported by base?
12:23:31 <dsal> I don't know.  I just followed through your link because I thought it was strange.  Now I think it's more strange.
12:25:14 <Zero96> i was wondering if you guys can help me to learn Haskell, i took a course about this language and isn't working. I am following this book or guide http://learnyouahaskell.com/introduction
12:25:58 <Zero96> i know how to program in java  and python but is really hard for me the functional aproach
12:26:15 <koz_> dsal: I guess I can use the legacy API which uses a CInt.
12:26:20 <koz_> Nicer with inline-c anyways.
12:27:19 <dsal> Zero96: unlearning java can be a bit uphill.  I haven't seen many good reviews for that particular resource.
12:28:24 <koz_> I think everyone speaks highly of the Hutton book.
12:28:24 <yushyin> Zero96: I would try a different resource, maybe 'Programming in Haskell' by graham hutton
12:28:32 <yushyin> koz_: ;)
12:28:35 <koz_> yushyin: Lol.
12:28:35 <ski> @where PIH
12:28:35 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
12:28:52 <sm[m]> @where HTAC
12:28:52 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:29:03 <ski> LYAH tends to not be that recommended, any longer, around here
12:29:14 <sm[m]> argh.. <gun drops from hand>
12:29:38 <monochrom> Please don't drop a gun. It may misfire.
12:29:58 <ski> Zero96 : learning a new programming paradigm will be a bit like learning to program from scratch all over again
12:30:42 <monochrom> Zero96: My http://www.vex.net/~trebla/haskell/prerequisite.xhtml sets your mindset in the right direction.
12:30:43 <solonarv> koz_: a FD is a file descriptor (from C/Unix-land), which is indeed just an int.
12:31:13 <koz_> solonarv: That's not what the thing dsal linked says.
12:31:21 <koz_> In there, the FD has a bunch of other stuff to it.
12:31:35 <koz_> (again, I can use the legacy API, if I could figure out wtf each of its args was)
12:31:47 <solonarv> oh, I got it mixed up with Fd from the 'unix' package
12:31:53 <monochrom> Not a big bunch, only a small bunch.  One more CInt, and the content depends on windows vs unix.
12:32:10 <koz_> monochrom: How do I make one though? I don't think that module is exported.
12:32:15 <monochrom> (i.e., notice the #ifdef)
12:32:32 <monochrom> I strongly believe it is an internal module.
12:33:41 <monochrom> about only GHC.IO.Handle.handleToFd
12:35:50 <solonarv> Zero96: also, if you have specific questions feel free to ask them either here or over in #haskell-beginners
12:37:14 * hackage unicode-tricks 0.7.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.7.0.0 (wvanonsem90)
12:50:14 <Zero96> Thanks to all gonna give a try to all your advise
13:07:35 <frdg> is it correct to say that pure heavily relies on type inference?
13:08:16 <solonarv> I guess? that's not exactly unusual, though
13:08:27 <koz_> By that logic, so does fmap.
13:08:48 <frdg> solonarv: ya it wasn't my most profound realization
13:09:14 <frdg> thanks though
13:12:47 <koz_> Am I missing something? http://hackage.haskell.org/package/heyting-algebras-0.0.2.0/docs/Algebra-Boolean.html#t:BooleanAlgebra doesn't list Predicate a, and I think it should.
13:14:30 <solonarv> koz_: looks like an oversight to me
13:14:41 <solonarv> since Predicate ~ Op Bool, and there is an instance for Op Bool
13:15:26 <koz_> solonarv: I believe it's an oversight in one of its underlying libraries, since there's a _lot_ of typeclasses you gotta be a member of.
13:15:34 * koz_ shuffles off to report.
13:17:15 <Nolrai> So if i fork a thread that is atomicly modifying an ioRef, and waid on user input in the main thread, then read the ioRef, do stuff, and exit, should I throwTo the worker thread before exiting?
13:18:09 <monochrom> You don't have to. When the main thread dies. the whole process dies.
13:18:22 <monochrom> The opposite of Java.
13:18:41 <Nolrai> Thanks!
13:19:19 <monochrom> However! If the other thread has important cleanup code to run before it can safely die, this mechanism doesn't run that cleanup code.
13:20:06 <Nolrai> Hmm. It doesn't yet.
13:20:51 <solonarv> actually, what sort of cleanup code would even need to run on program close?
13:21:04 <solonarv> I guess deleting temp files or gracefully terminating network connections
13:21:11 <monochrom> Perhaps the other thread has a buffer to flush for example.
13:21:20 <monochrom> Yeah, those too.
13:21:44 <monochrom> We understand that if it's merely malloc and free, no one cares except valgrind :)
13:25:55 <Nolrai> Why does atomicModifyIORef take a action of type (a -> (a, b)) and not just (a -> a) like modifyIORef?
13:27:05 <monochrom> To compute b from the old a, which would be inaccessible otherwise.
13:27:37 <frdg> im very new to installing/using libraries. I am trying to download Checkers. I tried to `cabal install` it but it didn't work out. I also tried to add `Checkers` in the build depends portion of my .cabal file, also did not work out. In the past ive `runhaskell Setup ...`'d everything but ive been told they're are better ways.
13:27:45 <Nolrai> Oh, I see.
13:28:28 <monochrom> So for example you get the same power as compare-and-swap.
13:28:34 <frdg> the reason cabal install didn't work is because "Cannot build the executables in the package checkers because it doesnot contain any executables"
13:36:06 <solonarv> frdg: indeed. 'cabal install' is for installing executables.
13:36:12 <solonarv> what do you want to do with Checkers?
13:36:24 <frdg> solonarv: my book requires I install it
13:37:20 <Nolrai> I mean "installing" is not really how libraries work in modern package management in haskell, per se.
13:37:26 <solonarv> indeed.
13:37:54 <solonarv> do you want to use it as part of a package? then add it to the appropriate 'build-depends' field.
13:38:09 <solonarv> do you just want to experiment with it in ghci? 'cabal repl -b packagename'
13:38:58 <mastarija> Hi guys. I remember asking about FRP and networking in multiplayer games some time ago. I'm doing a master's thesis on that topic and someone suggested that FRP is not really suited for that and that that approach could waste a lot of bandwidth, I didn't really ask more about it that time. Can maybe someone explain why that could be? As it stands now, I don't really see why such problem could occur.
13:39:07 <frdg> solonarv: I want to use it as part of a package. Ill read the readMe to see what I have to say in my build-depends
13:39:08 <MarcelineVQ> does your book say how to get checkers?
13:39:34 <frdg> MarcelineVQ: no, I think its some kind of an exercise to not tell me
13:40:18 <dsal> ha.  I just mostly live in stack.  That kind of stuff is mostly easy.
13:40:36 <mastarija> Also, since it's maybe a different crowd this time around, could anyone suggest a good paper on that topic. I've searched far and wide and haven't found anything in that area.
13:40:39 <solonarv> mastarija: I think FRP has a bit of a hard time dealing with the "make a guess on the client, then when you get an authoritative answer from the server rewind time and correct the game state" thing that's usually used to compensate for lag.
13:40:39 <dsal> It's still pretty awesome to me that I can use this much CPU to upload two files. https://usercontent.irccloud-cdn.com/file/NIQndFn6/upload.png
13:40:44 * hackage miso 1.5.1.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.5.1.0 (DavidJohnson)
13:41:13 <solonarv> frdg: do you already have a pkgname.cabal file?
13:41:23 <frdg> solonarv: yes
13:41:44 * hackage miso-examples 1.5.1.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.5.1.0 (DavidJohnson)
13:41:46 <mastarija> solonarv, but from what I see it's quite easy to do it, especially since everything is deterministic and received inputs can be "patched" since all of them are timestamped.
13:42:14 <MarcelineVQ> frdg: Did it perhaps tell you how to get libraries earlier in the book? in some kind of Building Projects chapter? :>
13:42:16 <solonarv> I guess it depends on the FRP library
13:42:19 <dsal> I just remembered I'm not using pread there.  that part sucks.  Haskell needs pread.
13:42:30 <solonarv> I think most FRP libraries are not set up to make this sort of thing easy
13:42:34 <mastarija> solonarv, Yampa is what I'm currently looking at
13:42:38 <solonarv> so instead it will be hard
13:42:45 * solonarv has only superficially glanced at yampa
13:43:17 <dsal> Does Windows not have something like pread?  I'm curious why I had such a hard time trying to find an implementation before I finally gave up.
13:43:35 <frdg> MarcelineVQ: it just showed me how to add QuickCheck and hspec to my build-depends
13:43:47 <dsal> frdg: You can add checkers, too, perhaps.  :)
13:44:02 <mastarija> solonarv: I don't expect it to be easy to implement, idea seems doable, but I'm concerned about the whole "latency/ bandwidth" thing.
13:44:55 <mastarija> I mean, sure there's the whole "timestamp" besides just the input but it doesn't seem like that much extra payload.
13:47:47 <frdg> solonarv: so I added checkers to my build depends (tried both capitalizations), yet its still not recognizing my import. The book seems to explicitly say I need to install it, "After installing checkers, we can reuse the existing properties." 
13:48:38 <frdg> though of course it may just be lazy/unclear wording
13:49:36 <MarcelineVQ> it does say that, and it's not exactly wrong since there's a few ways to get a library, but assume it's telling you to add it to your build depends in a project in this case since that's what the book has intended so far
13:50:09 <frdg> MarcelineVQ: ok
13:50:27 <dsal> How did you install QC and hspec?
13:50:37 <dsal> This is one of those things where stack just kind of does the magic, I guess.
13:50:44 <solonarv> frdg: okay, you've added it to your build-depends. how are you running your code / running GHC?
13:50:54 <solonarv> dsal: stack and cabal are equally "magical" in this way
13:51:10 <dsal> I don't have much experience using cabal directly.
13:51:23 <solonarv> in fact cabal is slightly *more* magical because it writes a special file that makes bare 'ghc' invocations pick up your package's dependencies.
13:51:26 <solonarv> stack doesn't do that
13:51:29 <MarcelineVQ> dsal: you just write  cabal build  instead of  stack build  :>
13:51:43 <dsal> I checked in a cabal file from one of my stack projects and tried the default github action and it failed.
13:51:46 <frdg> I just have it in a vim file and I can't compile into ghci
13:51:48 <dsal> That's how much I know about the world.
13:52:38 <frdg> "could not find module Test.QuickCheck.Checkers"
13:55:34 <solonarv> dsal: does your cabal file have version bounds?
13:59:57 <enthropy> are you supposed to make a local repository for cabal if you want to install a package that's not quite like the one on hackage? It used to be that you could "cabal unpack dbus; cd dbus; ..make the fix..; cabal install". That part is successful, but when I want to install something else cabal goes back to the hackage dbus package
14:02:46 <solonarv> enthropy: installing libraries in a "global" fashion isn't really the default workflow anymore.
14:03:26 <glguy> You can still unpack the packages and add them to your cabal.project's packages:
14:03:28 <alp> you can write a cabal.project file that lists your package as well as other ones in the "packages:" field. you can point to local directories, git repos, ...
14:03:38 <solonarv> so, if the package you want to use a modified version of is an executable, you can still 'cabal install' it from within the modified source directory ('cabal install' is for executables)
14:03:40 <glguy> The default cabal.project looks in subdirectories for cabal files
14:03:44 * hackage box-tuples 0.2.0.0 - A hack to use GHC.Prim primitives in GHCi  https://hackage.haskell.org/package/box-tuples-0.2.0.0 (mniip)
14:04:02 <alp> enthropy, https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html should get you up to speed
14:05:21 <frdg> https://pastebin.com/5b4fFHJ5 in case your wondering what my files look like. I can always go the runhaskell Setup route as well but this is very strange to me
14:06:05 <solonarv> frdg: you still haven't said how you are running your code.
14:06:59 <solonarv> but also: the 'executable functor-examples' stanza says that your code is in the 'src/' directory (which is relative to the cabal file); but your module Applicatives1 isn't in that directory!
14:07:29 <frdg> solonarv: this has to be the issue
14:07:39 <solonarv> frdg: that is only part of the issue
14:07:54 <solonarv> frdg: how are you actually compiling/running your code? what is the command you are running?
14:08:32 <frdg> so in my vim file it points out that it doesn't recognize the file. And then in ghci I run `:l Applicatives1` and it can't compile
14:08:53 * solonarv sighs
14:09:07 <solonarv> how are you running ghci?
14:09:33 <frdg> solonarv: I just say `ghci` from the directory that this stuff is in
14:10:05 <solonarv> frdg: aha! there's your problem
14:10:28 <frdg> !
14:10:34 <solonarv> if you don't run cabal, how is cabal supposed to figure out it needs to fetch, build, etc... 'Checkers'?
14:11:04 <solonarv> so, first step: make sure your source files actually are in the directory that pkgname.cabal says they are in
14:11:20 <solonarv> second step: instead of running a 'raw' ghci, run 'cabal repl'
14:11:57 <frdg> things are happening
14:13:50 <frdg> it worked! Thanks so much that must have been painful!
14:14:44 * hackage box-tuples 0.2.0.1 - A hack to use GHC.Prim primitives in GHCi  https://hackage.haskell.org/package/box-tuples-0.2.0.1 (mniip)
14:14:45 <solonarv> it was a bit painful how I had to repeat my question three times, yes :p
14:15:25 <frdg> *frdg was confused
14:16:54 <frdg> * is this how you do it
14:16:58 <frdg> ...no
14:18:47 <ski> /me understands
14:18:52 * ski understands
14:18:55 <ski> frdg ^
14:19:14 <hpc> and for completeness
14:19:19 <hpc> / /me understands
14:19:28 <hpc> is how you don't do the /command
14:21:23 * frdg can I do this in one try
14:21:35 * frdg frog can
14:21:42 <frdg> gosh im leaving bye
14:22:15 * hackage box-tuples 0.2.0.2 - A hack to use GHC.Prim primitives in GHCi  https://hackage.haskell.org/package/box-tuples-0.2.0.2 (mniip)
14:24:01 <mniip> third time's the charm
14:25:00 <Uniaika> haha
14:28:25 <mniip> hmm, what happened to the 8.x on the matrix ci
14:42:15 * hackage retry 0.8.1.2 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.8.1.2 (MichaelXavier)
14:59:42 <CrazyPython> https://gist.github.com/CrazyPython/67ade8f22d90043925a83a1afa86a307 How do I change this code so that "fail" results in Applicative empty?
15:00:58 <maerwald> Are you talking about line 12?
15:01:12 <CrazyPython> Yes.
15:01:32 <maerwald> Why don't you use guard?
15:01:52 <monochrom> Yeah I don't understand where is fail in this code.
15:02:02 <CrazyPython> I want to make pattern matching failures result in the equivalent of "guard False." (empty)
15:02:17 <monochrom> Where is the pattern matching?
15:02:21 <peutri> almost literally? instance MonadFail [a] where fail _ = empty
15:02:28 <peutri> but sme, i see no pattern matching
15:02:39 <solonarv> CrazyPython: you don't need to do anything, because the monad you are using is [] and its MonadFail and Alternative instances already do what you seem to describe
15:03:27 <CrazyPython> peutri: I think that's what I need, but GHC tells me duplicate instance declarations.
15:03:34 <peutri> yeah it's already in
15:03:44 <peutri> i never remember which ones are there and which ones aren't
15:04:07 <peutri> so back to solonarv's version: nothing needs be done
15:04:33 <CrazyPython> solonarv: when a bottom is encountered, Haskell throws an error. Instead, I want it to "convert" the error into an empty, in other words, it should skip all pythagorean triples where 4 is "y"
15:04:53 <peutri> well guard False *there*
15:05:02 <dsal> solonarv: (re: version bounds), yeah, this is the one I tried:  https://github.com/dustin/mqtt-hs  The failure looked kind of dumb to me:  https://github.com/dustin/mqtt-hs/runs/612996246?check_suite_focus=true
15:05:04 <monochrom> guard (y /= 4)
15:05:12 <solonarv> yes, exactly. don't use undefined in the first place.
15:05:16 <dsal> I was just trying the github suggestion for a haskell action.
15:05:30 <monochrom> And undefined has nothing to do with pattern matching or fail.
15:05:44 <monochrom> So once again misdiagnosis.
15:06:04 <solonarv> dsal: oh bleh, I guess the default github action is just bad.
15:06:18 <dsal> That's what I assumed.
15:06:40 <CrazyPython> Okay, to clarify, I want to turn any pattern matching failures / bottoms / infinite loops / erors inside my "do" into "empty."
15:06:52 <peutri> that's not going to be so easy
15:07:04 <solonarv> infinite loops? whoa there! do you have a halting oracle plugged into your computer?
15:07:34 <monochrom> This is XY problem raised to the power of 11.
15:07:39 <solonarv> dsal: for comparison, here's the GH action for my blog (which runs on haskell and compiles with cabal): https://github.com/Solonarv/solonarv.github.io/blob/source/.github/workflows/build-and-deploy.yml
15:07:52 <monochrom> What's wrong with KISS guard (y /= 4)
15:08:23 <dsal> I just learned about github actions yesterday.  I've got one working with stack.  I kind of want to figure out the nix one as well.  cabal itself doesn't work for me on this machine.
15:08:43 <CrazyPython> I'm using Haskell to make a story. At each time step, the program produces a list of possible choices. Some choices will lead to runtime errors. When an error is encountered, I want to filter away the choice from the list.
15:08:59 <dsal> cabal wants to find ghc, which isn't in my path.
15:09:12 <monochrom> I'm out of this mess.
15:09:19 <CrazyPython> solonarv: the halting problem is only unsolvable in the general case
15:09:42 <peutri> if your case isn't general you're going t have to convince the compiler
15:10:58 <peutri> that's for infinite loops
15:11:06 <dsal> In the AoC, I solved a special case of the halting problem in my VM by giving it a fixed amount of instructions.  If it can't get the job done in X instructions, it doesn't work.
15:11:14 <peutri> pattern match fail -> already taken care of (but you don't have any in your sample)
15:11:24 <CrazyPython> hmm
15:11:35 <peutri> errors -> no general case, but staying out of IO and avoiding partial functions will do most of it
15:11:52 <peutri> bottoms... i don't know jow to start on this
15:12:06 <monochrom> But it is not going to be "general" bottom.
15:12:23 <monochrom> It is always going to be "if foo then undefined else return bar"
15:12:40 <monochrom> Therefore it's simply "guard foo"
15:12:44 <CrazyPython> f False x y z = (x, y, z)
15:12:44 <CrazyPython> pythags = do
15:12:44 <CrazyPython>   z <- [1..]
15:12:45 <solonarv> you can catch bottoms that throw an exception if you are working in IO. but that is a bit cumbersome to do, and there is pretty much always a better way to accomplish what you're actually trying to do.
15:12:46 <CrazyPython>   x <- [1..z]
15:12:48 <CrazyPython>   y <- [x..z]
15:12:50 <CrazyPython>   guard (x^2 + y^2 == z^2)
15:12:52 <CrazyPython>   -- how do I implement "fail" of MonadFail so errors turn into "guard False"?
15:12:54 <CrazyPython>   return $ f (y == 4) x y z
15:12:56 <CrazyPython> main = print $ head pythags
15:13:02 <monochrom> I don't even undeerstand the logic behind the XY problem.
15:13:12 <CrazyPython> How do I turn empty pattern matches into empty?
15:13:25 <peutri> what's an empty pattern match?
15:13:26 <dsal> What's an empty pattern match?
15:13:33 <koz_> What's an empty pattern match?
15:13:34 <CrazyPython> Sorry, failed pattern match.
15:13:37 <maerwald> I'm getting headache
15:13:50 <monochrom> where is the empty pattern match in that code?  Answer a line number.  Don't give me English BS.
15:13:53 <CrazyPython> It should be a simple matter of reimplementing a newtype wrapper round list with a different "instance MonadFail," correct?
15:14:10 <maerwald> Where did newtypes enter the picture?
15:14:10 <peutri> it could
15:14:19 <iqubic> What do you mean by empty?
15:14:22 <monochrom> Oh well I said I'm out of this utter stupidity.
15:14:33 <CrazyPython> line 14 https://gist.github.com/CrazyPython/dde08406137bea6f3f6deb5a0c516e8f
15:14:33 <peutri> it was Alternative.empty in context
15:14:43 <iqubic> Ah. I see.
15:16:09 <peutri> your line 14 isn't a pattern match at all
15:16:17 <peutri> but it does refer to line 6
15:16:32 <peutri> which is a partial function
15:16:34 <monochrom> Is this trolling?
15:16:43 <peutri> "it could" :)
15:16:47 <monochrom> Because for the 3rd time "guard (y/=4)" is just fine.
15:16:52 <koz_> Also, TYPE SIGNATURES.
15:16:56 <CrazyPython> I'm genuinely trying to solve a problem :(
15:17:09 <peutri> but you don't yet understand what your problem is
15:17:17 <CrazyPython> okay, I want to turn non-exhaustive patterns into Applicative.empty
15:17:17 <maerwald> the problem is: not listening :)
15:17:18 <monochrom> Here is a person who knew enough to define "guard" themselves and then use it on line 12.
15:17:38 <monochrom> And then be like utterly refusing to use it for the other test condition.
15:18:05 <peutri> using without understanding?
15:18:06 <monochrom> This is either trolling or hypocrisy.  Take your pick.
15:18:25 <CrazyPython> monochrom: The original line 13 was just a way to demonstrate that I want to convert errors into empty.
15:18:47 <peutri> "errors" is too general
15:19:14 <maerwald> So you have a problem and that code has nothing to do with it
15:19:35 <koz_> If I have a uint32_t coming back from a C function, what Foreign.C.Types type should I marshall it into?
15:19:49 <monochrom> CUInt32
15:20:41 <monochrom> This is promised by the Haskell Report, so it's very robust.
15:20:41 <koz_> Uhh, there is no such type according to Hoogle.
15:20:56 <monochrom> Hrm! I'll find the correct name.
15:21:01 <CrazyPython> I want to implement fail as empty.
15:21:04 <Uniaika> koz_: https://blog.mgattozzi.dev/rust-haskell-ffi-and-a-whole-lot-of-linking/
15:21:15 <koz_> Uniaika: Merci.
15:21:36 <dsal> >  let f True = pure 1; f False = fail "boo" in   do { b <- [False ..]; f b } :: [Int]  -- CrazyPython is it not?
15:21:39 <lambdabot>  [1]
15:21:50 <koz_> Uniaika: Wait, what does this have to do with what I'm trying to do?
15:21:55 <koz_> It's a bunch of stuff about linking and Rust.
15:21:58 <monochrom> I think it's Word32 but let me check the Haskell Report agian
15:22:14 <Uniaika> koz_: utterly unrelated, you can thank my ADHD
15:22:18 <koz_> Wouldn't it be Word32# then?
15:22:25 <koz_> Uniaika: Merci, Uniaika's ADHD.
15:22:27 <monochrom> Yeah Word32.  # not needed.
15:22:37 <koz_> Hmm, OK.
15:22:48 <koz_> I'm a bit surprised, but OK.
15:22:49 <CrazyPython> dsal: interesting
15:22:54 <Uniaika> koz_: it says "de rien" :)
15:22:55 <monochrom> Table 8.2 has "Word32" "unsigned integral type, 32 bit; uint32_t if available"
15:22:59 <MarcelineVQ> CUInt is Word32
15:23:15 <MarcelineVQ> https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-C-Types.html
15:23:43 <monochrom> Don't add # because it is the FFI's proud job to convert between primitives to boxed types :)
15:23:44 <CrazyPython> Do non-exhaustive patterns trigger fail?
15:23:58 <peutri> only when they happen
15:24:12 <peutri> ...happen to miss, that is
15:24:22 <dsal> >  let f True = pure 1 in   do { b <- [False ..]; f b } :: [Int] 
15:24:24 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in function f
15:24:30 <koz_> Uniaika: My French is too weak to figure out what that means.
15:24:56 <peutri> it's the usual retort to "merci"
15:25:02 <Uniaika> koz_: yer welcome :)
15:25:07 <Uniaika> (that's what it means)
15:25:19 <Uniaika> or, more exactly, "it was nothing"
15:25:35 <koz_> Uniaika: Thanks - TIL. This is a much more useful phrase than 'chainsaw'.
15:25:56 <CrazyPython> dsal: why does the non-exhaustive pattern match not trigger fail in the outer monad?
15:26:31 <dsal> Well, it's bad code.  Better to avoid partial functions.
15:26:39 <dsal> There was a good article recently on haskell exception types.
15:26:40 <peutri> chainsaw back and forth would be a truncator
15:26:41 <peutri> how poetic
15:28:24 <jackdk> Axman6: I was asleep but i see you found semialign-extras
15:28:44 <jackdk> also there's @hackage patch from obsidian
15:28:51 <jackdk> @hackage patch
15:28:52 <lambdabot> http://hackage.haskell.org/package/patch
15:28:56 <jackdk> @botsnack
15:28:56 <lambdabot> :)
15:30:49 <koz_> Does inline-c not recognize uint32_t?
15:31:21 <CrazyPython> dsal: So, what you are saying is I should convert any partial functions into total functions by adding explicit failures
15:31:25 <monochrom> maybe it's a typedef from some *.h file
15:31:36 <koz_> monochrom: Ah, good point.
15:32:03 <koz_> stdint.h
15:32:07 <koz_> I'm clearly rusty at C.
15:32:12 * koz_ is the maintainer of awesome-c.
15:32:34 <ChaiTRex> koz_: It's in stdint.h, I think.
15:32:47 <koz_> ChaiTRex: Yep. I added that include, but I'm still getting issues.
15:32:47 <dsal> CrazyPython: It's hard to argue for functions to not be total in general.  I don't know why you'd want your function to fail, but I don't understand what you're doing.
15:34:21 <koz_> (specifically, this triggers a parse error - [C.pure | bool { $(uint32_t w) == IN_ACCESS }|] )
15:34:42 <koz_> (at $)
15:35:01 <CrazyPython> Imagine you're defining the rules for a board game in a declarative way. Some situations are illegal, which you mark with guard to prevent an action from making to the "valid actions list." The result of some actions are not defined, and you want to disallow not-defined actions by not including them in the valid list. Given a list of possibly valid actions, I want to return a list of valid actions.
15:35:24 <CrazyPython> I thought a clean way to define not-defined actions would be with partial functions.
15:36:01 <dsal> I don't think there's any reason to willfully write a partial function.
15:36:13 <peutri> convenience :)
15:36:24 <solonarv> partial functions are pretty much the opposite of clean.
15:36:30 <koz_> Maybe exists for a reason.
15:37:28 <koz_> monochrom: Ah, I think I see. I don't believe uint*_t is something the default C context in inline-c recognizes.
15:37:37 <koz_> if I'm reading Language.C.Types correctly.
15:38:21 <dsal> peutri: May be convenient to write, but seems rather inconvenient to use.
15:38:51 <monochrom> Yeah my impression is that while modern C standards promise uint*_t, they allow compilers to put them in typedefs in header files, rather than built-in.
15:39:03 <koz_> monochrom: In fact, that's what all the compilers I know do.
15:39:06 <peutri> well i see them as the dynamic typing way
15:39:12 <koz_> In my case, though, it's a bit unpleasant.
15:39:18 <koz_> Since I need to pass w back in.
15:39:27 <koz_> Should I just widen to unsigned long?
15:39:33 <peutri> you can start getting something up and running with them, using fail as an easy way of where it's wrong
15:39:40 <peutri> of *seeing
15:39:42 <dsal> peutri: *shrug*.  It's super easy in haskell to just indicate whether or not you got an answer.
15:39:48 <monochrom> To a large extent, if x86 or x86-64 ABI, you can safely assume uint32_t = unsigned
15:39:51 <peutri> and then type it up
15:40:40 <dsal> You can't use fail in functions, but you can use Left.
15:41:06 <peutri> undefined
15:41:28 <peutri> or a nicer error "this thing not done yet"
15:41:39 <koz_> monochrom: Weirdly, if I replace 'uint32_t' with 'unsigned long', I _still_ get a parse error!
15:42:08 <dsal> Yeah, I use undefined as a TODO.  But if I see that, it's time TODO the thing, not try to figure out how to deal with it.  Or just  `Left "implement the thing"`
15:42:59 <peutri> Left, or Maybe, or throw*
15:43:08 <peutri> i seldom know which one it's going to be until the rest is up
15:43:30 <CrazyPython> imagine you used "undefined" to mark stuff as TODO. imagine your boss rushes in, and says "we need to make a not buggy demo for the trade show IN AN HOUR!!" imagine you wanted to make a library that hid GUI buttons when pressing them would lead to an "undefined" error.
15:43:39 <CrazyPython> is there a way?
15:43:43 <peutri> no
15:43:45 <dsal> No, that's dumb.
15:43:50 <koz_> .... I am daft.
15:43:52 <peutri> change your boss
15:43:55 <koz_> It was due to a bad import.
15:43:55 <dsal> I use undefined *while I'm typing*.  It stays in there for like, 15 minutes.
15:44:24 <koz_> uint32_t is fine.
15:44:46 <dsal> `undefined` makes sense when a function can theoretically be total, but you just haven't implemented it yet.  If it can't theoretically be total, just return a Maybe or Either or something.
15:44:51 <dsal> We have good tools.
15:44:58 <koz_> How do I turn a CBool into a Bool?
15:45:33 <CrazyPython> dsal: I see
15:45:34 <peutri> toEnum?
15:45:53 <koz_> Wait that works?
15:45:57 <CrazyPython> I presume there is no library that wraps a partial function in a Maybe.
15:46:01 <peutri> i dunno
15:46:06 <dsal> CrazyPython: That's a very bad idea in general.
15:46:06 <peutri> it's just my first guess
15:46:19 <dsal> There are "safe" libraries that do specific things.
15:46:27 <koz_> Nope, that won't work - toEnum expects an Int.
15:46:33 <dsal> e.g., https://hackage.haskell.org/package/safe
15:46:33 <oats> > CBool 2
15:46:36 <lambdabot>  error:
15:46:36 <lambdabot>      Data constructor not in scope: CBool :: Integer -> t
15:46:37 <peutri> ouch it's a Word8
15:46:49 <oats> > import Foreign.C.Types
15:46:49 <CrazyPython> I'm imagining using this in an application where poorly defined logic is OK
15:46:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
15:46:57 <oats> dunno how to bot
15:47:06 <oats> :import
15:47:37 <dsal> CrazyPython: You can't bolt on correctness.  It's just easier to fix things.
15:47:40 <koz_> % import Foreign.C.Types
15:47:40 <yahb> koz_: 
15:47:45 <koz_> % CBool 0
15:47:46 <yahb> koz_: 0
15:47:59 <CrazyPython> dsal: correctness DOESN'T MATTER for this application
15:48:01 <koz_> % toEnum . fromEnum . CBool $ 0
15:48:01 <yahb> koz_: ()
15:48:08 <koz_> Huh.
15:48:09 <oats> % CBool 2
15:48:09 <yahb> oats: 2
15:48:11 <oats> rip
15:48:21 <koz_> Yeah... that's a problem.
15:48:24 <oats> % toEnum . fromEnum . CBool $ 1 :: Bool
15:48:25 <yahb> oats: True
15:48:27 <oats> % toEnum . fromEnum . CBool $ 0 :: Bool
15:48:28 <yahb> oats: False
15:48:31 <oats> % toEnum . fromEnum . CBool $ 2 :: Bool
15:48:31 <yahb> oats: *** Exception: Prelude.Enum.Bool.toEnum: bad argument
15:48:34 <oats> D:
15:48:39 <dsal> CrazyPython: *shrug*  then why do you want to bolt it on?
15:48:50 <solonarv> oats: yahb is just an interface to a ghci session. prefix your stuff with '% ' and enter whatever you would type into ghci.
15:48:57 <dsal> You're fighting super hard to avoid doing the simple, safe, easy thing.
15:48:57 <oats> gotcha
15:49:00 <oats> solonarv: cehers
15:49:01 <peutri> so that's as out as the existence of CBool 2
15:49:02 <oats> *cheers
15:49:08 <oats> there's a lot of 4-letter nicks in here
15:49:18 <koz_> Four-letter words are best words.
15:49:22 <dsal> Why do you guys keep misspelling CoBol?
15:49:35 <peutri> ENOTENOUGHCAPITALS
15:49:49 <oats> do you mean cabal?
15:49:56 <oats> CBaal
15:50:13 <oats> % listDirectory
15:50:13 <yahb> oats: ; <interactive>:59:1: error:; * No instance for (Show (FilePath -> IO [FilePath])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
15:50:14 <dsal> % type CBaal = CBool
15:50:14 <yahb> dsal: 
15:50:26 <oats> % listDirectory "/"
15:50:27 <yahb> oats: *** Exception: /: getDirectoryContents:openDirStream: does not exist (No such file or directory)
15:50:45 <dsal> / doesn't exist?  Neat.
15:50:50 <oats> % listDirectory "./"
15:50:50 <yahb> oats: [".ghc","tmp"]
15:50:58 <oats> I am  h a x
15:51:05 <monochrom> koz_: Haskell's Bool is marshalled automatically to C int.
15:51:10 <oats> hope that bot is properly secured lol
15:51:17 <dsal> % listDirectory "../../../../../.."
15:51:18 <yahb> dsal: *** Exception: ../../../../../..: getDirectoryContents:openDirStream: does not exist (No such file or directory)
15:51:32 <monochrom> C's bool, I think neither GHC nor Haskell Report have thought of that.
15:51:32 <solonarv> lambdabot on the other hadn is a more complicated beast. '> ' followed by an expression will evaluate that expression and print the result. '@let ' or '?let ' let you add definitions. '@type ', '?type ' or ':t ' let you ask for the type of an expression.
15:51:55 <oats> I feel like a locked down subset of haskell would actually make for a *great* and *fun* general-purpose IRC bot
15:52:06 <solonarv> oats: that's exactly what lambdabot does
15:52:06 <dsal> Isn't that what lambdabot is?
15:52:16 <oats> yeah, but libraries for quotes and factoids and stuff
15:52:27 <oats> and then the main interface to the bot is just ghci
15:52:38 <oats> but with the dangerous IO stuff removed
15:52:51 <dsal> :t unsafeIO
15:52:51 <oats> maybe that's yahb, I dunno, haven't really used it
15:52:52 <lambdabot> error: Variable not in scope: unsafeIO
15:53:27 <dsal> I think lambdabot doesn't have unsafe IO.  Just regular, safe IO.
15:53:39 <oats> :t putStrLn
15:53:39 <monochrom> > putStrLn "<IO ()>"
15:53:41 <lambdabot> String -> IO ()
15:53:41 <lambdabot>  <IO ()>
15:53:45 <oats> > putStrLn "howdy"
15:53:47 <lambdabot>  <IO ()>
15:53:55 <oats> neat
15:54:17 <solonarv> yahb runs IO and lets yuo access unsafePerformIO and friends. it lives in a ptrace jail so you (hopefully) can't break anything.
15:54:32 <oats> living on the edge, nice
15:54:47 <monochrom> think inside the box
15:54:49 <oats> I'd like to learn more about these ptrace jails
15:54:54 <oats> for reasons
15:55:39 <dsal> yahb was wrongly convicted.
15:56:22 <monochrom> Or rather, don't call it jail.
15:56:30 <monochrom> "walled garden" :)
15:56:30 <oats> % getCurrentDirectory
15:56:31 <yahb> oats: "/srv/sandbox/root/data"
15:56:50 <dsal> walled garden does sound prettier.  ptrace silo
15:57:12 <monochrom> ptrace social distancing
15:57:16 <dsal> ptrace retirement community
15:57:25 <koz_> :t ($>)
15:57:26 <lambdabot> error:
15:57:27 <lambdabot>     • Variable not in scope: $>
15:57:27 <lambdabot>     • Perhaps you meant one of these:
15:57:34 <koz_> % :t ($>)
15:57:34 <yahb> koz_: Functor f => f a -> b -> f b
15:57:46 <dsal> % :t (*>)
15:57:47 <yahb> dsal: Applicative f => f a -> f b -> f b
15:58:01 <peutri> so what *is* a ptrace jail?
15:58:05 <koz_> % :t \w -> guard (w == 3) $> w
15:58:05 <yahb> koz_: (Alternative f, Eq b, Num b) => b -> f b
15:58:15 <koz_> Yep, that's the incantation I need.
15:58:42 <monochrom> ptrace allows a controller process to intercept syscalls made by the controlled process.  There are other non-social-distancing things ptrace allows to do.
15:58:59 <koz_> % :info ($>)
15:58:59 <yahb> koz_: ($>) :: Functor f => f a -> b -> f b -- Defined in `Data.Functor'; infixl 4 $>
15:59:24 <peutri> oh, by implementing filters on all syscalls
16:02:06 <monochrom> oh actually the controllee is at the thread granularity, not process granularity
16:02:26 <monochrom> <-- just starting to read the man page now
16:04:25 <dsal> Someone linked to a thing that did plan9-bind-style path rewriting using ptrace recently.  Now I've lost it forever.  I do wish that were a generally available thing for all computers.
16:09:34 <enthropy> mniip, I've added the bug from a few hours ago https://gitlab.haskell.org/ghc/ghc/issues/18097
16:41:35 <dmwit> koz_: I call that `ensure`, and I find it useful in an unreasonable number of projects.
16:41:48 <dmwit> ensure p x = x <$ guard (p x)
16:42:15 <koz_> dmwit: Yes, agreed.
16:55:23 <monochrom> Is that the same as guard (p x) *> pure x ?
16:56:02 <monochrom> It's a bit surprising that in most cases the "pure x" part is useful :)
16:56:36 <monochrom> Ah wait, no, not surprising.  I even gave my student a similar assignment!
17:01:53 <dmwit> monochrom: The same, but potentially more efficient.
17:02:17 <oats> :t (*>)
17:02:19 <lambdabot> Applicative f => f a -> f b -> f b
17:02:27 <oats> oh right, it's basically applicative >>
17:03:06 <monochrom> Ah some laws say it's simplifiable to fmap
17:03:20 <oats> monochrom: ooh, what do you teach?
17:03:22 <dmwit> (<$) is fmap + const
17:03:27 <monochrom> Yeah
17:03:48 <monochrom> a "principle of programming languages" course butchered to the point there is too much FP in it :)
17:03:53 <MarcelineVQ> dmwit: I've heard that [ensure] called  guarded  as well, can't recall by whomst'd've'n't though
17:04:09 <dmwit> "n't" RIGHT TO JAIL
17:04:19 <monochrom> But my assignment had students implement a simple imperative non-deterministic language!
17:04:25 <dmwit> wait
17:04:32 <dmwit> Turns out I'm an idiot! o no
17:06:48 <MarcelineVQ> 🅱️lease no jail
17:06:59 <monochrom> So one of the test cases begins as a choice of "x := -5 or x := -4 or ... or x:= 5", following by "assert (x satisfies the given cubic equation)"
17:08:27 <monochrom> And implicitly x is an answer to the problem "solve that equation", so if translated to Haskell it would be do { x <- [-5 .. 5]; ensure (\x -> x satisfies that equation) x }
17:10:45 <juri_> ok, i think i've been up too long. i have a data that does not have a constructor that has the same name as it. how do i export this so that i can use the data in declaring a function?
17:11:31 <monochrom> module MyModule(MyType(..))  but I don't really understand the question.
17:11:44 <dsal> juri_: What do you mean?  There's not necessarily a relationship between the type and the constructors.
17:12:19 <monochrom> I'm watching Game of Thrones recently.
17:12:32 <juri_> yeah, i get that, and for functions within the module, i can use the type in my type definitions, but i can't seem to export it.
17:12:49 <monochrom> I wish someone here can be a warg, except for beginners rather than animals.
17:13:18 <monochrom> We direly need to have someone see the computer display of the beginner so we know what they're really talking about.
17:13:31 <juri_> https://gist.github.com/julialongtin/ed5b335f619b050da9500625c66a70de
17:13:44 <juri_> that's what i'm trying, and failing at.
17:14:00 <monochrom> Slope(IsOrigin, OnXAxis, OnYAxis, HasSlope)
17:14:22 <monochrom> Or be lazy, Slope(..) so nothing to change in the future.
17:15:09 <juri_> sure. and when i import that module, i get... hmm. ok, maybe i've got it.
17:16:23 <juri_> yep. been awake too long. :)
17:31:19 * dmwit . o O ( data Slope = Slope { x, y :: ℝ } -- invariant: x^2 + y^2 = 1 )
17:31:36 <dmwit> And I'm not even sure I want the invariant.
17:33:08 <dmwit> You could also consider using type Slope = PosInf ℝ, I guess.
17:33:55 <monochrom> newtype Slope = Slope { θ :: ℝ }   --- possibly ensure -π < θ ≤ π
17:33:56 <dmwit> (Why not NegInf? I don't know. That would be fine, too.)
17:34:23 <dmwit> monochrom: I like that, too.
17:34:27 <monochrom> :)
17:34:34 <dmwit> Everything about it except the name. ^_^
17:35:41 <dmwit> While we're on the topic: I recently enjoyed the realization that half of all Doubles are between -1 and 1.
17:35:48 <dmwit> What a weird type.
17:36:07 <monochrom> Hrm!
17:36:12 <koz_> dmwit: A large proportion are also NaN.
17:36:42 <koz_> OK, that doesn't quite parse right.
17:37:02 <koz_> I meant 'NaNs also take up a surprising number of possible Double values'.
17:37:24 <koz_> Not 'A large number of values of Double from -1 to 1 happen to be NaN as well'.
17:38:50 <dmwit> Hm. Seems not that many? Something like 2^-53 of them?
17:39:46 <dmwit> Ah, no, my mental arithmetic was backwards. More like 2^-11 of them.
17:40:18 <koz_> dmwit: Isn't it more like 10^15 or so?
17:40:33 <koz_> 2^-11 is 1/(2^11) which I don't think is what you meant.
17:40:41 <koz_> Unless I'm misunderstanding your notation.
17:41:39 <koz_> Also, how do you export pattern synonyms again?
17:42:21 <monochrom> dmwit means 1/2^11 of the 64-bit bit patterns are NaNs
17:42:27 <koz_> Oh, right.
17:42:36 <koz_> Yes, I am misunderstanding then.
17:42:46 * monochrom prefers fractions to percentages.
17:43:45 <MarcelineVQ> what are the odds
17:46:39 <monochrom> the odds are in my favour :)
17:46:50 <monochrom> darn, botched it
17:46:54 <monochrom> the odds are ever in my favour :)
17:47:04 <MarcelineVQ> ever vigilant
17:58:15 * hackage cpkg 0.2.5.3 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.5.3 (vmchale)
18:11:47 <bobbytables> monochrom: Cleary the best way to refer to any float-point number is it's Turing machine number.
18:12:38 <monochrom> No. Church encoding.
18:20:54 <iqubic> aren't Peano numbers just Church encodings for natural numbers?
18:21:51 <monochrom> No, the other way round
18:23:14 * hackage hstar 0.1.0.3 - Haskell version of tar CLI utility  https://hackage.haskell.org/package/hstar-0.1.0.3 (vmchale)
18:26:26 <koz_> I have a pattern synonym like 'pattern Bar <- (\e -> foo e someConstant -> True)'. Can I write this more concisely?
18:26:45 <koz_> I can redefine 'foo' if it would help.
18:28:00 <monochrom> likely "flip someConstant -> True" makes sense. (view pattern?)
18:28:43 <koz_> monochrom: It is a view pattern yes.
18:29:05 <monochrom> err, (flip foo someConstant -> True)
18:31:08 <koz_> Honestly, I am _in love_ with inline-c.
18:34:49 <koz_> How do I break a large pragma across many lines? I have a big {-# COMPLETE ... #-}.
18:36:12 <monochrom> I suspect you just break lines.
18:36:40 <koz_> Wow, it really is that simple. Thanks.
18:37:07 <monochrom> my intuition was "it's just glorified block comments"
18:39:35 <monochrom> I even tried: {-# \n LANGUAGE \n RankNTypes \n , \n BangPatterns \n #-}
18:49:10 <dmwit> > 0.0 * (-1.5)
18:49:12 <lambdabot>  -0.0
18:49:23 <dmwit> hmmmmmm
18:52:08 <monochrom> signed 0 is better than unsigned 0 in the context of the two-point compactification of the reals.
18:53:42 <monochrom> haha that sounds great until you ask why prefer the two-point version to the one-point version
18:54:17 <monochrom> anyway, Java went with unsigned 0 and got hate mails from numerical algorithms people
18:56:20 <shachaf> Why would the two-point compactification of the reals have signed 0?
18:57:27 <monochrom> 1/(1/-inf)) = -inf, 1/(1/+inf) = +inf
19:26:03 <shachaf> Is that how two-point compactification works?
19:26:27 <shachaf> I would expect it to be the reals, plus two points.
19:30:38 <dmwit> First you add two points. Then you compactify.
19:30:46 <dmwit> haha, just kidding
19:34:08 <xcthulhu> How do you prove you can't write `extract : ((a -> b) -> b) -> a` in Coq/Lean?
19:49:12 <dmwit> xcthulhu: https://math.stackexchange.com/q/1370805/139921 seems relevant to your interests
19:52:22 <frogsage> Hello everyone, i'm currently trying to download haskell in MacOs 10.14.6  and i'm prompted with this: 
19:52:33 <frogsage> ghcup: /usr/local/bin: openDirStream: inappropriate type (Not a directory)"ghcup --cache install" failed!
19:52:46 <frogsage> Anybody know how can i fix this? 
20:04:30 <dsal> Is /usr/local/bin a directory?
20:06:15 <dsal> Oh frogsage quit because of the support SLO or something.  I'm going to guess that /usr/local/bin isn't a directory.
20:06:16 * hackage xml-conduit-stylist 2.0.0.0 - Bridge between xml-conduit/html-conduit and stylist  https://hackage.haskell.org/package/xml-conduit-stylist-2.0.0.0 (alcinnz)
20:14:17 <koz_> dsal: SLO?
20:14:43 <dsal> koz_: service level objective.  In this case, mean time to resolution of raised issue.
20:14:53 <koz_> Ah. So, a pun? :P
20:15:23 <xcthulhu> dmwit, looks good.  I want to give a presentation at work about proving `Cont b` isn't a comonad.  I plan to use Kripke semantics, which are equivalent to a special case of the topological semantics you've posted.
20:15:39 <xcthulhu> dmwit, I was just wondering if there wasn't some simple proof I was overlooking
20:16:29 <sheepfleece> I can't clearly tell from a definition, but it seems Free monads are O(n^2) where n is a number of actions. Am I right to assume so? 
20:16:32 <sheepfleece> ` (Free x) >>= f = Free (fmap (>>= f) x)`
20:16:50 <sheepfleece> It's just like prepending to a list: xs ++ [x]
20:17:31 <xcthulhu> sheepfleece, if you use the final embedding you can do better
20:18:45 <sheepfleece> Does it work in a similar vein Huges list does?
20:19:07 <xcthulhu> I am not familiar with Huges lists
20:19:17 <dsal> koz_: Not a pun as much as just like, asking a question and leaving ten minutes after not getting an answer seems like one might be expecting too much.
20:19:35 <xcthulhu> sheepfleece, `newtype Freer f a = Freer (forall m. Monad m => (forall t. f t -> m t) -> m a)`
20:19:38 <koz_> dsal: I was just being silly.
20:19:53 <koz_> I'm not claiming that anyone is entitled to an answer that quickly on an unpaid channel.
20:19:59 <MarcelineVQ> sheepfleece: as you note it's like right-biased appending, so then we just need a dlist for them :> https://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
20:20:14 <MarcelineVQ> *left biased appending
20:20:29 <sheepfleece> xcthulhu: Lists with a type `[a] -> [a]` where concatination is a simple function composition, that means we have O(1) append and prepend.
20:20:39 <sheepfleece> Thank you! I'll read it right now.
20:20:50 <lyxia> sheepfleece: the difference list optimization applied to monads corresponds to the CodensityT monad transformer.
20:21:10 <sheepfleece> The things you learn..
20:21:21 <koz_> lyxia: Or Churching.
20:27:30 <xcthulhu> sheepfleece, Lists like that are in the `DList` package in Haskell.  The final embedding is different, it's like `newtype FinalList a = FinalList (forall r. Monoid r => (a -> r) -> r)`
20:28:26 <xcthulhu> Like DLists, you also have O(1) append for these lists
20:32:04 <xcthulhu> The final embedding for freer monads is the basis for Sandy McGuire's `polysemy` library for algebraic effects.  Sandy actually made changes to the Haskell compiler to optimize final-embedding freer monads.  He has a lot about this on his blog: https://reasonablypolymorphic.com/blog/freer-higher-order-effects/
20:32:43 <MarcelineVQ> aww :(
20:38:22 <sheepfleece> Also is there something like Free Zipper?
20:47:41 <Nolrai> So, I can't atomicly do an IO action on the contents of a IORef?
20:48:49 <Nolrai> Like I have a function of type "A -> IO A" but atomiclyModifyIORef' takes an (a -> (a,b))?
20:51:19 <Nolrai> Sheepfleece: freen in what sense?
20:51:27 <Nolrai> * free
20:53:47 <sheepfleece> In a sense of free monads
20:56:22 <dsal> Nolrai: What do you mean?  Doesn't that do what you're looking for?
20:57:13 <Nolrai> How do I pass a function of type (a -> IO a) to a function that expects a (a -> (b, a))?
20:58:12 <sheepfleece> You can't. I'm not sure what you want, but it seems you want to look into MVars instead of IORefs.
20:58:25 <dsal> Oh you're not trying to use a function there.
20:59:08 <dsal> It looks like you're intending to use an IO action, and not a function.
21:00:49 <koz_> atomicModifyIORef can't reasonably use an IO action.
21:00:55 <koz_> (I don't think)
21:01:35 <dsal> It'd be unreasonable, conceptually.
21:01:54 <dsal> Atomically swap this value with the result of whatever action is being performed here.
21:02:50 <Nolrai> Yeah, what I wanted didn't make sense.
21:02:54 <dsal> A CAS type operation will typically need to be retried, and just retrying an IO action is a bad idea.
21:03:13 <dsal> Nolrai: BTW, are you familiar with STM?  Bigger hammer, but super pleasant.  :)
21:04:01 <dsal> You can have an arbitrary number of such variables and atomically commit changes to them without any regard to order.
21:04:15 <Nolrai> What I want is too run a computation (A -> IO a) and then in another thread access the most recent result.
21:04:26 <Nolrai> * repeatedly run
21:05:31 <dsal> It wouldn't be conceptually different with a TVar vs. an IORef.
21:06:09 <Nolrai> My IO action will take like..several minutes, so I really don't want to run it twice.
21:06:25 <sheepfleece> Then you need to write into IORef in the first thread after completing your action? 
21:06:29 <dsal> You want to store the result, not the action.
21:08:21 <Nolrai> dsal: yeah. I was just geting confused because I reached for modify when its not actually what I want.
21:09:14 <dsal> Yeah, an atomic modification makes sense if you need to perform a transformation, e.g., record the last N results.
21:09:28 <dsal> If you just want to write it, just write it.
21:11:17 <dsal> I think I've only used IORef once.  STM is for me.  :)
21:11:30 <Nolrai> Its really overkill for what I need.
21:11:35 <Nolrai> Like way overkill.
21:11:40 <dsal> How way overkill?
21:12:10 <dsal> You're writing a value in one thread and reading it in another and want to make sure your reads and writes are atomic.
21:12:42 <Nolrai> I am guarentied that with just IORef.
21:13:14 <Nolrai> What STM would give me is atomic "transactions".
21:13:44 <Nolrai> Which if I had multiple work threads, I would probably want.
21:14:11 <Nolrai> Depending on what I was doing.
21:14:30 <dsal> I don't fully understand the memory model of IORefs.  If you're not atomically writing, then you don't have a write barrier.  I assume you won't have an issue with reads from another thread after an atomic write from one, but I haven't fully internalized it.
21:14:36 <dsal> I know what STM does with roughly the same code. :)
21:15:07 <c_wraith> if you don't atomically write to an STRef, readers are never guaranteed to see the new value
21:15:19 <dsal> Are they guaranteed to see a correct value?
21:15:32 <Nolrai> With an IORef?
21:15:41 <c_wraith> Err, yes. IORef
21:16:12 <Nolrai> Maybe I want an MVar then.
21:16:31 <dsal> I guess that's what "The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an IORef, the memory writes that created that value must have occurred from the point of view of the current thread." means
21:16:49 <c_wraith> or just atomicModifyIORef, which does guarantee later readers will see the new value
21:16:55 <dsal> I wouldn't feel comfortable writing multithreadfed code with IORef.
21:17:11 <Nolrai> Its only for very very simple cases.
21:17:16 <dsal> I'd probably use atomicModifiyIORef to read just because I'm paranoid.
21:17:17 <Nolrai> Which my case is.
21:17:19 <c_wraith> I mean, it gets real thundering herd problems anyway
21:18:06 <c_wraith> I've had severe performance problems under heavy concurrent load vanish instantly when changing to an MVar
21:18:31 <dsal> from what?
21:18:46 <c_wraith> atomicModifyIORef is essentially optimistic locking
21:19:11 <int-e> :t Control.Concurrent.MVar.modifyMVar
21:19:12 <lambdabot> GHC.MVar.MVar a -> (a -> IO (a, b)) -> IO b
21:19:29 <c_wraith> read value, calculate new value, atomic exchange pointers of expected old value and new value
21:19:50 <int-e> well it's not quite that bad
21:19:52 <dsal> mvar makes more sense for sharing a thing across threads to me than IORef.
21:19:55 <c_wraith> if there's a lot of contention, that atomic exchange fails a lot - for any number of threads
21:20:01 <int-e> the "calculate new value" just sets up a thunk
21:20:41 <c_wraith> give it enough concurrency, and that's exactly when it can change threads
21:21:24 <c_wraith> (also, runtime things like turning off sigalarm can make it way worse)
21:21:50 <int-e> It should be dominated by the atomic exchange... which can be pretty bad under heavy contention.
21:22:39 <dsal> I don't think I use MVar anywhere either, though.  `atomically . writeTVar` and `readTVarIO` is easy to get started with and I occasionally have to do fancier things.
21:23:13 <c_wraith> STM can end up with the same performance problems under heavy load, unfortunately.
21:24:01 <dsal> Yeah, but most of my use doesn't have a lot of threads doing complicated transactions rapidly.  Most of the time, it's just a few simple reads and writes, or maybe some slightly complicated memory updates.
21:24:01 <c_wraith> if you have high contention on a small number of TVars, you should probably think about how to stripe them.
21:24:22 <dsal> Yeah, that makes sense.
21:25:42 <int-e> I don't know; MVar seems to be an almost perfect fit for "modify a value using IO actions, one at a time, from several threads"
21:26:13 <dsal> Or just leave it somewhere for lots of things to pick up.
21:26:30 <c_wraith> MVar is great if every reference is independent.  When you want to make related updates to several references, that's when STM becomes more necessary.
21:27:00 <dsal> I also compose STM across module barriers, which is ncie.
21:28:21 <int-e> Hmm, but... I'd think that if you need to synchronize IO actions, STM doesn't really solve your potential deadlock problem for you, unless you take all required locks at once (in a single STM transaction).
21:28:53 <c_wraith> that's true.  you still need to make sure everything that needs to be is in the same transaction
21:29:47 <Nolrai> Which you can totaly do.
21:30:02 <c_wraith> this is why the async package exposes the STM versions of a bunch of operations - so you can compose them with other things that need to be in the same transactions
21:30:24 <c_wraith> Nolrai: unless they're coming from libraries that hide the STM in the public interface
21:30:51 <Nolrai> I did not think of that!
21:31:34 <dsal> If all your public interface does is `atomically $` then you do leave users without some opportunities.  I exposed some STM variants of one of my client APIs and immediately found an interesting use for an external module.
21:33:21 <Nolrai> Yeah, you would almost always want to expose that.
22:13:36 <dmwit> It's interesting. There's an abstraction boundary argument for not exposing STM in your API, but a power argument for exposing it.
22:13:48 <dmwit> I don't think it's as straightforward as "almost always want to expose".
22:15:19 <dmwit> For example, I have a library that communicates with a game server, and delivers (at your preference) entire game states or game deltas to you, the user. It's really none of your business that internally I use STM to make sure the things I deliver to you are consistent.
22:16:30 <dmwit> Perhaps someday in the future I will discover I can make it 2x faster by switching to MVar or something; why should you have to rewrite your code just because I'm using some other internal library now?
22:39:25 <dsal> I upgraded stylish-haskell so I could have BlockArguments and now it wants to mangle all my code in new and exciting ways I can't seem to stop.
22:56:10 <c_wraith> that's what you get with opinionated formatters
22:59:32 <dsal> I don't mind the opinions as long as they're the right ones.
23:00:04 <rotaerk> lol
23:15:44 * hackage github-webhooks 0.13.0 - Aeson instances for GitHub Webhook payloads.  https://hackage.haskell.org/package/github-webhooks-0.13.0 (onrock_eng)
