00:09:22 <Poscat[m]> I tried to use http-client-overrides but it can't log multipart/form-data which is what I'm intereted in.
00:12:36 <Amir51> Is there an implementation of immutable queues that allow for easy comparison (equals, not equals). My implementation is made up of 2 stacks https://docs.microsoft.com/en-us/archive/blogs/ericlippert/immutability-in-c-part-four-an-immutable-queue where one is reversed when accessing out-end however because the state of the queue depends on the
00:12:37 <Amir51> order of push/pop operations, I'm having difficulty implementing equality.
00:22:13 <JesseL> <|> can work on Either type?
00:22:27 <JesseL> > (Just 3) (<|>) Nothing
00:22:30 <lambdabot>  error:
00:22:30 <lambdabot>      • Couldn't match expected type ‘(f0 a0 -> f0 a0 -> f0 a0)
00:22:30 <lambdabot>                                      -> Maybe a1 -> t’
00:24:52 <[exa]> JesseL: Just&Nothing is Maybe. Also you dont't need to put the operator in parentheses if used in infix
00:25:48 <JesseL> I need to know a list like [Left a, Right b] contain any Left a
00:26:36 <JesseL> False elem $ fmap isLeft alist?
00:27:00 <[exa]> JesseL: what about 'any isLeft' ?
00:28:20 <JesseL> yeah, you're right
00:28:39 <JesseL> but can Left 3 <|> Right 3?
00:29:21 <[exa]> JesseL: I'm not sure if Alternative instance for Either still exists, but if it does it will preserve the "Right"s not lefts
00:29:51 <JesseL> ok
00:30:23 <[exa]> but there's Either monoid that behaves just like that if you needed it
00:30:30 <[exa]> Left "error" <> Right 2234234
00:30:54 <[exa]> (should give 'Right 2234234' if I didn't forget the > )
00:31:41 <JesseL> > (Just 3) <> Nothing
00:31:44 <lambdabot>  error:
00:31:44 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M340095171449...
00:31:44 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
00:32:25 <[exa]> JesseL: you can use <|> for Maybe, it prevents the ambiguity
00:33:54 <[exa]> (moreover, semigroup over maybe requires that the inner content is also semigroup)
00:35:17 <JesseL> filter isLeft [Left "a", Right "b", Left "c"] == [Left "a", Left "c"]
00:35:34 <JesseL> can I use <> on Left "a" and Left "b" ?
00:35:39 <JesseL> to get Left "ac"
00:35:54 <JesseL> but fmap won't work on Left
00:36:23 <[exa]> no, the instance works in a specific way that reminds treating Lefts as omittable errors
00:36:26 <[exa]> for various reasons
00:36:48 <[exa]> but you can use something easy from Data.Either and concatenate the result
00:36:53 <JesseL> is there a way can make [Left "a", Left "c"] to Left "ac"?
00:37:11 <[exa]> :t concatMap fromLeft
00:37:13 <lambdabot> error:
00:37:13 <lambdabot>     • Couldn't match type ‘Either a b0 -> a’ with ‘[b]’
00:37:13 <lambdabot>       Expected type: a -> [b]
00:37:26 <[exa]> oh noes
00:38:22 <JesseL> foldl1 <> $ fmap fromLeft alist
00:38:32 <MarcelineVQ> [exa]: fromLeft and fromRight are like fromMaybe rather than fromJust, for some reason
00:39:18 <[exa]> yeah always forget about the safety brake :D
00:39:30 <[exa]> > concatMap (fromLeft []) [Left "a", Left "bc"]
00:39:33 <lambdabot>  "abc"
00:39:41 <[exa]> JesseL: you don't even need the filter ^
00:40:16 <JesseL> even the list may contain Right value?
00:40:38 <JesseL> > concatMap (fromLeft []) [Left "a", Right "b", Left "c"]
00:40:41 <lambdabot>  "ac"
00:41:27 <JesseL> update message is Nothing
00:46:25 <JesseL> but what if I need this "ac" to be "a\nc"?
00:47:23 <JesseL> [Left "a", Right "b", Left "c", Left "d"] == "a\n\c\nd"
00:54:02 <JesseL> aha, there's lefts...
00:56:16 <JesseL> > foldl1 (<>) . fmap (<> "\n") . lefts . filter isLeft $ [Left "a", Right "b", Left "c"]
00:56:19 <lambdabot>  "a\nc\n"
00:58:16 <koz_> :t fold
00:58:18 <lambdabot> (Foldable t, Monoid m) => t m -> m
00:58:26 <koz_> Better than foldl1 (<>)
01:08:38 <JesseL> aha
01:11:30 <MarcelineVQ> you don't need to filter isLeft if you're using lefts
01:13:04 <JesseL> ok
01:13:58 <MarcelineVQ> > lefts [Left 1,Right 'a', Left 3]
01:14:01 <lambdabot>  [1,3]
01:14:43 <koz_> > foldMap (\x -> case x of Left y -> y <> "\n" Right _ -> "") [Left "a", Right "b", Left "c"]
01:14:46 <lambdabot>  error:
01:14:46 <lambdabot>      Pattern syntax in expression context:
01:14:46 <lambdabot>          \ x -> case x of { Left y -> y <> "\n" Right ... } -> ""
01:14:56 <koz_> > foldMap (\x -> case x of Left y -> y <> "\n"; Right _ -> "") [Left "a", Right "b", Left "c"]
01:14:59 <lambdabot>  "a\nc\n"
01:15:05 <koz_> :D
01:15:36 <koz_> Actually, that was sloppy.
01:16:09 <koz_> > foldMap (either (<> "\n") (const "")) [Left "a", Right "b", Left "c"]
01:16:12 <lambdabot>  "a\nc\n"
01:16:17 <koz_> :D
01:16:34 <MarcelineVQ> > unlines . lefts $ [Left "a", Right "b", Left "c"]
01:16:37 <lambdabot>  "a\nc\n"
01:16:43 <koz_> MarcelineVQ: Even nicer.
01:17:15 <JesseL> fold . fmap (<> "\n") . lefts $ [Left "a", Right "b", Left "c"]
01:17:47 <koz_> > fold . fmap (<> "\n") . lefts $ [Left "a", Right "b", Left "c"]
01:17:50 <lambdabot>  "a\nc\n"
01:18:39 <MarcelineVQ> fold and fmap is foldMap unsurprisingly
01:19:23 <koz_> MarcelineVQ: The f's fuse. :P
01:20:26 <MarcelineVQ> JesseL: There's lots of ways to write this particular thing as you're seeing, so it's best to go with whatever one is clearest to you
01:21:06 <koz_> inb4 someone lenses it.
01:25:00 <JesseL> ok
01:27:04 <JesseL> read and parse a config file https://paste.ubuntu.com/p/tbMWY5rNdZ/
01:34:29 <JesseL> what is lens?
01:34:42 <JesseL> a lot of people using it?
01:35:30 <maerwald> If you wanna be cool, you better use lens! 
01:37:20 <merijn> https://twitter.com/beroal_cs/status/1245272876070195200
01:40:27 <JesseL> how cool it gonna be?
01:41:29 <merijn> lens is what you get when someone does a bunch of acid while reading math books and thinking how properties (in the python sense) or getters/setters should really have a nicer abstraction :p
01:57:08 <Uniaika> I should do more acid while reading math books
02:16:15 <vilpan> there seems to be a skipped word in https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions - "write a slightly more helper function". If anyone has their mind reading hat on, we could save a few seconds of guessing time per reader of the page.
02:17:11 <koz_> Uniaika: I thought all the cool kids did meth for maths?
02:20:50 <Uniaika> koz_: yeah uh… not a good idea? :D
02:22:34 <koz_> Uniaika: Seemed to work wonders for Erdos.
02:23:32 <LlawlietZzz> Yep
02:33:10 <Uniaika> on the math level or the humane level? :P
02:51:56 <petersen> why does cabal new-repl start in Path_* module....?
02:52:44 <petersen> Is that a cabal 2.4 bug?
02:54:41 <w1n5t0n> hey peeps, does anyone know what method/tools GHC uses for its parsing?
02:55:03 <merijn> w1n5t0n: alex and happy
02:55:15 <merijn> w1n5t0n: Basically flex/bison, but Haskell :p
02:55:44 <merijn> petersen: v2- commands are considerably more solid in 3.0
02:55:58 <petersen> let me try
02:56:14 <merijn> petersen: Also, in 3.0 they're the default, so you can skip the v2-/new- part :p
02:56:29 <w1n5t0n> merijn: thanks!
02:56:58 <petersen> merijn: I see same with cabal-install 3.0 hmm, maybe I need to upgrade my .cabal file
02:58:06 <merijn> w1n5t0n: Relatedly, just this week someone published an ANTLR grammar for Haskell2010
02:58:09 <petersen> Hmm stack does the right thing...
03:00:22 <ph88> how can i put another package as part of my project ?
03:02:43 * hackage holmes 0.3.0.0 - Tools and combinators for solving constraint problems.  https://hackage.haskell.org/package/holmes-0.3.0.0 (i_am_tom)
03:09:08 <fendor> petersen, I think it loads the first module that is specified in a component 
03:09:21 <petersen> aha
03:10:00 <fendor> does that make sense? E.g. you have a "library" and first line is `other-modules: Paths_*`
04:00:52 <maralorn> ph88: What do you mean? 
04:01:05 <maralorn> Perheps cabal.project can help you?
04:05:32 <ph88> maralorn, i have a dependency and i want to pull the code into my project so i can edit it
04:11:09 <maralorn> Yeah, copy the code into your repo (or use git submodule) and then overwrite the path to the package in the cabal.project file.
04:19:43 * hackage jira-wiki-markup 1.2.1 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.2.1 (tarleb)
04:43:26 <cheater> hi
04:43:55 <cheater> anyone use TLA+ here? i'm not sure how to fix the PlusCal algorithm at the end of this page so that it doesn't violate the invariant. https://learntla.com/introduction/example/
05:25:43 * hackage hslua-aeson 1.0.1 - Allow aeson data types to be used with lua.  https://hackage.haskell.org/package/hslua-aeson-1.0.1 (tarleb)
05:39:13 * hackage holmes 0.3.0.1 - Tools and combinators for solving constraint problems.  https://hackage.haskell.org/package/holmes-0.3.0.1 (i_am_tom)
06:02:35 <ph88> maralorn, i'm using stack. How can i overwrite the path to the package ?
06:02:43 * hackage tptp 0.1.2.0 - Parser and pretty printer for the TPTP language  https://hackage.haskell.org/package/tptp-0.1.2.0 (EK)
06:05:41 <maralorn> ph88: Oh, Sorry. I don't know about stack. But I think it's at least possible that cabal.project works with attack. At least something similar might.
06:05:55 <merijn> cabal.project doesn't work with stack
06:06:06 <merijn> You need to work with on of it's yaml files
06:06:52 <ph88> oh ok
06:08:11 <kenran> ph88: AFAIK you can, inside your stack.yaml where you list the packages contained in your project, use a relative path to the downloaded repo
06:08:27 <kenran> ph88: that could be a git submodule ofc or just any local folder.
06:11:15 <kenran> just be aware that this affects the caching mechanisms of stack in some way. it might make your builds take longer this way
06:30:43 * hackage dobutokO2 0.23.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.23.0.0 (OleksandrZhabenko)
06:53:41 <ph88> thank you kenran 
07:23:43 * hackage ideas-statistics 1.0 - Interactive domain reasoner for statistics  https://hackage.haskell.org/package/ideas-statistics-1.0 (BastiaanHeeren)
07:32:13 * hackage git-brunch 1.2.0.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.2.0.0 (andys8)
08:02:23 <Wauchope> Ok so I need to get as many inputs of the same type from the user as there are elements in a list
08:02:27 <Wauchope> What's a good way of doing this?
08:03:09 <Wauchope> I'm using IO to handle inputs, with the list being of type [Int]
08:04:54 <phadej> the answer is `traverse`
08:06:33 <Wauchope> Maybe I worded it wrong, maybe I'm reading what traverse does wrong
08:06:56 <Wauchope> I'm building the [Int] up from [] in this function based on the length of another list
08:07:14 <Wauchope> Traverse seems to assume that the list is already at the size I want
08:08:13 <phadej> traverse (\_ -> readYourInt) anotherList
08:16:30 <Wauchope> Perfect, I'll play around with that to make sure I understand it now
08:35:50 <maralorn> I have a question about FunctionalDependencies and constraints. This Code does not work because the FunctionalDependencies are not fullfilled. Is there someway I an promise the compiler that I will never Implement B and C for a Type or better can I delay the check to the usage site? https://termbin.com/uov9
08:38:02 <jeetu> Is there an example of Brick tui with multiwindow. Wherein, by pressing some key, a total new set of widgets are displayed.
08:40:17 <jeetu> Something similar to https://github.com/jwlodek/py_cui/blob/master/examples/multi_window_demo.py
08:41:09 <lortabac> maralorn: I don't think you can use FunctionalDependencies here
08:42:15 <maralorn> lortabac: Any ideas how I could circumvent that problem?
08:42:15 <lortabac> what you are saying here is that for every a, b is a String, and then that for every a, b is an Int
08:42:44 <maralorn> lortabac: Yeah, now that I am.^^
08:42:46 <maralorn> I know
08:42:47 <lortabac> the context is not considered when selecting an instance, it is merely checked
08:43:23 <lortabac> I think you have to give up FunctionalDependencies and give up some inference
08:43:47 <maralorn> Yeah, that‘s the problem.
08:44:13 <maralorn> lortabac: Sadly I am not using my own Typeclass …
08:46:43 <lortabac> I don't think you can work around this limitation without modifying the type class
08:52:44 <fog> when decoding a json response into a datatype representation of the responseBody, using derive Generic - how can a response with a json field named type: be handled? 
08:53:26 <fog> i cant write "type" as a name of a record of the datatype, so I dont know how to construct a generic instance that would allow the json message to be decoded
08:53:31 <lyxia> fog: you can use Options to rename fields
08:53:53 <fog> what is this "Options" ?
08:54:13 <aveltras> any idea why only the first version works here ?  the second one is the same with the "encode" before the case..of
08:54:17 <aveltras> https://www.irccloud.com/pastebin/1HpYyN6Z/
08:54:43 <lyxia> fog: https://hackage.haskell.org/package/aeson-1.4.7.1/docs/Data-Aeson.html#v:genericParseJSON the first parameter of genericParseJSON
08:55:07 <fog> thanks lyxia!
08:55:25 <aveltras> (=:) being defined as 
08:55:29 <aveltras> https://www.irccloud.com/pastebin/kHYuAex0/
08:55:36 <fog> ln
08:56:02 <fog> oh, it was not json, it was going strait via Bytestring
08:57:48 <fog> instance ToJSON MyData where toEncoding = genericToEncoding defaultOptions
08:58:31 <fog> so i guess I change the defaultOptions (i think the Bytsestrings are handled using encode/decode)
08:59:10 <lyxia> you should still put an implementation for toJSON
08:59:13 <fog> ah ok, I just need to give the JSON instance for; decode :: FromJSON a => LC8.ByteString -> Maybe a
08:59:22 <lyxia> read the doc of ToJSON
09:00:04 <fog> genericToEncoding :: (Generic a, GToJSON Encoding Zero (Rep a)) => Options -> a -> Encoding
09:00:19 <fog> I guess thats where I need to make the new Options
09:00:49 <fog> any idea how to do this to rename a filed called "type" ?
09:02:27 <fog> ah, i can find; customOptions = defaultOptions { fieldLabelModifier = map toUpper }
09:03:37 <fog> so i guess i just change that to fieldLabelModifier = \xs -> if xs == "myType" then "type" else xs
09:17:25 <fog> also, how do I decode a list?
09:17:58 <fog> there is an instance ToJSON a => ToJSON [a]
09:18:37 <fog> but i can only use encode and decode to make a synonym of id which works for `a', not `[a]'
09:19:36 <fog> import Data.Aeson (FromJSON,ToJSON,toEncoding,Options(..),genericToEncoding,defaultOptions,encode,decode')
09:38:08 <fog> aha, I had it the wrong way round
09:38:17 <fog> its;
09:38:19 <fog> customOptions = defaultOptions { fieldLabelModifier = \xs -> if xs == "type" then "myType" else xs }
09:42:42 <fog> https://gist.github.com/fog-hs/68598511631eb1323636d9dd5d5235cb
09:46:07 <Wauchope> With traverse, is there a way to know which element I'm on
09:46:35 <fog> you can use mapAccumL
09:46:42 <fog> :t mapAccumL
09:46:44 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:46:55 <solonarv> you mean something like "element currently being processed is number 5" ?
09:47:05 <Wauchope> Yeah
09:47:18 <fog> for the function of type  (a -> b -> (a, c)) you would have a ~ Int
09:48:00 <fog> and you would use the original traversal function to process the b, and increment the int
09:48:28 <solonarv> yes, can be done; you can use 'State Int' (a monad that lets you carry around a state consisting of one 'Int' value) to carry around a counter
09:48:57 <fog> why use a monad transformer when this higher order function exists?
09:49:14 <fog> it captures the "carried state" notion perfectly
09:49:16 <solonarv> or if you are already using a different monad/applicative to traverse with (which is likely the case if you're using traverse in the first place!) you can layer 'StateT Int' on top
09:49:50 <JesseL> how to know a list is equal to another list without order? [1,3,5,2] is equal to [3,2,5,1], use intersect?
09:49:56 <solonarv> which is a monad *transformer* (takes in a monad, creates another monad out of it) that adds this same state capacity
09:50:12 <solonarv> JesseL: you could also sort them first, then use ==
09:50:41 <JesseL> alright
09:51:21 <Wauchope> Seeing all of this is making me think I don't need to use traverse at all. I'm trying to build a list of 7 integers in the following way "Please enter number 1: " user input ----> add to list "Please enter number 2" user input -----> add to list ..... etc
09:51:48 <Wauchope> I could probably write a small little function which does this for me, I'm just curious if one exists in the standard library
09:52:02 <solonarv> you don't *need* to use traverse, but it's the neatest way of doing it
09:52:16 <solonarv> sketch of the code: traverse getNthNumber [1..7]
09:52:45 <fog> so you could use something like;
09:52:48 <phadej> or `traverse ( \(i, _) -> getNthNumber i) (zip [1..] anotherList)
09:52:48 <fog> :t map (\n::Int -> print "Please enter number " ++ (show n))
09:52:50 <lambdabot> error: parse error on input ‘::’
09:53:09 <solonarv> note, you don't need to "graft on" a counter: you can just have the indexes in the input!
09:53:24 <fog> :t map (\n -> print "Please enter number " ++ (show n) >> getLine)
09:53:26 <lambdabot> error:
09:53:26 <lambdabot>     • Couldn't match expected type ‘[Char]’ with actual type ‘IO ()’
09:53:26 <lambdabot>     • In the first argument of ‘(++)’, namely
09:53:38 <fog> :t map (\n -> print ("Please enter number " ++ (show n)) >> getLine)
09:53:40 <lambdabot> Show a => [a] -> [IO String]
09:53:51 <Wauchope> I think the traverse getNthNumber [1..7] could work perfectly for me
09:54:11 <solonarv> yeah
09:54:20 <phadej> most likely, you want to combine the read number with anotherList data later, so then you actually should do `combined <- traverse ( \(i, x) -> (x,) <$> getNthNumber i) (zip [1..] anotherList); something with combined which is of type [(DataFromAnotherList, Int)]
09:54:21 <fog> :t sequence $ map (\n -> print ("Please enter number " ++ (show n)) >> getLine) [1..7]
09:54:23 <lambdabot> IO [String]
09:54:45 <phadej> also
09:54:48 <phadej> :t for
09:54:50 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
09:54:56 <solonarv> there's also 'for' which is just 'traverse' with the arguments flipper
09:54:57 <Wauchope> Something along the lines of 'traverse (\ i -> getInt "Please enter number " ++ i ++ ":") [1..7]' should do the job right?
09:55:08 <phadej> is handy, as yo ucan write readValues <- for [1..7] $ \i -> do ...
09:55:19 <fog> the reason traverse isnt what you want here is because you dont need any accumulating information, so you just have a map
09:55:19 <solonarv> need a 'show' in there but that basically works, yes
09:55:30 <phadej> fog: no.
09:55:35 <phadej> fog: sequence . map f = traverse f
09:56:18 <Wauchope> My getInt function receives a string to supply a prompt so it should handle the string nicely
09:56:49 <fog> yeah, but you could implement map in terms of traverse, and extend it to be more like mapAccumL, then sequence . map' wouldnt equate to traverse
09:56:51 <solonarv> Wauchope: yes, I am saying that 'i' is not a String so you can't '++' it together with additional strings
09:57:21 <Wauchope> Ah, keep forgetting you can't implicitly convert int to string
09:57:22 <fog> the fact that you can factorise traverse into map and sequence is by virtue of the traversal being "maplike" 
09:57:35 <fog> in which cases, writing the factorisation explicitly is informative
09:57:52 <phadej> Wauchope: do you have some resource you learn Haskell from, a book or a friend to ask things IRL (i.e. show them and get fast feedback?)
09:58:03 <Wauchope> :t sequence
09:58:04 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
09:58:40 <fog> sequnce over a list of IO is just going to run them in sequence, not pass any information between them
09:58:42 <Wauchope> I've always learned to program through trial and error. I've got my lecture notes to cover the bare basics, and learnyouahaskell if i need a decent explanation
09:59:09 <phadej> Wauchope: Haskell is not the good choice to learn by trial and error.
09:59:19 <phadej> The errors are very different that you are used to
09:59:34 <dsal> The trials are also great.
09:59:53 <phadej> i.e. you don't know what to try, so I suggest you to invest in proper material
10:00:29 <dsal> haskellbook was great, IMO.  I still write a lot of software in haskell I use every day.
10:01:02 <Wauchope> Would you guys not recommend learnyouahaskell? That was the "extra learning" resource my lecturer pointed me towards
10:01:06 * dsal uploads a few more gigs of video
10:01:14 <phadej> I'd recommend Hutton's Programming in Haskell
10:01:28 <phadej> I think LYAH cuts too many corners to be good learning material
10:01:47 <solonarv> one common criticism against LYAH is the lack of exercises
10:01:50 <dsal> haskellbook.com apparently takes you through all the corners.
10:02:08 <Wauchope> By that do you mean it can show you how to do X but won't teach you why the solution for X works?
10:02:12 <ornxka> i rather liked lyah
10:02:53 <phadej> dsal: yeah, it's massive - American-style textbook
10:02:54 <ornxka> it was apparently easy enough for me to complete it as a high schooler
10:03:18 <dsal> Easy enough to complete doesn't imply quality.  :)
10:03:27 <ornxka> well i learned haskell well enough with it
10:03:34 <Wauchope> "download a sample [95 pages]", that's one hell of a sample
10:03:51 <ornxka> in general i would say it is best suited for people with no prior experience with the ml family of languages
10:04:07 <justsomeguy> Haskellbook is like 1200 pages long. Currently working through it.
10:04:25 <dsal> haskellbook is huge, yeah.  But it walks you through all the fundamentals and has you build them all yourself.
10:04:38 <dsal> The one thing I didn't like about haskellbook is that it made all the magic go away.
10:05:23 <dsal> I had usable haskell code before that, but there was a bunch of magic that happened.  Since I had to build it all myself going through that book, it all just became normal.
10:06:08 <Wauchope> Forgive a probably dumb question here, but I've only been told to learn haskell for the purpose of completing this one coursework. What applications does haskell have in "the real world"?
10:06:21 <ornxka> sometimes i prototype interpreters in it
10:06:25 <dsal> Most of the applications I've written lately are in haskell.
10:06:33 <ornxka> because it has good ADTs and pattern matching
10:07:00 <ornxka> haskell's usefulness is mostly in being able to write specific kinds of programs quickly i think
10:07:09 <solonarv> it's a general-purpose language, so you *can* do anything with it
10:07:12 <ornxka> which is also aided by the type system
10:07:22 <dsal> The thing I'm running right now is uploading a bunch of video to GoPro Cloud (because their own tools fail me).  I reverse engineered enough of their APIs to completely reproduce their service and build myself a quite usable frontend.
10:07:32 <solonarv> prominent uses include compilers/interpreters, and web server type applications
10:07:35 <dsal> "specific kinds of programs" == any kind of program I feel like writing.
10:08:21 <ornxka> some kinds of programs (like programs with very consistent and well-defined performance characteristics) are more difficult to write in haskell than they are in other languages
10:08:41 <Wauchope> So I could theoretically use haskell to recreate most if not all software in another language such as one of the many C-based languages?
10:08:54 <dsal> You wouldn't write a kernel in haskell.
10:09:01 <dsal> Most programs shouldn't be written in C.
10:09:40 <justsomeguy> I think of haskell as inhabiting the same ecological niche as java or golang (application languages), just more expressive.
10:10:06 <justsomeguy> ...which of course is just my highly subjective opinion as a newbie.
10:10:12 <dsal> Yeah.  I can't imagine when I'd choose java over haskell for a thing.
10:10:35 <dsal> (I'm biased as having written a lot of java in the past)
10:11:11 <justsomeguy> Java doesn't seem like much fun. I've been actively avoiding learning it. (Java and C++ are big at my school.)
10:11:28 <dsal> C++ is the latin of programming languages.
10:13:19 * dsal interviewed a software developer solving an algorithm problem in C++ over the phone yesterday
10:13:20 <ornxka> i would say its more like german, and C is more like latin
10:13:29 <sm[m]> Wauchope: haskell is good at modelling complex concepts and at keeping a clean robust codebase over time
10:13:32 <justsomeguy> C++ actually seems very good. It's just so vast... and you have to understand a lot about the mechanics of how things are represented / passed.
10:13:57 <dsal> C++ isn't that good.  It's just big enough that there's technically an answer to everything.
10:14:04 <justsomeguy> Heh
10:14:15 <ornxka> i just like having c with namespaces
10:14:38 <dsal> haskell is also very good at writing concurrent software.
10:14:55 <fog> yeah, forkIO is awesome
10:14:55 <sm[m]> good point
10:15:13 <ornxka> yes the immutability solves a lot of concurrency problems
10:15:15 <dsal> :/  forkIO?
10:15:31 <sm[m]> it's also fast enough for almost everything
10:16:18 <ornxka> haskell also has the distinction of having the largest default compiler install of any of programming language by probably four orders of magnitude
10:16:41 <sm[m]> ornxka: really ? 1G, right ?
10:16:51 <dsal> heh.  It's large enough to be a problem for me at times.
10:17:04 <sm[m]> not four orders though :)
10:17:06 <justsomeguy> I kind of hope to use Haskell to do a lot of what I currently use Python for, but in a more maintainable way, and without the need to distribute a language runtime to end users. (Sysadmin scripts, talking to APIs, simple cli applications.) I'm really excited about using LiquidHaskell to make functions require fewer tests.
10:17:29 <fog> haskell is almost complete, its making its way onto android, and nix for server deployment is a very powerful tool
10:17:36 <JesseL> how to know if [1,2] is a subset of [1,2,3]?
10:17:55 <JesseL> [1,5] isn't
10:17:56 <fog> > [1,2] \\ [1,2,3]
10:17:58 <lambdabot>  []
10:18:22 <JesseL> > [1,5] \\ [1,2,3]
10:18:22 <dsal> JesseL: better to use sets if you're asking about set related questions.
10:18:25 <lambdabot>  [5]
10:18:31 <dsal> Lists aren't good at being things other than lists.
10:18:35 <sm[m]> justsomeguy: using static binaries, stack scripts, or.. ?
10:19:00 <solonarv> must be static binaries
10:19:07 <fog> > let isSubsetOf a b = null $ a \\ b in [1,2] `isSubsetOf` [1,2,3]
10:19:10 <lambdabot>  True
10:19:14 <sm[m]> maybe your users have known environments ? Just curious
10:19:16 <solonarv> for stack scripts you'd need to have stack on the user's machine. after all
10:19:38 <justsomeguy> sm[m]: My needs are simple. I just really want to be able to ship static binaries. It doesn't seem too hard.
10:19:51 <dsal> > S.fromList [1,2] `S.isSubsetOf` S.fromList [1, 2, 3] -- JesseL 
10:19:54 <lambdabot>  True
10:19:56 <sm[m]> solonarv: yes, or you can give them a bash script that installs it first
10:20:12 <sm[m]> justsomeguy: well, it depends
10:20:14 <dsal> justsomeguy: I have to do that because of both space and RAM limitations. 
10:20:44 <sm[m]> static binaries aren't really static, and user environments can be quite diverse
10:21:19 <justsomeguy> sm[m]: I'm sure there are a lot of considerations. I'm just talking about the simplest case -- shipping tiny cli applications to Linux servers. It's a big change from my current situation, where I only know dynamic languages that require and interpreter.
10:21:21 <dsal> Yeah, I found one of my builders no longer makes useful bins on another machine.  Docker, yay?
10:21:39 <justsomeguy> s/and interpreter/an interpreter/
10:21:45 <sm[m]> yeah, that sounds doable. That's why I was asking about your users' environments
10:22:10 <fog> always wanted to build sdl-reflex apps for android using obsidian oblisk, any ideas?
10:22:43 * hackage ngx-export-tools 0.4.7.0 - Extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-0.4.7.0 (lyokha)
10:36:30 <exarkun> Hi.  I have a Warp/Servant-based server that is returning a 500 error with no body and I have no idea why.  How do I get more information out of it?
10:37:07 <exarkun> I already have an onException and onResponseException that either print to stdout or add details to the response, and neither of those things is happening.
10:44:32 <dsal> My dependency list is huge.  I just need to add `dependencies: *` to my package.yaml
10:45:00 <exarkun> Also the 500 doesn't even appear in the request logs
10:45:12 <dmwit> dsal: Where is acme-all-of-hackage when you need it
10:45:12 <exarkun> It's super annoying that the server responds to requests without logging them. :(
10:46:01 <dsal> current status:  https://www.irccloud.com/pastebin/fBkAzs9H/deps.yaml
10:49:13 <jumper149> Can I tell ghc which instance to choose? I have something like `instance A a => A [a]` and `instance (Functor f, Foldable f, A a) => A (f a)`
10:49:34 <dsal> TypeApplications ?
10:49:41 <Cale> Those overlap
10:49:52 <dsal> Although, yeah, why do you have both?
10:49:58 <Cale> jumper149: For the purposes of instance resolution, you can ignore constraints on the instances
10:50:01 <jumper149> Yes they overlap. Can I tell ghc to prioritize one?
10:50:23 <Cale> It's possible, but best that you don't.
10:51:47 <jumper149> Would it make sense to wrap the latter in a newtype? So that it's still possible to use this "default" instance.
10:52:00 <Cale> Yeah, that's a better approach
10:54:11 <Cale> The way to make it happen anyway is with {-# OVERLAPPABLE #-} and {-# OVERLAPPING #-} pragmas. You could also use an {-# INCOHERENT #-} pragma on the polymorphic instance if you want it to be selected when the functor is as-yet unknow (with the understanding that if it turns out to be [] then the "wrong" instance will have been selected)
10:54:56 <Cale> But this stuff is the way to make it really hard to tell what's going on in your programs. I recommend only using overlapping instances in cases where you're not even going to export the class from the module it's defined in.
10:55:38 <jumper149> Yeah no... it's definetely exported^^
10:58:13 * hackage schedule 0.3.0.0 - Pure deterministic scheduled computations  https://hackage.haskell.org/package/schedule-0.3.0.0 (infinity0)
10:59:34 <Cale> Also, if you make a newtype for the polymorphic case, you can use deriving via to transport that instance to functors that you define.
10:59:37 <dsal> {-# PYTHON #-}
10:59:50 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-via
11:00:03 <Cale> {-# SCALA #-}
11:00:05 <Cale> haha
11:00:34 <Cale> {-# JUST KEEP ME GUESSING ABOUT WHICH INSTANCE YOU'LL PICK #-}
11:00:47 <dsal> (I've kind of wanted {#- PYTHON #-}  a few times, TBH.)
11:01:29 <phadej> everyone wants inline-python, but no-one have written one
11:01:33 <dsal> More like {-# JAVASCRIPT #-} where I'm doing json stuff and I don't have super strong types or whatever.
11:02:52 <Uniaika> dsal: isn't that called JSON Path?
11:02:53 <Uniaika> :P
11:03:16 <dsal> I'm using lens-aeson which isn't too bad.
11:06:31 <sm[m]> exarkun: how about Debug.Trace
11:06:34 <dsal> Huh.  I don't even know what the problem was now.  Maybe I just put more effort into learning lens-aeson better.
11:07:01 <exarkun> sm[m]: I'm not sure where I would put such a thing.  Do you have any ideas?
11:07:31 <akegalj> is it expected that `stack new` creates `package.yaml` that looks very similar to cabal file? What was the reason to introduce this ?
11:10:13 * hackage postgrest 7.0.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-7.0.0 (steve_chavez)
11:11:37 <sm[m]> exarkun: almost anywhere in the code, refining the location(s) as you get a sense of what code is executing. You may need to have the source of some packages available
11:12:59 <akegalj> ok - I found discussion on reddit about it
11:13:29 <sm[m]> ie: instrument the warp or servant internal code path
11:14:04 <sm[m]> Should be in the stack user guide akegalj
11:14:36 <yushyin> akegalj: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
11:15:12 <akegalj> yushyin: thanks
11:16:57 <exarkun> sm[m]: ok :/  kind of tedious, hey?
11:17:21 <sm[m]> Sure , but it’ll get you an answer!
11:17:53 <sm[m]> Whadya want, a stepping debugger or something ? :)
11:18:12 * exarkun coughs
11:18:44 <dsal> Debug.Trace is best stepping debugger.
11:19:42 <sm[m]> And there’s one right there in GHCi, go for it
11:20:56 <sm[m]> exarkun: of course I’m not suggesting an optimized rebuild each time. That would suck. Use ghci or ghcid —test
11:23:37 <exarkun> I can see how that would work, maybe, in principle, sure (except for never having stepped through anything with ghci before)
11:24:21 <exarkun> just kind of stuck beneath a huge mountain of complexity already, pretty sure I have already lost the thread of what I'm doing, throwing a new build system and a new tool into the mix is probably not gonna happen today
11:24:34 <exarkun> I guess that's what I'll pursue on monday
11:24:44 <exarkun> it would be nice if someone knew how warp worked, though, and could just point out the obvious stupid thing I did
11:24:58 <exarkun> I know, so slothful of me
11:25:26 <sm[m]> using the ghci debugger is more of a side quest, I’m really suggesting trace (reloading in ghci or with ghcid) because it’s the quick way
11:26:15 <exarkun> I'm building with nix and stack, so I guess I'd have to learn how to convince those tools to use a local, modified version of warp to use Debug.Trace
11:27:29 <exarkun> so yea, I'm not really saying it's a bad idea, it just might be beyond me at the moment
11:27:45 <sm[m]> Yes, I won’t speak to nix but for stack it usually means stack unpack PKG in your project dir and add PKG to local-packages: in stack.yaml
11:28:33 <sm[m]> stack build —fast —file-watch will do if you don’t want ghci’s speed
11:57:43 * hackage ejdb2-binding 0.1.0.0 - Binding to EJDB2 C library, an embedded JSON noSQL database  https://hackage.haskell.org/package/ejdb2-binding-0.1.0.0 (buro)
12:05:57 <maerwald> sm[m]: I think these should be. Specified in extra-deps according to the docs
12:06:19 <maerwald> https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
12:07:56 <MoodMojo> Anyone here?
12:08:02 <MoodMojo> Got a question
12:08:29 <yushyin> go for it
12:09:14 <MoodMojo> Well I'm having trouble using an environment variable in a function
12:09:52 <MoodMojo> Making a simple calculator and I want to use previously calculated values for future ones
12:10:35 <MoodMojo> Got my code if you'd like a look
12:11:56 <dsal> MoodMojo: What do you mean by "environment variable"?
12:12:06 <maerwald> I still don't see a question 
12:12:49 <dsal> Functions don't have environments.  You could pass the previous value in, though.
12:13:16 <dsal> :t runState
12:13:18 <lambdabot> State s a -> s -> (a, s)
12:14:05 <dsal> (is what that sounds like to me)
12:14:29 <maerwald> We haven't even seen the question 
12:15:08 <dsal> I'm speculating as to what code might look like since we've not seen that either.  :)
12:15:49 <MoodMojo> I mean a saved processed value or values actually. So the function I want should take a string and an equation then calculate the value of the equation and assign it to the string using a syntax tree
12:16:22 <MoodMojo> Hold on I'll show you guys what I mean by that
12:16:42 <dsal> It's not a function if it gives different values for the same input.
12:19:17 <MoodMojo20> ghci>foldAndPropagateConstants [("x", parse "1+2+3"), ("y", parse "5*x + 7")]
12:20:09 <dsal> It looks like you want a monadic fold and State, perhaps?
12:20:12 <MoodMojo20> So in calculating y I want it to use x. And if there was yet another argument that uses y in the list, then it should be able to calculate it
12:20:33 <MoodMojo20> dsal idk thought you guys might know how to do this
12:20:42 <MoodMojo20> Nothing seems to work
12:20:56 <dsal> Or you can keep the variables separate and use the fold to maintain a map that you accumulate.
12:21:08 <dsal> What have you tried?
12:21:26 <dsal> I see the function you want to run and can guess what it's supposed to do.  What do you expect that to return?
12:21:30 <MoodMojo20> The environment variable I had mentioned.
12:21:47 <MoodMojo20> You mean foldAnd...?
12:22:11 <dsal> We talk in types a lot.  What is the type of foldAndPropagateConstants ?
12:23:04 <dsal> (and what is the type of parse)
12:23:11 <MoodMojo20> foldAndPropagateConstants :: [(String, ExprV)] -> [(String, ExprV)]
12:23:53 <dsal> Interesting.  So what does it do?  `id` does that.
12:24:00 <MoodMojo20> Which is a custom data type by the way. But I'm quite sure the parse function works fine
12:24:25 <MoodMojo20> As I said it acts as a calculator
12:24:31 <dsal> Sure.  So you have a list of named expressions and you want to get a list of named expressions out of it.
12:24:52 <MoodMojo20> Pretty much yea
12:25:17 <dsal> Based your description,   `foldAndPropagateConstants = id` should work.
12:25:32 <MoodMojo20> And what's id?
12:25:35 <dsal> :t id
12:25:37 <lambdabot> a -> a
12:26:32 <MoodMojo20> Well that wouldn't really calculate anything would it?
12:26:53 <dsal> No, but it matches your type requirements.  You haven't described anything further about your problem.
12:26:57 <MoodMojo20> I have a helper function for that btw
12:27:30 <dsal> What do you expect to happen?  You said the output of that is a list of named expressions.  What named expressions would you expect to see from that input?
12:27:45 <MoodMojo20> I use a few examples elsewhere let me post them here
12:28:11 <MoodMojo20> ghci> foldAndPropagateConstants [("x", parse "1+2+3")]
12:28:12 <MoodMojo20> (Constant 37)),("z",BinaryOperation Plus (Leaf
12:29:37 <MoodMojo20> So as I said it's a calculator, but one that acts as a syntax tree. Bottom to top. Notice in my last example var is not defined so it shows it as is while y is defined so it replaces it with its value
12:29:55 <dsal> The last example was cut off.
12:30:20 <MoodMojo20> Looks fine on my end 
12:30:25 <dsal> It looks like `Map String ExprV` seems like a good idea.  You can accumulate values as you fold over the input.
12:30:36 <MoodMojo20> ghci> foldAndPropagateConstants [("x", parse "1+2+3"), ("y", parse "5*x + 7"), ("z
12:31:06 <dsal> Perhaps you can paste something larger into a pastebin somewhere.  You're getting cut off.
12:31:58 <MoodMojo20> Dunno if I pointed this out, but I'm a haskell beginner. So never used Map tbh
12:32:04 <MoodMojo20> I'll paste it hold on
12:32:37 <dsal> It's a mapping of keys to values.  So when you're evaluating an expression and you've got a map of named expressions, you can look up the name from a map to determine if you have a value to substitute.
12:32:39 <blabber> a
12:33:15 <dsal> :t mapAccumL
12:33:17 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:33:48 <dsal> That probably looks a bit much, but it does a lot of what you're asking
12:35:32 <MoodMojo20> https://pastebin.pl/view/e2cc3001 here are the examples
12:36:22 <dignissimus> Is there a way to pattern match on a tuple for say (x, y) and x==y
12:37:07 <solonarv> you can't do that in one pattern match, but you can match against a pattern like `(x,y)` and then check if x==y
12:37:19 <dignissimus> Ty I'll do that
12:37:40 <solonarv> note that most places where you might have a pattern match (function definitions, case expressions) also allow guards
12:37:43 * hackage gitlab-haskell 0.1.8 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.8 (RobStewart)
12:38:10 <solonarv> so you could write something like: case foo of (x,y) | x==y -> dostuff; | otherwise -> dosomethingelse
12:38:36 <dsal> MoodMojo20: Yeah, so you can resolve your variables pretty easily by just accumulating a map of names as you come across them, and look them up when you need.  See Data.Map.Strict
12:40:05 <dsal> mapAccumL (or R) will do the traversal and stuff for you, simultaneously building your symbol map, allowing you to use it, and giving you an accumulated output.
12:40:06 <MoodMojo20> Ok I'll check it out then
12:40:09 <MoodMojo20> Thanks
12:40:33 <MoodMojo20> So what about the case it doesn't find the variable?
12:42:49 <exarkun> are there docs somewhere about what version syntax cabal (2.x) accepts from `pkgconf --modversion`?
12:43:14 <dsal> MoodMojo20: You have to decide what to do then.  Is it an error, or is does it stay Variable?
12:43:37 <dsal> :t M.lookup
12:43:38 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
12:43:38 <exarkun> https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-pkgconfig-depends isn't exactly detailed
12:43:48 <sm[m]> maerwald: listing the package in local-packages works better for this situation, eg ghci[d] will reload changes
12:43:54 <MoodMojo20> It shouldn't give an error, no. Just leave it as a string
12:44:10 <sm[m]> it's just temporary for debugging
12:44:23 <dsal> :t M.findWithDefault
12:44:24 <lambdabot> Ord k => a -> k -> M.Map k a -> a
12:44:54 <dsal> > M.findWithDefault (Just "ex") "ex" mempty
12:44:56 <lambdabot>  Just "ex"
12:47:14 <MoodMojo20> I think this should work
12:47:41 <MoodMojo20> Now to actually do it internally as the function executes
12:50:04 <dsal> > mapAccumL (\m x -> (M.insert ("a variable named " <> show x) x m, x)) mempty [1, 2, 3] -- e.g., MoodMojo20 
12:50:07 <lambdabot>  (fromList [("a variable named 1",1),("a variable named 2",2),("a variable na...
12:50:43 <dsal> Dumb example, but I don't have your types here.
12:53:47 <monochrom> This is once again a case of the asker providing zero information in hope that the answerers provide infinite information.
12:54:39 <monochrom> But the appeal of functional programming is precisely Leibniz's property: If you can do something in isolation then you can just insert that code in the larger context and it will do the same thing in the larger context.
13:04:13 * hackage pandoc-lens 0.7.0 - Lenses for Pandoc documents  https://hackage.haskell.org/package/pandoc-lens-0.7.0 (BenGamari)
13:05:43 <iqubic> Why do you need a lenses for Pandoc?
13:05:49 <iqubic> What's the point there?
13:06:39 <dsal> To look at docs, obviously.
13:18:00 <jumper149> I am currently looking into the INLINE pragma, but don't really understand what it is really about. If it's just an optimization, why not have all functions inlined?
13:18:28 <ChaiTRex> jumper149: Inlining means to replace the call to the function with the function's body.
13:18:30 <dsal> It's a tradeoff.
13:19:02 <dsal> I do wish it magicked up a bit more.
13:20:43 <jumper149> So I save myself n pointer dereferences, if I use `map f ls` with `n == length ls` and f inlined?
13:21:29 <jumper149> And the tradeoff is that the file size of the binary gets larger?
13:21:54 <ChaiTRex> No, inlining saves function calls. There's also the cost of instruction cache misses due to larger functions.
13:30:09 <carbolymer> how can I tell GHC that I'm interested in function from the current module in case of "ambigious occurence"?
13:31:53 <carbolymer> wtf, I've recompiled and the error disappeared
13:33:17 <ChaiTRex> carbolymer: It was afraid of us finding out.
13:39:29 <carbolymer> prolly
13:39:48 <jumper149> Well, how is a function called when it's not inlined?
13:42:53 <MoodMojo20> dsal Do you need my type definitions?
13:48:55 <dsal> MoodMojo20: No, I could just write clearer code in that case... but there wouldn't be anything left for you to do.
13:52:13 * hackage leancheck-instances 0.0.4 - Common LeanCheck instances  https://hackage.haskell.org/package/leancheck-instances-0.0.4 (rudymatela)
14:05:39 <edmundnoble> jumper149: First, the function is evaluated; then, the function is "asked" how many parameters it has by the runtime system. Then, either you give it all of those parameters, you give it some of those parameters, or you give it more parameters than it wants
14:07:53 <edmundnoble> In the first case, the parameters are pushed onto the stack or put into registers and the function's code is jumped to; in the second, a "partial application" is constructed, which is a kind of closure that points to the function in question and also contains references to the function arguments; in the third, I don't remember, but it's probably like the first case plus a continuation being stored that basically 
14:07:54 <edmundnoble> tells the runtime that after it's done evaluating the function, it has to take the result and apply that to more arguments, repeating the process
14:08:21 <edmundnoble> Inlining isn't *about* saving function calls really, it's about optimizations
14:08:25 <edmundnoble> The compiler cannot optimize what it can't see
14:09:17 <edmundnoble> If for example a higher-order function is inlined, the function which is being passed to that higher-order function is known statically by the compiler, and the optimizer can work with that knowledge
14:09:47 <edmundnoble> To for example remove intermediate data structures, decreasing the amount of memory used at once
14:10:16 <edmundnoble> Almost everything that the optimizer can do is enabled by inlining
14:10:46 <edmundnoble> But inlining the wrong things, or inlining them at the wrong time, can lead to performance being *worse*, and code size jumping dramatically (exponentially, you might say)
14:11:16 <edmundnoble> So the compiler makes decisions about inlining when they're obvious, but when they're not obvious (and still beneficial), you have the ability to direct the compiler yourslef
14:18:51 <jumper149> edmundnoble: ty, for that explanation :)
15:19:35 <hexagoxel> sm[m]: I only noticed two minor issues with the stream; sometimes the application-switching does not trigger, keeping the browser in the foreground, and sometimes the IDE window capture stops working (I have an idea what causes it). I am not aware of any other problems.
15:24:33 <sm[m]> hexagoxel: I looked for it at https://www.twitch.tv/hexagoxel/ in firefox and I saw nothing live, just a 30s clip
15:27:39 <hexagoxel> sm[m]: hmm firefox you say? That is good to know. I had it open on a second machine in chromium and it worked fine. Will check that when I start up the next time.
15:29:03 <hexagoxel> I probably won't be able to change much about this issue, other than recommending to try a different browser :/
15:29:09 <sm[m]> I've watched twitch in this browser before, but it has been a long time. On your Home tab I see a black video image and the title "haskell coding on open source formatter brittany", pressing play just spins. I suspect twitch is having issues
15:30:14 <sm[m]> I expected your stream to show up in Videos also, but maybe that's not automatic
15:30:30 <sm[m]> anyway, hope it was productive :)
15:31:32 <hexagoxel> it was, thanks! I'd say the feature is in a state ready to ship, even though it is not as feature-complete as I'd like it to be.
15:32:25 <Ariakenom> yeah twitch likely has issues. some big events happening
15:33:17 <hexagoxel> merging (import A(x); import A(b) ->  import A(x, b)) and more compact formatting are on the to-do list. But sorting works, comments are retained in a sensible fashion.
16:49:13 * hackage system-linux-proc 0.1.1 - A library for accessing the /proc filesystem in Linux  https://hackage.haskell.org/package/system-linux-proc-0.1.1 (ErikDeCastroLopo)
17:12:43 * hackage ghc-prof 1.4.1.7 - Library for parsing GHC time and allocation profiling reports  https://hackage.haskell.org/package/ghc-prof-1.4.1.7 (MitsutoshiAoe)
17:19:13 * hackage sak 0.1.1.1 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.1.1 (vmchale)
18:44:02 <zeta_0> is kleisli composition right associative, just like regular composition?
18:44:12 <zeta_0> https://dpaste.org/qTS4
18:44:24 <zeta_0> ^
18:46:23 <solonarv> zeta_0: you can answer that question yourself by typing ':info <=<' into ghci
18:48:13 * hackage ghc-lib-parser-ex 8.10.0.3 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.3 (shayne_fletcher)
18:48:15 <zeta_0> solonarv: it's throwing a: not in scope error, what module is <=< in?
18:48:54 <solonarv> probably Control.Monad
18:49:02 <solonarv> % :i <=<
18:49:03 <yahb> solonarv: (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c -- Defined in `Control.Monad'; infixr 1 <=<
18:49:16 <solonarv> % :i . -- for comparison
18:49:16 <yahb> solonarv: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
18:49:19 <solonarv> aw
18:49:21 <solonarv> % :i .
18:49:21 <yahb> solonarv: (.) :: (b -> c) -> (a -> b) -> a -> c -- Defined in `GHC.Base'; infixr 9 .
18:49:32 <zeta_0> thanks
18:51:21 <benjwadams> Is there anything in the standard library that'd let you match directory contents against a glob?
18:52:43 <zeta_0> it's throwing a parse error, maybe the indentation is messed up? https://dpaste.org/nCuL
18:54:11 <solonarv> zeta_0: is that a module or a ghci history?
18:55:34 <zeta_0> solonarv: i don't know i just imported the Control.Monad module
18:56:01 <solonarv> zeta_0: I'm asking if these are separate lines you typed into ghci, or if that is the contents of a .hs file
18:56:31 <zeta_0> solonarv: that paste bin is a .hs file, sorry i didn't know what you meant by the question
18:56:53 <solonarv> then the answer is: top-level definitions don't start with a 'let'
18:59:01 <zeta_0> solonarv: i think i fixed it correctly, there's no error being thrown anymore: https://dpaste.org/CNg4
18:59:21 <solonarv> what's the 'x' argument for?
19:02:48 <zeta_0> solonarv: if i remove the x, ghcide throws this error? https://dpaste.org/3Tqc
19:03:08 <zeta_0> i added the x to remove the error ^
19:03:30 <solonarv> ah, the dreaded monomorphism restriction!
19:03:59 <zeta_0> solonarv: what's that?
19:04:16 <monochrom> Perhaps write a type signature.
19:04:17 <solonarv> if you don't provide a type signature *and* the binding isn't a function binding (no arguments on the LHS of the =), then the MMR kicks in
19:05:01 <solonarv> it says that constraints (e.g. 'Monad m') in the type signature aren't allowed, essentially
19:05:16 <solonarv> the easiest way around it is to write a type signature
19:05:45 <solonarv> you can also eta-expand the definition, i.e. turn 'foo = stuff' into 'foo x = stuff x'
19:06:33 <solonarv> the reason it exists is to avoid bad-performance surprises
19:06:55 <solonarv> if you have a binding like 'n = sum [1..100000]' this looks like it should be evaluated only once
19:07:28 <solonarv> but actually its type is 'forall a. Num a => a', and it's a function!
19:08:12 <d34df00d> Writing parsers is fun.
19:08:22 <zeta_0> oh i see, edge cases mess me up sometimes
19:08:31 <solonarv> er, oops, of course it's 'forall a. (Num a, Enum a) => a'
19:08:37 <d34df00d> Spent like an hour debugging my if-then-else support for my little terms language because I forgot to exclude if/then/else from valid identifiers, so it all got messed up.
19:09:06 <solonarv> in Core it looks something like 'n = \ fNum_a fEnum_a -> sum fNum_a (enumFromTo fEnum_a (fromInteger fNum_a 1) (fromInteger fNum_a 100000))'
19:09:35 <solonarv> so in fact it will be recomputed every time it's used!
19:09:52 <solonarv> to avoid this surprise, the MMR says "no, this is an error"
19:10:06 <zeta_0> what's the correct type signature? am i at least close? https://dpaste.org/huru
19:10:22 <solonarv> no, you're not close at all
19:10:28 <solonarv> are you just randomly guessing?
19:12:20 <monochrom> What is the purpose of this code?
19:12:57 <monochrom> It looks like piling up more and more patches on a very simple idea.
19:13:00 <zeta_0> solonarv: yes, that was a guess, when i add x as a parameter to g, ghcide's type inference tells me g's signature is: g :: (Monad m, Num c) => p -> c -> m c , is this type signature correct?
19:13:21 <monochrom> Therefore I suggest deleting this code and starting from scratch from the real problem.
19:13:30 <zeta_0> monochrom: it's a piece of code from learn you a haskell, i'm on the 2nd to last chapter of the book
19:13:52 <monochrom> What is the purpose of this code?
19:15:20 <zeta_0> monochrom: the section is: composing monadic functions
19:19:43 <zeta_0> nevermind, i'll just run the code in ghci instead, my type signatures keep throwing errors
19:22:41 <monochrom> If ghci accepts it, then you can ask ghci what is the type it figures out, then you can steal it.
19:22:54 <monochrom> I thought everyone knew that.
19:23:39 <zeta_0> monochrom: thanks, sorry, i'm a little bit slow, today, i'm almost 1 chapter away from finishing learn you a haskell
19:24:10 <monochrom> The last 10% takes exponentially more time.
19:25:02 <monochrom> This is why there are more B-grade students than A-grade students.
19:25:21 <zeta_0> monochrom: some of the concepts feel very natural, but other's confuse me, the only monad that i still haven't been able to wrap my head around yet is the state monad
19:25:36 <koz_> zeta_0: What blocks your understanding of State?
19:25:41 <koz_> If you can describe it.
19:26:10 <monochrom> Immersion is better than wrapping around.
19:26:33 <monochrom> For example to learn French, you don't wrap around French, you immerse in French i.e. French wraps around you.
19:27:14 <monochrom> In Soviet Russia, Russian wraps around your head.
19:27:34 <koz_> monochrom: Rofl.
19:27:49 <monochrom> This is why the old movie Firefox says "you must think in Russian" to pilot their new prototype telepathic jet fighter.
19:28:20 <zeta_0> well, i think i understand the State Monad instance, but when i try actually implementing to solve a problem i get lost, anyways, i'm going to finish the rest of the book 1st and then come back to learn the State Monad
19:29:40 <zeta_0> i'm not sure what state means? my understanding is state is `remembered information at some point/snapshot`
19:29:59 <monochrom> And is LYAH the reason why people hand-write code into ghci?
19:30:00 <benjwadams> How should I go about finding all files within subdirectories by and creating a Map to store the counts of files within each subdirectory?
19:30:41 <koz_> zeta_0: State doesn't _mean_ anything other than its definition. A better question is 'what is State _used for_?'.
19:30:46 <koz_> That has much more productive answers.
19:31:03 <monochrom> System.Directory has functions you can use to list directory contents.
19:31:51 <zeta_0> koz_: anyways, i'll forgot about that for now, and then come back to the State Monad when i finish lyah
19:32:13 <zeta_0> i'm on a roll, i don't want to get side tracked at the moment
19:33:41 <zeta_0> it took me a lot longer than i thought to work through the lyah book
19:33:50 <benjwadams> monochrom, i figured that much.  I'm not sure how I should go about loading all the counts into a Map: https://bpaste.net/EPPQ
19:34:04 <benjwadams> Pretty rusty on my Haskell and I haven't done much inside IO monad
19:34:33 <koz_> benjwadams: First-off, that return type mentions Map _nowhere_. Is this intentional?
19:35:26 <benjwadams> koz_: somewhat.  I want to get [(String, Int)] first in the IO monad and then maybe transform that into a map?
19:35:52 <pie_[bnc]> are there any preludes that are actively maintained but less unsound than Prelude?
19:35:53 <koz_> If your _final result_ from the function is a Map, then your function signature is wrong.
19:36:08 <pie_[bnc]> i just ran across universum by accident and the copyright on hackage is 2018
19:36:25 <koz_> If you wanna return a list of pairs, then it's fine, but then what's the Map for?
19:36:26 <pie_[bnc]> protoludes github seems to have been updated 2 months ago, i havent checked anything any deeper
19:37:01 <monochrom> What the hell is "getDirectory"?!
19:37:29 <zeta_0> that container analogy for functors really helped give me some good intuition as a beginner functional programmer for mapping functors, even though the haskell experts say it's kind of fake'
19:37:53 <MarcelineVQ> pie_[bnc]: check out relude
19:37:58 <MarcelineVQ> pie_[bnc]: https://github.com/kowainik/relude
19:38:16 <koz_> zeta_0: It's not even 'kind of' fake. It works in certain highly specific cases. Proxy is a functor, as is State s, but calling them 'containers' is extremely confusing.
19:38:42 <monochrom> Hahaha is "relude" simply "Prelude but without partial functions so just take away the P"?
19:38:50 <koz_> monochrom: I think that's the idea yeah.
19:39:04 <MarcelineVQ> [p]ossibly
19:39:31 <benjwadams> sorry, that should be listDirectory
19:39:44 <koz_> :t listDirectory
19:39:45 <lambdabot> error: Variable not in scope: listDirectory
19:40:17 <benjwadams> it's from System.Directory
19:40:22 <koz_> OK, so you run that, and you get a bunch of FilePaths.
19:40:25 <monochrom> so "sampleDir" is a list of strings, not one single string.  so "listDirectory sampleDir" makes no sense.
19:40:28 <koz_> Some of those will be directories.
19:40:36 <koz_> Some of them will be non-directories.
19:40:40 <koz_> What do you wanna do about it?
19:40:45 <benjwadams> filter!
19:41:15 <koz_> You know how to write that?
19:42:08 <benjwadams> Honestly, not at the moment.  I know how I'd tackle this in an imperative language:
19:43:30 <benjwadams> count_dict = {}; for dir in os.listdir: count_dict[dir] = len(os.glob("*.ext"))
19:43:52 <koz_> Yeah, and you can do something quite similar.
19:44:22 <koz_> With 'stuff <- listDirectory dir', you now have access to 'stuff :: [FilePath]'.
19:44:39 <benjwadams> can I map over the initial getDirectory call to list contents of each subdirectory and then get take length of it?
19:44:40 <koz_> You then need to transform it into _another_ [FilePath], but everything in it has to be a directory, right?
19:45:05 <monochrom> I don't understand how globbing and *.ext have anything to do with "is this a directory?"
19:45:05 <pie_[bnc]> MarcelineVQ: hm thanks ill check that out
19:45:11 <koz_> You can certainly map over it like that, but not everything in said list will be a directory.
19:45:20 <koz_> Also what monochrom said.
19:46:00 <benjwadams> koz_: I'm making a simplifying assumption here.  In this particular toy example I know the top level directory only happens to contain subdirectories, which in turn only contain files.
19:46:36 <monochrom> System.Directory has doesDirectoryExist for this.
19:46:37 <koz_> benjwadams: Sure, but all you need to do then is essentially skip non-directories in the listing no?
19:46:41 <koz_> It's not really that hard to do.
19:47:01 <monochrom> Seriously you need to read the doc of System.Directory thoroughly to know which tools are at your disposal.
19:47:36 <monochrom> I can't imagine any kid playing Lego to ask "how to build a rocket?" without even first taking a look at the blocks available.
19:48:40 <benjwadams> uh wow
19:49:06 <benjwadams> this isn't the #haskell I remember from earlier.  I haven't touched IO monad in quite some time
19:49:17 <monochrom> Hell there is even "findFilesWith" that saves you writing a nasty loop.
19:49:27 <benjwadams> and for the record I did look at it and a couple other modules including a glob module
19:50:17 <benjwadams> conceptually I know how to do this in an imperative language.  Is there any example file handling code I could take a look at with filtering, etc?
19:50:34 <koz_> benjwadams: It'd just be list processing in this case.
19:51:10 <koz_> The fact that the list is in IO doesn't change what you use, merely how.
19:51:11 <benjwadams> Yeah, my idea was to somehow get a list of (Filepath, Int) and turn it into a Map
19:51:22 <koz_> Well, you have a way to get a [FilePath].
19:53:17 <koz_> Then, for each of them, you wanna go something like 'is this a directory? if yes, pair it with how many things are in it, if not [insert some handling here]'.
19:53:37 <koz_> Then you wanna go 'collapse the resulting list into a Map'. There are a few ways you can do this, some more manual, some less so.
19:54:11 <koz_> None of this is IO-specific, and it doesn't even change much for being in IO.
19:55:02 <koz_> You can even potentially combine the two.
20:01:44 <benjwadams> example code of any sort would be very helpful.  It doesn't have to be tailored to my use case, but just FS operations.  Something like this: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples
20:02:28 <benjwadams> the haskell library docs are good when I have types in mind, but IMO lack examples compared to something like the Python standard library docs
20:03:18 <koz_> benjwadams: What kind of example would you like to see?
20:03:34 <koz_> Like, just 'how do I list directories', or something else?
20:03:49 <benjwadams> directory traversal returning something aside from `IO ()`
20:03:59 <koz_> Uhhh, it has to be in IO.
20:04:04 <koz_> One does not simply leave IO.
20:04:11 <benjwadams> I know that, but not returning ()
20:04:21 <koz_> Ok, sure.
20:04:32 <koz_> What do you mean by 'traversal' here?
20:05:13 <benjwadams> anything really.  just iterating over some directory contents and returning some kind of data structure
20:11:34 <koz_> benjwadams: https://gist.github.com/kozross/6932a5bd0875a7e41725523767ce97df
20:12:19 <benjwadams> thank you.  this helps a lot
20:14:57 <koz_> Note that, aside from System.Directory's functions, nothing I used is IO-specific at all.
20:16:22 <MarcelineVQ> doesFileExist f is IO​ Bool fwiw
20:16:36 <koz_> MarcelineVQ: Ah, yeah, good catch.
20:16:42 <koz_> That won't compile then lol.
20:16:45 * koz_ fixes.
20:18:00 <koz_> OK, better now.
20:19:15 <koz_> (this is why you don't try and write code without GHC handy lol)
20:21:28 <koz_> Also, I find myself reaching for traverse so much these days.
20:21:39 <koz_> (in fact, I recently needed traverse . traverse)
20:22:19 <monochrom> haha
20:22:33 <koz_> All-purpose wonder function.
20:27:29 <MarcelineVQ> koz_ benjwadams: https://gist.github.com/kozross/6932a5bd0875a7e41725523767ce97df#gistcomment-3239933
20:27:38 <MarcelineVQ> you're typing too fast :>
20:28:33 <koz_> MarcelineVQ: Lol, nice catch, again. Also, adorable Github avvy.
20:29:26 <oats> traverse is lovely
20:29:36 <MarcelineVQ> speaking of traverrrrse
20:29:43 <MarcelineVQ> lens question, Is there a clear way to roll this map into the traverse or is this about as reasonable as a select and modify line gets? [Left "a", Right 2, Left "c"] ^.. traverse . _Left & map (++"d")    I could write  traverse . _Left . (. (++"d"))  but that's skirting the edge of . clarity for me
20:29:51 <oats> I once spent a lot of time trying to figure out what it's for
20:30:07 <oats> and then one time I was search hoogle for a type signature to do a thing I needed
20:30:10 <oats> and it was traverse
20:30:14 <koz_> oats: The key answer is 'everything, nearly'.
20:30:18 <oats> and then it clicked and it was wonderful
20:30:49 <zeta_0> i completely forgot, how do i load modules in ghci ?
20:30:54 <oats> MarcelineVQ: whew, that's some dense code
20:30:58 <monochrom>  :load X.hs
20:31:45 <zeta_0> i'm trying to load Control.Monad in ghci
20:31:53 <MarcelineVQ> oats: it's pick the values out of the Left's in this list and ++"d" to them   [Left "a", Right 2, Left "c"] ^.. traverse . _Left & map (++"d")  = ["ad","cd"]
20:32:00 <koz_> zeta_0: Then you just do 'import Control.Monad'.
20:32:09 <monochrom> import Control.Monad, or :module +Control.Monad
20:32:10 <oats> to be fair I'm barely comfortable with lenses as is
20:32:11 <koz_> Although I would recommend only importing what you need.
20:32:17 <MarcelineVQ> oats: me2
20:32:27 <koz_> Since that dumps everything from Control.Monad into your session.
20:33:45 <oats> MarcelineVQ: what about Data.Either.rights
20:33:50 <oats> :t rights
20:33:52 <lambdabot> [Either a b] -> [b]
20:34:23 <MarcelineVQ> oats: for sure that's the better way    map (++"d") . lefts    but I'm just asking a lens question rather than about the method :>
20:34:32 <oats> ahh :)
20:35:18 <oats> I've been meaning to go through a proper lens tutorial so I can grasp this stuff better
20:35:23 <oats> the arcane operators don't help :P
20:35:25 <zeta_0> koz_ monochrom : thanks, import Control.Monad is much better than having to remember the other command, the import command didn't have auto-completion in ghci, so i wasn't sure if it was valid syntax or not
20:35:54 <MarcelineVQ> odd, it should  import Con<tab>
20:36:04 <koz_> oats: As the joke goes, the 'L' in 'APL' stands for 'lens'. :P
20:36:23 <oats> I don't get it, I'm not familiar with APL :<
20:36:42 <monochrom> The other command has uses not covered by import.
20:36:49 <zeta_0> the Con part does have auto-completion, but not the import part
20:37:10 <monochrom> Such as when you want to get rid of Control.Monad it's :module -Control.Monad
20:37:20 <MarcelineVQ> ah that's true, there's even a ticket about that, autocomplettion for things like import and qualified
20:38:30 <zeta_0> oh i see, more edge cases, thanks for the info
20:39:17 <koz_> Edge cases be best cases.
20:39:33 <monochrom> how about vertex cases?
20:39:42 <oats> booooo
20:39:42 <monochrom> also face cases?
20:39:58 <koz_> Lol.
20:40:18 <monochrom> Euler characteristic relates edge cases with face cases.
20:55:53 <zeta_0> when i'm in ghci is there an equivalent command to clear? like in terminal? so i can clear everything out and move the prompt to the top of the screen?
20:56:12 <jackdk> zeta_0: ^L aka Ctrl-L
20:58:08 <zeta_0> jackdk: thanks
21:00:40 <sm[m]> benjwadams: yes, this is #haskell 2020. Sorry 😐
21:01:11 <zeta_0> what is the difference between <=< and >=> ?
21:04:44 <jackdk> zeta_0: either the types or the haddocks will tell you
21:06:15 <MarcelineVQ> zeta_0: you can also call clear if you like  :! clear
21:06:35 <ysangkok> zeta_0: looks like it is just flipped, like intuition suggests.
21:10:29 <ysangkok> However, unlike Haskell, where
21:10:29 <ysangkok> the resolution algorithm for type class instances is hard-coded, in the case of Coq one
21:10:32 <ysangkok> can actually program the way the canonical instances are resolved. 6 This leads to a
21:10:35 <ysangkok> very powerful technique to automate the process of theorem proving by encoding the
21:10:38 <ysangkok> way to find and apply necessary lemmas, whenever it is required.
21:10:41 <ysangkok> whoa!!! mind blown
21:14:46 <zeta_0> ok, thanks
21:20:39 <pie_[bnc]> does anyone know any purely functional embeddable language (i.e. not an eDSL but something with an interpreter I can put in my programs) that has no effects/IO by default and that I could tack on effects/io/whatever onto with an effects library?
21:20:39 <pie_[bnc]> im interested in something simple but powerful i can use to write plugins with capabilities
21:20:39 <pie_[bnc]> so I dont want unconstrained IO in the interpreter by default
21:23:26 <benjwadams> https://bpaste.net/ANBQ
21:25:21 <benjwadams> How can I filter a list of lists within a monad here?  Also, how (or even should) I be lifting the pure function from `FilePath -> Bool` to go to IO Bool for the file extension?
21:27:22 <koz_> :t fmap
21:27:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:27:38 <koz_> If we set a ~ FilePath and b ~ Bool, we get
21:27:50 <koz_> Functor f => (FilePath -> Bool) -> f FilePath -> f Bool
21:28:24 <koz_> Generally speaking, if you want a pure function to operate on values in an effect, you want fmap.
21:28:33 <koz_> This is also the answer to your first question.
21:29:03 <koz_> Even more illustrative:
21:29:24 <koz_> fmap can be seen as 'Functor f => (a -> b) -> (f a -> f b)
21:29:26 <koz_> '
21:31:28 <benjwadams> `checkIfWaveFile fp = fmap (takeExtension fp == ".wav" &&) $ doesFileExist fp`
21:31:37 <benjwadams> Is this a reasonable approach?
21:34:02 <koz_> % :t takeExtension
21:34:02 <yahb> koz_: ; <interactive>:1:1: error:; * Variable not in scope: takeExtension; * Perhaps you meant `exeExtension' (imported from System.Directory)
21:34:43 <koz_> % import System.FilePath
21:34:43 <yahb> koz_: 
21:35:17 <koz_> % :t \fp = fmap (takeExtension fp == ".wav" &&) (doesFileExist fp)
21:35:17 <yahb> koz_: ; <interactive>:1:5: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
21:35:26 <koz_> % :t \fp -> fmap (takeExtension fp == ".wav" &&) (doesFileExist fp)
21:35:26 <yahb> koz_: FilePath -> IO Bool
21:35:31 <koz_> Seems reasonable.
21:36:30 <MarcelineVQ> :t (>>=)
21:36:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:37:27 <koz_> MarcelineVQ: We don't have an 'a -> m b' situation here I don't think.
21:38:42 <MarcelineVQ> koz_: >>= can be used to write fmap so you always have that situation, it just depends what is clearer to you. I'd be inclined to write  doesFileExist fp >>= \b -> takeExtension fp == ".wav" && b   because it's clearer to me than the fmap
21:39:02 <koz_> MarcelineVQ: If we're talking clarity, I'd probably not write it that way either.
21:39:21 <benjwadams> What's the significance of `Traverseable t` within mapM?  I assume it's some kind of "container" that can be iterated across
21:39:34 <koz_> benjwadams: Traversable gives you a function 'traverse'.
21:39:37 <koz_> :t traverse
21:39:39 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
21:39:51 <koz_> You can think of it as an 'effectful fmap' if it helps.
21:40:10 <koz_> In your case, t ~ [].
21:40:16 <koz_> But there are other Traversables possible.
21:40:20 <c_wraith> benjwadams: yeah, it more or less means "any container for which this operation makes sense"
21:40:35 <koz_> It's subject to some laws.
21:40:48 <koz_> So it has to 'make sense' in the sense that none of said laws break.
21:40:59 <koz_> Another example of a Traversable is Maybe.
21:41:05 <koz_> (one which I regularly forget about)
21:41:27 <benjwadams> so in the mapM case it's ... "unboxing" it from the monad type and traversing with the function?
21:41:35 <benjwadams> over the list
21:41:50 <c_wraith> traverse (and traverse_) are the thing I miss most when using any other language.
21:41:53 <koz_> :t mapM
21:41:55 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
21:42:03 <koz_> The Traversable isn't in a monadic context.
21:42:07 <benjwadams> and can I also combine mapM with a filter?
21:42:42 <koz_> :t \f -> fmap (filter f) . taverse
21:42:43 <lambdabot> error:
21:42:43 <lambdabot>     • Variable not in scope: taverse :: a1 -> f [a]
21:42:43 <lambdabot>     • Perhaps you meant one of these:
21:42:44 <benjwadams> I'm sorry, I'm a newbie, so my nomenclature is going to be pretty odd
21:42:46 <koz_> :t \f -> fmap (filter f) . traverse
21:42:48 <lambdabot> Traversable t => (t b -> Bool) -> (a -> [b]) -> t a -> [t b]
21:43:01 <benjwadams> :t mapM
21:43:01 <koz_> Wait, nope, that's not what I wanted.
21:43:02 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
21:43:12 <koz_> Right, look at the types carefully.
21:43:21 <benjwadams> ah
21:43:48 <koz_> In fact, mapM is just traverse.
21:43:56 <koz_> (with a Monad instead of an Applicative)
21:44:34 <ysangkok> % :t \fp -> do exists <- doesFileExist fp; let hasRightExtension = takeExtension fp == ".wav" in pure $ exists && hasRightExtension
21:44:34 <yahb> ysangkok: FilePath -> IO Bool
21:45:37 <benjwadams> :t filterM
21:45:38 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
21:50:34 <koz_> Huh, didn't realize it also only needed Applicative.
21:51:08 <koz_> @src filterM
21:51:09 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:51:46 <benjwadams> How can I filter a list of list contained in an IO monad?
21:51:56 <koz_> :t (=<<)
21:51:57 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:52:06 <koz_> Or potentially fmap.
21:52:15 <jusss> anyone meet freenode disconnected issue now?
21:52:24 <koz_> Are you asking for a filter (i.e. pure result) or a filterM (i.e. monadic result)?
21:52:34 <jusss> banned for 240 min
21:52:34 <koz_> If it's the former, fmap. If the latter, =<<.
21:56:07 <MarcelineVQ> koz_: iirc filterM is something like  foo :: Applicative f => (a -> f Bool) -> [a] -> f [a]; foo f [] = pure []; foo f (x:xs) = liftA2 (\b -> if b then (x:) else id) (f x) (foo f xs)
21:56:31 <koz_> MarcelineVQ: Yeah, I looked it up and it's basically that.
21:59:08 <benjwadams> :t filterM
21:59:10 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
22:00:06 <benjwadams> :t mapM listDirectory
22:00:08 <lambdabot> error:
22:00:08 <lambdabot>     Variable not in scope: listDirectory :: a -> m b
22:01:24 <koz_> % :t mapM listDirectory
22:01:24 <yahb> koz_: Traversable t => t FilePath -> IO (t [FilePath])
22:02:06 <benjwadams> what's % do? vs regular colon commands to bot?
22:02:47 <koz_> benjwadams: Different bot.
22:03:35 <benjwadams> The thing here is I don't know how to extract the [FilePath] within the IO ( t a ) to pass along to the filter
22:03:43 <benjwadams> s/filter/filterM
22:04:34 <koz_> The 't' in your case is [], so you have IO [[FilePath]].
22:04:42 <benjwadams> If I "assign" using `somevalue <- mapM listDirectory` I'm going to get [[FilePath]] Stored
22:04:49 <benjwadams> indeed, I follow that much
22:04:57 <koz_> What's the type of your goal?
22:05:04 <koz_> You wanna go from [[FilePath]] to what?
22:05:47 <benjwadams> Ultimately, IO (Map FilePath Int), but I want to take this one step at a time and get to `IO [(FilePath, Int)]` first
22:07:02 <benjwadams> I want to get the count of any files in the subdirectory and zip them with the subdirectory names, returning the latter type, then transform into a map
22:07:58 <koz_> So, first-off, you actually have 'stuff' which is your original directory listing, right?
22:08:05 <koz_> And then you produce 'somevalue' from that, right?
22:08:26 <koz_> :t zipWith
22:08:27 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
22:08:31 <benjwadams> :t zip
22:08:32 <koz_> ^ may give you a clue.
22:08:33 <lambdabot> [a] -> [b] -> [(a, b)]
22:08:47 <koz_> zipWith is more appropriate in your case I think.
22:09:07 <benjwadams> I want to make key value pairs
22:09:14 <koz_> In your case, a ~ FilePath, b ~ [FilePath], c ~ (FilePath, Int).
22:09:48 <koz_> So you need zipWith with a function whose type is FilePath -> [FilePath] -> (FilePath, Int).
22:10:19 <benjwadams> sounds good
22:10:52 <benjwadams> still wondering about the filter though
22:12:14 <koz_> You have a nested list. Do you need to filter the outer list, some of the inner lists, all of the inner lists, something else?
22:13:26 <benjwadams> I need to filter out elements in the inner nested lists which don't match an extension or aren't files
22:13:35 <koz_> :t fmap . fmap
22:13:37 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
22:13:44 <benjwadams> thus it's going to need to have `FilePath -> IO Bool`
22:13:46 <koz_> You need to lift several times.
22:13:52 <koz_> :t traverse . traverse
22:13:54 <lambdabot> (Applicative f, Traversable t1, Traversable t2) => (a -> f b) -> t1 (t2 a) -> f (t1 (t2 b))
22:14:09 <koz_> ^ is probably what you need to do your filtering.
22:14:23 <koz_> You're lifting through multiple layers, since you have a nested list in IO.
22:14:46 <koz_> If it helps, consider that in your case, both t1 and t2 are [].
22:15:14 <koz_> Wait, hold on, sorry.
22:15:34 <koz_> :t filterM
22:15:36 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
22:15:48 <koz_> :t \f -> traverse (filterM f)
22:15:50 <lambdabot> (Traversable t, Applicative f) => (a -> f Bool) -> t [a] -> f (t [a])
22:16:27 <koz_> Now set t ~ [], f ~ IO.
22:16:31 <koz_> Look familiar?
22:19:58 <benjwadams> `(traverse . traverse) (filterM checkIfWaveFile)`
22:20:36 <koz_> You don't need two traverses I don't think.
22:20:52 <koz_> :t \f -> traverse (filterM f)
22:20:54 <lambdabot> (Traversable t, Applicative f) => (a -> f Bool) -> t [a] -> f (t [a])
22:21:02 <koz_> Right, now set t ~ [], f ~ IO.
22:21:12 <koz_> The result type should look _very_ familiar.
22:38:24 <benjwadams> now my function is broken due to relative pathing.  But the return type is correct! `traverse (filterM checkIfWaveFile) allSubDirsFiles`
22:38:45 <koz_> benjwadams: I think the relative pathing thing was addressed by MarcelineVQ's edit to my original example.
22:59:13 * hackage ghc-events 0.13.0 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.13.0 (MitsutoshiAoe)
23:26:35 <benjwadams>  https://bpaste.net/CMWQ
23:27:10 <benjwadams> I got a working prototype.  That was a lot more difficult to do than most langs I'm used to.  Does it eventually become easier to reason about types?
23:28:43 <benjwadams> anyhow, thanks for the pointers.  dozing off now
23:30:29 <pie_[bnc]> has anyone seen someone do something in haskell like suspending a program on a write error (due to say, full disk) and allowing the user to continue the program after alleviating the error condition?
23:30:43 <pie_[bnc]> ive seen stuff like this mentioned for lisp but i cant remember the keyword right now
23:33:23 <Cale> Step 1) Run out of disk space. Step 2) Catch the exception. Step 3) Capture the current continuation of the program as a static closure. Step 4) Write that closure to d...
23:33:55 <pie_[bnc]> Cale: hehe
23:34:07 <pie_[bnc]> so maybe not xmonad
23:34:43 * hackage jira-wiki-markup 1.3.0 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.3.0 (tarleb)
23:38:27 <Cale> pie_[bnc]: But yeah, in Haskell, we don't make that easy from an arbitrary setting, you kind of have to prepare your program specially in some way to make such a recovery possible. It's possible that static pointers could be part of a solution. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#static-pointers
23:38:40 <jeetu> Hi. Is there a log of haskell irc which can be searched?
23:39:03 <Cale> Though in most cases, one could just define a data type for the parts of the program that the static pointers would have referred to.
23:39:56 <Cale> jeetu: hmm, I'm not sure at the moment, there have been at various times, and of course you could grab the logs from the link in the topic to be able to search locally
23:40:54 <jeetu> Cale: Ok
23:41:04 <jeetu> Cale: Thanks
23:41:40 <pie_[bnc]> Cale: yeah I figured id probably have to use something other than the IO monad
23:41:57 <pie_[bnc]> ill look at that static pointers thing
23:41:58 <Cale> pie_[bnc]: Yeah, IO actions aren't directly serialisable.
23:42:11 <pie_[bnc]> Cale: i mean, i didnt thing serializaiton would be necessary at all
23:42:14 <pie_[bnc]> *think
23:42:30 <pie_[bnc]> just "pause" the program
23:42:35 <Cale> Well, maybe this is just my misinterpretation of what it means to "resume"
23:42:49 <Cale> You could catch an exception and just wait for user input before retrying
23:43:02 <pie_[bnc]> yeah thats what i meant i guess
23:43:21 <pie_[bnc]> oh well yeah i guess thats a pretty obvious way to do it isnt it
23:44:19 <pie_[bnc]> i immediately jumped to something being a deeper component of the program
23:46:19 <Cale> I sort of assumed you wanted the program to be able to shut down entirely and resume from where it left off when run again.
