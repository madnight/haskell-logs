00:00:26 * dsal goes to sleep after doing enough thinking for a day
00:01:02 <tdammers> my "network status" is just sed-filtered output from the `ip` command
00:01:34 <tdammers> shows me the IP address, interface name, and (if applicable) wireless network name, for each connection that is "up"
00:01:40 <tdammers> (except lo)
00:12:15 * hackage systemd 2.3.0 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-2.3.0 (erebe)
00:52:10 <jonathan_> I'm reading htrough the "all you needa know about the yoneda lemma" functional pearl and stumbled upon the following sentence: "Thus, a preorder on any kind of carrier is equivalent to one on sets using inclusion, just as a monoid on any kind of carrier is equivalent to one on functions using composition."
00:52:35 <jonathan_> googleing "a preorder on any kind of carrier" turns up a LOT of cellphone related hits
00:52:55 <jonathan_> what does "carrier" mean in this context?
00:54:06 <opqdonut> jonathan_: the domain of the preorder, the set of things being preordered
00:55:21 <opqdonut> like in math speak (P,<=) is a preorder with carrier P when <= is a reflexive transitive binary relation over P
00:55:28 <jonathan_> I see, thanks!
00:55:41 <opqdonut> usually people say "over X" or "on X" instead of "with carrier X" 
00:56:20 <opqdonut> even that quote says "on sets" and "on functions"
00:59:00 <jonathan_> I think I get the point. The second part of the sentence refers to the tranformation monoid right?
00:59:35 <jonathan_> Or rather a part ("subset"?) of the transformation monoid
01:00:24 <jonathan_> no scratch that, the full one, since the domain M maps to an endofunctor each if I'm not mistaken
01:25:44 * hackage leb128-cereal 1.0 - LEB128 and SLEB128 encoding  https://hackage.haskell.org/package/leb128-cereal-1.0 (JoachimBreitner)
02:29:03 <Athas> Ugh, how do I get a stack trace from a <<loop>>?
02:29:32 <merijn> Athas: profiling and +RTS -xc?
02:31:11 <Athas> Hm, I thought profiling was enough these days?  But +RTS -xc does make the stack trace show up.
02:32:14 <merijn> Athas: Profiling is enough for a stack trace, but -xc makes it log stack traces for all exceptions without touching code
02:33:02 <Athas> Now a bad question: if I have 'default-extensions: Strict' in my .cabal file, is there a way to disable that for just some modules?
02:34:12 <merijn> Athas: maybe LANGUAGE NoStrict pragma?
02:34:16 <merijn> No clue if that works, though
02:35:05 <Athas> I will find out!
02:38:45 <Tuplanolla> Hey, Athas. Was FHPNC 2020 canceled for good?
02:38:53 <Athas> Tuplanolla: yes, unfortunately.
02:39:27 <Tuplanolla> The deadline is still on the important date list, so I wasn't sure.
02:41:39 <Athas> Oh, right.  Should be gone now.
02:46:59 <maerwald> I wish you could have strict modules have a different file extension
02:47:05 <maerwald> It really needs to be visible
02:49:17 <Tuplanolla> I guess the TyDe workshop is still close enough.
03:30:33 <tdammers> don't you just hate it when you make a 1-byte change to your codebase, and EVERYTHING needs to be recompiled?
03:32:53 <davve> sounds like you might want to restructure your code (if compile time is an issue)
03:33:32 <merijn> davve: That's not always possible
03:34:59 <merijn> Like, if I have 60 modules and one core module is dependent on by most of the others than any change to that *will* recompile everything and it will take ages
03:36:04 <davve> naturally
03:36:49 <merijn> I've taken a lot of effort to minimise the transitive dependencies to minimise recompilation, but compile time is still a massive bottleneck for me
03:37:02 <Tuplanolla> That's what you get for having a `Types.hs`.
03:37:11 <merijn> Tuplanolla: I don't even have that >.>
03:37:43 <merijn> Tuplanolla: Also, if GHC wasn't so annoying and properly supported cyclical imports then people wouldn't need to *have* a Types.hs
03:37:54 <Tuplanolla> That's true.
03:40:34 <merijn> There's hs-boot files, but in the past I haven't ever been able to make those work
03:43:20 <tdammers> davve: in my case, that's not possible. or at least I don't see a way.
03:43:40 <tdammers> the application consists of about a dozen individual binaries; one of them acts as a "hub" that spins up the others on demand
03:43:52 <tdammers> in order for the hub to find the others, they have to be in a predictable location
03:44:12 <tdammers> ergo, cabal build, which would do proper incremental builds, isn't the best choice
03:44:29 <tdammers> instead, I'm using cabal install, with a custom installdir, from where the hub picks up the other binaries
03:45:00 <tdammers> the problem is, of course, that cabal install insists on making an sdist bundle and doing all sorts of other work that makes sense, but is unnecessary in my case
03:45:29 <tdammers> and because all those binaries also depend on one library that is shared between them, any change to that library triggers a rebuild of pretty much the entire thing
03:46:32 <tdammers> I'm actually quite happy already that restarting the "hub" application is fairly seamless, that is, it persists its state and picks back up where it left off after a restart
03:47:05 <fendor> tdammers, why not utilise cabal-plan to find the locations after cabal build?
03:48:12 <merijn> tdammers: Would it be ok if the build was kicked of by the "hub" binary?
03:48:55 <merijn> tdammers: i.e. the "hub" runs one of the others (which was changed) and that triggers a rebuild
03:49:07 <merijn> (of that specific binary)
03:49:10 <tdammers> uhm
03:49:36 <tdammers> you mean defer the rebuild until the hub actually needs the binary?
03:49:52 <tdammers> I don't think that would work awfully well
03:49:58 <tdammers> fendor: that might actually work
03:49:58 <merijn> tdammers: Well, I mean "if you forgot to rebuild and the hub enters triggering one, is that a problem"
03:50:34 <tdammers> merijn: I want to see the fallout of code changes ASAP, so that would probably not be a useful setup
03:50:37 <merijn> tdammers: Because I have a simple setup with some shell scripts that utilises "cabal run" to run things (which will automatically trigger a rebuild)
03:50:54 <Axman6> A while ago someone released a tool for generating haskell projects, which had a bricked based TUI, anyone remember what it was?
03:51:02 <merijn> tdammers: The downside is, if the code changes and you don't manually build first then running the script will trigger a rebuild
03:51:43 <merijn> tdammers: But you can simply put those shell scripts in a predictable location (I use the working dir of my project) and use those so I don't have to bother locating the actual binaries
03:52:28 <merijn> tdammers: (Actually, I do something even worse, I have a single script for all binaries and base the one to run on which symlink is invoked >.>)
03:53:29 <fendor> Axman6, summoner?
03:53:42 <Axman6> yep, that's the one, thanks!
03:53:44 <merijn> tdammers: The simplest incarnation is something like: http://dpaste.com/0T56D28
03:54:09 <merijn> tdammers: In some projects I look up the path to the project file via the path of the script (they're in the same dir) and invoke that way
03:57:12 <tdammers> I'm pretty happy with what I have now, I just wish the build were faster
03:58:02 <merijn> Story of my life ;)
03:58:10 <merijn> 8.8 and 8.10 are supposedly faster
03:58:25 <tdammers> I *am* on 8.8
03:58:59 <tdammers> (and it's actually almost bearable on my "proper" computer, the 6-core one in my study room - but I can't easily take that one upstairs to work on the balcony)
03:59:12 <tdammers> maybe I should just ssh into that computer and build there
04:14:43 <__monty__> tdammers: Or setup nix and use a remote build host : )
04:16:41 <tdammers> __monty__: I'm up for that, minus the nix part
04:17:27 <merijn> tdammers: But Nix makes everything better at no cost! ;)
04:20:19 <tdammers> ah yes, I forgot about that part
04:20:47 <merijn> tdammers: Common mistake ;)
04:20:55 <__monty__> tdammers: Nix makes remote builds as easy as a couple lines of configuration but suit yourself. The trade-off is you mostly give up incremental builds (unless you painstakingly split everything up or use haskell.nix) but you said you're not profitting from incremental builds anyway.
04:21:37 <merijn> __monty__: You're ommitting some important implicit things there
04:22:14 <merijn> Like "Nix makes remote builds as easy as a couple of lines of configuration" is missing the implicit "after you've done all the configuration and porting work of getting something to build with Nix in the first place"
04:22:15 <__monty__> Aren't we all?
04:22:37 <__monty__> That's rarely hard with a haskell project though.
04:23:15 <merijn> My number one gripe with all the Nix shills in #haskell is the glossing over the very real costs of getting it to work to begin with
04:23:33 <merijn> It's all "look at this long list of benefits of Nix!"
04:24:06 <merijn> That's all nice and well, but unless you're volunteering to port my code to build with Nix, it's worthless as far as advice goes
04:25:10 <merijn> It's honestly equivalent to someone going "hey, I have this problem building this project on Windows" and replying "just use linux"
04:25:19 <tdammers> __monty__: getting back to the point where I can do incremental builds again is pretty much what I'm looking for
04:26:33 <tdammers> __monty__: that, and the fact that when I talked to some of the nix developers (in person, mind you) and asked them about my main concerns, the answer was basically "yes, we know, but we have no idea how to fix those"
04:32:37 <__monty__> merijn: In most cases is entirely straightforward though. If you can build your project with cabal or stack you can probably build it using nix. It's not like rewriting a project's build system.
04:33:22 <__monty__> If you don't like nix then don't use it. Was just a suggestion because it makes remote builds dead simple.
04:40:27 <fendor> __monty__, does it? I could not find any nice documentation for it. And building with haskell.nix so far was far from a pleasant experience
04:52:15 * hackage data-category 0.8 - Category theory  https://hackage.haskell.org/package/data-category-0.8 (SjoerdVisscher)
05:04:18 <__monty__> fendor: Yeah, nix on both machines, setup an ssh key so the client can access the remote build host and add a line of config on the client so it knows what host to use.
05:07:21 <tdammers> won't that have the automation copy source files and build output back and forth though?
05:07:38 <tdammers> I'd rather just move the entire dev environment over to the build host and develop over ssh
05:10:45 <fendor> __monty__, only nix is required? Not nixos? With nix-deploy, or what tool?
05:13:20 <merijn> __monty__: You still need to install Nix, read all the documentation on how to use it, figure out how to tie your cabal project into that, etc. that's a non-trivial amount of docs reading and research and I can't say that the reputation of Nix' docs makes that prospect anymore enjoyable
05:13:58 <srk> merijn: docs improved quite a lot recently 
05:14:18 <srk>  https://nixos.org/nixpkgs/manual/#haskell https://github.com/Gabriel439/haskell-nix
05:14:40 <srk> these two are pretty good to get you started, tons of examples around as well
05:15:00 <merijn> srk: Possibly, but even if the docs are flawless I'd estimate it'd still be *at least* 2-3 days of work to get up and running
05:15:23 <srk> well sure but potential time savings greatly outweight that if you do a lot of Haskell 
05:15:54 <srk> especially deployment is almost for free when you have nix files for your projects
05:16:03 <__monty__> fendor: Only nix yeah, no other tools, no nixos.
05:16:23 <__monty__> tdammers: Yeah, but how's the remote machine gonna build anything without sources?
05:16:36 <merijn> srk: I don't do deployment, though. So I just use a cabal freeze file and done :p
05:17:05 <__monty__> merijn: I never claimed nix's UX was great, or even good. If you want polished UX, nix is not (yet, fingers crossed) the place to be.
05:17:24 <merijn> srk: I'm not saying Nix never has benefits. I just get super annoyed by people acting as if "switching to Nix" is a 5 minute task that will solve all problems
05:17:53 <merijn> srk: It's a multi-day task that may or may not solve some of your problems, depending on which problems you have
05:18:08 <srk> yes, of course
05:18:18 <srk> I mostly suggest nix to people struggling with stack :)
05:18:48 <srk> (especially on #nixos as stack support isn't stellar and IMHO quite redundant)
05:19:07 <__monty__> It's only a multi day task if you go it alone and your project's not dead simple to convert. Feel free to have a different opinion though.
05:19:08 <srk> no tool is a silver bullet of course
05:19:42 <merijn> __monty__: Most times when people chime in with Nix it's too people who *are* going it alone
05:19:55 <srk> <citation needed>
05:19:57 <__monty__> I never bothered with remote builds until I tried nix because it makes that so simple.
05:20:02 <merijn> __monty__: And if my project was dead simple, why would I need Nix?
05:20:22 <__monty__> merijn: For the easy remote builds : )
05:20:24 <merijn> Nix is only helpful in cases where setting it up is not trivial >.>
05:20:37 <davve> 16
05:21:17 <tdammers> __monty__: install the entire toolchain there and pull it in with git.
05:21:21 <merijn> srk: If people were working in a team of haskellers to build things they wouldn't be asking advice here instead of their colleagues. Also, now you need to teach your whole team Nix :)
05:21:25 <tdammers> __monty__: I need the sources there for editing anyway,
05:21:44 <merijn> tdammers: Team "remote development and building over SSH"!
05:21:54 <tdammers> merijn: reporting in!
05:22:03 <srk> merijn: well for haskellers picking up nix is easy, just another lang / dsl :D
05:22:06 <__monty__> tdammers: I routinely work over ssh and it's just generally less pleasant than editing locally.
05:22:19 <tdammers> __monty__: I don't really notice much of a difference
05:22:30 <tdammers> __monty__: but maybe that's because my toolchain is quite suitable for this approach
05:22:36 <__monty__> merijn: I'm not talking about solo vs team. I'm talking about asking for help in #nixos.
05:22:47 <tdammers> __monty__: I'd probably hate it if I had to X-forward GUI applications or some such
05:23:12 <__monty__> My setup is tmux, ghcid and vim. I don't think it gets more optimal for remote editing over ssh.
05:23:21 <tdammers> __monty__: the problem with asking for help in the nix community is that they rarely teach you how to fish, all you get is buckets of fish
05:23:43 <tdammers> __monty__: same here, but I don't experience the slightest bit of discomfort, really
05:23:57 <__monty__> That's definitely not my experience with the nixos community.
05:28:24 <tdammers> I suspect that for some reason, the initial experience people have with nix varies drastically
05:29:45 <__monty__> Definitely depends on where you're coming from. I was frustrated with haskell development on arch and nix was bliss.
05:30:09 <tdammers> haskell on arch is apparently quite ghetto
05:30:19 <__monty__> If you don't have any problems with your setup rn then the admittedly lousy UX is probably gonna rub you the wrong way.
05:31:10 <__monty__> It doesn't have to be but the way they package GHC and haskell software basically causes mass rebuilds all the time, which is really annoying.
05:32:35 <__monty__> I've since learned to love NixOS. Being able to set up your entire system in configuration.nix and the ease of rolling back failed updates is so nice.
05:32:47 <srk> __monty__: I've recently switched from ssh to eternal-terminal aa I'm xmonad user and don't want another tiling in form of tmux, works pretty well, had to set OOMScoreAdjust for it, should proly PR that 
05:32:55 <srk> s/aa/as/
05:33:21 <srk> terms survive suspends of the remote machine which is .. epic
05:34:03 <__monty__> You would introduce state into my nice and declarative setup?! How dare you : )
05:34:16 <srk> :D
05:34:28 <buggymcbugfix> Where does one point a Haskell beginner to? https://typeclasses.com/?
05:34:58 <srk> http://learnyouahaskell.com/
05:35:27 <hpc> there's a list of resources on haskell.org under the documentation section
05:36:16 <hpc> that's probably a better starting point to reference, since it can update as tutorials are created and obsoleted
05:50:12 <jchia_> I have a megaparsec 8 question. Now that the the MonadFail proposal is fully implemented, what's the proper way to fail in a parser? E.g. I'm trying to write a "fooParser :: (MP.MonadParsec e s m, MP.Token s ~ Word8) => m Foo". What's the proper way to fail parsing? Just use fail, adding a "MonadFail m" constraint? Is there a better way? parseError  seems like a another way but I'm not really sure how to think about it as constructing 
05:50:12 <jchia_> a ParseError seems harder than the actual parsing itself.
05:53:14 <buggymcbugfix> srk: LYAH is nice but it's a bit slow-paced.
05:53:37 <buggymcbugfix> hpc: great, thanks
05:54:01 <buggymcbugfix> hpc: the university courses look good, I've consulted some of those in the past, didn't know they were collated here +1
06:01:13 <__monty__> buggymcbugfix: CIS194 is definitely the one I see most oft recommended.
06:02:39 <buggymcbugfix> __monty__: yes, that is a great one. I used that myself a few years ago, can't believe I had forgotten that. *hangs head in shame*
06:04:12 <merijn> jchia_: Use mzero
06:04:24 <merijn> jchia_: or empty
06:04:35 <merijn> jchia_: (if you don't care about the quality of the error message)
06:05:00 <jchia_> merijn: If I do, I construct an informative ParseError, right?
06:05:46 <merijn> jchia_: parseError lets you provide your own fancy error reporting, yes. If you just wanna play with your parser you can use mzero or empty and replace them with something better later
06:06:13 <jchia_> merijn: What if I just want to provide a string description?
06:06:52 <merijn> You'd have to find some way to turn a String into a ParseError
06:07:21 <jchia_> merijn: OK. I didn't see any helper function to do that, so I'll probably have to do it myself.
06:07:43 <merijn> jchia_: Acutally
06:07:48 <merijn> I think you just want label?
06:08:11 <merijn> 'label "foo" mzero' should work
06:09:22 <merijn> jchia_: Actually, if you just use ParsecT you can just use fail anyway
06:09:43 <jchia_> merijn: label "error description" mzero
06:10:17 <jchia_> I'm defining the parser for MonadParsec, so there's no fail, but there's mzero
06:18:58 <jchia_> If I use fail, I have to add a MonadFail constraint
06:25:12 <maerwald> tdammers: you can't teach something that has inherently no structure (as in: there's no design behind it). It's like teaching how to do shell scripting. It's really hard. Everyone does everything.
06:59:33 <jchia_> I have source-repository-package entries in my cabal.project. Is there a way to leave their build artifacts alone when I cabal clean?
06:59:55 <phadej> not currently
07:00:21 <phadej> there slow work towards making them cachable in .cabal/store
07:00:37 <jchia_> OK
07:02:03 <nowhere_man> I tried putting the code from a Codewars kata into a stack project, I copied the code of the kata in src/ and the test in test/Spec.hs
07:02:39 <nowhere_man> when I do `stack test`, I get `<no location info>: error: output was redirected with -o, but no output will be generated because there is no Main module.`
07:02:59 <nowhere_man> after a bit of googling, I fail to understand where the issue is
07:05:05 <sm[m]> nowhere_man: your main file needs to be called Main.hs, unless you specify it with main-is: in package.yaml
07:05:44 * hackage iso-deriving 0.0.7 - Deriving via arbitrary isomorphisms.  https://hackage.haskell.org/package/iso-deriving-0.0.7 (HansHoglund)
07:06:52 <sm[m]> jchia_: note that a megaparsec failure or ParseError just stops the current parse branch, it doesn't stop parsing entirely
07:14:36 <absence> is there a simple way to sort a vector, or is V.fromList . sort . V.toList the way to go?
07:15:45 * hackage streamly 0.7.2 - Beautiful Streaming, Concurrent and Reactive Composition  https://hackage.haskell.org/package/streamly-0.7.2 (pranaysashank)
07:15:50 <ChaiTRex> absence: Use the vector-algorithms package: https://hackage.haskell.org/package/vector-algorithms
07:15:56 <ChaiTRex> absence: Several sorts in there.
07:17:04 <nowhere_man> sm[m]: I have an app/Main.hs
07:17:29 <nowhere_man> my code skeleton was produced by `stack new foobar new-template`
07:18:02 <sm[m]> is there a module declaration in your Main.hs ?
07:18:04 <absence> ChaiTRex: i saw that one, but they all return m () rather than a vector
07:20:27 <jchia_> sm[m]: When you say 'branch' do you mean something like (<|>)?
07:20:58 <sm[m]> jchia_: yes, if there are alternatives it will keep trying those
07:21:16 <ChaiTRex> absence: Then clone the vector and mutate it.
07:21:30 <jchia_> sm[m]: Sure, that's the normal behavior in a parser.
07:22:07 <sm[m]> it wasn't obvious to me when I wanted to report a "final" parse error, so I mention it
07:23:13 <jchia_> sm[m]: The way I think of parser is that it's a hierarchical decomposition of parts. When would the failure to decompose a small part a certain way prompt the entire parse to fail? Do you have a concrete example?
07:23:20 * hackage futhark 0.15.5 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.15.5 (TroelsHenriksen)
07:23:24 <absence> ChaiTRex: doesn't that imply some kind of monadic context?
07:24:21 <nowhere_man> sm[m]: there's a Main module with a main function
07:25:04 <sm[m]> sometimes one of your parse alternatives might see something unambiguously wrong, and you want to report a precise error for that, without letting other alternatives mask that error
07:25:25 <sm[m]> nowhere_man: and does Main.hs have a "module ..." declaration at the top ?
07:25:46 <sm[m]> if it does, it should say "module Main ..."
07:25:59 <nowhere_man> sm[m]: yes `module Main where`
07:26:56 <sm[m]> nowhere_man: no other changes since you created the project ? That's strange, then. I ran the same command and it builds fine
07:27:32 <ChaiTRex> absence: You can use the ST monad.
07:27:42 <ChaiTRex> :t runST
07:27:44 <lambdabot> (forall s. ST s a) -> a
07:28:48 <absence> ew
07:29:36 <sm[m]> jchia_: am I making sense ? I don't have a real example handy, but imagine some syntax where there's a a choice of keywords followed by values, and you successfully parse a keyword but then the value is invalid, so you want to end parsing with a "bad value for keyword K" error
07:30:25 <Axman6> absence: it sounds like ST is exactly the thing you want
07:30:28 <jchia_> sm[m]: I see, but if you don't end it right there, usually a higher-level parser will eventually fail because this part failed
07:31:02 <nowhere_man> sm[m]: I get it, I did it all from scratch with Git, and I removed a `main :: IO ()` from Spec.hs
07:31:19 <sm[m]> possibly, not necessarily, and even so it will not be able to give as precise an error message
07:31:33 <absence> Axman6: yes, it's just a lot more noisy than "vectorSort" or something, although i can of course define that locally
07:32:35 <sm[m]> jchia_: it may not arise for you, it depends on what you're parsing and whether good errors matter
07:32:36 <tdammers> maerwald: sure. but shell script happened by accident; nix has quite an opinionated design behind it. it's supposed to be the answer to a system strung together with perl and shell script in an ad-hoc-scratch-my-itch fashion
07:32:54 <tdammers> if nix is like that, I'll just stick with the shell script mess
07:33:07 <jchia_> sm[m]: OK, you want to stop right there and have control over the error message.
07:33:07 <tdammers> at least I know my way around that one, and I can make it do what I want
07:33:29 <maerwald> tdammers: and shell language doesn't change that often :P
07:33:47 <absence> ChaiTRex: thanks for the tip
07:33:49 <nowhere_man> I had a spec :: Spec definition
07:34:02 <ChaiTRex> absence: No problem.
07:34:40 <sm[m]> jchia_ yep
07:36:19 <nowhere_man> sm[m]:  I added main = hspec spec and I get the same error again
07:37:49 <sm[m]> nowhere_man: stop doing that then ? :)
07:44:26 <nowhere_man> I finally got it: I copy/pasted from Codewars a first line of `module RailFenceCipher.TestsSpec (spec) where`
07:44:34 <nowhere_man> that's what was causing the issue
07:44:52 <nowhere_man> so I guess there's an implicit Main module in Spec.hs where there is no such line?
07:46:16 <Axman6> yes
07:47:18 <sm[m]> I think the GHC errors in this area could be better
07:55:19 <jchia_> What does it mean by "GHC 8.10.1 includes Cabal 3.2.0.0"? When I installed ghc 8.10.1, I don't see a cabal binary installed with the ghc binary. https://www.haskell.org/cabal//download.html
07:57:30 <merijn> jchia_: Cabal is not the cabal executable
07:57:30 <phadej> jchia_: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
07:57:32 <merijn> jchia_: See: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
07:57:42 <phadej> merijn: nice :)
07:58:02 <jchia_> OK
07:58:14 * hackage telegram-types 0.4.0 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.4.0 (Poscat)
07:58:15 <merijn> I should've made a blog before before going "Haskell viral" and wasting that google juice ;)
07:59:39 <jchia_> So the Cabal meant here is the library? Why does GHC need to include the Cabal library? If Cabal is a build system, doesn't Cabal get to invoke ghc instead of the other way round?
08:00:14 <c_wraith> Cabal is a library for parsing .cabal files
08:00:20 <c_wraith> it is not a build system
08:00:38 <c_wraith> I thought the link spelled that out pretty clearly
08:00:44 <jchia_> OK, but cabal the binary implements a build system, right?
08:00:49 <maerwald> c_wraith: I think it includes the dependency resolution part ghough, doesn't it?
08:01:28 <c_wraith> It includes enough to run Setup.hs files
08:01:29 <jkachmar> jchia_: GHC is shipped with quite a few libraries, actually; you can see a list of them here: https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history
08:01:49 <c_wraith> Which includes dependency checking, but not solving or installation
08:02:12 <merijn> c_wraith: I don't think I agree. Cabal does most/all of the lifting (else Setup.hs wouldn't work either)
08:02:41 <merijn> c_wraith: cabal-install/stack mostly do "select the various dependencies and ensure those get installed"
08:02:48 <c_wraith> last I checked, Setup.hs only works when the dependencies are already installed
08:03:00 <jchia_> Does cabal executable use the Cabal library in GHC to do stuff? If so why can't it be self-contained? It seems like excessive coupling.
08:03:15 <merijn> c_wraith: Sure, but Setup.hs is inside Cabal, not cabal-install and it does the building
08:03:44 <c_wraith> Ah, ok.  It's a build tool, but not a dependency solver.  ok, that's fair.
08:04:42 <maerwald> jchia_: cabal-install uses the Cabal library
08:04:58 <maerwald> It doesn't care whether that library was shipped with GHC
08:05:54 <jchia_> maerwald: So the Cabal library that ships with GHC is useful and relevant in case you want to build cabal executable against it, correct?
08:06:28 <maerwald> I don't really understand the question, but: probably?
08:06:52 <jchia_> I mean what's the connection between the GHC Cabal library and the cabal executable?
08:07:06 <jkachmar> merijn: From my reading of the `cabal-install` source it looks like all of the solver stuff is there, rather than in the `Cabal` library code
08:07:12 <jchia_> a particular cabal executable I have on my filesystem and the Cabal library installed with my GHC on my filesystem.
08:07:21 <jchia_> OK
08:07:22 <merijn> jkachmar: The solver is in cabal-install, the building is in Cabal
08:10:13 <jkachmar> jchia_: `Cabal` is a library; `cabal-install` is the build tool that uses `Cabal` (the library).
08:10:14 <jkachmar> GHC ships with `Cabal` (the library) because it's needed to do some important GHC things.
08:10:50 <jchia_> jkachmar: Not so that you can build your project against the Cabal library, correct?
08:11:09 <jchia_> (You'd have to get it from hackage separately)
08:11:48 <jkachmar> If you're getting `ghc` and `cabal-install` from, say, `ghcup` it's likely that you'd also get a `cabal-install`binary from the tool that was built using the same version of `Cabal` that was shipped with GHC just as a matter of convenience.
08:12:44 <jkachmar> If you're developing/building a project that _depends_ on `Cabal` (the library) then it may be downloaded from Hackage if the version that shipped with whatever version of GHC you're using doesn't match the version required by your project.
08:18:24 <sm[m]> in NewHaskell we'll give these things clearer names
08:19:45 * hackage haskoin-store 0.22.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.22.0 (jprupp)
08:23:35 <sm[m]> or preferably, they'll be one tool
08:23:51 <maerwald> sm[m]: uh-oh
08:25:45 <aveltras> i'm trying to setup some template haskell functions for use in yesod handlers but seems im not there yet. What i'd like to do is to have a function which generate the code to provide a restful response. I'd like to just have to give some arbitrary params and a template name in the handler. This would look kinda like the following
08:25:50 <aveltras> https://www.irccloud.com/pastebin/6BjUr8h2/
08:26:15 * hackage telegram-raw-api 0.2.0 - Servant bindings to the Telegram bot API  https://hackage.haskell.org/package/telegram-raw-api-0.2.0 (Poscat)
08:26:56 <aveltras> is it possible ? i'd also like the template to be looked for in a subdirectory in my template directory, this subdirectory should be automatically inferred from the name of the foundation type, for example, if my type is App and im in the homeR handler, it should look for app/home.hamlet
08:39:45 <jchia_> cabal question: Can I specify multiple subdirs with a source-repository-package, or do I just have to have multiple source-repository-packages that differ only by subdir?
08:40:29 <maerwald> jchia_: the latter
08:40:58 <jchia_> OK
08:49:57 <kuribas> can you have lazyness and totality?
08:50:19 <kuribas> Is there a way to prove a lazy program is total?
08:51:14 * hackage validity-containers 0.5.0.2 - Validity instances for containers  https://hackage.haskell.org/package/validity-containers-0.5.0.2 (Norfair)
08:51:31 <solonarv> it doesn't seem uniquely difficuly to me, so you probably can have both in a language
08:51:46 <solonarv> but maybe there are practical issues that mean nothing of the sort has caught on
08:52:08 <kuribas> how do you prove there is no loop?
08:54:06 <kuribas> maybe rewriting a lazy list as a function?
08:58:27 <sshine> kuribas, how do you prove that a strict program is total?
08:58:46 <kuribas> sshine: by limiting recursion
08:58:56 <hseg> so i'm writing a quickcheck test to check that multiple implementations of the same function are consistent (for regression testing). how do i get quickcheck to display the inputs/outputs that are inconsistent?
08:59:01 <kuribas> and having only total primitives
08:59:52 <tdammers> kuribas: unfortunately, that would make many perfectly reasonable programs impossible to write
09:00:11 <tdammers> kuribas: we're essentially talking about the incompleteness theorem here
09:00:44 * hackage data-category 0.8.1 - Category theory  https://hackage.haskell.org/package/data-category-0.8.1 (SjoerdVisscher)
09:00:56 <kuribas> tdammers: what would?
09:01:30 <tdammers> kuribas: limiting recursion and primitives so that all programs written in the language are total by construction
09:01:52 <tdammers> kuribas: you would basically have to get rid of Turing completeness
09:01:53 <kuribas> tdammers: you cannot be total if you allow unbounded recursion
09:01:58 <kuribas> tdammers: indeed
09:02:01 <tdammers> kuribas: exactly.
09:02:16 <kuribas> it's exactly what I want for my language
09:02:24 <tdammers> oh, OK
09:02:24 <sshine> kuribas, I recall a term like 'size-change termination'. I wonder, as you say, if it isn't somewhat the same for laziness, except expressed differently?
09:02:50 <kuribas> sshine: I don't know...
09:07:15 <berndl> I never realized this until today, but it seems that Alternative is a vain attempt at modelling Kleene algebras. Is this assessment correct?
09:08:32 <oats> ghc-lib-parser      > [200 of 207] Compiling OccurAnal
09:08:34 <oats> hmmmmmmmmmm
09:10:19 <sshine> oats, reminds me of a course that once was, "Introduction to Analysis", or "AnalIntro" for short.
09:10:25 <oats> lol
09:10:50 <sshine> It might've been Numeric Analysis. I don't know. I didn't take it. there were some stupid names though. :)
09:11:41 <solonarv> my uni dodges this by shortening to Ana instead
09:11:44 <solonarv> ;)
09:12:32 <[exa]> that must be terrible, everyone confusing with anamorphisms!
09:15:45 * hackage validity-containers 0.5.0.3 - Validity instances for containers  https://hackage.haskell.org/package/validity-containers-0.5.0.3 (Norfair)
09:19:44 <hseg> [exa]: no worse than the category of banach analytic manifolds, or BanAnaMan
09:19:54 <monochrom> haha
09:20:26 <Cale> berndl: More or less, but annotated with results?
09:20:56 <Cale> I don't know whether "vain attempt at" is fair
09:21:16 <hseg> hrm. so i can get quickcheck to give me the failing inputs, but not what the outputs were
09:21:55 <Cale> hseg: hmm, I thought there was a configuration option for that..
09:22:19 <Cale> Well, of course, if you're producing a Bool, it's not going to have the results
09:22:37 <solonarv> Cale: tbf, you need recursion to turn Applicative + <|> + empty into a kleene star
09:22:56 <Cale> solonarv: Yeah, but it does that with some/many
09:22:58 <[exa]> hseg: oh man
09:23:06 <Cale> hseg: Are you using === ?
09:23:06 <hseg> right. it should rather be Either res [([method], res)]
09:23:25 <hseg> no, didn't know it existed
09:23:53 <hseg> frankly, this is my first time using quickcheck, so i'm probably doing things wrong
09:24:15 * hackage telegram-raw-api 0.3.0 - Servant bindings to the Telegram bot API  https://hackage.haskell.org/package/telegram-raw-api-0.3.0 (Poscat)
09:24:36 <hseg> quickcheck code at http://ix.io/2jdJ
09:25:06 <hseg> impls :: [Int -> Partition -> Either Int Int]
09:25:14 * hackage launchdarkly-server-sdk 2.0.0 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-2.0.0 (launchdarkly)
09:26:27 <hseg> (where the Left case is basically the method's guess at the response)
09:31:36 <whatisRT> is there a way to refer to a specific version of a Haskell package in nix?
09:31:45 * hackage language-bash 0.9.1 - Parsing and pretty-printing Bash shell scripts  https://hackage.haskell.org/package/language-bash-0.9.1 (KyleRaftogianis)
09:33:19 <whatisRT> I have no idea how haskellPackages works, and I'm very confused because I can't find anything about it in the nixpkgs repo
09:37:18 <hseg> is there some way i can convert an Either err res into a Testable?
09:38:35 <hseg> basically, idea being that test case succeeded on Right, but that if a verbose output is desired, can get "case succ/fail w result foo"
09:44:08 <aveltras> is it possible to access the "Front" type in the widgetFile'' TH ? throwing error if the TH is not called in a correct context
09:44:14 * hackage language-bash 0.9.2 - Parsing and pretty-printing Bash shell scripts  https://hackage.haskell.org/package/language-bash-0.9.2 (KyleRaftogianis)
09:45:52 <hseg> q: is there a way to avoid repeated "deriving newtype instance C T => C N" for newtype N = N T ?
09:52:15 * hackage swagger2 2.6 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.6 (NickolayKudasov)
09:54:52 <Cale> hseg: You should be able to omit the constraint on that instance, if it's already satisfied.
09:55:00 <hseg> but it isn't
09:55:11 <Cale> hm, okay
09:55:25 <hseg> ... actually, i oversimplified the situation
09:55:34 <Cale> You can also just list the instances you want in the deriving clause
09:55:44 <hseg> it's C (T a) => C (N a) for newtype N a = N (T a)
09:55:47 <Cale> ... usually
09:56:02 <Cale> newtype N a = N (T a) deriving (C)
09:56:03 <hseg> and C (T a) only holds for certain a
09:58:45 <Cale> (you can also specify "deriving newtype" there using DerivingStrategies if you like)
09:58:53 <hseg> yeah. still fails
09:59:04 <Cale> why is that?
09:59:25 <hseg> can't derive C (T a) instance
09:59:45 <hseg> from which the C (N a) instance is supposed to be coerced
09:59:46 <Cale> Is GeneralizedNewtypeDeriving turned on?
09:59:51 <hseg> y
09:59:51 <Cale> oh
10:00:15 <hseg> need to go, be back in ~40m
10:00:16 <Cale> oh, okay, well, I guess you just write the full form out
10:00:39 <Cale> If you have a lot of them to generate and it's mechanical, you might be able to use template Haskell
10:00:40 <olavx200> https://bpaste.net/FR5A
10:00:53 <olavx200> Can I have some help with this error.
10:01:10 <hseg> 6 instances for 6 types
10:01:15 <hseg> annoying, not fatal
10:01:26 <hseg> but if it's removable, would prefer
10:01:47 <Cale> olavx200: What are you writing?
10:01:55 <Cale> olavx200: To generate the given error
10:02:09 <Cale> hseg: It'd probably be more than 6 lines of TH
10:02:31 <olavx200> I'm calling stepReverseSign -3 1 in the repl.
10:03:05 <Cale> That parses as   stepReverseSign - (3 1)
10:03:18 <Cale> and so you're treating 3 as a function
10:03:29 <Cale> and so it wants a Num instance for functions
10:03:39 <Cale> You probably meant to write (-3)
10:03:58 <olavx200> Thats right
10:04:28 <olavx200> Thanks a lot man
10:05:10 <Cale> no problem
10:13:15 * hackage squeal-postgresql 0.6.0.2 - Squeal PostgreSQL Library  https://hackage.haskell.org/package/squeal-postgresql-0.6.0.2 (echatav)
10:17:37 <nerdypepper> hiya, just started out with haskell, i have an operator (<>) in my module that i would like to export, but I get an "ambiguous occurence, could refer to Prelude", how could i export (<>) safely?
10:18:35 <Tuplanolla> Consider using another name.
10:19:19 <Tuplanolla> You can qualify it via `(Module.<>)`, but that's not nice.
10:19:19 <aveltras> nerdypepper: you can take https://github.com/aveltras/sessionula/blob/master/sessionula-extra/src/Sessionula/Extra.hs as an example, here the problem was for the lookup function
10:20:27 <nerdypepper> Tuplanolla: thanks that works, but ill consider renaming it
10:20:30 <monochrom> Perhaps choose another name. (<>) is now in Prelude and will stay there forever.
10:20:44 * hackage telegram-bot-simple 0.3.0 - Easy to use library for building Telegram bots.  https://hackage.haskell.org/package/telegram-bot-simple-0.3.0 (swamp_agr)
10:21:01 <nerdypepper> aveltras: how exactly is that working? i see you have exported `lookup`
10:21:38 <aveltras> that's lookup from the module
10:21:45 <monochrom> "import Prelude hiding (lookup)"
10:25:41 <aveltras> is it possible to access all instances from a specific typeclass which are in scope in a TH splice ? i've looked at reifyInstances but cannot make sense of the second parameter to the function
10:57:05 <kolu> hello
10:57:34 <kolu> I want to move an element from the back of a list to the front
10:57:53 <kolu> but with large inputs I get runtime errors
10:58:16 <monochrom> Show actual code on a paste website.
10:58:36 <[exa]> kolu: what kind of runtime error?
10:58:46 <monochrom> And not just that. Also how someone else can reproduce the same error.
10:58:57 <dsal> kolu: Also, not all lists have backs.  :)
10:59:39 <[exa]> "HS Error 405: List Too Long"
10:59:40 <Athas> kolu: I think 'last xs : init xs' would work for lists of about any length.
10:59:45 <dsal> More information would be useful, but if that's a thing you want to do more than once, you probably don't want to do it with a list.
11:01:06 <kolu> https://pastebin.com/X4CrjLwd
11:01:33 <kolu> that's the code
11:01:53 <kolu> but it's not about the code, when I think about it
11:03:44 <kolu> if linked lists are not suitable for searching by index and arrays are not suitable for inserting elements
11:04:03 <monochrom> then Data.Sequence is a possible good balance.
11:04:07 <dsal> That's silly levels of expensive.  Doing the same thing with Data.Sequence would be.  Feasible.
11:05:47 <monochrom> But shuffle can be done with splitAt and reverse in linear time.
11:07:25 <monochrom> shuffle a k = case splitAt (length a - k) of (pre,suf) -> reverse suf ++ pre
11:08:51 <monochrom> There is also a faster way to do [list !! x | x <- queries], if queries is in increasing order.
11:12:44 * hackage leb128 0.1.0.0 - LEB128 encoding logic for and in Haskell  https://hackage.haskell.org/package/leb128-0.1.0.0 (AndreasK)
11:13:38 <kolu> thank you
11:13:56 <kolu> I will have to decipher your suggestion first
11:31:13 <kolu> monochrom
11:31:14 <kolu> https://pastebin.com/ksEnSTeQ
11:31:23 <kolu> would that code follow the same principle
11:31:24 <kolu> ?
11:31:41 <monochrom> where is reverse?
11:32:09 <kolu> it does what its supposed to
11:32:15 <monochrom> I guess reverse would be wrong.
11:32:27 <monochrom> OK yes.
11:33:06 <kolu> so splitAt is linear and ++ is also linear?
11:33:12 <monochrom> Yes.
11:34:01 <kolu> I understand
11:34:14 * hackage haskoin-store 0.22.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.22.1 (jprupp)
11:34:34 <kolu> thank you
11:34:57 <kolu> I will try to figure the other part by myself
11:38:21 <monochrom> SIBC = structure and interpretation of bit coins >:)
11:52:31 <chloe_2> is there an analogue of take for Tree? I want to get upto level n
11:52:39 <chloe_2> depth*
11:52:55 <monochrom> Not in the standard library. Write it yourself.
11:53:00 <chloe_2> :/
11:53:15 <chloe_2> What do people do with unfoldTree? Just fold it again?
11:54:20 <monochrom> Strange question. Perhaps they really want to build a tree?
11:56:24 <chloe_2> I mean, they'd need it to be finite to do anything of use, wouldn't they?
11:56:54 <chloe_2> there isn't even a filter in Data.Tree? Isn't there only one way to define that?
11:59:52 <ChaiTRex> chloe_2: No, there are many ways to define that.
12:00:24 <ChaiTRex> chloe_2: Where do the child values go? Could go to the parent. Could go to a sibling. Could put one of the children as the new parent.
12:00:39 <ChaiTRex> chloe_2: If the parent is deleted, I mean.
12:01:14 <chloe_2> oh right. thanks
12:01:19 <chloe_2> how about takeWhile then?
12:01:22 <chloe_2> that should exist
12:02:40 <ChaiTRex> chloe_2: There's one major traversal order in a list. There isn't in a tree.
12:02:59 <chloe_2> but
12:03:09 <monochrom> Would you like to hear an Aesop fable.
12:03:29 <chloe_2> but isn't the obvious way to define it as "drop children if root fails test"?
12:04:07 <monochrom> A group of mice held a congress of mice to discuss how to evade being hunted down by the cat.
12:04:08 <ChaiTRex> chloe_2: No, there are use cases where that's not what you want. That's also not what happens with the list filter. It deletes one and only one element from the structure.
12:04:31 <ChaiTRex> chloe_2: (per failure)
12:04:48 <monochrom> They all agreed that obviously the needed to tie a bell under the neck of the cat, so everyone could get early warning when the cat approaches.
12:05:03 <monochrom> They also agreed that someone else should do it.
12:06:54 <chloe_2> ChaiTRex: I don't understand what you mean by "deletes an element"?
12:07:02 <chloe_2> I'm looking here https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#takeWhile
12:07:15 <chloe_2> and it just returns an empty list if the value fails the test
12:07:34 <chloe_2> similarly, it could just return an empty tree when a root fails the test
12:07:53 <ChaiTRex> chloe_2: I thought you were talking about filter.
12:07:59 <chloe_2> no, takeWhile
12:08:17 <chloe_2> I asked above "what about takeWhile then?"
12:08:22 <ChaiTRex> chloe_2: You need to specify what traversal order you're going to be using.
12:09:27 <chloe_2> I seem to be failing to grasp why traversal matters for takeWhile: you recursively apply takeWhile to all children, and that's it?
12:09:59 <ChaiTRex> chloe_2: Because takeWhile goes one-by-one until a predicate fails.
12:10:09 <ChaiTRex> chloe_2: One-by-one in which traversal order?
12:13:45 <chloe_2> something like 
12:13:46 <chloe_2> > twt p t = let Node a ts = t in if p a then Node a (fmap (twt p) ts) else Node a []
12:13:49 <lambdabot>  <hint>:1:9: error:
12:13:49 <lambdabot>      parse error on input ‘=’
12:13:49 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
12:14:13 <chloe_2> @let twt p t = let Node a ts = t in if p a then Node a (fmap (twt p) ts) else Node a []
12:14:15 <lambdabot>  Defined.
12:15:12 <chloe_2> > twt (== 2) (Node 3 [Node 1 [ Node 2 [ Node 4 [] ], Node 2 []] 
12:15:15 <lambdabot>  <hint>:1:63: error:
12:15:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:15:28 <chloe_2> > twt (== 2) (Node 3 [Node 1 [ Node 2 [ Node 4 [] ], Node 2 []] )
12:15:31 <lambdabot>  <hint>:1:63: error: parse error on input ‘)’
12:16:29 <chloe_2> > twt (== 2) (Node 3 [Node 1 [ Node 2 [ Node 4 [] ] ], Node 2 [] ])
12:16:32 <lambdabot>  Node {rootLabel = 3, subForest = []}
12:17:10 <chloe_2> (sorry for spamming, I'll try in ghci first)
12:17:36 <chloe_2> > twt (/= 2) (Node 3 [Node 1 [ Node 2 [ Node 4 [] ] ], Node 2 [] ])
12:17:38 <lambdabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
12:18:09 <chloe_2> anyway, maybe this isn't the only way.  I still don't see why order matters
12:18:20 <chloe_2> it's just an fmap
12:21:11 <dsal> ``I asked above "what about takeWhile then?"''
12:21:18 <dsal> That's quite a bit different from fmap.
12:21:59 <Uniaika> hvr: Hi! What are the differences between base-noprelude 4.12 and 4.13? Looks like there hasn't been any commits since 2018 on the github repo
12:25:17 <chloe_2> @dsal wouldn't you call what I defined a takeWhile, where "movement" flows down the tree?
12:25:17 <lambdabot> Maybe you meant: keal eval
12:25:41 <chloe_2> @type twt
12:25:42 <lambdabot> (a -> Bool) -> Tree a -> Tree a
12:27:01 <chloe_2> it's slightly wrong in that it also keeps root node that fail the test, but that's only because I couldn't return Leaf or something
12:27:34 <ski> > (showsTree showsPrec 0 `flip` "") (takeTree_via_unfold 2 positiveBinaryTree)
12:27:37 <lambdabot>  "Node 1 [Node 2 [Node 4 [],Node 5 []],Node 3 [Node 6 [],Node 7 []]]"
12:27:37 <ski> > (showsTree showsPrec 0 `flip` "") (takeTree_via_fold 2 positiveBinaryTree)
12:27:40 <lambdabot>  "Node 1 [Node 2 [Node 4 [],Node 5 []],Node 3 [Node 6 [],Node 7 []]]"
12:28:39 <chloe_2> yes! explain ski?
12:30:26 <ski> (the bodies of `takeTree_via_unfold' and `takeTree_via_fold' are `86' resp `89' characters long .. not so involved)
12:32:09 <ski> perhaps `takeWhile' (on `Tree') could be renamed to `takeUntil' (also inverting the test) ?
12:32:55 <ski> chloe_2 : are you familar with `unfoldTree' and `foldTree' ?
12:33:04 <chloe_2> yes
12:33:22 <ski> can you define `fmap' (on `Tree') in terms of each of them ?
12:33:25 <chloe_2> in fact, I'm only interested in takeWhile to prune an infinite tree from unfold
12:33:36 <ski> (`positiveTree' is an infinite tree, btw)
12:33:56 <ski> <ski> @let positiveBinaryTree = (`fix` 1) (\t n -> Node n [t (2 * n),t (2 * n + 1)])
12:35:04 <ski> btw, you could probably adapt your `unfoldTree' to produce a finite tree (pruning it directly) .. but it might still be easier to follow the code, with these two concerns separated
12:35:50 <chloe_2> ski: how can I get a finite tree out of unfoldTree?
12:35:51 <ski> chloe_2 : anyway, `takeTree_via_unfold' shouldn't be that hard to figure out how to write, if you're familiar with `unfoldTree', no ?
12:36:15 <ski> just make an empty list of new seeds/states, eventually
12:36:30 <chloe_2> oh right
12:37:28 <ski> (there's a difference between finite depth tree, and finite tree. i was thinking about the former. but, presumably, you don't have infinite breadth (/ branching), yes ?)
12:38:25 <ski> (oh, and the `showsTree' stuff is just that i'd prefer not to see the record syntax noise, when showing a tree ..)
12:39:55 <chloe_2> no, I don't have infinite breadth
12:40:25 <chloe_2> I was trying to do something simple: generate  a tree for all possibilities of n coin tosses
12:41:42 <chloe_2> I have this, I don't suppose it could be simpler?
12:41:51 <monochrom> > unfoldTree (\x -> ("hi", if x>0 then [] else [x])) 0
12:41:52 <lambdabot>  Node {rootLabel = "hi", subForest = [Node {rootLabel = "hi", subForest = [No...
12:41:53 <chloe_2> @def tosses n = unfoldTree (\(x,d) -> (x, if d < n then [(x++[H],d+1), (x++[T],d+1)] else [])) ([],0)
12:41:54 <lambdabot>  .L.hs:186:36: error: Data constructor not in scope: H
12:41:54 <lambdabot>      |
12:41:54 <lambdabot>  186 |          (x, if d < n then [(x ++ [H], d + 1), (x ++ [T], d + 1)] else...
12:42:29 <chloe_2> @def data Toss = H | T deriving Show
12:42:31 <lambdabot>  Defined.
12:42:33 <chloe_2> @def tosses n = unfoldTree (\(x,d) -> (x, if d < n then [(x++[H],d+1), (x++[T],d+1)] else [])) ([],0)
12:42:35 <lambdabot>  Defined.
12:42:44 <chloe_2> > tosses 3
12:42:46 <lambdabot>  Node {rootLabel = [], subForest = [Node {rootLabel = [H], subForest = [Node ...
12:43:00 <monochrom> Ha I didn't read the doc.
12:43:34 <monochrom> > unfoldTree (\x -> ("hi", if x>=0 then [] else [x])) 0
12:43:36 <lambdabot>  Node {rootLabel = "hi", subForest = []}
12:43:40 <monochrom> Finite.
12:44:20 <frdg> is the/a core purpose of an Applicative to be able to use the result of a partially applied function that is wrapped in structure?
12:44:46 <monochrom> Probably yes. But I wouldn't trust essay descriptions.
12:45:18 <ski> > (showsTree showsPrec 0 `flip` "") (tosses 3)
12:45:21 <lambdabot>  "Node [] [Node [H] [Node [H,H] [Node [H,H,H] [],Node [H,H,T] []],Node [H,T] ...
12:45:28 <frdg> monochrom: ok, it just kinda hit me that this is what was going on
12:45:30 <ski> > (showsTree showsPrec 0 `flip` "") (tosses 2)
12:45:32 <frdg> thanks
12:45:33 <lambdabot>  "Node [] [Node [H] [Node [H,H] [],Node [H,T] []],Node [T] [Node [T,H] [],Nod...
12:45:45 <ski> > (showsTree showsPrec 0 `flip` "") (tosses 1)
12:45:47 <monochrom> Every essay description between 2 persons is a telephone game of at least 4 players.
12:45:47 <lambdabot>  "Node [] [Node [H] [],Node [T] []]"
12:46:39 <monochrom> your mind -> your wording.  1 hop
12:46:45 <ski> frdg : one way to think of it is "lifting multiple-argument functions"
12:46:48 <monochrom> your wording -> my mind.  2nd hop
12:47:03 <monochrom> err, strike that, the following is better
12:47:10 <monochrom> your wording -> my interpretation.  2nd hop
12:47:13 <frdg> ski: that makes sense
12:47:14 <ski> frdg : converting `A -> B -> C -> D' to `I A -> I B -> I C -> I D', e.g.
12:47:32 <ski> frdg : case zero : converting `A' to `I A'. this is `pure'
12:47:36 <monochrom> my interpretation -> compare with my previous concept.  3rd hop
12:47:43 <monochrom> 3 hops. 4 participants
12:48:22 <monochrom> After 3 hops the outcome has almost nothing to do with what you had in mind.
12:48:24 <frdg> ski: I understand thanks!
12:49:15 <ski> frdg : it so happens that `(<*>)', which converts `I (A -> B)' to `I A -> I B', is a general way to do this, starting with `pure'
12:49:20 <monochrom> This is why mathematicians switched from using natural languages 500 years ago to using formulas 300 years ago.
12:50:16 <ski> monochrom : .. although, they're still not completely done
12:51:14 <aviD> I need a cabal file parser. I can't depend on the cabal library. Any suggestions?
12:51:26 <peutri> copy-paste it
12:51:28 <chloe_2> ski: right you are
12:51:52 <chloe_2> I especially hate when mathematicians introduce notation and definition in one go
12:51:59 <ski> frdg : you start with `A -> B -> C -> D', use `pure' to get `I (A -> B -> C -> D)'. then use `(<*>)' to get `I A -> I (B -> C -> D)'. then use `(<*>)' on the result there, to get `I A -> (I B -> I (C -> D))', one further use of `(<*>)' gets you to `I A -> (I B -> (I C -> I D))'
12:52:48 <ski> frdg : as an optimization, you can combine the `pure' and the first `(<*>)' into a `(<$>)'. so instead of `pure f <*> ia <*> ib <*> ic' you get `f <$> ia <*> ib <*> ic'
12:52:49 <chloe_2> "an integral \int x d \mu is defined as ..."
12:52:53 <frdg> ski: The usage of pure is becoming very clear to me! 
12:53:18 <ski> chloe_2 : it's (often) better than not introducing any proper notation at all ..
12:53:22 <amf> are there any good libraries that do file things with types like: `readFile :: MonadIO m => m (Either IOError ByteString)` ? (rather not roll my own)
12:53:39 <solonarv> amf: I think there is a library like this somewhere
12:53:44 <maerwald> aviD: why?
12:53:45 <chloe_2> ski: and scoping
12:53:59 <solonarv> name fits the pattern 'unexceptional-*' I think
12:54:10 <chloe_2> Instead of clearly defining scope they just go "fix  an x" and then continue in the same paragraph
12:54:27 <ski> frdg : conversely, `(<*>)' is just `($) :: (a -> b) -> a -> b', considered as a two-argument function, lifted into `I (a -> b) -> I a -> I b'
12:54:57 <chloe_2> how is it that none of their proofs contain any type annotations? It's bizarre
12:55:05 <ski> chloe_2 : mm. i think, often, they have only a rather implicit awareness of scope
12:55:24 <chloe_2> ski: right, and that makes it harder for students too
12:55:28 <ski> often, conventions with different letters, are used instead of types
12:55:42 <chloe_2> yes, it's just disgusting
12:55:51 <ski> it's probably Blub
12:55:53 <amf> solonarv: unexceptionalio ! thanks!!
12:56:22 <chloe_2> they need style guides
12:56:24 <ski> they're not aware of it being a problem, not having seen anything better. and being so used to it
12:56:39 <chloe_2> but so many of them play with software design now
12:56:53 <chloe_2> you'd think they'd start to get better at it
12:57:11 <aviD> maerwald: generating hie.yaml from cabal for hie-bios. I don't actually need a full parser, but it would make life a bit easier.
12:57:16 <ski> (and so the pratice propagates to the next generation .. well, for those students who've managed to persevere, that it, and who're now so used to it so they don't see the problem, either)
12:57:23 <chloe_2> but I guess I'm also using ancient math textbooks, so it's partly my fault
12:57:46 <chloe_2> well I hope everyone's taught using Lean/Idris in the future
12:58:14 <chloe_2> ski: we used to have spaghetti code and got better at it, didn't we?
12:58:23 <chloe_2> why are mathematicians slower?
12:58:35 <ski> more tradition baggage, maybe ?
12:58:42 <chloe_2> is it because they're all so smart that they can manage so much implicit?
12:59:03 <monochrom> We got "better" in only the sense that we don't use GOTO any more.
12:59:25 <monochrom> Mathematicians never started with GOTO so they're already as good as we're today at the onset.
12:59:38 <chloe_2> monochrom: I mean, most large open source projects have strict style guidelines
13:00:04 <chloe_2> I'm not sure why they didn't work harder at making their textbooks readable in a similar way
13:00:20 <monochrom> I'm pretty sure if more than 3 mathematicians write a paper together, they too start with agreeing on a style guide.
13:00:38 <chloe_2> monochrom: no, but they still write essays
13:00:40 <chloe_2> !
13:00:44 <chloe_2> as you pointed out, essays suck
13:00:55 <chloe_2> they could be writing code
13:01:02 <monochrom> Yes. So compare solo math papers with solo code.
13:01:04 <chloe_2> great software libraries, basically
13:01:24 <chloe_2> but instead they write it in english and you have to write it in code in your head
13:01:29 <monochrom> compare 100-authors papers with 100-programmers "large projects".
13:01:36 <monochrom> (good luck with that)
13:02:02 <chloe_2> I think what I'm trying to say is: very rarely is math written formally
13:02:23 <monochrom> Do you know of dailywtf?
13:02:57 <chloe_2> had to google, but yeah I've seen it before
13:03:18 <chloe_2> but I'm trying to compare the greatest software projects with the greatest textbooks
13:03:33 <chloe_2> Yet, grab a Rudin or a Munkres
13:03:37 <monochrom> the greatest textbooks are written solo
13:03:44 <chloe_2> true
13:03:59 <chloe_2> how about the greatest solo open source sotware projects?
13:04:15 <chloe_2> they're still formal and readable
13:04:26 <chloe_2> they don't have to do the 4 hops you mentioned earlier
13:04:35 <monochrom> Only because the programming language forces formal.
13:04:43 <monochrom> You think programmers actually like it?
13:04:50 <monochrom> This anal computer thing.
13:04:54 <chloe_2> I do :/
13:05:18 <chloe_2> (and I can't tell if you're joking tbh)
13:05:21 <monochrom> Look for the greatest solo COBOL project.  That begins to be a remotely half-fair comparison.
13:05:50 <[exa]> chloe_2: greatest textbooks only give intuition, indirectly
13:06:02 <monochrom> Or Knuth's source code for TeX. Because it's so "literate programming".
13:06:19 <[exa]> formalisms are for machines
13:07:16 <chloe_2> exa: okay, but type annotations are useful, right? How about formal annotations?
13:07:22 <[exa]> (and language references)
13:07:40 <[exa]> chloe_2: useful for what exactly?
13:08:05 <chloe_2> or in a world of hypertext, you could easily set various levels of formalism, for the reader to see as she wishes
13:08:26 <chloe_2> click on +expand to see this annoying ambiguous sentence in code
13:08:44 <mniip> that's called "go to definition"
13:08:50 <[exa]> why write it ambiguous though
13:09:00 <chloe_2> mniip: yes, hard to do in a math textbook
13:09:03 <[exa]> +1 mniip
13:09:10 <mniip> ah I thought you were talking about code
13:09:15 <ski> mathematicians did adopt `f : A -> B'
13:09:16 <mniip> sorry I have very little context here
13:09:30 <monochrom> No, go to definition is still different from hover definition
13:09:45 <chloe_2> exa: most of the time I struggle with proofs is because some bit is ambiguous
13:09:45 <[exa]> there's no hover when reading a book
13:09:54 <[exa]> eye-over, in a distant future with aR
13:10:05 <chloe_2> ski: no wait, we got that from mathematicians
13:10:13 <ski> of course, chloe_2
13:10:22 <ski> (i didn't mean to imply, otherwise)
13:10:26 <monochrom> and mathematicians got that from category theorists.
13:10:36 <chloe_2> I actually like the \mapsto syntax better than \x ->
13:10:42 <ski> yes, Hurewicz. and, apparently, Hausdorff
13:10:45 <monochrom> and category theorists got that from time travel and programmers. 
13:10:50 <[exa]> chloe_2: most of the time I tell the students they didn't read the definitions before, which turns out true in quite a lot of cases
13:11:39 <chloe_2> exa: I agree, and I would like it to be easier to ctrl-click to a definition in a math textbook
13:12:24 <[exa]> chloe_2: good textbooks have put tremendous effort into avoiding the necessity of this
13:12:25 <ski> chloe_2 : ⌜λ x ↦ ⋯x⋯⌝
13:13:04 <chloe_2> [exa]: I don't know about that
13:13:18 <chloe_2> reducing cognitive load is always a good idea
13:13:32 <[exa]> chloe_2: but the only guide the author has is the text flow, assuming the reader follows without skipping
13:14:08 <chloe_2> [exa]:right, I'm talking hypertext
13:14:28 * ski . o O ( "Letting the symbols do the work" )
13:14:38 <monochrom> Consider self-adventure math textbooks >:)
13:14:49 <chloe_2> monochrom: so like Juptyer notebooks?
13:14:49 <[exa]> ...but the time studying only flows linearly?
13:14:55 <ski> monochrom : "choose your adventure" ?
13:15:02 <monochrom> Yeah!
13:15:08 <chloe_2> I'm pretty sure those are going to be standard in the future
13:15:13 <chloe_2> well, hope maybe
13:15:27 <monochrom> Would you like to hear an Aesop fable.
13:15:35 * ski smiles
13:15:47 <[exa]> monochrom: father monochrom please tell us a fable! :]
13:16:12 <monochrom> A group of mice held a congress of mice to discuss how to evade being hunted down by the cat.
13:16:17 <chloe_2> [exa]: I'm just saying that it can make sense to put theorems first
13:16:22 <monochrom> They all agreed that obviously they needed to tie a bell under the neck of the cat, so everyone could get early warning when the cat approaches.
13:16:27 <monochrom> They also agreed that someone else should do it.
13:17:04 <ski>   The notation of elementary school arithmetic, which nowadays everyone takes for granted, took centuries to develop. There was an intermediate stage called syncopation, using abbreviations for the words for addition, square, root, etc. For example Rafael Bombelli (c. 1560) would write
13:17:12 <ski>       R. c. L. 2 p. di m. 11 L       for our       ∛ {2 + 11i}.
13:17:19 <ski>   Many professional mathematicians to this day use the quantifiers (⌜∀⌝,⌜∃⌝) in a similar fashion,
13:17:27 <ski>       ∃δ > 0 s.t. |f(x) - f(x₀)| < ε if |x - x₀| < δ, for all ε > 0,
13:17:44 <ski>   in spite of the efforts of Gottlob Frege, Giuseppe Peano and Bertrand Russell to reduce mathematics to logic.
13:17:54 <[exa]> chloe_2: theorems are results of brutal amounts of work. You can learn to do that work or use the result. I guess I'm not alone and most people here choose the frst.
13:17:57 <ski>   The logical calculus is easier to execute than any of the techniques of mathematics itself, yet only in 1934 did Gerhard Gentzen set it out in a natural way.
13:18:02 <monochrom> I think more like in defiance, ski.
13:18:08 <ski>   Even now, mathematics students are expected to learn complicated (⌜ε⌝-⌜δ⌝)-proofs in analysis with no help in understanding the logical structure of the arguments. Examiners fully deserve the garbage that they get in return.
13:18:15 <ski>   -- "Practical Foundations of Mathematics",Paul Taylor,1999,<https://www.paultaylor.eu/~pt/prafm/>
13:18:30 <ski> monochrom : i wouldn't be surprised
13:19:21 <ski> choose to redo the work, [exa] ?
13:20:03 <monochrom> Like other humans, mathematicans may easily conflate "mechanize what can be mechanized" with "mechanize it all", and repel the suggestion.
13:20:33 <[exa]> ski: find the reasons for the development, learn the intuition, find how it progressed, reapply
13:21:48 <ski> yes. conflating a machine assisting in keeping track of bookkeeping, in proofs and definitions, (hopefully ..) giving them more time to concentrate on more fun stuff, with a machine replacing them ("doing math")
13:21:49 <[exa]> we maintain a slightly historical calculus course just for the students to be able to see that kind of development
13:22:17 <chloe_2> [exa]: oh that sounds like fun
13:22:25 <chloe_2> course notes online?
13:23:18 <[exa]> it's a standard differential calculus, going to summation, integration, taylor and other series, and finishing in complex analysis
13:23:59 <ski> notation ought to offload cognitive work. i don't want to constantly consult the current aims, what we're trying to capture and do, in order to be able to understand how to interpret the formulae (as opposed to what we'd like to do with them)
13:24:13 <[exa]> you can start with Bolzano-Weierstrass theorem on the wiki (which gives quite a bit of intuition about infinite stuff), which kindof continues naturally
13:26:46 <ski> [exa] : it's good to understand the reasons (and see impetus for development), but it doesn't necessarily have to be done in a too historically accurate fashion
13:27:47 <[exa]> certainly not
13:27:57 <[exa]> but I found the calculus part really illustrative
13:28:27 <[exa]> and accessible, most students can do a bit of 15th century math before reaching uni
13:28:56 <ski> (but i don't mind adding in a bit more history. often in programming teaching, there seems to be little reference to who invented/discovered what, and why)
13:29:10 <[exa]> unlike e.g. the logic; motivations for the whole russel->gödel development are tricky at best
13:30:38 <[exa]> does pointing out, say, "who did this historically important abstraction" motivate the students to try the same kind of development?
13:37:34 <ski> [exa] : hm, pointing out, as a question ? or as a comment doing an explanation/lecture ?
13:39:23 <amf> in an async thread is there a way to know when `cancel` was called so you can do action? i want to make sure a channel is fully read before the thread terminates
13:39:25 <chloe_2> I'm so on board with what ski is saying rn
13:39:34 <chloe_2> I'm sure you've heard that Whitehead quote, ski?
13:39:48 <chloe_2> "Civilization advances..."
13:40:14 <ski> hm, i don't recall
13:40:21 <chloe_2> "It is a profoundly erroneous truism, repeated by all copy-books and by eminent people when they are making speeches, that we should cultivate the habit of thinking of what we are doing. The precise opposite is the case. Civilization advances by extending the number of important operations which we can perform without thinking about them.
13:40:22 <chloe_2> Operations of thought are like cavalry charges in a battle — they are strictly limited in number, they require fresh horses, and must only be made at decisive moments."
13:40:30 <chloe_2> https://en.wikiquote.org/wiki/Alfred_North_Whitehead
13:41:07 <chloe_2> the one before that mirrors what you were saying earlier:
13:41:09 <chloe_2> "By relieving the brain of all unnecessary work, a good notation sets it free to concentrate on more advanced problems, and in effect increases the mental power of the race."
13:41:24 <ski> hm, hadn't heard those ones before. ty
13:44:17 <[exa]> ski: commenting, basically just giving the credit to whoever invented it
13:44:31 <[exa]> more precisely s/invented/canonicalized/
13:45:06 <chloe_2> ski: check pm
13:47:13 <gentauro> why does Haskell need `let … in …` syntax for local let-binding but not for global (`module` level)?
13:48:53 <tdammers> frankly, find it weird that Haskell has a concept of "top-level" at all, and that modules are somehow these opaque thing that kind of lives outside of the language proper
13:49:13 <maralorn> Is there some trick to import type operators? I am getting for this line "import           Options.Generic                ( (<?>) )" the errror "Module ‘Options.Generic’ does not export ‘(<?>)’"
13:49:15 * hackage clash-prelude 1.2.1 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.2.1 (QBayLogic)
13:50:15 * hackage clash-ghc 1.2.1, clash-lib 1.2.1 (QBayLogic): https://qbin.io/flash-rugby-ccvf
13:50:37 <justsomeguy> It would be cool if modules were first-class, and you could store them in data structures, transform them with functions, assign them to variables, write them as literals, etc.
13:50:46 <solonarv> maralorn: you can explicitly refer to the type by saying 'import Options.Generic ( type (<?>) )'
13:50:54 <solonarv> you might need -XExplicitNamespaces
13:52:52 <gentauro> tdammers: if I compare to `Ocaml`, both top (`module` level) as well as local binding need `let-in` (at least it consistent). But it should be possible to have no `let-in` syntax in Haskell right? (if it works on module level, it should work in local levl as well)
13:54:11 <chloe_2> what does let-in look like for modules?
13:54:24 <gentauro> justsomeguy: like this? https://people.mpi-sws.org/~rossberg/1ml/
13:57:06 <justsomeguy> gentauro: Very cool, I'm going to have to try this out.
13:57:36 <Tuplanolla> If you think ML has it bad, you should try Coq's module system.
13:58:17 <gentauro> justsomeguy: oh, it's the guy from ICFP and WASM (pretty funny and short talk). I looks like he mostly do `wasm` now :( https://github.com/rossberg
14:01:15 * hackage opentelemetry 0.3.0 -   https://hackage.haskell.org/package/opentelemetry-0.3.0 (DmitryIvanov)
14:02:15 * hackage opentelemetry-wai 0.3.0, opentelemetry-lightstep 0.3.0, opentelemetry-extra 0.3.0 (DmitryIvanov)
14:16:14 <ski> gentauro : tbh, i often wish Haskell had SML's `local'-`in'-`end' construct for declarations
14:19:08 <maralorn> solonarv: Thank you. That helped!
14:19:25 <justsomeguy> So, silly question. What does the ↦ symbol mean? Is it just a function arrow in math notation?
14:19:50 <ski> what do you mean by "function arrow" ?
14:20:41 <maralorn> justsomeguy: The latex command for it is \mapsto.
14:20:47 <monochrom> It is equivalent to our lambda.
14:21:08 <monochrom> We write "\x -> x+1", they write "x ↦ x+1"
14:21:20 <justsomeguy> So, for example, would {a,b} ↦ {m,n} mean "a function that maps a to m, and b to n?"
14:21:31 <maralorn> justsomeguy: But it is typecally used on the value level not on the typelevel
14:22:10 <monochrom> No, that one maps {a,b} to {m,n}.
14:22:22 <justsomeguy> Ah.
14:22:58 <maralorn> justsomeguy: No. It means a set with the two elements a and b gets mapped to a set with the elements m and n. (And depending on context you will have to proof that this is actually a function.)
14:23:48 <justsomeguy> Thanks, that helps. Seems like FP has been teaching me a bunch of basic math recently. Gonna have to learn the greek alphabet and some latex soon.
14:24:28 <ski> you probably shouldn't write ⌜f : A ↦ B⌝, if that's what you're thinking about
14:24:54 * ski still doesn't know the whole greek alphabet
14:25:02 <ski> (has learned on a "need to know" basis)
14:26:08 <justsomeguy> I'm assuming the ":" indicates a type? I haven't seen that notation before. I guess it wouldn't work since the maplet symbol is for term-level only.
14:27:42 <ski> basically, yes
14:28:03 <ski> although, mathematicians only tend to use it for functions
14:43:30 <mniip> justache, very important distinction between -> and |->
14:43:48 <mniip> -> indicates between what sets a mapping occurs
14:43:54 <mniip> |-> indicates which point maps to which
14:50:15 * hackage gopro-plus 0.3.1.0 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.3.1.0 (dustin)
14:53:11 <chloe_2> if hackage has a newer version than stackage, do I have to add my package in extra-deps?
14:53:29 <maralorn> justsomeguy: Basically everyone other than Haskellers uses ":" for type.^^
14:53:29 <chloe_2> I'm looking at https://www.stackage.org/package/diagrams-cairo
14:53:52 <chloe_2> and I just want to be able to run whatever version without messing with extra-deps
14:54:04 <maralorn> There was this funny article about how Hackage would be 200MB (???) smaller if we would swap (:) and (::) in Haskell.
14:54:06 <chloe_2> is there a way to do that?
14:54:43 <maralorn> Probably more like 200KB?
14:54:44 <gentauro> ski: I mostly use `where` to hide away details. Once you get used to it, the `let … in …` becomes to verbose 
14:54:51 <solonarv> chloe_2: that is pretty much the opposite of the usecase stacl os designed for
14:54:56 <maralorn> Don‘t remember anymore.
14:54:59 <solonarv> s/stacl os/stack is/
14:55:22 <solonarv> if you find yourself annoyed by this frequently, I recommend switching to cabal.
14:56:16 <ski> gentauro : not always an option. and i'd still like `local'-`in'-`end'
14:57:11 <d2ci8xc5> Is there any easy way to do a range in a array and include other elements? eg ['a'..'c', 'd'] would be ['a','b','c','d']
14:57:34 <gentauro> ski: sure
14:57:35 <ski> d2ci8xc5 : use `++' ?
14:57:41 <d2ci8xc5> without doing ['a', 'b', 'c'] ++ 'd'
14:57:52 <ski> (also, it's a ((single-)linked) list, not an array)
14:58:25 <ski> > foldr (:) ['d'] ['a' .. 'c']
14:58:27 <lambdabot>  "abcd"
14:58:32 <ja> gentauro: but if the definitions do not have obvious names, let...in is easier to read
14:59:10 <ski> > concat [['a' .. 'c'],['d']]
14:59:12 <lambdabot>  "abcd"
14:59:18 <ski> d2ci8xc5 : that's two ways ..
14:59:18 <ja> gentauro: surely you seen people with 100 line functions with a where down below, indented 2 spaces, using parameteres from up above
14:59:35 <chloe_2> solonarv: somehow I can't even specify the version that's on stackage, it still complains "the stack configuration has no specified version "
15:00:27 <chloe_2> when I do diagrams-cairo==1.4.1 (which is on stackage), shouldn't it work?
15:00:34 <ski> (d2ci8xc5 : if you want better answers, maybe you could try giving more details about what you're doing and what you'd like to do or not do)
15:00:46 <chloe_2> ...inside projname.cabal
15:02:47 * ski idly wonders why d2ci8xc5 would like to avoid using `++'
15:05:14 <solonarv> chloe_2: no, stack effectively ignores version bounds specified in pkgname.cabal
15:06:45 <chloe_2> solonarv: huh? so how do I specify it?
15:07:07 <maerwald> Can't you tell stack to use the cabal solver?
15:07:18 <MarcelineVQ> solonarv: are you sure about that? people usually ignore package bounds when using stack but that doesn't have to mean stack ignores package bounds
15:07:21 <MarcelineVQ> chloe_2: https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
15:08:12 <solonarv> stack just uses whichever version is in the resolver you specify. If that matches the bounds in plgname.cabal, good. If not, you just get an error.
15:08:26 <solonarv> maerwald: not anymore
15:08:57 <solonarv> maerwald: stack did this by parsing the output from some cabal command or another, but at some point cabal changed that command's output format
15:08:57 <MarcelineVQ> oh, well, getting an error isn't ignoring them
15:09:12 <maerwald> solonarv: ah, the API war
15:09:21 <solonarv> so stack could no longer parse the output, and eventually stack jsut removed the feature
15:11:16 <solonarv> MarcelineVQ: that is why I said *effectively* ignores
15:11:34 <solonarv> if you put a ==x.y.z constraint in pkgname.cabal that will never cause stack to pick that version
15:12:21 <maerwald> so extra-deps it is, or switch to cabal
15:25:32 <solonarv> yup
15:25:46 <solonarv> even stack's solver thing - when it worked - just wrote out extra-deps for you.
15:30:37 <d2ci8xc5> I don't want to avoid it i was just curious
15:31:13 <oats> d2ci8xc5: I would argue that it's probably the way to solve your problem :)
15:31:42 <oats> Appending will requiring traversing the first regardless
15:38:11 <monochrom> If worried about long++short inefficiency, you may try ((long ++) . (short ++)) ""
16:18:20 <oats>  b12
16:18:26 <oats> oops, ignore
16:56:15 <dmwit> oats: you hit my battleship!
16:56:31 <oats> haha
17:36:45 * hackage greskell 1.0.1.0 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.0.1.0 (debugito)
18:06:36 <koz_> Which GHC is base 4.12?
18:07:03 <mniip> 8.6 iirc
18:07:30 <mniip> the way to find out is https://hackage.haskell.org/package/base/changelog
18:07:53 <koz_> mniip: So it is, thanks!
18:19:59 <jchia> cabal question: If ghc-options in .cabal is deprecated since 2.0, what should I use now instead?
18:20:58 <jchia> scratch that. i misread the doc
18:35:23 <koz_> jchia: Common problem.
18:43:25 <jackdk> mniip: https://wiki.haskell.org/Base_package has a good table too
18:44:31 <koz_> jackdk: Even better, thanks!
18:49:53 <koz_> There's some build-depends bounds indicator involving ^ in Cabal files - what does this mean and should I be using it?
18:53:21 <jackdk> koz_: https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-build-depends search "starting with cabal 2.0"
18:53:34 <koz_> jackdk: Thanks!
18:53:39 <jackdk> (there's not paragraph-level anchors in that doc)
19:01:31 <koz_> Also, this is more of a design question that anything: I wanna write some tests for (a new and much improved version of) my streamly-fsnotify library. It necessarily involves IO (as it watches folders for changes). How would I test this?
19:04:28 <sm[m]> chloe_2: got it figured out ?
19:09:29 <monochrom> koz_: It looks like it will be ad-hoc test code that creates/deletes files and see if you receive expected notifications.
19:09:48 <koz_> monochrom: I guess that's the way.
19:14:08 <jackdk> you could go down a massive rabbit hole of effect systems and state machine testing, to generate sequences of create/delete/modify
19:19:44 * hackage di-polysemy 0.1.1.0 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.1.1.0 (nitros12)
19:40:57 <jchia> Does cabal-install just ignore items that it doesn't understand in the .cabal file? I put a 'split-objs1' in a common stanza and it didn't complain
19:41:17 <jchia> split-obj1 is an intentional mispelling
19:59:28 <jchia> cabal question. Where should I put "executable-stripping: True" in my .cabal file? I put it at the top-level and it has no effect. My executable still has symbols.
19:59:53 <Axman6> maybe in the executable section?
20:02:41 <jchia> I think I tried that already and it didn't work. I'm trying again just in case. In any case, if they don't understand or recognize something, why don't they complain? (executable-stripping in this case) If they don't complain, I can't tell whether I made a mistake.
20:02:45 <jchia> this is so unlike GHC itself.
20:07:32 <jchia> Axman6: That didn't work. cabal build still gives an unstripped binary.
20:44:54 <akasha> so I noticed there's a haskell spec for 1998 and then again in 2010. is there another version coming soon?
20:45:03 <akasha> also, on that note, are there alternatives to ghc?
20:45:26 <akasha> > Language revisions are expected to be produced once per year, starting with Haskell 2010
20:45:29 <lambdabot>  <hint>:1:61: error: parse error on input ‘,’
20:45:30 <akasha> never mind the first question
21:07:50 <solonarv> akasha: answer to your first question: there has been some talk of a followup, perhaps "Haskell 2020" or "Haskell Prime", but nothing has really materialized
21:08:36 <solonarv> there aren't really any widely-used compilers besides GHC. There are a few forks of GHC or projects that build on top of it (GHCJS, Eta (compiles to JVM), WebGHC/Asterius (WebASM))
21:09:17 <solonarv> the university of Utrecht still maintains a haskell compiler, but I don't think anybody else uses it and I don't know what features it has
21:10:07 <solonarv> some financial institution or another - I don't recall its name - has a compiler for a strict dialect of Haskell, but it's not public
21:10:37 <solonarv> everything else (Hugs, JHC, Frege) is now unmaintained
21:17:34 <jackdk> solonarv: is that standard chartered?
21:17:57 <solonarv> it might be, the name rings a bell
21:18:33 <jackdk> or possibly mcgraw hill
21:46:18 <jchia> Is there a cabal command to determine the path of a built executable or copy it to some directory?
21:53:42 <ja> jchia: you can specify the directory for 'installation'
21:54:46 <ja> jchia: try 'cabal help install'. there is even an option to have it install a symlink. so you could install a symlink to a temp directory and read the path ;)
21:54:53 <jchia> ja: I find that when I do it, it tries to build again even though I have already built everything, and this time the build fails because I have an embedFile in TH that fails (it didn't fail when I just used cabal build)
21:55:25 <ja> hmm i had a problem like that
21:55:35 <jchia> i just wanted to install one particular executable and it went to do a bunch of big stuff
21:55:48 <ja> and i was wondering whether my cabal file was somehow not written correctly... but i can't say if that was the reason, i forgot how i avoided the problem
21:55:53 <jchia> like putting tar.gz into dist-newstyle/sdist
21:56:34 <ja> jchia: if it can't build from sdist, something is wrong
21:56:42 <ja> you could make it put the files in the sdist that it needs
21:57:08 <c_wraith> are you using the --only flag with install?
21:57:09 <jchia> I have an embedFile in TH that uses some file from outside the haskell part of the code base
21:57:47 <jchia> c_wraith: I add --only but the problems remain
21:58:35 <jchia> but what is '--only'? I don't see it in the help
22:02:55 <c_wraith> Hmm.  possibly defunct, possibly poor memory.  I thought it was the flag to install without building
22:03:43 <jchia> c_wraith: there's --only-dependencies
22:03:49 <jchia> but that's probably not what you meant
22:03:56 <c_wraith> that's different, indeed
22:05:51 <guest72> Hello everyone! Is it right to think that a typeclass is a set of types whose elements are types?
22:12:17 <jackdk> I think "a set whose elements are types" is a reasonably intuition for single param type classes
22:12:23 <jchia> guest72: I would think so.
22:12:24 <jackdk> s/reasonably/reasonable/
22:12:28 <Axman6> I feel like soething is redundant in that sentense
22:12:49 <jchia> "whose elements are types"
22:13:09 <jchia> but it's not just some arbitrary set. they have certain things in common
22:17:45 <guest72> [haskell]instance Num Int[/haskell] <=> [latex]Int \in Num[\latex]?
22:18:33 <jchia> yes
22:18:42 <guest72> Thanks
22:19:30 <jchia> In order to be in Num, certain conditions need to satisfied. E.g. (+) :: a -> a -> a needs to be defined for the type.
23:18:44 * hackage base64-bytestring 1.1.0.0 - Fast base64 encoding and decoding for ByteStrings  https://hackage.haskell.org/package/base64-bytestring-1.1.0.0 (topos)
23:24:37 <topos> i just invalidated so many caches lmao
23:25:01 <topos> get rekt
23:25:11 <ben> i just named so many things!!
23:25:24 <topos> ayyy nice
23:26:20 <phadej> topos: with major version not so much
23:27:17 <topos> damn
23:27:37 <topos> what's the point in publishing if you can't invalidate everyone's caches
23:28:52 <phadej> " annoy stackage users, as they cannot use the latest and shinest because some stupid people use upper bounds (and thus the caches aren't invalidated) " <- sarcastick
23:29:48 <topos> oo that's a good one
23:30:07 <phadej> or "never break anything" people (e.g. rich hickey, though he isn't using Haskell)
23:30:10 <topos> i suppose i can derive joy from that
23:31:32 <slack1256> Ok, is there a opengl introduction for haskellers?
23:31:55 <phadej> slack1256: trick Edward Kmett to show it to you.
23:32:32 <phadej> it probably won't be gentle :)
23:32:32 <slack1256> God damn he already has like 3 of my category theory books.
23:42:35 <mniip> topos, what'd you do
23:45:03 <topos> brought base64-bytestring into this century 
23:56:42 <jackdk> topos: you should weigh in on that typesafe encoding library that hit /r/haskell today
23:59:19 <Axman6> @hoogle (Traversable t, Monoid m) => (a -> f m) -> t a -> f m
23:59:20 <lambdabot> Universum.Monad.Container concatMapM :: (Applicative f, Monoid m, Container (l m), Element (l m) ~ m, Traversable l) => (a -> f m) -> l a -> f m
23:59:21 <lambdabot> RIO.Prelude foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w
23:59:21 <lambdabot> Stack.Prelude foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w
23:59:35 <Axman6> :t foldMap
23:59:37 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
