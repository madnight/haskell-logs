00:00:02 <iqubic> turlando: There isn't a specific channel, but be feel free to ask your questions here.
00:06:29 <turlando> Thanks for your reply
00:08:37 <turlando> I'm having an hard time trying to understand what's the purpose of the lexeme function. I'm following the official tutorial, more precisely this section: https://markkarpov.com/tutorial/megaparsec.html#lexing An integer it's been defined as lexeme decimal, I've written a bunch of text involving the presence of whitespace in different places but they're all passing with or without this lexeme function.
00:09:31 <turlando> Apparently it's making no difference at all. There's something I'm missing but I can't really grasp it
00:27:04 <arahael> turlando: I think it's a technical term - language consists of lexemes as I understand it.
00:27:18 <arahael> turlando: Ie, it's the smallest "component" in your language.
00:30:47 <turlando> Yeah I had this feeling reading the definition for it. As far as I understand I don't need to use it for built-in lexes, right? They already consume trailing whitespace? I was trying to get the point of the tutorial
00:31:29 <arahael> turlando: It's very convenient to define your grammer in terms of their components, rather than deal with the bytes directly.
00:32:01 <turlando> That's what I was trying to do to avoid to reinvent the wheel :)
00:51:37 <monadplus> I have a doubt about how to approach profiling
00:52:30 <monadplus> What kind of input data should I use and how many runs of the profiled code should it is recommended
01:06:19 <kush87> hello all, this is kushagra here .. call me kush.
01:08:55 <kush87> wanted to know some details about lists in haskell, if any could help me with that. I a noob, just started in haskell.
01:16:42 <monadplus> Lists are linked lists from the pointer machine model so take average cost into account when using them (as any other DS). They are subject to fusion optimization. 
01:18:09 <monadplus> Mosts of operations have linear so take this into account.
01:18:51 <monadplus> the definition is the following `data [] a = [] | a : [a]`
01:20:55 <ski> hello kush87, what would you like to know about lists ?
01:24:23 <kush87> hey ski
01:24:54 <kush87> so i was wondering, what is the strategy generally to convert a list to list of lists
01:25:13 <ski> depends on what kind of conversion you'd like to make
01:25:24 <ski> do you want to keep all elements ?
01:25:46 <kush87> for example, if we have a string "HyperText Markup" and i want it as ["Hyper", "Text", "Markup"]
01:26:16 <kush87> and i wanted to avoid using any groupBy or such, want to do it from first priniciples
01:26:25 <ski> hm, so you want to split it up, in some way ?
01:26:32 <kush87> yes
01:26:43 <kush87> String -> [String]
01:26:48 <ski> seems you want to split at whitespace, and also some other boundaries
01:27:00 <kush87> yeah so boundaries could be anything
01:27:10 <ski> when going from lowercase to uppercase ?
01:27:28 <ski> how about `"HyperText  Markup"' ?
01:27:58 <ski> should you get `["Hyper","Text","Markup"]' still, or maybe `["Hyper","Text","","Markup"]' ?
01:28:18 <kush87> ["Hyper","Text","Markup"]
01:28:20 <kush87> this one
01:28:41 <ski> hm, so contiguous chunks of at least one white space counts as a single boundary
01:29:27 <kush87> but i am making a more general point, like all i have seen  is people using span and break and stuff, but i have not been able to craft any solution where i am able to make a string a list of strings
01:29:45 <kush87> you can use space as an example
01:29:45 <ski> i guess one way would be to first split it into chunks, splitting at the whitespace. then split each of those, on lower->upper case transitions
01:30:32 <kush87> i understand that, split can be used, there are functions. what i am looking for is how i can create such a function from ground up
01:31:16 <kush87> so that i get the visceral feel of splitting a list
01:31:25 <ski> your two splitting conditions are quite disparate. one is about recognizing contiguous chunks of elements as boundaries, to be removed. the other is about noticing a transition from one element to the next, and introducing a split there (not dropping any elements)
01:31:38 <kush87> yes
01:31:53 <kush87> for simplicty .. lets just use space as an example
01:32:02 <kush87> that split a string on space
01:32:11 <kush87> how would one approach
01:32:41 <ski> initial and final spaces should be ignored ?
01:32:55 <kush87> yeah
01:33:01 <biiipon> Hi, can someone tell me how to improve this code https://gist.github.com/8afc9c5567430a9e92454b800ec7ed4d (about graph theory). I'm aware that my lines are too long. I'm still new to Haskell.
01:36:59 <ski> > unfoldr (\s -> guard (not (null s)) >> Just (second (dropWhile isSpace) (break isSpace s))) "HyperText Markup"
01:37:01 <lambdabot>  ["HyperText","Markup"]
01:37:07 <ski> > unfoldr (\s -> guard (not (null s)) >> Just (second (dropWhile isSpace) (break isSpace s))) "HyperText   Markup"
01:37:10 <lambdabot>  ["HyperText","Markup"]
01:37:15 <ski> > unfoldr (\s -> guard (not (null s)) >> Just (second (dropWhile isSpace) (break isSpace s))) "  HyperText Markup  "
01:37:17 <lambdabot>  ["","HyperText","Markup"]
01:37:48 <ski> that's one way to split on the spaces
01:38:08 <ski> you'd also want to drop initial spaces here, as the last example shows
01:39:19 <kush87> That's impressive, but that's not what i am looking for. This is a solution. I am looking for a way to approach these things. For example, i tried writing a tail recursion 
01:39:20 <ddk> Hello, I have 2 bytes as a ByteString and that contain a unsignedShort how do I convert it to equivalent string representation, something like `"20213"` so that I can do pattern match on case exps?
01:39:24 <ski> btw, i'm not quite sure what you're after, with "visceral feel of splitting a list"
01:39:43 <kush87> hahahhaa
01:40:55 <kush87> ok, so lets say you have a string "First Last" and you want it as ["First", "Last"], how would you do it in a tail recursive way without using any higher order functions
01:41:33 <ski> btw, i think tail-recursion is not what you'd want, here
01:43:09 <kush87> ok. could you just walk me through, how would you do it without using higher order functions
01:44:01 <ski> give you a solution, then discuss it ? or try to reason how one would arrive at a solution ?
01:44:02 <ddk> ?
01:44:24 <kush87> try to reason how one would arrive at a solution
01:44:33 <kush87> want to come at my own solutions
01:44:36 <ski> ddk : not sure why you want a `String', btw ?
01:45:34 <ddk> ski: I have a mapping of (String, doSomething) on which I have to pattern match that's why I need string representation 
01:45:35 <ski> kush87 : well, afaics, you're in either of two modes, as you're stepping through the input list. either you're (a) dropping spaces; or you're (b) outputting non-spaces
01:45:54 <kush87> ok
01:46:31 <kush87> but what is that step where i move from a single list to list of lists
01:46:32 <ski> kush87 : the reason for this is that you only want to start generating a new output list, when you go (b)->(a)->(b). not when you got (a)->(a)->(a)->(a)->...
01:46:55 <kush87> yes
01:47:59 <ddk> ski: two bytes represent opcode which is a number, and I have a mapping of a number -> action so I need to do pattern match, can you please help ?
01:49:45 <ski> if the two bytes are `lo' and `hi' (maybe in other order), then you should be able to compute `256*hi + lo', and then `show' that, to get your `String', ddk ?
01:50:55 <ddk> what is meant by little endian is it lo-hi or hi-lo ?
01:50:58 <ski> if you want to do this in a pattern-match, you could perhaps use a view pattern, or a pattern guard
01:51:12 <ski> should be the former
01:51:30 <ddk> view pattern how here ?
01:51:53 <ddk> I have 1000's of pattern to match, i.e. 1000s of opcodes
01:53:36 <ski> well, perhaps you can first call a function which converts your `ByteString' into the `String' you want, then match on that ?
01:54:02 <ddk> yeah 
01:54:04 <ski> kush87 : anyway, we start in (a), since there might be initial spaces which we want to remove
01:54:29 <ski> kush87 : (a) and (b) would here be modelled as two mutually recursive functions
01:54:39 <ddk> ski: directly calling unpack returns not readable strings 
01:55:20 <ski> yea, you need to access the two bytes, in some way. i forget how to do that, atm. there should be a way (maybe indirect ?)
01:56:45 <ski> kush87 : for (a) if the input is empty, we're done producing output lists. otherwise we check the current element. if it's white, we skip it, and continue with (a). otherwise we pass over to phase (b) (call the other recursive function)
01:57:08 <lleksah> How do I crosscompile Haskell? I'd like to compile on OS X and target linux64. Is this possible? How are people doing cross platform compilation? Is there a free service that will do it for me?
01:57:26 <kush87> i get it ski, thanks. Let me see if i can make it into a function.
01:57:28 <kush87> Thanks
01:58:45 <ski> kush87 : for (b), it could become empty here as well (if we've seen some non-white before, and reach the end). otherwise, we need to, someone keep adding to current output list, if it's non-white, else go back to (a)
01:58:58 <ski> kush87 : the adding to current output list sounds like it could be interesting to think more about, here
01:59:01 <ddk> ski: Thanks a lot
01:59:48 <ski> i think i can see how to do it, in a simple way. but that requires "reinterpreting" all the time, which sounds inefficient. it'd be interesting how to avoid that, preferably in some nice and simple way
02:00:12 <ski> but, start with the most simple and obvious way which is correct, first. can think about improvements after
02:00:20 <ski> np, ddk
02:01:27 <ski> kush87 : btw, i guess one of the (two mutually recursive) functions would be tail-recursive, but not the other ?
02:01:42 <ski> well, perhaps depending on how you set things up
02:02:08 <ski> (i was just thinking about the most obvious way to do it, without attempting to much with accumulators, and reversing)
02:13:36 <seanparsons> maerwald: Not profiling the application, profiling GHC.
02:46:42 <merijn> Is there a number pretty printer in base? (i.e. thousands markers, etc.)
02:53:41 <merijn> hmm, no apparently, well that's an embarassment
03:19:56 <jophish> cjay-: are you the cjay- of https://github.com/cjay/vulkyrie?
03:21:07 <maerwald> merijn: ghcjs and use some js library? :PP
03:28:49 <merijn> maerwald: Sure, lemme invest several months getting ghcjs working and porting all my C code (including all of SQLite!) to JS!
03:29:18 <maerwald> dmj` says it's easy with nix, so just spend several months learning nix
03:29:34 <merijn> Nix has a reality distortion field
03:29:53 <merijn> It causes people who use it to be blind to the, frankly, *insane* initial cost
03:30:24 <jophish> Perhaps nix users consider it worth it?
03:30:44 <merijn> jophish: Frankly I don't have an opinion on that
03:30:49 <jophish> (I love Nix BTW)
03:30:50 <maerwald> because they paid the initial cost already
03:30:52 <merijn> jophish: Use whatever works for you
03:30:54 <maerwald> and then forget that there is a cost
03:30:57 <jophish> merijn++
03:31:15 <merijn> But I get *super* annoyed by everyone who goes "oh, just use Nix" to every single build problem as if there is no cost or overhead to that
03:31:21 <int-e> . o O ( Stockholm syndrome )
03:31:24 <maerwald> Balanced technical decisions are not just about the power of tools
03:31:34 <maerwald> I think I barely told anyone "use haskell" in real life
03:31:35 <jophish> yeah, that's very understandable 
03:31:41 <merijn> I mean, I even *like* Nix conceptually
03:31:55 <merijn> I just think the Nix *reality* sucks donkey balls
03:32:27 <jophish> yeah, but there doesn't seem to be anything else close to it :/
03:32:37 <maerwald> merijn: I only like the goal, but none of the rest, not even the concept and even less the implementation
03:32:42 <merijn> "Nix is great, deterministic purely functional dependencies!" 'oh wow, that is great!'
03:32:45 <int-e> Nix - the Gentoo experience for Haskell?
03:32:58 <maerwald> int-e: Gentoo has packaging standards and quality.
03:33:00 <maerwald> Nix not
03:33:02 <merijn> "You write these Nix expressions to describe your dependencies..." 'go on...'
03:33:06 <int-e> maerwald: oh ouch
03:33:16 <[exa]> >  Gentoo has packaging standards and quality.
03:33:19 <lambdabot>  <hint>:1:44: error:
03:33:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:33:23 <[exa]> for a certain definition of "standards"
03:33:24 <jophish> maerwald: that seems a little unfair, people do review the PRs to nixpkgs
03:33:35 <merijn> "In an untyped ill-documented custom language that only a handful of people know and understand with poor error reporting!" 'oh...'
03:33:35 <maerwald> [exa]: yes, I worked on it for 4 years, but then I gave up ;)
03:34:02 <maerwald> but if you compare the packaging policies in general, that's not even on the same level
03:34:03 <[exa]> I was on gentoo as well, even co-maintain a few packages still
03:34:13 <jophish> the lack of types in Nix do make discovery very difficult
03:35:01 <jophish> maerwald: tbf I don't have much experience with other distros in this respect. I think that nixos is probably the way it is because of lack of developer time/money 
03:35:06 <jophish> not that that excuses it
03:35:06 <merijn> https://i.imgflip.com/3w42yn.jpg
03:35:19 <jophish> hahahaha
03:35:24 <maerwald> jophish: no. I was never paid to work on gentoo and do hundreds of hours of ebuild reviews for free.
03:35:24 <Uniaika> oof that's a hot take
03:35:35 <merijn> Uniaika: I only do the spiciest takes!
03:35:37 <int-e> merijn: hmm, who's that?
03:35:52 <merijn> int-e: No clue, I'm an uncultured swine copying memes
03:35:58 <maerwald> jophish: it is lack of experience and lack of attitude
03:36:10 <int-e> . o O ( sandboxes forever )
03:36:20 <Uniaika> “I'll take a community-splitting controversial opinion for $500, Alex”
03:36:31 <merijn> int-e: v2-build are superior to sandboxes in every way :p
03:36:37 <maerwald> sandboxes will be removed soon
03:36:38 <int-e> merijn: Not.
03:36:50 <merijn> int-e: Name one thing sandboxes do better?
03:36:55 <int-e> merijn: I hate the lack of cleanup story.
03:37:03 <[exa]> merijn: you can nuke them reliably
03:37:04 <int-e> project-local cleanup
03:37:05 <jophish> https://i.imgflip.com/3w434l.jpg
03:37:33 <merijn> int-e: There's some prototypes, the real problem is no one has clearly defined the UX yet
03:37:34 <maerwald> int-e: you can have a store per-project
03:37:37 <int-e> maerwald: I'll work around it with a project-local store, I suppose.
03:37:41 <int-e> maerwald: I knew that.
03:37:41 <maerwald> ...
03:38:01 <int-e> But it's a nuisance compared to the worry-free sandbox setup.
03:38:01 <merijn> [exa]: You can nuke the store reliably too :p
03:38:14 <[exa]> merijn: "without breaking the rest of the system"
03:38:22 <maerwald> https://github.com/haskell/cabal/issues/6445
03:38:23 <merijn> int-e: I GC by just nuking the store twice a year :p
03:38:29 <merijn> [exa]: It doesn't break anything, though
03:38:29 <jophish> maerwald: well, fwiw nix has generally been very good to me for installing packages. It builds and runs the tests and I'm not sure what else to reasonably ask for
03:38:36 <merijn> [exa]: Just increase recompile time for projects
03:38:40 <maerwald> jophish: consistent configuration for one
03:38:56 <maerwald> usable documentation
03:39:02 <merijn> [exa]: If you nuke the store the required bits will just get rebuild the next cabal build
03:39:09 <merijn> [exa]: That's the beauty!
03:39:10 <maerwald> basic project synchronisation
03:39:14 <[exa]> ok I underestimated that
03:39:35 <[exa]> let's try
03:39:53 <jophish> consistent configuration is something that I think nixos does better than any other os, the whole system (and most things in my .config dir) are configured in the same language
03:40:04 <int-e> maerwald: https://github.com/haskell/cabal/issues/6141 is one of the things that just doesn't happen with sandboxes.
03:40:07 <jophish> there's no messing around learning what weird syntax /etx/ssh/config uses or whatever
03:40:15 <[exa]> merijn: btw I seriously believe the "clearly defined UX" for nuking should be "rm -rf", based on the usual circumstances that lead to the need
03:40:18 <merijn> [exa]: And if you use freeze files/fixed ahckage index you can even guarantee it will rebuild the exact same version as before
03:40:36 <jophish> (but I might have misunderstood what you meant by consistent config)
03:40:49 <merijn> [exa]: Sure, but it would be nice to have a "GC" command that installs old versions not currently used in any project
03:40:49 <jophish> the documentation for nix isn't super, there's no denying that
03:40:58 <merijn> [exa]: The problem is how to define/detect "roots"
03:41:02 <jophish> not sure what you mean by project sync
03:41:37 <merijn> [exa]: There was a GSOC prototype that you could pass a bunch of cabal.project directories and it would nuke any package that wasn't (transitively) used by any of those "roots"
03:41:57 <merijn> [exa]: But people are still arguing about the UX. The actual implementation probably isn't even that tricky/hard
03:42:00 <[exa]> merijn: that's simple and effective, most people have all projects in 1 directory anyway
03:42:06 <maerwald> jophish: the configuration for anything outside of NixOS core is an absolute mess 
03:42:16 <maerwald> like, you actually want to configure your entire desktop, editor etc
03:42:17 <int-e> maerwald: though I guess the conclusion in that ticket is that "v2-install" is a weird command; and I still have not bothered to figure out what it's for.
03:42:20 <maerwald> there is zero consistency
03:42:40 <jophish> maerwald: home-manager has been working pretty great for me
03:42:55 <merijn> [exa]: See discussions here: https://github.com/haskell/cabal/issues/3333
03:43:06 <[exa]> merijn: I think it would be simpler to just write down a log of which packages/versions got used by what, and let the user nuke it selectively
03:43:24 <[exa]> like "versions not touched last month"
03:43:27 <merijn> int-e: v2-install is mostly for binaries, but you can also install libraries into named environments so that you can use them from ghci
03:43:44 <maerwald> jophish: compare that to gentoo, which has global and local use flags. You don't juse add global use flags yourself. These have to be discussed, the semantics, if it's intuitive for the user etc
03:43:45 <merijn> int-e: That workflow is rather underdocumented, though
03:43:47 <[exa]> and "I removed $src/project, remove stuff referred by only that"
03:43:47 <maerwald> in nix they just do whatever
03:44:05 <jophish> not sure what you mean by nixos core, but whenever I've had to make a service which doesn't have a module for nixos it's generally been a painless process
03:44:38 <int-e> Anyway, I'll figure it out when I have to, not before :P
03:45:42 <jophish> very sorry but you've lost me again, I'm not certain what global and local use flags are. Are they like the optional features when building packages?
03:45:49 <maerwald> merijn: cleaning up cabal documentation and --help output would be a gsoc project I guess :P
03:46:31 <jophish> because I'm not really sure what thought goes into adding these in nixpkgs, although as a user I've never had trouble with these
03:46:31 <maerwald> jophish: the point is, deciding on seemingly simple things like naming configuration is something that needs to be synchronized across the entire distro, potentially
03:46:36 <jophish> ah I see
03:46:38 <maerwald> they simply don't do that, except for the core
03:46:41 <maerwald> like configuring network
03:46:48 <int-e> (If I'm honest, a big part of this is that I hate change... sandboxes hit a sweet spot for me that I find very comfortable to live in.)
03:46:48 <maerwald> the rest is a mess
03:47:29 <merijn> maerwald: hvr and phadej are pretty much to busy/overworked to focus on that, so I think it's mostly a matter of people trying their best to submit docs patches when possible
03:47:59 <maerwald> but the worst part of nix is: they mix *configuration* API with *packaging* API and it leaks hard
03:48:02 <merijn> maerwald: Docs patches have a very low barrier to entry compared to the Cabal codebase at least, so that's good
03:48:05 <jophish> can't say I've had trouble using nixos options, but I can certainly understand that the system might be lacking some naming convention consistency
03:48:10 <maerwald> You can't be a nix user without understanding how the packaging works, ever
03:48:15 <maerwald> In gentoo, you can
03:48:38 <maerwald> because there is a clear separation to user configuration and how packaging works
03:48:56 <jophish> not sure I agree with that, the system configuration is by and large quite isolated from how packages are built
03:49:07 <maerwald> yes, as I said, anything beyond core
03:49:52 <jophish> can you give an example of something not in core, I don't think we're quite talking about the same thing:)
03:49:56 <maerwald> And the patterns and things ppl do are barely documented. There's no stable "API", there's just a language and ppl build whatever on top
03:50:16 <maerwald> in gentoo, you have EAPI and if you do weird stuff, ppl will punish you
03:50:16 <jophish> yeah, agree with that strongly :)
03:51:12 <maerwald> jophish: example: configuring vim. If you can do that without reading all the nix expressions, asking in forums, IRC, wading through blog posts and overly verbose documentation... ok
03:51:25 <jophish> ah I see
03:51:43 <maerwald> And the ultimate answer will be a random gist on the internet with some code
03:51:47 <jophish> well, for a long time I didn't use nix to configure vim and that's an option. 
03:51:51 <jophish> but I strongly agree with you there
03:52:10 <jophish> I'm surprised that gentoo has functionality for building a vimrc for the user though
03:52:14 <phadej> can one say "nix works if you are happy with defaults"?
03:52:50 <maerwald> phadej: just use ubuntu then? :P
03:52:55 <phadej> I do
03:52:58 <maerwald> heh
03:52:58 <phadej> ;)
03:53:05 <jophish> maerwald: I guess this comes back to the start of the conversaion. I spent the time to learn how vim config generation works in nixpkgs (after writing my own nix based vim package manager in fact) and I couldn't be happier with the investment
03:53:23 <maerwald> jophish: yes, that's a huge investment for something I want to be done in 30 minutes
03:53:29 <maerwald> So it's a time sink
03:53:44 <jophish> sure, that's a tradeoff people have to make
03:54:00 <maerwald> Yes, and nix fanboys are barely aware of this tradeoff :P
03:54:28 <jophish> personally I think it's saved me a bunch of time. If a vim plugin makes some change I don't like it's totally trivial to roll it back, or bisect it. and trivial to make a vim package with just this plugin and a minimal vimrc
03:54:30 <phadej> I think pathogen method of dozen of `git clone ...` (and maybe checkout) is like, easy enough. "And I understand what happens"
03:54:48 <maerwald> phadej: I basically do that with my entire config (vim, i3, ...)
03:54:51 <phadej> fwiw, I never upgrade them if they work
03:55:05 <maerwald> And it is reproducible enough lol
03:55:07 <phadej> (I might miss some new features, but whatever)
03:57:16 <jophish> I can certainly see how it would be annoying if people misrepresented the amount of time it takes to set up such a tool
04:22:06 <merijn> phadej: Just upgrade when something's broken/missing and you see the new feature has it, yeah :p
04:22:54 <merijn> honestly, that's how I upgrade GHC too :p
04:25:33 <phadej> 8.8 has nice feature as it's more picky about unused imports
04:26:14 <phadej> but more generally, yes, not much changes
04:26:28 <phadej> (which is good)
04:26:42 <merijn> 8.10 is the one with killer features, imo
04:27:20 <merijn> mpickering's work on speedscope support is made of happiness and bliss
04:34:47 <phadej> depends what one needs :)
04:52:23 <maerwald> what is speedscope
04:52:50 <merijn> maerwald: A visualiser for profiling data
04:52:53 <merijn> maerwald: https://www.speedscope.app/
04:53:43 <merijn> maerwald: See also: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
04:53:52 * hackage data-transform 0.1.1.0 - Functions to transform data structures.  https://hackage.haskell.org/package/data-transform-0.1.1.0 (JonasScholl)
05:09:07 <carbolymer> is there a lifted dot? I mean, I'm looking for a function (m b -> m c) -> (m a -> m b) -> m a -> m c
05:09:38 <merijn> carbolymer: eh... (.) works fine with that type
05:10:07 <carbolymer> merijn, hmm, so sth has to be wrong with my code because it isn't, lemme double check
05:10:28 <merijn> carbolymer: Note that the type variables in (b -> c) -> (a -> b) -> a -> c can be *anything*, including 'm b' or whatever
05:11:29 <carbolymer> merijn, that's what I thought, so I was puzzled why it's not working
05:11:41 <merijn> carbolymer: Got a minimal example/type error?
05:12:21 <phadej> maybe you have (b -> m c) -> (a -> m b) -> a -> m c ?
05:12:50 <phadej> (which is >=>) or something in between?
05:15:13 <carbolymer> ooh, I've asked a wrong question :D I need  (m b -> m c) -> (x -> m a -> m b) -> x -> m a -> m c
05:16:31 <maerwald> that isn't hard to write a lambda for
05:17:32 <carbolymer> right
05:17:43 <carbolymer> and even hoogle works with this, https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html#v:.:
05:17:49 <carbolymer> so I guess problem solved?
05:19:00 <merijn> Honestly I'd advice against using that operator and recommend you just invent a bunch of names
05:19:26 <maerwald> if you use obscure operators, better use them a lot
05:19:29 <merijn> On account of no sane person being able to understand that :p
05:19:49 <maerwald> if you have occasionally obscure operators in your codebase, you'll force ppl to look them up for sure
05:19:55 <carbolymer> that's a good advice
05:20:12 <carbolymer> thanks
05:20:44 <merijn> Alternatively, rewrite your input arguments to have types that play more nicely together :p
05:21:00 <merijn> Hell, you can simply partially apply the second function and just use (.)
05:21:18 <merijn> "\x -> f . g x"
05:24:29 <frdg> How good of code reusability does Haskell have? Im beginning to realize that it should have insane reusability because our functions are so predictable and we know everything about them. I have minimal experience in other programming languages but I can't imagine how difficult it is to combine programs when you have to worry about side effects.
05:25:24 <merijn> frdg: Much easier than a lot of other languages, yes
05:25:46 <merijn> frdg: cabal-install also makes it much easier to move code into it's own standalone package and reuse it
05:25:48 <maerwald> frdg: you have side effects in haskell too, in a way. Maybe not technically, but morally
05:26:15 <maerwald> Reasoning about exceptions/errors especially becomes complicated quickly.
05:26:29 <maerwald> And then you combine 10 things that can fail in different ways
05:26:38 <maerwald> that's an unsolved problem in programming imo
05:26:41 <merijn> maerwald: imo, not more so than other languages with unchecked exceptions (i.e. most of them)
05:26:48 <maerwald> yes, not more, not less
05:26:52 <maerwald> but it isn't really better
05:27:04 <frdg> very interesting
05:27:16 <maerwald> I think one thing you can say for sure is: haskell is easier to refactor (to some degree)
05:27:48 <maerwald> But code reusability is, in some instances, lower
05:27:55 <maerwald> because libraries don't combine arbitrarily
05:28:12 <maerwald> You have to choose a) an exception lib, b) an effects lib, c) a streaming lib, ...
05:28:23 <maerwald> and when you want to switch, you have a lot of work on your hands
05:28:48 <maerwald> if you have "weak" types in your API, it is in some way more reusable
05:28:52 <maerwald> but we don't like weak types
05:29:07 <frdg> would I be correct to say that in other programming languages you can combine programs "dangerously" and not realize it.
05:29:41 <maerwald> I think combining isn't the main problem. It works. Refactoring is
05:29:59 <frdg> ok cool
05:30:01 <maerwald> The compiler doesn't guide you in python
05:30:12 <maerwald> But you can still write amazing reusable python libs that combine well
05:30:20 <maerwald> But maintenance is really hard
05:30:22 <merijn> maerwald: Theoretically, at least ;)
05:30:29 <merijn> I've never seen that in practice :p
05:30:46 <maerwald> lxml in python is amazing
05:30:59 <maerwald> click is amazing
05:38:15 <maerwald> frdg: https://www.fpcomplete.com/blog/2018/04/async-exception-handling-haskell
05:38:29 <maerwald> is one good blog post about the complexity of exceptions in haskell
05:39:26 <maerwald> and then things like difference of evaluate vs $! etc
05:41:00 <maerwald> But those are mostly problems with IO-heavy code
05:45:52 <frdg> maerwald: ill look at that right now thank you
05:48:34 <zincy_> Aren't exceptions complex in every language
05:48:50 <zincy_> It is just that language designers quite like sweeping the issue under the rug
05:49:19 <zincy_> I mean exceptions as far as I understand them are errors which if unhandled modify control flow
05:49:26 <zincy_> That doesn't sound simple.
05:53:56 <maerwald> zincy_: well, for starters, you have no concept of checked exceptions in haskell. Then... whether an exception occurs or not may depend on evaluation (order)
05:54:21 <maerwald> so you must be careful to force things sometimes, so they don't leak outside your handlers
05:54:32 <maerwald> with pure exceptions for example
05:54:50 <maerwald> and async is its own beast, ofc
05:55:07 <maerwald> rust does it very different
05:55:17 <maerwald> But they also panic a lot
05:56:24 <maerwald> Java at least has checked exceptions, but the way ppl use it is useless
05:57:16 <maerwald> then... things like 'Either a b' (or ExceptT) don't combine well, because of the 'a'. Then you try open variants and get all other sorts of problems
05:57:39 <maerwald> (like inference not working anymore)
05:59:40 <maerwald> then you think hey, why not do polysemy... and then you're at the end of the road, ready for giving up KISS
06:00:06 <maerwald> Back to MonadThrow
06:01:28 <maerwald> this is the haskell cycle: 1. having a problem and getting severly annoyed, 2. finding an experimental type-level library that solves everything 3. realising nothing works properly, 4. going back to plain IO
06:05:22 * hackage inspection-testing 0.4.2.4 - GHC plugin to do inspection testing  https://hackage.haskell.org/package/inspection-testing-0.4.2.4 (JoachimBreitner)
06:05:30 <zincy_> "zincy_: well, for starters, you have no concept of checked exceptions in haskell. Then... whether an exception occurs or not may depend on evaluation (order)"
06:05:41 <zincy_> *may* depend.
06:06:14 <zincy_> But you can wrap exception prone code in IO with evaluate right to get the execution order guarantees of IO
06:06:19 <zincy_> Or am I way off
06:06:52 <zincy_> maerwald: There is a servant package for checked exceptions
06:07:05 <zincy_> Is that anything to do with what you are referring to?
06:07:11 <maerwald> No
06:07:12 <zincy_> I don't even know what checked exceptions are
06:07:29 <maerwald> GHC doesn't know what exceptions a function may throw
06:09:05 <infinity0> is there any particular reason polymorphic functions are not Typeable? could you not just represent the forall like how the haskell AST itself does it?
06:10:03 <zincy_> infinity0: That is a great question
06:10:12 <zincy_> I will wait for a response with you.
06:11:23 <merijn> I was at a SPJ talk about this, but I don't recall the reason why :p
06:14:02 <infinity0> e.g. https://hackage.haskell.org/package/template-haskell-2.15.0.0/docs/Language-Haskell-TH.html#t:Type
06:14:16 <infinity0> it even implements Generic so you could perhaps even serialise it
06:36:19 <lyxia> It's not obvious how to do it without impredicative polymorphism.
06:36:52 <lyxia> so you have typeRep :: Typeable a => TypeRep a, now you want to instantiate a with (forall x. x), that's impredicative polymorphism.
06:38:52 * hackage table-layout 0.9.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.9.0.0 (muesli4)
06:40:16 <merijn> Funny way of saying it's no obivous how to do it ;)
06:40:22 <merijn> s/no/not
07:23:01 <frdg> how should I think about "cannot construct the infinite type" errors?
07:29:52 <thotypous> hi! have someone seen lennart augustsson here on freenode lately? i don't remember which nickname he used to use
07:31:22 * hackage birch-beer 0.2.4.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.4.0 (GregorySchwartz)
07:32:33 <merijn> frdg: You're trying to define something that uses itself
07:32:50 <merijn> frdg: Consider: "x = [x]" what is the type of 'x'?
07:32:52 * hackage secp256k1-haskell 0.2.0 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.2.0 (jprupp)
07:33:37 <merijn> thotypous: augusts, but he hasn't been on freenode in ages
07:33:52 <merijn> thotypous: (Maybe it was augustss, I forget)
07:35:28 <frdg> merijn: We wouldn't know the type of x...hmm im still a bit unsure though
07:36:28 <merijn> frdg: Well, clearly the type of 'x' is [?] where, but ? has to be "the type of 'x'"
07:36:36 <merijn> frdg: So you get, well, an infinite type
07:36:42 <merijn> It's just an infinite nesting of []
07:36:55 <merijn> But that's not allowed
07:37:08 <merijn> frdg: That's what "cannot construct the infinite type" means
07:37:18 <frdg> so the type check just goes in a loop?
07:37:41 <merijn> frdg: It's not that it goes into a loop, it's just that the type is incomputable because it's infinite
07:38:15 <frdg> ok I see. thanks!
07:38:18 <merijn> frdg: You *can* have infinite nesting, just not directly and open like that. You have to delimit using a newtype
07:38:56 <merijn> So "newtype Infinite = MkInfinite [Infinite]" and doing "x = MkInfinite [x]" would work
07:39:31 <merijn> frdg: But notice how the introduction of the newtype has broken the self-reference in the type.
07:41:04 <frdg> because now x has a type
07:41:17 <frdg> its an Infinite
07:42:21 <merijn> frdg: Right
07:42:48 <merijn> Despite being the same thing, conceptually
07:43:30 <merijn> In fact, recursion-schemes has the more general "newtype Fix f = Fix (f (Fix f))" which works for any functor
07:43:53 <merijn> And before you know it you're on the way to free monads :p
07:44:21 <frdg> merijn: ill have to take your word for that haha
07:45:40 <ski> thotypous,merijn : yes, augustss
07:46:36 <thotypous> hmm last seen 10 weeks ago.. thanks, ski 
07:46:59 <thotypous> thanks, merijn 
07:47:00 <Cale> frdg: It's possible to develop type systems which admit infinite types of that sort, but there are a lot of simple mistakes when working on code that can result in infinite types, so Haskell makes that an error, and you can always introduce a recursive newtype to get the equivalent of any infinite type you might have needed.
08:01:03 <maralorn> I am using https://hackage.haskell.org/package/shh-0.7.0.7/docs/Shh.html to call some programs. Sadly sometimes when piping stuff programs misteriously don‘t exit. And then my script hangs. I guess this has something to do with file descriptor problems. But I have no clue how to debug it.
08:07:23 <f-a> I have a program (`xmonad --recompile`), which calls/uses ghc. I would like to specify a ghc (system one). Is there any other way than to modify my PATH?
08:13:45 <hvr> f-a: https://github.com/xmonad/xmonad/issues/199#issuecomment-609433196
08:14:20 <f-a> grazie valerio
08:14:35 <hvr> non c'e di che
08:34:22 * hackage cimple 0.0.1 - Simple C-like programming language  https://hackage.haskell.org/package/cimple-0.0.1 (iphydf)
08:51:52 * hackage stack2cabal 1.0.6 - Convert stack projects to cabal.project + cabal.project.freeze  https://hackage.haskell.org/package/stack2cabal-1.0.6 (tseenshe)
09:11:22 * hackage i3blocks-hs-contrib 2.0.0 - Base i3blocks written in haskell  https://hackage.haskell.org/package/i3blocks-hs-contrib-2.0.0 (panavtec)
09:20:07 <cjay-> jophish: yep that's me
09:26:09 <pie_[bnc]> is isovector on irc?
09:29:49 <Uniaika> yeah… last year or so I think?
09:32:49 <pie_[bnc]> heh
09:33:02 <pie_[bnc]> semi related, if anyone bothers with the wiki, might want to add his book to https://wiki.haskell.org/Books
09:35:35 <Uniaika> as well as the Joy of Haskell ones
09:39:13 <solonarv> pie_[bnc]: probably not anymore - https://sandymaguire.me/blog/burnout/
09:43:35 <pie_[bnc]> Uniaika: damn
09:44:10 <Uniaika> pie_[bnc]: maybe was he referring to Thinking with Types?
09:47:16 <yushyin> 'working on this research that not only did anyone understand, ' a bold statement. Sure /I/ don't know a bit about polysemy but other sure do. I guess lexi-lambda knows quite a bit about effect systems.
09:49:48 <pie_[bnc]> i dont think thats to be taken face value and at this moment in time
09:50:31 <yushyin> yeah
09:56:54 <pie_[bnc]> Heh, the loneliness of having a clue.
09:57:49 * pie_[bnc] is on the clueless side of that to be clear
09:58:52 <yushyin> well, I wish him a good recovery from all his stress ^^
09:58:56 <pie_[bnc]> yeah
09:59:20 <pie_[bnc]> (i need to get *out* of my stress, but yaknow, dont have lucrative tech jobs behind me x) )
09:59:32 <pie_[bnc]> anyway starting on the book now >:3
10:01:33 <monochrom> I have long learned to accept these two paradoxical aspects: 1. probability that a randomly-chosen person knows such-and-such can be extremely low; 2. probability that no one knows it at all is even lower
10:02:45 <monochrom> Point #1 implies that if you talk to someone geographically near you, sure, fat chance they know it.
10:03:28 <monochrom> But point #2 is the bright side and a triumph of the internet: if you talk on irc or twitter or reddit or ... you will find someone who knows it.
10:03:44 <tomsen> E.g. data Person = Person { name :: String }, is there a scenario where I wouldn't use Person two times here? but use a different "constructor" name?
10:05:17 <solonarv> if you only have one constructor and don't expect to add more later, it's not unusual for them to have the same name
10:05:37 <monochrom> I have come across a student who discussed Hask with me.  (I never taught it or brought it up.)
10:05:40 <dmwit>  monochrom: Perhaps there is a sampling bias here. You only know to talk about things that at least one person in the world knows about.
10:05:52 <solonarv> you could argue that a naming convention like 'data Person = MkPerson { ... }' is a bit less confusing because now there is no chance of mixing them up
10:06:11 <monochrom> OTOH this happened after teaching the course like 5 times, spanning over like 600 students.
10:07:58 <monochrom> dmwit: I think no. I think I have already factored in also the extremely low but still non-zero probability of independent discoveries/inventions.
10:10:50 <tomsen> but when matching patterns MkPerson would also be confusing i guess
10:11:25 <monochrom> No, not confusing at all.
10:15:40 <pie_[bnc]> there's a low chance someone knows it, an even lower chance theyll talk to you, and fat chance theyll work on it :D
10:16:00 <monochrom> damn you pessimistic people.
10:16:23 <ski> why confusing, tomsen ?
10:16:26 <monochrom> OTOH I do make that kind of jokes too.  Every silver lining has tarnish.  There!
10:16:30 <pie_[bnc]> im consciously a pessimist, but unconsciously i must be an optimist because i keep failin at the same thing over and over :P
10:16:52 <pie_[bnc]> i was supposed to make a joke about running headfirst into walls there, oops
10:17:31 <monochrom> "ramming speed!"
10:18:50 <monochrom> comical pessimist = "oh God we're are doomed, hahahaha"
10:18:53 <tomsen> I guess it's just my thinking. `Person "John"` is like "i have a person named john, otherwise it'd be "here is a builder, that gives me a person named john"
10:19:38 <monochrom> That's OO thinking.
10:20:01 <monochrom> No, nevermind, you have a point.
10:20:02 <tomsen> or maybe struct thinking
10:21:25 <monochrom> This is why I advocated "PersonOf" but no one listened.
10:23:07 <dsal> What about McPerson?  I think that reads better than MkPerson.
10:23:23 <tomsen> But then again, why even the need to have to write Person two times, or come up with 2 names 
10:23:47 <tomsen> data Person = McPersonface "john"
10:24:10 <monochrom> McPerson is a good mix of Mk and Of.
10:26:11 <jophish> cjay-: I saw your vulkyrie project and thought you might be interested in speaking about vulkan bindings.
10:26:33 <jophish> cjay-: in particular, I've just finished some bindings for the VulkanMemoryAllocator project: http://expipiplus1.github.io/vulkan/VulkanMemoryAllocator-0.0.0.0/Graphics-VulkanMemoryAllocator.html
10:27:30 <jophish> These are ever so slightly higher level than basic C bindings in that they take away all the automatable boilerplate of interfacing with Vulkan
10:27:31 <dsal> % :t   "John" & O'Person
10:27:31 <yahb> dsal: McPerson
10:29:13 <jophish> I plan to do some slightly higher level still bindings, for MTL and Polysemy (and whatever else, it's all automatable and very easy)
10:37:31 <dgpratt> I've been away from the Haskell realm for a bit, but am lately inspired to get back to it. Apparently the last setup I had going was Stack + VS Code + the Haskero VS Code plugin. Has the Haskell world moved onto something better since?
10:38:15 <solonarv> dgpratt: intero (which is used by haskero as a backend) is deprecated/abandoned
10:38:29 <dgpratt> ah
10:38:40 <dgpratt> is there an obvious replacement?
10:38:41 <solonarv> all the maintainers of HIE, intero, and so on have joined forces
10:38:49 <solonarv> the replacement is supposed to be ghcide
10:38:50 <dgpratt> sounds cool
10:40:52 * hackage burrito 1.0.1.0 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.0.1.0 (fozworth)
10:44:45 <cjay-> jophish: I haven't looked into memory allocation much, my own allocator is extremely basic and can't even deallocate. Maybe I should use your lib :)
10:45:24 <jophish> cjay-: it would mean switching over to `vulkan` from `vulkan-api`, which I appreciate may be a big ask!
10:45:42 <jophish> well, a big job. I'm not requesting anything :D
10:45:47 <cjay-> jophish: I also haven't looked into other vulkan bindings, vulkan-api seemed to be the best maintained when I started, and it had actual example code at the time that drew a triangle.
10:46:46 <jophish> hehe, `vulkan` has that too now https://user-images.githubusercontent.com/857308/78356735-b2bcd580-75e2-11ea-9830-14b2f0e88ca1.png
10:47:11 <cjay-> memory allocation is rather low on my todo list though. currently I'm trying to fix a segfault related to swapchain stuff.
10:47:23 <cjay-> next I will evaluate better resource management approaches
10:47:46 <cjay-> continuation based deallocation is probably not the best for performance
10:47:56 <jophish> I can let you know when I get the ResourceT bindings out
10:48:31 <cjay-> hmm ResourceT is the one with the IntMap, right? probably still overkill.
10:48:40 <jophish> well, that's an implementation detail
10:48:45 <cjay-> true
10:49:01 <jophish> I'd have thought though that continuation based deallocation wouldn't be too bad
10:49:06 <johnw> is "continuation based" the same finalizers?
10:49:31 <jophish> tbh I'm not sure what else there is between ResourceT and ContT (or ContT with a different name)
10:49:41 <cjay-> johnw: please rephrase ^^
10:50:02 <johnw> what is continuation based deallocation?
10:50:51 <cjay-> it means gluing deallocators after the current continuation, to make them happen automatically at the end
10:51:05 <cjay-> I recently read  that CPS is slow in haskell
10:51:17 <johnw> where did you read this?
10:51:23 <cjay-> in this discussion https://www.reddit.com/r/haskell/comments/f7p0qe/rfc_delimited_continuation_primops_ghc_proposal/
10:52:17 <johnw> ah, he doesn't give a reason or numbers
10:52:40 <johnw> i.e., is it closures that are slow, or the way they're being used
10:52:49 <cjay-> jophish: I'm thinking of having a state in the monad that is just chained deallocators with (>>)
10:53:22 <cjay-> johnw: I'm not 100% sure it applies to the Program monad of my project, but probably it does
10:54:19 <jophish> cjay-: makes it tricky to release things early though
10:54:31 <jophish> for example resources associated with the window size
10:54:45 <jophish> (no harder than ContT though)
10:55:11 <cjay-> jophish: to do that, I'd just put things into vars that can be empty. the deallocator would check the content of the var
10:55:18 <cjay-> but I'd do it only where it's needed
10:55:29 <jophish> ah I see,
10:55:41 <jophish> most (all?) of the vulkan deallocation functions accept nullptr
10:56:00 <cjay-> oh, I didn't know that
10:57:12 <cjay-> johnw: have you read this comment? https://www.reddit.com/r/haskell/comments/f7p0qe/rfc_delimited_continuation_primops_ghc_proposal/fij4mzc/
11:02:31 <jophish>  cjay- on the topic of freeing resources, `vulkan` already packages these up in CPS, for example http://expipiplus1.github.io/vulkan/vulkan-3.1.0.0/Graphics-Vulkan-Core10-Device.html#v:withDevice
11:04:30 <johnw> I see, thank you
11:04:37 <jophish> It does this for creation of all handles, as well as any other paired operations, such as mapMemory http://expipiplus1.github.io/vulkan/vulkan-3.1.0.0/Graphics-Vulkan-Core10-Memory.html#v:withMappedMemory
11:04:48 <jophish> (if there are any missing they're trivial to add)
11:06:26 <cjay-> jophish: it should be ok for long lived stuff I think
11:08:23 <jophish> yeah, need to decide on what UnliftIO/MonadMask/whatever type to use for the inside
11:08:31 <jophish> spoilt for choice
11:10:35 <jophish> cjay-: you may also be interested in https://hackage.haskell.org/package/apecs
11:10:42 <jophish> I've not used it personally, but I hear good things about it
11:11:27 <cjay-> jophish: I'm using it in 'some-roguelike' :)
11:12:03 <cjay-> I'm not totally convinced of apecs though
11:12:28 <cjay-> the api is quite imperative
11:12:55 <cjay-> jophish: https://github.com/jonascarpay/apecs/issues/64
11:14:01 <maerwald> anyone knows what is linking to libiconv on freebsd?
11:14:41 <maerwald> like, seema any ghc executable ends up with it
11:21:30 <jophish> cjay-: that seems like an important feature to miss in a FP world!
11:21:53 <cjay-> yep
11:25:35 <jophish> I saw another ecs recently, ecstasy I think it was called 
11:29:00 <jophish> lol, base-4.13 still isn't on Hackage
11:29:50 <cjay-> afaik it's a special case and requires changes to hackage
11:30:16 <jophish> yeah, cabal-3 support maybe?
11:30:27 <jophish> or is that another issue?
11:30:49 <cjay-> no idea, but there's a issue in a tracker somewhere with a long discussion
11:31:33 <jophish> well, I'll sort out proper documentation tomorrow https://hackage.haskell.org/package/VulkanMemoryAllocator-0.1.0.0
11:31:52 * hackage vulkan 3.1.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.1.0.0 (jophish)
11:32:52 * hackage VulkanMemoryAllocator 0.1.0.0 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.1.0.0 (jophish)
11:40:48 <jophish> docs done, time for sleep
12:00:22 * hackage GPipe 2.2.5 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.2.5 (TobiasBexelius)
12:18:23 <adius> Hi, how bad is it if I implement a `Fractional` instance without `recip` or `(/)`?
12:18:46 <adius> The documentation says "The Haskell Report defines no laws for Fractional.". So it's OK?
12:21:54 <int-e> adius: Well it'll mean that 4/5 :: <your type> doesn't work
12:22:49 <int-e> And since / and recip are defined in terms of each other, rather than an error, the program will just hang... so you should actually implement one of them even if it is just to produce an error.
12:22:53 <monochrom> What is the purpose if you leave out both recip and (/)?
12:23:08 <int-e> 4.5 :: <your type> will work, apparently
12:23:24 <int-e> so maybe that's the goal
12:23:34 <monochrom> If 4.5 has a meaning then the same meaning carries over to (/)
12:23:48 <int-e> maybe you can only divide by 10
12:23:58 <int-e> stranger things have happened :P
12:24:12 <monochrom> then code up (/) to accept dividing by 10
12:24:53 <monochrom> There are no laws but there are community expectations.
12:25:21 <monochrom> In one sense community expectations are more lax, in another sense more strict.
12:25:29 <int-e> > foldl1 (+) [a,b,c]
12:25:31 <adius> The goal is `fromRational (123456.789 :: Double) -> UNIX time`
12:25:32 <lambdabot>  a + b + c
12:26:41 <int-e> that seems like a pretty awful hack
12:27:02 <int-e> You'll have a completely bogus Num instance as well.
12:27:38 <monochrom> So don't call it fromRational?
12:28:02 <monochrom> You can always give it a different name like rationalUnixTime
12:28:20 <adius> Well, I think the whole type is a little bogus: https://hackage.haskell.org/package/hourglass-0.2.12/docs/Data-Hourglass.html#t:ElapsedP
12:28:32 <monochrom> You can also always import Prelude hiding (fromRational) so you can have your own fromRational
12:28:45 <adius> But you're right, a `Fractional` instance is probably not a good idea
12:29:13 <int-e> you could provide a UnixTime.fromReal :: Real a => a -> UnixTime (and then go wild with specialization rules if you feel that way)
12:29:52 <monochrom> People probably completely misunderstand the purpose of type classes.
12:30:22 <monochrom> People from shallow versions of OO probably think that it's only about hijacking names people like.
12:30:26 <int-e> People hate grand generalizations.
12:30:50 <monochrom> But even proper OO is against that.
12:31:29 <adius> > only about hijacking names people like.
12:31:29 <adius> Well, that's the problem, because it can't used for that 😂
12:31:32 <lambdabot>  <hint>:1:40: error:
12:31:32 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:32:20 <adius> I really miss the operator overloading from Python and Julia. It would make a lot of things much nicer
12:32:33 <maerwald> what??
12:32:56 <solonarv> I mean, I agree that Num is not exactly great
12:33:20 <monochrom> nicer? or really more reckless?  Again, what I said about hijacking names.
12:33:21 <solonarv> there are plenty of types (in base, no less!) where addition makes sense, but subtraction does not
12:33:44 <adius> Sorry, but I think 3 different versions of power function syntax is insanity https://wiki.haskell.org/Power_function
12:34:18 <solonarv> I don't want to recklessly overload operators one-by-one, but I also don't want to be forced to write bogus 'negate' and 'signum'/'abs' just because I have a semiring
12:34:19 <monochrom> Num is not great but there is community expectation that (+) and (*) make some sense such that "sum" and "product" works.
12:34:31 <monochrom> or at least somewhat works
12:35:33 <adius> solonarv: Yeah, exactly my point. Make nice things like `Euro 3 <> Euro 4` impossible
12:35:45 <zeta_0> hello everyone, i was wondering if you guys could send me some links to some `small` open source haskell projects that i can contribute to?
12:36:01 <monochrom> OK for a "unified" exponentiation operator (who needs one?) you have to go either MPTC (if static typing) or downright dynamic typing.
12:36:17 <monochrom> If dynamic typing is so much nicer for you then go back to python.
12:36:29 <maerwald> I used flint (bigint etc.) in C, without operator overloading and long C function names. I'd use that over operator overloading any day, tbh.
12:36:33 <monochrom> Why hijack haskell and then make it dynamically typed?
12:36:41 <zeta_0> i started contributing to ghc about a month ago, but it's been a struggle, and ghcide was not working, so the code was hard to read
12:36:51 <monochrom> See, people, this is why I am against "we need more people to use haskell".
12:37:13 <monochrom> No. We need fewer people---the dynamically typed ones---to come over to haskell and ruin it.
12:37:22 <adius> Taylor Fausak once made an alternative Prelude for PureScript with only one function per type class: https://github.com/tfausak/purescript-neon
12:37:26 <maerwald> monochrom: don't worry, half of the ppl will be gone once we get dependent types
12:37:42 <adius> Still not sure if this is a bad or genius idea 😅
12:37:44 <monochrom> OK I suppose I should join that movement!
12:37:51 <dgpratt> decided to "install" ghcide and give it a go...pretty sure it's currently compiling every Haskell module ever created
12:38:09 <maerwald> adius: are you on a phone? I get funny emoticons
12:38:22 <zeta_0> what open src projects would you recommend to junior haskell developers to contribute to such as myself?
12:38:22 * hackage dobutokO2 0.27.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.27.0.0 (OleksandrZhabenko)
12:38:30 <monochrom> And yeah while I'm ranting, what's with the obsession over IDEs?
12:38:58 <maerwald> zeta_0: check out kowainiks tools
12:39:04 <maerwald> not too advances, still useful
12:39:09 <maerwald> codebases not too big
12:39:11 <dgpratt> as opposed to what, monochrom ?
12:39:20 <monochrom> I won't debate it when a professional haskell programmer needs and uses an IDE. That's reasonable.
12:39:27 <monochrom> editor?
12:39:36 <maerwald> zeta_0: https://github.com/kowainik
12:39:38 <adius> maerwald: I use IRCCloud. They support all the nice things …
12:40:08 <dgpratt> does said editor let me hover to see types and jump to definitions and perform automated refactorings and such?
12:40:15 <maerwald> adius: I think in 5 years this is the first time I've seen such icons in this channel :P
12:40:15 <monochrom> What baffles me is yesterday I saw a 4-day-old reddit post "rant: ... casual programmer ... toolchain environment ..."
12:40:34 <monochrom> Is it just me or do you see the totally obvious oxymoron in that title
12:40:55 <solonarv> monochrom: people have slightly different definitions of words
12:40:55 <zeta_0> maerwald: thanks, i'll take a look
12:40:59 <monochrom> No, dgpratt.
12:41:04 <adius> zeta_0: I'm currently working on https://tasklite.org. I think the code is pretty straight forward, and any help would be highly appreciated =). I can also gladly help you with any questions!
12:41:10 <dgpratt> then I don't want it
12:41:38 <zeta_0> adius: cool, i'll take a look at that as well
12:41:54 <dgpratt> I'd think an "IDE" would be even more important for relative newbs like myself vs. a much more experienced Haskeller
12:41:59 <monochrom> dgpratt, if you write programs in anger, I won't debate it, you're likely right.
12:42:00 <dsal> zeta_0: If you use gopro cloud, I'm sure you wouldn't have a hard time making my stuff better. heh
12:42:36 <dgpratt> monochrom: more often I find myself trying to understand programs in anger
12:42:59 <monochrom> Oh, OK, yeah that too.
12:43:05 <solonarv> things like showing type/documentation on hover, basic autocomplete, jump to definition are quite nice to have IMO
12:43:19 <solonarv> actually even more so when you are trying to read code you are not already familiar with
12:43:27 <zeta_0> dsal: i've never used a gopro before
12:43:41 <monochrom> I should have worded "programming in anger" to include more
12:44:22 * hackage secp256k1-haskell 0.2.1 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.2.1 (jprupp)
12:44:24 <dsal> zeta_0: They've got some pretty neat stuff.  I'm starting to feel like I'm the only cloud user of theirs, though. heh
12:44:31 <dsal> zeta_0: What is interesting to you?
12:48:18 <zeta_0> dsal: well, at the moment i enjoy writing gui stuff like widgets, i'm writing some small Brick programs right now, and just started looking at threepenny-gui, the dev of Brick told me that he does not need any contributors, and i haven't messaged the three-penny-gui devs
12:48:52 <monochrom> ghci has some support for some IDE features: show type of subexpression, autocomplete, jump to definitions.
12:49:09 <monochrom> I don't mean to say you use ghci directly for this. (no one does.)
12:49:22 <dsal> zeta_0: I don't think you'll get good results in the form of "what can I help with?"  They should either have open bug lists or you should have something you want it to do that it doesn't.
12:49:45 <monochrom> A couple of emacs modes (haskell-mode, dante) know to translate this ghci feature into editor features.
12:50:20 <zeta_0> so far ghcide/ghcid is the only tools that have worked for me, i use it in emacs, and it's very stable, i use nix's ghcWithHoogle which ghcide uses to provide very good highlighted documentation
12:50:46 <monochrom> Since they're very simplistic just-some-elisp-code-asking-ghci, they are super easy to install.
12:51:47 <monochrom> no dependency other than "exec("ghci") needs to work"
12:51:57 <monochrom> you don't even need stack
12:52:46 <Bunogi> Beginner question: If I have a recursive function `bar x acc` where acc has to start at a certain value when you want to use the function(like zero if it's a counter), is there a clean way to do that? I'd rather call `bar someValue` where I use the function instead of  `bar someValue 0`. 
12:53:52 <dsal> Bunogi: You'd typically not have the surface be recursive, but recurse on an inner function.
12:53:54 <monochrom> No there is no default parameter.
12:54:28 <monochrom> So what dsal said.  Make two functions.  You can choose to hide away the helper function.
12:54:33 <dsal> I used `ImplicitParams` once.  It's pretty weird.
12:55:19 <monochrom> I hate default parameters because of another context.
12:55:58 <monochrom> I was TAing a course that included a couple of weeks over proving loops correct by invariants, and proving recursive programs correct by induction.
12:56:02 <Bunogi> Hmm okay, is there a convention for naming those helper functions?
12:56:14 <Rembane> Bunogi: Either go or functionName'
12:56:16 <yushyin> go
12:56:20 <monochrom> In this context, default parameters from python completely misled students.
12:56:42 <frdg> why does quickCheck falsify `isLower` from Data.Char?
12:56:58 <dgpratt> https://stackoverflow.com/questions/5844653/haskell-why-the-convention-to-name-a-helper-function-go
12:57:20 <Bunogi> Okay, I think I'll use `goBar`. Thanks for the pointers :)
12:57:27 <dsal> frdg: did it not tell you?
12:57:31 <monochrom> Students said "how to prove foo(n) returns such and such?  It's defined like: def foo(n, i=0): ... foo(n-1, i+1)..."
12:58:09 <monochrom> I answered "you don't, you prove a stronger statement about foo(n,i) for all n, for all i".  Student did not get it.
12:58:10 <frdg> dsal: it said it falsified it by testing 'A'
12:58:24 <monochrom> because "default parameters make so much sense in python!"
12:58:25 <dsal> frdg: what's the actual test?
12:58:41 <monochrom> This is why default parameters make no sense.  False abstraction.
12:59:44 <monochrom> Wow going all the way back to GHC 3.02 haha
12:59:53 <frdg> dsal: Im not sure. In ghci I ran `quickCheck isLower` and it gave me `Failed! Falsified (after 1 test and 1 shrink): 'A'`
13:00:17 <dsal> frdg: Do you believe '
13:00:21 <dsal> 'A' is a lower case letter?
13:00:25 <dsal> > isLower 'A'
13:00:30 <lambdabot>  False
13:00:35 <monochrom> I used to use "loop" but yeah "go" is so much shorter!
13:00:44 <frdg> dsal: ohhhh
13:00:50 <frdg> ok I get it now thanks
13:00:59 <dsal> You're saying, "This function returns true for all inputs."
13:01:13 <MarcelineVQ> monochrom: I used to use helper but people thought there was a little man in the machine
13:01:35 <dsal> I think I'm going to start using `loupe` -- at least in lens-heavy code.
13:02:01 <monochrom> Hrm!  My school teachers "helper function" since 1st year so my 3rd-year students have no problem with it.
13:02:17 * monochrom not going to worry how many students didn't make it past 1st year.
13:02:34 <dgpratt> oh my wooooord this is taking a long time; would've no doubt been quicker to figure out how to use nix instead 
13:06:21 <yushyin> monochrom: also default parameters in python are odd, they are mutable, shared and only created once when the function in defined oO
13:06:24 <dgpratt> I remember trying HIE and nix once upon a time -- got scared off by the hie-wrapper thing
13:10:22 <justsomeguy> yushyin: That has stung me once or twice -- I had several function calls that took the same list as input, and instead of operating on new copies of the list within the function, but calls were manipulating the original list at the same time.
13:10:45 <justsomeguy> s/but calls/both calls/
13:11:33 <yushyin> I fell for it too :/
13:13:41 <solonarv> and there are codebases out in the wild where that behavior is used *intentionally*
13:14:37 <justsomeguy> It would be nice if there was some kind of annotation you could add to control how aliasing works for parameters. Not sure if that makes sense.
13:15:10 <justsomeguy> But hey, it's worlds better than the crummy bash scripts I'm refactoring right now.
13:28:52 * hackage haskoin-core 0.12.0 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.12.0 (jprupp)
13:34:06 <zeta_0> whoops, my pasting is off today
13:44:36 <cole-k> if i have code like `case (x,y) of (x', _) -> x'` does `y` get evaluated at all?
13:44:42 <cole-k> my intuition is "no"
13:44:57 <Uniaika> cole-k: I think you're right
13:45:14 <cole-k> but i guess i'm kind of wary of what goes on with tuples when casing
13:47:51 <Uniaika> casing?
13:47:56 <Uniaika> you mean boxing?
13:48:23 <solonarv> generally speaking, an expression 'x' gets evaluated if, after desugaring, at some point: a) it's the scrutinee of a 'case' expression like 'case x of ...' that gets evaluated; or b) it's a function, and it is applied in an expression like 'x a b ...' that gets evaluated
13:48:25 <Uniaika> (I know, very small difference, but technical terms are what they are and I thought about font casing :P)
13:48:28 <glguy> Uniaika: "casing" as in matching in a case expression against a tuple pattern
13:48:45 <Uniaika> blawdy hell
13:48:52 <Uniaika> yes, pattern-matching
13:48:52 <solonarv> also you can ask GHC to -ddump-stg where this is all explicit
13:48:57 <solonarv> (but the output is a bit noisy)
13:50:33 <Uniaika> solonarv: I wonder if there's a tutorial / guide on decrypting STG outputs out there…
13:53:53 <solonarv> cole-k: oh, if you are wondering whether/when something gets evaluated you can also slap a 'trace' on it and see if you get an output
13:55:00 <Uniaika> :sprint works in ghci as well
13:55:04 <solonarv> cole-k: example: https://gist.github.com/Solonarv/8ec3afc27db371cadbfa98da67e960aa
13:59:22 * hackage distributive 0.6.2 - Distributive functors -- Dual to Traversable  https://hackage.haskell.org/package/distributive-0.6.2 (ryanglscott)
14:15:52 <monochrom> If you add -dsuppress-all it is much less noisy.
14:21:46 <monochrom> https://youtu.be/uR_VzYxvbxg is SPJ's talk on Core. It is not identical to STG but close enough.
14:23:33 <monochrom> For Core, I advocate knowing about both -ddump-simpl and -ddump-prep.  -ddump-prep is the one in best correspondence with STG, e.g., baby-step lets (important for reminding you of allocations of thunks)
14:24:38 <monochrom> However, because of that, it can be also too anal for some other purposes. -ddump-simpl is closer to humans.
14:25:59 <monochrom> Example: suppose you have a thunk for "f (g x)".  -ddump-simpl gives you "let y = f (g x)".  -dddump-prep and -ddump-stg give you "let tmp = g x; y = f tmp"
14:26:15 <solonarv> what's the difference between -prep and -stg ?
14:26:26 <monochrom> prep is Core, stg is STG
14:27:01 <monochrom> But prep is really the last Core. It's called "prep" precisely because "prepare for STG"
14:27:07 <solonarv> ah, I see
14:30:26 <monochrom> Err wait, so the Core talk was in an Erlang meeting?  What has the world come to?
14:30:43 <monochrom> Next there will be a Python 4 talk in a Haskell meeting?!
14:31:35 <monochrom> "Guido von Rossum will give a keynote at ICFP 2020"  missed an April 1 opportunity!
14:32:56 <Rembane> I love the cross pollination.
14:33:22 <ohhai> I'm trying to setup nix for a dev environment with reflex-dom which requires an earlier base than the latest GHC. So I'm trying to use nixpkgs's haskellPackages.shellFor with an earlier ghc-version. How do I do this?
14:34:37 <MarcelineVQ> If you don't already know the ins and out of haskell with nix I'd try the reflex-platform
14:51:22 * hackage butcher 1.3.3.0 - Chops a command or program invocation into digestable pieces.  https://hackage.haskell.org/package/butcher-1.3.3.0 (lspitzner)
15:45:22 * hackage juicy-gcode 0.1.0.5.2 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.5.2 (dlacko)
16:11:40 <zeta_0> adius: i ran into some problems with nix, but i should be finished fixing it by this afternoon
16:12:15 <zeta_0> adius: will you be online, tomorrow, i should be ready to start contributing by then
16:13:59 <adius> Cool! I’ll go to bed now. It’s already quite late in Germany. Maybe you can write a few notes how to get it running on nix? Would be cool to provide official support
16:14:32 <adius> See u later!
16:15:00 <zeta_0> adius: ok i'll write down the notes on how to do this with nix
16:15:04 <zeta_0> adius: see you later
16:15:44 <infandum> The install folder for stack used to be in something like .stack-work/install/x86_64-linux/lts-14.27/8.6.5/ but now it is in a x86_64-linux-tinfo6/d6540caf44818aa49ba02200eae463e8c8253a5b7c0a7e878591a8702d054815/8.6.5/ that isn't deterministic -- how can I have it be deterministic again?
16:20:55 <Uniaika> infandum: I'd say it's deterministic since it's based on a cryptographic hash. hash-less folder aren't, because their name doesn't change while their content do
16:21:11 <Uniaika> infandum: are you trying to run the binary you're producing?
16:21:54 <infandum> It's for copying the bin and share folder in a docker 
16:22:29 <maerwald> hashes or the new thing these days
16:22:35 <infandum> the thing is, it's a different for when I did a stack install on the docker vs the local build
16:25:59 <Uniaika> infandum: does this command produce the desired result: `stack path | awk -F ':' '/^bin-path:/ {print $2}'` ?
16:26:04 <Uniaika> run it in a stack project
16:27:36 <MarcelineVQ> there's flags for stack path so you don't need to search the whole output
16:28:39 <Uniaika> ah yes indeed, you can do
16:28:41 <Uniaika> $ stack path --bin-path | awk -F ':' '{print $1}'
16:41:38 <sm[m]> or stack exec -- which myexe
16:43:32 <ysangkok> monochrom: the defaulting gets really nasty with the tuple functor :O
16:43:34 <ysangkok> > all isNothing (Just 1, Nothing)
16:43:36 <lambdabot>  True
16:45:11 <monochrom> @type all isNothing (Just 1, Nothing)
16:45:12 <lambdabot> Bool
16:45:26 <monochrom> @type (Just 1, Nothing)
16:45:29 <lambdabot> Num a1 => (Maybe a1, Maybe a2)
16:45:53 <monochrom> @type all
16:45:54 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:47:47 <monochrom> No this one does not use any defaulting.  When no type class constraint is placed on a2, it is not an ambiguous type variable.  Parametric polymorphism is sufficient to resolve isNothing (Nothing :: Maybe ???????) = True.  Free theorems corroborates with this.
16:48:18 <xavo[m]> hey, I remember looking at some thing that was like the Monoid instance for Semigroup a => Maybe a but with "and"y semantics instead of "or"y
16:48:46 <xavo[m]> it's not a Monoid since Nothing `f` _ was Nothing but I don't remember what class had something like that?
16:49:29 <monochrom> Also, "all" doesn't use Functor, it uses Foldable.  This is the doing of the tuple foldable.  The tuple functor is just fine.
16:50:33 <ysangkok> ooooh thanks for your corrections and definition. that makes it clearer what defaulting really is
16:54:58 <ysangkok> monochrom: but the foldable is fine too, right? if you understand why it works like that ;)
16:57:33 <monochrom> It is of limited use. So a more important consideration is whether it is confusing.
16:58:17 <monochrom> OTOH I'm known to support "let 2+2=5 in 2+2" and "let in 5" which are also of limited use, are confusing, but I still support them.
16:58:47 <monochrom> Although, I have a better argument for "let in 5"
16:59:10 <ysangkok> is the first one n+k pattern?
16:59:23 <monochrom> No, because you can do it to * too.
16:59:34 <monochrom> > let 0/0 = 5 in 0/0
16:59:36 <lambdabot>  5
16:59:48 <solonarv> you are just redefining +
16:59:53 <solonarv> (or *, or /, or whatever)
17:00:00 <monochrom> If you truly understand, it's fine :)
17:00:36 <solonarv> I actually did not know that 'let { } in' was legal
17:02:17 <infandum> Uniaika: I don't think I can pass variables to different docker images though
17:02:33 <infandum> like in a Dockerfile, from one image to the next (first is to build, second is smaller for executable)
17:03:08 <monochrom> Ah, so someone asked in the last few days why n+k patterns were removed.  I think this is a good reason.
17:03:16 <xavo[m]> solonarv: _ where {} is too lol
17:03:52 <monochrom> Or maybe bad reason, I don't know, depends on how much you value n+k patterns vs how much you value "if it looks like a function name it is a function name".
17:04:11 <infandum> Ah, but I can copy to a known location, ok
17:04:51 <monochrom> My stance is that n+k patterns were cute while it lasted, but really it creates an exception of little value.
17:06:43 <frdg> https://pastebin.com question relating to Monoid/Semigroup
17:06:49 <infandum> Oh, that actually wont work because the executable is linked to the specific location
17:07:48 <solonarv> frdg: eh? you just linked to pastebin.com
17:08:12 <frdg> oops https://pastebin.com/NPRBsR83
17:09:40 <solonarv> frdg: okay. I see some code with gaps in it. what is your question?
17:09:47 <monochrom> I don't understand why you also defined First'.  Since you already have a brand new type Optional, you need neither First nor First'.
17:11:27 <frdg41> ok you know what im actually gonna come back in a bit. Im just lost in general sorry guys I didn't ask a useful question
17:11:39 <frdg41> and now im frdg41...
17:12:35 <MarcelineVQ> monochrom: Optional is already given a Monoid instance in an earlier exercise
17:14:06 <monochrom> Is it super important to load code for both exercises in conjunction?
17:15:03 <MarcelineVQ> Not critical, only to avoid redefining Optional and to give you practise working with newtypes
17:19:01 <MarcelineVQ> frdg41: compare your semigroup definition to the example outputs.  First' (Only 1) <> First' (Only 2)  in particular
17:25:05 <ysangkok> i am trying to swap out a dependency for the git version. what is the best way to do that? what i have done usually, is point hs-source-dirs at the source folder of the checkout out git repo. but this is bypassing the package system, feels dirty
17:25:19 <ysangkok> (i use cabal-install 3.2)
17:27:08 <frdg41> MarcelineVQ: I see. Is this a realistic scenario of how you would do this kind of thing?
17:27:30 <ysangkok> (and it requires me to copy their dependencies into my repo, it's terrible)
17:29:07 <MarcelineVQ> frdg41: I'm quite sure what you're asking but it is useful enough to exists in the standard library http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:First
17:29:52 * hackage entropy 0.4.1.6 - A platform independent entropy source  https://hackage.haskell.org/package/entropy-0.4.1.6 (ThomasDuBuisson)
17:31:57 <ysangkok> MarcelineVQ: but has been removed in 8.10, it says..
17:32:15 <ysangkok> why can't i find base 4.14 on hackage? weird
17:34:06 <MarcelineVQ> because Alt was invented "First a is isomorphic to Alt Maybe a, but precedes it historically." but that doesn't mean First is useless, just that another thing as powerful exists. Learning First is a good step 1
17:34:24 <solonarv> ysangkok: you can just point directly at a git repository (remote or local), and you can also say which commit you want
17:34:39 <MarcelineVQ> for example Last is much more straightforward to someone learning than Dual (Alt Maybe a), imo
17:35:41 <solonarv> ysangkok: I'll just link to the relevant section of the cabal docs: https://cabal.readthedocs.io/en/latest/cabal-project.html#specifying-packages-from-remote-version-control-locations
17:36:13 <ysangkok> oooh so 'remote' can be 'local'... that's why i missed it :O
17:36:21 <ysangkok> i'll try with "file://" i guess
17:36:39 <frdg41> MarcelineVQ: I got it! The question was just phrased in a way that didn't make sense to me but its actually a pretty simple concept. Thank you
17:37:50 <MarcelineVQ> frdg41: np, it could be a bit extra confusing since iirc that book kind of finished up just before Semigroup was split from Monoid, idk if it was updated for that or not
17:38:34 <solonarv> ysangkok: the feature I pointer at doesn't even require you to check out the repository
17:38:40 <solonarv> cabal will do that for you
17:39:58 <frdg41> MarcelineVQ: It was updated. 
17:41:34 <MarcelineVQ> ysangkok: Oh I see, more directly than  Alt Maybe a  there's  Maybe (Semigroup.First a)  that is fairly straightforward
17:42:42 <ysangkok> solonarv: thanks, it works. this improves my workflow a lot
17:46:06 <ysangkok> MarcelineVQ: yeah it gets a bit confusing once you read a recommendation to use Semigroup.Option on the docs of Semigroup.First, and if you don't read carefully, you won't notice that Option was removed in the latest base (which you apparently can't read on hackage :O)
17:46:57 <MarcelineVQ> Is it know what is up with newer bases not appearing on hackage?
17:51:34 <ysangkok> MarcelineVQ: i don't know what's happening. but i think this is also outdated since it says 8.8.3: https://downloads.haskell.org/ghc/latest/docs/html/libraries/index.html
17:53:35 <ysangkok> looks like the users' guide is being redone with a different theme: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/ (this one says base 4.14)
17:54:04 <ysangkok> aaah no, scratch that. the former link wasn't the users guide
17:54:59 <ysangkok> but something is rotten here... i found the docs for base 4.14 but the still have Monoid.First :O https://ghc.gitlab.haskell.org/ghc/doc/libraries/base-4.14.0.0/Data-Monoid.html
17:55:15 <MarcelineVQ> Why those stinky cheaters
18:01:51 <ysangkok> created an issue: https://gitlab.haskell.org/ghc/ghc/issues/18041
18:07:59 <jackdk> ysangkok: there are problems that make it not as straightforward as first hoped e.g.: https://gitlab.haskell.org/ghc/ghc/issues/17859
18:08:49 <d34df00d> So let's say you're encoding a term as a GADT parametrized by the type of said term.
18:09:10 <d34df00d> What's the type of the constructor corresponding to a variable name?
18:11:16 <MarcelineVQ> d34df00d: that 2nd line is a little unclear to me
18:11:59 <d34df00d> I mean you'll have TIfThenElse :: { tif :: Term Bool, tthen :: Term k, telse :: Term k } -> Term k
18:12:08 <d34df00d>  Or TInteger :: Int -> Term Int
18:12:20 <d34df00d> But say you have TVariable :: String -> Term ???
18:12:23 <d34df00d> What should be ??? ?
18:16:26 <d34df00d> That certainly depends on the context, but I really don't want to pull the context in.
18:17:02 <dgpratt> this might be more of a Nix question, but I wanted to try https://github.com/hercules-ci/ghcide-nix and I'm pretty certain it's possible, probably even "easy" to create an isolated environment with nix-shell where I could have the appropriate version of GHC and related bits along with ghcide -- anyone around with a clue how I might do that?
18:17:14 <d34df00d> How do typically folks solve this?
18:21:44 <d34df00d> I wonder if I should even go this GADT-type-safety route, given that my language has support for top-level bindings and function application and all that.
18:21:55 <d34df00d> My gut feel is it'll get incredibly messy really soon without full dependent types.
18:32:20 <jackdk> dgpratt: is ghcide provided inside nixpkgs.haskellPackages? If so, you could probably get what you want using a ghcWithPackages call
18:32:48 <SrPx> Is it possible to create a function that receives a Bool, and returns an Int if the bool is true, or a String if it is false, without wrapping the return type in Either or similar?
18:33:25 <Cale> SrPx: You could unsafeCoerce, I suppose, but basically no.
18:33:59 <d34df00d> *not in current haskell.
18:34:13 <jackdk> SrPx: or return `Typeable a => a`, but I'm curious about the problem you're facing that led you to ask that question
18:34:22 <dgpratt> not sure jackdk I'll explore that possibility
18:34:44 <Cale> Oh, you could have it produce Dynamic
18:34:46 <Cale> lol
18:35:01 <Cale> Does that count?
18:35:09 <monochrom> Why not go back to Python if you want this.
18:35:23 <d34df00d> monochrom: or the other direction.
18:35:38 <monochrom> @quote monochrom poor
18:35:38 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
18:36:14 <d34df00d> (a : Type ** a) just so you can do dynamically typed programming while doing dependently typed programming.
18:36:31 <monochrom> "Typeable a => a" won't do if universally quantified "a".  Dynamic would be right because it's equivalent to existential.
18:36:46 <Cale> In a dependently-typed setting it becomes possible to discuss such a function, but I'm not sure it becomes any more advisable to do.
18:36:55 <jackdk> monochrom: thanks for correction
18:37:01 <monochrom> But Either String Int is KISS.
18:37:20 <monochrom> But further KISS is simply to split into two functions.
18:37:37 <SrPx> I'm trying to figure out how to compile Formality (a dependently typed language) to Haskell. Problem is that even if I erase the dependent types (which I do), there are some functions that are simply not compilable to Haskell, such as:
18:37:43 <SrPx> foo : (b : Bool) -> if b then Int else String
18:37:45 <SrPx> foo true = 7
18:37:49 <SrPx> foo false = "seven"
18:38:00 <monochrom> Type erasure = unsafeCoerce
18:38:11 <SrPx> any idea what I could do in that example?
18:38:16 <monochrom> (This is also how Agda works)
18:38:32 <SrPx> but how unsafeCoerce helps? I still need to fill the type annotation line
18:38:42 <SrPx> as in, `foo : Bool -> ????`
18:38:48 <Cale> Well, you already had your dependent type checker check the types
18:38:54 <SrPx> even if I use unsafeCoerce on the definition, what do I fill `????` with?
18:38:58 <Cale> So you don't need Haskell's type checker checking them
18:39:04 <Cale> Any
18:39:12 <SrPx> I agree! I wish I could just disable type-checking entirely
18:39:18 <jackdk> @hackage acme-smuggler
18:39:18 <lambdabot> http://hackage.haskell.org/package/acme-smuggler
18:39:18 <Cale> There's a GHC type Any which could be used.
18:39:31 <SrPx> interesting, is that new?
18:39:32 <jackdk> acme-smuggler is a cursed package, don't use it
18:40:09 <monochrom> Really, type erasure is best when the output language is low level like asm.  Haskell is a bad output language.
18:40:35 <SrPx> I agree, but GHC is the best lazy functional compiler I'm aware of 
18:41:36 <monochrom> Perhaps output Core.
18:42:07 <monochrom> But also recall that even GHC going Haskell->Core still has to insert Core-level coerces.
18:43:45 <monochrom> acme smuggler is excellent!
18:44:37 <jackdk> excellent, but definitely cursed
18:45:44 <SrPx> hmm okay
18:45:53 <monochrom> oooohhhhh hahahaha it is fantastic!
18:46:21 <monochrom> Consider also my invention http://www.vex.net/~trebla/humour/Nightmare.java
18:46:42 <jackdk> risky click of the day
18:48:01 <monochrom> Becasue I was like "why does smuggle need to throw, in fact always throws?" and then I recall I was doing this in Java. The exception mechansim is the real data channel, that's why!
18:48:06 <jackdk> ehehehe they're checked exceptions!
18:48:12 <jackdk> that's beautiful
18:48:20 <jackdk> dibblego: you know java, right?
18:48:23 <monochrom> Java > Haskell Change My Mind
18:49:27 <d34df00d> I get paid by the lines of code count so definitely Java > Haskell.
18:50:29 <d34df00d> I wonder if per-instance orphan flag would be useful.
18:50:36 <d34df00d> Like {-# OVERLAPS #-} and the likes, but for orphans.
18:52:08 <d34df00d> SrPx: BTW idris 2 compiles to scheme.
18:52:19 <d34df00d> You might consider that route too.
18:52:44 <jackdk> I wonder if an annotation that you put on a class saying "there are instances in this package-qualified module that you might have" would help the orphan instances problem
18:54:05 <jackdk> like if I say `{-# LOOK_OVER_THERE FooClass "foo-aeson" Data.Foo.Aeson #-}` in module `Data.Foo` of package "foo", then if you import `Data.Foo` and have access to `foo-aeson`, you get the instances for free. Possibly a bad idea for spooky-action-at-a-distance reasons, potential for cycles, etc
18:54:41 <solonarv> it would certainly be a good idea to have *some* mechanism for this
18:56:27 <freeman42x> I would like to use https://hackage.haskell.org/package/cabal-debian to package a Haskell NW.js app. What would I need to do so that NW.js is also packaged with the project? the nw executable is required on deployed system
18:56:56 <jackdk> it would also provide a guide for people reading a new package, to know where the instances are. Downside: it could incentivise splintering packages further into a kaliedoscope of remote packages
18:57:22 <jackdk> also there's probably challenges around working out who is allowed to point at remote instances, expecially once MPTCs are involved
18:58:34 <DigitalKiwi> jackdk: https://github.com/tonymorris/java-trivia
19:08:55 <zeta_0> i like nix, but it can be painful sometimes
19:10:25 <zeta_0> here's an  error on setting up hoogle, if anyone would like to help me fix it, thanks in advance: https://stackoverflow.com/questions/61151192/configuring-withhoogle-in-default-nix
19:12:09 <zeta_0> i know that this is more related to nix than haskell, but i figured i'd post the question here anyways
19:14:50 <zeta_0> ah shoot the link changed: https://stackoverflow.com/questions/61151192/nix-configuring-withhoogle-in-default-nix
19:21:08 <dsal> I might use nix someday.
19:39:31 <MarcelineVQ> nixpkg and cabal at tenagra
19:41:34 <dsal> hahah
19:50:44 <Cale> I wonder if zeta_0 tried --show-trace
19:55:46 <jackdk> MarcelineVQ: I am GrahamcOfBorg. You will respond to my questions.
20:15:19 <Nolrai> So I have a long computation that updates a value, and when the user hits enter I want to immediately stop it, and output the most recent value. A raw Mvar isn't the right tool, but I don't want a Chan either I don't think? Am I wrong?
20:17:31 <Cale> You could just use an IORef that has its value updated repeatedly
20:17:52 <Nolrai> Ah.
20:18:02 <Nolrai> I was wondering if that would work.
20:18:24 <Nolrai> Thanks!
20:20:44 <dsal> I always reach for STM.  I'd probably do whatever that is with just two STM vars.
20:33:09 <dmwit> Why isn't a raw MVar the right tool?
20:57:08 <ysangkok> why does hackage list http://hackage.haskell.org/package/criterion-1.4.1.0 as having dependency base (>=4.5 && <4.12)?  the cabal file doesn't list that constraint https://github.com/bos/criterion/blob/1.4/criterion.cabal
20:58:00 <sclv> revision http://hackage.haskell.org/package/criterion-1.4.1.0/revisions/
20:59:00 <ysangkok> ah, makes sense. it assumes Monad(fail) and does not compile on 8.10
21:13:29 <sjakobi> ysangkok: To work around the cyclic dependency, I can recommend switching to "gauge". Simply replace "import Criterion" with "import Gauge".
21:14:10 <ysangkok> sjakobi: all right, thanks!
21:17:06 <dsal> Is gauge new hotness?
21:18:35 <dsal> Oh, looks nice.
21:19:35 <sjakobi> dsal: It's essentially a fork of criterion with most of the dependencies stripped or inlined. A few bug fixes and new features too.
21:21:04 <dsal> Yeah, I looked it up. It looks like it wouldn't have the pretty web page, but that only works for very specific things.
21:21:17 <dsal> Otherwise probably better.  I should try it.
21:21:37 <sjakobi> BTW my favourite benchmarking-related discovery is "criterion-compare" for comparing different benchmark runs…
23:16:06 <jle`> does anyone know if a Set type with only even number of elements allowed?
23:19:30 <jgt> I'm trying to do type/operator tetris on this line to see if I can reduce it a bit, but I'm struggling. How would you write this?
23:19:35 <jgt> lookupResponseHeader k = do { r <- getResponse; pure $ r >>= M.lookup k . M.fromList . simpleHeaders }
23:20:16 <jgt> (I haven't actually written it with braces and a semicolon; just don't want to spam a load of lines here)
23:23:14 <jle`> jgt: if that already typechecks, (M.lookup k . M.fromLIst . simpleHeaders =<<) <$> getResponse, maybe
23:23:34 <jle`> although in tims like these i really wish we had a non-infix (=<<)
23:24:12 <jgt> jle`: it seems this pattern of `(g =<<) <$> f` comes up quite often in my work; I wonder if that's a smell
23:24:43 <jle`> if they are one-offs, then probably not, but if you have a lot of them then depending on how they chain, you can unite it with MaybeT
23:25:00 <jgt> ah, that's a good insight. Thanks!
23:25:19 <jle`> MaybeT can help with the plumbing in a lot of cases it if it comes up a lot
23:28:19 <jgt> yeah, I've had to lean on it a fair bit before
23:28:50 <jgt> though I haven't used it enough yet to have developed a good intuition for where I ought to use it
23:40:00 <MarcelineVQ> jle`: that's kind of an interesting challenge since enforcing a two element insert or delete isn't enough due to duplicates erasure
