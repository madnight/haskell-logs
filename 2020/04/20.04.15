00:02:36 <jeetu> https://gist.github.com/jeetu7/c16b1c2931d74d8f8d04f566263⎈^32.0
00:02:40 <jeetu> @22222∢222.02
00:02:40 <lambdabot> Unknown command, try @list
00:02:42 <jeetu> ..0
00:02:44 <jeetu> ..0321
00:02:46 <jeetu> ␣
00:03:23 <maerwald> jeetu: tame your cat
00:19:57 <Axman6> I love that could refer equally to a feline cat or cat(1)
00:20:46 <Axman6> that that*
00:32:16 <anonymous123> https://gist.github.com/fusion5/cb1d098751a0d1cafce19c6194757bf1 ... any suggestions would be welcome
00:38:51 <sshine> anonymous123, use Haddock?
00:39:46 <Axman6> anonymous123: not sure if this will fix it, but you could try instance (a ~ ()) => Documentable (M1 a) where
00:40:04 <Axman6> but, this isn't a particularly got API
00:41:06 <Axman6> if it were me, I would define  Documentable over things of kind * -> *, so you'd have class  Documentable f where doc :: String -> f (), then you can have instance Documentable M1 and isntance Documentable M2
00:41:19 <Axman6> got = good above -_-
00:46:03 <anonymous123> (Haddock is a good suggestion but I'm actually not documenting Haskell code), ok let me try that * -> * suggestion
01:20:04 <anonymous123> Thanks for the help Axman6, it works! The code is cleaner now
01:55:12 <siraben> noteanonymous123: Does adding NoMonomorphismRestricting to your list of languages extensions help?
02:01:34 <cdunklau> .win 16
02:01:39 <cdunklau> whoops
02:02:15 <absence> is there a way to swap layers in a monad transformer stack in the same way sequenceA can change Either e (Maybe a) to Maybe (Either e a)?
02:03:30 <opqdonut> not in general
02:04:18 <opqdonut> but if the Monads are Traversable, yeah, sequence/sequenceA does it
02:05:14 <absence> opqdonut: it seems like sequenceA goes "through" the transformer layers and puts the inner applicative on the outside, rather than reordering the transformer layers
02:06:08 <opqdonut> :t fmap sequence :: Maybe [Either e a] -> Maybe (Either e [a])
02:06:11 <lambdabot> Maybe [Either e a] -> Maybe (Either e [a])
02:07:01 <opqdonut> you can use fmap & sequence to push a Traversable monad down the stack
02:07:04 <opqdonut> anywhere in the stack
02:07:12 <absence> opqdonut: that's not a monad transformer stack
02:07:30 <absence> opqdonut: i mean stuff like MaybeT, ExceptT
02:08:05 <opqdonut> the same applies
02:08:25 <absence> :t sequenceA (MaybeT (ExceptT _))
02:08:31 <lambdabot> error:
02:08:31 <lambdabot>     • Data constructor not in scope:
02:08:32 <lambdabot>         MaybeT :: ExceptT e0 m0 a0 -> t (f a)
02:08:39 <absence> meh
02:08:59 <mlugg> Hi, I'm playing around with `lens` and I'm slightly confused about `magnify`. Specifically, the `Magnify` constraint it adds. I feel like the functionality it provides shouldn't require an additional constraint (although I may be wrong). Is there a way to eliminate this constraint? Is it worth delving into the typeclass-ey details of how Magnify
02:08:59 <mlugg> actually works? (I haven't done that as of yet)
02:09:09 <opqdonut> you might need to compose with runMaybeT or something, but the transformers are just wrappers around types like Maybe (Either e [a])
02:10:15 <absence> opqdonut: that's my point, it doesn't work with transformer stacks. for trivial layers like MaybeT and ExceptT, it's trivial to unwrap them, but not for something like Stream
02:15:37 <opqdonut> which Stream?
02:15:37 <opqdonut> but as I said there's no way to do it in general for transformer stacks
02:15:37 <opqdonut> you might have a better time with some free monad library, commuting functors is easier
02:15:37 <opqdonut> but even then you need instances like (Traversable f, Traversable g) => Traversable (Compose f g)
02:15:37 <opqdonut> since AFAIU Traversable is the necessary condition for commuting functors
02:18:28 <absence> opqdonut: i understand, thanks! (Stream is from the streaming library, just as an example of something that isn't a trivial wrapper)
02:22:27 <opqdonut> absence: this might help https://ro-che.info/articles/2012-01-02-composing-monads
02:22:40 <opqdonut> has some examples of non-commutativity
04:54:02 <zincy_> Interesting. Before monadic IO haskell used a list of IO actions which was basically a free monad.
05:14:48 <mniip> not quite
05:15:05 <mniip> the intent was the free monad
05:15:13 <mniip> but the implementation not really
05:16:39 <arahael> My understanding is that you assume that it's a free monad, and don't look too hard at it nor ask any questions such as "if it were a free monad, how do you add arbitrary actions using FFI?)
05:17:34 <zincy_> arahael: Correct I just looked at it and assumed
05:18:03 <mniip> it used  main :: [IOResponse] -> [IORequest]
05:18:48 <mniip> with the intent of   data IO = End | Act IORequest (IOResponse -> IO)
05:19:03 <zincy_> I am confused about how you could take a request and feed the response in when the responses are the first parameter?
05:19:40 <mniip> laziness
05:20:55 <zincy_> So the index of the elements are what pairs request and responses
05:21:01 <mniip> yeah
05:21:08 <mniip> it's very unsafe
05:21:09 <zincy_> ooh
05:21:35 <zincy_> So you are hoping that the haskell program doesnt try and access the wrong element in responses
05:21:42 <zincy_> Or you get a bottom
05:21:42 <mniip> yup
05:21:56 <mniip> you could wrap this abstraction into a monadic interface if you wanted to
05:22:16 <mniip> the other way around is trickier...
05:26:53 <zincy_> So the intent was a free monad?
05:27:16 <mniip> not really a monad no
05:27:17 <zincy_> How can you have a free monad when you don't have monads in your language
05:37:53 <ski> zincy_ : monads aren't a language feature, per se
05:39:36 <merijn> They're not even a language feature in Haskell (ignoring a bit of optional syntactic sugar_
05:40:03 <opqdonut> well they are specified in the language standard
05:40:15 <opqdonut> but yeah, they could not be
05:42:27 <merijn> opqdonut: The report specifies a whole bunch of library APIs too
05:42:46 <merijn> I would not describe "putStrLn" as being a language feature either
05:43:14 <opqdonut> fair enough
05:46:33 <ski> (and definitely things like `Maybe',`lookup',&c.)
05:46:45 <ski> (er, s//not /)
05:47:39 * mniip . o O (not and definitely...)
05:48:54 <sshine> it would be neat if successfully compiling certain combinations of package versions in various contexts propagated back to Stackage.
05:53:04 <merijn> sshine: That'd go directly against everything stackage is attempting >.>
05:54:44 <merijn> https://i.imgflip.com/3wq6ax.jpg >.>
06:01:22 <zincy_> Ah ok, yeah I stand corrected.
06:11:45 <mniip> thonks? https://gist.github.com/mniip/1c49b715cd00be865e54f669883e2b92
06:50:35 <dmwit> lmao
07:03:13 <Lycurgus>  is there a working hs debugger these days that allows you to single step thru code?
07:04:54 <Lycurgus> iirc leksah did at one point
07:15:52 <oats> doesn't ghci let you do that?
07:16:00 <oats> could be wrong, I haven't used it :P
07:19:06 <Lycurgus> confirmed!
07:19:53 <Lycurgus> it would have been what leksah actually used and the others too such as hie in vs code
07:21:13 <Uniaika> ghci has a step debugger
07:21:15 <Uniaika> indeed
08:01:59 <infandum> How do I specify a package version for `stack script`? It's telling me to add it to `/home/user/.stack/config.yaml`, but usually I would do `/home/user/.stack/global-project/stack.yaml` but it doesn't change anything.
08:03:18 <lyxia> infandum: have you tried the --extra-dep option
08:05:04 <saurabhkukade> I am having this issue.. someone knows why? "    Module ‘Control.Monad.Writer’ does not export ‘writerT’
08:05:05 <saurabhkukade>   |
08:05:05 <saurabhkukade> 5 | import           Control.Monad.Writer (tell, writerT)
08:05:05 <saurabhkukade>   |  "
08:05:15 <infandum> lyxia: That worked... what is the difference between --package and --extra-dep?
08:06:01 <saurabhkukade> from where should I import 'writerT'?
08:07:19 <MarcelineVQ> saurabhkukade: https://hoogle.haskell.org/?hoogle=writerT
08:10:17 <lyxia> infandum: the snapshot determines what version of package you get. --package looks up the package in the snapshot so you don't get to choose the version. --extra-dep adds a package version to a snapshot (or overrides it if the package is already there).
08:11:03 <MarcelineVQ> saurabhkukade: are you sure you want writerT and not WriterT?
08:12:31 <saurabhkukade> MarcelineVQ: sorry, I wanted WriterT. Got it. Thanks for the link.
08:13:55 <infandum> lyxia: Makes sense. I wonder why it's not just "if there's no version appended to the package then use the resolver version"
08:30:54 <jchia_> Question about streaming package: Is there a straightforward way to demultiplex "Stream (Of (Int, a)) m ()" into "[Stream (Of a) m ()]", where an item with Int value k is put into the Stream at the kth position in the list?
08:31:33 <reactormonk> Should I run criterion with or without -threaded?
08:31:58 <dmwit> There is almost certainly no way to demultiplex like that.
08:32:12 <dmwit> For roughly the same reason you can't go `Monad m => m [Foo] -> [m Foo]`.
08:32:24 <dmwit> Then again I've never heard of the streaming package before today, so take my comment with a grain of salt.
08:32:29 <solonarv> well, there is, if you don't care about efficiency too much
08:34:27 <solonarv> demultiplex stream = [ Streaming.mapMaybe (\(i, x) -> x <$ guard (i == n)) | n <- [0..] ]
08:34:50 <phadej> that would duplicate effects
08:34:51 <solonarv> but this is not very efficient and there is probable some sort-of-unsafe duplication of the effects, too
08:34:55 <phadej> +1
08:38:32 <jchia_> solonarv: Not efficient because it's O(nm) where n is the number of items and m is the fanout, correct?
08:38:33 <Cale> Hmm, there really *should* be though.
08:39:36 <maralorn> In haddocks I can use 'myFunction' to hyperlink an identifier. I can use > myFunction param1 param2 as a code example. How can I hyperlink identifiers in my code examples?
08:40:02 <solonarv> I didn't bother figuring out asymptotics because this is just terrible in so many ways
08:40:15 <Cale> I guess that's a difference between Stream and Event :)
08:40:18 <solonarv> so you should not do it no matter exactly how bad the asymptotics are
08:42:00 <jchia_> solonarv: You're going through the input stream once for each output stream, correct? Your use of guard is new to me. Is it a common idiom?
08:43:55 <jchia_> The guard (i == n) evaluates to "Nothing" or "Just ()". Combined with x using (<$) you get Nothing or Just x. I see how it works. Just wondering if this pattern pops up a lot.
08:45:40 <Nilgeist> Why can't I create an array as "a=listArray (1,5) ([1..5] :: [Int])"? As soon as I switch to a concrete type, ghci spits our a mistifying error "Non type-variable argument in the constraint
08:48:28 <solonarv> jchia_: occasionally. in this case it's the same as 'if i==n then Just x else Nothing'
08:52:31 <lyxia> Nilgeist: because the type of the array is not determined, so a gets inferred with a polymorphic type, and there are some odd constraints about polymorphism in Haskell 2010 that you need extensions to lift.
08:55:20 <jchia_> What approach can I use to demultiplex a Stream (Of (Int, a)) m () efficiently?
08:55:37 <freeman42x[m]> is the way I wrote this part good? or can it be done better? https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/src/OS/Linux/NixOS.hs#L86
08:55:48 <jchia_> ...demultiple it into [Stream (Of a) m ()]
08:57:34 <lyxia> freeman42x[m]: with a bit of fusion,   mapM_ (configureAndInstall . uncurry ExtensionInfo)
08:58:54 <frdg> is it correct to say that all we really have is numbers like Ints, Floats, Doubles, and we just abstract over this. They say that Haskell is an extremely abstract language, does that mean that we have many ways to abstract over the fact that we just have numbers? 
09:00:36 <dmwit> maralorn: @'myFunction' param1 param2@
09:01:15 <maralorn> frdg: I think since that is not totally well-defined it’s probably correct and wrong.
09:01:51 <maralorn> dmwit: Yeah, thank you figured that out by looking at a working example.
09:02:00 <dmwit> Nilgeist: Because it doesn't know whether you want Array or UArray or what. Say `listArray (1,5) [1..5] :: Array Int Int` instead.
09:02:03 <freeman42x[m]> lyxia: is that stream fusion? I know nothing of how it works or how it is better unfortunately
09:02:26 <maralorn> frdg: Two points: First Many datatypes operato on Char or Word8. You can count them as numbers but then you are nearly at the point where every language is like that since they all abstract over bits and bits are numbers.
09:03:50 <Nilgeist> dmwit: That works as expected! Though I'm trying to construct an IArray with listArray
09:03:53 <maralorn> frdg: Second look at data Bool = True | False. There is no number at all there. (other than the runtime representation in memory which will of course be a number.)
09:04:04 <dmwit> Nilgeist: IArray is not a type, but a class.
09:04:15 <dmwit> So you can't construct one. You can only construct instances of the class.
09:04:28 <dmwit> You can make `a` be polymorphic over all instances by giving it an explicit type signature, as in
09:04:34 <frdg> maralorn: I see. Sorry to use you as google here but why is Haskell considered to be very abstract?
09:05:08 <dmwit> a :: IArray arr Int => arr Int Int; a = listArray (1,5) [1..5]
09:05:16 <dmwit> You will need to turn on a language extension. GHC will tell you which one.
09:05:29 <Nilgeist> dmwit: Ah, yes. I didn't see that in haskage
09:06:34 <Nilgeist> dmwit: huh, that's some tricky stuff
09:06:40 <maralorn> frdg: phew. abstract is a complicated word. I think it is because you can write a lot of code which is usable for a lot of different contexts and because when you write code you normally don‘t think that much about low level things like memory management or concrete representations.
09:07:43 <frdg> maralorn: ok cool. Thank you!
09:10:12 <dmwit> maralorn: Those were deft replies. Nice work!
09:10:14 <freeman42x[m]>  lyxia wait, there is nothing special about `mapM_ (configureAndInstall . uncurry ExtensionInfo)` over `mapM_ configureAndInstall $ uncurry ExtensionInfo` why would it be better? it's actually more verbose
09:10:41 <dmwit> freeman42x[m]: It is better because it does only one pass over the list. You dropped a `<$>` in your second code sample that does a second pass.
09:11:23 <dmwit> (Though I expect these days the compiler is smart enough to do that rewrite for you anyway if you have the optimization level cranked up to 11.)
09:12:16 <maralorn> dmwit: Thanks!
09:17:26 <sm[m]> indeed, "abstract" has different meanings and gets used in both positive and pejorative sense wrt Haskell
09:22:52 <solonarv> dmwit: but optimization level only goes up to 2 ;)
09:32:09 <dmwit> solonarv: This compiler, this one right here... a Glorious Haskell Compiler, rare vintage 8.6.4.3, only three copies released. Don't touch it, don't even look at it!
09:35:51 <MarcelineVQ> "It's a deal, it's a steal, it's the sale of the fucking century!   In fact, fuck it Nick, I think I'll keep it!"
09:37:02 <freeman42x[m]> dmwit: thank you for clarification, yeah, I will leave that to the compiler, and it's not at all a performance issue
09:49:43 <maralorn> simonmic: Oh, yeah. I totally forget that people also use abstract pejorative as in for "hard to understand".
09:53:57 <dmwit> Are there any compilers that parsed their optimization level as a double?
09:54:04 <dmwit> -O1.8
09:56:01 <Lycurgus> if likely because it's the default non integer type
09:56:06 <Lycurgus> *if so
09:57:20 <Lycurgus> also "1.8" could be a string with members
10:01:38 <maralorn> I like the idea of configuring the optimiser by time. Spend 1.8s optimizing and don‘t start any new optimization steps after that.
10:04:20 <maralorn> (I wonder how awesome the maps would be on a modern system.^^)
10:16:37 <Will34> Hi. I've come because I've got stuck trying to install Haskell/ghcup (not sure which) for OS X on https://www.haskell.org/ghcup/. I do `$ curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh` as suggested, and the error I get is `[ Info  ] Installing GHC (this may take a while)ghcup:
10:16:37 <Will34> /var/folders/ks/zvlbpmlx427bjjc0ptwmb_s80000gn/T/ghcup-dQoRz8/hc-8.8.3: getSymbolicLinkStatus: does not exist (No such file or directory)"ghcup --cache install" failed!`
10:17:27 <Will34> Web searching for "getSymbolicLinkStatus install" isn't enlightening.
10:21:14 <sm[m]> maerwald ^
10:21:47 <maerwald> Will34: hi
10:21:54 <Will34> Hi.
10:22:13 <maerwald> please run: 'ghcup numeric-version'
10:22:29 <maerwald> or: ~/.ghcup/bin/ghcup numeric-version
10:23:28 <Will34> `ghcup: command not found.` I thought the curl command was going to install ghcup for me.
10:23:39 <maerwald> run the second one
10:24:27 <Will34> `[ Warn  ] New GHCup version available: 0.1.3. To upgrade, run 'ghcup upgrade' 0.1.0` I guess 0.1.0.
10:24:58 <maerwald> run: ~/.ghcup/bin/ghcup upgrade
10:25:29 <maerwald> After that you can just rerun the bootstrap script: curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
10:25:56 <Will34> `[ Info  ] verifying digest of: /var/folders/ks/zvlbpmlx427bjjc0ptwmb_s80000gn/T/ghcup-rMs28B/ghcupghcup: ResourceCleanupException {rceOriginalException = Nothing, rceFirstCleanupException = /var/folders/ks/zvlbpmlx427bjjc0ptwmb_s80000gn/T/ghcup-rMs28B/hcup: getSymbolicLinkStatus: does not exist (No such file or directory),
10:25:56 <Will34> rceOtherCleanupExceptions = []}`
10:26:00 <maerwald> Yes, expected
10:26:07 <maerwald> did it install?
10:26:09 <Will34> Okay.
10:26:17 <maerwald> check the version again
10:26:18 <Will34> Yes!
10:26:22 <Will34> Sorry.
10:26:40 <Will34> Thanks.
10:26:52 <maerwald> now just rerun the curl thing
10:30:24 <Will34> I'm re-running it but it's warning me about `New GHCup version available: 0.1.3`. Then I get `[ Info  ] Installing cabalghcup: ResourceCleanupException {rceOriginalException = Nothing, rceFirstCleanupException = /var/folders/ks/zvlbpmlx427bjjc0ptwmb_s80000gn/T/ghcup-kIbUv7/abal.sig: getSymbolicLinkStatus: does not exist (No such file or directory),
10:30:25 <Will34> rceOtherCleanupExceptions = []}"ghcup --cache install-cabal" failed!` Has it worked?
10:31:02 <maerwald> The mirrors are old
10:31:08 <maerwald> Cloudfront or something
10:31:50 <maerwald> hang on a second
10:32:40 <monochrom> Wait ghcup is at 0.1.x already?  It was just 0.0.8 last week.
10:32:48 <Will34> Okay.
10:32:56 <maerwald> Wait :)
10:33:16 <maerwald> It seems the ftp symlinks don't work very well
10:33:22 <monochrom> haha
10:33:52 <monochrom> "ghcup has been rewritten in haskell. Please upgrade again via 'ghcup upgrade'"
10:34:14 <[exa]> wow, 3-stage upgrade
10:34:16 <monochrom> Is that an April 1st joke?  Is that a security breach?
10:34:58 <[exa]> monochrom: apparently not
10:35:03 <[exa]> (a joke)
10:35:28 <[exa]> wow the executable has 21 megabytes
10:36:32 <maerwald> Will34: run curl again
10:36:38 <monochrom> maerwald, has ghcup lost its --version flag?
10:36:51 <maerwald> monochrom: yeah, gonna add it later, there is numeric-version
10:37:01 <monochrom> no worries
10:37:17 <maerwald> There was this nasty mac bug and here is the fallout of it :)
10:37:33 <maerwald> apparently ccall "fdopendir" does something on mac
10:37:37 <maerwald> but not what you think
10:37:42 <Will34> ```sh: line 15: ghcup: command not found"ghcup upgrade" failed!```
10:37:55 <monochrom> Does it want to write to ${GHCUP_INSTALL_BASE_PREFIX}/logs ?
10:37:55 <maerwald> derp
10:38:07 <maerwald> Will34: again :)
10:38:26 <monochrom> Actually feature request, could you change it to write to ${GHCUP_INSTALL_BASE_PREFIX}/.ghcup/logs ?
10:38:36 <Will34> Same.
10:38:41 <maerwald> Wait
10:39:08 <monochrom> bascially because I set GHCUP_INSTALL_BASE_PREFIX=/usr/local and I give myself permission for /usr/local/.ghcup but not /usr/local per se
10:39:31 <maerwald> Will34: now :D
10:39:37 <maerwald> monochrom: what version?
10:39:51 <monochrom> The 21MB version
10:40:00 <maerwald> ghcup numeric-version 
10:40:17 <monochrom> Sorry I don't know yet because even "ghcup numeric-version" gives "ghcup: /usr/local/logs: createDirectory: permission denied (Permission denied)" as explained
10:40:27 <maerwald> so you're running 0.1.0
10:40:37 <monochrom> Oh, upgrade again?
10:40:42 <maerwald> yes, manually
10:40:51 <maerwald> you must be the only one using GHCUP_INSTALL_BASE_PREFIX
10:40:54 <maerwald> it's undocumented even
10:41:00 <maerwald> there was a small bug I fixed today
10:41:09 <monochrom> OK I can give myself permission to /usr/local/logs temporarily.
10:41:14 <maerwald> noo
10:41:23 <[exa]> btw what was the reason for porting to haskell?
10:41:39 <maerwald> [exa]: sick of platform incompatibilities... but then it turns out I have the same now
10:41:46 <monochrom> Oh it's just "sudo mkdir /usr/local/logs" and "sudo chown myself /usr/local/logs" it's no biggie
10:41:55 <maerwald> monochrom: no
10:41:56 <[exa]> maerwald: rewrite in autotools? (I mean it)
10:42:02 <monochrom> OK! Manually then.
10:42:26 <sm[m]> maerwald: not to pile on :) but doesn't that defeat the purpose a bit (you want ghc ? oh you need haskell..)
10:42:28 <maerwald> monochrom: https://downloads.haskell.org/ghcup/0.1.3/x86_64-linux-ghcup-0.1.3
10:42:42 <maerwald> sm[m]: no, on linux this is a static executable
10:42:46 <maerwald> but bc mac is sh... 
10:42:48 <sm[m]> oh the plan is to provide binaries for everybody
10:43:13 <maerwald> Will34: did it work?
10:43:19 <Will34> It said `Installation done!` but now I'm doing `ghc --version` and it's still 8.0.1.
10:43:30 <monochrom> Thanks maerwald
10:43:32 <maerwald> Will34: source ~/.ghcup/env
10:44:03 <maerwald> and then add that line to your ~/.bashrc or ~/.zshrc whatever you're using
10:44:46 <Will34> I asked the tool to do something like that (at the end). Maybe this is something else though.
10:45:03 <maerwald> Start a new shell then
10:45:03 <monochrom> \∩/ "list" doesn't need "-t all" anymore
10:45:04 <Will34> `source ~/.ghcup/env` doesn't return anything
10:45:17 <maerwald> Will34: not run ghc
10:45:17 <Will34> Started a new shell.
10:45:20 <maerwald> *now
10:45:31 <monochrom> Hey maerwald does ghcup now support windows because it is not a POSIX shell script anyway >:)
10:45:49 <maerwald> monochrom: I'm heavily relying on 'unix' package and other stuff
10:45:55 <monochrom> Ah OK
10:46:07 <maerwald> I wouldn't even know how to do windows support
10:46:13 <maerwald> there's some more stuff involved
10:46:25 <Will34> Now ghc is version 8.8.3.
10:46:29 <maerwald> Will34: looks ok
10:46:37 <Will34> Thank you.
10:47:04 <sm[m]> maerwald: windows will be easier than mac probably. Use unix-compat not unix, and build with CI 
10:47:47 <maerwald> sm[m]: symlinks are all different, filepaths are different, there's stuff with msys2 etc
10:48:15 <monochrom> Give maerwald time!
10:48:20 <maerwald> lolo
10:48:32 <sm[m]> yes you're probably right. I'm spoiled by using stack
10:48:41 <maerwald> I mean... the problem with mac was... I don't even have a VM
10:48:44 <maerwald> because it's ILLEGAL
10:48:45 <monochrom> But good suggestion about unix-compat etc.
10:48:48 <maerwald> So how to test anything
10:48:50 <sm[m]> which already went through all this
10:48:59 <monochrom> Be an outlaw.
10:49:23 <maerwald> And apparently, mac is the most weird thing
10:49:24 <monochrom> You're probably already breaking don't-export-crypto laws anyway.
10:49:29 <maerwald> oops
10:50:22 <maerwald> sm[m]: I'm using ByteString based filepaths =) so unless someone implement abstract-filepath-proposal... even unix-compat won't be enough
10:50:47 <maerwald> And I'm neither using directory, nor filepath libs
10:51:08 <sm[m]> well.. if you want to be cross platform.. 
10:51:10 <monochrom> Oh, right, GHCUP_INSTALL_BASE_PREFIX.  It is "kind of undocumented" but I found it back when shell script, and it was near the top, it's totally like intended to be used.
10:51:24 <monochrom> At least intended to be read.
10:51:50 <maerwald> monochrom: yeah, and bc I never used it myself, a bug slipped through that I found when finally doing gitlab CI
10:52:15 <maerwald> sm[m]: I believe cross-platform would involve using Win32 package and doing it low-level :P
10:52:24 <monochrom> I am special.  I think I'm really the only user who uses it.
10:52:53 <maerwald> E.g. https://hackage.haskell.org/package/Win32-2.8.5.0/docs/System-Win32-SymbolicLink.html
10:53:09 <maerwald> I trust this more than the symbolic link stuff in 'directory', which abstracts over two completely independent platforms
10:53:19 <sm[m]> how does stack do it ?
10:54:42 <sm[m]> I do see Win32 in its deps
10:54:45 <maerwald> No idea. Snoyman knows about those problems, he is one of the authors of the abstract filepath proposal.
10:54:50 <monochrom> My angle is economics.  stack has more devs.  cabal has more devs.  Firefox has way more devs.  They all have time to do it.
10:55:57 <maerwald> sm[m]: I would trust snoyman to do the right thing there and be it just bc he has so many users. But he's also very pragmatic.
10:56:15 <sm[m]> yep
10:56:19 <monochrom> A long time ago I read an article on how mozilla built a whole layer of abstraction so high level code does not need to know what OS it is at all, not even what GUI (X vs windows vs old mac, this was before mac os x)
10:57:08 <monochrom> It can always be done, the question is how to play your zero-sum game.
10:57:13 <koala_man> haha, I remember that. They said that Mozilla was an application platform and the browser was just an example application
10:57:22 <monochrom> :)
10:57:23 <koala_man> everyone laughed. now we have Electron
10:57:25 <sm[m]> stack must have many hands in it by now of course, but I expect he set the tone
10:57:36 <koala_man> they were just ahead of their time
11:00:00 <monochrom> I was really impressed.  I laughed but in the sense of "omg you actually pulled this off, this thing which people say can only happen on paper".  I admire it, it's dream come true.
11:00:41 <monochrom> It's really a lot of hard work and hard choices.
11:01:44 <maerwald> And in the end ppl tell you your work sucks :D
11:02:48 <maerwald> also, the mac bug for the curious https://github.com/haskell/unix/pull/110#issuecomment-613716712
11:02:57 <maerwald> it might have slipped into the unix package even ;)
11:03:35 <maerwald> tldr: never use ccall (unless for your own symbols)
11:05:25 <maerwald> no such thing happens on linux, freebsd or any other sane platform
11:20:24 <monochrom> I think some years ago I learned about that.  Some C bindings of syscalls are macros that expand to syscall(42, x, y, z).  (I'm making up "42", but it's a hardcoded number, index into kernal table of syscalls.)
11:21:16 <maerwald> monochrom: yeah and the scary thing is... the direct syscall to fdopendir *does* something and *kinda* works, but only kinda
11:21:27 <monochrom> Many crimes against humanity are committed for "high performance".
11:21:30 <maerwald> (it truncates the first char of d_name)
11:21:50 <maerwald> so you get somewhere into semi-random memory
11:21:58 <monochrom> err wait, what? what good is dropping the first char?
11:21:58 <maerwald> and then pull out struct fields
11:22:29 <maerwald> We don't know exactly what's happening, but it's reliable
11:23:05 <maerwald> The guy with the error above: /var/folders/ks/zvlbpmlx427bjjc0ptwmb_s80000gn/T/ghcup-kIbUv7/abal.sig: getSymbolicLinkStatus: does not exist (No such file or directory)
11:23:10 <maerwald> it says "abal.sig"
11:23:15 <maerwald> which should be "cabal.sig" :)
11:23:22 <monochrom> oh, haha
11:23:39 <maerwald> Thank god I wrote the code with absolute filepaths enforced on type level :)
11:23:43 <maerwald> and not relative paths
11:23:44 <monochrom> Yes this is a complete mystery.
11:24:21 <monochrom> btw why switched to haskell?
11:24:31 <maerwald> It's this nice language I heard about
11:24:40 <monochrom> haha
11:24:56 <maerwald> actually... the primary reason was mac users!
11:25:01 <maerwald> And now see how that played out
11:25:07 <maerwald> (e.g. mktemp works different on mac)
11:25:27 <maerwald> Can't write 20 LOC posix shell code without breaking mac
11:25:59 <monochrom> I was thinking shell scripting would be the least brittle against linux-vs-mac.  I don't mean perfect but, like, least of the two evils.
11:26:16 <maerwald> Well, the script is now ~2k LOC
11:26:23 <maerwald> and I don't want to touch it anymore
11:26:31 <maerwald> bc I can't reason about anything
11:26:42 <maerwald> Despite the extensive documentation
11:27:06 <maerwald> Want to add some features like building from git head maybe etc
11:27:13 <maerwald> alpha/rc release support
11:27:15 <monochrom> OK.  Well, growing pains.  Gain some, lose some.  etc etc truism wise words.
11:27:37 <maerwald> Also: it can be used as a library now
11:27:54 <maerwald> There was at least one package that invoked ghcup from haskell
11:28:45 <maerwald> https://github.com/vabal/vabal/blob/07aef09a3fc8ef2fd282f3027e90aec93ecf73d7/vabal/src/GhcupProgram.hs#L98
11:29:27 <monochrom> What I know --- a condition upon which I definitely switch from shell to haskell --- is that haskell's IO exception system, say what you may about its warts, is still infinitely better than shell's "trap" 1970s mindset.  on-error-goto die die die.
11:29:47 <maerwald> Oh, I used open variants for fun for exceptions :P
11:29:51 <maerwald> Not sure that was a good idea
11:30:39 <monochrom> Tell you what.  Haskell uses lazy evaluation for the same reason.  Lazy evaluation looks fun, let's follow it to its logical conclusion and see what happens.
11:30:45 <maerwald> https://git.io/JfvDP
11:31:27 <maerwald> It is actually kinda neat... I can run the Excepts from Main and then decide what is an "error", what's a warning etc
11:31:37 <maerwald> Ofc functions can still crash with IO exceptions
11:31:59 <monochrom> Neat.
11:32:21 <monochrom> I just hate type-level list for this, because list is totally the wrong model.  It's a set.
11:32:45 <maerwald> monochrom: there's a problem with that too... you never know whether you have too much types in your list
11:32:52 <monochrom> 90% of every type-level list library is about "x `elem` xs"
11:33:03 <monochrom> and "delete x xs"
11:33:04 <maerwald> If it were constraints, ghc could tell you that you have unnecessary constraints
11:33:15 <maerwald> with this approach, it can't
11:33:22 <maerwald> It's quite annoying actually
11:33:33 <maerwald> It can only tell you you missed a type
11:34:01 <t7> monochrom: do you want a type level btree?
11:34:03 <maerwald> to fix that, we would need the local-do proposal
11:34:06 <monochrom> Oleg advocated or demoed using constraints once.
11:34:29 <maerwald> https://github.com/haskus/packages/issues/32#issuecomment-596424753
11:35:07 <maerwald> Alternative from matt: https://hackage.haskell.org/package/plucky
11:36:04 <maerwald> That uses constraints... but as soon as you use the type familiy for the shorter version, GHC can't infer unnecessary constraints anymore :)
11:36:29 <maerwald> I'm not sure whether this is a bug
11:36:59 <maerwald> Must be related to type checking phases and whatnot
11:38:58 <maerwald> and then there is oops: https://github.com/i-am-tom/oops
11:39:05 <maerwald> But he hasn't cut a release yet
11:39:46 <maerwald> main :: ( e `CouldBe` ExceptionA , e `CouldBe` ExceptionB) => String -> Either e ()
11:40:34 <monochrom> Yeah, that would be very much along the line of Oleg's approach.
11:41:31 <monochrom> In Oleg's time, there was no type families.  And Oleg did involve some OverlappingInstances or UndecidableInstances or both, I forgot.
11:42:06 <maerwald> What is he doing these days anyway?
11:42:15 <monochrom> I don't know.
11:42:24 <maerwald> The last paper was the e-e thing?
11:42:31 <monochrom> I wouldn't be surprised if it's retirement time.
11:43:10 <nshepperd> retirement is when you finally get time to properly work on your haskell papers
11:43:16 <maerwald> :D
11:46:16 <maerwald> Also, I think the type-level list approach requires way more lifting
11:53:15 <unsupervised> Hi, I'm getting back into haskell. Is there a good ressource for advanced haskell topics, like these kind of topics? http://www.haskellforall.com/2014/03/introductions-to-advanced-haskell-topics.html
11:53:31 <unsupervised> there's also stuff here but it's incomplete and quality varies a lot https://en.wikibooks.org/wiki/Haskell
11:55:03 <Cale> I'd say just learn the extensions as you need them
11:55:17 <maerwald> unsupervised: https://github.com/i-am-tom/haskell-exercises
11:55:36 <maerwald> https://github.com/data61/lets-lens
11:55:46 <Cale> There are good reasons for them, but as you're starting out, it's best not to get distracted by stuff that really should only get used a small fraction of the time
11:57:11 * monochrom frowns.  MPTC and fundep could be much earlier, close to GADTs.  Even RankNTypes could be earlier.  What's with this DataKinds craze early on?  Haskell is not a dependent typing language, why perpetuat the lie that it is?
11:57:31 <unsupervised> how about arrows, kleisli, FRP, optimization, etc?
11:57:34 <maerwald> I find DataKinds hard... the design space is just too big
11:57:59 <Cale> I'd say we almost have a cultural problem that's growing in that regard -- people write about fancy stuff because it's new, and then beginners get the impression that using the fancy stuff is just how you do things, when there are much more straightforward approaches most of the time using the basic features of the language.
11:58:06 <monochrom> This is what's wrong with "enthusiastic" teachers.
11:58:29 <monochrom> The teacher is enthusiastic about dependent types so they teach you dependent types first.
11:58:38 <unsupervised> Cale: are you talking about my question?
11:58:43 <Cale> unsupervised: yeah
11:58:55 <unsupervised> I'm not a beginner, I want to dive into more advanced topics
11:58:56 <monochrom> Well my students would be doomed if I taught them my PhD theses first just because I am so excited about it.
11:59:05 <unsupervised> it's hard to find them
11:59:41 <monochrom> Have you done monad transformers?
12:00:03 <maerwald> tagless final, polysemy, extensible-effects
12:00:25 <maerwald> hey, how about Supermonads
12:00:32 <Cale> maerwald: haha
12:00:38 <monochrom> haha
12:01:20 <maerwald> if you like monad transformers, try to grok: https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/
12:01:28 <maerwald> I tried, I forget it a week later.
12:01:45 <monochrom> Actually, have we mentioned lens?
12:01:59 <maerwald> not cool enough, it's now optics
12:02:00 <Cale> I like monad transformers, I understand MonadBaseControl, but I think things of that sort shouldn't be used at all
12:02:24 <lexi-lambda> how can you like monad transformers
12:02:31 <maerwald> Cale: I think I've only ever encountered one instance where I needed something like MonadBaseControl, but then UnliftIO was enough
12:02:35 <Cale> They're fine
12:02:39 <lexi-lambda> no
12:03:03 <Cale> maerwald: I even think UnliftIO isn't a good idea
12:03:17 <monochrom> monadbasecontrol extends monad transformers.  change my mind.
12:03:28 <Cale> I recommend making a class for each higher order function you want to lift, more or less
12:03:55 <Cale> So that you have the opportunity to think about how it interacts with each transformer as you write the instances, and determine if what you're doing makes sense
12:04:13 <lexi-lambda> but that’s such an enormous amount of work, and you still end up with broken semantics
12:04:17 <Cale> It's not really hard at all -- you only implement what instances you need.
12:04:33 <Cale> and I disagree that you end up with broken semantics
12:04:39 <Cale> You end up with the semantics that you implement
12:04:47 <lexi-lambda> ListT and ExceptT don’t compose properly, fundamentally
12:04:57 <Cale> Which ListT?
12:05:01 <lexi-lambda> all of them
12:05:11 <lexi-lambda> including the “fixed” ones
12:05:35 <monochrom> broken semantics is caused by wishfully using monad transformers, not monad transformers.
12:05:43 <Cale> Well, they have different meanings.
12:06:00 <Cale> Monad transformers are a handy mechanism for implementing the monads you would have written by hand
12:06:08 <Cale> If you can't get the monad you wanted, then don't use them
12:06:11 <lexi-lambda> though there is an extremely reasonable semantics to compose nondeterminism and exceptions
12:06:22 <lexi-lambda> but you can’t compose those effects with monad transformers
12:06:26 <monochrom> "wishfully" means: I once had a student who mixed up the empty set and the empty string.  "They are both empty, so they are the same", he said.
12:06:57 <zincy_> Cale: Yes exactly. This is a real problem. People would rather just use fancy things for the sake of it.
12:07:26 <monochrom> All wrong uses of monad transformers are of the same nature.  Reasoning by presence of keywords.  "I need list-like behaviour and state-like behaviour.  Oh look, here be a ListT and a StateT.  Google hits."
12:07:48 <lexi-lambda> is it unreasonable to want compositional computational effects?
12:07:59 <Cale> It's unusual to need it
12:08:01 <maerwald> lexi-lambda: what's the alternative?
12:08:12 <lexi-lambda> algebraic effects
12:08:30 <Cale> You need just enough composition to be able to express the thing you're after, and then you're done.
12:08:41 <monochrom> It is wrong to know only one kind of composition.
12:08:59 <monochrom> and furthermore criminal to call it "the" composition.
12:09:03 <lexi-lambda> Cale: but if I want higher-order control a la LogicT and exceptions then I have to reinvent everything myself? and that’s fine?
12:09:05 <zincy_> <monochrom>: Wow!
12:09:08 <Cale> If you find that you often can't express the monad you wanted to build, then maybe you're working in weird areas, but monad transformers have done the job enough times that I'm reasonably happy with them.
12:09:28 <zincy_> monochrom: That was in reference to the empty string set thing.
12:09:36 <lexi-lambda> if you can do everything you need to do with StateT/ReaderT/ExceptT then monad transformers are fine
12:09:38 <Cale> What I'm not as happy about is the MTL type classes -- those get overused.
12:09:47 <monochrom> Already with Applicative and Alternative you already see two opposite kinds of compositions, <*> and <|>
12:09:49 <lexi-lambda> but I have had many real-world situations where I need something more sophisticated
12:10:06 <zincy_> When would monad-transformers not be enough?
12:10:09 <maerwald> lexi-lambda: so what do you use then?
12:10:13 <monochrom> There is an analogous story for monads, even effect systems.
12:10:29 <Cale> Sometimes people use the MTL classes in lieu of actually implementing the operations that they're interested in, and that's ugly
12:10:54 <lexi-lambda> maerwald: I currently suffer through the pain of writing the composition out by hand, but I have a better solution https://github.com/hasura/eff, it’s just blocked on a GHC proposal
12:11:17 <maerwald> Yes, I've seen the reddit announcement
12:11:32 <maerwald> where isovector basically said he's giving up on polysemy, because semantics are broken/unclear
12:11:47 <lexi-lambda> my semantics is different from what polysemy/fused-effects do
12:11:52 <lexi-lambda> I think those libraries are broken
12:12:32 <lexi-lambda> monochrom: my effects library can compose nondeterminism with arbitrary effects with a straightforward and reasonable semantics; if you want a different semantics that’s fine, but the ability to get a certain semantics for free, predictably, compositionally, clearly has value
12:12:38 <monochrom> zincy_: I don't know whether you've already heard my exploit, which exploits Google-hit reasoning done by some weak students.
12:13:15 <monochrom> No dispute there, lexi-lambda.  I'm saying the same thing of monad transformers.
12:13:28 <lexi-lambda> but monad transformers can’t do what I just described
12:13:31 <zincy_> monochrom: Not heard that one. 
12:14:11 <monochrom> Does yours do everything monad transformers do?
12:14:32 <lexi-lambda> I suppose it depends on what you consider to be “everything monad transformers do”
12:14:41 <lexi-lambda> monad transformers are vast and lawless
12:14:58 <Cale> All the monads with nondeterminism I've ever cared about have been 1) based on [] or 2) based on some continuation-based thing equivalent to [] like Nondet or 3) been hand-implemented parsing monads.
12:15:23 <Cale> I really haven't seen any real world application of ListT
12:15:25 <lexi-lambda> zincy_, Cale: I work on a codebase for a living where we have a lot of parsing-esque problems that are most naturally solved via manipulation of control
12:15:46 <monochrom> In that case you can still write a paper to lay out "whatever the other things monad transformers do, here is why you never want them"
12:15:50 <lexi-lambda> but we also want different computational effects to be available in different contexts
12:16:18 <lexi-lambda> monochrom: the library certainly does all the things I use monad transformers to do, but my point is the question as-stated isn’t really answerable
12:16:50 <zincy_> lexi-lambda: So you need an extensible effects system and monad transformers arent extensible?
12:17:34 <lexi-lambda> zincy_: I don’t need an extensible effects system per se, I just need a way to express a certain form of composition; it does happen that an effect system solves that composition better than monad transformers do
12:17:36 <monochrom> zincy_: I gave them an assignment in which I define the notion of probability monad and have them implement instances and also use such a monad.  If you Google for "probability monad" you'll get the correct hits.  Obviously I don't want students to get the correct hits.  So I renamed mine to "MonadRandom".
12:18:01 <monochrom> I was so proud when a student actually asked "may I import Control.Monad.Random?"  Haha gotcha.
12:18:03 <maerwald> Whenever I dabbled with effects systems, I feel I lost the ability to reason about what my code does. Unless you implemented it yourself, you can't see through the details.
12:18:38 <Cale> monochrom: "You may..."
12:18:41 <lexi-lambda> maerwald: that’s because every other effect system available in Haskell today has an unpredictable semantics, but that’s because they’re semantics is based upon that of monad transformers
12:18:48 <lexi-lambda> mine is not; my semantics is based on delimited control
12:19:03 <lexi-lambda> (*their semantics, rather)
12:19:42 <lexi-lambda> the semantics based on delimited control permits far better local, equational reasoning than the monad transformers model does
12:19:58 <lexi-lambda> which is why I think monad transformers are an inferior abstraction
12:20:42 <maerwald> ok, I'm easy to convince, because I like to try out things, but I get angry easily when I'm disappointed ;)
12:21:23 <lexi-lambda> the difference, fwiw, can sort of be explained this way: the monad transformer model focuses on >>=, but the delimited control model focuses on the effectful operations, i.e. ask/get/put/throw/catch/etc.
12:22:02 <lexi-lambda> with the monad transformer model you have to figure out how to manipulate >>= so that it can support all the behaviors you want, but that is sometimes extremely non-obvious to reason about
12:22:21 <lexi-lambda> with the delimited control model, >>= is fixed and straightforward; all of the reasoning can be done on the effectful operations directly
12:23:15 <maerwald> "eff is a work in progress, and since it requires changes to the GHC RTS, you cannot use it yet on any released version of GHC."
12:23:21 <maerwald> does that still apply?
12:23:24 <lexi-lambda> yes, I have an open GHC proposal
12:23:44 <monochrom> lexi-lambda: Recently I gave an assignment to my students about S -> [(S,a)}. I didn't tell them but it's equal to StateT S [], down to what >>= does.  Recently I brought up another way to do probability monads, the [(Rational, a)] way, and Cale showed me it's equal to WriteT (Product Rational) [], down to what >>= does.  Does your effect system help more for these two examples?
12:24:00 <lexi-lambda> maerwald: the changes to the RTS just permit an efficient implementation; they aren’t fundamental to what the library does
12:24:09 <lexi-lambda> I could implement a slow version of eff without the changes to the RTS
12:24:14 <lexi-lambda> but I care about performance
12:24:46 <lexi-lambda> monochrom: I don’t understand the question
12:24:59 <Cale> I want to see a monad construction mechanism that will beat the performance of monad transformers when all of GHC's optimisations are turned on (because we're going to turn them on anyway)
12:25:30 <monochrom> Then likewise I don't understand what point you're making.
12:25:34 <lexi-lambda> maerwald: the proposal in question, fwiw https://github.com/lexi-lambda/ghc-proposals/blob/delimited-continuation-primops/proposals/0000-delimited-continuation-primops.md
12:25:49 <monochrom> All I get is you're attacking monad transformers.
12:26:44 <lexi-lambda> monochrom: a model of effects based on delimited control follows a particular set of equational laws that are useful for reasoning about your program
12:27:01 <lexi-lambda> for example, if you have an algebraic operation, >>= is guaranteed to distribute over it
12:27:37 <lexi-lambda> so if you have `(e1 <|> e2) >>= k`, and <|> is nondeterminism (which is algebraic), it is guaranteed to be equivalent to `(e1 >>= k) <|> (e2 >>= k)`
12:27:43 <monochrom> Sorry that's high horse.  How do I use this for my S->[(S,a)]?
12:28:01 <lexi-lambda> I do not understand what you mean by “how do I use this”
12:28:16 <monochrom> Do you understand "use"?
12:28:25 <Cale> lexi-lambda: How does monochrom use eff to construct a monad isomorphic to that one
12:28:27 <lexi-lambda> as an English word? what are you asking me?
12:28:36 <lexi-lambda> Cale: monochrom uses the State effect
12:28:42 <monochrom> OK so you understand my question.
12:29:01 <lexi-lambda> well I understood Cale’s reformulation of your question
12:29:19 <nshepperd> it's ineffable
12:29:25 <monochrom> haha
12:30:55 <monochrom> On my exam, I brought up both EitherT E (Writer [Integer]) and WriterT [Integer] (Either E).
12:31:01 <lexi-lambda> monochrom: maybe you don’t care about equational reasoning. fine. but I don’t think anyone expects `m2 = (pure 1 <|> throwError "bang") `catchError` \_ -> pure 2` to throw an exception
12:31:23 <lexi-lambda> that semantics is nonsense, but monad transformers—ones perceived as “correct”—implement that semantics
12:31:27 <monochrom> I care about equational reasoning.
12:31:54 <lexi-lambda> eff makes that kind of nonsensical semantics inexpressible
12:31:57 <lexi-lambda> that is useful
12:32:13 <lexi-lambda> it gives you the ability to compose effects together and predict how they will behave without needing to understand their implementations
12:33:25 <lexi-lambda> but eff is fast (on par with mtl in microbenchmarks), and it can express operators like catch or listen that purely algebraic systems struggle to
12:34:03 <zincy_> monochrom: :D
12:34:14 <Cale> lexi-lambda: Which monad does it throw an uncaught exception in?
12:34:54 <Cale> Actually, I think I'd usually expect the catchError to be redundant
12:34:59 <lexi-lambda> some combination of (“fixed”) ListT over ExceptT, I forget which order off the top of my head (which is in fact indicative of the problem)
12:35:24 <Cale> ah, ListT again
12:35:29 <Cale> who cares about ListT?
12:35:47 <lexi-lambda> streaming libraries, for one
12:35:50 <monochrom> I do. Both versions.
12:36:01 <lexi-lambda> but okay, suppose you don’t care about ListT, do you care about backtracking parsers?
12:36:06 <lexi-lambda> same problems
12:36:15 <Cale> I do care about backtracking parsers
12:36:28 <Cale> But those are usually more like StateT over something like [] itself
12:36:33 <lexi-lambda> ListT basically is a kind of backtracking
12:36:47 <Cale> The backtracking isn't something you put in as a transformer
12:37:01 <lexi-lambda> ParsecT begs to differ
12:37:07 <monochrom> Yeah, on second thought, maybe barely.
12:37:11 <Cale> I don't care about ParsecT either ;)
12:37:20 <monochrom> LogicT I would care.
12:37:32 <lexi-lambda> LogicT has the same problems; eff handles it better
12:37:39 <yushyin> i hope the best for you to get this proposal accepted because I would really like to play a bit around with eff
12:37:53 <monochrom> ParsecT yeah but not very often.
12:37:54 <lexi-lambda> Cale: okay, fine, but eff handles your use cases fine and it handles ListT/ParsecT/LogicT better for the people who do care about it
12:37:55 <nshepperd> i didn't think ParsecT supported catchError
12:38:06 <Cale> I also haven't ever seen a use for LogicT -- the underlying nondeterminism monad, I've used as a version of list that had better performance in one case.
12:38:30 <monochrom> ParsercT supports <|> and try.  Close enough.
12:38:47 <lexi-lambda> Cale: c’mon, just because you have not personally encountered a use case for it doesn’t mean it’s not useful
12:39:10 <monochrom> lexi-lambda, I thought we were saying the same thing to you.
12:39:12 <lexi-lambda> imo a lot of people avoid stuff like LogicT precisely because it’s so anti-compositional in the context of monad transformers
12:39:25 <monochrom> I don't mean we're right, to be sure.
12:39:40 <nshepperd> i don't expect ParsecT's <|> to catch exceptions
12:39:45 <lexi-lambda> monochrom: what? how? eff supports every use case I know about that monad transformers are used for
12:40:08 <lexi-lambda> nshepperd: ParsecT provides a MonadError instance
12:41:06 <monochrom> nshepperd: I see, do you mean "ParsecT M" supporting catching M's exceptions?
12:41:23 <monochrom> I was thinking ParsecT's own parse errors.
12:41:35 <zincy_> Excuse my naivety. But I am trying to get my terminology right so I can follow this. By effect we mean any computation which can affects an environment. And since all monads are a way of sequencing effects. Monad transformers are a way of "composing" effects (although doesn't feel like real composition to me). A system for composing effects is an effects system..
12:41:58 <zincy_> Am I on the right page here?
12:42:18 <lexi-lambda> the term “effect system” does not have a precise definition, but it is often used as an abbreviation for either “algebraic effect system” or “type-and-effect system”
12:43:03 <zincy_> Ok so the general notion of keeping track of stacked effect groupings in the types.
12:43:13 <monochrom> OK where was I?  Why was all this started?
12:43:27 <lexi-lambda> someone said they liked monad transformers
12:43:54 <nshepperd> monochrom: yeah
12:43:54 <Cale> I did
12:44:12 <maerwald> lexi-lambda: do you have a timeline for your proposal etc?
12:44:30 <maerwald> Or a way how to patch GHC to use this
12:44:40 <Cale> I still think monad transformers are essentially fine for getting at most of the monads I've actually cared about constructing in real applications.
12:44:42 <monochrom> OK, I see, enthusiasm about one's own monumental work is why/how all this started.
12:44:59 <monochrom> So, may I tell you about my PhD thesis?  It's awesome.
12:45:15 <maerwald> It was ontopic though :)
12:45:25 <monochrom> And meanwhile let me bash and trash Wadler's earlier approach.
12:45:50 <lexi-lambda> maerwald: SPJ suggested I contact Daan Leijen, and I did, and he told me he had already read my proposal and planned to respond, but then I never heard back and haven’t felt like badgering him with a followup given current events
12:46:06 <monochrom> Mine is about running time of lazy evaluation so it's more than on-topic, it's eagerly sought after.
12:46:08 <lexi-lambda> but I probably should at this point now that it’s been a little while
12:46:28 <lexi-lambda> monochrom: I don’t think Wadler invented monad transformers
12:46:48 <lexi-lambda> (then again, he didn’t invent monads, either)
12:46:52 <monochrom> Actually I think I get to say that Wadler's approah doesn't compose, too. >:)
12:47:01 <maerwald> lexi-lambda: but do you have the GHC patches?
12:47:06 <monochrom> No, about timing of lazy evaluation.
12:47:15 <lexi-lambda> maerwald: yes, 90% done
12:47:31 <lexi-lambda> I need to clean up some edge cases around async exceptions for the other 10%
12:47:39 <maerwald> ghcup can compile GHC and apply patches now :P
12:47:43 <monochrom> Hell, most approaches are non-compositional, global analyses.  Wadler's is compositional in theory but too hard to use.
12:47:46 <lexi-lambda> the eff CI runs against my patched GHC
12:48:03 <lexi-lambda> so it is certainly working and did before I wrote the proposal
12:48:04 <nshepperd> your catchError expression seems to work fine with either combination of ExceptT and ParsecT
12:49:11 <Cale> (I also couldn't figure out which monad lexi was referring to with that catchError thing)
12:49:20 <maerwald> It went all too fast
12:49:23 <lexi-lambda> nshepperd: I think ParsecT does weird things on a distinct but similar expression
12:49:27 <monochrom> maerwald: Wait, what?  What does that even mean?!
12:49:39 <maerwald> monochrom: what?
12:50:00 <monochrom> Why does ghcup compile GHC and apply patches?
12:50:03 <lexi-lambda> Cale: I’ve tested it with both ListT from the list-t package and ListT from pipes
12:50:23 <maerwald> monochrom: ghcup compile ghc --patchdir <some-dir>
12:50:25 <monochrom> Sorry I'm just in disbelief, also not understanding the use case.
12:50:27 <lexi-lambda> IIRC the ListT from list-t is broken more deeply, but that is not fundamental, it’s just a mistake (albeit an easy one to make)
12:50:42 <lexi-lambda> the ListT from pipes is broken only in the fundamental way
12:50:50 <monochrom> Hrm, neat.
12:50:59 <maerwald> monochrom: it was actually in the shell script too, but hidden and less polished
12:51:10 <monochrom> Ah.
12:52:06 <maerwald> The problem with such a feature is that ppl will want "resume failed compilation" at some point
12:52:17 <monochrom> "It went all too fast" is right :)
12:53:02 <lexi-lambda> oh ghcup isn’t a shell script now? thank god; I might actually start using it now
12:53:10 <monochrom> Next week ghcup will have a CI daemon for rebuilding GHC from updated source.
12:53:43 <maerwald> lexi-lambda: heh, yes... I rewrote it believing this will solve cross-platform problems... and then I hit broken fdopendir syscall on mac
12:53:47 <monochrom> Next month ghcup.com will exist and you can create free accounts there.
12:54:28 <maerwald> Yeah, business booming
12:54:36 <monochrom> Yeah, traded one portability for another.
12:54:58 <monochrom> Unforeseen to be sure. Can't be helped.
12:55:19 <maerwald> What do you do with platforms you cannot legally test for free...
12:55:21 <maerwald> I mean
12:55:26 <monochrom> Oh hey since it has a library now...  Will there be "cabal install ghcup"?
12:55:47 <maerwald> I haven't uploaded to hackage yet, am still thinking about a few things
12:56:02 <monochrom> OK no worries.
12:56:16 <monochrom> Also how about self-reference: ghcup compile ghcup hehehe
12:56:48 <monochrom> yo dawg I heard you love compiling so I suggest self-compiling while you're compiling.
12:57:02 <maerwald> one thing is... by default I use http-io-streams, which has a brotli flag enabled by default, which pulls in some weirdo library
12:57:16 <maerwald> so in cabal.project I turn that nonsense off
12:57:33 <monochrom> What does that flag do?
12:57:36 <maerwald> but when you build from hackage, I'm not sure
12:57:47 <monochrom> Oh, right, that's tough.
12:57:55 <maerwald> Build with support for Brotli (RFC7932) compression algorithm for HTTP compression.
12:58:17 <monochrom> fancy
12:58:19 <maerwald> And default enabled, which is odd
12:58:54 <ja> what is the question regarding those two types? which one is easier to use?
12:59:12 <ja> monochrom: i meant regarding your EitherT
12:59:31 <ja> > 19:30 <.. monochrom> On my exam, I brought up both EitherT E (Writer [Integer]) and WriterT [Integer] (Either E).
12:59:34 <lambdabot>  <hint>:1:32: error: parse error on input ‘,’
13:02:09 <Cale> lexi-lambda: I don't understand what test you did, but that doesn't throw an exception with pipes' ListT for me
13:02:28 <monochrom> ja, suppose they are the two candidates for a semantic model for a toy expression language that has errors/exceptions and an output command (outputs an integer each time).  Which one best fits our usual expectations of how this language behave?
13:02:35 <Cale> (at least, one which isn't caught)
13:03:08 <maerwald> ExceptT on the outside
13:03:11 <maerwald> My gut feeling
13:03:32 <monochrom> The answer is basically based on this consideration: you have a program that says, "I output 5, then I run into a divide-by-zero error let's say, so abort".  Do you lose the effect of outputing 5?
13:03:40 <freeman42x[m]> how could I do a reload and run last command inside GHCI? is there any GHCI command that runs last command?
13:04:12 <maerwald> freeman42x[m]: yes
13:04:15 <maerwald> check the documentation
13:04:58 <maerwald> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html
13:05:10 <monochrom> My students don't see the monad transformer versions.  I wrote them "Either E (a, [Integer])" and "(Either E a, [Integer])"
13:05:50 <ja> monochrom: that would mean mearwald is wrong. if the EitherT is on the outside, you don't get the Writer in case of error
13:06:36 <maerwald> freeman42x[m]: : and :def
13:06:45 <Cale> monochrom: In my experience, it's important to have both options available, so it's good to show that distinction :)
13:06:49 <ja> *maerwald sorry
13:07:16 <ja> aaah so it's a trick question :P two right answers :P
13:08:15 <Cale> It's a good question whether both are expressible in these effects systems
13:08:21 <freeman42x[m]> maerwald:  I don't get your reply. could you put it in quotes?
13:08:36 <maerwald> freeman42x[m]: "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html"
13:09:15 <ja> don't know if i am supposed to be laughing at this quotation :P
13:09:26 <maerwald> :P
13:09:51 <lexi-lambda> Cale: I realized I got my example slightly incorrect, the broken program is (throwError "bang" <|> pure 2) `catchError` \_ -> pure 1
13:09:51 <lexi-lambda> with ListT from pipes, ListT over Either returns Right [1], but it should return Right [1, 2]
13:09:51 <lexi-lambda> there are more sophisticated ways you can trigger the breakage but that’s probably the simplest example
13:09:52 <lexi-lambda> Cale: yes, it doesn’t throw an exception, it drops a value
13:10:01 <monochrom> Cale: I agree.  Death to rule of thumbs.  You always have to think!
13:11:20 <freeman42x[m]> so the command to run last command seems to be `:`, does not work in the Atom REPL I am using though :/
13:11:25 <Cale> The result of that is obviously just 1
13:11:35 <Cale> Well, "obviously"
13:12:16 <Cale> Why do you expect to see the 2 after the first thing aborted?
13:12:48 <Cale> That's a weird notion of catch you want
13:13:27 <Cale> It's got to go back in and resume somewhere at the continuation of the exact point where the exception occurred? But where?
13:14:31 <freeman42x[m]> asked on SO: https://stackoverflow.com/q/61237685/750216
13:14:34 <Cale> The continuation supplied to catchError has the wrong type to replace the throwError -- it replaces the entire remainder of the computation
13:14:43 <lexi-lambda> Cale: the continuation of the choice point clearly includes the catch
13:15:01 <monochrom> I suppose some distributive law says: (x<|>y) `catchError h = (x `catchError` h) <|> (y `catchError h).
13:15:23 <Cale> ^^ that distribution is bizarre and would be very unexpected to me
13:15:37 <lexi-lambda> I don’t see why it’s bizarre at all
13:15:40 <monochrom> Crazy distributive law, but maybe I didn't understand <|>
13:15:45 <lexi-lambda> the continuation of <|> clearly includes the catch
13:15:59 <maerwald> freeman42x[m]: what do you mean it does not work
13:16:30 <monochrom> I really want to chalk it up to "see this is what's wrong with being religious about equational reasoning" but maybe it's unfar, maybe it's really disagreement on what <|> means and what throwError means.
13:16:35 <freeman42x[m]> maerwald: check the SO question for what happens
13:16:41 <Cale> lexi-lambda: (throwError "foo" <|> ...) is a single action which happens to do nothing except throw an exception. It never ever produces a result.
13:16:43 <maerwald> It doesn't say what you did
13:16:46 <maerwald> or what you expected
13:16:53 <monochrom> And I am saying this as a formal methods person of Dijkstra's and Bird's kind.
13:17:04 <lexi-lambda> Cale: if you think that’s the case, I can show you another program that has the opposite of the behavior you’re describing as “expected”
13:17:36 <Cale> It might as well be  throwError "bang" <|> undefined
13:17:58 <monochrom> If you say that you have both an exception system and nondeterminism, and they're orthogonal, then I can see how you need this distributive law, it's the pinnacle of that orthogonality.
13:17:59 <Cale> (and if you replace the remainder of the <|> with that, you'll see that the right half of the <|> is never even evaluated here)
13:18:21 <lexi-lambda> Cale: I don’t understand why you think that
13:18:34 <MarcelineVQ> freeman42x[m]: what is a list of macros?
13:18:35 <Cale> I don't even have to just think that, I know it because I just tried it
13:18:49 <Cale> ~> let p :: ListT (ExceptT String IO) Int; p = (throwError "bang" <|> undefined) `catchError` \_ -> pure 1
13:18:55 <lexi-lambda> <|> has a very well-defined meaning in the literature; it’s an expression in the embedded language that nondeterministically evaluates to each of its branches
13:18:59 <Cale> ~> runExceptT (runEffect (enumerate p >-> P.print))
13:19:04 <Cale> 1
13:19:04 <Cale> Right ()
13:19:28 <lexi-lambda> you’re claiming you “know it” because that’s what the implementation does, but that says nothing; I’m asking you why you expect that to be what the implementation does
13:19:54 <maerwald> I stopped thinking that high-level in haskell long ago
13:20:27 <monochrom> I sympathize with citing literature.  But I want to remind you: The mathematics literature has two well-defined meanings of "natural numbers", and three well-accepted meanings of 0^0.
13:20:40 <freeman42x[m]> MarcelineVQ: I updated the question with list of macros it prints: https://stackoverflow.com/q/61237685/750216
13:20:42 <maerwald> I read the instance implementations and hope I don't fall into a trap
13:20:47 <monochrom> (I can't say the latter is "well-defined" because one of them emphatically says "undefined" haha)
13:21:11 <lexi-lambda> this goes back to McCarthy’s operator for ambiguous choice
13:21:35 <lexi-lambda> just because some things have multiple meanings does not mean all things do
13:21:46 <Cale> Because as soon as it throws an exception, it's not going to make sense for it to resume from where it left off -- throwing an exception is typically going to be a consequence which is the last thing that happens, and just replacing the throwError with something else isn't going to restore the problem
13:21:58 <MarcelineVQ> is that really  cabal repl?
13:22:02 <Cale> That's not what catch does
13:22:14 <monochrom> This is great.  I will teach this course again in the summer.  This will be on the final exam!
13:22:33 <maerwald> freeman42x[m]: type ":info Int"
13:22:57 <lexi-lambda> Cale: but if you flip the order of the transformers you get Right [1, 2]
13:23:01 <monochrom> "here be a language in which exception and backtracking nondeterminism try to be as independent of each other as possible..."  will confuse the hell out of my poor students.
13:23:05 <lexi-lambda> which seems inconsistent with what you’re arguing for
13:23:09 <Cale> catch isn't going to go back into a chain of <|>'s after running the provided continuation, that's... crazy and I don't know how it could make sense, unless the types were all different
13:23:29 <maerwald> I agree that order of transformers is something nasty to reason about
13:23:39 <lexi-lambda> I genuinely don’t understand why you think it’s crazy, or why it would require the types to be different
13:24:07 <lexi-lambda> a <|> b is an expression that non-deterministically evaluates to a or b
13:24:15 <Cale> I get simply Right 2 in that case
13:24:40 <lexi-lambda> oh sorry, you can’t just flip them because then you’re using <|> on ExceptT, not ListT
13:24:42 <lexi-lambda> I forgot
13:24:46 <monochrom> maerwald: I always unmtl to see what I'm getting.  In that sense, monad transformers cease being compositional or usable-as-abstraction etc.  And yet, did you know...
13:24:51 <Cale> right
13:24:53 <lexi-lambda> there’s a simple way to make it use <|> from ListT though
13:25:20 <monochrom> The surprise is that I found that someone went out of their way to code up the instances so that ContT State and StateT Cont behave the same.
13:25:21 <lexi-lambda> define `amb = pure True <|> pure False`
13:25:24 <lexi-lambda> then write (lift amb >>= \case { True -> throwError "bang"; False -> pure 2 }) `catchError` \_ -> pure 1
13:25:33 <lexi-lambda> that way you get <|> from ListT, not ExceptT
13:25:55 <Cale> That's an entirely different thing
13:25:58 <lexi-lambda> why???
13:26:06 <Cale> amb doesn't fail
13:26:10 <monochrom> Because you would think that one of them (I forgot which, unmtl to see again haha) will roll-back the state when you escape?  No, someone bothered to preserve state.
13:26:30 <Cale> The thing you're <|>'ing together isn't throwing an exception
13:26:32 <lexi-lambda> Cale: `a <|> b` is an expression that non-determinstically evaluates to a or b, and the list monad collects the result of all possible executions. Do you agree with that?
13:27:08 <Cale> It collects all the executions up until an exception is thrown, and discards the remainder.
13:27:33 <lexi-lambda> That’s not what nondeterminism has meant in the literature *forever*. My definition is extremely simple. Why are you making it more complicated?
13:27:34 <Cale> If a throws an exception, b won't be used
13:28:00 <Cale> If b throws an exception, that exception will only occur after you've backtracked to hit it of course.
13:28:05 <lexi-lambda> It sounds like you don’t agree. But then I can’t argue with you, because you disagree with the meaning of nondeterministic execution.
13:28:30 <maerwald> I feel like, rather than talking about literature, there must be a very concrete use case where you want that behavior. You didn't wake up one morning and thought monad transformers don't adhere to literature semantics of <|>
13:28:31 <Cale> I'm just disagreeing with respect to how I expect exceptions to mix with it
13:28:31 <monochrom> Anyway I love ParserT Cont.  You can do SAX that way.
13:28:36 <lexi-lambda> The whole point is that the meaning of <|> shouldn’t depend on what other computational effects are in play! It always means “nondeterministic choice.”
13:28:42 <Cale> and I'm only disagreeing because of the type of catchError
13:28:57 <Cale> catchError :: MonadError e m => m a -> (e -> m a) -> m a
13:28:58 <lexi-lambda> Yes but you’re actively arguing for a *less* compositional semantics! Why?
13:29:13 <monochrom> Actually sometimes I think of ParsecT (ContT IO) too for the kick of it.
13:29:20 <monochrom> http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#ContT
13:29:22 <lexi-lambda> Please ignore Haskell for a moment. Abstractly speaking, why would you *want* the semantics you’re talking about over the one I’m talking about?
13:30:16 <Cale> In catchError x h, I never expect x to be resumed after h is used.
13:30:51 <lexi-lambda> I think what you’re arguing for is that you statically disallow composition of these two effects.
13:31:06 <Cale> If some problem occurred attempting x, no matter what x happens to be, I assume that it's done, and the entire rest of its execution was replaced by whatever h gave.
13:31:09 <lexi-lambda> Which is fine, I guess. But I’m asking you to pin down what <|> means in isolation.
13:31:31 <MarcelineVQ> freeman42x[m]: approaching from a different angle, what specifically do you mean by "2. run the previous thing I run in GHCI"  If it's something like you want to :reload then   foo 3   then no I don't think ghci has something for that,  ghcid --run="foo 3" can though
13:31:54 <lexi-lambda> Perhaps using <|> as the symbol is unhelpful, actually, since in Haskell it’s overloaded. What I mean is I’m asking you to define what nondeterministic choice means in isolation.
13:31:55 <maerwald> ':' resumes the previous *command*, yes
13:32:05 <maerwald> Not "whatever I wrote earlier"
13:32:46 <monochrom> I thought it's as simple as "press up-arrrow, press enter"
13:33:12 <Cale> lexi-lambda: Maybe I can make it clearer somehow with a slightly larger example... it's confusing precisely because the throwError is the entirety of one of the branches of the <|>
13:33:17 <maerwald> Yes, but they're not phrasing their questions in a way that makes helping not random guessing
13:33:25 <lexi-lambda> Cale: I want you to stop talking about errors. Please.
13:33:28 <Cale> and not something that simply happened to occur in the middle of a branch
13:33:31 <lexi-lambda> I want to talk about nondeterministic choice.
13:33:37 <Cale> huh?
13:33:53 <monochrom> We need to set up this protocol.
13:33:54 <Cale> But exceptions are important to the entire disagreement here. I think we both know how the list monad works
13:33:55 <lexi-lambda> I am asking you to tell me what laws you expect nondeterminstic choice to follow.
13:34:19 <monochrom> We make the most literal, superficial interpretation of a question, and answer the literal superficial answer.
13:34:28 <monochrom> A shitty answer for a shitty question.
13:34:39 <monochrom> How else would asker learn to hone their question skills?
13:34:42 <lexi-lambda> Like, do you think that `(a <|> b) >>= k` = `(a >>= k) <|> (b >>= k)` is a reasonable law for nondeterministic choice?
13:34:48 <MarcelineVQ> The most superficial answer was made in the SO​ post already ^^;
13:34:49 <Cale> Sometimes, but often not
13:35:03 <monochrom> We have too many do-gooders who are too good at this guessing game.
13:35:04 <lexi-lambda> But then what does the operation mean to you?
13:35:11 <maerwald> monochrom: the classic "yes" question to "do I do this or this?" =)
13:35:16 <Cale> It means whatever it's defined to mean
13:35:19 <freeman42x[m]> MarcelineVQ: I have updated the question to clarify what I mean: https://stackoverflow.com/q/61237685/750216
13:35:20 <monochrom> This is unhealthy, it fosters entitlement attitudes.
13:35:21 <lexi-lambda> Let me make an analogy. get/put clearly model mutable state.
13:35:34 <monochrom> Aww not down to that level :)
13:35:48 <lexi-lambda> We have certain laws about them. We expect `(,) <$> get <*> get` to always return a tuple of two of the same value.
13:36:04 <lexi-lambda> Now, mtl doesn’t write the laws down. That’s not great. But I think it’s good to have operations with laws!
13:36:14 <Cale> I expect that <|> is a monoid operation with empty as the identity
13:36:25 <Cale> and other than that, I don't expect much else
13:36:28 <lexi-lambda> This is why I said using <|> as the symbol was going to confuse you.
13:36:34 <lexi-lambda> I’m not talking about Alternative.
13:36:37 <Cale> what?
13:36:39 <lexi-lambda> I’m talking about nondeterministic choice.
13:36:55 <MarcelineVQ> Everyone's full of beans today.
13:37:02 <lexi-lambda> (<|>) @(Either e) is not nondeterministic choice; it’s quite deterministic.
13:37:24 <monochrom> Question improvement skill is an essential part of problem solving skills.  (Sure, there are also others.)
13:37:34 <lexi-lambda> But imagine we defined a totally separate typeclass specifically for nondeterministic choice.
13:37:52 <lexi-lambda> class MonadNonDet m where { choose :: m a -> m a -> m a }
13:37:59 <Cale> Wait, do we expect that (,) <$> get <*> get should always be equal to (\x -> (x,x)) <$> get ? I'm not sure about that.
13:38:09 <Cale> It's obviously true for StateT
13:38:15 <monochrom> Relieving askers from question improvement is a disservice.
13:38:24 <lexi-lambda> If you think laws are not desirable then it is impossible to argue for any semantics over another.
13:38:34 <pavonia> freeman42x[m]: What you could probably do is to define a command that stores "it" in a file (only works with a Show instance, I guess), then reloads the file and reads back the expression
13:38:36 <Cale> Some laws are desirable.
13:38:54 <Cale> Laws that don't actually hold are not ;)
13:38:56 <lexi-lambda> I am arguing for local, compositional reasoning. You seem to be arguing for something else. I’m not sure what.
13:39:12 <monochrom> Cale, I expect (,) <$> get <*> get = (\x -> (x,x)) <$> get.
13:39:18 <lexi-lambda> I have an idea in my head what nondeterministic choice means. Do you?
13:39:21 <lexi-lambda> Apparently not.
13:39:28 <monochrom> It is true of all imperative languages.
13:39:34 <Cale> lexi-lambda: It means a lot of stuff
13:39:39 <lexi-lambda> Why?
13:39:58 <monochrom> And so, there are formal method textbooks for imperative programming that have this law (or stronger).
13:40:07 <Cale> Because there are a lot of things which are kinda sorta like nondeterministic Turing machines in one way or another
13:40:07 <lexi-lambda> It’s one operation. It’s very well-defined, historically. And I want to be clear that I am not talking about Alternative.(<|>), I’m talking about nondeterministic choice.
13:40:27 <Cale> and they don't all behave identically
13:40:35 <monochrom> I'm open to listening to a scenerio in which you don't want this law.  But I can't imagine it, so you'll have to help me.
13:40:46 <Cale> It's important to actually understand what laws apply to whatever thing you're working with
13:40:57 <lexi-lambda> If you go to that level then we can’t expect anything to mean anything. “Maybe throwing an error will be caught by an enclosing catch, maybe it won’t; they don’t all behave identically.”
13:41:13 <maerwald> monochrom: it skips an effect, which one? first or second?
13:41:26 <lexi-lambda> We have laws on >>=. It is overloaded. We don’t “actually understand what laws apply to whatever thing we’re working with.”
13:41:48 <lexi-lambda> We expect the monad laws to hold for all monads. I expect certain laws to hold for all implementations of nondeterministic choice.
13:42:03 <monochrom> maerwald: The only effect I can think of is "this language counts how many times you call get for profiling purposes".
13:42:35 <maerwald> maybe 'get' becomes faster the more you use it
13:42:49 <Cale> monochrom: It's not clear in cases where get is reading from something that can be accessed concurrently by other threads, for example
13:43:08 <lexi-lambda> I think that if you start arguing that nothing means anything except what it does you are fundamentally arguing against abstraction.
13:43:21 <monochrom> I understand that the monad this live in allows many different kinds of effects.  But I expect that "get" tries very hard to not use them, apart from depending on a hidden variable.
13:43:43 <Cale> It might be fine to assume that get has that law in most cases
13:43:52 <Cale> But the class doesn't actually say that it does
13:43:56 <monochrom> Oh! OK concurrency.
13:44:10 <Cale> So, I'd be hesitant to just go ahead and put a rewrite into the compiler
13:44:13 <lexi-lambda> Cale: Maybe you don’t want get/put consistency, okay. But what about the law `catch (throw e) f` = `f e`?
13:44:23 <hexagoxel> Would you even expect f (a ? b) = f a ? f b    consider f x = x == x
13:44:25 <lexi-lambda> Surely that one ought to hold.
13:44:32 <freeman42x[m]> I thought that having something like this in .ghci file: `:def re const $ return $ Data.List.unlines [":reload", "it"]` would work. But it does not use the `it` from the GHCI context.
13:44:46 <monochrom> Cale, but I would still insist this law, just when restricted to sequential programming.
13:45:06 <hexagoxel> f (a ? b) === True?False,   f a ? f b === True ? True === True
13:45:39 <Cale> lexi-lambda: I'll give you that one perhaps, though Control.Monad.Except says nothing about it.
13:45:56 <monochrom> maerwald: To a large extent I think people deal with that by cheating.  We just declare that the denotational semantics doesn't talk about faster.  So you still have equality after putting on the [| |] brackets.
13:45:56 <hexagoxel> Adding >>= does not change anything
13:45:57 <lexi-lambda> Right, I’m not talking about Haskell here, I’m talking more abstractly. I’m talking about computational effects.
13:46:12 <Cale> lexi-lambda: I don't expect the same laws to hold in every circumstance
13:46:33 <monochrom> One day I may define a denotational semantics that includes time.  But meh, too hard.
13:46:36 <lexi-lambda> Do you not expect the monad laws to hold in every circumstance?
13:46:42 <Cale> lexi-lambda: For any given monad and collection of operations it has, they may or may not satisfy any given law
13:46:50 <lexi-lambda> Including the monad laws.
13:46:57 <lexi-lambda> That’s a take.
13:46:57 <Cale> Saying that it's a monad implies the monad laws
13:47:11 <Cale> But nothing else.
13:47:11 <monochrom> Actually I think some grad student was doing that.  Haven't checked what's the progress.  Tangentially relevant to my PhD work, but meh I finished mine first.
13:47:18 <lexi-lambda> Okay, what makes Monad special? Why can’t we have laws for other operations, too?
13:47:22 <Cale> We can
13:47:30 <Cale> But the question is, do we?
13:47:44 <lexi-lambda> Alright, now we’re back to my hypothetical: suppose we define a `MonadNonDet`. What laws should we give it?
13:47:48 <Cale> What does the definition of Alternative say the laws are?
13:47:57 <lexi-lambda> I’m not talking about Alternative.
13:47:57 <Cale> It says that it's a monoid.
13:48:16 <lexi-lambda> I’m talking about nondeterministic choice. Alternative is not a class for nondeterministic choice.
13:48:34 <Cale> What laws we should give our MonadNonDet depend on what instances we need it to have
13:48:56 <monochrom> Wait, is that what Aristotle was talking about.
13:49:02 <lexi-lambda> I think that’s a bit backwards. I think we should think about what the operation is supposed to *mean*, then let that inform which things support an instance.
13:49:02 <monochrom> I mean ?
13:49:21 <monochrom> Define by enumerating all instances, vs, define by enumerating all laws.
13:49:30 <hexagoxel> lexi-lambda: have you considered my example above?
13:49:36 <monochrom> and the Galois duality between them. or something.
13:49:37 <lexi-lambda> If we were to add laws for MonadError, we wouldn’t reason backwards from the instances. We’d start with our expectations about how MonadError models exceptions and go from there.
13:49:58 <Cale> It's too easy to build an abstraction which is beautiful but useless.
13:50:03 <lexi-lambda> hexagoxel: I don’t understand your example. Is it Haskell? Because it doesn’t typecheck in Haskell if (?) is a monadic operation.
13:50:06 <monochrom> Both are backwards.  There.
13:50:21 <hexagoxel> lexi-lambda: I was just using ? instead of <|>
13:50:23 <lexi-lambda> Cale: But nondeterministic choice is clearly quite useful!
13:50:35 <monochrom> You should evolve both sides togehter.  And consult the community and get consensus.
13:50:37 <lexi-lambda> hexagoxel: Then f (a ? b) doesn’t typecheck if f x = x == x.
13:50:39 <hexagoxel> i.e. it was not meant to have anything to do with >>=
13:50:46 <Cale> I care about getting my program to do a thing, if the operations I need to build it don't satisfy the laws of your class, then I don't get to use your class, but that's fine, I'll just use another one.
13:51:22 <monochrom> Math was not defined on day 0, despite how platonist mathematicians would want you to believe it.
13:51:32 <monochrom> Math was evolved.
13:51:58 <lexi-lambda> Cale: Okay, let me phrase my position differently, then. I believe that predictable effect composition is both possible and useful. I believe effect systems can deliver that value. I do not believe monad transformers do.
13:52:21 <monochrom> In fact the "law" x*y=y*x was asserted first, then retracted later.
13:52:37 <Cale> There's no one definition of how nondeterminism "ought" to act with respect to every conceivable other operation which will ever be correct in every circumstance.
13:52:38 <monochrom> So it's not even monotonically "add more laws"
13:52:41 <lexi-lambda> If your argument is that mtl’s operations should be lawless, then that’s your right. But I don’t want to work with those operations.
13:52:51 <lexi-lambda> Cale: My argument is that there is.
13:52:51 <Cale> There are instances where you want one sort of interaction, and instances where you want another
13:53:19 <lexi-lambda> By providing a framework for effect composition, you provide a consistent answer to how effects compose, so you can predict how they will compose.
13:53:33 <pavonia> freeman42x[m]: The old "it" is lost once you relaod the file
13:53:34 <lexi-lambda> Now, sure, sometimes you might want different behavior. Then you’re not helped at all!
13:53:36 <Cale> I think the way that Pipes' ListT interacts with ExceptT is pretty easily understood, no matter which way around you put them, and both are things that you might reasonably want in some cases.
13:53:48 <lexi-lambda> But suppose you *do* want the behavior the model gets you. At least you can rely on it.
13:54:17 <lexi-lambda> With monad transformers, you can’t rely on any behavior because they do not support this form of equational, local reasoning.
13:54:24 <freeman42x[m]> pavonia: ah yeah, great observation. So I would need somehow to reference an run it as a string or something if possible
13:54:37 <lexi-lambda> I think equational, local reasoning is desirable. I’m not claiming it solves all programming problems ever. Obviously.
13:54:47 <Cale> I think they do support equational, local reasoning
13:55:02 <Cale> They just don't support it with respect to globally-specified laws :D
13:55:21 <lexi-lambda> I think programming with operations with laws is nicer than programming with operations without them.
13:55:30 <Cale> Once you've constructed your monad, you can determine which laws it satisfies
13:55:37 <Cale> and use them
13:55:39 <lexi-lambda> With an effect system, I don’t have to.
13:55:57 <lexi-lambda> I know how effects will compose even though I might not have even defined the effect handler myseelf.
13:56:07 <lexi-lambda> That’s awesome!
13:56:07 <Cale> If you have to satisfy the same laws all the time, then there are just going to be a lot of things you can't express
13:56:10 <maerwald> Well, if you have some mtl style function, you have no idea what it actually does in terms of effect interaction, unless you read the interpreter.
13:56:19 <Cale> because they don't satisfy the same laws as the other ones
13:56:38 <hexagoxel> lexi-lambda: huh? f :: NonDet a -> NonDet Bool, ? :: NonDet a -> NonDet a -> NonDet a, (==) :: Eq a => NonDet a -> NonDet a -> NonDet Bool
13:56:39 <Cale> maerwald: This is part of why I don't like mtl's classes
13:57:01 <Cale> maerwald: They're usually at the wrong level of abstraction to mean anything
13:57:23 <hexagoxel> no monads..
13:57:35 <Cale> maerwald: I have to admit they're kind of convenient when you're defining the operations you *actually* want to use in your monad though.
13:57:35 <maerwald> I find them a lit less ugly to work with than transformers, especially when refactoring
13:57:43 <lexi-lambda> hexagoxel: Oh, okay, I see. I think you’re mixing the host language and the embedded language. == in that context is equality on terms in the embedded language, which is at the meta level. It’s outside of the language, so of course it doesn’t follow the same distributivity law.
13:58:02 <Cale> I just recommend defining your own classes which have more application-specific meanings for their operations as soon as possible
13:58:03 <lexi-lambda> But that’s like saying put 1 `seq` get should return 1.
13:58:48 <hexagoxel> lexi-lambda: yeah, I was sloppy in my first line. Should have been f (a ? b) === f a ? f b
13:59:16 <lexi-lambda> hexagoxel: f is a metafunction.
13:59:31 <hexagoxel> no
13:59:42 <lexi-lambda> If f x = x == x, then it is.
14:00:22 <hexagoxel> Wait, === is the meta operator, = is in-language definition
14:00:39 <monochrom> Bah. Tea time.
14:01:09 <maerwald> lexi-lambda: I take it you dislike the local-do proposal?
14:01:18 <lexi-lambda> hexagoxel: When you use the list monad, you can view it in two ways simultaneously: a Haskell expression on lists, and an embedded DSL that models nondeterministic choice.
14:01:39 <lexi-lambda> Your definition of `f` compares *computations* for equality. It is fundamentally at the meta level from the POV of the DSL.
14:02:04 <lexi-lambda> (Or perhaps a better way of saying it would be that `f` compares *programs* for equality.)
14:02:57 <lexi-lambda> maerwald: What proposal?
14:03:25 <maerwald> lexi-lambda: https://github.com/ghc-proposals/ghc-proposals/pull/216
14:03:32 <lexi-lambda> Cale: An effect system allows you to compose computational effects in a predictable way. Does it solve every problem in the world? No, of course not. But clearly many people, myself included, think it is useful to have a framework for composition of effects that provides predictable composition for 80% of use cases.
14:03:34 <maerwald> talking about >>= being overloaded... there you go
14:03:51 <lexi-lambda> Cale: Monad transformers provide predictable composition for 0% of use cases. So I think this is still a win.
14:04:22 <lexi-lambda> maerwald: That’s just a syntactic change; I’m talking about semantics.
14:04:25 <Cale> It's entirely predictable though
14:04:37 <lexi-lambda> Assuming you know the entire implementation?
14:04:41 <Cale> I don't see how you can claim that
14:04:43 <lexi-lambda> That’s a pretty vacuous statement.
14:05:24 <Cale> It's like saying that functions aren't composable because you can't predict the values that come out of them
14:05:42 <lexi-lambda> With an effect system, I can use a library that defines an entirely new effect I’ve never seen before, and I already know various details about how it interacts with State or Error.
14:05:49 <Cale> Monad transformers are literally just (fairly arbitrary) functions on monads.
14:06:10 <lexi-lambda> It’s the same kind of reasoning power you get from the monad laws, and the power here is that these laws are fundamental to the effect system, not to each effect individually.
14:06:15 <Cale> and sure, it's possible to put functions together and get a result which is different from what you wanted
14:06:26 <Cale> but still, you can reason about compositions of functions just fine
14:06:34 <lexi-lambda> Your argument says things like the monad laws have no value.
14:06:42 <Cale> Monad laws have value
14:06:50 <lexi-lambda> Why do those laws have value but the effect laws don’t?
14:07:15 <Cale> I'm not saying that laws regarding particular effects don't have value at all
14:07:28 <lexi-lambda> You’re just saying that laws regarding all effects don’t have value at all.
14:07:36 <Cale> I'm saying that it's easy for them to be overly optimistic about describing the monads we actually want to use
14:07:55 <lexi-lambda> Do you have any evidence for your claim that these laws *are* overly optimistic?
14:07:56 <hexagoxel> lexi-lambda: Sorry, I don't follow. It is perfectly fine haskell if you have NonDet = [].
14:07:59 <Cale> and so you might have to resort to different laws in some cases to be able to reason correctly
14:08:29 <lexi-lambda> hexagoxel: Nondeterministic choice exists as a concept independent of Haskell. The list monad models that concept, but they are not one and the same.
14:09:08 <hexagoxel> and if your law does not hold for the one instantiation of the concept, then it does not hold in general.
14:09:12 <Cale> Well, (a <|> b) >>= k = (a >>= k) <|> (b >>= k) surely does not always hold. Maybe it would be a good idea to split Alternative into a few separate classes, or make some operation-free subclasses of it to be able to express when it does.
14:09:25 <Cale> But yeah, that's not *always* going to happen.
14:09:54 <lexi-lambda> hexagoxel: No, that instantiation doesn’t violate the law, because the law doesn’t apply to the example you provided. The law only applies to the embedded language.
14:09:56 <lexi-lambda> It’s like how the beta law in the lambda calculus models function application. The beta law isn’t function application. But it’s a useful model for it.
14:10:23 <lexi-lambda> Sure, you can model the lambda calculus in Haskell and write code that contradicts, say, alpha-equivalence. But that doesn’t mean alpha equivalence doesn’t “hold in general.”
14:10:25 <Cale> Sometimes you want some degree of communication between the branches of your nondeterminism
14:10:30 <Cale> In other words
14:10:41 <Cale> Or you can't avoid it
14:10:43 <lexi-lambda> Cale: You’re still talking about <|> while I’m talking about nondeterministic choice.
14:10:58 <Cale> I'm talking about a more general notion of nondeterministic choice than you are
14:11:16 <lexi-lambda> My definition exists externally to me, across dozens of papers spread over decades of computer science.
14:11:22 <lexi-lambda> I’m not pulling it out of my ass.
14:11:46 <lexi-lambda> Maybe you don’t like my definition, but that doesn’t mean my definition ceases to be precisely defined.
14:11:59 <Cale> Whenever our monad creates monoids in some way, we can define nondeterministic choice to refer to the family of monoid operations so constructed.
14:12:18 <lexi-lambda> Yes, we can define any word to mean anything if we would like.
14:12:24 <Cale> Mhm
14:12:35 <hexagoxel> lexi-lambda: I have no idea what "embedded language" you are talking about, so I cannot evaluate your law.
14:12:49 <Cale> *Sometimes* that monoid will satisfy more than just the monoid laws
14:12:51 <lexi-lambda> But I choose to live in a world where, when engaged in a debate, both parties generally agree upon what words mean so that we don’t argue over definitions indefinitely.
14:13:05 * hexagoxel leaves
14:13:07 <Cale> and there's more than one reasonable way for it to interact with the monad operations
14:13:47 <Cale> Sometimes, you'll have  return a <|> b = return a
14:14:09 <lexi-lambda> Cale, I want to be very clear that what you are arguing right now is that nondeterminstic choice should mean something else. That’s fine, but it’s completely irrelevant to anything I’m talking about.
14:14:18 <Cale> This is a nice law to have, but completely is in disagreement with distribution of (>>=) over (<|>)
14:14:29 <lexi-lambda> Why do you keep talking about <|>?
14:14:34 <lexi-lambda> I stopped talking about it ages ago.
14:14:40 <lexi-lambda> Because I acknowledged it was confusing.
14:14:41 <Cale> Because it's the symbol for nondeterministic choice
14:14:52 <lexi-lambda> No it isn’t. It’s a method of the Alternative class.
14:15:01 <Cale> That as well
14:15:13 <lexi-lambda> Nondeterministic choice has existed since the 60s. I assure you they did not use <|> to represent it.
14:15:28 <Cale> Well, fine, would you like to use another symbol for it?
14:15:36 <Cale> It's just easier if we have some symbol
14:15:42 <Cale> I don't care what the symbol is
14:16:19 <freeman42x[m]> so... `-Wall` enables all warnings. what can I use to disable all warnings?
14:16:41 <oats> lol oh no
14:16:50 <lexi-lambda> I proposed one: class MonadNonDet where { choice :: m a -> m a -> m a }. But I want to be very clear that the meaning of nondeterministic choice is not something I am willing to debate. I am talking about modeling the generally agreed-upon concept of nondeterministic choice.
14:17:08 <Cale> I disagree that there is just one
14:17:17 <lexi-lambda> Would you like me to start citing papers?
14:18:46 <freeman42x[m]> it seems like I need to disable warnings individually, that's fine actually, better
14:19:14 <maerwald> freeman42x[m]: so, did you get any funding yet?
14:19:25 <Cale> lexi-lambda: Where's the paper which defines nondeterministic choice once and for all?
14:19:34 <lexi-lambda> A Basis for a Mathematical Theory of Computation, McCarthy, 1963.
14:19:45 <Cale> There's a bunch of completely different kinds of "nondeterministic" machines of various types
14:19:58 <freeman42x[m]> maerwald: funding for what?
14:20:00 <Cale> and they don't all satisfy the same equations
14:20:16 <peutri> yay, (amb)
14:20:22 <maerwald> freeman42x[m]: I had the impression you're setting up an MVP as quickly as possible to get funding 
14:20:25 <lexi-lambda> Yes, but “nondeterministic choice” is a term of art. Your argument is like saying “work” doesn’t mean “the product of force and displacement” because there are other forms of “doing work.”
14:21:27 <Cale> It is quite like that, yes
14:21:41 <freeman42x[m]> maerwald: nah, not have any current plans beyong creating this application and funding development on it through donations. This is kind of offtopic for the channel though
14:21:55 <lexi-lambda> Well then it sounds like you are knowingly wasting my time.
14:22:01 <Cale> Am I?
14:22:26 <monochrom> freeman42x[m]: If you just the default, and don't use -Wall, you get very reasonable warnings and lack of warnings IMO.
14:22:35 <Cale> There are a lot of other notions in physics of doing work, and that one specific one might not apply to your given situation
14:22:54 <Cale> So it's important to be flexible about it
14:23:15 <peutri> name one?
14:23:24 <freeman42x[m]> monochrom: I do not want to get distracted by REPL warnings, I see the warnings in the editors anway so I do fix them before commiting
14:23:49 <maerwald> I hope your editor is correct about those warnings :)
14:23:55 <maerwald> If it's using ghcide or sth, it might not
14:24:05 <monochrom> Some of us (the sane people among us, that is :) ) take this stance: turn on -Wall during coding so you have awareness.  Don't impose it on users who build your code from source.
14:24:44 <monochrom> Ah OK.
14:24:54 <monochrom> I don't know how to turn everything off.
14:25:09 <monochrom> I believe there is still a flag for that, just too lazy to find.
14:25:24 <monochrom> GHC user's guide as always for the 5th time by now :)
14:26:10 <monochrom> The probability that it's in the doc but too obscure for anyone to know off their head can only increase with time.
14:26:30 <MarcelineVQ> I've taken to setting -Wall (or other dev-time flags) in cabal.project.local
14:26:35 <Cale> peutri, maerwald: Well, maybe it's not a great example, but how about a case where your force is changing?
14:26:53 <peutri> physics-wise, that doesn't change a thing
14:26:57 <Cale> It does though
14:27:03 <peutri> right, it changes force
14:27:11 <Cale> Work won't be the pointwise product of force and displacement
14:27:12 <peutri> physics-wise, it doesn't change a word from the definition
14:27:27 <Cale> It'll be an integral
14:27:28 <peutri> err... yes it will?
14:27:34 <peutri> yes
14:27:36 <peutri> pointwise
14:27:53 <monochrom> I think we've also trained ourselve to do this: even when -Wall, we are selective in how much we care and when.
14:27:55 <Cale> an integral with respect to displacement
14:28:19 <peutri> or time
14:28:27 <peutri> or force, if really you like swiching variables around
14:29:04 <monochrom> Speaking of which, I have begun reading Functional Differential Geometry.
14:29:20 <peutri> that's the kinf of reading i'd need
14:29:44 <peutri> i just finished therefresher on linalg with that great book free from springer 'cuz covid
14:29:45 <Cale> W(t) = F(t) s(t)
14:29:53 <Cale> ^^ that is wrong
14:30:02 <Cale> Or, most likely anyway
14:30:26 <Cale> We need a different law to describe work in cases where the force varies
14:30:31 <monochrom> Half serious half joke: I can afford the cdn$70ish for it because the pandemic means I am not spending cdn$70 per week in restaurants for steak dinners and wines :)
14:30:55 <Cale> (it turns out to be a generalisation, but nonetheless, it's not identically the thing that lexi-lambda said)
14:31:16 <maerwald> yeah, I'm swimming in money since I don't get the obligatory 10 guinness after work
14:31:22 <peutri> try dW = F*ds
14:31:30 <Cale> yeah
14:32:25 <monochrom> Next time you can use this insult on people: "you are a piece of integrating force over distance".  It's a "physical" insult. >:)
14:32:37 <Cale> and that's an inner product, not, for example, a componentwise product of the vectors (that would be weird)
14:32:45 <peutri> with a bit f the analytical twist
14:33:11 <peutri> you do like to redefine things, don't you
14:33:29 <maerwald> hence transformers!
14:33:34 <Cale> peutri: Have you been following the discussion that lexi and I have been having?
14:33:43 <Cale> It's not really about physics
14:33:47 <peutri> last i checked (which is last week, cf linalg book) inner product *is* componentwise product
14:33:51 <peutri> nope i only saw the end of it
14:34:02 <monochrom> No, also sum over.
14:34:05 <peutri> and i bet you both were wondering why you started
14:34:16 <peutri> monochrom: indeed
14:34:24 <monochrom> x1*x2 + y1*y2, not (x1*x2, y1*y2)
14:34:50 <monochrom> usually "componentwise product" refers to   (x1*x2, y1*y2) keeping it a vector or tuple or ...
14:35:01 <peutri> yup
14:35:05 <peutri> not my native vocabulary
14:35:18 <peutri> i was agreeing with the componentwise as in x multplies with x
14:35:35 <peutri> as opposed to the classic (x1*y2,-y2*x1)
14:36:05 <Cale> peutri: Basically, I'm of the mind that it's too much to ask to expect certain terms to always satisfy exactly the same laws in every application, and that sometimes you'll need to refine things to the situation you actually have, rather than insisting on some sort of ideal behaviour.
14:37:01 <Cale> Lexi wants to make all the monad-related operations always satisfy the same laws -- which will result in *something* but my point is that if it doesn't turn out to be exactly the thing we want, that won't be too helpful.
14:37:20 <peutri> monochrom: come to think of it, i dont think anything useful in linalg deines as (x1*x2,y1*y2), does there?
14:37:49 <monochrom> Yeah it's pretty useless.
14:38:04 <peutri> so not that much (amb)
14:38:08 <Cale> Now, I can see refining things a bunch and splitting our classes up -- Alternative maybe ought to be split into a class which satisfies something of a distributive law and something of a catch-like law.
14:38:14 <solonarv> it has a name, so it's probably useful for something somewhere
14:38:27 <peutri> does it?
14:38:30 <Cale> Well, it's not useful for linear algebra
14:38:35 <monochrom> Err, actually, it's pretty useful, but in ring theory not linear algebra.
14:38:39 <Cale> But the product of rings works that way
14:38:42 <Cale> yeah
14:38:44 <monochrom> Yeah, that.
14:39:04 <solonarv> "Hadamard product"
14:39:13 <monochrom> You need it to state the Chinese Remainder Theorem for arbitrary rings :)
14:39:23 <peutri> yay, learn something night
14:39:26 <solonarv> aka "elementwise", "entrywise", "Schur" product
14:40:02 <Cale> The product of rings has the unfortunate property that it basically always gets you something with zero divisors, which excludes the rings which it produces from a lot of specific uses.
14:40:24 <Cale> But still, they have their place
14:40:49 <peutri> "useful for JPEG"
14:40:51 <peutri> well... TIL
14:41:16 <Cale> If we were to always insist that our rings were integral domains, then that would be nicer, but we'd be unable to talk about products of rings, and well, the Chinese Remainder Theorem would be harder to discuss
14:42:08 <Cale> Got to use the level of generality or specificity which is appropriate to the situation :)
14:42:35 <monochrom> Yes we add laws and retract laws all the time.
14:43:15 <Cale> Sometimes it's nice for the things which specify notations on terms in the first place to impose very few laws
14:43:38 <Cale> and then impose additional laws with extra concepts -- which is what we do in ring theory quite a lot
14:43:54 <nitrix> Is there less repetitive variant to this? https://ideone.com/dKfMrE
14:44:36 <peutri> yes, but it's got other drawbacks
14:44:58 <Cale> nitrix: Whenever you have a type for which the number of pattern matches on the type is less than the number of constructors of the type, you can consider taking the results of those pattern matches, and packing them together into a record
14:45:28 <Cale> and then defining constants corresponding to your former constructors
14:46:42 <Cale> It's hard to say how you might use this enumeration elsewhere
14:47:05 <Cale> But perhaps this is just a newtype of Int
14:47:47 <Cale> Maybe it's a little more than that though
14:47:56 <ChaiTRex> nitrix: Since your enumeration isn't consecutive, you're going to need to implement all methods of Enum.
14:48:01 <Cale> Maybe it's pairs of an Int and some handler for the command
14:48:11 <nitrix> packetAddCommand :: Packet -> Command -> Packet;   sendPacket :: Packet -> IO ()
14:48:46 <Cale> Oh, that too, assuming you actually use Enum
14:49:21 <Cale> Enum is kind of an awkward class because it's trying to be two kind of unrelated things at the same time
14:49:54 <nitrix> They're constants for a protocol. I serialize from/to them to an AST, to make things nicer internally, but was really hoping to not have to duplicate the definitions like that.
14:49:59 <Cale> Namely, it's trying to specify the meaning of the list iteration syntax, and it's trying to be a way to convert back and forth from Int
14:50:42 <Cale> nitrix: If it was just a bunch of newtype-wrapped constants, how would that affect the rest of your program?
14:50:54 <Cale> like
14:51:10 <Cale> commandQueryTickCount = Command 0xb
14:51:12 <Cale> etc
14:51:27 <nitrix> There's like 20 lines of code so far. Started to use Haskell again yesterday :P
14:51:56 <nitrix> Myeah, but then you can't pattern match on the constructor, you don't get help for the type system either. It's a bland `Command Int` :/
14:52:08 <Cale> Sometimes it's nice to explicitly enumerate everything because the compiler will check that you've handled every case
14:52:31 <Cale> However, in any case where you would have pattern matched
14:52:41 <Cale> What you then do is instead add a field
14:52:44 <nitrix> I'll go with that. I wish it could ensure the conversions back and forth are symmetric.
14:53:06 <Cale> So that the specification of what a command *is* includes the conclusion of whatever pattern match you were about to do
14:53:35 <Cale> It might turn out that this is annoying, if there were going to be enough pattern matches
14:53:58 <ChaiTRex> nitrix: If you want that assurance, you could use a bidirectional map or something.
14:54:02 <Cale> So, deciding on a representation can be tricky
14:54:15 <mcglk> I don't wish to start some major controversy, but have there been any updates to the GUI situation in Haskell?
14:54:18 <Cale> Ah, and yeah, maybe the right thing is some kind of bimap here
14:54:38 <Cale> mcglk: Um, updates since when?
14:54:48 <Cale> mcglk: and to what situation?
14:55:04 <Cale> mcglk: There are a bunch of GUI libraries of many different styles
14:55:49 <mcglk> From the HaskellWiki: "There is a large number of GUI libraries for Haskell. Unfortunately there is no standard one and all are more or less incomplete. In general, low-level veneers are going well, but they are low level. High-level abstractions are pretty experimental. There is a need for a supported medium-level GUI library."
14:55:52 <nitrix> ChaiTRex, Cale: I dismissed that idea early on, but you might be onto something. Realistically I'll probably never be matching directly on the command. It'll be some sort of deserialization that can lookup a map just fine. Let's see how it evolves :P
14:56:06 <Cale> mcglk: hmm, that seems like an ancient remark
14:56:20 <monochrom> No change to GUI.
14:56:36 <Cale> mcglk: I don't know what the original author meant by low-level vs. high-level
14:57:06 <Cale> But there are many libraries at all different levels of abstraction. Usually the direct complete bindings to big C or C++ libraries are a bit lower level.
14:57:11 <solonarv> perhaps "low-level" = "thin wrapper over a C/C++ library"
14:57:42 <Cale> But even they can be substantially nicer than using the original C library
14:59:32 <Cale> There have been cases where we took a GTK application and added some Reflex to it in order to get some of the benefits of FRP without necessarily writing a complete reflex-gtk binding (which is a thing that would be great if someone did it, but it's a bit of a sizeable undertaking)
14:59:32 <mcglk> . . . which, oddly, is why I'm asking if there've been any updates since then.
14:59:52 <Cale> Personally, I like using reflex-dom as a GUI library
15:00:34 <peutri> for a counterpoint, i don't "like" doing UI, but I've been using quite a bit of gi-gtk lately
15:00:40 <Cale> If you build your application with ghc, you get a desktop application that runs in native code, but behaves the same as the web application via a gtk-webkit widget
15:01:03 <Cale> and building for mobile is also reasonably possible
15:01:17 <Cale> (using reflex-platform or perhaps Obelisk)
15:01:22 <mcglk> Well, that's good; I have a starting point for reading up on this. Thanks!
15:07:35 <sm[m]> I believe there are 3 or more that multiple people have used for real and said "hey, this actually works great"
15:08:29 <monochrom> which one?
15:09:08 <sm[m]> the latest gtk one, fltkhs, several FRP'y and/or web-y things (reactive-banana.. threepenny.. reflex.. miso.. ?)
15:09:26 <mcglk> threepenny hasn't been updated in some time.
15:11:24 <sm[m]> uploaded 4 months ago, sounds not bad
15:14:17 <sm[m]> there's qt ones too
15:14:44 <sm[m]> but still, very few folks building GUIs with haskell
15:37:24 <adius> For a quick way to build a GUI app I can recommend gloss
15:37:32 <adius> E.g. I built https://github.com/ad-si/Perspec with it
15:37:59 <adius> That is if functionality is more important than looks 😛
15:40:16 <monochrom> um where is the perspec.cabal file?
15:40:35 <adius> It uses stack, which generates the cabal file from the package.yaml file
15:41:46 <monochrom> It was a rhetorical question.
15:43:11 <sm[m]> nice app! needs screenshots
15:45:51 <adius> monochrom: 🤨
15:46:05 <yushyin> does not build with cabal-install
15:46:27 <yushyin> sad :(
15:46:34 <adius> sm[m]: Thanks! Yeah, the screenshots are a little lacking
15:47:55 <adius> yushyin: Am I supposed to commit the cabal file as well?
15:48:14 <monochrom> It is up to you which users you care about.
15:48:15 <sm[m]> adius: yes, most folks think so. Otherwise the cabal people come after you with pitchforks :)
15:48:25 <monochrom> But don't pretend that stack is standard.
15:49:07 <sm[m]> adius: the brew install command worked on catalina, but open -a Perspec fails because it's unsigned
15:50:22 <sm[m]> but the open Finder, control click, option click on Open trick still works
15:51:06 <adius> I guess this answers it: https://github.com/commercialhaskell/stack/issues/5210
15:51:26 <adius> > I'm moving towards recommending that hpack-using projects store their generated cabal files in their repos
15:51:28 <lambdabot>  <hint>:1:93: error: parse error on input ‘in’
15:53:21 <adius> That's nowadays the default behavior for many apps from brew cask. I don't think there is an easy solution, is there?
15:54:15 <monochrom> It is true that it is awkward to include a generated file in a pristine source tree.  I sympathize with that.
15:54:33 <adius> monochron: I care about all users =). Gonna include the cabal file in the future. Thanks for the heads up!
15:55:04 <monochrom> Especially issues such as getting out of sync.
15:56:00 <sm[m]> I just added https://github.com/sol/hpack/issues/380 to the above issue, I think that would be a big help
16:00:01 <adius> sm[m]: Good to know, gave it a 👍
16:00:31 <sm[m]> adius: more user testing, if you want it.. It's cool to see a haskell GUI app that's simple to install and has a bit of polish - nice icon etc. It's a pity you see an extra "exec" icon in app switcher once you load an image. It would be nice if the app window had a file chooser button as well, I suspect dragging from finder is kind of a rare gesture these days. And, I'm sorry to tell you but after outlining the image region I
16:00:31 <sm[m]> couldn't figure out how to make it do the thing, even after reading the doc :)
16:01:01 <adius> pressing Enter 😅
16:01:41 <sm[m]> Aha, secret unlocked. :) Also, I first tried to drag the handles
16:02:44 <sm[m]> aha.. file saved. I was hoping to see the result on screen immediately
16:02:46 <sm[m]> but that's nifty
16:02:57 <adius> Haha, I feel you, the affordance is pretty poor.
16:03:03 <sm[m]> thanks for the tool
16:04:56 <adius> I'm aware of most of the problems, but the hack of wrapping gloss with Platypus has a lot of constraints. So some are actually not fixable, but yeah, the UX can nevertheless definitely be improved
16:05:13 <adius> Glad you like it =)
16:05:22 <adius> Btw the best way to use it is actually via the CLI
16:08:11 <adius> Call it like `/Applications/Perspec.app/Contents/MacOS/Perspec "$PWD"/image.jpeg`
16:10:16 <sm[m]> so for "GUI where you don't need widgets", we should include Gloss on the list
16:10:55 <adius> Something else: Is there an easy way to execute some code stored in Text ( e.g. Python) without having to write it to file first?
16:11:31 <sm[m]> you could pipe it to a command that can execute stdin
16:11:45 <adius> something like `runCodeWith:: FileContent -> PathToInterpreter -> IO Stdout
16:11:46 <solonarv> depends; if the interpreter for the other language can run code f from not-a-file, then tes
16:12:19 <adius> Ah right, I can pipe it to the interpreter. Stupid me 🤦‍♂️
16:12:20 <adius> Thanks!
16:12:43 <sm[m]> also there's a few python things on hackage
16:13:29 <sm[m]> piping to stdin reliably will be fiddly
16:15:05 <sm[m]> but also finding a python thing on hackage that works will take a while
16:16:10 * sm[m] thought there was an inline-python, but no
16:16:57 <adius> I need this for a hook system for TaskLite, so the interpreter is specified at runtime and I need a generic solution
16:18:23 <adius> Ah shit, I also need to be able to provide data via stdin. So i guess that's not working, right?🤔
16:18:37 <johnbk> Hello all, I've been learning haskell for a while now and looking for a place for code review and mentors. I don't write code as a profession so I'm missing outside opinions on what I'm doing. I've posted on code review stackexchange, but not many people there use haskell and I haven't gotten any responses. Any tips on resources would be great. 
16:18:54 <sm[m]> there's also http://hackage.haskell.org/package/cpython . But if lua is an option, hslua might be easier
16:19:26 <sm[m]> you can open a process and send data on its stdin
16:19:45 <adius> Yeah first class support for hslua is planned, and support for evertyhing else via simply execution script files
16:20:02 <sm[m]> nice
16:20:58 <sm[m]> welcome johnbk . Aside from linking your work here or on the haskell reddit, there's a site which specialises in review of puzzle solutions - exercism.io ?
16:21:05 <adius> But that's the question: Is there a https://hackage.haskell.org/package/process-1.6.8.2/docs/System-Process.html#v:readProcess like function where I can also specify the content of the script
16:21:28 <adius> Which does not just write it to a temp file (which feels pretty stupid)
16:22:06 <Cale> Execute a shell and write to it?
16:22:38 <sm[m]> I hear you.. well if you cat a script into python or bash, and the script then reads from stdin, can't you just cat more ? Or does that not work ?
16:24:03 <ChaiTRex> sm[m]: You don't cat a script into whatever. You do something like running `python whatever.py` or `bash whatever.sh`.
16:24:36 <adius> I can do `echo 'print("test")' | python`, but then how is the data supposed to be added ^^
16:24:48 <sm[m]> adius wants to run a script that's not on the filesystem
16:25:31 <ChaiTRex> Then you can can do `python -e 'whatever'` or `bash -c 'whatever'`, I think.
16:25:33 <Cale> I think it's not stupid to actually write the script you want to run somewhere, so that it can be passed to the shell wholesale
16:25:55 <ChaiTRex> Use explicit command argument array not just a single string containing the command.
16:26:43 <ChaiTRex> Sorry, python -c
16:27:11 <Cale> It's entirely possible to run bash and pass it a script on its stdin, but yeah, you need to interleave any input that is meant to be passed along from bash to whatever bash ran then.
16:28:20 <Cale> Since that's awkward, just writing the whole script and then executing it seems more sensible a lot of the time. Or you can just execute the programs that bash would have executed.
16:28:29 <Cale> i.e. write the script in Haskell
16:28:43 <ChaiTRex> You can also use FIFO something or other.
16:29:04 <sm[m]> yup
16:29:07 <sm[m]> on unix
16:29:20 <johnbk> Thank you sm[m] I'll check that site out. I don't have time now, but I will try posting here over the weekend.
16:29:36 <solonarv> can you do something like mounting part of your program's binary or memory as a file?
16:30:05 <ChaiTRex> solonarv: Cross-platform would be difficult.
16:30:41 <solonarv> yeah, I know. I was wondering if it was at least possible to do this on e.g. linux
16:31:56 <ChaiTRex> Yeah, you can get a ramdisk going on Linux and write a file into it.
16:32:16 <ChaiTRex> tmpfs, I think.
16:32:44 <solonarv> I actually specifically meant to *not* write a file somewhere (no copying)
16:33:14 <ChaiTRex> Hmm, I don't know.
16:34:43 <ChaiTRex> I suppose you could write a custom FUSE filesystem or something.
16:37:24 <sm[m]> adius: I have the feeling documenting how this works for a user might give some ideas
16:37:37 <sm[m]> what do you want to tell them ?
16:41:36 <adius> I have a config file where users can directly specify short hook scripts. The config file is then loaded into the haskell app. Therefore I need to find a way to execute the code from the haskell app.
16:42:24 <solonarv> ah, I see. then you can probably get away with piping them into stdin. 
16:42:32 <adius> I think I'll give `python -c` a try, and if that doesn't work. I'll stick with writing it to a temp file and then executing it
16:43:36 <adius> But my app is also passing some data to the script via stdin, so `echo 'print("test")' | python` wouldn't work (i guess), but `data | python -c 'echo 'print("test")'` should work
16:44:24 <sm[m]> your app will pass data on stdin ? And the user could too, interactively ? First one, then the other ? interleaved ?
16:47:12 <adius> The app executes a hook which it passes some data along (e.g like a pre-commit hook, where the data is the commit message)
16:47:41 * sm[m] wonders if it's possible to write to stdin initially and then attach that stdin to the terminal
16:47:54 <adius> The data is provided via stdin to the script, and the script is defined by the user in the config file
16:48:37 <adius> Sorry for the confusion. I should go to bed. 😅
16:49:40 * adius wonders the same =P
16:50:22 <sm[m]> or maybe lua's enough!
16:50:36 <sm[m]> if it's good enough for pandoc..
16:51:10 <sm[m]> but, I bet that is possible
16:51:13 <sm[m]> but not cross platform.
16:51:16 <adius> Had some discussions about this with TaskLite users. They said it's not good enough =P
16:51:36 <sm[m]> bah, fire those idiots
16:52:12 <adius> But this was also an idea I had: If i provide only lua binding, can users they call python code from the lua script? 
16:52:26 <adius> *can users then
16:52:26 <sm[m]> I bet they could
16:52:40 <sm[m]> the miscreants
16:55:53 <adius> I need to go to bed now. I'll try out the different options tomorrow and let you know  how it went. If anyone has more insights if it's possible to write to stdin initially and then attach that stdin to the terminal, let me know 😄.
16:56:03 <adius> Thanks for your help! Bye!
16:56:38 <ChaiTRex> adius: The program expect does that.
16:57:06 <ChaiTRex> adius: It can write to stdin initially and then allow the user to write to it interactively afterwards. Not sure how it does it, but it does.
16:59:29 <adius> TIL `expect`
16:59:57 <adius> ChaiTRex: Thanks for the pointer. Maybe I'll find something about it on the interwebs tomorrow
17:00:49 <ChaiTRex> adius: No problem.
17:06:29 <justsomeguy> What do the terms boxed and unboxed mean? Is it just heap vs stack allocated?
17:07:16 <Axman6> it's basically the difference between whether a piexe of data is referred to by a pointer to it or if it is inline with the object that contains it
17:07:25 <ChaiTRex> justsomeguy: Not necessarily. Boxed means it's off on the heap by itself. Unboxed means that it's written directly into the containing data structure.
17:08:07 <Axman6> so, data Foo = Foo Int {-# UNPACK #-} !Int is roughly equivalent to struct Foo { int * a; int b}
17:08:42 <ChaiTRex> justsomeguy: The containing data structure can be on the heap, so unboxed things can be on the heap.
17:09:11 <Cale> and not just a pointer to it, but a pointer to code
17:09:28 <Axman6> when we talk about unboxed and boxed vectors, an unboxed vector of Int has the ints sitting tontiguously in memory, like a standard array in C, where a boxed vector is an array of pointers to values sitting elsewhere in the heap
17:10:07 <Cale> Boxing serves two purposes: to implement polymorphism (all pointers have the same width, so the same generated code will work on any boxed data types so long as it doesn't care to inspect the values, and type variables reflect that)
17:10:12 <Cale> and to implement lazy evaluation
17:11:12 <Cale> The first time you jump to the piece of code pointed to by a boxed thing, it will compute the thing, and then rewrite the pointer to point at a shorter piece of code which simply returns the result
17:18:34 <justsomeguy> So, a boxed value is implemented as a reserved area of contiguous memory, whereas an unboxed value is implemented by combining multiple non-contiguous memory locations.
17:18:53 <justsomeguy> ...does that sound right?
17:19:43 <Axman6> I think you have it backwards
17:20:06 <monochrom> I think completely orthogonal.
17:20:52 <monochrom> pointer to heap object = boxed.  That's all.
17:21:28 <monochrom> no further deferencing needed = unboxed, if you want this completion.
17:22:17 <monochrom> My carefully crafted legalese is such that you can't deduce the naively wrong "unboxed is never in heap", for example.
17:22:25 <justsomeguy> Oh, right. I misread your first comment and mixed up the terms boxed/unboxed, Axman6.
17:23:02 <monochrom> btw "pointer to heap object" is exact wording from GHC user's guide.
17:23:03 <justsomeguy> monochrom: That is helpful, thanks.
17:26:00 <justsomeguy> ... I'm going to have to look up what a piexe is, and what it means to be inline, and what the {-# UNPACK #-} pragma does later on.
17:26:20 <Axman6> it wa ssupposed to be piece
17:26:35 <Axman6> uh, peace, far out
17:26:39 <Axman6> have not had coffee yet
17:26:45 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated
17:27:20 <justsomeguy> Axman6: Ah, ok, that makes more sense.
17:28:54 <justsomeguy> GHC seems like a remarkable work of engineering.
17:29:18 <Axman6> shh, don't tell anyone!
17:29:51 <monochrom> They truly figured out a great way of doing lazy evaluation.
17:30:37 <Axman6> mutation _all the time_
17:31:14 <monochrom> And I feel that as a corollary, it's a pretty good story for higher-order functions too.
17:44:14 <justsomeguy> So I'm reading this book "Introduction to recursive programming", and all the math formulas translate almost directly into Haskell. It's pretty neat.
17:45:17 <justsomeguy> (Guards and pattern matching help to make it look very similar.)
17:49:26 <monochrom> That's an extremely pricy book on amazon.
17:49:55 <monochrom> I prefer very simply https://www.smbc-comics.com/comic/recursion
17:50:18 <monochrom> Just before the pandemic caused university closing, I actually made that poster and posted at school.
17:50:30 <justsomeguy> The price increased recently, It was much less expensive when I bought it (around $40 US.).
17:50:39 <monochrom> and furthermore it hit upon me "why don't i do the same to the Cantor set?!"
17:51:05 <monochrom> Ah, $40 is much more approachable, yeah.
17:51:36 <monochrom> I was really like "dude, even Functional Differential Geometry is cheaper..."
17:52:04 <monochrom> even TaPL is slightly cheaper.
17:52:25 <justsomeguy> Amazon can really gouge you on book prices sometimes. If something becomes suddenly popular its not unusual for them to add $30 to the price.
17:52:56 <justsomeguy> Awesome comic btw.
18:42:05 <DigitalKiwi> i painted more stickers https://twitter.com/ArchKiwi/status/1250600070636097536?s=20
18:42:44 <meadt> hi
18:43:02 <monochrom> neato
18:43:52 <DigitalKiwi> some of them have glitter some of them are gloss some of them are matte
18:44:26 <DigitalKiwi> the first two were supposed to be at zurihac...
18:58:42 <meadt> not normally a question Haskellers have to consider, but how is Lazy Evaluation actually implemented? If writing a compiler for a lazy functional language, what would this consist of?
18:58:53 <meadt> (anticipating having to do something like this at type level)
18:59:59 <meadt> the easiest context to consider this in is writing a simple compiler for a toy language
19:00:47 <koz_> meadt: Depends on what you mean by 'lazy evaluation'. There's a couple of ways - I think SPJ's old-af book has a bunch of writing on this subject.
19:01:24 <meadt> well, the typical use case is the function 'take'
19:01:42 <koz_> I'm not really asking about use cases.
19:01:46 <koz_> What's your underlying evaluation model?
19:01:57 <koz_> 'Lazy evaluation' will mean different things depending on what that is.
19:02:00 <meadt> ah, im sure. 
19:02:10 <koz_> If your model is 'exactly what GHC does', then there's an answer.
19:02:13 <koz_> However, you didn't say that.
19:02:24 <meadt> well, whatever is that of the haskell type system... like, whatever evaluation model we have at type level
19:02:34 <koz_> The type system doesn't contain an evaluation model.
19:02:39 <koz_> Type checking occurs long before.
19:03:06 <koz_> Or are you asking 'how does GHC do type family resolution etc?'?
19:03:29 <meadt34> seems like that might be the first thing that would have to be implemented...
19:03:42 <koz_> Depends on your type system.
19:04:02 <koz_> If your type system is STLC, then it actually doesn't matter, because to typecheck a program you have to evaluate everything anyway.
19:04:04 <meadt34> what is haskells? hindly miller? or some extension therof
19:04:18 <koz_> System F_Omega, with a bunch of stuffs.
19:04:34 <koz_> HM is a subset of System F (specifically that which contains only rank-1 polymorphism).
19:04:38 <meadt34> ok, i think it might help to have a more concrete example of what i actually want to do
19:04:43 <koz_> I agree.
19:05:08 <meadt34> so, if I have a "hetrogenous stream" annotated by a phantom parameter, which is a "type level stream of types"
19:05:16 <koz_> (also, System F_Omega plus stuffs is _GHC_'s model, just to be precise)
19:05:50 <monochrom> You can start with call-by-name.  It's much easier and has the same termination property.  It is just less efficient.
19:06:11 <koz_> You could also compile everything down to SKI. It's as lazy as it comes. :P
19:06:18 <meadt62> and i wanted to write a version of take for this, i wouldn't want the typechecker to get stuck trying to typecheck this infinite stream of types
19:06:39 <koz_> meadt62: I think you lost a post there.
19:06:47 <monochrom> typehceking terminates for all programs, not just terminating programs.
19:06:48 <koz_> Oh, wait, no, I just can't read. :P
19:07:10 <monochrom> It's theorem proving that's non-terminating.
19:07:54 <koz_> I'm... not actually sure what a 'type-level stream of types' even is.
19:08:12 <koz_> Is your program source a stream which could be infinite or something?
19:09:04 <oats> koz_: you don't have in-home typing?
19:09:11 <oats> we get ours through the municipal utilities
19:09:22 <oats> price isn't bad, maybe $40/month
19:09:25 <oats> types straight to the house
19:10:55 <oats> I still can't believe sometimes that all I have to do get my types now is turn the knob on a faucet
19:11:49 <oats> back in my day we had walk 5 miles, uphill both ways, with a bucket on our shoulder to town, there was a fresh type-spring there
19:11:53 <monochrom> I use it for toilet paper.  It's why I don't need to buy toilet paper.
19:12:16 <monochrom> All those people panick-buying toilet paper are python people.
19:13:01 <oats> pythons are just pythoids in the category of noncategoricalisms
19:13:09 <monochrom> Type erasure is when I flush the toilet.
19:15:39 <meadt28> a type level stream of types e.g. xs :: Stream Type
19:16:16 <monochrom> Have you coded that up?
19:16:37 <meadt28> well, we have hetrogenous lists, its just that without a basecase
19:17:17 <monochrom> Have you coded that up?
19:18:19 <monochrom> Any of "yes", "no", "some" ought to be so much less effort to enter than that long sentence, no?
19:18:40 <d34df00d> In Idris sure.
19:20:47 <monochrom> Is it just me or is it true that most schools in most countries are such pompous fools as to teach everyone "you must never give direct short answers, you must ramble on and markov-chain an answer 3x longer than the question and still somehow evade the question altogther, this is called informative answering"?
19:20:53 <meadt> yes
19:21:42 <meadt> but streams at type level seem like a sticking point, since I'm not sure how to approach their lazy evaluation
19:21:52 <ornxka> tfw you answer your exam questions with the socratic method
19:21:58 <d34df00d> I think it starts in literature lessons, when we are taught to answer deeply and in long sentences about what the color of curtains in a room described by the author means.
19:23:16 <monochrom> There is nothing to evaluate.
19:23:42 <meadt> well, the infinite burden placed on the typechecker
19:25:09 <meadt> i guess if its not to be called type level lazy evaluation, then maybe "lazy typechecking" would be better - if "evaluate" implies value level and runtime
19:25:39 <d34df00d> Why not just python.
19:26:10 <meadt> i dont think that language is expressive enough to encode type level programming...
19:28:11 <meadt> type family Repeat (a ::k) :: [k] where Repeat x = x ': Repeat x
19:28:14 <meadt> :t repeat
19:28:15 <lambdabot> a -> [a]
19:30:04 <meadt> with lazyness at type level i can write type family Take, and have Take (n :: Nat) . Repeat (x :: k), not result in a non-terminating program resulting during typechecking
19:30:17 <meadt> s/./$
19:31:19 <meadt> but if lazyness doesnt come with GHC out-of-the-box, then it raises the question as to its implementation
19:35:10 <meadt> thought it seems impossible on seccond thoughts, that you would be able to modify the type checking process, using a type level program 
19:35:24 <meadt> is it possible to implement lazy evaluation in a strict language?
19:36:15 <meadt> i think i can remeber something about lazy by defauly vs strict by default, and that either could be implemented within the other
19:37:52 <meadt> and also, vaguely, something about stream fusion down to the program producing the values (repeat) when being folded...
19:38:35 <meadt> type level fusion seems about as daunting as type level lazyness though... and I'm not sure if fusion requires lazyness
19:39:01 <meadt> hmm, well it shouldnt since its just a "rewrite"
19:39:48 <meadt> so maybe I would have to interpret something with a type level interpreter, and have a way to refactor this, to commute the consumer into the producer. i guess that would be a way to get lazyness.
19:40:43 <meadt> does that make sense? and if so, is there a less overkill way to achieve the same result, of lazy typechecking?
19:41:00 <meadt> does GHC rely on fusion like this?
19:42:45 <meadt> i dont really want to have to have the way i write types be different from normall syntax... not sure about this whole interpreting and rewriting idea
19:48:13 <monochrom> No, none of that makes sense. I'll go out on a limb and bet you have never learned existing type-checking algorithms and you're making it all up.
19:49:26 <oats> my mind hurts trying to think about type-level list fusion
19:49:42 <monochrom> There is no list fusion at the type level.
19:53:11 <monochrom> Don't hurt your brain on---let me make something up---the Galois adjunction between the forgetful functor of type erasure and the forgetful functor of term erasure.
19:54:21 <meadt96> well, maybe i only need fold/unfold fusion...
19:56:06 <meadt96> so instead of having a Stream of Type's, it would just store (s->(a,s)), which could be passed more easily
19:56:38 <meadt96> which I think is called, using Church encoding...
19:56:59 <meadt96> that could be a workaround to the whole lazyness issue at type level
20:04:57 <fishooter> Is it common to call functions like addClientSTM if they are in STM monad?
20:06:24 <monochrom> If you don't have a non-STM addClient, you may as well just say addClient.
20:07:06 <koz_> Usually we do that kind of thing for situations like replicate/replicateM.
20:07:19 <monochrom> Typically you have a definition like this: f x = atomically ( ... g x ... )
20:07:31 <fishooter> I'm little bit confused about the structure of the code of the STM chat server in Marlow's book, because it mixes the two together
20:07:45 <fishooter> for example there is newClient in STM, but removeClient is in IO
20:07:53 <fishooter> it just seems inconsistent
20:08:01 <fishooter> so I was wondering what is the recommended practice
20:08:05 <monochrom> If you want to give the "... g x ..." code a name, fooSTM is a great name, because it's honest-to-God tied to STM.
20:08:59 <monochrom> If you want to give f a better name, fSTM is a terrible name, because nothing says the user of f needs to know you're using STM as an implementation detail
20:09:04 <fishooter> is the rule of thumb something like -- if you want it to compose, leave it in STM, if not, then do atomically to get IO?
20:09:22 <fishooter> I will not expose any of this :)
20:09:23 <monochrom> Yes.
20:09:34 <fishooter> ok, thanks :)
20:09:52 <monochrom> But I'm against rule of thumb.
20:10:50 <monochrom> My rule of thumb is to rid the world of rules of thumbs.
20:11:03 <koz_> monochrom: You mean 'rules of thumb' amirite? :P
20:11:20 <monochrom> I don't know. If there are many rules, maybe there are also many thumbs.
20:11:28 <solonarv> no, there are lots of thumbs involved
20:11:32 <oats> rule of thumbs. you've got two of 'em, right?
20:12:09 <monochrom> I also feel that in this the 21st century of facebook and youtube, maybe rename it rule of likes.
20:12:24 <monochrom> meaning that if you do it, you get likes, thumbs up.
20:12:52 <monochrom> And the symmetry is restored, because there are also rules of dislikes.
20:13:00 <monochrom> "the force is balanced"
20:14:30 <monochrom> "Hi I have two pics, one is my cat naked, another is me naked, which one should I upload and share"
20:14:47 <monochrom> the rule of likes is to upload the cat pic and skip your pic
20:17:26 <monochrom> Rather than a rule of thumb, I have a definition, and it's both simpler and more correct than the rule of thumb.
20:18:59 <monochrom> If your code is the whole atomic transaction, then it needs atomically.  If your code is only part of a transaction, therefore not atomic, then it needs to omit atomically.
20:19:57 <monochrom> The whole point it's called atomically.
20:19:57 <fishooter> is there an easy way to generate all function imports explicitely in existing code? I don't know from which packages some functions come from :-)
20:21:06 <monochrom> sounds like you're mixing up "module" and "package".
20:21:19 <monochrom> I'll autocorrect you to "module".
20:21:57 <monochrom> ghc has a flag -ddump-minimal-import, it will tell you
20:23:08 <fishooter> thanks :) yes, I have been programming in too many languages, these things get mixed up after some time
20:23:41 <monochrom> err, plural, -ddump-minimal-imports
20:29:55 <fishooter> yeah, I found out :)
20:30:11 <fishooter> I always keep forgetting this, but if I have 
20:30:19 <fishooter> f x = g $ h x
20:30:24 <fishooter> how can I eta-reduce this?
20:30:37 <monochrom> First remove $
20:30:42 <monochrom> f x = g (h x)
20:31:01 <monochrom> Removing $ is the first step of understanding and leaving cargo-culting behind.
20:31:08 <monochrom> Then:
20:31:16 <monochrom> f x = (g . h) x
20:31:22 <meadt30> is there a name for Foo a b = (a,a->b), as an encoding of `b' as `a' ?
20:31:22 <monochrom> f = (g . h)
20:32:13 <meadt30> if I wanted to abstract over the program used to "unfold" the stream?
20:32:13 <fishooter> ah, ok so maybe the reason why that didnt work
20:32:19 <fishooter> was because I actually had
20:32:25 <fishooter> f x y = g $ h x y
20:32:38 <fishooter> sorry for bad simplification :)
20:32:44 <monochrom> you can eta away the y
20:32:55 <fishooter> but I can't eta away both?
20:33:02 <monochrom> (f x) y = (g (h x)) y
20:33:07 <meadt30> I think it makes sense if the stream has to have a program generate the types, whereas a list can be cons'd to
20:33:17 <monochrom> err, my mistake
20:33:34 <monochrom> (f x) y = g ((h x) y)
20:33:47 <fishooter> f y = g . h x
20:33:54 <monochrom> (f x) y = (g . (h x)) y
20:34:02 <monochrom> f x = g . (h x)
20:34:23 <fishooter> but to be honest I find it less obvious than listing both x and y
20:34:27 <monochrom> Do the algebra, don't use intuition (you have none), don't pass Go, don't collect $200
20:34:42 <Axman6> % :t Store
20:34:43 <yahb> Axman6: ; <interactive>:1:1: error:; * Data constructor not in scope: Store; * Perhaps you meant one of these: `StoreT' (imported from Control.Comonad.Store), variable `store' (imported from Control.Comonad.Store)
20:34:48 <Axman6> % :t StoreT
20:34:48 <yahb> Axman6: forall {w :: * -> *} {s} {a}. w (s -> a) -> s -> StoreT s w a
20:34:58 <monochrom> Right, I would keep it as "f x y = g (h x y)"
20:35:21 <Axman6> monochrom: looks like the Store Comonad to me
20:35:33 <Axman6> uh, meadt* -_-
20:37:11 <solonarv> morally, data Store s a = Store s (s -> a)
20:38:03 <solonarv> instance Monoid s => Comonad (Store s) where extract (Store e f) = f e; duplicate = iDontRemember
20:42:13 <meadt> it just makes a store of itsself for duplicate I think
20:42:56 <johnw> something like ... duplicate (Store e f) = Store e (\e -> Store e f)?
20:43:18 <solonarv> no, the Monoid instance is used somehow
20:43:35 <solonarv> I don't remember how exactly, you can go check the source of whichever package has it
20:44:27 <crestfallen> hi - the commented line doesn't work and I guessed at the last line which does work. This is an example online that goes back 4 years I think. please critique:  http://ix.io/2ieY  
20:45:19 <solonarv> crestfallen: what does the error message say?
20:45:31 <Axman6> I think the second line could just be _ <> _ = FirstExisting Nothing
20:45:43 <solonarv> no, that's wrong
20:45:47 <Axman6> but those two lines don't do anywhere near the same thing
20:46:09 <Axman6> crestfallen: what semantics do you want <> to have?
20:46:26 <monochrom> What does "work" mean?
20:46:42 <Axman6> meadt95: the type you asked about before, type Foo a b = (a,,a -> b) is the Store comonad
20:47:08 <meadt95> basically, I dont have to choose which way to encode the stream of types, just that a stream of types can be recovered somehow - and that also there exists a way to get this to similarly produce a list of types, after which, (it having been lazily consumed) i dont need it to be encoded as something that can be unfolded in some abstract way
20:47:11 <Axman6> data Store s a = Store s (s -> a)
20:47:21 <meadt95> right
20:47:45 <meadt95> so then the type of the hetrogenous stream has a phantom parameter which is a store of a stream of types
20:47:47 <johnw> solonarv: in http://comonad.com/reader/2018/the-state-comonad/ it's (State s) which is a Comonad using Monoid, but Store does not have such a constraint.
20:48:21 <johnw> duplicate (Store f s) = Store (Store f) s, even simpler
20:48:35 <meadt95> thats what i meant^
20:49:24 <meadt95> but yeah, thats the wrong type parameter for Comonad (Store f)
20:49:58 <monochrom> I kid you not.  When I was a beginning grad student, the area being formal methods (remember this), I went to a senior grad student's PhD defense to see what it's like.  At some point a prof argued with the grad student over "do dataflow diagrams count as formal?", grad student said no, prof kept pressing "but why? what's missing?.  And my supervisor (also his supervisor) "helped" by chiming in "yeah, what is 'formal'?"
20:50:19 <monochrom> The grad student was like "oh god..."
20:51:18 <monochrom> It's good, it got me starting to think "how would I answer that? how should I? why do we call this formal methods?".  So I got a heads up, I had five years (or more) to prepare.
20:51:26 <johnw> what have you learned about the meaning of formal since?
20:52:30 <meadt> but finally, it needs to be both a store of a stream of Type *and* a store of list of Type...
20:53:30 <monochrom> I think it will not be wise to give a formal definition (pun!).  But there are some aspects like: machine readable, use given rules not make up new rules on the spot, don't interpret, Dijkstra's "let the symbols do the work"
20:53:38 <johnw> I think of formal as: assumes nothing beyond a given set of axioms.
20:53:45 <monochrom> Yeah.
20:53:52 <meadt> so that when I write `take', I can strictly evaluate this (similar to with a bang pattern) and recover the list of types that is the phantom parameter to the hetrogenous list
20:55:26 <meadt> and after making this conversion to not strictly infinite, I can do HCons as a more usual way to generate more list
20:56:51 <meadt63> which maybe makes the stream-cons seem slightly redundant
20:57:01 <meadt63> but i guess its the only way to encode it...
20:57:53 <Axman6> I still have no idea what you're actually asking about btw
20:58:09 <monochrom> No one does.  I gave up long ago.
20:58:30 <monochrom> "type-level infinite stream" was how it begun.
20:58:43 <monochrom> "type-level fusion" was how the 1st wave ended.
20:59:00 <Axman6> somehow we went from hos is laziness implemented in Haskell to infinite lists of types at the type level in haskell, which don't seem to be related concepts to me at all
20:59:00 <monochrom> and I called them bluff.
20:59:18 <Lycurgus> is everything in ur head formal stuff or not, that seems to be the issue
20:59:32 <meadt83> unless it was a similar kind of Store wrapper around an abstracted implementation of unfold paired with the argument it takes - but that would be difficult to have produce hetrogenous types...
21:00:13 <Lycurgus> formal : based on theory(ies)
21:00:27 <Lycurgus> seen with the minds eye
21:00:33 <johnw> Socrates did a pretty good job of showing that most people's model of the world does not reduce to a consistent set of axioms. The people he questioned couldn't even define well the concepts they most insisted on.
21:00:42 <Lycurgus> not just any ol stuff in ur head
21:01:21 <johnw> "It's not that it isn't right; it's that it isn't even wrong."
21:01:36 <Lycurgus> yeah my big buggaboo on that was "truth"
21:01:59 <Lycurgus> which i also found in hs channels some people thought/think is ineffable
21:02:17 <johnw> If we say that "truth" means "defined", at least I know how to work with that.
21:02:27 <Lycurgus> (was a bugaboo between c '87 and '14)
21:02:43 <johnw> intuistionic logic FTW
21:03:08 <crestfallen> Axman6, solonarv sorry I was detained..
21:03:33 <meadt> Axman6: I'm using a Church encoding to avoid needing lazyness at type level to handle hetrogenous streams, and the type level phantom parameter - a "type level stream of types", which would otherwise crash the typechecker - which is as a result of considering fold/unfold rewrite rules, avoiding fusion at type level 
21:05:24 <meadt> then, to abstract over the church encoding, I am using Store
21:06:10 <meadt> :k HStream = Store a (Stream Type) -> *
21:06:11 <lambdabot> error:
21:06:11 <lambdabot>     parse error on input ‘=’
21:06:11 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
21:07:29 <crestfallen> solonarv, Axman6 this was an example, so I'm trying to sort out the differences of semigroup vs monoid. I know semigroup doesn't have an identity. I'm especially trying to sort out the classes monoid vs. semigroup, now that semigroup is not the superClass of monoid (??)
21:08:14 <crestfallen> the example had (<>) _ other = other   which I don't get..
21:08:30 <crestfallen> so I just guessed and wrote the last line.
21:08:43 <crestfallen> to make it compile
21:09:09 <meadt6> and then I need a way to say that Store a (Stream b) ~~~ Store a ([] b), or at least, a type family to witness this
21:09:26 <meadt6> for when "lazily" consuming the hetrogenous stream
21:09:32 <Axman6> crestfallen: why not write it as _ <> other = other?
21:09:52 <meadt6> which never actually occurs, since it was never unfolded to begin with, hence the allusion to fusion
21:10:14 <Axman6> crestfallen: without sharing the error from the compiler we're just guessing though. if you have an error you want help with, share it
21:12:45 <meadt> thanks monochrom
21:19:15 <crestfallen> Axman6 I had some other error but now that compiles with _ <> other = other  .. but how would you use that? I figured it would make more sense with FirstExisting Nothing. so I don't understand the use of the program
21:19:56 <crestfallen> or understand the use of the instance
21:21:42 <monochrom> This code come from a blog or tutorial. I bet the author explained why they even bothered.
21:24:31 <crestfallen> the first part of the tutorial is here, as per mr kmett : http://ix.io/2if6
21:26:19 <crestfallen> so the purpose of that first part is to show "something that is a semigroup but not a monoid"
21:26:27 <crestfallen> but which is which
21:27:09 <crestfallen> because wouldn't one of those have a unit ?
21:28:06 <crestfallen> so I guess they're both semigroups
21:29:16 <crestfallen> sorry I see my error. 
21:32:21 <crestfallen> so in that second part, the newtype FirstExisting , what would go into the wildcard parameter that could return other?
21:33:19 <crestfallen> in this code   http://ix.io/2if7
21:35:11 <crestfallen> monochrom ^ please answer if you have time
21:38:00 <ja> crestfallen: can't ghc tell you what goes in there? it should tell you the type
21:38:39 <monochrom> Mr. Kmett speaks English. He never just spew out pages after pages of code and add no comment.  You are misrepresenting him.  There is nothing to answer.
21:41:45 <crestfallen> monochrom there's no commentary, but I do understand that part of the blog.
21:43:37 <crestfallen> monochrom, very sorry though, I have some dyslexia. this looks much different than it did last night. appreciate your time as always
21:45:08 <crestfallen> this is the blog if anyone wants to look :  https://www.reddit.com/r/haskell/comments/3srhit/something_that_is_semigroup_but_is_not_monoid/
21:48:38 <monochrom> MarcelineVQ, you have your url after 24 hours finally
21:52:26 <Axman6> crestfallen: for reference, the line ` mappend _ <> other = other` appears to be a typo, it should just be  mappend _ other = other
21:54:41 <crestfallen> thanks Axman6 ! one sec
22:04:02 <crestfallen> http://ix.io/2iff  This is how I have it Axman6 , but getting following error: 
22:05:41 <crestfallen> http://ix.io/2ifh Axman6 
22:19:28 <Axman6> well, did you read the error?
22:21:08 <crestfallen> yup I don' t understand it. arising from the superclasses? 
22:21:26 <Axman6> No instance for (Semigroup (FirstExisting a)) is all you need to read
22:22:58 <Axman6> Semigroup is a superclass of Monoid - to make an instance for Monoid, you need an instance for Semigroup. you can do this simply by either saying instance Semigroup (FirstExisting a) where (<>) = mappend, or making the definition of (<>) be what you currently have for mappend and then use instance Monoiod (FirstExisting a) where mappend = (<>); mempty = FirstExisting Nothing
22:23:50 <crestfallen> thanks let me try that
22:24:13 <Axman6> @src Monoid
22:24:13 <lambdabot> class Monoid a where
22:24:14 <lambdabot>     mempty  :: a
22:24:14 <lambdabot>     mappend :: a -> a -> a
22:24:14 <lambdabot>     mconcat :: [a] -> a
22:24:37 <Axman6> hmm, that's the old definition, these days it's class Semigroup a => Monoid a
22:24:54 <crestfallen> yeah I'm pretty confused tbh
22:26:30 <crestfallen> first of all I need both of those import statements right?
22:26:52 <fishooter> suppose I have two function f and g with the same argument list
22:27:01 <Axman6> I thnk so, I don't know of Data.Monoid re-exports Semigroup
22:27:11 <Axman6> fishooter: what's an argument list
22:27:19 <fishooter> I can write if pred then f x y z else g x y z
22:27:38 <fishooter> Can I write (if pred f else g) x y z ?
22:27:47 <fishooter> or something like this?
22:27:49 <Axman6> yes
22:28:03 <Axman6> apart from the missing then
22:28:14 <fishooter> exactly how I've done that? :)
22:28:17 <Axman6> yes
22:28:21 <fishooter> nice :)
22:28:34 <Axman6> functions are just values
22:28:50 <Axman6> and if isn't anything special, it returns one or the other of its arguments
22:29:19 <Axman6> if is just syntax sugar for if b then t else f = case b of True -> t; False -> f
22:29:42 <fishooter> makes sense, thanks :)
22:37:36 <crestfallen> Axman6, the way you have it above I'm getting the error beginning with :  Equations for ‘mappend’ have different numbers of arguments ; firstExisting.hs:7:3-61 ;  firstExisting.hs:8:3-18
22:38:15 <crestfallen> presently looking like this:   http://ix.io/2ifq
22:38:26 <Axman6> well, you wrote it, and I can't see it :)
22:39:04 <crestfallen> pls hold on
22:39:06 <Axman6> ... that is anything at all like what I said you should write
22:39:19 <Axman6> like, I literally wrote the code for you
22:40:35 <Axman6> isn't*
23:00:14 <crestfallen> Axman6, I'm very sorry but I can't interpret how you wrote the code above. Do I need an instance of both Semigroup AND Monoid OR one or the other? Can't sort out the way you wrote that sorry
23:01:24 <crestfallen> for instance Semigroup   all we need is mappend = (<>)   right?
23:01:25 <Axman6> to write an instance for Monoid you also need an instance for Semigroup. BUT you can use the definition of mappend as your definition of (<>) by just adding instance Semigroup (FirstExisting a) where (<>) = mappend
23:01:40 <Axman6> which is what I wrote above
23:03:00 <crestfallen> oh you had mappend = (<>)  I should have tried it
23:06:37 <crestfallen> so yeah it wouldn't compile with mappend = (<>) Axman6   it compiles when I switched it round
23:09:32 <crestfallen> but 
