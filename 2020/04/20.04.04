00:20:38 <scasc-> I was trying to write a binding to a foreign library (of which the dev version is installed by `apt` in my system)
00:20:59 <scasc-> and  `stack build`  errors out on cabal:
00:21:25 <scasc-> Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: Missing dependencies on foreign
00:21:25 <scasc-> libraries:
00:21:25 <scasc-> * Missing (or bad) C libraries: liberfa, liberfa
00:22:03 <scasc-> [ ... and then a block of text about either using -L or installing it globally with the system package manager ...]
00:22:28 <scasc-> it is installed but even if I pass the location with `-L` I still get the same error.
00:24:50 <scasc-> scasc-@local:~/dev/test-binding$ find /usr -name 'liberfa*'
00:24:50 <scasc-> /usr/lib/x86_64-linux-gnu/liberfa.a
00:24:50 <scasc-> /usr/lib/x86_64-linux-gnu/liberfa.so
00:24:50 <scasc-> /usr/share/doc/liberfa-dev
00:24:50 <scasc-> scasc-@local:~/dev/test-binding$ stack build --ghc-options -L/usr/lib/x86_64-linux-gnu
00:24:53 <scasc-> Building all executables for `haskell-bench' once. After a successful build of all of them, only specified executables will be rebuilt.
00:24:56 <scasc-> haskell-bench> configure (lib + exe)
00:24:58 <scasc-> Configuring haskell-bench-0.1.0.0...
00:25:01 <scasc-> Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: Missing dependencies on foreign
00:25:03 <scasc-> libraries:
00:25:06 <scasc-> * Missing (or bad) C libraries: liberfa, liberfa
00:25:41 <scasc-> any ideas?
00:26:19 <Axman6> please don't paste that much text in the channel
01:01:15 <jusss> hello
01:29:37 * hackage ngx-export-tools 0.4.8.0 - Extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-0.4.8.0 (lyokha)
01:31:56 <sm[m]> pie_[bnc]: what about dhall
01:54:13 <pie_[bnc]> sm[m]: someone mentioned it to me and ill definitely consider it, but im looking for something more turing complete i think
01:54:56 <Rembane> pie_[bnc]: Why?
01:55:16 <Rembane> pie_[bnc]: I mean, why do you need Turing completeness.
01:56:22 <pie_[bnc]> for those missing context from earlier;
01:56:22 <pie_[bnc]> <pie_[bnc]> does anyone know any purely functional embeddable language (i.e. not an eDSL but something with an interpreter I can put in my programs) that has no effects/IO by default and that I could tack on effects/io/whatever onto with an effects library?
01:56:22 <pie_[bnc]> <pie_[bnc]> im interested in something simple but powerful i can use to write plugins with capabilities
01:56:22 <pie_[bnc]> <pie_[bnc]> so I dont want unconstrained IO in the interpreter by default
01:57:21 <pie_[bnc]> Rembane: well im not sure i _need_ turing completeness, but it might be easier to get where i want to be with it
01:58:11 <pie_[bnc]> also dhall has a pretty limited stdlib because of the kinds of properties it wants to have i think? which IIRC is possible to extend but I don;'t know how much swimming against the stream would be involved
01:58:46 <Rembane> pie_[bnc]: Okay, got it, I think your best bet is to build a DSL. 
01:59:37 <pie_[bnc]> i was hoping someone already has some kind of relatively lightweight scheme-like, but i guess the whole "separate effects" thing probably throws a wrench in preexisting solutions
02:22:29 <jackdk> pie_[bnc]: I can't point you at anything but this feels like a thing that should exist
02:25:40 <sm[m]> There’s “has no IO” and there’s “is sandboxed”. Lambdabot uses the latter approach I believe
02:28:08 <jackdk> you can't coproduct two monads to get a monad, can you? but you could say that the effects of your languages are in some monad `m` and constrain `m` using MTL classes, or typeclasses from your effect system, or...?
02:40:41 <pie_[bnc]> jackdk: IKR? :P
02:40:55 <pie_[bnc]> re: feels like something should exist
02:41:04 <pie_[bnc]> i bet you a cookie that theres papers on it already
02:41:41 <pie_[bnc]> jackdk: re the monad-y stuff, i havent the faintest clue
02:42:16 <pie_[bnc]> meanwhile reading 8.6.5 release notes (well 8.6.1 tehnically?), oh neat~ "    Added an experimental :doc command that displays the documentation for a declaration."
02:54:09 <int-e> sm[m]: lambdabot relies on SafeHaskell and the "no IO" approach (but I'm sandboxing the underlying mueval as well). yahb relies purely on sandboxing, I think.
03:17:38 <matheus23_> What's the way to deploy haskell CLI applications for usage in the js ecosystem?
03:20:03 <matheus23_> More precisely: I want to deploy executables to npm, so others just npm install xy && npm run xy. Has anyone had experience with this?
03:21:51 <dmj`> matheus23_: probably better off with docker, otherwise you'd have to assume users have a way to get ghc
03:22:24 <matheus23_> dmj`: Hmm. Okay, how does that work?
03:22:42 <dmj`> matheus23_: how does docker work?
03:22:43 <matheus23_> I've only thought about building a static executable for various platforms
03:23:14 <dmj`> matheus23_: that's one approach, bundle the executable, but Darwin for example doesn't allow static linking
03:23:23 <matheus23_> dmj`: well.. I know docker, but I guess I don't know it well enough? I'm kind of confused... don't users need docker for running anything in docker containers?
03:23:53 <matheus23_> dmj`: Oh I see. Yeah that's important
03:23:58 <dmj`> matheus23_: yes, but docker has images w/ ghc pre-bundled
03:24:32 <matheus23_> dmj`: So would that mean that someone who runs `npm i -g xy` would need to have docker installed to run `xy`?
03:24:57 <dmj`> matheus23_: no
03:25:41 <matheus23_> dmj`: And with 'ghc pre-bundled' we're talking about ghc runtime libs, right? Because users won't need to compile, so that confuses me a little too.
03:25:47 <matheus23_> Ok, interesting
03:26:59 <dmj`> matheus23_: If you can statically link a haskell executable (you'll probably need to use musl) and bundle it into a node package and deliver to linux that could be an option
03:27:37 <matheus23_> dmj`: What would be some google search keywords for deploying a 'runnable' docker container to npm? "Deploy docker npm" doesn't bear any fruits for me...
03:27:45 <dmj`> glibc can't truly be statically linked, because of dlopen
03:29:14 <dmj`> matheus23_: instead of using npm for delivery, I'd deliver your package via nix, apt, homebrew, osx installer then have the npm package assume thats installed and complain otherwise, prompting the user to visit the website and downloade the binary
03:36:10 <matheus23_> dmj`: Ok, thank you so much for that info!
03:50:36 <iphy> can anyone help me with cross compilation? I'm having trouble convincing a package that a native library it needs actually exists
03:51:17 <iphy> it turns out, cabal tries to do its checks with the system-installed ghc instead of the cross compiler
03:54:23 <iphy> https://gist.github.com/iphydf/1ed89f68f68b96b6f30b1388e9a0c95e
03:55:13 * hackage example-haskell-project 0.1.0.0 - Example Haskell Project  https://hackage.haskell.org/package/example-haskell-project-0.1.0.0 (haskellworks)
03:57:13 * hackage hw-json-standard-cursor 0.2.1.3 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-standard-cursor-0.2.1.3 (haskellworks)
04:04:13 * hackage modern-uri 0.3.2.0 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.3.2.0 (mrkkrp)
04:26:43 <pie_[bnc]> there seems to be a lot of compilers written in ocaml but i cant think of any off the top of my head written in haskell other than the haskell compilers >.>
04:27:02 <ptrcmd> pie_[bnc]: agda
04:27:17 <pie_[bnc]> oh
04:27:21 <pie_[bnc]> huh
04:28:46 <zincy_> purescript and elm?
04:31:25 <opqdonut> carp
04:31:32 <zincy_> Why is throwIO generally preferable to throw?
04:32:16 <opqdonut> to docs tell you
04:32:17 <opqdonut> > The throwIO variant should be used in preference to throw to raise an exception within the IO monad because it guarantees ordering with respect to other IO operations, whereas throw does not.
04:32:20 <lambdabot>  <hint>:1:36: error: parse error on input ‘in’
04:32:29 <opqdonut> gah, I never remember not to quote with > here
04:32:55 <opqdonut> also, throw is impure, throwIO is pure, so that's another reason
04:33:11 <opqdonut> laziness can mess up your throws but not your throwIOs
04:37:16 <zincy_> Ah thanks!
04:37:52 <zincy_> Ah right so they are synchronous exceptions but evaluation can happen at any time
04:38:21 <opqdonut> yeah, it can be hard to catch exceptions from throw
04:38:37 <opqdonut> because the thunk that throws might get evaluated outside your catch
04:38:46 <zincy_> That makes sense
04:40:11 <opqdonut> I think http://book.realworldhaskell.org/read/error-handling.html was a pretty good source on this stuff
04:40:16 <opqdonut> but it's been a while since I read it
04:42:16 <zincy_> thanks
05:33:09 <zincy_> [throwIO] ... guarantees ordering with respect to other IO operations
05:33:31 <zincy_> Is this because the exception throwing is an IO action?
05:33:46 <zincy_> Whereas throw isn't?
05:33:49 <zincy_> I am confused.
05:40:32 <edmundnoble> There are three ways to throw exceptions: precise exceptions, imprecise exceptions, and asynchronous exceptions. We'll worry about the first two.
05:41:00 <edmundnoble> Imprecise exceptions are thrown with `throw`, precise exceptions are thrown with `throwIO`. 
05:42:22 <edmundnoble> An imprecise exception is so named because throwing it is driven by *evaluation*, and evaluation is *not ordered*. So the exception is thrown by an *expression*, and *which* exception is thrown exactly is *not always precisely defined*. 
05:43:31 <edmundnoble> The expression `throw ex + throw ex2` may in particular throw either `ex` or `ex2` when it's evaluated, because `+` is strict in both of its arguments, and if it's not evaluated at all, no exception will be thrown.
05:43:49 <opqdonut> zincy_: yes, the ordering comes down to the fact that throwIO is an IO operation, and IO operations are reliably sequenced by >>=
05:44:31 <edmundnoble> `throwIO ex` however can only throw `ex`, and since `throwIO` returns an IO action, it's sequenced relative to the IO action that came before it; because of this, `throwIO ex` is equivalent to `evaluate (throw ex)`
05:46:30 <opqdonut> and in e.g. `liftM2 (+) (throwIO ex) (throwIO ex2)` you'll always get ex (due to the implementation of liftM2 sequencing the first arg first)
05:46:37 <edmundnoble> `evaluate` sequences the evaluation of an expression with respect to IO actions, taking something which is ordinarily lazy - and weakly ordered with the evaluation of other expressions - and making it so strict that the time of its evaluation is *precisely* defined by your program.
05:46:58 <zincy_> Ah so in order to proceeed through a chain of IO computations you must evaluate the value returned by throwIO
05:47:03 <zincy_> in precise order
05:47:12 <edmundnoble> You must throw the exception, yes
05:47:29 <edmundnoble> But *evaluating* a `throwIO` call doesn't cause the exception to be thrown
05:47:32 <edmundnoble> *Executing* it does
05:47:34 <zincy_> So there isn't anything special about throwIO it just exploits this fact about IO actions necessarily being evaluated in chains
05:47:47 <edmundnoble> That's the distinction; `throwIO` must be *executed*, `throw` must be *evaluated*
05:48:26 <zincy_> So the precision distinction is about *runtime* ordering - execution?
05:48:45 <edmundnoble> It's also about what ordering the compiler will preserve
05:48:48 <zincy_> Doesn't evaluation happen at runtime though?
05:49:24 <edmundnoble> Both evaluation and execution *occur* at runtime, but the compiler is free to reorder evaluation as long as it doesn't make a terminating program stop terminating
05:49:45 <zincy_> Ah ok
05:49:55 <zincy_> So that is why IO is pure
05:50:04 <edmundnoble> Evaluation is only *weakly ordered* in terms of data dependencies; `x + y` doesn't mean "evaluate `x`, then evaluate `y`, then evaluate `x + y`"
05:50:12 <zincy_> Because an evaluated IO action isn't tied to execution
05:50:15 <edmundnoble> It means "before `x + y` can be evaluated, both `x` and `y` must be evaluated"
05:50:39 <edmundnoble> That is precisely a major reason why IO's being pure is so useful with laziness
05:50:51 <edmundnoble> Yes, evaluation of an IO action does not trigger its execution
05:50:56 <edmundnoble> However, it can if you want
05:51:09 <edmundnoble> `unsafePerformIO` does that basically
05:51:11 <zincy_> Ah this helps so much
05:51:21 <edmundnoble> `unsafePerformIO . evaluate` is actually `id`
05:51:35 <hpc> in fact, for (+) and many other functions, even less than that is necessary
05:51:58 <hpc> (x + y) means "before x+y can be evaluated, (+) must be evaluated", in general
05:58:03 <zincy_> edmundnoble: How can evaluate by the the inverse of unsafePerformIO?
06:00:28 <edmundnoble> Because `unsafePerformIO` creates an expression which when it's evaluated, executes an IO action
06:00:50 <edmundnoble> And `evaluate` creates an IO action which when executed, evaluates an expression
06:03:53 <edmundnoble> So `unsafePerformIO (evaluate x)` creates an expression which when it's evaluated executes an IO action which when executed, evaluates `x`
06:03:59 <edmundnoble> An expression which when it's evaluated, evaluates `x`
06:04:02 <edmundnoble> `x`
06:05:27 <zincy_> I am confusing myself 
06:06:23 <zincy_> so unsafePerformIO executes an action *when* evaluated but this evaluation is deferred
06:06:30 <zincy_> until runtime
06:06:39 <zincy_> so unsafePerformIO . evaluate 
06:06:54 <zincy_> undoes this before runtime
06:06:57 <edmundnoble> `unsafePerformIO x`, when it's evaluated, executes `x` 
06:07:01 <zincy_> So it is like nothing ever happended
06:07:04 <edmundnoble> Nothing to do with runtime vs compile time
06:07:13 <edmundnoble> It's evaluation versus execution
06:07:15 <edmundnoble> Both happen at runtime
06:07:33 <edmundnoble> Execution is strongly ordered, by the `>>=` calls that make up an IO action
06:07:42 <edmundnoble> Evaluation is not as strongly ordered
06:08:48 <edmundnoble> `x + y` as we covered (in the particular case, let's say, of `(+) :: Int -> Int -> Int`) requires that `x` and `y` both be evaluated, but it doesn't specify to the compiler what *order* they should be evaluated in
06:09:24 <edmundnoble> The compiler is free to reorder your code before runtime so that `x` or `y` is evaluated first
06:09:59 <edmundnoble> `liftA2 (+) x y` however, when executed, will *always* execute the `x` IO action *and then* the `y` IO action
06:11:28 <zincy_> So execution is always strongly ordered?
06:11:45 <zincy_> Because execution requires evaluation to already be forced
06:12:21 <edmundnoble> Yes, in the sense that `>>=` is always strongly ordered
06:12:25 <edmundnoble> `>>=` on IO
06:12:52 <zincy_> That property is held by all operations though?
06:13:06 <zincy_> oh no
06:13:12 <zincy_> Only operations you can execute
06:13:42 <zincy_> Which is just IO
06:13:46 <edmundnoble> If you have `x >>= f`, then it's *always* the case that `x` is executed, then if `x`'s result is `a`, `f a` is executed after
06:13:50 <edmundnoble> Yes it's all about IO
06:14:57 <edmundnoble> And you can go between execution and evaluation with `evaluate` and `unsafePerformIO`
06:16:34 <edmundnoble> So that you can write code which for example, `unsafePerformIO`'s some IO actions when you don't necessarily care when those actions are done with respect to one another, or even if they're done at all
06:17:00 <edmundnoble> And use `evaluate` to make sure that some work *is* done at a particular time when you *do* care about when it happens with respect to IO actions
06:18:16 <iphy> I need some help with cabal new-install
06:18:18 <edmundnoble> `unsafePerformIO` lets you give up the strong ordering guarantees of the compiler, `evaluate` lets you *make up* strong ordering guarantees for your code, and using both can be good for performance
06:19:18 <iphy> I want to cabal new-install a package manually, because I need to replace the build-type for it from Custom to Simple
06:19:43 <iphy> but if I then cabal new-install the next package that depends on it, it tries to reinstall that dependency I just manually new-installed
06:19:55 <phadej> cabal get pkgname; cd pkgname-*; $EDITOR ...; cabal v2-install
06:20:05 <zincy_> but evaluate takes a pure value?
06:20:18 <phadej> iphy: of course. `v2` paradigm is "stateless"
06:20:27 <iphy> I see
06:20:40 <iphy> so v2-install always reinstalls everything from scratch?
06:20:48 <iphy> or only the locally built things?
06:20:53 <dcoutts_> iphy: you need to include your modified package into the project you are actually trying to build. Each project is independent.
06:21:06 <zincy_> Is the aim to hijack the ordering guarantees of execution and tie it to evaluation, hmm I thought that is what unsafePerformIO was for
06:21:10 <iphy> I see
06:21:20 <iphy> dcoutts_: that sounds like something that makes sense to me
06:21:30 <phadej> or you could make your local repository, https://cabal.readthedocs.io/en/latest/installing-packages.html#local-no-index-repositories
06:21:46 <phadej> if it's something you don't care to share
06:21:57 <iphy> it's for cross-compilation only
06:22:13 <iphy> at the end, a binary comes out of it that I'm deploying to android devices
06:22:25 <iphy> so really, whatever works is good for me
06:22:44 <dcoutts_> iphy: so as phadej says, you can use "cabal get" to grab a copy of the sources and unpack them. So do that within the project you are trying to use it in, and edit the cabal.project file for your project to include that subdir.
06:25:08 <edmundnoble> zincy_: yes, each do it in opposite directions
06:25:33 <edmundnoble> `unsafePerformIO` makes evaluation trigger execution
06:25:39 <edmundnoble> `evaluate` makes execution trigger evaluation
06:26:01 <phadej> I'm occasionally tempted to teach cabal to override build-type though, but then I remember that removing need for build-type: Custom is better long term :/
06:26:06 <edmundnoble> And importantly the behavior with exceptions is that `unsafePerformIO . throwIO` is `throw`, and `evaluate . throw` is `throwIO`
06:26:49 <phadej> `throw` should really be exported only from some .Unsafe module :(
06:26:57 <phadej> :t throw
06:26:59 <lambdabot> Exception e => e -> a
06:27:21 <edmundnoble> Eh, I like the imprecise exceptions model. You do actually need to get what's going on with laziness
06:27:24 <edmundnoble> Maybe Control.Exception.Lazy
06:27:38 <edmundnoble> `.Lazy` is enough of a warning, I think ;)
06:28:55 <zincy_> So unsafePerformIO is the dual of evaluate
06:29:11 <phadej> I don't remember if I ever used `throw`. And use `error` only in cases where I don't care of catching those exceptions
06:29:28 <zincy_> return has the same type signature as evaluate
06:29:37 <zincy_> I guess evaluated uses `seq`
06:30:01 <phadej> (i.e. program should just die)
06:30:51 <phadej> at which point whether it's UserError or some other exception type is little difference
06:43:07 <zincy_> What is a less hand wavy definition of "execution" in respect to IO than - does things to the real world at runtime?
06:43:57 <phadej> "does things to the real world at runtime?" is missing a verb
06:44:28 <phadej> or I somehow fail to parse that
06:46:06 <phadej> (I guess any non-GHC implementation specific description of execution & IO won't be able to explain what unsafePerformIO does0
06:54:44 <zincy_> phadej: Can't things be a noun describing a class of verbs
06:54:46 <zincy_> :D
06:55:33 <zincy_> Maybe "things" is the undefined of the english language
07:06:51 <iphy> cabal: The program 'happy' version >=1.19 is required but the version of /home/androidbuilder/.ghc/android-9/arm-linux-androideabi-4.9/.cabal/store/ghc-8.6.5/happy-1.19.12-f50a43e6c8d02d3fcd7b5e4bdfd178586525ba06c4231665e218f4607e572859/bin/happy could not be determined.
07:07:01 <iphy> is there a way to override happy?
07:07:10 <iphy> this is the cross-compiled one that doesn't run on the build machine
07:08:06 <iphy> I have a happy built for the build machine as well
07:13:24 <zincy_> Do we call getLine an IO action or is it only an action when it is evaluated?
07:13:40 <zincy_> Bit confused about the terminology between IO action an IO value
07:14:29 <glguy> I don't think those two terms have much difference
07:15:17 <glguy> Calling it an action is just to distinguish it from other values in some way
07:15:35 <zincy_> Ah ok
07:16:47 <zincy_> When you evaluate getLine would it be unchanged.
07:16:58 <zincy_> In the same way that evaluating 2 would give you 2
07:17:33 <zincy_> I guess I don't understand how the compiler knows when something is fully evaluated
07:17:45 <zincy_> and especially how GHC knows when an IO value is fully evaluated
07:18:56 <iphy> --with-happy seems to do the trick
07:22:13 * hackage ngx-export-tools-extra 0.4.0.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.4.0.0 (lyokha)
07:28:51 <zincy_> "The illusion is so good that programmers are fooled into thinking I/O is pure in Haskell."
07:29:03 <zincy_> :D I thought it was pure, Am I fooled or not fooled
07:29:10 <zincy_> https://crypto.stanford.edu/~blynn/haskell/io.html
07:31:46 <zincy_> We call the type RealWorld but no one is under the illusion it actually represents the real world
07:32:03 <zincy_> So in that sense how is anyone fooled by thinking IO is pure
07:32:34 <glguy> GHC knows when some IO value is evaluated because the representation is not a mystery to GHC
07:34:15 <glguy> The RealWorld implementation detail doesn't matter for understanding IO, it's just a way for GHC to implement IO in terms of its existing machinery
07:38:30 <hpc> the way IO is actually implemented is that the entire language is technically impure
07:38:51 <hpc> but from the user's perspective, that impurity is only accessible with unsafePerformIO
07:39:21 <hpc> in fact, it has to be impure globally or unsafePerformIO wouldn't even be possible
07:41:23 <JesseL> is that only IO is impure in haskell?
07:42:21 <hpc> generally you should just imagine everything is pure, though
07:43:01 <hpc> as long as you're not calling unsafeWhatever, the properties you want out of writing pure code still hold everywhere
07:43:48 <hpc> IO is still pure as well, because anything you could do to break things is not available in its API
07:44:01 <JesseL> read/write file, display on monitor, network socket, they cannot be pure, time can not be pure
07:45:24 <hpc> they are pure when you keep those separate from evaluation
07:45:26 <hpc> which IO does
07:45:44 <hpc> you never have "value which depends on the current time" sort of things
07:45:57 <hpc> you have "value which depends on some arbitrary time", sequenced with "get the current time"
07:46:04 <JesseL> yeah, they are pure only when they are not been evaluated
07:46:17 <hpc> which combine to make "computation which produces a value based on the current time"
07:46:32 <hpc> and though the result it makes varies each time it is executed, the action itself is the same every time
07:46:38 <hpc> and that's the part that matters for evaluation
07:46:48 <JesseL> IO actions are pure before you run them which mean put them into main
07:47:47 <ph88> is Data.Set ordered or unordered ?
07:48:26 <hpc> even main is pure
07:48:35 <hpc> it just sits there, being the same value every time it is evaluated
07:48:44 <yushyin> ph88: it needs a Ord instance, so I guess ordered?
07:48:45 <hpc> the mechanism that executes main happens "outside the language"
07:49:14 <ph88> why is there no implementation for sort and cons for Data.Set ?
07:49:41 <hpc> the Ord instance is so it knows where in the set to store the elements for performance reasons
07:49:47 <hpc> the API presents the elements as unordered
07:50:18 <edmundnoble> The API can also efficiently present them as ordered iirc
07:50:26 <edmundnoble> Oh I see what you mean lol
07:50:56 <hpc> yeah
07:51:21 <hpc> if the constraint was Eq instead of Ord, Set k v would have the same performance as [(k, v)]
07:51:22 <ph88> so it's actually an unordered collection then ?
07:51:49 <JesseL> before someone introduce monad into haskell, how to think IO in haskell?
07:52:19 <ph88> i don't get why would you store items ordered and then only present them unordered .. what's the point of that
07:52:27 <JesseL> the lambda man, I forget his name
07:52:40 <yushyin> JesseL: church?
07:52:42 <yushyin> :D
07:52:45 <JesseL> no
07:52:48 <polyphem> Phil Wadler
07:53:14 <JesseL> yeah
07:53:27 <hpc> JesseL: IO is abstract - values of type (IO a) contain some magical piece of unchanging information that represents an effectful computation
07:53:37 <JesseL> in that time, how people think about IO
07:53:40 <yushyin> because of his superhero lambda shirt? or why lambda-man?
07:53:46 <ph88> is there a data structure that has a uniqueness property and also has an ordered api ??
07:53:49 <hpc> JesseL: and there are some limited general operations you can perform on those values, primarily sequencing them
07:54:56 <hpc> JesseL: the sequencing operation is similarly magical, it somehow knows how to create a new value of type (IO b) based on an (IO a) value and a function
07:56:04 <hpc> and that's pretty much it
08:02:26 <sm[m]> that exceptions discussion would make a great doc
08:19:03 <yushyin> ph88: what is it you want to achieve with an ordered api?
08:19:26 <ph88> yushyin, show a list to a user in an order
08:20:59 <yushyin> in a particular order, or the ascending order of the elements by there Ord instance?
08:33:03 <yushyin> elems will get you the elements in ascending order and you could always newtype your elements with a custom ord instance but that's a bit inconvenient, I guess
08:34:53 <cheater> anyone use TLA+ here? i'm not sure how to fix the PlusCal algorithm at the end of this page so that it doesn't violate the invariant. https://learntla.com/introduction/example/
08:38:22 <ahri_> I'm struggling a bit with Megaparsec; I have `type Parser = ParsecT Void B.ByteString IO`, and then `pAcctId :: Parser B.ByteString; pAcctId = (string $ satisfy $ (\c -> isPrint c && c /= '/') . toChar) <* newline`, which doesn't compile, and I had to steal `toChar` from Text.Megaparsec.Byte which feels like I'm doing something wrong! What I really want is a parser that will give me a ByteString of 
08:38:28 <ahri_> printable non-slash characters terminated by a newline, but this is eluding me!
08:47:56 <scasc> I was playing around with Unboxed Types, and I could not figure out how to use them with guards.
08:48:49 <scasc> Generally, while there are (<#), (==#), etc. they do not produce Bool, but an Int# (with boolean semantics: 1# vs 0#) again.
08:50:08 <scasc> Ah, rubber ducking seems to help :-)
08:50:31 <scasc> I'll have to wrap it in isTrue# every time...
08:53:26 <frdg> im trying to install hspec and im having some issues. https://pastebin.com/MYtT3xh4
08:54:11 <zincy_> So the evaluation of IO results in a pure value but the execution is impure?
08:54:57 <monochrom> It's richer than that.
08:56:02 <monochrom> Because of IO, we don't have one "evaluation", we have two: "evaluation" for the pure side, "execution" for doing what IO says it does, e.g., printing and getting input.
08:56:48 <monochrom> Suppose you have "getLine >>= \s -> print (length s)"
08:57:56 <monochrom> Here is what "evaluation" is responsible for: evaluating that expression to an internal representation of what needs to be done (note that no input/output happens here); later, computing length s when needed by the "print".
08:58:22 <monochrom> Here is what "execution" is responsible for: reading a line, printing that number.
08:58:56 <monochrom> Oh, I misread you, you already know these.
08:59:24 <monochrom> I don't like to say "impure".  I say effectful.  But yeah.
09:00:18 <zincy_> So when people say that programmers are "fooled" into thinking IO is pure
09:00:28 <zincy_> It would be better phrased as
09:00:42 <zincy_> Programmers are fooled into thinking execution of IO actions is pure?
09:01:04 <monochrom> I don't fool anyone.  I'm not going to follow that story.
09:01:41 <monochrom> The computer figuring out what "getLine >>= \s -> print (length s)" means is pure.
09:02:41 <monochrom> Upon you inputting the string "xyz", the computeer figuring out "so I am looking at print (length "xyz")" and subsequently "so this means print 3" is pure.
09:02:51 <monochrom> The actual printing is effectful.
09:03:07 <zincy_> Yeah
09:03:26 <zincy_> IO is like a pure interfact to an impure programming language called the Haskell runtime
09:03:31 <zincy_> *interface
09:03:34 <monochrom> Yes.
09:03:41 <monochrom> Everything is an interface!
09:03:52 <zincy_> This is the power of abstraction
09:04:22 <zincy_> When people say we are lying or fooling ourselves they don't realise that is the nature of abstraction
09:04:56 <hpc> we fool ourselves into thinking these things aren't ultimately just an array of bytes as well :D
09:05:17 <zincy_> And we fool ourselves into thinking bytes are just electrical charges
09:05:23 <zincy_> *arent
09:05:43 <hpc> and we fool ourselves into thinking those charges are always high or low voltage
09:07:34 <zincy_> Didn'y feynman say the most important thing isn't to fool yourself
09:07:51 <zincy_> I would say the most important thing is knowing when you are *allowed* to fool yourself
09:08:22 <hpc> or like a magic trick
09:08:31 <hpc> knowing you're fooled as you let it happen
09:09:13 <zincy_> :D
09:09:24 <hpc> perhaps something along these lines is how programmers end up referring to so many things as "magic" when they don't want to understand them
09:09:30 <monochrom> We know how to work at a higher level without using the fooling model.
09:09:55 <zincy_> hpc: Yes :D
09:10:00 <zincy_> monochrom: what do you mean
09:11:01 <monochrom> You can prove that the low-level model implies theorems about the high level model. Then you can comfortably work with the high-level theorems exclusively and you know they're true.
09:14:04 <zincy_> How is that not the fooling model?
09:14:20 <monochrom> Other programmers have to resort to fooling because they're too dumb for such bridging proofs.  It's also why they're stuck as programmers.  Those who can do these proofs enjoy much better careers than being code monkeys.
09:14:50 <zincy_> What is an example of a bridging proofs?
09:14:54 <monochrom> Difference being you kind of know how to prove it vs you can't even imagine?
09:15:46 <monochrom> "full abstraction" which means that every equation provable by an operational semantics is also provable by a denotational semantics.
09:16:10 <monochrom> and the denotational semantics is regarded as higher level
09:16:52 <zincy_> 1. How can I learn that
09:17:07 <monochrom> Proofs that your compiler is correct, i.e., you want "(\x -> x+1) 2  --> 2+1" and you prove that the compiler generates asm code that corroborates with that story.
09:17:13 <zincy_> 2. What would that look like for the IO magic fooling
09:17:14 <monochrom> Grad school?
09:17:38 <zincy_> Since for 2 I can't imagine proofs that would help with it
09:17:50 <zincy_> monochrom: Maybe it is time, the economy has died
09:17:55 <monochrom> What would help, fooling?
09:17:58 <frdg> monochrom: what would you reccomend to people who are inexperienced programmers who want to be experts/ not just code monkeys?
09:18:22 <monochrom> Take all of the more theoretical courses in CS
09:19:14 <zincy_> monochrom: Which courses in your opinion are the most important?
09:19:49 <zincy_> "<monochrom> What would help, fooling?" I mean what are such bridging proofs that would take my understanding of IO beyond code monkey level
09:23:20 <monochrom> "discrete math" to start with, so you become comfortable with proofs and a few "common sense" things that are not so common.  Then it will be some programming language theory courses (those that mention "operational semantics" and "denotational semantics"), and some formal method aka formal verification courses.
09:24:41 <monochrom> In the case of IO and GHC, no one has done it.
09:25:01 <monochrom> But there have been little bits discussed.
09:25:46 <monochrom> SPJ's "awkward squad" long paper has an operational semantics of an important part of IO.  One could start from there.
09:26:41 <monochrom> Working upwards, you can use the operational semantics to work out what it predicts about small programs.
09:27:10 <zincy_> People say you shouldn't go to grad school for no good reason
09:27:21 <monochrom> Working downwards, you can follow through GHC or another compiler to see it generates asm code that agrees with the operational semantics, at least for a small program of your choice.
09:27:27 <yushyin> i liked that paper, was very readable even for such a noob as me.
09:27:39 <zincy_> Is going to just to learn for the sake of learning about being a better coder good enough reasons
09:28:23 <monochrom> Combining the two, you now know that your small program is compiled to asm code that really says "read a line, print its length".
09:28:43 <zincy_> monochrom: So for IO and GHC does that not imply we are all stuck in the fooling ourselves model for now?
09:28:46 <monochrom> I agree, these courses should be inflicted on undergrads.
09:29:50 <monochrom> GHC generates actual asm code and makes actual syscalls.  I can't count it as fooling unless you invoke "the computer is fooling you", virtual machines, all that.
09:29:57 <pja> ahri_: You’re kind of doing things on hard mode with ByteString, but you could use isPrint && _slash from Data.Word8 instead of faffing about with toChar.
09:30:15 <polyphem> i like how math starts with a set of axioms , simple unprovable intuitionally true statements thet are used to develp higher abstractions
09:31:01 <polyphem> s/thet/that/
09:31:38 <zincy_> monochrom: Do you recommend the set of software foundations books? Sounds like a lot of overlap with what you are discussing regarding courses
09:31:53 <pja> ahri_: but probably better to use the actual byte parsing functions?
09:37:23 <JoeCordingley> Does anyone know why there aren't Semigroup and Monoid instances in the tuples-homogenous-h98 (Data.Tuple.Homogenous) ? Am I missing some reason why they shouldn't be Semigroups and Monoids?
09:38:46 <lyxia> given how old it is, I bet it's because nobody of the few people who used it needed it.
09:39:05 <solonarv> oof yeah, hasn't been touched in 6.5 years
09:39:55 <lyxia> it does seem like a sane thing to have
09:43:40 <monochrom> Yes zincy_
09:45:33 <maerwald> Well, we could demand haskell to be ever only evaluated on functional hardware
09:46:05 <monochrom> Perhaps you brought up fooling because you were thinking: at the high level we draw a line between eval and exec, but surely in asm we only have one kind? so what justifies drawing that line?
09:47:26 <monochrom> But everyone draws other artificial lines likewise, and no one would accept that it's "fooling".  For most C or Java programmers, the line between "stack" and "heap" is very real.
09:48:04 <monochrom> But oh look, the CPU doesn't care, all it does is "oh you are accessing this address? OK!  oh you again, you're accessing this other address? OK!"
09:48:30 <monochrom> So what justifies drawing the stack/heap line when the CPU doesn't care?
09:48:44 <pja> ahri_: Does parseTest (many ((satisfy (\c -> isPrint c && c /= _slash))::Parser Word8)) $ C.pack "hello" not work for you?
09:49:08 <pja> wfm. But I’m using Parser = Parsec Void ByteString
09:49:16 <ahri_> pja: hm, I'll have a go
09:49:19 <pja> not the ParsecT transformer that you claim to be.
09:49:33 <monochrom> So you go look at compiled code, and you notice that addresses derived from the stack register all stay within one area, and addresses derived from malloc all stay within another area.  At least for non-buggy C code anyway.
09:50:12 <monochrom> And also the stack register has a perfect correspondence to function calls and local vars.
09:50:15 <pja> ahri_: It fails to typecheck with ParsecT Void ByteString IO.
09:50:25 <maerwald> Well, that's the point. Your binary doesn't follow the rules of the high-level language necessarily. If you want that your high-level proofs carry over to the binary, you gotta do more work
09:50:27 <monochrom> This justifies the stack/heap line.
09:50:50 <maerwald> or just use CakeML
09:51:32 <monochrom> The asm code is all mixed up, but you know how to nicely classify it into two parts. This justifies drawing a line, especially if that line is also a useful for a high-level model
09:51:47 <nshepperd2> bridging "proof": the compiler documentation says it implements the standard semantics, so it probably does
09:52:23 <monochrom> You can do a similar thing to the eval/exec line of Haskell.  Some instructions correspond to pure functional programming.  The others correspond to input, output, exceptions, etc.
09:52:59 <pja> ahri_: I think you’re running in to trouble with building ByteStrings out of your Word8 pieces in your parser.
09:53:11 <pja> you might find using Text more intuitive...
09:57:24 <maerwald> monochrom: if we did that, it would be trivial to make it an actual effects system
09:57:58 <frdg> I successfully downloaded Hspec but I'm unable to get it to import. Im pretty unsure of what I need to do.
09:58:10 <ahri_> pja: yeah, you're probably right. your example does work with my ParserT though :) the reason I'm using ByteStrings is that I'm parsing input streaming in from stdin
09:58:24 <monochrom> P.S. ObStrictlySpeaking: For standard-aware people, the "stack"/heap line of C counts as fooling again, because in the C standard there is no "stack", so there can't be a line. >:D
09:58:54 <frdg> for reference im trying to import Test.Hspec
09:59:19 <ahri_> pja: and it's binary data, not something I can say is text encoded as utf8, for example - only this bit of it is recognisable text
09:59:38 <ahri_> well, and a bit to take a number of bytes to grab
09:59:59 <maerwald> monochrom: all carefully omitted concepts, so compiler engineers have room to work with :P
10:00:15 <monochrom> Theorem: If you don't support recursion and/or mutual recursion, you need no stack.  Proof: Look at all languages and compilers before Algol 60.
10:00:53 <maerwald> What's the reason to omit a definition of pointers then
10:01:02 <pja> ahri_: Fair. Use the byte combinators & the functions in Data.Word8 then.
10:01:06 <monochrom> Yeah! The standards leave so much room because you need that for code optimizations.  It's for performance!  It's a noble cause.
10:01:55 <pja> Not sure what to do about the "I have pile of  Parser Word8 funcions & want to get a Parser ByteString out of them" problem though. Seems like "chunk" ought to work, but doesn’t
10:02:05 <maerwald> I'm guessing this was all arbitrary and someone just copy-pasted half of what the compiler implemented into a standard and omitted the pieces that were too confusing
10:02:15 <monochrom> haha
10:03:04 <monochrom> I think they had a more serious reason.  I think some hardware had different address formats for different data types.
10:04:27 <ahri_> pja: I ended up with a [Word8] (thanks to `many`) and used `pack`
10:04:47 <maerwald> Yeah, I guess you can't easily write a language spec for a language that's supposed to be close to the hardware, without being vague
10:05:39 <pja> ahri_: Makes sense.
10:06:14 <frdg> I successfully downloaded Hspec but im unable to get it to import. When I type `import Test.Hspec` it says it doesn't recognize the import. This is my first time trying to use a non standard library 
10:06:27 <monochrom> Another angle: Suppose you allocated an array A successfully, and it starts at address 0x0f00.  Suppose you ask about &A[2].  Must the computer represent it as 0x0f02?  Can't the computer just call it 2?  You can choose either convention and make it work.
10:06:56 <pja> nb. You can’t use string, because string doesn’t take a parser as an argument: it generates a parser that matches the chunk of tokens you give it.
10:07:05 <pja> ahri_: does that make sense? 
10:07:27 <monochrom> Oops, no, you can't.  Nevermind.
10:08:14 <nshepperd2> but it could represent it as (&A, 2)
10:08:24 <nshepperd2> for garbage collection, or something
10:09:26 <monochrom> Yeah, my "can't" is only because what if you call a function "void bar(int *)" and give it &A[2]?  But I guess the compiler can do extra work and work out 0x0f02 in that case.
10:10:06 <monochrom> Portability is a mess.
10:10:25 <ahri_> pja: I think so - would I use it to match a token like "if" if I were writing a language? or are you saying it's more flexible than that?
10:10:26 <maerwald> all hail posix
10:12:05 <pja> ahri_: exactly. It’s for matching keywords in your input where you already know what the keyword is.
10:15:37 <ahri_> pja: ok, that makes sense then. Looking at the docs I can't see an obvious way to collect a given number of bytes into a ByteString - is this something I should with a combinator like `many`? I assume there's a more efficient way of doing it to avoid constructing a list of bytes
10:15:59 <pja> You have to construct your output explicitly yourself in Megaparsec.
10:16:37 <pja> It’s type is separate from that of the input, even if you happen to be using Megaparsec to convert from one ByteString to another...
10:16:54 <ahri_> ah perhaps `takeP` is what I'm after
10:16:54 <pja> one is in the Parser monadic world & the other isn’t.
10:16:58 <pja> I think.
10:18:16 <pja> takeWhileP is defined in terms of many & satisfy...
10:20:09 <pja> or rather it has equivalent behaviour.
10:26:13 * hackage store 0.7.3 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.3 (MichaelSloan)
10:27:29 <pja> ahri_: Yup. Looks like it: parseTest ((takeWhileP Nothing (\c -> isPrint c && c /= _slash))::Parser ByteString) (C.pack "test/input")
10:29:10 <ahri_> nice!
10:34:22 <pja> Digging through the source, takeWhileP ends up being defined in terms on span on ByteStrings, which is about as efficient as you can get...
10:37:58 <ahri_> I like those takeP and takeWhileP functions - they give me a nice handle to learn from
10:47:15 <ahri_> pja: thanks a lot for your help, it's really helped me a lot - I'm going to go and make some food now, just wanted you to know your time and effort have been very much appreciated
11:25:58 <zincy_> monochrom: Is it fair to draw a line between the type 1 and type 2 programmers you discussed earlier as this. The type that rely on models of "fooling" and the type that build higher models of abstractions based on conceptually useful distinctions at the lower level models.
11:26:30 <zincy_> Maybe type 1 are stuck on the lower level models generally.
11:32:43 * hackage store 0.7.4 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.4 (MichaelSloan)
11:34:19 <jota191> hi! I want to compare type level strings, is this implemented anywhere?
11:36:55 <zincy_> Look at CmpSymbol in GHC.Typelits
11:37:26 <zincy_> Actually  sameSymbol is better depending on your use case
11:37:54 <jota191> Oh, I checked the module before asking and I didn't see that
11:38:00 <jota191> thank you!
11:39:23 <jota191> cmpSymbol is the useful one for my case I guess
11:43:13 * hackage archive-sig 1.0.1.0 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-1.0.1.0 (vmchale)
11:44:31 <zincy_> No problem
12:08:13 * hackage dobutokO2 0.24.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.24.0.0 (OleksandrZhabenko)
12:11:15 <JoeCordingley> is there a way of referencing a non defined type in a record? i.e data F = F { f :: a -> a } without putting `a` in the type?
12:11:38 <JoeCordingley> forall a. or something?
12:13:07 <zincy_> What is a non-defined type?
12:14:32 <jota191> @JoeCordingley something like data F = forall a . F {f :: a -> a}
12:14:32 <lambdabot> Unknown command, try @list
12:14:46 <JoeCordingley> I don't know the correct terminology
12:14:59 <JoeCordingley> but that looks right 
12:15:29 <jota191> you have to use -XExistentialQuantification to make that work
12:16:29 <jota191> and that's it I guess, an existentially quantified type variable
12:22:20 <dmwit> ?hoogle [a] -> NonEmpty a -> NonEmpty a
12:22:21 <lambdabot> Data.List.NonEmpty.Extra appendr :: [a] -> NonEmpty a -> NonEmpty a
12:22:21 <lambdabot> Extra appendr :: [a] -> NonEmpty a -> NonEmpty a
12:22:21 <lambdabot> Data.NonEmpty.Mixed appendLeft :: Cons f => [a] -> f a -> f a
12:22:37 <dmwit> ?index Data.List.NonEmpty.Extra
12:22:37 <lambdabot> bzzt
12:26:47 <ArticulateHacker> hi... I'm having trouble creating a function from the type signature... `a :: (a -> c) -> a -> a` 
12:27:12 <ArticulateHacker> I can't figure out how to make a funciton that takes takes a and returns c into a function that takes a and returns c then returns a
12:28:30 <frdg> I successfully downloaded Hspec but Im unable to use it. When I try `import Test.Hspec` it says it doesn't recognize the module. 
12:28:43 <frdg> im very unsure of what im supposed to do
12:29:18 <dmwit> ArticulateHacker: You don't have much choice but to completely ignore the `a -> c` argument.
12:29:25 <dmwit> ?djinn (a -> c) -> a -> a
12:29:26 <lambdabot> f _ a = a
12:29:47 <dmwit> There are no other (total, eta-beta-inequivalent) implementations.
12:30:12 <dmwit> Hm. Maybe one other. =)
12:30:39 <ArticulateHacker> I thought I tried that and didn't get the right signature back... I'm getting `p1 -> p2 -> p3` ... or can I think of this as correct because p1 can be (a -> c) ?
12:30:49 <dmwit> frdg: What does "downloaded" mean? Have you used cabal or stack to either install it or list it as a dependency for your project?
12:30:53 <ArticulateHacker> the assignment is to write a function that matches the signature
12:30:58 <dmwit> ArticulateHacker: Exactly.
12:31:25 <frdg> dimwit: I installed it off hackage and installed all of the depen
12:31:30 <frdg> dependencies 
12:31:37 <dmwit> ArticulateHacker: There are two things the assignment could mean: 1. write an implementation for which GHC infers the given type, or 2. write an implementation which GHC agrees typechecks at the given type.
12:31:43 <dmwit> Do you know which the assignment intends?
12:31:51 <dmwit> (The former is a bit harder, though probably not impossible.)
12:32:04 <ArticulateHacker> no, it's a self learning book
12:32:08 <dmwit> frdg: Again: what does "installed" mean? What is the exact command(s) you ran?
12:32:10 <ArticulateHacker> it's not clear on that
12:32:22 <dmwit> ArticulateHacker: Okay. I would take the assignment to mean the latter, then.
12:32:24 <dmwit> Personally.
12:32:37 <ArticulateHacker>  makes sense
12:32:48 <dmwit> If you want, we could talk about how to do the former as well...? Sort of an extra challenge for the strong of heart.
12:33:16 <ArticulateHacker> hm... let's take maybe a smaller step and then do that
12:33:21 <ArticulateHacker> the next problem...
12:33:25 <ArticulateHacker> I get the right answer, but I"m not sure why
12:33:30 <dmwit> ^_^_^
12:33:34 <frdg> dmwit: I used the runhaskell Setup configure...runhaskell Setup build, runhaskell Setup install for every dependency 
12:33:54 <ArticulateHacker> `foo :: (a -> b) -> a -> b` can be answered correctly with `foo a b = a b`
12:35:17 <dmwit> frdg: Wow. That's... very old school. Did you intend to do it the hard way for some reason? If not, do you have a moment to talk about our lord and savior cabal?
12:35:22 <ArticulateHacker> i can see why it assumes `a` is a function
12:35:35 <ArticulateHacker> I'm not sure how it infers that the function returns an a
12:35:55 <dmwit> (it infers that the function returns a b)
12:36:02 <frdg> dmwit: lol it took just under an hour. I do have time though
12:36:28 <ArticulateHacker> er, rather that using that function (which returns b) as input, how the next function returns a
12:36:37 <ArticulateHacker> how does it know that `a` returns `b` anyway?
12:36:51 <ArticulateHacker> ah, wait..
12:36:53 <ArticulateHacker> b can be anything
12:37:02 <dmwit> frdg: Okay. The modern way, if you want to use HSpec in a new package, is to just list HSpec in the `build-depends:` clause of your `test-suite` stanza in the package's .cabal file.
12:37:04 <ArticulateHacker> so, just by nature of being a function it has a return
12:37:16 <ArticulateHacker> so, the (a -> b) part makes sense
12:37:50 <dmwit> frdg: If you just want to play with HSpec a bit, you could do that by going into the directory where you've unpacked a copy of HSpec, then running `cabal repl`. That will dump you into a ghci that has the appropriate stuff loaded (and fetch and install all the appropriate dependencies for you...!).
12:38:33 <ArticulateHacker> how does ingesting a function return an `a` and that return a `b`?
12:38:42 <dmwit> ArticulateHacker: What type of thing could the call `a b` possibly return if not the type of thing that the function `a` returns?
12:39:11 <dmwit> ArticulateHacker: You... don't ingest a function that returns an `a` and then return a `b`. You ingest a function taht returns a `b` and then return a `b`.
12:39:13 <ArticulateHacker> hm. that makes sense
12:39:19 <frdg> dmwit: https://pastebin.com/Yc8769Y2 This is the cabal file. For the book im reading Im gonna need to do more than just play around in the REPL I believe. I am not sure exactly how to edit the cabal file properly
12:40:09 <ArticulateHacker> oh right
12:40:28 <dmwit> frdg: The hacky thing is to just add hspec to the build-depends clause that's already there.
12:40:41 <dmwit> frdg: Then things built in the context of the `Learn` executable will have access to all the modules that hspec exports.
12:40:49 <dmwit> Excuse me, s/exports/exposes/
12:40:49 <ArticulateHacker> so, `a` is a function that returns something... the `b` in my declaration is really the `a` outside paranthesis in the type signature
12:41:04 <ArticulateHacker> so, I take a function, then a value, and get the value returned by the function
12:41:42 <dmwit> frdg: Usually hspec is part of a test suite, not an executable. If you want to do a best-practices thing, you can very nearly copy-and-paste that exact `executable` stanza, change `executable` to `test-suite`, and pick a new name. Then you'll have a valid `test-suite` stanza, and you can add hspec to the build-depends list for it.
12:41:51 <ArticulateHacker> i should use different letter for my function variables and type variables, I think
12:42:03 <dmwit> ArticulateHacker: That would make it easier to discuss things, yes. =)
12:42:22 <dmwit> You can practice mentally separating type- and term-level things later once you know how to do typejitsu already.
12:42:46 <ArticulateHacker> so, is there a way to make a function the explicitly has the type `foo :: (a -> c) -> a -> a` ?
12:42:59 <frdg> dmwit: ok ill give this a try
12:43:00 <dmwit> ArticulateHacker: Anyway, I find your latest message that starts "so, `a` is a function that returns something..." accurate.
12:43:06 <frdg> thanks
12:43:18 <ArticulateHacker> dmwit thanks, that helps
12:43:25 <dmwit> :t \aToC a -> let c = aToC a in a
12:43:27 <lambdabot> (t1 -> t2) -> t1 -> t1
12:43:35 <ArticulateHacker> wtf
12:43:55 <dmwit> Okay, so it chose names t1 and t2 instead of a and c. =P
12:45:10 <dmwit> ArticulateHacker: The One True Way to get GHC to infer that a thing is a function is to apply it to an argument.
12:45:39 <dmwit> If you don't do anything with the result of that function call, well, that's on you. The compiler isn't going to argue.
12:45:48 <dmwit> (Actually it is if you turn on the right warnings. But never mind. =P)
12:46:43 * hackage unicode-tricks 0.1.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.1.0.0 (wvanonsem90)
12:46:47 <dmwit> % :set -Wunused-binds
12:46:48 <yahb> dmwit: 
12:46:57 <dmwit> % :t \aToC a -> let c = aToC a in a
12:46:57 <yahb> dmwit: ; <interactive>:1:16: warning: [-Wunused-local-binds] Defined but not used: `c'; (t1 -> t2) -> t1 -> t1
12:47:20 <dmwit> % :set -Wno-unused-binds
12:47:20 <yahb> dmwit: 
12:47:20 <ArticulateHacker> so, you're explicitly naming `aToC a` as `c` and then just not using it and returning `a`
12:47:47 <dmwit> Yes. And by the way, all the names I picked are just for you and me. The compiler doesn't care, I could have called it godIsDead or whatever instead of c.
12:48:27 <ArticulateHacker> yea, I'm not terribly uncomfortable with that notion
12:48:56 <dmwit> There are other ways to create a thing and ignore it, of course.
12:49:01 <ArticulateHacker> I think I'll forgive myself for not know that.... I'm less than 200 pages into my n00b book
12:49:12 <dmwit> :t \aToC a -> const a (aToC a)
12:49:13 <lambdabot> (t -> b) -> t -> t
12:49:27 <dmwit> :t \aToC a -> snd (aToC a, a)
12:49:29 <lambdabot> (b -> a) -> b -> b
12:50:02 <dmwit> hm... I wonder if we can even get the right type variable names by accident =P
12:50:06 <gentauro> any good site (with examples) on how to combine: `hakyll` + `purescript`?
12:50:09 <dmwit> :t \aToC a -> fst (a, aToC a)
12:50:11 <lambdabot> (t -> b) -> t -> t
12:50:27 <gentauro> currently I'm only using `haskyll` to produce static sites
12:50:39 <gentauro> but I would like to add a bit of `fe logic`
12:50:42 <gentauro> :)
12:59:13 * hackage inline-c 0.9.1.0 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.9.1.0 (FrancescoMazzoli)
13:09:43 * hackage burrito 1.0.0.0 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.0.0.0 (fozworth)
13:18:52 <huskyhaskell> Hi guys, a question: If I have a string, let's say "hello whatever" and I want to cycle another string over that one preserving whitespace, how would one go about that? Example: cycling "lala" over the previous string: "lalal alalalal"
13:19:53 <Rembane> huskyhaskell: Split, cycle zip, join
13:20:10 <d34df00d> , rinse, repeat
13:20:56 <huskyhaskell> Alright, I am not quite sure how to implement that yet but now I have got direction at least...Thanks!
13:25:33 <dmwit> I like this puzzle. Doing it correctly with existing high-level functions is surprisingly tricky, while with basic recursion is easy as cheese.
13:26:29 <d34df00d> huskyhaskell: what if there are several spaces in a row in the source string? Should they be preserved?
13:26:47 <huskyhaskell> Yes, I think so
13:26:48 <d34df00d> I mean, "hello   whatever" should result in "lalal   alalalal", right?
13:26:58 <d34df00d> Ok, splitting gets even funnier.
13:27:18 <huskyhaskell> Yeah haha
13:27:37 <huskyhaskell> I've already trouble with the "easy" version
13:27:44 <solonarv> at this point I would be tempted to throw a mapAccumL at it (or was it mapAccumR ?)
13:27:59 <solonarv> I can never remember which of these is which
13:28:08 <Rembane> Do both! 
13:28:17 <d34df00d> And prove the equivalence!
13:28:20 <d34df00d> Formally!
13:28:25 <dmwit> > evalState (traverse (\c -> if isSpace c then pure c else state (\(x:xs) -> (x, xs))) "hello   whatever") (cycle "la")
13:28:27 <lambdabot>  "lalal   alalalal"
13:28:45 <solonarv> yes, traversing with State is what I usually end up doing
13:28:55 <d34df00d> Why not just recurse.
13:29:01 <dmwit> d34df00d: exactly
13:29:04 <dmwit> The explicit version is so easy.
13:29:10 <huskyhaskell> You guys just do it like that, huh haha
13:29:39 <Rembane> huskyhaskell: They've put way too many hours into Haskell. :)
13:29:44 <Rembane> +learning
13:30:02 <dmwit> > let go (x:xs) [] = []; go (x:xs) (c:cs) | isSpace c = c:go (x:xs) cs | otherwise = x:go xs cs in go (cycle "la") "hello    whatever"
13:30:04 <lambdabot>  "lalal    alalalal"
13:30:08 <huskyhaskell> Yeah I guess, I don't blame them though!
13:30:13 <huskyhaskell> Addictive
13:30:17 <dmwit> Hm. Actually the code of the explicit version is longer.
13:30:21 <dmwit> Consider me suitably admonished.
13:30:38 <d34df00d> But it's more straightforward anyway.
13:30:45 <d34df00d> Also you could replace the first (x:xs) with _
13:30:49 <d34df00d> Saving a few characters!
13:30:58 <solonarv> not *much* longer, tbh
13:31:01 <dmwit> ^_^
13:43:32 <huskyhaskell> dmwit I really liked the recursive one! Mostly because I've got zero clue what the other one is doing...
13:43:51 <dmwit> I like it too!
13:43:59 <huskyhaskell> Yay!
13:44:05 <dmwit> I wouldn't blink twice if I saw it in a real codebase, let alone dream of converting it to the stateful one.
13:45:06 <huskyhaskell> dmwit I wish I had anything of weight to say about that, but I can just agree then!
13:46:26 <huskyhaskell> dmwit Another question then, if I would like to implement the classic algorithms, would you do this with stateful computing? As in ST monads and the like?
13:46:37 <dmwit> E_TOOVAGUE
13:46:58 <huskyhaskell> dmwit Sry haha. I just mean if performance is the main concern
13:47:17 <dmwit> Which algorithms are the classic ones?
13:48:25 <huskyhaskell> dmwit Good question! I am thinking about Cormen's Introduction to Algorithms for example
13:48:46 <huskyhaskell> dmwit But I understand the question is a bit too vague to give a meaningful answer
13:49:45 <huskyhaskell> dmwit I was simply curious, as I am attending a course on algorithms and data structures and it is done in C++...
13:50:24 <dmwit> Um. It's a long book, presumably with a lot of algorithms in it.
13:50:46 <dmwit> I would give pretty good odds that some of the algorithms I would do without stateful computing, and some with.
13:52:51 <dmwit> I want to say of the, like, hard-core algorithmic cores I've done in the past, it's like 7:3 pure-functional to ST- or IO-based.
13:53:32 <dmwit> Take that ratio with a grain of salt. It's based on a gut feel, not on a careful inventory of code I've written.
13:53:43 <huskyhaskell> dmwit Wow, that's interesting
13:55:39 <huskyhaskell> dmwit It's my first time on here but I am already feeling that I will learn a lot here
13:57:55 <monochrom> zincy_: We all have limited time, so it is OK to spend more time on one job and less time on studying other issues. Still, awareness is important.
13:59:34 <monochrom> And honesty.
14:00:13 * hackage dobutokO2 0.24.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.24.1.0 (OleksandrZhabenko)
14:06:48 <monochrom> Some carefully written (or lucky) pure functional code gets compiled into merely updating registers.
14:09:36 <monochrom> The faulty inference "destructive update is important for efficency => hand-write destructive updates for efficient code" is a fallacy of thinking that theorems are preserved across huge abstraction gaps.
14:11:52 <monochrom> In fact, empirical benchmarking proves that looping over "n <- readSTRef v, writeSTRef v $! (n+1)" is much slower than looping over "f n = ... f (n+1)"
14:15:31 <monochrom> You've also got to see the generated asm code.
14:18:13 * hackage burrito 1.0.0.1 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.0.0.1 (fozworth)
14:22:08 <fragamus> > fix id
14:22:11 <lambdabot>  *Exception: <<loop>>
14:22:18 <fragamus> yeah
14:23:19 <monochrom> Why the interest in fix id? :)
14:23:31 <hpc> to be fair, it's pretty interesting
14:23:43 * hackage burrito 1.0.0.2 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.0.0.2 (fozworth)
14:23:47 <hpc> but mainly just as a look into the structure of thunks
14:23:48 <monochrom> It's one of the most boring fixed points.
14:24:33 <d34df00d> Isn't fix id ~ undefined?
14:24:37 <monochrom> Yes.
14:24:59 <d34df00d> > fix error
14:25:02 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
14:25:10 <hpc> as a neat party trick, ghc's single-threaded runtime modifies thunks to throw an exception if they are re-entered
14:25:13 <monochrom> In fact I can sharpen my statement to being technically accurate.  fix id is one of the most uninformative fixed points. :D
14:25:13 <fragamus> I learned about fix and my head exploded
14:25:28 <hpc> because the only way that can happen is a bottom value
14:25:36 <Rembane> fragamus: Have you seen MonadFix yet? :)
14:25:42 <fragamus> no
14:25:43 <d34df00d> mdo lol
14:25:48 <d34df00d> Or what is was.
14:26:07 <hpc> in the threaded runtime, it turns into some sort of sleep, because asynchronous exceptions are a thing and you might also just not want your other threads to exit for no reason
14:26:07 <monochrom> Yeah have a dose of mfix for the next level of brain supernova.
14:26:28 <Rembane> fragamus: People say that it's useful, I haven't yet found out what for, but it makes my brain scream in fun ways. :D
14:26:35 <monochrom> Just hope that the remnant of your brain doesn't collapse to a black hole haha.
14:26:53 <Rembane> Neutronium brain sounds like a good future-proof brain tech.
14:27:17 <monochrom> Here, I wrote most of it: https://wiki.haskell.org/MonadFix
14:27:47 <fragamus> i have this function having type (x->x) and it converges on some value and I create an infinite list of it iterating and then look for two consecutive equal values. Is that what fix does 
14:28:06 <monochrom> No.
14:28:43 <monochrom> Especially since your job requires Eq or even Ord, but fix doesn't, so fix must be doing something else.
14:29:20 <monochrom> Everyone needs to learn enough of parametricity to at least being able to deduce this much on their own.
14:32:26 <monochrom> Someone please declare that all my summer courses are cancelled completely due to the pandemic, so that I finally have time to write a proper tutorial on denotational semantics so that you can just go read it and see what kind of fixed points fix does.
14:32:42 <monochrom> Except at the expense of shrinking my income!
14:32:57 <d34df00d> Please also include a good list of references to read more about all this stuff.
14:33:06 <d34df00d> From a more, eh, mathematical viewpoint.
14:33:31 <dmwit> A proper introduction to denotational semantics would be fantastic and also an ENORMOUS undertaking.
14:33:52 <monochrom> Oh that one is easy, I already have it, Davey & Priestley's textbook "introduction to lattices and order"
14:34:07 <quantumplation> I'm trying to implement sendSignedMsg from this snippet: https://gist.github.com/Quantumplation/66b48c999ebdfc75545606c724be586e 
14:34:22 <quantumplation> I'm having trouble figuring out exactly how to get timestamp to play nicely with the ClientApp () bit
14:34:33 <monochrom> Actually the wikibook has enough of it.
14:34:40 <quantumplation> is there some series of lifts or fmaps or something that would help?
14:34:59 <d34df00d> monochrom: alright, let's say I've read TAPL, TTFP, "Programming in MLTT", "Proofs and Types" (didn't understand much there too beyond chapter 7 or 9 IIRC) and maybe something else I forgot.
14:35:06 <d34df00d> What would you recommend approaching next?
14:35:09 <monochrom> https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
14:35:25 <d34df00d> s/too/though/
14:35:56 <monochrom> I don't know, because I don't know what interests you.
14:36:41 <d34df00d> All this type theory stuff is fun. Formal logic is also fun (I've read an introductory book on that too, but it's in russian so it's unlikely the name'd tell you much).
14:36:47 <d34df00d> I'd also like to sort of explore what interests me, in a sense.
14:36:47 <monochrom> But I can use this chance to sway you away from the religion people built up around curry-howard, which is exactly what those books are raving about.
14:37:16 <monochrom> So let it be Bird & de Moor's Algebra of Programming bwhaahahaha
14:37:48 <d34df00d> That sentiment sounds promising.
14:37:50 <d34df00d> !
14:38:05 <Rembane> d34df00d: What is the name of the book? 
14:38:42 <dmwit> quantumplation: What is the exact error? This shouldn't be a problem.
14:38:57 <dmwit> quantumplation: Are you sure that ClientApp is a type alias and not a newtype, e.g.?
14:39:05 <monochrom> IMO curry-howard is valuable in guiding language design, but unergonomic and contrived and obscuring when proving programs correct.
14:39:19 <monochrom> Just look at ATS use cases.
14:39:37 <d34df00d> Oh, algebra... I should also finally jump onto the CT hype train!
14:39:42 <d34df00d> monochrom: are there any?
14:40:03 <monochrom> Algebra of Programming begins with category theory, so it's alright!
14:40:30 <d34df00d> Rembane: it could be translated roughly as as "lectures in mathematical logic and theory of algorithms".
14:40:55 <d34df00d> Rembane: it's in three parts, for set theory (including ordinals-cardinals and all that), for formal logic itself, and for recursion theory.
14:41:06 <quantumplation> @dmwit I updated the gist with the error, and pretty sure: https://hackage.haskell.org/package/websockets-0.12.7.0/docs/src/Network.WebSockets.Client.html#ClientApp
14:41:06 <lambdabot> Unknown command, try @list
14:41:10 <d34df00d> Rembane: I believe parts 1 and 3 were translated to English actually, let me find it.
14:41:38 <d34df00d> monochrom: I'm actually going through Aluffi's book right now. Nothing about programming at all, just to get some grip with abstract algebra.
14:41:50 <d34df00d> Although I got till finite group theory and sort of put that on hold as finite group theory is super boring for me.
14:42:27 <quantumplation> from the error, it sounds like I need to make a lambda that discards the Connection parameter and just calls timestamp? or something? Still trying to get a handle on this stuff :)
14:43:00 <monochrom> If you understand Aluff's book, then you can safely stick to it.  Basically there are enough category theory textbooks to choose from, so optimize personal style prefereence rather than always obeying monochrom.
14:43:04 <d34df00d> Rembane: yep, https://www.amazon.com/gp/product/0821827316/ref=dbs_a_def_rwt_bibl_vppi_i1 and https://www.amazon.com/gp/product/0821827324/ref=dbs_a_def_rwt_bibl_vppi_i0
14:43:56 <monochrom> What you may need to watch out for is that category theory is huge, there are many subtopics of little interest to your focus, but some books keep raving on those because that's their focus.
14:44:00 <d34df00d> monochrom: I had so much fun around all the snake lemma-related stuff!
14:44:26 <Rembane> d34df00d: I wonder if I've seen this one in real life. I had a course mate who reads books in cyrillic. 
14:45:16 <d34df00d> Rembane: I don't think they were ever printed really in Russian. They are basically lecture notes and the pdfs are officially available for free from a russian math site, and that's it.
14:46:00 <randomshinichi> https://gist.github.com/randomshinichi/6bcc08a077b4758dad98d81ae010c3fb
14:46:20 <randomshinichi> Can someone help me with this weird compiler error? Expecting one more argument to ‘Num’      Expected a type, but ‘Num’ has kind ‘* -> Constraint’
14:46:26 <dmwit> quantumplation: Could not reproduce. After fixing the obvious unrelated stuff (see my comment on your gist) it works fine here.
14:46:45 <d34df00d> monochrom: also, quite frankly I probably have the luxury of not _having to_ dig into a specific field. I'm just picking up on some more fundamental math than I had in my university.
14:46:46 <dmwit> quantumplation: So you must have made a transcription error while trying to minimize your example.
14:47:16 <d34df00d> But, on the other hand, just reading everything seems counter-productive. I'd like to do some fun research, however unimportant and minor, on my own eventually.
14:47:25 <Rembane> d34df00d: Interesting, then I must've mixed them up. It's one of my strong sides after all. 
14:48:13 <quantumplation> dmwit: mm, thanks, I'll try to figure out where I incorrectly minimized and come back
14:48:56 <dmwit> randomshinichi: Well, Num is not a type.
14:49:12 <dmwit> Int, Integer, Rational, Double are common choices of number-like types.
14:49:15 <dmwit> Perhaps you meant one of them.
14:49:58 <dmwit> randomshinichi: Unrelated: you should prefer using readLn over this getLine+read combo. It will throw parsing errors earlier, which is usually the desired behavior.
14:50:16 <quantumplation> randomshinichi: "Num" isn't a type, it's a typeclass (think: 'category of stuff that behaves like a number').  You either want a specific type (like Int, Integer, Double, etc.), or you want to be generic like `inputToNum :: Num a => String -> a`, which says "As long as a is something that behaves like a Num, inputToNum is a function from String to
14:50:16 <quantumplation> a"
14:50:17 <monochrom> d34df00d: What happened to me before I decided on my thesis target was partly chance encounters and partly getting excited about something for no reason.
14:51:04 <d34df00d> I'm quite past my thesis times :(
14:51:23 <d34df00d> And enrolling in a PhD program would require me to pass GRE, which requires to recall real analysis and all that stuff, which I completely forgot lol.
14:51:35 <monochrom> I guess the two cases can be unified to "studying a topic for no reason other than randomly choosing it to study"
14:52:13 <monochrom> Oh I don't mean you need to do a PhD.  I just mean when I did not need to choose a target for research, I just random-walked.
14:52:47 <Rembane> monochrom: did you drop the boring ones and tried again?
14:53:09 <monochrom> Except that it was really interleaving random walk steps with focuses study steps.  I.e., loop { choose a topic; patiently study that topic for a while }
14:53:45 <monochrom> I think I did for a few, yeah.  Maybe s/boring/boring or too difficult or not exciting enough etc/
14:54:33 <Rembane> Yeah, I put them in the same bucket 
14:55:52 <monochrom> There have also been retries.  For example at an early stage I tried to read Back & von Wright's book "the refinement calculus" and couldn't understand it.  Several years later I tried agian, now I understood it, and kept working on it for a few months (it's a thick book)
14:57:50 <quantumplation> dmwit: Ahh, ok.  I'm in the process of converting this from sendMsg to sendSignedMsg, and so I added the k parameter to the signature and my example, but didn't add it to the actual definition that was failing to compile
14:57:57 <monochrom> Generally my "choose a topic" step is basically merely: take a look around what some profs and grad students are doing, take a look at comp.lang.functional, take a look at #haskell, walk into the library intending to borrow a book but wait the other book next to it suddenly looks more interesting, ...
14:58:38 <dmwit> #blessed academic life
14:59:06 <quantumplation> :sweat_smile: been a while since I had to deal with that
14:59:31 <quantumplation> graduated with my masters in mathematics (thesis was on Topology) 2 years ago
14:59:54 <monochrom> Well since one of my entropy(!) sources are #haskell and newsgroups and haskell-cafe etc, you also enjoy the same sources.  Plus you also have reddit, stackoverflow, celebrity blogs and twitters... these I didn't have in my days.
15:00:22 <d34df00d> monochrom: I mean, doing a PhD is probably the best way to get into something research-oriented.
15:00:50 <d34df00d> On the other hand, I started a small research project after contacting somebody who might be a really good mentor, so we'll se how it goes.
15:01:01 <monochrom> :)
15:01:31 <Rembane> Research <3
15:02:02 <quantumplation> I love research, except when it's on a deadline.  The stress of having to have a breakthrough moment in a certain time frame is too much for me
15:02:28 <d34df00d> I get derailed a lot tho. But it may be for the better.
15:05:11 <d34df00d> Alright, I guess I'll get back to Aluffi then. Recalling and deriving myself all the concepts I've come across so far like cokernels or quotient groups or R-modules or what not after a ~half-a-year hiatus would be an interesting test to see how well I internalized them.
15:06:43 <d34df00d> Maybe something like "Topoi" would also be nice, dunno.
15:07:16 <monochrom> topoi is one of those I ran into and quickly decided "nah I don't want to know" :)
15:07:28 <d34df00d> Why's that?
15:08:00 <randomshinichi> thank you very much for your answers, dmwit, quantumplation
15:08:06 <monochrom> I don't know. It looked pointless to me.  Or perhaps I misunderstood it.
15:08:20 <d34df00d> Ah makes sense.
15:09:49 <Cale> Topoi are those categories in which you can interpret intuitionistic higher order logic.
15:10:22 <monochrom> Ah maybe I misunderstood it then.
15:10:39 <monochrom> My impression was "set theory except we don't call them sets"
15:10:57 <Cale> Yeah, that's kind of the same idea :)
15:11:03 <monochrom> haha OK
15:11:38 <gcoakes[m]> Hey, is this the right channel to go if I am having a hard time with something in haskell?
15:11:44 <Cale> yes
15:11:46 <monochrom> Yes.
15:11:52 <Cale> Despite appearances, it is, lol
15:13:03 <hpc> you'd think it was #python :P
15:13:19 <gcoakes[m]> Can anyone help me figure out what the (:<) operator does? I don't know if it comes from a specific library or not. I'm seeing it in a blog post but it unfortunately has no context about where it is imported from. https://blog.sumtypeofway.com/posts/serving-http-content-with-fused-effects.html
15:13:32 <monochrom> This is also the right channel for asking python 5 questions.
15:13:43 <gcoakes[m]> I've tried hoogling it.
15:14:25 <gcoakes[m]> Please. Don't. I don't want to have to transition another legacy project through two more major revisions of python. 
15:14:40 <monochrom> It is not in the standard libraries.  It is specific to the libraries assumed by that blog.
15:15:14 <Cale> I think it's from these fused-effects things... I've never used that stuff.
15:15:23 <gcoakes[m]> None of those imports have it. That's what's confusing me. I'm starting to think those libraries changed in the past 4 months.
15:15:24 <monochrom> You don't know that "python 5" was an April 1st joke two years ago and it's really Haskell? >:)
15:15:50 <gcoakes[m]> Oh, I must of missed that one.
15:16:08 <monochrom> https://www.reddit.com/r/haskell/comments/b81t7q/bubble_sort_in_python_5/
15:16:15 <Cale> oh
15:16:21 <Cale> It's from the streaming thing
15:16:34 <Cale> They're talking about streaming-bytestring there
15:17:14 <gcoakes[m]> Is it declared in there? I thought hoogle would have listed `streaming-bytestring`, if it exposed it.
15:17:28 <monochrom> hoogle is not omniscient.
15:17:45 <Cale> I think it's related to https://hackage.haskell.org/package/streaming-0.2.3.0/docs/Data-Functor-Of.html
15:17:59 <gcoakes[m]> Does it only look at the latest versions of these libraries?
15:18:08 <Cale> The question is, where is the :<
15:18:28 <gcoakes[m]> Screw it. I'll just git clone and grep it.
15:18:33 <Cale> haha
15:19:50 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/pGZgQBhXyluMICsMdDNuHTCb >
15:20:13 <justsomeguy> Oh, so that's why everyone explicitly does "import Module.Name (function)"... of course that would make it easier to figure out where things come from.
15:20:26 <Cale> They do say: result is of type Of Lazy.ByteString (ResponseHeaders, (Status, ()))
15:20:59 <Cale> justsomeguy: For those imports where it's going to be non-obvious where they come from, yeah
15:21:17 <Cale> Some people kind of overdo it, but it's something that you just have to judge for yourself
15:21:56 <Cale> gcoakes[m]: does this blog post come with downloadable code?....
15:21:59 <gcoakes[m]> @justsomeguy, yeah, that's one of the things I'm not liking about haskell. At least in python, you have to explicitly import from or be an ass and star import.
15:21:59 <lambdabot> Unknown command, try @list
15:23:23 <Cale> I honestly don't know why it is that this basic web backend stuff ends up getting so obnoxiously complicated. Where I work, we use a tiny fraction of Snap.
15:23:44 * hackage ulid 0.3.0.0 - Implementation of ULID - Universally UniqueLexicographically Sortable Identifier  https://hackage.haskell.org/package/ulid-0.3.0.0 (adrian)
15:24:32 <gcoakes[m]> No, unfortunately it doesn't have any downloadable code. I would just drop it, but I felt like I was actually understanding this library because of the blog post. I want to have some concrete results from it.
15:24:40 <Cale> I don't really get why you'd *want* to be using fused-effects here in the first place, and sure, some kind of stream abstraction might become necessary if you're serving large files out of a database or something, but this is hello world...
15:24:46 <Cale> ech
15:25:20 <hpc> i notice it in other languages too, i think webdev just creates this general aversion to writing glue code at all
15:27:20 <Cale> All of the complication of our backends gets redirected toward trying to push data from the database through to the frontends and determine which users need to receive updates when changes come in from DB servers. The actual web API stuff is absolutely trivial.
15:29:28 <dmwit> justsomeguy: Yeah, I recently started working on a project where the rule is "either qualified or an explicit import list, your choice", and man it has made finding out where things come from an absolute dream.
15:29:31 <Cale> With no fanciness whatsoever -- occasionally we'll slap on a ReaderT for the sake of configuration, so we don't have to pass around a signing key and logging stuff explicitly, and for various application-specific shenanigans. But that's one record.
15:29:41 <dmwit> In a big project it seems plain required.
15:29:46 <tonymclane> Hello, can anyone help a total noob here.....? I'm trying to upload my first .hs file to the GHCI it contains only this line  doubleMe X = X + X     and it gives this error  Not in scope: data constructor ‘X’
15:29:46 <tonymclane> Failed, modules loaded: none.
15:29:56 <dmwit> Until we have an IDE that can ask GHC, of course. ^_^
15:30:07 <Rembane> tonymclane: Try lower case letter and see what happens 
15:30:14 <dmwit> tonymclane: Variable names must start with a lower-case letter.
15:30:17 <Cale> tonymclane: Things that start with an uppercase letter must be data constructors
15:30:26 <Uniaika> tonymclane: contrary to Erlang, variables must be lowercase
15:30:33 <dmwit> tonymclane: (...or lower-case punctuation. ;-)
15:32:07 <d34df00d> > Until we have an IDE that can ask GHC, of course. ^_^
15:32:09 <d34df00d> We already have that!
15:32:10 <lambdabot>  <hint>:1:38: error: parse error on input ‘,’
15:32:11 <gcoakes[m]> cale: thank you for that doc link. It turns out the blog was wrong and (:>) is the constructor for Of. It doesn't compile yet, but I think that got me farther.
15:32:35 <d34df00d> My life got way easier after I tried to overcome my aversion towards fancy GUI IDEs and started using idea + intellij-haskell.
15:32:37 <Cale> no problem
15:32:43 <tonymclane> thank you!
15:41:56 <gcoakes[m]> d34df00d, do you use vi-bindings, and if so, does idea have good vim keybinds? I use vscode for work and nvim at home. I absolutely hate vscode's vim binds, but they are the best I've found in a GUI editor.
15:57:25 <lightandlight> Is there a way to encode non-haskell executable dependencies in a 3.0 .cabal file?
15:57:59 <lightandlight> `build-tools` was removed, and `build-tool-depends` seems like it's only for referring to executables in other haskell packages
16:04:06 <gcoakes[m]> I've been using nix for non-haskell dependencies, but I don't think that is exactly applicable to all situations.
16:04:24 <gcoakes[m]> I don't know about directly in the cabal file.
16:04:37 <solonarv> I'm not sure how you could usefully specify "this non-haskell executable must be present" in a cabal file, tbh
16:04:50 <solonarv> it's not like cabal is capable of installing it if it's missing, so it will just complain at you
16:05:55 <lightandlight> solonarv: GHC incapable of fixing my type errors, yet I'm still happy for it to yell at me :)
16:06:39 <solonarv> for haskell programs the "compile" and "run" steps can be quite some time apart and "run" might not exercise the entire program
16:06:48 <gcoakes[m]> lightandlight: If you're interested in the nix approach, I've made a cookiecutter template which does all the project setup you need to use nix+direnv.
16:06:50 <solonarv> this is much less true for build plans
16:07:06 <lightandlight> gcoakes[m]: Yeah, nix is my fallback. It would just be nice if cabal let me encode the dependency
16:07:44 <gcoakes[m]> Is it like a developer utility or a runtime requirement?
16:08:03 <lightandlight> I mean, this isn't actually a question about package management
16:08:10 <lightandlight> It's a build-time dependency
16:08:14 <solonarv> I agree that it would be nice, but it doesn't seem like a very big improvement, that's all I'm saying
16:08:27 <lightandlight> So what I'm going to do is have my setup.hs throw an error if the executable isn't on the path
16:08:48 <solonarv> oh yeah, you can just do it in setup.hs
16:08:58 <gcoakes[m]> That's probably the test approach. 
16:09:06 <gcoakes[m]> *best
16:09:23 <dmwit> lightandlight: I think you have to custom-Setup.hs for that.
16:09:50 <dmwit> So in addition to that being the way you are currently doing it, that is the way you should be doing it.
16:10:49 <dmwit> I guess you could also do the ./configure thing; I believe cabal has some special mode for that.
16:11:12 <lightandlight> Nah I'll be adding a postConfigure hook in
16:12:05 <solonarv> oh yes you are probably supposed to do this in the 'configure' step
16:19:17 <d34df00d> gcoakes[m]: depends. ``` doesn't work (meh), but Ctrl-W, L, say, or :q or :w work.
16:51:45 <phadej> Doing a check in Setup.hs is "too late", you might get a better error, but your users still get an error.
16:58:45 <solonarv> you can't really improve from "whoever tries to build your thing without that executable dependency being present gets an error"
16:58:51 <solonarv> at least not with cabal
17:07:37 <zeta_0> i'm doing some coding with the haskell yesod web framework, anyways, what does GET and POST mean?
17:08:49 <yushyin> GET and POST are http methods
17:09:15 <sm[m]> https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
17:09:56 <gcoakes[m]> Get usually means retrieve some immutable data or at least can't be modified by the client. Post usually means create something stored on the server.
17:10:11 <yushyin> was about to link that aswell, sm[m] was faster!
17:11:00 <MarcelineVQ> just as a useful thing keep in mind you can ask google that sort of short question first in particular "what does GET and POST mean?" is a good candidate for that
17:11:39 <MarcelineVQ> And if that doesn't clarify it you can go on to ask what those mean in yesod in addition to linking where you saw it
17:12:27 * sm[m] blows away the smoke and tips his hat
17:12:50 <zeta_0> that makes sense, thanks for the help
17:15:36 <zeta_0> the hoogle documentation for yesod is a confusing
17:16:17 <zeta_0> hopefully ghcide provides documentation yesod eventually, that would be very useful
17:16:41 <sm[m]> there's a book y'know
17:16:41 <zeta_0> for yesod
17:18:04 <zeta_0> sm[m]: i'm working through ch8 of the book right now, there's some things that still confuse me, i guess back to hoogle documentation
17:18:50 <zeta_0> i just finsished working through the lyah book, hopefully yesod will make more sense now
17:19:53 <sm[m]> zeta_0: cool. If you find something missing, I'd be interested to hear. I need that info from time to time
17:20:24 <Axman6> it sounds like you learn some of the basics of HTTP zeta_0
17:20:46 <tmciver> :help
17:21:03 <zeta_0> sm[m]: ok, when i get stuck again, i'll let you guys know, i'm going to look at the yesod documentation in hoogle for a while
17:21:24 <tmciver> Damn, ghci has ruined me.
17:23:52 <MarcelineVQ> tmciver: just wait until the day you write   :! ghci
17:24:28 <MarcelineVQ> Some sins are beyond forgiveness.
17:28:14 <zeta_0> what is a public function in haskell?
17:28:59 <zeta_0> does that mean that it's a global function?
17:29:01 <tmciver> MarcelineVQ: Heh. I'd say I'm an intermediate Hakeller and I must admit I just learned about :! but I'm sure now that I know it, I'll do that soon.
17:30:47 <MarcelineVQ> zeta_0: At a guess it's a function your module exports but public isn't a haskell keyword that I'm aware of so it's best to share where you saw it so people can see the context
17:34:24 <zeta_0> public is mentioned on the substitutivity section of the Eq typeclass: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Eq
17:36:43 <dsal> zeta_0: it seems to define the term immediately after coining it in that link.
17:36:45 <MarcelineVQ> their use of public is defined right there
17:37:19 <MarcelineVQ> I'm not sure I'd use that word but it doesn't matter what word they use since they define it there. you can swap "public" for "hamburger" if you like
17:37:52 <sm[m]> it could be clearer.. do they mean a library user ?
17:38:07 <sm[m]> ie, people like us ?
17:38:13 <zeta_0> ya, it's still a little bit confusing, but it makes more sense now
17:42:16 <MarcelineVQ> I also think this could be worded better, though I'm not sure what that wording would be
17:45:53 <sm[m]> mail `git blame` -s "class Eq doc: please explain yourself"
17:49:10 <monochrom> exported
17:49:18 <MarcelineVQ> The example given is enough it's just potentially mysterious if you've never had a reason to make an abstract type before
17:51:06 <monochrom> Everyone has a reason to have had made an abstract type before.  Proof: CS courses that force you to do OO.
17:57:46 <dmwit> I suspect they didn't use "exported" because of how popular .Internal modules are.
17:58:47 <monochrom> then perhaps user-facing
17:59:48 <dmwit> Or see also showTree from Data.Map. I sort of consider that non-public.
18:00:25 <dmwit> Since it's really intended as a debugging tool for folks hacking on Data.Map, not really a useful tool for users of Data.Map.
18:00:52 <dmwit> Anyway I think it's good that they left the definition of "public" a little bit vague, because it takes some taste to decide what it means given that library authors are human and messy.
18:00:53 <monochrom> I feel that I'm patching and patching but it now goes like: exported and user-facing and non-debugging :)
18:01:26 <MarcelineVQ> Mostly I just want a hamburger.
18:01:34 <dmwit> monochrom: And you of all people should be happy to admit that you can't do mechanical definitions when humans are involved. That's like 20% of your rants on here. =P
18:02:00 <monochrom> exterminate all humans
18:02:20 <dsal> Speaking of internal modules... is there any way to suppress the docs/exports/etc...?  I've got dumb internal modules exported I'd rather people not look at.
18:03:02 <monochrom> If your *.cabal file you can list them under hidden-modules
18:03:51 <monochrom> On April 1st I would also add "batcave-modules"
18:04:49 <dmwit> Haddock also has a pragma it understands to avoid generating documentation for a module.
18:05:14 <dmwit> And it is even mildly smart, in that it has a concept of "home module" for where links should go, and it will pick a different home for things in modules you ask it to hide.
18:06:13 * hackage ghc-lib-parser-ex 8.10.0.4 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.4 (shayne_fletcher)
18:06:40 <dmwit> https://haskell-haddock.readthedocs.io/en/latest/markup.html#module-attributes
18:07:03 <dsal> Thanks.  That might do what I want.
18:07:40 <dmwit> But if you want that people cannot even import that module, then monochrom's hidden-modules is the thing to do.
18:08:58 <gcoakes[m]> Is there any way to show which packages use a particular package on hackage?
18:09:39 <gcoakes[m]> Like the opposite of dependencies.
18:11:13 <joeyh> gcoakes[m]: https://packdeps.haskellers.com/reverse
18:11:38 <MarcelineVQ> oh it's /reverse  I thought I had gone crazy
18:11:51 <joeyh> I have to google it every time
18:11:54 <gcoakes[m]> Tk
18:12:13 * hackage autoexporter 1.1.16 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.16 (fozworth)
18:22:43 * hackage derulo 1.0.8 - Parse and render JSON simply.  https://hackage.haskell.org/package/derulo-1.0.8 (fozworth)
18:24:32 <ski> @where revdeps
18:24:32 <lambdabot> <http://packdeps.haskellers.com/reverse>,<http://packdeps.haskellers.com/>,<http://www.yesodweb.com/blog/2011/02/reverse-packdeps>
18:32:43 * hackage flow 1.0.20 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.20 (fozworth)
18:35:29 <sm[m]> would be great if someone added /reverse to hackage
18:53:13 * hackage github-release 1.2.6 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.2.6 (fozworth)
18:55:13 * hackage gopro-plus 0.3.0.1 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.3.0.1 (dustin)
19:04:43 * hackage json-feed 1.0.9 - JSON Feed  https://hackage.haskell.org/package/json-feed-1.0.9 (fozworth)
19:15:40 <ezzieyguywuf> my ghcid is failing with "No files loaded, GHCi is not working properly." ghci works fine. I've updated portions of my system recently, is it possible i need to rebuild/reinstall some haskell stuff? if so, how would i do that?
19:18:13 * hackage lackey 1.0.12 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-1.0.12 (fozworth)
19:18:43 <MarcelineVQ> it's saying it doesn't know what files to watch basically
19:19:12 <MarcelineVQ> are you typing ghcid in a place with a stack and/cabal file present? or otherwise telling ghcid what to keep tabs on if not? e.g. ghcid foo.hs
19:19:18 <ezzieyguywuf> MarcelineVQ: ah, ok maybe I'm running it from the wrong directory or something
19:19:46 <ezzieyguywuf> MarcelineVQ: i'll double check. pretyt sure i have a .ghcid file floating around somewhere
19:21:03 <gcoakes[m]> If you are using plain cabal, this is how I launch ghcid for my projects: `cabal v2-exec ghcid -- -T :main`.
19:21:07 <ezzieyguywuf> hm, i have a .ghcid and a .cabal file.
19:21:11 <MarcelineVQ> I've not used one of those so I can't comment but I use ghcid directly in the project root I'm working on,  stack exec ghcid  with stack or ghcid -c 'cabal repl' for cabal
19:21:35 <ezzieyguywuf> MarcelineVQ: maybe I'm missing a flag on ghcid
19:21:59 <ezzieyguywuf> pretty sure i was using it 'bare' before, i.e. withotu stack or cabal. I haven't been around for like a month or so, though, so my memory is fuzzy
19:22:16 <MarcelineVQ> You can try gcoakes[m]'s version too, I use -c with cabal because that has worked for me
19:23:28 <MarcelineVQ> you can use it bare but somethings needs to be telling ghcid what files to watch, if that's not a cabal file then that's you. 
19:25:04 <ezzieyguywuf> hah, i had commented out the ':load' in .ghci
19:25:10 <ezzieyguywuf> that's why it wasn't doing anything
19:28:43 * hackage ShellCheck 0.7.1 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.7.1 (vidarhol)
19:29:43 * hackage list-singleton 1.0.0.3 - Easily and clearly create lists with only one element in them.  https://hackage.haskell.org/package/list-singleton-1.0.0.3 (fozworth)
19:31:14 <zeta_0> anyone here have experience with yesod? i have a couple of questions about it
19:45:58 <ddellacosta> traverseOf and sequenceAOf break my brain
19:46:43 * hackage rampart 1.0.0.3 - 🏰 Determine how intervals relate to each other.  https://hackage.haskell.org/package/rampart-1.0.0.3 (fozworth)
19:49:13 * hackage salve 1.0.9 - Semantic version numbers and constraints.  https://hackage.haskell.org/package/salve-1.0.9 (fozworth)
19:50:43 * hackage wuss 1.1.16 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.16 (fozworth)
19:52:13 * hackage ratel 1.0.10 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-1.0.10 (fozworth)
19:53:13 * hackage ratel-wai 1.1.2 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-1.1.2 (fozworth)
19:53:58 <ArticulateHacker> alright, so I'm struggling with what should be the easiest part of this... I'm supposed to correct all of the errors to enable either string to print. I keep getting the "else" condition regardless of what values I use with `sing`
19:53:59 <ArticulateHacker> https://gist.github.com/ArticulateHacker/579371513fef6d9010c8cd8934919182
19:54:43 * hackage strive 5.0.10 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-5.0.10 (fozworth)
19:54:46 <ArticulateHacker> oh... it was a spacing issue
19:55:08 <ArticulateHacker> haven't quite gotten used to space delimited coding
19:56:10 <gcoakes[m]> I'm fairly certain haskell allows you to write bracketted and with semicolons, but it's just not standard.
19:59:47 <ArticulateHacker> gcoakes[m] I'm hesitant to do anything non-standard, being the n00b that I am 
20:00:31 <gcoakes[m]> I'm not saying you should do it, just that you can.
20:08:24 <ddellacosta> ArticulateHacker: fwiw I usually see this with the 'then', 'else', and 'where' beginning each line they are on, in terms of what seems to be conventional. See e.g. "Objections" at the bottom here: https://wiki.haskell.org/If-then-else
20:09:00 <ArticulateHacker> I rewrote it that way
20:09:22 <ddellacosta> gotcha. Yeah that'll probably make your life easier
20:11:26 <sm[m]> Go ahead zeta_0
20:11:45 <ArticulateHacker> ddellacosta I agree with the objection... it is very easy to read
20:12:13 <ArticulateHacker> I'm just in like... kindergarten grammar level right now :P
20:12:49 <dsal> Oh weird, I didn't even notice the where in that.  My brain couldn't parse it.
20:17:06 <ddellacosta> dsal: I know it took me a minute too. Definitely been indoctrinated lol
20:17:25 <ddellacosta> ArticulateHacker: totally, been there
20:20:33 <dsal> The elm folks think my formatting is gross.  They've got some weird ideas.
20:32:03 <gcoakes[m]> Am I the only one that formats my code by piping the output of brittany to stylish-haskell?
20:42:52 <p0a> Hello I have written this code: https://termbin.com/jn4t it's a Hello World, any advice for improvement?
20:46:21 <gcoakes[m]> decompose could probably just be `take 2 . words` then pattern matching on `(firstName:lastName:[])` instead of using Maybe. If the purpose of this is to learn how to use Maybe, then I think it looks good.
20:46:59 <p0a> Oh nice, I didn't know about words 
20:47:48 <ArticulateHacker> is there a reason for the different type variables in GHCi? `(t1 -> t2) -> (t2 -> (a, b)) -> t1 -> a`
20:47:53 <gcoakes[m]> Yeah, it's pretty cool. I'm pretty new to all of this, so maybe take what I'm saying with a grain of salt though.
20:48:26 <p0a> ArticulateHacker: readability? You mean, why aren't they a,b,c,... or t1,t2 ... ?
20:48:32 <ArticulateHacker> yea
20:48:53 <p0a> Definitely readability
20:48:58 <ArticulateHacker> k
20:48:59 <ArticulateHacker> thnx
20:49:56 <p0a> gcoakes[m]: originally everything was under `hello' in a `where'
20:50:11 <p0a> gcoakes[m]: but ghc complained that `str' wasn't defined (I was using it inside `where')
20:50:24 <ddellacosta> gcoakes[m], p0a keep in mind some of us have names with spaces in first or last name ;-)
20:50:41 <solonarv> ddellacosta: what, no way
20:51:07 <p0a> ddellacosta: that is a good point but there would be no exercise if I had two separate prompts for first/last name :P
20:51:18 <p0a> I could ask to separate with a comma however
20:51:20 <solonarv> people's names are one word (first name) followed by another word (last name), each composed of ASCII letters, starting with an uppercase and otherwise compose of lowercase
20:51:22 <crestfallen> hi in the case of a list monad, map can be written like this: mapMM :: Monad m => (a -> m b) -> [a] -> m [b]   I'm trying to figure out why the return value is m [b], which is sugar? I guess for [] [b] or [] : [b]
20:51:23 <solonarv> :P
20:51:24 <p0a> and strip excess whitespace
20:51:24 <ddellacosta> p0a: fair enough, I was being slightly pedantic
20:51:43 <p0a> ddellacosta: no it's fine. It's a good point. How to solve that?
20:51:53 <solonarv> "falsehoods programmers believe about names: ...; people have names; ..."
20:52:11 <crestfallen> i.e. the return value is a nested list [[b]]
20:52:16 <ddellacosta> p0a: unfortunately I think the only way (other than asking the user to delimit it themselves...bad) would be what you suggested already
20:52:23 <solonarv> the correct answer if you are actually making a program: ask the user to input a string and don't touch it.
20:52:24 <ddellacosta> but we're getting deep in the weeds wrt ux haha
20:52:38 <p0a> Okay sounds good
20:52:39 <ddellacosta> solonarv: that's not unreasonable, depends on what you need to do with the name though
20:52:46 <solonarv> yes, of course
20:52:48 <ddellacosta> p0a: but seriously for an exercise it doesn't matter much
20:52:54 <p0a> How can you run a program from inside haskell?
20:53:00 <solonarv> if you want to e.g. deliver mail to them then this is probably the best idea.
20:53:04 <p0a> Like `ls' for example
20:53:07 <ddellacosta> p0a: was definitely being a bit of a pedant because it's something I personally deal with
20:53:19 <ddellacosta> solonarv: definitely
20:54:23 <solonarv> despite being a mix of French, German and Transylvanian/Romanian, my entire extended family has ASCII names - which is an odd coincidence
20:56:01 <ddellacosta> p0a: I've been pointed at this before, but I don't think I've done much with it myself, it's been a while: https://hackage.haskell.org/package/process
20:57:20 <p0a> ddellacosta: thank you, seems the successor typed-process is even better
20:57:24 <ddellacosta> looks like that points at https://github.com/fpco/typed-process/#readme
20:57:27 <ddellacosta> ha, jinx
20:57:29 <crestfallen> so I guess I'm not sure why this returns a nested list, or why it is written to return one.
20:57:30 <ddellacosta> yeah, sounds like
20:57:37 <jackdk> I'm reading the DerivingVia paper. In 4.3 they create a neat `SameRepAs` newtype to allow DerivingVia between types that have the same `Generic` representation. I just got an `IsomorphicTo` newtype working on a similar principle: if `IsomorphicTo a b`, then we can use instances of `b` to derive instances of `a` (with a helper typeclass to let us pick out the conversion functions)
20:57:54 <p0a> ddellacosta: what I am making is a tag system for my files
20:58:02 <jackdk> Is there a library that packages up these patterns anywhere? Neither hackage search nor startpage search nor ddg search gave me promising results
20:58:25 <ddellacosta> p0a: I see, cool. Great to put Haskell to practical use!
20:59:05 <p0a> ddellacosta: I have a lot of binary files with long descriptions with cryptic filepaths; I can now "search" a description and immediately open it under the appropriate program if I wish so, using recutils (a GNU text database; imho better than csv)
20:59:40 <p0a> so it's some bash scripts; but I think I'd like to write it in Haskell and spiffy it a bit too, especially the UI
20:59:57 <p0a> by binary I mean PDF by the way
21:00:13 <ddellacosta> gotcha
21:00:33 <ddellacosta> so kind of a file/app launcher?
21:00:46 <p0a> yeah but it also "links" many files together
21:00:56 <p0a> you may have a PDF but also a note file for it
21:01:39 <ddellacosta> gotcha, nice
21:01:51 <crestfallen> any comments on that or suggestion that it's incorrect? ^ It seems I'd need to use concat as an only resort
21:03:35 <p0a> ddellacosta: I want to retain using recutils instead of writing my own; I don't want to reinveint the wheel with a text database
21:04:00 <p0a> anyway thanks for helping me
21:05:45 <ddellacosta> crestfallen: I'm not sure I understand your question. That looks like mapM specialized to a list for the Traversable, unless I'm missing something. What are you asking about wrt the return value?
21:08:45 <solonarv> @tell p0a one thing that might be a bit annoying is that there seems to be nothing on hackage for working with recutils.
21:08:45 <lambdabot> Consider it noted.
21:14:18 <crestfallen> ddellacosta, thanks .. its supposed to function like map, but we get i.e. [[4,5,6]] . In the type signature, why is the return value m [b] and not m b (which is [b])  ?
21:28:57 <zebrag> With (parseInt >>=) In can parse one of "1: one", "2: two", "n: a lot". Is there some sort of simple proof that I can't do that with (parseInt <*>)?
21:30:56 <zebrag> That seems pretty obvious that I can't
21:31:42 <monochrom> I don't understand the question.
21:31:56 <zebrag> Because I do not have access to what Int has been parsed, not until it is too late
21:32:55 <zebrag> monochrom: it is about that article: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf
21:32:58 <zebrag> section 2.1
21:33:38 <zebrag> (>>=) being more powerful than (<*>)
21:34:28 <zebrag> I'm trying to find a case that definitely cannot be parsed with <*>
21:34:41 <zebrag> but that can with (>>=)
21:36:00 <povman> Anything where a parse result changes the behaviour of the parser
21:36:30 <monochrom> As the paper suggests, you need to imagine a non-context-free language.
21:36:58 <zebrag> I was thinking of: "1: one", "2: two", "n: a lot"
21:37:10 <zebrag> like "2: a lot" is rejected
21:37:17 <monochrom> so perhaps try the classic { a^n b^n c^n | n natural }
21:37:30 <zebrag> okay
21:38:13 <monochrom> If you only have finitely many accepted strings such as {  "1: one", "2: two", "n: a lot" }, it's a regular language, you don't even need parser combinations.
21:39:33 <zebrag> Yes, but I've added the constraint that I must first parse an int
21:39:56 <zebrag> so at that point I have to parse what remains
21:40:19 <zebrag> But I don't have access to what int has been parsed, because of <*>
21:41:20 <zebrag> of course with (>>=), I can, at that point, choose to parse "one" if I had "1", "two" if I had "2"...
21:46:52 <monochrom> Then you don't know which one is the real cause: <*>'s limitation, or your additional constraint.
21:47:11 <zebrag> monochrom: thanks for the example, which is obviously a much better one
21:52:57 <povman> Well if you have `parseInt :: Parser Int`then in `((,) <$> parseInt <*> parseRest)` `parseRest :: Parser a` and doesn't take an Int input
21:58:51 <zebrag> The signatures of Control.Applicative.(<*>) and the signature of the <*> in the parser article seem reversed from one another (a bit strange)
22:00:03 <monochrom> That's because Applicative didn't exist.
22:02:13 * hackage musicScroll 0.2.3.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.2.3.0 (RubenAstudillo)
22:02:15 <zebrag> :t (<*>)
22:02:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:02:31 <slack1256> yay now with more scrolls
22:04:02 <zebrag> What is strange is that for the purpose of parsing f a -> f (a -> b) -> f b seems more appropriate, and since it implies some evaluation order, I don't see how to reduce one operator to the other
22:07:06 <monochrom> For the second point: From either version you can get liftA2, from liftA2 you can get both versions.
22:08:22 <zebrag> I yet fail to see how: liftA2 f x y = f <$> x <*> y
22:08:45 <monochrom> For the first point: I thought it was "obvious" that one version is most convenient for a prefix operator followed by its operand, and the other most convenient for an operand followed by its postfix operator, and so both are equally appropriate and useful.
22:10:01 <zebrag> yes, yes, I agree "obvious" was a lot there
22:11:51 <monochrom> Haha darn I should have taught this Consumed vs Empty trick to my students.
22:12:18 <zebrag> (<**>) :: Applicative f => f a -> f (a -> b) -> f b 
22:15:39 <zebrag> I understand one like to end one's sentences by "and, so both are equally appropriate and useful" (I've added the comma so that it is a iambic pentameter all by itself)
22:19:51 <jackdk> povman: looks like our IsomorphicTo didn't get any response. I might ask -cafe@
22:22:10 <povman> Good idea
22:24:26 <povman> Though I can't subscribe to that list because my email address is "not valid" :|
22:40:45 <stretchp> why am I getting this parse error? https://pastebin.com/TbvpnBx3
22:41:23 <monochrom> All the spurrious indentation.
22:43:45 <stretchp> monochrom: Indentation?
22:43:52 <monochrom> Yes, indentation.
22:44:22 <stretchp> monochrom: how is that causing a parse error?
22:44:37 <c_wraith> haskell uses alignment to determine grouping
22:44:46 <monochrom> If some indentation confuses the compiler, it's a parse error.
22:44:59 <c_wraith> the various foos should probably line up with each other so that they make sense
22:45:28 <c_wraith> I mean, they should do that anyway, so that they make sense to the reader
22:45:36 <c_wraith> so it's nice that the compiler asks you to get it right
22:50:00 <stretchp> I see but I remove all indentation and still getting the same error. I am following along with https://www.cis.upenn.edu/~cis194/spring13/lectures/01-intro.html
22:51:12 <stretchp> c_wraith: so is it better not to use indentation at all
22:51:46 <monochrom> And that page shows you correct indentation.  You added more than that.
22:52:03 <dsal> stretchp: what does your code look like now?  What error are you getting?
22:54:30 <stretchp> dsal: https://pastebin.com/uTBXqpDt
22:54:43 <dsal> You still have weird indentation there.
22:55:06 <monochrom> From the 2nd line onward why do you have 1 space before every line
22:56:47 <stretchp> monochrom: didn't realize that I had that much space before every line
22:57:22 <dsal> You should be able to see the foos not starting in the same column.
22:59:05 <stretchp> oh okay got it, so basically funtion names should always line up without any indentation
23:04:44 <povman> Top level definitions must have no indent. Everything within a definition must have the same indent level.
23:06:43 <povman> The indentation rules are quite complex but natural once you get used to it. I like to run ormolu to confirm the indenting is correct.
23:13:40 <zebrag> monochrom: It took me quite some time to figure it out about (<**>). I think I was reading the implementation upside down. Thanks
23:17:49 <dsal> :t (<**>)
23:17:51 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
23:20:47 <stretchp> povman: thanks guess I need to install everything I just have ghci
23:37:30 <povman> @stretchp :) It's all just helpful things. GHC is all you really need.
23:37:30 <lambdabot> Unknown command, try @list
23:56:13 * hackage homura-stopwatch 0.1.3 -   https://hackage.haskell.org/package/homura-stopwatch-0.1.3 (ncaq)
