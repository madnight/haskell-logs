00:12:37 <maerwald> koz_: should be possible to do implement
00:13:14 <maerwald> afaiu it just requires --target=<foo> to configure
00:13:34 <koz_> You also probably want to prefix the resulting binary.
00:13:43 <koz_> You wouldn't want it clashing with the native one.
00:13:54 <maerwald> Yeah, that'll require more work
00:18:38 <maerwald> I also wanted to allow to compile a ghc and than have a custom suffix appended, e.g. for testing patches.
00:18:48 <maerwald> e.g. wrt the eff patches
00:25:44 <DocKlobi> https://www.irccloud.com/pastebin/Il9ydho7/
00:27:08 <siraben> DocKlobi:  Oof, scary indeed.
00:28:03 <maerwald> how so?
00:29:54 <maerwald> It's just terrible obfuscation
00:30:20 <siraben> Yeah, but who is going to write code like that?
00:30:41 <siraben> @pl f x y = x * y + 2 * (x - y)
00:30:41 <lambdabot> f = ap (ap . ((+) .) . (*)) (((2 *) .) . (-))
00:30:43 <koz_> maerwald: Can't you feed the build a flag for a prefix/suffix?
00:30:52 <maerwald> not yet
00:31:11 <DocKlobi> Well, the training materials give you the impression monads are just more powerful than applicative. At least for me.
00:31:11 <DocKlobi> I am writing code like that so I can UNDERSTAND.
00:31:16 <koz_> Really? GHC's builds don't have this capability? Woah.
00:31:16 <maerwald> siraben: this looks like clinical examples from homework exercise
00:31:26 <maerwald> where professors think it is valuable to understand it
00:31:34 <siraben> Really? Huh.
00:32:45 <maerwald> I'm trying to find the SO post from kmett that explains the (->) Monad instance in detail
00:33:14 <DocKlobi> I want to understand the differences so I can take a proper decision
00:33:41 <koz_> DocKlobi: They are more powerful - do you know what sets them apart?
00:33:51 <jeetu> 1 
00:34:13 <siraben> There are more applicatives than monads, but roughly speaking monads are more powerful because they allow the future computation to depend on dynamic values.
00:34:27 <koz_> siraben: Or, more concisely, (>>=).
00:34:29 <DocKlobi> Monads allow you to inspect intermediary values, right?
00:34:34 <siraben> In some applicative expression, f <$> x <*> y, we run x and y always.
00:34:52 <koz_> Monads also allow us to choose the order effects happen in.
00:34:56 <koz_> Applicatives don't.
00:34:57 <siraben> DocKlobi:  Yeah, and as koz_ mentioned you can decide _which_ computation to run next.
00:35:04 <koz_> (there might still be an order, but we can't choose it)
00:35:12 <siraben> (although I saw an ICFP talk on an abstraction between monads and applicatives...)
00:35:15 <koz_> This is the key thing with bind.
00:35:21 <koz_> :t (>>=)
00:35:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:35:30 <siraben> https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf
00:35:39 <koz_> siraben: Yeah, selectives are a thing.
00:35:53 <siraben> Haven't used it myself, anyone have compelling cases for when they make sense?
00:36:01 <koz_> siraben: Facebook apparently do.
00:36:07 <koz_> I've not really seen one yet.
00:36:14 <DocKlobi> Yeah, thanks. Send me links with more info.
00:36:53 <siraben> DocKlobi: http://strictlypositive.org/IdiomLite.pdf
00:36:56 <koz_> siraben: You might wanna check the paper about them.
00:37:06 <koz_> They describe their use cases in it IIRC.
00:37:11 <siraben> koz_:  I plan to, thanks.
00:38:25 <maerwald> DocKlobi: https://stackoverflow.com/a/5316690
00:43:15 <maerwald> (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b
00:43:23 <maerwald> if you look at the unrolled type signature, it makes sense
00:43:44 * hackage json-autotype 3.1.0 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-3.1.0 (MichalGajda)
00:47:15 <DocKlobi> yeah, reading type signatures is key to. And that kind stuff is another challenge. Finding good tutorials and exercises is difficult.
00:48:09 <maerwald> Just don't use the Monad/Applicative instance for '(->) r' 
00:48:16 <maerwald> no one is going to understand it
00:48:41 <maerwald> Last time I saw that in use was in the hspec documentation afair, and the example had a bug.
00:49:12 <koz_> Yeah... I would agree with maerwald on that one.
00:49:44 <siraben> The S combinator corresponds to (>>=), right?
00:49:59 <koz_> :t ap
00:50:01 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:50:03 <koz_> ^
00:50:14 <koz_> Well, specializing for the monad instance of function.
00:50:31 <siraben> (r → a → b) → (r → a) → r → b
00:50:36 <siraben> :t (\x y z → x z (y z))
00:50:38 <lambdabot> (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
00:50:59 <siraben> voilà
00:51:10 <siraben> :t (>>=)
00:51:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:52:22 <siraben> (r → a) → (a → r → b) → r → b. Looks isomorphic to ap again.
00:53:15 <DocKlobi> the reader (->) pattern ist just the most attractive thing in Haskell. All the cool stuff seems to be implemented using it.
00:55:43 <koz_> siraben: Hmm, didn't realize that before.
01:04:12 <koz_> @pl \x y z -> x z (y z)
01:04:12 <lambdabot> ap
01:04:18 <koz_> ^ source of thinking
01:06:50 <DocKlobi> What? Not to use applicative/monad instance of (-> r)? I am confused. It's how Reader and State are implemented, right? 
01:08:13 <koz_> State isn't related to (-> r).
01:08:24 <koz_> Reader is literally that, but we usually prefer to be explicit about it.
01:08:49 <koz_> (as in, work with Reader r a, as opposed to r -> a)
01:09:08 <maerwald> DocKlobi: no
01:09:57 <maerwald> The (-> r) instance isn't use in ReaderT
01:11:12 <koz_> maerwald: Yeah, good point.
01:11:31 <koz_> I keep forgetting that Reader is really ReaderT Identity etc.
01:15:04 <DocKlobi> Well, maybe my wording is confusing (mostly myself). I associate Reader with r -> (r, a) and State with s -> (a, s).
01:17:12 <koz_> The latter is correct, the former not so much.
01:17:44 <koz_> Since the former isn't Reader r a - it's Reader r (r, a), which isn't the same thing.
01:19:23 <DocKlobi> Ah, alright, thanks.
01:19:23 <DocKlobi> The ((->) r) for me is just the most challenging thing to handle in Haskell. 
01:20:23 <Sathiana> hello, Anyone using Archlinux here - I am looking for a simple Haskell terminal Dev setup with Vim in mind if possible. Most of the guides are outdated or don't work so well on Archlinux
01:21:11 <freeman42x[m]> is there any function that takes a string and can put some other String between each 2 letters of the String? <- probably silly question haha
01:21:12 <koz_> Sathiana: Basically, use ghcup to get a compiler.
01:21:23 <koz_> DO NOT under ANY circumstances EVER use Arch's own GHC.
01:21:34 <koz_> You can use stack if you like.
01:21:48 <koz_> I use ALE - am happy to provide my config in a paste.
01:22:14 <Sathiana> yes do that pl
01:22:16 <Sathiana> plz*
01:22:51 <koz_> Sathiana: How familiar are you with vim configuration? In particular, do you know of local .vimrc?
01:23:04 <freeman42x[m]> ah, found what I needed, actually knew its name: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:intersperse
01:23:35 <koz_> freeman42x[m]: If you're using String, anything that works on lists will also work on them. Since underneath it all, String is [Char].
01:24:13 <freeman42x[m]> koz_: yes, I know that. But I could not find anything before I asked
01:25:38 <koz_> freeman42x[m]: Yes, I agree, #haskell is a great rubber duck.
01:25:48 <Sathiana> koz_, i'm ok with vim/nvim, I am new to Haskell and was testing coc.nvim with Hie but it works and breaks a few minutes later
01:26:01 <koz_> Sathiana: I don't recommend either of those things.
01:26:06 <koz_> My experience with them hasn't been positive.
01:26:16 <freeman42x[m]> koz_: the reason I found the function is not Hoogle in this case though, just happened to recall there is something called intersperse
01:26:26 <koz_> OK, so basically, my ALE config resides exclusively in project-local .vimrc (or .nvimrc in my case) files.
01:27:14 <koz_> Here is what I usually go with: http://ix.io/2iDj
01:27:20 <koz_> This is tailored for use with cabal new-build.
01:27:36 <koz_> If you wanna use stack, you can use ALE's stack-build instead.
01:27:36 <Sathiana> nice, will test it out
01:27:40 <koz_> I don't have a config handy.
01:27:54 <koz_> This assumes that you have a GHC set up for the project (via cabal new-configure, or on PATH).
01:28:10 <koz_> Obviously you will need said GHC. ghcup is the method I would suggest if you want simple.
01:28:22 <Sathiana> ok
01:28:52 <koz_> You can modify the (additional) flags being handed to cabal new-build by editing that Set call.
01:29:03 <koz_> The comments should explain the rest
01:29:27 <koz_> ALE can be found here: https://github.com/dense-analysis/ale
01:32:02 <koz_> I also have autoformating with ormolu enabled there - delete that whole thing if you don't want it.
01:53:41 <siraben> Anyone have papers that they'd like to see in my list? https://github.com/siraben/fp-notes/blob/master/Papers.md
01:54:54 <maerwald> papers about?
01:55:12 <siraben> Functional programming.
01:55:28 <siraben> I'm compiling a list of notes on FP and related topics.
01:56:00 <siraben> Sort of a survey of the field.
01:58:58 <koz_> siraben: Lazy Functional State Threads should _100000%_ be on that list.
01:59:04 <koz_> Also 'Codata in Action'.
01:59:28 <siraben> koz_:  Thanks. I haven't read those, seems interesting.
01:59:29 <koz_> There's also an older codata paper which is super-important, very readable and _still_ highly relevant, whose name I will dig out shortly.
01:59:42 <koz_> siraben: Lazy Functional State Threads is basically 'how do ST/IO work'.
01:59:47 <koz_> It's an oldie, but a goldie.
01:59:58 <koz_> Codata in Action is more recent, but _fascinating_ on many levels.
02:02:05 <koz_> That last paper is aggravating me - I'll need to dig a bit to get its name.
02:02:27 <siraben> koz_:  What's Codata in Action about?
02:02:49 <siraben> Nice, I want to know how ST/IO work, because I'm implementing a compiler for a lazy functional language that uses graph reduction.
02:02:56 <koz_> siraben: Basically the data-codata duality, and how we can translate one into the other for underlying languages which don't provide both.
02:03:18 <koz_> Applicative Programming with Effects also strikes me as a must-include.
02:03:27 <koz_> The Essence of the Iterator Pattern too.
02:04:12 <siraben> Yep, got Applicative Programming with Effects.
02:04:22 <siraben> I need to read Essence of the Iterator Pattern, that's planned.
02:04:51 <koz_> Got it! 'Total Functional Programming' by David Turner.
02:04:53 <siraben> koz_:  What about algorithms and data structures? I have the paper on finger trees and Oksaki's book in the file on FP books.
02:05:01 <koz_> siraben: Very broad topic.
02:05:03 <siraben> koz_:  Ohh! I read that one!
02:05:05 <siraben> It was really good.
02:05:19 <koz_> The finger tree paper is excellent.
02:05:25 <koz_> The IntMap one is also pretty awesome.
02:05:30 <koz_> The HAMT paper too.
02:05:40 <koz_> There's also Bagwell tries I guess?
02:05:56 <siraben> I was wondering if anyone used Haskell for competitive programming? I wonder how far the FP approach could be taken.
02:06:00 <koz_> Brodal-Okasaki heaps also.
02:06:13 <siraben> HAMT?
02:06:20 <koz_> Hash-array mapped trie.
02:06:21 <siraben> Ah, ideal hash mapped trie.
02:06:28 <Uniaika> HAMT are a nice datastructures
02:06:40 <koz_> It's the driver behind HashSet/HashMap I believe.
02:06:40 <siraben> Oh, yes.
02:06:49 <Uniaika> Erlang maps are serialised either as tuple, if there are less than 32 keys, or as a HAMT if there are more
02:07:00 <koz_> Uniaika: You mean a list of tuples no?
02:07:07 <koz_> This is a common optimization (Clojure does it too).
02:07:08 <Uniaika> yeah list of tuples
02:07:49 <siraben> koz_:  Ok, I've saved those papers, anything else you found fascinating?
02:08:11 <koz_> 'A Reflection on Types' is great.
02:08:28 <koz_> 'Functional Reactive Animation' is also pretty great.
02:08:35 <koz_> (it gave us FRP)
02:08:47 <koz_> The levity polymorphism paper.
02:09:11 <koz_> 'Safe Zero-Cost Coercions'.
02:10:23 <koz_> The LogicT paper by Oleg whose name escapes me is also pretty amazing.
02:11:18 <koz_> Oh oh oh, 'Compiling to Categories'.
02:11:35 <koz_> Also this: https://www.manuelbaerenz.de/files/Rhine.pdf
02:12:22 <koz_> I'm probably forgetting a few.
02:12:41 <koz_> There's a tonne of foundational stuff as well.
02:12:50 <koz_> (but I don't remember them all)
02:12:59 <koz_> Lazy Functional State Threads is probably my single favourite.
02:13:21 <koz_> It was one of the biggest mind-blown moments ever in my life reading it.
02:13:38 <koz_> (although Total Functional Programming also did that for me)
02:14:25 <koz_> I guess the recursion schemes paper, and the 'recursion schemes from comonads' paper count.
02:14:35 <koz_> They're definitely dense af, but the ideas are cool, especially in the second one.
02:14:57 <siraben> Ah right, also FP with Bananas Lenses Barbed Wire etc.
02:15:09 <koz_> Yeah, that one.
02:15:09 <siraben> I think I've seen Bananas in Space as well-cited too?
02:15:21 <siraben> Oleg's paper on fair backtracking monads?
02:15:28 <koz_> siraben: I think so?
02:15:34 <koz_> I think that's the LogicT paper.
02:16:01 <siraben> Oof, Compiling to Categories is a little dense, may need to get a mathematician help me read that!
02:16:02 <koz_> Also, I dunno if TMR counts, but _everything_ in TMR 6.
02:16:22 <koz_> In general, check out TMR, especially the early issues.
02:16:26 <koz_> Some _real_ gold there.
02:16:53 * koz_ wonders how much more paper knowledge he can flex.
02:17:21 <koz_> ALSO the discriminant sorting papers!
02:17:28 <koz_> How could I forget those, they're brilliant.
02:17:44 <koz_> s/discriminant/discrimination/
02:18:42 <siraben> Discrimination sorting?
02:18:48 <siraben> Wow, you read a lot of papers! Are you a researcher?
02:19:07 <koz_> Was.
02:19:16 <koz_> Discrimination sorting is like a very very general radix sort.
02:19:19 <siraben> One of my favorite TMR articles was the "Type-level instant insanity"
02:19:32 <koz_> (basically, it demonstrates that radix sorting can be extended to more-or-less arbitrary ADTs)
02:19:34 <siraben> Ah, what do you do now?
02:19:43 <koz_> I write compiler back-ends.
02:19:52 <koz_> Sometimes I also write schema language specifications and implementations.
02:19:55 <koz_> For considerable money.
02:20:03 <siraben> Whoa, that's fascinating.
02:20:06 <koz_> Agreed.
02:20:08 <siraben> Ah, which compilers?
02:20:15 <koz_> They're internal projects.
02:20:23 <koz_> Not really at liberty to discuss many details.
02:21:12 <koz_> I keep some tabs on research areas which interest me.
02:22:23 <siraben> Sure. Thanks for the recommendations!
02:22:31 <koz_> No worries. Will let you know if I can think of more.
02:22:55 <koz_> There's probably a few papers that fell by the wayside in my mind.
02:24:32 <koz_> Also, this Functional Pearl: http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf
02:24:44 <koz_> _Very_ relevant if you're gonna be doing language implementations.
02:25:09 <koz_> Do you have Boxes go Bananas on your list?
02:25:13 <koz_> It's the PHOAS paper.
02:26:31 <koz_> In the compilation section, SPJ's paper on compiling functional languages to stock hardware is great.
02:26:37 <koz_> It's what gave us the STG.
02:27:22 <siraben> Nope, I haven't done Boxes go Bananas yet.
02:28:13 <koz_> But yeah, I think I've just about tapped out my memory when it comes to papers I liked.
02:28:46 <siraben> koz_:  you implement functional languages, what do you make of Ben Lynn's Haskell compiler using Oleg's semantic bracket abstraction?  https://crypto.stanford.edu/~blynn/compiler/
02:29:11 <siraben> koz_:  Oh, I just realized I was looking for a paper on parsing whitespace sensitive layouts, have you seen any?
02:29:21 <koz_> I haven't seen that paper before - will read.
02:29:33 <koz_> I don't think parsing whitespace-sensitive layouts warrants theoretical coverage.
02:30:08 <siraben> Haha, then how did the GHC developers do it?
02:30:25 <koz_> The same way the Pythons ones did.
02:30:32 <koz_> s/Pythons/Python/
02:30:45 <siraben> They just did it?
02:30:47 <koz_> You just need a bit of extra parser state.
02:31:03 <koz_> It's annoying and fiddly, but not really theoretically hard in the way that requires a specific treatment.
02:31:12 <siraben> Ah, I see.
02:31:20 <siraben> I was wondering if a compositional solution was found, alas.
02:31:40 <koz_> Probably some kind of solution exists. I'm not aware of any publications in this area, and I doubt they exist.
02:31:52 <koz_> (also, I deal with back-ends)
02:31:59 <koz_> (parsing is a front-end concern, and thankfully not mine)
02:32:18 <siraben> I see.
02:32:45 <siraben> What about papers on type checking?
02:32:53 <koz_> There are _zillions_ of those.
02:33:01 <siraben> Also, type checking in dependently typed languages.
02:33:03 <siraben> Ah, of course.
02:33:08 <siraben> Any ones that stand out?
02:33:14 <koz_> There's one recent one on dependent type checking that inspired Idris 2.
02:33:17 <koz_> Let me dig that out.
02:33:25 <siraben> Typing Haskell in Haskell seems pretty good
02:33:57 <koz_> https://www.type-driven.org.uk/edwinb/papers/idris2.pdf
02:34:10 <koz_> I would recommend two _books_ for typechecker stuff.
02:34:13 <koz_> TAPL is one.
02:34:37 <siraben>  koz_ : For compiling functional languages I have SPJ's book on implementing functional languages, how useful is that still?
02:34:46 <koz_> Type Theory and Formal Proof: An Introduction is another.
02:34:52 <koz_> It's good for fundamentals.
02:34:52 <siraben> Ah, thanks. Yeah, TAPL is a classic.
02:35:00 <koz_> Techniques have _somewhat_ moved on.
02:35:13 <koz_> I actually recommend folks to read Type Theory and Formal Proof first.
02:35:27 <koz_> It sounds scary af from the title, but it's actually _easier_ and _more_ approachable than TAPL in my experience.
02:36:00 <siraben> Ah thanks.
02:36:46 <siraben> koz_:  Is compiling to combinators acceptable in your experience, or do you use more efficient compilation techniques?
02:36:47 <koz_> If you've read SPJ's book, I _definitely_ recommend the 'compiling functional languages to stock hardware' paper.
02:37:06 <koz_> In my experience I dunno. It depends on the backend.
02:37:16 <koz_> If you have an SKI machine, compiling to combinators is your only choice. :P
02:37:32 <koz_> On more realistic hardware, there's the STG, which is what GHC uses, for a reason.
02:37:37 <koz_> SPJ's paper on it elaborates.
02:37:49 <koz_> There's also whatever clever stuff GRIN is doing, which has the attention of a bunch of people.
02:37:51 <siraben> Ah, I'm trying to implement a functional language for the Ethereum Virtual Machine, which has its quirks such as program being in read-only memory, primarily stack-based etc.
02:38:08 <koz_> Well, the STG is basically a three-stack automaton.
02:38:17 <siraben> I see. This isn't terribly difficult for someone to implement in a few months, right?
02:38:25 <koz_> Like, seriously - you _definitely_ wanna read 'compiling functional languages to stock hardware'.
02:38:27 <koz_> I really dunno.
02:38:34 <siraben> Ok, I see.
02:38:36 <koz_> It depends on many factors I can't predict for.
02:38:55 <koz_> I am by no means an expert in compilers - my experience is rather narrow and focused on one specific set of requirements.
02:39:02 <koz_> They are, by their very nature, not everyone's. :P
02:39:24 <siraben> Right. I was reading Compiling to Continuations last, which put a lot of emphasis on, well, continuations, CPS, register spilling and more.
02:39:29 <siraben> Which seem quite compilated.
02:39:44 <siraben> Not the continuations bit but various problems that can quickly become NP-hard.
02:39:51 <koz_> Administrative normal form is usually preferred these days.
02:40:01 <siraben> Ah, how come?
02:40:04 <koz_> CPS exposes some optimizations, but hides others, which ANF is designed to address.
02:40:14 <koz_> I remember reading a paper on this topic, but its title escapes me.
02:40:33 <koz_> Another thing worth reading: Types are Calling Conventions.
02:40:35 <dramforever> That's the first time I heard what 'A' stands for in ANF
02:40:41 <koz_> _VERY_ relevant when compiling functional languages.
02:41:00 <dmj`> siraben: you should definitely check out lambda lifting if you're interesting in compiling functional languages, it's one way to go from lambda calculus to something like LLVM
02:41:08 <siraben> koz_: I wrote an implementation for ANF based on Matt Might's code, which I think comes from a paper. https://gist.github.com/siraben/447c419508b460afc99a232d5df8063f
02:41:24 <koz_> siraben: It most definitely comes from a paper - where do you think ANF first got defined? :P
02:41:56 <siraben> Ah, 1993 by Flanagan, Sabry, Duba and Felleisen
02:41:57 <siraben> Heh, of course!
02:42:00 <siraben> dmj`:  Right. I'll check that out as well.
02:42:05 <siraben> koz_:  What's types are calling conventions about?
02:42:23 <koz_> siraben: Basically, it talks about 'how do we determine whether we can treat any given function as fixed-arity or not'.
02:42:30 <dmj`> siraben: how complicated is the language you're trying to implement?
02:42:32 <koz_> Very critical when compiling function calls efficiently.
02:42:54 <dmj`> siraben: https://github.com/sdiehl/paris-fp <-- check this out
02:43:19 <siraben> dmj`: Something similar to Ben Lynn's Haskell https://crypto.stanford.edu/~blynn/compiler/type.html
02:43:52 <koz_> dmj`: I can't help but sound the word 'Haskell' there as 'askell', with emphasis on second syllable, and the Francophone l.
02:43:56 <siraben> Although, at first, substantially less complicated. Basically, ADTs, typeclasses, laziness, I/O is a must for the applicaiton
02:44:13 <koz_> siraben: I assume then you have read the type classes paper?
02:44:21 <siraben> koz_: Which one?
02:44:25 <koz_> As well as the one on fundeps and the one on MPTCs?
02:44:34 <koz_> The original one by Simon Marlow (I think).
02:44:39 <koz_> Title escapes me right now.
02:44:40 <dmj`> siraben: start with something very basic otherwise (in my experience, it's very easy to get discouraged)
02:44:52 <siraben> Right. I can see that.
02:44:59 <dmj`> siraben: the type-checker can even be developed independently of the code generator
02:45:07 <dmj`> siraben: you dont' need to implement data types in the beginning
02:45:20 <dmj`> siraben: I just started with an interpreter, didn't even implement a frontend
02:45:39 * ski . o O ( "Always Haskel was such a guy: a kombinator." / "A what?" / "A guy what makes kombinacya, a schemer ⋯ a crook." )
02:46:05 <dmj`> siraben: if you want a good grasp of the techniques in typing haskell in haskell there is a great video, after this you'll eventually want to do the bidirectional approach, but baby steps
02:46:28 <dmj`> siraben: someone who now works at dfinity gave a great walkthrough, the paper can be a little opaque at times
02:46:53 <siraben> koz_: Ah, I've read those papers but I'm not planning on implementing fundeps of multi params yet.
02:46:54 <siraben> s/of/or
02:47:24 <koz_> siraben: Fair enough, figured I'd mention.
02:47:28 <siraben> dmj`: Thanks, I'll take a look at your language.
02:47:53 <dmj`> siraben: https://www.youtube.com/watch?v=ytPAlhnAKro&t=9s
02:48:21 <dmj`> for understanding type inference (directly from thih paper)
02:48:37 <dmj`> good supplement
02:48:53 <dmj`> siraben: if you use LLVM then you don't need to worry about register allocation either
02:49:05 <siraben> dmj`: Thanks, I really like Ben Lynn's explanation. https://crypto.stanford.edu/~blynn/lambda/hm.html
02:49:16 <siraben> dmj`: Ah, the Ethereum Virtual Machine doesn't have registers!
02:49:33 <koz_> I think Stephen Diehl had a whole series of writing a language that compiles to LLVM.
02:49:42 <koz_> siraben: You said it was a stack machine?
02:49:46 <siraben> Yes
02:49:52 <koz_> In that case, know much about Forth?
02:50:14 <siraben> koz_: Haha, glad you asked! https://github.com/siraben/zkeme80
02:50:19 <koz_> LOL
02:50:21 <koz_> Figures.
02:50:22 <siraben> Yeah, we're looking at a statically typed Forth as well.
02:50:41 <koz_> Definitely _definitely_ read up on the STG then.
02:50:49 <koz_> You will feel a _very_ strong sense of familiarity.
02:50:53 <siraben> Ok, thanks.
02:51:09 <siraben> I think I lost the link, which one is it?
02:51:11 <koz_> May even give you a clue how to proceed.
02:51:13 <koz_> I never linked it.
02:51:24 <siraben> https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf ?
02:51:29 <koz_> https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
02:51:31 <koz_> Yeah that one.
02:51:32 <dmj`> siraben: nice, thats pretty terse
02:51:39 <koz_> s/Compiling/Implementing/
02:51:46 <koz_> Human error lol.
02:51:48 <koz_> Lossy memory.
02:51:53 <koz_> Need ECC RAM in my brain.
02:52:34 <siraben> At least, I have the SKI machine implemented in EVM; https://gist.github.com/siraben/cbf698c0455f55d41c01c14177e8d90a
02:53:27 <__monty__> siraben: Finally a typed EVM language with some thought as to design?
02:53:42 <siraben> Ben Lynn uses the Scott encoding approach to ADTs, which allow for a completely uniform compilation. I might try that.
02:54:01 <siraben> __monty__:  Haha, yes! We really need an alternative because Vyper is just not cutting it.
02:55:03 <__monty__> I'm surprised it's taken this long tbh.
02:55:31 <__monty__> I looked at it for a thesis a couple years ago. Sadly none of the profs was interested.
02:55:38 <siraben> I'm surprised as well, there isn't much, if any, work to base this on.
02:55:46 <siraben> Looks like we're starting from scratch.
02:55:54 <koz_> siraben: Not entirely.
02:56:05 <koz_> The 80s had a bunch of research for compiling functional languages to stack machines.
02:56:17 <koz_> The STG is, if anything, a logical consequence of that.
02:56:27 <koz_> (stack machines never got popular, but the ideas remain)
02:56:56 <siraben> Ah, so STG would be very suitable for this?
02:57:24 <koz_> siraben: Read it and check? I dunno basically anything about the EVM.
02:57:36 <koz_> You mentioned it's a stack machine.
02:57:42 <koz_> That rang a few bells in my head.
02:57:46 <koz_> But I dunno it as well as you do.
02:59:18 <siraben> It's really a stack machine, not unlike Forth. But no return stack, and the cells are huge 256 bits each
02:59:41 <siraben> Stack has a limit of 1024 cells, I wonder if there'll be issues.
03:00:04 <koz_> I doubt it.
03:00:09 <koz_> That's _huge_.
03:01:42 <siraben> Yeah, it's likely we'll even split up cells into 64-bit subcells, if that gains us anything
03:02:18 <siraben> It shouldn't matter, though. Compiling in the first place will be difficult.
03:03:33 <siraben> koz_: Thanks a lot, this is extraordinarily helpful.
03:03:40 <koz_> Glad to hear!
03:15:59 <dmj`> siraben: no registers no problems :)
03:16:23 <dmj`> siraben: mo' registers, mo' problems
03:16:56 <siraben> Haha, yes, being a stack machine this alleviates issues about register allocation.
03:18:10 <dmj`> siraben: problem solved :)
03:39:02 <dramforever> Hi! It seems that the newest shiny effect library is polysemy, and I skimmed the docs and. Is there any 'advanced' tutorial out there that covers intercept(H), Tactical, Inspector etc. out there, or do I have to just figure it out from the docs for now?
03:39:21 <dramforever> *I skimmed the docs and it seems to meet my needs
03:39:58 <maerwald> dramforever: the newest is eff, but you need GHC patches to run it
03:40:11 <dramforever> There's more?
03:40:21 <maerwald> and polysemy is semi-abandoned, no?
03:40:28 <dramforever> damn
03:40:41 <dramforever> I haven't even caught up and it's already outdated
03:41:56 <dramforever> So Eff seems to be something like ST that's actually wired into the compiler
03:42:07 <maerwald> Check out https://www.reddit.com/r/haskell/comments/dm3wyd/wip_eff_screaming_fast_effects_for_less_the/
03:42:18 <maerwald> isovector (author of polysemy) commented there too
03:43:16 <dramforever> this: 'If this goes on I need to be polymorphic over the effect library :)'
03:43:25 <dramforever> exactly my thoughts now
03:43:51 <dmj`> I think it uses a ghc plugin to alter core
03:43:54 <dramforever> This is also exactly me: 'I was just starting to like polysemy and wanted to give it a try in my next toy project. '
03:44:20 <dmj`> ghc plugins are underrated, ghc preprocessors are super underrated
03:44:54 <maerwald> I just gave up on effects system. I do use open variants though.
03:45:17 <maerwald> So at least I can try out expressive and composable errors
03:45:23 <maerwald> Don't need all effects
03:46:42 <dramforever> Might just do everything in something like: Member '[Foo, Bar] x => Reader x (IO a)
03:46:45 <dramforever> Or maybe ST s a
03:47:07 <r3dnaz[m]> How do I get open sum types in Haskell?
03:49:04 <dmj`> mtl works great
03:49:08 <dmj`> no complaints here
03:49:12 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant.html#t:V
03:49:15 <maerwald> r3dnaz[m]: ^
03:50:02 <r3dnaz[m]> Is that the best way?
03:50:06 <maerwald> No idea :D
03:51:12 <r3dnaz[m]> Very interesting. Thank you.
03:51:13 <maerwald> dmj`: mtl hides order of effects and you have all those problems with multiple readers etc.
03:51:26 <maerwald> r3dnaz[m]: Did I not send you that already?
03:51:45 <dmj`> maerwald: if you have a State on top of a State, just combine the two states, problem solved
03:51:53 <dmj`> maerwald: same with reader
03:51:56 <maerwald> awkward
03:52:02 <dmj`> all these people with their deep stacks, I'm just like ...
03:52:13 <dmj`> you pay for it in the bind too
03:53:08 <dmj`> better yet, don't use transformers at all
03:53:09 <r3dnaz[m]> dmj`: I agree. And use some optics if necessary.
03:53:11 <maerwald> mtl is barely an effects system. It's just the lesser evil.
03:53:29 <dmj`> r3dnaz[m]: yea the MonadState lenses are very nice, .= and fam
03:54:12 <dramforever> What if you use multiple states but use an interpreter to combine these
03:55:01 <dmj`> it sounds like you're coding against the grain of your own abstractions
03:56:04 <dramforever> Doesn't sound so bad though
03:56:21 <dmj`> I mean, anything is possible, but I'd optimize for readability and understandability 
03:56:37 <dmj`> at age 65 when you look at that code, will you feel the same
03:57:07 <maerwald> "opzimize for redability and understandability" -- is that why you like nix? =)
03:57:13 <dramforever> The interpreter is only at the top level where run your functions though
03:57:50 <dmj`> maerwald: I like nix for other reasons :) nix is just a necessary evil for now
03:57:50 <dramforever> Isn't it just 'whenever you run multiple State effects, combine them first to make things run faster'?
03:57:59 <maerwald> dmj`: it's a huge evil
03:58:26 <dmj`> maerwald: depends if you know it or not
03:58:51 <maerwald> dmj`: nah, knowledge doesn't make something less evil, just more bearable
03:58:56 * dramforever removes polysemy from dependencies
03:59:13 <dmj`> maerwald: I'm writing nix right now and its great
03:59:42 <maerwald> suddenly, I can see your priorities shifting =)
04:00:26 <dmj`> nix makes it so much easier to build, develop and deploy haskell reliably in my opinion, but at the end of the day, people like what they know and don't like what they don't know
04:00:43 <dmj`> I don't see any good alternative to nix for working with ghc cross compilers
04:01:13 <dmj`> plus, nix and haskell share the purity concerns. Haskell people all about purity but when it comes to builds they revert back to mutable global state, it's like a disconnect
04:02:16 <dramforever> I've heard someone dislike Nix specifically because it 'innovates too much'
04:02:40 <dramforever> There isn't even an excuse
04:03:04 <maerwald> dmj`: it's just... most of the time ppl don't need it :)
04:04:18 <dmj`> maerwald: I work with cross-compilers, I need it
04:04:18 <dramforever> One thing I hate about Nix: (Effectively) destroys dynamic linking
04:04:26 <maerwald> dmj`: that might be a good use case
04:04:34 <dmj`> maerwald: among others, yes.
04:04:37 <dramforever> If building something and pinning its runtime dependencies are separate
04:04:37 <maerwald> dmj`: my distro has native cross support too though.
04:04:53 <maerwald> I can easily build for arm or whatnot if I want to
04:04:55 <dramforever> Many things would go much more smoothly
04:05:28 <dramforever> (Also many will not, but... I think it's worth a go if we had a change to redo Nixpkgs)
04:05:31 <dmj`> maerwald: most distros come with broken haskell / ghc packages from their default installer
04:05:34 <dramforever> *chance
04:05:46 <dmj`> dramforever: how does nix destroy dynamic linking?
04:05:50 <maerwald> dmj`: I don't need the haskell packages to be part of the distro to do cross compiling
04:06:10 <dmj`> sure, again, people like what they know and don't like what they don't know
04:06:22 <dmj`> if I want to statically link haskell I have a musl toolchain ready to go
04:06:23 <dmj`>   ghc = pkgs.pkgsCross.musl64.haskellPackages.ghcWithPackages (p: with p; [ directory split transformers mtl linux-mount ] );
04:06:25 <maerwald> No, my point is: thinking about use case first :)
04:06:40 <maerwald> And always introducing the simples possible solution
04:07:03 <dmj`> maerwald: it's like a C programmer telling a Haskell programmer, "it's just too complicated, think about your use case"
04:07:07 <maerwald> If an excel sheet works, fire your programmers and be done with it.
04:07:12 <dramforever> dmj`: I mean, the fact that something can have varying dependencies is gone, and if you need to change anything you need to rebuild it
04:07:12 <dmj`> making builds pure is a hard problem
04:07:32 <maerwald> dmj`: if a static executable works, then why would you need reproducible configuration?
04:07:35 <dramforever> You can hack things a bit and replace dependencies
04:07:40 <maerwald> Your analogy makes no sense
04:07:51 <dmj`> maerwald: so next week when hackage is different, my package didn't break
04:08:05 <maerwald> dmj`: you can freeze the index state
04:08:21 <maerwald> have you encountered problems with that in production?
04:08:32 <maerwald> I have not (after using it for over a year)
04:08:34 <dmj`> maerwald: same thing as pinning the hash, you're preaching to the choir man. I used to cabal freeze and check in the freeze file, etc.
04:08:35 <dramforever> dmj`: But what if we have replacable dependencies straight away?
04:08:52 <dmj`> maerwald: most production problems I have, I'm using more than one language and nix covers a lot of different languages so its a great abstraction in that regard
04:09:01 <maerwald> dmj`: yes, that's a better use case
04:09:20 <dmj`> maerwald: if you're just playing around with haskell, sure you don't need nix
04:09:22 <dramforever> I built X with glibc-2.29 and I can *replace* the dependency with 2.30, not rebuild it with 2.30
04:09:38 <maerwald> dmj`: even if you are not just playing around, you might not need it
04:09:51 <dmj`> but anything remotely complicated immediately turns into a "works on my machine issue" situation
04:09:54 <dmj`> maerwald: maybe, sure
04:10:04 <dmj`> depende on la situaction
04:10:08 <dmj`> situacion*
04:10:33 <dramforever> I think maerwald just innately think of Nix as a complex solution...
04:11:01 <maerwald> It is
04:11:20 <dramforever> But what if others have done the complex things for you
04:11:28 <maerwald> dramforever: and then they quit the company?
04:12:13 <dramforever> why are you using hackage
04:13:02 <maerwald> nix is a full time job, especially if you add nixops to it
04:13:15 <dramforever> oh
04:13:24 <maerwald> Don't underestimate the time it takes to do seemingly trivial changes
04:13:45 <dramforever> so you're saying that you don't want to use something that attachs your workflow to it
04:13:45 <dmj`> dramforever: it's definitely complex
04:13:59 <dmj`> dev ops is def. a full time job, period
04:14:02 <maerwald> Now you want your end to end tests running in nix. There's no nix expression for it. It uses some random python stuff. No go figure it out.
04:14:19 <maerwald> I'm saying you need to be a *nix packager* to use nix.
04:14:30 <maerwald> There's no separation between dev and user
04:14:30 <dmj`> I just read nixpkgs and see what others did and copy and paste it.
04:14:33 <dmj`> yea, definitely
04:14:40 <dmj`> nix is a power user tool, you *have* to read the source
04:14:45 <dmj`> I'd almost say Haskell is that way too
04:14:46 <dramforever> So if you don't like that then I have nothing to say
04:14:55 <maerwald> So it's extremely poor user experience, you could say.
04:15:00 <maerwald> Same as my distro
04:15:27 <maerwald> Couldn't imagine any non-dev using this complexity
04:15:40 <maerwald> Haskell is not that way
04:15:46 <maerwald> I don't need to be a GHC dev to use it.
04:15:50 <dmj`> they're trying to fix the UX, but it def. sucks.
04:15:56 <dmj`> but when it works, its great
04:16:07 <dramforever> You're using 'complexity' to describe any aspect you don't like
04:16:20 <maerwald> dramforever: I like my distro
04:16:39 <maerwald> But I've never recommended it
04:16:42 <maerwald> to anyone
04:16:58 <dramforever> I'm saying that I don't think I feel as much 'complexity' as you describe
04:17:04 * dmj` points to his "plwtkadlwtdk" quote
04:17:18 <maerwald> It just accidentially happened that I, at some point, put a lot of time into it. And then I didn't care to go back to something else
04:17:32 <maerwald> But looking at it from a tech and investment point of view: not worth it
04:18:02 <dmj`> nix is a good abstraction obviating a lot tools in some cases
04:18:23 <dmj`> if not nix, then its docker, kubernetes, python, chef, etc. and gluing all that stuff together
04:18:35 <dmj`> and the connection points there can cause a lot of headaches
04:18:43 <maerwald> dmj`: and sometimes it just works too
04:19:04 <dmj`> and sometimes it doesn't https://github.com/hjacobs/kubernetes-failure-stories
04:19:10 <maerwald> correct, same as nix
04:19:26 <dmj`> I'd say no because nix just uses the linux kernel and systemd
04:19:34 <dmj`> nix is just like a fancy DSL on bash
04:19:48 <dmj`> kuberenetes / docker have their own Go runtimes
04:19:48 <maerwald> dmj`: so you're saying nix always works and you cannot write wrong configuration?
04:20:04 <dmj`> well that's a logic error, not like a runtime error
04:20:13 <dmj`> it can cause a runtime error in your own code
04:20:14 <maerwald> Oh, I've had runtime errors with nixops =)
04:20:31 <dmj`> nixops is just a DSL on python boto for aws
04:20:39 <dmj`> I guess it has its own sqlite thing
04:20:47 <maerwald> The systemd services had circular dependencies and on a new host, stuff would just crash
04:20:51 <maerwald> So the configuration was wrong
04:21:24 <dmj`> that's different than subtle go concurrency bug that manifests itself intermittently in production
04:21:33 <maerwald> Idc, both are dangerous
04:21:45 <dmj`> one is reproducible :)
04:21:48 <maerwald> no
04:21:55 <maerwald> Only on a fresh host :)
04:21:58 <dmj`> I'd prefer reproducible errors
04:22:00 <maerwald> So it went unnoticed for months
04:22:05 <maerwald> It is exactly not reproducible
04:22:19 <maerwald> nixops isn't stateless
04:22:45 <dmj`> servers are mutable state
04:23:06 <maerwald> Yes, it doesn't solve the problem ;)
04:23:09 <dmj`> nixops diffs its understanding of the state with what is in prod
04:23:14 <dmj`> lol
04:24:29 <dmj`> no servers, no problems
04:24:37 <dmj`> dev no ops
04:27:01 <dmj`> maerwald: maybe we should join the no code movement
04:28:17 <maerwald> As I said: if excel sheets are enough, fire all your programmers and be done with it.
04:28:17 <hpc> no dev no ops
04:30:43 <dmj`> maerwald: in finance some people can get away with CSVs / excel for everything, god bless them
04:31:01 <maerwald> finance just throws a lot of money at features they are never going to use
04:31:13 <maerwald> god bless them :)
04:31:21 * maerwald cashes out
04:31:58 <dmj`> ya gotta justify your salary somehow
04:32:12 <[exa]> 'it works'
04:32:26 <maerwald> I'm system relevant! I think... hmm, wait...
04:37:14 <alephu5> Hi, does anywhere here have much experience with servant?
04:38:27 <Rembane> alephu5: At least one. What's your concern?
04:40:26 <alephu5> Hi Rembane. I'm using a third-party service to authenticate by generating JWT tokens, but the public keys are changed every 24 hours. 
04:41:44 <alephu5> I'm using a context to handle the JWT verification, as shown in the docs, but I can't find any way of updating that context without restarting the server
04:42:50 <Rembane> alephu5: What stops you from restarting your server once every 24h? 
04:43:44 <alephu5> I'd prefer to avoid downtime because this is for a SaaS.
04:44:35 <alephu5> Ideally I'd like to keep the public keys in a redis instance and update that with a cron job, the problem is that contexts aren't handled in an IO monad
04:44:36 <Rembane> alephu5: Then you need to servers anyway. 
04:44:43 <Rembane> *two servers
04:46:01 <alephu5> Why?
04:47:04 <Rembane> If you need as close to 100% uptime as possible you cannot have a single point of failure. 
04:48:09 <Rembane> Which means that if you have two Servant processees on different machines you can restart them one at a time 
04:49:01 <alephu5> It's not a critical system, if it goes down so be it. But I'd prefer to avoid bringing it down just to update the keys
04:54:22 <Rembane> Got it. Another solution is to start another Servant function in another thread with the new certificate while the former Servant function handles the last users and then everything is shifted over. 
04:54:53 <freeman42x[m]> just run into this error on a brand new cabal init Haskell project: https://gist.github.com/razvan-flavius-panda/a6f2f4684c049007b82d66216f3e67af
04:55:35 <alephu5> Here's a snippet from the authentication procedure: https://pastebin.com/ejLf24gZ
04:56:10 <alephu5> Ideally if that had IO, I could just read it from redis.
04:56:32 <Rembane> alephu5: What's the AuthCheck type? 
04:56:35 <alephu5> Your suggestion is workable, but still more complex than the problem deserves
04:57:01 <dramforever> Is there a package somewhere that abstracts over IO/ST and IORef/STRef?
04:57:45 <alephu5> http://hackage.haskell.org/package/servant-auth-server-0.4.5.1/docs/Servant-Auth-Server.html#t:AuthCheck
04:59:32 <alephu5> Aha! AuthCheck  
04:59:34 <alephu5>     runAuthCheck :: Request -> IO (AuthResult val)
05:03:16 <alephu5> Rembane: Do you think it's feasible to sneak it into there?
05:05:45 * hackage taskwarrior 0.2.0.0 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.2.0.0 (maralorn)
05:09:23 <dmj`> dramforever: you could do that simply with an associated type family
05:09:37 <dmj`> dramforever: I would check ocharles blog he did this with the type families post I believe
05:09:39 <dramforever> dmj`: Yes but I want to know if someone already did it
05:09:52 <dramforever> Basically I want to use the 'standard' one
05:10:02 <dmj`> dramforever: maybe you can be the one to make the 'standard' one :)
05:10:10 <ocharles> Hmm, I'm not sure that's on my blog, but I think snoyman might have done this?
05:10:33 <ocharles> maybe https://hackage.haskell.org/package/mutable is relevant
05:11:07 <dramforever> ooh
05:11:13 <dmj`> ocharles: https://ocharles.org.uk/posts/2014-12-12-type-families.html :)
05:11:35 <dmj`> I guess its not exactly the same, but similar in spirit
05:11:41 <dramforever> So it's PrimMonad
05:12:00 <ocharles> I... do not remember this o.o
05:12:09 <dmj`> ocharles: you wrote this code ! :)
05:12:43 <dramforever> But I guess Mutable is exactly what I want
05:12:50 <dramforever> Thanks too all the help
05:12:58 <dramforever> dmj`++
05:13:00 <dramforever> ocharles++
05:13:05 <ocharles> :)
05:17:20 <dmj`> dramforever: I'd check primitive too (it has PrimMonad)
05:17:35 <dramforever> Yup, did notice that
05:17:46 <dramforever> thanks
05:18:02 <dmj`> dramforever++
05:18:13 <dramforever> eh :P
05:19:17 <dramforever> Well mutable technically is something I didn't know I need
05:48:44 * hackage serverless-haskell 0.10.3 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.10.3 (AlexeyKotlyarov)
06:00:00 <maerwald> can I tell cabal to re-download packages that are to be installed?
06:00:24 <zincy_> Electronics is a much more expensive hobby than coding.
06:00:52 <dcoutts_> maerwald: you can manually delete them from the download cache if you like
06:01:14 <maerwald> dcoutts_: that requires me to figure out the entire dependency graph
06:01:38 <dcoutts_> maerwald: you can manually delete the entire download cache if you like
06:01:44 <dcoutts_> what problem are you trying to solve?
06:02:19 <maerwald> CI runner on gitlab is misbehaving and I want it to redownload the packages without disrupting the .cabal state too much
06:02:38 <maerwald> it's a shared runner
06:02:57 <dcoutts_> what makes you think it's the locally cached source tarballs that's the problem?
06:03:09 <maerwald> because it cannot find a .cabal file inside a tarball
06:03:23 <dcoutts_> ok, fair enough
06:03:30 <maerwald> https://gitlab.haskell.org/haskell/ghcup-hs/-/jobs/312727#L390
06:03:41 <dcoutts_> then does it tell you which one? you should be able to delete the corresponding entry
06:03:54 <maerwald> Yeah, but going forward I would want cabal to always redownload
06:07:03 <dcoutts_> I don't think that's the right solution. Either we should identify where the corruption happens, or do the hackage security hash check on the packages when they're being built, rather than just when they're first downloaded.
06:07:17 <dcoutts_> The latter would not be too hard.
06:08:19 <zincy_> dcoutts_: What are you working on these days out of curiosity?
06:08:37 <dcoutts_> zincy_: fake internet money
06:09:08 <dcoutts_> ie a blockchain cryptocurrency :-)
06:09:42 <zincy_> Still cardano?
06:09:46 <dcoutts_> yup
06:09:51 <zincy_> How is that going?
06:10:08 <dcoutts_> the new impl is actually running now
06:10:50 <zincy_> I used to work at Consensys
06:10:58 <zincy_> We worked on a smart contract system in Haskell
06:10:58 <zincy_> https://github.com/ConsenSys/Fae
06:11:28 <zincy_> dcoutts_: What is the transaction volume like on the live network?
06:12:07 <dcoutts_> oh nice, Haskell/FP style smart contract languages are the new hotness :-)
06:12:29 <dcoutts_> zincy_: not that high on the real system, orders of magnitude higher in our benchmarks :-)
06:12:54 <srk> dcoutts_: :)) plutus++
06:13:03 <zincy_> dcoutts_: Are you hiring at the moment?
06:13:11 <dcoutts_> IOHK are yes
06:13:17 <dcoutts_> And Well-Typed are too
06:14:43 <dcoutts_> The old impl was capped at 7tps or it would fall over its own toes. The new impl doesn't fail under load, and can hit 100 TPS (globally distributed, not a one data-center cheat).
06:15:13 <zincy_> Oh cool
06:15:50 <dcoutts_> STM is awesome :-)
06:16:05 <dcoutts_> plus some actual thinking and design
06:16:19 <zincy_> Yeah STM is a godsend.
06:16:25 <zincy_> Do you hga
06:16:34 <dcoutts_> hga?
06:16:40 <zincy_> Oops
06:16:42 <dcoutts_> :-)
06:17:58 <zincy_> Can I send you an email with a speculative application to well-typed?
06:19:00 <dcoutts_> zincy_: see http://www.well-typed.com/blog/2020/03/haskell-development-job-with-well-typed/
06:19:01 <adamCS> A question, originating from Vinyl but not really a vinyl question:  suppose I have the type "Curried (as :: [Type]) (x :: Type)" representing a function which takes arguments of the types in "as" and returns an "x".  And I want to compose two of them, that is, I want "zipCurried :: Curried as a -> Curried bs b -> Curried (as ++ bs) (a, b)", where "(++)" there is concatenation of type-level-lists.  Can I do such a thing?
06:19:28 <dcoutts_> zincy_: deadline has officially passed, but the process is ongoing so go for it
06:19:50 <lyxia> adamCS: with a constraint on as and bs, yes
06:19:57 <phadej> adamCS: yes
06:20:03 <phadej> it's not pretty
06:20:11 <adamCS> lyxia, phadej: do tell
06:20:38 <zincy_> dcoutts_: Oh thanks!
06:20:40 <phadej> adamCS: https://hackage.haskell.org/package/optics-core-0.3/docs/Optics-Internal-Optic-TypeLevel.html#t:CurryCompose
06:21:00 <phadej> is simple version
06:22:05 <phadej> but hmm https://hackage.haskell.org/package/optics-core-0.3/docs/src/Optics.Internal.Optic.html#AppendProof is more general
06:23:09 <adamCS> phadej: Nice. I should've realized there was a do it one at a time class version.  That happens a lot with vinyl/TLLs.
06:23:12 <phadej> adamCS: Your problem is not exactly either, but those should give enough hitn how that works
06:23:20 <adamCS> phadej: yes.
06:23:24 <adamCS> phadej: Thanks!
06:39:44 * hackage barbies-th 0.1.1 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0.1.1 (FumiakiKinoshita)
06:53:41 <jarlg> Good day folks! I have a two-parameter data type (data T a b = ..) and I need to write an instance for e.g. "T a Char" that is parametric in a. Is there a nice way of doing this without newtype-wrapping and flipping the parameters?
07:01:47 <ivegotasthma> hello, how can I iterate over a list while keeping an index?
07:02:03 <ivegotasthma> I'm looking for an analogue to Python's enumerate()
07:02:19 <jophish> ivegotasthma: to get a list with indices in it you can use, zip [0..] list
07:03:38 <solonarv> @let mylist = ["one", "zwei", "trois"]
07:03:40 <lambdabot>  Defined.
07:03:47 <solonarv> > zip [0..] mylist
07:03:48 <lambdabot>  [(0,"one"),(1,"zwei"),(2,"trois")]
07:04:04 <ivegotasthma> thanks!
07:04:59 <xsperry> [0..] creates an infinite list, and zip stops when reaching last element of the shorter list
07:09:50 <sushi18> hello, i am trying to implement this https://imgur.com/a/vJoeXZP function. newbie in haskell so i am having kind of hard time implementing it. i have written the function but i keep getting an error `Ambiguous type variable ‘a0’ arising from a use of ‘print’      prevents the constraint ‘(Show a0)’ from being solved.      Probable fix:
07:09:51 <sushi18> use a type annotation to specify what ‘a0’ should be.`
07:10:20 <ocharles> Can anyone make any sense of this generalized newtype deriving error? https://gist.github.com/ocharles/a4b15a77a0fd0450c3150fc28021efb4. I don't get what's wrong. Is it a roles problem, perhaps?
07:10:56 <ocharles> (==.) :: EqTable a => Row a -> Row a -> Row Bool
07:11:16 <merijn> sushi18: Can you use a text pastebin? No one wants to retype text from images, plus imgur doesn't load if you have cookies disabled
07:12:46 <lyxia> ocharles: I would guess so. What's the role of Row's parameter?
07:12:58 <ocharles> How do I get GHCI to show that?
07:13:05 <ocharles> Ah, :i
07:13:19 <ocharles> type role Row nominal   and newtype Row a = Rel8.Row.Row (Rel8.Table.Schema a Rel8.Column.Column)
07:13:30 <solonarv> aha, that explains it
07:13:33 <ocharles> Schema is an associated type for a type class
07:13:41 <w1n5t0n> Posted this earlier but I disconnected so I didn't see if anyone replied: Is it possible to have a function signature where one of the parameters is any of a number of raw types, without having to define umbrella ADTs or typeclasses etc? For example, "foo :: Int | String | SomeOtherType -> String -> Bool", where the first parameter can be any of
07:13:41 <w1n5t0n> those three
07:13:45 <sushi18> @merijn sorry, here's the pastebin https://pastebin.com/QSLZPFQ0
07:13:45 <lambdabot> Unknown command, try @list
07:13:59 <solonarv> and the associated type explains why the role has to be nominal, too
07:14:15 <solonarv> s/associated type/use of a type family/
07:14:24 <sushi18> @merijn it's without the summing part, but that should be hopefully easy if the helper function `h` starts working
07:14:24 <lambdabot> Unknown command, try @list
07:14:26 <ocharles> Urgh, so I will never be able to use GND with this scheme?
07:15:02 <merijn> ocharles: Someone going out of their way to explicitly use roles suggests that it's unsafe to do
07:15:13 <ocharles> ?
07:15:25 <ocharles> Who's suggesting using roles?
07:15:33 <merijn> ocharles: No, you said there was a role
07:15:48 <lyxia> That's just the :i output
07:15:51 <ocharles> I _assumed_ roles might be part of the problem, that's all
07:15:57 <ocharles> I am not doing any role typing
07:16:15 <merijn> Ah, I misread then
07:16:16 <ocharles> I'm guessing it's https://gitlab.haskell.org/ghc/ghc/issues/15683
07:16:30 <solonarv> with that definition, GHC will already infer 'type role Row nominal'
07:16:53 <merijn> sushi18: What's the exact error
07:17:24 <sushi18> @merijn `<interactive>:110:1: error:    • Ambiguous type variable ‘a0’ arising from a use of ‘print’      prevents the constraint ‘(Show a0)’ from being solved.      Probable fix: use a type annotation to specify what ‘a0’ should be.      These potential instances exist:        instance Show Ordering -- Defined in ‘GHC.Show’
07:17:24 <lambdabot> Unknown command, try @list
07:17:25 <sushi18> instance Show Integer -- Defined in ‘GHC.Show’        instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’        ...plus 22 others        ...plus 19 instances involving out-of-scope types        (use -fprint-potential-instances to see them all)    • In a stmt of an interactive GHCi command: print it`
07:17:35 <sushi18> @merijn should i send it in pastebin too?
07:17:35 <lambdabot> Unknown command, try @list
07:17:36 <ocharles> ah fuck, this whole idea is falling down. Damnit
07:18:40 <merijn> sushi18: The problem is that you're code is to polymorphic
07:19:06 <merijn> sushi18: Basically, all your functions in the past work for any Num instance (I think, maybe Integral, i'm too lazy to check)
07:19:18 <merijn> sushi18: print works for any type that's an instance of Show
07:19:23 <sushi18> @merijn does it need constrains? I am sorry I don't know how to do that yet, i've been using haskell for a week barely
07:19:23 <lambdabot> Unknown command, try @list
07:19:33 <solonarv> when GHC says "ambiguous type variable" that means GHC can't figure out what type something should be
07:19:44 <merijn> sushi18: If you combine those two it infers "ok, this can be anything that is both Show *and* Num"
07:20:05 <merijn> sushi18: But there are many things which are both, so it's ambiguous which one you wanted
07:20:38 <sushi18> @merijn ok, i understand the problem. which typeclass should i use then?
07:20:39 <lambdabot> Unknown command, try @list
07:20:42 <merijn> sushi18: Any time GHC complains about ambiguous types it means "this could be many things" and GHC avoids guessing
07:20:55 <merijn> sushi18: The solution is to tell it which type you want it to be
07:21:11 <merijn> "print (h 5 6 :: Int)" or something like that
07:21:25 <merijn> :t (^)
07:21:27 <lambdabot> (Integral b, Num a) => a -> b -> a
07:21:33 <sushi18> merijn: I wanted the functions to have signature of Integer -> Integer -> Double, but that didn't work so I let haskell infer the types
07:21:35 <solonarv> sushi18: btw, it's not customary on IRC to ping people with @username - mentioning someone's username anywhere in your message works too
07:22:04 <merijn> sushi18: Ah, that's because there are no implicit conversions between numeric types
07:22:05 <sushi18> solonarv: yeah, i noticed that some bot kept telling me 'Unknown command' :D  thanks 
07:22:30 <merijn> @quote monochrom want.double
07:22:30 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
07:22:45 <merijn> :t fromIntegral
07:22:47 <lambdabot> (Integral a, Num b) => a -> b
07:22:54 <merijn> > fromIntegral 10 :: Double
07:22:57 <lambdabot>  10.0
07:23:44 <sushi18> merijn: what did you by "print (h 5 6 :: Int)" or something like that? 
07:25:56 <merijn> sushi18: So in "print (h 5 6)" it infers that "h 5 6" must have a type which is an instance of Integral (from the inferred type of 'h') and it infers that it must be an instance of Show (from print), but that's insufficient context to actually decide what it is (hence, ambiguous) by adding a ":: Int" annotation I explicitly say "this has type Int" and the ambiguity goes away. Now it only has to check: 1) 
07:26:02 <merijn> is Int an instance of Integral? (spoiler: yes) and 2) is Int an instance of Show (spoiler: yes)
07:26:23 <sushi18> merijn: h x i = x^i / fromIntegral (factorial i) seems to fix this
07:26:28 <merijn> So, I eliminated the ambiguity it was complaining about by explicitly saying what I want
07:27:03 <merijn> sushi18: You mean doing that and readding the type "Integer -> Integer -> Double"?
07:28:22 <sushi18> merijn: adding the signatures don't work for me atm, it keeps yelling at me that type Double with actual type Integer .. 
07:28:32 <sushi18> merijn: so i ll leave it without signature, is that bad?
07:28:53 <merijn> sushi18: Mostly just hard to read for people here and "you in 6 months" :p
07:29:56 <merijn> :t (^)
07:29:57 <lambdabot> (Integral b, Num a) => a -> b -> a
07:30:09 <sushi18> merijn: it's hard for me too read now too, i programmed only in java but I can't seem to make it work .. I tried the learnyouhaskell.com book but the functions we used there were quite easy to define
07:31:18 <merijn> sushi18: Oh, yeah, the issue with "Integer -> Integer -> Double" is that this means 'x' is Integer, but dividing an Integer with a Double is a no go. "fromIntegral (x ^ i) / fromIntegral (factorial i)" works but is...not particularly pretty :p
07:31:50 <merijn> I would probably just do the entire thing with Doubles immediately
07:32:53 <sushi18> merijn: yeah but the proff gave us an assignment with signature Integer -> Integer -> Double. I think I ll use it evne though it's not pretty
07:34:35 <sushi18> merijn: one last question, do you have some a book or a website that you think is really good as starting point to learn haskell?
07:35:56 <merijn> I've heard good things about "Haskell from First Principles" and Graham Hutton's "Programming in Haskell", but I don't have first hand experience with those
07:37:36 <merijn> I mostly learned through Learn You a Haskell (but objectively that's not a great book and I probably wouldn't recommend it) and lurking here :p
07:37:56 <solonarv> cheecky solution: fromRational (x^i / factorial i)
07:38:20 <solonarv> erm, oops, I meant: fromRational (x^i % factorial i)
07:40:33 <amar94> see region anyone ?
07:54:52 <jgt> is there a function to round a double to a maximum given precision?
07:55:31 <merijn> jgt: Define "round" and "precision". Do you mean for pretty printing or for further computing?
07:55:37 <siraben> amar94:  See?
07:55:41 <jgt> merijn: I mean pretty-printing
07:55:45 <siraben> Which region?
07:55:51 <merijn> jgt: Have you seen the Numeric module in base?
07:56:01 <jgt> I'm after `0.164899 -> 0.1649`, and `0.12 -> 0.12`
07:56:07 <merijn> :t showFFloat
07:56:08 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
07:56:17 <amar94> southeast europe
07:56:31 <jgt> merijn: yes, I was looking at showFFloat in Numeric, but it gives trailing zeroes
07:56:35 <siraben> Ah, I'm SEA, heh.
07:56:36 <merijn> :t showFFloat (Just 3) 0.57857827857 ""
07:56:38 <lambdabot> String
07:56:43 <merijn> > showFFloat (Just 3) 0.57857827857 ""
07:56:45 <lambdabot>  "0.579"
07:56:45 <maerwald> siraben: SG?
07:56:59 <siraben> TH
07:57:01 <merijn> jgt: Ah, you mean it always pads to the specified number of digits?
07:57:02 <jgt> > showFFloat (Just 4) 0.2
07:57:04 <lambdabot>  <[Char] -> [Char]>
07:57:08 <jgt> > showFFloat (Just 4) 0.2 ""
07:57:10 <lambdabot>  "0.2000"
07:57:14 <jgt> merijn: yep
07:57:21 <merijn> mm, I'm not sure, tbh
07:57:56 <jgt> merijn: I've been playing with showFFloat, toFixed, printf, formatting… All to no avail so far.
07:59:19 <merijn> The simplest thing to get on with your life would just be to strip any trailing zeroes >.>
08:00:01 <siraben> What happened to the Monad.Reader? Are they still releasing editions?
08:00:45 <jgt> merijn: yeah, true
08:01:23 <merijn> jgt: Or better yet, write something more efficient and add it to bas!
08:02:12 <jgt> it's nice that you encourage me to contribute to base :)
08:02:34 <jgt> I already feel like I'm taking liberties just contributing to yesod :P 
08:02:54 <merijn> I think my very first Haskell contributions were to GHC :p
08:02:56 <merijn> Aim high!
08:03:28 <jp_rider> Hi. I have multiple Haskell threads (created with with `forkIO`) that call an FFI function. The FFI function interacts with a global variable (declared with `volatile sig_atomic_t interrupted = 0;`). Will each Haskell thread have independent state for the FFI global variable, or only each OS thread? 
08:03:36 <merijn> Granted, the first one had to be redone 3 times due to it being buggy even after 3 people reviewed it and oked it ;)
08:04:07 <merijn> jp_rider: You mean declared globally in the C code?
08:04:39 <jp_rider> Yes. 
08:04:40 <jp_rider> https://github.com/jprider63/simplessh/blob/7752bceafba32e8a7688c4941c30076067534806/cbits/simplessh.c#L207
08:04:46 <merijn> jp_rider: Eh, what makes you think OS threads have independent variables?
08:05:06 <merijn> jp_rider: Global C variables are global, just as in C
08:05:45 <jp_rider> I'm seeing behavior that indicates they are at least OS thread local
08:06:20 <merijn> That'd be coincidence, because they can't be
08:07:15 * hackage configurator-pg 0.2.3 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.2.3 (vollmert)
08:07:32 <jp_rider> Ie, one forkIO'd thread times out once and interrupted is marked as true, so it continuously short circuits, while another forkIO'd thread is able to run without issue (so its interrupted must be false)
08:08:56 <merijn> If sig_atomic_t is defined using thread local storage that might be the case, I suppose. But that's not guaranteed by sig_atomic_t
08:10:58 <jp_rider> Ok, I won't rely on this then. I suppose the solution is to maintain the set of Haskell thread's that are interrupted in the FFI global state then? So I need to convert a ThreadId to some C type
08:11:13 <sushi18> Couldn't match expected type ‘Int’ with actual type ‘Integer’ what does this error message tell me?
08:12:59 <jp_rider> sushi18: `Integer` is unbount (a big int) while `Int` is bound (probably 64 bits)
08:13:26 <merijn> jp_rider: The solution to what? I'm not sure I see why you need to tie haskell threadid to the C code?
08:13:36 <jp_rider> This might be helpful: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:toInteger
08:13:53 <merijn> jp_rider: Can't you just have you FFI call return whether it was interrupted?
08:14:39 <jp_rider> merijn: I'm trying to detect if the thread I'm on was interrupted.
08:15:11 <merijn> jp_rider: Like, later in the program you mean?
08:15:32 <merijn> That's a nightmare...
08:15:44 * hackage texmath 0.12.0.2 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.12.0.2 (JohnMacFarlane)
08:16:15 <merijn> jp_rider: Can't you just have a foreign calls return if their interrupted and store that per thread on the Haskell side?
08:16:27 <merijn> jp_rider: Then it's just like "check some IORef" or whatever
08:17:00 <jp_rider> I don't know a better way. I have foreign calls that are timing out and I need to interrupt them. This is the only way I've seen to do it: https://stackoverflow.com/a/52194650/382462
08:17:11 <merijn> jp_rider: Incidentally, if you're writing signal handling code this finnicky let me go and recommend "Advanced Programming in the UNIX Environment, 3rd edition" it's infinitely more correct than most of SO will ever be
08:18:48 <jp_rider> I guess I don't care if I know on the Haskell side if it's been interrupted, I just need control back on the Haskell side so that the timeout signal will be thrown. 
08:18:49 <merijn> jp_rider: You probably want to temporarily install a signal handler for only the current thread (in C), have that update a local variable (rather than global) for that specific thread and then you know whether *you* specifically were interrupted, rather then "was anyone interrupted"
08:19:59 <jp_rider> Can you update a local variable in a signal handler? I thought this was impossible
08:20:20 <merijn> Sure you can, why not?
08:21:12 <merijn> Actually getting a callback to do so might be tricky, I'd have to see if you can pass in any extra state or not
08:26:51 <ivegotasthma> what's the difference between a zip and fold?
08:27:22 <Rembane> > zip [1,2,3,4,5] [6,7,8,9,10]
08:27:24 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
08:27:30 <Rembane> > foldr (+) 0 [1,2,3,4,5]
08:27:32 <lambdabot>  15
08:28:11 <Rembane> ivegotasthma: It's like comparing apples and oranges. But a zip is a bifold, or maybe a fold if you squint hard enough.
08:28:21 <Rembane> ivegotasthma: What makes you wonder? 
08:28:23 <xsperry> zip and fold aren't even remotely related
08:28:52 <ivegotasthma> Rembane: I have an infinite list generator that returns [[Integer]]
08:29:06 <ivegotasthma> and I want to sum the elements of the inner lists into [Integer]
08:29:19 <ivegotasthma> I see people on stackoverflow summing with zipWith and foldr
08:29:19 <Rembane> ivegotasthma: Cool, how long are your inner lists? 
08:29:29 <ivegotasthma> Rembane: varying length, from 1 to infinity
08:29:41 <Rembane> ivegotasthma: Infinity is very long. Do you want to sum all the way to infinity? 
08:29:49 <ivegotasthma> yes
08:30:10 <ivegotasthma> but I doubt the list will be summed up to infinity
08:30:17 <ivegotasthma> the use case is take 5 func
08:30:24 <ivegotasthma> and it needs to return the sum of the first 5 lists
08:30:24 <xsperry> :t map sum
08:30:26 <lambdabot> (Foldable t, Num b) => [t b] -> [b]
08:30:38 <xsperry> :t take 5 . map sum
08:30:41 <lambdabot> (Foldable t, Num a) => [t a] -> [a]
08:31:31 <Rembane> ivegotasthma: xsperry has the solution I believe. Check if it does what you want.
08:31:48 <ivegotasthma> that's perfect
08:31:57 <ivegotasthma> how can I learn this magic?
08:32:19 <Rembane> By reading through Data.List and programming a lot. 
08:32:56 <ivegotasthma> ah, the long route, shit
08:33:25 <dmwit> ivegotasthma: https://www.norvig.com/21-days.html
08:33:28 <Rembane> I'm afraid I haven't found any shortcuts yet. 
08:34:00 <jp_rider> merijn: I haven't seen anyway to do this
08:34:05 <jp_rider> Hi dmwit!
08:34:21 <ivegotasthma> I've written a function that I think can be simplified a lot. Anyone care to take a look? https://dpaste.org/at6A/raw it's supposed to generate infinite lists
08:34:22 <Rembane> ivegotasthma: https://pbs.twimg.com/media/CEVlco4UMAAs2t2.png:large
08:34:29 * dmwit waves vaguely
08:34:38 <ivegotasthma> Rembane: I know this one :D
08:34:43 <Rembane> ivegotasthma: ^^
08:34:45 <ivegotasthma> those are some OG memes
08:34:50 <Rembane> ivegotasthma: What's the function name? 
08:34:56 <ivegotasthma> stirling numbers
08:35:45 <Rembane> ivegotasthma: Avoid getElement in lists, it's fairly expensive since it needs to step through the whole list. 
08:35:50 <dmwit> ivegotasthma: next = iterate newElement
08:36:13 <Rembane> ivegotasthma: in calculcateNextRow you can use zipWith to make the code a bit more pleasant 
08:36:16 <Rembane> :t zipWith
08:36:18 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:36:53 <dmwit> None of the elements of `st` will be infinite, so I say you were lying when you said "varying length, from 1 to infinity". =)
08:37:07 <ivegotasthma> dmwit: hahaha
08:37:15 <dmwit> "from 0 to infinity exclusive" would be ok =P
08:37:16 <Rembane> 1 .. <infinity
08:37:34 <ivegotasthma> dmwit: using iterate just blew my mind
08:37:41 <ivegotasthma> :W
08:37:44 <ivegotasthma> whoops
08:38:02 <ivegotasthma> Rembane: thanks, I'll rework it
08:38:11 <dmwit> ivegotasthma: You want genericIndex instead of your getElement.
08:38:11 <Rembane> ivegotasthma: np
08:38:41 <dmwit> ivegotasthma: Also the singular form of "indices" is "index", not "indice". =P
08:38:45 <ivegotasthma> dmwit: damn, that's a good function
08:39:17 <ivegotasthma> hahah both programming and grammar advice, the Haskell community is great
08:39:57 <dmwit> ?hoogle unsnoc
08:39:58 <lambdabot> Data.ByteString unsnoc :: ByteString -> Maybe (ByteString, Word8)
08:39:58 <lambdabot> Data.ByteString.Char8 unsnoc :: ByteString -> Maybe (ByteString, Char)
08:39:58 <lambdabot> Data.ByteString.Lazy unsnoc :: ByteString -> Maybe (ByteString, Word8)
08:41:08 <dmwit> ivegotasthma: You might consider building up your lists in reverse to avoid the inefficiency of `lastElement`.
08:41:33 <dmwit> It'll be a constant-factor speedup only, of course.
08:41:48 <dmwit> (Since you're already doing init and map in calculateNextRow.)
08:43:17 <dmwit> Actually, I don't understand why the split into map/lastElement is needed.
08:44:10 <dmwit> Don't all the lists end with 1 anyway, in which case can't you just drop the `init` and `++ lastElement list` calls entirely?
08:44:35 <e1fa> i installed the regex-tdfa package with cabal but ghci can't find it
08:44:44 <e1fa> has this happened to anyone else?
08:44:57 <maerwald> e1fa: how did you install it?
08:45:15 <dmwit> cabal install --libs instead of cabal install, or make a package that depends on it and cabal-repl instead of ghci
08:45:24 <maerwald> --libs is dangerous
08:45:27 <dmwit> But, in general: cabal install is no longer needed these days, so just don't use it.
08:45:32 <maerwald> cabal repl --build-depends regex-tdfa
08:45:38 <dmwit> My vote is for "make a package that depends on it and cabal repl instead of ghci".
08:45:45 * hackage resourcet 1.2.4 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.2.4 (MichaelSnoyman)
08:45:52 <e1fa> originally with `cabal install` in a package dir that depends on it
08:46:02 <solonarv> yeah, that doesn't work anymore
08:46:09 <solonarv> that is the old deprecated workflow!
08:46:10 <EvilPyro> Hi! I'm getting the maximum of a [(a,b)] but if there values with the same a, I'd want to pick the one that has b nearest to the center of an interval [0, x] or nearest to x/2 if you prefer, how can i do that smartly?
08:46:24 <dmwit> e1fa: Yeah, so just don't bother with the `cabal install`, and just `cabal repl` instead.
08:46:37 <dmwit> `cabal repl` will already ensure that the correct dependencies are build, installed, and available.
08:46:39 <ivegotasthma> dmwit: thanks!
08:46:40 <e1fa> i'm trying to make a pr on shellcheck but getting anything into an operable state has been discouraging
08:46:50 <solonarv> EvilPyro: with maximumBy you can specify yuor own comparison function
08:46:56 <solonarv> :t maximumBy
08:46:58 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
08:47:16 <maerwald> e1fa: which cabal version, which ghc version?
08:47:36 <e1fa> cabal: 3.2.0.0 ghc: 8.8.3
08:47:38 <dmwit> e1fa: What goes wrong when you simply `cabal build all`?
08:48:03 <maerwald> e1fa: in the shellcheck directory, just do: cabal repl
08:48:08 <pyro__> sorry got disconnected
08:48:26 <e1fa> dmwit: nothing goes wrong, it says i'm up to date
08:48:34 <dmwit> e1fa: Great! Then you're in an operable state.
08:48:51 <dmwit> cabal repl will get you a ghci prompt with shellcheck available.
08:48:59 <e1fa> dmwit: but when i `:l ShellCheck/Parser.hs` it breaks
08:49:08 <dmwit> Okay. Don't do that.
08:49:16 <dmwit> In cabal repl, you may `:m *ShellCheck.Parser` instead.
08:49:33 <EvilPyro> Hi, I got disconnected, did anyone answer? xDD
08:49:47 <solonarv> EvilPyro: did you see my message about maximumBy ?
08:49:49 <dmwit> EvilPyro: Yes, use maximumBy
08:50:10 <EvilPyro> i didnt see anything, I'll search for maximumBy
08:50:37 <e1fa> dmwit: thanks for the help
08:51:23 <dmwit> yay!
08:55:50 <EvilPyro> tbh i dont really know how to use maximumBy
08:59:03 <EvilPyro> oh okay I get it xD the function passed is like a selector, but i still dont know why theres minimumBy since i could implement myself all the logic right?
08:59:16 <dmwit> Certainly.
08:59:27 <dmwit> In fact, you could implement maximumBy yourself. So why bother offering it in the library?
09:00:05 <dmwit> Other than maybe [a] and a few arithmetic operations, pretty much all of the standard library *could* be reimplemented every time it was needed. But thank goodness it's not!
09:00:27 <solonarv> tbh, the only thing that makes [a] special is the syntax
09:00:34 * dmwit nods agreeably
09:00:45 <Rombik> Hello, how can I stack two Reader monads together? I have a dbConnection token and supplied options from a client. I think I can just wrap it into a tuple or create another type. But is there a better way?
09:01:29 <dmwit> That is one standard way. You can also use `ReaderT r1 (ReaderT r2)`, though `ask` and friends will only touch the outer `r1` and never the inner `r2`.
09:01:31 <Rombik> I have functions of this type `:: DBConnection -> Options -> a`. And I want to hide first two arguments in a reader.
09:02:16 <EvilPyro> I meant that it seems to work like sort in the std of c++, you can pass a lambda to decide an arbitrary comparison, so its not required to have another to do it reverse, you just change the lambda
09:02:16 <[exa]> Rombik: you may use uncurried versions of this thing with ReaderT (a,b)
09:02:17 <dmwit> See also http://hackage.haskell.org/package/effect-stack if you plan to go the nested-ReaderT route.
09:02:26 <EvilPyro> same seems to apply here right?
09:02:50 <Rombik> Thank you, I think this is the way I would do it.
09:03:01 <dmwit> EvilPyro: Yes, the same applies. Nevertheless it is more clear to write `minimumBy` when you are thinking of the operation you are doing as a minimum.
09:06:09 <EvilPyro> btw is there any alternative without requiring an import?
09:06:36 <dmwit> Sure, you can implement it yourself.
09:07:11 <solonarv> you shouldn't be afraid of imports
09:07:13 <solonarv> they are free
09:07:19 <solonarv> no tariffs! :)
09:07:40 <EvilPyro> yep, but i dont want to argue with my teacher xD
09:07:47 <dmwit> Well, they aren't free. But they certainly cost less than implementing it yourself. Because sometimes you will write a bug that somebody else already fixed. =)
09:07:59 <sushi18> I have created a binomial coefficient function using memoization, but I keep getting negative index, how is that possible if the index is never negative? code here : https://pastebin.com/ZULeH3RG
09:08:08 <MarcelineVQ> can write maximumBy yourself if the teacher is import allergic
09:09:40 <solonarv> sushi18: what happens for binom (0, 1) ?
09:10:30 <sushi18> solonarv:*** Exception: Prelude.!!: negative index
09:10:34 <EvilPyro> MarcelineVQ, Is there a way to see the implementation?
09:10:36 * dmwit channels monochrom
09:10:44 <dmwit> It is not possible if the index is never negative. What does that tell you?
09:10:50 <solonarv> aha! now try figuring out (on paper, perhaps) why that would happen
09:11:28 <MarcelineVQ> EvilPyro: first you find it,  https://hoogle.haskell.org/?hoogle=maximumBy  then you can click the source link to the right of it when you have
09:11:30 <dmwit> EvilPyro: Just click the "source" link next to it in the documentation!
09:11:55 <sushi18> solonarv: binom_memo_list !! fromIntegral (n - 1) .. i suppose the evil here is the fromIntegral (n - 1)?
09:12:26 <solonarv> sure looks like it. how could you avoid that?
09:14:50 <sushi18> solonarv: i tried putting another guard there `k==0 && n==0 = 0` seems a bit better
09:16:14 <solonarv> well, the results are wrong though
09:16:40 <MarcelineVQ> EvilPyro: though imo it's unreasonable for a teacher to be against importing from the standard library when the task is to make a game. it's not like there's game just hidden behind a function somewhere there
09:16:43 <solonarv> but that is the right idea
09:17:53 <MarcelineVQ> base doesn't come with a tick-tack-toe module in other words
09:18:00 <EvilPyro> MarcelineVQ, I dont chose my teachers, i just chose the subject
09:18:14 <sushi18> solonarv yeah, the results are wrong.. damn
09:18:59 * monochrom refrains from philosophically critiquing "I didn't have a choice".  and "it's not personal" for that matter.
09:19:11 <MarcelineVQ> No but teachers are people, usually, so it could be worth bringing up
09:19:38 <monochrom> aw, some people are stubborn :)
09:19:40 <MarcelineVQ> I'd be especially sadface if my teacher said I could't use containers when making something
09:19:52 <MarcelineVQ> *containers (the common library)
09:20:13 <monochrom> But I bet "project" means more flexibility.
09:20:16 <MarcelineVQ> Rather, I'd want to know why
09:20:17 <sushi18> solonarv: is my approach with the indexes correct?
09:21:58 <solonarv> it looks fine to me, yes
09:22:36 <solonarv> it is just the number that is wrong.
09:22:45 <solonarv> (n choose 0) is always 1
09:23:05 <solonarv> (0 choose k) is 0 unless k is 9 as well
09:24:14 <biiipon> hello, what's the python equivalent of a function returning a Maybe value?
09:24:29 <halogen64> I am trying to use generics to parse json. I have encoded the constructor for a sum type in a "type" field and I'd like to correctly parse based on that, but I can't seem to figure out how to navigate generics to get there. Can anyone help: https://gist.github.com/halogenandtoast/24d2787e95f2011a92e381615fff5e8d
09:24:38 <monochrom> There is none. Unless you relax to "throw an exception"
09:24:53 <monochrom> Switch to Rust.  It's called Option in Rust.
09:24:58 <biiipon> sorry for this question but the python irc is asking me to register my nick...
09:25:10 <monochrom> Good riddance.
09:25:22 <biiipon> thank you, I think none will fit my case
09:25:22 <maerwald> There is functional programming in python: http://coconut-lang.org/
09:25:28 <maerwald> but that's as far as you can get
09:25:28 <monochrom> I mean: one more reason to ditch python :)
09:26:01 <monochrom> Darn. I knew I had to avoid the word "none".
09:26:42 <monochrom> But it's capitalized in python.
09:26:46 <biiipon> I'm just rewriting my algorithm in Python because my schoolmates only know some python
09:27:08 <monochrom> Invite them to learn Rust.  All of you will be better off.
09:27:25 <monochrom> Invoke "Rust performance is better than python".
09:27:29 <halogen64> With the added bonus that you would now be Rustaceans
09:27:36 <maerwald> biiipon: https://gist.github.com/hasufell/20dcd2b94641cf61e3467f55f5fb27f3 you can create a Maybe type like so
09:27:38 <monochrom> Invoke "rustup is very easy to use"
09:28:09 <sushi18> solonarv: i changed the guard from `n == 0 && k ==0 = 0` to just `n == 0 = 0` and it seems to work now
09:28:23 <maerwald> coconut supports type unions, paired with mypy, this works well
09:28:43 <maerwald> And it compiles to (readable) python
09:29:45 <biiipon> it's cool to recreate Maybe in python but I was purposely avoiding that because they could not understand my code
09:29:54 <sushi18> solonarv: thanks for guidance
09:30:45 <monochrom> This is called the "fast, cheap, good: pick two" dilemma.
09:31:21 <maerwald> coconut is the only reasonable alternative if python isn't functional enough for you. But... the abstractions are leaky a little bit.
09:32:12 <solonarv> "all valid Python is valid Coconut" - okay, I don't need to read any more
09:32:13 <solonarv> :p
09:32:38 <monochrom> to each their own, or something
09:33:11 <maerwald> It's nice. I wrote a tool that parses all the mitre XML databases and converts it into SQL. I bet the ppl who have to maintain that today hate me
09:33:13 <maerwald> xD
09:33:28 <biiipon> coconut looks really cool, I love the pipeline operator
09:35:55 <biiipon> sadly the pipeline operator is not often used, it's not imported by default and the & operator is not common for this function
09:36:10 <biiipon> *in Haskell
09:37:39 <unsupervised> how long does it take a motivated engineer to learn Haskell and get a job doing FP in Silicon Valley?
09:38:12 <halogen64> I would highly advise not getting any job in silicon valley.
09:38:14 <unsupervised> s/get a job/change job/
09:38:14 * hackage json-autotype 3.1.1 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-3.1.1 (MichalGajda)
09:38:42 <unsupervised> I'm not gonna debate silicon valley lifestyle
09:39:20 <alephu5> Do they hire FP developers in SV?
09:39:20 <halogen64> unsupervised: If you want a Haskell job in silicon valley, you are probably looking at cryptocurrency companies
09:39:25 <maerwald> unsupervised: 3-5 years
09:39:48 <unsupervised> you have to do 3-5 years of hobby FP work to get a job doing FP?
09:39:49 <halogen64> So if yo don't yet know cryptocurrency you'll need to pad the amount of time
09:40:23 <maerwald> unsupervised: most ppl have had far more
09:40:49 <maerwald> if you just learned it last month and try to get a job, I don't think that's going to go well, but can always give it a shot
09:40:54 <halogen64> unsupervised: there is also a huge difference between hobby-level Haskell and production-level Haskell
09:42:23 <halogen64> I think I spent around 6 years learning Haskell before I got a Haskell job.
09:42:31 <unsupervised> 3-5 years sounds like the time it takes do some work for the GHC compiler so that sounds too much
09:42:32 <halogen64> and I still think I'm bad
09:43:27 <halogen64> I would say though, I was not actively looking for a job.
09:44:34 <halogen64> I arrived to my current job and was like "lol, what are type families"
09:44:48 <halogen64> because you probably do not need them often in hobby code.
09:45:10 <DanS_> ?
09:48:17 <c_wraith> depends on your hobby!
09:49:32 <maerwald> The problem with type families is... the name. 
09:52:11 <halogen64> I solved my generics problem!
09:52:27 <halogen64> Not that anyone responded to my earlier request...
09:52:49 <EvilPyro> is there a way to count the elements in a list that fulfil a certain condition instead of doing length $ filter (cond) list  ?
09:52:59 <halogen64> I was trying to parseJSON too soon
09:53:30 <EvilPyro> I mean, it looks like something that can be improved
09:53:36 <dmj`> EvilPyro: what's the condition per se?
09:53:55 <EvilPyro> >=4
09:54:04 <EvilPyro> only one arg
09:54:23 <dmj`> > length [ 1 | 4 <- [1,2,3,4,5,6,5,4,3,2,1] ]
09:54:23 <halogen64> EvilPyro: performance-wise, because Haskell is lazy, it counts the length while it is filtering, so there probably isn't too much to do to improve this.
09:54:25 <lambdabot>  2
09:54:30 <dmj`> > sum [ 1 | 4 <- [1,2,3,4,5,6,5,4,3,2,1] ]
09:54:33 <lambdabot>  2
09:55:00 <dmj`> EvilPyro: you can hard pattern match in list comps w/o punishment
09:55:06 <dmj`> @src catMaybes
09:55:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
09:55:26 <dmj`> halogen64: what was your Generics problem?
09:55:54 <halogen64> dmj`: I was trying to use generics to parse json, where the sum type encoding was a key in the payload
09:56:26 <monochrom> I highly recommend against evangelizing haskell.
09:56:44 <halogen64> dmj`: the problem was here https://gist.github.com/halogenandtoast/24d2787e95f2011a92e381615fff5e8d
09:57:02 <monochrom> Let self-selection do its work.  If someone is interested, bring them in.  If someone is uninterested, don't fight them.
09:57:13 <EvilPyro> dmj`, i dont understand.. what does the 1 | mean in that expression?
09:57:44 <dmj`> EvilPyro: well ya gotta put something there to symbolize a successful pattern match, then you sum or length it, both will produce the same result if you put 1
09:58:05 <halogen64> instead of trying to do fmap M1 . parseJSON @(f p) which was completely wrong, I just needed to do fmap M1 . untaggedParse
09:58:33 <halogen64> then I could write instance (FromJSON a) => UntaggedParse (K1 R a)
09:59:04 <dmj`> there is a FromJSONKey class I believe, it might do this
09:59:14 <EvilPyro> dmj`, not sure how to adapt your example so it does what i want tbh, i need the count of >= 4 not equal to 4
09:59:54 <dmj`> > length [ x | x <- [1..10], x >= 4 ]
09:59:56 <lambdabot>  7
10:01:03 <dmj`> > length $ do { x <- [1..10]; guard (x >= 4); pure x }
10:01:06 <lambdabot>  7
10:01:25 <halogen64> dmj`: I think that is just to encode a value into a key
10:03:19 <DanS_> hi everyone! I'm a bit stuck trying to represent financial securities in different "universes" (exchanges), specifically how to define a unique mapping between the symbols used by two different exchanges, and would love some help. Here's what I've got so far: https://gist.github.com/dansanduleac/85afcf69b5fea78fbd972c602a85d052
10:03:38 <dsal> EvilPyro: what do you not like about `length . filter f` ?
10:04:30 <EvilPyro> dsal, I'm a newbie in haskell so my brain isn't used to lazynes yet xD
10:04:48 <halogen64> EvilPyro: you could write something like this: https://pastebin.com/9UUfpA7W
10:04:52 <maerwald> laziness is cool as long as you're newbie
10:05:11 <EvilPyro> bth i had a minimax algo that worked with 5 iterations in 2s, now 4 iterations are >2s so I'm worried xDDD
10:05:23 <dsal> What do you mean iterations?
10:05:25 <halogen64> then you just write `howMany (>= 4) [1,2,3,4,5]
10:06:27 <dsal> It's more code which is a bit harder to read, and if you're doing it for performance reasons, might be good to benchmark that.
10:06:41 <EvilPyro> dsal, minimax is like bruteforcing, it traverses all possible movements until a certain depth, i meant depth not iterations
10:07:48 <dsal> I don't know minimax.  I know writing gross brute force code to solve problems, though.  :)
10:08:09 <EvilPyro> halogen64, thankyou, I'll try that later. I'm trying to find obvious performance problems first 
10:08:55 <dsal> Don't do obvious in "I read this and it looks obviously wrong."  Ask the computer what it's spending its time on.  Work on that thing.
10:08:57 <dmj`> > getSum $ foldMap (\x -> if x >= 4 then Sum 1 else mempty) [1..10]
10:08:59 <lambdabot>  7
10:09:53 <halogen64> EvilPyro: there is no reason to use what I wrote over `length . filter pred`
10:10:22 <dsal> > let lengthOf p = length . filter p  in  lengthOf (>= 4) [1..10]
10:10:23 <halogen64> performance-wise they are likely very similar
10:10:24 <lambdabot>  7
10:10:48 <dsal> But the dumb, obvious thing is more likely to fuse.
10:11:05 <solonarv> halogen64: yours might even be worse because it is not tail recursive (and in this case we do want tail recursion)
10:11:26 <EvilPyro> dsal, it depends on the board state, if i have to emulate that lmao xDD I wrote the function targeting results first instead of tune fining so It should be easy to rewrite obvious performance issues, or thats what i thought xD
10:12:35 <dsal> EvilPyro: I'm just saying run it under a profiler.  Your intuition might be right, but if you're looking at stuff like making `length . filter` faster from your intuition, your intuition may be misleading you.
10:13:43 <halogen64> solonarv: been so long since I've had to think about that, I assume I'd just have to add an accumulator to fix that right?
10:14:05 <solonarv> halogen64: yes, or just write it in terms of foldl'
10:14:07 <dsal> halogen64: In general, if you can use a fold or similar, just do that.  :)
10:14:27 <monochrom> Is this premature optimization?
10:14:46 <dsal> monochrom: pessimization, IMO
10:15:36 <monochrom> OK, premature worrying about "performance".  Especially when it is known that actual input sizes are trivial.
10:16:46 <monochrom> If the problem in question is known to require Omega(n) and your code takes O(n), you are done, move on to the next problem.
10:17:26 <halogen64> dsal: true facts
10:17:36 <halogen64> I was just curious
10:18:06 <solonarv> in fact 'length . filter p' fuses beatifully
10:18:20 <halogen64> @define fuse
10:18:20 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
10:18:53 <dsal> I started to like MonadLogger less yesterday.   My stupid monad stack got too complicated and I end up with two different types that are kind of similar to represent my thing, but not quite the same.  I had to `lift ask` to take my reader apart and then build another reader on top of a new logger I wanted to use for a particular excursion.
10:19:05 <dsal> Maybe it's not MonadLogger I don't like, but myself.
10:19:15 * hackage rhine-gloss 0.6.0.1 - Gloss backend for Rhine  https://hackage.haskell.org/package/rhine-gloss-0.6.0.1 (turion)
10:19:27 <solonarv> fuse as in "list fusion", which is a pile of rewrite rules and so on that eliminate intermediate lists in stuff like 'foldr f z (map g xs)'
10:19:53 <c_wraith> in general, using a monad transformer stack as your actual interface is going to be painful.
10:20:04 <halogen64> solonarv: thanks, make sense
10:20:09 <solonarv> you can experiment yourself: compile with ghc -O2 -ddump-prep -dsuppress-all to see intermediate representation
10:20:49 <solonarv> 'countList :: (a -> Bool) -> [a] -> Int; countList p = length . filter p' turns into a nice fast loop
10:20:58 <dsal> c_wraith: As opposed to just constraints?
10:21:14 <solonarv> it correctly unboxes the Int, too
10:21:28 <c_wraith> The standard approach to dealing with a monad transformer stack (assuming you don't want to change technologies) is hiding the whole thing inside a newtype and providing functions with the functionality you need as building blocks
10:21:58 <c_wraith> Write all the lifting once, only deal with it afterwards if you need to change representation
10:22:12 <dsal> Hmm....  I've half-done that in this project.
10:22:23 <dsal> Tell me more about this "change technologies" thing...
10:22:47 <c_wraith> There are many arguments about free monads and effect systems out there. :)
10:23:19 <c_wraith> I don't currently have an opinion on the way you "should" do it.
10:23:36 <dsal> I fear this project has a large junk drawer of things it does.  While a bunch of it can be "IO" the things I've defined as useful come down to providing authentication to an external service, providing a DB connection, and MonadIO.
10:24:16 <monochrom> I did "newtype Parser a = MkParser (StateT [T] Maybe a) deriving (Functor, Applicative, Alternative, Monad)" last night.
10:25:10 <dsal> I have `deriving (Applicative, Functor, Monad, MonadIO, MonadUnliftIO, MonadCatch, MonadThrow, MonadMask, MonadReader Env, MonadFail)` and some hand-written instances.
10:25:52 <dsal> -XNewtypeDeriving*
10:26:13 <solonarv> it is actually GeneralizedNewtypeDeriving
10:26:21 <solonarv> (or s/z/s/ if you prefer)
10:26:35 <dsal> The list is too long, though.  Just derive all the things.
10:27:21 <halogen64> We're still writing code without DerivingStrategies?
10:27:57 <dsal> I don't even know about the existence of most of the GHC extensions.
10:28:43 <solonarv> halogen64: I'm not!
10:28:56 <solonarv> well, if it's all stock then I won't bother to mention that
10:29:23 <halogen64> We have the warnings on in our app so we have to specify
10:29:39 <halogen64> Was a pain for the persistent code, since it derives a Show instance for unique keys
10:29:40 <dsal> The annoying thing in my codebase is that most code doesn't take that newtype, but a simple type alias over ReaderT.  That was unpleasant.
10:29:49 <halogen64> So every entity file has to explicitly turn off the warning.
10:30:40 <halogen64> dsal: coerce all the things
10:30:47 * dsal fails to form question
10:31:04 <monochrom> We need a "deriving stack" for newtyped monad stacks :)
10:31:05 <dsal> I have a large list of constraints.  Is there a way to make that a variable?
10:34:06 <monochrom> If I understand your question, ContraintKind can help.
10:34:28 <dsal> Thanks.  I gave up on trying to form it sensibly and just threw words out and hoped for the best.
10:35:36 <dsal> Ah yes, this looks like what I was trying to say.
10:35:41 <monochrom> :)
10:36:20 <solonarv> with the arrival of DerivingVia, I've actually switched to 'newtype MyTrans m a = MyTrans (MyEnv -> m a) deriving (...) via ReaderT MyEnv m'
10:37:44 <monochrom> Oh! That actually is nicer.
10:38:36 <sheepfleece> Hello, how can I painlessly write multiline strings? I've got a couple of SELECT's for `mysql-haskell` and it is a pain to use \ everywhere.
10:39:03 <Rembane> sheepfleece: There's a hackage package that does it much nicer. Lets see what the name is...
10:39:10 <monochrom> qq
10:39:24 <halogen64> monochrom: is qq really painless though?
10:39:29 <maerwald> https://github.com/NixOS/nix/issues/2925 oh yeah
10:39:30 <monochrom> err, not qq
10:39:43 <dsal> sheepfleece: https://github.com/dustin/gopro/blob/master/src/GoPro/DB.hs#L90-L98
10:39:43 <Rembane> sheepfleece: https://hackage.haskell.org/package/heredoc
10:39:52 <sheepfleece> Thank you!
10:39:53 <monochrom> string-quote
10:40:12 <dsal> Excessive different answers.
10:40:19 <monochrom> pain is relative. honestly I don't find \ painful to begin with
10:40:42 <monochrom> what we can do is enumerate options so the chooser can choose their poison
10:40:52 <dsal> You don't find the caning operator painful?  You enjoy your back slashes?  You masochist.
10:41:48 <monochrom> But it looks like it's either \ or quasi quotes
10:42:07 <monochrom> I know of a 3rd option, it's popular in windows programming.
10:42:17 <monochrom> "resource files" bwahahahahaha
10:43:11 * Rembane hands monochrom the evil villain monocle 
10:43:22 <maerwald> quasi quotes are ok
10:43:52 <maerwald> https://hackage.haskell.org/package/string-interpolate
10:44:15 <maerwald> Note that all of these have a bug in ByteString: they truncate via Char8.
10:44:31 <maerwald> (but OverloadedStrings does too, so...)
10:46:41 <dsal> Yeah, getting rid of my type alias and just using my newtype solves *most* of my problems... the remaining one being MonadLogger doesn't actually have a way to just make a stderr logger.
10:47:06 <maerwald> dsal: huh?
10:47:12 <maerwald> of course it does
10:47:33 <dsal> It has runStderrLoggingT.  I can extract the logger from within that, but I can't just make one.
10:47:52 <Rembane> Why do you need to make one? 
10:47:56 <dsal> I'm using runStderrLoggingT and then just liftIO my stuff out.
10:48:00 <maerwald> dsal: you can write your own interpreter
10:48:20 <dsal> Because my type is a MonadLogger, but the default logger just uses the stderr logger.
10:48:31 <dsal> I override it in one place in my code.
10:48:35 <maerwald> dsal: https://git.io/JfUVn
10:49:07 <dsal> Yeah, I just want the default stderr logger most of the time.  But I have my own logger that I override with in one place.
10:50:16 <maerwald> I don't really understand, but seems you know what you're doing
10:51:14 * hackage krank 0.2.0 - Krank checks your code source comments for important markers  https://hackage.haskell.org/package/krank-0.2.0 (guibou)
10:51:42 <dsal> My MonadLogger works by just having a function it dispatches to in the reader.  I use runStderrLoggingT and then immediately askLogger to grab the function to use.
10:51:55 <maerwald> I wonder if that "krank" was an intended pun
10:53:05 <dsal> This is making my code so much easier to understand, though.  I was confused as to why I had two types that did fairly similar things.
10:54:14 * dsal wonders if it still works
11:07:59 <EvilPyro> why ghc outputs ghc: can't find a package database ? how can i solve it?
11:09:34 <dsal> EvilPyro: How are you running ghc?
11:10:21 <dsal> OK, I like this.  I probably should manage this thread, but this is a single-user app, so I don't care too much: https://github.com/dustin/gopro/blob/master/src/GoPro/Commands/Web.hs#L62-L67
11:13:31 <EvilPyro> dsal, ghc file.hs
11:14:56 <dsal> EvilPyro: I'd recommend picking up stack or cabal, depending on which gang you want to join.
11:15:11 <EvilPyro> it seems my teacher is from the cabal gang
11:15:46 <EvilPyro> I installed cabal-install, then run cabal install --lib random and then i got this err after executing ghc file.hs
11:21:55 <EvilPyro> maybe i need to restart the pc after installig cabal or something? sound stupid tho
11:25:56 <monochrom> I would say "ghc: can't find a package database" is a severe file corruption.
11:26:42 <solonarv> how did you install ghc & cabal?
11:27:36 <EvilPyro> this is the full err https://pastebin.com/kVzRvPha
11:27:57 <EvilPyro> theres no such store folder inside .cabal
11:28:34 <EvilPyro> solonarv, on arch just installed the cabal-install and then cabal install --lib random
11:29:13 <EvilPyro> I also did cabal update before installing the lib
11:29:53 <solonarv> you used arch's packages? uh oh
11:31:26 <EvilPyro> monochrom, I'm pretty sure its not a file corruption.
11:35:33 <geekosaur> maybe not, but it's also not as simple as rebooting or etc.
11:37:23 <EvilPyro> dos cabal replace ghc? I had ghc and ghci with  the arch ghc package, not sure if cabal replaces those
11:37:51 <maerwald> trash all arch packages related to haskell
11:38:02 <maerwald> they are broken
11:38:30 <monochrom> cabal calls ghc
11:38:34 <EvilPyro> okay, then how i install cabal and haskell
11:38:55 <monochrom> https://www.haskell.org/ghcup/
11:41:13 <EvilPyro> okay deleted all and running ghcup
11:41:41 <EvilPyro> I'll need to run cabal update and cabal install --lib random after that right?
11:41:58 <maerwald> it runs cabal update. 'cabal install --lib' is a problematic thing btw
11:42:14 <EvilPyro> i need random xD
11:42:14 <maerwald> it creates a default environment in ~/.ghc directory
11:42:17 <maerwald> for?
11:42:29 <EvilPyro> to compile a .hs file
11:42:44 <maerwald> you can use: cabal repl --build-depends random
11:42:49 <maerwald> and then load the file into ghci
11:43:01 <maerwald> or: create a proper project: cabal init --interactive
11:43:39 <EvilPyro> my teacher does not expect a file other than the .hs but its required to compile with ghc xDDD
11:43:56 <dsal> Exceed expectations.
11:44:26 <maerwald> yeah, give him an sdist tarball
11:44:42 <solonarv> you can place a #!/usr/bin/env cabal shebang at the top of the file, followed by a special comment, to make the file runnable directly :)
11:44:53 <dsal> Now that I've got my monad stack in order, I should burn it down and free all the monads.
11:47:38 <monochrom> haha
11:48:19 <EvilPyro> I have strong desires to just cry xD. why tf running my executable like ./program does not print nothing unless i do CTRL+C (to exit) and then prints but exits xDD Is haskell trolling me? ghci works nice
11:48:30 <EvilPyro> and i have a main
11:49:22 <geekosaur> you used putStr instead of putStrLn ?
11:49:32 <EvilPyro> yes
11:49:58 <EvilPyro> putStr "Enter number of rows: " because i want the input before the newline
11:50:37 <dsal> Do you understand terminal IO?
11:50:54 <geekosaur> output is line buffered by default, except in ghci because it's an interactive environment. hflush stdout or set output unbuffered with hSetBuffering
11:51:06 <geekosaur> ll of which are in System.IO module
11:52:04 <maerwald> imagine GHC could downgrade itself: --compile-as=8.6.5
11:52:06 <zeta_0> what does `-ddump-splices` mean?
11:52:08 <maerwald> I'm dreaming.
11:52:20 <EvilPyro> dsal, in C++ I'd do a std::flush
11:52:49 <dsal> EvilPyro: Yeah, so same thing here.  That's a pty thing, not a programming language thing.
11:53:07 <dsal> zeta_0: It expands TH splices so you can see generated code.
11:53:07 <solonarv> zeta_0: it dumps splices (a splice is a template haskell invocation)
11:53:18 <geekosaur> zeta_0, it tells ghc to show what code is generated for template haskell splices
11:53:52 <geekosaur> -d is actually a debugging flag but some of he debug output has uses other than debugging ghc
11:54:34 <geekosaur> gleh. this machine is way too slow
11:56:10 <EvilPyro> god. the executable is orders of magnitude faster than in ghci. thats amazing
11:56:50 <geekosaur> not ususual, ghci is not only interpreted, it has no optimization at all
11:56:58 <solonarv> yes, optimizations make things a lot faster :)
11:57:17 <zeta_0> thanks, that makes much more sense now
11:57:34 <EvilPyro> something that was like 1m execution is like 5s now
12:01:34 <koz_> EvilPyro: GHCi is basically for practice or testing.
12:01:42 <koz_> You wanna move to actual files with actual compilation ASAP.
12:02:43 <dmwit> I feel cheated. That's just one order of magnitude.
12:03:26 <EvilPyro> I expected a minor speed increase due to the main problem is the alg complexity (exponential) so even if the compiler optimizes an exponential is an exponential xdd
12:03:49 <koz_> Constant factors can and do matter.
12:04:03 <koz_> Asymptotic analysis ignores them, but that doesn't mean they don't come up.
12:04:19 <koz_> (c.f. nobody actually uses AKS for primality testing because the constant factors are hilariously huge)
12:21:54 <johnw`> given KnownNat n, is there any easy way to determine that KnownNat (n + 1)?
12:21:57 <johnw`> all I've found so far is a plugin
12:22:06 <koz_> johnw`: That's basically it.
12:22:10 <johnw`> :(
12:22:15 <koz_> GHC's own analysis of KnownNat constraints is rather primitive.
12:22:26 <c_wraith> As in "it doesn't do it"
12:23:35 <MarcelineVQ> what if you phrased it as 1 + n
12:24:09 <koz_> MarcelineVQ: Sometimes?
12:24:13 <koz_> It's not very clever.
12:26:45 * hackage json-autotype 3.1.2 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-3.1.2 (MichalGajda)
12:28:07 <zeta_0> has ghc moved from 8.6 to 8.8 as the current stable version? i have all my stuff configured to use 8.6.5, so i'm not sure if i need upgrade yet?
12:28:45 <MarcelineVQ> Not unless 8.8 has a specific feature you require in its changelog
12:29:15 <maerwald> 8.8 can be considered the recommended now, I'd say
12:29:32 <maerwald> latest stackage is based on it too
12:32:53 <solonarv> it's also the 'recommended' version according to ghcup
12:33:22 <zeta_0> ok, i'm going to upgrade now to 8.8.x, what version number should i substitute for x ?
12:34:14 <ja> zeta_0: the newest? 8.8.3 i think
12:34:30 <ja> they point releases are only bugfixes, i dunno why you wouldn't take them
12:35:51 <zeta_0> ok sounds good, thanks, time to upgrade, i hope nothing breaks
12:36:38 <koz_> zeta_0: Nothing should on a minor.
12:36:49 <koz_> _Major_ releases is when the ecosystem gets hit by a hurricane.
12:38:56 <zeta_0> good, i currently use ghcid/ghcide so i hope those work fine with ghc 8.8
12:41:29 <solonarv> ja: rarely, a point release breaks things
12:42:21 <solonarv> the only example I can recall is that 8.6.3 broke on windows because the compiler now went into an infinite loop/hang in some situations (one of these situations was template haskell)
12:43:19 <ja> koz_: technically the minor is the y in x.y.z... dunno what an unambiguous term the y would be...
12:43:20 <hseg> how do i force ghc to unify types? it's complaining that U (P n) cannot be used in a U (P m) context because U is noninjective and n is therefore ambiguous
12:43:30 <solonarv> but you can always just switch back to the previous point release
12:43:46 <solonarv> hseg: type applications, maybe
12:44:29 <hseg> hrm...
12:44:55 <solonarv> I can give more details if you give more details first ;)
12:47:39 <hseg> sure... trying to get more data
12:48:49 <hseg> hrm. ok, so i can get ghci to spit out the type it's inferring
12:49:33 <hseg> it thinks it has forall {n :: Nat} {r}. (KnownNat n, Unital r) => (Monomial n, Unit r) -> (Monomial n, Unit r)
12:50:14 <hseg> (where unless i'm mistaken, the (co)domain of the function are expansions of Unit (Polynomial n r) and Unit (TrigPoly n r) respectively)
12:51:11 <hseg> however, trying to test equality with the type forall n r. Unit (Polynomial n r) -> Unit (TrigPoly n r) results in an ambiguity error
12:52:13 <monochrom> zeta_0: In GHC's version number x.y.z, z is point release, you can always safely prefer the maximum z, in fact also recommended to keep an eye out and upgrade to every new z.
12:53:47 <monochrom> x.y should be taken together as major release, fundamental changes to features.  When do they increase y and when do they increase x is relatively subjective.
12:53:53 <hseg> solonarv: http://ix.io/2iIy contains the terms in question
12:54:13 <hseg> Unit is a type family associated to Unital
12:57:43 <solonarv> hm. I lack context, but it may be possible to enable the trifecta of ScopedTypeVariables + AllowAmbiguousTypes + TypeApplications and just specify all the types yourself
12:58:00 <Welkin> hola mi chicas!
12:58:23 <monochrom> what is chicas?
12:59:07 <Welkin> eres tu
13:01:16 <monochrom> I only know ertes.eu
13:02:54 <zeta_0> i'm contributing to ghc, does it matter what `flavour` i use to build it with when contributing?
13:03:19 <Welkin> monochrom: ertes is no longer with us
13:03:29 <monochrom> I know.
13:06:59 <sm[m]> 8.8.3 should be avoided if you’re  on windows, fwiw
13:07:54 <hseg> solonarv: context sketch is given here http://ix.io/2iIG
13:08:19 <ja> sm[m]: what is wrong with it?
13:08:23 <hseg> ... fmap (ass . getT . injU) should be fmap (assU . getT . injU)
13:08:32 <maerwald> windows is a minefield
13:08:45 <hseg> GHC complains n, r are ambiguous
13:09:09 <ja> chris penner is streaming live now (author of the optics book):  https://www.youtube.com/watch?v=MGCzbPOrVDQ
13:10:11 * monochrom turns it around --- inversion thinking.  windows should be avoided if you're on ghc :)
13:11:21 <maerwald> that's pretty good advice, especially since most people probably never *test* their code on windows :P
13:11:54 <sm[m]> ja:  access violation errors with some builds, ghc issue 17926 or something
13:12:13 <solonarv> hseg: they are indeed ambiguous; ghc cannot figure out what 'n' should be based on knowing what  'U (T n r)' is
13:12:34 <sm[m]> 8.8.2 or 8.10.1 work better for me (ymmv)
13:13:14 <solonarv> the two solutions are basically: enable AllowAmbiguousTypes here, and force uses sites to resolve the ambiguity with TypeApplications; or figure out a way to make U injective
13:13:16 <maerwald> sm[m]: You're using mac AND windows?
13:13:31 <ja> i had issues with e.g. uuid on 8.10 and hvr seems not to be looking at the issues or pull requests...
13:13:32 <maerwald> as if mac isn't full of surprises already :)
13:13:42 <hseg> yeah, but I want to preserve the ability to derivingVia HU
13:13:55 <monochrom> The two most popular desktop OSes
13:13:58 <solonarv> looks like you are stuck with option 1, then
13:13:58 <hseg> how would I use AAT+TA here?
13:14:03 <monochrom> and laptop
13:14:37 <solonarv> you usually also need ScopedTypeVariables in conjunction with those, so you can mention all the types you need
13:14:59 <sm[m]> maerwald: not using myself, but supporting and testing all platforms
13:15:04 <solonarv> type sigs would look like: f :: forall n r. [U (P n r)] -> P n r
13:15:12 <maerwald> sm[m]: Are you testing linux as well? :)
13:15:31 <sm[m]> of course, with every push
13:16:05 <sm[m]> windows is the one I test least of course
13:16:25 <sm[m]> but I can push to the windows-ci branch whenever I want to do that
13:16:48 <solonarv> f' :: forall n r. [U (T n r)] -> T n r; f' = T . f @n @r . catMaybes . fmap (assU @(P n r) . getT . injU @(T n r))
13:16:52 <solonarv> something like this should work
13:18:05 <zeta_0> monochrom: thanks for the explanation, i understand ghc's x.y.z release versions better now
13:18:32 <hseg> ah right. hit on the correct type application
13:19:06 <hseg> application needed to be made at getT
13:19:44 <hseg> and since I extracted the (assU . getT . injU) part, I needed to touch up its constraints
13:21:08 <solonarv> oh yeah, I just guessed at where to put the type applications
13:28:39 <dsal> I get a bit confused between ScopedTypeVariables and TypeApplications.
13:31:12 <sm[m]> :: and @, right ?
13:32:10 <zeta_0> dsal: are you still hanging in there with nixos?
13:32:38 <dsal> sm[m]: I just want to use @ and then it doesn't work so I use ::   *shrug*
13:32:46 <dsal> zeta_0: Yeah, been writing all my code there.
13:33:26 <dsal> Trying to figure out how to do websockets in elm since I got the haskell side mostly working.  Actually, I think I'm going to do it a bit harder on the haskell side, making a proper MonadLogger -> websockets thing.
13:34:18 <zeta_0> dsal: nice, i've been using nixos for 6 months now, i want to start writing more nix when i have the time
13:35:02 <dsal> It's a huge upgrade from debian.  All I've done so far is write haskell code in it, though.
13:35:18 <zeta_0> i'm good with the haskell side of things on nix, but i haven't looked too much into elm, i'm waiting for the new stable nixos version to be released so i can use the new elm compiler
13:35:58 <dsal> My project has a shell.nix in the elm ui directory so it should just do the right thing.
13:36:29 <srk> dsal: tried miso?
13:36:35 <ja> sm[m]: oh my, that unchecked malloc return value :O haskell's addiction to C never ceases to be a problem ;)
13:36:39 <dsal> srk: I do not know what that is.
13:36:44 <srk> pff
13:36:57 <srk> dsal: https://github.com/dmjio/miso 
13:37:20 <dsal> Yeah, just opened that tab.
13:38:58 <dsal> Hmm...  Might be nice.  This project is mainly a huge playground at this point.  It's quite practical, though.  :)
13:39:22 <srk> can recommend, next level code sharing :)
13:39:48 <dsal> Someday, I'll find someone else who uses this stuff.
13:40:13 <dsal> Woo.  I have stylish-haskell working with BlockArguments.
13:40:36 <srk> dsal: dmj` <--
13:40:47 <srk> also #haskell-miso 
13:41:15 * hackage brok 1.0.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-1.0.0 (smallhadroncollider)
13:41:55 <koz_> Lol...
13:42:02 <koz_> The naming game in the Haskell ecosystem is a goldmine.
13:42:12 <koz_> (though 'bork' would have been even better)
13:43:28 <srk> :))
13:45:12 <sm[m]> ja: wow, latest comment is promising!
13:46:18 <sm[m]> I wonder how they found it
13:48:30 <maerwald> I had to think of Brok Lesnar, but yeah
13:50:33 <koz_> maerwald: Thanks for taking my cross-comp request for ghcup seriously. I appreciate a caring maintainer. :D
13:51:04 <maerwald> koz_: I wasted the entire day fighting CI, so didn't get anything done
13:51:26 <koz_> maerwald: Wheeee.
13:51:34 <koz_> Gotta love fighting tooling.
13:52:07 <maerwald> Interactive shell coding... git push -f, wait 10 minutes, look at error, be confused, change code, git push -f
13:52:39 <koz_> maerwald: What exactly does CI do in the case of ghcup-hs?
13:52:43 <koz_> Does it just build on a bunch of platforms?
13:53:01 <maerwald> koz_: yes, and the release artifacts
13:53:11 <koz_> maerwald: Ah.
13:53:38 <maerwald> and for half of the platforms a modern cabal is still missing (FreeBSD, alpine, ...)
13:53:45 * hackage cpkg 0.2.5.2 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.5.2 (vmchale)
13:53:54 <maerwald> But now I got fully static cabal binaries, hehe
13:54:22 <koz_> maerwald: I guess this also applies to armv7 and aarch64?
13:55:10 <maerwald> Not yet, there's work going on in https://github.com/haskell/cabal/issues/6616
13:55:17 <koz_> Ah, OK.
13:55:24 * koz_ will keep an eye on.
13:58:14 <jarlg> Good day folks! I have a two-parameter data type (data T a b = ..) and I need to write an instance for e.g. "T a Char" that is parametric in a. Is there a nice way of doing this without newtype-wrapping and flipping the parameters?
13:58:15 * hackage git-brunch 1.3.0.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.3.0.0 (andys8)
13:58:27 <koz_> jarlg: Not really.
13:58:49 <koz_> I guess you're trying to write like, a Functor instance or something?
13:59:04 <koz_> So you _need_ to be of kind Type -> Type or something, and thus need the parameter to come last?
13:59:42 <jarlg> koz_: Sure. Yeah if the parameter came last I'd be fine.
14:00:09 <koz_> Yeah, basically, newtype's the way.
14:00:45 <koz_> You can also reorder the type parameters in the type definition if you prefer.
14:00:51 <koz_> I dunno if this is viable in your case.
14:02:21 <jarlg> koz_: Yep, thanks. No, I need various instances for each of the parameters. The newtype solution is quite ugly though, do you know of any discussion to improve the situation?
14:02:42 <koz_> jarlg: I don't think this can be done without _very_ nontrivial changes to the language.
14:03:05 <koz_> You can certainly propose a way forward (there's a Github repo for just such proposals), but it's quite major.
14:03:30 <comerijn> jarlg: What would you imagine as more elegant? Because all the options I can think of break the type system in dramatic ways
14:03:48 <koz_> comerijn: Hi! Are you co-working on Cabal? :P
14:04:10 <comerijn> koz_: I'm not working at all :p
14:04:14 <koz_> comerijn: Lol.
14:04:20 <koz_> Haskell: redefining co-working.
14:04:48 <comerijn> jarlg: You'd need a type level flip that allowed partial application, but allowing type level partial application is equivalent to type level lambdas and would break the type system in drastic ways
14:05:37 <comerijn> koz_: I only work on cabal when I *really* want something fixed for myself, because sadly no one is paying me to devote more time to it :p
14:05:48 <koz_> comerijn: Story of many lives here, I guess.
14:05:53 <jarlg> comerijn: I'm not familiar with GHC internals, when you say "break the type system" do you mean GHC specifically? I don't see the type theory crumbling from such an operator.
14:06:02 <koz_> jarlg: GHC specifically.
14:06:07 <comerijn> jarlg: The theory
14:06:12 <koz_> Oh wait, really?
14:06:13 <Uniaika> (nice)
14:06:28 <koz_> Uniaika: No-one could ever accuse me of being very smart.
14:06:37 <monochrom> GHC has a theory, too.
14:06:50 <monochrom> For example the OutsideIn(X) paper.
14:07:04 <Uniaika> koz_: get ready for the tribunal then, it needs to be fixed :P
14:07:32 <koz_> Uniaika: Seriously, I'm just a Markov chain that's been fed Haskell-related literature for years.
14:07:42 <monochrom> <-- Chinese room
14:08:12 <maerwald> I'd prefer those japanese gaming rooms where you can get instant ramen in the hallway.
14:08:27 <maerwald> Not that I live there...
14:08:29 <maerwald> Err...
14:08:51 <comerijn> koz_: My live consists mostly of work, thesis and procrastinating from thesis, so... :p
14:08:53 <koz_> maerwald: I'm not sure John Searle had those in mind.
14:08:59 <koz_> comerijn: That makes sense.
14:09:05 <koz_> (been there, done that)
14:09:33 <koz_> (didn't get the t-shirt/sticker/other merch)
14:09:41 <comerijn> The procrastinating has been going well the past few weeks... :p
14:09:55 <maerwald> You need some whisky to focus.
14:10:05 <comerijn> maerwald: I'm already drinking one right now :p
14:10:10 <maerwald> Oh dear
14:10:18 <koz_> maerwald: The functional kind. If you take a drink, the bottle doesn't change.
14:10:23 <comerijn> I bought a new one especially to get through the lockdown :p
14:10:37 <comerijn> Or, that's what I tell my SO to justify the price >.>
14:11:30 <maerwald> which one?
14:12:12 <comerijn> Ardbeg Corryvreckan, because I'm a man of taste and sophistication :)
14:12:39 <maerwald> Try Glendronach 21
14:12:57 <maerwald> If you can afford it :P
14:13:28 <monochrom> If it doesn't match the regex ^Glen.*ich$ it is not authentic.  Change my mind.
14:13:31 <monochrom> (Just kidding!)
14:13:35 <comerijn> Glendronach is highlands, right? (also, this might be more of an -offtopic discussion :p)
14:14:30 <maerwald> Yeah, very well balanced
14:14:34 <comerijn> monochrom: Is there even anything besides Glenfiddich that matches that? The special issue Glenfiddich's are nice, but the Glenfiddich 12 you find everywhere is kinda...bland...
14:14:51 <maerwald> I literally dreamed about the test the next night :P
14:14:52 <[exa]> big brands are sold for blandness
14:14:55 <maerwald> *taste
14:14:59 <maerwald> oh, we're offtopic indeed
14:15:08 <monochrom> Yeah I think I don't like 12.  I'm OK with taking away the i
14:15:35 <comerijn> monochrom: The recent "15 Solera Reserve" is really nice and affordable!
14:15:45 <crestfallen> anyone care to help me with an nvim / json file error?  https://snipboard.io/5qKGwa.jpg     error to follow
14:15:50 <monochrom> I can't go out and buy now.
14:16:07 <comerijn> monochrom: Pfft, there's no booze delivery where you live? :p
14:16:52 <crestfallen> http://ix.io/2iJb    this json file has two red >> on the first line, and a vertical bar on the left of the file
14:16:58 <maerwald> crestfallen: there are pastebins, why the screenshot :P
14:17:38 <crestfallen> I thought it would be helpful
14:18:11 <monochrom> This particular one doesn't matter either way actually.
14:19:00 <crestfallen> on linux i was using pathogen to load the nvim package, now using coc to try it on a new work computer.
14:19:15 <crestfallen> to load the *haskell package
14:19:46 <maerwald> crestfallen: did you try making it valid json?
14:19:49 <maerwald> wrapping in { }
14:19:56 <crestfallen> so <<EOF>> doesn't work
14:20:09 <crestfallen> all the text and brackets/
14:20:13 <crestfallen> ?
14:20:18 <maerwald> You don't have outer brackets
14:20:24 <crestfallen> ok let me try sorry
14:23:42 <crestfallen> maerwald, thanks kindly! never worked with json
14:24:10 <maerwald> Oh
14:24:16 <maerwald> You must be lucky
14:24:38 <comerijn> maerwald: Just live under a rock like me :p
14:24:54 <monochrom> Could be worse.  I have to use a web API that outputs my choice of json or xml.
14:25:07 <jarlg> koz_, comerijn: Thanks for your insights! I guess I'll have to wait for Dependent Haskell to get what I want, i.e. something like "instance Functor (\a -> T a Char)". (Or is this wholly too naive?)
14:26:16 <monochrom> Wishing for Dependent Haskell is at the joint of too naïve and too sophisticated.
14:26:18 <comerijn> I'm not convinced dependent haskell will be all that pleasant, tbh
14:26:24 <comerijn> monochrom++
14:26:41 <comerijn> If you want dependent types, just go for a language that was designed from the start to accommodate them
14:27:40 <maerwald> comerijn++
14:28:32 <monochrom> devil's advocation:
14:28:36 <monochrom> @quote monochrom poor
14:28:36 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
14:28:38 <comerijn> I'm not convinced they'll ever end up not painful in Haskell
14:29:07 <monochrom> I'm positively asserting that it's an XY problem.
14:29:49 <crestfallen> maerwald, yeah never gainful employment with computers.. you may have guessed ;)
14:29:54 <slack1256> Hi, I got a .prof file I generated with +RTS -P --RTS. If a cost-centre has its percentage "allocated memory" greater than 0 but at the same time the "entries" value equal to 0, does that mean the expression was probably inlined (so you can't enter) but it still allocated memory?
14:30:34 <monochrom> I am now looking for an excuse to do ++ on maerwald to complete the rock-paper-scissor ++ cycle :)
14:31:03 <maerwald> monochrom: you're absolutely right!
14:31:10 <ja> chris penner now getting into indexed optics: https://www.youtube.com/watch?v=MGCzbPOrVDQ
14:31:32 <maerwald> if I could only watch youtube on my mobile network
14:31:37 <monochrom> Bah I owed you some from the past because ghcup is great etc.
14:31:43 <monochrom> maerwald++
14:31:45 <maerwald> :P
14:32:02 <crestfallen> maerwald, out of curiosity, I figured <<EOF>> would work, given that there are those ominous red >> at the beginning
14:32:19 <p0a> Hello 
14:32:27 <p0a> is there a 2d-plotting library? For points in the plane for example
14:32:44 <maerwald> crestfallen: EOF? what?
14:32:49 <slack1256> p0a: I used the gnuplot library which is just a thin wrapper.
14:33:18 <crestfallen> the error was [config] 'end of file expected'
14:33:44 <p0a> slack1256: thank you 
14:33:54 <crestfallen> just from searching json errors that came up
14:35:17 <maerwald> crestfallen: no idea, probably depends on the parser
14:35:27 <monochrom> p0a: I think Chart is worth considering
14:35:28 <slack1256> p0a: IIRC there is a module on that library, the "Simple" module, which has a function taking list of the form [(x,y)] and give you the graph you want modifying a some options.
14:35:57 <p0a> monochrom: thank you 
14:36:44 <monochrom> maybe gloss too, not sure how relevant to your case
14:38:15 * hackage tempi 1.0.1.0 - For representing musical tempi  https://hackage.haskell.org/package/tempi-1.0.1.0 (dktr0)
14:47:34 <dsal> Now that I've got monadlogger writing to stderr and any connected websocket clients, I get to learn about the sad state of WS in elm.
14:50:40 <dmj`> dsal: websockets in ghcjs work great
14:51:12 <dsal> I got the impression ghcjs was dead or something.
14:52:00 <maerwald> not as long as dmj` keeps miso alive...
14:53:32 <dmj`> dsal: It's alive and well
14:53:55 <dmj`> maerwald: I'd say more people than me depend on it
14:54:10 <dmj`> stack did drop support for it though...
14:54:10 <dmj`> bad move
14:54:11 <maerwald> What other projects use it?
14:54:24 <maerwald> I don't remember if Obsidian depends on it
14:54:28 <maerwald> they do, right?
14:54:30 <dmj`> yea
14:54:33 <dmj`> afaict
14:54:50 <p0a> is there something better than (f . (g x))
14:54:53 <dmj`> but others too
14:55:09 <maerwald> f `fmap` g x
14:55:19 <koz_> f <$> g x
14:55:22 <maerwald> :P
14:55:22 <comerijn> (f . g x) ?
14:55:34 <p0a> f . g x won't work because g takes two arguments
14:55:47 <comerijn> p0a: That's entirely irrelevant
14:55:51 <dmj`> :t \f g -> (f . (g x))
14:55:52 <lambdabot> (b -> c) -> (Expr -> a -> b) -> a -> c
14:56:14 <koz_> @pl \f g x -> f . (g x)
14:56:14 <lambdabot> (.) . (.)
14:56:21 <p0a> comerijn: oh, sorry. the precedence makes it equivalent to (f . (g x)) ?
14:56:28 <monochrom> yes
14:56:30 <comerijn> p0a: precedence of infix operators is always lower than function application, so "(f . g x)" and "(f . (g x))" are identical
14:56:34 <p0a> got it. Thank you 
14:56:55 <monochrom> no one had "(f . g) x" in mind, don't worry :)
15:24:14 * hackage singlethongs 0.1 - Like singletons, but much smaller.  https://hackage.haskell.org/package/singlethongs-0.1 (RenzoCarbonara)
16:05:45 <lyxia> o.o
16:20:49 <hseg> ... using noninjective type families is getting annoying, _fast_
16:21:26 <hseg> they basically infect all use sites with typeapps
16:22:26 <Guest24356> Cool
16:22:27 <hseg> otoh, need noninjectivity since can't use derivingvia for data families
16:38:15 <solonarv> hseg: I did tell you that TypeApps would be required at all the use sites :/
16:38:25 <hseg> :/
16:38:43 <hseg> yes, but the typeapps are remarkably infectious
16:39:03 <hseg> anything that uses the type family nonparametrically needs them
16:41:01 <hseg> ... remind me why we can't have datafam+derivingvia, again?
16:42:13 <hseg> (so eg for the usual deriving via Int instance F Age, the idea would be to have F Age = an isomorphic copy of F Int)
16:42:55 <hseg> with all code needing to be coerced for this replacing the constructors by their isomorphic copies
16:44:33 <hseg> (aside from the possible implementation burden)
16:52:20 <sheepfleece> Sorry, it's kinda broad question, but I need to ask it anyway. How should I properly manage db queries? By that I mean that I have lots of functions which carelessly use `head` and `tail` on results of queries. And it looks really ugly.
16:53:12 <dsal> sheepfleece: You should return the right type from the query.
16:53:36 <monochrom> If you use both head and tail on the same result, you can easily change it to pattern matching.
16:53:39 <dsal> What DB client are you using?  And why would you use `tail`?
16:54:22 <dsal> i.e., I have a few queries that return exactly one result, but for the rest, I return a [Thing] or (Map K V) sort of result.
16:54:33 <Axman6> queries should return Maybe a, or Vector a
16:54:34 <sheepfleece> My query returns something like [[MySQLType]]. And all those results depend on how my query looks like.
16:54:45 <Axman6> which database library are you using?
16:54:56 <sheepfleece> mysql-haskell
16:55:17 <Axman6> mysql-- :(
16:55:18 * dsal is sad every time mysql comes up in conversation
16:55:28 <sheepfleece> but why :c
16:55:43 <dsal> There are lot of options.  I mean, I guess there has to be a worst.
16:55:50 <dsal> But this probably isn't entirely related to your problem.
16:56:12 <Axman6> Do you have to use MySQL? PostgreSQL is definitely much better supported (and a much better database)
16:56:39 <sheepfleece> No, I don't have. Just chose what I knew.
16:56:43 <dsal> All of my DB functions look something like this:  loadMedia :: (HasGoProDB m, MonadIO m) => m [Medium]
16:56:51 <Axman6> The reason I bring it up is that you have a much better choice of libraries to access postgres than mysql
16:57:38 <sheepfleece> Now I also have functions like this. I don't even now how to name them properly.
16:57:42 <sheepfleece> giveOrTake :: [[MySQLValue]] -> (Int, Int)
16:57:42 <sheepfleece> giveOrTake = \case
16:57:42 <sheepfleece>   [] -> (0, 0)
16:57:42 <sheepfleece>   ((x:y:_):_) -> (stripToWord x, stripToWord y)
16:57:42 <sheepfleece>   _ -> throw My.WrongParamsCount
16:58:22 <dsal> That seems wrong for a few reasons, but I don't know what it's supposed to do, so I can't quite explain how to do it better.
16:58:32 <sheepfleece> And as I understand `throw` introduces lazy IO, which is even worse.
16:59:19 <sheepfleece> Well, it takes the result of a query, and returns first two values in a first row.
16:59:22 <Axman6> No wonder you're struggling with how to manage things, that looks like an awful interface to a database
17:00:25 <sheepfleece> I can switch mysql, it's no biggie, which library should I choose then? 
17:00:58 <dsal> Can you use SQLite?
17:01:08 <sheepfleece> I think?
17:01:13 <dsal> sqlite-simple is pretty good.
17:01:28 <slack1256> I agree with dsal.
17:01:29 <sheepfleece> I'll check it out, thank you!
17:01:50 <slack1256> I learned both sqlite-simple and SQL in general reading the types and examples of that library.
17:02:25 <dsal> SQLite is like, a really great bicycle.  It's probably what you need most of the time.  It doesn't take the place of a bus or airplane or whatever, but you can get a lot done on a bicycle and it's far cheaper and more reliable.
17:02:39 <koz_> Yep, 'bicycle' is a good analogy.
17:02:49 <koz_> (it has about the same degree of safety)
17:02:54 <koz_> (don't forget your helmet!)
17:02:54 <dsal> haha.
17:03:20 <dsal> If mysql is appropriate, either sqlite or postgres is better.  sqlite is easier.
17:03:28 <slack1256> You can use a sqlite just a better replacement of FS files, with acid semantics and structure.
17:03:41 <monochrom> Can I bring the s/bicycle/sqlite/ on to the s/airplane/oracleDB/ ?  >:)
17:03:43 <dsal> mysql is the guy who gets a hummer to drive to the corner store.
17:04:08 <dsal> monochrom: Yeah, I suppose you could store sqlite databases as BLOBs in oracle.
17:04:41 <slack1256> I actually got an example of sqlite simple on MusicScroll (hackage, help my dl count :-p ). I use it to cache data from the web.
17:05:18 <dsal> The link I pointed sheepfleece to earlier WRT qq was using SQLite.  It's not like, *great*, but it's my current playground I'm doing awesome stuff with.
17:05:55 <sheepfleece> It uses tuples instead of lists for values in rows, should be way more simple to work with. However I wonder what would happen if I give it a tuple of wrong size.
17:06:08 <dsal> What is "it"?
17:06:19 <sheepfleece> sqlite-simple
17:06:29 <dsal> Uh, no.  Consider this bit:  https://www.irccloud.com/pastebin/4WNnS831/selectareas
17:07:04 <dsal> You *can* use a tuple and it'd make your question above moot.  Or you can use an arbitrarily complex type.
17:07:59 <sheepfleece> Yes, I think I can define an instance of `ToField` and `ToRow`, looks nice.
17:08:00 <dsal> For a bit more context, this is what Area is:  https://www.irccloud.com/pastebin/Cfk1itBe/area.hs
17:08:49 <slack1256> I just marshaled my data type to a list to use its ToRow instances directly.
17:09:53 <sheepfleece> Does it use `Generic` to derive them automatically? 
17:10:20 <dsal> That one is pretty complex, so I did it by hand:  https://www.irccloud.com/pastebin/oRIecPr2/area.hs
17:11:18 <sheepfleece> Oh, I see, thank you. And what if your query returns something else (say you change something in your select)?
17:11:28 <dsal> I also did this thing, which is kind of nuts...  https://github.com/dustin/gopro/blob/master/src/GoPro/Commands/Fixup.hs  -- it takes an arbitrary SQL query and then converts the results to API calls where it grabs arbitrary JSON from the GoPro Plus service and swaps out values based on additional columns and pushes those back up.  (Used it to do some data fixup)
17:11:40 <dsal> Well, then the whole action will fail.
17:12:45 <hseg> can anyone remind me why gnd+assocdata=poison?
17:13:21 <hseg> seems all you need to do is create an isomorphic copy of the data type
17:13:42 <hseg> and replace all constructors by their analogues in all terms from the instance declaration
17:13:59 <hseg> doesn't feel like such a heavyweight ask
17:14:00 <lyxia> uh, it's not poison
17:14:11 <lyxia> maybe some specific usages don't work
17:14:35 <hseg> ok, example?
17:17:43 <sheepfleece> I wonder whether Dependent Haskell can bring more static guarantees into this. 
17:18:36 <dsal> That sounds like all of the thing monochrom loves.
17:18:36 <sheepfleece> At least it should be possible then to count the number of `?`. It can be done even now with lots of boilerplate and TypeFamilies.
17:18:56 <dsal> You don't have to use ?, not that it helps.
17:19:23 <dsal> e.g. https://github.com/dustin/gopro/blob/master/src/GoPro/DB.hs#L219-L240
17:19:24 <sheepfleece> But for type safety you would need to also provide table definitions.. I wonder.
17:19:29 <lyxia> hseg: https://dpaste.org/OKFR
17:20:12 <dmj`> at what version of base did Prelude start re-exporting Data.Monoid
17:21:14 <slack1256> TIL: You have a filter syntax for cost centers via +RTS -hc -hcmyPolymorphicFun -hy[] --RTS
17:21:45 <sheepfleece> Oh, I saw a nice blogpost which listed all breaking changes to Prelude. I'll try to find it now.
17:22:17 <hseg> lyxia: https://dpaste.org/ivXn is basically what i had in mind would happen
17:22:17 <Phyx-> monochrom: haters gonna hate
17:22:48 <monochrom> Wait, what do I love? What is being hated? :)
17:23:15 <monochrom> Is it dependent types and poisons you're referring to?
17:23:35 <hseg> ... but that does require more spooky action at a distance than is reasonably
17:23:41 <hseg> *reasonable
17:24:43 <hseg> (consider the case where the rhs of a data family is some huge unwieldy type -- you'd need to somehow inspect the entire type. and what if it's recursive?)
17:26:50 <sheepfleece> @dmj` https://www.fosskers.ca/en/blog/base
17:26:51 <lambdabot> Unknown command, try @list
17:27:19 <sheepfleece> Well.. I hope they see it!
17:28:31 <sheepfleece> It also seems there is nothing about re-exporting modules :(
17:30:30 <hseg> yeah, don't think there's a way around the type annotations
17:30:40 <hseg> _ugly_ though
17:30:47 <hseg> and have been spoiled by inference
17:30:50 <dmj`> sheepfleece: I guess this is what base-compat is for
17:31:19 <hseg> too bad i can't tell ghc "this index is monomorphic in this block"
17:31:26 <dmj`> sheepfleece: I just have a small "Data.Monoid is redundant" for GHC 8.6.+, that I know would be an error on anything previous, but I don't think people actually use old GHCs
17:31:47 <hseg> .. that's basically me asking for type-level closures
17:31:59 <hseg> which is never going to happen
17:36:54 <sm[m]> slack1256: interesting trick!
17:40:47 <monochrom> dmj`: Once in a while there are beginners who go "apt install ghc".  They will get 8.0 IIRC.  I don't know about Monoid, but their Applicative certainly has liftA2 as a function not as a method.
17:41:08 <monochrom> I know because my students ran into this. Just this April.
17:42:16 <dmj`> monochrom: that's rough, poor students. Now their perception of Haskell is ruined :( 
17:42:58 <monochrom> Oh it's alright, they came to my office hours for help. Only their perception of ubuntu is ruined. :)
17:43:30 <monochrom> Very likely they have finally learned to love ghcup.
17:43:35 <yushyin> but monochrom is a good advisors/teacher and tells his students about ghcup asap
17:43:41 <dmj`> placing the blame on ubuntu, that's genius.
17:44:23 <monochrom> I don't even have to explicitly blame ubuntu.  They can infer it themselves.  Best kind.
17:45:51 <monochrom> because after trying both apt and ghcup, if one gives you trouble and the other doesn't, you will infer the same blame, I don't have to tell you.
17:56:22 <rednaZ> I am having some trouble with functional dependencies. I do not understand the type inference behavior of the compiler in this gist, https://gist.github.com/prednaz/ce3caba5c7eeaa86dd3e2c84c052b2a7 .
17:56:59 <rednaZ> I have added the compiler error and my problem with it as a comment at the bottom.
17:57:07 <siraben> monochrom:  Ah, you're a professor of computer science?
17:58:52 <Benzi-Junior> hey, Im having problems compiling xmonad after a system upgrade
17:59:24 <Uniaika> Benzi-Junior: what is your system?
17:59:29 <Uniaika> and your XMonad version?
17:59:31 <Uniaika> and the errors?
17:59:33 <slack1256> And what is the error?
17:59:39 <Benzi-Junior> ArchLinux
17:59:40 <dsal> What's your problem!?
17:59:44 <Axman6> rednaZ: those instances look odd to me, I can't figure out what they're supposed to do
17:59:51 <dsal> Oh.  I've never heard anything good about ArchLinux.
17:59:56 <Uniaika> Benzi-Junior: my condolences
18:00:07 <Benzi-Junior> version 0.15.19
18:00:12 <Uniaika> cf https://twitter.com/TechnoEmpress/status/1250934493722132480
18:00:20 <Benzi-Junior> sorry 0.15.39
18:00:25 <Axman6> Arch and Haskell used to be a pretty common combo but then they went and completely broke everything Haskell
18:00:25 <slack1256> Benzi-Junior: ArchLinux? por tortured soul...
18:00:54 <dsal> I just started using nixos.  Doing haskell dev there.  Running xmonad.   It's pretty nice.
18:01:00 <rednaZ> Axman6: `Construct element rest list` means, element is in list and rest is what you get after taking it out.
18:01:09 <rednaZ> Axman6: Thank you for your time.
18:01:29 <Uniaika> Benzi-Junior: sorry to tell you that but you're dependent on Arch's support team here :/
18:01:38 <Cale> rednaZ: In that case, why is there an instance Construct element (head ': rest) (head ': tail) ?
18:01:42 <Axman6> oh I see, I'd missed that head was in the first instance twice.
18:01:45 <Cale> oh, I see
18:01:51 <Cale> You're implementing sets
18:02:04 <rednaZ> Well, order still matters.
18:02:09 <rednaZ> ...unfortunately.
18:02:17 <Axman6> I definitely find this stuff simpler using type families
18:02:40 <Cale> I definitely find this stuff simpler not being done at all
18:02:41 <rednaZ> Wait, I see, what you mean when you say sets.
18:02:58 <rednaZ> associated or closed?
18:03:11 <Axman6> You know you're in for a good time when the first ten lines of a Haskell file are language pragmas
18:03:45 <rednaZ> Sometime you have to do the dirty work.
18:03:49 <Cale> It bothers me that {-# OVERLAPPABLE #-} doesn't appear to require a language extension
18:03:54 <monochrom> This is why I use only one line :)
18:03:58 <Cale> That's the most contentious thing going on here
18:05:23 <Cale> Sigh, maybe we ought to have type level Set built-in, just so that people stop abusing type level lists so hard. But that might encourage people to actually do this stuff more.
18:05:33 <monochrom> Yes I agree.
18:05:50 <monochrom> Both sentiments, the former and the latter >:)
18:06:19 <rednaZ> I would not do it, if I did not need it. I take no pleasure in this.
18:06:37 <Axman6> yeah I;'ve definitely wanted type level sets for a long time, it's really easy to get into situations where GHC can't infer what should be an obvious type 
18:07:35 <monochrom> Actually, I think that so far all uses of type-level sets are warranted, they are not abuses.  I would rather them enjoy real type-level sets than boilerplating type-level elem and delete.
18:08:16 <Axman6> I think this is where I ran into pain when using type level lists as sets: https://gist.github.com/axman6/764b609229fd9f53d3c7294a0c1ba4fe
18:09:02 <Cale> There are a lot of cases where one can replace type level sets by user-defined GADTs whose indices enumerate the options
18:09:10 <monochrom> Type-level sets will finally open the door to checked exceptions so we can finally exceed Java in all aspects!
18:09:35 <monochrom> oooohhhhh GADT IO...
18:09:50 <Axman6> monochrom: like https://gist.github.com/axman6/19adc08a809d919a2efb ?
18:10:06 <Axman6> maybe that was the one I had issues with
18:10:08 <monochrom> readFile :: FilePath -> IO e String ...
18:10:47 <Axman6> is e the type of possible exceptions there?
18:11:04 <monochrom> yeah Axman6, I think so. (TLDR skimmed it)
18:11:08 <monochrom> Yes!
18:11:26 <Axman6> hmm, I think I just realised how to make what I was trying to do in that last gist work actually...
18:11:34 <monochrom> I'm making it up on the spot.  It may be unimplementable etc.
18:11:47 <Cale> rednaZ: Are you familiar with dependent-sum?
18:12:26 <Cale> data DSum f g where (:=>) :: f a -> g a -> DSum f g
18:12:42 <rednaZ> No, I am not.
18:12:50 <rednaZ> Looking at it.
18:13:33 <Axman6> Hopefully it's already solved all your problems
18:14:03 <Cale> One thing you can do to relate it with the list-y strategy you were already going for is to define a GADT whose constructors identify an element of a type level list
18:14:40 <rednaZ> Ok. Do you understand GHC's behavior in my gist?
18:15:42 <Cale> Well, it's saying that you have both an instance  Construct head tail (head : tail)
18:16:01 <Cale> and a constraint  Construct Char '[Char] '[Char, Bool]
18:16:15 <Cale> and that due to the functional dependencies on Construct (let's figure this out in detail)
18:16:17 <rednaZ> But where is that constraint coming from?
18:16:42 <Cale> Well, that must be coming frm the type of inject
18:16:49 <rednaZ> It does not.
18:16:56 <rednaZ> Does it?
18:16:57 <Cale> We're clearly giving inject a Char, so element ~ Char
18:17:19 <Cale> and we're expecting an OpenSum '[Char,Bool] from the type of openSum
18:17:20 <rednaZ> Agree.
18:17:24 <rednaZ> Agree.
18:17:31 <Cale> so that means list ~ '[Char, Bool]
18:17:46 <Cale> So we know both element and list
18:17:50 <Cale> So rest is determined
18:17:53 <rednaZ> So it should be able to infer `rest ~ '[Bool]`
18:18:00 <Cale> (according to the functional dependency)
18:18:20 <Cale> So, we have instance Construct head tail (head ': tail)
18:18:36 <Cale> and we know head ~ Char
18:19:45 <Cale> and head ': tail ~ '[Char, Bool] seems fine so far
18:19:56 <Cale> so tail ~ '[Bool]
18:20:02 <Cale> now let's try the other instance
18:20:08 <Cale> which overlaps
18:20:29 <Cale> so, Construct element (head ': rest) (head ': tail)
18:21:17 <rednaZ> It is not going to match. But even if it did, should it not be discarded anyway because it is marked `overlappable`?
18:22:25 <Cale> Oh, maybe, hmm
18:22:52 <Cale> But also, I think that instance matches
18:23:24 <rednaZ> The precondition is never met, is it?
18:23:32 <Cale> The precondition is irrelevant
18:23:53 <Cale> You never look at constraints on instances when trying to decide which instance matches
18:24:10 <Cale> element ~ Char, and (head ': tail) ~ '[Char, Bool]
18:24:53 <Cale> and so the "rest" is some type (Char ': rest')
18:25:29 <Cale> and so this violates the functional dependency already
18:25:42 <Cale> because (Char ': rest') is not equal to '[Bool]
18:26:01 <Cale> That's where it's getting the "Char is not Bool" complaint from
18:26:33 <rednaZ> Ok, trying to understand that. Thank you already.
18:27:11 <Cale> The fundep means that for any given element and list, there can be at most one rest
18:27:23 <Cale> But this isn't actually true of the instances that you've provided
18:28:02 <Cale> (it might be true if you took the satisfiability of the constraints on those instances into account, but the instance resolution process never does -- constraints are imposed only after selecting an instance)
18:28:25 <rednaZ> Good to know.
18:28:40 <rednaZ> Thank you very much.
18:28:58 <Cale> There's a good reason for that by the way -- if the instance resolver rejected an instance due to constraints not being satisfied, a future module (either in the sense of not being compiled yet or not being written yet) might come along and define an instance which would satisfy the constraint
18:29:15 <Cale> and so the compiler would have made a decision that was later rendered incorrect
18:29:33 <rednaZ> I see.
18:30:34 <Cale> So while it will fail completely if it can't find an instance it needs, it'll never succeed on the basis of a missing instance.
18:31:22 <rednaZ> Thank you very much. And thank you for dependen-sum too. Do you have any other open sum library recommendations?
18:33:15 <rednaZ> ...or checked exception library recommendations?
19:26:22 <Cale> rednaZ: Usually for checked exceptions, I just use Either Something
19:27:18 <Cale> (Possibly a monad transformer like ExceptT, but that is quite a rare choice)
19:29:32 <DocKlobi> (\x -> succ) 1 -- don't pay attention to me; just playing around
19:31:11 <Cale> If you're trying to use lambdabot, it requires a "> " at the start of the line to respond. Also, it will reply to private messages
19:32:18 <DocKlobi> thxs
19:32:55 <cortexman> https://www.flickr.com/photos/188105686@N08
19:33:01 <DocKlobi> > (\x -> succ) 1 -- don't pay attention to me; just playing around
19:33:03 <lambdabot>  error:
19:33:03 <lambdabot>      • No instance for (Typeable a0)
19:33:03 <lambdabot>          arising from a use of ‘show_M91761595034899861229332’
19:34:44 <Cale> Wow, that's not a very readable error -- worse than normal because of the stuff that lambdabot does
19:35:41 <Cale> Your expression will evaluate to succ :: (Enum a) => a -> a, and it basically doesn't know how to print functions (well, lambdabot does, but only if their type is Typeable, which implies that it's not polymorphic)
19:41:37 <DocKlobi> yeah, got my error 
19:43:58 <DocKlobi> > (x -> succ x) 1 -- embarassing ... this is what I really had in mind ... well it is very early morning
19:44:00 <lambdabot>  error:
19:44:00 <lambdabot>      Pattern syntax in expression context: x -> succ x
19:44:33 <DocKlobi> > > (x -> succ x) 1 -- sh.. again!
19:44:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
19:45:06 <DocKlobi> what? it works in the message thing
19:45:46 <dsal> DocKlobi: \x -> f x    is f
19:47:11 <DocKlobi> well, at least I thought I knew that
19:47:24 <DocKlobi> > succ 1
19:47:26 <lambdabot>  2
19:47:45 <DocKlobi> > > (x -> succ x) 1
19:47:47 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
19:47:52 <DocKlobi> > (x -> succ x) 1
19:47:54 <lambdabot>  error:
19:47:54 <lambdabot>      Pattern syntax in expression context: x -> succ x
19:48:15 <DocKlobi> (x -> succ x) 1
19:48:58 <dsal> DocKlobi: You need to start a lambda with \
19:49:35 <DocKlobi> sh...!! yes, it is really tooooooo early
19:50:24 <oats> (hint: `(\x -> f x) is equivalent to `f` :>)
19:53:05 <DocKlobi> yes, thxs. Just playing around ... wrongly. May be I should stay away from Haskell or even the whole programming. The details are important. I wonder how I could have made a living out of that. 
19:54:07 <DocKlobi> Also new to IRC.
19:55:10 <DocKlobi> I am ten years "old"
19:57:43 <Axman6> > (\x -> succ x) 1 -- a.k.a succ 1
19:57:45 <lambdabot>  2
19:59:28 <DocKlobi> > putStrLn "good morning Haskell world"
19:59:30 <lambdabot>  <IO ()>
20:00:09 <DocKlobi> @Axman6: thxs
20:00:09 <lambdabot> Unknown command, try @list
20:01:37 <DocKlobi> Axman6: thxs ; trying to wake up and find out how to reply to someone; where is help in freenode app?
20:04:07 <suzu_> you seem very well-read for a ten-year-old
20:04:38 <koz_> @pl \k v -> [(k, v)]
20:04:39 <lambdabot> flip flip [] . ((:) .) . (,)
20:04:44 <koz_> ... yeah nope.
20:04:55 <suzu_> that makes my brain melt
20:05:31 <koz_> :t flip flip []
20:05:32 <lambdabot> (a1 -> [a2] -> c) -> a1 -> c
20:05:55 <koz_> :t []
20:05:56 <lambdabot> [a]
20:06:17 <koz_> Wat.
20:06:27 <koz_> :t flip flip
20:06:29 <DocKlobi> suzu_: the body is way over 50
20:06:30 <lambdabot> b -> (a -> b -> c) -> a -> c
20:06:44 <koz_> :t flip flip flip
20:06:46 <lambdabot> (a1 -> ((a2 -> b -> c1) -> b -> a2 -> c1) -> c2) -> a1 -> c2
20:07:01 <koz_> OK, I will pull back from this abyss.
20:07:03 <DocKlobi> suzu_: ... and it's not kilograms I am talking about
20:07:06 <koz_> I'm not Iceland Jack.
20:08:34 <DocKlobi> who is Iceland Jack (sorry, I am a foreigner)
20:08:55 <koz_> DocKlobi: Someone who regularly writes extremely interesting Haskell and posts it on Twitter.
20:09:04 <koz_> It tends to involve things like what I just had.
20:09:07 <koz_> (a lot)
20:09:24 <DocKlobi> worth following him?
20:09:40 <DocKlobi> ok, no
20:10:19 <DocKlobi> well ... may be ... I used to experiment with ghci a lot like that
20:11:13 <koz_> DocKlobi: Yes.
20:11:16 <koz_> Unequivocally yes.
20:11:18 <koz_> It's amazing.
20:12:16 <dramforever> DocKlobi: You can't really reply to someone in IRC
20:12:40 <dramforever> DocKlobi: You just do this :P
20:12:41 <DocKlobi> dramforever: yeah, got it now
20:13:20 <DocKlobi> the client just marks it differently and I thought I had to use some funny syntax
20:13:35 <dramforever> IRC is extremely simple
20:14:12 <dramforever> Everything you see is either just text as you typed, or slightly flavored text
20:14:22 <DocKlobi> I like simple things. Saying that ... should stay away from haskell
20:14:39 * dramforever types /me something and it shows up like this
20:15:45 <koz_> DocKlobi: Haskell is simple, because it is honest about what things are complex.
20:15:55 <koz_> Other languages just straight up lie to you, so you hit the _same_ complexity, just later.
20:16:10 <koz_> Where 'later' often means 'in production, when your servers are on fire and you're losing money every second'.
20:17:10 <dramforever> Haskell doesn't have to be complex
20:17:17 <dramforever> There's fancy show-off syntax everywhere
20:17:26 <koz_> And fancy show-off semantics too.
20:17:31 <dramforever> Yeah
20:17:37 <dramforever> Don't get distracted
20:17:47 <DocKlobi> just "kidding". I LOVE this thing for allowing to build complex stuff from simple bits. But whooooo those "simple" (one liners) can be powerful
20:17:55 <dramforever> And it's not even that fancy, it just looks daunting
20:18:15 <koz_> Yeah, Haskell's _different_, but there's good reasons for it.
20:18:18 <koz_> (mostly)
20:18:29 <koz_> Aping C is not the pinnacle of language design everyone seems to be convinced it is.
20:18:32 <dramforever> Those crazy function compositions?
20:18:34 <koz_> (either in terms of syntax _or_ semantics)
20:18:40 <dramforever> 1. They are all built from tiny pieces that each does a little
20:18:44 <dramforever> 2. You don't have to use them
20:19:47 <DocKlobi> dramforever: it looks BEAUTIFUL. Different from the noisy programming stuff I have seen in 30 years
20:20:20 <dramforever> Coincidentally Haskell is about 30 years old
20:20:28 <koz_> About as old as me!
20:20:35 <dramforever> IIRC
20:20:53 <suzu_> i am gonna say something important here
20:20:55 <DocKlobi> IIRC?
20:21:02 <koz_> If I Remember Correctly.
20:21:06 <suzu_> haskell honestly is pretty crappy sometimes
20:21:17 <suzu_> if i need to get something working quickly, haskell has shown itself to be a bad tool
20:21:36 <suzu_> in these cases i no longer use haskell and i instead reach for python or ruby or something
20:22:00 <suzu_> and i think everyone understands that those are bad technical choices when compared to haskell, but what they are is that they are /productive/
20:22:13 <DocKlobi> I do not want to build quick an DIRTY stuff anymore
20:22:16 <chew2> you know I always hoped that wasn't true and that it would get faster as I get better
20:22:34 <koz_> suzu_: I don't consider garbage built fast productive.
20:22:35 <koz_> YMMV.
20:22:36 <suzu_> getting things working right away for something is very easy when .. i dunno, there's just so many libraries contributed by so many people and with so much documentation
20:22:46 <suzu_> chew2: i thought so too
20:22:48 <suzu_> :(
20:22:52 <koz_> However, I _do_ agree we could do with better docs.
20:23:00 <dramforever> And better libraries
20:23:01 <suzu_> for anything long lived, i will use haskell for certain
20:23:09 <suzu_> after the great initial investment, it is excellent
20:23:13 <dramforever> It's unfortunately a chicken and egg situation
20:23:29 <suzu_> but for stupid scripts and things where i need to accomplish a goal and i need to accomplish it in under 20 minutes, haskell is not the answer
20:23:37 <suzu_> sometimes i need that, so i dont pick haskell
20:23:39 <dramforever> Not saying that it is though
20:23:49 <DocKlobi> yeah, that is the challenge ... to find something worse living long in these times
20:23:52 <suzu_> sometimes i need good software for the long haul, and then it is dead certain to be haskell
20:24:03 <dramforever> I don't see a problem in that
20:24:20 <dramforever> Picking the right tool for the job is part of the job
20:24:20 <suzu_> i think the thing is that it took me a long time to convince myself that this answer is okay
20:24:52 <suzu_> that it's okay to say "if i need a website to show to somebody, and i need users, forgot password, reset password, emails, csrf, logging, and a bit of nice ui, haskell is total shit"
20:25:13 <suzu_> just install ruby on rails and slap some libraries together and it's working in an hour
20:25:18 <dramforever> maybe 'haskell in 2020 is not for that' instead
20:26:02 <DocKlobi> sure, if the "customer" needs something quick ... and doesn't bother about dirt ...
20:26:02 <DocKlobi> horrible days
20:26:05 <dramforever> i don't think there's anything inherent about haskell that doesn't allow it to be used as a slap-together language
20:26:15 <suzu_> sometimes the customer is me
20:26:26 <dramforever> i blame the ecosystem
20:26:27 <suzu_> do you think the CEO of a company actually cares at all what the software is built in
20:26:45 <koz_> suzu_: Depends on the CEO. The one I (technically) currently work for and who pays me sure as hell does.
20:26:46 <suzu_> they need it to work well and to solve stuff for people
20:26:52 <suzu_> the rest is negotiable
20:26:59 <suzu_> okay that's pretty good
20:27:06 <DocKlobi> the CEOs are a problem ... often ... and their shareholders ... us
20:27:09 <koz_> suzu_: This kind of thinking is why I loathe this industry with the fury of a thousand fires.
20:27:14 <dramforever> it's not like 'work well and solve stuff' is not related to what your thing is built in
20:27:17 <koz_> 'WHo cares if it's trash, it makes money'
20:27:20 <suzu_> but this kind of thinking is.. honestly it's correct
20:27:26 <koz_> This is why I _constantly_ find breakages in _everything_.
20:27:26 <suzu_> in a way
20:27:28 <koz_> It's not correct.
20:27:34 <suzu_> okay hear me out
20:27:37 <koz_> It's idiotic, comes from the wrong angle, and ought to be illegal.
20:27:42 <suzu_> if i were starting a new business
20:27:46 <suzu_> and i don't know if people will buy my thing yet
20:27:49 <koz_> I _cannot count_ the number of _hours_ I have wasted because of garbage like this.
20:27:58 <suzu_> and i need to put together something to show off to gauge interest
20:28:00 <suzu_> i am not going to pick haskell
20:28:03 <koz_> On both paid _and_ unpaid software.
20:28:08 <suzu_> i am going to pick some horrible, but productive, garbage
20:28:17 <koz_> suzu_: Remind me never to pay you to do anything.
20:28:17 <suzu_> and if and only if i can measure a demand then i earn the right to do a haskell rewrite
20:28:19 <koz_> Or buy anything from you.
20:28:30 <koz_> Like, no offense, but this gives me _zero_ confidence in any product from you.
20:28:39 <dramforever> suzu_: what's that 'haskell' thing you're not picking?
20:28:43 <DocKlobi> stop fighting
20:28:55 <suzu_> you can't say no offense and then something offensive
20:29:10 <koz_> suzu_: I can disagree with a take and not wanna hurt ad hominems.
20:29:11 <suzu_> but i understand your viewport and i used to agree with you too
20:29:21 <koz_> s/hurt/hurl/
20:29:37 <dramforever> suzu_: I'm like 90% sure you are not picking 'haskell' because good and productive are exclusive
20:29:47 <suzu_> and i have worked on many crappy codebases and all kinds of things before and wished fury of a thousand suns upon those who do not think structurally about how to design good software
20:30:05 <dramforever> *you are not (not picking 'haskell' because ...)
20:30:27 <suzu_> haskell as it is right now cannot accomplish tasks that other languages right now can
20:30:43 <DocKlobi> we ALL are doing something wrong
20:30:48 <suzu_> ruby on rails is a highly productive ecosystem for producing crappy web applications very quickly
20:30:53 <dramforever> suzu_: and it's not intrinsic
20:30:56 <dramforever> to haskell
20:30:57 <suzu_> haskell just like, lacks the libraries and documentation
20:31:00 <suzu_> its objectively bad
20:31:02 <koz_> suzu_: And is also why I basically loathe everything web.
20:31:03 <dramforever> ecosystem
20:31:20 <koz_> I don't care how fast something gets done if I can break it in 5 minutes.
20:31:28 <koz_> And it typically takes me _way_ less time than that _doing normal things_.
20:31:29 <suzu_> if i need users, user accounts, oauth, forgot password, reset password, account verification blah blah blah
20:31:31 <suzu_> people have done that
20:31:32 <koz_> On paid services.
20:31:36 <dramforever> basically, you can see that there isn't even a comprehensive standard library for common tasks
20:31:43 <suzu_> and thye have not done it very well, mind you, because rails is also a complete tire-fire
20:31:48 <dramforever> but here lies the problem
20:31:49 <suzu_> but... it's productive. it really is
20:32:02 <remexre> is there a way to get case-splitting for Haskell in Vim?
20:32:03 <dramforever> it's chicken and egg
20:32:11 <koz_> remexre: Not to my knowledge, no.
20:32:14 <suzu_> koz_: yeah the web is garbage
20:32:14 <dramforever> no docs and libs -> users don't pick haskell
20:32:23 <koz_> Although if you find it, please tell me, because idris-mode has spoiled me forever.
20:32:23 <dramforever> not enough users of haskell -> no docs and libs
20:32:31 <suzu_> okay so i think i know why this problem exists dramforever 
20:32:37 <dramforever> The only way out of this that I know of
20:32:54 <suzu_> and i think the answer is similarly funny and also i am going to be burned by koz_ here possible
20:32:55 <dramforever> is money
20:33:04 <koz_> suzu_: It's OK, I've said my piece.
20:33:05 <dramforever> or maybe in a less pungent way
20:33:07 <dramforever> paid work
20:33:10 <suzu_> haskell requires you to be a little bit intelligent to write it
20:33:16 <koz_> I don't think anything I can say will convince, or not convince, anyone of anything.
20:33:16 <suzu_> ruby / go / python don't
20:33:21 <remexre> koz_: heh, ditto; spent a while in idris, now doing agda and haskell and being sad over lack of a bunch of stuff from its vim tooling
20:33:21 <koz_> (well, anything _else_ I can say)
20:33:27 <suzu_> hence, tons of people contribute to things in those languages
20:33:36 <suzu_> they go flying to the moon on github with tons of stars
20:33:39 <suzu_> everyone can understand them
20:33:44 <suzu_> and write their own garbage libraries for things
20:33:44 * dramforever is thinking about Rust
20:33:50 <remexre> suzu_: have you read http://marktarver.com/bipolar.html ?
20:33:55 <suzu_> and you get garbage but productive code
20:33:58 <remexre> not needing a brain may be an evolutionary advantage
20:34:07 <suzu_> that people can just profit off of
20:34:13 <suzu_> glue these libs and there ya go
20:34:17 <suzu_> in haskell you gotta work for it
20:34:21 <suzu_> theres great reward
20:34:33 <suzu_> your code wont be a brittle house of matchsticks
20:34:38 <suzu_> but it takes strong up-front investment here
20:34:39 <dsal> suzu_: not being good at something doesn't mean something's not good
20:35:02 <suzu_> dsal: my only argument is that haskell is unproductive for a lot of things and i think this is why
20:35:15 <suzu_> haskell is still an excellent language and i enjoy writing it
20:35:19 <suzu_> i mean i am in this channel, arent i
20:35:23 <dsal> I do all my prototyping in Haskell. Then I keep the prototypes because they're pretty good.
20:35:34 <suzu_> i do think it's fantastic but it's horribly suited for making like, web applications or other meme software
20:35:44 <suzu_> when compared to other $memelang
20:35:54 <suzu_> remexre: no i havnet read this before
20:36:17 <dramforever> suzu_: I just think 'requiring intelligence' it's not the reason
20:36:32 <suzu_> what do you think it is instead?
20:36:58 <dsal> I'd I didn't do the thing in Haskell you said it's not good at so frequently, you might have an argument.  It just sounds like you don't understand it well.
20:37:28 <suzu_> sure, maybe i'm actually just not good at haskell and that limits my ability to build prototypes of things quickly
20:37:30 <dsal> (er, if... I'm on my phone, ironically, eating popcorn)
20:37:40 <dramforever> suzu_: Nobody took the effort to create the ecosystem around Haskell
20:37:46 <suzu_> but that reason can't ever be proven false
20:37:50 <Axman6> Haskell is amazing for making web services at least... frontend is the wild west everywhere though
20:37:51 <remexre> dsal: as someone who does webdev outside of Haskell, and most dev inside of haskell; it definitely feels like Haskell's web stuff is less approachable to someone who knows basic Haskell than Python's is to someone who knows basic Python
20:37:52 <dramforever> Basically, the problem is the same as the reason
20:38:02 <suzu_> dramforever: i think there is truth in that
20:38:06 <suzu_> haskell is a research language
20:38:10 <suzu_> at least primarily it was
20:38:12 <dramforever> You're not using Haskell because not as many are using Haskell
20:38:50 <dsal> remexre: maybe. The last few times I had to do web dev in python were pretty horrific and required a lot of trial and error
20:39:10 <Axman6> This conversation is starting to make me think that maybe the last 6 years of me programming Haskell professionally has all been a lie
20:39:10 <suzu_> i mean, other languages fall short after the initial development of a prototype i think
20:39:18 <remexre> dsal: tried flask? :P
20:39:23 <suzu_> reasoning and understanding the correctness of python
20:39:26 <suzu_> thats uh, a good joke
20:39:36 <remexre> ^^
20:39:39 <suzu_> i have zero clue what my program will do in python until i hit 'run'
20:39:43 <suzu_> but, i sure can make stuff fast
20:39:52 <dsal> remexre: I don't necessarily get to choose... When I do, it's not going to be python, so that's perhaps not fair
20:40:16 <dramforever> Axman6: We need more of you
20:40:19 <dsal> suzu_: 'til my user hits run
20:40:49 <suzu_> so i want to just recap my main point here because i think i was all over the place
20:41:06 <suzu_> i think haskell's productivity at t=0 is reeeeeally low compared to meme languages
20:41:20 <Axman6> yes
20:41:24 <suzu_> and if i need to produce something short-lived quickly, picking haskell isn't right
20:41:27 <dibblego> here is a real-world language:
20:41:27 <dibblego> ghc -e "putStrLn (replicate 100 '(')" | python3
20:41:31 <Axman6> no
20:41:38 <suzu_> if i need to produce something to stand the test of time, i am damn well sure using haskell
20:41:49 <suzu_> because i've got the time to spend on that big initial investment
20:41:51 <suzu_> the end
20:42:18 <dibblego> I've never understood the mystery of this dichotomy and those who strongly believe it
20:42:28 <Axman6> Haskell is what allows us to move fast. it's all the other shit like deployment which takes a lot of time in our apps
20:42:33 <dramforever> suzu_: You keep talking about picking haskell and not picking haskell
20:42:42 <suzu_> i made a case where picking is bad and another where picking is good
20:42:55 <dibblego> on what evidence or argument? 
20:42:58 <Axman6> "WE need new feature X" "Ok, we'll change X and see what breaks, then fix until it compiles again"
20:43:02 <Axman6> hapens all the time
20:43:08 <dramforever> suzu_: but you are really talking about something that's not intrinsic about the language
20:43:15 <Axman6> then I have to go and spend a few days writing CloudFormation
20:43:18 <dramforever> Maybe you haven't been thinking this way
20:43:26 <dibblego> "I'll just use this hack to get up and running quickly — oh wait, we can't even get up and running quickly!" — also happens all the time
20:43:47 <dsal> Ironically, my project today was learning websockets and getting my web app to also send it's info and warning logs to the browser.
20:44:11 <dsal> That part was pretty easy in Haskell.  The client side kind of sucked.
20:44:39 <suzu_> these are just thoughts i've had since i got a new dayjob writing kotlin
20:44:48 <suzu_> i was writing haskell professionally before for about 2y
20:44:50 <dramforever> It isn't really a nicely designed language on which a framework of thinking that you're leaving behind
20:45:15 <dramforever> It's just there isn't enough of the gaps filled up that you're not going to stand on it for the moment
20:45:38 <suzu_> haskell got the 'excellent language' gap filled in well
20:45:48 <suzu_> py/ruby/etc fail hard here
20:46:02 <suzu_> ecosystem, tooling, build times, docs
20:46:09 <suzu_> that stuff isn't quite there yet :(
20:46:10 <dramforever> the ecosystem is mostly itself a gap
20:46:21 <dibblego> I was at t=0 this morning, needed sequence, and was finished 3 seconds later — lucky I didn't pick python, where it takes days to have anything like that
20:46:44 <dibblego> luckily there was a good prototyping tool available, called Haskell, to get up and running quickly
20:46:53 <suzu_> im glad that worked for you
20:47:03 <dibblego> repeatedly, for the last 15 years
20:47:04 <suzu_> but if i need web stuff, haskell will not have that in 3 seconds
20:47:08 <dibblego> where are the counter-examples?
20:47:14 <suzu_> ruby on rails is a counterexample
20:47:24 <dramforever> You need a random website that does stuff
20:47:33 <suzu_> full batteries-included web development meme
20:47:39 <dibblego> I wrote a webapp in Haskell about two years ago, which took about 8 hours, and if you did it in python, I'd expect development to still be going
20:47:43 <suzu_> anything under the sun you can think of, it's a single library install away
20:47:44 <dibblego> where am I wrong?
20:48:00 <suzu_> it would most certainly take less than 8 hours
20:48:15 <suzu_> i can find you several projects on github you can clone immediately and will run in less than 30 min
20:48:17 <dibblego> what is "batteries-included"?
20:48:31 <dibblego> no, it would take at least two years — I'm willing to be shonw wrong
20:48:38 <suzu_> suppose you want users, models, tracing, logging, csrf tokens, forms, an asset pipeline
20:48:55 <dibblego> I just wanted it to work. There are users, but that was never a goal (except myself)
20:49:08 <suzu_> https://github.com/wsvincent/djangox
20:49:09 <suzu_> here you go
20:49:20 <dibblego> oh, you mean "bugs" included
20:49:30 <dibblego> ok yeah
20:49:35 <suzu_> probably not at this stage
20:49:40 <suzu_> but yeah later on it is going to fall apart
20:49:47 <dibblego> also, very quickly
20:49:52 <suzu_> but for the first while it'll be fine
20:49:56 <dibblego> (whether you notice or not is probably the point of contention)
20:49:58 <suzu_> and if that's all you need then that's okay
20:50:02 <dibblego> no, it won't be noticed that it is not fine
20:50:03 <suzu_> and in many cases that has been all i've needed
20:50:16 <suzu_> "scripts" are just bad programs
20:50:21 <dsal> My app's up to 1200 lines.  It's not super nicely designed, but I'd like to see someone do it in python.
20:50:22 <dibblego> this is probably the point of disagreement here
20:50:43 <dibblego> we agree that nobody claims that it is not fine; we probably disagree that it actually *is* fine
20:51:02 <suzu_> 🤔
20:51:06 <dibblego> and if that's "batteries included", then I don't want those batteries
20:51:33 <chew2> hello, I had a question about laziness. I was trying to write a lambda calculus interpreter and have it log each intermediate reduction that it does on the expression. I was hoping that with laziness I could see the log as it goes even if the expression doesn't terminate but that doesn't seem to be the case. Is there something strict here that I'm missing, or something like that? Here's the main:
20:51:36 <chew2> https://github.com/stevenfontanella/lambda/blob/master/app/Main.hs and here's the reduction logic: https://github.com/stevenfontanella/lambda/blob/master/src/Reduce.hs
20:52:15 <suzu_> dibblego: i think you are right
20:52:19 <dibblego> ok
20:52:23 <chew2> basically I'm snocing to a DList as it goes and trying to print the DList before the whole thing terminates but it seems to hang instead until the expression is evaluated
20:52:23 <suzu_> and it comes down to 'how long will this project live'
20:52:28 <suzu_> and 'what is my tolerance for toil'
20:52:52 <dibblego> if a software goal is, "to not notice that it is broken for a short period [because it is difficult to notice]", then yeah, I'd pick ruby or python
20:52:57 <dibblego> I just hardly ever have that goal
20:53:09 <suzu_> i unfortunately have this goal quite a bit these days
20:53:24 <dibblego> so does my now former organisation
20:53:27 <suzu_> i've had to macgyver trash to other trash and found ruby and python to be productive for it
20:53:29 <suzu_> and haskell to not be so
20:54:25 <dsal> This is a lot of subjective arguing from your own perspective.  It's quite a bit of cognitive dissonance for me because the things you're saying haskell is bad at are exactly the things I use it for.
20:54:36 <suzu_> it is exactly subjective, you're right
20:54:54 <suzu_> could you tell me about your experience? im keen to know
20:55:17 <suzu_> i've been reduced to believing that haskell isn't good for this afte rhaving worked so long in it believing it'll get better and it hasnt
20:55:31 <dibblego> if I need to prototype something, get it up and running, I'll often use Haskell, and disregard any of the much more laborious alternatives — this is my experience
20:55:36 <dsal> My experience is basically all the things you said, but the opposite.
20:56:08 <suzu_> how about web stack stuff? that's primarily where i've had to concede on this
20:56:14 <dsal> My GoPro app, e.g., started out with my trying to reverse engineer their API at my gf's house.  I had the skeleton done in ~30 minutes.
20:56:14 <dibblego> especially that
20:56:22 <dsal> That's literally what I did today.
20:56:28 <suzu_> well i'm dumbfounded then
20:56:31 <suzu_> am i just really bad at haskell
20:56:42 <dsal> It's got a web frontend and I modified my MonadLogger to send to both stderr and websockets.
20:56:42 <suzu_> could you tell me how you did it and what made it productive
20:56:49 <dramforever> Maybe you could mention tech stacks you used and tried
20:56:59 <dsal> I had to learn websockets for this, but it went pretty quickly with stm broadcast tchans.
20:57:07 <suzu_> plenty of servant
20:57:10 <dramforever> So we're not just yelling 'I can do this' 'I don't see how'
20:57:22 <suzu_> for building json apis servant has been great
20:57:28 <dsal> But the elm frontend took a bit more time because they don't have native websockets support.  :(
20:57:40 <suzu_> though i always need to do a lot of boilerplatey stuff
20:57:48 <suzu_> like swap the servant monad out
20:57:53 <suzu_> get katip in for structured logging
20:58:00 <dibblego> I had to use websockets to interface with avionics hardware — without haskell, that would have been difficult/impossible
20:58:21 <suzu_> for "full stack web" i've tried to shy away from yesod because i really really dont like TH
20:58:36 <suzu_> so i worked with happstack and it took a while
20:58:54 <suzu_> and i still had features to build even after a couple hours, that would have been provided to me right "out of the box" by ruby on rails
20:59:20 <dsal> I learned scotty for this project.  Specifically, ScottyT around an MTL stack.
20:59:32 <suzu_> i mean i eventually got there but it just felt like it took so much longer because i had to make my own wheels so often
20:59:58 <suzu_> and i know these are all *literal libraries* you just glue into your pile of rails junkyard and move on with your life
21:00:18 <suzu_> and then in the end i didnt use the project for that long anyway, it fulfilled its purpose
21:00:25 <suzu_> i have done this a total of th..ree times i think
21:00:29 <suzu_> and now i concede defeat
21:00:29 <dsal> I had to do a decent amount of that as well, but it's fairly easy.
21:00:43 <dsal> Can you show me the GPMF parser you'd use in ruby?
21:01:17 <dsal> The C API that GoPro put out was... not usable for various reasons.  It wouldn't process most of my files and omitted tons of useful data.  It was also about 10x or so larger than the one I wrote in Haskell from spec (which works for everything I could find).
21:01:21 <dramforever> chew2: Maybe DList isn't strict enough
21:01:25 <dramforever> *lazy enough
21:01:58 <suzu_> no gpmf in ruby, ruby admits defat
21:02:00 <suzu_> defeat *
21:02:03 <suzu_> i would write it in haskell too dramforever 
21:02:07 <suzu_> err dsal * my mistake
21:02:10 <chew2> dramforever: I guessed something like that. The library page doesn't have any mention of strictness or laziness. I ctrl+f'd its source for bang patterns and nothing came up but idk if that means anything
21:02:19 <suzu_> if i have to start from scratch anyway
21:02:24 <suzu_> then haskell is the obvious choice in my opinion
21:02:36 <suzu_> but if theres tons of stuff to profit from already
21:02:39 <dsal> I did also end up writing my own MQTT library in haskell because all the ones I found were strangely bad, though I contributed new protocol support to a C library I use on IoT things.
21:02:59 <suzu_> and i've got some tolerance to the code needing maintenance and i'd like to be productive up-front
21:03:03 <suzu_> then i'll pick the meme
21:03:08 <dramforever> chew2: No, wait, I think there's a fundamental problem
21:03:11 <dsal> I had the app working somewhat before I gave in and decided I wanted the video metadata.
21:03:30 <suzu_> so i think for your domain you are correct to use haskell
21:03:35 <suzu_> and i would've chosen the same
21:03:38 <dsal> There was a bad go implementation whose author recommended a node.js implementation.  A python implementation also was failing me.
21:03:50 <suzu_> i see you also tested the memes out and they all sucked
21:03:51 <dramforever> chew2: If the action runs forever and keeps modifying the state
21:03:53 <suzu_> :P
21:03:54 <dsal> My domain was "I want to make a web app better than GoPro's to browse my data."
21:04:08 <suzu_> could you tell me about the web part
21:04:13 <dsal> What do you want to know?
21:04:14 <dramforever> I don't think it's going to work out
21:04:18 <suzu_> it was just scotty?
21:04:23 <dsal> Yeah.
21:04:31 <dsal> It's just one of the commands in my cli thing.
21:04:32 <suzu_> just personal use? not public facing?
21:04:35 <chew2> dramforever: ah you think so? I was hoping not
21:04:37 <dramforever> chew2: You might be looking for a reverse state monad where the state is passed backwards
21:04:52 <dramforever> And you cons the log onto the rest of the log
21:04:58 <dramforever> instead of snoc-ing
21:04:59 <chew2> you might be right
21:05:04 <suzu_> then yeah nothing i said applies
21:05:08 <dsal> suzu_: Yeah, this is a single-user app.  AFAICT, nobody else uses GoPro Plus.
21:05:17 <suzu_> like literally nothing
21:05:28 <suzu_> all the published code for this sucked and didnt work
21:05:35 <suzu_> your demands aren't a lot
21:05:41 <suzu_> no strong web stuff
21:05:43 <suzu_> is necessary
21:05:46 <chew2> but I don't understand why this doesn't work. Even if the state is always changing, I should be able to view the head of the list and so on right?
21:05:47 <suzu_> yep haskell all the way
21:06:22 <dramforever> chew2: Not really
21:06:25 <dramforever> You know foldl?
21:06:30 <dramforever> Think of an infinite foldl
21:06:45 <suzu_> however if there was already a lot of python stuff published for this domain and you had just short-term needs then i think py would've been the right idea
21:07:06 <suzu_> but there wasn't
21:07:08 <suzu_> so it isn't
21:07:08 <dsal> *shrug*  Not sure what you mean.  This project is managing about a TB of data.  Works pretty well.  At work, I'm processing a few tens of millions of state messages per day.  When I give it all the cores I've got, it sits around 100MB of RAM, which is nice.
21:07:24 <dramforever> If only we had a better ecosystem of published non-sucking Haskell code
21:07:41 <dramforever> I haven't been following closely but I know it's getting better
21:07:42 <dsal> Your argument is a little dumb.  The domain is "Get stuff from web service and store it locally.  Then let me browse it."
21:07:46 <chew2> true
21:08:00 <chew2> I will look at reverse state
21:08:06 <chew2> thanks
21:08:16 <suzu_> my domain is, "I want to build a public-facing well-featured web application. And on a productive timescale"
21:08:27 <dramforever> chew2: Maybe not
21:09:02 <dramforever> I'm hoping that there's a monad that just lets you log stuff
21:09:11 <dramforever> In a lazily streamed way
21:09:16 <dsal> What's the difference between the thing I built and public facing?
21:09:20 <dramforever> I don't know what it's called
21:09:23 <dsal> dramforever: I'm using MonadLogger
21:09:38 <dramforever> Looks a bit overkill
21:09:48 <suzu_> dsal: it just increases the scope of what needs to be built and relatedly increases the amount of profit from using code other people have written
21:09:56 <dsal> In particular, my GoPro monad is a MonadLogger that sinks messages to a list of downstream monads.  Right now, I've got stderr and websocket messages.
21:10:28 <suzu_> users, forgot password, reset password, emails, locking them out if they login too much, forms, pretty css/html, logging, error reporting
21:10:46 <dramforever> I feel like MonadLogger is more tailored to literally application logging
21:10:48 <suzu_> oauth login
21:10:54 <dramforever> not like a lambda calculus trace
21:11:19 <suzu_> of course you pay the cost of it not being in haskell and the fragility of python/ruby
21:11:45 <chew2> yeah I agree
21:11:54 <chew2> I didn't want to add IO just for that
21:11:59 <dsal> What is your goal here?  You seem to be trying to convince me that when my reality doesn't match your reality, it's because there's a small detail I didn't need that I'm suffering.
21:12:28 <suzu_> i don't think you're suffering at all
21:12:28 <dsal> You don't need IO for MonadLogger.
21:12:33 <suzu_> i am saying that /i/ am suffering
21:12:58 <suzu_> i tried to compete with the productivity of these crappier languages given their wealth of libraries and ecosystem and i failed
21:13:09 <dsal> I guess.
21:13:20 <suzu_> and so i'm saying, i dunno. i think haskell hasn't been productive for me on this task
21:13:22 <dsal> I suffer greatly when I have to touch node.js, but people seem to get a lot of crap done there.
21:14:02 <suzu_> yeah node is awful
21:14:03 <chew2> dsal: ah I see WriterLoggingT, maybe that's what I would want.
21:14:11 <suzu_> but i have found productivity in it :(
21:14:19 <suzu_> for the few times i used it
21:14:29 <suzu_> there were libraries that did the thing i wanted, and i was done in 30 minutes
21:14:32 <chew2> I'm hoping that I would be able to access the log 'lazily' i.e. view it partially for something that doesn't terminate, do you know if I can? dsal 
21:14:45 <suzu_> and then i took a shower to try and wash the experience off
21:15:04 <dsal> chew2: No idea.  I've just got a couple of IO instances.
21:15:19 <chew2> ok well thanks for the pointer
21:17:00 <DocKlobi> This discussion reminds me of historical times. It must have been similar an industry problem before Henry Ford did his revolutionary move: moving the cars along the assembly line instead of all workers having to move to the car.
21:17:00 <DocKlobi>  We need to think and get out of the box. We need to stop thinking in ancient (last millennium) ways. We are doing something terribly wrong and stupid.
21:17:00 <DocKlobi> Someone (may be not an Haskell or Python or Node pro) needs to organise this.
21:18:23 <DocKlobi> It seems like a huge waste of time and money and personal satisfaction.
21:18:26 <dsal> DocKlobi: part of the problem is that when something works well for someone, they don't necessarily want to fix it.
21:18:44 <dsal> And a lot of time, new people come in and they want to fix things that are very much not broken.
21:19:31 <DocKlobi> Who is that that this horror is working well?
21:19:45 <dsal> I was an early go adopter and watched tons of people coming in and wanting to change the language the first week because it didn't do something they like.  Similarly, haskell noobs think every function should be an IO action.  *shrug*
21:20:18 <dsal> DocKlobi: I sit down with an idea and then I see it working.  I've been able to get things done I've never even considered in other ecosystems.  It's working quite well for me.
21:21:16 <DocKlobi> Sorry, with "horror" is was not referring to haskell
21:22:36 <DocKlobi> These endless Haskell, Python, Node, bad coding practises, etc. conflicts
21:23:28 <DocKlobi> This competition and "things have to be done quickly and never mind the dirt" thing
21:24:13 <dsal> I can move faster in haskell than I have been able to in any other language.  It's fascinating.
21:25:50 <DocKlobi> You! But us ... the average guys ... not. And because of that Haskell stays in that niche and will never ever get adopted in industry.
21:26:31 <DocKlobi> I am going a little bit extreme. I know Haskell is being used in industry.
21:26:50 <dsal> Anyone who practices.  vi is hard to use on your first day, but after you spend a bit of time in it, you can get a lot done very quickly.  Notepad is easy to use the first day, and you're always as productive.
21:27:38 <dramforever> 'average programmer'
21:27:44 <dramforever> 'industry programmer'
21:27:54 <dsal> I mostly use emacs these days, but it's the same thing.  You can have something that's easy for noobs, but wouldn't you rather have something that's easier when you've been using it for a bit?
21:27:55 <dramforever> I have a word for these: excuses
21:28:52 <DocKlobi> The industry needs us average guys. Same for Henry Ford.
21:29:08 <dsal> haskell is harder to learn than like, python or something, I guess.  It's not easier to write apps in, though.
21:29:30 <dramforever> DocKlobi: But when you talk about the average programmer in the industry
21:29:44 <dramforever> You don't really mean the average programmer in the industry
21:29:49 <dsal> though, afaict, haskell is only hard to learn if you have stuff to unlearn.  It's probably easier if you don't have a broken mental model.
21:29:57 <jgt> > (-1.0 :: Double) == (-1.0 :: Double)
21:29:59 <lambdabot>  True
21:30:11 <jgt> > (-1.0 :: Double) == (-1.0e10 :: Double)
21:30:13 <lambdabot>  False
21:30:19 <dramforever> You just mean you are not familiar with the thing :(
21:30:47 <jgt> I know basically nothing about mathematics; can someone help me understand the unintuitive (to me) behaviour above?
21:30:55 <dsal> PHP was super popular for a while.  I never figured out how to do anything in it.  It's pretty crazy.
21:31:09 <dsal> > (1.0e10 :: Double)
21:31:11 <lambdabot>  1.0e10
21:31:17 <DocKlobi> The unlearning is key. The tutorials never speak about it.
21:31:21 <jgt> shouldn't negative one with a single zero after the mantissa be the same as a negative one with a whole bunch of zeroes after the mantissa?
21:31:48 <c_wraith> "after the mantissa"?
21:31:56 <jgt> c_wraith: after the dot
21:31:59 <dramforever> jgt: You're talking about
21:32:00 <nshepperd2> 1.0e10 is 10 billion
21:32:09 <jgt> oh… right.
21:32:09 <dramforever> > (-1.0 :: Double) == -1.00000000000000000e10
21:32:11 <lambdabot>  False
21:32:17 <dramforever> > (-1.0 :: Double) == -1.00000000000000000
21:32:19 <lambdabot>  True
21:32:22 <c_wraith> jgt: things after the e are the exponent
21:32:36 <dramforever> *That* was bunch of zeros after the mantissa
21:32:46 <jgt> yeah, so it's exponents that I've misunderstood
21:32:49 <jgt> but I get it now
21:32:51 <jgt> thanks!
21:33:25 <DocKlobi> the tutorials are confusing. They do not teach you on how to do the "shift" ... from imperative to "functional" or even better categorical.
21:34:06 <nshepperd2> 1.0eX is just shorthand for 1.0 * 10^X
21:34:20 <dsal> DocKlobi: Don't learn that way.  HPFFP does a great job of not trying to build on your broken prior knowledge.  :)
21:34:20 <DocKlobi> all these "how to" samples are so f....ing superficial
21:34:22 <nshepperd2> it's nothing to do with exponents or mantissas or floating point
21:34:47 <jgt> nshepperd2: well it is _something_ to do with it when it comes to pretty-printing
21:35:06 <dramforever> DocKlobi: I mean, since you're supposed to unlearn imperative
21:35:28 <dramforever> What good could it be to bring it up again?
21:35:42 <jgt> for context, I'm trying to write a function for pretty-printing floating point numbers that potentially rounds to a maximum precision and drops trailing zeros
21:35:45 <jgt> here's what I have so far: http://ix.io/2iLG
21:35:53 <jgt> I'm _also_ trying to learn PBT at the same time
21:36:24 <nshepperd2> i suppose you can think of the notation as a textual **decimal** floating point format
21:36:51 <nshepperd2> but should you? i dunno
21:39:19 <dramforever> DocKlobi: How about this way: If I taught you how to convert imperative to functional, when you write Haskell you'll just think imperative then convert and write functional
21:39:30 <jgt> ok, so I think my final PBT is telling me that I am representing negative ten billion as "-1.0", which is quite wrong
21:40:20 <DocKlobi> dramforever: how?
21:40:55 <nitrix> Can that meta conversation move elsewhere, like #haskell-offtopic?
21:41:54 * jgt hopes it isn't his question which is off-topic
21:42:08 <dramforever> nitrix: can do
21:42:33 <DocKlobi> moving there
21:51:44 * hackage servant-docs-simple 0.1.0.0 - Generate documentation via TypeRep for Servant API  https://hackage.haskell.org/package/servant-docs-simple-0.1.0.0 (HolmuskTechTeam)
21:54:53 <jgt> how would you write the final property in this snippet? http://ix.io/2iLG
21:55:19 <jgt> it's failing because (-1.0e10) /= (-9.999999999999998e9), which I understand
21:55:28 <jgt> well, I _think_ I understand it
21:55:47 <jgt> I think the two numbers are only equivalent to a given level of precision
21:56:56 <jgt> should I say "lhs is equal to rhs when the precision of rhs is dialled down a bit"? If so, how?
21:57:18 <dramforever> Perhaps something like: disp - precision / 2 < actual < disp + precision / 2
21:57:23 <dramforever> With a bit of margin
21:58:06 <jgt> dramforever: does my approach sound reasonable in the first place? I'm worried it might be a bit of a dumb idea
21:58:16 <jgt> (unknown unknowns, etc)
21:58:33 <dramforever> what approach
21:58:56 <dramforever> Oh oh the one in your code
21:58:58 <jgt> "lhs is equal to rhs when the precision of rhs is dialled down a bit"
21:59:23 <dramforever> I think you can exactly quantify the 'a bit'
21:59:27 <jgt> this is my first time trying PBT
22:00:24 <dramforever> If we're doing rounding, 0.03 means 0.025 <= x < 0.035
22:00:46 <dramforever> I'm thinking about something like this
22:01:28 <jgt> oh! So I should try and express that lhs is within some range?
22:02:19 <dramforever> Yeah, basically that
22:02:39 <jgt> ok, that's helpful :)
22:02:40 <dramforever> Not sure how to put a margin for floating point error on that though
22:02:57 <jgt> not me either, but you've given me a good starting point
22:03:07 <jgt> in any case, time for lunch :)
22:03:17 <dramforever> Yeah, was thinking in terms of 'what does seeing a number in x decimal places mean'
22:13:57 <koz_> This may be of use: https://hackage.haskell.org/package/math-functions-0.3.3.0/docs/Numeric-MathFunctions-Comparison.html
22:17:03 <nero_> hello
22:30:05 <koz_> nero_: Hi!
22:33:19 <nitrix> I devised a quick term-rewrite system (https://ideone.com/dJmf3I). Does anyone know something similar, more fundamental maybe, I'm looking for some sort of lambda calculus eureka to see how far I can go with this thing.
22:34:47 <nitrix> I've never used term rewrite systems before ._.
23:13:48 <chew2> nitrix: that's pretty interesting
23:16:01 <chew2> it might be similar to prolog, but I'm not too familiar with that language
23:16:03 <nitrix> It's a shower thought but I don't really know where to go with it. I'm flailing "term rewrite" on search engines like it means something, hoping to have another eureka >_<
23:17:02 <chew2> is your code open source? I'd like to see if you don't mind
23:19:19 <nitrix> The implementation is incomplete because there are still cases that I don't know hey they'd get modeled. It's a very different paragdim, hence trying to read on the subject :/
23:20:27 <dramforever> This? https://en.wikipedia.org/wiki/Production_system_(computer_science)
23:21:08 <dramforever> I know nothing about it. I've basically just heard the name before.
23:21:15 <chew2> I'd be happy to see it incomplete too. But no worries otherwise
23:22:09 <nitrix> chew2: Understood, I'll let you know when things develops :)
23:22:29 <nitrix> dramforever: Fantastic, exactly the kind of reading I was after for tonight, very appreciated.
23:32:53 <frobnicator> nitrix: Clean is a functional language based on term rewriting
23:33:35 <frobnicator> especially in the older days when it was still an intermediate language for miranda it really exposed this fact to the user
23:34:35 <frobnicator> clean.cs.ru.nl
