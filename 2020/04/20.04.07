00:04:57 <jluttine> is there a command to just not do anything and stop. basically like "sleep infinite". dbus starts a thread that does the actual work and i just want to keep the main loop running without doing anything
00:05:28 <koz_> :t forever
00:05:31 <lambdabot> Applicative f => f a -> f b
00:05:34 <koz_> :t forever pure
00:05:37 <lambdabot> error:
00:05:37 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
00:05:37 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
00:05:42 <koz_> *snicker*
00:05:51 <koz_> :t forever pure :: IO ()
00:05:53 <lambdabot> error:
00:05:53 <lambdabot>     • Couldn't match expected type ‘IO a1’
00:05:53 <lambdabot>                   with actual type ‘a0 -> f0 a0’
00:06:15 <koz_> :t forever (pure :: IO ())
00:06:17 <lambdabot> error:
00:06:17 <lambdabot>     • Couldn't match expected type ‘IO ()’
00:06:17 <lambdabot>                   with actual type ‘a0 -> f0 a0’
00:06:25 <koz_> Oh wait derp.
00:06:32 <koz_> :t forever (pure ())
00:06:34 <lambdabot> Applicative f => f b
00:06:37 <koz_> There you go.
00:06:40 <koz_> Does nothing forever.
00:06:52 <tdammers> in a tight, CPU-slurping busy loop, no?
00:07:06 <jluttine> koz_: great, thanks! i knew about forever, but couldn't figure that out
00:07:25 <koz_> It's admittedly _not_ something you see very often.
00:07:36 <tdammers> forever (threadDelay 1000) -- something like this is what I'd do
00:07:42 <MarcelineVQ> ^ ditto
00:07:47 <koz_> tdammers: Yeah, that's _probably_ a better move.
00:07:52 <jluttine> koz_: that seems to take 100% cpu..
00:07:56 <koz_> But my solution fits the bill of 'do nothing forever'.
00:08:04 <koz_> jluttine: See what the smarter people in the room suggested.
00:08:06 <tdammers> 'heat the room forever'
00:08:10 <koz_> I'm just a dork posting silly memes.
00:08:11 <jluttine> koz_: :D
00:09:41 <jluttine> tdammers: probably better yes! though, in principle, it'd be nice to not even wait for some time but just not even do that.. but in practice, that's probably a good solution, and the delay can be a big number
00:11:03 <tdammers> jluttine: true, but you don't even need a very big number
00:11:31 <jluttine> tdammers: yep
00:11:49 <tdammers> the thread sleeps for (at least) 1 ms, then does work for maybe 5 CPU cycles, and then goes back to sleep
00:11:52 <MarcelineVQ> koz_: spaceheater = getNumProcessors >>= \c -> replicateM_ c (forkIO $ forever (pure()))
00:15:36 <jluttine> tdammers: yes, in practice that indeed is perfect. just still would be nice if there was some "correct" way which actually just waits forever without doing anything at all ever.
00:19:32 <MarcelineVQ> if my math is somewhat close you can pick about 290,000 years threadDelay length :>
00:20:11 <Nolrai> Couldn't you wait on a mvar?
00:26:20 <Eduard_Munteanu> Is there a Heat monad? For irreversible computations. :P
00:27:51 <tdammers> Nolrai: you have to be smarter than the RTS though, otherwise you get a "blocked indefinitely on an MVar" exception
00:28:45 <Nolrai> Ah, I mean presumably you are waiting for something...otherwise theres no point? Unless I am confused.
00:29:46 <tdammers> the problem is that when you just create an MVar and have one thread block on it, the RTS will detect that there are no other threads holding references to that MVar, so it cannot possibly ever un-block, and so it throws an exception on the waiting thread
00:30:18 <tdammers> because usually, a thread that blocks forever is a bug
00:31:03 <tdammers> so if you want to actually keep blocking, you have to have another thread that *could* write to the MVar, but never does
00:31:14 <tdammers> idk, you probably want to create some sort of deadlock situation
00:32:24 <Nolrai> I mean " dbus starts a thread that does the actual work and i just want to keep the main loop running without doing anything" you have that second thread hold the mvar..though I guess as its not a haskell thread... hmm.
00:33:02 <tdammers> I think the proper answer would be to somehow wait for the dbus thread from your main thread
00:33:48 <tdammers> failing all else, you could use a socket or fifo between the two threads and block on that
00:39:17 <pie_[bnc]> does anyone know anyone that might be interested in throwing some money at me for working on qt binding generation?
00:41:55 * hackage dobutokO2 0.24.5.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.24.5.0 (OleksandrZhabenko)
00:44:25 * hackage dobutokO2 0.24.6.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.24.6.0 (OleksandrZhabenko)
01:06:32 <jluttine> Nolrai: i'm not familiar with dbus nor haskell, so i don't really know. all i know is that addMatch in dbus library forks a thread that listens to dbus. i want it to listen forever, so my main thread shouldn't stop. perhaps there's some way to just wait for that other thread to finish in the main thread..
01:07:57 <Nolrai> That _should_ work using an mvar. I've not used them in 5+ years though.
01:08:50 <Nolrai> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent-MVar.html
01:12:42 <Fargle> as a mathematician who is semi-newly learning Haskell, I just wanted to say that this language is tight as hell
01:27:08 <Fargle> if I'm doing a typeclass inherited from another, and I make a type that's an instance of the child typeclass, do I have to separately make it an instance of the parent in order to use that function?
01:28:52 <Fargle> more precisely, if I have Class1 with Func1, and (Class1) => Class2 with Func2, and I define Data as an instance of Class2, it seems like I'm not allowed to define Func1
01:29:09 <__monty__> Fargle: It needs to be an instance of the parent class before you can even make it an instance of the child.
01:29:12 <merijn> Fargle: There is no inheritance
01:29:18 <Fargle> understood
01:29:19 <Fargle> thanks
01:29:39 <merijn> Fargle: The commonly used "subclass" and "superclass" are more like "prerequisites"
01:29:47 <Fargle> that makes perfect sense
01:29:58 <jluttine> uh, so many command-line argument parsers.. any recommendations..? https://wiki.haskell.org/Command_line_option_parsers
01:30:06 <merijn> jluttine: optparse-applicative
01:30:15 <__monty__> Fargle: Only place it "gives" you anything for free is as a constraint. If you constrain with a subclass you have access to superclass functions.
01:31:34 <merijn> jluttine: It's *slightly* more verbose than some of the others, but it scales well (i.e. as your commandline interface becomes more complex and bigger the overhead goes down and the extra power/flexibility really pays off)
01:32:03 <merijn> Although I don't really like the style it's readme uses for code :p
01:32:03 <jluttine> merijn: thanks, looks very promising!
01:32:07 <Fargle> yeah, I wasn't sure about which way it worked but it's all clear now
01:32:45 <Fargle> bored and quarantined so I'm trying to cook up a Factorio calculator in Haskell
01:46:50 <Fargle> another noob question: there doesn't seem to be a way to make a typeclass function that can possibly have different return types for different instances; am I right in this?
01:48:53 <Logio> Fargle: you need a type family for that
01:50:27 <Logio> https://wiki.haskell.org/GHC/Type_families
01:50:59 <lortabac> Fargle: you need a type family (or associated type synonym). Alternatively you can define a class with two parameters with a functional dependency
01:51:22 <Fargle> this looks like what I'm looking for, thanks
01:52:18 <Logio> are you making a calculator for the resource ratios?
01:52:33 <Fargle> that among other things
01:53:05 <Fargle> not just ratios for crafting, but things like smelting and such
01:53:15 <Logio> right
01:53:56 <Fargle> the way I was doing it was to have a typeclass for items, and then """"""""inherited""""""" ones for more specific varieties (like smeltable items, or fuel, or things that can assemble)
02:03:24 <siraben> I'm getting an impredicative polymorphism error in Haskell, how do I resolve it?
02:03:26 <siraben> http://ix.io/2h2s
02:04:04 <siraben> Tried moving it out to a newtype, still doesn't work.
02:19:30 <merijn> siraben: The short answer is: You can't
02:19:58 <merijn> I think there was work on impredicativy for 8.12, but it's not done, afaik
02:20:28 <merijn> There's -XImpredicativeTypes, but you should avoid that at all cost
02:20:38 <siraben> Ok, I seem to have fixed it with open recursion:
02:20:39 <siraben> http://ix.io/2h2z
02:21:00 <merijn> siraben: That'll probably work far better for now
02:21:29 <siraben> Which languages have impredicative polymorphism? Is it the dependently-typed ones? (Coq, Agda, etc.)
02:21:51 <merijn> I don't know, tbh
02:22:58 <siraben> Oof, now I have to go and fix all the type signatures for E because of the extra parameter.
02:23:22 <siraben> Well, at least it works. Hopefully it interacts will with polysemy, since m will be in the Sem monad
02:23:28 <siraben> s/will/well
02:27:23 <siraben> Yay, it works.
02:57:55 * hackage haskoin-node 0.9.17 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.17 (jprupp)
04:39:25 * hackage pandoc-plot 0.2.2.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.2.2.0 (LaurentRDC)
05:06:01 <maralorn> When ghc tells me "plus one Potential instance involving out of scope types" what can I do to make ghc show them to me? -fprint-potential-instances doesn't seem to suffice 
05:12:14 <phadej> Depending on how you look on it, Coq and Agda either have or do not have impredicative polymorhism. You can write code which would require ImpredicativeTypes in GHC in them, but their type systems are predicative. Yet you can enable TypeInType like things for them too, if you really need.
05:12:50 <phadej> siraben: if that doesn't make any sense to you, than steak to merijn's advice and avoid ImpredicativeTypes extension.
05:13:17 <siraben> phadej:  I see.
05:13:42 <siraben> Polysemy seems to give quite poor error messages when using open recursion to store effect computations, it seems.
05:13:53 <siraben> Or are the error messages poor in general?
05:14:45 <siraben> For instance; http://ix.io/2h38
05:14:48 <phadej> (disclaimer: I think polysemy have too much hype in it), but I guess it's later. polysemy is "too fancy".
05:15:25 <phadej> I wonder if polysemy-plugin helps with that or not.
05:15:26 <siraben> What effect libraries are pretty stable then?
05:15:35 <siraben> Heh, maybe I should have just stuck to MTL.
05:15:38 <phadej> MTL
05:15:42 <siraben> I believe polysemy-plugin is activated.
05:16:27 <phadej> also, `rio` approach is ok for 99% of use-cases
05:16:37 <siraben> The issue I was having the entire time with MTl was trying to compose effects for an interpreter, Cont over Except doesn't work.
05:16:44 <siraben> MTL*
05:16:46 <siraben> Rio approach?
05:16:49 <merijn> The problem with -XImpredicativeTypes is that it's "not even wrong"
05:17:11 <phadej> siraben: cont and except don't compose
05:17:21 <phadej> lawfully
05:17:21 <merijn> Like, no one can tell you whether GHC's current implementation of -XImpredicativeTypes is "correct", because no one has even figured out what it'd mean for it to be correct
05:17:30 <siraben> Oh, that explains it
05:17:31 <aviD> fused-effects is developed and used by github. It's really nice. Master has some breaking changes, that significantly reduce boiler plate.
05:17:54 <siraben> So I want to rewrite this in a monadic style; https://github.com/siraben/r5rs-denot/blob/master/src/SchemeEval.hs
05:17:55 <phadej> remember, "you are not github (netflix, amazon, facebook)" :)
05:18:11 <siraben> Currently it's in explicit store-passing continuation-passing style, from the formal semantics of Scheme
05:18:21 <siraben> avid:  Ah, I'll take a look.
05:18:41 <siraben> But if Except and Cont don't compose, then I presume they don't compose whatever effect library I'm using?
05:18:55 <phadej> I don't think fused-effects has Cont
05:19:27 <siraben> Or perhaps I'm taking the wrong approach. Should I be writing my own typeclasses for effects? Up to this point MTL has worked fine.
05:19:56 <phadej> MonadSchemeEval might be what you want, yes.
05:20:20 <siraben> So just ruthlessly fuse all the effects together?
05:20:51 <aviD> phadej: you forgot, Edward Kmett from the list ;)
05:21:43 <siraben> And later I have plans to embed IO, seems like writing a big monad would make things harder.
05:21:54 <siraben> Hm.
05:22:20 <aviD> From the readme "Unlike fused-effects, mtl provides a ContT monad transformer; however, it’s worth noting that many behaviours possible with delimited continuations (e.g. resumable exceptions) are directly encodable as effects."
05:22:58 <siraben> I don't need to full-blown power of ContT, just call/cc really, so that the language being interpreted can take hold of its own continuation.
05:29:35 <siraben> Looks like "Monad Transformers and Modular Interpreters" is all about this.
05:31:11 <phadej> call/cc captures complete continuation, not delimeted one.
05:32:21 <phadej> I say bonkers./
05:32:58 <siraben> So if I need the complete continuation, I'm forced to use ContT?
05:33:54 <phadej> I guess what I try to say, that "if you need raw call/cc the extensible effects libraries have nothing to give you. call/cc can let you encode most of the effects"
05:34:26 <phadej> It's too powerful effect, a bit like saying `MonadIO` - can do essentially anything
05:36:31 <siraben> Ah, I see.
05:37:05 <siraben> Makes sense, given that Cont can simulate the other (all?) monads.
05:37:37 <phadej> yes. That's my understanding.
05:38:22 <siraben> Hm. I see.
05:38:31 <phadej> at least you can simulate all the algebraic effects.
05:38:38 <phadej> I'm not sure you can simulate `catch`.
05:38:58 <phadej> maybe you can, by construction continuations you pass forward.
05:39:29 <siraben> What alternatives do I have instead of passing the store, environment and continuation explicitly?
05:40:13 <phadej> I don't think that if you interpret scheme, you have your ways around those
05:40:34 <phadej> if you want to have call/cc and set! - that what you end up with
05:40:37 <phadej> either way or another
05:41:06 <phadej> That's the "price" of operational primitives
05:41:09 <siraben> Ah.
05:41:47 <siraben> Would have liked to cleaned up the semantics monadically, heh. It's really Cont that makes it hard, otherwise everything else composes.
05:43:38 <phadej> another (to directly interpretting ast) way to interpret scheme is to compile to some kind of bytecode with stack and make call/cc capture the stack. You'll still have environments for closures and lambdas.
05:44:01 <phadej> But it feels to be a crazy exercise to reuse code from direct interpret for that too much
05:44:07 <phadej> intepretter*
05:46:23 <netwraith> hello everyone
05:51:37 <andinus> hi 0/
05:55:55 * hackage require 0.4.5 - Scrap your qualified import clutter  https://hackage.haskell.org/package/require-0.4.5 (NickSeagull)
05:57:25 * hackage require 0.4.6 - Scrap your qualified import clutter  https://hackage.haskell.org/package/require-0.4.6 (NickSeagull)
05:58:25 * hackage sexpresso 1.1.0.0 - A flexible library for parsing and printing S-expression  https://hackage.haskell.org/package/sexpresso-1.1.0.0 (VincentArchambault)
06:26:55 * hackage haskoin-node 0.9.18 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.18 (jprupp)
06:32:42 <hseg> hi. ghc complains that DerivingVia makes no sense with associated types
06:33:23 <hseg> any way to engineer around this?
06:34:35 <infinity0> i'm trying to write something like "data T a = T a; data S c a = S (T (c => a))" and GHC is complaining about impredicative types, is there a way around this like with forall-functions where you wrap it inside a newtype/record?
06:35:10 <hseg> what I'm doing: have classes Group and Unital, where Unital a witnesses the fact that I have some type Units a embedding into a which is a Group instance 
06:35:14 <merijn> hseg: Associated types are just type families, so there is indeed no sense in derivingvia
06:35:58 <hseg> merijn: right, so i'm probably misengineering
06:36:03 <merijn> hseg: Like, I'm not really sure how you'd even try to use DerivingVia with that
06:38:31 <hseg> well, naive understanding was that derivingvia would create isomorphic copies of the data instances from the original
06:38:58 <merijn> hseg: Note that "associated types" are just some convenience sugar for type families, you are *not* defining a new type, you are defining a type family (i.e. type level function) that maps 1 (or more) types to another type
06:40:17 <hseg> was using data families, these are generative, aren't they?
06:40:40 <hseg> btw, note that in some cases GND does work with assoc'd types
06:40:59 <merijn> hseg: What's the code that fails to compile look like? You're trying to DerivingVia a class that has an associated data family?
06:41:10 <hseg> yep
06:41:42 <merijn> That requires GHC to invent a new data family from scratch and I don't see a sensible way to do that
06:42:36 <hseg> hrm. reading through when GND works with assoc'd types
06:43:03 <hseg> possibly can drop the generativity and gain GND
06:43:20 <hseg> (reading https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-type-families)
06:44:53 <infinity0> gah, the frustrating thing is "S (T (c -> a))" doesn't trigger the impredicative types error, i don't suppose there is a way to convert (c => a) into (c -> a) like how you can sort of do with singular?
06:47:31 <hseg> hrm. type famliies might make more sense anyway
06:48:25 * hackage haskoin-node 0.9.19 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.19 (jprupp)
06:56:09 <hseg> so annoying that i can't derive Applicative for what basically amounts to type-level tags (n phantom params, 1 representational param at end, and a newtype at that)
07:01:38 <hseg> ok, type families changed my problem
07:01:59 <hseg> The type family application ‘Unit (Proj "PlusMinus1" Z)’ is no smaller than the instance head ‘Unit Integer’
07:04:01 <hseg> nm, enabling UndecidableInstances gives me back me old error
07:09:25 <hseg> actually, situation is worse - have class U, class U => S, instance S' => U, instance S' => S. GHC complains at that last declaration, saying it can't deduce the U constraint
07:10:36 <hseg> intended meaning was for U,S to use the S' structure to define their own, and that requiring an S constraint would pull in a U constraint
07:12:19 <hseg> maybe if i make U+S a single class?
07:16:24 * hackage openweathermap 0.1.0 - Access data at OpenWeatherMap  https://hackage.haskell.org/package/openweathermap-0.1.0 (ip1981)
07:21:14 <chr0n1c> You are invited to take part in an important scientific lecture and chat with Dr Gamme Martin @ irc.butt.es #GAMME
07:33:33 <frdg> How do I configure GHCi to give error messages? When I make it mistake it only says "error". Im on Mac OS 
07:36:32 <matheus23_> does anyone have any links or further information about combining two f-algebras a :: F a -> a, b :: F b -> b into an f-algebra that folds both at the same time, e.g. ab :: F (a, b) -> (a, b). I feel tuples are chosen quite arbitrarily. Isn't an f-algebra a (endo?)profunctor, so could some info on profunctors help me?
07:39:18 <kayvan`> join #emacs
07:41:29 <tabaqui1> can anyone help me a little with singletons library?
07:41:31 <tabaqui1> https://gist.github.com/boris-stepanov/d332e91d76b2e5711bdae1dcb7056bfa
07:42:06 <tabaqui1> I can't extract type-level string with TypeApplications or ScopedTypeVariables
07:42:42 <tabaqui1> though, I could do it with sFromJust function, but it is unsafe
07:52:52 <tabaqui1> huh, it's funny
07:52:59 <tabaqui1> If I try something like:
07:53:23 <tabaqui1> instance Show (Foo ('Just s)) where Foo SNothing = ...
07:53:58 <tabaqui1> GHC doesn't treat this as an error, but as a warning Winaccessible-code
07:55:53 <tabaqui1> yeah, and the main problem is solved - one shouldn't use types, but singletons
08:07:07 <dmwit> matheus23_: I guess something like `\fab -> (a (fst <$> fab), b (snd <$> fab))`
08:08:16 <Uniaika> I was wondering: Is there an article somewhere about the state of the art of concurrency in Haskell? I see forkIO, async and co. frequently used, but should I make a basic concurrent network server using green threads (GHC sparks?), what should I use?
08:08:26 <matheus23_> dmwit: yeah I see how that's possible. I was hoping for some DSL that allows me to combine many reductions into one with a more meaningful choice than (,)
08:09:04 <matheus23_> I want to know whether the exact properties that are needed from (,) form some kind of structure, so that other things than only (,) might be used
08:09:25 <dmwit> `Algebra f` is probably Applicative.
08:09:40 <glguy> Uniaika: forkIO is green threads. You can't do IO with sparks, so that won't help. async is a library wrapper around forkIO
08:10:33 <dmwit> % newtype Algebra f a = Algebra (f a -> a)
08:10:34 <yahb> dmwit: 
08:10:48 <matheus23_> dmwit: I thought so too, unfortunately, it isn't, because a appears on the contravariant side
08:12:34 <dmwit> Oh, yeah, I want the co- version of Applicative.
08:12:52 <dmwit> Divisible or something?
08:13:34 <maralorn> So  (a, b) is to Either a b the same as (a, b,  c) to ? 
08:13:54 <dmwit> We don't have standardized types for sums bigger than 2.
08:14:19 <maralorn> Is there a better way to constructing adhoc sums than nesting eithers?
08:14:49 <dmwit> Nope. Declare a new data type is your alternative.
08:17:34 <maralorn> dmwit: okay, thank you 
08:17:40 <dmwit> matheus23_: Okay, Divisible isn't it either, hah!
08:17:52 <matheus23_> yeah it somehow has to be both at the same time
08:17:52 <dmwit> matheus23_: I'm not expert enough yet to answer you, it seems.
08:18:25 <matheus23_> if you're curious, I'm pretty sure there exists instance Functor f => Profunctor (Algebra f)
08:18:54 <matheus23_> oh no. not quite, the kinds don't match up. But Endoprofunctor, if something like that exists
08:19:02 <dmwit> Of, for something like `newtype Algebra f a b = Algebra (f a -> b)` or something?
08:19:45 <dmwit> https://hackage.haskell.org/package/comonad-5.0.6/docs/Control-Comonad.html#t:Cokleisli gives that instance
08:20:22 <Uniaika> glguy: oh, neat! 
08:20:28 <dmwit> Well. I don't know if that module has the instance. But the documentation for lens claims that type has a profunctor instance.
08:20:41 <matheus23_> dmwit: yeah I think that one fits
08:32:55 * hackage haskoin-node 0.9.20 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.20 (jprupp)
08:34:25 * hackage tar-bytestring 0.6.3.2 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.3.2 (maerwald)
09:28:42 <zeta_0> hello everyone, is a there a good free elm book that i can download that covers the newest elm version(0.19.1) ?
09:29:17 <glguy> zeta_0: wrong channel
09:31:43 <zeta_0> glguy: i figured i'd ask here because elm is a functional language, anyways, i already asked this question in #elm and ##javascript, so i'm waiting a response
09:37:25 * hackage smash 0.1.1.0 - Smash products - like 'These', but with a unit!  https://hackage.haskell.org/package/smash-0.1.1.0 (topos)
09:38:55 * hackage launchdarkly-server-sdk 1.0.4 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-1.0.4 (launchdarkly)
09:38:57 * hackage haskell-gi 0.23.1 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.23.1 (inaki)
09:39:01 * hackage pandoc-plot 0.2.2.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.2.2.0 (LaurentRDC)
09:39:02 * hackage haddock-library 1.9.0, haddock-api 2.24.0, haddock 2.24.0 (harpocrates): https://qbin.io/sharp-was-pqye
09:39:04 * hackage tracing 0.0.5.1, tracing 0.0.5.0 (mtth): https://qbin.io/india-womens-5zj1
09:39:06 * hackage bioinformatics-toolkit 0.9.3.1, bioinformatics-toolkit 0.9.3 (kaizhang): https://qbin.io/report-clocks-75z9
09:39:08 * hackage pagure-cli 0.2 - Pagure client  https://hackage.haskell.org/package/pagure-cli-0.2 (JensPetersen)
09:39:09 * hackage require 0.4.6, require 0.4.5 (NickSeagull): https://qbin.io/lyrics-breath-c87j
09:39:12 * hackage ngx-export-tools-extra 0.4.1.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.4.1.0 (lyokha)
09:39:13 * hackage haskoin-node 0.9.20, haskoin-node 0.9.19, haskoin-node 0.9.18, haskoin-node 0.9.17 (jprupp)
09:39:15 * hackage hgeometry-ipe 0.10.0.0 - Reading and Writing ipe7 files.  https://hackage.haskell.org/package/hgeometry-ipe-0.10.0.0 (FrankStaals)
09:39:18 * hackage hadoop-streaming 0.2.0.2 - A simple Hadoop streaming library  https://hackage.haskell.org/package/hadoop-streaming-0.2.0.2 (zliu41)
09:39:20 * hackage hackage-security 0.6.0.1 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.6.0.1 (HerbertValerioRiedel)
09:39:22 * hackage openweathermap 0.1.0 - Access data at OpenWeatherMap  https://hackage.haskell.org/package/openweathermap-0.1.0 (ip1981)
09:39:24 * hackage threadscope 0.2.13, ghc-trace-events 0.1.0.1 (MitsutoshiAoe): https://qbin.io/bikini-loaded-3y57
09:39:26 * hackage configuration-tools 0.5.0 - Tools for specifying and parsing configurations  https://hackage.haskell.org/package/configuration-tools-0.5.0 (fosskers)
09:39:27 * hackage lorentz 0.2.0, morley 1.1.0 (gromak): https://qbin.io/oval-duck-jtwl
09:39:29 * hackage musicScroll 0.2.3.2, musicScroll 0.2.3.1 (RubenAstudillo): https://qbin.io/walks-kits-z9c1
09:39:31 * hackage vault 0.3.1.4 - a persistent store for values of arbitrary types  https://hackage.haskell.org/package/vault-0.3.1.4 (sjakobi)
09:39:33 * hackage web-rep 0.3.2 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.3.2 (tonyday567)
09:39:35 * hackage sak 0.1.2.0 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.2.0 (vmchale)
09:39:38 * hackage tar-bytestring 0.6.3.2 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.3.2 (maerwald)
09:39:39 <dmwit> hm... this bot
09:39:40 * hackage sexpresso 1.1.0.0 - A flexible library for parsing and printing S-expression  https://hackage.haskell.org/package/sexpresso-1.1.0.0 (VincentArchambault)
09:39:42 * hackage dobutokO2 0.24.6.0, dobutokO2 0.24.5.0, dobutokO2 0.24.4.0, dobutokO2 0.24.3.0, dobutokO2 0.24.2.0 (OleksandrZhabenko)
09:39:44 * hackage extrapolate 0.4.2 - generalize counter-examples of test properties  https://hackage.haskell.org/package/extrapolate-0.4.2 (rudymatela)
09:39:47 * hackage deriving-aeson 0.2.3 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2.3 (FumiakiKinoshita)
09:39:49 * hackage haskell-say 1.0.0.0 - Let the Haskell logo talk to your users!  https://hackage.haskell.org/package/haskell-say-1.0.0.0 (DrewHaven)
09:39:52 * hackage th-lift-instances 0.1.15 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.15 (BennoFuenfstueck)
09:39:53 * hackage lens-csv 0.1.1.0 -   https://hackage.haskell.org/package/lens-csv-0.1.1.0 (ChrisPenner)
09:39:56 * hackage hslua-module-doclayout 0.1.0 - Lua module wrapping Text.DocLayout.  https://hackage.haskell.org/package/hslua-module-doclayout-0.1.0 (tarleb)
09:39:57 * hackage smash 0.1.1.0, smash 0.1.0.0 (topos): https://qbin.io/rage-mb-03ei
09:40:21 <ziman> these versions seem to have been announced already
09:44:25 * hackage smash-aeson 0.1.0.0 - Aeson support for the smash library  https://hackage.haskell.org/package/smash-aeson-0.1.0.0 (topos)
09:45:13 <sm[m]> mniip ^ bot trouble
09:48:55 * hackage smash-lens 0.1.0.0 - Optics for the `smash` library  https://hackage.haskell.org/package/smash-lens-0.1.0.0 (topos)
09:49:11 <dsal> @tell zeta_0 to look at https://elm-lang.org/docs
09:49:12 <lambdabot> Consider it noted.
09:50:16 <topos> #productivity
09:50:25 * hackage smash-microlens 0.1.0.0 - Optics for the `smash` library  https://hackage.haskell.org/package/smash-microlens-0.1.0.0 (topos)
09:55:40 <frdg> is property testing the best kind of testing in Haskell?
09:55:56 <dsal> s/Haskell/general/
09:56:20 <dsal> It's not always the right thing, but where you can do it, it's pretty awesome.
09:56:24 * hackage haskoin-node 0.9.21 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.21 (jprupp)
09:57:06 <frdg> dsal: thanks for the answer!
09:57:17 <monochrom> Proving is the best kind of testing. A proof is worth a thousand tests.
09:57:50 <monochrom> Unless you cite "but most people can't do it". Goes a long way to show what "best" means.
09:59:04 <frdg> monochrom: is this a major reason you believe strongly in understanding abstract math concepts?
09:59:13 <dsal> property testing is poor man's proofs
10:01:36 <monochrom> Indirectly. Even when you aren't proving, you still have some looser reasoning of why you design your code your way. Abstract math concepts inform those designs and those reasons. Those reasons can be refined to proofs, if you feel like going that last mile, though usually it's OK not to.
10:01:43 <amf> i'd love to see some proofs for dummies literature (especially for those that run in IO), all i know is TLA+ and alloy
10:02:44 <monochrom> There is a "Logic for Dummies" book.  I'm not kidding.  And I took a look and found it pretty decent.
10:02:46 <dsal> amf: https://plfa.github.io/ ?
10:03:25 <dsal> I still need to actually grok tla+.  I've never been able to make use of it.
10:03:48 <dsal> I tried alloy once, but it failed to run on my computer.
10:05:49 <frdg> monochrom: interesting. I am planning on getting deep into math. I can't imagine how cool it is to incorporate mathematical concepts into programs, and I am sure that Haskell is as a good a tool as there is for it.
10:05:55 <monochrom> If you don't have crazy concurrency and crazy shared variables, you don't need most of TLA+, maybe you just need the sequential fragment of it, but then you may as well just use my supervisor's book: http://www.cs.toronto.edu/~hehner/aPToP/
10:07:01 <monochrom> alloy : imperative programming :: smallcheck : functional programming
10:07:17 <dsal> Oh that makes sense.
10:07:48 <dsal> I have distributed systems with complicated interactions.  I feel like I could benefit from it, but describing the complicated system seems... complicated.
10:08:14 <monochrom> Oh, then TLA+ is right on.
10:08:55 <monochrom> Lamport is a distributed computing guy.  (I guess hybrid concurrency+distributed, at his level no need to draw a line.:)
10:10:33 <monochrom> I think TLA+ is fairly faithful to how simple or complicated your program really is.
10:11:45 <dsal> Part of the problem is that I don't completely understand what they're doing over there.  :)
10:12:23 <monochrom> OK! Yeah it takes a while to see what Lamport and TLA+ are doing and why.
10:13:33 <monochrom> The "temporal part" (generally any temporal logic) is also interesting but wacky at first.
10:17:48 <dsal> Heh, no, I meant the people working on the system I'm concerned about.  I was hoping to use it both to prove and document a system I interact with, but don't necessarily work on.  It seems that learning TLA+ in order to learn another system is a bit uphill.
10:18:16 <dsal> TLA+ isn't *super* confusing, but there's still a gap between anything I'm doing and what I understand about it.
10:23:41 <dsal> Thanks for the book link.
10:34:55 * hackage front 0.0.0.7 - A reactive frontend web framework  https://hackage.haskell.org/package/front-0.0.0.7 (swamp_agr)
11:33:58 <shapr> I'm setting up a company internal hoogle server. The haddocks link to file:/// URLs. Is there some way to serve up haddocks via the local hoogle server?
11:50:54 <solonarv> shapr: hmm, I think there is some sort of "base URL" flag you can pass to haddock
11:51:08 <solonarv> that is probably how hackage.haskell.org does it too
11:51:44 <shapr> solonarv: thanks, I'll try that
12:01:25 * hackage gscholar-rss 0.2.5.0 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.5.0 (fffaaa)
12:17:26 <zeta_0> dsal: thanks, i just got your message, with the elm-lang docs and this beginning elm online book that i found, i should be good to go
12:18:03 <aveltras> is there a way to solve this ?
12:18:08 <aveltras> https://www.irccloud.com/pastebin/ppp7r6B3/
12:18:30 <koz_> :t pure
12:18:33 <lambdabot> Applicative f => a -> f a
12:18:47 <koz_> You can fmap pure over your Map.
12:20:54 <aveltras> koz_: not sure where to put the pure here, here is the situation
12:20:57 <aveltras> https://www.irccloud.com/pastebin/71LExvzJ/
12:21:22 <koz_> aveltras: On the value.
12:21:41 <koz_> Map.singleton takes a key and a value: your value needs to be wrapped in pure.
12:22:12 <koz_> Although looking at it closer, hmmm.
12:24:02 <koz_> Where do you get the MediaType to look up the resp -> LByteString function in (=$)?
12:24:17 <aveltras> this is for a web request handler thing
12:24:22 <koz_> Since according to what you posted, toByteString returns a map whose values are functions.
12:24:33 <aveltras> i've defined response types with a typeclasse and each instance declares what media types it supports
12:24:51 <aveltras> the end goal here is to be able to know if the handler supports the media type before running it
12:25:11 <koz_> Sure, but in order for you to do the resp -> LByteString conversion, you need a MediaType to feed to the map.
12:25:39 <koz_> Since otherwise, how can you figure out what function you need to get from resp to LByteString?
12:25:43 <koz_> Something's really not clear here.
12:25:59 <aveltras> having a wai request
12:26:12 <aveltras> i can determine a http verb and an accept media type
12:27:33 <aveltras> the goal is to have a ready to use map of handlers here
12:27:52 <aveltras> the media type comes from a wai request parsed header
12:28:37 <koz_> That's all good, but fact of the matter is, 'toByteString :: Map MediaType (resp -> LByteString)' according to what you posted.
12:28:48 <koz_> You have a 'resp' in 'RIO env'.
12:29:02 <koz_> What you _want_ is an 'LByteString' in 'RIO env'.
12:29:06 <aveltras> yes
12:29:39 <aveltras> i mean no
12:29:59 <aveltras> i ll build a complete example, maybe that s not possible but let me show you what i have in mind
12:30:11 <koz_> That could help, because I'm 100% sure I'm missing some context here.
12:33:47 <aveltras> i have something like this
12:33:51 <aveltras> https://www.irccloud.com/pastebin/onf2rFzK/
12:34:03 <aveltras> what's imporatnt here is the "dispatcher" method
12:34:23 <pounce> hum, why did n+k patterns get removed
12:34:51 <aveltras> both View and Xhr are instances of the Response class which can (maybe) be transformed to bytestring
12:36:29 <aveltras> i'd like to map the acceptability of the response type over the handler (not sure this should be said like this :) )
12:37:12 <koz_> Ah, OK, I think I see.
12:37:31 <aveltras> since when i register handlers via =$, the response type is known from the signature and i can infer the media map from the response instance
12:37:55 * hackage data-fix 0.2.1 - Fixpoint data types  https://hackage.haskell.org/package/data-fix-0.2.1 (AntonKholomiov)
12:38:00 <koz_> Basically what you need is 'RIO env resp -> Map MediaType (resp -> LByteString) -> Map MediaType (RIO env LByteString)', right?
12:38:17 <aveltras> ye, the type of the dispatcher method
12:39:08 <aveltras> hmm wait
12:39:24 <aveltras> the function that would suit here is
12:39:25 * hackage configurator-pg 0.2.2 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.2.2 (vollmert)
12:39:27 <aveltras> https://www.irccloud.com/pastebin/mYkdjSpi/
12:39:33 <aveltras> if i can get it to typecheck
12:39:41 <koz_> Yes, but to get there, you need that thing I just said.
12:39:47 <koz_> Everything else is just scaffolding around that core idea.
12:39:53 <koz_> This is your typechecking issue.
12:40:01 <koz_> I've deliberately narrowed it down to avoid the noise.
12:40:07 <koz_> And hopefully to show you how to write it.
12:40:11 <aveltras> ye right sorry you re righ
12:40:13 <koz_> If you're still not sure, I can guide you further.
12:49:10 <aveltras> got this to typecheck :)
12:49:13 <aveltras> https://www.irccloud.com/pastebin/RknMc475/
12:49:36 <aveltras> koz_: thanks for your help
12:55:55 * hackage rib 0.8.0.0 - Static site generator using Shake  https://hackage.haskell.org/package/rib-0.8.0.0 (sridca)
12:56:01 <koz_> aveltras: No worries.
12:56:55 * hackage haskoin-store 0.20.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.20.1 (jprupp)
13:38:57 <ystael> Is there a way to tell stack to pull in a repo on my local machine, named by directory, as an extra-dep, without specifying a commit, because I just want it to build whatever is there? I am completely aware that this is not a reproducible build; since I am working on a library and its user at the same time, I want this and do not care that it is not reproducible.
13:39:57 <ystael> I cannot find any way to spell "yeah just treat this directory as a package source" in the Pantry docs.
13:41:23 <dsal> ystael: You can list an extra dep like:   - ../some/path
13:41:44 * dsal is doing exactly the same thing right now
13:42:17 <ystael> ah, wonderful, thank you! Did I miss this, or is it actually not there in the doc?
13:45:17 <frdg> property testing question https://pastebin.com/ZWmPrLms
13:46:27 <dsal> ystael: I don't remember.  I figured it out at some point in the past. heh
13:53:03 <lyxia> frdg: what's the error you're running into
13:53:22 <frdg> lyxia: one moment
13:53:51 <lyxia> frdg: it should just be     data Orderable =    without parameters on the left of =
13:55:38 <lyxia> frdg: do you want to generate lists whose elements can be any of these three types at the same time, or only lists of ints, or lists of strings, or lists of chars?
13:56:18 <frdg> lyxia: I only want to generate list of strings, or lists of chars, or lists of ints
13:58:49 <dsal> Then you want it to be a list, not a single value.
13:59:09 <monochrom> Then keep [Int], [Char], [String] separate.
14:00:08 <dsal> All lists of arbitraries are already implemented, though.  Reducing the space may not be helpful.  For that type of thing, I usually just make a test that works with any type, and then I have a separate invocation for each type.
14:00:49 <frdg> dsal: ya I think that makes more sense and I was able to accomplish that. For fun I guess im trying to do it the hard way
14:01:00 <dsal> e.g.    testProperty "withStrings" (testSort :: [String] -> Property)
14:01:54 <dsal> I'm not sure it's "the hard way."  It's just a sort of longer way that doesn't get you as far.  Your Arbitrary instance doesn't allow for shrinking, for example.
14:02:29 <frdg> dsal: ok I see thanks
14:04:07 <dsal> i.e., consider the properties before the generators.  If you need a generator (and you likely will eventually), you can make one.  There are already generators for all those types, though.  Instead of making new types with tags and arbitraries with tags and a property to take apart the tags and do the thing, you can just make the function that works with any `Ord` and throw a variety at it.
14:38:03 <koz_> Yeah, what dsal says makes sense. If you have 'internal invariants', you shouldn't be using a 'bare' type in any case.
14:38:10 <koz_> (c.f. [a] versus NonEmpty a)
15:06:16 <operand> Hi, I would like to know a few things related to the performance of Haskell
15:06:23 <koz_> operand: Try us.
15:07:08 <operand> I've got a potentially very large data structure which is returned by a function. In essence, a trie constituting all programs of a certain size. The point is to use this datastructure with QuickCheck to verify some properties
15:07:24 <operand> So I'd like to extract many random values from this datastructure
15:07:46 <operand> And I was wondering what an efficient way to do that is
15:08:00 <koz_> What's your trie keyed by? Is the structure lazy? If so, in what way?
15:08:24 <monochrom> tree? trie?
15:08:42 <hpc> true
15:09:26 <monochrom> But a trie is a tree so at each node throw a die to choose one of: go to a randomly chosen child, stop here.
15:09:47 <koz_> monochrom: The internal node may not correspond to any specific entry.
15:09:56 <koz_> So you can't _always_ stop there, but the idea works.
15:10:37 <monochrom> If it's conceptually a key-value dictionary, then it has n key-value pairs, so randomly choose from {0, 1, ..., n-1}.
15:11:03 <monochrom> Unless you say you must also randomly choose a key that has no value in the trie.
15:11:50 <Finley> Hi everyone, a library I'm using recently updated from using GHC 8.6.5 to GHC 8.8.2. They implement a GHC compiler plugin that compiles the top-level binding expressions to another intermediate language. Their update from 8.6.5 to 8.8.2 changed the a small thing in their compiler plugin, and it seems to be causing issues for me. Anybody here think
15:11:51 <Finley> they could assist me with this?
15:12:02 <monochrom> If it's very large, buy more RAM. shapr did that recently. Like 0.5TB of RAM. and his is a "laptop" too.
15:12:02 <operand> Sorry, I'm having some GPU stability issues so I had to reboot for a sec
15:12:27 <monochrom> (My last line is half joking!)
15:13:27 <hpc> @quote bug.cost.me
15:13:27 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
15:13:27 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
15:13:35 <operand> I'm not sure 'trie' is exactly the right word, maybe. The idea is to construct (functional) programs based on their prefix.
15:13:38 <monochrom> Anyway shapr's laptop is like a union of gaming laptop and heavy-duty server cramp into a laptop form factor :)
15:13:54 <koz_> operand: Unless you know what your data structure is, any and all performance discussions are moot.
15:13:55 <operand> The structure is, I think, hopefully, fully lazy though.
15:14:10 <koz_> I can't even describe its behaviour _theoretically_, much less in the context of GHC.
15:14:15 <monochrom> That's a trie, yeah, just an unusal application of.
15:14:50 <mniip> I mean uhh
15:14:50 <monochrom> Well, I taught trie to my students as a dictionary, so that's "usual" for me, but of course there are other uses.
15:15:01 <mniip> just make a 256GB swapfile on an SSD
15:15:04 <hpc> random traversal of the trie seems like the best bet, imo
15:15:19 <hpc> instead of trying to pick a random leaf node
15:15:26 <operand> Yea, 'tries' is a thing they skipped in my datastructures class for whatever reason
15:15:54 <operand> So my concept of this datastructure specifically is fairly good, though my concept of its position in the landscape of datastructures is a bit shakey
15:15:58 <monochrom> I know that the most common reason for a teacher to omit a topic is "ran out of time" :)
15:16:28 <koz_> Tries are also rather special-purpose, barring certain optimizations or tiny alphabets.
15:16:38 <koz_> So skipping them is reasonably justifiable.
15:16:39 <mniip> monochrom, a 512GB laptop?
15:16:48 <mniip> I don't think they make 128GB sticks in SODIMM form?
15:16:52 <hpc> it's biased for elements closer to the root (which translates to smaller test cases), and depending on the statistical properties of your trie it might be fine for it to be infinite too
15:16:54 <monochrom> And the 2nd most common: "it looks like you people are already failing the course even with the easier topics already"
15:17:33 <operand> hmm, that might be true, considering it is one of the more difficult classes in the first year :P
15:17:35 <monochrom> mniip: I am sure I was exaggerating. But it really is a server-level amount of RAM, and likewise for core count and CPU choice.
15:17:54 <mniip> xeon?
15:18:09 <monochrom> I think so.  didn't bother to remember details.
15:18:42 <shapr> yes, six Xeon cores
15:19:33 <shapr> mniip: 128GB ram
15:19:48 <monochrom> fake news: GHC nightly CI and cabal nightly CI are sent over cellphone network to shapr's laptop to be done. >:)
15:19:54 <shapr> :-P
15:20:20 <hpc> the real fake new is it doesn't even have linux installed, it boots into xen
15:20:23 <shapr> My new work laptop has 32GB of RAM and 8 i9(?) cores, it feels rather pitiful.
15:20:40 <operand> You guys are making me feel bad about my new PC i built last week v:
15:20:46 <koz_> operand: Don't take it too seriously.
15:20:54 <operand> I was joking too, don't worry :p
15:20:58 <mniip> I also have 32 and 8 i9 cores
15:21:06 <mniip> (16 logical)
15:21:23 <monochrom> "I mean, God, how do people live without an infinity RAM?"  >:)  (Today's smbc)
15:21:24 <shapr> I honestly don't use the RAM that often :-/
15:21:31 <koz_> 6 physical, 12 logical here.
15:21:36 <mniip> there are cases where I'd need ~20GB for work
15:21:38 <operand> Same, 6 physical 12 logical
15:21:47 <mniip> if for some odd reason I'd needed to compile with optimizations
15:21:56 <shapr> I tried a bunch of GHC options to feed it all the RAM it could possibly want, but cache size ended up being the limiting factor due to latency.
15:22:29 <monochrom> yikees
15:22:30 <operand> i once accidentally tried to build GHC on my 8GB laptop, and it went OOM but just barely.
15:22:37 <operand> managed to compile it by shutting down Plasma first
15:22:51 <mniip> uh, I've built GHC on smaller machines
15:22:55 <hpc> i remember building ghc on a 1 gig laptop
15:23:00 <mniip> thread carefully :P
15:23:06 <jle`> i remember building ghc with my bare hands
15:23:09 <wildtrees[m]> I think  I compiled ghc years ago on something with only 4 gigs 
15:23:10 <operand> I will fully admit that I had absolutely no idea what I was doing
15:23:17 <hpc> jle`: in a cave with a box of scrap?
15:23:17 <operand> I was barely even aware I was building GHC
15:23:39 <jle`> hpc: you wrote what i should have thought to D:
15:23:48 <shapr> This laptop has six mobile Xeon cores (no avx-512 :-( ), 128GB RAM, 4k touch screen, 3TB of storage (with a space for 4TB more) and six hours of battery if I'm careful, and one hour of heavy compile.
15:23:59 <mniip> once you got 4k you never go back
15:24:13 <hpc> shapr: that one hour, is that on battery power or with the ac adapter helping it out?
15:24:20 <shapr> hpc: that's on battery power
15:24:21 <monochrom> hahaha
15:24:22 <jle`> can't you just extend your laptop with cloud ram from amazon
15:24:32 <shapr> jle`: is that really a thing?
15:24:40 <evelyn> won't 4k on laptop make everything really small?
15:24:45 <shapr> evelyn: yes, very much so
15:24:54 <mniip> evelyn, you tell programs to scale it back up
15:24:58 <hpc> evelyn: you bump the dpi value in your desktop environment
15:25:03 <hpc> it works with pretty much everything
15:25:03 <jle`> shapr: i hope not heh, otherwise everything i know about how memory/io works is wrong
15:25:18 <mniip> I love the  s m o o t h  text and I'm not going back
15:25:25 <jle`> AWS doesn't provide cloud ram, only a cloud LRU cache
15:25:33 <operand> making things small is nice up to a point
15:25:33 <shapr> My major motivation was to be able to do useful programming work entirely without an internet connection. The big drawback is that the battery life is small, and when I have power I usually have internet.
15:25:39 <hpc> mniip: forget the smooth text, not having 700 vertical pixels to work with on a laptop is huge
15:25:40 <operand> upgraded to a 1440p monitor recently and it owns
15:25:43 <evelyn> on gnome it's either 100% or 200% scaling as far as i can tell
15:25:45 <hpc> laptop 4k is the best 4k imo
15:25:52 <evelyn> there doesn't seem to be anything in between
15:26:13 <jle`> pretty much all my haskell dev i do on the linux server i share rackspace with (with in my bedroom), and i ssh onto it from my dinky laptop
15:26:50 <shapr> evelyn: I haven't figured out how to do different scaling per screen, so text on external monitors is too large.
15:27:22 <shapr> jle`: I can see the advantage, but I tend to move around a bunch. I spent six months this past year in Brooklyn at Recurse Center.
15:27:48 <monochrom> I like that name!
15:27:49 <b0nn> hrm, not sure if this is helpful, but I use tmux inside a terminal, and vim is my editor, I can resize panes on a whim
15:27:57 <jle`> that's fair. i use a dns so i can deal with changing ip addresses but that can only go so far
15:28:48 <jle`> also it's sort of a pain to move because i am not very good with wire management ... i have a bunch of sata's snaking out of it to my RAID rack
15:29:11 <shapr> ooh, I want pix now :-)
15:29:51 <shapr> Also, this laptop is 15", so not really large enough to quickly dissipate heat from six Xeons, I burned myself thoroughly one summer.
15:30:41 <mniip> pfft, I have a scar on my arm from sleeping with a laptop
15:30:49 <shapr> I'm sure I'll buy the 256GB RAM ThinkPad when it's released.
15:30:53 <Rembane> mniip: Why did you have sex with a laptop? :O
15:30:58 <shapr> mniip: impressive :-)
15:31:20 <mniip> like, it's permanent pretty much. it happened like 7 years ago
15:35:45 <shapr> b0nn: I use byobu cause I got tired of configuring screen/tmux
15:36:25 <Rembane> shapr: What do you miss the most in byobu?
15:37:14 <shapr> Rembane: I don't understand? I do use byobu
15:37:27 <shapr> I don't miss any of the tmux/screen features from inside byobu
15:37:54 <b0nn> I've never tried byobu, I might look into it over the weekend
15:38:01 <Rembane> shapr: Cool. I ws mostly pondering if there was anything missing in byobu at all. 
15:38:26 <sshine> shapr, can't arandr fix the scaling per screen?
15:39:23 <shapr> sshine: I thought it couldn't, but now I have to check
15:44:34 <sshine> I think I downscaled my laptop monitor once because it did 1920x when my external monitor only did 1200x.
15:46:35 <sshine> but I find that with laptop monitor and external monitor having very different DPI, even having the same resolution can be a problem.
15:52:57 <evelyn> shapr: I have been trying this too and I don't think gnome does it
15:53:23 <evelyn> shapr: hopefully in a while it will become a more common use case and it will happen
15:55:11 <Cale> If you have a screen which is comprised of multiple monitors, it doesn't necessarily even make sense for them to have different scaling because a window might be split across more than one monitor.
15:55:30 <Cale> But it would be nice to have more control of that
15:55:52 <Cale> It would also be nice to have window managers that could straightforwardly zoom individual windows
15:55:59 <glguy> macOS can handle different scaling per monitor because apps don't get to split across multiple monitors
15:56:24 <glguy> I routinely using hidpi and regular monitors together
15:56:44 <Cale> I have a 4k monitor and a 1080p as well
16:08:54 <hseg> ghc is weirding me out. managed to write `deriving via ... instance (C n, D r) => U (P n r)`, but now for newtype T n r = T (P n r) ghc rejects `deriving via (P n r) instance (C n, D r) => U (T n r)`
16:09:01 <hseg> what gives?
16:09:43 <hseg> specifically, GHC complains about being unable to find a U (P n r) instance to coerce the U (T n r) instance from
16:10:00 <hseg> but i've imported the relevant module, so the instance should be in scope
16:10:56 <hseg> possibly relevant - the code is using associated types
16:11:16 <hseg> otoh, the original P n r instance was given by DerivingVia, no problem
16:13:46 <wrunt> maybe it would work if you used deriving newtype rather than deriving via?
16:15:35 <hseg> turning on GND and adding `deriving U` to the end of the newtype declaration gives me the same "No instance for U (P n r)" error
16:16:31 <Cale> How certain are you that there is an instance U (P n r)?
16:16:48 <hseg> it's right there in front of me, in the second file
16:16:55 <hseg> which is imported in the first
16:17:10 <Cale> If you remove the offending code, can you use the instance?
16:17:28 <Cale> Or maybe just :info U
16:17:35 <Cale> and see if it's listed
16:17:50 <Cale> Are the *kinds* of these things the same?
16:18:23 <frdg> https://pastebin.com/vCCzwYWU quick question related to property testing
16:18:33 <Cale> do
16:18:42 <Cale> main = do
16:18:46 <Cale>   quickCheck foo
16:18:49 <Cale>   quickCheck bar
16:18:55 <frdg> cale: thanks!
16:18:58 <hseg> just a sec, firing up a repl with only the module defining the P instance in scope
16:20:01 <Nolrai> frdg: Look at hspec or tasty, they have a bit of learning overhead, but produce a nice test harness.
16:20:47 <frdg> Nolrai: Ive done a couple things in hspec, ill check out tasty thanks
16:21:14 <hseg> ok, so :i U shows instance (C n, D r) => U (P n r)
16:21:38 <hseg> and :i P shows the instance as well
16:24:22 <Nolrai> Is "inverse" the word for the rate of something _not_ happening?
16:27:14 <hseg> even checked to make sure the component defining T properly depended on the one defining P. it does
16:27:40 <hseg> oh wait
16:27:43 <hseg> wait wait wait
16:28:05 <hseg> i think my use of backpack might have stopped me here
16:28:10 * MarcelineVQ waits
16:28:47 * Cale holds his breath
16:29:32 <hseg> success!!!
16:29:38 <Cale> nice
16:29:58 <hseg> forgot to export the U (P n r) instance in the module signature
16:30:06 <Cale> Ah, weird
16:30:06 <hseg> which makes sense, this is part of a current refactor
16:30:20 <Cale> Backpack can control the export of instances?
16:30:52 <hseg> no worse than ghc's lazy confluence checking
16:31:02 <hseg> (cf the diamond inconherence problem)
16:31:30 <hseg> so here i was depending on the signature, and ghc was separately compiling the components
16:31:38 <hseg> so it never picked up on the signature
16:32:18 <hseg> ok, so now i just have a couple of infinite type errors, but no biggie, was expecting something like that
16:32:51 <hseg> in fact, this entire refactor was originally motivated by wanting to solve it
16:33:01 <hseg> thanks!
16:35:38 <dsal> frdg: In general, if you want to perform two actions and ignore their results, you can stick >> between them.
16:36:04 <dsal> But if you're running quickcheck by writing a Main, you're kind of doing it the unusual/hard way.
16:36:23 <frdg> dsal: what is a better way?
16:36:56 <dsal> frdg: as Nolrai mentioned earlier, something like tasty makes it much easier.
16:37:13 <dsal> It's part of my default stack template.
16:37:53 <frdg> dsal: ok ill write that down somewhere thanks
16:38:32 <dsal> frdg: My default template leaves this as test/Spec.hs https://www.irccloud.com/pastebin/5GVubkCr/Spec.hs
16:42:08 <pounce> so im trying to debug my function
16:42:22 <pounce> and im using `bifunctor` with the return value product a list to trace values
16:42:35 <pounce> but it's kinda silly and hard to maintain. can i just use gdb on my source??
17:20:54 <johnw`> interactive debugging is not so common with Haskell
17:21:37 <solonarv> I don't know how well gdb works; I expect there to be a bunch of additional noise to wade through, at the very least
17:21:52 <solonarv> ghci does have an interactive debugger as well, but I haven't used it much
17:21:56 <johnw> it's possible to interactively step through an expression's evaluation using ghci
17:22:03 <johnw> but it's not very convenient
17:22:17 <solonarv> yes, that's why I haven't used it much :P
17:22:25 <johnw> I would think most of us use Debug.Trace, and either trace or traceM
17:22:59 <solonarv> I usually resort to testing small functions in ghci (breaking up larger ones if necessary) and spilling a few trace calls throughout the problematic code
17:23:26 <solonarv> (or if I'm already working in IO I sprinkle around putStrLn and print instead)
17:28:38 <pounce> hum yeah im trying ghci
17:29:16 <pounce> only problem is im trying to debug a dynamic programming algorithm i wrote
17:29:32 <pounce> and there's tons of weird recursion and such and all the work is inside a helper function
17:30:00 <johnw> what solonarv mentioned really helps the most: break it down into small functions, test them independently (usually in ghci)
17:30:28 <pounce> yeah
17:30:37 <pounce> i think im going to rewrite this function without memorization and test it in ghci
17:32:42 <johnw> memoization?
17:36:22 * hackage lowlin 0.1.0.0, nuha 0.2.0.0 (jodak): https://qbin.io/modes-drill-6p4k
17:36:22 * hackage unicode-tricks 0.4.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.4.0.0 (wvanonsem90)
17:36:22 * hackage yet-another-logger 0.4.0 - Yet Another Logger  https://hackage.haskell.org/package/yet-another-logger-0.4.0 (fosskers)
17:36:22 * hackage lz4-hs 0.1.4.1 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.4.1 (vmchale)
17:36:42 <mniip> ...why are you like this
17:37:09 <MarcelineVQ> that boy ain't right
17:38:44 <pounce> johnw: memorization
17:39:17 <mniip> pounce, the programming technique of storing previously computed outputs is called memoization
17:43:39 <berndl> When should a type class go under a Control module?
17:44:31 <mniip> when it's used to structure control flow I guess
17:45:14 <mniip> c.f. applicative, monad, category, arrow
17:45:15 <MarcelineVQ> berndl: the distinction is pretty flimsy, if it's anything at all, consider lens is Control.Lens but it's (to me) all about data manipulation
17:45:52 <mniip> MarcelineVQ, Control.Lens is the "meta" that you use to manipulate data manipulators (lenses)
17:46:13 <berndl> Define "control flow".
17:46:42 <berndl> Bool is used for if statements, which is definitely control flow, but it's not in Control.
17:48:06 <mniip> if statements are control flow
17:48:07 <mniip> bool is data
17:49:12 <mniip> but yea there is not a fine line
17:49:29 <mniip> church encoding turns data into control flow
17:49:32 <berndl> Alright. I'll concede. However, there are oddities like Data.Functor.
17:50:41 <berndl> If you had to place the Num typeclass somewhere, would you place it under Data or under Control?
17:51:29 <solonarv> my gut says "definitely Data" for this one
17:51:44 <berndl> Mine too.
17:51:56 <oats> in geneal small functions and a constantly going repl are what drives my debugging process :P
17:52:03 <oats> oops, I was scrolled up
18:13:39 <jumper149> Does anyone know how I could find a nixpkgs version to pin so that I can build GHCJS and miso with it? The one recommended on miso's readme is about 1 year old.
18:16:52 * hackage matrix-sized 0.0.4 - Haskell matrix library with interface to C++ linear algebra libraries.  https://hackage.haskell.org/package/matrix-sized-0.0.4 (kaizhang)
18:30:06 <iphy> is there a way to compile ghc base/rts/etc libraries as position independent code (-fPIC, -pie) even in the static versions of the libraries?
18:30:38 <iphy> android doesn't support TEXTRELs, so everything I link into the final binary must be PIC
18:57:34 <moistoreos> ok guys. i want to be weird and write a desktop gui using Haskell and qt. however, options seem limited.
18:57:43 <moistoreos> anyone have a recommendation?
18:58:03 <koz_> moistoreos: I think pie_[bnc] was chiming about Qt bindings for Haskell recently?
18:58:24 <iphy> does https://hackage.haskell.org/package/qtah-qt5 work?
18:58:43 <iphy> seems pretty old
18:59:03 <moistoreos> a lot of them seem either depricated or stale
19:09:39 <Cale> qtHaskell is ancient, but its last release was February 2019, which is recent enough to be usable
19:10:22 <Cale> and that qtah-qt5 package was just released December 24 2019
19:12:49 <Cale> I know that every day feels like a year now, but that really wasn't so long ago ;)
19:28:45 <pounce> here's a weird question
19:29:23 <pounce> can i make an array with bounds `((0,0,0),(n,2,n-x)` where `x` is the first coordinate
19:29:46 <pounce> i.e. have an array where all valid indices of the third coordinate are less than the first
19:33:20 <xacktm> not sure yet about your exact question, but do you know list comprehensions and that they support perdicates?  you can say [(x,y) | x <- [0..n], y <- [0..n], y < x] to get a list of tuples where y < x
19:34:01 <koz_> xacktm: Perdicates make your data perdy.
19:35:07 <xacktm> haha
19:35:14 <xacktm> oops, predicates*
19:40:42 <xacktm> maybe you're looking for  [(x,y) | y <- [0..x], x <- [0..n]] ?
19:41:38 <xacktm> hmm do those two generate the same list? 
19:52:55 <koz_> :t traverse_
19:52:56 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
19:53:59 <pounce> can you make an array from a list of indices?
19:54:26 <koz_> pounce: What would go in each index?
19:54:33 <monochrom> No, but yes from list of (index, content)
19:54:57 <Axman6> pounce: are you after something like: f n = [(x,y,n-x)| x <- [0..n], y <- [0..2]]?
19:55:00 <monochrom> Unless you're one of those python-poisoned people who alias array to list.
19:55:16 <Axman6> > let  f n = [(x,y,n-x)| x <- [0..n], y <- [0..2]] in f 3
19:55:18 <lambdabot>  [(0,0,3),(0,1,3),(0,2,3),(1,0,2),(1,1,2),(1,2,2),(2,0,1),(2,1,1),(2,2,1),(3,...
19:55:38 <monochrom> Which array library are you using anyway?
19:56:19 <pounce> Data.Array
19:56:39 <monochrom> Then you know of functions "array" and "listArray".
19:56:55 <pounce> yea
19:57:14 <monochrom> Also it is not going to support ragged arrays.
19:57:17 <pounce> but for `array` and `listArray` you still have to give bounds, so id have to give bounds for a bigg array
19:57:18 <mniip> pounce, with instance Ix anything is possible
19:57:20 <pounce> thats what i mean
19:57:34 <monochrom> So give bounds.
19:57:54 <pounce> but then it'll be twice the size i need
19:58:06 <monochrom> So half the size.
20:04:46 <pounce> but then indexing won't work normally....
20:14:20 <mniip> @let data Lt a = Lt a a deriving (Eq, Ord, Show)
20:14:21 <mniip> @let instance (Enum a,Num a,Eq a,Integral a)=>Ix(Lt a)where{rangeSize(Lt x y,Lt z w)=fromEnum$(z*(z-1)-x*(x-1))`div`2+w-y+1;index(Lt x y,_)(Lt z w)=fromEnum$(z*(z-1)-x*(x-1))`div`2+w-y;inRange(xy,zw)ab=xy<=ab&&ab<=zw;range(Lt x y,Lt z w)=case compare x z of{LT->[Lt x b|b<-[y..x-1]]++[Lt a b|a<-[x+1..z-1],b<-[0..a-1]]++[Lt z b|b<-[0..w]];EQ->[Lt x b|b<-[y..w]];GT->[]}}
20:14:22 <lambdabot>  Defined.
20:14:24 <lambdabot>  Defined.
20:15:33 <mniip> > listArray (Lt 0 0, Lt 4 3) ['a'..]
20:15:36 <lambdabot>  array (Lt 0 0,Lt 4 3) [(Lt 1 0,'a'),(Lt 2 0,'b'),(Lt 2 1,'c'),(Lt 3 0,'d'),(...
20:16:07 <mniip> > listArray (Lt 0 0, Lt 4 3) ['a'..] !! Lt 3 2
20:16:09 <lambdabot>  error:
20:16:09 <lambdabot>      • Couldn't match expected type ‘[a]’
20:16:09 <lambdabot>                    with actual type ‘Array (Lt Integer) Char’
20:16:21 <mniip> > listArray (Lt 0 0, Lt 4 3) ['a'..] Data.Array.! Lt 3 2
20:16:23 <lambdabot>  'f'
20:16:31 <mniip> pounce, does this look like what you want?
20:51:06 <pounce> hmmmm
20:51:11 <pounce> i kinda want a less than or equal
20:51:22 <pounce> but that looks pretty great! i'll try to mess around with it
20:51:22 * hackage purebred-email 0.3.1 - types and parser for email messages (including MIME)  https://hackage.haskell.org/package/purebred-email-0.3.1 (frasertweedale)
21:31:22 * hackage warp 3.3.10 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.10 (KazuYamamoto)
22:24:15 <pie_[bnc]> monochrom: I'm working on qt bindings yeah
22:24:48 <pie_[bnc]> moistoreos: qtah seems to work but coverage is currenntly limited and im working on expanding that
22:25:23 <pie_[bnc]> havent actually gone too deep into usage of the library et other than writing a POC for something and seeing it actually works
23:17:11 <librepunk> @help
23:17:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:17:17 <librepunk> @help list
23:17:18 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
