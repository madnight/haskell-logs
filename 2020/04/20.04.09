00:43:49 <flebron> Hi folks :) Not strictly Haskell related question. Say I'm typing a language, and want to have these 3 constraint types: 1) Variables v and w must have the same type. 2) Variable v must have a type in {t_1, ..., t_k}. 3) Variable v must be "at least as precise" as variable w. Here types have a notion of "precision", as in 8bit, 16bit, etc. Is there an efficient unification algorithm for these type 
00:43:55 <flebron> constraints?
00:57:45 <opqdonut> flebron: 1) can be handled in Hindley-Milner with asTypeOf 2&3) seem like they could have efficient unification, but I don't remember seeing anything like them
00:58:12 <opqdonut> (unless you think full subtyping, which is kinda heavy)
00:58:21 <opqdonut> 2&3 are easy-ish to implement with type families in haskell
01:06:19 <[exa]> flebron: how "dynamic" do you need the sets of choices in 2?
01:07:06 <[exa]> flebron: this is generally easy with typeclasses, but kills principial type property if you allow intersections
01:08:30 <[exa]> flebron: also, 3 is easily implemented by just an integer label on each variable where unification selects maximum
01:14:40 <dmwit> flebron: My gut says that it's relatively easy to solve those constraints. But I guess you won't have principal (principle?) types, which can be pretty annoying.
01:14:52 <dmwit> (2) is by far the most unusual of those constraints.
01:15:24 <dmwit> (1) and (3) are very straightforward. Even unification-fd should be able to handle those.
01:16:49 <dmwit> I guess it's also worth asking whether you're extra-sure all of the places you said "variable" are really "variable" and not "type".
01:26:58 <kingpimp> how you doin
01:30:50 <kingpimp> I'm trying to load the module which uses extensions in GHCi. When extensions are specified in package.yaml file under default-extensions, the module cab be loaded successfully, but when I specify exts using LANGUAGE pragma instead of package.yaml, GHCi for some reason ignores pragmas. Did anybody run into this problem? I googled but I can't seem to find the solution.
01:39:29 <kingpimp> Duh, forget me, I'm an idiot. Should have put pragmas in the beginning of the file, before `module Main where` line.
01:39:51 <kingpimp> All good now.
02:18:53 * hackage registry 0.1.7.1 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.7.1 (etorreborre)
02:49:52 * hackage require 0.4.7 - Scrap your qualified import clutter  https://hackage.haskell.org/package/require-0.4.7 (NickSeagull)
02:58:22 * hackage registry-hedgehog 0.2.1.1 - utilities to work with Hedgehog generators and `registry`  https://hackage.haskell.org/package/registry-hedgehog-0.2.1.1 (etorreborre)
03:14:31 <srk> hm, I have a `TesT m a` monad transformer and want to provide lifted versions of functions like `t (TestT m a)` which is fine I guess but now I sometimes need to "unlift" (using runIndetityT) and that forces IdentityT (TestT m a).. is there a way to avoid that?
03:18:03 <srk> oh, there's monad-unlift
03:19:06 <ndbroadbent> Hello! I'm a new Haskell user on Mac, and I'm having a pretty bad time getting things set up just to run an example project. I followed the instructions here to install ghcup with the curl command: https://www.haskell.org/ghcup/. Then I've been trying to follow this guide on the Haskell wiki: https://wiki.haskell.org/How_to_write_a_Haskell_program.
03:19:06 <ndbroadbent> But it seems like many of the commands are broken or have been changed. For example:  cabal sandbox init => cabal: unrecognised command: sandbox (try --help). cabal install -j => LICENSE: openBinaryFile: does not exist (No such file or directory). cabal install Cabal cabal-install => cabal: Cannot build the executables in the package Cabal because
03:19:07 <ndbroadbent> it does not contain any executables...
03:19:14 <ndbroadbent> Those are some of the errors I'm running into
03:19:32 <ndbroadbent> $ cabal --versioncabal-install version 3.2.0.0compiled using version 3.2.0.0 of the Cabal library
03:19:41 <ndbroadbent> $ cabal --version=> cabal-install version 3.2.0.0compiled using version 3.2.0.0 of the Cabal library
03:19:47 <ndbroadbent> $ cabal --version => cabal-install version 3.2.0.0compiled using version 3.2.0.0 of the Cabal library
03:20:32 <ndbroadbent> also I don't know how to run "haq me" since this path doesn't exist ".cabal-sandbox/bin/haq"
03:21:57 <srk> think you want 'cabal install cabal-install' without Cabal
03:22:42 <ndbroadbent> thanks, that worked!
03:24:15 <ndbroadbent> I think it was already installed though. Also I think the Haskell wiki might be out of date, since the last update on the "How to write a Haskell program" was in August 2018
03:24:33 <ndbroadbent> it might also need an "out of date" warning, like this page: https://wiki.haskell.org/Cabal-Install
03:25:49 <ndbroadbent> fwiw, these are the first pages I've found while looking up Haskell on Google
03:27:38 <gentauro> it's very `rare` that I get `stackoverflows` (it's mostly space-leaks): `Stack space overflow: current size 33624 bytes` (error message). Can anybody point me in the right direction on how to `debug` this? Thanks :)
03:29:45 <srk> ndbroadbent: yeah, there's now a whole new set of cabal new-* commands as well. to run an executable you can use cabal new-run 
03:32:58 <ndbroadbent> ah thanks
03:33:33 <ndbroadbent> wtf I finally figured out why "cabal install" was crashing with this error: "LICENSE: openBinaryFile: does not exist (No such file or directory)" - It's because "cabal init" doesn't create a LICENSE file by default
03:34:10 <ndbroadbent> but it does add "license-file:        LICENSE" to the default .cabal file
03:34:32 <ndbroadbent> so I can either remove that line or run "touch LICENSE"
03:35:19 <srk> yup
03:36:13 <MarcelineVQ> iirc you can have it add one if you use interactive.  cabal init -i  and pick no
03:37:02 <maerwald> make sure to pick a reasonable license
03:37:30 <zincy_> Is it good practice to wrap threadDelay with something like onException ?
03:38:06 <zincy_> I can't think of any reason at the moment the child thread in thread delay could die unexpectedly
05:03:16 <aveltras> im trying to implement a session combinator for servant, is there some way to execute some IO action after the handler has run. Here im building a "session handle" during the routing part of the request process, this handle is given to the handlers. What i'd like to do now is to read the handle to fetch a token to include in a response header. Here's the code as of now
05:03:20 <aveltras> https://www.irccloud.com/pastebin/OXIEdgCs/
05:03:40 <aveltras> taking inspiration from servant auth here https://github.com/haskell-servant/servant-auth/blob/master/servant-auth-server/src/Servant/Auth/Server/Internal.hs
05:23:14 <zincy_> aveltras: Have you checked out the Servant-auth-server package?
05:24:43 <aveltras> yes but now i think im not taking the easy way to make this work, i'm reading github issues mentioning using the vault combinator to accomplish this (since i already have a wai middleware ready), i think i'll follow this route
05:48:54 <kderme> I try to derive a Generic instance for a datatype, but I get an error that its data constructors are not all in scope. Its constructors are not exported at all, so is there any way to fix it? Also is there any reason a library wouldn't derive Generic for the types it exports?
05:54:06 <lyxia> Generic leaks implementation details
05:56:07 <merijn> lyxia: Generic "leaks" implementation details in the same way that a massive hole in a pipeline "leaks" fluids :p
05:57:16 <lyxia> :)
05:57:40 <maerwald> Uhm, I'm running curl in a forked subprocess and it never finishes. I can see the process in htop and the arguments are all correct
05:57:52 <maerwald> Invoking it in the shell works
05:58:55 <merijn> maerwald: Does it turn into a zombie?
06:01:01 <maerwald> it's sleeping
06:01:37 <merijn> maerwald: Where did you redirect stdin/stdout/stderr too (if anywhere?)
06:01:59 <maerwald> stdout and stderr er redirected to pipes
06:02:11 <merijn> maerwald: Also, consider attaching gdb to curl and see what it's blocked on?
06:05:54 <maerwald> It has to do with stdout and stderr redirection
06:06:02 <maerwald> Seems that changes curls behavior
06:09:31 <maerwald> 'dupTo pipe stdOutput' makes curl not exit
06:10:09 <merijn> maerwald: Is that copying the stdout of your process to the pipe?
06:10:35 <maerwald> Yeah
06:11:01 <maerwald> I use the same function with other commands
06:11:10 <merijn> curl is probably checking whether stdout is connected to a tty, detecting yes and switching to interactive mode and then getting stuck since your process is in the foreground for the terminal
06:11:42 <merijn> Also, why are you using dupTo to affect the fd of a child? That sounds suspicious and likely broken
06:12:49 <maerwald> https://git.io/JvpOQ
06:14:47 <merijn> You're using actual fork? Brave
06:15:35 <maerwald> :P
06:16:07 <maerwald> I'm looking for a switch in curl to turn off this automagic thing
06:16:22 <merijn> Why not use process?
06:16:46 <maerwald> Don't want
06:16:54 <merijn> Like, I'm not kidding, safely using fork() is borderline impossible in C and frankly I don't think you can ever do it correctly in Haskell
06:17:02 <merijn> It's deprecated in posix for a reason
06:17:52 * hackage datadog 0.2.5.0 - Datadog client for Haskell. Supports both the HTTP API and StatsD.  https://hackage.haskell.org/package/datadog-0.2.5.0 (dfithian)
06:58:06 <maerwald> merijn: I think it's not related to curl, but I can't see the problem with the code
06:58:32 <maerwald> Can't make it work with wget either
07:02:53 <frdg> what is the difference between an operation and a function in regards to the definition of a monoid? Can these two words be used interchangeably?
07:03:43 <merijn> frdg: You mean in the sense that "a monoid is an operation with an identity element...yada yada"?
07:04:31 <solonarv> "operation" is sometimes used to imply something like "the type looks like a -> a -> a"
07:04:59 <frdg> merijn: right
07:05:19 <tdammers> frdg: you have monoid-the-concept and Monoid-the-typeclass
07:05:22 <merijn> frdg: In the context of Haskell there is no difference between "function" and operation
07:05:46 <frdg> merijn: ok thanks
07:05:51 <tdammers> in the conceptual sense, you're talking about a set, an element of that set (the "empty" or "neutral" element), and an operation (a binary operator that takes two elements from the set and produces a third one)
07:06:09 <merijn> frdg: But note that monoids are a more general concept in algebra where you may want to distinguish "operation" from mathematical functions
07:06:32 <tdammers> the typeclass however is defined in terms of types (corresponding to the "set"), values (corresponding to elements of that set), and functions (corresponding to the operation)
07:06:59 <tdammers> the Haskell rendition is a bit narrower than the mathematical concept
07:07:02 <frdg> So far through what ive learned about Monoids reminds me a lot of folds. Are they related?
07:07:37 <merijn> frdg: Yes and no. No, they're not related, but also yes because "foldl mappend mempty" is a useful function :p
07:07:40 <merijn> :t fold
07:07:42 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:07:47 <merijn> :t foldMap
07:07:49 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:08:10 <solonarv> I'd say foldMap sums up the connection between them pretty well
07:08:12 <merijn> frdg: So they're like chocolate and ice cream, not really related, but they go very well together :p
07:08:42 <frdg> ok thanks guys!
07:11:15 <maerwald> merijn: hmm, maybe the buffer is full and it waits for someone to read on the other end of the pipe?? Because I read only after the process has finished, which is probably what's wrong
07:12:43 <merijn> maerwald: Yes, that is definitely something that causes blocking
07:37:21 <ddk> Hello Guys!
07:42:52 * hackage haskoin-store 0.20.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.20.2 (jprupp)
07:43:14 <sm[m]> ndbroadbent: greetings fellow mac haskeller, did you get it worked out ?
07:53:29 <zincy_> If you have two APIs calling each other in an Async manner. How should you manage retry logic? I am forking a new thread to do the request in.
07:53:32 <kuribas> merijn: shouldn't that be foldr mappend mempty?
07:53:46 <kuribas> :t foldr mappend 
07:53:47 <lambdabot> (Foldable t, Monoid b) => b -> t b -> b
07:53:48 <zincy_> At the moment the child thread could fail quietly and no one would know
07:54:01 <frdg> is '+' a monoid? I believe that it is because it is a binary function, it is associative, and it has an identity.
07:54:05 <zincy_> ddk: Hello
07:54:40 <kuribas> frdg: you need a type and a function on it.
07:55:15 <kuribas> frdg: but in haskell typeclasses work only on types, so Int has two newtypes for monoids.
07:55:29 <kuribas> frdg: guess which ones :)
07:55:45 <kuribas> frdg: hint, there are many possible monoids on integers
07:56:21 <phadej> zincy_: read on distributed systems, I doubt there is "correct answer"
07:57:02 <merijn> frdg: Yes
07:57:17 <phadej> zincy_: and maybe part of question to your answer is `aeync`
07:57:25 <phadej> sorry, async package
07:57:43 <kuribas> frdg: Int forms a monoid under addition
07:58:00 <frdg> Kuribas: im not sure at this point but id guess addition and subtraction have to do with it
07:58:11 <kuribas> frdg: not subtraction
07:58:17 <frdg> multiplication
07:58:40 <kuribas> frdg: indeed, so Int itself is not a Monoid, because you'ld need to arbitrarily choose one.
07:58:50 <kuribas> frdg: that's why we have Sum and Product
07:59:04 <kuribas> > Sum 3 <> Sum 3
07:59:07 <lambdabot>  Sum {getSum = 6}
07:59:14 <kuribas> > Product 3 <> Product 3
07:59:16 <lambdabot>  Product {getProduct = 9}
08:00:14 <frdg> ok im beginning to understand. Thanks
08:03:12 <maerwald> merijn: https://git.io/Jvpnm excellent
08:20:31 <ddk> Hello Guys, I have say 1000s of types and decoders of them where `decoder::ByteString -> SomeType`  now I have bytestring and I have to parse them to one of those 1000s of type, I also have a opcode mapping where `opcode::Int -> SomeTypeName` I can peek the opcode because its in the header of the bytestring after which follows the encoded SomeType
08:20:32 <ddk> data. Can you please suggest how should I proceed for parsing these values. Input is a sequence of bytes containing `opcode — data`-`opcode-data` ? output should be a collection of SomeType . Any suggestions / libraries to help ?
08:21:35 <merijn> ddk: binary?
08:21:58 <ddk> binary library ?
08:22:03 <merijn> @hackage binary
08:22:03 <lambdabot> http://hackage.haskell.org/package/binary
08:25:50 <ddk> merijn: my problem is not for selrialization / deserialisation as I already have encoders and decoders but decoder is of type `dec::(Message a)=>  Bytestring -> a` I have to fix `a` to be able to use it, and I have a function `opcode:: Int -> TypeName` now the problem is a will be changing always how to tackle this ?
08:28:09 <merijn> ddk: Well, ideally, don't design APIs like that ;) But if you're stuck with it, you'll have to CPS is. So, you need "a -> Result" for all 1000s types and then you can build "ByteString -> Result" by peeking at the SomeType and dispatching to the relevant handler
08:28:28 <reactormonk> Is there a library where I can toss it a list of IO () and it runs them for me, a Int number of them in parallel at max?
08:28:31 <reactormonk> Async doesn't seem to do that :-(
08:29:49 <merijn> reactormonk: IO bound or compute bound?
08:30:04 <ddk> merijn: yeah CPS is okay, but actually my question is how to model this decoding which could result in any of the 1000 type .
08:31:32 <ddk> merijn: how to fix a dynamically ? based on `opcode` 
08:33:08 <reactormonk> merijn, compute bound. I'm running a few benchmarks which take a bit of time, and I'm willing to trade correctness for speed for development purposes.
08:35:03 <merijn> reactormonk: ah, I wrote something like what you want for myself (since async didn't do it), but it's not particularly optimised for small/fast tasks, so if your tasks are IO bound or long compute tasks, it'll work. But if your compute tasks are very short the overhead might kill your speedup
08:35:22 <reactormonk> merijn, the benches take about 5s each
08:35:38 <reactormonk> Or 5mins, if I group a bit more aggressively
08:36:04 <merijn> reactormonk: oh, that should be fine, (I was thinking "sub 0.5 second tasks")
08:36:17 <reactormonk> Figured, hence the number :-)
08:37:26 <merijn> reactormonk: https://hackage.haskell.org/package/broadcast-chan-0.2.1/docs/BroadcastChan.html#g:4
08:38:09 <merijn> reactormonk: If you're doing streaming I've got a conduit version too that will run a conduit/pipeline section in parallel: https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.1/docs/BroadcastChan-Conduit.html
08:38:40 <ddk> merijn: ?
08:38:43 <merijn> reactormonk: You can control how to handle exceptions too (abort, retry, drop)
08:38:57 <merijn> ddk: honestly, no clue
08:39:54 <merijn> reactormonk: I use it so I can have multiple long IO request "in flight" in parallel within a conduit pipeline and so far it's working very nice for that :)
08:40:19 <maerwald> Hmm, I wonder how hard it is to incorporate the entire gzip source code in a cabal package? I've only seen this for small projects. E.g. https://hub.darcs.net/vmchale/bz2/browse/cbits
08:42:16 <merijn> maerwald: trivial, assuming it compiles cleanly
08:42:32 <merijn> maerwald: (i.e. no configuration or just autoconf)
08:43:19 <maerwald> gzip is full autotools
08:44:05 <merijn> There's an autoconf build type for cabal
08:45:43 <merijn> maerwald: https://cabal.readthedocs.io/en/latest/cabal-package.html#system-dependent-parameters
08:49:29 <ddk> anyone else to my problem ? 
08:49:42 <ddk> above mentioned 
08:52:52 <reactormonk> merijn, thanks
08:54:32 <reactormonk> merijn, `parFoldMap` doesn't use `Monoid`? :-(
08:55:29 <flebron> dmwit: Thanks for the info on unification. I do mean variable, though as is frequently the case, my variables don't vary :) This is an SSA language. The constraint of v having the same type as w comes from thing slike "v <- id w". The constraint about having a specific set of types comes from either explicit type annotations, or functions that are known to be instantiable only in a fixed set of 
08:55:35 <flebron> precisions (i.e. we can multiply in 8bit, and 16bit, but not 32bit). And the third constraint is if we have a variable v in 16bits of precision, I don't want by default to infer that "w <- v + w" has 8 bits of precision (unless otherwise stated via an explicit type annotation).
09:01:06 <flebron> Err that should've been w <- v + 1 :) No coffee yet.
09:04:44 <merijn> reactormonk: mmm, I guess a Monoid version might be useful, albeit a bit more limited
09:05:00 <reactormonk> merijn, more from the name, because `foldMap` uses `Monoid`
09:05:29 <merijn> reactormonk: Yeah, but what else to call it, considering it does a map and a fold :p
09:05:40 <reactormonk> merijn, foldr?
09:06:05 <reactormonk> well, `parMapFoldr`
09:11:45 <infinity0> `(FuncA0 .@#@$$$ FuncB0)` gotta love singletons
09:15:22 <maerwald> I only have liblzma and libz as dynamic libs left. I guess libz hasn't changed ABI in a few decades, has it?
09:15:43 <maerwald> liblzma I'm not sure
09:24:34 <maerwald> stable since 2010 it seems
09:53:32 <gentauro> infinity0: that look like some `template haskell` ...
09:53:37 <gentauro> (or worse) 
10:21:04 <stondo> hello everyone
10:24:13 <stondo> can anyone take a look at https://gist.github.com/stondo/a62fcbc4a8a55d9a7b8abcc3c097309e and tell me why I can't get liftM2 working with that filter please?
10:25:23 <stondo> I'm going crazy with those brackets or I'm missing something else, I have no clue
10:26:47 <fenedor> stondo, do you know about where-expressions, or let-expressions? How about splitting this long chain of functions into multiple digestible ones?
10:27:14 <stondo> fenedor: I updated the gist with what I tried
10:28:02 <stondo> fendor: I haven't written any Haskell in a while, but I should remember about where and let
10:31:24 <zeta_0> fendor: your one of the devs for ghcide right? if you could help me with this issue really quick: https://github.com/digital-asset/ghcide/issues/525
10:31:43 <zincy_> phadej: Thanks will read up on it!
10:32:01 <fendor> zeta_0, I am not a ghcide dev, I have literally 5 contributed lines of code
10:33:04 <zeta_0> fendor: oh my mistake, and sorry for bothering you, i was just looking for someone that could help with this issue
10:33:43 <fendor> zeta_0, no worries
10:34:02 <maerwald> when will brittay support CPP?
10:34:09 <monochrom> stondo: I think basically you were not paying attention to details.
10:34:59 <stondo> monochrom: I'm still having trouble figuring that out. Any help would be very much appreciatd
10:35:38 <monochrom> One aspect is parameter order.  Another aspect is which monad instance you're actually using; and it will turn out to be super sensitive to parameter order.
10:36:45 <monochrom> I wouldn't even use liftM2 or any of the monad operators for this.  KISS.
10:37:10 <stondo> I understand, I was more interesting in being able to use that using it
10:37:37 <stondo> I don't understand why I can't get it to work as I think it should
10:37:44 <monochrom> OK, it is a good exercise in that particular monad instance, even though I wouldn't use it for real.
10:37:59 <monochrom> So first question, which monad instance are you using?
10:38:03 <stondo> *more interested
10:38:26 <stondo> I fear I don't understand your question either
10:38:53 <stondo> I thought I was using liftM2 just to combine multiple filter conditions
10:39:20 <monochrom> Then IMO you're cargo-culting liftM2.  Find out the answer.  I can tell you five minutes later, but you ought to do due diligence first.
10:41:36 <stondo> (Bool -> Bool -> Bool) ?
10:41:45 <monochrom> No.
10:42:28 <stondo> maybe I'm starting to get it, but stil not sure
10:43:03 <stondo> does it have to do with that signature: isMultipleOf :: Int -> Int -> Bool ?
10:43:25 <monochrom> A little.
10:43:26 <stondo> I mean the problem I'm experiencing
10:43:46 <monochrom> You have a multitude of problems.
10:44:00 <monochrom> One of them is about "f x y" vs "f y x".
10:44:10 <monochrom> But even that is only the tip of the iceberg.
10:44:19 <stondo> if the problem has to do with the fact that I'm using liftM2 without understanding itself in deep, it's true
10:44:22 <monochrom> Overall I think you are not ready for liftM2.
10:45:08 <stondo> but then why I was able to use it in the other version below in the gist?
10:45:23 <monochrom> Luck?
10:45:42 <monochrom> The correct version has suitable parameter order.
10:45:43 <stondo> monochrom: are you trying to help or just having some fun with me?
10:46:30 <stondo> the version that works with liftM2, I think I understand the order in which things get applied/processed
10:46:41 <monochrom> No. IMO questions of the kind "why is this wrong?" is unanswerable.  Apart from: If you can't prove that it's right, then it's wrong.
10:47:18 <stondo> it's not unanswerable. It's just tat you don't want to answer it and explain it to me
10:47:32 <stondo> *that
10:48:01 <monochrom> OK, teach me how to answer that kind of questions.
10:49:04 <stondo> well, I don't wanna teach anything at all, but starting from what's wrong there's usually a way to show the mistakes and explain the proper way to do it
10:49:39 <monochrom> I already answered that.  This usage of liftM2 is very sensitive to parameter order.
10:50:26 <monochrom> You accused me of not helping so I'll reciprocate with accusing you of denying a perfectly good answer.
10:50:41 <stondo> OK, but that doesn't tell me what's wrong with params order. I thought that explicitly declaring filter param I could write it that way
10:51:19 <stondo> I think you-re deliberately arguing with me without any reason
10:52:02 <stondo> I didn't accuse you. I just let you know that I didn't understand your answer. if you were trying to help me
10:55:26 <monochrom> OK, I want you to compare these two (both are correct, and they are equivalent)
10:55:35 <zeta_0> what does # and #+ mean in haskell?
10:55:50 <monochrom> (\n -> isMultipleOfThree n || isMultipleOfFive n)
10:56:07 <monochrom> liftM2 (||) isMultipleOfThree isMultipleOfFive
10:56:14 <zeta_0> i'm ready some three-penny-gui code and that's the 1st time i've seen those
10:56:32 <monochrom> This is trying to say that liftM2 is removing the \n
10:56:33 <solonarv> zeta_0: nothing in particular. they are just operators which are presumable defined in whatever library you are using
10:56:59 <solonarv> not special syntax, and not operators from anywhere in the core libraries either
10:57:02 <stondo> monochrom I think the first one is just explicitly showing the param, while the second is implicit (currying)
10:57:22 <monochrom> So if you put back the \n, you are defeating liftM2, so it's the wrong direction.  At least if it's an outer \n covering the whole thing.
10:57:42 <zeta_0> solonarv: personally i've struggled the most with haskell's dsl's, it's hard having to learn other languages while learning haskell
10:57:56 <monochrom> or I guess s/removing/providing/
10:58:06 <monochrom> or replacing
10:58:48 <stondo> monochrom: then I don't know how to pass only 1 param to my function in second position
11:00:38 <monochrom> OK, next you have isMultipleOfThree = \n -> isMultiple n 3
11:00:58 <stondo> but my goal was just using isMultipleOf
11:01:14 <monochrom> Yes. But this is a good source of inspiration.
11:01:49 <monochrom> Your correct version is saying: liftM2 (||) (\n -> isMultiple n 3) (\n -> isMultiple n 5)
11:02:03 <monochrom> This is different from putting \n outside.
11:02:31 <maerwald> hm, I'm not getting anything out of split-sections. Do I have to apply it for dependencies as well?
11:02:35 <stondo> monochrom: probably I got it eventually
11:03:20 <monochrom> Yes maerwald, you use split-sections to build all libraries.  Then exes built afterwards will benefit.  split-sections is for libraries.
11:03:37 <maerwald> Ouch, rebuilding world...
11:03:56 <monochrom> I enable split-sections in my $HOME/.cabal/config
11:04:12 <monochrom> The happy news is that libraries that come with GHC already have it.
11:04:52 * hackage string-interpolate 0.2.0.1 - Haskell string/text/bytestring interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.2.0.1 (williamyaoh)
11:04:54 <stondo> monochrom: findSumOfMultiplesOfTwoNumsBelow a b below = sum (filter (liftM2 (||) (`isMultipleOf` a) (`isMultipleOf` b)) [1..below - 1])
11:04:58 <monochrom> In these days of cabal v2, I suppose you simply have to erase $HOME/.cabal/store ? >:)
11:05:00 <stondo> thanks for your help
11:05:08 <stondo> but I still have one question though
11:06:27 <monochrom> The reason I chalk it up to parameter order is this.
11:06:42 <monochrom> Suppose you have "g a n = isMultiple n a"
11:06:58 <monochrom> Then you can go: liftM2 (||) (g a) (g b)
11:07:16 <monochrom> and the purpose of g is to re-order thee parameters of isMultiple
11:07:45 <monochrom> liftM2 wants your n to be the last parameter, not the first.
11:09:36 <stondo> yes, I eventually got it. What if I has swapped the meaning of the params in my isMultipleOf? Would that been enough to fix it?
11:09:56 <stondo> without the need to the intermediate swap I mean
11:10:07 <monochrom> Yes.
11:10:10 <stondo> *to do
11:10:48 <stondo> well, thank you again
11:17:09 <dmwit> flebron: I find your explanation of why "variable" is the correct term a bit worrying. In particular you appear to be talking about computation-level variables, a thing that unification is completely ignorant of.
11:20:12 <dmwit> Okay, I reread your description with this in mind. When I thought the constraint was "type variable v stands for a type in the set { ... }" I was not too worried. Now that I know it means "computation variable v has a type which is in set { ... }" I am more worried.
11:20:31 <dmwit> I would have to think carefully with paper and pencil to know whether that is problematic or not. But presumably you, too, can do this paper-and-pencil thinking. =P
11:20:57 <dmwit> I continue to believe that the other two kinds of constraints are no problem, even with my new understanding of how you are using "variable".
11:21:02 <monochrom> What is a computation variable? Is it the same as a term-level variable appearing in/as a term?
11:21:09 <dmwit> yes
11:21:25 <dmwit> But I don't like "term-level" because there are terms at all levels.
11:22:06 <dmwit> "computation-level" isn't fantastic, either, because these days we can do computation at the type level.
11:22:06 <monochrom> That's an irony. Because I replaced "expression" by "term" because there are expressions at all levels, too.
11:22:19 <dmwit> But I don't know what to do about that. I haven't thought of a better name for the bottom level.
11:22:41 <dmwit> I didn't even know "expression" and "term" were different.
11:22:44 <flebron> dmwit: Why are you more worried?
11:23:21 <monochrom> I'll just chalk it up to "different authors have different conventions"
11:23:29 <dmwit> flebron: Because the types on both sides may be type applications, and it's not immediately obvious to me how to reduce such set-membership constraints of applications to more basic constraints that can be individually solved.
11:24:31 <dmwit> (on both sides of what? on both sides of `t1 ∈ {t2, t3, ...}`)
11:24:46 <monochrom> "value level" is a very good candidate, but it comes with a new problem.
11:25:26 <dmwit> "value level" is okay, except that there are many expressions at the value level which are not values, which might be confusing...
11:25:59 <monochrom> Yes that's the problem.
11:26:39 <dmwit> And so I must choose from many bad options, and what shall I do but then decide on what I think is the least bad? =P
11:26:56 <flebron> dmwit: When I use {t1, ..., tk}, those would be fixed types, never type variables, if that helps.
11:27:22 <dmwit> I don't really think it does.
11:27:23 <flebron> That constraint is born from the target platform's inability to do arithmetic in some precisions.
11:27:49 <monochrom> My convention (I gathered from some authors) is: terms at the bottom level; above that they're all types, perhaps clarified by type-1, type-2, etc if necessary.  Every level has expressions.
11:28:18 <dmwit> Think of `f x ∈ { Foo Int, Bar Int, Foo Bool }`. I cannot reduce this to `f ∈ { Foo, Bar } && x ∈ { Int, Bool }` because that addsa  new solution that the previous one didn't have.
11:28:43 <monochrom> But I reckon that even the mathematicians haven't agree on what to do with 0^0 so meh.
11:28:54 <flebron> dmwit: My types aren't type applications though, they're all arithmetic, integral types :) (And, well, functions between those). Does that change things?
11:29:04 <dmwit> Functions are applications.
11:29:12 <zeta_0> did the Paths module get renamed to Path, it says the Paths module does not exist? i'm following a three-penny-gui example, so maybe it's outdated
11:29:30 <dmwit> The name is usually Paths_<pkg>.
11:29:37 <dmwit> I don't believe it has ever been just Paths.
11:29:55 <flebron> Yeah, fair enough.
11:30:13 <monochrom> Is 0 a natural number? Must a CPO have bottom? Must a domain have non-empty meets? ...
11:30:53 <zeta_0> dmwit: here's the example code that contains: import Paths: https://github.com/HeinrichApfelmus/threepenny-gui/blob/master/samples/Buttons.hs
11:31:27 <dmwit> There's also a file there named Paths.hs...
11:32:04 <dmwit> Perhaps you are not in the correct directory?
11:32:07 <monochrom> Paths.hs is part of https://github.com/HeinrichApfelmus/threepenny-gui/tree/master/samples
11:33:45 <monochrom> A CPO with exactly 3 elements is called a C3PO.
11:35:55 <dmwit> In fact I bet I can encode 3SAT in solutions to applications+set element constraintss.
11:38:26 <int-e> monochrom: beep!
11:38:50 <zeta_0> ok, thanks, it makes sense now
11:38:57 <monochrom> C3PO doesn't beep.  Are you R2D2 or someething?
11:40:56 <zeta_0> i'm writing these examples from scratch, but for this case i just copied the Paths.hs file into my project to import
11:41:11 <zincy_> R2D2 speaks in morse code
11:46:54 <flebron> dmwit: lmao. OK, so the answer is "pretty hard."
11:47:31 <flebron> In my case those sets would have fewer than 10 types at most, so it may be OK to be slow and terrible.
11:47:51 <flebron> Thanks for the advice.
11:48:01 <maerwald> monochrom: ????
11:48:07 <maerwald> it went from 60mb to 8
11:48:14 <monochrom> :)
11:49:06 <monochrom> In my area (formal methods), NP problems are the easiest problems.  Because thank God at least it is not doubly exponential time.
11:50:13 <dmwit> SAT solvers scoff at 10-variable problems these days.
11:50:33 <dmwit> Come back when you have 100,000 variables and we'll talk.
11:50:51 <koz_> 10 variables is like 1024 possibilities.
11:50:54 <koz_> You can brute-force that.
11:51:02 <koz_> (in parallel probably)
11:51:11 <dmwit> On the other hand I haven't promised that I can turn this constraint set into a SAT problem.
11:51:37 <dmwit> I promised the other direction.
11:51:54 <monochrom> No, don't. The easier way is to describe a polynomial-time-checkable certificate for yes instances.
11:52:21 <dmwit> Ah, good, yes, that's easy.
11:52:41 <dmwit> Now I get to dust my hands off and say "coming up with the algorithm is somebody else's problem!".
11:52:44 <dmwit> ^_^
11:59:43 <zeta_0> is the Graphics.UI.Threepenny module located in the threepenny-gui package? ghcide says it does not recognize the module?
12:07:35 <zeta_0> nevermind
12:26:52 * hackage MissingH 1.4.3.0 - Large utility library  https://hackage.haskell.org/package/MissingH-1.4.3.0 (HerbertValerioRiedel)
12:29:52 * hackage dobutokO2 0.26.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.26.0.0 (OleksandrZhabenko)
12:50:50 <frdg> is it correct to say that one of the most useful ways to use `newtype` is to use it to wrap several types under an overarching type?
12:51:34 <frdg> like what Sum and Product do in terms of monoids
12:53:24 <Uniaika> IMO, the most useful way to use newtype is to provide the right balance of transparency, through derivation, and type-safety
12:54:38 <frdg> Uniaika: Could you please relate that statement to Sum and Product?
12:55:09 <monochrom> newtype wraps only one type.
12:57:18 <koz_> I would say the most useful way to use newtype is to direct type class methods.
12:57:23 <monochrom> The purpose of Sum, Product, and Endo is to attach a Monoid instance that's otherwise unattachable or undesirable.
12:57:40 <koz_> Since for a non-trivial number of type classes, there is more than one lawful implementation for any given type.
12:57:45 <koz_> (c.f. Ord, Applicative)
12:57:49 <koz_> (at least)
12:58:13 <monochrom> But even then, not all newtypes are for this purpose.
12:58:18 <koz_> Indeed.
12:58:22 <frdg> ohhh I understand what going on here.
12:58:29 <koz_> (in fact, I just wrote one for exactly not-that purpose)
12:59:19 <monochrom> It is easy to conflate a common use case with the definition.
12:59:24 <frdg> Product and Sum serve the purpose of specifying which type of monoid we want to use on any `Num a`
12:59:36 <frdg> cause we can either use addition or multiplication
13:01:07 <monochrom> The definition of newtype is no more no less: create a type of a different name---and under nominal typing, this is a brand new type in the eyes of type-checking---but it has the same low-level representation as another type.
13:02:08 <hyperisco> the opaque alias
13:02:23 <frdg> monochrom: I see, thanks!
13:11:26 <solonarv> oh hey, "opaque alias" is a nice way to phrase this
13:12:48 <frdg> solonarv: meaning that a newtype is an alias for another type that the compiler can't see?
13:15:01 <solonarv> the *typechecker* can't see
13:15:10 <solonarv> (and users of your library can't either!)
13:15:37 <frdg> ok its very clear to me now! thanks
13:48:46 <maerwald> hmm, I want a tool that transforms all implicit imports to explicit imports and back again
13:50:00 <Rembane> Me too 
13:50:16 <maerwald> For development, implicit is much better
13:50:20 <sm[m]> darn it, when will we have nice(r) things
13:50:36 <maerwald> but I want to freeze the imports later
13:51:00 <sm[m]> what’s the lib needed/existing that would enable such a thing ?
13:51:19 <sm[m]> ghc-exact-print or some such ?
13:51:40 <maerwald> I don't really know
13:51:52 <monochrom> There is a GHC flag to dump explicit but also minimal imports.
13:52:14 <monochrom> -ddump-minimal-imports
13:52:35 <monochrom> It will output like "import Prelude (id, (>>=))" etc
13:52:40 <sm[m]> https://hackage.haskell.org/package/ghc-exactprint
13:56:34 <infinity0> in singletons, is there a type family to refunctionalise a defunctionalisation symbol? i.e. turn a ~> b back into a -> b
13:56:44 <infinity0> it's easy enough to write my own but obviously a standard utility function would be better
13:59:18 <d34df00d> I have mixed feelings about (not understanding) singletons. I understand dependent types (at least, for applied programming), but singletons are just out of my reach. Dunno what to do about that.
13:59:53 <infinity0> jle`'s blog post series helped me, as well as trying to write some real-world including this code i'm writing right now
14:00:24 <maerwald> d34df00d: I've never found the need to understand them, so what
14:00:44 <d34df00d> I went through those too (and proper dependently typed programming helps a lot too), but I just don't understand the mechanics of the library good enough.
14:01:15 <koz_> d34df00d: Have you looked at jle`'s 'Introduction to Singletons'?
14:01:22 <d34df00d> Ehh, what's that type family? What is it for? SingI something something. What's that? I always forget that sort of stuff.
14:01:24 <koz_> I think it explains the mechanics of the singletons library pretty well.
14:01:38 <d34df00d> koz_: yes, but I forgot them after a few months not touching singletons.
14:01:42 <koz_> (since it actually motivates its constructions as part of teaching how to do dependent-typing stuff)
14:01:53 <koz_> d34df00d: Well, I'm just here to promote jle`'s stuff. :P
14:02:00 <d34df00d> Yeah, jle's stuff is great!
14:02:15 <koz_> Agreed.
14:02:16 <infinity0> there's several different parts, right now i'm not even using the Sing/SingI stuff but dealing with type-level functions and the workarounds you have to do in haskell that singletons has made into a framework
14:02:38 <d34df00d> But anyway.
14:02:40 <d34df00d> Sorry for derailing that.
14:03:48 <koz_> d34df00d: I think what it really comes down to is that a) dependently-typed programming in Haskell has a bunch of gotchas specific to GHC rather than dependent types; and b) as a result, it's not a very general-purpose hammer to hit problems with.
14:04:07 <d34df00d> Yeah.
14:04:13 <d34df00d> Looking forward to -XDependentHaskell.
14:04:37 <koz_> d34df00d: You may be waiting a long time. :P
14:04:50 <infinity0> well yes singletons tries to smooth that out a bit, and after understanding it better i can do type-level programming a bit better, after understanding how to use all of these workarounds
14:05:00 <koz_> infinity0: Yeah, exactly.
14:05:08 <infinity0> it's hard to navigate the docs though because 90% of it is autogenerated and what i need would be part of the 10% if it exists at all :(
14:05:12 * d34df00d still doesn't understand what's defunctionalization and why it's needed.
14:05:19 <d34df00d> But I never really tried hard enough to grasp that.
14:05:22 <koz_> d34df00d: We can't partially-apply type families.
14:05:23 <d34df00d> In singletons context at least.
14:05:30 <koz_> That's literally 100% of the reason.
14:05:31 <infinity0> it's needed because you can't partiually apply type families like (Fmap F '[whatever])
14:05:32 <d34df00d> koz_: yep, that I know (and that sucks sorta).
14:05:49 <d34df00d> Alright, so that's the "why it's needed part".
14:05:54 <infinity0> it's a GHC problem and one of these "gotchas", so without doing this you can't write simple things at the type-level
14:06:20 <infinity0> but now i want to refunctionalise a symbol and it's not clear what utility does this
14:06:34 <koz_> infinity0: The Apply tyfam I think?
14:06:35 <jofu4> i used to rebind variables more often on purpose, but then i worked with somebody who likes to have lots of warnings.  Is there a way to tell the compiler i'm intentionally rebinding so that the related warning is supressed?
14:06:48 <koz_> jofu4: Just turn off the warning?
14:06:56 <koz_> Like, -Wno-[insert name of warning this triggers].
14:06:56 <jofu4> for a single binding?
14:07:01 <infinity0> koz_: Apply sadly is slightly different
14:07:04 <koz_> Ah, for a single binding, hmmm.
14:07:08 <koz_> infinity0: Shows what I know lol.
14:07:32 <infinity0> i could easily write "type family Refun f where Refun (a ~> b) = a -> b" and manually write the defunctionalisation symbols for it, just feels like the library must already have this somewhere
14:07:48 <jofu4> i just want a {-# REBIND #-} pragma or something to give an extra cue that it is on purpose
14:08:32 <koz_> infinity0: Probbo. The whole 'documentation is lacking' thing is a very general problem, of which singletons is but one symptom.
14:08:45 <koz_> (which is why I try to document the extensible effect out of my libraries)
14:09:07 <jofu4> i put singletons and hlist in the same category of things to learn from but never to add as a dependency to any project of my own
14:09:53 <jofu4> i consider it crazy unstable and if i want to use anything from it, i cut and paste
14:10:04 <infinity0> it is pretty foundational for this type of code, like lens for its type of code, so i just swallow it >.> it's smaller than your kernel :p
14:10:56 <jofu4> i mean, unstable as in it changes a lot between versions
14:11:09 <jofu4> and ghc versions
14:11:38 <jofu4> not unstable as in any particular release is buggy
14:11:42 <jofu4> heh
14:12:52 * hackage tempi 1.0.0.0 - For representing musical tempi  https://hackage.haskell.org/package/tempi-1.0.0.0 (dktr0)
14:13:09 <infinity0> oh i only got into this stuff after PolyKinds was already implemented, so i guess i didn't see the worst of it. i suppose it must be more stable nowadays
14:16:37 <koz_> This coming weekend, I _definitely_ wanna do a bunch of surgery on my libraries.
14:16:50 <koz_> Been itching to do so for ages, and figured 8.10 was a good time, but I'm still blocked by upstream deps, sads.
14:21:51 <infinity0> when in doubt just file a PR i guess ¯\_(ツ)_/¯ https://github.com/goldfirere/singletons/pull/444
14:22:36 <infinity0> oh i forgot to export it whoops
14:59:31 <monochrom> -XNoDependentHaskellNoNoNo
14:59:48 <Welkin> o.o what
15:00:12 <Welkin> what is the status on linear and dependent haskell since the last year?
15:02:09 <koz_> Welkin: Linear I think is more or less where we left it.
15:02:35 <koz_> Dependent is... slightly closer? We've got a way to give explicit kind sigs rather than relying on CUSKs out of 8.10.
15:04:33 * MarcelineVQ patpat monochrom, "there there"
15:05:13 <maerwald> people are mad about getting more power, with no care for the consequences!
15:05:29 <Welkin> mad with power?
15:05:39 <Welkin> _unlimited power!_
15:05:51 <MarcelineVQ> foaming at the mouth, chomping at the bit
15:05:53 <infinity0> i thought we already had KindSignatures since a while ago, what's new?
15:06:30 <maerwald> we can only speculate, but... show me one language that has fully dependent types and isn't completely niche with an ecosystem that is at best a collection of toys and experiments
15:06:36 <Welkin> I don't have any specific use case for linear or dependent types, but I'm just curious about their status.
15:07:11 <maerwald> Yes, I worry about popularity. Among other things
15:07:19 <MarcelineVQ> They have plenty of uses for library makers, and an entire dimension of confusion to add to regulart users
15:07:53 <koz_> infinity0: If you're curious, read the StandaloneKindSignatures docs for GHC.
15:08:25 <infinity0> ah, thanks
15:13:37 <monochrom> If you s/dependent types/any of {Hindley-Milner, algebraic data types, lazy evaluation, probably a couple more other things}/, Haskell did manage to exceed being just toys and experiments, when back then people were not optimistic about those.
15:15:29 <monochrom> So I fear that Haskell may yet surprise us with getting dependent types more used.  But I still think dependent typing is overkill for some problems and XY problem for the rest.
15:15:46 <infinity0> interesting, SAKS makes sense
15:15:57 <koz_> Those acronyms.
15:16:03 <infinity0> yes, it's easy to get carried away with dependent types and use them when they're not really necessary
15:16:45 <monochrom> Curry-Howard is great at informing language design, but off the mark for individual program correctness.
15:17:31 <koz_> :t maybeToList
15:17:32 <lambdabot> Maybe a -> [a]
15:18:34 <infinity0> waa, they called it StandaloneKindSignatures but CUSKs, abbreviating one but not the other
15:18:45 <xe4> is there an equivalent of this for haskell? https://typelevel.org/cats/datatypes/nested.html
15:18:54 <koz_> infinity0: I think SAKS is an acronym too.
15:19:07 <Welkin> saks fifth avenue?
15:19:16 <infinity0> koz_: yes, but this blog post mentions the named language extensions
15:19:21 <Welkin> cusks sounds too much like cuck
15:19:40 <infinity0> https://ryanglscott.github.io/2020/01/05/five-benefits-to-using-standalonekindsignatures/ end of section 4, above section 5
15:19:46 <Uniaika> Welkin: there, you said it!
15:22:39 <infinity0> xe4: that sounds vaguely like lens
15:22:49 <monochrom> "cusk" sounds to me like an adjective for cats, and I don't know what it would say about cats. :)
15:22:52 <infinity0> including these properties:
15:22:58 <infinity0> If F[_] and G[_] are both Functors, then Nested[F, G, *] is also a Functor (we saw this in action in the example above)
15:23:03 <infinity0> If F[_] and G[_] are both Applicatives, then Nested[F, G, *] is also an Applicative
15:23:06 <monochrom> Like, some combination of cute and cuddy?
15:23:07 <infinity0> etc
15:24:01 <solonarv> xe4: I think their 'Nested' is (almost?) exactly 'Compose'
15:24:24 <solonarv> nothing to do with lens, really
15:24:58 <monochrom> Yeah I am also feeling that Nested is similar to Compose (functor composition)
15:25:57 <refusenick> Is there anything like a package manager for experimental/hobbyist programming with a-la-carte uninstallable packages and a global-by-default package namespace?
15:27:12 <solonarv> okay, after checking the source I conclude that Nested is the same thing as our Compose.
15:27:25 <monochrom> Compose: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html
15:27:48 <infinity0> ah right, yes - final case class Nested[F[_], G[_], A](value: F[G[A]])
15:29:07 <monochrom> If you waive "uninstallable" then cabal v1.
15:29:15 <solonarv> cabal v2 can do that too
15:29:25 <solonarv> you just have to pass --lib to your 'cabal install' command
15:30:19 <solonarv> as a bonus, you can use a different environment/namespace by passing a --package-env flag
15:31:46 <refusenick> Apparently GHC has its own methods for uninstalling packages?
15:32:06 <monochrom> No, only unregistering.
15:32:38 <refusenick> monochrom: Can you query "where" a registered package is and do so recursively for dependencies?
15:33:01 <monochrom> ghc-pkg.  But it doesn't recurse for you.
15:33:03 <refusenick> (I imagine this isn't straightforward if it's supposed to be the same on POSIX, Windows, etc)
15:33:17 <monochrom> Do a "ghc-pkg --help" and read it all.
15:33:50 <solonarv> perhaps you could use nix? I think it has a "collect garbage pls" command that will remove packages that aren't used by anything
15:34:18 <refusenick> solonarv: It always has weird bugs when I try it atop another OS.
15:34:42 <solonarv> mm, unfortunate
15:34:58 <solonarv> I haven't used nix other than to start up leksah once or twice
15:41:02 <refusenick> Are there any small/simple DBs in Haskell built on the "functions are data" concept?
15:42:38 <monochrom> I think no. And I think "functions are data" can mean several things, and the thing that implies DB is exactly absent in Haskell.
15:43:04 <monochrom> Note that for example Cloud Haskell faces similar difficulties.
15:43:07 <dsal> data are functions
15:44:47 <refusenick> monochrom: Isn't Cloud Haskell based on message passing? Isn't STM something like an in-memory database*? 
15:45:03 <refusenick> * please correct me on that - I don't understand STM yet
15:45:39 <monochrom> Cloud Haskll (or any cloud computing) needs to send some code over the network to run on another computer.
15:46:02 <monochrom> "like" is a meaningless word.
15:46:08 <dsal> STM is not anything like an in-memory database.
15:46:22 <dsal> Data.Map.Strict is closer to an in-memory databsae.
15:46:35 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #0
15:46:48 <maerwald> in memory databases in haskell are tricky
15:47:23 <MarcelineVQ> no one harking acid-state these days
15:47:24 <maerwald> you would use something like ixset-typed
15:47:30 <maerwald> @hackage ixset-typed
15:47:30 <lambdabot> http://hackage.haskell.org/package/ixset-typed
15:47:44 <maerwald> I can't recommend it
15:48:25 <maerwald> It doesn't express all what a proper relational database can
15:48:37 <Welkin> it's a key-value store though
15:48:38 <maerwald> And good look lucking for your thunks and leaks
15:48:43 <refusenick> monochrom: Aren't there equivalent models to message-passing process calculi? Actors (or derivative process calculi) don't seem like something natural to express in Haskell, for multiple reasons.
15:48:44 <nshepperd2> TVar (Map k v) -- in memory database for people who hate performance
15:49:03 <monochrom> And yeah we aren't even getting into whether a mere dictionary counts as "database".
15:49:13 <Welkin> refusenick: we have distributed-haskell, but it's not the same as erlang
15:49:23 <refusenick> monochrom: dictionary + transactional interface = database, no?
15:49:37 <refusenick> (if not a very good one in the naive case)
15:49:38 <dsal> Why is a transactional interface important?
15:50:07 <maerwald> sqlite is no database then
15:50:07 <dsal> I've used plenty of non-transactional databases.
15:50:16 <monochrom> We all remind each other that "OOP" has conflicting meanings from different people.
15:50:37 <monochrom> "database" is only worse, not better, along that line.
15:50:48 <maerwald> I just think of apples and icecream (that's how the prof started to describe objects, it was about food)
15:51:03 <dsal> I used to write a bunch of Eiffel.  The OO from Eiffel and the OO from smalltalk don't seem very related.  dbm vs. db2
15:51:16 <monochrom> Thinking of food is wise. :)
15:51:38 <maerwald> I would rather have food than think of it during a lecture
15:51:41 <refusenick> dsal: I've seen a Datalog in Haskell (which I'm still reading through), but Haskell (as it's written) doesn't play nice with Prolog (whose fact DB is a graph DB)
15:51:44 <monochrom> But you should be more fluid and think of wine. :)
15:52:16 <dsal> I've got a couple haskell programs that each have a about a half gig SQLite DBs.  Still my goto DB.
15:52:16 <maerwald> Wine during lecture. Checks out.
15:52:40 <maerwald> dsal: yeah, if you've only one process talking to it
15:52:46 <MarcelineVQ> monochrom: so your OOP analogy is a substance from which you can't ever remove the stains?
15:52:47 <monochrom> No! Only talking and thinking about wine during lectures.  Abstract wine.  No concrete wine during lectures.
15:52:47 <refusenick> dsal: When Alan Kay talks about OOP, he means something akin to what the rest of the world calls "the actor model"
15:53:11 <refusenick> Otherwise, OOP = ADTs + subtyping (as in Eiffel, C++, Java, etc)
15:53:47 <monochrom> prevention > cure.  Instead of allowing stains to happen and then worry about removing stains, don't allow stains to happen in the first place.  Keep your wine in your glass and mouth, don't let it spill.
15:53:53 <dsal> maerwald: Well, only one process with the file open typically, but I've run several thousand queries from a remote system against one of them today.
15:54:03 <monochrom> Prove your invariants. Don't wait for bugs to happen.
15:54:17 <monochrom> And don't let leaky abstractions happen.
15:54:27 <monochrom> Haha I'm great at these analogies. I'll stop.
15:54:38 <MarcelineVQ> so you're saying DTs are a sippycup, hard to use as a container, but much safer
15:54:44 <monochrom> But abstract wine is a great invention
15:55:05 <maerwald> dsal: concurrency in sqlite is particularly bad
15:55:06 <refusenick> abstract wine to pair with abstract nonsense :)
15:55:33 <maerwald> unless you went for WAL, which shifts the problems somewhere else
15:55:39 <dsal> maerwald: I'm super familiar with it.  :)
15:56:12 <maerwald> Yeah, all in all, something not to pick.
15:56:16 <dsal> I'm not Richard Hipp, but I'm sure he remembers me.
15:56:39 <dsal> It's the most widely used DB on the planet by a huge margin.
15:56:50 <monochrom> Did you know that lunacy in computer science is measured in nanokays?
15:56:59 <monochrom> There, I have avenged Dijkstra!
15:57:01 <dsal> It does a great job at what it does well.  And what it doesn't do well isn't hard to abstract over.
15:57:06 <maerwald> And it took me a lot of headache fixing concurrency issues by migrating to PostgreSQL in production, because sqlite was shite. :)
15:57:26 <maerwald> I think it's nice for local things
15:57:27 <dsal> Postgres is great software, yeah.
15:57:37 <maerwald> Don't ever run sqlite on a server
15:57:40 <dsal> SQLite is an excellent first choice for a file format in general.
15:57:42 <maerwald> on your desktop with your pm, maybe
15:57:59 <refusenick> monochrom: Dijkstra attacked Backus over his Turing Award lecture (which is where the justification for modern FP originated)
15:58:21 <refusenick> Basically, Dijkstra didn't like what would become Haskell
15:58:39 <monochrom> dsal: Am I misreading, or are you saying: Richard Hipp is the most widely used DB on the planet, and this DB has an entry about you (reemembers you)? >:)
15:59:17 <dsal> haha.  Multithreading...
15:59:47 <monochrom> I know of later Dijkstra's writings favourable to Haskell or at least some of the things Haskell stands for.
16:00:03 <maerwald> the one that gets posted on LinkedIn every other week?
16:00:11 <seanparsons> If I've built a profiled GHC from the source, how do I get the profile results from building a project with cabal out? I ended up with a `ghc.prof` file at the root the project but that was for building `setup.hs` which was pretty useless.
16:00:35 <refusenick> monochrom: He did walk back his criticism of Lisp, so it can't be dismissed out of hand that he might've changed his opinion.
16:01:25 <maerwald> seanparsons: https://github.com/haskell/cabal/issues/5930
16:01:34 <maerwald> every time I do profiling, I have to google it again
16:01:46 <maerwald> intuitive configuration
16:01:49 <refusenick> https://medium.com/@acidflask/this-guys-arrogance-takes-your-breath-away-5b903624ca5f
16:02:21 <refusenick> A Medium article, but surprisingly not-trash.
16:02:38 <maerwald> medium is too much wisdom for me 
16:02:45 <refusenick> Well, the sensationalistic spin could be dropped, but it isn't hot air at least.
16:04:34 <maerwald> I don't know why cabal still has no GUI
16:04:40 <maerwald> Maybe I should...
16:06:02 <maerwald> Similar in style to summoner
16:11:04 <monochrom> The same reason no one wants to implement any GUI in Haskell.
16:11:48 <refusenick> monochrom: FRP isn't yet at a usable level for non-experts?
16:11:52 <maerwald> Oh I have
16:11:56 <monochrom> Actually, even more than that, for cabal-install is expected to "just work" on multiple OSes with conflicting GUI paradigms.
16:12:13 <koz_> refusenick: _Which_ FRP? There's at least three different types.
16:12:17 <koz_> Four if you consider first-order viable.
16:12:22 <maerwald> Yes, I usually exclude windows in everything I do, which has worked well for me :P
16:12:45 <refusenick> koz_: None of them, AFAIK. I presume you mean classic, arrowized, and push-pull.
16:13:01 <koz_> refusenick: 'Classic' meaning higher-order, sure.
16:13:02 <monochrom> So: Even in the simple case of "this GUI program needs only on Ubuntu", people already don't want to do it.  cabal-install GUI would have to do even more.
16:13:38 <refusenick> koz_: Any resources on first-order FRP?
16:13:43 <monochrom> Well so far ghcup survives over both linux and mac because you can stick to POSIX shell scripts.
16:13:47 <koz_> refusenick: It's basically what Elm does.
16:14:13 <monochrom> But there is no POSIX GUI so if one day someone asks you "please give ghcup a GUI" you will have to give up one of them.
16:14:13 <koz_> I'm not too familiar with what writeups Elm has about that stuff, but I guess that might be a start.
16:14:34 <refusenick> koz_: Isn't that not FRP because it lacks a denotation for continuous time?
16:14:47 <maerwald> monochrom: hmm, electron! :P
16:15:10 <refusenick> What's to stop Haskell from adopting Elm's solution, anyways? It seems to get stuff done.
16:15:10 <maerwald> ok, there goes unix principle down 5 sink holes
16:15:20 <koz_> refusenick: I happen to be of this opinion. However, if that's your take, you also rule out a whole bunch of 'FRP' libraries in Haskell (and other languages), so I didn't assume this.
16:15:37 <maerwald> refusenick: you mean abandoning FRP?
16:15:45 <koz_> refusenick: Mostly because Haskell's ecosystem doesn't have the same needs as Elm's, and is _much_ less directed from the top.
16:16:10 <monochrom> I have a cunning plan!  All our command-line-options libraries e.g. optparse-applicative could be given a simple GUI backend...
16:16:11 <sclv> the language proposed by backus is almost nothing like modern fp and closer to apl
16:16:21 <monochrom> or frontend? I don't know which way is front :)
16:16:22 <refusenick> maerwald: It's kept on going until now and continues to yield useful ideas. Does that mean people can't do what Elm's doing when they need something that works, fast?
16:16:33 <maerwald> well, tui would work for linux, *bsd and mac
16:16:34 <Welkin> Elm is not FRP
16:16:45 <Welkin> it has not been since 4-5 years ago
16:16:56 <dsal> I thought there was a cabal gui.
16:17:01 <refusenick> Welkin: It wasn't then either, IIRC.
16:17:07 <refusenick> They just dropped the name.
16:17:10 <maerwald> dsal: link?
16:17:22 <maerwald> summoner is the closest you get, but it's really not a cabal gui
16:17:25 <dsal> Man... I don't remember.
16:17:32 <dsal> oh yeah, it was that
16:17:37 <sclv> ml already existed at this point iirc, so one shouldn’t overstate the relevance of the backus stuff
16:17:37 <Welkin> Haskell has reflex-frp and reflex-dom
16:17:42 <dsal> I didn't find it very useful.
16:17:44 <Welkin> which is true FRP (supposedly)
16:17:49 <maerwald> that's more a wrapper around "cabal init" with additional batteries
16:18:02 <maerwald> But TUI seems doable
16:18:11 <Welkin> haskell also has Miso, which is an implementation of the Elm architecture in haskell
16:18:14 <maerwald> Welkin: and uses ghcjs
16:18:18 <Welkin> yes
16:18:57 <Welkin> I have tried getting into frp in the past with netwire about 6 years ago
16:19:02 <refusenick> On the one hand, desktop GUIs are limiting. On the other hand, everything web is painful to deal with on its own, and probably near-impossible with bare Haskell tooling.
16:19:04 <Welkin> it'
16:19:08 <Welkin> it still confuses me greatly
16:19:10 <monochrom> I paid very little attention to Backus's language (and I'm sure it had a lot of warts). I pay more attention to what he said about the activities you would do to write code this way.
16:19:13 <MarcelineVQ> front-front-end
16:19:17 <refusenick> I'm guessing that's why the reflex people made Obsidian
16:19:29 <Welkin> elm/redux is a 99% solution that is trivial to understand and use by even complete beginners
16:20:34 <Welkin> some people have had great success using frp (inluding in the js world with rxjs/bacon/etc), but it's far from mainstream
16:20:48 <refusenick> monochrom: That's my take. It's more of a cultural continuity (both in content and what Dijkstra criticized) than syntactic similarity (and Backus's language is more similar to Forth in that matter than APL)
16:21:02 <maerwald> elm is probably nice, but why would I use it if there is TypeScript, with a larger ecosystem, better resources, more developer and a pretty sick typesystem too
16:21:03 <monochrom> For example you would do math, you would do serious algebra, not handwave.  For example even when state is a good idea, you would do something akin to today's state monad.  For example you think at the "map f xs" level not "for i=1 to n ...".
16:21:30 <Welkin> maerwald: because the type system is horrible by comparison, and it doesn't have immutable data, and has no effect tracking
16:21:41 <maerwald> It is absolutely nice
16:21:45 <Welkin> I use typescript at work and struggle with it daily
16:21:57 <Welkin> it's a superset of javascript, so it inherits all the same problems, including null and undefined
16:22:19 <sclv> i mean i think Dijkstra’s criticisms made some sense if you understand he was responding to the actual language proposed and not the “dream”
16:22:21 <refusenick> Point-free combinators in Haskell are more similar to APL than Backus's FP.
16:22:34 <monochrom> For example you use various composition operators more and glue together small functions more.
16:22:52 <monochrom> Now that last one does require help from language design.
16:24:22 <refusenick> monochrom: You can do that in Forth. Really, it requires intentional lack of help from language design. Designers tend to think they know best and that best is Algol. (or Lisp, for hipsters)
16:24:53 <maerwald> Welkin: we switched from clojurescript to typescript with functional react components (immutable) and it was a bliss. Easy to start, productive quickly
16:25:05 <refusenick> (Lisp is a nice language, but attempts to copy it without making "another Lisp" frequently fail to capture its power)
16:25:16 <maerwald> And a huge ecosystem
16:25:25 <maerwald> Most of the things in frontend is boring and you don't wanna do it
16:25:56 <koz_> refusenick: _Which_ Lisp? There's liek a bazillion of them with non-trivial design differences. The only thing they have in common is s-expressions and some vague notion of 'macro'.
16:26:10 <solonarv> monochrom: a GUI frontend for optparse-applicative? that actually sounds pretty neat!
16:26:21 <dsal> I'm doing elm+haskell.  It's pretty good.
16:26:42 <maerwald> I'd choose typescript+haskell probably any day. Or typescript+rust.
16:27:18 <refusenick> koz_: mmm, not quite. Common Lisp is a Lisp (the only one, according to true believers), Emacs Lisp is a Lisp, Scheme is questionably so. sexprs are key, but macros aren't everything unless you've only read Paul Graham.
16:28:03 <refusenick> Here's an example of non-macro "Lisp magic" not seen in Lispy not-Lisps like Ruby: https://m00natic.github.io/lisp/manual-jit.html
16:28:10 <koz_> refusenick: If your definition of 'Lisp' _doesn't_ include Scheme, I think you've just alienated half of all self-proclaimed 'Lispers'. 
16:28:29 <koz_> I'm not saying your definitions is wrong per se, merely that a lot of people would disagree quite vehemently.
16:28:31 <maerwald> But the best decision is: not doing frontend in the first place
16:28:51 <refusenick> koz_: I say "questionably so". I think it's a Lisp, but whether you use it "as a Lisp" or as a functional language is up to the user.
16:29:04 <koz_> Also, as a complete aside, I don't consider _either_ Common Lisp or ELisp as worthy of emulation.
16:29:07 <koz_> (in any sense)
16:29:16 <koz_> (however that's orthogonal)
16:29:43 <dsal> Sometimes, I just need a frontend.  GoPro's UI is awful.  My UI is merely bad.
16:29:54 <koz_> dsal: Most UIs are awful in my experience.
16:30:08 <koz_> So 'merely bad' is an improvement. :D
16:30:12 <dsal> heh
16:30:32 <refusenick> ML (and Haskell) being lambda-based is a mistake coming from trying to be "not-Lisps" (but not in the same way as Ruby, Smalltalk, etc)
16:30:38 <dsal> I haven't figured out how to "scale" elm.  Part of that is because I don't actually want to work on the UI.
16:31:17 <maerwald> koz_: because no one managed to come up with an abstraction over keybindings that works for more than just editors. Every application has its own set of completely random keys. So ppl use mouse. And with mouse comes cancer
16:32:07 <koz_> refusenick: What do you mean by 'lambda-based'?
16:32:17 <Welkin> dsal: elm scales perfectly fine. Ask NoRedInk with their 250k loc app
16:32:27 <Welkin> it's the same way that react/redux scales
16:32:36 <refusenick> koz_: Haskell's Core is lambda calculus.
16:32:45 <refusenick> (with type annotations)
16:33:05 <koz_> refusenick: Do you consider untyped and typed lambda calculus to be the same?
16:33:11 <refusenick> Well, GHC Core to be pedantic
16:33:12 <dsal> Welkin: Not suggesting it can't, but I've not really figured it out for my needs.
16:33:13 <koz_> (modulo annotations)
16:33:35 <koz_> Because any corner of the lambda cube _is_ markedly different to the untyped lambda calculus.
16:33:50 <Welkin> dsal: every time I dig into a new elm project I learn something totally new and discover hidden power in the language/libraries that amazes me.
16:34:04 <refusenick> koz_: Of course not. It's still not as far a jump as to a functional language built entirely on pattern matching (Refal) or concatenative combinators (Joy)
16:34:12 <Welkin> I see all the clever ways exstensible records are used
16:34:35 <Welkin> I wrote an xmpp library and fixed an xml parser
16:34:38 <Welkin> it was surprisingly easy
16:34:41 <koz_> refusenick: I'd love the see the theory and logic behind both of those suggestions as compared to the body of theory and analysis we can perform on lambda cube corners.
16:34:53 <koz_> (I'm not being facetious here)
16:34:54 <dsal> I miss xmpp.  :(
16:35:04 * koz_ is running an XMPP server as we speak.
16:35:21 <dsal> Since I don't talk to humans for the most part, I've mainly replaced xmpp with mqtt, though.
16:35:43 <refusenick> koz_: The research isn't there because time & effort haven't been put into it. Lambdas came first, lambdas got more attention, lambdas are still used because you don't have to connect all the dots yourself.
16:36:16 <Welkin> the funny thing about scheme is that it was an attempt to implement the actor model
16:36:26 <koz_> refusenick: Yeah, but STLC and friends were studied in the context of logic, not programming languages, at least initially.
16:36:33 <Welkin> but the authors discovered lambda calculus in the process and got sidetracked by it
16:36:33 <koz_> I don't think it's lack of time and effort.
16:36:46 <yushyin> dsal: there are some XEPs regarding IoT stuff you could make use of!
16:37:20 <refusenick> Welkin: Not quite. The point was to show that continuations could emulate actors. (i.e. actors aren't special like Hewitt claims)
16:39:40 <refusenick> koz_: So was Prolog (literally first-order predicate logic). Mercury's type system is based on the equivalence between conventional and many-sorted first order predicate logic and the fact that many-sorted-ness naturally gives rise to a type theory, as a direct transcription of research in (higher order) logic.
16:40:37 <refusenick> It's all the same in the end. That's what Turing showed, after all.
16:41:09 <koz_> refusenick: Are there signs that said research would yield something? Again, not my area, but I am genuinely intrigued.
16:42:00 <JCCJ> Hi everyone
16:42:04 <koz_> JCCJ: Yo.
16:42:20 <JCCJ> I'm a newbie and Im trying to set up vs on a macos
16:42:41 <JCCJ> following this
16:42:41 <JCCJ> https://dev.to/egregors/vscode-for-haskell-in-2020-5dn8
16:42:52 <refusenick> koz_: Well, type theory's place outside programming is an obscure corner of higher order logic. The work done on the lambda cube should be translatable back into logic via Curry-Howard in reverse.
16:43:05 <JCCJ> however when installing packages with stack
16:43:15 <JCCJ> I get Process exited with code: ExitFailure 1
16:43:29 <refusenick> Are you asking about Mercury's type system? https://mercurylang.org/documentation/papers.html
16:43:30 <koz_> JCCJ: Can you (using a pastebin) paste the _full_ error output from stack?
16:43:49 <koz_> refusenick: Nope. I'm asking about the two alternatives you mentioned regarding basing a language on pattern matching and some other thing.
16:43:56 <koz_> (the thing Joy is based on)
16:44:00 <JCCJ> --  While building package haskeline-0.7.4.2 using:      /Users/Juan Carlos Calvo/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2 --builddir=.stack-work/dist/x86_64-osx/Cabal-1.24.2.0 build --ghc-options ""    Process exited with code: ExitFailure 1Progress 7/19
16:44:31 <koz_> Kay, that's an old-af GHC, but that at least helps a bit.
16:44:58 <JCCJ> I'm completely new, Im following this to learn
16:44:58 <JCCJ> https://github.com/tssm/up-to-date-real-world-haskell/blob/master/3-defining-types-streamlining-functions.org
16:45:05 <JCCJ> and want to set up vs
16:45:50 <refusenick> koz_: Well, Joy is a direct descendant of Backus's FP. http://www.kevinalbrecht.com/code/joy-mirror/j00rat.html
16:46:04 <koz_> JCCJ: I'm not on macOS, so I can't offer many suggestions. Maybe someone else in the chat might know. You may have to wait some time though.
16:46:21 <JCCJ> ok, thank you koz
16:46:29 <koz_> JCCJ: No problem. Sorry I can't be of more help.
16:46:53 <refusenick> koz_: Unlike Haskell, Joy has well-defined syntactic and semantic monoids, meaning it actually forms a category (see: "Hask isn't a category")
16:47:24 <koz_> refusenick: I can't speak for category theory as I'm not actually literate in it, but the arguments I've seen against Hask being a category amounts to 'lol bottom'.
16:47:46 <koz_> (or something similar to that with more words)
16:48:11 <refusenick> koz_: Not just bottom, but also seq, lazy eval, etc
16:48:16 <sclv> how does joy handle nontermination in categorical semantic
16:48:47 <koz_> refusenick: Those arguments are similarly rather trivial IMHO.
16:48:57 <koz_> But again, not a category theorist, so can't evaluate said objections.
16:49:01 <sclv> Anyway sans seq hask is a category just not one with a nice structure
16:49:02 <JCCJ> No language can ever be a category because of the stopping problem
16:49:04 <koz_> Perhaps some other folks here may have something to add.
16:49:46 <refusenick> koz_: The whole point of math is to build nontrivial objects from seemingly trivial definitions. If a pervasive core part of the language breaks these, it all falls apart.
16:50:30 <sclv> thats not the point of math.
16:50:55 <sclv> the point of math is to calculate the higher homotopy groups of the sphere spectrum
16:50:57 <refusenick> sclv: The practice of math, then..
16:51:21 <sclv> no the practice of math is also calculating the higher homotopy groups of the sphere spectrum
16:51:42 <sclv> also, machine learning for ad companies
16:52:21 <refusenick> sclv: The point of math isn't to use long words to sound clever. If people can't understand what you claim to have proven, the proof is of questionable value. See: Mochizuki's claimed resolution of the abc conjecture
16:52:57 <sclv> I didn’t say it was to use long words. Ideally you just use symbols
16:53:09 <MarcelineVQ> like S
16:53:17 <dsal> JCCJ: I just use stack and emacs.
16:53:45 <refusenick> So what if people can't understand it? The Agda people understand this: https://semantic-domain.blogspot.com/2016/03/agda-is-not-purely-functional-language.html
16:53:50 <JCCJ> hahah, I guess I'm too much of a commoner to use emacs
16:54:32 <dmwit> So, "Hask is not a category" argues that *a specific* construction that people commonly refer to as Hask isn't a category.
16:54:32 <JCCJ> I like to use VS with the vim extension
16:54:58 <dmwit> Namely: id + (.) for identity and composition. But isn't the whole issue discussed there fixed by picking strict composition instead of lazy composition?
16:55:18 <refusenick> dmwit: You can categorize anything if you write enough. The point is to keep it simple so you can talk about its morphisms with other (similarly tersely-defined) categories.
16:55:25 <dmwit> i.e. id + \f g x -> f `seq` g `seq` f (g x)
16:55:55 <dmwit> refusenick: But, like, I didn't even write that much. My category definition is only about ten characters longer than the one in that article.
16:56:39 <dmwit> (Please insert scare quotes in the right places. It remains a proof burden on me to show that this definition is well-formed, I agree.)
16:57:37 <dmwit> excuse me
16:57:45 <dmwit> \f g -> f `seq` g `seq` \x -> f (g x)
16:57:58 <dmwit> It does take some care. But it's not super complicated.
16:59:40 <monochrom> Gosh, we have surely broadened the discussion from "what is the point of DBs" to "what is the meaning of math?".
17:00:25 <monochrom> This is what's wrong when people talk using essay-strength relations between buzzwords.
17:00:35 <monochrom> (or more like essay-weak)
17:04:16 <refusenick> Perhaps Haskell would be simpler if it was a lazy-only language.
17:04:26 <koz_> refusenick: What do you mean?
17:04:38 <refusenick> koz_: No seq, etc
17:05:12 <oats> hum, doesn't lazyness-always result in some pretty poor performance sometimes?
17:05:16 <oats> eg, foldl
17:05:41 <refusenick> I don't know how you'd even run programs in a language like that, but it'd be easier to reason about. I suppose that's what math is. (if you treat set enumeration as lazily extracting elements from a set)
17:05:56 <monochrom> What about pattern matching?  Suppose I have "f (Just _) = True; f Nothing = False". What does "lazy only" mean for my f?
17:05:58 <refusenick> Well, and no higher order functions
17:06:53 <refusenick> monochrom: Pattern matching alone is rich enough to build a language with its own semantics. I don't know how it's implemented in Haskell or what all the corner cases are in its interaction with the lambda calculus "core".
17:07:15 <koz_> refusenick: I believe SPJ's old-af book has a whole chapter covering that.
17:07:32 <monochrom> I was not asking for an evasive essay.
17:07:43 <monochrom> And I was not asking for implementation.
17:08:04 <oats> all hail spj
17:08:16 <monochrom> I was asking what "lazy only" means.  And to prevent evasive essay answers, I used a concrete example.
17:08:42 <monochrom> Litmus test telling apart BSing from actually being on to something.
17:09:04 <refusenick> I suppose that means it returns true when it's given "Just <something>" and false when given "Nothing"
17:09:34 <monochrom> There is one more case.  f bottom.
17:09:56 <refusenick> I'll admit that I don't know Haskell very well, but a lot of its issues seem to come from the lack of restraints on transitioning from strict to lazy code (and vice versa).
17:10:20 <monochrom> My question doesn't have to be a Haskell question.
17:10:31 <refusenick> That's what I meant by "lazy-only Haskell". Just ban the other kind of eval.
17:10:41 <monochrom> You said "lazy only" so it's really the language in your mind now.
17:10:57 <monochrom> So, f bottom = what?
17:11:12 <monochrom> Do you know how to give a direct answer?
17:11:20 <refusenick> Couldn't you do away with "true" and "false entirely" and treat bottom as failure to unify like in Prolog?
17:11:32 <refusenick> It's bottom, no?
17:11:44 <monochrom> Sure. It's your language.
17:11:57 <dmwit> ...and now monochrom's trap has sprung.
17:12:15 <monochrom> Not really a trap.  Clarification.
17:12:29 <dmwit> Because if f bottom = bottom, then you haven't forced "lazy-only". You can implement seq at any type you care to apply it at with this technique.
17:12:33 <monochrom> People use over-simplifying wording for very nuanced things.
17:12:58 <dmwit> seqMaybe :: Maybe a -> b -> b; seqMaybe Nothing b = b; seqMaybe (Just _) b = b
17:13:16 <dmwit> seqList :: [a] -> b -> b; seqList [] b = b; seqList (_:_) b = b
17:13:17 <dmwit> etc.
17:13:45 <monochrom> For example truckloads of mediocre haskellers are happy to say the over-simplifying "laziness means unevaluated unless needed" all the time.  (The problem is with being vague, even magical, about "needed".)
17:14:06 <refusenick> Don't you need seq to define bottom?
17:14:11 <monochrom> No.
17:14:19 <refusenick> Or is it that one can be defined in terms of the other and vice versa?
17:15:45 <refusenick> Yeah, I'm a mediocre Haskeller, but also a math major (an undergrad for now). I haven't studied category theory formally in depth (yet - we'll see), but a lot of the stuff here seems suspicious.
17:16:09 <dmwit> No, you don't need seq to define bottom. No, seq and bottom are not interdefinable.
17:16:46 <monochrom> To be sure, evasive essay writing is a great skill that comes in handy sometimes.
17:17:20 <monochrom> For example when a C-grade student asks me "I'm applying to grad school, could you fill in their reference letter/form for me?", I need that skill.
17:18:03 <monochrom> For example when an F-grade student asks me "is there some extra work I can do to bring my mark up to D?", I need that skill.
17:18:49 <monochrom> How do you write a huge getting-nowhere essay that's an obscure obfuscated BSing way to say "no"
17:20:01 <refusenick> Why would I BS this? I'm not trying to grab anyone's attention. I'm just trying to figure out "ok, what is the _actual_ math behind Haskell", because the accounts thus far conflict at the level I understand.
17:20:22 <monochrom> dmwit: Here is some historical background and some observation when bringing in free theorems.
17:21:48 <monochrom> An early Haskell version was such that where you use seq you incur an extra class constraint.  I didn't look up the name but let's say e.g. "f :: Seqable a => a -> (); f x = seq x ()"
17:22:02 <dmwit> That seems very reasonable to me.
17:22:08 <dmwit> The only real magic of seq is that it doesn't incur a constraint.
17:23:36 <refusenick> What are typeclasses? Are they akin to classes in set-based math (equivalence class, etc)?
17:23:41 <monochrom> So in the eyes of free theorems, in today's Haskell (ie no such extra constraint on the type), suppose you have two functions "f, g :: a -> ()".  They could still have very different behaviours even though free theorems can't tell them apart.  To some people, or sometimes, this is unnerving.
17:24:15 <dmwit> refusenick: They are mildly related, yes. A type class is a collection of types which implement an interface.
17:24:43 <monochrom> I learned this from someone else in this channel some years ago.  I agree that a Seqable class is a very nice sweetspot.
17:24:57 <infinity0> one completely different idea perhaps could be to lift "seq" and other similar things out into a meta-language and keep the base language undefined regarding evaluation order. then the "seq" annotations could only apply to specific evaluation strategies
17:25:06 <infinity0> that would give the language a more of a "mathematical" feel
17:27:14 <monochrom> So, in your seqMaybe and seqList examples, their differing types, ie, they can't both be "x -> b -> b", each one has to be "SomeConreteType -> b -> b", this also affects how much/little the free theorems can guarantee.
17:27:40 <refusenick> infinity0: Kind of like how the IO monad guarantees sequential evaluation?
17:28:12 <dmwit> infinity0: But the evaluation order/use of seq can and often does affect which value is produced by a computation. That seems antithetical to "separate out the annotations but be more mathematical".
17:28:48 <infinity0> i thought the only difference was potentially giving bottom / loop-forever, vs the actual value?
17:28:57 <refusenick> dmwit: Does "interface" have a meaning in type theory? Unless univalent foundations (+ homotopy type theory) takes off, I doubt I'll ever study type theory in depth.
17:29:23 <dmwit> No, it is not a standard technical term.
17:29:41 <refusenick> What is a typeclass, in standrad technical terms?
17:30:21 <dmwit> There is no standard technical term that means exactly the same thing as "typeclass", or else we would have just used that term.
17:30:57 <infinisil> Well it's very similar to interfaces in Java or other OOP languages
17:31:22 <infinisil> Or Swift calls them protocols
17:31:34 <refusenick> infinisil: I've used them and get that (although I've never used interfaces in Java or other OOP languages)
17:31:41 <infinity0> in which case i don't think it's particularly antithetical - there's no way to tell statically if a program will loop forever or give you a result, the only thing to do is run it. so it seems acceptable that different evaluation strategies will give different results regarding "bottom" or "the actual value"
17:32:39 <refusenick> infinity0: I meant standard technical terms which a math student might understand
17:32:45 <refusenick> infinisil:
17:33:21 <infinity0> if a program runs for 20 hours but you're sure it should produce a result, then maybe your program's semantics is fine but there's a bug in your evaluation strategy, similar to a memory leak
17:34:25 <infinity0> also, quantum computers inherently give different results all the time, but there is some structure to this non-determinism
17:34:56 <infinisil> Hehe, I have to admit, the main reason I said anything is to mess up somebody's tab completion, mission achieved lol
17:35:09 <refusenick> :(
17:35:11 <infinity0> hehe
17:35:16 <monochrom> "type class" is already the standard technical term.  See the Haskell 2010 Report.
17:36:09 <monochrom> OTOH, it is reasonable to ask "what's 'typeclass' in standard technical term?", since in the Haskell Report it's "type class" not "typeclass".
17:36:14 <gentauro> 02:28 < infinity0> i thought the only difference was potentially giving bottom / loop-forever, vs the actual value?
17:36:32 <gentauro> how would you provide this without dependent types?
17:36:57 <monochrom> "typeclass" probably came from a germanization mistake
17:37:11 <refusenick> monochrom: Is "type class", then, one of the primitive notions (an axiom, if you will) from which the rest of Haskell is inductively defined?
17:37:35 <monochrom> I can't say that Haskell has ever been inductively defined.
17:38:00 <monochrom> But type class is certainly primitive and not defined in terms of something else.
17:38:05 <monochrom> See the Haskell 2010 Report.
17:38:19 <monochrom> You are ready to read it.  Don't be shy.
17:39:09 <gentauro> or refined types (like F* uses)
17:40:21 <gentauro> (to specify that a function is total for all cases and hereby show that it terminates)
17:40:58 <monochrom> gentauro: We were discussing seq.  How does dependent typing come into it?
17:41:37 <gentauro> monochrom: I just say that line and I thought you were talking dependent types (total functions)
17:42:27 <gentauro> monochrom: but if it's `seq` like in: foo x y = x `seq` y `seq` x … y, I'm interested
17:42:40 <monochrom> Yes, that seq.
17:43:16 <gentauro> (I've asked Axman6 for feedback here in private as I don't have a reddit account)
17:43:35 <gentauro> he mentions that I use `seq` naively ...
17:43:36 <monochrom> Wait, what reddit?
17:44:00 <gentauro> monochrom: https://old.reddit.com/r/haskell/comments/fw56ir/haskell_dataoctet_v2_nand_smaller_but_slower/fmomg2x/
17:44:04 <monochrom> Oh, right, clearly, using seq for the second time on the same operand is redundant.
17:44:27 <gentauro> monochrom: my approach is just to use it anywhere I want to force strictness (I would rather add to many, than to few)
17:44:50 <infinity0> there is also just -XStrict
17:45:01 <gentauro> infinity0: I can't use it with my `stuff`
17:45:23 <gentauro> I use `undefined` as `bottom` and by going all strick, my `stuff` will crash on execution
17:45:26 <gentauro> I can't have that
17:45:30 <dsal> This microlens-mtl stuff is kind of breaking my brain.
17:45:36 <gentauro> so I need to do ad-hoc stricness
17:45:42 <dsal> Is this good or evil?   https://www.irccloud.com/pastebin/vsyeS7xR/mtlien.hs
17:46:10 <infinity0> i wish haskell 2020 would be done sometime if only to standardise all these "extensions" that you have to constantly be enabling
17:46:16 <koz_> dsal: ... I fail to see the problem here. :P
17:49:40 <gentauro> infinity0: are you talking about Haskell98? https://twitter.com/edwinbrady/status/1163816732902883329
17:49:43 <gentauro> :)
17:50:11 <infinity0> hah, yes now it is 2020 extensions enable
17:51:03 <infinity0> i'm reading the haskell 2010 report right now and it lists 3 new features on top of haskell 98, did not realise this
17:51:11 <infinity0> well, major new features
17:51:22 * hackage hstar 0.1.0.1 - Haskell version of tar CLI utility  https://hackage.haskell.org/package/hstar-0.1.0.1 (vmchale)
17:52:04 <dsal> Does microlens have all of the features of regular lens?
17:52:34 <solonarv> no. that is why it is *micro*lens.
17:52:46 <solonarv> most notably it is missing Prism and Iso
17:52:49 <monochrom> dsal: I think lens does this too?
17:53:09 <dsal> Oooh.  It's just lens.
17:54:05 <monochrom> You can still get an agreement from me if you go big for "any lens is evil" :)
17:56:18 <monochrom> next time refusenick speaks up, someone remind me to ask "have you written actual code?"
17:56:26 <monochrom> or maybe you could ask that, too.
17:58:02 <koz_> I think this was the person who was saying that von Neumann is going to die in the next few years.
17:58:03 <monochrom> because clearly they are operating on the level of essay writing that would get an A in an English class.
17:58:05 <koz_> About a week back.
17:58:18 <koz_> (or maybe it was two?)
17:58:23 <koz_> (time flies funny in quarantine)
17:58:43 <monochrom> I think they mean the von Neumann model, not the von Neumann person.
17:58:53 <koz_> monochrom: Meant, but sure.
17:58:56 <monochrom> I think I recall that too.
17:58:58 <koz_> That's what I meant to say as well. :P
17:59:17 <monochrom> Yes, still.  See, there is a reason I brought up "lunacy" :)
17:59:31 <koz_> Lol.
17:59:38 <monochrom> I am really not surprised that Alan Kay sounds like their role model.
18:00:01 <koz_> Except they're not nearly as parsimonious.
18:01:07 <monochrom> Actually, on second thought, Alan Kay talked big but at least coded up some of it.
18:02:11 <monochrom> So "Alan Kay as role model" has too sides: talk big like him, or got some ambitious projects done like him.
18:02:44 <monochrom> Why are people so fascinated by the former not the latter?
18:03:13 <koz_> monochrom: Easier to grokk talk, since we can all do it.
18:03:42 <koz_> Also, rhetorical skill has long been associated with intelligence, even though the relationship doesn't even hold in _one_ direction in all cases.
18:03:49 <koz_> (much less in both)
18:05:49 <infinity0> i am looking at oleg's hlist library from yokes ago, type-level programming from before singletons https://hackage.haskell.org/package/HList-0.5.0.0
18:06:46 <infinity0> it's kind of educational how he encodes stuff, instead of using type families to encode type-level functions he uses constraints like FunctionEq f v x to encode f x = v
18:07:09 <infinity0> and has its own implementation of type-level nats
18:07:19 <monochrom> Hey! I know the next generation cool name for the next generation parser library.  parsimony.  >:)
18:07:30 <koz_> monochrom: I approve.
18:07:39 <infinity0> and prefixes higher-kinded stuff with h even though the H in HList stands for heterogeneous not higher-kinded
18:07:55 <koz_> So then, for parsing currency amounts, you'd have 'parsimony-parsey-money'. :D
18:08:23 <monochrom> haha
18:08:55 <monochrom> "parsimony is a parser that's even more parsimonious than yottaparsec"
18:09:44 <koz_> [insert demo of a full parser for C in ten lines]
18:10:28 <monochrom> infinity0, type families did not exist back then.  (to be sure, all the more impressive that he pulled it off.  there is a reason why we said that type-level skill is measured in millolegs.)
18:10:45 <koz_> monochrom: Not microlegs?
18:11:04 <monochrom> Oh, yeah, I forgot the exact prefix.
18:11:14 <monochrom> I just remember that it's not a low as nano.
18:11:32 <monochrom> actually maybe lambdabot knows.
18:12:43 <monochrom> @quote Jafet oleg
18:12:43 <lambdabot> Jafet says: Can oleg create a term so complicated that even he could not type-check it?
18:13:00 <infinity0> haha
18:13:08 <monochrom> @quote mrd oleg
18:13:08 <lambdabot> mrd says: give a man a fire and you warm him for one day; point a man to oleg's web site, and he will create fire for himself -- in the type system
18:14:48 <monochrom> @quote olegfacts wizard
18:14:48 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
18:15:05 <monochrom> @quote type.*wizard
18:15:05 <lambdabot> OlegFacts says: Type wizardry is measured in milli-Olegs.
18:15:10 <monochrom> That one!
18:15:35 <infinity0> aha
18:16:11 <monochrom> So! Let us know when you need water to put out your fire. >:)
18:17:02 <infinity0> i think i'm actually close to the point where i can do practical stuff with this, hopefully can get out something interesting in the next couple weeks
18:22:19 <justsomeguy> Do people make "distributions" of haskell that make certian libraries the default -- like Data.Text as the default String type, and maybe an alternate Prelude that only has total functions?
18:22:33 <koz_> justsomeguy: There are a range of 'better preludes' on Hackage.
18:22:37 <koz_> Your mileage may vary.
18:22:57 <justsomeguy> I had just recently found Relude, which got me thinking about this in the first place.
18:23:06 <solonarv> of course, none of them can save you if a third library decides "okay, I will use String"
18:23:35 <justsomeguy> Ah, there's the rub.
18:24:14 * dsal creates Paylude
18:24:22 <solonarv> you decide: oh, hakyll looks like a nice way to run my website. but oh no! it uses String for everything!
18:24:34 <infinity0> are there plans to optimise String at some point? i seem to remember a talk by spj where he talks about typesystem improvements that would allow the programmer to specify optimised representations for specialised types like [Char]
18:24:56 <dsal> Optimize for what?
18:25:01 <solonarv> String is bad. I will replace 'base' with 'betterprelude', which replaces all the String stuff with Text. But this does not change hakyll's code, which is still all String!
18:25:35 <solonarv> the problem with replacing String is not that it's hard to figure out what the replacement should be, but that lots of code out in the wild uses String
18:25:56 <dsal> Or you run into code that did the obviously wrong thing in their replacement.  Which I've had happen.
18:34:05 <koz_> An even more annoying example - the fail method uses String.
18:34:09 <koz_> And will probably do so forever.
18:41:27 <monochrom> fail is falling out of favour, so it poses a lesser problem.
18:41:39 <monochrom> but consider error, hehe
18:42:23 <solonarv> you may not call fail directly, but you are somewhat likely to end up implementing it
18:43:58 <monochrom> Here is what you're fighting against: Data.ByteString and Data.Text.IO still uses FilePath=String for readFile, for example.
18:46:37 <MarcelineVQ> hey, that's specifically what I've fought with most recently
18:47:48 <dsal> fail was named appropriately. Someone had foresight
18:48:30 <dsal> I have a filesystem at work that uses bytestring for filenames.  That feels wrong.
18:55:37 <justsomeguy> ...haha, try  handling file names correctly in bash ;_;
18:58:51 <dsal> Is polysemy practical yet?
18:59:08 <dsal> I've gotten a little too deep into MTL lately.  I'm wondering if I can even get back out.
20:02:47 <JesseL> j
20:03:10 <JesseL> r
20:03:41 <JesseL> wtf
20:20:30 <whataday> :t id
20:20:32 <lambdabot> a -> a
20:30:13 <jollygood2> hello. sorry for being completely offtopic, but since I occasionally like to talk about haskell I know that there are a lot of smart and knowledgeable people in here
20:30:36 <jollygood2> I need to send an email to dozen or so news sites about high ranking officials in my country, that I could possibly be retaliated against and/or prosecuted (slim chance, but it is certainly possible). so the email service should 1) provide as much anonymity as possible 2) allow me to send identical emails to multiple email addresses, without marking my email as a spam (only a dozen or so email addresses, so it wouldn't be useful for a spam bot). any r
20:31:16 <MarcelineVQ> cuts off at "bot). any"
20:31:52 <glguy> jollygood2: You're right; that's off-topic here
20:32:07 <jollygood2> Marceline: any recommendations?
20:32:35 <jollygood2> glguy, yeah, I apologize. I asked in ##security, and got some recommendations from a guy who appeared to have just googled them on the spot
20:33:14 <lyxia> there are channels #haskell-blah or #haskell-offtopic
20:33:38 <jollygood2> you're right, I forgot
21:15:52 * hackage aop-prelude 0.2.0.0 - prelude for Algebra of Programming  https://hackage.haskell.org/package/aop-prelude-0.2.0.0 (KatsutoshiItoh)
21:30:30 <sm[m]> jollygood2: search past security discussions on hacker news
23:38:57 <turlando> Hello everybody. I was wondering if there was a megaparsec IRC channel. I couldn't find any reference in the documentation.
23:46:51 <maerwald> Probably too specific 
