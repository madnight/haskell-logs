00:22:43 * hackage hadoop-streaming 0.2.0.0 - A simple Hadoop streaming library  https://hackage.haskell.org/package/hadoop-streaming-0.2.0.0 (zliu41)
00:55:33 <brj> Hi
00:56:24 <brj> I've been trying to read Wadler's "Theorems for Free!"
00:56:33 <brj> on page five he defines "polymorphic functions are related if they take related types into related relations"
00:56:49 <brj> I'm having a hard time getting the intuition for this
00:57:06 <brj> can someone please give an example for how a polymorphic function takes related types into related relations?
01:31:03 <gentauro> how does `deriving Show` work under the hood?
01:33:23 <jackdk> gentauro: https://www.haskell.org/onlinereport/derived.html see "10.4 Derived instances of Read and Show"
01:46:39 <maxsu> Hey all, having a discussion about array starting indexing conventions (ie, should array indices start with 1 or 0)
01:47:25 <maxsu> It's been surprisingly amicable, but I'd like to see if there is any real evidence about which convention causes more bugs in code.
01:48:24 <maxsu> has anyone hear of studies in that direction? They would be a little difficult to design, since most languages don't let you adjust you array's starting index (lua does, however)
01:49:04 <maxsu> anyways, not really a haskell question, so I wouldn't mind taking the conversation over to #haskell-blah
02:02:06 <gentauro> jackdk: thx
02:35:47 <iphy> maxsu: the fact that it's adjustable in lua is possibly a source of bugs it itself
02:42:00 <nomeata> Hi! I recall having seen a Haskell library that allows me to, on the fly, generate X86 machine code and then directly execute it, but I can’t find it. Does that ring a bell with anyone?
02:46:27 <maxsu> iphy, I agree, lol
02:47:12 <iphy> nomeata: https://hackage.haskell.org/package/x86-64bit maybe?
02:49:15 <nomeata> Maybe… I unclear if it is just an assembler, or if it can actually call into the assembled stuff. Also, I was expecting something more high-level and type-safe :-)
02:49:32 <nomeata> http://hackage.haskell.org/package/llvm-dsl maybe, but that was just uploaded this month, so maybe not what I was looking for either
02:50:13 <iphy> high level?
02:50:48 <nomeata> Actually, this looks good: https://github.com/divipp/x86-64/blob/master/CodeGen/X86/Examples.hs#L25
02:51:40 <phadej> nomeata: https://hackage.haskell.org/package/llvm-hs ?
02:52:22 <nomeata> With high level I mean I write some numerical computation with some abstraction (a DSL, maybe even something with expressions with a Num instance), and magically I get a very fast implementation of that
02:55:38 <iphy> right
02:55:47 <iphy> I don't now of such a thing, but it sounds nice
02:56:00 <iphy> https://hackage.haskell.org/package/llvm-dsl could help you implement that
02:56:28 <iphy> is there a way to find all the packages that depend on this one?
02:57:32 <yorick> can I do a constant-time comparison of two bytestrings?
02:59:18 <nomeata> https://packdeps.haskellers.com/reverse/llvm-dsl
02:59:56 <nomeata> Maybe http://hackage.haskell.org/package/knead is what I was looking for
03:00:30 <phadej> yorick: you can compare that pointers are the same, but then you might have bytestrings with same content which are not "equal", so I'd say, no.
03:00:54 <yorick> phadej: yeah, I have bytestrings with the same content that are not the same location
03:01:10 <yorick> phadej: I need a non-short-circuiting string comparison for security purposes, basically
03:01:28 <iphy> that's not constant time in the complexity sense
03:01:37 <yorick> it is not
03:03:23 <yorick> php has hash_equals for this
03:06:14 <fendor> yorick, you can do the same, hash bs1 == hash bs2 ?
03:06:27 <fendor> > hash "me" == hash "you"
03:06:30 <lambdabot>  error:
03:06:30 <lambdabot>      • Variable not in scope: hash :: [Char] -> ()
03:06:30 <lambdabot>      • Perhaps you meant ‘has’ (imported from Control.Lens)error:
03:06:34 <fendor> :/
03:06:52 <yorick> fendor: the usecase is comparing relatively insecure hash outputs
03:07:48 <yorick> the long term solution is moving to anything else
03:08:17 <fendor> what are insecure hash outputs?
03:08:38 <yorick> fendor: the current code is basically md5(a) `equals` md5(b)
03:09:30 <yorick> of course, I can do hash(md5(a)) == hash(md5(b)), but I take it there's no `safeEquals` for now
03:10:20 <yorick> in dumber languages, you'd just write a loop and set a bit, and make sure the compiler doesn't see through your tricks
03:10:47 <yorick> but I had hoped there was some primitive I was overlooking
03:11:38 <iphy> https://github.com/dmp1ce/haskell-libsodium/blob/master/src/Crypto/LibSodium.hs#L53 this is the closest I found
03:12:08 <yorick> neat :)
03:14:59 <iphy> yorick: https://github.com/jedisct1/libsodium/blob/master/src/libsodium/sodium/utils.c#L197
03:15:08 <iphy> maybe better to reimplement this in haskell, though
03:21:41 <__monty__> yorick: If the md5 hashes collide anyHash(md5(a)) and anyHash(md5(b)) would still collide?
03:23:05 <yorick> __monty__: yeah, the problem is the timing side-channel
03:25:15 <yorick> phadej: ah, I see you wrote crypt-sha512 :)
03:25:26 <yorick> phadej: why not just wrap the crypt() from libc?
03:26:23 <phadej> because GNU extensions don't exist on macOS e.g.
03:28:25 <iphy> yorick: https://github.com/jedisct1/libsodium/blob/master/src/libsodium/crypto_verify/sodium/verify.c
03:28:38 <yorick> oh yes, libsodium is pretty good :)
03:29:25 <yorick> but I doubt I can use those avx things in haskell :D
03:31:22 <iphy> https://github.com/tel/saltine/issues/28
03:32:30 <yorick> iphy: there's no reason not to do that if you're already binding libsodium/nacl, yeah
04:00:43 * hackage unicode-tricks 0.2.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.2.0.0 (wvanonsem90)
05:22:52 <sm[m]> nomeata: your first q sounded like https://hackage.haskell.org/package/inline-asm
06:12:13 * hackage rattletrap 9.0.10 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.10 (fozworth)
07:02:22 <maerwald> I can't start ghci: http://dpaste.com/3M43NK1 8.10.1 built with 'GhcProfiled = YES' and 'GhcLibWays += p'
07:03:15 <[exa]> maerwald: does the -v show any hints what could be missing?
07:04:29 <maerwald> no
07:04:43 * hackage generic-data 0.8.3.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.8.3.0 (lyxia)
07:06:34 <[exa]> maerwald: perhaps what strace shows as the last thing it tries to stat/open ?
07:07:10 <maerwald> [exa]: it obviously didn't install the profiling library, the question now is why
07:19:48 <geekosaur> because nobody installs a profiling ghci, so it's never been tested?
07:21:17 <maerwald> geekosaur: I don't know what a profiling ghci is. I just want profiling libs, to do profiling. I wasn't aware that breaks ghci and I don't think it should
07:25:26 <geekosaur> GhcProfiled=Yes, it can't make only ghc profiled but also ghci (which is really ghc --interactive), ghc-pkg, etc.
07:25:46 <geekosaur> but this implies ghc is also broken, come to think of it
07:46:21 <randomshinichi> *Main> convertTuple ("Lelouch", "Lamperouge", 10)<interactive>:28:14: error:    • Couldn't match expected type ‘Maybe (String, String, Int)’                  with actual type ‘([Char], [Char], Integer)’
07:46:36 <randomshinichi> can someone tell me why this happens since String is supposed to be an alias for [Char]?
07:47:37 <maerwald> randomshinichi: Int is not Integer
07:47:38 <glguy> Int isn't Integer
07:47:44 <maerwald> :t fromIntegral
07:47:44 <{abby}> Also you're missing a Maybe
07:47:46 <lambdabot> (Integral a, Num b) => a -> b
07:51:23 <ahri_> I've been struggling with something really trivial for too long so I've conceded that I'm missing something here... I have a cabal file with a few exes defined, I'm working on two of them (a client and server), I want to run ghcid to watch my terrible mistakes, so I need the correct ghci incantation to do this (I'm using stack but whatever) but while `stack ghci foo:client foo:server` works but prompts me 
07:51:29 <ahri_> to pick which executable I want to load, passing this to `ghcid -c` results in an error "No files loaded, GHCi is not working properly." - I tried chucking in `--load-local-deps` out of desperation but that did nothing. In the end I gave up and used `entr` to watch and `stack build ...` to give me the errors but it's so slow I'd really like to fix it!
08:01:43 <geekosaur> I think you'd have to use something like: ghcid -c 'stack ghci foo:client; stack ghci foo:server'
08:01:55 <geekosaur> might need to wrap it in a sh -c
08:04:29 <ahri_> huh, I never considered passing ghcid multiple ghci commands
08:15:12 <ahri_> geekosaur: I tried that, but ghcid only loads 1 module (the first one) and ignores changes to the second
08:15:25 <ahri_> I tried with `sh -c "..."` too
08:16:29 <randomshinichi> OK I changed it all to Integer instead of Int
08:16:46 <randomshinichi> convertTuple maybe ("Lelouch", "Lamperouge", 10)<interactive>:8:1: error:    • Couldn't match expected type ‘([Char], [Char], Integer) -> t’                  with actual type ‘Maybe Person’
08:16:47 <geekosaur> oh, ghcid's being too smart. I don't think it handles this case at all, since ghci itself can't handle more than one module with a main
08:17:26 <randomshinichi> There's nothing wrong with the line itself now, right? Something wrong with my function now
08:17:37 <geekosaur> randomshinichi, someone else also pointed out the missing Maybe. you haven't shown code so we can't say anything more than that
08:17:40 <ski> randomshinichi : "<{abby}> Also you're missing a Maybe"
08:18:25 <randomshinichi> OK here's the code https://gist.github.com/randomshinichi/dfb2accfdc10da40cdba79162e283327
08:18:49 <randomshinichi> convertTuple Maybe ("Lelouch", "Lamperouge", 10) doesn't work either
08:19:01 <randomshinichi> even when the Maybe is lowercase
08:20:28 <ski> randomshinichi : `convertTuple' only takes a single argument
08:21:10 <ski> maybe you meant to say `convertTuple (Just ("Lelouch","Lamperouge",10))' ?
08:22:01 <ahri_> geekosaur: ah, ok, that sucks for me!
08:22:11 <randomshinichi> the Just worked! oh my god thank you. I feel like a total cripple in this language
08:23:06 <ski> randomshinichi : `Maybe' is a `data' type, lives on the type level, while `Just' (and `Nothing'), its `data' constructors, live on the value level
08:23:46 <ski> randomshinichi : btw, that `read' call may fail. perhaps you'd like to capture that failure (giving `Nothing' in that case). you could try to use `readMaybe' for that
08:24:23 <ski> @index readMaybe
08:24:24 <lambdabot> Text.Read
08:24:24 <randomshinichi> thank you for the tips. might be a few days before i can understand your explanation of Maybe/Just/Nothing
08:25:43 * hackage lens-th-rewrite 0.3.0.0 - Rewrites Template Haskell splices using the API  https://hackage.haskell.org/package/lens-th-rewrite-0.3.0.0 (DavidJohnson)
08:25:49 <ski> randomshinichi : what you write after `::' are types, things that "live on the type level". also types appear in a few other places, like in `data',`newtype',`type',`class',`instance' declarations. otherwise, you're basically "on the value level", dealing not with types, but with values (of various types)
08:26:34 <ski> randomshinichi : when you wrote `convertTuple Maybe ("Lelouch", "Lamperouge", 10)' you were (a) forgetting brackets; and (b) attempting to use a type thing (`Maybe') as if it was a value
08:28:37 <ski> `Nothing' and `Just' are `data' constructors for the data type `Maybe'. `Nothing' needs no parameters/arguments, is already a value of type `Maybe T', for any type `T' you like (e.g. `Person' in your case). while `Just' must be passed a value of some type `T' (e.g. a person, of type `Person'). and will package that value up into a new value of type `Maybe T' (`Maybe Person' in your case)
08:29:28 <ski> note that `Just' is a function, you pass it a value, and it packages it up in a little box, "labelled `Just'". while `Nothing' is like an empty box (labelled `Nothing')
08:30:30 <ski> if you get a value of type `Maybe Person', that is either an "empty box" (a `Nothing'), or a box containing one item (a `Just' box), namely a person, a value of type `Person'
08:30:36 <ski> randomshinichi : does that make any sense ?
08:31:21 <randomshinichi> Yes, makes more sense. I forgot that constructors can have different names from the type.
08:31:54 <ski> yea. in fact, imho, it would be better if people didn't use the same name for a `data' constructor, as for its corresponding `data' type
08:32:28 <ski> since this tends to confuse newbies. and i don't mind writing `data Person = MkPerson ...' e.g.
08:33:17 <ski> (unfortunately, this ("punning" by reusing the same name like that) is quite common in many standard libraries, though)
08:48:13 * hackage hadoop-streaming 0.2.0.1 - A simple Hadoop streaming library  https://hackage.haskell.org/package/hadoop-streaming-0.2.0.1 (zliu41)
08:52:01 <maerwald> joeyh: do you have an issue tracker for concurrent-output?
08:56:59 <ahri_> how can I spawn a process with Haskell and have the child process's stderr just flow through to my main program's stderr?
08:58:35 <dmj`> ahri_: (_, _, Just herr, _, _) <-   createProcess (proc "ls" []){ std_err = CreatePipe }
08:58:58 <maerwald> ahri_: just like in C, if you use the unix package
08:59:11 <int-e> ahri_: use Inherit, not CreatePipe
08:59:45 <int-e> https://hackage.haskell.org/package/process-1.6.8.2/docs/System-Process.html#t:StdStream are the available options
09:00:06 <ahri_> oh neat, "inherit" is the word I should've been searching for, thank you, that's really nice
09:08:13 * hackage unicode-tricks 0.3.0.0 - Functions to work with unicode blocks more convenient.  https://hackage.haskell.org/package/unicode-tricks-0.3.0.0 (wvanonsem90)
09:15:33 <fendor> who knows what happened to Data.Array.Diff? https://hackage.haskell.org/package/array-0.2.0.0/docs/Data-Array-Diff.html
09:17:18 <hvr> $ hit provides-module Data.Array.Diff
09:17:19 <hvr> array  ^>= 0.1.0.0 || ^>= 0.2.0.0
09:17:20 <hvr> diffarray  ^>= 0.1
09:18:13 <fendor> hvr, thank you! what tool is hit?
09:18:37 <hvr> a tool I haven't relased yet :) it allows querying cabal's local package-index cache
09:20:01 <maerwald> hvr doing proprietary projects now? :P
09:20:33 <hvr> it's on github; just not yet good enough for a release =)
09:21:16 <hvr> (i.e. it doesn't meet the standard yet to be published to Hackage)
09:21:39 <seedvray> ssssssssss
09:22:28 <maerwald> There should be a code-reviewed hackage :)
09:22:58 <maerwald> Submitting a package requires a peer-review
09:23:27 <rosterok> my goal for this quarantine is to get hie working.  i may have an old version of stack.  i can't remember how i installed it.  i created a new project `stack new my-project`.  I then installed hie.  i get an error in visual code: mismatching ghc versions:  stack project is 8.8.3, hie is 8.8.2.  i tried telling code to use hie-wrapper, but i assume i need to install hie-8.8.3, but that doesn't seem to exist
09:23:40 <maerwald> rosterok: don't bother, stick to ghcide
09:24:42 <rosterok> ha.  ok.  i'll give it a shot
09:27:13 * hackage speculate 0.4.2 - discovery of properties about Haskell functions  https://hackage.haskell.org/package/speculate-0.4.2 (rudymatela)
09:29:31 <jluttine> does // have some meaning in haskell? just trying to understand this example: https://hackage.haskell.org/package/dbus and i couldn't find (//) defined anywhere so i thought if it's something built-in
09:30:03 <hyperisco> jluttine, no it is not built-in
09:32:43 <ski> @type (//)
09:32:45 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
09:32:47 <ski> @index (//)
09:32:47 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array
09:33:02 <ski> it's for (bulk) update of an (immutable) array
09:33:59 <ski> (perhaps that `dbus' package uses some other definition of it, somewhere else. but that's the first thing i can think of. it's not buit-in, no, it's just a library function (infix operator, in this case))
09:37:26 <jluttine> i made those 3 imports in ghci but still (//) wasn't in scope, so i don't understand where that example is supposed to get the definition..
09:38:16 <jluttine> if i remove those lines, it builds fine
09:39:52 <ski> which three imports ? the ones suggested by lambdabot above ? only one of them should be needed (they all export the same binding)
09:42:07 <ski> hm
09:42:26 <ski> first (looking at the example), i was thinking it was using some other definition of `(//)'
09:42:53 <ski> but i don't see any, in the modules imported in the example, and looking closer, it looks like some kind of syntactic mistake in that code snippet
09:43:19 <ski> jluttine : i think you should just remove those three occurances of `//' from that example, and hopefully it'll work, then
09:43:23 <jluttine> ski: the three imports in the example
09:43:31 <jluttine> ski: yep..
09:43:51 <jluttine> it does work if i remove them. i reported to the maintainer
09:44:46 <ski> good
10:05:53 <rosterok> `ghc --version` shows `8.8.3`, but when i run `stack build --copy-compiler-tool` in the ghcide directory it seems to build for ghc-8.6.5.  i just updated ghc.  do i need to do anything with stack itself?  very new to haskell
10:07:03 <maerwald> rosterok: stack doesn't pick up your globally installed ghc, unless you tell it to
10:07:32 <maerwald> https://docs.haskellstack.org/en/stable/GUIDE/
10:08:02 * sm[m] posts a quick intro to the haskell-based cardano cryptocurrency at https://www.reddit.com/r/haskell/comments/fv3j2h/what_does_haskell_community_think_about_cardano/
10:09:12 <maerwald> ppl still doing blockchain in 2020?
10:09:59 <Rembane> That's my first reaction too. 
10:10:06 <maerwald> market isn't growing anymore, is it? It's more like "oh, let's add that to our portfolio"
10:10:18 <maerwald> like an accessoire
10:10:29 <geekosaur> there are adds for blockchain based stuff on tv now; it's clearly over
10:10:38 <geekosaur> *ads
10:10:39 <maerwald> xD
10:10:45 <sm[m]> there's a bit more to it than that :)
10:10:56 <sm[m]> it's not ALL snake oil
10:11:46 <maerwald> I was forced to write a paper on blockchain once as a sudden measure to expand product range in some random fintech thing. I didn't even know what for, so I just wrote BS.
10:12:10 <maerwald> (the company is dead now)
10:12:35 <sMuNiX> maerwald: did your paper kill it ?
10:12:37 <maerwald> lolo
10:13:13 <maerwald> Was never published. Afair it was to get funding or pretend to customers we knew anything about what was going on
10:13:27 <geekosaur> more likely the circumstances that had them digging at blockchain without a  plan
10:14:06 <rosterok> so, `stack new my-project` seems to use 8.8.3, but `stack build --copy-compiler-tool` seems to build ghcide with 8.6.5.  then when i try running ghcide for my-project it gives me an error about the versions not matching.  what should my next step be?
10:15:03 <maerwald> rosterok: it seems you're not aware of how stack works?
10:15:14 <maerwald> I would advise to use cabal, but
10:15:20 <maerwald> https://github.com/digital-asset/ghcide/blob/master/stack88.yaml
10:15:31 <maerwald> you probably have to tell stack to use that yaml file instead of stack.yaml
10:15:56 <rosterok> thanks.  yeah, i'm not sure how any of this works.  just downloaded optics by example and it suggested to get started with stack
10:16:12 <rosterok> thanks for the help.  i'll give that a shot
10:16:29 <maerwald> stack --stack-yaml stack88.yaml build --copy-compiler-tool
10:16:31 <sm[m]> rosterok: stack uses a different ghc version for each project, as specified by resolver: in the stack.yaml file
10:16:31 <sm[m]> the user guide explains all
10:17:09 <maerwald> sm[m]: *may* use a different ghc version
10:17:13 <rosterok> i get that.  i just wasn't sure if i should update ghcide or point my-project to the ghcide version since it seems older
10:18:13 <maerwald> cabal in fact, may too, when specified in cabal.project
10:21:13 * hackage tracing 0.0.5.0 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.5.0 (mtth)
10:41:20 <joeyh> maerwald: no, but email is ok
10:42:37 <maerwald> joeyh: I noticed when I have a region and stuff is printed normally to stdout before the region was created... and then the terminal resizes... it may just wipe out all the previous stuff
10:42:53 <maerwald> would probably take me a while to assemble a minimal example
10:43:41 <geekosaur> that's up tothe terminal mwhether stuff outside the region is saved or not, there's a terminfo flag for it iirc
10:44:08 <maerwald> I found it pretty glitchy in sakura, which uses vte
10:46:05 <maerwald> geekosaur: but it's only on resizing
10:46:38 <maerwald> and then sometimes it keeps stray lines of its own outside the region
10:46:38 <geekosaur> that could be a bug in the terminall
10:46:53 <maerwald> with no resizing, it seems fine
10:47:16 <geekosaur> display_above, display_below, non_dest_scroll_region are relevant flags but I don't think there's one for resizing vs/ scroll region
10:47:23 <maerwald> well, most terminals are based on vte these days I think
10:50:08 <geekosaur> didn't see one. behavior probably not defined
11:06:59 <welcome> Im trying to install ghc-mod and I'm in dependency hell. Im on Unix. Is there a command that just installs everything?
11:07:38 <Rembane> welcome: Which Unix?
11:07:51 <welcome> Mac OS 
11:08:25 <maerwald> welcome: wait, what? ghc-mod? :>
11:08:38 <welcome> yes
11:08:39 <Rembane> welcome: Why are you trying to install ghc-mod?
11:09:01 <welcome> to setup a vim environment
11:09:04 <gcoakes[m]> It looks like ghc-mod is unmaintained. Is that not correct?
11:09:11 <maerwald> welcome: ghc-mod is deprecated as a user-facing tool
11:09:23 <maerwald> welcome: try https://github.com/digital-asset/ghcide
11:09:50 <welcome> will do
11:10:16 <maerwald> gcoakes[m]: not unmaintained, but it's more like a "library" now
11:10:17 <maerwald> or somesuch
11:10:28 <maerwald> I don't think anyone really knows the scope anymore
11:11:54 <gcoakes[m]> I've just given up on having a language server for haskell. I use ghcid until these things get all sorted out.
11:12:09 <maerwald> yes, I also don't use one, I use ghci
11:12:49 <maerwald> Makes you more disciplined too. It's enjoyable if you've coded for 30 minutes and the result compiles
11:14:02 <Rembane> I use stack with build --test --file-watch 
11:17:38 <sm[m]> Rembane: you can add —fast to that
11:19:35 <Rembane> sm[m]: Nice! Thank you! 
11:22:13 * hackage ngx-export-tools-extra 0.4.1.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.4.1.0 (lyokha)
11:24:30 <sm[m]> (But when you’re just tweaking code, ghcid is truly faster - no linking)
11:26:40 <jumper149> Should I derive all instances that make sense or all instances that I need?
11:27:39 <Rembane> jumper149: All instances that you need imo, then you won't wonder some months later where you use that Ord instance.
11:29:19 <solonarv> I usually default to deriving Show for debugging, and Eq,Ord because I use Map a lot (this is for parameterless types)
11:38:02 <jumper149> I'm not coming to a satisfying conclusion but I think I will stick to what is needed.
11:39:13 <dmwit> Derive all the instances.
11:39:24 <dmwit> You'll discover later that you needed them, and the cost is very, very low.
11:39:51 <dmwit> I have keybindings for inserting `deriving (Eq, Ord, Read, Show)` and `deriving (Bounded, Enum, Eq, Ord, Read, Show)`.
11:39:58 <dmwit> Never been sad about having done it.
11:40:14 <jumper149> What about Generic? Should I import it everywhere just to derive it?
11:40:34 <solonarv> no, only do that if you are actually using it
11:40:49 <solonarv> or do as dmwit does and just add Generic to that list
11:41:06 <solonarv> it doesn't matter much because the cost is low either way
11:41:33 <dmwit> I think you can skip Generic most of the time.
11:43:04 <solonarv> oh, also when possible I add (Functor, Foldable, Traversable)
11:43:28 <solonarv> GHC conveniently knows how to derive those as well
11:45:15 <jumper149> Can I import Generic everywhere with cabal?
11:46:25 <solonarv> no, you can't make cabal stick 'import Generic' declarations at the top of every omdule
11:46:43 <solonarv> just write the import when you need it
11:48:01 <jumper149> I'm still having mixed feelings about it...
11:48:20 <solonarv> about "it"? about what, exactly?
11:48:43 <jumper149> adding not used instanced
11:49:41 <geekosaur> they cost nothing except a tiny amount of space
11:52:21 <jumper149> I do have one good argument for adding them: Orphan instances are not wanted, so there is no harm with adding all the instances. :)
11:52:53 <solonarv> orphan instances aren't relevant to this discussion if you are writing an application
11:53:25 <solonarv> if you find that you need an instance you didn't have yet, you just modify the file where the datatype is defined and add that instance
11:56:38 <sm[m]> dmwit / solonarv: I thought some deriving (eg Generic ?) is rather expensive, slowing down compilation quite a bit
11:56:46 <sm[m]> s/is/can be/
12:01:21 <solonarv> yes, that might be a reason to avoid deriving unneeded instances
12:01:40 <geekosaur> that's why solonarv said no at first, Generic is fairly exensive. most others are cheap
12:02:55 <sm[m]> what about Default ?
12:05:40 <geekosaur> can't be derived afaik
12:06:18 <sm[m]> huh. Maybe I'm thinking of something else.. Typeable ?
12:06:48 <geekosaur> that's wired in, every type internally has Typeable derived for it
12:07:14 <geekosaur> the only question is whether it's exposed
12:07:48 <sm[m]> I see
12:08:30 <sm[m]> Data ?
12:08:36 <sm[m]> also cheap ?
12:09:00 <geekosaur> I  think the only potentially interesting one, yes, because it's most of Generic
12:10:04 <jumper149> > data A = A | B Bool deriving (Enum, Eq, Ord, Read, Show)
12:10:06 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
12:10:25 <solonarv> lambdabot isn't a ghci session, > must be followed by an *expression*
12:10:26 <jumper149> Why isn't it possible to derive Enum here? Or is it only not implemented?
12:10:29 <geekosaur> DerivingVia might be expensive depending on how it's used
12:10:43 <geekosaur> jumper149, lambdabot is not ghci. "data" declarations aren't valid
12:11:00 <solonarv> DerivingVia is exactly as expensive as GeneralizedNewtypeDeriving
12:11:15 <jumper149> Ok guys I just wanted to ask about the Enum thingy ^^
12:11:19 <ski> @let data AB = A | B Bool deriving (Enum,Eq,Ord,Read,Show)
12:11:20 <lambdabot>  .L.hs:242:23: error:
12:11:20 <lambdabot>      • Can't make a derived instance of ‘Enum AB’:
12:11:20 <lambdabot>          ‘AB’ must be an enumeration type
12:11:34 <solonarv> well, I guess the instance you're reusing is more likely to be complicated in the case of DerivingVia
12:11:42 <geekosaur> because the spec says so, basically
12:11:48 <dmwit> jumper149: Yes, it should be possible in principle. However, it would have to be a language extension; the Report says only types with fieldless constructors are eligible.
12:11:56 <geekosaur> there's an obvious derivation but the spec is conservative
12:11:58 <ski> jumper149 : because there are "non-constant" `data' constructors, ones which take arguments (ones which are functions)
12:12:37 <ski> you could manually make an `Enum' instance, if you wanted to
12:12:42 <dmwit> Also keep in mind that it's trickier than it may seem on the surface if you want to actually use the fields' Enum instances.
12:12:57 <dmwit> In particular: Enum doesn't promise that enumerations start at 0, or that they are contiguous.
12:13:20 <dmwit> So you'd probably need some stronger constraint than just Enum to be able to do anything sensible. Certainly you'd need at least Bounded.
12:13:35 <fishooter> Hi :) I'm trying to setup hspec for unit tests. If I put Spec.hs auto-test-discovery file in the same folder as other *Spec.hs files, it works fine. However, if I put the *Spec.hs files into subdirectories, these files are not discovered anymore. I thought that should work, as it is done this way in the example here: https://github.com/hspec/hspec-example/tree/master/test 
12:13:40 <fishooter> what did I miss?
12:13:44 * koz_ mumbles something about Data.Finitary. :P
12:14:36 <dmwit> Oh? Do you have some deriving mechanism set up for Finitary?
12:14:42 <koz_> Yeah, via Generic.
12:14:45 <dmwit> Nice!
12:15:11 <jumper149> dmwit: Ah I see your point. The trivial implementation would be different for Bounded and unbounded types.
12:15:48 <geekosaur> no, you can't sensibly do unbounded types. where do you start it?
12:15:59 <dmwit> (Oh, and: Enum doesn't promise that enumerations cover the entire space!)
12:16:10 <dmwit> geekosaur: Sure you can. See e.g. Universe =)
12:16:15 <geekosaur> where do you start enumerating an Integer?
12:16:15 <jumper149> You could start with `toEnum 0`
12:16:18 <dmwit> geekosaur: at 0
12:16:26 <dmwit> geekosaur: Then 1, then -1, then 2, then -2, ...
12:17:05 <jumper149> > toEnum 0 :: Integer
12:17:07 <geekosaur> heh. I guess, although I though there was an assumption somewhere about Enum vs. Ord
12:17:08 <lambdabot>  0
12:17:20 <geekosaur> that bit someone not expecting it
12:18:05 <jumper149> > toEnum <$> [0..] :: [Integer]
12:18:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:18:19 <jumper149> Ye that's a problem^^ 
12:19:08 <dmwit> jumper149: But yes, if you'd like to see a more seriously worked example of a class that does handle this kind of stuff, check out my universe package or koz_'s finitary package.
12:22:30 <jumper149> Seems like a cool package :) and holy shit why is this documentation so fancy https://hackage.haskell.org/package/finitary-1.2.0.0/docs/Data-Finitary.html
12:22:49 <fog> whats a stream where the tail is in a monad?
12:23:00 <koz_> jumper149: Because I care very much about documentation. :P
12:23:16 <koz_> fog: Is your goal to do streaming in a monadic context?
12:23:27 <koz_> If so, you have an embarassment of riches at your disposal.
12:23:40 <fog> hmm
12:23:44 <fog> idk
12:24:03 <fog> its something like fix pair but with one side wrapped in the monad
12:24:14 <fog> im trying to find the implementation hang on
12:24:32 <fog> (it should be clear from the definition what its for..)
12:25:02 <fog> i cant write it in less than 2 lines...
12:25:09 <fog> newtype Stream_ m a = Stream (a, Stream m a)
12:25:15 <fog> type Stream m a = m (Stream_ m a)
12:25:44 <monochrom> Some people called it "ListT done right"
12:25:50 <fog> its kind of wierd because to pattern match on the datatype, you first have to retrive the contents within a monadic context
12:25:57 <monochrom> But Oleg just calls it stream.
12:26:10 <fog> monochrom: what, that thing I just wrote? or some other thing?
12:26:16 <koz_> fog: There's a whole tonne of those.
12:26:17 <monochrom> That thing.
12:26:23 <koz_> Every monadic streaming library does something like this.
12:26:26 <fog> ooh! im glade i done it right
12:26:57 <monochrom> It is designed so that "the next item", even "the rest of the stream", can be determined by effects rather than pure math.
12:27:02 <dmwit> fog: A slight variant of the thing you wrote that also supports nils.
12:27:15 <fog> ah right, yeah, this is a stream, not a list
12:27:16 <dmwit> (...is called ListT done right)
12:27:20 <monochrom> (Observe that a simplistic "m [a]" is completely off.)
12:27:47 <koz_> http://hackage.haskell.org/package/streamly-0.7.1/docs/src/Streamly.Internal.Data.Stream.StreamK.Type.html#Stream
12:27:52 <koz_> One example of such a thing.
12:27:53 <maerwald> so much fuzz about what is esentially a for-loop :>
12:27:57 <koz_> (this is also CPSed)
12:28:08 <monochrom> "ListT done right" also has an end-of-list case but that's a trivial addition and is not the main point.
12:28:36 <koz_> The README for this explains why m [a] is borked: http://hackage.haskell.org/package/streaming
12:28:50 <fog> hmmmm
12:28:58 <monochrom> Yes maerwald, until you desire to interleave two for-loops.
12:29:02 <fog> not sure this was the answer i expected... 
12:29:03 <maerwald> yeah
12:29:19 <fog> i thought i was doing something wrong...
12:29:21 <maerwald> and now you can also define a strategy on how to run them
12:29:34 <monochrom> fog do you sincerely and seriously expect that there are things to learn?
12:29:34 <fog> well, i could paste my helper functions...
12:29:36 <dmwit> for loops. so much fuzz about what is essentially a while loop.
12:29:48 <monochrom> Because learning implies there will be answers you don't expect.
12:29:49 <fog> monochrom: yes, it was crashing a lot
12:29:51 <koz_> while loops. so much fuzz about what is essentially a GOTO with some state.
12:30:04 <dmwit> koz_ gets it
12:30:18 <Rembane> GOTO with some state. So much fuzz about what is essentially a jump with flags.
12:30:22 <monochrom> If everything is within your expectation, there is nothing left to learn.
12:30:45 <koz_> A jump with flags. So much fuzz about what is essentially pushing some electrons around.
12:30:45 <{abby}> Jump with flags. So much fuzz about what is essentially a tail call.
12:30:58 <Rembane> Oh no, we branched.
12:31:08 <monochrom> I don't understand why people keep saying "I want to learn this" and then go into denial mode when there are really new things, unintuitive things, worth-your-time-to-learn things.
12:31:16 <maerwald> monochrom: not learning isn't what scares ppl, but imagine the boredom if there's no surprise
12:31:16 <monochrom> Unless they're complete hypocrites.
12:31:18 <dmwit> branches. so much fuzz about what is essentially quantum mechanics
12:31:50 <Rembane> Quantum mechanics, so much fuzz about what is essentially ... IÄ IÄ CTHULHU F'TAGHN!
12:32:00 <monochrom> no, complex numbers
12:32:08 <fog> heres what i had so far; https://pastebin.com/raw/vuFjfhiz 
12:32:21 <{abby}> Quantum mechanics, so much fuzz about what's essentially fuzzy mechanics :P
12:32:31 <geekosaur> I don't see a branch, I see two ways of citing QED :p
12:32:49 <koz_> fog: How come you're rolling your own monadic streams?
12:32:58 <koz_> Like, you _do_ know about a thousand libraries exist for this?
12:33:22 <fog> yeah, but its easier to do what makes sense than try and understand some bizzare implementation of the same thing
12:33:23 <monochrom> free monads, so much fuzz about that's essentially a recursive algebraic data type
12:33:37 <fog> it makes the libs easier to understand if you already ended up having to write them yourself
12:33:55 <fog> i was thinking something like conduit might be useful
12:33:55 <koz_> fog: Uhhh... I mean sure, if you want.
12:34:03 <fog> well, its actually faster also
12:34:08 <koz_> I favour Streamly (if I'm in IO already) or streaming (if not).
12:34:10 <fog> its kind of a lazy hack
12:34:11 <monochrom> I did roll my own things for learning.
12:34:12 <maerwald> conduit isn't a streaming library :P
12:34:22 <geekosaur> "soon: there are 15 competing standards"
12:34:30 <fog> conduit just because i was having to compose things
12:34:35 <maerwald> it has a notion of streaming processor, you're not working with actual streams
12:34:36 <fog> i guess they should be traversable
12:34:36 <monochrom> Like, when I learned free monads, I totally didn't use the free monad package.
12:34:57 <dmwit> I, too, have rolled my own to help me understand things. It's very enlightening.
12:34:58 <maerwald> streaming and streamly are the popular choices for *streaming* libraries
12:35:05 <monochrom> But be assured that I am not uploading my own either!
12:35:08 <fog> i thought i could just make it do what i needed it for and then see how it compares with existing stuff
12:35:25 <fog> and use their solutions to make it more modular and complete, and compositional
12:35:32 <monochrom> Hell in the early days I wrote my own "instance Monad Maybe" too.
12:35:46 <maerwald> I'm not sure how streamly compares with streaming. I believe streaming might be used more in production (but that's just a gut feeling from haskell meetups)
12:35:54 <dmwit> Like a coworker added Lambda as a constructor to a DSL I was creating. And I didn't understand the fields at all. So I added it myself, and lo and behold I got the exact same collection of fields.
12:36:06 <fog> right, but about *this* code...
12:36:15 <koz_> maerwald: Considering I subcontract for a non-trivially sized organization which funds Streamly and uses it in prod... yeah. :P
12:36:26 <monochrom> Writing it helped me learn that >>= is forced to be less lazy than pure function application.
12:36:45 <maerwald> koz_: yeah, I have never used streaming, only streamly and conduit
12:36:58 <maerwald> but to do anything with streamly you need to tap deep into internal modules
12:37:03 <maerwald> which isn't that cool
12:37:04 <fog> like, i could learn streamly and do the comparison myself, but for people that already know the common approaches, they might be able to see something in this kind of ad hoc approach that is worth discussing
12:37:17 <koz_> maerwald: Yeah... documentation and the way the library is arranged is far from ideal, agreed.
12:37:44 <maerwald> and Folds and Unfolds still feel a bit odd, especially when there are IO resources involved
12:37:45 <monochrom> Oleg has a million articles on Steam = m (a, Stream)
12:37:58 <koz_> maerwald: Also agreed.
12:38:01 <fog> streamHandler :: Monad m => [b] -> ([b] -> a -> m b) -> Stream m a -> Stream m b
12:38:16 <fog> this stores all of the previous values
12:38:18 <maerwald> basically, you end up having a Stream that hides the fact that there's a resource under the hood and that you must not consume it twice
12:38:22 <maerwald> so many gotchas
12:38:34 <fog> it reminded me of something like paramorphisms or something
12:39:23 <monochrom> Right, linear access is not enforced by types in Haskell.
12:39:35 <monochrom> "Linear types can save the streams!"
12:39:53 <monochrom> err maybe not "save" in the other sense...
12:40:38 <fog> ah, i remember now
12:40:47 <fog> it was supposed to be to observe the monadicity of lists
12:41:01 <fog> thats what the "chunk" and "spread" functions are for
12:41:10 * dmwit . o O ( streamHandler :: Monad m => b -> (b -> a -> m (b, [c])) -> Stream m a -> Stream m c )
12:41:46 <fog> no, the carry doesnt end up in the monad
12:42:03 <dmwit> Use NonEmpty c instead of [c] if you want to guarantee stream productivity, though keep in mind that this may hurt programmer productivity.
12:42:18 <maerwald> koz_: and finallyIO is a GC hook
12:42:51 <maerwald> Weird, I can't find the issue where we discussed the resource handling. It must have been on gitter. Damn gitter.
12:43:57 <fog> not going to bother with nonempty for now - sure, streams lists and nonempty all have different types for traverse, and only nonempty is actually a monad 
12:44:25 <fog> but still, i can make a stream into a stream of lists, which is about as monadic as making a nonempty into a nonempty of nonemptyies
12:44:53 <fog> co-monadic. and then obviously joining them up again
12:45:24 <fog> but as far as "real" traverse, and monad and comonad instances go, i doubt id find these in the streamly libs or anywhere
12:46:25 <fog> and anyway, with the extra monad, im not sure how that interacts with turning the spread function into a propper implementation of join would go
12:47:35 <maerwald> koz_: and things like https://github.com/psibi/streamly-bytestring/issues/7
12:47:48 <maerwald> "Please avoid using this routine in strict monads like IO unless you need a strict right fold." :>
12:47:50 <fog> does Nonempty_T done right have a Monad instance?
12:47:59 <maerwald> and then oops
12:48:09 <maerwald> this is hard when you combine things to higher abstractions
12:48:18 <maerwald> documentation doesn't propagate up ;)
12:48:30 <dmwit> I don't see an obvious reason that NonEmptyT shouldn't have a Monad instance. ListT does, and NonEmpty does.
12:48:55 <dmwit> I have no idea what you mean by "only nonempty is actually a monad". Streams, lists, and NonEmpty are all monads.
12:49:10 <fog> wait, is it cojoin that nonempty but not list has?
12:50:00 <fog> yeah, comonad, not monad, sorry
12:50:06 <fog> but yeah, thats why to use nonempty
12:50:39 * dmwit scratches his head
12:50:41 <fog> calling strams monads under concatination is pretty useless since each stream is infinite...
12:51:12 <dmwit> I'm not sure anybody claimed streams were monads under concatenation.
12:51:29 <fog> yeah, they would have to use head?
12:51:38 <dmwit> what
12:51:49 <fog> join would be fmap head
12:52:09 <fog> maybe thats why nonempty is used for monad? because then head is safe
12:52:12 <dmwit> No, it's diagonalization.
12:52:25 <dmwit> (!!0), then (!!1), then (!!2), then (!!3), etc.
12:52:28 <fog> oh, like the nth stream has its nth value taken
12:52:59 <dmwit> (Another way to understand it: (r ->) is a monad for any r, and in particular (Natural ->) is a monad.)
12:53:16 <fog> but like, if traversing a monadic stream, (or list, so it can terminate) how do you "commute through the monad" ?
12:53:47 <dmwit> I dunno. Is it hard?
12:53:48 <fog> dmwit: but list is not a comonad?
12:53:59 <dmwit> ReaderT exists. Perhaps you can just steal its instance, up to a suitable isomorphism.
12:54:26 <fog> idk, i dont know what all the monads are doing, maybe if its a state or something i might mess up the instance by commuting it wrong
12:54:44 <fog> i have no intuition for what properties should hold
12:55:16 <fog> i get, traversing a container, and comuting the applicative returned over each value, with the traversable container
12:55:36 <fog> but if each value is with IO or something, then how can this make sense?
12:55:52 <fog> i think i get scared about side effects
12:55:57 <monochrom> Why are you studying this?
12:56:13 * hackage sak 0.1.2.0 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.2.0 (vmchale)
12:56:21 <fog> well, because without a traversable instance, my monadic streams have an unwieldy api
12:56:49 <dmwit> Oh, I don't see a way for you to have a Traversable instance for StreamT.
12:56:58 <monochrom> OK, sounds like an XY problem.
12:57:00 <dmwit> Not a sensible one, anyway.
12:57:02 <maerwald> it all started with a reddit thread about the latest cool streaming API
12:57:08 <monochrom> So, why are you studying this again?
12:57:11 <dmwit> So better give up on that dream and think up a different dream.
12:57:52 <fog> and, as the thing i wrote it for, which was "chunking" up a deamon that was dumping files full of lists, into reprocessed lists, then this Comonadic chunking seemed like the abstraction being sought
12:58:02 <dmwit> (Why no Traversable instance? Because there are infinitely many contained values, and since Traversable instances traditionally iterate over all contained values, the iteration would never finish.)
12:58:11 <monochrom> I ask becasue you were asking why "m (a, Stream)" so implicitly "why not simply (a, Stream) and get rid of the monad".
12:58:26 <fog> well thats why you move to nonempty or list...
12:58:48 <monochrom> And if you see the point of that extra "m" if you don't have your own good purpose for studying this.
12:58:55 <fog> and anyway, isnt there a kind of "early escaping" thing like traversal that does not have to preserve input length
12:59:06 <monochrom> err
12:59:13 <monochrom> And you won't see the point of that extra "m" if you don't have your own good purpose for studying this.
12:59:26 <fog> wait, is what i wrote equivalent to what you wrote?
13:00:02 <fog> newtype Stream_ m a = Stream (a, Stream m a); type Stream m a = m (Stream_ m a)
13:00:43 <fog> im deploying a tool to a server, that consists of handling web api streams
13:01:21 <monochrom> "I don't know why but this library makes me do it" is a cargo-culting answer.
13:01:30 <fog> so it should consist of passing the stream through various forked threads, each reading them from a directory having the previous results written to 
13:01:56 <fog> no, this is the design i have devised to handle a real world problem i face
13:02:46 <monochrom> Come back when you really figure out why neither [a] nor NonEmpty a nor "X a = Cons a (X a)" is enough.
13:02:47 <fog> as the rest of the stream might not have been obtained, as the api calls request new data every few seconds, I have to store the tail in IO
13:03:24 <monochrom> No, IO is not about storing.  You aren't even ready for IO.
13:03:27 <fog> monochrom: could be less disparaging please? your criticisms really are a stretch to see their relevance. 
13:03:34 <dmwit> "it should consist of passing the stream through various forked threads, each reading them from a directory" What does "it" refer to? What does "them" refer to?
13:04:31 <nshepperd2> dmwit: there are lazy applicatives that you could traverse over infinite streams. like lazy StateT. or splitting based randomness monads
13:04:32 <monochrom> Relevance? OK.
13:04:34 <fog> it is a program i am writing, them are the streams
13:04:50 <dmwit> "im deploying a tool to a server, that consists of handling web api streams" Is it the tool or the server that consists of handling web api streams?
13:04:53 <monochrom> You are not getting the relevance of that "m" or specifically why IO could be involved.
13:04:58 <maerwald> they don't want help with the problem, but help with the tool :)
13:05:03 <fog> monochrom: but your joking when you say "your not ready for IO"? 
13:05:07 <monochrom> And for the record I already gave an accurate answer very early on.
13:05:20 <monochrom> So come back after you read that.
13:05:24 <fog> i just dont want to be insulted for no reason
13:05:37 <monochrom> I am serious.
13:05:50 <monochrom> This is not an insult, this is an assessment
13:05:51 <dmwit> You say "passing the stream through various forked threads", which implies a single stream. You also say "reading the streams from a directory", which implies multiple streams. What gives?
13:06:04 <monochrom> If you say "store in IO" you are totally wrong.
13:06:37 <dmwit> Or: You say "passing the stream through various forked threads", which consumes a stream. But you also say the threads "read the streams from a directory", which produces a stream. What gives?
13:07:36 <fog> ah, ok, so this is the stream at each different stage of processing. so, i get the data from a web api and write it to a file, process #1. then, because the subsequent api calls return some dumplicate data, i restream it, reading the stream of files from the directory, mapping a function that reads the files into a list, and then "spreading" these
13:07:36 <fog> lists, and "chunking" back to make files of a set length
13:08:15 <fog> monochrom: i defer the evaluation of the tail, by wrapping it in IO, which can be blocking on retriving the value within the monadic context
13:08:48 <monochrom> [a] defers evaluation of tails too.
13:09:12 <monochrom> NonEmpty a does that too.  "X a = Cons a (X a)" does too.
13:09:37 <fog> dmwit: so this dumps the now nicely rechunked files into a new directory, and i could keep populating new directories, with various forked processes turning getDirectoryContents into a IO stream
13:10:23 <dmwit> This seems like an awfully complicated architecture.
13:10:35 <dmwit> Especially if you hope for one thread to be a producer and another thread a consumer of one of these streams.
13:10:39 <fog> monochrom: but with these pure values being available immediately? like what happens if i try and fold a half existing list, oh i cant have that even, since i couldnt unpack the tail from IO 
13:10:48 <dmwit> It means each stream action will have to do interthread communication. Is that really what you've cooked up?
13:11:00 <fog> no, no interthread coms
13:11:09 <dmwit> ("each stream action": the IO (a, Stream IO a) actions)
13:11:31 <fog> it just sits watching a directory fill up, processes the contents as they arive and dumps the output in a new directory, one dir per thread
13:11:53 <fog> so i can have distributed parallel processing
13:12:04 <fog> i can have these dirs on different machines even
13:12:15 <fog> and the threads running on different processors
13:12:28 <fog> i dont know why the approach seems to be distressing...
13:12:31 <dmwit> Nothing in that description sounds easier to implement with streams than without.
13:12:37 <dmwit> To me, at least.
13:12:49 <fog> it has to be an IO stream
13:13:13 <fog> the tail has not yet been delivered, it has to wait for it to do so, and with real world time and reading from files, its all IO
13:13:28 <monochrom> So use >>=
13:13:29 <dmwit> Why does "it has to wait" imply "it has to be a stream"??
13:13:43 <fog> well, its not certainly finite
13:14:01 <monochrom> This is growing into a multidimensional XY structure.
13:14:03 <dmwit> Why does "it has to wait" and "its not certainly finite" imply "it has to be a stream"?
13:14:07 <fog> infact, its distinctly not finite, these api calls can be made indefinately 
13:14:25 <dmwit> Why does "it has to wait" and "it's definitely infinite" imply "it has to be a stream"?
13:14:25 <fog> streams are infinite lists... thats a pretty basic point
13:14:56 <dmwit> For example: `forever getLine` is infinite and has to wait.
13:15:01 <dmwit> ...but is not a stream.
13:15:24 <fog> you would be wrong to use a list for that, you dont need to handle []
13:15:37 <dmwit> Both a list and a Stream would be wrong for that.
13:15:51 <dmwit> ...which is kind of the point I'm trying to make.
13:16:04 <fog> im not going to argue about why streams are more appropriate for strictly infinite lists than lists are. this is just a strange conversation  
13:16:11 * dmwit shrugs
13:16:39 <dmwit> You have a question. You can try to find the interesting thought to think in the things people are saying while trying to answer it, or you can abandon the conversation. I certainly know which I think would be more productive.
13:16:39 <monochrom> All of your conversations have been strange, if you haven't noticed.
13:16:51 <fog> i dont see how infinite streams are wrong for infinite streaming data 
13:17:10 <fog> monochrom: lost in translation no doubt
13:18:54 <maerwald> well, time for a whisky
13:19:00 <monochrom> What was the question again?  You didn't know how to work with "IO (a, Stream a)"?
13:19:19 <monochrom> because the answer would be ">>=".
13:19:25 <fog> anyone reading, including me, could be helped by the discussion surrounding traversing monadic streams, and their (co)monadicity, and how to do this properly, and less so by metacometary i can avoid saying this
13:20:01 <monochrom> No, discuss >>= first.
13:20:04 <fog> monochrom; im not even sure thats an isomorphic datatype to the one i have
13:20:06 <dmwit> I guess I will try one last time: having the concept of monadic streams in your head while writing some simple code is not the same thing as saying "`StreamT IO X` is the right abstraction to use here".
13:20:53 <fog> thats ok. makes me wonder what criteria would be better to make that assesment
13:21:39 <fog> one question is certainly when that is the right abstraction, another is how to work with it
13:21:53 <dmwit> I think my criteria would be: are there multiple streams from different, unpredictable providers that I want to combine? If no, then do away with the abstractions and write simple code.
13:22:06 <dmwit> To me it sounds like there is 1. just one stream 2. from a predictable provider (you).
13:22:14 <dmwit> So it fails both criteria for using high-powered abstractions.
13:22:32 <fog> but it arrives in IO, in a stream, so what else should i use!?
13:22:37 <dmwit> IO
13:22:42 <monochrom> >>=
13:22:59 <monochrom> for the 3rd time or something
13:23:02 <maerwald> a reasonable technology-complexity balance evaluation....from a haskeller... what? :D
13:23:03 <fog> so if i have a getDouble :: IO Double
13:23:47 <dmwit> maerwald: I know, I feel gross. This "having a job" thing has really changed me. =P
13:23:50 <monochrom> Tell me this is not another of your episode of fetish with any word containing "travers" as a prefix.
13:24:12 <monochrom> getDouble >>= \x -> print (x + 3)
13:24:13 <fog> and i do, let streamDoubles = pause 1 >> getDouble >>= \d -> fmap (d:) streamDoubles
13:25:22 <dmwit> Well, you definitely don't do that.
13:25:37 <fog> right, because i would be waiting a long time to be able to call head
13:25:44 <fog> it having been fmapped over all the pauses
13:25:47 * dmwit nods agreeably
13:26:00 <fog> so, i use my nice IO tail
13:26:14 <fog> can get the head no bother, tail sits there waiting to exist
13:26:19 <dmwit> no
13:26:33 <fog> hmm
13:26:37 <fog> what went wrong?
13:26:42 <dmwit> You just `processDoubles = pause 1 >> getDouble >>= \d -> doSomethingFancy d >> processDoubles`
13:27:00 <dmwit> Or maybe you need to accumulate some information about previous doubles! No problem.
13:27:19 <fog> your saying i cant make them into a list
13:27:20 <dmwit> `processDoubles acc = pause 1 >> getDouble >>= \d -> doSomethingFancy acc d >>= processDoubles`
13:27:28 <fog> i have to do what i want with the head right there and then
13:27:51 <dmwit> You have a choice. You can do what you want with the head right there and then, or you can wait until you have them all.
13:27:54 <dmwit> You can't have both.
13:28:04 <fog> i can make a nice IO stream!? why not?
13:28:07 <dmwit> Even fancy stream transformers can't save you from that choice.
13:28:26 <dmwit> There's no reason why not. But then when you process that IO stream, you handle the head right there and then, or you wait until you have them all.
13:28:39 <fog> yeah but i can at least have a representation for tail might not have arived yet because the cons is sat within the IO
13:28:41 <dmwit> So if you have to make that choice anyway, why not just make it and be done with it?
13:29:02 <dmwit> Why represent the tail, instead of just *doing* the tail?
13:29:30 <fog> so, the argument is that the nice IO stream api can be avoided by an equivalent alternative technique, and there must be arguments for and against each option
13:29:31 <dmwit> (My answer: represent the tail when you want to do some interesting processing of it -- like combine it with a stream provided by some other unpredictable source. But you don't have that problem, so don't try to solve it and add complication!)
13:30:00 <dmwit> Sure, I have no objection to that summary, though it doesn't have a ton of content in it.
13:30:32 <fog> i mean, i *might* want to combine streams, i just started writing this a few days ago, and thankfully have only had simple use cases
13:30:52 <dmwit> YAGNI
13:31:11 <fog> my main concern right now is that as i just through it together, it has terrible compositionality and no traversable or monad instances, like the lists i know and love
13:32:04 <fog> it seemed similar to pipes, i thought some nuce things had a better way
13:32:19 <fog> mice*
13:32:23 <fog> ...
13:32:38 <fog> even my keyboard hates me
13:33:01 <Rembane> Of mice and keyboards.
13:33:31 <fog> so, i like the idea of just saying the word (>>=) and this somehow being enough to make all stream libraries go away, but i really dont understand it
13:33:47 <fog> despite it having been said thrice, there was no explanation as to what was meant
13:34:04 <Rembane> fog: Do you have enough information to try to implement it? 
13:34:12 <dmwit> Wow.
13:34:15 <dmwit> I feel seen.
13:34:26 <fog> Rembane: im not sure what your asking
13:35:24 <dmwit> I posted actual code to explain what I meant.
13:35:41 <Rembane> fog: Well, maybe you don't understand it until you have an implementation or have a more concrete way to fail.
13:36:01 <fog> so you would somehow have to commute the action through the program to that point, instead of passing the datatype, and accessing its contents
13:36:24 <dmwit> How many different actions do you anticipate needing to choose between?
13:36:26 <fog> Rembane: its happily sat on a server processing data streams
13:36:30 * dmwit guesses the answer is 1
13:37:15 <dmwit> Specifically: "read the directory contents from HERE and write it out to THERE"
13:37:29 <Rembane> fog: That's good. Why did you need to change it? 
13:38:41 <fog> dmwit: a common use case was something like, stream the results of ls called every few seconds. read the files by mapping over the stream of filepaths, processing the contents of the file into a list. "spread" the lists, to make a stream of values. filter this for duplicates, rechink the stream into set length lists, write these to the output file 
13:38:45 <maerwald> I still haven't figured out why not use streamly xD
13:38:56 <koz_> Is there something in QuickCheck which is like elements, but generalized to any Foldable?
13:39:10 <koz_> So something to the tune of 'Foldable t => t a -> Gen a'?
13:39:17 <koz_> (with similar partiality caveats)
13:39:21 <fog> Rembane: the things i was lacking were classes such as Monad that could cature the "spread" opperation
13:39:23 <dmwit> fog: I don't see anything in that description that sounds like it would be hard with plain IO and recursion.
13:40:02 <maerwald> with streamly you could just use (>>=) :P
13:40:31 <fog> wait, why does everyone hate monadic streams!? 
13:40:33 <dmwit> koz_: elements . toList ? =)
13:40:42 <maerwald> https://hackage.haskell.org/package/streamly-posix-0.1.0.0/docs/Streamly-External-Posix-DirStream.html
13:40:45 <koz_> dmwit: I guess I should have gone for the obvious answer first lol.
13:41:05 <koz_> fog: I should also mention streamly-fsnotify exists. :P
13:41:50 <maerwald> koz_: I find the cross-platform goals of streamly a bit annoying
13:42:01 <maerwald> But I guess that's what you get if you want to overtake base
13:42:03 <fog> hmm, streamly look much like what i was doing, and not much like what i was being discouraged into doing
13:42:32 <dmwit> I wonder whether there's any better/more general abstraction for data structures that support efficient indexing than the obvious `class Indexable f where (!) :: f a -> Int -> a`.
13:42:48 <fog> anyway, i must appologise for the vexation, ill catch up soon 
13:42:53 <koz_> dmwit: Representable with (Finitary n) on one side. :P
13:43:13 <dmwit> koz_: But I don't promise that the same indices are in bounds for all instances of `f a`.
13:43:15 <koz_> s/Representable/Adjunction.
13:43:21 <koz_> dmwit: Yeah, in that case, dunno.
13:43:56 <dmwit> I was just pondering how to do your generalized `elements` more efficiently, the inefficient bit being the call to `(!!)`.
13:44:26 <dmwit> e.g. the specialized version of `elements` for `Map k` should be much faster than the `toList` version.
13:45:43 <dmwit> Or, to take an extreme example, consider the specialized version of `elements` for `(Word64 ->)`...
13:45:51 <koz_> Or something over a Vector.
13:45:54 <dmwit> right
13:47:07 <fog> dont you just ask that an accessor lens exists?
13:47:26 <dmwit> I don't know. What's an accessor lens, and why is it better than my (!)?
13:47:36 <solonarv> dmwit: something like lens' Ix/At classes, perhaps
13:48:55 <dmwit> Okay! Ixed seems reasonable.
13:49:46 <fog43> so anyway, these "gremlins" were supposed to be a simple precursor to "concurrent function nets" 
13:50:02 <dmwit> Interesting. Why did lens choose to make Index and IxValue not be associated with Ixed?
13:50:17 <solonarv> I actually have no idea
13:50:19 <fog43> where, abstracting over this pretty rudimentary, writing everything to a file, sockets or process handles could pass information directly
13:50:19 <koz_> dmwit: I believe microlens _does_ associate those.
13:51:47 <fog43> basically i end up just using generic binary conversion, and then the "types" of the input and output can be made, despite only bytestreams ever actually being passed between these disparate processes
13:51:59 <dmwit> Perhaps because of Contains.
13:52:27 <dmwit> Though no, all of Contains' instances are also Ixed instances.
13:52:58 <fog43> yeah, there was an earlier idea about capsules, which would, by virtue of being all IO, that could trigger events when their contents was read
13:54:04 <fog43> something like concurrent containers with side effects
13:54:28 <fog43> and they had wierd composition rules and privacy and permissions masks and stuff, i cant remember, might dig it out one day
13:54:49 * dmwit . o O ( class (Ixed m, IxValue m ~ ()) => Contains m )
13:55:17 <fog43> but yeah, each of them was like a threaded process that was running to kind of sit over a bunch of data and marshal the queries to it
13:55:25 <dmwit> I guess IxValue m ~ () is too strong. Somebody might want IxValue m ~ Proxy m or something.
13:55:48 <fog43> so i thought these "gremlins" things that were kind of a primitive version dumping data to files and having a nice IO stream API was a good idea
13:56:45 <fog43> dmwit: why not just take the index as a parameter to the class?
13:57:57 <fog43> class HasAccessorLens i m where accessorLens :: i -> m a -> a
13:58:19 <fog43> maybe with | m -> i
13:59:33 <fog43> oh yeah, and then, because these "capsules" were not just hetrogenous lists (they had to be in order to nest Freely) but could also be Sum types, so thats why i was working on Datatype i posted recently
13:59:50 <dmwit> Lens appears to already be all-in on type families. So I think it's consistent to continue doing TF stuff rather than MPTC+FD stuff.
14:00:08 <llaro> Hello! Has anyone here used Data.Pagination?
14:00:15 <dmwit> ?where justask
14:00:15 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
14:00:30 <fog43> i guess if i get the streaming stuff working with good API, and the gremlins with data Datatype, and the abstraction over traversable, then i can get to concurrent function server nets
14:02:33 <fog43> also, recently had a proof-ish of nets as decision forests, or hierarchical mixture of experts - so there could be some kind of representation of functions as nets which leverages this
14:02:42 <koz_> If I'm working in microlens (assuming appropriate inclusion of microlens-ghc and whatnot), is there a lens-native way of spelling 'view (satisfiers . to (HS.toList . HS.filter pred))'?
14:04:03 <dmwit> lens has one called "filtered". Perhaps microlens does, too?
14:04:16 <koz_> dmwit: It does, but I'm not sure how to use Traversals.
14:05:00 <dmwit> (^.. filtered pred) -- I think
14:05:13 <koz_> And then I guess I need 'each'?
14:05:15 <koz_> So like
14:05:27 <koz_> view (satisfiers . (^.. filtered pred) . each)?
14:05:38 <dmwit> I don't know what satisfiers is.
14:05:42 <koz_> Lens'.
14:05:47 <koz_> (that fishes out a HashSet)
14:05:52 <dmwit> But I would guess it would just be `theOriginalList ^.. filtered pred`
14:06:07 <dmwit> Or theOriginalHashSet or whatever.
14:06:30 <solonarv> ^.. is an "optic consumer" (term I just made up) much like ^. or .~ and the like
14:06:43 <dmwit> or like view =)
14:06:48 <koz_> Yeah, the whole thing is that I'm working in MonadState SomeHugeRecord, and 'satisfiers' is a Lens' SomeHugeRecord (HashSet ThingICareAbout).
14:06:55 <solonarv> yes, I was trying to liken it to operators specifically
14:07:04 <solonarv> I think you asked this before?
14:07:12 <koz_> I may have done, but it was a while ago.
14:07:17 <dmwit> koz_: Oh, then (^.. satisfiers . filtered pred).
14:07:19 <koz_> And then I ended up needing to rethink things.
14:07:30 <dmwit> Well (^.. (satisfiers . filtered pred)) because parsing lmao
14:07:33 <solonarv> I'd spell this: gets $ toListOf $ satisfiers . traversed . filtered pred
14:07:42 <koz_> Does microlens's ^.. work inside MonadState?
14:07:51 <tonymclane> signum x =
14:07:51 <tonymclane> if x < 0
14:07:51 <tonymclane> then -1
14:07:51 <tonymclane> else if x > 0
14:07:51 <tonymclane> then 1
14:07:52 <tonymclane> else 0      Does that belong on one line of text editor? I can't figure out how to type it if it belongs on one line      parse error (possibly incorrect indentation or mismatched brackets)
14:07:59 <tonymclane> Failed, modules loaded: none.
14:08:19 <dmwit> tonymclane: One line would be fine. Multiple lines are fine, too, so long as all of them are indented more than the 's' of signum.
14:08:35 <solonarv> no, because its type is (paraphrased) s -> Traversal s a -> [a]
14:08:37 <dmwit> koz_: Probably not.
14:08:42 <koz_> Aww.
14:08:44 <koz_> Oh well.
14:08:58 <solonarv> toListOf is the function form and has the type: Traversal' s a -> s -> [a]
14:09:03 <dmwit> koz_: You could `gets (^.. (satisfiers . filtered pred))`. Though I would bet microlens has something else for that.
14:09:10 <dmwit> I'm not tooooo familiar with the full API.
14:09:10 <solonarv> so that one could be generalized to 'MonadReader s'
14:09:14 <solonarv> but IIRC it isn't
14:09:19 <koz_> solonarv: I should send them a patch.
14:09:34 <tonymclane> thanks 
14:10:22 <solonarv> it can't work in MonadState because ((->) s) does not have a 'MonadState s' instance.
14:11:13 <dmwit> Weird. I feel like solonarv and I are answering completely different questions, somehow. Maybe I know even less about lens than I thought I did.
14:11:14 <koz_> solonarv: Shows that I'm terrible on Mondays. I meant I'm in Monad_Reader_ SomeHugeRecord.
14:11:20 <solonarv> also, you can't directly compose 'satisfiers' and 'filtered pred' like you are doing, you need an intervening Traversal [a] a or similar
14:11:27 <solonarv> ah okay, I did remember that
14:11:29 <monochrom> Something like "s -> [(s, a)]" has a better chance of being a MonadState s.
14:11:34 <koz_> solonarv: Would 'each' work?
14:11:47 <solonarv> uh, possibly
14:12:05 <solonarv> I'm not too familiar with what microlens does/doesn't have
14:12:19 <koz_> Fair enough. I'll see if I can spell what I want.
14:12:29 <dmwit> Oh, yeah, definitely need an intervening each or similar.
14:13:00 <solonarv> 'folded' should work, I think
14:13:24 <jumper149> Can I somehow derive ToJSON for `newtype A = A B deriving Generic` without having it derived for B?
14:13:42 <koz_> jumper149: Not by that method.
14:13:45 <dmwit> You must have an instance for B. But it need not be the derived one.
14:14:11 <solonarv> if B has a Generic instance then you can probably do it via an appropriate incantation
14:14:19 <jumper149> dmwit: Ye surely mustnt be derived
14:14:27 <jumper149> solonarv: incantation?
14:15:29 <dmwit> And of course you can just write an instance yourself for A.
14:16:04 <monochrom> Did you, or will you plan to, handwrite "instance Generic B" yourself?
14:16:59 <monochrom> Because one way or another B needs to be a Generic instance before it makes sense to think about "deriving Generic" for A.
14:17:05 <dmwit> I think the other important question was "how precise was your question? did every 'derive' really mean 'derive', or are other methods of low-boilerplate instance generation acceptable?".
14:17:16 <monochrom> Yeah that too.
14:17:19 <monochrom> Never trust askers.
14:17:38 <dmwit> monochrom: I think what you just said isn't quite true? Generic is only one layer deep, no?
14:17:51 <monochrom> Hrm, then OK!
14:18:23 <jumper149> monochrom: It doesn't really have to be with the deriving clause
14:18:28 <dmwit> confirmed
14:18:51 <monochrom> But I guess you need "instance ToJSON B" then.
14:18:53 <dmwit> (specifically: `data Foo; data Bar = Bar Foo deriving Generic` works fine with no Generic instance for Foo)
14:19:02 <dmwit> monochrom: right
14:19:02 <jumper149> I probably won't handwrite instances
14:19:17 <dmwit> monochrom: (Hence my "you must have an instance for B". ;-)
14:19:30 <monochrom> Too many classes.
14:20:41 <dmwit> Anyway. Probably the answer to your question is `instance ToJSON A where toJSON (A b) = genericToJSON b`.
14:20:44 <dmwit> But who knows.
14:20:50 <Nolrai> Is there a shorter way to write `floor . (* fromIntegral n)`?
14:21:01 <dmwit> genericToJSON defaultOptions b -- I mean
14:21:06 <dmwit> Nolrai: nope
14:21:15 <dmwit> Nolrai: You might like div' though.
14:21:25 <dmwit> err, mod' I mean
14:21:27 <jumper149> ahh wait, B already has a Generic instance if it is still important
14:21:58 <jumper149> dmwit: That looks fantastic :)
14:22:00 <dmwit> > 3.5 - (3.5 `div'` 2)
14:22:02 <lambdabot>  error:
14:22:02 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M273719392763...
14:22:02 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
14:22:07 <dmwit> > 3.5 - (3.5 `div'` 2) :: Double
14:22:09 <lambdabot>  error:
14:22:09 <lambdabot>      • No instance for (Integral Double) arising from a use of ‘div'’
14:22:09 <lambdabot>      • In the second argument of ‘(-)’, namely ‘(3.5 `div'` 2)’
14:22:26 <dmwit> ...the same mistake, a second time.
14:22:27 <dmwit> wow
14:22:33 <dmwit> > 3.5 - (3.5 `mod'` 2) :: Double
14:22:35 <lambdabot>  2.0
14:22:37 <Nolrai> :t mod'
14:22:38 <lambdabot> Real a => a -> a -> a
14:23:17 <Nolrai> Ah, no thats sort of the opposite of what I need.
14:24:07 <Nolrai> I mean I guess I could make "totalPopSize" an double..but..
14:24:33 <dmwit> I don't necessarily endorse switching to mod'. I only said you might like it, because I'm not sure what output type makes the most sense for you.
14:24:41 <dmwit> Oh! You might also like approxRational.
14:25:14 <dmwit> > approxRational 3.5 (2 :: Double)
14:25:17 <lambdabot>  2 % 1
14:25:37 <dmwit> > approxRational 3.5 (0.5 :: Double)
14:25:40 <lambdabot>  3 % 1
14:25:54 <dmwit> > approxRational 3.5 (0.25 :: Double)
14:25:56 <lambdabot>  7 % 2
14:26:01 <monochrom> > mod' 0.1 0.25
14:26:03 <lambdabot>  0.1
14:26:10 <monochrom> > mod' 0.3 0.25
14:26:12 <lambdabot>  4.999999999999999e-2
14:26:21 <dmwit> monochrom: close enough lmao
14:26:30 <dmwit> Double is just the worst.
14:26:31 <monochrom> > div' 0.3 0.25
14:26:34 <lambdabot>  1
14:26:36 <monochrom> :)
14:27:00 <{abby}> > approxRational pi 10e-17
14:27:02 <lambdabot>  245850922 % 78256779
14:27:05 <Nolrai> @dmwit: yes yes it is.
14:27:05 <lambdabot> Unknown command, try @list
14:27:20 <monochrom> @type div'
14:27:22 <lambdabot> (Integral b, Real a) => a -> a -> b
14:27:33 <monochrom> Where does div' come from anyway?
14:27:38 <dmwit> > approxRational pi 1e-16
14:27:41 <lambdabot>  245850922 % 78256779
14:27:53 <dmwit> monochrom: Data.Fixed
14:27:56 <dmwit> I know, a weird place for it.
14:28:00 <monochrom> Interesting
14:28:12 <dmwit> But you can see how div' and mod' might be handy for implementing Data.Fixed operations.
14:28:21 <monochrom> Yeah
14:28:56 <monochrom> div' x (1/n) = floor (x * fromIntegral n)
14:29:10 <dmwit> % import Data.Fixed
14:29:11 <yahb> dmwit: 
14:29:11 <monochrom> actually, since n is Integral...
14:29:17 <monochrom> div' x (1/ fromIntegral n) = floor (x * fromIntegral n)
14:29:24 <dmwit> % data B2; instance HasResolution B2 where resolution _ = 4
14:29:24 <yahb> dmwit: 
14:29:25 <monochrom> can't say the LHS is shorter :)
14:29:37 <dmwit> % read "0.25" :: Fixed B2
14:29:37 <yahb> dmwit: 0.0
14:29:43 * hackage musicScroll 0.2.3.1 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.2.3.1 (RubenAstudillo)
14:29:44 <dmwit> >:-(
14:30:05 <dmwit> Data.Fixed is broken in a few frustrating ways. That's one. The other is that all the operations do the equivalent of floor instead of round.
14:30:26 <dmwit> > 0.25 :: Fixed B2 -- (it's exactly representable)
14:30:30 <lambdabot>  error:
14:30:30 <lambdabot>      Ambiguous occurrence ‘Fixed’
14:30:30 <lambdabot>      It could refer to either ‘Data.Fixed.Fixed’,
14:30:36 <dmwit> % 0.25 :: Fixed B2
14:30:37 <yahb> dmwit: 0.3
14:30:40 <monochrom> B2? E2?
14:30:49 <dmwit> B2 -- two binary digits
14:31:05 <dmwit> E2 -- two "exponent" digits, but with the base not specified because the base is always 9+1, right??
14:31:20 <monochrom> I guess I have an old version.
14:31:44 <dmwit> No, I defined B2 inline above. data B2; instance HasResolution B2 where resolution _ = 4
14:31:50 <monochrom> Oh!
14:32:06 <dmwit> % [0, 0.25 ..] :: [Fixed B2]
14:32:11 <yahb> dmwit: [0.0,0.3,0.5,0.8,1.0,1.3,1.5,1.8,2.0,2.3,2.5,2.8,3.0,3.3,3.5,3.8,4.0,4.3,4.5,4.8,5.0,5.3,5.5,5.8,6.0,6.3,6.5,6.8,7.0,7.3,7.5,7.8,8.0,8.3,8.5,8.8,9.0,9.3,9.5,9.8,10.0,10.3,10.5,10.8,11.0,11.3,11.5,11.8,12.0,12.3,12.5,12.8,13.0,13.3,13.5,13.8,14.0,14.3,14.5,14.8,15.0,15.3,15.5,15.8,16.0,16.3,16.5,16.8,17.0,17.3,17.5,17.8,18.0,18.3,18.5,18.8,19.0,19.3,19.5,19.8,20.0,20.3,20.5,20.8,21.0,21.3,21.5,21.8
14:32:51 <Nolrai> So I need to aproxemently divide a total into pieces porportional to a list of doubles. I think `(floor . (* fromIntegral totalPopSize)) <$>` is the best way?
14:33:27 <Nolrai> Is "dmwit" pronounced "dee-em-wit" or "dimwit"?
14:33:37 <dmwit> Empirically or canonically?
14:34:14 <dmwit> canonically "dimwit"; empirically "dee em wit"
14:34:39 <Rembane> D. M. Wit?
14:35:04 <dmwit> First visits to a twitch stream are always a fun bit of squirming for the streamer. =)
14:35:07 <monochrom> diem wit
14:35:18 <Rembane> Carpe diem wit!
14:35:27 <dmwit> <3
14:35:29 <monochrom> (That's right, the first time I heard "per diem" I thought "per D M"
14:35:31 <monochrom> )
14:35:44 <Rembane> monochrom: What did you think D and M meant? 
14:35:54 <Nolrai> Per Diagnos Murder episode obvs.
14:35:58 <dmwit> Nolrai: I dunno. What do you do about the leftovers that floor leaves you with?
14:36:00 <monochrom> I had no idea and I was too afraid to ask.
14:36:09 <Rembane> Ach!
14:36:28 <Rembane> It could've been the dungeon master's responsibility too.
14:36:56 <dmwit> Nolrai: Denotationally, I would want to sort the weights by how much over the threshold they were and distribute the leftovers one at a time in that order.
14:37:04 <dmwit> Though operationally perhaps there's a more efficient calculation.
14:37:26 <monochrom> dmwit: just let the leftover drop on the floor?  >:)
14:37:28 <Nolrai> dmwit: I don't think I care, I want like 10-100 per bin and its just a resource limitation.
14:37:59 <dmwit> monochrom: That calculation is certainly possible to do cheaply! =)
14:38:28 <dmwit> Nolrai: Ah. If you don't care, then I recommend `const (allOfThem : repeat 0)`.
14:38:50 <Nolrai> "..."
14:38:56 <dmwit> Oops, you are calling it `totalPopSize`, not `allOfThem`.
14:39:28 <Nolrai> Thats one method.
14:39:47 <dmwit> ("But is /dev/null web-scale?")
14:46:49 <dmwit> Okay. I rewatched the "is /dev/null web-scale" video and either it aged like milk or I'm a better person now.
14:47:02 <dmwit> Possibly both.
14:52:54 <dmwit> Ah. I know how to do the calculation efficiently now.
15:03:13 <f-a> https://www.haskell.org/cabal/download.html the cabal downloads for linux are 404. Where can I find bins?
15:04:33 <ysangkok> f-a: which distribution do you use?
15:04:47 <ysangkok> f-a: if you're on ubuntu, you can use hvr's ppa
15:04:50 <f-a> debian buster (linux 64)
15:04:51 <monochrom> perhaps ghcup can help. or perhaps ghcup downloads from the same url therefore also toasted
15:06:03 <monochrom> Ahhh!!!! They've moved to 3.2.0.0 and forgot to update html files!
15:06:13 <monochrom> https://downloads.haskell.org/~cabal/cabal-install-latest/  have fun :)
15:06:56 <ysangkok> do newer cabals work with older ghc's?
15:07:09 <monochrom> Basically the 404 url but let's hack around and try its containing directory :)
15:07:14 <monochrom> Usually yes.
15:08:10 <monochrom> Heh ghcup is now aware of 3.2.0.0 too
15:08:32 <monochrom> (and defaults to it)
15:09:49 <monochrom> If you desire 3.0 you can browse https://downloads.haskell.org/~cabal/cabal-install-3.0.0.0/
15:12:09 <f-a_> don't know if the messages passed:
15:12:14 <f-a_> excellent, many thanks
15:12:19 <monochrom> :)
15:12:54 <f-a_> does anyone know who signs the binaries? gpg --search-key 4B2CDA235E0C5841C7EE87612EAF8B8BB12873F5 give me no answer
15:13:09 <monochrom> that one I don't know.
15:13:36 <jumper149> About how long will it take to build ghcjs on a thinkpad x220?
15:14:21 <monochrom> But perhaps you can trust the posted sha256sums.
15:14:21 <hyperisco> x220 standard
15:16:53 <mekeor> is there a xml-library X as simple as this? `do string <- readFile "foo.xml"; let xml = X.parse string; let tag = X.cssQuery xml ("some-tag[some-attr='some-value']"); print (X.attr tag "other-attr")`
15:18:52 <sshine> good question. I'd like to know.
15:19:25 <sshine> there definitely is. question is if one is better than the other.
15:19:46 <sshine> 'selectors' last updated 2013, 'css-selectors' last updated 2020.
15:20:19 <sshine> https://hackage.haskell.org/package/css-selectors -- it looks like not all of CSS3 was implemented.
15:21:39 <mekeor> the xml package would need to support that css-selector-package, too…
15:21:53 <mekeor> if it doesn't implement it on its own
15:22:45 <mekeor> mekeor: did you check out hxt + hxt-css ?
15:22:57 <mekeor> mekeor: it seemed so complicated to me at first sight…
15:24:09 <ysangkok> mekeor: why hilight yourself? :O
15:24:45 * mekeor talks to himself
15:25:00 <sshine> I thought something was wrong with my IRC client. :'D
15:25:15 <mekeor> hehe
15:28:55 <pie_[bnc]> Does anyone know if theres a good way to detect if my code is being run in ghci?
15:29:37 <hpc> what for?
15:30:07 <pie_[bnc]> im trying to access stuff with a path relative ot my source file or executable
15:30:29 <hpc> try "cabal repl"
15:30:51 <pie_[bnc]> if its compiled i can just use getExecutablePath but but for "runnign form source" im using CPP + __FILE__
15:30:52 <hpc> that will usually do a smarter thing, if you've set up your package correctly
15:31:00 <pie_[bnc]> but i dont know how to actually choose the branch
15:31:16 <pie_[bnc]> the files it tries to access arent bundled with the haskell package per se
15:32:13 * hackage musicScroll 0.2.3.2 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.2.3.2 (RubenAstudillo)
15:32:46 <sshine> perhaps a config property somewhere that does bundle with the code points to the right place then?
15:35:53 <pie_[bnc]> I think what I want to do is reasonable, I dont want ot hav to fiddle with a separate file. scrpting languages dont normally have a problem with this, but sure haskell is not usually used like that
15:36:35 <pie_[bnc]> meh, I could look at the executable name :/
15:37:45 <hpc> is this just for debugging?
15:38:06 <hpc> programs that care about the location of the executable itself i find to be very frustrating to use
15:38:42 <hpc> generally you want to use the current working directory, or a particular directory in /etc
15:39:30 <pie_[bnc]> actually this is interesting, getProgname in ghci returns '<interactive>'
15:53:12 <koz_> :t filter (> 2) [1, 2, 3, 4]
15:53:14 <lambdabot> (Ord a, Num a) => [a]
15:53:19 <koz_> > filter (> 2) [1, 2, 3, 4]
15:53:21 <lambdabot>  [3,4]
15:54:06 <MarcelineVQ> woa
16:00:40 <mekeor> mekeor: the best thing i could get working so far with hxt is: `string = "<some-xml>…</some-xml>"; xml = head (Text.XML.HXT.Parser.XmlParsec.xread string); Control.Arrow.ListArrow.runLA (Text.XML.HXT.CSS.css "some-css-selector") xml`
16:00:56 <mekeor> mekeor: i find this quiet ugly
16:03:32 <MarcelineVQ> role1989: ping
16:06:19 <pie_[bnc]> MarcelineVQ: pong
16:08:43 * hackage haskell-say 1.0.0.0 - Let the Haskell logo talk to your users!  https://hackage.haskell.org/package/haskell-say-1.0.0.0 (DrewHaven)
16:12:27 <sm[m]> pie_[bnc]: I haven’t read in detail but I think embedding files with file-embed is much more robust that trying to figure out file paths
16:14:04 <sm[m]> Hledger does this if you need a working example (works in ghci too)
16:15:58 <dmwit> pie_[bnc]: Use cabal's Paths_* mechanism and cabal repl.
16:18:08 <dmwit> pie_[bnc]: https://cabal.readthedocs.io/en/latest/installing-packages.html#prefix-independence
16:18:28 <sm[m]> that only works for things built with cabal
16:19:15 <dmwit> Hm. That link appears to be broken. Try this one instead: https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code
16:19:22 <dmwit> sm[m]: Yes. So use cabal.
16:19:34 <dmwit> Should work with stack, too, if that's the objection, no?
16:20:48 <dmwit> Or maybe the objection is that it only works for things that are built, and not things that are interpreted. If so I believe that's not correct: cabal repl will set up environment variables appropriately so that the Paths_ module works right.
16:20:55 <sm[m]> The thing is you might not want to say to users. You must set up a haskell toolchsin, give up 1G of disk,  and build for an hour to run my thing :)
16:21:10 <dmwit> So distribute a binary that you built...?
16:21:39 <sm[m]> exactly, and if it needs support files, I’m saying embedding them in the binary makes it nice and robust
16:21:43 <dmwit> I mean you can't avoid a Haskell toolchain and still use Haskell. So I'm not sure what you're proposing as an alternative other than "use a language they've already installed the 1G toolchain for".
16:22:19 * dmwit shrugs
16:22:42 <dmwit> That's certainly one way. Another is to arrange that the Paths_ module works correctly by providing an installer or a script that sets up the right environment variables.
16:23:18 <dmwit> There's disadvantages to baking it into the binary, too: it's much harder to update resource files individually, e.g.
16:23:25 <sm[m]> we seem to have some confusion here, I blame typing on phone with wrong glasses in a moving car. Bbl
16:36:36 <d34df00d> Is there any raw string quasiquoter (or string interpolation quasiquoter) that'd remove leading indentation intelligently?
16:37:20 <solonarv> I think some of them do that, yes
16:37:25 <d34df00d> That is, if I have [someQQ|<\n><4 spaces>foo<\n><6 spaces>bar<\n><6 spaces> baz|], I'll get "foo\n  bar\n  baz"?
16:37:33 <solonarv> I can't recall the name, though
16:37:52 <d34df00d> https://hackage.haskell.org/package/qm-interpolated-string is quite close, but it cuts off all of the indentation, which I don't need here.
16:40:21 <d34df00d> Or, to avoid X-Y problem, I'm writing some tests for a typechecker for a tiny language (which is, of course, indentation-sensitive), and I want to make sure that tests don't look too ugly.
16:40:31 <d34df00d> How would you format multiline input keeping the indentation?
16:41:59 <d34df00d> On the other hand, I can just manually do lines, then count spaces on the first (or second) line, and drop that number of spaces from each line. Why do I even need a special QQ for that?
16:42:26 <d34df00d> Save me from going the javascript/npm/leftpad route!
16:57:54 <iqubic> How hard is it to set up a haskell webserver so that I can serve up pages on my local network?
16:58:11 <iqubic> I have a spare laptop that I'm putting Debian stable onto.
16:58:24 <solonarv> shouldn't be very hard at all, I'd think
16:59:38 <iqubic> Right. My main question, what steps do I need to take so that the webserver running on debian box can be accessed from other machines on this network?
17:00:07 <solonarv> very little, IIRC
17:00:44 <solonarv> make sure you are listening on 0.0.0.0 (so you accept connections from anywhere, not just localhost) and note down or remember the port your server is listening on
17:01:10 <solonarv> then run ifconfig to figure out the laptop's IP
17:02:02 <solonarv> then you can just type <laptopIP>:<port>/whatever/path?with=args&too=perhaps into a browser's URL bar on another device in your network
17:02:24 <solonarv> I'm assuming this is a simple home network and not some fancy setup
17:03:25 <iqubic> So to make sure I'm listening on 0.0.0.0 that be a setting I set within my program? So it'd be slightly different depending on if I'm running snap/wai/servant/yesod?
17:03:40 <iqubic> Also, yeah. It's a really simple home network.
17:05:43 * hackage lens-csv 0.1.1.0 -   https://hackage.haskell.org/package/lens-csv-0.1.1.0 (ChrisPenner)
17:07:14 <solonarv> I think that is actually the default (in warp at least), so you don't need to do anything special
17:11:09 <sm[m]> iqubic, do you want to program your own webserver/web app ? or just serve some files, using a haskell tool ? there is one like that
17:17:18 <remexre> is there a canonical (Ptr a -> IO ()) -> Data.Vector.Sized.Vector n a ? hoogle shows nothing
17:17:35 <Axman6> maybe ForeignPtr?
17:17:48 <remexre> er, IO (Vector n a)
17:17:56 <Axman6> probably not for Sized.Vector
17:18:20 <fishooter> I am confused... I tried using following:  x <> y  on a Monoid, and compiler complains that variable <> is not in scope.  x `mappend` y   works fine. How come?
17:18:45 <Cale> fishooter: Which compiler/version are you using?
17:18:47 <pie_[bnc]> the HXT documentation makes me angry, is there any way to tell that .Core is what youre supposed to use, without reading random internet tutorials or brute foricng the docs?
17:19:27 <fishooter> The Glorious Glasgow Haskell Compilation System, version 8.0.2
17:20:01 <Cale> Yeah, 8.0.2 is from before <> was a thing
17:20:08 <Cale> (it's from 2017)
17:20:28 <remexre> Axman6: oh, looks like there's some pointery stuff in Data.Vector.Storable; I'll start there
17:20:33 <ysangkok> remexre: i don't even think there is one for list
17:20:33 <Cale> You can define it yourself, or update GHC
17:20:52 <Cale> It's easy enough to write (<>) :: Monoid m => m -> m -> m; x <> y = mappend x y
17:21:04 <Cale> but you might just like to use a newer set of libraries
17:21:16 <remexre> ysangkok: I don't think it'd make sense on lists, would it? they don't have contiguous internal storage
17:21:20 <fishooter> ok, thanks! :)
17:21:35 <ysangkok> remexre: aaah ok, you don't want any copying. that wasn't clear to me!
17:22:01 <ysangkok> remexre: i thought you just wanted to copy out using withForeignPtr, withArray and such
17:22:04 <zeta_0> sorry for being off topic(it has a little bit to do with nix), what does this error mean? https://dpaste.org/RtUt
17:22:40 <remexre> ysangkok: oh, no; I'm trying to create a vector from an IOful/pointery function
17:23:11 <zeta_0> i'm guessing it's because it's using cabal 2.4 and needs to be cabal 3.0 instead, as for the missing dependencies i have no idea? any thoughts guys?
17:24:03 <ysangkok> remexre: i am currently doing pretty much the opposite of what you're trying to do. i have a dependently typed list and i want to store it continously and pass it as a pointer: https://gist.github.com/ysangkok/e5d4717eec2b69beeb0964572941ee72
17:25:14 <fog> https://wiki.haskell.org/ListT_done_right
17:25:20 <remexre> ysangkok: oof; yeah, for me I'm trying to make instances of Graphics.Rendering.OpenGL.Uniform for my custom dependently typed matrices
17:25:32 <ysangkok> lots of copying going on since i am using peek and withArray :(
17:25:43 <fog> instance (MonadReader s m, Functor m) => MonadReader s (ListT m)
17:25:53 <fog> instance (MonadState s m, Functor m) => MonadState s (ListT m)
17:25:56 <fog> what do these do?
17:26:11 <fog> i get, ask, local, get and put
17:26:21 <remexre> fog: if m is a MonadReader/State, so is (ListT m)
17:27:18 <fog> I guess its all down to;   lift = ListT . liftM (`MCons` return MNil)
17:27:44 <fog> but i cant really see whats happening there
17:28:21 <zeta_0> i'm guessing you guys don't understand nix to well, this may be the wrong channel to be asking that question
17:28:36 <fog> :t lift
17:28:38 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
17:30:44 <fog> zeta_0 : are you using cabal2nix? it looks like you have a missing dependency? is that from the cabal file, or did you not package the dependencies properly in default.nix?
17:31:30 <fog> remexre: Ok, I get that, but can you tell what functionality this actually amounts to for readers or states over ListT m
17:32:35 <sm[m]> pie_[bnc]: some packages have worse docs than others
17:33:24 <remexre> fog: oh, no. well, I assume reader is just that all "branches" of the computation can access the value; idk how exactly get, put, and mAppend commute without thinking abt it harder
17:34:08 <fog> hmm, well i dont understand about what branches you mean
17:34:46 <fog> i guess basically it has something to do with eg, embeding some values into the "state" part of the monad being used on each value
17:35:09 <fog> but since they are all nested, does it just do that for the head?
17:35:26 <jackdk> zeta_0: the haskell packages set in nixpkgs uses a specific version of each package, based off a stackage snapshot. Often, the build environment contains a requested dependency, but the cabal file has constrained it away. doJailbreak from pkgs.haskell.lib aims to turn off bounds-checking for a derivation but doesn't handle conditionals in the cabal file.
17:35:27 <fog> like, there are as many nestings of the monad as there are elements of the list
17:36:43 <fog> i guess im kind of confused about how state can be used during a traversal to accumulate a value to use some place after it is encountered 
17:37:23 <fog> so i kind of have the feeling like the monadstate for listT would do something like that, and im not sure i understand what the implementation actually does
17:38:24 <fog> and there is no foldable or traversable instances given in the wiki page. i might try and find them someplace
17:40:15 <fog> hmmm, none of them do. the closest thing is this;
17:40:15 <fog> https://hackage.haskell.org/package/list-t-1.0.4/docs/src/ListT.html#applyFoldM
17:40:30 <fog> applyFoldM :: Monad m => FoldM m i o -> ListT m i -> m o
17:40:39 <fog> but thats not exactly the normal type
17:40:59 <fog> not sure what FoldM m i o is
17:41:23 <fog> i guess the monad means the fold has a different type
17:42:10 <fog> i can vaguely remember something about each "different" container type having a type level mapping to the corresponding type of its fold
17:42:14 * hackage bioinformatics-toolkit 0.9.3 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.9.3 (kaizhang)
17:42:28 <fog> i guess the question is, what is the type of the varient of fold for ListT
17:42:34 <remexre> I think of ListT m as a monad for nondeterministic/logic programming; where each value produced represents a single "success state" of some sort that's been found
17:42:46 <remexre> it sounds like you're deeper in the weeds than I've been, though
17:43:07 <fog> :t foldr
17:43:09 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:43:14 * hackage tracing 0.0.5.1 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.5.1 (mtth)
17:45:48 <fog> remexre: so when you say that the reader value is visible to all "branches" you mean, all of the monadically wrapped values at each position in the ListT?
17:45:59 <remexre> yeah
17:46:15 <fog> which would imply descending and updating each monad, not just the one wrapping the head
17:46:50 <fog> which is what i was thinking when some kind of carry would be folded over the list and update each state during traversal
17:50:11 <zeta_0> fog jackdk , yes, i'm using cabal2nix with the cabal file that comes with the darcs developer repository that i cloned, as for my default.nix, i'm using the darcs.env option, so it should come with all the dependencies that darcs needs, i then imported the nix file that i used with cabal2nix into the default.nix file, anyways, i could paste bin all of the files i'm using to build darcs, if you want to take a look?
17:50:37 <jackdk> zeta_0: a
17:50:55 <jackdk> zeta_0: sorry, do you have a link to the repo?
17:51:15 * hackage bioinformatics-toolkit 0.9.3.1 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.9.3.1 (kaizhang)
17:52:40 <fog> maybe the default nix would be most helpful? 
17:52:41 <sm[m]> https://hub.darcs.net/darcs/darcs-screened
17:53:08 <sm[m]> I don't understand it, what could possibly go wrong with zeta_0 's plan ? :)
17:54:33 <sm[m]> but I've noticed zeta_0 does not give up!
17:54:53 <pie_[bnc]> sm[m]: is HXT still the de facto XML to use though?
17:55:43 <sm[m]> pie_[bnc]: it might be.. seems relatively recently released at least. I get the impression there's no XML lib that people love
17:56:06 <pie_[bnc]> apparently HXTs xpath implementation is all kinds of broken, but im not sure
17:57:37 <zeta_0> ok, i'm back, i was in the #darcs channel, give me a couple of minutes to get the paste bins ready
17:59:42 * pie_[bnc] considers roundtripping it through python -_-
17:59:50 <dsal> I used to really like darcs.
17:59:58 <dsal> I've been in javascript hell for a while now.
18:00:00 <fog> huh, ok
18:00:01 <fog> https://gist.github.com/fog-hs/4a8476d37042baa1810a70f743d495f0
18:00:10 <fog> it just wraps the result of the fold in a monad
18:01:09 <fog> i wasnt expecting for even there are even more types for fold...
18:06:38 <fog37> and i can write;
18:06:38 <fog37> foldMList_ :: Monad m => (a -> m b -> m b) -> m b -> MList_ m a -> m b
18:06:56 <fog37> which might seem more idiomatic 
18:07:18 <fog37> what about traverse though? how to contend with the applicatives!?
18:07:56 <fog37> :t traverse
18:07:58 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:17:08 <zeta_0> ok, here's contents of the directory listed, with the error again: https://dpaste.org/zavV , here's screen.cabal and screened.nix files: https://dpaste.org/r0K6 , https://dpaste.org/GNst , here's the default.nix file: https://dpaste.org/Rk4A , and here's the instructions that i used to clone darcs: http://darcs.net/Development/GettingStarted
18:18:23 <zeta_0> sm[m] jackdk fog ^
18:18:48 <zeta_0> sorry i took so long, it took me a while to organize this stuff
18:22:06 <jackdk> zeta_0: while I wait for darcs to clone, what is the output of `nix-instantiate --eval -E '(import <nixpkgs> {}).haskellPackages.constraints.version'` on your computer?
18:25:03 <LarryTheCow> Hello. Would one of you NixOS users tell me how I can get zlib to work with cabal?
18:25:33 <jackdk> zeta_0: the repository I cloned does not appear to have a screen.cabal. do you mean darcs.cabal or have I cloned the wrong repo?
18:25:58 <jackdk> LarryTheCow: beats me. I have always used the nixpkgs haskell infrastructure to provide dependencies to avoid that problem.
18:26:21 <jackdk> I may be able to help with that, but #nixos has a lot of haskell people
18:27:20 <LarryTheCow> Well that's the thing. I've always been using default.nix for my projects, but now I decided to use cabal or stack for writing libraries
18:28:09 <jackdk> When I write a lib, I keep nix files around for it and CI it to handle people using just cabal. seems to work so far but people don't seem to use my libraries, so... *shrug*
18:28:45 <LarryTheCow> I see. I'll go back to the beautiful world of nixpkgs
18:28:46 <LarryTheCow> Thanks
18:29:16 <sm[m]> what libraries, jackdk ?
18:30:12 <jackdk> sm[m]: libtelnet, reflex-libtelnet, semialign-extras. semialign-extras is probably the only non-niche one though `:-)`
18:30:18 <jackdk> things like that
18:30:55 <sm[m]> Ah.
18:31:17 <jackdk> I'm not salty about it, because I know I've crawled into a niche for most of them
18:31:35 <zeta_0> jackdk: https://dpaste.org/5C1A
18:31:45 <Axman6> s'if reflex-libtelnet isn't powering multinational's backend services
18:32:09 <jackdk> Axman6: ahahhahaha I wouldn't know whether to be flattered or horrified
18:32:10 <sm[m]> if you are interested, I read http://hackage.haskell.org/package/semialign-extras and did not achieve perfect understanding
18:32:55 <jackdk> sm[m]: I am interested in your imperfect understanding
18:33:02 <jackdk> do the module-level docs help any?
18:34:21 <zeta_0> jackdk: and, i renamed darcs.cabal to screened.cabal, so that it would be the same name as the screened directory that it's in, if not, nix-shell won't work if there's a name mismatch, well i guess it has to do with the screened.nix file, but i want to keep files that i use with cabal2nix with the same name
18:34:31 <sm[m]> "what do they mean by structures and line up.. visually ? ..lots of stuff I don't understand.. lean dependency footprint (yay) .. depends on lens (wait..)"
18:35:38 <sm[m]> jackdk: the haddocks are good, I'm just still stuck on "line up two structures of the same type". Maybe an example would help
18:36:52 <jackdk> sm[m]: thanks. the main thing is the `Semialign` class: `class Semialign f where align :: f a -> f b -> f (These a b) {- plus other methods -}`
18:37:15 <sm[m]> ah, and I just realised this is an addon to the semialign package (by clicking on the Semialign class) - could mention & link that in the readme too maybe
18:37:28 <jackdk> so you get instance like `align :: Map k a -> Map k b -> Map k (These a b)`
18:37:51 <sm[m]> s/readme/package description/
18:37:55 <jackdk> sm[m]: I can see how the description can be unclear on that point.
18:38:20 <jackdk> I might see if I can push a metadata revision on that
18:38:27 <sm[m]> just my 2c. Sometimes I have the reading comprehension of a 5 year old
18:38:54 <jackdk> but yea, semialign is small, so some of the things we'd like to do (e.g., diff/patch) cannot be done there, because we need some classes from `lens`
18:38:58 <zeta_0> jackdk sm[m] , ok, so do you guys know what is causing the nix-shell error? i paste binned everything already ^
18:39:09 <jackdk> zeta_0: can you hang on just a darn minute please?
18:39:24 <sm[m]> semialign: "The major use of These of this is provided by the align member of Semialign class, representing a generalized notion of "zipping with padding" that combines structures without truncating to the size of the smaller input." ... "I might not be the target for this lib" :)
18:40:17 <sm[m]> I'm interested in docs. Ignore me, I will in fact read up on this
18:40:39 <jackdk> have you ever wanted to line up two maps, so you can easily tell which keys are present in which map? it's one of those things where the abstract description doesn't capture the motivating common problems
18:41:45 <jumper149> Can I somehow have a function where it's not clear what the output is.
18:41:48 <sm[m]> now that sentence grabs me! still not immediately clear on it, but much closer
18:42:25 <sm[m]> a trivial example would do the trick
18:42:27 <jackdk> or zipping two lists together, but being able to talk about the tail of the longer list?
18:42:30 <jumper149> With that I mean it can output value of different types.
18:43:07 <zeta_0> jackdk sm[m] , sorry i didn't mean to rush you guys, i'll wait
18:43:16 <jackdk> zeta_0: I am looking at your stuff now
18:43:23 <sm[m]> sorry - dinner calls. Back to zeta  o/
18:43:56 <zeta_0> sm[m]: it's cool, thanks for the help, see you later
18:44:19 <jumper149> Can I somehow have something like a product type but not actually a product type, because I have to access the type later on and can't pattern match on type-level. I hope that makes sense^^
18:45:15 <zeta_0> jackdk: cool, and if your busy with something else, i can wait, i don't want to interrupt you
18:45:24 <fishooter> Hi, is it possible to run stack test without the Main module/executable?
18:45:43 <fishooter> When I removed the executable section from cabal file it complains about Main missing
18:48:38 <Axman6> jumper149: read is an example of a function which can return different types depending on the context in which it's used
18:48:45 <Axman6> > read "True" :: Bool
18:48:48 <lambdabot>  True
18:48:52 <Axman6> > read "7" :: Int
18:48:54 <lambdabot>  7
18:49:05 <Axman6> > read "\"Hello\"" :: String
18:49:07 <lambdabot>  "Hello"
18:49:08 <jackdk> > read "the type of read lies" :: Int
18:49:10 <lambdabot>  *Exception: Prelude.read: no parse
18:55:21 <jackdk> zeta_0: I used this for default.nix and got a shell that worked. Are you trying to get a development shell or build the package in a derivation? https://www.irccloud.com/pastebin/m544nsWO/default.nix
18:58:29 <jumper149> Ty Axman6, that's a nice catch :)
19:03:08 <fishooter> ok, I can just add a library: section to cabal file. Now another question: how can I make sure that when I run tests, the dependencies for executables are not downlaoded?
19:03:22 <fishooter> executable has some GUI, which I don't want to download for automated tests
19:04:17 <zeta_0> jackdk: when i try to go into a nix-shell it throws that throws that error, so that's where i'm stuck
19:04:52 <jackdk> zeta_0: have you tried using my default.nix, no shell.nix, and then running nix-shell?
19:07:04 <zeta_0> jackdk: sorry about the typos, i'm a little tired, anyways, no, i haven't tried running your default.nix, could you paste bin it?
19:07:22 <jackdk> I just did, above? 
19:08:34 <zeta_0> jackdk: sorry i missed it, i'll take a look now
19:13:23 <jackdk> zeta_0: I tend to use the haskellPackages.developPackage when I'm working on other people's software, as it allows me to easily set up a shell, it calls cabal2nix for me, etc. the reason nixpkgs does not do this, is that nixpkgs tries very hard to avoid importing the result of a derivation (because then you have to eval, then build, then eval, etc., and you can't know what you need to download and build statically)
19:16:30 <zeta_0> jackdk: ok, understood, and i ran nix-shell, and it just finished building, so i'm inside of a nix-shell now
19:16:51 <jackdk> so you should be able to cabal v2-build and hack on the package, right?
19:17:19 <jackdk> (darcs is already in the haskell package set, so I assume this is why you were cloning it)
19:18:42 <zeta_0> jackdk: so your default.nix file comes with all the dependencies needed by darcs? i thought i would need to setup the darcs.env option for that?
19:19:09 <zeta_0> jackdk: i cloned darcs using these instructions: http://darcs.net/Development/GettingStarted , should i use cabal get darcs instead?
19:19:15 <jackdk> the developPackage function will call cabal2nix for you, and that should provide you with the instructions
19:19:22 <jackdk> sorry
19:19:53 <jackdk> the developPacakge function calls cabal2nix on darcs.cabal as part of its evaluation, and that should provide you with a shell containing all the deps of darcs as a result
19:20:11 <jackdk> I too set up this nix file in a clone following those instructions, so they should work for you
19:22:14 <zeta_0> jackdk: wow, that's great, nix is an incredible tool
19:22:32 <jackdk> indeed
19:25:23 <zeta_0> jackdk: also, i'm using cabal version 3, so i think i should be able to run cabal's usual commands without any problems, correct? https://dpaste.org/VrQb
19:26:00 <jackdk> probably. I use whatever version of cabal-install that nixos gives me, but they're usually pretty good about backwards compat
19:26:32 <jackdk> zeta_0: oh I meant to send you this too. these are the docs for teh developPackage function https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/make-package-set.nix#L231
19:27:14 <jackdk> you can see in there that it calls .env for you if it's building a shell
19:29:05 <zeta_0> jackdk: ya, there was a lot of ambiguity with the cabal command version's, but i think with the cabal version 3, they fixed it, so using cabal's regular commands should be fine
19:29:26 <zeta_0> jackdk: thanks for the link, i'll take a look now in a bit
19:29:38 <jackdk> oh yeah. I just keep typing v2- out of habit, and because I often need to write docs for people on cabal 2.4 and >= 3.0
19:29:54 <jackdk> also I'm going to be busy for a while
19:31:35 <zeta_0> jackdk: oh, ok, thank you so much for the help, i was banging my head against my computer all day, trying to figure this out
19:32:17 <zeta_0> jackdk: so you have to leave now?
19:32:20 <jackdk> unfortunately the nixpkgs haskell infra is still one of those things that's mostly folklore. especially how to untangle dependency errors
19:32:29 <jackdk> I usually leave IRC on but stop responding
19:33:24 <zeta_0> jackdk: ya, it works, but with a lot of workarounds needed to get it working
19:33:44 <zeta_0> jackdk: could i ask you one more question before you have to leave?
19:34:30 <jackdk> yea but I'm gonna start making lunch
19:34:37 <jackdk> I'll keep an eye on this chan though
19:37:58 <zeta_0> jackdk: ok, thanks again for the help, i try not to be too much of a help vampire, but i'm still pretty new to nix(been using it for around 8 months now)
19:38:32 <chloe_2> Hi, I'm trying to generate all paths to leaves of a tree, and I think I need something like scanr\
19:38:41 <chloe_2> but I find nothing of the type (a -> b -> b) -> b -> t a -> t b on Hoogle
19:39:07 <chloe_2> scanr is only defined for lists, is it not possible to do for all foldables?
19:40:12 <jackdk> zeta_0: you did a lot better on this latest nix ask, which is good to see `:-)`. Nix still has a lot of dark corners that need better docs
19:40:13 <chloe_2> or is there an obvious traverse/mapAccum combination I'm missing?
19:40:37 <jackdk> zeta_0: you going to ask your last question?
19:41:08 <ski> > scanr (+) 0 [2,3,5,7]  -- one more element. where to put it ?
19:41:11 <lambdabot>  [17,15,12,7,0]
19:42:08 <chloe_2> ski, is that posed at me? I'm not sure I follow
19:42:26 <ski> you could do a version that didn't insert the seed element. or a version that inserted it, but didn't insert the final accumulated result (e.g. instead giving it back in a pair with the new structure)
19:42:35 <ski> using `Traversable', that is
19:42:39 <ski> yes, chloe_2
19:43:17 <zeta_0> jackdk: ok, have you built xmonad in a nix-shell as well? i'm currently trying to setup a default.nix file for xmonad, i want to make some contributions to xmonad as well
19:43:47 <ski> you should be able to use `traverse' on `State b', to do either of those two alternatives i sketched, chloe_2
19:44:34 <zeta_0> jackdk: but the xmonad-test instructions are cryptic, and only cover cabal and stack, it does not have documentation for building xmonad with nix
19:45:08 <ski> chloe_2 : but note that there are `Traversable's (and therefore also `Foldable's) that always contain a specific fixed number of elements. so, for those, it's not possible to "insert one more element" (disregarding that it may not be obvious where to do it, which of many choices to pick, if it's possible)
19:45:56 <ski> (e.g. imagine a `data Vec3 a = MkV3 a a a')
19:47:03 <ski> chloe_2 : well, i guess what i sketched gives the `scanl' variant. but you could change the order of the state-passing, to get the `scanr' version
19:47:41 <zeta_0> jackdk: and, i already built ghc with ghc.nix, it was a struggle but i was finally able to build it, so that's good to go: https://github.com/alpmestan/ghc.nix
19:47:47 <jackdk> zeta_0: no I haven't, and I don't have time to try now. Generally the way to build something with nix is to set up the dependencies and then build with cabal. I think nix builds compile the Setup.hs directly but that's just a detail. the way haskell dependencies are registered into a nix shell is the say way as cabal-v1 install, it sets up a "global" package database
19:48:08 <ski> chloe_2 : hm. actually, i missed your first message. can you elaborate on how you want to accumulate these paths ?
19:48:09 <jackdk> that's about all I have time to write, right now. I hope it helps, and best of luck.
19:48:37 <ski> chloe_2 : where you do want to put the paths ? in the leaves of a new tree ?
19:48:48 <ski> or partial paths in all internal nodes ?
19:48:54 <zeta_0> jackdk: it's fine i was just wondering, thanks again for the help, nix has some rough edges, but i'm starting get the hang of it
19:49:04 <chloe_2> ski: I think each node should carry the partial path? That seems like the most obvious choice
19:49:09 <chloe_2> I have a solution like this
19:49:47 <chloe_2> mapAccumL (\a b -> (a++b, a++b) []
19:50:00 <ski> yea. the `traverse' thing i was suggesting was considering a single traversal over the whole structure. while you're considering some kind of "multi-traversal" following multiple paths down the tree, never returning back up again
19:50:26 <chloe_2> >  mytree = Node "B" [Node "A" [], Node "D" [Node "C" [], Node "E" []]]
19:50:28 <lambdabot>  <hint>:1:8: error:
19:50:28 <lambdabot>      parse error on input ‘=’
19:50:28 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:50:55 <chloe_2> >  let mytree = Node "B" [Node "A" [], Node "D" [Node "C" [], Node "E" []]] in mapAccumL (\a b -> (a++b, a++b) [] mytree
19:50:58 <lambdabot>  <hint>:1:118: error:
19:50:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:51:07 <chloe_2> >  let mytree = Node "B" [Node "A" [], Node "D" [Node "C" [], Node "E" []]] in mapAccumL (\a b -> (a++b, a++b)) [] mytree
19:51:10 <lambdabot>  ("BADCE",Node {rootLabel = "B", subForest = [Node {rootLabel = "BA", subFore...
19:51:19 <ski> @let mytree = Node "B" [Node "A" [],Node "D" [Node "C" [],Node "E" []]]
19:51:21 <lambdabot>  Defined.
19:51:46 <chloe_2> thanks, yeah, it's been a while since I used lambdabot or Haskell
19:52:27 <ski> (btw, `mapAccumL' is just `traverse' on `State')
19:52:46 <ski> so, `mapAccumL' will not do the "multi-traversal" thing you had in mind
19:52:54 <chloe_2> ski: can you explain why you called it multi-traversal? It seems like it's a single traversal
19:53:38 <ski> because you don't want the path to `"D"' above to also include the node `"A"', right ?
19:53:46 <chloe_2> > putStr $ drawTree $ snd $ mapAccumL (\a b -> (a++b, a++b)) [] mytree -- this seems to work
19:53:48 <lambdabot>  <IO ()>
19:54:17 <chloe_2> ski: oh you're right
19:54:44 <ski> so, you want not just a single path, passing through all the elements (which is what `traverse', and `mapAccumL' will give you)
19:55:22 <ski> but rather, on each branch, you want to "split" the current path into multiple independent paths, which are independently added to, as you descend deeper into the tree
19:55:30 <chloe_2> right, I understand now. It seems like there should be a simple fmap with accumulation that would work
19:55:45 <ski> (i'm not sure whether "multi-traversal" is a sensible word for this, but hopefully you see what i mean)
19:56:22 <ski> it seems like maybe there could be some way to do this with something like `StateT b []' ..
19:57:15 <ski> (which is an appropriate monad or idiom to keep track of the state in such a "multi-traversal", i think, hmm)
19:57:36 <chloe_2> unfortunately I bragged to someone that this would probably be three words or so in Haskell. I should not have said so when I haven't used it in years. It felt traversy to me, and I thought it would be simple
20:00:35 <ski> hm, i thought dpiponi's <http://blog.sigfpe.com/2006/10/monads-field-guide.html> has a picture of `StateT s []', but it seems like it doesn't (but the other pics are nice, i think)
20:01:35 <ski> well, it's not hard to do what you want, for the particular `Tree' type above, of course
20:01:37 <zeta_0> does anyone here know of a good link that explains the state monad well?
20:02:00 <zeta_0> that's the one monad so far that i haven't been able to wrap my head around
20:03:00 <chloe_2> isn't "multitraversal" just a map with state?
20:03:31 <ski> zeta_0 : well, maybe you could try one of the first (the first ?) monad tutorials ever (not counting papers intended for researchers) : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> ?
20:05:05 <ski> zeta_0 : it's slightly dated (e.g. `accumulate' is now called `sequence'), but i like that it's practically oriented
20:05:27 <chloe_2> ski: I can't figure it out for tree either though, I didn't even notice that my solution was stupidly wrong
20:06:04 <zeta_0> ski: thanks
20:06:45 <ski> zeta_0 : but it would probably help to have some practice with explicit state-passing-style, e.g. write a function `label :: Tree a -> Tree (Integer,a)' that labels all elements in a tree, starting from zero
20:07:51 <zeta_0> ski: ahh, and tree data structures are my weakness
20:08:07 <ski> chloe_2 : keep an accumulator for the current path, so far. put it in the current node (extended or not, as you want it). call recursively with extended path
20:08:45 <chloe_2> oh, no funky high-level combinators to recommend as yet?
20:09:10 <zeta_0> i just finished working through learn you a haskell, and i understood about 80% of the book
20:09:36 <ski> zeta_0 : could also do some other problem that required passing state both into and out of calls, threading it through calls. doesn't have to be recursive either. but recursion on trees is probably one of the simplest examples to cook up which gives practice on this
20:10:22 <ski> chloe_2 : there might be something in the lens stuff for doing it
20:10:23 <zeta_0> i'm going to try working throught real world haskell, because i want start writing some more practical haskell code
20:11:39 <zeta_0> ski: cool, i guess i'll try trees that pass state like you recommend, but i want to work through the other link you sent me 1st
20:12:11 <ski> zeta_0 : well, LYAH tends to not be that much recommended anymore, since it doesn't have exercises (although it has pretty pics), and because it's explanations of some things are deemed to not be that good, not in-depth or explanatory enough. it has been likened with a "four-hour long film trailer"
20:12:43 <ski> zeta_0 : and RWH is a bit dated, since libraries have moved on. but general ideas in it are probably still worthwhile
20:13:02 <ski> @where AAM
20:13:02 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
20:13:10 <ski> zeta_0 : did you see ^ yet ?
20:13:15 <sm[m]> zeta_0: nothing wrong with real world haskell, except for being a bit old.. but did you look at HTAC yet ?
20:13:24 <ski> @where HTAC
20:13:24 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
20:14:02 <sm[m]> woah, high five ski
20:14:17 * ski low fours sm[m]
20:14:34 <dsal> zeta_0: what real world stuff do you want to do?  I find it easier just to start with what I want and fight until I have a working program.
20:15:01 <zeta_0> here's an up do date real world haskell, it's not completed yet though: https://github.com/tssm/up-to-date-real-world-haskell
20:17:04 <ski> @where CIS194
20:17:04 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
20:17:20 <zeta_0> dsal: i did yesod for a while because i wanted to build some websites, but it felt way too complicated, those dsl's and template haskell can be hard to understand, as well as Yesod's complicated type classes
20:17:22 <ski> zeta_0 : you could also give those exercises ^ a try, if you want to
20:18:34 <zeta_0> ski: thanks, but the minimum price for that cookbook is 5 bucks, does it accept paypal?'
20:18:46 <dsal> zeta_0: I've been using scotty for my GoPro interface.  Web.hs is 85 lines currently. 
20:18:50 * ski has no idea, sorry
20:19:08 <zeta_0> ski: thanks, i think that's plenty to keep me going for a while
20:19:10 * ski looks at sm[m]
20:20:12 <dsal> haha.  My package.yaml is larger than my web server code.
20:21:15 <zeta_0> dsal: yes but there aren't too many books for haskell web development, i think i saw 2 newly released haskell web development books on amazon, i need to check them out, maybe they will be easier to understand than yesod
20:21:20 <ski> chloe_2 : i guess if you have something like `multiTraverse :: (MultiTraversable t,Alternative i) => (a -> i b) -> (t a -> i (t b))', it would be easy
20:21:21 <dsal> Most of the work isn't web, though.  So I have web handlers like:        get "/api/areas" (lift selectAreas >>= json)
20:21:53 <ski> hm
20:21:56 <dsal> I don't typically learn from books.  I just make the stuff I need.  Then I figure out what people were telling me that I should've been doing in the first place.
20:23:05 <chloe_2> @let  go f acc (Node r ts) = Node (f acc r) ((fmap $ go f $ f acc r)  ts)
20:23:08 <lambdabot>  Defined.
20:23:20 <chloe_2> > go (++) [] mytree
20:23:22 <lambdabot>  Node {rootLabel = "B", subForest = [Node {rootLabel = "BA", subForest = []},...
20:23:40 <zeta_0> does anyone here know when the book haskell from 1st principles is going to be officially released(fully completed)? i heard that it's a really good haskell book
20:23:42 <ski> yes (i'd share `f acc r')
20:24:07 <dsal> zeta_0: I thought it was done.  If it's not, it'll probably be done before you can get to the end of it.
20:24:07 <zeta_0> dsal: well, i'm still a haskell beginner, so books help me out a lot
20:24:26 <ski> chloe_2 : good enough ?
20:24:35 <chloe_2> share?
20:24:54 <zeta_0> i heard it's over 1000 pages, that's insane
20:25:02 <chloe_2> wouldn't that be handled by the compiler? Some sort of thunk-matching? I can't remember what it was called
20:25:12 <ski>   go f acc (Node r ts) = Node acc' (map (go f acc') ts) where acc' = f acc r
20:25:16 <MarcelineVQ> zeta_0: it's been essentially done for a long time
20:25:19 <dsal> haskellbook is good for learning.  It teaches you how haskell works.  Books that teach you how to make a thing in a framework teach you one of millions of ways to do things.  Might imply a couple other ways. Most such things don't help me much, anyway.
20:25:40 <ski> chloe_2 : GHC doesn't do CSE, generally. it can sometimes drive up space usage
20:25:42 <dsal> I was trying to learn how to do a stupid thing in javascript today...streaming from an http response.  All the streaming tutorials tell you how to stream from a file.
20:26:17 <chloe_2> ski: oh thanks, I didn't know that. Anyway, your style is also good for readability
20:26:44 * ski is mostly not fond of using `$' at all
20:26:48 <chloe_2> but I couldn't show off any combinator magic :(
20:27:00 <ski> yea, there's that :/
20:27:25 <zeta_0> MarcelineVQ: i don't think it's fully completed, it says it will send period emails of the book when it gets updated
20:27:32 <MarcelineVQ> zeta_0: it's been essentially done for a long time
20:27:33 <zeta_0> periodic
20:27:50 <dsal> How long do you want it to be before you start?
20:27:58 <chloe_2> I'd certainly prefer ($) over "))))"
20:28:19 <ski> -NickServ- Last seen  : Apr 22 21:58:47 2019 (49w 6d 5h ago)
20:28:26 <ski> (re bitemyapp)
20:28:59 <dsal> Did he move on to python?
20:29:14 <zeta_0> ok, maybe i'm wrong, i was just wondering, i don't know if it's worth paying for it though, i usually download my haskell books for free off the internet
20:29:51 <MarcelineVQ> it was worth it for me
20:29:57 <dsal> I liked it quite a lot.
20:30:13 <ski> i prefer `f x . g . h y z $ blah' over `f x $ g $ h y z $ blah'. and usually/commonly prefer `(f x . g . h y z) blah' over either of those. also not that bothered by `f x (g (h y z blah))', unless there's a lot of parenthesis ending at the same place, or a lot of them (nested) spanning many lines
20:31:00 <ski> dsal : no idea. perhaps just isn't much on IRC nowadays ? perhaps got busier with other things in life ?
20:31:17 <LarryTheCow> lisp debunked
20:31:48 <MarcelineVQ> he does have a job :>
20:32:16 <ski> well, i think people tend to be too afraid of brackets. i find Scheme quite nice :)
20:32:56 <zeta_0> cool, thanks for the info everyone
20:32:59 <ski> (of course, it assumes that one's indenting them correctly)
20:33:45 <chloe_2> for a single line, it would be cool if IDEs underlined bracketed items, so you could see the nesting
20:34:37 <ski> there's things like (iirc name) "rainbow mode" in Emacs, which colors matching brackets in the same color, cycling through a list of colors, as you nest deeper
20:35:17 <chloe_2> that sounds useful, I was picturing the multiple underlines in different colors
20:35:52 <ski> (also `M-x show-paren-mode' highlights the other matching bracket, if you put point in editor at a bracket)
20:36:27 <chloe_2> the point of underlines would be to hide the ugly brackets altogether
20:36:47 <chloe_2> and just see the tree structure right there
20:37:03 <LarryTheCow> ski: Been using emacs for almost a year and I didn't know that. Thanks
20:37:14 <ski> if one wants to get a bit more fancy, there's also commands for moving up down and sideways in the bracketed tree. `paredit' is a more advanced version of that
20:37:34 <zeta_0> ski: ya, i've been wanting to setup something like rainbow-mode in emacs, there's also a couple of nice vscodium features that i would like to setup in emacs as well
20:38:08 <zeta_0> emacs is a nice tool
20:38:08 <ski> (`paredit' doesn't allow one to have unbalanced brackets. can also do XML stuff, iirc)
20:38:35 <LarryTheCow> Are you on ERC rn?
20:38:41 <ski> nope
20:38:56 <zeta_0> dsal: you said you work doing javascript right? i have a couple of questions
20:39:01 <dsal> I do not.
20:39:23 <zeta_0> dsal: sorry, i could have sworn you had said that a while ago, apologies
20:39:28 <dsal> I just used it today to solve a problem because it fit best.  I try to avoid it, but I've written some before.  Mostly UI.  I think it's especially dumb as a sever-side language.
20:39:41 <dsal> I wrote my GoPro interface in elm.  It's much less dumb.
20:39:41 <LarryTheCow> SICP for JS might help /s
20:40:18 * ski . o O ( "Lisp Cycles" <https://xkcd.com/297/> )
20:41:13 <ski> (although some people think they look like nail clippings)
20:41:18 <dsal> I have some kind of lens dyslexia.  I keep typing stuff like ~?
20:41:43 <MarcelineVQ> whereas when you mention lens other people tend to go ???
20:42:15 <dsal> heh
20:42:21 <ski> i've noticed i often type "type", when i mean to type "typo"
20:42:33 <zeta_0> vscodium comes with built-in language server support for js, css, and html, but i was not able to add similar functionality to my .emacs
20:43:10 <dsal> emacs is just a lisp interpreter.  You don't have to write such dirty things.  :)
20:43:10 <zeta_0> LarryTheCow: thanks, i'll take a look at that sicp in js
20:43:13 * hackage smash 0.1.0.0 - Smash products - like 'These', but with a unit!  https://hackage.haskell.org/package/smash-0.1.0.0 (topos)
20:43:27 <dsal> I've written some pretty cool apps in emacs.
20:43:41 <ski> btw, there are proposals to write Lispish expressions, without brackets, relying solely on indentation
20:45:33 <ski> (such as <https://srfi.schemers.org/srfi-49/srfi-49.html>,<https://srfi.schemers.org/srfi-119/srfi-119.html>)
20:45:33 <chloe_2> ski: can you help me generalize that `go' function? I feel like it would turn out to be scanr for lists, but I'm struggling with the generalizatoin
20:46:25 <zeta_0> dsal: how does elm compare to haskell, i'm just curious?
20:46:44 <dsal> It doesn't have type classes.  It has really amazing error messages, though.
20:47:40 <ski> i'm thinking, chloe_2
20:48:36 <zeta_0> oh, ok, that's nice
20:48:45 <ski> what is ?
20:48:50 <ski> oh
20:49:15 <dsal> Not having type classes is kind of a bummer.  But the error messages...
20:50:10 <chloe_2> dsal: what does it do instead of type classes? surely not mapMaybe and mapList etc?
20:50:43 <dsal> Other way around...  Maybe.map, List.map, etc...
20:50:48 <dsal> So it has functors, but they're all Thing.map
20:50:56 <ski> chloe_2 : on second thought (already having doubts, just after i wrote it), i think that `multiTraverse' is not what we want here. the nondeterminism should come from the branching in the structure, not from the action we invoke on each element
20:51:33 <chloe_2> ski: right, I agree with that
20:51:50 <ski> chloe_2 : and we want a single structure at end, not nondeterministically many ones. although it could be nice if we got the "left over" states, at each leaf
20:51:53 <zeta_0> dsal: ya, i heard elm's error messages are great, haskell's and nix's error messages can be very cryptic and long
20:52:36 <dsal> here's a screenshot of a time I tried to use `head` on a list in elm: https://usercontent.irccloud-cdn.com/file/1ThMJzVn/elmerr.png
20:52:47 <chloe_2> ski: by that sentence you mean something like "it's more of a map than a traverse" right?
20:53:14 * hackage tracing 0.0.5.1, tracing 0.0.5.0 (mtth): https://qbin.io/drives-land-qmq4
20:53:16 * hackage ghc-lib-parser-ex 8.10.0.4 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.4 (shayne_fletcher)
20:53:18 * hackage bioinformatics-toolkit 0.9.3.1, bioinformatics-toolkit 0.9.3 (kaizhang): https://qbin.io/date-yeast-27zu
20:53:20 * hackage ulid 0.3.0.0 - Implementation of ULID - Universally UniqueLexicographically Sortable Identifier  https://hackage.haskell.org/package/ulid-0.3.0.0 (adrian)
20:53:22 * hackage modern-uri 0.3.2.0 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.3.2.0 (mrkkrp)
20:53:24 * hackage ngx-export-tools-extra 0.4.1.0, ngx-export-tools-extra 0.4.0.0, ngx-export-tools 0.4.8.0 (lyokha)
20:53:26 * hackage store 0.7.4, store 0.7.3 (MichaelSloan): https://qbin.io/raised-saints-wk3q
20:53:28 * hackage gopro-plus 0.3.0.1 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.3.0.1 (dustin)
20:53:29 * hackage hadoop-streaming 0.2.0.1, hadoop-streaming 0.2.0.0 (zliu41): https://qbin.io/dover-smoke-2stv
20:53:32 * hackage ghc-events 0.13.0 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.13.0 (MitsutoshiAoe)
20:53:34 * hackage lens-th-rewrite 0.3.0.0 - Rewrites Template Haskell splices using the API  https://hackage.haskell.org/package/lens-th-rewrite-0.3.0.0 (DavidJohnson)
20:53:36 * hackage musicScroll 0.2.3.2, musicScroll 0.2.3.1, musicScroll 0.2.3.0 (RubenAstudillo): https://qbin.io/glory-idle-bj9j
20:53:39 <dsal> ahhh
20:53:41 * hackage rattletrap 9.0.10, strive 5.0.10, ratel-wai 1.1.2, ratel 1.0.10, wuss 1.1.16, salve 1.0.9, rampart 1.0.0.3, list-singleton 1.0.0.3, lackey 1.0.12, json-feed 1.0.9, github-release 1.2.6, flow 1.0.20, derulo 1.0.8, autoexporter 1.1.16, burrito 1.0.0.2, burrito 1.0.0.1, burrito 1.0.0.0 (fozworth)
20:53:43 * hackage unicode-tricks 0.3.0.0, unicode-tricks 0.2.0.0, unicode-tricks 0.1.0.0 (wvanonsem90): https://qbin.io/anal-herbal-hkyg
20:53:45 * hackage generic-data 0.8.3.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.8.3.0 (lyxia)
20:53:46 <MarcelineVQ> weird, I thought there was a heuristic for that to not happen
20:53:47 * hackage sak 0.1.2.0, archive-sig 1.0.1.0 (vmchale): https://qbin.io/paste-amber-zmm4
20:53:49 * hackage hw-json-standard-cursor 0.2.1.3, example-haskell-project 0.1.0.0 (haskellworks): https://qbin.io/cart-motion-qkbs
20:53:50 * hackage dobutokO2 0.24.1.0, dobutokO2 0.24.0.0 (OleksandrZhabenko): https://qbin.io/temp-ruled-r9n9
20:53:51 <MarcelineVQ> @where ops
20:53:51 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
20:53:52 * hackage speculate 0.4.2 - discovery of properties about Haskell functions  https://hackage.haskell.org/package/speculate-0.4.2 (rudymatela)
20:53:55 * hackage haskell-say 1.0.0.0 - Let the Haskell logo talk to your users!  https://hackage.haskell.org/package/haskell-say-1.0.0.0 (DrewHaven)
20:53:57 * hackage inline-c 0.9.1.0 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.9.1.0 (FrancescoMazzoli)
20:53:59 * hackage homura-stopwatch 0.1.3 -   https://hackage.haskell.org/package/homura-stopwatch-0.1.3 (ncaq)
20:54:01 * hackage lens-csv 0.1.1.0 -   https://hackage.haskell.org/package/lens-csv-0.1.1.0 (ChrisPenner)
20:54:03 * hackage jira-wiki-markup 1.3.0 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.3.0 (tarleb)
20:54:05 * hackage ShellCheck 0.7.1 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.7.1 (vidarhol)
20:54:06 * hackage smash 0.1.0.0 - Combinators for Maybe types  https://hackage.haskell.org/package/smash-0.1.0.0 (topos)
20:54:13 <zeta_0> dsal: wow, that error message looks nice, i can actually understand it
20:54:13 <chloe_2> nice
20:54:27 --- mode: ChanServ set +o glguy
20:54:36 <Cale> I guess we could mute hackage
20:54:40 --- mode: ChanServ set +q *!hackage@haskell/bot/hackage
20:54:45 <Cale> It might stop on its own...
20:54:56 <MarcelineVQ> that's a pretty verbose error message, just in a different way
20:55:18 <glguy> mniip: poke
20:56:00 <glguy> I guess I should tell sigyn not to server-ban hackage
20:56:50 <MarcelineVQ> speaking of uselessly verbose messages... *adds -fno-show-valid-hole-fits to cabal.project.local*
20:57:20 --- mode: ChanServ set -q *!hackage@haskell/bot/hackage
20:58:19 <chloe_2> ski: I guess it would work for a type like TreeLike s a = RootLike a | BranchLike s a, which List and  Tree are both an instance of?
20:58:20 <ski> chloe_2 : well, `mapM' and `traverse' is the same thing. and we want to keep some kind of state, so plain `fmap' isn't enough
21:00:32 <chloe_2> List = TreeLike List and Tree = TreeLike (List Tree) or something
21:00:52 <chloe_2> and hopefully we can get graphs to fit as well?
21:01:15 <ski> by `RootLike', do you mean `LeafLike' ?
21:01:57 <chloe_2> ski, yeah sorry
21:05:37 <ski> hm, i'm thinking about how to related a tree with internal nodes to one with leaves
21:05:44 <ski> s/related/relate/
21:10:41 <ski>   mapAccumDescend_ :: Descendable t => (s -> a -> (s,b)) -> s -> t a -> t b  -- one can imagine something like this
21:11:19 <ski> but it's specialized to deal with state (only), not some larger class of effects (as `traverse' is)
21:12:04 <ski> (and it doesn't give back the final `s's in leaves)
21:15:16 <chloe_2> that looks exciting. What do you have in mind for Descendable?
21:19:17 <shapr> dang, I got paged
21:21:08 <ski> chloe_2 : hm, well. `mapAccumDescend_' as a method is the obvious thing
21:21:45 <chloe_2> I'd be fine with mapAccum :: Descendable t => (a -> b -> b) -> t a -> t b, not sure why you're even bothering with state
21:22:02 <chloe_2> sorry that's mapAccum :: Descendable t => (a -> b -> b) -> b -> t a -> t b of course
21:22:05 <ski> shapr : hackage (bot) was "running amok" a little
21:22:35 <MarcelineVQ> running armok even
21:23:11 <ski> i guess, chloe_2
21:23:49 <ski> i'm not sure what would be a better ("finer-grained" in some sense ?) method(s) for `Descendable' (or something like that)
21:24:17 <chloe_2> something that lets you apply a function to the leaflike parts vs the branchlike parts?
21:24:27 <chloe_2> mapLeaf and mapBranch
21:24:28 <ski> and, it doesn't feel that nice, general, to me. is there even much point of having it as a type class ?
21:25:05 <ski> (is there a need/want to overload over different kinds of trees, each having a canonical descend operation ?)
21:25:06 <chloe_2> ski: true, I don't see any other except list and tree, I guess I just wanted a generalized scan
21:25:43 <ski> (if i saw a way to generalize from just state, it'd think it could be more useful)
21:26:07 <chloe_2> and was hoping *ahem* for there to be an existing way to do this, since descending
21:26:14 <ski> (or, maybe, if one could generalize from branching nondeterminism, to also other kinds of effects (or collections ?))
21:26:16 <chloe_2> …is such an obvious operatoin
21:26:44 <ski> anyway, as i said, there may be something lensy capable of doing what you want
21:27:11 <chloe_2> ski: any pointers to where I should begin looking for it? HaskellWiki?
21:27:24 <ski> you could ask in #haskell-lens, i suppose
21:28:41 <ski> there are ways to "focus" on multiple elements, e.g. updating each of them with some operation. something related to that may be available, for doing what you're after. i dunno
21:28:56 * hackage web-rep 0.3.2 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.3.2 (tonyday567)
21:40:58 <chloe_2> thanks for your help ski, I asked #haskell-lens
21:43:37 <ski> yw, chloe_2
21:44:40 <ski> (it might take some time until people there notice your question, i guess)
