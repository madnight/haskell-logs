00:07:13 * hackage cobot-io 0.1.3.0 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.0 (ozzzzz)
00:24:37 <Guest_90> Hello!
00:47:01 <nevere_> When I am in GHCI repl, how can I get warinings from all the files in the current stack project, even if it is unchanged, during a reload?
01:11:10 <whataday> I compiled a code with ghc -optl-static on debian, and I run the executable file on archlinux, and I got "Segmentation fault (core dumped)"
01:11:28 <whataday> is that normal?
01:11:36 <merijn> whataday: Since you're on linux: yes
01:11:55 <whataday> merijn is there a solution?
01:11:59 <merijn> whataday: glibc has some (intentional) hacks that make it hard, if not impossible, to statically link glibc
01:12:07 <merijn> whataday: "don't use glibc"
01:12:25 <whataday> function hsnet_getadd rinfo: warning: Using 'getaddrinfo' in statically linked applications requires at runt ime the shared libraries from the glibc version used for linking
01:12:35 <merijn> Right, there you go
01:12:46 <whataday> how I can solve it
01:12:54 <whataday> replace some functions or libs?
01:13:21 <merijn> Like I said: "don't use glibc", but since that's hardwired into most linux libraries and toolchains that means setting up a custom non-glibc toolchain
01:13:27 <merijn> Using something like musl as libc
01:13:48 <merijn> I think there's an Alpine Linux (uses musl instead of libc) docker container you can use, but I don't know the details
01:14:42 <whataday> how to set it to not use glibc with ghc?
01:15:10 <whataday> this is haskell's lib use glibc or ?
01:16:16 <merijn> whataday: The GHC runtime uses libc, which means glibc on most linux distributions. So you need to build GHC with a different libc (like musl), which in turn requires a C compiler (gcc or clang) which uses musl instead of glibc
01:16:41 <merijn> Note that you also have to build all non-haskell libraries you use with this musl-based gcc
01:17:02 <Athas> I think in practice, most people who produce static Haskell binaries use Nix to get all of the troops in position.
01:17:44 <whataday> wow, that's a lot
01:18:16 <whataday> build GHC will take how much time?
01:18:41 <whataday> intel i3 cpu, and 4G RAM
01:18:56 <Athas> 4G?  Uh.  That may not be enough.
01:19:19 <polyphem>   
01:19:27 <whataday> config Nix is hard
01:19:39 <merijn> On my laptop GHC from scratch takes about 45 minutes to an hour to compile, but I do have more than 4GB RAM
01:20:09 <merijn> whataday: This is why I recommended looking for this Alpine Linux docker container, since that already has GHC build with musl :)
01:20:13 <yushyin> whataday: alpine linux is one alternative if you don't like to use nix
01:21:50 <whataday> https://hub.docker.com/search?q=alpine&type=image
01:21:56 <whataday> which one is?
01:23:24 <merijn> I think maerwald was looking into this at some point, but I also think this resulted in frustrated ranting about the insanity of glibc, so... :p
01:24:28 <merijn> The damage one zealout can wreak on the entire world >.>
01:27:25 <whataday> why the most distros use glibc?
01:27:36 <whataday> why not libc or musl?
01:28:34 <whataday> if I use the official alpinelinux docker image, then install ghc inside, is that ok?
01:28:46 <whataday> alpine prove binary ghc package?
01:31:16 <merijn> whataday: libc is a specification, glibc is one possible implementation by GNU. Since linux is based on a GNU core, that's what they use
01:33:28 <whataday> merijn then why the binary will crush by using glibc, and musl won't? what's the difference between glibc and musl?
01:33:49 <whataday> even they're all implementation of libc
01:35:26 <yushyin> 'requires at runtime the shared libraries from the glibc version used for linking' because you are missing the right shared library
01:36:48 <merijn> whataday: One of the glibc core committers is a "true believer" who thinks static linking is bad
01:37:06 <merijn> whataday: The hacks that cause glibc to break when linked statically are *intentional*
01:37:24 <whataday> I found this https://hub.docker.com/r/mitchty/alpine-ghc
01:37:33 <merijn> Because one of its core committers doesn't *want* you to statically link it
01:37:33 <whataday> but it's out of date...
01:38:13 * hackage acme-dont 1.2 - A "don't" construct  https://hackage.haskell.org/package/acme-dont-1.2 (jack)
01:38:15 <merijn> musl (and the libc used on the various BSDs) work just fine when linked statically
01:38:33 <whataday> merijn the glibc core committers must use archlinux!
01:38:59 <yushyin> why?
01:39:13 <merijn> yushyin: Arch also hates static linking
01:39:26 <yushyin> not really
01:39:26 <merijn> yushyin: That's why the GHC toolchain it installs by default is horribly broken
01:40:01 <merijn> yushyin: They hate it enough to install a broken GHC and force everyone to update 300 haskell package when updating pandoc >.>
01:40:02 <yushyin> yeah but ghc is also horrible broken for shared libs, so it's bad in both ways
01:40:04 <yushyin> :)
01:40:39 <merijn> yushyin: GHC isn't horribly broken for shared libs, though
01:40:52 <yushyin> arch isn't horrible broken for shared libs either
01:41:07 <yushyin> it is just a bad matchup
01:41:40 <merijn> yushyin: THe problem with Arch is that it only installs dynamic libraries for GHC while GHC *by default* links Haskell code statically. So by not installing the static libs any "standard" GHC invocation breaks
01:41:40 <whataday> ghc is easy to use on debian than archlinux
01:44:06 <merijn> haha, that acme-don't release announcement :D
01:46:11 <dibblego> jackdk :)
01:46:54 <jackdk> dibblego: :)
01:48:11 <yushyin> merijn: I dislike the hatespeech I often see here against arch linux while ghc doesn't guarantee abi compatibility for shared libraries (yet). The arch linux builds work ok if you only use them to install haskell tools like pandoc and co. Arch also provides ghc-static. But truth be told I also think the situation with haskell on arch is not great and also I dislike to use distribution provided ghc
01:48:13 <yushyin> for developing anyways. I want more control which ghc version per project I gonna use. So I always recommend ghcup (or stack).
01:53:26 <whataday> if the compiled environment and runtime environment has the same glibc verion, this can run the executable file on both ?
01:55:43 * hackage language-avro 0.1.3.1 - Language definition and parser for AVRO files.  https://hackage.haskell.org/package/language-avro-0.1.3.1 (FlavioCorpa)
01:55:55 <dibblego> am I not doing it right or is tagsoup build not correct? https://gist.github.com/tonymorris/5bcf69b1bdc9de2a6d4291d457abed30
02:04:12 <merijn> yushyin: GHC is unlikely to ever support ABI compatibility as it doesn't even define an ABI at the moment
02:04:31 <merijn> whataday: That should work, yes
02:06:34 <whataday> ok
02:12:58 <maerwald> Static Linux binaries with alpine work fine
02:21:56 <funrep76> hello! i want to install HUnit globally, to be able to run a scripted setup where I replace a module and re-compile my project with "ghc File.hs -e "method"", however ghc doesn't find the package by defualt so i need to find a way to provide the path, i installed it using cabal and its in the folder ".cabal/store/ghc-8.8.3/HUnt-1.6.0.0"
02:23:32 <maerwald> But make sure you don't have c++ dependencies. It blows up linking 
02:25:36 <funrep76> extra note: "ghc-pkg list | grep HUnit" does not yield anything, so it seems like i need to provide some extra information to ghc to compile a file using HUnit
02:29:13 <merijn> funrep76: You have cabal-install 3.0?
02:29:28 <merijn> oh, yeah, you do by the looks of the install path
02:30:23 <merijn> funrep76: cabal-install 3.0 doesn't really do global installs anymore
02:30:53 <merijn> funrep76: You can manually load stuff into an environment file to get that behaviour, but I forget the command
02:31:18 <merijn> Probably easier to just create a simple cabal file for your project
02:32:10 <funrep76> yeah that is probably best solution in the end, i will see if i find that environment command though
02:34:08 <merijn> funrep76: There's some related comments here: https://github.com/haskell/cabal/issues/6478
02:34:24 <merijn> But the docs really need to be expanded a bit on how to do this
02:35:43 <merijn> funrep76: See also: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-environments
02:35:54 <maerwald> cabal repl --build-depends lens
02:35:58 <maerwald> Is a shortcut too
02:36:15 <maerwald> Add whatever deps you need via --build-depends 
02:36:16 <funrep76> thanks for the pointers!
02:39:54 <merijn> funrep76: Basically, v3.0 has a global store which allows arbitrarily many parallel installs of packages so you never have conflicts between projects. But this means that you somehow need to control "which parts of the store are visible", all the invidual bits are there, afaik, but I don't think anyone has written a nice comprehensive explanation of how to use them yet
02:41:46 <maerwald> And sandboxes are gonna be removed soon
02:53:43 * hackage ghcflags 1.0.3 - Dump the ghc flags during compilation  https://hackage.haskell.org/package/ghcflags-1.0.3 (tseenshe)
03:03:25 <Geekingfrog> I'm trying to write a function splitLast, which returns a list but its last element, and its last element in a tuple https://pastebin.com/rB5pLKmk Is there a way to write that with a fold, in such a way that it still works for inifinite list, when taking only some elements of the list.
03:10:38 <MarcelineVQ> I'm a bit confused about your requirements. an infinite list doesn't have a last element so a function that gets the last element of a list can't work for an infinite list. but you can  take n  on an infnite list and pass what that gives you to your function
03:11:52 <Souper> https://wiki.haskell.org/GADTs_for_dummies#Back_to_real_Haskell_-_type_classes
03:11:52 <Souper> Shouldn't `class Replace t a b res` also have `instance Replace a a b b`?
03:12:26 <Souper> i'm pretty new to GADTs but I can't really see where the actual replacement takes place in that example
03:13:24 <merijn> Souper: That instance would overlap *everything*
03:13:57 <merijn> Well, not everything, I suppose. But enough to be painful
03:15:48 <Souper> so, the way I understand it,`Replace t a a t` covers the trivial case where we are trying to replace a type by itself
03:16:16 <Souper> the next three cases are a recursion into lists, sets and maps
03:16:56 <Souper> and the last case just "returns" a type that did not match the type `a`
03:18:00 <gentauro> Haskells `negate` (https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:negate) is not the same as C `~` operator right?
03:18:32 <gentauro> (what I'm aiming at is to flip all the bits for a given value)
03:18:45 <MarcelineVQ> Geekingfrog:  splitLast :: NonEmpty a -> ([a], a); splitLast (x :| []) =  ([],x); splitLast (x :| (z : xs)) = let (ys,y) = splitLast (z :| xs) in (x:ys,y)   this is how I'd approach that sort of task, taking advantage of recursion rather than a helper, and NonEmpty instead of Maybe
03:19:07 <Souper> gentauro: negate just changes the sign of the number
03:19:26 <merijn> gentauro: You want Data.Bits
03:19:52 <merijn> :t complement
03:19:54 <lambdabot> Bits a => a -> a
03:20:05 <merijn> > complement -1 :: Int
03:20:08 <lambdabot>  error:
03:20:08 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘a0 -> a0’
03:20:08 <lambdabot>      • Probable cause: ‘(-)’ is applied to too few arguments
03:20:15 <merijn> > complement (-1) :: Int
03:20:19 <lambdabot>  0
03:20:44 <gentauro> merijn: thanks !!!
03:20:46 <Geekingfrog> MarcelineVQ, the "requirement" about infinite list is more an exercise but yes, it doesn't really make sense.
03:20:52 <gentauro> that's exactly what I'm looking for :)
03:37:17 <Souper> Ok, so I tried implementing the example at https://wiki.haskell.org/GADTs_for_dummies#Back_to_real_Haskell_-_type_classes
03:37:24 <Souper> the Replace class
03:38:08 <Souper> and then defined `x = undefined :: Replace [[Int]] Int Float t => t`
03:38:29 <Souper> and `f = undefined :: [[Float]] -> Bool`
03:39:39 <Souper> and when I call `f x`, type matcher says that there's no instance for `Replace Int Int Float Float`
03:40:22 <Souper> but when I also add `instance Replace a a b b`, then it matches
03:41:20 <Souper> type checker* checks*
03:44:33 <Souper> could it be a mistake in the wiki?
03:59:57 <opqdonut> Souper: I think in addition to the "Replace t a a t" instance, you need a "Replace "a a b b" instance
04:00:35 <opqdonut> didn't really bother reading the context, just looked at the Replace example
04:04:38 <Souper> yea, that's what I figured
04:04:46 <Souper> i think they omitted that in the wiki
04:04:53 <Souper> probably by accident
04:07:43 * hackage ngx-export-tools-extra 0.3.2.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.3.2.0 (lyokha)
04:51:56 <absence> my code stops compiling just by enabling the TypeFamilies extension. are there some common gotchas i should look into? the error is couldn't match type a with b because a is a rigid type variable bound yadda yadda (i have a RankNTypes function parameter with forall a, which is the "a" in question)
04:52:22 <dmj`> absence: can you paste your code here in a gist
04:54:08 <merijn> And the error :p
04:56:50 <dmj`> merijn: do you have experience with the GHC API
04:58:27 <absence> dmj`: i'll try to reduce it
04:58:58 <merijn> dmj`: Does "I looked at it and noped out" count?
04:59:10 <dmj`> merijn: yes
04:59:53 <merijn> Then yes :p
05:01:33 <dmj`> merijn: so I have this GHC plugin right, it modifies the AST after the parse phase, for some reason it parses the type signature "age :: Lens' Person Int" as a SigD where "Person", 'Int' are considered type variables (HsTyVar), which I think is wrong because these arent' type variables
05:02:17 <dmj`> merijn: so this leads to hitting errors I've never seen before like, "Illegal promoted term variable in a type: Lens'"
05:02:44 <merijn> That's well beyond me :)
05:07:46 <absence> dmj`: code is at https://pastebin.com/L3S5yfGs error is at https://pastebin.com/HufR49Za
05:08:47 <dmj`> absence: have you considered removing the type signature and seeing if ghc can infer it for you
05:09:40 <dmj`> merijn: me too ;_; 
05:09:46 <absence> dmj`: i did now, it can't (because of RankNTypes?)
05:13:28 <dmj`> absence: (Functor f, Monad m) => (forall x. f x -> g x) -> Stream f m r -> Stream g m r 
05:13:34 <dmj`> w/ RankNTypes
05:14:52 <phadej> ocharles: do you need `packages *` for weeder to work, or is it enough to specify it for local packages?
05:15:03 <dmj`> absence: note, this is just the definition of S.maps
05:15:30 <absence> dmj`: this is the minimised test case, not my code
05:16:10 <absence> well, not completely minimised it seems :)
05:16:48 <absence> dmj`: anyway, the point is that it doesn't compile, even with your simplified type signature
05:17:06 <phadej> ocharles: also README doesn't mention which file to put configuration into
05:17:12 <absence> dmj`: unless i remove TypeFamilies, then it magically works
05:17:52 <dmj`> absence: yes, type families aren't needed.
05:17:59 <bennofs> can cabal new-build print the install plan that would be used if no packages were in my ~/.cabal/store ?
05:18:20 <absence> dmj`: i think you are misunderstanding
05:18:28 <absence> dmj`: this is a minimised test case, not my code
05:18:35 <absence> dmj`: in my actual code, i need TypeFamilies
05:18:44 <dmj`> absence: I think you are misunderstanding. If you're insisting on using TypeFamilies, then you need to enable ScopedTypeVariables
05:19:32 <absence> dmj`: right, now you're answering my question :) why do i need ScopedTypeVariables, and what for?
05:20:21 <absence> just enabling the extension doesn't seem to be enough
05:20:38 <dmj`> absence: scoped type variables allow the variables defined in the forall to be accessible in different scopes of the function body
05:21:10 <dmj`> absence: Can you paste the full code?
05:21:12 <hvr> bennofs: a) what's the purpose?  b) you can if you temporarily point --store-dir to an empty store
05:21:12 <absence> so TypeFamilies affects this in some way?
05:21:34 <absence> dmj`: unfortunately i can't paste the full code, but the code i pasted is enough to trigger the problem
05:21:49 <hvr> bennofs: c) do you maybe rather want to use https://hackage.haskell.org/package/cabal-plan ?
05:21:55 <dmj`> absence: so do you still experience type errors after enabling scoped type variables?
05:22:04 <absence> dmj`: as it is, it compiles without TypeFamilies enabled, but fails as soon as i enable it
05:22:17 <dmj`> absence: did you enabled ScopedTypeVariables
05:22:20 <dmj`> enable*
05:22:30 <absence> dmj`: yes, just enabling it doesn't help
05:22:42 <dmj`> absence: what is the error you have after enabling ScopedTypeVariables
05:23:03 <absence> dmj`: exactly the same as without
05:27:28 <dmj`> absence: ok, remove both TypeFamilies and ScopedTypeVariables
05:27:47 <dmj`> absence: try this
05:27:50 <dmj`> absence:  (Functor f, Monad m) => (forall f g x . f x -> g x) -> Stream f m r -> Stream g m r
05:29:46 <absence> dmj`: without TypeFamilies it compiles (as does the original code i pasted)
05:30:37 <absence> dmj`: (and the type signature you suggested earlier)
05:30:44 <dmj`> absence: if you enable TypeFamilies, you have to provide a type signature in the where block for stuff
05:30:52 <dmj`> stuff :: f x -> g x
05:31:09 <absence> oh!
05:31:12 <dmj`> absence: but you also have to introduce x in the forall for this to work
05:31:44 <dmj`> without 'x' in the forall it won't typecheck even w/o a local signature for stuff
05:33:05 <dmj`> even w/ **
05:33:13 * hackage futhark 0.15.3 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.15.3 (TroelsHenriksen)
05:33:34 <absence> dmj`: with ScopedTypeVariables, "forall f g m r. (Functor f, Monad m) => (forall x . f x -> g x) -> Stream f m r -> Stream g m r", and the signature for stuff, it compiles with TypeFamilies
05:34:47 <absence> dmj`: so to summarise, what i was missing when enabling TypeFamilies was that functions in where clauses need signatures? is that every function in where clauses, or just ones that depend on the RankNTypes parameter?
05:40:31 <dmj`> absence: it's odd type families would cause this not to compile
05:42:02 <dmj`> absence: but your solution to introduce f g m r into other scopes uses ScopedTypeVariables allowed ghc to infer the type of stuff in the where block
05:42:06 <dmj`> using*
05:42:39 <absence> dmj`: it doesn't infer, i have an explicit signature for "stuff"
05:42:58 <absence> f x -> g x
05:43:30 <dmj`> absence: right, you can just omit stuff altogether though, since your definition is just S.maps
05:43:38 <amf> i have a sum type A = A {- ~10 fields -} | B {- more different fields -} | C; is there a clever way to just pattern match on the A, B, or C and pass the arg on? something like `f args@A _` but where the _ covers all any number of fields? 
05:44:39 <opqdonut> amf: args@A{}
05:45:17 <absence> dmj`: of course, but this is what triggers the TypeFamilies compile error. the real code is more complicated, but i could reproduce the compile error with this contrived example
05:45:20 <bennofs> hvr: thanks, --store-dir is useful. Turns out I didn't need it, since in my case I start in a clean state anyway :p It's for some legacy travis script that prints out the install plan
05:45:39 <amf> opqdonut: doh! i should have known, i'm purposefully not using record syntax, but didn't realize that would work too, thanks!!
05:45:48 <bennofs> hvr: btw, what's the state of packunused? Does it compile on recent GHCs (8.8.3 for example)?
05:46:15 <opqdonut> amf: yeah it's kind of a hidden feature :)
05:46:25 <dmj`> absence: ghc just needs to know that stuff is just as polymorphic as f in other lexical scopes. And unless you have access to the type variables it can't infer it, hence why you need scoped type variables.
05:46:42 <dmj`> absence: as to why introducing type families causes a compile error, I don't know
05:47:13 * hackage ngx-export-tools-extra 0.3.2.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.3.2.1 (lyokha)
05:48:19 <absence> dmj`: yes, that's the confusing part. without TypeFamilies, ghc didn't need to know that stuff. but anyway, thanks for the help, it's good to know the next time enabling TypeFamilies prevents my code from compiling :)
05:49:44 <dmj`> absence: it might be a bug, you can ask on #ghc
05:51:11 <Ariakenom> Q1 closest thing to haskell spec is haskell report? Q2 haskell report is easy to read for being a report? Q3 haskell report is easier to read than c++ spec?
05:51:35 <merijn> Ariakenom: The report *is* the Haskell spec
05:51:54 <merijn> Ariakenom: It's easy to read and definitely *much* easier than the C++ spec
05:52:10 <merijn> Note that GHC doesn't entirely implement the Haskell2010 report
05:52:58 <Ariakenom> true, for some value of haskell :D
05:53:29 <maerwald> only the go spec is easier
05:53:35 <Ariakenom> allright, thats what i thought. just saw someone saying something strange on the internet
05:53:54 <merijn> maerwald: R6RS is fairly easy too
05:54:22 <merijn> Ariakenom: The scheme spec is also called the "Scheme report", incidentally
05:55:30 <merijn> Ariakenom: The report is very much intended and written as a spec. Although significantly less obtuse than the C and C++ ones
05:55:43 <Ariakenom> incidentally or not at all incidentally?
05:56:25 <absence> dmj`: will do!
05:56:35 <merijn> Ariakenom: I don't know if there was anything intentional about the naming. Although both reports are produced by academic committees with a programming language background, so that might play a role
05:58:00 <merijn> Ariakenom: Most of the complexity in the C and C++ spec comes from the complexity of the C abstract machine and describing everything in terms of its operational semantics. The Haskell report doesn't say much about operational semantics, making it much simpler. (This also means you can't reason operationally about "Haskell", only about "GHC Haskell")
06:08:46 <aveltras> can the following template haskell work somehow or do i have to use associated type instead of data type to be able to derive template haskell for it ? 
06:08:51 <aveltras> https://www.irccloud.com/pastebin/2HPJEEXG/
06:09:20 <aveltras> right now it complains that
06:09:21 <aveltras> $(makeBoomerangs ''(Sitemap Core))
06:09:30 <aveltras> https://www.irccloud.com/pastebin/dmAIh7q5/
06:34:43 * hackage ghc-lib-parser 0.20200401 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200401 (shayne_fletcher)
06:35:43 * hackage ghc-lib 0.20200401 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200401 (shayne_fletcher)
07:05:04 <merijn> phadej: I'm getting a build failure for cabal-install due to lukko and it using nonexistent fcntl flags...
07:05:20 <phadej> on which system
07:05:28 <merijn> phadej: Any clue how to go about debugging what might be causing that?
07:05:42 <merijn> CentOS linux, not sure about the version
07:05:49 <merijn> But probably "stupid old"
07:05:49 <phadej> merijn: https://hackage.haskell.org/package/lukko see flags
07:06:02 <phadej> yes, if you are on "stupid old" system, read the docs.
07:06:08 <[exa]> phadej: what are the fcntl flags btw?
07:06:59 <merijn> phadej: There's no way to specify flags for transitive dependencies in cabal, is there?
07:08:03 <phadej> merijn: no, that would be useful but is just too tricky to specify (flag set is not stable, flags can come and go based on version)
07:08:09 <phadej> [exa]: FFI stuff
07:09:30 <merijn> phadej: Rats, so do I need to clone cabal-install and set lukko flags via cabal.project or is there another convenient way of overriding the flags?
07:10:17 <phadej> `cabal v2-install cabal --constraint='lukko -ofd-locking'`
07:10:57 <merijn> phadej: Cheers!
07:12:04 <merijn> ok, that seems to work fine
07:36:40 <lyxia> aveltras: try passing one of the data constructors 'Dashboard
07:39:37 <justsomeguy> When I run "import Data.String", ":info IsString" it shows "instance (a ~ Char) => IsString [a]" in the output. What is the "(a ~ Char)" syntax here?
07:40:12 <aveltras> lyxia: i don't get what you mean by this
07:41:23 <dmwit> justsomeguy: It is type equality. They chose ~ instead of = because = already had too many meanings.
07:44:52 <dmwit> (And then the followup question is "Well then why didn't they write `instance IsString [Char]`?". The answer there is that because instance contexts are not considered when choosing an instance, and `a ~ Char` is in the context, the instance `a ~ Char => IsString [a]` matches more often, and so guides type inference: any time you see a list and which an `IsString` constraint on it, the compiler knows to 
07:44:58 <dmwit> choose `Char` as the element type even if the element type is polymorphic.)
07:46:37 <jchia__> Question about Data.ByteString.Unsafe.unsafePackCStringFinalizer :: Ptr Word8 -> Int -> IO () -> IO ByteString. My pointer is actually from an mmap. After I unmap, the pointer will be invalid and so will the ByteString. How can I force a ByteString to be made that is backed by its own memory but copying the content from the pointer? I'm trying to avoid using Data.ByteString.Internal. I know I could use Data.ByteString.Internal.u
07:46:38 <jchia__> nsafePackLenBytes.
07:49:43 <jchia__> If there's just a function to force a copy to be made of an existing ByteString, it should work for me.
07:50:08 <jchia__> I can just force-copy the ByteString I get from unsafePackCStringFinalizer
07:50:50 <justsomeguy> dmwit: Great, thanks for the explanation. If I want to read more about this, where should I go? Is this a GHC specific thing? I don't see any mention of that syntax in the language report or the book I'm reading.
07:52:02 <justsomeguy> ...although, it's pretty simple, so I guess I probably won't have to read more about it, anyways.
07:53:41 <solonarv> jchia__: there is 'copy' in Data.ByteString
07:53:52 <solonarv> make sure that it's actually evaluated right away, though!
07:55:21 <solonarv> packCStringFinalizer ptr len fin = evaluate . Data.ByteString.copy =<< unsafePackCStringFinalizer ptr len fin
07:55:32 <solonarv> jchia__: something like that should work ^
07:56:50 <dmwit> justsomeguy: Yes, it is GHC-specific. https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/equality_constraints.html has some info
07:57:08 <jchia__> solonarv: Thanks. Data.ByteString.copy is just what I'm looking for. I just assumed that since Haskell is pure, they wouldn't provide such a function that doesn't change the value of the ByteString.
07:57:26 <dmwit> justsomeguy: Little more than what I said here, though. ^_^
07:57:53 <justsomeguy> Much appreciated :)
07:58:19 <solonarv> jchia__: it is still useful because it can reduce memory usage
07:58:44 <solonarv> if you have some big bytestring (read from a file or whatever) and you slice out a small piece of it, that uses the same backing store
07:58:48 <jchia__> solonarv: Yes, despite the purity of Haskell, there are still always practical considerations for a real computer.
07:58:49 <solonarv> s/store/array/
07:59:30 <solonarv> and so that big array can't be garbage-collected as long as the small bytestring is still live, even if the big bytestring isn't needed anymore
07:59:54 <solonarv> with 'copy' you can instead make a copy which has its own (small) backing array, so the big one can be GCed
08:01:37 <jchia__> solonarv: Without the evaluate, the copy may get deferred and happen too late, right?
08:02:12 <jchia__> i mean because of laziness
08:02:30 <solonarv> correct
08:04:22 <solonarv> 'evaluate :: a -> IO a' evaluates its argument (to WHNF), which is useful for a small number of things:
08:04:59 <solonarv>  - making sure unsafePerformIO's happen at the right time (bytestring uses that under the hood), thereby making it safer
08:05:28 <solonarv>  - making sure work happens on the right thread, instead of being snuck onto the thread that ends up looking at the result
08:05:44 <solonarv>  - catching exceptions (e.g. 'error' calls, pattern match failures, and the like)
08:06:22 <maerwald> "catching"?
08:06:25 <maerwald> you mean forcing
08:07:02 <maerwald> hard to catch 'error' and pattern match failures
08:09:10 <solonarv> you can absolutely catch them, you just need 'evaluate' to turn them into IO exceptions
08:10:16 <solonarv> % evaluate (error "kaboom") `catch` \e -> putStrLn ("caught: " <> show e)
08:10:17 <yahb> solonarv: ; <interactive>:87:1: error:; * Ambiguous type variable `a0' arising from a use of `catch'; prevents the constraint `(Exception a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Exception NestedAtomically -- Defined in `Control.Exception.Base'; instance Exception NoMethodError -- D
08:10:27 <solonarv> % evaluate (error "kaboom") `catch` \(e :: SomeException) -> putStrLn ("caught: " <> show e)
08:10:27 <yahb> solonarv: caught: kaboom; CallStack (from HasCallStack):; error, called at <interactive>:88:11 in interactive:Ghci31
08:10:34 <maerwald> solonarv: those are not IO exceptions
08:11:01 <maerwald> catching all exceptions is discouraged afair
08:11:04 <solonarv> okay, wrong term. "exceptions that can be caught using Control.Exception.catch" is what I meant
08:11:21 <solonarv> yes, I just couldn't be bothered to look up the correct exception type
08:11:21 <maerwald> You may also catch async exceptions, runtime exceptions and other stuff
08:11:37 <lyxia> aveltras: does $(makeBoomerangs 'Dashboard) do what you want? Otherwise you probably should file a feature request to the library
08:11:43 <solonarv> I think it's UserError or something, so that is what I should have done in actual code
08:11:54 <solonarv> but I was just demonstrating that you can catch 'error' calls this way
08:13:00 <jophish> Hi all
08:13:08 <maerwald> solonarv: ah https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#t:ErrorCall
08:13:33 <solonarv> see, I would've had to look it up! too much effort for a quick demo! :P
08:13:43 * hackage ghc-lib-parser-ex 0.20200401 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200401 (shayne_fletcher)
08:14:03 <maerwald> I would still not want to catch it... you never know what error type you get and if it's recoverable
08:14:22 <maerwald> 'error' feels like something unrecoverable to me
08:14:23 <aveltras> lyxia: this gives me an error too
08:14:26 <aveltras> https://www.irccloud.com/pastebin/vInuVyU8/
08:15:07 <solonarv> if you want to (for example) show a nice pop-up window to the user displaying the error message, you have to catch the error
08:15:15 <solonarv> same if you want to log it, or whatever
08:15:45 <solonarv> also sometimes libraries are bad and you need to tape over them, I guess
08:16:25 <bennofs> when running cabal v2-build, can I give extra ghc options that are only applied for my own package?
08:16:37 <bennofs> I would like to supply -Werror, but this should not be applied to dependencies
08:16:43 <maerwald> bennofs: better use cabal.project.local for that
08:17:06 <maerwald> package mypackage\n\tghc-options: -Werror
08:17:07 <maerwald> I think
08:17:29 <bennofs> ah. no command line option for that though?
08:17:43 <maerwald> you can pass ghc-options at cli, but afaik it applies to everything
08:18:19 <lyxia> aveltras: I think that means you're out of luck and someone needs to patch boomerang to use th-abstraction
08:19:52 <aveltras> lyxia: yeah i see, is there a way to have ghc not complain about non injectiveness with a typeclass like the following ? i had to add the "mod" parameters to all functions to remove the errors, i know this can be removed using functional dependencies but im wondering about type families
08:19:56 <aveltras> https://www.irccloud.com/pastebin/TyOleNuU/
08:22:27 <lortabac> aveltras: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
08:27:51 <aveltras> lortabac: thanks, seems to work, i need to carry some type informations to make it compile but it should be ok
08:36:48 <hseg> hi. how do i get ghci to dump the roles of a type constructor?
08:37:33 <solonarv> IIRC they're printed whenever they're not all representational, or something
08:37:55 <solonarv> let me see if there is a flag to make them always display
08:38:22 <hseg> hrm. then the fact that :kind! Data.Vector.Sized.Vector returns Vector :: ghc-prim-0.5.3:GHC.Types.Nat -> * -> *
08:38:33 <hseg> would imply that all parameters are representational?
08:38:34 <dmwit> hseg: :i
08:38:36 <dmwit> not :k
08:38:42 <hseg> and that hence i could coerce all params?
08:39:08 <hseg> ok, still no better:
08:39:09 <solonarv> well, m :: Nat and n :: Nat are only Coercible when they're actually the same
08:39:10 <hseg> type Vector =
08:39:12 <hseg>   Data.Vector.Generic.Sized.Internal.Vector
08:39:13 <solonarv> so that sounds right to me
08:39:14 <hseg>     vector-0.12.1.2:Data.Vector.Vector
08:39:16 <hseg>   :: ghc-prim-0.5.3:GHC.Types.Nat -> * -> *
08:39:18 <hseg>    -- Defined in ‘Data.Vector.Sized’
08:39:36 <dmwit> hseg: Then you need to chase the type alias.
08:39:37 <hseg> ok, then why does ghc complain when i try to call coerce @(Vector 4 Int) @(Vector 4 (Sum Int))
08:40:30 <hseg> i note that replacing Vector 4 by [] works here
08:40:39 <bennofs> does cabal new-build support building a source archive directly?
08:40:43 <hseg> so this is def a Coercible problem
08:40:53 <Wauchope> quick question, when using putStr and \t to separate elements, how many characters apart would each element be?
08:40:53 <bennofs> (I have a source dist, and want to check if it can be built)
08:40:54 <hvr> bennofs: yes
08:40:58 <bennofs> how?
08:40:59 <phadej> bennofs: will in 3.4
08:41:10 <hvr> bennofs: packages: ./my-cool-pkg-1.2.3.tar.gz
08:41:10 <solonarv> Wauchope: depends on the terminal
08:41:14 <phadej> or depends what you mean, yeah
08:41:26 <Wauchope> I'm using ghci
08:41:34 <dmwit> Wauchope: Most terminals will advance to the next column that is a multiple of 8 when they see a \t.
08:41:43 <dmwit> But this default can be changed.
08:41:44 <hvr> bennofs: in your cabal.project file -- but you need to also depend on it; another approach is the new file+noindex:// repo style
08:42:09 <hseg> hvr: what's this file+noindex:// thing? 
08:42:32 <solonarv> Wauchope: ghci is not a terminal, is it xterm? gnome-terminal? whatever windows has?
08:42:47 <hvr> hseg: basically https://github.com/haskell/cabal/issues/6359 -- implemented by phadej
08:42:49 <solonarv> (and I'm sure most terminals let you change that setting, too)
08:43:25 <hseg> oh, nice
08:43:40 <hvr> hseg: available since cabal 3.2 -- see also https://cabal.readthedocs.io/en/latest/installing-packages.html#local-no-index-repositories
08:44:52 <hseg> returning to my main question, coerce @(t Int) @(t (Sum Int)) succeeds for t ~ [] but fails for t ~ vector-sized:Data.Vector.Sized.Vector 4
08:44:58 <hseg> so i'm suspecting role
08:45:01 <hseg> problems
08:45:12 <hseg> but i can't get ghci to spit that out
08:46:08 <Wauchope> I'm using windows powershell to show the output, my bad
08:46:33 <maerwald> hvr: when you push pre-built cabal binaries?
08:46:57 <Wauchope> The reason I'm asking is that I'm trying to format a string into 8 columns, with the first column being a name and then the remaining columns containing integers.
08:47:12 <lyxia> hseg: Vector's last argument has a nominal role
08:47:15 <Wauchope> But as the name can vary in length, \t formatting isn't playing so nice
08:47:51 <dmwit> If each row is the same height, you might like
08:47:52 <dmwit> ?hackage boxes
08:47:52 <lambdabot> http://hackage.haskell.org/package/boxes
08:48:03 <dmwit> Wauchope: ^
08:48:10 <hseg> lyxia: i supposed that was the case (packing issues?) but how do i get ghci to tell me that?
08:48:34 <hseg> or how would i find that out besides trying to vary the type at which i apply that last argument
08:48:48 <Phyx-> Wauchope: powershell's default tabstop is 8 spaces
08:48:48 <lyxia> hseg: :i Vector    tells me it's a type synonym and a couple lines below the roles of the type it's a synonym for
08:49:28 <lyxia> hseg: I see this https://dpaste.org/qpLF
08:49:42 <hseg> ah, i needed to import Data.Vector.Generic.Sized.Internal as well
08:49:43 <Wauchope> I'm doing this for a coursework assignment, and no where in the brief it mentions that I am allowed to use a 3rd party package. Is there an easy way to do this natively?
08:49:52 <Wauchope> native may not be the right word there
08:51:23 <hseg> lyxia: i'm seeing http://ix.io/2gff
08:51:33 <dmwit> You can just do the calculation that the boxes package does yourself.
08:51:36 <dmwit> It's not a hard calculation.
08:51:38 <lyxia> hseg: Oh yeah that helps. But people also suggested to follow the aliases before.
08:51:59 <dmwit> Figure out how wide each column must be by taking the size of the biggest row. Then pad the others out to that size.
08:52:27 <hseg> right. that's what i was missing - importing Data.Vector.Generic.Sized.Internal brings Data.Vector.Generic.Sized.Internal.Vector's role info in scope
08:52:36 <hseg> and so ghci can display it
08:52:52 <hseg> it's surprising it doesn't automatically pull that info in though
08:53:21 <hseg> and that one can't query the roles of a type synonym, but rather needs to expand it
08:53:39 <Wauchope> Gotcha, was just wondering if there was a module which comes with the standard install I could import which'll do it for me, thanks!
09:17:43 * hackage cabal2spec 2.6 - Convert Cabal files into rpm spec files  https://hackage.haskell.org/package/cabal2spec-2.6 (PeterSimons)
09:28:43 * hackage microbase 4.14.0.0 - A minimal base to work around GHC bugs.  https://hackage.haskell.org/package/microbase-4.14.0.0 (dailectic)
09:46:13 * hackage skylighting-core 0.8.3.4 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.3.4 (JohnMacFarlane)
09:47:13 * hackage skylighting 0.8.3.4 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.3.4 (JohnMacFarlane)
10:03:13 * hackage microbase 4.14.0.0.1 - A minimal base to work around GHC bugs.  https://hackage.haskell.org/package/microbase-4.14.0.0.1 (dailectic)
10:11:16 <Wauchope> So another beginner question
10:11:30 <Wauchope> I'm trying to get items from a list which meet a certain criteria
10:12:37 <Wauchope> From googling, I can only find solutions which return the first item to meet this criteria which isn't what I want
10:15:07 <hseg> lambdabot: :t filter
10:15:23 <hseg> :t filter
10:15:25 <lambdabot> (a -> Bool) -> [a] -> [a]
10:15:33 <hseg> :haddock filter
10:16:02 <hseg> wOw
10:24:34 <Wauchope> Got disconnected there, was there a response to my question?
10:25:00 <monochrom> Yes, look for the function named "filter"
10:29:07 <Wauchope> Great, that's exactly what I need. Not quite sure how to apply it to my code though.
10:30:43 * hackage enum-text 0.5.2.1 - A text rendering and parsing toolkit for enumerated types  https://hackage.haskell.org/package/enum-text-0.5.2.1 (ChrisDornan)
10:31:10 <Wauchope> https://gist.github.com/Wauchope/00c30280bc76b01a79af662e715005f4
10:32:36 <whataday> Could not load module ‘Network.HTTP.Client.TLS’It is a member of the hidden package ‘http-client-tls-0.3.5.3’.You can run ‘:set -package http-client-tls’ to expose it.
10:32:47 <whataday> how to expose this hidden package?
10:33:07 <whataday> I know we can run ghc -package http-client-tls a.hs
10:33:21 <whataday> is there a way to expose it?
10:33:50 <Wauchope> So, following that gist (should have everything needed to understand what I'm doing), I'm trying to get a list of "places" which have a rainfall of 0 on day x-1... I'm not quite sure how I'm supposed to structure the first argument of filter to do this
10:34:14 <whataday> I installed it with cabal-v1 then cabal-v2, so it became a hidden package
10:35:19 <solonarv> whataday: if you are using cabal v2 (which you should be!), then the pattern is not "install library then invoke ghc/ghci"
10:35:44 <solonarv> instead it is: invoke ghc via cabal, telling it what packages should be available
10:36:19 <maerwald> whataday: cabal repl --build-depends http-client-tls
10:36:28 <solonarv> (also note that cabal 3.0 is released and you should update to it if you haven't; then you don't need the v2-* / new-* prefix anymore)
10:36:45 <solonarv> or for short: cabal repl -b packagename,anotherpackage
10:38:59 <monochrom> Wauchope: You should be giving getRainfall some parameter, no?  Currently you aren't.
10:40:10 <whataday> ghc: unrecognised flag: --build-depends
10:40:24 <whataday> ghc: unrecognised flag: -b
10:40:41 <solonarv> uh, what command did you run?
10:40:54 <solonarv> did you run 'ghc --build-depends ...' ?
10:41:05 <whataday> ghc v2-repl --build-depends http-client-tls, haha
10:41:12 <maerwald> O.o
10:41:14 <monochrom> WHY
10:41:24 <monochrom> Why do people behave like illterate?
10:42:06 <Wauchope> I've edited the code a little bit to supply that parameter
10:42:10 <whataday> cabal v2-repl --build-depends http-client-tls
10:42:12 <monochrom> This is why my course policy includes a clause "you're expected to have university-level reading comprehension"
10:42:26 <whataday> I have done this , but ghc a.hs still show that message, the package is hidden
10:42:39 <whataday> how use cabal to remove a package?
10:42:40 <Wauchope> When trying to execute it, however, I'm getting [] returned no matter what values I parse through
10:42:47 <whataday> or re-install it
10:43:05 <solonarv> whataday: as I said above, "install a library then call ghc" is not the expected workflow
10:43:21 <Wauchope> checkDayIsDry returns True or False correctly when executed on it's own so I'm not sure quite what I'm doing wrong with the filter
10:43:38 <whataday> what's the right way?
10:44:27 <Wauchope> Nevermind, I'm being stupid. Need to take a break lol
10:45:28 <monochrom> Yeah I have trouble believing that checkDayIsDry is bugfree because you should need parentheses like (x-1)
10:45:55 <solonarv> if you just want to open GHCI, then as said above use cabal repl -b package,otherpackage
10:46:30 <solonarv> if you want to compile then run a source file, you can put a special comment at the top (listing the package it depends on) and then use 'cabal run myfile.hs'
10:46:40 <solonarv> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-run
10:47:17 <maerwald> monochrom: xD
10:47:49 <maerwald> monochrom: tbf... I think programmers, with time especially, have this habit of not reading linearly
10:48:01 <maerwald> Because reading code is usually jumping randomly between lines
10:49:00 <monochrom> But when reading replies from other people, out of basic respect one should be reading completely, no?
10:49:17 <monochrom> Also you can be jumpy and still be complete.
10:51:13 <Wauchope> Is it bad form to be calling a method using the result(s) of another method like so: getDryPlaceNamesOnDay x y = getNames ( getDryPlacesOnDay x y)
10:51:13 <maerwald> Yeah, wouldn't be surprised if half of haskellers read from right to left xD
10:51:27 <Wauchope> I keep seeing method1 . method2 notation and I'm not too sure on how that works
10:51:27 <monochrom> It is good form, Wauchope.
10:52:07 <Wauchope> So am I correct to assume I can't rewrite the above code snippet using the notation I just mentioned?
10:52:40 <monochrom> Any code that is easy to comprehend is good form.  Focus on how well other people can understand your code, not robotic "rules of thumb".
10:53:10 <maerwald> yeah, and that means adapting to your colleagues, in fact
10:53:28 <monochrom> Implicitly I also assume you understand what you wrote, too.
10:53:41 <monochrom> You have to understand it, and other people have to understand it.
10:53:50 <maerwald> I used to like (fmap . fmap . fmap), but it confused other people
10:54:18 <monochrom> That is not the ultimate.  The ultimate is replacing (.) by fmap, too.
10:54:25 <maerwald> loool
10:55:10 <Wauchope> I try to structure my code in a way that I can look at it 6 months later and understand it, though I'm using haskell with OOP experience. Not too sure if nested functions (if you could call it that) are easy to read for someone with experience with haskell
10:55:10 <monochrom> FIFY: fmap fmap (fmap fmap fmap)
10:55:31 <monochrom> Supereasy.
10:56:14 <monochrom> In OOP I don't shy away from o1.m1(o2.m2(o3.m3())).m4(o4) either.
10:56:56 <dsal> Sometimes when I'm tired and not thinking too hard, I start adding fmap and fmap.fmap and fmap fmap just to see what happens.
10:57:00 <monochrom> If it's still short enough to fit on a 70-character line I keep it on a line.
10:57:01 <glguy> monochrom: You should pick better names than m1, m2, or m3 though :-S
10:57:13 <monochrom> Yes
10:57:36 <maerwald> wait, but identifier in Java usuallly are 70chars anyway :P
10:57:58 <monochrom> If it's longer but only because I use longer names, sure break it multiple lines, but still like:
10:58:27 <monochrom> same code but more line breaks and indentation.
10:59:00 <monochrom> Not going to comply to "you need to invent a tmp var for o3.m3()"
10:59:16 <Wauchope> Okay cool, I'll carry on trying to follow the SOLID principles as well as I can then
10:59:32 <Wauchope> Though some of it will definitely be abstracted out as objects and classes dont quite exist
11:00:09 <monochrom> On a case-by-case basis I judge whether it's a good idea to give a name to o3.m3() or it's red tape.
11:00:45 <monochrom> I know that some people insist on "one concept per line" because they have bird brains.
11:00:54 <maerwald> Lol
11:01:53 <monochrom> The whole point Backus gave us Fortran is to relieve us from "tmp1 := x+y; answer := z*tmp" so we can write "answer := z*(x+y)" and cut the red tape.  Only bird brains can't deal with it.
11:02:21 <maerwald> But listen to their sweet songs
11:03:32 <petrus> Could somebody familiar with wreq help me? Is it possible to get the responseBody as a strict ByteString instead of a Lazy one?
11:04:13 * hackage reflex 0.7.0.0 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.7.0.0 (3noch)
11:04:47 <maerwald> petrus: check Data.ByteString.Lazy
11:07:18 <petrus> maerwald: I hoped to spare the explicit conversion.
11:07:41 <maerwald> Why?
11:07:59 <petrus> why not?
11:08:01 <monochrom> implicit conversions are evil.
11:08:21 <maerwald> Dunno. Why would someone provide two APIs for something you can do yourself
11:09:22 <petrus> maerwald: many do
11:09:36 <monochrom> Also you're opening yourself to DoS attacks.
11:09:55 <ChaiTRex> maerwald: Because converting is expensive according to https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Lazy.html#v:toStrict
11:10:26 <monochrom> so don't convert at all
11:10:27 <maerwald> ChaiTRex: I don't see how that would be any different from the API returning strict bytestring
11:11:30 <maerwald> It is probably lazy IO, so the bytestring doesn't exist in memory yet. It's basically streaming
11:11:57 <monochrom> response body is offered as a lazy stream because that's your best chance of writing a O(1)-space algorithm.
11:12:07 <ChaiTRex> maerwald: Sometimes the server will send the length and the strict ByteString can then be fully allocated and streamed in. This would eliminate the need for an intermediate lazy ByteString.
11:12:52 <ChaiTRex> maerwald: Though I do agree with monochrom about the space and DoS concerns.
11:14:36 <monochrom> if a non-lazy API is also desirable for some other use cases (I agree they exist), someone will have to PR it.
11:14:46 <maerwald> ChaiTRex: ah yes, with e.g. streamly you can use a lazy ByteString and write it via chunks to a strict bytestring
11:17:02 <maerwald> So a better API would be to expose an actual streaming API, which you can then turn into lazy ByteString or not
11:17:11 <maerwald> The problem is: there are too many streaming libraries
11:17:14 <dsal> I probably don't understand how to use it correctly, but this used all the memory:   liftIO (BL.writeFile dest <$> view W.responseBody =<< W.get u)
11:17:28 <dsal> I ended up using conduit for that use case.
11:17:43 <nshepperd2> the cost of an intermediate lazy bytestring doesn't seem very high
11:18:31 <maerwald> nshepperd2: from what I read... it forces the entire lazy bytestring then copies, then releases, so you have 2*size?
11:22:51 <whataday> solonarv I found I can change .cabal , apped the package into build-depends, then cabal v2-build, now I can run ghc a.hs without erors
11:24:14 <Wauchope> In haskell variables are immutable... One of my tasks are to update a list of integers with a new value, where the new value takes the first index in the list and each other item shifts down 1 (with the exception of hte last which gets deleted).
11:24:37 <monochrom> "update" now means "produce a new thing"
11:25:02 <Wauchope> So I'd have to recreate the variable as a whole?
11:25:08 <monochrom> list
11:25:49 <maerwald> Do we have variables? In the language spec?
11:26:09 <monochrom> Yes, but only to the extent we say "variables".
11:26:16 <Wauchope> type Place = (String, (Float, Float), [Int]) -- with the Places being stored in a variable of type [Place]
11:26:26 <Wauchope> So its possible to modify only the [Int] part of each Place?
11:26:41 <monochrom> "3.2 Variables, Constructors, Operators, and Literals" in the TOC :)
11:26:50 <monochrom> totally means constant.
11:26:53 <maerwald> Oh
11:27:04 <maerwald> I'd argue IORef is a "variable" :P
11:27:08 <whataday> IORef
11:28:01 <dsal> Wauchope: You'll need a new outer tuple.  The inner tuple can stay the same.  The list will be rewritten.  Don't be afraid of this.  It's glorious.
11:28:08 <glguy> maerwald: Yeah: Section 3.2 Variables, Constructors, Operators, and Literals
11:28:14 <monochrom> Alternatively, the logicians chose the word "variable" long before programming existed.  And haskell is going with logicians on this.  Alonzo Church said "variable".  Lambda calculus's "variable", not Algol's.
11:28:54 <dsal> Values aren't generally able to vary.
11:29:21 <monochrom> My stance is that programmers should say "mutable cell" and respect logicians' sense of "variable".
11:29:35 <Ariakenom> variables in math dont mutate. in some programming they do
11:29:35 <maerwald> dsal: the "variability" is the domain of the type, you could argue
11:30:00 <Wauchope> See I've always seen it as a variable is named as such because its value can change (or vary), while a constant is exactly that... Constant
11:30:03 <Ariakenom> really programming should have made
11:30:05 <Ariakenom> up another
11:30:07 <Ariakenom> name
11:30:11 <Wauchope> ("London", (51.5, -0.1), [0, 0, 5, 8, 8, 0, 0])
11:30:16 <maerwald> Why? Now we can bikeshed about it :D
11:30:33 <dsal> Wauchope: Yeah, we don't(*) modify things in place.  This makes many things make much more sense.
11:30:47 <Wauchope> So I want to update the [Int] with the value 3, effectively making it [3, 0, 0, 5, 8, 8, 0]
11:31:08 <monochrom> My more realistic stance is that physicists muddled the whole pool so all is lost.
11:31:26 <ChaiTRex> Wauchope: f (_:xs) = 3:xs
11:31:48 <ChaiTRex> Wauchope: Oh, you're moving the other elements.
11:31:51 <dsal> > let (s, p, l) = ("London", (51.5, -0.1), [0, 0, 5, 8, 8, 0, 0]) in    (s, p, 3:l) -- Wauchope 
11:31:54 <lambdabot>  ("London",(51.5,-0.1),[3,0,0,5,8,8,0,0])
11:32:24 <dsal> > let (s, p, l) = ("London", (51.5, -0.1), [0, 0, 5, 8, 8, 0, 0]) in    (s, p, 3:take 6 l)
11:32:26 <lambdabot>  ("London",(51.5,-0.1),[3,0,0,5,8,8,0])
11:32:27 <ChaiTRex> Wauchope: f xs = 3:take 7 xs
11:32:46 <ChaiTRex> Ahh, dsal got it correctly.
11:33:17 <ChaiTRex> Wauchope: You may want to use a Seq instead of a list if you're going to be taking things off the right end.
11:33:52 <monochrom> This is probably a beginner course so we'll have to stay with lists and accept inefficiency.
11:34:04 <monochrom> Get the concepts right first.
11:34:54 <monochrom> Such as there is no such thing as "modify 5 to 6", there is only a 5, and a 6, in co-existence.
11:35:27 <dsal> Can't we all just get a long?
11:35:44 <monochrom> 5 satisfies the equation "5*2=10". If you really modify 5 to 6, you're saying you're modifying my equation to "6*2=10". You can't be serious.
11:35:47 <ChaiTRex> > let f x (s, p, l) = (s, p, x:init l)
11:35:50 <lambdabot>  <no location info>: error:
11:35:50 <lambdabot>      not an expression: ‘let f x (s, p, l) = (s, p, x:init l)’
11:35:59 <Wauchope> dsal: I'm not quite following what that line of code does
11:36:04 <dsal> Wauchope: which part?
11:36:20 <ChaiTRex> > let f x (s, p, l) = (s, p, x:init l) in f 3 ("London", (51.5, -0.1), [0, 0, 5, 8, 8, 0, 0])
11:36:22 <lambdabot>  ("London",(51.5,-0.1),[3,0,0,5,8,8,0])
11:36:42 <dsal> I always forget about init
11:37:13 <Wauchope> Mainly what each keyword exactly means - the source I'm using for keywords isn't the clearest at times
11:37:38 <Wauchope> For example, let is defined as "a nested, lexically-scoped, mutually-recursive list of declarations (let is often called letrec in other languages). The scope of the declarations is the expression and the right hand side of the declarations."
11:37:45 <monochrom> Actually they are function names from the standard library, not keywords.
11:37:55 <ChaiTRex> Wauchope: let means we're going to define some variables. in means we're going to now use those variables we defined.
11:37:56 <dsal> 'let' just names some things.  I'm naming s, p, and l as the parts of your outer tuple.
11:38:01 <monochrom> There are too many standard library functions to fit on a cheat sheet.
11:38:54 <Wauchope> 3:take 6 l -> Join 3 with 6 elements from l
11:38:57 <Wauchope> Am I correct there?
11:39:04 <monochrom> yes
11:39:08 <monochrom> but which 6?
11:39:29 <Wauchope> The first 6?
11:39:33 <monochrom> yes
11:39:46 <dsal> > 3:[4,5] -- Wauchope You can try little bits in ghci to see what each thing is doing.
11:39:49 <lambdabot>  [3,4,5]
11:39:52 <Nolrai> Is the standard sort resonably performant on lists?
11:39:58 <monochrom> yes
11:39:59 <ChaiTRex> Wauchope: Right. You can also use `init` in place of `take 6`. `init` gives you the whole list except the last element left out.
11:40:02 <ChaiTRex> Nolrai: It is.
11:40:29 <monochrom> a decade ago something went out of their ways to optimize and benchmark
11:40:33 <dsal> I'm mildly curious what sort actually does.  But most of the time I don't care.
11:40:42 <monochrom> err, s/something/someone/
11:40:48 <Nolrai> I think its a quicksort?
11:40:55 <ChaiTRex> It's a nice merge sort.
11:40:59 <Nolrai> Ah.
11:41:00 <dsal> But you can't quicksort a list.
11:41:03 <[exa]> Hm, is there any algebraic structure (like group/ring/whatever) that would nicely describe the states of a deterministic finite state machine?
11:41:21 <Nolrai> Yeah as soon as I said it I, I was like wait thats not right.
11:41:32 <monochrom> Look a look at its source code.  You will be surprised how it is not exactly any of the textbook algorithms.
11:42:00 <ChaiTRex> [exa]: Not really. The operation would be on an input symbol and a state, not two of the same type.
11:42:10 <Nolrai> exa: A logic?
11:42:26 <Wauchope> So I can use let as a way to reference elements by name... init to return all elements except the last (or :take 6 but that'll only work in my case as long as length [Int] = 7)
11:42:36 <Wauchope> What does in do? Is this a keyword or another method?
11:42:51 <ChaiTRex> Wauchope: in means 'now we're going to use those variables we just created'
11:42:55 <dignissimus> Do you think I can install haskell with ~1Gb of storage?
11:42:56 <[exa]> ChaiTRex: well that can be solved, e.g. vector spaces have algebraically "infinite number of scalar multiply operators"
11:43:07 <[exa]> ChaiTRex: but certainly it's an ugly way :]
11:43:16 <monochrom> [exa]: Monoid action on states.
11:43:17 <solonarv> whataday: oh yes, if you 'cabal build' within a project then cabal writes a file with name like .ghc.environment.x86_64-linux-8.6.5 which is a list of available packages that ghc picks up
11:43:32 <Nolrai> Monochrom has it right.
11:43:38 <[exa]> ah, actions
11:43:48 <solonarv> Nolrai: dsal: it is an extra fancy mergesort that exploits already-sorted runs in the input
11:43:52 <monochrom> like group action but strings don't have inverse of concatenation.
11:44:08 <solonarv> I think it's like timsort except it doesn't fall back on insertion sort for small inputs (because that doesn't make any sense for linked lists)
11:44:33 <glguy> solonarv / whataday: If you're using a recent cabal-install you might have to enable that behavior: --write-ghc-environment-files=always|never|ghc8.4.4+ 
11:45:03 <ChaiTRex> Wauchope: It's a keyword. The structure is `let ... in ...` (except in `do` blocks).
11:45:29 <[exa]> monochrom: that's extremely good, thanks a lot
11:45:49 <Nolrai> If I really just want to get the nth top items in the list without caring about the internal order is there a different algorithem I should be using?
11:46:26 <monochrom> I think I don't know of one.
11:46:32 <Wauchope> let (name, pos, rainfall) = x in (name, pos, y:init rainfall) -- where x is a place (String, (Float, Float), [Int]) and y is the value to update with would work?
11:46:43 <ph88> if i want to check if i have GHC version lower than 7.10 is this pragma correct ??    #if  __GLASGOW_HASKELL__ < 710
11:46:53 <monochrom> I have a feeling some theorem says "no better than asking for the top n items sorted"
11:47:07 <ChaiTRex> Wauchope: It should. Try it out.
11:47:10 <[exa]> Nolrai: there's even a proof that it cannot be done with a better complexity than with the usual "scanning heap"
11:47:23 <[exa]> similar to proofs of minimal sort complexity
11:47:27 <monochrom> So I would use (take n (sort that)) until it's proven too slow.
11:47:30 <Wauchope> updatePlace x y  let (name, pos, rainfall) = x in (name, pos, y:init rainfall)
11:47:36 <Nolrai> Yeah, but wont merge sort have to sort even parts of the list I wont see at all?
11:47:36 <solonarv> Nolrai: take n . sort should be alright I think
11:47:41 <Wauchope> How would I then go about using that in a function?
11:47:49 <opqdonut> for k smallest elements out of n O(n log k) is optimal
11:48:09 <solonarv> I do recall that head . sort is O(n), at least
11:48:12 <opqdonut> one solution is to have a minheap of size k and add elements to it one by one, just like [exa] said
11:48:16 <ChaiTRex> Wauchope: For that, you want `updatePlace y (name, pos, rainfall) = (name, pos, y:init rainfall)`
11:48:47 <ChaiTRex> Wauchope: It's a little bit shorter. The inputs to a function can be disassembled just like in a `let`, so you don't need the `let`.
11:49:02 <monochrom> I don't have a proof but it's folklore that our sort contains a small amount of laziness such that take n . sort is asymptotically OK.
11:49:13 <dsal> > let updatePlace y (name, pos, rainfall) = (name, pos, y:init rainfall)  in   updatePlace 3 ("London", (51.5, -0.1), [0, 0, 5, 8, 8, 0, 0])
11:49:15 <lambdabot>  ("London",(51.5,-0.1),[3,0,0,5,8,8,0])
11:49:24 <Nolrai> Huh, so a priority que isn't asomtoicly worse then a minheap?
11:49:26 <Wauchope> Is there a reason the statement is surrounded by single quotation marks
11:49:39 <dsal> In my irc client, it prints nicer.  :)
11:49:40 <ChaiTRex> Wauchope: Just to make it easier to read on IRC.
11:49:42 <seveg> join #postgresql
11:49:54 <ChaiTRex> Wauchope: You know what's Haskell and what's English.
11:50:00 <[exa]> Nolrai: unless the priorities are discrete and finite (and allow bucketing), no
11:50:25 <monochrom> People use minheaps and maxheaps for priority queues, no?
11:50:47 <Nolrai> Yeah, calculating these values will probably take so much longer then sorting them that I shouldn't worry about it.
11:50:57 <Nolrai> I could probably use bubble sort and be fine.
11:51:09 <Nolrai> I am probably just procrastinating.
11:51:14 <monochrom> haha
11:51:24 <monochrom> but bubble sort is error-prone to code up
11:51:45 <ChaiTRex> Merge sort or quicksort are easier to get right.
11:51:58 <Nolrai> Oh yeah, on lists its kind of hard.
11:52:05 <Nolrai> On arrays its pretty easy.
11:52:06 <[exa]> ChaiTRex: 'easier' in very specific programming language setting :D
11:52:39 <Wauchope> Okay thats cool, I didnt realise I could "deconstruct" a declared type using more convenient names in a function
11:53:05 <Nolrai> Wauchope: Its super useful!
11:53:35 <ChaiTRex> Wauchope: You can also do that for your own types. Like if you have `data Whatever = Whatsit Int`, you can get the `Int` out with `f (Whatsit x) = x`.
11:54:06 <ChaiTRex> Wauchope: Or, of course, do whatever you want with the `x` rather than just returning it.
11:54:15 <Wauchope> Suppose I could've inferred it from these lines I used earlier though 'getName :: Place -> StringgetName (x, _, _) = x'
11:54:22 <Wauchope> oh that didnt work lmfao
11:54:32 <solonarv> eh, close enough
11:55:24 <Nolrai> Yeah irc eats line returns or something.
11:56:24 <ph88> nom nom nom
11:56:28 <[exa]> multiline pasting on IRC is widely frowned upon btw
11:56:49 <Nolrai> Yeah, but like 2 lines?
11:57:15 <Wauchope> Figured it was easier than creating a gist for it - will make sure I avoid it in the future, thanks!
11:57:35 <monochrom> 2 lines are OK but make sure you do it right.
11:57:43 * hackage Rasterific 0.7.5.2 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7.5.2 (VincentBerthoux)
11:57:54 <monochrom> There also autobots around kicking you for too many lines.
11:58:03 <[exa]> Nolrai: borderline :]
11:58:08 <ph88> What is this syntax with strings in import ??  https://github.com/joneshf/purty/blob/master/lib/Purty.hs#L11 
11:58:58 <solonarv> ph88: PackageImports
11:59:00 <Wauchope> So all of my "place"s are stored within a variable (man, you made me not want to use the word lol) named testData. Am I right to assume that when I call updatePlace, I want to recreate the entire [Place]?
11:59:08 <solonarv> it allows you to say which package the module should be imported from
11:59:14 <Wauchope> To store that information for use later on
11:59:37 <Nolrai> What module is (>>>) in?
11:59:40 <ChaiTRex> Wauchope: What is the type of `updatePlace`?
11:59:41 <solonarv> this is *necessary* if you have name collisions, and could be argued to be a good idea for the sake of being explicit (but it's not used much)
11:59:47 <solonarv> Nolrai: Control.Arrow
12:00:03 <Wauchope> Place -> Int -> Place
12:00:04 <monochrom> Control.Category too
12:00:24 <ChaiTRex> Wauchope: OK, and you want to update just one place or the whole list of places?
12:00:40 <Wauchope> On each call of updatePlace I only want to update one place
12:01:23 <Wauchope> I'll have a separate function which takes a list of integers with the same lenght as the [Place] and uses that to call updatePlace on each Place using the respective Int
12:02:04 <ChaiTRex> Wauchope: For that, you want updatePlace to be type Int -> Place -> Place (put the big thing you're changing at the end of the argument list usually).
12:02:34 <ChaiTRex> Wauchope: Then you can use `zipWith updatePlace theInts thePlaces`.
12:04:03 <Wauchope> So zipWith has the following syntax... 'zipWith function listA listB'
12:04:19 <ChaiTRex> Wauchope: `zipWith` takes two lists, `theInts` and `thePlaces`, and takes one from each list. Then it runs `updatePlace` with the element from `theInts` and the element from `thePlaces`. It then loops through both lists like that, giving the results as a list. 
12:04:26 <ChaiTRex> Wauchope: You're right.
12:05:11 <Wauchope> Perfect
12:06:05 <Wauchope> I can then use the line testData = zipWith updatePlace theInts testData
12:06:06 <ChaiTRex> Wauchope: Keep in mind that when one list ends before another, it stops there. So, the result list will be as short as the shorter input list.
12:06:12 <Nolrai> Is there a operator like `(<$>)` is to `($)` for `(.)`?  
12:06:35 <ChaiTRex> Wauchope: You can.
12:06:46 <Uniaika> Nolrai: (>>=) ?
12:06:49 <Uniaika> :P
12:06:59 <Nolrai> Doh!
12:07:01 <Wauchope> I'll be adding a guard against that, probably something along hte lines of | length listA - length listB != 0 = error "error message here"
12:07:27 <Uniaika> Nolrai: try it out before saying "Doh!" :P
12:07:36 <Nolrai> Yeah, thats wrong.
12:07:45 <Uniaika> :D
12:07:48 <ChaiTRex> Wauchope: `length listA /= length listB` is shorter :)
12:08:01 <Uniaika> Nolrai: more seriously, what's the context?
12:08:30 <Nolrai> `splitIntoSpecies speciesRadius xs = snd <$> foldr insertIntoSpecies [] xs`
12:08:45 <monochrom> >>= or >=> depending on the real question
12:10:48 <solonarv> possibly also just (.) again
12:11:26 <Nolrai> No I need to map the snd.
12:11:47 <solonarv> oh I see, you want to point-free away the xs ?
12:11:52 <Nolrai> Yes.
12:12:02 <Nolrai> I think <=< is right?
12:12:08 <solonarv> I would just write that as 'fmap snd . foldr insertIntoSpecias []'
12:12:15 <solonarv> bah, typo
12:12:29 <Nolrai> np.
12:12:30 <dsal> Wauchope: We tend to not like partial functions.
12:13:57 <Wauchope> What do you mean?
12:14:33 <dsal> Wauchope: Your function should return a result for every input.
12:14:37 <dsal> "error" makes that not happen.
12:14:42 <ChaiTRex> Wauchope: Partial functions are functions that don't work for all inputs.
12:14:45 <dsal> Instead, for some inputs, you get surprises.
12:15:02 <Uniaika> like `head []`, Wauchope 
12:15:20 <ChaiTRex> Wauchope: The opposite is total functions that work for all inputs.
12:17:03 <Wauchope> Gotcha
12:17:47 <Wauchope> Thanks for the advice, I'll remember that. Luckily for me though the demo uses an [Int] of the same length as [Place] so I think I'm clear here
12:18:06 <dsal> You could also just consider it OK if they're different lengths
12:18:30 <dsal> I often use an infinitely long list when zipping things.  I don't expect both lists to be infinitely long.
12:18:34 <dsal> (though sometimes they are)
12:22:48 <Wauchope> So I'm a little unsure on how to use let .... do .... properly
12:22:54 <Wauchope> https://gist.github.com/Wauchope/00c30280bc76b01a79af662e715005f4 is my current code
12:22:58 <dsal> let and do are different things.
12:23:23 <dsal> I don't think you want do at al.
12:23:26 <solonarv> well, for starters 'let ... do ...' isn't valid
12:23:31 <solonarv> yeah, you don't need a do here
12:24:12 <Wauchope> What would be the best way to complete what I'm trying to do here then?
12:24:25 <dsal> Wauchope: If you don't add extra code to make your function partial, you could write this:     updatePlaces = zipWith updatePlaceWithRainfall
12:25:10 <dsal> Otherwise, get rid of the do.  I'm not sure what you're doing with 'testData = ' there.  You could put a let in front if it if you want, but then you'd have to do something with that binding.
12:25:41 <ChaiTRex> Wauchope: `otherwise = zipWith updatePlaceWithRainfall x y`
12:26:02 <ChaiTRex> Wauchope: Then it'll just return the result of the `zipWith`.
12:27:02 <dsal> In addition to being bad for being partial, note that length of a list is O(n), so you're doing two passes through the list before you even do the one you want.
12:27:25 <ChaiTRex> Wauchope: If you want a bunch of variables, just do `let whatever = blah` on one line, then `thingy = foo` aligned on the left with `whatever`, then `in  ...` aligned on the left with `let`.
12:27:32 <dsal> Not that I think performance is a concern, but if you really wanted to do this, you could build zipWithButLikeOnlyIfThey'reTheSameLength function.
12:28:03 <dsal> Then    updatePlaces = zipWithButLikeOnlyIfThey'reTheSameLength updatePlaceWithRainfall
12:28:53 <dsal> (And *that* could be total with Maybe or Either or similar)
12:31:40 <maerwald> hmm, consuming a lazy bytestring into a strict bytestring does indeed seem not too easy
12:32:18 <Wauchope> So I got rid of the guard to make it total. I'm not too sure how It's passing through the list twice, but fortunately the list of places is only (and will only ever be) 14 elements long.
12:32:34 <ChaiTRex> Wauchope: OK, I've added a comment on that Gist page.
12:33:51 <ChaiTRex> Wauchope: When you run `length`, it has to go through the entire list to figure out the length since it's a linked list.
12:34:20 <ChaiTRex> Wauchope: Then, later, you use `zipWith`, which also goes through the entire list again to get the elements of it to use in the function. So, together, you're going through the list twice.
12:34:35 <dsal> *each list twice
12:34:53 <dsal> Wauchope: Without the guard, your final answer can be:  `updatePlaces = zipWith updatePlaceWithRainfall`
12:36:28 <koz_> Are there any good pretty-printing libraries for tree-like things?
12:36:33 <Wauchope> Right, thanks for the clarification there. Wasn't aware that lists in haskell are represented using linked lists. 
12:36:55 <ChaiTRex> Wauchope: For array-backed lists, there's a Vector type.
12:37:16 <ChaiTRex> Wauchope: Those have O(1) length.
12:37:20 <Wauchope> I might be approaching this wrong, but say I execute updatePlaces listA listB
12:37:33 <Wauchope> Then I get the right result returned in the terminal
12:37:55 <Wauchope> If I then try to reference the variable made in let afterwards, its almost as if it disappears
12:38:26 <ChaiTRex> Wauchope: Where is the `let` located?
12:38:55 <Wauchope> I have a method which displays the contents of the [Place] list in a table, if I execute this on testData before and after updatePlaces the contents are the same
12:39:11 <Wauchope> Currently inside of updatePlaces
12:39:17 <solonarv> well, of course! you can't mutate variables
12:39:37 <dsal> Wauchope: If you have a thing, you will always have that thing.  You can make a new thing out of it, but they can't take your old thing away.
12:39:42 <ChaiTRex> Wauchope: `let`s only exist inside the thing they're defined in. So those variables only exist inside `updatePlaces`.
12:40:06 <ChaiTRex> Wauchope: You need to make a `let` inside the place you want to use it.
12:40:17 <dsal> (to store your new thing)
12:41:26 <dsal> If you had a thing, but you don't have it anymore (e.g., you left the scope where you had it) then it will be taken away and recycled for you.
12:42:16 <ChaiTRex> Wauchope: You have a variable to hold the old `[Place]`: `testData`. You need a variable to hold the updated `[Place]`, call it what you want.
12:43:05 <ChaiTRex> Wauchope: For example, on the top-level, you can do `newTestData = updatePlaces theInts testData`.
12:43:51 <ChaiTRex> Wauchope: Or in `main` function, you can have `let newTestData = updatePlaces theInts testData` on one line (no `in` because it's in a `do` block and the `in` part is implied to be the following lines).
12:44:36 <ChaiTRex> Wauchope: Then you can display both `testData` and `newTestData`.
12:46:38 <Wauchope> Right there we go, I'm back in
12:47:11 <Wauchope> So if I was to place inside the main function let testData = (DATAGOESHERE) in testData
12:47:28 <Wauchope> I'd then be able to reference that and modify it in later calls from within the main method?
12:50:54 <solonarv> no, you would still not be able to "modify" it
12:51:20 <ChaiTRex> Wauchope: You can modify it, but you can't store the modified data back in the same variable. Variables can only be set once.
12:51:34 <solonarv> however you would be able to define a new variable *also* called testData, which would shadow the previous definition
12:51:45 <solonarv> I wouldn't necessarily recommend doing this, though
12:53:36 <Wauchope> okay so the data is eventually going to be read from a file, some functions are going to be called, then when the exit program function is called this data is going to be stored back into the file
12:53:55 <Wauchope> What would be the best way of ensuring consistency during the 'some functions are going to be called' section?
12:54:40 <Wauchope> So I could, for example, call updatePlaces multiple times and it wouldnt just update the first value for testData each time
12:55:41 <ChaiTRex> Wauchope: If you call it on the same testData variable, it'll just modify the same starting data over and over.
12:56:01 <ChaiTRex> Wauchope: If you call it on the results of the previous modification each time, it'll make progress.
12:56:13 <Wauchope> If I can't store the modified data back in the same variable, how would I know which version of the "variable" is then the latest version if I'm not shadowing the previous variable with one of the same name
12:56:53 <dsal> You can't shadow bindings with the same name.
12:57:24 <ChaiTRex> Wauchope: You can make a loop. Then if you declare a variable inside the loop, you can have it have a different value each time.
12:57:43 <ChaiTRex> Wauchope: Also, perhaps the loop you want already exists as a stdlib function.
12:57:53 <dsal> :t foldr
12:57:55 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:57:58 <solonarv> dsal: oh right, not with a 'let'
12:58:26 <dsal> (list is Foldable)
12:58:46 <ChaiTRex> Wauchope: You can't set a variable twice in the same scope, but if that scope ends and then begins again, you can set it for the first time over and over again.
12:58:49 <dsal> solonarv: Oh, you can do that with <- in a do, can't you?  I've never considered it.
12:59:47 <ChaiTRex> Wauchope: It's much like function arguments. Inside the function, you can't set the variable to another value. It's already set when the function is called. But you can call it with different arguments and thus the variable is set to something else the next time it's called.
13:00:04 <dsal> > do { a <- Just 1; a <- Just 2; pure a }
13:00:07 <lambdabot>  Just 2
13:00:14 <dsal> huh.  Yeah, that makes perfect sense.
13:00:42 <ChaiTRex> Wauchope: So, what's the overall plan of what you're doing? You have the starting data hard-coded into your program and then you get rainfall reports from one file?
13:03:14 <koz_> Is there somewhere which has an Arbitrary instance for Data.List.NonEmpty.NonEmpty?
13:04:14 <dsal> I thought that was in base QC?
13:04:23 <koz_> dsal: They have a NonEmpty wrapper for lists.
13:04:34 <koz_> But not the actual datatype from base as far as I can tell.
13:04:56 <dsal> Oh, right.  I guess you could combine that easily enough.  Weird to be missing, though.
13:05:01 <lyxia> quickcheck-instances probably
13:05:06 <koz_> lyxia: Not that I can find.
13:05:59 <lyxia> https://hackage.haskell.org/package/quickcheck-instances-0.3.22/docs/Test-QuickCheck-Instances-Semigroup.html#v:-36-fArbitraryNonEmpty
13:06:18 <koz_> lyxia: Last place I thought it'd be - thanks!
13:08:42 <Wauchope> I'll put a pastebin up of the actual tasks, give me a moment I just made a coffee
13:08:56 <ChaiTRex> Wauchope: OK
13:10:33 <Wauchope> https://pastebin.com/FyD1Ha17
13:11:00 <Wauchope> I've been trying to avoid putting the actual brief up, so I can take advice and then try to implement it to suit the brief itself
13:11:06 <Wauchope> But I may just be overcomplicating things at this point
13:12:26 <dsal> "textual menu-based user interface" yikes
13:12:42 <Wauchope> The main confusion for me right  now is coming from understanding how I'll be storing the latest version of the data after some of the functions have been called
13:12:55 <Wauchope> As it specifically says to only save once the player calls the exit function from the UI
13:13:33 <ChaiTRex> Wauchope: Ahh, I see.
13:13:58 <Wauchope> lol @ player, can you tell I do game dev in my spare time?
13:15:20 <ChaiTRex> Wauchope: For the I/O section at the bottom, you can have a `main :: IO ()` function. You can also have a `whatever :: [Place] -> IO ()` that acts as a loop. It takes the `currentPlaces` variable and does one thing. If it needs to do another thing, it calls `whatever updatedPlaces`.
13:15:50 <ChaiTRex> Wauchope: This is one way of reusing a variable. You have function arguments that are variables ready for use inside that function.
13:16:02 <dsal> `whatever :: [Place] -> IO [Place]` could return the final state.
13:16:23 <ChaiTRex> Wauchope: So, the function can call itself with an updated argument. That way `currentPlaces` keeps updated.
13:16:49 <ChaiTRex> Wauchope: This way, you don't try to set a variable twice in the same scope. You use a new scope by calling the function again.
13:17:00 <sm[m]> I bet if you start implementing a minimal version you’ll see how to do things
13:17:43 <ChaiTRex> Wauchope: That's one way functional programmers get around the only-set-a-variable-once restriction.
13:18:22 <ChaiTRex> Wauchope: But first, get the top part of the assignment done. Make sure your functions from that part work, then worry about the I/O section.
13:29:59 <frdg> https://pastebin.com/ByT7tCPf foldr related question
13:32:10 <ChaiTRex> frdg: You start off with [], so you need to do something with the accumulated list. returnLeftVal as your foldr function doesn't handle an until-now-Left value and a list.
13:32:26 <ChaiTRex> :t foldr
13:32:28 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:33:24 <ChaiTRex> frdg: As you can see just above, the accumulated list is the second parameter to the foldr lambda. foldr (\ left list -> ...) [] (filter isLeft x)
13:33:41 <maerwald> Yeah, this is quite interesting: '(BS.last . L.toStrict) <$> L.readFile "foo"' will have 2 times foos size in memory. 'L.last <$> L.readFile "foo"' will be O(1) memory.
13:33:53 <ChaiTRex> frdg: So, what do you want to do with the left value and the list value to combine them into a new list value?
13:34:02 <ChaiTRex> frdg: Fill that ... in with that.
13:34:19 <frdg> ChaiTRex: ok im gonna have to think for a minute
13:38:40 <frdg> ChaiTRex: what do you mean by "an until-now-Left value"
13:39:33 <ChaiTRex> frdg: The Left value it's currently processing from (filter isLeft x).
13:40:44 <ChaiTRex> frdg: foldr gets the results of (filter isLeft x). Then it goes through all the elements of that list. It combines them in some way, using the foldr's lambda argument (`(\ left list -> ...)`) and the foldr's starting accumulator argument (the `[]`).
13:41:40 <frdg> ChaiTRex: ok I think im getting closer mentally!
13:41:47 <ChaiTRex> frdg: So the result of the `foldr` starts off as `[]`. The lambda argument tells how to change that for each element in the `(filter isLeft x)` argument.
13:42:27 <ChaiTRex> frdg: So you want to make the lambda argument do something with the left value from the input list and the current value of the result list.
13:42:41 <ChaiTRex> frdg: How do you want to combine the left value with that result-of-foldr list?
13:42:54 <ChaiTRex> frdg: Do you want to put it in the list but without `Left`?
13:43:14 <frdg> ChaiTRex: I just want to cons it on
13:43:52 <ChaiTRex> frdg: OK, then you have `foldr (\ left list -> left:list) [] (filter isLeft x)`.
13:44:08 <ChaiTRex> frdg: See how the lambda conses them?
13:44:45 <ChaiTRex> frdg: If you want the `Left` part removed, you have `foldr (\ left list -> returnLeftVal left:list) [] (filter isLeft x)`.
13:45:11 <frdg> ohhh
13:45:16 <ChaiTRex> frdg: That does `returnLeftVal` on `left` and then conses it to `list`.
13:46:28 <ChaiTRex> frdg: If you're confused, always start the first argument of `foldr` out with a lambda rather than just a function name. You can simplify it later.
13:48:03 <ChaiTRex> frdg: Also, consider `map returnLeftVal (filter isLeft x)`.
13:48:48 <frdg> ChaiTRex: I get it now. I had/have a lack of understanding of how folds work. It becoming more clear why we can just fold instead of using explicit recursion. All were doing with this fold is operating on each individual value from the filtered list and cons'ing it on  
13:49:09 <frdg> Which is exactly what we do with explicitly recursive functions
13:49:55 <frdg> Thanks you! Im learning so much its crazy
13:50:03 <ChaiTRex> frdg: You're welcome.
13:53:00 * monochrom squints. Why do you need "foldr (\ left list -> left:list) []"?  It's just rebuidling the same list.
13:53:36 <Cale> frdg: I think one thing which helped was to look at examples like:
13:53:39 <Cale> sum [] = 0
13:53:44 <Cale> sum (x:xs) = x + sum xs
13:53:48 <Cale> product [] = 1
13:53:56 <Cale> product (x:xs) = x * product xs
13:54:00 <Cale> concat [] = []
13:54:07 <Cale> concat (x:xs) = x ++ concat xs
13:54:25 <Cale> and see "hey, these are all basically the same thing"
13:55:39 <maerwald> monochrom: I wonder if that gets optimised away
13:55:49 <monochrom> very likely yes
13:56:10 <Cale> And if you think about it carefully, they're going through a list and replacing [] with something, and each (:) with something else
13:56:30 <monochrom> But it is more important to recognize and remove XY problems in your brain, than optimize away redundant code in the computer.
13:56:36 <monochrom> Debug your mind.
13:56:48 <maerwald> monochrom: I'd rather not :P
13:56:56 <Cale> foldr is the obvious generalisation to make after looking at those three
13:56:57 <maerwald> That's a rabbit hole
13:57:18 <Cale> I think it's important to at least think about foldr (:) [] at some point, just long enough to realise that it's the identity function
13:57:34 <gentauro> 22:54 < Cale> and see "hey, these are all basically the same thing"
13:57:44 <gentauro> in the sense that they alle produce a `space leak`? :)
13:57:49 <monochrom> foldr (:) [] = id_but_for_list_and_inefficent is also an important theorem to learn.
13:58:05 <Cale> gentauro: They might not, and specifically the last one certainly doesn't
13:58:21 <Cale> (but the first two more often will)
13:58:36 <gentauro> Cale: the two first **will for sure** 
13:58:40 <gentauro> :)
13:58:58 <gentauro> so I would have to say that `they are not the same thing` ;)
13:59:10 <Cale> gentauro: Not necessarily if your addition can produce part of its result without pattern matching on its second argument
13:59:15 <gentauro> even thought the syntax look very similar
13:59:20 <Cale> (+) and 0 are polymorphic
13:59:44 <gentauro> s/thought/though/
14:00:13 <gentauro> Cale: could you provide an example?
14:00:22 <Cale> data Nat = Zero | Succ Nat
14:00:37 <Cale> Zero + m = m
14:00:45 <Cale> Succ n + m = Succ (n + m)
14:01:07 <gentauro> Cale: with regard of your `sum [] = 0; sum (x:xs) = x + sum xs` example
14:01:31 <gentauro> the reason I'm asking is cos I avoid anything like that
14:01:43 <solonarv> gentauro: also not necessarily if the strictness analyzer is on the ball
14:01:48 <gentauro> now my defualt is always `foldl'` from the `Data.List` module
14:02:02 <gentauro> cos I burned my finger so many times that it's not funny ...
14:02:14 <solonarv> IIRC at some point foldl (+) 0 started being the same as foldl' (+) 0 because the strictness analyzer got improved
14:02:15 <Cale> I'll totally admit it's uncommon for numbers to have lazy addition or multiplication, but the usual natural numbers do.
14:02:20 <gentauro> solonarv: that's fine, I just want to see an example
14:02:33 <gentauro> (so I can run it on my *nix box to corraborate it)
14:02:43 <Ariakenom> careful with that "usual"
14:03:03 <Cale> Ariakenom: I mean the natural numbers as I gave them
14:03:03 <ChaiTRex> gentauro: Cale put a Nat type above.
14:03:13 <Cale> The Peano naturals
14:03:20 <ChaiTRex> gentauro: Try that. You'll need to implement Num.
14:03:22 <gentauro> ChaiTRex: I can see that
14:03:48 <Cale> :t Succ
14:03:50 <lambdabot> error:
14:03:50 <lambdabot>     • Data constructor not in scope: Succ
14:03:50 <lambdabot>     • Perhaps you meant variable ‘succ’ (imported from Prelude)
14:03:53 <Cale> okay
14:03:55 <gentauro> now I would like to see it working on the example which I just copy pasted :)
14:04:00 <monochrom> But you will want to use foldr for (++) and concat.
14:04:04 <Cale> @let data Nat = Zero | Succ Nat
14:04:06 <lambdabot>  Defined.
14:04:33 <Cale> @let plus Zero m = m; plus (Succ n) m = Succ (plus n m)
14:04:35 <lambdabot>  Defined.
14:04:44 <gentauro> I mean, there is a reason I end up doing stuff like this -> http://blog.stermon.com/articles/2020/03/30/haskell-data-octet-safe-idiomatic-and-big.html
14:04:47 <gentauro> :|
14:04:52 <Cale> > foldr plus Zero (repeat (Succ Zero))
14:04:55 <lambdabot>  error:
14:04:55 <lambdabot>      • No instance for (Show Nat)
14:04:55 <lambdabot>          arising from a use of ‘show_M64675526967374693412392’
14:04:59 <Cale> d'oh
14:05:15 <Cale> @let deriving instance Show Nat
14:05:17 <lambdabot>  Defined.
14:05:20 <Cale> > foldr plus Zero (repeat (Succ Zero))
14:05:22 <lambdabot>  Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ...
14:05:28 <Cale> ^^ sum of an infinite list
14:05:30 <monochrom> Instead of using "sum [] = 0; sum (x:xs) = x + sum xs" as a toy example for learning foldr, you beat the hell out of the dead horse of how everyone already knows it's inefficient for most number types.
14:07:05 <Cale> Another example where you probably want foldr is with foldr (.) id
14:07:58 <Cale> This is because:
14:08:05 <monochrom> Roast: People argue so much over performance because that's the only thing they know, for example they don't know algebra or correctness or semantics.  Change my mind.
14:08:08 <Cale> foldr (.) id (f : g : fs)
14:08:15 <Cale> -> f . foldr (.) id (g : fs)
14:08:33 <Cale> and so
14:08:40 <Cale> foldr (.) id (f : g : fs) x
14:08:52 <Cale> -> (f . foldr (.) id (f : g : fs)) x
14:09:05 <Cale> oops
14:09:10 <Cale> I left the f in the list
14:09:21 <Cale> -> (f . foldr (.) id (g : fs)) x -- rather
14:09:28 <frdg> Cale: Was away from my computer but thanks for the help
14:09:31 <gentauro> monochrom: I guess many people talk about performance cos they need to run stuff in production. Not everybody lives in a bubble where they can just earn their money by providing papers ...
14:09:33 <Cale> -> f (foldr (.) id (g : fs) x)
14:09:41 <Cale> and now f can get to work
14:09:52 <Cale> and only if and when it uses its argument will the foldr continue
14:10:15 <Cale> (I am a professional Haskell programmer and do often care about performance btw)
14:10:50 <Cale> It's important to understand how all of these things actually get you performance, defaulting to any one of them isn't really possible
14:11:13 <Cale> Sometimes foldr will be infinitely faster than foldl'
14:11:41 <Cale> and/or use less space
14:12:46 <monochrom> I trust that you also acknowledge that semantics and correctness are equally important in production?
14:12:53 <Cale> A good rule of thumb is that you usually want foldl' when you're producing a "summary" of some input, no part of which can be evaluated without knowing all the elements of the input list
14:13:13 * hackage d10 0.2.1.2 - Digits 0-9  https://hackage.haskell.org/package/d10-0.2.1.2 (chris_martin)
14:13:30 <Cale> If you can produce some part of the output by only looking at some initial fragment of the input list, you probably want foldr
14:14:40 <Cale> So, things which do searching or chunking of the input, or reshaping the input list into a tree, or something like map which applies a function to all the elements of the list
14:15:19 <Cale> Or something like concat where the first elements of the output list can be determined from the first elements of the first nonempty list in the input
14:15:39 <Cale> Those are all good uses for foldr
14:16:12 <Wauchope> Back again, with another probably very simple question
14:16:27 <Cale> Another example would be turning the input list into an IO action -- you might want to begin running the action before computing the entire list, and foldr would let you do that.
14:17:15 <Wauchope> I'm using 2D pythagoras to determine the distance of each place to a given coordinate
14:17:40 <Wauchope> How can I sort a list of places based on the results of this 2d pythag
14:17:59 <Wauchope> e.g. [place with distance of 2, place with distance 4, place with distance 9999]
14:18:14 <Wauchope> I'm looking at sortBy and I'm not understanding the syntax
14:18:47 <monochrom> @type sortBy
14:18:48 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
14:18:57 <ChaiTRex> Wauchope: sortBy (comparing (\ ... -> theDistance)) xs
14:19:01 <monochrom> You probably first need to learn the Ordering type.
14:19:29 <monochrom> And then maybe you have never thought that one of the parameters could be a function itself.
14:19:43 <jakalx> Wauchope, what exactly don't you understand?
14:19:43 <monochrom> Err actually you already know that. Nevermind.
14:20:05 <Wauchope> What I'm understanding is sortBy (element a, element b, comparison) listA returns sortedListA
14:20:19 <monochrom> No. Recall filter.
14:20:20 <Wauchope> not haskell notation but yeah
14:20:25 <Wauchope> huh
14:20:43 <monochrom> @type filter
14:20:45 <lambdabot> (a -> Bool) -> [a] -> [a]
14:20:51 <monochrom> What do you say of that?
14:20:57 <jakalx> Wauchope, sortBy takes a function that compares two elements, a list and returns a sorted list
14:22:13 * hackage record-dot-preprocessor 0.2.3 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2.3 (NeilMitchell)
14:22:18 <Wauchope> (element -> condition) -> list -> filteredList
14:22:27 <jakalx> and Ordering is simply LT, EQ, GT
14:22:38 <Wauchope> returns a filteredList which contains all elements of list which satisfy condition
14:23:02 <solonarv> ChaiTRex: even better: use sortOn
14:23:11 <jakalx> ... for which the predicate returns True
14:23:11 <solonarv> sortBy (comparing f) = sortOn f
14:23:19 <solonarv> (but the latter is more efficient)
14:23:36 <ysangkok> i had to write a test where the ordering should be EQ or GT. so I did /== LT, but i think that is so hard to read
14:23:39 <monochrom> OK so sortBy is (element -> element -> Ordering) -> list -> sortedlist
14:23:55 <ysangkok> is there some kinda fancy lens operator that does what "in" does in python?
14:24:13 <ysangkok> so that you could write result `in` [EQ, GT]
14:24:20 <jakalx> `elem` :)
14:24:21 <monochrom> that's elem, and it doesn't need lens
14:24:24 <ysangkok> ah
14:24:26 <ysangkok> thansk
14:24:28 <solonarv> does it have to be a fancy lens operator?
14:24:33 <monochrom> @type elem
14:24:35 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
14:24:38 <solonarv> you can use it infix by surrouding it with ``
14:24:45 <solonarv> % :info elem
14:24:46 <yahb> solonarv: class Foldable (t :: * -> *) where; ...; elem :: Eq a => a -> t a -> Bool; ...; -- Defined in `Data.Foldable'; infix 4 `elem`
14:25:03 <solonarv> > 5 `elem` [2,5]
14:25:06 <lambdabot>  True
14:25:08 <ysangkok> somehow i had assumed it wouldn't be in base :O
14:25:24 <monochrom> It's a simple list function.
14:25:28 <ChaiTRex> solonarv: Ahh, thanks.
14:25:35 <monochrom> or started out as
14:26:02 <Wauchope> (a -> a -> Ordering) is (element a, element b) and returns (order of a, b) where ordering is the function which determines and returns (order of a, b) 
14:26:33 <Wauchope> @type Ordering
14:26:35 <lambdabot> error: Data constructor not in scope: Ordering
14:26:57 <solonarv> Wauchope: no, Ordering is a very simple data type
14:27:01 <solonarv> @src Ordering
14:27:01 <lambdabot> data Ordering = LT | EQ | GT
14:27:16 <ChaiTRex> Wauchope: Yep. It returns GT, EQ, or LT
14:27:50 <Wauchope> Less Than, Equal, Greater Than?
14:27:53 <ysangkok> 0 `compare` 9000
14:27:55 <solonarv> exactly
14:27:56 <ysangkok> > 0 `compare` 9000
14:27:59 <lambdabot>  LT
14:28:23 <monochrom> Ordering is a data type.
14:28:31 <monochrom> Everything is not a function.
14:29:01 <ChaiTRex> Wauchope: Yep. You choose the one that goes between the two arguments. If you have `(\ a b -> ...)`, would it be a < b, a == b, or a > b? Choose LT, EQ, or GT.
14:31:25 <Wauchope> What does the \ mean in this context? I used it earlier in my program without quite understanding it. It seemed to work similar to "each element of"
14:31:45 <solonarv> no, it's used to define a lambda (anonymous function)
14:31:52 <ysangkok> @src id
14:31:52 <lambdabot> id x = x
14:32:20 <solonarv> the symbol \ is used because it looks sort of like the greek letter lambda, with the little left "leg" removed
14:32:28 <solonarv> s/is used/was chosen/
14:32:35 <monochrom> λ
14:33:01 <Wauchope> so (\a, b -> a LT b) would sort in ascending order?
14:33:19 <solonarv> no, because that's an error
14:33:43 * hackage partial-semigroup 0.5.1.4 - A partial binary associative operator  https://hackage.haskell.org/package/partial-semigroup-0.5.1.4 (chris_martin)
14:33:46 <solonarv> there are two errors here: the comma between a and b, and the 'a LT b' body
14:33:57 <ChaiTRex> Wauchope: The pattern is `(\ argument1 argument2 argument3 -> result)`. The result would be `LT`, but that won't sort in order.
14:34:43 * hackage partial-semigroup-hedgehog 0.6.0.4 - Property testing for partial semigroups using Hedgehog  https://hackage.haskell.org/package/partial-semigroup-hedgehog-0.6.0.4 (chris_martin)
14:34:49 <ph88> hi guys, i once saw a package that weave together compiler optimizations. It was a library to model optimizations. I can't find it because i don't know the name. Anyone got an idea ?
14:34:55 <monochrom> Wait, there is no argumnt3
14:35:00 <ChaiTRex> Wauchope: `LT` as the result means that you're saying `a` is less than `b` regardless of what `a` and `b` are because you didn't check them to see if they're actually less-than each other.
14:35:09 <ChaiTRex> monochrom: I meant the pattern for lambdas in general.
14:36:23 <Wauchope> sortBy a b (\a, b -> LT)
14:36:40 <Wauchope> Would that be correct syntax? Also how do you do the neat little code blocks in this
14:36:45 <ChaiTRex> Wauchope: No, it's sortBy (\ a b -> LT) list
14:37:11 <solonarv> IRC doesn't have any way to format code blocks, btw
14:37:11 <ChaiTRex> Wauchope: But you want to fill in the lambda with a correct comparison function that gives good results.
14:37:31 <ChaiTRex> Wauchope: Haskell doesn't have commas between function arguments.
14:38:05 <Wauchope> The commas are a force of habit, ghc keeps throwing a fit at me every 5 or so minutes
14:38:21 <solonarv> > sortBy (\a b -> LT) [3,1,2] -- uh oh!
14:38:23 <lambdabot>  [3,1,2]
14:38:29 <solonarv> what do you mean by "throwing a fit"?
14:38:38 <Wauchope> As in, telling me the commas shouldnt be there lol
14:38:57 <solonarv> well, they shouldn't be there, of course GHC will tell you that!
14:39:04 <ChaiTRex> Wauchope: You can also do this: `sortBy functionYouMadeSomewhereElse list` and then define `functionYouMadeSomewhereElse`
14:39:13 <monochrom> Perhaps don't worry about lambda now, write a named function and use it for now.
14:39:19 <ChaiTRex> Wauchope: If you want to define the comparison function using a normal function.
14:41:21 <Wauchope> so back to my example where im comparing distances
14:41:41 <Wauchope> lets say im getting the distance between two points using distance (Float Float) (Float Float)
14:41:54 <Wauchope> and that returns a single Float
14:42:17 <Wauchope> How exactly would I structure the sorting function
14:42:33 <solonarv> tuples are still written with commas, btw
14:42:52 <monochrom> Huh? I thought you're already using sortBy so you only worry about writing comparison?
14:42:57 <solonarv> I assume you have some reference point and you're comparing the distances of all the places to that one reference point?
14:43:09 <solonarv> tbh, sortOn is a better tool than sortBy here
14:43:20 <Wauchope> function def a b | a <= b = a | otherwise b
14:43:30 <Wauchope> yeah, for testing I'm using (0, 0)
14:43:46 <monochrom> When is this homework due?
14:43:52 <Wauchope> I have like a month left
14:44:02 <monochrom> OK that's a lot of time.
14:44:42 <monochrom> You can like learn Haskell basics properly for two weeks and then come back to this homework question.
14:46:56 <Wauchope> I'm probably going to rewrite a lot of this code before the submission date, I'd just like to know I have it working so I can work on some other coursework in the mean time
14:47:47 <monochrom> You can learn properly or you can cargo-cult.
14:47:48 <ChaiTRex> Wauchope: Well, you have three possible results. One of them is LT. When is a less than b?
14:48:09 <monochrom> I won't support cargo-culting but I guess I can't stop other people from supporting that.
14:48:30 <monochrom> Also most "dive-in approach"es are euphemism for cargo-culting.
14:48:42 <Wauchope> When distance (controlPos, a) < distance (controlPos, b)
14:48:51 <monochrom> Learning properly means bottom-up.
14:49:17 <ChaiTRex> Wauchope: OK, now you know the guard and you know the result. Make all three.
14:50:07 <ChaiTRex> Wauchope: I would recommend what monochrom said, though. For example, you're using `zipWith`. So learn how to create it. Make a function called zipWith' with the single quote on the end of the name (to avoid a name collision with zipWith) and use that instead.
14:50:55 <dsal> As a bonus, you can make it return `Maybe [c]` and have it only work on the same sized inputs if that's what you want.
15:07:24 <Wauchope> I appreciate the advice, though using what you've said I've managed to use the sortBy function to sort my list of places by their distance from a control point
15:09:06 <ChaiTRex> Wauchope: Oh, good.
15:48:43 * hackage path-text-utf8 0.0.1.4 - Read and write UTF-8 text files  https://hackage.haskell.org/package/path-text-utf8-0.0.1.4 (chris_martin)
16:18:23 <Nolrai> @ty \l -> sum $ fst <$> l
16:18:25 <lambdabot> (Foldable t, Num a, Functor t) => t (a, b) -> a
16:19:52 <MarcelineVQ> :o
16:20:25 <Nolrai> Hmm?
16:20:29 <MarcelineVQ> !
16:20:52 <Nolrai> Whats so exciting?
16:20:55 <MarcelineVQ> Figured you were prompting something since you could ask ghci that question :>
16:21:12 <Nolrai> ...I forgot ghci exists.
16:21:25 <Nolrai> I just don't use it much.
16:21:46 <Nolrai> Which probably sounds weird...
16:21:52 <MarcelineVQ> interesting, most people's experience with haskell tends to be a text editor and a ghci window
16:22:20 <MarcelineVQ> mine preference is a text editor and a ghci window and a ghcid window
16:22:26 <Nolrai> Eh, I prefer to just recompile.
16:22:47 <MarcelineVQ> then you should check out ghcid for sure
16:22:54 <Nolrai> What is ghcid?
16:23:08 <MarcelineVQ> It auto builds the project on changes and gives you the errors if any
16:23:10 <MarcelineVQ> you use stack or cabal?
16:23:17 <Nolrai> stack.
16:23:32 <sMuNiX> Nolrai, do you use : stack build --file-watch ?
16:23:34 <MarcelineVQ> k in your project you can type  stack build ghcid   and then  stack exec ghcid
16:24:08 <MarcelineVQ> I would do this per-project in stack rather than installing it globally
16:24:19 <Nolrai> ANd I was using HIE plug in for ms code, but those weird problems I was having earlier prompted me to turn it off.
16:24:53 <MarcelineVQ> editor integration had been hit or miss for me but ghcid has never failed, in a way that wasn't obvious to fix
16:25:07 <Nolrai> Interesting.
16:28:56 <Nolrai> Huh, it seems to have missed my LANGUAGE Rank2Types pragma for some reason.
16:29:36 <solonarv> there is just RankNTypes now. I don't know if writing a Rank2Types pragma does anything.
16:31:01 <Nolrai> When did that happen?
16:32:31 <solonarv> a while ago, though I'm not sure when
16:41:55 <monochrom> GHC declares Rank2Type deprecated and also aliases it to RankNTypes.
16:43:43 <Nolrai> So it should have worked.
16:44:20 <monochrom> Perhaps watch out for typos, I just made one. :)
16:45:58 <solonarv> but GHC will yell at you if it sees an unknown/misspelled LANGUAGE pragma.
16:46:09 <Nolrai> Okay I was momentarily getting this weird error, but deleting and reentering the s at the end of "RankNTypes" fixed it: https://pastebin.com/07EER5Vq
16:46:34 <ysangkok> even if you misspell LANGUAGE? i remember being confused about that sometime
16:46:51 <solonarv> hm, in that case it might not say anything.
16:46:52 <monochrom> Is your computer playing an April 1st on you? :)
16:47:33 <Nolrai> Maybe an interaction with my format on save?
16:47:53 <solonarv> might be, sure sounds like some program was working with a stale version of the file
16:48:17 <Nolrai> Well if it hapens again its easy to fix.
16:48:38 <monochrom> "have you re-entered your code?" :)
16:49:49 <Nolrai> Is there a way to write `(LM.distance `on` fmap (^. (weight . connections))) l r` without quite so many parens?
16:50:02 <Nolrai> Oh, opps.
16:50:15 <ysangkok> Nolrai: yes, using ($)
16:50:36 <asfewiona> When I type `:set -RecordWildCards` in ghci I get "Some flags have not been recognized: -RecordWildCards"
16:50:45 <MarcelineVQ> -XRecordWildCards
16:50:55 <Nolrai> Oh I don't _have_ to use on as an opperator!
16:50:56 <asfewiona> Thanks!
16:51:00 <MarcelineVQ> you can use autocomplete as well  :set -XRec<tab>
16:51:43 * hackage geniplate-mirror 0.7.7 - Use Template Haskell to generate Uniplate-like functions.  https://hackage.haskell.org/package/geniplate-mirror-0.7.7 (LTChen)
16:53:13 <Nolrai> ysangkok: I don't see how here..
16:54:22 <ysangkok> Nolrai: why wouldn't fmap $ ^. $ weight . connections work?
16:55:21 <ysangkok> (that would indeed need to be enclosed to have l r outside)
16:55:41 <Nolrai> Ah, well that wont work, but if I replace ^. with view it will.
16:57:32 <solonarv> actually you might be able to use: (LM.distance `on` view (mapped . weight . connections)) l r
16:57:48 <solonarv> or somethin like it
16:58:13 * hackage hadoop-streaming 0.1.0.0 - A simple Hadoop streaming library  https://hackage.haskell.org/package/hadoop-streaming-0.1.0.0 (zliu41)
16:58:53 <MarcelineVQ> you can just use the record accesors if you're only getting anyway
17:03:40 <koz_> For the newtype deriving strategy, what does it mean that GHC 'can't eta reduce the representation enough'?
17:04:34 <koz_> Never mind figured it out. I should brand 'Vector is a type family' somewhere visible every time I forget.
17:04:40 <koz_> s/type/data/
17:04:55 <solonarv> if you have a newtype like 'newtype FState t s a = FState (StateT s t a)' then that gives you an equality 'FState t s a ~ StateT s t a'
17:05:18 <solonarv> this can be eta-reduced to 'FState t s ~ StateT s t', but no further
17:05:33 <koz_> Ah, so it can't reach 'through' more than one layer of newtype?
17:05:39 <koz_> I guess I could do a deriving via?
17:05:39 <solonarv> so for this example you can derive e.g. Monad but not MonadTrans
17:05:48 <solonarv> derriving via can fix this, yes
17:05:56 <koz_> solonarv: Time to Iceland Jack it up.
17:07:14 <solonarv> for example if you had 'newtype MyTrans t a = MyTrans (StateT MyState t (Maybe a))' then no eta reduction is possible, but you can derive via MaybeT (StateT ...)
17:07:36 <solonarv> (note: I used ~ above; that's not strictly speaking the right symbol, but I was going for expediency)
17:10:54 <koz_> solonarv: You meant it in the sense of coercibility, I guess?
17:14:50 <Wauchope> Ah, still had this window open
17:15:18 <Wauchope> Right so I have a weird issue right now , probably caused by something very simple
17:15:30 <Wauchope> I have a snippet of code which runs perfectly in the command line
17:15:32 <Wauchope> Works, no issues
17:15:47 <Wauchope> But when I've put it in my code, it's throwing an error
17:17:23 <Wauchope> https://paste.myst.rs/c9p
17:17:26 <koz_> solonarv: I have a newtype like 'newtype Foo a = Foo (Vector (Bar a))', where Bar is all of Functor, Foldable, Traversable. Can I automagic Functor, Foldable and Traversable for Foo?
17:18:23 <Wauchope> Wait
17:18:27 <Wauchope> Nevermind, I am pretty dumb
17:19:12 <koz_> solonarv: Only DerivingVia can work, except I have no idea how to phrase it.
17:20:48 <solonarv> koz_: yes you can!
17:20:54 <koz_> solonarv: How would I phrase it?
17:21:03 <solonarv> the trick to DerivingVia is finding a newtype that already has the right instances
17:21:10 <solonarv> in this case, that's 'Compose Vector Bar'
17:21:32 <solonarv> so the clause looks like: deriving (Functor, Foldable, Traversable) via (Compose Vector Bar)
17:21:35 <koz_> Oh right.
17:21:38 <koz_> I see now.
17:25:43 <koz_> solonarv: By that you mean 'Data.Functor.Compose' right?
17:25:51 <koz_> Because I get a representation mismatch error.
17:26:14 <solonarv> yes, that's the one I mean
17:26:25 <koz_> I can get Functor and Foldable, but not Traversable.
17:26:28 <koz_> Hit this issue before.
17:26:43 <koz_> (due to the rule of the 'f' argument in the function fed to traverse)
17:26:46 <solonarv> ah, I think there's some issue where Traversable can't be newtype-derived
17:26:47 <solonarv> yeah
17:26:50 <koz_> It's assumed nominal.
17:26:53 <koz_> (for _very_ good reason)
17:27:01 <solonarv> perhaps the stock deriving mechanism works?
17:27:16 <koz_> I can try?
17:27:18 <solonarv> (you can explicitly use it with a 'deriving stock' clause)
17:27:25 <solonarv> yeah, give it a try
17:27:35 <koz_> Huh, stock actually works?
17:27:40 <koz_> But _newtype_ fails?
17:27:44 <koz_> What is this sorcery.
17:28:28 <solonarv> the sorcery is that the stock deriving mechanism actually looks at the structure of the type
17:28:46 <solonarv> newtype deriving (including DerivingVia) just slaps a few 'coerce's in there
17:28:52 <koz_> Ah, I see.
18:18:49 <jchia__> Does GHC have an optimization on integer operations that applies arithmetic identities? E.g. a - b - c == a - (b + c), a + b + c == (a + b) + c == a + (b + c). When multiple calculations are requested, it could rewrite formulas and increase the number of shared subexpressions. There is the problem of overflow but I think some of the identities work even with overflow.
18:21:13 * hackage WAVE 0.1.5 - WAVE audio file IO library  https://hackage.haskell.org/package/WAVE-0.1.5 (BartonMassey)
18:21:37 <dmwit> You could ask -ddump-simpl if you have something specific in mind you're hoping will happen.
18:21:45 <dmwit> But I sort of doubt anything very exciting happens.
18:22:40 <salumu> :t (+)
18:22:42 <lambdabot> Num a => a -> a -> a
18:23:03 <sMuNiX> :t (-)
18:23:05 <lambdabot> Num a => a -> a -> a
18:25:08 <ClaudiusMaximus> @hackage fast-math jchia__ but afaict that's for floating point and also unsafe
18:25:09 <lambdabot> http://hackage.haskell.org/package/fast-math jchia__ but afaict that's for floating point and also unsafe
18:27:13 * hackage WAVE 0.1.6 - WAVE audio file IO library  https://hackage.haskell.org/package/WAVE-0.1.6 (BartonMassey)
18:35:43 * hackage readme-lhs 0.4.0 - See readme.md  https://hackage.haskell.org/package/readme-lhs-0.4.0 (tonyday567)
18:49:53 <koz_> > fmap (+1) (1, "foo")
18:49:56 <lambdabot>  error:
18:49:56 <lambdabot>      • Could not deduce (Num [Char]) arising from a use of ‘+’
18:49:56 <lambdabot>        from the context: Num a
18:50:00 <koz_> Ah.
19:06:04 <oats> > fmap (+1) ("foo", 2)
19:06:07 <lambdabot>  ("foo",3)
19:06:23 <oats> huh, know that I've ever used the tuple functor instance
19:11:35 <oats> *don't know :P
19:13:29 <koz_> oats: It happens to be the exact one I need.
19:15:02 <oats> koz_: neat, what are you up to? :)
19:15:58 <koz_> oats: https://imgur.com/a/MRIzh69
19:16:59 <koz_> :t foldM
19:17:00 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
19:17:44 <oats> I do believe screenshots of code are punishable with a lashing 'round these parts :>
19:17:56 <koz_> oats: You were the one who asked.
19:18:16 <oats> I'm being silly
19:18:19 * koz_ mumbles something about a thousand words.
19:19:31 <Axman6> koz_: very cute, love the DerivingVia. I hadn;t thought of doing that
19:19:48 <koz_> Axman6: Neither had I until recently.
19:19:55 <koz_> I'm going full Iceland Jack.
19:20:54 <dsal> :t holdM
19:20:56 <lambdabot> error:
19:20:56 <lambdabot>     • Variable not in scope: holdM
19:20:56 <lambdabot>     • Perhaps you meant ‘foldM’ (imported from Control.Monad.Writer)
19:21:03 <Axman6> We need a new Compose :: [f :: * -> *] -> * -> *
19:21:48 <Axman6> so you can write feriving (Functor) via Compose [(,) Word, HashMap Word, VIRNode]
19:22:14 <koz_> Axman6: Singletons probably has you covered with a type-level Foldr.
19:22:41 <oats> oh no
19:22:45 <oats> My brain wrinkled
19:22:49 <koz_> It's a pity you can't get Traversable via that method.
19:22:59 <koz_> Something something role restrictions on arbitrary higher-kinded types argh.
19:23:14 <koz_> I mean, I know why this is necessary, but it's still aggravating.
19:23:26 <koz_> I'm firmly in the camp that 'fmap coerce == coerce' should 100% be a thing.
19:25:10 <solonarv> Axman6: koz_: you can at least make it slightly better using an infix alias for Compose
19:26:03 <solonarv> in fact you have infixr 9 `Compose` -- very nice!
19:26:19 <Axman6> does that work at the type level though?
19:26:31 <oats> type level stuff makes my neuron misfire
19:26:36 <solonarv> yes it does (at the term level Compose doesn't even take enough arguments for that to make sense)
19:26:40 <koz_> solonarv: Ah, so I could spell that 'deriving (Functor, Foldable) via ((,) Word `Compose` HashMap Word `Compose` VIRNode'?
19:26:46 <koz_> Nice.
19:26:49 <solonarv> yup!
19:27:00 <solonarv> you may or may not need the outermost parens, I don't know.
19:27:22 <MarcelineVQ> oak: https://i.imgur.com/WPc8Bit.jpg
19:27:48 <MarcelineVQ> ^ oats :>
19:28:08 <oats> wait no
19:28:16 <oats> but I cant think
19:28:19 <oats> and it wrinkle
19:32:49 <koz_> oats: Honestly, type-level stuff isn't that bad. It's just different and not often needed.
19:33:14 <oats> I'm sure if I look at it hard enough long enough, it'll make sense
19:33:24 <oats> (just like regular haskell at first :P)
19:34:08 <koz_> I am a _huge_ typelevel fanboi, and despite this, my work Haskell has zero typelevel shenanigans.
19:34:15 <koz_> (unless you count the above, which I don't)
19:35:18 <ysangkok> i just started using typelits-witnesses to enforce the right vector lengths for my api
19:35:32 <koz_> ysangkok: Why that and not vector-sized?
19:35:32 <ysangkok> it worked out well!
19:36:14 <ysangkok> koz_: because i just need sizes to be consistent throughout use, there is no hardcoded length
19:36:16 <oats> koz_: oh sweet, you do haskell jobbing
19:36:22 <oats> koz_: can I ask what kind of haskell jobbing you do?
19:36:31 <koz_> ysangkok: ... uhh, vector-sized can do that?
19:36:44 <koz_> oats: I'm a consultant working on an eDSL to do database shenanigans.
19:36:55 <koz_> I'm responsible for the translation back-end.
19:37:22 <oats> DSLs in haskell are so nice
19:37:30 <koz_> oats: I would _hate_ to do this in anything else.
19:37:36 <ysangkok> well, i wanted my context object to not contain a vector. i just want it to be indexed by the length that the functions that are passed the context have a matching vector length
19:37:46 * oats beats koz_ over the head with a ruby
19:37:50 <oats> jk
19:37:55 <oats> I wouldn't wish that on anyone
19:38:04 <koz_> ysangkok: Can you give me a function signature for something you're doing with typelits-witnesses?
19:38:34 <ysangkok> koz_: like, i have makeContext :: Context n ... and then useContext :: Context n -> Vec n -> Bool
19:38:49 <koz_> ysangkok: Vec n is a linked-list style vector.
19:38:59 <koz_> Or is Vec some other thing?
19:39:36 <ysangkok> i just wrote Vec for simplicity , i am actually using fixed-vector
19:39:42 <koz_> Ah.
19:40:15 <koz_> I suspect you'd be better off with vector-sized instead, unless your use case is _very_ specific.
19:40:38 <ysangkok> but i read that vector-sized has an overhead for the length
19:40:48 <koz_> ysangkok: And you believe fixed-vector lacks it?
19:41:21 <ysangkok> i used fixed-vector based on the section at the bottom here: https://hackage.haskell.org/package/vector-sized
19:41:34 <ysangkok> (i don't need more than tens of elements)
19:41:45 <koz_> So your use case is very specific, got it. :P
19:41:59 * koz_ wonders how their respective APIs compare.
19:44:30 <ysangkok> it's not that niche, it is a multisignature library. so if you decide that you have 5 co-signers, it doesn't make sense to provide 4 partial signatures and have it compile
19:45:37 <koz_> I didn't mean your particular target for the library was niche. It's more that linear collections capped at tens of elements _guaranteed_ isn't something I see often.
19:45:43 <koz_> I'm not saying yours isn't it.
19:45:47 <ysangkok> gotcha
19:45:53 <koz_> Just that it's a guarantee that I rarely see hold up in reality.
19:50:10 <koz_> But yeah, I'm still curious how fixed-vector and vector-sized's APIs compare.
20:00:43 * hackage pvar 0.2.0.0 - Mutable variable with primitive values  https://hackage.haskell.org/package/pvar-0.2.0.0 (lehins)
20:41:13 * hackage dlist 0.8.0.8 - Difference lists  https://hackage.haskell.org/package/dlist-0.8.0.8 (SeanLeather)
21:34:13 * hackage githash 0.1.4.0 - Compile git revision info into Haskell projects  https://hackage.haskell.org/package/githash-0.1.4.0 (MichaelSnoyman)
23:54:13 * hackage microbase 4.14.0.0.2 - A minimal base to work around GHC bugs.  https://hackage.haskell.org/package/microbase-4.14.0.0.2 (dailectic)
