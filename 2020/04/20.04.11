00:01:58 <freeman42x> does anyone know of an alternative for JSaddle.WebKitGTK ?
01:38:10 <tasuki> I've got two empty projects, one set up with `stack new first yesod-simple` the other with `stack new second`: the first uses `ghc-8.6.5` while the second tries to download `ghc-8.8.3` and gives me the warning `Stack has not been tested with GHC versions above 8.6, and using 8.8.3, this may fail`.
01:38:52 <tasuki> Why does the second one want 8.8.3 ? Grepping, I can't see that written down anywhere...
01:41:15 <tasuki> Ah, I see there's a different `resolver` in `stack.yaml`. This is super non-intuitive for newbies :S
01:41:34 <MarcelineVQ> it'll pick the ghc that is set by your projects stack.yaml, which lts that is is usually whatever the global lts is set to in .stack/global-config/stack.yaml or .stack/config.yaml     possibly the yesod-simple template picks a lower lts and so an older ghc
01:43:49 <MarcelineVQ> *it'll pick the ghc determiend by the resolver in your project's stack.yaml
01:44:27 <MarcelineVQ> I've a bad habbit of saying lts even though not every snapshot/resolver is an lts snapshot.
01:44:49 <tasuki> MarcelineVQ thank you, I wonder why `resolver: lts-15.7` is the default in the template when it's not necessarily supported?
01:45:51 <MarcelineVQ> is your stack up to date?
01:45:58 <tasuki> Also wonder why it's `resolver: lts-15.7` rather than `resolver: ghc-8.6.5`?
01:47:16 <tasuki> I'd hope so - installed stack yesterday by piping a magical curl to bash rather than my OS's package manager
01:47:37 <MarcelineVQ> I think ghc-8.6.5 provides only the packages that come with ghc, whereal lts 15.7 provides everything at  https://www.stackage.org/lts-15.7  but I'm not sure
01:48:26 <MarcelineVQ> ah, I would have reccomend just grabbing the binary from git, never know where scripts are going to stick things
01:49:49 <tasuki> is LTS like stack's own distribution of GHC?
01:52:37 <MarcelineVQ> That's the kind of question that suggests to me you should be reading the docs :> A stack snapshot (lts or otherwise) is a curated set of packages from hackage that are known to build together and does include an appropriate ghc version to match them.
01:53:00 <MarcelineVQ> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/ is a good first stop
03:09:33 <fendor> I saw in a .cabal file in `ghc-options: +RTS -A32m -RTS`. The intention was to pass flags to GHC itself while compiling. Does that work?
03:12:33 <MarcelineVQ> yes
03:14:14 <fendor> MarcelineVQ, thanks! Do you happen to know where this is documented?
03:14:40 <MarcelineVQ> this being  ghc-options:   or this being +RTS ?
03:15:13 <MarcelineVQ> anything you can give ghc on the cli can go in ghc-options
04:52:35 <SrPx> You know what the world really needs? A central place to post informal mathematical or programming articles without publishing a full paper. Things like algorithms or data structures. For example, I'd like to write an article to explain what the optimal lambda calculus is. But where do I post it?
04:58:14 <ziman> on your blog? :)
05:19:15 <SrPx> That's what I'm talking, everyone seems to create his own blog for that. This is extremely sub-optimal for discovery
05:21:56 <tasuki> MarcelineVQ very helpful link thank you!
05:25:51 <MarcelineVQ> SrPx: medium is pretty popular possibly similarly hard to discover in the way you want on but it's got better google searching than many sites
05:27:50 <tomjaguarpaw> How can I add a local directory as a package source in a .cabal file?
05:34:30 <tomjaguarpaw> I'm not having any luck with a packages: stanza
05:34:31 <tomjaguarpaw> cabal-install version 3.2.0.0
05:34:32 <tomjaguarpaw> compiled using version 3.2.0.0 of the Cabal library
05:36:29 <lyxia> shouldn't that be in the cabal.project file, not the .cabal file?
05:47:16 <tomjaguarpaw> Yes, apparently it should, thanks!  But now I get the dreaded "No targets given and there is no package in the current directory."
05:48:07 <tomjaguarpaw> Oh I have to say "packages: ." too
05:56:37 <tasuki> I thought I'd be able to describe a minimum-two length list as `Int : Int : [Int]` but am getting errors I don't understand... any quick solutions?
05:57:23 <c_wraith> values and types are separate.  (:) is a value constructor, not a type constructor.
05:58:25 <sedeki> tasuki you probably meant `Int -> Int -> [Int]`
05:58:38 <c_wraith> no, that's not at all what tasuki wanted.
05:58:46 <tasuki> c_wraith thanks that makes sense!
05:58:51 <c_wraith> tasuki wanted a type for lists with a minimum length of 2
05:58:57 <sedeki> ah.
05:59:06 <sedeki> sorry
05:59:14 <tasuki> what sedeki wrote would be kind of a workaround :)
05:59:38 <tasuki> thanks for the quick responses to you both!
05:59:38 <c_wraith> tasuki: there's also something like data AtLeastTwo a = AtLeastTwo a a [a]
05:59:58 <c_wraith> that's basically how Data.List.NonEmpty.NonEmpty is implemented
06:00:14 <tasuki> yes, that's probably an even nicer workaround
06:01:49 <kolu> hello guys
06:02:12 <sedeki> hello
06:02:16 <sm[m]> tasuki that stack warning is annoying but harmless
06:02:50 <kolu> I have a simple loop -> https://pastebin.com/ibz5cEMB
06:03:39 <kolu> it works, but I wonder if return() is the appropriate way to close it
06:03:40 --- mode: weber.freenode.net set +o ChanServ
06:05:29 <sedeki> kolu the return type is "IO ()" as per your signature
06:07:36 <kolu> I'm not sure I understand 
06:08:42 <kolu> when there are no more strings left inside the list
06:08:53 <kolu> It should stop
06:08:55 <sedeki> yes? then you return ()
06:09:12 <kolu> but what is return () 
06:09:16 <kolu> what do I return
06:09:57 <kolu> there is nothing left to return
06:09:58 <kolu> hmm
06:10:24 <sedeki> "return" does not mean the same thing in Haskell as in e.g. Python
06:10:51 --- mode: weber.freenode.net set +o ChanServ
06:11:27 <kolu> but that is the proper way to end the recursion?
06:11:27 <xdccMule[7276IJ]> Hellooooooooooo!!!
06:12:21 <sedeki> kolu you end a recursion with a base case - which is exactly as you have done
06:12:46 <kolu> ok, thank you
06:12:54 <kolu> I shall look further into the meaning of return
06:12:59 <yushyin> kolu: maybe you didn't know yet but () is a value of type () we sometimes call it Unit
06:14:16 <yushyin> kolu: return (or pure) injects/puts a value into a monadic context so it puts your () into the IO a context.
06:15:00 <sedeki> kolu sorry, i'm a newcomer to haskell as well, so I can't really explain well and don't want to try so much either because I might be saying something wrong
06:15:07 <aveltras> is it possible, in a cabal package, to get its own version in its code ?
06:16:38 <dcoutts_> aveltras: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
06:17:13 <aveltras> dcoutts_: thanks
06:18:02 <yushyin> kolu: so while () is of type (), return () is of type IO () (in your case). Maybe it is a bit confusing at first, that the type () and its value constructor () share the same name.
06:18:54 <kolu> it is indeed
06:19:21 <kolu> you say pure() would do the same?
06:21:17 <yushyin> kolu: yes, pure does the same. the default implementation of return by now is return = pure.
06:27:52 <kolu> thank you
06:28:56 <maerwald> and pure is 2 chars less
06:29:13 <maerwald> imagine how much disk space you save 
06:29:19 <kolu> hehe
06:34:01 <kolu> how about the empty list base case
06:34:07 <kolu> why does that work
06:34:15 <kolu> function [] = []
06:34:42 <sedeki> it pattern matches, so when "function" is passed the empty list, that part is run
06:35:06 <kolu> yes, but it returns the result not an empty list
06:35:59 <sedeki> it would help if you give us the entire function description
06:36:34 <aveltras> i'd like to define some kind of "dynamic" servant endpoint which exposes a js lib tagged with the package version, any idea how i could complete the missing part here ?
06:36:38 <aveltras> https://www.irccloud.com/pastebin/qacVf9Yv/
06:36:50 <yushyin> kolu: it returns a base-case so all good?
06:36:56 <kolu> https://pastebin.com/ibz5cEMB
06:38:06 <sedeki> say you run `loop [1,2,3]` then it pattern matches on `loop (x:xs)` so that x = 1, xs = [2,3]
06:38:28 <sedeki> then `loop [2,3]` is executed
06:43:17 <SrPx> @MarcelineVQ exactly, I wish we had a more tech-oriented, less comercial Medium though
06:43:17 <lambdabot> Unknown command, try @list
06:43:26 <SrPx> posting tech articles on Medium is so awful
06:43:28 <kolu> sedeki
06:43:44 <kolu> but then it gets to and empty list
06:43:55 <sedeki> kolu yes
06:44:07 <kolu> but it doesn't return an empty list
06:44:08 <yushyin> kolu: and it pattern matches on that empty list and returns an empty list, so: 1 * 2 : (2 * 2 : ( 3 * 2 : []))
06:44:26 <yushyin> kolu: loop [] = [] returns an empty list.
06:44:28 <sedeki> kolu remember that the base case is _called_ from the recursive step
06:45:11 <kolu> aah
06:45:20 <kolu> so it's like adding all the previous cases to that last case
06:45:24 <sedeki> yes
06:45:35 <kolu> yes, I got it
06:45:38 <kolu> thank you once again
06:45:42 <sedeki> np
06:45:59 <kolu> how elegant that language is
06:47:23 <yushyin> kolu: but your type signature is a bit messy, it should be :: [Int] -> [Int]
06:48:37 <kolu> yes, I just edited the previous example
06:48:41 <kolu> forgot to change the types
06:49:07 <yushyin> thought so ^^
06:49:55 <frdg> https://pastebin.com/fN7mZ3GU question in regards to writing semigroup/monoid instance
06:52:00 <frdg> also the code that isn't mine comes from my book
06:54:46 <aveltras> is there a way to get a cabal package version but as a type level symbol ?
06:56:43 <hvr> aveltras: would a type-level string literal suffice?
06:56:53 <dcoutts_> aveltras: there's a CPP symbol VERSION_thenameofthepackage for each dependency of your package, and your package itself
06:57:29 <aveltras> i need it for a servant end point as shown here
06:57:30 <aveltras> https://www.irccloud.com/pastebin/qacVf9Yv/
06:57:40 <aveltras> the cpp might work, i ll check this
07:03:00 <aveltras> dcoutts_: works fine :) thanks
07:06:50 <frdg> https://pastebin.com/fN7mZ3GU question about writing semigroup instance
07:12:49 <herrhotzenplotz> frdg: the append operation in the semigroup instance is an infinite recursion. ghci tries to evaluate it and recurses indefinitely.
07:14:08 <frdg> herrhotzenplotz: hmm ok. Ill have to think about why that is
07:14:39 <herrhotzenplotz> frdg: What you probably want to do is a append of the onlies and wrap the result into a First
07:16:35 <frdg> herrhotzenplotz: ok ill try that. I did try this earlier but couldn't get it to compile and figured that it wasn't what needed to happen. Ill comeback here if I continue to have problems. Thank you
07:16:49 <herrhotzenplotz> np
07:50:14 <tomsen> will the new record.field syntax fix namespace pollution?
07:51:57 <yushyin> tomsen: that would be NoFieldSelectors
07:53:50 <tomsen> i'll read up on it. thanks!
07:59:41 <yushyin> tomsen: the plan was first that RecordDotSyntax should imply NoFieldSelectors but the authors were later convinced that this should not be the case. here the argument for reference https://github.com/ghc-proposals/ghc-proposals/pull/282#issuecomment-547641588
08:01:25 <tomsen> so when using NoFieldSelectors and RecordDotSyntax, one should have namesprace free of record fields, and access can still happen through myrecord.somefield?
08:02:48 <yushyin> yup
08:03:22 <tomsen> i like it! do you by any chance when this will land?
08:03:27 <tomsen> *know
08:04:46 <yushyin> RecordDotSyntax is still not accepted so who knows ^^
08:05:23 <tomsen> ok, good to know. im ready for the candy whenever its there = )
08:06:37 <steb> hello
08:13:15 <fenedor> yushyin, I thought it was accepted? Wasnt there a shepherd decision or something like that?
08:14:59 <yushyin> tomsen: they recently decided on how the new syntax should work in detail because there were /many/ different opinions on that matter. The auhors need to update the proposal now (and is short on time currently) and the committee has to approve the new updated proposal anew. My humble guess is a couple months before it will land in a stable release.
08:15:39 <fenedor> ah, ok
08:19:09 <tomsen> it doesnt sound like it would be in nightly yet. otherwise i'd try it already. but im really stoked about that feature. is discussion happening on github? ill bookmark the issue
08:21:22 <tsani> wai-websockets & servant-websockets appear broken? Testing my API with curl, I would expect to get a 101 reponse, but nothing in wai-websocket's code suggests sending such a response
08:21:27 <tomsen> ah ok they say it in the issue. nvm thanks again yushyin
08:22:05 <yushyin> fendor: public discussion on github has stopped, the committee uses a mailinglist. the process is a bit complex you can read about it here https://github.com/ghc-proposals/ghc-proposals#the-life-cycle-of-a-proposal
08:23:40 <tomsen> woe, there is some typesystem magic going on in this lifecycle :D
08:43:30 <jmnoz> Hi, how do I fix Couldn't match expected type `T.Text'
08:43:31 <jmnoz>               with actual type `m0 T.Text'
08:46:05 <[exa]> jmnoz: very likely m0 is any Monad; suggest putting 'return' before the thing that's being returned
08:46:15 <[exa]> jmnoz: btw pastebin some code if you can
08:47:58 <jmnoz> https://gist.github.com/jmn/4adcca4a7e95e943fcb36640185423a4
08:48:20 <jmnoz> it's on the 2nd row from the bottom
08:52:39 <jmnoz> any ideas?
09:02:00 <[exa]> jmnoz: hm could you paste the full error too?
09:03:35 <[exa]> (also, what type is out ?)
09:03:46 <jmnoz> I pasted it as a comment to the gist
09:04:05 <jmnoz> out :: T.Text -> IO ()
09:05:56 <[exa]> jmnoz: ok, writeMarkdown is already for writing the markdown, it returns an action
09:06:02 <[exa]> not a "pure Text"
09:06:31 <jmnoz> hmm okay
09:07:27 <[exa]> so you can either use directly writeMarkdown to save it to a file, or (if `out' is somehow very custom) find a function that just formats the pandoc to the text
09:07:50 <jmnoz> okay thanks!
09:09:20 <[exa]> but wait, writeMarkdown should just return String
09:09:40 <jmnoz> yeah that is confusing
09:09:51 <[exa]> which module are you importing that from?
09:10:22 <[exa]> writeMarkdown here is cool nice ...->String   https://pandoc.org/doc/pandoc/Text-Pandoc.html
09:10:26 <jmnoz> hmm oh import qualified Text.Pandoc as Pandoc
09:10:55 <[exa]> oh yes that's well quite old version
09:11:00 <jmnoz> I see
09:11:06 <[exa]> anyway you can just do (writeMarkdown ...) >>= out
09:11:19 <jmnoz> thanks :D
09:11:52 <[exa]> if it's really generic in the monad, you can just bind the result so that it goes to the 'out' inside of the IO action
09:16:51 <jmnoz> maybe I'm doing it wrong? I get No instance for (Pandoc.PandocMonad IO)
09:16:51 <jmnoz>     arising from a use of `Pandoc.writeMarkdown'
09:16:51 <jmnoz> * In the first argument of `(>>=)', namely
09:16:52 <jmnoz>     `(Pandoc.writeMarkdown def doc)'
09:17:54 <[exa]> ok it was a wild guess, it didn't work
09:20:22 <[exa]> hm ok, let's try: (Pandoc.runIO $ Pandoc.writeMarkdown ...) >>= out
09:20:37 <[exa]> there's some kind of specific pandoc monad that wraps pandoc operations
09:21:53 <jmnoz> runIO seems to return an either
09:22:16 <jmnoz> if i am not misstaken
09:27:22 <monochrom> Don't give up yet. What's in the either?
09:28:34 <jmnoz> Either Pandoc.PandocError T.Text
09:28:48 <jmnoz> my haskell is really rusty (3 years ago) 
09:29:48 <jmnoz> do i have to use case?
09:33:15 <jmnoz> Kn
09:33:18 <jmnoz> I have no idea
09:34:23 <jmnoz> fromRight?
09:35:49 <[exa]> uh AFAIK there's a variant that returns just IO
09:35:56 <[exa]> see the docs, it will be pretty close there
09:36:13 <jmnoz> thanks again
09:56:18 <jmnoz> if I change it to:         Right doc -> (Pandoc.runIOorExplode $ Pandoc.writeMarkdown Pandoc.def doc) >>= out
09:56:35 <jmnoz> I get an error on earlier line: let pd = Pandoc.readHtml Pandoc.def t
09:56:50 <jmnoz>  No instance for (Pandoc.PandocMonad (Either Pandoc.PandocError))
09:56:50 <jmnoz>     arising from a use of `Pandoc.readHtml'
09:56:50 <jmnoz> * In the expression: Pandoc.readHtml def t
09:56:50 <jmnoz>   In an equation for `pd': pd = Pandoc.readHtml def t
09:57:38 <aveltras> any idea why the following doesn't type check ? i have scoped typed variables enabled
09:57:44 <aveltras> https://www.irccloud.com/pastebin/YNnWg3PD/
09:58:40 <aveltras> The problem being the ToJSON instance with the AFormErrors constructor
10:01:20 <aveltras> ok forget it, seems i has to move the forall in the sum type
10:01:26 <aveltras> https://www.irccloud.com/pastebin/PTlmZiGM/
10:27:46 <bredor> when I do `cabal build`, I have this error: https://paste2.org/U14454Cp. Had to delete `/usr/lib/ghc/package.conf.d` for some reason, is there a way to create a new package db?
10:32:52 <monochrom> The simplest way is to treat this the same way you treat corrupted GHC installation.
10:34:03 <bredor> monochrom: so no other way except reinstalling? 
10:34:48 <monochrom> There are always other ways. More expensive ways.
10:35:53 <monochrom> For example if you have a deep understanding of what's supposed to be in that directory, you "can" write it by hand.  I almost know how to do it in theory.  And I would still not do it.
10:36:08 <bredor> yeah, that is not convenient at all
11:02:54 <frdg> are infix data constructors common? Id never seen one until now.
11:03:38 <solonarv> depends, does : count? because that one's very common :D
11:04:11 <frdg> solonarv: ...I didn't think of that!
11:52:33 <svipal> I'm so sad hslua removed support for versions earlier than 5.3
11:52:36 <svipal> that means no more luajit
12:24:57 <svipal> wow wow
12:25:09 <svipal> I'm using stack and when putting an older version of a package in extra deps
12:25:43 <svipal> I'm not able to enabble flags that are in this version
12:25:46 <svipal> but not the most recent
12:25:47 <svipal> wtf ?
12:25:55 <svipal> will try destroying the .stack-work and trying again
12:26:26 <svipal> yeah doesn't work
12:26:32 <svipal> is there something I can do ?
12:27:26 <sm[m]> share your stack.yaml and cabal file, in case there's an issue ?
12:27:39 <sm[m]> cabal files
12:27:44 <sm[m]> it sounds like something that should work
12:28:53 <svipal> damn x)
12:29:11 <svipal> I was not writing in extra deps but in extra package dbs
12:29:22 <svipal>  /facepalm
12:33:39 <sm[m]> \o/
12:48:32 <nineonine> is there a Prelude function for \(a,a) f -> (f a, f a) ?
12:50:04 <lyxia> no
12:50:28 <nineonine> I guess I can just join bimap
12:51:37 <maerwald> > flip (join (***)) (1,2) (+1)
12:51:39 <lambdabot>  (2,3)
12:51:55 <maerwald> Please use the lambda
12:53:40 <nineonine> why
12:53:58 <Rembane> nineonine: I usually define it in a Utils module and call it both. If you love lenses too much it's there too. 
12:54:10 <Rembane> THB it's there even if you hate lenses.
12:54:17 <nineonine> :)
12:55:18 <Rembane> nineonine: It's also in extra: https://hackage.haskell.org/package/extra-1.7.1/docs/Data-Tuple-Extra.html#v:both
12:56:11 <monochrom> there is &&& or *** from Arrows, I forgot which.
12:56:16 <monochrom> @type (&&&)
12:56:17 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
12:56:32 <monochrom> (f &&& f) a
12:56:33 <Rembane> (***) is the one you want in this case
12:56:44 <Rembane> Or maybe not no 
12:56:46 <Rembane> Cool! 
12:56:48 <monochrom> @type (***)
12:56:49 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:57:21 <nineonine> thx everyone
13:01:56 <maerwald> nineonine: because it is more readable
13:02:13 <maerwald> and using join that way is obfuscation
13:05:35 <hseg> debugging a derivation error. sketch of the classes/instances involved: http://ix.io/2hCR 
13:06:16 <hseg> ... missing a `deriving instance S (T r)` there 
13:06:37 <hseg> updated: http://ix.io/2hCU
13:07:09 <hseg> GHC complains it can't deduce G (U (P r)) for the S (T r) instance
13:09:39 <hseg> hrm, ok so what i pasted fails, but the following succeeds http://ix.io/2hCW
13:09:48 <hseg> why are they different?
13:11:53 <hseg> in any case am running into the need to be able to convince ghc that U (T r) is coercible into U (P r). unless the appropriate way is to propagate Functor U constraints everywhere?
13:25:00 <lyxia> hseg: can you make these examples complete (can compile) and also paste the error?
13:31:17 <hseg> will need to wait for tomorrow, thanks anyway
14:12:44 <bwe> I don't understand the third Applicative law: u <*> (v <*> w) = pure (.) <*> u <*> v <*> w
14:17:00 <bwe> Which role plays the dot operator in a chain of <*>?
14:21:30 <d34df00d> Composing u and v.
14:21:43 <d34df00d> (or the functions within those applicatives, rather)
14:23:21 <pavonia> Is this making use of the Applicative instance for functions? That law doesn't seem obvious to me either
14:23:51 <maerwald> huh?
14:23:54 <monochrom> No, it is a law for all Applicative instances.
14:24:23 <maerwald> how can it be Applicative instance for function when there is a pure in front
14:24:44 <[exa]> bwe: it's "making sure that function composition works as expected even through <*>"
14:24:51 <monochrom> A first stab at understanding the law is that it is an associativity law, and the extra "pure (.)" is necessary for technicality because <*> has an assymetric type.
14:25:30 <[exa]> bwe: putting the right-hand side into parentheses according to <*> left fixity should clear it a bit
14:27:43 <monochrom> A second stab is then investigating what's the detailed technicality and why "pure (.) <*>" is necessary and sufficient.  For example you can start inferring the types of u, v, w and see how they match or mismatch.
14:28:24 <maerwald> we have 4 applicative laws, afair?
14:29:00 <monochrom> For simplicity if you investiage with u = pure u0, v = pure v0, w = pure w0, you can get a very good glimpse of what could happen.
14:29:34 <maerwald> https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws
14:30:16 <maerwald> the descriptions there are not that useful
14:30:37 <pavonia> It makes more sense when you don't think in terms of `f . g` but `\x -> f (g x)`, because under the hood (.) is just nested application
14:31:19 <d34df00d> Alright, stupid transformers question (haven't had too much sleep today).
14:31:35 <d34df00d> Let's say I have two computations of the type MonadReader Foo m => m (Maybe Int).
14:31:44 <d34df00d> How do I combine them with msum-like semantics for Maybe?
14:31:49 <d34df00d> Without executing too much.
14:33:56 <maerwald> d34df00d: just use msum?
14:34:05 <maerwald> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Reader.html#t:ReaderT
14:34:16 <maerwald> see the definition of MonadPlus instance
14:34:55 <d34df00d> Ah cool, this makes sense!
14:34:57 <d34df00d> Thanks!
14:35:05 <maerwald> I mean, how would you define it otherwise
14:35:19 <monochrom> You can also recall "(.) u0 v0 w0 = u0 (v0 w0)" now generalize from funapp to <*>
14:35:21 <d34df00d> Didn't think ReaderT has "proxying" MonadPlus instance.
14:35:33 <maerwald> Well, reading can't really fail, can it?
14:35:39 <monochrom> Hmm I should tell my students that view next time!
14:36:00 <d34df00d> On a somewhat related note, I just wrote the following instance:
14:36:01 <monochrom> Nonetheless, every binary operator begs for an associativity law!
14:36:17 <d34df00d> instance MonadZ3 m => MonadZ3 (ReaderT r m) where getSolver = ReaderT $ const getSolver ; getContext = ReaderT $ const getContext
14:36:29 <d34df00d> This looks awfully automatable, but is it?
14:38:06 <bwe> monochrom: https://bpaste.net/22QQ
14:38:17 <maerwald> d34df00d: (MonadReader Foo m, MonadZ3 m) => m (Maybe Int)?
14:39:00 <monochrom> Yes like that.
14:39:08 <bwe> monochrom: Thanks, I got it. The key were the parentheses instead of (.) plus getting the u into pure u0.
14:40:11 <solonarv> d34df00d: MaybeT might be relevant to your interests
14:40:15 <d34df00d> maerwald: I mean, this sort of instances for MonadReader usually look trivial.
14:40:39 <d34df00d> MonadZ3 is not really related to my original question (although both questions relate to the same project :]).
14:42:42 <monochrom> My http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Winter/06-fam.html also has some comments on the laws.
14:43:07 <monochrom> The page is long but you just need to scroll down to the "Applicative" section.
14:43:36 <monochrom> That section is still long so you still have to look for the place I list and discuss the laws :)
14:44:08 <monochrom> But I show how to the Applicative laws imply the Functor laws under "fmap f xs = pure f <*> xs"
14:44:39 <monochrom> s/ to / /
14:45:44 <monochrom> And then a second corollary about how liftA3 could be done two ways.  This one I "don't" show the proof, but if you ask your browser to show the HTML source code, I have it inside a HTML comment block. :)
14:46:52 <monochrom> I think these are good 3rd stabs at understanding the laws, i.e., deriving intuitive "common sense" corollaries.
14:47:50 <heatsink> Is there a library function that displays the first difference between two strings in a readable way?  This is for writing tests.
14:54:33 <jk54> Hello all, I'm having an issue parsing a json value using aeson  and any tips would be great. I can parse the data fine by creating a record and the an instance of FromJSON, I would like to get the parts of the json data without creating types though. For example, {items: [ {uuid: value_needed}, "uuid": value_needed, "uuid": value_needed]}. I would
14:54:34 <jk54> like to get [value_needed, value_needed]. Any help would be great.
14:56:25 <maerwald> I don't understand the question
14:56:51 <heatsink> JSON is represented with data type Value.  You can examine the value directly to read the parts
14:57:20 <heatsink> The Object constructor is a JSON dictionary.  The Array constructor is a JSON array.
14:57:45 <maerwald> Yeah, or you parse it into HashMap directly
15:18:06 <frdg> https://pastebin.com/QnCMagWK quick syntax question
15:19:52 <frdg> and this would explain why when I look at the prelude in Haskell there are so many a', b', c' etc. 
15:50:16 <dgpratt> I'd like to get a sense of what Haskellers are using for their toolchain these days. I think not so long ago, the best experience for those of us less experienced was using Stack. As long as you stay within the guard rails, Stack seems fairly foolproof. But I see progress continues in the direction of making the Cabal experience much better as well. And of course there's Nix as well as other options I probably don't 
15:50:16 <dgpratt> know about. So what are you guys using? Anyone gone back to straight Cabal from Stack?
15:51:10 <Uniaika> dgpratt: what I'm going to say is only my experience, so that it with a grain of salt
15:51:21 <dgpratt> salt handy
15:51:40 <yushyin> ghcup+cabal-install is what I'm using
15:51:41 <Uniaika> stack is wonderful to have some basic bootstrapping of a toolchain for a project, and its nix integration is very nice
15:51:43 * dcoutts_ has been the new cabal for 4 years
15:52:08 <Uniaika> nowadays, cabal 3 + nix is a possible, and legit setup
15:52:40 <Uniaika> but learning nix requires effort, time, and black magic fuckery to decypher the workings of an under-documented dynamically typed language
15:54:09 <Uniaika> (and I'm not only saying this out of spite or anything, my company uses Nix for our CI needs, and it's a real concern)
15:54:41 <dcoutts_> You can generate the nix setup from cabal.
15:55:04 <dcoutts_> From the cabal.project I mean, using a tool.
15:55:28 <dgpratt> Nix gives me mixed feelings as well; I love the concept and the execution is amazing, but I struggle to get on with it
15:55:52 <dcoutts_> So a project I'm working on also uses Nix for the CI but I never touch the nix files, and don't have to develop using nix.
15:56:38 <dgpratt> I wonder what a version of Nix that is based on Dhall would look like
15:57:39 <dgpratt> I appreciate the feedback, guys
15:58:50 <dgpratt> how long has ghcup been a thing? I don't remember that, but it might be because I've historically been stuck on Windows for practical purposes
15:59:29 <Uniaika> ask maerwald :P
16:37:00 <d34df00d> How is ADTs encoding called where, for example, you encode Nat = Z | S Nat as ∀X. X → (X → X) → X?
16:37:37 <d34df00d> That's not Church encoding in general is it?
16:41:40 <monochrom> Oleg encourages us to call it Böhm-Berarducci encoding.
16:42:16 <monochrom> At the term level, and when ignoring types, it's indistinguishable from Church encoding.
16:42:46 <monochrom> But sometimes the whole point is the System-F type, and Church encoding is emphatically untyped.
16:43:32 <monochrom> Böhm and Berarducci wrote the first paper that discussed the typed story, so Oleg likes to recognize them.
16:48:24 <Eduard_Munteanu> Hm, I used to call that defining inductive types by explicit introducers/eliminators. :/
16:55:06 <d34df00d> monochrom: didn't know about those folks, thanks!
17:35:26 <fishooter> hi :) I'm trying to learn a bit about networking with haskell. I found this tutorial: https://wiki.haskell.org/Implement_a_chat_server  
17:35:34 <fishooter> here is my messy version I made so far
17:35:36 <fishooter> https://repl.it/repls/ImmediateAbsoluteCopyrightinfringement
17:36:03 <fishooter> what I'm not sure how to implement is that on server interrupt all the connections should be closed
17:36:07 <fishooter> how do I do that?
17:36:30 <fishooter> it seems that after pressing ctrl+c the main is terminated in ghci
17:36:45 <fishooter> but the telnets are not disconnected, and can still send messages
17:37:08 <fishooter> how is that even possible? I thought the by terminating the main process the threads should terminate as well
17:37:25 <dcoutts_> that's just an effect of running in ghci
17:38:06 <dcoutts_> because in ghci, terminating the evaluation thread just goes back to the repl prompt, it doesn't shut down the process
17:38:20 <dcoutts_> but if you compile it as a standalone program it will
17:38:38 <fishooter> ah, ok :) I'll try that
17:38:51 <fishooter> how can I run Chat.main without renaming the module?
17:38:54 <fishooter> to Main.main
17:39:04 <fishooter> I only know how to do this via ghci
17:39:15 <dcoutts_> -main-is
17:41:33 <fishooter> hm, not sure how -main-is is used, but this worked: stack runhaskell Chat
17:42:28 <fishooter> yes, now it indeed terminates, thank you dcoutts_ :)
18:12:09 <mirk0> using % character in quasiquotation?
18:13:34 <mirk0> getting parse error on it
18:15:42 <mirk0> this is my example, [r|notify-send "date" "$(date +"%R %A, %e %B")"|]
18:16:08 <mirk0> error points to % in front of 'e'
18:18:15 <somestrangeircus> oh i found the room, i need smol advice with haskell, whats the simplest way to test and compile software and such? i would like to have something that gets out of my way and is simple to use for testing including functional root acces so i can focus solely on language and not on the kit to see how can i run it
18:36:00 <fishooter> somestrangeircus: if you want to try out simple examples without installing anything, I recommend to use https://repl.it/languages/haskell
18:38:03 <somestrangeircus> fishooter i meant more something like utility to test things, i dont wanna use internet tools
18:38:46 <yushyin> ?
18:38:48 <MarcelineVQ> somestrangeircus: what have you tried?
18:39:35 <somestrangeircus> its been quite a long time i forgot what it was called but it pretty much was compiling every library, took long ate lot of space and did not function in root, and was annoying to use, i think it was stack or something like that but not sure
18:40:46 <fishooter> somestrangeircus: I think you might have answered yourself :)
18:40:52 <fishooter> https://docs.haskellstack.org/en/stable/README/
18:41:09 <somestrangeircus> oh it was really called stack
18:41:11 <somestrangeircus> that thing, oh man
18:41:22 <somestrangeircus> i dont wanna use that ever again
18:41:42 <somestrangeircus> i dont really have a choice in that do i?
18:42:07 <fishooter> what is your usecase? what would you like to do?
18:42:54 <somestrangeircus> well i would like to be able to work with gtk, but right now my line of importance is towards TUI, if i can use haskell for that, i hope i can somehow
18:43:57 <fishooter> I have not used Haskell with gtk, but there is a nice simple 2D rendering library called gloss
18:44:15 <sm[m]> somestrangeircus: stack is still easiest
18:44:22 <fishooter> this is good starting point: https://www.youtube.com/watch?v=VxLvaHpAK-U&t=4s
18:44:38 <fishooter> and yes, you will probably need to manage packages with stack
18:44:52 <fishooter> it's actually quite pleasant to work with
18:44:52 <somestrangeircus> if i have to use stack, oh well i guess i just have to, i hoped to avoid it but seems like i have no chioce
18:45:05 <somestrangeircus> also how do you actually use haskell with root acces? in root it cannot load libraries it needs
18:45:35 <fishooter> I don't know what you mean by root access. Running haskell as root?
18:45:39 <somestrangeircus> yes
18:45:50 <fishooter> Why would you do that? :)
18:45:59 <fishooter> and you can just use sudo whatever
18:46:11 <somestrangeircus> thats the issue, when i sudo haskell complains about missing libraries
18:46:16 <MarcelineVQ> I find  cabal-install  easier than stack, ghc and cabal-install are painless to get with  ghcup.  root is a bad idea to do dev in for any language, "woops, I wrote to / again"
18:46:16 <fishooter> Haskell compiles to binaries, so you can use them just as any binary
18:46:34 <somestrangeircus> i require root sometimes so kek
18:46:47 <somestrangeircus> strange even when compiled it still complained, i suppose i did something wrong back then
18:47:11 <sm[m]> somestrangeircus: running as root is crazycakes and a definite source of problems
18:47:54 <monochrom> I wouldn't trust vague memories.  Especially someone else's vague memories further butchered by vague or even incorrect wording.
18:47:57 <somestrangeircus> the thing is, i would like to make comfy applet for fan control, not hard, but the thing is the fan control is controlled by writing value into a file thats located in /proc
18:48:30 <somestrangeircus> or small app or anything, for that root is the way to go, without root it wont work
18:52:11 <monochrom> Just a few days ago right here I saw a question "here is the paste, I got a syntax error, how to fix it?"
18:52:20 <somestrangeircus> oof
18:52:35 <monochrom> I loaded the code myself and found it was a type error, not a syntax error.
18:52:48 <monochrom> So I said that.  They replied, "oh, right, I meant type error".
18:53:10 <monochrom> YOU CAN'T EVEN TRUST SOMEONE TO CORRECTLY STATE WHAT HAPPENED RIGHT ON THEIR SCREEN RIGHT NOW.
18:53:15 <somestrangeircus> heh
18:53:24 <monochrom> So nevermind a "recollection" "a couple of years ago".
18:53:53 <somestrangeircus> well  i dont trust my memories too well either
18:54:30 <monochrom> If they say "stack" there is 50% chance they don't mean stack.  If they say "long time to compile" there is 50% chance it's long time to something else.
18:55:14 <somestrangeircus> i just forgot the name stack and when i requested i wanna install GTK libraries for haskell it just compiled it which takes a very long time so ye
18:55:16 <fishooter> somestrangeircus: I just tested some app I have at my machine. I can run the binary with sudo without issues.
18:55:24 <somestrangeircus> i guess i was just doing it wrong
18:55:59 <fishooter> it is a GUI app that uses OpenGL
19:00:38 <somestrangeircus> anyways thanks for help, imma go to sleep now, bye
19:01:08 <Welkin> I thought ghci had colored output
19:01:14 <Welkin> do I need to enable it?
19:01:20 <Welkin> or am I not remembering right
19:01:48 <monochrom> It has.
19:02:07 <Welkin> how do I enable it?
19:02:21 <monochrom> I did nothing. It's the default.
19:02:27 <Welkin> unrelated question: Can I use extensible records in haskell yet?
19:02:33 <Welkin> in 8.8?
19:02:44 <monochrom> Perhaps watch out for terminal type, TERMCAP, all that details.
19:02:58 <monochrom> 8.6 here, but I can try 8.8
19:02:59 <Welkin> I'm using iterm
19:03:05 <Welkin> iterm2 on mac
19:03:11 <monochrom> I still get colour.
19:03:16 <dsal> Oh man, I missed root guy.  Permission problem, better set everything to 777 and run as root.
19:03:21 <monochrom> OK, me is ubuntu and gnome terminal.
19:03:43 <Welkin> I mean full syntax highlighting
19:03:46 <MarcelineVQ> it is default, it is also not very colorful
19:04:03 <dsal> I'm still not super happy with my JSON parsing.  I tried doing something better, but when I finished, it was worse.
19:04:13 <MarcelineVQ> e.g. :set -Wall and foo :: Bool -> Int; foo True = 1  will reveal if there's color since that sort of warning is pink
19:04:14 <monochrom> I entered 'x'+4. The error message has "error" in red. The rest is just bright but default colour.
19:04:14 <Welkin> I'm always in awe when I see the elixir repl
19:04:17 <Welkin> it's so colorful
19:04:23 <Welkin> even the elm one has a lot of color
19:04:35 <Welkin> I see, ghci does have color, but the only thing it colors is the word "error" in red
19:04:36 <dsal> I can't figure out how to turn off the elm color stuff.
19:05:27 <Welkin> MarcelineVQ: it's purple =D
19:05:35 <Welkin> but yeah, no syntax highlighting
19:06:00 <Welkin> okay then
19:06:05 <Welkin> so about those extensible records
19:06:26 <Welkin> is the only feature from elm I feel like it a huge loss when using haskell
19:06:49 <monochrom> See how you can't even trust people to say "syntax highlighting" correctly.  They can only vaguely handwave "colour".
19:07:36 <dsal> Is that a thing coming to haskell?
19:07:49 <monochrom> Are people generally drunk tonight such that their whole vocabulary consists of only the  500 simplest words?
19:07:54 <MarcelineVQ> wich that?
19:08:02 <dsal> elm-type extensible records.
19:08:03 <Welkin> extensible records
19:08:05 <dsal> It's a neat feature.
19:08:12 <Welkin> it's my favorite feature of elm
19:08:36 <Welkin> if haskell had that, plus with miso, I may not have much reason to use elm over haskell
19:08:43 <Welkin> except for the nice polish it has
19:09:21 <monochrom> extensible record is in the past of haskell, not in the future.
19:09:28 <yushyin> :D
19:09:29 <monochrom> hugs has TREX.
19:09:30 <Welkin> so where is it?
19:09:44 <monochrom> hugs
19:09:47 <Welkin> I've seen some extension before, but it was so horribly ugly
19:09:50 <Welkin> I mean for ghc
19:09:53 <Welkin> I don't use hugs
19:09:55 <monochrom> the future has dependent typing only.
19:10:03 <Welkin> no 
19:10:08 <Welkin> I want extensible records
19:10:21 <monochrom> I don't like it either.
19:11:10 <monochrom> Nothing can be done.
19:11:29 <monochrom> A million curry-howard fans can't be wrong.
19:12:02 <Welkin> NOOO!
19:12:05 <Welkin> why is this happening?
19:12:13 <dsal> And the compiler will make it impossible to state stuff like that if you can't prove it.
19:12:14 <Welkin> I'm on macos catalina and I get this trying to install nix
19:12:15 <Welkin> mkdir: /nix: Read-only file system
19:12:21 <monochrom> Your best bet is encoding extensible record types as dependent types.
19:12:24 <MarcelineVQ> something something subtyping
19:12:27 <dsal> Welkin: catalina doesn't allow writing to /
19:12:42 <Welkin> so how do I install nix??
19:12:49 <dsal> and nix, for whatever reason thinks it belongs in /
19:12:53 <Welkin> dmj`: help!
19:13:37 <Welkin> why is nix not in homebrew either?
19:14:22 <d34df00d> Is there anything like MonadWriter m w, but where w isn't just a Monoid but some MonadicMonoid, for MonadicMonoid m w where mappendm :: w -> w -> m w
19:14:31 <d34df00d> (MonadicMonoid is also imaginary)
19:15:06 <d34df00d> So it's gonna be MonadicMonoid m w => MonadicMonoidMonadWriter m w where ...
19:15:17 <Welkin> is this a joke???? https://github.com/NixOS/nix/issues/2925#issuecomment-499517186
19:15:32 <Welkin> "Realistically, this may force us to drop support for macOS. Using a different store location for macOS would require a separate binary cache and a separate Hydra instance, and there would be no guarantee that the new location wouldn't break in the future."
19:15:49 <Welkin> what a stupid excuse
19:15:55 <MarcelineVQ> you can't tell nix where the store root is?
19:15:57 <Welkin> just change the install directory to ~/.nix
19:16:01 <Welkin> jesus
19:16:24 <monochrom> send a PR.
19:16:34 <Welkin> I have no idea how to fix it
19:16:53 <Welkin> I love that that comment got 116 thumbs down
19:17:01 <monochrom> heh
19:18:11 <d34df00d> I love that github has thumbs down reaction.
19:18:14 <dmj`> Welkin: nix's website has install instructions
19:18:31 <dmj`> Welkin: oh, don't upgrade to Catalina
19:18:42 <Welkin> I have catalina on all my machines
19:18:49 <Welkin> have had for over half a year
19:19:13 <Welkin> can I install ghcjs/miso without nix?
19:19:22 <Welkin> without ripping me hair out?
19:19:33 <dmj`> it's possible to make a new partition in Catalina where /nix isn't read-only, but it's kind of a pain
19:19:55 <dmj`> Welkin: I got it working, but it's not worth it imo, I just downgraded and found the OS to be much stabler
19:20:30 <dmj`> Welkin: stack dropped support for GHCJS, real bad move on their part
19:20:33 <monochrom> I almost switched to mac.  I was only stopped by lack of money.  :)
19:20:45 <dmj`> Welkin: you have to install GHCJS from source otherwise
19:20:59 <dmj`> monochrom: there's always the hackintosh option :)
19:21:17 <d34df00d> Alright, i guess I'll just do instance MonadZ3 m => Monoid (m AST) where mappend = ...
19:21:34 <d34df00d> monochrom: dunno, I don't like macs.
19:21:43 <d34df00d> I just don't feel like I have control over the system I presumably own.
19:21:49 <monochrom> By the time I had enough money, I gathered from here all sorts of oddball mac issues, so I stayed with ubuntu.
19:25:32 <dmj`> monochrom: NixOS is looking very nice these days with Gnome3
19:26:53 <dsal> Welkin: It's kind of dumb.  Having a writable / is not a good idea in general.
19:27:09 <average> hi, does FP have any merit?
19:27:32 <MarcelineVQ> Welkin: https://logs.nix.samueldr.com/nixos/2020-02-25#3105500 is elucidating on the problem but not exactly helpful
19:27:56 <Welkin> I use mac as my primary machine. I use linux at work, but even that I ssh into using a mac
19:30:33 <dsal> That bug is just sad.  It's this weird thing where people come around and ignore the history of everything.  I've had plenty of systems with read-only / over the years.  It's a good security measure.  But also, what other software in the last thirty years has decided / is the right place to install?
19:31:47 <monochrom> snap
19:31:49 <yushyin> guix
19:32:14 <MarcelineVQ> guix too?
19:32:29 <yushyin> for what I know it uses /gnu/store
19:32:43 <yushyin> (but I may be wrong on that)
19:32:49 <dsal> I've never heard of guix.  I used snap once in an ec2 image.  It was recommended to install docker and ended up making a docker install that required root to interact with (AFAICT).
19:32:52 <monochrom> but perhaps snap counts as "comes with linux distro" so it doesn't count as after-the-fact software.
19:32:52 <MarcelineVQ> seems to. so weird
19:32:53 <dmj`> average: yes
19:33:08 <dmj`> @google why FP matters
19:33:10 <lambdabot> http://www.google.com/url?q=https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
19:33:10 <lambdabot> Title: Уведомление о переадресации
19:33:17 <dmj`> @google why haskell matters
19:33:18 <yushyin> dsal: guix is nix but gnu and with scheme
19:33:18 <lambdabot> http://www.google.com/url?q=https://wiki.haskell.org/Why_Haskell_matters
19:33:19 <lambdabot> Title: Уведомление о переадресации
19:33:47 <dsal> So, guix and snap are both "part of the OS" then and not a program you'd install on your existing OS?  I guess they get partial credit.
19:34:10 <monochrom> Anyway it is in the recent years that a few people suddenly want to install to your /theirdirname
19:34:58 <monochrom> So my theory is millenials not respecting unix conventions and good habits.
19:35:20 <monochrom> "I am special"
19:35:30 <dsal> There are often good reasons to defy the laws of tradition.  I'm not sure I see how there's one here.
19:35:31 <yushyin> dsal: you can install guix on a foreign distro like you can nix
19:35:36 <dsal> "but we hard code all the paths"
19:36:02 * MarcelineVQ checks what's in their /opts, "seems like a pretty reasonable place to put things, based on what I see in here"
19:36:13 <monochrom> I'm OK with hard-coding paths, but at least make it /opt/mydirname not /mydirname
19:36:47 <dsal> Yeah.  /opt always seemed a little weird to me, but it's at least a thing.
19:36:48 <monochrom> virtualbox guest additions has the courtesy of using /opt
19:36:59 <dsal> I'm glad we don't have /stack and /ghc and stuff.
19:37:17 <MarcelineVQ> monochrom: But we'll need to rebuild the hydra cache if we change that path monochrom, one single time, ever
19:37:30 <MarcelineVQ> We can't stop now, the train is going too fast!
19:37:54 <MarcelineVQ> I've sunken all my costs
19:38:19 <dsal> Both users will be pissed!
19:39:47 <dsal> The other thing about requiring / is that there's no way around requiring root access.
19:40:07 <dsal> I guess some people like that, though.
19:40:59 <Welkin> "here, run this random shell script that asks for your root password to install this software"
19:41:00 <monochrom> My theory is again millenials not knowing that "I only have an unprivileged account on this shared server" is a thing.
19:41:17 <monochrom> "everyone has a laptop, right?"
19:43:08 <monochrom> "let them have cake"
19:43:36 <dsal>  Why would you share a computer?
19:58:07 <DigitalKiwi> psst #nixos is a place that could answer your questions better instead of everyone shit talking it
19:59:47 <Cale> monochrom: Why share computers when you can just make another one on AWS? ;)
20:00:22 <monochrom> let them have aws
20:00:27 <monochrom> :)
20:03:48 <dsal> DigitalKiwi: Fair, but they've made it literally impossible to use on this computer and it's a KI.  They have to convince people that they *should* use it and that systems should change around them to do it.
20:06:22 <Cale> I think there is a way to change where the nix store is. The downside is that it breaks the binary cache.
20:06:52 <DigitalKiwi> thus why they don't want to change it
20:07:14 <dsal> I mean, I don't like changing stuff I got wrong the first time sometimes, but things are generally better after I do so.
20:07:14 <DigitalKiwi> have fun rebuilding *everything*
20:07:52 <DigitalKiwi> the binary cache is over 200TB maybe 250TB
20:08:00 <DigitalKiwi> cache.nixos.org
20:08:57 <DigitalKiwi> on nixos, the primary and best supported target, /nix is fine :P
20:10:18 <dsal> This is a thing plan9 did really well.  I'm surprised more systems haven't picked up plan 9's bind(1) thing.
20:10:24 <DigitalKiwi> as to why they didn't use /opt idk i'm sure there's a reason (i don't know if you'd consider them good reasons...) but nix, by design, does enough different from the typical FHS that...well, w/e
20:11:01 <DigitalKiwi> like i said #nixos there are a few people on right now at this very moment that can probably answer
20:11:13 <monochrom> Yes I was baffled at that too.  But now that you mentioned "best on NixOS", perhaps that's why.  They were only thinking of NixOS.
20:11:54 <dsal> nix as a haskell build tool is kind of a non-starter at this point.  Some projects use stack, some projects just use cabal.  nix has been argued as superior, but requires all users on the system to have root filesystem write access... which isn't always possible.
20:12:04 <dsal> So maybe nixos is good at what it does, but it's not good for building haskell software.
20:12:05 <DigitalKiwi> even before catalina nix wasn't a *great* experience on macos...which is why i switched to nixos
20:12:32 <Cale> nixos and nix are not the same thing
20:12:45 <dsal> Man, I just built a new computer.  I forgot to even try nixos.
20:13:03 <Cale> We use nix to build all our projects where I work, it's quite good for ensuring that everyone is running the same code
20:13:23 <monochrom> Roll back and build it again :)
20:13:40 <dsal> It's not like I actually like debian.
20:15:03 <dsal> Cale: Do you just not ever user shared machines and grant local users write access to /nix ?
20:16:03 <dsal> I guess I'm not too deep into this install to not scrape some stuff together and try again.  It's basically just emacs, xmonad, and a couple of keys.  And somewhere between debian and emacs 26, emacs is broken anyway.
20:17:22 <Cale> The nix daemon controls /nix on any machine with shared users
20:18:37 <Cale> I believe that's also the default configuration for nixos as well, but you can set up a non-nixos machine that way as well.
20:18:46 <monochrom> Does it mean that important nix commands talk to the nix daemon to get things installed?
20:19:03 <DigitalKiwi> https://github.com/input-output-hk/haskell.nix there's this thing now too which seems to work ok for some
20:19:07 <Cale> yeah
20:19:18 <Cale> Or to do anything which manipulates the nix store.
20:20:41 <Cale> Also, our CI server is set up to build all our repositories and to dump everything into a binary cache, which is nice. If some time has passed since someone pushed to the repo, everything will be binary cached already when I go to do a build.
20:21:13 * DigitalKiwi was trying to find a tweet about that from the other day...
20:22:47 <DigitalKiwi> found it
20:22:50 <DigitalKiwi> https://twitter.com/chris__martin/status/1247994655427313665?s=20
20:24:20 <Cale> We don't let everyone's machine write to the cache though, because there's a security concern with that.
20:28:30 <Cale> (it would make it so that if anyone is pwned, then everyone is pwned)
20:33:30 <jchia_> What's a good way to integrate the use of hpack package.yaml into the workflow for a project that uses new-style cabal? Can I do better than manually running hpack whenever I need to update the package.yaml? AFAIK, cabal does not recognize package.yaml. I find the syntax of package.yaml more ergonomic than cabal's special syntax.
21:42:00 <jgt> jchia_: from what I can glean in the community, package.yaml is generally frowned upon, and even those who originally championed it have since changed their tune
21:42:44 <jgt> the benefits of hpack to me are 1) common stanzas, and 2) not having to manually declare all the exposed modules
21:43:23 <dsal> package.yaml is awesome.  People seem to also suggest you check in the generated .cabal file.  I haven't been doing that.
21:43:39 <jgt> cabal has common stanzas now anyway, but I'm not sure about automatically determining exposed modules. I would have thought this should be possible, pehaps using some similar mechanism to hspec discover
21:43:47 <dsal> I guess it's kind of like licensing.  If someone cares, that's signal that I did something potentially useful and I'll respond favorably if it doesn't get in my way.
21:44:05 <MarcelineVQ> cabal has common stanzas so it's mostly the latter that's novel (automatic module inclusion), with variuos opinions on whether it's a good thing or not
21:44:31 <MarcelineVQ> oh you said that, guess I'm typin slow today :>
21:44:46 <jgt> ftr — I don't have much of a strong opinion with package.yaml vs package-name.cabal. It seems like a really minor thing to care about. I just want my stuff to work :)
21:44:50 <dsal> Checking in derived values is pretty gross for a variety of reasons.  It'd be nice if stuff unified fully.
21:45:19 <dsal> The theory, I believe, is .cabal works for everybody and hpack works for people with hpack.  I'm not entirely sure that's true, though.
21:45:50 <jgt> but since I don't have a strong opinion on it, I'd personally not use hpack because it seems like an uphill struggle, at least with getting everyone else to work with it
21:45:52 <MarcelineVQ> I don't make modules so frequently that it saves me time to have them included for me, especially since I want to decide how/where they're included
21:46:26 <jgt> MarcelineVQ: Yeah. Reminds me of this: https://xkcd.com/1205/
21:46:29 <MarcelineVQ> dsal: hpack is built into stack so there's some momentum there
21:46:58 <dsal> Yeah, I never really knew a pre-hpack world for anything interesting.
21:47:10 <sclv> please check in cabal files
21:47:27 <MarcelineVQ> ^
21:47:30 <sclv> a ton of us don’t use hpack and dont want to
21:48:10 <dsal> I can understand that, except that checking in derived data is gross. I don't want to deal with merge conflicts from things that I don't edit.
21:49:00 <sclv> you can reject prs that modify it directly
21:50:04 <dsal> If someone changes a dependency, it either updates the .cabal file, or the .cabal file is wrong.
21:50:49 <jgt> my opinion on checking in derived data has softened. I use cabal2nix, and I check in the generated Nix expression.
22:27:05 <sm[m]> If hpack stopped adding its version and a hash to the cabal file, it’d be much easier to commit cabal files without conflicts
22:27:26 <sm[m]> There’s an open issue needing upvotes/a patch
