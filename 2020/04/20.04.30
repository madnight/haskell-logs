00:16:57 <DigitalKiwi> i want a rcs that doesn't feel like work
00:17:53 <phadej> All of them will require you to think about what you want to do
00:18:31 <phadej> if you sole developer who just records changes once in a while - then anything will do - and is simple
00:18:56 <phadej> collaboration is when things are difficult & interesting
00:19:11 <DigitalKiwi> https://twitter.com/tpolecat/status/1253680554685468675?s=20
00:19:31 <DigitalKiwi>     commit all the things
00:19:51 <DigitalKiwi> when it's annoying to use that i end up with a lot of commit messages like that :|
00:20:55 <DigitalKiwi> currently has 11 modified files and last commit march 13th
00:21:11 <DigitalKiwi> guess what the next commit message will be :D
00:21:18 <phadej> "I should made backups"
00:21:34 <DigitalKiwi> :D
00:22:02 <DigitalKiwi> i do need to setup znapzend still yeah :(
00:22:05 <phadej> for many my personal projects, git + github is not much more than complicated backup schem
00:23:07 <phadej> (.gitignore is a must, to not backup all the build artificts, which are way bigger than the source code in Haskell)
00:23:54 <tdammers> say about git what you want, designing it from the data model up is paying off big time
00:24:20 <maralorn> Just the other day I found a python library that hat the amazing version control of hosting a repo on github which contained library-2017-04-17.py, library-2019-09-23.py, …
00:25:04 <tomjaguarpaw> Has anyone done a writeup somewhere of how to use randomly generated data for benchmarking?
00:25:16 <tomjaguarpaw> Some sort of QuickCheck and Criterion, for example.
00:25:39 <vilpan> imho, abusing a VCS as a backup system is a gross underestimate of its power. You should not use it to merely make a backup of your work in case the hard disk fails, you should use it as a tool to tell the story of the project's evolution in the most clear and coherent way, be it for your future self or your collaborators.
00:25:40 <vilpan> If you don't see any value in that, you might as well simply use a backup tool.
00:29:18 <phadej> In the first months of sole developer project? Nah. The commits are of he kind DigitalKiwi mentioned. "Try this" "Didn't work, try that"
00:29:23 <phadej> there are no story yet
00:29:53 <maralorn> I see the value in it everytime I hear my not git using boss saying to his colleague „can I continue working on the book or do you have the .tex files right now?“
00:30:20 <phadej> maralorn: there the keyword is collaboration
00:30:25 <maralorn> Worse is only: „Just do any commit so that I can trigger a CI run.“
00:30:45 <maralorn> phadej: Yeah, true.
00:34:53 <maralorn> To be fair: Even in starting sole developer projects I often wish that I had at least commited everything before I start the next large change so that I can compare my code with the last working version.
00:35:05 <vilpan> it's a matter of opinion/experience, but mine is - the story starts with the first line. There's no point in documenting all the failed experiments - those commits get directed to /dev/null never having reached the master branch. The point is to show the right way in the clearest possible terms using commits of appropriate size with related changes grouped, informative commit messages with metainfo on the patch, etc.
00:35:26 <timCF> Hi! Let's say I have expression `($ req) <$> laws` which applies laws to request. Then I implemented one more argument in laws, context. And expression became a bit ugly `(\x -> x req ctx) <$> laws`. Also this worked for me as well `($ ctx) . ($ req) <$> laws` but still not beautiful. Can it be better/shorter somehow? Does Haskell have something
00:35:27 <timCF> like `$` but with signature `(a -> b -> c) -> a -> b -> c`?
00:36:38 <tdammers> my stance is that commits are cheap; if you want to add a narrative after the fact, you can usually rebase
00:37:35 <vilpan> sure, I often save intermediate states in a local branch and whip the history into proper shape when preparing for the merge
00:39:58 <vilpan> btw, as we're on the subject, I've been curious for a while what's the opinion of haskellers on Darcs? I see some features are missing compared to git, but on the other hand git has many features I don't use. Is Darcs a suitable tools for everyday work or is it still more of an experiment and only useful in limited cases?
00:40:48 <tdammers> AFAICT the problem with darcs is that it failed to gain sufficient traction
00:44:38 <vilpan> so it's doing well on the "Avoid success at all costs" front. :) Not sure that's as desirable for a VCS as compared to a programming language.
00:46:33 <maralorn> timCF: I can‘t think of any.
00:47:17 <timCF> Ok) Not big issue anyway)
00:47:46 <tomjaguarpaw> timCF: If it's an Applicative you can do `laws <*> pure req <*> pure ctx`
00:49:30 <maralorn> Or, you could curry it.^^ But that would hardly be nicer …
00:49:58 <timCF> wow, applicative thing look cool!
00:50:13 <timCF> thanks tomjaguarpaw
00:51:17 <tomjaguarpaw> timCF: Even better, perhaps, you can define `f ?? a = fmap ($ a) f` and then do `laws ?? req ?? ctx`.  This function is defined at various places in the ecosystem: https://www.stackage.org/lts-13.21/hoogle?q=f%20(a%20-%3E%20b)%20-%3E%20a%20-%3E%20f%20b
00:58:31 <tdammers> vilpan: problem with "avoid (success at all cost)" is that it often ends up as "avoid success entirely".
01:14:55 <vilpan> tdammers: depends on the definition of success. I would say success is when a project serves a purpose to its user base (however small that may be) and has the community to support it as long as there is a need for it. I don't consider world domination, i.e. reaching the top by popularity, the goal/criteria for success.
01:19:24 <phadej> But right now only darcs itself uses darcs? :) (and hmm `transformers` ?)
01:20:35 <alp> GHC used to: https://gitlab.haskell.org/ghc/ghc/-/wikis/darcs-evaluation
01:20:42 <srk> phadej: hehe, got bitten by this trying to use darcs to clone vervis but darcs was broken until recently and to clone darcs you need darcs :D
01:21:02 <srk> (broken on ghc883)
01:21:26 <peutri> darcs was more of a "personal projects" thing
01:21:54 <peutri> I know a few non-Haskellers who used it as such before git became unavoidable
01:23:49 <vilpan> right, I got the impression it's not very popular, to put it mildly. But that might be because the majority of people are simply "going with the flow" - using what they already have experience with or whatever popular hosting platforms offer. That's why I'm wondering what's the status from a technical PoV - is it usable in practice. If it's a simple, robust tool with some interesting ideas, I'm interested despite the fact it's likely to
01:23:49 <vilpan>  remain niche. However, if there's no one to maintain it, it's probably not worth trying.
01:25:18 <peutri> very subjective tradeoff :)
01:26:19 <phadej> darcs as project is alive
01:26:43 <phadej> and more active then pijul
01:27:04 <phadej> but my understanding is that pijul "theory part" is more solid than darcs'
01:27:12 <phadej> whether that matters in practice - I have no idea
01:31:04 <__monty__> Hmm, didn't Edward Yang work on Backpack? The draft of the paper I have listed him as an author but the more recent version doesn't.
01:32:27 <vilpan> phadej: ah, didn't know about pijul - thanks for the pointer!
01:32:55 <MarcelineVQ> __monty__: yes
01:33:11 <__monty__> Darcs is more active than Pijul?
01:33:28 <__monty__> Do you mean the efforts towards "Darcs 2?" Or have those stalled?
01:34:09 <__monty__> MarcelineVQ: Hmm, curious, guess I'll have to go digging to see whether there's a version of the full paper that does credit him.
01:37:11 <phadej> __monty__: I don't know what you mean by Darcs 2 as the current version seems to be 2.14.4
01:42:31 <merijn> vilpan: pijul is slated for their 1.0 beta release "any moment now", afaik
01:42:47 <merijn> peutri: Git is still avoidable ;)
01:43:49 <peutri> you know what i meant :p
01:43:50 <phadej> yet I don't find it nice that 1.0 beta release is prepared in opposite-of-open process
01:44:34 <phadej> i.e. I suspect there will be "I rewrote everything" mega-patch
01:44:40 <phadej> which is ironic for VCS :)
01:45:21 <merijn> peutri: No, I'm serious. I've been collaborating with git using colleagues and github for the past 6 years without touching git more than, say, 10 times and even then only to deal git repos using subrepos :p
01:45:27 <maerwald> merijn: you really using that?
01:45:40 <merijn> maerwald: What? pijul?
01:45:43 <maerwald> yes
01:46:02 <merijn> maerwald: No, but I'm closely following it and if the 1.0 version works well I might start
01:46:06 <maerwald> I tried to write a gtk gui for it. But the API is impossible to understand.
01:46:15 <peutri> merijn: I'm not thinking you're not serious, I'm just saying "unavoidable" as in "everybody knows it's there"
01:49:11 <merijn> Mercurial is a much nicer git UI than git, but still suffers from the broken DAG abstraction. Patches would be much nicer
01:50:59 <tobiasBora> Hello, I have a structure, say a list like [1,5,2,5,3,1], and I usually need to know what is the "support" of that list, i.e. the set of all the element in that list. Of course, I could do Set.fromList mylist everytime I would need it, but it will be pretty ineficient in practice because I need this info in most functions. Another idea would be to compute it once, and then pass it through the second argument
01:51:02 <tobiasBora> of the function, but it's a bit hard to maintain... I could also change my data type into a record, and when I initialize the list, I compute directly this value. Is there any other elegant way to proceed?
01:51:44 <phadej> patches are nice, and maybe would make average joe to think how they record their changes (e.g. avoid "fix previous" commits) - or maybe it will be just as bad - but even worse
01:52:31 <phadej> tobiasBora: opaque record with an accessor for lazy set field and with strict list field is common-enough pattern
01:52:50 <phadej> (i.e. actually using lazyness to compute something at most once)
01:52:53 <vilpan> merijn: so are you using darcs to avoid git? I've been using git-svn to avoid SVN, which is workable, but limiting. I wonder how git avoidance works for you :)
01:52:57 <[exa]> tobiasBora: so you want a data structure that acts as a bag for numbers, which can quickly report what numbers are used at any time?
01:53:09 <maerwald> merijn: I don't think the concept will ever fly. A patch in pijul isn't a *diff*. The user has to understand that. And that also makes it actually very hard to programmatically get a *diff* from a patch.
01:53:23 <merijn> vilpan: I'm using mercurial + hg-git which does a bidirectional conversion
01:53:45 <merijn> vilpan: Now that Mercurial's python3 mess is sorted they're working on builtin git support too
01:53:59 <tobiasBora> phadej: what do you call *opaque* record?
01:54:00 <maerwald> As a user, I care about *diffs* most of the time. So, conceptually, mercurial is the right choice of abstraction.
01:54:03 <[exa]> maerwald: what's the actual "patch" format then?
01:54:08 <phadej> tobiasBora: which constructor is not exported
01:54:18 <merijn> maerwald: As a user diffs get in the way A LOT for me >.>
01:54:20 <maerwald> [exa]: check the source code ;)
01:54:34 <[exa]> maerwald: I hoped to avoid that :]
01:54:40 <phadej> read the paepr
01:54:44 <tobiasBora> [exa]: kind of, but my structure is slightly more complicated (it's a list of sets)
01:55:06 <phadej> https://arxiv.org/abs/1311.3903
01:55:08 <tdammers> patch / diff format is an unsolvable problem in practice
01:55:18 <tdammers> at least as long as we stick with a textual representation
01:55:34 <phadej> pijul's patch isn't textual
01:55:41 <phadej> wire format is some binary blob (of something)
01:55:55 <tdammers> no, I mean the representation of the source code itself
01:56:21 <tdammers> we manipulate syntax trees, but the SCM only ever gets to see their serialized form
01:56:24 <maerwald> https://nest.pijul.com/pijul_org/pijul:master/662ad86eb85d3b203b01#GDrQkKziFVy
01:56:37 <phadej> yes, I guess pijul works with "lines in text file"
01:56:39 <merijn> maerwald: The problem with DAGs is that they inherently make the user care about the order of commits. If you look at any major open source project, they don't want to review branches, they want to review patches/patch sets (just look at GHC!)
01:57:07 <tdammers> and it has to be able to handle any textual serialization format from an open universe
01:57:12 <maerwald> pub changes: Vec<Change<ChangeContext<Hash>>>
01:57:13 <maerwald> and then check the Change data type
01:57:27 <merijn> maerwald: github's shitty PR UI doesn't help either
01:57:38 <maerwald> github is trash overall :)
01:57:47 <merijn> If I have 5 independent commits fixing issues and want to PR them independently that's super annoying to do in git
01:58:19 <merijn> I'd have to move every fix into a separate branch, which is annoying to work with, since you usually need all of them together locally to be able to work
01:59:06 <maerwald> what matters in the end is tooling
01:59:08 <maerwald> not the concepts
01:59:18 <maerwald> if the tooling is well enough, it can compensate for shitty concepts
01:59:40 <maerwald> and pijul API is too hard for drive-by contributors
02:00:13 <maerwald> afair, thet's actually the reason facebook switched to mercurial, because it was easier to develop tools against
02:00:16 <merijn> maerwald: git's tooling definitely can't compensate for the conceptual flaws :p
02:01:44 <phadej> maerwald: do you mean the Rust library api as "pijul API". I wouldn't say that internals of git are "easy" either.
02:01:57 <maerwald> phadej: yes
02:02:16 <maerwald> phadej: the core concepts of git (even the low level ones) aren't really difficult to understand
02:02:23 <maerwald> it's just hardcore C code, but yeah
02:02:59 <phadej> I boldly claim that pijul's vs. git concepts are abit of "understanding Haskell vs C"
02:03:07 <phadej> i.e. "it's not what you expect, thus difficult"
02:03:13 <phadej> but not difficult "in absolute" matter
02:03:26 <maerwald> phadej: well, I specifically mean the API as well :)
02:03:29 <maerwald> not just the concept
02:03:47 <phadej> that I cannot comment on
02:04:00 <maerwald> I gave up after a few days, because it's just utterly confusing.
02:04:11 <maerwald> But then again, it's an early project
02:04:25 <phadej> I guess libpijul is developed primarily to make pijul executable and the web stuff, and not much thought is given beyond that
02:04:32 <maerwald> Possibly
02:04:33 <phadej> indeed. It's an early project.
02:04:40 <maerwald> And it doesn't help that the nest is proprietary
02:04:50 <maerwald> (the web interface)
02:04:56 <tomjaguarpaw> }
02:05:07 <maerwald> Which would probably have useful insights on how to e.g. generate diffs
02:07:00 <siraben> Has anyone worked on Haskell running on Android/iOS for app development?
02:07:47 <merijn> siraben: I know >1 people have
02:08:00 <merijn> So yes, but don't ask me how ;)
02:08:02 <phadej> I already implied that I'm not 100% happy with how pijul development looks to the outside, I guess you could add nest being closed-source to that too
02:08:19 <tobiasBora> phadej: ok thank you!
02:08:33 <phadej> yet, GitHub is closed source too
02:08:42 <phadej> and GitLab effectively propriertrary too
02:08:44 <phadej> so...
02:08:44 <siraben> merijn: Ah, nice. I just found a list of people on Haskell wiki https://wiki.haskell.org/IPhone
02:09:13 <phadej> last edited 2016...
02:09:19 <merijn> siraben: I think Cale worked on that, at least in the past
02:09:25 <siraben> Outdated, yeah.
02:10:01 <siraben> Would the Haskell → WASM → App route be impractical?
02:10:01 <phadej> iohk haskell.nix has suff for cross-compilation, and obsidian systems obelisk has more nixpkgs approach to that
02:10:08 <phadej> both involve using Nix
02:10:11 <merijn> siraben: Not yet, at least not via GHC
02:11:27 <siraben> Ooh, https://keera.co.uk/blog/2017/06/01/haskell-android-ios/
02:12:02 <maerwald> phadej: that's why I use gitea ;)
02:12:19 <maerwald> And it's way easier to self-host than gitlab
02:13:09 <[exa]> +1 for gitea
02:13:43 <[exa]> the whole hosting procedure is basically: ./gitea
02:14:02 <merijn> I should look into fossil again :)
02:14:14 <merijn> That's open source and handles issues too :p
02:19:38 <tdammers> hosting gitlab is a terrible terrible experience
02:19:57 <merijn> tdammers: well, duh, else why would anyone pay them? ;)
02:20:20 <tdammers> I guess...
02:21:40 <phadej> that's I guess why I don't make OSS web-sites
02:21:46 <phadej> it's just pointless
02:22:56 <maerwald> tdammers: updating it is fun yeah
02:24:52 <tomjaguarpaw> Does anyone use criterion for "here's a graph that shows that this algorithm is O(N^k) in the input size"?  The tutorial seems to suggest you just manually choose a few input sizes and don't compare run time between them.
02:25:58 <tomjaguarpaw> If criterion is not for that, is there a Haskell library that is+
02:30:45 * hackage manifolds-core 0.5.1.0 - The basic classes for the manifolds hierarchy.  https://hackage.haskell.org/package/manifolds-core-0.5.1.0 (leftaroundabout)
02:31:45 * hackage linearmap-category 0.4.0.1 - Native, complete, matrix-free linear algebra.  https://hackage.haskell.org/package/linearmap-category-0.4.0.1 (leftaroundabout)
02:38:26 <lambdabuddy> I am reading about Functor for functions and found out that Control.Monad.Instances is deprecated. Why is that? I mean has it been moved somewhere else?
02:39:44 * hackage manifolds 0.5.1.0 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.5.1.0 (leftaroundabout)
02:40:45 * hackage manifold-random 0.5.1.0 - Sampling random points on general manifolds.  https://hackage.haskell.org/package/manifold-random-0.5.1.0 (leftaroundabout)
02:42:42 <merijn> lambdabuddy: It says at the top that that module doesn't actualy contain any instances any more
02:43:14 <merijn> lambdabuddy: So anything in there is define elsewhere and reexported
02:43:46 <merijn> lambdabuddy: "instance Monad ((->) r)" seems to be defined in GHC.Base, for example
03:03:35 <tobiasBora> Hello,
03:03:52 <tobiasBora> I'd like to create a strict type, does it makes sense to write "type Mytype = !Int"?
03:04:30 <merijn> tobiasBora: "type" doesn't create a type, so no
03:04:30 <tobiasBora> Or do I really need to use "newtype Mytype = Mytype !Int"?
03:04:41 <merijn> tobiasBora: That doesn't work either
03:04:47 <tobiasBora> really?
03:05:02 <merijn> tobiasBora: Strictness annotations on newtype's don't work, because newtypes don't exist at runtiume
03:05:26 <tobiasBora> so I need "data Mytype = Mytype !Int"?
03:05:51 <tobiasBora> (and have pattern maching everywhere)
03:05:58 <merijn> tobiasBora: Yes, but that probably doesn't do what you want anyway, so also no
03:06:27 * tobiasBora wonders why on hearth somebody wanted to write a lazy language by default
03:06:40 <phadej> because there weren't any
03:06:56 <phadej> (except propritrary miranda)
03:06:57 <merijn> tobiasBora: What is your actual problem?
03:07:52 <tobiasBora> merijn: So basically, I'm writting a program that should do heavy computations, but that do not care about undefined stuff, and therefore I don't see the point of lazyness
03:08:49 <tobiasBora> so I wanted to define my usual type strict, to make sure that when I sum two elements for example it does not produce a thunk
03:08:56 <merijn> tobiasBora: "make everything strict" is generally a bad solution, instead just make the core computation strict (and this is often more about functions, rather than datatypes)
03:10:11 <tobiasBora> merijn: I don't understand why it's a bad solution... Most language do that already no? Do you have a non pathological example of usecase for lazyness in my setting?
03:10:49 <tobiasBora> merijn: and when you say "make the core computation strict", you mean that I should put "f !a !b" everywhere?
03:11:25 <merijn> tobiasBora: "Making everything strict" in haskell will lead to lots of unnecessary overhead since libraries are written to assume that
03:11:45 <merijn> tobiasBora: Honestly, I'd say you should not put ! or strictness *anywhere* until you profile and show that there's an issue
03:12:04 <merijn> GHC is pretty good at recognising arithmetic code and making it strict
03:14:00 <tobiasBora> merijn: I thought GHC was not able to optimize a simple "foldl (+) 0 [1..1000000]"
03:16:54 <[exa]> tobiasBora: you might want to have a look at repa or similar packages that handle the strictness stuff very well
03:17:39 <tobiasBora> [exa]: I also read some things about -Xstrict. Is that what merijn you advise not to use?
03:19:24 <merijn> tobiasBora: "It Depends"
03:19:26 <tobiasBora> [exa]: and repa seems to be for array, can you find something similar for sets?
03:19:32 <[exa]> tobiasBora: it's good to avoid strictness until you explicitly know you need it from profiling. But I guess unless your usecase is super-intensive, a few exclamations in data definitions will do that.
03:19:59 <merijn> tobiasBora: tbh, I would not be surprised if "foldl (+) 0 [1..100000]" gets optimised fine if you add an Int annotation
03:20:01 <[exa]> tobiasBora: what exact algorithm are you going to implement? (there are many ways to represent sets)
03:21:49 <tobiasBora> [exa]: I want to play with sat solvers, so several algorithms around sat solving. I don't want to reach perfect optimized code, but I don't want to have a code that uses 1go of memory instead of 1M
03:22:22 <merijn> Will you need to add manual strictness in some places to squeeze out the best performance? Sure. Will haphazardly making everything everywhere strict solve performance issues? No, in fact, that's about as likely to make things worse as it is to make things better
03:22:45 * tobiasBora needs to go, and will be back in ~1h. Thanks a lot already for the help
03:23:20 <[exa]> tobiasBora: if that's for 'subsets of all variables' I'd go with bit arrays :]
03:23:40 <[exa]> depending ofc on variable count
03:28:44 <__monty__> phadej: Oh, you're right. I was referring to the hypothetical Darcs 3: http://darcs.net/Theory#future-darcs-3--
03:29:45 * hackage language-puppet 1.4.6.3 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.6.3 (pi3r)
03:30:44 * hackage cardano-coin-selection 1.0.0 - Algorithms for coin selection and fee balancing.  https://hackage.haskell.org/package/cardano-coin-selection-1.0.0 (JonathanKnowles)
03:46:52 <GasparVardanyan> Hi! Sorry for a nubic question, but I can't figure out how to install pandoc via cabal. I use this command: "cabal install pandoc --user" and have a huge list of errors:
03:47:13 <GasparVardanyan> Configuring library for HsYAML-0.2.1.0..
03:47:13 <GasparVardanyan> Preprocessing library for HsYAML-0.2.1.0..
03:47:13 <GasparVardanyan> Building library for HsYAML-0.2.1.0..
03:47:13 <GasparVardanyan> [ 1 of 14] Compiling Data.DList       ( src/Data/DList.hs, dist/build/Data/DList.o )
03:47:16 <GasparVardanyan> src/Data/DList.hs:8:8: error:
03:47:18 <GasparVardanyan>     Could not find module ‘Prelude’
03:47:21 <GasparVardanyan>     There are files missing in the ‘base-4.13.0.0’ package,
03:47:23 <GasparVardanyan>     try running 'ghc-pkg check'.
03:47:25 <__monty__> GasparVardanyan: Please use a pastebin.
03:47:26 <GasparVardanyan>     Use -v (or `:set -v` in ghci) to see a list of the files searched for.
03:47:28 <GasparVardanyan>   |
03:47:31 <GasparVardanyan> 8 | module Data.DList
03:47:32 <__monty__> @paste
03:47:32 <lambdabot> Haskell pastebin: http://lpaste.net/
03:47:33 <GasparVardanyan>   |        ^^^^^^^^^^
03:47:36 <GasparVardanyan> Failed to build SHA-1.6.4.4.
03:47:53 <GasparVardanyan> Ok, I'll try it. Thank you )
03:48:04 <__monty__> Uhm, sorry, lpaste.net may not be ideal anymore.
03:48:25 <__monty__> There's many pastebins though, bpaste.net for instance.
03:48:31 <__monty__> Or a github gist.
03:48:44 <GasparVardanyan> Can u help me to install pandoc?
03:48:55 <merijn> rch?
03:48:57 <__monty__> GasparVardanyan: Are you sure you want to install it with cabal? (Consider joining the #pandoc channel.)
03:48:58 <merijn> eh, Arch?
03:49:07 <tdammers> files missing in the base package hints at a broken ghc install
03:49:55 <GasparVardanyan> I use ArchLinux and I've installed the ghc and ghc-libs packages via pacman.
03:50:12 <nil> why not install pandoc via pacman?
03:50:54 <merijn> GasparVardanyan: The GHC installed by Arch's packages is broken and can't be used to compile your own things via cabal-install
03:50:55 <GasparVardanyan> I have 8GB root partition and want to install pandoc in the home partition (32G)
03:51:19 <maerwald> use ghcup, it works well on arch
03:51:27 <MarcelineVQ> given the choice I'd install the pandoc bins from the AUR
03:51:46 <maerwald> MarcelineVQ: binaries from AUR? ouch
03:51:57 <maerwald> who knows what they contain :)
03:52:27 <merijn> maerwald: How's that any different from running "cabal install"? :p
03:52:40 <__monty__> maerwald: Could also get the binaries from nixpkgs ; )
03:52:40 <MarcelineVQ> 144 libs totalling 750mb of system installed hs libs just to get pandoc isn't a barrel of fun either
03:52:44 <maerwald> merijn: you get backdoors compiled from source
03:52:52 <maerwald> much nicer
03:53:00 <merijn> maerwald: Ah, you're an ex-gentoo user? ;)
03:53:04 <maerwald> yes.
03:53:30 <GasparVardanyan> I have a secondary user namde terminator (:D) use any proprietary garbage via that user (like Zoom), so it's ok for me to use pandoc-bin from AUR )
03:53:58 <scasc> .
03:54:09 <merijn> GasparVardanyan: But yeah, on Arch I'd advice using ghcup (or manually installed GHC dist), rather than using the pacman GHC
03:54:30 <GasparVardanyan> Ok, I'll try ghcup now.
03:55:18 <MarcelineVQ> I also second using ghcup if you want ghc. but if you don't use it you'll at least need ghc-static if you don't have it yet and are using pacman installed ghc
03:56:53 <GasparVardanyan> I've uninstalled ghc and ghc-libs and now I'm trying to use ghcup (I want to keep my root partition lighter).
03:57:06 <maerwald> yes, ghcup installs into $HOME/.ghcup
04:01:26 <GasparVardanyan> ghcup install, ghcup install-cabal, cabal install pandoc --user ?
04:16:15 * hackage cobot 0.1.1.4 - Computational biology toolkit to collaborate with researchers in constructive protein engineering  https://hackage.haskell.org/package/cobot-0.1.1.4 (ozzzzz)
04:42:31 <freeman42x[m]> I installed HIE using stack commands here: https://github.com/haskell/haskell-ide-engine#install-specific-ghc-version How can I completely remove what it added during the installation?
04:57:49 <fendor> freeman42x[m], delete ~/.local/bin/hie*, if you generated a hoogle database, delete it at ~/.hoogle
04:59:03 <freeman42x[m]> fendor: I did not do anything to generate a google DB so I assume I... did not?
04:59:22 <fendor> I cant recall if it does that by default now...
05:00:05 <fendor> so, you may just delete it and regenerate it if you need it in your everyday workflow. Or not, it is just a hoogle db generated by `hoogle generate`
05:05:07 <freeman42x[m]> fendor: got it, thank you! @karma+ fendor
05:05:35 <freeman42x[m]> fendor: @karma+ fendor , got it, thank you!
05:05:40 <fendor> and obviously delete the repo of hie
05:05:55 <freeman42x[m]> is the karama functionality broken or something?
05:06:06 <fendor> your local copy that is
05:06:10 <fendor> @karma+ freeman42x[m] 
05:06:10 <lambdabot> freeman42x[m]'s karma raised to 1.
05:06:30 <fendor> needs to be first part of the message iirc
05:06:30 <freeman42x[m]> @karma+ fendor
05:06:31 <lambdabot> fendor's karma raised to 1.
05:07:04 <freeman42x[m]> oh, I see. But then why 2nd time I tried did not work?
05:07:16 <fendor> you still mentioned me before the command :)
05:07:29 <freeman42x[m]> aaaaaa
05:08:59 <freeman42x[m]> @karma+ fendor , testing testing
05:08:59 <lambdabot> fendor's karma raised to 2.
05:19:48 <freeman42x[m]> fendor: if I run that stack installation of HIE it will run faster cause of caches?
05:21:49 <fendor> freeman42x[m], idk, iirc stack only caches what you have built locally with the same ghc version. So, if you built many of the dependencies before then yes. Same applies for cabal-install
05:22:22 <freeman42x[m]> fendor: cool, ty. I am pretty sure it will be faster based on that
05:22:40 <freeman42x[m]> I want to try using HIE under WSL for now
05:31:45 <jonathan_> I have an app where I use physical units of measure. Since I want to code correctly, I'd like to add type security using dimensional analysis of my formulas. I've been looking around, and the two libraries I've found that seems promising is one called "units" and one called "dimensional". I think I prefer the "dimensional" one, since it has more dls and seem to be a bit easier on the custom operators.
05:32:24 <jonathan_> Have anyone used either? I have two needs that I'm not sure whether they can handle:
05:32:58 <jonathan_> 1. custom units, added during runtime (not custom dimensions, dimensions should be compile time) 
05:35:30 <jonathan_> 2. I do work on calculating carbon emissions, and use a custom type of units defined as kilograms of co2 equivalents, or kgco2e. While it may seem like a weight dimension, in reality it's a measure of the impact of a GHG
05:36:02 <jonathan_> So I'd like to be able to define that as a custom dimension to use in my compile time dimensional analysis
05:36:05 <jonathan_> any ideas?
05:37:22 <jonathan_> (The KGCO2e is industry standard btw, but I can't find it in either of the packages)
05:38:55 <tdammers> dimensional absolutely cannot do that. its unit representation has the SI dimensions hard-coded into the type
05:39:21 <tdammers> or rather its dimension representation
05:39:28 <tdammers> it's essentially a tuple of exponents
05:42:29 <jonathan_> bummer
05:42:41 <jonathan_> I guess I'll look into units
05:43:02 <tobiasBora> merijn: I am back! Hum... So I have two questions: 1) if full strictness is bad, how can I know if I should put manually strictness or not at a given position? I'd be tempted to put strictness everywhere after...
05:43:07 <jonathan_> (absolutely can't do nr 1, 2 or both?)
05:46:04 <tobiasBora> merijn: and 2) do you have an example where forcing strictness in all my functions can produce a bad result?
05:46:11 <merijn> tobiasBora: You use profiling to see which part of the code is slow/uses much memory
05:47:18 <tobiasBora> merijn: I see. So you think I should code without putting any !, and then at the end see what's inneficient?
05:47:36 <cdunklau> tobiasBora: say you have an algorithm that usually only needs to do 50 things, but in the worst case might need to do 50000 things
05:48:03 <cdunklau> tobiasBora: if you make it strict, it might have to do 50000 things *every time*
05:49:19 <cdunklau> and overall, worrying about performance is a futile exercise until you 1) actually have a real performance problem, and 2) measure to find out what the cause is
05:49:57 <cdunklau> tobiasBora: ideally, you don't even do the check to see if its inefficient
05:50:13 <cdunklau> you just run it, and if it's fast enough, you're done optimizing, enjoy your beer
05:52:21 <tobiasBora> cdunklau: I agree that optimizing too much is not a good idea until you have the need, but in some case (like mine), I want to compute things "as big" as possible. And if I try and I see "how this problems takes 1h to run on my computer", I'd like to know if it's really because it's long to run, or if it's because of a stupid lazyness issue
05:53:41 <tobiasBora> and that's why I'm a bit surprised that there is no generic recipe to know when to force strictness or not.
05:53:54 <cdunklau> tobiasBora: i don't see how that's at all different than "run it, check if it's fast enough"
05:54:00 <tobiasBora> but I'll try to play with the profiling after writting my code
05:54:23 <cdunklau> tobiasBora: if you ran it, and it's too slow, then you move on to step 2: measure
05:54:28 <cdunklau> like, with a profiler
05:54:46 <tobiasBora> cdunklau: I don't know in advance what it means for my problem to be fast enough.
05:54:48 <cdunklau> otherwise you're just guessing where the problem is, and humans reaaaaaaly suck at that kind of intuition
05:55:03 <cdunklau> tobiasBora: so make a decision. KPIs, whatever
05:55:38 <merijn> Bikeshedding poll: https://gitlab.haskell.org/ghc/ghc/issues/18117
05:55:39 <cdunklau> tobiasBora: "fast enough" cannot be an abstract trait. 
05:55:57 <cdunklau> it *must* be qualified by some concrete situation
05:56:33 <cdunklau> that is, you can't say Haskell is faster or slower than e.g. Python, or C
05:56:59 <tobiasBora> cdunklau: when you write a program for users, sure. When you write a program just to see how far you can go... It's not clear. If I tell you that my program evaluates "f 15" in 30mn, is it fast or not?
05:57:01 <cdunklau> you can only compare specific implementations of things that solve the same problem, with the same input conditions
05:57:31 <cdunklau> tobiasBora: that's a decision you must make.
05:58:41 <cdunklau> whether it's by an arbitrary "i pick 15 seconds" thing, or some heuristic based on reasonable experience, or you just ask someone else, there must be some baseline or you're just waffling and wasting time
05:58:47 <tobiasBora> cdunklau: I came to haskell because I was too lazy to code in C, and few % of leaks is not a problem. Just affraid to have a stupid error in my code and not even being able to say if it's normal or not. Anyway, I'll just try and see!
06:01:11 <tobiasBora> cdunklau: I find it frustrating to be forced to ask other persons if my benchmark makes sense or not... and I'm surprised that no tool exists to tell you "it seems you have a lazyness issue in that function". But anyway, I'll just play and see, thanks!
06:03:00 <tdammers> benchmarking is hard
06:03:11 <tdammers> and yes, it's even harder in a language as high-level as haskell
06:05:20 <sm[m]> peutri, darcs is more than a "personal project", eg it was the VCS of GHC for many years. vilpan, darcs is indeed good enough for production use assuming you don't need git-level efficiency and tooling. https://hub.darcs.net has some people using it. scasc, pijul has been not production ready for a long time, the next release might change that.
06:06:45 <peutri> sm[m]: I'm aware of that. I was merely describing my feeling of a general trend.
06:09:29 <sm[m]> niche tool might be more accurate
06:09:48 <peutri> but less "descriptive"
06:12:06 <Nolrai> When I try to sample an rvar in Gen (from quick check) it seems to hang and then say thread blocked indefinitely in an MVar operation.
06:12:29 <Nolrai> Which seems really strange.
06:18:37 <sm[m]> @paste is cool..
06:18:37 <lambdabot> Haskell pastebin: http://lpaste.net/
06:20:02 <sm[m]> ..but perhaps it needs a little more explanation for a beginner, like "please use a pastebin to share examples, eg: http://lpaste.net"
06:20:35 <sm[m]> also, is the lpaste maintainer here ? that url gives me a login form which is .. kind of useless
06:21:24 <peutri> so you need a slack account to have an lpaste account
06:21:28 <sm[m]> any other ideas for a paste site with good UX ?
06:22:08 <ski> <lpaste.net> hasn't been functioning, for some time
06:22:08 <sm[m]> I use http://hastebin.com but it's not 100% reliable and maybe not beginner friendly. gist.github.com is a bit heavy and requires a github login.
06:23:23 <sm[m]> who's a lambdabot op, that could update @paste ?
06:35:42 <merijn> Right, so back to yesterday's problem: How do I specify a multi flag -with-rtsopts in cabal?
06:35:53 <merijn> (in ghc-options, that is)
06:37:18 <fendor> merijn, doesnt "-with-rtsopts=..." work?
06:37:46 <merijn> No
06:37:54 <fendor> ok :( 
06:39:40 <merijn> Looks like I need to do: "-with-rtsopts=\"-p -l-au\""
06:39:45 <merijn> Which is ugly as sin >.>
06:39:51 <peutri> yuck :)
06:42:28 <merijn> I take it back
06:42:31 <merijn> That doesn't work either
06:45:09 <phadej> iircghc-options: "-with-rtsopts=-I0 -qg"
06:45:16 <phadej> ghc-options: "-with-rtsopts=-I0 -qg"
06:45:21 <phadej> https://github.com/haskell/cabal/issues/4818
06:45:36 <merijn> Nope
06:45:54 <merijn> At least, when I do that things don't work that work with explicit flags
06:46:04 <merijn> I suppose it could be a bug in -with-rtsopts too
06:46:25 <phadej> you mean, +RTS doesn't work?
06:46:50 <merijn> phadej: I mean that manually using "+RTS -p -l-au" works, but "-with-rtsopts=-p -l-au" does not
06:46:59 <merijn> At least, when I pass that via cabal
06:47:37 <phadej> check -v2 output, what arguments GHC is invoked with
06:47:44 * hackage hasql-th 0.4.0.7 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.7 (NikitaVolkov)
06:49:09 * gentauro (offtopic) tdammers: and merijn didn't we briefly speak about color blindness here? I just ran (randomly) into this blogpost -> https://www.alanzucconi.com/2015/12/16/color-blindness/
06:49:17 <merijn> hmm, the final GHC shows -with-rtsopts=-qg -p -l-au'
06:49:27 <merijn> eh, add a mising ' up front
06:50:13 <merijn> So maybe GHC is fucking up?
06:50:46 <phadej> try without cabal :)
06:51:18 <merijn> phadej: Easier said then done >.>
07:00:33 <Nolrai> @pl \ x y -> f (g x y)
07:00:33 <lambdabot> (f .) . g
07:01:00 <merijn> phadej: hmm at first glance it looks like manual GHC does the right thing
07:01:22 <merijn> ghc -prof -fprof-auto -Wall -rtsopts -threaded '-with-rtsopts=-p -l-au' test.hs
07:01:25 <phadej> what "-p -l-au" should do?
07:01:52 <merijn> If I run "./test +RTS --info" I see ("Flag -with-rtsopts", "-p -l-au") as expected
07:02:00 <merijn> phadej: mpickering's speedscope profiling stuff
07:02:04 <frdg> I don't understand how you can have a monad that is not a functor, but you can have an applicative that isn't a functor.
07:02:12 <phadej> frdg: you cannot
07:02:25 <phadej> merijn: do you pass `--enable-profiling` to cabal?
07:02:37 <phadej> and `ghc-options: -rtsopts -threaded" ?
07:02:44 <frdg> sorry I meant can't have an applicative that isn't a functor. Does your point still stand Phadej
07:02:44 * hackage haskoin-store 0.23.7 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.7 (jprupp)
07:02:47 <merijn> phadej: I have "profiling: True" in cabal.project and yes, I do
07:02:59 <phadej> ok, weird.
07:03:18 <phadej> do I  ned ghc-8.10 or is ghc-8.8 have that aready
07:03:35 <merijn> 8.10
07:03:49 <merijn> I have the following fields:
07:03:50 <merijn>   GHC-Options:          -rtsopts -threaded -with-rtsopts=-qg
07:03:50 <merijn>   GHC-Prof-Options:     -fprof-auto "-with-rtsopts=-qg -p -l-au"
07:04:02 <merijn> So, lemme try without th -with-rtsopts from GHC-options
07:04:53 <merijn> Interesting
07:05:10 <phadej> I wonder in which order those are concatenated
07:05:20 <phadej> (both `-with-rtsopts` will be ther)
07:05:56 <merijn> phadej: The right order, because the actual result was way weirder (it reported only "-l-au" as rtsopts)
07:06:19 <merijn> But removing the with-rtsopts from ghc-options showed the right result...
07:06:23 <merijn> The mystery deepens
07:06:38 <phadej> try test with -with-rtsopts=-qg "-with-rtsopts=-qg -p -l-au"
07:06:56 <merijn> And now that I add it back it still produces the right result...
07:07:31 <merijn> Something's fucky...
07:08:48 <merijn> I wonder if the problem is in cabal's recompilation logic
07:08:53 <phadej> cabal does rebuild and relink in between?
07:09:08 <phadej> it's highly likely
07:09:14 <merijn> phadej: I made sure it relinked, yes
07:09:29 <phadej> especially that it links wrong parts with enabling disabling profiling
07:09:40 <phadej> I wouldn't say that is much exercised path
07:09:45 <phadej> codepath*
07:09:47 <merijn> But yesterday evening I tried "-with-rtsopts=-p -with-rtsopts=-l-au"
07:09:56 <merijn> Before learning that -with-rtsopts clobbered
07:10:14 <phadej> ghc-options: -with-rtsopts=-p -with-rtsopts=-l-au
07:10:16 <phadej> should work the same
07:10:18 <merijn> If it accidentally relinked that one it'd explain the confusing "only half rtsopts" result
07:10:39 <merijn> phadej: No, that will only produce "-l-au"
07:10:49 <phadej> I see, it's override. good to know
07:11:23 <merijn> phadej: Feel free to weigh in: https://gitlab.haskell.org/ghc/ghc/issues/18117 :)
07:11:36 <merijn> phadej: I plan to remedy that/provide an alternative
07:13:41 <peutri> is there a way to turn those options off?
07:13:54 <merijn> peutri: Which options?
07:14:04 <peutri> the -with-rtsopts ones
07:14:14 <merijn> You can override them on the commandline IFF that's enabled
07:14:38 <merijn> phadej: btw, -rtsopts isn't needed for -with-rtsopts, they're orthogonal
07:14:41 <peutri> more to the point: if we go for -with-rtsopts combines, can we at least remove options from the left using options from the right?
07:16:00 <merijn> peutri: No clue :)
07:17:49 <peutri> (my opinion: -with-rtsopts really should be concatenate -- but changing that from a legacy of "it clobbered
07:18:02 <peutri> means we lose flag removing functionality
07:18:10 <merijn> peutri: I don't know if anyone actually relies on that behaviour, tbh
07:18:11 <peutri> which is ok if it can be done on its own)
07:18:20 <peutri> i hope not
07:18:26 <peutri> but... where's my xkcd link
07:18:47 <peutri> /1172
07:19:27 <phadej> peutri: no one proposes combining -with-rtsopts
07:19:43 <peutri> that's what I gathered from option 1
07:20:44 <merijn> phadej: That was literall option one and also a comment by some people in #ghc :)
07:20:58 <peutri> and it does make perfect sense to me
07:21:18 <merijn> phadej: -optc, -optl and similar flags do the same, as does cabal's --ghc-option, iirc
07:21:20 <peutri> i could conceive having part of them in a cabal common stanza, the rest in a specific executable
07:21:45 <merijn> peutri: Or just the example case I just posted of having one in ghc-options and an additional one in ghc-prof-options
07:21:48 <peutri> there are workarounds, but clobbering certainly violates "least surprise" AFAIC
07:21:59 <peutri> yup, that too
07:22:00 <phadej> I meant that Cabal won't combine -with-rtsopts for you. What GHC does with them is GHC business
07:22:21 <peutri> oh you mean cabal passes them to ghc individually?
07:22:29 <peutri> oh yes
07:22:33 <peutri> that's what's written
07:22:35 <merijn> phadej: Oh sure, we weren't talking about that
07:22:49 <peutri> (I was, but I was wrong, but it actually doesn't change a thing)
07:23:04 <merijn> phadej: If we wanted cabal to do it we should instead just have, like ghc-rts-options as a new field in a new cabal version
07:23:17 <phadej> merijn: yes, that makes sense
07:23:36 <merijn> But probably better to fix GHC (although that'd make it harder to support multiple older GHCs)
07:24:01 <phadej> changing the behavior of a flag is dangerous indeed
07:24:18 <phadej> especially as it won't cause any warnings or errors
07:24:30 <peutri> if it used to be an error to have two, it doesn't really "change" the behavior
07:24:36 <merijn> phadej: Yeah, which is why I think 2.3 is probably the safest change
07:24:37 <phadej> it isnt
07:24:45 <peutri> oh
07:24:51 <phadej> merijn: I don't know what your option 1 or 2.3 refer to
07:25:02 <merijn> phadej: The link I pasted before: https://gitlab.haskell.org/ghc/ghc/issues/18117
07:26:03 <phadej> voting with emojis is worse idea ever
07:26:16 <phadej> luckily I'm not even logged
07:26:42 <merijn> phadej: It is, but there's no builtin polling in gitlab
07:27:03 <merijn> And I can't be arsed to setup a site externally
07:27:15 * hackage hextream 0.1.0.0 - Streaming-friendly XML parsers  https://hackage.haskell.org/package/hextream-0.1.0.0 (koral)
07:27:34 <merijn> so unless you know a better way, that's what I've got :)
07:27:40 <phadej> I mean, voting is just bad idea to begin with
07:28:42 <merijn> phadej: It's not voting, though. Getting a read on public opinion
07:28:45 * hackage hextream 0.1.0.1 - Streaming-friendly XML parsers  https://hackage.haskell.org/package/hextream-0.1.0.1 (koral)
07:28:56 <phadej> public opinion on internet...
07:28:59 <phadej> good idea ;)
07:29:14 <phadej> either you get nonsense, or don't get enough volume :)
07:29:21 <merijn> phadej: Well, the limited part of the internet that cares about GHC and haskell-cafe
07:30:23 <merijn> At any rate, after nuking dist-newstyle things seem to work as expected, so presumably indeed an issue with recompilation logic
07:33:21 <phadej> good
07:34:40 <merijn> Well, bad, 'cause I have no idea how to reproduce :p
07:38:51 <phadej> it's not the only recompilation bug, no worries :)
08:07:44 * hackage haskoin-store 0.23.8 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.8 (jprupp)
08:35:44 * hackage haskoin-store 0.23.9 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.23.9 (jprupp)
08:39:33 <statusfailed> Are there any latex packages for doing haskell-style pseudocode?
08:43:51 <phadej> I guess "everyone" is using lhs2tex to prepare latex documents with haskell-likecode
08:44:55 <statusfailed> dang
08:45:39 <yushyin> if you just want pseudocode use listings with some custom added keywords?
08:46:09 <statusfailed> true, could do
08:46:19 <statusfailed> I was hoping there was something like "algorithm" which has lots of nice formatting by default
08:46:56 <yushyin> I doubt
08:47:09 <statusfailed> yeah I guess it doesn't make too much sense for haskell
08:48:19 <yushyin> yeah right, but listings has math escape and you can mix math and haskell code like you would with an algorithm package, so I guess it could work out.
08:48:36 <statusfailed> yeah maybe I will give that a shot, thanks!
08:59:15 * hackage byteslice 0.2.3.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.2.3.0 (andrewthad)
10:07:15 * hackage dialogflow-fulfillment 0.1.1.1 - A Dialogflow Fulfillment library for Haskell.  https://hackage.haskell.org/package/dialogflow-fulfillment-0.1.1.1 (mauriciofierrom)
10:10:15 * hackage bytehash 0.1.0.0 - Universal hashing of bytes  https://hackage.haskell.org/package/bytehash-0.1.0.0 (andrewthad)
10:27:44 * hackage parsec1 1.0.0.7 - Portable monadic parser combinators  https://hackage.haskell.org/package/parsec1-1.0.0.7 (ChristianMaeder)
10:31:12 <monochrom> Wait, downcounting? parsec1?
10:31:51 * monochrom thinks of creating "really universal parser combinators: parsec0" :)
10:32:21 <Uniaika> :D
10:33:37 <koz_> monochrom: parsec-1
10:34:20 <monochrom> Yeah I'm thinking how grand parsec minus 1 should be. It has to be grander than parsec zero now :)
10:34:53 <monochrom> Ah! Multiversal!
10:35:01 <monochrom> "one universe is not enough"
10:36:53 <berndl> Isn't Megaparsec the most universal parser combinator library?
10:40:04 <Feldmaus> It's nice to see that there are still people who care about minimalism :)
10:41:56 <tdammers> parsec-omega
10:43:43 <dmwit> Sorry for asking the dumb question, but... how did "universal" get into this conversation?
10:43:48 <monochrom> Another line you can follow for version numbers is surreal numbers, e.g., how about parsec-infinitestimal? :)
10:44:18 <monochrom> It started with "parsec1 1.0.0.7 - Portable monadic parser combinators"
10:45:08 <monochrom> so I was like, eh someone is counting down, what would parsec0 aim at, if I were to undercut it?
10:46:02 <dmwit> ok =)
10:51:08 <dsal> When I make a new parser library to supercede all of them, do I need to include parsec in the name?
10:52:39 <monochrom> Namesakes are extremely important in the fight for attention :)
10:52:47 <dmwit> It does seem to be traditional. Perhaps you could use another large distance unit, like AU or light-second.
10:53:27 <dmwit> millileague has a nice ring to it
10:56:53 <monochrom> For example, the Tudor kings of England still claimed the French throne, and they totally included "King of France", rather than "maybe I should s/France/somethingelse/ to start new and avoid confusion..."
10:56:54 <berndl> Why are they even called combinators?
10:57:00 <sheepfleece> How would you write this confetti? I just don't like how my code in Haskell always tries to move to the right with all those nested cases. https://paste.debian.net/1143983/
10:58:57 <dsal> berndl: they combinate
10:59:14 * hackage shakebook 0.2.0.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.2.0.0 (locallycompact)
11:02:12 <monochrom> sheepfleece: In this special case that every Nothing and Left leads to "next", perhaps slap on some kind of MaybeT or EitherT or ExceptT, and use "next" as your "last resort" or "exception handler".
11:03:33 <monochrom> However, personally I wouldn't do anything about it for now.
11:06:58 <sheepfleece> I see, thank you! 
11:14:07 <zebrag> Is it possible to transform a lambda-term in such a way that there is always only *one possible reduction*, whatever the reduction strategy, even with *nondeterministic reduction strategy*? (I thought is was all what CPS transform was about; the fact that I can't make head or tail about the latter might not help.)
11:14:38 <koz_> zebrag: If there is _always only one possible reduction_, then it's not non-deterministic.
11:14:46 <koz_> That's what determinism _means_.
11:14:47 <zebrag> At each reduction step, in the whole term, there is only one redex.
11:14:47 <fragamus> hi I have an AST dump obtained from -ddump-parsed-ast.  Is it possible to have GHC take this as input instead of a .hs file
11:15:50 <zebrag> koz, I was speaking of the strategy: whatever the strategy, even nondeterministic, the term itself is deterministic
11:16:10 <zebrag> koz_: ^
11:20:45 * hackage indexed-list-literals 0.2.1.3 - Type safe indexed list literals  https://hackage.haskell.org/package/indexed-list-literals-0.2.1.3 (DavidMD)
11:28:47 <sheepfleece> monochrom: I used `fromMaybe` and `pure <$> ...` to get this. Not sure whether it is more readable, though. https://paste.debian.net/1143998/
11:32:16 <monochrom> That probably changes behaviour.
11:34:16 <monochrom> Suppose I have:
11:34:25 <monochrom> f1, f2 :: Maybe Int -> IO ()
11:35:13 <monochrom> f1 m = case m of Nothing -> return (); Just i -> do { print i; putStrLn "bye" }
11:35:21 <monochrom> f1 is akin to your 1st version
11:37:09 <zebrag> How come you can avoid the `return`, line 10? (https://paste.debian.net/1143998/)
11:37:49 <sheepfleece> return is just a function. You don't need to use it if your last action has the same type.
11:38:00 <sheepfleece> Ah, oops.
11:38:09 <sheepfleece> It is Maybe (Maybe val)
11:38:14 <monochrom> f2 m = do { i <- fromMaybe (return ()) (pure <$> m); print i; putStrLn "bye" }
11:38:26 <monochrom> f2 is akin to your 2nd version.
11:39:10 <monochrom> Actually I don't even see how f2 or your 2nd version type-checks.  But suppose they did, then "f1 Nothing" does not output "bye", "f2 Nothing" still does.
11:39:50 <sheepfleece> Ah, yes, you are right, but in this case `next` is similar to `throw`, but is handled by scotty itself.
11:40:51 <sheepfleece> https://hackage.haskell.org/package/scotty-0.11.5/docs/Web-Scotty.html#v:next
11:41:10 <monochrom> Oh, then it works.
12:04:14 * hackage shakebook 0.2.0.1 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.2.0.1 (locallycompact)
12:24:57 <tobiasBora> Hello, just a quick question: if I create a newtype "newtype MyInt = MyInt Int", is it as efficient as defining "type MyInt = Int"? I just would like to use my own type to avoid typing errors, but I don't want to lose on efficiency
12:25:49 <ChaiTRex> tobiasBora: Yes, it's as efficient.
12:26:07 <tobiasBora> ChaiTRex: ok cool. And what if I do a record instead, to have a nice accessor?
12:27:04 <ChaiTRex> tobiasBora: That just defines a function that with no work returns the wrapped type.
12:27:55 <ChaiTRex> tobiasBora: The wrapped value is the only thing stored, so returning it just changes its type and types are a compile-time rather than runtime thing.
12:28:43 <ChaiTRex> tobiasBora: With data instead of newtype, it might store the constructor in memory as well, so stripping that can take time.
12:29:11 <berndl> When defining a function f :: a -> a -> a, what single-letter variable names do you use for arguments of f? Is there a guideline about this?
12:29:40 <ChaiTRex> berndl: Usually, it's a, then b, then c, unless you have a good reason for something else.
12:29:46 <monochrom> There is no guideline.
12:30:04 <ChaiTRex> berndl: For example, monads are usually m.
12:30:34 <berndl> Ugh. This is why I like point-free style - I don't have to worry about these naming decisions.
12:30:42 <ChaiTRex> :type mapM_
12:30:48 <monochrom> And I doubt you really literally have "forall a. a -> a -> a" in mind.  There are only two non-degenerate possibilities.  Both are boring and highly unused.
12:31:31 <ChaiTRex> :t mapM_
12:31:33 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
12:31:40 <koz_> :t traverse_
12:31:41 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
12:32:13 <berndl> Speaking of which, what do you use when the it's f a -> f a -> f a
12:32:27 <koz_> berndl: I can't parse that question, sorry.
12:33:22 <monochrom> Most interesting functions of that type are already in the standard library, so again I suspect you don't literally mean it.
12:33:29 <monochrom> What is the real question?
12:33:30 * koz_ just realized that traverse_ is what you'd use to implement foldMap.
12:33:36 <ChaiTRex> berndl: Oh, you mean value variables rather than type variables.
12:33:45 * hackage headroom 0.2.1.1 - License Header Manager  https://hackage.haskell.org/package/headroom-0.2.1.1 (xwinus)
12:33:53 <berndl> Yes, I mean the names of the arguments of the function.
12:34:44 <berndl> monochrom: Yes I do, because I'm making my own prelude.
12:34:45 <ChaiTRex> berndl: Variable names are usually related to the function name.
12:34:55 <Cale> berndl: It depends on how long the function definition is
12:35:02 <monochrom> Then copy from the standard prelude?
12:35:17 <monochrom> If they use "x", you use "x"?
12:35:17 <berndl> monochrom: the standard prelude is super inconsistent.
12:35:17 <Cale> berndl: As the function gets longer, I tend to choose more meaningful names
12:35:32 <Cale> berndl: If it's like a single line, I might just go with x and y or something
12:35:42 <monochrom> Pick one convention you like?
12:35:52 <berndl> But if the type is a, wouldn't it make sense to call the variable a too?
12:35:57 <Cale> Obviously, the names of those variables don't matter from outside the function's definition, so don't worry about it too much
12:35:57 <berndl> Why would I call it x?
12:36:08 <Cale> It's as good a letter as any
12:36:23 <monochrom> Understandably the standard prelude was written by a committee spanning 2 decades or more, probably spanning 2 generations now.
12:36:25 <maerwald> use `i` for max confusion
12:36:30 <maerwald> i, j, p ...
12:36:30 <Cale> and it's common to use x as the argument of a single-variable function in mathematics
12:36:35 <berndl> Of course, if I have two things of type a, I would prefer a1 and a2 or a and a'.
12:36:40 <ChaiTRex> Use k for constant.
12:36:52 <ChaiTRex> Since you can't change variable values, of course.
12:37:01 <maerwald> k_1, k_2
12:37:02 <Cale> berndl: Sometimes that's nice, sometimes using the same names at the term and type level is confusing.
12:37:11 <berndl> I've seen k used for continuations.
12:37:14 <monochrom> Yes if the type var is a, I am happy to use the term var a to go with it.  Until there are too many a's.
12:37:46 <maerwald> so you do: foo a @a
12:37:51 <maerwald> hmm
12:37:59 <maerwald> might be confusing with type applications
12:38:28 <berndl> Actually, were it would be confusing is in documentation.
12:38:34 <ChaiTRex> berndl: Things are usually based on what kind of thing you're dealing with, just like in math. Lists are xs, ys, zs. As you've seen, continuations are k.
12:38:39 <monochrom> I have seen this joke text on group theory.  "Let e be a group, x be its identity element. Let G be an element of e."
12:38:56 <berndl> Talking about a :: a in comments or a blog post would be really confusing.
12:39:43 <monochrom> The common math convention is f, g, h,... for bland functions, x, y, z,... for bland parameters.
12:39:45 <berndl> ChaiTRex: In math, you use capital X, Y, Z for sets though.
12:40:12 <monochrom> that is, until one day someone asks you this trick question: simplify (x-a)(x-b)...(x-z)
12:40:26 <ChaiTRex> berndl: I didn't mean we use math's conventions, though we do use some. I mean we, like math, use conventions based on what kinds of things we're dealing with.
12:40:57 <ChaiTRex> berndl: So, if we deal with lists or list-like things, we might use xs, ys, zs.
12:41:19 <berndl> And what happens when you need a fourth list?
12:41:32 <ChaiTRex> berndl: ws?
12:41:42 <berndl> Oh boy.
12:41:46 <monochrom> For most functions in a prelude, even a quality homebrew prelude, every function takes so few parameters, you won't easily run out of bland f, g, h, x, y, z, xs, ys, zs, i, j, k.
12:42:40 <ChaiTRex> berndl: What do you do in math when you have indexes i, j, k, and another?
12:43:01 <monochrom> Morever, for most functions in a prelude, they are so general-purpose there can be no "meaningful" names for parameters. "meaningful" names are for domain-specific application-specific narrowmind uses.
12:43:14 <koz_> ChaiTRex: I think i, j, and k are used for unit vectors?
12:43:15 <berndl> ChaiTRex: i1, ..., i4
12:43:20 <monochrom> So I don't understand what's the fuss about it, apart from OCD>
12:43:30 <ChaiTRex> berndl: OK, you can do that as well if you'd like.
12:43:39 <berndl> Yes, that's what I am doing.
12:43:47 <berndl> I just wanted to fish for opinions.
12:43:55 <ChaiTRex> koz_: I've seen it for sequence components as well.
12:44:50 <berndl> I'm tempted to use xs, ys, zs for f a terms rather than just [a] terms.
12:45:11 <monochrom> I do that too.
12:45:26 <monochrom> I even do that to free monads.
12:45:57 <berndl> The general trend though seems to be to use fa for a term of type f a
12:46:14 <berndl> or ma for m a, ta for t a, mna for m (n a), etc
12:46:23 <Cale> koz_: That's kind of an ancient convention that has an interesting history behind it. It's from when Hamilton was pushing the use of a certain subset of the quaternions for describing 3D vectors :)
12:46:24 <monochrom> I even call the data constructors "data FM f a = Unit a | Cons (f (FM f a))".
12:46:27 <ChaiTRex> berndl: Data.Foldable sometimes does that. For example, http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Foldable.html#foldr%27
12:46:31 <maerwald> someone should write all these insights down in a giant blog post
12:46:46 <maerwald> how to name verything: the final guide
12:47:07 <tdammers> just refactor everything into point-free style and don't name anything
12:47:13 <maerwald> lool
12:47:15 <ChaiTRex> berndl: By 'that', I mean your idea of using xs for f a.
12:47:21 <berndl> tdammers: I agree.
12:47:27 <maerwald> tdammers: that'll probably create quite a few space leaks =)
12:47:33 <tdammers> alternatively: name all your variables 'nufta' plus a numeric suffix
12:47:35 <monochrom> Pointfree just lifts the burden of naming to the combinator level.
12:47:38 <berndl> ChaiTRex: I bet that's just a copy-paste from the old list code.
12:47:54 <monochrom> Like what the hell do you name "(.) . (.) . (f .) . (. g)"
12:48:15 <monochrom> Cf. lens
12:48:42 <ChaiTRex> berndl: No, foldr on lists wouldn't use foldl, I don't think.
12:48:57 <maerwald> @hoogle (^.^)
12:48:57 <lambdabot> Geom2D (^.^) :: Num a => Point a -> Point a -> a
12:49:06 <ChaiTRex> @unpl (.) . (.) . (f .) . (. g)
12:49:06 <lambdabot> (\ x g0 x0 x1 -> f (x (g (g0 x0 x1))))
12:49:22 <monochrom> foldr' is not foldr
12:49:42 <monochrom> When I was younger and arrogant, I would add "are you blind?"
12:49:44 <ChaiTRex> Well, there's no foldr' in the old list code.
12:49:52 <maerwald> @hoogle (-.->)
12:49:52 <lambdabot> Generics.SOP newtype ((f :: k -> Type) -.-> (g :: k -> Type)) (a :: k)
12:49:52 <lambdabot> Data.SOP newtype (f -.-> g) a
12:49:52 <lambdabot> Data.SOP.Classes newtype (f -.-> g) a
12:49:56 <ChaiTRex> The closest they could be referring to is foldr.
12:50:38 <monochrom> But don't you find it a beautiful irony.  foldr' is definable by foldl, foldl' is definable by foldr
12:51:06 <maerwald> There should be a GHC extension turning all combinators into korean ascii emojis
12:51:07 <berndl> monochrom: You have that irony with foldrM and foldlM.
12:51:23 <monochrom> Ah, true that.
12:51:29 <tdammers> best naming convention, however, is to use only combinations of l, |, I, and 1 for all identifiers
12:51:32 * dsal plays xs foldM
12:52:28 <berndl> One thing about APL (and it's cousins) that I like is that you have no choice about the name of the arguments.
12:52:45 <dsal> sh is like that.
12:52:51 <^|{`-}_{> And what do you think of my name? >:)
12:53:03 <dsal> hey, I didn't get to respond.
12:53:13 <monochrom> Respond to me!  It was me. :)
12:53:40 <berndl> In APL, you use ⍺ for the first argument and ⍵ for the second argument.
12:53:56 <dsal> I don't know APL.  Are the parameter names better than sh?
12:54:01 <monochrom> And actually the username will be {$$$} next time it reconnects.
12:54:01 <dsal> You get two arguments?
12:54:13 <berndl> Yep.
12:54:14 <monochrom> Hrm maybe {$$} is better.
12:54:21 <dsal> In haskell, functions only get one argument.  Maybe we should just name it argument.
12:54:21 <berndl> If you need more than two, you're screwed.
12:55:08 <dsal> I think they actually did that in dhall.  If you want to take two arguments in a function, you have to do it manually.
12:56:02 <solonarv> monochrom: "most interesting functions of that type [forall a. a -> a -> a] are already in the standard library" - no, only half of them :)
12:56:18 <berndl> In Q, the situation is a better: you can use x for the first argument, y for the second and z for the third.
12:56:23 <dsal> In half the standard libraries?
12:56:40 <maerwald> dsal: the haskell reports uses "multiple arguments" speak :)
12:56:56 <dsal> Very progressive.
12:57:33 <maerwald> And this function, when passed one argument, produces another function, when passed one argument, that pr...
12:57:53 <monochrom> solonarv, "f a -> f a -> f a"
12:59:54 <solonarv> ah, yes, then I agree (assuming both f and a are forall-quantified, and there is a constraint on f)
13:00:14 <solonarv> for 'forall a. a -> a -> a', Prelude contains exactly half the interesting functions of that type
13:00:31 <solonarv> (it has \x _ -> x, but not \_ y -> y)
13:00:58 <berndl> Is there a nice name for the latter function?
13:01:04 <ChaiTRex> :t flip const
13:01:06 <lambdabot> b -> c -> c
13:01:13 <solonarv> tsnoc, obviously :)
13:01:21 <solonarv> :t const id -- also works
13:01:22 <lambdabot> b -> a -> a
13:01:44 <solonarv> ooh! we can call it 'ki' because it is 'K I' in SKI calculus!
13:01:45 <berndl> I think calling const lhs and flip const rhs would work nicely.
13:02:00 <monochrom> You can consider "forall a. a -> a -> a" to be an encoding of Bool.  Then you have the honour to bikeshed over which one is "true", which one is "false".
13:03:30 <monochrom> Lately I have been re-visiting free theorems.  I think I have a better way of stating the parametricity theorem.
13:04:52 <berndl> Do tell.
13:15:55 <monochrom> I turned the more clumsy and technical "<statement about expression E> but add t↦foo to the typevar environment" into the more implicit, lucid "let t=foo in <statement about expression E>"
13:18:31 <monochrom> There is a bit more.  This is in a context in which you start with "forall t. E" and say what to do about it.  You end up with "forall foo. <statement about E> but add t↦foo to the environment".
13:20:07 <monochrom> I also turned that into: you start with "forall F", where F is a lambda, and basically you would rewrite "forall t. E" as "forall (lambda t. E)" and use (lambda t. E) as F, so "forall" is a combinator now.
13:20:26 <monochrom> Then I get to write "forall foo. let t = foo in F t".
13:21:00 <monochrom> err, "forall foo. let t = foo in statement about F t".
13:21:49 <monochrom> (Why not directly "F foo"?  Because there is one more long story I haven't told you such that I am not really doing "F foo".)
13:39:35 <amf> is QuickCheck's Arbitrary still the best way to random generate values from data types? or is there a better way (preferrable a deriving based one)?
13:41:11 <remexre> amf: I've been using hedgehog recently and liking it
13:41:35 <remexre> I think a recent haskell weekly had an article comparing it w/ quickcheck
13:42:06 <berndl> Ugh, having two versions of First is confusing me.
13:42:14 <berndl> It seems the version from Monoid is the most useful one.
13:42:36 <koz_> Hedgehog is awesome.
13:42:44 <amf> i've played a little with hedgehog and liking it, but part of me feels the typeclass approach is better for more complex types.. especially if you are mixing types. but i could be wrong
13:42:45 <koz_> I would suggest its use over QuickCheck if at all possible.
13:42:51 <koz_> amf: It's _really_ not.
13:43:00 <koz_> Arbitrary in my mind is a good example of what _not_ to use type classes for.
13:43:38 <koz_> You can use component Gens quite easily - Gen is an applicative and a monad, so you don't have issues there.
13:43:43 <koz_> It's also significantly less magical.
13:43:57 <koz_> And requires significantly less help given to the compiler to not get ambiguity everywhere.
13:43:58 <amf> ahhh ok yeah im sold now
13:44:31 <koz_> You also don't need newtypes everywhere when you realize 'oh damn, I need to test two different invariants of my data type'.
13:44:46 <remexre> amf: found it https://frasertweedale.github.io/blog-fp/posts/2020-03-31-quickcheck-hedgehog.html
13:44:52 <koz_> (unless you want tests that discard like mental)
13:46:31 <amf> yes! that's what i wanted to see, i dont want to spend any time on producing random data and the applicative style lets me cheat (aka impress my coworkers)
13:47:37 <koz_> amf: Feel free to hit me up if you're having issues.
13:48:21 <dsal> I've still not tried QC, but that blog post recently at least helped me understand the point a bit.
13:49:07 <koz_> dsal: It's fairly logical, just somewhat obscured by the library itself.
13:49:15 <koz_> (took me a bit of use in anger to figure out)
13:49:29 <dsal> Yeah.  From a distance, it's like, "Yeah, but I have QC"
13:49:45 <amf> will do, thanks all!!
13:49:54 <dsal> The only issues I ever really have with QC are getting shrinks right.
13:50:00 <koz_> dsal: My real sell on Hedgehog is that 'Arbitrary' is really not a great idea.
13:50:05 <dsal> It's pretty easy to write a shrink that doesn't terminate.
13:50:09 <koz_> (in the sense of being a type class)
13:50:14 <dsal> I'm not super angry at Arbitrary.
13:50:29 <koz_> dsal: I am, but then again, I'm generally not fond of type classes without laws.
13:51:16 <dsal> What about Has* typeclasses?  I've been doing that a bit lately.
13:51:18 <MarcelineVQ> smallcheck is neat too
13:51:37 <koz_> dsal: I dunno what you're referring to by 'Has*'.
13:51:43 <koz_> MarcelineVQ: That's the exhaustive one right?
13:52:23 <MarcelineVQ> ye
13:52:28 <hseg_> just learned about https://hackage.haskell.org/package/overloaded, seems like a nicer way of doing RebindableSyntax. For the next refactor, I guess
13:52:42 <dsal> koz_: e.g.,  MonadReader, but more specific.  Monad m => HasSomeValue m where someValue :: m SomeValue
13:53:12 <koz_> dsal: Not fond of that, since I'm pretty sure it can't have any laws other than 'uhh... compiles?'.
13:53:24 <dsal> I rather like that law.  :)
13:53:56 <koz_> dsal: You do you.
13:54:03 <koz_> I'm an opinionated asshole and you don't have to agree with me if we're not collaborating.
13:54:32 <dsal> I tend to find out why people have opinions over time.
13:54:51 <dsal> Sometimes they're idiots and wrong, but often I just haven't caught on fire yet.
13:56:50 <koz_> dsal: That's a fun way of putting it.
14:34:04 <poliquin> I'm using Chart 1.8.3 and trying to add an image to a plot. Is this possible?
14:35:31 <dsal> What is Chart?
14:37:25 <poliquin> It's a Haskell package that draws Graphs and 'Charts' .. It's pretty powerful but I can't seem to add an image to a plot
14:38:15 <poliquin> Here's a link to a 'gallery' ... https://github.com/timbod7/haskell-chart/wiki
14:44:52 <dsal> Ah, it's capitalized.
14:44:56 <dsal> @hackage Chart
14:44:57 <lambdabot> http://hackage.haskell.org/package/Chart
14:46:31 <poliquin> Yep, that does get confusing sometimes especially with stack
14:52:44 <dsal> May just not be a thing.  I'm not familiar with this, though.
14:54:32 <hseg> hrm. have a type with a type-level Nat index, want to test a quickcheck property over all values of the index. ideas?
14:55:23 <hseg> obviously i could forAll (arbitrary @Natural $ \n -> reifyNat n p with p :: (KnownNat n, C (T n)) => Property
14:55:38 <hseg> but that combinator screams to be extracted
14:55:57 <hseg> especially since i have multiple type-indexed types
14:56:03 <dmj`> hseg: what's the underlying type, is it monomorphic?
14:56:09 <hseg> yes
14:56:33 <hseg> it's basically Map (Vector n Integer) Rational
14:56:34 <dmj`> hseg: if its just a newtype over vector then I'd just unwrap it, import Test.QuickCheck.Instances () 
14:57:33 <hseg> hrm. don't know about that
14:59:27 <hseg> don't think Vector :: Nat -> Type -> Type has an Arbitrary instance
15:01:26 <hseg> hrm. whatever the type i want to give this forAllNat combinator, i have the further problem that i'd basically want to say forAllNat @(T a _ b) prop, where T :: Type -> Nat -> Type -> Type
15:01:36 <hseg> which is obviously illegal
15:02:12 <hseg> but rejiggering this is also difficult
15:03:09 <hseg> so an alternative solution would want forAllNat @(T a) @b, but that basically encodes the arity of the type following the Nat index
15:03:18 <hseg> not ideal, but workable
15:03:27 <hseg> unless someone has a better solution?
15:06:03 <hseg> another problem is that i need to give an Arbitrary instance to a type, but don't want to infect its defining library with a quickcheck dep. otoh, the defining module implements a sig that my test bench is almost certainly going to somehow depend on
15:06:20 <hseg> and so i can't break abstraction boundaries
15:17:09 <koz_> Suppose I have a common stanza foo spelling out some GHC options. Can I make a common stanza bar with the same GHC options as foo, plus a few more?
15:19:37 <hseg> is there a cleaner way of writing if p x then Just x else Nothing ?
15:19:47 <koz_> hseg: :t guard
15:19:55 <koz_> Sorry, my bad.
15:19:57 <hseg> :t guard
15:19:58 <lambdabot> Alternative f => Bool -> f ()
15:20:18 <koz_> :t \f x -> guard (f x) $> x
15:20:20 <lambdabot> error:
15:20:20 <lambdabot>     • Variable not in scope: ($>) :: f0 () -> t -> t1
15:20:20 <lambdabot>     • Perhaps you meant one of these:
15:20:28 <koz_> % :t \f x -> guard (f x) $> x
15:20:29 <yahb> koz_: Alternative f => (b -> Bool) -> b -> f b
15:20:40 <hseg> good enough, thanks
15:20:50 <koz_> Conveniently works in _any_ Alternative.
15:21:04 <koz_> It's so useful that someone (might have been monochrom) said they define it all the time as 'ensure'.
15:21:18 <koz_> @pl \f x -> guard (f x) $> x
15:21:18 <lambdabot> (($>) . guard =<<)
15:22:29 <monochrom> It was someone else, but yeah.
15:22:39 <koz_> monochrom: Sorry for tagging you, then.
15:24:47 <monochrom> no worries
15:27:29 <koz_> Also, common stanza docs don't specify what happens if I define (say) ghc-options in a common stanza, then import it into something which defines ghc-options of its own.
15:27:33 <koz_> Do they concatenate?
15:38:04 <freeman42x[m]> can GHC be installed via cabal-install on Windows 10? if not, what is the best option of installing a specific older GHC version on WIndows 10?
15:38:23 <koz_> freeman42x[m]: cabal-install doesn't deal with the compiler.
15:38:31 <koz_> The best option is Chocolatey.
15:39:16 <freeman42x[m]> koz_: I was using Chocolatey GUI and it was only showing oldest GHC version. Are multiple versions available and justn not listed in the GUI?
15:39:52 <koz_> freeman42x[m]: Don't use GUIs.
15:40:08 <koz_> Learn the CLI, because there, you can request a version explicitly, and even pin it so an update doesn't accidentally replace it.
15:40:35 <freeman42x[m]> koz_: that was not a GUI issue, that was a UX issue...
15:40:38 <hseg> have some newtype N = N a, want to define an Arbitrary a => Arbitrary (N a) instance such that p (arbitrary @(N a)) always holds for some predicate p. is there a smarter way to do this than just repeatedly calling arbitrary and returning the first value satisfying the predicate?
15:41:03 <koz_> freeman42x[m]: I am generally wary of GUIs, because they tend to have massive numbers of (undiscoverable, unfixable) 'UI issues' of this exact nature.
15:41:16 <hseg> (i don't know the predicate in advance, most likely will be an equality/inequality test against a relatively small number of values)
15:41:36 <koz_> hseg: No, because arbitrary has no knowledge of what you're gonna do with what it generates.
15:41:36 <dsal> :t suchThat
15:41:37 <lambdabot> Gen a -> (a -> Bool) -> Gen a
15:41:47 <dsal> :t (==>)
15:41:48 <lambdabot> STestable prop => Bool -> prop -> Test.QuickCheck.Safe.SProperty
15:41:53 <hseg> thanks
15:41:59 <freeman42x[m]> koz_: you would have to demonstrate they are undiscoverable and unfixable
15:42:09 <dsal> hseg: Those two things might get you close. :/
15:42:14 <hseg> this is my first foray with quickcheck, i don't quite know the library yet
15:42:19 <hseg> nor the best practices
15:42:55 <koz_> freeman42x[m]: To answer your original question instead of bikeshedding around my personal hatred of GUIs; yes, there are a very large number of versions available via Chocolatey, going back at least to 8.2 if not older.
15:43:00 <koz_> (8.2 is the oldest I've tried)
15:43:27 <dsal> Well, an Arbitrary should produce an arbitrary representation.  There are many ways to deal with that input.  You can use ==> in a property to limit input, or you can categorize input to do things with "in" values vs. "out" values.
15:44:34 <koz_> Alternatively, construct multiple instances newtyping the same type, and rig the generator to produce the values which fit the invariants you want to test (or not).
15:44:49 <dsal> Yeah... depends on what your actual goal is.
15:45:37 <hseg> hrm. am writing library code, the predicate is instance-controlled
15:45:58 <dsal> What do you mean?
15:46:06 <dsal> You decide what you're testing properties on.
15:46:44 <hseg> yes, but i'm providing an Arbitrary instance to all instances of a certain typeclass
15:46:52 <hseg> (gated behind a data family, to avoid overlap)
15:47:17 <hseg> and the predicate to be satisfied is a typeclass method
15:47:35 <hseg> so i have no a priori knowledge of what the function will be
15:47:50 <dsal> Then what property do you wish to hold?
15:49:22 <hseg> specifically, i'm representing the group of units of a ring a as an associated type Unit a equipped with maps injU :: Unit a -> a; checkU :: a -> Maybe (Unit a) 
15:49:37 <hseg> and want to have an Arbitrary (Unit a) instance
15:49:54 <hseg> being the Just values of checkU
15:50:40 <koz_> hseg: Is what you're doing a law check?
15:50:50 <hseg> yeah
15:51:02 <hseg> am checking that my ring instances satisfy laws
15:51:17 <hseg> here that the group of units is an actual group
15:51:18 <koz_> hseg: The framework in quickcheck-classes is probably more suitable.
15:51:31 <koz_> Have a look at how it's implemented.
15:52:29 <hseg> sigh... thanks, i'm a bit tired
15:52:46 <hseg> will give it a look tomorrow
15:53:05 <hseg> in any case, still need basic quickcheck for my non-law properties
15:53:15 <MarcelineVQ> checkers   could also be informative
15:53:43 <hseg> (am checking that various implementations of the same function, valid in various ranges, are consistent)
15:55:00 <dmwit> hseg: I recommend adding a class.
15:55:12 <dmwit> class ArbitraryRing a where arbitraryUnit :: Unit a
15:55:14 <dmwit> err
15:55:20 <dmwit> class ArbitraryRing a where arbitraryUnit :: Gen (Unit a)
15:55:51 <hseg> which would double my library size
15:55:55 <dmwit> I suspect in almost all cases there will be a more efficient algorithm for generating valid units than rejection sampling.
15:56:17 <dmwit> You can still give a default instance that does rejection sampling, of course.
15:56:24 <dmwit> I don't know whether it doubles your library size. I doubt it.
15:57:13 <dmwit> It would surprise me a lot to learn that the code for generating valid units was as big as all the rest of the code in your library combined.
15:57:22 <dmwit> Unless the library is very small, I guess. =P
15:57:32 <hseg> more the latter than the former
15:57:47 <dmwit> If the library is very small, then doubling its size is a small cost.
15:57:59 <hseg> hrm. yeah, tiredness is making me pessimistic
15:58:14 <hseg> should go to sleep and return to this tomorrow when i'm fresh
15:58:22 <dmwit> Could be good!
15:58:23 <dmwit> Rest well.
15:58:37 <hseg> thanks!
16:59:14 * hackage lzo 0.1.0.0 - minilzo bundled for Haskell  https://hackage.haskell.org/package/lzo-0.1.0.0 (vmchale)
18:57:44 * hackage lzo 0.1.1.0 - minilzo bundled for Haskell  https://hackage.haskell.org/package/lzo-0.1.1.0 (vmchale)
19:09:15 * hackage hstar 0.1.0.4 - Haskell version of tar CLI utility  https://hackage.haskell.org/package/hstar-0.1.0.4 (vmchale)
19:13:44 * hackage sak 0.1.2.5 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.2.5 (vmchale)
20:26:44 * hackage shakebook 0.2.0.2 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.2.0.2 (locallycompact)
20:39:58 <p0a> Hello! I'm going to try to learn haskell again today
20:40:44 <p0a> My plan is to document my progress so that I can refer back to it when I forget something
20:41:28 <Axman6> In one day? That's ambitious! I'm 10+ years in and still learning!
20:41:58 <Axman6> Great idea though. Have you seen http://dev.stephendiehl.com/hask/? It might help accelerate some of that learning
20:41:58 <p0a> the humblebrag
20:42:29 <p0a> Nice thank you
20:43:11 <toni37> hello
20:45:08 <toni37> i'm trying to implement a priority queue using two implementations: with list and with binary tree
20:45:32 <toni37> i have defined this class: class (Ord a) => PQueue pq a where with some functions
20:45:42 <toni37> and list representation is this: newtype ListPQ a = LPQ a deriving Show
20:46:00 <toni37> how can i define empty queue?
20:46:13 <koz_> toni37: Your list representation has nothing to do with lists.
20:46:41 <koz_> newtype Foo a = SomeOtherThing a is an instruction to the compiler 'Foo is really an a, but I want you to pretend otherwise'.
20:46:50 <koz_> At runtime, ListPQ a and a are 100% indistinguishable.
20:46:56 <koz_> Therefore, I am fairly sure this isn't what you want.
20:47:07 <koz_> Did you perhaps mean 'newtype ListPQ a = LPQ [a]'?
20:48:38 <toni37> this is what i was expected too, but this is the skel from uni
20:48:49 <koz_> toni37: Are you absolutely sure?
20:48:55 <toni37> koz_: yep
20:49:23 <koz_> toni37: Could you give us the exact wording of the assignment?
20:49:33 <koz_> Because I _definitely_ suspect either a typo or a misunderstanding.
20:49:41 <toni37> https://pastebin.com/dcXDSzhy
20:50:25 <koz_> So line 86 was given to you?
20:50:46 <toni37> yep
20:50:47 <koz_> Are you sure this isn't a placeholder?
20:51:07 <toni37> i cannot say for sure
20:51:13 <koz_> Because to me, that's 100% a placeholder.
20:51:39 <koz_> I'd check with whoever assigned you this.
20:52:00 <toni37> well, i just try to learn haskell, i don't have experience with it
20:52:32 <toni37> so based on the skel, it should be LPQ [(Prio, Int)]
20:52:40 <toni37> and empty = LPQ []
20:52:44 <toni37> right?
20:53:02 <koz_> That can't be right.
20:53:15 <koz_> The type of fromList is [(Prio, a)] -> pq a
20:53:16 <toni37> considering the value is Int, and priority is Prio
20:53:22 <koz_> In the case of LPQ, this specializes to
20:53:30 <koz_> [(Prio, a)] -> LPQ a
20:53:35 <koz_> However, LPQ a is just a
20:53:43 <koz_> How do you magically turn [(Prio, a)] into a?
20:54:45 <koz_> I'd _definitely_ double-check whether this is a placeholder or an error. I've been a lecturer before, and especially with code stuff, I've made some _very_ embarassing errors.
20:54:55 <koz_> I also kinda suspect LPQ's implementation is a placeholder.
20:55:23 <koz_> Also, can you please translate me this sentence: Definiți tipul ListPQ care reprezintă o coadă de priorități ca pe o
20:55:24 <koz_>     listă de elemente.
20:55:34 <koz_> I don't know which language this is, but it's not one I understand,.
20:55:47 <toni37> define the type ListPQ which represents an priority queue as a list of elements
20:55:51 <toni37> romanian
20:55:57 <koz_> toni37: The key word here is 'define'.
20:56:03 <koz_> Which means 'this is a placeholder and you have to do it'.
20:56:27 <koz_> If you are asked to 'define a type', this does _not_ mean 'use this definition we already wrote for you'. Because then, why 'define' anything?
20:57:11 <toni37> it's not very clear for me how things works in haskell
20:57:58 <koz_> toni37: The word 'define' isn't really Haskell-specific.
20:57:59 <Axman6> toni37: I would 100% say you need newtype ListPQ a = ListPQ [(Prio,a)]
20:59:35 <toni37> Axman6: the 'a' type variable should be there so i can store any kind of elements in pq, right?
21:00:33 <toni37> also called parametric polymorphism
21:01:26 <Axman6> yep
21:01:35 <toni37> ok, i get it now
21:01:39 <toni37> thank you :D
21:02:24 <Axman6> I assume the list stored in the ListPQ is supposed to be sorted by priority (so sorted in reverse order, assuming you want the highest priority at the front of the queue)
21:03:07 <toni37> guess correctly
21:03:31 <p0a> What are test suites?
21:03:46 <p0a> is it some way in which your program runs on some parameters with expected output?
21:03:47 <koz_> p0a: Collections of related tests, typically for the same project or module.
21:04:03 <p0a> koz_: is it related to what I said? I'm not sure what you mean
21:04:16 <toni37> p0a: yep
21:04:45 <koz_> p0a: It's not related to the second thing you mentioned, no. When I hear 'test suite', I mentally translate that to 'a bunch of tests of logically-connected code bits'.
21:04:51 <koz_> What's the context?
21:05:07 <p0a> No context, just trying to understand that aspect of `stack'
21:05:17 <koz_> p0a: stack as in the build tool?
21:05:20 <p0a> yes
21:05:37 <koz_> Then it's definitely 'a bunch of tests of logically-connected code bits'.
21:06:18 <p0a> I don't understand what you mean by that, can you give an example?
21:06:29 <koz_> p0a: Are you familiar with automated testing of programs?
21:07:37 <toni37> koz_: can you give an example of automated testing of programs?
21:07:49 <Axman6> there are many kinds of tests, usually we test finctions,  both using what are called unit tests, where we give a specific input and the expected output, and also things like propert based tests, where we generate random inputs and make sure that the code always what we expect - like given a random list of values, we expect out sort function to produce an output where all the elements are in ascending order
21:07:51 <koz_> toni37: Are you also curious about this topic?
21:08:09 <p0a> It sounds a bit like what I said 
21:08:17 <p0a> At least the unit tests do
21:09:03 <koz_> p0a: Here ya go, a test suite: https://notabug.org/koz.ross/finitary/src/master/test/Main.hs
21:09:05 <toni37> koz_: yes, because in another context, i tried to implement dfa's into C code, and i realized that i could create a tool to generate automatically tests for any given dfa
21:11:15 * hackage shakebook 0.2.0.3 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.2.0.3 (locallycompact)
21:11:32 <toni37> but here rise another problem: to implement an dfa into C code could guarantee the correctness of a computer program, but is not the most optimized code
21:12:07 <gaze__> suppose I have a datastructure that might change
21:12:12 <koz_> toni37: You can implement DFAs in a number of ways, of varying optimality. Also, for test code, we usually aren't worried about optimality as much as for production code.
21:12:14 <gaze__> but I might add on a bunch of optional fields
21:12:26 <koz_> If your tests are a bit slow, that's OK as long as it doesn't make the tests so long that nobody runs them.
21:12:38 <gaze__> and this datastructure is filled a ton of times in different places
21:12:39 <koz_> Usually, we care more about coverage and ensuring that the required invariants will hold.
21:13:10 <gaze__> is there like... a flexible way to define records?
21:13:15 <toni37> koz_: of course, but at the end of the day, that code should be fast
21:13:28 <koz_> toni37: 'That code' meaning 'the test code'? Or 'the code being tested'?
21:13:55 <koz_> gaze__: Do you have something like JavaScript objects in mind?
21:13:58 <toni37> the code which will go into production
21:14:09 <koz_> toni37: Absolutely, but _tests_ check correctness.
21:14:24 <koz_> For _performance_, we can do benchmarking, but those can be misleading too.
21:14:42 <gaze__> koz_: What I have in mind is writing something _like_ an ffi for c++... in particular I'm inspired by ian woo kim's fficxx
21:14:48 <toni37> so we could rewrite the code without that structures, and make it fast, or is there some way to obtain comparable results with dfa's representations?
21:15:05 <koz_> toni37: Depends on what you mean by 'fast', and what representations.
21:15:07 <koz_> Also for what purpose.
21:15:14 <p0a> Where can I read about numbers and understand how they work?
21:15:25 <gaze__> but I may play with the definition of the class structure... and then that borks every instantiation
21:15:26 <koz_> There _is_ no 'fast', only 'fast enough'. And what 'fast enough' means depends a lot on the problem domain.
21:15:41 <p0a> For example the function f xs = [if x < 10 then 1 else 0 | x <- xs]. What is its type?
21:15:44 <koz_> gaze__: I'm afraid I'm not familiar with the thing you are describing, so I can't offer much advice.
21:16:02 <koz_> :t \f xs = [if x < 10 then 1 else 0 | x <- xs]
21:16:04 <lambdabot> error:
21:16:04 <lambdabot>     parse error on input ‘=’
21:16:04 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
21:16:04 <toni37> koz_: generally speaking, considering we want max performance from our application
21:16:10 <koz_> :t \f xs -> [if x < 10 then 1 else 0 | x <- xs]
21:16:11 <lambdabot> (Ord a1, Num a1, Num a2) => p -> [a1] -> [a2]
21:16:22 <koz_> toni37: That statement is under-specified. 'Max performance' can mean many different things.
21:16:34 <toni37> ok, minimum execution time
21:16:39 <koz_> Doing what task?
21:16:42 <koz_> In what domain?
21:16:45 <koz_> On what kinds of inputs?
21:16:51 <toni37> for example, a C preprocessor
21:17:02 <koz_> A C preprocessor involves file IO.
21:17:10 <koz_> At that point, your perf is bounded by how quickly your drives spin.
21:17:16 <toni37> let's focus just on the first part, where we parse the arguments
21:17:33 <koz_> toni37: The answer is 'it doesn't matter, because relative the cost of reading from disk it's irrelevant'.
21:17:44 <p0a> So Num is a general type?
21:17:48 <koz_> Plus, that's _also_ highly specific to language, implementation, etc.
21:17:50 <koz_> p0a: Num is a type class.
21:17:57 <p0a> Thanks koz_ that's what I meant
21:18:07 <koz_> So there's a bunch of types which are implementations of it, all sharing a common interface.
21:18:07 <p0a> Why did it deduce that x is Num? Why is it obvious from x < 10?
21:18:15 <koz_> :t 1
21:18:17 <lambdabot> Num p => p
21:18:19 <koz_> :t 0
21:18:21 <lambdabot> Num p => p
21:18:27 <Cale> :t (<)
21:18:28 <lambdabot> Ord a => a -> a -> Bool
21:18:37 <koz_> In general, if you write something that looks like a number literal, it'll infer as (Num a) => a.
21:18:40 <koz_> :t 1.0
21:18:41 <p0a> Then x could be just Ord 
21:18:42 <lambdabot> Fractional p => p
21:18:49 <koz_> p0a: No, because 'Ord' is a type class.
21:18:50 <Cale> :t 10
21:18:51 <lambdabot> Num p => p
21:19:02 <koz_> So 'x' in this instance most definitely _cannot_ 'just be Ord'.
21:19:18 <Cale> x's type must be an instance of Ord, and it must be the same type as 10, whose type must be an instance of Num
21:19:30 <p0a> It seems it says x is an instance of Ord and Num
21:19:37 <koz_> Yes.
21:19:40 <p0a> Why must it be the same type as 10?
21:19:45 <Cale> :t (<)
21:19:46 <lambdabot> Ord a => a -> a -> Bool
21:19:57 <Cale> The arguments to (<) must have the same type
21:20:03 <p0a> I see, thank you 
21:20:15 <p0a> you said it before I didn't catch it
21:20:31 <c_wraith> learning is sometimes a matter of repetition anyway
21:20:53 <remexre> hm, should lens' zoom work w/ fused-effects?
21:20:59 <Cale> Repetition legitimizes, repetition legitimizes, repetition legitimizes.
21:21:40 <remexre> not in like a "does it out of the box" (it doesn't), but hsould it be possible to make it
21:22:28 <remexre> oh wait it's in fused-effects-lens /facepalm
21:22:39 <remexre> that's what I get for using microlens
21:24:01 <p0a>  but in (Ord a1, Num a1, Num a2) => p -> [a1] -> [a2] what is p?
21:24:12 <p0a> lambdabot mentioned this `p' but I don't know what tha tis
21:24:15 * hackage shakebook 0.2.0.4 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.2.0.4 (locallycompact)
21:24:23 <koz_> p0a: Another type variable.
21:24:28 <pie_[bnc]> heh https://www.hillelwayne.com/monad-tutorials/
21:24:30 <p0a> why is it there koz_ ?
21:24:41 <c_wraith> Also, by parametricity, it's unused.
21:24:44 <koz_> :t \f xs -> [if x < 10 then 1 else 0 | x <- xs]
21:24:45 <lambdabot> (Ord a1, Num a1, Num a2) => p -> [a1] -> [a2]
21:24:57 <koz_> Because I'm silly.
21:25:01 <koz_> I should have written.
21:25:05 <koz_> :t \xs -> [if x < 10 then 1 else 0 | x <- xs]
21:25:06 <lambdabot> (Ord a1, Num a1, Num a2) => [a1] -> [a2]
21:25:19 <p0a> Ah sorry, I get it now
21:25:33 <p0a> koz_: you've ever done formal lambda calculus? :P 
21:25:39 <p0a> looks like it a bit when you wrote \f xs 
21:25:40 <koz_> p0a: I've read TAPL.
21:25:49 <koz_> (as well as a Types and Formal Proof)
21:26:00 <koz_> Whether that counts as 'formal lambda calculus' is debatable.
21:26:05 <p0a> well sounds good to me
21:27:16 <renzhi_> I'm using HSpec for unit testing, and stack test will run all tests. How do I run just one specifc spec?
21:27:40 <koz_> renzhi_: I think you can pass an argument to hspec itself to run one specific test.
21:28:19 <renzhi_> I've tried that, but it does not seem to like it.
21:28:31 <koz_> http://hspec.github.io/options.html -- there's a section saying how to do it with stack.
21:28:57 <koz_> For one-offs, you can also use environment variables, or a .hspec file.
21:29:04 <Axman6> f you run stack test -- --help you will get the help for your test suite, you can then use stack test --ta "--argument testname"
21:29:18 <koz_> Axman6 being 200% more useful than I am, once again.
21:29:24 <Axman6> (where argument is something else)
21:29:35 <renzhi_> thanks, will just check that.
21:30:01 <p0a> Where can I read about Num and Integral and the other type classes?
21:30:20 <koz_> p0a: The base documentation will tell you about the type classes and their instances.
21:30:25 <Axman6> in the Prelude docs probably
21:30:27 <koz_> Beyond that, it depends what you wanna know.
21:31:44 <p0a> How do I access the Prelude docs?
21:31:59 <koz_> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num
21:32:04 <koz_> ^ That's Num.
21:32:14 <koz_> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral
21:32:17 <koz_> ^ Integral
21:32:30 <Axman6> In the beginning, there was Bool, and we were happy
21:32:36 <p0a> wow really difficult to read
21:32:44 <koz_> Axman6: Word was there before Bool.
21:32:56 <koz_> p0a: Like all docs, some practice is required.
21:33:09 <koz_> And Word# before even that.
21:33:20 <Axman6> p0a: chinese is also very ifficult to read if you don't read chinese
21:33:53 <p0a> Axman6: Not sure what's your point :)
21:33:59 <renzhi_> I was trying "stack test --ta -m PATTERN", that does not seem to work, but "stack test --ta --match=PATTERN" is fine.
21:34:10 <koz_> p0a: Several possibilities arise. One is 'practice will make it easier'.
21:34:51 <Axman6> p0a: I find those documents very easy to read, but they are aimed at people who know some Haskell, and for helping people looking to make their own instances of those classes, not for someone who is learning the language on day one
21:35:09 <Axman6> renzhi_: adding quotes like I showed should also work
21:35:49 <p0a> Axman6: well not day one right now, I've done some before
21:36:01 <p0a> But I want to learn some things like File IO, and complex data structures
21:36:09 <p0a> I tried doing something in C++ and it's been 5 days and 500 lines of code
21:36:19 <p0a> and every time I reach a mile stone I decide to add features and it takes longer
21:36:31 <p0a> and it's all silly honestly, I bet it'd be easier in Haskell
21:37:51 <sleblanc> p0a a lot of things are extremely easier in Haskell (once you're past the step of understanding the paradigms and the language itself)
21:39:05 <sleblanc> it's just that some concepts map very well to do-notation, and Haskell isn't fond of syntax clutter like parentheses and curly braces
21:39:43 <c_wraith> you've obviously never seen how SPJ writes Haskell code. :P
21:39:44 <sleblanc> for instance you can get a fully fledged syntax parser up in a few hundreds of lines using Parsec, and less than 1% of the lines will be about actually reading and buffering the file
21:39:47 <renzhi_> Axman6: thanks, got it :)
21:40:06 <p0a> sleblanc: I'm doing mostly mathematical stuff, very algorithmic
21:40:24 <Axman6> Yo dawg, I heard you like semicolons so I put them RIGHT AS THE BEGINING OF THE FLIPPING LINE YOU FILTHY DOG
21:40:27 <sleblanc> c_wraith, I meant that C++ imposes a lot of clutter that you can easily do without in Haskell
21:40:31 <Axman6> AT*
21:40:36 <p0a> well I've gotten a taste of Haskell before so I know it's nice
21:40:45 <p0a> definitely way more pleasant than C++
21:41:01 <p0a> Immutability scares me
21:41:08 <sleblanc> p0a, it should not
21:41:11 <Axman6> Immutability saves you
21:41:12 <sleblanc> you should embrace it
21:41:20 <p0a> Well I wonder if I can embrace it quick enough
21:41:30 <Axman6> immutability is what lets you make the best mutations
21:41:39 <p0a> but thankfully my current problem does not require many mutations
21:41:46 <p0a> I mean, so it'll be fine I think
21:41:51 <koz_> Immutability is amazing, and truthfully, mutation is _never_ required.
21:41:52 <sleblanc> and if there are corner cases where you haven't figured how to take mutability out, you still have some fallbacks (hopefully I won't get too much flak for this)
21:41:53 <dsal> mutability scares me.
21:41:54 <koz_> (it's an efficiency hack)
21:43:17 <sleblanc> these workarounds will keep you up and running, but inevitably you'll come back to them as you will find it sticks out like a sore thumb
21:44:26 <sleblanc> by having no mutability and wrapping all your state for instance in a command interpreter, there are many neat features you can implement so easily, like undo history
21:44:45 <sleblanc> just track the state in a list! undo will pop the list
21:44:46 <koz_> Plus, in Haskell, we can have mutation just fine.
21:44:46 <dsal> And concurrency.
21:44:51 * koz_ looks at ST.
21:45:18 <Axman6> we have, far and away, the best concurrency
21:45:24 <koz_> Axman6: Hear hear.
21:45:26 <sleblanc> koz_, right, and you wrap your mutable access into some sort of DSL or state machine, for sanity retention
21:45:48 <koz_> Well, ST _does_ stand for 'state transformer', and it's in fact how IO is implemented.
21:45:56 <koz_> (under the covers, IO ~ ST RealWorld)
21:46:19 <p0a> Yeah I hope that I will be able to do some stuff with concurrency sometime
21:47:02 <sleblanc> p0a, concurrency in Haskell will really makes you think about how your task needs to be broken down
21:47:33 <dsal> concurrency in haskell is boring.
21:47:53 <koz_> dsal: Go go gadget async.
21:48:13 <sleblanc> p0a, pipes are cool
21:48:33 <dsal> s/mapM/mapConcurrently/g
21:48:50 <p0a> we'll see when the time comes
21:48:55 <dsal> I've never used pipes.  I've done good stuff with conduit, though.
21:48:58 <p0a> for now I need to figure out basic things like reading a file :P
21:49:13 <dsal> :t BL.readFile
21:49:14 <lambdabot> error:
21:49:14 <lambdabot>     Not in scope: ‘BL.readFile’
21:49:14 <lambdabot>     Perhaps you meant one of these:
21:49:36 <jackdk> my experience with pipes was they were an elegant but completely unusable abstraction, but I liked `streaming` as a lib
21:49:56 <koz_> I am also a 'streaming' fan.
21:50:20 <Axman6> I agree with jackdk, I've written a lot of conduit code because amazonka is conduit based, but streaming looks very nice too
21:51:46 <sleblanc> gotta admit I'm not sure what the differences between conduit and pipes are. I thought one relied on the other
21:53:31 <Axman6> no
21:54:24 <Axman6> pipes is very elegant, but in my experience very difficult to actually write something usable in. it has some restrictions which make life painful (IIRC you can't tell inside a pipe whether there will be no more outpassed to a stage)
21:54:47 <p0a> is there anything wrong with lengthPlusPi xs = pi + fromIntegral $ length xs
21:55:16 <p0a> ah precedence issue, nevermind
21:56:37 <Axman6> other than it being a very weird function, (and not compiling), no :)
21:56:40 <dsal> amazonka is pretty nice.
21:57:08 <Axman6> amazonka is amazing, but it's a little neglected at the moment, we need as a community to maintain it and take the weight off Brendan
21:57:13 <dsal> What's the circumference of a list?
21:57:43 <koz_> dsal: Is it a ring buffer?
21:57:49 <dsal> ha
21:58:20 <dsal> > length . cycle $ [ 1..10 ]
21:58:28 <lambdabot>  mueval: ExitFailure 1
21:58:35 <dsal> > circumference . cycle $ [ 1..10 ]
21:58:37 <lambdabot>  error:
21:58:37 <lambdabot>      Variable not in scope: circumference :: [Integer] -> c
22:00:49 <Axman6> I was thinking yesterday how difficult it would be to write isCycle :: Eq a => [a] -> Maybe [a] which would return the shortest cycle the list contains, once it had reached the end of the list. obviously it may never return
22:01:25 <dsal> I wrote that for my aoc library.
22:01:33 <Axman6> I feel like there should be a nice way to do it taking advantage of laziness
22:01:56 <remexre> hm, is Alternative a => Alternative (b -> a) a reasonable instance?
22:02:26 <remexre> er wait, that's a kind error
22:03:06 <remexre> oh, and that instance exists for Monoid
22:03:21 <remexre> neeeeever mind
22:05:37 <jackdk> I find that I use the Endo a Monoid a lot more than the Monoid b => Monoid (b -> a) instance but yeah it's valid
22:05:38 <sleblanc> Axman6, without some sort of 'timeout' (max length), I don't think it is generally feasible
22:06:40 <sleblanc> Axman6, what if your list is a trillion times [a, b], followed by a single c, then back at the trillion [a,b] ?
22:06:53 <Axman6> spoken like a non computer scientist
22:07:16 <sleblanc> absolutely
22:07:35 <dsal> > length . dropWhile 1 $ repeat 1 <> [2]
22:07:38 <lambdabot>  error:
22:07:38 <lambdabot>      • No instance for (Num (Integer -> Bool))
22:07:38 <lambdabot>          arising from the literal ‘1’
22:07:48 <dsal> > length . dropWhile (== 1)$ repeat 1 <> [2]
22:07:54 <lambdabot>  mueval-core: Time limit exceeded
22:08:03 <dsal> Man, I can tell the answer is 1.  lambdabot is stupid.
22:10:37 <p0a> Whenever I read "Learn you a Haskell" I always find it in such poor taste that they talk about bmi's and losing weight 
22:10:40 <p0a> in such a way
22:11:14 <dsal> I've not heard anything good about it, in general.
22:11:25 <koz_> We recommend the Hutton book in general for a reason.
22:11:43 <p0a> Yeah but I go for free 
22:11:45 * koz_ should really read it out of interest.
22:11:53 <p0a> I'm broke as hell 
22:12:34 <remexre> yeah wait, learn you a haskell stopped me from learning haskell for like 5 years :P
22:12:41 <p0a> LOL remexre why
22:12:51 <gaze__> k0z_: I answered my question... maybe my solution will help elucidate the question. Basically instead of having users fill in the records directly, I use accessors that fill in the field by composing the accessors
22:13:04 <gaze__> that way if the data structure changes, it's fine because I just change the accessors
22:13:11 <remexre> kept going back and forth between "I have no idea what's going on" and "okay but this is easier in python"
22:14:29 <remexre> tbf at the time I had 0 CS education, so anything complicated algorithmically was confusing w/out spending a lot of time thinking abt it
22:20:16 <p0a> is foldr inefficient?
22:20:31 <koz_> p0a: In what sense?
22:20:39 <p0a> any sense
22:21:09 <remexre> foldl' can be more efficient
22:21:28 <p0a> it seems foldr f z [1,2,3] === f 1 (f 2 (f 3 z))
22:21:43 <p0a> so either you are recursing deeply or you are transversing the list first
22:22:05 <p0a> right okay
22:22:23 <koz_> p0a: This may give some insights: https://apfelmus.nfshost.com/articles/lazy-eval-intro.html
22:23:02 <p0a> thanks I'll bookmark that 
22:25:13 <koz_> LLVM is such a chonky boi.
22:25:23 <dsal> foldr is the first thing I reach for.
22:25:24 <koz_> Even with -j12 it still takes forever to build.
22:25:39 <dsal> I generally don't recommend people asking people if something is efficient or not.  I do it sometimes, though.
22:25:58 <p0a> dsal: well at the end of the day I want to run some programs and get some output :P
22:26:15 <p0a> I am hoping that at some point I learn how to write efficient Haskell
22:26:20 <dsal> Yeah.  If you don't get your output by the end of the day, profiling might tell you what's slow.
22:26:40 <p0a> no no, you got it wrong, I want my output way earlier than the end of the day
22:26:40 <dsal> Don't worry about writing efficient haskell.  Worry about writing idiomatic haskell.  And then profiling if it takes too long.
22:26:41 <p0a> :P
22:26:52 <Axman6> > foldr const 0 [1..] -- seems pretty efficient to me!
22:26:54 <lambdabot>  1
22:27:00 <dsal> foldr is my first choice in general.
22:27:13 <p0a> foldl seems more natural to me
22:27:25 <Axman6> they  don't do the same thing*
22:27:50 <dsal> Eh, for a lot of catamorphisms, the ordering doesn't matter, and you can just pick.
22:27:52 <p0a> That's a good point. I guess they do when `f' is associative
22:27:58 <Axman6> (* foldl can be implemented using foldr though, so technically that's wrong the other way cannot be done though)
22:28:12 <dsal> foldr can work on infinite lists.
22:28:17 <Axman6> s/wrong/wrong./
22:28:21 <dsal> (as demonstrated above)
22:28:34 <p0a> wait, eh? I'm confused
22:28:41 <p0a> I'll figure that out tomorrow or something, too tired for that right now
22:29:20 <dsal> This code is using attoparsec.  hlint suggested I replace a    x <- p; pure x   type thing with fmap.  Sure, why not.  Except in one case, I get *a different answer*
22:29:36 <dsal> I'm mildly curious why.
22:30:37 <Axman6> p0a: in  f 1 (f 2 (f 3 z)) replace f with const and see why it works for infinite lists
22:32:20 <dsal> > let prd = foldr (\x o -> if x == 0 then 0 else x * o) 1   in   prd [1..10]
22:32:21 <lambdabot>  3628800
22:32:37 <dsal> > let prd = foldr (\x o -> if x == 0 then 0 else x * o) 1   in   prd [0..9999999999999999999999999]
22:32:39 <lambdabot>  0
22:32:50 <p0a> Axman6: ah yeah, because of recursion. I get it now
22:33:25 <p0a> When using stack haddock, why don't I get docuentation for my Main module
22:33:29 <p0a> I only get it for Lib
22:33:38 <dsal> Because it's a program.
22:33:53 <p0a> Is it possible to document those?
22:34:03 <dsal> Not in library documentation.
22:34:08 <dsal> You could write a manpage or something.
22:34:12 <p0a> Okay
22:34:41 <koz_> I hear pandoc's good for those.
22:34:53 <dsal> I don't think I've ever actually used pandoc
22:36:00 <dsal> Having recently discovered github actions, I suddenly want to document all the things.  https://dustin.github.io/tesla/ <-- more of this.
22:36:24 <dsal> Of course, those docs in particular look kind of bad.
22:36:43 <dsal> https://gitlab.haskell.org/ghc/ghc/issues/5467
22:37:36 <toni37> what mathematical meaning has 'undefined' function?
22:38:01 <c_wraith> "bottom" in domain theory
22:38:30 <toni37> can you be more specific?
22:38:36 <c_wraith> that's pretty specific.
22:39:08 <dsal> ⊥
22:39:16 <koz_> [insert obvious joke about top and bottom]
22:39:24 <dsal> I forgot what top is.
22:39:29 <dsal> We talk about bottoms a lot more.
22:39:29 <c_wraith> http://www.cs.nott.ac.uk/~pszgmh/domains.html
22:39:55 <dsal> That font is great.
22:40:53 <toni37> c_wraith: thank you :D
22:41:34 * koz_ was expecting comic cans.
22:41:38 <koz_> s/cans/sans/
22:41:47 <dsal> division by zero, sum of an infinite list, etc... are ⊥
22:42:04 <dsal> division by length of an infinite list
22:43:06 <koz_> dsal: Division of the length of an infinite list by zero?
22:43:19 <p0a> You can also use undefined to denote features that you will add later, like `coolFeature = undefined'
22:43:22 <dsal> That might wrap around.
22:43:24 <koz_> ("yo dawg, we heard you like bottom...")
22:43:48 <dsal> removeBeforeFlight = undefined
22:43:54 <p0a> I don't get it?
22:44:15 <dsal> I was referring to koz_' example.
22:44:23 <p0a> oh right
22:44:39 <p0a> sorry I'm tired
22:45:23 <dsal> ⊥+ ⊥ = ⊤
22:45:32 <dsal> That translates to "Two wrongs make a right."
22:46:21 <dsal> > undefined + undefined == defined
22:46:23 <lambdabot>  error:
22:46:24 <lambdabot>      • Variable not in scope: defined :: Integer
22:46:24 <lambdabot>      • Perhaps you meant ‘undefined’ (imported from Prelude)
22:46:35 <dsal> If defined were defined, we'd know the answer.
22:47:14 <toni37> lol
22:48:12 <toni37> reffering to this https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form we can generate an instruction set using bnf grammar?
22:49:13 <dsal> You mean you want a BNF parser to generate syntax defined by BNF?
22:49:31 <dsal> That seems like something everybody would do all the time. heh
22:50:45 <toni37> what formal model generates the instruction set of a cpu?
22:52:54 <koz_> toni37: What do you mean by 'formal model'? Which CPU?
22:53:03 <dsal> OK.  I solved the mystery.
22:53:06 <dsal> > undefined + undefined == defined
22:53:08 <koz_> Also, what do you mean by 'generates'?
22:53:08 <lambdabot>  True
22:53:24 <toni37> let's consider the 8080 architecture
22:53:27 <dsal> Two wrongs make a right.
22:53:40 <toni37> how intel defined the ISA?
22:55:10 <koz_> They just... did? They wrote a bunch of instructions, and decided how it affects registers.
22:55:53 <toni37> everything has to come from something
22:56:20 <dsal> Is this a religious argument?
22:56:24 <toni37> nope
22:56:52 <dsal> I accidentally made one wrong make a right when I made two wrongs make a right.  My ethics are broken this evening.
22:56:54 <toni37> but if we do things without order will cause chaos
22:56:56 <dsal> > undefined == defined
22:56:58 <lambdabot>  True
22:57:12 <dsal> > defined < defined
22:57:15 <lambdabot>  error:
22:57:15 <lambdabot>      • No instance for (Ord Defined) arising from a use of ‘<’
22:57:15 <lambdabot>      • In the expression: defined < defined
22:57:25 <dsal> Yep.  No order == defined is chaos.
22:57:57 <toni37> let's consider the output of an dfa, which could be a parser
22:58:06 <toni37> that parser is generated using a given DFA
22:58:21 <toni37> what formal model can be used to generate the ISA?
22:58:34 <toni37> how can we decide the instruction types?
22:58:39 <dsal> This is very confusing.
22:58:45 <toni37> why?
22:58:48 <koz_> toni37: You've got their process backwards.
22:58:52 <dsal> You want to use a BNF to generate an instruction set, and a DFA to generate a parser?
22:58:58 <koz_> Intel's engineers didn't start with a mathematical model.
22:59:07 <koz_> They started with 'stuff people wanted their CPU to do'.
22:59:10 <toni37> ok, let's forget about them and remember about math
22:59:24 <koz_> Then they looked at what physical electronic components could be used to do this, or something close to it.
22:59:47 <toni37> and bill gates camed to wash everyone's brain
22:59:50 <dsal> > abs (-128 :: Word8)
22:59:52 <lambdabot>  128
22:59:56 <koz_> toni37: The problem is, 'math' isn't a thing. You're asking a very vague, very high-level, and in my view mostly unanswerable, question.
23:00:11 <koz_> Bill Gates has nothing to do with this.
23:00:21 <koz_> You can't just handwave 'how do i instruction set from math' and expect a coherent answer.
23:00:25 <toni37> there must be a way to make it right
23:00:34 <koz_> It's heavily dependent on what _exactly_ you mean.
23:00:41 <dsal> This reminds me.  I'm out of mushrooms.
23:00:47 <koz_> What _exactly_ are you trying to describe.
23:00:55 <koz_> dsal: Hallucinogenic ones?
23:01:06 * dsal ...
23:01:18 <toni37> koz_: from amsterdam sucks
23:01:30 <toni37> a way to build a formally defined computer
23:01:45 <koz_> toni37: What about a computer are you trying to formally define?
23:01:58 <dsal> And like, do?
23:02:01 <koz_> I can 'formally define' a computer as a two-counter automaton.
23:02:31 <koz_> However, I would argue that this definition isn't really great, because a) it tells us nothing about how to actually build one, and 2) it wouldn't solve many useful problems in anything resembling reasonable time.
23:02:35 <dsal> I built a thing that parses simple math expressions and made an Arbitrary instance of the expression so I could have it generate expressions that I could send through my expression serializer to test my parser.
23:03:04 <dsal> The arbitrary expressions themselves aren't very useful.
23:03:24 <dsal> But they've valid math, I guess.
23:03:48 <toni37> you can define a basic calculator and call it computer as well
23:04:05 <dsal> Thanks, I guess.
23:04:05 <Axman6> not if it can't make decisions
23:04:10 <koz_> toni37: My point is, your entire line of questioning is too vague for me to give any sensible answer.
23:04:25 <toni37> maybe is from mushrooms
23:04:42 <koz_> toni37: I'm not going to speculate on what hallucinogens you imbibe when.
23:05:00 <toni37> i'm done with that shit, i tried almost everything
23:05:11 <koz_> Clearly.
23:05:25 <dsal> Probably good to get some sleep after such a day.
23:05:40 <toni37> maybe this is why i can't find someone to discuss in ambstract terms
23:05:49 <koz_> dsal: Rofl.
23:05:51 <toni37> abstract*
23:06:04 <koz_> ambstract - a combination of ambiguous and abstract.
23:06:18 <koz_> That's a useful neologism I might start using.
23:06:44 <dsal> Man, this project was such overkill.  It was one of those number puzzle things where you have numbers and operators and you have to figure out where to stuff operators in the numbers to get a particular value.
23:07:29 <toni37> backtracking
23:07:32 <dsal> That takes us back to undefined, right?  It's like, the most abstract function we have in haskell.  Fits *everywhere*
23:07:46 <toni37> you mean id?
23:07:55 <koz_> :t undefined
23:07:56 <dsal> id is very concrete
23:07:56 <lambdabot> a
23:08:00 <koz_> :t id
23:08:01 <lambdabot> a -> a
23:08:07 <koz_> There's a world of difference there.
23:08:10 <dsal> id can only do exactly one thing exactly one way.
23:09:46 <toni37> dsal: it's very deep this shit
23:10:37 <toni37> i mean, fits everywhere, but it exists only if you don't consider it
23:10:55 <dsal> > undefined + undefined == defined
23:10:58 <lambdabot>  True
23:11:27 <toni37> > undefined + undefined == defined
23:11:29 <lambdabot>  True
23:11:31 <toni37> wtf
23:11:35 <Axman6> leave the javascript out of here please
23:11:40 <dsal> haha
23:11:51 <flux77> Hi, I'm new to the Haskell ecosystem. I'm looking for a string templating library. Are there any standard/popular ones used by Haskell programmers? Are there any that are type-safe too?
23:12:30 <dsal> > undefined + undefined /= defined
23:12:32 <lambdabot>  False
23:13:03 <Axman6> flux77: what sort of templates? what features do you want?
23:14:21 <jackdk> @hackage formatting is one I like
23:14:21 <lambdabot> http://hackage.haskell.org/package/formatting is one I like
23:14:26 <jackdk> @botsnack
23:14:26 <lambdabot> :)
23:14:50 <Axman6> yeah formatting ias great for small strongs/printf style stuff
23:14:55 <Axman6> strings too
23:14:57 <flux77> Axman6: I intend to use the templating library to template configuration files, code, text documents, emails, etc. I previously used jinja (Python), which has conditionals and loops.
23:15:26 <jackdk> formatting is probably not the one for you
23:15:54 <Axman6> how about https://hackage.haskell.org/package/ginger
23:16:18 <p0a> I really like Haddock 
23:16:20 <p0a> what a great feature 
23:16:51 <flux77> Axman6: Interesting. Thanks. It could solve my greatest annoyance with Jinja: lack of type safety.
23:17:31 <dsal> Ah, I finally realized my mistake.
23:17:38 <dsal> > undefined == defined
23:17:40 <lambdabot>  *Exception: Prelude.undefined
23:17:43 <dsal> > undefined + undefined == defined
23:17:46 <lambdabot>  True
23:18:00 <dsal> OK.  two wrongs make a right, but not one wrong.  I can go to bed now.
23:18:53 <Axman6> I'm watching you like a hawk dsal
23:20:04 <dsal> heh.  I've got a contact high from toni37
23:21:40 <Axman6> you might want to get tested
23:22:06 <dsal> heh.  I think rested will suffice.
23:25:29 <p0a> Can you use LaTeX in Haddock?
23:25:55 <koz_> p0a: Yes.
23:26:03 <koz_> See also: literate Haskell.
23:26:39 <dsal> literate haskell is pretty neat.
23:26:43 <p0a> I don't understand it 
23:26:45 <dsal> I wrote code at work in markdown.
23:26:54 <Axman6> you can use Haskell in LaTeX
23:27:06 <p0a> I don't want to
23:27:07 <p0a> lol
23:28:49 <p0a> How can haddock use latex?
23:28:56 <dsal> I think pandoc will let you manipulate LaTeX using haskell without knowing either.
23:29:08 <p0a> It seems --latex generates the usual files of latex
23:29:20 <p0a> but I'd like the .html files of the docs to have latex (like KaTeX)
23:29:33 <dsal> What does it mean for html files to have LaTeX?
23:29:49 <Axman6> yeah that doesn't make sense
23:29:53 <Axman6> MAthML maybe
23:29:54 <dsal> Does my browser render LaTeX?  That'd be nice.  I don't much like HTML anymore.
23:30:32 <koz_> dsal: Unlikely, without some serious JS.
23:31:14 <p0a> You can look at KaTeX that
23:31:16 <p0a> https://katex.org/
23:33:10 <dsal> Isn't TeX written in WEB?  I've clearly been misled.
23:34:49 <p0a> I doubt you're the misled one here dsal
23:38:48 <dsal> I've not been tempted to do much fancy stuff with haddock, but my literate Haskell at work is super fancy with sections and sequence diagrams and stuff.
23:39:20 <dsal> I had some major tooling issue with lhs last time I tried, though.  I can't remember what.
23:39:27 <dsal> Probably everything.
23:41:35 <dsal> But to close the loop, latex is written in a literate programming language called web. Haddock targets the web, but not via latex unless you use pandoc which was written in haskell and can convert your latex to html.
23:44:35 <p0a> when I want to continue the function definition
23:44:45 <p0a> do I do = <break line> ... or <break line> = ...
23:45:37 <dsal> ? Continue?
23:45:59 <dsal> :t fix
23:46:00 <lambdabot> (a -> a) -> a
23:46:16 <p0a> ?
23:46:27 <p0a> It's an issue of style I suppose... I went with the frmer 
23:46:32 <dsal> Why is to line broken?  What do you mean continue?
23:47:20 <p0a> yeah break a line 
23:47:23 <p0a> it's just too long
23:47:56 <dsal> There's probably a better way. Depends on the line.
23:48:46 <dsal> Sometimes the line can be reinforced to hold more weight, but often, it just never needed to be that long to begin with.
23:49:42 <p0a> lol
23:49:44 <p0a> what are you on about
23:50:29 <dsal> Your question was similar to "how long is a string?"
23:51:17 <dsal> > cycle "all work and no play makes Jack a dull boy. "
23:51:19 <lambdabot>  "all work and no play makes Jack a dull boy. all work and no play makes Jack...
23:51:23 <p0a> so if 1.0 can be an instance of a Fractional
23:51:36 <p0a> why does my f :: Float -> Float complain that f 1.0 can't be applied to Double?
23:51:37 <dsal> :t 1.0
23:51:38 <lambdabot> Fractional p => p
23:52:02 <dsal> Need more context
23:52:04 <Axman6> given the code you have shared that shouldn't complain
23:52:15 <Axman6> there is no reason why that exact code should not work
23:52:28 <p0a> okay let me try 
23:52:39 <Axman6> if, howeverm you are doing something like let x = 1.0 :: Double in f x then yes, that is wrong
23:52:49 <p0a> this is my code https://pastebin.com/e4K0MC5K
23:53:03 <p0a> and I tried `Circle 1.0 1.0 1.0' in `stack repl'
23:53:20 <dsal> :t pi
23:53:22 <lambdabot> Floating a => a
23:53:49 <Axman6> can you give us exactly what you tried in ghci and what error you got? add it to the paste
23:54:03 <p0a> okay
23:54:26 <Axman6> because based on all the inforation you've given us there's no reason that shouldn't work
23:55:11 <p0a> https://pastebin.com/FDtFriw1
23:55:57 <dsal> Your Lib doesn't export Circle
23:56:09 <p0a> oh god
23:56:11 <p0a> thank you 
23:56:19 <dsal> Just get rid of the () 
23:56:32 <dsal> Export everything
23:56:48 <p0a> heh I was aso wondering why they weren't showing up in the docs 
23:56:50 <p0a> but now I know...
23:56:58 <Axman6> see if you'd told us what the actual error was 5 minutes ago we could have told you that right away
23:58:00 * dsal sleeps now that all mysteries have been solved
23:58:00 <p0a> My bad 
