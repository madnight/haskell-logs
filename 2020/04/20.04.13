00:00:14 <freeman42x[m]> average: you first need to know Haskell and create something preferably with little documentation for people to want to DM you badly
00:00:26 <average> freeman42x[m]: Great idea !!
00:00:36 <average> freeman42x[m]: but how did you get hooked on this tool/app of dmj` ?
00:00:40 <monochrom> My friend's child showed me a browser game in which pacmen eat other pacmen and become bigger.
00:00:46 <average> freeman42x[m]: what does it do that makes it so sought after?
00:01:11 <average> monochrom: agar.io?
00:01:28 <zincy_> dmj` made a great library and is an extremely helpful person. End of story.
00:01:43 <average> zincy_: yet it sounds like he wrote little docs for it
00:01:52 <freeman42x[m]> average: I did what I do before making a decision. I knew I needed something to do a web UI so I compared the different options. Miso was the best option for the project I needed it for.
00:01:56 <average> dmj`: congratulations on your small-docs idea
00:02:07 <MarcelineVQ> XD
00:02:07 <maerwald> what is this trolling, can someone clean this up?
00:02:32 <average> maerwald: you're literally the only one complaining
00:02:55 <Geekingfrog> https://pastebin.com/a6FqgUpZ I'm trying something similar to an open sum type with a type level list. But I can't figure out how to "handle effects". That is, a function can deal with a certain type, and if the given variable isn't of that particular type, then I can reduce my type level list. I can't figure out how to do that last bit though.
00:03:01 <monochrom> Not exactly agar.io because it was really pacmen.
00:04:23 <average> monochrom: let's write a shitty viral game together
00:04:31 <average> monochrom: in vanilla js or some shit
00:04:35 <average> monochrom: and we'll make some money
00:04:46 <MarcelineVQ> average: he's a teacher, they don't like money
00:05:06 <average> MarcelineVQ: teachers need money to eat
00:05:21 <average> monochrom: do you not eat?
00:05:23 <MarcelineVQ> Yes, and you need to poop, but if you really like doing it...
00:07:12 <average> MarcelineVQ: you're putting monochrom on a pedestal.. why..
00:08:06 <maerwald> this is -blah quality
00:08:13 <zincy_> Because he has incisive dry wit which rivals any troll yet brings a wealth of knowledge to the channel on Haskell
00:08:35 <monochrom> :)
00:09:20 <MarcelineVQ> average: Because I​ put him on a pedal-stool one time and he got all over the floor
00:09:42 <zincy_> :D
00:09:45 <average> one thing is for sure: I've never seen a fat Haskell programmer, and that's because they don't eat much
00:09:49 <average> and we know why
00:10:53 <MarcelineVQ> Sounds about right.
00:15:25 <freeman42x[m]> average: Haskell only had 30 years since it was created to actually allow developers to create software that is widely used and useful. You can't demand so much from Haskell developers when they had so little time to do it. Maybe if they had the same amout of time as Java, Ruby, PHP, JavaScript, C# or Scala... languages which have helped create a lot of useful software that is useful and used. <- yes, that is sarcasm
00:16:40 * ski . o O ( "Let me have men about me that are fat, / Sleek-headed men and such as sleep a-nights. / Yond Cassius has a lean and hungry look, / He thinks too much; such men are dangerous." )
00:17:29 <Welkin> the lady doth protest too much
00:19:13 <dmj`> average: why don't they eat much
00:19:44 <nshepperd2> eating can have dangerous side effects
00:23:53 <koz_> nshepperd2: Eating is in IO.
00:24:03 <koz_> Async IO if preparation is involved.
00:24:09 <koz_> (since you can eat the ingredients)
00:25:46 <zincy_> Useful is the dirtiest word in software.
00:27:50 <Welkin> I think you mean utilizeful!
00:37:33 <freeman42x[m]> Trying to output the _log part of the model here: https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/src/Main.hs#L135 The String that is currently there is displayed correctly. If I use `_log mode` it says it can't match `String` with `View Action` which is weird since the String literal worked fine... so there is some implicit conversion or something going on here. I tried using: `toView $
00:37:33 <freeman42x[m]> _log model` and that errors with `No instance for (ToView String) arising from a use of "toView"`. Any advice on how can I do this?
00:39:27 <freeman42x[m]> I'd prefer to keep `_log :: Text` instead of `_log :: String` if possible
00:54:18 <juri_> is there anything quicker than StateT for manipulating a continually increasing counter?
00:54:36 <maerwald> IORef
00:54:53 <ski> perhaps an explicit accumulator
00:54:54 <c_wraith> I doubt IORef benchmarks better
00:55:06 <maerwald> c_wraith: why?
00:55:14 <c_wraith> card-marking
00:55:35 <c_wraith> the whole extra indirection, in general, really
00:56:02 <c_wraith> StateT is just passing a parameter around.
00:56:31 <maerwald> yes and it doesn't mutate
00:56:46 <c_wraith> Neither does IORef
00:57:10 <maerwald> https://books.google.de/books?id=rIVcDgAAQBAJ&pg=PA200&lpg=PA200&dq=haskell+ioref+performance&source=bl&ots=coVrtIlYac&sig=ACfU3U2V6rim_9bPi52RsT_g3v16EeMiXA&hl=de&sa=X&ved=2ahUKEwiR_ILD9uToAhVCcZoKHTzyCNYQ6AEwAXoECAsQMA#v=onepage&q=haskell%20ioref%20performance&f=false
00:57:16 <maerwald> Says IORef is fast
00:57:25 <c_wraith> It's slower than passing a parameter
00:57:48 <c_wraith> IORef is good for sharing
00:58:03 <maerwald> not sure about that, especially with StateT
00:58:06 <maerwald> which is monadic
00:58:07 <c_wraith> but if you're just doing linear threading, you can do better with parameter passing
00:58:21 <maerwald> And there is proof that e.g. ReaderT is 10% slower at least than parameter passing
00:58:27 <maerwald> So likely that applies to StateT as well
00:58:40 <c_wraith> IORef has to be at the very best 50% of the speed of parameter passing
00:58:56 <maerwald> Do you have a reference to that?
00:58:59 <c_wraith> because of the double indirection
00:59:24 <c_wraith> There are all sorts of mutable counter primitives that you could point to
00:59:56 <c_wraith> IORef in particular is very bad to use for holding a counter
01:03:59 <monochrom> IORef is the slowest. State is faster. f n = f (n+1) is the fastest.
01:04:20 <ClaudiusMaximus> i got a massive speedup in one concurrent project using an atomic int counter vs atomicModifyIORef
01:05:08 <monochrom> Some years ago a beginner used IORef for a counter. I helped them change it to f n = f (n+1) and it went very fast.
01:07:39 <maerwald> That's kind of sad
01:07:59 <c_wraith> it's just what the type does
01:09:12 <monochrom> Recall that f n = f (n+1) for Int is eligible for unboxing and keeping n in a register directly.  IORef means you must rebox, put on heap, then store the pointer in the IORef.
01:10:20 <JavasucksMan> I'm lonely
01:10:37 <maerwald> weird https://marcotmarcot.wordpress.com/2010/03/13/performance-of-ioref/
01:11:51 <maerwald> over 3 minutes vs 1.5s
01:11:52 <maerwald> what the
01:13:23 <monochrom> list is involved eh? that can be a complication.
01:13:40 <maerwald> This is depressing either way
01:14:34 <freeman42x[m]> if I do `sudo cabal run` that will also generate some build artifacts which are only changeable by root and causes `cabal run` to fail later. Is there any easy way to just run as root a Haskell executable already created using `cabal build`?
01:14:54 <maerwald> oh wait, I read that wrong
01:15:13 <maerwald> 3m46s vs 1m29s
01:16:32 <juri_> maerwald: thanks for the book link regardess. some good stuff in there.
01:18:15 <monochrom> Today's GHC generates Core that works on Int# directly and no list.
01:20:48 <maerwald> So, who can beta the C version of 13s? :>
01:20:51 <maerwald> *beat
01:21:00 <freeman42x[m]> is MisoString required to be used instead of something like Text if I want to display it in the UI here? https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/src/Main.hs#L127
01:22:53 <maerwald> Imagine you hadn't pissed of dmj`, then you could ask him :)
01:24:06 <monochrom> Haha "<stdio.h>" disappeared. Amateur HTML writer.
01:25:00 <maerwald> lol
01:25:13 <freeman42x[m]> maerwald: what makes you think he is pissed or that I can't ask him?
01:25:24 <mr_sm1th> Does it make sense at all to print & read the Haskell 2010 report?
01:26:05 <ski> for what purpose ?
01:26:26 <maerwald> For reading?
01:26:35 <ski> presumably, yes
01:26:44 <freeman42x[m]> is there any Haskell function that gives you a newline string that is OS dependend?
01:26:44 <maerwald> Well, then printing would enable one to read it, arguably
01:26:54 <maerwald> Now you could argue about environment etc
01:26:54 <c_wraith> dunno.  the plot is scant and the characterization is pretty thin.
01:27:35 <mr_sm1th> ski, just because I want to really know all the standard functions
01:28:11 <mr_sm1th> and I want to have a reference for those handy
01:29:01 <ski> could possibly be useful, i guess
01:29:13 <monochrom> maerwald: It looks like gcc uses the following for mod 7: "imulq $613566757, %rax, %rax", "shrq $32, %rax".  I think I have heard of this kind of tricks before.
01:29:16 <Eduard_Munteanu> maralorn, be careful with JWT, it has security issues.
01:29:18 <mr_sm1th> thanks! Just wanted to make sure it's not all outdated for some reason.
01:29:49 <c_wraith> Well.  It is outdated in at least one big way, if you want to compare what it says to what GHC does.
01:30:25 <maerwald> Hmm, right. There should be a cost center analysis too
01:31:17 <dmj`> freeman42x[m]: MisoString is Text when compiling with GHC, JSString when compiling w/ GHCJS
01:31:31 <monochrom> I think the mod-7 trick is enough to explain a 5x difference like this.
01:32:00 <c_wraith> the Haskell 2010 report says `class  (Eq a, Show a) => Num a  where'
01:32:06 <monochrom> Because otherwise both ghc asm and gcc asm are honest-to-God 3-level for-loop code.
01:32:09 <c_wraith> GHC doesn't do that anymore
01:32:36 <maerwald> Now, what do I do for my imperative code when IORef is that slow?
01:32:47 <monochrom> Well, white lie, I didn't actually read ghc asm, but I know enough how Core becomes asm for this.
01:33:05 <monochrom> If you can, get rid of the IORef :)
01:34:03 <monochrom> If it's an IORef shared between several threads and you use it for atomicaModifyIORef, I would say that's already the best you can do for both speed and safety.
01:34:11 <maerwald> Dealing with threads, can't do parameter passing :>
01:34:19 <maerwald> ok
01:34:27 <c_wraith> At least for general-purpose data types
01:34:40 <c_wraith> for counters, as has been mentioned, there are the various atomic counter types
01:34:53 <maerwald> I have a buffer of 6 lines of ByteStrings that I update continously via IORef
01:35:19 <monochrom> C is not going to be much faster than this as soon as you bring in pthread mutex.  Faster in a minor way, sure.
01:36:13 <monochrom> For no compromise between both speed and safety, you would be looking at using a compare-and-swap asm instruction directly.
01:36:32 <monochrom> and possibly a couple of memory barrier instructions.
01:37:26 <monochrom> Also consider how pthread is more overhead than ghc green threads.
01:38:01 <freeman42x[m]> > freeman42x: MisoString is Text when compiling with GHC, JSString when compiling w/ GHCJS
01:38:01 <freeman42x[m]> ah, that's great, thank you for clarification
01:38:04 <lambdabot>  <hint>:1:55: error: parse error on input ‘,’
01:42:25 <freeman42x[m]> so, does Haskell define anywhere `newline = "\n"`, since this would meet the property of being OS dependent ? I'd prefer using a `newline` symbol over using the literal `"\n"` for obvious reasons
01:42:49 <maerwald> write one?
01:43:01 <maerwald> Shouldn't be hard, that's why probably no one bothered
01:43:24 <maerwald> or: it is hard, that's why no one bothered as well
01:45:19 <freeman42x[m]> dmj`: having a bug with appending of messages to the textbox: https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/src/Main.hs If I click the Install button multiple times it will work. If I make any edit to the textbox it breaks. Is that related to how Miso works? I will just make it readonly for my usage, but I am curious why it breaks. Do I need to handle onchange event or something with
01:45:19 <freeman42x[m]> Miso?
01:45:58 <monochrom> freeman42x[m]: If possible, just use \n, and let the System.IO output functions to do the actual conversion. Take a look at System.IO doc for details and settables.
01:46:24 <monochrom> Likewise, System.IO input functions already give you \n without \r.
01:46:57 <freeman42x[m]> > Shouldn't be hard, that's why probably no one bothered
01:46:57 <freeman42x[m]> maerwald This is entire definition `newline = "\n"` minus the type annotation. Why would this be hard? And since it si so easy and useful why would it not be easy to find? There is some aha moment here and I don't know what it is
01:46:59 <lambdabot>  <hint>:1:18: error: parse error on input ‘,’
01:47:31 <MarcelineVQ> constants are usually thing you think up and apply per project, maybe that is defined somewhere, but if it is did you save any time looking for it over writing it?
01:47:41 <freeman42x[m]> monochrom: I'd prefer using a `newline` symbol over using the literal `"\n"` for obvious reasons
01:48:23 <monochrom> OK, then you go ahead define it for your use.
01:48:28 <maerwald> https://hackage.haskell.org/package/word8-0.1.3/docs/Data-Word8.html#v:_lf
01:48:51 <monochrom> Culturally you can get a glimpse of why other people didn't care from functions like putStrLn, lines, unlines.
01:49:06 <dmj`> freeman42x[m]: yea, if you want synchrony between editing the textarea you'll need onChanged UpdateLog, data Action = UpdateLog MisoString, updateModel (UpdateLog s) m = noEff m { _log = s }
01:50:31 <freeman42x[m]> dmj`: I understand, thank you. Could you confirm whether you are dmijo / David Johnson please?
01:50:46 <maerwald> Yes, I also want you to confirm
01:50:47 <dmj`> freeman42x[m]: I can neither confirm nor deny anything, I plead the 5th.
01:50:50 <monochrom> It's easy to cross the line from "is it in some common library" to "why don't you people just bloody add it to the standard library what's so hard". Crossing that line is bloody unproductive and irrespectful of other people's preference.
01:50:52 <maerwald> Lol
01:51:05 * dmj` leaves room
01:51:19 * MarcelineVQ sly hat-tips at dmj`
01:51:39 <freeman42x[m]> dmj`: It seems you really want me to mention you twice under contributors. wink wink nudge nudge https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/CONTRIBUTORS.md
01:52:07 <dmj`> I want a lawyer
01:52:31 <freeman42x[m]> dmj`: one lawyer will be provided to you by default
01:52:36 <MarcelineVQ> I need an adult
01:52:42 <freeman42x[m]> I AM an adult
01:52:46 <monochrom> I need an alibi
01:53:02 <freeman42x[m]> pecking order...
01:55:52 <MarcelineVQ> I​ need a heroooo ♪♪♪
01:56:29 <freeman42x[m]> > It's easy to cross the line from "is it in some common library" to "why don't you people just bloody add it to the standard library what's so hard". Crossing that line is bloody unproductive and irrespectful of other people's preference.
01:56:29 <freeman42x[m]> monochrom if you phrase it like `"why don't you people just bloody add it to the standard library what's so hard"` yeah... of course that is a bad way to get people to do something, regardless of how good that thing would be
01:56:32 <lambdabot>  <hint>:1:209: error: parse error on input ‘of’
01:57:59 <monochrom> "Why would this be hard?" is your own exact wording.
01:58:12 <freeman42x[m]> if I do `sudo cabal run` that will also generate some build artifacts which are only changeable by root and causes `cabal run` to fail later. Is there any easy way to just run as root a Haskell executable already created using cabal build?
01:58:23 <maerwald> sudo cabal...
01:58:25 <maerwald> erm
01:58:58 <monochrom> sudo the executable
01:59:21 <monochrom> Nevermind, misread.
01:59:34 <freeman42x[m]> monochrom: did I suggest adding it? No, I did not. I was asking why I can't easily find something that does that already.
01:59:39 <maerwald> cabal new-exec --verbose=0 --offline sh -- -c 'command -v YOUREXE'
01:59:42 <maerwald> then copy it somewhere
02:00:26 <maerwald> or do whatever you need inside -c ''
02:00:50 <freeman42x[m]> was asking if something is not already provided that does that via cabal or something easily. Rather than do that I would just make a link to the executable, in the root of the project
02:04:39 <monochrom> Yeah easiest to find the exe and copy it out or symlink etc.
02:05:22 <maerwald> cabal new-exec --verbose=0 --offline sh -- -c 'sudo YOUREXE'
02:05:32 <monochrom> :)
02:05:33 <MarcelineVQ> freeman42x[m]: did maerwald's suggestion make sense to you? you could also possibly copy the executable to a known location and run it from there.   cabal install --install-method=copy --overwrite-policy=always --installdir=knowndir && sudo knowndir/executabale
02:06:04 <maerwald> MarcelineVQ: cabal install will create an sdist, unpack it in a temp folder and build it there
02:06:06 <MarcelineVQ> probably want to cd to the dir actually..
02:06:11 <maerwald> quite unfortunate for local dev workflow
02:06:19 <freeman42x[m]> > cabal new-exec --verbose=0 --offline sh -- -c 'sudo YOUREXE'
02:06:19 <freeman42x[m]> didn't say anything about this since it would be just worse than just linking to the executable I think
02:06:21 <lambdabot>  error: Variable not in scope: cabal :: t0 -> aerror: Variable not in scope: ...
02:06:26 <maerwald> and it will also (potentially) throw away cabal.project files
02:06:36 <maerwald> Most people don't add those to extra-source-files
02:06:44 <maerwald> And then get confused why debug symbols missing etc
02:07:15 <MarcelineVQ> it does? I'll have to pay closer attention next time I do that, didn't notice that much activity
02:07:25 <maerwald> Yes
02:07:36 <maerwald> You'll rebuild the entire project
02:08:07 <maerwald> freeman42x[m]: what?
02:08:10 <MarcelineVQ> geeze it does :<
02:08:35 <maerwald> the one thing that stack does better, imo
02:14:40 <freeman42x[m]> yeah, will definitely go with symlink since I do not want to type or autocomplete this: ./dist-newstyle/build/x86_64-linux/ghc-8.6.5/haskell-editor-setup-0.1.0.0/x/haskell-editor-setup/build/haskell-editor-setup/haskell-editor-setup
02:16:42 <maerwald> And the symlink might randomly break or point to old executables :)
02:17:00 <maerwald> the location depends on ghc version and even your optimisation/debug settings
02:17:58 <fendor> cabal-plan does a nice job of obtaining the executable location
02:18:04 <freeman42x[m]> maerwald: well, this does not solve the problem either:  `cabal new-exec --verbose=0 --offline sh -- -c 'sudo YOUREXE'`
02:18:11 <freeman42x[m]> maerwald: so what should I do?
02:18:32 <maerwald> freeman42x[m]: yes it solves the problem
02:18:39 <freeman42x[m]> would prefer something I could check in to git so that every developer could easily use it
02:18:58 <maerwald> wrap the line I wrote in a shell script then
02:19:12 <freeman42x[m]> maerwald: doesn't the `YOUREXE` part of that command need me to give the full path with ghc version etc. ?
02:19:17 <maerwald> NO
02:19:31 <maerwald> assumptions... 
02:22:47 <MarcelineVQ> freeman42x[m]: cabal new-exec --help    "The PATH is modified to make all executables in the dependency tree available (provided they have been built already)." I'm not sure what all is included in the dependency tree but it's fair to say your package's executable should be in there
02:23:15 <freeman42x[m]> maerwald: you really should be more chill. Yeah, it works great, so it's what I need so I can add it to repository also. Cheers
02:23:48 <maerwald> Ask your questions better, read the responses better
02:23:59 <maerwald> Then it's less noise overall
02:24:45 <freeman42x[m]> maerwald: well, I am sorry for not being perfect. Feel free to rage at me.
02:27:34 <maerwald> Also, now you need to add me to your CONTRIBUTORS.md
02:27:37 <maerwald> xD
02:29:50 <freeman42x[m]> maerwald: good you mentioned since I forgot - was too distracted by your quick irritation with me. If you think replying with messages showing annoyance to others quickly is a good idea you might want to see these simulations: https://ncase.me/trust/
02:30:27 <maerwald> LOL
02:32:39 <MarcelineVQ> maerwald, these simulations say you have 3 weeks to live
02:33:06 <maerwald> that should be enough to finish my project
02:33:08 <MarcelineVQ> I can ask my friend to check them, he's a modeler, clay mostly.
02:40:22 <maerwald> freeman42x[m]: you should also add to your resume that you've worked with me in the past
02:40:33 <siraben> Has anyone written a course scheduling library in Haskell?
02:40:55 <siraben> I'm wondering if I should throw a constraint solver at it or implement a scheduling algorithm.
02:41:00 <freeman42x[m]> maerwald: wtf?
02:44:48 <freeman42x[m]> maerwald: does your resume contain the names of people you worked with? anyway, this is offtopic... write in DM if you want to continue
02:45:21 <MarcelineVQ> I wish I had a reason to put maerwald on my resume, what an opportunity
02:45:37 <maerwald> loool
02:48:46 <fweht> when defining lenses L:(X,S)->(Y,R) as pairs (L0:X->Y,L1:XxR->S), what is the intuitive meaning of the objects (X,S),(Y,R) in that category?  i think of L0 resp. L1 as getter resp. setter functions but how should i think of (X,S)?
02:49:03 <freeman42x[m]> MarcelineVQ: he famous, posh or something? dammit, I hope we won't all get banned for going offtopic. Guess no harm as long as... ah there comes a Haskell question
02:50:21 <MarcelineVQ> He's pretty famous, he's even allowed to use a rabite for his avatar
02:50:30 <maerwald> freeman42x[m]: it seems the mods are a little bit forgiving in these times, at least that's my impression
02:50:44 <maerwald> everyone is nervous and stressed, so
02:52:05 * maerwald gives freeman42x[m] a hug
02:53:41 <MarcelineVQ> You can get a band you wear on your wrist that's good for a certain number of OT's
03:01:47 <Empry> qq all. I will start learning Haskell from "Learn You a Haskell for Great Good! Miran Lipovaca" book. Its good idea?
03:02:04 <maerwald> No
03:02:13 <maerwald> pick a book with good exercises
03:03:08 <MarcelineVQ> specifically because LYAH doesn't have any, so you'll get through it and not really know how to write something
03:03:23 <maerwald> https://github.com/bitemyapp/learnhaskell#how-should-i-learn-haskell
03:03:32 <maerwald> The cis194 is very popular here
03:05:00 <Empry> maerwald, MarcelineVQ, thanks you
03:05:27 <[exa]> Empry: I can't say that LYAH is bad per se, but you certainly need to have your own motivation&experience for inventing and doing the exercises
03:06:07 <maerwald> It's for when you had 2 glasses of wine, but still want to get some haskell inside afterwards
03:06:08 <[exa]> Empry: if you are skilled in many other programming language, LYAH will probably do very quickly. Otherwise suggesting to take exercise-ish courses.
03:09:58 <solonarv> but also, insert obligatory disclaimer: it is a bit dated, so some of the code snippets and explanations won't be quite right
03:10:25 <solonarv> but this actually applies to a lot of the books out there, so it shouldn't necessarily stop you from picking a particular one
03:19:41 <Empry> [exa], solonarv, thx
03:27:34 <polyphem> siraben: i did a work-scheme scheduler using CSP Solver ...
03:27:54 <siraben> polyphem:  Ah, how did that go?
03:30:03 <polyphem> it works , but got rejected cause it is unpractical to use a computer at my workplace cause nobody ther can use a computer
03:30:49 <polyphem> siraben: i have it locally , wait a bit so i can push it on github
03:31:12 <siraben> polyphem: Ah, that would be very helpful, thanks!
03:32:52 <arahael> I couldn't stand LYAH.
03:36:41 <polyphem> siraben: its from nov2017 ; stack is atm getting up to date :( ; i' ll tell you when ready
03:37:09 <siraben> polyphem:  Thank you!
03:38:51 <iphy> in wl-pprint, how would you undo all indentation/nesting for one line? I'm pretty-printing C code, and I'd like the "#define" and other preprocessor directives to start in the first column, regardless of nesting level
03:43:11 <maerwald> anyone an idea how to get ghc for alpine 32bit?
03:50:38 <Geekingfrog> In a library I see the pragma {-# INLINE[3] xxx #-}. What does the [3] means ?
03:50:48 <maerwald> the phase
03:51:44 <Geekingfrog> compilation phase you mean ?
03:51:51 <maerwald> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#phase-control
03:52:03 <Geekingfrog> cool, thanks
03:52:06 <maerwald> the simplifier phase
03:52:40 <maerwald> I'm not really sure how to make use of those, without understanding how GHC works, but yeah
03:55:37 <maerwald> Alternatively, is it possible to run a glibc ghc on alpine?
03:58:52 <solonarv> maerwald: the main use of phase control, IIRC, is stuff like the list fusion framework in base
03:59:30 <maerwald> Yeah, show me a pretty doc for mere mortals that isn't a 200pages MS research paper
03:59:57 <solonarv> it lets you say things like: okay, at the start don't inline the list functions and instead apply these {-# RULES #-} to replace them with the easily-fusible formulations
04:00:14 <solonarv> now apply more {-# RULES #-} to do the actual fusion
04:00:47 <solonarv> finally, if there's any of that crud left over, replace it with the normal list functions again (and perhaps inline them)
04:30:34 <dibblego> is there an extension for local data type declarations? `let data X = X in ...`
04:30:57 <solonarv> dibblego: nope
04:30:59 <dibblego> k
04:31:04 <solonarv> at least, not in ghc
04:42:12 <mniip> is there not a Set k -> Map k () and/or Set k -> Map k k
04:43:55 <MarcelineVQ> I'm sure I saw that recently..
04:44:40 <mniip> I've come up with a cool trick recently
04:45:03 <MarcelineVQ> Oh I was just thinking of fromSet
04:45:06 <mniip> if you have a processing function A -> B that has some "wind up" time you might want to make it process in batches like [A] -> [B]
04:45:11 <solonarv> yeah fromSet works for these
04:45:38 <mniip> but this listy thing retains no association between the input As and the output Bs
04:45:48 <solonarv> fromSet myset (const ()) or fromSet myset id
04:45:54 <mniip> so you might opt in for something like [A] -> Map A B
04:46:24 <mniip> now my trick is to go for Traversable f => f A -> f B
04:46:43 <mniip> which has in particular nice instantiations for f~[], f~Vector, f~Identity and most importantly f~Map A
04:47:23 <solonarv> oh, I like that
04:55:38 <Guest23> is this a place where i can ask some junior help with conduits?
04:55:56 <yushyin> sure, try us.
04:56:38 <Guest23> thx, i'll try to simplify my code without loosing details:
05:01:54 <zincy_> What are some interesting ways control structures can be created with effects in Haskell
05:02:02 <Guest23> i dont know if its required to go depper in api to get an answer, but i'm using this function: https://hackage.haskell.org/package/irc-conduit-0.3.0.4/docs/Network-IRC-Conduit.html#v:ircClient
05:02:22 <Guest23> how do i yielding data from consumer?
05:02:23 <zincy_> I am looking at monad-loops but wondering if there is anything else that could be inspiring.
05:03:38 <Guest23> say i got some IrcMessage and i want to yield a message depends on what i got
05:04:27 <Guest23> *IrcEvent
05:05:04 <Guest23> i cant just use yield-function inside of my consumer, so how do i give information to my producer?
05:05:28 <mniip> zincy_, zygohistomorphic prepromorphisms
05:05:47 <mniip> % :t zygoHistoPrepro
05:05:48 <yahb> mniip: forall {t} {b} {a}. (Corecursive t, Recursive t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (Control.Comonad.Trans.Env.EnvT b (Control.Comonad.Cofree.Cofree (Base t)) a) -> a) -> t -> a
05:08:02 <polyphem> siraben: now its up , but its rarly documented , but perhaps it helps as starting point .... https://github.com/polyrod/dplan
05:09:10 <siraben> polyphem:  Thanks, I'll take a look.
05:10:44 <zincy_> mniip: are you joking?
05:10:56 <zincy_> Or serious?
05:11:52 <mniip> maybe? ;)
05:14:32 <Guest23> yushyin, if my question was unclear i can put some code on pastebin
05:16:15 <Athas> I have written a parallel ray tracer in Haskell: https://github.com/athas/raytracers
05:16:15 <Athas> It is extremely slow.  Profiling shows that a lot of the time is spent in this function, but I don't see any obvious way to improve it, short of going all-in with unboxed low-level stuff: https://github.com/athas/raytracers/blob/master/haskell/Raytracing.hs#L71-L97
05:17:22 <Athas> This is the top of the profiling report: https://gist.github.com/athas/32c3aadf90227fab01b369867165917e
05:19:38 <gentauro> Athas: Hmmm, why is `OCaml multi-core` so much faster than the Haskell version? https://github.com/athas/raytracers#results
05:21:04 <Athas> Because OCaml put in the effort, I guess.  It doesn't have any low-level optimisations.
05:22:43 <MarcelineVQ> "aabbHit  %alloc 0.0"    [x] doubt     do you happen to have a more expanded aabbHit profile?
05:25:05 <Athas> Yes, that looks fishy to me as well.  I do not.  How could I create one?
05:25:42 <Athas> Or rather, aabbHit can definitely run with zero allocations, but I'd be (positively!) surprised if GHC could make it do that.
05:26:26 <MarcelineVQ> If it's possible at least, would be interesting to see work iter is doing 
05:27:33 <Athas> It's just a bunch of comparisons of floats, so if GHC unboxes all of it...
05:28:03 <MarcelineVQ> I'm not sure, I've not tried to profile in a long time, if we can get an entry count for aabbHit and  if we can see what iter is doing we can find out if strict fields would help for Ray and AABB
05:28:36 <Athas> I've added {-# LANGUAGE Struct #-} to the entire program and it has a small impact, but not all that much.  I think GHC does a pretty good job of strictness analysis alreayd.
05:29:11 <gentauro> Athas: it looks like the OCaml version have more parameters than the other apps https://github.com/athas/raytracers/tree/master/ocaml#running
05:29:26 <Athas> Yes, but I don't pass any of them.
05:29:28 <gentauro> `--cores number-of-cores` and `--chunk-size-render chunk-size-of-pixels`
05:29:41 <gentauro> Athas: roger, but are there some defaults?
05:29:56 <Athas> Yes, I think 8 workers or something like that.
05:30:01 <Athas> Which is also what I use for the Haskell version.
05:30:18 <gentauro> Roger that
05:30:27 <Athas> Both the MPL and OCaml versions use some kind of semi-explicit chunking for the parallel map, which is probably advantageous, but I don't think that's why Haskell is slow.  It doesn't look like scheduler overhead.
05:33:33 <ph88> linear types proposal got merged :)
05:34:09 <gentauro> ph88: to GHC?
05:34:33 <ph88> for GHC
05:34:58 <ph88> https://github.com/ghc-proposals/ghc-proposals/pull/111#event-3226482709 
05:35:18 <gentauro> Athas: https://github.com/athas/raytracers/blob/master/ocaml/ray.ml#L311-L316
05:35:34 <gentauro> hmmm, I don't see that in the F# code neither
05:36:05 <Athas> No, the F# code also just does a parallel map, with the chunking left to runtime/library code.  I prefer that, but MPL and OCaml doesn't provide such nice APIs.
05:37:23 <gentauro> Athas: well, last time I worked with F# and (array) parallelism, I added this `hack` to make it faster -> https://github.com/delegateas/Daxif/blob/8bb9bf3db4a7aa0602294f921c40428c44d82fc1/src/Delegate.Daxif/Common/FSharpCoreExt.fs#L8-L20
05:37:31 <gentauro> so I'm guessing this would also apply for Haskell
05:37:36 <gentauro> (chunking)
05:38:07 * MarcelineVQ slowly builds athas deps
05:38:54 <gentauro> MarcelineVQ: you know when it builds slow, it's going to be fast ...
05:40:15 <MarcelineVQ> Athas: how do I run the benchmark as you have in your profiling output?
05:40:39 <MarcelineVQ> build + run
05:43:52 <Athas> MarcelineVQ: cabal run -v0 bench-ray -- +RTS -N8
05:44:45 <Athas> I wish I could figure out how to make 'cabal bench' pass RTS options...
05:45:07 <Athas> Oh, actually -XStrict looks like it has a pretty significant impact after all.  I'll update the timings.
05:46:47 <maerwald> Athas: I have Strict and StrictData enabled on most of my projects now :P
05:46:58 <Athas> What is the difference between the two?
05:47:18 <maerwald> StrictData is for data types
05:47:24 <maerwald> It's pretty safe
05:47:24 <Athas> So I need both?
05:47:31 <maerwald> Strict is for functions and can break your code
05:47:51 <Athas> Won't break this number cruncher!
05:48:06 <maerwald> yes, the only time it broke mine was when I had defined monadic combinators
05:48:10 <maerwald> obviously, there it matters
05:49:38 <gentauro> maerwald: so `StrictData` is just: `data Foo a b c = F !a !b !c`?
05:49:44 <maerwald> yep
05:49:52 <gentauro> roger
05:50:13 <maerwald> https://gitlab.haskell.org/ghc/ghc/-/wikis/strict-pragma
05:50:25 <maerwald> Strict is a little more tricky
05:50:28 <Athas> Alright, strict Haskell is much faster than F#.
05:50:46 <Athas> Closing the gap to OCaml!
05:51:28 <maerwald> I believe Strict is a good choice for apps
05:51:42 <mjrosenb> is there an equivalent to Data.Map.mapWithKey for Data.Array?
05:51:44 <maerwald> But for libraries, I am not sure
05:51:55 <MarcelineVQ> Athas: try -funbox-small-strict-fields/-funbox-strict-fields too, in case StrictData doesn't imply it, though it might
05:52:01 <maerwald> Athas: also see https://github.com/yesodweb/wai/pull/752#issuecomment-501531386
05:52:14 <mjrosenb> or do I have to go through Data.Array.elems and Data.Array.array?
05:52:31 * MarcelineVQ waits again for profiling libs to build
05:53:29 <gentauro> building my `array` takes around `real: 5m48.639s, user: 5m42.664s, sys: 0m6.251s` for every single minor change ...
05:54:09 <gentauro> s/`array`/`array lib`/
05:55:01 <Athas> maerwald: that didn't seem to have an impact.
05:55:43 <Athas> Docs up front: https://github.com/athas/raytracers/tree/master/haskell#tldr
05:57:36 <solonarv> mjrosenb: array's API is disappointingly bare in general, I find
05:58:37 <svipal> that's one of the reasons I really like massiv
06:00:52 <Athas> Interestingly, while Strict makes a huge performance impact, the relative cost centres are almost unchanged: https://gist.github.com/athas/db2c57e9b829c74050ea9053d028c8ce
06:06:35 <MarcelineVQ> gosh it takes time to build profiling libs
06:07:35 <svipal> yeah
06:09:54 <maerwald> MarcelineVQ: Always have netflix on one monitor while doing haskell
06:10:24 <MarcelineVQ> usually it's my own stuff so it doesn't come up, I've already payed the attention fee incrementally
06:12:59 <MarcelineVQ> maerwald: but ditto, I do most stuff with something going on on the other screen
06:13:16 * maerwald wonders what it is
06:13:54 <f-a> as now when I make a release I need to change the version of my program in the cabal file («version: 0.0.0.1») and in Main.hs (for --help/--version) purposes. Is there a haskelly/sensible way to avoid this? i.e. to specify the version only once in .cabal? 
06:13:58 <MarcelineVQ> vinesauce, efap, wilburger game plays, older anime, the usual stuff
06:16:00 <solonarv> f-a: cabal generates a 'Paths_yourpackagename' module which contains the version (as well as some other info)
06:16:32 <Athas> f-a: this is how I deal with it: https://github.com/diku-dk/futhark/blob/master/src/Futhark/Version.hs
06:16:46 <Athas> I use the Paths_ module and also another package to get the Git commit.
06:17:00 <Athas> It is simple (except ew Template Haskell) and has worked without prolems for years.
06:17:24 <solonarv> f-a: cabal docs: https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code
06:17:45 <solonarv> also note that the template haskell is only for the git commit, you don't need it if you just want the version
06:17:47 <siraben> Can someone give an SKI term that blows up? I want to test my simulator
06:17:48 <MarcelineVQ> Athas: profiling really nukes your bench's :>
06:17:59 <siraben> I have (SII)(SII) for fixpoint, but I want to see a blowup
06:18:19 <f-a> excellent solonarv and Athas , many thanks
06:19:08 <stondo> hi all
06:19:40 <stondo> can anyone explain me why the zeros end up in the list? https://gist.github.com/stondo/c7915d043fae028119a4f17056a5086d
06:20:10 <stondo> I was expecting no element instead thanks to the filter in the list comp
06:21:15 <solonarv> siraben: you can write down a Y combinator (check wikipedia, it's a bit long) and then 'Y S' loops
06:21:23 <ski> (`S(K(SII))(S(S(KS)(S(KK)I))(K(SII)))', unless i made a mistake ..)
06:21:44 <siraben> Alright, looks good!
06:22:10 <siraben> Unfortunately I'll have to translate that to postfix, since the simulator is in EVM assembly syntax (like Forth)... 
06:22:23 <siraben> Maybe, (SII)((SII)(SII))?
06:23:01 <solonarv> SIIa = a a
06:23:03 <ski> (might have to apply it to a combinator, like `K' or `S', to saturate it)
06:23:10 <Athas> MarcelineVQ: yeah, but I think (hope...) that the hotspots stay the same.
06:23:36 <solonarv> so SII ((SII) (SII)) expands to ((SII) (SII)) ((SII) (SII)) and then that just loops
06:24:36 <solonarv> stondo: by "the filter" you mean the 'n `mod` 2 == 0' bit, yes?
06:24:42 <ChaiTRex> stondo: 0 `mod` 2 == 0.
06:25:23 <mjrosenb> is it possible (or even reasonable) to have a state monad with two separate types, so, e.g. get :: StateRead a a; put :: a -> StateWrite a (), so I can know that a function only reads from the state, but doesn't write to it by looking at its type?
06:26:45 <ChaiTRex> mjrosenb: Wouldn't that be a reader monad?
06:27:00 <ski> one could consider `Reader' as subtype of `State'
06:28:33 <ski> (we'd even have a retract situation)
06:28:35 <mjrosenb> but can you interchange Reader and State like that? e.g. do {put 5; x <- lift get; put (x*x);}?
06:29:27 <ChaiTRex> mjrosenb: If you want to ensure that a function can't write to the state, you don't allow put in the first place.
06:29:35 <ski> `lift' is for monad transformers
06:30:32 <ski> (unless this is a different `lift', of type `forall rs a. Reader rs a -> State rs a')
06:30:52 <mjrosenb> ski: this is a different lift
06:31:51 <ski> (and then you'd have the retraction being `lower :: forall rs a. State rs a -> Reader rs a'. and you want these to interact with `return' and `(>>=)' in some way)
06:31:52 <mjrosenb> ChaiTRex: I want to be able to put, but I also want to know if a function doesn't mutate the state (and/or I want to force a function to not update the state by restricting its type)
06:32:16 <ski> another example is `Maybe' vs `[]'
06:36:12 <mjrosenb> ski: neat, I think I can work with that.
06:36:40 <solonarv> mjrosenb: you can do something like this: 
06:36:47 <solonarv> https://gist.github.com/Solonarv/f6bcb0d46eb29ef631064a4cf48ab605
06:36:54 <mjrosenb> although wouldn't I want forall rs a. Reader rs a -> State rs a? since I want to be able to use a Reader inside my State?
06:37:00 <solonarv> but note that you can't actually write a Monad instance for it
06:37:16 <ski> mjrosenb : yes, that's the `lift'
06:38:12 <ski> note that `lower . lift = id', a retract situation. `lower' is a retraction (aka split epi), and `lift' the corresponding section (aka split mono)
06:38:33 <mjrosenb> ski: what is a better name for it, since lift is not a good one?
06:39:36 <jdartland> Hi Guys! First time here. I'm completely stuck trying to implement an Abstract DAG in haskell, all going fine but i have some unresolved type conflict that i just can't get my head around.... I've tried to isolate the problem with some part of the code together with the error provided in the pastebin. Would be so grateful if you have time to take a
06:39:37 <jdartland> look. https://pastebin.com/ruqZ9aQq  
06:40:04 <ski> perhaps `inject' and `project' ?
06:42:38 <solonarv> jdartland: what is the (Num a, Show a) on addVertexWeight for? doesn't seem to be used for anything
06:43:17 <f-a> mhhh I am trying to upload to hackage and get a 400 error, first time it happens
06:43:21 <f-a> Error uploading dist-newstyle/sdist/gscholar-rss-0.3.0.0.tar.gz: http code 400
06:44:11 <jdartland> solonarv I's what my compiler suggested, since I add two abstract types
06:45:11 <solonarv> jdartland: oh right, I skipped over the + there
06:45:42 <solonarv> in that case it is complaining that you are trying to add 'Char's
06:45:48 <f-a> (oh, it did not pass cabal check)
06:47:00 <solonarv> since your Vertex/Graph are just a pile of tuples/lists I don't know what any of the components are actually supposed to mean, so I don't understand what addVertexWeight is even supposed to be doing
06:47:35 <jdartland> solonarv Well the type a that i use in the mwe is only ints
06:48:28 <solonarv> if it's only supposed to be Int, why is it a type variable? and why does the error message mention Char?
06:49:03 <solonarv> your attempt to isolate the problem has actually removed important information and made your code incomprehensible
06:49:19 <mjrosenb> ok, so I can definitely make that work.  The thing that I actually wanted to know was if there's some ghc-based black magic that I could use to not have to have explicit functions, inject and project.
06:49:32 <MarcelineVQ> Athas: aabbHit.iter 36.3 %time  35.5 %allocation, k that's more honest
06:49:49 <solonarv> in fact your paste very obviously doesn't even compile !
06:50:17 <solonarv> it is laudable to try and produce a minimal reproduction of your problem, but please make sure that it *actually does* reproduce your problem
06:51:39 <jdartland> solonarv type a in my typedefenition is suppose to be handled as a type Int or Char depending of what's used when it's created. This is a part of a whole implementation of a graph thats why I stripped down the code. The function addVertexWeight is a part of a function that calculates the weight of the longest path of a directed asyclic graph
06:51:39 <jdartland> datatype. 
06:52:22 <solonarv> please stop trying to explain and just post the actual code that is giving you trouble
06:52:27 <mjrosenb> solonarv: cool, I'll have to investigate type families in order to figure out what on earth is going on there.
06:52:43 <solonarv> don't even bother trying to remove things you think are irrelevant
06:53:09 <solonarv> mjrosenb: oh, I forgot to actually write get/put/modify, one sec
06:54:41 <MarcelineVQ> Athas: dunno if it's any use for you but here's a thing https://gist.github.com/MarcelineVQ/8d52d36236baa6d1a3078e2288823084
06:55:34 <solonarv> mjrosenb: okay, added them
06:56:18 <solonarv> mjrosenb: these type families are basicaly the same (as you can probably guess)
06:56:45 <solonarv> Put and Get are copies of Bool with more meaningful names, and JoinGet / JoinPut are copies of (||)
07:04:33 <jdartland> solonarv I'm sorry, I think this code is abit more clear. I want addVertexWeight to add the weight of a provided vertex to a provided total weight of the same type and return it to then print it.  https://pastebin.com/NrvmwSnd
07:05:22 <Athas> MarcelineVQ: I'm looking at the Core for aabbHit, and while I'm not super fluent, it looks OK.  The 'iter' function has been inlined three times, and all internal operations are done with unboxed floats.
07:05:49 <jdartland> oh spotted an error, printing the wrong variable in the end.
07:21:21 <frdg> through some internet searching I found that if a Monoid is invertible it is a Group. Is this relevant in Haskell?
07:23:18 <hseg> doesn't seem to be used very much as an abstraction...
07:23:33 <hseg> though kmett, as usual, has found a way of making use of them
07:24:21 <hseg> https://www.youtube.com/watch?v=Txf7swrcLYs
07:24:28 <frdg> hseg: interesting. Ill look into groups a little more when I have some time. Thanks!
07:24:35 <hseg> np
07:26:46 <hseg> ghc's choice of which error to report is odd: http://ix.io/2hRK reports 'Could not deduce (Group (Monomial n))' whereas deleting the # operator from Semiring results in a 'No instance for (Group (Unit r))' error
07:27:31 <hseg> i suspect understanding this will help me build the mwe lyxia asked for yesterday
07:29:38 <frdg> hseg: I can't say I understand any of that code...but it seems very cool!
07:29:49 <Uniaika> :win la
07:29:52 <Uniaika> (oups)
07:30:38 <stondo> solonarv and ChaiTRex: thank you, I got it
07:30:48 <hseg> frdg: it is. ekmett brushes up against some wonderful stuff
07:31:52 <hseg> Q: given a type family F with declarations F A = C; F B = C in scope, is there some way of writing refl :: F A -> F B ?
07:32:50 <mniip> \x -> x
07:32:53 <mniip> should work no?
07:34:11 <hseg> doesn't
07:34:19 <hseg> oh wait, overabstracted my problem
07:34:58 <mniip> I'm assuming you have tyvars so that the tyfam doesn't reduce?
07:35:32 <hseg> i have F (A n) = C n; F (B n) = C n (or at least, that's what should be happening), and asking ghc to typecheck \x -> x :: F (A n) -> F (B n) makes ghc complain about ambiguity in n
07:37:00 <hseg> with GHC warning F is noninjective
07:37:45 <hseg> code in question (unminimized): http://ix.io/2hRN
07:37:59 <solonarv> jdartland: sorry, wandered off for a bit
07:38:15 <solonarv> jdartland: the problem here is simply that addVertexWeight's type is messed up
07:38:35 <solonarv> for an experiment, try removing the type signature and see what happens
07:39:49 <solonarv> jdartland: actually wait, I am very confused. you say that the second element in the tuple representing a Vertex is the vertex's weight
07:40:14 <solonarv> usually, you want to do some arithmetic with the weights (as you do in your code as well)
07:40:24 <hc> > map (( (!!) " !Maillno") . (flip (-) 48) . fromEnum) "284703651"
07:40:27 <lambdabot>  "Moin all!"
07:40:35 <hseg> while trying to minimize that error, deleted a previous experiment. annoyingly, turns out ghc's typechecking is nonmonoidal
07:40:37 <solonarv> but later on you decide to use 'Char' for the weights! how's that supposed to work?
07:41:20 <hseg> specifically, the errors given by the concatenation of two code fragments is not the union of their constituent errors and their emergent errors
07:43:26 <jdartland> solonarv Ahhhhh omg, how could i've missed that. Been staring myself blind... Thanks! :)
07:43:38 <solonarv> hseg: well, consider these two lines: 'foo :: forall a proxy. (Read a, Show a) => proxy a -> String -> String' and 'foo _ = read @a . show @a'
07:43:49 <solonarv> each individual line fails, but together they are accepted!
07:44:03 <solonarv> <end unhelpful counterexample>
07:45:12 <jdartland> solonarv Still the typeproblem though, worked when I removed the typedeclaration
07:48:13 <jakobrs> What is the current state of dependent Haskell?
07:48:22 <jakobrs> In particular with respect to goldfirere's dissertation
07:49:41 <solonarv> jdartland: if adding a type signature means your program doesn't compile anymore, then the type signature is wrong
07:50:12 <solonarv> you can ask GHC what type signature it inferred by using 'addVertexWeight :: _' as the signature
07:50:26 <solonarv> that will print out an error telling you what GHC thinks should go in place of that _
07:52:20 <jdartland> solarus hmmm, wait a second. actually it's suppose to be the second argument BUT iv'e defined all weights as chars and provides a 0 int
07:53:33 <jdartland> solonarv Thanks for the tip, that would actually be useful. And thanks for the help, think I've got it from here =)
07:54:13 <hseg> solonarv: that's irrelevant. the line 'foo _ = read @a . show @a' generates an expectation that the preceding line be a type signature naming a, which can be monoidally discharged or turned into an error 
07:54:30 <hseg> no different from monoidally balancing parens
07:55:11 <solonarv> I suppose that's true, it doesn't get in the way of it being a monoid
07:55:58 <hseg> hrm. research project: design a sugared version of haskell with better error messages, with an eye toward eventually evolving haskell there?
07:56:11 <hseg> would be instructive for me in any case
08:02:03 <maerwald> Haskell with more features?
08:02:40 <ziman> Haskell++
08:02:52 <maerwald> We have that: GHC :>
08:02:58 <jdartland> solonarv Well the _ works but it's based of  the derived type of GHC, in my case I want it to be abstract. It does now work as I use (a) as type int together with the type declaration, but If I use the code in the pastebin and change the input (0) to a char ('x') in addVertexWeight I get the smae error. Do I need to use a list of chars instead
08:02:58 <jdartland> since i try to do a add?
08:04:05 <hseg> maerwald: :) SHE'd like to have a word
08:04:48 <maerwald> Can have a String -- badum-tss
08:05:45 <solonarv> jdartland: no, you can't add lists either
08:06:10 <jdartland> Abstract types are not that easy I've realized, is it possible to define different typedeclaration for the same function xD
08:07:35 <solonarv> sure, there are often many different valid types for a function
08:08:06 <solonarv> for example, the definition 'id x = x' can be typed as 'Int -> Int', or 'Char -> Char', or 'Bool -> Bool', or... yuo get the idea
08:08:51 <jdartland> Something like a guard that checks it type, or maybe I can restrict my abstract datatype to be derived from a family where add is defined. 
08:09:03 <solonarv> but most of the time there is a most general type; in this case that's 'a -> a'
08:09:18 <jdartland> As you probably hear, I'm pretty new to haskell
08:09:30 <solonarv> it's the most general because you get any of the other possible types by replacing the type variable 'a' with the right type
08:10:01 <solonarv> are you perhaps familiar with any other programming languages? some have a similar feature
08:11:13 <jdartland> What I want to do is to atleast handle a as Int or string. adding or appending
08:12:00 <jdartland> solonarv not in the functional paragdim
08:12:24 <solonarv> there isn't anything String and Int have in common that would let you do 'append or add'
08:12:44 <solonarv> I'm not asking only about functional languages, btw
08:12:56 <frdg> does `fmap` make `map` obsolete? 
08:13:38 <solonarv> in a sense, yes
08:13:55 <solonarv> almost anywhere you see 'map' you could replace it with 'fmap'
08:14:26 <solonarv> (there are probably a few cases where fmap's more general type causes an ambiguity error to show up suddenly)
08:14:37 <frdg> solonarv: ok thanks!
08:15:12 <solonarv> > sum $ map (*2) $ pure 1 <> pure 2 -- silly example
08:15:15 <lambdabot>  6
08:15:15 <jdartland> solonarv Well in java or C++ I would have a abstractbaseclass and derive different classes from there using a apply method which then would be defined as + for a Int and append for a string 
08:15:22 <solonarv> > sum $ gmap (*2) $ pure 1 <> pure 2 -- silly example
08:15:27 <lambdabot>  error:
08:15:28 <lambdabot>      • Variable not in scope:
08:15:28 <lambdabot>          gmap :: (Integer -> Integer) -> f0 Integer -> [a]
08:15:35 <solonarv> > sum $ fmap (*2) $ pure 1 <> pure 2 -- if only I could type
08:15:38 <lambdabot>  error:
08:15:39 <lambdabot>      • Could not deduce (Foldable t0)
08:15:39 <lambdabot>        from the context: (Foldable t, Num a, Semigroup (t a),
08:15:55 <solonarv> see, now it doesn't know which "container-y type" should be used
08:16:13 <frdg> I see!
08:16:15 <solonarv> jdartland: that is not the analogy I was going to make and I don't think it's particularly helpful ehre either
08:16:55 <solonarv> jdartland: if you see an identifier in a type that starts with a lowercase letter (like 'a'), that's a type variable
08:17:05 <solonarv> which is sort of like a generic parameter in e.g. Java
08:18:30 <jdartland> So basically I somehow need to check the type of (a) in and handle it different depending on if it's derived from number or char for example
08:18:46 <solonarv> no, there are two things wrong with that idea
08:19:21 <solonarv> the first one is: you can't check which type you were given. your function has to work equally for all types someone might call it at.
08:19:39 <solonarv> the second is: there is no subtyping/subclassing in haskell
08:19:50 <solonarv> Char isn't derived from anything, it doesn't have a superclass
08:19:54 <solonarv> it's just Char
08:20:07 <solonarv> and likewise you can't "use it as a base class"
08:20:33 <Guest23> hey guys, stuck with some problem, please, someone take a look. maybe i dont have some basis, any help apreciate https://pastebin.com/QFLuGyXA
08:23:01 <solonarv> Guest23: hm, it looks like irc-conduit wants you to do something like sticking the messages into a queue/channel/whatever in your consumer, and read from there in your producer
08:24:21 <jdartland> solonarv Yeah but Number and List then, that would be two different cases(add for Number and append for list). Hmmm alright I will have to think about this, maybe restrict my input. I have to go now but thanks for your time! I really appreciate it.
08:24:56 <solonarv> jdartland: I suggest finding a book or something instead of fumbling around, it really helps
08:25:21 <Guest23> solonarv, yeah, but i didnt find any information of how i can do it or something similar to that. that thing killed my day
08:26:40 <Guest23> i red about conduits a lot, but i dont see relevant stuff in this package
08:27:10 <solonarv> honestly I'm not sure what the conduit approach is adding there
08:27:21 <solonarv> let me see if I can slap together some pseudocode
08:28:49 <arianvp> I'm trying to generate haddocks for a type with RecordWildcards enabled
08:28:53 <arianvp> but I get hyperlinks named "$sel:displayName:"
08:28:57 <arianvp> which link to nothing
08:28:59 <arianvp> is this a bug?
08:29:41 <Guest23> i actually asked author of this package(he is here), but he is afk i guess
08:30:08 <arianvp> turns out it is
08:30:10 <arianvp> https://github.com/haskell/haddock/issues/771
08:30:12 <arianvp> sigh
08:32:49 <solonarv> Guest23: this is a very basic approach: https://gist.github.com/Solonarv/ae8021fcba7653721a86b8ae643d86c2
08:37:22 <solonarv> Guest23: you could also do this in a slightly fancier way using a package like stm-conduit
08:38:23 <Guest23> solonarv, dear god, thank you so much! i spent all day on this thing, finally i got something i can work with!
08:42:14 <solonarv> Guest23: this is a more idiomatic approach: https://gist.github.com/Solonarv/ae8021fcba7653721a86b8ae643d86c2#file-irc-conduit-fancier-hs
08:45:39 <Guest23> solonarv, thank again!
09:23:18 <hseg> why isn't newtype N a = N (T a) deriving C equivalent to newtype N a = N (T a); deriving instance C (T a) => N a with GND on?
09:26:19 <hseg> hrm. only possibiltity a perusal of the user's guide brings up is that the methods aren't coercible
09:27:32 <maralorn> hseg: Do you mean deriving instance C (T a) => C (N a)?
09:27:43 <hseg> yes
10:05:21 <juri_> I need to take a M [a], and append a M b to it, giving me M [a]:b. how do i do that?
10:06:18 <mniip> juri_, elaborate?
10:06:55 <dsal> juri_: What is M?
10:07:41 <juri_> I have a function in stateT, and i want to MapM over the first (n-1) of a list, saving the result, then call the function on the last item in the list, adding it at the end of the list that MapM gave me.
10:09:54 <juri_> really, i'd prefer to MapM the whole list, but the last item needs to behave differently. I'd use a fold, but i don't want to concatenate the results manually in the function.
10:12:37 <dsal> mapM ?
10:13:12 <juri_> yeah. that one. :)
10:13:28 <maralorn> juri_: If M is applicative you can use liftA2 (:)
10:13:31 <maralorn> Ah, wait
10:13:49 <maralorn> You want to append an element to a list not the other way around.^^
10:14:03 <juri_> yep.
10:14:05 <monochrom> I think I would write my own recursive function that's like mapM except it has a special case for [x].
10:14:38 <maralorn> liftA2 (\a b -> a ++ [b])
10:19:23 <juri_> ok, i think that works.
10:19:26 <juri_> thanks!
10:20:32 <juri_> it typechecks. that means it's perfect, right? :P
10:20:43 <monochrom> Depends on the type.
10:21:02 <monochrom> If some Int->Int typechecks, we know nothing.
10:21:15 <monochrom> If some a->a typechecks, we know almost everything.
10:22:12 <juri_> ok, that eats all ram and cores swiftly. success! :)
10:22:12 <monochrom> On the flip side, knowing less also means richer possibilities.
10:22:48 <monochrom> https://www.smbc-comics.com/comic/half-full
10:31:17 <inkbottle> Is there a "standard" way to use some sort of "continuation transform" to adapt `a <*> b` parser to a "strict" language? (I'm trying to do it by hand, but I get mixed up in my notations)
10:31:38 <inkbottle> I'd need some academic references about that
10:33:11 <inkbottle> (what is the name of evaluation strategy that ends with weak head normal form? So confused)
10:35:58 <inkbottle> (it must be weak head reduction: https://www.irif.fr/~krivine/articles/lazymach.pdf)
10:42:03 <monochrom> Do you mean, for example, you go to Scheme and write like (<*> a b) and it still makes sense, doesn't go into unnecessary infinite loops?
10:42:32 <inkbottle> yes
10:42:35 <inkbottle> I do
10:42:56 <inkbottle> But without using key words "lazy"
10:43:12 <monochrom> In those languages, the common trick is to say "I expect a parameter to be a procedure that takes 0 argments, so I can decide whether and when to call it".
10:43:25 <inkbottle> I want to transform the expression so that b is evaluated last
10:43:46 <monochrom> So you go (<*> (lambda () (a)) (lambda () (b))).
10:44:12 <solonarv> in lisps, macros can make this less terrible to look at
10:44:44 <monochrom> Yeah, Scheme is a bad example because it has macros.  So consider SML, OCaml, F# instead :)
10:44:59 <monochrom> Except OCaml also has some kind of macro system...
10:45:26 <inkbottle> I relly would like to do it on paper first
10:45:35 <inkbottle> really*
10:46:03 <monochrom> lazy evaluation ends with weak head normal form.  At least in Haskell world.
10:46:18 <inkbottle> that's waht I gathered
10:47:21 <hseg> why is the following illegal: class C a => D a; instance C T; instance D T ? ghc complains at the D instance that it cannot deduce the C T constraint arising from the given context
10:47:59 <inkbottle> I had started putting a "bar" over all my expressions, and adding a "k" argument to everybody; then I got all mixed up
10:48:34 <inkbottle> Because I couldn't remember which was lazy and which was strict
10:48:36 <monochrom> This is why I ditched the *ML's and came to Haskell.
10:48:37 <solonarv> hseg: strange. are all those in the same file?
10:49:59 <monochrom> And then "ML" took on a new meaning.  So now nobody knows what I'm talking about when I say "ML has algebraic data types".
10:50:30 <monochrom> . o O (Do ML data types use tensorflow?)
10:51:08 <monochrom> Let's also design a dependently typed language, call it DL, and confuse the hell out of the deep learning people!
10:51:44 <monochrom> "DL can prove that your program terminates."  "Wow, that's serious AI."
10:52:04 <inkbottle> (I was having Plotkin on the phone last week and he told me that shifting from ML to Haskell and just ditching the question, was really having it too easy)
10:52:17 <monochrom> w00t Plotkin!
10:52:30 <inkbottle> kidding of course
10:54:00 <inkbottle> Waht is the new meaning of ML? I missed that one I think
10:54:11 <monochrom> machine learning
10:54:50 <inkbottle> okay, I definitely missed it
10:55:06 <monochrom> Look for the paper "how to add laziness to a strict language without even being odd".  I think it's the best technique for getting laziness in strict languages.
10:55:25 <inkbottle> cool, doing that
10:57:56 <monochrom> Maybe it is not exactly what you're looking for. but I bet in that case its tangential discussions are still useful to you.
10:58:07 <inkbottle> cool, only 8 pages, and I can sometimes understand what P. Wadler is saying
10:58:52 <inkbottle> Yes, I definitely want to read it
10:58:52 <monochrom> because an academic paper is obliged to discuss related things (because reviewers will insist it (because reviewers are secretly saying "you must cite my paper"))
10:59:08 <inkbottle> ;)
10:59:22 <inkbottle> (or else!)
10:59:48 <monochrom> Yeah! Reviewers wield absolutely corrupting power.
11:04:27 <monochrom> One time I showed Andrew Gordon's PhD thesis (functional I/O) to my thesis supervisor.  He flipped through it for just a few seconds and already declared "this is a great thesis!"
11:04:28 <infandum> Is there a generalized "take" that works with traversable?
11:04:54 <solonarv> no, and there can't be
11:05:12 <monochrom> and his next sentence immediately explained on what slight pretext: "it has a great list of bibliography"
11:05:12 <solonarv> (not with Traversable, maybe with some other typeclass)
11:05:35 <ja> hmm i get an error with process when i do 'cabal install --lib aeson base64-bytestring'
11:05:54 <average> how do I call that thing that I put the lighbulb in?
11:06:00 <ja> is cabal constrained by libraries that are already installed? i thought it wouldn't be since v3
11:06:03 <monochrom> trees could be traversable, so then it is no longer clear what "take 5" should mean.
11:06:12 <ja> average: socket
11:06:21 <monochrom> Is IO Traversable?
11:06:27 <solonarv> it is not
11:06:33 <infandum> solonarv: What about foldable?
11:06:40 <monochrom> Ah OK.
11:06:49 <solonarv> no, Foldable is strictly weaker than Traversable
11:06:56 <monochrom> Foldable has no hope.  Foldable allows consumption only.
11:07:13 <solonarv> (meaning if you can't implement something using only Traversable methods, then you can't do it using only Foldable methods either)
11:07:28 <monochrom> take has to be a transducer.  Traversable has some hope, your initial intuition was not entirely wrong.
11:07:28 <infandum> Why can't you take in a foldable?
11:07:33 <ja> if i look at the hackage pages of either of those packages, they don't show 'process'. but the error message from cabal complains that "constraint from user target requires process==1.6.8.2"
11:07:40 <solonarv> actually I should ask what you want. do you want genTake :: ??? => Int -> t a -> t a ?
11:07:52 <solonarv> or do you want genTake :: ??? => Int -> t a -> [a]
11:07:54 <monochrom> take has to be a transducer, i.e., consumer and producer
11:07:59 <infandum> Control.Foldl has a lastN, but not a headN
11:08:27 <infandum> I do
11:08:29 <infandum> no
11:08:38 <infandum> I want Int -> t a -> t a
11:09:13 <solonarv> then I don't know of any existing typeclass that does what you are asking for
11:09:31 <monochrom> What laws should your new take satisfy?
11:09:41 <monochrom> (Haha I'm a genius.  "new take".)
11:09:45 <solonarv> heh
11:10:10 <monochrom> "how to take a new take without even being odd"
11:10:11 <infandum> Shell
11:10:34 <infandum> https://hackage.haskell.org/package/turtle-1.5.18/docs/Turtle-Shell.html
11:11:31 <solonarv> what's that got to do with "generalized take"?
11:12:16 <infandum> I want the first n Shell values
11:12:26 <monochrom> ja: I put lightbulbs in lightbulb recycling collector boxes, and switch over to CFLs and LEDs.  Is that OK?  >:)
11:12:57 <ja> no, gotta use candlelight for maximum romance
11:13:19 <monochrom> Ah, you're wise.
11:16:06 <maerwald> I like romance, but not inside a trash bin.
11:16:26 <monochrom> Don't worry, no one is doing that.
11:19:55 <monochrom> infandum: Since Shell is at least IO, perhaps what would "takeIO :: Int -> IO a -> IO a" mean as a first approximation?
11:20:37 <monochrom> Either that or a reason why my "since Shell is at least IO" doesn't matter.
11:21:43 <monochrom> Also Shell isn't Traversable either.
11:22:07 <monochrom> at least if the hackage doc can be trusted to be complete on this.
11:22:47 <ja> it's so odd i can't install aeson and that the cabal error message doesn't show which package requires 'process' :O
11:23:31 <monochrom> adding -v helps.  The output is long but I know what to look for.
11:24:43 <ja> the problem disappeared after i removed the '--lib' flag :O 
11:24:58 <ja> but thanks for the -v tip, that'll be helpful in the future
11:25:22 <monochrom> Also I usually try --dry-run first.
11:26:12 <reuben> If I had a HKD record like `data Test f = { field1 :: f Int, field2 :: f String, ... }`, is there and instance that I can give it so that I can write a generic function `Test (Lens' a) -> Lens' a (Test Identity)`.
11:26:38 <ja> oh my, it seems i had both of those packages installed already. so the process goal was somehow implicit and from neither of them
11:27:48 <maerwald> monochrom: my distro PM has "--dry-run" as a default :) you have to pas --execute for it to do anything
11:28:07 <maerwald> It might be a surprising default, but I think it's good UI
11:28:16 <monochrom> haha that's great
11:28:31 <monochrom> dosfschk takes the same stance.
11:29:03 <maerwald> I mean, either you have a fully interactive client, or you have something with the least amount of surprise.
11:29:08 <ja> maerwald: is it exherbo?
11:29:11 <maerwald> yeah
11:30:04 <average> where do most companies keep a list of their employees, is it in wide-spread type of HR software, or maybe just in Active Directory? I'm interested in a very common piece of software that's widely used for this
11:30:19 <monochrom> They should rename --execute to --doitdoitdoit.  I have Chris Pine's Captain Kirk in mind (when Enterprise was near the newly created black hole and Scotty says "maybe ejecting such-and-such will help")
11:30:48 <phadej> average: there are plenty of SaaS offerings for HR software
11:31:02 <average> phadej: thanks, which ones are more popular?
11:31:21 <phadej> average: I have no idea, I guess the field is about as diverse as accounting software
11:34:14 <berndl> average: https://www.bamboohr.com/
11:34:32 <maerwald> Aww, that's cute
11:34:50 <berndl> Some companies just use spreadsheets.
11:35:13 <monochrom> Why is there no bamboo in the picture, only panda.
11:35:27 <monochrom> and a tree emphatically non-bamboo
11:35:49 <jakobrs> I'm sorry to repeat an earlier question, but what *is* the state of dependent haskell a la richard eisenberg?
11:36:13 <monochrom> 1%
11:36:50 <hseg> solonarv: sorry for delay. yes, in the same file
11:37:15 <hseg> maybe i've oversimplified the situation
11:37:18 <juri_> grr. i hate it when google has no hits for my problem.
11:37:26 <monochrom> there are still many open research problems, and even more open implementation problems. and the latter has to wait for the former first naturally.
11:38:10 <jakobrs> is there any form of tracking issue/whatever on this?
11:38:25 <monochrom> juri_: It could be worse. Misleading hits.
11:38:34 <monochrom> I deliberately did it to my students.
11:38:52 <hseg> solonarv: my test case is http://ix.io/2hTT, with error 'Could not deduce (Group (Vector n (Sum Integer)))' for the Semiring (Polynomial n a) declaration
11:38:59 <monochrom> I gave them an assignment that's basically known as "the probability monad" in the literature.
11:39:02 <hseg> monochrom: you evil bastard ;)
11:39:35 <monochrom> To google-proof my assignment, I was a genius, on the assignment handout (and starter code) I called it "MonadRandom".
11:39:50 <monochrom> Now everyone gets completely wrong hits when googling.
11:40:04 <monochrom> A student asked "may I import Control.Monad.Random?".  Success.
11:40:37 <jakobrs> inb4 one of your students creates their own probability monad library called "monadrandom"
11:41:56 <hseg> not sure if i approve, but don't see an alternative either
11:42:08 <maerwald> Overachieving completely besides the assignment? I did that a lot.
11:42:57 <maerwald> It's fine if you trick your students, but then allow them the freedom :)
11:43:28 <monochrom> Oh I totally allow them the freedom to be wrong.
11:43:38 <maerwald> ...
11:43:42 <monochrom> How else could I keep the class average low? >:)
11:44:36 <maerwald> like, we got an assignment about implementing a crypto-algo and the profs idea was that we fail and tell him after 4 weeks how we failed (project management etc.)
11:44:42 <maerwald> Guess what, we didn't fail :P
11:44:59 <hseg> nice
11:46:16 <maerwald> It isn't that hard, but with zero prior knowledge in that field it is.
11:46:36 <maerwald> "Let's see how students deal with failure..."
11:46:40 <maerwald> "err... oh"
11:46:54 <hseg> ok, figured out where my problem is coming from, but still unsure how it causes it
11:48:12 <hseg> basically, scenario is: instance C P; instance C p => D (W p); newtype T = T (W P); deriving via (W P) instance D T
11:49:26 <hseg> and derivingvia is complaining it can't find a C P instance
11:49:36 <hseg> but there is one in scope!
11:50:18 <hseg> code is at http://ix.io/2hTT
11:50:49 <hseg> wait, sorry, that's an old version. new at http://ix.io/2hU1
11:51:32 <monochrom> :( that's very long
11:51:55 <hseg> :( sorry
11:52:16 <hseg> basically, the essentials are the instance declarations for WFD
11:52:24 <hseg> and the derivingvia call for Polynomial
11:52:30 <monochrom> in the sense that if I loaded the paste and it does error out, I have zero confidence that it is akin to your one-line scenerio summary.
11:52:59 <hseg> yeah, have been trying to minimize it
11:53:48 <hseg> lemme try and minimize it a little more
11:54:28 <monochrom> I usually work from both directions.  (I don't understand why no programmers has ever thought of one of the directions.)
11:54:41 <hseg> ?
11:55:01 <jakobrs> Speaking of the probability monad, is there any efficient implementation of it that manages to ... be a monad?
11:55:35 <monochrom> While I minimize the existing code that has the issue, I also independently start from scratch to build mock code bottom-up that I believe has the essence and nothing else.
11:56:07 <jakobrs> I mean, with literal, structural equality (as opposed to hackage's probability where two "equal" values can have different representations)
11:58:09 <hseg> ah. yeah, so my approach is basically a binary search between erroring program and empty program
11:58:52 <monochrom> Yeah. But I picture digging a tunnel from both sides.
12:00:03 <hseg> fair
12:00:14 <hseg> somewhat smaller case at http://ix.io/2hUb
12:00:29 <hseg> still complaining about missing constraints
12:00:39 <hseg> now it's become Monoid Int (due to restructuring)
12:03:45 <monochrom> It is known that Monoid Int doesn't exist.
12:04:10 <monochrom> For the (+) monoid, use Sum Int; for the (*) monoid, use Product Int.
12:04:24 <monochrom> Do you think that's basically it?
12:05:11 <koz_> Isn't there also Min and Max?
12:05:18 <koz_> Or am I getting my wires crossed?
12:05:35 <monochrom> That has to be weakened to Semigroup.
12:05:55 <hseg> and that's the problem with minimizing errors, sometimes you cut too much away
12:06:01 <koz_> Int is bounded though.
12:06:05 <koz_> So you have mempties.
12:07:08 <monochrom> Yeah but they prefer to write like "instance Ord a => Semigroup (Min a)" and let it be one single way for all a's.  Rather than "instance Semigroup (Min Int)"
12:07:30 <koz_> monochrom: Yeah, that's a fair point.
12:07:31 <monochrom> or "instance Monoid (Min Int)"
12:07:47 <koz_> Wouldn't it logically make sense to have "instance (Ord a, Bounded a) => Monoid (Min a)" though?
12:08:06 <monochrom> Ah, I haven't thought of that.
12:08:15 <hseg> dammit. that solved my contrived cut-down test case.
12:08:23 <hseg> lemme make it slightly more complicated again
12:09:41 <koz_> Likewise for Max a.
12:09:51 <koz_> That's actually a fairly useful instance.
12:10:03 <monochrom> Yeah, I see now.
12:10:16 <koz_> I'm guessing by your reaction it doesn't exist?
12:11:12 <monochrom> I was just not thinking and never checked.  It already exists in base.  Happy ending.
12:11:20 <koz_> :D
12:13:28 <monochrom> If you import Data.Semigroup you get them all, even the Monoid instance predicated on Ord and Bounded.
12:13:41 <koz_> What's the deal with Data.Semigroup versus Data.Monoid exactly?
12:14:34 <monochrom> I bet merely some evolution history because Data.Monoid got there first.
12:14:51 <koz_> So which should we be importing? Data.Semigroup I guess?
12:14:58 <monochrom> Semigroup was like a 3rd-party library outside base for a while.
12:15:26 <monochrom> Data.Monoid doesn't have Max at all.
12:15:33 <monochrom> or rather, doesn't export.
12:16:33 <hseg> it shouldn't, unless the type is bounded
12:16:49 <koz_> hseg: Yeah, which is fair.
12:16:54 <koz_> (we've just been discussing this)
12:17:13 <hseg> ah ok
12:17:18 <monochrom> And mutually, some things in Data.Monoid (I ran into Ap) is not exported by Data.Semigroup either.
12:17:57 <monochrom> There is a large overlap such that importing either one you'll get it.  But they still have a symmetric difference.
12:18:17 <koz_> OK, figured it was something like that.
12:18:26 <koz_> I swear, half of programming is 'spot the monoid'.
12:18:59 <monochrom> Have you seen "where is Waldo?" amid the pandemic?
12:19:10 <koz_> Can't say I have.
12:19:22 <hseg> ok, bisection suggests error arises from some interaction with gadts
12:19:36 <hseg> still trying to minimize
12:19:53 <monochrom> It's like a picture of an empty street or plaza or beach, and Waldo is right there in the middle. There are no other people to obscure him. :)
12:20:04 <koz_> LOL
12:20:16 <hseg> heh
12:20:21 <hseg> sad but true
12:21:05 <monochrom> "Monoids are easier to recognize under social distancing"
12:22:28 <koz_> Monoids are like turtles.
12:22:31 <koz_> They are all the way down.
12:24:02 <[exa]> monochrom: "not groups" ?
12:24:18 <monochrom> hahahaha you win
12:25:49 <[exa]> :]
12:27:58 <hseg> "Breaking news: mandatory social distancing measures have been strengthened. All rings, clubs, and groups of more than three elements are hereby banned." 
12:28:19 <LKoen> what country is that from, hseg?
12:28:33 <koz_> hseg: Rofl.
12:28:45 <hseg> LKoen: was a joke riffing off monochrom's
12:28:53 <LKoen> ah
12:29:10 <LKoen> apparently I'm socially distant from humour now
12:29:46 <hseg> https://en.wikipedia.org/wiki/Club_set is slightly more obscure, might have thrown you off the scent
12:29:47 <monochrom> hseg: Also, sets of measure 0 are banned.  (Or should it be sets of measure > threshold?)
12:30:36 <hseg> all sets of positive measure are banned. only negligible sets are allowed
12:30:52 <monochrom> omg the set theorists are really out of their ways. or minds.
12:32:23 <hseg> tell me about it. attended a set theory seminar for a semester. didn't get a word of it
12:33:33 <monochrom> My disease is I comprehend their definitions and problem/theorem statements but then I'm like "why would anyone care".
12:34:44 <hseg> heh. yeah. independence of AC and CH basically killed the field for me
12:35:12 <hseg> ... though the reverse math fork it inspired is slightly useful
12:35:14 <monochrom> like "if axiom of choice then hereditary xxx topological spaces are the same as hereditary yyy topological spaces"
12:35:26 <hseg> but that's more to logic's credit
12:35:42 <koz_> Reverse mathematics is cool.
12:35:46 <monochrom> I like reverse math, yeah.
12:35:50 <koz_> Like, an exercise in mathematical minimalism.
12:36:03 <koz_> (it's actually surprising _just how much_ you can prove from a basic axiom)
12:36:18 <koz_> Actually monochrom, or hseg - do you have any insight as to why reverse mathematics uses second-order arithmetic?
12:36:19 <monochrom> very good way to explain the connections between different laws.
12:36:27 <hseg> though i guess it's basically the usual "more applied than me is gross, more abstract than me is navel-gazing" problem
12:37:04 <hseg> nope. only have seen a brief overview of reverse math
12:37:11 <hseg> never actually got into its guts
12:37:13 <monochrom> I don't know.  I have only took a cursory look at amateur popular level reverse math.
12:37:34 <koz_> OK, never mind then.
12:37:52 <koz_> I've always been curious about that choice, since a lot of _other_ stuff of this nature is pathologically first-order.
12:38:00 <koz_> (about the only exception is finite model theory, and I know why)
12:38:36 <hseg> what do you mean by "pathologically first order"?
12:39:12 <hseg> ... i do suppose that one reason you want 2nd order arith is because 1st order is insufficient to guarantee naturals are your Platonic naturals
12:39:17 <koz_> hseg: Everything seems to be relying on first-order everything.
12:39:27 <frdg> https://pastebin.com/pRyHaJyd im having trouble understanding the problem with this code. The explanation from my book isn't really clicking.
12:39:39 <koz_> For example, ZFC is a first-order theory, even though Zermelo originally phrased it in second-order language.
12:40:01 <koz_> Model theory which isn't finite also appears to default to first-order logic (but again, I know why).
12:40:50 <hseg> well, i suppose first-order is easier to analyse and has more than enough lower-hanging fruit
12:41:06 <hseg> but for practical use, you want second-order
12:41:56 <koz_> hseg: This is true. I know that model theory uses FOL because of Linstrom's theorem (sp?) giving it nice properties, which is also exactly why finite model theory doesn't bother, because said nice properties don't matter.
12:42:12 <koz_> (compactness fails for finite model theory, and downward Lowenheim-Skolem is a triviality when every model is finite)
12:43:11 <hseg> ooh, missed lindstrom's theorem
12:43:18 <hseg> thanks for the pointer
12:43:19 <koz_> Yeah, I did spell it wrong.
12:43:33 <koz_> I need to remember it's [nice chocolate]strom's theorem.
12:43:51 <hololeap> does anyone have any suggestions for someone who knows haskell and is looking to learn erlang?
12:44:14 <hseg> koz_: imagine streams of rich chocolate
12:44:32 <average> hololeap: well, know that erlang's main guy is gone, and erlang is now being adopted by FB
12:44:59 <koz_> hseg: Chocolate is now first-order. I don't make the rules. :P
12:45:11 <hseg> also, that wiki walk is connecting up with some stuff i've been meaning to look into, so thanks for that
12:45:24 <hseg> chocolate is first-order, first-serve?
12:45:28 <hololeap> not a fan of FB, but i'm just looking to contribute to an erlang project that i use frequently
12:45:40 <frdg> https://pastebin.com/pRyHaJyd im having trouble understanding the problem with this code. The explanation from my book isn't really clicking.
12:46:30 <hololeap> just wondering if there's much overlap between the two languages, or any aspects of haskell that fit in nicely with erlang
12:46:34 <hseg> frdg: what is the kind of v in there?
12:46:48 <koz_> hseg: Lol.
12:47:00 <frdg> hseg: *
12:47:07 <koz_> I have to admit, finite model theory fascinates me, but I lack almost any training in it.
12:47:17 <hseg> oh? is v a legal for v :: * ?
12:47:18 <koz_> I _just about get_ the first-order undefinability of graph connectivity.
12:47:21 <koz_> _Just about_.
12:47:39 <hseg> haven't looked into finite model theory, can you pitch it to me?
12:48:32 <jakobrs> Is there a name for _some_ ordering of the complex numbers in haskell?
12:48:49 <frdg> hseg: ohh, cause it wouldn't make sense to have an `Int Char`
12:48:52 <[exa]> koz_: sounds interesting, may you share a link?
12:49:06 <frdg> thats just like...not a thing
12:49:08 <koz_> [exa]: I've not seen the proof outside a textbook.
12:49:09 <hseg> jakobrs: you'll need to impose an order
12:49:20 <hseg> frdg: exactly
12:49:29 <jakobrs> I just need something that satisfies the ordering axioms
12:49:36 <[exa]> koz_: well that kinda reminds me the rest of the model theory I know :D
12:49:51 <dmwit> jakobrs: What are the ordering axioms?
12:50:12 <dmwit> jakobrs: I'm not trying to be difficult. There are multiple choices for which things count, and some are possible to satisfy while others aren't.
12:50:13 <koz_> [exa]: The classical model theory argument is easier (it relies on a proof by contraction by compactness).
12:50:25 <koz_> I can dig out a textbook and tell you the page references if that'd help?
12:50:30 <dmwit> jakobrs: For example: do you expect that `a < b` and `c < d` implies `a+b < c+d`?
12:50:42 <jakobrs> total order, I think
12:50:54 <dmwit> jakobrs: For total order, you can just use lexicographic ordering.
12:50:58 <[exa]> jakobrs: you can sort them as converted to tuples but 99% of the channel is going to tell you it's ugly. Unless you'd have gaussian integers. :]
12:51:37 <dmwit> jakobrs: It will not be compatible with arithmetic in the way I described above. Personally I am fine with that, and think it's silly that we don't already have an Ord instance that simply isn't compatible with arithmetic. But other disagree, so what the heck.
12:52:09 <jakobrs> Yeah I know that the complex numbers can't really be ordered in any satisfying way, but
12:52:24 <jakobrs> I just needed a way to "canonicalise" a list of complex numbers
12:52:44 <jakobrs> where with canonicalise I mean that [a, b] and [b, a] get sent to the same value
12:52:57 <dmwit> I know. It's a common need.
12:52:59 <monochrom> What have I done? :)
12:53:09 <dmwit> And it's why I think the requirement is silly.
12:53:24 <dmwit> You now know my recommended solution to this problem. Does this answer your question?
12:53:42 <[exa]> koz_: ok :]
12:53:52 <jakobrs> Yeah, I've just decided to just order on the real part, then the imaginary part
12:53:55 <[exa]> jakobrs: do you have Floats inside?
12:53:58 <jakobrs> or opposite if I mess up
12:54:00 <jakobrs> yes, floats
12:54:17 <jakobrs> I'd love for there to be something that does this in base
12:54:20 <dmwit> jakobrs: Yes, that ordering is called "lexicographic". =P
12:54:29 <koz_> [exa]: One moment. Could be a long moment, I'm doing like five things at once.
12:54:39 <koz_> (and I haven't had my coffee yet)
12:54:42 <jakobrs> (think similar to Sum or All)
12:54:43 <dmwit> And I, too, would love for this to be in base.
12:54:46 <[exa]> koz_: oh worry not then, I was just curious :]
12:54:50 <[exa]> koz_: I should be writing :D
12:55:06 <[exa]> jakobrs: careful with precision trouble then
12:55:24 <jakobrs> yes
12:55:40 <jakobrs> I just needed something that's similar enough to the reals
12:56:21 <jakobrs> for my experimentation with the probability monad with complex probabilities
12:56:34 <monochrom> Someone of us thought up that we should have two classes, not just one Ord class.  So that one of them is consistent with x<y => x+z<y+z etc., and the other is just for putting things into Set and Map etc.
12:56:42 <jakobrs> (which is called exotic probability btw)
12:57:11 <monochrom> It is not called quantum bits?
12:57:36 <monochrom> But if exotic probability uses a different norm, I understand. Quantum bits use the 2-norm.
12:57:51 <jakobrs> Quantum probabilities/amplitudes are very similar, yeah
12:58:08 <jakobrs> I actually came upon the concept when reading about quantum computing
12:58:18 <hseg> ok, monochrom , managed to reproduce in a reduced setting http://ix.io/2hUN
12:58:20 <koz_> [exa]: I'll look into it and send you a pageref. At some point. :P
13:00:21 <jakobrs> Here's a really cool definition
13:00:23 <monochrom> hseg: I think we also need {-# LANGUAGE FlexibleContexts #-} and {-# LANGUAGE GADTs #-}
13:00:39 <monochrom> But yeah after that, I see the error.
13:00:46 <jakobrs> rot :: Float -> Distr (Complex Float) (); rot ph = Distr [((), mkPolar 1 ph)]
13:00:50 <monochrom> Err, just mean I see the error message.
13:00:56 <hseg> somehow ghci isn't complaining about those extensions
13:01:20 <monochrom> hrm, maybe different versions? 8.6 for me
13:01:23 <jakobrs> It's just (), "rotated" by ph radians in the underlying "probability space"
13:01:34 <hseg> ah, because :r doesn't reset enabled extensions
13:01:49 <monochrom> haha
13:02:13 <phadej> fyi, there is :seti which doesn't affect how modules are loaded
13:02:24 <phadej> only the code you write in repl
13:03:26 <phadej> (though I never remember to use it mysefl)
13:03:44 <hseg> ok, managed to remove one more type from the testcase, but essence remains the same http://ix.io/2hUR
13:09:02 <hseg> some more shaving: http://ix.io/2hUU
13:09:17 <monochrom> I have to go for an hour but I am a little confused, maybe I haven't learned deriving-via properly.  From "deriving via (W Id (M n)) instance Semiring (M n)", I go and find "instance Semigroup m => Semiring (W p m)" so m = M n. So this brings me back to "is there Semigroup (M n)?" so it sounds circular to me now.
13:11:12 <monochrom> Eh? You also have both "deriving instance Semigroup (Vector n String) => Semigroup (M n)" and "deriving via (W Id (M n)) instance Semiring (M n)".  I think both me and the computer are confused.
13:14:38 <hseg> ? what version are you looking at
13:14:54 <monochrom> http://ix.io/2hUR
13:15:16 <monochrom> err oops, no
13:15:29 <monochrom> http://ix.io/2hUN
13:17:26 <hseg> sorry
13:18:05 <hseg> i updated my sample to http://ix.io/2hUU earlier
13:18:18 <hseg> reduced the amount of classes lying around
13:21:43 <hseg> monochrom: also need to close for the evening. mind taking this up again tomorrow?
13:53:57 <afnaeon> Does anyone know why when I try to import Network.HTTP.Conduit I seem to not get the variable withManager?
13:54:13 <afnaeon> I'm trying to run the code from here https://stackoverflow.com/questions/24718873/downloading-large-files-from-the-internet-in-haskell
13:54:15 <koz_> afnaeon: Are you sure your versions line up?
13:54:20 <koz_> I just had a very similar issue.
13:55:19 <afnaeon> Lemme check
13:55:23 <Uniaika> hey koz_ o/
13:55:26 <Uniaika> what's up?
13:56:46 <afnaeon> I'm trying it in a script where I have the line `--stack runghc ... --package http-conduit` How can I check which version of http-conduit is being used?
13:57:14 <koz_> Uniaika: Not a whole heap. Writing a schema language spec.
14:05:02 <afnaeon> nvm looks like withManager is obsolete
14:05:12 <solonarv> afnaeon: check which snapshot is being used
14:05:43 <solonarv> is there an argument that looks like '--resolver lts-X.Y' in that magic comment?
14:12:23 <sm[m]> afnaeon: runghc will use whatever resolver is "in context", specified by a project's stack.yaml if you run from inside a project or by ~/.stack/global-project/stack.yaml
14:13:30 * monochrom squints. When did runghc recognize stack infrastruture?
14:13:56 <sm[m]> "stack runghc" in this case, a similarly named stack subcommand
14:14:01 <sm[m]> afnaeon: so you can check what it sees by doing stack exec -- ghc-pkg list http-conduit
14:29:35 <sm[m]> (also adding the --resolver argument solonarv asked about, if there is one)
14:34:08 * mouse008[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/KLfXmAENdnBUjFFPYmVDVHVU >
14:35:57 * mouse008[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/kvbhiPTOlcTThdTjDcPshIEB >
14:36:40 * mouse008[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/kMbMJUUSNiHSwUkGjHQjbdiD >
14:37:04 <sm[m]> mouse008: just FYI, when you send a long message from matrix, most of the folks on this IRC channel see "* mouse008[m] sent a long message:  < https://..."  and are unlikely to click. Better to write each point separately
14:37:30 <sm[m]> or, one line of summary
14:47:25 <monochrom> This is not the cabal hell people were talking about. Far from it.
14:49:01 <sclv> anyway the answer is you can do local deps using cabal v2- and cabal.project files
14:49:05 <monochrom> If I understand correctly, v1 is the furthest away from "automatically check local availability, use local build or fetch from hackage predicated on the check".  Bascially v1 is the most static ever.
14:50:27 <monochrom> v2 may or should do it, I never tried, but it is always best to read the user guide to see your options.  https://cabal.readthedocs.io/en/stable/nix-local-build-overview.html
14:53:54 <mouse008[m]> @monochrom v1 installs locally, and subsequent v1 builds of other packages would look there first (I think in `~/.ghc/...`). v2 appears to ignore whatever's been already installed.
14:53:54 <lambdabot> Unknown command, try @list
15:09:29 <mouse008[m]> Not sure if the message posted:
15:09:29 <mouse008[m]> v1 installs locally, and subsequent v1 builds of other packages would look there first (I think in `~/.ghc/...`). v2 appears to ignore whatever's been already installed.
15:09:45 <monochrom> Yes.
15:10:59 <mouse008[m]> So, I have to use v1 for packages that I want to use what `ghc-pkg` shows?
15:11:31 <monochrom> I wouldn't be sure about "have to".
15:13:13 <monochrom> Oh, misread.  What ghc-pkg shows, yes, if I take it on face value and it's strictly simply "ghc-pkg" no amendment.
15:13:48 <mouse008[m]> Glad to hear. But so far I've been unable to find an alternative.
15:14:06 <monochrom> Because I bet "cabal v2-exec ghc-pkg" or something may do something.
15:14:43 <mouse008[m]> Oh I didn't think of that - thanks!
15:16:36 <mouse008[m]> By `ghc-pkg` I meant something that tracks system-wide and user-wide installed packages, and would "feed" them to Cabal when it creates dependency chains, so Cabal would user already-installed packages rather than re-building them.
15:16:53 <mouse008[m]> * By `ghc-pkg` I meant something that tracks system-wide and user-wide installed packages, and would "feed" them to Cabal when it creates dependency chains, so Cabal would use already-installed packages rather than re-building them.
15:21:24 <sclv> mouse008[m]: i don't think v2-exec will work. ghc-pkg doesn't know how to look in the store
15:21:54 <sclv> the way to do it is just to use a cabal.project file so you can "vendor" your locally built stuff into the same project with the main thing you're building
15:23:16 <sclv> like assume you have `a` and it depends locally on `b` and remotely on `c` then just have a directory with a cabal.project file and have `a` and `b` in it as subdirectories and cabal v2-build `a` and it should pick up the `b` from the subdirectory just fine
15:26:47 <fishooter> I'm just studying STM, is it implemented in other languages than Haskell? I completely fell in love with it :)
15:27:01 <mouse008[m]> sclv: my problem is that some of the dependent packages are what I pulled from Hackage and modified, others are what I want to install from Hackage as-is, and some are "purely" mine. I don't want to point`cabal.project` at each and every directory with the source, like `b` in your example.
15:27:33 <mouse008[m]> Also, I want to avoid re-building those dependent packages.
15:27:48 <mouse008[m]> * sclv: my problem is that some of the dependent packages are what I pulled from Hackage and modified, others are what I want to install from Hackage as-is, and some are "purely" mine. I don't want to point `cabal.project` at each and every directory with the source, like `b` in your example.
15:27:48 <monochrom> Clojure has STM but I think it's missing orElse --- the whole point IMO.
15:28:10 <monochrom> and retry.
15:31:03 <fishooter> What are typical pain points with STM? So far from the examples from Marlow's book it seems that you need to be careful with exceptions
15:31:14 <fishooter> I'm reading through the chat server
15:33:22 <phadej> to the first approximation, there are no pain points.. if you compare to MVar e.g.
15:34:09 <phadej> but lack of fairness is something which might be an issue in some cases, that's described in the Marlow's book
15:36:06 <phadej> (you have to be careful with exceptions in Haskell in general - especially in async setting, whatever you use for it, so it's not only STM concern)
15:39:12 <fishooter> thanks :)
15:43:06 <fishooter> is STM super slow?
15:43:26 <fishooter> there has to be some drawbacks :-)
15:43:36 <fishooter> it seems too good to be true
15:44:24 <phadej> one some workloads it's faster than MVars, because MVar is fair
15:44:48 <phadej> but I don't know how well it scales when transaction sizes are big
15:45:02 <phadej> never were an issue for my needs in practice
15:45:09 <fishooter> so as long you keep transactions small, it's fine?
15:45:35 <fishooter> I heard that in Facebook they're using Haskell for some internal tools that manage highly concurrent apps
15:45:40 <fishooter> I wonder if it is built on STM
15:46:30 <dsal> The question isn't whether STM is slow, it's whether it's slow for your application and whether you could write a correct alternative that would perform better and whether you could reason about such a thing.
15:46:47 <dsal> STM is super easy to use and get to do the right thing.  It composes quite well.
15:46:54 <phadej> I know only about Sigma, which is built using haxl - and it uses stm (no idea for what though), https://hackage.haskell.org/package/haxl
15:48:52 <fishooter> I'm just wondering... doesn't laziness bite you when combined with concurrency?
15:49:35 <phadej> kind of, you have to be careful to execute stuff to the end on the thread you want, e.g. by using deepseq
15:50:02 <fishooter> can you maybe elaborate on that?
15:50:20 <phadej> you are familiar with async library, aren't you?
15:50:41 <fishooter> not much, I just read Marlow's book, I haven't tried it out yet
15:51:00 <phadej> say you do x <- async (someExpensiveIOComputation :: IO [Int])
15:51:14 <phadej> let's imagine that someExpensiveIOComputation reads a file, and than computs something based on it
15:51:56 <phadej> if you don't force (as https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#v:force) the computation inside that IO action, then...
15:52:28 <phadej> async action would complete as file as read, but not doing hardly any computations after it
15:52:30 <dsal> laziness bites you with concurrency when you don't do the work concurrently.   It really depends on the kind of problem you're solving.
15:52:44 <fishooter> 16:50 < phadej> say you do x <- async (someExpensiveIOComputation :: IO [Int])
15:52:44 <fishooter> 16:50 < phadej> let's imagine that someExpensiveIOComputation reads a file, and than computs something based on it
15:52:55 <fishooter> oops sorry
15:53:31 <phadej> TL;DR you shouldn't transfer thunks between threads, if the idea is to execute them concurrently
15:53:37 <phadej> (to the end)
15:54:02 <fishooter> aha, ok that makes sense :)
15:54:14 <fishooter> thank you!
15:54:27 <dsal> abstractions handle some of that for you.  mapConcurrently and concurrently and race and all that.
15:54:45 <dsal> Though, yeah, I've got those wrong before.
15:54:53 <phadej> Chapter 2: has subsection deepseq
15:54:56 <phadej> I guess it's relevant
15:55:00 <dsal> But it really depends on what you need.
15:55:09 <phadej> I don't have a book with me, so cannot check.
15:55:11 <dsal> You *might* need deepseq, but I've almost never needed it.
15:55:50 <phadej> depends on what data you return, plenty has seq = deepseq behavior
15:57:14 <dsal> I use mapConcurrently_ quite a lot.  Just do a bunch of actions concurrently.  Not much to return.  Clients or servers dealing with independent actions.
15:57:19 <phadej> Marlows book is good, but it might require few iterations of reading (with trying stuff out in code in projects). There's quite a lot of stuff, i'd surprised if it all would just stick in one read-through :)
16:42:15 <starbolt> Has anyone used `cabal init sandbox` in a while?
16:42:47 <Uniaika> starbolt: aren't they about to be deprecated?
16:43:40 <starbolt> I should have said `cabal sandbox init` --- perhaps it's already gone? I just installed cabal 3.2.0.0
16:44:18 <monochrom> perhaps you need to say "v1-sandbox"
16:44:39 <monochrom> It is always a good idea to ask "cabal --help" and refresh yourself.
16:44:40 <starbolt> Is there a functional equivalent or general advice for making old projects work?
16:45:13 <monochrom> In most cases you just need to say v1-this, v1-that.
16:45:25 <monochrom> Again, cabal --help
16:45:44 <starbolt> Oh I see. Thanks.
16:54:28 <dmwit> starbolt: It should be the case that just `cabal build all` works now, if sandboxes worked in the past.
16:54:47 <dmwit> The need for sandboxes has been removed, by centralizing the sandboxes and hiding them from the user-facing UI.
16:54:47 <starbolt> ^^thanks
16:55:38 <dmwit> (Sandboxes were such a good idea that we just did them everywhere all the time!)
16:55:42 <sclv> mouse008[m]: you only have to point it at the modified ones afaik
17:01:30 <Axman6> are sandboxes reused, like stack libraries are, these days?
17:02:36 <yushyin> see https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
17:02:43 <dmwit> Libraries are reused. Sandboxes don't exist.
17:02:56 <dmwit> (Yes, I simultaneously say "sandboxes everywhere" and "sandboxes don't exist"!)
17:03:16 <Axman6> yeah I had a feeling that was the case now
17:03:36 <monochrom> That's deep philosophy :)
17:03:51 <dmwit> There's just one big pile of libraries in a central location. If you need a library with a specific dependency tree, it checks if it's already got that one in the pile and if not the pile gets bigger.
17:04:34 <monochrom> One way I describe is: v2 and sandbox solve the same problem by different approaches.
17:04:43 <dmwit> Then the story is complicated a little bit by the concept of "local packages", which don't go in the central pile because the user says they churn too much.
17:05:16 <dmwit> But if you're just building a package that used to work with sandboxes, you don't have a project file yet and so don't have any local packages, so you don't notice this wrinkle yet. =)
17:05:46 <monochrom> Another way briefly say what approaches: v2 gives similar semantics as sandbox, but shares and reuses what's conservatively sharable.
17:06:08 <dmwit> And then you say: one of the fun things about languages that take immutability seriously is writing a good GC. You say libraries never change in cabal-v2, so what's the GC story. And then I frown. =P
17:06:49 <dmwit> "disk space is cheap" is the current party line
17:07:04 <monochrom> or conservatively safe to share
17:08:09 <freeman42x[m]> anyone know how to set GHCI settings per project? same type of settings you would set under `~/.ghci`
17:08:20 <monochrom> but you can be paranoid and find out that the conservative safety is predicated on a cryptographical assumption >:)
17:10:38 <freeman42x[m]> ah `.ghci` file in project folder, works fine
17:16:04 <dmwit> monochrom: Hm, what would that look like?
17:17:00 <monochrom> which one? the way cabal v2 determines what's safe to share?
17:17:24 <dmwit> What would it look like to set up something where checking whether it's safe to share something would involve breaking a cryptographic assumption?
17:18:20 <dmwit> Oh, maybe I misread. Maybe you meant "the paranoid person discovers that it just uses a hash and worries there will be a collision".
17:18:28 <monochrom> Yes
17:18:32 <dmwit> ok =)
17:19:31 <freeman42x[m]> why would `main` not be available in `cabal repl`? https://i.imgur.com/BwHAVpz.png if I run `cabal run` the program runs fine
17:20:14 <dmwit> 1. Perhaps you currently have the wrong module loaded. Use :m *Main to fix.
17:20:36 <Axman6>  :m +Main?
17:20:36 <dmwit> 2. Perhaps you currently have a repl for the wrong component. Use `cabal repl exe:whatever` to fix.
17:20:45 <dmwit> Depends what you want loaded.
17:21:00 <dmwit> + if you only want what's exported, * if you want what ghci traditionally does with loaded modules
17:22:14 <dmwit> freeman42x[m]: I use a two-line prompt that includes %s in the first line exactly so that I can tell when I am in situation 1. You might want to adopt a similar configuration if you plan to do heavy-duty development with cabal repl.
17:22:56 <freeman42x[m]> dmwit: 1. works 2. I tried using cabal repl exe:haskell-editor-setup, where haskell-editor-setup is the name from .cabal for `executable` section and it does not load it
17:23:20 <dmwit> Twist ending: both 1 and 2 can be the case at the same time.
17:23:24 <freeman42x[m]> Axman6: `:m +Main` also works
17:23:44 <monochrom> It does look like you were in Type not Main.
17:24:12 <freeman42x[m]> dmwit: what do you pass to `:set prompt` for your config?
17:24:13 <dmwit> So your "I tried using cabal repl exe:haskell-editor-setup and it does not load it" can mean you now got the right component but the wrong module within it.
17:24:23 <dmwit> :set prompt "%s\n\ESC[32m\STX>>>\ESC[0m\STX "
17:24:37 <dmwit> :set prompt2 "\ESC[32m\STX...\ESC[0m\STX "
17:24:39 <monochrom> Kill your customized lambda prompt. There is a reason the default prompt goes like "*Main>" or "*Type>" or etc.
17:24:42 <freeman42x[m]> dmwit: I basically just want main to be loaded when running `cabal repl`, that works fine on other projects
17:25:06 <dmj`> there's no ghc flag to pretty up what -ddump-splices spits out right
17:25:21 <dmwit> Pretty up in what way?
17:25:40 <freeman42x[m]> dmwit: what is difference between `:set prompt` and `:set prompt2`, both needed?
17:26:01 <monochrom> prompt2 is when you enter :{
17:26:04 <dmj`> dmwit: just like remove all the module prefixes, maybe some light renaming of the variables
17:26:06 <dmwit> The first prompt is used in all the places you know and love. The second prompt is used for multiline entries.
17:26:20 <dmwit> So yes, :{ or when automatic multiline kicks in if you have that enabled.
17:26:48 <monochrom> I think I'll be royally unpopular if I say "the GHC user's guide"
17:27:09 <dmwit> dmj`: I believe no.
17:28:15 <dmwit> freeman42x[m]: Okay. I don't know if cabal has a syntax to request a specific module be the one loaded immediately when cabal repl starts. You could consider making component-specific .ghci files and pointing cabal at them as appropriate when you want a repl for each component.
17:28:38 <dmwit> If you have just one component, then... just put that stuff in .ghci I guess? And be confused later when your package grows another component. =P
17:29:28 <monochrom> If there is just one component, this wouldn't happen in the first place.
17:29:51 <dmwit> monochrom: Why not? The problem is choosing which module to make top-level, not which component to use.
17:29:55 <freeman42x[m]> dmwit: does module name prepended with * not being the main module mean I can't run main? see: https://i.imgur.com/fJm3SnC.png
17:30:03 <monochrom> I do have my own multi-exe package, and "cabal repl exe:whatever" works perfectly.
17:30:25 <monochrom> In fact more confusingly, my package has 3 exes, 1 lib, and the lib is listed first.
17:30:39 <dmwit> freeman42x[m]: That means that OS.Linux.NixOS's internals are exposed. If main is not in scope in OS.Linux.NixOS, then it won't be in scope at your prompt.
17:31:01 <freeman42x[m]> monochrom: there is only 1 component: https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/haskell-editor-setup.cabal#L12
17:31:21 <monochrom> dmwit: When it's one component and it's an exe, main-is is the top level.
17:31:53 <dmwit> monochrom: I'm not sure what conclusion you make from that. It loads the right module for your package, therefore it should load the right module for freeman42x[m]'s package? But there is empirical evidence saying otherwise, so what gives?
17:33:13 <freeman42x[m]> dmwit: so I do not understand why it is not loading main on `cabal repl` like it used to. Perhaps the `.ghci` is what broke it. Will test that
17:34:07 <monochrom> OK fine.
17:35:24 <dmwit> For what it's worth, I don't know why it isn't making *Main the module set either. =P
17:42:20 <freeman42x[m]> I added to `.ghci` to run `:m +Main` and it prints error now on load: https://gist.github.com/razvan-flavius-panda/f31c0e5a183c145d5ff2374beb36aa89
17:43:17 <freeman42x[m]> if I remove `:m +Main` from `.ghci` the error dissapears
17:43:52 <freeman42x[m]> even if I delete `.ghci` main still does not go in scope on `cabal repl`
17:44:15 <dmwit> Haha, whoops. .ghci being run too early is unfortunate.
17:44:30 <dmwit> Give up, bag groceries instead.
17:46:45 <freeman42x[m]> what is difference between `:m +Main` and `:m *Main` ? I will have to ask a SO question about this
17:47:20 <freeman42x[m]> I do not use stack so no other way I know of to test stuff, would have tried stack repl also out of curiosity
17:47:48 <dmwit> I said the difference above. You can also read the documentation; look for the "what's in scope at the prompt?" section of the ghci reference.
17:48:04 <dmwit> This doesn't need SO; it is already carefully written down.
17:48:10 <monochrom> Don't forgt :m +*Main too
17:48:34 <monochrom> OK yay I am not alone.
17:48:41 <Axman6> I always make sure I use :m ++Main to make sure I don't get the previous version of Main
17:48:52 <monochrom> I was about to give up.
17:49:14 <dmwit> Yes, accidentally :m Main++ and getting the old version is a very easy mistake to make once or twice.
17:49:24 <monochrom> Still, doesn't stop SO answerers to get nerd-sniped.  People beg to be nerd-sniped.  The whole point they sit around on SO waiting.
17:49:50 <freeman42x[m]> > I said the difference above. You can also read the documentation; look for the "what's in scope at the prompt?" section of the ghci reference.
17:49:50 <freeman42x[m]> Got it, thank you. No, I was not talking about that + vs *. I was discussing about the main issue I'm having.
17:49:53 <lambdabot>  <hint>:1:65: error: parse error on input ‘;’
17:49:56 <monochrom> It's hopeless.  Humanity is hopeless.
17:51:39 <fishooter> When I'm writing some monadic code (inside STM), how can I simplify nested if / else / if / else statements?
17:52:10 <fishooter> example: https://repl.it/repls/BriskSubstantialRegression
17:52:29 <fishooter> if I wrote some C code, I wouldn't have to use the else statement
17:53:40 <ski> @type when
17:53:42 <lambdabot> Applicative f => Bool -> f () -> f ()
17:53:44 <ski> @type unless
17:53:46 <lambdabot> Applicative f => Bool -> f () -> f ()
17:54:24 <freeman42x[m]> I am using an Atom extension that gives access to a REPL inside Atom and that REPL is configured to use cabal repl. And after it loads I can access main to run the program... This is very weird.
17:54:37 <fishooter> thanks :)
17:54:44 <ski> (hm, Brisk was a Haskell implementation)
18:03:03 <dmwit> fishooter: https://stackoverflow.com/q/33005903/791604
18:03:04 <monochrom> This one the if-then-else cannot be further simplified.
18:03:24 <dmwit> fishooter: I do not believe when/unless will help you here, because you need actually return interesting data and when/unless cannot do that.
18:03:55 <dmwit> monochrom: ExceptT will do the job. =)
18:06:32 <monochrom> I'm trying to think up a philosophical reason against it, because clearly it is correct mathematically.
18:07:02 <dmwit> Cool! Let me know when you've got one. =D
18:07:18 <monochrom> I can think up: artificial assymetry between the earlier return values and the last one.
18:07:41 <monochrom> In that light, I think I know how to one-up the game.
18:07:48 <monochrom> Use ContT and callCC.
18:08:06 <koz_> monochrom: Woah woah woah.
18:08:11 <koz_> Straight to nuclear.
18:08:16 <monochrom> It's early exit so let's get serious about early exit.
18:08:35 <koz_> "ContT - leave the party early seriously"
18:08:43 <monochrom> >:)
18:09:20 <dmwit> Hm. Okay. I think sometimes the less powerful abstraction is better, because it's harder to shoot your foot.
18:09:38 <koz_> And ContT is the equivalent of playing hot potato with a nuclear shotgun.
18:09:45 <dmwit> Or, well, if you shoot your foot at least there will be a hole in it instead of no more foot. =P
18:09:57 <koz_> You will shoot off not only your own feet, but all other feet in the area.
18:12:42 <monochrom> I was just joking!  And grumpy that I didn't have time to inflict call/cc on my students in my course.  ExceptT is perfectly adequate for this, don't worry.
18:12:53 <koz_> monochrom: 'inflict' lol.
18:14:07 <monochrom> call/cc is all about holes.
18:14:53 <monochrom> On the bright side it also means the surrounding foot of the foothole still exists, you don't get to the no-foot state.
18:21:45 <dmwit> yay!
18:22:03 <dmwit> My foot isn't connected to my leg anymore, but at least I can hold it in my hand. ^_^
18:22:34 <dmwit> No, seriously, though: I'm sad you didn't get to inflict call/cc on me. I'd take that course if it were let's say under 4 hours.
18:30:54 <mouse008[m]> #sclv: my goal is to free the project from having to be aware which of the dependent packages have been installed locally (usually but not necessarily because they were modified), and which ones weren't and should be retrieved from remote repo (usually Hackage) and rebuilt.
18:33:45 <freeman42x[m]> aight, could not figure it out so asked on SO: https://stackoverflow.com/q/61199396/750216
18:33:59 <sm[m]> https://downforeveryoneorjustme.com/wiki.haskell.org  <- is down
18:48:35 <mouse008[m]> Is there a way to list all the packages (executables, libraries) installed via `cabal v2-install`?
18:49:29 <mouse008[m]> And a silly question - how do you address a post to a user here?
18:49:42 <ski> mouse008[m] : like this ?
18:49:55 <sm[m]> damnit I was going for the easy one :)
18:50:08 <mouse008[m]> Yes - what symbols do I use?
18:50:17 <ski> simply mention the nickname in question
18:50:31 <ski> (no need to adorn it with sigils. it's preferred if you don't)
18:50:35 <mouse008[m]> ski thank you - hopefully this works
18:50:57 <mouse008[m]> Hmm it didn't. What's missing?
18:51:37 <ski> what do you mean ? it did work
18:52:20 <sm[m]> mouse008: it will have highlighted in ski's IRC client. I think your matrix client shows matrix nicks with extra highlighting, which it doesn't do for IRC nicks
18:54:04 <mouse008[m]> I mean that it didn't mark the message for the user. 
18:54:04 <mouse008[m]> sm thanks - so it's the deficiency of my client that I don't see the highlighting? I'm trying to make sure IRC users get notified when a message for them is posted
18:54:43 <sm[m]> yes. You did it fine, ski was notified
18:54:54 <mouse008[m]> Thanks!
18:54:59 <sm[m]> and in this room it's about 98% IRC users, FYI
18:55:12 <ski> it's the person who's highlighted who sees the highlighting
18:55:22 <mouse008[m]> Which is why I worried and wanted to make sure :-)
18:55:26 <ski> (which can appear differently, in different IRC clients)
18:55:41 <mouse008[m]> Great, thanks.
18:55:59 <ski> however, many IRC clients just highlight/alert/notify, when their nickname is mentioned as first thing, in a message
18:56:18 <ski> not as many highlight when it's mentioned anywhere in a message
18:56:34 <mouse008[m]> Now, maybe somebody could clue me in on that Cabal question...? :/)
18:56:36 <ski> (so, this is a reason to e.g. not say "@ski blah blah ..")
18:57:01 <mouse008[m]> Yep, got it. It's convenient this way.
18:59:43 <mouse008[m]> I'd like to be able to list globally installed packages, ideally - with their versions and build flags (Cabal-installed).
18:59:43 <mouse008[m]> And I'd like to know if I can enforce flags for building dependent packages (that, e.g., Cabal installs).
19:04:23 <foobarcloud> is a pure, lazy language easier to implement in haskell or in an impure, strict language?
19:05:15 <koz_> foobarcloud: I don't think it makes a serious difference honestly, assuming you're not writing an interpreter.
19:05:21 <koz_> And even then I don't think it makes much difference.
19:06:44 <monochrom> dmwit: My draft is at http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Winter/Continuation.hs
19:07:04 <d34df00d> Nested fmap . fmaps are old, how'bout `mapM $ mapM sequence`?
19:07:18 <d34df00d> In other words, how would you write `mapM (mapM sequence) [(1 :: Int, (2 :: Float, pure @IO 'c'))]` to pull IO outside?
19:08:42 <freeman42x[m]> I am trying to do a thing... but it not work: https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/src/OS/Linux/NixOS.hs#L31
19:09:20 <koz_> d34df00d: traverse . traverse?
19:09:44 <d34df00d> koz_: I think it has a different type.
19:09:46 <monochrom> foobarcloud: laziness is easiest to implement by mutable variables. I know because I tried the other way.
19:09:54 <koz_> d34df00d: traverse _is_ mapM I believe.
19:09:56 <koz_> :t mapM
19:09:58 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
19:10:02 <koz_> :t traverse
19:10:03 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:10:17 <d34df00d> Ah, right. But it'd be traverse $ traverse sequence then right?
19:10:24 <Axman6> <spiderman pointing at spiderman meme>
19:10:29 <d34df00d> BTW what's the reason d'etre of mapM when there is traverse?
19:10:30 <koz_> Axman6: LOL
19:10:36 <koz_> d34df00d: Hysterical raisins.
19:10:41 <koz_> Traversable was discovered later.
19:10:45 <d34df00d> That's the best kind of raisins.
19:10:55 <d34df00d> (unless you consider higher-kinded ones)
19:10:58 <monochrom> however, if you take a concession and weaken to call-by-name, it can be implemented just as easily in an immutable language.
19:11:05 <Axman6> :t traverse . traverse . traverse $ id
19:11:07 <lambdabot> (Applicative f, Traversable t1, Traversable t2, Traversable t3) => t1 (t2 (t3 (f b))) -> f (t1 (t2 (t3 b)))
19:11:23 <d34df00d> traverse traverse traverse
19:11:24 <d34df00d> So much fun.
19:11:46 <koz_> Gotta do all the traversing.
19:11:52 <koz_> It's probably the number 1 function I use the most.
19:11:57 <koz_> (and its discarding sibling traverse_)
19:11:59 <sclv> mouse008[m]: you can’t do what you want with v2. its not designed for that.
19:12:14 <d34df00d> I'd still use mapM cause it's less typing.
19:12:18 <d34df00d> And shifts my code less to the right.
19:13:07 <koz_> d34df00d: Solution - 'tvrs = traverse'. :P
19:13:43 <d34df00d> That gotta go in my utils module!
19:14:11 <koz_> Alternative: 'mapA = traverse'.
19:16:05 <monochrom> traverse_ and traverse are more like cousins than siblings. even uncle-nephew
19:17:00 <koz_> monochrom: Category geneaology.
19:18:53 <monochrom> Perhaps like European noble families, they're cousins and uncle-nephew and in-laws and in-laws-another-way, simultaneously :)
19:19:09 <koz_> monochrom: Yep, you _need_ category theory to sort out those family trees.
19:20:01 <monochrom> logical relations are so much simpler.
19:20:05 <ski> (hm, a bit back among my relatives, there were two brothers who married a mother and a daughter)
19:20:50 <d34df00d> I just know there's a way to become your own grandfather (or grandmother).
19:21:23 <koz_> d34df00d: https://www.youtube.com/watch?v=0VxLQZPqI2M
19:21:53 <d34df00d> That one, yes!
19:22:32 <monochrom> Is this what you call graph rewriting
19:22:52 <koz_> monochrom: Knot-tying. :P
19:22:56 <d34df00d> haskell is awkward, yes.
19:23:36 <monochrom> I have a completely gross and horrid unspeakble unthinkable idea.
19:23:47 <koz_> monochrom: Kay?
19:24:08 <monochrom> We need to teach Homer the sci-fi idea of going back in time.
19:24:10 <nshepperd2> i think technically he was only his own grandpa-in-law
19:24:17 <Axman6> If you can't unthink it, please speak it
19:24:45 <monochrom> So he would write the Oedipus story but with time travel to tie the knot.
19:25:52 <koz_> Same idea, in graph form: https://www.youtube.com/watch?v=qu_Y1wQ923g
19:27:30 <koz_> And this, ladies and gentlemen, is why family trees should remain acyclic.
19:28:47 <MarcelineVQ> monochrom: He probably had the tool but was smart enough to know that some tools damage the user
19:32:41 <mouse008[m]> sclv but Cabal v2 doesn't sandbox everything, does it? I haven't got a handle yet on how exactly it figures when am installed package is OK to reuse.
19:33:02 <mouse008[m]> * sclv but Cabal v2 doesn't sandbox everything, does it? I haven't got a handle yet on how exactly it figures when an installed package is OK to reuse.
19:33:07 <sclv> it does sandbox everything
19:33:27 <sclv> It calculates hashes that take everything into account
19:33:58 <sclv> Like the origin of the package, the hashes of its deps, the flags
19:34:24 <sclv> so there’s no global db, just a “store” that is used as a cache when everything matches
19:34:50 <sclv> literally just try v2 with a project file so you can specify local deps
19:34:54 <mouse008[m]> An I see. But what is "everything"? And on order to be repeatable, it has to have some canonical format to represent all those before running the hash?
19:35:14 <monochrom> Yes. They did it.
19:35:18 <mouse008[m]> * An I see. But what is "everything"? And in order to be repeatable, it has to have some canonical format to represent all those before running the hash?
19:35:21 <sclv> yes it uses its internal structure and hashes it
19:35:38 <sclv> everything is basically what I specified
19:35:57 <sclv> the full dep and origin tree and flags
19:36:17 <mouse008[m]> I have some v2 projects, and am trying to figure why they don't reuse dependencies...
19:36:47 <sclv> it calculates a plan “fresh” every configure and uses the cache where possible
19:37:11 <sclv> different projects won’t share local deps fwiw
19:37:40 <sclv> but often you might have the same pkg and version but a different hash because some dep of that pkg is different
19:37:41 <mouse008[m]> What do you mean by "full dep and origin tree"? Particularly, what does "origin" mean in this context, and why does it matter?
19:37:54 <sclv> origin is if its from hackage or elsewhere
19:38:28 <sclv> full dep is the deps and their versions and their deps and versions etc
19:38:29 <freeman42x[m]> question about importing symbols in a .ghci config file: https://stackoverflow.com/questions/24050217/whats-the-right-way-to-reload-and-run-main-as-a-single-command-in-ghci#comment108266627_24050401
19:38:37 <mouse008[m]> I see. And "dep of that pkg"? 
19:38:49 <sclv> a depends on b depends on c
19:39:05 <sclv> a different choice of version of c will yield two b
19:39:19 <sclv> each different, but with the same version
19:39:40 <sclv> the plan.json file gives all the calculated details
19:39:52 <mouse008[m]> sclv: so in practice is almost never that an installed package would be reused?
19:40:18 <sclv> its very frequent but not always
19:40:35 <mouse008[m]> Where is that `plan.json` stored? Hire can I examine it?
19:40:48 <mouse008[m]> * Where is that `plan.json` stored? How can I examine it?
19:40:49 <sclv> especially if you cabal update then it’ll pull in newer versions in the next configure
19:41:12 <sclv> https://hackage.haskell.org/package/cabal-plan
19:41:50 <mouse008[m]> And there's no tool to list what's already there in the global store and to help me pruning what I think isn't needed any more?
19:42:17 <sclv> you should not prune the global store
19:42:19 <sclv> Just don’t
19:42:48 <dsal> Is stylish-haskell still the way to style haskell?
19:43:30 <Axman6> it's a way - there's about half a dozen options these days, and I find them all annoying and not configurable enough. stylish-haskell is the best I've found though
19:43:48 <sclv> currently the only safe option on the global store is delete the whole thing
19:43:50 <dsal> Thanks.  It's what I've been using.  I've heard stories of others.
19:44:23 <mouse008[m]> sclv: thanks! `cabal-plan` seems very useful. I'll install it ASAP and play with it.
19:45:27 <monochrom> In practice, you cannot use build products made by GHC version m when you move to GHC version n, m/=n.
19:45:31 <mouse008[m]> Is there a way to ensure all the dependent packages will be built with the flags I want? Not just the project itself?
19:46:18 <monochrom> This means when you leave GHC version m, you just delete .cabal/store/ghc-m
19:47:10 <mouse008[m]> monochrom: yes, understood. But in my case "it" seems to avoid reusing even with the same versions of GHC, Cabal, and (presumably) same dependencies. 
19:47:30 <monochrom> except for executable still there that you have symlinked to your real PATH directories.
19:47:48 <monochrom> this is why I hate the symlinking policy since day 1.
19:48:34 <mouse008[m]> Yeah, but I can track those executables easily enough - their links contain GHC version.
19:50:46 <mouse008[m]> I've had to delete the whole store a few times recently, but that's not related to this discussion. Broken Cabal (dynamically built from GitHub repo) corrupted the store, so had to rebuild it all...
19:52:23 <mouse008[m]> So, how to ensure that all the dependent packages are built with exactly the same flags I set for the main project (that requires those dependencies)?
19:53:21 <sclv> you can set flags for packages in the cabal.project file
19:55:55 <fishooter> can you somehow elegantly write `if a < b < c` or do you always have to expand it to `if a < b && b < c ` ?
19:56:23 <monochrom> always expand. or define your own function name.
19:57:47 <hyperisco> Define a mixfix operator in Coq, then compile Coq to Haskell. (I am feeling creative)
19:58:14 <monochrom> I'm creative but still somewhat grounded.
19:58:24 <mouse008[m]> sclv: but do I need to list all those packages explicitly "by name" in `cabal.project`, is is there some form of "for all the dependencies do *this*"?
19:58:36 <monochrom> generalize to checking that an arbitrary-length list is increasing.
19:58:37 <mouse008[m]> * sclv: but do I need to list all those packages explicitly "by name" in `cabal.project`, or is there some form of "for all the dependencies do *this*"?
19:59:03 <monochrom> For that, start being cute with zip and foldr/l and scanr/l
19:59:41 <monochrom> and also somehow do it on arbitrary Foldable instances, not just list  (pfff)
19:59:50 <MarcelineVQ> cuteness activated:  and . (zipWith (<) <*> tail)
20:01:06 <sclv> use a package * stanza as documented in the fine manual, which you should read https://www.haskell.org/cabal/users-guide/nix-local-build.html#configuring-builds-with-cabal-project
20:01:24 <monochrom> the road to elegance is long and lonely
20:01:35 <monochrom> if you see Budhha, kill Buddha
20:02:12 <mouse008[m]> And if would cover local and remote packages, right? 
20:02:12 <MarcelineVQ> If, on your journey, you should encounter God, God will be cut
20:02:12 <mouse008[m]> I started that fine manual, will go deeper. ;-)
20:02:28 <mouse008[m]> * And it would cover local and remote packages, right? 
20:02:28 <mouse008[m]> I started that fine manual, will go deeper. ;-)
20:15:15 <dmwit> monochrom: sweet, thanks! i will take a look and pester you with questions
21:26:40 <freeman42x[m]> if I understand correctly, what this package does is basically re-export stuff from a lot of util type libraries? https://hackage.haskell.org/package/rebase
21:28:32 <Axman6> Looks like it
21:29:18 <dmj`> an astute observation
21:46:15 <freeman42x[m]> this is so funny: https://i.imgur.com/q7iiLF0.png
22:19:19 <freeman42x[m]> `One minor difference: head in protolude returns Maybe a while in relude it works with NonEmpty.` what would be pros/cons of one over the other?
22:20:56 <MarcelineVQ> head [] is an exception, NonEmpty can require extra pattern matches to work with. NonEmpty is essentially (a,[a])
22:21:43 <MarcelineVQ> exceptions in non IO code are a thing we want to avoid because we can't choose where/when to catch them outside of IO
22:22:02 <dsal> head [] is dividing by zero.
22:22:15 <MarcelineVQ> Another option is to use a sort of safeHead instead of NonEmpty,  safeHead :: [a] -> Maybe a
22:22:34 <MarcelineVQ> So if we get [] we can result in Nothing
22:22:54 <dsal> :t listToMaybe
22:22:55 <lambdabot> [a] -> Maybe a
22:25:27 <dmwit> You, a plebian: NonEmpty
22:26:13 <dmwit> Me, a sophisticated Haskell initiate: Product Identity []
22:28:17 <MarcelineVQ> :>
22:29:24 <MarcelineVQ> Data.List.NonEmpty.fromList []  *** Exception: NonEmpty.fromList: empty list              The sins of the father have tainted the child...
22:30:59 <Axman6> <shocked pikachu face>
22:31:04 <DigitalKiwi> to be extra safe it should be Maybe NonEmpty
22:35:32 <Axman6> (The correct function to use is called nonEmpty)
23:33:03 <freeman42x[m]> DigitalKiwi: Maybe Unsure Perhaps NonEmpty for those especially careful
