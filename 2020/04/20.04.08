00:39:24 <Guest59> I am looking into indentation and came across an example I don't understand: https://pastebin.com/zgdE25Kt I thought that a ';' should be added infront of `++` thus leading to a parse error but my compiler apparently accepts it. Could you help me figuring out my mistake?
00:40:53 <cdunklau> Guest59: bump the indentation of lines 3, 4, and 5 to the right a bit
00:41:39 <cdunklau> Guest59: (this is mostly a guess)
00:42:39 <Guest59> Sorry, maybe I wasn't clear enough. I fully expected a parse error after reading into how `{` and `;` are added by the compiler. But in my example there was *no* parse error. This confuses me.
00:42:42 <opqdonut> cdunklau: his question is why does the code work
00:43:03 <opqdonut> as far as I can see, there is no special case for infix operators in the haskell 2010 report layout rules
00:43:16 <opqdonut> so maybe that's a ghc convenience feature?
00:43:22 <cdunklau> opqdonut: ah thanks. 
01:12:52 * hackage mason 0.2 - Fast and extensible bytestring builder  https://hackage.haskell.org/package/mason-0.2 (FumiakiKinoshita)
01:50:04 <refusenick> Is it possible to have main be something other than "main :: IO()"? The FRP examples I've seen so far have main return IO() in the end.
01:50:28 <refusenick> I phrased the 1st sentence poorly. You see what I mean.
01:51:21 <cdunklau> refusenick: what else would main be?
01:53:01 <refusenick> cdunklau: IDK. Some kind of custom continuous reader/writer monad?
01:53:09 <refusenick> Perhaps an arrow?
01:53:21 <iqubic> refusenick: No. Main :: IO () is required by Haskell.
01:53:49 <iqubic> GHC requires main to have type IO ()
01:54:06 <refusenick> iqubic: Why and where does it say that?
01:57:42 <yushyin> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-980005
02:01:13 <yushyin> refusenick: as you can read, any value IO a goes
02:02:23 <lortabac> since the value is discarded, in practice the only type that makes sense is IO ()
02:03:15 <yushyin> right
02:03:48 <tdammers> you can of course write a function that converts whatever paradigm you want to use into IO ()
02:04:13 <zincy_> Is this a "Help how do I print a string without using monads?"
02:04:40 <tdammers> e.g., if you can express your program in terms of [Response] -> [Request], then you would write a function runHandler :: ([Response] -> [Request]) -> IO ()
02:05:09 <tdammers> same for FRP
02:05:15 <zincy_> refusenick: Is there any reason you don't want to have a main?
02:05:26 <tdammers> FRP libs generally have a function somewhere that takes a "network" and runs it into IO
02:07:01 <tdammers> there is a way, btw. - you can write Haskell code without a Main.main, expose your own custom entry point via FFI, and then link your Haskell object files into a C program that calls your custom entry point
02:07:14 <tdammers> but that's cheating, because it involves lying about the type of your custom entry point
02:08:11 <tdammers> it's also perfectly useless, because whatever semantics you want out of your custom entry point can also be expressed in terms of IO, and just writing that YourSemantics -> IO () function is going to be a more elegant solution
02:13:04 <merijn> iqubic: Technically not true, main is required to unify with "IO a", so you're not restricted to () :p
02:13:55 <refusenick> tdammers: "whatever semantics you want out of your custom entry point can also be expressed in terms of IO"
02:14:17 <refusenick> In the sense that IO's imperative language is Turing-complete, perhaps (I'm assuming it is, anyways)
02:14:42 <tdammers> it is
02:14:44 <iqubic> What?! What happens if you have the small toy program: ` main = PutStrLn "Hello" >> return 1` ?
02:14:51 <tdammers> but TC has nothing to do with it, really
02:14:58 <tdammers> Haskell's pure expressions are also TC
02:14:59 <ski> iqubic : `1' is discarded
02:15:06 <iqubic> really?
02:15:08 <ski> yes
02:15:14 <refusenick> What if you were linking against a non-imperative language, e.g. composing two Haskell programs which read and write streams of bytes in some agreed-on format?
02:15:26 <merijn> "main :: IO Int" is perfectly legal. Rather pointless so nothing is done with the Int in GHC compiled programs, but if you consider say a haskell OS then that could possibly use something like that
02:15:26 <iqubic> Why does GHC allow thi?
02:15:51 <refusenick> Doesn't IO effectively describe an interpreter to be generated at runtime?
02:15:58 <merijn> iqubic: Because the Haskell report allows it?
02:16:12 <merijn> refusenick: Yes, no, maybe, it depends
02:16:12 <tdammers> refusenick: you can think of it as that, yes
02:16:21 <iqubic> Alright... Why does the Haskell report allow it?
02:16:28 <tdammers> refusenick: the point, however, is that IO captures anything a Haskell program can possibly do
02:16:41 <merijn> refusenick: That's a useful *semantic* model (i.e. what code means), but not what any sane compiler actually generates
02:16:56 <refusenick> tdammers: ...on a sequential machine
02:17:05 <tdammers> refusenick: no. IO captures it all.
02:17:10 <merijn> iqubic: Why not? Compilers could do something useful with it and if you had a Haskell based OS you could actually use the return value of a process in your OS
02:17:16 <refusenick> Are there rules for IO with concurrent, distributed programs, then?
02:17:19 <tdammers> :t forkIO -- refusenick 
02:17:20 <lambdabot> error: Variable not in scope: forkIO
02:17:23 <tdammers> oof
02:17:44 <tdammers> there are concurrency primitives in IO, yes
02:18:06 <refusenick> Threads and mutexes, no?
02:18:19 <ski> @type Control.Concurrent.forkIO
02:18:22 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
02:18:23 <merijn> iqubic: GHC doesn't do anything useful with the result of a program, but nothing is restricting other implementations from doing something useful with the result of main
02:18:39 <tdammers> and you can express distributed programs in terms of IO; you will have to do the footwork yourself, that is, there is no built-in sugar for automatic ser/deser, but you can very much write a distributed computing framework on top of IO
02:18:57 <tdammers> you can *not* write a distributed computing framework *without* using IO anywhere
02:19:03 <refusenick> Could you replace IO with a monad which instead describes computation in a linearly-typed abstract machine or process calculus?
02:19:13 <merijn> refusenick: Yes, no, maybe
02:19:29 <tdammers> refusenick: you probably could, but that language would no longer be Haskell
02:19:33 <merijn> refusenick: Define "could", "replace" and "process calculus"
02:19:52 <Athas> nh2: you are the one behind https://github.com/nh2/static-haskell-nix, right?
02:20:29 <tdammers> refusenick: that said, there are a few Haskell-like languages that use different models for interacting with the real world, such as PureScript (uses an Effects system), Elm (uses "ports", kind of a streaming-reactive model)
02:20:37 <tdammers> etc.
02:20:49 <Athas> I'm confused about how to use it for my own package.  The only example says "don't use this in practice" and that I should read the README more, but I can't see where it says what to actually *do*.
02:20:56 <refusenick> merijn: by "replace", I mean "be really sneaking and make your own module called System.Environment with its own IO monad".
02:21:28 <tdammers> refusenick: you can't monkey-patch your own drop-in replacement into a Haskell program, if that's what you mean
02:21:36 <tdammers> IO comes with the compiler and cannot be overridden
02:21:40 <refusenick> merijn: By "process calculus", I mean "process calculus" - pi calculus, join calculus, etc
02:22:22 <refusenick> tdammers: Well, that about answers it. What's with all the talk of effect systems and their flexibility, then, if it all gets smushed through IO in the end?
02:22:31 <tdammers> also keep in mind that the "monad" part is a red herring - IO happens to have a Monad instance, and some crucial functionality is only exposed through the Monad API, but being a Monad is not what's special about IO
02:23:01 <tdammers> the advantage of an effect system is that you only need to worry about IO being overly broad in a very small, contained portion of your program
02:23:29 <refusenick> Like FRP, then, but more general and not handling the continuous time chimera.
02:23:37 <tdammers> you do convert the effects-based entry point to an IO () in the end, but anywhere that uses the effects system instead of IO, you can just reason in terms of those effects and ignore IO
02:24:11 <merijn> refusenick: What's the point of writing haskell if in the end it all just gets smushed down to assembly?
02:24:18 <tdammers> this isn't special, it's actually VERY common in Haskell code: the deeper you descend into the expression graph, the more specific your types become
02:24:33 <refusenick> merijn: lolreduceron
02:24:57 <tdammers> e.g., consider this program: main = do { a <- read <$> getLine; b <- read <$> getLine; print (a + b) }
02:25:13 <tdammers> main is :: IO (), but (+) most certainly isn't
02:25:17 <merijn> refusenick: The point is that abstractions let you reason about something at a simpler and more precise level
02:25:55 <tdammers> so when you look at the (a + b) expression, you can COMPLETELY ignore the fact that IO exist, because IO doesn't appear anywhere in the type
02:27:44 <refusenick> The difficulty in writing parallel Haskell compared to other pure languages with uniqueness types instead is starting to make more sense.
02:28:12 <merijn> "compared to pure languages with uniqueness types" <- how many of those are there? >.>
02:28:19 <refusenick> Clean, Mercury
02:28:34 <Athas> It's easy to write parallel Haskell that is correct.  It's just very hard to make it fast.
02:28:42 <Athas> But if you just want to keep all the cores busy, Haskell can help you!
02:28:58 <merijn> Athas: Which is perfectly fine if your parallelism is IO bound :)
02:29:14 <refusenick> I've tried one of them. The normal conjunction is , (same as Prolog); parallel conjunction is &. For the most part, it "just werks" (modulo a few type caveats which I don't understand)
02:29:20 <merijn> Which fortunately covers a significant percentage of all parallelism problems :p
02:30:26 <tdammers> compared to writing parallel / concurrent programs in C++, Java, JavaScript, or Python, doing in Haskell is an absolute joy
02:30:47 <tdammers> the difference between Haskell and, say, Clean or Mercury, is pretty much a luxury problem in comparison
02:31:07 <merijn> tdammers: The difference between Haskell and those is that Haskell has users :p *duck*
02:31:12 <tdammers> that too
02:31:36 <tdammers> also production-ready libraries for more than six niche use cases
02:31:39 <refusenick> tdammers: No disputing that. Of course, now that everyone's admitting that Dennard scaling is dead and the future is "more chiplets", you've got to assume everything that can't survive in a parallel world is going to start dying sooner or later.
02:31:52 <tdammers> don't be so sure
02:31:59 <gentauro> tdammers: and merijn is there any chance that Haskellers will go the Miranda-way, now that it's open sourced?
02:32:03 <merijn> Don't tell the Radboud university I said that >.>
02:32:09 <merijn> gentauro: No
02:32:25 <merijn> refusenick: haha'
02:32:39 <tdammers> you also have to acknowlege that most practical computing problems are simple enough for a single current CPU core to be way overkill already
02:33:11 <merijn> refusenick: NJ is struggling to find COBOL programmers and I know several people making 300k per year to "decompile cobol binaries, translate them to a new supported cobol compiler and recompile them", but sure all legacy code will die any day now :)
02:33:15 <tdammers> and hence, the main way "more hardware parallelism" is going to be exploited is not by making individual things run faster, but by being able to do more of them concurrently
02:33:25 <merijn> tdammers++
02:33:40 <tdammers> *especially* in the huge "end-user devices" segment
02:34:05 <merijn> gentauro: I mean "switch to Miranda" sounds to me like "throw out decades of ecosystem and library development over minor language nits"
02:34:07 * [exa] imagines more browser tabs
02:34:09 <tdammers> I have a CPU that can handle 12 concurrent threads. But except for compiling large software programs, I rarely max out more than 3-4 of them
02:34:33 <tdammers> yeah, more browser tabs, essentially
02:34:37 <refusenick> My Core2Duo regularly hangs while running Firefox with >30 tabs.
02:34:54 <refusenick> Core2Duo's ancient, but how much faster can phones be?
02:34:54 <merijn> refusenick: Yes, but is that due to shitty programming or insufficient compute :p
02:35:18 <tdammers> but browser tabs have to run in isolated contexts anyway, if only for security reasons; and once you have set up that level of isolation, most of the usual problems of concurrent and parallel programming disappear
02:35:21 <gentauro> refusenick: well you can't use 30 tabs at once
02:35:26 <gentauro> so somethings is not coded well
02:35:27 <gentauro> :P
02:35:31 <refusenick> merijn: Well, there's no way around shitty programming if it's a pile of (pre-C++11) C++ + JS.
02:35:31 <merijn> Modern phones have more than enough compute for 90% of things people want, assuming they were implemented well
02:36:01 <[exa]> anyway this discussion reminds me the biggest problem of multithreading today-- is there some reasonable mechanism to allocate and balance CPU resources between processes?
02:36:17 <merijn> [exa]: Tons, several decades of research even :p
02:36:19 <Athas> "CPU resources"?  You mean time slices?
02:36:22 <tdammers> I think the main bottleneck on modern consumer hardware is shitty programming and having to deal with stuff being strung together in horribly suboptimal ways for reasons that are entirely socio-economic
02:36:25 <Athas> Scheduling is a massively studied problem.
02:36:26 <[exa]> merijn: practical in an operating system?
02:36:30 <merijn> [exa]: Yes
02:36:58 <merijn> [exa]: There's lots of literature on scheduling with all sorts of constraints, different optimisation schemes, etc.
02:37:09 <merijn> But scheduling is like GC "it's trade-offs all the way down"
02:37:11 <Athas> The most succesful highly concurrent and parallel programming model in the world is probably server side web programming.
02:37:12 <[exa]> merijn: I don't mean _scheduler_, I mean something that tells the program "you will have at least 4 threads now for 10 seconds and you can pay the prize for optimizing your data for that kind of processing"
02:37:14 <refusenick> The real problem is Unix. Plain text and byte streams don't carry enough info for the OS to optimize as much as it really could.
02:37:18 <tdammers> I think the biggest practical problem in the scheduling realm right now is figuring out the best tradeoff
02:37:21 <Athas> And the concurrency is completely hidden from the programmer there.
02:37:22 <int-e> merijn: and computers are still sluggish to respond to user input ;)
02:37:37 <merijn> [exa]: There is research on scheduling if you can predict resource usage, yes
02:37:55 <merijn> int-e: I know, it's an embarassment to the field!
02:38:03 <[exa]> merijn: also, basically, something that tells the program "please use just 1 CPU now otherwise we'll totally throttle you"
02:38:09 <tdammers> in a web server, latencies of several milliseconds are acceptable, but you really do want massive throughput
02:38:11 <Athas> refusenick: why is the OS supposed to be involved at all?  It is better for the OS to get out of the way when things have to go fast.
02:38:22 <Athas> A modern web browser is probably more complex than an OS kernel, anyway.
02:38:30 <merijn> OS kernels are easy, tbh
02:38:37 <merijn> Their complexity is *way* overblown
02:38:39 <refusenick> Athas: Fast =/= low latency
02:38:40 <tdammers> in a realtime audio recording application, latencies are paramount, while reduced throughput is an acceptable sacrifice
02:38:43 <merijn> Drivers are hard
02:38:47 <[exa]> merijn: kinda same with memory, OSes do not have any means to tell the programs to e.g. try to minimize the memory because otherwise they will get OOM killed
02:38:50 <[exa]> merijn: +1 for kernels :]
02:38:56 <refusenick> Athas: ever heard of SynthesisOS?
02:39:16 <merijn> [exa]: You do realise the OOM killer is a linuxism? :)
02:39:16 <Athas> refusenick: yes.
02:39:40 <merijn> [exa]: Other OSes (like BSD) don't do infinite overcommit and malloc *will* start returning null if you allocate too much
02:39:51 <[exa]> merijn: well yes, other operating systems just do not overcommit, but that doesn't solve the problem
02:40:06 <merijn> [exa]: BSD does do overcommit, but bounded overcommit
02:40:40 <[exa]> a common case is that a program needs a bit of memory for doing something critical while another program just holds a huge bitmap cached because "yeah there was space for that"
02:40:58 <refusenick> Athas: I'm sure if you're running Futhark atop a bank of GPUs, you want the OS to avoid interfering, so it doesn't matter how fast it runs. Does that say anything about desktop performance, though?
02:41:13 <refusenick> how fast the kernels runs*
02:41:19 <refusenick> kernel*
02:41:28 <merijn> [exa]: That's what swap is for :p
02:41:28 <Athas> refusenick: but what exactly is the kernel supposed to contribute to performance?
02:41:49 <Athas> The kernel just needs to ensure application code can talk to hardware as fast as safely possible.
02:42:27 <refusenick> That's all there is in a microkernel. Monolithic kernels do a lot of the stuff reimplemented unperformantly in browsers, though.
02:42:44 <Athas> I'd wager browsers implement it much faster (for their needs) than the kernel does.
02:42:55 <Athas> After all, the kernel cannot specialise for any specific task.
02:43:16 <tdammers> kernels also need to make sure multiple processes can safely coexist
02:43:23 * refusenick looks at SynthesisOS papers again, looks back with raised eyebrow
02:43:27 <merijn> And ensure the kids play nice
02:43:35 <tdammers> merijn: "safely"
02:43:37 <merijn> kernels are basically kindergarden teachers
02:43:49 <merijn> No Timmy, it's Sarah's turn!
02:44:31 <refusenick> merijn: And that's because Unix assumes only plaintext communication, AKA communication at the level of a 5 year old.
02:45:30 <merijn> unix is not going anywhere, it'll hold us back for another 5+ decades at least
02:46:48 <Athas> refusenick: SynthesisOS has trouble with machines that don't provide good control of the icache, and that are pipelined(!).  That is essentially all modern machines.
02:47:02 <merijn> Athas: lol
02:47:13 <merijn> Athas: So basically it runs well on a Pentium? :)
02:47:15 <Athas> SynthesisOS's performance was also partially due to writing everything in super-tight assembly, and it was compared with the dismal state of Unix kernels in the early 90s.
02:47:20 <refusenick> merijn: Fuchsia isn't too much of a step away, but it is a step away. MirageOS isn't going to be a desktop system, but it shows that a radically different approach is possible. I hope Unix doesn't retain dominance for more than a century.
02:47:31 <Athas> Linux was initially famous for how it completely outperformed everything else in those days.
02:50:04 <Athas> I'm also not sure that OS computation overhead is really that significant these days.  It's mostly a question of whether the OS puts up barriers that prevent efficient hardware access, or require too many copies.
02:50:28 <merijn> Athas: I'm pretty sure it isn't, tbh
02:50:43 <Athas> And now we have hacky system calls like tee() to work around stuff like that.
02:50:56 <Athas> Not to mention eBPF.
02:52:04 <merijn> Athas: Don't forget my biggest linux pet peeve!
02:52:10 <Athas> Really, many big and performance-sensitive programs (browsers!) really don't need much from the OS.  They might be fine with a virtualisation-style OS.
02:52:15 <merijn> Athas: epoll (aka, "kqueue, but done shitty")
02:55:48 <refusenick> Did my last message (about a self-modifying bytecode interpreter) go through?
02:57:29 <ski> no
02:57:50 <refusenick> Are there Haskell projects building on Hume? https://en.wikipedia.org/wiki/Hume_(programming_language)
03:18:24 <gentauro> refusenick: I like this part of the example on Wikipedia: `within 500KB (400B) -- max heap ( max stack) cost bounding`
03:18:27 <gentauro> :o
03:26:50 * ski idly wonders what refusenick's message about "a self-modifying bytecode interpreter" was about
03:27:50 <[exa]> let's start futamuraOS
03:28:01 <iqubic> Sounds a bit like the IntCode thing from last December's Advent Of Code.
03:28:14 <refusenick> [exa]: We can call it "futa" for short.
03:28:18 <refusenick> I'll get started on the logo
03:29:30 <Uniaika> what the fuck did I just read
03:32:29 <maerwald> http://www.futamuragroup.com/en/markets/
03:33:04 <maerwald> Dairy cellulose films. Checks out
03:33:22 <refusenick> *dead silence*
03:37:42 <[exa]> refusenick: oh pls
03:38:01 <zincy_> If you want to log requests (save them to DB) with Servant. Should you be modifying Servant types or doing this at the WAI level by just writing custom middleware.
03:38:08 <[exa]> refusenick: this is serious OS! :D
03:38:34 <MarcelineVQ> this is serious mom
03:38:48 <[exa]> zincy_: depending on whether you want to just log HTTP transcript or some serious logic-aware actions
03:39:02 <[exa]> "logic" as in "application logic" not actual logic
03:39:26 <MarcelineVQ> ^ somewhere far away a PL fairy just died
03:39:41 <zincy_> haha
03:40:18 <zincy_> [exa]: Just data on the request itself - method, query params, path, headers etc
03:40:57 <[exa]> zincy_: I'd go with WAI
03:41:22 <[exa]> zincy_: anyway it may have some consequences, like e.g. identifying and filtering out sensitive data won't be that easy
03:42:04 <zincy_> [exa]: Thanks should I use this in wai-logger to persist request adata? LogCallback	:: (a -> IO ())	 -> IO () -> LogType' a
03:46:22 <infinity0> what do you call the transformation where you turn a recursive function non-recursive with an extra parameter for itself?
03:47:26 <zincy_> :t fix
03:47:27 <lambdabot> (a -> a) -> a
03:47:54 <infinity0> yes, you can put the resulting function into fix, i'm talking about the transformation itself, if it has a name
04:08:28 <[exa]> zincy_: not sure about WAI recommendations. Last time I used some default recommended thing for scotty which "just worked"
04:21:17 <zincy_> [exa]: Ah ok no worries, thanks.
04:30:54 <infinity0> so we have Data.Fix for defining parametric recursive datatypes, but what about mutually-recursive parametric datatypes
04:31:18 <infinity0> one can write "data A = Fix A'" but one can't write e.g. "data (A, B) = Fix2 A' B'"...
04:32:49 <phadej> you can simulate fixpoint of products with fixpoint on a single kind
04:32:58 <phadej> there's theorem about that
04:33:11 <phadej> wouldn't be pretty though.
04:33:48 <infinity0> hm do you have more details about it, maybe i can experiment with what it looks like
04:36:55 <[exa]> aren't there extra combinators just for that? (I recall seeing something like Fix2)
04:39:04 <tdammers> I have just found that WAI isn't as composable as I'd want it to be
04:39:38 <tdammers> I wrote a middleware that automatically checks the presence and correctness of a CSRF form token on all POST requests, but in order to make that happen I had to do unspeakable things
04:41:13 <maerwald> tdammers: what are you gonna do next?
04:42:28 <tdammers> maerwald: about the CSRF token?
04:42:40 <maerwald> yeah, is there an alternative?
04:42:50 <tdammers> there is - referer checks
04:43:38 <tdammers> but the goal of this whole exercise is to build a framework that allows me to create web apps that are vulnerable in very specific ways, for educational purposes
04:44:01 <infinity0> [exa]: i could write Fix2 fairly easily, the problem is to define two data types at once syntactically
04:44:03 <tdammers> i.e., I want to be able to quickly pump out artificial targets for demonstrating and attacking practical attacks
04:44:47 <phadej> infinity0: an idea is that if you have `data X = XNil | XCons Y` and `data Y = YNil | YCons X`, then `X = Fix (\x -> XNil | XConsYNil | XConsYCons x)` -- and similarly for Y in this case
04:45:07 <phadej> you won't get `Y` inside `X`, but the (part of types) would be isomorphic
04:45:41 <infinity0> ok, i'll try it out, thanks!
04:46:03 <phadej> the theorem is by Bekić 
04:46:44 <phadej> look, someone wondered about that in 2007: https://mail.haskell.org/pipermail/haskell-cafe/2007-March/023585.html :)
04:47:15 <infinity0> cool :)
04:47:53 <maerwald> tdammers: will that be opensource?
04:50:19 <tdammers> maerwald: not sure yet. have to talk to management about that. for now, it's for internal purposes only.
04:50:41 <maerwald> explain open source to management, good luck
04:51:29 <maerwald> I'm thinking about a configuration DSL for describing vulnerable networks
04:51:45 <maerwald> would be surprised if CISCO doesn't have something like that already
04:55:20 <tdammers> maerwald: "management", in my case, consists of three rather accomplished open-source developers, so I'm confident that the odds of this happening are nonzero
04:58:48 <infinity0> hm i'm not sure that trick helps me here, my problem is actually getting the types to type-check rather than representing the data isomorphically
04:59:06 <infinity0> i have some state that references a closure, so is parameterised on the closure type
04:59:19 <infinity0> and then the closure's monad type is also parameterised on the state type
04:59:37 <infinity0> so they are mutually recursive, and trying to actually use this results in lots of "cannot construct infinite type" errors
05:00:09 <infinity0> (and yes i'd like to keep the parameterisation since this is a framework, and general states could refer to general closures)
05:00:28 <infinity0> actually i would've thought someone else would've run into this issue before...
05:05:48 <infinity0> hmm, maybe i can just get the caller to supply a lens that extracts the relevant dependent-part from a wider state type s that is independent
05:14:11 <zincy_> "IO-based monad disables laziness" is wrong right?
05:14:19 <zincy_> It guarantees order of execution
05:14:32 <zincy_> It doesn't affect the order of evaluation.
05:14:52 <hpc> correct
05:16:42 <zincy_> hpc: Thanks
05:16:57 <merijn> Technically Haskell isn't lazy anyway :p
05:18:30 <maerwald> merijn: you mean because it doesn't provide a call-by-value implementation?
05:19:14 <merijn> maerwald: Haskell is in the report non-strict, not lazy. This is relevant, because if it was defined to be lazy any optimisation that involves making things "more strict" would be incorrect
05:19:46 <zincy_> merijn: Is it okay to call it lazy?
05:19:48 <merijn> maerwald: The reason we can unbox and strictify Int operations is because we can do so without affecting the observable semantics
05:19:57 <zincy_> Seems generally accepted terminology.
05:20:06 <merijn> zincy_: I mean, most people do and most people will understand what you mean
05:20:30 <merijn> zincy_: But if we're talking about details of "what do things mean?" it's an important distinction
05:21:05 <merijn> The Haskell report merely requires that "code that would've worked when it was lazy, should work", regardless of how that is implemented
05:21:34 <merijn> A completely stupid, but not incorrect, implementation could just do everything strict and have a timeout to abandon a computation and "leave a thunk for later"
05:23:45 <lortabac> there are also other non-strict evaluation strategies, such as call-by-name (I don't know how used it is in the real world though)
05:25:01 <zincy_> merijn: :)
05:25:03 <zincy_> cheers
05:26:08 <merijn> zincy_: Conversely this means that any compiler can make (parts of) Haskell code strict IFF it's sure this won't affect the actual behaviour (like the aforementioned Int example)
05:33:07 <pgiarrusso> lortabac: usually call-by-name is just an inefficient call-by-need — it’s much easier to study theoretically, and some of the answers even transfer to call-by-need.
05:34:11 <pgiarrusso> giving a clean operational semantics to a call-by-need language is pretty hard, I think that was first done in the ‘50s
05:34:16 <pgiarrusso> argh
05:34:26 <maerwald> Ah, that distinction 
05:34:29 <maerwald> I was confused 
05:34:30 <pgiarrusso> *around ~1995
05:35:09 <pgiarrusso> 2:13 PM <zincy_> "IO-based monad disables laziness" is wrong right?
05:35:37 <pgiarrusso> 2:13 PM <zincy_> It guarantees order of execution
05:35:43 <pgiarrusso> 2:14 PM <zincy_> It doesn't affect the order of evaluation.
05:35:55 <pgiarrusso> I _suspect_ I understand what that means, but I was actually wondering here.
05:36:08 <pgiarrusso> because of a problem with actual code
05:37:03 <pgiarrusso> somebody called `getDirectoryContents` on `/nix/store`, and that took 1 GB; I have some ideas why, but I’m wondering on fixes.
05:37:05 <maerwald> merijn: why does the report specify non strict semantics at all? 
05:37:55 <lortabac> maerwald: one of the reasons why Haskell has been invented was to experiment with laziness
05:38:03 <pgiarrusso> if you loop inside IO over the result of sth. like `getDirectoryEntry`, is there any chance to get list fusion and O(1) space consumption?
05:38:17 <solonarv> pgiarrusso: list fusion? very little chance
05:38:26 <solonarv> but you still have a pretty good chance of working in constant space
05:38:27 <maerwald> lortabac: no, what I mean is. If your language is pure, you can have lazy strict and non strict semantics 
05:38:29 <maerwald> Doesn't matter 
05:38:47 <pgiarrusso> maerwald: Haskell is not pure enough for that — it has infinite loops
05:38:57 <merijn> maerwald: Section 3.1 at least explicitly mentions "Haskell is non-strict", I'm not sure if there's a better reference to evaluation semantics, though
05:38:58 <maerwald> That's fine
05:38:58 <pgiarrusso> and infinite loops break that guarantee
05:39:02 <maerwald> How so
05:39:18 <merijn> maerwald: "Errors during expression evaluation, denoted by ⊥ (“bottom”), are indistinguishable by a Haskell program from non-termination. Since Haskell is a non-strict language, all Haskell types include ⊥. "
05:39:20 <pgiarrusso> maerwald: `(const 1) undefined`
05:39:35 <pgiarrusso> that’s `1` in Haskell, but `undefined` under strict semantics
05:39:36 <solonarv> ghc's garbage collector is tuned for this sort of thing: lots of short-lived objects
05:40:01 <pgiarrusso> solonarv: the actual code I’ve seen also uses difference lists, and that interferes
05:40:05 <maerwald> Purity only means call by name, call by value and call by need are weakly equivalent (modulo undefined) 
05:40:11 <solonarv> ah, then you might not get constant space
05:40:29 <pgiarrusso> but is it enough to avoid difference lists?
05:40:37 <maerwald> So I don't understand how infinite loops break the definition 
05:40:51 <pgiarrusso> maerwald: well, we want strong equivalence :-)
05:41:04 <maerwald> That's not how purity is defined though 
05:41:16 <maerwald> But then yes
05:41:27 <pgiarrusso> well, people disagree on purity.
05:41:33 <merijn> Do they?
05:41:41 <maerwald> I only know one scientific definition 
05:41:42 <pgiarrusso> yes.
05:41:47 <maerwald> If you have another one please share
05:42:07 <merijn> I know only some minor not very meaningful squables over exact denotation
05:42:18 <pgiarrusso> I don’t think there is an actual scientific definition, unless you can find a citation
05:42:26 <maerwald> Yes, wait a second 
05:42:26 <pgiarrusso> but we can ignore that
05:42:43 <pgiarrusso> the significant squabble is that you _can_ consider divergence a side effect
05:43:12 <pgiarrusso> there’s a “Total Functional Programming” paper by Turner arguing for that in practice
05:43:17 <maerwald> pgiarrusso: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
05:43:20 <pgiarrusso> and Agda programmers certainly treat divergence as a side effect
05:43:34 <maerwald> it's not about totality
05:43:53 <maerwald> that would indeed be a different definition
05:44:17 <maerwald> and then I wonder if we have any language that qualifies as pure
05:44:31 <pgiarrusso> Agda
05:44:43 <pgiarrusso> 2:38 PM <maerwald> lortabac: no, what I mean is. If your language is pure, you can have lazy strict and non strict semantics
05:44:53 <pgiarrusso> maerwald: that paper you cite explicitly rejects that definition.
05:45:00 <maerwald> pgiarrusso: how so
05:45:14 <maerwald> It demands you have all 3 implementations even
05:45:35 <pgiarrusso> “independence of order of evaluation” is one that is not sufficient
05:45:36 <pgiarrusso> ah
05:46:29 <pgiarrusso> in any case, yes, describing divergence as a side effect is a different definition from the one used by Haskellers. It does appear in the literature.
05:47:14 <pgiarrusso> but it’s true that, if your quote refers to the definition Sabry proposes, then your quote is valid according to Sabry
05:47:27 <maerwald> pgiarrusso: A language is purely functional if 1. it is a conservative extension of the simply typed lambda-calculus, 2. it has well-defined call-by-value, call-by-need and call-by-name ealuation functions (implementations) and 3. all three evaluation functions (implementations) are weakly equivalent (see chapter about weak equivalence)
05:48:07 <maerwald> Right, so I wonder if there is a competing definition
05:48:26 <maerwald> "Total functional programming"... are you sure that defines *purely functional programming*?
05:49:37 <pgiarrusso> there are two distinct concepts, and people disagree on what “pure” should mean.
05:50:07 <pgiarrusso> in a language like Agda, partiality is expressed with a monad like all other side effects
05:51:18 <pgiarrusso> moreover, treating partiality like an effects allows you to get _more_ referential transparency.
05:51:23 * hackage coercible-subtypes 0.1.0.0 - Coercible but only in one direction  https://hackage.haskell.org/package/coercible-subtypes-0.1.0.0 (viercc)
05:51:35 <pgiarrusso> in practice we very much care if a program diverges or not.
05:52:02 <pgiarrusso> we ignore that difference sometimes only because it’s hard to reason about, not because we don’t care :-)
05:52:07 <maerwald> pgiarrusso: yeah, so from what SPJ said about purity, afair, it was more like it's a nice property for compiler engineers, not so much for language users
05:52:27 <pgiarrusso> users will also disagree
05:52:36 <pgiarrusso> in any case, I don’t want to get into more debates.
05:53:03 <pgiarrusso> so it’s certainly true that Sabry gives _one_ valid definition of purity.
05:53:09 <maerwald> http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
05:53:13 <maerwald> I'll check that out
05:53:19 <pgiarrusso> it’s just not true that the entire PL literature agrees with it :-)
05:53:36 <pgiarrusso> or at least, that “Haskell-style” purity is all that you should demand from your language.
05:53:48 <pgiarrusso> none of this affects why Haskell is non-strict.
05:53:56 <pgiarrusso> They don’t want _just_ purity.
05:54:28 <pgiarrusso> they also want to guarantee that programs like `const 1 undefined` (or more sensible examples) do terminate.
05:56:34 <phadej> if you want your language to be non-strict, you need for it to be pure.
05:56:41 <phadej> the implication is in that direction.
05:56:53 <phadej> non-lazy ML-like language would be just impossible to use
05:56:58 <phadej> non-strict* sorry
05:57:04 <maerwald> yeah
05:58:54 <lyxia> I disagree, call-by-value is shit for pure functional programming, you always have to eta-expand everything.
05:59:53 <phadej> again, there can be strict pure functional language (e.g. Idris), but if you want your language to be non-strict it **has** to be pure.
06:00:10 <phadej> it can be pure and strict, that's a valid (though, IMO boring) option
06:00:28 <phadej> Haskell is non-strict, and therefore pure language.
06:01:16 <merijn> It doesn't have to be pure to be non-strict
06:01:24 <merijn> You just gotta be willing to give up your sanity
06:01:35 <merijn> And ability to get anything useful done :p
06:01:37 <phadej> quibbling
06:01:48 <merijn> It'd make a good esolang :)
06:03:32 <lyxia> I disagree with whatever definition of "pure" lets you have (f . g) not equivalent to (\x -> f (g x)).
06:04:34 <phadej> you are mixing up bottoms in here, don't you.
06:04:47 <lyxia> "mixing up"?
06:04:52 <phadej> adding to the mix.
06:06:03 <phadej> haskell is unfortunately non-total, and I doubt ever be. In Agda those are equivalent.
06:06:56 <lyxia> yes nontermination is relevant to my complaint
06:07:33 <lyxia> if you have totality the evaluation strategy is less of a problem, but it still is one in practice.
06:08:26 <asheshambasta> so, I'm not sure this is the right place to ask this but I'm trying to build brittany on nixos, but I'd like to build it using ghc865 instead of the pinned ghc822. Building it using nixpkgs on 19.09 works but the tests fail due to some dependency. So I'd like to be able to use nixpkgs from 18.09 and make ghc865 available in the package set. But I cannot seem to figure this out. This is what I have so far:
06:08:26 <asheshambasta> https://gist.github.com/asheshambasta/3fa7a2a1b5f69eb378f88d6b58530cc4 but as on the gist this errors out. 
06:08:42 <phadej> without `seq` you couldn't distinguish the above though.
06:09:05 <asheshambasta> I'm obviously doing something wrong here, but I'd like to know how to make a particular compiler available in the nixpkgs.
06:09:11 <phadej> So I'm not sure what is lyxia's complaint
06:12:03 <lyxia> even without seq, call-by-value can be way slower than lazy evaluation.
06:18:11 <phadej> this is why Haskell is non-strict, as pointed out. Up to compiler to decide when it should call-by-value or -by-reference
06:18:20 <phadej> no global setting
06:20:36 <kolu> hello guys
06:20:40 <lyxia> well yeah, and I was taking issue with your claim that there can be strict pure functional languages.
06:21:17 <lyxia> if you have to let your compiler choose, then the language must be either non-strict or total.
06:21:25 <phadej> tjere are. PureScript, Idris, ...
06:21:30 <phadej> I'm not saying it's sane choice
06:21:39 <lyxia> I don't count PureScript as pure for those reasons
06:21:55 <phadej> it has pure in its name... :)
06:22:07 <phadej> but whatever
06:24:58 <kolu> would somebody care to look at a small script I wrote and give some comments
06:26:43 <[exa]> kolu: if it's not a long read I guess people can look at a pastebin or so
06:32:38 <kolu> [exa]
06:32:40 <kolu> https://pastebin.com/ZM6BpWfU
06:33:22 <kolu> I'm not sure how to approach impure stuff like reading/writing on file and using randomness
06:33:52 <kolu> these do blocks look very imperative
06:34:31 <solonarv> they are imperative, but that's what do notation is for
06:35:54 <stevenxl> Hi folks. I am reading an article on property testing in Haskell which uses reflexivity as an example property. I don't know what a reflexive relation is. I tried reading https://en.wikipedia.org/wiki/Reflexive_relation but I'm not sure if I am fully grokking. Can someone "explain like I am 5"?
06:36:21 <stevenxl> Wikipedia says: "In mathematics, a binary relation R over a set X is reflexive if it relates every element of X to itself". But I don't know what it means to "relate" an element to itself.
06:36:45 <solonarv> that's because the meaning of "relate" depends on what relation we are talking about
06:37:13 <solonarv> for example, == is a relation that relates two elements x, y if they're equal
06:37:30 <solonarv> <= relates two elements x, y if x is less than y or if they're equal
06:37:41 <solonarv> (these two are examples of reflexive relations)
06:37:51 <stevenxl> why is < not reflxive?
06:38:13 <solonarv> because x < x is not always true
06:38:17 <solonarv> (in fact, it's always false)
06:39:09 <stevenxl> I see. So, to a very basic approximation, is a reflexive binary operator a function which will always return true if the two arguments are the same value? 
06:39:18 <solonarv> if we use @@ to stand for some arbitrary relation, then @@ is reflexive if 'x @@ x' is true for all x
06:39:37 <stevenxl> @solonarv thank you! That's the definition I was looking for!
06:39:37 <lambdabot> Unknown command, try @list
06:39:45 <solonarv> yes, one (quite useful!) way to think about relations is as two-argument functions that return true or false
06:39:54 <stevenxl> :-)
06:43:40 <kolu> solonarv so whenever I deal with impure stuff, this is the way to go
06:44:21 <solonarv> well, you don't *have* to use do notation, but it's okay if you do and it's okay if it comes out looking like that
06:44:58 <solonarv> alright, so it's not entirely clear to me what this code is supposed to do
06:45:31 <solonarv> it looks like it's reading a character set from a file, then generating random words from that alphabet and writing them to another file
06:45:34 <solonarv> is that right?
06:46:08 <kolu> it grabs a book - clears everything except for the alphabet characters and then generates random words from the content
06:47:18 <kolu> and writes them on another text file
06:48:18 <solonarv> did you actually run this script? does it work correctly?
06:48:39 <kolu> yes
06:49:15 <kolu> I was just not sure
06:49:19 <solonarv> hm, I'm guessing the input file is very large then
06:49:35 <solonarv> because your "summonWord" can cause an out-of-bounds error
06:49:59 <solonarv> the bounds on randomR / randomRIO are *inclusive* on both ends of the range
06:50:17 <solonarv> (and indexes start at 0, not 1)
06:50:18 * stevenxl OK - next question. So the author of the tutorial I am reading says that the Eq instance for Ratio assumes that values are normalised. What does normalised mean here? For example, we get that 2 :% 2 == 1 :% 1 is actually false. Is a normalised value in this context saying that the ratios have the same denominator? 
06:50:48 <kolu> ah, yes
06:50:57 <kolu> I need to add a -1 to length dictionary
06:50:58 <solonarv> stevenxl: I think "normalized" here means that we're not allowed to pass 2 :% 2, because that can be reduced to 1 :% 1
06:51:05 <merijn> stevenxl: Normalised fractions have the "smallest" possible divisor
06:51:10 <stevenxl> oooo 
06:51:14 <solonarv> kolu: and start the range at 0 instead of 1, probably
06:51:14 <stevenxl> damn, I wish I knew math.
06:51:22 <stevenxl> Thank you solonarv & merijn 
06:51:24 <solonarv> otherwise you can never choose the first letter (and surely that isn't intended)
06:51:41 <kolu> it doesn't matter, since there are thousands of letters
06:51:58 <kolu> but if I accidentally hit the last one it would probably stop the program
06:52:15 <solonarv> stevenxl: note, it's fine for the Eq instance to assume this because you are not supposed to use the :%  constructor directly, so you can't construct a non-normalized Ratio
06:52:20 <solonarv> kolu: yes, it would crash
06:52:42 <kolu> thank you very much for your feedback
06:52:46 <stevenxl> Thanks solonarv  - noted.
06:52:52 * hackage cpkg 0.2.5.1 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.5.1 (vmchale)
06:52:55 <solonarv> (by which I mean an error message would be printed and the program would stop. possibly there would be some garbage at the end of file.txt as well.)
06:53:20 <solonarv> kolu: frankly, summonWord is a bit of a mess
06:54:01 <solonarv> it generates a random word (in a somewhat overcomplicated way) *and* writes it to a file *and* writes the separator (the space) as well!
06:54:31 <kolu> so split the chores?
06:55:14 <solonarv> yup
06:55:29 <kolu> can I write short do blocks just as I write short pure functions?
06:55:45 <kolu> I mean, would that be a better solution to such programs
06:56:02 <solonarv> I would split them up like this: 1) pick a character at random; 2) repeat step 1 multiples times and glue the results together; 3) write that string to the output file
06:56:10 <solonarv> yes, you can write short do blocks as well
06:56:34 <kolu> but can I return the result?
06:56:45 <solonarv> of course!
06:56:53 <kolu> -> IO ()
06:56:59 <solonarv> the '()' in 'IO ()' is actually the type of the value being returned
06:57:02 <kolu> inside the brackets?
06:57:14 <kolu> aaah, that's interesting
06:57:21 <kolu> that opens up a lot of possibilities
06:57:21 <merijn> > ()
06:57:24 <lambdabot>  ()
06:57:24 <merijn> :t ()
06:57:26 <lambdabot> ()
06:57:32 <merijn> kolu: "data () = ()"
06:57:33 <solonarv> () is a built-in type that has only one value (so it's a "dummy" value that you return when there is no interesting information to return)
06:57:47 <solonarv> you can replace it with 'String' or 'Int' or 'Char' or whatever.
06:57:55 <kolu> so return 5 would be IO (Int)
06:58:03 <solonarv> the brackets aren't needed
06:58:08 <merijn> kolu: parentheses are optional there
06:58:11 <merijn> kolu: But yes
06:58:13 <solonarv> but yes, that's correct
06:58:32 <merijn> "foo :: IO Int; foo = return 5" <- perfectly fine
06:58:46 <kolu> great, thank you
06:58:54 <kolu> much appreciated
06:59:30 <merijn> kolu: "IO a" is "just a value", you can do anything with it that you can do with other values. Store it in data structures, bind names to them, etc.
06:59:49 <kolu> so I could probably also say
06:59:52 <kolu> IO Maybe Int
06:59:52 <merijn> :t map print [1..5]
06:59:54 <lambdabot> [IO ()]
07:00:10 <merijn> kolu: For fun, try doing "map print [1..5] !! 3" in ghci :)
07:00:27 <merijn> kolu: "IO (Maybe Int)", but yes, you can do that
07:00:54 <kolu> 4
07:01:20 <merijn> kolu: The important part is: Note how none of the others were printed :)
07:01:36 <kolu> yes, only the element at the specified index
07:01:43 <kolu> interesting
07:02:13 <kolu> thank you thank you
07:02:18 <merijn> "IO Foo" represent "some computation (sometimes called action) that produces a 'Foo'". However, you can never observe that action being executed within Haskell. You can merely "build bigger actions out of smaller ones"
07:02:19 <kolu> that leaves me with a lot to do
07:03:14 <merijn> So as long as they are in data structures or whatever, nothing happens. Only once you explicitly tie them into your code (via >>, >>= or do notation) will they (potentially) get executed
07:04:20 <solonarv> kolu: here is my version with some of the changes I would make: https://gist.github.com/Solonarv/a01308e3a82de2692cd0a450bff02628
07:09:07 <kolo> solonarv
07:09:13 <kolo> for some reason isAlpha doesn't work
07:09:19 <kolo> properly
07:11:43 <zincy_> phadej: Is that because impure functions would give you different results depending on the order of evaluation? 
07:11:54 <phadej> yes
07:11:56 <zincy_> well not would necessarily but could
07:12:04 <zincy_> Ah ok
07:13:10 <kolo> what does forever do?
07:13:22 <kolo> loop forever?
07:13:53 <pavonia> Yes
07:13:58 <pavonia> @src forever
07:13:58 <lambdabot> forever a = let a' = a >> a' in a'
07:14:43 <solonarv> kolo: isAlpha doesn't work how?
07:14:48 <solonarv> what is it doing wrong?
07:15:16 <kolo> it leaves stuff that is non-character
07:15:30 <kolo> \\56700 
07:15:44 <kolo> I'd think it has something to do with encoding
07:15:51 <solonarv> > generalCategory '\56700'
07:15:53 <lambdabot>  Surrogate
07:16:02 <solonarv> hm, looks like encoding issues indeed
07:16:35 <pavonia> > isAlpha '\56700'
07:16:38 <lambdabot>  False
07:17:20 <solonarv> I guess if you are fine throwing away all non-ascii you can replace 'isAlpha' with 'isAsciiLower'
07:17:38 <solonarv> (note that your previous code was throwing away non-ascii already)
07:18:03 <kolo> I guess isAsciiLower would be faster than my version
07:18:33 <kolo> or does it just look better
07:19:16 <solonarv> both
07:21:08 <kolo> ok, got it
07:22:28 <kolo> would haskell be an appropriate choice for more complicated text processing software 
07:22:48 <maerwald> text processing?
07:22:52 <maerwald> Yes
07:23:06 <[exa]> the answer is yes and now tell us what kind of text processing you meant :D
07:23:18 <maerwald> Probably one of the more popular choices, actually
07:23:41 <maerwald> parsers, elegant streaming, EDSLs
07:23:53 <[exa]> pandoc
07:24:01 <maerwald> I said elegant
07:24:03 <maerwald> xD
07:24:05 <maerwald> jk
07:24:05 <[exa]> :]
07:24:06 <solonarv> haha
07:24:21 <solonarv> there are like half a dozen templating engines too
07:24:33 <kolo> uhm
07:24:39 <kolo> I was thinking
07:24:51 * hackage monad-bayes 0.1.1.0 - A library for probabilistic programming.  https://hackage.haskell.org/package/monad-bayes-0.1.1.0 (curiousleo)
07:24:52 <kolo> something that can create actual meaningful text
07:25:19 <maerwald> What is meaning though if not an illusion? *staring intensifies*
07:26:10 <maerwald> This sounds like machine learning almost :P
07:26:10 <kolo> U feed it 100 books
07:26:17 <maerwald> Ah, I guessed right
07:26:21 <kolo> and it generates its own book
07:26:34 <maerwald> Ok, then your choice of language is probably going to be python
07:26:42 <solonarv> if you just want to generate random (but plausible-looking) text based on some source material (e.g. a book), then it's probably very difficult for anything hand-written to beat the "throw it at GPT-2" approach
07:27:07 <kolo> no, python is ugly
07:27:13 <maerwald> Yes, but the ecosystem...
07:27:30 <solonarv> while GPT-2 is not written in python, python is unfortunately the best-supported language for interfacing with it
07:27:37 <maerwald> Yeah
07:27:40 <kolo> what is GPT-2
07:27:43 <solonarv> (the same is true for most of the machine learning ecosystem)
07:28:01 <kolo> I thought perhaps Prolog would be more appropriate 
07:28:02 <solonarv> I forget what the acronym stands for, but it's a big pre-trained neural network that generates text
07:28:10 <kolo> Prolog looks really beautiful
07:28:28 <maerwald> Are you looking to get something done or just want to mess around with a cool language?
07:28:35 <solonarv> you can try it out here -> https://talktotransformer.com/
07:28:47 <maerwald> Prolog is certainly cool
07:28:49 <kolo> I'm not interested in the actual output, just the process to generate it
07:29:19 <maerwald> My advice would be: make a minimal prototype in python. Just do it. Then look at doing it nicer with Prolog/Haskell whatever
07:29:32 <solonarv> unfortunately, neural networks are rather opaque; you can't really "look inside" to see what it's doing
07:29:47 <solonarv> you have a black box; you throw some inputs at it; you let it churn and it spits out some output
07:30:38 <reactormonk> How can I use the singleton package (probably more specifically the TH module) to create me the two bindings `SFoo` and `SBar` from `data Test = Foo | Bar`?
07:32:17 <solonarv> reactormonk: I think you just have to move that definition into a singletons [| CODE HERE |] block
07:32:35 <solonarv> so in your case: singletons [| data Test = Foo | Bar |]
07:33:01 <reactormonk> solonarv, I've already got `genSingletons [''Test]` with the definition up front, apparently that's not enough?
07:33:22 <solonarv> I don't know, haven't actually used singletons myself
07:33:35 <reactormonk> Aye, let's try that
07:34:52 * hackage contracheck-applicative 0.1.0.0 - Validation types/typeclass based on the contravariance.  https://hackage.haskell.org/package/contracheck-applicative-0.1.0.0 (Birkmann)
07:35:42 <reactormonk> gives me a parse error .--
07:39:32 <lortabac> reactormonk: $(singletons [d| data Test = Foo | Bar |])
07:40:15 <lortabac> you need to enable TemplateHaskell of course
07:40:46 <reactormonk> gotcha, forgot about the d
07:45:19 <zincy_> Is there a function which makes an IO action repeat until the result equals some value?
07:46:23 <solonarv> that sounds like something that would be in monad-loops
07:47:25 <stevenxl> Was there ever a GHC.Real module in the base package at some point? I can't seem to find that or the `:%` data constructor that this post mentions. https://www.fpcomplete.com/blog/quickcheck-hedgehog-validity
07:48:55 <zincy_> Thanks
07:48:58 <zincy_> On another note
07:49:05 <zincy_> when is unsafePerformIO every permissible?
07:49:23 <zincy_> Because in my book it is a bad idea for using it to read env vars from the environment
07:50:40 <solonarv> reading env vars is not totally horrible, I think: at least they should not change for the duration of your program
07:50:52 <stevenxl> zincy_: I have never used unsafe*. Reading from an environment should occur in the main function. A value of type environment should be constructed in the main function, and then the rest of the program should be ran  a reader monad that has access to that environment.
07:50:53 <solonarv> so it does not matter when or how often the unsafePerformIO get evaluated
07:51:04 <solonarv> but for env vars it's also just not necessary
07:51:28 <zincy_> Yeah people are pushing for using it to read env vars
07:51:37 <zincy_> I am trying to find a reason why it would be a good idea
07:51:39 <solonarv> if you want a function to be configurable in some way then it should have an actual function argument that exposes the configuration switch
07:53:04 <solonarv> libraries like 'bytestring' and 'vector' use it internally
07:53:17 <solonarv> (unsafePerformIO, that is)
07:54:22 <solonarv> sometimes you want or need a top-level IORef or TVar or similar, which can be done with unsafePerformIO (newIORef blah) and a {-# NOINLINE #-} pragma
07:54:22 * hackage contracheck-applicative 0.1.0.1 - Validation types/typeclass based on the contravariance.  https://hackage.haskell.org/package/contracheck-applicative-0.1.0.1 (Birkmann)
07:57:05 <zincy_> solonarv: Right
07:57:22 <zincy_> It is pointless for `getEnvironment` though isn it
07:57:59 <solonarv> yeah, I'd just do that in 'main'
08:09:52 * hackage microbase 4.14.0.0.4 - A minimal base to work around GHC bugs.  https://hackage.haskell.org/package/microbase-4.14.0.0.4 (dailectic)
08:14:52 * hackage neuron 0.2.0.0 - Haskell meets Zettelkasten, for your plain-text delight.  https://hackage.haskell.org/package/neuron-0.2.0.0 (sridca)
08:35:13 <Athas> Does anyone have an example of building a statically linked Haskell binary with Nix?
08:36:08 <Athas> In principle it should just be a matter of the normal cabal2nix approach, but linking against musl and passing some more flags to GHC, but I can't for the life of me find a simple example.
08:37:36 <sm[m]> Athas: see nomeata's recent post on planet haskell
08:38:30 <sm[m]> uh.. well planet haskell is still broken. In planet haskell feed only
08:39:11 <sm[m]> https://www.joachim-breitner.de/blog/770-A_Telegram_bot_in_Haskell_on_Amazon_Lambda
08:39:58 <Athas> sm[m]: thanks!  It still looks oddly complicated, but simpler than other things I've seen.
08:40:34 <sm> I thought that was the definition of nix :)
08:44:16 <Athas> Hrm, it looks like nomeata's example doesn't use cabal2nix.  That means I'd have to duplicate a bunch of information.
08:47:33 <maerwald> Athas: I tried. It didn't work. Then I used alpine with docker. And it worked. 
08:47:46 <maerwald> So my advice is don't bother 
08:49:07 <maerwald> https://github.com/nh2/static-haskell-nix/issues/85
08:53:57 <srk> Athas: https://github.com/vpsfreecz/vpsadminos/blob/master/os/packages/machine-check/default.nix
08:55:57 <Athas> srk: that looks deceptively simple!  What's the catch?
08:56:24 <srk> Athas: no catch I'm aware of :)
08:56:54 <Athas> Hm, it also looks like it repeats the version number.  Is there no way to use cabal2nix to just grab whatever is in my .cabal file?
08:57:07 <Athas> There is 100% certainty that it will go out of sync otherwise.
08:57:08 <srk> callCabal2nix
08:57:36 <srk> use that instead of callPackage and manually calling cabal2nix
08:57:55 <Athas> Does this link statically?
08:58:09 <Athas> I don't see any mention of musl.
08:58:33 <srk> enableShared* = false results in staticly build lib/exe
08:59:02 <srk> *built
09:05:42 <Athas> srk: thanks!  Something seems to be happening now.
09:05:53 <Athas> I like Nix a lot, but some of the abstractions are really hard for me to grok...
09:06:17 <srk> takes a bit of time to get used to it but there's no way back
09:06:40 <srk> it makes other package managers look like toys 
09:06:52 <Athas> This is what I am trying: https://gist.github.com/athas/244279225eabb380a0d674bae5a5ee9f
09:06:58 <Athas> It's building.  Will be interesting to see what comes out the other end.
09:07:36 <srk> oO, futhark, cool :)
09:08:32 <Athas> Yeah, I'd like the binary tarball with nightly builds (or releases for that matter) to be statically linked.
09:20:17 <zincy_> Does wai-logger allow you to log responses?
09:30:25 <iphy> I'm getting this error while compiling the base library (building ghc):  https://www.irccloud.com/pastebin/FBK6RErG/
09:30:52 <iphy> this is when trying to compile GHC/Float.hs into GHC/Float.o
09:31:05 <iphy> I don't know why it calls the linker here, but it seems to be calling it wrong
09:48:52 * hackage pandora 0.2.6 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.6 (iokasimovmt)
09:52:39 <zincy_> In fact
09:52:52 <zincy_> what is the standard way of logging request and responses when using Servant?
09:55:02 <[exa]> is there a standard way of logging in general?
09:55:48 <Rembane> zincy_: I think I added MonadLogger to the transformer stack when I did Servant.
09:57:33 <edmundnoble> I usually log to stderr or stdout
09:57:47 <edmundnoble> If I care more about logs, I'll set up a systemd unit usually
09:58:11 <zincy_> Using wai-logger or some other logger will allow you to log responses too right?
10:06:57 <shapr> @quote
10:06:57 <lambdabot> yac says: all i want to do is pass haskell and never touch it again
10:07:01 <shapr> poor yac
10:07:06 <shapr> missing out on so much awesome
10:07:36 <hexagoxel> asheshambasta: have you resolved your brittany/nix issue?
10:09:02 <maerwald> MonadLogger +1
10:09:24 <maerwald> especially because for APIs, you can have extensive logging and the user can disable it all if they please so
10:09:51 <monochrom> There really are people unable to learn Haskell.
10:11:11 <zincy_> monochrom: Doesn't stop them being employed as Haskell devs
10:11:16 <maerwald> :D
10:12:01 <Ariakenom> Athas, how long does a build take? would be interesting to know if it worked
10:13:45 <Athas> Ariakenom: it worked, but produced a dynamic executable.
10:13:57 <Athas> Now I'm adding some more configureFlags...
10:14:27 <Athas> What -flambda do when passed to GHC?  nomeata is using it in his Nix derivation, but the GHC manpage doesn't mention it.
10:14:46 <Ariakenom> ... D:
10:15:43 <phadej> Athas: nothing, there is no such option
10:15:56 <phadej> Athas: ask nomeata if he meant -fdo-lambda-eta-expansion
10:16:06 <monochrom> I get "unrecognised flag: -flambda" for 8.6, 8.8, 8.10
10:17:03 <Athas> Oh, it must be a cabal flag.
10:17:18 <phadej> there's no such cabal flag either
10:17:20 <Athas> Ah, it must set some cabal flag for his package.
10:17:51 <phadej> that, might be.
10:18:21 <Athas> Right now I'm building at least one version of LLVM (maybe two), Firefox, MLKit (with MLton), and my Haskell program, so it takes some time to see results!
10:18:25 <Athas> I need bigger CPU.
10:19:07 <maerwald> have you heard of cloud before?
10:20:01 <Athas> You'll lend me your computer?
10:20:25 <maerwald> Yes, if you pay my rent
10:20:47 <monochrom> oooo MLton will take a while.  (whole-program analysis!)
10:21:36 <Athas> monochrom: it's worse in space than time.  20GiB resident.
10:21:43 <maerwald> Yep, I was gonna say it, haha
10:21:46 <{abby}> -flambda sounds like someone mixed up GHC and ocamlopt
10:21:55 <maerwald> especially since haskell space consumption isn't linear
10:22:36 <maerwald> I always set cabal jobs to 1 everywhere, no matter how many cores.
10:22:57 <maerwald> If you are unlucky and get the wrong two packages to be compiled in parallel, it's over
10:25:05 <Uniaika> the Haskell Docs project has striken again!! this time to improve the documentation the Control.Monad.IO.Class module. :) Hope you'll enjoy the result: https://twitter.com/TechnoEmpress/status/1247919843518668801
10:26:44 <monochrom> Except it should be s/striken/struck/
10:27:02 <sm[m]> thanks Uniaika 
10:27:26 <Uniaika> monochrom: probably, I'm not a native speaker :P
10:27:37 <srk> Athas: dynamic? what does ldd says?
10:27:58 <Athas> srk: lots of dynamic libraries.
10:28:26 <maerwald> Uniaika: Nice, but I would keep the style as technical as possible (E.g. not saying "Luckily we know of a function...")
10:28:37 <maerwald> feels a bit lyah style
10:29:51 <Uniaika> maerwald: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/2942
10:30:11 <Uniaika> please add a comment. :)
10:30:45 <Uniaika> You can even join #haskell-docs if you wish to take part in the other documentation-related discussions :)
10:30:46 <Athas> maerwald: I would normally feel the same way, but the conversational style is under a (hidable) "Example" section.
10:31:12 <Athas> I think it's a good balance to have the terse technical remarks up front, and then more verbose example/tutorial sections available when desired.
10:31:22 * hackage prim 0.1.0.2 - An ergonomic but conservative interface to ghc-prim  https://hackage.haskell.org/package/prim-0.1.0.2 (dailectic)
10:31:31 <monochrom> Don't listen to me but I don't understand the following two happening together: obsession with saying "real world", and at the same time using toy examples.
10:33:12 <monochrom> For example:
10:33:23 <monochrom> @quote monochrom fib.*python
10:33:23 <lambdabot> monochrom says: the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
10:34:19 <Uniaika> monochrom: I can understand why it's confusing, and in that particular case the example was less to show theoretial properties but something concrete
10:34:22 <Athas> The fibonacci sequence is the real-world industrial-strength version of the factorial function.
10:34:42 <srk> Athas: building it as well, flags look good to me
10:35:08 <monochrom> I.e., I don't understand why the python people can, logically, laugh at haskell tutorials for using fibonacci "real world doesn't care", and then their very own official python tutorial goes on to open with fibonacci again.
10:36:07 <maerwald> Uniaika: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Encoding.html#v:decodeUtf8
10:36:19 <maerwald> I remember the discussion about better annotation for partiality
10:36:33 <maerwald> that function just blew up my code, because I didn't read the second sentence fully
10:37:21 <monochrom> If you ask where I really stand, screw real-world examples (I'll explain next), admit your example isn't real world, it's toy, but it's clarifying, and precisely because it's clarifying it needs to be small and minimal distracting side issues, so it must be toy.
10:38:15 <hyperisco> It is different. Haskell is Fibonacci all the way down, whereas Python stops with the math stuff when the tutorial ends.
10:38:45 <maerwald> I can hear the Num instances crying
10:39:35 <monochrom> Real-world examples, if honest-to-God real-world, means for example you have to show actual WAI-using code from an actual in-deployment app you actually make money out of, just to show "see? I need liftIO at line 5784".  Surely that defeats the point of showing an example.  In general, real-world code is the worst examples.
10:39:36 <hyperisco> University: you need to know the collision probability of a hash table n% full. Reality: array.push
10:41:58 <srk> Athas: $ ldd ./result/bin/futhark not a dynamic executable
10:42:01 <Uniaika> maerwald: that is definitely a discussion I'd love to have on the docs channel
10:43:53 <Athas> srk: your Nix must be better than mine.
10:44:00 <srk> Athas: quite similar to your default.nix https://gist.github.com/sorki/b42218329152312c7859204a9c94166c
10:44:14 <srk> Athas: only difference is nixpkgs version then
10:44:26 <Athas> Huh.  That's odd.
10:44:26 <srk> Athas: I'm at 77a062fe47940f1d1cdfb136934bb42d20094c51
10:44:56 <Athas> I'm not sure what I'm at.  Whatever is nixos-unstable right now.
10:46:49 <hyperisco> monochrom, I have come to realise the exceptional thing to accomplish is being mildly rigorous while still getting work done
10:46:50 <srk> Athas: I'm pretty sure this is working for a long time now - I didn't grab futhark repo but used the one in nixpkgs (0.15.2), enableLibraryProfiling = false is just to save time building
10:48:15 <hyperisco> like, the difference between I'm going to define the next progression in technology and I'm going to squeak out a passable product
10:48:23 <Athas> Alright, I'll try it again starting from your default.nix, and then adding my cabal2nix afterwards.
10:48:36 <monochrom> Sure, I think we all do that already.
10:48:37 <Athas> You are also using GHC 8.8.3 where I was using 8.8.2, but I can't imagine that has an impact.
10:49:12 <srk> yep, I just switched to one I have most deps for already
10:49:30 <Athas> It always strikes me as ironic and backwards that *static* linking is the difficult case.  It is both conceptually and technically simpler, and was around first as well.
10:49:40 <srk> :))
10:50:46 <monochrom> My quarrel is with keeping saying (really lying) "real world" like tyrannies keep lying "for the people".
10:51:32 <hyperisco> I'm saying I think people are saying "real world" in place of "what I can hope to achieve"
10:53:38 <monochrom> and corporates keep lying "your satisfaction is our top priority"
10:54:18 <monochrom> (just so you know that I know that both communists and capitalists are pigs)
10:55:57 <Athas> srk: wait, that is because the nixpkgs futhark actually builds a shell script.
10:56:13 <Athas> Do run 'file' on that 'futhark' you got.
10:56:30 <Athas> I don't really get why it's done like that, but that's another discussion.
10:56:37 <dsal> Which Real World?  IO?
10:56:45 <monochrom> haha
10:57:15 <maerwald> naming thing in CS...
10:57:28 <srk> Athas: oooh, indeed, my bad for missing that wrapper
10:57:42 <dsal> My current real world problem has a cache invalidation problem, but the names are mostly OK.
10:58:11 <maerwald> mine are not, because I got utf8 decode error
10:59:26 <dsal> I'm doing stuff with Other People's JSON which isn't quite as fun as I'd like.
10:59:56 <maerwald> you got a json schema?
11:00:21 <dsal> I don't even have a public API.  I'm reverse engineering things.   But I guess I could come up with one.  If I did, would it help me?  :)
11:01:08 <maerwald> This reminds me of an API I had to build integration with, which was in XML. I asked for an XML schema and guess what I got: a docx document with a table.
11:03:13 <monochrom> What's in that table? Did it help you?
11:03:58 <maerwald> The table had *some* of the xml nodes with semi-usable descriptions of what they may contain. When real-world data came in, all of those assumptions were wrong.
11:04:09 <monochrom> Ah
11:04:22 <monochrom> Why do programmers keep lying.
11:04:46 <dsal> A lot of it is just that it's fairly inconvenient to parse.  I need to go back and look at what I did and maybe find some commonalities.  Much of the stuff is in the form of   {"_embedded": {"things": [{Thing}]}}  I have a parser for Thing and I want [Thing] -- that's easy to get wrong in Aeson in such a way that fails at runtime.
11:04:55 <maerwald> I was more fascinated by the idea that this was direct output of their database.
11:05:06 <maerwald> It was a little scary
11:05:21 <hyperisco> maerwald, I work with such a thing regularly, so, meh, par for the course?
11:06:25 <hyperisco> there is this new feature wanted, which requires some extra data and that is just tossed into the XML amalgamation without much thought
11:06:45 <maerwald> hyperisco: but from a multi-million dollar financial institution?
11:06:47 <nshepperd2> was it a Microsoft Access database...?
11:07:05 <monochrom> heh
11:07:11 <nshepperd2> running on the main developer's desktop computer, perhaps
11:07:11 <maerwald> But yeah, let's not think about what happens with our critical data in banks :D
11:07:33 <hyperisco> does sanity scale with market capital?
11:07:55 <monochrom> I think it's insanity that scales with market capital :)
11:08:11 <evelyn> I kind of hate banks but all these new companies that boast they are 'not a bank' still manage to be worse
11:08:13 <maerwald> monochrom: definitely hastiness
11:08:13 <evelyn> like paypal
11:08:31 <dsal> or bitcoin
11:08:42 <maerwald> faster, smarter, more energetic ppl... but somehow still manage to produce shit code
11:08:55 <maerwald> Something doesn't add up
11:09:07 <solonarv> but they produce it quickly and with much energy! ;)
11:09:09 <evelyn> turns out they hire from the same pool of people as banks!
11:09:36 <srk> important thing is a lot of crunch
11:09:36 <evelyn> but they get to avoid the protections that some conutires have for banks like the FSCS in the UK
11:09:56 <evelyn> countries*
11:10:16 <evelyn> anyway o/t sorry
11:10:26 <monochrom> My fault.
11:10:37 <srk> Athas: will investigate further, wanted to play with futhark anyway :)
11:11:23 <maerwald> Ok, so anyone knows how to bootstrap 7.10.3? It starts throwing this fPIC error on runtime and probably the ghc versions before it as well
11:11:36 <maerwald> 8.0.2 apparently can't build it
11:12:16 <phadej> you cannot build older GHC with newer one
11:12:23 <phadej> in general, just doesn't work
11:13:01 <phadej> (on which operating system btw, if it's macOS or windows, don't even try)
11:13:11 <maerwald> linux
11:13:14 <monochrom> Oh, something about many linux distros switching over to random positioning so they began to require fPIC around that time and GHC had to catch up and/or work around.
11:13:59 <phadej> maerwald: you might want to look into HVR's PPA source packages
11:14:14 <maerwald> not on ubuntu, this will be hard :P
11:14:27 <phadej> you can unpack them and look what patches are applied
11:14:43 <phadej> that should work on non linux too
11:15:19 <phadej> I doubt you can compile 7.10.3 with modern toolchain without some patches, in those (source) packages may be some valuable hints
11:16:11 <monochrom> Take a look in $prefix/lib/ghc-<version>/settings, maybe some line about ("C compiler supports -no-pie", "YES").
11:16:35 <monochrom> Compare that setting between older GHC and newer GHC.
11:16:56 <monochrom> Also switching to an old gcc that was popular at the time of the old ghc may help.
11:17:15 <maerwald> I can go down to 6 easily
11:17:56 <frdg> is this a correct statement in regards to property testing?: Ints, Chars, Strings, Integers come with an instance of Arbitrary so we do not need to define instances of arbitrary for these types to make generators for them. When we make custom data types though we have to create an instance of arbitrary in order to make generators of their type. 
11:18:28 <monochrom> Yes.
11:18:40 <frdg> monochrom: ok thanks
11:20:01 <monochrom> Basically the random positioning technique was implemented as a new gcc default.
11:20:29 <monochrom> err, maybe not "as", maybe gcc was only part of it.
11:20:53 <monochrom> Anyway, long story in the distant past I forgot most details of.
11:21:23 <monochrom> haha does my school server still has ghc 7.something?
11:22:12 <monochrom> nah it's gone.
11:22:29 <monochrom> but it still has java 7!
11:28:19 <maerwald> how does one bootstrap java 7?
11:29:25 <monochrom> Are you doing the equivalent of "I want to make a hamburger from scratch, really scratch"? :)
11:30:13 <maerwald> bootstrapping java is for inflicting maximum self-damage
11:31:41 <monochrom> Same for making a hamburger from scratch.  Someone raised a cow from baby cow for that.  I say even that's not enough, you need to first evolve a cow from primodial soup.
11:32:18 <maerwald> Wow, I guess ppl have worse OCD
11:32:25 <maerwald> must be from... SCRATCH
11:32:34 <monochrom> So, how does one bootstrap java 7?  First, invent/discover Turing machines...
11:33:21 <maerwald> I fear I might die before I manage to even have a terminal
11:35:44 <t7> anyone here do TDD? do you commit failing tests?
11:36:31 <monochrom> Turing did get some CRT display to work and connected to an early computer before he died, so you are in good shape. :)
11:38:13 <maerwald> I wonder if there lies value in rediscovering old knowledge from scratch, despite the personal value.
11:41:51 * hackage LTS 0.1.0.0 - LTS: Labelled Transition System  https://hackage.haskell.org/package/LTS-0.1.0.0 (ajayeeralla)
11:43:49 <jtza8> maerwald: Srinivasa Ramanujan was an Indian mathematician who proved that. Wikipedia has an article on him I suppose.
11:45:21 <maerwald> So java from scratch it is...
11:45:43 <jtza8> Yes, but Java never really was a good idea. :P
11:47:09 <jtza8> maerwald: I mean in that it didn't do OOP any favours.
11:47:44 <pie_[bnc]> im stuck in scroll but happened to see this:
11:47:45 <pie_[bnc]> <tdammers> also keep in mind that the "monad" part is a red herring - IO happens to have a Monad instance, and some crucial functionality is only exposed through the Monad API, but being a Monad is not what's special about IO
11:47:59 <pie_[bnc]> which makes sense but good to read nevertheless, didnt think of that
11:48:12 <pie_[bnc]> everyones always on about monads when IO comes up
11:48:53 <maerwald> pie_[bnc]: the reason is that "Monad" is the most expressive interface of your data type (usually)
11:49:03 <maerwald> that's why ppl talk about their monads
11:50:52 * hackage retry 0.8.1.1 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.8.1.1 (MichaelXavier)
11:51:41 <tdammers> no, it's not usually the most expressive one, but rather a very generic one, shared with a huge truckload of other types
11:51:45 <tdammers> that's what makes it so useful
11:52:16 <maerwald> what do you think is more expressive?
11:52:31 <tdammers> all the other stuff IO can do that aren't in the Monad typeclass
11:52:56 <tdammers> all the things that distinguish IO actions from lists, Maybes, States, Conts, and what have you
11:53:08 <maerwald> But there's no other typeclass that's more expressive for IO, except maybe arrow or something
11:53:35 <tdammers> you didn't say "typeclass"
11:53:40 <maerwald> Forgive me sir
11:53:45 <tdammers> but even then, there's MonadIO
11:53:58 <tdammers> which is technically as expressive as IO itself
11:54:04 <tdammers> (trivially)
11:54:05 <monochrom> I fear that this is just diagreeing on what "expressive" means.
11:54:09 <dsal> I don't quite understand what expressive means here.  It sounds like it means "smaller"
11:54:13 <tdammers> probably
11:54:23 <maerwald> monochrom: I think we are agreeing...
11:54:29 <dsal> (where "smaller" means "is applicable in fewer places")
11:54:52 <tdammers> to me, "A is more expressive than B" means that there are things that can be expressed in terms of A, but not B, but no things that can be expressed in B but not A
11:55:21 <maerwald> Monad is the ultimate thing, where effects depend on values (woah!), so yeah, we get a little excited, don't we?
11:55:55 <maerwald> Or maybe not anymore...
11:56:30 <solonarv> tdammers: no it isn't; you can't write 'catch :: Exception e => m a -> (e -> m a) -> m a' given MonadIO m
11:56:49 <monochrom> But if you try to learn getLine etc and you click/lookup too much, it's very easy to run into "instance Monad IO", "class Monad m", "(>>=) :: Monad m => ..." etc.  If no one is there to guide you, you tend to dig too deep into the wrong end.
12:00:58 <tdammers> solonarv: ah yes, you're right, you need those godawful lifted-base-control-IO-something classes for that, and then you'll end up crying
12:02:04 <solonarv> haha, not inaccurate
12:02:08 <maerwald> Scotty to MonadBaseControl: we weren't able to lift the Monad.
12:02:27 <monochrom> Beginners have no idea which one is more expressive or what it even means.
12:03:02 <monochrom> They're only working on the shallow level of "I see that word in that type sig, I must find out all about it".
12:03:41 <monochrom> They're just doing depth-first search gone wrong.
12:03:57 <maerwald> traversing knowledge is hard
12:05:00 <maerwald> And things like wikipedia don't solve this problem
12:05:16 <maerwald> They just structure the content, they don't filter it
12:10:13 <maerwald> I had this vision about a wikipedia equivalent, which would have such filters, where you define what type of reader you are and the article would self-adjust.
12:10:26 <maerwald> And then I went watching netflix
12:12:15 <monochrom> I had a related vision.  I noticed how a researcher would write a journal paper, a conference paper (shorter), and conference talk slides (even shorter) for the same thing.  I was thinking could one write just once and then some compiler will generate the three products.
12:12:34 <maerwald> But it's so hard.
12:12:47 <monochrom> Yeah! So it still stays as a vision.
12:13:10 <maerwald> Our children may carry out the glory.
12:13:35 <infinity0> if i use singletons type-level functions, is doing something like (Elem k kk ~ 'True) => legit / conventional, or should i define an actual constraint
12:14:12 <frdg> how should I think about errors that say "Ambiguous type variable"?
12:14:14 <zincy_> Is that not a constraint?
12:14:27 <infinity0> zincy_: it is, it just looks slightly weird
12:14:59 <zincy_> frdg: It means GHC has multiple types it could assign this variable but it doesn't have enough information to narrow it down to one.
12:15:12 <monochrom> frdg: It means some type class is involved, and the computer needs to select an instance, but it doesn't know how.
12:15:27 <frdg> ok thanks guys ill write that down
12:15:42 <monochrom> Usually you add some more explicit types.
12:15:52 * hackage toxcore 0.2.11 - A Tox protocol implementation in Haskell  https://hackage.haskell.org/package/toxcore-0.2.11 (iphydf)
12:17:37 <monochrom> An example is "print []".  [] :: [a], and "print" adds the requirement Show a.  The computer doesn't know, but needs to know, which type do you want for "a", i.e., element type, before it knows how to print the empty list, because it really matters, there are differences.
12:18:11 <monochrom> For example []::[Int] is printed as [] but []::[Char] aka String is printed as ""
12:19:11 <monochrom> ghci has an extra defaulting rule that says "let's assume the user is happy with a=()" so you don't see a cry for help.
12:19:15 <monochrom> But ghci is wrong.
12:22:42 <ysangkok> is this related to extrinsic/intrinsic typing? you could make the argument that who empty lists always be equal. if they aren't even comparable, they aren't equal.
12:22:48 <ysangkok> s/who/two/
12:23:15 <monochrom> I guess so!
12:24:51 <ysangkok> maybe that means it should be forbidden in cedille to have strings as lists of char, because it would violate the abstraction as you said
12:25:31 <ysangkok> (if you want a decent Show for String)
12:26:22 <monochrom> "print Nothing" suffers the same problem. So it is independent of how to do String.
12:26:57 <monochrom> The real source is from this clause: "instance Show a => Show T a", where T could be [], Maybe, ...
12:28:24 <monochrom> If you allow such clauses, you're basically taking the intrinsic typing stance, because now Nothing :: Maybe Int and Nothing :: Maybe () are distinguishable by the type system.
12:30:45 <ysangkok> but haskell has intrinsic typing, so it is just consistent with that, no?
12:31:32 <monochrom> Yes. But we can entertain the thought "what if you prefer extrinsic typing, what do you have to give up then?"
12:31:58 <monochrom> or alternatively "how do you tell that haskell is leaning on the intrinsic side"
12:32:22 <ysangkok> i guess we'll see how cedille pans out :)
12:32:58 <ysangkok> seems like it at least saves some repetitive code if you do dependent typing
12:33:01 <ysangkok> that could be important
12:34:20 <monochrom> because if you chalk it up to "look, you can't use == between []::[Int] and []::[()]", then I'll answer "but that's only the surface, recall == comes from instance Eq a => Eq [a], the real decision was made there"
12:38:33 <Cale> tdammers, solonarv: You should be able to use MonadCatch for that
12:39:22 <Cale> That's much better than MonadBaseControl/MonadTransControl for the specific thing, because someone gets to think about what it means for each transformer rather than doing something at random and hoping it was the right thing
12:40:21 <dramforever> The more common example for that Eq thing is: What's the difference between null and (== [])?
12:42:24 <dramforever> Oh wait, maybe that's not what's being talked about
12:42:32 <Cale> monochrom: It's also fair to put some blame on the class for that fact, as that's where (==) :: (Eq a) => a -> a -> Bool comes from
12:43:14 <dramforever> Yeah *this* is what I'm talking about
12:43:24 <Cale> So the class would have to change if we wanted to allow heterogeneous equality, and of course, you can actually try that and quickly find out it's totally not worth the trouble.
12:44:33 <Cale> The fact that you end up needing far more instances is possibly surmountable, but then, the inconvenience which comes from the typechecker not being able to decide if the two arguments to (==) have the same type is not.
12:47:30 <ysangkok> Cale: but why does the typechecker need to be involved if == erases the types before comparing? how is that an inconvenience? it can be no worse than for all the dynamic languages?
12:49:40 <ziman> because how you exactly do the comparing depends on which type it is?
12:50:22 <Cale> ysangkok: Imagine that you have some expression x == y where the type of x can be inferred, but y is polymorphic so its type can't be inferred
12:50:30 <Cale> A simple example of that would be x == 0
12:51:09 <Cale> ysangkok: Here, the typechecker is able to determine that 0 must have the same type as x, and so the comparison proceeds under that assumption
12:51:23 <Cale> :t 0
12:51:25 <lambdabot> Num p => p
12:51:27 <ysangkok> ziman: how do you compare in pure untyped lambda calculus?
12:51:34 <Cale> ^^ noting that 0 might be of any numeric type at all
12:52:17 <dsal> ysangkok: You first have to get into arguments about what equality means.
12:52:24 <Cale> If == were able to compare things of any two types, this would be inconvenient, because 0 on its own is ambiguous, and numeric defaulting might cause it to be specialised to Integer
12:52:44 <Cale> If that happened, and x was of any type other than Integer, you just wrote a comparison which is always False, probably a bug
12:53:27 <Cale> If numeric defaulting is turned off, then you just get a compile error complaining that the type of 0 can't be determined, also frustrating, but at least not a subtle runtime bug.
12:53:48 <Cale> (but also, you don't get the benefit of numeric defaulting anywhere else then)
12:54:04 <ysangkok> i don't have any problems with giving up numeric defaulting, never really felt the benefit
12:54:34 <Cale> Whether or not you have it, it would be frustrating and would require a lot more type signatures placed on equality tests.
12:54:43 <Cale> (often on both sides of the ==)
12:54:47 <ysangkok> more docs for free! awesome
12:55:06 <Cale> Not for free, you have to write them, even though the second one will usually be essentially redundant
12:55:11 <Athas> srk: this almost works, but fails with linker errors at the end, where it cannot find libc symbols: https://gist.github.com/athas/4b6e2ced36095681e70c320a48be293f
12:55:31 <Athas> I'm now trying with musl instead, but it will take a while, because Nix has to rebuild the world from scratch, it seems.
12:55:43 <Cale> (since you probably don't want to write a test that is constantly False)
12:56:14 <ysangkok> can't i just demand at least two examples when defining comparison? :O
12:56:24 <Cale> hm?
12:56:29 <srk> Athas: cool!
12:56:34 <ysangkok> an example of True, an example for False
12:56:56 <Cale> I don't understand
12:56:58 <operand> Ah, man, I'm happy that the lazy evaluation of my datastructure works the way I expected (and wanted) it to work
12:57:12 <ysangkok> you said i would tend to write comparisons that are always False
12:57:34 <ysangkok> if the language doesn't allow defining without giving examples, you won't be able to come with the True example
12:58:12 <ysangkok> effectively just a proof that the function is not (_ -> ())
12:58:13 <Cale> ysangkok: Yeah, because the very types of the things you were comparing were not the same, so how could they be equal?
12:58:54 <ysangkok> because they erase to the same untyped terms?
12:58:57 <Cale> There might be some cases where values of distinct types would be regarded as equal nonetheless, but that would be rare.
12:59:01 <ysangkok> i am just parroting https://cedille.github.io/
12:59:46 <Cale> There are some philosophical questions there, I suppose, espeically when it comes to numbers: is the natural number 0 the same as the real number 0?
13:00:36 <zeta_0> fendor_: hello again, i finally setup a good default.nix to build darcs in a nix-shell, anyways, i forgot what is the terminal command to generate the yaml file that will get ghcide working with darcs inside of a nix-shell?
13:01:22 <zeta_0> i hope i messaged the correct fendor , i could have sworn his nick did not have an underscore _
13:01:39 <Cale> But yeah, for the most part, heterogeneous equality is not very helpful, and certainly not helpful enough to justify its cost in forcing the programmer to explicitly specify types. The point of having a static typechecker is to relieve the programmer of having to think about types as much as possible.
13:02:38 <ysangkok> you're forcing people to think of the type checker if types are intrinsic
13:02:39 <Cale> If you want, feel free to define class HEq a b where (.==) :: a -> b -> Bool and have a go at filling out instances for it
13:02:41 <ysangkok> more stuff to think about
13:02:56 <frdg> I have a bunch of stand-alone .hs files that are in a sibling directory. How could I import these? Did I mess up by not using stack build initially? 
13:03:18 <Cale> You'll figure out pretty quickly how frustrating and annoying it is to use
13:04:03 <ysangkok> cedille people would say you will get tired of repeating your programs once for computation and once for the proof ;)
13:04:03 <Cale> There may be some cases where you really need something like that, but I haven't run into any in my 20 years of programming in Haskell
13:05:26 <Cale> Besides, I don't think cedille even discusses this operation very much
13:05:27 <ysangkok> i hear c programmers say the same ;) 'appeal to experience'
13:05:50 <Cale> The equality that Cedille makes heterogeneous is not term-level equality testing
13:05:57 <Cale> It's type level identity types
13:06:07 <Cale> Unless I'm missing something
13:07:54 <Cale> That's not a sort of equality which produces True or False, it's a sort of type which is either inhabited or not depending on whether two terms are equal.
13:08:05 <dramforever> ysangkok: Are you talking about this kind of equality: Walk the whole tree data constructors of both arguments and return True iff they match
13:08:38 <Cale> I haven't done a whole lot with Cedille, I could be missing out on their story for term level equality testing.
13:10:04 <frdg> how do I import a standalone .hs file that is in a sibling directory?
13:10:15 <dsal> That's not a thing.  You don't import files.
13:10:25 <dramforever> I don't think what I said can really mix with Eq as typeclass
13:10:38 <dramforever> It would need this scary thing called dynamically dispatched typeclasses
13:11:13 <Cale> Looking at the cedille standard library, I'm not even certain they formalise the operation that Eq discusses
13:11:20 <frdg> dsal: How could I turn this directory into something I can import? Can I just `stack build` it?
13:11:36 <dsal> frdg: You import modules from the source directory.
13:11:38 <dramforever> frdg: Not sure what you mean by 'sibling directory'
13:11:47 <Cale> But maybe I'm just missing it? I haven't used cedille much.
13:11:54 <dramforever> You mean lib/A.hs, lib/B.hs, lib/C.hs, then foo/X.hs
13:12:06 <dramforever> And you want to import A within X?
13:12:19 <frdg> dramforever: correct
13:12:43 <Cale> ysangkok: In fact, they have a bunch of entirely monomorphic equality tests
13:12:49 <Cale> https://github.com/cedille/cedille/blob/master/new-lib/data/nat.ced#L72
13:14:03 <Cale> https://github.com/cedille/cedille/blob/master/new-lib/data/list.ced#L104 -- here's a slightly polymorphic one for lists that allows for heterogeneous testing, but of course we could do this just as well in Haskell
13:14:25 <Cale> It just takes an argument of type (a -> b -> Bool) for comparing elements
13:14:31 <frdg> What would happen if I ran `stack build` from within the directory that has the .hs files? Basically what I am asking is, how do I turn this into something I can import?
13:14:39 <dsal> frdg: what happens when you try?
13:15:07 <Cale> ysangkok: So what is it that you're referring to?
13:15:11 <frdg> dsal: I didn't want to try in case it would make my life harder in the future.
13:15:14 <frdg> but ill go for it
13:15:34 <Cale> If you want that eqList function, I could write it in Haskell easily
13:15:52 <ysangkok> Cale: referring to in which statement?
13:15:55 <dsal> frdg: In general, reusable code goes into the src directory.  If you're using stack, sticking to the conventions will make things far easier.
13:16:00 <dramforever> frdg: Turning your files into a stack or cabal project will surely make your life easier
13:16:12 <Cale> ysangkok: You seemed to want Haskell to be more like cedille in some way
13:16:30 <frdg> ok thanks dsal, dramforever
13:16:47 <Cale> But I'm looking at how Cedille does things, and it's not substantially different from Haskell, except they lack any sort of type class under which equality testing operations would lie
13:17:15 <dramforever> frdg: But meanwhile you can just pass -ilib to GHC/GHCi
13:17:53 <Cale> eqList :: (a -> b -> Bool) -> [a] -> [b] -> Bool; eqList cmp xs ys = case xs of [] -> null ys; (x:xs) -> case ys of [] -> False; (y:ys) -> cmp x y && eqList cmp xs ys
13:18:01 <dramforever> frdg: https://dpaste.org/wYoC
13:18:42 <dramforever> (I think it's also how stack/cabal runs stuff under the hood)
13:18:48 <Cale> I'm being a little too literal there in my translation, you might like to take advantage of Haskell's ability to match on more than one parameter at a time
13:18:57 <frdg> ok thank you
13:20:19 <ysangkok> Cale: i didn't understand why numeric defaulting was so important. and afterwards, it seemed like you non-polymorphic equality will be too much work , i don't understand that either, why is the cedille equality a deal-breaker?
13:20:59 <Cale> The equality that the Cedille documentation mostly talks about is what we write as  ~  in Haskell
13:21:03 <Cale> at the type level
13:21:22 * hackage tokstyle 0.0.5 - TokTok C code style checker  https://hackage.haskell.org/package/tokstyle-0.0.5 (iphydf)
13:21:33 <Cale> It's not ==
13:21:54 <Cale> Cedille doesn't even have a convenient single == function which works with more than one type at a time
13:22:17 <Cale> Perhaps it could, but I don't know whether it even has type classes.
13:22:39 <Cale> That doesn't seem to be a priority, they're more interested in other aspects of the language
13:23:14 <Cale> Or I guess it's not quite Haskell's ~ since that's the constructor for type equality *constraints*
13:23:18 <Cale> It's more like :~:
13:23:27 <dramforever> This sounds interesting but I need to read the logs
13:23:34 <Cale> data a :~: b where
13:23:40 <Cale>   Refl :: a :~: a
13:23:45 <Cale> This thing
13:23:50 <ysangkok> are you talking about ≃ ?
13:24:21 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.13.0.0/Data-Type-Equality.html#t::-126-:
13:24:57 <Cale> Of course, Cedille is dependently typed, so it can be applied to terms to make types which are inhabited only if the terms are equal.
13:25:29 <ysangkok> i meant the cedille ≃ described at https://cedille.github.io/docs/about.html in section 1.2.2 Primitive equality between untyped terms
13:25:47 <Cale> In Haskell :~: can only be applied to types, and we can use the DataKinds extension to promote values to the type level to be able to apply :~: to them
13:26:23 <Cale> ah, okay
13:27:05 <Cale> But what sort of thing is { t ≃ t' } ?
13:27:13 <Cale> I don't think it's meant to be a bool, but I could be wrong
13:27:43 <Cale> I'm pretty sure it's a type
13:28:43 <dramforever> I think it's just a weird identity type, as in it's inhabited t equals t'
13:28:49 <dramforever> *inhabited iff
13:28:53 <Cale> Yeah, it seems to occur only on the right hand side of :'s in the source code
13:29:01 <Cale> right
13:29:05 <dramforever> It's just that the inhabitant can be anything
13:29:20 <ysangkok> Cale: it is the type construct for "untyped equality between terms t and t’" as noted in section 1.2
13:29:46 <Cale> tailDrop: ∀ A: ★. Π n: Nat. Π l: List ·A. {tail (drop n l) ≃ drop n (tail l)}
13:29:49 <dramforever> Oh right
13:29:53 <zeta_0> mpickering: i posted my issue in ghcide's issue section, if guys will be able to help me solve this, that would be great, thanks in advance
13:29:54 <Cale> See, it shows up in the *type* of tailDrop here
13:29:57 <dramforever> It's also untyped
13:30:11 <Cale> and not at the term level
13:30:25 <Cale> So in no way is it analogous to ==
13:30:33 <zeta_0> mpickering: https://github.com/digital-asset/ghcide/issues/525
13:30:49 <dramforever> ysangkok: To even compare an equality with Haskell's (==), you need a *function* that takes two *arguments* and returns a *value* that indicates whether the two are equal
13:31:18 <zeta_0> if anyone else could help me with that issue, it would be greatly appreciated, thanks
13:31:41 <Cale> (tailDrop is a thing which, given a type A, a natural number n, and a list l of values of type A, constructs a proof that tail (drop n l) is equal to drop n (tail l)
13:31:44 <dramforever> You need something like the eq function for Nat, as mentioned above https://github.com/cedille/cedille/blob/master/new-lib/data/nat.ced#L72
13:32:28 <Cale> { t ≃ t' } is the type of proofs that t and t' are the same term
13:34:14 <ysangkok> so equality is just a function, fine, and it is not in a type class
13:34:20 <Cale> right
13:34:34 <ysangkok> still don't understand why it is a dealbreaker
13:34:36 <Cale> Cedille's equality testing is actually way more restrictive than Haskell's
13:34:44 <ysangkok> booleans are a code smell ;)
13:35:00 <Cale> It just has a bunch of one-off tests for equality that only work on specific types
13:35:00 <dramforever> The dealbreaker is you're talking about two different things
13:35:14 <Cale> Yeah, you're not comparing the same parts of the languages
13:35:41 <dramforever> You're just saying 'Hey, why is X like this and not something that's almost completely unrelated to X'
13:35:59 <ysangkok> dramforever: i never mentioned (==) ;)
13:36:05 <Cale> huh?
13:36:15 <Cale> Did you mean to be asking about :~: then?
13:36:20 <dramforever> But that's where the discussion started...?
13:37:07 <Cale> You can't use { t ≃ t' } as a runtime test to compare anything with anything else. It only exists as a type for expressing the proposition that two things may be equal, and if they are equal, then that type will be inhabited by some value, and if not, it won't.
13:37:11 <dramforever> You said: 'is this related to extrinsic/intrinsic typing? you could make the argument that who empty lists always be equal. if they aren't even comparable, they aren't equal.'
13:37:28 <ysangkok> ok, true, that is way back
13:37:40 <Cale> Yeah, everything I've been saying has been related to that
13:37:56 <ysangkok> my current question is really just why it was untenable not to have the polymorphic equality that haskell has
13:38:11 <ysangkok> somehow i got the feeling that you suggested that just after numeric defaulting
13:38:22 <Cale> Well, Cedille could define all the sorts of equality that Haskell has.
13:38:33 <Cale> (apart from the fact that they're missing type classes, I think)
13:38:48 <ysangkok> but the typeclasses are just dictionaries, right, just sugar?
13:39:00 <dramforever> ysangkok: Defaulting was mentioned as a techicality
13:39:27 <Cale> Kind of, except that the language implementation constructs those dictionaries automatically from the instances based on the structure of types
13:39:35 <Cale> So it can actually end up doing a bunch of work for you
13:39:54 <Cale> But apart from that, sure
13:40:01 <dramforever> It's sugar
13:40:06 <dramforever> But it's far from 'just sugar'
13:40:39 <dramforever> wrt defaulting: Technically 0 == 128 shouldn't compile. Actually the types default to Integer so it does.
13:40:45 <dramforever> That's the deal with defaulting
13:40:56 <Cale> hm?
13:41:01 <Cale> oh, yeah
13:41:23 <dramforever> I believe that's why you mentioned it
13:41:47 <ysangkok> in coq , as i found out, you can write your own instance lookup algorithm
13:41:58 <Cale> Yeah, 0 and 128 are both polymorphic, so it's unclear which type of numbers we're comparing, even though the type of (==) insists that 0 and 128 both have the same type in that expression
13:42:03 <ysangkok> so it seems like typeclasses can be implemented in 'user-space'
13:42:35 <Cale> ysangkok: Yeah, I wonder if anyone's written a good instance resolver in Coq yet
13:42:49 <Cale> Which actually insists that instance resolution is coherent
13:43:08 <dramforever> I should have picked 256
13:43:10 <Cale> I'm not sure you can restrict which instances people write so that they're coherent
13:43:47 <dramforever> Then I can make the point that defaulting actually makes a difference because (0 :: Word8) == 256 is indeed True
13:43:49 <dramforever> > (0 :: Word8) == 256
13:43:52 <lambdabot>  True
13:43:55 <dramforever> > 0 == 256
13:43:58 <lambdabot>  False
13:44:16 <ysangkok> isn't that an argument against defaulting?
13:44:26 <Cale> ysangkok: A very important property of Haskell's type classes which is not shared by those of Coq or Idris is that if you have an instance C t, there is no question about which instance you have that satisfies the constraint
13:44:33 <dramforever> ysangkok: Nobody was arguing for or against defaulting
13:45:18 <Cale> Note that without the type of (==) being what it is, even dramforever's first line there (0 :: Word8) == 256 would be ambiguous
13:45:33 <dramforever> yes
13:45:59 <ysangkok> Cale: i agree, it is useful. but just pondering whether you can't have that guarantee if you use the right algorithm
13:46:43 <Cale> ysangkok: You might have to check hard after the fact to make sure that there isn't an overlapping instance
13:46:57 <Cale> Rather than being able to check at the time that people write the instances
13:47:53 * hackage contracheck-applicative 0.1.1.0 - Validation types/typeclass based on the contravariance.  https://hackage.haskell.org/package/contracheck-applicative-0.1.1.0 (Birkmann)
13:48:14 <ysangkok> Cale: ah tricky
13:57:47 <Athas> srk: this works and gives me a fully static executable: https://gist.github.com/athas/0474d01efc2d18aff9bf6be8da1d31f2
13:57:58 <Athas> Failed to build with musl, unfortunately.
13:58:34 <Refried_> Hi there.  For performance reasons, I'm trying to track down what is triggering a certain top-level expression in my larger application to be forced.  Is that possible?
13:58:38 <Athas> The resulting binary is 34MiB, which isn't bigger than normal.  In fact, the binary produced with standard 'stack install' is 59MiB...
13:59:15 <srk> Athas: pretty cool anyway! funny how the static flags differ for the three packages
13:59:26 <Athas> Variety is the spice of life.
13:59:32 <monochrom> Is it really important to statically link even libc?
13:59:34 <srk> indeed :)
13:59:58 <dramforever> Anyone know about using -fno-code in GHCi for fast checking? I'm not familiar with it but want to use it in vscode-ghc-simple extension as a default
14:00:21 <Athas> monochrom: glibc probably not, but I'd really like to statically link the others.
14:00:35 <dramforever> Stuff like, example workflows, caveats, etc.
14:00:53 <Athas> And I'm not sure if I can partially statically link something.
14:01:16 <maerwald> no
14:01:20 <maerwald> that's the problem
14:02:26 <maerwald> I have the same problem. An ugly workaround is for packages that have external dependencies to *bundle* them, then have a cabal flag that triggers building from the bundled version instead of linking
14:02:30 <maerwald> lots of work
14:02:46 <Athas> Well, I'm moderately happy with this.  We'll see if I'll actually use it for something.
14:03:26 <maerwald> And then again... do you want to statically link OpenSSL?
14:03:35 <maerwald> For portability yes, for security no
14:03:55 <Athas> Why not?
14:04:05 <maerwald> Depends... are you the only user of the binary?
14:04:17 <Athas> In any case, my program is not security sensitive in any real way.
14:04:26 <maerwald> if it does network calls, then it would be
14:04:48 <maerwald> and users don't get a security patch for your statically linked openssl that easily
14:05:22 <maerwald> the only problem dynamic linking really solves is this
14:05:26 <maerwald> for the rest it is annoying
14:06:08 <Athas> Oh, and -split-sections cuts down the binary size to 34MiB.
14:06:17 <Athas> It's still huge of course, but I can live with it.
14:06:19 <monochrom> Yes <3 -split-sections
14:06:25 <maerwald> oh, never tried that
14:10:57 <dramforever> maerwald: And that doesn't even work for Haskell
14:11:08 <maerwald> hehe
14:11:29 <maerwald> yes, dynamic linking in haskell is absolutely useless
14:12:00 <dramforever> Arch Linux probably disagrees for some reason
14:12:13 <maerwald> Yes, their packages work great
14:12:18 <monochrom> Arch LInux doesn't even care.
14:12:49 <maerwald> these are the things you should base your distro choice on: are the maintainers sane?
14:13:17 <monochrom> likewise with choosing an employer too.
14:13:45 <maerwald> monochrom: but so hard to test lol
14:15:02 <dsal> My employer doesn't dynamically link much, AFAICT.
14:15:07 <maerwald> xD
14:17:11 <dramforever> maerwald: I think if you only work with Arch packages then it's okay
14:17:25 <dramforever> (Although I kinda dislike the huge number of packages involved)
14:17:47 <dramforever> But the rest of the ecosystem just goes, meh dynamic linking doesn't do much anyway
14:18:27 <maerwald> ABI is too unstable anyway
14:18:39 <yushyin> are arch linux hate AGAIN :)
14:18:39 <maerwald> can't mix stuff from different GHC versions
14:18:42 <yushyin> very nice channel
14:19:00 <maerwald> yushyin: well, it has caused a lot of users a lot of trouble, who then seek help here
14:19:21 <solonarv> to be precise we are hating on how they package haskell development stuff
14:19:33 <monochrom> I hate those who don't hate themselves.
14:19:38 <maerwald> solonarv: well, I could hate on way more, but that would be offtopic
14:19:55 <solonarv> also I vaguely remember that they half-ass the "everything should be dynamic" thing, so if you want to use it you actually have to do additional configuration
14:20:00 <solonarv> this is terrible!
14:20:22 <maerwald> how is Go working for them so far?
14:21:12 <yushyin> yes, but I often read rude lines about arch linux and about the poeple about arch linux. That's a kind of hate I don't need. Can we people just tell what we all people tell how to install haskell on ANY linux platform? => ghcup
14:21:46 <maerwald> ok :D
14:22:18 <solonarv> yushyin: that's all I do! well, I also bemoan the arch maintainer's choices that make it so people have problems.
14:22:40 <Cale> yushyin: Well, it would be really nice if the default arch linux install of GHC were not so broken.
14:23:20 <Cale> yushyin: Not everyone who has problems with it might find their way here -- it especially affects would-be users of xmonad who aren't even Haskell programmers
14:23:21 <monochrom> I do have a rare use case of GHC's dynamic linking story.  I test hundreds of students' code.  I build hundreds of exes and only run them 10 times immediately and no one needs them anymore after the school term ends.  So these are very suitable for GHC's highly unportable dynamic linking feature.
14:25:09 <dramforever> yushyin: Not really hate on my side... In fact I'm saying this on Arch :)
14:25:18 <infinity0> i'm having some trouble with type-level inference with singletons, basically i have a type family that recurses into the data structure, and i can't get GHC to go through these steps when doing inference
14:25:22 <maerwald> monochrom: tell them to hand in a static executables (say its part of the exercise) :P
14:25:28 <infinity0> https://gist.github.com/infinity0/4615326d329083de8434d2249866ec70 -- does anyone have any tips
14:25:41 <monochrom> No I won't trust executables they hand in.
14:25:45 <maerwald> hahaha, yes
14:26:10 <monochrom> And I don't want to spend disk space storing static executables.
14:26:46 <dramforever> I'd say, it would be really nice if the default arch linux install of GHC were usable by default
14:26:53 <w1n5t0n> hey peeps, I have a question regarding Template Haskell: does the compile time limitation mean that I can't use (not define) TH functions in ghci?
14:26:59 <w1n5t0n> I currently use ghci to live code music (by sending strings from an emacs buffer to a ghci session) and I wanted to use TH to create some custom syntax, is this possible?
14:27:50 <yushyin> Cale: yes I also see the problem with the current situation, but I also think we could tell people in a tone in way where we don't insult the work of others :( I do see why xmonad could be especially a problem.
14:28:05 <monochrom> Where is the insult?
14:28:13 <solonarv> you can use TH in ghci. the way ghci works is that each line you type in is compiled (to a bytecode format) and then run immediately.
14:28:16 <dramforever> w1n5t0n: There shouldn't be a problem
14:28:36 <solonarv> as you can see there is still a compile step where TH gets run :)
14:28:52 <w1n5t0n> solonarv: is the bytecode format that ghci compiles to the same that a normal ghc compilation would produce?
14:29:03 <w1n5t0n> ie. does it take just as long and does it optimize just as much?
14:29:07 <dramforever> No, it's in-memory only
14:29:07 <yushyin> monochrom: I did't say that maerwald insulted anyone, but I certainly read some in the past.
14:29:13 <dramforever> and it's unoptimized
14:29:13 <maerwald> I could expand probably for 30 minutes straight why I would stay away from archlinux, because I know their packaging practices very well :)
14:29:24 <maerwald> And I was an arch users for years
14:29:39 <solonarv> no optimization at all, not by default and you can't turn it on
14:29:46 <dramforever> But it can call optimized code
14:30:02 <solonarv> yes, and it can call ordinary compiled code as well
14:30:11 <dramforever> So your library functions run at optimized speed
14:30:48 <w1n5t0n> So is there a way to explicitly define which parts of a library get pre-compiled? Currently I just load the whole module but a lot of its parts don't (have to) change
14:31:11 <monochrom> bytecode is very different from compiled asm code.
14:31:32 <dramforever> w1n5t0n: Can you split it up into several modules? This way only the changed ones get recompiled
14:31:41 <nshepperd2> how come base 4.13.* still isn't on hackage yet
14:31:45 <dramforever> Like, why not put the unchanging parts in a separate module
14:32:05 <monochrom> bytecode still counts as interpreted because there is still a bytecode interpreter.
14:32:17 <w1n5t0n> dramforever, sure I could, but how would I load them so that they're compiled and not interpreted?
14:32:27 <maerwald> nshepperd2: last time it also lagged behind a week or more
14:32:29 <nshepperd2> isn't ghc 8.8 like a year old now
14:33:24 <dramforever> w1n5t0n: Assuming you're talking about within GHCi, :set -fobject-code, load the library, then :set -fbyte-code, load the rest
14:33:46 <dramforever> Uhh, I mean
14:33:47 <monochrom> The GHC user's guide has a detailed section on how to have some of your modules interpreted and some others pre-compiled and stay away from being interpreted.
14:33:52 * hackage dobutokO2 0.25.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.25.0.0 (OleksandrZhabenko)
14:33:52 <maerwald> hvr probably busy, not sure who's uploading it
14:34:22 <dramforever> Noice, referring to official docs
14:34:27 <monochrom> And actually you don't need to keep switching between :set -fobject-code and :set -fbyte-code.  But you do need to know about "ghc -c"
14:34:55 <dramforever> Yeah
14:35:00 <dramforever> Ignore what I said above
14:35:00 <monochrom> The section is called "loading compiled code"
14:35:08 <dramforever> It doesn't mean what I thought it would mean :(
14:35:34 <monochrom> To be sure, temporarily switching to :set -fobject-code works too, but I think it's too much typing.
14:36:19 <dramforever> What I was trying to say is that so long as there's an up-to-date, -fobject-code compiled version of a module, GHCi will happily use that even under -fbyte-code
14:36:51 <monochrom> Its previous section "loading source files" is also worth reading.  A few life hacks few people know about but hiding in plain sight in a very good user's guide.
14:37:40 <w1n5t0n> That's exactly what I needed, thanks all!
14:38:06 <monochrom> GHC user's guide covers all your toilet paper needs.
14:38:36 <w1n5t0n> On a slightly related note, would it be possible for me to replace ghci completely with a binary that's using something like hint to interpret (relatively simple) Haskell code?
14:39:45 <w1n5t0n> I'm not doing anything other than using and perhaps defining simple functions operating on pre-determined datatypes, so having to depend on a complete ghci installation is a pain for portability
14:39:47 <monochrom> I don't know because I don't know what you use ghci for.
14:40:02 <monochrom> But let me just bayesianly bet "yes".
14:40:08 <dramforever> 'I currently use ghci to live code music (by sending strings from an emacs buffer to a ghci session) and I wanted to use TH to create some custom syntax, is this possible?'
14:40:20 <w1n5t0n> https://github.com/lnfiniteMonkeys/TimeLines, if you scroll to the bottom you'll see some example code
14:40:20 <monochrom> (If it turns out "no", I lose nothing anyway!)
14:40:55 <dramforever> My answer I also bet you can, but I don't think there's much to gain
14:41:18 <maerwald> interesting how popular haskell is with music/audio stuff
14:41:28 <w1n5t0n> The only thing I'd care to gain is having a single executable that can do what I want it to, which would make it insanely easier for people to install and use this
14:41:46 <monochrom> hint requires >90% of a complete ghc installation.
14:42:01 <monochrom> every program that uses the GHC API does.
14:42:25 <monochrom> if statically linked, I guess s/requires/links in/
14:42:28 <w1n5t0n> So is there no hope for a single binary that can interpret simple Haskell code?
14:42:46 <monochrom> Yes there is hope. But it's as big as 90% of GHC.
14:42:51 <dramforever> There's no 'simple Haskell code'
14:42:52 * hackage benchpress 0.2.2.13 - Micro-benchmarking with detailed statistics.  https://hackage.haskell.org/package/benchpress-0.2.2.13 (willsewell)
14:42:54 <w1n5t0n> Alternatively I guess I could package a custom distribution of ghc
14:43:07 <w1n5t0n> Size is not particularly an issue, portability and ease of installation is the main concern
14:43:18 <monochrom> OK then hint can help.
14:43:19 <w1n5t0n> And performance; would hint suffer substantially?
14:43:24 <nshepperd2> i think the desire here is more to avoid messing with configuration of package database and stuff then code size
14:43:39 <monochrom> No, hint is just calling the same functions ghci calls.
14:43:58 <dramforever> Can you just make something like a Docker image
14:44:17 <dramforever> Or AppImage, although I don't know if the latter works with GHC
14:44:30 <w1n5t0n> I think I could, but I'm not sure what kind of overhead that would introduce for latency and for time-sensitive stuff
14:44:32 <monochrom> Hey let me get old-school.  Consider hugs.  >:)
14:44:43 <nshepperd2> docker seems like taking one problem and turning it into two problems
14:45:20 <monochrom> That is not bad on its own.  Divide-and-conquer does that all the time.
14:45:34 <dsal> I miss hugs.
14:45:40 <monochrom> For it to be bad, the two subproblems have to be bigger.
14:45:42 <dramforever> I guess just think of it first because I think it's popular
14:46:25 <w1n5t0n> The problem then is that Docker becomes a dependency, when the objective is to minimize dependencies
14:46:31 <hpc> dsal: yeah, social distancing is rough
14:47:12 <monochrom> IRC users have long solved the social distancing problem by /me hugs
14:47:47 <monochrom> And /me slaps
14:47:51 <monochrom> @slap monochrom
14:47:52 * lambdabot activates her slap-o-matic...
14:48:08 <monochrom> Who needs zoom
14:48:19 <maerwald> ppl who like to run vulnerable software
14:48:34 <maerwald> did you see how it installs itself on mac?
14:48:54 <monochrom> No, but I read the article on it.
14:49:05 <dramforever> They fixed it quite quickly though
14:49:18 <monochrom> One of a few things I would rather only read than see :)
14:50:24 <maerwald> in NYC zoom is already banned from schools :>
14:50:28 <monochrom> @botsnack
14:50:29 <lambdabot> :)
14:50:53 <dramforever> I mean, if the userbase grows faster than it gets banned
14:51:00 <dramforever> It's still net growth
14:51:06 <monochrom> R0 > 1  >:)
14:51:15 <maerwald> Yes, it's a virus.
14:51:29 <dramforever> Also maybe #haskell-offtopic
14:52:33 <monochrom> No wait sorry, I was wrong.  Any program that uses the GHC API, such as hint, still assumes and needs a proper GHC installation.
14:52:40 <nshepperd2> oh good, cabal-install supports ghc-8.8 now
14:52:50 * nshepperd2 updates cabal-static aur package
14:53:19 <w1n5t0n> monochrom then what use is hint meant for, if not to cover the need for a GHC installation?
14:53:24 <maerwald> nshepperd2: btw https://github.com/haskell-infra/hackage-trustees/issues/240
14:53:43 <monochrom> If you do static linking, well this is dumb, but all you have accomplished is doubling the disk space footprint.  hint is statically linked with a copy of GHC API, sure; then the GHC API code goes on to look for another copy that lives in a proper GHC installation.  I'm serious.
14:54:06 <dramforever> well
14:55:23 <monochrom> hint is meant for using the GHC API easily.  It doesn't claim to eliminate installation issues and dependency issues.
14:55:51 <w1n5t0n> Is it possible to package GHC with all dependencies (internal or external) in a directory so that I can copy-paste that to a different computer and trust that it works?
14:56:12 <maerwald> hmm, I just checked cabal-install and it doesn't link to openssl... how does it do its networking? just plain http?
14:56:13 <w1n5t0n> I guess similar to what Portacle does for Emacs
14:56:58 <monochrom> I think cabal-install calls curl
14:57:14 <nshepperd2> maerwald: :S
14:57:32 <maerwald> hmm
14:57:46 <monochrom> And even to the point it calls curl as in exec("curl", ...)
14:58:21 <monochrom> And even there is a flag or an option to use wget instead, or something like that.
14:58:21 <maerwald> I guess that is more portable than relying on openssl ABI...
14:59:40 <glguy> I don't know that cabal-install is doing TLS. I think it relies on its own signing
14:59:40 <monochrom> do a "cabal --help" and look for "--http-transport" for a glimpse
14:59:59 <dramforever> I took a look at hint's API, and I think it's very like a bare-bones GHCi, but they are Haskell functions rather than text sent back and forth
15:00:37 <dramforever> There's even interpret :: (...) => String -> a -> m a
15:00:45 <dramforever> Imagine getting a function back from GHCi
15:00:48 <monochrom> Yes that's the benefit of hint.  A simple interface and much more structured and programmable than "everything is a string".
15:00:56 <maerwald> Let's see what happens when I set --http-transport to powershell :P
15:01:06 <monochrom> :)
15:01:37 <monochrom> "Automatic downloading of Windows commenced..."
15:01:38 <maerwald> Ok, it just downloads regardless, now I'm scared
15:01:51 <yushyin> powershell features an https client?
15:02:02 <monochrom> Now you need to strace it to see who it's really calling!
15:02:09 <maerwald> I'm suspecting the cli option is old and maybe deprecated
15:02:26 <monochrom> I don't know about the "s" part, but powershell can certainly do http
15:02:35 <yushyin> oh cool
15:04:49 <maerwald> ah right, it just falls back to whatever available
15:06:46 <monochrom> Ah powershell does TLS and (or for) https too
15:07:09 <monochrom> basically I know this from chocolatey instructions
16:06:11 <dgpratt> I've been pondering the fact that TypeScript is an example of a type system with proper union types, whereas in Haskell we have discriminated unions. Is there a particular reason why (non-discriminated) union types would not be workable in Haskell? Maybe some implications for type inference?
16:14:49 <koz_> dgpratt: Sorry, but I don't know what you mean about 'proper' versus 'discriminated' unions. 
16:20:48 <dgpratt> koz_: in TS you might have a type like `string | number`. A value of that type would either be a `string` value or a `number` value. In Haskell, we might represent that as `Either String Int`.
16:21:23 <koz_> Is the TS type 'number | string' distinct from the type 
16:21:24 <lyxia> subtyping with typeclasses is a hard problem
16:21:27 <koz_> 'string | number
16:21:30 <koz_> ?
16:22:00 <dgpratt> koz_: I don't believe it is
16:22:30 <dmwit> Why is string | number a useful type?
16:25:05 <dgpratt> dmwit: it may not be the best example, but maybe a case where a certain piece of data could come from e.g. an API call in one case (as a number), or user input in another case (as a string)?
16:25:28 <dmwit> But, like, what well-typed consumer can you write for that thing? There's essentially none, right?
16:25:31 <dmwit> So why bother?
16:26:35 <dmwit> Because any well-typed consumer doesn't get to assume which side of the union you're on. It has to work no matter which it is. And there's, like, no operations you can do that actually make sense for both strings and numbers.
16:26:41 <dgpratt> I can either further discriminate the type on a case-by-case basis or I can perform operations on the value that are in-common between both element types (e.g. converting the value to a string)
16:27:15 <dmwit> For the former, you can only do that if you have the tag. So why not a discriminated union? For the latter, well, we have typeclasses already.
16:28:24 <dsal> How do you discriminate when consuming?
16:28:59 <dgpratt> like dmwit said, there is some runtime-inspectible tag in this scheme
16:29:11 <dsal> I mean, what does it look like?
16:30:40 <dsal> The haskell equivalent in my brain is pretty straightforward.  I'm just wondering what your code that uses one or the other would do.  Do you have to explicitly deconstruct it (e.g., like when working with Value in Aeson)?  It does something similar, but I don't find it very convenient.
16:31:02 <dsal> I think you could do something similar in haskell, though.  I should be able to have both an IsString and a Num instance, right?
16:31:16 <dmwit> I don't know how it's done in TypeScript. But in C, say, you'd have an enum that lists the possible tags, and you'd use switch to dispatch on the different possibilities.
16:31:22 <dmwit> Then you'd have a type-unsafe cast inside each branch.
16:32:05 <dgpratt> https://ultimatecourses.com/blog/understanding-typescript-typeof-type-guard
16:32:25 <dsal> Oh, typeof
16:32:59 <dsal> if(typeof bar === 'string')  -- it's somehow funny to me that the type of typeof is a string.
16:33:27 <koz_> dgpratt: That requires runtime type information.
16:33:55 <dmwit> dgpratt: What is the (inferred?) type of getSongDuration?
16:33:56 <dsal> I never really looked into TypeScript.  From descriptions I've heard of it, it always seemed to make me think of putting a bandaid on the finger of a degloved hand.
16:34:03 <dgpratt> good point -- not something we have "by default" in Haskell
16:36:06 <dmwit> Follow-up question: what is the inferred type of `function foo(item:Song, ty:string) { if(typeof item.duration === ty) return item.duration }; foo(bar, 'string')`?
16:36:54 <dmwit> Follow-up follow-up question: what is the inferred type of `foo(bar, collatzConjecture ? 'string' : 'number')`?
16:37:11 <koz_> dmwit: follow-up^2 question.
16:37:40 <dgpratt> dmwit: to your first question, as you can see here 
16:37:40 <dgpratt> https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=2&pc=22#code/PTAEEkFsAcHsCcAuoDOiCeAbApigFttoigFACWMCyA5AHTBpba0DGKK1A3CSS5gIbtQAZVgA7AOagA3iVCgW4tPACuLRAgAU0FQCNMZFqERlEOAFypE8MpIA0oHfsOgAJivj8T4y8ttSAH1AxFUhdbHgAShkAXxI4kgAzFTF1MnFQCSJRSQARDy90sU1TbEhLHIlo2XkyRNBNDGhsWHrSyFp3T28xUABeAdBqP0lqarl5UHgiD172zoKe7nk4+UUxNBk3RaLQGP7QduWFJWRIWxVEXAOAWS88WkTMWC0uwoywADYABl-vyOO602KGw61cKAOmjePVAYAAjH9ogBSUA-Y7TRCzUAAAwAJ
16:37:40 <dgpratt> NJziErigYuZ8SCwSTsdwEkDkChxBJ8t0igAxeCwSDCaz+A5ZRCVZnvYoTMTYADuIkZmmoAHVxK4IslMKB5WJFfBldQHNRvgBWcwAZjhY1AJABJBA+qNcN4SlgOFozwkmgZeR24nZnO5NkkFp4dNQjKFPS9kBuwj52WDHpF8jFksqMrVGuVqoVSpUmG1oENhr+-zNFpABvzdo2DuYztdMZZno54eEAKAA the inferred return type is `string`
16:37:48 <koz_> DAT LINK
16:37:53 <jackdk> wow
16:37:53 <koz_> Wargarble.
16:38:35 <dmwit> when you need to send a pastebin link for your pastebin link
16:39:10 <dgpratt> it encodes the entire TS code as a param
16:39:20 <monochrom> heh
16:39:37 <koz_> dmwit: A meta-pastebin link?
16:39:38 <dmwit> I have opened your link. But I do not understand how to "see" that the inferred return type is string.
16:39:51 <koz_> Rank-2 linking.
16:39:52 <dgpratt> hover over the function with your mouse
16:40:56 <dmwit> Right. So it already falls over with my simple follow-up question.
16:41:15 <dmwit> Because it infers foo(bar,'string') : string | number instead of : string.
16:41:28 <dmwit> And I think that says pretty much all that needs to be said about why it isn't in Haskell, honestly.
16:42:35 <koz_> Most 'object' 'oriented' languages approach type safety roughly as thus 'Ehh, runtime'll handle it'.
16:42:55 <koz_> (add as many levels of scare quotes to both of those terms as desired or warranted)
16:45:32 <dmwit> In summary: it doesn't solve an interesting problem, union types can't really be used without at least one type-unsafe cast, and typeclasses already cover the "but multiple types implement the same interface" use case.
16:46:21 <dgpratt> dmwit: You and others have made some good points, but I think that's a bit unfair. TS is intended to be a type-system for JS code. "typeof" is a JS construct. If JS had something more akin to the `is` operator of C#, that would not be an issue.
16:46:44 <koz_> dgpratt: The 'is' operator of C# is still reliant on runtime type information I think.
16:47:05 <dgpratt> but I agree, this scheme requires run-time inspect-able type tags 
16:47:49 <dgpratt> but that is pretty much what discriminated unions do, so for me this is more a question of ergonomics
16:47:51 <monochrom> "is", "instanceOf", "type(...) == ...", tomehto tomahto
16:48:16 <koz_> dgpratt: Discriminated unions in Haskell don't need runtime type information.
16:48:22 <koz_> GHC at least practices full type erasure.
16:48:35 <monochrom> They are all boolean blindness brought to the type level.
16:49:22 * hackage poly 0.4.0.0 - Polynomials  https://hackage.haskell.org/package/poly-0.4.0.0 (Bodigrim)
16:49:34 <monochrom> For a union type system that could be remotely called properly designed, what you need is the following consumer construct:
16:50:20 <dmwit> I dunno. What it sounds like to me is that you don't want to admit that C#'s and TS's unions are in fact discriminated unions.
16:51:04 <dmwit> A proper union type does not have a way to test which side of the union it's on. And this makes it truly difficult to make actually useful while maintaining type safety.
16:51:08 <monochrom> Suppose x :: string|number for example, then the construct goes like: typecase x of { s::string -> ... here you may use s ...  ;  n::number -> ... here you may use n ... }
16:51:47 <dmwit> monochrom: But how can the language support that without making string|number secretly be a discriminated union? *scratches head*
16:52:08 <dgpratt> guys, to be clear, I'm not trying to criticize Haskell -- ask anyone I work with, I love Haskell -- it was just a question :)
16:52:24 <monochrom> None of those false separation of non-separable concerns "a predicate to ask whether it's a number; a caster to make it a number".  Recall what's wrong with isJust, fromJust.  Same deal.
16:52:39 <koz_> dgpratt: For what it's worth, I didn't take any of what you're asking as criticism.
16:53:06 <koz_> My biggest 'why Haskell (that is, GHC Haskell) doesn't do this' was 'runtime type info'.
16:53:17 <koz_> Which I believe was your original question, right?
16:53:36 <dgpratt> I've got more insight on the question now, yes koz_
16:53:51 <dgpratt> which was the point
16:53:52 <monochrom> dmwit: I don't know.  There are two stances and I am not sure which one is better.  A. It is tagging, but nicer syntax.  B. The tagging is an implementation detail, we don't think about it when at a higher level.
16:53:54 * dmwit . o O ( Why doesn't TS support having number|number properly? :trollface: )
16:54:20 <koz_> In general, as I mentioned, 'object' 'oriented' languages kick a _lot_ of stuff to runtime, regardless of what claims they (claim to) make about being 'typesafe' or 'statically typed' or what-else-have-you.
16:54:29 <monochrom> which is the same as my thought when Rob Harper kept harping on "there is no dynamic typing, it is unitype with tags".
16:54:34 <koz_> Almost all of it requires _some_ kind of RTTI.
16:55:18 <monochrom> It is still useful to have a dynamic typing narrative as a high-level model without always doing reductionism to "it's an algebraic data type underneath".
16:55:29 <monochrom> And I thought I was the only reductionist.
16:55:50 <koz_> monochrom: As with colours, so with dynamic typing narratives? ;)
16:56:32 <dmwit> monochrom: I like thinking this new thought, thank you.
16:59:31 <monochrom> At any rate, I thought it was immediately obvious to everyone who appreciate haskell or sml that even when you like union types, whether you think of it in terms of tagging or not, the typecase construct is far superior to an "is" predicate plus a cast converter.
16:59:49 <monochrom> LIke, it's clearly as bad as an isJust predicate plus a fromJust converter.
17:01:21 <monochrom> In the case of Haskell's Typeable, at least they know to give you cast :: <constraints omitted> => a -> Maybe b
17:02:23 <monochrom> boolean blindness people from java and c# and python and typescript and similar pretenders likewise need to learn this.
17:02:53 <dgpratt> in C# we at least now have a construct like `if (value is string s) { /* s of type string in scope here */}
17:03:20 <monochrom> I do have some disagreements with some Rob Harper points, and I think that his boolean blindness article is too long, but I thank him for coining the name! :)
17:03:46 <monochrom> Oh! Then C# has my respect.  Sorry!  I didn't check.
17:04:14 <dgpratt> also, to be clear in the TS case, you don't need the check *plus* cast -- the correct type is inferred within the block where you did the check
17:04:20 <monochrom> Yes you need C#-like "is" if you want typescript union types to fly.
17:04:21 <koz_> dgpratt: As of which C# version do we have said construct?
17:04:35 <monochrom> Ah OK nevermind!  Sorry!
17:05:05 <solonarv> koz_: I believe it is a fairly recent addition
17:05:36 <solonarv> and I think Java is supposed to get the same construct (or possibly a similar one)
17:05:51 <dgpratt> lots of good stuff recently added to C# -- a lot inspired from Haskell-like languages, clearly
17:06:24 <dgpratt> like they finally fixed implicitly nullable reference types!
17:06:28 <koz_> solonarv: I figured it was fairly recent. Was curious just _how_ recent, because I heard a few folks chiming about C# 8 lately.
17:07:08 <dgpratt> the `is` thing was in C# 7 also, not sure when it was introduced
17:08:38 <sshine> I wonder if there's a library for constructing control-flow graphs based on program ASTs? in particular, I'm working with assembly, so it's all straight-line chunks with jumps.
17:09:04 <koz_> sshine: Do you just want a library to represent control-flow graphs?
17:09:12 <koz_> Or do you wanna be able to do something specific with them.
17:09:37 <sshine> koz_, represent control-flow graphs first. construct them second, if possible.
17:10:01 <koz_> sshine: There's a bunch of graph libraries. Check if algebraic-graphs suits your needs, as it's pretty cool.
17:19:47 <dmwit> sshine: https://github.com/GaloisInc/crucible
17:20:49 <dmwit> We also have some libraries with semantics for specific assembly architectures, among them x86-64, PPC, and I think we have a WIP semantics for ARM.
17:20:54 <dmwit> https://github.com/GaloisInc/macaw
17:22:00 <dmwit> But... they are honking complicated libraries. I consider myself pretty expert at Haskell, and it took me several months and close contact with the library authors to get going with them...
17:28:27 <dmwit> If you have questions, I may be able to help. Maybe 60% I can answer the first round, of the ones I can answer maybe I can answer 60% of the followups, etc. =P
17:29:03 <koz_> dmwit: But doesn't this mean that you never answer all questions?
17:29:13 <dmwit> I am very confident I cannot answer all questions.
17:29:42 <koz_> In that case, you are a wise man/woman/eldritch tentacled horror.
17:30:05 <sshine> koz_, thanks!
17:30:13 <sshine> dmwit, wow! I'll have to look at those.
17:30:33 <koz_> Yeah, I had no idea that thing dmwit linked existed either.
17:44:17 <dibblego> dmwit: what do you use crucible for?
18:06:24 <dmwit> The thing I was hacking on most recently is: we have a binary rewriter, and want to check that the rewrites we do preserve the behavior of the program. I laid some of the groundwork for asking an SMT solver whether that was true (and if not, what a counterexample looks like, in the sense of what values the registers had when the code started and what the results of the various memory reads were).
18:08:29 <sshine> I don't know how you ask an SMT solver that, but that sounds really cool.
18:08:50 <dmwit> The project more broadly was looking for ways to transform programs so that they crash more often (!).
18:08:55 <sm[m]> koz_: thank you for acknowledging the eldritch horrors in the room, it’s rare
18:09:32 <dmwit> The pitch there is that getting exploited is not so bad if you notice it right away and do something about it, so make it easier to notice by making common exploit patterns crash the program harder instead of just corrupting the internal state and continuing on.
18:10:44 <dmwit> sshine: The way we ask the SMT solver is: 1. construct a (very complicated!) symbolic expression that represents the results of all the registers after running a chunk of assembly on fully-symbolic starting input registers 2. do it again, for the rewritten program 3. ask if there are any starting assignments that cause the final register values to differ.
18:11:58 <dmwit> (This requires having a translation of all assembly instructions into the language that SMT solvers speak, of course! This is the semantics I was alluding to above. The standard theory of bitvectors is the main workhorse there.)
18:13:41 <quantumplate> I'm getting some hands on time with the state monad, and I'm starting to grok simple cases.  I'm trying to understand, now, how I might compose simpler state monads into more complex ones, like in this example: https://gist.github.com/Quantumplation/ea8ab364d4906ebb593b55883340d0b5
18:15:22 <dmwit> Gluing together actions that work on different state types is annoying but doable.
18:15:40 <dmwit> The usual pattern is to instead make a God Object that contains all the state, and have your actions modify fields of the God Object.
18:15:47 <quantumplate> in particular, I think I could probably write this in a very verbose way, just wondering if there's an elegant way to make these compose.
18:15:58 <dmwit> ...and then there's lens. =P
18:16:28 <oats> quantumplate: I'm not sure I understand. Are you trying to turn the State (Seq (Double, Double)) into a State (Seq Trade)?
18:16:40 <koz_> dmwit: Indeed, I've used microlens to great effect with MonadState SomeHugeRecord.
18:16:40 <Axman6> lens plus the Zoomed stuff makes this quite nice
18:17:15 <oats> koz_: I about had a little brain 'splosion when I found out (micro)lens had State functions
18:17:17 <quantumplate> no.  I'm effectively trying to say project the sequence of trades down to a sequence of their prices, or a sequence of (price, volume) pairs, and then use that as the state for the other state functions
18:17:19 <dmwit> One of two lens ways is to use `zoom`, which has a type roughly like `zoom :: Lens' s t -> State s a -> State t a`.
18:17:27 <dmwit> err, backwards
18:17:29 <Axman6> zoomed (my . inner . state) $ do someThing >>= workingOnTheInnerState >>= whichWIllBeUpdatedIn theGodState
18:17:35 <dmwit> `zoom :: Lens' s t -> State t a -> State s a`
18:17:43 <koz_> oats: Yep, in microlens-mtl.
18:17:46 <solonarv> dmwit: zoom is just a way to make that "god object" approach not terrible
18:18:16 <solonarv> I wouldn't want to do that without lens, tbh
18:18:18 <solonarv> sounds horrible
18:18:23 <dmwit> solonarv: Well, I think there's still two approaches. One is to use zoom to combine actions that operate on fields. Another is to have the actions do their own descending into fields.
18:18:36 <Axman6> I'me personally almost never had a need to use state in my programs though, except in mocks of actually stateful services
18:18:37 <dmwit> The former is painful without lens. The latter is... mostly fine.
18:18:45 <dmwit> (even without lens)
18:18:58 <oats> koz_: yeah, I like how microlens splits it out :)
18:19:04 <solonarv> lens *does* make the latter nicer though, IMO
18:19:18 <solonarv> nothing like a 'nextIndex += 1' to brighten my day ;)
18:19:22 * dmwit shrugs
18:19:28 <dmwit> I don't feel strongly enough to want to argue about it.
18:19:30 <oats> because haskell is totally a pure language :P
18:19:30 <Axman6> also, the classy lens technique also works well here
18:19:53 <Axman6> your actions then run on (MonadState s m, HasTheSubStateICareABout s) => m a
18:20:06 <Axman6> yes, a bout
18:20:14 <oats> what's this about classy lens? I haven't heard of this
18:21:25 <quantumplate> The reason I chose state is that I want to effectively iteratively react to each trade, updating some collection of different indicators, and then make decisions on the updated indicators, without having to recompute everything
18:21:52 <quantumplate> i.e. (average, total) can be updated incrementally on each new observed trade, without having to sum over the whole history again
18:21:53 <Axman6> data Foo = Bar { baz :: X, quux :: Y}; makeClassy 'Foo gives you class HasFoo a where foo :: Lens a Foo; bar :: Lens a X; quux :: Lens a Y; instance HasFoo Foo where foo = id
18:22:24 <quantumplate> is there a better, more haskelly way to do that? (mostly this is just an exercise to dive deeper into haskell idioms)
18:23:28 <quantumplate> I'm looking for a new job, and some of them that are coming up are haskell related, so I'm trying to beef up those skills.  20 years of imperative programming isn't always translating super easily heh
18:27:24 <Axman6> oats: https://carlo-hamalainen.net/2015/07/20/classy-mtl/
18:30:17 <Axman6> % :T zoom
18:30:18 <yahb> Axman6: unknown command ':T'; use :? for help.
18:30:21 <Axman6> % :t zoom
18:30:21 <yahb> Axman6: forall {m :: * -> *} {n :: * -> *} {s} {t} {c}. Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
18:32:08 <dmwit> pretty opaque
18:33:43 <Axman6> yes
18:40:00 <solonarv> yeah the type is pretty opaque
18:41:03 <solonarv> you can look at a less-general instantiation of it: zoom :: Monad m => Lens' o i -> StateT i m a -> StateT o m a
18:41:31 <solonarv> and then wave your hands and go "oh, but actually it also works if the StateT is hidden under some other monad transformers"
19:01:34 <dsal> quantumplate: I'm not entirely sure why state matters.  It sounds like you want a map or a fold or something.
19:02:00 <dsal> I've used StateT a couple times, but not for that sort of thing.
19:02:23 * hackage aeson-schema 0.4.2.0 - Haskell JSON schema validator and parser generator  https://hackage.haskell.org/package/aeson-schema-0.4.2.0 (MateuszKowalczyk)
19:02:44 <dsal> huh.  Maybe I should try that.  I already have a million dependencies.  What's a million and one?
19:22:50 <sm> hackage is our prelude, what's the problem
19:25:04 <dsal> That particular package suggested another one that was better maintained.  That one it recommends is deprecated.
19:40:53 <koz_> dsal: Yeah... that package is not good.
19:40:56 <koz_> Like, at all.
19:41:02 <koz_> Speaking as someone who has battle scars from it.
19:49:29 <ddellacosta> is StateT used a lot in Haskell production code?
19:49:40 <koz_> ddellacosta: I'm using it a lot, and I'm writing production code.
19:50:03 <ddellacosta> koz_: do you tend to use a big "god object" as dmwit mentioned above, or do you somehow compose StateT instances?
19:50:06 <Axman6> I've never had a need for it for anything other than testing
19:50:39 <ddellacosta> Axman6: for managing mutable state, do you use like a IORef in ReaderT or something?
19:50:40 <dsal> debugloop: I've used it a couple times.  The last time, I kind of wish I didn't.
19:51:09 <koz_> ddellacosta: The former, with microlens assistance.
19:51:15 <Axman6> mutable state goes in databases
19:51:20 <dsal> I kind of want to know what this microlens stuff is all about.
19:51:20 <ddellacosta> koz_: gotcha, thanks
19:51:33 <koz_> dsal: It's basically 'lens but without half of Hackage as deps'.
19:51:38 <koz_> (although it lacks some features)
19:51:43 <koz_> I believe it depends only on base.
19:51:45 <dsal> Yeah, I've used it before... but not with StateT
19:51:54 <dsal> We casually use it at work some.
19:51:55 <koz_> dsal: Check out microlens-mtl.
19:52:03 <koz_> You may be pleasantly surprised.
19:52:08 <ddellacosta> Axman6: yeah was just curious, as I think I've heard the fpcomplete people (or maybe just Michael Snoyman?) suggesting that approach
19:52:48 <dsal> StateT complicates a few things unpleasantly.
19:52:49 <ddellacosta> Axman6: so, then, where do you hold your database handles? :-p
19:53:06 <dsal> You can't(*) unliftIO it, for example.
19:53:28 <dsal> DB Connection in a Reader is conceptually different.
19:53:45 <dsal> e.g., unliftIO is meaningful there.  :)
19:55:06 * ddellacosta goes to re-read the blog post on unliftio, because he doesn't write production Haskell code and promptly forgets things after learning about them
19:57:24 <ddellacosta> huh, so I kinda get it, it seems to be about making mtl-style work in situations it may not ordinarily
19:57:35 <dsal> It doesn't come up every time I write code, but, e.g., I do this a lot:   `mapConcurrentlyLimited :: (MonadMask m, MonadUnliftIO m, Traversable f, Foldable f) => Int -> (a -> m b) -> f a -> m (f b)`
19:58:06 <dsal> Yeah.  I want to spawn a few threads and do a bunch of stuff concurrently, but I want to keep my monad stack.
19:58:29 <ddellacosta> dsal: gotcha, thanks for the explanation
20:00:52 <dsal> I was going to pull up a simple example, but my examples require you to know what I'm doing.
20:01:45 <dsal> I'm using it all over this project because I'm working with a remote API, syncing local state to an upstream service.
20:29:11 <sm> reddit says optics is about as light as microlens but closer to lens in power, now
20:29:32 <koz_> sm: Interesting.
20:29:50 <koz_> This here optics? http://hackage.haskell.org/package/optics
20:30:05 <sm> yup
20:30:30 <koz_> Hmm, they dodge the profunctor bullet nicely.
20:30:43 <sm> discussed in https://www.reddit.com/r/haskell/comments/fvzvdp/blog_wide_haskell_reducing_your_dependencies/
20:31:09 * sm wonders what's the profunctor bullet
20:31:26 <koz_> sm: profunctors is a big dep.
20:31:30 <sm> ah
20:31:45 <koz_> And it's largely responsible for why lens is so big-large-huge and why microlens won't support Prisms or Isos properly.
20:32:00 <koz_> Although you've given me something very worthwhile thinking and asking my team about.
20:32:04 <ddellacosta> dsal: fwiw I'd still be interested, the more "real" Haskell code I can read the better
20:32:51 <dsal> ddellacosta: Well, most of my code lately has been in github.com/dustin/gopro (and gopro-plus).  I've reverse engineered most of the GoPro Plus service and built my own junk to interact with their cloud.
20:32:58 <ddellacosta> wow cool!
20:33:08 <ddellacosta> thanks, I'll definitely check it out
20:33:15 <dsal> The code is not meant to impress people.  Mainly just give me a more usable interface than they do.  :)
20:33:43 <dsal> e.g., I can rsync video over a slow unreliable link and upload it from the commandline somewhere that will more likely succeed on the first try.  And like, browse my stuff in meaningful ways.
20:34:17 <ddellacosta> that sounds like real code lol
20:34:18 <dsal> It's got a silly long dependency list.  I also wrote a parser for the metadata stream the cameras include in your video, for example.
20:34:42 <dsal> Current top of my web interface:  Showing 42 (2.12 GB) out of 2,162 items (907.67 GB).
20:35:06 <ddellacosta> actually this is awesome because this feels like a lot of "wiring up," which I feel is a neglected topic in Haskell blog-land
20:35:41 <dsal> I've wired up hackage here. heh
20:36:01 <ddellacosta> ha
20:36:37 <dsal> Over the weekend, I built a thing that uses Amazon SQS to backup all my video from GoPro to my own S3 bucket via AWS Lambda.
20:36:50 <dsal> I didn't write that little bit in Haskell, though, for dumb reasons.  :(
20:37:01 <ddellacosta> also this is the first time I've read SQLite code in Haskell
20:37:28 <dsal> It's not meant to be amazing.
20:37:35 <ddellacosta> oh I'm not judging
20:37:56 <ddellacosta> more like, "I'm seeing a lot of this for the first time, this is awesome"
20:38:28 <dsal> But as a practical example, this loads a list of all known IDs from sqlite, sees which ones I've got in in S3, and then, at a given concurrency, asks for temporarily signed URLs from GoPro and then sends those to SQS to tell Amazon to copy them into S3:  https://github.com/dustin/gopro/blob/master/src/GoPro/Commands/Backup.hs#L62
20:39:04 <dsal> Oh, this is super gross, because it's using positional parameters, too.  :(  But it was a prototype.  My first time using Lambda or SQS.
20:40:58 <dsal> This is, perhaps a bit less gross.  Does a query to compare the current media moment counts against the number of moments I've kept for each video, and then goes and fetches all of the moments from GP Plus with some concurrency, and then stores them in a single multi-update: https://github.com/dustin/gopro/blob/master/src/GoPro/Commands/Sync.hs#L61-L67
20:42:06 <dsal> That's part `sync` command I run after I (or my camera or whatever) upload some new stuff:  https://github.com/dustin/gopro/blob/master/app/Main.hs#L87
20:45:18 <dsal> This thing is a massive kitchen sink, though.  It's got a variety of commandline tools and a web server.
20:57:55 <ddellacosta> sorry had an interruption. Yeah I'm just happy now I can mention casually that I've seen a GoPro Monad 
20:58:13 <ddellacosta> no seriously thanks for sharing!
20:59:35 <dsal> haha.  You'll love my car automation, then:  http://hackage.haskell.org/package/tesla-0.1.0.1/docs/Tesla-Command-Alerts.html
21:00:17 <dsal> There's a long standing bug that describes why that isn't documented.   :(  The source code is nice, though:  https://github.com/dustin/tesla/blob/master/src/Tesla/Command/Alerts.hs
21:01:07 <ddellacosta> omg that's awesome
21:01:20 <ddellacosta> module Tesla.Command.Valet
21:01:28 <dsal> Yeah I can honk my car's horn via mqtt.  woo
21:01:39 <ddellacosta> it was only a matter of time
21:01:42 <koz_> dsal: Yep, I remember you posting about that.
21:01:49 <dsal>  You mocked my Car monad.
21:01:56 <ddellacosta> hahaha
21:02:13 * MarcelineVQ honks dsal's car horn via mqtt
21:03:19 <ddellacosta> you know, speaking of, doesn't Tesla use Haskell here and there?
21:03:30 <dsal> my mqtt stack was my hardest code to get right, though.  Getting that kind of stuff right is hard.   I've got a ton of apps that have been solid for a long time, though.
21:03:37 <dsal> Yeah, but I don't think I want to work for Tesla.
21:03:50 <ddellacosta> oh yeah not suggesting that, just curious
21:03:52 <dsal> I'll buy stock and cars and batteries and stuff...  That's about enough.
21:04:22 <ddellacosta> sounds like they work very long hours, from the people assembling cars to the C-level
21:04:47 <dsal> Yeah, I lived that life when I was younger.
21:04:59 <ddellacosta> no thanks
21:06:58 <dsal> This kind of code isn't as exciting, but you can do neat things with it.  I've got a program running in The Cloud that tracks my car's state and sends it to my mqtt server at home.  Another thing picks that up and extracts it into something Home Assistant can understand for state tracking.  That figures out which "area" my car is in.  If it's here, then that's a good reason to turn on my tea heater around 7 in the monrning
21:10:31 <dsal> Some really neat practical STM in here, though.  I've got a sync tool for fetching all the state from the cloud using an RPC over MQTT.  I built an RPC client that has to intercept some of the packets from the MQTT client based on some junk.  I atomically add and remove those handlers and run a couple hundred concurrent RPCs to pull any given day's state.
21:13:41 <dsal> It's kind of obvious if you're used to STM, but while the RPC client waits for the response, it's also monitoring the connection state, so I'm watching my own TChan in a callback I injected into the client, but also the client's connected state so I can abort my request if the connection drops.  The whole RPC client is here: https://github.com/dustin/net-mqtt-rpc/blob/master/src/Network/MQTT/RPC.hs
21:16:58 <sm[m]> sounds awesome.. how is it keeping all this up and running ?
21:17:53 <sm[m]> how is it for you I mean
21:18:17 <dsal> Just systemd here and there.
21:19:18 <dsal> I've got three or four bits I rely on heavily that are haskell.  An importer, exporter, bridge, monitoring thing.  I guess the tesladb thing, and probably some I've forgotten about.
21:27:52 * hackage net-mqtt-rpc 0.1.1.0 - Make RPC calls via an MQTT broker.  https://hackage.haskell.org/package/net-mqtt-rpc-0.1.1.0 (dustin)
23:01:53 <dsal> Eh, I had more constraints that I strictly needed.
23:02:51 * hackage net-mqtt-rpc 0.1.2.0 - Make RPC calls via an MQTT broker.  https://hackage.haskell.org/package/net-mqtt-rpc-0.1.2.0 (dustin)
23:49:37 <dsal> One downside of BlockArguments is that it breaks tools.
23:49:47 <dsal> But it saves so much money.
