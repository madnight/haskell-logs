01:17:45 <asheshambasta> is there a cabal equivalent of `stack build --fast`?
01:18:16 <Axman6> --disable-optimization?
01:19:00 <asheshambasta> ah yes, basically stack is also just disabling optimisations with --fast
01:43:37 <koz_> Axman6: Would -O0 also achieve this?
01:43:52 <Axman6> --ghc-options=-O0 probably would
01:44:03 <koz_> Axman6: Yeah, that one, lol.
02:00:49 <jchia_> Anyone familiar with ghc-pkg & hoogle around? I think I found a bug in how hoogle parses ghc-pkg output under GHC 8.8.3. Here is a gist of the dumps from the 8.2.2 vs 8.8.3. https://gist.github.com/jchia/cf4412d7402f7bfeb01324b9cd537986 Under 8.2.2, things are working but under 8.8.3, things are parsed wrongly. for example the package name is parsed with extra leading spaces and the haddock-html is parsed as just the empty string.
02:01:50 <jchia_> I couldn't find an issue for this on github. It's surprising because it seems like such a noticeable problem and 8.8.3 has been out for a while.
02:04:05 <jchia_> Basically, ghc-pkg-8.8.3 adds spaces and newlines to make things look nicer and hoogle parsing doesn't account for that. IDK whether it's ghc-pkg's fault for deviating from some standard or hoogle's fault for not adapting to the new formatting.
02:19:42 <phadej> Cabal has functions to parse InstalledPackageInfo, i bet hoogle isn't using this but uses some homebrewed approach
02:20:55 <phadej> In short, that format is defined by implementation (in Cabal), so not using that is "own fault"
02:22:08 <maerwald> @hoogle m (t a) -> (a -> m b) -> m (t b)
02:22:09 <lambdabot> No results found
02:23:19 <phadej> :t \xs f -> xs >>= traverse f
02:23:21 <lambdabot> (Monad m, Traversable t) => m (t a) -> (a -> m b) -> m (t b)
02:26:46 <dmj`> does anybody have a link for that java jargon generator website? They make you guess between fake vs. real java classes
02:30:47 <siraben> While experimenting with profunctor optics, I could implement set and modify, but anyone know how to implement view?
02:30:52 <siraben> https://github.com/siraben/fp-notes/blob/be946e7ef3de048e0cf7af8738a3d7502b83c69b/lens/ProfunctorOptics.hs#L238
02:32:45 * hackage ghc-check 0.3.0.1 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.3.0.1 (PepeIborra)
02:34:41 <koz_> siraben: What signature does view have?
02:34:50 <koz_> s/does/should/
02:35:09 <siraben> Something like view :: Lens' s a -> s -> a but more polymorphic?
02:35:59 <koz_> Well, can you write that less-polymorphic one?
02:37:04 <siraben> Well, I have something like view (Lens l) s = _
02:37:15 <siraben> http://ix.io/2jtc
02:37:36 <siraben> Seems like there's no way to get that a.
02:38:32 <siraben> The only thing avaliable is l :: forall (p :: * -> * -> *). Strong p => p a a -> p s s
02:39:16 <siraben> Perhaps I could use Proreader?
02:39:21 <siraben> s/Proreader/ProReader
02:39:27 <koz_> siraben: Try reading this? https://gist.github.com/phadej/c32503efd3274e83196d549eaae28a1a
02:39:32 <koz_> Might give you a clue.
02:40:43 <jchia_> phadej: Yes, they use their own string parsing
02:41:20 <jchia_> hoogle has no dependency on Cabal
02:41:44 <siraben> koz_: Thanks, will take a look.
02:43:11 <jchia_> phadej: Do you mean Cabal has functions for parsing ghc-pkg output? How does it maintain compatibility with different versions of GHC?
02:49:04 <siraben> koz_:  Wow, that really helped, now I have to go read about it all! http://ix.io/2jtg
02:52:48 <siraben> phadej:  Where can I find the missing SVGs?
02:53:42 <koz_> siraben: Noteworthy fact - Forget r ~ Star (Const r).
02:55:06 <koz_> % :info Star
02:55:06 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `Star'
02:55:39 <siraben> Forget looks just like Reader with a phantom type?
02:55:55 <siraben> Found the HTML version of phadej's gist; http://oleg.fi/gists/posts/2017-04-18-glassery.html
03:02:41 <boothead> Hi All - I keep having this with cabal (when being used in nix): newParallelJobControl: not a sensible number of jobs: 0. Seems to be related to the an empty config, but I can't find out a decent fix..
03:32:20 <boothead> So ^^ seemed to be a problem with lorri/direnv 
04:19:46 <juri_> is there a good function for showing a double precision, with up to 5 digits after the point?
04:20:03 <juri_> toFixed doesn't truncate following zeroes...
04:20:42 <juri_> I'm trying to output to ByteString.
04:20:51 <merijn> juri_: You probably want showFFloat or something from Numeric
04:21:03 <merijn> > showFFloat (Just 5) 0.974972974972979 ""
04:21:05 <lambdabot>  "0.97497"
04:21:32 <merijn> Although that also doesn't truncate following zeroes >.>
04:22:22 <juri_> also, that gives me String, not ByteString, i think..
04:23:51 <merijn> I find "encoding doubles as character strings into ByteString" highly suspicous. The former implies text, ByteString implies "not text"
04:26:25 <jchia_> I finally nailed a bug that's been bothering me for weeks. Under GHC 8.8.3, I couldn't generate local hoogle with haddock. It turned out to be a bug with hoogle that I just fixed.
04:26:45 <jchia_> Now I can upgrade to 8.8.3
04:31:11 <Uniaika> jchia_: hurray!
04:43:14 * hackage hw-balancedparens 0.4.0.0 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.4.0.0 (haskellworks)
04:46:39 <tomjaguarpaw> Has anyone noticed that TH's tupleT of a singleton seems to have changed from being a the type unchanged to being wrapped in Unit?
04:47:45 * hackage souffle-haskell 0.2.1 - Souffle Datalog bindings for Haskell  https://hackage.haskell.org/package/souffle-haskell-0.2.1 (luc_tielen)
04:48:57 <tomjaguarpaw> And why on earth is Unit called Unit?  () is already called "unit"!
04:51:12 <tomjaguarpaw> https://www.stackage.org/haddock/lts-13.21/ghc-prim-0.5.3/GHC-Tuple.html#t:Unit
04:51:14 <tomjaguarpaw> This is absurd
04:52:52 <hpc> it even calls () "the unit datatype" right above it lol
04:53:09 <hpc> it should have been named Identity
04:55:16 <tdammers> of course it wouldn't give you a ByteString - ByteString means "sequence of octet", not "sequence of characters" or "sequence of unicode codepoints"
04:55:33 <tdammers> but formatting a float as a string is by definition the latter
04:56:15 <siraben> Wow, what's with so many tuples in GHC.Tuple?
04:56:52 <tdammers> siraben: you mean the fact that Haskell doesn't provide a way to generalize over n-tuples, other than using TH or generics?
04:57:35 <siraben> I suppose, so they have to be hardcoded?
04:57:39 <tdammers> yes
04:57:55 <siraben> But also, who needs such large tuples?
04:58:04 <tdammers> gotta draw the line somewhere
04:58:04 <ski> % $(tupE [ [| 1 |] ])
04:58:05 <yahb> ski: ; <interactive>:129:1: error:; * No instance for (Show (Unit Integer)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
04:58:08 <tdammers> but where?
04:58:26 <tdammers> it would be nicer if tuples were conceptually type-level linked lists
04:58:48 <siraben> Right.
04:59:02 <tdammers> i.e., make (a, b, c) syntax sugar for Pair a (Pair b (Pair c Void)) or some such
04:59:19 <comerijn> tdammers: Then you'd use the nice direct indexing, though
04:59:32 <comerijn> Because that's just HList :p
04:59:37 <tdammers> right, yeah
04:59:42 <siraben> How is this approached in other functional languages?
05:00:09 <merijn> siraben: See the GHC base comment with "tuples limited to 62, if you need more than that we can probably fix the issue, but I can't be bothered" :p
05:00:09 <ski> in SML, tuples are just records whose field names are natural numbers
05:00:10 <siraben> Agda and Coq IIRC have them hardcoded as well.
05:00:31 <tomjaguarpaw> In strict languages an n+1-tuple can be a pair containing an n-tuple
05:00:33 <tdammers> https://github.com/purescript/purescript-tuples/blob/master/src/Data/Tuple.purs is how purescript does it
05:00:41 <siraben> Ah, what about referencing out of bounds?
05:00:51 <fendor> elixir's tuples are essentially lists but stores in contiguous memory
05:01:03 <merijn> siraben: Ah...beauty: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Tuple.html :)
05:01:13 <tdammers> the only other properly functional language I'm familiar with would be Elm, but I try to forget that it exists
05:01:34 <siraben> tdammers: Haha, what do you make of it?
05:01:35 <merijn> "{- Manuel says: Including one more declaration gives a segmentation fault."
05:01:57 <tdammers> siraben: make of what?
05:02:33 <siraben> Elm.
05:03:30 <siraben> Heh there should be some sort of data analysis looking into tuple length across Hackage, anyone seen 5+ in the wild?
05:03:45 <tdammers> I think it's a condescending shitshow; I'd recommend against using it in production, but I can see how it might have a place as a didactic vehicle for people who are afraid of the M word but want to dip their toes in FP regardless
05:04:37 <siraben> Ah I've heard of issues with how the maintainer handles development too.
05:06:08 <siraben> In any case, it's nice to have an accessible language to those getting started with FP.
05:17:53 <jackdk> I have a rule that has served me well: be very careful around organisations that operate under "here are the rules for you, and here are the rules for the Cool People"
05:18:04 <jackdk> I also don't like being condescended to by a compiler.
05:18:30 <tomjaguarpaw> hpc: I reported it https://gitlab.haskell.org/ghc/ghc/issues/18099
05:18:34 <tdammers> frankly, they lost me when I discovered that the compiler has rules that have zero technical reasons and are entirely down to social factors
05:18:46 <DigitalKiwi> jackdk: lol? but i heard the error messages are great!
05:19:13 <tdammers> for example, each package must have a github URL. if it's not a github URL, then the compiler will reject your program.
05:19:26 <jackdk> DigitalKiwi: I am not sure whether you are being serious
05:20:28 <tdammers> not because the github URL is actually necessary to compile the program, but because the author thinks that all packages should be on github. the compiler doesn't actually use that URL, it just checks whether it's there, and if it's not, or doesn't contain the word "github", then it aborts
05:20:55 <jackdk> DigitalKiwi: People complain that GHC's error messages obscure the thing you need to read in a pile of technical babble. Burying the thing you need to read in a pile of prose is no better
05:21:00 <siraben> tdammers: wow, that's crazy.
05:21:25 <tdammers> yes, and I don't want to depend on the work of crazy people
05:21:42 <DigitalKiwi> ffi for me not for thee
05:21:47 <siraben> Vendor lock with github as well? Huh.
05:21:57 <tdammers> that too
05:22:07 <tdammers> but you don't actually have to put your code on github, mind you
05:22:13 <tdammers> you can put a fake github URL there
05:22:22 <tdammers> basically, you can lie to the compiler, and it'll work
05:22:27 <phadej> siraben: cabal-imstall uses 5+ tuples
05:23:01 <siraben> Oh hey phadej, I was reading your glassery post, very well written!
05:23:19 <phadej> it maybe shouldn't, as there aren't nice setting syntax
05:23:27 <siraben> Ah, do you know where?
05:23:40 <DigitalKiwi> https://www.reddit.com/r/haskell/comments/fy848b/why_im_leaving_elm/
05:23:42 <phadej> siraben: don't confuse "well written" with "long text" ;)
05:23:45 <siraben> Why use large tuples when records/data would do as well?
05:24:23 <siraben> Haha, well, so far looks like a more readable version of the profunctor optics paper.
05:24:53 <tdammers> re elm error messages: they're great, until the compiler second-guesses you wrong, then they are terrible
05:25:12 <DigitalKiwi> jackdk: i've never seen their error messages but that's one of the things that people say is elm has good error messages (of course from the rest of what i know about it i have reason to doubt the sincerity of that...)
05:25:22 <tdammers> DigitalKiwi: ^
05:25:41 <phadej> siraben: there is (FooFlags, BarFlags, QuuFlags, ...) collection of arguments
05:25:54 <tdammers> the problem with Elm's error messages is they don't tell you what went wrong, they skip right to suggesting a solution
05:26:05 <phadej> siraben: making record for possible combinations is boilerplate as well
05:26:13 <tdammers> when that solution is correct, then it's great, but when it's not, you have to reverse-engineer the compiler's guesswork
05:26:15 * hackage base-encoding 0.2.0.0 - Binary-to-text encodings (e.g. base64)  https://hackage.haskell.org/package/base-encoding-0.2.0.0 (HerbertValerioRiedel)
05:26:31 <merijn> tdammers: Story of my live :p
05:26:49 <siraben> phadej: That's true.
05:27:09 <siraben> Do people into into 5-tuples then, or pattern match?
05:27:24 <siraben> s/into/index
05:28:00 <merijn> siraben: You can't index into tuples (well, lens can up to a point, I think)
05:28:16 <siraben> Right, that I know.
05:29:11 <tdammers> lens can do it by wrapping pattern matches into typeclass methods
05:29:54 <merijn> I thought it was because edwardk sold his soul to the devil? :p
05:34:26 <zincy_> 1:27
05:34:26 <zincy_> Am I correct in thinking that if I have to keep looking at how a library is implemented internally when I am consuming it then the library has bad abstractions?
05:36:13 <juri_> grr. so far, the best i've come up with is Data.Double.Conversion.ByteString's toFixed.
05:37:03 <juri_> and then i'm going to have to strip off the following zeroes manually.
05:37:57 <tdammers> I wonder why my sqlite database is deadlocking
05:39:06 <frdg> im using checkers and my tests are extremely slow. Here is what I'm doing. I open my repl with `cabal repl`. I load my file. then in my repl I say: `xs = [("b","w",1)]` then `quickBatch $ applicative xs` it is able to test identity relatively fast (still slow though) then it just can't test composition and I have to quit my repl. 
05:40:41 <frdg> if I do `quickBatch $ monoid xs` it takes about 30 seconds to complete the test
05:41:56 <frdg> I also tried restarting my computer and nothing changed
05:45:49 <merijn> tdammers: Define deadlocking?
05:46:03 <merijn> tdammers: Also, how are you interacting with it?
05:46:16 <tdammers> ah, I don't actually know it's deadlocking. all I'm seeing is an indefinite blocking behavior when I try to insert something
05:46:27 <tdammers> sqlite-simple, using an in-memory database
05:46:41 <merijn> tdammers: Sounds like they might have said a dumb busy timeout?
05:47:08 <tdammers> not sure. I suspect something doesn't get closed
05:47:39 <merijn> tdammers: Also, which concurrency/threading mode is the database opened in?
05:48:12 <tdammers> hmm, I don't know actually. I'm basically just saying open ":memory:" to create the DB
05:48:19 <tdammers> and then I pass the resulting handle around
05:49:16 <merijn> You can check the output of "PRAGMA busy_timeout;"
05:49:48 <tdammers> that says 0
05:49:58 <merijn> Could also be an issue with filelocking (NFS by any chance?)
05:50:09 <tdammers> plain old ext3
05:50:31 <merijn> Oh wait, it's in memory, that doesn't apply >.>
05:50:40 <tdammers> I see the same behavior with a local file btw
05:50:52 <tdammers> but yeah, it can't be file locks when it also happens in-memory
05:51:14 <tdammers> my suspicion is that somehow something doesn't get closed, and then the insert waits forever
05:51:44 * hackage product-profunctors 0.10.0.1 - product-profunctors  https://hackage.haskell.org/package/product-profunctors-0.10.0.1 (tomjaguarpaw)
05:51:48 <merijn> tdammers: That should produce a busy timeout error, though
05:51:56 <tdammers> right. but it doesn't.
05:52:01 <tdammers> so that's weird
05:52:09 <merijn> Oh, unless sqlite-simple is silently hiding those and rerunning the command :)
05:52:39 <tdammers> oh dear
05:53:32 <hpc> that doesn't sound simple at all!
05:53:39 <merijn> I'm just guessing here :)
05:54:26 <hpc> (i mean, if that's the case then the name sqlite-simple is a misnomer :P)
05:56:16 <maerwald> I wish regex-posix could tell me at compile-time whether my regex is valid. At least the parts that don't have variable input.
05:56:30 <frdg> is it common for a library to be slow when using its functions in a `cabal repl` ? I do not have the library installed, it is included in my build-depends.
05:56:59 <merijn> maerwald: It has a function "Text -> Maybe Regex" or something along those lines?
05:57:40 <tdammers> my suspicion is that it's to do with laziness
05:57:44 <maerwald> merijn: I don't know of any
05:58:06 <tdammers> I'm inserting a session, which includes a userID, and that userID comes from a User record I've just fetched from the DB
05:58:23 <merijn> maerwald: ah, I though you meant "at source compile time", but you mean "at regex compile time"
05:59:09 <maerwald> merijn: no, I mean I would like to have some quasi quoter that at least partially proves my regex is correct
05:59:17 <maerwald> for the input parts it could just assume it's "aaa" or whatever
05:59:43 <merijn> maerwald: Well, you need something that can do it at regex compile time before you can do it at source compile time :p
06:00:12 <maerwald> I'm already regretting using regex, but parser combinator seems useless overkill
06:00:28 <maerwald> for matching filenames
06:02:01 <tdammers> is there a "regex-qq" or something of the sort?
06:02:13 <tdammers> I reckon it'd be a terrible chore to implement, but fundamentally possible
06:02:16 <[exa]> wasn't there a tiny DSL for basically writing the regex-like stuff in normal expressions?
06:02:37 <merijn> tdammers: If you have any check I've already got a package for doing that :p
06:02:39 <solonarv> regex-applicative ?
06:02:52 <merijn> tdammers: So you just need "String -> Maybe Regex" :p
06:03:45 * hackage haskoin-store 0.22.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.22.3 (jprupp)
06:03:54 <merijn> https://hackage.haskell.org/package/validated-literals the ergonomics of the API could use some work, but figuring out what works requires more people try and use it and run into problems :p
06:04:08 <tdammers> merijn: https://hackage.haskell.org/package/regex-tdfa-1.3.1.0/docs/Text-Regex-TDFA-ReadRegex.html looks close
06:07:19 <solonarv> huh, I wonder why lift doesn't have a method with type 'a -> Q (TExp a)'
06:08:38 <maerwald> https://hackage.haskell.org/package/rex-0.6.1/docs/Text-Regex-PCRE-Rex.html
06:10:31 <maerwald> you can use it as a argument pattern matcher
06:10:33 <maerwald> lol
06:11:43 <merijn> solonarv: It predates typed TH
06:12:48 <solonarv> I know that, but I'm surprised it wasn't added yet
06:13:41 <maerwald> hm, also can't find a function that escapes input text
06:14:08 <merijn> solonarv: You can just use splice syntax?
06:15:25 <zincy__> Can someone jog my memory on that what Cofree does?
06:15:26 <jophish> I wrote this small utility, but really have the feeling that it's been done before: https://github.com/expipiplus1/autoapply
06:15:30 <solonarv> % let liftTExp :: a -> Q (TExp a); liftTExp x = [|| x ||]
06:15:31 <yahb> solonarv: ; <interactive>:130:51: error:; * No instance for (Language.Haskell.TH.Syntax.Lift a) arising from a use of `x'; * In the Template Haskell quotation [|| x ||]; In the expression: [|| x ||]; In an equation for `liftTExp': liftTExp x = [|| x ||]
06:15:43 <jophish> It feels quite similar to a crappy proof assistant 
06:15:45 <solonarv> oh huh, so that just needs a Lift instance
06:15:54 <solonarv> never mind me, I guess
06:16:04 <zincy__> The class has a method called unwrap. Is this just for deciding how an effectful query is done which peels a layer of a tree of functors?
06:18:03 <solonarv> zincy__: I'd recommend looking at the Cofree data type and comparing it to the ComonadCofree class (I think that's what it is called)
06:18:30 <solonarv> 'Cofree f a' is indeed a tree of sorts, with an 'a' at every node and 'f'-shaped fanout
06:28:14 * hackage opaleye 0.6.7004.2 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.6.7004.2 (tomjaguarpaw)
06:30:26 <zincy__> solonarv: Yeah the functor controls the fanning behaviour
06:31:29 <zincy__> Does the data type control branching and the class control the collapsing - evaluation?
06:38:45 * hackage binaryen 0.0.1.0 - Haskell bindings to binaryen  https://hackage.haskell.org/package/binaryen-0.0.1.0 (terrorjack)
06:48:14 * hackage barbies 2.0.1.0 - Classes for working with types that can change clothes.  https://hackage.haskell.org/package/barbies-2.0.1.0 (DanielGorin)
07:03:45 <solonarv> zincy__: no, the class just generalizes 'unwrap' to more datatypes that look sort of like Cofree
07:03:54 <solonarv> instead of being restricted to just exactly Cofree
07:04:15 * hackage haskoin-store 0.22.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.22.4 (jprupp)
07:04:16 <solonarv> for Cofree you have 'unwrap (_ :< branches) = branches
07:08:06 <zincy__> solonarv: Ah thanks!
07:08:37 <zincy__> I am looking at warp and am confused about how http requests relate to a TCP socket connection
07:08:56 <zincy__> So when you run a warp server it binds a port to a socket
07:09:38 <zincy__> When the socket is open then http requests come in as messages in that system level socket
07:09:59 <zincy__> Now the bit I am confused about is I am seeing there can be multiple connections?
07:10:37 <zincy__> ugh maybe I just need to read a book on systems programming
07:11:52 <solonarv> you skipped a step there.
07:12:16 <solonarv> your server program binds to a socket (which is a combination of host + port).
07:12:51 <solonarv> clients try to connect to that socket. when such a request comes in, the server accepts the connection
07:13:01 <solonarv> only then do you have a connection
07:13:11 <solonarv> (and the server might keep listening for more connections)
07:15:03 <zincy__> So at the OS level you have a socket which can have many connections to the port, then at the application level on the other side of the socket you have warp.
07:15:42 <zincy__> Warp uses this single socket connection to deal with all the reqs/resps
07:24:33 <tdammers> I don't think it does
07:24:55 <tdammers> I'm pretty sure it opens one socket for listening, but accepts many connections on that listening socket
07:25:08 <solonarv> yes, exactly
07:25:18 <solonarv> manpages actually explain this too!
07:25:19 <tdammers> the way this is typically written doesn't make that obvious though
07:26:01 <solonarv> quote from the listen(2) manpage: to accept connections, the following steps are performed:
07:26:08 <solonarv> 1. a socket is created with socket(2)
07:26:28 <solonarv> 2. the socket is bound to a local address using bind(2), so that other sockets may be connect(2)ed to it
07:26:48 <solonarv> 3. a willingness to accept incoming connections and a queue limit for incoming connections are specified with listen()
07:26:58 <solonarv> 4. connections are accepted with accept(2)
07:30:06 <thyr15t0r> hello Haskell gods! I study the languige using WinGHCi.  import System.Random returns error could not find module. How to?
07:31:28 <maerwald> is WinGHCI still maintained?
07:32:19 <maerwald> you need the package 'random', with cabal you would do: cabal repl --build-depends random
07:32:19 <[exa]> thyr15t0r: what version?
07:33:27 <thyr15t0r> last
07:33:43 <thyr15t0r> 8.6.5
07:35:04 <solonarv> that's *not* the latest version
07:35:31 <solonarv> the latest version is 8.10.1 (but 8.6.5 is not horribly outdated yet, so you don't have to upgrade right away. just something to be aware of)
07:36:17 <maerwald> 8.10.1 isn't usable yet
07:36:25 <thyr15t0r> <maerwald>  unrecognized repl option  --build-depends
07:36:37 <maerwald> thyr15t0r: your cabal is outdated then
07:36:47 <maerwald> how did you install ghc and cabal?
07:37:32 <solonarv> hm, IIRC at the time 8.6.5 was released cabal 3.0 was not out yet. so probably thyr15t0r has cabal 2.4
07:38:07 <solonarv> thyr15t0r: but do answer maerwald 's question.
07:38:09 <thyr15t0r> <maerwald> i got it from site haskell.org. 
07:38:42 <thyr15t0r> cabal was installed with compiler
07:38:50 <maerwald> Afair, the recommended way to install GHC and cabal on windows is using 'chocolatey'
07:38:56 <maerwald> https://chocolatey.org/packages/ghc/8.8.3
07:39:00 <maerwald> https://chocolatey.org/packages/cabal
07:39:03 <thyr15t0r> i just run exe installer
07:40:09 <solonarv> the Haskell Platform installer? that's not even available anymore past 8.6, hah
07:40:13 <thyr15t0r> is random in the 8.8.3 version only?
07:40:36 <solonarv> no, random doesn't come with the platform IIRC
07:40:51 <solonarv> oh it does, I read too quickly
07:41:25 <solonarv> ah! once again I read too quickly! it comes with the "full" platform (which no longer exists / isn't recommended), but not with the "core" platform
07:42:54 <solonarv> the official recommendation is to use chocolatey to install cabal & ghc: https://www.haskell.org/platform/windows.html
07:43:07 <thyr15t0r> thank you
07:43:47 <thyr15t0r> will random come with chocolatey installation?
07:44:03 <maerwald> thyr15t0r: no, but you will be able to use cabal as I explained above
07:44:11 <maerwald> which is easy and convenient
07:44:13 <thyr15t0r> good
07:44:31 <solonarv> No. the "core" platform (which is what's installed by chocolatey) contains only the compiler, and packages which the compiler itself uses.
07:45:07 <solonarv> installing libraries by saying "sometool install somelibrary" is how you eventually get into a big old mess where nothing works anymore
07:47:10 <thyr15t0r> why haskell upates so quickly? few years old languige and modern are two different languiges
07:47:55 <thyr15t0r> it is rhetorical question
07:48:37 <maerwald> "few years old languige and modern are two different languiges" -- what does that mean?
07:49:44 <thyr15t0r> most modules are not working in the latest version
07:51:41 <solonarv> there is not one monolithic "haskell language" that evolves at a given speed, many things come from libraries rather than being bundled with the standard library or compiler
07:52:28 <solonarv> on top of that, it is true that there are occasional breaking changes; this is partly fixing old mistakes, and partly because Haskell is also a research language
07:53:32 <maerwald> most of the new changes to GHC are not due to "research", but because someone at some big company wants to optimise some of their code :P
07:53:33 <thyr15t0r> research of what?
07:53:54 <maerwald> ApplicativeDo for example
07:54:04 <maerwald> Wasn't particularly "research", or most other plugins
07:54:24 <maerwald> I would say it isn't really a research language anymore
07:54:55 <maerwald> F* is a research language
07:55:28 <[exa]> which one of the big companies are you referring to btw? :]
07:55:49 <merijn> [exa]: Facebook, in case of ApplicativeDo
07:57:23 <maerwald> linear types and dependent haskell also are mostly, because people already have ideas what to do with it in production
07:58:07 <maerwald> a research language would be more radical about changing it's semantics, syntax and scope
07:58:46 * [exa] activates the inner revolutionary: Foorrrkkk!!111
07:59:14 <[exa]> anyway, I thought that ApplicativeDo was in the long-term plan for quite some time, wasn't it?
07:59:27 <maerwald> Dunno, have you used it? It's quite confusing at first
07:59:36 <maerwald> Can't see myself using it, really
07:59:52 <maerwald> And the compile errors are confusing too
08:02:04 <[exa]> reading the spec, I obvously remembered a completely different ApplicativeDo from quite some time ago
08:02:52 <maerwald> monochrom: I went through your "lazy evaluation" slides and I can't but wonder why it's so verbose. Like, you're not trusting the reader.
08:04:18 <maerwald> Is this about liability? ;P
08:04:42 <merijn> maerwald: Have you ever taught a class?
08:04:50 <maerwald> Yes
08:04:58 <maerwald> Multiple times
08:05:02 <maerwald> Usually, they were sleeping.
08:05:05 <maerwald> :D
08:05:32 <merijn> maerwald: Then you should know why it's so verbose >.> If you don't spell out every details *someone* will get confused
08:06:17 <maerwald> merijn: well... if you spell out every detail they will stop following and fall asleep. If you don't, they won't be able to follow and fall asleep.
08:06:19 <maerwald> Pick one
08:07:46 <maerwald> I like tense heads-up postulates and then optional detailed examples. That also saves me from writing up my own summary.
08:07:52 <maerwald> *dense
08:08:31 <maerwald> But yeah, this is a never ending topic
08:09:34 <maerwald> I found the section about evaulation order for functions with multiple arguments and guard useful
08:09:46 <maerwald> But it was buried between multiple examples
08:13:15 * hackage haskoin-store 0.22.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.22.5 (jprupp)
08:14:56 <maerwald> and a little surprised it didn't mention WHNF/NF
08:16:18 <tomjaguarpaw> Why is cabal trying to configure a package when its .cabal file is in a subdirectory of the one I run it in?
08:16:50 <maerwald> tomjaguarpaw: is there a cabal.project file?
08:17:30 <tomjaguarpaw> No
08:18:08 <tomjaguarpaw> I have opaleye.cabal in this directory, and opaleye-sqlite/opaleye-sqlite.cabal
08:18:44 <tomjaguarpaw> It claims "opaleye-sqlite" is a user goal, even though I haven't asked for it.  And this only happens with 8.6.5, not 8.4.4, so I'm jolly confused.
08:19:15 <maerwald> ghc version should have nothing to do with it, only cabal version
08:19:41 <tomjaguarpaw> Well I get this divergent behaviour with the same cabal, different GHCs
08:19:57 <tomjaguarpaw> 3.0.0.0, for the record
08:20:22 <maerwald> tried 3.2.0.0?
08:20:24 <maerwald> Maybe a bug
08:20:51 <maerwald> unless
08:21:07 <maerwald> do you have environment files in ~/.ghc?
08:22:21 <tomjaguarpaw> Ah, on a fresh checkout it fails with 8.4.4 as well.
08:22:57 <maerwald> the environment files are ghc-version dependent
08:23:12 <tomjaguarpaw> I don't have environment files
08:23:45 <thyr15t0r> hello again
08:24:00 <tomjaguarpaw> Hmm, no even with a fresh checkout it's still divergent.
08:24:05 <tomjaguarpaw> This is such a sorry state of affairs.
08:24:23 <thyr15t0r> i installed random into my ancient version. just did cabal update and cabal install random
08:24:26 <maerwald> tomjaguarpaw: so ~/.ghc is empty, except for ghci_history?
08:25:31 <tomjaguarpaw> It's got various package.conf.ds in it
08:25:51 <maerwald> If it has something like ~/.ghc/x86_64-linux-8.6.5/environments/default
08:25:56 <maerwald> then that might be a problem
08:26:00 <tomjaguarpaw> It hasn't
08:26:42 <tomjaguarpaw> I'm so confused.
08:27:32 <tomjaguarpaw> This is bizarre
08:29:51 <tomjaguarpaw> Same with cabal-install 3.2.0.0 that I just got via ghcup
08:31:41 <asheshambasta> is there something in Haskell-Mode (emacs) that overwrites files as we type or after a timeout:?
08:33:23 <tomjaguarpaw> I believe flycheck does something like this
08:33:41 <tomjaguarpaw> I can't quite remember, but some component does.  Why do you ask?
08:33:51 <maerwald> tomjaguarpaw: for me, it also wants opaleye-sqlite
08:34:15 <tomjaguarpaw> Ah thanks for checking.  Do you understand what's going on?
08:34:26 <asheshambasta> tomjaguarpaw: I've been disabling modes one by one, let me see if its flycheck.
08:34:45 * hackage box-tuples 0.2.0.3 - A hack to use GHC.Prim primitives in GHCi  https://hackage.haskell.org/package/box-tuples-0.2.0.3 (mniip)
08:34:56 <maerwald> tomjaguarpaw: apparently cabal looks into subdirectories? :)
08:34:59 <maerwald> rm -rf it and it's fine
08:35:38 <asheshambasta> nope, this is not flycheck
08:35:46 <tomjaguarpaw> But not with GHC 8.4.4?
08:36:17 <tomjaguarpaw> So does #hackage require registration to join?
08:37:30 <stevenxl> Hi folks. I am trying to use the cryptonite package. That package defines a typeclass called ByteAccessArray, and according to the docs, there is an instance of ByteAccessArray for the String data type - please see here: https://www.stackage.org/haddock/lts-14.7/memory-0.14.18/Data-ByteArray.html#t:ByteArrayAccess
08:38:03 * stevenxl However, when I try to use the "hashWith" function with a string, it says that String is not an instance of ByteArrayAccess.
08:39:14 <merijn> stevenxl: In that version, yes
08:39:35 <merijn> Are you sure you're using 0.14.18 or later?
08:40:25 <stevenxl> merijn:  Hi! When I run the command "stack ls dependencies | grep -i crypto" I get "cryptonite 0.25".
08:40:42 * stevenxl which are the docs that I am reading. (I am on lts-14.7 of the stackage resolver).
08:40:53 <merijn> stevenxl: cryptonite isn't the package, memory is
08:41:55 * stevenxl merijn: Yup - my fault. stack reports memory as "memory 0.14.18", and that's also the version listed in the resolver I am using. https://www.stackage.org/lts-14.7.
08:42:18 <stevenxl> When i look at the memory source code, there seems to be some "if statements" that I am not familiar with.
08:42:40 <stevenxl> https://www.stackage.org/haddock/lts-14.7/memory-0.14.18/src/Data.ByteArray.Types.html#ByteArrayAccess
08:42:53 <stevenxl> "#ifdef WITH_BASEMENT_SUPPORT"
08:43:12 * stevenxl I think I have to somehow tell my system to compile the memory package with basement support. I am not sure how to do that.
08:43:33 <stevenxl> I think I have to somehow tell my system to compile the memory package with basement support. I am not sure how to do that.
08:45:02 * stevenxl Maybe the fact that I have to contort myself to get the instance for String for ByteArrayAccess is a strong indication I shouldn't do it.
08:45:07 <stevenxl> Maybe the fact that I have to contort myself to get the instance for String for ByteArrayAccess is a strong indication I shouldn't do it.
08:46:03 <pavonia> Are you posting messages twice, or am I drunk again? :o
08:46:59 * ski calls the `/me' police
08:47:09 <stevenxl> pavonia: The former. I am having trouble using IRC because my IRC client and Slack use the same shortcuts for different things.
08:47:11 <stevenxl> Sorry.
08:47:34 <ski> oh, okay
08:48:03 <tomjaguarpaw> maerwald: Posted an issue for it https://github.com/haskell/cabal/issues/6739
08:48:05 <maerwald> I wish we had a pure re-implementation of curl in haskell
08:48:51 <maerwald> I wrote a naive one for http/https, but https bears so many things to care about.
08:49:31 <zincy__> Yeah there are so many details to TLS
08:50:07 <maerwald> tomjaguarpaw: I can confirm it doesn't happen with 8.4.4
08:53:11 <tomjaguarpaw> maerwald: Thanks. The --verbose output is subtely different too. I can't understand what's happeneing.
08:53:41 <maerwald> I would give up and watch netflix instead
08:54:37 <ja> there will be a haskell videochat about effect systems at 17:00 utc: https://funprog.zulipchat.com/#narrow/stream/234801-VideoChat
08:55:12 <peutri> (an hour from now)
09:10:31 <mpickering> If I want a version of `race` which doesn't kill the loser, do I use `waitEither`?
09:17:44 * hackage i3blocks-hs-contrib 2.1.0 - Base i3blocks written in haskell  https://hackage.haskell.org/package/i3blocks-hs-contrib-2.1.0 (panavtec)
09:18:09 <monochrom> yes I think so
09:31:41 <peutri> spontaneously I'd reach for concurrently, but I suppose it depends on what you want to do with res result
09:32:01 <peutri> oh but you also want early return
09:32:09 <peutri> nevermind
09:44:01 <tomjaguarpaw> maerwald: Thanks for chiming in on the ticket.
09:44:11 <maerwald> tomjaguarpaw: I can provide a PR to fix
09:44:13 <maerwald> or are you on it?
09:48:28 <srid> Has anyone had to deal with the near-impossibility of writing COMPLETE pragmas for polymorphic pattern synonyms? My problem is described here: https://discourse.haskell.org/t/writing-complete-pragma-for-polymorphic-pattern-synonyms/1198
09:49:41 <tomjaguarpaw> maerwald: I don't have any idea how to fix it and I don't really understand what's required
09:49:47 <maerwald> I already fixed it
09:49:54 <tomjaguarpaw> maerwald++
09:51:15 * hackage hint 0.9.0.3 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.9.0.3 (gelisam)
09:53:45 * hackage co-log-concurrent 0.5.0.0 - Asynchronous backend for co-log library  https://hackage.haskell.org/package/co-log-concurrent-0.5.0.0 (AlexanderVershilov)
10:08:56 <dsal> It's annoying that every project requires me to write 'nix:\n  packages: [zlib]' into my stack.yaml.  I don't know whose bug that is, but it's pretty annoying.
10:10:15 <dsal> It's either every project's problem, or I add it in ~/.stack/config.yaml and it's every user's problem.
10:24:30 <Orbstheorem> Hi o/. Say I have the following code: https://paste.gnugen.ch/raw/25dB will GHC shortcircuit its evaluation if the length of the argument is too small to match anything than the base case or will it effectively execute multiple times until reducing to the base case?
10:26:50 <dsal> I'm not sure I understand the question.  It's not a shortcircuit.  The definition says [] is Nothing, so if the argument is too small, it returns Nothing for that match.
10:27:07 <dsal> Did you try it?
10:27:14 <maerwald> Orbstheorem: read https://www.vex.net/~trebla/haskell/lazy.xhtml :P
10:28:35 <monochrom> That's a very long hammer for this :)
10:28:36 <dsal> Orbstheorem: It'd be *slightly* less confusing if you used "" for an empty string instead of []
10:28:59 <maerwald> @info String
10:29:00 <lambdabot> String
10:29:07 <maerwald> @src String
10:29:07 <lambdabot> type String = [Char]
10:29:13 <monochrom> No, I think "too small to match anything than the base case" is the confusing one.
10:29:17 <Orbstheorem> If I run `foo "on"` we can statically infer that any list of length <3 cannot match "foo" nor "bar", so instead of going to the tail case and running `foo "n" ` and ultimately `foo "" `
10:29:36 <monochrom> Like a poet going out of their way to look for a way to avoid saying "the empty string".
10:29:43 <dsal> Orbstheorem: You could write that code, but it'd be more expensive, I think.
10:29:45 <maerwald> Orbstheorem: no, it isn't that smart
10:30:02 <solonarv> I wouldn't exactly call that behavior "smart".
10:30:02 <maerwald> you can do that with guards
10:30:34 <solonarv> remember, [] is a linked list, not an array - and getting the length is *slow*, you have to walk through the entire list counting up one by one!
10:30:42 <monochrom> But "on" is not statically known.
10:30:44 <dsal> `foo s | length s < 3 = Nothing` -- but that's not going to be cheaper than what you're doing since it has to traverse the list a lot.
10:31:12 <solonarv> so using the string's length to skip over the first few patterns is actually not a win at all.
10:31:34 <Orbstheorem> Ha, okay
10:31:45 <Orbstheorem> Thank you! 
10:31:53 <maerwald> use Text or ByteString, then you get len in O(1)
10:32:08 <maerwald> Err, Text
10:32:10 <Orbstheorem> How about Text? 
10:32:22 <dsal> You can also match the end faster than recursing a character at a time.  :)
10:32:25 <monochrom> Yeah please never mention ByteString :)
10:32:42 <dsal> It's a string, it contains bytes.  What could go wrong?
10:32:55 <Orbstheorem> Unicode I guess :P
10:32:55 <maerwald> Actuall, text isn't O(1)
10:33:18 <maerwald> That's a bit surprising though
10:33:33 <Orbstheorem> So Text is O(n)? 
10:33:40 <maerwald> Yes, ByteString is O(1) only
10:33:44 <tdammers> except that Text.length is pretty much useless
10:33:45 <monochrom> because UTF-16
10:33:57 <solonarv> what does 'length' on Text count anyway? number of grapheme clusters, or number of codepoints, or something else?
10:34:08 <monochrom> same disease as Java String
10:34:19 <Orbstheorem> dsal: How would I go to match the end faster if I do not know the string prefix? 
10:34:20 <tdammers> the only useful thing about Text.length is that it's O(1)
10:34:22 <monochrom> number of codepoints.
10:34:23 <maerwald> solonarv: yeah, but I would say it could be useful to have bytelength for Text that is O(1)
10:34:40 <tdammers> maerwald: Text doesn't have a meaningful byte length
10:34:40 <maerwald> It might be useful to know how big your text is
10:34:42 <dsal> > "foo" `isSuffixOf` "a string that contains foo" -- Orbstheorem 
10:34:44 <lambdabot>  True
10:35:08 <tdammers> maerwald: because that depends on the encoding, but Text doesn't expose the encoding through its API; it's conceptually "encoding-agnostic"
10:35:45 <maerwald> ok, let's settle on grapheme_length :P
10:35:50 <monochrom> Text could have supported O(1) length by caching the hard-earned length.
10:36:14 <monochrom> Like, the text content isn't even mutable, why re-compute it every time.
10:36:22 <monochrom> s/ it / length /
10:36:45 <Orbstheorem> tdammers: my python brain says that it could be a bytestring as long as every code point is a byte and promote itself to something else when needed but many other problems come with dynamic dispatching. 
10:37:12 <Orbstheorem> Also, deterministic asymptotes are nice x) 
10:37:17 <solonarv> you're right with that last part.
10:37:36 <solonarv> also, mixing blobs and text into the same type is generally not a great ideea
10:37:41 <solonarv> even python knows that!
10:38:06 <maerwald> solonarv: some shell installers do that :P
10:38:29 <maerwald> (I'm a script until this byte, then I'm not)
10:38:36 <tdammers> Orbstheorem: this could easily be implemented in Haskell... data Text = Text7BitClean ByteString | TextUtf16 (Array UInt16), but IMO it would complicate matters a lot, for no good reason
10:39:15 <monochrom> Yeah I ran into one of those self-exploding shell script installers once, it's clever but cringy.
10:40:02 <monochrom> (just having fun with "self-exploding". of course it's just benign self-decompressing.)
10:40:07 <maerwald> monochrom: It's funny to convert those to distro packages, because you have to find the magic byte, then unpack from there, then unzip throws a few errors you have to ignore
10:40:44 <Orbstheorem> maerwald: Is ignoring those errors the intended way to use that compressing format?
10:41:03 <maerwald> who knows
10:42:10 <monochrom> tdammers: I think it very like complicates or confounds writing rewrite rules for fusion.
10:42:32 <maerwald> makeself was the name :)
10:42:56 <monochrom> but I haven't really tried, I may be wrong.
10:44:02 <monochrom> Historically the real reason is this was a summer student project so there was a lot of KISS that didn't scale.
10:53:53 <maerwald> Oh, https://apfelmus.nfshost.com/articles/lazy-eval-intro.html has a mistake on the explanation of `seq`
10:54:32 <maralorn> Does someone understand why my project is building fine with cabal but ghcide throws this error? (I have correctly configured the cabal cradle in hie.yaml). https://termbin.com/pnye
10:54:54 <maralorn> ghcide and cabal both use the same ghc version.
10:55:06 <monochrom> No, IMO the mistake is about "space leak".
10:55:24 <maerwald> monochrom: it suggests that seq enforces an ordering on evaluation
10:55:37 <maerwald> At least I read it that way
10:55:38 <monochrom> Yes, I know.
10:56:22 <monochrom> seq forces order : seq indicates strictness :: galileo-newton relativity : einstein relativity
10:56:54 <monochrom> It is not wrong, it is a 1st-order approximation that works for the majority of the cases.
10:57:37 <monochrom> Ever wonder why it's called "seq" not "strict"?  Note that Bird's earlier textbook did call it "strict".
10:57:58 <monochrom> Because John Hughes invented it and he totally had evaluation order in mind.
10:58:10 <monochrom> Also note that strictness alone doesn't reduce space.
10:58:36 <monochrom> And John Hughes invented it for the sole purpose of reducing space .
10:59:44 <monochrom> It was only political correctness (if I may say so) during the writing of the Haskell Reports to say "let's only talk about strictness, ah well so we can only talk about seq's strictness"
11:00:23 <monochrom> Lastly, notice the community-wide, including founding fathers, error of saying "lazy vs strict".
11:02:50 <monochrom> Now, "leak", that's something we can really pick on and tear apart.
11:03:18 <maerwald> A leak, imo, increases memory consumption over time
11:03:21 <monochrom> If you hold on to a piece of data that you will never use again, that's a leak.
11:03:44 <monochrom> But in foldl (+) 0 [1..n], you totally will use the built data.
11:04:23 <monochrom> This is not a leak, this is an inefficient algorithm.  But it totally uses everything it builds.
11:04:57 <monochrom> If you write bogosort, no one calls it a time leak.  It is a stupid algorithm, but it is not a leaky algorithm.
11:05:44 <monochrom> If you compute addition by first expanding each number n to a string of length n, then do string concatenation, then count final length.
11:06:32 <monochrom> This is another stupid algorithm. But it is not a leak. Neither "memory leak" nor "space leak", for those of you who actually came up with a bogus fictional difference between them.
11:07:27 <monochrom> Like, what is memory if not space, and what is space if not memory.
11:07:44 <monochrom> Or is it one of those "shellfish is not fish" silliness.
11:08:30 <maerwald> selfish isn't a shellfish
11:08:34 <maerwald> but yeah
11:08:37 <monochrom> So, I ask again, what is the difference between my stupid addition algorithm and foldl (+), such that the former is not "leaky" but the latter "is".
11:08:51 <maerwald> I think "inefficient" suffices here.
11:25:53 <asuper> If I make a pull request to change the phrasing "arising from the use of" to "required by the use of" (which is less technical-sounding but still conveys the same information I think) would that be well-received? 
11:27:00 <maerwald> To every haskell repo?
11:27:10 <asuper> To GHC. 
11:27:23 <monochrom> I cannot know, because I don't know who are in power to approve or disapprove.
11:27:57 <monochrom> But I say that "required" is both more technical and more precise, and I prefer it.
11:28:10 <monochrom> However, I don't know whether it is more correct.
11:28:44 <asuper> Well, as far as I can tell the word "arising" is because the compiler is trying to fulfill aa constraint that it cannot, and it's talking about the use that caused that constraint to exist
11:28:47 <asuper> IE arise 
11:29:08 <monochrom> But it is always preferred to disambiguate "should" to one of: user may assume, use must satisfy
11:29:16 <monochrom> s/use must/user must/
11:30:22 <monochrom> This is oddly enough something that functional programmers are missing out, and imperative programmers have an advantage over.
11:30:59 <monochrom> Because imperative programmers know "precondition" and "postcondition" and how they are the two opposite ends of "should happen somehow".
11:31:20 <monochrom> As usual, by Sapir-Worf, functional programmers haven't even thought of this.
11:32:14 <heatsink> We say "forall" and "exists"
11:35:12 <monochrom> You think it's that simple?  Which one is which?
11:36:42 <heatsink> A constructive proof of "forall x such that P(x), there exists y such that Q(y)" corresponds to a function with precondition P and postcondition Q
11:36:53 <heatsink> P(x) and Q(y)
11:37:45 <monochrom> May I not use foralls and exists inside P? inside Q?
11:38:37 <heatsink> you can
11:39:21 <monochrom> Inside P, are my foralls preconditions? postconditions? are my exists preconditions? postconditions?
11:41:28 <monochrom> Also, by skolemization, the proof proves "exists f, forall x such that P(x), Q(f(y))"
11:41:32 <heatsink> In the game theoretic interpretation, forall means an adversary chooses the value, and exists means the player chooses the value
11:42:33 <Chousuke> I'm not sure what's difficult about the forall/exists formulation. It makes perfect sense to me
11:42:57 <MarcelineVQ> Where difficult means unclear?
11:43:04 <monochrom> Answer my questions to find out!
11:43:56 <asuper> https://gitlab.haskell.org/ghc/ghc/issues/18100
11:44:20 <asuper> Hopefully this ticket isn't formatted terribly or whatever 
11:44:37 <heatsink> This distinction between constraining what someone else does and constraining what I do works for both contracts and quantifiers
11:45:16 <monochrom> How hard is it to answer my question directly?
11:47:22 <bifunc2> When writing my own Storable instances, are my alignment, sizeOf, peek, poke functions automatically inlined?
11:47:26 <heatsink> It would involve categorizing all possible uses of quantifiers and contracts, and then establishing a correspondence between them.  That is quite hard.  You'd be trying to make a comprehensive overview of the subject.
11:47:31 <bifunc2> Or should I always specify INLINE on all of them?
11:48:21 <monochrom> Or you can just concede, as I have long done, that forall is not always precondition, exist is not always postcondition, despite the truth about game semantics.
11:48:44 <monochrom> Concede that when I asked "you think it's that simple?" the correct answer is "hell no".
11:48:53 <Chousuke> wait, what, did someone say that?
11:48:57 <Chousuke> I'm confused.
11:49:28 <Chousuke> I'm not even sure how you're supposed to think of preconditions and postconditions if not in terms of logic
11:50:21 <monochrom> Because I sure as hell can contrive a contrived example that P(x) could be "x is a representation of a language that satisfies a pumping lemma" and so it contains interleaved foralls and exists and by that point it is not simple.
11:50:23 <ivegotasthma> hello, I'm trying to understand how to write an accumulating function for accumArray, can someone tell me what I'm doing wrong here? https://dpaste.org/mvON/raw
11:50:38 <heatsink> You were referencing the Sapir-Whorf hypothesis.  Which would mean that functional programmers do not think about the concepts of preconditions and postconditions because they don't have names for them.
11:50:42 <koz_> bifunc2: Type class methods are not automagically inlined anywhere. Storable is no exception.
11:50:51 <MarcelineVQ> bifunc2: I don't see why they would, fwiw the instances in https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Foreign.Storable.html#Storable aren't specifically marked as inline. Is there some material you have that suggests they are? I would like to see it if there is for my own curiosity
11:51:03 <bifunc2> ok thanks
11:51:08 <bifunc2> nope haven't seen such material
11:51:12 <MarcelineVQ> alrighty
11:51:18 <Chousuke> monochrom: but how is that relevant to being able to talk about preconditions and postconditions in terms of exists/forall? What
11:51:31 <Chousuke> what's actually inside the conditions is completely irrelevant.
11:52:01 <heatsink> asuper: It looks readable to me
11:53:57 <heatsink> Functional programmers can use logical formulas to describe preconditions and postconditions.  If they can use logical formulas to describe other things too, that doesn't negate their usefulness for preconditions and postconditions.
11:54:06 <Chousuke> I'm just not seeing how preconditions and postconditions are any different in imperative languages compared to non-imperative ones. Aren't they the same thing?
11:54:29 <asuper> Thanks for looking ot over, heatsink. Looking through the other "arising from" errors I can't figure out a better phrasing for most of them 
11:54:37 <asuper> the ambiguous type variable ones especially 
11:55:30 <asuper> I've long wondered if Haskell would be more or less usable with really verbose errors in general, honestly. Like if the error message for 
11:55:33 <asuper> "foo" + "bar"
11:55:38 <asuper> was
11:55:59 <asuper> Something like, I dunno:
11:56:40 <asuper> "Found a use of '+', a member of the `Num` typeclass, with arguments [Char] and [Char]. This requires an instance of `Num` for `[Char]`, which does not exist."
11:57:12 <asuper> Is that better or worse than "No instance for (Num [Char]) arising from a use of `+`"
11:57:32 <MarcelineVQ> worse for me, same info, more words
11:57:42 <heatsink> asuper: C++ does fine with really verbose errors
11:58:07 <heatsink> Oh, you mean more wordy descriptions
11:58:19 <asuper> MarcelineVQ: I agree  for myself, but that's because I know what this error means 
11:58:39 <asuper> Ideally you'd be able to toggle "terse errors" or something so noobs can understand what's going on more easily 
11:58:40 <heatsink> It depends on whether you want to optimize for beginners
11:59:01 <asuper> but GHC constructs errors by globbing together docstrings which makes that nearly impossible 
11:59:21 <monochrom> I think it is unnecessary to actually say "method".
11:59:38 <monochrom> err, "member of ___ typeclass"
12:00:16 <monochrom> It is necessary to say, one way or another, you used (+) so you're missing Num, yes.
12:01:04 <monochrom> but it is unnecessary to have two versions, one of methods, another for non-methods.
12:01:11 <monochrom> s/one of/one for/
12:01:33 <asuper> That's true, actually
12:02:03 <asuper> I somehow forgot it's kosher to define myAdd = (+) lol
12:02:05 <heatsink> I think it's worthwhile to use source code syntax.  "Num [Char]" is the syntax you would use to define the class.  "`Num` for `[Char]`" isn't
12:02:23 <asuper> That's also a good point. 
12:02:27 <asuper> So maybe it should be something more like
12:02:58 <asuper> "Found a use of `+`, with arguments [Char] and [Char]. This requires an instance (Num [Char]), which does not exist." 
12:03:26 <monochrom> But I don't think GHC was concatenating docstring.  It did not have docstrings at all until months ago, haha.
12:04:19 <asuper> https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Tc/Errors.hs
12:04:31 <asuper> The errors build up an error document 
12:04:36 <Chousuke> I think something like rust might show you "foo" + "bar" and then say something like "Tried to use a method of typeclass `Num` (here) with arguments that don't implement it (here) and (here)" with ascii art pointing at the problem.
12:05:15 <Chousuke> that kind of output is probably tricky to implement though. :/
12:05:42 <monochrom> GHC error messages already contain that kind of ascii art.
12:06:14 * hackage cabal2nix 2.15.2 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.15.2 (PeterSimons)
12:06:55 <monochrom> some GHC error messages.
12:13:28 <monochrom> If you enter "foo"+"bar" at the repl, it won't do the ascii art.  But put x="foo"+"bar" in a file, load that file, you will get it.
12:15:18 <asuper> It does
12:16:36 <monochrom> It begins to suck if I replace "foo" and "bar" by really long expressions
12:16:44 <monochrom> x = (cycle "bar" ++ cycle "xx" ++ "yyz") + (cycle "choc" ++ cycle "yz" ++ [ x | x <- ['z'..'a' ]])
12:17:19 <asuper> Honestly, just showing a type signature with thigns replaced might be interesting
12:17:20 <maerwald> https://apfelmus.nfshost.com/articles/non-strict-semantics.html the cheating example is really nice
12:18:04 <asuper> Like if it printed something like `(+) :: (Num [Char]) => [Char] -> [Char] -> [Char]` with the `(Num [Char])` bit in spooky red text with ASCII art pointing to it
12:18:06 <asuper> or something 
12:19:10 <monochrom> I envy apfelmus. He wrote all the tutorials I wanted to write.
12:19:42 <monoko123> anyone can solve some linear algebra questions
12:19:49 <monochrom> No.
12:20:10 <monoko123> SAD :(
12:20:14 <maerwald> last (take n (player signs)) = last (player (take (n-1) signs)) -- that took a while to grok though, lol
12:20:25 <maerwald> :D
12:25:11 <monochrom> In old Haskell, when IO was [Answer] -> [Request], it had to satisfy a similar condition too.
12:25:41 <monochrom> The condition was expressed by a different formula but it's equivalent.
12:25:57 <maerwald> and "sync" function is really clever too
12:26:31 <monochrom> the nth request you emit cannot depend on the nth, (n+1)th, (n+2)th, ... answers you receive as input.
12:26:42 <maerwald> Wait, did you mean [Request] -> [Answer]?
12:26:59 <monochrom> It really is [Answer] -> [Request],
12:27:26 <monochrom> your function outputs requests to the RTS, inputs answers from the RTS
12:27:40 <monochrom> [Request] -> [Answer] would be the RTS
12:28:17 <maerwald> Oh right, RTS as a microservice
12:28:48 <monochrom> You are right that not only this is mind bending, it is also hard to imagine how to even write code like this.
12:29:15 <monochrom> And so they also provided a continuation-style thin wrapper. (So thin, it's just type aliases.)
12:30:04 <monochrom> continuation style is close to monadic style, so at least it looks more like imperative sequencing than infinite list tricks.
12:30:45 <maerwald> Reminds me of the variadic function trick in quickcheck
12:31:01 <maerwald> Recursive instance resolution or what was it
12:32:12 <monochrom> Also Text.Printf
12:36:38 <monochrom> Yeah sync is neat.
12:38:00 <monochrom> But I wonder if zipWith const is better.
12:39:47 <maerwald> monochrom: but that wouldn't return bottom if someone cheats
12:42:05 <monochrom> Um, he has a typo, he wrote "chat" for "cheat" :)
12:42:16 <maerwald> there are multiple typos
12:42:48 <monochrom> typos in code are unforgivable because you're supposed to at least load it up into ghci before you post.
12:42:52 <maerwald> the function signatures of the first alwaysPaper and whatYouDid are incorrect
12:43:05 <maerwald> Oh wait, they are not
12:43:07 <maerwald> type aliases...
12:43:44 <maerwald> but this is trickery anyway
12:44:03 <maerwald> I can't imagine I want to write something more complicated like sync and hope I got the semantics right...
12:56:56 <monochrom> I have done some tests.  zipWith const is as effective as sync.
12:58:09 <monochrom> zipWith const is sync plus two more clauses that don't matter for rounds.
12:58:28 <maerwald> But it doesn't crash on cheating?
12:58:38 <fendor> :t withMVar
12:58:40 <lambdabot> error: Variable not in scope: withMVar
12:58:42 <monochrom> It crashes on cheating, I tried.
12:58:52 <monochrom> or rather, it hangs
12:59:14 * hackage bazel-runfiles 0.12 - Locate Bazel runfiles location  https://hackage.haskell.org/package/bazel-runfiles-0.12 (MathieuBoespflug)
12:59:28 <maerwald> monochrom: yeah, because it stops producing
13:00:43 <maerwald> this is what happens when you play with infinity!
13:01:56 <monochrom> Whether rounds uses sync or zipWith const, rounds (cheat, whatYouDid) hangs.
13:02:21 <maerwald> Huh?
13:03:08 <monochrom> Inside the fair rounds, you have "signs1 = player1 (sync signs1 signs2)", likewise for signs2 = player2 ...
13:03:22 <monochrom> If I have sync2 = zipWith const, then ...
13:03:57 <monochrom> empirical tests show that it doesn't matter whether I use sync or sync2.  I get hangs either way when someone cheats.
13:06:27 <maerwald> for cheat (alwaysPaper vs cheat) , we have: sync (Paper : Paper : )  =  -- since cheat cannot start
13:06:36 <monochrom> The only reason why I noticed typos is because I actually enter the code and test it :)
13:07:03 <maerwald> but I would have expected it to "fall through" sync and not have a pattern match
13:07:06 <monochrom> > zipWith const (1 : 1 : undefined) undefined
13:07:06 <maerwald> and then cause error
13:07:07 <lambdabot>  *Exception: Prelude.undefined
13:08:31 <monochrom> bottoms caused by infinite loops manifest a little differently from bottoms caused by inexhaustive patterns.
13:09:15 <monochrom> If a player cheats, rounds ties a knot, you don't run into inexhaustive pattern, you run in circles.
13:12:01 <monochrom> And my tests have been in ghci, interpreter.
13:12:13 <monochrom> If compiled with -O, the result is <<loop>>
13:12:45 <monochrom> main = mapM_ print (rounds2 (whatYouDid, cheat))
13:12:59 <monochrom> rounds2 is rounds but using zipWith const
13:18:58 <maerwald> witchcraft
13:25:44 * hackage headroom 0.2.0.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.2.0.0 (xwinus)
13:28:34 <monochrom> hehe
13:33:23 <ski> monochrom : hm. i suppose "`forall's in positive position and `exists's in negative position corresponds to preconditions, `exists's in positive position and `forall's in negative position corresponds to postconditions" wouldn't cut it ?
13:35:00 <ski> (also, what if the formula uses an "if and only if" ?)
13:38:22 <monochrom> Taking positive and negative into account is good enough.  But yes iff ruins that.
13:39:14 * hackage kubernetes-webhook-haskell 0.2.0.1 - Create Kubernetes Admission Webhooks in Haskell  https://hackage.haskell.org/package/kubernetes-webhook-haskell-0.2.0.1 (amarrella)
13:40:24 <monochrom> If people stated, much earlier, that forall vs exist is how functional programmers learned assume vs oblige, I would concede much earlier, too.
13:41:49 <monochrom> The seeing that in every precondition and postcondition one may use all logical connectives freely, it is not going to be a simple correspondence between {forall, exists} and {pre, post}
13:41:56 <monochrom> s/The seeing/But seeing/
13:42:58 <ski> anyway, i'm not sure i've heard FPers not talking in terms of pre- and post- conditions, before
13:43:19 * ski . o O ( logic variable / meta-variable vs. skolem )
13:45:06 <ski> (i would certainly describe e.g. `head' and `fromAscList' as having preconditions)
13:46:26 <monochrom> The #haskell bunch, the Curry-Howard fans, eliminate it and go with refinement types, dependent types, and "no partial function at all".
13:48:22 <MarcelineVQ> pro/post-condition indexed monads :>
13:48:24 <MarcelineVQ> *pre
13:48:24 <maerwald> Is there a way to figure out whether a megaparsec parser has consumed input, without checking the parse result? getInput before and after and then ==? Seems a little odd
13:48:44 <monochrom> Trying to remind me "the two ways are meta-logically equivalent" is just the Turing tarpit raised to the proof level.
13:49:03 <monochrom> The two styles of proofs are obviously very different and invite different mental models.
13:49:34 <monochrom> Yes I fear the Hoare monad very much.
13:51:28 * ski . o O (  x : A | P x.  y : B | Q y. R x y vs.  f : {x : A | P x}  {y : B | Q y}.  x : A | P x. R x (f x) vs.  f : A  B.  x : A | P x. Q (f x)  R x (f x) )
13:54:00 <monochrom> maerwald: Are you open to the idea that given a denotational tutorial we've recently read, you can setInput undefined and give the parser a try... :)
13:54:19 <monochrom> OK just kidding!  I'll try to look for a realistic solution.
13:54:42 <maerwald> MP.getInput before and after and then checking it is probably a solution
13:54:48 <maerwald> but it feels dumb
13:55:06 <maerwald> and is also slow, given large input
13:55:08 <monochrom> Yeah. And "catching exception" is not exactly right in this case.
13:56:00 <monochrom> Internally, megaparsec knows whether input has been consumed.
13:56:52 <maerwald> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Internal.html#t:Consumption
13:57:04 <maerwald> hmm, there's Virgin... just what I was looking for!
13:57:28 <monochrom> Yes but does megaparsec let you use it?
13:58:25 <maerwald> unParser :: forall b. State s e -> (a -> State s e -> Hints (Token s) -> m b) -> (ParseError s e -> State s e -> m b) -> (a -> State s e -> Hints (Token s) -> m b) -> (ParseError s e -> State s e -> m b) -> m b
13:58:31 <maerwald> I can't see it there, lol
13:58:54 <monochrom> That's cringy, but I guess desperate measure etc.
13:59:45 <monochrom> runParsecT may be a bit easier to use.
14:00:36 * ski . o O ( (x ) A  B x vs. A k  B ( k) )
14:00:52 <maerwald> But I'm inside the parser, I can't run it!
14:00:54 <monochrom> Also, depending on why you need this, "observing" and a few other normal API may be sufficient
14:01:51 <monochrom> darn, observing doesn't tell you consumption. I don't know what does.
14:02:23 <maerwald> getSourcePos may be a bit cheaper for Eq test
14:02:37 <monochrom> Yeah, I think that's it.
14:02:53 <maerwald> but the documentation still says it's slow
14:04:17 <monochrom> maybe getOffset is good enough
14:06:05 <maerwald> Oh, I think that is O(1)
14:06:12 <maerwald> getOffset = stateOffset <$> getParserState
14:06:32 <maerwald> if it just queries the parser state
14:06:34 <maerwald> should be fine 
14:07:47 <monochrom> It seems to me PosState is not computed-and-updated until someone asks for it by getSourcePos or error messages.
14:08:24 <monochrom> offset is, of course, cheap to update and query.
14:09:50 <monochrom> "getSourcePos is O(1)-time amortized" :D
14:10:44 * hackage dobutokO2 0.36.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.36.0.0 (OleksandrZhabenko)
14:10:46 <maerwald> wait, but stateOffset is strict
14:11:09 <maerwald> Maybe for that reason
14:11:41 <monochrom> Oh it's just because 0+1+1+1+1+1 vs 5
14:12:12 <monochrom> It is strict and rightfully so, any less strictness is slower not faster.
14:12:33 <monochrom> not statePosState is not strict, nothing to worry about
14:13:21 <monochrom> darn, typo
14:13:23 <monochrom> but statePosState is not strict, nothing to worry about
14:15:09 <maerwald> I somehow prefer the attoparsec API
14:15:43 <maerwald> but one of my libraries provides only megaparsec parsers and you can't combine different parser libs :)
14:17:56 <koz_> maerwald: Wasn't there some Edward Kmett library that was meant to solve this?
14:18:03 <koz_> It's like some 'am a parser' type class thingo.
14:18:13 * maerwald pulls in kmettoverse ...
14:18:15 <maerwald> :D
14:18:25 <koz_> maerwald: The Kmett Cinematic Universe.
14:18:38 <monochrom> haha
14:19:02 <maerwald> let me get my PhD in CT real quick before using this library...
14:19:46 <koz_> maerwald: Lol.
14:19:55 <monochrom> It doesn't solve "some library has already committed to megaparsec"
14:20:17 <Uniaika> maerwald: noooooooo :<
14:20:53 <maerwald> monochrom: well, imagine how things play out when effects systems become even more popular and infect APIs :P
14:21:12 <maerwald> "Oh this is exactly what I need... oh no..."
14:22:45 * hackage dobutokO2 0.36.1.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.36.1.0 (OleksandrZhabenko)
14:25:08 <MarcelineVQ> you boys :>
14:25:18 <ski> ".. and a Ukrainian text." ?
14:25:53 <MarcelineVQ> ski: afaik there's a bunch of related packages that should provide more info
14:25:59 <koz_> MarcelineVQ: BOIIIIS
14:26:44 * ski fails to see how Ukrainian would enter the "create experimental music" part
14:27:15 <asuper> I actually really hope that GHC standardizes on an effects system tbh
14:27:16 <MarcelineVQ> ski: https://hackage.haskell.org/package/mmsyn7ukr
14:27:24 <asuper> Otherwise it's just going to become impossible to use any fuckin library 
14:28:43 <ski> hm
14:29:19 <MarcelineVQ> like the way that vocaloid assists in experimental music
14:29:27 <koz_> Also, maerwald - thank you for your dedication to cross-comp support in ghc-hs.
14:29:31 <ski> never heard of that, either
14:29:35 <MarcelineVQ> ohmy
14:29:55 <maerwald> koz_: yeah, almost done
14:30:31 <maerwald> koz_: I also noticed a bug in "make bindist"
14:30:43 <maerwald> it basically can't create a working configure script for cross GHC
14:30:53 <maerwald> the configure script will bail out when you unpack and run it
14:30:57 <maerwald> some checks are borked
14:31:03 <maerwald> mixes up host and target or something
14:31:14 <koz_> maerwald: Good thing you noticed.
14:31:35 <maerwald> would be interesting to have bindist'ed cross GHCs
14:31:44 <maerwald> arm is probably the most popular target
14:32:09 <koz_> Yeah, it's very much relevant to my interests.
14:32:35 <ja> asuper: "his means that applications using mtl can migrate many existing transformers-based monad stacks to fused-effects with minimal code changes."
14:33:20 <maerwald> fused-effects, did that come after or before freer? I lost track
14:33:44 * hackage typed-encoding 0.1.0.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.1.0.0 (rpeszek)
14:34:02 <maerwald> I remember some CTO blogged about it being awesome. I wonder if his employees agree after he left
14:35:13 <maerwald> (you never see the fallout of your decisions :P)
14:39:15 * hackage dobutokO2 0.36.2.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.36.2.0 (OleksandrZhabenko)
14:42:15 <Taneb> Is there a convient wrapper type which adds a zero (absorbing element) to a Semigroup?
14:42:24 <Taneb> Like how Maybe's Monoid instance adds an identity
14:44:23 <asuper> I don't believe there is, but it's pretty trivial to define a newtype wrapper around Maybe that will do it 
14:45:00 <asuper> In fact, I think you would even be able to do `DerivingVia` with `Ap` to get zero semantics, wouldn't you?
14:49:23 <Taneb> Hmm, that's an interesting idea
14:59:38 <edwardk> koz_: the kmett cinematic universe sounds like some weird twitter/youtube/twitch/irc media programming-talk crossover event
14:59:58 <solonarv> @check \e -> (Ap Nothing :: Ap Maybe (Sum Int)) <> e == Ap Nothing
15:00:00 <lambdabot>  error:
15:00:00 <lambdabot>   No instance for (Arbitrary (Ap Maybe (Sum Int))) arising from a use of my...
15:00:04 <solonarv> aww.
15:00:08 <koz_> edwardk: Lol, senpai noticed me. :P
15:00:15 <solonarv> @check \e -> (Ap Nothing :: Ap Maybe (Sum Int)) <> Ap e == Ap Nothing
15:00:17 <lambdabot>  +++ OK, passed 100 tests.
15:00:34 <solonarv> \o/
15:01:15 <koz_> Fun fact - I _actually_ got to use your Codensity/Church-related free monad writeup in Comonad Reader in a work setting last week.
15:01:24 <koz_> So thanks for writing that!
15:42:45 <koz_> Does the Semigroup instance for this type, as described, violate the associativity law of <>? http://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly.html#t:WSerialT
15:43:49 <maralorn> Any recommendations what git library I should use for a) check that index is clean, b) add a file c) commit?
15:44:51 <maralorn> There are tons of hackage and 0 of them have dokumentation that makes me happy.
15:44:53 <maralorn> tons of git libs on hackage
15:46:40 <maerwald> maralorn: I believe gitea/gogs actually invokes git as a process for lots of things
15:47:15 <maralorn> maerwald: So your saying: Dont use a lib?^^
15:47:18 <maerwald> and it saves you from linking to libgit
15:47:25 <maerwald> dunno, it's a tradeoff
15:47:47 <maralorn> Yeah, I was nearly at that point.
15:47:50 <maerwald> I was looking at the same thing and decided to call git directly
15:47:57 <maralorn> New (completely unrelated questiion) what library do I use fr subprocesses?^^
15:48:07 <maerwald> I wrote my own functions :P
15:48:10 <maerwald> but there is process package
15:48:13 <maerwald> @hackage process
15:48:13 <lambdabot> http://hackage.haskell.org/package/process
15:48:44 <maerwald> I use fork/exec directly from unix
15:52:34 <maerwald> maralorn: forkProcess, executeFile and getProcessStatus is all you need
15:52:42 <maerwald> https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Process-ByteString.html#v:executeFile
15:52:52 <koz_> On a somewhat-related note: am I missing something, but shouldn't we have '(Semigroup a) => Semigroup (ZipList a)'>
15:52:55 <koz_> ?*
15:52:55 <lambdabot> Maybe you meant: v @ ? .
15:53:26 <maralorn> maerwald: Thanks. Gonna use readProcess.
15:54:57 <MarcelineVQ> "<koz_> Does the Semigroup instance for this type, as described, violate the associativity law of <>?" yes
15:55:08 <koz_> MarcelineVQ: *loud sigh*
15:55:16 <koz_> Time to file a bug!
15:58:21 <MarcelineVQ> If it's lawful it's in a way that's not obvious, like how the actions are combined possibly, as far as results though  (a <> b) <> c  gives a different observable result than  a <> (b <> c)
15:58:39 <koz_> It's not even an effect question - the _values_ are straight-up wrong.
15:59:45 <koz_> Also, MarcelineVQ: Am I right that (Semigroup a) => Semigroup (ZipList a) makes sense?
15:59:53 <koz_> Ditto (Monoid a) => Monoid (ZipList a)?
16:03:49 <monochrom> Yes.  In Data.Monoid, this is provided by "(Applicative f, Semigroup a) => Semigroup (Ap f a)" and "(Applicative f, Monoid a) => Monid (Ap f a)".  Ap is a newtype wrapper, Ap f a = f a.  So set f = ZipList.
16:03:59 <koz_> monochrom: Oh, neat.
16:04:10 <koz_> I keep forgetting Ap is a thing.
16:04:48 <monochrom> Hrm, does it do what we think it does? :)
16:05:26 <monochrom> > Ap (ZipList ["ab", "cd"]) <> Ap (ZipList ["12", "34"])
16:05:29 <lambdabot>  Ap {getAp = ZipList {getZipList = ["ab12","cd34"]}}
16:05:40 <monochrom> > Ap (ZipList ["ab", "cd"]) <> Ap (ZipList ["12"])
16:05:43 <lambdabot>  Ap {getAp = ZipList {getZipList = ["ab12"]}}
16:05:53 <monochrom> I think it does what we think.
16:06:28 <koz_> > Ap (ZipList ["ab", "cd"]) <> Ap (ZipList ["12", "34"]) <> Ap (ZipList ["..", ",,"])
16:06:31 <lambdabot>  Ap {getAp = ZipList {getZipList = ["ab12..","cd34,,"]}}
16:07:17 <koz_> > Ap (ZipList ["ab", "cd"]) <> mempty
16:07:19 <lambdabot>  Ap {getAp = ZipList {getZipList = ["ab","cd"]}}
16:07:24 <koz_> OK, convinced.
16:07:47 <koz_> It's a little odd that we gotta go through Ap though.
16:07:52 <koz_> Should really be on ZipList itself IMHO.
16:08:09 <MarcelineVQ> Ap is pretty nice tho for the sake of ad-hoc generality
16:08:22 <koz_> Oh yeah, no arguments against Ap.
16:08:24 <MarcelineVQ> > Ap (ZipList [1,2]) <> Ap (ZipList [3,4,5]) <> Ap (ZipList [6,7,8]) :: Ap ZipList (Sum Int)
16:08:26 <lambdabot>  Ap {getAp = ZipList {getZipList = [Sum {getSum = 10},Sum {getSum = 13}]}}
16:09:01 <monochrom> Probably just "You already have Ap, I'm too lazy to write code for ZipList that does the 'same' thing"
16:09:22 <MarcelineVQ> "I mean who's even using ZipList"
16:10:22 <heatsink> I want to write tests for a library that compile a program, execute it, and check its output
16:10:45 <koz_> heatsink: Haskell program I assume?
16:10:47 <heatsink> yes
16:10:50 <heatsink> Is there a way to query Cabal for the ghc flags to use?
16:11:21 <heatsink> The test driver itself would be a test in the package description, I think
16:11:31 <maerwald> --verbose=3
16:12:19 <heatsink> If I do it that way, the test driver would invoke ghc, so it would have to determine what flags to use
16:12:45 <maerwald> Why not shell?
16:13:10 <koz_> heatsink: What're you actually testing in this case?
16:13:17 <koz_> Like, what does the library do?
16:13:53 <heatsink> It generates C++ code
16:14:32 <koz_> heatsink: inline-cpp or something?
16:14:51 <heatsink> So, a test would involve running a .hs file to produce a .cpp file, then compiling the cpp file into an executable, then running the executable, then checking its output
16:15:23 <maerwald> that sounds like a job for shell
16:15:44 <koz_> Yeah.. I think this is closer to CI than testing.
16:16:15 <maerwald> GHC uses python for its test suite, afaik. It isn't that uncommon.
16:18:11 <heatsink> A shell script is fine
16:18:30 <heatsink> I still don't know how to build the ghc command line for it
16:18:36 <koz_> Also, why the step to compile the .hs? If this is a library, surely it has some 'makeTheActualCode :: WhateverCodeRep -> Text' function right?
16:18:58 <heatsink> I could write tests that way also
16:19:22 <koz_> I'd say that's a good idea, since it saves you having to invoke _two_ compilers in your testing-CI-hybrid shindig.
16:19:53 <heatsink> Yeah, I'm feeling that will be easier to set up
16:19:59 <koz_> Also, what dialect of C++ do you generate?
16:20:13 <heatsink> Then cabal will handle invoking ghc
16:20:18 <heatsink> It's c++11
16:20:21 <koz_> Ah, OK>
16:37:35 <sm[m]> heatsink: how about shelltestrunner
16:39:09 <heatsink> I don't know what it is
16:40:35 <heatsink> I see
16:41:10 <heatsink> Not a good match for this case 
16:42:29 <heatsink> Since I'm not testing a shell program
16:46:34 <dmj`> haddock: internal error: internal: extractDecl
16:46:40 <dmj`> anyone seen this guy before
16:52:08 <sm[m]> darnit.. https://pypi.org/project/shelltest encroaching on my https://github.com/simonmichael/shelltestrunner brand
16:53:39 <dmj`> this this same bug
16:53:40 <dmj`> https://github.com/commercialhaskell/stackage/commit/0736d33fa2e5f09fab3b087498fe2e7f4501da04
16:53:46 <dmj`> its this*
16:56:54 <edwardk> koz_: glad to hear!
17:08:53 <dmj`> nvm I found the patch https://gitlab.haskell.org/ghc/ghc/-/commit/2a431640d199b164ca5d233684d4f4bdaf5ca021
17:29:48 <nowhere_man> I'm wondering about point-free
17:30:03 <nowhere_man> I just wrote: arrApply arr idx fun = readArray arr idx >>= writeArray arr idx . fun
17:30:18 <nowhere_man> can this be written point-free, without fun as argument?
17:31:00 <nowhere_man> arrApply :: (Data.Array.Base.MArray a1 a2 m, GHC.Arr.Ix i) => a1 i a2 -> i -> (a2 -> a2) -> m ()
17:31:34 <siraben> @pl arrApply arr idx fun = readArray arr idx >>= writeArray arr idx . fun
17:31:35 <lambdabot> arrApply = ap (ap . (((.) . (>>=)) .) . readArray) (((.) .) . writeArray)
17:31:47 <siraben> nowhere_man: yes
17:34:32 <yushyin> very readable! ;)
17:38:13 <monochrom> You're looking at \f -> (>>=) (rA arr idx) ((.) (wA arr idx) fun)
17:38:23 <monochrom> err
17:38:30 <monochrom> \f -> (>>=) (rA arr idx) ((.) (wA arr idx) f)
17:39:23 <monochrom> Let h = (>>=) (rA arr idx), k = (.) (wA arr idx).  You're looking at \f -> h (k f) = h . k
17:39:44 <monochrom> = (>>=) (rA arr idx) . (.) (wA arr idx)
17:40:07 <monochrom> = (rA arr idx >>=) . (wA arr idx .)
17:41:06 <monochrom> It's up to you.  Some people don't understand this, some other do.
17:58:15 <nowhere_man> monochrom: your last one is pretty readable
18:55:14 * hackage greskell 1.1.0.0 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.1.0.0 (debugito)
19:07:45 * hackage taskwarrior 0.2.1.0 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.2.1.0 (maralorn)
19:18:15 * hackage staversion 0.2.3.5 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.3.5 (debugito)
19:22:03 <sheepfleece> Is there some kind of a type safe `exception` library? Which would force we to catch all possible exceptions an action can throw.
19:27:57 <dsal> {-# LANGUAGE JAVA #-}
19:31:28 <sheepfleece> It's not like it is a bad thing having possible exceptions in your type!
19:32:02 <dsal> It's good to get things documented, but I feel the java experiment failed pretty badly.
19:33:15 <sheepfleece> I actually don't know how they did it. But something like a type level list of possible exceptions could be pretty neat.
19:33:59 <dmwit> Does ExceptT not already do this for you?
19:34:30 <dsal> Java has "checked exceptions" such that you have to declare the exceptions you're going to throw and callers are expected to handle or also declare those exceptions.  Or their subclasses.  Exception RuntimeException or like, Error or something.
19:35:47 <mniip> yeah RuntimeException is the exception
19:35:49 <sheepfleece> dmwit: Oh, but I want to be able to catch IO exceptions too, things like ErrorCall and the like. I don't think ExceptT can do it. 
19:36:23 <mniip> sheepfleece, it's impossible to tell whether a value contains any bottoms
19:36:35 <mniip> and error is one of them
19:37:13 <sheepfleece> But it should be an action, not a value.
19:37:26 <mniip> actions are values
19:37:42 <mniip> % putStrLn "hi" >> undefined
19:37:43 <yahb> mniip: hi; *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:141:18 in interactive:Ghci31
19:38:35 <sheepfleece> Well, I want something that when I call throw <something> that something gets reflected in a type somehow. 
19:38:52 <sheepfleece> And forces me to handle it later on.
19:39:10 <mniip> I'm not sure that's possible
19:39:13 <dmwit> sheepfleece: You can wrap any call that throws IO exceptions in an ExceptT API.
19:39:49 <dmwit> Yes, if you want the type system to enforce something for you, you must tell the type system about the thing you want to enforce first.
19:39:58 <mniip> ^
19:40:13 <dmwit> So, okay, no big deal. You just write a parallel openFile API that uses ExceptT instead of IO exceptions.
19:40:27 <dmwit> Or whatever other actions you find essential to your application.
19:40:56 <sheepfleece> Well, that's why I was looking for such a library in the first place! But I'll look again in ExceptT, maybe it can do something similar.
19:41:04 <mniip> the closest I can think of to your suggestion is wrapper datatypes that maintain an invariant of being whnf/nf
19:41:12 <dmwit> I don't think there is an existing collection of wrappers around `base`'s IO actions.
19:41:46 <dmwit> mniip: I think it's probably already valuable if it doesn't prevent bottoms, only IO exceptions.
19:41:54 <mniip> sure
19:42:01 <dmwit> Which is much easier.
19:42:01 <mniip> but this is a completely parallel line of thought
19:42:09 <dmwit> ok =)
19:43:41 <mniip> newtype WHNF a = WHNF a; newtype NF a = NF a; toWHNF :: a -> IO (Either SomeException (WHNF a)); toNF :: NFData a => a -> IO (Either SomeException (NF a))
19:44:10 <mniip> and then for every field accessor  f :: a -> b you'll have to write a corresponding one f :: NF a -> NF b
19:44:14 <mniip> though notably not WHNF -> WHNF
19:44:44 <mniip> you will also need patterns
19:45:38 <mniip> pattern (WHNFCon x y z) = WHNF (Con x y z); pattern (NFCon (NF x) (NF y) (NF z)) = WHNF (Con x y z);
19:45:48 <mniip> (I don't remember whether that's valid syntax but something along the lines of)
19:46:09 <mniip> that will give you a library for manipulating bottom-free values
19:47:01 <mniip> though as you can see there's nothing you can do to ensure that a function doesn't throw when applied
19:47:06 <mniip> save for somehow structurally memoizing it
19:47:28 <sheepfleece> I see, thank you.
19:47:55 <mniip> which is an interesting adventure in and of itself
19:48:02 <mniip> but of dubious worth
19:49:58 <nowhere_man> sheepfleece: do you have a specific use case?
20:00:55 <sheepfleece> nowhere_man: I just have a couple of `throw` functions, and I thought it would be cool if it were somehow represented in a type. 
20:01:07 <sheepfleece> they* 
20:02:54 <disconsis> Could anyone recommend any formatting libraries for strict Text?
20:03:17 <disconsis> Somehow every one that I googled used lazy Text, and it's a pain converting all the time
20:06:45 * hackage string-interpolate 0.2.0.2 - Haskell string/text/bytestring interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.2.0.2 (williamyaoh)
20:09:41 <dsal> disconsis: You can compose functions.  :)
20:10:40 <disconsis> I imagine it gets a bit boilerplate-y for variadic functions :P
20:10:53 <disconsis> I think I found a library though - text-all
20:11:20 <dsal> What do you mean?
20:12:12 <dsal> That thing you just linked to implements format as:  `format f = TL.toStrict . Format.format f`
20:15:57 <disconsis> Does it? That's surprising
20:16:06 <disconsis> I imagined there'd be more of a difference
20:16:14 <dsal> Why?  That's what I'd expect.
20:16:47 <dsal> Functions take one parameter and return one value.  You have a value of a particular type and a function that converts it to the type this other thing wants.  It makes sense to just compose those two and get the thing you want.
20:16:47 <disconsis> Well, because the type of format is `format :: Params ps => Format -> ps -> Text`
20:17:01 <disconsis> Oh I see what you mean
20:17:14 <disconsis> It's not the output that I'm concerned about, but the input
20:17:33 <disconsis> I thought it was the strict text arguments that it was complaining about
20:17:38 <disconsis> But it was the output
20:17:45 <disconsis> That makes sense
20:40:15 * hackage di-polysemy 0.1.1.1 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.1.1.1 (nitros12)
20:50:14 * hackage sv 1.4.0.1 - Encode and decode separated values (CSV, PSV, ...)  https://hackage.haskell.org/package/sv-1.4.0.1 (GeorgeWilson)
21:14:15 * hackage xml-conduit-stylist 2.1.0.0 - Bridge between xml-conduit/html-conduit and stylist  https://hackage.haskell.org/package/xml-conduit-stylist-2.1.0.0 (alcinnz)
21:31:44 * hackage net-spider 0.4.3.1 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.3.1 (debugito)
21:33:45 * hackage net-spider-pangraph 0.2.0.1 - Conversion between net-spider and pangraph  https://hackage.haskell.org/package/net-spider-pangraph-0.2.0.1 (debugito)
21:34:45 * hackage net-spider-rpl 0.4.1.1 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.4.1.1 (debugito)
21:35:45 * hackage net-spider-rpl-cli 0.1.3.1 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.3.1 (debugito)
21:54:06 <martinium> anyone have any example code for iterating through paginated json web responses?
21:57:45 * hackage ipynb 0.1.0.1 - Data structure for working with Jupyter notebooks (ipynb).  https://hackage.haskell.org/package/ipynb-0.1.0.1 (JohnMacFarlane)
22:02:14 * hackage hw-int 0.0.2.0 - Additional facilities for Integers  https://hackage.haskell.org/package/hw-int-0.0.2.0 (haskellworks)
22:17:20 <koz_> martinium: What library are you using to fetch them?
22:26:02 <scasc> Question re. package namespace hierarchy: Where can I look up the population of namespaces? I could have sworn there was a possibility on hackage, but I can't seem to find it for the sake of it.
22:26:26 <scasc> Or was it on the wiki? -- no great sources found yet.
22:29:29 <lyxia> scasc: what namespaces are you talking about
22:47:58 <scasc> The module namespaces. You know, where the top level ones are Data, Control, Language, Text, ...
22:48:20 <scasc> I know it's an organic list, but I am pretty sure to have seen a compilation from hackage sometimes somewhere
23:34:32 <nowhere_man> I have a weird typing error, the expected and actual types seem to matach: https://pastiebin.com/5ea52b41e0688
23:34:44 <nowhere_man> Expected type: ST s1 (STArray s1 Int [a1])
23:34:55 <nowhere_man> Actual type: ST s1 (STArray s1 Int [a])
23:35:43 <c_wraith> note that a and a1 are not the same
23:36:12 <nowhere_man> what prevents them to be unified?
23:36:20 <c_wraith> the fact that they're rigid
23:36:44 <c_wraith> You probably have a function declared in a where block with a type signature
23:37:29 <c_wraith> that claims it works for all types a, but what you really mean is the enclosing definition's type a
23:37:53 <c_wraith> Of course, you'd need to enclose the code to know that for sure
23:38:24 <lyxia> well the enclosed line 69 looks like there's a missing forall and/or ScopedTypeVariable extension.
23:39:02 <c_wraith> oh, it's got the type right there.  Yeah, that needs ScopedTypeVariables
23:39:56 <c_wraith> when you use `a' in that line, it means a *totally different type variable* than any `a' in a different type signature
23:41:37 <nowhere_man> c_wraith: and they can't get unified?
23:43:43 <c_wraith> no.  for the same reason { const :: a -> b -> a ; const a b = b } is a type error.
23:44:24 <c_wraith> just because they're both variables doesn't mean they're interchangeable
23:50:57 <nowhere_man> ha yeah, with ScopedTypeVariables and a forall in the topmost type, it works
23:51:08 <nowhere_man> I really don't understand the issue, though
23:51:19 <nowhere_man> the type 'rigidity", I guess
23:52:21 <c_wraith> so, type variables can be "rigid" or "wobbly"
23:52:40 <c_wraith> a wobbly type variable is allowed to unify.  a rigid one is not.
23:53:05 <c_wraith> In most cases, inferred type variables in Haskell are wobbly, specified ones are rigid
23:53:39 <nowhere_man> OK, but what made it rigid on line 69 but not on line 44 (https://pastiebin.com/5ea52c612710a)
23:54:14 <nowhere_man> The types are litteraly the same
23:58:18 <Lycurgus> inferred might be a better choice of words
23:58:28 <c_wraith> Hmm. The thing that's different is that on line 44, [a] isn't actually wrong
23:58:47 <c_wraith> you're initializing the array with empty lists
23:58:50 <c_wraith> :t []
23:58:51 <lambdabot> [a]
23:59:38 <c_wraith> there's no values there to fail to type-check against the type you specified
