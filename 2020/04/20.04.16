00:28:30 <brj> dd:w
00:28:32 <brj> :qall
00:32:00 <brj> gg/docs
00:32:16 <brj> ljjjjjjjjjggjjjjjl/h/res
00:32:19 <brj> lj/read
00:32:34 <opqdonut> this is not vi
00:33:10 <Axman6> I'm a little sad we didn't have a bunch of people who use vi as their IRC client drop out with that :qall
00:36:11 <brj> ah dang my bad, my terminator started boadcasting 
00:38:26 <maerwald> wrong port
01:18:38 <pgiarrusso> brj: ah, last week it was broadcasting some Java code in #coq :-P
01:20:37 <maerwald> sounds like a good way to get banned
01:20:49 <maerwald> :D
02:40:33 <mr_sm111th> I can't think of a * -> * kind that cannot be made into a Functor. Can I get a hint? 
02:41:55 <merijn> mr_sm111th: Set
02:42:14 <merijn> Also, anything contravariant :)
02:42:44 <merijn> "newtype Contra a = Contra (a -> Int)" <- also not a functor
02:42:59 <polyphem> merijn: contravariantFunctor ?
02:47:16 <mr_sm111th> That's not a very subtle hint. But thanks. :)
02:47:31 <merijn> Oh, I glossed over the hint part :p
02:50:18 <maerwald> so, I've only done hspec so far, any reason to ditch it for something else?
02:51:38 <merijn> maerwald: the typeclass based "pseudo english" DSL can make it hard to abstract and follow the code
02:55:23 <jchia> It seems that the read function is fine with trailing spaces in the input but not other kinds of extra characters. Is there a special reason spaces are special?
02:55:50 <jchia> I noticed this trying to read @Int, for example.
02:56:13 <merijn> I'd personally recommend just avoiding read entirely, tbh :p
02:56:39 <fendor> > read "2   \t\n" :: Int
02:56:41 <lambdabot>  2
02:56:45 <fendor> lol
02:56:47 <merijn> jchia: reads is more general
02:56:52 <merijn> > reads "123abc" :: [(Int, String)]
02:56:54 <lambdabot>  [(123,"abc")]
02:58:07 <jchia> I defined Show and Read for my own data and it round-trips
02:58:36 <jchia> merijn: I see, reads gives more information.
02:59:27 <merijn> Most parser combinators are faster and give more control anyway, so I'd probably use those :p
03:00:01 <ski> mind showing the definitions, jchia ?
03:01:02 <jchia> ski: Definitions for what?
03:01:11 <jchia> the instances?
03:02:51 <ski> yes, of the methods therein
03:03:02 <jchia> https://gist.github.com/jchia/afa09464d83b46a8849f278e227dbd42
03:03:30 <sshine> merijn, haha, I like that there was a clippy meme addressing what was wrong about my idea.
03:03:35 <jchia> I wanted to just use read because calling parsing functions seems quite troublesome with so many arguments
03:03:50 <merijn> sshine: I made it :p
03:03:54 <jchia> but read is imprecise and doesn't fail when the input is not fully-consumed
03:04:21 <merijn> jchia: Just partially apply the parsing functions to fit what you want/need
03:04:29 <jchia> ski: definitions in the gist
03:04:37 <tdammers> parser-combinators typically don't fail upon unconsumed input either. with (mega-)parsec, for example, you have to explicitly use the `eof` combinator to make it do that
03:05:33 <tdammers> Read supports "nondeterministic" parsing (i.e., returning a list of possible parses, rather than picking one for you according to Maximum Munch or whatever), but that's not fundamentally something a parser-combinator can't do
03:07:40 <sshine> ReadP you mean?
03:08:37 <sshine> merijn, oh ;)
03:09:07 <tdammers> ReadS
03:09:16 <sshine> ok.
03:10:53 <sshine> I wonder if there were any esoteric extensions to parser combinators that became useful. I remember an exercise where one had to do probabilistic parser combinators, where it'd deal with ambiguity by selecting subsets of parsers at random with some predetermined frequency.
03:10:59 <sshine> I don't think that was very useful for anything.
03:12:50 <tdammers> maybe for NLP
03:14:16 <ski> jchia : `MP' ?
03:14:22 <jchia> Megaparsec
03:14:39 <jchia> Text.Megaparsec
03:23:29 <ski> jchia : hm, i was wondering whether you could avoid the `get' restoring the remainder of the input in `ReadP'
03:24:10 <jchia> ski: I had to add the replicateM_ processed get. The read failed when I didn't it.
03:24:36 <jchia> when i didn't have it
03:27:23 <ski> jchia : it probably doesn't matter that much in this case, but you should get into a habit (whenever you seldom decide to instance `Show') define `showsPrec' rather than `show'
03:27:42 <ski>   shows date . showChar 'n'
03:28:34 <jchia> ski: I never got down to understanding the meaning of precedence as it pertains to showsPrec so I just did something simple.
03:30:14 <ski> jchia : however, the most important point is that you should not (imho) be putting this code into `Show' and `Read' to begin with ! instances of these classes are intended to work with other instances for other types. consider e.g. `Show (Maybe Session)'. they are expected to refer to a string representation of Haskell code which (in the appropriate environment) evaluates to the relevant value
03:31:33 <ski> the precedence argument of `showsPrec' and `readsPrec' tells you the precedence level of the surrounding context, typically as established by an infix operator
03:33:39 <ski> you'd normally use `showParen (p > 5)' / `readParen (p > 5)', where `p' is the precedence, if you're currently handling something of precedence level `5' (an operator of that precedence)
03:33:44 <ski> ghci
03:34:09 <ski> er
03:36:07 <jchia> ski: What software depends on Show & Read in this way that my definitions break them? I see that show and read don't roundtrip for (Maybe Session).
03:36:33 <jchia> Can I make it roundtrip properly if I deal with the precedence properly?
03:37:25 <ski> take `:+' as an example, it's `infix 6'. we'd have something like `showsPrec p (re :+ im) = show„é©ren (p > 6) $ showsPrec 7 re . showString " :+ " . showsPrec 7 im'
03:38:33 <ski> if it was `infixr 6', we'd have `showsPrec 6 im'. if it instead was `infixl 6', we'd instead have `showsPrec 6 re'
03:39:24 <ski> or, take `Just', we have `showsPrec p (Just a) = showParen (p > 10) $ showString "Just " . showsPrec 11 a', since application has precedence `10', and is left-associative
03:39:36 <mniip> >show„é©ren
03:40:29 <ski> `Show' and `Read' are primarly intended for debugging in the interactor, i'd say
03:42:32 <ski> jchia : your instances might work (assuming that `Show Date' is sane enough). but let's say they happened to include commas. or imagine another custom data format for another data type that did. consider `Show [Date]' and `Show (Date,Date)' and so on
03:43:05 <ski> jchia : my recommendation would be to leave custom-formats out of `Show' and `Read'
03:55:17 <zincy_> Is it correct to say every monad describes an effectful computation?
03:55:45 <merijn> For some definition of "correct", "every", "monad", "describes", "effectful" and "computation", sure :p
03:56:09 <zincy_> Yeah that is where my unease comes from.
03:56:30 <zincy_> Computer science has this same issue as the humanities.
03:57:11 <MarcelineVQ> every *clap* monad *clap* desribes *clap*
03:57:22 <zincy_> In mathematics everything has one definition.
03:57:40 <zincy_> haha  :D
03:58:38 <zincy_> You can't sing the same song for functors though can you
03:58:55 <gentauro> what are the things you need to have in mind when writing Haskell code with regard of build times
03:59:14 <gentauro> at the moment, I have a "simple" library that takes around 5 minutes to build
03:59:34 <gentauro> which is annoying as I'm still working on it and every single change, I have to wait 5 minutes :|
03:59:48 <gentauro> (which development `pretty` slow)
04:00:18 <zincy_> If you split it up into modules you can take advantage of parallelism.
04:00:55 <MarcelineVQ> that's pretty long. I can build 1/4 of ghc in 5 mins. do you happen to be using deriving with really large records?
04:01:09 <zincy_> Also template haskell?
04:01:52 <gentauro> MarcelineVQ: yes
04:02:36 <gentauro> MarcelineVQ: well I did, but I don't do anymore
04:03:08 <gentauro> I write my own instances (Show, Functor)
04:03:25 <gentauro> but I have `somehow` big records :)
04:03:33 <zincy_> Also use --fast --file-watch during dev.
04:04:20 <MarcelineVQ> It'd be hard to say more without seeing it, you can try searching for long build time tickets in the ghc issues and see if any of them fit patterns you have
04:04:46 <ski> zincy_ : imho, yes
04:05:02 <gentauro> zincy_: are those `cabal` or `stack` falgs?
04:05:11 <MarcelineVQ> issues with deriving and generics and th are the most obvious ones that can come up, other than that there's typechecking which can sometimes be made to take a long time
04:05:24 <zincy_> ski: Was that in reference to "Is it correct to say every monad describes an effectful computation?"
04:06:01 <ski> yes
04:06:19 <gentauro> MarcelineVQ: it went pretty slow when I added `inline` pragmas to the code
04:06:20 <gentauro> :S
04:08:18 <zincy_> I need to get my head around this "free monads ... have the ability to represent the very structure of monadic computations."
04:08:37 <zincy_> Is that because the branching strategy is defined by the implementation of the functor?
04:08:53 <gentauro> zincy_: btw, I have already split up to `modules`, but I can't du any further due to I have to `hide` data type constructors (not expose them)
04:09:34 <zincy_> gentauro: I meant actually separate stack projects. My conviction level that this will work is not that strong though.
04:20:20 <gentauro> zincy_: --fast = (-O0) helped a lot !!!
04:20:29 <zincy_> Yay
04:21:31 <gentauro> fuild build takes only 30 seconds now (I also commented all the INLINE pragmas ... I guess I'll turn them on when I'm done with the lib)
04:21:40 <gentauro> zincy_: but now I can at least develop again xD
04:23:06 <gentauro> zincy_: full rebuild = 30 seconds. Ad-hoc build = intant !!!
04:23:08 <gentauro> thx !!!
04:41:46 <merijn> gentauro: I assume you mostly want to typechecking?
04:41:59 <merijn> (for development)
04:42:07 <merijn> Because you can do better than -O0
04:53:52 <gentauro> merijn: at this moment, I just want fast builds :)
04:54:13 <gentauro> when all the code is written, I will look into performance/tunning 
04:54:29 <gentauro> merijn: just out of curiosity, what would your suggestion be?
04:56:29 <merijn> gentauro: -fno-code is magic for fast type checking
04:56:41 <merijn> It basically skips compilation entirely and only does type-checking
05:00:23 <gentauro> merijn: :o
05:00:28 <gentauro> what is this sorcery :o
05:06:29 <gentauro> merijn: is there a way to use this with `stack`? It works, but because of how `stack build` works, it will try to copy the binary ...
05:08:02 <opqdonut> https://github.com/commercialhaskell/stack/issues/977
05:16:55 <zincy_> gentauro: My pleasure :)
05:27:55 <gentauro> opqdonut: so no stack :(
06:03:54 <flatlands> heay
06:07:22 <flatlands> https://www.youtube.com/watch?v=tnFPQ57l0Dg
06:07:37 <flatlands> JENKEM - Matt Tomasello in "Rodney Mullen on Bath Salts: Round Three"
06:38:18 <z0> is there a good example of the ((->) r) monad being useful?
06:38:41 <tdammers> sure
06:38:45 <tdammers> it's basically the reader monad
06:39:07 <tdammers> ((->) r) ~= Reader r
06:51:03 <infinity0> suppose i want compile a test file outside of a cabal project but i want to import stuff from the cabal store, how do i do that?
06:51:43 <merijn> infinity0: You can load a .ghc.environment and then it should work. Unfortunately, I forget how and it's not very well documented atm
06:51:56 <infinity0> ah, ok
06:55:20 <infinity0> bah, sadly doing ghc -package-db complains about duplicate packagess, i guess i really do need to add the whole environment file :(
07:20:37 <fendor> infinity0, with cabal-env, it is really easy: https://github.com/phadej/cabal-extras
07:21:26 <infinity0> oh nice thanks
07:27:58 <maerwald> fendor: hey, where did you get that from!
07:28:01 <maerwald> :D
07:28:15 <maerwald> now phadej has to support all my use cases :)
07:28:54 <phadej> for stuff cabal-extras I'm quite ignorant to issues
07:28:57 <fendor> I cant remember who showed me this repo... but it is awesome. I hope nobody is mad at me for suggestning it :/
07:32:05 <phadej> stuff is provided as is
07:32:54 <merijn> Isn't it more like "if you break it, you fix it" ;)
07:32:55 <phadej> "<maerwald> now phadej has to support all my use cases :)" is sadly not a funny joke
07:34:01 <maerwald> xD
07:36:22 <srk> 'cabal-store-check: A naive tool to try to repair cabal's nix-store'
07:36:46 <srk> really uses nix-store under the hood?
07:37:50 <merijn> srk: cabal-install doesn't use Nix, though. v2- commands just use a Nix inspired store
07:38:15 <srk> inspired, I see
07:38:25 <srk> is working on hnix-store from time to time
07:38:28 <srk>  /me
07:40:30 <merijn> srk: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
07:40:54 <srk> yup, I know about that
07:41:04 <srk> merijn: can you point me to implementation as well?
07:41:14 <srk> namespace would be enough if you know
07:41:36 <merijn> The implementation is just "the cabal git repo"? :)
07:41:48 <srk> yes but that one is huge :D
07:41:52 * srk has a crude browser
07:41:55 <srk> with no js
07:42:05 <srk> gotta clone it
07:42:09 <srk> nvm
07:43:30 * srk looking at Distribution.Client.Store
07:45:25 <infinity0> cabal-env works well, for my simple use-case anyway
07:55:14 <sm[m]> gentauro: ghcid is faster again than --fast/-O0. With stack, it can be eg: ghcid -c "stack ghci" ...
07:55:52 <sm[m]> or sometimes just "ghcid"
07:57:23 <MarcelineVQ> I used to type  stack exec ghcid
07:58:53 <sm[m]> I do ghcid -c 'make ghci' which runs ghci with all the flags to load all local packages
07:59:22 <Uniaika> cocreature: hi! is there somewhere where I can report an LSP construct that ghcide does not seem to support?
07:59:41 <merijn> Uniaika: Github?
07:59:51 <molossus_spondee> https://hackage.haskell.org/package/selective-0.4.1/docs/Control-Selective-Rigid-Freer.html I don't understand the types here. Is there a simpler version of the freer selective. It can be strict.
08:00:04 <Uniaika> merijn: I didn't see anything in the issues and I wanted to make sure there was a *right place* :)
08:00:20 <Uniaika> (with some sort of roadmap / priority list‚Ä¶)
08:00:27 <merijn> Uniaika: I guess LSP constructs might belong in one of the LSP repos
08:00:51 <merijn> Uniaika: Anyway, I've just been opening issues directly on the github rep
08:01:11 <cocreature> Uniaika: the issue tracker on github is totally fine.
08:01:21 <Uniaika> thank you cocreature and merijn :)
08:04:56 <Uniaika> cocreature: here it is! https://github.com/digital-asset/ghcide/issues/530
08:05:20 <merijn> I should update ghcide and see if I get any better results in my doomed repo
08:24:06 <Uniaika> cocreature: wanna laugh? the bad message is sent if Neil Mitchell's ghcid's neovim plugin is installed.
08:24:33 <Uniaika> oh, and this ghcid plugin does *not* interact with LSP in any way whatsoever
08:24:56 <Uniaika> too bad, I don't have the mental bandwidth to deal with that, otherwise I would have become a systems programmer.
08:27:03 <EvilPyro> Hello, is there a clean way to check if a matrix like [[]] has 4 or more elements in line (think of the connect 4 game)
08:27:42 <EvilPyro> when i say in line I mean any direction, so horizonal, vertical and diagonals
08:27:55 <merijn> EvilPyro: tbh [[]] is a rather bad data structure for storing matrix like data structures, which makes this question considerably harder
08:28:20 <merijn> EvilPyro: If you used a 2 dimensional array it becomes considerably simpler
08:29:52 <EvilPyro> then I'll need to include a module right?
08:30:23 <merijn> EvilPyro: For example the array package which would let you use "Array (Int, Int) Value" and then checking a row of four would be a matter of mapping the access function over a set of indices like [(0,0), (0,1), (0,2), (0,3)] etc.
08:30:42 <merijn> https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html
08:31:35 <EvilPyro> This is for a class where we are learning haskell and I'm required to make a project of my choice so the teacher breaks it into parts commenting what i did good and bad xD, not sure if adding a module its allowed
08:31:41 <tdammers> Map (Int, Int) a -- is a surprisingly useful data structure
08:31:52 <merijn> That too
08:32:36 <tdammers> but anyway, for a tightly-packed 2D grid, I'd just use a flat Array or Vector, and provide a wrapper that translates coordinates from 2D to the 1D storage space and back
08:32:45 <tdammers> (and also manages bounds and such)
08:32:47 <merijn> Honestly writing any non-trivial project without imports is gonna be...hard
08:33:03 <tdammers> yes. and not the good kind of "hard", usually
08:33:21 <merijn> You can tell your instructor #haskell gave you permission ;)
08:34:48 <EvilPyro> maybe i could implement the data structure, not sure where to start of if its too much 
08:36:01 <tdammers> for a toy example, you can start with something like data Grid a = Grid { w :: Int, h :: Int, cells :: [a] }
08:36:26 <tdammers> the performance characteristics are atrocious, but for educational purposes it'll do the trick
08:44:45 <EvilPyro> so basically that and then check all posible lines in the grid
08:45:32 <[exa]> EvilPyro: personally I'd submit the version with lists and attach a simple conversion that uses Data.Vector, showing how much faster it is
08:47:40 <[exa]> also, the haskellest way is to make 4 functions that extract all kinds of lines as lists, another function that checks if there's 5 equal items in a list, and do something like 'any (hasSequenceOfLen 5) (allLinesIn board)'
08:49:28 <fendor> merijn, In the course at my uni, you implement the same task with different datastructures to illustrate how much easier it becomes
09:27:46 <EvilPyro> how can i get the value of a Maybe x ? I'm having problems with the grid_get function in this fragment https://pastebin.com/Q07daqhY
09:28:15 <EvilPyro> l || index where l is a list and index is maybe Int
09:28:34 <EvilPyro> l !! index sorry
09:29:26 <ChaiTRex> EvilPyro: You mean you have Nothing or Just x and you're wondering how to get the x?
09:30:59 <ChaiTRex> EvilPyro: Ahh, I see. In the bottom function, use pattern matching. case index of (newline) (indent) Nothing -> Nothing (newline) (indent) Just x -> (do something with x)
09:31:15 <solarliner> If you're 100% sure that the `Maybe` cannot be a `Nothing`, then you can use `fromJust`
09:31:23 <solarliner> Otherwise it's just a case expression away
09:32:37 <ChaiTRex> EvilPyro: Something like this: https://pastebin.com/QUXmpDxN
09:33:33 <ChaiTRex> EvilPyro: Or, even better: https://pastebin.com/u7bLU1p0
09:36:10 <EvilPyro> oh thankyou!
09:47:14 <dmwit> (l!!) <$> grid_index (Grid w h l) x y
09:49:22 <heath> I know that the complexity of nub has been discussed several times. Are there any discussion on the complexity of Data.List.Unique.unique?
09:52:14 <ChaiTRex> heath: It's O(n log(n)) for the sort and then O(n) for the filter, so O(n log(n)) overall.
09:52:45 <[exa]> heath: it has Ord constraint, can use sorting magic
09:53:41 <ChaiTRex> unique = concat . filter ((== 1) . length) . group . sort
09:56:19 <ChaiTRex> heath: For that matter, if uniq can have sorted output, it can also achieve O(n log(n)). uniq = map head . group . sort
09:57:35 <solonarv> note: (==1) . length is inefficient, although I don't think it changes the asymptotics in this case
09:57:50 <zincy_> merijn: Thanks for -fno-code , it is a real time saver!
09:57:56 <aviD> Weekly Haskell video chat group anyone?
09:57:56 <aviD> I would like to talk with a group of people about Haskell, FP, etc, for around an hour a at scheduled time each week. People could drop in to, ask questions, talk about a project or just chat (basically face to face Haskell IRC). Is anyone else interested? If you are, what times/zones and days of the week tend to work?
09:58:33 <zincy_> I would be up for that, any week day GMT.
09:58:37 <ChaiTRex> solonarv: Yeah, [_] -> True; _ -> False would be quicker.
09:59:47 <aviD> This is cross-posted on https://www.reddit.com/r/haskell/comments/g2iq3y/weekly_haskell_video_chat_group_anyone/
10:00:04 <ChaiTRex> \ xs -> not (null xs) && null (tail xs)
10:00:08 <[exa]> aviD: +1 but many people prefer writing (also the written information gets archived&reused much more easily)
10:00:32 <ChaiTRex> You wouldn't even need the first one there, since group doesn't produce null sublists.
10:00:36 <monochrom> Most video chats seems to come with text chat.
10:00:52 <dmwit> \xs -> length (take 1 xs) == 1
10:01:12 <sm[m]> avid: a fun idea, what tool would you use ? they don't support too many simultaneous users, unless you pay (zoom supports the most ?)
10:01:17 <monochrom> haha neat, dmwit
10:01:53 <dmwit> oh
10:01:59 <dmwit> actually, \xs -> length (take 2 xs) == 1
10:02:01 <sm[m]> avid: a sort of related thing people do is a twitch stream - one person streaming and everybody else chatting
10:02:20 <sm[m]> that can give some structure and a focus
10:02:31 <ChaiTRex> null . tail
10:02:37 <heath> ty ChaiTRex and solonarv üôè
10:02:48 <ChaiTRex> Since all inputs have at least one element.
10:03:29 <aviD> Written s definitely more useful, but it's not quite the same as face to face.
10:03:52 <aviD> Likely google hangouts
10:04:23 <ChaiTRex> betterUnique = concat . filter (null . tail) . group . sort
10:04:27 <monochrom> I think you just need a platform that does both.
10:05:22 <[exa]> ...can you use editor with Agda as a Zoom background?
10:05:34 <ChaiTRex> betterUnique = map head . filter (null . tail) . group . sort
10:06:17 <dmwit> betterUnique vs = do v@[_] <- group (sort vs); v
10:07:02 <monochrom> haha [exa]
10:07:31 <dmwit> > (length "do v@[_] <- group (sort vs); v", length "[v | [v] <- group (sort vs)]")
10:07:33 <lambdabot>  (30,28)
10:14:05 <solonarv> dmwit: but those don't do the same thing
10:14:22 <solonarv> :t \vs -> [ v | [v] <- group (sort vs) ]
10:14:24 <lambdabot> Ord a => [a] -> [a]
10:14:31 <solonarv> hmm, never mind
10:14:48 <zincy_> monochrom: I can't unsee the truth now. I see models everywhere.
10:15:21 <monochrom> It's like monads.  When you learned monads, you saw monads everywhere too.  I know I did.
10:16:46 <zincy_> monochrom: It gives you some motivation to understand how to prove properties of programs
10:17:05 <zincy_> Because surely proofs of correctness make our models more rigorous.
10:18:35 <monochrom> There is a proof-checking system HOL4 (more like a bunch of SML functions you use to put together proof steps) that provides, at your option, a bunch of CPS proof step commands.  I saw that it might as well be monadic.  So I coded a toy fragment in Haskell's Monad: http://www.cs.utoronto.ca/~trebla/fp/prover/index.html
10:20:06 <zincy_> Why Haskell and not Coq or Agda?
10:20:59 <monochrom> Two sides.  One: Monad.
10:21:56 <MarcelineVQ> Three gods, one true faith.
10:22:39 <monochrom> Second: May as well ask why HOL4 uses SML not Coq or Agda.  Answer: We are looking for a programming language and writing in it a proof EDSL, not looking for a proof language.
10:23:22 <monochrom> See this is what's wrong with keyword-Google-hit reasoning again.
10:23:50 <monochrom> You hear "proof" you just knee-jerk "Coq! Agda! Curry-Howard!"
10:23:55 <zincy_> Haha
10:23:57 <zincy_> Yes
10:24:22 <zincy_> The words came straight out my mouth, even though I don't know what them mean.
10:24:25 <monochrom> Not even the courtesy of "ACL2"
10:24:41 <zincy_> Like an incantation
10:25:15 <zincy_> So the idea is to embed a proof language within Haskell
10:25:27 <Uniaika> oof https://twitter.com/buggymcbugfix/status/1250802502263504897
10:25:30 <monochrom> But keyword-Google-hit knee jerk is only the 2nd worst.
10:25:40 <monochrom> There is a worst, it comes out of the blue.
10:26:27 <maerwald> has anyone used http-io-streams extensively?
10:26:32 <monochrom> Many Haskell programmer has this strange trigger like they were hypnotized and conditioned to do it, I don't undeerstand why.
10:26:47 <maerwald> It seems there are weird issues with downloading/SSL context behind firewalls/proxy gateways
10:26:53 <zincy_> monochrom: What the agda, coq, curry-howard chant?
10:27:01 <monochrom> Any time you mention or discuss an equation that's true for all programs in scope
10:27:21 <monochrom> they just burt out "so you can use it for code optimization?"
10:27:47 <monochrom> I completely don't understand why.  I was talking about proving my program correct.  What optimization?
10:27:58 <zincy_> It can fix your marriage too.
10:30:08 <monochrom> maerwald: Have you considered cabal's attitude of just system("curl")? :)
10:30:17 <maerwald> monochrom: that is already implemented
10:30:24 <monochrom> Ah OK cool.
10:30:43 <maerwald> Still, doing it manually allows better control and interaction with headers etc
10:31:21 <maerwald> But I'm not sure I want to reimplement curl
10:31:26 <monochrom> :)
10:31:56 <maerwald> just a few decades of engineering and bugfixing...
10:32:04 <monochrom> No, don't. The SSL/TLS story is, like, let someone else do it, too much chore.
10:32:20 <monochrom> And cookies.
10:32:41 <monochrom> And getting redirected etc.
10:33:09 <maerwald> Oh, I implemented the redirection already
10:33:15 <monochrom> haha
10:33:31 <maerwald> but anything SSL/TLS I feel rather paranoid
10:33:50 <zincy_> When you need a 128bit session id to login. And the manager asks to add in another id randomly to make it more *secure*.
10:33:55 <maerwald> I mean... using OpenSSL isn't that trivial
10:34:58 <maerwald> https://hackage.haskell.org/package/openssl-streams-1.2.2.0/docs/System-IO-Streams-SSL.html#v:withConnection
10:35:05 <maerwald> although I use this, it should be safe
10:35:06 <maerwald> no?
10:35:55 <maerwald> metric: count downloads... assume it's fine > 10k users
10:38:07 <monochrom> Anyone who codes up SSL/TLS will get an angry mob out of the blue asking "is your implementation secure against timing side-channel-attack?!"  It does not matter that it is irrelevant in your special case.
10:38:27 <monochrom> Again, humans acting like knee-jerk monkeys.
10:39:00 <maerwald> Or: give in and use haskell-tls, lol
10:39:09 <maerwald> Then say "it uses haskell, it must be safe"
10:39:12 <monochrom> Descending upon you on the slightest pretext.
10:39:15 <isovector1> lexi-lambda: i'm reading your post on dynamic typing myths, and it ends saying hs is really bad at structural typing, and that this is its biggest flaw in your eyes. what would a solution look like?
10:40:15 <lexi-lambda> isovector1: row-polymorphic records and variants
10:40:35 <monochrom> Haskell is heavily leaning on the nominal typing side.  I see it the biggest achievement, haha.
10:41:41 <maerwald> care for the link to the post?
10:41:47 <maerwald> Always enjoying a good rant
10:42:09 <monochrom> Also, in terms of wording, I would think  row : column :: record : variant.  But perhaps it's just a pun.
10:42:17 <buggymcbugfix> isovector1: https://twitter.com/ocramz_yo/status/1250836711418060807
10:42:36 <monochrom> hahahaha
10:43:18 <maerwald> Uhm, I'm not sure I want to work on that codebase.
10:43:35 <zincy_> haha
10:43:50 <monochrom> It's like "82 authors on a particle accelator result paper"
10:46:05 <maerwald> If you need structural typing that much, I suggest to use typescript. I like it.
10:46:30 <monochrom> Does Pascal use structural typing?
10:46:37 <maerwald> Structural functions
10:47:03 <zincy_> Think Typescript does ..
10:48:24 <solonarv> it does; it has to, because it tries to be a type system on top of the (untyped, or if we're generous: duck-typed) javascript
10:49:13 <monochrom> I side with nominal typing because structur typing applied to recursive types becomes eqirecursive types. (And nominal, isorecursive types.)  At which point, TaPL will tell you "sure you can do it, no unsoundness, but here is why/how programmers using your language will suffer..."
10:49:54 <frdg> https://pastebin.com/vr0U5hxu could use some help understanding this type signature 
10:51:27 <monochrom> I will not translate the type to English.  There is a reason why types are not written in English, and why "COBOL looks like English" is a joke.
10:51:44 <ChaiTRex> How do I specify to `cabal bench` that I want to run tests with names of the pattern `Main/*/aaa/*`?
10:51:53 <monochrom> But I can show you examples.
10:52:04 <frdg> monochrom: sounds great
10:53:13 <monochrom> One example: (a -> b) -> (b -> Int) -> Maybe a -> Bool.  f = Maybe, c = Int.  Check: Functor Maybe, Eq (Maybe Int)
10:53:56 <monochrom> It turns out that Maybe enjoys "instance Eq c => Eq (Maybe c)", so I can relax that example to the more general:
10:54:18 <zincy_> How can languages like JS be untyped and dynamically typed at the same time?
10:54:21 <monochrom> (a -> b) -> (b -> c) -> Maybe a -> Bool.
10:54:32 <zincy_> Does dynamic mean *any* type?
10:55:22 <monochrom> Err wait no, I was missing Eq c
10:55:35 <monochrom> So: Eq c => (a -> b) -> (b -> c) -> Maybe a -> Bool
10:55:44 <monochrom> I guess I'll go back to c=Int then.
10:56:21 <monochrom> Another example: (a -> b) -> (b -> Int) -> [a] -> Bool.  f = [], c = Int.  Check: Functor [], Eq [Int] (because Eq Int)
10:56:42 <monochrom> I think you can also do f = Proxy, too.
10:57:05 <frdg> oh I think im seeing
10:58:08 <monochrom> See the power of plugging in randomly to generate examples.
10:58:42 <monochrom> And it will be fun to see a counterexample too, an example of type error for an unsuitable f.
10:58:59 <frdg> I do. I totally see whats going on now actually.
10:59:09 <monochrom> (a -> b) -> (b -> Int) -> IO a  -> Bool.  f = IO.  Problem because no Eq (IO Int).
10:59:44 <frdg> I get it! Thank you
11:00:41 <monochrom> zincy_: People disagree with each other on this.  Here is my take.
11:01:15 <monochrom> JS is typed.  For examples of untyped, see the plain vanilla no-frills untyped lambda calculus.
11:01:45 <monochrom> Here is the other side's take so you know what they're thinking.
11:03:32 <maerwald> for reference, the blog post is https://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open
11:03:44 <maerwald> And it is a proper rant
11:03:58 <monochrom> For dynamically typed, you can model as: so statically speaking just one type, it's equivalent to an algebraic data type that goes like "data T = IntCase Int | BoolCase Bool | ..." so "dynamically check 'types'" means dynamically check tags.
11:05:24 <monochrom> Since it's just one type at static time, Robert Harper calls it "unitype".  Since everything has the same type at static time, you may as well not even speak of types at all, so some other people call it "untyped".
11:06:20 <monochrom> My stance is that they are conflating the high-level model of "check type during run time" with the low-level model of "the implementation detail uses tags".
11:06:47 <monochrom> Yes that's right I still like Robert Harper but I am not afraid to call him bluff on this!
11:07:05 <zincy_> ah right.
11:07:40 <zincy_> What makes you put them as data constructors and not as type constructors though?
11:07:50 <zincy_> Is it because JS doesn't actually care either way?
11:07:51 <monochrom> But all models are artificial!  Nothing says you must use the high-level model of "check type during run time".
11:08:57 <monochrom> If something exists in memory/register during run time, you don't call it a type constructor, you call it a data constructor, com'on it's data in memory/register.
11:09:23 <monochrom> Hell I hate "xxx constructor" altogether, it's why I say tag.
11:09:30 <zincy_> This is where my lack of understanding of the different layers of abstraction hurts me
11:09:57 <monochrom> But JS cares a lot.  Just not statically.
11:10:17 <zincy_> So it hinges on whether you count runtime type checking as valid?
11:10:47 <zincy_> So static / dynamic is basically a compiletime/ runtime distinction
11:11:10 <monochrom> You read the ECNA spec (I did), it's full of "if x is an integer ... <10 lines of what to do> ...; else, if x is an array ... <20 lines of what to do>... etc".  It's just that the spec words it as doing all that during run time.
11:11:15 <maerwald> Anyone else knows the phenomenon of: if you put your TODOs into tickets, you'll never actually finish them.
11:11:44 <monochrom> Oh, static vs dynamic is easy.  dynamic is alwasy "when running".  static is always "before running".
11:12:20 <monochrom> Academics say static instead of "compile time" because you don't even want to commit on whether you have a compiler or an interpreter or anywhere in between.
11:12:34 <monochrom> (Does javac count as a compiler? hahaha)
11:12:41 <zincy_> Ah ok, so static versus dynamically typed is just when values are given types
11:12:49 <monochrom> Also "static" is so much shorter.
11:13:33 <maerwald> zincy_: more like when you check them. You can check types in python before running. You can turn of type-checking in haskell =)
11:13:54 <monochrom> Anyone wanna pool money to lure Harper and Stroustrup into a debate on "what the hell does RTTI even mean?"?  >:)
11:14:16 <monochrom> Yeah, "when".
11:14:41 <zincy_> maerwald: What do you mean by "turn off"
11:14:51 <monochrom> Err, I mean, "check".
11:15:31 <monochrom> But meh, mincing words I guess?  check type = assign type = give type.  To a large extent, in some sense, FSVO, blah blah.
11:15:35 <sm[m]> <maerwald "Anyone else knows the phenomenon"> Yes
11:15:46 <solonarv> "You can turn of type-checking in haskell" - how?
11:15:55 <monochrom> This is dangerously close to intrinsic vs extrinsic typing haha
11:16:06 <monochrom> -fdefer-type-somethingsomething
11:16:09 <maerwald> zincy_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--fdefer-type-errors
11:16:13 <monochrom> Oh, -fdefer-type-errors
11:16:13 <solonarv> -fdefer-type-errors
11:16:17 <zincy_> What is extrinsic vs intrinsic?
11:16:19 <solonarv> but it doesn't turn off the type checker!
11:16:28 <maerwald> yes, that's why I said *when*
11:16:53 <maerwald> the good thing about runtime is
11:16:53 <monochrom> extrinsic vs intrinsic is close to philosphy than technical.
11:16:59 <maerwald> you can handle the type error at runtime!
11:17:02 <solonarv> types are still checked at compile time, it's just that the typechecker doesn't report type errors at compile time anymore and instead turns them into runtime kabooms
11:17:36 <zincy_> So its like God mode for Haskell.
11:17:50 <zincy_> When you are really confident you don't make mistakes.
11:18:02 <solonarv> if you turn off the type checker in haskell, then simple programs like 'main = print 42' don't work anymore!
11:18:15 <solonarv> because the typechecker is also responsible for solving constraints
11:18:58 <monochrom> Extrinsic typing takes this stance, which is probably the older stance.  Values don't have types per se.  For safety, you assign them types so you can check compatibility.  But these types are only meaningful for that safety check.  Before and after, values don't have types.
11:19:19 <zincy_> monochrom: So that is the opposite of the set theory intuition?
11:19:31 <zincy_> Where values live in sets of types.
11:20:03 <monochrom> It is the older stance because untyped languages and untyped thinking came first, e.g., untyped lambda calculus.  And then one day people thought it would be a good idea to check, even infer, various compatibility and sanity conditions.
11:22:16 <monochrom> Intrinsic typing is probably the generation after that who grew up with the presence of static type checking/inference and go, why not take types for granted, every value comes with type.
11:23:15 <monochrom> Pretty much extrinsic smartphone vs intrinsic smartphone, don't you think? :)
11:23:36 <monochrom> <-- intrinsic paper-and-fountain pen
11:24:01 <maerwald> sm[m]: I found that using a TODO.md is better. I can move stuff around, change priorities and still have a good overview. Once I put stuff into the issue tracker...
11:24:08 <maerwald> it becomes so formal and feels like "work"
11:24:14 <monochrom> cool kid on Apple iPad ad "what is a computer?" <-- intrinsic iPad, extrinsic computer
11:24:49 <maerwald> feels like scrum (chat, bikeshed, groom, don't get anything done)
11:25:17 <maerwald> This could be the start of a song
11:25:45 <monochrom> I don't know how set theory fits into this.  Set theory has "4 ‚àà ‚Ñï ‚àà P(‚Ñï)".  Type systems don't have this.
11:26:12 <monochrom> Type systems stop at the like of "4 ‚àà ‚Ñï" that's it.
11:26:26 <MarcelineVQ> What is the P?
11:26:30 <monochrom> powerset
11:28:07 <monochrom> Set theory feels like untyped some times, and extremely dependently typed other times.
11:28:15 <MarcelineVQ> is this different than  3 : Nat : Set1 : Set2 : ...  ? Er rather, it must be different, but can levels be like powersets?
11:28:33 <MarcelineVQ> cumulative levels especially
11:28:43 <monochrom> Consider a spectrum laid out linearly with two ends.  Now join the two ends.  Set theory is at that joint.
11:29:56 <monochrom> Maybe.  Can you, using a predicate or refinement or otherwise, get a subtype of Set1 that corresponds to powerset(N)?
11:31:16 <monochrom> <monochrom> Set theory feels like untyped some times, and extremely dependently typed other times.
11:31:27 <monochrom> that's one of the philosophical reasons I said:
11:31:36 <monochrom> @quote monochrom poor.*m
11:31:36 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
11:32:50 <trey> very new to Haskell, so this question is probably silly, but I'm writing my own takeWhile method, and I have it working, but not entirely sure why. f = foldr (\x xs -> if f x then x:xs else []) [] 
11:32:51 <monochrom> Taoism (new preferred spelling Daoism) is big on the "take your linear spectrum, now join two ends to make a circle" way of thinking.
11:33:19 <trey> why does that else [] stop everything that doesn't meet the condition of the predicate from following?
11:33:36 <peutri> because it doesn't refer to xs
11:33:51 <monochrom> Because that's what takeWhile does.
11:33:57 <trey> oh so that stops the recursion
11:34:01 <monochrom> "We are bad people! It's what we do!"
11:34:05 <peutri> in a way, yes
11:34:12 <Cale> Exactly yes
11:34:52 <peutri> it's missing the part "but is there even recursion" to be an exact yes in my book
11:34:53 <trey> so is the empty list in the else statement essentially a "doNothing" method?
11:34:54 <Cale> @src foldr
11:34:55 <lambdabot> foldr f z []     = z
11:34:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:34:57 <peutri> but that's enough philosophy for today
11:35:24 <trey> ohhh it's due to the definition of foldr
11:35:26 <Cale> foldr passes control to f in the recursive case
11:35:47 <Cale> and in the case that f doesn't use its second argument, the foldr f z xs will never be evaluated
11:36:24 <monochrom> For better growth in functional programming, you'd better shed the "do something vs do nothing" mindset as early as possible.
11:36:28 <sm[m]> maerwald: in addition to public issue tracker, I use a private org outline. The same effect kind of happens there, but it's less of a problem
11:36:48 <trey> what's a better way to consider it?
11:36:54 <sm[m]> I can see why some projects might choose to have "no issue tracker"
11:37:11 <monochrom> I always recommend taking it as algebra.  Suppose "f x = x+1".  f 5 doesn't "return" 6 or "do anything".  f 5 equals 6.
11:37:41 <monochrom> But since programmers became programmers precisely because they flunked algebra, usually mine is a lost cause.
11:37:49 <maerwald> sm[m]: yes, if there's still an issue about it, it means no one cared enough to work on it :P
11:37:49 <Cale> monochrom: It can be helpful to recover that perspective once you want to think about performance though (but I admit this isn't exactly a case where performance is being considered)
11:38:16 <trey> so... foldr f seed [] = seed
11:38:21 <monochrom> Like, if they did OK in algebra, they're now $100K quants in Wall Street already, why bother being a code monkey.
11:40:17 <Cale> trey: The thing that stops the evaluation is not so much the base case for foldr here
11:40:51 <Cale> trey: But rather, that f is able to produce its result without examining its second argument (which will look something like (foldr f z xs)
11:40:53 <Cale> )
11:40:54 <zincy_> monochrom: I know mathematicians that became programmers 
11:41:03 <Cale> zincy_: *waves hand*
11:41:18 <zincy_> Cale: What field?
11:41:46 <zincy_> Im guessing it was related to category theory
11:41:59 <monochrom> Anyway, trey: More on this in my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
11:44:17 <zincy_> monochrom: I think code monkeys and quants are actually on similar salaries
11:44:41 <monochrom> But coding is such a chore!
11:44:56 <zincy_> Would you rather be sweating in a bank?
11:45:08 <monochrom> quants don't sweat
11:45:23 <monochrom> Or at least, don't let them see you sweat :)
11:45:50 <zincy_> monochrom: Do you write code for fun?
11:46:02 <zincy_> Or is it for masochistic pleasure
11:46:06 <EvilPyro> Whats the best way to output a list as a matrix?
11:46:22 <monochrom> Some for fun, some to simplify and automate my teaching job, some for my assignments.
11:46:40 <zincy_> So you are teaching people how to be proficient at doing chores?
11:46:42 <EvilPyro> data Grid a = Grid Int Int [a]
11:47:10 <monochrom> But we all know that writing programs in a "web devop" shop under a clueless manager is the masochistic one.
11:47:27 <monochrom> LIke, just ask hypererisco or something.
11:47:38 <zincy_> Yeah.
11:48:16 <zincy_> The manager who did a course in visual basic 10 years ago and is now a technical person.
11:48:16 <trey> monochrom: thanks for the read. makes a lot of sense and it's refreshing to see the simplistic examples. Going to try to use substitution and matching more when writing 
11:49:33 <monochrom> You're right I may be teaching people to do chores.  Behold the power of economics I guess?  If you pay me good money I can work against my own philosophy...
11:50:13 <Cale> zincy_: tbf, I was never a mathematician professionally, but my degree is in pure mathematics. I strongly considered going on in algebraic combinatorics though, I really like areas where algebraic or categorical things come into contact with things which are tangible or visual in some way.
11:50:27 <Cale> Algebraic topology / geometry / combinatorics
11:51:11 <zincy_> Cale: Ah that is where the Hasse Diagrams came from. :)
11:51:16 <zincy_> monochrom: As long as you enjoy it
12:18:07 <petrus> Cale: Out of curiosity, could you point to an an area where algebraic combinatorics and category theory have some intersection yielding interesting results?
12:20:14 <freeman42x[m]> how can I add a GitHub dependency to a .cabal file? not using stack for ethical reasons, and I know stack can refence GitHub dependencies
12:20:30 <Cale> Well, there's all the stuff on combinatorial species -- I actually think it's possible to strip a lot of the category theory out there if one wants to, but the categorical approach overall results in some very powerful tools
12:21:17 <Cale> There's also some relationships between Hopf algebras and symmetric functions which is quite nice
12:21:36 <Cale> (Hopf algebras in the categorical generalisation)
12:24:14 <Cale> There's also this really beautiful-looking thesis which I've felt slightly guilty for not taking the time to understand better: http://pi.math.cornell.edu/~maguiar/a.pdf
12:28:13 <solonarv> freeman42x[m]: you add it to cabal.project (which has a similar role to stack.yaml), not to mypkg.cabal
12:28:56 <solonarv> let me go find the docs...
12:29:31 <cjay-> https://www.haskell.org/cabal/users-guide/developing-packages.html#source-repositories
12:29:32 <solonarv> freeman42x[m]: https://cabal.readthedocs.io/en/latest/cabal-project.html#specifying-packages-from-remote-version-control-locations
12:30:22 <maerwald> freeman42x[m]: ethical reasons?
12:30:43 <solonarv> cjay-: what you linked is a different feature; it's for specifying "here is where you can find the source code of this package"
12:31:08 <cjay-> solonarv: oh, right. could it work below "package foo" in cabal.project though?
12:31:35 <maerwald> no
12:31:41 <solonarv> looks like the stanza I linked is just top-level
12:31:49 <cjay-> k
12:32:00 <ChaiTRex> @src (&&)
12:32:00 <lambdabot> True  && x = x
12:32:00 <lambdabot> False && _ = False
12:32:24 <maerwald> > False && undefined
12:32:26 <lambdabot>  False
12:32:29 <maerwald> amazing
12:32:35 <monochrom> In fact, even stronger:
12:32:46 <monochrom> > foldr (&&) undefined (False : undefined)
12:32:48 <lambdabot>  False
12:32:57 <maerwald> yeah, try that with foldl!
12:33:04 <monochrom> So much for "foldr starts on the right"
12:33:16 <maerwald> monochrom: I've never understood that confusion :>
12:33:32 <monochrom> I understand it.  It pains me to.
12:33:48 <Unigurd> l
12:34:16 <monochrom> Basically schools merge parsing with evaluation order because all operators they see are strict anyway.
12:34:24 <ChaiTRex> maerwald: The innermost parentheses are on the right and that's where most people start evaluating expressions manually.
12:34:40 <Cale> That confusion stems directly from misunderstanding how lazy evaluation works and from the confusion between bracketing of expressions and evaluation order that eager evaluation creates.
12:34:48 <monochrom> 1+(2+3) is both "parser sees 2+3 as one group" and "2+3 is done earlier".
12:35:19 <maerwald> ChaiTRex: yeah, but if you try to imagine it would traverse the list in reverse... how would that even look like
12:35:34 <Cale> It would look like foldl ;)
12:35:46 <monochrom> I'm kind of OK with the merge because good luck teaching teenagers both parsing and evaluation order.
12:36:00 <ChaiTRex> maerwald: What Cale said.
12:36:03 <monochrom> (but separately)
12:36:27 <maerwald> ChaiTRex: ?
12:36:37 <Cale> @src foldl
12:36:37 <lambdabot> foldl f z []     = z
12:36:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:36:51 <maerwald> it's always left to right, no matter the fold
12:36:52 <Cale> foldl runs to the end of the list before f is allowed to do anything
12:36:59 <ChaiTRex> maerwald: It would put the entire expression in memory and then evaluate from most nested to least.
12:36:59 <Cale> (assuming lazy evaluation)
12:37:03 <monochrom> But humans need to learn the meta lesson "things you learned before work great for things you saw before, but expect revisions for new things".
12:37:04 <maerwald> I'm aware
12:37:19 <Cale> Now, the list still gets taken apart left to right of course
12:37:22 <maerwald> I'm not talking about evaluation
12:37:27 <maerwald> I'm talking about list traversal
12:37:31 <maerwald> Yes
12:37:59 <monochrom> When I was young and arrogant I said that people write-protect their brains after college graduation or age of 21.  I still find that insightful.
12:38:46 <maerwald> monochrom: Bc starting something completely new makes you feel like a student again. Think about that ;)
12:39:26 <maerwald> Who wants to repeat that experience?
12:39:27 <monochrom> My strength is I love being a student!  I'm studying Functional Differential Geometry recently.
12:39:50 <monochrom> I feel very productive when acting as a student.
12:42:05 <freeman42x[m]> @karma+ solonarv thank you very much
12:42:06 <lambdabot> solonarv's karma raised to 17.
12:42:24 <maerwald> freeman42x[m]: care to elaborate on stack being unethical?
12:44:25 <zincy_> monochrom: haha
12:44:43 <tdammers> maerwald: "not using stack for ethical reasons" doesn't imply "stack is unethical"
12:44:47 <tdammers> not necessarily anyway
12:44:54 <maerwald> yeah
12:45:16 <maerwald> Still can't find an argument for either of it
12:45:19 <maerwald> So I'm curious
12:46:01 <freeman42x[m]> maerwald: I have my own reasons backed by evidence for thinking that Nix + cabal is far superior to anything else combined with stack when deciding what to use for a new project. In addition to that I know some very talented Hakell engineers which think that using stack is unethical. I just meant it in a humorous manner
12:46:27 <maerwald> what did they say why it's unethical?
12:46:48 <monochrom> Do they have talents in ethics?
12:47:03 <monochrom> I mean I avoid stack too but I don't say "ethical reason".
12:47:12 <freeman42x[m]> maerwald: of course they justified it. They are engineers not irrational people
12:47:16 <maerwald> LOL
12:47:35 <freeman42x[m]> they might say it is unehtical is a humorous manner also, can't tell Poe's Law :)
12:47:57 <monochrom> I know talented mechanical engineers who found how to square a circle with only straightedge and compass.
12:48:17 <monochrom> I know some others who disproved FLT.
12:48:57 <ja> what's flt?
12:49:04 <monochrom> I know talented singers who "know" vaccines cause problems.
12:49:09 <monochrom> Fermat's last theorem
12:49:09 <ja> aah fermat's last theorem!
12:49:23 <dmwit> Faster than Light Travel
12:49:29 <dmwit> It is okay to disprove this in my book.
12:49:46 <freeman42x[m]> monochrom: it seems you do not understand that examples that are not representative of the whole can not be used to disprove general statements about the whole...
12:50:06 <maerwald> freeman42x[m]: I think what many engineers get wrong is that the tool you use for development doesn't have to be the same for deployment
12:50:15 <monochrom> Mine are not examples.  Mine are counterexamples.
12:50:25 <freeman42x[m]> anyway, this is offtopic for the channel. I created an issue to create a blog post for this so I do not have to keep having same discussion again and again: https://github.com/razvan-flavius-panda/blog/issues/30
12:50:35 <monochrom> Counterexamples destroy universally quantified implicative statements alright.
12:50:53 <freeman42x[m]> monochrom: if you think you made a point, you do not understand what i just explained
12:51:19 <monochrom> OK that's more fair then just saying I got logic wrong.
12:51:34 <srk> freeman42x[m]: +1 to Nix+cabal & blogpost, I do find stack redundant and problematic 
12:51:39 <srk> also yaml pls
12:52:17 <maerwald> yaml is better than this hugely custom cabal format, in fact :)
12:52:18 <tdammers> I can think of a couple of reasons against using stack, but most of them have nothing to do with ethics
12:52:36 <srk> maerwald: cabal eDSL needed
12:52:43 <maerwald> Formatting cabal file takes a completely customly written parser
12:52:47 <maerwald> You can't reuse anything
12:52:59 <maerwald> Rust did it right: pick toml
12:53:04 <maerwald> don't do weird stuff
12:53:05 <srk> right - I like this idea https://breaks.for.alienz.org/blog/2012/12/17/cabal-a-haskell-edsl/
12:53:17 <freeman42x[m]> srk: that is my position also: stack was very useful in 2015 to push the cabal-install devs forward on features, usability etc. but currently stack does little better than just cabal-install and it is so bug filled that... I do not want to get into how much time I wasted on failed stack builds
12:53:48 <tdammers> a bigger issue I have with stack is that it makes you commit to an entire snapshot of the library ecosystem wholesale
12:53:51 <maerwald> tdammers: I think it might be unethical to waste freeman42x[m]s time, so then the argument would check out!
12:54:05 <monochrom> haha
12:54:58 <frdg> https://pastebin.com/K3RpyreX syntax related question
12:55:08 <petrus> Cale: thanks for the paper, that would definitely need much time. I jumped to chapter 13 for a test reading, was like looking at some familiar landscape through thick fog.
12:55:15 <f-a> while reading https://www.tweag.io/posts/2020-04-16-exceptions-in-haskell.html, ¬´They are [...] named [imprecise] because it is not determined which exception will be thrown by (error "foo") + (error "bar")¬ª. I thought that by looking at the definiton of a function, we would know which `error` gets thrown. How is it that we are not sure?
12:55:28 <tdammers> more often than once, I have been in a situation where I needed to upgrade one of my dependencies to get access to a new feature, but as a result, I had to also upgrade GHC, and as a result of that, I had to upgrade the stackage snapshot version, and as a result of THAT, I had to upgrade 20 other dependencies, and find replacements for 6 dependencies that would have compiled just fine against the new
12:55:31 <tdammers> situation had I been using cabal
12:55:53 <tdammers> so I ended up rewriting the HTTP client code in one project just because I wanted to use a new Aeson feature
12:56:08 <monochrom> frdg: I don't know but perhaps you mixed up types with terms.
12:56:48 <monochrom> Since a legal term is Pair 5 6, you aren't going to call both 5 and 6 "a".
12:57:22 <solonarv> f-a: in something like 'error "foo" + error "bar"', you might expect that the exception you get is the one thrown by whichever of 'error "foo"' or 'error "bar"' is evaluated first
12:57:40 <solonarv> and this is probably correct, but you do not know which one gets evaluated first!
12:57:41 <dmwit> cabal predates toml by about a decade. yaml was young and not clearly a winner yet. json is not a good choice for what cabal needs, independently of its creation date.
12:57:53 <monochrom> Also perhaps "data Pair a = MkP a a" to begin with.
12:58:00 <maerwald> tdammers: gentoo has a stable and an unstable branch. In the unstable branch people don't generally do: 1. testing reverse dependencies, 2. checking that stuff compiles on all platforms
12:58:09 <maerwald> stackage could have been that too
12:58:10 <frdg> monochrom: yes I think I see. In the `stuff before the where` were talking about types but once we are `after the where` were talking about terms
12:58:16 <maerwald> so both rolling, but one tested
12:58:22 <frdg> I see the issue
12:58:25 <solonarv> because haskell does not have a defined evaluation order. so you *cannot* know which one gets evaluated first.
12:58:27 <maerwald> you don't need "releases" to be stable
12:58:29 <tdammers> maerwald: but stackage never tried to be that
12:58:56 <dmwit> f-a: Can you show me the definition of +, please, so that I can know which error gets thrown?
12:58:56 <monochrom> What are the advantages of toml over yaml?
12:58:57 <maerwald> And in software, IMO, you should always be rolling
12:59:26 <maerwald> monochrom: no weird indenting, I get eye cancer
12:59:38 <monochrom> Hrm!
12:59:44 <dmwit> monochrom: toml does not try to guess the type of the thing, so you don't accidentally get a boolean true where you were expecting the string "true", e.g.
13:03:26 <monochrom> This is a tough choice.  Because *.cabal isn't known for "strings must be quoted" either.
13:03:46 <dmwit> f-a: (Alternate answer: I define `Just x + Just y = (); _ + _ = ()`. Which error does `error "foo" + error "bar"` throw, given this definition? Why?)
13:04:52 <dmwit> monochrom: No. But the type is always clear from the context; strings need not be quoted but this can't cause a problem because there are no contexts where both bools and strings could rightfully appear.
13:04:57 <sclv> saying "if you have yaml you have a prewritten parser" doesn't solve anything
13:05:18 <sclv> that's like saying "if you  have s-expers you have a prewritten parser"
13:05:27 <sclv> it just solves the easy part  -- parsing into an unstructed mess
13:05:34 <Nilgeist> Weird question, do haskellers generally put their closing brackets on new lines?
13:05:42 <sclv> the "real" parsing is turning that into the desired structure with actual semantics
13:05:53 <f-a> solonarv: dmwit: right, I understand it now. I guess I had (||) in mind (which would `foo` it without exceptions, right?)
13:05:55 <solonarv> Nilgeist: sometimes
13:06:04 <sclv> "general purpose" things like yaml, toml, json arguably don't give you "parsers" at all
13:06:09 <sclv> they just give you overpowered lexers
13:06:52 <dmwit> f-a: Certainly not all functions require the fanciness of imprecision. But since some do, we must have fanciness.
13:06:57 <maerwald> sclv: and you get all sorts of stuff for free. Formatting, syntax checking, schema validation, ...
13:07:15 <maerwald> try all that with cabal-the-format
13:07:48 <sclv> you don't need the latter since it parses it _into_ the schema
13:07:59 <sclv> nor "syntax checking" since thats literally what a parser does
13:08:14 <sclv> and the formatting you get is wrong since it reorders stuff that in a domain specific stuff you don't want to reorder
13:08:29 <maerwald> What?
13:08:33 <sclv> so really what you get are "tools that make it slightly closer to an honest parser, if you add a bunch more information like schemas"
13:08:55 <merijn> maerwald: Would YAML give you those things, though?
13:09:10 <merijn> maerwald: Last I checked not a single YAML implementation actually matched any other
13:09:35 <merijn> maerwald: Look at how many buggy broken implementations of YAML exist: https://matrix.yaml.io/
13:09:58 <monochrom> I have a cunning plan!  Use windows ini format.
13:10:06 <merijn> Not to mention: 1) yaml is a ridiculously overcomplicated and unnecessarily ambiguous format
13:10:13 <monochrom> squid does it, we can to.
13:10:16 <merijn> monochrom: Honestly, ini files are a million times better than yaml
13:10:16 <monochrom> err, too!
13:10:32 <maerwald> merijn: I don't use yaml, unless I'm forced to
13:10:45 <maerwald> sclv: formatting isn't just about reordering.
13:10:51 <maerwald> Or rather: not tat all
13:11:12 <monochrom> Is there a windows-ini parser (super-lexer if you prefer) on Hackage? :)
13:11:46 <monochrom> Hrm I can ask hackage.  Sorry!
13:12:08 <maerwald> Also, once you defined your own file format, you tend to make it overcomplicated. Bc it's just so convenient to add more stuff to the grammar. But you don't really need it.
13:12:11 <monochrom> Oh there are.  The stage is set!  The time is ripe!
13:12:41 <Nilgeist> Some of the rust community is adopting RON; making your own format is hip
13:12:50 <maerwald> I can't imagine anyone arguing that the cabal file format is simple. If that was the case, there surely would be more tools around it
13:13:39 <monochrom> I don't think FOSS programmer self-esteem works that way.
13:13:45 <maerwald> It seems the only ones written are written by the main cabal dev =)
13:13:57 <merijn> maerwald: It is simple, though. I wrote a parser for most of it in like 70 lines of code, it's about as simple/straightforward as it can be
13:14:27 <maerwald> merijn: did you run it over all of hackage?
13:14:40 <merijn> Everything is labelled fields of labelled blocks, there's only like 8 different field types
13:14:47 <monochrom> I don't think "most of it" works that way either.
13:15:11 <merijn> monochrom: I only needed a very specific sub part so I didn't see a reason to write a full one
13:15:14 <monochrom> Every YAML implementation does "most of it" too.  That's where the problem lies!
13:15:31 <merijn> maerwald: There's not many parsing tools for cabal files because there's not many reasons to programmatically touch them
13:15:33 <monochrom> Fair but you can't deduce "simple" out of that.
13:15:45 <fresheyeball> hey out there
13:15:51 <merijn> monochrom: I had to stare at the spec to write it and I can deduce "simple" from that :p
13:15:55 <fresheyeball> I have a desire for something.. applicativeish
13:15:58 <monochrom> OK!
13:16:01 <maerwald> merijn: I want a configurable formatter. If it was toml... I wouldn't even want one ;)
13:16:11 <maerwald> Bc what's the point in formatting toml
13:16:27 <fresheyeball> data Foo f = Foo { bar :: f Int, baz :: f String } deriving Generic
13:16:58 <zincy_> If I want to do a bit of math solely for the purposes of computer science, should I just start with discrete maths?
13:17:00 <monochrom> Wait, is toml basically ini plus multi-line strings?
13:17:03 <merijn> maerwald: What's there to configure, really? Like, vim's regular auto-indent covers 90% of what I need to format in a cabal file. What's missing that you so desperately need?
13:17:14 <merijn> zincy_: Yes
13:17:25 <merijn> zincy_: In my opinion anyway :p
13:17:26 <fresheyeball> newtype G a = G (a -> Maybe a)
13:17:35 <fresheyeball> gfoo :: Foo G
13:17:38 <maerwald> merijn: tabs vs spaces!!!11
13:17:43 <fresheyeball> afoo :: Foo Idenity
13:17:47 <zincy_> merijn: Cheers
13:17:59 <zincy_> I just want to get comfortable with proofs
13:18:00 <fresheyeball> applyFoo :: Foo G -> Foo Identity -> Foo Maybe
13:18:13 <fresheyeball> If that made any sense
13:18:13 <merijn> maerwald: Is that really a daily problem? If so, wtf are you doing with your cabal files?
13:18:18 <maerwald> :D
13:18:20 <fresheyeball> I want to do something like a field wise application
13:18:33 <merijn> maerwald: If you want spaces, use spaces, if you want tabs, use spaces
13:18:36 <hseg> chapter n of my debugging saga. i've tried unsuccessfully to isolate the part of the code exhibiting the error. unfortunately, the code in question is pretty dependent on the rest of the project
13:18:37 <fresheyeball> ideally through Generics so I don't have to write functions like ApplyFoo
13:18:43 <maerwald> merijn: haha
13:18:47 <merijn> If someone PRs something with tabs, tell them to fix their PR and their brain
13:19:10 <EvilPyro> can someone tell me what I'm doing wrong in this instance? https://pastebin.com/e2AM0L5r I'm trying to redefine show for a data type
13:19:25 <merijn> maerwald: I was going to write "if you want tabs, use tabs", but then I remembered that people who want tabs are evil
13:19:38 <hexagoxel> lets invent a toml-based package description language that translates to package.yaml!
13:19:46 * hexagoxel giggles
13:19:55 <merijn> EvilPyro: "Owner" is not a constructor of Owner
13:20:06 <merijn> EvilPyro: Just replace "(Owner a)" with "a"
13:20:19 <maerwald> hexagoxel: The might actually be a fun project to experiment with obscure libraries
13:20:33 <merijn> EvilPyro: Also, calling show on a String is redundant and using a non-derived Show implementation is widely considered bad
13:20:36 <hseg> but project is ~2kloc, which is way too much to paste
13:21:07 <monochrom> EvilPyro: What merijn said holds for all functions you will write of type "Owner -> ..." too.
13:21:14 <maerwald> hexagoxel: and not that hard, because you would just support a subset of package.yaml
13:21:28 <maerwald> I think I'm sold on that idea.
13:21:55 <hexagoxel> maerwald: yeah I tried to talk nonsense, but outputting to yaml might in fact make this easier than outputting to whatever cabal has as format.
13:22:00 <hseg> at this point i regret borking my vcs history
13:22:03 <merijn> maerwald: Don't go making the ecosystem even worse >.<
13:22:17 <hseg> but have no practice using vcs for initial project development
13:22:51 <monochrom> And I'm adding ini to the mix.
13:23:00 <EvilPyro> merijn, https://pastebin.com/JUV2CAEx still doesnt work, I just want to output a list of Owners in a matrix-like style (given a row length) and thats the best idea I've managed to think xD
13:23:36 <monochrom> And it is not an ini until the file has \r\n even on unix :)
13:24:20 <merijn> EvilPyro: "case a of", not "case a"
13:24:28 <maerwald> merijn: I think what we need is an interactive frontend to cabal. E.g. in a TUI you can have an action "add new module" and then have sane defaults (e.g. if there's only a library component, add it, otherwise ask)
13:24:31 <hexagoxel> maerwald: the name of the project needs to be tpack (pronounced teabag)
13:24:44 <maerwald> lol
13:24:53 <EvilPyro> merijn, damn, sorry and thankyou
13:25:01 <merijn> maerwald: For the initial creation that already happens, though?
13:25:17 <maerwald> Yeah, like... you know... 
13:25:19 <monochrom> Now non-default.
13:25:27 <maerwald> just proper :P
13:25:37 <merijn> maerwald: I await your PR to cabal-install ;)
13:26:14 <maerwald> I haven't done much ncurses stuff. I'd probably start with a simpler project first, trying that out
13:26:15 <monochrom> I think maybe I'll PR just switching the default back to --interactive or someething.
13:26:29 <maerwald> monochrom: it really confused me
13:26:58 <maerwald> I doubt anyone runs "cabal init" during CI
13:27:08 <maerwald> so interactive as default is fine
13:27:10 <monochrom> This is one of those attitudes of stack that I am against.
13:27:51 <monochrom> conflating "just works" with prejudiced presumption.
13:28:16 <solonarv> it confused me as well
13:28:40 <monochrom> Roast: "one size fits all" is true of stack because stack attracts unthinking users only.  Change my mind.
13:29:36 <tdammers> "just works" is fine if it actually delivers 100%
13:29:51 <tdammers> "just works, except when it doesn't" is most definitely NOT fine
13:30:19 <tdammers> the things that cabal, stack, nix, etc. do are not things I necessarily WANT to think about
13:31:04 <tdammers> but given the choice between thinking about them in order to make them work, and being at the mercy of a tool that attempts to do the thinking for me but doesn't always get it right, well...
13:31:43 <maerwald> so you chose nix
13:32:57 <tdammers> I tried to choose nix
13:33:02 <tdammers> I really wanted to
13:33:18 <maerwald> It's a full-time job :)
13:33:26 <maerwald> So yes, you should hire a nix engineer
13:34:08 <maerwald> And then it's fine
13:34:12 <tdammers> the first sign that nix wasn't for me was when it asked for `/nix`, and I said, no, you moron, you don't belong in `/`, nobody belongs in `/`, your files go in `/usr/local/var/nix`, but of course that cannot possibly work
13:34:24 <Nilgeist> nix is a hard sell for a default package manager; it
13:34:31 <Nilgeist> it's a bit complicated *
13:34:48 <tdammers> Nilgeist: it's an even harder sell for a special-purpose package manager
13:35:19 <maerwald> Nilgeist: my main problem is that it conflates configuration and packaging. Both is in the same language and more or less on the same level. There's literally no abstraction, there's just stuff.
13:35:22 <tdammers> there is also not such a thing as a single-user install; the closest thing you can get is an install where no other user can install or use nix at all
13:35:52 <olavx200> Hello. I have a problem with installing ghc on macOS. When I run curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh I get errors. https://bpaste.net/ZRZQ
13:35:59 <tdammers> then there's the fact that apparently it is considered reasonable to learn an entire programming language just to configure you OS - a programming language that is never ever going to be useful for anything else
13:36:13 <hexagoxel> I am stuck where I don't want to do dev without features that I associate with nix, but I struggle to make anything work with nix at the same time.
13:36:48 <hexagoxel> (and a language that is untyped as of now)
13:37:15 <maerwald> olavx200: that's a new one. What does 'ghcup upgrade' do?
13:37:16 <tdammers> "as of now"? I don't think it will even be typed
13:37:25 <tdammers> I ran a nixos VM for a while to see if I could get to the point where things start making sense and I actually understand enough of it
13:37:49 <tdammers> but nobody ever teaches you to fish, they just keep giving you fishes. truckloads of them. no idea where they find them.
13:38:01 <olavx200> > fossegrim: that's a new one. What does 'ghcup upgrade' do?
13:38:01 <olavx200> It is not installed
13:38:03 <lambdabot>  <hint>:1:56: error:
13:38:03 <lambdabot>      Unexpected do block in function application:
13:38:03 <lambdabot>          do
13:38:16 <maerwald> olavx200: source ~/.ghcup/env
13:38:23 <maerwald> then: ghcup numeric-version
13:39:12 <olavx200> source ~/.ghcup/env && ghcup numeric-version
13:39:15 <olavx200> => 0.1.4
13:41:17 <maerwald> olavx200: is there something ins ~/.ghcup/logs?
13:41:55 <olavx200> Two files. ghc-configure.log  and ghcup.log
13:42:01 <maerwald> can you pastebin them
13:42:16 <hseg> any way of getting ghc to spit out the actual instance it's trying to generate in a deriving clause?
13:43:04 <hseg> because newtype N = N (T ...) deriving S and deriving via (T ...) instance ctx => S (N ...) seem to have different behaviours
13:43:34 <hseg> where ctx is my best guess at the context GHC gives the newtype instance
13:44:30 <c_wraith> hseg: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/debugging.html#ghc-flag--ddump-deriv does that do the job?
13:44:35 <olavx200> maerwald: https://bpaste.net/VZRA
13:45:23 <hseg> nope. because ghc dies *before* -ddump-deriv runs
13:45:59 <hseg> i.e. i'm getting "Could not deduce ... arising from the 'deriving' clause of a data type declaration" even with ddump-deriv
13:46:02 <maerwald> olavx200: echo $PATH pls
13:46:09 <maerwald> I think you have a binary in your PATH
13:46:25 <maerwald> yes, the code doesn't handle that :)
13:46:26 <hseg> is there some analog of -defer-type-errors that could help here?
13:46:42 <olavx200>  /Users/olav/opt/anaconda3/bin:/Users/olav/opt/anaconda3/condabin:/Users/olav/.rbenv/bin:/Users/olav/go/bin/golint:/Users/olav/.rbenv/shims:/Users/olav/.rbenv/bin:/Users/olav/.nix-profile/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Applications/Postgres.app/Contents/Versions/latest/bin:/Users/olav/.scripts:/Users/olav/.local/bin:/snap/bin
13:46:48 <maerwald> yes
13:46:51 <maerwald> see
13:46:53 <maerwald> golint
13:46:55 <maerwald> is a binary
13:47:13 <maerwald> Ofc it's a bug, but yeah, just remove it
13:48:42 <maerwald> afterwards just rerun the curl .. | sh thing
13:49:53 <olavx200> What shall I remove?
13:50:25 <maerwald> /Users/olav/go/bin/golint should probably be /Users/olav/go/bin
13:50:41 <maerwald> PATH is for directories
13:51:34 <olavx200> Thats right
13:51:42 <maerwald> interesting bug though
14:03:28 <monochrom> Fishing is unenvironmental, be it teach-to-fish or give-fish.  We need to switch to setting-on-fire.
14:04:10 <monochrom> But I should have put that in #haskell-offtopic. Blah.
14:05:37 <maerwald> Is the channel dead?
14:05:39 <hseg> *facepalms* -ddump-deriv -fdefer-type-errors gave me the data i was looking for
14:05:51 <hseg> now to see whether i can figure out what's wrong from that
14:05:55 <monochrom> No, it's pretty alive.
14:06:21 <maerwald> olavx200: did it work?
14:06:52 <olavx200> I'm still in the process.
14:07:24 <olavx200> Had some problems unrelated problems.
14:14:31 <EvilPyro> Is this channel intender for newbie questions? I dont understand what I'm doing wrong https://pastebin.com/R4Gkbixp
14:15:28 <solonarv> EvilPyro: newbie questions are fine here, yes
14:15:34 <ski> yes, EvilPyro
14:15:36 <monochrom> Both beginner questions and advanced questions are fine.
14:16:13 <monochrom> But you need to say what's wrong.
14:16:18 <berndl> EvilPyro: Why no pattern matching on l?
14:16:24 <ski> EvilPyro : presumably, `show Grid(w h (drop w l))' should be `show (Grid w h (drop w l))' ? (bracket in wrong place)
14:16:49 <ski> EvilPyro : `foldl show' is not going to work
14:17:09 <solonarv> expanding on the brackets thing: in haskell, brackets are not syntax for function calls
14:17:13 <solonarv> they are just used for grouping
14:17:24 <ski> EvilPyro : also, imho, this code shouldn't be put into a `Show' instance, in the first place
14:18:18 <wildtrees> EvilPyro, I don't think you need the foldl 
14:19:15 <solonarv> indeed you don't; you *can* use foldl here to do something sor tof useful, but that's an overly convoluted way of going about it
14:19:24 <solonarv> and the way you used it is simply not correct at all
14:19:28 <EvilPyro> I know its not the best approach, but its what I've been instructed, this is for an assigment where i define a project myself and the teacher then tells me what can me archieved better
14:19:38 <ski> EvilPyro : minor point, instead of using `take w l' and `drop w l', you could add to the end `where (row,rest) = splitAt w l', and then use `row' and `rest' in place of the former two. this would avoid doing the traversal over the first `w' elements twice
14:20:48 <ski> EvilPyro : `foldl' expects a function argument (a callback) that it can feed two input arguments to. `show' only expects one (before giving a `String'). that's why `foldl show' doesn't work
14:20:59 <EvilPyro> ski, I think i got error when using where after guards idk, i'll try later
14:21:01 <gentauro> so I moved from `package.yaml` to `package.cabal` based on https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07. There only one thing that annoys me and that is that `name: package` can be changed unless you also change the filename
14:21:21 <gentauro> my problem with my `template` approach, is that all my build are no `packages` :|
14:21:31 <gentauro> s/no/now/
14:21:38 <ski> EvilPyro : it should be okay, as long as you indent it more than the start of the whole defining equation of the operation (here `show')
14:21:41 <EvilPyro> Oh i understand, so fold has two args and I'm assigning show that only has one
14:22:17 <gentauro> can anybody explain why the package name needs to be the same as the file name?
14:22:21 <gentauro> in advance thx
14:22:29 <EvilPyro> i mean the func passed to fold needs two args, not one like show
14:22:33 <ski> EvilPyro : no, the problem is that `foldl' expects (as first argument) a function that can accept two arguments. but you're passing `show' as first argument, and it only accepts one argument
14:22:37 <ski> yes
14:22:50 <solonarv> gentauro: presumably it is a similar reason to the "module name must match file name" rule for haskell source files
14:23:13 <hseg> found my impedance mismatch, unless i'm very much mistaken!
14:23:25 <ski> EvilPyro : btw, an alternative design would be `data Grid a = Grid Int Int [[a]]'
14:23:27 <gentauro> solonarv: I would buy that arugment if there were many `.cabal`, but there is only one per project (unless I'm mistaken)
14:23:35 <solonarv> there can be many
14:23:52 <gentauro> btw, `other-modules: Paths_package` can I remove this?
14:23:57 <solonarv> each .cabal describes one package, a project (configured by 'cabal.project') can contain an arbitrary number of packages
14:23:59 <sm[m]> gentauro: practically speaking, because that's how it has been and will be.. why it was designed that way I'm not sure, since you can't have multiple .cabal files in a directory. Right
14:24:15 <merijn> gentauro: No, you can't remove it
14:24:17 <gentauro> I have no clue of what it is (redundant?) I mean, if I manually don't all all my modules, the project will not build
14:24:17 <EvilPyro> ski,  then how can i achieve that? maybe i can use map instead of fold and then ++ with fold to merge the resulting [[String]] ?
14:24:20 <gentauro> :(
14:24:22 <solonarv> you can remove the Paths_package entry if you are not using the Paths_ module, yes
14:24:45 <merijn> solonarv: That seems unlikely, though if it's in there ;)
14:24:46 <solonarv> it is generated by cabal automatically and exports a few constants and functions
14:24:56 <ski> EvilPyro : there is a function called `concat', which might be useful. perhaps you could also check `intersperse' and `intercalate'
14:25:00 <hseg> what's going on is that i have a chain of deriving vias: data W; newtype P; newtype T; class G (U r) => S r; instance G (U W); instance S r; deriving via W instance S P; deriving via P instance S T 
14:25:13 <solonarv> one of the constants is your package version (useful for e.g. displaying in a --help or --version message)
14:25:16 <gentauro> sm[m]: many cabal files? That differs from stack. Could you provide an example on why/how it's useful
14:25:24 * gentauro still in the learning process
14:25:26 <ski> > concat [[],[0],[1,2],[3,4,5],[6,7,8,9]]
14:25:29 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
14:25:49 <merijn> gentauro: cabal.project files are for orchestrating the development of multiple packages depending on each other
14:25:51 <sm[m]> I think you misread me maybe. I was agreeing with you
14:25:57 <solonarv> and the functions tell you what the data directories (XDG and so on) for your package are
14:26:28 <ski> > intersperse [-1] [[],[0],[1,2],[3,4,5],[6,7,8,9]]
14:26:28 <solonarv> and btw, stack/hpack also supports multiple-package-one-project.
14:26:30 <lambdabot>  [[],[-1],[0],[-1],[1,2],[-1],[3,4,5],[-1],[6,7,8,9]]
14:26:32 <gentauro> merijn: my project are pretty simple and basic :)
14:26:39 <gentauro> I want to keep them like that :)
14:26:41 <ski> > intercalate [-1] [[],[0],[1,2],[3,4,5],[6,7,8,9]]
14:26:44 <lambdabot>  [-1,0,-1,1,2,-1,3,4,5,-1,6,7,8,9]
14:26:48 <monochrom> But not to the point of multiple *.cabal per directory.
14:27:20 <merijn> gentauro: You can't always, though
14:27:22 <gentauro> sm[m]: roger
14:27:26 <ski> EvilPyro : see examples ^
14:27:29 <monochrom> OTOH I wouldn't spend so much time and mind and effort on "why???!!!!"
14:27:34 <solonarv> indeed. but perhaps there is some way to say "actually, you should look at thatpackage.yaml instead of package.yaml")
14:28:47 <hseg> ... that should be deriving via P instance S P => S T
14:29:04 <gentauro> I guess I recall that a cabal file was generated from the package.yaml with the name of the package
14:29:07 <merijn> gentauro: Personal example: https://github.com/merijn/broadcast-chan that repo has 2 packages depending on broadcast-chan. So if I've changed broadcast-chan for a new version release/etc. I need the other two packages to depend on the (unreleased) package in my repo NOT the version from hackage, because if it did that I could never test/develop against the new version
14:29:13 <monochrom> Explicit listing vs auto-discovery of modules though is going to be a perpetual debate lasting beyond the demise of our sun.
14:29:14 <gentauro> so maybe there is something about it
14:29:39 <maerwald> there are already 2 ways of auto discovery with cabal
14:29:43 <monochrom> Because programmers are just going to bash and trash any use case they themselves don't care about.
14:30:01 <gentauro> monochrom: my packages have very few modules, so I can live with adding them to .cabal
14:30:13 <hseg> this works because the S P instance pulls in the G (U P) constraint, which (given a G (U P) => G (U T)) instance permits the S T instance to match
14:30:33 <maerwald> monochrom: https://oleg.fi/gists/posts/2019-08-11-cabal-fmt.html cabal-fmt has annotation to auto-expand
14:30:34 <gentauro> I was just not getting any sense of `Paths_package` (unless it was to auto-add-modules, but it isn't)
14:30:47 <EvilPyro> ski, I think I've improved the code with all you said but I'm not sure what's failing now: https://pastebin.com/RrRvggfE
14:31:24 <gentauro> merijn: so you can have nested builds
14:31:24 <merijn> gentauro: Paths_package is generated by cabal so you can reference the version of your package from the code and lookup data files, etc.
14:31:27 <gentauro> that pretty nifty
14:31:28 <maerwald> phadej: your certificate for oleg.fi seems expired
14:31:34 <gentauro> s/that/that's/
14:32:19 <rednaZ> Indeed.
14:32:41 <merijn> gentauro: Not so much nested builds, but the cabal.project file ties the 4 packages in that repo together and makes them depend on the local versions in that repo, ignoring hackage (which is what you want for development), the cabal.project isn't needed for anyone simply using those packages, because they should be using the released hackage version anyway
14:33:21 <hseg> by contrast, newtype T = T (P ...) deriving S copies the P instance's constraints + head. in this case, the P instance discharges the G (U P) obligation at via other context, which prevents using the G (U P) => G (U T) instance
14:34:25 <merijn> gentauro: cabal files describe packages (what files do they contain, how do you build them, etc.) whereas cabal.project files describe specific build setups (like depending on unreleased versions or using specific flags), so the former are for other people to build your code and the latter are for you and contributors to build the code
14:35:10 <ski> EvilPyro : `row' has type `[a]', it's a list of `a's. you call `show' on each element, and so you require a constraint `Show a'. so you need to replace `instance Show (Grid a)' by `instance Show a => Show (Grid a)'
14:36:15 <ski> EvilPyro : also, you didn't stop making this a `Show' instance in the first place :)
14:36:36 <ski> (in case you've been instructed to do that, i would like to complain to your instructor)
14:38:23 <gentauro> merijn: so we are talking about one `stack.yaml` + many `packages.yaml` right?
14:38:27 <olavx200> The installation still does not work.
14:38:34 <gentauro> so that would be the next step (going all the way)
14:38:38 <maerwald> olavx200: show error
14:38:47 <olavx200> Now I get ghcup: <file descriptor: 12>: hPutBuf: resource exhausted (No space left on device).
14:38:59 <maerwald>  /tmp is full
14:39:09 <maerwald> too bad, we need some space
14:40:01 <solonarv> gentauro: yes, that is a valid setup (although of course the package.yaml files have to be in different directories)
14:40:06 <merijn> gentauro: Stack.yaml doesn't really relate at all. It configures what snapshot to use, etc.
14:40:10 <EvilPyro> sky,  it works like a charm! The problem is the project I've chosen its far beyond my haskell level, thats why I've been told to use Show, because the teacher didnt expect my project to require formating
14:40:16 <monochrom> It is not everyday that we run into disk full these days. :)
14:40:20 <merijn> gentauro: Not to mention stack doesn't even require you to use package.yaml
14:40:32 <olavx200> I don't understand how can /tmp be full when the rest of my computer has space.
14:40:39 <olavx200> Is that its own device or something. :/
14:40:42 <EvilPyro> btw thankyou so much
14:40:44 <gentauro> merijn: that's true
14:40:53 <gentauro> and that's the reason I'm using .cabal files now :)
14:41:11 <gentauro> (why add extra overhead if the .cabal is generated from the package.yaml anyway)
14:41:19 <gentauro> I would rather just write it myself :)
14:41:24 <maerwald> olavx200: maybe
14:41:33 <hseg> olavx200: on most linux boxes, yes - it's allocated a set amount of ram space
14:41:33 <maerwald> olavx200: so you're saying your HOME has enough space?
14:41:37 <ski> EvilPyro : what i would be suggesting, instead of `instance ... Show (Grid a) ...' is to simply define a function, with signature `display :: Show a => Grid a -> String', and whose body is what you're now putting inside `show'
14:41:49 <gentauro> merijn: I just `stack.yaml` to point to my local project like this -> https://gitlab.com/uniprocess/haskell-template/-/blob/master/stack.yaml#L9-16
14:42:06 <gentauro> so I use one `stack.yaml` and my `package.yaml` in the same build
14:42:08 <maerwald> olavx200: if you set TMPDIR to something, ghcup will use that as the temporary dir
14:42:20 <gentauro> so that's why I asked if it was similar to your suggestion
14:42:31 <olavx200> > fossegrim: on most linux boxes, yes - it's allocated a set amount of ram space
14:42:31 <olavx200> If it is saved in ram on macOS too closing some programs might fix it. I will try that.
14:42:33 <lambdabot>  <hint>:1:31: error: parse error on input ‚Äò,‚Äô
14:44:52 <olavx200> > fossegrim: if you set TMPDIR to something, ghcup will use that as the temporary dir
14:44:52 <olavx200> That just made the installation crash instantly :/
14:44:54 <lambdabot>  <hint>:1:42: error: parse error on input ‚Äò,‚Äô
14:45:06 <monochrom> What the hell is fossegrim?
14:45:26 <olavx200> I will try installing it on my linux box instead?
14:45:28 <maerwald> olavx200: mkdir "$HOME/.tmp" && TMPDIR="$HOME/.tmp" curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
14:45:32 <maerwald> try that
14:46:04 <maerwald> then afterwards feel free to clean up "$HOME/.tmp"
14:46:36 * monochrom flips through the length POSIX spec to determine whether the TMPDIR=stuff scopes over the "sh".
14:47:14 <hseg> olavx200: btw, might be useful to run df to find out whether /tmp is getting full
14:47:15 <monochrom> (That's a lie.  I'm only checking my own notes. :) )
14:47:34 <olavx200> maerwald: Doesn't work. I will be satisfied with an installation on my Linux box for now.
14:47:34 <hseg> by default, /tmp is allocated half your ram
14:47:48 <olavx200> Thanks for the help guys.
14:48:08 <gentauro> monochrom: why POSIX when you can go ASM :) -> https://www.youtube.com/watch?v=fpEwOXzYBi8
14:48:20 <gentauro> monochrom: http://menuetos.net/docs.htm
14:48:20 <monochrom> Ah exactly, "X=v prog1 | prog2" prog2 does not see X=v.
14:48:27 <maerwald> oh
14:48:37 <maerwald> so: prog1 | X=v prog2
14:48:44 <monochrom> Yeah that's better.
14:48:45 <maerwald> olavx200: ^
14:49:00 * monochrom hard work pays off!
14:49:23 <maerwald> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | TMPDIR="$HOME/.tmp" sh
14:49:31 <maerwald> remote code execution... live
14:49:38 <olavx200> > What the hell is fossegrim?
14:49:38 <olavx200> It is a norwegian folklore creature which also happens to be my pseudonym on the internet.
14:49:40 <lambdabot>  <hint>:1:28: error:
14:49:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:51:35 <monochrom> gentauro, I'm sorry but I'm not interested.
14:51:54 <hseg> ... wait. testing my hypothesis, still can't reproduce. however, am getting interesting data
14:51:58 <gentauro> monochrom: I just saw it today
14:52:12 <gentauro> I fInd it kind of amazing that they can put all of that in 1.4Mb :o
14:52:24 <hseg> what is the difference in -ddump-deriv output between coerce @({P} n a -> {P} n a) and coerce @(P n a -> P n a) ?
14:52:32 <gentauro> (probaly off-topic so I will not say anithing else, but I just say the POSIX stuff)
14:54:14 <maerwald> I think mkdtemp on mac doesn't produce semi-predictable filenames, while on linux, it does
14:54:57 <maerwald> https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Temp-ByteString.html#v:mkdtemp
14:55:05 <maerwald> the first argument is ignored on mac I think
14:56:06 <monochrom> yikes
14:56:29 <maerwald> because on linux you can: rm -r /tmp/ghcup-*
14:58:37 <monochrom> Oh, 0.1.4 already.  Do you recommend upgrading from 0.1.3 to 0.1.4?  Or do you say "dude ghcup list says recommended, what do you think?" :)
14:59:18 <maerwald> yeah, there was a bug: https://gitlab.haskell.org/haskell/ghcup-hs/-/blob/master/CHANGELOG.md#014-2012-04-16
14:59:39 <monochrom> \‚à©/
15:01:01 <hseg> ok, judging by the ddump-deriv output, the only difference between my erroring case and the nonerroring case is that the error has @({P} ...) applications whereas the nonerroring case has @(P ...) applications 
15:01:06 <hseg> what do the {} signify here?
15:02:11 <yushyin> maerwald: interesting release date ^^
15:02:50 <maerwald> lol
15:03:05 * maerwald hides his time machine
15:04:30 <hseg> ... any ideas what the braces signify in coerce @({P} n r) ?
15:05:00 <hseg> can't find them documented anywhere
15:05:16 <solonarv> I think it's something about visibility(?) or availability for type applications(?)
15:05:35 <hseg> ok... but that's for tyvars, no?
15:05:49 <hseg> what would this signify for P a type constructor?
15:06:14 <hseg> and what would be able to affect it?
15:06:37 <hseg> i'm suspecting backpack, but i've backpacked the test case as well
15:07:10 <hseg> unless cabal is eagerly resolving the signature application in the test case due to simplicity?
15:07:50 <solonarv> yeah I have no idea what's going on here either
15:10:18 <hseg> oh wait. i think i made a mistake in my test code...
15:11:06 <hseg> aha!
15:11:14 <hseg> yes, backpack is to blame here!
15:12:37 <hseg> all of the above was a red herring, what's really going on is that i need to be able to write a backpack module signature asserting G (U P), where G :: * -> Constraint, P :: *; U a type family
15:14:24 <hseg> ... unfortunately, one cannot declare instances of type families
15:14:30 <hseg> misspoke
15:14:48 <hseg> meant "one cannot declare applications of type families to be instances of typeclasses"
15:15:25 <monochrom> I thought FlexibleInstances would allow it.
15:15:30 <hseg> nope
15:17:15 <hseg> weird though. what breaks if one allows it?
15:17:58 <monochrom> I don't know.
15:18:57 <hseg> https://stackoverflow.com/a/2591220
15:18:57 <monochrom> Oh, overlapping instances is a possible consequence.
15:19:31 <hseg> seems it's more due to the fact that current tyfam semantics assume you can eagerly rewrite them
15:20:26 <hseg> however, here i don't care what the actual U P type is, just that whatever it is, that it have a G _ instance
15:20:51 <hseg> however, the "obvious" fix to this is seriously overlapping: (t ~ U P) => G t
15:23:18 <hseg> i suppose i could require the module to export a Dict (G (U P)), but ghc can't make use of that in its derivation mechanisms
15:29:38 <hseg> ... or i could just punt on requiring the module signature to prove G (U P), and write a standalone deriving line whose given constraints entail G (U P)
15:29:40 <hseg> ... which is basically what my deriving via P instance S P => S T line was doing all this time
15:30:53 <hseg> hrm. pity we can't make passing around Dict values zero-cost
15:31:47 <hseg> any such mechanism would probably be able to solve the problem by forcing the Dict value at compile-time, bringing the G (U P) instance into scope
15:34:08 <maddo> \o
15:35:32 <hseg> o/
15:38:55 <hseg> will have to put a note in the .hsig file to this effect. ugh
15:39:56 <ski> hello maddo
15:55:51 <xsperry> hi. is there some language pragma that would let me auto derive Random class for a sum type?
15:59:30 <monochrom> I think no. Howevrer, you can derive Generic, and then you can write code that can make Random instances for all sum types that derive Generic. Similar to how aeson offers automated From/ToJSON instances for algebraic data types.
16:10:18 <hseg> given class C t => D t and instance D a => D (P a); shouldn't the context (D (P a)) be equivalent to (C a, D (P a)) ? 
16:11:06 <hseg> in particular, shouldn't deriving via _ instance (_, D (P a)) => be equivalent to (_, C a, D (P a)) => _ ?
16:14:53 <hseg> hrm. seems so.
16:15:35 <hseg> lambdabot: (==) :: Eq [a] => a -> a -> Bool
16:16:24 <hseg> :t (==) :: Eq [a] => a -> a -> Bool
16:16:26 <lambdabot> error:
16:16:26 <lambdabot>     ‚Ä¢ Could not deduce (Eq a1) arising from a use of ‚Äò==‚Äô
16:16:26 <lambdabot>       from the context: Eq a
16:17:16 <hseg> not conclusive, but good enough for me. surprising, though
16:17:21 <Uniaika> :t (==) :: Eq a => a -> a -> Bool
16:17:22 <lambdabot> Eq a => a -> a -> Bool
16:17:26 <Uniaika> yay
16:19:57 <xsperry> monochrom, that is out of my league. even my Random implementation seems sloppy, relying on Bool's implementation. any suggestion for improvement? https://pastebin.com/v46qbeCt
16:21:19 <xsperry> thinking about it though, I have to rely on some existing type with Random instance, and bool seems appropriate. suggestion for improvement is still welcome though
16:27:04 <frdg> https://pastebin.com/8bGU0PY3 functor related question
16:28:38 <frdg> ...sorry I made a huge typo 
16:29:48 <hseg> makes some sense, still odd
16:30:01 <hseg> eg note that this is fine
16:30:09 <hseg> :t (<>) :: Monoid a => a -> a -> a
16:30:10 <lambdabot> Monoid a => a -> a -> a
16:30:26 <hseg> difference being that
16:30:28 <hseg> :i Monoid
16:30:41 <hseg> :( lambdabot doesn't know that
16:30:57 <hseg> class Semigroup a => Monoid a
16:31:08 <solonarv> frdg: no, not possible - Functor only cares about the *last* type parameter.
16:31:13 <hseg> whereas instance Eq a => Eq [a]
16:31:48 <frdg> solonarv: ok thanks. hseg: Im not understanding the connection between functor and Monoids 
16:32:10 <hseg> i suppose that having every instance declaration trigger a search throughout the entire known instance space to check solvability would be massively inefficient
16:32:21 <hseg> frdg: ?
16:32:23 <solonarv> I'm not sure what coonection you expect to find, I certainly can't think of one
16:32:48 <hseg> don't mind me, i'm continuing my monologue from 10m ago
16:33:01 <frdg> hseg: ohhh ok haha I was confused
16:33:21 <monochrom> No connection. Client Quit. :)
16:34:13 <hseg> .... dammit. just realized that what i've learned today spells doom for the last bug left to solve
16:35:01 <hseg> hopefully there's some way around it
16:37:24 <hseg> have class HU t { type U }; instance HU P; newtype T = T P deriving HU. Obviously, U P ~ U T. How do I cash this in for a function U T -> U P ? 
16:37:52 <hseg> ... making matters a little worse is that the above is a lie
16:38:04 <hseg> in fact, P :: Nat -> * -> *
16:38:41 <hseg> and so GHC complains that my naive \x -> x has ambiguous type indeces
16:49:09 <hseg> ... well, at least -fdefer-type-errors also turns off ghc's eager error reporting
16:52:45 <jackdk> frdg: https://hackage.haskell.org/package/bifunctors-5.5.7/docs/Data-Bifunctor-Flip.html is as good as you're gonna get
17:02:25 <EvilPyro> how can i get a random element from a list [a] given an integer IO Int without returning IO a ? I dont want to contaminate all my source with IO types everywere...
17:02:35 <dmwit> Too bad.
17:03:07 <EvilPyro> really?
17:03:10 <dmwit> Yup.
17:03:17 <dmwit> If you do IO in the computation of a thing, the type's got to say so.
17:03:39 <dsal> Also, "random" and "list" don't mix well.
17:03:51 <dmwit> They mix fine for beginner code.
17:03:53 <EvilPyro> I hate that beheviour with all my soul
17:04:07 <dsal> Your soul can be saved
17:04:15 <Axman6> it's, like, literally one of the best features of Haskell
17:04:51 <EvilPyro> hope that doesn't mean i hate haskell xD
17:05:04 <monochrom> EvilPyro: See my http://www.vex.net/~trebla/haskell/IO.xhtml#organization
17:05:16 <Axman6> It means you don't understand the absolutely enormous benefits
17:05:33 <monochrom> Generating a random number, maybe even to go on to use it to pick out a randomly chosen element, belongs to IO alright.
17:05:54 <monochrom> Doesn't mean that the receiver of that randomly chosen element needs to be in IO.
17:06:06 <Axman6> BUT! there is an alternative - you can produce a ninfinite list of ranfom Ints in IP, and then pass that to your pure function. It'll still be IO at the top, but you only need IO for IO things, not everywhere
17:06:11 <dmwit> Well, it does mean that. But you can teach receivers that don't know how to handle IO how to handle IO.
17:06:23 <Axman6> :t randomRs
17:06:25 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
17:07:15 <Axman6> (Or, instead of a list, pass around a random generator)
17:08:04 <rednaZ2> :quit
17:08:16 <dsal> But don't quit.
17:08:39 <EvilPyro> just before i was starting to get work done ... i discover my codebase is trash. Nice
17:09:04 <monochrom> Better than after work is done.
17:09:11 <dsal> You'll discover this many more times before you can achieve perfection.
17:09:33 <dsal> monochrom: that's a neat way to describe that.
17:10:00 <dmwit> EvilPyro: I suspect you're being too dramatic.
17:10:15 <Axman6> You will continue to do this, until you recognise that all codebases are trash. They just doin they best
17:10:16 <dmwit> A very large, pure codebase can be lifted into IO with a single extra token.
17:10:34 <dmwit> So it is almost certain that what you have now is better reused than trashed.
17:11:20 <EvilPyro> dmwit, I'm a total beginer in haskell, I've been all day for just like 200 lines of code, which have a bad design since I just discovered now..
17:11:38 <dsal> Why would you expect to design well if you're a beginner?
17:11:42 <dmwit> EvilPyro: My claim is that you have not discovered that.
17:11:57 <Axman6> feel free to share the code (if you can, don't if it's homework)
17:12:14 <dmwit> EvilPyro: Although I gladly admit that you believe you have discovered that.
17:12:20 <monochrom> I think it took me a year to accumulate 200 lines of haskell code. And they're all toys, even then.
17:12:46 <monochrom> The benefit is that I actually know Haskell, not cargo-cult it.
17:12:57 <dmwit> And, for what it's worth: my average lines/day at my first real programming internship was 10, and by all reports they were very pleased with my productivity. They tried to hire me even.
17:13:04 <EvilPyro> Axman6, kinda is, I had to choose a project myself and develop it, its an optional assignment, but i really need it to consolidate what i know about haskell
17:13:10 <monochrom> Yes, I am saying that dive-in projects have high chance of inducing cargo-culting.  You heard me.
17:13:41 <monochrom> It depends on your personality, of course.
17:13:47 <dsal> I don't think cargo-culting is entirely bad.
17:14:20 <dsal> I sometimes use parts I don't understand while working on parts I do.  As my understanding expands, I can figure out what I did elsewhere.
17:14:34 <monochrom> Yes that's OK.
17:15:36 <dmwit> By comparison: one natural reaction to "there is no god" is "oh, damn, this changes my whole life, because I have so many things predicated on that assumption". But then after some time trying to work out exactly what changes next, you realize... it actually isn't that much.
17:15:43 <monochrom> For each ever-growing programmer like you, there are maybe 10 never-growing programmers who never proceed to your 2nd sentence.
17:16:09 <dmwit> You are in a similar situation. You learned "there is no pure random" and went "oh, damn, this changes my whole code base, because I assumed that while I was writing all this code".
17:16:18 <dsal> monochrom: Do they end up in Haskell?  This doesn't seem like a good place for people who don't want to learn things.
17:16:23 <dmwit> But actually if you work out exactly what has to change... just because you assumed it while writing the code doesn't automatically mean the code is wrong.
17:16:29 <dmwit> You might find out only small things need to change.
17:16:32 <dsal> dmwit: Your analogy is quite interesting.
17:16:39 <dmwit> And if you show us the code, we can help you find those small changes.
17:17:14 * dsal hangs out here to watch smart people be smart to cargo-cult smartness
17:17:30 <hseg> Q: if I have modules A B C depending on each other sequentially, and I define an instance in A, will that instance be available in C?
17:17:44 <dmwit> If "depending on" means "importing", then yes.
17:18:02 <hseg> second-guessing myself before opening a ticket
17:18:04 <monochrom> dsal, I think some of them tried. Among those who tried, some go because of this, some grudgingly need to change their attitude.
17:18:12 <dmwit> If C imports B imports A, then all instances available in A are also available in C.
17:18:32 <monochrom> You know who they are! Those who blackmouth Haskell as "too academic".
17:19:08 <dsal> Ah.  Yeah.  I can see that.  blub paradox is real.
17:19:13 <hseg> ... sorry, internet is on the fritz today
17:19:32 <dmwit> hseg: The last message I wrote was "If C imports B imports A, then all instances available in A are also available in C.".
17:20:20 <dmwit> (The rule is even simpler. If A imports B, then all instances available in B are available in A. My previous message is a logical consequence of this one.)
17:20:43 <EvilPyro> The code right now its a mess, there are unfinished functions etc, Its a connect-4 game, IA its not yet implemented but will have Random, Greedy and a Smart algorithm  https://pastebin.com/2PDNaZ20
17:22:08 <monochrom> Sounds like the Random NPC could just receive an infinite list of Int or something.
17:22:42 <EvilPyro> ?
17:22:46 <Axman6> That's what I said...
17:22:55 <monochrom> Yes, what Axman6 said.
17:23:03 <dmwit> EvilPyro: To me it looks like at least the first 90 lines need change not at all.
17:23:22 <dmwit> Almost certainly the only thing that needs to change is machine_turn and its callers.
17:23:41 <dmwit> And all its callers are already in IO, so the change will be very light indeed.
17:23:55 <hseg> ok, thanks
17:23:55 <hseg> i'm tired and reasoning is slipping
17:24:01 <dmwit> You see what I mean? Just two lines need modification, at my quick guess from a fast read.
17:24:40 <dmwit> Oops, machine_random_ia will need modification, too. Okay, 10 lines.
17:25:13 <EvilPyro> xD
17:25:17 <Axman6> EvilPyro: I wouldn't call this a mess, certainly cleaner than most of what the students I've tutored would write
17:25:42 <dsal> EvilPyro: If you always return the same output for the same input, you have a function and you're good.  If you return different values for given input, that difference has to be captured *somewhere*.
17:27:59 <EvilPyro> Axman6, :D btw i dont understand the infinite list of integers you mentioned earlier
17:28:25 <monochrom> Haskell heightens your aesthetic sense.  You no longer need a style guide.  Your heart is already your best style guide.  You are unable to make a mess now.  Even when you think you do, it is still not a mess.
17:29:29 <EvilPyro> well, i've noticed that its hard to do a total mess, either it works or it doesnt compile xD
17:30:10 <Axman6> EvilPyro: Imagine I gave you an infinite list of random Ints, and you needed, do you think you could use that instead of needing to call an IO Int function repeatedly?
17:30:14 <dmwit> EvilPyro: Here's my small diff that makes your thing compile (though I haven't run or tested it at all): https://gist.github.com/dmwit/8e97cb361e41689d33feff49dde58341
17:30:31 <dmwit> EvilPyro: I think you'll agree the total amount of stuff that needed to change is pretty small.
17:30:41 <Axman6> could you maybe take an Int from the front, use that as your random int, and pass around the rest of the list?
17:31:11 <dsal> > let randomGen = > mkStdGen 104 in randomRs (0, 9) randomGen
17:31:13 <lambdabot>  <hint>:1:17: error: parse error on input ‚Äò>‚Äô
17:31:15 <dsal> > let randomGen = mkStdGen 104 in randomRs (0, 9) randomGen
17:31:16 <dmwit> (I actually think Axman6's recommendation is going to entail a much larger rewrite. Though it may be educational if you want to take a stab at it.)
17:31:18 <lambdabot>  [7,3,8,1,7,9,0,5,9,2,0,4,8,9,5,0,9,6,6,5,3,1,0,3,3,0,2,9,8,6,7,1,6,4,6,6,3,2...
17:31:55 <dsal> ^ that's an infinitely long list of random numbers from 0-9 given a random number generator.  But don't use that random number generator.
17:34:02 <EvilPyro> Axman6, not sure, depenting on the ammount of functions I'll need to adapt, I'll become a bit strange to pass around an unrelated list tbh, not sure
17:34:47 <EvilPyro> It'll*
17:36:11 <EvilPyro> dmwit, thanks for the diff it was long ago the last time i merged a diff into a file xD
17:36:30 <dsal> Well, you need to pass around the sense of randomness somehow.  Another approach is to do stuff in IO.  Which you said you didn't like.  :)
17:36:43 <dmwit> Look at the diff, then try to do it yourself without referring back. It'll take longer than just calling patch, but you'll learn much more.
17:37:20 <EvilPyro> okay then, i'll do that hehe
17:37:48 <Axman6> EvilPyro: we have ways to do that without it being tedious, including using MonadRandom, which does something similar, by passing around a pseudo-random generator and producing valued from that as you ask for them. 
17:38:02 * dmwit chuckles
17:38:22 <dmwit> "I hate that I have to lift all this stuff into IO!" "Okay, lift it into RandomT IO instead."
17:38:32 <monochrom> No.
17:38:40 * monochrom always one-up the game.
17:38:47 <monochrom> ContT (RandomT IO)
17:38:54 <dmwit> lmao
17:39:35 <dmwit> I have a favorite Korean restaurant. The thing that I love about it is that no matter what you order, from the $0.50 ramen to the $15 roast duck, they ask you if you want egg with that.
17:39:51 * monochrom idly wonders about the other order, RandomT (ContT IO)
17:39:59 <dmwit> You order bibimbop with a side of egg and they ask if you want an egg on top.
17:40:06 <Axman6> "Don't like this random number? time travel backwards and pick a new one"
17:40:25 <dmwit> And here comes monochrom, my new favorite Haskell vendor. No matter what you order, "You want ContT with that?".
17:43:30 <dsal> I just recently learned that Jack Conte founded Patreon.  Small world.
17:44:27 <dsal> I still want to write something real with tardis.  Use random number.  (Note to self, provide random number at some point)
18:09:15 <meadt> is there any similarity between lattices (like in elvish) and the "layers" of neural nets?
18:10:19 <meadt> they are kind of like these graphical networks that share information over edges, but are directed, and have no "highways" or edges that point backwards...
18:10:50 <meadt> oh no, I mean, they are not "recurrent"... I think highways are edges that jump forwards a bunch
18:11:05 <monochrom> That sounds like not for this channel.
18:11:31 <meadt> i was just watching ed kmetts most recent talk on propagators 
18:11:57 <meadt> his concept of a lattice seems like it could be useful for this
18:12:43 <Axman6> I also wouldn't have categorised neural networks as something that converge like a lattice does, there's no reason any individual "neuron" wouldn't fluctuate between a few values
18:12:54 <meadt> alternatively, to get further from the neural nets terminology, you could think of the edges as being dereferenching of let bound implementations
18:13:38 <Axman6> you might enjoy Ed Kmett's talks on Propagators
18:13:52 <meadt> Axman6: not that the nodes would increase monotonically, ie. not the "hypergraph" with propergators on the edges, with nodes as lattices
18:13:56 <Axman6> https://www.youtube.com/watch?v=acZkF6Q2XKs was the first one I heard
18:14:23 <meadt> it was this one; https://www.youtube.com/watch?v=s2dknG7KryQ
18:15:01 <meadt> that the whole network would increase monotonically... ie, the signal kind of goes from the inputs to the outputs
18:15:30 <monochrom> This still has nothing to do with #haskell
18:15:48 <monochrom> You will stop or I will make it stop.
18:16:42 <meadt> it can be rephrased with the example of function evaluation instead of neuronal signals
18:16:54 --- mode: ChanServ set +o monochrom
18:17:00 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.109.123.74.179
18:17:00 --- kick: meadt was kicked by monochrom (meadt)
18:17:06 --- mode: monochrom set -o monochrom
18:17:39 <Axman6> heh
18:18:15 <solonarv> I don't think they realized you were an op. oh well, their loss!
18:20:23 <skipper> meadt: function evaluation like in a functional programming language like haskell?
18:20:31 --- mode: ChanServ set +o monochrom
18:20:35 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.178.62.200.75
18:20:35 --- kick: skipper was kicked by monochrom (skipper)
18:21:20 <Axman6> monochrom: need some coffee mate?
18:21:25 <DigitalKiwi> wow
18:30:32 --- mode: monochrom set -o monochrom
18:43:32 <oats> uh, I don't really get what this person's about, but was a kick really necessary?
18:43:49 <oats> (though it is a bit weird that they come back with a different IP each time)
18:44:39 <DigitalKiwi> u r next oats
18:45:15 <monochrom> I did not kick when it was not necessary.
18:45:28 <monochrom> There is a difference between the following two:
18:45:35 <Axman6> It's more than just today, they've been going on about mostly nonsensical stuff for a few days
18:45:41 <dmwit> You're welcome to discuss moderator actions further with us in #haskell-ops, but let's keep this channel uncluttered.
18:45:48 <oats> :thumbsup:
18:46:52 <monochrom> 1. Sincerely interested in discussing a topic, and when pointed out it is off-topic, forthcomingly confess "yes sorry it is offtopic, but I reckon some of you are interested too".  We can be gentle with them and guide them to another channel.
18:48:05 <monochrom> 2. "Oh, so I'll just pay lip service and make up a fictional facetious connection/mention of haskell stuff to rationalize staying here and game the system".  These are proven trolls.
18:49:43 <oats> fair enough
19:09:55 <kaychaks_riot> can we have something like `Data.ListZipper.{moveLeftLoop, moveRightLoop}` from list-zipper using combinators of zippers package ?
19:12:13 <dmwit> I don't know. What does moveLeftLoop do?
19:12:59 <dmwit> Oh, I misunderstood the question. My new understanding is that moveLeftLoop already exists and is your specification.
19:13:04 <kaychaks_riot> its like a circular zipper which does not fall off after the leftmost element
19:13:16 <kaychaks_riot> yes
19:13:16 <dmwit> Not that you want moveLeftLoop to exist and plan to implement it using zippers. Okay, let me look at what moveLeftLoop does.
19:14:22 <dmwit> Oof, moveLeftLoop is expensive!
19:15:26 <dmwit> I suspect that, if it is possible, it will be very, very painful both to implement and to use.
19:15:31 <dmwit> Its type is... complex.
19:16:02 <monochrom> Hmm! Maybe it is efficient, and therefore has a complex type.
19:16:03 <dmwit> You will certainly need at least to implement a new type family.
19:16:23 <monochrom> But I haven't read it.
19:17:15 <dmwit> moveLeftLoop has a simple type, and is inefficient. I have read it.
19:17:30 <dmwit> But maybe you don't trust me! Then you should read it yourself.
19:17:46 <dmwit> I mean it's not egregious. It is O(n).
19:17:47 <monochrom> I prefer learning GHC.Generics at this time :)
19:18:09 <dmwit> (And I guess in retrospect how could we hope for it to be anything less?)
19:19:31 <dmj`> monochrom: GHC.Generics is the best
19:19:40 <monochrom> :)
19:20:49 <dmj`> I'm waiting for the day when someone will build the perfect database library just using GHC.Generics
19:20:56 <kaychaks_riot> dmwit: I guess you are saying its expensive coz it just checks if we are the farthest and then it moves either to end or fist depending upon the combinator and hence it would be O(n) right ?
19:21:06 * dmj` looks at monochrom
19:21:51 <dmwit> kaychaks_riot: Yes. I object less the more I think about it. =)
19:21:53 <ddellacosta> dmj`: why would you want that in particular? Or is that an in-joke as you know something about what monochrom is working on now?
19:23:02 <monochrom> It is a haskell-community-wide in-joke that our database libraries/binding all suck (or is it OCD on our part?) and everyone is waiting for the haskell database system from The Book.
19:23:22 <ddellacosta> monochrom: ah, gotcha, thanks.
19:23:38 <dmj`> ddellacosta: the best haskell libraries are the ones that give you functionality without compromising your types. Libraries that force you to do a ton of boilerplate or annotate your types in different ways make integrating with other libraries a pain, and it can often hinder type inference. GHC.Generics has the potential to give you rich functionality while keeping your data types vanilla.
19:24:16 <dsal> I get by with sqlite-simple like a peasant.
19:24:24 <monochrom> I feel that a good macro system is necessary.
19:24:26 <ddellacosta> on a side note, I'd love to know what people think the best resource for learning Generics is. The last time I fumbled through it I bounced between Andres Loh's original paper/talk, a post from Stephen Diehl, and the Haskell wiki page and found them all kind of lacking in different ways
19:24:31 <dmj`> dsal: that's what I do, but I load it up with custom GHC.Generics 
19:24:58 <ddellacosta> dmj`: ah okay, I thought you had some specific mapping between e.g. SQL and Generics in mind or something! Gotcha
19:25:04 <dsal> I've not had to learn generics yet.
19:25:06 <dmj`> ddellacosta: if you use servant, or make your own servant interpretation, its spiritually the exact same as GHC.Generics.
19:25:08 <monochrom> I think the best one will be the one I will write in the far future. :)
19:25:23 <dsal> monochrom: I assume it'll be 100 lines.
19:25:38 <ddellacosta> dmj`: that's interesting
19:25:41 <monochrom> However! I think today's GHC.Generic haddock is actually pretty good.
19:26:12 * ddellacosta goes to remind himself of what is written there, since he forgets everything to do with Generics promptly after reading it
19:26:33 <dmj`> ddellacosta: I have a custom Generics implementations for all serialization code (JSON, PG, Binary), some DB access code (generate DDL, basic CRUD ops), environment variables, get-opt parsing.
19:26:35 <ddellacosta> ah yeah actually now I remember reading this too and yeah it's maybe the best
19:27:08 <dmj`> ddellacosta: it depends on what you're trying to do, but there's a few different patterns, sometimes you only want to operate on sum types, sometimes only products, sometimes both
19:27:09 <monochrom> I am only reading the GHC user's guide and the GHC.Generics haddock.  The latter totally subsumes the former though.  And I am needing nothing else except making up my own fingering exercise "let me re-do Show this way".
19:27:26 <ddellacosta> dmj` woah, that is amazing. I've struggled to figure out where to apply it past toy examples. I guess I have to rethink some assumptions and open my mind!
19:27:50 <dmj`> ddellacosta: GHC.Generics is a gold mine of untapped potential for the community.
19:27:51 <ddellacosta> monochrom: that makes sense. I think the key, and where I've been lacking, is practicing it a lot
19:28:01 <ddellacosta> dmj`: it does seem like
19:28:03 <dmj`> ddellacosta: it would be like finding a billion barrels of oil in the desert
19:28:29 <Axman6> dmj`: I found generica-sop much easier to deal with than GHC.Generics
19:28:38 <Axman6> ggenerics-sop*
19:29:03 <dmj`> ddellacosta: you should check out envy
19:29:07 <dmj`> @package envy
19:29:07 <lambdabot> http://hackage.haskell.org/package/envy
19:29:15 <dmj`> it's a good use of generics to do a "real world haskell" thing
19:30:01 <ddellacosta> nice. I mean, I know about e.g. Aeson and generics-lens and whatnot, but definitely want to learn about more applications. Thanks for the pointer
19:30:20 <ddellacosta> *generic-lens
19:30:24 <monochrom> envy is neato
19:30:29 <dmj`> monochrom: :)
19:31:32 <ddellacosta> great docs I gotta say, love seeing that in a Haskell library
19:31:54 <dsal> Is there a way to read the envy docs without the infomercial voice?
19:32:13 <ddellacosta> I mean, why would you _not_ want to read it in the infomercial voice
19:32:16 <dmj`> dsal: no, that is by design, it's a bug not a feature :)
19:32:21 <dsal> haha
19:32:35 <dmj`> it's a feature not a bug*** lool quarantine is gettin' my wires all crossed
19:32:47 <dsal> Oh mean, I read it that way, too.
19:32:59 <dsal> Too many dogs and cats living together.
19:33:43 <dmj`> (Deep movie man voice) "In a world, bound by data types, one man, dares to derive Generic... this summer, reify your types, coming to a hackage near you"
19:34:41 <ddellacosta> hahaha I love it
19:34:53 <Axman6> our apps at work have added some stuff on top of optparse-applicative which allows us to specify that arguments can be obtained from environment variables, which is pretty neat
19:35:15 <dsal> envparse-optplicative
19:35:52 <Axman6> 2env2plicative
19:35:59 <dsal> haha
19:36:02 <dmwit> Hm. This actually seems like a mildly tricky asymptotic analysis. Is transpose O(n), where n is the total number of list elements?
19:36:16 <Axman6> IO (Tok, Drift)
19:36:37 <Axman6> @src transpose
19:36:38 <lambdabot> transpose []             = []
19:36:38 <lambdabot> transpose ([]   : xss)   = transpose xss
19:36:38 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:36:46 <dmj`> ddellacosta: here's one for optparse-applicative's ReadM (works only on sum types), https://gist.github.com/dmjio/843d5ff477df2dfe535ce0976f0deb4e
19:37:58 <dmj`> ddellacosta: here's another one for Web.HttpApiData https://gist.github.com/dmjio/33d7b000f4e8a84ef2619bbb4bdc4d8a
19:38:51 <dmj`> I like how GHC.Generics uses :+: and :*: to indicate sum (addition ~ +) or product (multiplication ~ *)
19:39:15 <monochrom> @remember dmj` (Deep movie man voice) "In a world, bound by data types, one man, dares to derive Generic... this summer, reify your types, coming to a hackage near you"
19:39:15 <lambdabot> I will never forget.
19:39:22 <ddellacosta> dmj`: so like, one thing it seems like you're doing is writing not-super-generalized things with Generics, is that a reasonable thing to say?
19:39:42 <ddellacosta> I put it that way because I guess I realized I was assuming that you always had to implement them in some super general fashion but now I'm not sure why
19:39:52 <oats> applicative was really fun once I figured what kinds of things it's used for
19:40:05 <oats> and then I got jealous when I saw idris's idiom brackets
19:40:25 <ddellacosta> dmj`: I also like those operators
19:40:33 <dmj`> ddellacosta: yea, doesn't have to be, it's like if you find yourself doing the same instances over and over again just on sum types, that's a good candidate for it. Sometimes you want to go full hog wild and reify the whole farm and all the farm animals with it
19:40:44 <ddellacosta> haha
19:40:54 <ddellacosta> well cool, that's a handy rule of thumb I'll have to remember
19:40:55 <dmj`> that's what aeson does, no type left behind policy
19:41:19 <ddellacosta> yeah maybe that's kind of where my mental model is from actually, that's really the main library I've used that leverages Generics
19:41:53 <monochrom> dmwit: Very roughly: transpose is a "simple" foldr for the outer and foldr for the inner.  So yes proportional to total number of elements.
19:43:19 <dmj`> ddellacosta: it's a good example of it for sure, but a bit daunting 
19:43:24 <dmwit> hmmmm
19:43:27 <ddellacosta> seriously
19:43:57 <dmj`> ddellacosta: one thing that really helped me get GHC.Generics is to define some type families that operate on the type level structure
19:44:17 <dmj`> ddellacosta: like, try to write a type family that just extracts field names, and see how far you can get.
19:44:25 <dmj`> ddellacosta: then after that, try to reify it at the value level
19:44:57 <ddellacosta> dmj`: interesting. My type family skills at this point are super mediocre so that would be a useful exercise
19:48:31 <dmwit> monochrom: Okay, I guess I buy it!
19:48:42 <monochrom> Aaahhhh the GHC.Generics haddock is missing "what if I want to know the data constructor name"
19:49:21 <monochrom> more precisely, bring the data constructor name down to the term level.
19:49:22 <ddellacosta> umm I thought that's part of the Metadata bit
19:49:31 <ddellacosta> I swear I've done that
19:49:46 <monochrom> Yes, but the tutorial example doesn't show how to do it.
19:49:59 <ddellacosta> hold on let me see if I can find the thing I hacked together at some point
19:52:46 <monochrom> aaaarrrrggghhhh Int is not a Generic instance
19:53:19 <monochrom> It's OK I'll settle with "data My = A Bool Bool"
19:53:55 <dmj`> ddellacosta: this one is for quickcheck and it does products and sums, https://gist.github.com/dmjio/1f624f57baabb1ab61077903d31763b1
19:54:34 <koz_> dmj`: Is that not just this? http://hackage.haskell.org/package/generic-arbitrary
19:54:57 <ddellacosta> monochrom: so my head's been out of the Generics game for a while, but does this look like the kind of hackery that would get you what you want? https://gist.github.com/ddellacosta/04c88d5b99f6123140f583853acd0c06
19:55:30 <monochrom> Yes I forgot the classes Constructor, Selector, etc
19:55:45 <ddellacosta> dmj`: I don't know quickcheck very well, what does this do? Arbitrary is an fundamental type in that lib right?
19:56:27 <dmwit> Huh. No instance ToJSON ByteString. That seems unfortunate.
19:58:09 <koz_> ddellacosta: Arbitrary is a type class, not a type.
19:58:26 <ddellacosta> sorry was being lazy with terminology, yeah 
19:59:02 <koz_> ddellacosta: Arbitrary is a type class which says 'I have some way to magic up values of this type (arbitrary method) and to 'reduce' a 'complicated value' to a 'simpler value' (shrink)'.
19:59:29 <ddellacosta> koz_: ah, gotcha, thanks. I can see how Generics fits well there
20:30:30 <dmj`> koz_: hah, never saw this. Seems they use frequency when choosing sums
20:30:44 <koz_> dmj`: Yeah, a lot of this stuff is exceptionally well-buried.
20:40:29 <dmj`> koz_: there's got to be a way to make a DSL works that works on the generic representation of types (treating them as SQL tables). So that when your expression compiles the type would just be a Symbol literal that was SQL
20:41:03 <koz_> dmj`: Why are you directing this to me?
20:41:28 <dmj`> koz_: oh sorry, I meant to send this to ddellacosta, seems they're offline now
20:41:36 <koz_> Lol, no worries.
20:41:40 <koz_> Was a bit confused there.
20:41:52 <dmj`> koz_: if you have input I'm not opposed to hearing it :)
20:42:03 <koz_> dmj`: I do not, sorry.
20:42:19 <dmj`> koz_: apology accepted
22:21:33 <yanti> hiiii
22:24:35 <yanti> any1 here?
22:28:01 <Lycurgus> you mean is anyone attentive, right? Are you new to irc?
22:29:05 <Axman6> No one here but us unnamed functions
22:29:22 <Axman6> yanti: do you have a question about Haskell?
22:30:01 <yanti> mm not really.. im looking for haskell pros to hire\revshare
22:30:56 <Axman6> what salary are you offering?
22:31:08 <Axman6> If you're not offering a salary, good luck!
22:32:53 <Lycurgus> tyvm Axman6 
22:33:10 <yanti> that depends
22:33:30 <yanti> 25-50$\hour
22:33:39 <koz_> yanti: USD I assume.
22:33:48 <Axman6> I already make more than that, I'll pass
22:33:49 <yanti> ye
22:34:08 <Lycurgus> that's a shitty wage for an experienced hs developer
22:34:27 <Lycurgus> they're not all clueless poindexters
22:34:37 <Axman6> How much exposure will I get?
22:34:37 <yanti> im only starting out
22:34:57 <Lycurgus> oh if you mean tutoring you, then it's not so bad
22:34:58 <yanti> i can tell u about some cool projects we do
22:35:04 <Axman6> go ahead
22:36:08 <yanti> a multiplayer game server that  gets update messeges from client
22:36:19 <ja> hot damn
22:36:23 <yanti> wow its hard to explain
22:36:24 <Lycurgus> lol
22:36:26 <yanti> hehehehe
22:36:27 <yanti> lol
22:36:28 <yanti> wait
22:36:34 <yanti> im stoned
22:36:42 <yanti> writing seems so hard suddenly
22:36:46 <Axman6> no shit
22:36:47 <Lycurgus> quelle surprise!
22:37:14 <Axman6> the whole "I want to hire someone but can't even write in full words" kind of gave that away
22:37:34 <Axman6> "revshare"
22:37:54 <yanti> hey i have a blizzard coder on revshare
22:38:46 <yanti> is there a nicer chat client than irc you are all part of?
22:39:17 <Axman6> no. IRC is the original and the best. Perfection cannot be improved upon
22:39:31 <yanti> but how do i send photo
22:39:32 <yanti> :(
22:39:44 <Lycurgus> do a link
22:40:23 <Axman6> link us to ya insta brah
22:40:26 <yanti> whats that sites name where u dump images and get a link :|
22:40:32 <Lycurgus> also you confuse a whole technology with a thing in it
22:40:53 <Lycurgus> there's a bunch, imgur, etc
22:42:29 <yanti> https://imgur.com/PSn1dtm
22:42:50 <yanti> basicaly a stateless server\db
22:43:31 <yanti> all server needs to do is get all update msgs from clients
22:43:39 <yanti> check if any is malicious
22:44:06 <yanti> then chain-compose them - and send the chain to each client
22:44:59 <yanti> i have a CLR guru than will do the server in c#+clojureCLR
22:45:32 <yanti> but i need some haskell guru\s to mock up a quick server example in haskell
22:46:27 <yanti> i have some young haskell padawans in my team
22:46:30 <yanti> but no pros
22:46:33 <yanti> :(
22:47:31 <ja> haskell people are too rational to join you
22:47:45 <ja> you need to find a programming community with more yolo
22:48:08 <yanti> interesting point
22:49:03 <yanti> what if i tell you i solved the "data crisis" in ML?
22:49:31 <Axman6> I wasn't aware there even was a crisis! Oh god!
22:49:53 <yanti> ill admit it wasnt hard..
22:50:53 <yanti> the only question is whether or not u realize you are speaking to the next google
22:51:00 <Axman6> should I be worried? I can call the fire brigade if I need so... do I need to?
22:51:15 <yanti> its ok im fully diagnosed :D
22:51:27 <Axman6> I'm very confident I'm not talking to the next google
22:51:32 <yanti> currently im hypomanic
22:51:39 <yanti> no big deal
22:52:17 <yanti> well i agree.. google is too small a target to even be competing with
22:52:27 <ja> yanti: that you think you solved some big thing is another sign of emotional distress. another sign that you are ruled by emotions, not reason
22:52:51 <yanti> they dont have quantum cpu and dont have my lower bound on learning
22:53:01 <DigitalKiwi> delusions of grandeur; hypomanic; yup checks out
22:53:19 <yanti> and yet im valedictorian for 2 years
22:53:34 <yanti> without repeating a test ever
22:53:35 <Axman6> I cannot wait to start working with. the dailywtf is going to get so much new content. I'm in
22:53:35 <yanti> hmmm
22:53:38 <yanti> i wonder
22:53:51 <Axman6> with you*
22:53:57 <Lycurgus> delusions of grandeur, yep ur in the right place
22:53:58 <yanti> hehe
22:54:20 <yanti> basicly imo im einstein -2 iq points
22:54:24 <DigitalKiwi> i say this as nicely and with concern as possible; are you off your meds
22:54:40 <yanti> so like galois is smarter than any of us any way so y worry
22:54:51 <yanti> actually no im on my meds
22:55:04 <Lycurgus> galois the company?
22:55:10 <yanti> prob is im also smoking weed with my meds
22:55:15 <Axman6> why don't you ontact Galois then, they've got plenty of excellent HAskell devs and do contract work
22:55:18 <DigitalKiwi> because hypomania is great you get tons of shit done...it's just that often leads to a lot of bad things :P
22:55:28 <yanti> yup
22:55:30 <Lycurgus> and they prolly don't drug test
22:55:39 <yanti> i gotta learn how to cut my spending
22:55:58 <DigitalKiwi> smoke less drugs
22:55:59 <Axman6> They do government contracts, the definitely drug test their employees... but probably not the people who're contracting them XD
22:56:25 <yanti> btw im israeli
22:56:34 <Lycurgus> otoh they prolly have a ball breaking hs test
22:56:35 <yanti> so seen lots of war and trauma
22:56:41 <DigitalKiwi> hi israeli i'm kiwi
22:56:47 <yanti> hi
22:58:03 <yanti> ok so lets talk about big data for a sec
22:58:26 <Axman6> you do not have big data
22:58:31 <yanti> y is it so hard for machines to learn from a small number of examples like humans do?
22:58:39 <Axman6> there are roughly 6 organisations which actually have big data
22:59:01 <ja> Axman6: is big data bigger now than it was 10 years ago?
22:59:45 <yanti> heard of one shot learning?
22:59:55 <Axman6> it's so big, like, you could call it, very large data
23:00:12 <yanti> trololo
23:00:40 <yanti> u probrly know ML pretty well right?
23:00:50 <yanti> all of you's
23:00:51 <Lycurgus> it's not like kaiju, size don't matter
23:00:59 <Axman6> Haskell is very similar to several ML languages
23:01:08 <DigitalKiwi> i took an SML course
23:01:15 <yanti> oy vey
23:01:22 <Axman6> "Small medium large"
23:01:25 <yanti> talking to u gurus is hard work
23:01:29 <Axman6> it covers everything
23:01:37 <Axman6> It sure is!
23:02:16 <Axman6> we speak in tounges to ensure the masses are not destroyed by our brilliance
23:02:18 <DigitalKiwi> that robin milner was a smart guy; i bet haskell could learn something from him
23:02:52 <yanti> ok so  .. occams razor
23:03:06 <Axman6> We don't allow weapons in here
23:03:07 <yanti> "regularization"
23:03:31 <DigitalKiwi> Axman6: tsk tsk. it's for shaving!
23:03:34 <yanti> NN regulariztion is more of a joke than a weapon 
23:04:19 <Axman6> We do allow occam's safety razor if we trust you, otherwise you'll need to use occam's disposable razor
23:04:27 <yanti> ever try to do genetic programing with a regularized loss function?
23:04:45 <yanti> its shit
23:04:53 <DigitalKiwi> i think CRISPR is offtopic for this channel
23:05:05 <yanti> ok so come telegram?
23:05:11 <yanti> plizzz
23:05:16 <yanti> pretty pliiizzzz
23:05:46 <DigitalKiwi> only if the singer stays 6 feet away from me
23:05:59 <Axman6> I don't know who pliiiizzzz is, are they really pretty?
23:06:09 <yanti> :\
23:06:22 <yanti> dam sure
23:06:22 <Axman6> I feel that's a subjective thing
23:06:32 <yanti> surjective?
23:06:43 <yanti> hey i know math words like u 
23:06:51 <DigitalKiwi> misjective
23:06:52 <Axman6> I've never been in the defence forces
23:07:00 <yanti> u sure?
23:07:12 <yanti> i can tell some stories
23:07:41 <DigitalKiwi> i was born at a very young age
23:08:03 <Axman6> I hear that was a mistake
23:09:07 <yanti> y must u always troll the noob
23:09:15 <yanti> im not like u
23:09:19 <yanti> i dont like coding
23:09:35 <yanti> i just want to fix teh world
23:09:44 <yanti> using my insane IQ
23:09:44 <DigitalKiwi> me too buddy, me too
23:10:46 <yanti> :(
23:11:04 <yanti> how can you tell you are better than me?
23:11:49 <monochrom> You people must be very bored.
23:12:08 <Axman6> We get people who want to do that com in here and the Haskell subreddit a few times a month. They all have the next multi-billion dollar idea, all want to pay in stocks/exposure/anything but a salary, for work they won't disclose anything about (at least you've done that, good work). If you want to make a startup that changes the world, you're going to have to have a very solid idea that you can convince people to gived up their lives for the
23:12:08 <Axman6>  possibility of success. most actually have nothing and have done no research
23:13:06 <monochrom> I think the trick is to take "insane IQ" and delete "IQ".
23:13:35 <yanti> ok but like im verryy slleepy and very stoned.. can u please troll me less?
23:14:04 <DigitalKiwi> that's what makes it interesting
23:14:11 <monochrom> And you are not trolling? How?
23:14:19 <yanti> They all have the next multi-billion dollar idea - i dont care about the money
23:14:40 <monochrom> I do. Give me yours.
23:14:57 <yanti> but im pretty sure ill make lots of it.. after understanding what kind of people the israeli hightech industry is made of
23:15:16 <DigitalKiwi> i need it more than monochrom plz share with me too
23:15:25 <yanti> ok wait a sec
23:15:33 <monochrom> OK give it all to DigitalKiwi, I'm OK.
23:15:34 <yanti> there will be money
23:15:40 <monochrom> NOW
23:16:08 <yanti> listen me an the CLR guru - we are building a SaaS for gamedevs
23:16:12 <Axman6> I've only heard of a few Israeli Haskellers, which surprises me a little, for a country which has such an advanced tech industry
23:16:37 <monochrom> Tell you what. I was a great procrastinator. I didn't submit my MSc thesis until the last day.  And my supervisor sent me an email on that day.  subject: thesis.  body: NOW
23:16:38 <Axman6> Who are you competitors? what already exists?
23:16:43 <yanti> we will have like a game server as service for novice unity devs
23:16:43 <monochrom> Short email. :)
23:17:00 <yanti> we are mostly free in this niche
23:17:10 <monochrom> WTH is SaaS?
23:17:21 <yanti> unity itself has no network solution
23:17:21 <koz_> monochrom: Funnily enough, I actually did the same for my Master's!
23:17:28 <DigitalKiwi> sarcasm as a service
23:17:39 <monochrom> :)
23:17:41 <DigitalKiwi> is snoyberg iranian or israeli
23:17:46 <koz_> (I think it was in the _last hour_ it was due)
23:17:49 <yanti> there are thinks like "photon" but they are really expensive for noob devs
23:18:00 <Axman6> oh yeah, I'd forgotten about Snoyman, he's the obvious one
23:18:18 <koz_> Axman6: Yeah, Snoyman was _the_ first person I thought of when someone mentioned 'Israeli Haskell'.
23:18:29 <Axman6> He's Israeli 
23:18:37 <yanti> so 1. im making a game studio \ publisher
23:18:47 <yanti> with a guy who has 15 y xp in gamedev
23:19:03 <yanti> also i have an animator who worked for disney
23:19:10 <DigitalKiwi>  may i ask what brought you to #haskell of all places?
23:19:20 <yanti> me and him are setting up an animation studio
23:19:31 <Axman6> why does a backend server need animators :\
23:19:45 <DigitalKiwi> Axman6: it's a game studio keep up
23:20:07 <yanti> we'll be using TensorFlow pose estimation + his skills to make super quick mocap anims
23:20:11 <Axman6> shit, this is growing so fast
23:20:28 <yanti> im all about exponential growth
23:20:37 <DigitalKiwi> oh no
23:20:39 <yanti> its like a company axim
23:20:41 <yanti> axiom
23:21:53 <Axman6> you should call yourselves COVIDeo-19
23:22:10 <Axman6> (I actually kinda like that)
23:22:31 <Axman6> Ok I'm in, what are you paying me. $50/h isn't enough
23:22:37 <yanti> we are TROLLsPACE
23:22:45 <DigitalKiwi> plus revshare
23:22:54 <Axman6> obviously
23:23:03 <yanti> what salary do you want
23:23:03 <yanti> ?
23:23:08 <yanti> like average
23:23:15 <yanti> is 80$\h good?
23:23:21 <yanti> 100$?
23:23:29 <yanti> idk what good in america
23:23:30 <Axman6> yeah sure, why not
23:23:36 <monochrom> WTH is revshare?
23:23:38 <Axman6> I'm not in america
23:23:55 <Axman6> ,it means youy get access to the whole git repo so you can see all the revisions
23:25:02 <yanti> he is lying
23:25:16 <DigitalKiwi> s/lying/trolling/
23:26:05 <Axman6> I would never troll, I'm Australian! WE take everything very seriously
23:26:15 <yanti> surely
23:26:22 <yanti> wow i cant go on
23:26:25 <yanti> must sleep
23:26:31 <DigitalKiwi> monochrom: sounds like about 25% if you get in early. there's the animator, the 15y game dev, yanti and one of us
23:28:47 <yanti> ok bye guys
23:28:58 <yanti> was fun being trolled by all of u
23:29:04 <DigitalKiwi> was fun
23:29:06 <Axman6> <3
23:29:11 <yanti> im crashing
23:29:18 <yanti> ttyl
23:29:22 <DigitalKiwi> check your pms
23:30:55 <[exa]> #blah should be more accessible
23:31:27 <Lycurgus> that's why there's -offtopic
23:32:10 <yanti> #blah is unavailable
23:32:27 <Lycurgus> it's #haskell-blah
23:32:47 <yanti> oh thanks
