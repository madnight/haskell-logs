00:09:02 <coot> @Phyx-  @angerman metioned you're working on windows networking.  In IOHK we pushed `WinIO` further.  Our work is in `Win32-network` package in https://github.com/input-output-hk/ouroboros-network/ 
00:09:02 <lambdabot> Unknown command, try @list
00:13:27 <Phyx-> coot: yeah, let's talk in a pm
00:15:23 <Axman6> coot: you guys have the most intense expressions of interest form I've seen for a job, never been asked for atwitter handle, timezone or hangouts address!
00:16:19 <Axman6> (you guys = IOHK)
00:37:11 <cadabrax> Hi, how can I make sense of the notation that comes up constantly in Haskell? It goes like `[a] -> [a] -> Bool` for instance. I see this all over the docs. What does it mean?
00:37:44 <DigitalKiwi> Axman6: does it ask for your mothers maiden name
00:37:59 <koz_> cadabrax: ... it means exactly what it says. It's a type signature.
00:38:57 <cadabrax> koz_: right, but I dont understand how to read it. Does it mean there are three arguments, the first two are a list and the third is a Bool?
00:39:34 <koz_> cadabrax: Have you tried going through a basic Haskell book or something?
00:39:54 <koz_> Haskell isn't the same as many (or likely, _any_) languages you're familiar with.
00:39:57 <opqdonut> cadabrax: Bool is the return value. Perhaps have a look at http://book.realworldhaskell.org/read/types-and-functions.html or some tutorial
00:39:59 <cadabrax> I am reading Hakell for great good, but I didnt see any explanation for that notation
00:40:36 <opqdonut> http://learnyouahaskell.com/types-and-typeclasses
00:40:46 <opqdonut> chapter 3 covers types
00:41:07 <koz_> opqdonut beat me to it.
00:41:24 <cadabrax> opqdonut: ah I didnt get there yet. It's confusing the author introduces this notation way before explaining it IMHO
00:41:32 <cadabrax> alright, I'll keep on reading then
00:41:58 <opqdonut> it's not a great tutorial
00:42:05 <koz_> cadabrax: Where are you up to? I don't think LYAH has type sigs before Chapter 3.
00:42:45 <monochrom> My http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Winter/02-haskell-types-1.html is also on this.
00:42:48 <opqdonut> there are others too. some prefer the good old https://www.haskell.org/tutorial/
00:44:03 * DigitalKiwi is a fan of the graham hutton book
00:45:43 <cadabrax> I think I have an old copy of learn haskell, the chapters on the online version are in a more logical order. I'll read the online one instead :)
00:47:42 <gentauro> I'm waiting for kmetts: "Write `decent` fast Haskell code"
00:55:15 <gentauro> by any chance, somebody in here has this PDF? 
00:55:20 <gentauro> https://mathr.co.uk/source-codes/hp2pretty.pdf
00:55:35 <gentauro> apparently the authoer has gone on a clima strike with the site :(
00:56:00 <gentauro> (I'm colourblind and really can't see what the hech I'm being presented, the colours are too close)
00:56:03 <gentauro> :S
00:57:12 <DigitalKiwi> cached on google
00:58:30 <DigitalKiwi> maybe not
00:58:32 <DigitalKiwi> it might be
01:02:00 <DigitalKiwi> gentauro: maybe this could help http://haskell.1045720.n5.nabble.com/hp2pretty-0-9-td5880767.html
01:08:45 <cadabrax> I just had an epiphany... Does the Tuple name come from the fact that it's a Ntuple? Like quadruple, quintuple, etc.?
01:10:58 <gentauro> DigitalKiwi: thx, I could get to the code from that page -> https://code.mathr.co.uk/hp2pretty.git/
01:11:52 <gentauro> DigitalKiwi: oh, it's just the `.git` folder :(
01:12:22 <Taneb> cadabrax: yes!
01:12:23 <DigitalKiwi> did you try the cabal unpack?
01:12:52 <tdammers> cadabrax: yes. https://en.wikipedia.org/wiki/Tuple#Etymology
01:13:49 <gentauro> but can still be cloned 
01:14:09 <gentauro> sadly, I can't find a colourblind profile or just b&w
01:15:14 <gentauro> nevermind
01:15:24 <gentauro> I will just use `convert` to B&W
01:15:58 <gentauro> and when I write B&W, I mean grayscale :)
01:19:33 <gentauro> LEL, the grays are equal, so the colour pattern for hp2pretty isn't ideal ...
01:19:49 <gentauro> no wonder I was seeing the same colours xD
01:24:59 <tdammers> color blindness is probably one of the most under-facilitated disabilities on the internet
01:25:30 <tdammers> I guess it's really difficult to build tooling for color blindness when you're color blind, but it's also super difficult when you're not
01:26:00 <tdammers> if you're color blind, you can't check what it looks like for someone with full color vision, and vv.
01:28:28 <DigitalKiwi> i've seen sites that simulate it but i don't know how well they work
01:28:44 <tdammers> well yeah, that's the problem - you can't tell unless you're color blind
01:29:01 <DigitalKiwi> would be crazy to talk to users
01:29:11 <tdammers> totally
01:29:34 <tdammers> but it's a legit problem for a solo dev trying to solve their own problem at hand
01:29:44 <tdammers> which is how a lot of open-source stuff starts out
01:30:55 <DigitalKiwi> anyway i would suspect the sites that simulate it have done some testing and user interaction to see if they are accurate or not but like...nothing surprises me anymore
01:32:16 <DigitalKiwi> there are apps too!
01:32:32 <gentauro> tdammers: but can people without colorbliendess actually see our colour patterns?
01:33:17 <gentauro> or are they just to awful? (I recall from small when I was allowed to put on my own cloth, my siblings were calling my mom telling her: "We are not going to schoolk with him in those colours")
01:33:22 <tdammers> what do you mean, color patterns? I'm not color blind myself, and always assumed that for those who are, certain colors would just look the same
01:33:55 <gentauro> I mean, I have bought some crappy cloth cos I didn't went with a person with `decent colour taste` (we must be `the dream` for sales people)
01:34:18 <gentauro> tdammers: well, I know that Dota2 has a colour profile for colourblind people
01:34:36 <tdammers> are you completely color blind?
01:35:30 <gentauro> http://i.imgur.com/aoqlpel.jpg
01:35:38 <gentauro> tdammers: well depends on the colours
01:36:00 <DigitalKiwi> https://www.color-blindness.com/coblis-color-blindness-simulator/
01:36:07 <gentauro> but when green, orange, red, brown, ... "are too close" I can't really distinguise them
01:37:20 <gentauro> I'm not even mad cos it got me away from FE development (the only times I agree to do it, is if a customer provides me with pantone colour profile with hex values)
01:37:50 <tdammers> ah, so the red/green type, right?
01:37:57 <gentauro> tdammers: I guess so
01:38:11 <DigitalKiwi> heh i was thinking it's a good excuse for when you do wear bad colors "hey, it's not my fault i'm colorblind!
01:38:13 <DigitalKiwi> "
01:38:37 <gentauro> DigitalKiwi: I should put that on a t-shirt
01:38:58 <gentauro> but I was at ICFP in Berlin, and some people when they make slides, don't really take any consideration with me
01:39:24 <gentauro> it's so annoying having to ask friends: "Can't se that stuff, can you tell me"
01:39:45 <gentauro> it's rude to the speaker (I know) but I would argue that the speaker is rude to us as well :(
01:40:33 <tdammers> I think the basic recommendation to not rely on hue alone, but also use brightness/contrast to distinguish elements, would go a long way
01:40:43 <DigitalKiwi> gentauro: what's this look like https://mostlyabsurd.com/pieces/2020/01/11/spilled-paint-5x7/
01:41:02 <__monty__> gentauro: Are you talking figures? I don't know why people do either greyscale with shape variation (dots, dashes, solid, double) XOR color variation but not both.
01:41:09 <merijn> tdammers: I like minimalist slides anyway, so then it's less of an issue
01:41:31 <merijn> __monty__: I do both, because I know reviewers print papers in black and white and I want the graphs to be readable
01:41:42 <merijn> But it's hard in many plotting libraries
01:41:59 <tdammers> merijn: use xterm to render your slides!
01:42:08 <merijn> __monty__: I also have a website that generates colourblind friendly high contrast colour schemes for graphs
01:42:31 <__monty__> I seem to recall it's easy in gnuplot and matplotlib. Probably matlab too?
01:42:46 <merijn> __monty__: Nothing is easy in matplotlib
01:43:08 <merijn> matplotlib is honest to god one of the worst libraries I've ever had the displeasure of interacting with >.<
01:43:12 <__monty__> I used to like it better than gnuplot.
01:43:14 <merijn> This one: https://medialab.github.io/iwanthue/
01:43:25 <merijn> gnuplot is at least consistent and predictable and has working examples :p
01:43:39 <merijn> Also, documentation that is actually correct and understandable >.>
01:45:06 <gentauro> DigitalKiwi: https://youtu.be/R3nFooEArqQ?t=2379 (I was at the audiece)
01:45:22 <gentauro> __monty__: and code and text as well
01:45:31 <gentauro> I'm guessing people think it looks pretty cool
01:46:03 <gentauro> but I would rather have some "boring" and plain slides I can read, than some fancy stuff other can read where I just stare into the void :S
01:47:00 <merijn> I'm reminded of this speaker showing a bunch of code and asking "can everyone read this?" audience member 'no' *font size increased* "is this better?" 'it's still scala...'
01:47:27 <DigitalKiwi> merijn *chortle*
01:47:42 <gentauro> DigitalKiwi: based on that talk, when in doubt, I always convert to grayscale :)
01:47:59 <gentauro> merijn: xD
01:48:28 <merijn> gentauro: Just send more people that link I pasted earlier, it has an option for generating colourblind friendly contrasts :)
01:49:03 <__monty__> merijn: Does it cover all types at once?
01:49:11 <__monty__> And don't you basically end up with greyscale if you do?
01:49:27 <merijn> __monty__: It has a legibility report at the bottom for different types, so yes?
01:49:59 <__monty__> I think the reason people don't is you're ostracized if you do. "Wow, this guy didn't even syntax color his code examples, what a chump."
01:50:46 <__monty__> Thanks for the link, looks like what I tried to do manually for my terminal colors.
01:50:48 <DigitalKiwi> Improve for the colorblind (slow) -- wow that's rude
01:53:33 <gentauro> merijn: I might have missed that link
01:53:42 <merijn> gentauro: https://medialab.github.io/iwanthue/
01:53:53 <gentauro> merijn: thx
01:54:18 <merijn> gentauro: I'd be interested how their contrast analysis for different colourblindness lines up with your experience :)
01:57:23 <gentauro> merijn: I was about to write it didn't do that much for me, then I saw the `Colorblind friendly` color space :D
01:58:11 <merijn> gentauro: There's also a checkbox to improve for colourblindness
01:59:34 <gentauro> merijn: anything over 10 and I'm out
01:59:43 <gentauro> it's in the range of red to green
01:59:54 <gentauro> they are to `equalish`
02:01:01 <__monty__> Yeah, I'd like to know too. It doesn't seem to be quite what I'm looking for. I'd like to be able to specify some constraints and am looking more for good contrast between any pair of colors than having a nice palette of colors a designer could use to make a site look nice.
02:02:04 <__monty__> gentauro: I think it's more that you should stick to picking only a single color out of every cluster?
02:02:19 <gentauro> it was mentioned before, but I like `old-school` paper diagrams in black and with with symbols 
02:02:22 <gentauro> that I can read
02:02:28 <gentauro> __monty__: probably
02:02:47 <__monty__> Are the clusters visually distinct for you though?
02:02:49 <merijn> gentauro: You mean if you ask for a palette of more than 10?
02:02:56 <gentauro> merijn: yes
02:03:12 <merijn> gentauro: It's nearly impossible to get that many colours with adequate contrast, tbh
02:03:30 <merijn> That only works if you start using shades, but that's where colourblind people get into trouble
02:03:51 <DigitalKiwi> https://xritephoto.com/cool-tools
02:03:53 <merijn> Also, if you have more than 10 distinct things in a graph you probably already fucked up :p
02:03:53 <gentauro> merijn: and __monty__ an example: #aab64c and #d8ac51, no good. #457b2d and #837121 no good. and finally #c88033 and #e2735a no good
02:04:58 <gentauro> merijn: my last run with `+RTS -p -h -RTS` = 11 colours
02:05:02 <gentauro> so I'm screwed :D
02:08:16 <turion> So if I have a datatype and I lift it to a kind with DataKinds, then functions on that datatype don't get automatically lifted to type families?
02:09:00 <merijn> turion: They don't, no
02:09:09 <merijn> turion: It sounds like you want the singletons package
02:09:32 <merijn> turion: Actually, it sounds like you should reevaluate your life choices, because down this road lies pain, but who am I to stop you ;)
02:10:15 <turion> Reevaluating my life choices sounds like the easy path in that situation
02:11:02 <turion> Or reimplementing with type families, for that matter
02:11:17 <merijn> turion: Honestly, once you start wanting functions on both the type level and value level you really want proper dependent types and 1) haskell doesn't have those and 2) there's a reason why the first paper on faking them is called "Hasochism" ;)
02:11:37 <merijn> turion: I don't know the context, but would using something like Idris be an option?
02:22:27 <kderme> Is there any way to tell on runtime if an instance was derived or defined explicitely?
02:23:57 <kderme> I could probably add a new field `default wasDerived = True`, but then the user has to define wasDerived = False for his types.
02:29:48 <merijn> kderme: The though of why you might want to know this panics me >.>
02:35:03 <kderme> merijn Basically I want to avoid infinite loops when deriving a specific class for recursive types.
02:36:07 <merijn> kderme: Why would it infinite loop?
02:37:02 <merijn> I don't see why "being derived or not" would impact "loops or not"
02:47:51 <kderme> For examples at the classic examples of Generic for Serialiazable (https://wiki.haskell.org/GHC.Generics) there is thisinstance (Serialize a) => GSerialize (K1 i a) where  gput (K1 x) = put x This could be a source of infinite loops, since `put` may call back to gput if the default implementation is used and not a defined by the user (which brakes
02:47:51 <kderme> the loop).
02:55:28 <dramforever> kderme: I don't think the problem you described exists
02:57:52 <dramforever> If you define instances with recursive types, then put *should* be recursive, right?
02:59:16 <dramforever> For example if I have data Pair = Pair Int Char
02:59:36 <dramforever> I can do: instance Show Pair where show (Pair a b) = show a ++ show b
03:00:01 <dramforever> That's not a loop :)
03:00:45 <dramforever> I can also have: data List = Nil | Cons Int List
03:02:21 <dramforever> And: instance Show List where { show Nil = "/"; show (Cons x xs) = show x ++ "," ++ show xs }
03:02:32 <dramforever> Note the final 'show xs'
03:02:35 <dramforever> That's a loop
03:02:39 <dramforever> But that's not a bad thing
03:03:36 <dramforever> You *want* to 'loop' back to the same instance in these cases
03:04:29 <dramforever> That's what K1 is trying to do: it lets you handle these 'dispatches' of gfoo to foo
03:05:23 <dramforever> If you don't believe me and think there's a problem...
03:06:03 <dramforever> Well, maybe try breaking something, and if you do, show us :)
03:07:03 <mikidep> Hi everybody, what's your style for writing long guards in function definitions?
03:07:59 <ski> you could align `=' under `|' ?
03:08:52 <ski> dramforever : .. imho, using `Show' for custom format is a bad thing :)
03:08:54 <mikidep> But then you would have the `=' misaligned with the other `='s
03:09:06 <ski> not if you align all the `='s under each other
03:09:22 <mikidep> That would make it double the lines
03:09:40 <phadej> lines are cheap
03:09:44 <dramforever> ski: IMHO, using a simple typeclass that already exists for demo is a nice thing
03:10:03 <ski> if you can sensibly break your condition over multiple lines, you could put the `=' at the end of the last line of a condition
03:10:08 <mikidep> phadej: is visual space cheap?
03:10:23 <dramforever> (Note that the topic was ghc generics)
03:11:40 <phadej> mikidep: it depends on your definition of long, e.g. this -> https://github.com/phadej/overloaded/blob/2c06cd9c4250d82235f603bb67a4a3ec4c124d84/src/Overloaded/Plugin/Categories.hs#L126-L165 i consider long :)
03:11:41 <ski> yea, i understand the context. i just can't refrain from commenting on such uses of `Show' (and `Read'), lest someone would think it's sensible
03:12:19 <dramforever> Oh yeah, that's reasonable
03:12:25 <phadej> the single match is so long, it doesn't really matter how others are aligned, you cannot really connect them visually anyway
03:12:46 <mikidep> phadej: that *is* long
03:14:15 <mikidep> ski: so like https://pastebin.com/Da7a7178 ? That was my first thought, I wanted to know if it was common/accepted
03:15:11 <phadej> mikidep: i'd write     | mn > lpknown
03:15:12 <phadej>           && isPali mn
03:15:15 <phadej> as
03:15:19 <phadej> | mn > lpknown
03:15:22 <phadej> , isPali mn
03:15:44 <phadej> yet, those are so short that I'd go for single line
03:17:16 <phadej> ... but the current version doesn't look "odd" either
03:18:12 <ski> i would probably either align the second `&' in `&&' with the `|'s, or else write that whole condition in one line, but then put the following `=' on the next line, aligned with the rest of them
03:18:59 <mikidep> ski: also thought of that
03:19:23 <ski> mikidep : `(show n) == (reverse (show n))' could be `show n == reverse (show n)'. i'd put the type signature for `lpRec' together with its defining clause
03:20:37 <mikidep> ski: yeah the lpRec thing slipped beneath my sight
03:21:28 <ski> (i also indent the declarations after a `where' as much as it itself)
03:21:59 <ski> i might align the arguments of the recursive calls with each other
03:23:13 <mikidep> ski: the `where' style I used was pretty consistent in all (three) style guides I found
03:25:38 <ski> mm. i find it needlessly adds to the inward drift of the lines
03:26:28 <ski> hm, which ones did you check ?
03:26:35 <ski> @where style
03:26:35 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide https://github.com/chrisdone/haskell-style-guide
03:26:38 <ski> any of those ?
03:26:41 <ski> <https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md> ?
03:27:14 <mikidep> The last one
03:29:21 * ski . o O ( <https://mumble.net/~campbell/scheme/style.txt> )
03:30:24 <mikidep> Someone there took style very seriously I guess
03:30:52 <ski> mm, i found that one (tibbe's) mostly reasonable
03:31:44 <mikidep> That's where my `where' style is fro
03:31:46 <mikidep> *from
03:32:18 <ski> i tend to often break the code into pages, with form feed, as suggested in those "Riastradh's Lisp Style Rules"
03:32:41 <ski> hm, it seems also to often be popular to do
03:32:52 <ski>   instance MyClass MyType where
03:32:56 <ski>     ...
03:33:07 <ski> but i prefer
03:33:08 <merijn> Well...that's annoying. On Travis my tests sometimes fail, but locally they never do and the problem seems to be that it's considering an expected exception as not expected...fun times!
03:33:09 <ski>   instance MyClass MyType
03:33:11 <ski>     where
03:33:14 <ski>     ...
03:33:20 <merijn> Everybody loves debugging obscure race conditions!
03:33:38 <ski> (i do this with `module' as well, which may perhaps be a bit unusual)
03:34:20 <mikidep> ski: Well it is annoying to have half-indented code, even if it's just one word
03:34:31 <ski> half-indented ?
03:35:01 <ski> you mean indenting `where' two spaces, and the following declarations with four ?
03:35:14 <mikidep> Yes
03:35:41 <ski> mm, i wasn't really a fan of the GNU brace style in C, either
03:35:59 <davve> haskell has classes? oO
03:36:01 <merijn> mikidep: Well you could indent it 4 spaces and then indent the thing in the where block another 4 spaces, but then you *rapidly* shoot right
03:36:09 <ski> dramforever : what do you mean by "classes" ?
03:36:17 <merijn> davve: Not in the sense you might be familiar with from OO languages
03:36:19 <mikidep> merijn: yeah I'd rather not
03:36:27 <ski> er, davve ^
03:36:40 <mikidep> ski: yucl
03:36:42 <mikidep> *youck
03:36:45 <merijn> mikidep: "half-indents" are not a problem if you just let go of the notion of "indent" :)
03:36:47 <davve> I see
03:36:48 <mikidep> **yuck
03:37:03 <merijn> mikidep: Haskell is *not* an indentation based language
03:37:30 <merijn> It seems to be at first glance, which is why some people struggle in the beginning with "why is this a syntax error?"
03:37:43 <mikidep> merijn: curious that you say that considering I've had GHC complain about the lack of indentation a couple times now
03:38:16 <dramforever> Very common question: Body of function defined in 'where' block seems to need extra indentation
03:38:28 <merijn> mikidep: People generally write indentation for lack of a better word, but the way whitespace based code gets desugared is not based on indentation "levels"
03:38:30 <dramforever> (Also 'let' if you use 2 spaces steps)
03:38:44 <merijn> mikidep: It's based on "indent relative to surrounding lines"
03:39:19 <mikidep> merijn: I guessed so
03:39:21 <merijn> mikidep: The rules are rather flexible which is why there is not consistent uniform style (although there are some recurring key features)
03:39:36 <dramforever> I'd say it's based on column position of key tokens
03:39:38 <ski> mikidep : <http://dmwit.com/tabs/> might be a fun read, btw ;)
03:39:48 <dramforever> and key tokens might not be what you expect
03:40:14 <mikidep> merijn: But then the rules are even more flexible in free-spaced languages like C and still we have plenty of style recommendations
03:40:18 <merijn> I prefer the 2 space for "where" because I use a 4 space indent for do blocks and binding sin the where, so the 2 space indent provides a clear easy to scan separation between "do block" and "where bindings"
03:40:30 <dramforever> I'm talking about this
03:40:35 <dramforever> function params = body
03:40:50 <dramforever>   where helper params too long =
03:40:52 <merijn> mikidep: Sure, there's plenty of basic rules. But in my own style the overarching rule is "readability trumps consistency"
03:41:03 <dramforever>     this is the body but it got broken by another message
03:41:21 <merijn> I have a rather predictable and consistent style *usually*, but I'd sacrifice consistency before readability any time
03:41:40 <troydm> how do I list installed stack LTS versions using stack command?
03:41:42 * ski would tend to agree with merijn there
03:42:23 <merijn> mikidep: Especially when you have functions with lots of arguments finding a good clean way that's consistent can be nigh impossible
03:42:30 * dramforever agrees. Rule #0: Use your own judgement
03:42:47 <ski> s/judgement/informed judgement/
03:43:04 <merijn> This is why I dislike auto-formatters. I format code the way I do for a reason. And honestly, 90% of the layout I do is so simple I really don't need tool assistance
03:43:06 <ski> it's good to know what common styles are out there, and some rationale for them
03:43:30 <ski> (even if you disagree)
03:43:43 <statusfailed> what language extension do I need to use a pattern as a literal string?
03:43:59 <ski> huh ?
03:44:29 <statusfailed> the vulkan library defines this: pattern KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain"
03:44:37 <mikidep> Ok I think I will go with half-indented `where's, thanks. I like my Tab key on my keyboard.
03:44:39 <statusfailed> but when I use it as a literal string, I get an error
03:45:03 <merijn> mikidep: I think this module is about "as bad" as it gets for me in terms of layout variations: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/model-src/Train.hs
03:45:20 <statusfailed> "Data constructor not in scope"
03:45:46 <MarcelineVQ> I use tab too, it just adds spaces instead of \t
03:46:01 <merijn> mikidep: I actually configured vim to automatically dedent where to a half regular indent when I write it :p
03:46:10 <ski> and you turned on `PatternSynonyms', statusfailed ?
03:46:16 <dramforever> I think there are a few autoformatters with the explicit goal to not touch what you painstakingly arranged
03:46:23 <mikidep> merijn: nice
03:46:33 <merijn> statusfailed: What's the error?
03:46:44 <statusfailed> ski: Yeah I have that on
03:47:16 <statusfailed> merijn: "Data constructor not in scope", plus a suggestion to add it to the import list (it's already in the list)
03:47:28 <ziman> hello, i'm trying to implement a show for HList: https://gist.github.com/ziman/f29137a78f47b9dc29596ef218320fc1
03:47:36 <ziman> but somehow GHC can't take the constraint apart
03:47:46 <ski> could you repro, statusfailed ?
03:47:50 <merijn> mikidep: I have a sort of gradual switching you can see in, for example, the type signatures. If they can fit on one line with the name, do that. If not, move the signature to a separate line indented once, if that doesn't fit, linewrap at every ->
03:48:05 <merijn> mikidep: And if *that* doesn't fit, despair and improvise whatever looks good ;)
03:48:23 <ziman> (this is a reduced example of a real-world problem, where I want to implement fromByteString and toByteString)
03:48:36 <ziman> any ideas how to make this go through?
03:48:44 <dramforever> statusfailed: Can you paste a (preferably minimal) example to gist.github.com or something, so we know exactly what you did?
03:49:40 <merijn> dramforever: But how can it possibly tell what I did or did not arrange?
03:49:56 <dramforever> It can be conservative
03:50:30 <dramforever> ziman: Maybe make the base case at line 6 AllShow '[] = ()
03:50:50 <Axman6> yeah I was going to say that's an odd base case
03:51:15 <dramforever> merijn: Something *like* this
03:51:19 <dramforever> https://github.com/tweag/ormolu/blob/master/DESIGN.md#printing
03:51:21 <mikidep> merijn: that's also reasonable
03:51:22 <dramforever> probably not exactly
03:51:30 <ziman> oh, that works
03:51:35 <ziman> thank you very much!
03:51:42 <Axman6> ziman: it doesn't work because there's nothing stopping you passing in Nil
03:52:19 <statusfailed> ski, dramforever sure
03:52:44 <Axman6> and there's no instance for AllShow '[]
03:53:06 <ziman> and I even have an explicit clause of tshow for that case ;)
03:53:15 <statusfailed> ski, dramforever: https://gist.github.com/statusfailed/309c7efc9ded57de9cab6373b773af0d
03:53:18 <Axman6> yeah
03:54:09 <ski> statusfailed : tried adding `{-# LANGUAGE PatternSynonym #-}' to the top of that file ?
03:54:24 <ski> statusfailed : also, what if you prepend `pattern' to the import item ?
03:54:48 <statusfailed> ski: yea tried the extension, didn't work
03:55:19 <statusfailed> ski: yay!
03:55:25 <statusfailed> ski: adding pattern to the import works
03:55:27 <statusfailed> cheers!
03:55:35 <ski> np
04:09:58 <ski> hm, now i kinda wish Haskell had a proper mode system ..
04:14:43 <maerwald> what's the easiest way to get the output of running a command as a String with TH at compile-time
04:25:21 <[exa]> ski: modes like +-? from prolog?
04:26:40 <MarcelineVQ> maerwald: maybe spliced  (litE . stringL) <$> runIO (readProcess "echo" ["foo"] "")
04:27:32 <MarcelineVQ> (LitE . StringL)  rather, depending on your imports
04:29:56 <ski> well, perhaps more like Mercury, [exa]. since Prolog doesn't have modes in the language (although some implementations have descriptive or prescriptive modes)
04:30:11 <ski> point is that the pattern synonym things are a step in such a direction
04:31:29 <ski> e.g. i'd like to be able to write (simple familiar example) `foo ("blah" ++ s) = ..s..)'
04:33:39 <[exa]> hmm
04:33:58 <[exa]> ok guess I get the connection now
04:35:16 <[exa]> wouldn't it be easier to use some simple syntax for supporting prisms in that place?
04:36:22 <ski> the `COMPLETE' pragma is also relevant, here
04:36:38 <[exa]> oh and there are free variables in there, hm
04:37:05 <[exa]> ok that's certainly some good stuff to think about, thanks.
04:39:35 <ski> (should there be a `DISJOINT' pragma ?)
04:53:47 <zincy_> If x contains an exception. Why would we need to use evaluate . force  to guarantee that it is raised immediately and not just evaluate?
04:54:17 <zincy_> Is it because evaluate alone won't *fully* evaluate x all the way down if the exception is deep within thunks in x
04:55:41 <merijn> zincy_: If you don't force it, the exception may escape any surrounding catch/finally/try/etc. operations
04:56:01 <merijn> zincy_: The real solution is to simply never use "throw" and only use throwIO
04:58:07 <zincy_> Ah so evaluate doesn't force the exception.
04:58:26 <zincy_> I guess throwIO is equivalent to evaluate . force?
04:58:42 <merijn> No
04:59:03 <merijn> evaluate force something to WHNF and force forces *everything* when forced to WHNF
04:59:19 <merijn> zincy_: Which is all wasteful because you're strictifying the entire result of a computation
04:59:32 <merijn> throwIO removes the need to evaluate anything
05:00:24 <merijn> zincy_: the problem is that "throw" doesn't throw until it is forced. throwIO ties the throwing to IO's sequencing and thus guarantees anything thrown with throwIO can never hide in some unevaluated expression
05:00:37 <zincy_> So by piggybacking the strongly ordered execution of IO you don't need to evaluate anything when it comes to throwIO?
05:00:44 <merijn> zincy_: Yes
05:00:56 <merijn> :t Control.Exception.catch
05:00:58 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
05:03:23 <merijn> zincy_: the problem with "throw" is that the exception may be hiding in an unevaluated thunk of 'a'. If you use "throwIO :: Exception e => e -> IO a" it guarantees that the exception is raised before the "IO a" finishes. This guarantees it can't escape from the "IO a" part of catch (because catch only terminates after the first argument finishes and throwIO guarantees raising the exception before then)
05:03:23 <ski> [exa] : hm, btw, how did you intend to use prisms there ? with a view pattern (or pattern guard) ?
05:05:40 <[exa]> ski: not sure really, don't know how to get more variables in there
05:05:46 <zincy_> merijn: So evaluate . force would do the same thing as throwIO but it is wasteful because the evaluation would continue past the point an exception is raised?
05:07:11 <merijn> zincy_: I think the exception would abort it. It's wasteful because, if there's no exception you're still evaluating everything
05:07:39 <zincy_> ah yes
05:08:13 <zincy_> So throwIO only fully evaluates when an exception is present
05:08:27 <zincy_> by tying evaluation to execution
05:08:30 <merijn> zincy_: throwIO doesn't need to fully evaluate
05:08:48 <merijn> zincy_: throwIO ties "throwing exception" to IO, rather than to evaluation
05:08:51 <zincy_> So you can have execution without full evaluation?
05:08:58 <[exa]> ski: (well at least it could "lens down" a complicated patternmatch to a simple pattern match, with pattern like say `a@^(prefixed "blah")` in your case (I made the @^ thing up as a combination of @ and ^? minus ?)
05:10:36 <[exa]> ski: preferably getting out more variables wit ha prism that views the result wrapped in something, like `(V2 x y)@^(get2dimensions 123 543 vector)`
05:10:49 <[exa]> but well the last example is dumb
05:12:25 <[exa]> perhaps I'm reinventing something that already exists, but it comes natural as: prisms generalize the patternmatch -> why not just use them for a better patternmatch
05:13:33 <ski> hm, would those correspond to `(^? prefixed "blah) -> Just a' and `(^? get2dimensions 123 543 vector) -> Just (V2 x y)' ?
05:14:12 <[exa]> yes, very likely
05:14:26 <[exa]> except without the Maybe in the way
05:15:04 <zincy_> merijn: I am wondering if my confusion is beyond help and I need to go and learn about laziness
05:16:12 <zincy_> Gonna read this which I think you linked https://apfelmus.nfshost.com/articles/lazy-eval.html
05:18:51 <ski> i suppose i'd prefer being able to write `a ^. prefixed "blah"' and `V2 x y ^. get2dimensions 123 543 vector', in these cases
05:19:40 <ski> [exa] : i'd like to share corresponding syntactica phrase forms, between patterns and expressions, as much as possible, when the "abstract semantics" is the same
05:21:44 <[exa]> yes, understood. That's why the prisms came to mind as they are nicely almost-bidirectional. Except that syntax needs a lot of polishing I guess. :]
05:38:14 <zincy_> merijn: In Control.Except it says "The rule of thumb is to use evaluate to force or handle exceptions in lazy values."
05:38:48 <zincy_> But then it says that evaluate only goes to WHNF. So why does it say that evaluate forces exceptions?
05:39:13 <zincy_> evaluate wouldn't force the exception if the value needed to be evaluated to NF in order to be raised right?
05:39:31 <merijn> zincy_: Simpler rule of thumb: Never put exceptions in lazy values by using throwIO instead
05:41:02 <solonarv> that doesn't help you when libraries do the bad things, tbh
05:41:24 <merijn> solonarv: That's fairly rare, though
05:41:46 <solonarv> (btw, you can combine evaluate with 'force' from deepseq to get as-deep-as-possible NF
05:41:49 <solonarv> )
05:41:49 <merijn> solonarv: Also "always force everything to NF" is the only solution to that, which is, frankly insane
05:42:06 <solonarv> oh yes, I'm not saying you should do that all the time
05:42:24 <solonarv> in fact I can't remember the last time I actually had to use evaluate *or* force
05:42:32 <solonarv> I did play around with them but have never needed them
05:43:40 <zincy_> So can IO throw an exception inside a value without evaluating it? I wouldn't have thought so
05:44:14 <solonarv> no, you are confusing things: 'throw' is how you throw exceptions when evaluating a value
05:44:26 <zincy_> From what I understand throwIO is a way of evaluating only as much as you ever need to in order to raise the exception and guarantee it is always raised immediately so it can be caught
05:44:41 <solonarv> merijn is saying that you should not use throw, and should instead (if you really need exceptions) use throwIO and accept the IO being in your type signature
05:45:36 <solonarv> % :t \a -> unsafePerformIO ((Right <$> evaluate (force a)) `catch` (pure . Left))
05:45:37 <yahb> solonarv: ; <interactive>:1:45: error: Variable not in scope: force :: t -> b
05:45:45 <solonarv> % import Control.Deepseq
05:45:46 <yahb> solonarv: ; <no location info>: error:; Could not find module `Control.Deepseq'; Perhaps you meant Control.DeepSeq (from deepseq-1.4.4.0)
05:45:48 <solonarv> % import Control.DeepSeq
05:45:48 <yahb> solonarv: 
05:45:50 <solonarv> % :t \a -> unsafePerformIO ((Right <$> evaluate (force a)) `catch` (pure . Left))
05:45:50 <yahb> solonarv: forall {a} {b}. (Exception a, NFData b) => b -> Either a b
05:46:16 <solonarv> see, you *can* do this sort of thing to catch pure exceptions, but that's all I've ever found myself using force/evaluate for
05:46:42 <ski> @hoogle Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b
05:46:43 <lambdabot> No results found
05:47:35 <solonarv> :t \f g -> try >=> either f g
05:47:37 <lambdabot> Exception a => (a -> IO c) -> (b -> IO c) -> IO b -> IO c
05:47:45 <solonarv> up to argument order, blah
05:48:10 <solonarv> I guess I could've used 'try' for my thing.
05:50:38 <zincy_> ah so throwIO means the exception isn't tied to evaluation?
05:50:42 <zincy_> At all.
05:51:02 <solonarv> :t throwIO
05:51:03 <lambdabot> Exception e => e -> IO a
05:51:11 <zincy_> When the IO action is evaluated, the exception isnt raised. Only when the IO action is executed.
05:51:15 <solonarv> yes
05:51:19 <zincy_> Yay!
05:51:22 <zincy_> Finally got there
05:51:37 <solonarv> just like 'readFile "doesntexist.txt"' only throws when it actually is executed :)
05:53:54 * ski . o O ( "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <https://www.researchgate.net/profile/Nick_Benton2/publication/234791717_Exceptional_syntax/links/0c9605264f817cea5d000000/Exceptional-syntax.pdf> )
05:54:41 <ski> (that talks about why a `catchBind' operation is good to have direct support for)
06:11:45 <frdg> https://pastebin.com/LFRSHjVj question about writing functor instances
06:12:43 <frdg> maybe it has to do with kinds?
06:13:14 <[exa]> frdg: no, just the types in the second constructor do not match
06:13:38 <[exa]> here: `Three' a b (f c)`
06:13:41 <Axman6> your definition of Three says that the second and third values the Three' constructor contains must be the same type
06:13:59 <Axman6> if you apply f to only one of them, then they will be different types
06:14:18 <frdg> and if I only apply the function to one of the values im risking having different types?
06:14:28 <[exa]> frdg: `b` and `(f c)` need to have the same type by constructor definition, which you contradict because from input `b` and `c` have the same type and you modify `c` by `f`
06:14:34 <Axman6> there's no risk, you have said it's not possible
06:15:05 <Axman6> Three' has the type a -> b -> b -> Three a b, the second and third arguments )must_ be the same type
06:15:13 <Axman6> _must_*
06:15:32 <[exa]> frdg: btw the second version would work with definition `data Three' a b = Three' a a b`
06:15:49 <Axman6> the type of fmap for three is fmap :: (a -> b) -> Three x a -> Three x b
06:16:32 <frdg> axman6: right but I could in theory apply a function that goes from `Int -> Int` and then I will still have the same types. But just the fact that many functions change types it wouldn't make sense to do what I tried to do. Is this accurate?
06:17:08 <Axman6> fmap says you must handl;e the case when a is not the same as b in fmap :: (a -> b) -> f a -> f b
06:17:31 <frdg> Ok I understand. Thanks guys
06:17:39 <Axman6> it doesn't matter that a and b _could_ be the same, it _must_ work when they are not the same
06:17:54 <[exa]> frdg: the grand purpose of functors is that you can't really choose what's inside or what transformation comes with 'fmap'
06:18:27 <frdg> [exa]: ok I see. Ill put that quote on my wall!
06:19:52 <[exa]> frdg: more precisely, specific stuff that only work "for some types" aren't general enough to be functors. Generally the rule with implementing functors is to never touch the type you "carry", and only handle the structure of the wrapping
06:20:49 <frdg> ok cool
06:29:53 <jophish> statusfailed: Hi, I'm expipiplus1 on github
06:37:21 <solonarv> in fact there is a theorem saying: for a given type F, there is at most one lawful 'Functor F' instance.
06:37:32 <solonarv> (and the only law is 'fmap id = id', or 'fmap id x = x')
06:52:17 <yanti> im back
06:52:24 <yanti> whats up ppl
06:52:39 <yanti> ppl who dont like abbreviations
06:53:11 <yanti> #haskell-blah
06:55:14 <cmcma20> hello people! Let Finite be (Bounded, Enum). Can Haskell automatically derive Finite instances for GADTs indexed by Finite types, if all constructors of this GADT have Finite arguments?
06:57:17 <cmcma20> Can Finite then be derived for Sigma a (GADT a), where a is Finite itself?
06:57:34 <solonarv> Can Haskell (the language as described in the Haskell Report)? No, because that behavior isn't in the Haskell Report. Can GHC? Also no, not automatically
06:57:44 <solonarv> Can you write those instances yourself? Yes, you can.
06:57:49 <dmwit> cmcma20: http://hackage.haskell.org/package/universe-some-1.2/docs/Data-Universe-Some-TH.html
06:58:27 <cmcma20> dmwit: god bless you, son of Galois
06:58:36 <cmcma20> It's exactly what I'm looking for
06:59:33 <dmwit> ^_^
07:05:26 <maerwald> MarcelineVQ: the idea is to catch the result of 'git describe' at compile time
07:09:35 <MarcelineVQ> right so something like   describe_result = $( (LitE . StringL) <$> runIO (readProcess "git" ["describe","--all"] "") )   ?
07:11:33 <merijn> maerwald: That sounds rather brittle, tbh
07:11:38 <MarcelineVQ> You can get more control than that, readProcess is just the most direct thing in process that returns something
07:12:58 <MarcelineVQ> reading the output lazily takes a few extra steps for instance since readProcess will block until it's done
07:16:24 <MarcelineVQ> maerwald: People are sure to have useful things to add if you have more details though
07:20:59 <merijn> Doing this in TH would mean it breaks as soon as I try and build it, so that's unfortunate >.>
07:21:32 <merijn> Or maybe it doesn't break, but then I'd get "fatal: not a git repository (or any of the parent directories): .git" in the source :p
07:23:48 <statusfailed> jophish: oh hi :)
07:23:57 <statusfailed> thanks for all your help btw
07:23:58 <MarcelineVQ> Can't expect much better from just reading the string result of a command
07:25:48 <jophish> statusfailed: no problem, thank you for helping make the examples run on other drivers than nvidia!
07:26:02 <statusfailed> haha no worries, let's see if it works first :p
07:26:32 <jophish> I've managed to stop the nvidia driver on my laptop, but haven't got the intel one working :(
07:26:38 <jophish> typicalk
07:27:03 <statusfailed> I had a horrible time trying to get optimus running on my previous laptop so i basically gave up ^^;
07:27:22 <jophish> yeah, likewise. But I happened to land on the nvidia side of the fence
07:27:39 <jophish> I'm sure I had it working nicely at one point
07:29:31 <jophish> statusfailed: so to recap, the program segfaults when you have the debug utils extension enabled, and you get ERROR_INITIALIZATION_FAILED when it doens't have it enabled?
07:30:49 <statusfailed> jophish: that's right- although I realised that if I run the examples in the main library with "cabal run" I get a different error again: ERROR_LAYER_NOT_PRESENT
07:31:07 <statusfailed> ( I think I started doing the standalone examples just to see where it was going wrong )
07:31:10 <jophish> I think your guess is right about why the initialization fails, the queue setup must be different on the intel card
07:31:28 <jophish> the cabal problem is almost certainly cabal messing up the environment in which this is run
07:31:37 <jophish> (so that the khronos validation layer isn't found
07:31:42 <statusfailed> There's only one queue on the intel card- is it the same on the nvidia one?
07:31:52 <statusfailed> I mean graphicsQueueFamilyIndex and presentQueueFamilyIndex are both 0
07:32:01 <statusfailed> oh I see
07:33:36 <jophish> They're both 0 for my nvidia card
07:33:41 <statusfailed> hmm ok
07:34:11 <jophish> Although not strictly required by the spec, I think that all or nearly all implementations are able to present from the graphics queu
07:34:27 <jophish> there was an issue about making this a requirement on the github tracker some time ago
07:35:26 <jophish> having to start ubuntu in recovery mode lol
07:35:54 <statusfailed> jophish: to get the intel driver loaded? :D
07:36:01 <jophish> yeah, :)
07:36:03 <jophish> all in a days work
07:36:12 <statusfailed> #lifehacks
07:36:59 <statusfailed> jophish: got some debug output finally
07:37:04 <EvilPyro> is required to return IO() in any function that returns something ? how can i stop the propagation of -> IO() on functions?
07:37:14 <statusfailed> Validation: terminator_CreateDevice: Failed in ICD /usr/lib/libvulkan_intel.so vkCreateDevicecall
07:37:20 <statusfailed> Validation: vkCreateDevice:  Failed to create device chain.
07:37:44 <ski> EvilPyro : pass the result of one `IO'-action, rather the `IO'-action itself, to another function
07:37:53 <statusfailed> I hope this isn't something stupid like "I forgot to reboot after updating"... I'm gonna try that
07:39:20 <EvilPyro> ski, can ou point me an example?
07:39:46 <ski> EvilPyro : well, if you have some code you're struggling with, i could take a look, and perhaps come with some suggestions for improvement ?
07:40:42 <maerwald> merijn: it would fall back to the version if the process fails in any way
07:41:21 <jophish> statusfailed: try adding DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT and DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT to the messageSeverity flags
07:43:00 <EvilPyro> ski, https://pastebin.com/1bBUcZz6 just at the end, line 193
07:44:48 <statusfailed> jophish: OK
07:45:39 <ski> EvilPyro : btw, look into `randomRIO'
07:45:59 <ski> (`deriving (Read)' could be just `deriving Read')
07:46:52 <ski> i think neither `Owner' nor `Grid' should have that code in `Show' instances
07:48:23 <EvilPyro> I'll probably ask my teacher for permision changing that to a better approach
07:48:40 <ski> `((y*w) + x)' could be just `y*w + x'. better to express `grid_valid_pos' as one large `Bool'ean expression, rather than using guards
07:49:16 <statusfailed> jophish: having some issues getting the standalone examples to compile now- type error related to the ::& operator
07:49:49 <jophish> I made the type a little more general a couple of commits ago
07:49:56 <ski> `(prev ++ [v]) ++ end' would be more efficient as `prev ++ [v] ++ end' (which is parsed as `'
07:49:59 <ski> 16:45 < ski> (`deriving (Read)' could be just `deriving Read')
07:49:59 <ski> er
07:50:00 <jophish> it should still be ok to just set the 'next' member directly
07:50:03 <statusfailed> i'm not sure what's wrong because it's now pretty identical to the example in the main project
07:50:21 <ski> (which is parsed as `prev ++ ([v] ++ end)')
07:50:36 <statusfailed> jophish: ah ok, I'll just do that
07:50:55 <jophish> statusfailed: I think I can use the intel driver here as long as I don't reboot
07:51:29 <jophish> yeah, vulkaninfo says intel 630
07:51:52 <ski> `(last_row !! column)' could be just `last_row !! column'. `(used_board_cells (Grid w h remaining) column)' could be `used_board_cells (Grid w h remaining) column'
07:52:05 <statusfailed> jophish: want me to post the verbose debug output on the github issue?
07:52:17 <ski> and `(length l) - w' could be `length l - w'
07:53:20 <jophish> statusfailed: sure
07:53:23 <ski> similarly redundant brackets in `(all (grid_valid_pos board) x)' and `(h - 1 - used_board_cells (Grid w h l) col)'
07:53:42 <jophish> I'm hoping it has some output like https://github.com/realitix/vulkan/issues/23#issuecomment-326249345
07:54:25 <ski> EvilPyro : `check_line' should also be expressed as a large `Bool'ean expression, rather than using guards (which doesn't really help comprehension, in cases such as these)
07:54:45 <ski> and ditto for `is_winner_movement'
07:56:14 <ski> EvilPyro : the type ascriptions on the calls to `read' in `main' are not necessary, since the types of the functions being called provides the expected type, as argument type
07:57:01 <statusfailed> jophish: i'm gonna try rebooting in case it's to do with having updated
07:58:31 <ski> EvilPyro : what should `play' do, when passed `Empty' ?
07:58:52 <statusfailed> jophish: ok, update changed nothing :)
07:59:42 <EvilPyro> ski its an invalid parameter, a position in the board can be owned by Empty, Machine or Player, I'm reusing that data type for the Machine and Player types
07:59:53 <ski> EvilPyro : type ascriptions in `player_turn' are also redundant
08:00:38 <ski> `(options !! rint)' could be just `options !! rint', and `(used_board_cells (Grid w h l) x) < h)' just `used_board_cells (Grid w h l) x < h'
08:00:44 <jophish> statusfailed: hmm, the log isn't too helpful either
08:00:53 <jophish> \might be time to ask in ##vulkan
08:01:37 <jophish> I'm getting closer to getting things running on my end
08:02:06 <EvilPyro> ski, when you say that type ascriptions are redundant you mean name::Type can be just name right? The read call its required anyway
08:02:31 <statusfailed> jophish: I might try some vulkan test programs, I don't think I've done that
08:02:43 <ski> EvilPyro : `player_turn',`machine_turn',`machine_random_ia' all themselves does I/O, so return type should be `IO Something' (`Something' in your case being `()')
08:02:53 <statusfailed> what was the equivalent of opengl spinning cube?
08:03:11 <statusfailed> vkcube- works
08:03:17 <jophish> that's good
08:03:31 <ski> EvilPyro : "its an invalid parameter, a position in the board can be owned by Empty, Machine or Player" -- then match on `Machine', so that if you accidentally pass `Empty', you get a "loud bang", rather that the program silently doing the wrong thing
08:03:48 <ski> EvilPyro : "when you say that type ascriptions are redundant you mean name::Type can be just name right? The read call its required anyway" -- yes
08:04:47 <jophish> statusfailed: what happens if you try to create the device with a more simple deviceCreateInfo?
08:05:05 <jophish> (for example no enabled extensions and no queues)
08:05:33 <jophish> or removing the queue protected bit
08:05:42 <jophish> it may fail later on, but at least you'll have a device
08:06:35 <statusfailed> jophish: I tried creating without queues, but the validator layer complains - I think it's against the spec? you have to have at least one queue?
08:06:49 <statusfailed> I'll try removing the protected bit
08:07:32 <statusfailed> jophish: removing protected bit gets me a beautiful triangle on the screen
08:07:33 <statusfailed> :
08:07:34 <statusfailed> :D
08:07:45 <jophish> \o/
08:07:47 <jophish> so simple
08:07:51 <statusfailed> amazing :D
08:07:53 <statusfailed> thanks!
08:07:55 <EvilPyro> ski, lmao I've changed a lot of things and anoted a lot more thanks, but I still dont know how to manage the problem with IO in machine_turn, my plan its to refactor machine_random_ia and future machine AIs to return the chosen column instead of the resultant board, so machine_turn also manages winning state and congrats message
08:08:03 <statusfailed> jophish: I will update the github thread- what's the protected bit do?
08:08:04 <jophish> why on earth didn't the validation layer pick up on that!?!?!
08:08:09 <statusfailed> not a clue :D
08:08:27 <statusfailed> is it maybe an implementation-specific thing? stabbing in the dark here
08:08:40 <jophish> statusfailed: just turns on protected memory or something
08:08:45 <jophish> non essential for a triangle
08:08:48 <statusfailed> like, it's not against the spec, but intel doesn't support it? *shrug*
08:08:48 <jophish> or anything
08:09:10 <ski> EvilPyro : i still don't see what you think is a problem, there
08:09:12 <jophish> yeah, it's queryable in the device features I think
08:09:19 <ski> it does I/O, it should have an `IO' result type
08:10:03 <EvilPyro> ski let me refactor some things a bit and repeat the question with a proper example of the problem
08:10:10 <ski> EvilPyro : if you refactor them so that they don't, themselves, do I/O, then you could avoid the `IO' in their type. but you'd presumably need some kind of driver which, on their behalf, did I/O, i think ?
08:10:30 <statusfailed> jophish: well either way, thanks for sticking with this! I would definitely never have gotten to this wonderful triangle without your helP :D
08:10:37 <ski> EvilPyro : yea, i didn't check the details of what the code did, too closely, on this read
08:10:49 <jophish> statusfailed: no problem at all
08:11:09 <jophish> thank you for your patience too :)
08:12:53 <statusfailed> jophish: not at all!
08:13:06 <statusfailed> looking forward to future messing around with the librarY :D
08:13:21 <jophish> suggestions are very welcome
08:15:50 <yanti> hey can i bud in?
08:16:22 <yanti> https://pastebin.com/0xQUMyS9
08:16:46 <jophish> oh, statusfailed. What was it you did to get the debug utils extension working?
08:16:53 <yanti> hey umm im hiring
08:16:57 <frdg> how should I generally think about "non-type variable argument in this constraint" errors? Am I correct to say that they come up when you feed a function a value that doesn't match the functions type-signature?
08:17:09 <jophish> btw, I've used this library successfully with RenderDoc, it's a super useful tool for writing Vulkan programs
08:17:30 <yanti> oo interesting convo
08:17:36 <yanti> vulkan?
08:17:40 <yanti> like gpu ?
08:19:03 <jophish> yanti: exactly
08:19:21 <yanti> oo cool
08:19:25 <jophish> (although there do exist CPU implementations)
08:19:34 <yanti> so u are a gpu guru?
08:19:47 <yanti> jophish
08:22:08 <EvilPyro> ski, not all changes have been applied but its enough to show the problem, https://pastebin.com/HpVDxZRT function machine_turn
08:22:13 <jophish> yanti: lol, I just spent the last 30 minutes failing to switch GPUs on my laptop :)
08:22:32 <jophish> yanti: interesting job ad, seems to cover a very wide array of topics
08:22:43 <Cale> Yeah "interesting"
08:22:45 <Cale> haha
08:23:13 <yanti> yeah
08:23:45 <statusfailed> jophish: hmm I think I might have been confused when I disabled the debug utils extension, Ic an't recall what I did to get it working
08:23:50 <yanti> i have lots of open topics
08:24:03 <jophish> "We need to create ~50 games to make our app more pizzaz", you must be hiring a lot of devs
08:24:08 <EvilPyro> ski, main calls play, play calls either player_turn or machine_turn. machine_turn can call 3 other funcs that will be AIs, the only one implemented for now is machine_random_ia
08:24:26 <statusfailed> jophish: oh, and thanks for the tip on RenderDoc! that should come in handy!
08:24:41 <yanti> jophish yeah.. not really hiring.. we are building a publishing studio
08:25:09 <yanti> and as a publishing studio we will help lots of noob dev finish their first project
08:25:14 <yanti> with our guidance
08:25:32 <EvilPyro> ski, not sure if this is the best approach since the random ai returns IO Int but the other two could return Int
08:26:01 <yanti> most indie game devs fail.. like 99%. and its sad.. because they often have cool ideas
08:26:10 <yanti> but they dont understand scale
08:27:21 <yanti> almost all noob dev jump too high.. then crash.. then give up
08:27:23 <yanti> :(
08:28:08 <ski> EvilPyro : mhm, okay
08:28:27 <tdammers> you think understanding scale is the problem? idk, I think understanding marketing and business is more likely the culprit
08:28:54 <yanti> lots of culprits yeah
08:29:06 <tdammers> but, yeah, megalomania also
08:29:16 <jophish> I think in a lot of cases (this probably applies to any creative project) the idea is just pants
08:29:19 <tdammers> comparing yourself to big studios who can throw hundreds of people at a project
08:29:21 <yanti> not understanding scale is a symptom of not understanding business in their case
08:29:30 <tdammers> hmhm
08:29:32 <yanti> lots of terrible feature creep
08:29:54 <tdammers> yeah, but I think that's not so much "not understanding scale", but just "not being realistic about what your team can do"
08:30:02 <yanti> yup
08:30:20 <ski> EvilPyro : i don't see any immediate problem or issue, relating to I/O, yet
08:30:56 <yanti> any ML people here wanna bounce some ideas?
08:31:01 <EvilPyro> ski, it doesnt compile 
08:31:42 <yanti> i need to figure out a good loss function for genetic algos
08:31:57 <ski> well, you haven't implemented `is_winner_movement' yet
08:32:14 <yanti> im stuck
08:32:22 * ski thought yanti meant ML, as in SML,OCaml,F#,AliceML
08:32:29 <yanti> oh
08:32:32 <yanti> umm
08:32:37 <yanti> AI
08:32:50 <EvilPyro> ski, what? yes i did
08:33:14 <yanti> so  like the naive solution is to do regulariztion like in NN
08:33:28 <EvilPyro> Its pending a refactor, I'll make it a big boolean expresion as you said
08:33:33 <EvilPyro> but it work
08:33:35 <EvilPyro> s
08:33:54 <yanti> loss(h) = fitness(h) + k*size(h)
08:35:07 <EvilPyro> ski, Couldn't match expected type Int with actual type IO Int in machine_turn
08:35:26 <ski>   let election = machine_random_ia board
08:35:28 <ski> should be
08:35:32 <ski>   election <- machine_random_ia board
08:36:02 <MarcelineVQ> yanti: galaxybrain is to not have a direct objective function https://www.frontiersin.org/articles/10.3389/frobt.2016.00040/full
08:36:09 <Cale> yanti: This channel is about Haskell, do you have any Haskell questions?
08:36:44 <Cale> (You might be better served by finding a machine learning channel instead to talk about machine learning)
08:36:45 <yanti> oh sorry
08:36:57 <yanti> i wondered off
08:37:04 <EvilPyro> ski, I must learn about the do notation and what <- actually means, for me it was equivalent to declaring a binding
08:37:12 <yanti> im looking for haskell devs Cale
08:37:13 <EvilPyro> thankyou!
08:37:29 <MarcelineVQ> EvilPyro: http://www.vex.net/~trebla/haskell/IO.xhtml
08:37:39 <yanti> not sure where to findem
08:38:14 <Cale> I'm not sure you're going to find anyone who will take that job offer seriously.
08:38:38 <yanti> can you help me understand why
08:38:52 <yanti> im verry different from hitech people
08:38:59 <Cale> It's unrealistically broad
08:39:03 <yanti> thats why ive been freelancing all my life
08:39:25 <yanti> but im really planning on doing all of that in 2 months
08:39:28 <yanti> Cale
08:39:32 <Cale> Basically, nobody's going to believe that your company who nobody's heard of does all that stuff
08:39:40 <Cale> Start with one thing.
08:39:50 <yanti> ok thanks
08:40:00 <yanti> im kinda megalomaniac
08:40:03 <yanti> diagnosed
08:40:17 <yanti> so i sometimes just wonder off
08:40:35 <yanti> but i rly believe ill achieve like 70% of my goals
08:40:36 <maerwald> Now I feel comfortable for you hiring me
08:40:56 <yanti> ok but im on meds
08:41:04 <yanti> im pretty healthy
08:41:16 <maerwald> Ok, I'm in
08:41:17 <yanti> its mostly the weed that drives me into mainia
08:41:25 <yanti> hehe
08:42:22 <yanti> and Cale ive been "hasking" here about ML because im more interesten in making a formal function Learn(DATA) in haskell
08:42:39 <yanti> i think its possible
08:42:47 <yanti> the "one true" learning algo
08:43:21 <yanti> its similar to my stateless-abstracted-server idea
08:43:42 <yanti> servers only realy see bitstreams passing thru them
08:43:58 <yanti> they dont need to care what the bitstream represents
08:44:09 <yanti> the server only needs to know delta functions
08:45:35 <yanti> so a server that can handle a multiplayer game and then a chat session - withot any code switching or polymorphizm
08:45:57 <yanti> is kinda like an ML algo that ccan learn any DATASET
08:46:29 <yanti> without switching between hypothesis clases
08:47:52 <yanti> :(
08:47:59 <yanti> cmon guys talk to me
08:48:03 <yanti> im lonely
08:49:13 <maerwald> Those are all great ideas
08:49:20 <maerwald> Who's funding you?
08:49:35 <yanti> now im funding my self
08:49:39 <yanti> with my savings
08:50:26 <yanti> but im gaining lots of attention in israel
08:50:43 <yanti> basically i think im to israeli and rude and thats y u dont like me
08:50:51 <yanti> too
08:51:24 <yanti> ive been having a hard time with hitech people since forever
08:51:29 <ja> maerwald: in a serious setting, do you think it is ok to ask who is funding in a job interview?
08:51:32 <enthropy> running 'cabal install --constraint="containers==0.6.0.1"' somehow leads cabal to build a newer containers. Is there an easier way to figure it out than reading through -v3
08:51:48 <yanti> hi ja
08:51:48 <maerwald> ja: yes
08:52:16 <yanti> im in a less manic state now ja
08:52:19 <ja> maerwald: i have to muster the courage next time :)
08:52:32 <enthropy> if I request a version that isn't installed, it quits right away
08:52:41 <maerwald> ja: I also usually ask who's the biggest customer
08:53:08 <maerwald> yanti: There are a few offtopic channels where your ideas might be more appreciated
08:53:20 <monochrom> Why is the troll still here?
08:53:22 --- mode: ChanServ set +o monochrom
08:53:25 <yanti> i tried blah
08:53:27 --- mode: monochrom set +b *!*@147.161.15.182
08:53:27 --- kick: yanti was kicked by monochrom (yanti)
08:53:32 --- mode: monochrom set -o monochrom
08:53:38 <ja> thanks, finally :D
08:53:57 <Cale> monochrom: haha, I thought it was kind of funny, but yeah, it was wearing a bit thin
08:54:08 <maerwald> It was also a bit sad
08:54:22 <ja> nah, can't assume good faith on IRC ;)
08:54:36 <monochrom> It was fun between midnight and dawn when people were bored, I understand. But back to work now, all of you.
08:54:45 <MarcelineVQ> It's the position of this channel, historically, to assume good faith :>
08:54:55 <ja> oh, didn't know this channel had an official timezone :O
08:54:59 <MarcelineVQ> But if you do want to troll you should endevor to be either funny or subtle.
08:55:29 <johnw> we want to be artfully trolled?
08:58:00 * MarcelineVQ sagenods
08:58:44 <solonarv> I think they spammed /r/haskell a week or two ago as well
09:00:16 <ski> @quote calmly.talk
09:00:16 <lambdabot> jmcarthur says: we calmly talk trolls to death
09:00:24 <ski> @quote feed.trolls
09:00:24 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
09:00:30 <ski> @quote read.a.few
09:00:30 <lambdabot> accel says: next time I'll read a few research papers before I start trolling hakell
09:00:33 <zincy_> MarcelineVQ: The subtle trolls have the most potential for damage
09:01:06 <enthropy> nevermind about my problem the newer version of containers is just needed for an executable (happy)
09:01:17 <ski> @quote sufficiently.advanced.ignorance
09:01:18 <lambdabot> jlf says: sufficiently advanced ignorance is indistinguishable from trolling
09:01:19 <tdammers> ja: asking about the business structure isn't outrageous at all; it shows interest, a sense of business concerns, and the ability to look beyond your own plate
09:01:25 <tdammers> ja: by all means do
09:01:39 <zincy_> haha those are great quotes
09:02:59 <MarcelineVQ> further, if an employer is reluctant rather than proud of their money source and which of their customers trusts them most, red flag
09:06:21 <monochrom> You still don't know whether I have been trolling you, after all these years --- I think 2 decades already.
09:06:33 <monochrom> <--- literally a Chinese room.
09:07:01 <maerwald> Wonder if there's funding for trolls...
09:07:05 <MarcelineVQ> hey now, your thesis supervisor told me you were probably real, though he did refuse to say anything further
09:07:14 <monochrom> Perhaps I learned Haskell so that I can make Haskell puns.
09:07:24 <MarcelineVQ> Except maybe "get out of my house" but that was unrelated I think
09:07:40 <monochrom> heh
09:08:50 <zincy_> monochrom: Has #haskell even been around for twenty years?
09:09:02 <monochrom> I don't know.
09:09:11 <MarcelineVQ> more than 10 for sure
09:09:16 <zincy_> Where are the elders
09:09:16 <monochrom> But chanserv knows
09:09:48 <zincy_> monochrom: My new favourite phrase is bird brain.
09:10:17 <MarcelineVQ> bird up
09:10:37 <zincy_> Although crows are remarkably intelligent. 
09:11:31 <maerwald> And octopi
09:11:46 <maerwald> But why are we talking about fish now?
09:12:22 <MarcelineVQ> because squid's have feelings too
09:12:40 <zincy_> Maybe animals insult each other with "sapien brain"
09:12:53 <monochrom> YES!
09:14:03 <ski> zincy_ : yes
09:15:38 <ski> @get-shapr
09:15:38 <lambdabot> shapr!!
09:16:05 <ski> zincy_,MarcelineVQ : i came here, in 2001, i think
09:16:44 <MarcelineVQ> you've been here longer than mniip's been alive
09:16:45 <ski> we were maybe around fifteen to twenty people in the channel then ?
09:17:36 <ski> my first IRC channel. back then, i thought every IRC channel was as friendly and helpful :)
09:20:19 <maerwald> that kinda sounds romantic
09:26:07 <mniip> MarcelineVQ, that's incorrect
09:26:14 <MarcelineVQ> not in my head :>
09:31:16 <maerwald> ERROR: brittany pretty printer returned syntactically invalid result.
09:31:18 <maerwald> woosh
09:31:46 * Lycurgus dates to c. '06
09:31:56 <maerwald> hexagoxel: https://git.io/JfJWd 
09:32:14 <maerwald> it compiles
09:33:47 * Lycurgus (as far as #haskell is concerned)
09:34:09 * ski . o O ( ##prolog )
09:44:46 <hexagoxel> maerwald: do you _need_ the `do` in `DInfo -> do` (L743) ?
09:46:58 <hexagoxel> It is definitely a bug in brittany, but writing something like `do { x } >>= y` is a bit weird. I get the idea of argument-do, but this over-doing it
09:48:01 <maerwald> I don't really need it
09:48:40 <ski> `(UpgradeAt p)   ->' :(
09:49:14 <maerwald> ski: ?
09:49:30 <ski> redundant brackets
09:49:40 <maerwald> xD
09:50:01 <maerwald> I don't use hlint, for my own sanity
09:50:12 <ski> i don't, either
09:57:19 <maerwald> Haven't seen the hackagebot in a while
09:59:48 <ski> hm, true
10:35:45 * hackage apply-refact 0.8.0.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.8.0.0 (mpickering)
10:37:23 <lambdaFan> hello haskell gurus
10:38:45 <lambdaFan> is there any haskell os in development?
10:39:30 <lambdaFan> Yaramoe  hi
10:39:43 <lambdaFan> long time no see old friend
10:40:08 <ski> hello lambdaFan
10:40:14 <ski> not that i can recall
10:40:24 <Yaramoe> Hello
10:40:35 <lambdaFan> hey :)  dont think we know each other
10:40:56 <lambdaFan> u a veteran here?
10:41:30 <Yaramoe> No i just started
10:41:31 <ChaiTRex> lambdaFan: Don't know if they're currently in development, but see here: https://wiki.haskell.org/Applications_and_libraries/Operating_system
10:41:48 <lambdaFan> thanks
10:42:15 * hackage HListPP 0.2.2 - A preprocessor for HList labelable labels  https://hackage.haskell.org/package/HListPP-0.2.2 (AdamVogt)
10:43:12 <ski> @where house
10:43:12 <lambdabot> http://programatica.cs.pdx.edu/House/
10:43:32 <ski> (looks like that hasn't seen an update in a while, at least judging from a quick look on the page)
10:44:34 <lambdaFan> looks cool
10:44:46 <lambdaFan> very theoretical thou
10:50:07 <scheming_around> Is it possible to interpret System F as a category? It's clear how to view terms that are also well-typed in Hindley-Milner as morphisms, but it's not clear to me how something with type   .   can be viewed as a morphism, for example
10:52:12 <phadej> scheming_around: https://ncatlab.org/nlab/show/locally+cartesian+closed+category
11:00:35 <lambdaFan> btw im yanti the "troll"
11:00:48 <maerwald> loool
11:00:56 <monochrom> OK maybe not troll but definitely crackpot.
11:01:23 <lambdaFan> i dont want to annoy anyone
11:01:30 <monochrom> You already did.
11:01:56 <lambdaFan> you are serious? monochrom
11:02:02 <monochrom> Yes.
11:02:19 <monochrom> People literally rejoiced when I kicked you.
11:03:16 <Uniaika> (literally)
11:06:09 <lambdaFan> can i jump to the conclusion that most of you are ideologically left?
11:06:25 <maerwald> That is definitely a jump
11:06:53 <lambdaFan> so then i dont how do i annoy or troll when im trying to be nice
11:06:58 <MarcelineVQ> Literally a festival was held, but don't get it twisted, people just like festivals. One time a tree fell down and we had a bonefire party about it. We didn't even burn the tree that fell down.
11:07:20 <lambdaFan> hehe
11:07:44 <monochrom> I don't care what you intend or try.  I only look at the result.
11:07:51 <lambdaFan> its like coders are allergic to me
11:07:56 <lambdaFan> i dont get it
11:08:13 <lambdaFan> i cant get into any jobs
11:08:21 <lambdaFan> in israeli hightech
11:08:36 <monochrom> OK, here is a starter.  You talk big, do nothing.  Go talk to manager types.
11:09:01 <lambdaFan> no but i'm mathy like u
11:09:01 <monochrom> We are rightfully annoyed by postmodern talking big.
11:09:04 <MarcelineVQ> talk big do nothing + charisma = exceptional political pay
11:09:20 <lambdaFan> i dont just hand wave
11:09:26 <lambdaFan> i write equations
11:10:10 <monochrom> Again, I don't care what you claim is in your head. (Why should I believe you anyway?)  You proved by your observable behaviour that you talk big, do nothing, sales type not math type.
11:11:14 <monochrom> And evaded Axman6's perfectly legit question last night: how much money will you offer to pay for your employees.
11:11:18 <lambdaFan> i think what i reaally need is just to talk and get some advice from haskell gurus
11:11:27 <maerwald> For free?
11:11:32 <monochrom> I already gave you advice.
11:11:40 <lambdaFan> i can pay for consulation
11:11:48 <lambdaFan> thats very doable
11:12:35 <maerwald> There are a few credible consulting companies you can try. Start with https://www.fpcomplete.com
11:12:55 <monochrom> maerwald: I approve. >:)
11:12:58 <maerwald> xD
11:13:30 <oats> maerwald: do you work for fpcomplete?
11:13:35 <oats> er, *monochrom
11:13:41 <monochrom> No.
11:14:23 <monochrom> Hell, if someone feels that I work against fpcomplete, that may not be too far off >:)
11:14:39 <lambdaFan> u know them?
11:14:45 <lambdaFan> r they good?
11:14:51 <maerwald> lambdaFan: Very good
11:15:08 <maerwald> But they're expensive, most probably
11:15:08 <lambdaFan> ok thank u very much!
11:15:14 <maerwald> Shouldn't be a problem for you
11:15:38 <lambdaFan> worst case ill wait for second wave of investors
11:15:43 <maerwald> right
11:15:59 <lambdaFan> i dont understand y are you trolling me
11:16:13 <maerwald> nah, just gave you pointers
11:16:38 <lambdaFan> ok but im not that stupid
11:16:45 <juri_> we've considered fpcomplete. they look too expensive for us.
11:17:05 <lambdaFan> i understand u are all kinda laughing at my noobish expense
11:17:29 <monochrom> No, we don't laugh at beginners or amateurs.
11:17:49 <dsal> beginners and amateurs are the best
11:17:52 <lambdaFan> yes but you do laugh at what you define as "troll"
11:17:52 <monochrom> We laugh at talk big, do nothing, self-centered people like you.
11:18:05 <monochrom> You aren't even a beginner. You are nothing.
11:18:06 <dsal> People who know they don't know things have so much potential to learn,.
11:18:22 <monochrom> Show us your first Haskell exercise.
11:18:23 <lambdaFan> ok but why would you decide about me
11:18:32 <maerwald> juri_: Many consulting companies are. And in the end they just sell you what they already have, not what you need :)
11:18:33 <lambdaFan> ok ill find it
11:18:44 <lambdaFan> sec
11:18:49 <maerwald> But there surely are a few good ones as well
11:18:59 <lambdaFan> its somwhere in my 1000 open sublime tabs
11:19:04 <lambdaFan> im very messy
11:19:04 <MarcelineVQ> you are all full of beans today
11:20:00 <srk> is there something like functor but for data T a b = .. where you could specify a or b to transform?
11:20:40 <sm[m]> #haskell used to be the friendliest irc channel
11:20:59 <monochrom> srk: Perhaps bifunctor?
11:21:02 <sm[m]> Right ski ?
11:21:12 <srk> monochrom: oh .. 
11:21:36 <srk> monochrom: lol, I've discovered monofunctor yesterday, could have occured to me
11:22:03 <srk> thanks! :)
11:22:06 <monochrom> sm[m], I think ski meant if #haskell is one's very first exposure to IRC, it's plausible to extrapolate it to all IRC, not knowing that #haskell is at one extreme.
11:22:51 <lambdaFan> monochrom
11:22:53 <lambdaFan> https://pastebin.com/zRSZWgsy
11:22:58 <oats> I've found #haskell to be reasonably friendly if you ask questions in good faith, and if you're willing to put in work yourself
11:23:15 <lambdaFan> some first ex i did while watching a video lecture series
11:23:23 <maerwald> lambdaFan: You did well
11:23:38 <monochrom> In Chinese, primary school is "small school", secondary is "middle school" (OK it is also middle school for many of you), university is "great school".
11:23:50 <lambdaFan> like all noobs im still struggling with functors
11:24:02 <lambdaFan> pretty sure i understand the technicals
11:24:08 <maerwald> lambdaFan: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
11:24:14 <monochrom> When I first went to primary school, the building was very big too me, so I said "this is not small school, this is big school (university)"
11:24:26 <srk> oats: I've found it to be a great rubber duck repl - often I don't even need to post the question 
11:24:35 <lambdaFan> umm not functors monads
11:24:35 <monochrom> Time flied like an arrow.  I got to big school too.  Even a PhD later!
11:25:06 <monochrom> err s/big/great/  (In Chinese they're the same character)
11:25:18 <dsal> Then you realized that life is the only real school all along.
11:25:33 <lambdaFan> haha thanks maerwald
11:25:45 <lambdaFan> i think i understand the technicals thou
11:25:58 <dsal> If you understand, then what is the struggle?
11:26:02 <lambdaFan> i just need to catch up with my mathematical intuition you know?
11:26:12 <maerwald> lambdaFan: so what is your question?
11:26:31 <lambdaFan> umm i dont have a specific Q
11:26:45 <maerwald> Ok, then go write code
11:26:51 <lambdaFan> im just trying to get to know you
11:27:03 <lambdaFan> hehe i think im done with coding
11:27:13 <lambdaFan> after 7 years
11:27:22 <lambdaFan> i think i dont like it anymore
11:27:39 <lambdaFan> i can even look at sub-haskell langs anymore
11:27:41 <lambdaFan> cant
11:28:04 <lambdaFan> if i see c++ i get a strong urge to punch walls
11:28:16 <monochrom> You have mental illness.
11:28:25 <lambdaFan> its actually true
11:28:34 <lambdaFan> i have bipolar type !!
11:28:36 <lambdaFan> II
11:28:38 <lambdaFan> 2
11:28:47 <lambdaFan> like the bad kind of bipolar
11:28:50 <srk> bipolar functor!
11:28:57 <MarcelineVQ> East to West?
11:29:10 <maerwald> monochrom: most coders I met in real life have one or another. It's just how to deal with it. But IRC isn't a therapy room
11:29:35 <monochrom> There was an extremely creative bipolar person on efnet #math and #physics.
11:29:47 <lambdaFan> i really hope u stop hating on me :\
11:29:49 <oats> monochrom: hey now, don't you think that's a little unnecessary?
11:30:02 <monochrom> Eventually I decided that a perm ban was the right thing to do in his case.
11:30:18 <lambdaFan> so u kick me again?
11:30:24 <MarcelineVQ> oats: is there something wrong with having a mental illness? :>
11:30:28 <dsal> lambdaFan: You're providing negative value and claim no interest in coding.  You could dismiss yourself.
11:30:49 <monochrom> oats, wanting to punch walls upon merely C++ is unhealthy.
11:30:50 <lambdaFan> i do have interest in coding
11:31:11 <monochrom> violent tendency is.  they need to seek help along that line.
11:31:14 <lambdaFan> haskell = math basically no?
11:31:19 <EvilPyro> man I need some popcorn
11:31:21 <monochrom> not along talking big in #haskell
11:31:30 <lambdaFan> u know homotopy type theory
11:31:32 <lambdaFan> ?
11:31:34 <srk> EvilPyro: ++
11:31:45 <MarcelineVQ> EvilPyro: weekend's started early is all
11:32:11 <lambdaFan> monochrom i have all the mental help in the world
11:32:21 <lambdaFan> im really much better
11:32:56 <lambdaFan> i have great meds
11:32:57 <sm[m]> This is not the #haskell I know. Would anyone like to talk about Haskell ?
11:33:03 <lambdaFan> yes!
11:33:05 <lambdaFan> lets
11:33:12 <monochrom> Will I permban you?  It depends on you.  I said "in his case" for a reason.
11:33:23 <lambdaFan> im trying to develop mathematical intuition for monads
11:33:52 <maerwald> sm[m]: have you seen https://github.com/phadej/cabal-extras it has a gc command
11:33:56 <monochrom> In the latter days, he stopped taking his meds, he spammed the channels with his crackpot inventions too often.  Last straw.
11:34:05 <oats> lambdaFan: monads are for when you want to compose functions, but the return types of those functions aren't "simple"
11:34:24 <oats> like, the last function returned a "m a" for some Monad m, but the next function's input wants an a
11:34:27 <maerwald> monads are programmable semicolons
11:34:28 <lambdaFan> so in this video lecture they define an abstract parser
11:34:32 <sm[m]> sounds good!
11:34:42 * dsal could use a stack gc
11:34:44 <maerwald> they're also delicious
11:34:54 <lambdaFan> and say that mondas are just 
11:35:02 <lambdaFan> State -> (State,a)
11:35:11 <mniip> that is an example of a monad
11:35:12 <sm[m]> dsal indeed
11:35:17 <mniip> but not vice versa
11:35:21 <lambdaFan> ok
11:35:26 <lambdaFan> i think i understand
11:35:31 <frdg> https://pastebin.com/Wug4JQQB question about a strange type
11:35:58 <dsal> nix gc is a bit devastating on my mac, as it builds ghc 8.8.3 to build some of my projects.  Need to figure out how to have that not happen.
11:36:17 <monochrom> frdg, it is the constant functor.  It has an analogy with the constant function:  const x y = x
11:36:54 <monochrom> It is one of the great examples that a functor/monad "Foo t" does not have to "wrap/contain t".
11:37:06 <lambdaFan> can u suggest a channel where i can find haskellers seeking for a job?
11:37:20 <maerwald> lambdaFan: #haskell-blah maybe
11:37:21 <lambdaFan> there was the fp discord
11:37:32 <lambdaFan> but i think its down
11:37:39 <monochrom> For beginners, neither the constant functor nor the constant function look remotely useful at all.  They look pointless.  Yes.
11:37:49 <sm[m]> lambdaFan: the Haskell reddit. Search for past job ads to get ideas
11:38:04 <frdg> monochrom: ok thank you. 
11:38:11 <monochrom> But when you get to an intermediate level, they begin to be at least convenient in some cases.
11:38:14 * hackage dobutokO2 0.32.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.32.0.0 (OleksandrZhabenko)
11:38:32 <monochrom> And at an advanced level, they are important.  For example the constant functor is important for lens.
11:38:38 <dsal> Oh, so fmap transforms b?
11:38:46 <srk> dsal: are you using haskellPackages? 
11:38:53 <frdg> hmm ok, sounds pretty cool
11:39:01 <lambdaFan> ok thanks for all the help!
11:39:11 <srk> dsal: you can be more specific with pkgs.haskell.packages.ghc883 for example
11:39:22 <dsal> srk: I just started using nix-os over the weekend, and got nix working on my mac where it tries to rebuild ghc 8.8.3 on LTS
11:39:28 <lambdaFan> i thinnk ill go aand stop bothering you .. till i have some hask questions
11:39:28 <srk> dsal: default one (haskellPackages) points to ghc883 for me
11:39:29 <dsal> (it doesn't do that on nixos)
11:39:35 <lambdaFan> cya
11:39:39 <srk> ah, I see
11:39:57 <dsal> Related:  What is "Hask" ?
11:39:59 <srk> dsal: missing in cache?
11:40:24 <dsal> srk: Yeah, I guess.  I had forgotten what was even building by the time I noticed it happening.  Now I'm extra afraid of gc
11:40:28 --- mode: ChanServ set +o monochrom
11:40:47 --- mode: monochrom set -bo *!*@147.161.15.182 monochrom
11:41:40 <srk> dsal: know that feeling :)) I do accumulate like 100G of work before I have to gc and than I need to take a break for a day or two for everything not-rooted to build again
11:41:54 <monochrom> Hask is a category we like to think of/up, in which Haskell types are objects, Haskell functions are morphisms.
11:42:08 <dsal> ohh
11:42:12 <sm[m]> See you lambdaFan
11:42:31 <monochrom> No one has sit down and carefully defined Hask, so some of us say it's fictional and/or undefined.
11:42:43 <dsal> Yeah, that's a good enough explanation.  :)
11:44:34 <monochrom> FWIW, no one has sat down to carefully define some of the semantics things that Haskell 2010 mentioned but didn't define, so some of us say that Haskell doesn't have a semantic, either :)
11:46:10 <monochrom> "Although the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus with a straightforward denotational semantics."
11:46:13 <monochrom> That sentence.
11:47:06 <monochrom> (Section 1.2)
11:47:34 <dsal> I'm a fairly blue-collar haskeller, slowly increasing my knowledge, but not putting too much thought in theory most days.
11:47:53 <monochrom> That's fair.
11:48:16 <monochrom> The theorists strive to make theories agree with practice anyway.
11:48:53 <monochrom> Heed Knuth's excellent advice: The best theory is inspired by practice. The best practice is inspired by theory. Two legs.
11:49:03 <dsal> Which I greatly appreciate.  I often see myself bump the blub bar up as I go from "this feature is annoying" to "omg, how did I ever write code before?"
11:49:04 <Uniaika> wow that guy was exhausting
11:49:48 <maerwald> monochrom: Popper described the moment of creation of theory as an "irrational" moment and as such no one should try to follow how it came to be. They should just look at the theory :)
11:50:14 <MarcelineVQ> monochrom: https://tinyurl.com/yc9ml2sy
11:53:25 <monochrom> haha MarcelineVQ
11:54:21 <monochrom> maerwald yes, it's like we programmers' journey from messy prototype to coherent, well factored, well polished product
11:55:34 <MarcelineVQ> Like taking a ring to a mountain and all everyone wants to do is ask the eagles to do it
11:56:10 <maerwald> I think he made that argument, because there was a movement of science theorists that expected a "credible" inspiration for your theories and would dismiss more radical ideas, just because they were so radical
11:57:22 <maerwald> On the other hand, you could argue that's just resource allocation strategy
11:58:12 <monochrom> I take the resource scarcity and priortization stance.
11:58:53 <monochrom> Especially when it comes to why the proposer has the burden of proof.
11:59:21 <monochrom> You just look at all the recent crackpots showing up here and that's why.
11:59:24 <maerwald> Lol
11:59:36 <maerwald> Maybe Popper didn't account for crackpots :D
12:00:09 <monochrom> A lot of great thinkers have never considered the sheer weight of basic economics.
12:00:22 <monochrom> Anyway.
12:01:01 <MarcelineVQ> well, a brain is only 3lbs after all
12:01:10 <maerwald> is there a way to append stuff to --help output in optparse-applicative?
12:03:28 <EvilPyro> whats the sexyest way to obtain the index of the maximum value of a [Int] there may be something better than findIndex (==(maximum l)) l
12:03:31 <monochrom> In type ParserInfo, there is a field infoFooter.  Do you think it helps?
12:03:34 <tarskpean> hey guys! just starting out on learning haskell and couldn't grasp a concept. I am learning from the cis 194 lectures and I am currently here: https://www.seas.upenn.edu/~cis194/spring13/lectures/02-ADTs.html what I do not understand what are Shoe, Ship etc. standing for? are they blank values or what? I come from a C background and I can understand enums quite well but I cannot understand these data constructors and the 'deriving Show' thing. 
12:03:34 <tarskpean> thanks for help!
12:04:17 <monochrom> Correspondingly, the function "footer" which is want they intend you to use.
12:05:45 <monochrom> EvilPyro: zip [x,y,z] [0..] = [(x,0), (y,1), (z,2)].  Do you see what you can do next, and how it helps?
12:07:29 <maerwald> footer is exactly it
12:07:51 <monochrom> tarskpean: My http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Winter/02-haskell-types-1.html  scroll down to "User-defined types: Algebraic data types" has a good explanation IMO
12:08:19 <monochrom> ... No! Strike "IMO".  I wrote it, therefore of course it's the best!  Grrr....
12:08:30 <MarcelineVQ> maerwald: Most components in optparse are monoids as well, in case you can't find a special function
12:08:45 <maerwald> I find the documentation confusing (or rather: the module structure)
12:08:51 <maerwald> Can never find what I'm looking for.
12:09:16 <monochrom> Also, the CIS194 course assumes that you also have a very detailed textbook you're following concurrently.
12:09:37 <tarskpean> I was reading along side the suggested reads
12:09:40 <monochrom> Therefore the course notes are intentionally brief and fast and loose.
12:09:46 <monochrom> OK!
12:09:59 <monochrom> But doesn't hurt to switch to mine >:)
12:10:32 <tarskpean> and basically the 'deriving Type' means what type the data constructors are?
12:10:41 <monochrom> maerwald: I brute-force search :)
12:11:02 <maerwald> I think I'm too obsessed with structure and approach things tree-wise when searching
12:11:27 <monochrom> It's best to worry about "deriving ..." later.
12:11:33 <EvilPyro> monochrom, oh I could get the max of the result and the index its the second part of the tuple, but how do i get the max of the [(Int,Int)] list? does maximum compare against the first part of the tuple?
12:11:46 <monochrom> Yes.
12:11:59 <monochrom> When tie, compare the 2nd.
12:12:07 <monochrom> HOWEVER!
12:12:08 <lambdaFan> hey.. hope im not disturbing.. i posted a less megalomaniac job post on reddit
12:12:11 <lambdaFan> https://np.reddit.com/r/haskell/comments/g3887p/hiring_we_are_building_a_haskellrust_platform/
12:12:26 <monochrom> There is some version of "maximumBy" so you can tell it "compare 1st part only"
12:13:28 <maerwald> "abstract(discord, telegram , udemy , tinder , web-video-games , netflix)" -- what the???
12:13:43 <MarcelineVQ> "<maerwald> I think I'm too obsessed with structure and approach things tree-wise when searching" xml must be a hassle :X
12:14:00 <tarskpean> monochrom: but if I don't worry about 'deriving ...' how can I write code that I understand?
12:14:05 <MarcelineVQ> Oh I misread you actually, pardon
12:14:05 <lambdaFan> ok maerwald u r right
12:14:10 <maerwald> MarcelineVQ: I still have nightmares from my last job where I was dealing with large scale XML input data
12:15:31 <tarskpean> my guess is that 'deriving ...' is not mandatory?
12:16:31 <koz_> tarskpean: deriving is not mandatory for declaring a type, no.
12:16:33 <monochrom> If you worry, worry only enough within your reach, don't expect perfection yet.  This is why I do have a comment on the purpose.
12:16:45 <monochrom> And what koz_ said.
12:16:51 <maerwald> that reddit post is nuts, again
12:17:05 <monochrom> Although, without "Show", things are annoying when you experiment at the REPL.
12:17:25 <monochrom> In retrospect I should not have included Eq haha.
12:17:54 <tarskpean> I think I got it
12:17:58 <monochrom> Because my purpose is to force students to learn pattern matching, not "if x==North then ... else if x==East then ..."
12:18:23 <monochrom> Hey, I'm teaching it again this summer! I can fix it right now...
12:20:01 <tarskpean> so basically what I am about to write is right: data Int = -2,147,483,648 | 2,147,483,647 | ... | 2,147,483,646 | 2,147,483,647
12:20:07 <tarskpean> isn't it?
12:20:26 <tarskpean> it's just a value a variable of type Int can have
12:20:30 <monochrom> Conceptually OK, but unrealistic.
12:20:59 <maerwald> argh, the footer throws away newlines
12:21:10 <monochrom> yikes
12:21:14 <tarskpean> the important thing for me is to give examples
12:21:28 <tarskpean> that way I am sure I understood something
12:21:36 <monochrom> But you can also give realistic examples that the compiler actually accepts.
12:21:51 <monochrom> That way your example can actually be tested.
12:22:04 <koz_> Principle > example.
12:22:07 <koz_> Every damn time.
12:22:35 <tarskpean> the 'data Bool = True | False' part gave me the most insight
12:22:40 <monochrom> But koz_, in the processing of learning, examples -> principle.  Piaget's concrete before abstract.
12:22:58 <koz_> monochrom: Maybe I'm just strange, then.
12:23:00 <monochrom> However!  You don't have an example until the objective world agrees.
12:23:29 <monochrom> Oh don't worry, I also bash people who stopped at the example stage and never grew up to the principle stage.
12:23:46 <monochrom> Every time you see me say "cargo-culting", that's when!
12:23:56 <koz_> monochrom: Yeah, I was going to employ that term, then stopped short.
12:24:06 <koz_> Again, I've taught uni students before.
12:24:10 <koz_> (for... a long time)
12:24:13 <koz_> (across a range of levels)
12:24:20 <koz_> (I even got a class of postgrads to babysit once)
12:26:04 <MarcelineVQ> geeze, you guys have so much experience :>
12:26:20 <koz_> MarcelineVQ: Ehh, it's an ongoing process.
12:26:23 <monochrom> It's a zero-sum game.  I don't have experience on other things.
12:26:29 <koz_> And I'm out of the tertiary teaching game nowadays anyway.
12:26:30 * ski . o O ( `data Bool = False | True' )
12:26:51 <MarcelineVQ> Are you? You talk here don't you :>
12:26:55 <ski> yes, monochrom,sm[m]
12:26:55 <monochrom> You have read 10x more novels and 10x more movies than I have. There is a reason why.
12:29:37 <koz_> MarcelineVQ: I work remote for a small consultancy.
12:29:47 <koz_> Among other things, I can pick my own hours and don't have to commute.
12:29:56 <koz_> Leaves me much time for spending on #haskell. :P
12:33:17 <monochrom> I teach remotely and don't commute, either. >:)
12:34:39 <koz_> monochrom: Hence, you also talk here!
12:34:43 <koz_> See, it makes sense!
12:44:08 <lambdaFan> hi im back
12:45:13 <lambdaFan> people?
12:45:26 <lambdaFan> where is the love?
12:47:04 <monochrom> Please use the other channel.
12:48:37 <lambdaFan> can you explain 'do' syntax?
12:50:05 <lambdaFan> look man .. please dont ban me
12:50:09 <koz_> lambdaFan: https://en.wikibooks.org/wiki/Haskell/do_notation
12:50:19 <koz_> Pretty good explanation there.
12:50:21 <lambdaFan> ye i read that
12:50:37 <lambdaFan> but something still doesnt click
12:50:45 <koz_> lambdaFan: Then ask a more specific question.
12:50:53 <koz_> Low-effort questions usually attract low-effort answers.
12:51:09 <lambdaFan> its hard for me to talk in a chat env
12:51:17 <lambdaFan> i need to see faces
12:51:22 <lambdaFan> to understand people
12:51:25 <koz_> lambdaFan: I'm afraid that I can't help much with that.
12:51:38 <koz_> Also, there are no people here to understand - your understanding, or lack thereof, is of a written text.
12:51:38 <maerwald> lambdaFan: maybe you wanna do facetime with monochrom?
12:51:46 <koz_> There are zero 'people' involved.
12:51:58 <lambdaFan> i think hell kill me maerwald
12:52:29 <lambdaFan> but koz_ you are a person
12:52:33 <maerwald> Afair he teaches remotely, so should be fine
12:52:38 <lambdaFan> probably a very smart one
12:52:55 <koz_> lambdaFan: Not the point here.
12:53:00 <koz_> The logical flow here is as so:
12:53:04 <monochrom> koz_: Remember, "it's always personal" >:)
12:53:05 <koz_> 1) You read the thing I linked
12:53:13 <koz_> 2) You didn't understand said thing
12:53:23 <koz_> So far, the only person involved in logical comprehension here is you.
12:53:28 <MarcelineVQ> lambdaFan: http://www.vex.net/~trebla/haskell/IO.xhtml
12:53:32 <koz_> Since you comprehended me well enough to follow the link and read.
12:53:40 <koz_> So now, it's on _you_ to ask a specific question.
12:53:50 <koz_> There is _zero_ 'understanding of people' involved in this interaction.
12:53:54 <lambdaFan> ok you are logicaly correct
12:54:00 <lambdaFan> like always 
12:54:02 <maerwald> :D
12:54:04 <koz_> This is exactly why folks here are having trouble taking you seriously.
12:54:17 <lambdaFan> but logic isnt everything
12:54:31 <lambdaFan> math is also very emotional
12:54:31 <koz_> You keep going on these non-sequitur tangents, and we don't understand why you're doing this, what you're getting at, or how to assist you.
12:54:36 <koz_> lambdaFan: Moot.
12:54:45 <koz_> You are 100% exhibiting the exact behaviour I just described.
12:54:48 <koz_> Let's stay on topic.
12:54:53 <koz_> You don't get do notation.
12:54:57 <maerwald> math is emotional?
12:54:58 <koz_> The resource I linked isn't clear to you somehow.
12:55:01 <koz_> How is it not clear?
12:55:21 <lambdaFan> yes but wouldnt you categorize my behavior as that of a less intelectually evolved person?
12:55:25 <koz_> Please answer that question, that question _alone_, and refrain from any ad-lib regarding your personal philosophies on communication, or whatever the hell else.
12:55:39 <koz_> lambdaFan: I don't categorize your behaviour as anything other than confused, and perhaps in my case, frustrating.
12:55:44 <koz_> This is me trying to help you.
12:55:52 <koz_> How is it not clear?
12:55:54 <koz_> Please answer that question, that question _alone_, and refrain from any ad-lib regarding your personal philosophies on communication, or whatever the hell else.
12:56:04 <koz_> This is quite literally the last time I will attempt this.
12:56:24 <lambdaFan> but koz_ could you perhaps try to help me the way *I* want you to help me?
12:56:47 <maerwald> like, explaining it emotionally?
12:56:48 <monochrom> (Not really my business but I bet "no".)
12:56:48 <koz_> lambdaFan: You asked for an explanation of do notation. I responded. You said it still wasn't clear. I asked for clarification.
12:57:05 <koz_> You have so far given me zero clarification regarding what about do notation you don't get.
12:57:13 <monochrom> Egotistic askers won't get help.
12:57:17 <koz_> _My_ obligations are over until you do. I have no idea what's stumping you.
12:57:30 <lambdaFan> look, im very feminine.. and you are kinda always subliminaly insulting me for my alleged stupidity
12:57:39 <maerwald> xD
12:57:43 <koz_> lambdaFan: I am making zero assumptions about your intelligence.
12:57:55 <koz_> I'm trying to get you to clarify your question so that I can answer it.
12:58:04 <koz_> I'm not sure how much clearer I can be than that.
12:58:08 <monochrom> Anyone who want this to stop, just let me know.
12:58:14 <lambdaFan> ok but let me try to explain my problem
12:58:19 <koz_> OK, sure.
12:58:20 <lambdaFan> can i give example?
12:58:23 <koz_> Yeah.
12:58:39 <lambdaFan> you know the course "algebraic structures" ?
12:58:49 <koz_> No.
12:58:56 <lambdaFan> its like basic algebra
12:58:59 <koz_> How does this relate to do-notation?
12:59:00 <lambdaFan> groups
12:59:12 <lambdaFan> its an example for my problem
12:59:25 <lambdaFan> im very "explain by example" im sorry
12:59:58 <monochrom> MarcelineVQ gave a link.  It has examples.
12:59:58 <koz_> OK, sure, let's go with that. Continue.
13:00:14 <lambdaFan> ok did you do a math course on basic group theory?
13:00:21 <lambdaFan> and some ring theory?
13:00:26 <koz_> lambdaFan: I haven't.
13:00:38 <koz_> My knowledge of maths can be best described as 'ad-hoc'.
13:00:53 <koz_> I am still not sure what this has to do with do-notation.
13:00:55 <lambdaFan> ok so a group is just a very basic mathematical formulations
13:01:09 <lambdaFan> its like a graph with some more constraints
13:01:14 <mniip> a group is just a single object groupoid
13:01:30 <koz_> lambdaFan: I happen to know what a group is.
13:01:36 <koz_> I can probably give the axioms off the top of my head.
13:01:36 <lambdaFan> thing is - its very easy for me to visualise that
13:01:44 <koz_> And also give some key examples and theorems from the field.
13:01:52 <lambdaFan> so at the exam i bombed!
13:01:52 <koz_> Get. To. The. Do. Notation. Issue.
13:01:56 <lambdaFan> 96!
13:02:03 <lambdaFan> one seccondd
13:02:03 <monochrom> mniip: I'm pretty sure it's tangential.  At any rate, watch out for too-many-chefs
13:02:20 <lambdaFan> but then i got to rings
13:02:31 <lambdaFan> and rings arent as easy to visualize
13:02:38 <lambdaFan> so i just lost focus
13:02:49 <lambdaFan> the same is with do notations
13:03:08 <lambdaFan> from what i understans its just some sugar for something monadic
13:03:15 <lambdaFan> i dont care about the sugar
13:03:16 <koz_> lambdaFan: You understand correctly.
13:03:24 <koz_> The whole point _is_ the sugar.
13:03:33 <koz_> Anything we can write with do-notation, we can write without do-notation.
13:03:34 <lambdaFan> ok so i dont get that
13:03:37 <koz_> It just makes it a bit easier.
13:03:53 <lambdaFan> oh
13:03:56 <lambdaFan> ik
13:03:58 <lambdaFan> ok
13:03:59 <ski> you're welcome to not use `do', if you prefer that
13:04:25 <lambdaFan> but then can someone  explain like categoricaly what is happening here
13:04:37 <scheming_around> category theory really won't illuminate this ata ll
13:04:44 <lambdaFan> i want like a book that delves into haskell AND category theory
13:04:45 <koz_> lambdaFan: I don't understand what category theory has to do with syntactic sugar.
13:04:58 <koz_> lambdaFan: Bartoz Milewski (sp?) wrote one!
13:05:13 <ski> Bartosz, i think ?
13:05:20 <lambdaFan> so do is just sugar for "passing the state around" right?
13:05:39 <koz_> lambdaFan: No.
13:05:41 <ChaiTRex> lambdaFan: No, it's sugar for >>= and >> and such.
13:05:46 <lambdaFan> Bartoz Milewski (sp?) wrote one!  -- a book with integrated CAT theo?
13:05:48 <ski> @where CTfP
13:05:48 <lambdabot> "Category Theory for Programmers" by Bartosz Milewski in 2018-10-21 at <https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>,<https://github.com/hmemcpy/milewski-ctfp-
13:05:48 <lambdabot> pdf>
13:06:07 <scheming_around> If you have trouble learning about rings...you'll certainly have a lot of trouble with categories
13:06:08 <koz_> Thanks ski !
13:06:13 <lambdaFan> thanks ski
13:06:14 <ski> also see his YouTube lectures on category theory
13:06:18 <lambdaFan> hehe nice!
13:06:22 <koz_> But this is completely moot.
13:06:31 <koz_> Do notation, and syntactic sugar in general, has nothing to do with this.
13:06:40 <koz_> My basic answer to you is 'if you don't get do-notation, don't use it'.
13:06:44 <lambdaFan> ok thanks i think ill read some more about =>>=
13:06:45 <koz_> It is never required.
13:06:55 <koz_> Now, let me make an illustrative point for you.
13:07:00 <lambdaFan> and the book
13:07:07 <koz_> You spent something like 10 minutes getting to this point with utterly irrelevant ad-lib.
13:07:16 <koz_> How everyone _else_ would have done this:
13:07:18 <lambdaFan> im just lacking my mathematical intuition here and it drives me mad u understand?
13:07:32 <koz_> "Hi, I don't understand what do-notation is for. It seems to just be the same as monadic operations. What's the point?"
13:07:35 <koz_> Three sentences.
13:07:50 <koz_> Mathematical intuition is orthogonal here.
13:07:56 <lambdaFan> ok but im trying to develop a deeper conversation
13:08:06 <koz_> lambdaFan: Start by developing a conversation at all!
13:08:11 <dsal> lambdaFan: Your problem seems to have less to do with math and more to do with inter-human communication.
13:08:13 <scheming_around> what you did was really not the way of going about that lol
13:08:14 <koz_> Dumping random ad-lib is not conversation - it's performance art.
13:08:18 <lambdaFan> maybe you can somehow enrich my mathematical intuition .. idk..
13:08:29 <scheming_around> the best way to enrich mathematical intuition is to actually do mathematics
13:08:55 <koz_> If you want us to help you, we will, but you have to at least _try_ and meet us halfway.
13:08:58 <lambdaFan> koz_ what is ad lib ?
13:09:02 <dsal> I didn't understand monads until I stopped trying and just wrote code.
13:09:23 <koz_> https://en.wikipedia.org/wiki/Ad_libitum#Drama
13:09:30 <lambdaFan> thnks
13:09:35 <lambdaFan> ok sorry all
13:09:36 <monochrom> Conflating postmodern BSing for deeper.
13:09:47 <monochrom> err, s/for/with/
13:09:49 <koz_> Basically, if you ask a question, put in effort, respond to clarifying questions, and don't wander off-topic.
13:10:15 <koz_> Nobody is interested in whatever random thing is in your brain right now. Focus on the question, the whole question, and nothing but the question.
13:10:27 <lambdaFan> basically i dont have much questions
13:10:54 <lambdaFan> i mainly wanna talk about some haskell
13:11:01 <koz_> lambdaFan: And we can do that too.
13:11:07 <koz_> But you _still_ have to meet us halfway!
13:11:13 <koz_> That's what a conversation is.
13:11:15 <lambdaFan> im trying
13:11:19 <lambdaFan> promise
13:11:25 <koz_> It's not 'one person expounds and the rest listen in rapt wonderment'.
13:11:35 <koz_> It's 'one person says, another responds, another adds, etc.'.
13:11:36 <lambdaFan> im just familiar with you culturaly
13:11:43 <lambdaFan> not familiar*
13:11:55 <koz_> lambdaFan: I'd say that's pretty universal.
13:11:55 <monochrom> So lurk and learn?
13:12:06 <koz_> Also, actually write Haskell.
13:12:11 <koz_> It's amazing what you'll discover.
13:12:17 <lambdaFan> i do
13:12:28 <lambdaFan> at least try to
13:12:31 <koz_> I recall that _less than twelve hours ago_, you said you hate writing code.
13:12:44 <lambdaFan> c++ code
13:12:44 <koz_> Considering we're a community _primarily_ of Haskell coders... that's an odd choice of environment.
13:12:48 <maerwald> koz_: can you facetime with him?
13:12:56 <maerwald> maybe he'll stop writing here then :P
13:12:58 <monochrom> The standard netiquette is lurk for 6 months to learn the culture before ever speaking up at all.
13:13:01 <koz_> maerwald: No, because I don't have Facetime and I value my time at more than 'free'.
13:13:11 <koz_> monochrom: I didn't follow that here!
13:13:16 * dsal demands monadic freedom
13:13:18 <koz_> I think I jumped in here to ask Parsec questions.
13:13:18 * ski . o O ( "Dr. Pagefault or: How I Learned to Stop Worrying and Grok the Monad" -- film at eleven )
13:13:26 <monochrom> I can help you with a +q for that.
13:13:38 <maerwald> But he needs facetime
13:13:51 <koz_> maerwald: Then he can pay me my going rate, plus weekend extra.
13:13:55 <koz_> I doubt that's happening.
13:14:00 <MarcelineVQ> koz_: Did you have any questions left about parsec?
13:14:04 <maerwald> He said he got funding, so maybe
13:14:09 <koz_> MarcelineVQ: Nope! They were all answered.
13:14:10 <lambdaFan> actually i can koz_
13:14:19 <koz_> And I managed to build a parser for a bunch of Weka output.
13:14:23 <koz_> And did the thing I needed to do.
13:14:25 <solonarv> hm, I actually can't recall when or why I joined #haskell. But I sure did lurk a lot.
13:15:50 <EvilPyro> I dont understand whats happening here: https://pastebin.com/Trrmhmry It seems the condition in line 7 isn't evaluated as expected in line 8, Only the first condition seems to be
13:16:01 <lambdaFan> dont lurk solonarv
13:16:13 <MarcelineVQ> I joined because someone said on an imageboard that haskell was for geniuses and I already knew how irc worked
13:16:39 <MarcelineVQ> Turns out it's not for geniuses so it all worked out
13:16:46 <lambdaFan> i joined because i wanna meet u all
13:16:48 <nshepperd2> instead of lurking, try looming menacingly
13:17:02 <lambdaFan> yes! nshepperd
13:17:13 <lambdaFan> nshepperd2
13:17:28 <lambdaFan> can we all facetime?
13:17:47 <lambdaFan> haskell party?
13:17:56 * dsal would rather write code
13:18:05 <lambdaFan> :D
13:18:13 <maerwald> EvilPyro: I don't understand the question
13:18:20 <monochrom> EvilPyro: Is it possible that "used_board_cells (Grid w h l) column >= h" just happens to be true all the time?
13:18:25 <solonarv> EvilPyro: what maerwald said
13:18:27 <lambdaFan> so most of you are hardcore coders .. woow
13:18:36 <solonarv> so I am not sure what your question is
13:18:44 <dsal> /ignore lambdaFan 
13:18:53 <maerwald> also not sure what "caching" means there
13:18:59 <monochrom> OK I take that as a sign.
13:19:01 --- mode: ChanServ set +o monochrom
13:19:03 <solonarv> what do you mean by "isn't evaluated"? normally you cannot tell at all whether an expression gets evaluated.
13:19:23 --- mode: monochrom set +q *!*@147.161.*
13:19:27 --- mode: monochrom set -o monochrom
13:19:31 <maerwald> he really needs facetime though
13:19:39 <dsal> Is facetime like, zoom for old people?
13:19:52 <solonarv> facetime is just apple's proprietary videotelephony thing
13:20:02 <EvilPyro> maerwald, monochrom solonarv the consequent if to line 7 evaluates false instead of true when clearly (column < 0) or (column >= w) are true
13:20:22 <maerwald> EvilPyro: did you print out all the things?
13:20:29 <EvilPyro> maerwald, I meant catch xD
13:20:34 <maerwald> check what the values are
13:20:44 <solonarv> yes, printing all the values is a great first step
13:20:48 <solonarv> I do it all the time!
13:21:14 <maerwald> put them in their own let bindings, then print them out
13:21:27 <dsal> That code seems rather complex.  If I have doubts for things like that, unit tests always end up saving lots of time.
13:21:29 <maerwald> so you have 4 prints
13:21:56 <EvilPyro> okay let me print things to ensure
13:22:21 <solonarv> good old printf debugging :)
13:22:43 <dsal> I've heard stories of better debuggers, but I've rarely seen one.
13:23:37 <monochrom> I read in "Learn C The Hard Way" a reason for preferring printing to gdb in most cases, and I am very convinced.
13:23:46 <EvilPyro> putStrLn show binding  (binding is Bool) should work right?
13:23:53 <dsal> monochrom: what was that?
13:24:04 <dsal> EvilPyro: bools aren't strings
13:24:04 <maerwald> EvilPyro: sure
13:24:13 <maerwald> show on bools are
13:24:15 <maerwald> :)
13:24:17 <monochrom> The reason is if gdb, after you quit gdb and run it the next time, you have to enter all your watches and breakpoints all over again.
13:24:20 * ski laments Buddha
13:24:24 <dsal> Oh, you meant `putStrLn show binding` --   You could also just `print binding`
13:24:25 <maerwald> but you're missing a $
13:24:43 <monochrom> print statements stay much longer, and you can even do some #ifdef to turn them on and off at a whim.
13:24:48 <ChaiTRex> EvilPyro: A shortcut to putStrLn and show is print. print will do the show for you.
13:24:55 <oats> I tried to do LCTHW a long time ago, I don't remember it being very helpful
13:24:59 <dsal> maerwald: I think your English parser matched the intention better than mine did.
13:25:16 <monochrom> Of course gdb has its use, but because of that reason it's minor not major now.
13:25:16 <oats> Still didn't really grok C for a while until a college coursr
13:25:18 <ski> EvilPyro : `putStrLn (show binding)'. or with `print', yes
13:25:34 <maerwald> oats: debug driven development. What's there to grok?
13:25:44 <maerwald> You grok nothing and hope something will work eventually
13:25:44 * hackage WEditor 0.2.0.0 - Generic text-editor logic for use with fixed-width fonts.  https://hackage.haskell.org/package/WEditor-0.2.0.0 (ta0kira)
13:25:45 <monochrom> Also your print statements act as one way to express your scientific hypothesis of what you think is the issue.
13:26:12 <ski> monochrom : perhaps gdb should be able to emit a patch, that one could apply to the source ?
13:26:54 <dsal> I enjoyed life with dtrace in which you could add and remove those prints in your running binary.
13:27:23 <monochrom> The author's most important use of gdb is in case of core dumps and in case the program is already running, you don't want to restart it, so connect gdb to it live.
13:27:28 <maerwald> monochrom: https://sourceware.org/gdb/onlinedocs/gdb/Save-Breakpoints.html
13:27:54 <maerwald> there's also nemiver, graphical UI for gdb, maybe it has more features
13:28:13 <maerwald> But I'm not sure how well that works when yout code changes
13:28:16 <maerwald> probably not.
13:29:30 <maerwald> I recall bagder programs basically with gdb, lol. One word change, check in gdb, ...
13:29:35 <EvilPyro> Ohhh i discovered the issue, I use column as part of used_board_cells argument so the thing crashing was that function not what the if was protecting xDD I got confused due to lazy eval
13:30:02 <maerwald> He sometimes streams on twitch
13:30:44 * hackage penntreebank-megaparsec 0.1.0 - Parser combinators for trees in the Penn Treebank format  https://hackage.haskell.org/package/penntreebank-megaparsec-0.1.0 (twotrees12)
13:30:51 <davve> a/10
13:36:44 <amf> if i have a GADT and would like to keep that, but have a list of those types, what is the best way to do so?
13:37:30 <monochrom> I don't understand.  Do you have one type?  Do you have many types?
13:37:45 * hackage WEditorBrick 0.2.0.0 - Text-editor widget with dynamic line-wrapping for use with Brick.  https://hackage.haskell.org/package/WEditorBrick-0.2.0.0 (ta0kira)
13:38:00 <solonarv> yes, can you tell use what the GADT's definition looks like and what kind of list you would like to have?
13:39:07 <amf> `data X a where X1 :: Y a -> X (Y a), X2 :: Z -> X Z`, and would like `xs :: [X]`
13:39:49 <amf> im trying to encode a complicated cli program's subcommands at the type level, imagine something like git
13:40:00 <solonarv> well, [X] is a kind error. I assume you would like to define something like: xs = [X1 something, X2 somethingElse] -- and have that typecheck?
13:40:03 <EvilPyro> How can i rewrite https://pastebin.com/q19KcYC3 to be less horrible? The problem i have is with the input, I need to read a line before doing guards etc
13:40:52 <maerwald> EvilPyro: get rid of all if-then-else
13:40:52 <solonarv> EvilPyro: it looks to me like the outermost 'if' is missing its 'else' part?
13:41:19 <amf> solonarv: yeah was kind of thinking that, but wanted to see if ghc could infer the type, but it can't
13:41:44 <solonarv> amf: thinking it through, obviously the type would have to be [X ???]
13:41:54 <ski> amf : if you want what solonarv was suggesting, then you want `[exists a. X a]', presumably ?
13:42:02 <EvilPyro> maerwald, The problem is i dont know how because i still need the do part for the input
13:42:14 <solonarv> but there is nothing that we can substitute for ???, because that would have to be equal to Z and also equal to (Y a) for some a
13:42:21 <EvilPyro> solonarv, yep, I'm not putting it since I'm rewritting it
13:42:24 <solonarv> but Z and (Y a) aren't equal, so that' simpossible
13:42:25 <maerwald> guards, functions, multiway-if, viewpatterns, ...
13:42:31 <amf> i may just remove the `a` bit and operate contcrete types, but it is nice to see `rule1 :: TCRule (Filter [FlowerOpt])` instead of `rule :: TCRule`
13:43:15 <monochrom> EvilPyro: There is "else return ()" as a last resort.
13:43:33 <solonarv> one thing you can do is change your approach so you do not actually need to have this list at all
13:44:05 <amf> well i need to apply the rules in order so a list seemed natural (and I didn't want to reach for HList which i still don't quite get)
13:44:29 <koz_> 30
13:44:36 <koz_> Whoops, wrong window.
13:46:45 <Uniaika> irssi user detected!!!
13:46:52 <Uniaika> (or not)
13:48:02 <dsal> EvilPyro: One thing you might consider is not having it return ().  You've got a thing requesting input, a thing applying it, and a thing deciding whether there's a win or not.  They don't need to all be the same thing.
13:50:14 <solonarv> Uniaika: I use irssi and I don't know what would cause me to randomly type '30' ..?
13:50:34 <dsal> e.g., your first win goes away with `column <- getValidColumn grid`
13:50:36 <solonarv> EvilPyro: dsal's suggestion is very good. your function can be split up into smaller ones.
13:50:40 <dsal> er, first `if`
13:51:09 <maerwald> solonarv: over the years I used to ask ppl what client they use on IRC whenever there was an odd mistype. I'd say 80% of them were irssi users :)
13:51:36 <maerwald> That suggests it's a UI issue
13:52:07 <solonarv> as an irssi user, I have absolutely no idea what you could possibly be talking about ;)
13:52:45 <EvilPyro> dsal, thankyou
13:52:51 <EvilPyro> I'll do that
13:53:47 <dsal> EvilPyro: The things my brain are thinking and my fingers are typing don't exactly match, but `getValidColumn :: Grid -> IO Int` will probably set you along the right direction.
13:53:51 <Uniaika> maerwald's right
13:53:51 <johnw> OK people, I've just had a legitimate need for partsOf from lens. I don't even know what to make of this.
13:54:05 <johnw> it boils down to needing to do something like this:
13:54:08 <johnw> > [('a',1),('b',2),('c',3)] & partsOf (each._2).mapped %~ (+1)
13:54:11 <lambdabot>  [('a',2),('b',3),('c',4)]
13:54:41 <johnw> or really, more like
13:54:45 <johnw> > [('a',1),('b',2),('c',3)] & partsOf (each._2) %~ map (+1)
13:54:47 <lambdabot>  [('a',2),('b',3),('c',4)]
13:54:54 <dsal> > (fmap succ) <$> [('a',1),('b',2),('c',3)] 
13:54:55 <johnw> since I need to deal with the "inner list" as a list on its own first
13:54:56 <lambdabot>  [('a',2),('b',3),('c',4)]
13:55:10 <dsal> I guess I didn't need those parens.
13:55:12 <johnw> it's not an element-wise operation, but a list-wise operation on the aggregate of the snd's
13:55:23 <johnw> but where the result get "puts back"
13:55:48 <solonarv> > :t partsOf
13:55:50 <lambdabot>  <hint>:1:1: error: parse error on input :
13:55:50 <dsal> My lens skills are still at the "I could use this slightly weirder way to solve this problem" stage.
13:55:53 <solonarv> oops
13:55:57 <solonarv> :t partsOf
13:55:58 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
13:56:19 <solonarv> ah right, that thing
13:56:24 <johnw> partsOf lets you turn a "path" within a structure into a list that you can manipulate, with the result laying back over the original path
13:56:35 <johnw> I think it's an unlawful traversal, though, if the result is of a different size
13:56:43 <solonarv> you think correctly
13:56:54 <shachaf> Hmm?
13:57:06 <shachaf> > over (each . _2) (+1) [('a',1),('b',2),('c',3)]
13:57:08 <lambdabot>  [('a',2),('b',3),('c',4)]
13:57:21 <solonarv> yes, perhaps your example was not chosen well
13:57:24 <shachaf> There's no need for partsOf and map. You can just map over the traversal.
13:57:28 <johnw> yeah, I've misled
13:57:40 <solonarv> a better example would be:
13:57:46 <johnw> it's not about the elements, schachaf, but being able to use the parts as a list
13:58:12 <johnw> actually, unzip would solve my problem here too
13:58:13 <solonarv> > [('a', 2), ('b', 3), ('c', 1)] & partsOf (each._2) %~ sort
13:58:15 <lambdabot>  [('a',1),('b',2),('c',3)]
13:58:18 <johnw> right
13:58:27 <johnw> zip . second sort . unzip
13:58:31 <dsal> heh, I was just thinking about that, but with reverse.
13:58:37 <shachaf> Yes, I know what partsOf does.
13:59:09 <shachaf> It's just that example doesn't need it.
13:59:27 <johnw> the sort example is more accurate
14:00:22 <maerwald> https://hackage.haskell.org/package/hOpenPGP huh
14:00:29 <maerwald> a native implementation?
14:01:10 <dsal> I read that as hopin' PGP.  Like, "hopin' this is right"
14:01:48 <maerwald> lol
14:01:58 <maerwald> That sums up crypto in haskell :P
14:02:18 <maerwald> still interesting though
14:02:23 <nshepperd2> you're gonna need a bunch of hope to believe that it's not riddled with side channel attacks
14:02:29 <maerwald> Yeah
14:07:41 <johnw> shachaf: I've been using lens quite heavily this week, and it's been amazing as always
14:09:12 <maerwald> johnw: lens or optics?
14:10:00 <johnw> the `lens` library
14:10:09 <maerwald> > view (_Just . to (++ "abc")) Nothing
14:10:11 <lambdabot>  ""
14:10:21 <maerwald> Is one of my favorite confusions
14:10:45 <maerwald> Can be much harder to catch if the lens is more complex
14:11:18 <maerwald> view + prisms = urgs
14:11:38 <maerwald> in optics, this doesn't compile :)
14:12:26 <heatsink> Is there a Map function to look up the closest key to a given value?
14:13:01 <heatsink> find the maximum key k in the map such that k <= x
14:13:13 <monochrom> yes, I forgot its name
14:13:31 <monochrom> perhaps successor, predecessor
14:14:13 <monochrom> lookupGT and LT and LE and GE
14:14:27 <heatsink> that's it, thanks 
14:15:44 * hackage stratosphere 0.52.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.52.0 (jdreaver)
14:23:24 <tabaqui1> hey all
14:24:02 <tabaqui1> let's imagine that one has two types Key (a :: Bool), Value (a :: Bool) and want to store them in Data.Map
14:24:43 <tabaqui1> but with condition that Key 'True points on Value 'True and vice versa
14:25:18 <tabaqui1> well, without this such constraint, one could just use "SomeKey :: Key a -> SomeKey" and SomeValue
14:25:44 <tabaqui1> but how should he do this with the constraint
14:25:51 <tabaqui1> ?
14:26:08 <lyxia> Use typerep-map or something similar
14:26:10 <nshepperd2> sounds like you want https://hackage.haskell.org/package/dependent-map
14:27:08 <solonarv> yes, this sounds exactly like dependent-map
14:27:13 <tabaqui1> allright, actually I would like to augment HashPSQ from psqueus
14:27:27 <nshepperd2> although in this case (Map (Key False) (Value False), Map (Key True) (Value True)) would be a low tech option
14:28:08 <tabaqui1> it's some "Priority (a :: Kind1) (b :: Kind2) (c :: Kind3)", to be more precise :)
14:28:31 <tabaqui1> 3 kinds, each contains about 4 points
14:31:35 <tabaqui1> ah, I see, DMap is just like a regular Data.Map, but it's API was rewritten to compare types additionally with :~: 
14:31:47 <tabaqui1> allright, I can do the same with HashPSQ
14:31:49 <tabaqui1> thanks
14:31:58 <pie_[bnc]> oh cool! i just had to google hackage reverse dependenvies
14:32:01 <pie_[bnc]> https://packdeps.haskellers.com/reverse
14:32:37 <tabaqui1> pie_[bnc]: https://www.stackage.org/package/process/revdeps
14:35:39 <Guest_8> hi guys
14:36:13 <Guest_8> [ Error ] Build failed with NonZeroExit 77 "./configure" ["--prefix=/Users/apple/.ghcup/ghc/8.8.3"]Check the logs at ~/.ghcup/logs and the build directory "/var/folders/30/64x4kl_93w1dtqq2wwkcnm5h0000gn/T/ghcup-h7dkA3/ghc-8.8.3" for more clues."ghcup --cache install" failed!
14:36:35 <maerwald> Guest_8: did you check the logs?
14:37:15 <Guest_8> could you pls tell me how to check it?
14:37:32 <maerwald> ~/.ghcup/logs
14:38:26 <Guest_8> thank you, i try it now.
14:39:02 <Guest_8> -bash: /Users/apple/.ghcup/logs: is a directory
14:39:11 <maerwald> Correct
14:39:14 <maerwald> The logs are inside
14:39:46 <Guest_8> cool, so what should i do for next?
14:39:54 <maerwald> open them
14:40:41 <Guest_8> how to open them?
14:41:13 <maerwald> with an editor of your choice
14:46:56 <Guest_8> -bash: ghci: command not found
14:47:08 <maerwald> Guest_8: is that what the log says?
14:47:39 <Guest_8> i don't know how to open them with an editor... sorry
14:47:50 <maerwald> You have no editor?
14:48:05 <maerwald> How do you code?
14:48:14 <tabaqui1> cat ~/.ghcup/logs/*
14:48:37 <tabaqui1> oh, wait
14:48:51 <tabaqui1> please, do not paste the content here, use any pastebin-like service
14:48:54 <maerwald> https://dpaste.org/
14:49:24 <Guest_8> i use sublime text as editor
14:51:11 <maerwald> cat ~/.ghcup/logs/* | curl -F 'sprunge=<-' http://sprunge.us
14:52:02 <maerwald> Can you do that?
14:52:19 <Guest_8> ok, in terminal?
14:52:22 <maerwald> Yes
14:53:12 <Guest_8> cat ~/.ghcup/logs/*checking build system type... x86_64-apple-darwin19.4.0checking build system type... x86_64-apple-darwin19.4.0checking host system type... x86_64-apple-darwin19.4.0checking build system type... x86_64-apple-darwin19.4.0checking host system type... x86_64-apple-darwin19.4.0checking target system type...
14:53:13 <Guest_8> x86_64-apple-darwin19.4.0checking build system type... x86_64-apple-darwin19.4.0checking host system type... x86_64-apple-darwin19.4.0checking target system type... x86_64-apple-darwin19.4.0Build platform inferred as: x86_64-apple-darwinchecking build system type... x86_64-apple-darwin19.4.0checking host system type...
14:53:13 <Guest_8> x86_64-apple-darwin19.4.0checking target system type... x86_64-apple-darwin19.4.0Build platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinchecking build system type... x86_64-apple-darwin19.4.0checking host system type... x86_64-apple-darwin19.4.0checking target system type... x86_64-apple-darwin19.4.0Build
14:53:14 <Guest_8> platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinTarget platform inferred as: x86_64-apple-darwinchecking host system type... x86_64-apple-darwin19.4.0checking target system type... x86_64-apple-darwin19.4.0Build platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinTarget
14:53:14 <Guest_8> platform inferred as: x86_64-apple-darwinGHC build  : x86_64-apple-darwinchecking target system type... x86_64-apple-darwin19.4.0Build platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinTarget platform inferred as: x86_64-apple-darwinGHC build  : x86_64-apple-darwinGHC host   : x86_64-apple-darwinBuild platform
14:53:15 <maerwald> Noooooooo
14:53:21 <maerwald> Omg
14:53:42 <peutri> ouch
14:53:52 <maerwald> How hard can that be
14:54:03 <monochrom> Why do computer-illiterate people even bother
14:54:11 <alx741> wow
14:54:30 <monochrom> "what do I do with a directory?"
14:54:35 <peutri> literate enough to paste
14:54:57 <maerwald> monochrom: You know... sorry to say this, but they are *always* mac users.
15:05:04 <tabaqui1> https://gist.github.com/boris-stepanov/d81b4be2f06901a39edd9fab0f19e42c
15:05:21 <tabaqui1> what do you thinks, is it possible to impelement withAny?
15:05:52 <tabaqui1> not sure, if I write signature of the function correctly
15:06:06 <tabaqui1> *think
15:09:00 <dmj`> tabaqui1: does it give a type error
15:11:02 <monochrom> It should, because "(constraints => a -> b)" will need fixing
15:11:05 <tabaqui1> No idea. I remember some code that behave like "f :: a -> String; f x = if showable x then show x else "Not a Show instance""
15:11:50 <tabaqui1> my question was, is it possible to implement (fix) withAny function, so it behave like in examples below
15:12:16 <oats> yikes, don't see kill used very often
15:12:21 <oats> does it actually quit the client?
15:12:51 <monochrom> Depends on client. Good client, no.
15:13:40 <tabaqui1> I guess, macos burns a laptop and ships new in the store
15:13:45 <monochrom> Bad clients quit or make the window/tab disappear.
15:13:58 <monochrom> haha
15:14:23 <monochrom> /kick monochrom get a new laptop
15:15:36 <dsal> I always assumed kill killed the end user.  It should be used sparingly.
15:15:44 * hackage WEditor 0.2.0.1 - Generic text-editor logic for use with fixed-width fonts.  https://hackage.haskell.org/package/WEditor-0.2.0.1 (ta0kira)
15:15:45 <tabaqui1> "success, your credit is approved"
15:16:28 <monochrom> dsal: It's why we let the machine auto-determine when to do it to whom
15:16:48 <dsal> Yes, no weird inconsistent human morality.
15:16:55 <dsal> I think this was a recent smbc.
15:17:05 <monochrom> Yes!
15:17:29 <monochrom> Also no weird repeat "yes"
15:20:07 <oats> I love smbc
15:24:05 <rednaZ> tabaqui1: It cannot be done because of type erasure.
15:24:45 * hackage hurl 1.4.0.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.4.0.0 (alcinnz)
15:25:43 <tabaqui1> rednaZ: not sure, what you mean. I can use TypeReflection to match with some specific input type (a -> b)
15:25:51 <tabaqui1> but without constraint (p =>)
15:25:55 <solonarv> tabaqui1: can't be done in full generality.
15:26:24 <solonarv> you can do this *without* the 'constraints =>' bit if you sling around a few 'Typeable ???' constraints
15:27:23 <tabaqui1> sane additional constraints are ok
15:27:25 <rednaZ> tabaqui1: What is TypeReflection? Typeable?
15:27:41 <tabaqui1> @where eqT
15:27:41 <lambdabot> I know nothing about eqt.
15:27:48 <tabaqui1> % :t eqT
15:27:48 <yahb> tabaqui1: forall {k} {a :: k} {b :: k}. (Typeable a, Typeable b) => Maybe (a :~: b)
15:28:17 <tabaqui1> % (eqT 'c' 'a', eqT 1 'a')
15:28:17 <yahb> tabaqui1: ; <interactive>:70:2: error:; * Couldn't match expected type `Char -> Char -> a' with actual type `Maybe (a0 :~: b0)'; * The function `eqT' is applied to two arguments,; but its type `Maybe (a0 :~: b0)' has none; In the expression: eqT 'c' 'a'; In the expression: (eqT 'c' 'a', eqT 1 'a'); * Relevant bindings include it :: (a, b) (bound at <interactive>:70:1); <interactive>:7
15:28:36 <tabaqui1> % (eqT @Char @Char, eqT @Int @Char)
15:28:36 <yahb> tabaqui1: (Just Refl,Nothing)
15:28:40 <rednaZ> tabaqui1: If you add a Typeable instance, you are adding runtime type information.
15:28:53 <tabaqui1> fine
15:29:13 <tabaqui1> "Wrap :: Sing a -> a -> Wrap" ?
15:29:37 <tabaqui1> *"Sing k -> (a :: k) -> Wrap"
15:30:14 <dmwit> I find the `constraints` bit puzzling. What could `withAny` possibly do to supply those constraints?
15:30:37 <dmwit> Almost certainly you just want to drop that and leave it to the caller to ensure that whatever constraints are needed to build the `a -> b` they care about exist.
15:30:52 <tabaqui1> % :i deferEither
15:30:53 <yahb> tabaqui1: ; <interactive>:1:1: error: Not in scope: `deferEither'
15:31:14 <tabaqui1> % import Data.Constraint.Deferrable
15:31:14 <yahb> tabaqui1: 
15:31:16 <tabaqui1> % :i deferEither
15:31:16 <yahb> tabaqui1: class Deferrable (p :: Constraint) where; deferEither :: forall (proxy :: Constraint -> *) r. proxy p -> (p => r) -> Either String r; -- Defined in `Data.Constraint.Deferrable'
15:31:34 <amf> what is one of the better libraries for pretty printing? haven't ever used ansi-wl-pprint, but i know it's got some backing, wondering if there are more contenders
15:31:36 <dmwit> In which case, `withDynamic :: (Typeable a, Typeable b) => (a -> b) -> Dynamic -> Dynamic` is easy to implement.
15:31:52 <trey> ' runLengthDecode :: [(a, Int)] -> [a]
15:31:59 <trey> guess that markup didn't work, ugh
15:32:10 <trey> but anyone know why I'm getting a type match error?
15:32:34 <tabaqui1> trey: what's the problem?
15:32:37 <monochrom> That line will not cause an error on its own.
15:32:40 <tabaqui1> % :t (\a -> fmap fst a)
15:32:41 <yahb> tabaqui1: forall {f :: * -> *} {b1} {b2}. Functor f => f (b1, b2) -> f b1
15:32:50 <monochrom> You will need to show actual code.
15:32:59 <monochrom> and more complete
15:33:00 <trey> where's the nest place to post it?
15:33:01 <tabaqui1> % :t (map . fst)
15:33:01 <lyxia> amf: prettyprinter
15:33:01 <yahb> tabaqui1: forall {a} {b1} {b2}. (a -> b1, b2) -> [a] -> [b1]
15:33:11 <tabaqui1> % :t (map fst)
15:33:11 <yahb> tabaqui1: forall {b1} {b2}. [(b1, b2)] -> [b1]
15:33:23 <tabaqui1> trey: gist.github.com if you have an account
15:33:34 <dmwit> tabaqui1: withDynamic f (Dynamic repA a) = case testEquality (typeRep @a) of Just Refl -> Dynamic (typeRep @b) (f a); _ -> Dynamic repA a
15:34:00 <lyxia> amf: Relevant quote from the README: "Haskell, more specifically Hackage, has a zoo of Wadler/Leijen based prettyprinters already. Each of them addresses a different concern with the classic wl-pprint package. This package solves all these issues, and then some."
15:34:13 <amf> lyxia: perfect! exactly what i want!
15:34:25 <tabaqui1> dmwit: but we cannot run it with some "foo :: Num a => a -> a"
15:34:26 <trey> I don't have an account there.
15:34:32 <dmwit> tabaqui1: Why not?
15:34:50 <dmwit> tabaqui1: I mean, yes, you can, provided you have a `Num a` instance for the `a` you care about.
15:34:54 <tabaqui1> unambigious types
15:34:59 <monochrom> perhaps dpaste
15:35:10 <dmwit> tabaqui1: Yes, you must choose which `a` you claim the `Dynamic` is holding.
15:35:16 <trey>  Couldn't match expected type `(a0, Int)'
15:35:17 <dmwit> tabaqui1: I don't see how you could hope to avoid that.
15:36:10 <tabaqui1> dmwit: well, with RankNTypes we can make "withDynamicNum :: (forall a. Num a => a -> a) -> Dynamic -> Dynamic"
15:36:23 <dmwit> No, you can't.
15:36:35 <tabaqui1> can't?
15:36:37 <dmwit> nope
15:37:12 <monochrom> What would withDynamicNum do?
15:37:13 <dmwit> (Are we both talking about `Data.Dynamic.Dynamic` from `base` here?)
15:37:43 <tabaqui1> monochrom: fire the first argument if Dynamic contains numeric data, or do nothing otherwise
15:38:01 <dmwit> But how is `withDynamic` supposed to magic up a `Num` dictionary out of thin air?
15:38:08 * tabaqui1 is searching for that paper
15:38:24 <monochrom> OK. But you can only downcast Dynamic to Int, or Dynamic to Double, or...  You have to choose types explicitly.
15:39:34 <monochrom> Also, all downcasts can fail because it is not the type you think. the cast functions give you "Nothing" for this. What do you do then?
15:39:47 <dmwit> Compare: `data Exists c where Exists :: c a => a -> Exists c`. Then you could e.g. `withExists :: (forall a. Num a => a -> a) -> Exists Num -> Exists Num`.
15:40:00 <dmwit> But then you are not magicking up a dictionary, you are explicitly storing it in the data structure.
15:40:22 <dmwit> N.B. Dynamic is essentially `Exists Typeable`.
15:40:52 <dmwit> So you get to "magic up" a `Typeable` instance. But nothing else.
15:42:02 <monochrom> Yeah it's probably best to define your own existential type. And it contains all information you need.
15:42:03 <tabaqui1> ah, I found it
15:42:04 <tabaqui1> https://stackoverflow.com/a/44399367
15:42:06 <dmwit> In fact you can `withExists :: (forall a. c a -> b) -> Exists c -> b`.
15:42:07 <tabaqui1> well, sort of
15:42:30 <tabaqui1> but yes, this approach still requires passing witnesses
15:42:38 <dmwit> ugh, `withxists :: (forall a. c a => a -> b) -> Exists c -> b`.
15:43:11 <trey> https://gist.github.com/treysampson/38435b36f7708241f473f06a40a08077
15:43:18 <trey> created an account, so you could look at the error
15:43:27 <trey> i appreciate the help :)
15:43:51 <dmwit> trey: replicate produces a list. So you have one list per element of `xs`.
15:43:59 <dmwit> trey: That's a list of lists. You claim to produce a flat list.
15:44:12 <dmwit> trey: This is what the error says, though in some jargon rather than English.
15:44:31 <tabaqui1> [a | a <- xs] producing " do { a <- xs; return a }
15:44:39 <monochrom> "Proof" is the existential type there. It is just being strange in holding no data, just class.
15:44:41 <tabaqui1> you need just " do { a <- xs; a }"
15:44:45 <tabaqui1> trey: ^
15:45:30 <tabaqui1> be carefull with syntactic sugar
15:45:30 <monochrom> Getting Typeable involved may be too general.
15:45:33 <dmwit> trey: `concat` out front to flatten the list, or an extra bind inside the comprehension, would work fine. tabaqui1's suggestion using do notation would work, too.
15:46:49 <trey> okay I'm going to process your suggestions lol. I wish I could just read them and understand them at face value, but I'll need a sec
15:46:52 <monochrom> In this case, you could have commented out your type signature, let the computer infer one (will be different). Then you would make two observations:
15:47:02 <monochrom> 1. what's the different, correct type?
15:47:20 <dmwit> tabaqui1: Given that excellent answer, all of which agrees with what we are telling you ("no, can't be done"), I'm not sure where we're left. What question is left in your mind?
15:47:30 <monochrom> 2. now that you can test your function, test it. You could have discovered you missed a concatenation stage.
15:48:02 <monochrom> Damn right, the problem with being told the answer is that you won't understand it until you have experienced it yourself.
15:48:35 <dmwit> I, too, support "I'll need a sec". Please take many seconds, we are patient.
15:48:56 <trey> monochrom: I always forget I can use the type signature as a tool like that for determining where I've gone wrong
15:49:02 <trey> thanks for that advice
15:50:02 <tabaqui1> dmwit: if the problem can't be solved, it should be reformulated. To do this I need to know exact reasons why something is impossible
15:50:06 <tabaqui1> pretty obvious to me
15:51:02 <tabaqui1> right now, I'm marking the boundaries
15:51:30 <tabaqui1> dmwit, monochrom: btw, thanks for the helping :)
15:51:41 <dmwit> Sure. So: do you understand how the dictionary-passing translation of typeclasses works?
15:52:06 <tabaqui1> not quiet. I need to read the full topic again
15:52:30 <dmwit> I think that would be an excellent place to start.
16:08:21 <monochrom> I think it was a mistake for standard Haskell to keep "forall" implicit.
16:09:01 <monochrom> I understand the argument: standard Haskell is rank-1 anyway. It saves coding time.
16:09:56 <monochrom> But it costs learning time. It causes beginner-level confusions. The confusions can be resolved, but it takes time.
16:10:54 <monochrom> I don't have data to show how much coding time saved vs how much learning time wasted. So I can only keep it as an opinion, not a "told you so".
16:11:32 <solonarv> monochrom: I agree 100%
16:12:09 <monochrom> What rubs me the wrong way is some people actually dare to claim "implicit forall is easier to learn".
16:12:42 <monochrom> Complete falsehood. Implicit forall is easier to learn wrong.  Now the learner wastes time learning the wrong way and then fixing it.
16:13:08 <monochrom> Implicit forall is the whole reason why students take forever to learn induction.
16:13:26 <justsomeguy> Are you talking about quantification of type variables in type signatures?
16:13:32 <monochrom> Yes.
16:14:06 <monochrom> But game-theoretically it has the same nature as predicate logic's.
16:15:32 <justsomeguy> What do you mean by induction?
16:19:07 <yushyin> out of sheer curiosity, what can be learned wrong from implicit forall?
16:19:36 <justsomeguy> (I'm guessing you mean inferring what a function can do based on a type signature.)
16:22:17 <justsomeguy> Well, I interjected in the middle of a conversation with some assumed background and started asking basic questions. Sorry about that. It's really interesting how logic and Haskell overlap, though.
16:23:04 * justsomeguy is excited to learn some logic and see what he can do with it and TemplateHaskell, but still has to get the basics down, first.
16:42:22 <monochrom> In the Haskell case, a typical lesson goes "f :: a -> a"  "that 'a' can be any type".
16:43:12 <monochrom> The problem is that it is completely informationless.  No one has ever doubted the "any" aspect.
16:43:44 <monochrom> The unresolved ambiguity is who controls the choice. Author of f?  User of f?
16:44:07 <monochrom> The student is left to guess.  Worse, left to assume that they guess right.
16:44:53 <monochrom> Next time you see someone asking: "I coded up f :: a -> a; f x = x + 1.  Why is the computer hating me?"  You now know what happened.
16:45:17 <monochrom> "But my teacher said 'a' can be any type!"
16:45:32 <monochrom> "So I chose Integer"
16:48:41 <monochrom> In the induction case, it's technically off-topic, I don't know whether I should discuss it here or in another channel.
16:49:37 <monochrom> But briefly: "assume P(n), prove P(n+1)" the students resolved the ambiguity the other way.
16:50:01 <monochrom> And they have just cause to do it wrong due to previous training.
16:53:06 <justsomeguy> What would a type signature that doesn't use implicit forall look like for that function, f?
16:53:17 <monochrom> f :: forall a. a -> a
16:53:28 <yushyin> monochrom: ah I see now, I never considered that to be an issue for beginners but you are right.
16:54:04 <monochrom> Adding "forall a" doesn't solve the problem.  But it forces the teacher to do a better job to explain it.
16:54:19 <monochrom> s/doesn't/alone doesn't/
16:56:24 <monochrom> And students have a slightly better chance of guessing it right.  In discrete math or other previous courses, they have seen "forall vs exist".
17:00:20 <MarcelineVQ> huh neat. that and the literal memnonic  for all a  doesn't hurt
17:00:53 <monochrom> GHC has an extension for exactly this syntax :)
17:01:14 <monochrom> ExplicitForall
17:01:34 <monochrom> Err!  ExplicitForAll
17:01:55 * monochrom Expletive...
17:02:27 <MarcelineVQ> I get got by GeneralizedNewTypeDeriving just about every time
17:02:30 <monochrom> Should I code up and PR a -XExpletiveForAll for next April 1? >:)
17:03:12 <monochrom> Why do I always come up with April 1 ideas one month late???!!!!!
17:04:55 <MarcelineVQ> comedy = tragedy + time    so I guess it's actually funny but comes late then you're not tragic enough
17:05:07 <MarcelineVQ> *if it's actually
17:07:07 <solonarv> monochrom: do it!
17:07:21 <solonarv> the effect should be that GHC curses you out when you don't write a forall.
17:07:57 <monochrom> No, I'm thinking "f :: dammitall a. a -> a" and "main = bloodydo { x <- getLine; ..."
17:08:27 <monochrom> It is more like ExpletivesForAll hehe
17:10:10 <hpc> or on the command line, ghc -XPletives
17:10:18 <monochrom> :)
17:20:47 <polyphem> https://imgflip.com/i/3x3o44
17:21:29 <monochrom> hehe
18:16:05 <dmj`> is the hackage counter telling us the truth
18:54:28 <flebron_> Hi folks. If I have a [ExceptT e (State s) a], is it possible to "Give me the first computation that doesn't fail, when run with the current state"?
18:59:10 <monochrom> I think you have better luck with the other order, StateT s (Except e) a
18:59:26 <flebron_> Can't choose what I have :) 
19:00:07 <flebron_> I guess it's OK if the computations are sequenced until the first success. Is that easier?
19:00:52 <monochrom> It is easier but each "failed" computation still changes state, the change being visible to later ones.
19:00:57 <evertedsphere> how do i go from, e.g. "3f2a" to the unicode character '\3f2a'
19:00:58 <solonarv> @unmtl ExceptT e (State s) a
19:00:58 <lambdabot> ExceptT e (State s) a
19:01:01 <flebron_> Yeah that's fine :)
19:01:08 <solonarv> lambdabot pls -.-
19:01:12 <solonarv> @unmtl ErrorT e (State s) a
19:01:12 <lambdabot> s -> (Either e a, s)
19:01:12 <monochrom> Use ErrorT
19:01:23 <flebron_> Hrm?
19:01:35 <monochrom> whereas my order has "roll back to old state" semantics.
19:01:39 <solonarv> oh that's just lambdabot's @unmtl plugin being a bit old
19:01:49 <monochrom> very old
19:02:18 <flebron_> I'm fine with sequencing the computations until the first success.
19:02:40 <solonarv> in that case 'asum' should work.
19:02:42 <solonarv> :t asum
19:02:44 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
19:02:47 <flebron_> I can do it myself via pattern matching and recursion if needed, just wondered if there was a combinator
19:03:07 <solonarv> asum [x,y,z,...] = x <|> y <|> z <|> ...
19:03:07 <flebron_> Doesn't the Alternative instance of ExceptT e (State s) a need a Monoid on e?
19:03:32 <solonarv> % :t (<|>) @(ExceptT _ (State _))
19:03:33 <yahb> solonarv: forall {w1} {w2} {a}. Monoid w1 => ExceptT w1 (State w2) a -> ExceptT w1 (State w2) a -> ExceptT w1 (State w2) a
19:03:34 <flebron_> "instance (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m) where
19:03:44 <solonarv> apparently it does.
19:03:57 <monochrom> You probably have to write your own.
19:04:01 <flebron_> I thought of <|> and then became sad when I saw that constraint.
19:04:04 <flebron_> Oh. The sad.
19:04:22 <monochrom> All standard combinators try to preserve standard semantics, which is not your semantics.
19:04:33 <solonarv> I think you can write firstWorking :: ExceptT e m a -> ExceptT e m a -> ExceptT e m a
19:04:37 <flebron_> The standard semantics are of sequencing, no?
19:04:48 <evertedsphere> > readLitChar "\\005a"
19:04:49 <solonarv> and then: foldr firstWorking nothingWorked
19:04:51 <lambdabot>  [('\ENQ',"a")]
19:04:52 <flebron_> So what's wrong with sequencing all of the stateful computations, until the first one that doesn't fail?
19:05:13 <monochrom> Ah OK, try <|>, see what happens.
19:05:24 <flebron_> Can't <|> without Monoid :) 
19:05:26 <solonarv> we already determined that <|> does not work
19:05:41 <flebron_> But I guess solonarv's firstWorking is a more lenient <|>.
19:05:52 <monochrom> "sequencing" is broad and open-eneded.
19:05:58 <evertedsphere> or even
19:06:05 <evertedsphere> > readLitChar "\\0041"
19:06:08 <lambdabot>  [(')',"")]
19:06:16 <solonarv> <|> technically only needs a Semigroup, and (First a) is a semigroup for any type a
19:06:26 <evertedsphere> i'm at my wits' end here shouldn't this just be 'a'
19:06:32 <solonarv> my firstWorking is just <|> usign the (First a) semigroup
19:06:36 <flebron_> Yeah I was looking for something like that. I searched for "OneOf" but I guess First is better :)
19:06:47 <monochrom> or Last.
19:06:49 <flebron_> Is there an easy way to adapt to use First in such a list of computations?
19:07:03 <solonarv> evertedsphere: check that you are using the correct one among: octal/decimal/hexadecimal
19:07:32 <solonarv> flebron_: well, First isn't a monoid, so you can't actually use <|> with it
19:07:37 <evertedsphere> ...crap. thank you
19:07:46 <solonarv> the easiest way is to just hand-write:
19:07:46 <flebron_> The sadness returns.
19:08:43 <solonarv> firstWorking a b = ExceptT $ runExceptT a >>= \case Left e -> runExceptT b; Right x -> pure (Right x)
19:08:57 <solonarv> in fact:
19:09:01 <solonarv> % firstWorking a b = ExceptT $ runExceptT a >>= \case Left e -> runExceptT b; Right x -> pure (Right x)
19:09:01 <yahb> solonarv: 
19:09:05 <solonarv> % :t firstWorking
19:09:05 <yahb> solonarv: forall {m :: * -> *} {e1} {a} {e2}. Monad m => ExceptT e1 m a -> ExceptT e2 m a -> ExceptT e2 m a
19:09:17 <solonarv> huh.
19:09:47 <monochrom> It's OK.
19:09:50 <flebron_> (My errors here are identical)
19:10:07 <flebron_> Kinda funny though, why can it deduce it's e2 and not e1?
19:10:42 <monochrom> e1 is eaten
19:10:55 <solonarv> yup
19:11:00 <monochrom> e1 cannot happen anymore. The whole point.
19:11:06 <solonarv> you could of course give it a more specific type signature if you wantd
19:11:07 <flebron_> Ohhh. Right.
19:11:09 <monochrom> e2 is the only possibility
19:11:16 <flebron_> If it fails, it's because e2 failed.
19:11:20 <flebron_> s/e2/b/
19:11:20 <monochrom> BE CAREFUL WHAT YOU WISH FOR
19:11:37 <flebron_> Thanks folks :D
19:11:49 <solonarv> % :t foldr firstWorking (throwError "end of list")
19:11:49 <yahb> solonarv: forall {m :: * -> *} {t :: * -> *} {e1} {a}. (Monad m, Foldable t) => t (ExceptT e1 m a) -> ExceptT [Char] m a
19:12:09 <solonarv> huh, that's more polymorphic than I expected.
19:12:20 <solonarv> I guess it makes sense!
19:12:36 <monochrom> type inference is very informative
19:12:57 <monochrom> puny human brains cannot follow their own wishes to their logical conclusion
19:13:13 <solonarv> and I am bad at it because I am sleepy :)
19:13:26 <monochrom> robots can go much further, but only when rank-1.
19:14:17 <monochrom> against rank n, the turing machines themselves, cannot contend
19:16:02 * ski nods solemnly
19:58:15 * hackage net-spider 0.4.3.0 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.3.0 (debugito)
20:05:47 <zeta_0> how would i return the number of elements of an array without using the count, size or length functions? what would you recommend?
20:07:15 <zeta_0> i just want a hint, not the code
20:08:50 <solonarv> zeta_0: conceptually clean: replace every element with 1, then sum up the resulting [Int] (or Vector Int, or Array i Int, you get the idea)
20:09:59 <solonarv> to do it in one step, you will need to use some sort of fold (i.e. foldr, foldl, foldMap, or one of their variants)
20:13:39 <koz_> foldMap is the coolest option.
20:14:19 <zeta_0> this seems like a simple way:
20:14:21 <zeta_0> len :: [a] -> Int
20:14:21 <zeta_0> len [] = 0
20:14:21 <zeta_0> len (x:xs) = (+1) (len xs)
20:15:12 <solonarv> yes, that is the simplest way to write it
20:15:20 <solonarv> (but why did you write (+1) like that?
20:15:21 <solonarv> )
20:17:09 <solonarv> I must go, my bed beckons. good luck with your length implementations!
20:17:10 <zeta_0> solonarv: to keep adding by 1 to add up the length, is there a better way?
20:17:14 * hackage net-spider-rpl-cli 0.1.3.0 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.3.0 (debugito)
20:17:26 <solonarv> well, you could just have written that as: len (x:xs) = 1 + len xs
20:17:42 <solonarv> or len xs + 1 I suppose
20:19:27 <zeta_0> i'm not sure what you mean
20:20:18 <zeta_0> solonarv: oh, ya, i didn't see that thanks, and later
20:21:17 <xsperry> now try fold
20:25:23 <zeta_0> ok: length = foldr (\ _ acc -> 1 + acc) 0
20:27:29 <xsperry> yes, but foldl' would be better choice for this. unlike foldr it would use constant memory
20:28:45 <zeta_0> oh i see
20:29:40 <zeta_0> i think i'm going to call it a day as well, later everyone
20:48:50 <koz_> ala Sum foldMap (const 1) :D
20:58:45 <slack1256> Is there a disciplined way to deal with data dependencies on variables?
21:00:14 <slack1256> I am currently revisiting some code I "fixed" on taffybar which deal with network interfaces output rates. I inserted some `seq` where the profiling told me and fixed the leak. But re-reading I kind of shudder to the amount of data-dependencies I am ignoring and how they can trigger leaks.
21:01:48 <sm[m]> slack1256: an FRP framework ?
21:04:44 <fishooter> I have two threads, one that write to stdout and another that reads from stdin. How can I make writing in terminal kind of like in IRC, i.e. when I am in the middle of typing input, the output will be posted above the typed string?
21:05:25 <fishooter> I suppose it's some carrieage return magic?
21:05:47 <slack1256> fishooter: Use the `brick` library create the TUI.
21:05:58 <jackdk> the low-level answer is using a library like "curses" that emits the correct magic escape sequences. There are probably libraries on hackage that let you write your code in terms of screen areas to write to
21:06:04 <jackdk> yeah, like brick
21:06:10 <slack1256> I am currently using glirc (an irc client written on haskell) which does exactly what you're describing.
21:06:52 <fishooter> if it's not too complicated I would prefer doing it on my own, I suspect it's just a few correct magic escapes
21:06:57 <fishooter> I'll look into brick, thanks!
21:07:13 <fishooter> or curses
21:08:34 <sm[m]> the concurrent-output lib, maybe
21:10:50 <fishooter> concurrent-output seems to be, well, just concurrent output :)
21:10:58 <fishooter> brick and ncurses seem too complicated
21:11:17 <fishooter> I just want to achieve this simple task, but I'm not sure what are the keywords to search
21:11:39 <fishooter> even just outside of haskell, how would you do that in bash?
21:12:34 <sm[m]> it gives you control of separate regions of the terminal for output/input, no ?
21:12:35 <fishooter> put one thread to bg, and read input in the main thread. Do not get those two mixed up
21:13:00 <fishooter> it's too complicated, I don't want to get yet another dependency into the project :)
21:14:21 <sm[m]> ok, go for it. Keep us posted! :)
21:18:58 <fresheyeball> Can I use generics to write a typeclass for zipping two HKD's together?
21:19:27 <fishooter> another thing -- I'm using gloss for rendering. It seems that when I fork a thread for GUI and press the X button, it not only closes the window but also quits the whole program
21:19:32 <fishooter> How can I prevent that?
21:23:22 <dmwit> Haskell programs exit when the main thread exits.
21:23:51 <dmwit> So either 1. the other thread is doing something (like System.Exit-ish) that kills the main thread or 2. you aren't holding the main thread open as long as you wanted.
21:23:59 <dmwit> Pretty tough to say with the info we've been given so far.
21:25:38 <fishooter> it seems to be related to which rendering backend gloss uses: https://stackoverflow.com/questions/39606232/why-does-my-program-exit-immediately-after-playing-a-gloss-animation
22:08:07 <evertedsphere> is there a way to generate base functors using Data.Functor.Foldable.TH for *mutually recursive* ADTs?
22:08:58 <evertedsphere> i tried it on something that looks like data Expr = ExprApp App | ExprLam Lam (where data App = App Expr Expr etc) and it didn't *recurse into* the constructor fields
22:11:22 <evertedsphere> (is this even a valid thing to do?)
22:13:40 <c_wraith> There would be a couple options
22:15:19 <c_wraith> Though I'm not sure how well the TH module handles any of them
22:16:04 <c_wraith> But here's my most important question - what do you want to actually fold/unfold over?  
22:16:30 <evertedsphere> https://github.com/sdiehl/paris-fp/blob/master/src/Transform.hs#L20 
22:16:51 <evertedsphere> i'd like to write a similar closureConvert function for my Expr type
22:17:05 <evertedsphere> but using a catamorphism as shown here: https://gist.github.com/jozefg/652f1d7407b7f0266ae9#file-closconv-lhs-L127
22:17:59 <evertedsphere> my datatype has a ton of cases and it's quite time-consuming having to manually pattern-match on each constructor separately and so i figured using `cata` might save me a lot of work
22:18:22 <c_wraith> it actually doesn't save you from writing all the cases.
22:18:35 <evertedsphere> maybe i could get away with some other library? i'm not very familiar with them but would syb/uniplate etc be of any use here?
22:18:49 <evertedsphere> well, no, i mean writing the recursion explicitly. my bad
22:19:34 <Rembane> If you want to add Fix everywhere you can use cata. 
22:19:44 <c_wraith> wait...
22:20:02 <c_wraith> Why are you calling (closureConversion globals) a bunch instead of go?
22:20:15 <evertedsphere> not my code haha
22:20:26 <evertedsphere> those are just two examples i'm referring to
22:21:27 <evertedsphere> i guess i should avoid the X/Y problem and ask what's the quickest way to get access to something cata-like? i'm not necessarily required to use recursion-schemes
22:22:10 <evertedsphere> i just want to not have to write separate closConvApp closConvLam closConvCase etc things for each constructor of my Expr type and have something "intelligently" recurse into the syntax tree
22:22:36 <c_wraith> depends on what kind of output you want
22:22:48 <Rembane> evertedsphere: Here's an example of using Fix on an AST: https://github.com/Rembane/MiniML/blob/master/src/Language/MiniML/Expr.hs
22:23:08 <c_wraith> If you want to rewrite a tree, but still have the output be a similar tree, the plate-style stuff is good
22:23:33 <evertedsphere> thanks for the link, but that's not a mutually recursive type, Rembane 
22:23:40 <evertedsphere> it's the mutual recursion that is the problem here
22:23:50 <evertedsphere> c_wraith: right, i think that's what i want
22:24:01 <evertedsphere> the function I'm trying to write is of type [Var] -> Expr -> Expr
22:25:08 <c_wraith> I never learned to use uniplate or biplate...  but I'm comfortable with their lens equivalents, in a bizarre twist.
22:25:26 <Rembane> evertedsphere: Sorry, I missed the mutually part. 
22:25:28 <evertedsphere> hahaha i've used some of the rewrite lenses too in the past
22:25:35 <c_wraith> There's also the entire Control.Lens.Plated module for self-similar recursion along all kinds of dimensions
22:25:36 <evertedsphere> Rembane: npnp
22:26:16 <evertedsphere> i'm not sure i need *lenses*, is that functionality not available in pure uniplate?
22:26:50 <evertedsphere> i guess i should probably just jump in now and see for myself
22:26:54 <evertedsphere> thanks for the pointers!
22:27:04 <c_wraith> I'm sure most of it is in uniplate
22:27:13 <c_wraith> I just don't know how to use that.  lenses are easier :)
22:27:49 <evertedsphere> fair, it's just that this is $work code and the other people on my team won't necessarily take kindly to a lens dependency haha
22:27:54 <evertedsphere> but if i must i must
22:28:05 <evertedsphere> https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Data.html 
22:28:12 <evertedsphere> wow this page looks like it's from 10 years ago 
22:28:30 <evertedsphere> wait no it's just my dark reader thing. huh
22:28:43 <c_wraith> dark mode is from 10 years ago.  check
22:29:00 <evertedsphere> :(
22:29:10 <c_wraith> actually, uniplate looks like it matches what I'm comfortable with from lens pretty well:  https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
22:30:16 <evertedsphere> i've never had to use Data before, i understand GHC.Generics pretty well though... i guess Data is some Typeable-flavoured thing?
22:30:58 <c_wraith> Yes, Data depends on Typeable
22:31:05 <evertedsphere> primops for plate libraries, i guess?
22:31:29 <c_wraith> Data provides operations to fold over arbitrary constructors.
22:31:47 <c_wraith> They're very weirdly typed due to having to work on... well, arbitrary constructors.
22:32:00 <c_wraith> A library like uniplate provides a far easier to understand interface
22:35:15 * hackage hurl 1.4.1.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.4.1.0 (alcinnz)
22:38:29 <slack1256> https://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
22:38:41 <slack1256> Has anyone seen that idea expanded on? I think is onto something...
22:41:02 <evertedsphere> C{-# LANGUAGE DeriveGeneric #-}
22:41:05 <evertedsphere> oops
22:46:32 <jackdk> we forgive you, it's a pretty cool extension
22:47:56 <evertedsphere> i knew it could do many things but i didn't know it gaining execute privileges and pasting itself into the irssi input field was one of them
23:14:22 <clmg> I successfully built asterius, but I get cbits/atomic.c:182:10: error: note: '__sync_fetch_and_nand' changed semantics in GCC 4.4 when I boot. What are my troubleshooting options?
