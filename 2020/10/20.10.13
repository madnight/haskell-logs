00:38:19 * hackage pandoc-crossref 0.3.8.2 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.8.2 (lierdakil)
01:13:27 <gentauro> so it looks like I got `lsp` to work with `emacs`. But is there a way to disable the "clippy a like boxes"? I mean, as a colorblind person, they don't do anything for me :D https://postimg.cc/QBPhSSM9
01:14:47 <gentauro> btw, this is how I got it to work -> https://pastebin.ubuntu.com/p/WTqKCSNJYS/
01:15:03 <gentauro> it seems like the `install.hs` doesn't really play nice with stack :(
01:16:28 * gentauro I would <3 to update https://github.com/haskell/haskell-language-server/issues/171#issue-643008760 with this comment, but sadly I "wiped" my GH account when M$ overtook the platform …
01:19:56 <gentauro> oh, so if I remove `lsp-ui` from `emacs`, then "clippy msgs" go away. Good to know :)
01:23:38 <gentauro> I guess it's fair to say that `lsp-haskell` is pretty fast compared to `intero`. Hmmm
01:29:05 <kindaro> Is there an introduction to Object Oriented Programming for a functional programmer?
01:30:49 <kindaro> I would like to have basic concepts and motivation explained to me, but so far I have not been able to locate a clear introduction.
01:32:29 <gentauro> kindaro: at KU they teach the three paradigsm: imperative, FP and OO under the same umbrella (F#) for newcomers to CS
01:32:39 <kindaro> KU?
01:33:01 <gentauro> that way it's easier to see the differences between these paradigms (same language/syntax) and not get lost in translation
01:33:29 <gentauro> kindaro: KU = København Universitet (in English: University of Copenhagen)
01:33:50 <gentauro> maybe the teaching material is available openly? You might reach out to Athas for that
01:35:20 <kindaro> This looks like the thing: https://studier.ku.dk/bachelor/datalogi/faq/livet-paa-uddannelsen/Eksempel_p__en_tekst_fra_datalogi.pdf
01:39:05 <gentauro> kindaro: might be. I would have hoped for `Torben Ægidius Mogensen` material :)
01:40:52 <gentauro> kindaro: I'm asking him on FB
02:03:07 <merijn> When (which GHC) did Monoid move to prelude?
02:06:44 <Taneb> merijn: 7.10
02:06:57 <Taneb> base has a pretty useful changelog
02:07:37 <kindaro> gentauro, I value your help. I have to go presently. If you have any more information about that F# teaching material, please write to me offline _(I can check the public log)_ or ask the bot to deliver a message.
02:11:11 <merijn> Taneb: Yeah, that just occurred to me
02:13:10 <jonathanx> So I want to create a typeable representation of a GADT tagged with datakind based phantom types. I run into issues which I think is due to datakind based types not having Typeable instances (as opposed to to ordinary types). This is a bit annoying, seeing as a typeable instance for datakind is a simple "demotion" from type->value. So my question is: is there a convenient way to create typeable instances for GADTs that have DataKinds 
02:13:10 <jonathanx> phantom types?
02:14:49 <merijn> jonathanx: Eh, out of curiousity, why do you wanna do that?
02:23:36 <jonathanx> I'm working with a domain similar to dataflow languages (such as labview), where the nodes have various invariants in the way they connect together/the outputs relate to the inputs. I'm prototyping encoding these invariant in GADTS decorated with datakind based phantom types. When constructing this/connecting the nodes together, I'm planning to first create a rose-tree representing all wanted connections, where the invariant-enforcing 
02:23:36 <jonathanx> phantom types are "boxed" into a GADT such as "data Any where Any :: Specific phantomType -> Any". Then I want to fold that tree, "unboxing" the data as I go, and connect all children to each tree-node with phantom type based type security. When "unboxing", I want to use typeReps to help the compiler validate that the type "boxed" can be used as a parameter to the node it's connecting to
02:25:50 <merijn> eh, all I can say is "good luck" >.>
02:27:21 <jonathanx> Thank you!
02:29:59 <sshine> I'd probably go with JSON. :-D
02:30:25 <dminuoso> JSON is webscale.
02:30:34 <sshine> what does webscale mean?
02:30:57 <dminuoso> sshine: https://www.youtube.com/watch?v=b2F-DItXtZs
02:31:04 <sshine> I see JSON more like a common serializable format. short path between two command-line programs to share structured data.
02:32:39 <dminuoso> Superficially, JSON only solves the "how do I serialize numbers (that's a funny bit, btw), strings, dictionaries, lists and bools" part.
02:32:50 <sshine> dminuoso, it sounds like tacking "web scale" onto something means you disapprove of it because of premature scaling concerns. :)
02:33:02 <sshine> s/only // and I'm with you.
02:33:10 <dminuoso> sshine: There's a lot of tongue-in-cheek in the webscale remark, above.
02:33:15 <sshine> yeah
02:33:24 <sshine> I think JSON is quite unambitious, which is a good thing.
02:33:38 <dminuoso> The thing is, when you're getting a deserialized JSON, you still have to parse the structure of it.
02:33:55 <dminuoso> Much of Python code is more adhoc, and destructures the data all over the place.
02:34:48 <dminuoso> Since JSON types can be mapped into equally unstructured Python data.
02:34:58 <sshine> so, my idea is, you have a bunch of ADTs, you derive Aeson encode/decode, and you save your configs to disk. if you need to interact with them in *any other way*, serialization is given. if not, you can post-pone deriving Aeson.
02:35:16 <sshine> so no web scale ambition here. :)
02:37:12 <sshine> they're not as safe as GADTs with phantom types, but they serialize nicely, which is something I'd probably appreciate sooner. :)
02:42:58 <gentauro> jonathanx: why not just to `show` / `read`?
02:43:34 <gentauro> jonathanx: I have started to use that (with pretty-print) instead of `JSON`
02:43:55 <gentauro> It's more readable and it's easily save/load -able
02:43:56 <Uniaika> hey folks, I'm having a bit of an issue with Aeson. Do you know how I can write a `ToJSON MySumType` instance that would write the two members of the sum type as separate keys in the top-most object?
02:44:06 <Uniaika> because I could write them in a sub-object
02:44:23 <Uniaika> but due to reasons like backward compatibility, this is hardly an option :/
02:46:31 <jonathanx> Well, if I were to use json, then I'd have to somehow serialize the phantom types (representing them in the json), and validate them on deserialization. This would leave me open to pretty mauch the same range of errors I'd get if I just enforced the invariants using runtime checks
02:46:51 <gentauro> dminuoso: that `webscale` video made my day. It's actually a documentary, cos that moment (2:35) I had far to many times … (it's like they are "quoting me") :o
02:48:30 <jonathanx> which would turn the entire phantom type based invariant forcing into just a piece of redundant bloat/an excessive roundtrip
02:48:42 <gentauro> Uniaika: I tend to use `set <|> bin` (`Control.Applicative` Alternate) for that
02:49:21 <gentauro> I can post code that does exactly what you are asking for, but I'm working on the proejct at this exact moment :)
02:49:29 <gentauro> s/I can/I can't/
02:51:49 <gentauro> kindaro: `please write to me offline` Roger that
02:53:49 <Uniaika> gentauro: oh, thank you :)
02:57:08 <dminuoso> Uniaika: You could always just write the object out by hand `object ["foo" .= foo, "bar" .= bar]`, Ive grown quite fond of that.
02:57:49 <dminuoso> Too often I found, relying on generics, generics with options, and things like the Alternative, is trying very hard to take indirect control over the encoder/decoder
02:57:57 <kuribas> Uniaika: do you need to rewrite the Aeson?
02:58:09 <kuribas> Uniaika: I actually just wrote code to do that.
02:58:20 <kuribas> Uniaika: and you can still use generics after it.
02:59:45 <dminuoso> Also, with generics you're tying external representation directly to your data types. To get around that, you might start having a separate data type, where you rename fields particularly to control the representation, and then you need a sort of `fromRep/toRep` functions, which is the exact boilerplate you tried to avoid in the first place..
02:59:50 <kuribas> Uniaika: https://gist.github.com/kuribas/5c617ecf025ccb37467a23556cbe963e
02:59:57 <dminuoso> Every time I stare at aeson, I dont think generics are a good idea. :(
03:00:02 <dminuoso> Or typeclasses at all
03:00:27 <kuribas> there are many times where generics are actually desirable.
03:00:38 <Uniaika> thanks to you all :)
03:00:51 <kuribas> because you know it will still be consistent when you add a field.
03:01:02 <kuribas> while manual instance don't garantee that your instances are consistent.
03:01:22 <Uniaika> kuribas: I have a roundtrip test for that
03:01:33 <Uniaika> always with manual instances for Aeson and pg-simple
03:01:36 <kuribas> Uniaika: with my code it is actually garanteed
03:01:56 <kuribas> Uniaika: as long as you use the same options of course.
03:02:11 <Uniaika> kuribas: I'm waiting for a blog post to introduce that AesonTrans :)
03:02:20 <Uniaika> it really looks interesting :)
03:02:20 <kuribas> Uniaika: I should make a library for it...
03:02:25 <Uniaika> also! :D
03:03:30 <kuribas> Uniaika: the disadvantage is that it rewrites the Value, so it is less efficient than a direct toEncoding.
03:04:49 * hackage Z-IO 0.1.5.1 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.5.1 (winterland)
03:05:18 <kuribas> Uniaika: fromField (Proxy @"field") ["a", "b"] "c", pulls in field c, for example {"a": {"b": {"c" = 2 }}} => {"field" => 2}
03:07:24 <kuribas> Uniaika: maybeFromField does the same, but can be empty.
03:08:06 <kuribas> Uniaika: you can compose the AesonTrans with monoid, use postTransJSON and preTransJSON to translate the JSON.  That's it basically.
03:08:36 <kuribas> Uniaika: and don't forget to set the fieldModifier using transFieldModifier if you have one.
03:10:17 <Uniaika> kuribas: I doubt I'll be able to pull this off for the current project, but I will definitely think about it for any next project I'm bootstrapping
03:10:30 <Uniaika> (but again, I'll need some kind of blog post to introduce the lib and its usage :P)
03:10:55 <kuribas> Uniaika: yeah, a hackage library with some docs would be a good idea :)
03:11:08 <Uniaika> <3
03:38:19 * hackage matchable-th 0.1.1.1 - Generates Matchable instances using TemplateHaskell  https://hackage.haskell.org/package/matchable-th-0.1.1.1 (viercc)
03:43:02 <Uniaika> god damnit
03:43:55 <Uniaika> I'm having this JSON format to parse and I can't seem to make sense of what to do
03:44:11 <Uniaika> I have *two* top-level field, that are to be unified in a sum type in Haskell-land
03:46:06 <Uniaika> so naturally I'm writing such an instance https://ghostbin.co/paste/r64hne2
03:46:52 <Uniaika> (surprise, doesn't compile)
03:53:05 <fendor> Uniaika, in the example, aren't you missing the unifying sum type?
03:55:27 <Uniaika> >_> sorry, I'll edit the snippet
03:56:02 <Uniaika> fendor: reload, it's been added
03:57:09 <fendor> Uniaika, and why doesn't it compile? Code-snippet looks roughly good to me
04:01:30 <merijn> heh
04:01:43 <Uniaika> fendor: https://ghostbin.co/paste/r64hne2
04:01:46 <Uniaika> here is the error
04:01:47 <merijn> "maybe" is exported from Prelude?
04:02:00 <Uniaika> merijn: yes, I think so
04:02:18 <Uniaika> fendor: also, I think I have a hard time expressing the fact that they may be null, but not at the same time?
04:02:46 <Uniaika> I mean, if it were an object, I'd use (.:?)
04:02:53 <nshepperd> this looks like a job for Alternative
04:03:22 <Uniaika> hmm
04:03:26 <Uniaika> sounds like it yeah
04:03:52 <Uniaika> but every tutorial under the sun seems to be operating on an object, and not with top-level values, so I don't know how much they apply?
04:03:55 <Uniaika> hmm.
04:04:03 <Uniaika> I'll try something
04:04:20 <Uniaika> (thanks for being rubber ducks, it's incredibly helpful to be able to lay down my thoughts)
04:04:50 <fendor> Uniaika, I think the type for field2 is wrong, too. Don't you need Data.UUID.fromText ? 
04:05:19 <Uniaika> fendor: well, since there is already a FromJSON instance for UUID, I thought it would work out-of-the-box?
04:05:35 <nshepperd> what exactly do you mean by a top level field
04:05:59 <nshepperd> value, whatever
04:06:03 <Uniaika> I'll add the desired JSON representation to the snippet
04:06:50 * hackage git-mediate 1.0.8.1 - Tool to help resolving git conflicts  https://hackage.haskell.org/package/git-mediate-1.0.8.1 (EyalLotem)
04:06:56 <fendor> Uniaika, I don't think `withText` gives you a text and then you have to specify a value parser for that text. Doesnt use the instance automatically
04:07:26 <nshepperd> that usage of withText doesn't look right anyhow
04:07:34 <fendor> indeed
04:07:49 <nshepperd> The first argument is only used for the error message
04:09:12 <Uniaika> fendor, nshepperd : https://ghostbin.co/paste/r64hne2
04:09:26 <merijn> Uniaika: I recommend using a different pastebin, that one is terrible
04:09:31 <Uniaika> ah shit
04:09:32 <Uniaika> sorry
04:09:36 <Uniaika> dpaste? 
04:09:41 <merijn> It apparently requires me enabling cookies AND solving a captcha to read things
04:09:43 <merijn> screw that
04:09:45 <Uniaika> I think hpaste is dead now, right?
04:09:46 <dminuoso> https://paste.tomsmeding.com/
04:09:54 <dminuoso> Is the spiritual hpaste successor
04:10:02 <Uniaika> https://paste.tomsmeding.com/QMFidUu1
04:10:07 <Uniaika> dminuoso: thx
04:10:11 <fendor> well, for Foo, it could be something like: `parseJSON v = Field1 <$> v .: "field1" <|> Field2 <$> v .: "field2"`
04:10:13 <merijn> tomsmeding is the hero #haskell needed ;)
04:10:31 <merijn> He resurrected ircbrowse too, so now I can be self-concious about how much time I spend here :p
04:10:39 <Uniaika> fendor: ooooh
04:10:52 <merijn> tomsmeding: oh, maybe you should send a mail to Haskell Weekly to publicize those two?
04:11:49 * hackage http-conduit-downloader 1.1.0 - HTTP downloader tailored for web-crawler needs.  https://hackage.haskell.org/package/http-conduit-downloader-1.1.0 (VladimirShabanov)
04:12:36 <Uniaika> fendor: but (.:) is expecting a HashMap right?
04:12:47 <tomsmeding> merijn: I'm not sure it would be a good idea to publicise ircbrowse that way, given that it's not my project... :p
04:13:15 <dminuoso> Uniaika: No.
04:13:18 <merijn> tomsmeding: It's open source, you just forked/maintained it
04:13:27 <dminuoso> (.:) :: FromJSON a => Object -> Text -> Parser a
04:13:27 <tomsmeding> true
04:13:34 <merijn> tomsmeding: I don't think Chris would mind, but you could always ping him over email and ask
04:13:35 <dminuoso> Uniaika: The interface is usually like this:
04:13:39 <fendor> Uniaika, Then you would need: `parseJSON obj = withObject "TopLevel Object" $ \v -> Field1 <$> v .: "field1" <|> Field2 <$> v .: "field2"`
04:13:57 <dminuoso> Uniaika: withObject "foo" $ \o -> F <$> o .: "some" <*> o .: "other"
04:14:32 <dminuoso> Or, as I prefer, with RecordWildcards:
04:15:05 <dminuoso> withObject "foo" $ \o -> do { field1 <- o .: "field1"; field2 <- o .: "field2"; pure F{..} }
04:15:09 <fendor> Personally, I found my library to go now is aeson-combinators. Json decoders and encoders is one thing elm got right
04:15:37 <cpressey> May I humbly propose replacing 'https://gist.github.com/' in the topic of this channel with 'https://paste.tomsmeding.com/'? :)
04:15:45 <dminuoso> fendor: waargonaut addresses most issues well
04:15:56 <dminuoso> it has a much better and flexible interface
04:16:04 <Uniaika> dminuoso: but wouldn't that mean that the expected JSON has this "foo" sub-object then?
04:16:21 <dminuoso> Uniaika: No, that's just a name that is used for debugging
04:16:35 <dminuoso> Uniaika: So when the parser fail, it will call the object (it was looking for) "foo"
04:16:45 <fendor> dminuoso, too complex for my taste
04:16:54 <dminuoso> fendor: Dunno, I find it rather simple.
04:17:16 <dminuoso> Uniaika: https://hackage.haskell.org/package/aeson-1.5.4.1/docs/src/Data.Aeson.Types.FromJSON.html#withObject
04:17:35 <merijn> dminuoso: waargonaut's API is a Lovecraftian mess I wouldn't wish upon my worst enemy
04:18:47 <dminuoso> merijn: It's not any less offending than say megaparsec.
04:19:10 <dminuoso> And zippers!
04:19:26 <dminuoso> When you have to deal with other peoples formats, zippers are really a blessing.
04:20:11 <fendor> aeson-combinators is much less offending. But I have to admit, Currently I only have rather trivial json formats to maintain
04:20:12 <dminuoso> And waargonaut handles JSON better, since it can deal with multiple "overlapping" attributes in objects
04:20:21 <merijn> dminuoso: tbh, I think megaparsec has regressed *a lot* in that regard
04:20:40 <merijn> And it's a bad thing for Haskell and the ability to promote megaparsec to beginners
04:21:22 <dminuoso> merijn: The rudimentary interface of waargonaut is simpler than aeson by far.
04:22:04 <merijn> dminuoso: Then they need to package/document it better to hide away the clutter from the "main" user facing UI
04:22:15 <dminuoso> I agree, the documentation could be improved.
04:23:29 <nshepperd> Uniaika: the top level json you're looking at there _is_ an object, that's what withObject is for
04:23:49 <nshepperd> field1 and field2 being text fields of it
04:24:14 <Uniaika> nshepperd: okay, I was afraid that since I'm writing an instance for what is a secondary object, it would try and mimic that structure in the JSON, which is a flat object
04:24:45 <dminuoso> merijn: https://github.com/qfpl/waargonaut#example if you consider these examples, the ergonomics is quite good. :)
04:25:18 <merijn> dminuoso: the Haddocks are just 15 pages of type gobbledy-gook, though
04:25:19 * hackage imm 2.0.0.0 - Execute arbitrary actions for each item from RSS/Atom feeds  https://hackage.haskell.org/package/imm-2.0.0.0 (koral)
04:26:11 <dminuoso> merijn: Bringing me back to my original point, we should get rid of all that JSON nonsense.
04:26:19 <fendor> dminuoso, also, why are they using fromKey instead of atKey? atKey seems to be simpler
04:26:29 <dminuoso> Just specify and write wire protocols, like programmers have done for the past 30 years.
04:26:47 <dminuoso> a bit of `binary` works wonders
04:26:50 <merijn> dminuoso: Or use dhall :)
04:27:01 <dminuoso> Oh, for configuration sure.
04:27:22 <dminuoso> For data exchange, if I had to pick a premade serialization format again, I'd go cbor.
04:27:29 <merijn> but yeah, a good BNF + wire protocol >> poorly implemented shit on top of JSON
04:27:47 <dminuoso> Indeed.
04:28:06 <nshepperd> @hackage serialize
04:28:06 <lambdabot> https://hackage.haskell.org/package/serialize
04:28:27 <dminuoso> nshepperd: I think you were looking for cereal?
04:28:28 <merijn> binary has pretty much obsoleted serialise, tbh
04:28:34 <nshepperd> oop misspelt
04:28:36 <merijn> eh, yeah cereal I mean
04:28:51 <nshepperd> @hackage serialise
04:28:51 <lambdabot> https://hackage.haskell.org/package/serialise
04:28:56 <dminuoso> I mean, cereal was made because binary was lacking support for strict bytestrings?
04:29:05 <dminuoso> binary supports both lazy and strict bytestrings now
04:29:15 <dminuoso> has good support for adding contexts
04:29:26 <nshepperd> serialise is cbor based, very nice imo
04:30:48 <dminuoso> nshepperd: serialise seems great if you want to do data exchange between two haskell systems over the network.
04:31:14 <merijn> template-haskell versions are tied to specific GHCs, right?
04:31:30 <dminuoso> https://hackage.haskell.org/package/template-haskell
04:31:35 <dminuoso> merijn: Judging from the bounds, Id say now
04:31:38 <dminuoso> *no
04:31:43 <dminuoso> base (>=4.11 && <4.15), ghc-boot-th (==8.10.1), ghc-prim, pretty (==1.1.*) [details]
04:31:47 <nshepperd> i also use it for serialising cached stuff to disk between runs of the same program
04:34:04 <tomjaguarpaw> I can't help thinking that what's important is the logical structure of the wire format rather than its concrete structure.
04:35:18 <tomsmeding> merijn: https://github.com/haskellweekly/haskellweekly/pull/52
04:42:12 <kuribas> Uniaika: don't you need (.:?) ?
04:42:28 <kuribas> Uniaika: it returns a Maybe for a field that can be possibly null.
04:42:45 <Uniaika> I found a way, actually
04:43:12 <Uniaika> solving the issue upstream, and not deriving the instance for the type, but taking care of serde in the upstream type
04:43:22 <Uniaika> (it does work)
04:43:24 <kuribas> that's even better :)
04:43:38 <Uniaika> thank you all for your time, I love you all, you're incredible <3
04:44:09 <kuribas> Uniaika: although I think your case match is a good way BTW...
04:44:22 <kuribas> because it clearly shows you want exclusive or.
04:44:27 <merijn> Anyone know how to avoid "redundant import" warnings for "Data.Monoid ((<>))" on GHC >8.2 in a way that doesn't break GHC 8.0-8.2
04:44:44 <Uniaika> merijn: I'm going to say the bad word but…
04:44:45 <Uniaika> CPP?
04:49:24 <kuribas> CPP :)
05:07:19 * hackage termonad 4.0.1.1 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-4.0.1.1 (cdepillabout)
05:09:41 <merijn> I just got rid of all the CPP :(
05:11:09 <Uniaika> I know, I know…
05:14:05 <merijn> hmm, a change in examples probably doesn't warrant a new release
05:17:13 <kuribas> merijn: do you know a better way to deal with breaking changes?
05:17:18 <kuribas> like the semigroup stuff
05:17:30 <merijn> kuribas: There's usually a migration guide with GHC
05:17:41 <kuribas> merijn: which recommends cpp...
05:17:58 <merijn> And the rule is that backwards compat for 3 releases should be possible without CPP
05:23:18 <hekkaidekapus> dminuoso: After some light sleuthing, the OutsideIn algorithm seems to be implemented as described in the paper, more or less. I would succinctly answer this to your original question: no matter how involved a method’s constraints are, the solving will boil down to generating implicits and using them as evidence.
05:26:00 <dminuoso> hekkaidekapus: Fair enough, the reason Im asking is, Ive been staring at a mail on haskell-cafe for so long, Im starting to think there's a bug in the instance selection algorithm.
05:26:41 <dminuoso> Where GHC selects an instance despite overlapping instances existing.
05:27:15 <dminuoso> The video though I think helped, since it explained roughly how the constraint checking on instances with context works.
05:27:21 <tomjaguarpaw> dminuoso: The Wrapper (Maybe a) mail?
05:27:25 <dminuoso> tomjaguarpaw: Yeah.
05:27:31 <tomjaguarpaw> I was also puzzled by that.
05:27:48 <hekkaidekapus> dminuoso, tomjaguarpaw: link?
05:28:43 <tomjaguarpaw> https://mail.haskell.org/pipermail/haskell-cafe/2020-October/132815.html
05:28:50 <hekkaidekapus> Thanks.
05:29:20 * hackage hwk 0.5 - Commandline text processing with Haskell functions  https://hackage.haskell.org/package/hwk-0.5 (JensPetersen)
05:32:24 <dminuoso> % newtype Foo = Foo Int; instance {-# OVERLAPS #-} Show (Maybe Foo) where show _ = "foo"
05:32:24 <yahb> dminuoso: 
05:32:32 <dminuoso> % newtype W a = W (Maybe a); instance Show a => Show (W a) where show (W a) = show a
05:32:32 <yahb> dminuoso: 
05:32:35 <dminuoso> % foo :: Show a => W a -> String; foo a = show a
05:32:36 <yahb> dminuoso: 
05:32:38 <dminuoso> This should be rejected.
05:32:49 <dminuoso> (Unless IncoherentInstances was enabled)
05:34:04 <dminuoso> % foo' :: Show a => Maybe a -> String; foo' a = show a
05:34:04 <yahb> dminuoso: ; <interactive>:9:47: error:; * Overlapping instances for Show (Maybe a) arising from a use of `show'; Matching instances:; instance Show a => Show (Maybe a) -- Defined in `GHC.Show'; instance [overlap ok] [safe] Show (Maybe Foo) -- Defined at <interactive>:5:50; instance [overlap ok] [safe] Show (Maybe Ghci4.Foo) -- Defined at <interactive>:1:50; (The choice depen
05:34:23 <ClaudiusMaximus> % foo (W Nothing) -- just checking what happens at point of use
05:34:23 <yahb> ClaudiusMaximus: "Nothing"
05:35:59 <ClaudiusMaximus> % foo (W (Just (Foo 1))) -- just checking what happens at point of use
05:36:00 <yahb> ClaudiusMaximus: ; <interactive>:11:1: error:; * No instance for (Show Foo) arising from a use of `foo'; * In the expression: foo (W (Just (Foo 1))); In an equation for `it': it = foo (W (Just (Foo 1)))
05:36:06 <dminuoso> It seems, that the deferring the constraint `Show (Maybe a)` changes how instance is selected.
05:36:54 <dminuoso> If that was the case, it could imply that GHC falsely generates incoherent code.
05:37:34 <dminuoso> I tried debugging the type checker with a minimal program, but -ddump-tc-trace generated 5k lines of output..
05:37:42 <dminuoso> The manual did *not* lie when it said it would be real chatty.
05:38:52 <dminuoso> I think, if nobody else does it, Ill file a bug report. Either the GHC manual is incorrect, or GHC is buggy. One has to be the case here.
05:39:19 <merijn> Time for everyone's daily reminder of the invaluable service of packdeps having an RSS feed when you need to bump your package bounds ;)
05:40:00 <merijn> dminuoso: pfft, you're missing an alternative
05:40:05 <merijn> dminuoso: They could *both* be wrong :p
05:40:32 <dminuoso> merijn: Im confident that its not the case, the instance selection algorithm descriped in the overlapping instances section seems rather clear.
05:43:07 <hekkaidekapus> dminuoso: I’m looking at the corresponding Core before drawing conclusion. <https://paste.tomsmeding.com/aHILkhin>
05:43:20 <hekkaidekapus> *conclusions
05:44:04 <dminuoso> hekkaidekapus: Mind my asking, what is Core gonna tell you?
05:44:21 <hekkaidekapus> The dictionary passing.
05:47:30 <dminuoso> $cshow1_rX8
05:48:18 <dminuoso> Internally, it picked dShow2_aV5 = $fShowMaybe $dShow1_aUS
05:49:24 <dminuoso> Despite another, equally good, dictionary, existing: $cshow_rWA
05:49:50 <hekkaidekapus> Yeah, file a bug report!
05:50:23 <hekkaidekapus> Overlapping instances considered harmful anyway :0
05:59:17 <dminuoso> hekkaidekapus: The one thing Im not quite sold on, is this:
05:59:20 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-overlap
05:59:47 <dminuoso> At the bottom it does mention that FlexibleInstances can lead to incoherent instance selection, but Im not immediately seeing whether this is related
06:06:53 <hekkaidekapus> dminuoso: The bulb seems pretty related, but I would file the report still. It might be a short-lived ticket but we will have an up-to-date explanation as to “An alternative possible behaviour, not currently implemented…”.
06:08:52 <dminuoso> hekkaidekapus: Well, it's not really related because the incoherence arises from making a *more* specific instance in another module, and then run an instance selection in both modules.
06:09:56 <dminuoso> But yeah, I filed a bug report. At the very least the GHC manual should be improved if this is not an instance selection bug.
06:10:25 <hekkaidekapus> 👍
06:52:49 * hackage Z-IO 0.1.5.2 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.5.2 (winterland)
07:00:07 <merijn> btw, does anyone know of any working human cloning programs? >.>
07:02:06 <merijn> I was clicking through some dependencies and I'd like to order some backup phadej's ahead of time so the ecosystem doesn't grind to a halt without him >.>
07:03:21 <dminuoso> merijn: Well, we should get an ekmett along side. They could grow up together.
07:03:36 <phadej> dminuoso: ekmett is cloned already: RyanGlScott
07:03:49 <dminuoso> Haha. :)
07:03:51 <juri_> merijn: i've spent almost 7 years working on 3d printing in haskell. unfortunately,  i'm falling apart faster than i can print.
07:04:09 <dminuoso> juri_: Hold on, 3d printing in haskell?
07:04:11 <dminuoso> tell me more.
07:04:26 <merijn> Ah, but see, edwardk is just inventing cool new stuff, plenty of volunteers for that
07:04:36 <phadej> merijn: order two copies (hopefully you can a discount) of hvr too
07:04:50 <juri_> dminuoso: implicitcad. hslice. modeling and slicing natively in haskell. badly, because there is only one of me.
07:04:51 <phadej> could get a discount*
07:05:04 <merijn> Less volunteers for turning duct tape and string into semi-solid engineering foundations :p
07:05:10 <dminuoso> juri_: How good is your slicing of human models?
07:05:14 <juri_> I don't have hslice on hackage yet.
07:05:29 <juri_> dminuoso: poor. i'm still working on simple geometric shapes.
07:05:54 <merijn> phadej: And maybe an SPJ ;)
07:06:05 <juri_> worse, i decided halfway through to change everything to projective geometric algebra, so hslice has a PGA engine embedded in it.
07:06:37 <dminuoso> merijn: Soon we're gonna need a clone of Stephanie Weirich as well to keep the cogs in dependent haskell going.
07:06:53 <merijn> I'm not sure I'm happy with those cogs :p
07:06:59 <phadej> isn't Richard kind of a mixture of both?
07:07:29 <dminuoso> 16:05:32          merijn | phadej: And maybe an SPJ ;)
07:07:40 <dminuoso> Luckily for us, SPJ did reproduce already.
07:08:34 <dminuoso> juri_: What is PGA?
07:08:54 <tomjaguarpaw> projective geometric algebra, presumably
07:09:32 <akegalj> &quit
07:09:40 <juri_> it's a high performance / high precision algebra system for doing geometry in. takes less operations to do stuff, and uses pure forms of objects, rather than approximations.
07:10:15 <akegalj> ;'\[]
07:10:20 <dminuoso> Does that require the input to be in some PGA format as well?
07:10:29 <dminuoso> Or can an arbitrary CAD output be fed into that?
07:12:03 <juri_> it uses STLs.
07:12:18 <juri_> which coincidentally are what implicitcad outputs.
07:18:09 <fendor> can I generate a module graph with some tool?
07:18:17 <merijn> "yes"
07:18:26 <merijn> But now you're gonna ask which one, aren't you? >.>
07:18:28 <dminuoso> fendor: `cabal-plan dot --tred`
07:18:39 <dminuoso> (the --tred is not required, but probably desirable)
07:18:52 <dminuoso> And then the usual graphviz tools. :)
07:19:07 <dminuoso> Oh wait. module graph
07:19:09 <dminuoso> mmm
07:19:19 <dminuoso> graphmod?
07:19:37 <fendor> merijn, :P well, preferably
07:20:02 <fendor> dminuoso, looks good
07:22:49 * hackage effet 0.3.0.0 - An Effect System based on Type Classes  https://hackage.haskell.org/package/effet-0.3.0.0 (MichaelSzvetits)
07:24:17 <fendor> dammit, I have multiple Types modules that almost everyone depends on
07:24:31 <merijn> fendor: As always :p
07:24:33 <fendor> dminuoso, thanks, beautiful tool!
07:24:41 <merijn> I wish GHC would just get proper cyclic imports
07:25:35 <dminuoso> merijn: I recall a length discussion at dinner with a few of the GHC folks.
07:26:12 <dminuoso> Dont think it's ever gonna happen. :p
07:26:22 <merijn> Which is a travesty!
07:27:28 <merijn> I demand my convenience! :(
07:30:49 * hackage gi-gtksheet 4.0.1 - GtkSheet bindings  https://hackage.haskell.org/package/gi-gtksheet-4.0.1 (ivanbakel)
07:49:14 <blip> Is it possible to have enum on the type level? data X = A | B | C | D; foo :: Proxy [A..D]
07:49:25 <merijn> blip: Yes!
07:49:45 <blip> I've got a quite large datatype and I'd like to avoid TH and copy pasting
07:49:47 <merijn> blip: Although this is a path that *can* lead to incredibly painful code in the long term, so be warned :p
07:49:54 <merijn> oh, wait
07:49:58 <ocharles> Does anyone know if `build-tool-depends` should be putting executables in PATH for the relavant components when I use Cabal with Distribution.Simple.defaultMain? Because I'm not seeing that
07:49:59 <merijn> You mean the syntax
07:50:20 <ocharles> The documentation for build-tool-depends writes: Cabal tries to make sure that all specified programs are atomically built and prepended on the $PATH shell variable before building the component in question, but can only do so for Nix-style builds
07:50:31 <merijn> blip: You could write a type family that computes that list?
07:50:32 <ocharles> But I don't know if a Setup.hs counts as Nix-style or old style
07:50:45 <merijn> ocharles: Setup.hs is lower level
07:50:54 <merijn> Setup.hs is Cabal (not cabal-install)
07:51:12 <blip> merjin: how would that work without writing explicitly every inhabitant?
07:51:37 <blip> my data has about ~100 promoted constructors
07:51:44 <merijn> ocharles: And most likely no one knows the answer :p
07:52:13 <merijn> blip: eh...I'd probably recommend "not doing that", but that's not very constructive :)
07:52:29 <merijn> blip: And now you know why the original paper was called Hasochism ;)
07:52:43 <merijn> blip: Maybe you can do something horrific using singletons?
07:52:54 <bahamas> ocharles: if I remember right, the nix builder for cabal relies on Setup.hs. but it's been a while
07:53:12 <merijn> <MS Clippy>Did you mean to use Idris?</MS Clippy>
07:53:44 <blip> merijn: I already contemplated screwing kind-safety and convert my constructors in a bunch of Symbol
07:54:23 <merijn> blip: Once your type-safety involves "100s of type level constructors" I don't think it passes any sensible "cost-benefit analysis"
07:54:35 <merijn> Compile times will be a massive pain, as will refactoring >.>
07:55:45 <blip> merijn: Yeah, it's quite a bit excessive
07:55:57 <blip> mirijn: 1000LOC type-level  https://github.com/knupfer/type-of-html/blob/master/src/Html/Type/Internal.hs
07:56:18 <merijn> For *HTML*? >.>
07:56:19 * hackage ad 4.4.1 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.4.1 (ryanglscott)
07:56:30 <blip> merijn: better safe than sorry :)
07:56:36 <ocharles> merijn: I feared that might be the case >.<
07:56:42 <merijn> Jesus Christ
07:56:44 <ocharles> bahamas: well, it will write its own if there isn't one
07:56:57 <merijn> That module probably takes 5 million years to compile
07:57:25 <blip> It's actually not bad
07:57:51 <blip> But using the library gives ghc a sweat
07:58:01 <merijn> I wonder why >.>
07:58:20 <blip> not because of the type checker
07:58:31 <blip> the simplifier goes absolutely nuts
08:00:06 <blip> Or is there a type level function which does something like      type family ToSymbol x where ToSymbol Banana = "Banana"
08:00:38 <blip> Like show, but with symbols
08:10:22 <blip> Perhaps it would be possible with generics? I'm recalling vaguely that it's possible to retrieve the constructors at the type level
08:10:34 <blip> constructor names
08:11:02 <merijn> blip: Out of curiosity, have you ever read any Lovecraft novels/stories?
08:11:22 <blip> merijn: No, why do you ask?
08:11:50 <merijn> Because this path will lead you to the same fate as any of his protoganists :p
08:12:18 <merijn> i.e. gibberingly mad and insane after staring into the Eldritch horrors of the universe :)
08:12:30 <Taneb> merijn: sometimes that can be very fun
08:13:06 <blip> Well, considering that haskell is just a little hobby of mine I can only gibber mad and insane in my free time
08:13:24 <blip> At work, I'm at the receiving end (music teacher)
08:14:02 <merijn> Sounds like "The Music of Erich Zann" would be an appropriate recommendation :p
08:14:33 <blip> I like Dr Faustus and The Expanse
08:14:49 <blip> And mediaeval treaties about music theory
08:16:08 <blip> I.E. :  (3/2)^12 /= 2^7 ==> modern music sucks
08:19:39 <c_wraith> of course, for m, n > 0, (3/2)^m /= 2^n
08:19:59 <blip> yeah, but these numbers are quite special
08:20:11 <c_wraith> You can't have perfect fifths and perfect octaves uniformly across the scale.  You have to decide what to give up.
08:20:38 <blip> yes, that's the point
08:20:50 <c_wraith> that's not "modern music sucks" that's math.
08:21:25 <blip> Well, Pythagoras at least claims that beautiful interval are simple rationals
08:21:57 <blip> so the modern fith (2^(5/12)) wouldn't please him
08:22:13 <merijn> But Pythagoras is dead, so we win!
08:22:48 <blip> I don't claim that I use exclusively Pythagoras taste to determine my taste
08:23:08 <blip> But it's interesting to change ones point of view
08:23:46 <blip> oops: not 2^(5/12), it's 2^(7/12)
08:24:48 <jil> hi
08:25:04 <blip> hi jil
08:25:39 <blip> jil: do you prefer perfect fiths or equidistant semitones?
08:25:44 <blip> :)
08:26:17 <monochrom> 2^(1/2) wouldn't please him either. It's still irrational.
08:26:18 <jil> I'm learning Haskell with "Programming in Haskell" 2nd edition..
08:26:38 <blip> Nice, can we help you?
08:27:00 <blip> monochrom: Yes
08:27:03 <monochrom> You know what, s/It's still/He's/  >:)
08:27:04 <jil> what a perfect fith or an equidistant semitone ?
08:28:01 <jil> It would bother me If I was rational, not you ?
08:28:10 <blip> monochrom: He'd use (3/2)^7 minus some octaves for a semitone
08:29:50 <blip> jil: that is a quite modern stance
08:30:57 <blip> jil: don't be confused, we're just smalltalking about historic music theory
08:31:18 <gentauro> kindaro: Torben wrote back and it is Jon Sporing who currently is wrote/maintain the material. Torben say that you should write Jon an e-mail and ask (nicely) if you can have a copy :-)
08:32:29 <jil> blip: I was confused.  Thank you.
08:33:32 <blip> jil: So, can we help you on your journey to enlightenment?
08:33:53 <blip> (regarding haskell)
08:34:44 <blip> merijn: Thanks for the recommendation, that's quite intresting
08:35:15 <blip> merijn: The descriptions of this literature reminds me of Kafka
08:40:49 <jil> I think listing your smalltalking is already helping me a lot.  But I was also wondering if the construct `add x  = x :: Int` with the type coercing at the end, was recent because I don't see it in my manual (from 2016) but it work in GHCi 8.6.5
08:41:18 <ski> it's not a coercion, but a type ascription
08:41:32 <blip> Ah, yes. In the MetaData of Generic Rep are the constructor names as Symbols. All I need now, is a type level function which converts camel case Symbols into hyphenated lowercase Symbols. That's a challenge but possible :)
08:41:39 <ski> (it doesn't change the type of anything, it just specifies (pins down) what the type should be)
08:41:40 <monochrom> It is not recent. Just unidiomatic.
08:41:52 <ski> and yes, it's standard Haskell. was in Haskell98 already
08:42:00 <jil> thank you for the correction ski I wasn't sure about the vocabulary indeed.
08:42:43 <blip> jil: normally, you would write:
08:42:52 <ski> no worry, clearing up terminological (and sometimes conceptual) misalignments can often be useful, when communicating
08:42:58 <blip> `add x :: Int -> Int`
08:43:08 <ski> (without the `x')
08:43:20 <blip> oops
08:43:50 <blip> and propably `add :: Int -> Int -> Int`, magmas are cool
08:44:16 <jil> what are magmas ?
08:44:26 <ski> jil : it can sometimes be useful to have them, if there's a type ambiguity problem (the system has trouble figuring out which specific type you intend, somewhere in your code)
08:44:38 <blip> all functions which take two arguments of the same type and return something of that type
08:44:47 <blip> `magma :: a -> a -> a`
08:44:58 <blip> addition or multiplication for example
08:45:03 <ski> "magma" is a concept in math (abstract algebra) for a binary operation on a set/type
08:46:22 <ski> blip : why're they cool ?
08:47:12 <jil> I see.
08:47:13 <blip> ski: I like them a lot; you can define nice operators and a lot of things are magmas
08:47:29 <blip> ski: Or would you prefer them described as hot?
08:47:36 <blip> :)
08:47:37 <ski> usually you'd want a few laws, i think
08:48:08 <ski> sure, if you have a magma, you automatically gets an operation taking a binary tree with leaves being elements in the magma, to an element in the magma
08:48:24 <blip> and that is nice
08:49:11 <blip> for example (<>) is quite nice, obviously it's even a monoid, but a lot of the niceness comes from the magma part
08:49:23 <blip> or semigroup
08:51:31 <ski> with semigroup, you have associativity, so you can combine a sequence of elements into a single element, and get the same result, regardless of how you group the elements in the sequence
08:52:08 <monochrom> That means magmas are freer than semigroups. :)
08:52:31 <blip> jil: How would you implement this signature:   `slurp :: (a, b) -> a`
08:52:46 <blip> monochrom: :)
08:52:55 <ski> i guess you have a free functor from magmas to semigroups
08:54:43 <jil> as `slurp (x,y) = x` blip
08:55:07 <blip> jil: cool, and what about: barf :: a -> (a, b)
08:58:09 <jil> I'm looking for a definition with the flowing type `add :: Int -> Int -> Int -> Int` and I come up with this https://paste.debian.net/1166987 but I feel something is correct.
08:58:15 <jil> or not necessary
08:59:32 <ski> what do you mean by "flowing type" ?
08:59:37 <jil> more precisely I don't understand why removing the first `:: Int` make a fucntion returning `Num a` also I have x, y z Ints
08:59:39 <ski> @type let add x y z = x+y+z::Int where x :: Int; y :: Int; z :: Int in add
08:59:39 <monochrom> Write "add :: Int -> Int -> Int -> Int" instead of the "where x::Int etc" block. That block means something else.
08:59:40 <lambdabot> error:
08:59:41 <lambdabot>     The type signature for ‘x’ lacks an accompanying binding
08:59:41 <lambdabot>       (The type signature must be given where ‘x’ is declared)
09:00:02 <blip> jil: it's correct, albeit unusual
09:00:07 <monochrom> ski, I think s/flowing/following/
09:00:13 <ski> oh
09:00:23 * ski sometimes fails to read typo :/
09:00:47 <blip> jil: you'd need only the top level type signature, all the other types are infered
09:01:16 <ski> @let add x y z = (x :: Int) + (y :: Int) + (z :: Int) :: Int
09:01:16 <jil> sorry ski, I'm unfortunately very good at writting typos.
09:01:19 <lambdabot>  Defined.
09:01:30 <monochrom> I trained myself to guess meanings from very large contexts when I was a child. Because I was too lazy to look up a word in a dictionary, I would rather guess an approximation from context.
09:01:39 <ski> is possible, if you really want to write it like that (but it's not idiomatic, as noted)
09:02:15 <jil> ok.  Thank you.
09:02:28 <ski> @let add (x :: Int) (y :: Int) (z :: Int) = x + y + z :: Int
09:02:30 <lambdabot>  Defined.
09:02:31 <merijn> blip: Eh, the top level is inferred too
09:02:35 <merijn> blip: Everything is inferred
09:02:57 <merijn> You'll just get lynched by angry programmers if you don't annotate the top level :p
09:03:02 <ski> is another, similar, way (imho looks better). but it's still unidiomatic. and this one requires a language extension (`ScopedTypeVariables')
09:03:28 <ski>   add :: Int -> Int -> Int -> Int
09:03:32 <ski>   add x y z = x + y + z
09:03:34 <jil> @let add (x :: Int) (y :: Int) = x + y
09:03:35 <lambdabot>  .L.hs:157:1: error:
09:03:35 <lambdabot>      Equations for ‘add’ have different numbers of arguments
09:03:35 <lambdabot>        .L.hs:157:1-55
09:03:37 <ski> is the usual way to write it
09:03:47 <blip> @pl \x y z -> x + y + z
09:03:48 <lambdabot> ((+) .) . (+)
09:03:54 <dolio> If you don't annotate the top level you're probably going to end up hating yourself, eventually.
09:03:55 <ski> sorry, let me remove the earlier definition for you
09:03:58 <ski> @undefine
09:03:59 <lambdabot> Undefined.
09:04:06 <ski> @let add (x :: Int) (y :: Int) = x + y
09:04:08 <lambdabot>  Defined.
09:04:10 <ski> @type add
09:04:11 <lambdabot> Int -> Int -> Int
09:04:36 <blip> add = ((+) .) . (+) :: Int -> Int -> Int -> Int
09:04:38 <blip> :P
09:04:39 <jil> I see.  It's clearer like that. Thank you.
09:05:00 <dolio> At least if you write anything non-trivial.
09:05:06 <jil> :)
09:06:23 <ski> @let add (x :: Int) (y :: Int) (z :: Int) :: Int = x + y + z  -- too bad this doesn't work, anymore ..
09:06:23 <lambdabot>  Parse failed: Cannot give an explicit type signature to a function binding
09:08:13 <ski> jil : "more precisely I don't understand why removing the first `:: Int` make a fucntion returning `Num a` also I have x, y z Ints" -- i suppose you mean the (first) `:: Int', in the paste
09:09:21 <jil> yes
09:09:25 <ski> if you just say `add x y z = x + y + z', then it infers that `x',`y',`z' (and the result `x+y+z') must be of "numeric type", meaning some type that supports `+' (and a few other operations). that is what the `Num a =>' part means : works for all types `a', provided that `a' supports the `Num' operations
09:09:42 <ski> @src Num
09:09:42 <lambdabot> class Num a where
09:09:42 <lambdabot>     (+), (-), (*)       :: a -> a -> a
09:09:42 <lambdabot>     negate, abs, signum :: a -> a
09:09:42 <lambdabot>     fromInteger         :: Integer -> a
09:10:55 <jil> sure but I was understanding the `where x :: Int...` as a restriction or condition on my arguments' type
09:10:56 <ski> (note that this doesn't include division. if you (also) want division, you'll have to say whether you want integral (with remainder) division, or fractional division. instead of `Num', you'd then use `Integral' or `Fractional')
09:11:47 <blip> these arguments are restricted by the top level type signature
09:12:16 <blip> or by the return type, because the (+) forces the same type on both sides and for the result
09:12:40 <ski> jil : when i try the first section of code in the paste (inbetween the `{:' and the `:}'), i get errors for missing bindings (definitions) for `x',`y',`z'
09:12:59 <ski> (i'm not sure how you're trying this piece of code, without getting errors)
09:13:44 <kuribas> is there an applicative for records?  Positional arguments can be come quite unwieldy and unreadable...
09:13:52 <jil> I evaluate in from org-mode  in emacs that sends it to ghci
09:13:59 <ski> jil : generally, if you put `someName :: SomeType', e.g. in a `where'-clause attaching to a definition, there should also be a definition of `someName' in there
09:14:10 <kuribas> hmm, maybe applicative-do...
09:14:36 <blip> kuribas: perhaps you'd like to use lensesd
09:14:38 <blip> lenses?
09:14:50 <kuribas> blip: how do lenses help with applicative?
09:15:01 <ski> so, i'm getting complaints, because there's no definition of `x',`y',`z', accompanying those type signatures for them, inside that `where'
09:15:27 <blip> blip: to select which part of the record you'd like to act upon
09:15:30 <ski> (since `x',`y',`z' are not bound in the `where', but rather in the patterns / formal parameters, to the left of the `=', in the defining equation)
09:15:48 <kuribas> blip: but I need to act on all parts
09:15:58 <ski> jil : hm. maybe it does something unexpected, not sure
09:16:12 <blip> kuribas: well, if they are all of the same type, you can derive a functor instance
09:16:18 <ski> (it being `org-mode', or perhaps some more particular mechanism invoked by it)
09:16:22 <kuribas> blip: like MyRecord <$> field1 <*> field2 <*> field3
09:16:29 <kuribas> but with field names instead of positions
09:17:05 <blip> kuribas: well, what about record updates?
09:17:15 <kuribas> perhaps applicative do: do a <- field1; b <- field2; c <- field3; MyRecord {..}
09:17:36 <kuribas> blip: record updates aren't a problem
09:17:59 <kuribas> blip: my question isn't about record updates.
09:18:12 <kuribas> it's about doing an applicative on a record.
09:18:47 <blip> well, what you propose would work (adding a pure to the last line)
09:18:52 <kuribas> yeah
09:18:56 <ski> jil : in any case, the normal way to specify the types of function arguments is to provide a type signature for the whole function (normally before the function definition), like `add :: Int -> Int -> Int -> Int' (also specifying the result type)
09:19:10 <jil> also when I :load a script with `add (x :: Int) (y :: Int) (z :: Int) = x + y + z :: Int` directly from ghci I get an error. https://paste.debian.net/1166990/  illegal type signature 'Int'
09:20:00 <geekosaur> because it's trying to do a pattern signature which is an extension (it should have said something about ScopedTypeVariables)
09:20:01 <jil> why is that ?
09:20:08 <blip> kuribas: but also quite dangerous, you can easily construct an incomplete record
09:20:09 <ski> jil : yes. as i mentioned (in brief) above, using that style (having `:: Int' in the formal parameters / patterns) is a language extension. try placing the following line as the first line in your script :
09:20:09 <jil> yes it does.
09:20:18 <ski>   {-# LANGUAGE ScopedTypeVariables #-}
09:20:21 <geekosaur> ski just told you the correct way to specify a function signature
09:20:32 <jil> ok.
09:20:35 <kuribas> blip: wouldn't that generate a warning?
09:20:58 <ski> (if you want to play around with this style of ascribing types also to patterns, not just to expressions, that is)
09:21:01 <blip> kuribas: I think yes with -Wall
09:21:41 <kuribas> blip: I can turn a warning in an error, can't I?
09:21:56 <blip> kuribas: yes, -Werr
09:22:37 <kuribas> ah -Werror=⟨wflag⟩
09:22:48 <blip> yep
09:22:52 <jil> ski geekosaur ok. I had not understood what you meant by `a language extension`.  It's clear know and my script works.
09:23:15 <kuribas> strange haskell is so loose with undefined fields
09:23:24 <kuribas> IMO it should be an error
09:23:46 <ski> ditto for missing methods ?
09:23:51 <blip> there is a lot of undefined
09:23:57 <blip> what about head?
09:24:00 <kuribas> ski: that's an error right?
09:24:08 <dolio> No.
09:24:14 <ski> @let data Foo = MkFoo; instance Num Foo
09:24:16 <lambdabot>  .L.hs:160:10: error: [-Wmissing-methods, -Werror=missing-methods]
09:24:16 <lambdabot>      • No explicit implementation for
09:24:16 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, ‘fromInteger’, and (either ‘negate’
09:24:28 <blip> :)
09:24:29 <monochrom> missing methods and undefined values are dynamic errors, not static errors.
09:24:37 <ski> lambdabot doesn't like it, since it has `-Werror=missing-methods'
09:24:39 <kuribas> ah you mean missing instance methods...
09:24:50 <kuribas> indeed, that should be an error IMO
09:25:12 <blip> > head []
09:25:14 <lambdabot>  *Exception: Prelude.head: empty list
09:26:14 <blip> we need `-Werror=undefined`
09:26:19 <ski> jil : you understand how to "line up" the arguments in `add x y z = x + y + z' with the types in `add :: Int -> Int -> Int -> Int' (or even `add :: Num a => a -> a -> a -> a'), yes ?
09:27:05 <kuribas> I find partial functions are always a mistake, because you don't get a good error message.
09:27:20 <blip> like (/)
09:27:50 <blip> :: Rational
09:28:24 <kuribas> yeah
09:29:28 <monochrom> Perhaps you can accept a compromise? Partial functions/values with the HasCallStack constraint are not static errors; without, are static errors.
09:30:28 <blip> I have to go, the abyss of promoted constructors is calling my name
09:30:51 <dolio> I write good errors in my partial functions. :)
09:35:49 * hackage prolens 0.0.0.0 - Profunctor-based lightweight implementation of optics  https://hackage.haskell.org/package/prolens-0.0.0.0 (shersh)
09:44:13 <maerwald> A language with no partial functions seems like a pain in the *ss. You don't really care about partial functions, you care about your program being total.
09:45:50 * ski . o O ( preconditions & postconditions )
09:46:36 <monochrom> inb4 Sapir-Whorf
09:56:56 <Cheery> bucklescript translates the partial functions away.
09:58:10 <Cheery> I'm curious about that because it means that on partial parameters they're constructing a closure that fills in the partial.
09:59:15 <Cheery> also if you have function like a → b, if the 'b' turns out to be a function, then the parameters cannot be fused anyway.
10:01:07 <Cheery> nobody cares as long as they're not exposed in a library interface. That'd be interesting subject on its own.
10:09:18 <monochrom> That sounds like you mistook partial function for partial application.
10:09:50 <Cheery> you're right.
10:12:30 <Cheery> But then got opinion on that as well. I think I like the approach where you tag the partial functions.
10:16:26 <Cheery> I might also do that for recursive functions.
10:22:46 <Cheery> fix :: Fix a => (a → a) → a
10:35:49 * hackage matterhorn 50200.10.3 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.10.3 (JonathanDaugherty)
11:02:49 * hackage rescue 0.3.0 - More understandable exceptions  https://hackage.haskell.org/package/rescue-0.3.0 (expede)
11:24:24 <romildo> Is there an irc channel for haskell-mode/lsp-haskell with emacs?
11:31:57 <ski> romildo : try here or maybe in #emacs ?
11:33:48 <romildo> Is there a key binding to insert in the text the inferred type of a variable in a equation?
15:08:34 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
15:08:34 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
15:12:23 <kupi> hi. in ghci ":module + Data.Ratio" and "import Data.Ratio" are equivalent?
15:13:24 <monochrom> Yes
15:34:20 * hackage fourmolu 0.3.0.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/fourmolu-0.3.0.0 (GeorgeThomas)
16:02:41 <kupi> in ghci how to undo ":set +t"?
16:03:08 <hpc> use :unset
16:03:17 <hpc> see also, :help
16:05:50 * hackage formatting 7.1.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  https://hackage.haskell.org/package/formatting-7.1.0 (AlexChapman)
16:19:11 <crestfallen> hi please assist me going through this unification exercise. It's from SO and someone here helped me earlier though I still don't understand a few things, for starters: how g is both g :: c -> b -> a    and    g :: d -> c
16:19:17 <crestfallen> https://github.com/varreli/haskell/blob/master/handEval/unify_f_g_h.txt
16:20:34 <hpc> type variables can unify with other type variables
16:20:41 <hpc> they're placeholders with names
16:20:57 <hpc> imagine (+) :: Num a => a -> a, and (+) :: Num b => b -> b
16:21:14 <Axman6> unary plus++
16:21:35 <hpc> whoops, you know what i mean
16:21:46 <hpc> anyhoo
16:22:12 <hpc> when you look at g :: c -> b -> a, it's actually g :: c -> (b -> a)
16:22:32 <hpc> and if you put that side by side with g :: d -> c
16:22:52 <hpc> then you have the left (->) lining up with the only (->)
16:23:02 <hpc> and c = d, and c = (b -> a)
16:23:33 <hpc> or well, upper c = lower d, upper (b -> a) = lower c
16:23:35 <crestfallen> hpc thanks one moment
16:25:09 <crestfallen> hpc what is the logic behind assigning the whole expression to a on line 3
16:25:51 <Axman6> you just need a name for the result of the whole expression, and that type will be the ultimate return type of f
16:26:15 <hpc> ^ that
16:26:26 <hpc> the expression has a type, you just haven't figured out what it is yet
16:26:26 <Axman6> f :: ? -> ?? -> ??? -> ???? -> a
16:26:29 <hpc> but you can give it a name
16:26:38 <hpc> and that name is a, because why not
16:27:49 <hpc> as you dig deeper into the expression you build constraints on what a can actually be
16:27:53 <hpc> and then you unify those constraints
16:28:16 <hpc> it's essentially solving a system of equations
16:28:43 <crestfallen> yeah thanks ok so the g on line 11 is the g in (g x) getting expanded, right?
16:29:52 <crestfallen> then the g on line 14 is the leftmost g in the expression
16:31:30 <hpc> something like that, that part's weirdly written
16:31:39 <hpc> but yeah, you're building constraints from two different applciations of g
16:32:12 <crestfallen> hpc which part? pls explain why it's weird and better alternative
16:33:44 <crestfallen> There's this algorithm W in ghci, I'd like to understand this aspect of haskell
16:35:23 <hpc> just that i can't tell which g is which, but to be fair, i am not reading this paste very carefully, most of explaining this is kind of autopilot for me at this point :P
16:39:58 <crestfallen> hpc it came from this SO : https://stackoverflow.com/questions/50777884/manual-type-inference-in-haskell/50778324     
16:40:25 <crestfallen> it goes on to assign y :: e
16:42:02 <crestfallen> I see e in these unifying exercises: does that mean partial application like (-> e) or something?
16:58:07 <proofofme> do y'all know any good Haskell bindings for MapBox?
17:02:52 <crestfallen> so if we infer that g :: a ~ (c -> e)     is e used just as a symbol for an unknown type?
17:03:01 <crestfallen> hpc Axman6  ?
17:06:17 <Axman6> sure, you can make up your own variable names any time you want
17:08:58 <crestfallen> Axman6: thanks thats a convention I guess, like a placemarker until you figure out what it is?
17:09:12 <crestfallen> e, that is..
17:13:34 <crestfallen> also how do we know that " by inspection, we know that c and d are equivalent " in     g :: c -> b -> a    and    g :: d -> c      ..? 
17:32:40 <Axman6> because g can only have one type, so c -> (b -> a) ~ d -> c', therefore c ~ d
17:32:51 <Axman6> and b -> a ~ c'
17:36:30 <crestfallen> copy that Axman6 hpc thanks so much . not easy with such a abstract func. definition.
17:37:52 <dnlkrgr> could all Haskell syntax extensions be represented as template haskell packages instead?
17:38:18 <Axman6> well, most of them are syntactic, so there wou;dn't be much point
17:39:22 <Axman6> if I had to write [NumericUnderscores|0b1100_1010_0011_0101|] I'd be unhappy (technically a quasi quote but similar)
17:40:31 <dnlkrgr> right the ergonomics are worse,  I think the cool thing would GHC development is not burdened by such extensions and users could just get a package instead of waiting for a new GHC version
17:41:19 <dnlkrgr> and I guess one is limited by what the AST offers, no new stuff
17:42:16 <monochrom> This seems to presuppose that most GHC extensions are merely syntax sugars over Haskell 2010.
17:42:24 <solonarv> GHC plugins would be a better approach than TH packages for a lot of extensions
17:42:35 <solonarv> and that idea has indeed been floated a few times
17:43:13 <monochrom> What would [RankNTypes | f :: (forall a. a->a) -> (Int, Bool); f g = (g 1, g True) ] desugar to, if after desugaring you're stuck with rank-1 Haskell 2010?
17:43:25 <crestfallen> so say with join, we don't know the monad being used, so we use e , such as in       m = (->) e      
17:43:35 <crestfallen> join :: (->) e ((->) e a) -> ((->) e) a
17:43:39 <dnlkrgr> right, plugins might be the way to go
17:43:41 <dolio> I think the answer is just, "no."
17:44:29 <crestfallen> Axman6: is that the same way e was being used in the unify exercise? 
17:44:41 <solonarv> plugins still don't quite work for (many) extensions that add new syntax, but that could in theory be fixed with a better plugin API
17:45:09 <monochrom> My bad, I did not read "syntax extensions".
17:49:00 <crestfallen> s
18:04:46 <amf> in `data T = A | B` what would the A and B be called? cases? 
18:05:38 <Axman6> constructors
18:05:56 <Axman6> "constructors of type T" 
18:46:29 <dsal> A friend just sent me a web page that had some haskell code on it and it never occurred to me that you could infix constructors.
18:46:40 <dsal> @let data XY = XY Int Int deriving Show
18:46:42 <lambdabot>  Defined.
18:46:47 <dsal> > 1 `XY` 2
18:46:49 <lambdabot>  XY 1 2
18:48:06 <monochrom> There is more.
18:48:22 <monochrom> @let data MN = Int `MN` Int deriving Show
18:48:23 <lambdabot>  Defined.
18:48:28 <monochrom> > MN 1 2
18:48:30 <lambdabot>  1 `MN` 2
18:48:56 <monochrom> The derived Show instance respects which syntax you used at "data" time. :)
18:49:37 <monochrom> This also applies to "data C = Double :+ Double" vs "data C = (:+) Double Double"
18:51:07 <monochrom> If you also derive Generic, the meta information about the constructor also tells you prefix vs infix according to which syntax you used in the "data" line.
18:51:42 <monochrom> (So that for example you can perfecting duplicate the behaviour of "deriving Show".)
18:51:51 <monochrom> s/perfecting/perfectly/
18:54:09 <dsal> Oh wow.
18:54:29 <dsal> It's the little things.
22:14:49 * hackage citeproc 0.1.0.1 - Generates citations and bibliography from CSL styles.  https://hackage.haskell.org/package/citeproc-0.1.0.1 (JohnMacFarlane)
22:41:19 * hackage hasql-dynamic-statements 0.3.1 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.3.1 (NikitaVolkov)
23:46:19 * hackage stm-incremental 0.1.0.0 - A library for constructing incremental computations  https://hackage.haskell.org/package/stm-incremental-0.1.0.0 (sgschlesinger)
23:48:49 * hackage stm-incremental 0.1.0.1 - A library for constructing incremental computations  https://hackage.haskell.org/package/stm-incremental-0.1.0.1 (sgschlesinger)
