00:56:51 <dminuoso> Mmm, I've been pondering about whether a SelectiveDo notation makes sense.
00:57:19 <dminuoso> One of my annoyances with selective functors has been the ergonomics since you can't use do expressively
00:58:38 <dminuoso> Though things are bearable if you use `branch` a lot, such that code looks a bit if/then/else-y
02:59:47 <maerwald> ApplicativDo was a mistake imo, SelectiveDo won't be any better
03:02:01 * hackage in-other-words 0.1.1.0 - A higher-order effect system where the sky's the limit  https://hackage.haskell.org/package/in-other-words-0.1.1.0 (KingoftheHomeless)
03:04:15 <merijn> ApplicativeDo is to complicated
03:05:00 <Rembane> What's the syntax for ApplicativeDo? Left arrows?
03:06:53 <Kolkrabe> It's the usual do-notation, IIRC
03:08:37 <merijn> Rembane: Do syntax, but with voodoo black magic deciding if it works or you get a type error
03:10:07 <Rembane> merijn: That sounds like something I don't want in a programming language. 
03:10:30 <[exa]> Rembane: some people hate the applicative .. <$> .. <*> .. <*> .. noodles
03:10:44 <dminuoso> Rembane: Well, think of it as a freebie.
03:10:52 <dminuoso> Consider the use case of haxl
03:11:09 <dminuoso> You get the expressivity of monadic code, but with automatic parallelization whenever possible
03:11:22 <dminuoso> If you dont want it, you get no automatic parallelization
03:12:03 <lortabac> maybe they should have added an explicit keyword for ApplicativeDo
03:12:04 <Rembane> [exa]: I love them! :) 
03:12:14 <Rembane> dminuoso: That is a very good point though. 
03:13:35 <[exa]> they overloaded `do` instead of using `doA` or something?
03:13:48 <lortabac> [exa]: yes
03:13:52 <[exa]> I hoped that people have learned from `mdo`
03:15:12 <dminuoso> Introducing new keywords is very unpopular in GHC.
03:15:23 <dminuoso> It causes friction every time
03:15:55 <[exa]> lucky we have pretty nice isolated extensions!
03:16:07 <[exa]> ( :] )
03:16:20 <Uniaika> hmm, I think there will be an extension for having Selective do without RebindableSyntax 
03:16:27 <Uniaika> damnit, I can't recall its name
03:16:38 <dminuoso> If there is, Id be very curious what the ergonomics is
03:16:59 <dminuoso> Is it a sort of modified case-of?
03:17:03 <dminuoso> a kind of `applicative-case-of`?
03:17:35 <dminuoso> (That seems to be the only way that can make sense)
03:20:44 <dminuoso> Such that you could do `let s :: Parser (Either L R); s = ...; in caseS s of Left x -> ...; Right x -> ...;
03:21:02 <Uniaika> dminuoso: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0216-qualified-do.rst
03:21:08 <Uniaika> it's QualifiedDo!
03:21:27 <Uniaika> and here is the MR https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3436
03:21:28 <dminuoso> Uniaika: I recall that, but Im not sure whether it could help at all
03:21:41 <dminuoso> Selective requires a case-of version, rather than a do version
03:22:01 <dminuoso> But case-of has no RebindableSyntax to speak of
03:22:20 <dminuoso> Or rather a weird cross between `case of` and `(>>=)`
03:22:30 <[exa]> +1 ^
03:22:31 <dminuoso> Without guards?
03:23:27 <[exa]> they kindof "made sure this works" with having the Either type in the paper (so that a->b branch "must" be executed) but it would clearly help if the whole patternmatching mechanism was supported
03:23:45 <dminuoso> [exa]: Except you can rig the same type signature with just Applicative
03:23:51 <dminuoso> So the type signature alone is not strong enough
03:24:41 <[exa]> still kindof thinking how's the select useful in the common case when the decision trees don't really terminate
03:26:03 <merijn> [exa]: The Selective Functor paper is pretty goood :)
03:26:09 <[exa]> yeah reading it now
03:26:18 <Uniaika> yes it's a good read
03:26:51 <dminuoso> Im still hoping parsley will become a thing some day
03:26:53 <Uniaika> as a follow-up and concrete implementation, there is also : https://github.com/kowainik/validation-selective
03:27:07 <dminuoso> https://github.com/J-mie6/ParsleyHaskell
03:27:13 <dminuoso> It's still being developed on
03:27:43 <Uniaika> hi kuribas :)
03:28:07 <[exa]> dminuoso: is there any read on parsley?
03:28:25 <dminuoso> [exa]: There was a presenstation on Haskell eXchange 2018
03:28:39 <dminuoso> But I think the skillcasts are not publically available unless you bought a ticket
03:28:53 <dminuoso> (Or was it 2019?)
03:29:08 <[exa]> dminuoso: can you sum it up in like 1 sentence? I can read through the code but you know... :D
03:29:35 <dminuoso> [exa]: So selective is a cross between monad and applicative. You get dynamic choise based on previous results, but static analyzability.
03:29:47 <dminuoso> The idea is to build a parser optimizer in template haskell using that knowledge.
03:30:04 <kuribas> Uniaika: hey :)
03:30:05 <dminuoso> Where TH would probe and dissect your parser, and transform it
03:30:21 <[exa]> dminuoso: ooh okay
03:30:50 <[exa]> I don't like the TH part but it makes sense for sure
03:31:37 <dminuoso> Im not sure whether it still uses TH, but I think the demo used it
03:32:24 <dminuoso> TH at least would avoid some external tooling that you need to glue into the build process
03:33:08 <dminuoso> In a perfect world this would probably be a compiler plugin
03:34:00 <[exa]> like the point with TH is that it's getting back to bison-ish parser processors agaon
03:34:27 <[exa]> *again
03:34:27 <dminuoso> except you get to describe your parser with your beloved parser combinators
03:34:46 <dminuoso> *and* get the benefits of the parser generator generating a better performing parser
03:34:56 <dminuoso> (or perhaps even detect parser bugs)
03:35:43 <[exa]> shift-reduce conflicts yay!
03:35:47 <dminuoso> external tool I think is very unlikely, because of multiple modules, language extensions, etc..
03:36:01 * hackage modern-uri 0.3.3.0 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.3.3.0 (mrkkrp)
03:36:04 <dminuoso> so I think TH and compiler plugin are your only options
03:36:14 <dminuoso> Unless you offload the parser combinator into a haskell-like DSL
03:36:31 <[exa]> anyway you still cannot use the old-fashioned patternmatch or if in the parser b/c it wouldn't get caught by Selective, right?
03:36:42 <dminuoso> Sure you can
03:37:04 <dminuoso> selective just wouldnt know about it, and assume both effects can happen
03:37:27 * [exa] puzzled now
03:37:27 <dminuoso> superficially it'd just see:
03:37:39 <dminuoso> branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
03:37:46 <dminuoso> branch f g h
03:37:55 <[exa]> oh the ifs are rewritten by TH?
03:37:56 <dminuoso> and know that these three effects can all happen
03:38:04 <dminuoso> no, the structure on selective itself
03:38:06 <dminuoso> think
03:38:19 <[exa]> sorry I'm probably missing something important
03:38:19 <dminuoso> imagine this was written in a Free fashion
03:38:32 <dminuoso> with Monad you couldnt realistically go in and manipulate much
03:38:36 <dminuoso> (even if its a free monad)
03:38:44 <dminuoso> thta is, manipulate without changing the meaning
03:39:03 <dminuoso> the core issue is
03:39:06 <dminuoso> % :t (>>=)
03:39:07 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
03:39:20 <[exa]> yeah, you can get new effects from "environment"
03:39:27 <[exa]> (with monads)
03:39:39 <dminuoso> Is an optimization barrier. To optimize into >>= it would require GHC to analyze the function itself, leading very quickly to halting problems
03:40:00 <dminuoso> or not just optimization, but introspection
03:40:11 <dminuoso> consider optparse-applicative otoh, which can statically give you informatoin about the parser structure
03:40:15 <dminuoso> it can tell you exactly what flags are possible
03:40:43 <[exa]> yeah that's understood, that is impossible with (Appl|Select)ives
03:40:47 <dminuoso> but optparse applicative does not have the power to say "if you first specify -f, then we accept another flag -g, otherwise we accept -h in additoin"
03:41:19 <dminuoso> selective gives you that power, while allowing the tooling to analyze and tell you `-f/-g/-h` are possible
03:41:42 <dminuoso> so some optparse-selective could give you dynamic choices, while maintaining the analyzability to generate help pages from
03:41:49 <dminuoso> the reason is
03:41:55 <[exa]> oh I get it now sorry
03:42:01 <dminuoso> if it sees `branch f g h`, then it knows all `f, g and h` are possible
03:42:37 <dminuoso> equivalent to how `(,,) <$> f <*> g <*> h` lets you know that all `f, g and h` are possible
03:42:39 <[exa]> the confusion was that I somehow expected that you could have 2 branches of code that are switched by a simple 'if' (outside of selective) but that's impossible b/c you don't have >>= to extract the boolean
03:43:12 <dminuoso> Right, the branching in selective functors is constrained to `select/branch`
03:43:29 <dminuoso> Which is why I said that the equivalent to do-notation would be some version of `case-of`
03:43:36 <dminuoso> So instead of saying
03:43:48 <dminuoso> `branch f (branch g h i) j k`
03:43:51 <dminuoso> you might be able to say
03:44:05 <typetetris> Whats a small server side rendering web framework to look at?
03:44:19 <dminuoso> caseS f of G -> ...; H -> ...; I -> ...; J -> ...
03:44:24 <typetetris> Especially for creating easy links between pages.
03:44:43 <dminuoso> Where caseS is a "sort-of" constrained version of bind
03:45:24 <dminuoso> But such a thing would require some first-class way of specifying generic pattern matching
03:46:03 <dminuoso> typetetris: you can just use servant or scotty?
03:46:32 <[exa]> hm, lenses? `caseS :: [ (Prism ... , sel) ] -> sel -> sel`
03:47:16 <typetetris> dminuoso: now you mention it, there is a link creating function in servant?
03:47:44 <dminuoso> typetetris: Mmm, perhaps you could concoct such a thing yourself?
03:48:03 <dminuoso> Add some type combinator to tag endpoints
03:48:04 <[exa]> typetetris: I used scotty and just made a small function that gave the correct link to given routes
03:48:23 <dminuoso> Such that you can say `Tag "foo" :> "foo" :> Get '[] NoContent`
03:48:35 <[exa]> typetetris: if I got it correctly you basically want to make sure that rendered html anchors match what's in routing?
03:49:03 <[exa]> dminuoso: anyway thanks for explanation :]
03:49:16 <dminuoso> And then pull out the route through some `getUrl :: (KnownSymbol k, MonadFail m) => Proxy k -> m Url`
03:49:23 <dminuoso> With some magic machinery that needs to be written
03:49:39 <typetetris> [exa]: yes
03:49:47 <dminuoso> That would be some real type tetris right there.
03:49:59 <merijn> dminuoso: Please make optparse-selective so I won't have to ;)
03:50:08 <typetetris> dminuoso: I knew, I need to change my nickname some time ... :(
03:50:26 <dminuoso> typetetris: I think it should be quite possible, in fact.
03:50:33 <dminuoso> ANd useful
03:50:42 <typetetris> dminuoso: I think it is already there :)
03:51:57 <[exa]> merijn: hopefully that could finally allow the global options leaking to subparsers :]
03:52:08 <dminuoso> typetetris: https://hackage.haskell.org/package/servant-0.16.2/docs/Servant-Links.html
03:52:12 <merijn> [exa]: That's already fixed, I think?
03:52:18 <[exa]> merijn: O_O
03:52:27 <dminuoso> typetetris: Would that work for you?
03:52:32 * [exa] opens docs
03:52:53 <merijn> [exa]: https://github.com/pcapriotti/optparse-applicative/issues/294
03:53:13 <typetetris> dminuoso: I will take a look at it.
03:53:32 <[exa]> merijn: w o n d e r f u l
03:53:45 <dminuoso> Personally, I'd try very hard to avoid yesod. I'd take any pain to get links with servant instead :p
03:53:46 <merijn> [exa]: It's even on hackage already :)
03:54:45 <typetetris> What is that selective thing you are talking about?
03:55:01 * hackage mu-schema 0.3.1.1 - Format-independent schemas for serialization  https://hackage.haskell.org/package/mu-schema-0.3.1.1 (AlejandroSerrano)
03:56:19 <[exa]> merijn: are there any code changes required? (I'm on optparse 0.16)
03:56:23 <merijn> typetetris: Selective functors
03:56:38 <merijn> [exa]: The changelog has some stuff on how to enable it
03:56:46 <dminuoso> Ah what I wouldnt give for "disabling the type system" for just a moment, so I could build [1,[2,3,4],5,6,[7,8]] and flatten it...
03:56:47 <[exa]> great, thanks
03:56:48 <merijn> or disable? I don't remember
03:56:52 <dminuoso> Is there any cool tricks to build lists like that?
03:57:25 <merijn> typetetris: https://hackage.haskell.org/package/selective
03:57:38 <merijn> typetetris: See the paper linked in the docs for an explanation of the niche it fills
04:00:33 <[exa]> back to selectives...this sounds like a great way to describe DFAs (and regexes)
04:03:46 * [exa] takes a huge melting pot and combines alternative+selective
04:09:57 <[exa]> merijn: anyway it's off by default, enabled by `prefs $ subparserInline <> helpShowGlobals`, thanks a lot!
04:12:11 <Uniaika> dminuoso: not that I know of :/
04:12:25 <Uniaika> except maybe building your own AST of values and operating on it
04:15:32 * hackage mu-protobuf 0.4.0.1 - Protocol Buffers serialization and gRPC schema import for Mu microservices  https://hackage.haskell.org/package/mu-protobuf-0.4.0.1 (AlejandroSerrano)
04:16:06 <dminuoso> Well, Im just using a slightly modifivation of Writer
04:16:30 <dminuoso> newtype ListW e a = ListW { unListW (Writer [e] a) }
04:16:44 <dminuoso> with some putE :: e -> ListW e (); putEs :: [e] -> ListW e ();
04:17:26 <dminuoso> So I can do `execList $ do { putE a; putEs bs; putE c; putE; d; putEs es }`
04:19:35 <Uniaika> that's uh… that's a way to do it indeed :D
04:21:57 <dminuoso> an alternative is just `[a] <> bs <> [c] <> [d] <> es` and align it nicely vertically
04:22:05 <dminuoso> Perhaps Ill just do that and not care 
04:23:01 * hackage megaparsec 9.0.1 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-9.0.1 (mrkkrp)
04:24:01 * hackage megaparsec-tests 9.0.1 - Test utilities and the test suite of Megaparsec  https://hackage.haskell.org/package/megaparsec-tests-9.0.1 (mrkkrp)
04:43:43 <dexterfoo> i am using:  cabal v2-build  how can i see which versions of dependencies are being used?
04:44:43 <dminuoso> dexterfoo: you can use cabal-plan
04:53:20 <kuribas> dminuoso: I think you want DList?
04:54:31 <kuribas> https://hackage.haskell.org/package/dlist
04:54:54 <kuribas> which is basically Endo
04:54:57 <kuribas> :t Endo
04:54:58 <lambdabot> (a -> a) -> Endo a
04:57:32 <kuribas> DList creates a tree internally, then you flatten it to a list
04:57:41 <kuribas> in linear time
05:15:24 <merijn> dexterfoo: That depends why you wanna know :p
05:16:51 <merijn> If the reason is, say, "because I wanna get a reproducible configuration" then the answer is "you probably want (v2-)freeze"
05:28:19 <dminuoso> Mmm. Im starting to approach 150k lines of Haskell code for this library..
05:28:36 <dminuoso> Compilation times are getting worse every day...
05:29:52 <dminuoso> All for the sake of type safety. I should have build this codec library with runtime dictionaries, and some Dynamic sprinkling.
05:40:03 <__monty__> Is this a single-person codebase?
05:43:59 <dminuoso> Yes.
05:44:02 <dminuoso> code generated
05:44:24 <dminuoso> If I went the Dynamic route, this would probably be a 500-1000 lines thing
05:50:23 <tomsmeding> I'm waiting for the day when ghc can meaningfully compile modules of a single package in parallel with speedup factor actually reasonably close the number of threads
05:50:37 <tomsmeding> that day I shall be happy
05:57:45 <merijn> tomsmeding: The parallelism there is limited by the dependency graph of your modules
05:58:04 <tomsmeding> I know, I have extensive experience with building makefiles ;)
05:58:19 <tomsmeding> currently ghc doesn't even try though
05:58:48 <tomsmeding> the -j option only compiles a single module using multiple threads, I think, and I find that to give marginal to no speedup in practice
05:59:22 <tomsmeding> running multiple ghc's in parallel with 'make' suffers from lots of ghc overhead I'm told, though I actually haven't tried that recently...
05:59:38 <tomsmeding> (and also doesn't play nice with cabal and friends)
06:00:02 <merijn> Well, there's Shake ;)
06:13:19 <tomsmeding> that replaces the 'make' in my messages above, doesn't it?
06:31:11 <bahamas> can you handle multiple patterns differently in a lambda?
06:31:39 <geekosaur> not without an explicit case
06:31:54 <geekosaur> (or lambdacase, I guess)
06:35:43 <bahamas> I see
07:10:03 <maerwald> I'm also not too pleased with our syntactic options there
07:10:42 <maerwald> but if you use multiwayif...
07:19:32 * hackage mmsyn2 0.3.1.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.3.1.0 (OleksandrZhabenko)
07:30:38 <texasmynsted> I was reading about haskell deployments and the article talked about upx to compress the executable. It looks like a win. Does anybody here use it for their haskell deployments?
07:30:41 <texasmynsted> https://upx.github.io
07:33:54 <merijn> texasmynsted: I think upx is a terrible and dumb idea
07:34:02 <texasmynsted> lol why?
07:34:04 <merijn> texasmynsted: What, exactly, do you expect to win by it?
07:34:31 <maerwald> upx sometime breaks binaries, depending on the algorithm
07:34:38 <texasmynsted> faster deployments because the executable is smaller. Take up less space on the server.
07:34:45 <texasmynsted> Hmm.
07:34:48 <merijn> texasmynsted: Is that really a problem, though?
07:35:01 <maerwald> I wouldn't trust anything that comes out of it. Is there any proof that it's the same binary?
07:35:07 <merijn> texasmynsted: How big are your binaries that this is a significant bottleneck?
07:35:09 <texasmynsted> not one worth breaking binaries over
07:35:29 <merijn> texasmynsted: If you want smaller binaries trying using --enable-split-sections and stripping the binary first
07:36:01 * texasmynsted reads about --enable-split-sections
07:36:04 <merijn> Especially split sections, which can have an order of magnitude shrink if you have tons of dependencies
07:36:15 <merijn> (it does mean you'll have to rebuild everything first :))
07:36:24 <texasmynsted> If I had to choose, I would rather have a faster binary than a smaller one
07:37:23 <merijn> texasmynsted: Basically, split sections lets you only like relevant portions of your dependencies. So if you only use 1 or 2 functions from, say, lens and lens was compiled with split-sections you pull only a fraction of lens' compiled code into your executable
07:37:47 <merijn> In terms of "impact per effort" it's probably the lowest fruit for Haskell binaries (together with stripping)
07:38:16 <texasmynsted> wow, why is this not the default?
07:38:46 <merijn> texasmynsted: Because older linkers don't support it and only made it into GHC fairly recently (a few years ago I recent to me!)
07:38:55 <texasmynsted> ah okay
07:38:58 <texasmynsted> Thank you.
07:39:07 <merijn> Safer to make it "opt in" then risk breaking toolchains
07:39:35 <texasmynsted> I need to find a ghc news site or something so I can learn these tricks
07:39:40 <merijn> texasmynsted: I would say if binaries are smaller than, say 20 MB it's not worth any effort to go smaller (and even for biggers ones it might not be worth it)
07:40:03 <maerwald> well, GHC is already hard to get working on systems that don't have ld.gold
07:40:06 <merijn> texasmynsted: I recommend skimming the very good and often overlooked GHC user guide every so often and reading the release notes for new GHCs
07:40:14 <merijn> @where userguide
07:40:14 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
07:40:17 <maerwald> so not sure backwards compat is hat important
07:41:15 <merijn> texasmynsted: haskell-cafe, haskell-libraries and ghc-devs mailing lists are also a good way to keep an eye on things, they're not that high traffic
07:41:38 <merijn> And lurking in #ghc of course :p
07:45:21 <texasmynsted> :-)
07:45:24 <texasmynsted> Thank you
07:45:31 * hackage snap-server 1.1.2.0 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.1.2.0 (GregoryCollins)
07:45:52 <merijn> But yeah, release notes for new features and the user guide are the most instructive usually
07:46:15 <merijn> texasmynsted: Like, there's an entire section on runtime tweaking and speeding up stuff that I think 80% of people aren't aware off
07:46:23 <merijn> (and getting smaller binaries!)
07:46:30 <texasmynsted> I am reading that now actually
07:46:47 <texasmynsted> (I did not look for, or know it existed before)
07:58:17 <tomsmeding> (reading section 9 in the ghc user's guide...)
07:58:19 <tomsmeding> "One time when Float might be a good idea is if you have a lot of them, say a giant array of Floats. They take up half the space in the heap compared to Doubles. However, this isn’t true on a 64-bit machine."
07:58:59 <tomsmeding> this reminds me of the discussion here yesterday(?) aobut Word types in ghc all being 8 bytes long due to their definition being e.g. 'data Word8 = Word8 #Word'
07:59:06 <tomsmeding> s/#Word/Word#/
07:59:25 <tomsmeding> is this the same kind of thing with Float/Double? That sounds stupid
07:59:41 <dolio> Even on 32-bit, they're more than half if boxed.
08:01:16 <tomsmeding> okay true, boxing reduces space saving, but then with boxing all space bets are off anyway
08:01:47 <__monty__> Hmm, angerman just said something about Word sizing in #ghc, so *maybe* there's work towards changing that?
08:02:17 <dolio> Apparently there is a Word8#, but Word8 doesn't use it.
08:02:37 <angerman> Yes. Word8 = W8# Word8#, Int8 = I8# Int8# is coming.
08:02:52 <tomsmeding> ah! neat stuff
08:03:12 <dolio> I'm not sure how big Word8# actually is, though. There's also Float# that Float actually uses, so it might actually be smaller than Double, unless alignment makes that not happen.
08:03:47 <tomsmeding> Float# adjacent to Float# should theoretically not induce any padding for alignment
08:03:59 <angerman> it's just really annoying to get it in. It's necessary for apple silicon support, as arm64 (that's aarch64 in fruity speak) has a rather funky procedure calling convention for C, where it packs function arguments by their size on the stack.
08:04:03 <tomsmeding> (at least, extrapolating from C :p)
08:04:10 <dolio> I think that'd be the idea.
08:04:20 <angerman> So if you FFI into something it needs to be 4byte int32 on the stack, not just 8bytes for every arg.
08:04:50 <tomsmeding> ah of course this is one of the many things pushed by the ARM work you are doing angerman :)
08:19:18 <tomsmeding> in a simple test, an unboxed array from Data.Array.UArray with Floats indeed takes ~4*num_elements bytes of memory, whereas the same with Doubles takes ~8*num_bytes of memory
08:21:20 <tomjaguarpaw> I'm trying to build stm from source https://github.com/haskell/stm. The testsuite has a bound base < 4.14 so I can't configure it.  What's going on?
08:22:55 <merijn> tomjaguarpaw: the main package only had its dependency bumped a month ago, so maybe they forgot to bump the testsuite?
08:23:07 <tomjaguarpaw> Ah, I'll try just doing that.
08:23:14 <merijn> CI isn't testing 8.10 yet either
08:23:18 <tomjaguarpaw> How would I build /without/ the test suit, in any case?
08:23:25 <tomjaguarpaw> I tried --disable-tests
08:25:41 <dolio> The cabal file doesn't actually have a test suite.
08:26:02 <tomjaguarpaw> I think it's pulled in by cabal.project
08:26:05 <merijn> dolio: There's a testsuite + cabal file in the testsuite directory and cabal.project pulls it in
08:26:57 <dolio> Right, so you should build only the stm package, probably.
08:28:53 <tomjaguarpaw> How would I do that? cabal v2-build stm doesn't seem to work.
08:28:58 <tomjaguarpaw> Nor does cabal v2-build .
08:29:04 <tomjaguarpaw> I'm not sure what the incantation is
08:29:24 <merijn> Just comment out the two lines in cabal.project? :p
08:33:06 <dolio> Possibly `.:stm` would work. I'm not super familiar with the syntax for specifying things.
08:34:54 <angerman> tomsmeding: I think it's also going to possibly provide some foundation for SIMD optimisations; let's see.
08:41:58 <tomsmeding> that would be very nice, more optimisations is always a good thing
08:44:31 * hackage polysemy-fskvstore 0.1.0.0 - Run a KVStore as a filesystem in polysemy.  https://hackage.haskell.org/package/polysemy-fskvstore-0.1.0.0 (locallycompact)
08:47:42 <mananamenos> hi, `f a b $ f c d $ f w z` is there a way rewrite this this call in some way so that `f` appears once only/
08:48:24 <mananamenos> `f a b $ f c d $ f w z []`, sorry, meant to write this
08:48:33 <__monty__> (\g -> g a b $ g c d $ g w z []) f
08:49:18 <dminuoso> mananamenos: Can you share a bit more context perhaps?
08:50:38 <dminuoso> `f a b (f c b (f w z))` looks like a list, so a recursion scheme could fit.
08:52:16 <mananamenos> dminuoso, just playing with concepts..yes you're probably right, it is recursion scheme that would fit best 
08:52:26 <merijn> Or just uncurry + map
08:52:37 <merijn> ah, no, not quite
08:52:44 <dminuoso> uncurry + foldr
08:52:52 <dminuoso> or, rather curry + foldr
08:52:56 <dminuoso> uh
08:53:01 <merijn> :t uncurry
08:53:02 <lambdabot> (a -> b -> c) -> (a, b) -> c
08:53:06 <dminuoso> I always mix them up
08:53:11 <merijn> same
09:01:58 <mananamenos> thanks
09:13:01 <giorgoskos> any hacker here?
09:16:29 <ghoulguy> giorgoskos, yes, how can I help you?
09:16:48 <giorgoskos> i need someone to help me to hack someone facebook
09:17:24 <Uniaika> wtf
09:18:24 <giorgoskos> any help?
09:18:36 <ghoulguy> giorgoskos, ah OK. You're on the wrong network.
09:18:56 <giorgoskos> were i go?
09:19:10 <ghoulguy> giorgoskos, try Google
09:19:24 <giorgoskos> and?
09:19:28 <ghoulguy> and search
09:19:44 <giorgoskos> i found this site for hacks
09:19:48 <giorgoskos> on google
09:19:53 --- mode: ChanServ set +q *!*@79.130.40.161
09:19:54 <monsterchrom> "We are not a directory service either."
09:21:27 <monsterchrom> I inflicted shift/reset on my students today. They are now thoroughly turned inside-out.
09:21:54 <monsterchrom> I also caught a chance to say "now we shift gear to..."
09:24:57 <koz_> Not gonna lie - I didn't get shift/reset until I saw their Cont-based type sigs.
09:25:09 <koz_> Then I was like 'oh, so _that's_ what they do, huh'.
09:25:25 <dolio> Which ones?
09:26:13 <texasmynsted> sigh Haskell cafe keeps telling my my email address is invalid. Oh well. 
09:27:16 <Uniaika> texasmynsted: oh?
09:27:23 * texasmynsted shrug
09:27:25 <texasmynsted> yes
09:27:39 <monsterchrom> Today I showed Racket's shift/reset.  But I think I will have a chance to show Haskell's Cont and runCont next month.
09:27:47 <texasmynsted> May try another day. 
09:30:57 <koz_> dolio: https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html#v:reset and https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html#v:shift
09:32:30 <dolio> koz_: Oh, those aren't the good ones. :Þ
09:33:04 <dolio> The good ones are `reset :: Cont r r -> r` and `shift :: ((a -> r) -> r) -> Cont r a`
09:33:05 <monsterchrom> "shift = ContT" is the good one :)
09:33:16 <monsterchrom> err, shift = Cont
09:33:20 <dolio> Yeah.
09:33:50 <monsterchrom> http://www.vex.net/~trebla/haskell/cont.xhtml#shift-reset
09:34:02 <monsterchrom> but it may be better to start from the beginning.
09:34:05 <dolio> They show you how the effect scoping works in the types.
09:34:46 <monsterchrom> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html for more confusion :)
09:37:02 <dolio> ContT is fine, too. It's incorporating other effects.
09:40:11 <dolio> I haven't really thought about it, but you might be able to make sense of multi-prompt continuations that way, with multiple ContTs.
09:41:06 <monsterchrom> I think sigfpe or you or someone else wrote a blog on that.
09:41:23 <monsterchrom> but the limitation is it is statically scoped prompts, not dynamic prompts.
09:41:43 <monsterchrom> Then again dynamic prompts can be error-prone like all dynamic things.
09:42:29 <texasmynsted> monsterchrom: I would like to see your presentation on Haskell's Cont. Will it be available online?
09:49:19 <dexterfoo> hSeek gives error "invalid argument" when trying to seek more than approx 16 TB. (15TB or less works). is this a known bug?
09:49:39 <texasmynsted> Okay, I do not know why this is bothering me but . . . I have a String. It may contain a '/' as its last character. I am testing for this by reversing the string and pattern matching '/': _ -> 
09:50:33 <texasmynsted> This seems bad because while the strings will never be infinite, reverse feels like an unnecessary expense. Is there a better way?
09:51:26 <kuribas> texasmynsted: nope
09:51:32 <geekosaur> last str == '/' ?
09:51:33 <kuribas> or don't use String, use Text
09:51:53 <monsterchrom> texasmynsted: http://www.vex.net/~trebla/haskell/cont.xhtml
09:51:55 <koala_man> is it a directory? if so, don't bother and just concatenate to form foo//bar
09:51:57 <kuribas> there is no way to avoid traversing the String
09:52:26 <monsterchrom> "Extra credit for getting it to run on an Apple II or a Commodore 64" >:)
09:52:47 <texasmynsted> koala_man: It is a URL, but I only need to add index.html if the last character is /
09:54:06 <koala_man> if it's a URL you should probably use a proper URL parser. Consider e.g. https://example.com/?id=42#bar
09:54:33 <texasmynsted> `last` requires that the string be non-empty. Pattern matching would avoid that restriction.
09:55:45 <texasmynsted> I will look for a URL parser. 
09:56:44 <dexterfoo> never mind, it seems that hSeek detects the filesystem of the handle and gives "invalid argument" error when trying to seek past the maximum supported file size
09:57:24 <texasmynsted> The final output has to be String, so using Text to preform the test seems like I may pay more
10:00:07 <monsterchrom> Use both null and last if the string may be empty.  Or write your own recursion.
10:02:35 <tomjaguarpaw> [__1] skipping: base-4.14.0.0 (has the same characteristics that caused the
10:02:35 <tomjaguarpaw> previous version to fail: excluded by constraint '^>=4.13.0' from
10:02:36 <tomjaguarpaw> 'haddock-api')
10:02:55 <tomjaguarpaw> ^^ does that make sense to anyone?  ^>=4.13.0 surely matches 4.14.0 doesn't it?
10:05:14 <texasmynsted> thank you monsterchrom
10:05:20 <geekosaur> I thought the leading ^ meant it didn't (makes it follow PVP, so 4.14 is out of scope for 4.13)
10:06:15 <texasmynsted> if the string is empty it does not require manipulation, so the _anythingElse part of the pattern match is fine
10:09:58 <tomjaguarpaw> geekosaur: Oh, is that what it means
10:10:01 <tomjaguarpaw> Thanks
10:17:31 * hackage phonetic-languages-plus 0.1.0.0 - Some common shared between different packages functions.  https://hackage.haskell.org/package/phonetic-languages-plus-0.1.0.0 (OleksandrZhabenko)
10:25:06 <Kingpatzer> hey folks, quick (i hope) and likely dumb question: I just
10:25:06 <Kingpatzer>                    started worknig through cis194 and I would like to print
10:25:06 <Kingpatzer>                    out the results from the "testWhatWentWrong" function as
10:25:06 <Kingpatzer>                    one string per line. Some google fu got me to "mapM_
10:25:06 <Kingpatzer>                    putStrLn [String]" but that fails with an error because
10:25:07 <Kingpatzer>                    testWhatWentWrong returns IO [String] and not plain
10:25:07 <Kingpatzer>                    [String]. Anyway I can accomplish just printnig each
10:25:07 <Kingpatzer>                    string on it's own line?
10:25:18 <Kingpatzer> oops, sorry about that, pasting didn't work as intended
10:25:20 <ghoulguy> Kingpatzer: please do not paste into your IRC client
10:26:57 <tomsmeding> Kingpatzer: 'testWhatWentWrong >>= mapM_ putStrLn' perhaps? or using do-notation, 'do result <- testWhatWentWrong ; mapM_ putStrLn result'
10:28:15 <Kingpatzer>  that worked tomsmeding. thanks!
10:33:05 <tomsmeding> Kingpatzer: both mean exactly the same thing; >>= is what do-notation "desugars" (converts) to intermally
10:33:36 <tomsmeding> you use >>= to "continue" your program having access to the value within the monad, here IO
10:34:11 <tomsmeding> (hooks in nicely in the discussion of continuations just now...)
10:35:18 <monsterchrom> For IO we write in callback style. Do you "extract the answer". Supply a callback that receives the answer.
10:35:35 <monsterchrom> or even s/that receives/to receive/
10:35:56 <monsterchrom> http://www.vex.net/~trebla/haskell/IO.xhtml
10:36:17 <monsterchrom> OTOH CIS194 would not have you dabble in IO without first teaching you this.
10:37:14 <monsterchrom> It's pure effectless functional programming for the first 70% at least.
10:37:39 <tomsmeding> as it should be
10:41:30 * hackage uniqueness-periods-vector-general 0.5.2.0 - Some kind of the optimization approach to data inner structure.  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.5.2.0 (OleksandrZhabenko)
10:50:22 <mantovani> exit
11:03:31 * hackage uniqueness-periods-vector-examples 0.14.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.14.0.0 (OleksandrZhabenko)
11:20:01 * hackage uniqueness-periods-vector-examples 0.14.1.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.14.1.0 (OleksandrZhabenko)
12:10:51 <joel135> What are the most important haskell libraries to know?
12:11:46 <maerwald> unix
12:12:05 <yushyin> base?
12:13:25 <geekosaur> mtl?
12:15:21 <monsterchrom> What kind of question is that?
12:15:52 <monsterchrom> If it's for a job interview tomorrow, it's already too late.
12:16:05 <joel135> I don't know if it was a good question.
12:16:33 <monsterchrom> It is a poor question. Only exam crammers would need to know.
12:16:36 <maerwald> It's something you'd say on a dating app if you matched with a haskeller... so to get their attention
12:17:04 <dsal> joel135: The most important haskell libraries to know are the ones that you use the most when building code to do the thing you care about the most.
12:17:18 <monsterchrom> Yeah, that.
12:17:22 <joel135> I get that tautology.
12:17:48 <maerwald> the standad lib base isn't that great, but you'll have to use it anyway
12:18:00 <monsterchrom> The people I know are the people known to everyone who knows everyone I know.
12:19:36 <dsal> I like sqlite-simple.  I use it a bunch.   And optparse-applicative, though I'm open to trying some new ones.
12:20:31 * hackage phonetic-languages-vector 0.1.0.0 - A generalization of the functionality of the uniqueness-periods-vector package.  https://hackage.haskell.org/package/phonetic-languages-vector-0.1.0.0 (OleksandrZhabenko)
12:21:31 * hackage polysemy-kvstore-jsonfile 0.1.0.0 - Run a KVStore as a single json file in polysemy.  https://hackage.haskell.org/package/polysemy-kvstore-jsonfile-0.1.0.0 (locallycompact)
12:22:01 <dsal> I'm seeing more polysemy stuff.  Still not used it, and the last news I read about it made it seem like a hoax.
12:22:20 <maerwald> it's slow
12:23:07 <maerwald> just use IO
12:23:24 <dsal> Yeah, there was initially magic about how it erased all the overhead at compile time and made extremely efficient code and then later... that didn't happen.
12:24:04 <maerwald> even if it did trigger the right optimistions, it's a fragile gamble, hence the eff approach from alexi
12:24:43 <maerwald> but I don't even know if we will see that any time soon either
12:25:27 <monsterchrom> That triggered the GHC proposal to add first-class continuations.
12:29:30 <dsal> joel135: Can you expand on the nature of your question a bit?
12:30:22 <dsal> My favorite "this library makes things way easier in Haskell than other languages" are STM, async, lens, megaparsec, etc...
12:31:21 <dsal> The amazonka stuff is pretty good.  And conduit.
12:32:09 <joel135> I have known about haskell for a long time, and have during this time learned a lot about the lambda calculus, but the haskell libraries are still as foreign to me as they were at the beginning.
12:32:13 <maerwald> conduit is an example of an over-engineered API imo
12:33:31 <maerwald> streamly seems much more idiomatic haskell, but it's a bit less polished
12:33:55 <maerwald> and a lot faster
12:34:28 <dsal> I wasn't sure about conduit...  It's served me pretty well, but yeah, I've not looked hard for something else.
12:34:30 <merijn> I'd argue that streamly is both much more complex and much more over-engineered than conduit >.>
12:34:39 <sm[m]> joel135: a good start is to get familiar with what's in base
12:34:48 <dsal> I don't have experience with alternatives to conduit.
12:35:01 <merijn> streamly's API is super complex and the use of MonadBase/MonadBaseControl is terrible, because those typeclasses are terrible
12:35:46 <joel135> I am tring out some posix functions right now; maybe it can be good to read through base at some level of detail later unless that's too big of a task.
12:36:26 <dsal> joel135: It takes me some effort to study things for the sake of studying them.  I have to put a need between myself and my learning goals most of the time.  I've got a lot of pragmatic Haskell code for things I do.
12:37:50 <dsal> I was kind of annoyed that I couldn't find a pread implementation that worked when I was doing a thing that needed it.  Then I found one, and the change required to use it was going to be too large to be worth it.
12:37:51 <joel135> What does that mean? "put a need between myself and my learning goals"
12:38:11 <dsal> I learn stuff by intending to use it to solve a real problem I have.
12:38:33 <sm[m]> joel135: to be clear, and echoing dsal: learning all of base is way overkill for starter projects. But you can at least skim the modules and you'll know where to look later
12:38:44 <dsal> Or, at the very least, something like Advent of Code.
12:38:57 <Franciman> Hi, I would like to implement the matrix protocol in haskell
12:39:14 <Franciman> anybody likes the idea?
12:39:18 <dsal> Yeah.  There are *tons* of things I've "learned" in the sense of having seen before, but "Why would I ever need this?"  Then one day realizing, "Holy crap, I need a way to do that thing!"
12:40:55 <sm[m]> Franciman: great idea, please do. But first problem is a name - hmatrix is taken
12:41:18 <joel135> Yes, maybe that is what I should rather do - find a good motivating project first.
12:41:24 <Franciman> sm[m], I thought about this name: linearfunction
12:41:28 <Franciman> but it's cringe
12:41:33 <monsterchrom> hahaha
12:41:36 <sm[m]> facepalm :)
12:42:36 <dsal> Franciman: I've never used Matrix, but I like implementing protocols.
12:42:52 <dsal> Franciman: I've created a lot of projects just because I thought of a stupid name and had to build a project around it.
12:43:15 <Franciman> this is cool
12:43:31 * hackage polysemy-extra 0.1.0.0 - Run a KVStore as a filesystem in polysemy.  https://hackage.haskell.org/package/polysemy-extra-0.1.0.0 (locallycompact)
12:45:01 * hackage phonetic-languages-common 0.1.0.0 - A generalization of the uniqueness-periods-vector-common package.  https://hackage.haskell.org/package/phonetic-languages-common-0.1.0.0 (OleksandrZhabenko)
12:45:03 <dsal> joel135: I do a lot of stuff on the commandline.  Learning something like optparse-applicative is a prerequisite for doing anything kind of complicated.
12:45:06 <Franciman> if we can lower the power of google by the means of matrix and haskell, it would be great
12:45:43 <dsal> Is matrix an anti-google thing?
12:46:04 <Franciman> it's a tool I guess, if we can use it as anti-google
12:46:05 <Franciman> then yes
12:46:10 <Franciman> otherwise no
12:46:44 <sm[m]> it's a decentralising thing
12:47:09 <Franciman> maybe it could be used for classrooms
12:47:14 <dsal> joel135: One example of stuffing a bunch of junk into a small very useful  (to me) project is https://github.com/dustin/waitforsocket -- I use it to tell when a machine is done rebooting or when a web server is working, or whether I have connectivity, etc...  It has a few different parsers for stuff and some fun use of async.
12:47:25 <Franciman> instead of damn mircosoft, zoom, google et al
12:47:27 <dsal> I don't quite understand matrix vs. xmpp.  I used to do a lot of stuff with xmpp
12:47:50 <Franciman> eheh neither do I dsal, they are similar, but have different philosophies I guess
12:48:01 <dsal> Oh, says it right there:  "Matrix is really a decentralised conversation store rather than a messaging protocol."
12:48:26 <sm[m]> some more discussion here dsal: https://news.ycombinator.com/item?id=17064616
12:48:31 <dsal> The downside is I already use irc and discord and dumb work chat and Signal.
12:48:57 <dsal> "The core Matrix team maintains bridges to Slack, IRC, XMPP and Gitter, and meanwhile the wider Matrix community provides bridges for Telegram, Discord, WhatsApp, Facebook, Hangouts, Signal and many more."  -- maybe that's an upside?
12:49:31 <Franciman> the problem is that I can't even implement irc protocol
12:49:37 <Franciman> and matrix is harder ahah
12:49:46 <sm[m]> yes, matrix is really good at bridging to other networks. I've used it as my IRC client for a good while now
12:49:47 <dsal> Can't, or haven't?
12:50:43 <Franciman> I tried, I failed
12:50:45 <joel135> dsal: I'll take your waitforsocket as a small case study :)
12:50:47 <sm[m]> I also participate in some gitter channels (IHP)
12:50:56 <Franciman> man the world is full of chats
12:51:13 <dsal> joel135: It's meant for inspiration.  How to have a small goal and fill it with learnings.  I've implemented that in like, four languages now.  Haskell's worked the best. heh
12:51:16 <sm[m]> slack of course doesn't want to be bridged
12:52:14 <dsal> farn__: Failing is important.  I've failed at just about everything I've tried.
12:52:18 <dsal> er, Franciman damnit
12:53:04 <dsal> I've eventually got a few things stable enough that they work pretty well and I don't want to change them.  Someone filed a quite reasonable bug against my mqtt client I've not figured out how to deal with.  (I'm guessing matrix can't be harder than mqtt).
12:54:13 <Franciman> true
13:03:59 <texasmynsted> I often am unable to reach this channel from Matrix by their bridge
13:04:14 <texasmynsted> I gave up trying so using limechat now. 
13:04:17 * texasmynsted shrug
13:10:32 * hackage phonetic-languages-common 0.1.1.0 - A generalization of the uniqueness-periods-vector-common package.  https://hackage.haskell.org/package/phonetic-languages-common-0.1.1.0 (OleksandrZhabenko)
13:16:01 * hackage polysemy-path 0.0.1.0 - Polysemy versions of Path functions.  https://hackage.haskell.org/package/polysemy-path-0.0.1.0 (locallycompact)
13:18:47 <maerwald> sm[m]: I used slack in weechat, but slack API seems to be unreliable, often diconnecting the client. And then the feature creep doesn't translate well to terminal
13:19:19 <maerwald> like ppl post 200 LOC of some code and it messes up your entire terminal
13:20:08 <dminuoso> indeed, slack in weechat is a horrid experience
13:21:49 <jjhoo> slack... that thing that doesn't seem to handle formatting ```if this block is too long``` for an outgoing webhook (legacy thing, maybe things are better with slack apps)
13:27:32 * hackage phonetic-languages-general 0.1.0.0 - A generalization of the uniqueness-periods-vector-general functionality.  https://hackage.haskell.org/package/phonetic-languages-general-0.1.0.0 (OleksandrZhabenko)
13:53:09 <sm[m]> texasmynsted: strange, I access it 24/7
13:53:31 * hackage phonetic-languages-properties 0.1.0.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-properties-0.1.0.0 (OleksandrZhabenko)
13:53:34 * texasmynsted shrug
13:54:38 <texasmynsted> I put a few days/weeks as a limit for troubleshooting. After that I figured it would be faster to use something else. 
13:54:52 <texasmynsted> I am fine with limechat for now
13:55:34 <texasmynsted> It worked okay for me for some channels, but not others. I think the more traffic the channel, the less likely it worked for me over the bridge.
14:10:01 * hackage predicate-typed 0.7.4.1 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.4.1 (gbwey)
14:30:05 <taio> A question about Haskell's terms: Type constructors are functions at the type level that return a type when fully applied. But how are such structures called ?: Num :: * -> Constraint
14:30:17 <taio> A type class constructor or a constraint constructor?
14:31:09 <icebreaker> join ##trading
14:31:37 <icebreaker> sorry guys 😅
14:43:33 <monsterchrom> Num is a type class.
14:43:56 <monsterchrom> This shows that generally if you see Foo :: * -> Constraint, Foo is a type class.
14:44:37 <monsterchrom> Well OK maybe I forgot equality constraints, which you wouldn't call that.
14:53:05 <monsterchrom> Amazing, my program that uses HXT written in 2015 still builds today.
14:53:23 <jbox> I've been trying to get a haskell dev environment set up
14:53:33 <jbox> should I use ghcup or stack to install everything?
14:54:19 <maerwald> are you a beginner? What platform?
14:55:02 <taio> Thanks for the answer. I know Num is a type class. my question was about what to call this function, e.g. a constraint constructor?
14:55:53 <dolio> You should only call it a constructor if it makes sense to match on it with e.g. a type class.
14:57:04 <jbox> maerwald: I'm a beginner. I'm trying to get a dev environment set up so I can use xmonad. I'm on Arch Linux
14:57:05 <monsterchrom> :)
14:57:18 <monsterchrom> I like dolio's criterion.
14:58:05 <maerwald> jbox: it seems xmonad README suggest to use cabal, so I'd go with ghcup + cabal. But it also supports stack
14:58:08 <byorgey> jbox: if you just want to use xmonad, probably easiest to use ghcup, then install xmonad with cabal
14:58:55 <byorgey> jbox: also, you should feel free to hang out and ask questions in #xmonad too
14:59:01 <jbox> I tried installing xmonad with my distro package managers first, and it worked out of the box, but it gave me problems when I tried to configure anything, so I'm doing it the "right" way now haha
14:59:12 <jbox> byorgey: gotcha, thank you :)
14:59:16 <jbox> maerwald: thank you :)
15:06:31 * hackage phonetic-languages-examples 0.1.0.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.1.0.0 (OleksandrZhabenko)
15:11:39 <flux41> does anyone have a good beginner reference for kinds
15:11:49 <flux41> been reading through 5-6 tutorials with no success
15:15:14 <DigitalKiWicked> does https://wiki.archlinux.org/index.php/Xmonad not work?
15:20:18 <jbox> whenever I try to launch stack or xmonad, I get an error like "error while loading shared libraries: libHSbase-4.14.1.0-ghc8.10.2.so: cannot open shared object file: No such file or directory"
15:20:27 <jbox> and the .so file is different each time
15:25:27 <maerwald> jbox: do you have a GHC installed via pacman?
15:27:01 <jbox> maerwald: I have ghc 8.8.4 isntalled via ghcup
15:27:25 <maerwald> why is something picking ghc-8.10.2 then
15:27:36 <jbox> oh, I also have it installed through pacman LOL
15:27:37 <jbox> thank you
15:27:43 <maerwald> uninstall that
15:28:07 <maerwald> also, you can tell cabal which ghc to use: cabal build -w ghc-8.8.4
15:28:36 <jbox> ghc is required by xmonad. Should I not install xmonad via pacman either?
15:28:45 <jbox> I haven't even built anything yet hahaha
15:28:55 <jbox> I've screwed this up so bad
15:28:58 <maerwald> I'd not install anything haskell-ish via pacman
15:29:07 <sm[m]> flux41: kinds aren't a beginner topic I think
15:30:28 <jbox> maerwald: gotcha, thank you
15:36:51 <crestfallen> hi a member was helping me with this program and wrote the evaluation to resolve to Nothing. So I'm a bit confused, because (with one or two possible mistakes) I thought the evaluation would look something like this: https://termbin.com/2b34
15:39:12 <crestfallen> I believe I have errors on lines 2 and/or 3: too many or too few Add 's   ..
15:39:39 <crestfallen> please critique
15:42:41 <crestfallen> yeah I guess the 2 Just constructors in the left branch on line 4 are also wrong
15:49:26 <crestfallen> ok I think the member wrote two different evaluations; one with map for Maybe and one for Traversable
15:51:42 <crestfallen> no, actually thoroughly baffled still..
15:52:28 <crestfallen> this is probably the correct evaluation: https://paste.tomsmeding.com/7TIQdWo7
16:03:53 <crucify_me> correction on line 4 of evaluation https://termbin.com/5r6r   (guessing at this point)
16:19:00 * hackage lentil 1.4.0.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.4.0.0 (fffaaa)
16:39:01 <jbox> what should I do if I keep getting errors like "error while loading shared libraries: libHSxmonad-0.15-2PS2yVgZEOJ5LumuexxAMV-ghc8.10.2.so: cannot open shared object file: No such file or directory"
16:39:22 <jbox> I've installed xmonad and xmonad-contrib with cabal
16:40:47 <jbox> also, for some reason, I don't have ghc-pkg installed
16:42:57 <jbox> oops, disregard my last
16:44:08 <jbox> /usr/bin/ghc-pkg: line 11: /usr/lib/ghc-8.10.2/bin/ghc-pkg: No such file or directory
16:44:10 <jbox> I'm so stumped
16:46:24 <infinisil> Well personally I'd try installing xmonad with Nix
16:46:49 <infinisil> Works on any distro, and pretty much guarantees no dynamic linker errors ever
16:48:03 <hoppfull> I'm starting an SDL2 window and I want to be able to interact with my program in ghci while it's running. Since SDL2 is a foreign C library with state, I suspect I need to start the application with forkOS and use an MVar to communicate with it. If anyone has experience with this and any bells are ringing like "oh don
16:48:21 <hoppfull> I'm starting an SDL2 window and I want to be able to interact with my program in ghci while it's running. Since SDL2 is a foreign C library with state, I suspect I need to start the application with forkOS and use an MVar to communicate with it. If anyone has experience with this and any bells are ringing like "oh don't forget to say your name
16:48:22 <hoppfull> backwards" or something, please tell me
16:50:09 <hoppfull> sorry, that was formulated kind of rude, I didn't mean that you have to tell me, I'm just curious if anyone knows anything about this since it seems quite subtle
16:52:00 <hoppfull> Does a thread disappear after it has run its course? Or do I have to manually clean it up?
16:55:02 <ghoulguy> A GHC thread from forkIO doesn't need to be cleaned up. Once the ThreadId gets GC'd and the thread as completed it's done
16:56:02 <hoppfull> ghoulguy: thanks, I'm using forkOS though, I'm guessing it's the same
16:56:09 <ghoulguy> yeah, same deal
16:56:14 <hoppfull> cool
17:16:01 * hackage recursion 2.2.4.3 - A recursion schemes library for Haskell.  https://hackage.haskell.org/package/recursion-2.2.4.3 (vmchale)
17:20:12 <jbox> I managed to fix the missing library
17:20:26 <jbox> now I just need to fix where it can't find the XMonad lib
17:20:32 <jbox> it errors on `import XMonad`
17:22:49 <jbox> sike, the library is still missing
17:26:34 <infinisil> Again, would be pretty easy to have that work with Nix, just sayin!
17:28:19 <sm[m]> jbox: often it's something like: need to prefix your command with "cabal exec --". Xmonad project should be explaining this stuff 
17:28:51 <yushyin> I'm pretty sure, cabal install xmonad works just as good, but _using_ the library with cabal v2-* is another matter
17:29:20 <jbox> I'm running into different kinds of issues, so I'm not sure where I am in the "stack" persay. I don't know if it's an xmonad issue or a haskell issue
17:32:14 <sm[m]> jbox: understandable. It sounds like a typical 2020 Haskell tooling/packaging gotcha, and it's something the xmonad project should be explaining/supporting since it's really common. Just saying, nothing wrong with your question
17:32:28 <jbox> sm[m]: thank you :)
17:33:03 <jbox> I'm very thankful to be getting help in here and I hope I'm not being too annoying with my noob questions. I'd have given up if I didn't have all this help haha
17:33:14 <yushyin> https://github.com/xmonad/xmonad/issues/199#issuecomment-609433196 maybe relevant?
17:34:44 <yushyin> I think so
17:35:50 <sm[m]> lord.. I knew about cabal v1 and v2, what's v3 ?
17:36:54 <crestfallen> hi another attempt: please critique the evaluation of the 'bb' program here. thanks: https://termbin.com/2b34
17:36:55 <yushyin> sm[m]: I think they meant cabal-install v3.x
17:36:59 <yushyin> ^^
17:37:16 <sm[m]> I guess so
17:40:29 <yushyin> and yes, the xmonad project really should explain how to use xmonad with cabal v2-* oO
17:49:15 <crestfallen> man I think I was barred from the chatroom. sorry folks for any over-reliance on you.
17:53:59 <DigitalKiWicked> wat
19:49:09 <emb> Any suggestions on the fastest way to become fluent in Haskell? 
19:50:41 <emb> 📖📚📖📚
19:51:18 <ghoulguy> emb, finding a project your interested in working on
19:51:25 <ghoulguy> you're*
19:51:56 <emb> How do yoi define "project"? 
19:52:02 <emb> *you
19:52:13 <emb> Opensource? 
19:52:35 <ghoulguy> Either a new program that does something you're interested in or modifying one that does something you're interested in
20:26:24 <Just> Hi there. I'm trying to get ghcide working with stack. Output for "stack ghc -- --version" says ghc is 8.8.4. It looks like hie only has up to 8.8.3. Should I downgrade stack's ghc version?
20:27:19 <ghoulguy> Just, stack's GHC version is selected by the resolver you pick
