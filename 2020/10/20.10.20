00:00:01 <asheshambasta> (I'm also using niv here)
00:00:59 <asheshambasta> I can enter a nix-shell; but I get a "called without default argument "bulmex-custom"" error. 
00:02:09 <asheshambasta> (when firing up cabal; which has bulmex-custom as one of its dependencies.)
00:05:12 <Echosolace> Hey, newb here looking at sum . replicate 5 . max 6.7 $ 8.9 
00:05:21 <Echosolace> Can someone tell me if my understanding is correct?
00:05:27 <Echosolace> It goes like this - 
00:07:54 <Echosolace> max calls two parameters, so we are left with max 6.7 and a variable, let's call it a. It's a partial function, which is then called by replicate, which leaves us with a list that looks like this: [max 6.7 a, max 6.7 a, max 6.7 a, max 6.7 a, max 6.7 a]. Sum is called on that list, but now since a is undefined, it finally reaches out and replaces a with 8.9 and sums 5 x 8.9. 
00:10:26 <merijn> Echosolace: Not really
00:10:34 <Echosolace> Sigh*
00:10:35 <suzu_> you have it backwards
00:10:43 <merijn> Echosolace: You are overthinking the partial application thing
00:11:11 <merijn> Echosolace: Let's work backwards rewriting things
00:11:16 <Echosolace> Ok
00:11:22 <merijn> $ has the lowest precedence, so we start there
00:11:30 <merijn> f $ x = f x
00:11:31 <Echosolace> Yep. Everything to the left first.
00:11:32 <merijn> So
00:11:48 <merijn> (sum . replicate 5 . max 6.7) 8.9
00:12:00 <Echosolace> Yes.
00:12:12 <merijn> f . g = \x -> f (g x)
00:12:37 <suzu_> the stuff in the braces is a function that gets called with 8.9
00:12:40 <Echosolace> f of g
00:12:44 <merijn> SO you get ((\x -> sum (replicate 5 x)) . max 6.7) 8.9
00:13:29 <merijn> (\y -> (\x -> sum (replicate 5 x)) (max 6.7 y)) 8.9
00:13:43 <merijn> Then we can simplify
00:14:04 <merijn> (\y -> sum (replicate 5 (max 6.7 y))) 8.9
00:14:08 <merijn> And finally
00:14:21 <merijn> sum (replicate 5 (max 6.7 8.9))
00:15:39 <Echosolace> Ok ok I think that helped... The stuff in the braces is a function that gets called with the outside parameter... got it.
00:15:53 <merijn> Although in practice you normally read "f . g . h" sorta like a pipeline where a values goes into 'h', it's result goes into 'g', and that result goes into 'f' (which, as you can see is exactly what happens in the elaborate version I wrote out
00:16:30 <merijn> Without constructing all the lambda's in your head, because that's a load of bookkeeping
00:16:36 <ghoulguy> I think it might help to rewrite (f.g.h) to (f.(g.h)) as an explicit step
00:17:25 <merijn> Possibly, but I had was too lazy to figure out the brace and (fortunately) "f.(g.h)" and "(f.g).h" are the same ;)
00:18:31 <ghoulguy> They end up being the same. I suppose it's convenient to collapse that all at once to \x->f(g(h x))
00:19:19 <dminuoso> Mmm, can a generic function to provide isomorphisms between arbitrary tuples (that is `f :: (S,T,U) -> ((S,T),U)`, `f :: (S,T,U) -> (S,(T,U))`, `f :: ((S,T),U) -> (S,T,U)` exist at all?
00:19:20 <merijn> Yeah, that's what my brain does, but that feels too much like "voodoo" for beginners, I think :)
00:19:40 <merijn> I like dumb, mechanical rewrite rules, because anyone get understand them and they work really well in Haskell :)
00:25:49 <Echosolace> Ok this one has been doing my head in for a couple of days. It seems so similiar to the previous one - replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
00:26:16 <Echosolace> So a lengthy function is being called on 4,5..8
00:26:31 <Echosolace> max determines that 4,5..8 is bigger.
00:26:42 <Echosolace> it's the zipWith that has me confused.
00:26:49 <Echosolace> There's nothing to zipWith...
00:27:04 <merijn> :t zipWith
00:27:05 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
00:27:15 <Echosolace> What...
00:27:18 <Echosolace> :t zipWith
00:27:19 <opqdonut>  Echosolace: zipWith max [1,2,3,4] [4,5,6,7] ==> [max 1 4, max 2 5, max 3 6, max 4 7]
00:27:20 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
00:27:26 <Echosolace> Holy shit you can do that here?
00:27:32 <merijn> Yes? :p
00:27:38 <merijn> :t zipWith max
00:27:40 <lambdabot> Ord c => [c] -> [c] -> [c]
00:27:47 <Echosolace> wtf you can type multiples?
00:27:58 <Echosolace> Yo.
00:28:00 <merijn> Echosolace: The flaw in your reasoning is that max isn't being applied to those lists
00:28:09 <merijn> zipWith is being applied to max
00:28:36 <merijn> And then "zipWith max" is applied first to one list and then "zipWith max [1,2,3,4]" is applied to the final list
00:29:23 <merijn> Echosolace: In general "foo bar baz quux" is parenthesised as "(((foo bar) baz) quux)"
00:29:47 <merijn> The exception is operator which are binary and *always* have lower precedence then function application
00:30:33 <merijn> So "replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5]" is "(replicate 100) . product . (map (*3)) . (zipWith max [1,2,3,4,5])"
00:31:38 <merijn> > zipWith f [1,2,3,4] [5,6,7,8]
00:31:40 <lambdabot>  error:
00:31:40 <lambdabot>      • Ambiguous type variable ‘c0’ arising from a use of ‘show_M201622632345...
00:31:40 <lambdabot>        prevents the constraint ‘(Show c0)’ from being solved.
00:31:49 <merijn> > zipWith f [1,2,3,4] [5,6,7,8] :: [Expr]
00:31:52 <lambdabot>  [f 1 5,f 2 6,f 3 7,f 4 8]
00:32:10 <merijn> opqdonut: ^^ lazily not writing things out like a pro ;)
00:32:11 <Echosolace> Thanks, it's all still processing...
00:32:31 <opqdonut> merijn: heh, I can never trust myself to get the expr stuff to work "live"
00:34:29 <Echosolace> > max 4 5
00:34:31 <lambdabot>  5
00:34:36 <Echosolace> So cool.
00:35:02 <Echosolace> > max [1,2,3,4] [4,5,6,7]
00:35:04 <lambdabot>  [4,5,6,7]
00:43:18 <Echosolace> This stuff is beautiful...
00:43:38 <Echosolace> So, maybe someone can hear out my understanding.
00:44:20 <Echosolace> zipWith uses the function max to tie the two lists together... a la [max 1 4, max 2 5, max 3 6, max 4 7]
00:44:44 <Echosolace> map then ties *3 to each list element.
00:45:31 <Echosolace> so now we have [ (max 1 4) * 3, (max 2 5) * 3, (max 3 6) * 3, (max 4 7) *3]
00:46:11 <Echosolace> replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5]" is "(replicate 100) . product . (map (*3)) . (zipWith max [1,2,3,4,5])"
00:46:30 <Echosolace> Then that gets evaluated, then each element is multiplied together...
00:46:46 <Echosolace> and then repeated into a list 100 times?
00:47:33 <Echosolace> Original reference - replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
00:47:46 <Echosolace> > replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
00:47:48 <lambdabot>  [1632960,1632960,1632960,1632960,1632960,1632960,1632960,1632960,1632960,163...
00:47:59 <Echosolace> Sure looks like it...
00:48:35 <Echosolace> > 12 x 15 x 18 x 21
00:48:38 <lambdabot>  error:
00:48:38 <lambdabot>      • Could not deduce (Num t0)
00:48:38 <lambdabot>        from the context: (Num t, Num t3, Num t4,
00:48:52 <Echosolace> > 12 * 15 * 18 * 21
00:48:54 <lambdabot>  68040
00:49:19 <Echosolace> > 12 * 15 * 18 * 21 * 24
00:49:21 <lambdabot>  1632960
00:49:38 <Echosolace> Thanks for the help!
00:56:28 <Echosolace> Just finished the higher order functions chapter on learn you a haskell. It was daunting but ya'll helped a bunch, thanks! Woot!
00:59:50 * hackage jsonifier 0.1.0.4 - Fast and simple JSON encoding toolkit  https://hackage.haskell.org/package/jsonifier-0.1.0.4 (NikitaVolkov)
01:08:15 <merijn> Echosolace: One side note about your use of "and then" is that the evaluation order of Haskell isn't defined (well, that's a bit of an oversimplification, but it will do for now) so there's no real notion of "and then", they key is that in a pure setting the order becomes irrelevant
01:53:11 <dminuoso> ito :: (s -> (i, a)) -> IndexedGetter i s a
01:53:26 <dminuoso> Im looking for a variant of `to` that gets access to the current index. Is there such a thing?
01:54:15 <dminuoso> That is, some `((i, s) -> a) -> IndexedGetter i s a` maybe?
01:58:48 <edwardk> :t withIndex
01:58:49 <lambdabot> (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)
01:59:54 <edwardk> :t withIndex.to _foo
02:00:00 <lambdabot> error:
02:00:01 <lambdabot>     • Found hole: _foo :: (j, t) -> a
02:00:01 <lambdabot>       Where: ‘j’, ‘t’, ‘a’ are rigid type variables bound by
02:00:06 <edwardk> like that?
02:00:58 <edwardk> you need to use it inside of some context where you have an index, of course
02:01:17 <edwardk> :t itraversed.withIndex
02:01:19 <lambdabot> (TraversableWithIndex i t, Indexable i p, Applicative f) => p (i, a) (f (j, b)) -> t a -> f (t b)
02:01:29 <edwardk> :t itraversed.withIndex.to id
02:01:30 <lambdabot> (TraversableWithIndex j t, Indexable j p, Contravariant f, Applicative f) => p (j, b) (f (j, b)) -> t b -> f (t b)
02:03:08 <dminuoso> % toListOf (itraversed . withIndex) ([1,2,3] :: [Int])
02:03:08 <yahb> dminuoso: [(0,1),(1,2),(2,3)]
02:03:11 <dminuoso> edwardk: Looks about right, cheers!
02:03:39 <edwardk> :t asIndex
02:03:40 <lambdabot> (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)
02:03:54 <edwardk> also exists and might be useful in some situations
02:05:50 <dminuoso> edwardk: I guess `asIndex = withIndex . to fst` roughly?
02:05:59 <edwardk> yeah
02:52:34 <siraben> Anyone know what I should do if I want to install the latest haskell-language-server from https://github.com/haskell/haskell-language-server ? Here's what the derivation looks like, http://ix.io/2BlI
02:52:35 <siraben> But it's missing an argument hls-tactics-plugin, which is not in haskellPackages yet
02:52:52 <siraben> edwardk: saw that your recursive PR got merged to master
03:01:19 * hackage attoparsec-data 1.0.5.1 - Parsers for the standard Haskell data types  https://hackage.haskell.org/package/attoparsec-data-1.0.5.1 (NikitaVolkov)
04:36:49 * hackage phonetic-languages-rhythmicity 0.1.2.0 - Allows to estimate the rhythmicity metrices for the text (usually, the Ukrainian poetic one)  https://hackage.haskell.org/package/phonetic-languages-rhythmicity-0.1.2.0 (OleksandrZhabenko)
05:12:48 * hackage sweet-egison 0.1.1.3 - Shallow embedding implementation of non-linear pattern matching  https://hackage.haskell.org/package/sweet-egison-0.1.1.3 (SatoshiEgi)
05:17:46 <dminuoso> Mmm, Im generating a lot of boiler plate code using haskell-src-exts, suddenly I realized I might want to generate a few bits of haddock as well, but haskell-src-exts seems to not know about comments at all.
05:17:49 <dminuoso> What are my options here?
05:19:50 <dminuoso> Oh.. turns out I wasn't reading the haddock clearly.
05:19:52 <dminuoso> http://hackage.haskell.org/package/haskell-src-exts-1.18.2/docs/Language-Haskell-Exts-Comments.html
05:33:45 <tomjaguarpaw> What's the standard idiom for zipping more than three lists together?
05:34:01 <merijn> tomjaguarpaw: Applicative
05:34:09 <merijn> tomjaguarpaw: Lemme introduce you to your saviour
05:34:27 <merijn> > (+) <$> ZipList [1..5] <*> ZipList [6..10]
05:34:29 <lambdabot>  ZipList {getZipList = [7,9,11,13,15]}
05:34:58 <merijn> tomjaguarpaw: Turns out n-wise zipping is a lawful Applicative ;)
05:39:41 <ski> > [x + y | x <- [1 .. 5] | y <- [6 .. 10]]
05:39:44 <lambdabot>  [7,9,11,13,15]
05:41:06 <merijn> ski: That one requires an extension, though :p
05:43:38 <tomjaguarpaw> Thanks, I think I will use zipWith ($)
05:45:44 <merijn> That doesn't work for more than 3, though :p
05:57:59 <dminuoso> ski: ParallelListComp is an extension I've never seen in use anywhere.
05:59:04 <Taneb> > (,,,,) <$> ZipList "hello" <*> ZipList [1..5] <*> ZipList "world" <*> ZipList [6..10]
05:59:06 <lambdabot>  error:
05:59:06 <lambdabot>      • No instance for (Typeable e0)
05:59:06 <lambdabot>          arising from a use of ‘show_M2158027891849958446363’
05:59:13 <Taneb> > (,,,) <$> ZipList "hello" <*> ZipList [1..5] <*> ZipList "world" <*> ZipList [6..10]
05:59:16 <lambdabot>  ZipList {getZipList = [('h',1,'w',6),('e',2,'o',7),('l',3,'r',8),('l',4,'l',...
05:59:24 <Taneb> I can definitely count commas no problem
06:11:34 <ski> > zipWith ($) (zipWith ($) (zipWith (,,,) "hello" [0 .. 4]) "world") [5 .. 9]
06:11:36 <lambdabot>  [('h',0,'w',5),('e',1,'o',6),('l',2,'r',7),('l',3,'l',8),('o',4,'d',9)]
06:12:10 <ski> > let with = zipWith ($) in repeat (,,,) `with` "hello" `with` [0 .. 4] `with` "world" `with` [5 .. 9]
06:12:12 <lambdabot>  [('h',0,'w',5),('e',1,'o',6),('l',2,'r',7),('l',3,'l',8),('o',4,'d',9)]
06:14:24 <dminuoso> Pattern match checker exceeded (2000000) iterations in a case alternative. (Use -fmax-pmcheck-iterations=n to set the maximun number of iterations to n)
06:14:28 <dminuoso> I should feel bad
06:14:37 <dminuoso> Also, that typo in maximun :>
06:15:25 <dminuoso> Perhaps I should stop doing case-of here, and just use non-inlined top level maps..
06:15:55 <ski> is it checking exhaustiveness and non-overlap ?
06:16:10 <dminuoso> Probably, yes.
06:16:52 <dminuoso> I mean this is a 2,000 constructor coproduct type.
06:17:02 <dminuoso> It's reasonable that GHC has some limits.
06:19:17 <ski> yea
06:20:37 <phadej> if the code is generated, you can (and maybe even should) disable pattern-match checks
06:21:03 <phadej> you should rathere test that codegenerator makes sensible code on smaller examples :)
06:21:19 <phadej> i.e. "if you generate code, generate code which is fast to compile"
06:21:44 <dminuoso> phadej: Honestly, had I done that, I wouldn't have discovered a nasty bug that only occured in one of those large data types. :)
06:21:54 <dminuoso> So Im keeping this on.
06:22:02 <merijn> dminuoso: pfft, amateur
06:22:06 <merijn> dminuoso: Just don't write bugs
06:22:16 <dminuoso> I didn't write a bug. My code generator did!
06:22:27 <phadej> what kind of bug, why only in larger datatypes?
06:22:49 <dminuoso> Oh, it wasn't even the size. The problem only manifested with a particular data type that also happened to be very large.
06:23:13 <phadej> then you didn't test your codegen properly
06:23:16 <dminuoso> heh
06:23:27 <dminuoso> Yeah this is all very adhoc
06:23:33 <dminuoso> And Im being punished badly for it
06:24:10 <dminuoso> to be fair, ghc diagnostics *are* tests for my codegen
06:25:46 <phadej> yes, but they run faster on the smaller datatypes :)
06:27:17 <dminuoso> phadej: Very roughly, I was building up a `Map String Int` where strings correspond to constructors, and the Map represents an Enum instance. I failed to check whether this was injective or not.
06:27:36 <dminuoso> And in some particular degenerate case, the source data had duplicate data.
06:28:16 <phadej> heh. something similar happend with tzdata just recently
06:28:24 <phadej> they mangle timezonenames into constructor names
06:28:45 <phadej> and that mangling failed to be injective with recent additions of timezones in IANA db
06:41:58 <remexre> ghoulguy: yeah, looks like that works; I'll try and see if hoistFree will work for my case too
07:07:13 <DigitalKiwi> what's injective mean
07:07:27 <Uniaika> like for sets
07:10:01 <Cheery> DigitalKiwi: it means that you can figure from the output what the input was.
07:13:02 <Cheery> Eg. (/2) is not injective, because 1/2 and 2/2 produce same result.
07:13:24 <Cheery> > (1/2, 2/2) :: (Int, Int)
07:13:27 <lambdabot>  error:
07:13:27 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
07:13:27 <lambdabot>      • In the expression: 1 / 2
07:14:08 <Cheery> haskell has no floordiv?
07:14:57 <Cheery> ah it has better.
07:15:16 <Cheery> > (quot 2 2, quot 3 2)
07:15:19 <lambdabot>  (1,1)
07:15:44 <Cheery> Ug good at math.
07:16:04 <opqdonut> see also: div
07:16:25 <opqdonut> > (div 3 2, quot 3 2, div (-3) 2, quot (-3) 2)
07:16:27 <lambdabot>  (1,1,-2,-1)
07:17:06 <opqdonut> and divMod and quotRem
07:18:34 <JetNoBrains> Why `r` parameter in `ContT` transformer isn't universally quantified inside constructor?
07:19:02 <Taneb> JetNoBrains: because that would be a different, less powerful
07:19:05 <Taneb> type
07:19:07 <DigitalKiwi> thanks
07:20:09 <Taneb> JetNoBrains: having it outside lets us reset :: Cont r r -> Cont r' r
07:22:31 <JetNoBrains> Taneb interesting, but I can't find such function in mtl - where it is located?
07:23:05 <Taneb> It's in Control.Monad.Trans.Cont in transformers
07:23:38 <Taneb> I'm a little surprised that mtl doesn't reexport it
07:23:46 <JetNoBrains> Thanks, will take a look!
07:24:26 <Taneb> JetNoBrains: the type you described, with the r parameter quantified on the inside of the constructor, is Control.Monad.Codensity in the kan-extensions package
07:31:54 <JetNoBrains> I'm reading an article https://ro-che.info/articles/2019-06-07-why-use-contt where author uses ContT to manage resources, here "universality" of `r` is moved to function level
07:32:25 <JetNoBrains> But it seems that building intuition for ContT as "lifetime management" is not complete
07:42:31 <maerwald> with 3 words, do you do `foo $ bar baz` or `foo . bar $ baz`? :D
07:43:32 <ski> either the latter, or `(foo . bar) baz' or `foo (bar baz)'
07:44:17 <JetNoBrains> `foo (bar baz)` anyone? :)
07:44:46 <ski> DigitalKiwi : two different timezones had the same name, apparently
07:45:58 <ski> `f :: T -> U' being injective means that given different `T' inputs, it produces different `U' outputs. in a formula, one can say it like `forall (x0 :: T) (x1 :: T). f x0 = f x1 => x0 = x1' (if the outputs are the same, then the inputs must also have been the same)
07:47:36 <ski> data constructors are injective in Haskell. this means that you can pattern-match uniquely. if a value matches `Just x0' and also matches `Just x1', then `x0' is the same as `x1'. so in the pattern `Just x', there's no ambiguity about what `x' would be. the only question is whether there exists such an `x' at all (if the input is `Nothing', then there is no `x' such that the input is equal to `Just x')
07:49:34 <ski> however, if you're doing an abstract data type, often you want to simulate a "quotient type", and then, conceptually, the data constructor (which should not be exported) is not injective. e.g. the same `Set' (or `Map') can potentially be represented internally as different (balanced) trees
07:50:01 <fresheyeball> I got a hardish one
07:50:08 <fresheyeball> https://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server-StaticFiles.html#v:serveDirectoryWith
07:50:21 <fresheyeball> I need to replicate the behavior of this function but for a new Servant combinator
07:50:50 <fresheyeball> and I just cannot get the types to unify
07:51:15 <fresheyeball> I don't totally understand what is going on in Servant but I can get my custom version to compile 
07:51:20 <fresheyeball> with the correct implimentation
07:51:23 <fresheyeball> but with the following type
07:51:29 <ski> another example would be doing rational numbers. we could have `data Ratio a = a :% a', where `1 :% 2' is supposed to represent the same rational number as `2 :% 4'. so, conceptually, if you match on `n :% d', uniqueness of `n' and `d' isn't given. meaning, you have to make sure that the result is the same (or behaves the same), if the input had instead been another representation of the same rational number
07:51:43 <fresheyeball> StaticSettings -> Tagged (Get '[HTML] (Html m a)) Application
07:51:53 <fresheyeball> that type works for the implimentation 
07:52:00 <fresheyeball> but I need it to be this
07:52:07 <fresheyeball> StaticSettings -> ServerT (Get '
07:52:29 <fresheyeball> StaticSettings -> ServerT (Get '[HTML] (Html m a)) Handler
07:52:49 <fresheyeball> the same exact implimentation is what is used for the library version, I don't get what is wrong
07:52:57 <fresheyeball> and the library version has this type
07:53:06 <fresheyeball> StaticSettings -> ServerT Raw Handler
07:53:30 <fresheyeball> Tagged is kind polymorphic in a way I don't understand, and I could use help
08:04:40 <hyperisco> renamePath on my system (Windows) seems to truncate the file
08:06:50 <hyperisco> as does copyFile oO
08:10:19 <phadej> hyperisco: is the file over 2GB in size?
08:11:05 <hyperisco> actually seemed to be a bug or something in vscode and it wasn't reading the current version of the file
08:11:54 <phadej> it would much nicer if random int32 bug still happened in 2020
08:12:02 <phadej> s/nicer/more interesting/
10:13:36 <yushyin> hackage returns 503 for a lot of urls :/ https://hackage.haskell.org/package/system-filepath-0.4.14/docs/Filesystem-Path-CurrentOS.html
10:18:20 <statusbot> Status update: The host is fixing the switch, hopefully resolved shortly. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5f8f1bc50f323c04c157dbeb
10:18:54 <yushyin> oh
10:20:16 <geekosaur> #haskell-infrastructure is where to ask about these things, by the way
10:20:29 <yushyin> that explains it
10:36:18 * hackage prolude 0.0.0.3 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.3 (saramuse)
10:48:39 <statusbot> Status update: connectivity fixed. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5f8f1bc50f323c04c157dbeb
10:49:00 <Athas> I'm mystified that haskell-mode's built-in "autocompletion" is about showing me the grammar for syntactic constructs.
10:49:32 <Athas> Showing me the type of the term would be more useful.  Especially since Haskell's syntax is so flexible that just listing the grammar is hardly useful.
10:55:51 <tomsmeding> Athas: does haskell-mode use a ghc under the hood? I think showing syntactic grammar is all you can do without getting into the weeds of all that haskell-ide-engine, ghcide, etc are doing
10:56:28 <tomsmeding> which involves building IDE-like functionality against the API of the ghc your project is using, etc
10:56:37 <Athas> It does not.  And I guess what I'm really sad about is that such a significant technical infrastructure is needed to do things that ought not be very difficult.
10:56:59 <tomsmeding> perhaps it ought not to be very difficult in a language that is not as complicated as Haskell :p
10:57:51 <tomsmeding> or do you mean that harnessing ghc should not be as difficult?
10:58:08 <Athas> I do wonder what motivated this grammar hinting, though.  I cannot think of what would have motivated its inclusion.
10:58:37 * tomsmeding neither
11:22:16 <frdg> is `monotonicity` a relevant concept in Haskell? 
11:22:46 <monochrom> Depends on context. But probably yes.
11:23:26 <monochrom> Depends on context, but monotonicity could be relevant to all computing. All computable functions are monotonic.
11:23:49 * hackage versions 4.0.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-4.0.0 (fosskers)
11:23:53 <frdg> The context I am thinking of is if I can benefit by ensuring all of my functions are monotonic.
11:24:18 <frdg> or does Haskell ensure that implicitly?
11:24:20 <koz_> frdg: mapMonotonic et al in Data.Map maybe?
11:24:27 <monochrom> The context determines which "monotonic" we're talking about.
11:24:32 <koz_> I don't think Haskell can ensure something like monotonicity.
11:24:41 <koz_> (of any stripe)
11:25:02 <monochrom> In other words, which partial order you have in mind.
11:25:27 <frdg> I know of monotonicity through learning Prolog
11:25:48 <frdg> so whatever the context is in Prolog I guess.
11:25:48 <koz_> Wait, are we talking about monotonicity of entailment?
11:26:11 <frdg> koz_: yes just found that
11:26:12 <monochrom> https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
11:26:35 <frdg> Ill read this
11:26:57 <monochrom> I don't know Prolog's monotonicity of entailment.
11:27:21 <monochrom> TLDR ctrl-f for "semantic approximation order"
11:27:22 <koz_> monochrom: It's a property of some logics.
11:27:45 <dolio> Naturally computable functions are monotone with respect to a specific partial order, not every possible partial order.
11:27:49 * hackage lp-diagrams 2.1.3 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-2.1.3 (JeanPhilippeBernardy)
11:27:51 <frdg> This post has a nice answer: https://stackoverflow.com/questions/43314658/what-are-the-requirements-a-computer-function-must-meet-to-be-considered-monoto
11:27:59 <dolio> Some of which may disagree with each other. :)
11:30:48 <tomsmeding> frdg: the monotonicity of entailment as described in that SO answer is specific to logical derivation; what would you then mean with "ensuring all of my functions are monotonic" in haskell?
11:30:49 * hackage gasp 1.3.0.0 - A framework of algebraic classes  https://hackage.haskell.org/package/gasp-1.3.0.0 (JeanPhilippeBernardy)
11:31:57 <frdg> tomsmeding: that question doesn't make sense does it?
11:32:15 <monochrom> It makes sense iff you can give examples and counterexamples.
11:32:53 <tomsmeding> in other words: strictly that definition of monotonicity doesn't really apply, but that doesn't mean there is not another definition that you have in mind that _is_ relevant :)
11:35:08 <frdg> say you had a pipeline of composed functions. A function could be "monotonic" if it's addition to the pipeline restricts the size of the codomain. If it enlarges the size then it is not monotonic.
11:36:58 <frdg> though I cannot think of any pure function that would be "non-monotonic" in this definition. 
11:38:50 <ski> what about `(>= 0) . abs' vs. `(>= 0) . subtract 1 . abs' ?
11:39:07 <frdg> restricts the size of the range not codomain. 
11:39:22 <ski> what does "restricts the size of the codomain" mean ?
11:43:03 <frdg> ski: I believe that both these function would fit this definition of monotonic if we added a rule that the function could at most preserve the size of the functions range. 
11:45:58 <ski> "monotonic" usually refers to some partial order. what is the partial order, in your case ?
11:46:48 * hackage lp-diagrams 2.1.4 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-2.1.4 (JeanPhilippeBernardy)
11:47:49 * hackage beam-postgres 0.5.0.0 - Connection layer between beam and postgres  https://hackage.haskell.org/package/beam-postgres-0.5.0.0 (TravisAthougies)
11:48:02 <frdg> skit: the size of the range.
11:48:19 <frdg> ski
11:49:57 <ski> so you define `f =< g' to mean `forall y. (exists x. f x = y) => (exists x. g x = y)' ?
11:55:38 <frdg> ski: You mean `=<` as less or equal right?
11:58:49 * hackage parsek 1.0.3.0 - Parallel Parsing Processes  https://hackage.haskell.org/package/parsek-1.0.3.0 (JeanPhilippeBernardy)
11:58:56 <frdg> ski: to me this definition would be for equality of functions.
12:00:12 <merijn> hmm
12:00:20 <merijn> Why is there no foldMapM? :\
12:01:51 <kuribas> foldTraverse?
12:02:03 <monochrom> Since M is involved, order matters now. Should foldMapM mean left to right? right to left? top down? bottom up?
12:02:18 <merijn> monochrom: eh
12:02:29 <merijn> monochrom: That matters for monoids too
12:02:39 <merijn> monochrom: So that's a bit of a non argument
12:03:01 <kuribas> left to right
12:03:25 <merijn> monochrom: Exhibit A: Alt
12:04:22 <phadej> :t Control.MOnad.foldM
12:04:24 <lambdabot> error:
12:04:24 <lambdabot>     Not in scope: ‘Control.MOnad.foldM’
12:04:24 <lambdabot>     Perhaps you meant one of these:
12:04:27 <phadej> :t Control.Monad.foldM
12:04:28 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
12:04:41 <merijn> monochrom: Perhaps you were thinking of commutative monoids? :p
12:04:48 <monochrom> No.
12:04:59 <merijn> phadej: Yeah, but then I need to write an awkward wrapper :\
12:05:07 <phadej> (a <> b) <> c = a <> (b <> c)
12:05:21 <phadej> if <> would "print" something, these will sequence effects in different order
12:05:49 * hackage parsek 1.0.4.0 - Parallel Parsing Processes  https://hackage.haskell.org/package/parsek-1.0.4.0 (JeanPhilippeBernardy)
12:05:51 <phadej> but if you don't care, then foldMapM would just work
12:06:34 <phadej> looks like rio and relude define foldMapM
12:06:37 <merijn> phadej: But that doesn't hold for "(Monad m, Monoid r) => (a -> m r) -> [a] -> m r"
12:06:47 <merijn> phadej: <> can't have an effect there
12:07:01 <merijn> phadej: That's just Alt/liftA2 (<>)
12:07:02 <monochrom> Data.Foldable.foldlM and foldrM
12:07:14 <phadej> merijn: there you can still can traverse in arbitrary order
12:07:16 <merijn> both of which have perfectly well defined semantics
12:07:20 <phadej> but I guess you'd expect `traverse` order
12:07:27 <merijn> phadej: Yes, but the traversal order also impacts the monoid
12:07:53 <merijn> The order of traversal matters for foldMap *anyway*
12:08:03 <phadej> :t \f -> fmap fold . traverse f 
12:08:05 <lambdabot> (Monoid b, Traversable t, Applicative f) => (a -> f b) -> t a -> f b
12:08:05 <merijn> So the fact that it matters for foldMapM is trivial
12:08:11 <merijn> Of course it does
12:08:11 <monochrom> Not that order. The other order.
12:08:38 <phadej> fmapTraverse should be a member of `Traversable`
12:08:46 <phadej> \f g -> fmap f . traverse g
12:08:48 <phadej> :t \f g -> fmap f . traverse g
12:08:48 * hackage flashblast 0.0.4.0 - Generate language learning flashcards from video.  https://hackage.haskell.org/package/flashblast-0.0.4.0 (locallycompact)
12:08:50 <lambdabot> (Traversable t, Applicative f) => (t b1 -> b2) -> (a -> f b1) -> t a -> f b2
12:09:40 <merijn> monochrom: Please show me how the traversal order "doesn't matter" for "Just . First" :)
12:10:25 <phadej> it doesn't matter, Maybe is commutative effect
12:10:44 <merijn> phadej: eh, it does...
12:10:50 <merijn> phadej: You get a different value
12:11:04 <phadej> you don't
12:11:31 <monochrom> evaluation order and confluence, vs execution order and effects?
12:11:35 <phadej> yes
12:11:40 <monochrom> Must I spell it out?
12:11:50 <phadej> no, let's just stop
12:12:03 <phadej> \f -> fmap fold . traverse f -- is what merijn wants
12:12:18 <merijn> Given a datatype "Foo a" the result of both foldMap and hypothetical foldMapM is dependent on the traversal order of Foo, yes or no?
12:12:47 <phadej> https://gitlab.haskell.org/ghc/ghc/-/issues/13153 looks like I'm not the only one who wants mapTraverse
12:13:27 <phadej> merijn: ...
12:14:38 <phadej> monochrom meant that if "Foo" is a tree, foldMap can reassosiate the <>, and that shouldn't matter for the end result
12:15:02 <phadej> as in, foldMap implementation may use associativity of <> to its advantage
12:15:05 <merijn> phadej: Well my type only admits the Alt monoid in which case it *doesn't* matter
12:15:22 <phadej> but that's different "order" then traverse-ing
12:16:00 <merijn> phadej: I'm trying to determine where the asssumptions diverge that leads to monochrom disagreeing.
12:16:16 <merijn> afaict the type I want only admits the Alt implementation in which case reassociating <> is irrelevant
12:16:20 <phadej> internet, where people disagree just because
12:16:41 <merijn> (well, that's a lie I guess it also admits the dual of Alt)
12:17:01 <merijn> Either way, reassociating of <> doesn't affect the result, effects or no
12:17:59 <monochrom> So you don't need a general polymorphic function that covers all Foldable instances.
12:18:02 <merijn> So only the traversal order has an impact on the behaviour of effects, but that has effect on <> anyway
12:19:38 <merijn> monochrom: Ok, so the disagreement (seems?) to be whether "foldMapM :: (Foldable t, Applicative f, Monoid r) => (a -> f r) -> t a -> f r" admits an implementation other than "\f -> getAlt . foldMap (Alt . f)"
12:20:01 <phadej> :t \f -> fmap fold . traverse f . toList
12:20:02 <monochrom> s/implementation/expectation/
12:20:03 <lambdabot> error:
12:20:03 <lambdabot>     Ambiguous occurrence ‘toList’
12:20:03 <lambdabot>     It could refer to
12:20:07 <phadej> :t \f -> fmap fold . traverse f . Data.Foldable.toList
12:20:09 <lambdabot> (Monoid b, Applicative f, Foldable t) => (a -> f b) -> t a -> f b
12:20:55 <phadej> I guess that's the same
12:21:03 <merijn> monochrom: Do you agree that "\f -> getAlt . foldMap (Alt . f)" always has the same result, regardless of any reassociating that foldMap happens to do?
12:22:16 <phadej> no that's different. Alt would have Alternative somewhere
12:22:25 <phadej> :t \f -> getAlt . foldMap (Alt . f)
12:22:26 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Alt f a1)) => (a2 -> f a1) -> t a2 -> f a1
12:22:28 <merijn> oh, wait
12:22:29 <merijn> I mean Ap
12:22:38 <merijn> my bad
12:22:44 <merijn> That's what I get for writing form memory
12:22:44 <phadej> :t \f -> getAp . foldMap (Ap . f)
12:22:46 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> f a1
12:23:11 <phadej> :t \f xs -> getAp (foldMap (Ap . f) xs)
12:23:12 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> f a1
12:23:25 <phadej> silly lambdabot, can you disable PolyKinds
12:23:41 <merijn> % :t \f -> getAp . foldMap (Ap . f)
12:23:42 <yahb> merijn: ; <interactive>:1:2: warning: [-Wname-shadowing] This binding for `f' shadows the existing binding defined at <interactive>:91:1; forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> f a1
12:23:46 <merijn> bah
12:23:58 <merijn> % :seti -XNoPolyKinds
12:23:58 <yahb> merijn: 
12:24:01 <merijn> % :t \f -> getAp . foldMap (Ap . f)
12:24:01 <yahb> merijn: ; <interactive>:1:2: warning: [-Wname-shadowing] This binding for `f' shadows the existing binding defined at <interactive>:91:1; (Foldable t, Applicative f, Monoid a1) => (a2 -> f a1) -> t a2 -> f a1
12:41:34 <Guest_85> can't install it on my ubuntu subsystem on my windows 10 machine
12:41:39 <Guest_85> bruh
12:46:24 <dsal> Oh man.  I hope whoever that is manages to get it installed.
12:46:48 <koz_> Whatever 'it' was.
12:47:41 <monochrom> People who only understand the simpleton boolean "it works / it doesn't work" shouldn't be in programming in the first place.
12:58:14 <dminuoso> monochrom: That sounds rather simpletony boolean.
12:58:35 <monochrom> haha
13:15:38 <tomsmeding> I have a function that, when I run it and measure its execution time using Criterion.Measurement.measure, alternatingly takes ~0.53 and ~0.62 seconds
13:15:53 <tomsmeding> seeing those timings made me do a double take
13:16:40 <tomsmeding> fortunately I know the cause, and the cause is unsurprisingly GC; passing +RTS -c reduces the difference to ~0.60 vs ~0.61 (though it still oscillates!)
13:18:15 <koz_> Is there a pre-rolled instance of Arbitrary for Scientific out there?
13:21:19 * hackage dsv 1.0.0.0 - DSV (delimiter-separated values)  https://hackage.haskell.org/package/dsv-1.0.0.0 (chris_martin)
13:24:07 <dminuoso> tomsmeding: That difference seems well within margin of errors, induced by things like TLB flushes on preemption, cache evictions from other threads.
13:24:35 <tomsmeding> dminuoso: also if it's fully reproducible on an intel i7 laptop as well as an amd threadripper server?
13:24:46 <dminuoso> The difference between 0.60 and 0.61?
13:24:48 <dminuoso> Id say yes.
13:24:53 <dminuoso> Or is it still alternatingly?
13:24:54 <tomsmeding> oh that one, sure
13:24:58 <tomsmeding> still alternating
13:25:01 <tomsmeding> :p
13:25:04 <tomsmeding> that's what makes it interesting
13:25:58 <dminuoso> Curious though, in the degenerate case, the GC takes that much time?
13:26:04 <tomsmeding> oh correction: the +RTS -c doesn't help om the AMD, only on the intel
13:27:06 <tomsmeding> on intel, Criterion.Measurement.measure reports an 'measGcCpuSeconds' of alternatingly about 3.6e-2 and about 7.2e-2
13:28:28 <dminuoso> tomsmeding: I wonder, could the alternating behavior happen because of some oscillating swapping?
13:28:44 <dminuoso> (swapping in the sense of swap memory)
13:29:03 <dminuoso> I admit, this is rather handwaving
13:29:19 <dminuoso> But this must clearly be something stateful
13:29:28 <dminuoso> Or..
13:29:32 <dminuoso> Hold on. When you say alternatin
13:29:40 <dminuoso> Is that within the same program execution?
13:29:41 <tomsmeding> if you mean swapping as in memory full so swap to disk, no, because memory is far from full
13:30:52 <tomsmeding> yes one process that runs the same function a number of times, and the even cases (say) are 0.62 +- 0.3 seconds, and the odd cases (say) are 0.53 += 0.3 seconds
13:46:34 <hololeap> i don't understand constraints that don't take any type variables, like HasCallStack. what are these kinds of constraints acting on?
13:48:57 <tomsmeding> you can see constraints as kind of "inferred implicit parameters"
13:49:20 <tomsmeding> where the value being passed as that parameter is a record of the functions defined in the relevant class instance
13:50:25 <tomsmeding> e.g. for a function like nub :: Eq a => [a] -> [a], under the hood it really takes two arguments: a dictionary Eq { (==) :: a -> a -> Bool }, and a list [a]
13:51:30 <tomsmeding> hololeap: and the inference algorithm for those inferred parameters is the instance resolution algorithm :)
13:52:06 <tomsmeding> from that perspective, it makes sense to also allow classes that take zero parameters; their dictionary types just happen to have no type parameters
13:52:58 <tomsmeding> now HasCallStack is a magical thing that uses the weird dynamic scoping functionality that GHC offers, so it's really a separate case :p
13:58:43 <tomsmeding> hololeap: this "dictionary" idea is actually also how type classes are implemented in GHC; see e.g. the original paper (http://ropas.snu.ac.kr/lib/dock/HaHaJoWa1996.pdf (which I haven't actually read, sorry :D)) or other resources online
14:32:04 * nshepperd . o 0 (hmm, what if defining all functions in a module in a zero parameter typeclass to resolve circular dependencies instead of using hs-boot)
15:09:49 <monochrom> HasCallStack is implemented by being an alias of an implicit parameter constraint.
15:12:11 <monochrom> Because of ContraintKinds, it can be coded as a type alias, "type HasCallStack = ?callstack :: CallStack" and then you just write "f :: HasCallStack => Int" it simply expands to "f :: (?callStack :: CallStack)  => Int"
15:14:19 * hackage antiope-sqs 7.5.2 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-sqs-7.5.2 (arbornetworks)
15:15:19 * hackage antiope-es 7.5.2, antiope-dynamodb 7.5.2, antiope-core 7.5.2, antiope-s3 7.5.2, antiope-shell 7.5.2, antiope-messages 7.5.2, antiope-athena 7.5.2, antiope-sns 7.5.2, antiope-contract 7.5.2, antiope-optparse-applicative 7.5.2 (arbornetworks)
15:16:02 <hpc> if that was anything but HasCallStack, that trick would make code unreadable with terrifying ease
17:15:23 <koz_> @pl \x -> (x, x)
17:15:23 <lambdabot> join (,)
17:25:58 <MarcelineVQ> dup
18:32:31 <texasmynsted> hello
18:43:30 <ghoulguy> hi
18:48:09 <koz_> Sup?
18:48:14 <koz_> :t dup
18:48:16 <lambdabot> error: Variable not in scope: dup
19:00:37 <texasmynsted> anybody up for making a suggestion on improving a small block of simple code?
19:02:01 <texasmynsted> heh
19:04:07 <texasmynsted> The lets look like something I should be able to remove. https://gist.github.com/mmynsted/b6df6c87056ab5582f82b8b329e39cac
19:09:52 <dsal> `(,) bad good` is a funny way to write `(bad, good)`
19:11:36 <dsal> `f (_, v) = V.toList $ V.map redirectMapToPair v`  looks a lot like   `V.toList . map redirectrMapToPair . snd`
19:11:50 <dsal> But why are you making a pair if you just want the second part?  Just don't make the tuple.
19:13:59 <dsal> Something like:  `loadUrlMap bs = V.toList . V.map f  <$>  decodeByNameWith myOptions bs   where f (RedirectMap _ good) = good`
19:14:03 <dsal> But I don't know what all that stuff does.
19:15:43 <texasmynsted> ah well. because I am applying f to the Right of an Either. The Right of the Either has a tuple where I only want the snd bit, which is a vector... 
19:16:15 <texasmynsted> I will try your suggestions. I think they are more readable in any case
19:18:47 <texasmynsted> THank you
19:20:07 <dsal> > let f (_, v) = show v   in   f <$> Right (1,2)
19:20:09 <lambdabot>  Right "2"
19:20:20 <dsal> > show . snd  <$> Right (1,2)
19:20:22 <lambdabot>  Right "2"
19:20:50 <dsal> (of course if you don't want the tuple, it's easier to just never have one)
19:20:59 <etherealemb> Which Haskell GraphQL framework would you guys suggest? 
19:21:44 <dsal> > fmap show  <$> Right (1,2)
19:21:46 <lambdabot>  Right (1,"2")
19:26:07 <texasmynsted> Okay I updated the gist with a comment, taking your suggestions. The ones I undestood.
19:26:25 <dsal> Oh, if that's vector, V.map is just fmap.  And V.toList is in Foldable.  You don't need the V.   My brain keeps trying to remove stuff you don't need there.  You may not even need Either.  heh
19:26:57 <dsal> IMO, you should really use `where` instead of `let`.  I don't think `let` is helping you here.
19:27:13 <texasmynsted> okay
19:27:32 <dsal> What is `decodeByNameWith`  ?  I think that's part of what's confusing me.  I'm making assumptions.
19:30:49 * hackage eve 0.1.9.0 - An extensible event framework  https://hackage.haskell.org/package/eve-0.1.9.0 (ChrisPenner)
19:32:11 <texasmynsted> oh that is from cassava 
19:32:13 <texasmynsted> decodeByNameWith :: FromNamedRecord a => DecodeOptions -> ByteString -> Either String (Header, Vector a)
19:33:01 <texasmynsted> it gives me the pair on the happy path and I do do not need the Header
19:33:29 <dsal> Ah, OK.  Yeah.  I thought something like that was happening, but it was kind of weird with the pair you were processing.
19:34:49 <dsal> `fmap.fmap` will let you give an `(a -> b)` to make that a `Either String (Header, Vector a) -> Either String (Header, Vector b)`
19:35:01 <dsal> But you might as well throw away the header.
19:36:50 <dsal> You could also write:   `good :: RedirectMap -> String;   good (RedirectMap _ g) = g`  and then    `loadUrlMap = toList . ((fmap.fmap) good) . decodeByNameWith myOptions`
19:37:33 <dsal> I probalby missed something there, but that might be a bit easier to read.  Unless you don't like doublefmaps, but (I put too many parens in).  In either case, separating out the function for getting goodness from RedirectMap makes it a good deal cleaner.
19:38:41 <dsal> This would be easier if I started up a GHCI
19:44:40 <dsal> You could also avoid having to write `decodeByNameWith myOptions` and then worrying about the `snd`ing by making `decode :: FromNamedRecord a => ByteString -> Either String (Vector a); decode = fmap snd . decodeByNameWith myOptions`.
19:49:09 <sm[m]> how best to configure stack ghci --ghci-options "-interactive-print=Text.Pretty.Simple.pPrint" --package pretty-simple as my default ?
19:50:04 <sm[m]> I can put :set -package pretty-simple and :set -interactive-print=Text.Pretty.Simple.pPrint in ~/.ghci, but it only works in projects where I have installed the pretty-simple package, unlike stack's --package which installs it if missing
19:50:56 <sm[m]> I wondered if there's a way other than alias stack-ghci='stack ghci --ghci-options "-interactive-print=Text.Pretty.Simple.pPrint" --package pretty-simple' 
19:53:29 <sm[m]> by the way, this is from https://github.com/cdepillabout/pretty-simple readme and seems pretty great - auto pretty printing of values in ghci
19:56:49 * hackage selections 0.3.0.0 - Combinators for operating with selections over an underlying functor  https://hackage.haskell.org/package/selections-0.3.0.0 (ChrisPenner)
20:00:49 * hackage lens-filesystem 0.1.0.0 - Lens interface for your filesystem; still a bit experimental  https://hackage.haskell.org/package/lens-filesystem-0.1.0.0 (ChrisPenner)
20:01:11 <texasmynsted> actually what I need is a mapping of bad url to good url. So the (bad, good) pair is what I am after. A list of them.
20:02:06 <texasmynsted> The strange part is that cassava is giving me (Header, Vector), I then drop the Header, and parse out the Vector to get the bad/good pair.
20:02:47 <texasmynsted> :-) Lots of good advice. Thank you so much dsal!
20:03:16 <dsal> Oh.  That's just `Map.fromList`
20:08:22 <dsal> I got super distracted by a twitch stream...
20:11:21 <dsal> So if you have    `(a -> (k,v))` and you want     `(Either String (Header, Vector a)`  ->  `Either String (Map k v))`  then that's something like     `fmap (Map.fromList . toList . fmap convert)`     (But, again, I don't have a ghci so my faulty brain is guessing.
20:11:22 <dsal> )
20:31:20 <dsal> texasmynsted:  finally got my ghci running and can confirm: https://www.irccloud.com/pastebin/IV3jl2bc/conv.hs
20:32:44 <dsal> texasmynsted: with decode as mentioned above:  https://www.irccloud.com/pastebin/w46VHMk2/
20:33:06 <texasmynsted> :-)
20:35:19 <dsal> Does that make sense?
20:35:35 <dsal> (my brain is feeling kind of sluggish tonight, so I'm surprised that typechecked)
20:46:20 <dsal> The one in the middle might look a little complicated, but it works with all Foldables, not just Vector.  Partially confusing because I didn't apply it to the `got` variable that I'd defined for that purpose:   https://www.irccloud.com/pastebin/0Gcm62uR/got.hs
20:52:37 <Squarism>  Someimes i feel ghci ":info class" gets too much with all instances listed. Isnt there just a command showing the class?
21:01:33 <ghoulguy> Not that I know of
21:01:49 * hackage lens-filesystem 0.1.0.1 - Lens interface for your filesystem; still a bit experimental  https://hackage.haskell.org/package/lens-filesystem-0.1.0.1 (ChrisPenner)
21:16:49 * hackage dhall-lsp-server 1.0.11 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.11 (GabrielGonzalez)
21:17:49 * hackage dhall-json 1.7.3 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.7.3 (GabrielGonzalez)
21:18:49 * hackage dhall-yaml 1.2.3 - Convert between Dhall and YAML  https://hackage.haskell.org/package/dhall-yaml-1.2.3 (GabrielGonzalez)
21:19:49 * hackage dhall-bash 1.0.34 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.34 (GabrielGonzalez)
21:25:20 * hackage dhall-nix 1.1.18 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.18 (GabrielGonzalez)
21:26:19 * hackage dhall-nixpkgs 1.0.2 - Convert Dhall projects to Nix packages  https://hackage.haskell.org/package/dhall-nixpkgs-1.0.2 (GabrielGonzalez)
21:27:18 * hackage dhall 1.36.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.36.0 (GabrielGonzalez)
21:28:19 * hackage dhall-docs 1.0.2 - Generate HTML docs from a dhall package  https://hackage.haskell.org/package/dhall-docs-1.0.2 (GabrielGonzalez)
22:52:15 <sim590> I have this code: https://paste.debian.net/1168059/ and I'm getting this error: https://paste.debian.net/1168060/. Why ?
22:52:31 <sim590> I don't understand what I'm missing nor what the message tries to tell me.
22:53:24 <sim590> The message is related to DHComputable, but I don't understand why I don't get any error for the usage of dhEchange and I get a message about exponentiate..
22:55:42 <shafox> I am on ghcup, with ghc-8.10.2, cabal 3.2, and this is my xmonad project that I am creating. https://github.com/shadow-fox/foxmonad however when i do cabal build, i get this error: https://gist.github.com/shadow-fox/3cb1d3639395548dc091b0b2c73df8ac
22:58:12 <sim590> (The issue is about the line 24 in the pastebin)
22:59:27 <shafox> Don't know what is wrong. 
23:01:04 <c_wraith> sim590: well, that error is referring to a line number not in the paste....
23:02:15 <sim590> c_wraith: yes. I didn't want to include confusing content.
23:02:35 <c_wraith> sim590:  anyway...  the problem is that it can't tell what instance of DHComputable you want
23:03:07 <c_wraith> sim590: an indicator comment on line 24 saying that it was the line the error was talking about would have been kind
23:03:32 <sim590> Yes. True. Sorry about that.
23:03:44 <sim590> So, I'm not using classes correctly here.
23:03:59 <sim590> Is that it?
23:04:12 <c_wraith> sim590: the DHComputable instance is chosen based on both v and b.  It can infer v from the input to exponentiate, but it has no idea what to pick for b
23:04:30 <sim590> Oh
23:04:54 <c_wraith> sim590: if you used parent_pk, it might be able to infer the type
23:05:18 <c_wraith> sim590: otherwise you could use the ScopedTypeVariables to talk about types from the signature.
23:05:39 <shafox> the xmonad-extras I believe what is failing to build.
23:05:53 <sim590> "talk about types from the signature". I assumed it was the case by default? I'm very surprised.
23:06:11 <c_wraith> by default, type variables in expressions are considered to be fresh types.
23:06:36 <c_wraith> So it will rename them internally by sticking numbers on to them
23:09:08 <sim590> OK, but in practice, it seems to me that it's infeasible for dhExchange to take variables v and b while exponentiate would take v0 as a type. Is it?
23:09:43 <c_wraith> sim590: one other thought - I'm not sure v and b should be independent in the class.  Does it make sense that the two types can be chosen independently?
23:10:11 <c_wraith> Or will the choice of one always require a particular choice for the other?
23:10:56 <sim590> Yes, I think that it makes sense since v stands for "private key" and b stands for "public key" and it could be implemented with this function for example: https://hackage.haskell.org/package/cryptonite-0.27/docs/Crypto-PubKey-DH.html#v:getShared
23:11:43 <c_wraith> That sounds like it doesn't make sense to select them independently.  It makes no sense to choose a ECDH public key and an RSA private key
23:11:45 <sim590> c_wraith: Well. Yes, the choice of one implies the other type.
23:12:02 <c_wraith> ok, good
23:12:05 <sim590> Yeah. So, I should change the signature?
23:12:12 <c_wraith> Then you can modify the class definition a little bit
23:12:45 <c_wraith> If you enable the FunctionalDependencies extension, you can tell ghc that choices of one type determine the other type.
23:13:01 <sim590> Interesting.
23:13:10 <c_wraith> I think in this particular case, they only come in pairs, right?  Either type specifies the other one?
23:13:51 <c_wraith> In that case, you would change it to    class DHComputable v b | v -> b, b -> v where ...
23:14:09 <c_wraith> that extra part from | to the where are the functional dependency
23:14:27 <c_wraith> It says that for any particular choice of type v, there can only be one b, and vice versa
23:15:12 <c_wraith> The combination of those things tells ghc not to allow instances that would violate that rule, and that it can use that rule to infer types
23:15:23 <sim590> c_wraith: Yeah, so if you specify the private key type, then a  public key type would correspond and vice versa I guess.
23:16:06 <sim590> That's very nice. 
23:16:55 <c_wraith> That should solve the issue you're running into, and be safer (it can catch cases where you mix things up while writing instances)
23:18:09 <sim590> I'm continuously learning. I have never really created classes for concrete use cases. I must admit that I don't master the technique for defining classes properly. Would you say that FunctionalDependencies is quite common pattern ?
23:18:30 <c_wraith> It is relatively common with multiparameter classes
23:18:44 <sim590> c_wraith: I guess that this is a good benefit for the library I'm writing.
23:19:15 <sim590> Right. This is the first time I use multiparameter classes so that's why I discover this now.
23:19:47 <c_wraith> like, you're using MonadState there.    class Monad m => MonadState s m | m -> s where ...
23:20:20 <c_wraith> That only goes one direction.  The monad type must always specify the state type, but you can have multiple different monad types specify the same state type
23:20:27 <sim590> Ohhh. So that's what that part (m -> s) meant in the documentation.
23:20:35 <c_wraith> yep!
23:20:42 <sim590> Nice
23:21:12 <sim590> Thanks for all those explanations!
23:21:17 <c_wraith> you're welcome
