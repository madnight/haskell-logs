00:01:04 <dsal> If so, then the type of that list will always be the same and can have values represented by any of the constructors.  If you mean something else, I don't know what that'd be. (I don't understand what your forall is intended to do).  You can't have a list of an unspecified type meaningfully.
00:02:05 <dsal> I think it'd be easier to understand what the code your were trying to write with this these data types would be doing instead of how you think you'd express the types.
00:02:33 <dsal> But I meant to go to bed before midnight, and failed, so oops.
00:22:20 <dminuoso> I extract a list of IP addresses, and I want to bring them into a data structure in which I can coalesce adjoined IP ranges, or at give a coalesced representation.
00:22:50 <dminuoso> For the purpose of this, we could also consider IP addresses as just numbers, so Im getting a list of numbers (or some of them might be intervals).
00:25:26 <dminuoso> My initial instinct was to just build up a binary trie and make some kind of algorithm on that, but I cant find a trivial algorithm for that
00:26:23 <dminuoso> There's of course the very naive approach of just taking the list, sorting it, and fusing adjoined neighbors repeatedly, but that has poor complexity
00:28:03 <MarcelineVQ> What does 'coalesce adjoined IP ranges' mean?
00:28:49 <dminuoso> So say the list consists of ["10.0.0.0/24", "10.0.1.0/24", ...] I want those first two to merge into ["10.0.0.0/23", ...]
00:29:30 <dminuoso> Or, in terms of a more numeric view, if I have [Range 1 1, Range 2 2, Range 3 5, Range 6 7], I want to turn that into [Range 1 5, Range 6 7]
00:29:58 <dminuoso> Not necessarily directly, just some data structure in which I can coalesce them 
00:30:12 <dminuoso> Oh wait
00:30:14 <dminuoso> THat example was bad
00:30:21 <dminuoso> that should turn into [Range 1 7] of course
00:30:47 <dminuoso> But if it was [Range 1 1, Range 2 2, Range 3 4, Range 6 7], then that should become [Range 1 4, Range 6 7], so I get all continguous ranges merged together
00:31:04 <MarcelineVQ> sort of an ip interval-map?
00:31:17 <dminuoso> Right
00:34:52 <outerpassage> cabal seems to ignore the --bindir flag for v2-build, any ideas why that might be happening?
00:45:04 <jackdk> back up another step; why do you want to do this thing?
00:45:11 <jackdk> Squarism: ^
01:33:54 <mimi_vx> bgamari: hello, who is responsible for uploading GHC source to Hackage ? hackage known ghc-8.10.1 as latest, which cases for examle for hie-bios and similiar packages with defined depends on ghc
01:34:54 <mimi_vx> maybe hvr ? ^^
02:25:48 * hackage free-functors 1.2.1 - Free functors, adjoint to functors that forget class constraints.  https://hackage.haskell.org/package/free-functors-1.2.1 (SjoerdVisscher)
02:30:45 <gentauro> if I use the `network` package: https://hackage.haskell.org/package/network, can I then build the binary on a Windows 10 box?
02:31:35 <sm[m]> yes
02:32:20 <gentauro> sm[m]: are there any "specific" *nix packages that can't be build on a Windows 10 box?
02:32:39 <gentauro> if yes, would it give sense to add that to `hackage`?
02:33:49 <sm[m]> gentauro: unix is one; vty is another
02:34:24 <sm[m]> Yes it would be nice to see that clearly on hackage, I'm not sure if it is shown
02:36:13 <sm[m]> basically I think if it depends transitively on unix, that's the signal
02:36:35 <jackdk> gentauro: make sure you have MSYS set up and that cabal knows about it. otherwise you'll get failures on any package that wants to run a `configure` script
02:37:08 <gentauro> jackdk: thx
02:37:10 <jackdk> the haskell-dev chocolatey package should do this correctly if you do a clean install
02:37:39 <jackdk> which I think is the current recommended way to get haskell on windows, but it's not an area I'm enormously familiar with
02:37:57 <sm[m]> using stack is the easiest
02:38:53 <gentauro> sm[m]: I intend to use `stack`, but it seems that `MSYS` is needed
02:39:09 <sm[m]> stack provides it
02:39:23 <sm[m]> or ghc does, I'm not sure
02:41:27 <gentauro> sm[m]: roget that. I will give it a try and if it fails, I will install MSYS
02:41:32 <gentauro> (as well)
02:41:44 <sm[m]> the stack binary is all you need to build most of hackage on windows
02:43:40 <gentauro> oh. So jackdk might sugested that `MSYS` is needed when only using `cabal`. Got it (I think)
02:45:27 <jackdk> I don't remember whether the stack installer brings along MSYS or not. But whatever build tool you use, you will need a way to run configure scripts, and that way is MSYS these days
03:02:27 <phadej> mimi_vx: `ghc` is not buildable package. It's uploaded to hackage purely for haddock purposes
03:03:07 <mimi_vx> phadej yes, but for example try build hie-bios on system with ghc-8.10.2 
03:03:33 <mimi_vx> phadej: using cabal , from hackage
03:04:02 <fl0_id> hey, what is a good way / guideline to compile ghc (etc) for repackaging? this is necessary for conda-forge (conda-forge.org) so that we do not rely on distribution packages. And because of the old ghc version used by centos 6, I think I would have to start from ghc 7.4 to bootstrap. It just give weird linker errors and stuff like that. Is here a good place to ask questions about that?
03:04:14 <mimi_vx> phadej: you end with https://pastebin.com/TvXYZ8d1
03:05:01 <mimi_vx> phadej: so not only haddock docu , but also dependency resolution for packages which depends on GHC
03:05:24 <maerwald> fl0_id: is conda-forge centos7 compatible?
03:05:53 <mimi_vx> phadej:  well , prtially main problem is different base package for 8.10.1 and 8.10.2
03:06:21 <phadej> mimi_vx: are you sure you don't have some freeze file or something which makes solver want to pick up 8.10.1
03:06:29 <phadej> because there is no such bound on hie-bios itself
03:06:32 <mimi_vx> clean cabal
03:06:39 <mimi_vx> hie-bios depends onb ghc
03:07:00 <mimi_vx> and hackage return as last ghc 8.10.1 which has base 4.14.0.0
03:07:07 <maerwald> I don't think the solver looks up the ghc package from hackage, because it's always installed with a GHC
03:07:21 <fl0_id> maerwald it is an option yes, but by default it is centos 6
03:07:35 <phadej> he left
03:07:37 <mimi_vx> but ghc 8.10.2 has base 4.14.1.0 so it isnt possible satisfy ghc deps of hie-bios
03:07:40 <fl0_id> and still centos 7 uses an non-current ghc iirc
03:07:44 <maerwald> fl0_id: https://downloads.haskell.org/~ghc/8.0.2/ghc-8.0.2-x86_64-centos67-linux.tar.xz
03:07:46 <phadej> mimi_vx: I don't believe you, https://pastebin.com/3vsPE9z9 it works here
03:07:47 <phadej> fine
03:07:59 <maerwald> fl0_id: https://downloads.haskell.org/~ghc/8.6.5/ghc-8.6.5-x86_64-centos7-linux.tar.xz
03:08:05 <phadej> hie-bios doesn't have 4.14.1.0 bound
03:08:12 <phadej> or specifically, hie-bios-0.7.1
03:08:22 <mimi_vx> hmm, -w flag 
03:08:38 <fl0_id> maerwald yeah, that I know. but we want to build because there are no binaries for aarch64 and ppc64le at least.
03:08:47 <maerwald> ah
03:08:56 <fl0_id> (or at least not anymore / not consistently)
03:09:09 <maerwald> yeah, that's gonna be fun, you might get more help in #ghc
03:09:48 <fl0_id> mmh ok
03:10:09 <fl0_id> maerwald thansk
03:10:24 <phadej> mimi_vx: your paste is unclear, it doesn't tell whether `ghc` in your path is ghc-8.10.2 or some else
03:12:36 <mimi_vx> phadej: https://pastebin.com/HL8dRErY
03:14:07 <phadej> I'm sure that either you are in a project folder, or you have ~/.ghc/*-8.10.2/default or something which confuses the solver
03:14:24 <mimi_vx> no 
03:14:32 <mimi_vx> look at paste ...
03:14:35 <phadej> but you removed them, so I don't know what's wrong on your system
03:14:37 <mimi_vx> claen , after rm
03:14:47 <mimi_vx> clean system ghc-8.10.2
03:15:10 <mimi_vx> and [__2] rejecting: base-4.14.1.0/installed-4.14.1.0 (conflict: ghc => base<0 &&
03:15:11 <mimi_vx> ==4.14.*)
03:15:48 <mimi_vx> states installed base-4.14.1.0 --> shipped with ghc-8.10.2
03:15:51 <phadej> yes, that is a way to say "don't ever try to reinstall base"
03:16:59 <mimi_vx> phadej: nobody reinstalled / upgraded base outside shipped with ghc, and ghc-8.10.2 updated version of base
03:17:02 <phadej> what your `ghc-pkg list` says
03:19:27 <mimi_vx> phadej: https://pastebin.com/AzWHkt0Y
03:20:06 <phadej> that is screwed one, why there is so much stuff?
03:20:11 <phadej> and specifically, there is no `ghc`
03:20:35 <phadej> do you try to use systems' own GHC on some bleeding edge distro? (don't)
03:21:24 <phadej> you probably do, because "/usr/lib64/ghc-8.10.2/package.conf.d"
03:21:45 <phadej> why they remove `ghc` package, I don't know. But that means there is no way you can install hie-bios
03:21:55 <phadej> `ghc` is not buildable with cabal-install
03:22:14 <phadej> complain to your distro packages.
03:22:16 <mimi_vx> ahh, thx
03:22:17 <phadej> packagers*
03:22:52 <mimi_vx> now find why isnt correctlyu added ghc-8.10.2 to package config
03:23:24 <maerwald> arch linux? :p
03:27:18 * hackage lists-flines 0.1.0.0 - Additional data and structures to some 'String'-related lists.  https://hackage.haskell.org/package/lists-flines-0.1.0.0 (OleksandrZhabenko)
03:57:19 * hackage stylish-haskell 0.12.1.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.12.1.0 (JasperVanDerJeugt)
04:04:48 * hackage lists-flines 0.1.0.1 - Additional data and structures to some 'String'-related lists.  https://hackage.haskell.org/package/lists-flines-0.1.0.1 (OleksandrZhabenko)
05:08:48 * hackage acc 0.1.3 - Sequence optimized for monoidal construction and folding  https://hackage.haskell.org/package/acc-0.1.3 (NikitaVolkov)
06:02:18 * hackage haskell-lsp-types 0.23.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.23.0.0 (luke_)
06:03:18 * hackage haskell-lsp 0.23.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.23.0.0 (luke_)
06:31:32 <gentauro> is there a way to find the code for `tuples` with `hoogle`? (tuple as in: `( 42, 'a')`
06:37:19 <dminuoso> code for tuples?
06:37:35 <dminuoso> What exactly are you looking for?
06:45:30 <frdg> `equal xs ys =  subset xs ys && subset ys xs`. Is there a general way to apply this function in both directions instead of explicitly calling subset twice?
06:48:18 <dminuoso> Nothing as concise.
06:49:53 <frdg> ok
06:51:47 <dminuoso> frdg: There's of course the option to define some `symmEq p x y = p x y && p y z`, which can be handy if you define a bunch of functions like equal.
06:52:18 <dminuoso> (Or well, call it symm rather than symmEq, but you get the idea)
06:52:37 <dminuoso> But if this is just a one-off, I'd just write it like you put it
06:54:50 <frdg> yes I went to write something like symm, but I see why its kind of just extra confusion.
06:56:39 <gentauro> dminuoso: just the place in GHC where `tuples` are handled :)
06:57:14 <gentauro> like I wrote: `( 42, 'a')` but also `( 42, 'a', "b")`
06:57:27 <dminuoso> What do you mean by "handled" exactly?
06:57:35 <dminuoso> Do you want to know how tuples are defined in GHC?
06:57:48 <dminuoso> https://hackage.haskell.org/package/ghc-prim-0.6.1/docs/src/GHC.Tuple.html#%28%2C%29
06:58:10 <dminuoso> (Im not sure whether that code is actually used, or whether that's just for haddock assistence)
06:58:13 <[exa]> gentauro: there's some desugaring to (,) (,,) (,,,) ..., and the data is AFAIK defined normally using `data`
06:58:40 <dminuoso> The import at the top of the module suggests that is the real definition
07:00:02 <[exa]> btw why is everyone using a b c d e f... for tuple variable names instead of a1 a2 a3 (which are noticeably better for determining how long the definition actually is) ?
07:00:39 <dminuoso> Half as many characters?
07:00:58 <dminuoso> Also, there's a common theme of enumerating letters
07:01:05 <dminuoso> type Lens s t a b = ...
07:01:20 <dminuoso> That also pervades much of mathematics
07:02:08 <[exa]> I still kinda hope that no one is going to use say 14-tuple, so won't need to remember that it should end with `n`
07:02:58 <[exa]> but seriously for mechanical code like this I find the usage of a b c d ... followed by a1 b1 c1 ... well counterintuitive. :]
07:03:06 <dminuoso> Im quite confident large tuples are used amongst postgresql-simple users.
07:03:33 <dminuoso> query conn qry (a, b, c, d, e) ...
07:04:25 <[exa]> jiribenes:  o/
07:05:10 <[exa]> hm yes, relations, forgot about them again.
07:05:24 <gentauro> 15:57 < dminuoso> Do you want to know how tuples are defined in GHC?
07:05:25 <gentauro> yes
07:05:31 <gentauro> 15:57 < dminuoso> https://hackage.haskell.org/package/ghc-prim-0.6.1/docs/src/GHC.Tuple.html#%28%2C%29
07:05:37 <gentauro> I didn't expect this …
07:06:14 <[exa]> straightforward right? :D
07:07:08 <dminuoso> Nobody expects the spanish inquisition.
07:08:00 <gentauro> what would it take to convert `GHC.Tuple` to `GHC.TupleWithLabel` => `GHC.AnonymousRecord`?
07:08:11 <gentauro> s/convert/derive/
07:08:18 <dolio> I think they decided long ago that it was easier to just make GHC handle the illegal declarations than to hack them in.
07:09:22 <dminuoso> And then have their users tell customers to just go for Agda if they wanted custom mixfix, while using it themselves!
07:10:26 <dolio> Well, it still needs to be special cased.
07:10:49 <dolio> It's probably just less special cases.
07:12:12 <noctux> "Manuel says: Including one more declaration gives a segmentation fault."
07:12:22 <noctux> good to know :P
07:12:50 <dminuoso> noctux: Amusingly it was never discovered why
07:12:56 <dminuoso> The bug could still be there.
07:13:44 <dminuoso> Rather than identifying memory corruption, it was deemed easier to comment them out and hope for the best. :p
07:14:53 <Squarism> jackdk. Sorry, work happened. I want users of the library be able to write a their own type that we can call TheirType. It must only contain the allowed elements and nodes need to be of a certain type. I want to use TH to to generate the posted datastructure from TheirType. That will later be used to create a serializable index to parts of the datastructure. I need it to be serializable so I can send it over the wire.
07:15:01 <noctux> till the day of the 63 element tuple appears :p
07:16:27 <Squarism> jackdk, or the structure I posted is something I know I can construct a serializable index for. 
07:16:51 <Squarism> as in paths to leafs in the datastructe. 
07:20:42 <shapr> yay, #haskell 20th anniversary is in 30 weeks!
07:36:52 <Cheery> I just got to examining how relax NG works and wow that thing is named badly.
07:38:32 <Cheery> well maybe it signifies the problem in HTML5 and pals.
07:42:14 <fog23> i tried c# the other day, they dont even have sum types!? 
07:42:43 <shapr> we got sum type
07:42:59 <dminuoso> Most languages dont have sum types...
07:43:00 <fog23> they were saying "dont use haskell - you wont be able to get a job" and i was like - but i can actually express programs!!
07:43:14 <dminuoso> Or very poor support for mimicing.
07:43:29 <dminuoso> Pythonistas get away by just using dictionaries everywhere.
07:43:38 <davve> stark contrast between C# and haskell
07:43:51 <fog23> yeah, i eventually managed to write maybe using somehting like "enums and generic classes" but it was a total mess
07:44:51 <fog23> and, it did not seem like it was even worth trying to do "generics" as they call it - basically polymorphic type restrictions 
07:45:05 <fog23> where it would need eg a list of types at type level
07:45:08 <dolio> If you need to do .net stuff, it's probably worth looking at F#.
07:45:18 <fog23> i could hardely even *write* a list!!
07:45:49 <fog23> dolio: the closet thing to .net i ever thought of using was node
07:46:20 <[exa]> fog23: luckily for you, c# has auto-maybe on almost everything!
07:46:28 <Uniaika> [exa]: hahahaha
07:46:32 <Cheery> I'd love to bash C#, but it's bit of stale because it's too easy.
07:46:39 <fog23> they kept shouting at me for trying to use a "cons list" instead of their built in version
07:47:06 <fog23> [exa] i only wanted maybe to write list...
07:47:35 <fog23> List a = Maybe (a,List a)
07:47:45 <fog23> (they have pairs at least)
07:48:38 <fog23> it just left me totally exasperated. how can this be a more industrially applicable language than haskell!?
07:48:47 <dminuoso> 16:46:18        fog23 | they kept shouting at me for trying to use a "cons list" instead of their built in version
07:48:55 <dminuoso> You insist on not following a language idioms.
07:49:09 <dminuoso> There's little value in being thickheaded and trying to write C# as if it were Haskell
07:49:32 <fog23> everything i understand is built around get/set ! i worked for a full year just on the traverse class
07:50:02 <fog23> the idea of not even being able to *express* a cons list made my skin crawl
07:50:15 <dminuoso> And "industrially applicable" depends on factors such as "how well is the implementation", "how stable it is it", "how much tooling do you have", "how is library support for your problem domain", "how many developers can you easily get"
07:50:48 <dminuoso> And for what its worth, .net has linked lists.
07:50:52 <fog23> i was trying to justify why a cons list is so important
07:51:00 <dminuoso> They are doubly linked, but oh well
07:51:13 <fog23> i guess thats what industry would need to understand - i hadnt realised what a large difference there was 
07:51:28 <fog23> and that the fundamental stunbling block would be something as simple as sum types
07:51:29 <dolio> They're probably mutable linked lists, so you have to be careful what you do with them.
07:51:38 <dminuoso> Im willing to argue that cons lists are not even so important in other languages. 
07:51:55 <fog23> right, but why are they so useful to us
07:51:59 <fog23> that more to the point
07:52:11 <fog23> that would be "why should industry use haskell"
07:52:11 <dminuoso> We encode control flow in lists
07:52:21 <dminuoso> Other languages just do some imperative take with a for-loop.
07:52:21 <fog23> but why is that better
07:52:49 <dminuoso> Well, its only better because we've built an entire eco system around the idea.
07:52:50 <fog23> i began trying to talk about higher order functions
07:53:02 <dminuoso> Let's take C++ for instance
07:53:18 <fog23> and about the ubiquity of the church state duality - but i dont think they were ready 
07:53:25 <dminuoso> Looping over things in C++ requires using iterators
07:53:30 <dminuoso> Or manual for loops
07:53:51 <fog23> i mean, what can we *do* with our "enhanced ecosystem" 
07:54:22 <dminuoso> Does it matter? The relevant point is, trying to transport "the idea that florishes in Haskell" and "insisting it must be useful in another language because its useful in Haskell" is a very poor start.
07:54:36 <fog23> i just take the "style" for granted, and not actually being able to understand how they can do anything at all without GADTs and tail recursion - i couldnt easily say why haskell was better
07:54:54 <dminuoso> Most of the time, its better to just accept the other languages paradigms, and write idiomatic (in their language) code instead.
07:55:07 <dminuoso> The code ends up less convoluted and more maintainable
07:55:09 <dminuoso> Strangely
07:55:14 <fog23> but what could that enable, and what would it lose?
07:55:17 <Cheery> I just recently figured out dhall is really short distance away from a markup language.
07:56:00 <fog23> sure, i get how the "idiomatic" code is easier to read and write
07:56:16 <fog23> but, everything i do is based on traversals 
07:56:33 <dminuoso> Well, people coming over to Haskell have the same exact problem.
07:56:33 <fog23> i thought it was everything anyone *could* do
07:56:54 <dminuoso> Everything they do is ad-hoc imperative manipulation of state, and they cant figure out how to translate the *idea* into something declarative
07:57:16 <dminuoso> This is the same, just in reverse.
07:57:16 <fog23> right, but thats more like just restating the point about idioms
07:57:20 <fog23> yeah
07:57:47 <fog23> i was trying to understand what we actually gain from the syntax built to facilitate lazy recursion
07:57:48 <Cheery> if you think about things such as html, how is it deconstructed or constructed?
07:58:03 <Cheery> if you wanted to examine it from what it encodes usually.
07:58:11 <fog23> idk! its top down evaluation right?
07:58:29 <fog23> we have more of an AST right? like a "lambda tree" or something
07:59:12 <fog23> like *everything* is made by functional binding and dereferencing, with no top down evaluation at all
07:59:27 <fog23> i guess thats the main difference between imperative and functional programming...
07:59:54 <fog23> so i cant really see how you could speak of "producers/consumers" in HTML
08:00:08 <dminuoso> Well, formally that's the difference between call-by-value and call-by-name/need
08:00:32 <fog23> to do with the top level let bindings?
08:00:52 <fog23> i guess we do alot with precedence 
08:00:53 <dminuoso> Interestingly, in C++ the term "call-by-value" is grossly misunderstood, as people have introduced something called call-by-reference. 
08:01:04 <dminuoso> But that no longer is about evaluation semantics, but oh well. 
08:01:27 <fog23> whats the upshot of these 3 different things?
08:01:52 <fog23> call by name/value/reference...
08:01:59 <dminuoso> Well, call-by-value just means to evaluate an argument before you enter the function
08:02:07 <dminuoso> call-by-need/name does not
08:02:07 <Cheery> fog23: producer outputs the html. For example template generators or website backends, etc...
08:02:10 <fog23> "enter a function" ?
08:02:12 <dolio> I think they say 'pass' instead of 'call'.
08:02:30 <dminuoso> dolio: You'd lose on a google fight on this one.
08:02:33 <Cheery> fog23: consumer is what reads and interprets html.
08:02:34 <fog23> Cheery: why are you speaking about code generation though?
08:02:55 <dminuoso> But you might be right that that's more common. Still, the phrase "call by reference" is used far too foten
08:03:02 <Cheery> fog23: because if I want to describe a type, I'd like to describe it through how it's constructed and destroyed.
08:03:07 <fog23> i still have no idea what they mean...
08:03:39 <fog23> Cheery: right, we have recursive datatypes, but thats no like, HTML
08:04:27 <dolio> dminuoso: Well, if they did say 'pass', it could be excused, at least. :)
08:04:34 <dminuoso> dolio: https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference
08:04:38 <dminuoso> There's an article entry even! :)
08:05:06 <fog23> hmm, so its to do with making copies?
08:05:12 <dolio> Well, you can't trust wikipedia.
08:05:12 <fog23> so haskell we copy everything right?
08:05:26 <fog23> thats just purity?
08:05:37 <fog23> i guess its since we hide the memory access
08:05:58 <fog23> though Mutable vectors and mutable variables in ST or IO kind of get round that.
08:06:28 <dminuoso> fog23: My point is just, evaluation wise, there's call-by-value, call-by-need/name, call-by-future, perhaps Im forgetting something more exotic here. What's called "call-by-reference" is about copying/referencing. But that's not about evaluation.
08:06:56 <fog23> seems basically like its "calling a method with an input variable, can change that variable, even if it is not returned as an output" 
08:07:29 <fog23> no wonder they have so much bugs
08:07:31 <dminuoso> Well if we dig deep into C++, then reference have so much subtleties to them
08:07:40 <dminuoso> It's very very complicated.
08:07:52 <fog23> no i really dont care
08:08:14 <fog23> this brief foray into c# was not something i wnat to do again in a hurry 
08:08:30 <fog23> it just left me completely dismayed at the state of reality 
08:08:56 <fog23> what a sad state the world is in - with all of these primitive evaluation strategies 
08:09:07 <fog23> but that industry would *enforce* them - ey gads
08:09:28 <fog23> "you should learn our idom - then we will pay you". seems like some kind of cooked nepotism 
08:09:37 <fog23> crooked*
08:09:56 <fog23> idiom* 
08:14:09 <fog23> oh, speaking of linked lists. can you have a doubly linked tree?
08:14:24 <dolio> Yes.
08:14:31 <fog23> if so there might be a way to have "upwards facing branches" 
08:14:36 <fog23> does that sound possible?
08:14:54 <fog23> like, if you refer to the branches above as well as the branches below, because of the double link
08:15:23 <fog23> so then you could put a *different* upper part of the tree as an upwards branch
08:16:44 <fog23> or something like a "highway" reference, to a lower portion of the tree - though thats not a "doubly linked" idea. more like double link -> upwards reference -> multiple upwards references -> referring to "elsewhere upwards" -> refereeing to "elsewhere downwards" 
08:17:04 <fog23> or is that completely impossible
08:17:11 <fog23> what would be difficult about that?
08:19:19 * hackage prolude 0.0.0.1 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.1 (saramuse)
08:21:03 <fog23> dolio: how would you write a doubly linked tree?
08:22:32 <dolio> Just like a doubly linked list, except it's a tree. You have parent pointers in addition to child pointers.
08:23:38 <fog23> pointers!?
08:24:00 <fog23> Tree = Free Nonempty 
08:24:05 <fog23> thats pretty easy
08:24:06 <dolio> Doubly-linked stuff usually only works out well with pointers.
08:24:16 <fog23> rrg
08:24:22 <fog23> i dont understand
08:24:29 <fog23> where are the pointers in the regular tree?
08:24:36 <fog23> the lower branches?
08:24:40 <dolio> Yes.
08:24:46 <fog23> why are you calling them pointers?
08:25:21 <fog23> DBLTree = Free (\a -> Nonempty a, Nonempty a) 
08:25:22 <fog23> ?
08:25:29 <fog23> erm
08:25:38 <fog23> DBLTree = Free (\a -> (Nonempty a, Nonempty a) )
08:25:56 <fog23> thats like, branches below and branches above
08:26:07 <fog23> oh, i guess it would be just *a* branch above
08:26:21 <fog23> DBLTree = Free (\a -> (a, Nonempty a) )
08:26:54 <sm[m]> I use a doubly linked tree, using laziness to tie the knot
08:26:57 <fog23> (that `a' is going to be replaced by DBLTree a by Free)
08:27:15 <fog23> sm[m] can you paste that?
08:27:27 <sm[m]> (not a literal tree but a tree-shaped set of ADTs)
08:28:03 <fog23> but is that DBLTree written using Free correct?
08:29:14 <fog23> oh right, there is nothing intrinsicly built into the "data" syntax that allows the upper refference to be passed into the reference below
08:29:25 <fog23> might be a pretty cool functional language that could do that!
08:30:11 <fog23> i cnt get my head round how to do the several upwards pointing branches
08:30:40 <sm[m]> fog23: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Account.hs#L93 is one place
08:31:32 <fog23> i guess, the lower branches are like, by default "tree shaped" and there is no ambiguity - but just putting the extra list of beanches, where these are *supposed* to refer upwards - is not actually something thats built in using the GADT syntax
08:31:48 <fog23> so it kind of feels, incomplete
08:33:49 <fog23> sm[m] ah, so there is nothing intrinsic about the record that makes it a parent until you use that knot tying function 
08:33:59 <fog23> i guess thats what makes it "complete"
08:34:26 <fog23> but this feels so clumsy, like, that the GADT is only actually specified correctly based on the function that ties the knot 
08:34:50 <fog23> while, if there is no knot tying, then the lower branches are exactly that, just by construction
08:35:58 <fog23> well, i guess that means Free (\a -> (Nonempty a,Nonempty a)) *is* a valid way to do the "upwards branches"
08:36:07 <fog23> and i just need to do the knot typing function for it
08:36:38 <fog23> so how does this work, you pass in Nothing... and then...
08:37:17 <fog23> that acts as the parent of the top node
08:37:36 <fog23> and then it recurses, and has a node above to pass in for all the lower branches, that seems easy enough
08:37:56 <fog23> i guess it becomes more difficult when there is this, having to tie various different upper nodes
08:38:13 <fog23> there would have to be some way of directing which upper nodes were supposed to be referenced
08:38:14 <sm[m]> fog23: good question.. this seems to accept a tree of Account, and recurses through tying the knot for each one to its parent
08:38:28 <sm[m]> https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Transaction.hs#L563 is a simpler example
08:40:19 <fog23> sm[m]: i dont see a recursive call to txnTieKnot, so im guessing its not a tree, or recursive datatype 
08:40:45 <fog23> ah, right, so its to do with "descending" into the tree, by recursive calls
08:40:52 <sm[m]> right, txnTieKnot just ties the knot for the postings of a single transaction
08:40:56 <fog23> then you always have the current node to pass in for the upper reference
08:41:23 <fog23> so that typing many knots would be more difficult, since you cant just use the current position
08:41:29 <fog23> typing*
08:41:29 <sm[m]> data types: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Types.hs#L490, https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Types.hs#L332 
08:42:47 <fog23> ah, ok, so Account contains reference to [Account] as one of its records, but Transaction has no reference to Transaction at all, so its not a recursive datatype
08:43:25 <fog23> unless one of its records refers to Account
08:43:31 <fog23> Transation*
08:43:35 <fog23> which i guess it must...
08:44:34 <fog23> ah yes, its Posting https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Types.hs#L285
08:44:39 <fog23> that has a maybe Transaction
08:44:42 <sm[m]> Transaction refers to Posting which refers back to Transaction, this one is a tree of two types.. yep
08:44:48 <fog23> ok, this all seems quite straitforwards
08:45:17 <fog23> but again, this is a natural recursive function
08:45:24 <sm[m]> that's haskell for you.. no big drama :)
08:45:41 <fog23> and the "order of visitation" intrinsic, means it always has the think needed to tie the knot
08:46:19 <fog23> but if im trying to tie the knot on several upwards pointing branches - then i dont have those values available while descending by recusing 
08:46:40 <fog23> thing* 
08:46:44 <sm[m]> you could pass them down as you build the tree ?
08:46:57 <fog23> you mean, pass them up?
08:47:05 <sm[m]> (but that wouldn't be called a tree, right ? dunno)
08:47:14 <fog23> well its a cyclic tree
08:47:31 <fog23> im not sure if there is need to distinguish which is the "natural" parent
08:47:42 <fog23> or if all of the upper nodes are...
08:48:09 <fog23> hmm, i guess only one of them actually has the branches below that contain the branch that is with the upwards knots
08:48:13 <fog23> argh, so complicated
08:48:19 <fog23> (no drama, yeah right)
08:48:51 <fog23> or should all the nodes that can be refered to from some upwards knots - have these lower branches
08:48:59 <sm[m]> time for some prototyping !
08:49:05 <fog23> then you would have several different paths having to have the same branches
08:49:17 <fog23> sm[m] you cant understand the human words?
08:49:25 <fog23> i dont think i can manage the types just yet
08:49:30 <fog23> still total confusion
08:49:53 <sm[m]> I don't want to think to hard here (and have to go), sometimes a little tinkering helps the thinking
08:50:11 <fog23> the main question - if i can manage to phrase it is;
08:50:15 <fraktor> This might be a dumb question, but why isn't `map` defined as just `fmap` so that every monad can use `map`?
08:50:40 <fog23> do the nodes have the same branches below
08:50:45 <dolio> Because people in 1998 thought a map specialized to lists would be helpful.
08:50:55 <fog23> that would require copying right?
08:51:02 <fog23> thats also something GADTs dont do
08:51:13 <fog23> and then i just melt in despair 
08:51:19 <lortabac> dolio: to be honest I still think so
08:52:12 <fog23> how can i ensure the downwardly referenced branches that are "common" between two paths, are references to the same thing?
08:52:31 <fog23> i think i need imperative style reference by call value name or whatever it is
08:52:59 <fraktor> dolio: I don't understand why that is. Was it an optimization thing?
08:53:16 <dolio> No. Teaching, I think.
08:53:28 <fog23> or nonlinear logic in GADT construction, or some other kind of unheard of language functionality
08:53:35 <fog23> maybe i should just give up 
08:54:50 <dolio> There were multiple changes like that. (++) used to be mplus. List comperehensions were generalized to monads (which you can turn on in GHC again).
08:55:10 <fog23> fraktor: turns out some languages *only* have lists. so that these were considered kind of fundamental constructions, traditionally, during language design. we have list comprehensions, also, because this is actually ubiquitous in mathematics also, with set builder notation using "lists" as the kind of natural container
08:55:59 <fog23> something something partial ordering - ranging over integers etc
08:55:59 <dsal> lortabac: Why do you think map specialized to lists is a good idea?
08:56:11 <fog23> total ordering*
08:56:31 <fog23> its Enum right?
08:56:33 <fog23> > [1..3]
08:56:36 <lambdabot>  [1,2,3]
08:57:06 <fog23> so thats the fundamental structure of a ring
08:57:13 <lortabac> dsal: because I don't want to use overloading when I don't need it
08:57:18 <fog23> or, a ring without multiplication, whatever that is
08:57:25 <fog23> a monoid i guess
08:57:32 <dsal> > fmap succ [1..4]
08:57:35 <lambdabot>  [2,3,4,5]
08:57:47 <dsal> lortabac: if map were fmap, it'd just work.
08:57:56 <fog23> hmm, i guess you need a unit as well as an identity to get enum
08:58:06 <fog23> Enum = Monoid + Unit
08:58:15 <fog23> and then thats naturally "list like"
08:58:43 <fog23> and since things like the integers are like that, we basically have lists everywhere we have monoids, which is everywhere we have things like (+)
08:58:51 <fog23> which is basically everywhere!
08:59:01 <fog23> so yeah, lists are kind of totally fundamental
08:59:09 <sm[m]> but error messages would be more confusing making the language harder for learners, right
08:59:11 <tdammers> geez, it's much simpler
08:59:34 <tdammers> lists are concrete enough that someone new to the language and FP in general can grasp the concept and understand `map`
08:59:49 <fog23> thats not why they are ubiquitous in maths though
08:59:54 <tdammers> just like natural numbers are concrete enough that someone new to basic algebra can grasp the concept of a binary operation such as addition
09:00:14 <fog23> and its because of *that*, which makes haskell good for learning
09:00:22 <fog23> precisely because of []
09:00:56 <tdammers> you can probably say that enough things are list-like to make lists a good concept to have
09:01:20 <fog23> thats why, similar to matlab, haskell is considered as a more naturally mathmatical syntax - so better for math/sci majors 
09:01:25 <sm[m]> agreed!
09:01:37 <fog23> but then so are trees
09:01:37 <sm[m]> (tdammers)
09:01:42 <fog23> (obvs)
09:01:48 * hackage boilerplate 0.0.1 - Generate Haskell boilerplate.  https://hackage.haskell.org/package/boilerplate-0.0.1 (tseenshe)
09:02:10 <fog23> and so are graphs! but as far as i can tell no language yet supports their representation
09:02:17 <lortabac> :t fmap succ
09:02:19 <lambdabot> (Functor f, Enum b) => f b -> f b
09:02:22 <lortabac> :t map succ
09:02:24 <lambdabot> Enum b => [b] -> [b]
09:02:52 <fog23> and if we follow, turing tape -> basic (with goto) -> imperative (without goto) -> functional (without top down evaluation)
09:03:02 <fog23> where function referencing is naturally graph like
09:03:08 <fog23> erm, tree like
09:03:09 <lortabac> dsal: the second one has a simpler signature
09:03:21 <lortabac> and plays better with inference
09:03:39 <tdammers> problem with trees, graphs and sets is that you typically have to decide on a subset of those that you want to be able to represent
09:03:41 <dsal> lortabac: You could make that argument for everything you can do with functors, monads, monoids, traversables, foldables, etc...
09:03:45 <fog23> then it seems like list -> tree -> graph, is the natural evolution of the structure of programs
09:03:54 <fog23> so we need graphs to get graphical languages
09:04:02 <fog23> (which i guess is why im working on graphs)
09:04:09 <monochrom> dsal, I think I did make that argument with foldables :)
09:04:30 <dsal> monochrom: I may have missed it.
09:05:02 <fog23> well yeah, its possible to maintain the order of traversal during the algebraic construction of the graph
09:05:10 <lortabac> dsal: IMHO overloading is useful when you want generic operations over all Functors, all Foldables etc.
09:05:23 <fog23> thats what the seti/geti "structured" traversal was all about
09:05:23 <monochrom> If you show students "length :: [a] -> Int", it's very elementary and explainable with little background. If you show them "Foldable f => f a -> Int", there are like 2 or 3 new prerequisite concepts.
09:05:45 <lortabac> dsal: if you know you are working with lists, why making your signature more ambiguous?
09:05:55 <fog23> and then you show them cojoin for a graph
09:06:00 <fog23> pointer...
09:06:01 <monochrom> Well yeah, it's a long time ago, also I was not (and am not) very strongly convicted about it.
09:06:27 <c_wraith> lortabac: If you're writing code that works correctly with more types than list, why not make it more polymorphic so that callers know the implementation space is more restricted?
09:06:29 <monochrom> It is also true of Num, too.
09:06:42 <Cheery> adding dependency "pandoc" and almost bursting in laughter
09:06:45 <fog23> you get traverse_i, where `i' is a "structure directing index, which is a navigation to the pointer to take it to the "next" position
09:06:58 <fog23> so that a carried copy of the future reference can be placed at the bridge locations
09:07:00 <lortabac> c_wraith: I don't understand
09:07:06 <monochrom> Sometimes I first tell the white lie "(+) :: Integer -> Integer -> Integer" and then later when the students are ready I'll explain type classes.
09:07:53 <dsal> monochrom: I think that makes sense for the Foldable example as well.  Things other than lists have length, but you can talk about just lists at first.
09:08:31 <fog23> and then you explain about matricies and functions not supporting quotients - so that we need rings not groups for the extension to monoid most general to represent "polynomial functions"
09:08:40 <Cheery> I'm also going to tell myself a white lie. I'm going to say that something like RelaxNG but on type level can be useful even if I didn't do it properly, and only to writeout stuff reliably.
09:08:54 <monochrom> But here is a downside I don't know how to solve.
09:09:13 <monochrom> Despite my white lies, error messages are going to leak the cold hard truth.
09:09:35 <c_wraith> lortabac: the more polymorphic a type is, the fewer possible implementations it has.  Making something more polymorphic often (not always) makes it clearer what it does, because the type eliminates more possible things that it could be doing.
09:09:42 <monochrom> And 90% of the time it happens when one is not ready to explain or learn what the error message is saying.
09:09:52 <fog23> yeah, how could you ensure that if you made a functional version of call by variable, that it wouldnt break purity
09:10:11 <fog23> or is there a weaker version of purity where you could still make some guaranties 
09:10:16 <lortabac> c_wraith: fair point, but in my experience this is more often the case with parametric polymorphism than with ad-hoc polymorphism
09:10:17 <monochrom> So this perpetuates people's bad habit of ignoring error messages.
09:10:31 <dolio> I pretty much always use fmap for mapping over lists, and I have essentially 0 problems.
09:10:35 <Cheery> monochrom: does your students have haskell-language-server on vscode?
09:10:49 <Chousuke> monochrom: sounds like you need some kind of learn_prelude that swaps out the generic stuff with your dirty lies :)
09:10:50 <monochrom> (Well, people see there is an error. People just disbelieve that the message content is informative.)
09:10:53 <fog23> i cant believe that C# has "inheretence" to mean extensible records 
09:11:36 <fog23> dolio: 0 problems is a side effect of not enough fun
09:12:54 <fog23> and then you combine erlang with go and haskell and get pure structure-concurrent graphical functional languages
09:13:05 <c_wraith> monochrom: how terrible is the user experience of giving them an alternate Prelude to work with?
09:13:15 <monochrom> I haven't tried.
09:13:51 <fog23> c_wraith: about as terrible as most of the forms of pety-facism 
09:14:11 <fog23> ie, context dependent! 
09:14:26 <lortabac> dolio: it's not about problems, but more about better error messages and for example better inference when using typed holes to get the type of an intermediate expression
09:15:36 <lortabac> replacing fmap with map has helped me more than once when I was stuck in dealing with complex data structures
09:15:46 <fog23> yeah, its not a bad idea to make a synonym using TypeApplications for your common types
09:15:47 <lortabac> of course YMMV
09:15:54 <fog23> such as the "has" function
09:15:54 <monochrom> Actually, empirically, I have been doing nothing to the dilemma, and the students survived just fine. :)
09:16:48 <fog23> otherwise the type applications are optional, and you end up with (fmap . fmap . fmap) and its sometimes impossible to read which types they apply to
09:17:15 <dsal> lortabac: But you're solving the problem for exactly one function on exactly one type.  The problem exists both in other functions and other types.
09:17:15 <fog23> explicit type applications would solve that, but they are optional, so the better practive is that of map
09:17:52 <fog23> just make the synonym when you make the instance as a good style 
09:17:54 <monochrom> But as usual, whereas a more general type restricts implementation space, it relaxes usage space, and some usages are potential mistakes (the same reason we have occurs check and ban infinite types).
09:18:02 <monochrom> @quote monochrom dialectic
09:18:02 <lambdabot> monochrom says: Programming is a dialectic class struggle between the author and the user.  My freedom is your slavery. Your ignorance is my strength.
09:18:45 <fog23> or, equivalently good practice, use type applications as a form of code commenting 
09:18:57 <fog23> with the lesser number of synonyms
09:19:00 <dsal> lambdabot: that monochrom dude is clever
09:19:14 <fog23> aka, map depreciated following since @
09:19:15 <monochrom> :)
09:19:57 <fog23> that Hegelian synergy  
09:20:03 <dsal> I'm not good at type applications, but that seems like a good way to get you there.
09:20:28 <fog23> ah, yeah, then you get plenty of foralls
09:20:33 <dsal> :t fmap @([Int] -> [Int])
09:20:36 <lambdabot> error:
09:20:36 <lambdabot>     Pattern syntax in expression context: fmap@(_)
09:20:36 <lambdabot>     Did you mean to enable TypeApplications?
09:20:50 <fog23> % :t fmap @([Int] -> [Int])
09:20:50 <yahb> fog23: ; <interactive>:1:8: error:; * Expected kind `* -> *', but `[Int] -> [Int]' has kind `*'; * In the type `([Int] -> [Int])'; In the expression: fmap @([Int] -> [Int])
09:21:09 <fog23> % :t fmap @[] @Int 
09:21:09 <yahb> fog23: (Int -> b) -> [Int] -> [b]
09:21:20 <fog23> % :t fmap @[] @Int @Int 
09:21:20 <yahb> fog23: (Int -> Int) -> [Int] -> [Int]
09:21:26 <fog23> there you go
09:21:38 <fog23> so map = fmap @[] 
09:21:59 <fog23> i dont think the @a @b are required to see what the fmap is acting on
09:22:38 <dsal> More importantly, you fix your error messages by, instead of replacing each function name to match what you think you're working with, just annotating it with what you think you're working with.
09:23:31 <dsal> % :t fmap @[]
09:23:31 <yahb> dsal: (a -> b) -> [a] -> [b]
09:23:43 <fog23> i guess its either, make synonyms everytime you write an instance. or, write type applications everywhere. or (the seemingly better way) make *some* synonyms, for the more common things, and use TypeApplications where otherwise your (fmap . fmap . fmap) would be unintelligable 
09:23:48 <dsal> % :t fmap succ
09:23:49 <yahb> dsal: (Functor f, Enum b) => f b -> f b
09:23:51 <dsal> % :t fmap @[] succ
09:23:51 <yahb> dsal: Enum b => [b] -> [b]
09:24:47 <fog23> dsal: right! so you can easily try several different versions, just depending on the type, instead of trying all different named synonyms
09:24:48 <c_wraith> lortabac: yeah...  with ad-hoc polymorphism, it depends on how big the class is.  Num is almost too big to help.  Monoid or Functor are vastly more informative than any concrete instance.  Foldable...  is right on the edge.
09:25:14 <fog23> but then, this might not be the case for "has" where you would very rarely, *not* want the synonym named version
09:25:28 <fog23> like, everytime you write a Has instance, you should make a synonym 
09:25:36 <fog23> (Has is basically coerce)
09:26:06 <fog23> you wouldnt want the whole of your code being a bunch of has casts, and a myriad of type applications
09:26:51 <fog23> but then you have to think of better synonym names than hasTypeATypeB
09:27:18 * hackage servant-auth 0.4.0.0 - Authentication combinators for servant  https://hackage.haskell.org/package/servant-auth-0.4.0.0 (domenkozar)
09:27:28 <fog23> (your only really writing has instances where there is a natural choice for a unique coercion) 
09:27:38 <fog23> hmm
09:27:47 <ski> monochrom : "But here is a downside I don't know how to solve.","Despite my white lies, error messages are going to leak the cold hard truth." -- in Racket, they have language levels, to deal with that
09:27:51 <fog23> i remember having a "labled" or tagged has class aswell
09:28:07 <dsal> racket-style language levels would be really neat.
09:28:13 <fog23> so you could choose which of several has instance, by an extensible label 
09:28:20 <dsal> I like the idea of map when I know nothing at all, but I really dislike map today.
09:28:26 <fog23> dont think you can use data families in instances though...
09:28:41 <fog23> or if you do it has to use an equality constraint or something
09:28:47 <fog23> it was very complicated to say the least
09:29:34 <sm[m]> dsal: agreed on language levels!
09:29:49 <sm[m]> as a start, we could at least define some
09:29:54 <dsal> I'm glad we've finally solved this problem.  See you guys at the next meeting.
09:30:02 <fog23> bsically, i think i have to abandon haskell, because i cant express graphs
09:30:11 <fog23> because GADTs cant have copying
09:30:14 <fog23> or something
09:30:17 * sm[m] assigns action time to dsal on the way out
09:30:22 <sm[m]> ITEM
09:30:38 <ski> there are a few graph libraries, i thought
09:30:45 <fog23> no
09:30:46 <fog23> like trees
09:30:55 <fog23> they can be expressed using GADTs
09:31:19 <fog23> graphs cant because several lower branches on different paths can refer to the same common lower branch
09:31:30 <fog23> and i dont think there is a way to express that "copying" 
09:31:40 <ski> but no direct support for defining specialized kinds of graphs, akin to how `data' can be thought of as a way to define specialized kinds of trees
09:31:58 <fog23> also we need some way to say things like "this record is reserved for knot typing"
09:32:02 <fog23> tying*
09:32:25 <ski> you could use some kind of references, to express that sharing (DAGs, i suppose you want ? or also allow cycles ?)
09:32:59 <fog23> and also maybe some kind of linear types, like "this lower tree portion is referred to exactly once" 
09:33:44 <fog23> ski: what do you mean, i dont undertand how DAGs correponds to the sharing - and what are you asking about cycles?
09:33:44 <ski> (dunno what you mean by "this record is reserved for knot tying")
09:34:02 <ski> there are many different kinds of graphs, mathematically speaking
09:34:20 <fog23> if i dont care about sharing/copying, then i can have a doubly linked tree as Free (\a -> (a,Nonempty a))
09:34:37 <fog23> where the fst, the `a' - is "reserved for knot tying" 
09:35:17 <ski> you can have directed vs. undirected graphs (or even have both directed and undirected edges). you can allow self-edges (loops) or not. you can allow multiple parallel edges or not. you can adorn vertices, ior edges, with some extra associated information
09:35:43 <fog23> without syntax to do that during the writing of the GADT, then this is not demanded of the user, and they must choose to write the knot typing function to actually construct the datatype properly
09:36:03 <fog23> you cant "pass the upper reference into the lower constructors" during the writing of the GADT
09:36:40 <ski> you can have graphs where the vertices come in several different kinds (which, say, determine which out-nodes they have, and possibly also determine in-nodes). and presumably also different kinds of edges
09:37:01 <fog23> thats quite comprehensive 
09:37:24 <ski> (i still dunno what you mean by the "reserved for knot tying")
09:37:24 <fog23> but, we have *none* of the tools to express these as datatypes
09:37:59 <ski> yea, we have to do them, manually, as abstract data types .. it would be nice, if we could, somehow, express them more directly/explicitly
09:38:03 <fog23> we were using this example before
09:38:03 <fog23> https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Account.hs#L93
09:38:16 <fog23> as a "knot tying function"
09:38:26 <fog23> this has to be done aswell as construction
09:38:39 <ski> "pass the upper reference into the lower constructors" is for ?
09:38:49 <fog23> without those, there is no telling that the "parent" record, is actually a knot
09:39:09 <fog23> ski: thats basically what typing the knot is all about - in the context of double linkage
09:39:15 <ski> oh, you want parent links, in nodes
09:39:19 <monochrom> dsal: I wonder if you also find this other quote related :)
09:39:24 <monochrom> @quote monochrom Kripke
09:39:25 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
09:39:26 <fog23> but specifically, just for when the knot is tyed to the directly preceeding element 
09:39:53 <fog23> ski: parent links, in nodes, is *one* of the forms of knot tying we dont support by construction
09:40:06 <fog23> we also dont have *several* knots, or knots extending far below
09:40:11 <fog23> or above
09:40:11 <monochrom> (So, Kripke structures formalize multiple worlds so you can have multiple different truths in different worlds.)
09:40:34 <dolio> Kripke structures are just degenerate sheaves.
09:40:42 <fog23> your a degenerate sheef
09:40:43 <dolio> Presheaves, even.
09:40:45 <ski> an alternative to parent links, is to use a zipper that reverses edges as you traverse them. but this doesn't work (at least directly), if you have cycles (other than the bidirectional edges)
09:41:02 <fog23> monochrom is the second variety 
09:41:17 <ski> "we also dont have *several* knots, or knots extending far below or above" ?
09:41:22 <ski> by "knots", you mean cycles ?
09:41:33 <fog23> typing the knot establishes cycles
09:41:41 <fog23> a knot would be a cyclic reference, i think
09:41:44 <ski> (s/sheef/sheaf/)
09:42:20 <ski> monochrom : that's like, your truth, man
09:42:29 <fog23> pinciple bundle section of the module of spectral hyperkhaler distributions  
09:43:06 <monochrom> But don't you like how it pairs up with "there are lies, damn lies, and statistics"? :)
09:43:34 <fog23> cuspidal solitonic top forms in the harmonic fibration of differential topologies  
09:43:39 <ski> anyway, it's possible to use references to describe cycles. they can be compared for equality, so you can know when you're back again
09:44:40 <monochrom> Ooohhh, immutable references to help with explicating cycles.
09:44:40 <fog23> hodge arrows in the quiver monoid  
09:44:48 <nshepperd> knot tying is generally a bad idea except as an optimization
09:45:48 <fog23> shepperd: oh contrare 
09:46:19 <fog23> im away to run counterwidishins around the bliths stone, avast to you 
09:46:34 <monochrom> Good riddance.
09:46:46 <nshepperd> the knot tying that hledger does seems very silly to me
09:47:01 <monochrom> What was all that about anyway?
09:47:38 <nshepperd> fog in his manic phase
09:47:48 <c_wraith> I'm not sure anyone's ever known what they're talking about
09:49:25 <sm[m]> nshepperd: it probably is, but it has been working great since beginner-me concocted it
09:52:53 <ski> monochrom : yes, like `simple-ivar'
09:55:42 <monochrom> ivar-simple
09:59:48 * hackage hakyll-alectryon 0.1.0.0 - Hakyll extension for rendering Coq code using Alectryon  https://hackage.haskell.org/package/hakyll-alectryon-0.1.0.0 (lyxia)
10:02:34 * int-e wonders whether to worry about the ivar-simple reference.
10:03:38 <monochrom> It is mentioned for "immutable references to help with explicating cycles"
10:05:37 <int-e> Not sure that it does anything about cycles... oh well. It still compiles with ghc-8.10, I'll stop worrying :)
10:07:40 <monochrom> It has Eq so we can observe aliasing in pure functions.
10:08:19 <zoom84> could really use some help understanding implementing functors for type constructors that take two params. I read through the learnyouhaskll example of the Either type and generally understand the notion of partially applying the typeclass via Functor (Either a) but I'm getting twisted in knots trying to understand how the class Functor translates
10:08:19 <zoom84> to the implementation of Functor (MyEither a)
10:08:42 <int-e> monochrom: Oh right. Heh... it's been so long.
10:08:59 <zoom84> I created my own type to experiment:
10:09:10 <zoom84> data MyEither a b = MyLeft a | MyRight b deriving(Show)
10:09:19 <zoom84> instance Functor (MyEither a) where
10:09:27 <zoom84> fmap f (MyRight b) = MyRight (f b)
10:09:32 <ski> monochrom : er, right
10:09:35 <zoom84> fmap f (MyLeft x) = MyLeft x
10:09:59 <ski> (it also has `read :: IVar a -> a')
10:10:00 <monochrom> That's correct. What's the error message?
10:10:47 <zoom84> learnyouhaskell says the effective prototype would be would be :  (b -> c) -> MyEither a b -> MyEither a c
10:11:08 <ski> zoom84 : "generally understand the notion of partially applying the typeclass via Functor (Either a)" -- the type class (`Functor') isn't partially applied, it's the `data' type, `Either', that is
10:11:44 <ski> yes, that's a correct type signature for `fmap' here
10:11:47 <zoom84> I get the "MyEither a b" part, but I don't understand how the "c" var is introduced, for both b->c and My Either a c
10:12:21 <monochrom> OK. Allow me to use the shorthand E to stand for "Either a".
10:12:34 <monochrom> You expect (b->c) -> E b -> E c, no?
10:12:44 <monochrom> Now expand E to Either a.
10:13:33 <monochrom> or s/Either/MyEither/g throughout
10:13:36 <zoom84> why is it (b -> c) instead of (a->b)
10:13:38 <ski> zoom84 : if you add the line `{-# LANGUAGE InstanceSigs #-}' to the top of your module, then you should be able to put the type signature `fmap :: (b -> c) -> MyEither a b -> MyEither a c' inside your `instance'
10:14:00 <zoom84> consdering fmap in the class is map :: (a -> b) -> f a -> f b
10:14:04 <monochrom> "a" is already used up in "MyEither a". Gotta think up other variable names.
10:14:15 <zoom84> ahh...
10:14:23 <ski> zoom84 : the names of type variables doesn't really matter (as long as you use them consistently, within one context)
10:14:25 <sim590> zoom84: it's the return type of your function that is applied to the right part of the MyEither type. Functor describes how to map a function onto elements in the type. The implementation of Functor for Either chooses to apply the map on the right side by convention. That's what you wrote with your example for MyEither. When f is applied on the `b` type, it becomes a  ̀c`.
10:14:40 <ski> saying
10:14:44 <ski>   class Functor f
10:14:45 <zoom84> @monochrome, let me process that and see if it makes sense then...
10:14:45 <lambdabot> Unknown command, try @list
10:14:46 <ski>     where
10:14:53 <ski>     fmap :: (a -> b) -> (f a -> f b)
10:14:58 <ski> is the same thing, as saying
10:15:00 <ski>   class Functor f
10:15:01 <ski>     where
10:15:06 <monochrom> For this reason I much prefer "(a -> b) -> Either x a -> Either x b" actually
10:15:07 <ski>     fmap :: (b -> c) -> (f b -> f c)
10:15:27 <ski> iow, you can rename `a' and `b' to some other variable names here
10:15:53 <int-e> monochrom: Oh I see. The Eq instance wasn't my idea. "this change was suggested by nwf" -- probably on IRC and I don't know who it was, which is why there's no proper credit for it in the changelog.
10:15:57 <ski> (but you can't rename the `f' in the signature here, without also renaming the `f' in the type class head `class Functor f')
10:19:52 <zoom84> i've read countless times how the placeholder variable names like 'a' and 'b' have no significance in the names selected but I still manage to get tripped up when single-letter placeholders like that are used for when integrating different vars in a single case like functor
10:20:39 <zoom84> i carry over the original use of "a" and "b" when integrating into a different type signature which also uses it's own letters. it's a constant source of confusion for me
10:21:09 <zoom84> maybe I should just start using more descriptive variable names and dropping the letters, even though the convention is to use letters
10:21:39 <ski> after a while, you'll probably get more used to renaming tyvars, on a by-need basis ?
10:21:47 <lordcirth_> zoom84, descriptive names don't hurt
10:22:10 <ski> if they can sensibly be descriptive
10:22:11 <hpc> the hard part is, for things that generic, what do you name them?
10:22:15 <monochrom> descriptive names take forever to conjure, or forever to understand
10:22:21 <ski> (and, i suspect, they can actually hurt, at times)
10:22:50 <hpc> even the famously verbose java has the convention of "T" for type variables
10:22:54 <ski> @type lookup
10:22:56 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:22:56 <ski> @type M.lookup
10:22:58 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
10:23:03 <int-e> . o O ( Lens s t a b )
10:23:05 <monochrom> The greatest hypocrisy of people bragging about descriptive names is they go on to give you foo, bar, quux.
10:23:09 <ski> `k' here is reasonable, abbreviating "key"
10:23:21 <zoom84> back to my original question now
10:23:22 <monochrom> Proving that for generic things there is no such thing as descriptive names.
10:23:43 <ski> spelling out `key',`token',`stream',&c. all the time, might make some type signatures long enough, that they're harder to comprehend, though
10:23:48 <int-e> I'm really a fan of having the length (and hence "descriptiveness") of the name increase with its scope.
10:24:04 <ski> yes, that's a good guideline
10:24:22 <zoom84> instance Functor (MyEither a) where
10:24:27 <zoom84> fmap f (MyRight b) = MyRight (f b)
10:24:34 <zoom84> fmap f (MyLeft x) = MyLeft x
10:25:02 <zoom84> so for my fmap instances, the "a" in Either a b is not available. Only the "b" is available, correct?
10:25:32 <monochrom> Or you write "Either x" like I do, so a is available again.
10:25:33 <dsal> Correct.
10:25:39 <ski> zoom84 : which `Either a b' ?
10:25:48 <zoom84> good. how then does MyLeft x work then? Since MyLeft uses "a"
10:25:56 <ski> zoom84 : are you talking about the definition of the `data' type `Either' ?
10:26:06 <int-e> :t fmap :: (b -> c) -> Either a b -> Either a c
10:26:08 <lambdabot> (b -> c) -> Either a b -> Either a c
10:26:10 <dolio> I think "correct" might be the wrong answer.
10:26:26 <ski> zoom84 : the `b' in `MyRight b' has nothing to do with the `b' in `MyEither a b' or `MyEither x b'
10:26:27 <int-e> That's the only possible Functor instance for Either.
10:26:41 <zoom84> I created my own MyEither. It's the same as Either. I did it so I can experiment trying to learn this aspect. Either vs MyEither interchangeable
10:27:38 <ski> zoom84 : yea, in `data MyEither a b = MyLeft a | MyRight b deriving Show', `a' and `b' are local names. they are not available outside this definition of `MyEither'
10:28:16 <ski> if you wanted to, you could define it as `data MyEither coffee tea = MyLeft coffee | MyRight tea deriving Show', and it would not affect other code at all
10:28:37 <int-e> zoom84: note that you had to write `instance Functor (MyEither a) where`, with only the last type parameter left out; that's all Haskell can do.
10:29:12 <int-e> (You could use a different variable name for that `a` though.)
10:29:41 <ski> zoom84 : it's just a convention to start naming the parameters `a',`b',`c',..., unless there's some particular significance (rôle) one may want to hint, like `k' for "key", `t' for "token", `f' for "functor", &c.
10:29:50 <zoom84> yeah, convention still tripping me up
10:29:55 <int-e> . o O ( instance Functor (Either idontcarewhatthisisaslongasitsneitheranorb) where ... )
10:30:05 <dsal> Oh, is it the variable name that is confusing?
10:30:27 <monochrom> I think it is the notion of dummy variables.
10:30:31 <zoom84> rewriting my sample now with totally different names
10:30:48 <zoom84> to make it obvious...i'll see if it clicks then
10:31:18 <ski> zoom84 : it's also quite common, if you have say type variables `a',`b',`c' in a type signature, to also name corresponding values, in the definition, `a',`b',`c'. but one could instead name these `x',`y',`z' (so that we get `x :: a',`y :: b',`z :: c', which looks less confusing than `a :: a',`b :: b',`c :: c')
10:32:03 <ski> (or, if you have a list of values of type `a', it could commonly be called `as', so that you have `as :: [a]'. but you could instead call it `xs', so that you have `xs :: [a]')
10:32:07 <zoom84> data MyEither dog cat = MyLeft dog | MyRight cat deriving(Show)
10:32:13 <zoom84> instance Functor (MyEither doodad) where
10:32:19 <zoom84> fmap f (MyRight x) = MyRight (f x)
10:32:34 <zoom84> fmap f (MyLeft x) = MyLeft x
10:32:46 <ski> zoom84 : did you try my `InstanceSigs' suggestion from above ?
10:33:16 <ski> try adding the line
10:33:18 <ski>   {-# LANGUAGE InstanceSigs #-}
10:33:25 <ski> at the top of your source file
10:33:34 <zoom84> if I do the following in ghci: fmap (*2) (MyLeft 10)
10:33:36 <monochrom> Koodos for writing code to test your understanding
10:33:45 * geekosaur hopes there was some indentation there, also
10:33:59 <ski> then, just above the definition of `fmap' in your instance, you can write the type signature for `fmap' that you expect, for `MyEither'
10:34:24 <ski> zoom84 : try `fmap (* 2) (MyLeft 10) :: MyEither Integer Bool'
10:34:55 <zoom84> my original statement works
10:35:12 <zoom84> i'm trying to understand what that fmap instance actually receives
10:35:15 <ski> hm, actually, say `fmap (* 2) (MyLeft 10) :: MyEither Integer Double'
10:35:23 <monochrom> ski, there is ExtendedDefaulting to default to MyEither Integer () :)
10:35:38 <ski> yea, i just recalled :)
10:36:26 <fog> its not my fault! its election season - all the lobbying efforts and competing partisan spending distorts the fabric of reality 
10:37:10 --- mode: ChanServ set +o monochrom
10:37:16 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.193.176.87.226
10:37:16 --- kick: fog was kicked by monochrom (fog)
10:38:16 <zoom84> does this implicit type signature look about right: (a -> b) -> MyEither doodad foobar -> MyEither a b
10:38:26 <ski> no
10:38:37 <ski> try writing
10:38:43 <ski>   fmap :: (a -> b) -> MyEither doodad foobar -> MyEither a b
10:38:49 * hackage fused-effects-mwc-random 0.1.0.0 - High-quality random number generation as an effect.  https://hackage.haskell.org/package/fused-effects-mwc-random-0.1.0.0 (patrick_thomson)
10:38:50 <ski> above your definition, and see how it complains
10:38:58 <zoom84> not writing the signaturte
10:39:08 <zoom84> trying to impute the equivalent
10:39:19 <ski> you can check your understanding, by writing the signature that you expect
10:39:47 <ski> where did `doodad' and `foobar' come from ?
10:39:52 <ski> where did `a' and `b' come from ?
10:40:18 <zoom84> where i can specify that signature?
10:40:28 <ski> just above the definition of `fmap'
10:41:01 <zoom84> The type signature for ‘fmap’ lacks an accompanying binding      (The type signature must be given where ‘fmap’ is declared)    |795 | fmap :: (a -> b) -> MyEither doodad foobar -> MyEither a b
10:41:31 <zoom84> fmap is in a library source file. you're saying i should put it there?
10:41:54 * geekosaur again points to indentation
10:42:39 <MarcelineVQ> This requires InstanceSigs
10:42:52 <ski> (as was already mentioned, twice or thrice :)
10:43:09 <ski> at top of your source file :
10:43:11 <ski>   {-# LANGUAGE InstanceSigs #-}
10:43:14 <ski> later :
10:43:19 <ski>   data MyEither dog cat = MyLeft  dog
10:43:23 <ski>                         | MyRight cat
10:43:26 <ski>                           deriving Show
10:43:32 <ski>   
10:43:36 <ski>   instance Functor (MyEither doodad)
10:43:37 <zoom84> sorry ski, missed that. it's hard to follow multiple threads of help at once. i'll at it
10:43:44 <ski>     where
10:43:49 <ski>     fmap :: (a -> b) -> (MyEither doodad foobar -> MyEither a b)
10:43:53 <ski>     fmap f (MyLeft  x) = MyLeft     x
10:43:57 <ski>     fmap f (MyRight y) = MyRight (f y)
10:44:05 <ski> zoom84 : like that ^
10:44:42 <ski> zoom84 : "fmap is in a library source file. you're saying i should put it there?" -- yes, there is a general type signature of `fmap' in the type class declaration of `Functor', it looks like
10:44:46 <ski>   class Functor f
10:44:47 <ski>     where
10:44:53 <ski>     fmap :: (a -> b) -> (f a -> f b)
10:45:42 <ski> however, when making an `instance' declaration, you can actually (if you enable the `InstanceSigs' language extension, as above) put the specific type signatures, for your instance, on the type class methods
10:46:47 <ski> geekosaur : pretty sure they have relevant indentation in their source code :)
10:47:19 <geekosaur> I'm not, because you get that error instead of "turn on InstanceSigs" if you didn't indent it.
10:47:52 <geekosaur> and you don't get other errors you might think you would, it'd just be a local redeclaration which is legal
10:48:13 <ski> ah, i missed that. perhaps they dedented, then, since from earlier discussion, it seemed the issue wasn't some error, but understanding the code in question
10:48:17 <geekosaur> until you go to use it and it complains it's declared twice in the same scope, one in Prelude
10:48:52 <ski> zoom84 : yes, make sure the definition (and type signature) of `fmap' is actually indented more than the `instance Functor ..' line
10:49:08 <zoom84> indent was ok. here's what I get:
10:49:23 <zoom84> instance Functor (MyEither doodad) where
10:49:30 <zoom84> fmap :: (a -> b) -> MyEither doodad foobar -> MyEither a b
10:49:50 <zoom84> fmap f (MyRight x) = MyRight (f x)
10:50:03 <zoom84> fmap f (MyLeft x) = MyLeft x
10:50:11 <zoom84>  • Couldn't match type ‘a’ with ‘doodad’      ‘a’ is a rigid type variable bound by        the type signature for:          fmap :: forall a b foobar.                  (a -> b) -> MyEither doodad foobar -> MyEither a b
10:50:30 <zoom84> that error is for the fmap f (MyLeft x) = MyLeft x line
10:50:31 <ski> zoom84 : is there actually some (more) spaces in front of those last three lines you showed, in your source code ?
10:50:45 <zoom84> spaces. don't know how to retain intent pasting into this web irc client
10:50:50 <ski> zoom84 : yes, you get that error because your type signature is wrong (as mentioned before)
10:51:05 <ski> it's ok, as long as they're there, in your code
10:51:27 <zoom84> missed the correction in the cross-talk. what's the correct sig
10:51:47 <ski> the point, i thought, was that you wanted to figure out the correct signature yourself ?
10:52:17 <zoom84> i do
10:52:25 <zoom84> why is the sig I wrote incorret
10:52:44 <zoom84> ie, what's the correct sig
10:53:17 <ski> if you look at `fmap :: (a -> b) -> MyEither doodad foobar -> MyEither a b', and compare it with the definition equation `fmap f (MyLeft x) = MyLeft x', you can see that the first parameter,`f', gets type `a -> b', and the second parameter, `MyLeft x', gets type `MyEither doodat foobar', and that the result `MyLeft x' is to have type `MyEither a b'
10:53:55 <ski> zoom84 : do you understand that part, matching up parameters and result, in a definition equation like `fmap f (MyLeft x) = MyLeft x', with the corresponding parameter types and result type, in the type signature ?
10:57:37 <zoom84> still working on it...
10:57:49 <ski> zoom84 : a "yes" or "no" would be nice
10:57:52 <zoom84> understand what you wrote ski...making changes to understand
10:57:56 <ski> ok
10:58:41 <zoom84> zoom, I understand. in isolation it makes sense, ie for simpler functions. in this context I get confused
10:58:54 <ski> next step, it to actually check that the matching up of formal parameters (aka patterns) and result (expression), with the parameter and result types, actually makes sense
10:59:09 <ski> so, let's think about that
10:59:14 <ski> we know
10:59:16 <zoom84> give me a sec..
10:59:25 <ski>   fmap :: (a -> b) -> MyEither doodad foobar -> MyEither a b
10:59:27 <zoom84> can only work on one thought experiemnt at a time
10:59:28 <ski>   fmap f (MyLeft x) = MyLeft x
10:59:53 <ski> and, from matching up parameters and result with corresponding types in signature, we get
10:59:56 <ski>   f :: a -> b
11:00:03 <ski>   MyLeft x :: MyEither doodad foobar
11:00:08 <ski>   MyLeft x :: MyEither a b
11:01:15 <ski> (that's the same as i mentioned before, just spelled out a little more explicitly, using the `::' ("has type") notation)
11:01:29 * ski waits for zoom84
11:02:22 <monochrom> I wonder if it's helpful again to do my trick.  By going "instance Functor (MyEither doodad)", you saying: in "(a -> b) -> f a -> f b" you're setting "f" to "MyEither doodad". So do that consistently and see what you get.
11:06:50 <zoom84> :r
11:07:21 <ski> Ok, one module loaded.
11:10:07 <zoom84> finally have a signature that correctly compiles...reading over to understand fully.
11:10:16 <ski> ok
11:20:13 <ski> zoom84 : do you understand it better, now ?
11:20:36 <zoom84> yeah. there are multiple aspects that confused me. with the correct sig I'm working through them one at a time
11:21:38 <ski> zoom84 : would you like to see how one could, manually, check the definition, given the type signature (continuing the line i started to get into, above) ?
11:22:13 <zoom84> sure
11:22:48 * hackage wai-extra 3.1.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.1.1 (MichaelSnoyman)
11:22:50 <ski> continuing from the incorrect type signature above (so you can see why it doesn't work), or using your current, correct, type signature ?
11:23:04 <zoom84> let's use my correct sig. here's what I have:
11:23:04 <ski> (or both, if you want to)
11:23:11 <zoom84> fmap :: (a -> b) -> MyEither doodad a -> MyEither doodad b
11:23:15 <ski> ok
11:23:27 <ski> so, comparing that with
11:23:44 <ski>   fmap f (MyLeft  x) = MyLeft     x
11:23:59 <ski> we can see that the formal parameters (the patterns) will get types
11:24:03 <ski>   f :: a -> b
11:24:04 <frdg> is there a better way to turn a list into a set than using nub?
11:24:18 <ski>   MyLeft  x :: MyEither doodad a
11:24:31 <Cale> frdg: Data.Set.fromList
11:24:33 <ski> and that the result expression then ought to have the type
11:24:44 <ski>   MyLeft     x :: MyEither doodad b
11:25:09 <Cale> If you really want sets, might as well be using Data.Set -- it has more of the operations you probably want to perform on sets as well.
11:25:24 <frdg> Cale: I am trying to write that module myself. 
11:25:44 <ski> zoom84 : so, the goal here is to take apart the formal parameters, the pattern, to get types for the variables in the pattern (here `f' and `x'), and then to check that the expected type for the result expression (sometimes called the "body" of the defining equation) is correct
11:26:10 <frdg> and I was going to use sets as lists that have been made sets.
11:26:18 * hackage lists-flines 0.1.1.0 - Additional data and structures to some 'String'-related lists.  https://hackage.haskell.org/package/lists-flines-0.1.1.0 (OleksandrZhabenko)
11:26:28 <ski> @type S.toList . S.fromList
11:26:29 <lambdabot> Ord a => [a] -> [a]
11:26:34 <zoom84> ski, I kinda stumbled on that route by just closely reading the compiler error messages and matching the expected vs actual types
11:26:51 <Cale> map head . group . sort -- this might also be of interest
11:27:04 <zoom84> that let me cobble together the correct signature...from which I was able to finally connect the dots
11:27:15 <zoom84> in terms of understanding all the params
11:27:15 <frdg> ok thanks
11:27:30 <Cale> > sort "mississippi"
11:27:33 <lambdabot>  "iiiimppssss"
11:27:40 <Cale> > group . sort $ "mississippi"
11:27:43 <lambdabot>  ["iiii","m","pp","ssss"]
11:27:47 <Cale> > map head . group . sort $ "mississippi"
11:27:50 <lambdabot>  "imps"
11:27:58 <frdg> I see.
11:28:05 <ski> zoom84 : ok. so we already know the type of `f'. but, given `MyLeft  x :: MyEither doodad a', what will be the type of `x' ?
11:29:25 <zoom84> it will be 'b', correct?
11:29:29 <ski> no
11:29:46 <zoom84> it works as 'b' in my actual implementation
11:29:55 <zoom84> err
11:29:57 <zoom84> take that back
11:30:34 <ski> perhaps, if you ask in the interactor, it will have renamed some type variables. i'm talking specifically about the naming that we picked above, not about some other naming
11:30:35 <zoom84> MyLeft x works, which means it conforms to the return type sig of "MyEither doodad b"
11:30:59 <ski>   fmap f (MyLeft  x) = MyLeft     x
11:31:05 <zoom84> yep
11:31:16 <zoom84> so you're asking what's the type of x?
11:31:17 <ski> note that i'm talking, so far, only about the underlined pattern (formal parameter)
11:31:20 <ski> yes
11:31:40 <ski> we know
11:31:42 <ski>   MyLeft  x :: MyEither doodad a
11:31:44 <zoom84> well,(MyLeft x) is a destructuring
11:31:50 <ski> so, we should be able to figure out
11:31:52 <ski>   x :: ???
11:32:06 <ski> yes, it's pattern-matching
11:32:16 <zoom84> and I'm passing a (MyLeft 10) in, as an example
11:32:27 <zoom84> such as fmap (*2) (MyLeft 10)
11:33:00 <zoom84> doodad is already bound by the partial application of My Either
11:33:05 <zoom84> so doesn't x have to be a?
11:33:17 <ski> no
11:33:35 <ski> consider again your `data' type definition
11:33:45 <ski>   data MyEither dog cat = MyLeft  dog
11:33:46 <ski>                         | MyRight cat
11:33:49 <ski>                           deriving Show
11:33:51 <zoom84> you mean dog then?
11:34:51 <ski> the `MyLeft  dog' part here is a "template", it actually means that if (e.g.) `t' has type `dog', then `MyLeft  t' will have type `MyEither dog cat'. and if `u' has type `cat', then `MyRight u' will (also) get type `MyEither dog cat'
11:35:18 <ski> in your case, `dog' is `doodad', and `cat' is `a', since we're considering `MyLeft  x :: MyEither doodad a'
11:35:27 <ski> and, instead of `t', you have `x'
11:36:16 <zoom84> so it's dog, correct
11:36:18 <zoom84> ?
11:36:26 <ski> if we rename `dog',`cat',`t',`u' to `doodad',`a',`x',`y', then the above becomes
11:37:07 <ski> the `MyLeft  doodad' part here is a "template", it actually means that if (e.g.) `x' has type `doodad', then `MyLeft  x' will have type `MyEither doodad a'. and if `y' has type `a', then `MyRight y' will (also) get type `MyEither doodad a'
11:37:39 <ski> in other words, if it helps, we're imagining now that we actually had written
11:37:54 <ski>   data MyEither dogdad a = MyLeft  doodad
11:37:59 <ski>                          | MyRight a
11:38:03 <ski>                            deriving Show
11:39:08 <zoom84> ok
11:39:09 <ski> so, in the current situation, with `fmap :: (a -> b) -> MyEither doodad a -> MyEither doodad b', and `MyLeft  x :: MyEither doodad a' .. there is no `dog' (nor `cat'). so "so it's dog, correct ?" is wrong
11:39:31 <zoom84> so the question posed to me is still, what's the type of x, right?
11:39:33 <ski> you have to answer in terms of the available type variables, in the current situation, which are : `doodad',`a',`b'
11:39:37 <ski> yes
11:40:17 <zoom84> then i don't know. because I guess the entire vernacular of what's being referred to as a type confuses me
11:40:25 <zoom84> based on my reading of haskell, the only type here is MyEither
11:40:39 <zoom84> MyLeft and MyRight are constructors for that type
11:40:54 <zoom84> but irrespective of whether an instance is MyRight or MyLeft, the type is still MyEither
11:41:03 <ski> `MyEither' is a type, `MyEither doodad a' and `MyEither doodad b' are also types, as are `a -> b',`a',`b',`doodad' (all type variables are types)
11:41:06 <zoom84> unless my understanding of what we're calling a type is wrong
11:42:42 <ski> saying `MyLeft  x :: MyEither doodad a' means that the (pattern / formal parameter) `MyLeft  x' has type `MyEither doodad a'
11:42:57 <ski> (so `MyEither doodad a' is a type. otherwise `MyLeft  x' couldn't have it as type)
11:43:32 <ski> what you're doing, when pattern-matching (which is a generalization of destructuring), is that you're going "backwards"
11:43:38 <zoom84> you're saying MyEither doodad a is a type distinct from MyEither?
11:43:48 <ski> yes
11:44:00 <ski> `MyEither doodad a' is a "concrete" type
11:44:07 <ski> it makes sense to say e.g
11:44:15 <ski>   MyLeft  x :: MyEither doodad a
11:44:36 <zoom84> yeah, that's another point of confusion for me. the fact that a parameterized var can be considered concrete
11:44:40 <ski> "concrete" types are those types that are types of values
11:44:50 <dolio> That seems like a bad name for them.
11:44:56 <ski> "concrete" doesn't mean "specific"
11:45:10 <ski> yea, sometimes people trip up over this distinction
11:45:23 <zoom84> ok, good. because this was another point of confusion to me that feed into this
11:45:36 <zoom84> so MyEither doodad a is concrete
11:45:45 <ski> `doodad' and `a' are type variables. that mean that we don't have any specific types in mind (like `Int' or `[Bool]', ..), when we write them
11:45:51 <zoom84> what does that make MyEither Int or MyEither String?
11:46:46 <zoom84> is there a name for MyEither Int vs MyEither doodad...to help me grasp the nomenclature
11:47:10 <ski> so, what we mean when we say that `MyEither doodad a' is a concrete type is actually : if we'd replace `doodad' and `a' with specific (concete) types, then the result of that replacement on `MyEither doodad a' will be a concrete type
11:47:26 <zoom84> ok, understood on that point
11:47:35 <zoom84> so it's a pathway to a concrete type
11:47:41 <ski> e.g. since `Int' and `[Bool]' are specific (concrete) types, `MyEither Int [Bool]' is a concrete (specific) type
11:48:12 <ski> however, it gets long-winded to all the time say that "if we replace the type variables with specific types, then .." part all the time
11:48:47 <zoom84> ok, so what's an example of a non-concrete type in this specific context
11:49:04 <ski> it's like when saying that `x + 1' is a number. we really mean here : if `x' is replaced by a number, then `x + 1' will become (an expression for) a number
11:49:24 <ski> `MyEither' is not concrete
11:49:29 <ski> it doesn't make sense to say
11:49:35 <ski>   blah :: MyEither
11:49:52 <ski> `MyEither' is "incomplete" on its own, it's a "template" that's missing it's parameters
11:49:52 <zoom84> ok, so MyEither is non-concrete because it doesn't establish which specific constructor would be referenced
11:50:20 <ski> you have to say `MyEither T U', for some specific types `T' and `U', to get a concrete type
11:50:22 <zoom84> but the constructors themselves are concrete because they have placeholders which lead to concrete types
11:51:22 <ski> you have to distinguish between two different "levels". "value level" where values (including functions) live, and interact. and "type level" where types (including non-concrete types) live
11:51:56 <ski> the data constructors `MyLeft' and `MyRight' live on the "value level". they are functions. we in fact have :
11:52:02 <ghoulguy> ski:  are you using "concrete" as a stand-in for "has kind *"?
11:52:13 <ski>   MyLeft  :: dog -> MyEither dog cat
11:52:19 <ski>   MyRight :: cat -> MyEither dog cat
11:52:25 <dolio> Yeah, I've never heard this terminology before.
11:52:36 <ski> ghoulguy : almost. i'm also using it to gloss over unboxed stuff, &c.
11:53:12 <ski> (which part of the terminology ?)
11:53:40 <zoom84> i think i get it SKI. the abstractness here is what throws me off. In my C world view, haskell's "data" created types are what I would implement as unions in C, which a hidden enum field describing which of the type constructors were used. it's probably not useful for me to relate this to C
11:53:48 <dolio> Using "concrete" in this way.
11:54:09 <zoom84> but I'll table that C comparison because it's not useful
11:54:37 <ski> zoom84 : in C, you can't really have "an array". it's always "an array of something". if you say you have an array, you really mean an array with elements of some particular type
11:55:14 <ski> zoom84 : saying `blah :: MyEither' is like trying to say `blah' is an array (rather than an array of something)
11:56:00 <hc> zoom84: actually that comparison if not bad... :)
11:56:03 <ski> "array" is a parameterized type, in C. (as is "pointer", it's always "pointer to something"). in Haskell, you can define your own parameterized types
11:56:48 * hackage uniqueness-periods-vector-examples 0.8.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.8.0.0 (OleksandrZhabenko)
11:57:37 <zoom84> data MyEither dog cat = MyLeft dog | Myright catstruct {	enum { DOG, CAT } type;	union {		int dog;		int cat;	}}
11:57:46 <dolio> I think "saturated" might be a better word.
11:57:48 * hackage porpoise 0.1.0.0 - A minimalist HTTP server framework written on top of wai  https://hackage.haskell.org/package/porpoise-0.1.0.0 (sgschlesinger)
11:58:36 <zoom84> ok, so MyEither is a type. MyLeft is also considered a type, but a concrete one. is that recap correct?
11:58:38 <monochrom> I think this is trying to explain kinds without explaining kinds.
11:58:38 <hc> zoom84: sounds about right; but you'd need a parametrized macro to expand the doc and cat types
11:58:42 <sep2> What would be the best way to even get started with this one, a one-liner or do a function for each instance being empty? https://dpaste.org/ZQ2h
11:59:04 <dolio> monochrom: Well, yeah.
11:59:06 <ski> zoom84 : anyway, `MyEither dog cat' is comparable to "array of `N' `int's" in C (which could be written `int[N]'). in both cases we have supplied (two) parameters
11:59:14 <monochrom> But it is a really long story, I don't have a better suggestion.
11:59:29 <ski> zoom84 : not quite. `MyLeft' and `MyRight' are not types. they're values (specifically they're `data' constructors)
12:00:11 <ski>   MyLeft  :: dog -> MyEither dog cat
12:00:12 <ski>   MyRight :: cat -> MyEither dog cat
12:00:14 <zoom84> Ok. MyEither is a type. MyLeft and MyRight are value constructors, which create concrete types of MyEither. is that right?
12:00:15 <monochrom> Well, I have a prelim one I use in my class. I start with Maybe Int and [] Int and I say "now you can have a type class for the Maybe-ness without Int, the []-ness without Int".
12:00:23 <hc> zoom84: that's right
12:00:42 <zoom84> are they called value constructors or is the correct term, type constructors?
12:01:16 <hc> This is a type constructor, because you get a type and not a value back
12:01:22 <ghoulguy> constructor is a class of names, the capital first letter gives away that it's a constructor here
12:02:00 <ski> zoom84 : `MyLeft' and `MyRight' are functions, like any other functions. you can apply them to an input (of the correct type, as always). the difference with ordinary functions are (a) you can pattern-match on them, "running them backwards"; (b) they don't actually do/compute anything, except storing their parameters so that you can later match and get them back
12:02:58 <zoom84> ok, understood. so what's the entity called that's created say "MyLeft 50"? I would consider it an instance of a type in other languges
12:02:58 <ski> dolio : i think the "concrete" terminology has floated around this channel, for many years
12:03:16 <ski> zoom84 : it's also a value. a value of type `MyEither Int Double' (e.g.)
12:03:19 <ghoulguy> 'MyLeft 50' is a value that has the type "MyEither Integer something"
12:03:27 <monochrom> sep2: I don't understand the question.
12:03:52 <zoom84> ok, so using a type constructor yields something haskell terms a value?
12:04:08 <ski> zoom84 : in terms of Java terminology, yes, you could say it's an "instance" of the type `MyEither Int Double'. but Haskell doesn't use the term "instance" in this sense, uses it for something different instead
12:04:24 <ski> zoom84 : a type constructor is different from a data constructor
12:04:26 <frdg> how could I go about creating a type-class for Set? In the same way that fmap is defined for the Functor class, can I a define a predicate, isSet, that a individual Set (just a list to haskell) must hold for? Is what I am describing different from a type class?
12:04:44 <hc> zoom84: a type constructor yields a concrete type
12:04:45 <zoom84> ah, ok. i remember that ski.
12:05:22 <zoom84> so MyLeft and MyRight are called data constructors
12:05:24 <ski> zoom84 : `MyEither',`Int',`Bool',`Double',`IO',`(->)' are type constructors. `MyLeft',`MyRight',`False',`True' are data constructors
12:05:27 <ski> yes
12:05:28 <frdg> isSet :: [a] -> Bool
12:05:36 <sep2> @monochrom How do I go about accepting an empty finite state machine ? Q = {0}•s=0•F=∅• δ(0,a)=0foralla∈Σ.
12:05:37 <lambdabot> Unknown command, try @list
12:05:50 <sep2> That was badly formatted excuse me
12:05:50 <dolio> Either doesn't yield a concrete type after one application.
12:06:02 <ski> zoom84 : type constructors are types. but not necessarily vice versa. `MyEither Int [Bool]' is a type, but not a type constructor
12:06:12 <monochrom> Accept an empty machine? Accept an empty language?
12:06:56 <zoom84> your example is not a type constructor because it's fully applied, correct?
12:07:19 <ski> zoom84 : some type constructors are concrete (e.g. `Bool',`Int'), some aren't (e.g. `MyEither',`IO',`(->)',`Maybe'). you could also say that the latter are parameterized (/ are type functions), and the former are not parameterized (are not type functions)
12:07:51 <monochrom> Are you OK with simply emptyFSM = ([0], 0, [], \s c -> 0) ?
12:07:53 <zoom84> for example, (MyEither a) is a type constructor but (MyEither a b) is a type (and a concrete one). is that right?
12:08:12 <zoom84> the former being a constructor because it's not fully applied (ie, missing "b")
12:08:24 <ski> zoom84 : `MyEither' is parameterized, is a type function, since you can "apply" it to a type (not a value). e.g. applying it to `Int' gives `MyEither Int' .. which is also not concrete, is still a type function, still accepts a further parameter
12:09:22 <ski> zoom84 : applying `MyEither Int' to e.g. `[Bool]', you get `(MyEither Int) [Bool]', which we can write simpler just as `MyEither Int [Bool]', and this is a concrete type (no further parameters accepted), and so we can talk about values of this type `MyEither Int [Bool]'
12:09:36 <ski> (it doesn't make sense to talk about values of a non-concrete type)
12:09:57 <zoom84> got it. to fully nail down the correct terminology, both (Either a) and (Either Int) are type constructors since they're not fully applied. the former uses a parameterized var but otherwise they're called the same thing?
12:10:37 <ski> zoom84 : "your example is not a type constructor because it's fully applied, correct?" -- no. `MyEither Int [Bool]' is fully applied. type constructor is a separate issue from being concrete (some type constructors are concrete, some aren't. some concrete types are type constructors, some aren't)
12:10:52 <ski> zoom84 : no
12:11:08 <zoom84> hmm...
12:11:14 <zoom84> if I have Either a b
12:11:20 <sep2> @monochrom that's what I had originally thought but I would get error: Data constructor not in scope: Undefined :: FSM Int
12:11:20 <lambdabot> Unknown command, try @list
12:11:35 <zoom84> and use (Either a) in a functor, I thought that (Either a) implicitly creates a type constructor by dint of not being fully applied
12:11:57 <monochrom> But I didn't wrote "Undefined" anywhere.
12:12:15 <ski> a type constructor is a "single atomic name" for a type (not including type variables). like `MyEither',`Int',`Maybe',`IO',`(->)'. but not including compound/complicated types like `Maybe Int',`(->) Int Bool',`MyEither Int',`MyEither Int [Bool]'
12:12:18 <monochrom> WHO WROTE THAT?!
12:13:12 <zoom84> "Well well, what did we do here? You can see how we made Either a an instance instead of just Either. That's because Either a is a type constructor that takes one parameter, whereas Either takes two. "
12:13:20 <zoom84> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
12:13:27 <sep2> It was looking at the next line after this one, where it takes in 'a' from sigma which is undefined for now @monochrom 
12:13:52 <monochrom> You need to paste full code. I am not telepathic.
12:14:09 <maerwald> not even a little bit?
12:14:10 <ski> just like a data constructor is a "single atomic name" for an alternative of a data type. like `MyLeft',`MyRight',`Nothing',`Just',`False',`True'. but not including compound/complicated value expressions like `MyLeft 10',`MyRight [False,True,False]',`Just 42'
12:14:17 <monochrom> I am dumb.
12:14:39 <monochrom> I know that most of you are telepathic.
12:14:41 <zoom84> ski, so is the text I pasted from learnyouhaskell incorrect then?
12:14:49 * hackage uniqueness-periods-vector-examples 0.8.0.1 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.8.0.1 (OleksandrZhabenko)
12:14:55 --- mode: ChanServ set +o dolio
12:14:55 --- mode: dolio set -o monochrom
12:15:02 --- mode: dolio set -o dolio
12:15:34 <ski> zoom84 : there are two different schools of terminology. one calls parameterized types / types functions, "type constructors" (but then there's no good name for the "single atomic names of types", reserves the name "type" for what i've called "concrete type"
12:15:54 <sep2> https://dpaste.org/fFjT
12:16:27 <monochrom> OK, so use lowercase "undefined"?
12:16:31 <zoom84> ski, that's unfortunate
12:16:32 <ski> in the other school, `Functor' is not a type class, but a "constructor class" (since `f' in `Functor f' is not a "type", but a "type constructor")
12:16:44 <shaman_king> i think haskell sucks ass.
12:16:49 <ski> however, i haven't seen people use the term "constructor class" in a long time
12:16:50 --- mode: ChanServ set +o monochrom
12:17:04 --- mode: monochrom set -o monochrom
12:17:18 <ski> and i personally think the alternative terminology that i've been using is better
12:17:34 <dolio> Type functions definitely don't need another name.
12:17:43 <zoom84> btw, haven't thanked you yet for all the time you spent walking me through this. so before I continue, a huge thanks
12:17:50 <ski> (some people disagree about the "concrete" term. but otherwise, i think mostly people use "type constructor" and "type" in the sense i've been using them)
12:17:52 <dolio> With a distinct meaning from the value-level version to confuse things.
12:18:29 <zoom84> so what is the output of a data constructor called? Just data? ie, "MyLeft 50"
12:18:46 <ski> you could call it a value of a data type
12:18:47 <zoom84> z = MyLeft 50. is z just considered "data"?
12:19:21 <ski> usually people say "value" unless they have a more specific term in mind (like "integer","string","list (of ...)",&c.)
12:19:24 <zoom84> calling it a value is deeply unsatisfying :)
12:19:39 <ski> why ?
12:19:57 <ski> you could call `z' a datum (singular of "data"), if you want to
12:20:23 <ski> (btw, note that also functions are values, in Haskell)
12:20:25 <zoom84> because of habit working with other languages. I realize it is indeed just a value, esp since it's immutable. but it's hard to not just call it a variable, or at least an instance of a type
12:20:53 <ski> yea, using the "value" term tends to emphasize the immutability, which is a good thing :)
12:21:17 <ski> a "variable" is a syntactic thing
12:21:19 <monochrom> MyLeft 50 is not a variable in any sense, any culture.
12:21:35 <ski> in your program source, `z' is a variable, but `MyList 50' is not a variable
12:21:54 <ski> but the variable `z' refers (will refer) to the value `MyList 50'
12:21:58 <zoom84> mono, If in an OOP I have a class called MyLeft and a constructor which takes an int, the resulting instance would be stored in a variable, no?
12:22:00 <monochrom> I'm OK with "instance" as long as you also agree, consistently, to say that "50 is an instance of type Integer".
12:22:20 <monochrom> MyLeft is not an OOP constructor to begin with.
12:22:32 <zoom84> i guess more specifically the variable would be called a reference. or a ptr
12:22:36 <monochrom> OOP constructor means you can write arbitrary code.
12:22:43 <dolio> No, it's a variable.
12:22:49 <ski> (of course, `MyList 50' is, strictly speaking, also just text, in a source file. so when we say "the value `MyList 50'", we really mean "the value that the expression `MyList 50' describes")
12:22:50 <monochrom> MyLeft doesn't contain arbitrary code you can write.
12:22:56 <dolio> Like an actual mathematical variable.
12:23:28 <ski> variables (in Haskell, as in math) are immutable
12:23:36 <zoom84> monochrom, by culture i thought you were including other languages. do you mean specific to haskell?
12:23:54 <monochrom> By "any culture" I already include other languages.
12:24:13 <monochrom> In no language you take a literal and say "it's a variable".
12:24:22 <monochrom> 50 is a literal. MyLeft 50 is also a literal.
12:24:38 <zoom84> the literal is not a variable. the instance created by the constructor that was passed the literal is what I'm calling a variable
12:24:42 <monochrom> z is a variable but MyLeft 50 is not a variable.
12:25:01 <ski> zoom84 : if you don't name the value, then there is no variable
12:25:03 <zoom84> agreed
12:25:24 <ski> the variable is a name, that you use to refer to a value (the value described by some expression)
12:25:28 * geekosaur wonders if zoom84 is reaching for "expression"
12:25:45 <monochrom> In OOP even the objects and instances are not called variables.
12:26:13 <zoom84> let x = MyLeft(50)
12:26:20 <monochrom> And that includes both mutable objects and immutable objects.
12:26:56 <monochrom> What is dissatisfying to me is a double standard in other cultures.
12:27:05 <ski> zoom84 : btw, it's quite normal (and important) to struggle a bit, as a beginner, with terminology. first to "align vocabulary", so that you can more easily communicate without misunderstandings. but perhaps even more to "align mental maps", to form and highlight the right concepts that we use, when thinking about and discussing things
12:27:32 <sep2> @monochrom apologies. What is it implying in the '\s' in \s c->0 part? 
12:27:32 <lambdabot> Unknown command, try @list
12:28:05 <monochrom> To them, an object of a user-defined type "is an instance", but one of a built-in type like int "is not an instance". That's double standard. That's proving that in those cultures, user-defined types are second class, doesn't enjoy as much privilege as built-in types.
12:28:11 <ski> (it's not so simple as just to say "this term in Java is called this in Haskell". there are actual discrepancies between how we delineate concepts, and which concepts we elect to give importance, by naming them, talking about them)
12:28:21 <dolio> Oh man, I thought the @ might stop without the op. :P
12:28:56 <monochrom> In Haskell, we will have none of that. All types, built-in or user-defined, have values. Oh, for user-defined types the value syntax looks a bit different? Big deal, they're still values.
12:29:54 <ski> sep2 : note that it's not IRC custom/convention to adorn nicknames with sigils (like `@'). if you want to refer to someone, or address them specifically, simply mention their nickname
12:29:56 <zoom84> ski, agreed that terminology is important, esp for asking questions effectively. that's why I go out of my way to make sure I'm naming things correctly
12:30:08 <zoom84> ie, why I ask if i'm naming things correctly :)
12:30:48 <hpc> sep2: your client should tab-complete with the correct convention btw, like this
12:30:50 <ski> sep2 : in the latter case, it's good to mention their nicknames first in the message, followed by a comma or colon, and the bulk of the message. many IRC clients alert/hilight the user, if their nickname is mentioned first. not as many do that, if the nickname is not at the very start (e.g. if there a `@' in front of it)
12:31:15 <monochrom> sep2: That's a lambda.
12:31:37 <ski> sep2 : also, `@', in association with nicknames, means something specific on IRC (namely that someone is a channel operator. but even if someone has a `@' in front of their nickname, in the channel nickname list, i'd suggest not spelling `@' out, when referring to them)
12:31:38 <monochrom> I wrote an anonymous function in situ.
12:31:56 <monochrom> It's for the state transition function.
12:32:10 <ski> (sep2 : as you noticed, starting a message like "@<nickname> ..." also confuses lambdabot ..)
12:33:46 <ski> zoom84 : yea, it's fine :) .. i tend to, sometimes, nitpick a bit on ambiguous or incorrect terminology, especially if i think there's a beginner involved. i've been told several times that that has helped them to get a better understanding of the relevant concepts that we're referring to, in Haskell
12:34:30 <sep2> ski: right on I didn't notice these things until you pointed it out
12:35:32 <ski> (if someone is already more familiar with the concepts, one can afford to use more sloppy terminology, when communicating, as long as people "get what you mean" (can fallback on more explicit, on a by-need basis). but, in my experience, this is not a good thing to do, when one's learning the concepts)
12:36:20 * hackage uniqueness-periods-vector-examples 0.8.0.2 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.8.0.2 (OleksandrZhabenko)
12:40:49 <ski> zoom84 : "If in an OOP I have a class called MyLeft and a constructor which takes an int, the resulting instance would be stored in a variable, no?" -- not necessarily. e.g. `frob(new MyLeft<Integer,String>(50));'
12:43:26 <monochrom> I store my DVDs in a box. I don't call my DVDs "the box".
12:44:06 <int-e> . o O ( A DVD is a physical container for bits. )
12:45:20 <monochrom> We sometimes forgive ourselves for saying "let's watch a DVD together for two hours!" but you never literally stare at the DVD itself.
12:45:45 <no-n> lol
12:45:54 * ski . o O ( `foldDVD :: (a -> Bool -> a) -> (a -> DVD -> a)' )
12:46:52 <sep2> for taking in a letter, first example I see is Q={ε,a,T}, how do you represent the epsilon in Haskell? Theres a small diagram and looks like epsilon is start state, a end, t is trap state 
12:47:02 <ski> int-e : fwiw, `IChan' has no `Eq' instance
12:47:19 * hackage uniqueness-periods-vector-examples 0.8.0.3 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.8.0.3 (OleksandrZhabenko)
12:47:52 <tomsmeding> % :kind! FilePath
12:47:52 <yahb> tomsmeding: *; = FilePath
12:48:01 <tomsmeding> when did that stop giving me the full, normalised type?
12:48:08 <monochrom> You use Int for states, so make up some numbers 0, 1, 2 to stand for the states, instead of Greek names.
12:48:25 <tomsmeding> the ghc user's guide claims that it still does, but as can be seen, it doesn't :p
12:49:16 <monochrom> hrm, maybe it only works for type families
12:49:40 <int-e> ski: Would it be useful? I probably thought it wouldn't be because you keep hopping from one IChan value to the next all the time.
12:49:54 <tomsmeding> monochrom: it does seem to work for type families indeed
12:51:03 <monochrom> ha, yahb just replaces newline by semicolon
12:51:14 <tomsmeding> "works"
12:51:26 <ski> int-e : i guess i'd be more useful, with an `uncons :: IChan a -> Maybe (a,IChan a)'
12:51:50 * hackage wai-feature-flags 0.1.0.1 - Feature flag support for WAI applications.  https://hackage.haskell.org/package/wai-feature-flags-0.1.0.1 (JasperWoudenberg)
12:52:11 <Super_Feeling> can someone explain what this means: "y :: Int \n y = y + 1"
12:52:23 <ski> (or `isEmpty :: IChan a -> Bool',`readHead :: IChan a -> a',`readTail :: IChan a -> IChan a', if you prefer)
12:52:29 <Super_Feeling> I know y is an Int, but the second line
12:52:32 <tomsmeding> Super_Feeling: it's a bottom!
12:52:36 <ski> Super_Feeling : `y' is defined to be itself, plus one
12:52:50 <Super_Feeling> yeah but what is y then? a function, on which i can pass a value?
12:52:57 <Super_Feeling> and get the value + 1?
12:52:58 <tomsmeding> it's an integer
12:53:02 <ski> Super_Feeling : so, `y  =  y + 1  =  (y + 1) + 1  =  ((y + 1) + 1) + 1  =  ...'
12:53:10 <tomsmeding> but if you try to evaluate it, you'll infinite-loop
12:53:11 <Super_Feeling> so infinite recursion 
12:53:22 <Super_Feeling> got it, this is mind boggling 
12:53:23 <monochrom> Ah, the user guide wording includes "type synonyms" so this is not good
12:53:34 <ski> yes, there's no finite integer `y' satisfying the equation `y = y + 1'
12:53:44 <tomsmeding> monochrom: that was indeed my point, perhaps I should've saved you the search for the right paragraph :p
12:53:51 <Super_Feeling> wow, this is a lot like those recursive definitions in math
12:53:59 <tomsmeding> ski: that's suggestive of the wrong thing
12:54:11 <ski> hm ?
12:54:14 <tomsmeding> saying "y = y * 0" will also infinite-loop, though there's certainly a solution for that one
12:54:20 <dolio> There's no infinite integer, either. :)
12:54:36 <ski> tomsmeding : yes, it wasn't an "iff" condition :)
12:54:41 <tomsmeding> fair :p
12:54:48 <Super_Feeling> it basically evaluates forever. keeps on solving for y, but y contains another "y" in the definition
12:54:50 <Super_Feeling> am i right?
12:54:55 <monochrom> Yes.
12:54:55 <ski> yes
12:54:56 <tomsmeding> > let fibo = 0 : 1 : zipWith (+) fibo (tail fibo)  in  take 10 fibo
12:54:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
12:55:13 <dolio> > let y :: Integer ; y = y + 1 in y
12:55:15 <monochrom> But don't hold up your hope for "y = y * 1" either.
12:55:17 <lambdabot>  *Exception: <<loop>>
12:55:22 <ski> > let  ones = 1 : ones  in  take 10 ones
12:55:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
12:55:36 <dolio> GHC figured out not to take forever.
12:55:54 <ski> Super_Feeling : sometimes, such "cyclic/circular/recursive" definitions can be useful. but for `Int', they aren't
12:56:05 <helaoban> hi haskell, not sure where the right place to report this is, but there is a broken link on https://hackage.haskell.com/package/<package-name>/dependencies, at the bottom of the dependcies page for packages with flag-mediated dependencies there is supposed to be a link to cabal docs that explains how to use these flags, but it's broken.
12:56:26 <ski> helaoban : maybe #haskell-infrastructure ?
12:56:33 <tomsmeding> monochrom: where would I report this documentation inconsistency about :kind! ?
12:57:05 <helaoban> eg for https://hackage.haskell.org/package/cassava-0.5.2.0/dependencies, the link is http://www.haskell.org/cabal/users-guide/installing-packages.html#controlling-flag-assignments when it looks like it should be https://cabal.readthedocs.io/en/latest/setup-commands.html#controlling-flag-assignments
12:57:11 <helaoban> ski: cool, i'll try there
12:58:32 <ski> > let  y :: Natural; y = 0 * y  in  y
12:58:35 <lambdabot>  0
12:58:47 <Super_Feeling> ski got it. it's pretty mind boggling for me, since i am not used to such recursive definitions. thanks tho
12:59:35 <ski> Super_Feeling : note that an ordinary recursive(ly defined) function, is also a "circular definition". it's just that it happens to be done in a way that's productive
13:00:16 <tomsmeding> ski: doesn't work for me locally (loops), if Natural is from Numeric.Natural :p
13:00:29 <ski> > let  factorial 0 = 1; factorial n = n * factorial (n-1)  in  factorial 5
13:00:36 <lambdabot>  120
13:00:42 <Super_Feeling> i'm not really familiar with circular definition
13:00:44 <ski> > let  factorial 0 = 1; factorial n = n * factorial (n-1)  in  factorial 5  :: Expr
13:00:48 <lambdabot>  5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * ((5 - 1 - 1 - 1 - 1) * 1))))
13:01:03 <int-e> ski: That uncons would be in IO, I guess?
13:01:05 <sep2> https://dpaste.org/Hn8V Would I be in the right area trying to translate this over? included the def I'm trying to follow 
13:01:25 <monochrom> tomsmeding: Found it: https://gitlab.haskell.org/ghc/ghc/-/issues/13795
13:01:42 <tomsmeding> oh now you did my work again!
13:01:52 <ski> Super_Feeling : that definition of `factorial' is "cyclic/circular/recursive" (the definition is given as a "recurrence relation", to use some math terminology). the thing being defined (the "definiendum"), `factorial' is mentioned to the right of the `='s (what it's being defined as, the "definiens")
13:02:23 <ski> int-e : for `MIChan', yes, but not for `IChan'
13:02:27 <monochrom> I just had a hunch that it already existed.
13:02:30 <int-e> ski: Because this particular IChan is coneptually an endless stream... there's no end
13:02:47 <ski> ah, right. so no `Maybe' then
13:02:48 <int-e> ski: Oh you mean for comparisons. Sorry, I'm slow.
13:03:17 <ski> (i read the implementation, but then forgot again that they can't end)
13:03:57 <int-e> ski: It's not the most useful channel in existence. I just wanted to use those IVars for *something*.
13:04:28 <int-e> (I guess you can put your own end-of-stream markers on the channel though.)
13:04:34 <ski> tomsmeding : hm, try `y = y * 0'
13:04:55 <tomsmeding> ah that does work
13:06:18 <ski> int-e : i should probably try to use `IVar' for keeping track of shared nodes in a graph, and see where the pain points are ..
13:06:49 <ski> tomsmeding : i guess they probably changed the parameter to do induction/recursion on, at some point
13:07:34 * ski was thinking, semi-recently, about which parameter is the "correct" one, to induct on, for some of the most basic arithmetic operations, ..
13:09:25 <tomsmeding> eh, define "correct"
13:09:55 <tomsmeding> I mean. you can even alternately recurse on both parameters to find the one that's zero fastest
13:10:00 <tomsmeding> s/\./,
13:10:26 <ski> yea, part of the exercise was to search for some reasonable meaning of "correct" :)
13:11:25 <tomsmeding> I think for commutative operations, the arguments ought to be equivalent for all senses that you consider relevant
13:11:34 <monochrom> Almost sounded like you have solved the "parallel or" problem. :)  (Don't worry, it doesn't solve that problem.)
13:11:44 <ski> let's take addition. you can an accumulative definition `Z + n = n; S m + n = m + S n'. or you could have the "direct" version `Z + n = n; S m + n = S (m + n)'
13:11:56 <int-e> ski: Hmm, you don't need an IVar for that. You can achieve the same thing, more cheaply, with an IORef:  data Node a = Node !(IORef a) a; instance Eq (Node a) where Node r1 _ == Node r2 _ = r1 == r2; newNode a = Node <$> newIORef a <*> pure a. Note also, that the allocated IORef is responsible for the identity of the node...
13:12:00 <tomsmeding> so if you think evaluation strategy is important, then you should recurse on both parameters at the same time :p
13:12:11 <ski> (and then you can flip the parameter orders, if you want. and yes, you could have variants where you induct on both parameters, in different ways)
13:12:47 <int-e> ski: Or is the point that the IVar can resolve cycles, hmm.
13:12:57 <tomsmeding> and of course the proposal that meant to (re-)add a ghci command for expanding type synonyms got stranded due to inactivity :D https://github.com/ghc-proposals/ghc-proposals/pull/79
13:13:11 <monochrom> But I can see that "add Z n = n; add m Z = Z; add (S m) (S n) = S (S (add m n))" is very much nicer, like zip.
13:13:45 <int-e> ski: (which the IORef version can do as well, but it'll be more prone to undetected bugs that set a node value more than once)
13:14:00 <tomsmeding> monochrom: I very much like that one indeed :p
13:14:39 <int-e> ski: Anyway, it's certainly a use I've never ever considered before.
13:15:01 <int-e> So thanks for that :)
13:15:31 <int-e> The lack of an Ord instance will hurt eventually, I suppose.
13:15:58 <ski> int-e : yea, one could do that. but you'd need a way to generate an uninstantiated `IVar', and to instantiate it, after the fact (getting blocking read if it's not instantiated yet). and perhaps think about whether there'll be any problem with threads, due to using simple `IORef's
13:16:30 <ski> @type newCyclicIORef
13:16:31 <lambdabot> (IORef a -> a) -> IO (IORef a)
13:17:02 <ski> what's a nice way to do that, but generating multiple `IORef's ?
13:17:10 <dolio> Most refs aren't orderable, because that's not stable under GC.
13:17:14 <ski> @type newCyclicIORefT
13:17:16 <lambdabot> Traversable f => f (f (IORef a) -> a) -> IO (f (IORef a))
13:17:27 <ski> still requires all of them to be `IORef a' ..
13:17:33 <dolio> So it's more expensive to be ordered.
13:18:32 <int-e> dolio: Sure, I know why :) But for the purpose of detecting sharing, having just Eq results in a scalability problem.
13:19:05 <ski> monochrom : except it's not really that much like `zip', you get two `S's out, for one `S' in, in each parameter ?
13:19:24 <int-e> dolio: Which is not really the intended purpose of those references (Eq instance notwithstanding) so that's fine.
13:19:25 <dolio> That's why the well-ordering principle is false. :)
13:19:45 <ski> (and you still have the (lack of) parallel-or problem, that `add undefined (S n)' isn't equal to `S (add undefined n)')
13:21:09 <tomsmeding> ski: but that one you can't solve in general: you got to inspect _an_ argument first :p
13:21:17 <ski> int-e : it was the `read :: IVar a -> a' together with `instance Eq (IVar a)' (and also, of course, the ability to fill it in, independently, some time after creation time), that made it catch my attention (years ago)
13:21:29 <ski> tomsmeding : except if you race threads :)
13:22:00 <tomsmeding> that went very quickly from total language land to ugly haskell land :p
13:22:06 <int-e> ski: I still think this particular IVar is cute. However, personally, I never found a convincing use for it. :)
13:24:05 <ski> tomsmeding : anyway, to continue, i think the "direct" version is suerior to the "accumulating" version (comparing just those two), since the former is incremental, while the latter is bulky. and, with dependent types, this manifests as if you have `m0 + n' in your type, and you learn that `m0 = S m', then it can rewrite `S m + n' to `S (m + n)', and so you get an outer `S' to "match" on, rather than an 
13:24:11 <ski> opaque call to `+'
13:24:51 <tomsmeding> yes making progress early by putting an S on the outside is nice
13:25:10 <ski> (obviously i'm not talking about a strict representation of naturals here, where accumulation can make more sense, since you don't get incrementality anyway)
13:25:47 <int-e> ski: Having a pure `read` is the essence of the whole package; everything else is designed to make that possible, including all limitations.
13:26:03 <ski> int-e : ah, i see :)
13:26:17 <int-e> (limitations compared to other IVar implementations)
13:27:12 * ski . o O ( the joy of Matrix and IRCCloud netsplits ? )
13:28:07 * int-e nods
13:28:24 <ski> so, then the question is whether to induct on `m' or on `n' in `m + n'. i think, from a certain standpoint, it makes more sense to induct on `m'
13:29:13 <ski> when listing naturals in order, we tend to list them with `Z' at the leftmost, then, going rightwards, `S Z',`S (S Z)',&c.
13:29:35 <ski> (if you prefer writing right-to-left, then flip the order)
13:30:24 <ski> now consider finite prefices of the natural numbers. a type `Fin n', having the natural numbers (strictly) less than `n' as inhabitants
13:32:53 <ski> it's natural to want to define two inclusions. if `i : Fin m', then `injl i : Fin (m + n)'. and if `j : Fin n', then `injr j : Fin (m + n)'
13:34:24 <tomsmeding> which is fortunately nicely symmetric
13:34:51 <ski> let's say we picked the version of `+' that does recursion on the left operand. then we'd have `injl Z = Z; injl (S i) = S (injl i)'
13:36:10 <ski> but we realize now that for `injr', we need to induct on `m' as well. so let's define `injr j : Fin (m + n)' in terms of `m + j : Fin (m + n)', where `Z + j = j; S m + j = S (m + j)'
13:36:21 <sep2> Did I translate transition over correctly? https://dpaste.org/u84O
13:36:28 <sep2> For letter
13:36:54 <ski> we really need to induct on `m' here, not `j', since we need to rewrite the `m + n' in the type to something of the form `S (...)' to be able to use the data constructors of `Fin'
13:37:25 <ski> sep2 : what's the final state ?
13:38:29 <ski> (if we have some kind of subtyping, we could allow `i : Fin (m + n)' if `i : Fin m', eliding the explicit `injl' call which just "copies" the constructors anyway)
13:38:59 <tomsmeding> there is no single definition of + which makes both injl and injr natural, right
13:39:14 <sep2> :ski final state should be {a}
13:39:33 <sep2> • Q={ε,a,T} •.        s=ε          • F = {a}
13:39:35 <tomsmeding> so for choosing a definition of +, you'd have to look for a different motivation :p
13:40:07 <ski> so, the effect of this is that, if we list the elements of say `Fin (3 + 5)', from least element, to greatest, we start with the elements corresponding to `Fin 3', being (using syntactic sugar) `0',`1',`2', and then comes the elements corresponding to `Fin 5', that is `3 + 0',`3 + 1',`3 + 2',`3 + 3',`3 + 4'
13:40:35 <ski> sep2 : you have listed zero states (empty list), for your list of final states
13:41:24 <ski> tomsmeding : i think it's reasonable, for `Either a b', if we're listing the elements of it, to list the elements coming from `a' to the left of the elements coming from `b' (since `a' occurs to the left of `b' in the type)
13:42:10 <ski> and combining that with wanting to start from the least element, counting upwards as we're going to the right, forces this particular version of `+' (inducting on left operand)
13:42:10 <tomsmeding> kind of?
13:42:18 <ski> yea
13:42:40 <tomsmeding> I find the motivation kind of far-fetched, but sure :p
13:43:04 <tomsmeding> it does invoke the kind of asymmetry you were looking for :p
13:43:18 <ski> the premiss is somewhat weak, i agree. but it's the rationale that i've been able to find, so far, for preferring one over the other
13:43:31 <tomsmeding> though maybe I'm understating the importance of Fin in dependent-typed programming
13:43:41 <tomsmeding> s/understating/underestimating/
13:44:42 <sep2> ski: with [1] ? [0] would indicate how many states but not which state? 
13:44:53 <ski> btw, note that `Fin m + Fin n = Fin (m + n)' expresses both injections (in the left-to-right direction), but also expresses a "try to subtract `m', either discovering that the input was less than `m', or else getting a difference that's less than `n'"
13:45:39 <ski> sep2 : `0' is the way you're writing/encoding the starting state ⌜ε⌝, in Haskell
13:46:08 <sep2> https://dpaste.org/5G3N
13:46:44 <sep2> hold on
13:47:33 <ski> (similarly, `Fin m * Fin n = Fin (m * n)' expresses converting between a "coordinate pair in a rectangle" and a "running index in a rectangle". in one case, it's `(i,j) |-> i * n + j', in the other it's `k |-> (k / n,k % n)')
13:48:32 <ski> (and then, `(Fin m -> Fin n) = Fun (n ^ m)' is about converting between a number, and its digits, in a positional number system of base `n', having at most `m' digits)
13:49:30 <tomsmeding> neat
13:49:40 <ski> sep2 : `M = (states,starts,finals,transitions)' is an explanation of the rôles the different components in your quadruple, describing a finite state machine, play
13:50:00 <tomsmeding> rôles
13:50:09 <ski> one interesting thing about this is that, in this setting "division by zero" is not a problem :)
13:50:40 <tomsmeding> certainly so :p
13:51:01 <sep2> ski: so when I used [1] for final state it was saying 0,1 are final states?
13:51:12 <ski> i still haven't convinced myself whether to induct on left or right, for multiplication (although i'm heavily leaning towards left)
13:51:33 <ski> (but that's the version i assumed, when i wrote `i * n + j', rather than `i + m * j')
13:52:23 <tomsmeding> (or `n * i + j')
13:54:45 <ski> (then one can go on to have equalities/isomorphisms like `Sym (Fin n) = Fin (n !)', where `Sym A' is set of permutations (or (`Set') automorphisms, if you prefer) on `A'. it forms a group, the symmetric group, hence `Sym'. or `Sub (Fin n) (Fin k) = Fin (C n k)', where `C' is binomial coefficient, and `Sub A B' is set of `B'-sized subsets of `A' ..)
13:55:52 <ski> tomsmeding : yes, but if `+' is doing induction on left parameter, then `n * i + j' will have to traverse `n * i' (which could be quite large), rather than just `j' (which is less than `n')
13:56:35 <tomsmeding> I know, just noting that i*n+j and i+m*j are not the only options :p
13:56:36 <ski> (hm, at least if we interpret `n * i + j' as `(n * i) + j' .. rather than as a ternary (mixfix) operation)
13:56:42 <tomsmeding> lol
13:56:47 <ski> yea, good point
13:56:48 <tomsmeding> let's not go there
13:57:23 <ski> sep2 : if you only specify `1' as final state, then that's the only final state that you've specified ..
13:57:26 <ski> (a truism, i know)
13:57:42 * tomsmeding . o O ( :D )
13:58:45 <ski> unless you interpret `M = (states,start,finals,transitions)' to mean that `finals' does not contain all the final states .. but that seems a bit weird to me. would you have any particular reason for such an interpretation (and how to know what the remaining final states are, then) ?
14:00:52 <ski> tomsmeding : anyway .. i'm only partly thinking about this as an exercise in counting, combinatorics (and dependent types in general). the other reason is to experiment with a notation for defining equalities (isomorphisms) between types, directly, rather than via two functions, which are then shown to be inverses of each other ..
14:01:14 <dolio> Why is division by zero not a problem?
14:01:23 <ski> (.. and doing that has led me to want to incorporate some ideas from logic programming into the mix)
14:01:32 <tomsmeding> dolio: in that k / n, k : Fin n
14:01:44 <tomsmeding> um
14:01:44 <tomsmeding> no
14:02:01 <tomsmeding> right, k : Fin (m * n)
14:02:10 <tomsmeding> and if n = 0, then Fin (m * n) = Fin 0 = <empty>
14:02:56 <zoom84> probably a stupid question but why is the mapping func of a functor b->a instead of a->a? Is it just to provide the flexibility of returning an output whose type is different from input?
14:03:12 <Cheery> how about including (Maybe a) right in your algebra and making it closed over Nothing?
14:04:16 <sep2> ski: [1] gives me 1 and empty list rather than 1?
14:04:35 <ski> dolio : given `k : Fin (m * n)' we want to define `k / n : Fin m' and `k % n : Fin n'. we attempt to subtract `n' from `k', repeatedly, until we know `k < n'. but we have an upper bound on the number of subtractions (that's `m'), so we can't get stuck in an infinite loop. also, if `n' is zero, then `k' with `k < n' is impossible (and then `m * n = m * 0 = 0', so `k < m * n' was also impossible, to begin with)
14:06:14 <ski> zoom84 : yes. it's "just" that
14:06:20 <ski> (that's not a small thing, btw)
14:06:39 <zoom84> is there a built-in version that uses a->a instead? or would I have to write my own?
14:06:50 <ski> (also, the mathematical concept of "functor", that Haskell's `Functor' is modelled after / inspired by, requires that flexibility)
14:07:10 <tomsmeding> zoom84: b->a can also be used as a->a :p
14:07:33 <tomsmeding> > fmap (+1) [1..5]
14:07:36 <lambdabot>  [2,3,4,5,6]
14:07:51 <ski> zoom84 : <https://hackage.haskell.org/package/mono-traversable-1.0.15.1/docs/Data-MonoTraversable.html#t:MonoFunctor>
14:08:04 <dolio> Oh, I see. Dividing an element of the finite set by a factor of the index.
14:08:35 <zoom84> tomsmeding, Understood. But an a->a version would permit more flexibility, such as for constructors that take two values of the same type
14:08:48 <ski> sep2 : what do you mean by "[1] gives me 1 and empty list rather than 1?" ? i don't understand the question
14:09:01 <zoom84> thanks for the link @ski 
14:09:10 <tomsmeding> zoom84: if you have a type that can _only_ support an a->a operation, then indeed the link by ski
14:09:21 <ski> zoom84 : if you define `data Pair a = MkPair a a', then you can easily make an `instance Functor Pair where ...'
14:09:39 <tomsmeding> yes that :p
14:10:25 <ski> `MonoFunctor' is when your data type forces a particular "element type"
14:10:48 <tomsmeding> or, I guess, for stuff like Set?
14:10:50 <sep2> ski: my final state is [1], and you let me know that there's two final states in that 
14:10:57 <tomsmeding> though MonoFunctor is not really the right restriction there
14:11:04 <ski> `Functor' is when your data type is parametric, allows the user of it to specify which "element type" they want to use (and so then it's useful to be able to switch from one "element type" to another)
14:11:45 <ski> <sep2> • Q={ε,a,T} •.        s=ε          • F = {a}
14:12:00 <ski> sep2 : could you explain what is ⌜a⌝ here ?
14:13:49 <dsal> fmap for `->` is just `.` isn't it?
14:14:00 <ski> yes
14:14:30 <tomsmeding> which belongs in the list of niceties together with ($) = id
14:14:33 <ski>   fmap :: (a -> b) -> ((rho ->) a -> (rho ->) b)
14:16:00 <ski> it used to be the case, in lambdabot, that `(.)' was defined as `(.) = fmap' (with the general type, yes). also with `flip fs a = fmap ($ a) fs'
14:16:22 <ski> @type let flip fs a = fmap ($ a) fs in flip
14:16:23 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:16:59 <ski> so you could say `flip [(2 +),(2 *),(2 ^)] 3', e.g.
14:17:32 <ski> > [(2 +),(2 *),(2 ^)] `sequence` 3  -- another way to get the same thing
14:17:34 <lambdabot>  [5,6,8]
14:18:42 <ski> zoom84 : did you try making such an instance for `Pair', perhaps ?
14:18:52 <sep2> ski: I had the thought that I just fill in the numbers for a espilon, a, T  so I used 0,1,2
14:19:12 <ski> sep2 : is ⌜a⌝ a state ?, is ⌜T⌝ a state ?
14:19:14 <dolio> ski: That seems kind of like the 'division' equivalent of the type theoretic 'axiom of choice'.
14:19:42 <ski> dolio : hm, which ?
14:19:58 <tomsmeding> ski: that's an... interesting definition of 'flip'
14:20:15 <ski> > sequence ["ab","012"]  -- you mean this ?
14:20:17 <lambdabot>  ["a0","a1","a2","b0","b1","b2"]
14:20:31 <ski> tomsmeding : actually, i recall seeing it in a math paper :)
14:20:49 <dolio> ski: By that I mean, what is sometimes called 'the axiom of choice' is just rearranging a choice that has already been made. :)
14:21:12 <ski> dolio : yes. i'm just not seeing the relation to what was discussed above
14:21:18 <monochrom> Ha, I like that, dolio. :)
14:21:20 <tomsmeding> Like sure, the function is nice, but why call it 'flip' :p
14:21:21 <dolio> And this 'divide by zero' is obligated to provide the other factor of 0 as a premise.
14:22:00 <zoom84> :r
14:22:25 <ski> (Bishop expresses it as it lying in the meaning of the existential quantifier that a choice already has been made. but then, the operation that the AoC gives you needn't be extensional wrt the equivalence relation you've specified your sets (setoids) with)
14:23:05 <dolio> Right. In something like HoTT you can write a proper notion of the axiom of choice.
14:23:39 <monochrom> "If I have a whole bunch of non-empty sets" --- sounds like for each set there, I have already chosen an element.  "then their cartesian product is non-empty" --- use the aforementioned chosen elements to form the desired sequence. What can possibly go wrong? :)
14:24:04 * ski . o O ( "Intensional vs Extensional Choice" by roconnor in 2005-06-04 at <http://r6.ca/blog/20050604T143800Z.html> )
14:24:09 <dolio> Without having to decode it into the setoid interpretation explicitly.
14:24:43 <sep2> ski: from what I can tell they're all states start, end and trap 
14:25:46 <ski> dolio : well, i think it can be blind in `m'. it's just that, if `n' is zero, then there is no `k : Fin (m * 0)', and so we can't even get to the point of evaluating `k / n'
14:27:07 <dolio> But you can't call the function on `Fin i` without exhibiting a factorization of `i`.
14:27:47 <ski> sep2 : i don't know the particular flavor of FSMs that you're dealing with. but `M = (states,start,finals,transitions)' only seems to mention start state and final states as being "special", from the point of view of this general FSM description. in other words, no "trap" states. in particular FSMs that you construct, you could have some other state(s ?) that you call "trap" states, though
14:28:47 <ski> dolio : yea. i remember when i discovered that, years ago, i called it `skolem' (since i associated it with skolemization, not with axiom-of-choice, not sure i'd seen that formulation of it then)
14:29:42 <dolio> Well, I don't exactly mean it's the axiom of choice, but it's giving it the 'hard part' in a similar way.
14:30:24 <ski> sep2 : so, for your particular FSM that you're trying to encode (which one is that, at the moment, `emptyFSM' or some other ?), you can have ⌜T⌝ be a "trap" state. but you never answered me whether ⌜a⌝ was also a state, or not
14:31:58 <ski> dolio : i think it's likely that the reason why it's provable in type theory is related to the fact that mathematicians have regarded it as being obviously true
14:32:41 <ski> (it all has to do with the interpretation one gives to "there exists". and also, from what i understand, whether one allows defining quotient sets/types)
14:32:48 <dolio> Well, the problem with mathematicians is that they don't actually make the choice beforehand.
14:33:01 <ski> yea, so it's a conflation of two different senses
14:33:16 <ski> (that's how it looks to me, at least)
14:33:38 <sep2> ski: I see a would be one of the sigmas correct 
14:33:50 * hackage hsinspect 0.0.14 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.14 (tseenshe)
14:33:58 <ski> sep2 : i dunno what "the sigmas" are, in your context, so i can't answer
14:35:39 <ski> sep2 : hm, looking at your paste, perhaps `sigma' refers to your set of allowed symbols/tokens, that your FSM is meant to recognize some subset of finite words, built from such symbols, from ?
14:36:15 <monochrom> ski: Nice link to roconnor's post, thanks.
14:36:24 <dolio> I think the real problem with classical mathematics is that it extrapolates too much from finite things to infinite things.
14:36:28 <ski> dolio : "But you can't call the function on `Fin i` without exhibiting a factorization of `i`." -- yea, good point
14:37:12 <dolio> Like, excluded middle is kind of reasonable in a completely finite setting.
14:37:36 <monochrom> Also, sep2's alphabet Σ is simply {'0', '1'} or {'a', 'b'}, I forgot which, but it's a fixed hardcoded alphabet.
14:38:45 <dolio> (Still not really reasonable probably, but more reasonable.)
14:39:02 <frdg> is it possible to write `subset` with only a Foldable instance? https://dpaste.org/Vuo3
14:40:08 <ski> frdg> :t member
14:40:35 <frdg> member :: (Foldable t, Eq a) => a -> t a -> Bool
14:40:53 <monochrom> @type \xs ys -> all (\x -> elem x ys) xs
14:40:55 <lambdabot> (Foldable t1, Foldable t2, Eq a) => t1 a -> t2 a -> Bool
14:40:59 <ski> try `flip member s2' instead of `member s2'
14:41:31 <frdg> ski: I was close :)
14:41:42 <monochrom> Also it means that the two sets don't have to have the same container type.
14:41:43 <ski>   foldr ((&&) . (`member` s2)) True s1  -- would also be possible
14:44:15 <ski> @let  member x s = foldr ((||) . (== x)) False s
14:44:17 <lambdabot>  Defined.
14:44:20 <ski> @type member
14:44:21 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
14:44:35 <ski> @type \s0 s1 -> foldr ((&&) . (`member` s1)) True s0
14:44:36 <lambdabot> (Foldable t1, Foldable t2, Eq a) => t1 a -> t2 a -> Bool
14:45:44 <ski> dolio : well, there's also "subfinite" and other such fuzzy things
14:45:58 * ski . o O ( Kripke semantics )
14:46:07 <monochrom> What is subfinite?
14:46:13 <ski> a subset of a finite set
14:46:24 <ski> (which needn't be finite itself, constructively)
14:46:36 <monochrom> Yikes.
14:46:45 <ski> (that it, one can't prove it's not finite. but one can't always prove it's finite, either)
14:47:08 <monochrom> Constructive math is too hard. :)
14:47:20 <zoom84> ski, here's what I came up with for your suggestion that MkPair a a would work. Compiles and runs. Lemme know if I missed anything:
14:47:39 <zoom84> data Pair a = MkSingle a | MkPair a a deriving(Show, Eq)
14:47:43 <zoom84> instance Functor (Pair) where
14:47:48 <zoom84>     fmap :: (a -> b) -> Pair a -> Pair b
14:47:50 <ski> consider `{() | Goldbach}'. claiming this is finite amounts to having a bijection with a prefix of the natural numbers. which means that we could then decide Goldbach's conjecture from such a hypothetical proof of finiteness
14:47:53 <zoom84>     fmap f (MkPair x y) = MkPair (f x) (f y)  
14:47:57 <zoom84>     fmap f (MkSingle x) = MkSingle (f x)
14:48:22 <dolio> ski: Subfinite is a notion from constructive mathematics, though.
14:48:27 <ski> zoom84 : that's fine. although in my version, i had no `MkSingle', just `MkPair'
14:48:31 <ski> dolio : yes
14:49:01 <monochrom> I still like the fact that constructive math/logic points out where I am using non-constructive choices. But I still insist on using those non-constructive choices.
14:49:10 <ski> one can model stages of knowledge about some mathematical object or structure, with Kripke semantics
14:49:12 <dolio> Also I mean, subfinite is a concept that arises once infinite things exist.
14:49:26 <zoom84> understood ski, thanks. i wanted to include a single var constructor as well because I wanted to see fmap work for both cases in a single type
14:49:38 <monochrom> Also, I recognize that natural deduction for constructive logic is so nicely symmetric.
14:49:46 <zoom84> which can't be done for (a->b), at least with the standard functor
14:50:09 <monochrom> (However! Classical logic also also nicely symmetric in the lattice sense.)
14:50:33 <ski> so, we can have one stage ("possible world") in which neither `A' nor `not A' is known. and then have two alternative possible future stages, one in which `A' is known, and another in which `not A' is known. and the interpretation of `not Phi' is that it holds at a stage, if for no future stages (no accessible worlds) we have that `Phi' holds
14:50:42 <dolio> Ah, but so is linear logic, which is properly constructive still.
14:50:49 <ski> so, at the initial stage, we can neither claim `A' nor `not A'
14:51:43 <dolio> There's kind of a sense in which linear logic takes constructiveness more seriously than intuitionism.
14:51:47 <ski> another thing one can model here is "discovering new elements of domains". we could know that `a' and `b' are elements (generators, say) of a presentation of a group. in a later stage, we may learn `c' is also a generator
14:52:09 <ski> and at different stages, we can also learn relations between "words" involving these generators
14:52:22 <monochrom> Ah, increasing stages of knowledge. I didn't think of that analogy when I learned this.
14:52:27 <dolio> Because the linear dual of something is like a positive disproof rather than 'assuming this leads to a contradiction.'
14:52:55 <ski> so, this is about being able to reason with partial knowledge, what holds for a group presentation where `a' and `b' are generators, but we haven't decided yet if there's to be any more ? (and possibly also not decided yet whether `a = b')
14:53:01 <monochrom> (A true formalist, I just learned and obeyed the rules of making a Kripke multiverse without asking why. :) )
14:53:12 <ski> zoom84 : ah, ok
14:53:48 <monochrom> (I did have my intuition, but it's only based on "I tried many examples and they all work out, this looks solid". :) )
14:53:52 <ski> dolio : "Also I mean, subfinite is a concept that arises once infinite things exist." -- yea, i suppose so
14:54:28 <ski> monochrom : "Also, I recognize that natural deduction for constructive logic is so nicely symmetric." -- but sequent calculus for classical logic is also very nicely symmetric (even a bit more so, i'd say) :)
14:54:38 <monochrom> Yeah!
14:55:00 <monochrom> But somehow I like the lattice story more than the sequent calculus story for classical logic.
14:55:06 <ski> monochrom : .. but the problem then is that cut-elimination (normalization of proofs, removing lemmata, going to canonical/direct proofs) is non-deterministic, for the classical case
14:55:22 <monochrom> Every powerset lattice is a boolean lattice \∩/
14:55:36 <ski> (but then, classical linear logic somehow manages to be computational, not have such non-determinism ..)
14:56:00 <ski> (ah, dolio already mentioned linear logic :)
14:56:33 <dolio> There's also some work on non-linear 'logic' that has this kind of duality.
14:56:59 <dolio> You get essentially all the same connectives, but they're distinct in a different way.
14:57:12 <dolio> And the difference is evaluation order.
14:57:35 <ski> monochrom : it's interesting that for finitely presented groups, we have the "word problem", that it's not decidable whether two presented elements are equal. this proposition is "affirmative", in the sense that if they are equal, then a search of the space will eventually find the proof using the relations/laws of the presentation
14:58:26 <ski> monochrom : otoh, for real numbers, defined in terms of Cauchy sequences, it's the other way around. if they're not equal (they're apart), we'll eventually learn so, by taking fine enough approximations. but if they're equal, then inspecting the approximations won't terminate
14:58:29 <dolio> So like, + is call-by-value, and \par is call-by-name.
14:59:43 <ski> dolio : i think Mike Shulman has been trying to make use of linear logic (or actually affine, iirc), to do interesting math, to more nicely explain things (like splitting of notions) in constructive math
15:00:03 <dolio> Yeah, that's one of the things I'm drawing from.
15:00:37 <dolio> I'm not sure it's even strictly affine in the paper.
15:00:47 <ski> (it may have been you who've mentioned some links to that here. i forgot whom)
15:01:08 <ski> (hm, last time, it may have been carter, i think ?)
15:01:20 <carter> eh?
15:01:46 <ski> carter : you mentioned some paper by Mike Shulman, not too long ago, in here, yes ?
15:01:48 <dolio> Like, it suggests certain additional axioms that are based on the specific translation into intuitionistic logic.
15:01:49 <carter> yes
15:02:05 <carter> but the linearity / affinity isn't the important part :) 
15:02:09 <dolio> Like A×A -> !A.
15:02:27 <dolio> Once you have two, you have as many as you want.
15:02:53 <int-e> Oh I should really take advantage of the new-ish atomic readMVar in ivar-simple; that way an IVar would only have one MVar instead of two.
15:02:59 <carter> yeah, evaluation order + dualitiies  is nice
15:03:07 <ski> monochrom : one way to understand this constructivistic kerfuffle about "subfinite" and so on, is to think of it as being about "stages of knowledge"
15:03:47 <dolio> That's definitely the Brouwerian angle, I think.
15:04:14 <ski> (but in an epistemic modal logic, one has an explicit connective for "known" (often "by some particular agent"). but in a constructive setting, it's so to speak "built in")
15:04:16 <carter> dolio:  which semantics for par are you drawing from?
15:04:25 <carter> i think choice/& is also cbn
15:04:32 <dolio> carter: I was thinking of Compiling with Classical Connectives.
15:04:48 <dolio> Yeah, & is also call-by-name.
15:04:53 <dolio> And × is by-value.
15:04:55 <ski> monochrom : but yes, the Kripke semantics for intuitionistic logic is, iiuc, related to the one for epistemic modal logic
15:05:26 <carter> do whats their semantics for par? (i'd actually wanted to read that paper when i found it a few months ago, but it fell off my queue)
15:05:28 <int-e> ("new-ish"... refers to ghc 7.10 here, I think.)
15:05:32 <ski> (there's a "modal translation" from the former logic to the latter. at least in the propositional case, dunno about how it works with the quantifiers)
15:06:27 <dolio> ski: You should definitely look at that paper, by the way. It's got arbitrary (co)data types with constructors whose types are sequents, and can have arbitrarily many value and continuation fields.
15:06:35 <ski> dolio : oh .. that's a bit strange (the "i can't distinguish between two and infinity" one)
15:06:39 <dolio> I think I've pointed you to it, but I don't know if you've seen it.
15:07:23 <ski> carter : hm, did you look into the paper by Wadler about relating session types to linear logic ?
15:07:34 <carter> session types are trash :) 
15:07:57 <dolio> carter: A par continuation is two continuations, and a par value is a lambda term that binds two continuations, I think.
15:08:11 <carter> ok, that sounds correct
15:08:16 <carter> its forkIO by another name !
15:08:30 <ski> i think the "cbn" vs. "cbv" distinction you mentioned above is more or less the same as the "negative" vs. "positive" one, that's cropping up in some cases (focusing, uniform proof)
15:08:53 <carter> or "cbpv"
15:08:55 <dolio> Yes, but another cool thing this paper does is incorporate call-by-need and call-by-coneed.
15:09:02 <carter> ... whats that even mean
15:09:10 <carter> *coneed
15:09:19 <ski> dolio : hm, i haven't seen this one before. ty for the suggestion
15:10:15 <dolio> -by-need saves work when you do a let that gets used multiple times. -by-coneed saves work when you do a shift where the continuation gets used multiple times, or something.
15:10:41 * ski . o O ( "Compiling with Classical Connectives" by Paul Downen,Zena M. Ariola in 2020-08-28 at <https://arxiv.org/abs/1907.13227> )
15:10:59 <fraktor> Hey, I've been trying to find definitive sources on this (admittedly controversial) topic: what's the plan for the new record syntax?
15:12:03 <ski> carter : well, that session types paper does evoke such analogies as `forkIO'
15:12:40 <ski> dolio, hm, interesting
15:12:47 <carter> ski:  explicitly?
15:12:48 <carter>  i gave a talk where i dervied it
15:14:07 <ski> carter : i don't recall if it's mentioned explicitly. but i did a presentation of the paper (first part was a refreshed of linear logic), which ended by a translation table having terms like "spawn" and "join" for the `par' case
15:14:15 <dolio> ski: It's probably not all novel, but it was the first time I've seen almost everything in the paper (because I slacked on learning CBPV), so it just seemed like one cool idea after another when I read it. :)
15:14:25 <ski> (s/refreshed/refresher/)
15:15:41 <koz_> :t maybe empty pure
15:15:43 <lambdabot> Alternative f => Maybe a -> f a
15:16:12 <ski> koz_ : i sometimes wish that was in a "standard library"
15:16:21 <koz_> ski: Yeah, you and me both.
15:16:26 <koz_> It's probbo in extra or something.
15:16:50 * hackage tini 0.1.0.1 - Tiny INI file and configuration library with a minimal dependency footprint.  https://hackage.haskell.org/package/tini-0.1.0.1 (AntonEkblad)
15:17:19 <carter> ski:  oh, it def does that, the issue i have with session types is  that a lotta expositions kinda treat par as not being symmetric in the two args
15:18:55 <dolio> carter: I guess in more detail, the idea with by-need is that there can be non-trivial work to reduce a term to an actionable value when you 'let' something, and you want to delay doing that work until you need it, but only do it once. Similarly, when you capture a continuation, there might be non-trivial work to reduce it to an actionable co-value, and you similarly only want to do it once, but only if you actually jump to it.
15:20:28 * ski . o O ( `(getAlt .) . foldMap . (Alt .) :: (Foldable t,Alternative f) => (a -> f b) -> (t a -> f b)' )
15:21:18 <ski> carter : yea, it's a bit annoying, perhaps, but it seems it's what you get, for the intended application domain of session types ? (at least to a first approximation ?)
15:22:11 <ski> (note that i haven't really looked much at session types, apart from that paper relating them to linear logic .. so i might be missing some relevant stuff)
15:24:30 <moet> is it better to have a "search & extract" function like `(a -> Bool) -> [a] -> Maybe ([a], a)` or like `(a -> Bool) -> [a] -> ([a], Maybe a)` ?
15:25:05 <koz_> moet: I guess this finds (possibly) the first satisfying item, and the rest?
15:25:05 <moet> i tend to prefer the former `Maybe ([a], a)` because it communicates that there's no need to update the list in it's containing data structure because no result was found
15:25:12 <koz_> What happens if there's more than one?
15:25:46 <ski> moet : assuming i understand the context correctly, i'd go for the former, probably
15:26:20 <ski> it seems less common to want to remove an element, if present, and separately get a notification whether an element was removed
15:26:20 <moet> koz_: yes, it finds the first and returns the list with that item removed .. eg `searchExtract (=='l') "hello" == Just ("helo", 'l')`
15:26:27 <koz_> Ah.
15:26:28 <moet> koz_: if there's more than one, they're left in the list
15:26:30 <dolio> carter: I'm not sure what a great example is. The one that comes to mind is: when you capture a continuation that does some lets to build (by-need) closures after it's called, those closures should not be built for each invocation of the continuation.
15:26:52 <ski> usually, i think, one'd want to explicitly tell how to continue with the list, if the item was not present
15:26:53 <dolio> Only once, if possible, and shared.
15:27:34 <ski> dolio : maybe some `shift'&`reset' example ?
15:28:17 <moet> ski: so if i'm understanding you correctly, you agree with what i said above about preferring `Maybe ([a], a)` because it's less ambiguous in meaning than `([a], Maybe a)`?
15:28:39 <dolio> Maybe. I have trouble of thinking of good 'doing computation to determine the continuation' examples because that's basically something you can't do in most type theory.
15:28:44 <ski> (there's some paper on normalization-by-evaluation, which has a `reflect' operation that uses `shift' on sum types, to evaluate both branches, iirc .. hmm)
15:29:55 <carter> ski:  i specfically think that the session types approach to linar logica was the biggest barrier to people understanding linear logic and relating it to functional programming
15:30:03 <ski> moet : yes, the latter would allow/encourage continuing using the list (whether an element was removed or not), and perhaps later checking the removal status of the other part. if that was a common pattern one'd want to support, i'd probably go with the latter alternative (or maybe support both)
15:30:46 <ski> moet : but if it's not a likely situation (to reasonably be in), i'd go with the former, to reduce risk of bugs due to not being forced to upfront check the status
15:32:52 <ski> carter : oh, that might be so. i haven't heard of many people trying to understand linear logic (or even functional programming), coming from a session types perspective. i learned linear logic long before i heard of session types
15:33:19 <carter> How’d you manage that?
15:33:35 <ski> dolio : hm, elaborate on "doing computation to determine the continuation" ?
15:34:16 <carter> dolio:  this is the co-need bit?  the paper kinda talks about it 
15:34:30 <carter> "control effectful cbv but more efficient for weird programs"
15:34:34 <ski> carter : i dunno. i'm not sure how long session types have been a thing (i heard of them, less than ten years ago, i think). but i was reading lots of papers on various logics and type systems, and encountered linear logic that way
15:34:43 <carter> cool
15:35:10 <carter> by volume, most linear lgoic stuff in the last 20 years seems to either be in small boring fragments, or session types
15:35:13 <carter> until the past 2-5 years
15:35:21 <ski> carter : let's enable more weird programs, heh ;)
15:37:35 <dolio> carter: Yeah.
15:37:53 <carter> dolio:  wrt co-need or wrt linear logic?
15:38:03 <carter> https://ix.cs.uoregon.edu/~pdownen/presentations/beyond-polarity.pdf maybe this presentation by the author has stuff
15:38:05 <carter> skimming atm
15:38:24 <ski> a tail-recursive function (definition) is one that passes the same continuation (for output) to the recursive calls. how would a "head-recursive function (definition)", being one that passes the same value (for input) to the recursive calls, work ?
15:38:41 <carter> ski: ???
15:38:44 <dolio> ski, carter: I think another example is: if the continuation starts by doing case analysis on a sum type that is closed over by the continuation, you should just reduce that out of the continuation the first time you go through it, and memoize the result.
15:38:47 <carter> co deta?
15:38:57 <ski> ah, i suppose this is related to "message-dispatching syntax" (aka "copattern syntax") (i was thinking that before, but didn't mention)
15:39:08 <dolio> carter: co-need.
15:39:40 <ski> dolio : what's the dual situation to that ?
15:39:43 <carter> i dont like the up/down shift notations in this 
15:39:48 <carter> in these papers
15:39:49 <carter> hard to read
15:40:25 <dolio> ski: The first time you evaluate a lazy let function call, you should remember the value it produces.
15:41:34 <ski> carter : if you consider `shunt [] ys = ys; shunt (x:xs) ys = shunt xs (x:ys)' (for `reverse xs = shunt xs []'), then it inspects information in its input value (putting stuff into the accumulator), and continues looping with the same continuation (only actually used in the base casr)
15:41:50 <carter> whats this about?
15:42:22 <ski> carter : for a "head-recursive" definition, you'd pass the same input parameter `v' to the recursive call as you got in the current call. but instead, you'd extract information, by inspecting your continuation (which would change across recursive calls)
15:42:33 <argent0> Hi, what does `do ...; let foo bar = cat <$> dog <*> aniamal` means?
15:42:33 <carter> are you just talking about coinductive
15:42:49 <argent0> I ask about the `foo bar` part?
15:43:12 <ski> i was wondering if one could relate this to what dolio mentioned about "doing computation to determine the continuation"
15:43:22 <monochrom> <$> is fmap, from the Functor class.  <*> is from the Applicative class.
15:43:40 <ski> dolio : "a lazy let function call" ?
15:43:55 <monochrom> This is obviously very abstract and unnecessarily general. But this is how much information is possible from the question.
15:44:07 <argent0> monochrom: yes but how does the `foo bar` part matches
15:44:24 <monochrom> foo is a function name, bar is an argument name.
15:44:45 <monochrom> This is defining the function "foo".
15:44:55 <argent0> monochrom: ok, thanks
15:45:10 <ski> argent0 : if `cat :: I (Dog -> Animal -> Farm)', and `dog :: I Dog',`animal :: I Animal', then `cat <$> dog <*> animal :: I Farm', where `I' is some idiom (an instance of `Applicative')
15:45:11 * argent0 :-P
15:45:43 <argent0> ski: thanks I get it now
15:46:20 <ski> (er, sorry. that should be just `cat :: Dog -> Animal -> Farm'. if you had used `cat <*> dog <*> aniamal', then it would have been as i said above)
15:47:41 <ski> carter : "are you just talking about coinductive" -- more or less. thinking about how to relate it to the other topic here. have you seen "message-dispatching syntax" (perhaps read the "copatterns" paper) ?
15:47:57 <carter> copatterns are fun
15:48:13 <ski> indeed
15:48:17 <carter> ski:  did you see my thing about how to fake copatterns in haskell on reddit a few years ago
15:48:26 <ski> hm, i don't recall so ?
15:48:37 <ski> @where ErikPoll
15:48:37 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
15:48:37 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
15:48:37 <lambdabot> pdf>
15:49:17 <dolio> ski: `let y = f x` is naming (y) a computation that matches up closed-over variables in a par redex that might do non-trivial amounts of work before reducing to a value. So call-by-need says that when you want its value, you should do the work and remember the value.
15:49:22 <carter> https://www.reddit.com/r/haskell/comments/4aju8f/simple_example_of_emulating_copattern_matching_in/ ski  
15:49:49 <ski> the first two of these papers, are where i first saw the idea (which i called "message-dispatching syntax", since it seemed to obviously correspond to definitions of how objects respond to messages (by giving method implementations), in OO)
15:50:11 <dolio> Instead of re-doing the redex every time (call-by-name).
15:50:37 <carter> dolio:  aka its saying "continuations  are cbn normally in cbv languages"
15:52:16 <dolio> Something like that.
15:52:22 <Andre4> is the St Monad ( Data.STRef, DataArrayST) impure, is this monoad magic, like IO ?
15:52:28 <ski> carter : ah, cool :) .. you're emulating a record as a function taking a tag (in this case a `GADT' tag)
15:53:06 <dolio> carter: Like, they just grab the stack, and run back through it verbatim every time. They don't optimize it on the first time through.
15:53:34 <carter> dolio:  ohhh, it makes more sense when explained that way
15:53:40 <carter> call CC is terrible for exposition
15:53:43 <carter> CPS makes more sense to me 
15:53:44 <carter>  :)
15:53:59 <carter> dolio:  would this allow a faster logicT mmonad? :) 
15:54:49 * hackage ivar-simple 0.3.3 - Write once concurrency primitives.  https://hackage.haskell.org/package/ivar-simple-0.3.3 (BertramFelgenhauer)
15:55:24 <dolio> Hah. I don't know. I barely understand this paper.
15:55:42 <ski> carter : reminds me of a trick to represent `data Expr where Let :: [Decl] -> Expr -> Expr; data Decl where Def :: Ident -> [Ident] -> Expr -> Decl' as `data Tag = E | D; data AST :: Tag -> * where Let :: [AST D] -> ADT E -> AST E; Def :: Ident -> [Ident] -> AST E -> AST D'
15:55:45 <int-e> ski: ^^new release
15:55:46 <carter> Yeah. It found it a bit hard to read
15:56:21 <int-e> (it's even simpler now; writeIVar is just a putMVar, the way it was originally intended)
15:56:24 <carter> int-e: I cooked up a fun idea for an Mvar variant when helping viktor debug some fun perf issues
15:56:32 <ski> carter : the point is that if one wants to do explicit fixpoints, we can encode a type-level tuple/record as a type function from `Tag'
15:56:57 <carter> https://gitlab.haskell.org/ghc/ghc/-/issues/18798
15:57:23 <carter> ski: I’m middle of eating. So not 100% atm
15:58:33 <ski> dolio : hm, not seeing how it relates to `par'
15:58:50 <dolio> function calls are par.
15:59:37 <ski> Andre4 : neither `ST' nor `IO' are impure. but both are "magic", in the sense that they have direct support by the implementation. (they aren't defined totally in Haskell source code)
15:59:49 <dolio> I'd have to think a while how to actually write that 'let' thing. :)
15:59:57 <ski> (similarly to how `Integer',`Int',`Double',`(->)' are also "magic", or "primitive", in the same sense)
16:02:33 <carter> dolio:  more you can encode functions in par
16:02:33 <Andre4> aki: in the source code from Stref some foreign statements are included
16:04:52 <Andre4> ski: does stref, or arrayst work together with laty evaluation ?
16:05:07 <Andre4> lazy evaluation
16:06:33 <dolio> ski: Something like this, maybe: <shift k. <f|¬x:k> | let y. ...>
16:06:50 <ski> int-e : nice :D
16:08:26 <dolio> How to reduce that is ambiguous, though, and I left out all the polarity shifting that makes it deterministic. :)
16:08:38 <ski> dolio : hm, yes. but for some reason, i thought you were thinking about constructing a `par', behind the scenes, in some way there
16:10:00 <dolio> I guess you should imagine that f is actually a lambda term.
16:10:06 <dolio> To be analogous to a case statement.
16:10:38 <ski> Andre4 : yes, they don't force the values stored inside the mutable cells. however, `Control.Monad.ST' is strict in the state (the collection of `STRef's and `STArray's) that it carries around. if you want laziness there, try `Control.Monad.ST.Lazy' (i'd link you to some fun examples by monochrom here, but alas, the paste service they were on is no more ..)
16:10:52 <dolio> Then it's a β redex.
16:11:38 <ski> dolio : how should i parse `<.. | ..>' ? creating a `par' ?
16:12:16 <dolio> No, <...|...> is cut.
16:12:38 <dolio> cut a term with a coterm.
16:12:45 <ski> ah, i was just thinking it could be that
16:13:16 <dolio> Anyhow, `shift` can capture a β redex for a sum in a continuation, dually to this.
16:13:41 <ski> (still pondering how to parse it, though)
16:14:37 <dolio> Haha. <(shift k. <f|¬x:k>) | (let y. ...)>
16:14:50 <ski> what's the type of either side of the jump `<shift k. <f|¬x:k> | let y. ...>' ?
16:15:03 <ski> (yes, i took that bracketting for granted)
16:15:10 <dolio> 'let' is supposed to capture the term it's cut with in the variable (y). 'shift' captures the continuation it's cut with in `k`.
16:15:19 <ski> how does it correspond to `let y = f x in ...' ?
16:15:28 <ski> (is it the same `...' in both ?)
16:16:57 <ski> hm, ok, so `let y. ...' is a continuation, then
16:17:04 <dolio> Yeah.
16:17:23 <ski> (and that `...' is another jump)
16:17:31 <dolio> It's a continuation that captures the term it's cut with and runs a computation in an extended environment.
16:17:40 <ski> yes
16:18:09 <dolio> To make a value version of the let might require another shift or something.
16:21:54 <int-e> carter: looks risky... I'd think that marking the MVar as dirty is as much about the list of waiters (which, if you block on an MVar, contains an item in the youngest generation) as it is about the value.
16:22:14 <ski>   Γ , y : B ⊢{ ⋯y⋯ } Δ
16:22:17 <ski>   ──────────────────────
16:22:20 <ski>   Γ | let y. ⋯y⋯ : B ⊢ Δ
16:22:25 <ski> something like that
16:22:39 <dolio> Yeah, I think so.
16:23:21 <carter> ohh
16:23:25 <carter> int-e:  comment on that plz :) 
16:23:35 <ski> and ⌜¬x:k⌝ is a "calling context" of a called function, yes ?
16:24:12 <dolio> Yeah. A function continuation is an argument pushed on the return continuation.
16:24:19 <ski> right
16:24:42 <ski> (oh, that's why you used ⌜:⌝, since you're thinking of the continuation as a stack you're pushing things on)
16:25:18 <int-e> carter: you sure know how to put the "labor" into elaborate :P
16:25:31 <ski> (at first i was wondering why ⌜¬x⌝ had type ⌜k⌝ ..)
16:25:45 <dolio> Oh, sorry.
16:26:36 <dolio> I should say, that's what a function continuation value is. Or a co-value.
16:27:20 <dolio> You could also put a 'let' in there to do more stuff.
16:30:52 <argent0> :q
16:31:09 <ski>   Γ ⊢ x : A | Δ
16:31:13 <ski>   ────────────────
16:31:17 <ski>   Γ , ¬x : ¬ A ⊢ Δ   Γ | k : B ⊢ Δ
16:31:21 <ski>   ────────────────────────────────
16:31:24 <ski>   Γ | ¬x::k : A → B ⊢ Δ
16:32:26 <dolio> Yeah.
16:32:58 <ski>   Γ ⊢ f : A → B ⊢ Δ   Γ | ¬x::k : A → B ⊢ Δ
16:33:03 <ski>   ─────────────────────────────────────────
16:33:06 <ski>   Γ ⊢{ ⟨f|¬x:k⟩ } Δ
16:34:37 <dolio> Yeah, with one of the ⊢ replaced with a |.
16:34:59 <ski> er, yes
16:35:17 <ski> should have been ⌜Γ ⊢ f : A → B | Δ⌝
16:35:23 <dolio> Right.
16:36:07 <dolio> And for a genuine β redex we'ere imagining f = λ[¬x::k] <...>
16:37:35 <dolio> So it's a value cut with a covalue.
16:37:40 <ski>   Γ ⊢{ ⟨f|¬x:k⟩ } Δ
16:37:44 <ski>   ───────────────────────────────────
16:37:48 <ski>   Γ ⊢ ξ k. ⟨f|¬x:k⟩ : B | Δ ∸ (k : B)
16:37:53 <ski> and then cut with the other one
16:38:29 <ski> (i should have included ⌜k : B⌝ in ⌜Δ⌝, for the ⌜¬x::k⌝ derivation, above)
16:38:37 <dolio> Oh, you never put k in the context.
16:38:40 <dolio> Yeah.
16:39:50 <ski> hm, so we have a "critical pair"
16:40:06 <ski> each one side wanting to override the other one
16:40:46 <dolio> Yeah, so you need an evaluation strategy to decide what happens.
16:40:57 <ski> mm
16:41:09 <ski> i'm not seeing where by-need ties into this, atm, though
16:44:40 <ski> <dolio> ski, carter: I think another example is: if the continuation starts by doing case analysis on a sum type that is closed over by the continuation, you should just reduce that out of the continuation the first time you go through it, and memoize the result.
16:44:44 <ski> <dolio> ski: The first time you evaluate a lazy let function call, you should remember the value it produces.
16:44:53 <ski> <dolio> ski: `let y = f x` is naming (y) a computation that matches up closed-over variables in a par redex that might do non-trivial amounts of work before reducing to a value. So call-by-need says that when you want its value, you should do the work and remember the value.
16:45:04 <ski> (backtracking back to these now)
16:45:36 <dolio> Suppose `let` wins, B is by-name, and y occurs multiple times. Then the beta reduction happens twice, because we duplicate the whole term (I think).
16:45:59 <ski> "a sum type that is closed over by the continuation", would that be ⌜y⌝, above ?
16:47:07 <dolio> No, that would be the dual case.
16:47:54 <ski>   Γ ⊢ ξ k. ⟨f|¬x::k⟩ : B | Δ ∸ (k : B)   Γ | let y. ⋯y⋯ : B ⊢ Δ
16:47:57 <ski>   ─────────────────────────────────────────────────────────────
16:48:01 <ski>   Γ ⊢{ ⟨ξ k. ⟨f|¬x::k⟩|let y. ⋯y⋯⟩ } Δ
16:48:06 <ski> (spelling the final cut out, for easy reference)
16:49:06 <dolio> <λ[¬x::k] ... | ¬x::k> is a par redex, <inl x | case{inl x -> ... | inr y  -> ...}> is a + redex.
16:49:45 <int-e> carter: Fine there you go
16:50:42 <ski> hm, yes. in the latter, the continuation is a pair of two continuations
16:51:00 <ski> (thinking about the former)
16:51:21 <dolio> Yeah, but it's a pair of continuataions that does arbitrary computation in each case.
16:51:34 <ski> as opposed to ?
16:51:43 <dolio> Whereas par has continuations that are well-founded trees.
16:52:06 <dolio> At least, those are teh values.
16:52:10 <ski> how do you mean ?
16:52:17 <dolio> That 'case' is a continuation value for +.
16:52:23 <ski> yes
16:54:08 <dolio> Well, it's not quite true once you get into all the polarity shifting. But if you work in the system without any shifts, then par is only applicable to hereditarily by-name codata types, and those have continuation values that are well-founded trees, just like data types have term values that are well-founded trees.
16:54:43 <ski> hm, ok
16:55:18 <dolio> Codata covalues are the tree of all the projections, data values are the tree of all the constructors.
16:56:20 <dolio> And you're only allowed to substitute (co)values for variables.
16:59:58 <ski> (loking at the typing rules in the paper now .. i think i was thinking of another right rule for `par')
17:00:48 <ski> in the reductions in the first figure in the paper, are they only substituting (co)values for variables ?
17:01:10 <ski> or maybe that's the initial system they start with, and want to improve on
17:01:22 <dolio> I think the first figure is showing you the problem with classical logic.
17:01:27 <dolio> First section, even.
17:02:05 <dolio> So they can over-fix it, and then relax into something that can actually be used (kind of).
17:02:36 <ski> mhm (over-fix ?)
17:03:54 <dolio> Well, when everything is hereditarily by-name or by-value, you can't write some things, I think.
17:04:52 <dolio> You can't put a function value in an either.
17:05:51 <ski> hm, so some escaping from / explicit switching of polarity, i suppose
17:06:06 <dolio> Yeah.
17:09:07 <dolio> Actually, the identity function isn't even well-typed, I think.
17:09:32 <dolio> Because `A \par ¬A` doesn't make sense. A would have to be both positive and negative.
17:32:47 <ski> hm. reminds me of dinatural transformations
17:52:17 <Squarism> Anyone got some idea on this. I want users of a library be able to create a type TheType that can consist of any composition of records/lists/maybe/either/tuple2. All "leafs" of this structure should be of type "forall a. Leafy a => Leaf a". I want to create a serializable/textual addressing by type "Path" so that I can do that I can implement : get :: forall a b. (Leafy a,THDerivedMagic b) => b -> Path -> Maybe (Leaf a). Or, as a will be lost, ge
17:52:17 <Squarism> (THDerivedMagic b) => b -> Path -> Maybe LeafProjection.
17:53:26 <Squarism> a textual/serializable getter lens that rely on the fact all leafs carry the same parameterized type.
17:54:19 <ski> cut off after ".. Or, as a will be lost, ge"
17:55:13 <Squarism> where THDerivedMagic is an instance that TheType gets after compilation
17:55:53 <ski> "all leafs carry the same parameterized type" -- hm, "All \"leafs\" of this structure should be of type \"forall a. Leafy a => Leaf a\"" sounded like you had something like `data TheType = ... | forall a. Leafy a => Leaf a', in which case not all leaves would have the same type
17:55:54 <Squarism> ski, it continued on next row there
17:56:24 <ski> hm, so you're saying you wrote ".. Or, as a will be lost, ge(THDerivedMagic b) => b -> Path -> Maybe LeafProjection.", then ? nothing missing in the middle ?
17:56:56 <Squarism> oh ok. Man, I have a hard time explaining / figuring this out. 
17:57:37 <Squarism> ski, get :: (THDerivedMagic b) => b -> Path -> Maybe LeafProjection
17:59:10 <ski> first, i was thinking you might want something like `data TheType = FromList [TheType] | FromMaybe (Maybe TheType) | FromEither (Either TheType TheType) | FromPair (TheType,TheType) | forall a. Leafy a => Leaf a' (not sure what to do with records) .. but then the `THDerivedMagic b => ..b..' part seemed to suggest you wanted to reflect the actual structure of the nested types, in the Haskell type `b' (rather 
17:59:17 <ski> than using a single "universe" type `TheType')
17:59:18 <ski> Squarism : ty
17:59:41 <ski> i dunno what `LeafProjection' is for
18:00:15 <Squarism> I guess I'm trying to provide half of the solution wo knowing if its a good idea or not. 
18:01:28 <Squarism> Important parts are really. Let users define a type using above mentioned constructs. Be able to address leafs of that structure using textual paths/addresses. 
18:01:29 <ski> i'm not sure what `Leafy' includes .. nor what `THDerivedMagic' would provide
18:01:47 <Squarism> neither do I really.
18:02:26 <Squarism> But previous message formalizes the basic requirement. 
18:02:32 <ski> why do you want users to express themselves using exactly those particular type constructions, when interfacing with your library ?
18:02:54 <ski> do you intend to serialize values of types constructed in such a way ?
18:03:43 <ski> what if the user would like to use some other type, e.g. maybe `NonEmpty' or `Map' or `Queue' ?
18:03:54 <Squarism> I want them to freely define a process as basic data structure.
18:04:02 <Squarism> that is TheType
18:04:11 <ski> i don't understand what you mean by that
18:06:40 <ski> for the `TheType' i mentioned, i guess you could have `data Path = Here | ToIndex Int Path | InJust Path | InLeft Path | InRight Path | InFst Path | InSnd Path'
18:07:20 <ski> (not sure to which extent that type would make sense, for what you're trying to do)
18:08:37 <ski> oh .. and i suspect that instead of `get :: forall a b. (Leafy a,THDerivedMagic b) => b -> Path -> Maybe (Leaf a)', you may have intended something like `get :: forall b. THDerivedMagic b => b -> Path -> Maybe (exists a. Leafy *> a)' ..
18:08:54 <ski> .. perhaps `exists a. Leafy *> a' is what you meant by `LeafProjection' ?
18:09:02 <Squarism> Lets call the Leaf a type Step a. So users could define data TheType = TheType { s1 :: Step S1, s2 :: Maybe (Step S2, Maybe (Step S3)) } . Which would be a very simple process. Easy to serializa and pattern match
18:09:52 <Squarism> so basically i just want to great serializable addressing of Step's in this structure. 
18:10:06 <ski> another thing one could imagine (with `Path' a GADT) would be `get :: forall a b. THDerivedMagic b => b -> Path b a -> Maybe b' (dunno if you'd want a `Leafy b' somewhere in there)
18:10:32 <ski> er, sorry, that should be : `get :: forall a b. THDerivedMagic b => b -> Path b a -> Maybe a' (dunno if you'd want a `Leafy a' somewhere in there)
18:11:15 <ski> Squarism : wait a moment. is `TheType' something the library defines, or something a user of the library would define ?
18:11:37 <Squarism> Something the that the user defines 
18:12:06 <L29Ah> https://github.com/kowainik/learn4haskell lol
18:12:07 <Squarism> Basically I want to a simple textual lens library. 
18:12:32 <ski> (also, i thought `Leaf' was to be a data constructor, not a type constructor. if it was meant as a type constructor, then i doubt that you really meant `forall a. Leafy a => Leaf a' before. perhaps rather `exists a. Leafy a *> Leaf a')
18:13:06 <Squarism> ski, okok
18:13:56 <ski> i don't understand what `Step' is for
18:14:09 <ski> what is `S1',`S2',`S3' ?
18:14:11 <Squarism> its the same as "Leaf a"
18:14:33 <ski> yes, but i don't understand what `Leaf' is for, either, if it's a type constructor
18:14:36 <Squarism> S1-3 are parameters to "Step a"
18:14:46 <Squarism> its a type and and constructor
18:14:49 <ski> yes, but what purpose does `Step' have ?
18:14:59 <ski> which is a type and a constructor ?
18:15:50 <Squarism> A requirement on "TheType"  (verified by TH presumebly) is that all leafs of the datastructure are of that type. 
18:16:22 <ski> also, you didn't answer whether the library or the user would define `TheType'
18:16:38 <Squarism> I use Leaf/Step interchangeably (sorry for that). Same thing
18:16:40 <ski> oh. actually, i'm sorry. you did
18:16:46 <Squarism> so data Step 
18:16:55 <ski> (i think i got confused by the other link, at the time)
18:16:58 <Squarism> data Step a = Step a 
18:17:15 <ski> that looks fairly useless, to me
18:17:28 <Squarism> which part?
18:17:37 <ski> the whole `data' type declaration
18:17:45 <ski> it's basically just `Identity'
18:17:54 <ski> why use `Step S1' instead of just `S1' directly ?
18:18:28 <Squarism> yeah, But I leave out other information as its not important for the task at hand "Step a" will contain other info too
18:18:38 <ski> ok
18:19:28 <ski> so, the user defines some `TheType' data type, and makes it (maybe using TH), an instance of some type class (perhaps `THDerivedMagic')
18:19:53 <ski> is that correct ?
18:19:58 <Squarism> correct. 
18:20:02 <Squarism> BUT
18:20:57 <Squarism> What THDerivedMagic contains I really have to clear idea of yet. I see it will be needed at some point to collect the "analysis" of TheType. 
18:21:03 <ski> if `TheType' derives `Generic', i think you could use that to inspect how `TheType' was constructed, so that you can do different things, in e.g. an instance of `THDerivedMagic', depending on whether you see a record, a list, a `Maybe', a pair, an `Either'
18:22:06 <ski> i think looking into docs for `Generic' (or `Data' ?) could possibly be useful, for what(ever) you're actually trying to do
18:22:43 <Squarism> So the gist of this is. Give basic lens functionality to some type (TheType - defined by user). First milestone, create a getter on TheType (automatically) that answers "Maybe (StepProjection)"
18:23:13 <Squarism> and by "lens" I mean textual/serializable addresses as opposed to real lenses.
18:23:37 <Squarism> ski, ok, ill read up on Generic
18:26:23 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-programming>,<https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.14.0.0/GHC-Generics.html>
18:26:30 <ski> Squarism ^
18:27:14 <Squarism> ski, thanks. I stumbled upon that class before and see you can have a point there. I need to refresh my memory
18:27:45 <ski> i'm not totally sure whether you can do what you want to do with this. but it sounds like it could possibly be relevant
18:28:18 <Squarism> ski, thanks for helping me process this. Really appreciated. 
18:28:40 <ski> Squarism : anyway, what's `StepProjection' for ?
18:30:45 <Squarism> ski, results of the getter need to be sent over the wire. Then "a" of Step a will be out of scope. So need to make a type independent type (?) =D
18:31:03 <Squarism> "a" of "Step a" 
18:32:20 <ski> "will be out of scope" -- out of which scope ?
18:33:08 <ski> could `StepProjection' be something like `exists a. (Leafy a,Typeable a) *> a' ?
18:42:03 <Squarism> ski, imagine some "REST Controller" delegating the "get" application on TheType". 
18:42:27 <Squarism> ...that will work for all implementations of TheType
18:42:40 <Squarism> or should i say definitions
18:44:46 <Squarism> ski, " could `StepProjection' be something like `exists a. (Leafy a,Typeable a) *> a' ?" ... I really dont know. Wouldnt "a" need to be in function scope for such applications?
18:47:37 <ski> by `StepProjection' encoding `exists a. (Leafy a,Typeable a) *> a' i mean something like `data StepProjection = forall a. (Leafy a,Typeable a) => MkStepProjection a', or the equivalent (using `GADTSyntax') `data StepProjection where MkStepProjection :: (Leafy a,Typeable a) => a -> StepProjection'
18:48:25 <ski> (i dunno what you mean by "Wouldnt \"a\" need to be in function scope for such applications?" -- what is "function scope" ? are you thinking of any particular function (`get' ?) ?)
18:51:32 <ski> (an alternative encoding of `exists a. (Leafy a,Typeable a) *> a' is `forall o. (forall a. (Leafy a,Typeable a) => a -> o) -> o'. this is CPS (Continuation-Passing Style), where you pass your main result to a callback (a continuation). like `withCString :: String -> (CString -> IO a) -> IO a' or `withStep :: StepProjection -> (forall a. (Leafy a,Typeable a) => a -> o) -> o')
18:52:24 <ski> (or, i suppose, `get :: forall b. THDerivedMagic b => b -> Path -> (forall a. (Leafy a,Typeable a) => a -> o) -> o', directly)
18:53:30 <Squarism> ski, yeah "get". If I had say `myRestEndpoint :: Path -> SomeSerializableStep ; myRestEndpoint p = let r = get theTypeInstance in convertToSomeSerializableStep r` wouldnt it complain about not knowing what "a" is. "Not bound"
18:54:17 <Squarism> (oh forgot to pass p to get ^)
18:54:48 <ski> (better to say `theTypeValue', since "instance" means something else, in Haskell)
18:55:11 <ski> Squarism : what's the intended type of `convertToSomeSerializableStep', here ?
18:55:45 <ski>   convertToSomeSerializableStep :: Leafy a => a -> SomeSerializableStep  -- ?
18:56:19 <Squarism> not that important. Something that could contain the important informaiton `forall a. Step a`
18:56:36 <ski>   myRestEndpoint p = get theTypeValue p convertToSomeSerializableStep  -- in that case. using the CPS version of `get'
19:19:21 <hololeap> how important is it to know where to add INLINE pragmas these days? will compiling with -O2 on the latest GHC be sufficient without worrying about using INLINE?
19:19:53 * hololeap is actually using GHC 8.8.4, not the latest one
19:20:44 <dolio> Depends on the program.
19:23:41 <hololeap> can you elaborate, dolio?
19:24:04 <dolio> Well, if I remove all the inline pragmas from vector-algorithms, it will be a lot slower.
19:24:19 <dolio> (Unless I compensate in other ways.)
19:24:58 <dsal> If you need something inlined, or need it not inlined, you should say so.
19:25:53 <dolio> That isn't the only significant factor, necessarily. But sometimes it enables important optimizations, and GHC will not automatically inline everything.
19:26:17 <dolio> Inlining everything isn't even really desirable.
19:26:54 <hololeap> i don't understand what makes a function needing to be inlined, where GHC wouldn't already do it automatically. is there a good primer on all this?
19:26:55 <dsal> Does GHC ever automatically inline anything?  I've had pretty big optimizations from telling it to inline things I thought would be obvious.
19:27:18 <dolio> Well, here's an example from vector-algorithms again.
19:27:33 <dolio> The algorithms need to be inlined so that the code can be specialized to the comparison function.
19:27:40 <dsal> If you have a tiny function you use in a lot of places, copying the instructions will be faster than making a function call.
19:27:55 <dolio> Because if that doesn't happen, the overhead of comparing integers will be massive.
19:28:28 <hololeap> dsal: what determines the size of a function?
19:28:31 <dolio> Like, a couple instructions on unboxed values vs. function calls on boxed values.
19:29:41 <dsal> hololeap: I mean like, you write the abstraction that makes sense, but if you have something that's called enough that the overhead of calling it makes a difference in your runtime, inlining might help.
19:30:19 <dolio> The actual size of the expression is the size.
19:30:27 <dolio> I'm not sure what exactly the threshold is.
19:31:01 <dsal> If it's a lot of code, and you use it in a lot of places, inlining while make your code a lot bigger and your cache less effective.
19:31:42 <dolio> I'm pretty sure `f x = x + x` is small enough for GHC to decide to inline it automatically. But if you're in doubt, and it matters, it's better to annotate it.
19:32:11 <hololeap> ok, it's becoming clearer
19:34:02 <dolio> I've been experimenting with doing vector-algorithms with backpack, and that doesn't require inlining tons of code.
19:34:14 <hololeap> the problem is, i've been spending all my time learning haskell focusing on semantics and getting stuff to compile. i haven't looked into performance or tweaking GHC at all beyond using -O2 every time
19:34:17 <dolio> Because you can specialize the implementation to the comparson/types.
19:35:04 <dolio> Well, it might not matter a whole lot depending on what you're doing.
19:35:59 <dolio> If you're trying to beat C's qsort, though, it matters.
19:37:06 <hololeap> i'm using a lot of newtype wrappers around monad transformer stacks; packing and unpacking while using inherited typeclasses. and a lot of production code i've seen uses INLINE a lot for this type of thing. but i wonder how much of it is necessary.
19:37:46 <dsal> Profiling is usually a good step before taking action.
19:38:07 <dsal> benchmarking helps both as well, but benchmarking as an effort can be pretty misleading.
19:38:49 <hololeap> i don't even understand the difference between profiling and benchmarking :/
19:39:40 <dsal> benchmarking is writing a tool that gives you a repeatable measurement.
19:39:47 <dsal> profiling is using a tool that tells you where time is spent.
19:40:25 <dsal> So profiling might tell you that a particular function is where you spend a lot of your time.  So you write a benchmark for that function, and then do stuff to the implementation until the benchmark gives you consistently better results.
19:40:40 <dsal> It's a little tricky in haskell, but the tools are helpful.
19:40:52 <hololeap> what tools should i be looking into?
19:41:15 <dsal> criterion (or whatever that lighter version is people use, but I still use criterion, I think)
19:41:33 <dsal> And like, wherever "how to profile haskell" takes you.
19:42:24 <hololeap> cool, i will crawl the web for it, but i also appreciate specific advice from people who have done it.
19:42:46 <dsal> stack test --profile
19:42:59 <dsal> It's a report you read.
19:43:43 <dsal> Your test or application or whatever runs and then you look at it, stroke your bear, say "hmm... I see" and then your code is faster.
19:44:23 <dsal> In any case, you don't try to optimize anything you're not measuring.
19:44:41 <dsal> I've seen every optimization you can think of slow code down.
19:45:03 <hololeap> is the species of bear a crucial variable in this equation?
19:45:38 <dsal> Maybe.  It's best to go in without assumptions.
19:45:39 * ski . o O ( "Let's hug a bear." )
19:57:20 * hackage reanimate-svg 0.12.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.12.0.0 (DavidHimmelstrup)
20:18:26 <zoom84> when I load a module with a type error in a function, GHCI shows me the expected and actual types, and also shows me all the bindings. is there a way to display the bindings on command for a given function, outside of compile errors
20:19:13 <dsal> The bindings?  Are you debugging?
20:19:20 <dsal> Or do you just want type annotations?
20:19:21 <dsal> :T fix
20:19:22 <dsal> :t fix
20:19:24 <lambdabot> (a -> a) -> a
20:19:43 <zoom84> more exploring than debugging
20:19:59 <zoom84> :t shows me the sig. i'm looking to the the sig and the bindings that resulted from it
20:20:01 <lambdabot> error:
20:20:01 <lambdabot>     • Variable not in scope: me
20:20:01 <lambdabot>     • Perhaps you meant one of these:
20:20:03 <dsal> There's :browse and :i and :t
20:20:13 <dsal> I'm not quite sure what you mean by bindings.
20:20:29 <zoom84> for example, here are the bindings displayed for a compile error:
20:20:29 <dsal> Local variables inside of functions?  That's not normally a thing that you care about from the outside.
20:20:51 <zoom84>  • Occurs check: cannot construct the infinite type: a ~ (a, a)
20:20:53 <zoom84>     • In the first argument of ‘f’, namely ‘(x, y)’
20:20:54 <solonarv> you can add a typed hole somewhere in the function; that will produce a compile error telling you: the type of what should fill the hole; bindings in scope; and expressions that might be able to fill the hole
20:20:55 <zoom84>       In the expression: f (x, y)
20:20:57 <zoom84>       In an equation for ‘fmap’: fmap f (MyT (x, y)) = f (x, y)
20:20:59 <zoom84>     • Relevant bindings include
20:21:01 <zoom84>         y :: a (bound at learn.hs:806:20)
20:21:03 <zoom84>         x :: a (bound at learn.hs:806:18)
20:21:05 <zoom84>         f :: a -> b (bound at learn.hs:806:10)
20:21:07 <zoom84>         fmap :: (a -> b) -> MyTT a -> MyTT b (bound at learn.hs:806:5)
20:21:09 <zoom84> i'm looking to display the "relevent bindings include" section on command
20:21:24 <solonarv> a typed hole looks like this: _  , or _someNameHere (has to start with an underscore)
20:21:24 <dsal> Yeah, typed holes and pastebins
20:22:38 <dsal> Once you get your function done, it's basically a sealed box.  None of the insides matter to you.  When you're writing something, typed holes induce that type of thing and help you understand what goes somewhere when you're confused.
20:24:05 <zoom84> not clear where I put the typehole. do I create a new pattern match line and just do a _ on it
20:24:23 <dsal> You put it anywhere you'd put a value, but you don't know what the value is that you need.
20:24:31 <dsal> % 1 + _
20:24:36 <yahb> dsal: [Timed out]
20:24:41 <dsal> heh.  Thanks, yahb 
20:25:12 <dsal> % maximum _
20:25:18 <yahb> dsal: ; <interactive>:1:9: error:; * Found hole: _ :: [a]; Where: `a' is a rigid type variable bound by; the inferred type of it :: Ord a => a; at <interactive>:1:1-9; * In the first argument of `maximum', namely `_'; In the expression: maximum _; In an equation for `it': it = maximum _; * Relevant bindings include it :: a (bound at <interactive>:1:1); 
20:25:45 <dsal> So, I need a list of things that have an Ord instance.
20:26:50 <zoom84> i put the type hole on both the left and right site of the pattern, right?
20:27:10 <dsal> % let x = 1 :: Int in  1 + _
20:27:14 <yahb> dsal: ; <interactive>:2:26: error:; * Found hole: _ :: a; Where: `a' is a rigid type variable bound by; the inferred type of it :: Num a => a; at <interactive>:2:1-26; * In the second argument of `(+)', namely `_'; In the expression: 1 + _; In the expression: let x = 1 :: Int in 1 + _; * Relevant bindings include; x :: Int (bound at <interactive>
20:27:25 <dsal> You can put them where you'd like.  It will make suggestions for you.  e.g., it suggests x here.
20:28:39 <zoom84> if I put it only on the destructuring side doesn't that just mean I'm not interested in the pattern-matched value and thus it's not an error
20:29:48 <dsal> % let   x = 1 :: Int; y = 2 :: Int in  _ x y + x   -- contriving kind of hard, but run this in your ghci
20:29:50 <yahb> dsal: ; <interactive>:4:38: error:; * Found hole: _ :: Int -> Int -> Int; * In the expression: _; In the first argument of `(+)', namely `_ x y'; In the expression: _ x y + x; * Relevant bindings include; x :: Int (bound at <interactive>:4:7); y :: Int (bound at <interactive>:4:21); it :: Int (bound at <interactive>:4:1); Valid hole fits include; (-) ::
20:30:27 <dsal> Oh, yeah, if it's a parameter binding, it just means "don't care"
20:30:50 <zoom84> ok, it only works if I put it inside the function body
20:31:03 <zoom84> got it, thanks
20:31:58 <dsal> Well, it works if you put it somewhere you want to try to find a possible match.  This can't be a parameter, for example, because that's input.  If you want to know possible parameter values, you _ the caller
20:33:19 <zoom84> the hole trick works great, thanks
21:04:19 * hackage yesod-filter 0.1.0.0 - Automatic filter generator for Yesod  https://hackage.haskell.org/package/yesod-filter-0.1.0.0 (KenzoYotsuya)
21:14:11 <gnumonik> Hello. I'm having some trouble with the lens library. I have a complicated data structure that consists of a product type that contains a record which is a list of a sum type. I would like to use the library to write a function that allows me to set/"over" a specific (indexed) element of the list (if it exists). I can't figure out if I can do that. Everything I try runs into "can't deduce As(sum type) (Product type)" (I'm using 
21:14:11 <gnumonik> classy prisms). AFAIK I can't write a prism for a product type so I can't actually declare the instance and I'm wondering if there's another way to do this. Could someone point me in the right direction? 
21:17:02 <c_wraith> You can certainly do it.  You just need to ensure you actually have the necessary lenses available.
21:17:05 <hololeap> zoom84, _ has type `a` (e.g. anything, similar to `undefined`) and you can use it multiple times and get multiple error messages
21:17:53 <c_wraith> if you don't have a sum type, don't try to create a prism for it?
21:18:59 <hololeap> gnumonik: you might want to look at a data structure instead of lists, which supports something better than O(n) lookups with an index
21:19:45 <hololeap> like Seq (O(log(n))) or Vector (O(n))
21:19:56 <hololeap> oops... Vector (O(1))
21:19:59 <c_wraith> that seems like an entirely useless criticism
21:20:11 <c_wraith> also, if you're using over, Vector is also O(n)
21:20:19 <c_wraith> because it has to allocate an entire new one
21:21:24 <dsal> A nice thing about using lens is you can replace a list with a vector without changing code.
21:21:27 <hololeap> well, it would be more efficient when getter
21:21:40 <hololeap> *using a getter
21:22:35 <gnumonik> The lists are so short I doubt that'll make much of a difference. So actually I'm writing template haskell to generate setting/over functions, and the only case in which it doesn't work is where I have a product with one component that's a list of a sum type. And the only clue I have as to why it's not working is that can't deduce error :-(  
21:23:57 <c_wraith> well, the nice thing about lens is composability.  Break things down and figure out exactly which part is sketchy.
21:36:53 <hololeap> :t \x y -> _ (x + y)
21:36:58 <lambdabot> error:
21:36:58 <lambdabot>     • Found hole: _ :: t -> t1
21:36:58 <lambdabot>       Where: ‘t’, ‘t1’ are rigid type variables bound by
21:39:51 <gnumonik> I'm not even sure how to break this down. I've been at this for more than a week... This seems like it should work: myFunc adt val adtLens fieldPrism i = set' (adtLens . ix i . fieldPrism) val adt. But it doesn't for the list-of-sums-inside-a-product. The sketchy part, as far as I can tell, is that the product type doesn't have an instance of a class that it can't possibly have. Oh well.
21:42:43 <Axman6> gnumonik: can you share a more concrete example?
21:45:01 <Axman6> gnumonik: given that code it's difficult to tell what the types are, I can sort of infer them, but some type signatures and definitions of the sums and products would be good
21:46:31 <Axman6> :t set'
21:46:33 <lambdabot> ASetter' s a -> a -> s -> s
21:46:38 <Axman6> :t set
21:46:40 <lambdabot> ASetter s t a b -> b -> s -> t
21:47:54 <hololeap> doesn't lens composition get reversed from the usual order, e.g. (fieldPrism . ix i . adtLens), assuming that the sum type is the "topmost" structure
21:48:54 <Axman6> yeah if it's a product containing a list containing a sum then it would be fieldLens . ix i . sumPrism
21:49:05 <hololeap> "topmost" isn't very descriptive. i mean the first structure you navigate
21:49:16 <hololeap> right
21:49:29 <Axman6> it looks to me like it is doing the right thing, assuming it is what I said it is
21:51:05 <hololeap> oh, so it would be the normal order of composition then (same as functions)? i remembered composing lens' to be the opposite of what you usually do
21:52:16 <gnumonik> It's actually a sum containing a product containing a list of sums. The actual context of this is pretty substantial. I'm writing a protocol analyzer that wraps different message types in one big sum type. The 'adtLens' thing is actually a composition of lenses and prisms but I dunno that that matters 
21:52:50 <hololeap> sorry, i misread
21:52:57 * hololeap edges away from the conversation
21:54:30 <dsal> > Right (1, [Right 2, Left 3, Right 4]) ^.. _Right  . _2 . folded . _Right
21:54:33 <lambdabot>  [2,4]
21:56:45 <dsal> > Right (1, [Right 2, Left 3, Right 4]) & _Right  . _2 . traversed . _Right %~ (^2)
21:56:47 <lambdabot>  Right (1,[Right 4,Left 3,Right 16])
21:56:54 <Axman6> :t (folded, each)
21:56:56 <lambdabot> (Indexable Int p, Contravariant f1, Each s t a1 b, Foldable f2, Applicative f1, Applicative f3) => (p a2 (f1 a2) -> f2 a2 -> f1 (f2 a2), (a1 -> f3 b) -> s -> f3 t)
21:57:25 <dsal> Oh, I never think of each like that.  That's pretty neat.
21:57:37 <dsal> Lens doesn't fit in my tiny headcache
22:01:48 <gnumonik> Ugh I can't even make this more concrete. If there's nothing wrong with that function then I think I just can't do what I want with lens. That's literally the function I use.
22:04:34 <dsal> The above examples match your description.  It's hard to guess what you're doing differently.
22:06:50 * hackage reanimate-svg 0.12.1.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.12.1.0 (DavidHimmelstrup)
22:13:51 <gnumonik> Well, if I'm going to start over I have a question: My goal here is to find a way to expose lens functionality to the user without writing a bunch of boilerplate for every record field/constructor. I was trying to use TH to generate parsers for every valid combination of nested records/type constructors (i.e. the string "foo.bar" parses to the composition of lenses foo and bar). Is there an... obvious easier way to do that? 
22:15:05 <dsal> the lens library does that for you.
22:17:04 <gnumonik> huh? how?
22:20:35 <gnumonik> Er maybe that wasn't clear. What I really need is a function :: String -> Lens, since I was hoping to use the functionality in a small DSL. When I say I'm trying to generate parsers, I mean functions that take strings and spit out lenses/prisms/traversals. (I'm sorry if this is stupid, Haskell's my first programming language and I've been teaching myself without much guidance)
22:42:04 <jackdk> I think dsal's saying that the point of lens is that lenses themselves compose with `.`, so you shouldn't feel like you have to generate all the compositions yourself
22:45:53 <dsal> Well, I mean you don't have to generate the boilerplate for every field.  That's what makeLenses does.  But doing this at runtime is a bit weird.
22:47:09 <[exa]> kindof guess that gnumonik only wants an autogenerated dictionary that does f "foo" = foo
22:47:32 <[exa]> the rest (like parsing out the dot and joining the results) can be easily done with the parser
22:48:19 * hackage hoauth2 1.16.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.16.0 (HaishengWu)
22:48:50 <gnumonik> yeah, ideally i'd not have to pre-generate the entire string, but that seemed to work (up to a point anyway) whereas storing a variety of differently-typed lenses in any kind of data structure did not
22:49:28 <dsal> How would a user use this mechanism?
22:50:05 <dsal> Is it just about making runtime errors out of lens expressions?
22:53:13 <gnumonik> Not really. I wanted to somehow leverage lens to allow a user to select fields in data types that represent network packets and filter or replace those fields. But given that there are... i dunno, a few thousand network protocols out there, I wanted some way of automating the construction of functions for doing those things.
22:54:48 <dsal> I think that makes sense.  The string is throwing me off, though.  I think it's a confusing detail.  If you didn't have the string, and someone were using your library, what would they have to do now in one example?
22:57:45 <dsal> because, as jackdk says, you don't need to generate all the combinations, but you might be able to write some useful helpers that skip a few common steps.
23:04:43 <gnumonik> Well I wasn't exactly writing a library; the rest of the program (it's a packet stream generator/processor, for lack of a better term), is a small dsl for live packet modification/analysis that uses libpcap and the machines library
23:05:34 <gnumonik> If it were possible (maybe it is? couldn't figure out) to just package ghci in a binary I suppose I could just do that and skip the parsing. 
23:07:15 <dsal> Oh.  Well, I think it'd be far easier to get something parsing haskell to operate on lenses than to build a language that has some of lenses to do a subset of the same thing.  After all, we have two bots here that do that.  :)
23:09:59 <gnumonik> The sort of people who might actually use the thing probably aren't going to do so if they have to deal with stack/cabal/etc though. My intended audience wasn't exactly coextensive with haskell users. Bleh.
23:10:40 <dsal> Sure, sure.  But I don't install stack to interact with lambdabot  :)
23:11:43 <dsal> > let halt = halt in halt
23:11:46 <lambdabot>  *Exception: <<loop>>
23:12:03 <dsal> Look at that thing solving the halting problem.
23:12:27 <dsal> I wonder if I named it something else if it'd still figure out what I was doing.  It's pretty clever...
23:24:57 <gnumonik> Wait is lambdabot actually parsing and evaluating this stuff? Like it's not just echoing to and from a ghci terminal somewhere? 
23:27:29 <gnumonik> > foldr (+) [1..]
23:27:32 <lambdabot>  error:
23:27:32 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_11’
23:27:32 <lambdabot>      • In the expression: e_11
23:27:50 <gnumonik> Hm it does not work how I thought it did. 
23:29:24 <dsal> yahb is more of just a ghci
23:31:19 <gnumonik> Well I think lambdabot actually solved my problem. Some combination of mueval and hint should allow me to not have to parse an infinite number of lenses. Yay. 
23:32:26 <dsal> Yeah, that sounds pretty great.
