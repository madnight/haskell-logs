00:01:18 <siraben> Yes. I'm thinking of implementing http://3e8.org/pub/pdf-t1/macros_that_work.pdf
00:03:19 <suzu_> idk seems like a compiler design question than a haskell thing
00:05:59 <siraben> Yeah
00:47:19 * hackage ttn 0.2.0.0 - Things Tracker Network JSON Types  https://hackage.haskell.org/package/ttn-0.2.0.0 (srk)
00:59:49 * hackage ttn-client 0.2.0.0 - TheThingsNetwork client  https://hackage.haskell.org/package/ttn-client-0.2.0.0 (srk)
01:00:25 <bahamas> does anyone have an example of a function in the prelude that uses pattern matching in the definition? and another example that uses guards?
01:04:30 <hc> bahamas: pattern matching: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#head
01:05:08 <hc> guards: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#dropWhile
01:11:37 <bahamas> hc: thank you!
01:14:24 <bahamas> hc: interesting definition for "take". it uses a guard without `otherwise`, but it doesn't seem to be a problem
01:18:13 <hc> bahamas: it isn't a problem because of the ordering of patterns
01:18:44 <hc> bahamas: if the list is empty, #2 will match regardless of the value of n, unless n<=0 in which case the 2nd parameter won't be evaluated and thus an empty list wouldn't be a problem here either
01:19:06 <hc> the 3rd case will only be attempted to match if the list isn't empty
01:22:27 <bahamas> hc: yes. btw, an exclamation mark in front of a function argument forces the evaluation, right?
01:24:59 <hc> bahamas: I think so; at least that's the case in Data declarations
01:26:07 <dminuoso> bahamas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#bang-patterns-informal
01:31:24 <merijn> bahamas: btw, if all guards of a pattern fail it simply "falls through" to the next pattern of the function (similar to failing pattern matches) which can be useful in places :)
01:35:14 <bahamas> merijn: right. I had forgotten about that. `otherwise` is a catch all
01:35:30 <bahamas> dminuoso: thanks!
01:35:48 <maerwald> @src otherwise
01:35:49 <lambdabot> otherwise = True
01:36:11 <bahamas> dminuoso: oh, so it's an extension. it's not part of the report
01:36:30 <dminuoso> Right.
01:36:41 <dminuoso> bahamas: Roughly, think it to be equivalent to `seq`
01:36:50 <dminuoso> Perhaps, in hindsight, we should have had bang patterns instead of seq.
01:37:18 <dminuoso> The ergonomics of bang patterns are much better. :)
01:38:16 <dminuoso> So bang patterns are just syntactic sugar around Haskell2010, rather than introducing additional semantics.
01:38:38 <bahamas> I see
01:39:33 <dminuoso> Then we could have defined `seq !l r = r`
01:41:40 <bahamas> btw, judging from this file I assume there's an unwritten rule to put a fixity declaration at the top of a module? https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#.
01:42:19 <Taneb> bahamas: differnet libraries do it differently, I prefer to keep it close to the operator
01:42:47 <Taneb> If you're defining a lot of operators with a lot of different fixities it can make things clearer how they relate if the fixity declarations are together, though
01:43:18 <dminuoso> Though, you can quickly extract the latter knowledge by just `grep infix foo.hs`
01:43:19 * hackage Z-Data 0.1.6.1 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.6.1 (winterland)
01:43:43 <bahamas> ok. it makes sense
01:43:46 <dminuoso> Whereas relating a fixity declaration to its definition is not as easy, so I'd say keeping fixity declarations close to the definition is more useful
01:44:37 <merijn> bahamas: No, I mean even in the absense of "otherwise"
01:45:02 <merijn> bahamas: I'd say "put fixity near the definition", tbh
01:45:58 <dminuoso> But really at the end, code convention is flexible and should fit your needs.
01:46:40 <nshepperd2> I'd always put it right next to the type signature
01:46:50 <dminuoso> nshepperd2: with a semicolon?
01:46:57 <dminuoso> Or do you mean above/below?
01:47:35 <nshepperd2> err, above
01:48:08 <nshepperd2> is a semicolon legal? that would be interesting
01:48:31 <dminuoso> GHCi accepts it at least
01:49:10 <dminuoso> % infixr 6 `f`; f = f
01:49:10 <yahb> dminuoso: 
01:49:22 <dminuoso> % f :: Int; infixr 6 `f`; f = f
01:49:22 <yahb> dminuoso: 
01:49:59 <bahamas> merijn: what do you mean by "I mean even in the absense of `otherwise`"?
01:50:28 * dminuoso wonders whether merijn forgot to press enter on some message
01:55:28 <merijn> Nah, I got distracted by work
01:56:30 <merijn> bahamas: I meant that this is perfectly fine: https://paste.tomsmeding.com/bYa6W8My
01:56:43 <merijn> If the 2 guards fail, it will simply fall through to the 2nd pattern
02:01:35 <dminuoso> Useful to know, you can define let bindings in guards. :)
02:01:48 <dminuoso> Took me a while to figure that one out
02:02:06 <merijn> dminuoso: Or, you just use pattern guards :p
02:02:19 <merijn> Pattern guards are the most underrated feature of Haskell2010
02:03:09 <kuribas> merijn: I found a solution for the json representation problem.  I made a DSL for rewriting the JSON before parsing it using generics.
02:03:30 <kuribas> https://gist.github.com/kuribas/9826b1fb9f2907a5c40baff1d7bbcb83
02:03:40 <kuribas> it's typesafe
02:03:42 <merijn> Not sure I wanna click that xD
02:04:17 <dminuoso> merijn: pattern guards are more limited though
02:04:26 <merijn> dminuoso: How so?
02:04:35 <dminuoso> Can you set up recursive bindings with them?
02:04:43 <merijn> ah...probably not?
02:06:20 <dminuoso> merijn: And at the same time, why would I use `Foo r <- bar` over `let Foo r = bar`?
02:06:50 <dminuoso> Non-simple bindings are already part of Haskel2010
02:07:24 <dminuoso> I mean, pattern guards have their use for when you want to *filter* out based on non-match
02:07:31 <dminuoso> but they dont seem like a good alternative to let just for the sake of it
02:07:52 <bahamas> merijn: do you have an example of pattern guards usage?
02:08:36 <dminuoso> bahamas: https://gist.github.com/dminuoso/0da790d5ac72f0cfab1e451a306ca064
02:11:10 <kuribas> merijn: it's pretty easy
02:11:30 <kuribas> merijn: you give the destination field, and the path to the origin field.
02:11:48 <kuribas> merijn: and the destination field is typechecked against the given type.
02:12:03 <bahamas> dminuoso: thanks
02:12:17 <kuribas> merijn: and there is a Maybe variant for possible empty fields.
02:12:38 <kuribas> merijn: and the generator does the opposite operation.
02:13:29 <kuribas> merijn: here is the implementation: https://gist.github.com/kuribas/5c617ecf025ccb37467a23556cbe963e
02:14:55 <kuribas> merijn: and you simply apply the transformation before/after parsing/toJSON
02:25:45 <kuribas> merijn: this substantially reduces the amount of boilerplate required when writing manual instances.
02:26:18 <kuribas> merijn: and also solves the problem that manual instances aren't guaranteed to be consistend, when going to and from JSON.
02:28:31 <kuribas> I am not saying this solves every usecase, for everyone, but it works great for ours.
02:53:20 * hackage mu-schema 0.3.1.0 - Format-independent schemas for serialization  https://hackage.haskell.org/package/mu-schema-0.3.1.0 (AlejandroSerrano)
02:56:49 * hackage mu-rpc 0.4.0.0 - Protocol-independent declaration of services and servers.  https://hackage.haskell.org/package/mu-rpc-0.4.0.0 (AlejandroSerrano)
03:01:19 * hackage mu-lens 0.3.0.0 - Lenses for @mu-schema@ terms  https://hackage.haskell.org/package/mu-lens-0.3.0.0 (AlejandroSerrano)
03:05:49 * hackage mu-avro 0.4.0.0 - Avro serialization support for Mu microservices  https://hackage.haskell.org/package/mu-avro-0.4.0.0 (AlejandroSerrano)
03:09:20 * hackage mu-protobuf 0.4.0.0 - Protocol Buffers serialization and gRPC schema import for Mu microservices  https://hackage.haskell.org/package/mu-protobuf-0.4.0.0 (AlejandroSerrano)
03:12:49 * hackage mu-graphql 0.4.0.0 - GraphQL support for Mu  https://hackage.haskell.org/package/mu-graphql-0.4.0.0 (AlejandroSerrano)
03:16:49 * hackage uniqueness-periods-vector-examples 0.12.2.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.12.2.0 (OleksandrZhabenko)
03:18:49 * hackage mu-servant-server 0.4.0.0 - Servant servers for Mu definitions  https://hackage.haskell.org/package/mu-servant-server-0.4.0.0 (AlejandroSerrano)
03:23:19 * hackage mu-prometheus 0.4.0.0 - Metrics support for Mu using Prometheus  https://hackage.haskell.org/package/mu-prometheus-0.4.0.0 (AlejandroSerrano)
03:24:19 * hackage mu-tracing 0.4.0.0 - Tracing support for Mu  https://hackage.haskell.org/package/mu-tracing-0.4.0.0 (AlejandroSerrano)
03:48:19 * hackage data-reify 0.6.3 - Reify a recursive data structure into an explicit graph.  https://hackage.haskell.org/package/data-reify-0.6.3 (ryanglscott)
05:11:40 <xsperry> vr
05:11:52 <xsperry> r
05:24:49 * hackage Z-IO 0.1.5.0 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.5.0 (winterland)
05:47:49 * hackage barbies-th 0.1.5 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0.1.5 (FumiakiKinoshita)
05:48:34 <gentauro> leaving `intero` and reaching `HIE` which seems to be another `historical artifact`. So the way to go forward is `haskell-language-server`? https://github.com/haskell/haskell-language-server
05:50:00 <geekosaur> pretty much, yes. rather than N different approaches everyone has converged on haskell-language-server
05:50:27 <dminuoso> Well. Some, others stick with the simpler solution of `ghcid`
05:50:51 <gentauro> geekosaur: I will give it a try https://github.com/haskell/haskell-language-server#using-haskell-language-server-with-emacs :)
05:51:03 <dminuoso> You get some good portion of the functionality, but in a future proof and minimalistic way.
05:51:18 <siraben> Does anyone know if there's a way to avoid having to pass JSNoAnnot to Language.JavaScript.Parser.AST's constructors?
05:51:19 <siraben> https://github.com/siraben/lisp-to-js/blob/master/src/Translation.hs#L17-L28
05:51:20 <dminuoso> (Dunno if you will ever convince me to move from ghcid to haskell-language-server)
05:51:31 <siraben> There's a generic instance but not sure if it can help me make unannotated trees
05:51:45 <Zetagon> ghcid is pretty nice :)
05:52:04 <siraben> (also, is Language.JavaScript the best way to work with JS ASTs in Haskell?)
05:52:17 <fendor> geekosaur, also, there is a nice emacs plugin: https://gitlab.com/tseenshe/haskell-tng.el
05:53:07 <gentauro> dminuoso: I was pretty happy with `intero` but the GH-banner "No Maintenance Intended" helps me "moving on" (sadly)
05:56:19 * hackage vulkan 3.6.10 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.10 (jophish)
06:05:27 <merijn> gentauro: Basically all the tool contributors have (thankfully) converged on one platform to collaborate and work together (hls), which is good
06:06:04 <gentauro> merijn: yeah, and I can see it's under the `https://github.com/haskell/` group on GH which is nice
06:06:28 <gentauro> hopefully it's not a painfull transition and hopefully I can get up and running fast :)
06:06:57 <merijn> gentauro: I'm still on ghcide (hls builds on top of that) and it's working pretty well
06:07:27 <gentauro> merijn: roger that. Good to hear that there are alternatives to fall back to ;)
06:07:37 <geekosaur> part of the reason they converged on hls is that there's a common language server platform that's cross-language they can integrate with
06:07:39 <gentauro> but I will give `hls` a try and see how it goes
06:09:41 <fendor> if hls does not work for you, chances are, neither will ghcide
06:16:53 <gentauro> fendor: `Error when running Shake build system` ;)
06:16:56 <gentauro> good to know
06:17:21 <fendor> lol. I have never seen that one. When does that happen? 
06:17:50 <gentauro> `stack ./install.hs hls-8.6.5`
06:17:57 <gentauro> and `stack ./install.hs hls`
06:18:22 <gentauro> fendor: I will do a bit of `debugging` to see if it works (or not) then I will update with a status ;)
06:19:19 <fendor> I am trying as well. Personally, I only use cabal for installation, but that worked well and should be the same as stack...
06:19:46 <Taneb> Well, I finally got around to trying haskell-language-server
06:19:58 <Taneb> Been a while since I tried to use an IDE in, like, any language
06:22:03 <fendor> oh well, nixos and stack do not really work together...
06:24:34 <linuxnoob> haskell is terrible.
06:26:45 <Uniaika> aren't we all
06:26:54 <linuxnoob> haskell is shit.
06:28:24 <ski> all languages have bad parts
06:28:48 <ski> do you have some specific thing in mind you wanted to discuss ?
06:29:28 <merijn> Man...why engage such blatantly trolling
06:29:37 <merijn> s/trolling/obvious trolling
06:31:16 <dminuoso> ski: My language has no bad parts, I designed it particularly that way.
06:31:32 <linuxnoob> thats what she said.
06:32:15 <dminuoso> I mean consider a language specification that starts off with "This language has no bad parts", then by definition it can't be bad.
06:32:32 <linuxnoob> its shit lang thats all
06:32:45 <linuxnoob> and its also MANGLED
06:34:32 <ski> seems like you don't have any specific criticism, then .. ?
06:34:47 <linuxnoob> i get mangled output
06:35:32 <merijn> I'm putting $10 on "trying to use Haskell on Arch and blaming Haskell for Arch's brokenness"
06:35:35 <merijn> Any takers?
06:35:49 <ski> linuxnoob : what, specifically, did you try ?
06:35:53 <maerwald> raise to 100$
06:39:15 <cohn> merijn: happily using Haskell on Arch. Using `ghcup` of course...  :D
06:39:21 <merijn> cohn: Of course
06:39:32 <merijn> But can't blame beginners for trusting the distro package manager
06:39:33 <maerwald> as you should!
06:40:49 <cohn> in my experience, many programming languages are much more pleasant when you don't use the distro's package manager to manage the language's packages, libraries, etc...
06:41:06 <maerwald> only exception is C/C++
06:41:22 <cohn> for example, I switched to using the "pipenv" utility for Python and have never looked back.
06:41:27 <merijn> That's because those don't have one :p
06:41:50 <merijn> cohn: I'd give a kidney to get v2-build for python over all it's pip and virtualenv BS :(
06:41:52 <dminuoso> I have a file format that Im parsing with megaparsec. The file itself has `include` stanzas, are there combinators to fork off new parsers while running from inside one?
06:42:08 <maerwald> merijn: you can go full nix!
06:42:24 <merijn> dminuoso: That's just "liftIO + join"? :p
06:42:45 <dminuoso> merijn: No its not, it's more like runParserT and connecting error output correctly
06:42:56 <merijn> dminuoso: I'd just two stage it
06:43:04 <merijn> Handle all includes first, then parse the result
06:43:39 <dminuoso> Mmmm, that complicates the context information on diagnostics. :(
06:43:41 <cohn> merijn: yea, true. But even with C++, I find that using Eigin (http://eigen.tuxfamily.org/) is nicer than (and more current) than what apt/yum/pacman gives
06:44:10 <merijn> dminuoso: why?
06:45:48 <dminuoso> merijn: line numbers will be all wrong
06:46:09 <cohn> merijn: yes, it'd be *really* nice to have a real build system for Python. There are a few templates out there at least.
06:48:41 <merijn> dminuoso: Easily fixed by inserting some metadata
06:48:57 <merijn> "easily" ;)
06:49:00 <dminuoso> Forking off new parsers seems more easy than that
06:49:04 <cohn> also, and hopefully I don't get too many sharp, pointy objects thrown at me for saying this, but VS Code has some nice dev container templates for various languages. Sadly, no Stack or Cabal stuff. :(
06:49:32 <dminuoso> But to be fair, for my usecase, I can actually go with a 2-pass solution
06:49:45 <dminuoso> This is just a haskell code generator
06:50:02 <dminuoso> Im the sole user of that code generator...
07:03:19 <kuribas> gentauro: I am trying HLS with HIE, but I keep comming back to emacs
07:09:24 <merijn> phadej: Are there any project with a haskell-ci config file I can use as example?
07:17:50 * hackage xmonad-dbus 0.1.0.0 -   https://hackage.haskell.org/package/xmonad-dbus-0.1.0.0 (troydm)
07:44:36 <dminuoso>  (a ~ Tokens s, IsString a, Eq a, Stream s, Ord e) => IsString (ParsecT e s m a)
07:44:42 <dminuoso> Wow, that one tripped me up.
07:45:18 <dminuoso> At times, I wish I could limit the reach of OverloadedStrings.
07:46:29 <merijn> Word
07:47:16 <merijn> phadej: Relatedly: Is there any reason why the --osx flag doesn't have a wildcard that adds a job for each GHC?
08:16:53 <merijn> heh
08:17:02 <merijn> Why is GHC head in hvr's PPA 8.7?
08:21:14 <merijn> (incidentally, what happened to him, I haven't seen him in ages...)
08:40:10 <maerwald> sometimes rants on the mailing list, so probably just busy :p
08:42:00 <merijn> Ugh...Christ
08:42:08 <merijn> Travis is so brittle and broken nowadays
08:42:19 <maerwald> everyone is on github actions now
08:42:34 <merijn> maerwald: haskell-ci doesn't have a backend yet and I haven't had the time to make one :p
08:43:01 <phadej> merijn: 1) `haskell-ci dump-config`, 2) not really, and comments like maerwalds ^ really dismotivate to do anything to haskell-ci
08:43:16 <phadej> just use github actions
08:43:47 <merijn> phadej: I know about dump-config, but I'm not sure what the syntax of, e.g., the osx field looks like
08:44:00 <phadej> try, the parser will yell atyou
08:44:18 <phadej> aka. I don't really remember myself
08:44:24 <phadej> probably whitespace separated tokens
08:44:30 <merijn> phadej: Any objections to a PR that does "--osx *" or "--osx all" to just generate an OSX job for all the versions?
08:45:11 <phadej> https://github.com/haskell-CI/haskell-ci/blob/d5d3da6823acbb207f35e06ab59f71c8822ee72c/cabal.haskell-ci#L76
08:45:19 * hackage clckwrks-plugin-page 0.4.3.23 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.23 (JeremyShaw)
08:45:40 <phadej> merijn: if you also change it to use ghcup rather then haskell.futurice.com script
08:45:48 <phadej> as ghcup has wider version support
08:46:04 <phadej> ... at least for now, until maerwald's gets bored with it too :P
08:46:19 <maerwald> ;/
08:46:35 <merijn> phadej: Incidentally, the ghc-head entry fetches ghc-head from hvr's PPA but that seems to still be 8.7?
08:46:39 <maerwald> you can be sure I at least support alpine, so I don't have to use nix for static linking
08:46:48 <phadej> merijn: Herbert didn't bother to rebuild it
08:46:59 <merijn> That's what I guessed
08:47:09 <phadej> I guess he found it busy work to keep track of GHC's build system changes
08:47:11 <merijn> Does ghcup support ghc-head? Probably not?
08:47:18 <maerwald> you can install it yes
08:47:22 <merijn> \o/
08:47:40 <merijn> So maybe just rip out the PPA from haskell-ci entirely and just use ghcup always?
08:47:55 <maerwald> ghcup install ghc -u 'https://gitlab.haskell.org/api/v4/projects/1/jobs/artifacts/master/raw/ghc-x86_64-fedora27-linux.tar.xz?job=validate-x86_64-linux-fedora27' head
08:48:12 <maerwald> but there's a bug in ghc-pkg detection that requires you to *set* it as your active version
08:48:30 <merijn> maerwald: In general or in this specific head?
08:48:50 <maerwald> if you *know* the exact version, then you can use that instead of `head`
08:48:53 <phadej> merijn: haskell-ci is originally Herbert's project. Feel free to fork it.
08:49:03 <phadej> I don't think not using hvr-ppa is an option in haskell-ci
08:49:11 <maerwald> merijn: https://gitlab.haskell.org/haskell/ghcup-hs#custom-ghc-version-names
08:49:14 <merijn> hmm
08:49:30 <tomjaguarpaw> merijn: I'm not completely following the thread by I use Neil Mitchell's "neil" package for Travis CI.  It works well for the basic use cases that I have.
08:49:53 <merijn> tomjaguarpaw: Haskell-CI works fine, it's travis that's not working well :p
08:50:35 <phadej> `neil` is tuned for Neils liking, haskell-ci maintainer occasionally listens for others ;)
08:50:43 <merijn> phadej: I want to avoid forking/writing something from scratch as much as possible as I don't want to have to reinvent all your and hvr's work :p
08:51:03 <phadej> merijn: then find out how to help herbert with his ppa
08:51:18 <phadej> merijn: as far as I understood, packaging GHC is "not fun"
08:51:30 <merijn> yeah
08:52:10 <merijn> Unfortunately that's the sorta thing it's hard to make time to improve until someone starts paying me to write Haskell...
08:52:18 <phadej> in particular, hadrian is very very much not fun
08:52:44 <merijn> I'd love to spend more time on GHC/cabal-install/etc. :\
08:52:46 <phadej> it works for development like a charm, but in restricted build environments...
08:53:26 <phadej> no-one pays me (nor herbert afaik) to work on e.g. haskell-ci
08:53:40 <phadej> so, nothing new.
08:54:19 <merijn> I know, but I meant that I can sneak in some Haskell and minor PRs during work/free time, but getting familiar enough to do more comprehensive things is something I don't have time for atm
08:54:25 <tomjaguarpaw> It's interesting you say hadrian isn't fun. I thought it was supposed to be the new, "fun" way.
08:54:36 <phadej> tomjaguarpaw: it's fun for development
08:54:43 <merijn> tomjaguarpaw: "development" and "packaging" are very different beasts :)
08:55:55 <tomjaguarpaw> Interesting. Is the makefile version better for packaging?
08:56:25 <phadej> it's not better, but its dependencies are easier to manage
08:56:39 <phadej> e.g. hadrian have to be built itself, so you need to package that too
08:56:51 <phadej> and hadrians dependencies don't come in ghc source distribution
08:58:58 <phadej> in fact, source distribution for 8.10.2 doesn't seem to contain hadrian at all
08:59:36 <phadej> I guess that [hadrian for packaging] is work which is not even started
09:07:49 * hackage clckwrks-plugin-media 0.6.17 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.17 (JeremyShaw)
09:15:11 <siraben> Is there a way to do pattern matching on raw bytestrings? 
09:15:11 <siraben> ViewPatterns?
09:17:12 <merijn> siraben: What's wrong with guards?
09:20:09 <phadej> foo "bar" = ... works for bytestrings with OverloadedStrings
09:20:24 <phadej> but if you want to extract individual bytes then it's indeed trickier
09:31:49 * hackage capnp 0.6.0.3 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.6.0.3 (isd)
10:05:49 * hackage uniqueness-periods-vector-common 0.5.1.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.5.1.0 (OleksandrZhabenko)
10:12:49 * hackage deferred-folds 0.9.11 - Abstractions over deferred folds  https://hackage.haskell.org/package/deferred-folds-0.9.11 (NikitaVolkov)
10:19:50 * hackage uniqueness-periods-vector-general 0.5.1.0 - Some kind of the optimization approach to data inner structure.  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.5.1.0 (OleksandrZhabenko)
10:24:19 * hackage uniqueness-periods-vector-properties 0.5.5.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.5.5.0 (OleksandrZhabenko)
10:38:49 * hackage uniqueness-periods-vector-examples 0.12.3.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.12.3.0 (OleksandrZhabenko)
10:45:01 <z0> if we do something like `f l = go l l where go (x:xs) (y:yy:ys) = x + yy + go xs ys` is haskell keeping a single l in memory with 2 pointers behind the scenes?
10:45:42 <monochrom> Yes
10:47:06 <z0> nice. thanks
10:48:55 <z0> whats a good resource on reasoning about performance in thinks like this?
10:49:10 <z0> s/thinks/things
10:50:54 <dsal> Do you mean as to entirely copying a potentially infinite list?
10:52:00 <dsal> er, as opposed to.  I don't quite understand what else it could do.
10:52:25 <phadej> i'd rewrite that as f l = go 0 l l where go !acc (x:xs) (y:yy:ys) = go (acc + x + yy) xs ys
10:52:32 <phadej> i.e. foldr to foldl'
10:53:20 <phadej> "whats a good resource on reasoning about performance in thinks like this?" - there's plenty of resources, e.g. https://www.well-typed.com/blog/2017/09/visualize-cbn/
10:55:02 <gentauro> 16:02 < kuribas> gentauro: I am trying HLS with HIE, but I keep comming back to emacs
10:55:37 <gentauro> kuribas: I thought `hls` would work with `emacs` just like `intero` did. Still not working, but not giving up (yet)
10:56:18 * hackage prolude 0.0.0.2 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.2 (saramuse)
11:13:22 * shapr hops randomly
11:13:26 <shapr> good afternoon #haskell !
11:17:46 <juri_> shapr: hio. :)
11:18:03 <shapr> howdy juri_! You still scaddin' ?
11:18:21 <shapr> I'm in the DC area for the new few years it seems, but you've left forever, right?
11:18:40 <juri_> shapr: indeed, on both counts. :)
11:18:56 <shapr> well, too bad I didn't get to meet you when we were both in the same area
11:20:15 <juri_> watch talks, write code.. profit? :)
11:20:24 <koz_> juri_: Sounds delicious.
11:38:50 * hackage unicode-transforms 0.3.7.1 - Unicode normalization  https://hackage.haskell.org/package/unicode-transforms-0.3.7.1 (Bodigrim)
11:39:23 <ezzieyguywuf> I seem to recall reading that hledger doesn't work too great at tracking/managing investments, specificially stocks. I do that a bit in beancount today but even that's sort of a pain. Do you all know of any good, solid, FOSS tools that I can use for this?
11:39:30 <ezzieyguywuf> I don't mind manually importing transactions etc.
11:39:52 <ezzieyguywuf> also, this is "vaguely haskell related" due to hledger, but if this is more appropriate in #haskell-offtopic feel free to tell me so
12:10:35 <maerwald> the real question is: do you need blockchain?
12:32:15 <ezzieyguywuf> maerwald: I don't think so
12:32:42 <ezzieyguywuf> I have a bunch of money wrapped up in different securities and funds, and I want one centralized place where I can track their performance and figure out my allocations
13:06:38 <untseac> hello. is it me doing something really wrong or yesod uses a archaic LTS?
13:06:59 <c_wraith> that would be surprising, as yesod is the main reason stack exists
13:07:11 <untseac> hum that I didn't know
13:07:49 * hackage hwk 0.4 - Simple cli text processing with Haskell functions  https://hackage.haskell.org/package/hwk-0.4 (JensPetersen)
13:07:51 <untseac> so nobody likes stack anymore?
13:07:53 <hc> true... yesod was pretty much unusable before stack :)
13:08:08 <c_wraith> And the latest stackage LTS lists yesod
13:08:28 * hc has the feeling that the growing dislike for stack is mostly political
13:08:31 <untseac> ok so maybe the templates are just old but yesod itself is not
13:08:37 <c_wraith> that's probable
13:08:45 <unclechu> untseac: i like stack when i can’t use nix
13:09:03 <hc> i was in a webinar with fp complete once and specifically (and innocently) asked for their thoughts about nixos/cabal and didn't get an answer :)
13:09:04 <c_wraith> I don't like stack because it's extra complication that doesn't provide value for me.  But I can see how it would be useful for others.
13:09:07 <untseac> yeah I'm on arch and don't really want to bother with nix yet
13:09:11 <untseac> yeah I'm on arch and don't really want to bother with nix yet unclechu 
13:09:18 <untseac> oops duplicate
13:09:26 <koz_> https://www.stackage.org/lts-16.18/package/yesod-1.6.1.0
13:09:41 <hc> i for one wouldn't have dared to use haskell at my company without stack and the stability promise it bringe :)
13:09:44 <koz_> 16.18 is pretty recent!
13:09:46 <c_wraith> are you using matrix?  Editing messages in matrix causes its IRC bridge to resend messages.
13:10:02 <untseac> ok so it's probably just the templates
13:10:14 <koz_> untseac: Stack templates right?
13:10:19 <untseac> yeah
13:10:26 <koz_> In my experience they are completely unusable garbage in the general sense.
13:10:32 <untseac> it's on yesod webpage: https://www.yesodweb.com/page/quickstart
13:10:41 <koz_> I literally had to roll my own using cookiecutter because of how utterly useless they were.
13:10:44 <untseac> but they're using this usper old LTS
13:10:52 <koz_> Both in terms of content and documentation.
13:11:02 <untseac> which kind of made me not want to try yesod lol
13:11:10 <untseac> I was already looking into alternativs
13:11:18 <koz_> untseac: What're you trying to build?
13:11:31 <untseac> just experimenting
13:11:35 <untseac> nothing special
13:12:27 <untseac> yesod seems to be the most popular web framework in haskell right now
13:12:35 <untseac> that's why I was trying first
13:13:15 <untseac> but all main web frameworks looks okay to me to be honest
13:13:34 <davean> yesod is definately the most *marketed*
13:13:54 <koz_> davean: Interestingly enough, I had to bench yesod vs servant vs snap recently.
13:13:54 <untseac> yeah might as well start with the most marketed
13:14:03 <koz_> Yesod came out _by far_ behind the other two.
13:14:10 <davean> koz_: oh of course
13:14:22 <koz_> It also trips spurious GHC warnings with its TH.
13:14:28 <davean> Of course it does
13:14:50 <koz_> davean: You sound unsurprised.
13:14:54 <davean> Entirely
13:14:57 <koz_> LOL
13:15:06 <davean> I couldn't believe it wasn't that way
13:15:07 <koz_> Good to know I wasn't wrong to be skeptical to my workmates.
13:16:07 <untseac> I finally have a good grasp and can handle haskell more or less easily. the most annoying part is that all these places try to teach monads and friends in a weird way when it's really simple.
13:16:25 <untseac> but that's just me ranting as usual
13:17:02 <untseac> codewars helped lol
13:17:29 <koz_> I found a lot of practice helped. Weirdly, getting my first Haskell Job For Money made me improve almost instantly.
13:17:45 <untseac> yeah practice is indeed the best way to learn haskell
13:17:52 <untseac> that's what I found
13:18:23 <untseac> usually it's the opposite, read first do later, but with haskell it's just do it
13:18:38 <untseac> at least worked for me
13:19:46 <untseac> which is the most technically decent web framework btw? if there's one.
13:20:00 <davean> Depends on what you want, theres levels of complexity
13:20:06 <untseac> fair enough
13:20:09 <davean> like servant is rather complicated but buys a lot of nice features with that
13:20:24 <davean> But you might not want to pay that overhead for some basic stuff
13:20:56 <koz_> Servant is good _if_ you work in the way they intend.
13:21:09 <koz_> If you need anything else, it's _very_ difficult to work around.
13:21:19 <untseac> oof I hate that
13:21:22 <koz_> And the typelevel stuff can give _horrific_ error messages if you're not familiar with it.
13:21:23 <cohn> anyone using HDBC to connect to a SQLite database?
13:21:50 <davean> koz_: right, though I'd disagree with the "_very_ difficult" part - you can patch your own stuff in pretty easily
13:21:55 <koz_> (I literally had pages of vomit giving me headaches before going 'oh, ScopedTypeVariables wasn't on)
13:22:27 <untseac> I come from Java world so I doubt any of these web frameworks are worse
13:24:14 <koz_> cohn: What sort of issue are you seeing?
13:25:18 <cohn> koz_: can't seem to install HDBC + HDBC-sqlite3 via Stack. Wondering if it's because I'm using a too-new GHC.
13:25:33 <koz_> cohn: Exact error message (in a pastebin)?
13:26:18 <cohn> koz_: yep, one sec
13:28:02 <cohn> koz_: https://pastebin.com/eWfUc67E
13:28:16 <cohn> fwiw, this is on an OS X box
13:28:53 <koz_> Yeah, I think it's an issue that HDBC-sqlite3 leans on a deprecated library.
13:28:54 <bliminse> what were you using in Java untseac ? Spring/quarkus/micronaut?
13:28:55 <davean> Oh my sqlite is old
13:28:57 <maerwald> koz_: the funny thing is... most ppl don't make actual use of servant (e.g. sharing types or generating clients) :p
13:29:20 <bliminse> if you were using smaller frameworks (i.e., not spring), you could try warp in haskell
13:29:25 <davean> maerwald: Is that true? I know dozens of places using it and doing that.
13:29:27 <koz_> But yeah, what's your resolver?
13:29:37 <dminuoso> Where in either the Haskell report and GHC manual can I find a remark, how instance contexts are not considered for instance selection?
13:29:38 <untseac> bliminse, spring
13:29:44 <bliminse> it's going to require you implementing some things that may be available in the other frameworks but it's nowhere near as bloated
13:29:46 <untseac> it's not fun
13:29:50 <maerwald> davean: I've seen a good chunk of "let's use it, because it's cooler than scotty"
13:29:54 <bliminse> ahhh, yeah :/
13:30:00 <cohn> koz_: lts-16.16
13:30:00 <davean> maerwald: huh, never seen that.
13:30:07 <bliminse> I mean I get the appeal of spring, having the kitchen sink and then some
13:30:26 <bliminse> but all the behind-the-doors magic is not something I enjoy
13:30:39 <untseac> it's enterprise over-engineering crap tbh
13:30:45 <bliminse> and that's considering at work I have to deal with the whole spring family! xD
13:30:51 <dminuoso> In particular, Im trying to understand how instance methods of classes with superclass constraints are type checked.
13:31:25 <davean> maerwald: infact, I've often seen it used *only* to produce clients
13:31:27 <untseac> yeah my main issue with spring is that it tries to solve everything with this weird complicated mechanism but it's okayish I guess
13:31:40 <koz_> I'm wondering why it has a dependency on sqlite - neither HDBC nor HDBC-sqlite seem to want it.
13:31:43 <dminuoso> davean: Id be willing to argue that servant is great even for small APIs.
13:32:16 <dminuoso> The complexity is mostly in your head, the actual implementation of servant/servant-server is rather simple.
13:32:16 <davean> dminuoso: I didn't mean your API size anywhere
13:32:19 <cohn> koz_: it?
13:32:20 <untseac> I just want to get rid of Java. Haskell looks like the best way to make maintainable software. At least so far.
13:32:21 <koz_> cohn: What's your stack.yaml look like?
13:32:30 <maerwald> For API layer, I don't care about typed API, I want proper structural typing, so I can create web-types easily. TypeScript is better at that
13:32:37 <davean> dminuoso: Though I really dislike some of its things, like setting HTTP headers is *brokenly bad* in servant
13:32:40 <bliminse> heh yes it's very enjoyable. well so, if you want to give a try with warp you can set something up really quickly with just a few packages:
13:32:54 <cohn> koz_: I just have these lines in there. everything else is default:
13:32:55 <cohn> extra-deps:
13:32:55 <cohn>   - sqlite-0.5.5@sha256:2ffbff8fdeeb4db51550755a4a8fa73f33ac74313713a6f2608e108889d0ef13,1875
13:32:58 <cohn>   - HDBC-sqlite3-2.3.3.1@sha256:5025fd94d02b9b3f0b8b8233796dd9a85a0b3dda6503c6e671e3eddbc51cb4d4,2424
13:33:02 <davean> you have to set them in 3 places, its rediculous
13:33:10 <untseac> I don't see much future in imperative languages, not with 32 cores, which we already have. That's my noobish prepective.
13:33:11 <bliminse> warp itself, warp-tls for HTTPS, and possibly wai-extra for some handlers/middleware
13:33:18 <davean> Where as *none* of most headers is what servant is supposed to represent at the type level.
13:33:22 <koz_> Did it ask you to add the sqlite-0.5.5 line when you tried 'stack build' or something?
13:33:26 <dminuoso> davean: I agree that it has some ergonomics problems, luckily if you're the one providing an API it's a non-issue. :)
13:33:56 <cohn> koz_: yes.
13:33:57 <davean> dminuoso: incorrect?
13:34:06 <untseac> I do want to see a decent game engine in haskell but it seems like no one figured that out yet
13:34:08 <davean> The header things is exactly a case where it doesn't matter - its always a problem
13:34:16 <koz_> Can you remove that line, run 'stack build' again, and pastebin its error message?
13:34:17 <cohn> koz_: now that I think of it, I can probably get away with using sqlite-simple instead
13:34:19 <maerwald> untseac: why
13:34:28 <untseac> maerwald, why what?
13:34:29 <koz_> If you _can_, definitely do so.
13:34:33 <dminuoso> davean: What do you want to encode in headers that you can't encode in QueryParams or a ReqBody?
13:34:33 <koz_> sqlite is deprecated.
13:34:38 <maerwald> untseac: why would you want to see it
13:34:39 <cohn> koz_: lemme try that first.
13:34:43 <davean> dminuoso: You know - like cache controls?
13:34:46 <davean> HTTP semantics
13:34:54 <davean> HTTP has semantics, those semantics are controlled by headers often, they are not the client's concern and they don't represent anything on the recieve handling
13:35:16 <davean> They are decisions made about the request by the hander, based on the request, and none something the client observes
13:35:42 <davean> Which makes getting HTTP-correct requests encoded in Servant *very* difficult
13:36:09 <untseac> maerwald, because declarative seems like a good way to make games. imperative is gives too many changes to make mistakes. if everything is functional than there's a good change that it's easy to maintain. but as everybody else I don't know a good way to do it.
13:36:28 <maerwald> I think that's a fallacy, but we'd have to see
13:36:29 <dminuoso> davean: It depends on your problem domain I guess. In mine, I can get away without any caching.
13:36:49 * hackage yamlparse-applicative 0.1.0.2 - Declaritive configuration parsing with free docs  https://hackage.haskell.org/package/yamlparse-applicative-0.1.0.2 (Norfair)
13:36:57 <davean> dminuoso: Right - if you're using HTTP as a dumb transport, but it isn't. Servant's design can't really handle that sanely.
13:37:03 <untseac> perhaps maerwald but no point in not trying
13:37:14 <dminuoso> davean: Im well aware.
13:37:15 <davean> dminuoso: theres a bunch of other semantic HTTP headers
13:37:30 <maerwald> I'd rather use rust for a game engine
13:37:49 <maerwald> haskell seems more like "because I want to", not because it makes terrible sense for an engine
13:38:02 <untseac> so far it seems like it
13:38:20 <davean> maerwald: As an ex-cared-about-game-dev I can think of a few ways in which Haskell is good, or more really functional.
13:38:27 <davean> But its hard to get the other stuff right
13:38:38 <dminuoso> davean: If you grok HTTP well, and understand programming well enough, it's quite insane how people stuff data into an unstructured and inefficient protocol like JSON, and then stuff it into a highly semantic, inefficient and human readable protocol like HTTP...
13:38:45 <maerwald> engines care about performance and predictable memory consumption
13:38:48 <dminuoso> And I must admit, we do it as well
13:38:57 <untseac> real time is hard in haskell. I think anyone figured that out with some time.
13:39:02 <dminuoso> The main reason is just, it's fast to get communication between two agents with servant.
13:39:28 <dminuoso> (And in the above, my main beef isnt even HTTP, it's how JSON is an awful serialization format)
13:40:02 <maerwald> I could much rather imagine a DSL-style API around a C engine. But why do the low-level work in Haskell
13:40:05 <dminuoso> What happened to the art of writing a simple wire protocol ontop of TCP..
13:40:28 <untseac> that could be an option maerwald 
13:40:38 <cohn> koz_: yep, sqlite-simple installed without a hitch
13:40:41 <cohn> thanks!
13:40:44 <koz_> cohn: No worries.
13:40:47 <untseac> but there are many games in Java and it's far from the fastest or with predictable memory
13:40:57 <davean> maerwald: its easier to talk about the data structure changes, which are pretty critical for performance, and the functional style avoids a whole bunch of (very common in games) errors around pipelining.
13:40:58 <untseac> in fact it's really bad at predictable memory
13:42:30 <untseac> the main problem from what I see in game dev is that everyone thinks imperative by default so there's a lack of interest. Even languages other than C++ took a very long time to be popular in video game development.
13:42:35 <untseac> let alone haskell
13:42:57 <untseac> only now C# and python are popular choices
13:43:09 <davean> C++ took a while too
13:43:20 <davean> C++ use to be a lot harder to write efficiently than it is now
13:43:23 <untseac> yeah it was C before that and assembly before
13:43:53 <davean> I was mostly active in the C-like-C++-but-with-custom-assembly-for-every-CPU era
13:43:58 <untseac> game development cares more about what exists, not what can be done. after all it's a business model to sell fast.
13:44:09 <dminuoso> davean: At any rate, I fully understand your beef with servant if managing headers is something you actually have to do. I just noticed that myself and some others don't have that need.
13:44:12 <JordiGH> What's the syntax to define several where variables on the same line?
13:44:36 <JordiGH> (Haskell's the whitespace thing is an optional the whitespace thing, right?)
13:44:43 <davean> dminuoso: of course. I just wish they would have a sane approach to HTTP given its supposed to be for HTTP ;)
13:44:53 <ski> JordiGH : `... where x = 2; f y = x + y'
13:44:54 <untseac> JordiGH, put another variable bellow
13:45:10 <untseac> or that
13:45:16 <JordiGH> ski: k thanks, let me see.
13:45:19 <laserpants> Is anyone using hdevtools and Syntastic with vim/neovim? I reinstalled my machine and probably missed some step because the checks are not working. The background service is running and hdevtools is in the PATH. Typing :SyntasticInfo in vim also says that it is active.
13:45:19 <JordiGH> untseac: Below?
13:45:33 <ski> they mean, "not on the same line"
13:45:49 <untseac> y
13:46:51 <JordiGH> Alright, this works, let me see if I can figure out how to do this... I want to write a four-point recurrence... two-point is pretty easy with zipWith and tail
13:47:27 <dminuoso> davean: To partially quote monochrom: "Programming is a dialectic class struggle between the author and the user.". On one hand you want to get easy access to headers, and on the other side of the table there's the desire to consider all parameters in a request to be parameters that belong in the declarative description of the API.
13:47:47 <dminuoso> It's a trade off either way
13:48:45 <davean> dminuoso: Eh, thats true for some HTTP headers, but I don't think that can be considered true for the semantic ones because they should not be observable on either end
13:48:58 <davean> They are how the infastructure handles the transport
13:50:31 <ski> JordiGH : `as = a0 : a1 : a2 : a3 : [..an0..an1..an2..an3.. | an0:an1:an2:an3:_ <- tails as]' ?
13:50:42 <JordiGH> Okay, yeah, I don't have enough for this. I want to compute fib_2*fib_4 - fib_1*fib_3 where fib_1, fib_2, fib_3, and fib_4 are four consecutive fibonacci numbers.
13:51:27 <dminuoso> davean: Id say a web server is not separated from the semantics, it's part of it. For instance, it's your job to produce the correct semantic HTTP status codes.
13:51:29 <JordiGH> ski: Ohhhh, wait, I think I get it.
13:51:53 <JordiGH> And I also realise I didn't mean a recurrence. :-/
13:51:54 <davean> dminuoso: But its not even the server - its things like the caches inbetween, etc
13:52:08 <davean> Also, status codes are header-invariant
13:52:16 <JordiGH> I meant... taking four elements at a time from the fibonacci sequence.
13:52:26 <ski> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs]om [fib_1*fib_3 - fib_0*fib_2 | fib_0:fib_1:fib_2:fib_3:_ <- fibs]
13:52:29 <lambdabot>  <no location info>: error:
13:52:29 <lambdabot>      not an expression: ‘let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:...
13:52:36 <ski> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs] in [fib_1*fib_3 - fib_0*fib_2 | fib_0:fib_1:fib_2:fib_3:_ <- fibs]
13:52:39 <lambdabot>  error:
13:52:39 <lambdabot>      • No instance for (Num [Integer])
13:52:39 <lambdabot>          arising from a use of ‘e_101010113020123’
13:52:52 <JordiGH> A use of what??
13:53:15 <ski> er, sorry
13:53:29 <ski> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs] in [fib_1*fib_3 - fib_0*fib_2 | fib_0:fib_1:fib_2:fib_3:_ <- tails fibs]
13:53:31 <lambdabot>  [2,1,7,14,41,103,274,713,1871,4894,12817,33551,87842,229969,602071,1576238,4...
13:53:32 <ski> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs] in [fib_1*fib_3 - fib_0*fib_2 | [fib_0,fib_1,fib_2,fib_3] <- chunksOf 4 fibs]
13:53:35 <lambdabot>  [2,41,1871,87842,4126649,193864607,9107509826,427859097161,20100270056687,94...
13:53:36 <JordiGH> The ghc error messages never make any sense to me, I've learned to ignore them.
13:53:47 <ski> the latter is "four at a time". the former is "sliding window of four"
13:54:12 <davean> dminuoso: specificly headers vary on the occuring path between the client and server 
13:54:24 <davean> So you can't know them without knowing the path
13:54:38 <JordiGH> ski: Huh, thanks, okay... that wasn't the result I expected, though. Let me check my math...
13:55:01 <ski> JordiGH : perhaps i misinterpreted what you wanted, possibly ?
13:55:44 <ski> > tails "abcdefghijklmnop"
13:55:47 <lambdabot>  ["abcdefghijklmnop","bcdefghijklmnop","cdefghijklmnop","defghijklmnop","efgh...
13:55:54 <ski> > chunksOf 5 "abcdefghijklmnop"
13:55:57 <lambdabot>  ["abcde","fghij","klmno","p"]
13:56:15 <JordiGH> ski: Yeah, wait, you have the right thing, what do I have wrong, hmmm...
14:02:11 <JordiGH> ski: right, I meant fib_0*fib_3 - fib_1*fib_2 whoops
14:02:31 <JordiGH> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs] in [fib_0*fib_3 - fib_1*fib_2 | [fib_0,fib_1,fib_2,fib_3] <- chunksOf 4 fibs]
14:02:33 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
14:02:37 <JordiGH> Yay that worked.
14:02:47 <JordiGH> Except chunking but close enoguh.
14:03:14 <ski> ok
14:03:31 <JordiGH> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs] in [fib_0*fib_3 - fib_1*fib_2 | [fib_0,fib_1,fib_2,fib_3] <- tails fibs]
14:03:37 <lambdabot>  mueval-core: Time limit exceeded
14:05:21 <JordiGH> > let fibs = 0 : 1 : [fib_n0 + fib_n1 | fib_n0:fib_n1:_ <- tails fibs] in [fib_0*fib_3 - fib_1*fib_2 | fib_0:fib_1:fib_2:fib_3:_ <- tails fibs]
14:05:26 <lambdabot>  [-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,...
14:05:29 <JordiGH> w00t
14:05:41 <JordiGH> ski: thank you so much!
14:06:02 <JordiGH> But that took a while to compute, is this doing the dumb exponential recursive thing?
14:06:59 <ski> no
14:09:08 <JordiGH> Hm, how do I make ghci remember readline history across sessions?
14:12:08 <dminuoso> Doesn't ghci do this out of the box already?
14:12:32 <JordiGH> Oh, it does, my bad, sorry.
14:15:05 <koz_> Does anyone know if snap-core's Params type handles percent encoding for you, or whether you have to do it yourself?
14:15:20 <koz_> I _think_ the answer is 'you have to do it yourself', but I'd like to be sure.
14:16:03 <kelanu> I noticed that Google Colab said it supports the IHaskell kernel, which got me pretty excited. But I can't find any documentation for this, any ideas? I fonud a StackOverflow but it was removed.
15:09:31 <dminuoso> I have the desire to write some `f :: proxy (s :: Symbol) -> T (TyFam s)`, but the ergonomics looks annoying. Is there something that lets me write `f "foo"` rather than `f (Proxy @"foo")`?
15:10:12 <dminuoso> Maybe through some extension?
15:11:41 <newhoggy> Axman6: Did you send me a message?  I think can't find it anymore.
15:13:42 <dminuoso> Mmm. I think OverloadedLabels is what Im after..
15:15:16 <dolio> Oh, I wasn't aware of that.
15:16:54 <dolio> So that lets you write `f ?field`?
15:17:08 <dminuoso> f #field
15:17:37 <dminuoso> not sure how to deal with spaces or special characters
15:17:49 * hackage little-rio 0.2.2 - When you need just the RIO monad  https://hackage.haskell.org/package/little-rio-0.2.2 (ejconlon)
15:18:00 <dolio> Oh yeah, I was reading the 'digression'.
15:18:08 <dminuoso> Perhaps parens could be used?
15:18:22 <dminuoso> % instance IsLabel "x y" Int where fromLabel = 42
15:18:23 <yahb> dminuoso: 
15:18:30 <dminuoso> % (#x y)
15:18:30 <yahb> dminuoso: ; <interactive>:114:6: error: parse error on input `)'
15:18:33 <dminuoso> Mmm
15:20:04 <dminuoso> Yeah, this is going to be a tough one. At the very least I need hyphens to be there.
15:21:19 <dminuoso> Perhaps this is the point where replacing the Proxy with forall + TypeApplications is sensible
15:21:28 <dminuoso> Then I could just say `f @"foo-bar" ...`
15:35:45 <hekkaidekapus> <circa 20:30 UTC> dminuoso In particular, Im trying to understand how instance methods of classes with superclass constraints are type checked.
15:36:05 <hekkaidekapus> dminuoso: I don’t have a quotation from the report/manual, but there is <https://www.microsoft.com/en-us/research/publication/type-inference-as-constraint-solving-how-ghcs-type-inference-engine-actually-works>.
15:36:46 <hekkaidekapus> I managed to dig out the slides if you are not into videos: <https://drive.google.com/file/d/1NRkP0hz-0Yo49Rto70b2nUwxjPiGD9Ci/view>.
15:37:28 <hekkaidekapus> In short, you might be interested in constraint generation and the solving after that.
15:37:31 <dminuoso> hekkaidekapus: Ah I dived into parts of that video a while ago, sadly it was cut off right in the interesting part I cared about.
15:38:19 <dminuoso> Thanks for the slides, this is really helpful for other reasons already. :)
15:38:22 <hekkaidekapus> hmm… Did not check if the video is whole, but the slides are good.
15:39:06 <hekkaidekapus> Enjoy!
15:39:34 <dminuoso> Ill give the video a look from the beginning
15:41:14 <hekkaidekapus> Yeah, better so rewatch to refresh your mind. There is also commentary pages on the ghc/wiki, there you can dive deeper into specific parts.
15:41:46 <hekkaidekapus> (Which will eventually lead you into Notes.)
16:12:33 <Axman6> newhoggy: "If you haven't seen it, you might enjoy https://liuliu.me/eyes/loading-csv-file-at-the-speed-limit-of-the-nvme-storage/"
16:13:05 <newhoggy> Thanks!
16:31:51 <dminuoso> hekkaidekapus: Alright, the video didn't give me too many insights, and it was rather focused on the implementation of the constraint solver.
16:31:59 <dminuoso> But it was a good refresher nevertheless.
16:34:44 <hekkaidekapus> Right. It’s only a video after all. :)
16:35:10 <hekkaidekapus> dminuoso: Are you familiar with OutsideIn(X)?
16:38:51 <dminuoso> No, but Im looking at the paper right now
16:41:35 <hekkaidekapus> Okay. It is substantial and will be a long step further the Zurihac talk. I am not sure the current implementation is following it closely, still, but the exposition is really thorough.
16:50:14 <Axman6> newhoggy: I'd be interested to hear if you find anything you could use in hw-dsv in there
16:51:42 <newhoggy> Yep.  I had a skim and would like to look into it in more detail later.
16:52:07 <gentauro> .NET also have number separators like -> https://twitter.com/denicmarko/status/1314198060117884928
16:52:16 <gentauro> will it ever come to Haskell for better readability?
16:52:37 <Axman6> GHC already has that
16:53:02 <gentauro> Axman6: `Use NumericUnderscores to allow underscores in integer literals` :o
16:53:05 <gentauro> I didn't knew that
16:53:10 <Axman6> yes
16:53:53 <Axman6> not sure if Ada came up with that, but it's one of the features of Ada I always liked. great for binary literals: 0b1101_0101_1100_1010
16:53:54 <gentauro> I like it !!!
16:54:18 <gentauro> Axman6: `great for binary literals: 0b1101_0101_1100_1010` exactly
16:54:30 <no-n> it's in perl and C# too
16:54:32 <gentauro> but also big numbers: 42_000_000_000
16:54:56 <Axman6> except when you confuse people by doing 42_000_000_0000 =)
16:55:01 <newhoggy> Axman6: One of the design choices I made was to load the CVS via a lazy ByteString.  I suspect there is a performance penalty for doing that and the method is not easily parrallelisable.  There is an option to `mmap` to increase parallelism but in this case there is the down side the process will clock up a lot of memory usage which may not be suitable for some kinds of jobs.
16:55:50 <Axman6> do you know if the chunks of the lazy bytestring are mmapped?
16:55:55 <hekkaidekapus> dminuoso: “We do not discuss overlapping instances, implicit parameters, superclasses, or functional dependencies, although our implementation deals with all of these.” — (Emphasis is mine) Hmm… The paper may not be what you want if the implementation has changed in recent years. I would love to continue the digging, alas bed is calling. See you later.
16:56:13 <gentauro> 01:54 < Axman6> except when you confuse people by doing 42_000_000_0000 =)
16:56:18 <newhoggy> The kinds of jobs I'm thinking of are those that run in typical memory constrained VMs in where virtual memory is usually turned off (like in AWS)
16:56:26 <gentauro> people doing that should loose at least a finger :)
16:56:34 <int-e> Yeah with {-# LANGUAGE BinaryLiterals, NumericUnderscores #-} you can have 0b1000_000 or maybe 0b_1000_0000
16:56:49 <Axman6> sine it is mmapped the memory usage isn't real memory usage right? the OS can page them out if needed since it's loaded read only
16:57:18 <justsomeguy> gentauro: Seems like an easy typo to make. Maybe it should be checked by the compiler.
16:57:43 <newhoggy> Swap gets turned off a lot on AWS because of the higher latency to disk of most machine types.
16:57:44 <int-e> (Hmm, the first one came out short :) )
16:57:50 <Axman6> newhoggy: I would be surprised if you can't mmap a huge file read only even if there isn't enough ram
16:59:07 <newhoggy> I haven't tested it, but you may be right in that an mmapped file will function as expected even if swap is disabled.
17:00:24 <newhoggy> I think the danger is if a page you're not done with gets evicted because you're aggressively pulling in new pages and you are forced to pay to reload it.  On AWS, that's likely to be more expensive.
17:01:12 <newhoggy> The other reason streaming is prefferrably is the CSV files *usually* come from S3 in compressed form rather than from local disk.
17:01:20 <newhoggy> preferrable*
17:01:38 <ski> % 0x10_10.10_10
17:01:38 <yahb> ski: 4112.062744140625
17:01:52 <ski> % 0b10_10.10_10
17:01:52 <yahb> ski: ; <interactive>:151:1: error:; * Could not deduce (Num (b0 -> c)); (maybe you haven't applied a function to enough arguments?); from the context: (Num (b -> c), Num (a -> b)); bound by the inferred type for `it':; forall b c a. (Num (b -> c), Num (a -> b)) => a -> c; at <interactive>:151:1-13; The type variable `b0' is ambiguous; * In the ambig
17:03:53 <Axman6> newhoggy: sure, though my take on this is that if you _do_ have a single strict bytestring, you should be abble to process it efficiently
17:04:00 <newhoggy> Most likely use case is outside the cloud.  Either locally or custom hardware.
17:04:19 <Axman6> I would be interested to see the benchmark comparing both
17:04:43 <newhoggy> Yeah.  `hw-dsv` does have a strict mode which uses `mmap`
17:05:57 <newhoggy> I think it ends up slower in general because it has to build a `cspoppy` index.
17:05:58 <Axman6> great - I couldn't remember from looking at the code yesterday
17:06:47 <newhoggy> I don't have a data parallel version of the index building code :D
17:07:25 <newhoggy> I wonder if that is possible?
17:07:55 <newhoggy> Definitely interested in what the article does.
17:18:11 <sep2> https://dpaste.org/V12z I want to go through entire list and see if they are all proper. On union
17:18:43 <sep2> From what you see here, how can I just get my list?
17:34:17 <lemmih_> sep2: That link is 404.
18:05:57 <Nolrai> So whats the name for Functor like things where you need both `a -> b` and `b -> a` to get `f a -> f b`?
18:06:40 <Nolrai> One second..I need to reboot.
18:11:30 <nolrai> Sorry about that.
18:14:08 <jackdk> nolrai: try the `invariant` package?
18:28:20 <gentauro> justsomeguy: I guess that would be difficult to do
18:28:51 <gentauro> in Axman6 example he uses four digits cos binary while I use three cos of thousand, million, billion, …
18:59:16 <ski> @type dimap  -- nolrai
18:59:18 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
18:59:38 <ski> oh, i suppose that's not quite what you were looking for
19:05:17 <Buntspecht> It's like functor plus cofunctor
19:08:09 <ski> (no such thing as "cofunctor". itym "contravariant functor")
19:09:08 <Buntspecht> Yeah
19:09:34 <dolio> But it's also not a covariant nor contravariant functor.
19:10:42 <dolio> Oh, well, profunctors are, but things that tie together both arguments aren't.
19:12:17 <Buntspecht> Meh, they already left ...
19:16:10 <fresheyeball> hey out there
19:16:19 <fresheyeball> anyone know how to debug hie with vscode?
19:16:28 <fresheyeball> I moved to vscode for hie, and it was working amazing
19:16:33 <fresheyeball> but I still have some issues
19:16:48 <fresheyeball> Failed to parse result of calling cabal
19:16:50 <fresheyeball> Warning: cannot determine version of /run/user/1000/bios-wrapper29062-0 :
19:16:52 <fresheyeball> ""
19:16:54 <fresheyeball> cabal: The program 'ghc' version >=7.0.1 is required but the version of
19:16:56 <fresheyeball> /run/user/1000/bios-wrapper29062-0 could not be determined.
19:16:58 <fresheyeball> this is it right now
19:46:47 <koz_> ski: I think they meant an invariant functor.
20:09:29 <Axman6> gentauro, justsomeguy: IIRC Indian numbers are often divided in a way similar to what I did, I don't remember the details but think it was something like four digits and then the rest are grouped by two digits
20:10:55 <Axman6> looks like it's three, then twos
20:12:12 <Axman6> Crore => 1,00,00,000, Lakh Crore => 10,00,00,00,00,000
20:21:37 * vincenz waves
20:23:42 <Axman6> o/
20:25:45 <jackdk> Is there a library which provides a convenient function of this type: `HashMap k1 (HashMap k2 v) -> HashMap k2 (HashMap k1 v)`? It felt like `distributive`, but that package doesn't seem to do instances for things in `containers` and I may have misunderstood its theory
20:26:32 <ski> yea, i realized, koz_
20:26:44 <vincenz> Hi ski
20:26:51 <ski> hello vincenz
20:27:49 <ski> jackdk : looks like a kind of "transposition". perhaps you can find one that first goes to `HashMap (k1,k2) v' ?
20:34:37 <vincenz> ski been a while
20:36:45 <jackdk> ski: well sure: I can `fmap toList`, then toList, then rebuild the table. But that might not be quite what you're asking?
20:39:16 <Axman6> :t Map.toList . fmap Map.toList
20:39:17 <lambdabot> error:
20:39:17 <lambdabot>     Not in scope: ‘Map.toList’
20:39:17 <lambdabot>     Perhaps you meant one of these:
20:39:22 <Axman6> :t M.toList . fmap M.toList
20:39:25 <lambdabot> M.Map k1 (M.Map k2 a) -> [(k1, [(k2, a)])]
20:41:01 <Axman6> jackdk: this feels like a thing that reflex would have implemented somewhere (with efficient observations n' stuff)
20:41:26 <ski> vincenz : yep
20:43:52 <jackdk> so the reason we can't have Distributive and (and therefore not Representable either) is that you need an isomorphism to `(->) x` for some x. Which we don't have; we have like an isomorphism `HashMap k <-> Compose ((->) k) Maybe` or something
20:50:16 <vincenz> Is there a type for a vector of N values?
20:50:20 <vincenz> Where N is fixed
20:51:55 <jackdk> https://hackage.haskell.org/package/vector-sized
20:51:57 <jackdk> maybe?
20:52:21 <jackdk> the `linear` package also has some short vectors useful for 3D sort of work
20:53:19 <vincenz> I'm trying to define a partial order on a pareto space
20:54:18 <vincenz> Thanks! jackdk, that seems better than the one I was looking ato
20:57:19 <jackdk> I don't know those mathswords but good luck
20:58:13 <Axman6> he's talking about the birds space pirates have
20:59:42 <jackdk> rawk
21:02:31 <jackdk> so there's not a map-specialised transposition function I'm aware of. Has anyone seen one like it for lists? `[(a,[(b,c)])] -> [(b,[(a,c)])]`?
21:11:00 <Axman6> should be pretty simple with a list comprehension
21:15:30 <dibblego> https://github.com/qfpl/separated/blob/master/src/Data/Separated.hs#L902
21:16:12 <Axman6> "[5,'x',6]" I beg your pardon what is this nonsense
21:16:40 <jackdk> I do not understand what I am looking at
21:16:51 <Axman6> :aliens:
21:17:26 <dibblego> actually it's a bit different to what you wrote
21:19:10 <Axman6> :t lef f mmp = fold [ (k2,M.singleton k1 v) | (k1,vs) <- M.toList mmp, (k2,v) <- M.toList vs in f
21:19:11 <lambdabot> error: parse error on input ‘=’
21:19:27 <Axman6> :t let f mmp = fold [ (k2,M.singleton k1 v) | (k1,vs) <- M.toList mmp, (k2,v) <- M.toList vs] in f
21:19:29 <lambdabot> (Monoid a1, Ord k) => M.Map k (M.Map a1 a2) -> (a1, M.Map k a2)
21:19:58 <Axman6> :t let f mmp = M.fromListWith M.union [ (k2,M.singleton k1 v) | (k1,vs) <- M.toList mmp, (k2,v) <- M.toList vs] in f
21:20:01 <lambdabot> (Ord k1, Ord k2) => M.Map k2 (M.Map k1 a) -> M.Map k1 (M.Map k2 a)
21:20:47 <Axman6> technically there's optimisations to be had from the uniqueness of the keys but yolo
21:21:00 <Axman6> jackdk: happy?
21:25:10 <jackdk> axman6: I broke out the monoidal-containers hammer https://www.irccloud.com/pastebin/atKmxOH8/Transpose.hs
21:25:43 <jackdk> I think I like yours better
21:27:22 <Axman6> :t let f mmp = M.fromListWith M.union $ do {  (k1,vs) <- M.toList mmp; (k2,v) <- M.toList vs; pure (k2,M.singleton k1 v) } in f
21:27:23 <lambdabot> (Ord k1, Ord k2) => M.Map k2 (M.Map k1 a) -> M.Map k1 (M.Map k2 a)
21:28:37 <jackdk> yeah I thnk donotation is clearer
21:31:37 <Axman6> @ :t let f mmp = M.fromListWith M.union $ do {  (k1,vs) <- M.toList mmp; (k2,v) <- M.toList vs; [(k2,[(k1, v)])] } in f
21:31:49 <Axman6> % :t let f mmp = M.fromListWith M.union $ do {  (k1,vs) <- M.toList mmp; (k2,v) <- M.toList vs; [(k2,[(k1, v)])] } in f
21:31:49 <yahb> Axman6: ; <interactive>:1:97: error:; * Couldn't match expected type `Map k3 a3' with actual type `[(a2, b1)]'; * In the expression: [(k1, v)]; In the expression: (k2, [(k1, v)]); In a stmt of a 'do' block: [(k2, [(k1, v)])]; * Relevant bindings include; v :: b1 (bound at <interactive>:1:73); vs :: Map k2 b1 (bound at <interactive>:1:48); k1 :: a2 (bound at <interact
21:32:03 <Axman6> % :set -XOverloadedLists
21:32:03 <yahb> Axman6: 
21:32:05 <Axman6> % :t let f mmp = M.fromListWith M.union $ do {  (k1,vs) <- M.toList mmp; (k2,v) <- M.toList vs; [(k2,[(k1, v)])] } in f
21:32:06 <yahb> Axman6: (Ord k1, Ord k2) => Map k2 (Map k1 a) -> Map k1 (Map k2 a)
21:32:11 <Axman6> awww yiss
21:33:10 <vincenz> How do I do something like:
21:33:29 <vincenz> for all n: instance PartialOrd a => PartialOrd (Vector n a)
21:37:09 <Axman6> instance (KnownNat n, PartialOrd a) => PArtialOrd (Vector n a)?
21:37:45 <vincenz> Thanks, I'll try tat!
21:42:05 <vincenz> I'll go without fixed size for now to simplify, then I can always add it later I guess
21:47:18 <vincenz> How do I qualify an operator in binding position?
21:47:31 <vincenz> instnace ... where .... x PartialOrd.<= y = ...
21:50:13 <vincenz> Found it, I import only what I want from prelude and thus mask the <= in prelude
23:23:19 * hackage hurl 1.4.2.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.4.2.0 (alcinnz)
23:58:28 <gentauro> 05:11 < Axman6> Crore => 1,00,00,000, Lakh Crore => 10,00,00,00,00,000
23:58:34 <gentauro> first time I see this :o 
