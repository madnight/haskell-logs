00:04:49 <p0a> Hey all, here's my code, feel free to criticize: https://paste.tomsmeding.com/hu7SEMVu
00:06:19 <p0a> The comment at the beginning of Main.hs explains the purpose of the program. I plan to rewrite it. I want to include proper strings (instead of String), exceptions for file handling, prettier printing and some other functionality to my database (like deleting records), as well as using an actual database instead of relying on the haskell Read
00:07:25 <zeta_0> hello there, has anyone here used the haskell package miso ? my issue has to do with nix configuration.
00:07:47 <p0a> a better "search" function would be nice, the one I currently have is a bit lame. Is there a google-esque String -> String -> Double function available? (Double representing the score of x being searched in y)
00:08:15 <p0a> The only thing I'm aware of is Levenshtein distance which is not exactly what I'm describing but would do
00:12:12 <tomsmeding> p0a ah nice idea
00:14:08 <p0a> yeah :) I think it'd be nice 
00:14:29 <p0a> tomsmeding: btw in my latest paste https://paste.tomsmeding.com/hu7SEMVu there is no colors
00:14:44 <p0a> Did I break it by having lines that are too long?
00:14:56 <taurux> i see colors just fine in your paste
00:14:57 <p0a> oh nevermind I toggled highlighting 
00:15:24 * p0a is in a permanent state of confusion
00:15:39 <ski>   (mapM_ . mapM_) (putStrLn . if optPathOnly opts then path else show) . fmap (queryStrings nonOptions) =<< readDatabase (optDatabase opts)
00:16:01 <p0a> ah thank you ski let me think about that 
00:16:32 <ski> not sure whether you want to elide naming `db', but you can do it
00:16:34 <p0a> kinda intense to be honest
00:16:52 <p0a> Like, it's cool that you can write and understand that 
00:17:02 <p0a> but I think it places an unnecessary barrier to those of us who can't :P 
00:17:16 <p0a> or am I being naive? idk
00:18:59 <p0a> okay so =<< allows us to ignore the do binding, then you fmap over the Maybe, followed by a double mapM_ to get inside Maybe and List
00:19:03 <ski>   (mapM_ . mapM_) (putStrLn . if optPathOnly opts then path else show) (queryStrings nonOptions <$> db)  -- is a version that assumes you keep `db <- readDatabase (optDatabase opts)' on the line above
00:19:34 <p0a> ski: see, what I was trying to do is 'get inside' Maybe only once; but it seems necessary that you do it twice
00:19:37 <ski>   (forM_ (queryStrings nonOptions <$> db) . mapM_) (putStrLn . if optPathOnly opts then path else show)  -- same thing, just putting the action last
00:19:48 <p0a> Once to do the transformation Database -> [String] and once to use mapM_
00:19:56 <p0a> otherwise the types won't match? I think
00:19:58 <taurux> ski: Can't you move the (queryStrings nonOptions) inside the argument of (mapM_ . mapM_)?
00:20:23 <taurux> oh no sorry I didn't think that there are 2 mapM_
00:20:59 <ski> one is for `Maybe', the other is for `[]'
00:21:25 <p0a> I guess mapM_ . mapM_ doesn't have a name, right?
00:21:45 <ski>   (mapM_ . (. queryStrings nonOptions) . mapM_) (putStrLn . if optPathOnly opts then path else show) db
00:21:50 <ski>   (forM_ db . (. queryStrings nonOptions) . mapM_) (putStrLn . if optPathOnly opts then path else show)
00:22:14 <p0a> oh lol
00:22:20 <ski> i considered those, at first, but figured you might be more confused by `foo . (. bar) . baz'
00:22:26 <p0a> now it's getting too tricky ski
00:23:31 <ski> `fmap'ping `queryStrings nonOptions' over `db' before getting into the `mapM_' seemed more clear
00:26:04 <p0a> hahah that code is crazy
00:26:11 <taurux> p0a, you will get used to composing things functions like this
00:26:15 <taurux> :t (.) . (.)
00:26:17 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
00:26:47 <ski>   (. Compose) . mapM_ :: (Foldable t,Foldable u,Monad m) => (a -> m b) -> t (u a) -> m ()
00:26:55 <p0a> Right so (.) . (.) is what in math is composing a scalar function with a R^2 -> R function
00:27:26 <taurux> ski, I think we're just scaring a haskell newcomer
00:27:31 <p0a> e.g. (a, b) -> a + b with doubling the result, so ((.) . (.)) (*2) (\(a, b) -> a + b)
00:27:52 <ski>   mapM_ (putStrLn . if optPathOnly opts then path else show) (Compose (queryStrings nonOptions <$> db))
00:27:58 <p0a> taurux: it's cool I've witnessed horrors before, at least I have a math background
00:28:07 <ski>   forM_ (Compose (queryStrings nonOptions <$> db)) (putStrLn . if optPathOnly opts then path else show)
00:28:25 <p0a> taurux: but I'm warry about using ski's suggestions because from my (small) experience, dummy-code is better than smarty-code
00:28:34 <ski> using `Data.Functor.Compose'
00:29:07 <ski> i'm not saying you should use any of my suggestions :)
00:29:21 <p0a> yeah I get it, you're "composing" right now :P 
00:29:32 <ski> they're more meant as "hm, it is possible to express it like this"
00:29:47 <taurux> p0a, it's a matter of style. I like to use code like ski's (but without that `Compose's, they're too much ahah) because I find it elegant and concise
00:30:09 <ski> it's a matter of balance, as well
00:30:35 <taurux> yes, you could write an entire program without using do-notation, but it would just be crazy
00:30:46 <ski> too much pointless code, and it becomes inscrutable
00:32:56 <ski> i only started playing with this, since you were already pointlessing with `putStrLn . if ...' (and also, i admit, because `\db -> mapM_ (...) $ queryStrings nonOptions db' annoyed me, since it used `$', and seemed to name this `db' unnecessarily)
00:33:04 <ski> you could write
00:33:50 <p0a> ski: I think what I would do to make my code look better is call the first maybeDb and the second would be `db'
00:34:24 <ski>   forM_ db $ \db -> forM_ (queryStrings nonOptions db) $ \f -> putStrLn $
00:34:32 <ski>     if optPathOnly opts
00:34:37 <ski>       then path f
00:34:42 <ski>       else show f
00:34:53 <tomsmeding> p0a: good line numbers are hard though
00:35:14 <ski> (or you could put each `forM_' on a separate line, the second indented more than the first. these are basically nested loops, anyway)
00:35:28 <ski>   forM_ maybeDb $ \db ->
00:35:34 <ski>     forM_ (queryStrings nonOptions db) $ \f -> 
00:35:37 <tomsmeding> someone opens it on mobile where the font sizes are borked and all is unaligned, or someone puts in a character that the standard font doesn't have and the sizes don't match up, or ...
00:35:52 <ski>       putStrLn (if optPathOnly opts
00:36:03 <ski>                   then path f
00:36:08 <ski>                   else show f)
00:36:20 <p0a> tomsmeding: Okay fair enough. I figured out that might be the reason why you don't have that feature 
00:36:42 <ski> p0a : i was thinking that before, yea. but i didn't want to mention it, while we were considering other things
00:37:08 <p0a> Right I think that forM_ approach is nice 
00:37:24 <p0a> ski: how do you keep track of your files in your disk?
00:37:42 <p0a> ski: say if you want to find a pdf file but you dont' remember where you put it. Or does that not happen?
00:37:57 <p0a> (this is unrelated to haskell but it's that my program helps me with)
00:38:07 <ski> sometimes i remember the general area i might've put it in
00:38:28 <ski> sometimes i remember title or authors or so, enough so i can find it again on the net
00:38:42 <p0a> I feel like I'm managing my 6 disk backups, it's a mess
00:39:08 <p0a> I just want to rm -rf it all lol
00:39:34 <taurux> p0a, fdisk is more satisfying
00:39:37 <p0a> I'm trying to write a tool that lets me track my files and eventually I'd like to use it to back up properly (i.e. have all the files move in some proper hierarchy)
00:39:41 <p0a> ahahah taurux 
00:39:54 <taurux> p0a, you could take a look at git-annex. It's written in Haskell!
00:40:09 <taurux> I use it to keep track of my enormous photo library
00:40:46 <p0a> "With git-annex, Bob has a single directory tree that includes all his files,"
00:40:53 <taurux> it can sync between different devices and folders (and also S3 buckets!) and supports tags and revisions
00:41:04 <p0a> Yeah, Bob was careful. p0a wasn't
00:41:48 <taurux> p0a, ahaha I know how much managing files can be boring but it's necessary
00:41:53 <p0a> taurux: can git-annex archive your files even if they're at different places? Or do I need to turn / into a git project?
00:42:25 <ski> (i guess sometimes it feels like i'm wading through drifts of køkkenmøddings of old cruft, making trails after me, through older accumulated trails)
00:42:35 <taurux> p0a, yes, it does
00:42:50 <taurux> It has a quite steep learning curve but it's really powerful
00:43:25 <taurux> It manages different places through different git repositories, but your files don't need to be present in each of the repos
00:43:50 <taurux> it can keep track of files independently from git, git only manages symlinks to the actual files that are managed by git-annex
00:43:54 <p0a> that's awesome, thank you. I guess that's the tool I'm trying to write? 
00:43:59 <p0a> I should just use git-annex instead 
00:44:29 <p0a> you can attach textual descriptions to binary files and search for those, right?
00:45:50 <p0a> well it might be off-topic of this channel. Thank you regardless I'm going to look into it now 
00:47:06 <taurux> p0a, yes, it support tags
00:49:08 <p0a> tags won't do 
00:49:11 <p0a> I need long descriptions 
00:49:29 <p0a> I basically need text files associated to binary files that I can grep 
00:50:34 <taurux> oh I don't know if git-annex supports that. You had better write a tool on your own as you just did probably, or a simple solution with some text files and a shell script
01:05:16 <tomsmeding> p0a: tried to implement line numbers in the stupid way, my suspicion was confirmed: https://tomsmeding.com/ss/get/tomsmeding/GFBLec
01:05:49 <tomsmeding> (note the wrong line height for the high characters in a different font)
01:05:52 <p0a> Yeah I'll try to write my own tool. I haven't been able to find a solution so far plus I will learn quite a few things down the road
01:06:37 <p0a> tomsmeding: utf8 is maddening
01:07:25 <Rembane> p0a: ...in that 1 character /= 1 byte? 
01:07:40 <tomsmeding> well no, utf8 is a nice encoding, fonts are the problem
01:07:46 <p0a> Rembane: I'm mostly talking about alignment issues when drawing them
01:07:54 <p0a> Yeah right, well I wasn't being technical 
01:07:58 <tomsmeding> utf8 /= unicode /= fonts :p
01:08:07 <p0a> That's all true and I'm aware
01:08:07 <Rembane> p0a: Yeah, that's a problem too. :)
01:08:07 <tomsmeding> p0a: you're in #haskell
01:08:19 <p0a> I know lol I just don't like being technical in general 
01:08:57 <p0a> I had a similar issue tomsmeding, alignment of text tables, and I tried to fix it from within bash (it was a disaster)
01:09:08 <tomsmeding> lol
01:09:39 <tomsmeding> like, a potential solution to this is not making two <pre> elements of which you need to match the line heights, but make a huge table with a <tr> for each line
01:09:53 <tomsmeding> but that's, I dunno, awkward
01:09:59 <p0a> delegate it to the browser, right?
01:10:28 <tomsmeding> also means I need to process the output of highlightjs to be a table instead of a <pre> :D
01:10:32 <Rembane> I wonder if brick could help you. I'm not sure though, but curses seem like at least slightly useful here
01:10:58 <p0a> tomsmeding: another approach instead of line numbers would be to allow the user to hightlight some parts of the code in the url
01:11:12 <p0a> tomsmeding: i.e. ?highlight=12,25,34-36
01:11:31 <tomsmeding> ... the canonical way to select which, is having line numbers that you can click on :)
01:11:36 <p0a> which instead of showing line numbers, just uses a yellow background color 
01:12:25 <p0a> Rembane: Yeah I think curses would work, but it's high powered. I was trying to do everything from inside bash scripts
01:15:06 <Rembane> p0a: Got it, making everything from bash scrips seems to me like a good way to make your life extra painful
01:17:47 <tomsmeding> p0a: it's going on my todo list :p
01:37:11 <tomjaguarpaw> If one has a `cabal.project` that doesn't contain a `packages: ...` stanza does that mean that the project implicitly contains no packages?  If `cabal.project` doesn't exist then `packages:` is implicitly `*.cabal` (I believe) but it seems that if `cabal.project` does exist but doesn't contain `packages:` then the set of packages is implicitly empty.
01:43:46 <siraben> What's the question mark do in getSessionInt :: (?requestContext :: RequestContext) => Text -> IO (Maybe Int) ?
01:46:45 <ski> siraben : implicit parameters, <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters>
01:48:18 <p0a> do I put my warning options (like -Wall) under ghc-options in package.yaml using stack?
01:49:47 <sm[m]> Yes, p0a
01:50:54 <p0a> thank you 
01:51:51 <p0a> When reading RIO documentation, I read "A primary design choice you'll need to make in your code is how to structure your monads. "
01:52:22 <p0a> What does that mean? 
01:56:26 <sm[m]> p0a: above a certain size it's common for haskell apps to have custom monad involving several monad transformers (layers). Rio provides a standard one of these for you
01:56:49 <p0a> layers like m1 (m2 (m3 t)) ?
01:57:59 <sm[m]> yes, essentially
01:59:11 <p0a> any good newbie database modules one can take a look at? I was looking at haskelldb. I don't need much functionality
01:59:26 <p0a> I am planning to use RIO, probably doesn't matter but I am mentioning it 
01:59:41 <siraben> ski: thanks
02:00:36 <sm[m]> any of the -simple libs. Next step up would be persistent
02:01:51 <siraben> ski: Hm, implicit parameters reminds me of dynamic scoping
02:02:29 <p0a> thank you. I'm a bit intimidated by all the details
02:03:01 <p0a> data-simple looks nice
02:03:27 <sm[m]> I don't know that one
02:04:13 <p0a> maybe I'll try mysql-simple
02:04:37 <sm[m]> not on hackage which isn't a great sign
02:05:04 <p0a> sm[m]: https://hackage.haskell.org/package/data-basic
02:05:13 <p0a> (I wrote it wrong, sorry)
02:06:58 <sm[m]> It does sound nice. There's also https://hackage.haskell.org/package/sqlite-simple
02:07:18 <chreekat[m]1> sqlite-simple would be be first recommendation. Ah sm just beat me to it
02:07:29 <p0a> Right, actually that looks even better. I do remember that sqlite is better than mysql for simple things
02:07:55 <p0a> I'll try to learn some sql today and design my schema(?) and interface with the database from haskell 
02:10:53 <sm[m]> simplest of all is to writeFile.show and read.readFile
02:11:45 <p0a> sm[m]: That's version alpha which I got down already :)  (https://paste.tomsmeding.com/hu7SEMVu humblebrag)
02:12:00 <p0a> If you'd like, read the top comment, it explains the use
02:14:48 <sm[m]> cool
02:15:24 <tomjaguarpaw> p0a: Definitely don't use HaskellDB. It is utterly obsolete.
02:15:42 <p0a> tomjaguarpaw: got it. I'm going for sqlite-simple, thank you
02:17:48 <tomjaguarpaw> Wise choice.
03:21:17 <Guest_92> im trying to install haskel but am presented with this error. [ Error ] Build failed with NonZeroExit 77 "./configure" ["--prefix=/Users/maz/.ghcup/ghc/8.8.4"]    Check the logs at "/Users/maz/.ghcup/logs" and the build directory "/var/folders/nt/wx7qk_ks7lv4x_102964057w0000gn/T/ghcup-ANoIrO" for more clues.    Make sure to clean up
03:21:18 <Guest_92> "/var/folders/nt/wx7qk_ks7lv4x_102964057w0000gn/T/ghcup-ANoIrO" afterwards."_eghcup --cache install ghc recommended" failed!(base) maz@Mazharuls-Air ~ % 
03:21:29 <Guest_92> can someone help me please 
03:21:53 <maerwald> did you check the logs?
03:22:48 * hackage pontarius-xmpp-extras 0.1.0.5 - XEPs implementation on top of pontarius-xmpp  https://hackage.haskell.org/package/pontarius-xmpp-extras-0.1.0.5 (SergeyAlirzaev)
03:23:02 <Guest_92> how do i do that? 
03:24:37 <maerwald> Guest_92: http://letmegooglethat.com/?q=how+do+I+open+directory+on+mac
03:33:56 <Guest_92> i am still unable to check my logs
03:34:00 <maerwald> why?
03:34:07 <tomjaguarpaw> Guest_92: Perhaps more helpfully, note that that error message tells you 'Check the logs at "/Users/maz/.ghcup/logs" and the build directory "/var/folders/nt/wx7qk_ks7lv4x_102964057w0000gn/T/ghcup-ANoIrO" for more clues.
03:37:39 <Guest_92> i have tried Users/maz/.ghcup/logs"
03:37:50 <Guest_92> but there is nothing there 
03:39:05 <tomjaguarpaw> And how about the build directory?
03:39:51 <Guest_92> how would i go about checking that?
03:40:24 <tomjaguarpaw> Look in that directory and see if there's anything notable in there
03:40:37 <tomjaguarpaw> Are you saying that /Users/maz/.ghcup/logs is empty?
03:40:57 <tomjaguarpaw> Can you run "ls -l /Users/maz/.ghcup/logs" and paste the full output here?
03:42:21 <maerwald> It cannot be true, otherwise ghcup would crash at the start
03:42:51 <Guest_92> -rw-r--r--  1 maz  staff  1248  3 Oct 11:20 ghc-configure.log-rw-r--r--  1 maz  staff   929  3 Oct 11:20 ghcup.log
03:42:55 <maerwald> see
03:43:11 <Guest_92> when i try accessing the logs, it says that access is denied 
03:52:27 <tomjaguarpaw> OK, so there is something there
03:52:51 <tomjaguarpaw> What happens when you try "less /Users/maz/.ghcup/logs/ghc-configure.log"
03:56:48 <Guest_92> Target platform inferred as: x86_64-apple-darwinGHC build  : x86_64-apple-darwinGHC host   : x86_64-apple-darwinGHC target : x86_64-apple-darwinLLVM target: x86_64-apple-darwinchecking for path to top of build tree... /private/var/folders/nt/wx7qk_ks7lv4x_102964057w0000gn/T/ghcup-ANoIrO/ghc-8.8.4checking for perl... /usr/bin/perlchecking for a
03:56:49 <Guest_92> BSD-compatible install... /usr/bin/install -cchecking for gfind... nochecking for find... /usr/bin/findchecking whether ln -s works... yeschecking for gsed... sedchecking XCode version... xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instancenot
03:56:49 <Guest_92> found (too old?)checking for gcc... gccchecking whether the C compiler works... noconfigure: error: in `/private/var/folders/nt/wx7qk_ks7lv4x_102964057w0000gn/T/ghcup-ANoIrO/ghc-8.8.4':configure: error: C compiler cannot create executablesSee `config.log' for more details
03:57:50 <tomjaguarpaw> Looks like something is wrong with your gcc. I wouldn't know how to fix that, especially on a Mac. Maybe someone else here will.
03:58:41 <tomjaguarpaw> I suppose you could try "less /private/var/folders/nt/wx7qk_ks7lv4x_102964057w0000gn/T/ghcup-ANoIrO/ghc-8.8.4/config.log"
03:58:46 <tomjaguarpaw> Maybe that has the answers
04:00:28 <maerwald> you need gcc, your xcode is broken
04:02:58 <maerwald> http://letmegooglethat.com/?q=how+to+install+gcc+on+mac
04:24:26 <kuribas> Is there a way to force HLS to always you cabal new-style?
04:24:36 <kuribas> it's picking stack now...
04:36:41 <kuribas> putting cabal: -path "./grin/" - component: "grin:lib" in hie.yaml doesn't help either
04:58:32 <fluturel> any ideas on why this isn't working? 'either length (*2) (someFunc 4 6)' where someFunc is of type someFunc :: (Fractional a, Eq a) => a -> a -> Either String a
04:59:53 <fluturel> It gives me the error No instance for (Fractional Int) arising from a use of 'someFunc'
05:01:09 <tomjaguarpaw> The return value of the either call must be the same as the return value of 'length', i.e. Int
05:01:37 <tomjaguarpaw> either (fromIntegral . length) (*2) (someFunc 4 6)
05:01:45 <tomjaguarpaw> fluturel: ^^ perhaps you want that
05:03:30 <fluturel> tomjaguarpaw: that's exactly what i was looking for, thank you
05:03:39 <tomjaguarpaw> You're welcome!
05:03:45 <fluturel> Forgot length returns Int, not something of Num
05:04:08 <tomjaguarpaw> Yeah, that can be annoying
05:04:39 <kuribas> it says no cabal found, but there is a cabal in grin/grin.cabal
05:05:04 <tomjaguarpaw> Does it mean no /executable/ called cabal found?
05:05:51 <kuribas> no it says the glob *.cabal
05:06:22 <kuribas> it says create a package .cabal or cabal.project
05:07:51 <tomjaguarpaw> Does it expect to be run from the directory where the cabal file is found?
05:07:57 <tomjaguarpaw> i.e. do you need to be in the grin/ directory?
05:10:20 <kuribas> tomjaguarpaw: it's trying to run stack
05:10:32 <kuribas> I want it to run cabal
05:10:49 <kuribas> if it can run stack from this directory, it should run cabal as well from this directory.
05:12:30 <tomjaguarpaw> Yes, one would hope that would be possible. I'm just making a suggestion that could be used to futher analyse the situation.
05:12:56 <kuribas> these tools are pretty fiddly
05:14:32 <fendor> text has no pattern synonyms to access it first characters?
05:15:37 <kuribas> tomjaguarpaw: there's a stack.yaml, maybe that's why it works?
05:16:25 <tomjaguarpaw> kuribas: possibly. What happens if you delete the stack.yaml?
05:26:59 <kuribas> tomjaguarpaw: running it in the ./grin directory doesn't even do anything
05:27:43 <kuribas> these tools suck so badly
05:28:02 <tomjaguarpaw> Yup, the command line and ambient Unix system makes a very poor interface
05:29:43 <kuribas> tomjaguarpaw: I am running it from vscode
05:30:14 <tomjaguarpaw> Sure, but hls itself has the whole Unix system to contend with.
05:30:33 <kuribas> what does haskell project management have to do with unix?
05:31:18 <tomjaguarpaw> It is ill-defined what actually constitutes a Haskell source tree. There is an informal idea that it as a hierarchy of directories with .hs files in appropriate places and some .cabal files and maybe a cabal.project file in the correct place.
05:31:32 <tomjaguarpaw> Not "free of place and time", as Rich Hickey would put it
05:33:49 <kuribas> that's not UNIX fault, but the haskell project structure.
05:34:06 <kuribas> it's overcomplicated
05:34:10 <tomjaguarpaw> I never said it was Unix's fault.
05:34:45 <tomjaguarpaw> It's very much the fault of all these tools for not starting by precisely defining the interface to the ambient system.
05:34:59 <kuribas> indeed
05:35:13 <tomjaguarpaw> Or rather, by precisely defining which parts of the ambient system they will use in their interface
05:35:43 <tomjaguarpaw> What does it mean if a file exists but is not readable?  Who knows?  What does it mean if a .cabal file is a symlink?  Who knows?  It's all just "defined" by the implementation.
05:35:55 <kuribas> IMO also the problem is how bad these tools report errors.
05:35:58 <tomjaguarpaw> What does it mean if a file vanishes half way through compilation?  Who knows?
05:36:11 <tomjaguarpaw> Yes, the error reporting is often abysmal.
05:36:45 <tomjaguarpaw> Rather than saying "no cabal file found" it should say "I looked in all these places but didn't find a cabal file: ..."
05:36:54 <tomjaguarpaw> Then you can start to get a clue about how to fix it.
05:36:58 <kuribas> indeed
05:38:26 <maerwald> fendor: make one :)
05:38:44 <fendor> maerwald, fair enough, good idea, thanks!
05:39:14 <tomjaguarpaw> Or just use a function!  unconsText :: Text -> Maybe (Char, Text).  No need to go outside of Haskell98!
05:39:24 <maerwald> the syntax for pattern synonyms is confusing imo
05:39:32 <maerwald> I can never memorize it
05:39:52 <maerwald> tomjaguarpaw: a function is not a pattern synonym
05:40:22 <tomjaguarpaw> Indeed. I think I'm missing the point of the need for such a synonym.
05:40:34 <maerwald> you mean the need for pattern matching?
05:41:05 <tomjaguarpaw> No, for the synonym.  If you define functions (simple Haskell, boring Haskell) `unconsText` and `consText` why do you need the synonym?
05:41:27 <maerwald> Why do you need pattern matching at all when you can have functions?
05:41:59 <tomjaguarpaw> There's no way of matching on user-defined sum types without pattern matching!
05:42:19 <maerwald> the compiler could emit functions instead
05:42:28 <tomjaguarpaw> Sure, but it doesn't.
05:42:35 <maerwald> why?
05:43:26 <tomjaguarpaw> Well, you need some primitive form of pattern matching, else how are you going to deconstruct the result of the function?
05:43:43 <tomjaguarpaw> But given that Maybe and (,) already exist, `unConsText :: Text -> Maybe (Char, Text)` seems fine to me
05:44:33 <maerwald> no, the answer is: because it's convenient
05:44:36 <maerwald> you don't need it at all
05:46:14 <tomjaguarpaw> OK, thanks for the answer. Nonetheless I don't see that "case myText of { ConsText c rest -> ...; NilText -> ... }" is more convenient than "case unconsText myText of { Just (c, rest) -> ... ; Nothing -> ... }", and the latter is far less confusing.  PatternSynonyms are not standard Haskell after all.
05:46:47 <maerwald> I usually avoid arguing about other ppls style and assume they know what they are doing :)
05:47:14 <tomjaguarpaw> A reasonable policy.
05:47:23 <maerwald> Additionally, pattern synonyms allow the COMPLETE pragma, which you don't have with functions.
05:48:38 <kuribas> https://gist.github.com/kuribas/0a828d64c9d2564d8045289dca0ae515
05:48:42 <kuribas> tomjaguarpaw: ^
05:49:01 <kuribas> what's this /grin/a ?
05:49:44 <kuribas> I added the hie.yaml file
05:49:51 <tomjaguarpaw> maerwald: I am making a suggestion that applies to the case of fendor, not a suggestion to avoid pattern synonyms under all circumstances.
05:50:15 <maerwald> tomjaguarpaw: I think he knows that there is a function :p
05:51:00 <kuribas> tomjaguarpaw: this is what I mean with the tools suck.  I just hope that it will improve in the near future.
05:51:37 <kuribas> tomjaguarpaw: I'll just go back to emacs and recursive grep
05:51:54 <tomjaguarpaw> maerwald: That seems to be a vital piece of context I was missing.
05:52:27 <maerwald> kuribas: I did that too, until I started working on a project where it's policy to put "::" after a newline, so it broke my grepping for function definitions
05:53:04 <kuribas> maerwald: grep-fu is a complicated skill :)
05:53:09 <maerwald> I started to use codex with hasktags again, but it was broken
05:53:22 <fendor> Well, I liked to have something like: (x:'+':y:r) for text. In this case, I like it more than the nested case statement
05:53:22 <maerwald> kuribas: it isn't, just a waste of time
05:53:33 <tomjaguarpaw> kuribas: './*.cabal' really does look like it's looking just in the directory it's run from.
05:54:00 <tomjaguarpaw> fendor: Aha! Nested patterns.  A good counterargument.
05:54:54 <maerwald> and codex has this issue of picking stack automagically too, lol
05:55:10 <maerwald> so if you have a hybrid project, it's gonna be annoying
05:57:08 <kuribas> maerwald: better than nothing
05:57:39 <maerwald> I just use ag
05:57:53 <kuribas> speed isn't critical
05:58:09 <maerwald> speed is everything
05:58:11 <kuribas> tomjaguarpaw: I followed the documentation for hie.yaml
05:59:05 <tomjaguarpaw> I think HLS maintainers will be responsive if you file a GitHub issue with a minimal reproducer
06:01:35 <kuribas> does anyone have experience with other typed functional languages?
06:01:44 <kuribas> in a production setting.
06:01:44 <fendor> kuribas, elm? :D 
06:01:55 <kuribas> I really cannot recommend haskell for my team.
06:02:19 <kuribas> or perhaps I need to stick to stack?
06:02:48 * hackage linear 1.21.3 - Linear Algebra  https://hackage.haskell.org/package/linear-1.21.3 (ryanglscott)
06:03:00 <maerwald> kuribas: TypeScript
06:03:19 <kuribas> maerwald: for backend stuff
06:03:25 <maerwald> oh
06:03:52 <maerwald> I would say clojure, but I urge you to stay away from it as far as possible
06:03:59 <maerwald> don't even touch it with a stick
06:04:09 <kuribas> maerwald: we're already using clojure :)
06:04:16 <maerwald> oh god, I'm sorry
06:04:26 <maerwald> hope you get paid well
06:04:26 <kuribas> maerwald: I want to propose something more robust
06:04:48 <aldum> what is Rich Hickey's problem with types, I don't get it
06:05:20 <tomjaguarpaw> kuribas: Would you mind filling in a ticket for me explaining the reasons for not being able to recommend Haskell for your team?  I am trying to understand better the sources of friction in the Haskell ecosystem.  https://github.com/tomjaguarpaw/tilapia/issues/new
06:05:30 <maerwald> kuribas: I haven't tried Ocaml, but people use it and it has some large company backers
06:05:43 <maerwald> I'm confident it can't be worse than clojure
06:05:46 <maerwald> because nothing can
06:05:53 <kuribas> tomjaguarpaw: I just need something that work.
06:06:06 <tomjaguarpaw> Yeah, it's the definition of "work" that I'm trying to understand.
06:06:22 <kuribas> tomjaguarpaw: I mean good tooling.  I know my colleagues don't want to use emacs.
06:06:49 <kuribas> maerwald: sure, php, javascript
06:07:17 <maerwald> kuribas: php isn't really a language :p there must be some other definition for it
06:08:16 <tomjaguarpaw> kuribas: "Tooling" meaning what? Editor integrations?
06:08:20 <kuribas> tomjaguarpaw: yes
06:08:58 <maerwald> There's a bigger problem than tooling: GHC doesn't scale. Because compilation is both slow and memory intensive. Tooling suffers from that too
06:09:11 <tomjaguarpaw> I think HLS is the best Haskell has to offer at the moment.  But I really do think that the HLS team will fix this issue for you if you report it.
06:09:22 <maerwald> If you have a 300 module monolith, running plain ghci becomes a challenge
06:09:39 <maerwald> (and anything else, including hls/intero/etc OOMs)
06:09:54 <kuribas> tomjaguarpaw: this isn't the first problem, there also was a problem when launching HLS in a workspace.
06:10:29 <kuribas> tomjaguarpaw: alright, I'll report the issues...
06:10:31 <tomjaguarpaw> Sure, there are loads of problems. I'm just saying that I'm pretty sure they will get fixed if you report them.  HLS is being used extensively, especially by the people who maintain it!
06:10:57 <maerwald> When I worked on a pretty large Go backend system... it was actually a bliss to iterate code-wise, because compilation is cached and fast
06:10:58 <kuribas> tomjaguarpaw: at least if I can get something somewhat stable before I present it to the team.
06:11:23 <kuribas> maerwald: yeah, because the language is so primitive.
06:11:30 <maerwald> kuribas: true
06:17:49 * hackage aeson 1.5.4.1 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.5.4.1 (AdamBergmark)
06:22:18 * hackage text-show 3.9 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.9 (ryanglscott)
06:26:48 * hackage qhs 0.3.3 - Command line tool qhs, SQL queries on CSV and TSV files.  https://hackage.haskell.org/package/qhs-0.3.3 (itchyny)
06:27:54 <Cheery> I installed haskell language server
06:28:12 <Cheery> it's telling me ghcide compiled against GHC 8.8.4, but currently using 8.0.2
06:28:23 <Cheery> I decided.. ok. Lets go to 8.8.4 but how?
06:30:29 <tomjaguarpaw> Cheery: Are you asking how you can get GHC 8.8.4?  If so, try https://www.haskell.org/ghcup/ (and when ghcup is installed, run `ghcup install ghc 8.8.4`)
06:30:59 <maerwald> if it's a stack project, bump lts to 16.16
06:35:14 <Cheery> ok.. it seem to be going to 8.8.4 now.
06:35:52 <Cheery> haha. hasking whether I want to install haskell language server
06:38:00 <maerwald> Cheery: it's a good idea
06:38:13 <maerwald> because it's managed properly and will tell you if there are updates
06:56:41 <ski> siraben : they are a form of dynamic scoping, i'd say
07:09:38 <p0a> maerwald: about the 300 module monolith, isn't a 'solution' to get faster hardware?
07:10:13 <maerwald> p0a: no, because GHC isn't good at compiling in parallel :)
07:10:27 <maerwald> and if you do, you need 64GB of ram
07:10:37 <p0a> If you do what?
07:10:40 <maerwald> (and that's what our amazon instance was, which is quite expensive)
07:11:04 <maerwald> if you do compile modules in parallel
07:12:08 <p0a> It's surprising to me that ghc doesn't scale with cores
07:12:21 <yushyin> yeah, I often do -j1 or -j2 otherwise my 8GB notebook would go OOM while compiling haskell stuff :/
07:12:23 <kuribas> ghc is quite imperatively written
07:12:27 <kuribas> AFAIK
07:12:52 <p0a> 64GB isn't that expensive for a personal build right? we're talking servers -- that's what's expensive
07:13:07 <maerwald> you need to build on servers too, yeah :)
07:13:29 <kuribas> maerwald: can't you modularize your code more?
07:13:34 <maerwald> slow CI iterations decrease productivity
07:13:37 <kuribas> 64GB seems excessive
07:13:59 <kuribas> maerwald: does it takes hours to compile?
07:14:15 <kuribas> I find 5 or 10 minutes still acceptable for a CI build
07:14:34 <maerwald> kuribas: CI was 30 minutes minimum
07:14:57 <dminuoso> For what its worth, with -O0 you can usually get much better memory and CPU usage.
07:15:03 <maerwald> currently, they are 1h+
07:15:15 <dminuoso> For develop iterations, -O0 should be fine for many cases
07:15:43 <dminuoso> Even in CI you could do that, as long as you switch to the desired optimization level for actual releases.
07:15:47 <maerwald> dminuoso:  then spinning up the event sourced backend would take 2 hours xD
07:17:21 <p0a> 2 hours means that with 256GB of ram it'd be just 30 minutes maerwald 
07:17:25 <p0a> see? it's fine
07:17:48 * hackage derive-lifted-instances 0.2.1 - Derive class instances though various kinds of lifting  https://hackage.haskell.org/package/derive-lifted-instances-0.2.1 (SjoerdVisscher)
07:18:22 <kuribas> maerwald: what do you do that's so heavy?  Lots of generics?
07:18:49 * hackage text-show-instances 3.8.4 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.8.4 (ryanglscott)
07:19:15 <maerwald> kuribas: TH, generics, aeson, aeson-typescript
07:19:56 <kuribas> maerwald: you could try replace some of the generics with TH, that may decrease compile times.
07:20:25 <maerwald> I don't think that buys much. The problem is rather that it's 300 modules
07:20:27 <kuribas> maerwald: for example Aeson deriving.
07:20:33 <maerwald> and I don't work on that project anymore
07:20:52 <kuribas> maerwald: do you need to compile everything from scratch everytime?
07:20:57 <p0a> 300 modules means what exactly? 300 invocations of ghc?
07:21:00 <maerwald> nope
07:25:18 * hackage exp-pairs 0.2.1.0 - Linear programming over exponent pairs  https://hackage.haskell.org/package/exp-pairs-0.2.1.0 (Bodigrim)
08:05:49 * hackage atomic-primops 0.8.4 - A safe approach to CAS and other atomic ops in Haskell.  https://hackage.haskell.org/package/atomic-primops-0.8.4 (ryanglscott)
08:19:49 * hackage derive-lifted-instances 0.2.2 - Derive class instances though various kinds of lifting  https://hackage.haskell.org/package/derive-lifted-instances-0.2.2 (SjoerdVisscher)
08:25:48 * hackage termonad 4.0.1.0 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-4.0.1.0 (cdepillabout)
09:19:18 * hackage rattletrap 9.2.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.2.0 (fozworth)
09:46:25 <dsal> I spin up a sufficiently large aws instance to do my builds.  At least, initial builds. cachix is taking care of the deps.
09:47:13 <maerwald> caching isn't the problem
09:47:16 <tomjaguarpaw> dsal: That's very cool. Do you have a script or write up you've published about how you do that?
09:47:27 <maerwald> we used cabal-cache and it works fine too
09:52:27 <maerwald> but that's not what "scales well" means :)
09:54:36 <dsal> tomjaguarpaw: I have a small note about how to launch the instance again.  All I did was built out an aws instance on nixos, and then use cachix.
10:14:39 <kw> How do I tell GHC that a typeclass-based pair of patterns is complete?
10:15:20 <kw> I keep getting parse errors on the `{-# COMPLETE ... #-}` prgagma when I add signatures.
10:18:22 <kw> E.g. I get a parse error on `{-# COMPLETE Empty :: (HasTail m)=> m a, (:<:) :: (Consable m, HasTail m)=> a -> m a -> m a #-}`
10:18:52 <kw> But on `{-# COMPLETE Empty, (:<:) #-}` GHC tells me that I need to add signatures.
10:23:36 <tomjaguarpaw> Does anyone know how to increase the stored history length in GHCi?
10:25:55 <geekosaur> https://github.com/judah/haskeline/wiki/UserPreferences
10:27:08 <geekosaur> unfortunately, this seems to apply to anything that uses haskeline. fortunately, to date there's not a lot beyond ghci that uses it
10:31:43 <tomjaguarpaw> geekosaur: Thanks
10:33:38 <shaman_king> hi
10:33:46 <shaman_king> i hot a huge fart coming in
10:33:58 <shaman_king> a massive one as wel
10:35:59 --- mode: ChanServ set +q *!*@185.65.134.170
10:43:38 <tomsmeding> thanks for telling us
10:46:49 <koz_> When ghcup labels something as 'stray', what does it mean?
10:47:50 <maerwald> koz_: you won't be able to install it after you remove it, because the version has been removed from ghcup
10:48:00 <koz_> maerwald: Ah, I see.
10:48:32 <koz_> I ask because I have 9.0.1-alpha1 seemingly installed.
10:48:53 <koz_> But the prerelease is 9.0.0.20200925 according to ghcup.
10:49:31 <maerwald> yes, pls revome that version
10:49:34 <maerwald> and install the other
10:49:49 <maerwald> https://gitlab.haskell.org/haskell/ghcup-hs/-/issues/73
10:52:35 <koz_> maerwald: Thanks - doing now.
11:17:17 <dsal> My AWS instance only has 2GB of RAM, but every haskell program I'm running uses a TB of it.
11:18:47 --- mode: ChanServ set -q *!*@185.65.134.170
11:20:51 <Rembane> dsal: No, it reserves 1TB, it doesn't actually use it. 
11:21:04 <dsal> I know.  It just looks really funny on this 2GB machine.
11:22:15 <dsal> https://usercontent.irccloud-cdn.com/file/KUhHDqj8/memories
11:22:30 <Rembane> dsal: Yeah, it's amazing. :)
11:52:13 <ciupakabra> hello
11:53:04 <ciupakabra> I've heard this is a friendly channel, was wondering why I wasn't able to text in #xmonad? I had identified with Freenode
11:54:15 <dsal> What happens when you try?
11:54:47 <ciupakabra> I join successfully, but it says #xmonad Cannot send to nick/channel
11:55:04 <ciupakabra> I can see your message
11:57:11 <ciupakabra> dsal - any idea?:)
11:58:51 <sm[m]> Sure you identified successfully ?
11:59:17 <ciupakabra> got this from the bot NickServ(NickServ@services.)- You are now identified for ciupakabra.
11:59:45 <dsal> no weird modes or anything.  Were you quieted there?
12:00:02 <ciupakabra> I registered just today
12:01:10 <ciupakabra> is it possible to check if I'm quieted there?
12:05:15 <geekosaur> you don't appear to be
12:06:27 <ciupakabra> Also, I haven't set up IRC that well, and don't know much about how connecting to servers works. I just did /connect Freenode /nick ciupakabra /msg Freenode identify pw and /join #xmonad
12:06:34 <ciupakabra> so maybe the way I identify is wrong
12:09:30 <ciupakabra> */msg NickServ identify pw
12:16:10 <ixlun> Hi all, I'm trying to do a fold with a cutoff.. i.e. at some point during the computation of the fold, an intermediate value should be retunrned, even though the entire input list may not have been traversed.
12:16:35 <ixlun> I'm currently trying: `head . takeWhile cutoff . scanr'
12:17:14 <dsal> :t scanr
12:17:16 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
12:17:37 <ixlun> I'm not sure if that's doing as I expect...  if I traceShowId on the value returned by cutoff, it appears to only be evaluated once
12:18:19 <dsal> I'm a bit confused as to what you're doing.  Can you just use foldr?
12:18:44 <ixlun> I can kind of see why it's doing that since I'm calliing `head', but that's only to get the value where the the cutoff predicate became true.
12:19:18 <geekosaur> it's lazy so the scan would end when you stop consuming values
12:19:20 <dsal> If you move that predicate into the argument to foldr, I would expect it to do the right thing.
12:21:26 <dsal> Does that function differently from `f i . head` ?
12:21:31 * dsal needs to have lunch
12:21:35 <ixlun> Say I have the list: [a,b,c,d] and I also have a predicate function `cutoff :: x -> Bool'.  Part way through the list that preciate could become true, so I want to stop the fold at that point and return the value
12:22:11 <dsal> Is the predicate on the input or the output?  If it's the output, then it doesn't seem to do anything at all.
12:22:34 <ixlun> The predicate is on the output
12:23:14 <dsal> But if you're asking for head, so it's a partial function that either returns the first output, or there's no output.
12:24:20 <ixlun> Yeah, that's not what I want I guess
12:25:58 <ixlun> As an example, suppose I predicate: `x > 10' and then I have: `foldl (+) 0 [2,3,4,5]' I'd want the return value to be: 9
12:26:21 <ixlun> is there such a thing?
12:28:33 <ahf> jag
12:30:12 <ixlun> I suppose what I'm after is a terminating fold
12:30:25 <dsal> Well, foldr terminates.
12:30:37 <dsal> But it's a bit hard in this exact situation.
12:32:09 <dsal> foldr will stop if you don't look at the output, but your condition depends on that here.
12:34:23 <dsal> > last . takeWhile (<10) . scanl (+) 0 $ [2..] -- this is pretty close to what you described.
12:34:26 <lambdabot>  9
12:35:48 <Zetagon> wait I'm new here, but does lambdabot evaluate all haskell code? or just pure?
12:36:13 <Rembane> > putStrLn "Maybe?"
12:36:14 <dsal> It's sandboxed.  yahb is less restricted.
12:36:16 <lambdabot>  <IO ()>
12:36:23 <dsal> % putStrLn "hi"
12:36:23 <yahb> dsal: hi
12:36:50 <ixlun> dsal: Ahhh I get it, last and scanl will cause the evaluation to happen
12:37:11 <dsal> That's kind of a weird way to think about it.
12:37:39 <dsal> You're not worried about "causing evaluation" because there's no difference between something that didn't happen and something that wasn't observed.
12:38:06 <dsal> last is just the thing you were asking for -- it's the boundary value in the produced list, as opposed to head, which is always the same.
12:38:44 <ciupakabra5> mm
12:39:19 <ciupakabra5> darn this is weird, so I've connected to Freenode through their website, and it lets me write in #haskell but not in #xmonad
12:39:31 <Xnuk> % readFile "."
12:39:31 <yahb> Xnuk: *** Exception: .: openFile: inappropriate type (is a directory)
12:40:41 <Xnuk> % readFile "/etc/hostname"
12:40:41 <yahb> Xnuk: *** Exception: /etc/hostname: openFile: does not exist (No such file or directory)
13:11:17 <koz_> MaybeT IO Database
13:13:18 <MarcelineVQ> chad EitherT () IO Database vs simp MaybeT IO Database
13:13:46 <koz_> MarcelineVQ: ReaderT DatabaseStatus IO Database, for the FP Completionists.
13:13:59 <MarcelineVQ> fp completionists use RIO
13:14:09 <koz_> MarcelineVQ: My bad, lol.
13:14:22 <koz_> I clearly don't know enough about that world.
13:21:14 <koz_> Also, shouldn't that be ExceptT () IO Database?
13:21:40 <Super_Feeling> new to haskell. what to do lol
13:21:41 <ddellacosta> I thought FP completionist was some extremist camp of statically-typed FP programmers until I realized you were talking about the company
13:21:56 <koz_> ddellacosta: Yeah, I guess I was a bit vague.
13:21:56 <ddellacosta> Super_Feeling: what kind of help are you looking for?
13:22:02 <dsal> Super_Feeling: learn it and then write all the code.
13:22:06 <ddellacosta> koz_: it gave me a chuckle
13:22:12 <koz_> ddellacosta: Happy to help!
13:23:17 <Super_Feeling> i have no fp experience. I did some elixir, but haskell has some good type checking i reckon
13:23:37 <koz_> Super_Feeling: It'd help us help you if you told us what your goals are.
13:23:41 <ddellacosta> Super_Feeling: have you gone through any learning materials? Are you looking for learning materials?
13:23:46 <ddellacosta> ^ what koz_ said
13:23:48 <koz_> Are you looking to write a killer webapp? A compiler? Some other thing?
13:24:03 <koz_> Or are you looking to learn how to set up a Haskell environment? How to use some library? Some other thing?
13:24:22 <koz_> "I need All Of The Help" is a good way to attract attention, but not really constructive responses.
13:25:19 <dsal> I'm trying to get tests running with haskell.nix.  I'm not sure anybody knows how to actually use this thing.  heh
13:25:34 <Super_Feeling> haha I agree. I need something that can convince me on haskell, I've watched a bunch of youtube videos on FP and haskell but I want to know what exactly makes haskell so special, I know the features it offers but there's a philosophy around it and I don't understand it
13:25:57 <koz_> I would say this is not a fruitful or useful line of inquiry.
13:26:02 <dsal> There are a lot of things that can't be understood without experience.
13:26:03 <koz_> We program to solve a problem or do a task.
13:26:11 <koz_> What is _your_ problem or task?
13:26:16 <ddellacosta> dsal: is that tweag's next-gen how-to-approach-haskell-in-nix thing?
13:26:21 <koz_> Given this, we can give some pros (and cons) of Haskell.
13:26:34 <koz_> In a vacuum, that discussion is fairly hard to ground in anything reasonable IMHO.
13:26:49 <ddellacosta> Super_Feeling: yeah the big catch-22 with Haskell IMHO is that you really have to spend some time with it to appreciate what it provides, and how it's distinct from other languages
13:26:57 <dsal> ddellacosta: I'm not actually sure who did it.  It's really easy to get building in nix, but it builds all software by default.  I *can* build the test suite and run it manually, but I feel like something's missing.
13:27:08 <Super_Feeling> Okay, just for the sake of it. Let's pick up a killer webapp
13:27:35 <ddellacosta> dsal: gotcha. Yeah I've only done ad-hoc nix stuff with Haskell, above and beyond Gabriel Gonzalez's nix stuff
13:28:15 <koz_> Super_Feeling: If you wanna build a killer web app, I would argue Haskell gives you a _lot_ of tools to make this much more reasonable.
13:28:28 <dsal> ddellacosta: I'm trying to figure out a good approach.  I mostly use nixos because it's the best linux distribution for my needs.  I'm hoping I find the magic that makes me like, not rebuild ghc and stuff.
13:28:34 <Super_Feeling> yeah i saw ihp, was pretty sweet and comparable to rails/dj.
13:29:04 <koz_> I'm not really a web person (others in this channel are way more qualified than me to describe these advantages to you), but I _have_ tried writing some web stuff in Haskell for my Real Job.
13:29:18 <koz_> I am _purposefully_ ignorant about the toxic hell that is web.
13:29:36 <koz_> I managed, with my Haskell knowledge, to write something inside of a day, that actually worked and wasn't absurdist.
13:29:37 <ddellacosta> dsal: I've been wanting to check out bazel after reading this, sounds like it provides very nice behavior even in a nix context, as long as you're willing to slog through the configuration: https://blog.sumtypeofway.com/posts/bazel-haskell-build-system-joy.html
13:29:43 <Super_Feeling> haha, even I'm tired of it but that's the area of my expertise lol
13:30:02 <koz_> It's an anecdote, and possibly a vague one, but I _very_ much doubt that I could have done that in anything else and ended up with anything halfway sensible.
13:30:11 <koz_> Largely, it was thanks to Haskell hand-holding me.
13:30:37 <Super_Feeling> Let me take on an experiment and write an interpreter, maybe I'll learn a few new things
13:31:28 <dsal> ddellacosta: I use a similar system at work.  It's not exactly the build system I'm looking for, but trying to find that place where all the amazing development stuff people say about nix clicks.  So far, it's great for user/system, but the development stuff is not amazing.  I'm convinced it's because I don't know how to use things, though things are kind of poorly documented.
13:32:04 <ddellacosta> dsal: ah I see, yeah I think I got focused on your comment about not re-building GHC
13:32:07 <dsal> Super_Feeling: writing parsers and evaluating languages in Haskell is entirely too easy.
13:32:22 <dsal> ddellacosta: Yeah, the effort of getting starting with haskell.nix is nearly zero.  But each build takes hours.  :)
13:32:30 <dsal> (well, each time *something* changes)
13:32:37 <ddellacosta> what I've found nix really does that I appreciate in terms of spinning up build environments is just being able to configure my Haskell project and the associated dependencies with relative ease
13:32:52 <ddellacosta> dsal: okay that in particular it sounds like bazel helps with at least
13:33:28 <dsal> cachix allegedly helps.  I just keep managing to have cache misses.
13:33:36 <ddellacosta> ah
13:33:38 <Super_Feeling> not for me, i've never written a parser
13:34:15 <ddellacosta> Super_Feeling: I don't know exactly where you're at in your Haskell journey but I'm fond of this tutorial, and I recommend megaparsec to folks: https://markkarpov.com/tutorial/megaparsec.html
13:34:18 <dsal> Super_Feeling: Writing parsers is unfortunate pain in most languages.
13:34:35 <ddellacosta> gives a good overview of the landscape too
13:34:42 <Zetagon> Super_Feeling: https://www.seas.upenn.edu/~cis194/spring13/lectures.html this is a great intro to haskell and concludes in writing a parser
13:35:07 <ddellacosta> oh yeah that's good stuff too
13:35:24 <Super_Feeling> sounds good. I never expected this irc to be so receptive. thanks guys.
13:35:43 <ddellacosta> the link I gave is going to be more useful if you're already somewhat comfortable in Haskell, whereas I'd recommend Zetagon's link if you are starting more "from scratch"
13:35:46 <ddellacosta> good luck!
13:37:36 <dsal> ugh, this demo project about how awesome nix is for haskell has a cabal file, four .nix files, a Makefile, and possibly more stuff.  The thing I like about stack is that I almost never edit anything but my source.  I guess these tools are better for people who work on few projects.
13:39:14 <dsal> My github CI stuff broke, so I'm trying a different recipe I found somewhere and it's been running for an hour and a half now (building ghc)
13:39:57 <ddellacosta> yikes that sucks
13:43:13 <dsal> I got it all figured out and threw it into a bunch of projects, and then one day they all started failing.   It looks like it's jle's setup-stack thing which both doesn't work and is no longer needed.  Guess I edit all the yamls. h eh
13:46:41 <ddellacosta> dsal: good luck 😬
14:01:19 * hackage bizzlelude 1.7.0 - A lousy Prelude replacement by a lousy dude  https://hackage.haskell.org/package/bizzlelude-1.7.0 (TheBizzle)
14:16:58 <dsal> Someone needs marketing help.
14:17:53 <hpc> yeah, it's hard to differentiate a prelude replacement just by being lousy :P
14:18:11 <Rembane> Or some help to handle the pressure you get by releasing something that people rely on 
14:19:22 <hpc> the funny thing is, that one's actually not half bad
14:19:50 <hpc> if it wasn't for a few bits like map = fmap, it wouldn't even be a prelude replacement
14:20:10 <hpc> just a ton of reexports
14:36:44 <dsal> OK.  Removing that Setup Stack thing seemed to get all my github CI flowing again.
14:59:35 <Squarism> Using classes as a way of make "typed modules". Types/functions dependent on types defined for a particular instance of a class. I see no way of making private member of the "typed module" class. Is there any around trick to that?
15:19:48 * hackage polysemy-http 0.3.0.0 - Polysemy effect for http-client  https://hackage.haskell.org/package/polysemy-http-0.3.0.0 (tek)
15:32:48 * hackage curl-runnings 0.16.0 - A framework for declaratively writing curl based API tests  https://hackage.haskell.org/package/curl-runnings-0.16.0 (aviaviavi)
15:36:18 <MarcelineVQ> that is beyond dad-tier punnery
15:40:06 <hpc> that is up there with acme-schoenfinkel for sure
15:41:16 <hpc> hasslich = unschoen is still my all-time favorite programming joke
15:41:41 <hpc> it's so simple, but it's got so much prerequisite knowledge too
15:51:03 <MarcelineVQ> roughly 100% prerequisite knowlege
15:52:31 <koz_> @hoogle Env
15:52:31 <lambdabot> module System.Posix.Env
15:52:32 <lambdabot> module Control.Comonad.Env
15:52:32 <lambdabot> Control.Comonad.Env type Env e = EnvT e Identity
15:52:39 <MarcelineVQ> like explaining an isomorphism just by naming your functions finkle and einhorn
15:52:58 <koz_> MarcelineVQ: That causes _physical_ pain.
15:53:08 <koz_> @hoogle Alt
15:53:09 <lambdabot> Data.Monoid newtype Alt f a
15:53:09 <lambdabot> Data.Monoid Alt :: f a -> Alt f a
15:53:09 <lambdabot> Language.Haskell.Exts.Syntax data Alt l
15:53:29 <MarcelineVQ> @hoogle Arg
15:53:29 <lambdabot> Data.Semigroup data Arg a b
15:53:29 <lambdabot> Data.Semigroup Arg :: a -> b -> Arg a b
15:53:29 <lambdabot> Test.Hspec type family Arg e :: Type
15:55:54 <koz_> MarcelineVQ: Wait, what's Arg from Data.Semigroup meant to be?
15:56:57 <MarcelineVQ> ArgMin/ArgMax
15:57:10 <MarcelineVQ> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Semigroup.html#t:Arg
16:32:26 <OmegaDoug> Hi. I want to model the Coinbase API and one of the keys is called "type". When I try to make a record with a key called "type" I get a parse error but "type1" works. What's the idiomatic way to model and serialize the data so I pass a key called "type" to Coinbase using Aeson?
16:41:49 <dsal> You can name the field anything you want.  I'd probably not name it type just because there may be more than one thing called type anyway, so maybe a name that has something to do with what it's the type of.
16:44:58 <OmegaDoug> dsal, this is Coinbase's api, so I have no choice but to use the key names that they specify. So if I use the name _type it gets serialized as _type, and not type. I suppose what I need to do is name the field as _type and (de)serialize to/from "type". Do you know the best way to do that?
16:46:10 <dsal> You can name it whatever you want and add field manipulation in your FromJSON instance.
16:47:06 <dsal> e.g.,      instance FromJSON YourThing where parseJSON = genericParseJSON jsonOpts{ fieldLabelModifier = dropWhile '_'
16:47:12 <dsal> Something like that.  And then a }
16:48:26 <OmegaDoug> dsal, thanks. I was looking for a concise solution. The other solutions I found online had a lot more code involved. I'll give that a try.
16:49:05 <dsal> fieldLabelModifier is a simple function that rewrites your field name to match a JSON field.  You can do lots of things there pretty easily.
16:56:25 <d34df00d> Hi!
16:57:43 <d34df00d> I want to parse an XML file and fold over the values of some of the nodes. Is there anything that'd stream the file as well?
16:57:53 <d34df00d> I wrote something with hxt, but it seems to load the whole file in memory.
16:59:47 <dsal> I used xeno a while back.  It was pretty easy.
16:59:50 <d34df00d> Namely, I wrote this, and, judging by memory consumption, it indeed loads the whole file:
16:59:55 <d34df00d> https://bpaste.net/RVMA
17:00:08 <d34df00d> dsal: thanks! Never used (or even heard about) xeno before, will look at ti!
17:00:49 <dsal> I don't have to deal with xml very much, so I don't know what's best, but that worked well for me. :)
17:01:39 <d34df00d> Yeah, same here. Last time I had to parse XML before was... well, I don't even remember!
17:02:10 <jedii> anyoine using happstack.com? looks sick
17:06:02 <d34df00d> Dang, Xeno.SAX is strict on the bytestrings.
17:06:52 <dsal> I wasn't using it for anything big.
17:06:57 <d34df00d> …but there's bytestring-mmap!
17:17:13 <cohn> hi, how do I create a minimal .cabal file for experimenting?
17:20:56 <OmegaDoug> Aeson fieldLabelModifier doesn't seem to get applied to by data type. I can't see what I'm doing which is different from any online example. I'm wondering if I could get a second set of eyes: https://gist.github.com/DouglasBrunner/5bf94447f57db989f9df5b6682a7fdf6
17:24:59 <dsal> cohn: I just use stack, tbh.  But stack will make your cabal file for you.
17:25:37 <dsal> OmegaDoug: Why would you expect the latter?
17:26:03 <dsal> Er, *not* expect the latter.  I think you're looking at different things.
17:26:58 <OmegaDoug> dsal, I think I'm making a simple mistake and didn't encode it.
17:27:14 <OmegaDoug> I think I'm just printing the output directly.
17:27:36 <dsal> You're using the Show instance, which isn't related to JSON (it's not even valid JSON).
17:27:38 <OmegaDoug> printing the type as serialized by Show, not as serialized by Aeson
17:27:50 <OmegaDoug> Yeah, you beat me to it. ;)
17:28:11 <dsal> But you also don't want "drop 1" here.
17:28:43 <dsal> `dropWhile (== '_')` would be safer, unless you prefix all your fields with `_` (which is common in lens code, anyway)
17:29:57 <OmegaDoug> I agree 100%. But when I was mistakenly using "Show" instead of "toJson" I wanted to use a function which should have been guaranteed to work. I'll switch back to dropWhile once I have it working.
17:30:48 * hackage immortal-worker 0.1.0.0 - Create worker threads that logs exceptions and restarts.  https://hackage.haskell.org/package/immortal-worker-0.1.0.0 (NCrashed)
17:31:37 <OmegaDoug> dsal, it's working perfectly now. Thanks for the help.
17:32:12 <dsal> Yeah.  I've spent a bunch of time in weird bits of aeson
17:38:14 <d34df00d> dsal: yeah, xeno is super fast, modulo a space leak in their `fold` abstraction.
17:38:20 <d34df00d> (modify instead of modify'? srsly?)
17:38:28 <d34df00d> Thanks for pointing me to that!
17:38:35 <OmegaDoug> I was looking through https://artyom.me/aeson and it's a library with a large surface area. I'll be curious to see how it is to work with compared with some of the JSON libraries I regularly use at work going forward.
17:38:50 <dsal> d34df00d: Cool.   Yeah, nobody uses xml, so it's not surprising it has bad parts.  heh
17:39:42 <OmegaDoug> We use XML a fair bit. We favour JSON, but XML is hard to escape. 
17:39:54 <dsal> &lt;
17:40:45 <dsal> aeson + lens is pretty magical.  Advent of code 2015 had a problem where you had to calculate the sum of all of the numbers in an arbitrary xml document.  It's like, 40 characters of code.
17:45:24 <cohn> dsal: I'm just trying to make a sandbox. Looks like I can just run `stack init` but I don't see where to plug in the package names I want to use in stack.yaml
17:46:04 <dsal> Oh.   Now I'm curious how you've been building stuff.  heh
17:47:23 <dsal> cohn: I have a template I use when starting projects.  Here's an example of what that might look like:    stack new awesomeproject https://gist.githubusercontent.com/dustin/e1a519e6d699ceb04c7542afe0282d56/raw/8066c389ff14799bddbb9278c5d986c20ed6d4b9/mytemplate.hsfiles
17:47:56 <dsal> (that's my default template, so I just do 'stack new awesomeproject' and start running stuff)
17:48:09 <cohn> nice! thanks
17:48:12 <dsal> Packages don't go in stack.yaml, but in package.yaml
17:48:36 <dsal> I don't have a lot of default deps other than for tests.
17:48:39 <cohn> I created a package.yaml but when I run `stack ghci`, it doesn't install anything
17:49:12 <dsal> It shouldn't "install" anything.  It's going to grab deps for whatever it's making a repl for.
17:49:17 <dsal> e.g. try that in this project:  https://github.com/dustin/gopro/blob/master/package.yaml  :)
17:49:23 <cohn> ok
17:50:12 <dsal> (don't actually try that in that project -- it uses half of hackage)
17:50:28 <cohn> yea, I noticed... yeesh!  :D
17:53:19 <cohn> hmm. still nothing.
17:54:56 <cohn> ah, fixed it! I had to comment out the "packages: []" line in stack.yaml
17:55:32 <cohn> suhweeeet
17:56:48 <cohn> dsal: thanks yet again! You should probably start charging for support. hehe
18:01:41 <quazimodo> sorry for o/t, is there an ocaml channel on freenode?
18:03:10 <cohn> quazimodo: /join #ocaml seems to be an actual OCaml channel
18:08:26 <zoom66> Question regarding polymorphic type associated with Num typeclass
18:08:43 <zoom66> Each of the following three funcs simply return the value passed to them:
18:08:46 <zoom66> retNum:: (Num a) => a -> a ; retNum x = x
18:08:50 <zoom66> retInt :: Int -> Int ; retInt x = x
18:08:54 <zoom66> retInteger :: Integer -> Integer ; retInteger x = x
18:08:58 <zoom66> if in GHCI I do retInt (retNum 10000000000000000000), I get an Int out of range warning, which is expected
18:09:03 <zoom66> however, if I do z = retNum 10000000000000000000
18:09:11 <zoom66> and then retInt z, I get an Int value which has wrapped since 'z' is too large for an Int to hold
18:10:07 <zoom66> retInt z displays -8446744073709551616
18:10:36 <zoom66> i'm a noob and trying to understand what bounding var checking I should be expecting, if any
18:11:18 <zoom66> naturally if I do retInteger z, I get the correct value
18:12:28 <dolio> Where are you doing the second thing?
18:12:37 <zoom66> ghci
18:13:00 <dolio> Well, z is probably a polymorphic value.
18:13:15 <dolio> Then retInt is instantiating it to Int.
18:13:31 <zoom66> so is there no type bounds checking for retInt?
18:13:40 <dolio> The warning only happens when you use a literal at a type known to be Int, I think.
18:14:22 <zoom66> it's basically just truncating the value to an Int. is that typical for a polymorphic type of Num typeclass?
18:16:11 <zoom66> ok, just tried it in compiled code and the z = retNum 10000000000000000000 generates the -Woverflowed-literals warning
18:16:14 <dolio> Numeric literals just wrap around on the finite integer types in base.
18:16:33 <zoom66> i don't get the warning doing the same statement interactively in ghci
18:16:38 <dolio> Because the `fromInteger` function wraps around.
18:17:27 <dolio> Well, in the compiled code, it will probably be trying to find a monomorphic type for `z`, and it will see that it needs to be `Int`.
18:17:48 <dolio> Which means that the literal's type is Int, and then it can warn.
18:18:05 <dolio> When you're doing it in GHCi, the literal's type is `forall a. Num a => a`.
18:18:20 <zoom66> so when constructing real-world logic, if there's ever a function that may exceed the bounds of Int, I guess I can't guess a polymorphic type variable? 
18:18:24 <dolio> Because it's doing things line-by-line.
18:18:47 <dolio> So if it didn't leave it polymorphic, you wouldn't be able to use it at arbitrary other types later.
18:18:56 <zoom66> ok, got it
18:19:20 <zoom66> what if I have two Int that are polymorphic and do an operation where the result exceeds Int. Does it just wrap?
18:19:46 <dolio> Yes. There are packages with other Int types that will throw exceptions, though.
18:20:14 <zoom66> great, thanks
18:27:31 <Squarism> I used to know why this was a bad idea but I've been away from haskell to long. 
18:27:42 <Squarism> I want to create a function returning a generic interface. foo :: Int -> SomeGenericInterface. So I think classes + instance is the thing. So foo :: Int -> SomeClass a. But then I need to provide "a" at invokation. Is the right answer to create a datatype (unparamterized) SomeType with accessors for funktions I want in this generic interface? Classes are just usefule when working with a known type.  
18:39:21 <nitrix> Squarism, Type classes don't appear like that on the right of an arrow.
18:39:40 <Squarism> Yeah, its coming back to me
18:40:00 <nitrix> Squarism, You normally have a type variable with a constraint to restrict it to one of the types that implements the typeclass.
18:40:02 <Squarism> Just feels like it would be possible to create classes where the type is not used in functions that could be "anonymous" like this. But I guess Its out of their scope
18:40:21 <nitrix> Squarism, e.g. foo :: SomeClass c => Int -> c a
18:40:30 <Squarism> yeah. 
18:42:07 <infinisil> Squarism: You may be looking for existential types, see https://wiki.haskell.org/Existential_type
18:47:48 <koz_> I've noticed that most (effectful) streaming libraries (aside from conduit and io-streams) don't have a notion of 'peeking' a stream (namely, looking at the next value, but without removing it from said stream). How come this is the case?
19:49:26 <lechner> Hi, I recently discovered Haskell and love it. At the same time, I wonder if it can express all of a programmer's common intentions. Functional programming seems strictly inferential, and H. Curry read Whitehead and Russell. Do I have to worry about Haskell being incomplete similar to algebra?
19:52:37 <sm[m]> lechner: someone more knowledgeable on this will come along, but you don't have to worry about being able to express practical software
19:54:13 <sm[m]> what sort of situation could arise if your fear is true ?
20:03:09 <dsal> lechner: I write almost all of my software in Haskell.
20:06:28 <dsal> heh, my cachix CI task takes about 2 hours to run for my mqttd.  About 3m for my old stack thing now that I've fixed it.
20:06:31 <davean> lechner: its turing complete, it can do exactly what any other programming system can do. 
20:14:49 * hackage silkscreen 0.0.0.0 - Prettyprinting transformers.  https://hackage.haskell.org/package/silkscreen-0.0.0.0 (robrix)
20:19:23 <zoom> I have a basic polymorphic type question. I have default (Int, Float) set for my module. In compiled code, I have "z = 0". GHCI reports z's type as Int, as expected.
20:19:41 <zoom> If I then pass z to the following function:
20:19:54 <zoom> retInteger :: Integer -> Integer ; retInteger x = x
20:20:07 <zoom> and store it in z2, the type of z is now Integer instead of Int
20:20:12 <zoom> to recap:
20:20:26 <zoom> z = 0 (type is Int)
20:20:35 <zoom> z2 = retInteger z
20:20:47 <zoom> z now compiles as Integer
20:21:57 <zoom> why is the type of z affected by the fact that it was passed to retInteger, which returned a separate immutable value
20:22:26 <dsal> I think you're inferring too hard.  If z should be an Int and fail here, you should say `z :: Int`
20:22:45 <zoom> understood I can explicitly cast. Just trying to understand the compiler / language behavior
20:22:58 <dolio> :: isn't casting.
20:23:02 <dsal> I don't think cast is the right word.
20:23:04 <zoom> didn't mean to say casting
20:23:23 <zoom> I mean I understand I can explicitly specify the type
20:24:04 <zoom> but trying to understand why the compiler implicitly switches z from an Int to Integer if z is passed to a function that treats z as an Integer
20:24:20 <zoom> i would expect z2 would be an Integer and z would remain an Int
20:24:21 <dsal> It's not totally clear what you're doing.
20:24:36 <zoom> default (Int, Float)
20:24:36 <zoom> z = 0
20:24:43 <zoom> when compiled, the type of z is an Int, as expected
20:24:54 <dolio> z needs to have type `Integer` to be an argument of `retInteger`.
20:25:03 <dolio> So defaulting isn't even happening.
20:25:23 <cohn> zoom: maybe this helps?  https://stackoverflow.com/questions/3429291/what-is-the-difference-between-int-and-integer
20:25:26 <dsal> Are you playing in ghci?
20:25:33 <zoom> not ghci, this is compiled code
20:25:45 <dolio> Defaulting only happens when something needs a monomorphic type, but nothing else in the code determines the choice.
20:26:31 <dsal> You mentioned ghci.  You're being vague about what you're doing, because you can't both have something you're asking GHCI for the default type of, and have a thing you're compiling that passes a value to a function with a known type.
20:26:49 <zoom> i only use ghci to check the type the compiler inferred. code is compiled
20:27:42 <dsal> But if you're passing z to a function that requires an Integer, then you know the type that was inferred is Integer.
20:28:51 <zoom> ok, i guess the compiler infers z1 is an Integer from the call. what threw me off is if I compile z = 0 by itself it's an Int. If I then add the line to call retInteger it's an Integer. I considered them two separate statements but I guess the compiler changes the inferences of z1 = 0 when it sees the call to retInteger
20:29:21 <zoom> If I explicitly set z :: Int and then call retInteger I get the type mismatch error, as expected
20:30:09 <dsal> In general, you don't want to do that.  -Wall will enable a warning telling you a) what it inferred the type to be and b) that it shouldn't have to do that because you should declare your toplevel types.
20:32:52 <zoom> ok, tried the -Wall and see the warning you mentioned. 
20:35:20 <zoom> does top-level binding refer to scope?
20:35:28 <zoom> ie, the outermost scope?
20:39:27 <dsal> Yeah.  I don't annotate all my types, just at the toplevel and whenever it's otherwise helpful or avoids confusion.
20:41:11 <zoom> thanks. i'm surprised it's suggested practice considering how useful type inference is. is the suggestion limited to top-level binding because it's assumed all subsequent calls/uses flow from the types at the top-level?
20:41:39 <dsal> It's a good boundary.  You can get *massively* confused if you let the type system guess your whole program.
20:42:19 <zoom> my preference coming from C is to specify all my types. I thought I was actually adapting by using inference instead. 
20:42:34 <dsal> You think you're working with a list of ints or something, but no, it's a Foldable Semigroup of an Integral value.
20:42:40 <zoom> ie, adapting to the haskell way. thanks for setting me straight
20:43:43 <hololeap> using type annotations here and there (e.g. all top level definitions) helps to make sure that your thought process and the compiler are in-sync
20:43:45 <dsal> -Wall is generally a good idea.  :)
20:44:22 <zoom> makes perfect sense to me. and would my preference now that I see it's recommended practice anyway
20:44:24 <dsal> It makes your code far easier for you as a human to read, but it also means your error messages won't be just an arbitrary permutation of type classes and a frowny face.
20:45:04 <hololeap> ghc outputs frowny faces?
20:45:25 <dsal> I don't know... if you get too deep into inference, the error is too large for anyone to really know what happens.
20:45:34 <dsal> Well, except for C++ programmers, I guess.  They won't notice the error scroll by.
20:46:37 <dolio> It's not necessarily that it's large. It's more that it's non-local.
20:48:00 <dolio> You can write code where the types accidentally work out until a part that isn't really related to where the problem is.
20:48:42 <dsal> Yeah, and as you make things more generic, they can work in more places, so you use them in more places, and then just weird happens.
20:49:26 <hololeap> "Occurs check: cannot construct infinite type" is usually the hardest one for me to understand what i did wrong
20:49:55 <dsal> > foldMap (*1) [0, 1, 2, 3, 4]
20:49:57 <lambdabot>  error:
20:49:57 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M650599424046...
20:49:57 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
20:50:18 <dsal> Errors like this will ramble on for a bit.
20:50:24 <dsal> > foldMap (*1) [0, 1, 2, 3, 4] :: Sum Int
20:50:28 <lambdabot>  Sum {getSum = 10}
20:50:32 <dsal> > foldMap (*1) [0, 1, 2, 3, 4] :: Product Int
20:50:34 <lambdabot>  Product {getProduct = 0}
20:50:39 <dsal> Stupid zero.
20:51:46 <dsal> It gets *really* exciting when you enable OverloadedLists
20:52:24 <c_wraith> hololeap: that error means that GHC tried to unify a pair of types where one occurs inside the other.  Just declaring them to be equal would mean the full expansion is infinite.
20:53:04 <dsal> a ~ [a]   kinds of things
20:53:08 <hololeap> c_wraith: it often crops up when i refactor to pointfree and i forgot to remove one of the arguments from the function definition
20:53:32 <dsal> OMG, I'm trying to figure out where I've used OverloadedLists, and I have a tiny file here with it on, but I'm still using Map.fromList
20:53:35 <c_wraith> hololeap: sure, a -> b and b could unify if infinite types were allowed
20:53:38 <dolio> You can actually have type systems that allow that. But it catches so many incidental errors it'd be kind of terrible.
20:53:52 <dsal> Ah, I use it in tests sometimes.
20:53:54 <c_wraith> hololeap: but it would also imply a -> a -> b is the same type as b
20:53:58 <dolio> At least, you don't want it without requesting it.
20:54:48 <hololeap> c_wraith: i am glad that it throws _some_ error, but that particular error message usually leaves me scratching my head for a minute. at least it gives a line number so i can stare at it until i see what i did wrong
20:54:51 <dsal> The error message confuses people because it's accurate in type theorist language, but it generally means, "I don't think you're saying what you mean."
20:55:12 <c_wraith> Just look at the two types it tells you
20:55:52 <c_wraith> If the bigger one is a function type, it means you have differing numbers of arguments in different branches.
20:56:10 <hololeap> that's a very useful tip that i will keep in mind
20:56:21 <dsal> It's usually `a ~ [a]` for me which is always a dumb error.
20:56:42 <c_wraith> > let f 0 = Nothing ; f x = show x in f ()
20:56:44 <lambdabot>  error:
20:56:44 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Maybe a2’
20:56:44 <lambdabot>        Expected type: Maybe a2
20:56:46 <dolio> Yeah, it usually has something to do with too many or too few arguments, or arguments in the wrong order or something.
20:56:50 <c_wraith> Oh, whoops.
20:56:54 <c_wraith> > let f 0 = Nothing ; f x = x in f ()
20:56:57 <lambdabot>  error:
20:56:57 <lambdabot>      • Couldn't match expected type ‘Maybe a’ with actual type ‘()’
20:56:57 <lambdabot>      • In the first argument of ‘f’, namely ‘()’
20:57:04 <dolio> Or forgetting to map/bind something.
20:57:07 <c_wraith> Oh, too much inference.  Oh well.
20:57:20 <c_wraith> Anyway.  Look at the two types it's telling you it's trying to unify
20:57:35 <c_wraith> The difference between them is the important part
20:57:38 <dolio> I'm not sure if GHC tries to tell you what's wrong, but I'm not sure how it would narrow it down.
20:59:20 <hololeap> don't get me wrong, i'm not complaining. the fact that ghc uses type theory to allow a huge number of valid things is awesome. but at first it complaining that i was trying to construct an infinite type for some mundane function made me go WTF
20:59:50 <c_wraith> the thing to remember is that GHC tries *really* hard to make your code work.
21:00:19 <c_wraith> In this case, it's reaching the conclusion "this code would type-check if these two types are the same."
21:00:33 <c_wraith> And then going "oops, I'm not allowed to make these two types the same"
21:01:19 <c_wraith> And it reports that last problem, because that's the point from which it could make no more progress.
21:03:49 <hololeap> it's like if i was trying to skip rocks, and failed, and someone came up to me and said "why are you trying to subvert the laws of physics by skipping a rock at that velocity and trajectory?"
21:03:57 <zoom> kind of an open-ended questions but I'm in the midst of learning haskell and I'm about 2/3 through the learnyouhaskell guide. I can see the steep learning curve and I'm fine with that but I'm wondering if there's any hidden learning curves I don't forsee. for example, quirks in the language that you really only learn "on the job" after using it in
21:03:57 <zoom> a production environment. 
21:04:21 <zoom> and if so, how significant those additional learning curves might be
21:04:42 <c_wraith> You can bounce hard off of some of the more high-powered libraries used in production code
21:06:06 <c_wraith> like...  lenses are so useful it's hard to justify not using them on sufficiently large projects, but there's another huge upfront cost to learn.
21:06:38 <cohn> agree --^
21:06:43 <zoom> maybe quirks isn't the right word. I guess I'm asking how deep the rabbit hole goes beyond the basic language. like undocumented or lightly documented behaviors
21:06:48 <MarcelineVQ> it is a bit of a cost, I wrote a lens library and still don't know how to use them ^^;
21:07:31 <c_wraith> debugging performance issues is probably the one big thing with poor documentation.
21:07:54 <hololeap> zoom: it isn't as bad as you might think. there are some well known thorns such as lazy IO and space leaks, but overall, the scariness overshoots the actual dangers
21:08:08 <c_wraith> There are a ton of tools that are all documented individually, but there's little in the way of unified big-picture documentation for the process
21:08:22 <zoom> i actually enjoy exploring the nuances and corner-cases of languages but that seems like kids play to what I'm facing with haskell
21:08:43 <c_wraith> for the language itself, Haskell has fewer corner cases than most.
21:08:58 <c_wraith> Unless you start turning on every type system extension you can find :)
21:09:42 <hololeap> but, then again, there are many benign language extensions that shouldn't be off-limits for a beginner
21:10:10 <c_wraith> Sure.  There are lots of extensions that don't hurt anything.  But *some* of them add all sorts of corner cases.
21:10:11 <zoom> for example i discovered a few of the {-# LANGUAGE ... } behaviors and the breadth of what's there is a bit scary to me
21:10:26 <hololeap> i was scared of using any language extensions when i first started, and now i see how many of them really don't hurt at all
21:11:16 <zoom> it almost seems like one has to learn or at least understand all the antecedent versions and behaviors
21:11:40 <c_wraith> *most* extensions can be learned in isolation.  They're just a thing that can be added to the base language.
21:12:13 <c_wraith> There are exceptions.  Functional dependencies only make any sense with multiple parameter type classes, for instance.
21:13:08 <c_wraith> But for the most part, extensions try to be focused additions to the language.
21:13:55 <hololeap> i remember seeing a list of language extensions that was sorted by relative safety
21:14:10 <dolio> You can use functional dependencies without multi-parameter classes. It means you can only write one instance. :)
21:14:22 <dolio> Like `class C a | -> a where ...`
21:14:45 <c_wraith> so...  the same as just writing a function? :P
21:14:47 <hololeap> and it included which ones you could have turned on all the time without having any dangerous corner cases
21:14:50 <c_wraith> (or set thereof)
21:15:42 <hololeap> there were quite a few that were deemed totally safe, like MultiParamTypeClasses, FlexibleContexts, FlexibleInstances, LambdaCase, etc...
21:15:55 <MarcelineVQ> hololeap: search for What I Wish I Knew when learning haskell or something
21:16:01 <zoom> A comment I watched from Simon Peyton Jones scared me too - he said they put as much complication they could get away with without programmers running away.
21:16:24 <hololeap> zoom, it's well-typed complications :)
21:16:39 <c_wraith> It's useful to remember that SPJ is all about accessibility.
21:17:17 <cohn> MarcelineVQ: http://dev.stephendiehl.com/hask/   <-- great read
21:17:41 <hololeap> MarcelineVQ: thank you
21:17:48 <hololeap> zoom: check this out: http://dev.stephendiehl.com/hask/#the-benign
21:18:13 <zoom> cohn and hololeap, thanks, i'll give it a read
21:18:34 <cohn> np
21:22:42 <cohn> zoom: this is another good book if you can stomach working through ~ 1,200 pages of text.
21:22:45 <cohn> https://haskellbook.com/
21:25:44 <hololeap> zoom, i remember when i really started to grok haskell was when i understood monad transformers. i'm not sure why, but that was the key for me feeling less overwhelmed and more excited by learning the language
21:27:41 <cohn> this is also worth reading:  http://norvig.com/21-days.html
21:28:16 <zoom> cohn, thanks. I have that book on my list. I read through a little of the 21-days but decided ping-ponging back and forth between learnyou and it was a little distracting. my plan is to finish learnyou, then do the 21 days, then the book
21:29:12 <zoom> oops, meant https://www.seas.upenn.edu/~cis194/spring13/lectures.html, not the 21-days
21:30:26 <lechner> hololeap cohn MarcelineVQ: I like Stephen Diehl's book too!
21:30:27 <cohn> zoom: yep, that's a good resource too.
21:30:55 <cohn> lechner: yea, it's really good stuff! :D
21:35:53 <dsal> I really liked haskellbook.com.
21:36:19 <dsal> It let me pretend like I didn't know anything, which made it a lot easier to learn things.
21:49:18 * hackage little-logger 0.2.0 - Basic logging based on co-log  https://hackage.haskell.org/package/little-logger-0.2.0 (ejconlon)
22:56:51 <gewaltdisney> what is the best way to do live coding in haskell in 2020?
22:57:05 <gewaltdisney> ghci?
23:06:25 <dsal> ghci is probably the worst.
23:07:23 <dsal> I've done it on occasion in emacs with the interpreter in place over a file, but I usually just write code in files.
23:08:20 <c_wraith> it depends on what you're doing.
23:08:36 <c_wraith> if you're using tidal, you use ghci
23:14:21 <gewaltdisney> cool, ghci seems to be the way then :)
23:24:38 <p0a> Hello how can I offer some documentation corrections in a package on hackage?
23:24:58 <gewaltdisney> curious why you say its the worst dsal 
23:25:51 <dsal> It's hard to do multiline, and if you're doing anything remotely complicated, you're going to be sad about having to either throw away a bunch of state or try to recreate it in a file.  It's easier to just have a file.
23:25:57 <sshine> p0a, 1) find the project on GitHub (link is on Hackage), 2) search for the thing you want to correct, 3) submit a pull request.
23:26:20 <sshine> p0a, if you want a t-shirt for your efforts, sign up for Hacktoberfest before you do this.
23:27:14 <p0a> sshine: thank you! I am against paraphanelia tho (I still shiver about being given a yo-yo in a math conference)
23:28:37 <nshepperd> true, yoyos are spooky
23:28:57 <sshine> also, yoyos mainly collect dust.
23:29:30 <sshine> p0a, there's no guarantee that the package is hosted on GitHub, but it's so often the case.
23:29:49 <p0a> Yeah, it's sqlite-simple which is on github. I didn't realize there's github links, I definitely know what to do now
23:30:28 <sshine> gewaltdisney, I'd go with Emacs + haskell-mode since there's a keyboard shortcut for sending your file to be evaluated in a split-screen REPL. perhaps this is equally doable with VSCode or some other editor. but that's the user experience I'd aim for. :)
23:30:49 <p0a> I can't get Emacs and haskell-mode to work with stack projects, am I doing something wrong?
23:31:03 <p0a> I can give the error if needed 
23:31:13 <sshine> gewaltdisney, typing into GHCi is too limiting for anything above one-liners, and you can't easily save.
23:31:53 * sshine hasn't run Emacs for a year now and can't remember.
23:32:09 <p0a> NEvermind. I was running haskell-process-cabal-build on a stack project, that's why. lol
23:32:15 <sshine> hehe :)
23:32:31 <p0a> sshine: as with many other issues, I solve it as I'm about to explain it on IRC
23:32:33 <sshine> when I use editor/IDE tooling, I mostly tab into the console and run build commands, anyways...
23:32:58 <p0a> Yeah but one useful feature is to be able to examine the type of a symbol/expression in the source
23:33:06 <sshine> p0a, that's the story of why I never ask questions on StackOverflow. I want to provide enough context for people to be able to help me, and that's usually enough context for me to help myself.
23:33:18 <p0a> hah 
23:33:38 <sshine> like, I want to rule out the "did you look in <obvious place X>?" and "did you try <obvious thing Y>?"
23:34:41 <sshine> with obvious being anything I can easily come up with while formulating the question, of course. :) it's just that if I ever try to bite off more than I can chew, I usually have to ask a *lot* of questions.
23:35:07 <p0a> So a basic question now, but can I use sqlite-simple with RIO?
23:35:15 <sshine> why not?
23:35:31 <p0a> For example, SQLText is !Text, but RIO has RIO.Text 
23:35:41 <gewaltdisney> sshine thanks! I use emacs but am new to haskell (coming from ocaml). i'll figure out how to set things up this way
23:35:45 <p0a> I'm not sure how that works. Does it know to use RIO.Text instead of Data.Text?
23:35:54 <sshine> p0a, RIO.Text is just a re-export
23:36:44 <p0a> I don't know what you mean 
23:36:51 <sshine> p0a, https://hackage.haskell.org/package/rio-0.1.19.0/docs/src/RIO.Text.html <- all it does is import Data.Text and then only export some of that.
23:37:19 <p0a> okay, but it's called RIO.Text and not Data.Text. So it works anyway?
23:37:41 <sshine> so RIO.Text is just convenience for Data.Text. I think the points RIO is trying to make are 1) Text is so common, let's just have it in our version of Prelude, and 2) let's not include the bad functions.
23:38:30 <sshine> so I don't think you even need to 'import RIO.Text' if you have followed one of the recommended ways of using RIO as your Prelude replacement.
23:38:55 <p0a> Right the introduction to RIO mentions these things more or less, I am just not sure how haskell code works. In the sense that if I write a module that imports Data.Text (how else would they have SQLText be !Text), how can that then be replaced by RIO.Text.Text?
23:38:55 <sshine> p0a, https://github.com/commercialhaskell/rio#import-practices
23:39:34 <p0a> I did read that but I'm still confused about how a module that was built for/with Data.Text would work ok with RIO
23:39:52 <p0a> say I have f :: Data.Text.Text -> Int with f _ = 1. How would that function work if I import RIO instead?
23:39:57 <sshine> so, sqlite-simple may import Data.Text explicitly and your module may import RIO.Text implicitly, but in the end, the same module that exports the same data type is referred to in two places, and they get unified...
23:40:31 <sshine> I think it's actually pretty neat that that works. I remember that you *don't* get that kind of convenience across Standard ML functor (as in parameterised module) application.
23:40:39 <p0a> the signature wouldn't match would it? f ("foo" :: RIO.Text.Text)
23:41:07 <sshine> the type's name is just 'Text'. when you see it as e.g. 'RIO.Text.Text', that's mostly an indicator of how you imported it.
23:41:20 <p0a> Aha. Tricky
23:41:40 <p0a> Thank you 
23:41:51 <sshine> if RIO.Text defined 'newtype Text = Derpy Text deriving ...', then RIO.Text.Text would kinda be the same type but you'd get a type mismatch error.
23:42:29 <sshine> but that wouldn't benefit the purpose of RIO's RIO.Text module.
23:42:45 <sshine> they just want to import Text-related stuff automatically and not have partial functions.
23:44:34 <koz_> sshine: Derpy Text rofl.
23:44:40 <sshine> I think that if you had to explicitly import RIO.Text, then this would actually be confusing: is their Text even the same? but since it's automatically imported, the purpose of the library is just to provide a list of the Text functions they like (and provide a place for extending this collection without having to deal with upstream).
23:45:06 <sshine> sorry, s/the library/the module/
23:57:57 <p0a> When I use `stack new projectname rio' there's some code that let's me use command line arguments  
23:58:11 <p0a> I can't understand from looking at the source, is that a hand-crafted solution or does it use getOpt somewhere?
23:58:42 <p0a> Is it logOptionsHandle?
