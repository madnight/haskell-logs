00:06:26 <dsal> I've never seen this rio template, but I don't think I like it.
00:07:11 <p0a> Okay, I think I figured out that I now need to read the intro to rio from https://www.fpcomplete.com/haskell/library/rio/
00:07:24 <p0a> Are there any other sources to learn rio from? A book perhaps?
00:09:52 <dsal> I've just seen blog posts and stuff.  It looks like it wants to be the next big thing, but makes me learn stuff and accept opinions without me seeing the obvious benefit.
00:10:25 <p0a> what about their exceptions? I read a bit on it and it seemed cool
00:11:21 <dsal> I don't know.  I've read some of the stuff and the goal sounded interesting.  I like unliftio, but too much of this "I've solved all the problems" kinds of things from that camp.  -- someone who can't quit stack
00:12:10 <p0a> Would you recommend I do my project without rio then?
00:12:49 <dsal> Not really.  Part of my problem is having to unlearn stuff to learn new stuff to get marginal benefit.  If you don't have patterns you're comfortable with, RIO might be good for you.
00:13:02 <p0a> that's what I was thinking dsal
00:13:33 <p0a> I haven't developed a style yet and rio appears to be developed by experts
01:47:48 * hackage these-lens 1.0.1 - Lenses for These  https://hackage.haskell.org/package/these-lens-1.0.1 (phadej)
01:48:48 * hackage these-optics 1.0.1 - Optics for These  https://hackage.haskell.org/package/these-optics-1.0.1 (phadej)
03:15:19 * hackage wai-feature-flags 0.1.0.0 - Feature flag support for WAI applications.  https://hackage.haskell.org/package/wai-feature-flags-0.1.0.0 (JasperWoudenberg)
03:25:22 <maralorn> Is there a nicer function for \(x :: IO ()) -> race_ (concurrently_ x (threadDelay 20000))  (threadDelay 500000)?
04:31:19 * hackage publish 2.1.5 - Publishing tools for papers, books, and presentations  https://hackage.haskell.org/package/publish-2.1.5 (AndrewCowie)
04:49:18 * hackage elm-street 0.1.0.3 - Crossing the road between Haskell and Elm  https://hackage.haskell.org/package/elm-street-0.1.0.3 (HolmuskTechTeam)
04:51:12 <irc_bot_9000> hi, haskell n00b here. From the paper "Why Functional Programming Matters" by John Hughes, can someone explain the optimization performed by the introduction of maximize`/minimize` ?
04:51:34 <irc_bot_9000> it seems to be that it have to iterate through the tree anyways, I don't see how it optimizes the search algorithm
04:55:48 * hackage silkscreen 0.0.0.1 - Prettyprinting transformers.  https://hackage.haskell.org/package/silkscreen-0.0.0.1 (robrix)
05:07:19 * hackage free-functors 1.2 - Free functors, adjoint to functors that forget class constraints.  https://hackage.haskell.org/package/free-functors-1.2 (SjoerdVisscher)
05:27:48 * hackage vulkan 3.6.8 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.8 (jophish)
07:02:18 * hackage pretty-diff 0.2.0.1 - Pretty printing a diff of two values.  https://hackage.haskell.org/package/pretty-diff-0.2.0.1 (JasperWoudenberg)
07:32:40 <jollygood2> > printf "%g" 1.0 :: String 
07:32:42 <lambdabot>  "1.0"
07:32:53 <jollygood2> is this expected and deliberate? it doesn't match behavior of printf in C
07:49:55 <tomsmeding> jollygood2: see the last part of the documentation: https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-Printf.html#v:printf
07:54:05 <jollygood2> tomsmeding ok. I like C's behavior better, but it is what it is
07:55:17 <tomsmeding> ¯\_(ツ)_/¯
08:05:15 <maerwald> "I like C's behavior better" ...so as long as you don't pass user input into it :p
08:09:04 <tomsmeding> maerwald: that's not really what the question was about ;)
08:09:44 <maerwald> I wasn't answering the question :)
08:32:48 <jollygood2> %10s flag in printf alignts to right, %-10s to the left, but is there a way to center the text?
08:34:00 <geekosaur> there is not, neither in haskell nor C printf
08:55:49 <jollygood2> @hoogle Show a => IO a
08:55:51 <lambdabot> System.Exit exitFailure :: IO a
08:55:51 <lambdabot> System.Exit exitSuccess :: IO a
08:55:51 <lambdabot> GHC.IO.Handle.Internals ioe_closedHandle :: IO a
08:56:04 <jollygood2> what function is that? reading a line from stdin, and then trying to read it with read
08:56:10 <jollygood2> @hoogle Read a => IO a
08:56:11 <lambdabot> Prelude readLn :: Read a => IO a
08:56:11 <lambdabot> System.IO readLn :: Read a => IO a
08:56:11 <lambdabot> Test.Hspec.Discover readLn :: Read a => IO a
08:56:16 <jollygood2> nm ;)
08:57:49 <geekosaur> the Show version is `print', fwiw
08:59:19 * hackage simple-cabal 0.1.3 - Cabal file wrapper library  https://hackage.haskell.org/package/simple-cabal-0.1.3 (JensPetersen)
09:12:43 <tomsmeding> is there a simple way to make command-line hoogle print the _package_ a particular module is from?
09:28:56 <c_wraith> can't ghc-pkg do that?
09:30:32 <c_wraith> yeah...  it depends on having a package database, of course, but ghc-pkg find-module does exist
09:38:49 * hackage irc-client 1.1.2.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-1.1.2.0 (barrucadu)
09:43:33 <tomsmeding> c_wraith: oh that's exactly what I wanted!
09:44:03 <tomsmeding> though I still wonder why hoogle can't seem to, especially since its web interface does list the source package :p
09:52:43 <[exa]> (also ghc-pkg doesn't really help you if you don't have the package installed, right?)
09:53:11 <geekosaur> right
09:54:10 <ibloom> Let's say I have a buffer that I created in the IO monad using mallocBytes. I wrote a bunch of data to it in using poke.  Is there a way I can freeze that buffer and access it, read only, from a pure function.
09:56:28 <rotaerk> ibloom, it would involve copying the contents of it into a pure value
09:57:06 <ibloom> Would I need to actually copy it or can I tell the compiler that it's frozen somehow?
09:57:06 <[exa]> there are some ways for wrapping it in a "nice" interface, e.g. ByteString can be created from ForeignPtr
09:57:18 <[exa]> (without copying ofc)
09:57:20 <c_wraith> ibloom: mallocBytes and poke are part of the FFI, they're not really designed to support freezing.  the array/vector packages give you an interface that does support freezing.
09:57:51 <[exa]> ibloom: why the raw malloc btw?
09:58:12 <ibloom> The reason I'm doing this is because I have functions in OpenCL, Cuda and reference functions in Haskell. 
09:58:41 <ibloom> I'd like the haskell functions to just read from the same structures.
09:58:44 <[exa]> probably better allocate an unboxed vector, convert it to Ptr and send that pointer
09:59:12 <[exa]> or are the structures allocated in the foreign code?
10:00:23 <ibloom> The other reason I'm using malloc is because I homebrewed an append only buffer that can grow indefinitely. So maybe what I'm looking for is a package with a datatype that can be appended indefinitely and then frozen.
10:01:16 <rotaerk> the problem with freezing-without-copying is that it can still be mutated through the original pointer to it
10:01:34 <rotaerk> unless it's an interface that forces the pointer to go out of scope just before the freeze
10:01:42 <ski> (unless you ensure that you have a unique reference to the mutable block)
10:02:06 <ski> ibloom : `realloc' ?
10:02:44 <ibloom> I'm currently using realloc to grow my homebrew buffers.
10:03:17 <ibloom> Basically I  serialize haskell structures into buffers to send them to the GPU. I'm also maintaining haskell versions of the GPU code and I'd like that code to read the same buffers while being pretty clean.
10:04:24 <ski> you could look at how <https://hackage.haskell.org/package/bytestring-0.11.0.0/docs/Data-ByteString-Internal.html> does things, e.g.
10:06:03 <ibloom> ski: I'll take a look at that thanks. I read about a newer variable size vector implementation a while back but I forgot the name.
10:36:31 <justsomeguy> What do you think of using Haskell to write devops tooling? (Stuff to talk to APIs over http, move files, ssh into things and run commands remotely, log analysis, talk to dbus, etc.)
10:36:44 <maerwald> use bash
10:37:09 <maerwald> all you gonna do is trying to wrap existing tools (like curl), what for
10:38:06 <Guest_4963> complete novice to ghcup - run installation but no ghci - is that normal? 
10:38:20 <Guest_4963> complete novice to ghcup - I ran the ghcup installation but no ghci - is that normal? 
10:38:33 <maerwald> Guest_4963: source ~/.ghcup/env
10:43:35 <Guest_4963> @maerwald thanks! turns out I had to run 'ghcup set' 
10:43:36 <lambdabot> Unknown command, try @list
11:06:20 <kindaro> What monad transformer should I use for modeling non-determinism? I read that the obvious `Control.Monad.Trans.List` is deprecated. My underlying monad is Q from Template Haskell.
11:07:50 <kindaro> A quick search shows that there is a number of alternatives and I wonder if any of them is considered superiour.
11:09:11 <sm[m]> justsomeguy: you might be interested in http://hackage.haskell.org/package/propellor
11:09:48 * hackage rib-core 1.0.0.0 - Static site generator based on Shake  https://hackage.haskell.org/package/rib-core-1.0.0.0 (sridca)
11:10:48 * hackage rib 1.0.0.0 - Static site generator based on Shake  https://hackage.haskell.org/package/rib-1.0.0.0 (sridca)
11:12:42 <ski> @hackage ListT done right
11:12:42 <lambdabot> https://hackage.haskell.org/package/ListT done right
11:12:48 <ski> er, right
11:12:53 <ski> @hackage ListT_done_right
11:12:53 <lambdabot> https://hackage.haskell.org/package/ListT_done_right
11:14:10 <ski> oh. sorry, i'm actually using the wrong lambdabot command (which explains why the link was incorrect) ..
11:14:13 <ddellacosta> https://hackage.haskell.org/package/list-t
11:14:16 <ski> @wiki ListT_done_right
11:14:16 <lambdabot> https://wiki.haskell.org/ListT_done_right
11:14:26 <ddellacosta> ^ think you're looking for that ski?
11:14:58 <ski> no, i was looking for that wiki page (having just looked at it, before, in the browser)
11:15:06 <ddellacosta> oh, gotcha, sorry to muddy the waters
11:15:12 <ski> (but it does mention `list-t', yes)
11:16:16 <justsomeguy> sm[m]: Looks awesome <3. Thanks for bringing it to my attention.
11:16:45 <sm[m]> it's interesting, I have used it a bit but not in anger. Let me know if you do
11:17:06 <kindaro> @sk
11:17:06 <lambdabot> Who should I ask?
11:17:16 <sm[m]> the downside is you have to install a haskell toolchain before you use it, unlike a bash script
11:17:56 <sm[m]> an upside is that it converges to the desired state, unlike most bash scripts
11:17:58 <kindaro> ski, I am aware of that page, but it does not single out a specific package. Besides, my impression is that Haskell Wiki is mostly obsolete.
11:18:16 <sm[m]> (when is that really useful ? I'm not sure)
11:18:24 <ddellacosta> some parts remain very useful, but unfortunately it can be hard to filter out what is and isn't deprecated info
11:18:35 <ski> kindaro : it's not too clear what you're looking for, i guess
11:19:04 <maerwald> I've used propellor and I would not recommend it
11:19:14 <kindaro> What is not clear? I am looking for a monad transformer for running non-deterministic effectful computations.
11:19:28 <kindaro> Preferably one that enjoys community support.
11:19:53 <ski> are you looking for some sort of incremental streaming ?
11:19:55 <justsomeguy> Even if it's not a practical tool, it will be interesting for me to read the code to see how it works.
11:19:57 <maerwald> For the kind of stuff propellor does, you don't actually care much about types. You care about: 1. documentation, 2. help and community and 3. correctness of the recipes
11:20:04 <maerwald> propellor scores low on all of these
11:20:31 <ski> by "non-deterministic", do you have angelic non-determinism in mind ? erratic ? demonic ?
11:21:13 <ski> there should be some CPS-based `ListT' alternative, although i forget the package name
11:21:18 <maerwald> ansible scores higher on 1. and 2., but not on 3.
11:21:49 <maerwald> but it's much easier to use and has better support
11:22:25 <geekosaur> I haven't seen much that scores high on 3. because everyone's after "just good enough"
11:22:28 <maerwald> if you want support for propellor... there's not even a github issue tracker
11:22:35 <kindaro> I have functions like `a → m [b]`, `b → m Bool` and so on. I want to get a composition of functors `m` and `[ ]` that happens to be a monad.
11:22:47 <maerwald> you sign up for some weird forum where no one ever replies
11:22:50 <ski> if you're looking for a backtracking monad transformer, with fair scheduling, then you could try `logict'
11:22:53 <geekosaur> ( </grump> )
11:23:10 <justsomeguy> I'm pretty disillusioned when it comes to configuration management systems, overall, to be honest.
11:23:30 <ski> kindaro : you want the `b's to be produced incrementally, with `m'-effects interleaved inbetween ?
11:23:44 <maerwald> I replaced propellor with ansible in one company and we never looked back. It was a good decision.
11:24:00 <justsomeguy> Yes, that sounds like a good choice.
11:24:10 <maerwald> Just make sure you don't use 90% of those silly playbooks
11:24:11 <kindaro> I have no preference as to the order of execution, everything will be forced in the end.
11:25:00 <maerwald> (even the "install python" playbooks are mostly broken... )
11:25:09 <maerwald> so geekosaur is pretty much correct :p
11:25:16 <monochrom> logict is probably the CPS-based ListT alternative
11:25:35 <monochrom> err you already know logict
11:27:08 <sm[m]> maerwald these are good points. One plus I found for propellor was that (for a haskeller) it's small and simple enough to understand relatively quickly, unlike all the other config management tools
11:27:22 <maerwald> sm[m]: the types are not easy
11:27:33 <sm[m]> no
11:28:00 <sm[m]> but I was just following the examples
11:28:02 <maerwald> https://hackage.haskell.org/package/propellor-5.12/docs/Propellor-Types-MetaTypes.html#t:DebianLike
11:28:25 <ski> iirc, there may've been some simpler one (without interleaving)
11:29:00 <maerwald> check the IfStuck type family :p
11:30:03 <maerwald> config doesn't need strong types, because you don't need to compile config... you need to *check* it
11:31:05 <maerwald> propellor goes the opposite way and extending the expressivity instead of minimizing it
11:31:18 <maerwald> which I think is the wrong approach for the problem domain
11:33:56 <sm[m]> maerwald: nowadays some would say nixos or nixpkgs is the way
11:34:14 <maerwald> sm[m]: theoretically, if you ignore the bad ergonomics
11:35:18 <sm[m]> it has the same problem as the other tools (big and complicated, big investment required)
11:35:52 <maerwald> it leaks memory, disk space and you need someone with a minimum of 3 years experience to fix any non-trivial nix problems
11:36:14 * geekosaur observes that ansible started out as "the answer" to those problems
11:36:32 <geekosaur> i.e. they come with the territory, it turns out
11:37:18 * hackage reflex-dom-pandoc 0.4.0.0 - Render Pandoc documents to HTML using reflex-dom  https://hackage.haskell.org/package/reflex-dom-pandoc-0.4.0.0 (sridca)
11:37:25 <maerwald> last time I ran nix-env on my pc it locked 6GB of ram doing nothing and then ate 20GB of disk space while it was compiling unrelated GHC versions (8.4.4 or something) until it OOMed out
11:38:38 <maerwald> I don't know why tools keep installing random GHC versions for me
11:39:38 <maerwald> but yes, it's nice in theory :)
11:43:06 <Rembane> maerwald: I think they don't want the installed GHCs to feel lonely. 
11:44:42 <maerwald> and I don't even know how to decrease disk space in nix. I'm scared to touch any of it, because next time it will build for 3 hours again.
11:45:58 <dolio> ski: LogicT doesn't do any fancy interleaving on its own. It's CPS list like monochrom said. The interleaving comes from using different (overloaded) functions.
11:46:04 <geekosaur> supposedly it's open to garbage collection but I've not played with it enough to know how
11:46:22 <dolio> But those could be implemented for list, even.
11:48:58 <dolio> At least, if you mean 'interleaving choice' type stuff.
12:16:19 * hackage exotic-list-monads 1.0.1 - Non-standard monads on lists and non-empty lists  https://hackage.haskell.org/package/exotic-list-monads-1.0.1 (maciejpirog)
13:06:04 <OmegaDoug> Is there a way to catch 'Ctrl-C' on windows when testing code in GHCi? The purpose is to close a socket. I'm using Control.Exception.bracket but when I press Ctrl-C I have to go into the task manager and kill the ghc.exe instance to close the socket.
13:06:05 <OmegaDoug> https://gist.github.com/DouglasBrunner/5bf94447f57db989f9df5b6682a7fdf6
13:08:39 <koz_> OmegaDoug: GHCi isn't the place to test this in.
13:08:53 <koz_> Since I believe it has its own signal handling.
13:10:45 <OmegaDoug84> koz_, a shame since the REPL is nice to use and I jump in and out of it a lot. I don't suppose you happen to know the recommended approach to kill a long running process in GHCi?
13:11:08 <koz_> OmegaDoug84: That's a different question. You want to test signal handling in your program, correct?
13:11:16 <koz_> My answer was 'GHCi isn't the way to do this'.
13:11:29 <koz_> When it  comes to killing long-running processes in GHCi, I dunno.
13:11:49 <OmegaDoug84> Yes. I want to ensure the sockets are released when the program exits. 
13:12:23 <koz_> Yeah, GHCi isn't the place to do this kind of testing. Write an actual test suite.
13:15:06 <koz_> (you are correct in that bracket is a good idea in such a case)
13:16:01 <OmegaDoug84> I'll certainly do that. But for now I'd like to stop leaking resources as I'm developing in the REPL. 
13:16:19 <koz_> Yeah, that's not really gonna happen in GHCi.
13:16:28 <OmegaDoug84> It would be a nicer development experience not to have to consistently kill GHC.
13:16:40 <OmegaDoug84> lol, good to know how far down the rabbit hole I should go ;)
13:17:01 <koz_> Basically, you're at the stage where you should have tests, and be running them regularly.
13:17:12 <koz_> GHCi is good for small scratch stuff.
13:17:26 <koz_> Or asking questions like 'what is the type of this random off-the-wall thing I just thought up'.
13:18:29 <OmegaDoug84> Good advice. What about the runhaskell command? Will that suffer from the same problems that GHCi does?
13:18:56 <koz_> I don't use it, so no idea. Isn't it just a wrapper around 'ghc && ./executable-name'?
13:19:25 <OmegaDoug84> I'll read up on it. I can't remember if it used the compiler or interpreter. 
13:21:09 <OmegaDoug84> koz_, the exception handler gets called using runhaskell. I'll stick with that approach for now. Thanks.
13:21:42 <koz_> OmegaDoug84: Glad that helped. I still 100% suggest writing an actual test suite for this purpose.
13:22:53 <OmegaDoug84> koz_, I'll definitely be doing that. For now I'm just exploring the design space.
13:28:10 <ski> dolio : oic. for some reason my vague memory suggested it did some sort of interleaving "out of the box", with the usual `Monad' and `MonadPlus' operations
14:08:39 <koz_> maerwald: You're the person who deals with ghcup right?
14:09:23 <maerwald> koz_: yes
14:09:41 <koz_> Part of the compilation process for 'ghcup compile ghc' is this: cd bindistprep && "/usr/bin/tar" hcf - -T ../bindist-list.uniq | /usr/bin/xz  -c > ../bindistprep/ghc-8.8.4-x86_64-unknown-linux.tar.xz
14:10:03 <maerwald> yeah
14:10:04 <koz_> Is there a way we can parallelize this step? xz can take a -T argument for parallel cores to use.
14:10:13 <koz_> (-T0 means 'as many as I can')
14:10:27 <koz_> We already feed -j to ghcup compile ghc, so that could be translated in.
14:11:33 <koz_> It's actually quite a long step, and it's _needlessly_ quite long IMHO.
14:11:47 <maerwald> https://gitlab.haskell.org/ghc/ghc/-/blob/master/ghc.mk#L1096
14:12:10 <koz_> Ah, so it's hardwired.
14:12:21 <koz_> So I guess I need to take it up with folks in #GHC?
14:12:25 <maerwald> yeah
14:12:30 <koz_> maerwald: OK, thanks!
14:12:40 <koz_> How do you feed -j12 into the compile process in ghcup?
14:12:45 <koz_> (or -jwhatever, rather)
14:12:52 <maerwald> -j 12
14:13:09 <koz_> Ah, so do you just pass it into GHC's own build system thingo?
14:13:29 <maerwald> `ghcup compile ghc --help` is quite verbose
14:13:37 <maerwald> yeah
14:16:46 <koz_> maerwald: OK, gonna chat to them.
14:35:49 * hackage recursion-schemes 5.2.1 - Representing common recursion patterns as higher-order functions  https://hackage.haskell.org/package/recursion-schemes-5.2.1 (ryanglscott)
14:51:33 <sep2> https://dpaste.org/0jMi I am doing a finite state machine check, for transition function am I on the right path? I'm not sure if I'm understanding it correctly. 
14:55:18 * hackage these-lens 1.0.1.1 - Lenses for These  https://hackage.haskell.org/package/these-lens-1.0.1.1 (phadej)
14:56:18 * hackage these-optics 1.0.1.1 - Optics for These  https://hackage.haskell.org/package/these-optics-1.0.1.1 (phadej)
14:58:18 * hackage strict-lens 0.4.0.1 - Lenses for types in strict package  https://hackage.haskell.org/package/strict-lens-0.4.0.1 (phadej)
14:59:18 * hackage strict-optics 0.4.0.1 - Optics for types in strict package  https://hackage.haskell.org/package/strict-optics-0.4.0.1 (phadej)
14:59:44 <Buntspecht> sep2: Does that code compile for you?
15:04:04 <sep2> I suppose not I was wondering if I had the right idea of going about it
15:07:34 <Buntspecht> sep2: The logic look okay too me, but there's a syntax error at the bottom. If you introduce lokal definitions for a function, you use the "where" keyword
15:07:53 <Buntspecht> Also there's a spurious $ in line 29
15:09:12 <int-e> that looks like a cut-off line actuall
15:10:02 <int-e> And the $ is the 80th character on that line, making that idea more plausible.
15:12:56 <Cheery> I installed LanguageClient to Vim and trying things out. Any idea of what convenient things I can do with this thing?
15:13:25 <Cheery> For example, can I see the stuff for the type holes, and can this thing evaluate things for me?
15:16:04 <maerwald> evaluating selections it cannot do
15:19:37 <Cheery> It shows a cross in the column on the left side, and I'd like to see the whole error message at that point.
15:23:36 <justsomeguy> Is C a weakly typed language?
15:24:24 <maerwald> Cheery: open quickfix window
15:24:53 <justsomeguy> (For context, I'm learning about type systems, and don't know any C, but suspect that it may be weakly typed since I see a lot of errors related to pointers.)
15:26:10 <justsomeguy> I'm actually not sure if this is a productive question to ask. Maybe I shouldn't have. But I thought it would be interesting to hear a Haskellers opinion about it.
15:28:01 <justsomeguy> ...in fact, please just ignore me; I'm about to go for a run, anyways, and this seems like a spicy topic.
15:30:06 <dolio> "Weakly typed" doesn't have any definitive meaning, really.
15:31:48 <justsomeguy> One possible meaning that I've read is that weakly typed means that you can perform operations on a term of some type that is normally not permissible by, for example, an implicit coercion, or acting on it's underlying representation without going through the type system.
15:33:25 <justsomeguy> But it's interesting that you say that -- it seems like a lot of these ideas (about types) are more like general notions than very well defined and agreed on things.
15:34:42 <justsomeguy> (...and even the definition of functional programming seems to be not well agreed on, which kind of surprised me...)
15:35:28 <dolio> Well, there are more precise ideas out there. But the ones used by run of the mill programmers tend to be more intuitive ideas, and not precise.
15:36:15 * justsomeguy is just going to have to read TAPL some day. Scratching the surface by reading a few papers has made him curious about what's out there.
15:38:12 <Cheery> maerwald: I have a quickfix window?
15:38:21 <maerwald> Cheery: yeah, you are a vim user?
15:38:52 <Cheery> maerwald: yup, but lsp is relatively new meet.
15:39:15 <maerwald> you should know about quickfix window and location window then
15:39:49 <maerwald> https://medium.com/@lakshmankumar12/quickfix-and-location-list-in-vim-ca0292ac894d
15:42:35 <dolio> The closest formal thing I can think of that would match "weakly typed" is "unsound." But judging whether C is unsound would require thinking about what a "model" of C is supposed to be.
15:45:18 <justsomeguy> I've heard the term model come up a few times. What is a model?
15:46:25 <dolio> A model is a mathematical structure that can serve as a basis for interpreting what syntactic things 'mean'.
15:47:40 <justsomeguy> Interesting.
15:48:13 * justsomeguy will save the rest of his questions for a web search, since he's about to leave
15:48:24 <justsomeguy> Thanks for humoring my silly questions ^_^
15:50:37 <JohnTalent> What are some decent tools/lib for programming websites in haskell?
15:51:18 * hackage tasty-discover 4.2.2 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-4.2.2 (haskellworks)
15:51:38 <dolio> Anyhow, whether or not C is sound probably depends on what you choose the models to be like, so you're just deciding whether or not you want it to be. If you choose the models to be like, "there's just bits," then it's probably all sound. If integers are not interpreted as the same things as floats which are not the same as structures, then it's probably not sound.
15:52:48 <dolio> "There's just bits" is a lot less useful, though.
16:00:07 <maerwald> JohnTalent: miso
16:10:15 <JohnTalent> maerwald: thank you.
16:10:32 * ski . o O ( progress and preservation, "well-typed programs don't go wrong" )
16:11:25 <JohnTalent> maerwald: firefox reports the examples are a security risk.
17:00:20 <quintasan> Is there any way I could write a function Hasql.Decoders.Result (Int32, Text) -> Tea where Tea is Tea { id :: Int32, name :: Text }? https://hackage.haskell.org/package/hasql-1.4.4.2/docs/Hasql-Decoders.html here are the docs. If my approach is not the correct one then let me know as well because I'm a beginner
17:23:48 * hackage crc 0.1.1.0 - Implements various Cyclic Redundancy Checks (CRC)  https://hackage.haskell.org/package/crc-0.1.1.0 (MichaelXavier)
17:25:48 * hackage crc 0.1.1.1 - Implements various Cyclic Redundancy Checks (CRC)  https://hackage.haskell.org/package/crc-0.1.1.1 (MichaelXavier)
17:34:34 <JohnTalent> sounds like a honeypot.
17:34:44 <sm[m]> JohnTalent: also yesod, IHP, maybe clckwrks
17:35:02 <JohnTalent> sm[m]: yeah, that makes perfect sense in english.
17:35:21 <sm[m]> nobody uses clckwrks but it keeps on ticking, maybe it's good!
17:45:56 <jackdk> quintasan: The key is that the `Result` type has a `Functor` instance. This means you can `fmap` over it. Let me prepare a snippet
17:50:58 <jackdk> quintasan: Here are some examples that may clear things up: https://www.irccloud.com/pastebin/RNBBmdUn/Tea.hs
17:58:58 <quintasan> jackdk: This still gives me Result Tea which... not exactly what I wanted. Hasql uses some weird (to me of course) idea of Encoders and Decoders and I wanted to write a decoder once and reuse it multiple times but it seems that my approach is either incorrect or I'm not good enough
17:59:19 <jackdk> quintasan: Oh I must've misread you sorry
17:59:21 <quintasan> And I'm still having problems with Text vs. [Char]
18:00:20 <ski> jackdk : nitpick, that's using function extensionality, not eta-reduction
18:00:26 <quintasan> jackdk: No worries, I'm trying to build a web application in Haskell coming from Rails so it's kind of frustrating when I can't do simple stuff like writing things to database and getting hashes back
18:00:46 <jackdk> ski: thank you
18:01:08 <ski> function extensionality says that if `f x = g x' for every `x', then `f = g'
18:01:46 <jackdk> makes sense, cheers
18:02:02 <ski> eta-conversion says that `\x -> (...) x' (where `x' doesn't occur (freely) in `...') is equal to `...'. (forward direction is eta-reduction, backward is eta-expansion)
18:02:19 <ski> they're closely related, though. you can prove they're equivalent
18:04:20 <dolio> Sometimes.
18:04:20 <ski> (you could try to prove this, if you want to. it's not terribly complicated. you'll need to know beta-conversion, though, that `(\x -> <body>) <argument>' is equal to `<body>' with all (free) occurances of `x' replaced by `<argument>')
18:05:49 <ski> mm .. i suppose it depends on what ambient theory one has
18:05:59 <jackdk> quintasan: looking at the examples in https://github.com/nikita-volkov/hasql , it looks like Result is passed to the constructor of Statement, and you run Statements using Hasql.Session.statement
18:06:08 <ski> (one'll need some version of congruence as well, i think)
18:06:31 <jackdk> quintasan: then you use Hasql.Session.run to turn a (Session a) and a Connection into IO (Either QueryError a)
18:07:29 <dolio> Yeah. For instance, Agda's "propositional equality" admits eta, but not extensionality.
18:07:31 <jackdk> quintasan: the bottom of the readme on github talks about a hasql-th lib that automatically generates the Statement for you from the SQL string, so that might be a little easier
18:08:08 <dolio> At least in the normal mode.
18:14:31 <ski> dolio : hm, so one can't formalize `f  =  \x -> f x  =  \x -> g x  =  g', then ?
18:15:59 <dolio> There's no way to apply the extensionality hypothesis for the middle step.
18:17:01 <dolio> You basically want to apply both sides to an abstract variable, but there's no way to do that.
18:18:53 <ski> mhm, i see. so it's the congruence step that's problematic
18:18:59 <dolio> Yeah.
18:19:46 <dolio> Congruence holds judgmentally, but has no propositional equivalent.
18:19:54 <ski> is this related to decidability of type-checking ? intensional vs. extensional type theory ?
18:20:04 <dolio> The way to write it propositionally is basically extensionality.
18:20:12 <ski> (i don't think i understand the latter distinction that well)
18:20:36 <dolio> Or, it's extensionality up to eta.
18:21:17 <dolio> Yeah, extensional type theory can do it somehow, because the propositional equalities can be turned back into judgmental equalities.
18:21:48 <ski> yea .. discarding the proof term. which seems like hocus pocus, to me
18:22:27 <ski> (hopefully some version of HoTT will improve on this ?)
18:22:29 <dolio> But, cubical type theory also allows it, basically because it has a mechanism for the variable thing.
18:23:03 <dolio> You can abstract over a 'dimension' to prove the equality, and then you can give a lambda expression which is doing the variable abstraction.
18:23:38 <dolio> I think that might be one of the insights of this paper, too: https://arxiv.org/abs/2008.08533
18:24:15 <ski> oh, is that the square root thing ?
18:25:00 <dolio> It's a generalization of that (apparently) and other stuff. I hadn't heard of the square root thing until this paper.
18:25:13 <ski> (i recall reading about 2-dimensional (directed) type theory (Licata, iirc). thinking i could express some of the things there more nicely, with my notation)
18:25:33 <ski> mhm. ty for the suggestion
18:25:47 <dolio> Also one of the examples is fresh names in nominal logic, which seems like the sort of thing you'd need for this.
18:26:02 <dolio> Or, one possible sort of thing.
18:26:43 <ski> hm. i remember briefly taking a look at nominal logic, at some point, but not quite getting it, or possibly not quite liking it
18:27:15 <dolio> Yeah, I think it's not ideal.
18:27:19 * ski . o O ( lambdaProlog,MacroML,MetaML,MetaOCaml )
18:28:44 <dolio> Like, in this situation you want sort of a 'fresh variable of a type', but the variables in nominal logic aren't typed.
18:30:11 <ski> and it's not entirely straight-forward to make a multi -sorted / -typed version of it ?
18:30:29 <dolio> Well, I don't know. There are other things like that.
18:30:43 <dolio> Like contextual modal type theory.
18:30:59 <ski> mm. that's interesting, i recall
18:31:53 <ski> (relativizing the modality by a context, iirc)
18:34:50 * ski . o O ( "A Combinatorial Theory of Formal Series" (about (combinatorial) species) by André Joyal in 1981 (partial (in-progress) translation by Brent A. Yorgey) at <http://ozark.hendrix.edu/~yorgey/pub/series-formelles.pdf> )
18:36:20 <quintasan> https://github.com/nikita-volkov/hasql-tutorial1/blob/master/library/HasqlTutorial1/Transaction.hs – why is Write and Serializable visible in this file, I don't get it. My module is even simpler (https://pastebin.com/XD1nAVA4) but I'm getting Data constructor not in scope: Write. I'm pretty much sure Write and Serializable come from  https://hackage.haskell.org/package/hasql-transaction-1.0.0.1/docs/Hasql-Transaction-Sessions.html
18:38:22 <dolio> Anyhow, there's definitely work on HoTT-adjacent stuff that has a better story than the proof term just disappearing.
18:38:45 <dolio> That's the sort of thing that makes things undecidable.
18:41:14 <dolio> I actually read a paper a couple days ago about how it's even a problem for constructing models in extensional type theory. Like, even if the extensional type theory is constructive, if you use its features to build a model for another theory, you end up with an uncomputable model.
18:42:05 <dolio> Because the part that needs to be decidable in practice (judgmental equality) gets modelled by the undecidable extensional equality.
18:42:10 <ski> quintasan : tried importing `Hasql.Transaction.Sessions' ?
18:42:53 <ski> dolio : mhm, i see
18:43:31 <quintasan> ski: Yeah, now it's even worse
18:43:47 <quintasan> https://pastebin.com/mZKS16v8
18:45:10 <quintasan> https://pastebin.com/G8M1XsMp without highlighting
18:45:35 <quintasan> I'm having a bad time here, it's either me doing something wrong or the docs being wrong (I think it's the former)
18:46:28 <quintasan> https://gitlab.com/Quintasan/teadb in case anyone wants to inspect what I've done https://gitlab.com/Quintasan/teadb
18:47:22 <ski> quintasan : well .. you seem to be passing four parameters, where only two are expected (as the type error says)
18:48:27 <quintasan> ski: Well... you are probably right but I've tried to do what the documentation tells you to do and I'm stuck :D
18:49:23 <ski> quintasan : where's `insertTeaStatement' ?
18:49:53 <quintasan> ski: src/Statements.hs
18:51:34 <ski> what is `name' ?
18:52:25 <quintasan> name to insert in the database, it's supposed to be plain Text
18:52:46 <ski> what's the type of it ?
18:52:50 <ski> mhm
18:53:43 <ski>   insertTea name = transaction Write Serializable (statement Statements.insertTeaStatement name)
18:54:13 <ski> is probably still not right, i suspect. but perhaps closer
18:54:22 <quintasan> I'm suspecting the tutorial is wrong because https://github.com/nikita-volkov/hasql-tutorial1/blob/master/library/HasqlTutorial1/Transaction.hs has `import Hasql.Transaction` and then calls `statement` and https://hackage.haskell.org/package/hasql-transaction-1.0.0.1/docs/Hasql-Transaction.html says `statement` takes a -> Statement a b -> Transaction b
18:54:36 <ski> oh, sorry, wrong order
18:54:41 <ski>   insertTea name = transaction Serializable Write (statement Statements.insertTeaStatement name)
18:55:11 <ski> yea, that says `statement' only takes two parameters, now four
18:56:21 <quintasan> https://hackage.haskell.org/package/hasql-transaction-1.0.0.1/docs/Hasql-Transaction-Sessions.html has `transaction` which accepts IsolationLevel -> Mode -> Transaction a -> Session a
18:56:25 <quintasan> I'm confused
18:57:18 <Squarism> infinisil, thanks about that existential type trick from yesterday. It was what I needed.
18:57:25 <ski> and `Serializable' (an `IsolationLevel'), and `Write' (a `Mode'), seems like you wanted to feed them to `transaction' (which will also take a `Transaction b' (which is what `statement' will produce, if you feed it an `a', and a `Statement a b', which seems to fit what `insertTeaStatement' is ..), producing a `Session b')
18:58:26 <ski> quintasan : yes. but in your paste(s), you only called `statement', not `transaction'. but you tried to pass `Serializable' and `Write' to the former, not the latter ..
18:58:42 * ski idly wonders what Squarism did with existentials
18:59:19 <Squarism> ski, cheating the type system. What else is there? =D
18:59:46 <quintasan> ski: I'm holding on to provided tutorials for my dear life but at this point it looks to be flat-out wrong - https://github.com/nikita-volkov/hasql-tutorial1/blob/master/library/HasqlTutorial1/Transaction.hs#L42
19:00:05 <Squarism> I guess I could have done wo but it sorta works so I guess I'll settle for that
19:02:23 <ski> Squarism : well, i'm guessing (and guessed before), that the interface has changed, that possibly those two parameters (the `IsolationLevel' and the `Mode') previously was to be passed to `statement', but not longer goes there
19:03:50 <ski> er, sorry
19:03:57 <ski> quintasan : that ^ was meant for you
19:04:22 <ski> Squarism : .. still wondering what you used them for :)
19:09:13 <Squarism> ski, So I had a function. Say foo :: Bar a . Bar had a function that produced values who's type was independent of "a". So I got a bit dissapointed when I realized I had to know "a 
19:09:16 <Squarism> "
19:09:29 <Squarism> upon invocation. 
19:10:32 <ski> `Bar a' being a `data' type, which included a function inside ?
19:10:32 <Squarism> So I did foo :: GenBar. and data GenBar = forall a. Bar => GenBar { val :: a } 
19:11:12 <ski> (if `foo :: Bar a', and `Bar a' is not a type synonym for a function type, then `foo' is not a function, btw)
19:11:24 <ski> hm
19:11:27 <Squarism> oh sorry. foo :: Bar a => a 
19:11:34 <Squarism> Bar was a class
19:11:38 <ski> oh
19:11:43 <ski> and what's the methods of `Bar' ?
19:12:34 <Squarism> well it was gimmeString :: a -> String
19:12:47 <Squarism> sure, a is an argument there. 
19:12:48 <ski> only that ?
19:13:00 <Squarism> I mean, I make it simpler for ease of discussion.
19:13:38 <ski> your `GenBar' expresses/encodes `exists a. Bar a *> a' (i presume you meant `Bar a', not just `Bar' in the definition of `GenBar' ..)
19:13:56 <Squarism> yep
19:14:04 <Squarism> Bar a
19:14:12 <ski> if `Bar a' only has `gimmeString :: a -> String', then `exists a. Bar a *> a' is basically the same as just `String'. so the existential is fairly useless, then
19:14:38 <ski> but perhaps you had some more methods, which perhaps mentioned `a' more than ones ? or perhaps mentioned `a' in return type ?
19:14:50 <ski> s/ones/once/
19:17:46 <Squarism> I tend to confuse myself that classes are like java interface. I forget you have to parameterize all usage of them. a must be bound in scope I guess you say. 
19:20:05 <ski> yea, in an implementation of methods of an interface in Java, you can use `this'
19:20:13 <ski> there is an object, associated with the interface
19:20:18 <dsal> I think java's worse at mentally contaminating people than basic.
19:20:22 <ski> not so, with type classes in Haskell
19:22:14 <quintasan> \o/
19:22:15 <quintasan> I got it
19:23:00 <quintasan> But at what price, it's 4:21
19:23:03 <ski> `Comparable' in Java in Haskell terms would be `exists a. Comparable a *> a', where `Comparable' on the Haskell side would be a type class with a `compareTo :: a -> Object -> Int' method
19:23:37 <ski> or, with the later `Comparable<T>' in Java, in Haskell terms would be `exists a. Comparable a T *> a', where `Comparable a b' on the Haskell side would be a type class with a `compareTo :: a -> b -> Int' method
19:24:52 <Squarism> ski, what is that "exists .." thing called?
19:25:12 <ski> quintasan : hm, i think you might need to find where in the code you're converting from `Transaction' to `Session', and pass `Serializable' and `Write' to the `transaction' call, there ?
19:25:18 <ski> Squarism : existential quantification
19:25:27 <justsomeguy> Describing type classes by comparison with features of other languages is starting to become a pet peeve of mine. ...But whatever helps you learn, I guess.
19:25:47 <ski> (not to be confused with the `ExistentialQuantification' language extension, which, imho, is a misnomer)
19:27:36 * justsomeguy got confused by the java analogy since he didn't know java, and then to decipher how type classes (are like|differ from) interfaces he had to learn what the heck and interface is on top of what a type class is. The most readable description was actually from the haskell language report.
19:27:53 <ski> justsomeguy : iirc, at least last time i looked, traits in Rust were also limited in this way. that is, with neither them, nor interfaces in Java, can you express something like `exists w. Widget w *> Map String w'. iow, they only support encoding `exists x. C x *> x', with the plain existentially quantified variable, after the `*>'
19:28:25 <SirClueless> I have a beginner question I think. On the wiki page for fibonacci numbers they have the following program for generating an infinite sequence of them: `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)`. What I'm trying to understand is whether or not that function recurses an exponential amount of times or a linear amount of times. Or does Haskell not
19:28:25 <SirClueless> make any guarantees either way?
19:29:05 <ski> justsomeguy : yea .. it's not intended that people should go learn Java interfaces, to better understand Haskell type classes. it's just that, often, people already have some idea of Java interfaces, and in that case, it might help a bit, to compare with that, when learning type classes. there are similarities, but there's also differences
19:29:39 <justsomeguy> It seems good for getting an intuition of it, I suppose.
19:30:03 <dsal> I don't think java is good for getting an intuition.  If you have a java intuition, it would help to translate, but it's like any other language translation concept.
19:30:14 <dsal> i.e., idioms don't translate super well
19:30:22 * ski . o O ( "Interface-passing style" by Fare (François-René Rideau) in 2010-02-17 at <https://fare.livejournal.com/155094.html> )
19:30:34 <justsomeguy>  ¯\_(ツ)_/¯
19:30:37 <ski> dsal, yep
19:31:03 <ski> justsomeguy : perhaps not good, but possibly useful, to get into the right ballpark, at least
19:31:42 <ski> Squarism : it's not a function. and, with by-need / lazy evaluation/reduction, it'll run in linear, not exponential, time
19:32:15 <justsomeguy> Sure, as a first step, it seems useful. Then again, the idea of a type class isn't that hard. The description is only two paragraphs in the Haskell language report, and actually readable (not too much jargon).
19:32:32 <ski> (the reason is that the data structure (the list), will act as a cache for the elements of the Fibonacci sequence, not recomputing them)
19:32:50 <justsomeguy> So sometimes I wonder why people bother with the intermediary step of explaining type classes by comparison.
19:33:07 <dsal> The hard thing about a haskell typeclass if you're used to a java interface or go interface or C++ abstract class or something is that you can't have a "Show" value.
19:33:22 <dsal> You'll really want to have a [Show], but you can't do that.
19:33:23 <Squarism> Sorry to stir up such debate. I used to know this, I just went away for a year and lost details. 
19:33:53 <ski> justsomeguy : being able to define your own derived overloaded operations, with (almost) no special care at all to ensure that happening, when calling other overloaded operations, is not something people tend to be used to, from other languages, though
19:34:01 <justsomeguy> Squarism: Hey, no problem. I think of this as a friendly conversation rather than a debate. :)
19:34:38 <Samos> greetings
19:34:39 <justsomeguy> Fair point, ski -- I suppose the main concept takes some getting used to.
19:34:46 <ski> dsal : you can have `[exists a. Show a *> a]' .. but (for `Show'), that's not terribly useful. it's more or less just a more hairy version of `[String]'
19:34:56 <ski> @src elem
19:34:56 <lambdabot> elem x = any (== x)
19:35:10 <ski> well, take this implementation
19:35:13 <SirClueless> @ski so this is a guaranteed part of the Haskell language then, that re-evaluating some early piece of the list will be efficient and not recompute the whole list? I'm just beginning to understand "thunks" so it's hard for me to understand why it's guaranteed by the language, even if it happens in practice
19:35:13 <lambdabot> Maybe you meant: wiki src ask
19:35:32 <ski>   _  `elem` [    ] = False
19:35:42 <ski>   x0 `elem` (x:xs)
19:36:22 <ski>                    = x0 == x
19:36:33 <ski>                   || x0 `elem` xs
19:36:52 <SirClueless> Like, I don't really understand yet how the language can guarantee that, in practice, the millionth fibonacci number is available cheaply when requested and won't be recomputed
19:37:05 <ski> because `(==)' is overloaded (being a method of `Eq'), this `elem' will automagically also be overloaded (requiring `Eq')
19:38:41 <ski> Squarism : "so this is a guaranteed part of the Haskell language then, .." -- no. but it tends to be what implementations do, unless they have any particular reason to deviate from this (such as speculatively evaluating some sub-expressions that're not demanded (yet, at least), since you have some parallel cores available for use, and you think you might need the value soon)
19:39:15 <ski> "thunks" is an implementation method, for implementing lazy / by-need reduction/evaluation
19:39:31 <Squarism> ski, : was that for me?
19:39:46 <SirClueless> That's so scary to me. It's like saying the performance of the evaluation isn't part of the correctness of the evaluation.
19:40:05 <ski> Squarism : yes (not the one about uoverloading, but the two messages after that)
19:40:26 <SirClueless> (I think ski is responding to me sometimes while using your name, Squarism)
19:41:19 <ski> SirClueless : it's something i think all implementations have done by default, unless there's been any clear reason (like optimization) to do otherwise
19:41:52 <ski> oh. hm, yea, i think i managed to refer to the wrong person, in one message above -- sorry about that
19:41:58 <justsomeguy> SirClueless: If you enjoy watching videos, I recommend this explanation of thunks ... https://www.youtube.com/watch?v=j19amq73-qA&list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV&index=26 ; I'm not sure it will satisfy your curiosity, but it should at least give you a taste, and maybe you'll find it fun.
19:43:14 * justsomeguy chides himself for reccomending stuff even though he's a total noob.
19:43:16 <ski> SirClueless : note that the language doesn't specify an operational/procedural semantics, how to get to the answer. it only talks about denotational semantics, what the answer is
19:43:25 <SirClueless> It just seems super scary to say "It's exponential runtime, but in practice on every major Haskell implementation it's linear"
19:43:46 <SirClueless> Like, in my world that's the same as saying "It's broken, but in practice on every major Haskell implementation it's not broken"
19:43:57 <dolio> Maybe you should care about the actual implementation, then..
19:43:59 <dsal> Wait until you learn about optimizing compilers in other languages...
19:43:59 <ski> SirClueless : by-need / lazy reduction/evaluation is an operational semantics concept. and since the language report doesn't talk about operational semantics, it doesn't specify by-need / laziness
19:44:22 <SirClueless> It would be like writing non-portable C code that works everywhere in practice: yeah it's OK for now, but still a bit scary
19:44:51 <dsal> I've written portable C code that runs everywhere.  Except ARM where it segfaults.
19:45:26 <SirClueless> Exponential vs. Linear Time isn't just operational semantics though: getting the result of Fibonacci in exponential time is just as bad as getting the wrong result from Fibonacci, in pretty much every computation environment I've ever been in
19:45:53 <ski> (and ditto for talking about time or space complexity. those are operational semantics concepts, and the report doesn't talk about that)
19:46:19 <SirClueless> Like if it was in a batch process in a data center it would take arbitrary resources, or if it was computed in response to a request to a server, it would timeout
19:46:32 <SirClueless> And not being able to make any guarantees about that stuff is scary
19:47:03 <ski> (perhaps one could argue that it ought to talk some about it. e.g. to specify "proper tail recursion" (another misnomer, since it doesn't have to do with recursion, per se), which is a space complexity thing (unbounded number of active tail calls in bounded space))
19:47:12 <dsal> I think, in practice, you wouldn't use that implementation of fibs as a list of all fibs in a real program.  In practice, you write the code that does what you want, and if it can't do it to your efficiency requirements, you change the parts that need to be optimized.  Refactoring is super easy in haskell.
19:48:15 <SirClueless> ski Yeah, tail recursion is another important one. Lots of languages end up *requiring* tail recursion as a result, because in practice it affects correctness even if you are a pure functional language for all formal purposes
19:48:35 <ski> GHC tends to try to not apply "optimizations" which worsen space or time complexity
19:49:03 <dsal> tail recursion is a "how" rather than a "what"
19:49:09 <ski> yes
19:49:30 <SirClueless> Sure, but it doesn't make guarantees that it *will* make certain optimizations, you just have to assume when it will or not
19:49:43 <ski> (e.g. CSE can cause worse space usage, so GHC doesn't do much of it)
19:50:15 <SirClueless> Whether or not you have tail recursion means that certain computations will either complete successfully in a reasonable amount of memory, or blow the stack of every machine ever produced
19:50:55 <SirClueless> Sure it's just "how" not "what" but at some point "how" becomes "this is no longer computable" and every software engineer in existence has to start caring
19:51:01 <ski> i think, as a first approximation, it's quite safe to assume that GHC does by-need / lazy reduction. one can also think of this as graph reduction (with e.g. shared nodes caching results)
19:51:38 <ski> iirc PFDS' analysis of algorithms take this into account
19:51:43 <ski> @where PFDS
19:51:43 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
19:52:45 <ski> anyway, even with "proper tail recursion" (which is what Scheme calls it), that doesn't exactly mandate how you'll implement it. it doesn't have to be TCO, e.g. ..
19:54:16 <dolio> Yeah, scheme just says it's bounded, right?
19:54:58 <ski> yep
19:55:15 <ski> must support an unbounded number of active tail calls in bounded space
19:55:39 <dolio> Bounded by what?
19:57:38 <dolio> Doesn't seem like it says.
19:59:34 <ski> iirc, Chicken just uses the C stack, with CPS code, making it ever deeper, never returning in C, instead GCing the "stack" (which acts like a heap), compacting it, when necessary
20:00:11 <SirClueless> I guess I'm too much of a systems programmer to enjoy Haskell :D  "You can assume the graph is reduced in a reasonably efficient way" is missing an axis of correctness that matters to me just as much as actually delivering the correct result of the computation
20:00:19 * ski . o O ( "CONS Should Not CONS Its Arguments, Part II: Cheney on the M.T.A." by Henry G. Baker in 1995-09 at <https://web.archive.org/web/20200223051632/http://home.pipeline.com:80/~hbaker1/CheneyMTA.html> )
20:01:07 <ski> (and, MIT Scheme remembers the last 100 calls (including tail calls), for debugging purposes)
20:02:05 <dolio> If you care about performance, then implementation details matter, not just the language specification.
20:02:53 <quintasan> holy smokes
20:03:06 <quintasan> I think I'm starting to get it but at the same time I'm not getting it
20:03:31 * ski . o O ( "PCLSRing: Keeping Process State Modular" by Alan Bawden at <http://fare.tunes.org/tmp/emergent/pclsr.htm> ; <https://en.wikipedia.org/wiki/PCLSRing> ; "PCLSRING in Semantics" by Robert Harper in 2016-07-11 at <https://existentialtype.wordpress.com/tag/pclsring/> )
20:03:35 <SirClueless> ^^ Well sure, but for example, using a language whose definition is "it must behave the same as this abstract machine defined here" which is how C or C++ work, means that unless the implementation expands primitive machine ops into non-constant evaluations, you can make guarantees about runtime
20:04:40 <quintasan> If I get IO (Int32, Text) and have a record Tea then I can - `fmap (uncurry Tea) $ functionThatGivesIO`. How do I do this for IO [(Int32, Text)] to get IO [Tea]?
20:05:37 <koz_> quintasan: You fmap twice.
20:06:02 <dolio> I don't believe that C and C++ specify enough in the language specification to guarantee good performance.
20:06:29 <koz_> dolio: Since UB is a thing, they _can't_.
20:07:03 <quintasan> wait, so I just fmap . fmap (uncurry Tea) $ functionThatGivesIOArray ?
20:07:13 <koz_> quintasan: Not quite.
20:07:26 <koz_> But you're on the right track.
20:07:30 <koz_> Consider the type of fmap:
20:07:32 <koz_> :t fmap
20:07:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:07:50 * ski . o O ( "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <https://www.microsoft.com/en-us/research/publication/exceptional-syntax/>,<http://lambda-the-ultimate.org/node/1193>,.. )
20:07:50 <koz_> Now, if f ~ IO, you get (a -> b) -> IO a -> IO b
20:07:59 * ski . o O ( ..,<https://web.archive.org/web/20161027043544/http://mjambon.com/extend-ocaml-syntax.html#lettry>,<https://blog.janestreet.com/pattern-matching-and-exception-handling-unite/> )
20:08:22 <SirClueless> koz_ they can't guarantee runtime of programs that contain UB, for sure, but other programs they might be able to (with a lot of assumptions about the machine you're executing on)
20:08:27 <koz_> Now, in your case, a ~ [(In32, Text)], and the b you want is [Tea].
20:08:32 <koz_> SirClueless: There's also IB.
20:08:45 <koz_> So no, even if we assume no UB, the standard cannot guarantee very much at all.
20:08:55 <koz_> s/In32/Int32/
20:09:06 <koz_> So therefore, your function has to have that type.
20:09:19 <koz_> Now, you have something that types that way - fmap (uncurry Tea).
20:09:19 <quintasan> So ideally I'd write a function for [(Int32, Text)] -> [Tea] and fmap this?
20:09:27 <koz_> You can, but in this case, you don't need to.
20:09:45 <koz_> You would have fmap (fmap (uncurry Tea)).
20:10:23 <ski> quintasan : `fmap (map (uncurry Tea)) actionThatGivesIOList',`(fmap . map) (uncurry Tea) actionThatGivesIOList',`(fmap . map . uncurry) Tea actionThatGivesIOList',`map (uncurry Tea) <$> actionThatGivesIOList',`(uncurry Tea <$>) <$> actionThatGivesIOList'
20:10:50 <koz_> That last one is a step too far IMHO.
20:11:10 <SirClueless> It sounds like they can guarantee more than Haskell can though -- if only because they can't really express lazy evaluation and whether or not its result is immediately available
20:11:29 <quintasan> I still have no idea what <$> and <*> do but I decided that won't stop me from making this work.
20:11:41 <koz_> quintasan: <$> is just infix fmap.
20:11:43 <quintasan> koz_, ski: thanks
20:12:34 <koz_> SirClueless: I don't know how much you could guarantee about the performance of a C program given the standard.
20:12:42 <koz_> You first must ensure that neither IB nor UB applies.
20:13:15 <koz_> Then after that point, you gotta deal with the fact that the standard makes few promises about, say, type widths.
20:13:26 <koz_> Which might _significantly_ alter, for instance, how many times a loop will execute.
20:14:15 <koz_> There's probably _thousands_ of other small things there too.
20:15:05 <koz_> Maybe it's _different_ to the Haskell case, but 'more'? I doubt it.
20:15:15 <ski> SirClueless : those last links were about interaction of tail calls with exception handlers (not having the dynamic extent of the handler include the tail call)
20:15:33 <ski> this suggests it may be a good idea, having `catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b)' / `handleBind :: Exception e => (e -> IO b) -> (a -> IO b) -> (IO a -> IO b)', and not just `catch :: Exception e => IO a -> (e -> IO a) -> IO a',`handle :: Exception e => (e -> IO a) -> (IO a -> IO a)',`try :: Exception e => IO a -> IO (Either e a)'
20:18:35 <ski> (and perhaps some custom syntax for this, like the `let'-`try' above, which OCaml now supports as pattern-matching <https://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html#s%3Aexceptions>)
20:19:30 <SirClueless> Maybe I just already understand all the tradeoffs in C better? Like, I can't think of any way to sneak exponential runtime into a C program -- it would take some *very* obscure interactions. But you can certainly sneak some UB into a C program and that's perhaps worse.
20:22:08 * ski . o O ( "A Guide to Undefined Behavior in C and C++" by John Regehr, "Part 1" in 2010-07-09 at <https://blog.regehr.org/archives/213>,"Part 2" in 2010-07-23 at <https://blog.regehr.org/archives/226>,"Part 3" in 2010-07-30 at <https://blog.regehr.org/archives/232> )
20:22:50 <koz_> SirClueless: Do you understand C-as-the-standard-calls-it? Or C-as-your-favourite-compiler-implements-it?
20:22:56 <koz_> Those may, or may not, be the same thing.
20:24:00 <SirClueless> I try, as far as possible, to understand C (and more often C++) as the standard guarantees it. Obviously the C++ standard is like 10k pages or something stupid so there's no way to claim I understand it all.
20:25:36 <c_wraith> The standard guarantees so little in C.  I don't think it's actually possible to write non-trivial code that's portable across all spec-compliant C compilers.
20:25:52 <SirClueless> But there are ways to guarantee some things even in standard C++ that you can't really in Haskell afaict. For example the ability to interpret bytes in an IO device DMA buffer as data without any copying.
20:25:59 <koz_> c_wraith: I remember that one C99 draft made memmove impossible to write.
20:27:20 <c_wraith> SirClueless: sure you can...  but it's going to be awkward to use because Haskell forces you to understand that the backing bytes could change at any time.
20:29:22 <SirClueless> Yes, but using C++ allows you to rely on memory guarantees provided by the device itself. FWIW C++ forces you to understand too that backing bytes can change at any time (it's just less strict about writing programs that fail to acknowledge that fact). This is basically the purpose of the volatile keyword.
20:29:40 <c_wraith> right.  The point of Haskell is that you can't fail to acknowledge it.
20:30:35 <dolio> DMA of an IO device is in the C++ standard?
20:33:29 <SirClueless> Yes. In that there are standard-compliant ways that a device vendor can provide you with a buffer that you can use in productive ways. When you do that you rely on the standard, the linux kernel, the x64 ISA, a certain pointer addressing mechanism, etc. but that's all stuff that's well defined even if it's not portable.
20:35:56 <dolio> So that's actually a no.
20:36:24 <SirClueless> When you write a load from a memory address provided by an IO device's driver with a volatile keyword qualifier, the standard defines what kinds of bytes you will and will not access, and the ordering of that load with respect to the other statements in your program. In that sense the standard defines reading a DMA buffer.
20:37:02 <c_wraith> The standard tells you that you can read from a pointer.  It doesn't say anything about DMA
20:37:35 <c_wraith> (of course, you can only read from *some* pointers.  It's not clear how the driver generates that pointer and whether it's valid according to the spec)
20:39:20 <SirClueless> It tells you it will read exactly once and with well-defined ordering with respect to reading any other volatile memory addresses. That's enough to implement interoperating with a DMA buffer.
20:40:18 <c_wraith> You seem to have ignored the provenance of the pointer.  the standard says a lot about when reading from a pointer is defined and when it isn't.  I sincerely doubt that the way the pointer is acquired is standard-compliant.
20:40:38 <c_wraith> (The OS may guarantee it's fine, but that's not the same as the spec)
20:40:47 <koz_> I'm also unsure that you get a well-defined ordering across multiple volatile variables this way.
20:41:01 <koz_> (I'm open to being proved wrong here, but I don't think the standard goes quite that far)
20:41:03 <koz_> (at least not in C)
20:41:36 <SirClueless> I'm not sure I follow. If it's implementation-defined by the standard, and the OS guarantees certain behavior, then it's well-defined access.
20:42:14 <koz_> SirClueless: 'Implementation-defined' translates to 'read your compiler docs'.
20:42:22 <dolio> You mean like how the Haskell specification has implementation defined behavior, so you need to ask about the implementation you're using?
20:42:24 <koz_> The OS's guarantees may or may not matter.
20:42:44 <SirClueless> And it does provide some number of guarantees of ordering. Basically using the concept of "sequence points" as defined in the C abstract machine and the ability (or inability) of a compliant implementation to reorder certain loads and stores over sequence points.
20:43:17 <koz_> SirClueless: So I guess we're talking C11, since before that, there's no memory model.
20:45:14 <SirClueless> Well, technically even before that there were guarantees about some kinds of ordering. And compilers would in practice make guarantees like "we won't reorder around inline assembly" giving you a non-portable backdoor into your ISA's memory barrier instructions to try and do the right thing (inasmuch as that was possible).
20:45:17 <koz_> "What  constitutes  an  access  to  an  object  thathas volatile-qualified type is implementation-defined." bodes well...
20:46:22 <SirClueless> Yeah, it was a crappy landscape for a long time. Recently things have gotten better (in C++ especially) with various flavors of standard-defined atomic data types.
20:52:22 <SirClueless> Anyways, I think it's interesting to discuss these things. Thanks for taking the time to go back and forth with me! I think there are a lot of interesting tradeoffs to make: In C you can write a type-checking program that blows up because you wrote a[n] for too large n. In Haskell you can write a type-checking program that blows up because you
20:52:23 <SirClueless> wrote `rfold` when you meant `lfold`. Ain't software fun.
20:53:26 <koz_> SirClueless: Those are different notions of 'blowing up' though.
20:53:36 <koz_> Former is 'the compiler can emit code that erases your hard drive'.
20:53:45 <koz_> Latter is 'if you don't have hilarious RAM you'll OOM'.
20:53:55 <koz_> Those aren't even in the same _universe_.
20:56:37 <SirClueless> That's where we disagree at a philosophical level, I suppose. Both of them could equally bring down a server.
20:58:02 <koz_> ... you're seriously saying that 'your server now lost all its data forever' is in the same ballpark as 'one program on said server crashed to OOM'?
20:58:45 <SirClueless> There are some differences to be sure: the former is much more likely than the latter to end in an attacker having control of your network. But both are stop-the-world disasters in the right context.
20:59:06 <koz_> 'In the right context' almost anything is anything.
20:59:26 <koz_> I'd say, in general, UB creates issues of far worse gore than laziness will ever afflict you with.
20:59:35 <SirClueless> Sure, the context for me is writing high-availability network services.
21:00:07 <koz_> It sure is great for availability when you've had your entire non-volatile storage nuked.
21:00:11 <koz_> Or your passwords dumped.
21:00:52 <SirClueless> Yeah, that's a memory-safety problem. Utterly terrifying for C programs, a non-issue for Haskell programs.
21:01:03 <SirClueless> But DoS vectors are problems for both.
21:02:51 <koz_> Denial-of-service can also be done by attacking the hosting architecture, irrespective of what you wrote in or with.
21:03:07 <koz_> (in fact, I believe that's where it commonly arises, unless we're talking like, hash flooding or something)
21:08:10 <SirClueless> The malicious kinds, yeah, probably. The kinds that are more like "2% of our RPC calls timeout because the host dies" and you go and investigate the machines where it happens and it turns out there's a legitimate use case for requesting 10000 records at a time from your service and somewhere in the network stack someone wrote an O(n^2) linear scan
21:08:10 <SirClueless> routine that they never expected to be exercised like this and now needs to be rearchitected
21:09:30 <koz_> But this isn't really unique to Haskell. No language will prevent you writing a quadratic scan.
21:09:39 <koz_> I don't think laziness makes it any more likely.
21:12:12 <SirClueless> So far I'm not experienced enough to say. Having made multiple "d'oh" style performance flubs like that in my limited time trying out Haskell it does seem somewhat more likely. Less to do with lazy evaluation I think and more to do with super concise ways of abstracting control flow. But I admit I'm not really giving Haskell a fair shot due to my
21:12:12 <SirClueless> inexperience.
21:51:49 <koz_> Yeah, there's things to watch out for there, definitely.
22:04:28 <dsal> In practice, I write more correct and useful code in haskell than I ever did in C, even though (and likely because) I can't pay huge attention to all the implementation details all the time.
22:09:40 <dsal> optparse-applicative started doing this useful thing recently, it seems. https://www.irccloud.com/pastebin/CTguX34u/
23:13:42 <Squarism> I often fall into this situation I want to shove a bunch of parameterized types into a big datastructure and foreget their types and then want to pick out values from the big structure and reconstruct their types. I gathered that this is not "right". Are there any "ugly tricks" you can use to atleast save the type info to be able to restore the values to their correct type?
23:14:58 <dsal> I've never needed to lose a type in Haskell code.  It's not clear to me what pattern you're referring to.
23:15:21 <MarcelineVQ> yeah, don't forget their types. but you can google existential antipattern for some techniques
23:30:35 <jackdk> do you have a concrete instance of where you want this? Often it's a problem-solving impulse from other experience that doesn't work so well in Haskell
23:37:23 <Squarism> jackdk, I have this idea atm : https://paste.ofcode.org/TGvEbepNQbjtWRqKzgkgkd
23:39:28 <Squarism> In this case I want to be able to traverse an SType and determine the type of the list. That should be any of the "data P..." types
23:54:02 <dsal> What do you want to do with the type?
23:54:33 <dsal> I keep thinking you're bumping up against optics, but I don't fully understand your intention.
23:56:28 <dsal> The P types don't seem to be doing anything of value here.  You can already disambiguate with the S constructor.
23:58:08 <dsal> Do you mean `SList` should be `SList [SType]` ?
