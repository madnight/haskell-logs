00:57:49 * hackage ukrainian-phonetics-basic 0.1.5.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.5.0 (OleksandrZhabenko)
01:08:20 * hackage stack-clean-old 0.2 - Clean away old stack build artefacts  https://hackage.haskell.org/package/stack-clean-old-0.2 (JensPetersen)
02:06:19 * hackage lorentz 0.7.0 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.7.0 (gromak)
02:07:19 * hackage hie-compat 0.1.0.0 - HIE files for GHC 8.6 and other HIE file backports  https://hackage.haskell.org/package/hie-compat-0.1.0.0 (wz1000)
02:09:20 <gentauro> with PRAGMAs like: `{-# Language DerivingVia #-}` taken from https://old.reddit.com/r/haskell/comments/jibgfe/validpreorder_ord_aa_bool/ga5jalm/ will that not make it more complicated for newcomers to understand how to code in Haskell?
02:10:36 <gentauro> and would such a PRAGMA be part of the GHC20xx (global) PRAGMA? https://github.com/ghc-proposals/ghc-proposals/pull/372
02:52:33 <siggard> Hello. I come to you from iOS dev world and started studing Haskell with book "Learn You a Haskell for Great Good!". Before that I played a bit with Scala and did that basic Scala course by Martin Odersky.
02:53:13 <siggard> There is no slack channel nor gitter for Haskell community, isn't it? :-)
02:55:02 <merijn> I'm sure someone has made something like that at some point
02:55:21 <merijn> tbh, LYAH isn't a particularly great book
02:55:56 <Zetagon> there is a functional programming zulip
02:57:36 <siggard> merijn: What would you recommen for someone who has programmed in object oriented environment for last 10 years? :-)
02:58:58 <merijn> There's "Programming in Haskell" by Graham Hutton, "Thinking Functionally with Haskell" by Richard Bird and of course https://haskellbook.com/
02:58:58 <Cale> siggard: I often recommend "Programming in Haskell" by Graham Hutton as a good intro.
02:59:26 <merijn> siggard: The problem with LYAH is: It's not greatly structured, glosses over some details, and has no exercises (and kinda dated)
02:59:40 <Rembane> It has cute images though
02:59:48 <merijn> So the end result is that LYAH is great at "showing you cool things", but not so great in preparing you to "write actual code that does something"
03:00:11 <merijn> LYAH is importance/relevance is mostly historical
03:00:26 <merijn> In that it came out when there wasn't that much written about Haskell that was accessible
03:00:42 <Zetagon> I like https://www.seas.upenn.edu/~cis194/spring13/lectures.html . I'm not sure how good the introduction is because I didn't read it, but I like the last few parts
03:01:04 <merijn> And helped start (well, fuel, maybe?) the semi-mainstream popularity of Haskell
03:01:47 <merijn> I remember it coming out and the only other text I could find was the infamous tutorial :p
03:02:01 <merijn> @quote Brend whoever.named
03:02:01 <lambdabot> No quotes match. Are you on drugs?
03:02:03 <merijn> aww
03:02:23 <merijn> @quote Brend
03:02:24 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
03:06:55 <siggard> Thanks people. I will take a look on your recommendations. :-) Zetagon thanks, it looks like this course is from 2013 but there are homeworks so maybe it'll be easier to follow. Thanks!
03:07:18 <siggard> merijn: "infamous tutorial"? ;-) 
03:07:33 <Zetagon> siggard: I particularily like the functor homeworks
03:11:28 <siggard> Cale: looks like i have that Haskell Book in my emoyer's library. But it's in PDF only which makes it hard to read on Kindle. :D 
03:11:41 <siggard> But you think it's worth it, right? 
03:13:03 <merijn> siggard: See the above quote :p
03:13:22 <merijn> siggard: There's an e-reader PDF version too, iirc
03:23:13 <ulidtko> does Cabal's build-type: Simple support distributing custom files?
03:24:01 <dcoutts__> ulidtko: do you mean installing extra files, or just including extra files into the source tarball?
03:24:07 <ulidtko> I can see there're apis like installOrdinaryFile in Distribution.Simple.Utils, but not sure how to use that
03:24:16 <ulidtko> dcoutts__, the former, installing
03:24:43 <dcoutts__> ulidtko: no it just supports installing header files I think
03:25:01 <merijn> You can install data files
03:25:19 <merijn> So it depends exactly what these files are for
03:25:19 <dcoutts__> oh yes, and data files
03:25:32 <ulidtko> exactly, data files is what i need
03:25:41 <ulidtko> any guide links?..
03:26:51 <merijn> ulidtko: https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code
03:27:21 <ulidtko> merijn, thank you
03:27:39 <merijn> ulidtko: and https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-data-files
04:02:49 * hackage reanimate 1.1.2.1 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-1.1.2.1 (DavidHimmelstrup)
04:38:19 * hackage morley 1.8.1 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.8.1 (gromak)
04:38:24 <__monty__> I think arian was talking about the original issue, i.e., they don't exist after just building the expression.
04:38:37 <__monty__> Whoops, wrong chan.
04:39:49 * hackage indigo 0.3.1 - Convenient imperative eDSL over Lorentz.  https://hackage.haskell.org/package/indigo-0.3.1 (gromak)
04:41:44 <dminuoso> Are there QQs for ghc-lib-parser, to generate AST fragments from?
04:42:03 <dminuoso> (Say via TH Exp?)
05:45:06 <Raito_Bezarius> is it a good idea to use Alex & Megaparsec together?
05:45:47 <Raito_Bezarius> I'm trying to write a parser for programming language which requires to add automatically semicolon to the end of certain lexemes, I'm not sure megaparsec is built to handle this by itself
05:45:52 <dminuoso> It can be sensible, sure
05:46:53 <dminuoso> Raito_Bezarius: You can trivially do this yourself
05:47:21 <Raito_Bezarius> using megaparsec?
05:47:29 <dminuoso> Sure
05:47:39 <dminuoso> lexeme spc p = p <* spc
05:47:41 <Raito_Bezarius> Is there any pointer to where should I look in the megaparsec docs?
05:47:47 <dminuoso> lexemeSemi spc p = p <* semi <* spc
05:47:50 <dminuoso> Done
05:47:57 <Raito_Bezarius> ha
05:48:27 <dminuoso> (Note that the first definition is already defined in megaparsec, I just included it for reference)
05:48:28 <Raito_Bezarius> well, I'll read more the docs until I understand why is it enough/trivial enough
05:48:35 <Raito_Bezarius> but like
05:48:42 <dminuoso> lexing and parsing are really the same thing. :)
05:48:42 <Raito_Bezarius> if I want to add a semicolon to a lexeme if only it's a certain lexeme
05:48:48 <Raito_Bezarius> I can just really chain lexeme & lexemeSemi ?
05:48:56 <dminuoso> Raito_Bezarius: Yes, that's why you use both lexeme and lexemeSemi
05:48:59 <dminuoso> For example:
05:49:34 <dminuoso> say you have:
05:49:44 <dminuoso> lexemeSemi = p <* semi <* spc
05:49:48 <dminuoso> Where spc is your space consumer
05:49:50 <dminuoso> Then you can define
05:50:00 <dminuoso> err
05:50:04 <dminuoso> lexemeSemi p = p <* semi <* spc
05:50:14 <dminuoso> foo = lexemeSemi (string "foo")
05:50:21 <dminuoso> which would lex `foo;` plus leading whitespace
05:50:26 <dminuoso> (or trailing I guess)
05:50:32 <Raito_Bezarius> yes
05:50:39 <Raito_Bezarius> now if I give foo; can I still get foo; without error?
05:50:50 <dminuoso> "get foo; without error"?
05:50:52 <Raito_Bezarius> sorry
05:50:57 <Raito_Bezarius> if I give as input `foo;`
05:51:03 <Raito_Bezarius> can I still make it so it lex to `foo;`
05:51:05 <geekosaur> I think Raito_Bezarius wants the opposite of what you're providing
05:51:11 <Raito_Bezarius> I want both
05:51:20 <Raito_Bezarius> I want semicolon to be automatically added when it's relevant
05:51:21 <geekosaur> insert a virtual semicolon after some lexemes, but allow it to be explicit as well
05:51:27 <dminuoso> ahh
05:51:33 <Raito_Bezarius> something like lexemeSemi (string "foo") <|> lexeme (string "foo;") or something like this
05:51:37 <dminuoso> Well, I'd just get rid of it in the parser
05:51:41 <dminuoso> or lexer
05:51:52 <dminuoso> I see
05:51:58 <dminuoso> You can make the semi optional
05:52:05 <dminuoso> lexemeSemi p = p <* optional semi <* spc
05:52:25 <Raito_Bezarius> but then, this separator won't always appear right?
05:52:33 <dminuoso> what do you mean by separator?
05:52:36 <Raito_Bezarius> the ;
05:52:40 <Raito_Bezarius> it will lex as foo or foo;
05:52:41 <Raito_Bezarius> right?
05:52:49 <dminuoso> Raito_Bezarius: What do you mean with "lex as"?
05:52:54 <dminuoso> It will *consume* both
05:53:19 <Raito_Bezarius> I mean, my grammar assumes that those semicolons always appear
05:53:53 <Raito_Bezarius> so the parser will expect semicolons for certain rules, but without automatically adding them explicitly, the rules will fail
05:54:04 <dminuoso> Im not quite sure what "adding" even means?
05:54:15 <dminuoso> We're in a parser, we dont generate a string, we consume it
05:54:17 <Raito_Bezarius> in this case, I'm looking at Julia
05:54:30 <Raito_Bezarius> if I have, `while foo end`
05:54:44 <Raito_Bezarius> it should appear as `while foo end;`
05:54:50 <dminuoso> what do you mean by "appear"?
05:55:18 <dminuoso> A parser usually transforms `while foo end;` into some concrete or abstract syntax tree
05:55:23 <Raito_Bezarius> Yes
05:55:30 <Raito_Bezarius> Hm, maybe I am creating a XY problem or something
05:56:38 <Raito_Bezarius> dminuoso: thanks for the ideas, I'll try to go for implementation first and expose the precise problem when I encounter it
05:56:40 <Raito_Bezarius> That was very helpful
05:56:41 <geekosaur> if you want to parse something and then prettyprint it, just have the prettyprinter always print the semicolons while rendering the AST back into text
05:56:55 <Raito_Bezarius> I'm not in the prettyprint phase though I plan to do so
05:57:08 <Raito_Bezarius> I was rather adapting a set of rules from a grammar into megaparsec parsing code
05:57:21 <Raito_Bezarius> and the set of rules expects semicolon because the lexical analysis suggests to automatically add them
05:57:24 <dminuoso> Raito_Bezarius: So this is where things can very very quickly become complicated.
05:57:38 <dminuoso> Do you need to preserve the exact input?
05:57:42 <Raito_Bezarius> No I do not need
05:58:01 <Raito_Bezarius> I didn't want to go for custom lexer code because I wanted to benefit from megaparsec source position stuff
05:58:10 <dminuoso> Raito_Bezarius: Okay. I think there may be some confusion here of what the output of a parser really is
05:58:19 <Raito_Bezarius> I want to output an AST right now
05:58:34 <Raito_Bezarius> I have an AST in terms of data
05:58:35 <dminuoso> Raito_Bezarius: Do you represent semicolons in that AST?
05:58:41 <Raito_Bezarius> No, so I can just discard them
05:58:54 <Raito_Bezarius> But I was afraid of stuff like ambiguous things in the grammar
06:05:31 <Raito_Bezarius> maybe stupid question, I'm trying to have "some digitChar" but I cannot because "Illegal equational constraint Token s ~ Char", should I just enable TypeFamilies or GADTs?
06:05:38 <Raito_Bezarius> or am I doing something wrong?
06:05:44 <Raito_Bezarius> integer = some digitChar <?> "an integer"
06:07:30 <dminuoso> Raito_Bezarius: What's the type signature of integer?
06:07:54 <dminuoso> Or.. that error mmm
06:08:00 <dminuoso> Which ghc are you using?
06:08:15 <Raito_Bezarius> I want something like (MonadParsec m, …) => m [Char]
06:08:17 <Raito_Bezarius> GHC8 dminuoso 
06:08:23 <Raito_Bezarius> 8.10
06:08:58 <Raito_Bezarius> enabling GADT made it work
06:10:16 <dminuoso> It's possible this is due to some changes in 8.10
06:10:44 <dminuoso> "GHC now performs more validity checks on inferred type signatures."
06:10:49 <dminuoso> That's very non-descript.
06:10:56 <dminuoso> But Im guessing that's why
06:11:38 <geekosaur> this might be worth asking haskell-cafe about, if it's affecting random Megaparsec parsers then it might be surprising to a bunch of people
06:11:58 <geekosaur> lthough 8.10 has been out for a while now so it should have already caused an uproar, hm
06:12:39 <Raito_Bezarius> Well, I'm okay with enabling type families or GADT meanwhile
06:13:50 <geekosaur> I'm kinda not so comfortable with it tbh. Megaparsec seems a strange place for a hidden dependency on GADTs to arise
06:14:35 <Raito_Bezarius> Could one of you verify in a REPL I'm not saying stupid things?
06:14:48 <Raito_Bezarius> I just imported a bunch of megaparsec classic things, everything is built-in
06:14:49 <dminuoso> Raito_Bezarius: Im very sure this is why.
06:14:52 <merijn> dminuoso: I think it's basically like before where GHC would infer types that required extensions that weren't enabled
06:15:08 <merijn> And then when it (correctly) demanded those extensions be enabled, stuff broke
06:15:12 <dminuoso> Raito_Bezarius: The release notes even lists a similar example, albeit with a different extension.
06:15:20 <Raito_Bezarius> Fair enough
06:15:31 <dminuoso> merijn: Oh because it affected the semantics of other code?
06:15:36 <dminuoso> Like ScopedTypeVariables?
06:16:12 <merijn> dminuoso: No, stuff like, if you left out a type signature and GHC inferred one that used MultiParamTypeclasses, then it would allow the inferred type *even* if MPTC wasn't enabled
06:16:16 <merijn> Which is, of course, wrong
06:16:24 <dminuoso> (Say because you're doing something like `(\(e :: FooException) -> ...)`, then enabling ScopedTypeVariables could actually alter the meaning in other places where if you have ExplicitForAll
06:16:43 <dminuoso> mmm
06:17:01 <merijn> So it used to allow types with extensions that weren't enabled *iff* the types were inferred, which is a bug, but one you can accidentally rely on
06:17:50 <dminuoso> merijn: I cant even fathom what kind of engineering complexity language extensions brings with them because you have precisely this kind of cross-module friction.
06:18:25 <merijn> So it looks like, in Raito_Bezarius's example is that due to the lack of type signature, the inferred type has megaparsec Token constraint, which uses type families, but type families isn't enabled in his code
06:18:31 <dminuoso> merijn: Right.
06:18:40 <merijn> So writing out a non-polymorphic type would *also* fix the issue
06:18:42 <dminuoso> merijn: Im just saying the release note could have explained this better
06:18:45 <Raito_Bezarius> merijn: I see
06:18:45 <dminuoso> I *assumed* what you said
06:19:15 <merijn> Raito_Bezarius: If you write out a specific type, then the constraint is already solved and the extension unneeded
06:19:16 <dminuoso> I sometimes wish, GHC would roll out such things with deprecation notices
06:19:17 <dminuoso> like
06:19:24 <dminuoso> "This is going to fail in a future GHC"
06:19:30 <merijn> dminuoso: Where do you draw the line, though?
06:19:41 <merijn> Does every bugfix need a deprecation warning?
06:19:56 <merijn> dminuoso: See the endless discussion on the TH change I got temporarily rolled back in 8.10
06:20:02 <dminuoso> Which TH change?
06:21:10 <merijn> That typeclass constraint (incorrectly) are allowed to violate the staging/splicing rules
06:21:15 <merijn> https://gitlab.haskell.org/ghc/ghc/-/issues/17816
06:22:28 <dminuoso> merijn: Perhaps GHC releases should be tested against stackage.
06:22:33 <merijn> They are
06:22:38 <merijn> But once again
06:22:46 <merijn> Where's the line?
06:23:11 <merijn> The behaviour in that ticket is *clearly* a bug that violates the definition of TH as it is specified
06:23:13 <dminuoso> 1.73% breakage
06:24:24 <merijn> Is that including transitive dependencies?
06:24:37 <merijn> Because then you probably will be unable to ever fix anything
06:25:25 <dminuoso> Unrelatedly
06:25:28 <dminuoso> Im sad now
06:25:30 <dminuoso> % % Just 'a' <**> (Just 'b' <&> (,))
06:25:30 <yahb> dminuoso: ; <interactive>:183:1: error: parse error on input `%'
06:25:35 <dminuoso> % Just 'a' <**> (Just 'b' <&> (,))
06:25:35 <yahb> dminuoso: Just ('b','a')
06:25:37 <dminuoso> % Just 'a' <**> Just 'b' <&> (,)
06:25:37 <yahb> dminuoso: ; <interactive>:185:15: error:; * Couldn't match type `Char' with `Char -> a'; Expected type: Maybe (Char -> a); Actual type: Maybe Char; * In the second argument of `(<**>)', namely Just 'b'; In the first argument of `(<&>)', namely Just 'a' <**> Just 'b'; In the expression: Just 'a' <**> Just 'b' <&> (,); * Relevant bindings include it :: Maybe (b -> (a, b)) (bound 
06:25:42 <dminuoso> Why is the precedence all wrong here? :(
06:27:36 <dminuoso> merijn: But I see what you're getting at.
06:27:40 <dminuoso> I mean for bugfixes its hard
06:27:46 <dminuoso> But when you *know* you're making breaking changes
06:27:55 <dminuoso> Its not too much to ask for a deprecation notice one major release in advance
06:28:07 <merijn> dminuoso: -Wcompat exists
06:28:15 <merijn> But, sadly, not enabled by default
06:28:36 <dminuoso> merijn: Does -Wcompat work with *GHC* changes?
06:29:10 <merijn> for those added
06:29:10 <dminuoso> I mean only if they receive a particular warning for it
06:29:16 <dminuoso> Like, star-is-type
06:36:57 <Raito_Bezarius> Let us suppose that I'd like to define a character literal as something which is an ASCII char which is not \ or " and accept the escaped versions as char literals
06:37:04 <Raito_Bezarius> charLiteral = satisfy (all isValidCharacter) <|> string "\̈ <|> string "̈" <?> "a character"
06:37:07 <Raito_Bezarius> something like this
06:37:20 <Raito_Bezarius> it would produce [Char] necessarily, right?
06:37:44 <Raito_Bezarius> is it a bad idea to have a charLiteral producing [Char]? Is it easy to build stringLiteral which (++) the many charLiteral (?)
06:38:56 <Raito_Bezarius> (also, it seems like that this charLiteral produces a type of (Foldable t) => m (t Char) rather than m [Char] which I can understand but I'm not sure how I can enforce the array version
06:39:42 <geekosaur> list, not array; and you just ive that as the type signature instead of the more general inferred one
06:39:55 <geekosaur> inference always goes for the most general signature, which is not always what you want
06:40:08 <geekosaur> *give that
06:40:30 <Raito_Bezarius> right
06:40:38 <Raito_Bezarius> what I might not understand
06:40:49 <Raito_Bezarius> rather than having token of Char, I have now token of [Char]
06:40:55 <Raito_Bezarius> so parseTest cannot use such a parser looks like
06:41:09 <Raito_Bezarius> is there a way to keep Char token?
06:41:23 <Raito_Bezarius> charLiteral
06:41:25 <Raito_Bezarius>   :: (MonadParsec e s m, Tokens s ~ [Char], Token s ~ [Char]) =>
06:41:27 <Raito_Bezarius>      m [Char]
06:41:29 <Raito_Bezarius> here's the obtained type sig
06:42:06 <Raito_Bezarius> what I want is Token s ~ Char
06:43:20 <geekosaur> not if it returns more than one
06:43:35 <dminuoso> satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)
06:43:36 <geekosaur> what makes you think parseTest can't work with [Char]?
06:44:06 <Raito_Bezarius> geekosaur: sorry, I meant rather that I would not be able to do parseTest myParser "a string" and would have to do parseTest myParser aListOfString
06:44:15 <Raito_Bezarius> so if I do, charLiteral = many (satisfy isValidCharacter) <|> string "\̈ <|> string "̈" <?> "a character"
06:45:28 <Raito_Bezarius> but if I do,  parseTest (charLiteral :: Parser [Char]) "abc"
06:45:40 <Raito_Bezarius> it fails with Couldn't match type ‘Text’ with ‘[Char]’
06:45:42 <Raito_Bezarius>         arising from a use of ‘charLiteral’
06:46:41 <Raito_Bezarius> hm
06:46:54 <Raito_Bezarius> many will give: m [a]
06:47:13 <Raito_Bezarius> so many (satisfy X) should give m [Token s] right?
06:47:30 <Raito_Bezarius> at the same time, string will give m (Tokens s) rather than m [Token s], I suppose?
06:48:05 <Raito_Bezarius> but as, Tokens s ~ [Char] and Token s ~ Char, shouldn't it work fine?
06:53:28 <gothnbass> I've been looking into porting an existing Common Lisp codebase into Haskell, but it's possible I'm barking up the wrong AST. The application dynamically serialises/deserialises objects according to definitions that are stored in a database, and that cannot be known at compile-time. Is this feasible in Haskell, or am I running myself face-first into the type system?
06:59:02 <dminuoso> gothnbass: That's absolutely feasible.
06:59:55 <gothnbass> That's a relief. There's a lot to love about CL, but I got a taste of the type-system's assurances in Haskell, and I want more :)
07:01:07 <dminuoso> gothnbass: What do these definitions look like?
07:02:36 <gothnbass> They're stored in a Neo4j database, so a JSON object is pretty much their natural representation. I'd just use a Map, but they're heterogeneous.
07:04:29 <dminuoso> gothnbass: If they're already in JSON, you could keep that as JSON directly?
07:04:53 <dminuoso> Well, `Value` for instance 
07:04:59 <gothnbass> To be slightly less vague, the Haskell representation of one of them looks like `data Tag = Tag { uid :: String , createddate :: Int , original_uid :: String , description :: Maybe String } deriving (Show)`
07:09:08 <gothnbass> It's a 2-layer app, where the layer closes to the DB is basically an engine that dynamically constructs a REST API according to whatever the DB says is valid. I started with porting the webapp first, which receives JSON objects, and is expected to deal with them on the fly. It _can_ fetch the schema via the API, but of course that's also a runtime operation.
07:10:49 <gothnbass> But keeping them in JSON is an interesting idea. It hadn't occurred to me to parse them that far and no further. Thanks for the pointer!
07:11:29 <dminuoso> gothnbass: JSON/Value might not be an ideal format though.
07:13:21 <dminuoso> gothnbass: Maybe I misunderstood. Are the data in JSON, or the definitions?
07:13:45 <dminuoso> Also, can these things be nested? Can there be recursion?
07:13:56 <dminuoso> (That is, can the data be cyclic)
07:16:11 <gothnbass> dminuoso: JSON's just a representation format, but is a good fit. Absolutely they can be nested and there can be recursion; it's part of the idea, so you can chase assocations from one node to another.
07:18:31 <gothnbass> dminuoso: Because of this, I'm using JSON as the format for returning data from the API, as well as for representing the schema when a client calls on that API to find out what's in there. What I'm actually trying to port right now is the webapp on top of the API, which receives JSON and constructs HTML accordingly.
07:19:10 <gothnbass> I'm basically putting a relational-inspired schema on top of a graph database, because you can't put one in there directly. This is the most practical (least impractical?) way I found of doing that.
07:20:03 <dminuoso> It's mildly amusing, that people go to great length to ignore 50 years of research in relational databases, put up unstructured databases, and then there's folks like you putting effort into figuring out how to specify a schema for that.
07:20:17 <gothnbass> I know, right? :)
07:20:52 <Raito_Bezarius> :D
07:21:41 <dminuoso> gothnbass: My first instinct, is to not think about JSON here.
07:21:51 <gothnbass> I love relational databases, and have since I first administered a production one in '97, but there are problem-spaces for which they're just not a good fit. Graph DBs are a great fit for this space, but I've seen the mess that can result when the data definitions are scattered through the codebase, and nobody actually defined a clear data model.
07:21:52 <dminuoso> JSON seems like a bad fit for a few reasons
07:22:11 <dminuoso> If you want a graph, use proper graph data types.
07:23:02 <dminuoso> gothnbass: So far, any excuse I've heard for unstructured databases is just "We are too lazy/unprincipled/messy"
07:23:45 <gothnbass> dminuoso: also, "but properly updating the schema is haaard!" Well, yes, it often is.
07:24:11 <dminuoso> Yes. And all the engineering complexity you put into managing the schema *pales* in comparison to all the pain and effort you spend in working with completely unstructured data.
07:24:51 <gothnbass> Hence me wanting to put a structure onto it, complete with constraints on what kind of relationships you can make between what kinds of nodes.
07:25:00 <dminuoso> And it makes testing so much harder, data retrieval becomes complex, hard to optimize for, and very difficult to analyze with formal methods
07:25:18 <dminuoso> At any rate
07:25:38 <dminuoso> I have not solved that kind of problem, but I see absolutely no reason why haskell wouldn't be a prime candidate for this type of problem.
07:26:12 <gothnbass> Well, I already solved it in CL, so I'd hope it can do it :)
07:26:14 <dminuoso> Presumably you're doing something similar to OpenAPI?
07:27:57 <gothnbass> Will be, yes. At the moment the schema API basically returns a dump into JSON, which has been enough for debugging purposes. I plan to turn that into something OpenAPI-compliant.
07:57:54 <dsal> Data.Aeson.Lens is pretty great for this kind of thing.
07:59:59 <gothnbass> OK. Lens is a feature I've heard about, but haven't yet gotten to exploring.
08:06:08 <__monty__> Uhm, why does GHC 8.10 come with an older version of text than 8.4?
08:06:46 <Uniaika> I think it's a plain mistake
08:06:55 <Uniaika> __monty__: what's the status with 8.10.1?
08:07:21 <__monty__> Uniaika: Same for both 1.2.3.2.
08:07:40 <__monty__> And the 8.8 series came with 1.2.4.0
08:11:03 <Uniaika> __monty__: shit, indeed
08:18:11 <Uniaika> __monty__: 8.10.1 should have indeed bundled 1.2.4.0 https://gitlab.haskell.org/ghc/ghc/-/issues/17214
08:20:09 <yushyin> https://github.com/haskell/text/issues/279
08:22:49 * hackage byline 1.1.0.0 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-1.1.0.0 (PeterJones)
08:23:12 <merijn> __monty__: Due to a miscoordination fuck up
08:23:19 <merijn> __monty__: THe older text is intentional (sadly)
08:23:52 <monsterchrom> Data is always structured. Even the most ardent user of "everything is string" has a much-more-rigorously-structured-than-string model. "unstructured" means there is a structure in someone's mind but they are too smug to spell it out.
08:24:22 <merijn> __monty__: https://github.com/haskell/text/issues/273
08:24:39 <monsterchrom> Err nevermind, late by an hour.
08:31:22 <gothnbass> No matter: I agree with your point. There's always a structure somewhere in there; it's just a question of how it's communicated.
08:32:40 <gothnbass> Well, also whether it emanates from the minds of humans or Great Old Ones. I swear some structures aren't just non-relational, but outright non-Euclidean.
09:04:56 <Raito_Bezarius> is there a Text version of Read?
09:04:58 <Raito_Bezarius> read *
09:07:50 * hackage http-client-openssl 0.3.2.0 - http-client backend using the OpenSSL library.  https://hackage.haskell.org/package/http-client-openssl-0.3.2.0 (MichaelSnoyman)
09:11:06 <T0pH4t> so should this not be legal, I get that x is a rigid type if I try to invoke it with an instance of Show, but it should be legal... `data ShowW = forall x. Show x => ShowW (x -> String)`
09:11:14 <T0pH4t> i feel like i'm screwing up the type sig
09:12:00 <tomsmeding> T0pH4t: what is your intention with that data type?
09:12:28 <T0pH4t> its a simple example, but essentially `case w of ShowW f -> f (8 :: Int)`
09:12:32 <T0pH4t> for example ^
09:12:48 <tomsmeding> as it's written, that 'x' in 'forall x' is an existential variable
09:13:08 <tomsmeding> meaning that if you have a value ShowW f, then there _exists_ an x such that f is of type x -> String
09:13:39 <tomsmeding> since you can't know whether that x is Int, that application f (8 :: Int) won't typecheck
09:13:51 <T0pH4t> well x is an instance of Show..
09:13:59 <tomsmeding> sure, but you don't know which one
09:14:03 <T0pH4t> the function should not care about x
09:14:05 <tomsmeding> might be Float
09:14:10 <T0pH4t> could be, should not care
09:14:16 <T0pH4t> all it cares is that x has show
09:14:18 <tomsmeding> but you're applying it to an Int!
09:14:35 <T0pH4t> right, but x is a Show instance
09:14:44 <tomsmeding> perhaps you wanted your declaration to mean: for _any_ x that is Show, f is a function that takes it
09:14:50 <tomsmeding> is that accurate?
09:14:52 <T0pH4t> yes
09:14:54 <tomsmeding> right
09:15:08 <T0pH4t> which is why i think my type sig is wrong :/
09:15:37 <tomsmeding> data ShowW = ShowW (forall x. Show x => x -> String)
09:15:44 <tomsmeding> now x is universally quantified
09:16:00 <tomsmeding> so the _user_ of the ShowW can choose x
09:16:09 <T0pH4t> that was it! thx tomsmeding.
09:16:25 <tomsmeding> as you wrote it, x was existentially quantified, so the _producer_ of the ShowW chooses x, and the caller has no idea which one was chosen
09:16:37 <T0pH4t> ok, make sense
09:16:58 <T0pH4t> odd that existentially would compile tho
09:17:04 <T0pH4t> i don't see how that could ever resolve
09:17:27 <tomsmeding> well, consider the following type
09:17:53 <tomsmeding> data ToShow = forall x. Show x => ToShow (Int -> x)
09:18:15 <tomsmeding> then as the producer of a ToShow, you can insert any function from Int to something that implements Show
09:18:35 <tomsmeding> as the user of a ToShow, you get a function Int -> x, where you have no idea what x is except that it implements Show
09:18:48 <tomsmeding> see: same situation as in your datatype, but suddenly you can actually use this
09:19:10 <tomsmeding> because if you have a ToShow f, then you can do 'show (f 42)', and you'll get a String :)
09:19:13 <T0pH4t> oh so it inverses
09:19:14 <T0pH4t> interesting
09:19:41 <T0pH4t> very cool, good to know. Thx!
09:19:56 <tomsmeding> https://wiki.haskell.org/Existential_type
09:20:00 <tomsmeding> this may or may not be a good explanation
09:20:30 <T0pH4t> haha as with many haskell wiki pages lol
09:21:01 <tomsmeding> do you know the use of GADTs for expression AST's?
09:21:10 <tomsmeding> (the typical motivating examples for GADTs)
09:21:56 <tomsmeding> like this one https://en.wikibooks.org/wiki/Haskell/GADT#GADTs
09:22:30 <tomsmeding> sometimes it's useful to define the following: data SomeExpr = forall a. SomeExpr (Expr a)
09:22:56 <T0pH4t> yeah gdats i use fairly often
09:23:06 <T0pH4t> gadts*
09:23:20 <tomsmeding> e.g. a parser function might have type signature: String -> Either ErrorMsg SomeExpr
09:23:41 <T0pH4t> right, infact i'm buidling a parser right now ;)
09:23:59 <tomsmeding> existentials are quite useful in some circumstances :)
09:24:33 <tomsmeding> the syntax where the exact placement of the 'forall' determines whether it's universal or existential can be very counter-intuitive however
09:24:36 <T0pH4t> for example `data Parser a = PNum (forall x. (GTLType x, Num x) => I.Expression x -> I.GTL a)`
09:24:54 <tomsmeding> yeah there 'x' is universal
09:25:05 <tomsmeding> unsure what GTL is though :)
09:25:19 <T0pH4t> yeah, my own monad for the language
09:25:46 <T0pH4t> but then you can have `parseToken :: Token -> Parser a -> I.GTL a`
09:25:55 <T0pH4t> such that you can do some really cool stuff
09:37:02 <T0pH4t> so apparently this doesn't work :/ `parseToken t1 (PNum pure) >>= <blah>`  assuming t1 contains an instance of Num such that Parser can be invoked.
09:51:10 <T0pH4t> tomsmending: is there a way to get both univeral and existential? 
09:51:46 <T0pH4t> ie the producer sets a and invoke set x, `data Parser a where PNum :: (forall x. (GTLType x, Num x) => (I.Expression x -> I.GTL a)) -> Parser a`
09:57:17 <monsterchrom> If you mean nesting and/or alternating, you can always do that, but you always have to define one more type for each quantifier.
10:02:10 <T0pH4t> mm not sure i get ur meaning monsterchrom, I'm basically want the producer to set the output type based on a consume setting the input type.
10:02:23 <T0pH4t> so in theory producer has context to chose how to convert w/e the consumer gives it
10:08:50 <tomsmeding> T0pH4t: can you write your desired datatype using 'forall' and some hypothetical construct 'exists'?
10:09:17 <monsterchrom> Oh then it's vanilla polymorphic function. For example, reverse :: [a] -> [a] means the caller decides that the input list should be [Int], so reverse spits out [Int] too.
10:11:20 <nlhowell> I am trying to write a typeclass instance for Compose F G where F and G are functors; is there any way I can avoid wrapping arguments with Compose { getCompose = ... } ?
10:11:31 <nlhowell> (without going point-free)
10:11:55 <T0pH4t> so evectively that parser example a few lines up. But actually even what i suggest won't work in the larger context since my Num types can't be guaranteed :/  So for now don't worry about it
10:11:58 <hyperisco> nlhowell, no
10:12:15 <hyperisco> nlhowell, you don't have to use record syntax though
10:12:17 <T0pH4t> tomsmending: thx for now!
10:12:49 <thblt> I have a function that produces multiple named files (a compiler of sorts), that I'd rather not write directly in IO, but I'm not sure of an idiomatic way to type this.  I was thinking of `type Compiler = Layout -> [(FilePath, String)]`. Does it sound reasonable?
10:13:05 <nlhowell> hyperisco: oh? what can i use instead? I think Compose is defined using record syntax
10:13:47 <hyperisco> nlhowell, it doesn't matter if it is defined that way, there is still the constructor named Compose
10:14:08 <nlhowell> ah, just "Compose x"
10:14:10 <nlhowell> thanks!
10:14:18 <hyperisco> nlhowell, np
10:14:20 <nlhowell> that's at least a lot less typing :)
10:14:43 <hyperisco> newtype wrapping and unwrapping is a struggle
10:15:23 <nlhowell> i was hoping for some extension that does some auto-coerce or something
10:15:57 <nlhowell> but avoiding the record syntax with the wordy getCompose= is more than half the battle
10:53:45 <cylon007> ls
11:06:33 <danza> texasmynsted, did you choose your library for shell scripting?
11:23:57 <av3games> hello
11:24:00 <av3games> i need
11:24:02 <av3games> help
11:24:20 <av3games> i am new to haskell and idk what this is
11:24:44 <av3games> <interactive>:3:1: error:    * Variable not in scope: main    * Perhaps you meant `min' (imported from Prelude)
11:25:18 <av3games> here's my code:import Data.Listimport System.IO-- Int -2^63 - 2^63maxInt = maxBound :: Int
11:25:23 <av3games> import Data.Listimport System.IO-- Int -2^63 - 2^63maxInt = maxBound :: Int
11:25:32 <av3games> ...
11:25:40 <ghoulguy> av3games: What's your file named?
11:25:53 <av3games> main.hs
11:26:00 <av3games> i am stupid
11:26:17 <av3games> i am new to haskell
11:26:37 <ghoulguy> change the name to something like: Fun.hs
11:26:44 <ghoulguy> and then add this to the top of your file: module Fun where
11:26:52 <av3games> ok
11:26:54 <av3games> thx
11:27:15 <ghoulguy> av3games: By default, if you don't specify a 'module' line, you get this by default: module Main (main) where
11:27:24 <ghoulguy> which assumes you've defined a 'main' to export
11:27:29 <av3games> ok
11:27:53 <av3games> thanks ghoulguy
12:11:24 <falsifian> I'm trying to understand how to work around the monomorphism restriction. If I write (in a .hs file) "x = let f = show in (f 1, f ())", I get an error, which matches my understanding ("No instance for (Num ()) arising from the literal ‘1’"). But what confuses me is that if I write "x = let f = show :: Show a => a -> String in (f 1, f ())" I get the same error. Can I not explicitly tell the compiler 
12:11:30 <falsifian> the let-bound identifier f should be polymorphic?
12:13:04 <thblt> I *think* you need to be explicit about the type of 1, because number literals are polymorphic too.
12:13:37 <geekosaur> > let f :: Show a => a -> String; f = show in (f 1, f ())
12:13:39 <lambdabot>  ("1","()")
12:13:53 <falsifian> Replacing 1 with (1::Int) just changes the error to "Couldn't match expected type ‘Int’ with actual type ‘()’"
12:13:56 <geekosaur> you assigned a type to show, not to f
12:14:23 <merijn> falsifian: "write a type signature"? :)
12:15:01 <merijn> falsifian: "f y = show y" should also work
12:15:09 <merijn> iirc
12:15:41 <falsifian> geekosaur, merijn: Thanks. It hadn't occurred to me that I wasn't giving f a type signature.
12:16:07 <falsifian> Yes, "f x = show x" fixes it too.
12:17:59 <merijn> monomorphism only apply when something "looks like a value" (i.e. no arguments) *and* has no type signature *and* is typeclass polymorphic
12:30:19 * hackage aur 7.0.5 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-7.0.5 (fosskers)
12:31:19 * hackage aura 3.2.0 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.2.0 (fosskers)
12:40:20 <fraktor> :t foldr (&&) True . map
12:40:22 <lambdabot> error:
12:40:22 <lambdabot>     • Couldn't match type ‘[b]’ with ‘Bool’
12:40:22 <lambdabot>       Expected type: (a -> b) -> [a] -> Bool
12:40:29 <fraktor> I don't understand why this is happening.
12:41:18 <xerox_> map takes 2 arguments
12:41:30 <xerox_> :t (foldr (&&) True .) . map
12:41:31 <lambdabot> (a -> Bool) -> [a] -> Bool
12:41:42 <fraktor> Oh I see, it's a composition rule thing.
12:41:59 <fraktor> Why is the additional `.` required inside the parentheses?
12:42:52 <tomsmeding> '(f . g) x' is equivalent to 'f (g x)', so '(foldr (&&) True . map) x' is equivalent to 'foldr (&&) True (map x)'
12:42:55 <tomsmeding> that won't work :)
12:43:20 <fraktor> I see.  Thank you!
12:43:29 <xerox_> f . g = \x -> f (g x)  so  (foldr (&&) True .) . map = \f -> (foldr (&&) True .) (map f) = (foldr (&&) True) . (map f) = \xs -> foldr (&&) True (map f xs)
12:43:30 <fraktor> Also I know that `all` exists, I just wanted to see how I might implement it.
12:44:06 <tomsmeding> however, '(((foldr (&&) True .) . map) x) y' is equivalent to '((foldr (&&) True .) (map x)) y', which is '(foldr (&&) True . map x) y', which is 'foldr (&&) True (map x y)'
12:44:25 <tomsmeding> @src .
12:44:25 <lambdabot> (f . g) x = f (g x)
12:44:36 <tomsmeding> equational reasoning allows you to write it all out :)
12:45:07 <fraktor> I didn't know about the `src` thing, that's really cool! Is that lambdabot or ghci?
12:45:08 <fraktor> @src all
12:45:09 <lambdabot> all p = and . map p
12:45:15 <fraktor> :t all
12:45:16 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:45:24 <tomsmeding> that's lambdabot; it gives you an idealised definition
12:45:34 <tomsmeding> the real definition might be more complicated for performance or generality reasons
12:45:39 <fraktor> "Idealized"?
12:45:51 <fraktor> Like, someone went and wrote these, or it generates them?
12:45:58 <tomsmeding> someone wrote these :p
12:46:14 <fraktor> I was going to say...
12:46:23 <fraktor> :t (and .) . map
12:46:25 <lambdabot> (a -> Bool) -> [a] -> Bool
12:46:41 <geekosaur> the actual definitions are often optimized or generalized
12:46:57 <tomsmeding> for example, for (.) : https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-1443
12:47:50 <tomsmeding> (the comment helpfully explains why it's not the intuitive definition; 'base' is generally well-written like that)
12:50:23 <merijn> fraktor: The definitions are lambdabot are mostly the ones copied from the Haskell Report
12:50:52 <maerwald> tomsmeding: didn't you say ALE is good wrt LSP?
12:51:07 <tomsmeding> maerwald: in my very limited experience, yes
12:51:20 <merijn> maerwald: "works for me"
12:51:22 <maerwald> It does nothing here lol
12:51:38 <tomsmeding> you have to instruct it to use your language server probably
12:51:41 <merijn> maerwald: With which client?
12:51:45 <merijn> eh, server, I guess
12:52:31 <maerwald> https://paste.tomsmeding.com/EdTf9fLZ
12:53:33 <maerwald> wait, now it does something... seems the build just took longer than expected
12:54:03 <tomsmeding> in that case your cpu usage should've been an indicator that something was amiss :p
12:54:09 <maerwald> oh wow... a sensible default: only lint when saving
12:54:23 <maerwald> tomsmeding: not really, since hls often just gets stuck here and sticks to 100% cpu
12:54:34 <tomsmeding> interesting
12:54:44 <tomsmeding> have you tried plain ghcide?
12:55:14 <maerwald> and it behaves very funny when your project GHC is not the currently set ghc (the `ghc`)
12:55:57 <maerwald> https://user-images.githubusercontent.com/1241845/97086886-61c80980-1626-11eb-8874-5467c508d60e.png
12:56:00 <maerwald> then this happens
12:56:32 <tomsmeding> well at least you get some heating
12:56:46 <tomsmeding> but I gather it works now? otherwise I can share my current setup
12:56:50 <maerwald> I don't get OOMed anymore since I bumped my ram, at least
12:57:03 <maerwald> how do you do stuff like goto definition and code actions?
12:57:04 <tomsmeding> yes with 16G you would've been out at this point :p
12:57:10 <tomsmeding> :ALEGoToDefinition
12:57:19 <tomsmeding> or map a key to <Plug>(ale_go_to_definition)
12:57:29 <tomsmeding> in general :ALE<tab> and their help sections
12:58:00 <tomsmeding> not sure how much support there is for code actions, I don't really use that myself
12:58:49 <maerwald> well, that doesn't do anything 
12:59:07 <maerwald> with no error
12:59:31 <tomsmeding> has your cpu quieted down already?
12:59:34 <maerwald> seems not https://github.com/dense-analysis/ale/issues/1466
12:59:42 <tomsmeding> if not, might want to wait for that to happen
12:59:47 <maerwald> that seems quite limited
12:59:59 <maerwald> also, my RSI kicks in again, so I'll stop now
13:00:48 <maerwald> (the import code action is very useful)
13:01:07 <maerwald> (at least if your project forces you to use explicit import, which I find nonsensical for the record)
13:01:19 <maerwald> (you can quote me :p)
13:01:59 <tomsmeding> I kind of like the custom, since it reduces dependence on IDE-like integration to navigate through code
13:02:39 <tomsmeding> within measure, of course; if you start importing >10 symbols from a module it's not worth the bother anymore
13:03:23 <tomsmeding> but it's certainly a subjective point
13:08:56 <hyperisco> any hints on how I can hash a dhall config (I am using dhall as a library)
13:09:41 <maerwald> output as json, convert to dense format with newlinet removed, make sure you don't have trailing newline
13:09:55 <maerwald> and sort the objects
13:09:57 <hyperisco> wait why?
13:10:24 <tomsmeding> or write a https://hackage.haskell.org/package/hashable-1.3.0.0/docs/Data-Hashable.html instance :p
13:10:40 <hyperisco> dhall supports hashing configs
13:10:52 <maerwald> oh, why do you ask then? :D
13:10:54 <hyperisco> the tutorial just doesn't seem to say how to do it using dhall as a library rather than by cli
13:11:21 <tomsmeding> https://hackage.haskell.org/package/dhall-1.36.0/docs/Dhall-Import.html#v:hashExpression ?
13:12:06 <maerwald> hashExpressionToCode looks cool too
13:12:31 <hyperisco> I am not sure... so I decode the file with  input auto
13:12:46 <tomsmeding> what is the type of the thing you want to hash?
13:12:48 <hyperisco> that gives me a type I defined with a FromDhall instance, not an  Expr Void Void
13:13:01 <tomsmeding> ah
13:13:37 <hyperisco> is there a way to break it apart so I can get both?
13:13:49 * hackage byline 1.1.0.1 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-1.1.0.1 (PeterJones)
13:14:17 <hyperisco> well whatever, I'll just use the file mod time then oO
13:18:19 * hackage themoviedb 1.2.0.1 - Haskell API bindings for http://themoviedb.org  https://hackage.haskell.org/package/themoviedb-1.2.0.1 (PeterJones)
13:21:36 <tomsmeding> hyperisco: what about inputExpr and rawInput from the Dhall module?
13:32:11 <maerwald> I wanted to migrate an OpenAPI spec from yaml to dhall. I think that's a pretty good use case (e.g. abstracting and merging multiple types that represent sets of HTTP return codes)
13:32:21 <maerwald> yaml anchors don't really do merging
13:45:53 <Mrbuck> https://youtu.be/O9upVbGSBFo?t=3801  Hi why did this guy said it took a week to write some small program in haskell and then it run like a turtle? 
13:47:56 <Uniaika> idk, never saw him around asking for help :P
13:48:05 <Athas> Mrbuck: I think he's exaggerating for effect, but Haskell is infamous for requiring more ceremony around IO.
13:48:37 <Athas> Regarding performance, it's possible he used one of the old interpreters (Hugs), or just had a space leak.  Haskell is not generally a particularly slow or fast language.
13:50:41 <maerwald> They do some nice js bashing later though
13:50:42 <Mrbuck> Athas:  Thank you for the answer
13:52:17 <davean> Haskell can produce quite fast code but calling GHC an optimizing compiler is a little silly. I can beat C implimentations in Haskell but I have to do the work.
13:52:31 <davean> When i don't its several times slower by default usually.
13:52:45 <tomsmeding> davean: ghc is an optimising compiler; if it didn't optimise your code, it would run a _lot_ slower ;)
13:52:55 <tomsmeding> attestable by using -O0 with ghc
13:53:25 <davean> tomsmeding: I find the ASM GHC puts out to be pretty much the straight translation of my Haskell personally.
13:54:03 <tomsmeding> hm, perhaps most of the work is to strip away all the abstractions we like to make?
13:54:10 <tomsmeding> *most of the work it does
13:54:25 <davean> yes, thats most of the -O0 -O2 difference in many cases
13:54:32 <davean> directly refering to, and inlining things
13:54:37 <maerwald> I've never been able to beat C performance with haskell. That's an interesting statement 
13:54:39 <davean> but the code its self is straight line either way
13:55:13 <tomsmeding> I wonder, ghc can use llvm as a backend, can't it? would that help?
13:55:16 <davean> maerwald: usually my benchmarks there are reasonable C programs that compitent people wrote but didn't care to spend time optimizing.
13:55:34 <davean> tomsmeding: LLVM doesn't help. Well it does, but only for heavy numerical portions of the code.
13:55:44 <tomsmeding> makes sense
13:55:49 <davean> for non-numerical codes, not using LLVM is faster
13:55:59 <maerwald> Ah, I thought you wrote both implementations
13:56:02 <tomsmeding> that may be the most interesting statement yet
13:56:17 <maerwald> Everything else isn't really representative imo
13:56:19 <tomsmeding> except if you mean _compilation_ is faster without llvm, which is unsurprising
13:56:36 <davean> maerwald: I'd say that isn't representative because that would be comparing how much effort and skill *I* had
13:56:41 <davean> tomsmeding: no
13:56:59 <davean> tomsmeding: I mean the generated program is faster without LLVM if its not generally numerical in nature.
13:57:06 <maerwald> Yes and yet it's the only useful comparison
13:57:14 <tomsmeding> that sounds like a huge failure of llvm then :p
13:57:18 <tomsmeding> or of ghc's usage of it
13:57:42 <davean> maerwald: I don't think thats true "This is the actual C code people put out as final products" vs. "This is how I can do it in Haskell given $X time" is perfectly useful.
13:58:01 <maerwald> As in: I want to know if anyone proficient with both languages managed to beat C
13:58:21 <maerwald> I wasn't able to
13:58:36 <davean> maerwald: but that just says you're more proficient at C optimization
13:58:42 <maerwald> No
13:58:54 <maerwald> You need more data points
14:04:07 <Athas> It's a lot easier to write fast C than it is to write fast C.
14:04:22 <Athas> And fast C looks a lot more like idiomatic C than fast Haskell looks like idiomatic Haskell.
14:05:01 <Athas> Er: It's a lot easier to write fast C than it is to write fast Haskell.
14:06:31 <davean> Hum. I'd say yes and no. In C it "looks" idiomatic sometimes because theres no representation at all that its different then a horrificly slower design. Most C programmers I know would accidently trample some massice optimizations because they didn't see they were there because the language has litterly zero representation of the optimization. That said, theres a lot of basic optimizaiton mistakes
14:06:32 <davean> people make in Haskell that don't look much different either. (Though some super important optimizations are directly not idiomatic Haskell and thats sad and GHC should improve because the ones I'm thinking of shouldn't have to be done by hand at all)
14:07:17 <davean> Also, more Haskell optimizations are actually optimizations than ways to trick the compiler into generating the code you want.
14:07:25 <davean> So they stay optimizations.
14:07:44 <tromp> It's also a lot easier to write correct Haskell than it is to write correct C :-)
14:07:52 <davean> Also C compilers are just *smarter*
14:08:10 <Athas> How are C compilers smarter?
14:08:24 <davean> Athas: Things like polygonal optimization for ASM instruction dependency breaking.
14:08:31 <davean> Athas: C compilers try to optimize code.
14:08:47 <davean> GHC translates what you write into ASM pretty directly.
14:09:09 <davean> GHC can't even unroll a fold against a CAF.
14:09:15 <Athas> For things like instruction scheduling and register allocation?  When going through LLVM, GHC should benefit from the same optimisations.
14:09:24 <davean> Athas: incorrect.
14:10:20 <Athas> Why not?
14:10:33 <davean> for a number of reasons, one LLVM doesn't have enough semantic representation left.
14:10:48 <davean> For another Haskell has more semantics defined.
14:11:00 <davean> which means that LLVM doesn't have the analysis capability
14:11:13 <davean> LLVM is fairly weak in understanding semantics, its too late for a number of things.
14:11:27 <Athas> Could you clarify what you mean by polygonal optimization?  I'm not sure I've heard that term before (is it like polyhedral optimisation?), but my work is mostly in high-level optimisations.
14:11:36 <tomsmeding> why does it have that information then if it receives code from e.g. clang?
14:11:42 <davean> er, yes, sorry I got it autocorrected it seems.
14:12:08 <davean> tomsmeding: well for one they're designed for each other.
14:12:14 <tomsmeding> sure
14:12:25 <Athas> I'm not sure GCC or Clang does polyhedral optimisations by default, but I could be wrong.
14:12:32 <tomsmeding> but then it sounds to me like ghc is leaving some llvm attributes on the table
14:12:42 <Athas> Also, LLVM for sure only does polyhedral optimisations at the LLVM IR level (with Polly), and I'm not sure the C compiler helps.
14:12:52 <Athas> After all, LLVM barely even has loops - they are reconstructed on demand.
14:13:16 <davean> yes but based on the concept of how the C compiler works.
14:13:30 <davean> So GHC has things like boxing.
14:13:42 <Athas> Sure, LLVM shows its lineage as a C compiler backend, but I thought mostly in the area of nasty undefined behaviour semantics.
14:14:03 <davean> Athas: A) not only B) uh, don't you think thats the thing thats directly relivent here?
14:14:34 <Athas> By "undefined behaviour semantics", I mean things like LLVM removing some infinite loops, because they happen to be undefined in C.
14:14:47 <Athas> I'm not sure it matters much for the kinds of optimisations that would help GHC.
14:15:50 <Athas> Actually, I'm not really sure which optimisations would help GHC!  Better automatic unboxing maybe?
14:16:49 <davean> Well yes, though thats not the sort of thing LLVM can reason about. Also just inlining certain things. There are a lot. I have further studies in it to do, but have been working on a bit of a search for which main ones its missing.
14:17:39 <Athas> GHC does a lot of inlining, doesn't it?  It's the enabler of all the other big GHC-level optimisations, like fusion, or anything else driven by simplification rules.
14:17:45 <davean> You can't "just" got from boxed to unboxed sums for example, and returning stuff as an unboxed tuple can be pretty massive.
14:18:03 <davean> Athas: I mean fusion and such is some pretty basic code rewriting.
14:18:22 <davean> Athas: Its a moderate framework for code no one optimized at all.
14:18:58 <davean> These optimizations *are* semantic changing though I want to point out. Which means they're very hard to talk about
14:19:04 <davean> and they're also data representation changing.
14:19:04 <Athas> I think there is great value in optimisations that let us write modular code without overhead, which is exactly what fusion does (in ideal cases).
14:19:18 <davean> Athas: with *less* overhead
14:19:23 <Athas> An optimisation that changes semantics is simply wrong, in the nomenclature I'm familiar with.
14:19:44 <davean> Athas: many change semantics locally but won't change them outside the function boundaries for example.
14:21:11 <Athas> I'm still not sure I understand.  Could you name an example of such an optimisation?
14:21:25 <davean> Athas: well, a bang pattern.
14:21:41 <davean> That line evaluates differently but the function probably doesn't if the bang is appropriate.
14:22:02 <Athas> Those are certainly semantics-changing in an observable way, at least in general.
14:22:18 <davean> in general yes, but in many specific cases no
14:22:25 <davean> Hence GHC's strictness analysis
14:22:29 <Athas> GHC only does the equivalent of adding bang patterns when the strictness analyser determines it can be done without any observable semantic effect.
14:22:42 <davean> Right, but define "observable" there
14:22:52 <davean> Where is the observer?
14:22:57 <Athas> With respect to Haskell's (unwritten...) operational semantics.
14:23:08 <davean> that line *did* change but the function its in didn't usually is the answer
14:23:40 <monsterchrom> It doesn't look like this conversation is getting productive.
14:23:45 <davean> no it does not
14:24:02 <davean> I've been looking for how to step away from it politely.
14:24:22 <monsterchrom> I recommend "I need a drink" :)
14:24:48 <monsterchrom> I'm always fond of "computer science has become a bit too technical, let's go for a drink"
14:25:14 <monsterchrom> Jay Misra said that after a conference.
14:25:45 <monsterchrom> And of all people, he wrote a super technical, hard-to-follow proof in a paper (though not for that conference).
14:27:29 <monsterchrom> To be fair, his proof was merely operational semantics chasing. In the conference, some of the speakers inflicted monads on us.
14:27:48 <davean> Monads are the definition of terrible, clearly.
14:27:49 <monsterchrom> (basically the monad for Hoare triples)
14:28:06 <davean> Oh interesting
14:28:07 <dolio> Seems like the problem is Hoare logic, not monads.
14:28:13 <monsterchrom> :)
14:28:30 <davean> dolio: I liked monsterchrom's telling better.
14:28:39 <davean> dolio: Its not about the story, its about *how* you tell it.
15:32:17 <Squarism> Anyone heard of any library able to (de)serialize a subset of Traversal's (used by lens)?
15:32:54 <Rembane> Squarism: What's serialize in this context? 
15:33:00 <Squarism> e e
15:33:42 <Squarism> Rembane, preferably something human readable. But any string would do I guess. 
15:35:46 <Rembane> Squarism: Interesting, I've never seen one but perhaps someone else here has. 
15:39:00 <Squarism> I mean, it feels as if something like "field1 . ix 4 . fieldA . _Just" could have a textual representation. But maybe thats a naive conclusion
15:39:39 <Rembane> Well, you need to go from a function to a textual representation and that's kinda tricky 
15:40:56 <Uniaika> I can't see a way to have a straightforward, abitrary expression of a Traversal that would not need a heap of context for it to make sense
15:41:08 <Uniaika> hmm.
15:41:10 <Uniaika> that being said.
15:41:49 <Uniaika> Squarism: have you read the Typed Tagless Final Interpreters paper? http://okmij.org/ftp/tagless-final/course/lecture.pdf
15:42:23 <Uniaika> the author shows a way to have multiple interpreters for an eDSL. One that would evaluate the functions, one that pretty-prints them, one that serialises them into a Tree, etc
15:42:37 <Uniaika> you may get some good stuff out of it
15:42:50 <Squarism> Maybe a start would be to just have deserialize and find other means to create the serialized "addresses". 
15:43:13 <Squarism> Uniaika, ah cool. Ill look into that
15:43:40 <Uniaika> 👍
15:44:05 <Uniaika> tell me if it helped you acquire some new techniques for your goal
15:44:13 <Uniaika> (or if it didn't)
15:44:16 <Squarism> I will
15:44:50 <Rembane> Squarism: Here's a related blog post that might be easier to digest than the paper: https://serokell.io/blog/tagless-final
15:45:06 <koz_> Tagless final doesn't help you here.
15:45:09 <Squarism> sounds like a good start. Thanks
15:45:14 <koz_> This isn't eDSL territory.
15:45:23 <koz_> Uniaika: We had a conversation on this topic already, I believe. :P
15:45:51 <Rembane> Uniaika: Have you perhaps found a new hammer? :) 
15:46:00 <koz_> Rembane: Can confirm.
15:46:33 <Rembane> koz_: ^^ 
15:46:39 <Rembane> It is a very good hammer though. 
15:47:20 <koz_> Yeah, but all hammers are, after all, hammers, not hammer-chisel-screwdriver-breadmaker-firearm-sketchpads.
15:47:23 <Rembane> Isn't there another representation of lenses called optics that's more like an initial encoding than a final encoding? 
15:47:39 <Rembane> koz_: Are you talking about recursion schemes? :D
15:47:56 <koz_> Rembane: No, because you did you see any Ancient Greek there? :P
15:48:06 <koz_> Also yes, optics exist, but I don't think it helps here.
15:48:26 <Rembane> koz_: I see Ancient Greek everywhere! :D
15:48:41 <Rembane> koz_: It's like "I see dead people" but s/dead people/Ancient Greek/g
15:49:01 <Rembane> Squarism: What do you need the serialization for btw? 
15:49:03 <koz_> Yep, both be dead, yo.
15:49:19 <Rembane> They have much in common. 
15:49:24 <Rembane> Deadomorphisms
15:49:37 <koz_> Mortimorphisms?
15:49:46 <koz_> Thanamorphisms?
15:50:06 <koz_> Should be thanamorphisms, I think, since 'mort' is a Latin root.
15:50:31 <Rembane> Yeah, mixing greek and latin always makes for good fun 
15:51:01 <koz_> Rembane: It's how privately-educated English people amuse themselves, I've heard.
15:51:20 <mort> "mort" has no relation to "morph" afaik though?
15:51:51 <koz_> mort: No it does not, but that's beside the point here. The joke is that all recursion schemes are [some Greek root] + morphism.
15:52:08 <koz_> Such as 'anamorphism', 'catamorphism', 'hylomorphism', 'chronomorphism', etc.
15:52:18 <Rembane> Adnd you can combine them for even more fun 
15:52:28 <Rembane> And to make sweet rhymes 
15:52:32 <koz_> So if we wanna talk about 'dead-related recursion schemes', 'thanamorphism' appears to be the convention-following construction.
15:52:49 <Squarism> Rembane, i have a webapp that does addition and changes to some user defined type. So i was hoping to be able to produce "all addresses for addition of values" (Nothing, List-ends) "all modifiable addresses" (any leaf of some data type)
15:53:38 <mort> I see. Is thana- or thano- a root for dead in Greek then 
15:53:49 <mort> this explains the name thanos at least
15:53:54 <Rembane> Squarism: I might be out on a limb here, but can you make another representation that can both be shown/serialized and turned into traversals?
15:54:09 <koz_> mort: Indeed.
15:54:10 <Rembane> mort: Who's Thanos? 
15:54:30 <koz_> It's the root of words like 'thanatosis', although English doesn't lean on Greek much for words of that meaning.
15:54:30 <mort> the Marvel supervillain
15:54:37 <Squarism> Rembane, so the address needs to be sent over the wire. Also, the interface on the "server" is untyped as it only operates on a serialized version of the above mentioned user defined type. 
15:54:47 <koz_> The 'cata' in 'catamorphism' means 'to collapse', like in 'catastrophe'.
15:55:19 <Squarism> Rembane, not a bad idea. 
15:55:25 <koz_> But yes, the Thanos connection is indeed this.
15:55:39 <Squarism> Ill ponder that
15:56:05 <koz_> Usually we tend to use 'mort' or 'necro' in English for fancy death-related terms.
15:56:10 <Rembane> Crunchomorphism! 
15:56:24 <koz_> (consider 'necrosis', 'necromancy', 'mortify', 'mortal', etc)
15:57:03 <Rembane> Squarism: Got it, untyped interface sounds exciting. :)
15:57:19 <Rembane> Necrofy, necrtal... hm... 
15:57:38 <mort> hydromorphism
15:58:05 <mort> oh, quadromorphism, the true Fourier transform which makes numbers four-ier 
15:58:10 <koz_> mort: ROFL.
15:58:23 <Squarism> Rembane, i guess it doesnt. But web only knows text and json so yeah. 
15:58:25 <Axman6> gold
15:58:37 <Rembane> mort: :D
15:58:42 <koz_> Axman6: Chrysomorphism?
15:58:54 <Rembane> Squarism: That doesn't stop you from type checking it when you deserialize it. :)
15:58:57 <koz_> (inb4 I finally get where the whole 'Christ' thing came from)
15:59:05 <Axman6> @quote+ mort quadromorphism, the true Fourier transform which makes numbers four-ier  
15:59:05 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
15:59:37 <Axman6> @remember mort quadromorphism, the true Fourier transform which makes numbers four-ier  
15:59:37 <lambdabot> Done.
15:59:48 <Axman6> @quote four
15:59:48 <lambdabot> copumpkin says: I love: Warning: Due to a known bug, the default Linux document viewer evince prints N*N copies of a PDF file when N copies requested. As a workaround, use Adobe Reader acroread for
15:59:48 <lambdabot> printing multiple copies of PDF documents, or use the fact that every natural number is a sum of at most four squares.
16:00:19 <mort> @quote fourier
16:00:19 <lambdabot> mort says: quadromorphism, the true Fourier transform which makes numbers four-ier
16:00:45 <koz_> Although in retrospect, I think I've hit a false cognate (krysos versus kristos).
16:01:38 <mort> re: the evince thing; just ask for sqrt(n) copies to get n copies
16:01:51 <koz_> mort: I want 3 copies, wat do.
16:02:08 <Axman6> ask for one and one and one
16:02:20 <Rembane> Ask for sqrt 3 copies. *nods*
16:02:22 <koz_> Axman6: Unary counting, always good.
16:02:30 <mort> just print 1.7320508075688772 copies, yeah
16:02:44 <Rembane> "Noch einmal, bitte."
16:02:56 <Axman6> assume you'll fuck one up and ask for 2 copies
16:04:12 <Rembane> I have this book on folding paper planes, so I always become happy when the printer prints too many pages. You should get a book on paper planes too. 
16:06:43 <MarcelineVQ> why would you fold a paper plane
16:06:58 <MarcelineVQ> it won't fly at all!
16:07:11 <koz_> MarcelineVQ: inb4 samsung joke
16:07:22 <hpc> if you fold paper, is it still a plane?
16:07:58 <MarcelineVQ> how can folding be real if our planes aren't real
16:08:19 <Rembane> If you put a mark on the paper it can easily become a catastrophy when folded
16:08:33 <Rembane> MarcelineVQ: Fold along one dimension 
16:08:47 <MarcelineVQ> I saw a movie about that one time
16:08:58 <mort> I mean with the "every number can be written as a sum of four squares" thing, any number N of pages can be printed with O(1) print instructions, it's not even that bad
16:09:05 <MarcelineVQ> some guy lost his eyes and morpheus had to beat him up
16:09:28 <Rembane> Sounds like Minority Report
16:09:53 <MarcelineVQ> the majority of people who see it enjoy it
16:11:37 <hekkaidekapus> Come on people, you can’t let a Latin/Greek conversation end without asking mort: ”Ets tu mort?” and requiring mort to think in French.
16:11:50 * hackage aura 3.2.1 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.2.1 (fosskers)
16:12:06 <koz_> hekkaidekapus: Not all are so linguistically graced.
16:12:20 <hekkaidekapus> :)
16:12:34 <koz_> We can't all insist that it's actually 'la COVID-19'.
16:12:44 <mort> pardon, mais mon français n'est pas bonne 
16:12:59 <hekkaidekapus> :D
16:13:23 <mort> mon français est mort 
16:14:16 <hekkaidekapus> At least we have dead-k :D
16:14:35 <mort> it's a bit sad, the "feel" for the language is there but the vocabulary isn't
16:15:00 <Rembane> Are linguistics some kind of human eating bovine? 
16:15:10 <mort> probably?
16:15:44 <Axman6> it's called linguineistics if it's from Italy though
16:15:45 <mort> not sure if it has to be a bovine precisely
16:16:25 <Rembane> Tasty! 
16:18:27 <koz_> mort: Vocabulary is hard.
16:19:22 <mort> yes
16:35:05 <koz_> :t foldM
16:35:06 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
16:43:51 <Uniaika> 2~< koz_> Uniaika: We had a conversation on this topic already, I believe. :P // ah bloody hell I was persuaded it was
16:44:15 <Uniaika> lens functions do seem like a proper eDSL though
16:44:26 <koz_> Not if you're textualizing then reading them back.
16:44:42 <Axman6> lens is just just traverse with more steps, fight me
16:44:50 <koz_> Repeat after me: as soon as your input is arbitrary text from outside, you have a compiler, not an eDSL.
16:45:54 <Uniaika> as soon as my input is arbitrary text from outside, I have a compiler, not an eDSL
16:49:20 <dmwitch> Seems like a category error.
16:49:36 <dmwitch> As soon as your input is arbitrary text from outside, you have a DSL or GPL, not an eDSL.
16:49:49 <koz_> dmwitch: That's a valid point.
16:50:16 <koz_> Also, I get your name is meant to call to mind a spellcasting woman, but I see the food consisting of a filling with bread either side.
16:51:17 <sandmwitch> ^_^
16:51:19 <koz_> PERFECT
16:51:39 <sandmwitch> conclusion: sanch = bread
16:52:00 <koz_> Two slices of, at that.
16:54:05 <hekkaidekapus> lol :P Are Halloween times like this every year?
16:54:27 <sandmwitch> This is the first year I've seen it. But I like it, and assign high probability to this becoming a tradition.
16:55:20 <hekkaidekapus> It merits a proposal so that it’s enforced in all community medium/media.
16:55:23 <sandmwitch> (Possibly related: people are turning to electronically-maintained relationships for their holiday celebrations more than usual this year.)
16:55:55 <hekkaidekapus> That, too.
16:56:18 * DigitalKiwi /nick WitchKiwi
16:56:46 <DigitalKiwi> ya know what f it
16:57:17 * hekkaidekapus rests my lungs :D
17:00:13 * sandmwitch proposes DevilKiwi
17:01:24 <sandmwitch> Another strong contender: DigitalKiwicked
17:01:26 <WitchKiwi> i was thinking GhostKiwi
17:01:51 <WitchKiwi> i love Wicked
17:02:10 <WitchKiwi> DigitalKiWicked
17:02:20 <WitchKiwi> fun fact: my gmail name is Ki Wi
17:02:35 <sandmwitch> v. oriental
17:02:51 <DigitalKiWicked> quora banned me
17:04:02 <DigitalKiWicked> kiwitch
17:04:56 <DigitalKiWicked> "are you a bird or a fruit" "sandwich"
17:05:16 <sandmwitch> I've only been banned from an online community once, and I couldn't even be upset about it because the message telling me why was just a link to this video: https://www.youtube.com/watch?v=p12coHOA51Q
17:05:32 <sandmwitch> Still no idea what I did wrong. haha
17:06:41 <Axman6> dat clipping
17:07:10 <sandmwitch> it is the Flash way
17:07:48 <Axman6> my DAC is wasted on this trash. but I would also not be mad if that's how I were banned
17:09:16 * hekkaidekapus thanks sandmwitch for being literally kicked out of the room. I sweared I’d behave but it has been many consecutives minutes of loud giggles…
17:09:55 <DigitalKiWicked> Quora 
17:09:55 <DigitalKiWicked> Quora Moderation flagged your profile as not conforming to Quora's Real Name Policy.
17:09:55 <DigitalKiWicked> Quora Moderation blocked you from editing on Quora for this reason:
17:09:56 <DigitalKiWicked> Blocked from editing due to an unverified name. For more information, see Quora's policy on using real names: https://www.quora.com/Do-I-have-....
17:09:56 <DigitalKiWicked> You will not be able to add questions or write answers at this time.
17:11:27 <DigitalKiWicked> guess they don't want my free labor
17:11:40 <Rembane> DigitalKiWicked: So you had a so awesome name that you got blocked? 
17:33:46 <cylon007> /?
17:34:00 <sandmwitch> /!
19:20:19 * hackage agda-unused 0.1.0 - Check for unused code in an Agda project.  https://hackage.haskell.org/package/agda-unused-0.1.0 (msuperdock)
19:30:49 * hackage barbies-th 0.1.7 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0.1.7 (FumiakiKinoshita)
20:13:12 <Kolkrabe> What are "strippable HKDs"? (I presume it has nothing to do with the currency of Hong Kong)
20:13:40 <Axman6> higher kinded data
20:14:39 <Axman6> I can't renenber what strippable means in this context, though it may be that when your functor is Identity there's no wrapping of the fields in identity (but maybe that was another package which did that)
20:17:20 <Kolkrabe> Is it like wrapping fields of a datatype into another datatype?
20:18:52 <Kolkrabe> I'm looking at the example at http://hackage.haskell.org/package/barbies-1.1.3.0/docs/Data-Barbie-Bare.html
20:19:42 <Axman6> basically - instead of defining your types like Data Foo = Foo { foo :: Int, bar :: Bool } you use data Foo f = Foo {foo :: f Int, bar :: f Bool}. Then a lot of nice things fall out of doing that - Foo Identity is basically the original type, Foo (Const String) lets you associate a string with every field, Foo (Either String) might be the result of parsing a Foo where you can collect errors for each field, and if all fields were Rights you pa
20:19:43 <Axman6> rsed it successfully
20:21:49 <Axman6> one really nice thing you can do is the transformation from Vector (Foo Identity) to Foo Vector - a.k.a the vector of structs to struct of vectors transformation
20:26:04 <Kolkrabe> Axman6: I see, thanks. Would be also useful for parse trees where you want to have different trees with source position information attached or not
20:43:54 <koz_> Kolkrabe: Yeah, it can be used for that too.
20:44:10 <koz_> HKD does have some downsides though.
20:57:10 <Orbstheorem> #nixos
20:57:38 <Orbstheorem> (sorry for the noise)
21:47:48 <crestfallen> http://ix.io/2CfR  hi the ghci session I have commented out at the bottom of this paste gave unexpected results. how did the zero in (Just 0) end up in the tree? thamks
21:48:59 <sandmwitch> Well... I mean, -5 is not > 0, so
21:49:23 <koz_> Yeah, pretty much exactly this.
21:49:45 <crestfallen> (aa was originally : aa x = if even x then Just (div x 2) else Nothing   )
21:50:04 <crestfallen> so with Nothing it fails, I see that
21:50:42 <crestfallen> But I thought that if anything fails the predicate then I would have Just 0 returned
21:51:29 <sandmwitch> What does "if anything fails the predicate then I would have Just 0 returned" mean?
21:51:47 <sandmwitch> Are you saying that you expect that `trevarse aa foo = Just 0` whenever there is a negative number somewhere in `foo`?
21:51:57 <sandmwitch> If so, why do you expect that?
21:52:07 <sandmwitch> (trevarse -> traverse, obviously)
21:53:07 <crestfallen> so if we used this func, and gave it the list [2,4,6] we'd have Just [1,2,3] 
21:53:56 <crestfallen> so every member of the list needs to be even. but the other function I figured would return (Just 0)
21:57:03 <sandmwitch> Why did you figure that, though?
21:59:34 <crestfallen> because whatever goes after the else clause would be returned as (Just 0) ; I didn't expect 0 to be integrated into (Con 0) like that. weird
22:00:07 <sandmwitch> The then/else divide is not special. The Just/Nothing divide is special.
22:00:51 <sandmwitch> (And the *reason* it is special is because the Applicative instance for Maybe does different things depending on whether it sees Just or Nothing.)
22:01:36 <crestfallen> sandmwitch: thanks not sure I see exactly what's happening
22:02:39 <crestfallen> I thought Just 0 would be a return value
22:04:47 <koz_> :t traverse
22:04:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:04:55 <koz_> Note what happens to the 'f'.
22:06:20 <crestfallen> in the return? : f (t b)  koz_ 
22:06:52 <koz_> crestfallen: Yeah, exactly. That's what makes 'traverse' what it is. Now, notice where that 'f' is in the function argument to traverse.
22:07:01 <koz_> Now, look at your situation - what is 'f' in your case.
22:07:04 <koz_> Take. Due. Care.
22:08:09 <crestfallen> f is Maybe.. in this case Just
22:08:28 <koz_> The first was right, then you sank yourself. Again, please do not confuse the value level and the type level.
22:08:46 <crestfallen> hold on
22:08:48 <koz_> So therefore, given your 'aa', you'll _always_ end up with Just [some tree inside].
22:09:08 <koz_> Because no matter which branch you take, you'll get a Just.
22:09:28 <koz_> And since in your case, f ~ Maybe, the expected result is 'Maybe (Tree Int)'.
22:09:33 <koz_> Which is exactly what you're seeing.
22:09:42 <koz_> s/result/result type/
22:11:09 <crestfallen> ...
22:15:31 <crestfallen> so koz_ that behavior is interesting. it seems like the logic in the if / then statement has changed. (Just 0) is feeding the value to the rhs branch : (Con 0). trying to wrap my head around that
22:15:57 <koz_> No, the logic in the if-then-else hasn't 'changed', whatever that means.
22:16:09 <koz_> Look at your definition of 'traverse'.
22:16:16 <koz_> (for your Tree type).
22:16:51 <koz_> That behaviour _is_ interesting, but the if-then-else you have there is literally the least interesting part of it.
22:16:56 <koz_> It's all about the traverse definition.
22:17:14 <crestfallen> what I meant was ... else Nothing changes the logic
22:17:21 <koz_> It does.
22:17:31 <koz_> And that's because of _the traverse definition_.
22:17:38 <koz_> I cannot stress enough just how much it matters.
22:17:53 <Axman6> returning Nothing anywhere from the function passed to traverse causes the result to be Nothing, since that's what the applicative instance for Nothing requires
22:17:56 <Axman6> uh, for Maybe
22:18:35 <crestfallen> right. let me re-paste one sec
22:18:36 <koz_> Axman6: Well, assuming it's not conditional on the values 'in' the Traversable somehow.
22:18:41 <Axman6> iun traverse fn (Con a)   = Con <$> (fn a), if fn returns Nothing, then the Con being fmapped over that Nothing still gives you as Nothing
22:19:04 <Axman6> @src Functor @Maybe
22:19:04 <lambdabot> Source not found. Do you think like you type?
22:19:35 <koz_> Sassy lambdabot.
22:20:04 <crestfallen> sorry just to keep a reference http://ix.io/2CfX
22:20:12 <Axman6> fmap f (Just a) = Just (f a); fmap _ Nothing = Nothing
22:23:56 <crestfallen> so the first Just in aa is the constructor for Maybe Tree a. the second Just : else (Just 0) is actually being fmapped over
22:25:27 <crestfallen> Axman6: am I correct?
22:25:41 <Axman6> I don't think so, you seem very confused
22:27:38 <Axman6> I think you need to step through this line by line: traverse bb (Add (Add (Con 3) (Con 4)) (Con (-5))) ==> Add <$> traverse bb (Add (Con 3) (Con 4)) <*> (Con (-5)) ==> ???
22:28:08 <crestfallen> Axman6: no I get it. in aa there is no failure at all. so (Con a) on the right hand branch is going to take the 0.
22:28:10 <Axman6> just keep substituting the definitions for traverse, once you have none left, substitute in the definition for bb, in the Con 9 case
22:28:19 <dminuoso> TIL, operator dont have to be functions. :>
22:28:33 <dminuoso> % (.>>) = ">>"
22:28:33 <yahb> dminuoso: 
22:28:47 <Axman6> % :t (%)
22:28:48 <yahb> Axman6: Integral a => a -> a -> Ratio a
22:28:56 <Axman6> % :t (.>>)
22:28:56 <yahb> Axman6: [Char]
22:29:14 <koz_> Oh wow, TIL indeed.
22:29:33 <Axman6> crestfallen: I would _strongly_ recommend you go the evaluation by hand I suggested above
22:29:46 <dminuoso> Im using this in a code generator with haskell-src-exts, such that I can do
22:30:26 <dminuoso> let (.>>) = op (sym ">>") in infixApp fooE (.>>) barE 
22:33:09 <dminuoso> (Though ultimately I think Im going to use QQ instead, since [hs| $fooE >> $barE |] is a bit more readable)
22:35:09 <dsal> :t infixApp
22:35:11 <lambdabot> error: Variable not in scope: infixApp
22:36:12 <koz_> dminuoso: I recently wrote my first quasi-quoters, and it was honestly rather pleasant.
22:36:27 <dsal> oooh
22:38:44 <dminuoso> koz_: Yeah, Im fond of QQ myself. I have some for IP/mac literals, especially in tests this is convenient. :)
22:39:17 <koz_> I'm definitely adding them to my arsenal for the future.
22:39:25 <dminuoso> http://hackage.haskell.org/package/hexquote-0.1/docs/Data-Hex-Quote.html this is a cute one as well
22:39:33 <dminuoso> That find usage in one of my projects tests a lot
22:43:11 <crestfallen> Axman6: koz_:  please look at > traverse bb list   http://ix.io/2Cg1
22:51:51 <Axman6> wretchswollen: what about it?
22:53:10 <Axman6> wretchswollen: try using this: bb x = if even x then Right (x `div` 2) else Left (show x)
22:54:37 <dminuoso> wretchswollen: You seem to be confusing Traversable with Filterable (see `witherable` package)
22:55:12 <dminuoso> (A poor mans witherable on just [] is `mapMaybe` in case you are looking for that)
22:56:26 <dminuoso> (Or I guess Witherable rather than Filterable)
22:57:47 <wretchswollen> with list each member needs to be even. so if it's traverse bb [2,4,6] then we get Just [1,2,3]. so the program doesn't get to the else statement
22:59:02 <wretchswollen> it builds Maybe List a without getting to the else statement
22:59:27 <dminuoso> wretchswollen: `Nothing` *is* Maybe [Int] too
22:59:50 <Axman6> wretchswollen: why won';t you do the thing I've now told you three times you should do? step. through. the. functions. by. expanding. their. definitions
23:00:02 <Axman6> you will see what's happening nearly immediately
23:00:19 <Axman6> but instead yuou keep asking the same question and not understanding the answers
23:00:41 <dsal> To write good code, one must become one with the compiler.
23:00:41 <Axman6> you have the wrong intuition, you can fix than by actually stepping through the evaluation
23:01:10 <Axman6> I started the work for you, all you need to dfo is contunue it
23:01:13 <Axman6> continue*
23:02:02 <wretchswollen> theres a lot going on. 
23:02:07 <Axman6> yes
23:02:12 <Axman6> so you take it one step at a time
23:02:16 <Axman6> like I told you to
23:02:42 <wretchswollen> I don't have scrollback on this blasted chat client
23:02:50 <Axman6> I think you need to step through this line by line: traverse bb (Add (Add (Con 3) (Con 4)) (Con (-5))) ==> Add <$> traverse bb (Add (Con 3) (Con 4)) <*> (Con (-5)) ==> ???
23:02:52 <dminuoso> wretchswollen: Check the topic
23:02:55 <dminuoso> We have a log.
23:03:36 <Axman6> @where paste
23:03:36 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
23:06:50 <Axman6> wretchswollen: https://paste.tomsmeding.com/7TIQdWo7
23:07:17 <Axman6> I took a few steps at a time there, you can spread it out more if you want
23:09:22 <wretchswollen> Axman6: thanks so much. I should probably revisit this tomm. dminuoso thanks kindly
23:13:15 <wretchswollen> Axman6: yeah ok so doing > traverse aa (Con (-5)) ==> Just (Con 0)
23:15:31 <Axman6> yes
23:15:58 <Axman6> which is _exactly_ what the definition of traverse says will happen if your applicative is Maybe
23:16:36 <wretchswollen> so what happens is essentially:    Just (Add (Add (Con 8) (Con 9))) <*> Just (Con 0)
23:17:04 <wretchswollen> hold on checking that..
23:17:13 <Axman6> sort of, the Add <$> is needed in front of that to make it type check
23:17:32 <Axman6> you get Add <$> Just (Add (Add (Con 8) (Con 9))) <*> Just (Con 0)
23:21:01 <wretchswollen> that's pretty interesting thanks Axman6 
23:21:02 <Axman6> which becomes Just (\x -> Add (Add (Add (Con 8) (Con 9))) x) <*> Just (Con 0)
23:21:19 <Axman6> % :t (<*> @Maybe)
23:21:19 <yahb> Axman6: ; <interactive>:1:6: error: parse error on input `@'
23:21:24 <Axman6> % :t (<*>) @Maybe
23:21:24 <yahb> Axman6: Maybe (a -> b) -> Maybe a -> Maybe b
