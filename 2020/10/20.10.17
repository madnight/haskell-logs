00:17:49 * hackage Z-Data 0.1.7.2 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.7.2 (winterland)
01:05:20 * hackage Z-IO 0.1.6.0 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.6.0 (winterland)
01:06:19 * hackage stm-queue 0.1.2.1 - An implementation of a real-time concurrent queue  https://hackage.haskell.org/package/stm-queue-0.1.2.1 (sgschlesinger)
01:50:48 <tomsmeding> why does ghc, when giving me an error about an ambiguous type variable, not tell me where that type variable occurs?
01:51:07 <tomsmeding> if that happens in a large expression it's less than helpful :p
01:56:49 * hackage numhask-space 0.6.1 - numerical spaces  https://hackage.haskell.org/package/numhask-space-0.6.1 (tonyday567)
01:57:25 <Rembane> tomsmeding: Doesn't it? Do you have an example? :) 
01:57:41 <tomsmeding> well I have a huge one :p
01:59:24 <tomsmeding> Rembane: https://paste.tomsmeding.com/oKOtSj3l
02:00:17 <Rembane> tomsmeding: Yeah, that's not small, what would GHC say if you had your way? 
02:00:42 <tomsmeding> well presumably it's trying to help me by saying "the constraint (Elt x00)"
02:01:31 <tomsmeding> if the x00 would occur somewhere else in a larger type too, then I'd like it to print the entire type (just "Elt x00" tells me nothing about where this x00 comes from)
02:01:39 <tomsmeding> but now I realise that perhaps it _only_ occurs in this constraint
02:02:30 <Rembane> I think it only exists in this constraint 
02:02:57 <tomsmeding> but in that case it would be nice if it said that this type variable occurs _only_ in a constraint -- because that particular situation is something you never want anyway, I think
02:03:06 <tomsmeding> also that would be weird
02:03:14 <tomsmeding> given the code, let me see if I can distill a smaller case
02:03:32 <Rembane> Sounds like a good approach
02:03:50 * hackage hw-json 1.3.2.2 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-1.3.2.2 (haskellworks)
02:05:22 <nshepperd> arising from a use of zipWith? is this some sort of nontraditional exotic zipWith? not the list one
02:05:53 <tomsmeding> it certainly is :)
02:07:02 <nshepperd> i think you'll find that type variable occurs in the type of your exotic zipWith
02:07:10 <nshepperd> in that case
02:07:59 <tomsmeding> nshepperd: true enough, but it has three Elt constraints: https://hackage.haskell.org/package/accelerate-1.3.0.0/docs/Data-Array-Accelerate.html#v:zipWith
02:08:10 <tomsmeding> so basically my point is: constraint "Elt x00", okay, _WHICH_ Elt :p
02:10:24 <tomsmeding> ah there is a different case, look at this: https://paste.tomsmeding.com/b8b4SRuW
02:10:55 <tomsmeding> look at it giving a _different_ binding than what the problematic type variable occurs in, showing that indeed the variable occurs outside of the constraint
02:11:06 <tomsmeding> (note a40f != a40)
02:11:56 <tomsmeding> now I guess I'd like to see the type of a40f with that type variable x10 shown where it occurs (because it must; a40 is defined fairly trivially in terms of a40f)
02:12:49 <tomsmeding> (indeed now I know it's that particular tuple element, I know how to solve it :p)
02:13:45 <nshepperd> yeah i guess it would be nice if it printed the type signature of zipWith with the ambiguous variable highlighted or something
02:14:07 <Rembane> I wonder if there's an issue on the GHC bug tracker about this, or if it's worth posting one.
02:14:17 <tomsmeding> precisely (though highlighting is not even the primary concern :p)
02:20:57 <Rembane> Yeah, it's an x/y one. :) 
02:26:43 <tomsmeding> okay this is a more minimal case: https://paste.tomsmeding.com/jvWCizUj
02:26:53 <tomsmeding> no deps
02:27:20 <tomsmeding> do people agree that error is uninformative?
02:29:01 <tomsmeding> in particular: there are two Elt constraints around: one on map' and one on constant'. It's not indicating which is the problem; in this case it doesn't really matter, but in a more complex scenario that may be useful information
02:29:48 <tomsmeding> "a40f = map' (constant' 2.0)" is a better replacement of the last two lines, no need for the "id" indirection
02:35:02 <Rembane> tomsmeding: In this case I can manage because I can see everything that creates this error, but in your earlier case I would've loved to have some more help from the compiler. 
02:35:53 <Rembane> tomsmeding: This all boils down to, post in on the issue tracker please. :) 
02:39:00 <tomsmeding> I can post it; I feel uncertain whether there is an existing issue about it, given that there are 4k+ issues open :p
02:40:37 <tomsmeding> this is a feature_request, isn't it?
02:42:04 <Rembane> tomsmeding: I think it is, blame me if it isn't. :) 
02:44:31 <phadej> doesn't that error happen because 2.0 is arbitrary Fractional a => a
02:44:44 <phadej> if you do (2.0 :: Double) it will "go away", or at least say Elt Double cosntraint?
02:45:33 <phadej> I don't think its uninformative, it's a literal gotcha
02:47:12 <phadej> in the minimal example, it's the same `Elt a` which is unsatisfied, i.e. it could come from either map' or constant'
02:47:28 <phadej> as `a`s are unified
02:47:46 <tomsmeding> phadej: true, it's about the literal, but it could equally be a variable with type Fractional a => a
02:48:06 <phadej> tomsmeding: more concretely, what you think GHC should say
02:48:23 <tomsmeding> the point is: what if there were a number of such literals, and most could be inferred based on external information except one. Which one is it? The error message doesn't tell.
02:49:38 <tomsmeding> phadej: for errors reading "... (mentions type variable a0) ... arising from a use of â€˜myFunctionâ€™, ...", I'd like to see the type of myFunction, that includes a0
02:49:53 <tomsmeding> because presumably a0 is in there :p
02:53:36 <phadej>  arising from a use of â€˜a40fâ€™ at type 'a40f :: (Elt a0, Fractional a0) => (Exp a0 -> Exp a0) -> ()'
02:53:39 <phadej> ?
02:54:07 <phadej> yes, that could be reasonable feature request
02:54:46 <tomsmeding> yes that; I'll see if I can make a more compelling example
02:54:50 <phadej> this example is a bit too minimal, as `a40f` has only one variable
02:56:50 <phadej> something with (Integral a, Integral b) => ...
02:56:55 <phadej> and used so you flip arguments
02:57:05 <phadej> so you aren't sure anymore whether a0 was actually b
02:59:14 <phadej> except integral will be defaulted :(
03:00:08 <tomsmeding> that can be fixed with a custom class :p
03:00:34 <tomsmeding> I had an example where the variable got an obscure name from somewhere, let me see if I can resurrect that one
03:03:05 <phadej> https://gist.github.com/phadej/7b95d1876dd085d28f49bf4ebf349663
03:03:26 <phadej> here it's unclear is "MyIntegral b1" is from 1 or 2
03:04:09 <phadej> in fact, type of plus2 is
03:04:10 <phadej> plus2 :: (MyIntegral b1, MyIntegral b2) => b2 -> b1 -> b1
03:04:17 <tomsmeding> yes that's a neat one
03:04:41 <phadej> tomsmeding: I have to admit, I have sometimes scratched my head what's wrong in similar-ish examples
03:04:48 <phadej> and had to add extra type-signatures to figure out what
03:05:04 <phadej> as here. The obvious solution is to add a type-signature to plus2
03:05:13 <phadej> (with better type-variables)
03:05:32 <phadej> but if you open an issue you have to argue why you cannot or don't want do that in non-minimal example :)
03:06:08 <phadej> I guess saying that "annotating every auxiliary bindingin in accelerate code isn't acceptable, adds too much noise"
03:06:48 <tomsmeding> that latter statement is certainly the case
03:06:55 <phadej> in my case, when there are type-variables brought into the scope by pattern matching on GADTs, it was in fact very tricky to just add a type-signatures
03:07:20 <phadej> as one had to re-arrange code to get this type-variables
03:08:57 <phadej> (https://github.com/ghc-proposals/ghc-proposals/pull/126 would solve it, but I have no idea if anyone is working on it)
03:10:12 <phadej> you concinced me there is a problem worth fixing :)
03:10:24 <phadej> go ahead, open an issue!
03:10:40 <tomsmeding> :D
03:15:39 <tomsmeding> phadej: https://gitlab.haskell.org/ghc/ghc/-/issues/18860
03:16:04 <tomsmeding> probably could be worded better, so if you want to re-word stuff / tell me to re-word stuff, go ahead :p
03:16:46 <phadej> +1
03:16:56 <phadej> IMO it's fine
03:17:03 <phadej> let see if others see the problem :)
03:35:04 <gopher----> hi
03:35:09 <gopher----> is anyone a dev in here?
03:36:07 <gopher----> btw
03:36:15 <gopher----> haskell is absolute gobshite
03:38:14 <Axman6> gopher----: yeah it is
03:38:22 <gopher----> yep
03:38:28 <gopher----> its horribal
03:39:09 <[exa]> ...but isn't that the fundament of the existence?
03:39:21 <gopher----> haskell is massive shit
03:39:23 <Axman6> we are all but gobshite
03:39:59 <Axman6> gopher----: trolling works better if you make some arguments, and not just whinge because you're doing badly in a university assignment
03:40:17 <gopher----> haskell is mega bs
03:40:46 <Axman6> GHC is definitely several hungres megabytes, so it might even be giga bs!
03:40:51 <Axman6> hundred*
03:41:02 <gopher----> niga
03:41:17 <Axman6> come on mate, try harder, this is embarassing
03:41:23 <no-n> gopher----: which language do you prefer?
03:41:32 <gopher----> a non blm supported lang
03:41:49 <no-n> oof
03:42:21 <Axman6> damn, I knew we should have voted against -XBlackLivesMatter
03:42:43 <gopher----> yes
03:42:49 <gopher----> dem cotton pickers
03:43:52 <gopher----> yup
03:43:56 <Axman6> I reckon PHP might not be a BLM supported language, maybe you should try that? It's not very supported at all these days
03:44:21 <gopher----> php ss on every major website
03:44:23 <gopher----> is
03:45:05 <Axman6> is it tho???
03:45:43 <gopher----> yup
03:45:52 <gopher----> on most commercial grade apps
03:45:56 <gopher----> banking sites
03:46:09 --- mode: ChanServ set +o dibblego
03:46:12 --- mode: dibblego set +b *!*@2a03:1b20:3:f011::4d
03:46:12 <Axman6> I think you're misspelling ASP.Net
03:46:15 --- kick: gopher---- was kicked by dibblego (gopher----)
03:46:18 --- mode: ChanServ set -o dibblego
03:46:34 <Axman6> dibblego: Sorry mate, things were quiet =)
03:46:57 <dibblego> :)
03:50:22 <jophish> nh2: How are things going with static haskell nix?
04:26:38 <tomjaguarpaw> jophish: How are things going with dynamic python windows installer?
04:32:55 <jophish> dynamic python windows installer? tomjaguarpaw 
04:33:30 <jophish> sounds pretty horrible all round
04:36:26 <jophish> Ah, I understand!
04:37:06 <jophish> tomjaguarpaw: poorly enough that I'm looking forward to the alternative!
04:58:05 <arahael> ANd that alternative is: "Anything else!" ;)
05:04:16 <tomjaguarpaw> jophish: We should play a game some time
05:16:03 <jpcooper> Hello. The documentation for ShowS (https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:ShowS) mentions constant time concatenation of Strings. How does this work if Strings are just [Char]?
05:19:52 <Cheery> jpcooper: it's how it is accessed.
05:19:57 <jophish> tomjaguarpaw: I would like that very much
05:20:13 <jpcooper> Cheery: Yes good point. Thanks. Should have worked it out in my head
05:20:45 <jophish> tomjaguarpaw: I've been taking photos recently, if you'd like to look at an album: https://photos.app.goo.gl/yUVCPMRnks8cP4fHA
05:21:29 <Cheery> jpcooper: you only need the first value when the structure is being accessed.
05:22:35 <phadej> jpcooper: https://wiki.haskell.org/Difference_list
05:24:09 <jpcooper> Makes sense. Thanks
05:24:39 <phadej> https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/lists.pdf 
05:24:42 <phadej> very old idea :)
05:24:46 <Cheery> for x ++ y, if x=(z:xs), then x ++ y = z:xs++y.
05:25:19 * hackage polysemy-video 0.1.1.0 -   https://hackage.haskell.org/package/polysemy-video-0.1.1.0 (locallycompact)
06:13:13 <JordiGH> take 100 $ [fib_0*fib_3 - fib_1*fib_2 | fib_0:fib_1:fib_2:fib_3:_ <- tails fibs] where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
06:13:19 <JordiGH> Why is that a syntax error?
06:13:33 <JordiGH> Is it because I need newlines?
06:13:42 <JordiGH> I don't understand where I can use `where`.
06:14:18 <ski> JordiGH : `where' attaches to definition, not expressions
06:14:20 <geekosaur> `where` is part of declaration syntax, not something you can attach to just any expression
06:15:32 <ski> you could use `let fibs = ... in take 100 [...]'
06:15:47 <JordiGH> Is that because I can use = with let but not with where?
06:15:57 <JordiGH> Is that a definition or an expression?
06:16:09 <ski> `let ... in ...' is an expression
06:16:13 <Guest29616> Hello. Since i added sockaddr as a dependency of my stack project, stack build is displayid me an error saying i need to add a line on extra-deps field. But when i do, then it say that extra-deps field is not recognized. I dont get it :/  Herer is the error and my package.yaml :
06:16:13 <Guest29616> https://pastebin.com/68kGhcKJhttps://pastebin.com/68kGhcKJhttps://pastebin.com/68kGhcKJhttps://pastebin.com/68kGhcKJ
06:16:15 <JordiGH> But there's an =
06:16:20 <JordiGH> An = is not a definition?
06:16:32 <Guest29616> https://pastebin.com/68kGhcKJ sorry
06:16:37 <ski> yes, the part between the `let' and the `in' can contain defining equations
06:16:49 <ski> but the whole thing is still an expression
06:16:57 <JordiGH> So expressions can contain definitions?
06:17:08 <JordiGH> I can't write an expression that contains a where definition?
06:17:17 <ski> (cf the expression `(let ((fibs ...)) ..fibs..)' in the Lisps)
06:17:20 * hackage nix-thunk 0.2.0.0 - Lightweight dependency management with Nix  https://hackage.haskell.org/package/nix-thunk-0.2.0.0 (RyanTrinkle)
06:17:44 <ski> you can, but then that `where' have to be attached to a defining equation (or a `case' branch), inside that expression
06:18:02 <ski> you can go `let foo = ..x.. where x = ... in ..foo..'
06:18:14 <JordiGH> Haskell doesn't distinguish statements from expressions, does it?
06:18:27 <ski> (you can also do `case ... of x:xs -> ..x..xs..y.. where y = ..x..xs..')
06:18:33 <JordiGH> Definitions seem like statements, sort of.
06:18:51 <ski> definitions are not commands
06:19:05 <ski> (commands are what you write after `do')
06:19:28 <JordiGH> Hm, okay.
06:19:56 <ski> (statements, i'd say, is what you write in Prolog. like `mother(bob,eliza).')
06:20:00 * JordiGH = https://www.youtube.com/watch?v=KdxEAt91D7k
06:20:50 <ski> (statements of fact, and conditional statements like "Mothers are parents.", `parent(Person,Mother) :- mother(Person,Mother).')
06:22:26 <JordiGH> I think I'm trying to picture Haskell syntax as sexps and failing.
06:23:19 <JordiGH> And I thought "do" wasn't a real thing, just some kind of sugar for something else.
06:23:48 <JordiGH> Like, you could translate every "do" into something else that didn't require, uh, "commands".
06:23:55 <geekosaur> it is sugar. I would have described it more that the inside of a do pretends to be commands
06:24:01 <JordiGH> So, do is just a reader macro.
06:24:22 <geekosaur> but trying to shoehorn haskell into scheme syntax won't get you very far, I think
06:25:22 <geekosaur> I mean,in some sense typeclasses are also sugar, but you can't do it with a reader macro
06:26:01 <ski> `do ...' itself is an expression, yes
06:28:30 <ski> (there has been `do'-macros defined in Scheme, fwiw ..)
06:37:12 <JordiGH> I'm identifying so hard right now with that kid who can't subtract.
06:40:31 <ski> the syntax ?
06:51:54 <bifunc2> Is it appropriate to put an integration test into an HUnit testCase?
07:34:21 <zincy__> Is it correct to refer to the parameter in Maybe's type constructor as a polymorphic type variable?
07:35:07 <L29Ah> s/polymorphic//
07:35:37 <zincy__> Does that mean delete the word?
07:36:11 <L29Ah> yes
07:37:13 <zincy__> Ok thanks
07:39:10 <ski> zincy__ : not polymorphic
07:40:18 <zincy__> ski: Maybe I dont understand what polymorphism is but when I see a type variable I just think oh look polymorphic
07:40:23 <zincy__> Is that misguided?
07:40:25 <ski> (parametric types begets polymorphic operations on such types. so there is a relation)
07:41:07 <ski> `length' is polymorphic. its type `[a] -> Int' is not polymorphic (nor is the type variable `a', in that type, polymorphic)
07:41:37 <zincy__> Oh so polymorphism refers to operations on values of different types
07:42:03 <zincy__> Whereas type variable is just about representation 
07:42:09 <ski> the explicit type of `length' is `forall a. [a] -> Int'. Haskell allows you to leave out the `forall' in source, and it'll be inserted implicitly by the language. but it's always, conceptually, there
07:42:33 <ski> a value is polymorphic if and only if it has a type of general shape `forall a. ..a..'
07:42:45 <zincy__> Ah thanks!
07:43:09 <ski> just like a value is a list if and only if it has a type of general shape `[...]'. or is a function if and only if it has a type of general shape `... -> ...'
07:43:16 <zincy__> So just functions can be polymorphic?
07:43:37 <ski> no. e.g. `Nothing' is not a function, but is still polymorphic. has type `forall a. Maybe a'
07:44:17 <zincy__> Is Nothing not a data constructor and data constructors are functions?
07:44:29 <ski> not all deata constructors are functions, no
07:44:47 <ski> `Nothing' doesn't have a type that looks like `... -> ...'. hence it's not a function
07:45:27 <zincy__> So only data constructors which are parameterised by at least one other value are functions?
07:45:35 <ski> in fact, strictly speaking, `Just' isn't a function, either. it has type `forall a. a -> Maybe a'. it's a "polymorphic value (that when specialized, will become a function)"
07:46:00 <ski> yes, data constructors which take arguments, which "pack data fields", are functions
07:46:28 <ski> (or, in this case, "polymorphic functions", meaning "polymorphic value, that when specialized, will become a function")
07:46:45 <zincy__> So forall a. id :: a -> a   isn't a function?
07:46:55 <zincy__> Until you parameterise the `a`?
07:47:40 <ski> strictly speaking, it's not a function. but if we take `id :: forall a. a -> a', and specialize this, replacing `a' by `Bool' say, we get `id :: Bool -> Bool', which is a function
07:48:12 <zincy__> Thanks, I have upgraded my thinking
07:48:24 <ski> one perhaps confusing part here is that the specializing of a polymorphic value is written as nothing, in the syntax. we still write `id'. but conceptually, it's an operation
07:48:29 <zincy__> And to think I understood data constructors and Maybe :D
07:48:43 <ski> (with a language extension, you can actually write `id @Bool' for this)
07:49:21 <zincy__> Yeah so the polymorphic value becomes a function at some point during run time
07:50:06 <ski> you can think of it as being a kind of expression node, in the abstract syntax tree in the implementation. it's just that it's (usually) written as nothing, in the source code
07:50:47 <zincy__> Ah thanks
07:51:49 * hackage path-io 1.6.1 - Interface to â€˜directoryâ€™ package for users of â€˜pathâ€™  https://hackage.haskell.org/package/path-io-1.6.1 (mrkkrp)
07:52:33 <ski> something like `data Exp | Var Ident | Con Ident | App Exp Exp | Spec Exp Typ | ...' with `data Typ = TyVar Ident | TyCon Ident | Fun Typ Typ | Forall Ident Typ | ...'
07:52:36 <zincy__> So is the general shape the same for parametric and adhoc polymorphism?
07:52:51 <zincy__> Or is the difference there just the behaviour of the operation
07:53:46 <ski> you could represent an expression like `not (id False)', using this AST, as `App (Var "not") (App (Spec (Var "id") (TyCon "Bool")) (Con "False"))'
07:54:16 <ski> zincy__ : the difference is that the latter also involve type class constraints
07:54:30 <zincy__> Ok gotcha
07:54:56 <ski> `sort :: forall a. Ord a => [a] -> [a]' means `sort :: forall a. ((Ord a) => ([a] -> [a]))'
07:55:06 <zincy__> So will that AST be reqritten when the `a` is specialised?
07:55:20 <zincy__> And when would the rewriting occur?
07:55:22 <ski> `... => ...' is a separate operation on types. you could call it the type of overloaded operations, i suppose
07:56:17 <zincy__> Interesting
07:57:30 <ski> well, in that example, `Var "id"' would be classified as having the type (namely `forall a. a -> a') expressed by `Forall "a" (Fun (TyVar "a") (TyVar "a"))'
07:58:58 <ski> specializing that to `Bool', we have that `Spec (Var "id")' is classified by `Fun (TyCon "Bool") (TyCon "Bool")'
08:00:33 <ski> i'm not sure if the rewriting you have in mind would correspond to reducing/evaluating expressions .. or maybe you were thinking of the substitution (in the type, replacing the type variable with some other type) when specializing a polymorphic value
08:02:04 <zincy__> The latter
08:03:12 <ski> that substitution (in the type) happens during type-checking
08:03:28 <zincy__> So a nullary data/type constructor shouldn't be thought of as a function but just a plain  value/type
08:03:38 <zincy__> Ah ok
08:04:16 <zincy__> Because I used to think of nullary constructors as functions of 0 parameters
08:04:20 <ski> (you could imagine a corresponding substitution, in the implementation of e.g. `sort', that would be happening (conceptually) at run-time. it's just that with a type-erasing implementation, this would corresponds to a no-op)
08:04:39 <ski> yea, all functions take exactly one argument, in Haskell
08:05:00 <ski> if a value doesn't have a type that looks like `... -> ...', it's not a function
08:05:09 <zincy__> Ah great thanks
08:06:08 <ski> it's another thing that, because of Haskell's non-strict semantics, you can define a value, like e.g. with `ones = 1 : ones', whose computation won't happen yet, until its result is demanded
08:07:09 <ski> in a strict language, the only way to delay a computation like this, tends to be to define a function. but that's not the case in Haskell
08:08:35 <ski> if you want to, you could say that general values, in Haskell, can be implemented by a procedure, that, when executed/followed, will produce the demanded result (typically a data constructor, to be matched on)
08:08:57 <ski> but that's an implementation detail, not a property of Haskell itself
08:09:32 <ski> (but sometimes people try to express this, by saying that "everything in Haskell is a function", or something like that)
08:10:59 <zincy__> So values with lazy semantics are represented by procedures which yield a value 
08:11:21 <zincy__> But functions are concrete values which are yielded by such procedures
08:12:00 <zincy__> As in functions are specific values but in the first line I was talking about general values
08:12:17 <ski> (careful to distinguish values at the level of the language, from .. i suppose, let's call them "tokens" .. at the level of the implementation)
08:17:12 <zincy__> Yeah
08:19:24 <lightwave> Hello everyone. Newbie here. Going down the Haskell highway without wearing a seat belt.
08:19:44 <ski> hello lightwave
08:20:19 <lightwave> hi ski
08:20:59 <lightwave> Any Doom Emacs user here?
08:21:00 <ski> do you have any questions, so far ?
08:22:02 <lightwave> ski, I'm trying to get my Doom Emacs Haskell LSP module setup but having a confusion in Haskell-language-server installation.
08:22:26 * ski hasn't tried getting LSP working
08:22:55 <lightwave> It seems Haskell-langauge-server can be installed with ghcup but I came across some advice against using ghcup.  Is there a way to install Haskell-language-server with Stack?
08:22:58 <ski> (if you wait a bit, perhaps someone else who's tried that could give some advice)
08:23:10 <lightwave> ski, what do you use? Dante?
08:23:52 <maerwald> lightwave: what was that advice?
08:24:06 <maerwald> (against using ghcup, that is)
08:25:03 * ski just uses basic `haskell-mode'
08:26:00 <lightwave> maerwald, here is the link. https://mail.haskell.org/pipermail/haskell-community/2015-September/000014.html
08:26:56 <maerwald> I don't see ghcup discussed there
08:27:17 <maerwald> that's a post from 2015
08:27:25 <lightwave> maerwald, is ghcup not the same as 'Haskell Platform'?
08:27:27 <maerwald> no
08:27:57 <lightwave> So, ghcup doesn't install a global ghc and packages along with it?
08:27:58 <maerwald> I don't even know what haskell platform is these days
08:28:13 <maerwald> lightwave: it installs ghc and cabal into ~/.ghcup
08:28:16 <maerwald> nothing else
08:28:26 <lightwave> Haskell.org points Haskell Platform to ghcup.
08:28:37 <lightwave> Very confusing for newbie. :-)
08:28:38 <maerwald> yes, it's a mess of page redirections and confusion
08:28:48 <maerwald> I raised that several times, there's no action
08:30:08 <maerwald> https://github.com/haskell-infra/www.haskell.org/issues/12
08:30:41 <lightwave> Are those libraries/packages in ~/.ghcup/ghc/8.8.4/lib/ghc-8.8.4 not going to cause potential conflicts down the road for me?
08:31:00 <maerwald> no, those are always shipped with GHC, no matter how you install
08:31:35 <lightwave> I feel less stressed now. ðŸ™‚
08:31:39 <maerwald> :D
08:32:54 <lightwave> It drives me nut when I don't know if I'm potentially shooting myself in the foot especially when there is some voice in the Internet warning me loudly in my head.
08:33:13 <maerwald> Paranoia is a virtue
08:46:49 * hackage req 3.7.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.7.0 (mrkkrp)
08:55:47 <monochrom> How could the Internet be in your head?
08:55:56 <maerwald> a terrifying thought
08:57:06 <monochrom> "The Phaaaaaaan, tom of the Internet is theeeeeeeere. In siiiiide my mind!"
08:59:22 <monochrom> Haskell Platform is now a historic relic.
09:04:19 <MarcelineVQ> It belongs in a museum!
09:04:29 <lightwave> monochrom, my wife says I have a big head.
09:04:38 <maerwald> xd
09:04:44 <monochrom> Megamind
09:29:19 * hackage haskell-exp-parser 0.1.4 - Simple parser parser from Haskell to TemplateHaskell expressions  https://hackage.haskell.org/package/haskell-exp-parser-0.1.4 (EmilAxelsson)
09:49:49 <maerwald> https://paste.tomsmeding.com/N28qCrM3 is there a more efficient way to write this? (with efficient I mean faster/better optimized, not golfing)e
09:51:00 <opqdonut> looks pretty optimal to me
09:51:04 <phadej> maerwald: chunksOf -- no
09:51:16 <opqdonut> given lists
09:51:37 <phadej> https://hackage.haskell.org/package/extra-1.7.8/docs/src/Data.List.Extra.html#chunksOf
09:52:09 <maerwald> that looks pretty much the same, yeah
10:05:19 * hackage joint 0.1.8 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.8 (iokasimovmt)
10:27:41 <Kira_> Greetings
10:27:47 <lightwave> Hello Kira
10:27:57 <Kira_> Helloo
10:30:26 <lightwave> newbie question: If one stack install hoogle or something else from one stack project and then stack install hoogle from another stack project. The hoogle binary will be overwritten in ~/.local/bin. If two different stack projects are using two different LTS version and hence two GHC versions, how do you ensure each sandbox project has its own versioned Hoogle binary?
10:31:19 <phadej> version of hoogle binary itself doesn't matter
10:31:50 <phadej> (except I don't know how compatible databases are)
10:32:05 <phadej> but having just one hoogle binary will make your life easier
10:33:19 <geekosaur> what should happen is it gets installed in a project-specific exec directpry and then symlinked to ~/local/bin, then use stack exec to run hoogle within each project to ensure its specific hoogle is run. although as phadej says it'll all go easier if you can get away with running one version globally
10:35:01 <Kira_> I've havent organized myself to continuously keep practicing haskell, but little by little I think Im understanding the language. Finally when attempting to finish my tiny dummy login, I attempted to do the following:
10:35:09 <Kira_> https://pastebin.com/0DTLpFrW
10:35:31 <Kira_> but Im getting the error noted at the end of the pastebin ^:
10:36:02 <Kira_>     â€¢ Couldn't match type â€˜Loginâ€™ with â€˜HashMap Text Valueâ€™
10:36:05 <Kira_>       Expected type: Object
10:36:07 <Kira_>         Actual type: Login
10:36:09 <Kira_>     â€¢ In the first argument of â€˜(.:)â€™, namely â€˜loginâ€™
10:37:04 <Kira_> in Yesod do we obtain the values of keys of a JSON in a different way?
10:38:08 <geekosaur> it's not a json at that point, but a Haskell value
10:39:52 <geekosaur> or at least that's what you have told it with the type `Handler Login`
10:47:11 <a1c3> :t
10:47:16 <Kira_> hmmm
10:47:24 <Kira_> so then I should transform my Handler Login into a 
10:47:27 <Kira_> Login
10:47:51 <Kira_> and then, obtain the property email, from this Login
10:47:56 <geekosaur> requireCheckJsonBody presumably did that
10:48:08 <monochrom> You already have your Login.
10:48:11 <geekosaur> so you just want to extract the email field from the resulting Haskell value
10:50:20 <Kira_> Yup, you guys were right
10:50:41 <Kira_> like this:
10:50:43 <Kira_> postUserLoginR :: Handler Value
10:50:46 <Kira_> postUserLoginR = do
10:50:48 <Kira_>  login <- requireCheckJsonBody :: Handler Login
10:50:50 <Kira_>  let usermail = email login
10:50:52 <Kira_>  sendStatusJSON ok200 (object [ "login" .= usermail ] )
10:50:54 <Kira_> the method compiles
10:50:57 <Kira_> the project *
10:51:17 <Kira_> and then, when performing a POST request, I now get the user email
10:51:45 <Kira_> as {"login": "foo@mail.com"}
10:51:53 <Kira_> Thank you all!
10:59:49 * hackage less-arbitrary 0.1.0.0 - Linear time testing with variant of Arbitrary class that always terminates.  https://hackage.haskell.org/package/less-arbitrary-0.1.0.0 (MichalGajda)
11:05:49 * hackage less-arbitrary 0.1.0.1 - Linear time testing with variant of Arbitrary class that always terminates.  https://hackage.haskell.org/package/less-arbitrary-0.1.0.1 (MichalGajda)
11:09:49 <monochrom> aaarrrggghhh they forgot to include less-arbitray.md
11:11:18 <monochrom> OK nevermind, probably intended.
12:02:45 <masamasa> haskell is fooking shite
12:05:54 <maerwald> this seems to be a recent meme
12:06:46 <maerwald> I wonder if these are the fruits of a failed course
12:07:03 <masamasa> fak u
12:07:10 <geekosaur> or "fruit" singular
12:07:47 <maerwald> masamasa: I respectfully decline
12:08:17 --- mode: ChanServ set +o monochrom
12:08:19 --- mode: monochrom set +b *!*@2a02:20c8:4124::1d
12:08:19 --- kick: masamasa was kicked by monochrom (masamasa)
12:08:28 --- mode: monochrom set -o monochrom
12:11:59 <Rembane> Is the fruit from the appetizer, main course or desert? 
12:12:12 <Kira_> wow
12:15:11 <geekosaur> just desserts?
12:15:59 <Rembane> Seems legit, the spice must flow.
12:16:33 <Rembane> Also, I learned the hard way that you need to walk without rhythm and you won't attract the worm. 
12:20:29 <tomsmeding> geekosaur: the three that I remember (including this one) were all different IPs, it seems
12:27:33 <monochrom> Can worms tell whether your walk pattern is cryptographically random or not? :)
12:29:44 <Rembane> monochrom: The high level worms with great taste can. :) 
12:30:11 * geekosaur *eyeroll*
12:41:51 <ddellacosta> wait, did that person leave without anyone converting them into a Haskell fanatic? sad
12:42:43 <koz_> ddellacosta: We only have so much juice.
12:42:48 <[exa]> unbeievable, these difficult times
12:43:00 <ddellacosta> koz_: that's fair
12:43:20 <koz_> And honestly, I don't think we're under any obligation to convince bad-faith trolls.
12:43:35 <koz_> It's not usually even possible.
12:43:49 <ddellacosta> koz_: oh not at all, I just always think of that one legendary exchange with the person who came on here trolling and then decided to check Haskell out for real
12:44:06 <koz_> ddellacosta: Well, sometimes, we can work magic, but honestly, in 2020? We're all tired.
12:44:15 <ddellacosta> koz_: absolutely, I feel that
12:44:59 <ddellacosta> here we are (homophobic language at the beginning, be warned) https://gist.github.com/quchen/5280339
12:46:10 <koz_> ddellacosta: Yeah, I'm familiar.
12:46:58 <ddellacosta> to be fair, in the example I linked to that person was clearly more receptive
12:47:24 <maerwald> he only got kicked from bitcoin-dev
12:47:30 <maerwald> that doesn't seem too hard
12:47:34 <ddellacosta> hahaha
13:03:09 <tomsmeding> that is an absolute gem
13:03:18 <tomsmeding> though indeed the person seemed more receptive
13:26:28 <{abby}> love the lambdabot command to ping all of the ops
14:20:49 * hackage uniqueness-periods-vector-examples 0.13.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.13.0.0 (OleksandrZhabenko)
14:33:29 <CodeWeaver> Got kind of an odd discrepancy in thunk (or maybe seq) behaviour...
14:33:47 <CodeWeaver> for ghci in particular.
14:33:49 <CodeWeaver> https://pastebin.pl/view/b4a4b142
14:34:38 <CodeWeaver> If I run this in the interpreter, in stack ghci, must by asking main to run, q seems to get dethunked once.  You can see the delay as it evaluates.
14:37:10 <CodeWeaver> Stupid disconnect.
14:37:31 <CodeWeaver> If I use foo direction as in foo () in the interpreter, it again dethunks q just once.
14:38:05 <CodeWeaver> But if I paste the let clause _from_ foo directly into the interpreter, it seems to dethunk q muiltiple times.
14:40:10 <jil> Hello, working through theexampls of the book programming in haskel, I run into this problem https://paste.debian.net/1167620/
14:40:12 <CodeWeaver> Funny thing is if I paste the entirety of the foo function (with a preceding let) into the interpreter and run _that_, it seems to dethunk q multiple times there too.
14:40:29 <jil> The type signature for myand lacks an accompanying binding
14:40:32 <CodeWeaver> Hoping someone smarter than me knows why the interpreter behaves differently under these circumstances.
14:41:37 <[exa]> CodeWeaver: weird... monomorphism restriction perhaps?
14:41:50 <[exa]> (not sure if it would apply then though)
14:42:35 <[exa]> jil: you need to say the type for the same identifier that you are defining; ie. there you are typing 'myand' and defining '&&'
14:43:07 <[exa]> jil: if you rename it to:  True `myand` True = True ... etc, it should work
14:43:56 <CodeWeaver> jil: Or corresondingly, (&&) True True = True in the second half, so that you can see you're defining a function more obviously.
14:44:48 <jil> ho I see. thank oyou
14:44:53 <CodeWeaver> exa:  Maybe, but I'm not quite smart enough to work out if that's the case.  There's a subtlety here... loading in that file and evaluating foo (), as opposed to using a let foo _ = ... paste into the interpreter... the distinction eludes me.
14:45:30 <[exa]> CodeWeaver: well, check the types, that should show if you're dreaded by the monomorphism
14:46:01 <CodeWeaver> exa:  Okay, there's a way to do that?  How would I show the distinction?  (My haskell's a bit rusty, and that's above my mental pay grade)
14:46:10 <CodeWeaver> : can use the :t syntax in ghci but I don't know what I"m looking for.
14:46:14 <[exa]> otherwise it's some subtlety in ghci perhaps, I really don't know much about that
14:46:41 <[exa]> CodeWeaver: if it's MR, you will have the type of one binding defaulted, and one with a typeclass
14:47:05 <[exa]> and the typeclass materializes the "invisible" parameter that causes that memoization does not occur
14:47:24 <[exa]> ...or perhaps add explicit type to foo and see
14:47:49 <jil> ho I see. thank you
14:48:13 <CodeWeaver> exa:  Okay, loaded from file, evaluating foo (), where it behaves right, the type is:
14:48:14 <CodeWeaver> foo :: Num a => p -> [a]
14:48:17 <jil> why don't I nee back quote around && ?
14:49:01 <CodeWeaver> jil: because its an operator.  You turn normal functions into operators with the `myadd` syntax, and you turn operators into ordinary functions with the (&&) syntax
14:49:29 <CodeWeaver> exa:  The type for the directly pasted let foo _ = ... line gives:
14:49:30 <CodeWeaver> foo :: Num a => p -> [a]
14:49:46 <CodeWeaver> So, nothing explicitly revealed from :t
14:50:34 <CodeWeaver> Very odd that the dethunking would simply not happen in one case.
14:50:38 <[exa]> CodeWeaver: o good, try forcing the type to p -> [Int]
14:51:12 <CodeWeaver> exa: will do.
14:52:37 <[exa]> anyway I think this might be the whole reason for monomorphism restriction; the parameter appears there automagically and there is no way to really memoize something with a parameter
14:52:59 <CodeWeaver> But I'm not memoizing foo.
14:53:04 <CodeWeaver> I'm memoizing q, inside foo.
14:53:08 <jil> Clear. Thank you
14:53:24 <CodeWeaver> q has no relationship to the 'throwaway value' p.
14:53:50 <[exa]> CodeWeaver: that might vary if you start pulling the code out of context
14:54:00 <[exa]> not sure though
14:54:27 <[exa]> if you specialized the code to Ints and nothing happened, it's likely not the monomorphism restriction
14:54:53 <CodeWeaver> Nope, no effect.  At least if I got my multiline let syntax in the repl right.
14:55:36 <[exa]> quite likely, it's pretty resistant to weirdness :]
14:55:43 <[exa]> ok nevermind, it was a guess :D
14:55:46 <CodeWeaver> Good guess.
14:56:20 <CodeWeaver> Its more a curiosity, because by the time I'm ready to do something performant, I'm rarely doing direct pastes into the repl like that.  But.... it really bugs me not to know. ;)
14:56:45 <CodeWeaver> I mean, I"m literally using the repl in both cases.  It's just that in one case it's bein gloaded from a file.
14:56:49 * hackage uniqueness-periods-vector-examples 0.13.1.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.13.1.0 (OleksandrZhabenko)
14:57:02 <dolio> Loaded from a file isn't the same as pasted into the repl.
14:57:10 <CodeWeaver> Okay, that's a fair statement.
14:57:36 <CodeWeaver> But I am still not quite sure why the evaluation would be different in that particular way.  The reuslt is the same, obviously, but the dethunking is wildly different.
14:58:18 <dolio> Different defaulting rules are enabled in the repl, so it may be treating the code differently in each case.
14:58:43 <CodeWeaver> Mm.
14:59:05 <CodeWeaver> I wonder if I can change that default in the repl just for the sake of this test.
15:02:16 <dolio> I wouldn't trust breaking a whole expression into a bunch of separate lines in the REPL, either.
15:02:44 <dolio> Things need to be treated differently when they're expected to work line-by-line.
15:03:04 <dolio> GHC isn't, like, collecting all the lines you type in, and reconsidering previous ones in light of later ones.
15:03:48 <CodeWeaver> Sure.  But in this case the expression I'm evaluating, the type signature aside, is one line, and the dethunking is on a value expressly inside the function in question.  That's a pretty odd difference.
15:04:07 <[exa]> CodeWeaver: very roughly, if it's about types, you might just put a typehole everywhere and try to find a difference. But chances are it isn't, esp. if reusing the thunk would eg. depend on optimization
15:04:13 <CodeWeaver> I'm sure there's a reason.  Don't get me wrong, I understand the REPL is likely to be a special case... but I'm curious what the special case is on this one.
15:04:47 <CodeWeaver> Okay, sure.
15:05:02 <CodeWeaver> I'll see if I can scare up a plausible reason.
15:05:30 <dolio> It's not super clear exactly what you're doing in each case, either.
15:05:34 <[exa]> perhaps just wait for more people showing up here, or repost on monday morning
15:05:55 <CodeWeaver> Yup, sure.  I won't belabour the point much more today.  But I do appreciate the time.
15:06:36 <dolio> Because there are a lot of variables. Like, telling GHC to compile a file and then opening it in the REPL is different from not compiling it first, I think.
15:07:16 <CodeWeaver> Well, I'm not telling GHC to compile anything at present.  This is all pure repl.  Just with a :load instead of a paste.
15:07:24 <CodeWeaver> Which, yes, I realize, is still likely different.
15:08:05 <CodeWeaver> : guess you could argue it's 'internally compiling' by doing a :load, but that too is beyond my immediate ken.
15:09:40 <dolio> Well, maybe. I don't know specifically.
15:10:26 <dolio> I think it compiles it, but it might use different settings than compiling before :load.
15:10:54 <dolio> Also :load is different from import, for instance. :)
15:11:08 <dolio> And I'm unsure what effects that has besides just scoping.
15:11:10 <CodeWeaver> Because that doesn't complicate my life. :D
15:12:25 <CodeWeaver> Reading up on the MR, I can see how this might be the case, but I'd love to be able to prove it somehow, one way or the other.
15:12:53 <CodeWeaver> Fascinating.
15:16:03 <dolio> MR seems like the most likely answer.
15:16:48 <CodeWeaver> The more I read about it, the more I agree.
15:17:26 <CodeWeaver> q isn't just a value in this case.  It's a function expecting a type dictionary, bound at each of the use sites, and only because its in the repl.
15:17:31 <CodeWeaver> I _think_.
15:18:12 <CodeWeaver> Its happening for the same reason I use the phony parameter for foo in the first place -- to avoid caching. 
15:18:18 <CodeWeaver> Again, I _think_.
15:18:18 <dolio> I think it's off by default in the REPL, yeah.
15:18:34 <CodeWeaver> Super fascinating.
15:18:36 <dolio> Because it's much easier to break things with it line-by-line.
15:18:54 <dolio> Default to something is invalid for a later line.
15:18:55 <CodeWeaver> Sure.  The fact that it's in one line in my case probably doesn't justify doing it there.
15:20:01 <dolio> Yeah, it's either on or off. It's not going to do a case-by-case analysis of whether or not to do it.
15:20:42 <CodeWeaver> I could see that being a WORSE problem for people trying to figure it out, if it _sometimes_ did it.  I mean you could have scoped behaviour in an expression, but that'd be super confusing if you didn't know about it.
15:20:59 <CodeWeaver> Yeah, okay.  I;m seeing this now.  At least a little.
15:21:41 <_deepfire> Is the TH's Quote monad primarily about hygienic name allocation?
15:23:57 <phadej> yes
15:24:08 <phadej> or in fact, only about that
15:24:30 <_deepfire> thank you! : -)
15:25:15 <phadej> (don't mix Quote and Quasi, latter is "everything")
15:26:47 <CodeWeaver> PROOF (or close enough):  Changed expression to:   let {q::Integer;q = .... }  
15:26:58 <CodeWeaver> Now behaves like the loaded file.  MR almost certainly.
15:27:20 <CodeWeaver> You all are magnificent.  Thanks, exa, dolio.
15:27:40 <dolio> No problem.
15:27:55 <CodeWeaver> I may be dancing around like a maniac now. :)
15:38:47 <Guy> Hello :)
15:39:03 <CodeWeaver> Hi.
15:39:42 <[exa]> CodeWeaver: unbelievable how MR hides right. :]
15:40:49 <CodeWeaver> exa:   Not something one has to fight with in a lot of other languages, and arguably, something you almost don't have to think about even in this one.  Until it bites you.
15:47:20 * hackage core-program 0.2.5.0 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/core-program-0.2.5.0 (AndrewCowie)
15:48:20 * hackage unbeliever 0.10.0.7 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/unbeliever-0.10.0.7 (AndrewCowie)
16:18:48 <larou> i have awesome code!
16:19:05 <larou> look look!
16:19:06 <larou> https://pastebin.com/raw/Yzd5rZsB
16:21:49 <larou> this is all supposed to go at type level
16:22:04 <larou> its a container you can only construct to have links
16:22:29 <larou> the term level thing thats supposed to use this, should tie the knot over these links
16:23:00 <larou> its a list, of Maybe Nats, where they are in pairs
16:23:08 <larou> of Nats pointing to each other
16:23:18 <larou> ie, if a Nat is at some position in the list
16:23:29 <larou> then at the position this Nat corresponds to
16:23:40 <larou> should contain a Nat corresponding to the first position
16:23:53 <larou> ...
16:24:00 <larou> so now there can be a doubly linked list
16:24:06 <larou> *with extra links!*
16:24:37 <larou> these are like semicircles underneath the list connecting pairs of elements  
16:25:01 <larou> probably i could extend this to having multiple links per node, but for now this is complex enough
16:26:06 <larou> i made a paste yesterday that showed that the constraints at type level work for the smart constructors...
16:26:54 <larou> this being at type level means it has kind level nats...
16:27:39 <larou> and that the smart constructors are basically then doing a kind level computation
16:27:46 <larou> to ensure the types are constructed safely
16:27:49 <larou> cool or what!?
16:32:14 <larou> idk if that because graphs are traversable
16:32:23 <larou> that establishing cycles over them
16:32:38 <larou> would then collapse down to some kind of extra linked list like this
16:33:17 <larou> i think you might lose some speed from the evaluation order.. cant really tell
16:33:26 <larou> but it would mean its as expressive...
16:34:40 <larou> makes it worthwhile constructing the graphs algebraically to preserve the existence of a traversable implementation 
16:34:50 <larou> ie "shaped construction"
16:38:19 <justsomeguy> I'm only a noob, so this stuff is beyond my comprehension, but it looks pretty cool.
17:04:55 <Guest36918> hello
17:05:35 <ski> ehlo
17:05:43 <Guest36918> i need to change my name
17:05:44 <Guest36918> but
17:05:55 <Guest36918> was wondering if someone could help me fix a snipper of haskell code
17:06:01 <Guest36918> snippet
17:06:02 <Guest36918> *
17:06:46 <ski> hard to tell, without seeing it
17:06:59 <ski> /nick myNewNickName
17:07:04 <ski> to change your nickname
17:07:12 <christo> thx
17:07:24 <Squarism> i see here OverlappingInstances and IncoherantInstances are both deprecated here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
17:07:24 <christo> what's the best way to link haskell code? 
17:07:30 <Squarism> what should one use instead?
17:07:49 <ski> @where paste
17:07:49 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
17:08:01 <ski> you could use that ^, christo
17:08:07 <christo> thx
17:08:16 <christo> basically, i'm writing an infix operator function
17:08:24 <Squarism> oh its the pragmas
17:08:24 <christo> < i'm a newbie to haskell and experimenting
17:08:42 <christo> and i'm getting a type error with floor (n1 / n2)
17:08:47 <christo> i'll paste full code now
17:08:54 <christo> it's for a custom modulo operator
17:09:37 <koz_> ski: Didn't know we had this as a pastebin, nice.
17:10:07 <christo> https://paste.tomsmeding.com/QutEatIe#file-1
17:10:48 <christo> â€¢ No instance for (RealFrac Integer) arising from a use of â€˜floorâ€™
17:11:01 <christo> haskell language server error i get in vs-code
17:11:34 <koz_> :t (/)
17:11:35 <lambdabot> Fractional a => a -> a -> a
17:11:39 <koz_> There's your issue.
17:11:42 <koz_> I assume you wanted this?
17:11:44 <koz_> :t div
17:11:45 <lambdabot> Integral a => a -> a -> a
17:13:05 <Squarism> gah.. im on ghc865 but it still tells me to use deprecated IncoherentInstances
17:13:20 <koz_> Squarism: What're you trying to write?
17:13:20 <christo> so i do. round (n1 (div) n2) ? 
17:13:41 <Squarism> koz instances that "overlap" =D
17:13:43 <koz_> christo: If you wanna use div infix, you wanna write it as n1 `div` n2
17:13:53 <koz_> Squarism: Yes. In other news, cream puffs are puffs which are creamy.
17:14:00 <koz_> And regular expressions are expressions which are regular.
17:14:37 <christo> @koz_ still not working it seems
17:14:37 <lambdabot> Unknown command, try @list
17:14:39 <Squarism> im just confused i got the error message instructing me to use a deprecated extension 
17:14:48 <ski> Squarism : `/' doesn't work on `Integer's. `/' is for fractional division. either convert your `Integer's to some fractional number type, or else use integral division (`div')
17:14:51 <koz_> christo: Paste the code again?
17:14:58 <ski> er, sorry
17:15:01 <ski> christo ^
17:15:13 <christo> â€¢ No instance for (RealFrac Integer) arising from a use of â€˜floorâ€™
17:15:17 <christo> ooops sorry
17:15:37 <koz_> christo: You don't need floor in this case then.
17:15:40 <koz_> :t floor
17:15:42 <lambdabot> (RealFrac a, Integral b) => a -> b
17:15:50 <Axman6> floor also doesn['t wokr on Integers
17:15:54 <christo> https://paste.tomsmeding.com/QutEatIe#file-1
17:16:01 <koz_> You don't have a RealFrac anything, since if you use div, you don't get a fractional thing back.
17:16:04 <ski> christo : `fromInteger' can be used to convert from `Integer' to another numeric type
17:16:13 <Axman6> > 13 `div` 3
17:16:15 <lambdabot>  4
17:16:24 <christo> :t fromInteger
17:16:26 <lambdabot> Num a => Integer -> a
17:16:57 <ski> (e.g., you could convert to `Rational' ..)
17:16:57 <christo> > fromInteger 2
17:17:00 <lambdabot>  2
17:17:04 <christo> > fromInteger 2.0
17:17:06 <lambdabot>  error:
17:17:06 <lambdabot>      â€¢ Could not deduce (Fractional Integer)
17:17:06 <lambdabot>          arising from the literal â€˜2.0â€™
17:17:23 <ski> > floor (fromInteger 18 / fromInteger 7)
17:17:26 <lambdabot>  2
17:17:46 <ski> > 18 - 7 * floor (fromInteger 18 / fromInteger 7)
17:17:48 <lambdabot>  4
17:18:03 <ski> > 18 - 7 * floor (fromInteger 18 / fromInteger 7 :: Rational)
17:18:05 <lambdabot>  4
17:18:38 <christo> :t (/)
17:18:39 <ski> (without the type ascription, it'll default to `Double', iirc)
17:18:40 <lambdabot> Fractional a => a -> a -> a
17:19:12 <christo> what does :: Rational do? some sort of type Cast or ? 
17:20:16 <Axman6> :t \x -> fromInteger x
17:20:17 <lambdabot> Num a => Integer -> a
17:20:33 <Axman6> :t \x -> (fromInteger x :: Rational)
17:20:35 <lambdabot> Integer -> Rational
17:20:56 <Axman6> it's picking the type to use, there is no casting in Haskell*
17:22:25 <christo> ahh ok
17:22:34 <christo> so is Num like a generic or something? 
17:22:45 <koz_> christo: Num is kind of like an interface.
17:22:57 <koz_> Something that is an instance of Num is 'kinda sorta number-like' in some sense.
17:23:20 <Axman6> @src Num
17:23:21 <lambdabot> class Num a where
17:23:21 <lambdabot>     (+), (-), (*)       :: a -> a -> a
17:23:21 <lambdabot>     negate, abs, signum :: a -> a
17:23:21 <lambdabot>     fromInteger         :: Integer -> a
17:23:24 <christo> Hmm, as a haskell beginner may be a bit beyond my head
17:23:39 <koz_> christo: Type classes are a fairly important concept, even at beginner level.
17:24:20 <koz_> (in terms of how to use their instances, at least)
17:24:25 <Axman6> Num is the class of types which can do some number like things, such as addition, subtradction, multiplication this allows you to use the usual 1 + 2 * 3 syntax for your own types
17:25:06 <Axman6> @let data MyNum = Val Integer | Add MyNum My
17:25:08 <lambdabot>  .L.hs:159:24: error:
17:25:08 <lambdabot>      Not in scope: type constructor or class â€˜Myâ€™
17:25:08 <lambdabot>      Perhaps you meant â€˜Muâ€™ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
17:25:19 <Axman6> @let data MyNum = Val Integer | Add MyNum MyNum | 
17:25:19 <lambdabot>  Parse failed: Parse error: EOF
17:25:26 <Axman6> omg, typing on a couch is ahrd
17:25:36 <koz_> Axman6: It's those axe hands.
17:25:40 <christo> lol 
17:25:49 <koz_> Too much couch stuffing everywhere.
17:25:54 <Axman6> @let data MyNum = Val Integer | Add MyNum MyNum | Mul MyNum MyNum
17:25:54 <christo> btw, my (%) infix operator works now
17:25:55 <lambdabot>  Defined.
17:26:08 <christo> but need
17:26:16 <christo> maybe look into type classes then
17:26:18 <Axman6> koz_: congrats on your sane election btw
17:26:32 <koz_> Axman6: Thanks! I gotta say I wasn't too surprised by the outcome.
17:27:15 <Axman6> @let instance Num MyNum where a + b = Add a b; a * b = Mul a b; fromInteger i = Val i
17:27:17 <lambdabot>  .L.hs:162:10: error: [-Wmissing-methods, -Werror=missing-methods]
17:27:17 <lambdabot>      â€¢ No explicit implementation for
17:27:17 <lambdabot>          â€˜absâ€™, â€˜signumâ€™, and (either â€˜negateâ€™ or â€˜-â€™)
17:27:39 <Axman6> @let instance Show MyNum
17:27:41 <lambdabot>  .L.hs:162:10: error: [-Wmissing-methods, -Werror=missing-methods]
17:27:41 <lambdabot>      â€¢ No explicit implementation for
17:27:41 <lambdabot>          either â€˜showsPrecâ€™ or â€˜showâ€™
17:27:51 <Axman6> @let deriving instance Show MyNum
17:27:53 <lambdabot>  Defined.
17:28:07 <Axman6> % 1 + 2 * 3 :: MyNum
17:28:08 <yahb> Axman6: ; <interactive>:62:14: error: Not in scope: type constructor or class `MyNum'
17:28:25 <ski> > 1 + 2 * 3 :: MyNum
17:28:27 <Axman6> you're the worst yahb
17:28:28 <lambdabot>  error:
17:28:28 <lambdabot>      â€¢ No instance for (Num MyNum) arising from a use of â€˜+â€™
17:28:28 <lambdabot>      â€¢ In the expression: 1 + 2 * 3 :: MyNum
17:29:24 <Axman6> koz_: we had a similar result over the pond in our territory election, so it was as good night
17:29:40 <koz_> Axman6: In that case, congratulations!
17:31:41 <koz_> Would someone be able to guide me in creating Nix environments wherein I can build _static_ Haskell applications for 32-bit x86?
17:32:02 <koz_> So like, a chonky binary I can copy over to another machine and just run.
17:40:15 <jared-w> nix-shell -p cabal-install ghc && cabal build `--enable-executable-static --ghc-options=-split-sections`?
17:40:25 <jared-w> (if you're on nixos the answer changes substantially)
17:40:44 <koz_> jared-w: I am not on NixOS. So do I not need like, a configuration file for Nix or anything?
17:40:53 <koz_> And won't this build a 64-bit binary?
17:41:15 <jared-w> Not that I'm aware of. Ah, true. If you're *on* a x64 system and wanting to cross compile to x86 that throws a wrench into the works
17:41:29 <koz_> jared-w: That was my primary question really.
17:42:31 <jared-w> Yeah, makes sense. If you're not on nixos, cabal build --enable-executable-static more or less "just works" now. Cross compiling onto x32 can be a bit painful depending on what and where. I haven't done it, personally, so I can't immediately point you to any solution with experience
17:43:11 <koz_> OK, thanks.
17:44:32 <jared-w> https://nixos.wiki/wiki/Packaging/32bit_Applications this is really the first thing that I can find. So it seems "possible" and maybe even "sorta easy", but given that you're not on nixos, some of the cross compiling stuff doesn't always apply, which complicates things
17:45:58 <koz_> I figured it _should_ be possible, but I dunno much about Nix. Oh well, thanks anyway.
18:15:37 <koz_> jared-w: I'm trying to follow this: https://github.com/Gabriel439/haskell-nix/tree/master/project0 , but I keep getting 'error: cannot auto-call a function that has an argument without a default value ('mkDerivation')' for (something near enough a carbon copy of) project0.nix when I run 'nix-build': error: cannot auto-call a function that has an argument without a default value ('mkDerivation')
18:15:47 <koz_> Whoops, two pastes of error message.
18:16:14 <koz_> default.nix: http://ix.io/2B5a
18:16:28 <koz_> What am I missing?
18:25:42 <koz_> OK, never mind, see it now.
18:30:00 <Squarism> im playing with Generics here. I tried : from ([1,2,3,4] :: [Int]). I was a bit surprised the expression resulted in this : https://paste.ofcode.org/AXUFkv4hcGLmHQQbMvmUgb
18:32:45 <Squarism> why isnt [2,3,4] expanded with a product type? is it lazy evaluation at play?
18:35:54 <proofofme> name :: Word8 -> Parser Name    This type declaration is in Cassava Parse docs: https://hackage.haskell.org/package/cassava-0.5.2.0/docs/Data-Csv-Parser.html  Is the `Parser` a monad?
18:36:20 <ghoulguy> Squarism: Generics affects a single instance of a datatype
18:36:22 <koz_> proofofme: Yes.
18:36:27 <koz_> https://hackage.haskell.org/package/attoparsec-0.13.2.3/docs/Data-Attoparsec-Internal-Types.html#t:Parser
18:36:33 <ghoulguy> Squarism: It doesn't recursively convert between the generic and normal representation
18:37:19 * hackage Z-IO 0.1.6.1 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.6.1 (winterland)
18:43:07 <koz_> OK, I think I have nix-build firing, finally.
18:44:54 <Squarism> ghoulguy, okok.
18:45:24 <Squarism> ghoulguy, i had a question for you regarding our latest talk about addressing a datastructure using string like paths. 
18:47:52 <Squarism> ghoulguy, could you see how the approach you elaborated, on using generics, could be extended to "multi level" addressing?   
18:48:48 <proofofme> is it possible to use cassava to parse just a String and not from a file?
18:49:05 <koz_> proofofme: Yes. You need a ByteString, but you can use the 'decode' function.
18:50:11 <proofofme> ok I will start there
18:56:25 <proofofme> Prelude Data.Text> decode("a,b,c")
18:56:42 <proofofme> Variable not in scope: decode :: [Char] -> t
18:57:05 <koz_> proofofme: Cassava's decode.
18:57:15 <koz_> And you don't call functions that way in Haskell.
18:57:57 <Guy> yeah you call em like this
18:58:15 <Guy> Function: (CALL) => [args]
18:58:39 <koz_> Guy: ?
18:58:43 <koz_> I don't follow.
18:58:52 <Guy> a real mans way of calling functions
18:59:13 <koz_> Guy: What has this got to do with Haskell?
18:59:38 <Guy> its how functions will be called in the new Haskell update
19:02:00 <texasmynsted> Hello. 
19:02:04 <texasmynsted> What do you think would be a nice clean way to deal with some configuration data that would be a list of thousands of tuple/pairs? Considering: Dhall, Data.ini, CSV, other. . . 
19:02:39 <texasmynsted> maybe just a giant List in its own module? . . . 
19:02:45 <infinisil> texasmynsted: What kind of configuration has thousands of tuples?
19:02:58 <texasmynsted> URL redirects 
19:03:12 <texasmynsted> Like thousands of pairs
19:03:38 <texasmynsted> (badUrl, goodUrl)
19:04:00 <infinisil> Hm I see
19:04:05 <texasmynsted> [(badUrl, goodUrl), (badUrl, goodUrl)...]
19:04:27 <infinisil> A list in a submodule wouldn't be configurable though
19:04:33 <infinisil> s/submodule/module
19:04:59 <infinisil> Or should it just be non-configurable static data?
19:05:20 <texasmynsted> You can imagine that the person doing the configuration is a haskell programmer and would re-compile anyway
19:05:31 <texasmynsted> non-configurable static data.
19:06:51 <texasmynsted> I am thinking maybe Dhall, but maybe simply because it is interesting. It might be way overkill.
19:07:33 <infinisil> That does sound overkill
19:07:40 <texasmynsted> It is so easy to make things too complicated.
19:09:15 <infinisil> I'd probably go for a simple "<badurl> <goodurl>"-per-line format
19:09:36 <infinisil> And either access it with data-files
19:09:42 <infinisil> Or read it in at compile time with TH
19:11:06 <texasmynsted> TH?
19:11:50 <dsal> texasmynsted: sqlite
19:12:17 <infinisil> texasmynsted: template haskell
19:12:27 <infinisil> E.g. https://hackage.haskell.org/package/include-file
19:12:44 <texasmynsted> hm. yes this is sounding better.
19:13:25 <texasmynsted> If I do tsv (tab delimited file) that should be super easy to read it, easy to read from text editor, and I could load it as a spreadsheet for maintenance 
19:15:12 <texasmynsted> thank you dsal but I think sqlite is more than I need yet also
19:17:01 <dsal> heh, sqlite is a bit less than a spreadsheet.   It's easy and pretty good for thousands of pairs of things which might turn into millions of triples of things.  I use it when I have tens of things.  :)
19:18:22 <texasmynsted> okay. 
19:48:49 * hackage regex-pcre-builtin 0.95.1.3.8.43 - PCRE Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-pcre-builtin-0.95.1.3.8.43 (AudreyTang)
20:09:01 <ibloom> Is there a standard lens such that "use lens" just returns the whole state?
20:10:56 <koz_> ibloom: You can just use 'get' then, right?
20:11:43 <ibloom> I just want to reuse the same set of functions that use "use"
20:12:14 <ibloom> It's a small thing.
20:12:14 <koz_> @hoogle use
20:12:15 <lambdabot> Control.Lens.Combinators use :: MonadState s m => Getting a s a -> m a
20:12:15 <lambdabot> Control.Lens.Getter use :: MonadState s m => Getting a s a -> m a
20:12:15 <lambdabot> Distribution.Compat.Lens use :: MonadState s m => Getting a s a -> m a
20:12:51 <koz_> I think you can use something that turns a function into a Getter, then just pass id to that?
20:13:51 <ibloom> Hmmm...
20:13:54 <koz_> to.
20:13:57 <koz_> So you would do like
20:14:03 <koz_> use (to id)
20:14:22 <ibloom> Let me see if that typechecks
20:17:01 <ibloom> Not quite
20:17:13 <koz_> ibloom: What seems to be the problem?
20:17:23 <ibloom> "Could not deduce (Contravariant f) arising from a use of â€˜toâ€™"
20:17:54 <ibloom> @hoogle to
20:17:54 <lambdabot> GHC.Generics to :: Generic a => Rep a x -> a
20:17:55 <lambdabot> Control.Lens.Combinators to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
20:17:55 <lambdabot> Control.Lens.Getter to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
20:18:31 <koz_> Yeah, since I think 'use' can grab a variety of things.
20:18:39 <koz_> That's what 'Getting' means in its type.
20:18:45 <koz_> So on its own, it doesn't know what you want.
20:18:55 <edwardk> koz: id is usable as the identity lens
20:19:04 <koz_> edwardk: Ah, OK.
20:19:07 <edwardk> to id = id
20:19:08 <koz_> So just 'use id' would work?
20:19:24 <edwardk> yeah, or 'get'
20:19:40 <ibloom> Aha
20:19:51 <edwardk> lens deliberately didn't use 'get/set' and went with 'view/set' to avoid trampling the State 'get' operation's name
20:19:56 <koz_> edwardk: I already suggested 'get', but ibloom said that they need something reusable (lol) with 'use'.
20:20:05 <edwardk> then use id
20:20:38 <ibloom> I feel dumb for not trying that.
20:20:51 <ibloom> Works perfectly.
20:21:44 <ibloom> Thank you.
20:45:23 <texasmynsted> I have not used Template Haskell. What do you recommend I read to quickly get a feel for how I could use it to consume a TSV file?
20:46:11 <koz_> texasmynsted: Why TH?
20:46:32 <koz_> Are you trying to mimic C's #include or something?
20:46:44 <texasmynsted> Somebody recommended it earlier as a nice way to include the TSV file content in my project. 
20:47:22 <texasmynsted> The file is static content. It would be used to load many lines of URL pairs
20:48:04 <texasmynsted> for a URL re-direction process. Adding new redirects requires a re-compile.
20:49:03 <texasmynsted> Though it seems like it should be super easy to just read all the lines of the TSV to a list then split the text of each line to pairs
20:49:15 * texasmynsted shrug
20:49:30 <texasmynsted> It also seems like this is a "solved problem"
20:49:32 <koz_> You probably need an intro to TH. https://wiki.haskell.org/Template_Haskell
20:54:49 <texasmynsted> thank you. I will go through the tutorials
20:55:20 <texasmynsted> Is it worth it? Like what does TH bring to this simple problem?
21:00:05 <Cale> texasmynsted: Literally only the ability to read the file at compile time and splice in a string literal with its contents.
21:01:27 <Cale> texasmynsted: You can do something like $(fmap TH.lift (readFile "foo.txt")) and that will behave like a string literal with the contents of foo.txt
21:01:55 <Cale> Where TH.lift is the one from Language.Haskell.TH.Syntax
21:02:41 <Cale> Oh, that readFile might need to be runIO'ed
21:02:47 <Cale> yeah
21:02:59 <Cale> Forgot that lift produced something in the Q monad
21:03:22 <Cale> So, it'd be more like  $(runIO (readFile "foo.txt") >>= TH.lift)
21:21:19 * hackage churros 0.1.4.0 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.4.0 (LyndonMaydwell)
22:08:14 <slack1256> On yesod, the hamlet/lucius templates should be declared as data on the data-field or somewhere else?
23:15:28 <avp> https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=004c05badb7b60c82c2a112906ceec46 - i have a structure like this and I want to be able to create a Foo. My solutions so far are: store Bar in an Option temporarily (bad because I don't want to force an Option check on Foo) or don't store `shared` in Bar at all (bad because I then have to pass shared to `bar` every time I want
23:15:30 <avp> to make a call)
23:17:12 <avp> ...wrong channel, sorry
23:48:53 <proofofme> Still having problems with Cassava for CSV Parsing.  I posted the issue in this pastebin: https://pastebin.com/raw/rhQ83Tch  Anyone know what I need to do to get this working?
