00:57:04 <Xnuk> Why do Haskellers prefer naming type variables with just a single character like: `type Over p f s t a b = p a (f b) -> s -> f t`?
00:58:28 <opqdonut> heh that one could definitely use some better names
00:58:57 <opqdonut> most type signatures only have 1 or 2 type variables, and the meanings of the variables are so abstract that it's hard to find good names
00:59:06 <opqdonut> :t const -- for example here
00:59:08 <lambdabot> a -> b -> a
00:59:33 <opqdonut> there are also some conventions like f for functor and m for monad
00:59:58 <opqdonut> it's also a cultural thing, people see one-letter type variables so they use them, not necessarily weighing the benefits
01:01:19 <opqdonut> wanting to fit a type signature on one line might be an additional reason for short type variable names
01:02:15 <lortabac> I have the impression that the same convention exists in other languages too, ex. List<T>, except that in Haskell we use type variables more often so it's probably more confusing
01:02:28 <opqdonut> :t traverse
01:02:30 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:02:50 <opqdonut> "traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)" is almost 80 chars already
01:02:52 <dminuoso> Xnuk: Imagine reading that particular type synonym if these were words 3-5 characters long
01:05:31 <Xnuk> dminuoso: It would be more clear reading than pfstab, isn't it?
01:15:07 <dminuoso> Xnuk: Doubtfully
01:15:38 <dminuoso> It would require actively reading, with this you can just build up a mental mind model
01:15:47 <dminuoso> And pretty much grok it with a first look
01:16:15 <dminuoso> The one thing I sometimes miss, is operator variables
01:16:23 <dminuoso> That is, that'd read much nicer if we could write:
01:17:04 <dminuoso> type Over (~>) f s t a b = a ~> (f b) -> s -> f t
01:17:11 <dminuoso> (Or something equivalent)
01:17:49 <dminuoso> You used to be able to do that for certain situations
01:18:17 <dminuoso> (Maybe that needs some extra parens as well, not quite sure)
01:45:25 <jgt> Xnuk: can you think of better names for those variables?
02:14:07 <maralorn> I am writing a program that is supposed to quickly read the input, do some transformation on it (probably line by line) and then forward it to output. So that I can put nicely into a linux pipeline like grep or sed.
02:14:31 <maralorn> Right now I have a very stupid forever loop that reads a line to Text and then prints a line to Text.
02:14:54 <maralorn> Any tricks how I can do that more nicely?
02:17:52 <dminuoso> Do what more nicely exactly?
02:17:58 <dminuoso> % :t interact
02:17:58 <yahb> dminuoso: (String -> String) -> IO ()
02:18:02 <dminuoso> That? :)
02:30:18 * hackage libmpd 0.9.2.0 - An MPD client library.  https://hackage.haskell.org/package/libmpd-0.9.2.0 (psibi)
03:05:44 <ski> dminuoso : yes. it was `(a ~> f b) -> s -> f t'
03:07:08 <ski> hololeap : order parameters so that partial application makes more sense
03:13:56 <tomjaguarpaw> What is standard practice for getting small PRs to Cabal reviewed?
03:15:33 <ski> (with `IsFoo f n e', you could do `newtype Blah = MkBlah Bork deriving (IsFoo MyF myN)', assuming you have `instance IsFoo MyF MyN Bork'. but perhaps you'd prefer another partial application here, from another ordering, in case such would be useful at all for you)
03:18:33 <dminuoso> tomjaguarpaw: Bribing phadej could work.
03:20:48 <dminuoso> tomjaguarpaw: I find your style harder to read.
03:28:36 <tomjaguarpaw> If you could go to the PR and explain why that would be a good start :)
03:33:48 * hackage th-lego 0.1.0.3 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.1.0.3 (NikitaVolkov)
03:37:05 <maralorn> dminuoso: Does interact split line by line or does it rely on lazyness?
03:37:12 <phadej> dminuoso, tomjaguarpaw for whole of september I was concentrating on polishing 3.4 release, there are still some (but I hope only one in Cabal-the-lib), and GHC-9.0-alpha1 is already out
03:37:20 <phadej> so sorry for not context switching
03:37:49 <hc> context switching is bad anyway. (I do it everytime I am waiting for the compiler to finish, though ;p )
03:37:55 <maralorn> Also, I would like a solution that preserves terminal controlcode formating.
03:38:49 <hc> maralorn: interact relies on lazyness
03:40:04 <maralorn> Other question how can I build a state machine based parser?
03:41:35 <maralorn> Right now I parse a line that could be one of many things with megaparsec and I do it very terribly by having one parser for every possible variant and "try" them one after the otherr.
03:42:25 <ski> perhaps you could try Happy
03:45:29 <maralorn> Is the documentation for happy rendered somewhere? The webpage linked on hackage apparently hasn‘t been updated since 2010 (!) https://www.haskell.org/happy/
03:50:04 <tomjaguarpaw> phadej: No problem at all.
03:51:09 <phadej> s/some/some bugs
03:52:15 <ski> @hackage happy
03:52:15 <lambdabot> https://hackage.haskell.org/package/happy
03:52:41 <ski> perhaps
03:52:43 <ski> @where bnfc
03:52:43 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
03:52:55 <ski> could also be useful, depending on what you want to do
03:53:05 <ski> (it uses Happy)
03:56:16 <maralorn> ski: happy seems a bit of an overkill for my purpose. Especially because I want to look at an input stream, see if something in there parses and if not take that line as "raw" and proceed to the next line.
03:56:25 <perdent> For all  the the integers in the interval [100, 1400] which are a multiple of 20,  find the numbers that have a digit sum of 14. The solution to the  challenge is the average of all the resulting numbers, rounded up to an  integral value. The digit sum of a number is the sum of all decimal digits. For example, the digit sum of 324 is 3+2+4=9.
04:00:02 <maralorn> Or phrased differently: ski, how do I deal with a grammar where a certain input can have multiple generators?
04:00:34 <ski> dunno what you mean by "multiple generators" ?
04:00:37 <tomsmeding> maralorn: how hard is it to determine what case the line falls in from looking at the line?
04:00:50 <ski> you mean the grammar is ambiguous ?
04:00:52 <tomsmeding> like, would case-switching on head (words line) work? :p
04:01:00 <ski> perdent : is it Haskell-related ?
04:01:25 <perdent> No ignore it
04:02:03 <maralorn> tomsmeding: It's not that easy.
04:02:05 <ski> (you mean you sent it in here, by mistake ?)
04:02:35 <tomsmeding> maralorn: okay, what algorithm did you have in mind then, ignoring complexity of implementation?
04:03:26 <perdent> Yeah
04:04:13 <maralorn> tomsmeding: Right now I do this: Look at the line, does it match a) if yes process if no does it match b) if yes ... until if it does not match anything at all process as "raw"
04:04:35 <maralorn> The problem is that some of the cases have long common prefixes.
04:04:43 <tomsmeding> ah
04:04:52 <tomsmeding> long as in?
04:05:13 <ski> maralorn : could you reasonably left-factor those cases ?
04:05:31 <maralorn> long as in I don‘t have a performance problem at all, my program  works I just want it to be pretty.^^
04:05:39 <tomsmeding> :D
04:05:46 <maralorn> ski: I am not sure I know what that means.
04:06:22 <tomsmeding> what ski said, or perhaps use an applicative parser library that includes a decent optimiser (I don't know if that exists)?
04:06:31 <maralorn> I have actually solved the trickiest one by having a Parser (Either MatchA MatchB) …
04:07:24 <tomsmeding> I take it that ski meant going from try (string "prefixA" >> return 1) <|> try (string "prefixB" >> return 2) to the following: try (string "prefix" >> ((char 'A' >> return 1) <|> (char 'B' >> return 2))
04:07:49 <maralorn> Ah, nice.
04:07:57 <ski> yes 
04:08:22 <tomsmeding> modulo syntactic details :p
04:09:07 <tomsmeding> but I think that if you can express your parsers in applicative form, a good optimiser would be able to perform that left-factoring automatically
04:09:27 <tomsmeding> but I don't know whether that's actually true, and also I don't know whether such a good library exists
04:09:36 <maralorn> Does megaparsec do something like that?
04:09:46 <tomsmeding> megaparsec is monadic parsing, right?
04:10:04 <tomsmeding> applicative parsing is strictly weaker than monadic parsing, so unless it has two completely distinct parsing engines under the hood, I think it doesn't
04:10:36 <tomsmeding> https://stackoverflow.com/questions/7861903/what-are-the-benefits-of-applicative-parsing-over-monadic-parsing
04:10:36 <ski> i suppose you could also try something like <https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-ParserCombinators-ReadP.html> or <https://hackage.haskell.org/package/base-4.14.0.0/docs/Text-ParserCombinators-ReadP.html>
04:10:47 <tomsmeding> same link?
04:12:28 <tomsmeding> ski: looks cool, TIL
04:13:19 * hackage nri-prelude 0.1.0.1 - A Prelude inspired by the Elm programming language  https://hackage.haskell.org/package/nri-prelude-0.1.0.1 (JasperWoudenberg)
04:14:57 <tomsmeding> ski: is that able to optimise   (string "prefixA" >> return 1) +++ (string "prefixB" >> return 2)   to something like   string "prefix" >> ((char 'A' >> return 1) +++ (char 'B' >> return 2))   ?
04:15:41 <tomsmeding> ah the ReadP representation is CPS'ed, so I guess not
04:17:18 * hackage fused-effects-readline 0.1.0.1 - A readline-like effect and carrier for fused-effects  https://hackage.haskell.org/package/fused-effects-readline-0.1.0.1 (robrix)
04:18:03 <tomsmeding> or perhaps it does, there's some magic going on with the P type
04:21:25 <maralorn> I think I need interact where the function can be IO …
04:21:49 <tomsmeding> okay so it kind of does: the implementation of +++ via <|> does combine Look, and later Get values, but I think there's still some kind of double work performed but not sure
04:22:26 <tomsmeding> :t \f -> getContents >>= f >>= putStr
04:22:27 <lambdabot> (String -> IO String) -> IO ()
04:22:31 <tomsmeding> maralorn: ^
04:22:33 <tomsmeding> :p
04:22:56 <maralorn> Also: Looks right.^^
04:23:39 <ski> what `IO' do you want/need ?
04:24:12 <maralorn> ski: I want to e.g. put a current timestamp into my output.
04:24:52 <maralorn> Or query the system for additional info about the input I am getting.
04:25:11 <maralorn> I wonder if I should look into a Streaming lib.
04:26:07 <tomsmeding> maralorn: caution: that expression doesn't work, it blocks until the entire input is read apparently
04:27:21 <ski> if timestamps are always put in the same place in the generated lines, perhaps you could (incrementally) generate a list of `String's, and then insert the timestamps as you output the lines
04:28:27 <maralorn> I think my Plan would be right now to do something like having a "Parser [ParseResult]", a function "ParseResult -> IO Text", map that to something like [ParseResult] -> IO [Text] and then return the concatenation of that …
04:28:48 * hackage nri-prelude 0.1.0.2 - A Prelude inspired by the Elm programming language  https://hackage.haskell.org/package/nri-prelude-0.1.0.2 (JasperWoudenberg)
04:29:04 <maralorn> Where I would write the Parser in a way that could never fail.
04:29:23 <ski> tomsmeding : you could sprinkle `unsafeInterleaveIO' :)
04:30:48 * hackage nri-env-parser 0.1.0.1 - Read environment variables as settings to build 12-factor apps.  https://hackage.haskell.org/package/nri-env-parser-0.1.0.1 (JasperWoudenberg)
04:31:14 <tomsmeding> or use
04:31:20 <tomsmeding> :t \f -> getContents >>= mapM_ (f >=> putStrLn) . lines
04:31:21 <lambdabot> (String -> IO String) -> IO ()
04:31:31 <tomsmeding> which runs f for every line :)
04:32:33 <maralorn> tomsmeding: Yeah, but sometimes the Parser needs to consume multiple lines
04:37:19 <orzo> I'm trying to do scalar multiplication with hmatrix's type-safe "static" vectors http://dis.um.es/~alberto/hmatrix/static.html
04:37:26 <orzo> i can't figure it out
04:41:36 <orzo> do i have to convert it to a dynamic vector just to multiply it by a scalar?
04:45:47 <opqdonut> orzo: is * perhaps element-wise multiplication? so you could create a constant matrix of the same size and then use *
04:46:28 <opqdonut> so something like 'fromInteger 3 * mat'  should work as far as I can see
04:46:45 <opqdonut> but I'm just curious and reading the docs, I haven't used hmatrix
04:46:48 <tomsmeding> orzo: https://hackage.haskell.org/package/hmatrix-0.20.0.0/docs/Numeric-LinearAlgebra.html#g:3 seems to suggest '3 * mat' should work
04:47:01 <tomsmeding> though that does create a dynamic vector behind the scenes
04:47:19 <tomsmeding> (if you follow the Num and >< definitions in the source)
04:47:46 <tomsmeding> perhaps Vector fusion does magic and eliminates that intermediate vector? /shrug/
04:50:23 <phadej> probably no
04:50:56 <tomsmeding> ah there is 'scale :: t -> Matrix t -> Matrix t'
04:51:04 <tomsmeding> orzo: ^
04:52:54 <tomsmeding> and that seems to call out to a foreign C function via some detours
04:54:04 <tomsmeding> (scale comes from the Linear typeclass)
04:55:49 * hackage stylish-haskell 0.12.0.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.12.0.0 (JasperVanDerJeugt)
04:57:07 <maralorn> Wait, I can‘t have a lazy Parser, can I? At least parse :: s -> Either (ParseErrorBundle s e) a will be strict in the Either, so it needs to consume all input until it knows, it it succeeded, right?
04:58:29 <ski> i guess if you assume your input is well-formed, don't care about potential errors, then you could be more lazy
05:04:00 <maralorn> Yeah, it makes sense in my head. But I don‘t finde a lib which can do it.
05:04:08 <maralorn> Or I don‘t see how to use them to do it.
05:05:08 <maralorn> I think the problem is that I need a Parser type that can say "Success this a is my Result, but oh btw. I haven‘t consumed this string s, so you might wanna look into that"
05:05:55 <maralorn> Huh, I could try that With Parser (a,s).^^
05:06:26 <tomjaguarpaw> What is the canonical location for Cabal documentation?  
05:06:42 <tomjaguarpaw> Is it cabal.readthedocs.io?
05:09:27 <yushyin> tomjaguarpaw: at least https://www.haskell.org/cabal/ links to https://cabal.readthedocs.io/ so I guess, yes!
05:10:57 <ski> maralorn : `s' would be the remaining input ?
05:11:17 <maralorn> ski: Yeas
05:11:41 <Axman6> I thought most parser libraries gave you a way to parse something and also get the remaining input
05:11:53 <Axman6> I'm sure Attoparsec does
05:13:13 <ski> yea, they usually do
05:13:25 <tomjaguarpaw> yushyin: Thanks
05:13:29 <maralorn> Do they?
05:14:05 <maralorn> I see that you can provide more input to a partial parse in attoparsec. And that you can have a "Fail" that gives you the remaining input.
05:14:27 <maralorn> But I don‘t see a function, that gives you a Success with the remaining input.
05:17:49 <maralorn> I am a bit confused, because I know I have seen something like that, but I can‘t find it …
05:22:48 <ski> maralorn : <https://hackage.haskell.org/package/attoparsec-0.13.2.4/docs/Data-Attoparsec-ByteString.html#v:parse> ?
05:23:44 <maralorn> Oh, the Done Constructor is different.^^
05:23:45 <maralorn> Sorry for that.^^
05:30:49 * hackage record-dot-preprocessor 0.2.7 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2.7 (NeilMitchell)
06:02:54 <maralorn> Is there a way to flush stdout while writing a lazy Text?
06:04:10 <phadej> you mean, between chunks?
06:06:58 <hc> You could write your own lazy putStr function and do it there, I think
06:08:03 <hc> i.e., get Chunk, write it, flush stdout, unsafeInterleaveIO, repeat
06:09:37 <ski> `unsafeInterleaveIO' ?
06:14:22 <phadej> why
06:14:29 <phadej> indeed why
06:26:49 <maralorn> yeah, I mean between chunks …
06:27:14 <maralorn> but since I am concating them anyways before I can just putStr and flush them one after the other.
07:29:06 <Guest18> Hey guys, common question here: can anyone make an ELI5 for what a monad is? I can't seem to grasp the concept on my own. Yes, I've heard the joke with the endofunctors :)
07:30:10 <dolio> Monads are a way of presenting abstract algebra.
07:31:05 <Guest18> I understand monads are a way of introducing side-effects in a purely functional context. Don't know more than that
07:32:07 <Taneb> Guest18: forget everything you know about them. "IO" is a way of talking about (but not really introducing) side-effects in a purely functional context, and it happens that IO is an example of a monad
07:32:16 <tbreslein> well, that is not true though. there are monads that introduce "side-effects", but side-effects aren't an inherent feature to monads
07:32:26 <Taneb> @where typeclassopedia
07:32:27 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:32:27 <tbreslein> that was @Guest18
07:32:45 <Taneb> Guest18: Typeclassopedia (see the link that I got lambdabot to write) is what I recommend
07:33:02 <Uniaika> Guest18: I'll try and ELI5 it
07:33:04 <Taneb> But it's more "explain it like I'm a maths student" (which I was when I learnt)
07:33:38 <Uniaika> you can have some data in a datatype, and this datatype can implement something akin to the pipe operator in other languages (Elixir, OCaml, F#, maybe PHP one day…)
07:33:59 <ski> Guest18 : monads are used to express "effects" without the "side-"
07:34:29 <Uniaika> this something is the Monad typeclass
07:34:43 <Uniaika> which provides a pipe-like operator called bind, or (>>=)
07:35:09 <Uniaika> now, if you want an ELI10, or ELI15, we can talk about composing effects and stuff
07:35:26 <Uniaika> but at its core, a Monad is a datatype that implements/provides a pipe-like operator
07:36:27 <Guest18> so if i do 'data SomeType = ... deriving (Monad)' I get >>=, which is a pipe operator. By pipe operator, i understand i can redirect the output (the return value?) somewhere else
07:37:12 <Guest18> Uniaika: ok then, do an ELI22, please :))
07:37:16 <hc> Guest18: you have heard the endofunctor 'joke'... have you also heard the monad tutorial joke? ;)
07:37:36 <dolio> Monad cannot be derived.
07:37:49 <Guest18> hc: probably, but doesn't ring a bell right now
07:38:30 <hc> Guest18: https://mvanier.livejournal.com/3917.html
07:38:34 <Guest18> dolio: but Uniaika said Monad is a typeclass, aren't all typeclasses derivable?
07:38:43 <dolio> Nope.
07:38:43 <xsperry> Guest18 there are many useful monads that have nothing to do with side-effects (or effects). the benefit of monad abstraction is that we can reuse all the generic functions that accept monads (as well as do-syntax) with all of them, without having to rewrite them for each one
07:39:06 <dolio> In the report there's only like 8 that are derivable.
07:39:28 <hc> Guest18: oh, see also https://blog.plover.com/prog/burritos.html for the monad tutorial joke ;p
07:40:47 <dolio> Also keep in mind that constantly referencing burritos isn't actually funny.
07:41:09 <hc> dolio: glad that you're here then to lighten up the mood :)
07:41:44 <dolio> :)
07:41:49 <Taneb> (I made the mistake of learning Haskell in 2011-ish, and only learning what a burrito is a while later)
07:41:56 <Taneb> (it's not all that much like a monad)
07:42:24 <Guest18> I'm now gonna look over the link hc sent with the tutorial. Fingers crossed that i understand it
07:42:28 <ski> xsperry : heh, my notion of "effect" includes every monad we can express computationally
07:42:42 <ski> Guest18 : how much of basic Haskell do you understand ?
07:43:33 <dolio> ski: Is completion of the rationals to the reals an effect?
07:44:43 <Guest18> Well, I know about types, type classes, creating new types and their constructors, currying, pattern-matching, modules, Maybe. Most recently I've read about maps and sets
07:46:07 <Guest18> ski: Is that enough to understand monads?
07:47:43 <tbreslein> personally, I've only learned about monads after learning about Semigroup, Monoid, Functor, and Applicative, which sounds like a lot, but they all flow into each other, and Monad is basically 5th element of that list
07:47:47 <jollygood2> Guest18_, do you know how to deconstruct do to >>=?
07:48:13 <jollygood2> can you write your own Maybe-like or list-like type and write monad instance for it?
07:49:34 <Guest18> jollygood2: I haven't learned about do, >>=. I know how to write the Maybe type, but nothing about the monad instance for it
07:50:09 <jollygood2> Guest18, you do'nt know about do-syntax yet?
07:51:08 <ski> dolio : probably
07:51:11 <Guest18> jollygood2: no
07:51:44 <Guest18> I know about 'let ... in ...'. Is it something like that?
07:51:46 <ski> knowing `do' is not a prerequisite
07:52:23 <ski> Guest18 : well, you certainly know more (things that a relevant) than some people who're asking about monads, then
07:52:26 <jollygood2> no, but it shows where he's at in his journey to learn haskell
07:54:07 <ski> Guest18 : i'd say learn `Functor' first, at least. probably also `Applicative' is a good idea, now that it's a superclass of `Monad'. and having seen `Monoid' (and `Semigroup') shouldn't hurt (although is probably not as essential)
07:54:52 <Guest18> jollygood2: well, i consider myself very much a beginner. As soon as i look over someone else's code, my lack of language knowledge becomes apparent immediately
07:55:32 <ski> Guest18 : anyway, a good way to learn about monads is to first learn about particular monads, like `Maybe', list, `Either e', `Writer w', `Reader r', `State s', `Cont o', ..
07:58:20 <ski> Guest18 : you could say monads are a kind of design pattern; or a way to avoid certain kinds of boiler-plate (/ repetitive) code; or akin to an abstract data type interface, which could be implemented in different ways (compare with "queue", you could have different implementations of queues). but that doesn't really tell you what a monad is, in particular
07:58:26 <Guest18> ski: I can't help but notice some of those sound like group theory from algebra. Like you know, a monoid has certain composition operators, that must be commutative, associative and so on. Can't remember the exact conditions, it has been some time since 12th, but then you had groups, rings. I wonder how do those relate to the things you mentioned
07:58:49 * hackage machines 0.7.1 - Networked stream transducers  https://hackage.haskell.org/package/machines-0.7.1 (ryanglscott)
07:59:00 <dolio> Well, if you know about group theory...
07:59:06 <ski> yes, a monoid is "a group that doesn't have to have inverses"
07:59:58 <ski> e.g. keeping a running counter, or a running sum, or appending messages to a log, would have to do with monoids
08:00:14 <Guest18> My math professor in highschool used to say that the real numbers wanted to insult the naturals, and told them, "You are not a group, you are a monoid". Sounds funnier in Romanian..
08:00:38 <ski> a semigroup is "a monoid that doesn't need to have a neutral element". e.g. computing minimum or maximum
08:01:01 <ski> (every group is also a monoid, and every monoid is also a semigroup)
08:01:42 <Guest18> Then it was "You are just a monoid" :)
08:01:43 <ski> (btw, neither semigroups, monoids, nor groups, need to have a commutative combination/composition operator)
08:02:07 <Guest18> I see
08:02:29 <Guest18> Interesting, I wish I remembered more group theory then..
08:02:41 <Guest18> I need to relearn it
08:02:59 <ski> well, natural numbers form a rig ("a ring that doen't need to have an additive inverse, negation")
08:03:46 <ski> (sometimes aka "semiring")
08:07:13 <ski> Guest18 : if you want a quick and short tutorial on monads, i'd suggest "What the hell are Monads?" by Noel Winstanley in 1999 (one of the first monad tutorials) at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html>
08:07:35 <ski> Guest18 : it's by no means complete, but could give you an idea of what they're about
08:14:02 <dolio> Monads are one of the ways mathematicians talk about algebra, too. And it's actually similar to what Haskell programmers use them for.
08:14:35 <dolio> There is a monad that characterises the 'extra operations' on top of sets that an algebra (group, ring, etc.) has.
08:16:10 <dolio> And Haskell programmers often find it convenient to work in an 'extended language' that has operations (throw/catch, get/put, etc.) that don't exist in the 'pure' language (because it would be confusing for them to exist there).
08:16:31 * ski . o O ( Let's use `do'-notation to talk about algebra. )
08:18:58 <dolio> You could. There's at least one exact correspondence with monoids.
08:20:02 <ski> mhm ?
08:20:14 <Guest18> ski: so.. many.. things.. to bookmark
08:20:34 <dolio> Although I guess monoids are too plain for traditional algebra. Only category theorists care about those.
08:22:25 <dolio> Monoids are what you get by having `zero :: Void` and `bit :: Bool` effects.
08:22:51 <TMA> I remember from my algebra course that monoids were glossed over in one of the lectures. They are merely a stepping stone to groups from that vantage point
08:24:10 <ski> dolio : <https://en.wikipedia.org/wiki/Associative_algebra> ?
08:24:50 <dolio> Oh yeah, they need to satisfy some equations, of course.
08:26:09 <ski> these are just monoid objects in the monoidal category of vector spaces (with tensor), aiui
08:26:59 <dolio> Well, there's probably a lot of examples like that.
08:27:10 <dolio> I meant specifically monoids in Set.
08:27:53 <ski> TMA : endomorphisms over a structure naturally form a monoid, i suppose. for an abelian group, you even get a ring
08:27:58 <ski> ok
08:29:43 <dolio> I think traditional algebraists thought that monoids in set were too boring to be studied, but there are actually interesting things to say about them.
08:30:20 <ski> what about more restricted classes, that might not be as wild ?
08:30:41 <ski> like cancellative monoids, idempotent monoids, ..
08:31:01 <dolio> But, like, rings are monoid objects in Ab. And I think abelian groups are monoid objects in Grp.
08:33:24 <dolio> Oh, maybe it needs to be a group object for the latter.
08:33:48 <ski> hm, perhaps it had something to do with the Erlangen program focusing on automorphisms and isomorphisms, rather than on more general endomorphisms and homomorphisms ?
08:34:36 <dolio> I'm not clear on the details. I just know there's someone on the category zulip whose work is about monoids.
08:35:39 <dolio> I think at least some of that is that monoids are a special case of categories, so a lot of things you can do with categories have special properties when you look at just doing them with monoids.
08:36:23 <dolio> Like, "what special properties do presheaves on monoids have"?
08:36:46 <ski> hm, `mempty = case zero of' and `x <> y = if bit then y else x' ?
08:37:03 <dolio> Right.
08:38:53 <ski> and then `x = if bit then case zero of else x',`if bit then x else case zero of = x',`if bit then if bit then x else y else z = if bit then x else if bit then y else z'
08:38:54 <dolio> MonadPlus is basically the theory of monoids.
08:39:15 <ski> "theory", in a Lawvere sense ?
08:40:06 <dolio> Yeah. Probably only if you pick the right choice of the laws people have for it.
08:40:53 <dolio> Like left/right cancellation.
08:41:03 <Guest18> Say I want to make a safeDiv function that returns a string if the divider is 0, the result otherwise. Is this the way to do it? safeDiv :: (Num a, Fractional a, Eq a) => a -> a -> Either a String
08:41:03 <Guest18> safeDiv _ 0 = Right "Ooops!"
08:41:04 <Guest18> safeDiv x y = Left $ x/y
08:41:11 <Guest18> Like, is there a better way here?
08:41:37 <Guest18> I don't want to use Maybe, but I want to learn how Either functions
08:41:49 <ski> i'd flip the order of the alternatives (and not use `$')
08:42:24 <ski> also .. `"Ooops!"' is not a that informative failure condition
08:42:30 <Guest18> Why flip the order?
08:42:49 <ski> because then one can use `fmap' (from `Functor') on the `a' in the result (if present)
08:43:01 <Guest18> I know it isn't, just wrote it as an exercise, and wanted it to be a string
08:43:12 <cpressey> Guest18: by convention, Left contains an error value and Right contains the "right answer".
08:43:15 <ski> @quote stark
08:43:15 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
08:43:40 <cpressey> (when Either is used this way)
08:44:06 <ski> (i'd generally try to avoid using `String's to represent failure conditions)
08:45:03 <Guest18> safeDiv :: (Num a, Fractional a, Eq a) => a -> a -> Either String a
08:45:04 <Guest18> safeDiv _ 0 = Left "The divider is zero, computation failed"
08:45:04 <Guest18> safeDiv x y = Right $ x/y
08:45:17 <Guest18> Ah, forgot to get rid of $
08:45:24 <Guest18> Anyway, you mean like this?
08:45:29 <ski> Guest18 : "Is this the way to do it?" -- anyway, it also depends on how you intend to use it, e.g. what other possibly-failing operation could you want to use, together with this ? or in what ways (if any) would you want to handle/catch the failure ?
08:45:34 <ski> yes
08:46:09 <ski> although `Num a' is redundant, since `Num' is a superclass of `Fractional'
08:46:53 <Guest18> Well, I know this is a bad example, because it can only fail in one way. But say for some reason, I hate dividing by 3, so i add a pattern for that and return another string or something to signify that
08:47:09 <Guest18> So i can see what actually happened
08:47:20 <Guest18> Is this how Either is supposed to be used?
08:47:53 <ski> (i've occasionally used e.g. `Either Integer' as a monad, or idiom. aborting some operation involving "attempts", reporting the first `Integer' that failed an attempt)
08:48:43 <ski> Guest18 : it's really hard to say, without seeing the context in which you intend to use this
08:49:58 <cpressey> Guest18: Yes, Either can be used this way.
08:50:09 <ski> if you just want to represent possible failure, and don't care about a situation where you may want to distinguish between the possible failures of multiple operations, i'd just use `Maybe'
08:50:48 <ski> if you do want to be able to distinguish between failures from different operations, then it could make more sense to use `Either'
08:51:02 <Guest18> Ok, then, once i get the result, how do i extract the value? Through pattern-matching?
08:52:18 <Uniaika> Guest18: you may, but helper functions such as `either` exist as well, to inline the case analysis
08:52:23 <ski> Guest18 : again, "it depends"
08:54:05 <ski> if this is a "one off" case, sure, you can do that. or things like `maybe',`fromMaybe',`either'. or sometimes things like `catMaybe',`mapMaybe',`partitionEithers' could be what you're looking for
08:54:52 <ski> but often you e.g. want to "short-circuit" a combination of multiple possibly failing operations, so that if one operation fails, the "next one" won't be tried, instead failing the whole combination
08:55:11 <ski> Guest18 : this is one thing that `Monad' (and `Applicative') is useful for
09:00:12 <ski> @let safeDiv :: (Integral a,Eq a) => a -> a -> Maybe a; safeDiv _ 0 = Nothing; safeDiv n d = Just (div n d)
09:00:14 <lambdabot>  Defined.
09:00:23 <monochrom> It always comes down to pattern matching. The only question is do you handwrite every time or do you refactor and reuse.
09:00:25 <ski> > maybe "Oops !" show (for [1,2,3,4,5,6] (\d -> safeDiv 12 d))
09:00:29 <lambdabot>  "[12,6,4,3,2,2]"
09:00:32 <ski> > maybe "Oops !" show (for [1,2,3,0,5,6] (\d -> safeDiv 12 d))
09:00:35 <lambdabot>  "Oops !"
09:01:21 <ski> Guest18 : that's an example of performing a sequence of possibly-failing operations, short-circuiting so that it fails (doesn't continue) as soon as an individual operation fails
09:07:12 <Guest18> ski: I see, thank you for the thorough explanation. You too, Uniaika
09:11:28 <ski> > (either id absurd . (`evalStateT` 1) . forever) (do n <- get; when (n >= 1000) (throwError n); put (2 * n))  -- Guest18, another example, doubling (starting from `1'), aborting when we reach at least a thousand
09:11:32 <lambdabot>  1024
09:13:00 <ski> (if we didn't abort with `throwError' (which corresponds to `Nothing' or `Left' above, expressing (short-circuiting) failure), this would go on `forever')
09:15:31 <ski> sometimes, one might also have an alternative branch (or a bunch of them), to try, in case the "main computation branch" failed. then one could reach for library operations having to do with `MonadPlus' (or `Alternative')
09:17:07 <Guest18> Thank you, I'm gonna go over your examples later, i need to go now
09:20:34 <fresheyeball> anyone know how to get haddock themes to work?
09:25:19 * hackage blank-canvas 0.7.3 - HTML5 Canvas Graphics Library  https://hackage.haskell.org/package/blank-canvas-0.7.3 (ryanglscott)
10:16:49 * hackage vivid 0.4.2.4 - Sound synthesis with SuperCollider  https://hackage.haskell.org/package/vivid-0.4.2.4 (TomMurphy)
10:27:48 <maralorn> Is there something nicer than "fold <$> sequence [pure "a", pure "b"]"?
10:31:21 <tomjaguarpaw> Nicer in what way?  "ab" is pretty nice.
10:31:22 <ski> do you have those `pure's in your code ?
10:32:59 <ski> note that `sequence (fmap pure as) = pure as' (at least when `as' is finite)
10:33:58 <Carl20> Hello good evening, I tried to install chocolatey but only 4/5 packages succeeded, ghc failed to install, hoping for some help, thanks!
10:38:34 <lordcirth_> Carl20, was there an error message?
10:44:59 <Carl20> It only showed this one: ghc (exited -1) - Error while running 'C:\ProgramData\chocolatey\lib\ghc\tools\chocolateyInstall.ps1'
10:45:07 <Carl20> lordcirth_
10:47:18 <C20> Within the chocolatey.log, it only showed this one: The install of ghc was NOT successful.
10:50:20 <lordcirth_> C20, maybe you should ask on chocolatey help how to get better logs
10:55:19 * hackage structs 0.1.4 - Strict GC'd imperative object-oriented programming with cheap pointers.  https://hackage.haskell.org/package/structs-0.1.4 (ryanglscott)
10:57:16 <frdg> I am trying to use lenses and I am not understanding what I need to do. `:t (^.) :: s -> Getting a s a -> a`. To me I should get back a string with this function (which is what I want) but I am not really sure what I am getting. https://dpaste.org/xYe9
10:58:28 <[exa]> frdg: the lens is usually not called _time
10:58:48 <[exa]> (as a first guess, can you try just `time` ?)
10:59:09 <[exa]> _time is the accessor function which is certainly not going to work in that place
10:59:13 <frdg> [exa]: yup
10:59:19 <frdg> thanks
11:28:19 * hackage acc 0.1.2 - Sequence optimized for monoidal construction and folding  https://hackage.haskell.org/package/acc-0.1.2 (NikitaVolkov)
12:11:32 <frdg> with lenses what is the nicest way to `get,  apply a function,  set`? 
12:12:45 <ghoulguy> frdg: over
12:13:10 <frdg> okay thank you
12:16:04 <solonarv> frdg: or %~ as an operator
12:22:07 <frdg> solonarv: I have never seen a non-binary operator. 
12:22:32 <koz_> frdg: GHC allows you to define unary postfix operators I think?
12:22:39 <solonarv> fear not, %~ still isn't a ternary operator
12:22:43 <koz_> Not many folks do it, but I think it's technically possible.
12:23:22 <ghoulguy> > let (!) = "wow" in (+) ++ (+)
12:23:24 <lambdabot>  error:
12:23:24 <lambdabot>      • Couldn't match expected type ‘[a]’
12:23:24 <lambdabot>                    with actual type ‘a0 -> a0 -> a0’
12:23:28 <ghoulguy> :(
12:23:38 <solonarv> 'lens %~ func' is a function again; commonly it's applied using & which is a flipped version of $
12:23:46 <lordcirth_> ghoulguy, ... what did you expect that to do?
12:23:55 <ghoulguy> >  let (!) = "wow" in (!) ++ (!)
12:23:56 <frdg> ohh I see what is going on there
12:23:58 <lambdabot>  "wowwow"
12:24:19 <geekosaur> PostfixOperators extension is a thing, yes
12:24:19 <solonarv> e.g.: bigRecord & lenses.here %~ func
12:25:10 <geekosaur> of curse it plays oddly with operator section syntax, like unary negation does
12:25:24 <geekosaur> *of course
12:25:41 <geekosaur> although "curse" might also describe it :)
12:28:47 <cohn> any Wreq gurus around?
12:28:55 <ghoulguy> lordcirth_: to show that there are non-function operator symbols
12:28:59 <Uniaika> (~) of irrefutable pattern is technique a non-binary operator
12:29:03 <Uniaika> (I love that term)
12:29:09 <Uniaika> (but I'll call it "unary")
12:29:47 <geekosaur> "technically"? ("technique" seems wrong there)
12:29:47 <lordcirth_> ghoulguy, is it really an operator if it's just a value?
12:30:06 <ghoulguy> lordcirth_: being a value is more general than being a function
12:30:16 <ghoulguy> being composed of symbols like that is what makes something an operator symbol
12:30:35 <ghoulguy> The "binary" aspect comes from being used in an infix position
12:30:59 <lordcirth_> Just a concrete value, then
12:31:00 <ghoulguy> but that's about the syntax at the use-site, not the thing itself
12:31:12 <ghoulguy> "concrete value" doesn't really mean anything
12:31:20 <lordcirth_> value of concrete kind?
12:31:30 <lordcirth_> To me an operator has to operate on something, that is, take at least one argument
12:31:36 <ghoulguy> concrete doesn't really mean anything, what are you hoping to get to?
12:31:51 <lordcirth_> "concrete" is usually how people pronouce the kind "*", AFAIK
12:32:05 <lordcirth_> As opposed to kind "* -> *"
12:32:09 <ghoulguy> maybe some do, but that's not an official thing
12:32:11 <Uniaika> geekosaur: yeah, I just switched to french and forgot to end the adverb 
12:32:36 <ghoulguy> lordcirth_: Maybe the term you mean is just "non-function"?
12:32:54 <lordcirth_> A non-function value, yes
12:33:33 <lordcirth_> I don't see how something can be considered an operator if it doesn't take an argument.
12:33:53 <ghoulguy> lordcirth_: it's just a syntactic construct
12:36:09 <koz_> \me o O O (A concrete value: 'x :: Concrete')
12:37:14 <ghoulguy> I suppose you could take the position that nothing "is an operator" but things can be "used as operators"
12:37:48 <ghoulguy> (!) would be a variable symbol, f could be a variable identifier, and then if you use either as: x!y or x`f`y you're using them *as an operator*
12:44:24 <ski> "operator" is a syntactic thing, yea
12:55:40 <maralorn> I have a _very_ silly problem.
12:56:05 <maralorn> I have a hunit test. I run it with "runTestTT"
12:56:19 <maralorn> But that returns "()" so I do
12:56:31 <maralorn> main = print <=< runTestTT $ myTest
12:57:14 <maralorn> But now if I run "cabal test" it will say all tests passed.
12:57:19 <maralorn> There has to be a simple solution to this.
12:57:32 <maralorn> But all hunit examples I find use ghci.
12:57:45 <maralorn> I mean this is _the_ use case for hunit.^^
12:59:25 <frdg> what is the way to do multiple lens operations in one expression? This should kind of show what I mean: https://dpaste.org/rs1B
12:59:29 <maralorn> https://github.com/hspec/HUnit/blob/master/tests/HUnitTests.hs
12:59:41 <maralorn> I can just copy that from there …
12:59:57 <dolio> `cabal test` only shows test output if tests fail, I think.
13:01:22 <dsal> frdg: tr & temp %~ (fmap MYP.celsiusToFahr) & feels %~ (fmap MYP.celsiusToFahr)
13:02:02 <dsal> I guess you don't need all those parens.
13:02:24 <frdg> ok nice
13:02:49 * hackage uniqueness-periods-vector-examples 0.7.2.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.7.2.0 (OleksandrZhabenko)
13:09:33 <solonarv> note that 'temp %~ fmap func' can also be written as 'temp.mapped %~ func'
13:18:50 <ezzieyguywuf> can anyone recommend a package that will allow me to 'stream' csv data, i.e. like pipes or conduits or w/e?
13:18:58 <ezzieyguywuf> i'm interested in reading the data in one row at a time
13:20:41 <cohn> hi, what's the difference between "import qualified Foo.Bar as B" and "import Foo.Bar as B"?
13:21:06 <cohn> I know what a qualified import means but it seems like you don't really need to use the "qualified" keyword
13:21:43 <dolio> Without the `qualified`, it imports everything unqualified as well.
13:21:44 <ezzieyguywuf> cohn: when you don't use the 'qualified' keyword, thet `B.SomeFooFunc` and `SomeFooFunc` are both valid.
13:22:05 <ezzieyguywuf> yea what dolio said.
13:22:21 <[exa]> cohn: 'qualified' is mainly for preventing name ambiguity in the "unprefixed" globally available names
13:23:48 <[exa]> .....btw why is it called 'qualified'?
13:25:21 <ezzieyguywuf> b/c it forces you to 'qualify' any functions from the imported module that you wish to use with a prefix, I imagine
13:26:05 <ezzieyguywuf> `import Foo; import Bar; someFuncInBothFooAndBar` ghc won't know which to use, so it'll ask you to "qualify" the function name with a prefix (in this case the module name)
13:26:31 <cohn> ok, thanks everybody.
13:27:15 <cohn> coming from python, where qualifying an import is just "import foo as bar", the difference was confusing
13:28:36 <ezzieyguywuf> cohn: it's similar, just adds an extra layer of tunability in haskell
13:29:07 <ezzieyguywuf> i.e. to accomplish `import Foo as Bar` in python you'd need two lines, `import Foo; import Foo as Bar`
13:33:13 <ezzieyguywuf> hrm, maybe pipes-csv
13:35:35 <cohn> ezzieyguywuf: true, but I was only curious about qualifying an import. So, seems like I need to use the "qualified" keyword so I don't potentially step on similar-named functions
13:36:30 <cohn> so for Python's "import foo.bar as b" I need to do "import qualified Foo.Bar as B" in Haskell
13:36:57 <ezzieyguywuf> cohn: yea, I use qualified pretty much every time
13:37:19 <ezzieyguywuf> correction: I use qualified every time I import a whole module.
13:37:35 <ezzieyguywuf> cohn: usually I just import exactly what I need, i.e. `import Foo(Bar, Baz)`
13:37:52 <cohn> exactly
13:38:17 <ezzieyguywuf> cohn: but this is unqualified, so I use Bar and Baz "bare". I prefer this, though, as it keeps my namespace uncluttered
13:39:40 <cohn> yea. The hlint utility definitely helps in that regard!
15:26:48 * hackage fourmolu 0.2.0.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/fourmolu-0.2.0.0 (GeorgeThomas)
15:58:14 <monochrom> http://www.vex.net/~trebla/tmp/hasdoc  :)
16:53:19 * hackage pandoc-plot 0.9.4.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.9.4.0 (LaurentRDC)
17:15:08 <inkbottle> variadic/dyadic fixed point: I don't understand the 6th line of code; is there a mistyping (why the `~`)? https://web.archive.org/web/20160304101809/http://osdir.com/ml/lang.haskell.cafe/2003-10/msg00211.html
17:16:02 <inkbottle> polyvariadic*
17:18:04 <ski> inkbottle : lazy/irrefutable pattern-match
17:19:29 <koz_> ski: What's the idea behind irrefutable pattern matches? How do they differ from regular ones?
17:20:36 <ski> if you have a pattern like e.g. `x:xs', it will check, when matching, whether the list is non-empty .. and if it's empty, it'll discard this case, and try the next instead
17:20:48 <inkbottle> ski: right, thanks 
17:21:10 <ski> but, with an irrefutable pattern `~(x:xs)', the pattern-matching will always succeed, immediately, regardless of whether the list is empty or not
17:22:09 <ski> only when you actually try to access the value of `x' ior `xs', will it try to match the list with `x:xs' (and if that fails, you get a pattern-match failure. it won't "travel back in time" to try the next alternative/case. it's already too late for that)
17:22:15 <ski> now, consider
17:22:19 <ski> @src partition
17:22:19 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
17:22:20 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
17:22:20 <lambdabot>                               | otherwise = (ts, x:fs)
17:22:51 <ski> > let (evens,odds) = partition even [0 ..] in (take 4 evens,take 4 odds)
17:22:53 <lambdabot>  ([0,2,4,6],[1,3,5,7])
17:22:59 <ski> and compare this with
17:23:43 <ski> @let partition' p xs = foldr (select' p) ([],[]) xs where select' p x (ts,fs) p x = (x:ts,fs) | otherwise = (ts,x:fs)
17:23:43 <lambdabot>  Parse failed: Parse error: |
17:23:48 <ski> er
17:23:51 <ski> @let partition' p xs = foldr (select' p) ([],[]) xs where select' p x (ts,fs) | p x = (x:ts,fs) | otherwise = (ts,x:fs)
17:23:53 <lambdabot>  Defined.
17:24:17 <ski> which is what you get, if you remove the lazy / irrefutable pattern `~<pat>' from the former
17:24:20 <ski> now, we get
17:24:25 <ski> > let (evens,odds) = partition' even [0 ..] in (take 4 evens,take 4 odds)
17:24:31 <lambdabot>  mueval-core: Time limit exceeded
17:24:55 <ski> in this case (passing an infinite list as input), it's crucial to have the `~' here !
17:25:22 <ski> also, for a long, but finite list,  partition  will produce output, before seeing the end, but  partition'  won't !
17:25:50 <koz_> ski: OK, that makes sense, and is very interesting.
17:25:53 <koz_> Thank you!
17:26:33 <ski> (and if you use `readFile' or `getContents' to process a file that's very big, possibly even too large to fit into memory all at once (lazy I/O), you don't want to have to see the end of the list, before you can produce some part of the output. you want to be "incremental", rather than "bulky".  partition  is incremental)
17:27:22 <ski> the problem is that, if you're just matching on `(ts,fs)', you're actually matching on the recursive call to `foldr'. so, you're forcing `foldr' to get to the end of the list, before you can output the current element `x' in one or the other of the output lists
17:27:45 <ski> by matching on `~(ts,fs)', you delay that forcing of the recursive call
17:27:48 <ski> @src foldr
17:27:48 <lambdabot> foldr f z []     = z
17:27:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:28:22 <ski> in this case, `~(ts,fs)' is perfectly safe, since there's no way that matching on `(ts,fs') (later) can fail with a pattern-match error
17:29:07 <ski> now .. lazy patterns aren't required that often. but when there's a situation that calls for them, they can help make the code more readable
17:29:52 <ski> insyead of `select p x ~(ts,fs) = ..ts..fs..' here, we could have said `select p x tsfs = ..(fst tsfs)..(snd tsfs)..', and it would also have worked
17:31:09 <ski> or, instead of `foo ~(x:xs) = ..x..xs..', one could say `foo xs0 = ..x..xs.. where (x,xs) = case xs0 of x:xs -> (x,xs)' (or `foo xs0 = ..(case xs0 of x:_ -> x)..(case xs0 of _:xs -> xs)..')
17:31:28 <ski> however, the first is more readable
17:36:09 <cohn> for anyone that's familiar with the Wreq HTTP library: when you use a lens on a nested object, how do you get the values out?
17:37:46 <dsal> What do you mean?
17:38:34 <dsal> cohn: I have a few helpers: https://github.com/dustin/gopro-plus/blob/master/src/GoPro/Plus/Internal/HTTP.hs
17:38:54 <cohn> dsal: so if I have some json data like '{"foo": ["bar", "baz"]}' the array seems to get transformed into a Vector. How would I get the values out?
17:40:59 <dsal> I think I'd probably use `toListOf`
17:41:15 <cohn> hmm. okay
17:41:16 <dsal> I'm looking for a simple example, but none of my examples end up being quite simple enough.
17:41:55 <cohn> exactly my dilemma.  : (
17:42:04 <dsal> Maybe this one:  https://github.com/dustin/gopro-plus/blob/master/src/GoPro/Plus/Media.hs#L173-L180
17:43:23 <cohn> that's promising. Thanks!
17:44:58 <dsal> I was hoping one of the bots had Aeson, but `toListOf` is your friend here.
17:45:13 <dsal> Or just use the vector, but that can be annoying sometimes.
17:45:30 <dsal> Or make a custom type and let it parse into that.  I guess it depends on what you actual want.
17:45:53 <cohn> for now, just trying to learn Aeson and Wreq on some play data
17:46:37 <dsal> Much of mine ends up accessing custom types.  Aeson will run my FromJSON code and just give me a value of my type.
17:46:59 <dsal> I do occasionally play with the underlying Aeson Value thing, though.
17:47:00 <cohn> I'll probably need to do the same
17:47:12 <dsal> Doing the "hard" thing may very well save you a lot of time and confusion.
17:48:05 <dsal> Aeson lens is cool when you really want to just pull a smaller blob out of a big wad of JSON.  But if you have a regular form you intend to do a lot with, you'll find the long road shorter.  :)
17:48:42 <cohn> I was hoping to avoid actually having to write a bunch of code just to play around with some data but I think you're right.
17:50:12 <dsal> You can do it in lens code, or you can do it in type code.  If you're in a repl, the lens stuff might be easier.  If you're in a file, defining a type is straightforward unless you need to do some custom decoding.
17:50:28 <cohn> I will say though, Wreq + Aeson + Lens makes this MUCH less painful.
17:50:56 <cohn> I might need some custom decoding for a few things, but I think I have everything I need.
17:51:08 <dsal> cohn: e.g., much of my code looks something like this:  https://github.com/dustin/tesla/blob/master/src/Tesla/Car.hs#L215-L228
17:52:07 <dsal> Actually, from about there down is defining a sum type for two different types of results, making a request with wreq, and returning a list of the things of my type.
17:52:21 <cohn> ooh, nice
17:52:38 <dsal> (the two functions in the middle aren't actually part of this, just helpers for looking at only one type or other based on the prism)
17:54:59 <cohn> prism?
18:56:45 <dsal> cohn: Sorry, went outside for a bit.
18:56:47 <dsal> > [Right 1, Right 2, Left 3, Right 4, Left 5] ^.. folded . _Right
18:56:50 <lambdabot>  [1,2,4]
18:57:39 <dsal> prism is a concept in optics that lets you do fun things with sum types.
18:59:53 <cohn> ah
19:06:22 <dsal> > [Right 1, Right 2, Left 3, Right 4, Left 5] & traversed . _Left  %~ (^2) -- cohn: you can also do stuff where prisms point you a particular way.
19:06:24 <lambdabot>  [Right 1,Right 2,Left 9,Right 4,Left 25]
19:06:38 <cohn> oh cool.
19:06:53 <cohn> maybe I can use that to pull the data out of my lens result
19:07:35 <dsal> In my case, I get a big blob of results that includes both superchargers and destination chargers as different JSON results, but my charger type supports both and then lets me disambiguate later if I need to.
19:09:59 <cohn> I have a value "x" with type "x :: vector-0.12.1.2:Data.Vector.Vector Value" but I'm not sure how to get the values out. I thought you could use the "!" operator on a vector 
19:10:32 <cohn> but it appears that it's storing an Aeson Value type that I'm not sure how to deal with.
19:13:11 <dsal> I kind of wish I could aeson with a bot here, but... what lens library are you using?
19:13:34 <cohn> both "Control.Lens" and "Data.Aeson.Lens"
19:14:21 <dsal> Yeah, but what library is the latter?
19:14:33 <dsal> @package lens-aeson
19:14:33 <lambdabot> https://hackage.haskell.org/package/lens-aeson
19:15:16 <cohn> checking.
19:15:38 <cohn> yea, should be lens-aeson
19:15:41 <dsal> The docs on that one show you how to use the prisms over value.
19:16:21 <dsal> Do you have a small sample of your JSON and what you want to do with it?
19:17:00 <dsal> `stack ghci` in this project wants to go grab a copy of ghc.  So... this will take me a sec.  heh
19:17:30 <dsal> Oh wait, here's one where I have all the parts.
19:17:36 <cohn> sure, I'm basically working with the Kodi JSON RPC API
19:17:44 <cohn> fwiw:  https://kodi.wiki/view/JSON-RPC_API/Examples
19:19:39 <dsal> I looked up at your example above:
19:19:54 <dsal> λ> "{\"foo\": [\"bar\", \"baz\"]}" ^.. key "foo" . _Array . folded . _String    ->   ["bar","baz"] 
19:20:17 <cohn> that's exactly what I'm trying to do...  :D
19:23:20 <dsal> λ> "{\"foo\": [\"bar\", \"baz\"]}" ^. key "foo" . nth 1 . _String    ->  "baz"
19:25:34 <dsal> λ> "{\"foo\": [\"bar\", \"baz\"]}" ^.. members . values  --  also, this sort of thing  --> [String "bar",String "baz"]
19:26:56 <cohn> ok, here's a sample of the data I'm working with:  https://pastebin.com/cYUUvXHe
19:28:20 <cohn> if "r" is my HTTP request response, I'm doing this:  r ^? responseBody . key "result" . key "tvshows" . _Array
19:28:47 <cohn> sorry, replace "^?" with "^."
19:29:04 <dsal> Sure.  I've got r as the responseBody in my repl
19:30:29 <cohn> that gives me something like this:
19:30:30 <cohn> [Object (fromList [("tvshowid",Number 157.0),("label",String "Show1")]),Object (fromList [("tvshowid",Number 164.0),("label",String "Show2")]),Object (fromList [("tvshowid",Number 31.0),("label",String "Show3")]),Object (fromList [("tvshowid",Number 162.0),("label",String "Show4")]),Object (fromList [("tvshowid",Number 163.0),("label",String "Show5")])]
19:30:45 <cohn> so it looks like an array of objects to me
19:30:52 <dsal> It's a list of an object.
19:31:03 <cohn> I want to get the pairs of show ids and labels out
19:33:04 <cohn> I assume it'd be easier to create a type for that and use FromJSON/ToJSON but it'd be nice to just explore the data without that stuff
19:34:03 <dsal> This is a little annoying.   r ^.. key "result" . key "tvshows" . _Array . folded . to (\x -> (x ^? key "label" . _String, x ^? key "tvshowid" . _Integer))
19:34:08 <dsal> But yeah, it'd be easier if you just had a type for that.  :)
19:35:04 <cohn> heh, okay
19:35:08 <dsal> You can't guarantee all of those things have the correct values, so they'd have to be maybes at best (which you could do in that lambda).  Actually, that looks fun.
19:36:02 <cohn> depends on your definition of fun...  ; )
19:36:29 <dsal> You can't guarantee all of those things have the correct values, so they'd have to be maybes at best (which you could do in that lambda).  Actually, that looks fun.
19:36:32 <dsal> Try this awful thing:   r ^.. key "result" . key "tvshows" . _Array . folded . to (\x -> do { l <- x ^? key "label". _String;  i <- x ^? key "tvshowid" . _Integer; pure (l,i)} ) . to sequenceA
19:36:35 <dsal> Oops, sorry for the dup.
19:37:36 <dsal> Oh wait, that was dumber than I meant.
19:37:51 <cohn> didn't work.
19:38:17 <dsal> r ^.. key "result" . key "tvshows" . _Array . folded . to (\x -> do { l <- x ^? key "label". _String;  i <- x ^? key "tvshowid" . _Integer; pure (l,i)} ) . _Just
19:38:35 <dsal> That returns   [("Show1",157),("Show2",164),("Show3",31),("Show4",162),("Show5",163)]  for me.
19:39:47 <cohn> ah, okay. I'm getting an error but probably because my result is a lazy byte string
19:40:06 <cohn> <interactive>:51:7: error:
19:40:06 <cohn>     • No instance for (AsValue
19:40:06 <cohn>                          (Response Data.ByteString.Lazy.Internal.ByteString))
19:40:06 <cohn>         arising from a use of ‘key’
19:40:08 <cohn>     • In the first argument of ‘(.)’, namely ‘key "result"’
19:40:42 <cohn> I need to redo this... I was using the http-conduit library but I should convert it all to Wreq
19:41:17 <dsal> Yeah, you need to tell wreq to give you JSON
19:41:51 <dsal> There's an `asJSON` call in there somewhere.
19:41:54 <cohn> yep
19:42:19 <dsal> Did you get it working?
19:42:27 <cohn> should be something like r <- asJSON =<< get "http://blahblah" 
19:42:42 <dsal> Yeah, I end up burying that in helpers.
19:42:45 <cohn> not yet. 
19:42:54 <dsal> jget :: (FromJSON j, MonadIO m) => String -> m j;   jget u = view responseBody <$> liftIO (asJSON =<< get u)
19:43:39 <cohn> nice
19:45:07 <dsal> Once you get it working, delete this all and do it a sane way.  :)
19:45:40 <cohn> haha, will do. Thanks so much for all your help!
19:46:17 <dsal> I do occasionally use this for weird one-off HTTP things, but making a type makes it easier.  Then making lenses for my types gives me the same things with fewer conversion prism things.
19:46:42 <cohn> I now see the benefit of types!
19:47:26 <dsal> You can do *bizarre* stuff with Aeson lenses.  One of the Advent of Code problems had me like, sum up all of the numbers in an arbitrarily complex JSON file.  That's a half-liner.
19:47:51 <cohn> fwiw, I'm coming from a Python background. Trying to switch some development over to Haskell for the safety and purity gains
19:48:07 <cohn> plus, the Python GIL sucks. :D
19:48:09 <dsal> Well, you're trying to learn haskell and lenses at the same time.  That's also kind of a lot.  heh
19:48:17 <cohn> it is
19:48:23 <dsal> Yeah, I burn every nearby thread with my haskell projects.
19:49:34 <cohn> I know the basics of Haskell so I can at least create the types for handling the JSON data
19:50:07 <cohn> I completed the "Get Programming with Haskell" book by Will Kurt. Great read!
19:50:26 <cohn> wanted to take that knowledge and start doing useful things with Haskell.
19:51:34 <dsal> I don't know that one, but I like your style.  :)
19:52:10 <dsal> Haskell's been my goto language for a while now.  I don't do heavy lens stuff much, so I stay a bit rusty there, but for blue collar stuff, it's pretty great.
19:52:23 <dsal> I can pick up projects I've not looked at in months and drop a new feature in with little effort.
19:52:53 <dsal> My biggest complaint is that it's often *too* little effort.  Like, I sit down to write a bit of code and then once I figure out what I want to do, I'm done.  Now I'm sad because my big project isn't.
19:53:01 <cohn> that's not always easy to say with other languages
19:53:42 <dsal> You'd *think* it'd be hard with haskell with some of the golf we do sometimes, but in practice, it just means the hard parts are in one place and well tested, and the easy parts are just kind of obvious.
19:54:12 <dsal> For an egregious example, here's the code that honks the horn and flashes the lights in my car:  https://github.com/dustin/tesla/blob/master/src/Tesla/Car/Command/Alerts.hs
19:54:40 <dsal> https://dustin.github.io/tesla/Tesla-Car-Command-Alerts.html -- (there's a longstanding bug about not being able to document TH stuff better, unfortunately)
19:54:50 <cohn> hah, nice
19:54:57 <dolio> I don't know why anyone would think it'd be hard.
19:55:18 <dolio> People haven't been developing functional programming for 50+ years to make programming harder.
19:55:45 <dsal> Haskell is only for smart people who think they're better than everyone else.
19:56:33 <dsal> Or at least people who *think* they're smart, but can't even explain monads to me like I'm five in six words or less without having me understand any further context.
19:56:49 <cohn> xD
19:57:30 <dsal> Imagine talking to a programmer who only knows like, BASIC.  They want you to explain python metaclasses to them, but in terms of things they understand.
19:57:38 <cohn> what's that saying: better to be quiet and have people think you're an idiot than open your mouth and remove all doubt
19:57:41 <cohn> something like that.
19:58:05 <dsal> Nah, go ahead and ask dumb questions.  Better to have people think you're dumb than to just sit around being dumb.  :)
19:58:17 <cohn> yea, I probably couldn't explain stuff to a BASIC programmer
19:58:24 <cohn> lol, true
19:58:53 <ski> @quote beyond.hope
19:58:53 <lambdabot> EdsgerDijkstra says: "It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
19:58:54 <lambdabot> regeneration."
19:59:08 <cohn> I will say, everyone I've encountered in this channel has been incredibly helpful. I've learned quite a lot so far
19:59:15 * ski raises hand
19:59:26 <ddellacosta> it's better to be loud and have people think you're an idiot than suffer in ignoranc.
19:59:26 <cohn> heh
19:59:32 <ddellacosta> *ignorance
19:59:44 <dsal> It's a bit of the blub paradox.  Everything the BASIC programmer knows is in terms of GOTO and GOSUB.  Why do you need a function?  It's just a fancy case of GOSUB.  Same thing as you go up.  I can't explain a functor to you if you don't have a concept of data structures or functions.  Even if you've probably used them.
20:00:38 * ski remembers `DEF FNAR(R)=PI*R^2'
20:01:17 <ski> people have to take it in reasonable enough steps
20:01:49 <dsal> Yeah, and some people believe that's incorrect and if they can't understand it in one, then it's a pointless waste of time.
20:02:00 <monochrom> I need a function because GOSUB doesn't let me pass parameters or return values unless I set aside global variables for that and hope I don't make a mistake.
20:02:04 <ski> not much you can do about it ..
20:02:13 <cohn> dsal: you must read Paul Graham essays.  ; )
20:02:16 <dolio> monochrom: Just don't make mistakes.
20:02:32 <dsal> I was trying to explain a trivial thing I did in a library using STM that was really exciting to me to someone once.  She was like, "Can't you do that in java?"  Which... yes, I could solve this problem in java, but it'd be an engineering feat for this one exact use case.  I wrote the code without considering this use case.
20:02:35 <dsal> cohn: heh, that one at least.
20:02:39 <monochrom> And then if I desire a recursive function I'm screwed.
20:03:00 <cohn> dsal: http://paulgraham.com/avg.html ?
20:03:06 <ski> who needs dynamic allocation of variables ..
20:03:12 <ski> cohn, yep
20:03:53 <dsal> cohn: yeah, it at least helps the understanding.  If you only know language X and are good at it, then it's all you need and it's hard to talk to you in terms of things that you can't possibly do that I feel like I require to solve my problems.
20:04:17 <ski> you can call a subroutine by modifying the ending `jmp' instruction to jump back just after where you `jmp'ed to it
20:04:33 <dsal> e.g., I've seen STM in other languages (e.g., C++, java, etc...), but they all look very hard to use correctly in a way that haskell is nearly impossible to use incorrectly.
20:04:46 <monochrom> So I was an exception to Dijsktra's quote. BASIC prepared me to be disappointed at BASIC and ready to receive Pascal as gospel.
20:05:23 <dsal> monochrom is secretly working his students up to be Pascal programmers.
20:05:59 <ski> i remember learning about C (and compilation), being amazed at the idea that there was a standardized format for functions, each function didn't have its own custom syntax ..
20:06:04 <cohn> dsal: exactly. the blub paradox is one reason I set out to learn FP. Just so happens that Haskell is a general purpose language without all the damn parenthesis. 
20:06:09 <cohn> hehe
20:06:49 <dsal> Yeah, and once you learn about some of our tools, you'll be incredibly frustrated when you go to work and they don't let you use them.
20:06:51 <cohn> err, s/parenthesis/parentheses/
20:06:59 * ski . o O ( "6. The more you know, the more you know." )
20:07:24 <cohn> I'm already loving stack and the language server plugin for VS Code (yea, yea)
20:07:29 <dsal> Or you see really bad translations of stuff.  go shipped with a quickcheck library that is fundamentally broken because the language is lacking in several dimensions.
20:07:41 <dsal> was the (yea, yea) for stack or VS?  :)
20:07:47 <dsal> We have our own subreligions.
20:07:48 <cohn> hmm...
20:08:08 <cohn> VS Code. I'd imagine most folks shun it in favor of Emacs
20:08:12 <dsal> I like/use stack, but some people will fight.
20:08:27 * monochrom draws sword
20:08:38 <dsal> emacs is the one true religion, but we support alternative lifestyles
20:08:42 <dolio> I mean, I don't care what other people use. I just want them to stop telling me to use their stuff.
20:08:46 <cohn> I normally would too since I tend to associate anything from Redmond with pure evil, but I gotta say, VS Code is pretty nice
20:08:53 <dolio> Or lying about the stuff I use.
20:09:11 <dsal> cohn: You're talking like you're around my age.  heh
20:09:28 <dsal> It was kind of nice doing a fresh nixos install today and starting a project build without installing stack or ghc or anything.
20:09:37 <cohn> I might be
20:09:59 <cohn> been doing this crap for ~ 30-ish years
20:10:17 <cohn> wish I had found FP much sooner.
20:10:22 <dsal> There are brilliant haskell brains at MS.  Keeping some of those folks on the payroll at least makes me feel much better about them.
20:10:29 <dsal> cohn: You're describing everything in my life.
20:10:48 <cohn> whoa. 
20:10:54 <iqubic> dsal: I do love a fresh nixos install.
20:11:02 <dsal> The good news is, though I've never found anything and felt like I was too late, I still hopefully have some time left.
20:11:08 <iqubic> Haskell and Nix work so well together.
20:11:15 * cohn must be in The Matrix
20:11:29 <dsal> nixos is another religion that bumps up against people in this channel at times.  heh
20:12:22 <dsal> iqubic: are you using haskell.nix?  I'm super lazy.  It's nearly zero effort for me to build my packages, but it's a lot effort for the computer.
20:13:03 <cohn> I just want to learn everything I can. I use what works best for what I need and leave the religous wars to everybody else
20:14:14 <cohn> e.g. I use vim, Emacs, and VS Code every day for different things. I've played with Nix a little bit, as well ask stack and cabal.
20:14:36 <dsal> Sure, sure.  nixos is a Linux distribution that solves all of my OS problems.  It's not super relevant here.
20:15:22 <dsal> I think stack is a little less popular here, but I've not been able to replace it yet.  Each time I try, there's something that it does that I have a hard time replacing, so I don't bother.
20:15:58 <cohn> nix seems very well suited to use with Docker. But that could be overkill.
20:16:40 <dsal> nix is an alternative to docker in many ways.  You end up with much less overhead and more resource sharing and stuff.  That said, I run docker on nixos when I need it.  *shrug*
20:17:07 <cohn> huh, never thought about it that way
20:18:10 <dsal> I do a build of my project, copy it into an external nix store, and then pull it down and run the specific version where I need it.  I run a bunch of junk in aws on a machine too small to actually do the build, so I spin up a big machine to do the build, then copy artifacts out and upgrade when needed.
20:18:32 <dsal> Something about my lazy haskell.nix thing means it often ends up building like, all of ghc to make a binary.  A little expensive, but it's just zero effort on my part.
20:20:03 <dsal> I had a small fix of my mqttd a day or so ago and the build process took *hours* on a large AWS machine.  It actually caches all those artifacts, but I don't keep any of that state.
20:20:31 <dsal> haskell *can* compile very slowly.  Some of my Advent of Code solutions run in O(1) time because I made the compiler compute the answer. heh
20:23:19 <cohn> that's cheating.  ;)
20:23:56 <dsal> Not in that case, but it was just to do it.
20:24:26 <cohn> heh
20:24:49 <dsal> I liked running the benchmarks and having it say my solution was around 6 ns.
20:26:41 <monochrom> If you can compile slowly, you can run quickly. >:)
20:39:00 <kreyren> i asked this question in #haskell-stack but reasking here as it seems that the channel has low traffic
20:39:04 <kreyren> i am keep getting https://dpaste.com/ASUFJEDKC.txt running build target in makefile http://ix.io/2zyp -> How do i make sure it's not trying to halt my system over time
20:39:08 <kreyren> basically fails to compile each time, system info http://ix.io/2zyr
20:53:36 <kreyren> created swapfile with 2G and that made it to continue past the breakpoint so i guess there is an issue with resource allocating on linux
20:58:34 <c_wraith> there are a couple of libraries that do so much inlining that they take up ridiculous amounts of memory to compile
20:59:09 <dsal> I think I end up building those in parallel
20:59:13 <c_wraith> vector-algorithms is the worst offender in my exerience, but there are probably some others.
20:59:42 <dsal> kreyren: you may consider reducing concurrency
21:00:13 <kreyren> dsal, i am not upstream can you elaborate?
21:00:41 <dsal> You can limit jobs in ~/.stack/config.yaml
21:01:19 <dsal> https://docs.haskellstack.org/en/stable/yaml_configuration/#jobs
21:01:40 <kreyren> checking
21:02:51 <dsal> -j1 will take longer, but use less memory
21:40:47 <hololeap> class Foo a where ; type Bar a ; foo :: Bar a -> Maybe Bool
21:41:07 <hololeap> why is GHC trying to make me turn on AllowAmbiguousTypes for this?
21:41:27 <c_wraith> because it has no way to infer `a' from a call to foo
21:41:47 <ski> `Bar' is not injective
21:42:06 <hololeap> ski: what does that mean?
21:42:37 <ski> it means that you could possibly have `Bar T0 = Bar T1', for two different types `T0' and `T1'
21:42:40 <c_wraith> instance Foo Int where Bar Int = ()   ;   instance Foo Bool where Bar Bool = ()
21:43:35 <ski> so, if you're passing something of type `Bar T0' to `foo', and say that `Bar T0 = String'. then it you also have `Bar T1 = String', and so it doesn't know whether to use the `Foo T0' or the `Foo T1' instance (which may give different implementations for `foo')
21:43:57 <hololeap> so, since there could be multiple instances of Foo which define the same Bar, there is no way to determine the Foo, given a Bar?
21:44:11 <ski> (that is, you're actually passing `String' to `foo', and it can't decide whether you mean `Foo T0' or `Foo T1')
21:44:14 <c_wraith> Not by inference, anyway
21:44:29 <c_wraith> You can use -XTypeApplications
21:44:35 <hololeap> c_wraith: it yells at me just with the class definition
21:44:36 <ski> you could declare `Bar' to be an associated `data' type. then it'd be injective
21:44:56 <c_wraith> yes, you need to allow the class, too
21:45:03 <ski> or, you could add an FD on it, to declare that it must be injective (prohibiting having both `Foo T0' and `Foo T1' as instances)
21:45:31 <hololeap> ski: what would that look like in this case?
21:46:50 <hololeap> are you saying have something like `class Foo a bar | a -> bar ...`
21:47:27 <ski>   class Foo a where {type Bar a = b | b -> a; foo :: Bar a -> Maybe Bool}
21:47:52 <hololeap> oh, i didn't know you could use functional dependencies on type families in a class
21:49:23 <ski> (if one could use the usual FD syntax, it would have looked like `class Foo a | (Bar a) -> a where ..'. but that's not allowed syntax. an FD `x y -> z' means `z' is functionally determined by `x' and `y', not by `x' applied to `y')
21:50:04 <ski> anyway, of course you could instead use `class Foo a bar_a | bar_a -> a where bar :: bar_a -> Maybe Bool', if you want to go for MPTC with FD
21:51:21 <hololeap> so `b -> a` in FD terms means that each `b` must have exactly one `a` (thus ensuring injectivity)
21:52:12 <ski> (and, as i said, you could have done `class Foo a where data Bar a; foo :: Bar a -> Maybe Bool}'. but then you couldn't make synonyms in some instances)
21:52:22 <ski> hololeap : no, at most one
21:52:45 <hololeap> right, since some b's may not have a typeclass associated with them
21:53:05 <hololeap> or, that particular typeclass
21:53:27 <hololeap> they may not have an instance of the given typeclass associated with them
21:54:20 <ski> if you have `class Blah a b c | a -> b where ...', then the FD here logically means `forall a. unique b. exists c. Blah a b' (by `unique' i mean "exists at most one"), which is logically equivalent to `forall a b0 b1 c0 c1. (Blah a b0 c0,Blah a b1 c1) => b0 = b1'
21:55:03 <ski> iow, if two instances of `Blah' agrees in the `a' parameter position, then they've got to also agree in the `b' parameter position (or else you're not allowed to have both instances at the same time)
21:56:39 <hololeap> so, `class Foo a b | b -> a ...` `instance Foo Int String` `instance Foo Bool String`
21:56:42 <hololeap> would not be allowed
21:56:48 <ski> right
21:57:46 <hololeap> okiedoke. this opens up a new world of GHC yelling at me. thanks :)
21:58:16 <hololeap> (not sarcastic, though tongue in cheek)
21:58:22 <ski> so practical effects of FDs are two. (a) not being allowed to have such instances at the same time, which would violate the FD; and (b), if during type inference/checking, it has derived that `Blah a b0 c0' and also `Blah a b1 c1' holds, then it knows that `b0' and `b1' must be equal, so it goes on to unify them directly
21:59:03 <ski> if there's no `c' part, then that in turns means that it can simplify the constraint `(Blah a b0,Blah a b1)' to just `Blah a b'
22:00:05 <ski> and, this unification of `b0' and `b1' typically manifests itself as getting less ambiguous types, less need for explicitly informing the type system that, yes, you'd like this `b' over here to actually be the same as that `b' over there
22:01:04 <ski> or, in your case, as allowing a signature that would otherwise be illegal, due to being ambiguous (no way to determine `a' from the argument and result type of `foo')
22:02:39 <hololeap> ski, why did you write `forall. a` earilier? wouldn't this signify that every possible type needs to have an instance of this class?
22:02:54 <ski> no
22:03:15 <ski> are you thinking about the `forall a. unique b. exists c. Blah a b' formulation, or the `forall a b0 b1 c0 c1. (Blah a b0 c0,Blah a b1 c1) => b0 = b1' formulation ?
22:03:38 <hololeap> `forall a. unique b. exists c.`
22:03:57 <hololeap> i put the period in the wrong place
22:04:24 <ski> that reads as : for each type `a', there can be at most one type `b', such that for (at least) one type `c', we have an instance `Blah a b c'
22:04:42 <hololeap> ok
22:05:07 <hololeap> i see what you're saying
22:05:36 <ski> note that `unique b. ..b..'/"there can be at most one type `b', ..`b'.." is contravariant in `..b..'. so it's not demanding that `..b..' should hold, but rather placing a constraint on situations in which it does hold
22:06:58 <ski> `unique b. ..b..' means `forall b0 b1. (..b0..,..b1..) => b0 = b1'. so `unique b. exists c. Blah a b c' means `forall b0 b1. (exists c. Blah a b0 c,exists c. Blah a b1 c) => b0 = b1'
22:07:36 <hololeap> and `exists c.` just means that c needs to be defined, no other constraints
22:07:39 <ski> so, `Blah ...' ends up not in the consequent (after the `=>'), but in the antecedent (before the `=>'), of the implication
22:08:26 <hololeap> got it
22:08:33 <hololeap> never had it explained that way before
22:08:39 <ski> (and, in turn, `(exists c. Blah a b0 c,exists c. Blah a b1 c) => b0 = b1' becomes `(exists c0 c1. (Blah a b0 c0,Blah a b1 c1)) => b0 = b1', which becomes `forall c0 c1. (Blah a b0 c0,Blah b1 c1) => b0 = b1')
22:09:26 <ski> "and `exists c.` just means that c needs to be defined, no other constraints" -- exactly. there just has to be some `c', we don't care which (can be different, for the two different instances that we're considering). `c' is irrelevant to the FD `a -> b'
22:11:01 <ski> the same interpretation of FDs applies to relations/tables, in relational data base design (usually one thinks of this, when doing normalization of relations)
22:13:15 <ski> (one can, similarly, do normalization of MPTCs with FDs. and i suppose also if you have ATs with injectivity annotations)
22:15:00 <p0a> Hello
22:15:10 <p0a> is there a way to view documentation of the Main module in haddock?
22:34:47 <p0a> I can see how the compiler catches bugs now with the type system 
22:35:11 <p0a> for example when you add fields to a type, the constructor will no longer match the signature 
22:35:37 <p0a> whereas in C you can get silent compilations with uninitialized data
22:35:56 <p0a> and even if the code is correct, you still need to dig up all such occurences and fix them. 
22:36:38 <dsal> You can totally have uninitialized fields in haskell types.  :)
22:36:55 <dsal> It's a bad idea, but occasionally it's useful.
22:41:16 <p0a> dsal: Okay but (X y z) messes up when you change X to three fields, right? :)
22:41:25 <dsal> Yeah.
22:41:46 * ski . o O ( (`-Wmissing-fields',`-Woverlapping-patterns',)`-Wincomplete-patterns',`-Wincomplete-uni-patterns' )
22:42:15 <dsal> Same as in go and other languages.  That's not the revolutionary benefit of haskell's type system.  :)
22:42:44 <ski> > let foo Node{} = () in foo Node{}  -- not really fond of such patterns
22:42:47 <lambdabot>  ()
22:45:25 <p0a> Why do I get this error? file-library-exe: ./library.database: openFile: does not exist (No such file or directory)
22:46:08 <p0a> https://paste.tomsmeding.com/Um3sNGUr
22:47:02 <p0a> (I know the code is long, but readDatabase and writeDatabase are relevant on Lib.hs 
22:47:25 <p0a> tomsmeding: your paste would be nicer if it had line numbers :) I think
22:47:42 <dsal> Does the file exist?
22:47:50 <p0a> No it does not 
22:47:54 <p0a> but I use readMaybe 
22:48:13 <dsal> That's not what readMaybe does.  heh
22:48:15 <dsal> :t readMaybe
22:48:17 <lambdabot> error: Variable not in scope: readMaybe
22:48:27 <p0a> oh wait
22:48:39 <p0a> huh I wonder what it is I used readMaybe for then
22:49:14 <dsal> You're trying to fmap readMaybe into an IO action that is failing.
22:50:04 <p0a> okay I see now 
22:50:15 <p0a> I remember what happened 
22:50:24 <p0a> There were two issues, I fixed one, and I forgot about the other
22:50:25 <p0a> :)
22:50:33 <p0a> Thank yuo 
22:51:08 <p0a> (This is my little project which I hope to improve, but right now trying to get version 0.01)
22:52:41 <p0a> I wanted to move to RIO soon
22:52:57 <p0a> I guess for now I'll leave this bug unfixed and assume the database exists. I think I'd have to use exceptions otherwise
23:04:19 * hackage arch-hs 0.2.0.0 - Distribute hackage packages to archlinux  https://hackage.haskell.org/package/arch-hs-0.2.0.0 (berberman)
23:29:38 <p0a> if I have a Maybe (IO ()) how am I supposed to act on it? 
23:30:04 <p0a> What's the idiomatic way? Sorry, I meant Maybe (IO T)
23:30:37 <ski> `sequence'/`sequenceA' ?
23:32:18 <p0a> so say I have a file I read. It's a Maybe (IO Database) and I'd like to print the entries of the database 
23:32:55 <p0a> if I had a database I'd just do map putStrLn (contents db)
23:33:19 <p0a> sorry, I meant mapM_
23:33:28 <c_wraith> It's vastly unlikely something that interacts with the filesystem is going to produce Maybe (IO Database)
23:33:40 <p0a> Is it a mistake c_wraith ?
23:33:53 <p0a> That's how I wrote it. I have a readDatabase that returns a Maybe (IO Database)
23:33:56 <c_wraith> IO (Maybe Database) would make much more sense.
23:34:09 <p0a> Yes, that's what it is, sorry
23:35:15 <ski> that's quite different
23:35:59 <ski> what should happen, if you get `Nothing' ?
23:36:04 <p0a> Right
23:36:53 <p0a> I see it's a problem with types. So is there an idiomatic way or do I need to do a conditional?
23:36:54 <taurux> p0a: you can use my_io_maybe_db >>= (maybe what_to_do_when_nothing (\db -> what_to_do_when_db))
23:38:01 <p0a> What does -> do?
23:38:04 <p0a> oh it's a lambda 
23:38:06 <taurux> it's a lambda
23:38:30 <taurux> what_to_do_when_nothing :: IO something
23:38:30 <c_wraith> p0a: it's not a "problem" with types.   It's just types.  At most there's a puzzle involved.  bind the value so you can use it in an IO block, then deal with the Maybe appropriately
23:38:33 <ski> do you want to catch the failure, and do something else, here ?
23:38:39 <ski> or just propagate the failure ?
23:38:47 <p0a> propagate the failure 
23:38:56 <taurux> You should use a Monad transformer
23:38:57 <taurux> MaybeT
23:38:58 <p0a> so that I never deal with it, I'm at top level :P 
23:38:59 <ski> use `MaybeT IO', possibly
23:39:30 <ski> it will short-circuit, if something fails (with `Nothing')
23:39:45 <taurux> monad transformers make semantics of failure propagation much more clear. Take a look at the dedicate chapter in LYAH
23:39:49 <taurux> *dedicated
23:40:47 <p0a> for one thing I realized it's just Maybe Database because I do bind it in a do block
23:40:53 <p0a> I'm just confused as usual 
23:42:08 <p0a> ah I know the issue, I actually have a Maybe [String] that I wish to print
23:42:41 <p0a> Because I have a Database -> [String] function applied to my db. Uh, sorry everyone I'm just confused.
23:43:14 <c_wraith> what do you want to do if it's Nothing?
23:43:49 <ski> <p0a> propagate the failure
23:44:39 <p0a> I like that (1+) <$> Nothing == Nothing, so that's the kind of thing I want 
23:44:52 <ski> .. but at some point, you're going to have to handle the possible `Nothing', in some way (perhaps just by throwing away a `Maybe ()' result ..)
23:47:14 <p0a> i.e. I wnat something like (putStrLn . show) <$> (Just 1)
23:47:19 <p0a> but as is it won't work 
23:47:36 <p0a> I think MaybeT might be what I need
23:47:37 <c_wraith> what do you want to *happen* if it's Nothing?
23:47:58 <taurux> p0a: It does not work because it has type (Maybe (IO ()))
23:48:11 <p0a> c_wraith: no print
23:48:25 <c_wraith> do you care to communicate the information to a higher level?
23:48:31 <c_wraith> err, communicate the failure
23:48:37 <p0a> no because this is version alpha of the thing I'm doing
23:48:48 <p0a> I was planning to move to RIO after I get something down and do things more properly
23:48:51 <taurux> if you use MaybeT you can directly bind it in an action in do-notation, and perform the related IO action. If it is nothing, the whole function will return Nothing (wrapped in MaybeT)
23:48:59 <c_wraith> traverse_ or mapM_ work with Maybe, too
23:49:14 <c_wraith> so you could do something like mapM_ (mapM_ putStrLn)
23:49:19 <p0a> ah two mapM_'s 
23:49:39 <p0a> nice. I did notice that mapM_ worked with Maybe which is why my code was working in the first place (but putStrLn . show was applied to [String] ...)
23:49:45 <p0a> of course! thanks 
