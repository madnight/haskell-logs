00:03:29 <Uniaika> topos: has the CLC received a copy of my email, btw?
00:05:48 <remexre> is there a reasonably-standard monad for concurrency that allows labelled + manipulable coroutines, with a "parallel" operator (of the same type as sequence)
00:08:05 <remexre> I'm building... I guess it's kind of like a structural editor for an AST while it's being eval'd, so filling in a hole might cause reductions to be performed
00:08:23 <remexre> but I'd like to be able to write the actual eval function in reasonably normal-looking haskell
00:24:47 <dminuoso> gnumonik: regarding your initial question, consider this counter example. Imagine this function `general` existed, and you applied it to `putStrLn`, what would that even do?
00:25:35 <dminuoso> Remember it can't apply anything to function passed to it to anything, because it's fully polymorphic in `a`
00:25:49 <dminuoso> *It cant apply the function passed to it to anything
00:27:37 <dminuoso> If it cant apply to it, how can it come up with an arbitrary monadic value? Recall, since it's also polymorphic over *any* Monad m, it can't craft concrete effect values other than through pure.
00:27:41 <dminuoso> (Or `return` rather)
00:28:04 <dminuoso> But for pure, it'd need some value of `a -> b` for all choices of a and b, again not possible
00:28:23 <dminuoso> The most defined implementation possible would be `general _ = pure undefined`
00:32:48 <merijn> dminuoso: pffft
00:32:56 <merijn> dminuoso: "pure unsafeCoerce" :p
00:36:05 <dminuoso> Well.
00:36:17 <dminuoso> At that point, why not straight unsafeCoerce?
00:43:52 <Ariakenom> koz_, why that one. and not ex https://github.com/nh2/static-haskell-nix 
00:44:30 <koz_> Ariakenom: Because I have zero idea how that thing works or how to use it. I wanna get things from first principles ideally, and that's just too magical and has too much going on as far as I can tell.
00:44:33 <dminuoso> Ariakenom: the overlay is quite broken and unstable for starters
00:44:58 <koz_> However, your advice helped - I'm closer than I was!
00:45:02 <dminuoso> Every few commits on nixpkgs master the overlay breaks
00:45:22 <dminuoso> I'd rather use plain nix + dockerTools if I wanted a portable deployment
00:45:23 <Ariakenom> ouch
00:45:28 <dminuoso> From experience that works much more reliable
00:46:06 <Ariakenom> koz_, in the default.nix in that repo, the option with those library flags is configureFlags
00:46:34 <dminuoso> koz_: I can give you a quick guide how to use that overlay
00:46:51 <dminuoso> (You really want that, as there's many subtleties when building static things in nix)
00:47:08 <koz_> dminuoso: You mean static-haskell-nix?
00:47:13 <dminuoso> yes
00:47:31 <koz_> dminuoso: That would be good.
00:48:47 <dminuoso> koz_: https://gist.github.com/dminuoso/15222b2cb2a8b791525f902fe5beee4e
00:49:08 <dminuoso> (This is in the middle of my emacs buffer, so there might be some very basic but obvious issues)
00:49:39 <dminuoso> The json file contains just `{"url": "git://github.com/nh2/static-haskell-nix","ref": "master","rev": "dbce18f4808d27f6a51ce31585078b49c86bd2b5"}`
00:49:48 <dminuoso> So you can equivalently use fetchTarball or fetchGitHub
00:49:59 <dminuoso> There's really not much to it.
00:50:57 <koz_> OK. I'm very new to Nix, so I'm not too sure what's going on here. Specifically, what of this is general across any use of this overlay, as opposed to your specific thing you're working on?
00:51:07 <koz_> Like, what's a hello-world default.nix for it?
00:51:51 <dminuoso> koz_: It sets up GHC and libraries up appropriately to support static linking
00:52:04 <dminuoso> At its core, it boils down to two ideas being married here:
00:52:24 <dminuoso> First:
00:52:48 <dminuoso> To build a haskell package, I use callCabal2nix to dynamically generate a derivation that is always up-to-date. This is better than calling cabal2nix manually
00:53:15 <koz_> OK, that makes sense.
00:53:17 <dminuoso> Then, the derivation gets mixed into haskellPackages using an overlay
00:53:42 <dminuoso> At first that might seem silly, but it ties better into several tools, and it makes it easier if you have other packages that depend on it
00:54:02 <dminuoso> So you pretend that your derivation sits inside the regular nixpkgs haskellPackages attribute set
00:54:45 <dminuoso> Im doing that overlay a bit more elaborate, since I want this to work with any compiler. If you're fine with just the canonical GHC compiler, the overlay is much simpler there.
00:55:06 <dminuoso> https://gist.github.com/dminuoso/15222b2cb2a8b791525f902fe5beee4e#file-default-nix-L11
00:55:26 <dminuoso> This is where I build up the nixpkgs with my own overlay that mixes freyja in
00:55:42 <dminuoso> Specifically, I overlay staticPkgs
00:55:48 <koz_> OK, so let me see if I understand this correctly.
00:56:06 <koz_> Lines 1-9 I need to get the overlay no matter what I'm building.
00:56:46 <koz_> Lines 12-26 is a list of a) things I wanna build and b) dependencies.
00:57:01 <dminuoso> not dependencies
00:57:04 <dminuoso> I just do overrides there
00:57:15 <dminuoso> Because some dependencies are sometimes not buildable out the box for some reasons
00:57:19 <koz_> Oh, I see.
00:57:28 <koz_> You have dontChecks and things.
00:57:30 <dminuoso> right
00:57:38 <dminuoso> *and* that's where I mix in my own derivation
00:57:43 <koz_> And callCabal2Nix.
00:57:59 <dminuoso> Indeed, that's what generates my derivatoin
00:58:12 <dminuoso> You can still override the cabal or the derivation using standard nix tools if need be
00:58:23 <koz_> Now 11, and 28-34, I don't get.
00:58:24 <dminuoso> (It really beats callCabal2nix and manually fiddling around)
00:58:33 <dminuoso>   extendedPkgs = staticPkgs.extend pkgOverlay;  
00:58:34 <dminuoso> This?
00:58:42 <koz_> That.
00:59:17 <dminuoso> koz_: So look at this first https://gist.github.com/dminuoso/15222b2cb2a8b791525f902fe5beee4e#file-default-nix-L27-L33
00:59:23 <dminuoso> The main thing to understand, Im doing something more elaborate
00:59:28 <dminuoso> Than strictly needs be
00:59:51 <koz_> Ah, right that.
00:59:54 <dminuoso> Normally you could just say `haskellPackages.overrides = ...`
00:59:55 <koz_> You just explained.
00:59:59 <koz_> So technically optional?
01:00:19 <dminuoso> Well that's just the version of haskellPackages.overrides that works for a particular GHC version
01:00:33 <dminuoso> You can just straight up copy it, it just does a nested attribute set merge
01:00:43 <dminuoso>        ${compiler} = super.haskell.packages.${compiler}.override (makeHsOverrides super.haskell.lib);
01:00:44 <koz_> Ah, because you want it to work on any compiler, right?
01:00:52 <dminuoso> Right, or rather a particular compiler
01:00:59 <dminuoso> As opposed to whatever haskellPackages uses
01:01:32 <dminuoso>   extendedPkgs = staticPkgs.extend pkgOverlay;  
01:01:49 <dminuoso> Then is the entrypoint that uses the overlay to build up a new nixpkgs attrset with my overlay applied
01:02:01 <dminuoso> so inside extendedPkgs you can find: 
01:02:15 <dminuoso> extendedPkgs.haskell.packages.${compiler}.freyja
01:02:18 <dminuoso> extendedPkgs.haskell.packages.${compiler}.freyja-api
01:02:27 <dminuoso> https://gist.github.com/dminuoso/15222b2cb2a8b791525f902fe5beee4e#file-default-nix-L35-L39
01:02:32 <dminuoso> This is where I reference that then
01:02:42 <dminuoso> Then from the outside, you can just say `nix-build -A exe` 
01:03:12 <koz_> OK, that _mostly_ makes sense.
01:03:21 <koz_> I'll give it a try tomorrow and see if I can get it building.
01:03:29 <koz_> (well, modulo what I need, obviously)
01:03:57 <dminuoso> koz_: If you get rid of all these dontCheck  and overrideCabal things inside makeHsOverrides, then it should be much much more readable and clear :)
01:05:08 <koz_> OK, that makes worlds more sense. I'll give it a go, thanks.
01:06:55 <dminuoso> Just know that the static-haskell-nix overlay is relatively unstable. So if you rely on fast moving targets in nixpkgs, building inside alpine might be much preferrable.
01:08:54 <koz_> dminuoso: Using like, Docker or something?
01:08:59 <dminuoso> Yeah
01:09:27 <koz_> Noted, thanks!
01:09:44 <dminuoso> koz_: Btw, I think there's some bug in there. I was in the middle of refactoring it and stopped because I had some issues with a dependencies.
01:23:19 * hackage alfred-margaret 1.1.1.0 - Fast Aho-Corasick string searching  https://hackage.haskell.org/package/alfred-margaret-1.1.1.0 (rkrzr)
01:36:49 * hackage ptr-poker 0.1.1.1 - Pointer poking action construction and composition toolkit  https://hackage.haskell.org/package/ptr-poker-0.1.1.1 (NikitaVolkov)
01:52:00 <delYsid> -Wname-shadowing drives me crazy.  I guess I have been spoiled by Rust.  I find myself often rebinding the same name, and finding new names is a waste of time.  Adding the umteenth tick doesnt help with readability.  Am I alone, or is -Wname-shadowing a pretty pedantic default?
01:56:19 * hackage focus 1.0.1.4 - A general abstraction for manipulating elements of container data structures  https://hackage.haskell.org/package/focus-1.0.1.4 (NikitaVolkov)
01:56:35 <lortabac> delYsid: I tend to use long names for toplevel definitions and abbreviations for the local ones, so I rarely get that warning
01:56:53 <dminuoso> delYsid: It's a very pedantic default indeed.
01:58:07 <dminuoso> delYsid: One of the main annoyances is that you can't selectively turn it off for a binding via some pragma.
01:59:13 <dminuoso> Strangely, there's 2 parts where this would be useful. One is orphan instances, the other is shadowing names, but the GHC maintainers shot down attempts to cook something up for some "overarching universal tool to disable diagnostics selectively" idea, that nobody has followed for many years.
02:01:34 <kuribas> +1 for a pragma to disable it.
02:02:09 <kuribas> it's occasionally useful
02:02:27 <Uniaika> sometimes I use expressions to avoid having to produce new variables to store intermediate values
02:02:35 <dminuoso> This diagnostic really is a double-edged sword. It tends to discover infinite recursion errors rather well, at the cost of having to rename your binders all the time.
02:02:35 <Uniaika> that doesn't apply everywhere of course
02:02:48 <Uniaika> but you can replace some do-notation with an applicative 
02:03:02 <dminuoso> (though the cases of infinite recursion Im talking about are rather rare)
02:03:09 <dminuoso> Perhaps just disabling the diagnostic is better
02:06:18 * hackage stm-containers 1.2 - Containers for STM  https://hackage.haskell.org/package/stm-containers-1.2 (NikitaVolkov)
02:09:13 <merijn> I think it's a sane enough default, if it really bothers you you can just turn it off >.>
02:09:19 * hackage stm-containers 1.1.0.5 - Containers for STM  https://hackage.haskell.org/package/stm-containers-1.1.0.5 (NikitaVolkov)
02:09:30 <merijn> I find -Wunused-do-bind much less useful, tbh
02:12:22 <kuribas> infinite recursion errors are really hard to debug
02:14:08 <dminuoso> Are they, really?
02:14:23 <kuribas> yes
02:14:42 <dminuoso> `+RTS xs -RTS` + sigint works rather well for me
02:15:34 <kuribas> what's xs?
02:15:39 <dminuoso> Err sorry xc
02:15:50 <dminuoso> The muscle memory defeated me. :)
02:16:56 <kuribas> good to know
02:17:48 <dminuoso> You can also use GHCi with `:set -fbreak-on-error`
02:18:00 <dminuoso> And then run the offending expression with `:trace expr`
02:18:14 <dminuoso> Send sigint via Ctrl+C, then you have :history and :back
02:21:31 <maerwald> how do you figure out what error codes a servant handler might return?
02:22:16 <Taneb> maerwald: there's not currently a way but there's active work ongoing to change this
02:28:34 <maerwald> Taneb: since 2017 https://github.com/haskell-servant/servant/issues/841
02:28:42 <maerwald> :D
02:29:02 <maerwald> I'm late to the party
02:34:49 * hackage chessIO 0.4.0.0 - Basic chess library  https://hackage.haskell.org/package/chessIO-0.4.0.0 (mlang)
02:45:21 <dminuoso>     A do-notation statement discarded a result of type ‘Void’
02:45:27 <dminuoso> merijn: You know what, you're right.
02:50:45 <merijn> There's two warnings for do, one for "you used something with a non-() return in a do block" and one for "you returned an unused 'IO a' in a do block"
02:50:58 <merijn> The latter is somehwat useful, but the first one is just bollocks
02:51:16 <merijn> You end up wrapping everything in your parser with void ot "_ <-"
02:51:30 <dminuoso> unused `IO a`?
02:51:43 <dminuoso> What warning are you referring to?
02:52:10 <merijn> dminuoso: If you have "IO (IO ())"
02:52:18 <dminuoso> There's a warning for that?
02:52:34 <dminuoso> % pure getLine
02:52:35 <yahb> dminuoso: 
02:53:10 <merijn> -Wwrong-do-bind
02:53:21 <merijn> dminuoso: Only in do notation
02:53:56 <dminuoso> Ah.
02:54:01 <dminuoso> % :set -Wall
02:54:01 <yahb> dminuoso: 
02:54:09 <dminuoso> % do { pure getLine; pure 1 }
02:54:10 <yahb> dminuoso: ; <interactive>:67:6: warning: [-Wunused-do-bind]; A do-notation statement discarded a result of type `IO String'; Suppress this warning by saying `_ <- pure getLine'; <interactive>:67:25: warning: [-Wtype-defaults]; * Defaulting the following constraints to type `Integer'; (Num a0) arising from the literal `1' at <interactive>:67:25; (Show a0) arising from a use of `print' a
02:54:34 <merijn> % :set -Wall -Wno-unused-do-bind
02:54:35 <yahb> merijn: 
02:54:40 <merijn> % do { pure getLine; pure 1 } 
02:54:40 <yahb> merijn: ; <interactive>:69:25: warning: [-Wtype-defaults]; * Defaulting the following constraints to type `Integer'; (Num a0) arising from the literal `1' at <interactive>:69:25; (Show a0) arising from a use of `print' at <interactive>:69:1-27; * In the first argument of `pure', namely `1'; In a stmt of a 'do' block: pure 1; In the first argument of `GHC.GHCi.ghciStepIO :: for
02:54:45 <merijn> ugh
02:54:52 <merijn> % do { pure getLine; pure 'c' } 
02:54:53 <dminuoso> % do { pure getLine; pure "foo" }
02:54:53 <yahb> merijn: 'c'
02:54:53 <yahb> dminuoso: "foo"
02:54:58 <merijn> hmm
02:55:02 <dminuoso> Maybe its not included in Wall?
02:55:04 <merijn> Maybe someone broke the warning :p
02:55:08 <merijn> It used to work
02:55:11 <dminuoso> % :set -Wall -Wno-unused-do-bind -Wwrong-do-bind
02:55:11 <yahb> dminuoso: 
02:55:12 <dminuoso> % do { pure getLine; pure "foo" }
02:55:13 <yahb> dminuoso: "foo"
02:55:20 <dminuoso> Never seen it fire..
02:55:26 <merijn> % do { return getLine; pure 'c' } 
02:55:26 <yahb> merijn: 'c'
02:55:32 <merijn> I have :p
02:55:39 <merijn> But that was long ago in 7.x
02:55:53 <dminuoso> fair enough, either way, this diagnostic doesnt seem useful ot me
02:56:08 <dminuoso> but, if I had it for free why not
02:56:24 <merijn> It's helpful to not lose "free" actions after something like allocate
02:56:36 <dminuoso> but -Wno-unused-do-bind should become my default
02:56:58 <merijn> It already is for me :p
02:57:09 <merijn> dminuoso: Don't forget to enable -Wcompat, I always forget >.>
02:57:30 <dminuoso> I avoid the need by never updating GHC.
02:57:34 <dminuoso> :p
02:57:40 <merijn> ;)
02:57:59 <dminuoso> jokes aside, we're still using 8.6.5 for one project.
02:58:19 <merijn> I just moved my phd codebase from 8.6.5 to 8.10.2 :)
02:58:35 <dminuoso> Willing to bet facebook is still running on 7.*
02:59:18 <dminuoso> 2 years ago they still were, and Simon kept humming and hawing when asked when they wanted to switch to 8.0..
02:59:18 <merijn> Probably not, ApplicativeDo is 8.x, no? :p
02:59:32 <dminuoso> Mmm
02:59:43 <dminuoso> Then they must be stuck on 8.0 or 8.2 then
03:17:04 <kuribas> dminuoso: what's wrong with 6.8.5?
03:17:13 <kuribas> erm 8.6.5
03:25:51 <maerwald> yeah, you can't switch GHC just like that, especially if you rely on certain performance characteristics of your code
03:26:11 <maerwald> new version might be slower or faster or behave different for whatever reason
03:30:15 <dminuoso> kuribas: I like staying up to date on GHC for bug fixes and new features.
03:30:42 <kuribas> dminuoso: are no bug fixes done for 8.6.5?
03:30:44 <dminuoso> I dont want my compiler/base be the reason why I cant get package `xyz` at a desired version.
03:31:13 <dminuoso> kuribas: The GHC team doesn't have the capacity to backport all fixes promptly.
03:31:38 <kuribas> I prefer a stable compiler over a cutting edge one with the latest features.
03:38:04 <maerwald> kuribas: 8.6.5 has still massive problems on windows with long paths
03:38:09 <maerwald> but 8.10.2 is also broken
03:38:28 <maerwald> and the windows fixes won't get backported to 8.6.5 afais
03:43:09 <__monty__> How many versions back does active GHC support go?
04:02:22 <dminuoso> __monty__: Judging from a recent thread on the mailing list, I'd say backporting happens as far as 8.2.3
04:02:41 <dminuoso> Cant find any authoritative list of supported versions though
04:05:45 <dminuoso> servant-client question. If I want to log the request made for debugging purposes, is there some premade tools for that? Or should I set my own managerModifyRequest in the ManagerSettings of http-client?
04:07:04 <merijn> __monty__: Depends how much anyone cares to do the work
04:07:33 <merijn> __monty__: I don't think there's an official maintenance window for anything but the last release
04:08:03 <dminuoso> That alone should make you wary of using 8.6.5 in the long term.
04:08:14 <dminuoso> There's two different notions of "stable" here.
04:08:29 <merijn> The maintenance window is "you get what you pay for"
04:08:48 <dminuoso> There's "stable" meaning it's well tested and supposedly bug free, and there's "stable" meaning it's the supported versions that receives attention and prompt bug fixes.
04:08:49 <merijn> So, unless you pay someone to contribute to GHC and backport stuff for you... :p
04:08:54 <dminuoso> kuribas: ^-
04:09:31 <merijn> Which is fine
04:09:49 * hackage splitmix 0.1.0.2 - Fast Splittable PRNG  https://hackage.haskell.org/package/splitmix-0.1.0.2 (phadej)
04:09:59 <merijn> If your company relies on Haskell, maybe you *should* contribute to the ecosystem, rather than freeloading on volunteer labour
04:10:22 <kuribas> merijn: maybe you *should* just use java like everyone else.
04:11:59 <merijn> If a company's opinion is "do all our support for free or we switch to Java", then I say, let them fuck off and switch to Java 
04:12:56 <kuribas> I didn't say for free.
04:13:06 <kuribas> Companies are happy to pay good money for good tooling.
04:13:12 <merijn> kuribas: lol
04:13:24 <kuribas> But requiring them to develop or contribute to tooling is a big turn-off.
04:13:25 <dminuoso> Companies are generally not happy to pay good money.
04:13:33 <dminuoso> otoh nobody has ever been fired for buying cisco/ibm.
04:13:35 <merijn> So that's why all our infrastructure runs on free software maintained by unpaid people?
04:14:25 <dminuoso> merijn: Heh, its crazy isnt it. So many companies products rely on just glueing free software together.
04:14:42 <merijn> kuribas: Companies are happy to pay good money for *non-open source* tools
04:14:49 <merijn> Because they have no choice
04:15:09 <kuribas> not all of it :)
04:15:15 <kuribas> we use expensive vmware
04:15:25 <merijn> Given the number of companies building stuff in Haskell, I don't see anyone paying phadej or contributing stuff to cabal-install
04:15:34 <merijn> But I do so people whining about them
04:16:01 <phadej> merijn: IOHK pays
04:16:09 <phadej> merijn: in fact for all the work in 2020
04:16:26 <merijn> phadej: That's good, but still only one out of probably hundreds :)
04:16:43 <kuribas> we pay for intellij licenses, so I don't see why we wouldn't pay for haskell tooling.
04:16:58 <dminuoso> phadej: Do they pay you directly? Or does the money go to some foundation?
04:16:59 <merijn> kuribas: Because you can't get intellij without paying for the license
04:17:14 <phadej> kuribas: cabal is more like `mvn`, it's not "tooling" per se
04:17:21 <kuribas> we can get eclipse for free... but intellij is just better
04:17:21 <phadej> or very low-level
04:17:28 <merijn> In general IOHK seems to contribute more than many others
04:17:43 <merijn> kuribas: Note how eclipse is open source and intellij isn't?
04:17:53 <phadej> dminuoso: IOHK pays Well-Typed for someone to work on Cabal
04:17:56 <merijn> You're just making my point for me ;)
04:18:19 <phadej> dminuoso: similarish setup how companies X and Y pay Well_Typed for someone to work on GHC
04:18:31 <kuribas> isn't FP complete doing some work on haskell infra?
04:18:36 <merijn> If we made cabal-install closed source I'm sure we could have a well-funded company in no time and thus much more dedicated work
04:18:43 <phadej> kuribas: not as far as I'm aware
04:18:52 <merijn> Isn't FP complete mostly doing work on fracturing the infrastructure community? :p
04:18:55 <phadej> or well, you can say Stacakge is haskell infra
04:19:08 <phadej> but it's more or less owned by FP complete, so you can say "on their infra" as well (IMO)
04:20:10 <kuribas> merijn: why not a closed source IDE, where the developpers also contribute to tooling and compilers?
04:20:48 <sclv> not enough users
04:21:06 <merijn> Also, then all the beginners, hobbiests, etc. are left out
04:21:06 <sclv> no paid ide would be profitable or even close
04:21:20 <kuribas> and not enough users because not good tooling
04:22:56 <kuribas> so how does clojure do it?
04:23:57 <dminuoso> Running on jvm and java interop is probably a big part of it.
04:24:18 <dminuoso> That means interfacing with existing code is reasonably easy, and you get access to a relatively large eco system that way
04:25:39 <dminuoso> I'd argue that similarly C++ wouldn't have had nearly as much success as it did, if it wasn't largely C-compatible by syntax, and didn't have seamless linkage into C.
04:25:54 <merijn> kuribas: "we provide escape from Java"
04:26:08 <merijn> kuribas: Also, by Rich Hickey labouring unpaid for ages to bootstrap things
04:26:23 <dminuoso> merijn: And that's probably survival bias right there!
04:26:29 <merijn> Yeah
04:27:21 <merijn> It's just baffling how software engineers as a community can see billion/trillion dollar companies exploiting unpaid labour in open source while stressing out maintainers and go "yeah...this is fine!"
04:27:55 <kuribas> merijn: for what it's worth, we are not a billion dollar company, and we are barely profitable.
04:28:15 <kuribas> merijn: actually our current project isn't even profitable yet
04:28:19 <merijn> And instead of going "hey, wait, maybe these people can damn well pay for all this support they want" and instead go "we should bend over backwards to be used"
04:28:37 <merijn> kuribas: That sounds like a "your company" problem and not a "open source maintainer" problem
04:30:30 <kuribas> btw clojure tooling isn't that nice IMO
04:30:47 <kuribas> I think haskell is still better, if only because of the type system.
04:31:23 <kuribas> clojure: no dead code detection, no way to see if you are calling functions that don't exist.
04:31:24 <merijn> Frankly, I don't care if companies are billion dollar companies or 2 cents away from bankruptcy. I support what's convenient for me and if you need more I can send you my bank account and an invoice
04:31:36 <opqdonut> well said
04:32:05 <kuribas> merijn: personally I think with the bad tooling etc haskell is still better and more productive than what we have currently.
04:32:11 <kuribas> merijn: but it's hard to convince others
04:32:13 <merijn> And if that causes everyone who wants more from open source to leave, I say "good riddance"
04:33:12 <kuribas> it's always the same myth "haskell is not practical because it's made by/for academists"
04:33:42 <merijn> I'm not convinced "better tooling" will have measurable impact on "people who have dumb opinions"
04:35:36 <kuribas> though there is some truth to it.
04:39:32 <dminuoso> So... for over a year Ive been using LoggingT and ReaderT. Why exactly have runLoggingT and runReaderT the argument order they have?
04:39:44 <dminuoso> Every time I feel like they should be flipped
04:40:14 <merijn> dminuoso: Because they use record syntax?
04:40:23 <dminuoso> merijn: That's such a poor reason. :(
04:40:27 <merijn> Yes
04:40:51 <kuribas> dminuoso: that annoys me too
04:41:05 <kuribas> runState as well
04:41:10 <kuribas> :t runStateT
04:41:11 <lambdabot> StateT s m a -> s -> m (a, s)
04:42:02 <lortabac> has anybody every used run* without flip?
04:42:16 <dminuoso> lortabac: Yes
04:42:22 <dminuoso> I use & (.) and sections
04:42:46 <merijn> I use where bindings :p
04:42:50 <merijn> I dislike flip
04:42:53 <dminuoso> foo & (`runFoo` f) . (`runBar` b)
04:43:04 <dminuoso> (you can align the dots with the (&) nicely
04:43:10 <lortabac> I use where too, it was just a joke
04:51:15 <unfixpoint> It's been a while since I've been using lenses for the last time, here's a thing which I'm stuck on:
04:51:50 <dminuoso> lortabac: I was serious though https://gist.github.com/dminuoso/e28a461bcb324a5d29c125165c0da0e0
04:52:04 <unfixpoint> If I have a `State (Array Int Bool) *` I can change state with `ix 0 .= True` but I cannot read somehow?
04:52:37 <unfixpoint> `use (ix 0)` always tells me: No instance for (Monoid Bool) arising from a use of `ix'
04:52:51 <dminuoso> unfixpoint: You are probably view'ing through a Fold.
04:53:01 <dminuoso> (Or a traversable)
04:53:12 <dminuoso> Consider:
04:53:20 <unfixpoint> Are you saying it's an issue with GHC.Arr.Array?
04:53:34 <dminuoso> oh mm
04:53:47 <unfixpoint> I could move to `IntMap` but not sure whether that'd help
04:53:47 <dminuoso> unfixpoint: ix gives you a traversal back
04:53:50 <dminuoso> That's the problem
04:54:05 <dminuoso> Consider a more simplified example:
04:54:17 <dminuoso> [Product 1, Product 2, Product 3] ^. each
04:54:20 <dminuoso> What should that give you?
04:54:24 <dminuoso> What would you expect?
04:54:30 <unfixpoint> [1..3]?
04:54:40 <dminuoso> % [Product 1, Product 2, Product 3] ^. each
04:54:41 <yahb> dminuoso: ; <interactive>:76:1: warning: [-Wtype-defaults]; * Defaulting the following constraints to type `Integer'; (Show a0) arising from a use of `print' at <interactive>:76:1-41; (Num a0) arising from a use of `it' at <interactive>:76:1-41; * In a stmt of an interactive GHCi command: print it; Product {getProduct = 6}
04:54:46 <dminuoso> % [Product 1 :: Product Int, Product 2, Product 3] ^. each
04:54:46 <yahb> dminuoso: Product {getProduct = 6}
04:54:52 <dminuoso> unfixpoint: ^- voila. Maximum surprise.
04:55:13 <dminuoso> When you view through a fold/traversable, it uses the monoid instance on what you're looking at to combine all targets.
04:55:16 <unfixpoint> Oh so it wants to mconcat it?
04:55:23 <dminuoso> and it defaults to mempty if there's nothing to look at
04:55:24 <dminuoso> so
04:55:33 <dminuoso> % [] ^. each :: Product Int
04:55:33 <yahb> dminuoso: Product {getProduct = 1}
04:55:36 <merijn> unfixpoint: Incidentally Data.Monoid has two newtypes for Bool to get a monoid
04:55:49 <merijn> unfixpoint: "Any" and "All"
04:55:50 <unfixpoint> It's not `Bool` there ;)
04:56:06 <merijn> > Any True <> Any False
04:56:08 <lambdabot>  Any {getAny = True}
04:56:08 <dminuoso> unfixpoint: Right. Recall, a traversal/foldable has 0-to-many targets.
04:56:16 <dminuoso> unfixpoint: so now:
04:56:17 <merijn> > All True <> All False
04:56:19 <lambdabot>  All {getAll = False}
04:56:19 * hackage jsonifier 0.1.0.3 - Fast and simple JSON encoding toolkit  https://hackage.haskell.org/package/jsonifier-0.1.0.3 (NikitaVolkov)
04:56:20 <dminuoso> ix :: Index m -> Traversal' m (IxValue m) 
04:56:34 <unfixpoint> The probably actually occurs with a `data`-type and I'm using `ix 0 . entryBla .= xxx` and `view (ix 0 . entryBla)` etc.
04:56:58 <dminuoso> unfixpoint: ^- now because this produces a Traversal, which could have many targets or none, the view implementation demands a monoid
04:57:12 <unfixpoint> Is there a way, or should I just implement a Monoid instance?
04:57:23 <dminuoso> unfixpoint: you could just use toListOf instead
04:57:28 <merijn> unfixpoint: There already is one as I pointed out :p
04:57:35 <merijn> Well, two, actually
04:58:26 <dminuoso> unfixpoint: So what you could do:
04:58:30 <unfixpoint> For Bool yeah, but not for the actual type. I just used Bool as example
04:59:14 <dminuoso> % [True, False, True] ^. ix 1
04:59:14 <yahb> dminuoso: ; <interactive>:84:24: error:; * No instance for (Monoid Bool) arising from a use of `ix'; * In the second argument of `(^.)', namely `ix 1'; In the expression: [True, False, True] ^. ix 1; In an equation for `it': it = [True, False, True] ^. ix 1
04:59:16 <dminuoso> % [True, False, True] ^. ix 1 . to Any
04:59:17 <yahb> dminuoso: Any {getAny = False}
04:59:20 <dminuoso> unfixpoint: ^- there
04:59:24 <dminuoso> You can also use `ala` if you like
04:59:59 <dminuoso> unfixpoint: ah. if you want this to work with anything, use toListOf instead.
05:00:05 <dminuoso> And accept the fact that you cant view through a traversa
05:00:15 <dminuoso> (The fact this works at all is surprising and disliked by some)
05:00:20 <merijn> Or use First
05:00:26 <merijn> and/or Last
05:00:56 <merijn> > First (Just 1) <> First (Just 2) <> First (Just 3)
05:01:00 <lambdabot>  First {getFirst = Just 1}
05:03:50 <unfixpoint> Yeah, First makes most sense. I don't want to convert it to list as I only care about a certain index
05:05:02 <unfixpoint> Maybe I should just use `(!0) <$> get` and not use lens for the array access.
05:09:18 <unfixpoint> `use (ix i . entryBla)` would be so much nicer than `_entryBla . (!i) <$> get` heh
05:59:06 <dminuoso> @tell unfixpoint the lens-y way of (!0) is to use unsafeSingular which says "This looks like a traversal, but I do promise it targets one and only one element. Burden of proof is on me. Make it a lens!"
05:59:06 <lambdabot> Consider it noted.
06:01:19 * hackage clckwrks-plugin-redirect 0.0.1 - support redirects for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-redirect-0.0.1 (JeremyShaw)
06:02:50 <dminuoso> @tell unfixpoint So you could also just say `use (unsafeSingular (ix 0))` - but then you have to ensure that `ix 0` definitely points at an element, or a bottom with 6 legs will crawl up on you.
06:02:51 <lambdabot> Consider it noted.
06:20:37 <dminuoso> for_ [sigTERM, sigINT, sigKILL] $ \sig -> liftIO (installHandler sig (Catch (io suicide)) Nothing)
06:21:02 <geekosaur> you can't catch sigKILL
06:21:02 <dminuoso> This line of code causes tje line "agnar: sigaction" to be written to stderr once.
06:21:18 <dminuoso> geekosaur: Oh! That was prompt. :>
06:21:42 <geekosaur> I don't know if it's checking that, but it immediately came to mind
06:22:17 <geekosaur> ("agnar"? "range" backwards?)
06:22:28 <dminuoso> Haha no my process is called agnar
06:24:50 <tomjaguarpaw> If I am running  cabal v2-repl and I  :load  a file from outside my project then I can no longer import modules from my project.  If I  :load  a file from my project then I can import modules from my project again. Does anyone know why this happens?
06:25:20 <merijn> hmmm, what's the best way to get some absolute paths into my code? I'm leaning towards "build-type: Configure" and having the paths as CPP defines, but that's a bit messy. Any better solutions?
06:26:39 <geekosaur> tomjaguarpaw, :load sets the base from which imports and such work. so you'd be able to import modules related to the :load-ed file afterward
06:27:10 <geekosaur> that's how ghci works, not something cabal repl can change
06:27:29 <geekosaur> some ways it's best to think of :load as loading a project, not a file
06:27:45 <tomjaguarpaw> But if I  :load  a file I can still import modules that are build-depends
06:28:20 <dminuoso> geekosaur: Cheers, that helped. The output on stderr comes from the RTS, but it seems the implementation of installHandler silently ignores the error code returned by the RTS.
06:28:29 <tomjaguarpaw> I assumed that v2-repl would build my project and expose it in exactly the same way as other build-depends packages, but I guess not.
06:28:40 <geekosaur> right, because they're passed as -package parameters so still there. :load changes what modules are considered part of the current project
06:28:48 <merijn> dminuoso: FYI, I would consider the current signal handling code of the RTS *highly* questionable
06:28:54 <geekosaur> they're fundamentally different things to ghc / ghci
06:28:55 <tomjaguarpaw> Can I :load two different modules at once?
06:29:01 <geekosaur> nope
06:29:15 <dminuoso> merijn: Well Im just staring at the `unix` package, and the installHandler itself is doing funky things.
06:30:05 <tomjaguarpaw> So if I have a project and I want to  :load  a file to play around with that project's functionality then I am out of luck? I'm sure I've done that before, I just can't remember how ...
06:30:15 <dminuoso> It ignores the return code of stg_sig_install if the previous handler was the default handler or ignored..
06:30:18 <dminuoso> That seems awfully wrong.
06:30:38 <dminuoso> Oh heh, it always ignores error conditions.
06:30:58 <geekosaur> tomjaguarpaw, more or less unless you can make it part of your project or make it a build-depends lib
06:31:00 <dminuoso> geekosaur: Anyway, thanks. Gave me the answer before I even described the problem. :)
06:31:20 <merijn> dminuoso: The entire RTS approach to signals is super questionable and it's somewhere on my list of yaks to look into
06:31:53 <tomjaguarpaw> geekosaur: OK thanks. That's very surpsing. 
06:32:05 <geekosaur> ghci's a bit of a hack
06:32:22 <geekosaur> and wht cabal and stack try to make it do is a hack on top of a hack
06:33:05 <dminuoso> merijn: Well Im staring at undocumented and half dead code pathshere.
06:33:20 <merijn> dminuoso: So, maybe I'll get around to looking at it by 2050 :p
06:33:50 * hackage bugsnag-haskell 0.0.4.0 - Bugsnag error reporter for Haskell  https://hackage.haskell.org/package/bugsnag-haskell-0.0.4.0 (PatrickBrisbin)
06:33:55 <dminuoso> This particular bug seems to be easy to fix though.
06:48:19 * hackage hadolint 1.18.2 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.18.2 (lorenzo)
06:52:50 * hackage ghc-events-analyze 0.2.8 - Analyze and visualize event logs  https://hackage.haskell.org/package/ghc-events-analyze-0.2.8 (EdskoDeVries)
07:11:19 * hackage miv 0.4.3 - Vim plugin manager written in Haskell  https://hackage.haskell.org/package/miv-0.4.3 (itchyny)
07:18:46 <hyperisco> how can I get the last modification time of a file for both posix and windows systems?
07:19:20 * hackage yesod-core 1.6.18.5 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.18.5 (MaxGabriel)
07:19:24 <hyperisco> oh derp it is in the directory package
08:01:49 * hackage pvar 1.0.0.0 - Mutable variable with primitive values  https://hackage.haskell.org/package/pvar-1.0.0.0 (lehins)
08:08:57 <lightwave> newbie question: is there a generally accepted 'good' style guide for Haskell that most Haskellers agree to be good?
08:09:05 <maerwald> no
08:09:07 <merijn> No
08:09:12 <lightwave> LOL
08:09:23 <maerwald> good question, next question
08:09:36 <merijn> lightwave: There's tons of guide, but nothing universally agreed upon
08:10:28 <merijn> lightwave: I think the closest to consensus you'll get is: "Curly braces and semicolons bad, layout good" and "spaces, not tabs" and even those aren't universal (but close enough)
08:10:57 <merijn> lightwave: Oh, and generally people tend to prefer "where" blocks over "let in"
08:11:11 <{abby}> if you ask 3 haskellers how they format their code you'll get at least 4 different answers
08:11:16 <merijn> :)
08:11:38 <merijn> lightwave: I'd just do "whatever seems most readable" and "try and match surrounding style" (in projects)
08:11:54 <merijn> lightwave: And people will be more than happy to critique your style ;)
08:12:04 <lightwave> LAMO
08:12:10 <lightwave> LMAO
08:12:17 <maerwald> yes, if you wanna waste a lot of your time, ask ppl for advice on formatting
08:12:27 <lightwave> Something never changes in programming languages.
08:12:40 <merijn> maerwald: Well, for beginners it makes sense, they often don't know many Haskell-y idioms
08:13:08 <{abby}> there are, of course, automated formatters---but I suspect the "every project has its own style" culture does not lead itself well to adopting "one true style" tools… I find ormolu's style painfully ugly, for example :p
08:13:12 <merijn> I see many beginners asking for feedback where there code can be cleaned up considerably, just don't expect any universal consensus :)
08:13:14 <maerwald> my advice is: never align, only indent. But that's already quite controversial
08:13:20 <noctux> what, spaces? damn it...
08:13:40 <{abby}> maerwald: oo, them's fighting words
08:13:50 <merijn> noctux: tabs are well defined in GHC, unfortunately they follow unix and not "what people like to pretend they mean"
08:14:00 <lightwave> My keyboard only has 0, 1, space, backspace and enter keys. No tab.
08:14:23 <lightwave> Forgive me for asking the style guide question. LOL
08:14:42 <noctux> merijn: meaning? \t being an ordinary whitespace ascii character?
08:15:01 <lightwave> I'll not ask what editor is the best for Haskell. ;-)
08:15:28 <merijn> noctux: \t rounds to nearest multiple of 8
08:15:51 <merijn> noctux: That means that the width of a tab is dependent on preceding characters
08:15:53 <{abby}> lightwave: whichever you're used to using, honestly. except for nano, unless someone's written a nano LSP client...
08:16:01 <merijn> If you have 3 spaces followed by a tab, the tab is 5 wide
08:16:13 <merijn> Which is the standard unix convention
08:16:22 <merijn> but not how people treat tabs in source code :)
08:16:42 <noctux> yeah, and as long as you set tw=8, all is fine :P
08:16:58 <merijn> noctux: No
08:16:59 <hyperisco> if I just want to wait for a process to terminate, do I have to read its stdout char by char until I hit EOF?
08:17:12 <{abby}> noctux: set tw=0 et, you mean? :P
08:17:20 <merijn> noctux: because tw says "tabs are 8", which is *different* from "tabs round to nearest multiple of 8"
08:17:21 <{abby}> s/0/8/ even
08:17:41 <lightwave> s/\t/doh!/g
08:17:53 <merijn> hyperisco: Possibly, if the process blocks on blocked writes
08:18:19 <merijn> lightwave: It's basically 1/3rd vim, 1/3rd emacs, 1/3rd rest in here
08:18:39 <maerwald> I had the impression slightly more emacs than vim
08:18:53 <merijn> maerwald: That's because, like nix people, emacs people are loud :p
08:18:55 <{abby}> of the emacs users, how many do you think are vim users in denial? evil, vile and co
08:19:11 <maerwald> 20 vim, 35 emacs, 45 rest
08:19:18 <noctux> {abby}: well, I seem to want ts :p
08:19:25 <lightwave> I use Doom Emacs (evil mode) Best of both worlds
08:20:02 <noctux> hihi, vim's helptext on the matter:
08:20:05 <noctux>  Note: Setting 'tabstop' to any other value than 8 can make your file
08:20:08 <noctux>  appear wrong in many places (e.g., when printing it).
08:20:43 <maerwald> Last time I printed code was when trolling a prof and he liked it.
08:20:49 * hackage quickjs-hs 0.1.2.3 - Wrapper for the QuickJS Javascript Engine  https://hackage.haskell.org/package/quickjs-hs-0.1.2.3 (goodlyrottenapple)
08:38:23 <monochrom> The nuanced real problem is mixing spaces and tabs.
08:56:12 <maerwald> yeah, programmers fight over all sorts of non-sense, but everyone agrees that consistency is holy
08:58:41 <maerwald> Is there a good alternative to c2hs? The parses seems to not parse all of C correctly
08:58:48 <maerwald> It's quite tiresome
08:59:17 <merijn> maerwald: c2hs isn't intended to be fully automated
08:59:26 <maerwald> some issues on 32bit headers, some issues on windows
08:59:39 <merijn> Or am I thinking of c2hsc?
08:59:41 <merijn> I forget
08:59:53 <maerwald> sounds similiar :D
09:00:23 <maerwald> https://github.com/vmchale/libarchive/issues/17 and https://github.com/vmchale/libarchive/issues/12
09:00:25 <tdammers> the proper way is to set :tabstop to something like 3, 5 or 7; now any incorrectly indented file will look bad, and you will fix it
09:00:32 <tdammers> instead of perpetuating the badness
09:01:28 <monochrom> People will "fix" it with spaces after the tabs.
09:01:28 <merijn> maerwald: Which headers are you parsing with it?
09:02:53 <maerwald> merijn: C:/ProgramData/chocolatey/lib/ghc/tools/ghc-8.10.2/mingw/x86_64-w64-mingw32/include/psdk_inc/intrin-impl.
09:03:14 <maerwald> it's in the bug reports
09:08:45 <merijn> maerwald: There error is correct, though
09:08:54 <merijn> It's, in fact, no legal C
09:09:01 <merijn> At least, not C11
09:10:03 <merijn> alignment specifiers aren't valid inside structs, afaict
09:11:27 <merijn> Probably not why c2hs errors out, but still ;)
09:11:41 <merijn> It actually seems double illegal
09:11:59 <merijn> Since you can't have _Alignas inside struct definitions and it's not allowed inside typedefs either :p
09:18:58 <maerwald> well, like I care :p
09:19:03 <maerwald> I just want it to build
09:19:40 <maerwald> not fixing old windows headers
09:20:03 <maerwald> where do you send a PR even...
09:21:20 <maerwald> and then end up on an old gitlab instance where you get a response 2 years later, someone politely asking if that problem still exsits
09:29:26 <maerwald> parser should just be as permissive as possible
09:29:45 <geekosaur> with C that's asking for trouble
09:42:47 <phadej> alternative to c2hs is hsc2hs and a bit more manual code writing
10:03:24 <tomjaguarpaw> geekosaur: Turns out ghci does support what I was asking about: https://old.reddit.com/r/haskell/comments/jdhocz/how_to_have_the_executable_main_module_in_cabal/g9cb6yc/ 
10:04:15 <tomjaguarpaw> I've no idea what those commands are doing, but they do the job.
10:15:19 * hackage beam-core 0.9.0.0 - Type-safe, feature-complete SQL query and manipulation interface for Haskell  https://hackage.haskell.org/package/beam-core-0.9.0.0 (TravisAthougies)
10:58:50 * hackage beam-migrate 0.5.0.0 - SQL DDL support and migrations support library for Beam  https://hackage.haskell.org/package/beam-migrate-0.5.0.0 (TravisAthougies)
11:11:36 <bifunc2> Is it considered bad practice to put an integration test into an HUnit testCase?
11:11:58 <bifunc2> It works fine, but I'm asking because it's all in the name: HUnit (as in UNIT tests)
11:21:43 <fendor> bifunc2, I would not say so, but I would clearly declare what is an actual unit test and what is an integration test.
11:22:18 <bifunc2> yeah I put it into a seperate "Integration.  ..." module
11:23:28 <fendor> I think that is good enough
11:24:03 <crestfallen> hi after setting -XTypeApplications I can get the types of pure @[] (*) and pure @[] ((*),(+)) , but I don't know what that is doing or how to use it: http://ix.io/2BhD
11:24:54 <koz_> crestfallen: Are you asking 'what does TypeApplications do for me'?
11:27:10 <crestfallen> koz_: that and a few things: what is this type doing with (*) and Num a => [a -> a -> a], if that is a single entry list? How would you use that? 
11:27:57 <crestfallen> and the other entry there, pure @[] ((*),(+))
11:29:49 <crestfallen> yeah I don't get this type either (I assume it is also a single item list) : [(a1 -> a1 -> a1, a2 -> a2 -> a2)]
11:30:37 <koz_> A type doesn't specify how many items the list has.
11:30:40 <koz_> :t (*)
11:30:42 <lambdabot> Num a => a -> a -> a
11:30:47 <koz_> :t (+)
11:30:48 <lambdabot> Num a => a -> a -> a
11:31:08 <koz_> You're applying pure, specialized to produce lists, to a pair of functions of type a -> a -> a.
11:31:22 <koz_> Therefore, you get something of type 'I am a list of pairs of functions of type a -> a -> a.
11:31:25 <koz_> '.
11:31:39 <koz_> You're mixing type and value level again - don't do that.
11:31:49 * hackage beam-sqlite 0.5.0.0 - Beam driver for SQLite  https://hackage.haskell.org/package/beam-sqlite-0.5.0.0 (TravisAthougies)
11:32:26 <koz_> All TypeApplications lets you do is fill in yourself what you want a type variable to be.
11:32:31 <koz_> If you look at pure:
11:32:33 <koz_> :t pure
11:32:35 <lambdabot> Applicative f => a -> f a
11:33:04 <koz_> This says: For _any_ Applicative whatsoever, if you give me a thing of type 'a', I will give you an Applicative full of 'a's.
11:33:28 <koz_> Now, if you just write 'pure 10', you haven't said _what particular_ Applicative you want.
11:33:43 <koz_> That could create [a], Maybe a, Proxy a, whatever.
11:34:02 <koz_> So by saying 'pure @[] 10', you are saying 'I want a list _specifically_'.
11:35:22 <crestfallen> what about with the arithmetic operators koz_ ? could you show me that in action?
11:35:33 <koz_> crestfallen: Arithmetic operators are just functions./
11:35:38 <koz_> There's nothing special or magical about that.
11:35:51 <koz_> You can have lists full of functions, Maybe functions, Proxies of functions, whatever.
11:36:12 <crestfallen> I don't follow
11:36:40 <crestfallen> the note there says ... :
11:36:44 <koz_> What in particular about 'arithmetic operators' in this particular context throws you?
11:37:09 <crestfallen> it's not obvious just from the types here that @[] is a single item list
11:37:17 <koz_> @[] is not a single-item anything.
11:37:18 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
11:37:34 <koz_> It's a type application, to fix a type variable to a specific type.
11:37:44 <koz_> Stop. Mixing. Type. And. Value. Level.
11:37:56 <koz_> pure for lists produces a single-item list.
11:38:05 <koz_> This has nothing of any kind to do with type applications.
11:38:06 <crestfallen> I'm not mixing anything
11:38:58 <koz_> A statement like '@[] is a single item list' is _precisely_ mixing the type and value level. TypeApplications is about types. Single-item lists is about values.
11:39:02 <crestfallen> I don't know what it means to have the ((*),(+)) ascribed to defining pure to work on a list
11:39:16 <koz_> ((*), (+)) is a value.
11:39:22 <koz_> It is, more specifically, a pair of functions.
11:39:33 <koz_> You could do 'pure ((*), (+))' just fine.
11:39:36 <crestfallen> but those aren't my notes. that is from SO or someplace
11:39:51 <koz_> crestfallen: Your reading of said notes is what I take issue with.
11:40:00 <koz_> Let's clearly separate what's going on here.
11:40:02 <monochrom> This is why I don't use SO.
11:40:17 <koz_> Does the concept of ((+), (*)), on its own, make sense to you?
11:40:18 <monochrom> I know first-hand that SO contains wrong answers.
11:40:27 <koz_> Like, a pair of functions?
11:40:47 <monochrom> Granted, the example I know is about C and stdio, not Haskell.
11:40:49 <crestfallen> I'm only certain they are not my notes.
11:41:12 <koz_> monochrom: C has a lot of misconceptions about it everywhere. SO just amplifies this.
11:41:22 <geekosaur> that doesn't necessarily mean (a) they are correct (b) you have understood them
11:41:45 <monochrom> heh
11:41:51 <koz_> And in this case, from where I'm standing, it's an issue of (b).
11:42:12 <monochrom> But this one is more about stdio than C. C is "involved" because stdio is a C library.
11:42:57 <monochrom> So I gave this midterm question "how to detect whether stdin has hit EOF?"  I have a lecture slide that has the answer very visiblly.
11:43:22 <monochrom> My students decided to look up SO instead. This being COVID online exam and all.
11:43:51 <monochrom> The SO answer is "fseek to end, ask ftell if the offset is 0"
11:44:32 <geekosaur> "…not even wrong…"
11:45:31 <hyperisco> well I just implemented that as  (hGetChar hout $> True) `catchIOError` \_ → pure False  so I hope I'm right lol
11:45:56 <monochrom> I think Haskell's hIsEOF does that for you.
11:46:34 <crestfallen> koz_: I'd appreciate some review re: " Does the concept of ((+), (*)), on its own, make sense to you? 
11:46:42 <hyperisco> ah I guess slightly different… I also want to discard everything
11:46:52 <hyperisco> I am doing that in a loop until False
11:47:04 <koz_> OK, so, are you OK with, say (1, "foo") as a value?
11:47:19 <crestfallen> sure
11:47:32 <monochrom> But please don't put the catch-and-handler inside the loop. Put that outside.
11:48:11 <hyperisco> I see what you're saying but I've removed exceptions from my control-flow thinking lol
11:51:19 <bifunc2> fendor thanks :)
11:51:23 <koz_> crestfallen: What is the type of (1, "foo")?
11:52:30 <hyperisco> forever (hGetChar hout) `catchIOError` mempty -- für monochrom
11:52:42 <monochrom> Yeah
11:53:09 <crestfallen> (1, "foo") :: Num a => (a, [Char])
11:53:37 <koz_> OK. Now, what's the type of (+) and the type of (*)?
11:53:49 <hyperisco> in some languages (like JS I think) there is no operational cost to try/catch unless an exception is actually caught
11:54:29 <hyperisco> so I guess the only other reason is removing the redundancy by accepting exceptional control flow
11:55:03 <crestfallen> I see where it's going. pure @[] is ascribing List to the type of (a1 -> a1 -> a1, a2 -> a2 -> a2) , giving us ...
11:55:13 <crestfallen> [(a1 -> a1 -> a1, a2 -> a2 -> a2]
11:55:41 <crestfallen> oops
11:55:54 <crestfallen> [(a1 -> a1 -> a1, a2 -> a2 -> a2)]
11:56:44 <monochrom> Err nevermind, you're right, this one doesn't matter.
11:57:15 <monochrom> I wrongly had in mind "p = ... `catch` (\x -> ... p)"
11:58:28 <crestfallen> so the exercise is to set that up in ghci. so koz_ could you show me how that would play out in a ghci session? (If I'm correct to this point :))
11:59:51 <__monty__> crestfallen: Are you really asking for someone to enter something in a repl, which you could easily do yourself?
12:02:20 <__monty__> monochrom: I can't actually find an SO question that has that among the answers, they're all "use feof."
12:03:44 <monochrom> OK, I worded my question wrong. A more correct wording is "stdin is empty" as in if you try to read in the future you'll get EOF.
12:04:33 <monochrom> and I have the SO link my TA found when my TA marked that question, I'm finding the email now
12:04:55 <crestfallen> __monty__: the exercise , wherever it came from, only shows the types, as I have it in the paste. not sure where to go from here. 
12:05:14 <geekosaur> :t well, that makes a little more sense then
12:05:16 <lambdabot> error: parse error on input ‘,’
12:05:24 <geekosaur> where did that :t come from
12:05:52 <monochrom> https://stackoverflow.com/questions/36428098/c-how-to-check-if-my-input-bufferstdin-is-empty?rq=1
12:09:20 <crestfallen> I was trying to review pure, what it did, and this was in my notes. I understand what it is doing in this case :     
12:09:23 <crestfallen> λ> Just ((:) 4) <*> (pure [])
12:10:58 <crestfallen> but not the stuff about @[], how it is used
12:12:35 <hyperisco> SO is like Wikipedia with less sources
12:13:09 <hyperisco> SO is like if Wikipedia was a concatenation of opinions
12:13:48 <crestfallen> why would you set pure @[] beforehand, if you could use pure like this? : 
12:13:50 <crestfallen> λ> Just ((:) 4) <*> (pure [])
12:14:10 <crestfallen> doesn't that do the same lifting?
12:14:56 <geekosaur> because in this case it can infer which Applicative to use
12:15:29 <geekosaur> @[] is for when it otherwise couldn't
12:15:29 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
12:15:31 <hyperisco> crestfallen, did you realise that @[] is not a value and not an empty list?
12:16:43 <crestfallen> thanks all, yeah hyperisco it is a setting, so ghci knows what f you want pure to indicate
12:16:53 <crestfallen> indicate? word choice
12:18:11 <hyperisco> if you like, all types are passed as parameters, but normally they are passed implicitly by the compiler
12:18:43 <hyperisco> if you want to pass a type explicitly, you can use TypeApplications to do so
12:19:24 <crestfallen> ok yeah so if you set it, and wanted to write a full expression, what would the (shortened) expression look like? 
12:19:45 <crestfallen> I'm assuming it is a more terse expression
12:19:48 <hyperisco> I am not sure what you are asking for
12:20:50 <crestfallen> Like instead of using Just ((:) 2) <*> (pure [])
12:21:29 <crestfallen> if it were to be already set, could you have a shorter expression?
12:22:20 <geekosaur> if you had one where it could be inferred
12:22:43 <geekosaur> have you tried asking ghci the type of the expression with and without the @[] ?
12:22:45 <hyperisco> types can be inferred, values cannot be (if we ignore ImplicitParams)
12:23:54 <crestfallen> let me try that thanks geekosaur 
12:23:55 <hyperisco> you can golf your code there but it isn't going to be helped by a type application
12:24:14 <crestfallen> thanks one moment
12:26:12 <hyperisco> going on a tangent… you need more sophisticated types than Haskell has (conveniently) on offer to have useful value inference
12:27:09 <monochrom> You know how people prefer following tangents than following direct relevant productive answers.
12:28:26 <monochrom> The excitement of maximizing mysterious, uncertainty, adventures, and procrastinating actually solving the problem at hand.
12:28:31 <hyperisco> well I am not sure what the thinking is, but if it is wondering why we have to still state values when the type is already known, it is a relevant point
12:29:02 <monochrom> No, the question is why or when to state types.
12:29:13 <hyperisco> there is no reason to assume Haskell's asymmetry of values and types if you have a fresh perspective
12:30:00 <monochrom> phrased very unclearly, but it is still asking about when to omit types
12:30:21 <monochrom> or when to legally omit types
12:37:05 <crestfallen> very sorry, I don't know how to set @[] so the inference is known by ghci if pure is used
12:37:51 <hyperisco> :t pure @[] -- what does ghci tell you when you do this?
12:37:53 <lambdabot> error:
12:37:53 <lambdabot>     Pattern syntax in expression context: pure@[]
12:37:53 <lambdabot>     Did you mean to enable TypeApplications?
12:38:07 <hyperisco> if it says that then you need to  :set -XTypeApplications
12:38:59 <crestfallen> that I get: it's a -> [a], which is a -> f a
12:39:27 <hyperisco> those are not the same type
12:39:28 <koz_> Do Vectors have something like itraverse?
12:39:46 <koz_> Like, something of type (Applicative f) => (Int -> a -> f b) -> Vector a -> f (Vector b)
12:40:03 <crestfallen> sorry I meant pure :: Applicative f => a -> f a
12:40:16 <crestfallen> the f is []
12:40:39 <hyperisco> what is the problem?
12:41:01 <hyperisco> are we having a confusion of variable scope
12:41:28 <crestfallen> well I also read where ghci defaults to the f being IO or something
12:41:30 <hyperisco> every use of  pure  has its own  f
12:41:56 <hyperisco> in Haskell source you're used to seeing type variables not explicitly bound
12:42:01 <hyperisco> pure :: Applicative f => a -> f a
12:42:11 <hyperisco> what this means though is   pure :: forall f a. Applicative f => a -> f a
12:42:24 <hyperisco> every use of  pure  has its own  f  and  a  variables, they are bound by it
12:42:40 <solonarv> koz_: if nothing else, lens has a typeclass for that indexed traversal and Vector is certainly an instance of it
12:42:52 <hyperisco> :t (pure @[], pure @Maybe)  -- for example
12:42:54 <lambdabot> error:
12:42:54 <lambdabot>     Pattern syntax in expression context: pure@[]
12:42:54 <lambdabot>     Did you mean to enable TypeApplications?
12:43:17 <crestfallen> very sorry hyperisco but what about where we have the ((*),(+)). that is also part of what is being ascribed?
12:43:27 <solonarv> koz_: oh! there is Data.Vector.imapM if you're okay with a Monad constraint rather than Applicativ
12:43:38 <hyperisco> I don't know the discussion about that
12:44:26 <crestfallen> hyperisco: it's here, thanks   http://ix.io/2BhD
12:44:36 <koz_> solo
12:44:42 <koz_> solonarv: That's fine.
12:44:43 <hyperisco> saying  pure @[]  is like saying  subtract 3  … you wouldn't expect that because you use  subtract 3  once that everywhere then on that the first argument to subtract is set to 3
12:45:08 <hyperisco> so is the same for  pure @[]  it isn't the case that  f  is set to  []  then on for every use of pure, it only applies to the one use of pure
12:49:37 <hyperisco> I am not aware of ghci making special inferences for IO. I am only aware of ghci executing an IO value if you give it one and Show the result, rather than trying to Show the IO value
12:50:41 <crestfallen> hyperisco: how is that different from :    λ> Just ((:) 4) <*> (pure [])
12:50:52 <hyperisco> what am I comparing to?
12:50:56 <geekosaur> the rule IIRC is that if it's given an expression of type (Monad m, Show a) => m a, it instantiates m as IO
12:51:13 <hyperisco> is that ghci particularly or is that a default?
12:51:21 <geekosaur> ghci specifically
12:51:35 <hyperisco> okay
12:51:50 <hyperisco> > pure 3
12:51:52 <lambdabot>  error:
12:51:52 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M791473534142...
12:51:52 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
12:52:08 <hyperisco> maybe not lambdabot, though I thought it was based on ghci
12:52:27 <geekosaur> > return 3
12:52:29 <lambdabot>  error:
12:52:29 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M686074374140...
12:52:29 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
12:52:35 <hyperisco> works from the CLI though
12:52:35 <monochrom> Try yahb, real ghci
12:52:41 <gattytto> hello!
12:52:49 <geekosaur> yeh, llambdabot is not ghci
12:52:54 <monochrom> lambdabot is more like hint
12:53:03 <geekosaur> % return 3
12:53:04 <yahb> geekosaur: ; <interactive>:86:8: warning: [-Wtype-defaults]; * Defaulting the following constraints to type `Integer'; (Num a0) arising from the literal `3' at <interactive>:86:8; (Show a0) arising from a use of `print' at <interactive>:86:1-8; * In the first argument of `return', namely `3'; In the first argument of `GHC.GHCi.ghciStepIO :: forall a. IO a -> IO a', namely `(return 3)'
12:53:06 <monochrom> err no, not hint, mueval
12:53:27 <gattytto> I came to tell you all that Haskell is now officially part of Eclipse Che cloud-native WEB IDE :D  in 3 versions: 8.8.4, 8.10.1 and 8.10.2
12:53:46 <hyperisco> \o/
12:54:10 <gattytto> I'm also here to ask for demo projects for all those 3 versions that can be useful for newbies to the haskell 
12:54:13 <monochrom> I like Eclipse but I don't want the inefficiency implied by "cloud" and "web".
12:54:23 <gattytto> because my search got me quite outdated ones
12:55:00 <crestfallen> hyperisco: seriously should I delete this "lesson" that I got somewhere online? http://ix.io/2BhD
12:55:09 <hyperisco> I am speculating it is based on wasm
12:55:17 <geekosaur> anyway it works in yahb, and specifically requires Monad not Applicative
12:55:25 <gattytto> monochrom cloud means that all the haskell stuff resides in a docker sidecar with about 3GB's of mem and web means all the "ide" related stuff is rendered (not executed) within the browser's scope
12:56:01 <monochrom> You are confirming said inefficiency.
12:56:24 <geekosaur> monochrom, may I remind you of the dancing bear?
12:56:31 <crestfallen> should I forget about @[] and just be happy that it is explicit rather than inferred by ghci?
12:56:34 <hyperisco> crestfallen, I don't read anything wrong with it, though it is a bit threadbare for a beginner
12:56:41 <monochrom> What is dancing bear?
12:57:05 <gattytto> it runs quite nice in a 1GB ram tablet monochrom
12:57:11 <geekosaur> "the amazing thing about a dancing bear is not how gracefully it dances, but that it dances at all"
12:57:19 <monochrom> haha
12:57:40 <crestfallen> yeah thanks hyperisco I made the notes from something online I didn't understand initially. so it turned out threadbare :)
12:57:44 <hyperisco> crestfallen, what are you trying to learn from it?
12:57:55 <gattytto> now I'm looking for nice and noob ready examples to include in the ide, could you give me some ideas / links? 
12:58:32 <hyperisco> oh these are your notes? well I don't read anything wrong with your notes… not sure what the issue is
12:58:40 <monochrom> I suppose I do support programmers limiting themselves to tablets.
12:58:54 <hyperisco> possibly we're getting hung up on terminology
12:59:08 <crestfallen> hyperisco: every step .. beginning with > :set -XTypeApplications in ghci, 
13:00:08 <hyperisco> can you ask the question again because I think I'm lost
13:01:40 <monochrom> You know, question asking is a monadic art. Your next question depends heavily on the answer you get for the previous question.
13:02:02 <geekosaur> monochrom, a tablet would be a step up from what I'm currently running on. Except this has a real keyboard fsvo.
13:02:05 <crestfallen> hyperisco: if you could show it to me in a yahb session, like loading the thing and writing and expression after you've set (and please show me how) pure @[] ((*),(+)) or similar
13:02:19 <crestfallen> writing *an expression
13:02:26 <monochrom> adding a keyboard is OK
13:02:30 <gattytto> geekosaur my POC is a tablet insterted in a bluetooth keyboard that includes a mousemad
13:02:36 <gattytto> mousepad* 
13:02:46 <hyperisco> crestfallen, do you have the Haskell Platform installed? or can you otherwise run ghci?
13:02:59 <monochrom> I'm going for the 5-inch screen so programmers don't just assume "users have 40-inch 4K screens"
13:02:59 <crestfallen> yeah
13:03:16 <hyperisco> crestfallen, okay, then first you run the command   ghci  to start it
13:03:25 <crestfallen> thanks!
13:03:38 <crestfallen> :)
13:03:42 <hyperisco> that will bring you to a prompt, and there you can type in whatever expression you want
13:04:23 <hyperisco> also ghci commands like :t, :set, :help, etc, and statements like  import Data.List
13:04:29 <monochrom> Wait what are you running on such that it is a step down from even a tablet?  VT100?
13:04:42 <crestfallen> the only thing I know how to do is to check the types , as in that paste
13:04:43 <monochrom> 300 baud modem? :)
13:04:47 <crestfallen> hyperisco: ^
13:04:56 <hyperisco> as you import things the prompt will become longer, but you can set it to whatever you want with  :set prompt "λ> "  for example
13:05:34 <hyperisco> if you want to evaluate an expression you just put in the expression
13:05:35 <hyperisco> > 1 + 2
13:05:38 <lambdabot>  3
13:06:00 <crestfallen> hyperisco: sorry we are not communicating. very sorry. I can use ghci
13:06:05 <gattytto> or sum([1..10]) ?
13:06:54 <hyperisco> okay, well, I am struggling to understand what question you are asking
13:08:15 <crestfallen> ..> :t pure @[] ((*), (+)) what would you do with with this setting? hyperisco 
13:08:39 <hyperisco> that is a ghci command that asks what the type of  pure @[] ((*), (+))  is
13:09:45 <crestfallen> yes, but that's all I have from that "lesson" online. I don't know how you would go about using something of that type.
13:09:49 <hyperisco> do you know the difference between ghci and ghc? have you written a Haskell program in a file and compiled it?
13:10:34 <crestfallen> many times to varying effect
13:11:13 <crestfallen> could you show me some examples where that type is used in some way?
13:11:23 <hyperisco> I am not sure how to answer that sort of question… if you do not see a use for it, then don't use it :)
13:11:55 <hyperisco> I do not have any reason to use that type either
13:12:54 <crestfallen> I'm learning haskell from textbooks and online. I don't need haskell for anything except pure learning
13:12:57 <geekosaur> there are uses but they can usually be avoided
13:13:02 <hyperisco> but if we wanted to make something up… lets say I had two lists of numbers and a list of operations
13:13:27 <crestfallen> ok..
13:13:31 <hyperisco> > [x `op` y | x <- [0..2], y <- [0..2], z <- [(+),(*)]]
13:13:34 <lambdabot>  error:
13:13:34 <lambdabot>      • Couldn't match type ‘Unwrapped s0’ with ‘Unwrapped s’
13:13:34 <lambdabot>        Expected type: [Unwrapped s]
13:14:04 <hyperisco> > [x `op` y | x <- [0..2], y <- [0..2], op <- [(+),(*)]] -- should always talk to lambdabot first...
13:14:06 <lambdabot>  [0,0,1,0,2,0,1,0,2,1,3,2,2,0,3,2,4,4]
13:14:27 <hyperisco> well that is not using a tuple of operations I guess
13:14:33 <hyperisco> exercise for you :P
13:15:21 <gattytto> this is what I like about haskell, makes me feel like my first dev class, every time xD 
13:21:08 <crestfallen> so a pretty basic list comprehension hyperisco .. that much I get
13:21:47 <hyperisco> if you just want to study and not actually do anything with a computer language, why not try Agda?
13:22:45 <dminuoso> hyperisco: Haha.
13:28:46 <hyperisco> crestfallen, I reckon whatever you were reading was just picking arbitrary examples, they probably were not claiming they were important
13:32:25 <crestfallen> hyperisco: not a programmer, just an older person trying to keep intellectually active. I find haskell very interesting. I don't have a STEM background. just teaching myself. thanks kindly for your patient help.
13:34:08 <hyperisco> you can get a more distilled presentation of these ideas if you study the mathematical roots, if that is more so what you are interested in
13:35:01 <hyperisco> being a pragmatic programming language, Haskell has a lot of features that make it convenient for creating real computer programs, but sometimes at the cost of clarity
13:36:07 <hyperisco> you might like "lambda calculus" or "term rewriting" or "proof theory" for instance
13:38:40 <crestfallen> hyperisco: I've gone through a bunch of GADT, some proving , types as propositions - programs as proofs stuff. type unification (which I love). the little things, like @[] can be toughest for me. don't know why. like that was just incomplete notes of mine. sorry
13:40:11 <hyperisco> well see that is one of those Haskell blemishes (imo) … the intention of Haskell is to infer all types, but as Haskell programmers started pushing the boundaries, types became ambiguous or not inferrable
13:41:11 <hyperisco> TypeApplications walks back a bit from the intention of inferring all types… what you could do before was pass type proxies, or sometimes you could annotate
13:42:12 <crestfallen> still not sure how your example of the list comprehension applies to using pure @[]. like how that relates in Applicative hyperisco 
13:42:26 <dolio> Haskell has never been able to infer all types, I think.
13:42:39 <hyperisco> pure @[] (*) = [(*)]  so I just wrote  [(*)]
13:43:14 <hyperisco> if you meant to ask why you would ever use  pure @[]  and not just  pure  then it would probably only be because the type could not be inferred
13:43:59 <hyperisco> dolio, maybe but I think it fair to say that you are meant to lean on inference as much as possible. It is seen as a good thing, mrore is bertter
13:44:11 <dolio> Yeah, that's definitely true.
13:44:12 <hyperisco> more is better
13:46:04 <dolio> TypeApplications do seem like an odd design in light of a lot of other stuff. I think they could have been a nicer syntax for things people were already doing.
13:46:10 <hyperisco> crestfallen, but you can also say  (:[])  which is shorter and also the same thing
13:47:03 <dolio> Like `@[] :: Proxy# []` or something.
13:48:31 <hyperisco> I think it is fairly clear if you view it from Core, you're just explicitly passing type arguments as is done in Core
13:49:17 <dolio> Yeah, but importing core notions directly into the surface syntax isn't necessarily a consistent design.
13:49:51 <hyperisco> true, but I think proxies themselves are inconsistent
13:50:49 * hackage tzdata 0.2.20201016.0 - Time zone database (as files and as a module)  https://hackage.haskell.org/package/tzdata-0.2.20201016.0 (MihalyBarasz)
13:50:58 <hyperisco> well at least with a hardline view that types should be inferred… we're accepting more and more explicit type arguments as time goes on
13:51:49 * hackage phonetic-languages-rhythmicity 0.1.1.0 - Allows to estimate the rhythmicity metrices for the text (usually, the Ukrainian poetic one)  https://hackage.haskell.org/package/phonetic-languages-rhythmicity-0.1.1.0 (OleksandrZhabenko)
13:51:57 <dolio> You can't do anything about that except remove certain features.
13:52:30 <hyperisco> if/when dependent Haskell lands that will fly in the face of everything before
13:55:11 <hyperisco> my personal bet is that McBride wins and the future is just types
13:56:25 <maerwald> I think the future is lax strong structural typing with immutable functional architectures and strict by default semantics
13:57:08 <hyperisco> well I am going out a ways when I say "future", not saying what the immediate next thing is
13:57:13 <hyperisco> what is lax strong structural typing?
13:57:22 <maerwald> I just made that up
13:57:33 <maerwald> But something in between purescript and typescript
14:00:05 <crestfallen> maerwald: whatever you do don't drop it on your foot.
14:00:07 <hyperisco> my prediction is based on the assumption that we will progress from more to less work for the human programmer, and the way to do that is for the programmer to say what they want rather than how to get what they want
14:00:51 <maerwald> I think more expressive language go backwards to the goal
14:01:13 <maerwald> we think more expressive is always good, because it gives more ways to say what you want
14:01:19 <crestfallen> what do you mean the future is just types?
14:01:23 <hyperisco> assuming that, I think we're going to cross from computational expressions to declarative expressions
14:01:27 <maerwald> but you should have less ways to say what you want 
14:02:02 <gattytto> hyperisco yeah like protobuf .proto files that aren't actually code but just a declarative syntax to generate code in diff languages (made and used by google for a long) 
14:02:27 <hyperisco> maybe not the best terminology… I mean, when we use a programming language, what makes it so is that it has a semantics of computational steps
14:03:01 <hyperisco> and I don't see why that is necessary to concern a person with, ultimately
14:04:02 <crestfallen> how does that relate to say, handwriting recursive steps?
14:04:13 <monochrom> Does not.
14:04:39 <crestfallen> ok thanks all
14:06:40 <hyperisco> you can say that foldr removes you from concern of how to recurse on a list, I don't think that is an invalid observation, but the meaning of both (foldr or writing it yourself) is the same
14:07:06 <hyperisco> so the question would be, if foldr removes you from the concern of how to recurse on a list, where exactly does your thinking lie? obviously not in the language semantics
14:07:27 <hyperisco> and so we want to get to that place in our programming languages
14:08:06 <monochrom> foldMap has a better chance to the claim of distancing from that concern.
14:08:27 <monochrom> foldr? the "r" already talks about that concern.
14:11:00 <hyperisco> at least we're not programming register machines anymore (sorry embedded devs)
14:11:57 * davean looks at some haskell he did recently and quietly slides it to the side out of hyperisco's view.
14:13:20 <hyperisco> hey its fun, like a board game is fun… would make a good video game
14:14:13 <davean> Hey sometimes a bump pointer is too expensive
14:14:48 <hyperisco> I just don't see why I'd want to use it pragmatically, anymore than I'd want to use Mouse Trap to actually catch rats
14:15:33 <hyperisco> (I mean idealistically… I cope with obnoxious hardware too)
14:16:57 <hyperisco> anyways monochrom is worried that I am taking everyone on a distracting mysterious adventure, so I'll call it a night. later!
14:17:50 <monochrom> That was for another context.
14:29:50 <ph88> This might be a stupid question .. but is this module really just called "Prettyprinter" without any dots in the name ?  https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Prettyprinter.html  
14:32:01 <ddellacosta> ph88: yeah that looks right to me
14:32:07 <monochrom> You can click "source" to find out. But yes.
14:33:01 <ph88> i have dependencies   prettyprinter    and    import Prettyprinter   on lts-16.19 but can't find it
14:33:09 <ph88> wait let me check if its in lts
14:33:25 <ph88> ye it's there ..
14:33:28 <monochrom> Then you should look in stackage, not hackage.
14:33:45 <ph88> ok
14:33:57 <ph88> i see stackage has old version .. i think that is the problem then
14:34:58 <dolio> Man, ApplicativeDo is really picky.
14:35:45 <ph88> what about it ?
14:36:04 <ddellacosta> what is a better way to create a timing loop than e.g. calling threadDelay at the level of granularity that I want to trigger timing events? I'm not sure how to approach this
14:36:21 <dolio> `pure $ f . g $ x` works, but not `pure . f . g $ x`
14:36:56 <int-e> dolio: I like it ;)
14:36:59 <dolio> Also you can't use functorial stuff.
14:37:42 <int-e> (No, not really. But I do tend to write  pure $ f . g $ x  by default.)
14:37:55 <monochrom> @type (<$)
14:37:56 <lambdabot> Functor f => a -> f b -> f a
14:38:28 <gattytto> >@type (<$)
14:38:41 <gattytto> oh I thought the bot was gonna parse it
14:39:25 <phadej> dolio: yes, the `pure` becomes "syntax" with ApplicativeDo
14:39:57 <phadej> IIRC in first version you had to write pure (f . g $ x), i.e. pure $ ... form was added afterwards
14:40:20 <dolio> Also `let` in a do messes it up.
14:40:32 <monochrom> In all likelihood it is better to invent a flipped <$> than to invent ApplicativeDo.
14:41:54 <dolio> There's already a flipped (<$>), but that's not all you need.
14:42:20 <monochrom> getChar <*> getLine <*> putStrLn "thank you" <&> (\c s _ -> c : s)   =  what ApplicativeDo dreams of
14:42:38 <dolio> You need a complete set of opposite applicative operations that run in a different order, and to write your code in the opposite order.
14:45:24 <monochrom> I think my example is in ApplicativeDo order, down to the point the "return value" is specified last, no?
14:45:52 <dolio> Well, your example doesn't make sense, really.
14:45:55 <monochrom> Ah nevermind.
14:46:04 <monochrom> Right, that.
14:46:30 <dolio> Maybe it would work with (<**>), but I'm not very confident that associates correctly.
14:47:16 <dolio> Because it probably wasn't designed for that sort of thing.
14:49:10 <monochrom> Could you be talked into ApplicativeComprehension instead? :)
14:49:21 <dolio> (It's designed for the sequencing to occur in the opposite direction of the 'data flow'.
14:49:36 <dolio> Yeah, I'd use comprehensions if they could actually do applicative.
14:49:59 <dolio> I though they should be comprehensions from the get-go, really.
14:50:10 <dolio> Because that automatically implies a 'pure' at the end.
14:50:59 <monochrom> :)
14:52:06 <monochrom> $ is the root of all special compiler support
15:03:30 <phadej> https://hackage.haskell.org/package/overloaded-0.2.1/docs/Overloaded-Plugin.html Idiom brackets from TemplateHaskellQuotes
15:03:34 <phadej> (at the bottom)
15:03:45 <phadej> Use at your own risk!
15:04:33 <dolio> Nah, I'm not going to do that. :)
15:04:59 <phadej> wise choice!
15:05:49 <dolio> I'm just surprised at how fragile the desugaring is. I saw Marlow suggesting that it needed to be beefed up, but now I see why.
15:06:33 <dminuoso> I've heard Simon say a few times that ApplicativeDo has many corner cases where it fails to desugar into Applicative.
15:07:08 <dolio> Like, not allowing `let (x, y) = ...` where something in the `...` was bound earlier is a bit much.
15:07:19 * hackage churros 0.1.4.1 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.4.1 (LyndonMaydwell)
15:08:29 <dolio> Actually, the match doesn't even matter, I guess. Just no lets.
15:13:28 <phadej> will (x,y) <- pure ... work?
15:14:17 <dolio> Oh, maybe.
15:16:03 <dolio> Oh, no, it doesn't, because that's not applicative if it's using something in a previous bind.
15:17:12 <dolio> I'd have to inline the expression into the original binding.
15:17:13 <phadej> then `let` wouldn't work either. Would it?
15:17:35 <phadej> I see. If it's used once, then it's safe
15:17:48 <dolio> It should. Let just defines some expressions. It could be moved into the final expression.
15:17:50 <phadej> but I guess ApplicativeDo wouldn't want to reason on that level
15:18:27 <phadej> or hmm, the pure (\.... -> let (x,y) in ...) could still work
15:18:28 <dolio> Yeah, it might be a little complicated to keep track of.
15:18:41 <phadej> but specifyingthat might be tricky
15:19:22 <phadej> IIRC when the result isn't forced to be Applicative, the rewriting is somewhat ad-hoc
15:19:48 <phadej> (i.e. where binds happen)
15:20:37 <dolio> The desugaring doesn't seem to be type-directed. The reason I noticed this is that it's failing to work.
15:24:36 <ixlun> Hi all, I've got a template Haskell question.  Is there a way I can splice a name within a [d| .. |]?
15:25:16 <ixlun> for example [d| $(name) (Just x) = x |]
15:25:37 <ixlun> I get a syntax error when I do
15:28:10 <phadej> I don't think you can splice Names. That would be handy indeed
15:28:24 <ixlun> :-(
15:29:35 <phadej> I think you can use `syb` to replace your dummy name, but I'm not sure if the cure is worse than a problem
15:31:44 <ixlun> :t syb
15:31:45 <lambdabot> error: Variable not in scope: syb
15:31:59 <phadej> https://hackage.haskell.org/package/syb
15:32:19 <phadej> a package which allows you to traverse types which has `Data` instance
15:33:16 <phadej> e.g. https://hackage.haskell.org/package/syb-0.7.1/docs/Data-Generics-Schemes.html#v:everywhere would allow you transform all `Name`s inside `Dec`
15:42:48 <dminuoso> Mmm, Lift only provides `lift :: t -> Q Exp` and that's the only typeclass in TH I think?
15:44:11 <dminuoso> At that point the question is, why doesn't lift also let you `liftPat :: Lift t => t -> Q Pat` and `liftType :: Lift t => t -> Q Type` as well
15:45:58 <ixlun> Actually, it looks like even replacing all the names won't work...
15:46:22 <ixlun> I'm trying to do multiple pattern matches in a top-level fn decl
15:46:53 <ixlun> I think I need just one FunD with multiple claues
15:47:08 <ixlun> since the error I'm getting is: Multiple declarations of ‘psqt’
15:47:10 <dminuoso> ixlun: You can also use Language.Haskell.TH.Lib
15:47:14 <dminuoso> That could be a middleground
15:47:43 <dminuoso> Since that's filled with FooQ things instead of Foo, so you can lift/splice in between more liberally
15:48:16 <dminuoso> So rather than splicing inside a quoter, you could do the opposide and lift inside a splice.
15:52:17 <koz_> OK, am I patently insane? I'm getting an error message which says 'Expected a type, but 'a' has kind 'Type''. This is in something like 'newtype Foo (a :: Type) = Foo (State (HashMap Bar Baz) a)'.
15:54:54 <koz_> Apparently removing the :: Type part makes it OK?
15:55:40 <koz_> What am I missing here?
15:57:09 <MarcelineVQ> is that extra ' in 'Type'' intentional?
15:57:28 <koz_> MarcelineVQ: That's me quoting the error message.
15:57:35 <koz_> I shoudl really use double-quotes when quoting.
15:59:37 <MarcelineVQ> Where are you importing Type from?
16:00:28 <koz_> OH FFS
16:00:32 <MarcelineVQ> :>>
16:00:32 <koz_> That was it, thanks!
16:00:44 <koz_> Shows how much TH I've written.
16:00:51 <koz_> Both currently and up-to-now.
16:01:11 <koz_> import qualified Data.Kind as Actual
16:01:23 <koz_> newtype Foo (a :: Actual.Type) = ...
16:01:26 <MarcelineVQ> When you see a ' it means promotion of a value constructor is occuring, afaik
16:02:33 <MarcelineVQ> It might occur for type constructors too, I'm not sure, but it's your hint that a datatype is being promoted and Data.Kind.Type isn't a datatype, I think
16:03:04 <gnumonik> ixlun, Why do you wanna splice a name? I thought I wanted to do that when figuring out TH but it wasn't really what I needed every time I thought it was 
16:06:11 <hpc> there's a weird sort of humor to it being Data.Kind.Type and not Data.Type.Kind
16:06:52 <koz_> hpc: Lol.
16:06:57 <MarcelineVQ> Type.Type.Kind.Type.Kind
16:07:05 <koz_> If we're going for humour, we shoudl have Data.Type.Type.
16:08:13 <hpc> ("sort of humor" was an unintentional bonus pun)
16:08:24 <MarcelineVQ> You've gone too far.
16:08:36 <koz_> hpc: That was worthy of the 80s.
16:08:43 <MarcelineVQ> Rewease the secwet weapon!
16:12:23 <nshepperd> The Haskell type system is a kind sort
16:22:20 * hackage churros 0.1.5.0 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.5.0 (LyndonMaydwell)
16:35:29 <monochrom> I love puns. Keep them coming!
17:53:24 <koz_> @hoogle ($>)
17:53:24 <lambdabot> Data.Functor ($>) :: Functor f => f a -> b -> f b
17:53:25 <lambdabot> Data.Functor.Compat ($>) :: Functor f => f a -> b -> f b
17:53:25 <lambdabot> Data.Functor.Apply ($>) :: Functor f => f a -> b -> f b
18:28:56 <remexre> how does one write a (Free f a -> Free f a) effect? having a (a -> a) field on the functor would make it a non-functor...
20:09:57 <koz_> remexre: What do you mean by a (Free f a -> Free f a) effect?
20:10:31 <remexre> how would I write an effect like local (from Reader), for example
20:10:57 <koz_> :t local
20:10:58 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
20:11:32 <koz_> You don't need Free in your functor definition - that's what defines the effect.
20:11:37 <koz_> let me just sketch it for you quickly.
20:18:51 <koz_> remexre: Something like this I think. https://gist.github.com/kozross/a90e4554562d2f056d3c4c3c20da0545
20:20:26 * koz_ actually had to refresh his memory even though he worked on free monads like, a week ago.
20:22:36 <koz_> I think that's incorrect though. I figured out computation nesting once, and then promptly forgot about it.
20:33:34 <remexre> koz_: I think we might be using different definitions of Free or something; I don't think that definition of Ask works for me either
20:34:21 <remexre> mine would be Ask :: (r -> a) -> Reader r a
20:40:14 <ghoulguy> The question is: How do I define Reader in terms of Free, and then write ask and local on top of that?
20:42:24 <siraben> Ah, I think I've had that problem before when working with free monads, heh.
20:42:31 <siraben> Didn't get local to work
21:10:22 <koz_> remexre: That doesn't make a lot of sense though, since the point of ask is 'retrieve the environment'. That looks like Asks.
21:14:07 <koz_> But yeah, I guess I have no idea what I'm doing.
21:14:44 <koz_> Essentially, this is me: https://i.kym-cdn.com/photos/images/newsfeed/000/234/765/b7e.jpg
21:21:25 <ghoulguy> remexre: How about this? https://gist.github.com/glguy/a8be2d28c212c116a76035401710c4ad
21:22:07 <koz_> ghoulguy: Wait, are you going with a spooky season nick or something?
21:22:38 <ghoulguy> Yeah, it's the thing to do in #freenode
21:22:44 <koz_> TIL.
21:23:05 <koz_> I didn't realize who you were until just now.
21:23:17 <ghoulguy> In particular the freenode staff collectively think it's the thing to do :3
22:41:53 <hololeap> is there a library that simplifies outputting some strings into columns/rows?
22:52:28 <hololeap> for instance outputting something like [(String,String)] as a table in stdout
22:55:22 <hololeap> i just found 'boxes' which looks promising
23:02:19 * hackage ptr-poker 0.1.1.2 - Pointer poking action construction and composition toolkit  https://hackage.haskell.org/package/ptr-poker-0.1.1.2 (NikitaVolkov)
23:19:17 <koz_> hololeap: I think most prettyprinter libraries offer something like this?
23:59:54 <asheshambasta> Hi everyone, reflex-platform (?) related question. How does one override packages when using reflex-platform.project? I so far have: https://gist.github.com/asheshambasta/b18f21bc0bdf78b33b02cb846f4b83fe (based off https://github.com/srid/reflex-stone) where I'm trying to add the bulmex package. 
