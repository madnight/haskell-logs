00:00:23 <Axman6> I have no idea if this'll work though, I'm just following the types
00:00:53 <fragamus> V would have to implement typeclass Additive etc.
00:01:11 <Axman6> which it does
00:08:32 <fragamus> ok Linear.V looks like a winner
00:09:02 <fragamus> what does Portability      non-portable mean?
00:09:19 <Axman6> probably works with GHC
00:09:44 <fragamus> ok so it is prtable
00:09:50 <fragamus> portable even
00:26:02 <merijn> honestly "portability" and "stability" fields have no well defined meaning
00:26:13 <merijn> Some of my packages have stability "haha" :p
01:00:46 <avdb> What's the best way to install all Haskell tools on Linux? I did a fresh installation yesterday and I'd rather not clutter it again by installing GHC, Stack & Cabal in 5 different ways
01:01:06 <avdb> I head you're not supposed to use Haskell Platform or something because it was harmful
01:02:15 <merijn> define "all haskell tools" :)
01:02:41 <merijn> Are you on Arch? Because if so, rule one is: avoid the official packages :)
01:02:54 <avdb> I need GHC, GHCi, Stack, Cabal and the base packages
01:03:12 <avdb> Nope, Gentoo, Haskell support is amazing
01:03:17 <merijn> avdb: GHC+cabal are probably most easily/portably done via ghcup
01:03:35 <merijn> stack is most easily done via, well, stack (which will get GHC for you)
01:03:46 <avdb> Alright, that was the method I read about in "What I wish I knew before learning Haskell"
01:04:19 <merijn> If you're a Luddite whose pedantic about his environment there's also the "just download the GHC bindist" approach
01:04:34 <avdb> Unlike other books, instead of letting you dip your toes in the water first, it throws you directly in the cold water
01:04:38 <merijn> Which is what I stick with, but that's not for everyone :p
01:07:47 <maerwald> avdb: you can't have multiple GHC in gentoo
01:08:50 <maerwald> and it exposes hackage packages in a way that makes it impossible to have the same version installed multiple times, effectively leading to lots of dependency resolution problems
01:10:14 <avdb> Alright, so I need to stick with my package manager?
01:10:53 <[exa]> "your package manager" as the distro's package manager?
01:11:04 <avdb> Portage
01:11:12 <avdb> We have a Haskell overlay
01:11:16 <maerwald> avdb: as I said, you can only have one GHC and haskell packages are not handled properly 
01:11:32 <maerwald> it's not worth the trouble
01:11:58 <[exa]> avdb: certainly use ghcup and local cabal for your development packages... the way haskell packages work is problematic for distros to grasp correctly to allow both development and reliably installed packages
01:12:51 <avdb> Oh okay, but how do I update ghcup without hassle?
01:12:52 <maerwald> most package managers were written in an era where packages were C packages and maintainers lost sleep over changing/breaking API
01:12:58 <avdb> Since it's not recorded in Portage
01:13:18 <avdb> Hahaha, XMonad wasn't easy on dependencies either :$
01:13:21 <maerwald> now we have SemVer, npm and need tools like nix to handle any of that, but no one really understands
01:13:23 <[exa]> avdb: you don't need to, it's basically an onetime script
01:13:55 <[exa]> avdb: also it can kindof update itself, like rustups, pips and other "local" managers
01:14:20 <[exa]> anyway I have to say that I'd welcome ghcup in distro packages
01:14:32 <maerwald> it's a bit sad that you need the least ergonomic package manager out there to handle haskell packages correctly
01:14:44 <avdb> Oh that's cool, seems like it installs itself in my home directory
01:15:28 <[exa]> avdb: it's really convenient for development, just gives the user a working copy of ghc and cabal, with easy way to switch versions etc. Certainly the easiest way around, by far
01:16:52 <[exa]> avdb: if you don't mind a bit of `make install`, you can install ghc+cabal yourself from binary distribution on the web, which will give you a similar result with a bit more control. Eventually you could compile ghc, but that's a longer adventure
01:17:26 <[exa]> (by "longer" I mean "please don't do this to yourself now")
01:18:34 <merijn> You shouldn't compile GHC yourself unless you really have to
01:18:44 <merijn> And actually you run into circular issues anyway
01:18:56 <merijn> You need to already have a working GHC to compile GHC from source
01:19:10 <merijn> So, why would you bother building it if you've already got it :p
01:19:48 <avdb> [exa]: Oh no, I already had horrible experiences compiling rust in the past
01:20:22 <jchia> i'm wondering how much performance improvement you can get by compiling ghc yourself with optimization options fit for the target machine
01:20:31 <avdb> You're 100% right merijn. Compiling packages from source is only useful for customization with USE flags or ports.
01:20:49 <[exa]> jchia: that's very gentoo-oriented question right. :D
01:21:05 <avdb> Oh and optimizations, forgot.
01:21:08 <jchia> [exa]: i just find ghc, but i don't use gentoo
01:21:12 <jchia> i find ghc slow
01:22:07 <jchia> So if i can even get 5% improvement from building ghc from source, i would do it. i just haven't tried
01:22:40 <[exa]> I don't really believe the machine-specific optimizations would help it... ghc is slow because it handles giant heaps of irregular structures and tries to do it in a (relatively) sane and clean way, which can be hardly optimized by lowlevel changes in the compiler
01:23:11 <[exa]> jchia: would be interesting to see the benchmark though
01:33:01 <Guest6760> Hello. Im discovering Haskell through the development of a little chat server using TCP protocole. Sadly, i can only parse the message sent initially at the client connexion. If a client keep the socket open and continue sending message, i cant get them server side. Anyone with some experience with the Network module has a clue ? 
01:33:12 <Guest6760> as example im using the snippet found on the Network module documentation : 
01:33:35 <Guest6760> https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html
01:35:45 <[exa]> Guest6760: how exactly you "can't" get them on server side? the client disconnects? the read from the connection hangs forever?
01:38:13 <[exa]> (also, it might help a lot to pastebin some representative sample of your code)
01:39:27 <Guest6760> ah yeah pastebin ill do that. by i cant i mean i dont find how to do it. The client does not disconnect, but i dont know how to listen to/parse the message that the client keep sending
01:40:30 <Guest6760> https://pastebin.com/RCyZcwVb here is my server code
01:41:22 <Guest6760> i can log the message client send on connexion, and answer it also, at the connexion, but then nothing
01:42:18 * hackage benchpress 0.2.2.15 - Micro-benchmarking with detailed statistics.  https://hackage.haskell.org/package/benchpress-0.2.2.15 (willsewell)
01:43:15 <[exa]> ok good, you probably don't want to use plain 'recv' but you can wrap the socket with a handle-like interface; convert it using `socketToHandle` first. Then you can e.g. read the first "line" from the client using `hGetLine`
01:44:00 <[exa]> Guest6760: btw, highly suggest using some kind of telnet or netcat tool to debug&inspect client and server separately
01:45:32 <Guest6760> ok thanks a lot, i'll give it a try. Im using netcat as client but im was not aware i could use it to debug 
01:45:42 <Guest6760> i  was not aware
01:45:56 <maerwald> avdb: compiling from source is about trust too... and I don't  mean that from some paranoid privacy perspective, but from the perspective that package maintainers tend to mess up
01:46:27 <ph88> you mean you have to trust them not to mess up ? :P
01:46:46 <[exa]> Guest6760: if you are using it as client, you are probably already there :]
01:46:47 <maerwald> no, I don't have to, because I can see what they are doing exactly
01:53:19 * hackage conduit 1.3.3 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.3.3 (MichaelSnoyman)
02:09:15 <Franciman> Hi, what is the most mature GUI toolkit for haskell?
02:09:21 <Franciman> gi-gtk?
02:09:23 <Franciman> or gtk3?
02:13:26 <merijn> Mature in which sense?
02:14:38 <merijn> The most robust is probably ftlkhs, but it doesn't look all nice and shiny
02:17:20 <Guest6760> [exa] I'm experiencing the same issue with Handles : i read the first message sent, then the talk function is called again recursively, there is nothing to read, then it stop to listen to messages (i guess)
02:17:26 <Guest6760> https://pastebin.com/PBkc0KNe
02:18:05 <Guest6760> It seems that talk stop calling itself recursively after the 2nd execution
02:22:10 <dminuoso> Guest6760: Did you read the note at
02:22:15 <dminuoso> https://hackage.haskell.org/package/network-3.1.2.0/docs/Network-Socket.html#v:socketToHandle
02:22:23 <dminuoso> "By default, the new handle is unbuffered. Use hSetBuffering to change the buffering.'
02:23:01 <Guest6760> i red it but it didnt mean much to me :p
02:23:29 <dminuoso> Well, hGetLine will block until it gets a newline
02:24:02 <dminuoso> But if the handle is unbuffered, it wont get to a newline even though one may be in its buffer already
02:24:08 <dminuoso> Oh
02:24:10 <dminuoso> Haha
02:24:14 <dminuoso> Wait, I read this the wrong way around.
02:32:57 <maerwald> Franciman: gi-gtk is better maintained afair
02:34:34 <maerwald> Franciman: the gtk3 readme says "For all new application development you should consider using haskell-gi as it has much more complete bindings."
02:37:00 <Franciman> merijn, yeah I meant between gi-gtk and gtk3
02:37:02 <Franciman> thanks maerwald 
02:37:37 <merijn> Just throwing it out there because I know deech has put a ton of time into making it work/compile well on all platforms :)
02:45:46 <Franciman> merijn, but is fltkhs as low level as fltk?
02:46:10 <Franciman> I wanted to make something similar to https://github.com/wavewave/hoodle
02:49:55 <merijn> Franciman: Well, the docs claims "comes with GUI builder support to alleviate the tedium of laying out widgets by hand."
02:52:33 <merijn> tbh, I've mostly given up on GUIs for a while because they tended to be rather painful to setup and the ease of building ftlkhs is what got my attention, but if it can't really do what you need, then yeah, that matters very little :)
02:52:48 <Guest6760> setted the buffering mode to line buffering but the issue remains, i never get past the 2nd hGetLine call
02:54:07 <merijn> What is the remote side sending you, though?
02:55:21 <Guest6760> opening a connection client side with the command : echo "hello" | nc 127.0.0.1 3000
02:55:37 <Guest6760> then typing text in the opened process
02:55:44 <merijn> eh
02:55:50 <merijn> That's not going to work
02:56:01 <merijn> stdin is going to point to echo, not to nc
02:56:09 <merijn> and echo won't read anything from stdin
02:56:21 <Guest6760> AH
02:58:13 <Guest6760> AAAAAAAAAH, without echo it work perfectly
02:58:36 <Guest6760> i spent a whole day of this i feel ashamed.
02:58:41 <Guest6760> on
03:00:48 <Guest6760> thank u merijn, apologize since it was not haskell related at all
03:20:43 <tomsmeding> Guest6760: { echo "hello"; cat; } | nc 127.0.0.1 3000
03:21:07 <tomsmeding> assuming you're using bash or something similar
03:28:31 <dminuoso> What's the right way to gracefully shut down a warp server running in some thread?
03:28:42 <dminuoso> Is there a particular async exception to throw?
03:31:01 <phadej> KillThread?
03:31:27 <phadej> or ratheer https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Concurrent.html#v:killThread
03:51:19 * hackage radius 0.7.1.0 - Remote Authentication Dial In User Service (RADIUS)  https://hackage.haskell.org/package/radius-0.7.1.0 (erick)
04:05:49 * hackage aeson-commit 1.2 - Parse Aeson data with commitment  https://hackage.haskell.org/package/aeson-commit-1.2 (jonascarpay)
04:35:06 <dminuoso> phadej: Mmm, is that the most graceful thing to do?
04:35:17 <dminuoso> That might kill handlers right in the middle of it, wouldn't it?
04:35:17 <phadej> dminuoso: yes
04:35:24 <phadej> to graceful
04:35:45 <phadej> to handlers, I think they will run to completion, as they are in separate threads
04:35:53 <phadej> I don't think warp links them
04:41:24 <phadej> the docs imply that with runSettingsSocket you can control graceful shutdown of live (keep-alive)connections. You should read the code on what happens if exception is thrown to the warp's main thread
04:44:34 <Franciman> I see merijn thanks
04:53:49 * hackage pandoc-crossref 0.3.8.3 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.8.3 (lierdakil)
05:16:57 <gentauro> is there anybody that would like to talk about some work/hobby project in about two weeks for MF#K? https://www.meetup.com/MoedegruppeFunktionelleKoebenhavnere/events/rqbcdlybcnbkc/
05:17:09 <gentauro> it would be an online event ofc
05:17:37 <gentauro> here are some slides about MF#K :) http://blog.stermon.com/assets/talks/2019-12-13_Siteimprove-Community-Day.pdf
05:20:32 <dminuoso> phadej: Mmm, indeed. that seems to be it. Im mapping out the source code at the moment, but it seems as if settingsInstallShutdownHandler does the trick.
05:21:20 <dminuoso> At any rate, warp sets FileCloseOnExec - presumably throwing an async exception should be fine. Ill dig further whether warp links threads or not
05:21:37 <[exa]> gentauro: probably depends on how advanced stuff you'd want there
05:23:14 <gentauro> [exa]: depending on the topic, the crowd will match ;) I think Oskar Wickström had a 2-3 hour Q&A :)
05:23:23 <gentauro> and Marlow had 1 hour ;)
05:23:46 <gentauro> Marlow said "please stawp" xD
05:24:27 <[exa]> ok I guess I'm not that advanced in FP :]
05:25:05 <gentauro> [exa]: that said, we also had less advanced talks ;)
05:26:04 <gentauro> for the Agda talks, we have very few participants, for the more "normal" ones, the amount in participants increase
05:26:27 <gentauro> and if you can relate the FP topic with daily work, you will get a full house ;)
05:50:59 <[exa]> gentauro: well right, not very sure about that :D I'll think that through
05:51:19 * hackage elynx-markov 0.4.1 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.4.1 (dschrempf)
05:52:19 * hackage elynx 0.4.1, tlynx 0.4.1, slynx 0.4.1, elynx-tree 0.4.1, elynx-tools 0.4.1, elynx-seq 0.4.1, elynx-nexus 0.4.1 (dschrempf)
05:56:33 <gentauro> [exa]: please do and we will be happy to host your talk :)
06:32:19 * hackage mcmc 0.2.4 - Sample from a posterior using Markov chain Monte Carlo  https://hackage.haskell.org/package/mcmc-0.2.4 (dschrempf)
06:34:42 <kindaro> How can I encode my type to a `ByteString` with custom Aeson options?
06:35:03 <kindaro> The default `encode` does not accept options.
06:35:55 <kindaro> My type is Generic, so I can use `genericToJSON` to obtain `Value`, however I cannot find a way to convert `Value` to the serial representation.
06:36:50 <kindaro> I read the docs with all eyes I have but I could not find an appropriate function.
06:41:19 <lortabac> kindaro: one way to do it is to define a ToJSON instance: toJSON = genericToJSON options
06:42:03 <kindaro> So then a type can only be encoded one way, I see.
06:44:03 <lortabac> if you don't want to rely on the type classes, you can find a way to produce a Value and then just 'encode' the Value
06:44:23 <lortabac> Value has a ToJSON instance
06:45:50 * hackage pusher-http-haskell 2.0.0.2 - Haskell client library for the Pusher Channels HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-2.0.0.2 (willsewell)
06:46:49 <kindaro> Oh, I did not realize this. Thanks.
06:47:05 <lortabac> unless you need to customize the Value -> ByteString part
06:47:42 <merijn> At that point you need to question your life choices, tbh
06:47:53 <kindaro> `encode ∘ genericToJSON options` is what I need.
06:48:06 <kindaro> Life choices?
06:48:30 <merijn> If you need to customize the "Value -> ByteString" part as lortabac commented
06:48:59 <kindaro> Ah. Well, in my case I do not.
06:49:26 <lortabac> I said that because I was not sure I understood your question correctly
06:49:42 <lortabac> I was not encouraging to do that :)
06:51:53 <phadej> genericToEncoding might be more direct way
06:52:05 <phadej> refer to the documentation how to convert Encoding to (lazy) ByteString
07:09:58 <hyperisco> > (\if then 1 else 0) True
07:10:01 <lambdabot>  <hint>:1:6: error: <hint>:1:6: error: parse error on input ‘then’
07:10:30 <phadej> :t bool 0 1
07:10:32 <lambdabot> Num a => Bool -> a
07:10:41 <phadej> bool 0 1 False
07:10:48 <phadej> > bool 0 1 False
07:10:51 <lambdabot>  0
07:11:02 <Uniaika> phadej: I feel you
07:14:55 <hyperisco> > flip map [1,2,3] \x -> x + 1
07:14:57 <lambdabot>  error:
07:14:57 <lambdabot>      Unexpected lambda expression in function application:
07:14:57 <lambdabot>          \ x -> x + 1
07:15:06 <hyperisco> is that extension in GHC yet and what is it called?
07:17:19 <ski> % (`map` [1,2,3]) \x -> x + 1
07:17:19 <yahb> ski: ; <interactive>:58:17: error:; Unexpected lambda expression in function application:; \ x -> x + 1; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
07:17:31 <kuribas> I wonder what the added value of recursion schemes is.  They are fun to learn, but I feel they ultimately don't solve a real problem.
07:17:37 <ski> % :set -XBlockArguments
07:17:37 <yahb> ski: 
07:17:39 <ski> % (`map` [1,2,3]) \x -> x + 1
07:17:39 <yahb> ski: [2,3,4]
07:17:48 <dolio> kuribas: Yep.
07:17:48 <kuribas> you get slightly less verbose code...
07:18:22 <hyperisco> am I looking in the wrong place? not documented https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
07:18:23 <dolio> The value is that endless papers can be written about them.
07:18:50 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-BlockArguments> ?
07:19:17 <kuribas> dolio: indeed
07:19:19 <hyperisco> apparently I kept typing "black" instead of "block"
07:20:41 <kuribas> maybe they could better prove termination in a total language?
07:20:59 <dolio> I've never seen anyone use them in a total language.
07:21:20 <dolio> Also, some of them are not total.
07:21:55 <kuribas> anamorphism...
07:22:14 <merijn> I tried learning recursion schemes once
07:22:15 <phadej> anamorphims is corecursion, not recursion
07:22:19 <merijn> Decided it wasn't worth it
07:22:28 <hyperisco> we've all used foldr … the problem is that we have not learned enough as a community
07:22:29 <merijn> So hard to see what's going
07:22:36 <dolio> hylo is non-total.
07:22:52 <merijn> "oh, but by not reimplementing the recursion each time you avoid screwing it up"
07:23:04 <merijn> Which, in the grand scheme of things seems like a non-issue
07:23:20 <hyperisco> I'd say it is the wrong perspective
07:23:21 <merijn> I can't recall the last time I messed up implementing some recursive function
07:23:32 <kuribas> merijn: I find I can still screw up with cata :)
07:23:40 <hyperisco> the point should be removing the need to think about recursion, that is what it removes
07:23:45 <merijn> I spend more time trying to figure out recursion schemes then I ever spend debugging recursion
07:24:03 <merijn> hyperisco: But thinking about recursion is an order of magnitude easier than thinking about recursion schemes
07:24:18 <hyperisco> maybe, or maybe it is just an education problem
07:24:47 <hyperisco> and probably, before that, a lack of many people having experience
07:24:59 <phadej> merijn: learning a bit about recursion schemes might make you think about ordinary recursive functions in more principled way
07:25:04 <merijn> Seems like a big coincidence that the 10+ blogposts by different authors, 3 papers and the docs of recursion schemes are all inscrutable, even for the ones I know
07:25:15 <phadej> merijn: not much different than learning a bit of Haskell might make you better Python programmer
07:25:18 <merijn> phadej: Sure, but so far the ROI seems slim to non-existent
07:25:31 <phadej> merijn: maybe
07:26:10 <hyperisco> several arguments can be brought out that are hard to distinguish from, say, an OO programmer bemoaning the needless obscurity of FP
07:26:57 <typetetris> Someone here using ghc8102 for his production software already?
07:27:01 <merijn> I'll reconsider/reevaluate my opinion if/when someone shows me a tangible example that's improve
07:27:08 <merijn> typetetris: Define production
07:27:19 <hyperisco> I'd say all the same things about lens :P
07:27:26 <merijn> hyperisco: I don't use lens either
07:27:30 <typetetris> merijn: run software compiled with ghc8.10.2 to earn money.
07:27:48 <dolio> Lens is way more useful than fancy recursion schemes.
07:28:01 <merijn> dolio: Oh, I'm sold on the usefulness of lens
07:28:10 <merijn> dolio: I just haven't done anything where it was worth bothering
07:28:42 <merijn> I'm all about Luddite haskell :p
07:28:55 <merijn> (he says, after enabling TypeFamilies and GADTs everywhere...)
07:29:12 <kuribas> lens is great, but most stuff in lens is unnecessary IMHO
07:29:36 <phadej> merijn: UTerm in unification-fd is a very neat example of using recursion schemes ideas
07:29:40 <hyperisco> I am finding that some things just serve an implementation, and that isn't really where the challenge is
07:29:49 * hackage lucid-cdn 0.2.2.0 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.2.2.0 (locallycompact)
07:29:58 <hyperisco> I feel like lens is that sort of thing… but I am pretty stupid about lens.
07:29:59 <phadej> UTerm though being the same as Free
07:30:18 <merijn> I'm still undecided about free too :p
07:30:34 <phadej> it's used very differently though
07:30:37 <phadej> UTerm is very data-like
07:30:38 <merijn> I was trying to do a fancy AST with Free, ended with tons of boilerplate
07:30:44 <phadej> Free is hardly ever presented as it
07:31:08 <merijn> Talked to Ed about it and he told me he was just using a regular AST type instead of free for that reason
07:31:10 <phadej> boilerplate is worth if you can have something "for free" (like unification)
07:31:23 <phadej> for abitrary `f`
07:31:40 <phadej> but if you don't need (or cannot have) that kind of separation
07:31:44 <merijn> phadej: Sure, but I feel some of these solutions get over-hyped and then drag beginners into abstraction tarpits :)
07:32:06 <phadej> merijn: yes. I do think that all extensible-effects things are overhyped
07:32:21 <hyperisco> I think incorporating a generalisation and only using it in special cases is often increasing burden without benefit
07:32:23 <phadej> most people don't have the problems they solve
07:33:28 <lortabac> what problems do they solve?
07:33:49 <merijn> lortabac: Staying employed as PL researcher ;)
07:33:51 * merijn ducks
07:33:52 <phadej> "separation of concerns"
07:34:02 <hyperisco> getting Monad machinery from just a Functor is helpful when your total effort needs not be much more than obtaining Monad machinery
07:34:39 <phadej> which in that case is decoupling syntax from semantics
07:34:40 <hyperisco> if you then have to go on defining several more things, the benefit of Free becomes comparatively small and the burden multiplies over your remaining effort
07:35:00 <phadej> (specifically having different semantics for the same syntax)
07:35:10 <phadej> if these words don't mean anything to you, you don't have that problem ;)
07:35:26 <lortabac> I think I don't have that problem :)
07:35:28 <hyperisco> in other words, Free life seems to start with your Functor, then you start adding on more definitions, then you realise what Free is giving you isn't worth it
07:35:51 <phadej> (here syntax is "program text", and semantics "what this text actually does, if executed")
07:35:53 <dolio> It might just mean you don't recognize that you have the problem.
07:36:35 <lortabac> dolio: possible
07:37:35 <hyperisco> the truly free Free would be an automatic derivation, something that adapts to your data definition rather than you having to adapt to Free
07:37:39 <merijn> Meanwhile I just want checked exceptions in Haskell :(
07:37:50 <merijn> Also, proper first class concurrency/threading
07:38:01 <merijn> With resource domains
07:38:06 <hyperisco> merijn, have you used checked exceptions in any other language?
07:38:21 <merijn> hyperisco: Yes, but those are shit, because they're not inferred
07:38:52 <hyperisco> personally I failed to find a compelling use
07:39:03 <merijn> hyperisco: I want to be able to know "what *exact* set of exceptions can this throw?" and "this can never throw an exception"
07:39:26 <merijn> None of this Haskell shit of "look at the docs and pray someone documented all exceptions (spoiler: they never do)"
07:39:33 <dolio> So, an extensible effects system.
07:39:38 <hyperisco> I found some utility with file system operations, because you learn things about files through exceptions
07:39:38 <merijn> dolio: No
07:39:50 <merijn> dolio: I want it pure, because I think I've worked it out
07:39:59 <merijn> dolio: Specifically I *don't* want it in the types
07:40:01 <merijn> or rather
07:40:06 <merijn> not in the types we have now
07:40:12 <merijn> I want orthogonal types for exceptions
07:40:48 <merijn> "(/) :: Int -> Int -> Maybe Int" (or whatever checked variant) is unacceptable
07:40:57 <kuribas> hyperisco: I have in java, and it's still better than nothing.
07:41:07 <xsperry> having used checked exceptions in java, I don't miss them
07:41:09 <dolio> Maybe isn't an extensible effects system.
07:41:27 <merijn> I wanna determine that "(/) :: Int -> Int -> Int" can throw "division by zero" *without* any change to that type signature
07:41:47 <xsperry> determine how? by getting a compile error if you don't catch that exception, every single tim eyou use /?
07:41:53 <merijn> And I'm 95% certain it can be done
07:41:59 <hyperisco> merijn, I would be more inclined to that idea
07:42:19 <hyperisco> my issue is that different types of exceptions have scant uses, at least in my experience
07:42:22 <merijn> xsperry: In java you need to annotate them in all intermediate functions, ain't nobody got time for that
07:42:36 <hyperisco> in other words, having one type for all exceptions seems to cover almost every use
07:42:36 <kuribas> merijn: I'd prefer a theorem prover, than proves the denominator is never 0 :)
07:42:49 <merijn> kuribas: That's nice, but not always possible
07:43:32 <lortabac> merijn: do you have some draft/prototype of your idea?
07:43:33 <merijn> Maybe once my thesis is finally done I'll get around to revisiting my idea and make a prototype
07:43:52 <merijn> lortabac: I started working on one, but it's on indefinite hold
07:44:03 <hyperisco> merijn, even annotating just top level definitions I found was a chore
07:44:16 <davean> kuribas: and we already have that :)
07:44:22 <kuribas> merijn: then you can always do: if denom == 0 then exceptionCase else compute...
07:44:26 <hyperisco> if you try and be fine-grained and have different exceptions for different sorts of problems, there is a systemic problem with it
07:44:28 <kuribas> davean: liquid haskell?
07:44:36 <merijn> kuribas: No, because that only works there
07:44:41 <merijn> kuribas: It doesn't propagate
07:45:02 <merijn> kuribas: If I map a throwing exception over a list, I wanna track that without handling it right away
07:45:16 <merijn> kuribas: Your solution is "just handle the case so you don't have an exception"
07:45:19 * hackage secp256k1-haskell 0.5.0 - Bindings for secp256k1  https://hackage.haskell.org/package/secp256k1-haskell-0.5.0 (jprupp)
07:45:45 <hyperisco> I think the focus is maybe too much on "how" and not enough on the "what" and "why"
07:45:58 <merijn> I want to have it transparently and be able to assert "this doesn't throw" (either due to not throwing or an underlying catch dealing with it)
07:46:45 <davean> kuribas: thats one of them
07:48:21 <hyperisco> what is the actual problem? if the problem is merely knowing if something throws or not, that doesn't require anything too fancy
07:48:30 <hyperisco> it is just one bit of information
07:49:09 <merijn> hyperisco: 1) that's harder than you think and 2) handling multiple possible errors isn't much harder
07:49:50 <davean> hyperisco: Its somewhat uninteresting as every unmasked thing throws
07:49:59 <hyperisco> 1) I didn't say how difficult it was 2) but what is the point
07:50:02 <merijn> davean: Well, see my 2nd point
07:50:07 <phadej> pure exceptions are hard in lazy language
07:50:15 <merijn> davean: I want proper first class concurrency and resource domains too
07:50:20 <phadej> you cannot have pure `try`
07:50:21 <davean> yes, sure
07:50:21 <merijn> phadej: I'm not convinced
07:50:46 <hyperisco> I am saying I've been around this block twice in two different ways over the past 3 years and both times it proved fruitless
07:50:49 <merijn> phadej: I think you can! Now I just need to free up half a year to prove it :p
07:50:54 <davean> phadej: there is an entire deterministic class of exceptions.
07:50:55 <xsperry> merijn, how can you ensure that "this does not throw out of memory exception"?
07:51:05 <davean> phadej: really we already *have* pure try
07:51:08 <merijn> xsperry: Ok, that one is tricky
07:51:23 <merijn> xsperry: Or really, not really interesting, since everything can throw that
07:51:27 <xsperry> disk failure. or even not enoug hspace on disk
07:51:36 <phadej> disk failure is not pure exception
07:51:39 <phadej> it's IOError
07:51:45 <davean> xsperry: those are the unmasked exception case
07:51:50 <kuribas> merijn: something like "(/) :: Int -> Int -> Int throwing DivideByZeroException"?
07:52:12 <merijn> kuribas: I like types, so I think we need more of them!
07:52:22 <merijn> kuribas: You need finer grained in a lazy setting, tbh
07:52:39 <kuribas> merijn: then what is the type of?  map (/) numbers
07:52:42 <phadej> davean: which is? do you mean deepseq, I don't think it's "pure try"
07:52:43 <xsperry> phadej, what's a pure exception? you can't throw exceptions in non-IO code in haskell
07:52:51 <phadej> xsperry: sure you can
07:52:54 <phadej> :t throw
07:52:54 <merijn> I want a type signature for exceptions (inferred) and resource domains, but without the usual nonsense of stuffing everything into the "functional" type
07:52:56 <lambdabot> Exception e => e -> a
07:53:05 <phadej> you shouldn't, but you can
07:53:07 <phadej> and / throws
07:53:10 <phadej> > 1 / 0 :: Int
07:53:13 <lambdabot>  error:
07:53:13 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
07:53:13 <lambdabot>      • In the expression: 1 / 0 :: Int
07:53:17 <phadej> > 1 `div` 0 :: Int
07:53:19 <lambdabot>  *Exception: divide by zero
07:53:23 <davean> phadej: no, All the exception monads that aren't transforms of IO/ST
07:53:42 <merijn> davean: I don't consider those exceptions, tbh
07:53:47 <merijn> (stuff like ExceptT)
07:53:47 <dolio> You can throw IOErrors in pure code if you want in GHC.
07:54:23 <davean> dolio: I don't want, can I still do it?
07:54:36 <dolio> You can.
07:54:45 <davean> Damn
07:54:46 <dolio> But if you don't want, you probably won't.
07:55:01 <phadej> davean: these have overheads, mostyl acceptable, sometimes not
07:55:08 <phadej> and that sometimes is nasty :(
07:55:27 <davean> phadej: They have overhead, sure, but they do catch pure exceptions effectively.
07:55:56 <davean> Theres no reason we couldn't build a better version of them
07:55:58 <phadej> davean: but they aren't vocabulary. If you want to catch division by zero, you need to rewrite about everything
07:56:09 <davean> phadej: thats just a failing of Haskell currently.
07:56:21 <davean> Because our sollutions are bad doesn't mean we can't have less shitty ones
07:56:34 <davean> It is clearly a solvable problem
07:56:38 <merijn> Like I said, I think it can be done
07:56:48 <davean> We absolutely *know* it can be done
07:56:52 <phadej> I don't think people would agree on Either someting a to be the result type of division
07:56:54 <merijn> Probably not in a backwards compatible way with Haskell, which is a shame :\
07:56:59 <merijn> phadej: Without that
07:57:03 <phadej> it have to be convinienet enough to be used
07:57:07 <phadej> (or first accepted)
07:57:53 <hyperisco> mm how about use constraints
07:57:55 <merijn> Actually, maybe it could be backward compatible enough...
07:58:09 <davean> The question isn't if it can be done, its how much we like the best version we know how to make
07:58:11 <hyperisco> (/) :: Exceptional => Int -> Int -> Int
07:58:13 <merijn> You know what I also want that ties into this
07:58:20 <hyperisco> or  Partial
07:58:29 <merijn> strictness polymorphic code
07:58:49 <davean> merijn: Thats sorta levity polymorphism ...
07:58:55 <davean> (Which Haskell sucks at)
07:58:58 <phadej> merijn: that sounds that you don't want Haskell anymore, but something else ;)
07:59:04 <merijn> phadej: I do
07:59:09 <hyperisco> catch :: (Partial => x) -> (Exception -> x) -> x
07:59:11 <merijn> (want something else)
07:59:18 <phadej> that's fair
07:59:30 <merijn> But implementing a sufficiently well-performing alternative to Haskell is more than a 1 person job :p
07:59:43 <merijn> phadej: I want something that is a lot *like* Haskell, but not Haskell
08:00:02 <phadej> merijn: having a prototype toy language is something 1 person can still make
08:00:06 <merijn> Maybe csaba's whole program compilation stuff will help me get started
08:00:23 <hyperisco> I bet that is doable with backwards compatibility
08:00:25 <phadej> then bigger community can think whether it can be bolted back to GHC Haskell, if its found valuable
08:01:09 <merijn> phadej: A lot of the things I truly want are probably to invasive to ever get into GHC (it'd be a mess trying to intergrate it with the existing dependent haskell stuff, etc.)
08:01:38 <phadej> well, LinearTypes got in...
08:01:42 <hyperisco> then we can watch the Partial constraint get inferred on most of Haskell code :P
08:01:43 <merijn> But csaba's has (wildly ambitious plans) to develop/split of the Core pipeline from GHC, which I think would be an *amazing* development
08:01:50 <merijn> phadej: People got paid to make linear types ;)
08:01:52 <phadej> I do think everything is possible if you want (and yell) hard enough
08:02:29 <merijn> If GHC's code generation could be split off and reused I think that'd encourage/help experimenting with other languages a lot
08:02:43 <phadej> yes
08:02:44 <merijn> Like, having something that can ingest something like Core
08:02:56 <merijn> I can work with Core and reasonably target it
08:03:14 <phadej> Well, no. Core evolves
08:03:18 <phadej> it changed with linear types e.g.
08:03:24 <phadej> and will further change with more dependent haskell
08:03:48 <phadej> so it's not that stable interface (though quite small, so you may be able to adopt)
08:04:24 <phadej> but it's very likely it will iss some feature that an experimental frontend would like to have
08:04:36 <phadej> (that's the case with LLVM IR e.g.)
08:05:14 <merijn> phadej: Yeah, but an evolving high level interface is much better than having to compile to LLVM IR myself
08:05:15 <phadej> one IR to rule them all is quite ambitious goal :)
08:05:23 <merijn> that's way too low level to deal with
08:05:41 <phadej> (the type-theoreitical IR = Core-like language, it is)
08:06:15 <phadej> but I do agree, that making GHC Core usable without GHC frontend is a good first step
08:06:16 <dolio> LLVM seems to lack features for compiling functional languages, too.
08:06:20 <phadej> and quite big one
08:06:22 <merijn> phadej: but having to develop a full native code backend is just way too much work for someone to attempt with a useful goal
08:06:50 <phadej> (i..e. if GHC Core is good enough for your experiment, it's a shame it cannot be used today)
08:07:38 <merijn> Or GRIN, I suppose
08:30:49 * hackage subG 0.1.0.0 - Some extension to the Foldable and Monoid classes.  https://hackage.haskell.org/package/subG-0.1.0.0 (OleksandrZhabenko)
08:37:57 <blip> Is it possible to get the ghc version used to compile a module without cpp?
08:38:49 <kuribas> merijn: I'd like a language which allows type level computations in it using the same language.
08:39:05 <kuribas> merijn: but still with separation between types and kinds (not dependend types).
08:39:32 <kuribas> merijn: so you can still have hindley millner inference for most programs.
08:40:25 <kuribas> merijn: GRIN looks nice as an IR.
08:41:57 <dolio> Have you tried dependently typed languages? Agda and Idris are not exactly poor when it comes to inference.
08:42:31 <kuribas> dolio: I still prefer haskell inference
08:43:22 <kuribas> merijn: if you want to make a derivative language using GRIN, you can count me in :)
08:43:43 <monochrom> "One IR to rule them all" sounds like standardizing C all over again, you will just end up having 90% of it UB or implementation-defined.
08:44:13 <kuribas> monochrom: GRIN is meant as a step above C or LLVM, to defunctionalize a program.
08:44:23 <kuribas> monochrom: it's not meant to be between the machine and the program
08:44:25 <hyperisco> every time you read or hear "the IO monad" just imagine "the dog animal"
08:44:46 <hyperisco> and we can expunge this from common parlance
08:44:52 <monochrom> Do you also extend that to "the Maybe monad"?
08:45:32 <dolio> How about the free monoid monad?
08:45:43 <monochrom> "the integer monoid"? "the integer group"? "the integer ring"? "the integer commutative ring"? "the integer module"?
08:46:03 <monochrom> "the human species"? "the dog species"?
08:47:38 <monochrom> I know there are terrible writers who write "the IO monad" blindly. But for the rest of us, if we bother to write that, the context is we're focusing on the monadness.  Just like when we bother to write "the human species" instead of just "humans".
08:48:45 <carbolymer> I'm looking for mutable thread-safe, performant, hash map implementation, sth like Java's concurrenthashmap; I've found stm-containers, but the docs are vague and after reading the code I'm under impression ithat it just shoves whole multimap into TVar - which isn't really what I want
08:49:30 <hyperisco> well then the substitution makes sense and you can carry on :P
08:50:04 <hyperisco> I guess we don't say "dog animal", even though it follows the same pattern
08:50:26 <dolio> They do in Battlefield Earth.
08:50:39 <carbolymer> do you know which map implementation would be good? or should I just use `Map Text (TMVar DList a)` ?
08:51:11 <monochrom> We say "the dog phylum" or whatever level in the hierarchy it is, similar to "the human species".
08:51:39 <monochrom> because "animal" is too broad in that hierarchy.
08:51:54 <monochrom> and "the sine function", and "the sine wave".
08:52:47 <monochrom> There is a reason natural languages nor programming languages are xz files.
08:53:28 <hyperisco> hm, is "the sine function" another extraneous phrase
08:54:26 <monochrom> NO
08:54:38 <monochrom> <monochrom> "the integer monoid"? "the integer group"? "the integer ring"? "the integer commutative ring"? "the integer module"?
08:54:51 <monochrom> Read that 100 times until it feels natural.
08:55:09 <hyperisco> it feels natural if we're talking about algebraic structures
08:55:12 <monochrom> err s/100 times/repeatedly/
08:55:49 <monochrom> Then "the sine function" is natural when talking about function structures. "the sine wave" is natural when talking wave structures.
08:56:00 <monochrom> "the IO monad" is natural when talking about monad structures.
08:56:13 <hyperisco> yes I am just saying I think I usually hear "the sine function" and never simply "sine"
08:56:14 <monochrom> So you have always known it, you just don't want to admit it.
08:56:38 <EvanR> carbolymer: any reason you need specifically that data structure
08:56:42 <hyperisco> granted, it is a homophone with too many other meanings
08:57:07 <EvanR> generally haskell's GC works better with immutable
08:58:02 <hyperisco> the weirdness isn't when you're talking about >>= and you say "the IO monad", it is when you're talking about putStrLn and you say "it runs in the IO monad"
08:58:32 <monochrom> The Haskell library doesn't have imperative lock-free concurrent mutable data structures.
08:58:44 <monochrom> There is not enough demand to begin with.
08:59:01 <hyperisco> but maybe that happens because "IO" isn't unambiguous enough
08:59:57 <monochrom> One single IORef, atomically used, that points to an immutable version, solves 99% of the same problems.
09:00:13 <monochrom> Note that you get ACID automatically.
09:03:48 <kuribas> the danger is that the monadicness of IO looks like something special by beginners.  But IO works perfectly without a Monad instance.
09:04:23 <c_wraith> and conversely, monads have nothing to do with "impurity"
09:04:49 <dolio> Seems like sometimes people decide it's useful to communicate with more than the absolute minimum number of bits of information possible, and that isn't really a problem to be solved.
09:05:08 <monochrom> Right, I don't say "monad" when the context is teaching IO itself.
09:05:32 <monochrom> But that is hardly the only valid context.
09:06:15 <c_wraith> dolio: no, I think this one is.  The problem is that people really do think monads are special because they think IO is what monads are.  It's IO that's special, not monads.  But they get conflated by a *lot* of people because they always see IO described as a monad.
09:08:49 * hackage subG 0.1.1.0 - Some extension to the Foldable and Monoid classes.  https://hackage.haskell.org/package/subG-0.1.1.0 (OleksandrZhabenko)
09:09:09 <blip> Why are there only Natural nums on the type level?
09:09:25 <kuribas> Then it seems monads are only necessary because you have a pure language, and they are no more than a kludge to fix a language that can only appeal to accedemics.
09:09:29 <blip> What about a promoted 4.7?
09:09:36 <Rembane> blip: Because it's almost impossible to put other kind of numbers there. 
09:09:42 <Rembane> blip: How would you represent 4.7 as a type? 
09:10:06 <blip> for example :     Proxy :: Proxy (4, 7)
09:10:22 <blip> why wouldn't that be possible?
09:11:10 <blip> why isn't it syntactically suported? Often I use negative numbers at the type level
09:12:51 <Rembane> blip: That sounds like a more possible, representation.
09:13:09 <solonarv> it probably just isn't supported because nobody has said to GHC devs "hey, I really need type level non-integer numbers"
09:13:25 <blip> non-natural
09:13:58 <solonarv> you can of course define type-level integers or rationals yourself, you just won't get nice syntax where you just write down a numeric literal
09:14:03 <dolio> Monads (and similar stuff) are useful for many things that are not directly related to 'purity'.
09:14:23 <davean> I mean you can create a TDouble Nat Nat, but defining rules for it will be "fun"
09:14:25 <blip> solonarv: yes, but that get's ugly fast
09:15:20 <kuribas> blip: I think because Naturals are used for array indexing, one of the main usecases for typelevel numbers, but Double is much less handy.  
09:15:59 <blip> Well, but negatives can be nicely used for physical dimensions for example.
09:16:17 <davean> what physical dimensions can be negative?
09:16:24 <davean> weight can't be, length can't be ...
09:16:42 <kuribas> blip: how do you use physical dimensions on type level?
09:17:08 <blip> davean: length can be, for example  5 s/m
09:17:26 <davean> blip: Theres no negative there
09:17:37 <blip> davean: yes, there are
09:17:39 <davean> kuribas: Oh thats easy, you often want to run a program for a specific case, so you pass parameterize at the type level by the static information
09:17:50 <blip> m^(-1)
09:18:02 <davean> no, theres no negative there, theres a m^-1
09:18:05 <davean> but thats not a negative value
09:18:15 <kuribas> davean: I don't get it
09:18:16 <davean> Which is a very important thing to realize
09:18:20 <blip> well, -1 looks negative to me
09:19:33 <blip> 60 :: Meter^1 * Second^(-1)
09:20:40 <davean> blip: its a negative exponent, but not a negative value, it produces a unit and the value of the unit isn't negative. You can choose to talk about it as an exponent, or directly what it is
09:20:53 <davean> The negativeness there is just notation for the unit
09:22:06 <davean> in the same sense that subtraction isn't a negative number
09:23:23 <solonarv> right, and if you want to write down the negative exponent on the type level, you need negative type-level integers
09:23:24 <kuribas> blip: I am missing the explanation why this would be interesting *at type level*.
09:23:39 <solonarv> I do think blip's notation is sensible and desirable
09:23:53 <blip> kuribas: you could avoid adding seconds to meters for example
09:24:08 <solonarv> putting units/dimensions on the type level lets you make the typechecker do dimensional analysis for you
09:24:29 <kuribas> blip: then you just need a Meter newtype and Seconds newtype.
09:25:04 <kuribas> solonarv: in that case I would just have one canonical type.
09:25:25 <solonarv> now if you want to multiply two Meter values you also need an Area newtype, if you want to divide a Meter value by a Seconds value you need a MeterPerSecond newtype... it's a profusion of newtypes!
09:26:09 <blip> kuribas: how would you possibly implement multiplication
09:26:23 <phadej> https://hackage.haskell.org/package/uom-plugin
09:26:45 <kuribas> blip: a Squared type?
09:27:14 <kuribas> like (Squared Meter)
09:27:38 <blip> (:*:) :: (Meter x, Second y, Mass z, ...) -> (Meter x', Second y', Mass z', ...) -> (Meter (x+x'), Second (y+y'), Mass (z + z')...)
09:27:51 <solonarv> and now you need a Cubed type, and you need to figure out division still...
09:27:51 <blip> of any SI-Dimension
09:27:59 <solonarv> there *are* libraries that do this already, mind you
09:28:10 <davean> dimensional for example
09:28:16 <davean> a few others
09:28:19 <kuribas> solonarv: or just... don't?  Don't try to encode everything in types?
09:28:57 <phadej> >>> It is traditional here to cite the Mars Climate Orbiter, or the Gimli Glider
09:29:00 <phadej> (http://lamar.colostate.edu/~hillger/unit-mixups.html).
09:29:10 <davean> kuribas: so, for example, if I want to setup a control system, knowing the paraeters staticly let me generate code that optimally performs the control operation for each enumerated case
09:29:15 <solonarv> but this is actually a sensible thing to encode in types. The system of dimensions (or units) *is* a type system already, and it can be embedded into Haskell's type system.
09:29:39 <phadej> solonarv: can, but it can also be painful without compiler support. See uom-plugin paper
09:33:44 <dolio> 'Dimensional analysis' that physicists talk about is basically type checking.
09:33:56 <kuribas> solonarv: Squared and Cubed sounds ok to me.  How many dimension do you really need?  Besides, a lot more can go wrong in numerical calculations than wrong dimensions.
09:34:21 <blip> kuribas: up to ^5
09:34:28 <blip> isn't that uncommon in physics
09:34:33 <dolio> Maybe only physics professors.
09:35:04 <solonarv> even fractional exponents come up sometimes! although admittedly not often
09:35:10 <blip> dimensional analysis: don't do only profs, that's taught in schools
09:35:49 <solonarv> yeah, I was taught DA in high school. We even properly distinguished units from dimensions.
09:37:40 <blip> if my pupils don't do DA, I slap them with a Force of 5 kg :)
09:38:07 <blip> kuribas: so you would use a newtype for Newtons?
09:38:29 <kuribas> blip: possibly?
09:38:39 <blip> hm
09:38:44 <davean> blip: have you looked at 'dimensional', etc?
09:39:02 <blip> davean: yes, but I'm using that just as an example
09:39:07 <solonarv> @hackage units - the one I remembered first when this discussion came up
09:39:07 <lambdabot> https://hackage.haskell.org/package/units - the one I remembered first when this discussion came up
09:39:37 <blip> I'm more generally interested in representing more stuff ergonomically at type level
09:39:47 <blip> I'm a bit of a TL fan
09:40:10 <solonarv> type-level (negative) integers and fractions might be within the realm of what a GHC plugin can do
09:40:23 <kuribas> type level, ergonomic and haskell don't really go together
09:40:30 <kuribas> except for simple stuff
09:40:36 <blip> don't be that negative
09:40:44 <solonarv> there is some facility within GHC plugins to add new syntax if it can be cobbled together from existing syntax
09:40:46 <davean> I don't know why you'd use a plugin for it, you can just do it if you want
09:41:13 <davean> You have to lie and just claim laws, but thats easy
09:41:43 <kuribas> blip: I am not negative.  It's nice to have it, but most of it was an afterthought.
09:41:44 <blip> Well, kind-safety is overrated
09:41:51 <blip> yeah
09:42:02 <blip> But it's getting better over time
09:42:40 <kuribas> blip: actually, that's something I miss, well kinded type level computation.  For example servant is pretty ad-hoc.
09:43:23 <blip> I actually love servant, and think it's relatively non-ad-hoc for what it's doing.
09:43:53 <blip> that's a lot more ad-hoc: https://github.com/knupfer/type-of-html
09:44:46 <blip> considering that we've got Type :: Type, I think we've lost on the well kinded front
09:46:33 <dolio> I don't think that really follows.
09:50:49 * hackage Z-Data 0.1.7.1 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.7.1 (winterland)
09:51:49 * hackage subG 0.1.1.1 - Some extension to the Foldable and Monoid classes.  https://hackage.haskell.org/package/subG-0.1.1.1 (OleksandrZhabenko)
09:58:22 <nerdypepper> hiya, is there a shorter way to do this: https://pastebin.com/0XBjebVt ?
09:58:45 <davean> sure
09:58:49 <nerdypepper> there is no particular reason i want to shorten it however, just trying to scratch an itch
10:00:14 <lyxia> It looks good already to me.
10:00:58 <solonarv> I agree. There is no immediately obvious way to shorten it, which to me means I should leave it alone
10:01:11 <solonarv> (well, you save two characters with s/return/pure/ :p )
10:01:39 <siraben> `(some_computation val >>= another_computation) >> pure result`
10:01:53 <fryguybob> carbolymer: stm-container is based on the Hashed Array-Mapped Trie data structure and has internal TVar's.
10:01:55 <geekosaur> there's a way to shorten it but it's not obvious
10:02:20 <blip> siraben: wrong
10:02:35 <siraben> blip:  interesting, which part?
10:02:56 <blip> your `result` doesn't exist
10:02:57 <siraben> Oh oops
10:02:58 <siraben> missed the result
10:02:59 <siraben> lol
10:03:10 <siraben> then it's fine as is
10:03:24 <nerdypepper> lyxia, solonarv : fair enough, thanks
10:03:35 <blip> `f val >>= \r -> g f >> pure r`
10:03:54 <blip> `f val >>= \r -> g r >> pure r`
10:05:05 <carbolymer> fryguybob, thanks for the info, I think I've overlooked that
10:05:49 <carbolymer> EvanR, I just need a bit finer locking than on a whole Map level
10:05:50 <nerdypepper> blip: nice! 
10:06:00 <blip> `f val >>= uncurry (>>) . (g &&& pure)` ??
10:08:04 <blip> actually  `*>` is nicer than `>>`
10:08:12 <nerdypepper> blip: sweet, i was looking to do this somehow using arrow combinators, thanks a lot
10:08:20 <nerdypepper> blip: any reason *> is better than >> ?
10:08:34 <blip> it's usable in more cases
10:08:48 <blip> it's more honest
10:08:59 <blip> it's like using `pure` and not `return`
10:09:21 <nerdypepper> gotcha
10:09:33 <blip> and it's combinable with applicative do
10:10:58 <fryguybob> carbolymer: A non-STM, concurrent version of the HAMT is in the ctrie package.
10:12:19 <fryguybob> That one can have non-blocking snapshots, but I don't think the ctrie package implementes it.
10:12:29 <blip> proposal: let's deprecate mapM
10:12:39 <hekkaidekapus> dminuoso, tomjaguarpaw: Actionable input is required at <https://gitlab.haskell.org/ghc/ghc/-/issues/18836#note_307788>. After all, you’ll started it :) So, ”would you care to […] propose a paragraph or two that would have cleared it up for you?”
10:14:03 <hekkaidekapus> *you all
11:09:14 <hyperisco> still on the hunt for a templating solution that is just a library for parsing templates and evaluating them
11:09:27 <hyperisco> something not oddly conflated with JSON and CLI
11:11:51 <dsal> What kind of templates?  I'd expect there would be too many to choose from.  e.g. https://hackage.haskell.org/package/mustache
11:12:13 <fragamus> I'm having trouble constructing a Linear.V vector from a list   can anyone help
11:12:48 <larou> i was wondering about arrows and the support for various channels of communication over adaptive programs...  
11:13:48 <larou> fragamus: did you see; http://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector.html#g:7
11:14:29 <amf> in the 4 version approach (e.g. 0.1.2.3) what number would i bump if i were to add deriving Generic to one of the exported types?
11:14:54 <fragamus> looking now
11:15:16 <larou> probably you want; http://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector.html#g:36
11:16:00 <larou> amf: im not sure thats subjective?
11:18:11 <monochrom> amf: I think it's 0.1.2.3 -> 0.1.3.3.  But see eg https://pvp.haskell.org/#leaking-instances and later the "decision tree"
11:18:14 <davean> amf: 0 or 1
11:18:26 <davean> well, yahm depends on your feeling on leaked instances :)
11:18:57 <fragamus> larou: I am trying to construct a Linear.V V
11:19:19 <larou> thats just a newtype wrapper
11:19:29 <larou> so you would just dot with the newtype constructor
11:19:44 <larou> V . toList
11:19:59 <larou> does that work?
11:20:18 <amf> or... i could just let the lib maintainer handle it :)
11:20:28 <fragamus> sorry larou I am not understanding
11:21:02 <monochrom> Your case is not even an orphaned instance.
11:21:14 <fragamus> larou: are you saying I must first construct a Data.Vector Vector
11:21:24 <larou> erm, fromlist sorry
11:21:32 <larou> fromList :: [a] -> Vector a
11:21:38 <fragamus> ah
11:22:04 <larou> V :: Vector a -> V n a
11:22:14 <fragamus> ok
11:22:20 <larou> so; V . fromList :: [a] -> V n a
11:22:43 <fragamus> ok
11:22:52 <fragamus> ill give that a go thanks
11:23:09 <monochrom> amf: Ah, instead, https://pvp.haskell.org/#version-numbers point 2 is the applicable point. You are adding a non-orphan instance.
11:23:17 <larou> so, i was thinking, for "arrows for different coms channels within modifiable programs"
11:23:53 <larou> about the kind of picture there is in arrows docs, where a pair or an either can kind of have an "arrow going through a node"
11:24:10 <monochrom> and point 6 is saying "woe to your user if they added their own orphan Generic to your type" :)
11:24:29 <larou> like, maybe for most of the operation of the program types are just composed together in functions as usual
11:24:54 <larou> but then, there can be an option to like, generate a replacement for some function, and pass this through the program to where it replaces some node
11:25:25 <larou> so it would kind of have an Either, from if it was one or the other of these kinds of data being passed through the program
11:25:33 <larou> and a pair, to allow it to get to where it needs to go
11:26:04 <larou> im not sure what those opperations are called in arrows... but does that seem comprehensible?
11:27:13 <larou> i guess this ends up being quite complicated though. like, if one function can be modified by another, thats fine, since then this pathway can be "hard coded"
11:27:36 <larou> but if you need any part to be able to modify any other part, then it seems like some kind of crossroads would be needed
11:28:04 <larou> like signal boxes on train tracks, to direct the modification to where it needs to go 
11:28:18 <amf> monochrom: ah ok, that does make sense, thanks!
11:28:20 * hackage hslua 1.3.0 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.3.0 (tarleb)
11:28:46 <larou> it needs to be able to pass the data through the program along pathways that can be dynamically configured
11:29:26 <larou> kind of like in FPGAs where the logic units are connected together by programable switching paths, i forget what they are called, 
11:29:53 <larou> oh, they call it "programable routing" 
11:30:49 <larou> or "programable interconnections" 
11:31:01 <larou> they just have a 2d grid, so its quite simple
11:31:12 <hyperisco> dsal, mustache is oddly confused with both JSON and CLI
11:31:17 <larou> with just 4 wires and the switching block
11:31:20 <hyperisco> but those sorts of templates, yes
11:31:25 <dsal> It's just the first thing I thought of.
11:31:51 <hyperisco> not savvy on templating languages anymore
11:32:05 <dsal> My last web thing was in elm, which doesn't do templating language at all.  :/
11:32:18 <larou> "Each CLB is tied to a switch matrix to access the general routing structure. The switch matrix provides programmable multiplexers, which are used to select the signals in a given routing channel and thereby connect vertical and horizontal lines."
11:32:23 <larou> https://towardsdatascience.com/introduction-to-fpga-and-its-architecture-20a62c14421c
11:32:37 <larou> i was thinking something like this might be doable with arrows
11:32:51 <larou> but on an arbitrary architecture, not just a 2d grid
11:34:31 <larou> and obviously, with arbitrary types of data sent along the edges, not just the binary or floating point signals - since we have functions in a program instead of logic units, or configurable logic blocks, as in a FPGA 
11:34:34 <hyperisco> maybe I should just whip up my own with megaparsec lol, isn't that complicated oO
11:34:49 * hackage tasty-lua 0.2.3.1 - Write tests in Lua, integrate into tasty.  https://hackage.haskell.org/package/tasty-lua-0.2.3.1 (tarleb)
11:36:54 <monochrom> larou: The value of your messages to #haskell is decreasing rapidly. I ask you to stop.
11:38:19 * hackage hslua-module-text 0.3.0.1 - Lua module for text  https://hackage.haskell.org/package/hslua-module-text-0.3.0.1 (tarleb)
11:38:30 <larou> ah, your right, im getting distracted - sorry. it was just an afterthought to a discussion about the "fanout" operation yesterday 
11:38:50 <larou> i guess id be better off trying to grapple with the arrows framework in a less complex application
11:38:52 <hyperisco> why are all template processors dependent on Aeson lol
11:38:59 <tabaqui> hey all
11:39:12 <monochrom> aeson is our go-to JSON library.
11:40:19 <tabaqui> Do you know a good tutorial for recursion-schemes?
11:40:49 * hackage hslua-module-system 0.2.2.1 - Lua module wrapper around Haskell's System module.  https://hackage.haskell.org/package/hslua-module-system-0.2.2.1 (tarleb)
11:41:00 <phadej> tabaqui: there isn't
11:41:09 <monochrom> Yes IMO but my opinion includes only learning catamorphisms and anamorphisms, and ignoring the rest.
11:41:28 <phadej> that's not wrong :)
11:41:49 * hackage hakyll-process 0.0.2.0 - Hakyll compiler for arbitrary external processes.  https://hackage.haskell.org/package/hakyll-process-0.0.2.0 (jhmcstanton)
11:41:50 <tabaqui> well, -morphisms are pretty easy, but I'm interesting in Fi'ed  datatype
11:41:57 <tabaqui> *Fix'ed datatypes
11:42:04 <phadej> you don't need Fix for recursion schemes
11:42:36 <tabaqui> I want to combine them to build AST interpreter
11:42:58 <phadej> you don
11:42:59 <phadej> 't
11:43:06 <phadej> use concretely recursive types
11:43:15 <tabaqui> nah, it's boring:)
11:43:42 <monochrom> in which case something like http://www.cs.ox.ac.uk/publications/publication2360-abstract.html
11:43:53 <phadej> you get barely any mileage from recursion s chemes for an AST
11:44:06 <phadej> about everything interesting isn't just cata
11:44:43 <monochrom> and http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf
11:44:55 <tabaqui> monochrom: seems good, thanks
11:46:42 <monochrom> Gibbon's work with the Fix type IIRC. Jacob's is general math.
11:46:45 <tabaqui> phadej: why not, it looks very promising
11:47:11 <monochrom> But I certainly needed Jacob's to prepare me. It also teaches many other things.
11:49:02 <monochrom> And now, for "just one step away from cata/ana", I present to you http://www.cs.ox.ac.uk/ralf.hinze/publications/index.html#P32
11:50:33 <zincy__> What is/are Jacobs?
11:50:48 <monochrom> Paper author
11:51:09 <larou> "adjoint folds and unfolds" !?
11:51:13 <monochrom> I guess Jacobs's
11:51:16 <monochrom> Yeah
11:51:21 <tabaqui> monochrom: till now, I've only learned this: https://www.youtube.com/watch?v=TEvDaKg4XXA
11:51:55 <larou> if there is a way to make anything less appealing it is to add the word "adjoint" to it...
11:51:56 <geekosaur> "Jacobs'" if we're being pedantic. Except usage is still changing and not settled
11:52:05 <geekosaur> yay natural language
11:52:07 <zincy__> Can someone unpack this sentence "The distinction between algebra and coalgebra pervades CS .. described usually in terms of data versus machines?
11:52:15 <monochrom> Well mine was a simple typo.
11:52:37 <tabaqui> fun fact: haskell programmers don't laugh at function "anaL"
11:52:45 <monochrom> Don't attribute to rich linguistic studies what can be attributed to typos and ELS.
11:52:48 * hackage hslua-aeson 1.0.3.1 - Allow aeson data types to be used with lua.  https://hackage.haskell.org/package/hslua-aeson-1.0.3.1 (tarleb)
11:53:13 <monochrom> Like, as well, "Gibbon's work with Fix" should be "Gibbon's works with Fix", too.
11:53:14 <larou> zincy__ : its a nod towards folds and unfolds 
11:53:22 <larou> i think...
11:53:29 <monochrom> err and there I have a new typo of a spurrious space
11:53:32 <zincy__> Oh thanks
11:53:35 <larou> slightly confused about this being in terms of "algebras"
11:54:29 <monochrom> I have a feeling that future archaelogical linguistics in the 25th century looking at my IRC log and trying to theorize on my peculiar writing "style", any theory except honest typo.
11:55:25 <larou> hmm, actually, if "coalgegras" is going to include "things that dont have constructors" including *modifiers*, im not sure the fold vs unfold perspective isnt stretched beyond applicability 
11:55:42 <geekosaur> one hopes their corpus consists of a bit more than just your IRC messages :)
11:56:54 <geekosaur> (then again, if they've any sense at all they'll see English and give up :)
11:57:13 <monochrom> zincy__: Do you already know of "Let F be a functor. An F-algebra is defined as: ..."?
11:57:44 <monochrom> Err actually I have a more elementary way. Do you already know of both foldr and unfoldr for []?
11:58:32 <monochrom> foldr is a logical conclusion of "data [] a = [] | a : [] a" so it feels like data.
11:59:16 <monochrom> unfoldr is a little program that emits a list, it feels like a list-producing machine. You can even ascribe an "internal state" to it.
12:00:31 <larou> i get confused about list being CoFree
12:00:39 <zincy__> Yeah I only know about foldr and unfoldr
12:00:46 <larou> but its still "data" as opposed to "codata"
12:00:52 <larou> whatever that is...
12:01:27 <larou> list is both isnt it, both foldable and unfoldable...
12:01:29 <monochrom> > unfoldr (\s -> if s==10 then Nothing else Just (even s, s+1)) 0
12:01:32 <lambdabot>  [True,False,True,False,True,False,True,False,True,False]
12:02:29 <larou> and what about Free cf. Free Monads, for Free f, where f is a Functor
12:02:30 <monochrom> My example can be narrated as: I have an internal state, initially 0. If the state value hits 10, end; else, emit one more message "even s" and the next state is s+1.
12:02:50 <zincy__> So is this kinda like - machines produce data and unfoldr is our machine and lists are data?
12:03:01 <larou> (monoids in the category of endofunctors.... algebra?)
12:03:01 <monochrom> So I have a little automaton that has an internal state and emits messages accordingly for several steps.
12:03:09 <monochrom> Yes
12:03:13 <zincy__> Oh cool
12:03:27 <larou> :t build
12:03:28 <lambdabot> error:
12:03:28 <lambdabot>     • Variable not in scope: build
12:03:29 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
12:04:05 <larou> :t \f -> foldr f (:) []
12:04:07 <lambdabot> (a1 -> (a2 -> [a2] -> [a2]) -> a2 -> [a2] -> [a2]) -> a2 -> [a2] -> [a2]
12:04:25 <larou> oh no, i got that very wrong...
12:04:59 <larou> but like "unfold" isnt the machine... nor is the argument to it. its both the unfold and its argument, that produces the list
12:05:05 <larou> :t unfoldr
12:05:07 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:05:26 <larou> so i guess its just anything thats (b -> [a])
12:05:47 <larou> ah, i was thinking of Church encoding, not build
12:05:52 <larou> like, a partially applied fold
12:06:10 <larou> :t foldr undefined
12:06:12 <lambdabot> Foldable t => b -> t a -> b
12:06:29 <larou> oh, i guess it needs the initial data too...
12:06:34 <larou> :t foldr undefined undefined
12:06:35 <lambdabot> Foldable t => t a -> b
12:06:59 <monochrom> larou, you're being anal about "unfoldr is the machine".  Clearly, you could have also picked on "the State monad" --- there is no State monad, you always have to pick a type T and say "the State T monad".
12:06:59 <larou> which is dual to (b -> t a) from the partially applied unfold
12:07:57 <larou> well, just considering; f a -> b, and b -> f a, its clear one of them produces data and one of them consumes it
12:08:55 <larou> anyway, where does the "adjoint" enter?
12:09:03 <larou> its supposed to generalise over this right/
12:10:23 <monochrom> There is a URL, you could use it.
12:11:22 <monochrom> Like I said the value of your messages is dropping under 0.
12:11:35 <larou> nice summary 
12:12:43 <larou> can you explain though? i dont know enough theory to understand this paper...
12:13:15 <larou> some vague intuition to serve as a foundation to grasp at the abstract concepts?
12:13:43 <monochrom> Learn adjoint functors, then?
12:13:55 <larou> what are those for?
12:14:01 <monochrom> Adjunction itself takes a while to learn already.
12:14:09 <monochrom> For reading Hinze's paper?
12:14:14 <larou> ...
12:14:37 <monochrom> I certainly avoided learning adjunction until I found Hinze's paper. I learned adjunction for it.
12:14:57 <larou> ah, that must have given you the ability to explain it in less technical terms!
12:15:02 <monochrom> It's a good enough justification for me.
12:15:25 <monochrom> Do I owe you something?
12:16:23 <larou> its like Kan extensions, there is this commuting diagram
12:16:29 <larou> ok....
12:23:17 <larou> so we have datatypes as the fixed points of base functors...
12:24:39 <larou> F(uF) = uF
12:25:25 <larou> vF = F(vF)
12:25:40 <larou> those cant be equals signs, they must be some kind of arrow
12:26:03 <larou> thats like monoids in endofunctors by the looks of it
12:26:12 <larou> or comonoids... for the dual
12:27:20 * hackage silkscreen 0.0.0.3 - Prettyprinting transformers.  https://hackage.haskell.org/package/silkscreen-0.0.0.3 (robrix)
12:27:29 <larou> it says that in haskell, the inductive and coinductive data coincide, unlike Charity or Coq
12:28:30 <larou> (since we can pattern match on the constructor - foldables are unfoldables?)
12:30:41 <larou> it references this; https://www.cs.tufts.edu/~nr/cs257/archive/tim-sheard/two-level-unification.pdf
12:31:24 <larou> "The first of these is the definition of recursive
12:31:25 <larou> data types using two levels: a structure defining level, and
12:31:25 <larou> a recursive knot-tying level"
12:31:36 <larou> woop woop!
12:34:55 <larou> hmm, then it says something about termination. seems like folds need to terminate, so inductive data is finite - while unfolds are potentially infinite
12:35:06 <larou> i guess thats why we have lazy evaluation
12:37:15 <monochrom> Haha "class Pretty a" "Overloaded conversion to Doc." "Laws: 1. output should be pretty. :-)"
12:37:34 <dsal> *objectively*
12:39:32 <larou> argh! then it does trees as mutually recursive base functors as a categorical product
12:41:29 <larou> it says " Haskell has no concept of pairs on the type level, that is, no product
12:41:30 <larou>  kinds"
12:41:33 <larou> is that still true?
12:45:32 <monochrom> I forgot what it means, but in 2010 even GHC didn't have an interesting kind system.
12:48:27 <larou> well, the paper goes from mutually recursive datatypes as fixed points of pairs of base functors 
12:48:30 <dminuoso> hekkaidekapus: Cheers, yeah I noticed. Been pondering a bit about it
12:48:43 <larou> and then extends this to parametric recursive datatypes
12:49:04 <larou> anyway, i got to the point where it mentions adjunction
12:50:11 <larou> basiclly just says the fixed point definition for the base functor in the Monad vs Comonad style F-algebra, need to be adjoint to each other
12:50:30 <dminuoso> hekkaidekapus: My main issue is, we dont have any specification in the Haskell report to talk about what context in instance declarations means. And Im struggling at understanding at full depth the quoted Note.
12:50:49 <larou> something about a datatypes realisation being "unique" to a given fixed point induction/coinduction
12:51:49 * hackage little-logger 0.3.0 - Basic logging based on co-log  https://hackage.haskell.org/package/little-logger-0.3.0 (ejconlon)
12:54:07 <larou> rarg. then instead of having the datatype as the solution of the fixed point equation of the base functor
12:54:23 <larou> it does a pullback by the adjoint morphism (or something)
12:54:44 <larou> like, you use the unfold version of the base function, and the casting from that to the fold version
12:54:57 <larou> and *that* gives an "adjoint fold"
12:55:08 <larou> what a bizarre concept 
12:56:16 <larou> so you get "adjoint base functions" 
12:57:27 <larou> if i was going to say things that are almost wrong to explain, it would be something like "imagine if you tried to fold using the unfolding function, and that worked somehow, but you were doing this to define the datatypes"
12:57:57 <larou> almost not wrong*
12:58:34 <larou> apparently this is more expressive!?
12:58:56 <larou> like adjoint-folds "capture more" than regular folds...
13:00:03 <larou> he says they are at least as expressive since Id is dual to itself... 
13:00:11 <larou> *baffled* 
13:02:07 <larou> and then, apparently, the adjunction expressed by currying somehow leads to accumulator patterns!?
13:06:25 <larou> and then something to do with the adjunction with categorical product giving mutuomorphisms such as the paramorphism required for the basecase guard used in the definition of fac 
13:11:52 <larou> and then by adjunction with the type application for summing over parametric datatypes as an adjoint fold...
13:12:10 <larou> adjunction with the opperation of type application*
13:12:24 <larou> which is equally as peculiar 
13:15:07 <larou> and then finally concatination by the adjunction ebtween left and right kan extensions... just because...
13:15:28 <larou> what a waste of time
13:30:14 <johnw> who are you talking to, larou?
13:30:40 <geekosaur> they left. thankfully
13:31:01 <johnw> his speech sounds awfully similar to another user we banned about six montsh ago
13:49:28 <gentauro> johnw: who left?
13:51:23 <Uniaika> johnw: yeah I kinda noticed that
14:04:04 <monochrom> I'm waiting for one last straw to be an excuse to ban them. :)
14:04:17 <monochrom> Actually if some of you already want to ban now, I can do it.
14:04:49 * hackage buffet 0.5.0 - Assembles many Dockerfiles in one.  https://hackage.haskell.org/package/buffet-0.5.0 (evolutics)
14:10:28 <proofofme> which package do you guys use to convert a string of CSV to a list of elements?  I saw there are several
14:14:03 <monochrom> I use cassava
14:15:07 <monochrom> More honestly, there is some 10% of the easy case I just use Data.List.span/break and split at commas :)
14:16:40 <monochrom> But I escalate to cassava when I need it properly done, esp if there is something like 43591,"monochrom, inc."
14:17:05 <proofofme> thank you!  I will try Data.List.span/break!
14:25:06 <proofofme> hmmm. how does span translate the literal string to the list of elements?
14:25:25 <monochrom> It doesn't. It just splits on the first comma.
14:25:42 <monochrom> Actually even a bit less than that.
14:26:07 <monochrom> > break (',' ==) "abc,def,ghi"
14:26:09 <lambdabot>  ("abc",",def,ghi")
14:26:49 <monochrom> You add your own code to detect the leading comma in ",def..." and strip it
14:27:05 <monochrom> You also add your own recursion to continue.
14:27:36 <monochrom> You can steal code from "words" keeping in mind "words" splits on spaces.
14:28:03 <proofofme> hmmm I seee 
14:28:20 <proofofme> can this be foldr'ed?
14:28:30 <monochrom> and the fact that words "abc    def" = ["abc", "def"]  but you want something different for "abc,,,,,def"
14:28:50 * hackage postgres-websockets 0.10.0.0 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.10.0.0 (diogob)
14:28:57 <monochrom> No.
14:31:07 <monochrom> Maybe I should also let you know of http://hackage.haskell.org/package/split so you don't have to write your own recursion.
14:31:26 <monochrom> But here is my real consideration:
14:32:12 <monochrom> If you don't plan to worry about 43591,"monochrom, inc.", why incur a dependency? The recursion is just 3 lines.
14:32:49 <monochrom> If you do want to incur a dependency, why not incur the proper one?
14:33:29 <proofofme> so you WOULD use the split package for an easy case?
14:33:37 <monochrom> No.
14:34:33 <proofofme> the elements I want to split contain stuff like the 43591, "monochrom, inc."
14:34:46 <monochrom> Then use cassava
14:34:50 <proofofme> there are a lot of random chars, even ',' that will be in it.  ah ok
14:34:52 <proofofme> cool
14:41:57 <johnw> gentauro: I was thinking of 'fog'
14:42:48 <gentauro> johnw: ahh, fair nok
14:59:13 <dibblego> I use https://hackage.haskell.org/package/sv
15:02:34 <frdg> why would somebody search for functions on stackage instead of hoogle?
15:03:08 <monochrom> Is that a rhetorical question?
15:04:03 <frdg> no. I saw someone use it in a video. This is what I mean by stackage. https://www.stackage.org/
15:05:00 <monochrom> I don't use stack or stackage. But I think I understand that a stackage user would like to avoid getting search hits that hit outside stackage.
15:06:51 <frdg> alright. As always I am confused about what stack even is. I used stack for my project and I was able to use packages from everywhere.
15:06:55 <monochrom> I certainly do the parallel thing myself. When I'm looking for "getArgs" in the libraries I actually have, I'm not going to Google it worldwide.
15:08:07 <frdg> ohh stackage is like hackage.
15:08:31 <monochrom> stackage is a meticulously hand-checked subset of hackage.
15:09:11 <frdg> ok I see
15:09:31 <monochrom> and the subsetness is along at least 2 orthogonal axis at the same time.
15:11:43 <monochrom> I had a software engineering prof who explained how to achieve reproducible, consistent build of legacy software. Say for example you have pretty old but time-tested code, you just need to fix a small bug.
15:12:43 <monochrom> You may have to be so anal down to the point you have to keep around the old compiler version you used last time, the old OS you used last time, the old hardware you used last time.
15:13:24 <monochrom> stackage's purpose is doing that for library dependencies.
15:14:19 <pjb> Yes, you can try.
15:14:23 <frdg> ok that makes sense.
15:14:53 <pjb> But often you need to keep the old hardware too, and here is the problem. Hardware breaks.  Virtual machines bit-rot.
15:15:02 <pjb> It's a full-time job.
15:15:52 <monochrom> We do demand our governments and corporate overlords of "more jobs, and they have to be full-time jobs", no? :)
15:16:23 <dibblego> I use av sim software that only runs on windows-xp
15:16:54 <gentauro> 00:02 < frdg> why would somebody search for functions on stackage instead of hoogle?
15:17:07 <gentauro> frdg: I wouldn't. Hoogle is pretty fast and `stackage` not so much …
15:21:46 <johnw> I have an app that only works on xp too
15:22:29 <johnw> I have a VM where that app has been running for the last 20 years, only ever being suspended, never exited, because I wouldn't be able to restart it now
15:30:36 <dibblego> heh, yeah I use vbox for winxp — aviation is stuck in the 1960s
15:31:37 <hpc> sometimes it seems like it should stay there
15:36:01 <dibblego> today I have 4 flights totalling ~6 hours. It is going to be a 18 hour day
15:41:18 <monochrom> I once booked my flight from Munich to Toronto too late. The booking was very late, pretty last minute (OK, last week), it was also summer, so availability sucked. Therefore...
15:41:20 * hackage churros 0.1.3.0 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.3.0 (LyndonMaydwell)
15:42:30 <monochrom> it consisted of Munich -> London -> Halifax and St. John (no need to leave plane) -> Montreal -> Toronto
15:42:43 <monochrom> It spanned 24 hours.
15:43:35 <monochrom> (no need to leave plane between Halifax and St. John. I forgot which order.)
15:43:38 <dibblego> I am doing 4 flights today, in command, totalling 6 hours. Since aviation is stuck in the 1960s, I anticipate an additional 12 hours of error-prone, manual administration work
15:44:04 <hpc> oh wow, that kind of "have 4 flights"
15:44:42 <dibblego> I may have added that up incorrectly. Standby while I find my pen.
15:45:53 <int-e> . o O ( time flies )
15:45:56 <hpc> although, apparently newer gulfstreams are modern in a pretty nice way
15:46:17 <hpc> (source, https://www.code7700.com/ which has some pretty interesting blog posts)
15:47:48 <monochrom> I guess software project delays and flight delays have a lot in common.
15:48:19 * hackage webby 1.0.1 - A super-simple web server framework  https://hackage.haskell.org/package/webby-1.0.1 (AdityaManthramurthy)
15:48:22 <monochrom> Or "delays" because perhaps we simply always underestimate schedules.
15:48:46 <hpc> monochrom: you should read that link, it's shocking how much is the same
15:49:02 <dibblego> my first one is 0030Z-0200Z want to time it?
15:50:59 <dibblego> that website is very US-oriented and generalises inaccurately in places
15:51:19 <hpc> exactly like programming!
15:51:35 <dibblego> :)
15:52:59 <dibblego> better go
16:02:19 <justsomeguy> This is kind of a shot in the dark, but ... Where did the idea of pattern matching come from? I'm somewhat interested in what the original motivation was for creating the feature.
16:03:15 <justsomeguy> I guess I should probably start by looking searching for things related ML or CLU.
16:04:49 <monochrom> I know pretty little, but ML is the earliest I know of.
16:05:21 <dminuoso> justsomeguy: ALGOL 68 seems to be the earliest language that supports it
16:05:51 <monochrom> But did Algol 68 have algebraic data types?
16:05:54 <dminuoso> At least that's what a little bit of wiki warrioring reveals
16:06:01 <hpc> if it had a mathematical inspiration, it would probably be definition by parts
16:06:15 <dminuoso> monochrom: well you had union types, at least.
16:06:25 <monochrom> OK that counts.
16:06:38 <dolio> https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf
16:07:12 <dolio> Might be earlier than 66, too, though.
16:07:37 <justsomeguy> Funny; Half the time I ask where a PL feature originates from, it leads to Algol 68.
16:12:50 <dolio> Hah, the ISWIM paper is already using the phrase "purely functional" in 1966.
16:18:42 <ski> (Peano) recursive definition of operations on naturals is older
16:19:55 * ski . o O ( <https://plato.stanford.edu/entries/recursive-functions/> )
16:28:43 <earldouglas> Is there a way to pattern match on a newtype constructor that's in a hidden module?
16:29:44 <hpc> somehow or another, the data constructor needs to be in scope in order to match on it
16:30:43 <L29Ah> earldouglas: can't you coerce instead?
16:36:13 <monochrom> "This instance is only usable if the constructor MkNT is in scope."
16:38:12 <earldouglas> L29Ah: Do you mean `Data.Coerce (coerce)`?  I'm not sure how to use that.
16:38:30 <monochrom> Yes. And unusable as said.
16:40:49 <earldouglas> monochrom: Ah, I see that now.  Yeah, coerce fails with "The data constructor ... of newtype ... is not in scope"
16:42:00 <earldouglas> I'm probably doing something wrong, but this feels like a bug.  Is it even possible to use requestAccept?  https://hackage.haskell.org/package/cgi-3001.5.0.0/docs/Network-CGI.html#v:requestAccept
16:42:24 <earldouglas> I can't import Accept, which is hidden in Network.CGI.Accept, then re-exprted in Network.CGI
16:46:09 <monochrom> Use negotiate?
16:49:51 <earldouglas> That should work.  Thanks!
16:58:48 <larou> do constraints in smart constructors work at type level?
17:10:19 * hackage minio-hs 1.5.3 - A MinIO Haskell Library for Amazon S3 compatible cloudstorage.  https://hackage.haskell.org/package/minio-hs-1.5.3 (AdityaManthramurthy)
17:15:33 <larou> hmm, it seems like it works!
17:15:41 <larou> thats quite interesting
17:15:49 <larou> i didnt think constraints at type level would work
17:15:59 <larou> but apparently this is a workaround! woop!
17:16:18 <larou> https://pastebin.com/raw/R1YH9J7e
17:16:42 <larou> so apparently, you can provide constraints at type level using smart constructors
17:17:21 <larou> this gives the "place in syntax" where the constraint goes, since it would be an error if it appeared in a kind... 
17:17:39 <larou> i think... unless some recent extension like standalone kind signatures enables this
17:17:50 <larou> anyone know if it does?
17:20:52 <halogenandtoast> If I have an instance like this deriving anyclass instance (IsInvestigator investigator) => HasModifiersFor env investigator Asset is there anyway to have another instance with a different constraint?
17:21:22 <halogenandtoast> Just changing the constraint will give a duplicate instance error.
17:33:59 <larou> halogenandtoast: would it be possible to provide an extra parameter that could "label" these instances?
17:34:45 <larou> your essentially trying to match on constraints
17:45:27 <halogenandtoast> larou: ooh interesting, the answer is assuredly yes, I could
17:45:53 <larou> i think thats the best way to do that
17:47:17 <halogenandtoast> larou: thanks, I may try that if my current route (just removing the polymorphism) doesn't work out for me.
17:48:10 <larou> if you do, you can create a sum datatype with constructors that dont take arguments (like Bool)
17:48:31 <larou> with one of each of these "labels" to disambiguate the instances
17:58:54 <monochrom> Today I begin to learn the Yoneda lemma. Interesting.
18:00:18 <monochrom> It currently feels like setting up a lot of machinery to conclude very little. But I haven't applied it to really interesting things.
18:01:51 <monochrom> (Namely, I have only tried applying it to forgetful functors. Yeah I know, lame, heh.)
18:02:15 <koz_> monochrom: Or, should we say, _forgettable_? :P
18:03:09 <monochrom> Unfortunately forgetful functors are needed to define "free", so one must not forget them.
18:03:35 <EvanR> category theory: a lot of machinery to conclude very little
18:04:55 <monochrom> I think it feels limiting because Yoneda lemma's premise is "you can pick your category C, but you must pick a functor F from C to Set".  The "to Set" part is a bit disappointing. It's why I could only thought up forgetful functors for now.
18:05:02 <dolio> There are probably dozens of examples where some discipline has a 'cool theorem' that is the Yoneda lemma applied to a relevant category.
18:05:45 <monochrom> However! I see that if F is a homset functor, you can get some really useful theorems.
18:06:53 <dolio> It doesn't have to be Set. The reason Set is special is because all ordinary categories are constructed out of sets.
18:07:15 <dolio> When you do V-enriched category theory, then V is special instead.
18:08:58 <dolio> Or specifically, it's because categories have hom-sets.
18:11:01 <monochrom> For example, let G be an endofunctor so you can talk about G-algebras. (No further restriction on G.) Then Yoneda's lemma gives you the natural isomorphism between algebras GA->A and polymorphic functions "forall t. (t->A) -> (G t -> A)"
18:13:09 <monochrom> I learned this today when I read again the Hinze paper I mentioned earlier today. Hinze gave a proof specific to that statement about GA->A, but he also mentioned how to use the Yoneda lemma on a suitable homset functor to get the same conclusion in two steps.
18:21:42 <dolio> For instance, if you consider proposition 'enriched' categories where every arrow has an inverse, then C -> Prop is special instead; predicates on C.
18:23:17 <dolio> Then the Yoneda lemma says that P(x) ≃ (x ≃ y) → P(y), so it's telling you about Leibniz' notion of equality.
18:33:47 <larou> dolio: how do you read that line in spoken words?
18:45:47 <sshine> Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn
18:46:02 <koz_> sshine: I see you too have found Nyarlathotep, our lord and saviour.
18:53:20 <clmg> How can I add a heading to the bibliography section of my Hakyll blog? I'm generating it this way: https://pastebin.com/6L58eAPU
19:25:47 <ddellacosta> can anyone help me understand the definition for forever? It's hurting my brain
19:25:49 <ddellacosta> forever a   = let a' = a *> a' in a'
19:26:05 <koz_> :t forever
19:26:07 <lambdabot> Applicative f => f a -> f b
19:26:18 <koz_> The key is that forever doesn't actually return a value at any point.
19:26:19 <ghoulguy> ddellacosta: Is something about it confusing in particular?
19:26:23 <koz_> It just repeats the effect over and over.
19:26:32 <c_wraith> ddellacosta: would you be comfortable with the definition  forever a = a *> forever a   ?
19:26:39 <ddellacosta> ghoulguy: I think I'm having trouble understanding the order of evaluation
19:26:53 <ddellacosta> koz_: yeah that's what's hurting my brain lol
19:27:04 <ddellacosta> c_wraith: processing
19:27:25 <ddellacosta> c_wraith: okay yes actually now I see the order
19:27:42 <ddellacosta> so it just executes a's effect and calls itself again
19:27:55 <c_wraith> ok.  the definition you quoted does the same thing, but with a knot-tying trick in order to reduce potential overhead
19:28:10 <monochrom> "forever" is most useful if you use it for IO and go something like "forever (putStrLn "Your PC is stoned")"
19:28:41 <ddellacosta> c_wraith: okay! I get it! Thank you so much
19:28:55 <monochrom> It is clearly useless if you try "forever Nothing" or "forever (Just 4)"
19:28:59 <c_wraith> you're welcome
19:29:26 <ddellacosta> monochrom: yeah, actually I have used it a bunch but all of a sudden realized I didn't know how it was defined, so then I went to take a look and got confused 
19:30:16 <c_wraith> > forever Nothing
19:30:18 <lambdabot>  Nothing
19:30:24 <c_wraith> that hardly took forever at all!
19:30:25 <monochrom> So now you're ready for "fix f = let x = f x in x", too. TEE HEE HEE
19:30:35 <iqubic> > forever (Just 4)
19:30:38 <lambdabot>  *Exception: <<loop>>
19:31:08 <ddellacosta> monochrom: you're making me remember when I spent a week learning recursion schemes, and I have mostly forgetten them at this point
19:31:10 <iqubic> Oh, that's just "Just (Just (Just (Just (Just (Just ...)))))" With a 4 at the bottom of the infinite stack.
19:31:11 <ddellacosta> forgotten
19:31:24 <ddellacosta> _sigh_
19:31:30 <c_wraith> iqubic: actually it isn't.
19:31:37 <ddellacosta> I need to figure out how to retain all the haskell I've forgotten
19:31:40 <iqubic> Oh? How come?
19:31:54 <c_wraith> iqubic: it's Just 4 *> (Just 4 *> (Just 4 *> ...
19:31:57 <monochrom> Age of Empires Infinity: The Forgotton Recursions: Definitive Edition
19:32:14 <c_wraith> iqubic: Just 4 *> Just 3
19:32:23 <iqubic> Right, but what does (*>) do for Maybe?
19:32:27 <larou> % Just 4 *> Just 3
19:32:28 <yahb> larou: Just 3
19:32:29 <c_wraith> > Just 4 *> Just 3
19:32:32 <lambdabot>  Just 3
19:32:55 <c_wraith> :t (*>)
19:32:55 <iqubic> @src (*>)
19:32:55 <lambdabot> (*>) = liftA2 (const id)
19:32:56 <lambdabot> Applicative f => f a -> f b -> f b
19:33:18 <c_wraith> Notably, it doesn't add a layer of f
19:33:21 <ddellacosta> monochrom: that definitely sounds like a game that would suck up a lot of time
19:33:31 <iqubic> I'm so confused by that definition?
19:33:32 <monochrom> It took me about 3 re-learnings to retain catamorphisms, so don't worry.
19:34:07 <larou> oh, i had a fun thing
19:34:11 <monochrom> But buy one get one free, retaining catamorphisms implies retaining anamorphisms.
19:34:31 <monochrom> After that, I simply declared that the rest of recursion schemes are not worth my time.
19:34:39 <larou> a list of maybe Int, where the Int points to the location of another Int somewhere else in the list
19:34:50 <larou> and you have to constrain it so the ints "point to each other"
19:35:04 <monochrom> Instead, Ralf Hinze's "adjoint folds and unfolds" are actually elegant and not ad hoc.
19:35:13 <c_wraith> iqubic: fa *> fb = (\_ y -> y) <$> fa <*> fb  -- is this more comfortable of a definition?
19:35:19 <ddellacosta> I mean, I think folds are really cool and fundamental and I love how it like turns them inside out
19:35:30 <ddellacosta> monochrom: oh, I'll check it out, thanks
19:35:48 <iqubic> :t const
19:35:49 <lambdabot> a -> b -> a
19:36:23 <iqubic> Wait a minute...? Isn't "const id" just the same as "flip const"
19:36:30 <ddellacosta> haha "Or: Scything Through the Thicket of Morphisms"
19:37:21 <iqubic> If my last statement is true, then I fully understand how "liftA2 (const id)" works.
19:38:16 <iqubic> Wait... no, not really. Where does the loop get introduced? What causes the infinite recursion there.
19:38:50 <c_wraith> which "there" do you mean?
19:39:52 <iqubic> "liftA2 (const id)" creates what is the equivalent of an infinite loop. How does that function introduce infinite recursion?
19:40:14 <c_wraith> I think you've mixed things up.  (*>) doesn't introduce recursion, forever does
19:40:31 <iqubic> Oh. I see.
19:41:00 <iqubic> "liftA2 (const id)" is the default implementation of (*>). That clears things up.
19:41:28 <iqubic> Now, does "const id" do the same thing as "flip const"?
19:41:34 <iqubic> :t const id
19:41:35 <lambdabot> b -> a -> a
19:41:40 <iqubic> :t flip const
19:41:42 <lambdabot> b -> c -> c
19:43:53 <iqubic> From those very generic and unconstrained type signatures being the same, I conclude that they two different implementations of the same function.
19:44:03 <sshine> :t liftA2 (const id)
19:44:05 <lambdabot> Applicative f => f b -> f c -> f c
19:44:20 <sshine> :t liftA2 (\a b -> b)
19:44:21 <lambdabot> Applicative f => f a -> f c -> f c
19:44:44 <sshine> :t (*>)
19:44:45 <lambdabot> Applicative f => f a -> f b -> f b
19:45:04 <iqubic> :t liftA2 (flip const)
19:45:05 <lambdabot> Applicative f => f b -> f c -> f c
19:56:01 <sshine> const id  =  (\b c -> b) (\a -> a)  =  (\c -> (\a -> a))  =  (\c a -> a)
19:56:21 <sshine> flip const  =  (\f y x -> f x y) (\b c -> b)  =  (\y x -> (\b c -> b) x y)  =  (\y x -> x)
20:00:55 <crestfallen> hi re: lines 27-28, are c and d equivalent because of referential transparency? (If they are equivalent, they must return the same (b -> a) , correct?
20:00:59 <crestfallen> https://github.com/varreli/haskell/blob/master/handEval/unify_f_g_h.txt
20:01:18 <fragamus> howdy
20:02:28 <iqubic> If c and d truely are the same, then you've got a function of the type c -> c, which can only be id.
20:03:58 <iqubic> So, yeah, if can prove that c and d are the same type, then you've also proven that g is id.
20:07:45 <crestfallen> iqubic so you would back track, by saying both g's were (c -> c)    By backtracking I mean naming them both c .. and then substituting (b -> c) for the id on line 28?
20:11:29 <crestfallen> iqubic: I mean, if you have c -> (b -> a) and c ~ d, then by the idea of referential transparency, both g's must return (b -> a)
20:15:11 <koz_> fragamus: Yo.
20:18:42 <crestfallen> iqubic: thanks only now saw your post at 20:03:58
21:28:26 <gnumonik> Hello. I am trying to write an interpreted DSL that "compiles" to Haskell (i.e. parses to haskell expressions). I would like to implement composable record accessors/setters in the DSL, so I've been trying to marshal strings into Setters/Getters from Control.Lens. I've been at it a month and there seems to be no way to get it to work (without impredicative polymorphism...) Has anyone ever tried to successfully do something like 
21:28:26 <gnumonik> this? 
21:30:09 <larou> where do you encounter impredictive polymorphism?
21:39:14 <koz_> larou: When you try to combine . with runST, for example.
21:39:37 <koz_> With lenses, there's a nested forall in the representation.
21:39:59 <larou> can you write that down?
21:40:00 <koz_> That's why (I think) we have Lens and ALens.
21:40:30 <koz_> larou: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
21:40:31 <larou> how does that fit in with the question about the DSL?
21:40:38 <koz_> Now try passing that as an argument.
21:40:47 <koz_> You hit impredicativity issues _very_ fast.
21:40:53 <larou> ah, ok
21:41:20 <larou> isnt there the option of using a different representation of lenses?
21:42:10 <koz_> larou: If by 'different' you mean 'profunctor optics', then I think the issue remains, though I'm not sure.
21:42:16 <larou> i thought you could exhaustively enumerate Traversables
21:42:24 <koz_> larou: What does that even _mean_?
21:42:47 <koz_> (also, probbo not, since we have type Lens s t a b = forall p. Strong p => Optic p s t a b)
21:43:02 <larou> isnt there soemthing halfway towards the lenses setup?
21:43:29 <larou> that instead of abstracting over Traversals, just systematically represents them?
21:43:55 <larou> im not sure if that would solve the issue
21:44:21 <koz_> larou: The specifics of the question don't mention Traversals.
21:44:50 <larou> i cant quite remember how it goes, but it was something to do with biplate
21:45:24 <larou> i think you can do all the lens stuff when you have arbitrary Traversal instances
21:45:26 <koz_> larou: You'd have to give me a more specific reference, because nothing like this comes to mind, and I don't think I get it in the abstract.
21:45:39 <koz_> Traversal? Or Traversable?
21:45:58 <larou> you avoid Traversal, but enumerating instances of Traversable
21:46:18 <larou> this gives you the modifiers and insertion/deletion operations
21:46:30 <koz_> Yeah, I'm not sure I follow. 'Enumerating instances of Traversable' doesn't make much sense to me.
21:46:45 <larou> i just approach it in terms of Get & Set instances
21:46:56 <larou> with abstractions to account for "structure"
21:47:23 <larou> i think these can basically be formulated into monadic Get/Set varients
21:47:40 <larou> where the monad is sufficient to capture structure information
21:48:02 <larou> if its true, that everything Traversable is...
21:48:11 <larou> oh no, wait, then you get scanners
21:48:23 <larou> because you cant do monadic traversal properly 
21:48:47 <larou> i think geti&seti get there for the pure varients 
21:49:06 <larou> but the nested states are difficult
21:49:13 <larou> for the unfolding therof
21:49:39 <larou> like, imagine trying to unfold a list of lists, you need a depth 2 nested state for the unfold
21:50:08 <larou> and if your trying to capture all possible Traversal instance, you need a systematic framework for the nested States and Costates
21:50:18 <larou> for the unfolds and folds respectively 
21:50:25 <MarcelineVQ> bleep borp
21:50:33 <larou> so the geti&seti setup isnt quite suffiencet 
21:52:15 <gnumonik> The problem (as far as I can tell) is that in order to cross the bridge from string land to lens land in a way that lets you compose, you a function with a type like :: forall a c. (forall b. Lens' a b -> c) -> String -> c. I think anyway. This is my first real haskell program so I might  be wrong 
21:52:20 <larou> idk if it solves your impredictive polymorphism problem...
21:52:29 <gnumonik> And that's an impossible function 
21:53:06 <larou> seems like an ambitious first program! 
21:53:29 <larou> i cant really follow sorry, idk lenses, but thanks for explaining 
21:54:03 <larou> i have never really seen anything that enamoured me towards them - let alone the documentation! 
21:55:04 <gnumonik> I wrote the rest of it on the assumption that there'd be some easy way to parse strings into lenses... I don't want to give up but right now my best idea for how to make it work is "rewrite the whole thing in clojure" 
21:56:00 <larou> does that have impredictive polymorphism?
21:56:29 <gnumonik> No but I'm pretty sure I could make this work in an impure dynamic language 
21:56:55 <larou> hmm, intersting. 
21:57:18 <gnumonik> It's either that, or write a type system capable of supporting profunctor optics for a dsl that is (aside from the record accessing stuff) about as a complicated as a calculator 
21:58:23 <larou> ah, your making me wish i knew what you mean 
21:58:36 <larou> the siren song of lenses! 
21:59:28 <larou> i thought your whole problem was writing DSLs in the first place!
21:59:32 <larou> seems like a catch 22
22:01:27 <gnumonik> Well I read that haskell was a good language for embedding a dsl and was like "oh this will be a good first project", but that is apparently only true if you want to use the features of haskell that don't involve higher rank types. Which is kinda disappointing I guess. 
22:02:24 <larou> im still not convinced that its inexpressible in this language 
22:03:01 <larou> either your lens problem is totally profound, or its just a limitation of trying to use that machinery 
22:03:27 <larou> can you tell if its a revelation or a limitation of lenses?
22:06:49 <gnumonik> as far as i can tell it's a limit of the type system. I mean there is a way to make it work. Actually, there are 2 ways: One is to package the program with Hint (makes the binary 10x as large and isn't suitable for my application cuz it needs to be run as root), and use that as a 100mb parser for the lenses. The other is to write a super rich type system for what amounts to a calculator. I'm probably not smart enough to do the 
22:06:49 <gnumonik> latter :-( 
22:07:50 <davean> gnumonik: do you mean the 'hint' package?
22:08:46 <gnumonik> yeah
22:08:52 <davean> ... why would you run that as root?
22:09:30 <gnumonik> You wouldn't. But my DSL is for packet capturing, so you need superuser, so although hint solves the "parse some lenses" problem, it's not suitable
22:09:40 <davean> No you don't?
22:09:45 <davean> You can packet capture without root
22:09:53 <davean> thats what capabilities are for
22:10:52 <davean> Also, lenses have composition rules
22:10:58 <davean> so if you just map strings to the lens objects
22:11:07 <davean> and combine them with the operators, you don't need to use something like 'hint'
22:11:17 <davean> Haskell is a functional language
22:13:06 <gnumonik> Yeah you can write a function from "foo" to foo (where foo without quotes is a lens), but as far as I can tell you can't write a function from a string to any given lens for a data type
22:13:42 <davean> No, you have to enumerate the lenses that exist 
22:13:42 <dsal> You should also be able to test packet capture mechanisms offline.
22:13:52 <davean> yes, thats what tcpdump helps with
22:13:57 <davean> or libpcap
22:14:04 <larou> ah, its to do with matching on record accessor names
22:14:07 <davean> But you can capture online without root
22:14:25 <larou> all my datatypes are just like HLists or whatever
22:14:27 <davean> gnumonik: you can code-gen the tables of names to lenses also
22:14:44 <larou> so you have "positional" data other than "record names"
22:15:02 <larou> i guess thats actually a pretty serious limitation for most practical uses
22:15:05 <larou> damn...
22:15:07 <gnumonik> You can kind of use type classes and higher rank types to pass another function to the String -> Lens function, but to get composition I'm pretty sure you need something like, (again) forall a c. (forall b. Lens' a b -> c) -> String -> c. If I'm wrong about that let me know but I can't think of anything 
22:16:00 <larou> wait, isnt that what the template haskell machinery for autoderiving lesnes is for?
22:16:06 <gnumonik> And yeah I know about capabilities and was glossing over that, but anyway there has to be something better than lugging around most of GHCI to parse...record selectors
22:16:40 <davean> I'm confused why you're talking about doing the lenses the way you are - can you restate the problem? Because that signature doesn't make sense for what I understand you want
22:17:00 <larou> well, i was doing it for scientific computations, where "locality" on a manifold is basically the end goal
22:17:07 <dsal> If you're using lens for "record selectors" then that might be the wrong tool for the job, especially if the job is an interactive runtime that behaves like haskell, but isn't haskell.
22:17:07 <larou> you just have structured access paterns
22:17:37 <larou> all the data is selected relative to some position, so all this string names stuff just never arises
22:18:17 <larou> trying to enumerate all the different names would just be totally pointless!
22:18:35 <gnumonik> Well they're not actually just record selectors, and technically I need prisms too so talking about lenses is a bit wrong (is the general term for lens-ey things 'optics'?). Lemme try to restate the problem, gimme a min
22:18:53 <larou> i guess i quotient away all the isomorphisms by record renaming as an equivalence class
22:19:12 <davean> Yah, optics
22:19:38 <larou> so isnt it just about the "shape" at the end of the day?
22:21:07 <larou> and then the logis is something like, lists are good. and then you Fix them and hopefully get graphs at some point
22:21:26 <larou> again, something to do with isomorphisms 
22:22:00 <larou> and then with type hetroginaity you get the most general structure thats isomorphic to everything else
22:22:17 <larou> ah, that was the problem, the nested states were unfolding type hetroginous things
22:22:25 <larou> horror 
22:23:45 <larou> i guess thats the point about product base functors 
22:24:02 <gnumonik> So I have a DSL. Just for elaboration, the DSL is some pretty simple syntactical sugar over Edward KMett's "Machines" library, and the point is to allow for generation/modification/performing side effects with streams of network packets. I wrote the DSL on the assumption that there'd be some way to translate strings into optics in such a way that, if, e.g., _Foo is a prism and bar is a lens, you could type "Foo . bar" in the dsl 
22:24:02 <gnumonik> to access the bar field of a product type inside a sum type "Foo." But.. I can't figure out how to go from string to the optics in a way that lets them compose. 
22:24:24 <gnumonik> Again this is my first real haskell program ever, so I dunno if that was a horrid idea or if there's some obviously better approach 
22:24:59 <davean> mmm, I see
22:25:22 <larou> wait, i thought lenses composed good
22:25:45 <davean> larou: he needs to match the type, but he's at runtime, so he has to prove he only composes correct ones ever
22:25:53 <davean> Which is doable
22:25:54 <gnumonik> they do. as a *library* everything would work fine. but i wanted this to be used by people who won't install ghc
22:26:06 <gnumonik> er usable at least 
22:26:17 <larou> whaaaat!?
22:26:23 <bifunc2> Can an integration test be done within an HUnit testCase, or are there more usual ways to do integration tests?
22:26:24 <davean> A) Thats not what lenses are for, B) I can see how to do it, but I'm not sure how much you'd like it
22:26:26 <larou> why throw away the compiler!?
22:26:46 <davean> gnumonik: You'd want a Map for every starting type, and return the result type with it
22:27:00 <larou> i thought DSLs were supposed to *leverage* the typechecker into their own type systems
22:27:01 <davean> it'll compose, you can fold them together
22:27:12 <davean> larou: depends on how deeply embeded they are, for example
22:27:33 <larou> hmmm
22:27:54 <larou> like, if they are supposed to do something the haskell typesystem cant?
22:28:36 <davean> I mean thats exactly one case
22:28:36 <gnumonik> Wait a Data.Map map? I'm a little confused on how that would work if the data types don't contain fields of all the same type. (Do heteogenous maps exist?) I might not be understanding you 
22:28:53 <larou> in which case wouldnt it be better to compile it to a subset of haskell that *is* expressive enough?
22:29:26 <gnumonik> Yeah, I was a little ambitious in thinking that "Oh hey lenses are really neat, lemme throw them in my DSL as expressions". Or I didn't know enough to know that that wasn't a good idea 
22:29:44 <larou> not really sure how Map is implemented tbh... can you emulate it using list?
22:29:55 <davean> gnumonik: You can make them hetrogenious, or dependent. I was suggesting sometihng like (data OpticMap s = OMap (Map String (forall r . (Optic s r, r)))
22:30:33 <larou> and that impredictive right?
22:30:41 <larou> thats*
22:30:52 <davean> gnumonik: if you store the tag, you can look up the correct map next time ... etc
22:31:06 <davean> gnumonik: it'll get ugly, but you can make it work. I'm not sure you want to.
22:31:21 <larou> is the issue that a HList with a pair with an accessor index would be slow to lookup?
22:31:40 <davean> gnumonik: to be clear, I hate this approach
22:31:42 <gnumonik> I've been trying to solve this problem for a month out of sheer anger that I couldn't do it, I don't really care if it's ugly at this point :p
22:31:46 <larou> i mean, maybe you could use some kind of tree based thing thats faster..
22:32:04 <davean> I'm pretty sure it'll work
22:32:46 <larou> i cant tell if vinyl would be helpful...
22:33:49 <larou> runtime typechecking sounds off though... never seen that 
22:33:53 <davean> you know the result type because you get a token and look up the next in the map that starts with that by having a top level map like Map 'r (forall s . Map String (forall r . (Optic s r, r)) 
22:34:20 <davean> So your'e chaining through the connecting type
22:34:23 <davean> but ugh
22:34:27 <davean> Its *basicly* a type checker
22:34:54 <davean> Just linear chaining
22:35:16 <davean> er
22:35:22 <larou> what about parallel? 
22:35:25 <davean> I mixed up an r and s above
22:35:29 <larou> like zipwith
22:35:32 <gnumonik> ohhhh I see now. That might work. That might not even be that bad. I have some template haskell that generates type for a data type and its subtypes (I know they aren't real subtypes, components I guess) until it reaches a "primitive" type (relative to the DSL)
22:35:39 <gnumonik> that I could probably use 
22:35:46 <larou> im sure some mix of those two should be arbitrarily expressive
22:36:13 <larou> hmm, maybe its the difference between successive flat layers and a lattice like partial order for an arbitrary graph
22:36:28 <larou> the good thing about layers is they are obviously ordered 
22:36:35 <davean> gnumonik: At least I gave you something to consider.
22:37:15 <zoran119> is anyone using vscode + haskell-language-server (with haskell.haskell plugin in vscode)? got to definition should work there, right? it doesn't seem to be able to find definition of my modules in other source files (only current source file)...
22:37:38 <larou> i really wanted something that could represent modern computing architectures so you could compile to bitcode for the virtual version and run it on regular hardware 
22:37:46 <gnumonik> I appreciate it! I've been smashing my face against this for so long that any way of making it work is relieving
22:38:18 <larou> its the realisation thats the obstacle 
22:38:58 <gnumonik> Though, actually, running into this problem made me dive deep into TH/Generics.SOP and really figure out the lens library at some depth, so I suppose it was a good problem to run into.
22:39:10 <larou> something about emulating concurrency 
22:39:23 <gnumonik> None of those helped me solve it but oh well :p
22:39:45 <davean> gnumonik: I know how that feels. I do think you more want like a query engine but ... Hey, I'm not here to tell you what to code, just answer questions :)
22:40:00 <davean> A good problem is very educational
22:40:57 <larou> modifiable programs represented as scanner nets, anybody? 
22:41:30 <larou> with structured access for implementation on virtual FPGAs...
22:41:33 <larou> *sigh*
22:41:59 <larou> autodeploys to skynet...
22:43:05 <larou> implements nets based on virtual market signal processing. subsumes the finance sector, brings about the rapture...
22:43:23 <larou> now with 50% more functions! free!
22:43:28 <davean> gnumonik: Also, if you don't like capabilities, sudo tcpdump and pipe that into your program? Or drop privileges
22:44:33 <justsomeguy> zoran119: I tried it out just now on a stack project, and it gave a warning message about some config file called hie.yaml. Maybe that file needs to be populated so hie can find stuff.
22:44:58 <justsomeguy> https://github.com/mpickering/hie-bios#hie-bios
22:47:25 <zoran119> justsomeguy: thanks for trying it out, i just found this (seems like a new issue): https://github.com/haskell/haskell-language-server/issues/486
23:30:49 <proofofme> can cassava be used for csv parsing without a filepath?  like can you just give it a string and it yields a list of elements instead?
23:32:10 <c_wraith> that...  sure seems like what decode does
23:32:26 <koz_> http://hackage.haskell.org/package/cassava-0.5.2.0/docs/Data-Csv.html#v:decode
23:32:36 <koz_> Well, aside from it being given a ByteString.
23:37:00 <proofofme> how to convert something like "a,b,c" to a bytestring?
23:42:27 <dsal> proofofme: One way is to have it always be a bytestring so you don't have to convert it.
23:42:42 <proofofme> it's being read from a database where it comes that way
23:43:03 <dsal> The database doesn't return a ByteString?  It probably has one.
23:43:32 <dsal> What database interface is this?
23:43:49 <proofofme> mysql
23:44:08 <dsal> AFAIK, that's not an interfae.
23:44:43 <dsal> I guess there is one named that.  It looks fairly old, though.
23:45:01 <proofofme> Database.MySQL.Base
23:46:29 <dsal> Ah, stackage has docs.  It says it returns ByteString.  How did you convert it from ByteString?  Maybe do the opposite of that.  :)
