00:00:00 <hololeap> it seems like it would, with my brain's limited computing power
00:18:00 <dminuoso> 09:02:56   hololeap | [06:32:15] it's interesting to me that not all Profunctors are Categories, which means some Profunctors don't compose, i would assume
00:18:18 <dminuoso> Hi, out of curiosities, are not all profunctors composable via coends in bicategories?
00:23:46 <random> hey guys, does anyone know if you can generate a "create table" command with persistent
00:23:56 <random> I know it's doable because the automatic migrations do it but I can't seem to find a way
01:41:19 * hackage uniqueness-periods-vector-common 0.5.0.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.5.0.0 (OleksandrZhabenko)
01:51:19 * hackage uniqueness-periods-vector-general 0.5.0.0 - Some kind of the optimization approach to data inner structure.  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.5.0.0 (OleksandrZhabenko)
01:58:20 * hackage uniqueness-periods-vector-properties 0.5.0.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.5.0.0 (OleksandrZhabenko)
02:11:35 <xwvvvvwx> Hi, so I want to generate strings in quickcheck that never repeat themselves. I'm fuzzing a parser, and I need unique random names for identifiers. 
02:11:40 <xwvvvvwx> Does anyone have any tips?
02:13:07 <Taneb> xwvvvvwx: can you use the arbitrary instance for Set? I think that would work if you only need a small number of names
02:15:23 <xwvvvvwx> ohhhhhh clever
02:15:49 <xwvvvvwx> and then pull a random element from the set?
02:18:39 <xwvvvvwx> or no if I pull a random elemnent I might repeat myself
02:18:49 * hackage openapi3 3.0.0.1 - OpenAPI 3.0 data model  https://hackage.haskell.org/package/openapi3-3.0.0.1 (maksbotan)
02:18:59 <xwvvvvwx> I need to have some counter to make sure I never pull the same element
02:19:04 <phadej> you cannot have "unique randoms" without carrying some state with you
02:19:54 <dminuoso> xwvvvvwx: Just a hunch.. but you are not looking for `unbound`, are you? :>
02:20:38 <xwvvvvwx> https://hackage.haskell.org/package/unbound ?
02:20:41 <dminuoso> Yes.
02:20:54 <dminuoso> Oh wait, I missed the QuickCheck part. Nevermind me.
02:21:19 * hackage servant-openapi3 2.0.0.1 - Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.  https://hackage.haskell.org/package/servant-openapi3-2.0.0.1 (maksbotan)
02:22:39 <xwvvvvwx> Can I do something with the state monad?
02:28:13 <phadej> you can work with StateT something Gen yes
02:30:33 <phadej> But i'd rather rethink whether you really need unique random names
02:30:36 <phadej> to begin with
02:30:52 <carbolymer> I need to block thread indefinitely - `newEmptyMVar >>= takeMVar` - is it a good idea?
02:31:06 <phadej> that's something (uniqueness) which is hard to maintain in shrinking
02:31:43 <phadej> carbolymer: that might not work, as you might get a "BlockedIndefinitelyOnMVar" exception
02:32:05 <phadej> why you want to block indefinitely, that doesn't sound right
02:32:18 <phadej> surely there' something you can wait on
02:32:46 <carbolymer> phadej, we have weird app shutdown process implemented - all services are getting `cancel`-ed (from async)
02:33:05 <carbolymer> phadej, so my idea is to catch AsyncCancelled and perform resources cleanup
02:33:46 <phadej> they [async'd threads] will do cleanup if you use `bracket`?
02:33:53 <phadej> ... to acquire them
02:33:56 <phadej> no need to catch anything
02:34:06 <carbolymer> phadej, I can't use bracket, because the cleanup has to be done a completely different place
02:34:36 <carbolymer> our app design is flawed :/
02:35:07 <carbolymer> phadej, so my idea is to `(newEmptyMVar >>= takeMVar) `catch` (\(_ :: AsyncCancelled) -> doCleanup)`
02:35:08 <phadej> anyway, you can have "this thread is completed" TVar for each thread, and wait until they become `True`
02:35:30 <dminuoso> carbolymer: How about, instead of throwing an async exception, you use an MVar?
02:35:43 <dminuoso> That way you can just take from an initially empty MVar, and if the other side wants to terminate, they just put to it?
02:35:48 <[exa]> async exception?!
02:36:01 <phadej> yes, what dminuoso proposes is better.
02:36:07 <phadej> make something to wait upon, and wait on it.
02:36:39 <phadej> flawed current state is not a good reason to make it even worse :)
02:36:50 <carbolymer> dminuoso, that would work I guess, it would be a precedent though
02:37:11 <phadej> feels like there is no clear resource ownership
02:37:21 <carbolymer> yeah...
02:38:15 <[exa]> carbolymer: do the services somehow process "requests" or "data packages" or anything?
02:39:31 <carbolymer> [exa], yes
02:40:29 <[exa]> the usual way is to either have a special request that says "all done, pls exit", or even better a shared exit flag (simple wrapped IORef will do) that the tiny services check regularly
02:43:43 <carbolymer> [exa], I agree, it's aka poison pill, If I were implmeenting the app from scratch, I would implement it that way, it's just it was done previously by canceling services 
02:44:09 <carbolymer> and I wanted to fit in, without week-long refactoring ;)
02:44:19 * hackage hasql-dynamic-statements 0.2.0.3 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.2.0.3 (NikitaVolkov)
02:45:05 <phadej> Haskell is the language to do refactorings
02:45:42 <phadej> very enjoyable if you are sure what's the end state should be, IMO.
02:45:47 <phadej> would rather do sooner than later.
02:45:54 <carbolymer> but when you can deliver business values, when all you do is refactoring? :)
02:46:06 <phadej> on mondays.
02:46:12 <carbolymer> on meetings ;-]
02:57:34 <AWizzArd> Guys, what is your general strategy in Snap to „extract” request parameters? We may have  route [ ("populate/:collection/:precision", populateHandler) ]  and expect two variables, say an Int and String. I can call `getParam "collection"` to get a Maybe value. Same for precision. Only when both are available I want to handle the request, otherwise throw a client error.
02:57:42 <AWizzArd> Then I will also have to parse the incoming data and see if it is plausible. This may result in more Maybes or Eithers. This whole machinery needs to be repeated in every single handler.
02:57:48 <AWizzArd> Does Snap offer anything that allows me to do the core extraction, getting rid of Maybes/Eithers and such?
03:01:20 * hackage mmsyn7s 0.9.1.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.9.1.0 (OleksandrZhabenko)
03:05:23 <cr0ssw1nd> hi folks
03:06:16 <AWizzArd> Hey cr0ssw1nd
03:08:50 * hackage prettyprinter-graphviz 1.1.0.0 - A prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-1.1.0.0 (GeorgeThomas)
03:19:20 * hackage uniqueness-periods-vector-properties 0.5.1.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.5.1.0 (OleksandrZhabenko)
03:20:20 * hackage named-servant-server 0.1.0, named-servant-client 0.1.0 (KristofBastiaensen): https://qbin.io/arabia-sole-w4ye
03:27:19 * hackage named-servant 0.1.1 -   https://hackage.haskell.org/package/named-servant-0.1.1 (KristofBastiaensen)
03:28:20 * hackage named-servant-server 0.1.1, named-servant-client 0.1.1 (KristofBastiaensen): https://qbin.io/cat-rpm-5a0f
03:34:50 * hackage bytestring-tree-builder 0.2.7.5 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.7.5 (NikitaVolkov)
03:38:19 * hackage uniqueness-periods-vector-examples 0.11.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.11.0.0 (OleksandrZhabenko)
03:41:53 <kuribas> why does hlint recommends (Just True = x) for fromMaybe False x
03:41:54 <kuribas> ?
03:42:20 <dminuoso> kuribas: Because its an opinionated tool
03:42:36 <kuribas> s/=/==
03:43:07 <dminuoso> If the author believes `A` is better than `B`, you have to ask the author why they think that.
03:43:30 <kuribas> well, sometimes I can see the point, even if I disagree.
03:43:30 <maerwald> which is why I don't understand why ppl use it in CI
03:43:34 <kuribas> here I don't even see the point
03:43:40 <dminuoso> It's weird when I see people using tools like `hlint` and then zealously following its recommendations, hoping it "improves your code"
03:43:53 <kuribas> maerwald: it doesn't make sense in CI at all.
03:44:03 <maerwald> Yet, ppl do that.
03:44:07 <dminuoso> You should modify and tweak hlint to tell you about things *you* want to know about
03:44:14 <maerwald> hintman makes sense, but not in CI
03:44:24 <kuribas> maerwald: unless it just shows the warnings, not stopping the build.
03:44:32 <dminuoso> Like, Im a big fan of stylish-haskell and similar tools, but only if you tweak them to apply the formatting you wanted *anyway*.
03:44:34 <kuribas> maerwald: even some ghc warnings I disagree with.
03:44:37 <maerwald> https://github.com/apps/hint-man
03:44:50 <dminuoso> kuribas: that's why GHC allows you to turn them on or off.
03:44:58 <dminuoso> If you dont agree with them, disable them.
03:44:59 <maerwald> kuribas: it does stop the build, so I have to argue every time and disable non-sensical warnings :)
03:45:19 <dminuoso> Mostly, GHC has good defaults if you enable -Wall. Emphasis on mostly.
03:45:30 <maerwald> if those are comments in the PR, like hint-man does, it's fine
03:46:08 <dminuoso> Though in case of GHC, I wish we had a granular tool to disable particular warnings in code regions.
03:46:15 <dminuoso> That would solve the above issues.
03:47:09 <dminuoso> Especially orphan instances. :>
03:47:17 * dminuoso wishes for {-# ADOPT #-}
03:52:25 <kuribas> maerwald: making some warnings errors I can understand, like totality checking.
03:52:47 <kuribas> maerwald: I would also disallow `head`, `(!)`, etc...
03:53:36 <kuribas> maerwald: I was bitten by partial functions in a small script I wrote.  I was thinking it didn't matter for the small script, but the person using it was getting unhelpful errors.
03:54:20 <kuribas> the good thing is that finally my colleage could make his hands dirty on haskell :)
04:01:49 * hackage named-servant 0.2.0 -   https://hackage.haskell.org/package/named-servant-0.2.0 (KristofBastiaensen)
04:03:04 * hackage lightstep-haskell 0.10.4 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.10.4 (DmitryIvanov)
04:03:04 * hackage named-servant-server 0.2.0, named-servant-client 0.2.0 (KristofBastiaensen): https://qbin.io/sur-robots-p3us
04:12:50 * hackage uniqueness-periods-vector-properties 0.5.2.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.5.2.0 (OleksandrZhabenko)
04:32:34 <kuribas> since JSON decodes utf8, isn't it wrong for aeson to take ByteString, instead of Text?
04:33:04 <lyxia> aeson does the utf-8 decoding.
04:33:14 <kuribas> lyxia: that's not my question
04:33:20 * hackage lsp-test 0.11.0.7 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.11.0.7 (luke_)
04:33:28 <lyxia> what's wrong about it then
04:33:34 <kuribas> lyxia: not because it *does*, that it *should*.
04:34:01 <kuribas> lyxia: it's wrong because it does to much.
04:34:21 <dminuoso> kuribas: If you want something more customizable, consider waargonaut.
04:34:29 <dminuoso> That lets you use a custom parser.
04:35:02 <kuribas> dminuoso: that's a different issue :)
04:35:54 <kuribas> lyxia: Aeson is meant to do text encoding/decoding, so it should have to mess with bytestring encodings.
04:36:16 <dminuoso> kuribas: You probably get better performance if you dont roundtrip through text.
04:36:29 <lyxia> that seems to be a pretty arbitrary requirement
04:37:01 <dminuoso> Also, if you require Text, then you're *still* forced into a particular decoder, namely those provided by text.
04:37:45 <kuribas> dminuoso: there are different encoders for Text.
04:37:52 <dminuoso> And ontop, that puts additional burden on the programmer, since you yourself have to explicitly use decodeUtf8, since Utf16/32 is invalid for JSON.
04:38:00 <dminuoso> (Outside closed systems)
04:38:18 <kuribas> lyxia: for example, I may want to generate a json string into Text.
04:38:41 <kuribas> ByteString and Text shouldn't be interchangeable
04:38:47 <phadej> It's not about having either, yes, aeson should have an option to generate Text directly too
04:39:09 <phadej> but due mentioned performance reasons, one have to pick one, and ByteString is "better" choice
04:39:42 <phadej> bold claim: make stack support backpack (or go away), then there could be backpacked Aeson for either bytestrings or text
04:40:13 <dminuoso> phadej: An even bolder claim, before we use backpack, can we have a functional documentation for it first? :p
04:40:14 <phadej> i.e. lets rather not choose either, but make library support everything (but without performance penalties)
04:40:33 <kuribas> phadej: that would be a better option of course...  Is aeson really that optimized on speed?
04:40:38 <phadej> kuribas: it is
04:41:21 <phadej> the addition of toEncoding was purely motivated by performance considerations
04:41:47 <phadej> otherwise you (can quite easily in fact) use toJSON + Value -> Text function
04:42:29 <phadej> writing Text -> Value parser is in fact also ok and possible, I guess someone just need to do the legwork there
04:42:45 <phadej> (as parsing side of aeson always goes through `Value`)
04:42:54 <kuribas> I thought Text was still quite performant
04:43:16 <kuribas> was aeson made pre-Text?
04:45:42 <phadej> text is performant when you already have it
04:45:58 <phadej> for parsing, in fact it isn't as you have to decode backing UTF16 on the fly
04:46:33 <phadej> Vector Word32 would be more performant (i.e. UTF32 encoding), if you can afford having 4bytes per character
04:49:14 <phadej> in fact, `text` is weird compromise nowadays, utf16 isn't really space efficient, nor is fixed-width (i.e. as performant as it can get)
04:49:50 <phadej> but then there are reasons why its internal encoding isn't changed
04:50:59 <kuribas> if the internals aren't leaky, we could change to utf8
04:53:05 <phadej> https://github.com/text-utf8/META/issues/1
04:53:23 <phadej> "we" doesn't work
04:53:53 <phadej> people burnout climbing this kind of hills
04:54:23 <dminuoso> Presumably the main issue is that those people have day jobs, hobby projects, maintainer positions for dozens of other projects..
04:54:41 <dminuoso> So if you have a personal life and still want to get text-utf8 done, it's gonna be hard.
04:55:04 <phadej> yes, these kind of issues should be someones dayjob
04:56:52 <phadej> Though, honestly, I don't think that driving these kind of big-scale changes through is a nice job
04:58:25 <phadej> and IMHO that team should be at least of size three
04:58:38 <phadej> so it's not any single person's job either
04:59:16 <__skn> CX
04:59:49 <phadej> because these kind of libraries should be associated with a single person
05:05:30 <dminuoso> *shouldn't
05:11:29 <Cheery> I wrote a tool that fetches a og:title/og:description from the website and dumps it along the link.
05:11:59 <Cheery> Now I'd need a tool that can get in bunch of text, and produce a short summary from it.
05:15:19 <Cheery> Yay.. there's a linux tool for that. :)
05:19:08 <phadej> dminuoso: yes, thanks for correction :)
05:35:21 <Cheery> Ok.. the summarizers seem to not work too well.
05:35:31 <Cheery> So the stuff I get is probably the best I can get.
05:36:08 <Cheery> there's this crazy python-written kit, but it's even harder to use than all the rest.
05:51:42 <titusg> hi, how do I tell ghc about cabal 3.2 packages?
05:52:18 <geekosaur> ideally you use a cabal project instead of ghc directly
05:52:36 <dcoutts> titusg: e.g. cabal repl will start ghci in your project
05:52:39 <titusg> this is in order to use xmonad
05:53:19 <geekosaur> use "cabal v2-install --lib" outside of a project, then
05:53:43 <geekosaur> that said, there are build scripts that can use cabal to rebuild xmonad
05:53:50 <dminuoso> titusg: For xmonad you need to use a custom build script
06:14:41 <crossw1nd> what should I install on linux server over SSH in order to random random haskell binary?
06:14:44 <crossw1nd> just ghc?
06:14:57 <crossw1nd> *to run random haskell binary
06:15:52 <[exa]> what kind of linux is that?
06:16:11 <[exa]> generally ghc compiles the haskell source to a normal binary that you should be able to run just as any other language's binary
06:17:28 <crossw1nd> debian I guess
06:17:33 <crossw1nd> apt is present
06:17:55 <crossw1nd> [exa] but I mean usually it isn't statically compiled?
06:18:05 <crossw1nd> I need to have haskell runtime at least
06:18:12 <maerwald> crossw1nd: you need libgmp
06:18:20 <crossw1nd> or is GC bundled into a binary already?
06:19:22 <geekosaur> the runtime should be statically linked into the executable usually
06:20:09 <maerwald> you need at least libgmp and possibly other libraries
06:20:36 <maerwald> just check the binary with lddtree
06:20:39 <kuribas> is there a way to force servant-client to always emit a =true for boolean flags?
06:20:52 <kuribas> it seems it sometimes emits flag=true, and sometimes just flag
06:24:25 <crossw1nd> geekosaur, ooh, I guess it was different 5 years ago
06:24:47 <crossw1nd> maerwald, thanks, trying to figure out how to do it in ubuntu :)
06:24:55 <crossw1nd> there are several libgmp
06:25:06 <crossw1nd> lddtree is awesome idea
06:25:53 <geekosaur> it depends on the platform, but dynamic by default has mostly gone away iirc
06:26:18 <crossw1nd> that's nice
06:26:23 <geekosaur> OS libs are linked dynamic but ghc's own or generated libs should normally be static
06:27:00 <geekosaur> (arch links dynamic by default, and breaks a bunch of stuff thereby, but that's another story)
06:28:10 <mcmoor> Hello, I have this snippet of red-black-tree implementation https://repl.it/repls/DisastrousClientsideDataset#main.hs
06:28:29 <mcmoor> My main question is, why does redden success to be compiled?
06:29:02 <mcmoor> I thought that Valid class only allows Red Black Black or Black Red/Black Red/Black
06:32:35 <crossw1nd>     libicuuc.so.65 => not found
06:32:36 <crossw1nd>     libicui18n.so.65 => not found
06:32:36 <crossw1nd>     libicudata.so.65 => not found
06:32:42 <crossw1nd> omg can't find it on ubuntu
06:33:11 <crossw1nd> is it some common lib for haskell? 
06:33:18 <crossw1nd> or very specific
06:33:37 <geekosaur> it's part of the ICU package
06:33:47 <geekosaur> which is a common package, not Haskell specific
06:34:46 <crossw1nd> but this particular so can be found only in CentOS and Fedora
06:34:49 <crossw1nd> according to pkgs.org
06:35:13 <crossw1nd> (+ alt, openmandriva and slackware)
06:35:29 <crossw1nd> ah I get it
06:35:31 <crossw1nd> of course
06:35:31 <geekosaur> on ubuntu it's libicu60 package
06:35:35 <crossw1nd> becaues I compiled in on fedora
06:35:52 <crossw1nd> but I need to recompile it on debian then?
06:36:02 <crossw1nd> then can be not easy in current circumstances..
06:36:45 <crossw1nd> yeah, libicu60 is installed
06:37:25 <crossw1nd> docker to the rescue
06:37:42 <geekosaur> oh, fedora had 6.5 I guess
06:42:24 <maerwald> crossw1nd: are you planning to redistribute the binary to multiple users?
06:43:09 <crossw1nd> maerwald, no, it's one-time job
06:43:24 <crossw1nd> it's just quicker than to fix all warning or find how those guys enabled -Werror :D
06:43:42 <crossw1nd> the setup is pretty complicated with multiple docker kubernetes etc
06:44:16 <crossw1nd> so this is my savious, I guess
06:44:16 <crossw1nd> docker run --net=host --rm -it -v /root:/host -it fedora:32 /bin/bash
06:44:50 <crossw1nd> or I can recompile there, but I don't want to install haskell there
07:02:30 <crossw1nd> yeah it worked
07:14:19 * hackage Z-Data 0.1.6.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.6.0 (winterland)
07:16:53 <kuribas> ah I found it: makeClientRequest can rewrite the requests
07:57:10 <maralorn> I‘d like some opinions about hackage. I have written a tool, which might benefit a large number of users and a few have already voiced interest. It is a workaround that should actually be fixed upstream in nix (which is written in C++), which will take years, if it ever happens. But still my tool is kinda temporary. Should I release it to hackage anyways? https://github.com/maralorn/nix-output-monitor/issues/2
07:58:09 <geekosaur> you can deprecate it later if it ever does get fixed upstream
08:05:36 <maralorn> So that wouldn‘t count as spaming hackage?
08:06:19 <geekosaur> maybe if they were planning to fix it in a week or so, it might count as spamming. but I suspect not even then
08:06:55 <kuribas> it's not like there is a quality garantee on hackage
08:39:09 <maerwald> hackage isn't collaboration point, it's a publishing platform
08:40:56 <phadej> https://hackage.haskell.org/upload 
08:40:58 <phadej> Because each package added to the main package index has a cost of operation and maintenance associated to it, your package should strive to provide value for the community by being intended to be useful to others.
08:41:10 <phadej> is your tool useful to others in current state?
08:42:25 <phadej> if it is, and you aim to maintain it (which entails giving your package a meaningful synopsis/description as well as ensuring your package is installable by helping with providing accurate meta-data.) then putting it on Hackage is fine
08:44:33 <phadej> otoh, if it's usable only to nix people, maybe less binding way is just to make github releases and make people install it from there
08:45:21 <phadej> it's nix tool, and nix makes it easy to install from github, so why to go through Hackage at all
08:45:42 <maerwald> especially when all your deps need to be on hackage too
08:46:12 <maerwald> fork, fire and forget is easier with github release
08:46:50 <phadej> well, https://matrix.hackage.haskell.org/#/package/nix-derivation
08:46:56 <phadej> IMO that is not really maintained
08:47:10 <phadej> and I think this is even more common with nix-oriented libraries than stack ones
08:47:20 <AWizzArd> Is there possibly a `check` function like this in Haskell?    check val f err = if f val then Right val else Left err
08:47:44 <phadej> their maintainers don't care about non-nix(pkgs) installation methods
08:49:10 <phadej> AWizzArd: you have just written one :)
08:49:11 <ski> @hoogle (a -> Bool) -> e -> a -> Either e a
08:49:13 <lambdabot> No results found
08:49:18 <phadej> but, no, I don't think there is such.
08:49:27 <phadej> better to write your `f` to return Either to begin with
08:49:46 <ski> (also wrong parameter order, most likely)
08:50:17 <phadej> compare
08:50:19 <phadej> :t Data.List.NonEmpty.nonEmpty
08:50:20 <lambdabot> [a] -> Maybe (GHC.Base.NonEmpty a)
08:50:21 <phadej> and
08:50:26 <phadej> :t null :: [a] -> Bool
08:50:28 <lambdabot> [a] -> Bool
08:50:57 <phadej> https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/
08:51:46 <ski> @where boolean-blindness
08:51:46 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
08:56:13 <Ariakenom_> slightly reminiscent of
08:56:16 <Ariakenom_> :t guard
08:56:18 <lambdabot> Alternative f => Bool -> f ()
08:57:21 <phadej> guard is nice in Maybe
08:57:47 <phadej> but with Either MyError it's too rough :)
08:58:00 <Ariakenom_> ye :(
08:58:04 <ski> @type \p e a -> a <$ unless (p a) (throwError e)
08:58:06 <lambdabot> MonadError e f => (t -> Bool) -> e -> t -> f t
09:01:18 <phadej> that looks almost like perl (which has postfix conditionals :)
09:21:27 <maerwald> phadej: everything should be installed through nix anyway :p
10:43:40 <dwts> hi all, when a comparison returns  GT, LT, or EQ, is it safe to assume that in reality the "real" values of them are numbers?
10:43:55 <tomsmeding> dwts: the real values of what exactly
10:43:59 <tomsmeding> GT/LT/EQ ?
10:44:01 <dwts> yes
10:44:23 <dwts> I have trouble understanding what is the benefit of returning these instead of numbers
10:44:38 <tomsmeding> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Ord.html#t:Ordering
10:44:47 <tomsmeding> it's just 'data Ordering = LT | EQ | GT'
10:45:10 <dsal> dwts: Why would you want a number there?
10:45:11 <tomsmeding> though you can use fromEnum on them to get 0,1,2 if you should wish :p
10:46:15 <tomsmeding> re:benefit: more type safety
10:46:55 <tomsmeding> a number you can potentially confuse with something else that produces a number
10:46:56 <dwts> dsal: I don't *want* a number, I'm trying to visualize in my mind what haskell is doing underneath and why the ordering is implemented that way
10:47:13 <dwts> ah, I see
10:47:19 <tomsmeding> well deep down in the implementation details, Ordering really boils down to just a byte
10:47:22 <tomsmeding> that's 0, 1 or 2
10:47:31 <tomsmeding> because that's how haskell compiles down sum types like these
10:47:42 <tomsmeding> but the programmer need not think about that :)
10:48:08 <dsal> Similar to how Bool is False and True.  You *can* convert those to numbers and some languages do that and it's massively error prone.
10:48:49 <dwts> do these LT/EQ/GT have a special name like True/False have Boolean?
10:49:02 <Uniaika> hmm, not that I know of
10:49:05 <tomsmeding> data Bool = False | True
10:49:08 <Uniaika> they're just values of an ADT
10:49:11 <tomsmeding> data Ordering = LT | EQ | GT
10:49:13 <dsal> Ordering?
10:49:18 <dwts> ok
10:49:55 <dwts> I think I'm good for now, thank you all
10:49:59 <dsal> Similarly, Boolean is often a really bad abstraction.
10:50:27 <dwts> dsal: not sure why, but I have no reason not to believe you :)
10:50:29 <dsal> I had an awful time understanding some of my own code that I modeled a bit from a protocol specification as a Boolean before I changed it to my own sum type and suddenly could read my own code.
10:50:36 <dsal> boolean blindness is a terrible thing
10:50:42 <tomsmeding> now we're (indirectly) talking about performance anyway: is there a faster way to read lots of Double's from a file than the following: sum . map (read @Double) . words <$> readFile "doubles.txt"
10:50:52 <tomsmeding> because that's horribly slow
10:51:21 <ski> @where boolean-blindness
10:51:22 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
10:51:25 <dsal> Is read that slow?
10:51:30 <tomsmeding> apparently?
10:52:07 <dsal> You could probably make a faster parser if you don't need all of the things that a Double parser could parse.
10:52:58 <ski> > sortBy (comparing length <> compare) (words "The quick brown fox jumps over the lazy dog")  -- dwts, with a separate `Ordering' data type, we can do this "primarily sort by length, secondarily by ordinary lexicographic word ordering")
10:53:01 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:53:04 <tomsmeding> from some rudimentary timing the 'read' part indeed takes the longest time
10:53:50 * hackage rebase 1.10.0.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.10.0.1 (NikitaVolkov)
10:53:51 <tomsmeding> dwts: ski's example is a thing because we can define <> to do something special on Ordering that it does not do on plain numbers
10:54:00 <dwts> ski: I was actually reading a book with  a sortBy example and came to the definition of LT/EQ/GT
10:54:25 <dwts> this looks really powerful and confusing at the same time
10:54:42 <tomsmeding> dsal: I could try that, but 'length . words' already takes longer than C++ takes to parse the entire thing into an std::vector<double>
10:54:50 * hackage rerebase 1.10.0.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.10.0.1 (NikitaVolkov)
10:54:56 <tomsmeding> dwts: welcome to haskell :p
10:55:04 <ski> @where monoids
10:55:05 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
10:55:05 <lambdabot> instance Monoid a => Monoid (rho -> a)'
10:55:08 <ski> dwts ^
10:55:46 <dsal> dwts: At a higher level, discussing meaning makes it a lot easier to reason about things than discussing implementation.
10:56:21 <dwts> tomsmeding: thanks :P Coming from a scheme background some things are similar but others seem so different
10:56:41 <dwts> dsal: I see your point
10:56:42 <dsal> You never have to read the manual to remember what a compare function returns and how the integer value maps to maybe -1, 0, 1, or maybe just some negative or positive value, or 0, 1, 2, or how you might be able to combine comparisons by renormalizing them, etc...
10:57:16 <dsal> The Ordering semigroup is really a secondary benefit.  Primarily, you get to talk about what you mean instead of going back and forth to machine speak constantly.
10:58:32 <dwts> hmmm
10:58:37 <dwts> there's a lot to digest here
10:58:38 <dwts> lol
10:59:01 <tomsmeding> dwts: sidenote: "semigroup" means that definition of <>
10:59:11 <tomsmeding> nothing more :p
10:59:12 <dwts> ah
11:00:13 <dsal> Well, what happens is when you start talking about what you mean, you get to make a lot of things common that you wouldn't have been able to see the commonality in before.
11:02:34 <galagora-> Has anyone ever used Silica, the lens library?
11:08:10 <dsal> galagora-: I just heard about it a around 5 minutes ago.  Is it working out for you?
11:10:09 <tomsmeding> dsal: the same pipeline but then with Int instead of Double is only slightly faster (on a file that only contains integers, of course)
11:10:18 <tomsmeding> so a custom Double parser is unlikely to make things better
11:11:11 <dsal> I tend to reach for megaparsec early, but I also don't parse for performance much.
11:11:22 <geekosaur> depends. Read itself has a decent amount of overhead
11:11:43 <tomsmeding> @hoogle ByteString -> (Double, ByteString)
11:11:44 <lambdabot> Algebra.RealRing splitFraction :: (C a, C b) => a -> (b, a)
11:11:44 <lambdabot> NumericPrelude splitFraction :: (C a, C b) => a -> (b, a)
11:11:44 <lambdabot> NumericPrelude.Numeric splitFraction :: (C a, C b) => a -> (b, a)
11:11:50 <tomsmeding> now if that would've existed :p
11:12:18 <tomsmeding> @hoogle ByteString -> Maybe (Double, ByteString)
11:12:19 <lambdabot> Data.ByteString.Lex.Integral readDecimal :: Integral a => ByteString -> Maybe (a, ByteString)
11:12:19 <lambdabot> Data.ByteString.Lex.Integral readHexadecimal :: Integral a => ByteString -> Maybe (a, ByteString)
11:12:19 <lambdabot> Data.ByteString.Lex.Integral readOctal :: Integral a => ByteString -> Maybe (a, ByteString)
11:12:26 <tomsmeding> there we go, let's try that
11:15:20 <ski> @type ((listToMaybe .) . evalStateT . (>>= \ns -> do "" <- StateT lex; return ns) . many . StateT) (reads :: ReadS Double)
11:15:22 <lambdabot> String -> Maybe [Double]
11:19:34 <tomsmeding> ski: that's ~60% slower than my simple read pipeline
11:19:59 <tomsmeding> and my read pipeline additionally has the advantage of not using the list monad in an obscure manner :p
11:20:33 <tomsmeding> (on my machine)
11:24:15 <tomsmeding> ski: though I'm curious how you came up with that monstrosity :p
11:25:16 <tomsmeding> ah the bytestring way seems _significantly_ faster
11:25:31 <tomsmeding> (as expected, in hindsight)
11:25:45 <Guest18> Hello, I have a question regarding unbalanced binary search trees in haskell
11:26:04 <ski> dwts : you could compare with <https://srfi.schemers.org/srfi-67/srfi-67.html#node_sec_4.5>
11:26:10 <Athas> Roughly, when you have a monad transformer stack, is it more efficient to have an Error/Except monad innermost, or an error monad transformer outermost?
11:26:16 <Athas> Or does it depend on the specifics?
11:26:29 <ski> tomsmeding : hm, i thought it was fairly straightforward
11:27:23 <ski> "my read pipeline additionally has the advantage of not using the list monad in an obscure manner" -- is that an advantage ? ;p
11:27:42 <tomsmeding> questionably :
11:27:42 <ski> (but i don't really think it's that obscure ..)
11:27:43 <tomsmeding> * :p
11:27:53 <tomsmeding> but apart from how obscure your pipeline is or not
11:28:01 <tomsmeding> why did you think it would be faster than my simple read pipeline?
11:28:31 <bifunc2> If unsigned integers are serialized in big endian, order is preserved. (smaller number gets a  smaller bytestring)
11:28:31 <bifunc2> Is there any such way to serialize signed integers, Doubles, and Floats?
11:29:27 * tomsmeding has no idea regarding Athas' question, pass to another willing answerer
11:30:02 <Guest18> I made a small type that is a binary search tree and some functions for it, like insert, delete, etc. All is well so far, except for the function that returns the node depth for a given value. for example, if a node has a value of '3' and is 2 levels down from the root, it should return 'Just 2'. If the value searched for isn't in the tree, it
11:30:02 <Guest18> returns nothing. I have a working example, but it isn't that good. Can anybody provide me with a better implementation or at least some advice?
11:30:08 <dolio> Innermost vs. outermost might not have the same semantics.
11:31:38 <tomsmeding> bifunc2: in the standard IEEE floating point format, positive doubles and floats already sort correctly
11:31:49 <tomsmeding> negative ones sort above positive ones
11:31:51 <ski> @quote Dr._Seuss
11:31:52 <lambdabot> Dr._Seuss says: `type Parser a = String -> [(a,String)]' -- "A Parser for Things / is a function from Strings / to Lists of Pairs / of Things and Strings!" -- <https://willamette.edu/~fruehr/haskell/
11:31:52 <lambdabot> seuss.html>
11:32:05 <tomsmeding> the same holds for signed integers in 2's complement, when you write them in big endian order
11:32:16 <bifunc2> tomsmeding, wow, that's mind-blowing, thanks!
11:32:23 <Guest18> The code here: https://pastebin.pl/view/9ea923e2
11:32:26 <Cale> Guest18: Seems like something that perhaps the Monad instance for Maybe could help to make clean
11:32:29 <tomsmeding> bifunc2: about the signed integers, or about the floats?
11:32:58 <Guest18> Cale: I don't know how to use monads yet
11:33:00 <Cale> Guest18: one sec... that's just taking a moment to load here
11:33:16 <bifunc2> tomsmeding, I'm more interested in the floats. For positive Doubles and Floats, will the "store" package preserve the order on a  little endian machine?
11:33:19 <tomsmeding> for the floats, you can see that by noting that if 0 < A < B, then either A has a smaller exponent than B, or it has the same exponent and a smaller mantissa
11:33:33 <tomsmeding> ignoring the sign bit of course
11:33:35 <Cale> Guest18: does it load for you?
11:33:46 <Cale> Not sure if I'm just having an issue locally...
11:33:48 <Guest18> Cale: Slowly, but yeah
11:33:53 <Guest18> It took a while
11:34:15 <tomsmeding> bifunc2: I have no idea what the 'store' package does, but that claim about the IEEE format only holds for big-endian order
11:34:24 <Cale> Maybe try dpaste.com?
11:34:53 <tomsmeding> ski: it's unfortunate that that quote splits over lines halfway through a URL
11:35:08 <Guest18> Cale: https://dpaste.com/GX8QSKDLD
11:35:14 <Cale> thanks
11:36:22 <bifunc2> tomsmeding okay. https://hackage.haskell.org/package/store always uses machine endianness. so i'm out of luck there with the order on most machines nowadays.
11:36:23 <bifunc2> However I can use cereal https://hackage.haskell.org/package/cereal-0.5.8.1/docs/Data-Serialize-IEEE754.html which can encode floats in big-endian
11:36:25 <Cale> That code looks fairly reasonable to me actually
11:36:33 <bifunc2> are there any alternatives to cereal that are faster nowadays?
11:36:34 <Cale> You might want to use compare x root
11:36:35 <Guest18> Oh, yeah, I should mention that i used to do a lookup first, to ensure that if the element isn't there, i return nothign
11:37:08 <Cale> Oh, right, depthGo isn't returning Nothing, somehow
11:37:19 <Guest18> but it seemed to me that it would be too slow and maybe there is a better way, but i couldn't find it
11:37:24 <Guest18> that's why i came here
11:37:35 <tomsmeding> bifunc2: not well-versed enough in the library ecosystem to answer that question, unfortunately
11:38:01 <Guest18> for small trees, it's fine, but doing a lookup on big trees before searching for the depth once again, does add unnecesarry computation
11:38:01 <Cale> Guest18: I would guess that you want depthGo _ EmptyTree acc = Nothing
11:38:37 <monochrom> and the x==root case, = Just acc
11:38:41 <Cale> yeah
11:38:42 <bifunc2> tomsmeding, np, thanks for the other info!
11:38:54 <monochrom> So generally the whole depthGo does Maybe, too.
11:38:59 <Cale> and then take the Maybe stuff out of depth
11:39:01 <Guest18> so modify the depthGo to return Maybe b as well
11:39:11 <Cale> (it'll produce Maybe only because depthGo does)
11:39:12 <Cale> yeah
11:39:14 <Guest18> Yeah, actually that makes sense
11:39:19 <ski> tomsmeding : hm, i didn't really had in mind that it would be. i just wondered how to express it, with `reads'
11:39:26 <Guest18> i don't know why i didnt see that
11:39:36 <ski> tomsmeding : hm, i don't recall it used to break line, quite that early
11:39:47 <monochrom> depth should be "depth x tree = depthGo x tree 0" very simply, no more no less.
11:39:55 <tomsmeding> ski: ah I see
11:40:05 <Guest18> I am programming in haskell for one week so my code can be sketchy sometimes
11:40:06 <monochrom> For example there is no point "depth" cares about empty trees.
11:40:24 <Cale> also, you can do:  depthGo x (Node root left right) acc = case compare x root of EQ -> ...; LT -> ...; GT -> ...
11:40:27 <Guest18> i see, yeah
11:40:37 <monochrom> Well in this case I'm just using the DRY principle.
11:40:40 <Cale> Which will only compute the comparison once, and match on the result
11:43:05 <ski> Guest18 : instead of using an accumulator, it would be possible to do the addition "after the recursive call"
11:43:36 <Guest18> ski: isn't the accumulator letting the compiler use tail call optimization?
11:43:47 <monochrom> That turns out to be much uglier in this case. And don't even get me started on efficiency.
11:44:15 <ski> Guest18 : yes, that might be preferrable (at least if you'd be using say `Int' or `Integer' ..) .. but then you should make sure to force the accumulator, as you go
11:44:35 <monochrom> Because you then have to say "if the recursion gives you Nothing, nothing to add" and "if the recursion gives you Just n, now it's Just (n+1)"
11:44:45 <ski> Guest18 : but ignoring such performance considerations, a non-accumulating version can often be more readable
11:44:53 <ski> yea, there's that
11:45:39 <ski> Guest18 : depending, it's commonly preferable to not be tail-recursive
11:45:45 <monochrom> For computing tree height or tree size, yes I would do "1 + height left + height right".
11:46:14 <monochrom> In fact for height and size, tail recursion is the much uglier one.
11:46:20 <ski> (but in this case, you're just computing a single number, so there's not much point to that, here)
11:46:27 <monochrom> Also throughout, my "ugly" includes both ugly and hard to follow.
11:46:32 <dolio> monochrom: Not only that, it's easier to not be better than an accumulator with that. :)
11:46:40 <monochrom> because they are caused by complications
11:46:40 <dolio> An unforced accumulator, that is.
11:47:22 <ski> (i suppose an alternative here would be CPS ..)
11:47:45 <monochrom> Oh CPS is the most unreadable of them all haha
11:48:14 <ski> hm, i think it could be more readable than doing `case's
11:48:36 <Guest18> https://dpaste.com/DRF3G9AA6 -- any other suggestions?
11:48:39 <ski> (as long as one's familiar with CPS, of course)
11:49:08 <ski> Guest18 : your `Show' instance is incorrect
11:49:43 <monochrom> <CPS> Mirror mirror, who's the most unreadable of them all?  <Mirror> You, in all Haskell Land.  <CPS> But I mean universally, not just Haskell Land.  <Mirror> Then it's your step daughter, CPS+trampolining, she's is Javascript Forest now.
11:50:06 <Guest18> ski: how so? it works fine for me
11:50:24 <ski> Guest18 : it doesn't output valid Haskell source
11:50:39 <dolio> monochrom: That's why you need delimited continuations, to make it perfectly clear.
11:51:21 <monochrom> <CPS> I'm going to give reactive node.js thingy to Javascript Forest to poison them all!
11:51:43 <Guest18> ski: why should it? I just wanted a more readable version, so i can debug easily
11:51:45 <ski> Guest18 : if you want to do custom pretty-printing, then please don't use `Show' for that. (`Show' instances are meant to work together. your instance, when combined with other `Show' instances, will produce a mixture of Haskell and non-Haskell code). please define a separate function, say `displayTree'
11:52:01 <Guest18> ski: oh, okay
11:52:14 <Guest18> That actually makes sense
11:52:41 <geekosaur> also Show and Read are designed to work together such that the output of a valid Show instance can be passed to `read'
11:53:13 <ski> Haskell will automatically combine instances like this, e.g. if you were to display a list of type `[BST (BST a)]'
11:53:20 <ski> yes, that too
11:53:22 <tomsmeding> monochrom: :D
11:53:30 <Guest18> I also have a flatten, insert, search and fromList functions and want to add some more. I'm really digging how easy it is to make these kind of stuff in Haskell
11:56:40 <ski> Guest18 : there are cases when one may want to make a hand-written `Show' (and `Read') instance. e.g. when the implementation can't manage to derive one for you. or when you're making an abstract data type, and don't want to expose your implementation, but rather display a value in terms of the exported operations
12:00:04 <Guest18> yeah, this was more for the educational value than naything else
12:00:57 <Guest18> follow up question
12:01:43 <dwts> Which haskell book would you guys suggest for someone new to haskell but not new to programming? I've started "Get programming with Haskell" but I'm not very happy with it 
12:02:39 <Guest18> say i have the following line of code: `[depth x tree | x <- flatten tree]`. How do i sum up these depths? Since they are wrapped in a Just, I can't just use `sum` on the list
12:03:13 <Cale> dwts: Graham Hutton's Programming in Haskell seems pretty good
12:03:23 <dwts> To help you understand what I don't like: 1) it doesn't explain how to indent code 2) it doesn't explain how to read function definitions
12:03:31 <dwts> Cale: thank you sir
12:03:39 <Cale> Guest18: What do you want to do if there's a Nothing?
12:04:02 <Cale> Guest18: Oh, of course there won't be
12:05:17 <Cale> Guest18: One cute way is to write  [d | x <- flatten tree, Just d <- [depth x tree]]
12:05:52 <Cale> But it seems a bit expensive to be doing it like this
12:05:57 <Guest18> Cale: yeah, there will never be nothing
12:06:51 <monochrom> <pun>Just cause to use fromJust? >:) </pun>
12:06:56 <Cale> You're going to end up paying the price to look up every element of the tree, when ideally you'd do none of that work
12:08:09 <monochrom> More realistically, how about directly write a function that computes the list of all depths of all internal nodes?
12:08:34 <monochrom> Or even, a tree of the same shape but keys are replaced by depths; then use flatten.
12:08:44 <Cale> yeah
12:09:13 <Cale> avoid all the order comparisons
12:09:19 <Guest18> monochrom: i like the first idea, seems pretty efficient
12:09:20 <ski> monochrom : Just because
12:10:16 <Guest18> so using fromJust is expensive?
12:10:40 <koz_> Guest18: It's not expensive, it's just error-prone, and you wanna avoid it if possible.
12:10:41 <ski> no, repeatedly traverersing down the tree, for every element in it, is
12:10:42 <geekosaur> no, Just a bad idea
12:10:44 <monochrom> No. It's just unsatisfactory.
12:10:45 <koz_> And in this case, it's 100% possible.
12:12:17 <Guest18> Well, it's not error prone, because i am guaranteed that depth will never return Nothing in my list comprehension
12:12:29 <Guest18> but i see why it isn't efficient
12:12:42 <dsal> dwts: I really like haskellbook.com -- it's easier if you pretend that you're new to programming
12:13:21 <Guest18> I am going to get back to you with a better solution
12:13:48 <Cale> Guest18: It's often error prone in that while your code might satisfy the precondition to not have fromJust crash when you write the fromJust, future changes to the code often result in fromJust being applied to Nothing, and they're a total pain to deal with
12:14:00 <Cale> > fromJust Nothing
12:14:02 <lambdabot>  *Exception: Maybe.fromJust: Nothing
12:14:06 <Cale> ^^ this is all you get at runtime
12:14:16 <Cale> Note the lack of a source location to help you
12:14:28 <Cale> I would actually usually prefer to write (\(Just x) -> x)
12:14:31 <Cale> just because...
12:14:40 <Cale> > (\(Just x) -> x) Nothing
12:14:42 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
12:14:59 <Cale> ^^ that will include the file and line number of the lambda which failed to match
12:15:18 <Guest18> Although, I must say, I was getting errors non-stop when i started with haskell, but now, i kinda get some things and i start to understand where the ghc has a problem and know how to fix it. It is really satisfying to write haskell :))
12:15:45 <Guest18> Cale: I see, good to know! Thanks!
12:15:54 <Cale> Yeah, generally the type system makes refactors a lot more manageable -- you learn to rely on the errors that the compiler is going to give you
12:16:14 <Cale> You can just change something and let the compiler figure out most of the consequences
12:16:20 <ski> dsal : i suspect they didn't want to pretend that. (especially since they come from Scheme)
12:17:04 <dsal> Yeah, scheme might be a more gentle approach vector.
12:17:20 <Guest18> Cale: yees, i so love it. I dread working with normal, idiomatic C# now, I much favor using functional constructs in it now
12:18:02 <Guest18> One of these days, I am gonna suggest to my boss to maybe let me work in F# 
12:19:27 <Guest18> I heard F# is pretty good actually, what do you think?
12:21:02 <koz_> As far as I am aware, F# is basically .NET's Scala.
12:21:21 <dsal> Isn't F# ocaml?
12:21:42 <dsal> I don't know much about microsoft.
12:21:47 <dolio> It's more like ocaml than scala, I think.
12:21:48 <Guest18> dsal: that's what i heard, and seeing it, yeah, it is very similar to ocaml
12:22:01 <koz_> dolio: Yeah, that's a fair call. 
12:22:58 <dolio> It's missing a lot of ML stuff, though.
12:23:20 <dolio> Or maybe not a lot, but what it's missing is significant.
12:23:26 <Guest18> like what?
12:23:33 <dolio> The module system.
12:24:11 <Guest18> it does have modules though
12:24:53 <dolio> It doesn't have ML style modules.
12:25:48 <aldum> anyone know about F*?
12:26:23 <aldum> allegedly it's an even more advanced functional lang from MS, but there's not much out there about it
12:26:36 <Guest18> never heard of it
12:26:39 <monochrom> Oh, if you already have a Scheme background, then "a gentle introduction to haskell" ought to do.
12:29:49 <dminuoso> It's very gentle.
12:29:53 <dminuoso> The name isn't totally misleading.
12:30:01 <monochrom> \∩/ "In the rest of the paper we will often say “more polymorphic than” instead of the more precise but clumsier “at least as polymorphic as”."  I have always wanted to do that.
12:30:04 * dminuoso stops with the tongue-in-cheek
12:30:40 <monochrom> It is gentle if you're OK with Scheme or ML or ...
12:30:52 <dminuoso> It's still not, really.
12:31:49 <dminuoso> I'd say the type system, lack-of-IO-purity and lazyness make for a pretty wild experience, even from Scheme.
12:32:57 <dminuoso> The gentle introduction is just a very brief rush over Haskell that works well enough for someone who comes from say Idris.
12:33:14 <dminuoso> It doesn't teach the language at all
12:33:18 <dolio> I read it after learning Scheme.
12:33:27 <monochrom> It worked very well for me, and Idris didn't exist when it worked for me.
12:34:04 <dsal> I played with haskell for years and even had some useful not-completely-trivial programs, but it wasn't until I suspended prior knowledge that understanding got a lot easier.
12:35:11 <dminuoso> monochrom: Says the professor in comp sci.
12:35:13 <dminuoso> ;)
12:35:16 <monochrom> nor Agda. Coq existed but I wasn't patient with it, I gave up after a few simple propositions.
12:35:57 <monochrom> For the type system you could point towards me having done ML before I ran into Haskell.
12:36:23 <monochrom> But how the hell did I grok ML's type system in the first place, after only Scheme and Pascal?
12:36:36 <monochrom> Well I guess I also met Ada.
12:36:54 <dolio> I didn't do ML first.
12:36:57 <monochrom> and C++ templates
12:38:10 <ski> monochrom : with Ada generics ?
12:38:24 <monochrom> My feeling is that, eg, Hutton's and Bird's are only more wordy, and more examples, than the gentle introduction. But not gentler.
12:38:27 <monochrom> Yeah
12:39:37 <monochrom> Those books feel gentler because the wordy fillers forces you to spend 500 pages of time over what could be said in 10 pages such is in the gentle introduction.
12:40:24 <monochrom> This means if you consume the gentle introduction at the slow rate of, like, one afternoon per paragraph, then it's gentle.
12:40:31 <monochrom> And I think I did exactly that.
12:41:09 <dminuoso> I think its highly situational
12:41:16 <dwts> dsal: let me check that - thanks
12:41:55 <dolio> If you already know how to write scheme programs, it seems like enough to start messing around.
12:42:06 <dolio> It won't teach you everthing about every situation, obviously.
12:43:41 <dsal> dwts: When I started learning Haskell for real, I had production code in c, c++, objective c, ocaml, java, scheme, perl, tcl, erlang, ruby, r, and probably something else I forgot.  Tossing another language on seemed like no big deal.
12:44:11 <dsal> Haskell isn't hard fundamentally.  People build a lot of seemingly complex things in Haskell, but that's because it's easy.  :)
12:45:14 <dsal> I realized I never had any production Eiffel.  I built a postgres replication system in it, but clearly I never made anything I thought was useful enough.
12:46:33 <dwts> dsal: I can't yet have an opinion if it's hard or not, but I need to get a better understanding on the function definitions (and how to read them e.g. when reading the haskell docs). Functional programming is not new to me as I've played with scheme before, but I tend to find the parentheses much more readable (so far)
12:47:53 <dsal> Heh.  Yeah.  I used to write a lot of (small) scheme.  It was fine.  ocaml was a bigger step for me.  But I went from "Haskell is really hard and only for elite snobs" to finding it the easiest language to work in for almost anything I want to do.
12:48:26 <dolio> Maybe the problem is that I was content messing around with homework exercises in Haskell, but it seems like a lot of people only want to 'mess around' if it involves a ton of web junk or something.
12:48:38 <dwts> I wish I'll reach that stage, so far it manages to make me feel like a complete idiot :)
12:48:57 <dsal> Yeah, that's why I like the approach of suspending knowledge and watching it all unfold.
12:49:15 <dolio> And all the web junk in Haskell is fancy.
12:49:16 <dwts> the irc community doesn't seem snob at all btw, lots of interesting conversations in here
12:49:19 <dsal> Much of the really cool magic goes away when you become a magician, but then you can still get more done more eaisly.
12:49:43 <dsal> Haskell folks really like Haskell and want everyone to feel the same joy.
12:50:06 <ski> dwts : yea, often it seems newbies goes way overboard with `$' .. i much prefer seeing the brackets, much of the time. using `.' is fine, though
12:50:36 <dsal> If I have a lot of $ in code, it's because I'm shell scripting incrementally in Haskell.
12:50:58 <dwts> ski: I guess the haskell people tried a lot to avoid the parens. You can clearly see that in the funciton definitions
12:51:27 <dminuoso> Question, why exactly do we have no parens for function application?
12:51:30 <monochrom> What dolio said is true of me too. Also generally not just web junk, but overall any "real" "application".
12:51:40 <dsal> dminuoso: You can if you want, but why do you want?
12:51:48 <ski> dminuoso : curried style ?
12:51:55 <ghoulguy> dminuoso: with functions all taking a single argument it probably gets pretty noisy to do it with them
12:51:56 <dwts> I thought hat you can use parens?
12:51:59 <ski> possibly goes back to ISWIM, at least ?
12:52:19 <dwts> s/hat/that
12:52:26 <nshepperd1> too many parentheses spoil the curry
12:52:32 <monochrom> Me, I believe in "stronger foundation before higher ambition". More need to mess around with "toys" to more deeply understand what's really going on, before it's meaningful to try a useful project.
12:52:51 <dolio> Logicians were already avoiding parentheses when Church was around.
12:53:07 <dsal> > subtract (7) (5)
12:53:08 <ski> yea, combinatory logic
12:53:09 <lambdabot>  -2
12:53:10 <dminuoso> Im just wondering whether someone knows what the reason was
12:53:20 <dminuoso> Id say the immediate reason was that Miranda was that way I guess
12:53:28 <ski> Church did curried stylw
12:53:49 <ski> yea
12:53:52 <dminuoso> But, perhaps the origins of parens-less function application are just lambda calculus?
12:53:57 <dwts> I assume the lambda bot is written in haskell too?
12:54:01 <ski> yes
12:54:03 <dwts> nice
12:54:09 <monochrom> If you point at Miranda then you still have the question "so why did they do it this way?"
12:54:13 <dminuoso> Right. :)
12:54:18 <ski> @version
12:54:18 <lambdabot> lambdabot 5.3.0.1
12:54:18 <lambdabot> git clone https://github.com/lambdabot/lambdabot
12:54:24 <dminuoso> My instinct says it was from lambda calculus.
12:54:38 <monochrom> But really you look at eg Landin's papers "f(x)(y)(z)(t)" after a while you would invent "f x y z" too.
12:54:48 <ski> monochrom : the "why ?"s never end :)
12:54:55 <dsal> It also kind of overloads the meaning of ()
12:55:04 <ski> math, yes
12:55:11 <ski> (heavily)
12:55:16 <monochrom> Disgust is the mother of syntax invention. :)
12:55:23 <dminuoso> Well, I was hoping for someone to just have a citation ready "XYZ explained the decision in publication ABC"
12:55:25 <dminuoso> :p
12:55:34 <dminuoso> monochrom: Disgust is sometimes also the child of it.
12:55:46 <dwts> 22:54 < monochrom> Disgust is the mother of syntax invention. :)
12:55:50 <dwts> that quote is gold ^
12:56:04 <ski> there's `@remember', if you think it's memorable enough
12:56:15 <dolio> Back in the 30s and such they were doing `∃ x . P` to avoid the parentheses in `(∃x)(P)` and such. :)
12:56:35 <dminuoso> dolio: hold on, what did the spaces add exactly there?
12:56:46 <dminuoso> `∃x.P` seems clear as well
12:56:46 <dolio> The spaces aren't important. The dot is.
12:56:49 <dminuoso> Ah
12:56:51 <ski> before ⌜(∀x)Px⌝ it was ⌜(x)Px⌝
12:57:00 <dolio> Dot is kind of like $. Low-precedence.
12:57:04 <monochrom> dolio, then I'm really disappointed that many 1960s logic textbooks still go "(∃x)(P)"
12:57:06 <ski> @help remember
12:57:07 <lambdabot> remember <nick> <quote>: Remember that <nick> said <quote>.
12:57:25 <dminuoso> See, the one thing mathematical publications is missing, is fixity declarations of these notations.
12:57:27 <dwts> ah, I see
12:57:51 <ski> the brackets in ⌜(x)Px⌝ comes from the "rounded dent" in Frege's two-dimensional notation for graphical formulae
12:57:53 <dwts> thanks ski 
12:58:01 <dolio> Also you write `P ⊃. Q ⊃ R` to avoid `P ⊃ (Q ⊃ R)`
12:58:24 <ski> yes, there should be a language that picks up the dot notation, instead of brackets
12:58:25 <monochrom> Yikes.
12:58:26 <dolio> Because making it associate one way wasn't a thing yet.
12:58:49 <monochrom> Well there is now a language that picks up the $ notation. It's called Haskell. :)
12:59:23 <ski> it annoyes me when people write `foo $ bar $ ...' or `blah (f $ ...)'
12:59:40 <ski> usually the code is clearer, reinserting the brackets
13:00:07 <dminuoso> my rule of thumb is, ($) is for non-BlockArguments code and liftIO/lift :p
13:00:32 <ski> yea, `lift $ ...',`liftIO $ ...',`return $ ...',`pure $ ...' can be okay
13:01:31 <ski> (but if `...' is just a simple expression (on a single line), with no brackets, i'd usually replace the `$' by brackets, anyway)
13:02:04 <dsal> $ is for the last thing in a chain of .
13:02:17 <Cale> I'm perfectly happy writing stuff like  liftIO . forM blah $ \x -> ...
13:02:38 <dolio> Yeah, putting a $ at the end of a composition is what I usually do.
13:04:50 * nshepperd1 can't stop thinking about that idea of abusing BlockArguments to substitute indentation for parentheses
13:04:58 <Cale> P ⊃: Q ⊃. R ⊃ S for P ⊃ (Q ⊃ (R ⊃ S))
13:05:04 <dolio> nshepperd1: Yeah, can't say I'm a fan of that.
13:05:04 <Cale> moar dots
13:05:22 <Cale> That'll be a 50 dkp minus for parens
13:05:28 <dolio> Cale: You're not thinking creatively enough.
13:05:32 <dminuoso> nshepperd1: can you elaborate?
13:06:01 <ski> nshepperd1 : yea, i'll need to think about that
13:06:02 <dolio> P ⊃ Q .⊃. P ⊃ R
13:06:39 <ski> that's ⌜(P ⊃ Q) ⊃ (P ⊃ R)⌝
13:06:50 <dolio> Yeah, obviously. :)
13:07:11 <dwts> dsal: I'll probably get the book you suggested
13:07:33 <Cale> The periods are literal pauses in speech
13:07:35 <dwts> looks promising
13:07:38 <Cale> haha
13:07:50 <ski> but then the periods were also used for conjunction, at the same time
13:08:06 <Cale> If you were speaking "P implies Q ... implies ... P implies R", people would know where you wanted the parens
13:08:12 <dsal> dwts: I've found the slow path the fastest way to get there.
13:08:17 <dolio> You can put them on any connective.
13:08:56 <dwts> dsal: what do you define as slow path here?
13:09:41 <dolio> I was looking at Church's simple type theory recently, and one of his core things is 'A' which stands for ∨.
13:10:12 <dsal> dwts: That book starts with really basic fundamentals that kind of seem obvious, but walks you through layers in a fairly slow, but deliberate way, building on things until, instead of running around asking people to explain what a Monad is, you find yourself wanting a solution to a problem and realize that the name of that solution is Monad (or whatever part you're on).
13:10:23 <ski> Cale : some math teacher got a bit confused, at one point, when i used indentation rather than brackets, for indicating precedence
13:10:52 <ski> hm, for "Alternative" or something like that, dolio ?
13:10:59 <dsal> dwts: e.g., instead of just throwing cool magic things at you, it shows you how function application works.  And then you build on that.  By the time you get to magic, there's no magic left.
13:11:08 <dolio> I have no idea. I guess that makes more sense.
13:11:19 <dwts> dsal: that sounds encouraging. No that I don't enjoy to other people more knowledgable than me, but the best way to learn is by reading/experimenting on your own
13:11:24 <dsal> dwts: vs. trying to take a concept you know and "translate" it to Haskell and then maybe stuff in an advanced concept.
13:11:37 <Cale> dolio: 'A' for "or"?
13:11:44 <dsal> To be fair, I did a lot of this in parallel with solving problems I had.
13:11:49 <dwts> yeah, that is very common (trying to translate from other langs)
13:11:57 <dolio> Cale: Yeah. Then p∧q = ¬(¬p∨¬q).
13:12:18 <dwts> dsal: it's hard to stay 100% on a book's exercises/examples
13:12:27 <ski> hm, Frege had conjunction, negation, universal, as primitives
13:12:27 <dwts> as you try new things, new ideas pop up usualy
13:12:29 <dwts> usually*
13:12:36 <ski> hmm
13:12:42 <dsal> Yeah, exercises are often too narrow to really understand what they're doing.
13:12:45 <ski> or was it implication, rather than conjunction ?
13:12:46 <dwts> so you want to try them while you learn that new language
13:13:11 <dwts> in any case, I need to go offline, long day tomorrow
13:13:17 <dsal> I really enjoy doing Advent of Code in Haskell.  Lots of applied knowledge.
13:13:18 <ski> ah, it was implication
13:13:22 <dwts> thank you all for your help
13:13:24 <dwts> cheers
13:13:33 <dwts> dsal: note taken
13:13:33 <no-n> dsal, what book?
13:13:33 <ski> have fun, dwts !
13:13:52 <ski> @where HPFFP
13:13:53 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
13:15:19 <no-n> oh, ok. that one is still on my reading list :p
13:16:26 <nshepperd> dminuoso: i forget exactly how the person i saw using it had things laid out, but like this https://zlkj.in:8778/uploads/33f4737ce81a95c4/lisp.hs
13:17:11 <dminuoso> Cunning.
13:17:39 <ski> nshepperd1 : reminds me of <https://srfi.schemers.org/srfi-49/srfi-49.html>
13:17:46 <dminuoso> % :t (do 'c')
13:17:47 <yahb> dminuoso: Char
13:17:49 <dminuoso> Wow fancy.
13:17:54 <nshepperd> or like this https://zlkj.in:8778/uploads/9e74cf0ad48d0794/lisp.hs
13:17:55 <dminuoso> What does do even do. :<
13:17:59 <ski> GHC generalization
13:18:02 <ski> @undo do x
13:18:02 <lambdabot> x
13:18:06 <nshepperd> endless possibilities xD
13:18:13 <shapr> that's wild
13:18:33 <dminuoso> I think Ill just sneak some (do work) bits into my code
13:18:42 <dminuoso> Just to confuse future generations
13:19:02 <dminuoso> (do work) `and` fix error
13:23:16 <ski> > do let in [do () | let,do let {}; not otherwise,case () of]
13:23:18 <lambdabot>  []
13:24:18 <nshepperd> % do it
13:24:18 <yahb> nshepperd: 1
13:25:08 <Cheery> I came from python2 to code haskell stuff, now to get a autosummarizer I'm still installing python3, tensorflow, torch, transformers, then have pipeline download gig-large models to summarize articles for me.
13:26:26 <nshepperd> i wish you luck in your impossible quest
13:27:59 <dminuoso> ski: that's not bad
13:29:14 <Cheery> I was going to make a python deprecation alliance, now I got to write a footnote "summarized with tensorflow&pals"
13:30:50 <bsima> if I do random.getrandbits(128) in python, what is the equivalent in Haskell?
13:31:19 * hackage uniqueness-periods-vector-properties 0.5.3.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.5.3.0 (OleksandrZhabenko)
13:32:59 <dminuoso> bsima: You could use the hackage package `random`
13:33:21 <dminuoso> `genShortByteString 16 g` for a suitable RandomGen g
13:33:29 <dminuoso> Or maybe some other variants, depends a bit on your usecase
13:33:57 <Cheery> are there well-defined ways to seed it?
13:34:22 <Cheery> because you could use genWord64 twice.
13:34:32 <dminuoso> Sure
13:34:42 <dminuoso> I mean it depends really on what you want the random data for.
13:36:25 <nshepperd> % do id or do Just do not do otherwise
13:36:25 <yahb> nshepperd: False
13:36:28 <Cheery> Hm.. yeah, you seem to be able to do plenty of tricks with that stuff.
13:36:41 <dsal> I agree with yahb on tha tone.
13:40:52 <dminuoso> % Just do fix error
13:40:53 <yahb> dminuoso: ; <interactive>:1:6: error:; Unexpected do block in function application:; do fix error; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
13:41:00 <dminuoso> Gah! Im fighting with someone here.
13:41:05 <dminuoso> % :set -XBlockArguments
13:41:05 <yahb> dminuoso: 
13:41:07 <dminuoso> % Just do fix error
13:41:13 <yahb> dminuoso: Just "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** 
13:41:15 <dminuoso> Someone keeps turning the above extension off.
13:43:48 <bsima> dminuoso: i see, my version of random is 1.1, all the good stuff is in 1.2
13:44:58 <dminuoso> bsima: What do you need the random data for?
13:45:34 <bsima> i just need a uid
13:46:02 <bsima> maybe i'll use the uuid package instead, i don't think i have a constraint for 128=-bits specifically
13:46:36 <dsal> I like the uuid package on occasion.
13:46:43 <dminuoso> Fun fact
13:46:54 <dminuoso> There's an entry in procfs that generates uuids: `/proc/sys/kernel/random/uuid`
13:47:37 <bsima> cool, unfortunately i'm on mac at the moment
13:48:29 <dminuoso> bsima:  Random Word64
13:48:39 <phadej> % Just do fix error
13:48:40 <yahb> phadej: ; <interactive>:1:6: error:; Unexpected do block in function application:; do fix error; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
13:48:43 <phadej> :(
13:48:50 <dminuoso> % :set -XBlockArguments
13:48:50 <yahb> dminuoso: 
13:48:53 <phadej> % Just do fix error
13:48:59 <yahb> phadej: Just "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** 
13:49:01 <phadej> % Just do it
13:49:02 <yahb> phadej: ; <interactive>:1:6: error:; Unexpected do block in function application:; do it; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
13:49:07 <phadej> what
13:49:09 <phadej> % :set -xBlockArguments
13:49:10 <yahb> phadej: Some flags have not been recognized: -xBlockArguments
13:49:10 <dminuoso> Someone keeps flipping it off
13:49:14 <phadej> % :set -XBlockArguments
13:49:15 <yahb> phadej: 
13:49:17 <phadej> % Just do it
13:49:18 <yahb> phadej: Just ()
13:49:22 <phadej> % Just do fix error
13:49:27 <yahb> phadej: Just "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** 
13:49:33 <phadej> % :set -XBlockArguments
13:49:34 <yahb> phadej: 
13:49:36 <phadej> % Just do it
13:49:36 <yahb> phadej: Just ()
13:49:38 <int-e> Uhm
13:49:44 <phadej> I guess it flips on exception
13:49:48 <int-e> doesn't yahb answer privmsgs?
13:49:58 <dminuoso> int-e: No it does not. It only answers in #haskell
13:50:00 <dminuoso> Clearly.
13:50:04 <dminuoso> Otherwise we'd be using queries.
13:50:25 <int-e> Well that's weird, because it works for me :-P
13:50:54 <monochrom> Some kind of selection bias.  (OK I know I know, you were joking. :) )
13:50:56 <dsal> Yeah, I usually have private dialogues with yahb and lambdabot.
13:51:20 <dminuoso> oleg does not simply have a private chat with yahb.
13:51:28 <phadej> let's try again
13:51:35 <phadej> % :set -XBlockArguments
13:51:35 <yahb> phadej: 
13:51:42 <phadej> % error "foo"
13:51:42 <yahb> phadej: *** Exception: foo; CallStack (from HasCallStack):; error, called at <interactive>:5:1 in interactive:Ghci6
13:51:47 <phadej> % Just do it
13:51:48 <yahb> phadej: Just 1
13:51:56 <dminuoso> phadej: Oh I have an idea.
13:51:58 <phadej> someone is playing with it concurrently!
13:52:02 <phadej> % Just do it
13:52:02 <yahb> phadej: Just (Just 1)
13:52:03 <dminuoso> Maybe, `fix error` hangs yahb
13:52:13 <dminuoso> so it gets killed off, and that resets the flags
13:52:15 <phadej> because that `1` could come from just somewhere
13:52:18 <phadej> % Just do it
13:52:18 <yahb> phadej: Just (Just (Just 1))
13:52:33 <dminuoso> % fix error
13:52:39 <yahb> dminuoso: "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Excep
13:52:40 <dminuoso> % Just do it
13:52:40 <yahb> dminuoso: ; <interactive>:1:6: error:; Unexpected do block in function application:; do it; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
13:52:49 <monochrom> Ah, yeah.
13:52:51 <dminuoso> Yeah, I think it's that `fix error` hangs yahb.
13:53:30 <monochrom> It's an infinite loop printing that infinite string. Gets timed out and killed. The watchdog starts a new one.
13:54:23 <monochrom> As a corollary, if you want a reset, just use :quit to tell it to quit, the watchdog will start a new one too.
14:03:16 <ghoulguy> Good dog
14:13:13 <Cheery> wee.. these guys haven't solved what to do if the text is longer than what the program is meant to process.
14:16:10 <Cheery> it's interesting though.. should the summarizer run twice on the content? Or should there be sentiment analysis that identifies non-important parts of the text first?
14:29:55 <nshepperd> first summarize the first half, then summarize the second half, then summarize the two summaries
14:31:31 <monochrom> That doesn't bode well when each half establishes context for the other half.
14:32:33 <monochrom> Or rather, e.g., the last sentence of the first half is useful when summarizing the second half.
14:33:44 <monochrom> And so I propose a sliding window scheme. For every i, summarize from byte i to byte i+N, where N is the input length limit of the summerizer algorithm.
14:33:53 <sshine> I'm writing a Megaparsec parser for an AST made recursive with Data.Fix. before Data.Fix I would write e.g.: InfixL (Mul <$ symbol "*") -- with Mul :: Expr -> Expr -> Expr. but with Data.Fix, I need to replace 'Mul' with '\a b -> Fix (Mul a b)'. is there a convenient way to overcome that?
14:34:18 <monochrom> Then perhaps summarize the concatenation of those outputs. And perhaps one more level above that, as necessary.
14:35:05 <ghoulguy> sshine: When you're using Fix it's not uncommon to then name the constructors wrapped in fix
14:35:15 <ghoulguy> mul x y = Fix (Mul x y)
14:35:46 <sshine> ghoulguy, as part of the module where the AST lives in?
14:36:02 <sshine> that certainly makes my tests look nicer.
14:36:21 <ghoulguy> or even with pattern synonyms to do that
14:36:30 <ghoulguy> yeah, close to the AST definition makes sense
14:36:31 <monochrom> It certain makes good sense for a module to provide convenience for its user and use cases.
14:36:51 <sshine> I sense TH opportunity, and I sense that maybe recursion-schemes did something here.
14:36:56 <ski> sshine : you could define pattern synonyms
14:37:07 <monochrom> Now, if you also find that when writing pattern matching, "f (Fix (Mul a b)) = ..." is very tiresome...
14:37:19 <ski> what monochrom was about to say
14:37:30 <monochrom> then what ski said. Pattern synonyms solves both problems. Two birds in one stone.
14:37:32 <ghoulguy> You're going to find using Fix is tiresome in general
14:37:35 <sshine> I don't actually pattern match much on the Fix thingy because of all the convenience combinators.
14:37:51 <sshine> ghoulguy, oh, thanks for the heads up.
14:38:13 <monochrom> And as well, it's desired to define the pattern synonyms in the AST module and export them, so users benefit.
14:38:14 <sshine> I was wanting to save lines doing passes. :)
14:38:33 <monochrom> s/desired/desirable/
14:39:10 <monochrom> pattern synonym = smart constructors and deconstructors
14:39:22 <monochrom> well, bidirection pattern synonym
14:39:24 <sshine> right.
14:39:40 <sshine> I've tried pattern synonyms. seems neat.
14:44:19 * hackage wolf 0.3.48 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.48 (markfine)
14:45:14 <sshine> ghoulguy, so you wouldn't pick data-fix/recursion-schemes for an AST at some point in the near future?
14:48:06 <monochrom> I am not ghoulguy, but I found recursion schemes ineffective in cost-benefit. For all its extra Fix annoyance, it saves you, what, from writing an easy-to-write catamorphism?
14:48:28 <dsal> I kind of wish I knew what recursion schemes was.
14:49:16 <monochrom> Instead, I find "data types a la carte" much more worthwhile, if you plan an extensible AST and interpreter etc.
14:49:48 <ski> i still would like to be able to turn `splitPrefix' into a pattern synonym ..
14:50:16 <dminuoso> dsal: The motivation is actually quite simple.
14:50:29 <dminuoso> % foldr (+) 0 [1..10] -- dsal 
14:50:29 <yahb> dminuoso: 55
14:50:31 <monochrom> There are even many free monads that I would rather hand-write than use the free monad library. Unless I want that library's feature of making things efficient.
14:50:49 <dminuoso> dsal: Do you see, how foldr lets us hide the recursion, instead we can just sort of talk about (+) and 0 here.
14:51:02 <dminuoso> Recursion schemes is about exploring such ideas. :)
14:51:08 <dminuoso> (Very handwavingly)
14:51:16 <ski> (perhaps with a focus on "exploring")
14:51:34 <dsal> I get it at that level, but the last time I looked at it, it required a lot of commitment to get started.
14:53:10 <dsal> A single word of documentation would be pretty great.  Some are documented, but there's stuff like `gzygo :: (Recursive t, Comonad w) => (Base t b -> b) -> (forall c. Base t (w c) -> w (Base t c)) -> (Base t (EnvT b w a) -> a) -> t -> a`
14:54:22 <dsal> This is the most haskell section header I've ever seen on a web page, though:   Zygohistomorphic prepromorphisms
14:55:22 <topos> what's so hard about a zygohistomorphic prepromorphism? it's just a zygomorphic histo that's also prepromorphic
14:55:58 <dminuoso> @remember topos what's so hard about a zygohistomorphic prepromorphism? it's just a zygomorphic histo that's also prepromorphic
14:55:59 <lambdabot> I will remember.
14:56:06 <topos> LOL
14:57:07 <ski> monochrom : at first i read "hand-wave"
14:58:04 <monochrom> @quote olsner zygohistomorphic
14:58:04 <lambdabot> olsner says: nah, SkyNet is just a zygohistomorphic prepromorphism, nothing fancy
14:59:49 * hackage cut-the-crap 2.0.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-2.0.0 (Jappie)
15:01:33 <phadej> reminds me of
15:01:35 <phadej> The full chemical name of the human canonical form of titin, which starts methionyl... and ends ...isoleucine, contains 189,819 letters 
15:01:51 <monochrom> eek
15:02:17 <dsal> phadej: Please use a pastebin.
15:02:24 <monochrom> haha
15:03:10 <phadej> FWIW, the pieces of that protein are quite simple in separation ;)
15:04:07 <hpc> jeez, it might as well be DNA at that point
15:05:22 <phadej> Titin is a giant protein, greater than 1 µm in length,
15:06:10 <phadej> dna does encode how to make one :)
15:09:49 <dsal> I think I may have gone from mocking recursion-schemes to consider applying it to something.
15:13:35 <monochrom> "First you ignore it. Then you laugh at it. Then it wins"? >:)
15:21:47 <dsal> I thought I used fixM or something like that once, but I can't find it.
15:44:18 <dsal> WEren't we having this conversation earlier?  https://twitter.com/elonmusk/status/1314666526297923585
15:50:04 <Guest18> Can I pattern match with `case ... of ...`?
15:50:20 <dsal> I don't exactly understand what you're asking, but yes.
15:51:07 <dsal> > case odd 3 of True -> "yes"; False -> "no"
15:51:11 <lambdabot>  "yes"
15:51:49 <Guest18> that's all i needed to know, thank you
15:51:51 <dsal> > case pure 3 of Just 3 -> "yes"; _ -> "no"
15:51:54 <lambdabot>  "yes"
15:52:25 <Guest18> was looking into ways of making my code a bit prettier and readable, as i'm not entirely happy with it
15:52:54 <Guest18> it's the code for deleting a value from a binary search tree
15:53:44 <dsal> I don't use case all that much.  It's not obvious I'd fit it into something like that.  What's your code look like currently?
15:54:27 <Guest18> https://dpaste.com/D2N9HH7UH
15:54:44 <Guest18> I included only the relevant parts, i have more
15:55:48 <dsal> I'd just use a guard instead of that case.
15:55:57 <Guest18> deleteOn seems to me like it could use a little refactoring
15:56:30 <Guest18> so would i, but in this case, i only compare once
15:57:18 <dsal> Sure, it's clear enough.
15:57:44 <Guest18> any other suggestions? how would you do it?
15:58:39 <dsal> I tend not to use let like you're doing in deleteOn.  where is a bit nicer there, I think.
15:58:45 <dsal> Also, have you considered making your BST Foldable?
15:59:09 <dsal> `foldr1 min (flatten right)` is basically `minimum right`
15:59:11 <Guest18> Yes, I did, but I do not posses the knowledge to know how to do it
15:59:35 <Guest18> I know what the typeclass is, i don't know how to make it an instance of Foldable though
15:59:59 <monochrom> Foldable is going to be a distraction at this stage.
16:00:06 <Guest18> yeah, actually where would be nicer, thank you
16:00:59 <dsal> Well, I guess in any case, `foldr1 min` is `minimum` -- both are partial.
16:02:21 <monochrom> "deleteBST nextSuccesor left" sounds like simply "left".
16:02:52 <monochrom> "foldr1 min (flatten right)" sounds like "head (flatten right)"
16:04:11 <monochrom> in the context of binary search trees, that is
16:04:18 <Guest18> i understand the latter, but the former seems weird
16:04:56 <Guest18> if i said simply left, how would i delete the extra node left there? I would have duplicates in the tree
16:05:00 <monochrom> The successor is from the right subtree only, so there is no need to modify the left subtree?
16:05:20 <Guest18> Oh
16:05:30 <Guest18> Yeah, that makes sense
16:06:57 <Guest18> Yeah, since flatten traverses the tree in order, the resulting list is sorted, so the minimum is the head, i didn't think of that
16:07:00 <dsal> Oh, `deleteOn` is slightly misleading.  I didn't actually read it.  heh.  If you're not using `x` it'd be clearer to not name it.
16:07:53 <monochrom> Nice. In that case get rid of the parameter altogether.
16:08:00 <Guest18> actually, it is never used, so why bother taking as a parameter
16:10:43 <Guest18> https://dpaste.com/3PXJGRMV8 -- new version
16:10:53 <Guest18> I am actually quite happy with this
16:12:30 <Guest18> It feels good to actually make something useful with a new language you just started learning
16:13:32 <Guest18> any ideas for projects that i can do with haskell?
16:15:15 <Guest18> I was thinking of making a small shell with haskell, like a restricted version of bash - only the basic commands
16:21:37 <Guest18> I reckon you don't dig the idea?
16:22:21 <Clint> i think it's a great idea
16:27:19 * hackage web-plugins 0.3.0 - dynamic plugin system for web applications  https://hackage.haskell.org/package/web-plugins-0.3.0 (JeremyShaw)
16:27:49 <Guest18> Awesome! I will get around to it soon. I still have more to learn about IO, and it does seem pretty scary
16:33:19 * hackage citeproc 0.1 - Generates citations and bibliography from CSL styles.  https://hackage.haskell.org/package/citeproc-0.1 (JohnMacFarlane)
16:35:35 <ski> Guest18 : `deleteOn' could be called `merge' ?
16:37:30 <ski> redundant brackets in `flatten'
16:38:55 <ski> i might define a `splitMin' operation, that both gives the minimum, and the remaining tree
16:39:24 <Guest18> ski: I mean, I don't really see how it merges stuff any more than the other functions, and I wanted to emphasize that it has a connection with deleteBST, same way I did with `depth` and `depthGo` earlier. It seemed appropiate, because it deletes the root on that subtree
16:40:28 <Guest18> how would i implement splitMin?
16:43:26 <dsal> Guest18: one way to emphasize that connection is to stick it in a where clause where it's used.  :)
16:43:44 <ski> the minimum element is always in the left-most leaf
16:44:39 <ski> Guest18 : your `deleteOn' takes two trees (and an element that's always ignored), and combines them into a single tree
16:44:58 <Guest18> dsal: but it was too big for a where clause, wasn't it?
16:45:05 <ski> (ah, sorry, in your last paste version, you didn't pass it the element)
16:45:40 <bliminse> Guest18: unrelated to current query, but before on project suggestion, I liked what you said but you may wanna try a more specific one first to learn IO and other bits
16:45:58 <dsal> Guest18: too big?  It's never too big!  :)
16:46:02 <bliminse> you could try something like parsing git log results and constructing a tree
16:46:15 <ski> if you wanted `deleteOn' to be an implementation detail of `deleteBST', you could define `deleteOn' inside a `where' attached to `deleteBST'
16:46:36 <bliminse> i.e., if you have any git repo run git log --pretty="tformat:%h{%aI{%an{%d{%s" | column -t -s '{' and save that to file
16:46:46 <ski> but merging two `BST's sounds like it could be an independently interesting operation
16:47:07 <ski> (ah, i see dsal was talking about the same thing)
16:47:29 <bliminse> then you can pick up skills on reading/parsing, building a tree, optionally doing some folding on the tree to gather stats (e.g., number of commits per year/month), then write stats to a file
16:47:31 <Guest18> bliminse: this is good stuff, what else do you got?
16:47:53 <bliminse> so you pick up read, parse, folds/unfolds, writing, and who knows what else xD
16:48:30 <Guest18> ski: I didn't know `where` can fit function definitions longer than a line
16:49:45 <Guest18> Although it does make sense now that i think about it, otherwise i couldn't have made this module, as it uses a where in the beginning
16:51:42 <ski> Guest18 : ah. now you know :)
16:51:54 <ski> you can, of course, also put type signatures in there
16:53:12 <Guest18> So you're saying make deleteOn to be merge, that takes 2 BSTs and merges them, and i can apply the deleteBST to the left subtree before giving it to merge, and then construct a minSplit function and define it in a where clause in deleteBST, that will return the minimum of the right subtree, aka head (flatten right)
16:53:22 <Guest18> am i undersanding this correctly?
16:55:37 <ski> why apply `deleteBST' ?
16:56:06 <ski> `minSplit' would not be defined locally, since it could well be a common operation a user could want to do
16:56:41 <ski> and your `deleteOn'/`merge' could be defined, in terms of `minSplit'
16:56:57 <ski> (instead of using `flatten' and `deleteBST')
16:59:01 <Guest18> I am sorry, but I don't see how this would eliminate deleteBST from being called in `merge`
16:59:11 <Guest18> I still need it
16:59:56 <Guest18> I am also really really tired, it's 3 AM here
17:03:37 <Guest18> the edges of the screen are starting to get blurry
17:06:04 <dsal> Sleep solves a lot of programming problems.
17:07:23 <Guest18> Schlafen is fur die Schwachen
17:08:14 <Guest18> ist
17:16:33 <ski> Guest18 : why do you need it ?
17:17:11 * ski . o O ( "Ich will mit mein Kopf arbeiten. Am liebsten möchtest ich schlafen." )
17:18:42 <MarcelineVQ> ichkabibble
17:19:55 <Guest18> I need it to delete the duplicate from the right subtree. If the element i need to delete has two subtrees, i take the minimum from the right subtree, as discussed, and set it as the new root. If i stop there, that minimum element from the right subtree is still there, resulting in a duplicate in my tree
17:20:48 <ski> yes. that's why i thought using a `splitMin' would be nicer there
17:21:24 <Guest18> So splitMin would return the minimum and the tree without that minimum, you say
17:22:01 <Guest18> i a tuple
17:22:04 <Guest18> in*
17:22:53 <Guest18> right, ski?
17:24:03 <ski> yes
17:27:15 <Guest18> ok, will do it tomorrow
17:27:22 <Guest18> i seriously need to sleep now
17:27:38 <Guest18> goodbye, for now
17:30:05 <mcmoor> I think I might re ask my question I have data CT (c :: Color) (a :: *) where   E  :: CT Black a   T  :: Valid c c1 c2 =>          SColor c -> (CT c1 a) -> a -> (CT c2 a) -> CT c aclass Valid (c :: Color) (c1 :: Color) (c2 :: Color) whereinstance Valid Red Black Black instance Valid Black c1 c2
17:31:06 <mcmoor> https://repl.it/repls/DisastrousClientsideDataset#main.hs
17:31:51 <mcmoor> I thought that because of Valid the tree only allows Red Black Black or Black (any color) (any color)
17:32:00 <mcmoor> But then there's this code
17:32:02 <mcmoor> redden :: CT c a -> DT aredden (T B a x y)  = DT R a x yredden (T BB a x y) = DT B a x yredden (T R a x y)  = DT NB a x yredden (T NB a x y)  = error "Nope"
17:32:19 <mcmoor> and somehow it's compiled eventhough the tree contatins NB and BB
17:36:52 <dolio> I don't understand the problem.
17:39:55 <mcmoor> the Valid Instance only allows Valid Red Black Black and Valid Black c1 c2
17:40:21 <dolio> Those are the only ones you wrote so far.
17:41:04 <dolio> Matching on a GADT doesn't go look for which typeclass instances have been written currently to filter out cases.
17:41:45 <dolio> If you want that, then Valid should probably be a GADT.
17:42:04 <dolio> E.G. instead of the singleton colors, make it a relation GADT.
17:43:14 <mcmoor> Oh really? Interesting
17:43:30 <mcmoor> This is not my code and I'm trying to understand how it works
17:44:13 <ski> (or a type family ?)
17:44:17 <mcmoor> But like in GHCI I can't make something like (T BB a x y) or (T NB a x y) without being scolded by the compiler so I'm confused why it allows this one
17:44:25 <dolio> Yeah, there are probably multiple ways to do it.
17:44:34 <ski> (a closed one, i mean)
17:48:42 <dolio> I think the issue with that would be that GADTs (inductive families) are kind of genuinely different than type families (recursively defined types) in Haskell, because of bottom.
17:49:30 <dolio> Or maybe the coverage checker is smart enough for that, I'm not sure.
17:53:35 <dolio> mcmoor: Yeah, you can't build them, because there's no instance in scope to build them.
17:53:48 <dolio> But you can't assume that a function won't receive one.
17:55:09 <dolio> Type classes aren't closed, so in principle, someone could write an instance, build one, and give it to your function.
17:56:31 <mcmoor> Oh yeah I just remember than you can add instances in other program
17:56:58 <mcmoor> So now I'm questioning the intent of the code author... Thank you very much!
17:57:44 <dolio> Even if you could reason from all the instances in scope that no others could be declared under GHC's rules, you still can't really assume that.
17:57:58 <dolio> Because it's not that sophisticated.
18:32:20 * hackage hasql-dynamic-statements 0.3 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.3 (NikitaVolkov)
18:50:50 * hackage Z-IO 0.1.4.0 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.4.0 (winterland)
19:45:46 <sepi> Might be a dumb question but if I wanted to pair two numbers, can I just do list comprehension for that
19:46:10 <ghoulguy> What would lists have to do with it?
19:48:01 <sepi> Finite state machine doing the union function, for the start state. I believe they just start simontaenously so  they are just paired like (s1, s2)
19:50:56 <dsal> pair sounds a lot like a tuple.
19:51:01 <dsal> Yeah, that's a tuple.
19:51:13 <dsal> Perhaps you could expand your problem statement a bit.
19:51:37 <c_wraith> or at least explain why you think lists are involved.  that question is still standing.
19:51:53 <ski> sepi's doing finite state machines, iirc ?
19:52:43 <ski> sepi : if you want to pair corresponding elements, then a plain list comprehension will not do that
19:53:06 <ski> > [(s,t) | s <- [0,1,2],t <- [3,4,5]]
19:53:08 <lambdabot>  [(0,3),(0,4),(0,5),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
19:53:14 <ski> > zip [0,1,2] [3,4,5]
19:53:17 <lambdabot>  [(0,3),(1,4),(2,5)]
19:53:54 <ski> > [(s,t) | s <- [0,1,2] | t <- [3,4,5]]  -- using the `ParallelListComp' language extension
19:53:56 <lambdabot>  [(0,3),(1,4),(2,5)]
19:54:43 <MarcelineVQ> you've gone mad with power
19:55:37 <sepi> https://dpaste.org/d6WS
19:56:49 <sepi> >zip 1 2
19:56:58 <ghoulguy> > (1, 2)
19:57:00 <lambdabot>  (1,2)
20:01:34 <ski> how's `(><)'
20:01:39 <ski> defined ?
20:04:49 <sepi> From my understanding its a Cartesian product function 
20:05:17 <sepi> xs >< ys = [(x,y) | x <- xs, y <- ys].   or is that exactly the same thing of what I was trying to do
20:05:27 <ski> yes, that's cartesian product
20:05:35 <sepi> 👍
20:08:50 * hackage micro-gateway 1.1.0.1 - A Micro service gateway.  https://hackage.haskell.org/package/micro-gateway-1.1.0.1 (Lupino)
20:19:42 <sepi> https://dpaste.org/ajxX
20:20:34 <sepi> for trans function am I just literally translating it like that
20:20:45 <sepi> The comment has what I'm going off of
20:20:52 <koz_> The wince operator?
20:55:59 <slack1256> If I want to do native UI and FRP, which libraries will give me the least friction?
20:56:40 <slack1256> I've only done gi-gtk and I liked it. But I haven't seen the FRP light apart from some SwiftUI usage (which is just reactive).
21:15:49 * hackage formatting 7.0.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  https://hackage.haskell.org/package/formatting-7.0.0 (AlexChapman)
21:39:50 * hackage longshot 0.1.0.0 - Fast Brute-force search using parallelism  https://hackage.haskell.org/package/longshot-0.1.0.0 (thyeem)
21:54:19 * hackage longshot 0.1.0.1 - Fast Brute-force search using parallelism  https://hackage.haskell.org/package/longshot-0.1.0.1 (thyeem)
21:56:19 * hackage formatting 7.0.0.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  https://hackage.haskell.org/package/formatting-7.0.0.1 (AlexChapman)
23:28:50 * hackage tasty-test-reporter 0.1.1.2 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.1.2 (JasperWoudenberg)
23:36:49 * hackage longshot 0.1.0.2 - Fast Brute-force search using parallelism  https://hackage.haskell.org/package/longshot-0.1.0.2 (thyeem)
23:41:50 * hackage reanimate-svg 0.13.0.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.13.0.0 (DavidHimmelstrup)
23:43:25 * hackage pretty-diff 0.2.0.2 - Pretty printing a diff of two values.  https://hackage.haskell.org/package/pretty-diff-0.2.0.2 (JasperWoudenberg)
