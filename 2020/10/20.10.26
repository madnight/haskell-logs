01:56:29 <Unhammer> Anyone remember that quote, possibly from this channel, that went something like "listening to someone explain git oh no he's going to say DAG" ? Can't find it on bash.org =P
02:10:09 <tomsmeding> Unhammer: from how long ago?
02:20:32 <Unhammer> oh no idea ‚Ä¶ 
02:36:57 <simon> Unhammer, never heard it. sounds fun.
03:11:19 * hackage ngx-export-tools-extra 0.5.6.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.6.1 (lyokha)
03:18:49 * hackage ngx-export-tools-extra 0.5.6.2 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.6.2 (lyokha)
03:47:19 * hackage configurator-pg 0.2.5 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.2.5 (vollmert)
04:20:46 <tomsmeding> merijn: forgive the off-topic question but do you have a vim binding for :pclose, and if so what :p
04:27:16 <maerwald> <leader>pc
04:51:42 <tomsmeding> it does roll fairly nicely, I guess it works
04:51:54 <Uniaika> oh, hi tomsmeding :)
04:52:33 <tomsmeding> hi Uniaika :)
04:52:53 <Uniaika> tomsmeding: how are you doing?
04:53:28 <tomsmeding> thesis project :p
04:53:40 <tomsmeding> and migrating from languageclient-neovim to ALE
04:54:01 <tomsmeding> ALE doesn't use neovim's floating window and that annoys me, hence the question above :p
04:54:47 <Uniaika> I do use coc.nvim which works perfectly fine for that :P
04:55:04 <Uniaika> (and it renders the markdown output of hie, contrary to LC-neovim)
04:55:37 <maerwald> coc.nvim is like running an entire website inside my edtior... it's scary (and similarly broken)
04:57:27 <yushyin> you even need nodejs ...
04:58:06 <maerwald> it also lights up my editor like a christmas tree... I'm surpised there are no floating window ads
04:58:11 <tomsmeding> I've been attempting to avoid coc.nvim but perhaps I'll have to descend to it at some point
04:58:42 <yushyin> at that point you can just use vscode
04:59:08 <maerwald> yes and it's actually a better experience
04:59:18 <maerwald> except for editing xD
05:00:43 <Uniaika> I too despise the necessity of using nodejs
05:01:07 <Uniaika> but at some point I make the choice of having a working and full-featured LSP client :P
05:01:15 <Uniaika> LC-neovim does not qualify
05:01:33 <maerwald> why
05:02:31 <tomsmeding> LC-neovim completely fails somehow with ghcide
05:02:54 <tomsmeding> if you edit a file, then ~50% of the time imports of that file in all the other modules are suddenly unresolved
05:03:24 <tomsmeding> part of the problem was that file watches were mostly unimplemented in LC-neovim, which I fixed with a PR, but either my code also fails or something else is still broken
05:03:28 <maerwald> works here, except that hls signal handling is fishy and eventually all LSP clients fail and spawn too many instances or fail to shut down exising ones
05:03:48 <tomsmeding> I hope ALE does that better but I haven't stress-tested it yet :p
05:04:13 <tomsmeding> maerwald: I'd like to use hls instead of plain ghcide but hls doesn't work on https://github.com/AccelerateHS/accelerate for some reason
05:04:44 <tomsmeding> but the project is huge so submitting a useful bug report is hard
05:05:10 <tomsmeding> (well, "huge" for my standards, which is not all that huge probably)
05:18:49 * hackage tree-monad 0.3.1 - Non-Determinism Monad for Tree Search  https://hackage.haskell.org/package/tree-monad-0.3.1 (nbu)
05:19:10 <Uniaika> ah, finally!
05:19:20 <Uniaika> poor thing was left unmaintained :(
05:19:48 * hackage parallel-tree-search 0.4.2 - Parallel Tree Search  https://hackage.haskell.org/package/parallel-tree-search-0.4.2 (nbu)
05:44:42 <thblt> Stupid obvious question: in a monad transformer stack, an action running in the transformer have access, through lifting, to all the monads in the stack, right?
05:45:19 * hackage ukrainian-phonetics-basic 0.1.4.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.4.0 (OleksandrZhabenko)
05:45:48 <dminuoso> thblt: Right
05:45:54 <thblt> For context, I'm trying to implement a simple guessing game as a ReaderT GameConf (StateT GameState IO)
05:45:58 <thblt> dminuoso: thanks!
05:45:59 <dminuoso> Assuming all transformers have an instance MonadTrans of course.
06:01:50 * hackage Cabal 3.2.1.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-3.2.1.0 (phadej)
06:25:19 * hackage githash 0.1.5.0 - Compile git revision info into Haskell projects  https://hackage.haskell.org/package/githash-0.1.5.0 (MichaelSnoyman)
06:58:54 <thblt> (I just read on some blog post that monad transformers are like onions. If monads are still burritos, the weird consequence is that transformers are both part of the monad as an ingredient, but the monad is part of its own ingredient as one level in a stack.)
06:59:05 <thblt> (tl;dr metaphors are bad)
07:02:30 <[exa]> in metaphor language, leaky onions that grow from inside are apparently perfectly okay!
07:03:24 <thblt> Ho good point.
07:05:40 <tomsmeding> nah, you just get recursive burritos
07:05:56 <tomsmeding> I mean, more burritos, right?
07:05:57 <dminuoso> A recursive burrito is one with one side plugged into the other right?
07:05:59 <dminuoso> A circular burrito
07:06:14 <Uniaika> a mexican doughtnut
07:06:36 <dminuoso> 14:58:43       thblt | (tl;dr metaphors are bad)
07:06:47 <thblt> Isn't it more of a non-euclidian burrito?  
07:07:02 <[exa]> just a klein burrito
07:07:10 <thblt> When you near the center of the burrito where the onions live you're at the same time outside in the presentation plate.
07:07:41 <Uniaika> I have already eaten but I'm hungry again now
07:07:49 <dminuoso> thblt: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
07:08:13 <dminuoso> These metaphors and mindmodels are not bad, they're usually just bad for *explaining*
07:08:28 <dminuoso> The above blog article goes into why
07:08:46 <dminuoso> If "burrito" makes perfect sense to you, then it's an adequate metaphor.
07:10:00 <[exa]> thblt: anyway the most practical "metaphor" I saw is that you just run a program in a DSL 1 that borrows some actions from another DSL 2, and the transformer is a magic burrito-bending function that converts such program to the language of DSL 2
07:10:52 <[exa]> which kinda describes lift/run*T without much unnecessary cutlery
07:10:55 <thblt> dminuoso: as a teacher, in a classroom context, metaphors aren't bad. What's bad (and this article rightfully criticizes) is the confusion between my intuitive understanding of x and the best explanatory analogy for x.
07:11:13 <dminuoso> Even in a classroom context metaphors can be bad.
07:11:27 <thblt> Because the latter doesn't exist.  Teaching is often trying different explanations until one works.
07:11:28 <[exa]> metaphors != illustrative examples
07:12:33 <thblt> Yeah, wrote too fast.  What I meant is that you can use metaphors, but not believe there's one definitive metaphor.  Some people will grab $complex-topic through abstraction, some through examples, some through metaphors.  
07:12:35 <Ferdirand> i thought monads were just type-safe continuations
07:14:05 <dminuoso> The easiest way to think of a monad on K, is as a lax 2-functor from the terminal bicategory 1 to K.
07:14:35 <[exa]> I sometimes wonder that we shall once explain the imperative programming as a metaphor, originating from IO monad
07:15:15 <[exa]> "You know guys, now just imagine that IO is everywhere."
07:15:49 <thblt> That's actually a nice idea.
07:17:46 <[exa]> "But how can everything change the world?" -> "OK look, the programs are like spaghetti"
07:17:59 <[exa]> well now I'm hungry
07:18:29 <dminuoso> [exa]: Maybe a burrito would help?
07:18:35 <dminuoso> with onions.
07:19:35 <[exa]> well tbh I have a Maybe Burrito in FridgeT now
07:19:43 <thblt> Seriously you should eat something then write this because now I want to read it.
07:19:45 <[exa]> (this needs to stop)
07:20:24 <thblt> And in all seriousness it can *also* be a powerful method of explanation.
07:21:31 <[exa]> the greater point is that the students at c++ course sometimes already lack this "basic computers" understanding of instructions that just get executed and everything is a side effect
07:22:30 <[exa]> ("uninitialized memory? that's not like null?!")
07:22:51 <[exa]> so we might even get to the spaghetti analogy sooner than I hope
07:27:03 <Franciman> hi, Standard ML has an easier syntax than Haskell, why don't we change to SML syntax?
07:27:27 <merijn> Define "easier:
07:28:15 <Franciman> it's easier to parse
07:28:17 <merijn> Also, Python syntax is easier than C, so why don't all C compilers just use Python syntax?
07:28:28 <Franciman> because C people aren't open minded
07:28:34 <Franciman> so we could have better tools
07:28:42 <Franciman> for example a good tool to automatically indent haskell code
07:28:46 <merijn> Franciman: And you expect Haskell programmers will throw away 3 decades of work to start over?
07:28:57 <merijn> It will never happen
07:28:58 <Franciman> :<
07:29:03 <Franciman> time to fork!
07:29:04 <Franciman> lol
07:29:11 <merijn> Also, I fundamentally disagree with the notion of autoformatting code
07:29:24 <Franciman> how so?
07:30:54 <merijn> https://twitter.com/comerijn/status/1257804634833420292
07:31:12 <merijn> (specifically the replies)
07:31:24 <Franciman> thranx
07:31:54 <Franciman> oh I see
07:32:01 <Franciman> well my problem is of pragmatic form
07:32:04 <Franciman> I have tendonitis
07:32:09 <Franciman> the less I have to type the better I feel
07:32:24 <Franciman> having my computer automatically position the cursor is RAD
07:32:54 <merijn> Franciman: Did you see the talk on coding by voice?
07:33:12 <Franciman> no
07:33:35 <Franciman> worth a check, thanks
07:33:38 <merijn> https://www.youtube.com/watch?v=8SkdfdXWYaI
07:34:40 <ixlun> How would I generate a random number for every elm in a list to convert to a tuple?
07:35:13 <ixlun> (,) <$> [0,1,2,3] <*> genWord64 would just give me the same val every time 
07:35:13 <merijn> :t randoms
07:35:14 <lambdabot> (Random a, RandomGen g) => g -> [a]
07:35:19 * hackage liboath-hs 0.0.1.2 - Bindings to liboath  https://hackage.haskell.org/package/liboath-hs-0.0.1.2 (parsonsmatt)
07:35:46 <merijn> ixlun: You generate a lazy infinite list of random values :)
07:35:52 <merijn> > randoms (mkStdGen 5)
07:35:54 <lambdabot>  [2287595555194033867,-7444196218550052205,7729549144295431816,-8651862829265...
07:36:05 <merijn> > randoms (mkStdGen 5) :: [Bool]
07:36:06 <ixlun> Ahhh I see
07:36:07 <lambdabot>  [True,True,False,True,False,True,True,True,False,False,True,False,False,True...
07:37:18 <ixlun> Then I can just use zip to get the tuple array
07:37:35 <ixlun> (I need to learn to think lazily!)
07:40:53 <thblt> Re monad transformers, does lift . lift already have a name?
07:42:17 <[exa]> thblt: I guess 'doubleLift' would be longer than 'lift.lift'
07:42:47 <thblt> I thought lift2, but undefined
07:43:02 <[exa]> thblt: anyway people often use typeclasses like MonadReader and MonadState that auto-lift the action to appropriate context
07:45:01 <thblt> Maybe I'm doing something stupid actually!  I have `type Game = ReaderT GConf (StateT GState IO)`, so in `somefunc :: Game ()` I *think* I can only do IO by `lift . lift $ someIoFunction`.  Am I wrong?
07:46:19 <thblt> Er, liftIO
07:47:33 <thblt> Who could have guessed this would be the name of the function to lift into IO? /s
07:48:39 <[exa]> :t liftIO
07:48:41 <lambdabot> MonadIO m => IO a -> m a
07:48:47 <[exa]> there it is, MonadIO
07:49:07 <thblt> [exa]: ]thanks
07:50:44 <ixlun> If I want to index by a data type into an array, do people prefer using Enum and a Vector, or derving Ix and an Array?
07:51:12 <opqdonut> I think nobody uses the Array types any more...
07:51:22 <dminuoso> ixlun: or a map?
07:51:24 <opqdonut> at least for serious software
07:51:36 <ixlun> Why has Array died?
07:51:49 <dminuoso> Enum feels like a horrible kludge for most cases
07:52:00 <dminuoso> It's used incorrectly mostly
07:52:01 <opqdonut> I guess it didn't offer unboxed variants? that's at least one reason to prefer Vector
07:52:21 <opqdonut> also the Vector API is just a bit cleaner maybe? I don't know really
07:52:55 <ixlun> dminuoso: I hadn't thought about using a Map
07:53:07 <opqdonut> Maps tend to be nicer for updates
07:53:36 <ixlun> It's just static data, that I know is going to have a fixed size
07:53:54 <ixlun> seems a shame to incur the performace penalty for lookups when I could index straight to it
07:54:06 <[exa]> ixlun: if you can convert your data to 0..n, just go for the vector :]
07:54:13 <dminuoso> ixlun: Is that code region in a hotspot?
07:54:20 <dminuoso> or do you have your premature optimization hat on?
07:54:37 <dminuoso> If it's the latter, I'd just go for map..
07:54:42 <ixlun> dminuoso: quite possi
07:54:51 <ixlun> possibly!*
07:56:19 <ixlun> [exa]: I have managed to implement Enum for the data type, it's a union of two other types that also dervie Enums so I just shiftR one of the values
07:57:00 <ixlun> Err, `shiftL` sorry
07:58:49 <dminuoso> Is there a cute little high performance prettyprinter with low dependency footprint?
07:59:50 <dminuoso> prettyprinter sadly drags semigroups along with it :(
08:04:07 <[exa]> ixlun: so just wrap the (!) from Vector with your new fromEnum and there you have it :]
08:07:17 <int-e> dminuoso: is that really so bad?
08:09:03 <tomsmeding> opqdonut: https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-Unboxed.html ?
08:11:24 <tomsmeding> I like the fact that 'array' has 0 dependencies
08:13:17 <[exa]> dminuoso: I don't see any other reason for the semigroup dependency other than that they have NonEmpty list instance there... you might just kill it in a local repo copy, if the dependency is the only problem
08:14:53 <tomsmeding> that's an annoying situation in general, I think I've seen stuff pull in aeson just to provide a FromJSON instance or something
08:15:36 <dminuoso> [exa], int-e: semigroups pulls in quite a bunch of libraries 
08:17:26 <dminuoso> At any rate
08:17:29 <dminuoso> https://hackage.haskell.org/package/pretty
08:17:31 <dminuoso> This looks about right
08:17:56 <dminuoso> deepseq is already in my dependency footprint, so this is very very light :)
08:19:32 <[exa]> I'm using this one on tutorials, it's been around forever. It's pretty simple so I didn't expect it would be very fast
08:22:54 <tomsmeding> it seems 'pretty' doesn't have an equivalent of https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Prettyprinter.html#v:flatAlt , does it?
08:23:36 <tomsmeding> if that's true, that alone should make it O(input + output), which is already pretty fast
08:26:37 <int-e> dminuoso: you could play with the flags...
08:27:02 <tomsmeding> oh right it does have 'sep' and friends, which do alternatives, so it'll be slow too
08:29:09 <thblt> For the lazy, is there an automated way to reduce imports to what's strictly required by the module? Ie to turn `import Module` into `import Module (used, or, reexported, names)`?
08:31:57 <tomsmeding> thblt: I don't think there's a tool to do that, but there is also no unique answer
08:32:20 <tomsmeding> what if A and B both export 'foo', and you use 'foo' in a module that has 'import A' 'import B'
08:32:31 <tomsmeding> should the tool add (foo) to A or to B?
08:32:36 <thblt> tomsmeding: isn't this a compile error?
08:32:55 <tomsmeding> not if they were actually the same symbol in the beginning
08:33:05 <thblt> Ha, haven't thought of that.
08:33:13 <tomsmeding> e.g. Foo exports foo, A and B re-export foo from Foo, and Main imports A and B and uses foo
08:33:35 * tomsmeding now wonderse what ghc does if you make both the A and the B import of foo explicit
08:33:44 <thblt> And ghc is happy with that?  As long as the symbol's definition isn't ambiguous?
08:33:48 <tomsmeding> yup
08:34:01 <thblt> Makes sense.
08:35:06 <tomsmeding> if Main has 'import A (foo)' 'import B (foo)', ghc is completely fine
08:35:18 <tomsmeding> I guess that's one way to make the output of our imaginary tool unambiguous?
08:36:03 <thblt> This tool pretends to do that https://github.com/serokell/importify
08:36:06 <tomsmeding> there is already a tool to prune unused imports (https://hackage.haskell.org/package/fix-imports), but it doesn't convert implicit imports (import A) to explicit ones (import A (foo))
08:36:18 <thblt> but archived
08:37:10 <tomsmeding> > In the future, we plan for Importify to be able to: [...] Convert imports between implicit and explicit, [...]
08:37:12 <lambdabot>  <hint>:1:14: error: <hint>:1:14: error: parse error on input ‚Äò,‚Äô
08:37:13 <tomsmeding> it doesn't ;)
08:37:19 <thblt> Ha yes, read too fast.
08:38:44 <thblt> OK, I have another stupid question.  I wrote a simple number guessing game using monad transformers, and it should work I think, but‚Ä¶ I have no idea how to *start* the game.  Here's the code https://paste.thb.lt/1603726423.lhs.html
08:38:56 <thblt> The question is: what's the type of the thing that takes a GConf, inits a GState and actually instantiates a Game?
08:40:14 <thblt> Game is type Game = ReaderT GConf (StateT GState IO)
08:41:14 <tomsmeding> what about https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#v:runReader and https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#v:runState ?
08:41:25 <thblt> tomsmeding: reading this!
08:41:35 <tomsmeding> oh runReaderT and runStateT of course, because transformers
08:49:08 <thblt> I feel stupid, but in ghci, `runReaderT play def` just prints `runReaderT play def :: StateT GState IO ()`
08:50:01 <monsterchrom> add runStateT on top of that
08:50:02 <__monty__> You'll probably want to runStateT on that?
08:50:29 <monsterchrom> Yes this is what happens when you go crazy with monad transformers.
08:50:46 <monsterchrom> piled higher and deeper
08:50:47 <[exa]> thblt: runReaderT translates ReaderT r x a to `x a`, in your case this continues because x=StateT...
08:51:16 <thblt> monsterchrom: is that so crazy? a config ReaderT, a runtime state and IO?
08:51:31 <thblt> (Thanks all)
08:51:56 <monsterchrom> You look at "runStateT (runReaderT play def) initial", you tell me.
08:52:15 <thblt> monsterchrom: i honestly don't know.
08:52:20 <monsterchrom> for starters, the sheer obligation to say that in the correct order
08:52:59 <T0pH4t> is there a way to put a type constraint on a type family decl eg "class Foo a where type Bar a" where i limit the type set for "Bar a" to be an instance of some class Baz
08:56:10 <thblt> monsterchrom: I think I see what you mean. I thought it was a common pattern.
08:56:12 <__monty__> monsterchrom: Would you recommend MTL instead (or another effect system)? Or rather just define a monad per-project?
08:56:23 <tomsmeding> T0pH4t: I don't think so, but maybe you can make this work: "class Baz a => Foo a where type Bar a"
08:56:49 <dolio> thblt: I don't see a problem.
08:57:03 <monsterchrom> Define a monad per project. And, ironically, its definition is a newtype wrapper around using MTL stuff.
08:57:22 <monsterchrom> err I guess transformers stuff.
08:57:30 <T0pH4t> ]tomsmeding: that woudl only constrain 'a' and not the type of "Bar a"
08:57:47 <T0pH4t> tomsmeding: ^
08:57:48 <tomsmeding> monsterchrom: wanting the newtype does not mean that you can't have more than 1 monad stack per project
08:58:25 <tomsmeding> and you just move the problem: you still have to say runStateT (runReaderT blabla), but now just in runMyMonad instead of in main
08:58:31 <monsterchrom> So define two newtype wrappers of two stacks?
08:58:35 <tomsmeding> yes!
08:58:49 <thblt> GHC has been screaming at me a few times talking about "functional dependencies".  What can I read to understand what it's screaming about?
08:59:02 <tomsmeding> T0pH4t: ah that's true; then I don't think that's possible
08:59:15 <monsterchrom> OK, inside the newtype wrapper it doesn't have to be transformers stuff. You can handcode it yourself. That's a choice.
09:00:00 <texasmynsted> The ~/.cabal/config has only seven options listed in the init section. How do people normally make a template for cabal init? I have done this with "template" programs, but it seems like there must be a better way.
09:00:04 <[exa]> thblt: functional dependencies arise to disambiguate various stuff with multiparameter type classes, I guess you just hit some minor problematic spot
09:00:17 <monsterchrom> I have done "newtype X a = MkX (String -> Maybe (String, a))" by hand.
09:01:26 <monsterchrom> If you're too lazy to write its >>=, you could choose "newtype X a = MkX (StateT String Maybe a)" and write a few "deriving" clauses.
09:01:57 <tomsmeding> I'm not sure whether coding something like that by hand would be easier than saying runStateT . runMaybeT for some definition of (.)
09:02:26 <tomsmeding> not saying it's particularly difficult, but I guess I don't really see your argument against transformer stacks anymore then :p
09:02:28 <dolio> Yeah, I don't get what's being optimized here.
09:03:34 <monsterchrom> Bah, that was a tangent.
09:03:52 <monsterchrom> For this particular game, one doesn't need the StateT GState stage.
09:04:24 <tomsmeding> ... or, apparently, I misunderstood you. Sorry for the confusion :p
09:04:26 <thblt> monsterchrom: of course!  I wanted to learn about transformers, which was easier with a simple problem.
09:04:34 <T0pH4t> so this doesn't seem to work either :/ "class Baz a => Foo a where type Bar a, toBaz :: Baz (Bar a) => a -> Bar a"
09:04:52 <monsterchrom> And the ReaderT stage could be replaced by the equivalent but lighter (GConf ->)
09:05:20 <tomsmeding> T0pH4t: remove the 'Baz a =>' constraint on Foo?
09:05:37 <tomsmeding> oh oh oh maaaybe you can "class Baz (Bar a) => Foo a where type Bar a"
09:05:37 <T0pH4t> woops, thats not there, wrong copy
09:05:37 <thblt> monsterchrom: thanks for the tip!
09:05:58 <tomsmeding> need some FlexibleContexts or similar, but I recall that may work
09:06:01 <T0pH4t> This compiles: class Foo a where type Bar a, toBaz :: Baz (Bar a) => a -> Bar 
09:07:25 <T0pH4t> but if you try to use it, like  "doStuff :: Baz a => a -> Int" , "doStuff (toBaz x) " where x is an instance of F
09:07:29 <T0pH4t> Foo*
09:07:42 <T0pH4t> it will not infer the Baz instance
09:07:49 <T0pH4t> for doStuff invoke
09:07:54 <T0pH4t> which in theory it should
09:08:17 <T0pH4t> or at least in my mind it should But apparently it wants the concrete
09:10:41 <tomsmeding> oh interesting, indeed it doesn't
09:11:01 <tomsmeding> did you try the 'Baz (Bar a) =>' constraint on the class already?
09:11:05 <tomsmeding> T0pH4t: ^
09:11:55 <T0pH4t> oh that, no let me try
09:13:07 <T0pH4t> tomsmeding: that seems to be legal, thx!
09:13:48 <tomsmeding> the 'Baz (Bar a) =>' constraint on toBaz seems to go in the other direction: toBaz then _requires_ the caller to prove that Baz (Bar a), instead of _producing_ that information
09:14:08 <tomsmeding> as background why that didn't work
09:14:30 <T0pH4t> the toBaz was going to be a work around, the class constraint is better
09:14:44 <T0pH4t> but i am curious, i would have thought toBaz would work
09:14:59 <T0pH4t> assuming i only needed the Baz class contract
09:16:49 <tomsmeding> yes the class constraint is certainly better, but the toBaz workaround didn't work because the constraint on toBaz goes in the other direction
09:17:00 <T0pH4t> i see, ok thx
09:17:22 <T0pH4t> i will need to think about that a bit more "other direction"
09:18:56 <tomsmeding> T0pH4t: generally, when you have e.g. nub :: Eq a => [a] -> [a], the caller is supposed to prove that Eq a holds, right?
09:19:12 <tomsmeding> it doesn't magically appear because of using nub
09:19:19 <T0pH4t> right
09:19:20 <tomsmeding> same here with toBaz ;)
09:19:23 <T0pH4t> ah ok
09:19:24 <T0pH4t> thx
09:19:32 <tomsmeding> I was confused for a bit too
09:20:39 <T0pH4t> yeah, but assuming you called nub with something else "foo :: Eq a => [a] -> [a]" foo = nub
09:20:42 <T0pH4t> that should work
09:20:50 <T0pH4t> which is what i kind of thought i was doing
09:20:53 <T0pH4t> but maybe not
09:21:11 <tomsmeding> oh
09:21:17 <T0pH4t> i gues that example isn't fully legit, more like "foo :: Eq a => [a]" then calling numb
09:21:19 <T0pH4t> nub*
09:21:22 <T0pH4t> which doesn't work :/
09:21:27 <tomsmeding> indeed
09:21:31 <tomsmeding> heh
09:24:35 <tomsmeding> T0pH4t: but it does work: https://paste.tomsmeding.com/L29Apujl this compiles
09:25:31 <tomsmeding> (note the Baz (Bar a) constraint on 'kaas')
09:26:07 <tomsmeding> (still the class constraint is better but we decided that already)
09:30:46 <thblt> I got my stupid little game working and I think I got a better understanding of how I can write "real" programs in hs. Thanks all :)
09:31:14 <tomsmeding> thblt: cheers! good luck :)
09:33:18 <thblt> Now to make acrobatic stack of monads.  "If if doesn't work, just add one stacking level".
09:34:58 <tomsmeding> maybe you can conjure up an AbstractFactoryT
09:35:03 <tomsmeding> and a beanT
09:35:11 <tomsmeding> corr. BeanT
09:35:49 <thblt> HaskellEE
09:37:04 <tomsmeding> I suddenly see an alternative reverse-acronym for IEEE
09:37:30 <ixlun> ugh.. just killed GHC
09:37:45 <ixlun> it used up 30Gigs of RAM compiling :-(
09:38:40 <thblt> That's not polite.  But I think GHC tends to overallocate?
09:39:04 <ixlun> I think it's because I'm doing some TH 
09:39:23 <ixlun> and I must have generated a monster data structure
09:39:32 <monsterchrom> :)
09:39:39 <geekosaur> generics?
09:40:40 <ixlun> geekosaur: Nah, static data generation
09:41:21 <ixlun> I'm writing a chess engine and I get TH to generate all possible moves for every piece kind at every position on the board
09:42:20 <ixlun> Can I get a vector that's indexed by Word8?
09:42:31 <ixlun> rahter than Int
09:42:51 <monsterchrom> No. Use fromIntegral
09:43:28 <tomsmeding> (or use Array)
09:46:26 <ixlun> If I use fromIntegral would GHC manage to optimise that out?
09:47:58 <tomsmeding> I think at the assembly level, assuming you're running on x86_64, it's going to be a 64-bit int anyway
09:48:16 <tomsmeding> or I guess 32, that will work too
09:49:56 <monsterchrom> Optimizations depends on detailed actual code. Including your specific question.
09:52:35 <dolio> Optimize what out?
09:52:52 <monsterchrom> fromIntegral :: Word8 -> Int
09:53:20 <geekosaur> iirc there's a bunch of RULEs for simple cases?
09:53:25 <dolio> Yeah, but GHC doesn't have inherently Word8-based arrays, so what would it be optimizing out?
09:53:59 <monsterchrom> Oh, ha, point.
09:54:01 <geekosaur> because so many Integral types have the same internal representations
09:55:51 <tomsmeding> geekosaur: I'd reckon Word8 and Int don't have the same internal representation ;)
09:56:03 <dolio> They basically do, I think.
09:56:30 <monsterchrom> They do. Word8 uses a whole machine word. Recall "alignment".
09:56:34 <geekosaur> yeh. there are differences in how they're treated, but more or less the same thing underneath
09:57:26 <geekosaur> constructor tag == 0, then a machine word for the value
09:57:35 <tomsmeding> monsterchrom: what exactly does alignment have to do with this? If you place an Int after a Word8, then there's 7 bytes of padding in between, but I'd think that two Word8's can still occupy two bytes, can't they?
09:57:38 <tomsmeding> or is that C thinking :p
09:57:43 <dolio> At some point there were plans to add smaller-width unboxed types, but I don't think that's happened yet.
09:57:48 <tomsmeding> okay Word8# then sure
09:57:54 <tomsmeding> oh
09:57:57 <tomsmeding> lol
09:58:09 <geekosaur> they're still thinking about it last I heard
09:58:15 <tomsmeding> okay then llvm will do the job handwave
10:02:22 <monsterchrom> But there is no Word8#.  data Word8 = W8# Word#
10:03:24 <monsterchrom> To a large extent it's simply low priority.
10:05:18 <tomsmeding> ixlun: that means that using Word8 with ghc for space saving is a useless endeavour at the moment, I think
10:06:40 <geekosaur> vector *of* Word8 will compact them together, but *indexed by* won't
10:06:47 <geekosaur> iirc
10:06:53 <tomsmeding> because it's special-cased? ah
10:07:17 <geekosaur> yeh, there's a lot of magic going in in the background to pack various common vector use cases
10:07:40 <geekosaur> it may have to be an unboxed vector to get the packing
10:07:59 <tomsmeding> yes, because otherwise the vector just contains pointers :p
10:10:25 <tomjaguarpaw> My code compiled and worked.  This is highly suspicious.
10:14:23 <tomsmeding> it's haskell, that's expected behaviour
10:15:24 <tomjaguarpaw> There are lots of permutations of this code that typecheck but are invalide..
10:17:54 <tomjaguarpaw> I actually got everything right in my head on the first try \o/
10:18:53 <tomsmeding> üéâ
10:19:36 <geekosaur> xmonad does that a lot. although mostly because everything's in IO when it comes down to it
10:21:35 <tomjaguarpaw> I can't believe I got everything right. That almost never happens.  It's like a Python program working on first try.
10:26:42 <thblt> tomjaguarpaw: maybe you ran it through clang by error? Most sequences of bytes are legal C++ programs that immediately segfault, after all :)
10:27:36 <tomjaguarpaw> It is most definitely a Haskell program tested by our very own Hedgehog.
10:31:17 <ixlun> Could somene explain how to write `peek' or `poke' for a 'data Foo = A | B | C' which dervies enum?
10:31:41 <ixlun> I don't understand as I have a `Ptr Foo', I just want to write the enum value for that type
10:32:07 <ixlun> but I can't as I need to write an Int32
10:33:36 <dsal> :t fromEnum True
10:33:38 <lambdabot> Int
10:36:21 <maerwald> is there a way to generate a json schema via aeson?
10:36:35 <monsterchrom> I think no.
10:37:15 <hyperisco> I'd really like a  Map String A  from Dhall‚Ä¶ can I read a record as such a map perhaps?
10:41:40 <hyperisco> still seems to stand that I think auto codecs are stupid :P
10:44:00 <hyperisco> hm there is a special  toMap  thing, alright
10:55:23 <hyperisco> so I am in IO, and I just want to throw an exception with a string message‚Ä¶ how can I construct such an exception? do I have to define my own data type? is there a predefined one in base?
10:56:23 <geekosaur> throwIO (ErrorCall "waaah") -- ?
10:57:38 <hyperisco> okay thanks
10:58:50 <geekosaur> (this is more or less `error` but with `throwIO` instead of `throw`, that may not be what you want)
10:59:03 <POGtastic> hi all, what is it called when you constrain a generic data type to instances of another typeclass? For example, `data (Ord a) => Tree a`
10:59:18 <hyperisco> if it can be caught in IO then that is fine
10:59:19 <monsterchrom> alternatively, userError :: String -> IOException
10:59:54 <monsterchrom> in fact, IO's fail s = ioError (userError s)
11:00:23 <hyperisco> oh can I jsut call  fail  then? seems so
11:01:03 <monsterchrom> Yeah, and the catcher catches IOException and check isUserError
11:01:22 <hyperisco> > catchException (fail "my error") \_ -> putStrLn "caught!"
11:01:25 <lambdabot>  error:
11:01:25 <lambdabot>      Unexpected lambda expression in function application:
11:01:25 <lambdabot>          \ _ -> putStrLn "caught!"
11:01:36 <hyperisco> the spoils of BlockArguments
11:01:42 <monsterchrom> heh
11:02:07 <monsterchrom> also, yahb is better for IO
11:03:52 <POGtastic> nm, i figured it out - haskell needs the DatatypeContexts extension for this
11:04:11 <geekosaur> yes. because it's fairly useless
11:04:11 <srid> It would be really nice to make the Haskell Wiki https://wiki.haskell.org/ look a bit modern. Has anyone thought about it?
11:04:13 <srid> (.. also update its content)
11:04:37 <monsterchrom> It already looks postmodern to me.
11:04:49 * hackage ffmpeg-light 0.13.0 - Minimal bindings to the FFmpeg library.  https://hackage.haskell.org/package/ffmpeg-light-0.13.0 (AnthonyCowley)
11:04:57 <hyperisco> % catch (fail "my error") \e -> const (putStrLn "caught!") (e :: IOException)
11:04:58 <yahb> hyperisco: caught!
11:05:07 <monsterchrom> But content update would be good, I haven't checked.
11:05:42 <monsterchrom> Generally, any presence of round-corner graphical buttons is postmodern to me.
11:06:00 <geekosaur> heh
11:06:02 <monsterchrom> Any use of custom downloadable fonts is postmodern to me.
11:06:16 <monsterchrom> Any contentless aesthetics is postmodern to me.
11:06:29 <hyperisco> the wiki looks old?
11:06:30 <dminuoso> monsterchrom: What's that *graphical* button you mentioned?
11:06:45 <monsterchrom> haha
11:07:39 <monsterchrom> Contentful, informative aesthetics exist. But "buttons should have round corners" is not one of them.
11:07:46 <hyperisco> srid, can you point out to someone stuck in the 00's what is dated about the wiki design?
11:09:11 <srid> hyperisco: for one, the header styling is terrible. eg: go to https://wiki.haskell.org/Books and look at level-2 headers ... I had trouble locating them (eg: look at the "Foundations" header which has a bad contrast compared to the surrounding text)
11:09:46 <srid> And just as a nicety, it doesn't hurt to make the wiki style consistent with https://www.haskell.org/ - though that would require substantial work from someone proficient in CSS and mediawiki theming
11:10:26 <hyperisco> so a typography problem more specifically
11:10:34 <dminuoso> "header", "styling", "contract", "CSS"
11:10:39 <dminuoso> You sound more than qualified
11:11:00 <dminuoso> srid: Why not get the work started?
11:11:00 <srid> dminuoso: what's your point?
11:11:06 <monsterchrom> the issue with level-2 headers is also a mediawiki theming issue.
11:11:09 <dminuoso> Im volunteering you.
11:11:22 <Uniaika> :D
11:11:34 <hyperisco> I have a feeling there is something amiss with the wiki markup, though I am no expert on it‚Ä¶ headers are supposed to be indexed, suggesting to me it isn't the right kind of header
11:11:39 <Uniaika> ‚ÄúCongratulations citizen for your volunteer drafting!‚Äù
11:11:41 <monsterchrom> In addition, it also plays poorly with people's habit of using bloody unnecessary bolds for book/article titles there.
11:12:11 <dminuoso> For what its worth, being dated is unlikely to be a deterrence. People *still* use LYAH.
11:12:26 <monsterchrom> I.e., if you go unbold all book titles there, it's an instant 50% improvement.
11:12:37 <srid> dminuoso: I'm happy to volunteer with the content; I'd like to meet someone that is interesting in improving the design. Which is I came here to ask. Do I understand right that nobody cares about it in IRC?
11:12:46 <srid>  * dminuoso: I'm happy to volunteer with the content; I'd like to meet someone that is interested in improving the design. Which is I came here to ask. Do I understand right that nobody cares about it in IRC?
11:12:52 <monsterchrom> the remaining 50% being making level-2 section headers just a tiny bit more visible
11:12:53 <srid>  * dminuoso: I'm happy to volunteer with the content; I'd like to meet someone that is interested in improving the design. Which is why I came here to ask. Do I understand right that nobody cares about it in IRC?
11:13:20 <dminuoso> srid: Sorry, must have been written before I connected to the BNC then.
11:13:43 <srid> I'm sure if we ask for feedback from people not stuck in 00's, they might have more to say.
11:13:58 <dminuoso> srid: I think the topic of the wiki was raised on haskell-cafe recently
11:14:33 <hyperisco> I agree with the typography problem but personally I don't see any problem with the overall aesthetic
11:14:42 <srid> dminuoso: link? I see one for wikibook: https://mail.haskell.org/pipermail/haskell-cafe/2020-September/132779.html
11:15:15 <dminuoso> srid: Id have to dig, it was a few months ago.
11:15:43 <dminuoso> IIRC it was said that folks stopped contributing after it was modernized.
11:15:50 <dminuoso> The wiki is pretty dead now
11:16:15 <monsterchrom> hrm, but wikibook/haskell is distinct from wiki.haskell.org.  even in terms of contributors.
11:16:28 <Uniaika> yes, it's an entirely different platform
11:16:31 <Uniaika> for starters
11:17:06 <monsterchrom> wikibook/haskell actually has better structure and content today than when I checked in the 00's.
11:17:25 <Uniaika> monsterchrom: the 00's have ended 10 years ago, dear :)
11:18:06 <monsterchrom> It's monad chapter in the 00's, oh God, such a longwinded fictional story that got nowhere at all.
11:18:30 <hyperisco> I think lines and gradients are out of style now
11:18:33 <monsterchrom> either that or the author really had a PhD in allegorical literature techniques.
11:19:09 <Uniaika> srid: btw, if you're interested in improving the docs at large, you can join #haskell-docs
11:19:16 <hyperisco> I noticed a bit of dimensionality and colour came back after that weird bit around the Windows Metro era‚Ä¶
11:19:48 <hyperisco> a rebound from extreme minimalism
11:20:31 <monsterchrom> Uniaika: Still, there is one kind of improvement that doesn't happen often enough, not even over decades. Deletion. People are usually too polite to delete someone else's stuff.
11:20:32 <hyperisco> maybe by 2030 we will make buttons look like buttons again, who knows
11:21:06 <monsterchrom> And this rare improvement happened to the monad chapter. That useless story was totally deleted.
11:21:42 <hyperisco> maybe you have to click a link every year that is emailed to you to keep your revision alive :P
11:21:47 <monsterchrom> It was at least 100 lines.
11:29:16 <motte> hi, is there a function for something like [(a, Either b c)] -> Either b [(a, c)]"
11:30:10 <dminuoso> motte: traverse
11:30:53 <dminuoso> Amusingly, since `(,) a` is a Traversable as well, you can just go `traverse . traverse`
11:31:33 <motte> oh wow
11:31:40 <Uniaika> monsterchrom: oh yeah I understand you
11:31:47 <motte> dminuoso: thanks
11:32:05 <Uniaika> motte: read this https://clementd-files.cellar-c2.services.clever-cloud.com/lambdalille-traverse.html#1
11:32:23 <ghoulguy> :t traverse sequence :: [(a, Either b c)] -> Either b [(a,c)]
11:32:24 <lambdabot> [(a, Either b c)] -> Either b [(a, c)]
11:32:31 <dminuoso> motte: (Well or rather, for that *particular* type signature it'd be sequence rather, but it's probable that you're fmapping before, so look into using traverse instead.
11:32:42 <dminuoso> (Every time you see sequence, there
11:32:49 <dminuoso> (Every time you see sequence, there's a high probability a traverse is missing somewhere)
11:34:47 <monsterchrom> Haha, one of the rare moments when "instance Traverable ((,) a)" makes sense, and by logical conclusion, "instance Foldable ((,) a)" makes sense. :)
11:35:06 <dminuoso> The Foldable instance Im still not so sure about
11:37:18 <hyperisco> another victory for functional programming
11:40:18 <monsterchrom> Well, if you accept a Traversable instance, you're pretty much forced to accept unwillingly the Foldable instance too :)
11:40:30 <monsterchrom> I mean >:)
11:40:45 <dminuoso> heh true
11:41:20 <monsterchrom> a "small" price to pay for the greater good
12:01:07 <tomsmeding> merijn: ALE+ghcide works so well I now write overly generic code, and it's your fault
12:28:54 <tomjaguarpaw> What's ALE?
12:30:07 <maerwald> delicious
12:30:30 <thblt> Linting for Neovim?
12:32:28 <tomsmeding> linting for neovim, but also includes a language client implementation that's significantly better than languageclient-neovim in my experience
12:32:30 <tomsmeding> for some reason
12:32:59 <tomjaguarpaw> How does that lead to writing overly generic code?
12:33:08 <tomsmeding> better feedback about types
12:33:15 <tomsmeding> makes me give up later
12:33:17 <tomjaguarpaw> Ah, I see. That's cool.
12:33:24 <maerwald> no, it's not for neovim, it's for any vim
12:33:45 <tomsmeding> very true
12:36:00 <tomsmeding> it does more, for more targets, and of better quality, when compared to languageclient-neovim
12:36:18 <tomsmeding> unless I'm missing something
12:36:38 <thblt> Ha yes I misread, it's for *Vim
12:53:31 <dansho> anyone know why terminal transparency (xfce4-terminal) in xmonad stopped working when i did a system upgrade? "Opacity is not available since compositing is either disabled or not supported by your Window Manager"
12:54:22 <thblt> dansho: something broke your compositing manager? Maybe config becoming invalid?
12:55:14 <dansho> i'm on nixos, just upgraded from 19.03 -> 20.03, but otherwise the system config is the same
12:55:32 <thblt> dansho: well what's your compositing manager? compton?
12:55:37 <geekosaur> xmonad doesn't do compositing, you'd have to run a separate compositor. (I use compton, there are others)
12:55:46 <dmwitch> Perhaps your terminal changed from doing fake transparency (which does not need a compositor) to real transparency.
12:56:11 <dansho> i assume its xfce: desktopManager.xfce.enable = true;
12:56:25 <thblt> Also maybe we could move the discussion to #nixos?
12:56:32 <thblt> could/should?
12:56:44 <geekosaur> xfce isn't a compositor, it's a desktop environment
12:56:44 <dansho> thanks =)
12:57:24 <dmwitch> Desktop management is... not the same as compositing management.
12:59:12 <thblt> Os you have services.picom.enable or services.compton.enable in your configuration.nix? 
12:59:16 <thblt> Do
13:00:36 <dansho> neither
13:00:58 <thblt> then maybe you should. picom --- it's the most recent name. rebuild --switch then restart X
13:02:19 <maerwald> well, none of that is ontopic (xfce, xmonad, nix, picom) :p
13:03:35 <dmwitch> I think it's fine to help with that stuff in here.3
13:04:05 <dmwitch> (I think it's also fine to say "nobody seems like an expert right now and there are places more targeted to that expertise".)
13:05:03 <dansho> thanks i'll try
13:11:17 <dansho> thanks it worked =)
13:12:20 <geekosaur> so they removed automatic compositing from the xfce configuration
13:14:11 <hyperisco> so I could traverse_ with StateT to keep a running state‚Ä¶ is there a definition other than traverse_ to use?
13:18:38 <edwardk> :t mapAccumL
13:18:39 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:19:22 <edwardk> sadly there is no mapAccumL_
13:24:53 <hyperisco> meh StateT it is then
13:37:55 <noname234234> can I ask beginner question here?
13:38:36 <dminuoso> noname234234: Yes.
13:38:51 <noname234234> I don't know how to format code here, can you help me with that
13:39:05 <dminuoso> https://paste.tomsmeding.com/
13:39:48 <noname234234> I'm trying to do the exercise here -> https://en.wikibooks.org/wiki/Haskell/Monoids#Monoid_laws
13:40:37 <noname234234> My code is https://paste.tomsmeding.com/BGe5UG1c
13:41:18 <noname234234> Uh forget to include this -> https://paste.tomsmeding.com/BGe5UG1c
13:41:29 <noname234234> Oops... this -> newtype Sum a = Sum { getSum :: a }
13:41:47 <noname234234> So I don't know how the correct syntax for this instance definition
13:42:23 <dminuoso> The syntax looks good.
13:42:33 <dminuoso> Do you get any error?
13:42:39 <noname234234> Yes ->  Illegal instance declaration for ‚ÄòMonoid (Sum Bool)‚Äô    (All instance types must be of the form (T a1 ... an)     where a1 ... an are *distinct type variables*,     and each type variable appears at most once in the instance head.     Use FlexibleInstances if you want to disable this.)‚Ä¢ In the instance declaration for ‚ÄòMonoid (Sum
13:42:39 <noname234234> Bool)‚Äôtypecheck
13:42:43 <dminuoso> Ah!
13:42:48 <dminuoso> Indeed, enable the specified extension
13:42:54 <dminuoso> Or change the newtype to `newtype Sum = Sum Bool`
13:43:13 <dminuoso> To do the former, just add {-# LANGUAGE FlexibleInstances #-}
13:43:31 <dminuoso> The extension is fairly benign
13:43:36 <noname234234> someone else said like this but I couldn't figure it out -> `The problem is wanting you to rewrite the Any and All wrappers from Data.Monoid which are data Any = Any { getAny :: Bool } etc`
13:44:27 <noname234234> what's the real problem here i don't understand, is syntax correct or not correct?
13:44:35 <tomsmeding> what that person meant is: the Any and All definitions in Data.Monoid are in essence the answers to this question
13:44:39 <dminuoso> noname234234: Formally, when you write an `instance T (C ...) where`, then you may only have type variables in the dots.
13:44:41 <tomsmeding> just with different na,es
13:44:57 <tomsmeding> *names
13:44:58 <dminuoso> noname234234: To specify an `instance T (C Bool)` is illegal 2010 haskell
13:45:19 <dminuoso> The reasons for this restrictions are somewhat subtle, but you can either lift them by enabling the pragma I have suggested
13:45:28 <noname234234> so type variable is something lke bool?
13:45:28 <dminuoso> or you change the newtype so you wont have to mention `Bool` in the instance head
13:45:37 <dminuoso> noname234234: sure, or just `a`
13:45:43 <dminuoso> anything with lower case
13:47:22 <noname234234> So in the exercise I have to write this two instance for sum and product
13:48:25 <noname234234> I have imagined product for and operation and sum for `or` operation
13:48:48 <noname234234> I believe my reasoning is correct
13:48:56 <noname234234> but I don't really know how would I express this in haskell
13:49:22 <tomsmeding> you managed Sum, didn't you? :)
13:49:59 <tomsmeding> though it's more natural to write: newtype Sum = Sum { getSum :: Bool }
13:50:06 <tomsmeding> instead of parametrising on a variable `a'
13:50:31 <noname234234> https://paste.tomsmeding.com/w73fxoro
13:50:45 <dminuoso> noname234234: Your code is almost spot on, really. If you want to just "get it done", enable the extension by adding `{-# LANGUAGE FlexibleInstances #-}` to the top
13:50:54 <dminuoso> Or change the newtype like tomsmeding has suggested
13:51:38 <tomsmeding> I'd say, because this Sum data type is intended to be used only with Bool, I think, I would write it as I suggested
13:52:25 <dminuoso> (Note I didnt bother to check whether your boolean algebra is right, but oh well, that's on you :-)
13:52:25 <noname234234> so I want to understand the real issue here let me write it as I understood -> currently generic types are not supported in instance definition in haskell? sorry for `generic type` term but I see that as `a` I defined there
13:52:36 <dminuoso> noname234234: So
13:52:44 <dminuoso> If we consider a general intsance declaration as:
13:52:56 <tomsmeding> dminuoso: side note: why didn't the haskell spec allow "flexible instances", so to speak? Didn't they want to mess with overlap detection algorithms?
13:52:59 <dminuoso> instance ClassName (TypeConstructor t1 t2 t3 ...)
13:53:11 <dminuoso> then t1, t2, t3, etc *must* only be type variables
13:53:20 <dminuoso> they may *not* be type constructors like Bool
13:53:39 <noname234234> type variable is typeclasses?
13:53:40 <dminuoso> tomsmeding: I dont know for sure, but I think there's two parts to it
13:54:02 <dminuoso> tomsmeding: For one, FlexibleInstances essentially incurs FlexibleContexts, and you can write incoherent code with that alone (see the GHC manual)
13:54:05 * tomsmeding would say "type names", not "type constructors"; I've seen someone use "type constructor" where they meant "data constructor" in this channel
13:54:22 <dminuoso> Another one I've heard mentioned is that their implementation is non-trivial
13:54:35 <dminuoso> At least if you didn't know how to do it beforehand.
13:55:43 <monsterchrom> I avoid "type constructor" because people then go anal about whether Int counts, and independently whether (Either Int) counts.
13:55:43 <dminuoso> (It takes some real effort to write incoherent code with it, which is why I called it fairly benigh above)
13:56:08 <dminuoso> monsterchrom: a type constructor is something you can pattern match on in tyfams/tyinsts!
13:56:14 <dminuoso> just like data constructors can be pattern matched on in case-of
13:56:17 <dminuoso> :p
13:56:23 <noname234234> so type variable is for example `Num ` class?
13:56:50 <tomsmeding> noname234234: no, that's a class name ;)
13:56:57 <tomsmeding> it's something like `a`
13:57:05 <noname234234> ah oaky
13:57:14 <tomsmeding> like the `a` in your `newtype Sum a = Sum { getSum :: a }`
13:57:53 <noname234234> ah okay its like generic type
13:57:55 <noname234234> inother languages
13:58:00 <dminuoso> noname234234: no
13:58:15 <dminuoso> a type variable is the `a` itself, not what you can do with it
13:58:18 <tomsmeding> it's like the type parameter to a generic type/function in other languages, I guess
13:58:22 <dminuoso> % :t id
13:58:23 <yahb> dminuoso: a -> a
13:58:34 <dminuoso> noname234234: in that type signature above, the `a` is sort of like a placeholder
13:58:42 <tomsmeding> in java or c++, the T in the <>'s
13:59:02 <dminuoso> noname234234: so a type variable means "you can pick whatever you want there"
13:59:02 <noname234234> okay thank you
13:59:08 <dminuoso> Bool
13:59:10 <dminuoso> is not a type variable
13:59:19 <dminuoso> It's a concrete/particular type
13:59:58 <noname234234> aha get it
14:00:16 <noname234234> got it*, so I will now work on the example, 
14:00:17 <tomsmeding> dminuoso: I don't see a mention of being able to write incoherent code with FlexibleContexts in the ghc user manual; am I looking in the wrong place? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleContexts
14:00:33 <dminuoso> tomsmeding: See rules on overlap
14:00:55 <tomsmeding> including {-# OVERLAPPABLE #-} pragmas and such? I'd not say that counts
14:01:05 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances
14:01:10 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-overlap
14:01:23 <dminuoso> no, without overlap even
14:01:47 <dminuoso> (I think)
14:02:28 <dminuoso> And, with the bug report I opened recently, there's a lot of awkwardness with typeclass instance resolution, where it's not even clear what the semantics are
14:02:50 <dminuoso> if you look at the haskell report, it doesnt say anything about what context of typeclass instances mean/do
14:03:01 <tomsmeding> interesting
14:03:20 <dminuoso> tomsmeding: https://gitlab.haskell.org/ghc/ghc/-/issues/18836
14:03:36 <noname234234> now I get this error -> `‚Ä¢ No instance for (Semigroup Product)    arising from the superclasses of an instance declaration‚Ä¢ In the instance declaration for ‚ÄòMonoid Product‚Äôtypecheck`
14:03:48 <noname234234> for this -> `-- | Monoid under multiplication.newtype Product = Product { getProduct :: Bool }instance Monoid Product where    mempty = Product True    Product x `mappend` Product y = Product (x && y)`
14:03:48 <dminuoso> A quick look at that note alone makes you wonder how subtle typeclass instance implementations really are. :-)
14:04:00 <dminuoso> noname234234: Ah, that might be friction due to changes in GHC Haskell
14:04:16 <dminuoso> noname234234: We split Monoid into Semigroup and Monoid, where mappend was moved into Semigroup as <>
14:04:49 <dminuoso> So when you wrote `instance Monoid Foo where mappend = ...; mempty = ...;` you'd now write `instance Semigroup Foo where l <> r = ...; instance Monoid Foo where mempty = ...`
14:05:31 <noname234234> I have to separate these two?
14:05:36 <dminuoso> Yes
14:05:46 <dminuoso> they belong together semantically
14:06:01 <dminuoso> the split was done because Semigroup is a "weaker/stronger" (depending on your perspective) version of Monoid
14:06:11 <dminuoso> There's thing that have an associative operation, but no identity
14:06:15 <dminuoso> (Thus they are Semigroup but not Monoid)
14:06:51 <monsterchrom> for example Integer and max
14:07:20 <noname234234> there's no mappend anymore in `monoid`?
14:07:43 <dminuoso> noname234234: Well there is, but it defaults to (<>)
14:07:49 <Uniaika> noname234234: it's inherited from Semigroup
14:08:02 <dminuoso> Uniaika: No, its part of Monoid
14:08:53 <tomsmeding> dminuoso: fascinating read, that issue :p
14:09:20 <tomsmeding> though you're still using an OVERLAPS pragma, so I'm not yet convinced one can write incoherent code without those pragmas :p
14:09:29 <dminuoso> noname234234: These are unfortunate things, over the years we've had a few breaking changes like that (to make a cleaner language), but resources frequently fail to be updated.
14:09:41 <dminuoso> tomsmeding: you can easily if you use multiple packages.
14:09:48 <dminuoso> I have a git repo ready for you...
14:10:01 <Uniaika> dminuoso: oh, okay
14:10:06 <noname234234> It's alright It happens to every resource about programming languages. So far this has been the first though one.
14:10:10 * tomsmeding becomes scared
14:11:01 <monsterchrom> This Halloween, instances overlap to torment you. Spooky resolution at a distance. >:)
14:11:21 <tomsmeding> √∂
14:12:00 <noname234234> so if `semigroup` is superclass of `monoid` why can't I define `mappend` under `monoid?`
14:12:01 <dminuoso> tomsmeding: hold on, I might need to retract that comment. Ill get back to you tomorrow on this.
14:13:12 <tomsmeding> don't sweat, was just curious :p
14:13:27 <tomsmeding> only if you wanted to do it anyway
14:14:04 <tomsmeding> noname234234: you can, but to write an instance of Monoid, you also have to provide an instance of Semigroup
14:14:40 <tomsmeding> and then if you do, you can leave out the explicit definition of `mappend`, because it will take the definition of <> by default
14:14:56 <monsterchrom> Oh, "superclass" doesn't mean implement all methods under one instance declaration.
14:15:29 <tomsmeding> ah yes, that's a difference with c++/java and friends
14:15:53 <tomsmeding> (one of the many differences, but this one is relevant here :p)
14:16:13 <monsterchrom> Really, "superclass" only means if I write my function type signature "f :: (Semigroup a, Monoid a) => ..." I can omit "Semigroup a".
14:16:31 <monsterchrom> NO OTHER BENEFIT.
14:17:34 <noname234234> but in the example code works even though no semigroup definition is made
14:18:04 <noname234234> https://paste.tomsmeding.com/wUUmo0KG
14:18:06 <noname234234> this code
14:18:31 <aldessa> Is there a monad~thing that keeps track of an rng, logging and a state?
14:20:03 <monsterchrom> old compiler?
14:20:12 <monsterchrom> Certainly doesn't "work" for me.
14:21:04 <noname234234> wait, it doesnt work for me too..
14:21:10 <noname234234> I think in my laptop I have old compiler
14:21:14 <noname234234> On PC right now
14:22:08 <dminuoso> tomsmeding: Anyhow, OVERLAP* pragmas are not the cause behind incoherence.
14:22:19 <dminuoso> Overlap would either always result int
14:22:23 <dminuoso> 1) a deterministic instance choice
14:22:25 <dminuoso> 2) a diagnostic
14:23:40 <tomsmeding> has the real incoherence case got to do with defining functions where only some of the instances are in scope?
14:23:55 <dminuoso> you mean in the issue?
14:24:02 <dminuoso> or in case of FlexibleInstances?
14:24:04 <dsal> aldessa: transformers?
14:24:50 <justsomeguy> Is there an editor feature or plugin that will let me press a key and replace a function with its definition for Haskell code?
14:24:57 <tomsmeding> FlexibleInstances dminuoso 
14:25:19 <tomsmeding> justsomeguy: how do you imagine that works with something like
14:25:20 <tomsmeding> @src map
14:25:20 <lambdabot> map _ []     = []
14:25:20 <lambdabot> map f (x:xs) = f x : map f xs
14:25:45 <noname234234> ok I have finally did this example. I was feeling defeated on this one for two days. Thank you guys
14:25:59 <tomsmeding> noname234234: üéâ
14:26:09 <dminuoso> tomsmeding: Yes. All incoherent examples rely on not all instances being in scope
14:26:20 <dminuoso> Otherwise GHC would produce a diagnostic
14:26:22 <tomsmeding> ah
14:26:36 <dminuoso> (Unless of course you're tripping into undocumented behavior like in my issue)
14:26:48 <dminuoso> In which case GHC does something non-obvious instead of erroring out
14:27:07 <dminuoso> disclaimer: unless IncoherentInstances was enabled of course
14:27:10 <dminuoso> ;)
14:27:11 <tomsmeding> do you also need orphans, or can you do it with -Werror=orphans?
14:27:24 <tomsmeding> sure :p
14:27:26 <dminuoso> orphans are one way that is actually quite possible
14:27:34 <dminuoso> even without any other extensions
14:27:45 <dminuoso> The FlexibleInstances works without orphans
14:27:47 <tomsmeding> because I know that orphans are dangerous for this reason
14:27:50 <tomsmeding> ah
14:30:19 <dminuoso> tomsmeding: In the particular example of FlexibleInstances, the cause is just with FlexibleInstances, you allow for multiple matching instances 
14:31:28 <dminuoso> \(IY\) is strictly more specific than \(IX\). That is, \(IY\) is a substitution instance of \(IX\) but not vice versa.
14:31:47 <justsomeguy> tomsmeding: For example, you could move your cursor to ‚Äúflip‚Äù, press Control-K, and then it would be replaced by ‚Äú(\f x y -> f y x)‚Äù. Or, for more complicated functions that need a name binding, it could replace it with ‚Äú(let flip f x y = f y x in flip)" I got the idea from Pharo Smalltalk, which lets you do this for class methods, unwinding indirection of the entire inheritance chain in-place.
14:32:25 <tomsmeding> justsomeguy: I _think_ it doesn't exist yet, but you can suggest it as a plugin for HLS :)
14:33:00 <justsomeguy> tomsmeding: I may do that; But first I'll probably try to write a crummy proof of concept in vimscript.
14:33:25 <tomsmeding> parsing haskell in vimscript? my condolences :p
14:34:23 <justsomeguy> lol, maybe that's too hard. I was thinking more along the lines of "grep and paste".
14:34:37 <aldessa> dsal Would that be RandomGen g => StateT g (StateT s Writer a) a? Like a transformer stack with a lot of lifting
14:35:31 <aldessa> StateT s Writer*
14:35:40 <dminuoso> tomsmeding: So, without FlexibleInstances, you wouldn't even have that problem because there can't be two simultaenously matching instances.
14:35:43 <dsal> Transformers gotta lift.  But I tend to use MonadLogger + Reader.  State sometimes is fine, but it's hard to weave through some things.  Depends on your needs.
14:35:54 <dminuoso> (Because any instance is already as general as possible by demanding all type parameters to be tpye variables)
14:36:01 <tomsmeding> yes makes sense dminuoso 
14:40:37 <aldessa> dsal Is it possible to avoid the lifting? I was thinking as two alternatives Polysemy or writing my own monad transformer?
14:40:56 <noname234234> I will ask you guys a question. I may have used some monad concept before even having aware of what I did. I still don't know what a monad is but here the story: I have wrote a high-order function in some imperative language that takes a function and calls it on a list inside the method body. so after a month had passed and I had to change the
14:40:56 <noname234234> behavior of the existing code, but I figured out that I don't need to change the method body at all, just I have written a  function overload where I `wrap` the parameter function, lets say I have just did a null check and then call the function and return its value from the lambda function. its something like `C#: methodOverload(Func<bool> a) =>
14:40:56 <noname234234> originalMethod( () => { doSomethingElse(); return a(); })`
14:41:13 <dminuoso> aldessa: You can wrap some primitives to work with your particular monad stack
14:41:39 <aldessa> dminuoso, sorry what do you mean?
14:41:50 <noname234234> so does that have any relation to monads at all?
14:42:10 <dminuoso> aldessa: Instead of `genWord32 :: RandomGen g => g -> (Word32, g)` you could write `myGenWord32 :: App Word32`
14:42:19 <dminuoso> And then use that primitive instead. That moves the lifting into a single place.
14:45:46 <aldessa> dminuoso do you mean like a wrapper function that is lift original/ lift . lift $ original?
14:46:42 <dsal> aldessa: you generally put the lifting in your lib somewhere
14:50:14 <gnumonic> This is maybe a stupid question but: If I'm writing a simple (interpreted) DSL that parses user expressions to haskell functions at runtime, is that an EDSL or some other kind? The terminology is kind of confusing 
14:50:59 <aldessa> gnumonic does it have an external parser?
14:51:48 <gnumonic> I don't think so? I'm not exactly sure what external means there. It uses parsec to parse expressions directly into haskell functions.
14:53:47 <gnumonic> But it just runs in a main loop (more or less) where I run the parser over a line of user input and then execute the expression. Some resources make it seem like an eDSL has to be a library, so if this happens at runtime in a binary then it's not that? 
14:54:09 <gnumonic> I guess it doesn't really matter but I want to get the terminology right 
14:54:24 <aldessa> gnumonic, I'd say it is not an embedded DSL if you don't write the language in haskell source files
14:54:42 <aldessa> like I'd consider Earley an eDSL but it calls itself a DSL https://hackage.haskell.org/package/Earley
14:55:17 <noname234234> I have a question. I use python interpreter on daily basis a lot. I was wondering could I use GHCi for simple tasks like file reading/parsing but though haskell doesn't allow impurity so can't I just read file contents and if it succeeds store it in a immutable string?
14:55:46 <tomsmeding> gnumonic: Accelerate is an EDSL: https://github.com/AccelerateHS/accelerate-examples/blob/master/examples/quicksort/QuickSort.hs
14:55:53 <aldessa> I would also consider this an EDSL https://gitlab.com/sheaf/fir
14:56:06 <sm[m]> noname234234: certainly
14:56:09 <sm[m]> s <- readFile "foo"
14:56:17 <tomsmeding> (scatter/fill/awhile... come from Data.Array.Accelerate)
14:57:10 <tomsmeding> whereas Futhark is a DSL: https://github.com/nqpz/futracer/blob/master/futracerlib/render.fut
14:57:24 <aldessa> noname234234, you can but the underlying string will be wrapped in an IO type
14:57:29 <tomsmeding> both are array processing languages, both have a compiler implemented in Haskell, both compile to both CPU and GPU code
14:57:44 <tomsmeding> but the one is embedded in Haskell, and the other is not :)
14:57:49 <noname234234> wow lol I didn't imagine this would be this much easier sm[m]
14:57:49 <nf> is there a GHC extension that would make `const 42 return` output 42 instead of an error?
14:57:49 <gnumonic> Ok, so the difference is that an eDSL is one such that the source is Haskell. It's just a DSL if it compiles to haskell functions, but is written in some other language then? So I guess you could consider parsec itself to be a kind of eDSL 
14:58:08 <tomsmeding> parsec is definitely an EDSL
14:58:13 <noname234234> I think from now on haskell would play a large role in my daily work
14:58:16 <sm[m]> why, noname234234 ? Haskell Is Easy (tm) :)
14:58:26 <gnumonic> That makes sense, thanks. 
14:58:33 <noname234234> I was using python in a full functional manner anyways, so
14:58:50 <tomsmeding> gnumonic: also: in an EDSL in haskell, an important property is that you can do metaprogramming using Haskell itself
14:59:13 <noname234234> I think you would all say `you can't use python full functional` eh anyways I said that because I just redefine all variables everytime when I do changes on them xD
14:59:27 <tomsmeding> e.g. with parsec, you can use haskell's tools to build complex combinations of parser combinators that you don't have to write out by hand
14:59:56 <tomsmeding> but when you say "compiles to haskell functions", what exactly do you mean? is it a transpiler to haskell?
15:00:39 <tomsmeding> or is it a haskell library that parses your DSL, and makes the resulting functions available somehow to haskell code?
15:01:46 <tomsmeding> the first I'd call a language that compiles to haskell, the second an ?
15:01:57 <tomsmeding> like you call lua :p
15:02:07 <tomsmeding> wikipedia also uses 'embedded' there, but in a different way
15:04:10 <hyperisco> am I hosed if I am trying to decode Dhall to a recursive type?
15:04:39 <hyperisco> I am guessing so because the Expr for that type would not be bounded
15:08:37 <gnumonic> It's really just a simple scripting language I guess. I compile the haskell in which it is written to a binary, the binary parses user input into haskell functions and their arguments and then runs them. Not really more complicated than a calculator I guess. It could be an eDSL (i.e. I could make the parser just generate haskell source) but I want to distribute a binary for people who don't want to deal with ghc :p
15:09:55 <noname234234> how do you split file contents to lines by `\n`? 
15:10:11 <noname234234> im disappointed that I couldn't get a simple answer from google
15:10:19 <noname234234> everyone says some other package to install
15:10:20 <noname234234> lol
15:10:54 <Athas> gnumonic: if you made the parser generate Haskell source, then it would not be an eDSL, but just a compiler, wouldn't it?
15:10:59 <monsterchrom> > lines "abc\ndef\n"
15:11:02 <lambdabot>  ["abc","def"]
15:11:20 <noname234234> if I wanted to split on custom characters?
15:11:50 <monsterchrom> Then it's a simple recursion you can steal from the simple source code of lines
15:12:01 <monsterchrom> or the "split" package
15:12:18 <monsterchrom> I usually just steal. It's just 3 lines.
15:13:27 <noname234234> uh
15:13:41 <noname234234> is there a way to unload a module in ghci session?
15:13:43 <noname234234> Or I have to restart it
15:14:08 <yushyin> :m - ModuleA
15:14:52 <monsterchrom> If you do a :load on the module you want, that's also a reset.
15:15:32 <monsterchrom> That's a simplified story. The real story is much more nuanced than that.
15:15:48 * hackage streaming-bytestring 0.2.0 - Fast, effectful byte streams.  https://hackage.haskell.org/package/streaming-bytestring-0.2.0 (fosskers)
15:26:32 <noname234234> why this doesn't work? `foldr (++) ["str", "str"] [' ']`
15:27:10 <dibblego> foldr (++) ["str", "str"] [[" "]]
15:29:03 <noname234234> I think I have confused the argument order
15:29:36 <dsal> What are you trying to do there?
15:29:51 <dibblego> perhaps you want intercalate
16:22:44 <Raito_Bezarius> is there a way to compose boolean functions of the form a -> Bool arbitrarly using && and || ?
16:22:54 <Raito_Bezarius> (>= 32) && (<= 42) for example
16:23:04 <Raito_Bezarius> (which is not valid Haskell)
16:23:21 <dolio> liftA2 (&&)
16:23:41 <Raito_Bezarius> thanks dolio 
16:24:18 <Raito_Bezarius> dolio: is there a liftAn generalization?
16:24:40 <Raito_Bezarius> my use case is for 4 functions
16:26:24 <Raito_Bezarius> but I guess I can just do three liftA2
16:27:46 <dolio> Depends what you want. The incremental sort of solution is `f <$> x <*> y <*> z` where `f` is your boolean function, and x,y,z are your tests.
16:28:10 <dolio> You could use ApplicativeDo, too.
16:30:16 <Raito_Bezarius> Okay, I'll check out those, but maybe it's over kill to my usecase and I should just write the explicit function
16:38:22 <motte> say i have a record like this: data A = Foo String deriving (Show, Read)
16:38:32 <motte> doing read "Foo a" :: A fails, read "Foo \"a\"" :: A succeeds. is there a way to avoid the need for these quotes?
16:46:18 <Squarism> motte, would need to reimplement Read for String's 
16:47:01 <Squarism> but sounds really cumbersome and how would you deal with space
16:56:26 <motte> Squarism: alright, guess i won't bother then, thanks
17:00:26 <fresheyeball> hey
17:00:30 <fresheyeball> I have an api I need to query
17:00:41 <fresheyeball> that returns a gzip, and all I care about is the status code
17:00:48 <fresheyeball> is this doable with servant client?
17:14:30 <dsal> :t foldMap (All .) -- Raito_Bezarius 
17:14:31 <lambdabot> Foldable t => t (a -> Bool) -> a -> All
17:16:16 <dsal> > getAll . foldMap (All .) [even, (>5)] $ 4
17:16:18 <lambdabot>  False
17:16:19 <dsal> > getAll . foldMap (All .) [even, (>5)] $ 6
17:16:21 <lambdabot>  True
17:17:49 <dsal> > let isEvenAndBigEnough = getAll . foldMap (All .) [even, (>5)] in    isEvenAndBigEnough <$> [4..7]
17:17:51 <lambdabot>  [False,False,True,False]
17:40:00 <hekkaidekapus> > sortBy (comparing even <> comparing (> 5)) [4..7] -- dsal, let‚Äôs golf :)
17:40:02 <lambdabot>  [5,7,4,6]
17:40:13 <hekkaidekapus> > sortBy (comparing even <> comparing (< 5)) [4..7]
17:40:15 <lambdabot>  [5,7,6,4]
17:40:41 <hekkaidekapus> > sortBy (comparing odd <> comparing (> 5)) [4..7]
17:40:43 <lambdabot>  [4,6,5,7]
17:50:27 <olligobber> :t even
17:50:29 <lambdabot> Integral a => a -> Bool
17:51:01 <olligobber> what?
17:51:31 <hekkaidekapus> olligobber, what did you expect?
17:52:06 <olligobber> I'm just confused by what comparing and <> are doing in your code
17:52:20 <dsal> :t comparing
17:52:21 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
17:52:36 <olligobber> oh I see
17:52:44 <hekkaidekapus> > sortBy (comparing even <> comparing (>5)) (reverse [1..11])
17:52:46 <lambdabot>  [5,3,1,11,9,7,4,2,10,8,6]
17:52:52 <olligobber> wait, there's a <> instance for Ord?
17:52:53 <dsal> It's a sort thing to take two values and a function to build a shwartzian transform for sorting.
17:53:01 <dsal> Yeah, it's super useful.
17:53:08 <olligobber> *Ordering
17:53:22 <dsal> * Semigroup  :)
17:53:25 <dsal> > LT <> GT
17:53:27 <lambdabot>  LT
17:53:36 <hekkaidekapus> @where monoids -- olligobber, the monoid instance for functions is a superstar topic around here.
17:53:37 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
17:53:37 <lambdabot> instance Monoid a => Monoid (rho -> a)'
17:54:00 <olligobber> oh, I know about the monoid instance for functions
17:54:07 <olligobber> used it myself when golfing a quine
17:54:58 <dsal> > fold [EQ, EQ, LT, GT]
17:55:00 <lambdabot>  LT
17:55:06 <dsal> > fold [EQ, EQ, GT, LT, GT]
17:55:08 <lambdabot>  GT
17:55:15 <dsal> In practice, it does the thing you'd want.
17:55:44 <dsal> > mempty :: Comparing
17:55:46 <lambdabot>  error:
17:55:46 <lambdabot>      Not in scope: type constructor or class ‚ÄòComparing‚Äô
17:55:53 <olligobber> it returns the first non-EQ thing?
17:55:53 <dsal> > mempty :: Ordering
17:55:55 <lambdabot>  EQ
17:55:59 <dsal> *sigh*  But yeah, it's a monoid as well.
17:56:01 <dsal> Yeah.
17:57:08 <olligobber> I still haven't used comparing enough to figure this code out
17:57:23 <olligobber> I'm starting to get it though
17:57:28 <MarcelineVQ> :t comparing even
17:57:29 <lambdabot> Integral a => a -> a -> Ordering
17:57:45 <olligobber> ok, I think I get it now
17:58:02 <dsal> The question Raito_Bezarius had was about combining `a -> Bool` functions, which means you have to ask what it means to combine bools.  So there are two different monoids.
17:58:25 <dsal> even is a weird way to compare numbers.
17:59:05 <dsal> > comparing length "a long string" "x"
17:59:07 <lambdabot>  GT
18:04:30 <la-jesystani> howdy, has anyone here built a program using nix flakes? id be really interested to hear about it
18:11:03 <servo> HELLO ALL MEMEBERS
18:11:39 <hekkaidekapus> Hi, servo.
18:12:06 <servo>  what type of work her ? plz
18:13:25 <hekkaidekapus> servo, please ask a Haskell-related question?
18:15:28 <hekkaidekapus> dsal | ‚Äúeven is a weird way to compare numbers.‚Äù What else to use when comparing numbers without even being odd?
18:48:19 * hackage reanimate 1.1.2.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-1.1.2.0 (DavidHimmelstrup)
19:06:37 <simon> dsal, isn't xor a third candidate?
19:30:10 <dsal> simon: not sure how that would work, but give it a shot! :)
19:33:42 <koz_> dsal: Bool is a monoid under xor and False.
19:33:58 <koz_> s/False/True/ argh
19:34:11 <koz_> Nope it was False, lol.
19:34:14 <koz_> I always get this wrong.
19:36:46 <dsal> You mean mempty is true?  Where is this defined?
19:41:17 <koz_> dsal: Nowhere presently.
19:41:34 <koz_> I did send a thing to the libraries ML a while ago for newtypes to this effect, but it attracted zero attention.
19:41:52 <koz_> (and it's False for xor)
19:42:18 <koz_> Because False `xor` False = False (because they're the same) and False `xor` True = True (because they're different).
19:55:18 <int-e> > let xor = (/=) in xor <$> [False,True] <*> [False,True]
19:55:20 <lambdabot>  [False,True,True,False]
20:59:49 * hackage vulkan 3.6.11 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.11 (jophish)
23:39:20 * hackage telegram-bot-simple 0.3.3 - Easy to use library for building Telegram bots.  https://hackage.haskell.org/package/telegram-bot-simple-0.3.3 (swamp_agr)
