00:39:15 <z0> i just found out you can have infix arguments: f (><) x = x >< x ; f (+) 3 => 6 ; f (*) 3 => 9
00:44:31 <dminuoso> z0: How is that infix arguments?
00:44:43 <dminuoso> And, what is an "infix argument" even?
00:45:49 * hackage metro 0.1.0.4 - A simple tcp and udp socket server framework  https://hackage.haskell.org/package/metro-0.1.0.4 (Lupino)
00:46:16 <dminuoso> Oh.
00:46:36 <dminuoso> It felt so intuitive, I didn't even notice what you did there.
00:46:50 <dminuoso> z0: What's also cool, is that you can have infix data constructors :)
00:48:39 <z0> dminuoso: yup :) i didnt know how to call it besides infix arguments
00:49:09 <dminuoso> operator arguments maybe?
00:50:59 <z0> that makes more sense
00:52:33 <dminuoso> z0: Somewhat relatedly, one can define fixity declarations for non-operator variables/data construtors as well. :)
00:55:35 <z0> dminuoso: ha, i never thought of that! but how could you not
00:56:47 <ski> > let f (><) x = x + x >< x ^ x where infixl 7 >< in f (*) 2  -- :(
00:56:50 <lambdabot>  error:
00:56:50 <lambdabot>      The fixity signature for ‘><’ lacks an accompanying binding
00:56:50 <lambdabot>        (The fixity signature must be given where ‘><’ is declared)
00:57:41 <dminuoso> % infix 6 `f`; f = (+) -- z0 
00:57:41 <yahb> dminuoso: 
00:58:57 <ski> % :i div
00:58:58 <yahb> ski: type Integral :: * -> Constraint; class (Real a, Enum a) => Integral a where; ...; div :: a -> a -> a; ...; -- Defined in `GHC.Real'; infixl 7 `div`
00:59:18 <dminuoso> % infixr 5 `Cons`; data List a = Nil | Cons a (List a) deriving Show
00:59:18 <yahb> dminuoso: 
00:59:25 <dminuoso> % 1 `Cons` 2 `Cons` 3 `Cons` Nil  -- z0 
00:59:25 <yahb> dminuoso: Cons 1 (Cons 2 (Cons 3 Nil))
00:59:58 <z0> is it impossible to define fixity for operator arguments?
01:00:07 <dminuoso> Mmm, I think not
01:00:37 <dminuoso> I'd have to study the grammar to be sure though
01:00:47 <ski> > let f g x = x + x >< x ^ x where infixl 7 ><; (><) = g in f (*) 2  -- is possible
01:00:51 <lambdabot>  10
01:00:57 <dminuoso> Oh.
01:01:05 <dminuoso> Right, because it's a declaration then
01:01:39 <ski> i'm not sure whether you could associate a fixity declaration to a variable bound by a pattern in a function definition definiendum, though
01:02:31 <z0> ski: yeah, that's what i got from your first example
01:02:32 <ski> > let f (let infixl 7 >< in (><)) x = x + x >< x ^ x in f (*) 2  -- no workee
01:02:35 <lambdabot>  <hint>:1:8: error:
01:02:35 <lambdabot>      <hint>:1:8: error: (let ... in ...)-syntax in pattern
01:05:20 <ski> mm. for some reason the derived `Show' (and `Read') instances doesn't really seem to take fixity (as opposed to precedence) into account. and not using the infix form, either, of a non-operator constructor identifier, despite having a fixity&precedence declaration in scope at the point of the deriving request
01:05:39 <ski> % deriving instance Read a => Read (List a)
01:05:39 <yahb> ski: 
01:06:02 <ski> % (reads :: ReadS (List Int)) "1 `Cons` 2 `Cons` 3 `Cons` Nil"
01:06:02 <yahb> ski: []
01:06:50 <ski> (i thought that maybe the `Read' instance would at least accept it, as an alternative syntax. but i guess it doesn't. probably doesn't feel the need to, since the derived `Show' instance can't generate output of that form)
01:07:15 <ski> % (reads :: ReadS (List Int)) "1 `Cons` (2 `Cons` (3 `Cons` Nil))"
01:07:16 <yahb> ski: []
01:13:49 * hackage hs-server-starter 0.1.2.0 - Write a server supporting Server::Starter's protocol in Haskell  https://hackage.haskell.org/package/hs-server-starter-0.1.2.0 (hiratara)
01:14:49 * hackage nri-prelude 0.1.0.3 - A Prelude inspired by the Elm programming language  https://hackage.haskell.org/package/nri-prelude-0.1.0.3 (JasperWoudenberg)
01:54:04 <dminuoso> ski: They do
01:54:12 <dminuoso> Consider:
01:54:19 * hackage uniqueness-periods-vector-examples 0.12.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.12.0.0 (OleksandrZhabenko)
01:55:30 <dminuoso> % infixr 5 :*:; data l :*: r = l :*: r deriving Show;
01:55:30 <yahb> dminuoso: 
01:55:35 <dminuoso> 1 :*: 2 :*: 3
01:55:40 <dminuoso> % 1 :*: 2 :*: 3
01:55:41 <yahb> dminuoso: 1 :*: (2 :*: 3)
01:55:43 <dminuoso> % infixl 5 :*:; data l :*: r = l :*: r deriving Show;
01:55:43 <yahb> dminuoso: 
01:55:45 <dminuoso> % 1 :*: 2 :*: 3
01:55:45 <yahb> dminuoso: (1 :*: 2) :*: 3
01:57:50 <dminuoso> "The result of show is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces."
01:57:52 <dminuoso> Mmm
01:58:09 <dminuoso> "If the constructor is defined to be an infix operator, then the derived Read instance will parse only infix applications of the constructor (not the prefix form)."
01:58:14 <dminuoso> (The latter one also applies to Show)
01:58:25 <dminuoso> I guess the Haskell report leaves this a bit open to interpretation
01:59:00 <dminuoso> But at the end show doesnt print your ast, which is why something like
01:59:46 <dminuoso> show (1 :*: 2 :*: 3) = 1:*: (2 :*: 3)
02:00:01 <dminuoso> (or not ast, rather cst)
02:21:16 <ski> dminuoso : hm, doesn't seem to me like they do, from those examples
02:24:20 <dminuoso> ski: regarding that latter fact the haskell report is quite clear though
02:24:42 <dminuoso> "Associativity is not used to reduce the occurrence of parentheses, although precedence may be"
02:27:01 <ski> right, as i thought
02:28:20 <ski> (if/when i do manual `Show' instances, i guess i do tend to take fixity/associativity into account, as well)
02:30:28 <dminuoso> Sure, the haskell report has all these rules about Show/Read for deriving generated only.
02:30:41 <dminuoso> So even the `read . show = id` law doesnt matter for handwritten instances
02:31:55 <ski> yea, i do try to ensure that :)
02:32:01 <ski> (for finite inputs)
02:33:04 <dminuoso> Ultimately I think Show is a misguided typeclass.
02:33:44 <dminuoso> Precisely because it has no proper laws, and with the open-world assumptions and singular instances you generally don't have a sensible obvious canonical instance for most things
02:34:18 <ski> elaborate on "open-world assumptions and singular instances" ?
02:34:36 <dminuoso> Well, so lets say you have some library with some fancy data type and you provide a Show instance.
02:34:59 <dminuoso> Why provide that Show instance at all? You can't possibly know how I need to turn that thing into a string, what formatting I want, what sort of visualizatoin
02:35:24 <ski> yea. that's for pretty-printing
02:36:21 <dminuoso> For debugging, sure. Though from experience you quickly hit concrete walls anyway, since you quickly have parametrized types with tyfams (solvable, but it adds more annoyance), or you have functions inside them
02:36:21 <ski> (i guess it might be nice with some kind of pretty-printing (within the bounds of the syntax of Haskell), could still be nice, when testing, debugging)
02:36:43 <dminuoso> Or you have some IO action inside.. things that are just not Showable
02:36:44 <ski> yea, that's a problem
02:37:04 <ski> it's not really a good candidate for serializatoin
02:38:08 <dminuoso> And for pretty printing, a typeclass is a bad fit because any instance you provide resides in the open world, so you either have a very clear canonical way of pretty printing, or you end up with a bunch of `pprFooWithColors, pprFooWithoutDetails` functions
02:39:18 <ski> mm. for something that's supposed to bring different pieces of code, possibly done by different people, together, i think only the former of those two could possibly be reasonable
02:40:40 <ski> there's also the option that perhaps we shouldn't really be constructing strings, but some kind of code representation. say `Exp' or `TExp T'
02:41:27 <ski> (this could perhaps also solve, or at least help ameliorate, the issue of having different bindings in scope, possibly qualified imports, maybe with renaming, &c.)
02:42:04 <dminuoso> Do you mean in the sense of TH quotation?
02:42:13 <ski> yes. or something akin to that
02:42:30 <ski> a representation where identifiers know where they're bound
02:42:38 <dminuoso> At the very least with TH you have proper `id ~ antiquotation . quotation` laws.
02:43:28 <ski> the MLs don't really have `Show', from what i recall. but using a standard generic printer
02:44:10 <ski> (hm, possibly one can register a printer, for a particular type, in the interactor. seem to have a vague memory of something like that)
02:44:52 <ski> but then, how'd one handle abstract data types ? one'd like to present values, in terms of exported API
02:45:08 <dminuoso> I mean the GHC deriving generated Show instance is a standard generic printer.
02:45:12 <dcabrejas> Hi, quick question about testing with stack & quickcheck. I can run tests for my local project by "stack test", however I only have a single test file, is it possible to create multiple test files and then have them all run when running "stack test"? My single file is getting large and I would like to group related tests in different files. Thank
02:45:12 <dcabrejas> you.
02:45:26 <dminuoso> With the option of manual control, since you can just write an instance by hand if you wanted to.
02:45:34 <ski> i guess one alternative, depending, could be to define an alternative type, where the API operations are the data constructors, and then translate a value to that representation, prior to showing
02:45:49 <ski> (the showing being provided automatically by the system)
02:45:50 <dminuoso> But functions/IO/existentials/etc do bind GHCs hands
02:45:54 <dminuoso> *tie
02:46:24 <dminuoso> ski: Sure, so something like free monads rather?
02:46:33 <dminuoso> (in spirit)
02:46:54 <ski> all the derived `Show' instances together would correspond to the standard printer, in the MLs, was rather the comparision i had in mind
02:47:41 <ski> well, this "free" representation would only be used, when you wanted to have an abstract data type
02:49:08 <ski> (e.g. in Mercury, you explicitly declare when a data-type is to have any other than the structural equality (so that the data constructors no longer need to be injective, meaning that matching can, conceptually, give multiple alternative sets of bindings))
02:50:50 <dminuoso> Mmm, how can matching give multiple alternative sets of bindings?
02:50:59 <dminuoso> Not sure I understand that
02:54:54 <ski> well, let's say `data Ratio a = a :% a'. you define `n0 :% d0 == n1 :% d1 = n0 * d1 == n1 * d0'. if you really mean this, then `(:%)' is not injective, since `1 :% 2 == 2 :% 4' is `True'
02:55:39 <ski> so, conceptually, if you do `let f (n :% d) = ..n..d.. in f (1 :% 2)', you could bind `n = 1; d = 2', but you could just as well bind `n = 2; d = 4', or other choices
02:57:20 <dminuoso> Ah I see
02:57:21 <ski> with this comes the proof obligation that if matching the input could produce both `n = n0; d = d0' and `n = n1; d = d1', then, you should prove that the body `..n0..d0..' is equal to the body `..n1..d1..', provided that you only know that `n0 * d1 == n1 * d0' is `True'
02:58:41 <ski> in Haskell, you have to think about this matters, on your own (or fail to do so), with no help from the implementation (since it doesn't know that you're defining a quotient type (having a user-defined equality), or perhaps a subtype, or a combination of the two)
02:59:09 <ski> while, in Mercury, the implementation is aware that your data constructors are not injective, and will flag your code as non-deterministic
03:00:10 <ski> you can't really prove to it that, at some point, the non-determinism doesn't matter, is "cancelled out". but you can promise to it, at that point, that that is the case (and that discharges the non-determinism that otherwise would taint every operation that calls the present one)
03:01:30 <ski> the reason why Mercury has to do this (if it wants to support quotient types (as represented via abstract data types), sanely), is because in Mercury, equality checking is more closely integrated with semantic equality. conceptually it's the same predicate there, unlike in Haskell, which distinguishes `==' from `='
03:03:39 <ski> (from the POV of Haskell, `(==)' is just another type class method. the implementation doesn't really assume that it respects some laws that one'd expect equality to satisfy. while in Mercury, the implementation does rely on such laws)
03:12:49 * hackage servant-docs-simple 0.3.0.0 - Generate endpoints overview for Servant API  https://hackage.haskell.org/package/servant-docs-simple-0.3.0.0 (HolmuskTechTeam)
03:16:20 <dminuoso> ski: I guess its two fold since Haskell implementations to assume reflexivity and transitivity of (=) at least.
03:25:43 <kuribas> ski: I was wondering, in dependently typed languages you could require class instances to come with proofs, and then have rewrite rules based on those proofs.
03:26:05 <kuribas> ski: it would allow for more optimizations.
03:29:23 <ski> dminuoso : library operations, yea. but not the language implementations themselves, afaik
03:29:37 <ski> kuribas : yea .. possibly
03:30:57 <ski> (then, in HoTT, one could express quotient types with extra "equality constructors" of a data-type. and then, when defining a function, matching on inputs of that type, one'd also need to (forced by the type system, and exhaustiveness checker) prove the well-definedness condition exemplified above)
03:55:10 <burritoprogramme> exercises to do while learning haskell in uni?
03:55:44 <no-n> lift
03:56:00 <no-n> lift as much as possible
03:56:17 <burritoprogramme> :(
03:56:21 <Rembane> There are some good ones but I've forgotten the link. ski, do you know the command to the Stanford course? 
03:56:29 <burritoprogramme> or eat borritos?
03:56:37 <no-n> yes
03:56:40 <davve> project euler
03:57:04 <no-n> lift burritos if you can
03:57:43 <Rembane> burritoprogramme: Lets start with this one: https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
03:58:01 <davve> ^ all the best students from my CS class did P.E excercies :P
03:58:31 <davve> good challenges
03:59:30 <davve> not haskell-specific in any way, but haskell is a good place to solve them and there are haskell solutions to everything
03:59:40 <Squarism> ghoulguy, hey. You dont happen to be around? I have a question about the addressing solution you proposed.
04:19:39 <Zetagon> burritoprogramme: I found this to be very good: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
04:20:21 <Zetagon> aw they left
04:26:49 * hackage uniqueness-periods-vector-properties 0.5.4.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.5.4.0 (OleksandrZhabenko)
04:29:14 <dminuoso> ski: GHCs capability to both inline or let-float, is that not using the symmetric proprety of equality?
04:33:17 <dminuoso> mmm.. no I guess not
04:33:50 <dminuoso> Well, but transitivity is assumed by the fact that the simplifier could repeatedly inline, and it's valid because equivalence is transitive.
04:53:19 * hackage uniqueness-periods-vector-examples 0.12.1.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.12.1.0 (OleksandrZhabenko)
05:37:49 * hackage aeson-deriving 0.1.1.2 - data types for compositional, type-directed serialization  https://hackage.haskell.org/package/aeson-deriving-0.1.1.2 (Cliff_Harvey)
05:39:50 <siraben> Is there a way to read a value from a Text other than `(read . T.unpack)`?
05:41:21 <tomjaguarpaw> Hoogle doesn't give any obvious suggestion: https://www.stackage.org/lts-16.17/hoogle?q=Read+a+%3D%3E+Text+-%3E+a
05:43:30 <__monty__> There's Megaparsec (or other parser combinators).
05:46:19 <maralorn> Are there any parsing libraries, where the parser type has a Lift instance?
05:47:53 <__monty__> Isn't being a monad transformer enough? (I'm not familiar.)
06:00:49 * hackage vulkan 3.6.9 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.9 (jophish)
06:13:49 * hackage in-other-words 0.1.0.0 - A higher-order effect system where the sky's the limit  https://hackage.haskell.org/package/in-other-words-0.1.0.0 (KingoftheHomeless)
06:35:13 * sureyeaah sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/alUKhbzZLSPgQjulLNSJZcLb/message.txt >
06:37:38 <sureyeaah> What am I doing wrong? Also is there a better way of doing what I'm trying to do?
06:38:26 <Entroacceptor> sureyeaah: at first, you probably want to use /usr/bin/cat
06:39:05 <Entroacceptor> echo just outputs its parameters and quits, totally ignoring its stdin.
06:39:20 <merijn> sureyeaah: Your message got replaced with some matrix link due to being too long and generally many people ignore those links
06:40:28 <sureyeaah> Entroacceptor: Okay, I changed that. Also I realised I should be swapping those handles since `hin` is where I should be writing and not reading from.
06:40:46 <sureyeaah> Here's the new code:
06:40:53 * sureyeaah sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/cWDzSDVdMkOOvCyagGIaEEVF/message.txt >
06:41:16 * sureyeaah sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/nkbpKzmuWjLpJJbTNMOAbSeS/message.txt >
06:41:29 * sureyeaah sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/xvdMrDoUPSOkuEEkMcxYCbJO/message.txt >
06:41:38 <sureyeaah> This doesn't show any output
06:41:53 <sureyeaah> merjin: thanks, better now?
06:42:04 <sureyeaah> merijn:
06:45:19 * hackage reanimate 1.1.1.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-1.1.1.0 (DavidHimmelstrup)
07:07:20 <Guest_59> I can't install Haskell on my mac
07:07:49 * hackage cmaes 0.2.3 - CMA-ES wrapper in Haskell  https://hackage.haskell.org/package/cmaes-0.2.3 (DominicSteinitz)
07:10:02 <Guest_59> nothing worked
07:14:18 <Uniaika> welp
07:15:29 <maerwald> :D
07:16:19 <maerwald> I think these are instances of: oh f**k, I need to hand in the assignment on monday and I don't even have a develompent env -> panic
07:17:00 * Uniaika is glad not to have had that kind of relationship to the language
07:17:22 <maerwald> that's how you fail the course :D
07:17:29 <maerwald> at least in haskell
07:17:51 <yushyin> oO
07:17:54 <yushyin> again?!
07:18:58 <maerwald> Maybe someone should give a lecture about how to adjust your PATH variable before the haskell course :p
07:20:03 <yushyin> yes, that would be absolutely necessary and appropriate
07:20:25 <maerwald> I remember we had a unix/linux course, in fact
07:20:34 <maerwald> first year
07:20:43 <yushyin> it is getting ridiculous, tbh
07:21:07 <Uniaika> IMO, this unofficial course is fairly good https://missing.csail.mit.edu/
07:35:07 <maralorn> __monty__: I wasn‘t looking for a monad transformer. I was talking about the Lift instance from TH. There it would mean that you could compute your parser at compile time, apparently they call it staging. I was wondering if there already is a lib that does that.
08:05:35 <dwts> dsal: I heard your advice and just got the haskellbook. I just started reading it
08:16:07 <merijn> maralorn: Yes!
08:16:10 <merijn> maralorn: Sorta
08:16:18 <merijn> @hackage validated-literals
08:16:18 <lambdabot> https://hackage.haskell.org/package/validated-literals
08:20:54 <maralorn> merijn: Cool! But I didn‘t mean parsing at compile time. I meant constructing the Parser at compile time but applying it at runtime.
08:21:34 <merijn> maralorn: I mean, nothing restricts that library to parsing
08:21:50 <merijn> maralorn: You can basically use it to reify any value computed by a pure function :p
08:22:09 <maralorn> What?
08:22:37 <maralorn> How does the parser get represented in the generated TH?
08:22:50 <maralorn> *generated Code
08:23:31 <merijn> maralorn: By default I use the Lift instance, which is easy since GHC has -XDeriveLift since (I think?) 8.0
08:24:09 <maralorn> But can you derive Lift for a Monadic Parser?
08:24:23 <merijn> I mean, I don't see why not?
08:24:58 <maralorn> Because you need to be able to reify arbitrary functions?
08:25:22 <maralorn> Hm, okay. That means you just write arbitrary functions into the code.
08:25:33 <merijn> Well, you don't need to reify arbitrary ones, you need to reify calls to the very specific ones used in the parser
08:27:04 <maralorn> Yeah, I realize, that they are more a problem for the hope of optimizing a parser at compile time.
08:27:50 * hackage BNFC 2.8.4 - A compiler front-end generator.  https://hackage.haskell.org/package/BNFC-2.8.4 (AndreasAbel)
08:28:08 <maralorn> But I mean if can reify "Parser Text" I also have to be able to reify "f <$> Parser Text" for all f : Text -> Text, right?
08:28:18 <maralorn> But that has nothing to do with being monadic …
08:41:20 * hackage type-of-html 1.5.2.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.5.2.0 (knupfer)
09:26:49 * hackage lucid-cdn 0.2.1.0 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.2.1.0 (locallycompact)
09:46:49 * hackage bugsnag-hs 0.2.0.2 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.2.0.2 (JasperWoudenberg)
10:13:29 <gattytto> hello
10:13:50 <gattytto> I managed to make use of haskell extensions in che web ide, thanks to some help from here and other sources :D  
10:14:59 <gattytto> now while testing this project https://github.com/gattytto/example-servant-minimal/tree/ghci-dap I am running with an error when trying "stack test" that says: "Not in scope: type constructor or class `ServantError'"
10:37:41 <frdg> what is a known algorithm to determine if a relation, ie `[ (a,a) ]` is reflexive? I can hack it but I am looking for a nicer solution.
10:45:44 <bifunc2> With cereal (serialization library) I'm finding deserializing Word64s is much faster than deserializing Doubles. Is this something you'd expect?
10:59:11 <c_wraith> Depends on the serialization format.  I don't know what cereal uses.
11:01:48 <koz_> frdg: For totally arbitrary relations, the only way to 'determine' this is if the relation is finitary.
11:02:00 <bifunc2> c_wraith sorry, i forgot to mention i'm doing big-endian for both
11:02:52 <bifunc2> (btw i got disconnected there for a while and may not have seen some messages)
11:02:57 <c_wraith> bifunc2: ok...  the short answer is "yes", especially if you're doing millions of them. 
11:03:17 <c_wraith> bifunc2: https://hackage.haskell.org/package/cereal-0.5.8.1/docs/src/Data.Serialize.IEEE754.html#wordToDouble
11:04:32 <c_wraith> bifunc2: that call to alloca is a problem for performance, because it's part of the FFI
11:05:03 <c_wraith> bifunc2: it has to put it in a separate memory space (outside the nursery) because it needs a stable address in case it's passed to C code
11:05:46 <c_wraith> bifunc2: that means both allocating and collecting it are going to be slower than they would be for something managed entirely in GHC's nursery
11:06:14 <bifunc2> c_wraith has nobody (other than cereal) made anything faster yet?
11:08:07 <dolio> The new binary might be faster, but it uses a particular format, not just 'whatever bits you want to spit out'.
11:09:20 <dolio> I guess it's called cborg now?
11:09:39 <dolio> Or serialise?
11:10:19 <bifunc2> hmm, no idea..
11:11:02 <ghoulguy> I think one is the format: cborg and the other is a serialization library using that: serialise
11:11:18 <ghoulguy> I like that better as other languages have libraries to read cbor
11:11:29 <dolio> Yeah.
11:11:50 <dolio> Anyhow, my understanding is that their technique for implementation is more reliable, too.
11:12:10 <bifunc2> hmm cereal is not just standard? big-endian for word64 is standard. it uses IEEE754 for doubles
11:12:47 <ghoulguy> cereal is legacy, I would advise people not to use it, it's unmaintained and there's really no reason not to use binary if you don't care much about how you serialize things
11:13:38 <dolio> The only reason I ever hear for using cereal is, "it's required for this other library," and usually by people who are telling me because they'd rather not use cereal.
11:13:50 <dolio> Lately, that is.
11:13:51 <bifunc2> ah, i did not know that, thanks!
11:14:03 <bifunc2> Now the question is, "binary" vs. "store"?
11:14:18 <bifunc2> (for machine representation, where explicit endianess is not important)
11:15:48 <dolio> Anyhow, one of the other advantages of serialise/cborg, in my understanding, is that they wrote it so that only a fixed loop (which is part of the package) needs to be well optimized by GHC.
11:16:39 <dolio> And that is relatively reliable, whereas the old binary/cereal relied on whatever instances anyone wrote to be optimized in each end-program, which is less reliable.
11:17:16 <dolio> So in principle, binary might be slightly faster if everything goes according to plan, but often it doesn't.
11:17:36 <dolio> And you have to put in more effort to make sure it does.
11:19:26 <dolio> It's like the usual, "I could write faster assembly code than a compiler," but then you don't.
11:20:08 <c_wraith> I'm really surprised GHC.Exts doesn't export primops for Double# <-> Word64# and Float# <-> Word32# that just ship bytes back and forth instead of doing numeric conversions
11:21:35 <dolio> I've got `Word# -> Double#` in GHC.Prim (but not the reverse).
11:22:02 <dolio> Not sure how that actually makes reliable sense.
11:22:43 <c_wraith> I'm pretty sure that is a numeric conversion, not byte-shipping
11:22:59 <dolio> Oh, that makes sense.
11:23:50 <dolio> I guess you need to make byte arrays to convert.
11:23:53 <phadej> Does even C make it easy, or is the way is to use `union { .. }` /
11:24:05 <c_wraith> union is the only correct way in C
11:24:17 <c_wraith> But at least that can be done on the stack
11:24:20 * hackage hwk 0.2.0 - A modern Haskell based AWK replacement  https://hackage.haskell.org/package/hwk-0.2.0 (JensPetersen)
11:24:43 <dolio> I don't think that's actually guaranteed to work in C>
11:24:52 <dolio> It would be implementation dependent.
11:27:58 <c_wraith> Prelude GHC.Exts> D# (word2Double# 3##)   ->  3.0
11:28:13 <dolio> Okay, yeah.
11:28:20 <dolio> That explains why the reverse doesn't exist.
11:28:26 <c_wraith> Today I learned the syntax for Word# and Double# literals
11:30:16 <c_wraith> Amusingly, the name Double# tells you what the syntax is.
11:31:10 <bifunc2> I'm finding deserializing Word64s 10x slower on binary than cereal
11:31:21 <bifunc2> Double deserialization is 2x slower on binary
11:31:26 <bifunc2> sad...
11:31:31 <bifunc2> hmm
11:31:39 <bifunc2> even when cereal is "legacy"
11:34:44 <koz_> dolio: Like basically everything.
11:34:50 <dolio> Yes.
11:34:50 <koz_> (which isn't straight-up UB)
11:35:36 <dolio> But I think whether it works is even independent of whether 'double' is "compatible" with the integer type.
11:36:03 <dolio> Which is a second implementation-specific behavior.
11:36:17 <koz_> C: Putting the 'lowest' in 'lowest common denominator' since 1976.
11:36:18 <dolio> If they are compatible, then pointer casting might work, but I'm unsure.
11:44:49 * hackage uncaught-exception 0.1.0 - Customize uncaught exception handling.  https://hackage.haskell.org/package/uncaught-exception-0.1.0 (gromak)
11:46:26 <dolio> I think the only thing that's guaranteed to work with a union (aside from reading back exactly what you put in) is structure subtyping.
12:00:53 <koz_> Galaxy brain take: use inline-asm for this. :P
12:06:19 <dolio> I wonder if you can use the 'prim' (or whatever) foreign import to implement it in Haskell.
12:06:37 <dolio> Or GHC.
12:08:55 <dolio> Nah, that's probably still too heavy.
12:42:54 <frdg> Would you say this a decent way to express forAll and thereExists? https://dpaste.org/dAXQ
12:48:16 <dsal> frdg: your arguments look backwards to me.
12:50:10 <frdg> dsal. ok. But there is no way to drop an instance for `t` correct? At least I cant think of a way.
12:50:22 <dsal> :t or
12:50:25 <lambdabot> Foldable t => t Bool -> Bool
12:50:26 <dsal> :t all
12:50:28 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:50:59 <davean> frdg: you can push the part you're fmapping into the foldr's function along with the (&&)
12:51:24 <dsal> Yeah, I realized or isn't quite the same, but I'd do that.
12:52:01 <frdg> hmm so there is a way
12:52:20 <davean> frdg: and from the Functor laws you know there is a way really
12:53:05 <frdg> alright thank you ill try to figure this out.
12:53:08 <dsal> :t \p -> getAny . foldMap (Any . p)
12:53:10 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
13:02:42 <frdg> davean: I was able to get rid of the functor instance by composing p with (&&) and (||) like you said thanks
13:03:37 <davean> frdg: that composition is basicly what the functor laws say a functor is BTW
13:04:13 <frdg> right. fmap f . fmap g == fmap (f . g)
13:04:38 <frdg> this is exactly what I did
13:15:45 <dsal> Oh, I finally looked at the docs.  It's `any` not `or`.  I get `all` and `and` confused and `or` and `any` confused.
13:15:48 <dsal> :t any
13:15:50 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
13:16:34 <dsal> Oh wow, my guess was right, though.  heh  `any p = getAny #. foldMap (Any #. p)`
13:16:39 <dsal> Except I don't know what `#.` is.
13:17:18 <dsal> `(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)` -- oh wow.  That seems... redundant
13:17:21 <MarcelineVQ> infix coerce iirc
13:18:57 <dolio> The first argument is a dummy, right?
13:19:09 <dolio> Just telling it which b and c to use.
13:20:07 <dolio> The presumption is that you will use the half of the isomorphism you want.
13:22:11 <dsal> I don't understand why there's coercion at all.  You could use it if you didn't want to specify `Any` on the right.  or maybe the left.
13:22:35 <dsal> % let f p =  foldMap (coerce . p); v = f even [1,2,3] in    (getAll v, getAny v)   -- I mean, you can have the same implementation for both but you do need to mention the semigroup at some point.
13:22:35 <yahb> dsal: (False,True)
13:22:59 <MarcelineVQ> There's a note about it below the defintion of #.
13:24:27 <dsal> Ha.  I don't expect useful information in comments.
14:02:56 <foo6> @lambdabot let (Foo a) = a in abc a
14:02:56 <lambdabot> Unknown command, try @list
14:03:23 <foo6> @list
14:03:24 <lambdabot> What module?  Try @listmodules for some ideas.
14:03:42 <foo6> @pl let (Foo a) = a in abc a
14:03:42 <lambdabot> (line 1, column 5):
14:03:42 <lambdabot> unexpected "("
14:03:42 <lambdabot> expecting "()", natural, identifier or "in"
14:04:08 <foo6> @pl let (Foo a) = 123 in abc a
14:04:09 <lambdabot> (line 1, column 5):
14:04:09 <lambdabot> unexpected "("
14:04:09 <lambdabot> expecting "()", natural, identifier or "in"
14:10:14 <crestfallen> hi what would be the quickest way to put (!>) to use? http://ix.io/2AkS
14:10:49 <crestfallen> it's the same as >=> I believe. I forget if I ever got it to work..
14:16:41 <crestfallen> a poor place to start reviewing haskell again?
14:18:08 <Squarism> Warning, maybe flawed question. Say I have a class instance : instance MyClass a b. If I want to express that there is an instance for all parameterized types instead of b, how would one do that? 
14:19:10 <Squarism> incomprehensible question?
14:22:43 <clmg> I'm running archlinux. I have a lot of `haskell-` packages installed via pacman already. But when I run, e.g., `stack install hakyll`, it starts downloading a lot of packages. I want to use stack to get multiple versions of haskell, but I don't want packages installed both via pacman and via stack.
14:26:39 <maerwald> clmg: what's the question?
14:27:02 <dsal> Squarism: A little.  What do you mean "for all parameterized types"?
14:28:28 <phadej> probably something like MyClass a (f b)
14:28:46 <clmg> maerwald: how do I figure out why I have `haskell-` packages installed via pacman, when I'm already using stack?
14:30:10 <maerwald> clmg: because you installed them
14:30:10 <clmg> Pacman says they are installed because they're required by stack. But shouldn't stack download them itself? Why does stack rely on pacman sometimes and other times not?
14:30:39 <dsal> stack shouldn't require much of anything.
14:31:33 <maerwald> clmg: don't install stack via pacman
14:31:34 <yushyin> download the static build binary from the stack website and you won't need the haskell- packages ...
14:31:38 <clmg> dsal: exactly. so why when I run `pacman -Qi haskell-mustache` does it say: `required by: stack`
14:32:04 <yushyin> of course the pacman stack will depend on some haskell- packages on arch linux
14:32:37 <clmg> So I should `-R stack` and curl `get.haskellstack.org`
14:32:39 <clmg> right?
14:32:51 <maerwald> just download the binary
14:33:03 <maerwald> the install script is terrible, it invokes sudo I believe
14:33:28 <maerwald> https://github.com/commercialhaskell/stack/releases/tag/v2.3.3
14:33:59 <clmg> Ah I see (from arch wiki Haskell page): "Alternatively, Stack can be installed through stack-staticAUR package. It provides statically linked binaries, thereby avoiding dozens of haskell-* dependencies."
14:34:14 <maerwald> don't do that either
14:34:43 <maerwald> then you'll have stack in two places when I tries to auto-upgrade itself I think
14:34:54 <clmg> hmmm what's wrong with stack-static? that way I can keep it up to date via AUR
14:35:01 <MarcelineVQ> If I was gonna install stack via pacman I'd be by getting stack-bin from the AUR, but just getting the bin and putting in in ~/.local/bin is the most direct method by far
14:35:35 <maerwald> clmg: stack handles updating itself
14:35:48 <clmg> ah ok
14:36:04 <maerwald> then you'll come back and ask why it didn't work and then we have to solve PATH issues again
14:36:14 <Squarism> dsal, The "GDeliver" instance works well if I instruct the result to be a fully applied paramterized type. But If I I try to say it produces "Step b" as in the recursiveDeliver function i get the compile error at the bottom:    https://paste.ofcode.org/6hQCnXKNmVNGkWE32D7Dhx
14:36:21 <yushyin> maerwald is a fan of those
14:36:25 <maerwald> lol
14:36:33 * maerwald shoots himself
14:36:57 <yushyin> nooo we need you, or rather the mac users need you!
14:37:58 <MarcelineVQ> clmg: with that in mind don't forget to add ~/.local/bin to your PATH if that's where you put stack. By default that's where it places its upgraded self so that's the best spot
14:40:04 <clmg> Will stack install ghc into my home directory by default? I don't want it in root.
14:40:42 <maerwald> sure, it will download as many GHCs at it wants
14:41:09 <MarcelineVQ> it places what it needs in ~/.stack/
16:35:49 * hackage oplang 0.1.0.0 - Compiler for OpLang, an esoteric programming language  https://hackage.haskell.org/package/oplang-0.1.0.0 (aionescu)
17:19:48 <c_wraith> huh.  I'm looking at some core because I wanted to verify that ghc would evaluate a (,,) constructor strictly even though it's not actually forced, because it's used immediately in a recursive call that pattern-matches on it...
17:20:03 <c_wraith> Turns out GHC just plain removed the tuple entirely.
17:20:29 <c_wraith> It just unpacked it into three arguments instead of one.
17:21:15 <dolio> Yeah, it does that sort of thing.
18:38:20 * hackage flat-mcmc 1.5.2 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.5.2 (JaredTobin)
18:51:30 <Tario> greetings
18:53:53 <Tario> QQ: if I have a JSON that's has the following body:
18:53:53 <Tario> {
18:53:53 <Tario>  "a": "blabla",
18:53:54 <Tario>  "b" : 24
18:53:54 <Tario> }
18:53:54 <Tario> How can I obtain with aeson the value from the key "a" as a Text, in the simplest way possible?
19:02:11 <lemmih> Tario: T.take 6 . T.drop 8 :)
19:04:20 <int-e> lemmih: I'm pretty sure that 8 would be too small :P
19:04:45 <int-e> (I counted 9, maybe 10 with cr/lf newlines)
19:06:51 <lemmih> Hm, right. The JSON is therefore broken. Gotta delete a space or newline.
19:08:18 <lemmih> Tario: If you don't want to fix the JSON then you can use 'aeson' instead.
19:08:56 <Tario> oh
19:10:49 * hackage project-m36 0.8.1 - Relational Algebra Engine  https://hackage.haskell.org/package/project-m36-0.8.1 (agentm)
19:12:43 <c_wraith> This is one of those awkward things, where lens-aeson makes the task look like a super-tiny bit of code...  But if you have problems, you suddenly need to understand lens.
19:15:51 <Tario> yes, I've tried using aeson, but still I'm too novice to comprehend it, but I'm still trying.
19:15:51 <Tario> Like when presented with a JSON like
19:15:51 <Tario> { "name": "John", "age" : 54}
19:15:51 <Tario> I would like to obtain the Text value from the "name" key. I tried to do
19:15:52 <Tario> let name = myJson .: "name"
19:15:52 <Tario> Or 
19:15:53 <Tario> HashMap.lookup "name" myJson
19:15:54 <Tario> but that doesn't work
19:16:45 <Tario> (I'm really new to Haskell, and it's been a learning experience. It's a really interesting language)
19:28:01 <lemmih> Tario: The simplest way might be: parseMaybe (.: "name") =<< decode your_input :: Maybe Text
19:29:46 <ski> Rembane : Standford course ?
19:30:28 <ski> dolio : "GHCs capability to both inline or let-float, is that not using the symmetric proprety of equality?","mmm.. no I guess not","Well, but transitivity is assumed by the fact that the simplifier could repeatedly inline, and it's valid because equivalence is transitive." -- that's about `=', not about `=='
19:36:15 <Tario> lemmih: That would return a Nothing in case of being invalid or Just "John", in this case, correct?
19:36:33 <lemmih> Tario: Yeah, I think so.
19:36:53 <Tario> I think that works, I'm going to give it a try in a bit in my tiny personal project
19:37:07 <Tario> Thank you!
19:38:14 <Tario> I'm going to give it a try shortly, Thank you, lemmih!
20:10:42 <dsal> Tario: The simplest way is probably just to make a type that has the matching fields and let Aeson populate a value for you.  The easiest way is probably lens-aeson.
20:11:55 <Tario> dsal: ok, that I think I can do
20:12:27 <dsal> λ> "{ \"name\": \"John\", \"age\" : 54}" ^? key "name" . _String    ->   Just "John"
20:12:47 <Tario> I'll explain with more detail in my other device (who's also connected to the channel, but by the name of Kiraaa) 
20:12:56 <Kiraaaa> ok im here
20:13:03 <dsal> Hey, we were just talking about you.
20:13:26 <Kiraaaa> really?
20:15:42 <Kiraaaa> for a tiny login, POST endpoint, I was thinking of creating a data type like this,
20:15:46 <Kiraaaa> data LoginData = LoginData {
20:15:48 <Kiraaaa>     email :: Text
20:15:50 <Kiraaaa>   , password :: Text
20:15:52 <dolio> ski: I think you tagged the wrong person.
20:15:52 <Kiraaaa> }
20:16:20 <ski> oh
20:16:23 <ski> so i did, sorry
20:16:39 <ski> dminuoso ^
20:16:42 <Kiraaaa> with the following instances:
20:16:45 <Kiraaaa> instance FromJSON LoginData
20:16:46 * ski 's a bit sleepy ..
20:16:46 <Kiraaaa> instance ToJSON LoginData
20:17:25 <Kiraaaa> so inside my POST handler, I wanted to perform the following: 
20:17:35 <Kiraaaa> my login POST handler*
20:19:04 <Kiraaaa> pass a Handler Value, obtain the inputted json body with requirecheckjsonbody :: Handler LoginData (not sure if this was the right choice)
20:19:30 <Kiraaaa> sort of like this:
20:19:32 <Kiraaaa> postUserLoginR :: Handler Value
20:19:33 <Kiraaaa> postUserLoginR = do
20:19:35 <Kiraaaa>   newLogin <- requireCheckJsonBody :: Handler Value
20:19:47 <Kiraaaa> (ignore the last Handler Value, it should be Handler LoginData in my mind)
20:19:52 <dsal> You can use a pastebin if you have a bunch of stuff you want to share without flooding out the whole channel.
20:20:03 <Kiraaaa> oh 
20:20:17 <Kiraaaa> will do, it will be better
20:22:24 <Kiraaaa> https://pastebin.com/gVwZiH2Z
20:23:36 <Kiraaaa> so this was my attempt at getting the json body from a POST request for a simple login, for now I wanted to obtain the email from the object, and perform a query to obtain an user binded to that email address
20:25:46 <Kiraaaa> leading up to this: https://pastebin.com/CBrSPXPT
20:29:01 <Kiraaaa> however, that did not work
20:30:41 <Kiraaaa> (due to type errors between Value and HashMap Text Value)
20:40:13 <Kiraaaa> this is where I got stuck, thinking on how to parse that value from the JSON (or any value from its key)
21:05:08 <Kiraaaa> *back to Tario (other device)
21:05:19 <Tario> back
