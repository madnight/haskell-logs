00:05:55 <lemmih> Tario: It would be easier to help you if you pasted the error together with the code.
00:07:42 <lemmih> Tario: You're doing something which should just work. If it doesn't then you've made a typo or a type error somewhere. But we can't help you if don't show us what is wrong.
00:21:19 * hackage commander-cli 0.10.1.2 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.10.1.2 (sgschlesinger)
03:25:04 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
03:25:04 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
03:25:04 --- names: list (clog avdb kori fendor polyrain_ Zao_ nursen GyroW falafel RusAlex raehik rembo10 albert_91 emmanuel` z0k jedii snakemas1 berberman chaosmasttter m0rphism gehmehgeh ralejs danvet_ fraktor Tuplanolla taurux xerox_ takuan p3n DirefulSalt nyd xff0x wz1000 DataComputist aaaaaa Benett idnar m-renaud Tritlo andi- karolus wraithm DTZUZU albethere dmj` drbrule tiru SrPx robotmay alehander92_ banjiewen_ liquorice scav benwr____ pent ullbeking edmundnoble gambpang_)
03:25:04 --- names: list (ajmcmiddlin atomi tdammers_ no-n buggymcbugfix bitonic sis7_ cemerick ^[_ PatrickRobotham_ J_Arcane eruditass ocharles JSharp ishutin rednaZ[m] stree_ day carlomagno gxt tabemann mrchampion yahb lemmih theDon nshepperd nshepperd2 lagothrix elliott_ inkbottle Chi1thangoo L29Ah Khisanth whataday Ranhir olligobber reallymemorable p8m nineonin_ Rudd0 renzhi _ashbreeze_ OscarZ drewolson Tario bitmapper fresheyeball Codaraxis_ Alleria_ sm[m] cheater niko dqd otulp)
03:25:04 --- names: list (thecoffemaker teqwve nullheroes lep-delete alx741 bliminse hekkaidekapus sw1nn xsperry gabiruh qz urdh oldsk00l_ jb55 is_null proteusguy shutdown_-h_now TMA quazimodo questionmarkking ridcully cyphase koz_ Cthalupa pjb Kaiepi perrier-jouet Axman6 MarcelineVQ Katarushisu Forkk zaquest hyiltiz pfurla alexelcu ziman cpape brisbin darjeeling_ whiteline jrqc ChaiTRex verement jjhoo CitizenSnips justache rihards_ tomboy64 marek M2tias nopf coeus pong joshmeredith)
03:25:04 --- names: list (ezzieyguywuf arahael CindyLinz jkaye[m] hsiktas[m] michaelpj nihilazo kadoban jiribenes1 martin02 remexre dsal taktoa[c] ixian dyniec[m] betrion[m] tttom[m] mikr[m] mmynsted[m]1 gmind[m] Noughtmare[m] albestro[m] CaptainFox[m] sepp2k steve[m] GuillaumeChrel[m jlv alexfmpe ciderpunx[m] materialfuture[m psydruid domenkozar[m] srid lnxw37d4 theduke fgaz pqwy[m] siraben maralorn JoelMcCracken[m] PotatoHatsue themsay[m] ethercrow[m] Fernando-Basso[m unclechu)
03:25:04 --- names: list (johnnyboy[m] sureyeaah io_r_us[m] iinuwa Ericson2314 drozdziak1 chreekat[m] alvinsj[m] lambdaclan jeffcasavant[m] ThaEwat bonvoyage[m] SlackIntegration hnOsmium0001[m] jtojnar mmynsted[m] lightandlight tsrt^ gienah sagax acowley poljar fr33domlover natechan ericsagnes hololeap tmciver evanjs quinn Benzi-Junior revprez_anzio balbirs int-e Unhammer quicksilver __skn haasn andreas303 Habib NinjaTrappeur1 nemesit|znc anoe clever polux2001 jle` systemfault)
03:25:04 --- names: list (ProofTechnique jonrh uwap @Sigyn cheers Raito_Bezarius Nascha liff zincy__ SupaYoshi wallacer3 ent sudden saurik Papa juri_ cjh` aidecoe Entroacceptor ft patrick1 freeside WzC le_jonge grfn mrus coddinkn datajerk c-rog tomsmeding lassulus monochrom nisstyre Clint atraii feepo blissful noctux dorkside Bergle_3 jluttine thunderrd jokester yorick ryjm ryjm_matrix dolio jinblack bgamari Boarders alexknvl ski mupf xelxebar drupol Graypup_ fredcy deu lyxia glamas)
03:25:04 --- names: list (iteratee tomku steve__ steve_ ech a3f zariuq cp- pacak Vq kav mrbentarikau theorbtwo nckx auri_ ArsenArsen aurieeeh Takumo minne PragCypher pta2002 gekh hyiltiz-M dixie Velpoman opqdonut noteness bcoppens barrucadu miklcct dequbed thonkpod fl0_id dcoutts seanparsons parisienne topos joeyh_ nick_h verlet64_ angerman noCheese recon_- _flow_ liszt_ tchar adius conjunctive elvishjerricco carter ghuntley lexi-lambda mudri pasukon rodlogic__ rawles sphalerite amiri)
03:25:04 --- names: list (SolarAquarion entropygain pierrot graingert Cerise darthThorik aizen_s johs metadave rslima_____ FMJz____ pepeiborra eyenx connrs thaumavorio zopsi Xnuk operand Firedancer thi cvlad- Cir0X koankeeper brown121407 carldd10 aplainzetakind haritz jwynn6 vk3wtf Lowl3v3l tromp dminuoso tv- atk AndreasK noan alanz shadowdao Niamkik vqrs raoulb crtschin mystfox megaTherion lucas8 xarian_ fiadliel jlpeters incognito9999_ devalot jiribenes cohn tessier klardotsh ambiso)
03:25:04 --- names: list (ekleog_ hive-mind michalrus brettgilio bollu Cale chrpape jchia MindlessDrone luigy i7c ibloom mflux mantovani acertain copypasteque_ lukelau_ mcfilib_ NemesisD teehemkay_ bwe_ gentauro Flonk wowi42 hiptobecubic madnight iphy heyj betawaffle chessai d0liver sdx23 vnz reda loc sarahzrf quaestor fiQ2 Foritus jtcs_ Hijiri_ aldum rotaerk caasih jetpack_joe typetetris mpickering kyagrd__ glowcoil simony nlofaro eacameron hamishmack jvsg entel rizary PoliticsII_____)
03:25:04 --- names: list (jared-w xyggos alunduil Kamuela lortabac Wamanuz DigitalKiwi xwvvvvwx digia wei jackdk NieDzejkob tanuki clynamen rkrishnan rzmt magog Taneb xts filwisher rann mud Igloo bobbytables edwtjo Tristan- mnrmnaugh Orbstheorem tinga xlei troydm mac10688 ghoulguy nkly Patternmaster outerpassage mstruebing ptrcmd cow-orker bob_twinkles sveit pdxleif kkd puffnfresh Jonno_FTW beka mmaruseacph2 Klumben Logio Tspoon amosbird dftxbs3e russruss8 PotatoGim Shun131 kozowu jbetz)
03:25:04 --- names: list (cstrahan rotty gluegadget jhuizy Majiir noexcept Rembane obfusk werneta lambdabot affinespaces dsturnbull sgraf runeks newhoggy integral Adeon wildsebastian ReinH__ srhb adamse tnks higherorder aristid edwardk benl23 hazard-pointer chpatrick enemeth79 rdivyanshu nh2 gaze__ mankyKitty dgpratt sclv parseval bjs kip gregberns_ yogani meck elcaro BIG_JIMMY_D puffnfresh_ davetapley amatecha__ lally bradparker totbwf ebutleriv wpcarro cbarrett natim87 moobar)
03:25:04 --- names: list (billstclair stylewarning dddddd dexterlb dredozubov davve robogoat jlamothe twk- TheScoop nek0 Unode dagnabbit concept2 lemald spoonm xacktm styledash centril `slikts dmiles andyo rom1504 morbeus fii heredoc_ Putonlalla nh beaky m4lvin cocreature debugloop Jon byorgey jamestmartin arkeet` dysfigured Randy noecho micro strangeglyph nerdypepper AWizzArd xintron dxld interruptinuse bspar dale Nik05 hc maerwald Inoperable eedgit2 wagle ichimaru dani- agander_m)
03:25:04 --- names: list (kristjansson lisq sqrt2 Moyst Cathy phaazon a3Dman farn__ Faye DustyDingo jdt suppi Tene ByronJohnson echoreply hiredman mursu mingc ManiacTwister nikola2 idupree2 tolt ashnur Ferdiran1 milessabin dwts ircbrowse_tom gawen rkvist relrod blackdog swater dave_uy averell terrorjack hvr arianvp drdo Maxdamantus tylerjl leah2 lockshaw stiell jzl dmwit Eduard_Munteanu towel eldritch incertia immae ViCi {abby} SquidDev MasseR esg veverak amf niklasb_ delobuch spamlessj)
03:25:04 --- names: list (komasa Adluc saidinwot1 johnstein aib HoolaBoola atle infinisil LittleFox duairc orzo pharaun APic valdyn irclogger_com comboy seliopou Deewiant feuerbach_ mort arw mimi_vx myme electricityZZZZ cgfbee thebnq bcmiller adaj ornxka ring0` stvc jmsx drewr Madars tumdedum exarkun cods joehillen orcus- jrm voidcontext sdrodge landonf Spooktober hpc daenth connrs_ nitrix zgrep sajith gareth__ duckonomy rednaZ2 e2 hongminhee marble_visions jakalx tms_ lkurusa sm sud0)
03:25:04 --- names: list (PyroLagus krjst yushyin ggVGc jophish Bigcheese s4msung noctuks zzz nurupo Kneiva efertone bendo pounce enikar wayne kini asm89 tasuki sea-gull infty Guest2620 cjay mikolaj_ mniip lowryder bjobjo stux|RC-only bonz060 jassob canta adamCS shapr NGravity Guest60204 sshine dustinm- tv dpl greymalkin tstat avn Nikotiini ps-auxw Jajik yumh vimto1 Eliel reyu djanatyn deni oleks pie_ anderson electrocat w1gz piele Zemyla hwabyong_ gilbertw1_ msgctl malthe)
03:25:04 --- names: list (haskell_enthusia statusbot cyberlard Squarism samebchase add^_ dh quintasan Dykam Jello_Raptor raoul shachaf hyperfekt srk Firedancer_ kqr xsarnik0 Arguggi eagleflo PlasmaStar jtobin Athas RoguePointer stefan-_ PHO_ obiwahn sujeet LambdaDuck chindy ben_m zymurgy zyeri epta raid EvanR bandali Someguy123 dumptruckman infinity0 TimWolla haveo janne madog m1dnight_ mr_yogurt Ekho mceier jackhill esotericalgo lieven supki gargawel heath cynick jvanbure fiddlerwoaroof)
03:25:04 --- names: list (jkarni exferenceBot mikolaj Sparadox uberj phadej xe4 tureba joeytwiddle lpsmith davl esph kloeri jfredett_ lnx ahf Drezil oats electrostat energizer tristanC suzu_ ego dexterfoo @ChanServ rdivacky sim590 sayak1 Geekingfrog peutri kaol agrim koala_man so hackage Techcable tinwood c_wraith catern kosmikus Blkt Chousuke Ankhers vodkaInferno carbolymer newsham ammar2 gothos [df] turq divVerent nf rodgzilla statusfailed vancz jorj tomjaguarpaw xnyhps xcin solarus)
03:25:04 --- names: list (rprosper- dilinger andjjj23 grol vjoki hexagoxel SegFaultAX t36s_ acro magicman bind jol TommyC geal deadk fre iomonad Chobbes chirpsalot tensorpudding avp runawayfive earthy daGrevis zfnmxt Philonous nyaomi dibblego bsima forell Reiser HiRE_ riatre benschza Uniaika Cheery mawk abuss davean nekomune hodapp codedmart simplegauss kjak Tourist reactormonk samebchase- absence kipras`away [exa] jameekim1 mp___313 sim642 MagBo)
03:27:49 * hackage inline-c 0.9.1.3 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.9.1.3 (FrancescoMazzoli)
03:55:49 * hackage path-dhall-instance 0.2.1.0 - ToDhall and FromDhall instances for Path.  https://hackage.haskell.org/package/path-dhall-instance-0.2.1.0 (locallycompact)
04:18:49 * hackage heterocephalus 1.0.5.4 - A type-safe template engine for working with front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.5.4 (arowM)
05:47:49 * hackage unliftio-path 0.0.1.0 - UnliftIO using well-typed Paths.  https://hackage.haskell.org/package/unliftio-path-0.0.1.0 (locallycompact)
06:14:20 * hackage unliftio-path 0.0.2.0 - UnliftIO using well-typed Paths.  https://hackage.haskell.org/package/unliftio-path-0.0.2.0 (locallycompact)
06:15:50 * hackage aeson-combinators 0.0.3.0 - Aeson combinators for dead simple JSON decoding  https://hackage.haskell.org/package/aeson-combinators-0.0.3.0 (MarekFajkus)
07:15:53 <dwts> quick question to all of you lambda wizards. Supposing we have this expression: (λx.x)(λy.y)z , are (λy.y) and z two arguments that λx accepts or is it that λx accepts one argument, λy which itself accepts another argument z ?
07:16:54 <hpc> (λx.x) takes (λy.y), then the /result/ of that is what takes z
07:17:04 <dwts> ok
07:17:14 <dwts> so both x and y lambdas accept one argument
07:25:04 <ski> yes
07:26:54 <merijn> *all* lambdas accept only one argument
07:27:23 <merijn> We just sometimes use syntactic short hand where we skip the boilerplate and write "as if" they took multiple
07:28:19 <dwts> yeah, the book made that clear in the first pages that all lambdas accept only one argument, but the way it's written confused me to think that it accepts two
07:34:10 <tomjaguarpaw> Hmm, careful. The correct parenthesisation is ((λx.x)(λy.y))z.  As I understood it your question was about that.
07:35:56 <dwts> tomjaguarpaw: hmm okay
07:36:03 <dwts> yeah, my question was about that
07:36:20 <dwts> trying to figure out how to "read" this expressions properly
07:37:24 <merijn> Everything's left associative, so as tomjaguarpaw says "\y.y" is passed to "\x.x" and "z" is passed to the result of that
07:38:13 <dwts> yup, that makes sense now, the confusion comes from slightly more "complex" expressions but I'll get there I guess :)
08:11:19 * hackage arch-hs 0.3.0.0 - Distribute hackage packages to archlinux  https://hackage.haskell.org/package/arch-hs-0.3.0.0 (berberman)
08:24:14 <Tario> lemmih: yes, I'll post the error I'm receiving from GHC
09:25:13 <dminuoso> What's the relationship between sum types and existentials? It occured to me that there's a similar theme going on. That is, some `f :: T -> ∃x. x` and `g :: T -> G :+: H` behave somewhat similarly, and consuming them requires being able to handle "all possible values"
09:25:43 <dminuoso> (Except that with existentials, they seem to behave more like open sum types)
09:27:05 <dminuoso> And equivalently, some `h :: G :+: H -> T` seems similar to `i :: ∀x. x -> T`
09:28:23 <dminuoso> Of course, it makes more sense to probably constrain the existential/universal quantification, so say `f :: T -> ∃x. C x *> x` and `i :: ∀x. C x => x -> T`
09:29:50 * hackage hwk 0.3 - Simple Haskell-based awk-like tool  https://hackage.haskell.org/package/hwk-0.3 (JensPetersen)
09:33:49 * hackage pandoc 2.11 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.11 (JohnMacFarlane)
09:42:28 <ski> dminuoso : roughly, sums and existentials are "positive", products, exponentials, and universals are "negative"
09:43:11 <ski> (btw, did you see what i responded, earlier ?)
09:44:29 <dminuoso> ski: No I did not
09:44:56 <ski> "GHCs capability to both inline or let-float, is that not using the symmetric proprety of equality?","mmm.. no I guess not","Well, but transitivity is assumed by the fact that the simplifier could repeatedly inline, and it's valid because equivalence is transitive." -- that's about `=', not about `=='
09:45:17 <dminuoso> 12:15:58         dminuoso | ski: I guess its two fold since Haskell implementations to assume reflexivity and transitivity of (=) at least.
09:45:28 <dminuoso> I assumed it was clear from that previous line that I was referring to (=).
09:45:39 <ski> yes, it was
09:48:20 <ski> (but what i was talking about, before, was Haskell implementations (as opposed to libraries) not relying on having the laws hold for `==' (as opposed to for `='))
09:50:26 <ski> (i guess maybe we were talking past each other, a bit, at the end ? i was still on the distinction between `==' and `=', and how, if you treat them as talking about the same notion of equality, you have to do something more, when simulating quotient types as abstract data types, like Mercury does)
09:51:20 <ski> anyway, sums and existentials are "lower adjoints", while products, exponentials, and universals are "upper adjoints"
10:11:19 * hackage type-fun 0.1.2 - Collection of widely reimplemented type families  https://hackage.haskell.org/package/type-fun-0.1.2 (AlekseyUymanov)
10:16:19 <dminuoso> ski: lower/upper adjoints of what?
10:16:25 <dminuoso> Or did you mean left/right?
10:18:24 <dminuoso> Well the thing is, I dont quite draw a comparison between `sum` and `product` here, since it's rather that `sum in negative position/sum in positive position` seems to line up with `existential in positive position/univeral in negative position` 
10:18:59 <dminuoso> Which I found odd, since if I have an existential producer, I need a universal consumer to eliminate it
10:19:25 <dminuoso> But to eliminate a sum, it's sufficient to have a function that consumes a sum
10:20:04 <dminuoso> Though, what Im saying is a bit handwaving and incorrect, since the universal quantification is bracketed differently than I imagine
10:20:56 <dminuoso> To consume some `s :: ∃x. C x *> x` I need some `f :: forall x. C x => x -> ...`, and not `g :: (forall x. C x => x) -> ...`
10:21:40 <dminuoso> The thing that's just buzzing around my head is, when you produce a value of a sum type, it acts as a sort of existential since from outside the choice of which type was used is hidden
10:21:57 <dminuoso> And equivalently, when you consume a sum type, you have to pattern match on all cases, that is you have to be able to handle *all* possible values
10:22:28 <dminuoso> So a function `f :: (S + T + U) -> V` must be able to handle all choices `S`, `T` and `U`
10:22:50 <dminuoso> While a function/producer `g :: ... -> (S + T + U)` hides which choice it made
10:22:55 <dminuoso> ski: Am I making any sense here?
10:24:01 <dminuoso> It was in this sense, that I was thinking an existential could be an open sum type.
10:25:43 <dminuoso> Because, a function `f' :: (∃x. C x *> x) -> V` must be able to handle all possible type choices made for `x` (constrained by C, so this is a sort of open sum type of all types belonging to C)
10:26:18 <dminuoso> And equivalently, a function/producer `g :: ... -> (∃x. C x *> x)` would tell you "I chose some type of C, but I wont tell you which"
10:26:56 <dminuoso> And its open in the sense that you can just write an `instance C T` anywhere, so you can just add to it
10:27:40 <ski> `f :: (exists x. C x *> F x) -> V' is equivalent to `f :: forall x. C x => (F x -> V)', yes
10:28:01 <ski> i don't follow "`sum in negative position/sum in positive position` seems to line up with `existential in positive position/univeral in negative position`"
10:28:27 <ski> "But to eliminate a sum, it's sufficient to have a function that consumes a sum" -- this is a truism
10:29:01 <ski> what's `(S + T + U) -> V' equivalent to ?
10:29:23 <ski> "lower/upper adjoints of what?","Or did you mean left/right?" -- yes (but i don't like that terminology)
10:31:28 <dminuoso> ski: https://gist.github.com/dminuoso/6d3ad7972fbe6a00e1a7c9fffcc64c77
10:32:15 <dminuoso> Im using existentials instead of forall, because it's easier in my head here.
10:32:53 <ski> what do you want to say about these two pairs of functions ?
10:34:28 <dminuoso> f and f' behave similarly, if they want to consume their argument, they need to provide an implementation that handles *all* possible choices a caller makes.
10:34:44 <ski> yes
10:34:55 <dminuoso> And the sum type seems like an existential in that sense
10:35:11 <dminuoso> Except the types it ranges over is finite
10:35:39 <dminuoso> Since it can always be only S, T or U. In case of the existential in f it could be any member of C.
10:35:47 <dminuoso> Or, if unconstrained, literally any type.
10:37:44 <dminuoso> 19:34:33         dminuoso | And the sum type seems like an existential in that sense
10:37:47 <dminuoso> Is this an accurate assessment?
10:40:22 <monochrom> dminuoso: This is similar to my http://www.vex.net/~trebla/weblog/any-all-some.html
10:40:32 <monochrom> especially "2. Any" and "3. Every"
10:47:19 <ski> dminuoso : ⌜(∃ x. C x ∗› F x) → V⌝ is "trivial" in the sense that it can already be expressed as (the in some sense simpler) ⌜∀ x. C x ⇒ (F x → V)⌝. ditto for ⌜(S + T + U) → V⌝ as ⌜(S → V) × (T → V) × (U → V)⌝. otoh ⌜V → (S + T + U)⌝ and ⌜V → (∃ x. C x ∗› F x)⌝ are "serious / nontrivial"
10:47:35 <ski> (the first two equivalences are the adjunctions, of course)
10:48:18 <ski> "And the sum type seems like an existential in that sense" -- the sum type has similarities to the existential here, yes
10:48:43 <koz_> monochrom: That's a really good writeup.
10:49:42 <ski> @quote monochrom is.my
10:49:42 <lambdabot> monochrom says: Programming is a dialectic class struggle between the author and the user.  My freedom is your slavery. Your ignorance is my strength.
10:50:02 <monochrom> :)
10:55:02 <dolio> dminuoso: Either is a 2-ary sum, exists is a *-ary sum (sort of).
10:55:08 <ski> "If ⌜p⌝ is any prime, then for every integer ⌜a⌝, ⌜aᵖ⌝ is congruent to ⌜a⌝, modulo ⌜p⌝."
10:56:00 <xerox_> so squaring doesn't change parity (modulo-2-ness) cubing doesn't change module-3-ness and so forth
10:57:04 <ski>   (∃ p : ℕ. Prime p) → (∀ a : ℤ. aᵖ ≅ a (mod p))
10:57:05 <dolio> Really Σ is a sum, and ∃ is something more restrictive.
10:57:25 <dolio> But you don't have Σ in Haskell.
10:57:38 <ski> "and" corresponds to the existential here. note that this is an anaphoric use. (⌜p⌝ appears to be used, out of scope)
10:57:46 <dminuoso> dolio: You said "sort of", in what sense do they differ?
10:57:52 <dolio> In the same way that ∀ is different from Π.
10:58:04 <ski> er, .. s/and/any/
10:58:32 <dolio> dminuoso: ∃ is parametric, so it is supposed to 'hide' the choice of type.
10:59:56 <dolio> In e.g. Agda, you have Σ over types where the value is accessible, and then it's a strict generalization, where A + B = Σ b:Bool. if b then A else B.
11:02:36 <dolio> That's why it's Σ, or 'dependent sum' and not 'product' like people sometimes call it. :)
11:03:27 <ski> "dependent sum","dependent product" vs. "dependent product","dependent exponential"
11:03:38 <hpc> it's like how Σ in math is the sum of a function for x in some range
11:03:45 <dolio> The 'tags' of the sum are generalized to an arbitrary type, rather than an externally given set of constructor tags.
11:03:52 <ski> (i don't really see the point of the former terminology)
11:04:27 <phadej> calling Sigma dependent pair makes sense, dependent product is wrong.
11:04:40 <ski> why ?
11:04:54 <phadej> because Pi is product
11:05:22 <ski> it's an iterated/flexible product, yes
11:05:41 <ski> but the dependency is not "on the level of thinking of it as a product", the way i see it
11:05:45 <phadej> dependent pair and dependent function space are non-ambiguous names
11:06:02 <ski> the dependency is from the exponent to the base. so if i'm thinking about the dependency, i'm not thinking about it as a product
11:06:29 <phadej> I'd prefer names where I don't have to think which way they are ;)
11:06:46 <phadej> also sigma-type and pi-type are good
11:06:58 <phadej> jargon, but concise and non-ambiguous
11:07:15 <ski> (and similarly, "dependent sum" doesn't make sense. or rather, "dependent sum" ought to refer to ⌜(k : A) ∨ (⋯k⋯)⌝, where ⌜k⌝ is a continuation (a disproof/refutation) of type ⌜A⌝)
11:10:16 <dolio> Σ is a coproduct and Π is a product in a pretty straight forward way.
11:11:05 <ski> (if i'm thinking about the dependency in ⌜(x : A) ∧ (⋯x⋯)⌝, i'm clearly thinking about it as a product, with a dependency from one factor (the "multiplicand", if you wish) to the other (the "multiplier"). if i'm thinking of ⌜(i : {0,1,2}) ∧ Bᵢ⌝ as an iterated/flexible sum ⌜B₀ ∨ B₁ ∨ B₂⌝, then i'm not explicitly thinking about the dependency)
11:14:24 <ski> when i write ⌜∑ᵢ Bᵢ⌝/⌜∏ᵢ Bᵢ⌝, i'm commonly thinking of this as a(n iterated/flexible) sum/product. but if i'm talking/thinking about the dependency, i'm clearly thinking of this as a product / an exponential (coming from iterated sum/product)
11:15:20 * hackage cut-the-crap 2.1.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-2.1.0 (Jappie)
11:17:16 <koz_> ski: What's a dependent exponential?
11:17:26 <dolio> Well, in this case, 'sum' is the correct terminology to recognize the correspondence between Σ and +, so I don't see the value in insisting on the other terminology.
11:17:32 <koz_> Like, I know that 'exponential type = function', but I don't get how dependent types would go here.
11:17:36 <dolio> It is strictly worse for understanding this case.
11:20:58 <dolio> I generally call them Σ and Π.
11:21:32 <ski> (i sometimes write ⌜(i <) n ⋅ aᵢ⌝, and ⌜aᵢ⁽ⁱ˂⁾ⁿ⌝, for the usual arithmetic operations, to emphasize the dependent product/exponential viewpoint)
11:21:49 <hpc> koz_: perhaps something like printf's type, adding more parameters based on the format string
11:22:04 <koz_> hpc: Ah, OK.
11:22:23 <koz_> I didn't think of that, but it makes much sense.
11:22:27 <ski> yes, i should probably say that when i'm thinking of it as a "dependent product", i'm usually not writing it as ⌜∑⌝
11:23:02 <nihilazo> hi, I'm struggling to understand applicative functors. I understand the concept I think, but I don't see how they're useful?
11:23:02 <nihilazo> going through chapter 11 of learn you a haskell, I can't really see why this is useful vs just removing the stuff from the functors and using it as normal data
11:23:17 <nihilazo> aside from for doing stuff with lists, which I feel like comprehensions are cleaner for? Is it just a style choice to use them?
11:24:06 <koz_> nihilazo: Applicative functors are the thing that allows us to sequence computations.
11:24:20 <koz_> Functors alone cannot do this - they can only 'lift' pure functions to operate on effectful data.
11:24:25 <dolio> (Some) comprehensions can be turned into Applicative operations.
11:24:38 <koz_> Whereas Applicative actually allows us to compute inside of an effectful context.
11:25:04 <dolio> So by saying comprehensions are good, you are acknowledging that Applicative is good, just with a different syntax.
11:25:08 <c_wraith> nihilazo: have you run across the Traversable class?  It's one of those things that really points out why Applicative shines.
11:25:10 <koz_> For example: suppose you have x :: m Int, y :: m Int, where Applicative m. How do you add them?
11:25:18 <koz_> With Functor alone? You can't.
11:25:58 <koz_> But with Applicative, you can, and quite straightforwardly, while maintaining the effects that 'wrap' those values.
11:27:09 <nihilazo> ah ok, that makes sense
11:27:49 * hackage cut-the-crap 2.1.1 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-2.1.1 (Jappie)
11:27:59 <nihilazo> thanks
11:31:30 <nihilazo> Still not sure I entirely understand how applicatives are used in context, even though I think I understand the idea? I can always go back and revise if I come across things i don't understand
11:32:12 <ski> koz_ : ⌜Bₓ⁽ˣ ݃⁾ᴬ⌝ is equivalent to ⌜(x :) A → Bₓ⌝
11:32:40 <koz_> ski: Sorry, but I don't get that notation.
11:33:39 <ski> koz_ : example : ⌜replicate : (n :) ℕ → A → Aⁿ⌝
11:34:04 <koz_> Ah, OK.
11:35:23 <ski> (i don't mind calling ⌜Σ⌝. it's just that the adjective "dependent" here seems completely misplaced to me. there is no dependence of one term of the term, upon another term of the sum)
11:35:33 <ski> (don't mind calling it "sum", that is)
11:54:45 <ski> nihilazo : in that case, you could say `(+) <$> x <*> y', or `liftA2 (+) x y'
11:56:29 <nihilazo> ah ok
12:05:20 <avdb> Why is getting started with programming so hard? I've been procrastinating every minute I had the past month ...
12:06:44 <yushyin> because it's often so dull
12:08:19 <Uniaika> unless you have a compelling use-case, it's dull indeed
12:08:49 <dolio> Is it?
12:09:00 <nihilazo> I've decided on a project to do for my first thing in haskell but it's maybe not something haskell is suited to particularly
12:09:13 <nihilazo> because just learning is interesting but also kinda pointless if you then do nothing
12:09:41 <avdb> yushyin: What do you mean by dull?
12:13:03 <monochrom> It's a very vague question.
12:13:35 <avdb> It is, maybe I should just schedule an hour every day instead of being hopeless.
12:13:47 <monochrom> It also sounds like a counsellor is most suitable for this.
12:26:01 <maerwald> programming is for fellows with very hight frustration tolerance
12:26:48 <monochrom> In my case it's the opposite. Social interaction is the highly frustrating one.
12:27:30 <monochrom> People are moody. People have subtexts. People have secret rules. People expect me to second-guess them. People never say what they mean.
12:27:57 <monochrom> Programming has none of that, and I decided to have none of that.
12:28:26 <maerwald> which begs the question... why do we seek frustration?
12:28:49 <ptrcmd> your computer might become moody one day and decide to stop working xD
12:29:33 <monochrom> Then again, it was also a time when computers were simple, e.g., Apple II. Today's Windows look like moody and full of hidden rules, too.
12:29:34 <MarcelineVQ> ptrcmd: a lot of very smart people are working very hard to achieve just that
12:30:28 <monochrom> I imagine that programming is frustrating to social people because programming is against "do what I mean not what I said".
12:31:14 <monochrom> whereas programming is natural to me because it does what I said and I do what it said. What meaning?
12:31:58 <Zetagon> I can be pretty frustrated with computers not doing what I mean a times
12:33:17 <Zetagon> I had a computer lab where I was going to write some routing tables, and missed to type one dot in an ip address and the route program just swallowed it whole
12:33:23 <MarcelineVQ> semantic death approaches in the form of a great purple cloud, sparks within ignite the surface in brilliant flashes that draw in lowly insects, soon to be consumed and added to the cloud. Would you like to file a git issue about the cloud's color?
12:34:04 <monochrom> haha
12:34:08 * ski idly recalls programs which would only repond with `?', if they detected something they didn't understand, in user input
12:34:34 <MarcelineVQ> ski: I don't know anything about 'eat the apple'
12:36:04 <ski> like the `?' responses at <http://cs.wellesley.edu/~cs249/Resources/ed_is_the_standard_text_editor.html>
12:36:32 <ski> (although, in my case, it was a monitor/disassembler)
12:38:52 <maerwald> https://hackage.haskell.org/package/vty-5.31/docs/Graphics-Vty-Attributes.html#v:blink this doesn't do anything for me
12:40:30 <maerwald> I mean, not in an asthetics sense... but in a practical one
12:48:37 <maerwald> why no one invents a new terminal?
12:49:15 <Uniaika> maerwald: non-VT100 terminal?
13:06:56 <maerwald> a clean set of standards
13:07:59 <maerwald> should only take 3 lifetimes to convince everyone
13:22:09 <koz_> maerwald: 3? Optimistic aren't we?
13:22:19 <koz_> Also, anything on my xz thingo I tested for you?
13:22:37 <maerwald> xz?
13:22:40 <maerwald> ah
13:25:25 <hpc> is that what happens when you compose two XY problems? :D
13:26:38 <monochrom> or maybe compress two XY problems and get an xz file. :)
13:28:43 <hpc> imagine the trouble you have to be in to make a gz
13:45:20 * hackage longshot 0.1.0.3 - Fast Brute-force search using parallelism  https://hackage.haskell.org/package/longshot-0.1.0.3 (thyeem)
14:48:32 <jedii> java is so vile and same with .net
14:48:44 <jedii> why cant more companies adopt haskell or something decent
14:49:07 <Guest25> Can be made a nuclear fusion device from a lab on a chip?
14:52:23 <jedii> use thorium safe atomic
14:52:31 <jedii> liquid floride salt reactor flibe.com
14:52:37 <jedii> fusion doesnt work
14:53:02 <dolio> This doesn't seem like it's about Haskell.
14:59:17 <Guest25> Could be made a nuclear fusion device from a "lab on a chip" device?
14:59:25 --- mode: ChanServ set +o monochrom
14:59:28 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.78.75.21
14:59:28 --- kick: Guest25 was kicked by monochrom (Guest25)
14:59:32 --- mode: monochrom set -o monochrom
15:02:19 <maerwald> for the right amount of money, yes :)
15:02:29 <maerwald> here's my bank account...
15:02:42 <monochrom> They're gone.
15:03:50 * hackage pandoc-plot 1.0.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-1.0.0.0 (LaurentRDC)
15:11:45 <rom1504> "the right amount of money", like a few dozens of billions :) ?
15:17:00 <carter> lab fusion != net energy positive fusino
15:17:02 <carter> *fusion
15:17:32 <carter> theres some cool flavors where you could build it at home if you tolerated the eletrical bill and had enough materials to build stuff
15:18:37 <rom1504> ah really? is that used for anything useful?
15:19:10 <dminuoso> personal enjoyment
15:19:26 <dminuoso> I've read articles that some kids even did build fusion reactors at home with easy-to-obtain materials
15:19:41 <dminuoso> nuclear fusion is not hard
15:20:44 <dminuoso> sustained steady nuclear fusion with a Q > 1, that's an as-of-yet unsolved problem
15:21:09 <dolio> What's a lab on a chip, though?
15:22:54 <dolio> Sounds like a phrase from a Markov chain.
15:30:19 * hackage churros 0.1.0.0 - Churros: Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.0.0 (LyndonMaydwell)
15:56:49 * hackage hstar 0.1.0.5 - Haskell version of tar CLI utility  https://hackage.haskell.org/package/hstar-0.1.0.5 (vmchale)
16:28:50 <proofofme> which MySql driver do y'all recommend?
16:29:00 <koz_> mysql-haskell is pretty good in my experience.
16:29:31 <koz_> It's what I use at my Real Job For Real Money due to us having to interact with a MySQL database.
16:30:17 <proofofme> thanks, i will check it out
16:31:07 <proofofme> cabal: The following packages are likely to be broken by the reinstalls:
16:31:07 <proofofme> tls-1.5.4
16:31:08 <proofofme> http-client-tls-0.3.5.3
16:31:09 <proofofme> scalpel-0.6.2
16:31:11 <proofofme> http-conduit-2.3.7.3
16:31:13 <proofofme> connection-0.3.1
16:31:15 <proofofme> Use --force-reinstalls if you want to install anyway.
16:31:21 <koz_> proofofme: What version of cabal are you using?
16:31:22 <proofofme> would you trust --force-reinstalls?
16:31:24 <koz_> This shoudl be a non-issue.
16:31:46 <proofofme> cabal --version
16:31:46 <proofofme> cabal-install version 2.2.0.0
16:31:47 <proofofme> compiled using version 2.2.0.1 of the Cabal library 
16:31:51 <koz_> That is hilariously old.
16:31:59 <koz_> Current is 3.2, and we're heading to 3.4 soon.
16:32:03 <koz_> Upgrade first.
16:32:05 <Axman6> That's an error message I have not seen for a long time - I thought reinstalls were completely unnecessary with modern cabal?
16:32:24 <koz_> Axman6: Yes. Emphasis on 'with modern cabal' and *points to version above*.
16:32:33 <Axman6> newhoggy: If you haven't seen it, you might enjoy https://liuliu.me/eyes/loading-csv-file-at-the-speed-limit-of-the-nvme-storage/
16:52:19 * hackage churros 0.1.0.1 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.0.1 (LyndonMaydwell)
16:57:09 <proofofme> cabal install cabal-install, yeah?  I did this, checked the version and it's the same one still hmmm
16:57:27 <koz_> proofofme: What platform are you on?
16:57:30 <koz_> (as in, which OS?)
16:57:34 <proofofme> MacOS
16:57:38 <koz_> Use ghcup.
16:57:46 <koz_> To get a working toolchain.
16:57:48 <koz_> Always and forever.
16:58:10 <koz_> Since that'll not only do this for you, with sensible versions, it'll also show you what you have and when it becomes old.
17:02:24 <zoom8484> basic question regarding how the list type is able to construct a list value using syntax like [5]
17:02:33 <zoom8484> the list type is defined as: data [] a = [] | a : [a]
17:02:50 <Axman6> it's syntax sugar
17:02:52 <zoom8484> I've read that [5] is syntactic sugar for 5:[]
17:03:00 <koz_> Yeah, basically this.
17:03:15 <zoom8484> but is that sugar built into the compiler or is it derived the from list data definition
17:03:25 <monochrom> built into the compiler
17:03:26 <Axman6> it;s defined as part of the language
17:03:40 <Axman6> so a haskell compiler has to support it
17:03:51 <zoom8484> thanks. is it specific to only [], or is it available for my own types as well, of course using different symbols
17:04:07 <Axman6> sort of
17:04:21 <monochrom> Unavailable for your own types.
17:04:39 <Axman6> we have the OVerloadedLists extensions which lets you construct things using list syntax
17:04:55 <zoom8484> hmm, so even though the data type is really a library-defined type, there is hard-coded logic in the compiler to handle this specific case of it
17:05:14 <Axman6> so you can write [('a',True),('b',False)] :: Map Char Bool
17:05:22 <Axman6> yes
17:05:46 <zoom8484> ok, thanks. just wanted to make sure I wasn't missing some magic in the data declaration for the list type
17:05:53 <monochrom> Actually "data [] a = [] | a : [a]" cannot be library-defined either.
17:06:13 <zoom8484> it's defined in GHC.Types. Is that considered "built-in"
17:06:18 <Axman6> there is a lot of magic magic when it comes to making lists feel familliar
17:06:55 <Axman6> s/magic magic/magic/
17:07:48 <monochrom> I don't know what GHC.Types does, but you go through the Haskell grammar and there is no way "data [] a = [] | a : [a]" is correct syntax.
17:08:00 <zoom8484> i got that via :i [] in ghci
17:08:04 <monochrom> s/correct/legal/
17:08:54 <Axman6> zoom8484: youy're right to be confused - all of this is only legal because the standard says it is, and it's inconsistent with every other data type definition
17:09:07 <proofofme> `curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh`    <= I did this.  `cabal --version` says the same thing still :(
17:09:24 <Axman6> you can't make your own list by saying data <> a = <> | a :+ <a> for example
17:09:38 <Axman6> proofofme: how did you install cabal initially?
17:09:45 <monochrom> It's easy to check. "data Maybe a = Nothing | Just a", this is library-defined but even if the library didn't have it, you could have entered this yourself. In fact you can enter it right into ghci and it will be gladly accepted.
17:09:50 <ski> non-standard data constructor name `[]', non-standard type constructor name `[]', syntactic sugar for lists of definite length `[a,b,c,...y,z]', syntactic sugar for list types `[T]', list comprehensions `[E | x <- L,let {...},G]', `OverloadedLists' extension
17:09:57 <proofofme> I think homebrew maybe?  idr
17:10:09 <monochrom> Now try "data [] a = [] | a : [a]", that will be a syntax error left right and centre.
17:10:16 <Axman6> proofofme: well start by uninstalling it from homebrew
17:10:41 <Axman6> monochrom: I love the inconsistency of using both [] a and [a]
17:10:58 <monochrom> "[a]" is very intuitive.
17:11:05 <ski> "intuitive"
17:11:14 <monochrom> It's why I doubt everything intuitive. 90% probably of being wrong.
17:11:14 <koz_> proofofme: You have to then use ghcup to install cabal.
17:11:34 <Axman6> exept when people start writing f [a] = ... expecting a to represent all the a's (or something)
17:11:37 <monochrom> If it's intuitive it's BS. Change my mind.
17:11:49 * hackage churros 0.1.0.2 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.0.2 (LyndonMaydwell)
17:11:52 <ski> Axman6 : i wonder why people do that ..
17:12:00 <Axman6> yeah I see it a lot
17:12:04 <monochrom> For example every mixfix syntax!
17:12:14 <MarcelineVQ> at least it's not agda, where [a] is an identifier, like xs, and [ a ] is a list of a single a, like [x]
17:12:17 <ski> i guess people want to represent the type (or some aspect of it), in the identifier name
17:12:22 <ski> BASIC,Perl,..
17:12:34 <Axman6> when I was teaching firsty years it qwas very common for students to get stuck in "I'm using a list, therefore I MUST use square brackets"
17:12:41 <ski> (people even say `strlen()' when they mean `strlen' ..)
17:13:07 <ski> Axman6 : the faster they get out of that, the better, imho
17:13:24 <Axman6> indeed
17:13:27 <proofofme> https://gist.github.com/begriffs/6408415   would something like this work, and then rerun the ghcup command?
17:13:41 <ski> iirc, i saw some suggestion for allowing some syntax with square backets, as an alternative to `x : xs' .. not really a fan of that idea
17:13:56 <Axman6> I think we might have changed the course to use data List a = Nil | Cons a (List a) at least for a few weeks at the beginning
17:14:00 <ski> (Prolog,Erlang, and (iirc) Clean, does that)
17:14:47 <Axman6> proofofme: if you haven't done anything, that will probably be a decent start, but if you used homebrew you will also need to uninstall ghc and cabal from there too
17:14:49 <ski> MarcelineVQ : hah, yea ..
17:15:04 <Axman6> ski: yeah I always found that gross
17:15:15 <ski> MarcelineVQ : sometimes i name proofs of propositions, that way, in Agda, by removing the spaces
17:15:20 <Axman6> but syntax is hard. all we need is trees and opaque hashes
17:15:46 <MarcelineVQ> ski: ye
17:16:02 <MarcelineVQ> foo a b x>y =...
17:16:32 <ski> perhaps some notation for "the unique value in scope having this type" could be useful .. not sure
17:16:55 <MarcelineVQ> _ ?
17:17:18 <ski> it doesn't mean the same, in patterns
17:18:10 <dolio> I've been using identifiers like `[a]` in Agda lately. It was pretty convenient that they aren't lists.
17:18:15 <MarcelineVQ> not in pattern no but why would you you need that in patterns?
17:18:25 <dolio> Because I don't even need lists for what I was doing.
17:19:45 <ski> MarcelineVQ : to remind myself of the type of the particular pattern
17:20:45 <ski> (taking into context the refinements made by matching on data constructors)
17:23:47 <proofofme> tried that script ... still have the old cabal.  should i use `rm -r /usr/local/bin/cabal`?
17:31:08 <koz_> proofofme: Did you adjust your PATH as ghcup suggested?
17:31:52 <proofofme> no, I didn't ...
17:32:10 <koz_> proofofme: Then it's highly likely you're not seeing the newly-installed (higher-versioned) cabal.
17:36:53 <proofofme> yes!  success!  putStrLn "Thanks, koz_"
17:37:19 <koz_> proofofme: No worries. You can use 'ghcup list' to see what cabal it gave you, and which are available.
17:37:28 <koz_> You should now no longer see issues of the form you ran into.
17:40:04 <proofofme> could not resolve dependencies.  so Kafkaesque lol
17:40:25 <koz_> Exact error message (in a pastebin)?
17:42:52 <proofofme> https://pastebin.pl/view/d5fa52c0
17:43:46 <zoom8484> thanks guys!
17:44:21 <koz_> proofofme: Try re-running with --minimize-conflict-set?
17:45:15 <proofofme> https://pastebin.pl/view/9d998ecb
17:46:15 <koz_> Hmm, you can do one of two things: use GHC 8.6.5 or try with --allow-newer.
17:47:19 * hackage web-plugins 0.4.0 - dynamic plugin system for web applications  https://hackage.haskell.org/package/web-plugins-0.4.0 (JeremyShaw)
17:48:46 <proofofme> LICENSE: openBinaryFile: does not exist (No such file or directory).   <---from --allow-newer
17:49:01 <proofofme> wouldn't it be bad to go back to 8.6.5?
17:53:46 <koz_> proofofme: Why? I mean, is there a particular 8.8 feature you want?
17:53:58 <koz_> ghcup can give you multiple GHC versions quite trivially.
17:54:14 <koz_> And you can use 'cabal configure -w the.ghc.version.I.want' to set it up.
17:54:45 <koz_> That error is a bit weird though - could you give the exact error message?
17:55:06 <proofofme> that was the extent of it; it was only one line
17:55:18 <koz_> OK, could you pastebin your cabal file?
17:56:33 <proofofme> one sec
17:58:00 <proofofme> `cat ~/.cabal/config`? 
17:58:08 <koz_> No, the cabal file of your project.
17:58:27 <koz_> You shoudl have a whatever-you-named-your-project.cabal in your project folder.
17:58:38 <koz_> That is typically referred to as 'a cabal file'.
17:58:51 <proofofme> that was in the mysql haskell folder that I did this.  I was trying to install the db driver
17:59:08 <koz_> proofofme: mysql-haskell is a library.
17:59:14 <koz_> You don't _install_ it, you depend on it.
17:59:24 <proofofme> ah
18:00:10 <koz_> You only install executables.
18:07:34 <proofofme> what's the proper way to add a library, like Text.HTML.Scalpel, for example?
18:12:09 <lemmih> proofofme: First you find the name of the library that has that module.
18:12:43 <proofofme> https://hackage.haskell.org/package/scalpel
18:13:07 <lemmih> proofofme: Good. Add 'scalpel' to the list of 'build-depends' in your cabal file.
18:13:41 <proofofme> I don't have a cabal file in the project yet ... It's just an hs file for now
18:13:45 <proofofme> I can create one
18:14:06 <proofofme> `cabal init`
18:17:50 <proofofme> cabal init didn't create the file hmmm
18:20:23 <monochrom> "cabal init" creates a lot of files silently. You'll have to do an "ls" and explore around.
18:21:31 <lemmih> proofofme: You can also just do 'cabal v1-install scalpel'. That will make the library globally available.
18:27:26 <proofofme> it's installing successfully so far :)
18:28:25 <cohn> I'm playing around with the Text.CSV module. Hopefully this is an easy one: how can I get the "head" of the CSV data (the column names)?
18:28:37 <cohn> when I do this: dat <- parseCSVFromFile "foo.csv"
18:28:50 <cohn> the result has this type:  dat :: Either parsec-3.1.14.0:Text.Parsec.Error.ParseError CSV
18:29:17 <cohn> so it's wrapped in an "Either"... just need to get the Right value.
18:31:45 <proofofme> pattern matching and `case` is my best guess.  I'm pretty novice though ... 
18:32:55 <proofofme> https://stackoverflow.com/questions/46944347/how-to-get-value-from-either  Does this help?
18:33:27 <cohn> yep, thanks proofofme!
18:35:12 <proofofme> apparently, you can use `fromRight` as well, but that can come with some issues, if not accounted for.  I used `fromJust` to unwrap a Maybe from an IO monad to get to the [String] beneath yesterday.  Took some time to figure it out lol
18:38:39 <ski> proofofme : probably better to handle the error case explicitly .. unless maybe if you're really sure it can't happen
18:39:23 <ski> (but even then, it can be better to have an explicit pattern-match, rather than `fromJust',`fromRight',`head',`tail', since with those, you don't get a location if things go south)
18:39:41 <cohn> crikey... not woring
18:39:43 <proofofme> so you would use `case` and pattern matching for that just by default, yeah?
18:39:45 <cohn> *working
18:40:45 <proofofme> cohn, let me see if I can get the same thing working on my end
18:41:36 <ski> proofofme : you could use `Right x = ...' in a `let' or where. or apply `\(Right x) -> x' to the result
18:41:55 <cohn> for the curious:  https://pastebin.com/MYixX2vp
18:44:08 <cohn> this is what frustrates me about Haskell. It's easy to pick up the basics of the language but when it comes time to use library modules, it's a PITA.
18:44:36 <proofofme> what is `dat`?
18:44:44 <lemmih> cohn: Your problem is with static typing, though, not libraries.
18:44:50 * hackage churros 0.1.0.3 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.0.3 (LyndonMaydwell)
18:45:26 <lemmih> cohn: What's the type of your expression?
18:45:40 <cohn> proofofme: it's the result of reading the CSV file
18:45:47 <cohn> https://hackage.haskell.org/package/csv-0.1.2/docs/Text-CSV.html
18:45:48 <proofofme> ah
18:45:59 <cohn> lemmih: I would agree
18:46:05 <ski> cohn : probably `head d' doesn't have type `String'
18:46:46 <lemmih> cohn: Static typing is not optional in Haskell. You just gotta bite the bullet and always keep types in mind.
18:47:01 <jchia> Why is there a head fold but no 'tail' in Control.Foldl? Is a tail old that hard to define properly?
18:47:07 <ski> cohn : do you know what you want to happen/do, in the error case ?
18:47:21 <cohn> so, `dat <- parseCSVFromFile "foo.csv"`
18:47:36 <cohn> ski: just print an error message.
18:47:42 <ski> what is `CSV' ?
18:47:48 <ski> a type synonym ?
18:48:01 <cohn> yes
18:48:07 <ski> cohn : and abort the program, or not ?
18:48:10 <lemmih> type CSV = [[String]]
18:48:13 <ski> ok
18:48:37 <cohn> ski: I'm playing around in GHCi, so no need to exit.  : )
18:49:18 <ski> cohn : yes, but i'm asking you what you want your program to do, when there's a parse error
18:49:31 <cohn> just print an error message
18:49:33 <ski> should it continue processing, somehow ?
18:49:35 <ski> or just stop ?
18:49:46 <cohn> yes, just stop and print an error message
18:50:01 <ski> then call `error' in the `Left' parameter case for `either'
18:50:24 <ski> (that will also fix this type mismatch error)
18:50:58 <cohn> whoa! that worked! thanks, ski!
18:51:05 <ski> because
18:51:08 <ski> @type error
18:51:10 <lambdabot> [Char] -> a
18:51:25 <ski> `error' promises that its return value will be of any type `a' that the caller would like
18:51:43 <ski> (this works, because `error' doesn't return a value, instead it aborts computation)
18:52:22 <ski> cohn : btw, you can simplify ("eta-reduce") `\d -> head d', to just `head'
18:52:23 <cohn> ah, okay. so because I didn't use `error`, the computation didn't abort, which caused the type mismatch message in my paste?
18:52:35 <ski> (but possibly you want to put more code into that alternative ..)
18:52:41 <ski> yes, cohn
18:53:01 <ski> it tried to check that the result type of both "branches" was the same .. and they weren't
18:53:34 <cohn> ok, so...
18:53:38 <cohn> @type either
18:53:40 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:53:57 <cohn> so the type of 'c' was different?
18:55:33 <cohn> and yes, it works with eta reduction:  `either (\err -> error "Didn't work") head dat`
18:58:09 <cohn> thanks everyone!
18:58:44 <proofofme> main = allDivs >>= (\x -> mapM_ print (fromJust x))
18:59:12 <proofofme> how would you rewrite the fromJust portion?  I've been trying to do pattern matching but get a mismatched type error
18:59:13 <Axman6> formJust is a code smell
18:59:23 <Axman6> what have you tried?
19:00:02 <proofofme> https://pastebin.com/HYHRj4PY
19:00:09 <ski>   main = maybe (putStrLn "Oups !") (mapM_ print) =<< allDivs  -- one way. you could also use a `case', e.g.
19:00:18 <Axman6> main = do {divs <- allDivs; case divs of Nothing -> <handle error case>; Just x -> do <things with x> }
19:00:49 * ski can't recall whether proofofme's seen `do' yet
19:01:08 <proofofme> very briefly ... not an expert
19:01:10 <ski>   main = do divs <- allDivs
19:01:11 <Axman6> proofofme: what is the type oif handleMaybe?
19:01:17 <ski>            case divs of
19:01:23 <ski>     Nothing -> <handle error case>
19:01:29 <ski>     Just x  -> do <things with x>
19:01:37 * Axman6 notes that's the correct spelling of the Australian "of"
19:02:35 <proofofme> type is [Div] | Nothing, right?
19:02:45 <proofofme> data Div = Div String deriving (Show, Eq)
19:03:11 <Axman6> doesn;'t sound right to me, | isn't a thing in types
19:03:27 <Axman6> "" looks like a String to me though
19:08:22 <Axman6> proofofme: you should start by adding a type signature to handleMaybe, that should help you get your thoughts in order
19:14:44 <cohn> lemmih: can you recommend any good resources on types besides the Typeclassopedia?
19:20:49 * hackage clckwrks 0.26.2 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.26.2 (JeremyShaw)
19:24:51 <proofofme> `main = maybe (putStrLn "Error") (mapM_ print) =<< allDivs` this line ended up working
19:27:42 <Axman6> do you understand it though? I still think you should do what I suggested above
19:28:12 <Axman6> because I have a strong feeling you wrote handleMaybe without understanding why it compiled
19:28:32 <Axman6> and it was not doing hwat you intended it to do
19:28:53 <proofofme> I understand the maybe function.  I was returning the wrong type, yeah?
19:29:48 <Axman6> for a hint about what type handleMaybe should have, in the code you had before, change it from main = allDivs >>= (\x -> mapM_ print (handleMaybe x))  main = allDivs >>= (\x -> mapM_ print (_handleMaybe x)) and let the compiler tell you
19:30:55 <Axman6> "I was returning the wrong type" is almost always the answer to why something didn't compile, but you have to understand what types you expect to be returning (and accepting) to be able to do something with that fact
19:32:42 <proofofme> Found hole: _handleMaybe :: Maybe [Div] -> t0 a0
19:32:42 <proofofme>       Where: ‘t0’ is an ambiguous type variable
19:32:42 <proofofme>              ‘a0’ is an ambiguous type variable
19:32:44 <proofofme>       Or perhaps ‘_handleMaybe’ is mis-spelled, or not in scope
19:33:36 <Axman6> hmm, slightly less heklpful now mapM_ has a more general type than it used to. read `t0 a0`  as [a]
19:33:42 <proofofme> Couldn't match type ‘Div’ with ‘Char’
19:33:55 <proofofme> this is when I use it without the `_`
19:34:21 <Axman6> yep, so your function in the Nothing case returns a String, which is [Char], but you really wanted to return a [Div]
19:34:51 <proofofme> oh! I see
19:35:32 <proofofme> trying to fix it now ...
19:35:59 <Axman6> uh, also, you had ... Just x -> return x, which means you're actually using some monad, which you probably didn't mean to, you probably wanted Just x -> x; Nothing -> <something that is also of tyoe [Div]>
19:36:09 <Axman6> :t return
19:36:11 <lambdabot> Monad m => a -> m a
19:36:35 <Axman6> our return is not the same as everyone else's return
19:36:42 <proofofme> so exclude the return
19:37:03 <proofofme> compiled!
19:37:05 <proofofme> makes sense
19:37:22 <proofofme> handleMaybe x = case x of
19:37:22 <proofofme>     Just val -> val
19:37:22 <proofofme>     Nothing -> [Div ""]
19:37:25 <proofofme> I used that
19:37:34 <Axman6> is there a simpler way to make a [Div]?
19:38:04 <Axman6> how can we construct lists in Haskell (hint, there are two answers, according to the definition of lists)
19:38:04 <proofofme> hmm how?
19:38:14 <Axman6> @src []
19:38:14 <lambdabot> data [] a = [] | a : [a]
19:38:15 <proofofme> cons
19:38:42 <proofofme> use data?
19:38:54 <Axman6> if I say to you "I need a list of Wombles", and you don't have any Wombles, can you give me a list of Wombles?
19:39:11 <proofofme> I can give [], yeah?
19:39:15 <Axman6> yep
19:39:20 * hackage clckwrks 0.26.2.1 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.26.2.1 (JeremyShaw)
19:39:31 <Axman6> since [] doesn't need any Wombles
19:39:44 <proofofme> handleMaybe x = case x of
19:39:44 <proofofme>     Just val -> val
19:39:44 <proofofme>     Nothing -> []
19:39:49 <proofofme> like that, yeah?
19:39:54 <Axman6> what's the type of that function?
19:40:03 <Axman6> looks good, but it;s only half the story!
19:41:02 <proofofme> handleMaybe :: Maybe [Div] -> [Div]
19:41:58 <Axman6> looks good to me (though, that's a much more specific type that that function actually needs - do you know what its most general type is?)
19:42:46 <proofofme> handleMaybe :: Maybe [a] -> [a]
19:42:56 <Axman6> noice, nailed it
19:43:03 <proofofme> why generalize it?
19:43:15 <dsal> Why write special code for every special case?  :)
19:43:24 <proofofme> ha good point
19:43:40 <dsal> @hoogle Maybe [a] -> [a]
19:43:41 <lambdabot> Prelude concat :: Foldable t => t [a] -> [a]
19:43:41 <lambdabot> Data.List concat :: Foldable t => t [a] -> [a]
19:43:41 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
19:43:44 <Axman6> it's more useful then, I can use it on my Maybe [Womble] without having to write it myself, thansk for the useful function!
19:44:17 <proofofme> I contributed to the commons!
19:44:18 <Axman6> % :t concat @Maybe
19:44:19 <yahb> Axman6: Maybe [a] -> [a]
19:44:20 * hackage clckwrks-theme-bootstrap 0.4.2.4 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.4.2.4 (JeremyShaw)
19:44:33 <Axman6> damn, looks like someone beat you to it!
19:45:06 <proofofme> XD
19:45:15 <dsal> Notice that the same thing you'd use for `[[a]] -> [a]` also works for `Maybe [a] -> [a]` (and tons of other foldables)
19:46:23 <Axman6> you mean, even my OWN foldables? :mindblown:
19:46:48 <proofofme> guys brb.  I must hunt for food.  I will be back soon.  thanks^1000000
19:47:06 <dsal> I caught a pomegranate today.
19:47:12 <Axman6> > a^1000000
19:47:14 <lambdabot>  a * a * (a * a) * (a * a * (a * a)) * (a * a * (a * a) * (a * a * (a * a))) ...
19:47:46 <dsal> Is that a Gigafonzee?
19:48:05 <Axman6> > let thanks = var "thanks" in thanks^1000000
19:48:07 <lambdabot>  thanks * thanks * (thanks * thanks) * (thanks * thanks * (thanks * thanks)) ...
19:48:39 <dsal> That library is kind of magic.
19:49:01 <Axman6> nah, it's simple... simple-reflect XD
19:51:01 <monochrom> > 1^10 :: Expr
19:51:04 <lambdabot>  1 * 1 * (1 * 1) * (1 * 1 * (1 * 1)) * (1 * 1)
19:51:35 <Axman6> > reduction (1^10)
19:51:38 <lambdabot>  [1 * 1 * (1 * 1) * (1 * 1 * (1 * 1)) * (1 * 1),1 * (1 * 1) * (1 * 1 * (1 * 1...
19:51:44 <monochrom> It's very dumb, like some kind of FreeNum.
19:54:11 <monochrom> > (-0)^10 :: 
19:54:13 <lambdabot>  <hint>:1:12: error:
19:54:14 <lambdabot>      <hint>:1:12: error:
19:54:14 <lambdabot>          parse error (possibly incorrect indentation or mismatched brackets)
19:54:16 <monochrom> > (-0)^10 :: Expr
19:54:19 <lambdabot>  negate 0 * negate 0 * (negate 0 * negate 0) * (negate 0 * negate 0 * (negate...
19:54:27 <monochrom> I didn't expect that to be that dumb. :)
19:55:19 <monochrom> You could imagine that it merely uses an AST, and so the most sophisticated code is in the Show instance.
20:04:20 * hackage longshot 0.1.0.4 - Fast Brute-force search using parallelism  https://hackage.haskell.org/package/longshot-0.1.0.4 (thyeem)
21:54:48 <proofofme> `cabal install mysql-haskell` fails for me
22:35:08 <yushyin> a bit more information would be needed to help you e.g. a log file
22:58:50 * hackage longshot 0.1.0.5 - Fast Brute-force search using parallelism  https://hackage.haskell.org/package/longshot-0.1.0.5 (thyeem)
23:29:57 <siraben> Is there an elegant way to implement hygienic macros?
23:30:35 <Axman6> I don't know what defined hygenic macros, but there is a new way to write type safe Template Haskell in GHC
23:30:40 <Axman6> defines*
23:50:28 <kuribas> siraben: generics
23:50:49 <siraben> Oh I should clarify, I meant I'm implementing a Lisp
23:50:58 <siraben> and want to implement hygienic macros
23:51:21 <suzu_> macros that wash their hands often
23:53:33 <kuribas> do they wear masks?
23:53:56 <suzu_> yes, safety first
23:54:07 <kuribas> siraben: have a look at scheme
23:54:24 <u-ou> what about macros individual freedom?
23:55:14 <siraben> kuribas:  Yeah, https://github.com/siraben/r5rs-denot
23:55:28 <siraben> It just that, the hygienic expansion algorithms I'm looking at are quite stateful
23:56:31 <kuribas> siraben: of course it's stateful, you need to create new identifiers.
23:58:32 <suzu_> ok i just looked up these macros
23:58:55 <suzu_> it means they don't pollute / consume / shadow any bindings in scope at macro-use time?
23:59:12 <siraben> suzu_:  Yes
23:59:35 <suzu_> they're guaranteed an internal consistent binding scope by the compiler in some way?
23:59:49 <suzu_> and you want this in a lisp interpreter?
