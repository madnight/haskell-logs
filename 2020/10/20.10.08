00:39:39 --- mode: ChanServ set +o Sigyn
01:11:04 <spinnylights> hiya haskellers‚Äîif i run `stack setup` in a new stack project, it tries to pull down and build ghc 8.8.4, but the build fails due to a sanity check; the error is "Could not load module Distribution.Simple; It is a member of the hidden package Cabal-3.0.1.0"
01:11:15 <spinnylights> this is on arch linux, ghc installed via ghcup
01:11:39 <spinnylights> i've googled about it a bit but i've only found stuff related to people hitting errors like this on their own projects, not on ghc itself, unless i'm confused about something
01:13:15 <maerwald> spinnylights: which ghc does it actually use? do you have one installed via arch repo?
01:14:06 <spinnylights> if i run `which ghc` it gives the ghc installed via ghcup, which is 8.8.4; i also have ghc 8.10.2 installed globally via arch repos
01:14:25 <spinnylights> do you think stack is getting confused by that?
01:14:46 <maerwald> it should use its own, unless you tell it otherwise, but not sure
01:15:00 <spinnylights> yeah, i was under the impression that stack wouldn't use either of them
01:15:48 <spinnylights> i could try telling ghcup to use 8.10.2 and see if it makes any difference i guess
01:16:58 <spinnylights> seems like it still wants to pull down 8.8.4, but we'll see what happens i guess
01:18:04 <spinnylights> same thing :/ this is after wiping out the ghc-tinfo6-8.8.4 stuff in ~/.stack
01:23:49 * hackage yesod-filter 0.1.0.2 - Automatic filter generator for Yesod  https://hackage.haskell.org/package/yesod-filter-0.1.0.2 (KenzoYotsuya)
01:27:34 <spinnylights> i'm going to try using the nightly resolver instead and see if that makes a difference‚Äîi notice that the 8.8.4 lts release came out only 5 days ago so maybe i've hit a bug
01:28:28 <maerwald> just use the previous one
01:28:30 <maerwald> e.g. 16.15
01:29:32 <spinnylights> okay nightly did work‚Äîi'll try 16.15 then
01:30:54 <spinnylights> well 16.16 i guess
01:33:44 <spinnylights> same thing :/ i kind of suspect it'll do this for every 8.8.4 lts resolver; let's see about the 8.8.3 lts, wonder what happens there
01:34:29 <spinnylights> no trouble there either‚Äîseems to be specific to 8.8.4
01:37:02 <gentauro> is this a joke or did somebody implement "clippy"? https://asciinema.org/a/xkqfc5Fst9yC5gDaPskiNE5au xD
01:37:51 <Taneb> gentauro: it's entirely possible that both are the cae
01:38:01 <opqdonut> it's a very popular feature in kakoune I hear
01:38:23 <opqdonut> originally an easter egg?
01:40:00 <gentauro> Taneb: `cae`? What does that mean?
01:40:09 <Taneb> Typo for "case"
01:40:20 <Taneb> (it's early and I didn't sleep well)
01:40:25 <gentauro> aha
01:42:35 <gentauro> I really need to find an alternative to `intero` on my NixOS. I think it's the last `stable channel` that will allow for the usage of `intero`, then I must move on (which is pretty sad)
01:42:44 <gentauro> so getting a "clippy" could be fun :)
01:46:20 * hackage openapi3 3.0.0 - OpenAPI 3.0 data model  https://hackage.haskell.org/package/openapi3-3.0.0 (maksbotan)
01:56:24 <Guest_58> i have a question. Im trying to isntall haskell on my mac, using the ghcup installer, where i just copy the link to my terminal and the code get downloaded by itself. But when its being unpacked it says that i need to update my mac, however, when i try to update it says that i have no updates avalible
02:02:35 <yushyin> maerwald: ^ ~.~
02:02:45 <maerwald> I don't have a mac
02:02:53 <yushyin> I know!
02:03:57 <yushyin> but why is macOS + ghcup such a bad experience, or is it just the users?
02:04:14 <maerwald> because of mac?
02:05:50 * hackage servant-openapi3 2.0.0 - Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.  https://hackage.haskell.org/package/servant-openapi3-2.0.0 (maksbotan)
02:06:14 <tomsmeding> interesting report; maybe their hardware is old and ghc wants a newer macos version that cannot (officially) be installed on that machine?
02:07:50 <c_wraith> Part of it is that OS X has decided to split its bash configuration across two files, and ghcup often updates the wrong one
02:08:07 <maerwald> that's already fixed
02:08:15 <maerwald> (blatantly)
02:08:16 <c_wraith> people still ask about it frequently
02:09:07 <c_wraith> like, I remember at least two people in the last week with that issue
02:36:15 <christo> hey guys, anyone know if i can set cabal build to default to cabal v1-build and same with other commands? 
02:36:46 <dcoutts> christo: you can use an older release of cabal where it still defaulted to v1
02:45:30 <christo> dcoutts, you know how i can find which version defaults to v1? 
02:45:50 <dcoutts> christo: check the changelog, it was probably 3.0
02:52:11 <jackdk> https://hackage.haskell.org/package/cabal-install-3.2.0.0/changelog
02:52:29 <jackdk> 3.0.0.0: Legacy commands are now only accessible with the `v1-` prefixes, and the `v2-`commands are the new default.
02:57:48 <christo> jackdk so 2.4 then? 
02:59:11 <jackdk> if that's what the changelog says
03:03:06 <christo> when using ghcup to install different cabal version
03:03:10 <christo> is it: 
03:03:20 <christo> ghcup install cabal 2.4.1.0
03:03:25 <christo> having issues with that
03:07:00 <maerwald> "having issues" isn't very specific
03:10:49 <christo> ye, my bad. have it working now. thx jackdk dcoutts
03:11:22 <christo> i'm trying to get haskell language server support working for the Euterpea music lib in vs code
03:11:57 <maerwald> I'm not sure that will work with an old cabal
03:13:26 <maerwald> note that ghcup can install hls too
03:20:21 <christo> maerwald i've tried most things to get HLS to provide support for Euterpea but no luck
03:20:43 <christo> so for euterpea to work ghc has to be set lower, i'm uisng 8.6.4
03:20:46 <christo> but
03:21:08 <christo> euterpea only builds and works when you use the v1 style cabal commands
03:21:32 <christo> i've changed cabal to 2.4.1.0 and ghc at 8.6.4
03:21:37 <christo> and from the cmd line project works
03:22:04 <christo> but haskell language server in vs code still gives me a msg saying it can't resolve Euterpea dependency
03:22:21 <christo> even though the project is building from cmd line
03:38:49 * hackage HsOpenSSL 0.11.4.20 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.4.20 (VladimirShabanov)
03:43:40 <matthias_gorgens> Hello!  I have a monad computation that runs in RWS.  Specifically, for the config provided by the Reader bit, I have a list of values.  So I typically run my RWS computation multiple times.
03:44:47 <matthias_gorgens> Now I want to add the ability for my computations to communicate: basically somehow add an operation `collect :: a -> m [a]` that you give a value and that returns the values given by your own computation and those of all the other computations running in lockstep.
03:45:08 <matthias_gorgens> (It's fine for `collect` to fail, if the different computations somehow get out of lockstep.)
03:45:14 <matthias_gorgens> Any idea how to implement this?
03:45:34 <matthias_gorgens> I am thinking of something with coroutines or continuations.
03:47:54 <matthias_gorgens> (If I need to restrict the values that `collect` can transmit to a single type, that's not ideal, but still ok.)
03:48:59 <davean> christo: euterpea only builds with v1 commands?
03:49:54 <maerwald> it looks like an abandoned project
03:57:28 <davean> christo: I just build it with v2-build, I think you might be confused about the problem
04:00:03 <christo> davean i mean, i want to use the package in a personal cabal project and have haskell language support for the Euterpea API
04:00:29 <christo> i want to use the Euterpea package in a personal cabal project as a dependency*
04:00:48 <davean> Right, so?
04:01:53 <christo> whenever i use the package as a dependency i always get a cannot resolve dependency error from HLS in vs code and it breaks/or interrupts rather all of other code suggestion support through the project
04:03:06 <christo> i want ide features with coding a euterpea project basically
04:03:18 <davean> Right so why do you think this has to do with v1 vs v2?
04:03:42 <christo> on the website it said euterpea only builds with v1
04:03:51 <christo> or the package as a dependency does
04:04:01 <christo> haskell language server
04:04:07 <christo> by default calls cabal build
04:04:13 <christo> when doing checks i think
04:04:16 <christo> not v1-build
04:06:12 <christo> maybe only way around this is to build the Euterpea project itself so i can get code completetion/suggestions? 
04:06:30 <christo> and create my own files within the project for playing around with it
04:11:49 <davean> The issue is just its Setup, you can build it with v2 just fine, just specify the Cabal version.
04:12:29 <yushyin> they left :/
04:14:11 <davean> I think they just really wanted to think the problem was what they thought it was :/
04:30:20 * hackage hsinspect 0.0.17 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.17 (tseenshe)
05:13:40 <Tario> Alright, thank you sm! I'll take a look on the repos wiki
05:14:41 <codedmart> I am trying to use http-conduit to download a file and stream to s3 using amazonka-s3-streaming. I am seeing this error: https://gist.github.com/codedmart/d3c5f008c4a8ad27b24e649f8771a590
05:15:00 <codedmart> Anyone that can provide some ideas/clues to what I am missing here.
05:17:46 <jackdk> codedmart: looks like the commit that fixes the problem -- https://github.com/brendanhay/amazonka/commit/83dc7ad38a76e1db5f2490d7c7d8e269df8976aa -- hasn't yet made it into an amazonka release.
05:18:35 <codedmart> jackdk Ah I missed that :(. Thanks!
05:19:26 <jackdk> yeah, the slow rate of PR merges in amazonka is a tragedy
05:19:59 <sshine> I'm getting a type error I don't understand. http://pastie.org/p/3PpeaPreqcmDAG87HAFhVD - https://github.com/sshine/dagger2/blob/more-foldfix/src/Dagger/Contract/Traversal.hs - somewhere in my code, word = Integer gets assumed, but I don't know why.
05:22:18 <siraben> How do I get `[Maybe String]` out of a prism? I ahve `myCSV ^? namedCsv . rows . column @String "Timestamp"` but it gives me a single result.
05:24:55 <carbolymer> how lightweight is thread from forkIO? i need to push data to rabbitmq (couple times per second) and I plan to wrap each call in `async` - is it a good idea or would it be better to create channel/queue and separate long-living thread to read from that queue and push to rabbit?
05:27:51 <sshine> hmm, it seems that I'm messing up mutually recursing two Fix types a slight bit...
05:28:10 <sshine> hi siraben :)
05:28:29 * sshine doesn't know lenses.
05:28:29 <siraben> Hi sshine 
05:28:47 <siraben> sshine:  the github link seems broken?
05:28:53 <sshine> eh.
05:28:56 <sshine> d'oh.
05:29:29 <sshine> there!
05:29:50 <siraben> Why is it called foldFix instead of cata now?
05:30:12 <sshine> they changed it in 0.3, I think
05:30:24 <siraben> catamorphism is standard terminology in literature
05:30:25 <siraben> Heh
05:30:34 <sshine> I don't know... maybe the foobarmorphisms sound scary.
05:30:37 <sshine> sure
05:30:48 <sshine> I am certainly confused. :-D
05:31:18 <siraben> sshine:  what's the function supposed to do?
05:32:05 * [exa] writes down foobarmorphism as a general morphism placeholder
05:33:25 <sshine> siraben, gather a list of transfers identified by their parameter. so initially a [(asset, party)]. but because of other combinators, I'm actually gathering an [(asset, party, Expr word oracle)] with Expr being another Fix type. what I think I'm forgetting is to add 'Fix' to the value 'Const 1'.
05:33:52 <[exa]> carbolymer: forkIO is almost free, these threads are very "green". by the `thread` for comparison, y[4~ou mean an actual spawned pthread?
05:33:56 <sshine> siraben, this is my first use of Data.Fix, so I'm not sured to wrap everything in Fix.
05:33:59 <siraben> sshine:  yes that would appear to fix the type error
05:35:03 <sshine> that Fix'ed it.
05:35:21 <siraben> Interesting, why use Data.Fix over the recursion schemes library?
05:35:42 <sshine> I don't know yet. I have only tried one and not the other. :) I did look at recursion-schemes earlier.
05:36:07 <yushyin> (recursion schemes calls it cata)
05:36:41 <sshine> doesn't recursion-schemes mainly provide ListF, NonEmptyF, TreeF? this is a specific AST type...
05:36:42 <siraben> sshine: I like recursion schemes because it matches the theoretical background better
05:37:00 <sshine> siraben, "matches the theoretical background better" = uses cata, para, hylo naming?
05:37:08 <siraben> data ListF a b = Nil | Cons a b; type instance Base [a] = ListF a, which makes the concept of initial algebra for lists
05:37:13 <siraben> clearer*
05:37:30 <sshine> ah
05:37:52 <sshine> I'm not sure how to use recursion-schemes on arbitrary syntax trees that aren't lists and rose-trees.
05:39:46 <siraben> sshine: Similar to how you did it in src/Dagger/Contract.hs, define the base functor then `Fix` it
05:40:14 <siraben> Argh, lenses have such poor type errors
05:41:57 <sshine> ah, I wasn't looking in Data.Functor.Foldable.TH which appears to have the recipe for doing this to your own type... I try to avoid TH when I can get most without.
05:42:07 <sshine> siraben, optics!
05:42:56 <siraben> sshine:  oh great, now the code would look even more natural than writing in open recursive style
05:43:17 <sshine> siraben, apropos?
05:43:39 <siraben> apropos?
05:43:54 <sshine> oh you mean using data-fix / recursion-schemes is a boon?
05:43:59 <sshine> it certainly seems so :)
05:43:59 <siraben> sshine: Oh I was referring to your TH discovery
05:44:02 <sshine> ah
05:45:04 <siraben> IMO using these abstractions are nice but when they start impacting readability for others, I weigh that too. Even beginner Haskellers can read a normal `Expr a` declaration, so that's great.
05:45:14 <sshine> yes.
05:45:45 <sshine> I'm still evaluating whether Fix will mess up things or make things easier for people less experienced than myself.
05:46:20 <sshine> there will be a bunch of 'Fix' constructors, like the bug I experienced, that will clutter the view.
05:47:36 <siraben> sshine:  Is this a new smart contract language?
05:47:38 <sshine> I compared the optparse-generic library with/without TH magic for type-level --help hints... there is very little overhead and it is easily extensible without having to understand how it does what it does.
05:47:58 <sshine> siraben, no, it's the same. I'm just generalising the Contract type so that it can more easily target multiple blockchains.
05:48:06 <troydm> hey guys! I'm trying to implement show for IOUArray and I'm getting ‚Äòshow‚Äô is not a (visible) method of class ‚ÄòIOUArray‚Äô, with GHC 8.2.2, any suggestions&
05:48:08 <troydm> ?
05:48:30 <carbolymer> [exa], thanks; by long-living thread I meant another thread from forkIO - but If they're very "green" I think wrapping each rabbimq publish in `async` will be fine in my case;)
05:48:51 <sshine> siraben, also, the original author of the compiler simplified a few things and I added let-expressions.
05:49:26 <sshine> siraben, but it's mostly the same concept, just different ideas of execution runtimes. :)
05:49:37 <sshine> siraben, how's your macro language going?
05:50:02 <siraben> sshine:  Perhaps we should move this conversation to the evm-lang-design gitter channel
05:50:38 <[exa]> carbolymer: yeah, in fact that's the recommended way for network programming afaik
05:50:50 * hackage stylish-haskell 0.12.2.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.12.2.0 (JasperVanDerJeugt)
05:51:18 <carbolymer> [exa], to spawn new threads when pushing things to avoid blocking? 
05:52:09 <[exa]> carbolymer: yeah, the threads are cheap and the internal eventloop is pretty good. you may also check the rabbitmq wrapper, I'd expect that it already does something like that internally
05:52:19 * hackage network-transport-tests 0.3.0 - Unit tests for Network.Transport implementations  https://hackage.haskell.org/package/network-transport-tests-0.3.0 (FacundoDominguez)
05:53:00 <[exa]> troydm: can you share a bit of code that doesn't work? (first guess, are you writing the instance of Show?)
05:55:43 <carbolymer> [exa], you mean amqp library? the publishMsg pushes message to mvar and blocks, hence why I want to wrap it in async
05:56:36 <troydm> [exa]: https://pastebin.com/BZ08cd7X
05:56:39 <troydm> [exa]: yes
05:57:01 <[exa]> carbolymer: maybe better have a channel for throwing the messages at, and a "worker thread" that just forwards the stuff to publishMsg ?
05:57:59 <carbolymer> [exa], yep, but if those threads are so "green" is it worth the effort to implement this "worker thread"?
05:58:13 <[exa]> carbolymer: I wouldn't bother until there's a proof that it's too slow
05:58:27 <carbolymer> [exa], that's exactly my reasoning ;)
05:58:29 <[exa]> how many thousand messages per second do you want to pass through? :D
05:58:48 <jackdk> sshine: if you're doing languagey-stuff with recursion schemes, this post might interest you: http://newartisans.com/2018/04/win-for-recursion-schemes/
05:59:26 <carbolymer> [exa], a dozen of messages per second in high traffic ;]
05:59:40 <[exa]> troydm: okay, you need to write a Show behind the =>, this way you are instancing IOUArray typeclass
05:59:50 <[exa]> carbolymer: </care>
06:00:05 <carbolymer> yeah
06:00:39 <troydm> [exa]: oic
06:01:10 <[exa]> troydm: I guess the instance should read "If the HType e is showable, IOUArray i e should also be showable" right?
06:01:55 <troydm> [exa]: yeah, well, sometimes I have no idea what I'm writing and if it compiles it usually works, but I have no idea how it works
06:02:55 <troydm> [exa]: I just need to make instance of IOUArray Int64 HType showable
06:03:06 <troydm> [exa]: and I'm bit struggling
06:03:50 <[exa]> troydm: you are using HType there as a higher-order type constant, which it is not. I guess you want:
06:03:59 <sshine> jackdk, thanks! I am.
06:04:32 <[exa]> troydm: instance Show e => Show (IOUArray i e) where .... (which says "IOUArray of e's is showable if there's a way of showing he e's)
06:04:50 <[exa]> *the
06:06:27 <sshine> jackdk, excellent article, thank you. :)
06:06:35 <sshine> jackdk, I
06:06:42 <sshine> jackdk, I'll look into it and do a comparison.
06:06:48 <troydm> [exa]: Could not deduce (MArray IOUArray e [])
06:06:50 <troydm>         arising from a use of √¢¬Ä¬ògetElems‚Äô
06:06:55 <troydm> [exa]: is what I get
06:07:07 <troydm> [exa]: when I change it to what you've suggested
06:07:14 <[exa]> ok we're getting closer
06:07:25 <troydm> [exa]: which is a bit confusing
06:07:55 <[exa]> it also needs some assurance that you are not running this on an array that wouldn't have a workable getElems
06:08:48 <[exa]> troydm: (also that `i` is an actual index as in Ix )
06:09:13 <[exa]> you can have a look at the type of getElems here https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-MArray.html#v:getElems to see how much assurance it requires to work
06:10:36 <[exa]> you actually need to declare your typeclass instance with the same (or stricter) conditions, because otherwise you'd be "promising" to deliver instances that can not work
06:12:39 <[exa]> so in our case, the instance should read, very roughly: If `i` is an Ix index, if `e` is showable by Show, and if the IOUArray forms a `MArray IOUArray e m` for some `m`, you can also show `IOUArray i e`
06:14:13 <[exa]> now you should notice the obvious problem; `getElems` is a monadic action of the monad `m`, I'm not sure you'll be able to fit that into a normal `show` that must return a "pure" String
06:16:23 <troydm> [exa]: No instance for (MArray IOUArray HType []) <= what's [] in this?
06:17:07 <[exa]> troydm: you are trying to use `map show` on `m e` returned from getElems, so it assumes that you know what are you doing and that m==[]
06:17:34 <troydm> [exa]: ohh fuck I've missed that m a part of getElems
06:17:36 <[exa]> obviously that MArray instance does not exist, I assume it will require `m` to be IO or something similarly powerful
06:17:48 <troydm> [exa]: are there any good MArray examples out there
06:18:13 <[exa]> yeah, as MVector... :]
06:18:19 <troydm> ohh I've could do the obvious, unsafeIOPerform
06:18:25 <[exa]> please don't :D
06:18:38 <[exa]> btw why do you need the thing mutable?
06:19:34 <troydm> [exa]: well I'm trying to write R7RS scheme interpreter, so I need a vector elements to be mutable
06:22:46 <troydm> [exa]: well, even with unsafePerformIO, I get No instance for (MArray IOUArray HType IO)
06:23:29 <dminuoso> Is there a way to have `foo $ \do -> \n ...` with the following block at the same indention as `foo`?
06:23:45 <dminuoso> I have the problem of deeply nested callbacks here
06:23:50 <dminuoso> Or is ContT my only solution here?
06:29:39 <[exa]> troydm: okay, then it should _not_ have any showable representation, a mutable state cannot be exported. Just supply a dummy
06:39:05 <cohn> can anyone recommend any books on learning parallel and concurrent Haskell? The book by Simon Marlow seems to be a good bit out of date at this point.
06:39:15 <dminuoso> cohn: Simon Marlows book.
06:39:36 <dminuoso> There are no other good resources Im aware of.
06:41:53 <cohn> dminuoso: ok. I ask because I've worked through a few examples and it seems like some of the syntax used in the book is no longer valid
06:42:07 <dminuoso> Can you give some examples?
06:43:35 <cohn> GHC complains about this line for one:  https://github.com/simonmar/parconc-examples/blob/master/Sudoku.hs#L77
06:43:53 <dminuoso> Can you share the diagnostic it gives?
06:43:56 <cohn> even tried setting it up in an isolated Stack environment and no good
06:44:00 <cohn> sure, one sec
06:46:08 <cohn> https://pastebin.com/LLndiZyi
06:46:22 <cohn> that's actually from the HLS, but you get the idea
06:46:23 <cohn> :D
06:47:14 <dminuoso> cohn: Do you have overloaded strings turned on?
06:47:36 <cohn> yes
06:47:48 <dminuoso> Try giving the string an explicit annotation then.
06:48:02 <cohn> like "foo" :: String?
06:48:11 <dminuoso> Yeah
06:48:15 <dminuoso> Or actually, do you have OverloadedLists as well?
06:48:32 <cohn> no
06:48:35 <cohn> try it?
06:48:44 <dminuoso> No.
06:48:54 <dminuoso> % :set -XOverloadedStrings
06:48:54 <yahb> dminuoso: 
06:49:32 <dminuoso> % regularGrid g  = if all (`elem` "0.-123456789") g then Just g else Nothing
06:49:32 <yahb> dminuoso: ; <interactive>:83:21: error:; Ambiguous occurrence `all'; It could refer to; either `Text.all', imported from `Data.Text'; or `Prelude.all', imported from `Prelude' (and originally defined in `Data.Foldable')
06:49:36 <dminuoso> % :set -XNoOverloadedStrings
06:49:36 <yahb> dminuoso: 
06:49:38 <dminuoso> % regularGrid g  = if all (`elem` "0.-123456789") g then Just g else Nothing
06:49:38 <yahb> dminuoso: ; <interactive>:85:21: error:; Ambiguous occurrence `all'; It could refer to; either `Text.all', imported from `Data.Text'; or `Prelude.all', imported from `Prelude' (and originally defined in `Data.Foldable')
06:49:44 <dminuoso> % regularGrid g  = if Prelude.all (`elem` "0.-123456789") g then Just g else Nothing
06:49:44 <yahb> dminuoso: 
06:49:57 <dminuoso> cohn: Ah I mispasted. But anyway, OverloadedStrings is the cause here.
06:50:02 <dminuoso> Consider:
06:50:31 <dminuoso> "0.-123456789" is a polymorphic type, but so is `elem`
06:50:37 <cohn> I ran `stack ghci`, got the error, then entered `:set -XOverloadedStrings` into ghci followed by `:r`. Same error.  : 
06:50:45 <dminuoso> So it cant infer that "0.-123..." is even a list
06:50:58 <dminuoso> cohn: No, you need to set -XNoOverloadedStrings
06:51:02 <cohn> oh!
06:51:04 <dminuoso> Just to verify locally
06:51:06 <cohn> lemme try that
06:51:06 <dminuoso> But anyway
06:51:08 <dminuoso> 15:47:40             cohn | like "foo" :: String?
06:51:13 <dminuoso> That is a drop-in workaround.
06:51:27 <dminuoso> Or you annotate `elem`
06:51:47 <cohn> ok, it works when using `:set -XNoOverloadedStrings`
06:51:50 <cohn> interdesting
06:52:02 <dminuoso> cohn: Consider this trivial example:
06:52:04 <dminuoso> % :t elem
06:52:04 <yahb> dminuoso: (Foldable t, Eq a) => a -> t a -> Bool
06:52:14 <dminuoso> % :t null
06:52:14 <yahb> dminuoso: ; <interactive>:1:1: error:; Ambiguous occurrence `null'; It could refer to; either `Text.null', imported from `Data.Text'; or `Prelude.null', imported from `Prelude' (and originally defined in `Data.Foldable')
06:52:17 <dminuoso> % :t Prelude.null
06:52:17 <yahb> dminuoso: Foldable t => t a -> Bool
06:52:26 <dminuoso> % :t fromString "foo"
06:52:26 <yahb> dminuoso: IsString a => a
06:52:36 <dminuoso> Prelude.null (fromString "foo")
06:52:45 <dminuoso> What should that give you? What Foldable instance should be selected?
06:53:20 <dminuoso> So it's your mistake at the end for using OverloadedStrings. :)
06:53:26 <cohn> hah
06:53:28 <cohn> good point
06:53:52 <cohn> yea, I can see why GHC would get confused
06:54:05 <cohn> dminuoso: thanks so much!
06:54:13 <dminuoso> You're welcome.
06:54:26 <cohn> :D
06:58:16 <cohn> dminuoso: I can't build the package the author published for the book: https://hackage.haskell.org/package/parconc-examples
06:58:41 <cohn> though it seems like a problem with a 3rd party package and not the parconc-examples package
06:59:17 <dminuoso> Do you get some particular error message?
06:59:19 * hackage boilerplate 0.0.2 - Generate Haskell boilerplate.  https://hackage.haskell.org/package/boilerplate-0.0.2 (tseenshe)
06:59:26 <cohn> I get this:  https://pastebin.com/gZpSC8kv
07:00:58 <cohn> using cabal to build seems to pinpoint the problem:  https://pastebin.com/vBuc4FrW
07:01:32 <dminuoso> In case of `cabal` the problem is that your GHC is too new.
07:01:40 <dminuoso> The package is no longer maintained, so you need an older GHC
07:01:50 <dminuoso> Unless you're willing to experiment bumping the bounds.
07:01:55 <cohn> not really.  ; )
07:02:02 <cohn> easy enough to just ghcup
07:02:04 <dminuoso> Right
07:02:25 <dminuoso> 8.6.5 should be fine
07:02:37 <dminuoso> no wait, you need 8.4
07:04:20 <sshine> bumping bounds isn't hard or longwinded, though.
07:04:59 <cohn> sshine: it would just require some code refactoring, then submit a Github PR?
07:05:12 <sshine> yup!
07:05:32 <sshine> and in the meantime, you can always refer to your copy of the github repo.
07:06:00 <cohn> that could be an interesting project to help me get more experience reading/writing Haskell code.
07:06:03 <sshine> cohn, probably only changing the bounds in the .cabal file.
07:06:20 * hackage network-transport-tcp 0.8.0 - TCP instantiation of Network.Transport  https://hackage.haskell.org/package/network-transport-tcp-0.8.0 (FacundoDominguez)
07:06:22 <cohn> oh
07:08:15 <dminuoso> cohn: In general Id prefer to bump bounds. Even if it is some minor work, it's contributions that everybody else will benefit from.
07:12:19 <cohn> agreed
07:15:19 * hackage capnp 0.6.0.2 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.6.0.2 (isd)
07:21:50 * hackage mmsyn7s 0.9.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.9.0.0 (OleksandrZhabenko)
07:22:50 * hackage phonetic-languages-rhythmicity 0.1.0.0 - Allows to estimate the rhythmicity metrices for the text (usually, the Ukrainian poetic one)  https://hackage.haskell.org/package/phonetic-languages-rhythmicity-0.1.0.0 (OleksandrZhabenko)
07:41:20 * hackage futhark 0.18.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.18.1 (TroelsHenriksen)
07:50:49 * hackage phonetic-languages-rhythmicity 0.1.0.1 - Allows to estimate the rhythmicity metrices for the text (usually, the Ukrainian poetic one)  https://hackage.haskell.org/package/phonetic-languages-rhythmicity-0.1.0.1 (OleksandrZhabenko)
07:54:19 * hackage derive-topdown 0.0.2.2 - Help Haskellers derive class instances for composited data types.  https://hackage.haskell.org/package/derive-topdown-0.0.2.2 (songzh)
08:00:49 * hackage uniqueness-periods-vector-properties 0.4.0.0 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.4.0.0 (OleksandrZhabenko)
08:02:29 <dminuoso> ghc: panic! (the 'impossible' happened) (GHC version 8.10.1:Loading temp shared object failed: /run/user/1000/ghc16141_0/libghc_5.so: undefined symbol: crypt
08:02:31 <dminuoso> Bingo!
08:03:05 <dminuoso> Ah, wrong channel
08:11:49 * hackage uniqueness-periods-vector-properties 0.4.0.1 - Metrices for the maximum element for the uniqueness-periods-vector packages family.  https://hackage.haskell.org/package/uniqueness-periods-vector-properties-0.4.0.1 (OleksandrZhabenko)
08:27:23 <tomsmeding> 'impossible'
08:28:52 <dminuoso> Yeah.. Im really staring at the weirdest wall ever.
08:29:35 <dminuoso> https://gist.github.com/dminuoso/0932484d82167ffad98baaf3348f5126
08:29:41 <dminuoso> This is enough to completely bug out GHC :S
08:29:51 <dminuoso> On some strange linker errors on a completely unrelated library
08:30:27 <Cheery> When I paste stuff into slack or discourse, it summarizes the link for me. I'd love to have that in my blog as well.
08:31:07 <sshine> I'm sure there's a javascript for it.
08:31:38 <dminuoso> Im fairly sure that both slack and discourse use some "standard" library js library too.
08:33:17 <monochrom> @quote autrijus impossible
08:33:17 <lambdabot> autrijus says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
08:39:09 <Cheery> :D I saw somebody has written a summarizer in haskell.
08:39:22 <Cheery> https://github.com/amliby/summary
08:39:26 <tomsmeding> dminuoso: well at least you have a nice, small test case :)
08:40:42 <siraben> Does anyone know if Emacs' `lsp-haskell` package has support for case splitting yet?
08:40:54 <siraben> It's been added in haskell-language-server 0.5.0.0
08:40:59 <Cheery> I'm too old to write a html parser myself when I need one. Not youthful enough to read a spec.
08:41:37 <Cheery> I'm glad I found a good HTML5 parser though.
08:50:23 <siraben> Ok so it looks like I have to do `s-l a a` to show the list of actions
08:50:31 <siraben> Holy hell, this is insane, like Agda-style holes.
08:53:24 <dminuoso> tomsmeding: One that makes absolute no sense.
08:53:36 <tomsmeding> those are the best
08:53:43 <dminuoso> What does quasiquoters have to do with linking completely unrelated external libraries...
08:53:47 <dminuoso> Im smelling some memory corruption here.
08:53:52 <tomsmeding> ooooooooh
08:53:53 <dminuoso> Or some internal corruption
08:54:07 <tomsmeding> I've always known that TH is trouble
08:54:19 <dminuoso> well, QQ are much more harmless.
08:54:34 <dminuoso> In fact, the splice is just an Exp splice..
08:54:44 <dminuoso> It doesn't get more harmless than that. :(
08:54:49 <tomsmeding> claim :)
08:54:54 <tomsmeding> apparently
08:55:01 <dminuoso> Well who knows
08:55:11 <dminuoso> Perhaps this is just some unrelated bug that my code shuffling manifests.
08:55:27 <dminuoso> Ill have to do a bisect on ghc
08:55:43 <monochrom> yikes
08:56:27 <dminuoso> In fact, if you looked at the QQ, it's like a totally trivial 3 lines QQ...
08:56:34 <monochrom> maybe also reproduce it on another computer, just to be sure you don't have a RAM problem
08:56:51 <dminuoso> Well I have 16GiB of ram. This module is very harmless otherwise
08:57:05 <monochrom> I mean faulty RAM
08:57:17 <dminuoso> Well, this triggers *very* consistently with the diff applied...
08:57:21 <dminuoso> by very I mean 100%
08:57:42 <leungbk> Would anyone mind helping me make this more memory-efficient and idiomatic? https://paste.debian.net/1166370
08:58:08 <leungbk> I tried running my solution in a practice coding competition but the automated judge said it used too much memory.
08:58:17 <dminuoso> leungbk: run with `+RTS p -RTS` and include the output
09:00:19 * hackage HaTeX 3.22.3.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.22.3.0 (DanielDiaz)
09:01:05 <leungbk> dminuoso: I'm not entirely sure how to execute it locally. Whenever I compile with `ghc dijkstra.hs` and `ghc -o a.out dijkstra.o`, I get errors like `error: undefined reference to 'containerszm0zi6zi2zi1_DataziSetziInternal_minView`
09:01:23 <leungbk> Which is weird since `containers` is built in to ghc 8.8.4
09:03:38 <c_wraith> skip the second line.  ghc builds the binary as its output unless you ask it to do otherwise, and has for like 10 years now
09:07:44 <leungbk> Sorry, my irc client died just now and didn't save the chat log; would someone mind reposting the `+RTS -p ...` bit from a few mins ago?
09:08:05 <monochrom> <dminuoso> leungbk: run with `+RTS p -RTS` and include the output
09:08:15 <c_wraith> for compiling locally, just use `ghc dijkstra.hs`
09:08:28 <c_wraith> it compiles and links in a single invocation
09:10:13 <c_wraith> anyway, it's very probable there's a space leak in the foldl' starting on line 18.
09:10:54 <dminuoso> Keep in mind you'll have to compile the program and dependencies with profiling
09:11:02 <dminuoso> So it's probably best to quickly wrap that into a cabal project
09:11:16 <c_wraith> all the foldl' is doing is making sure the tuple is evaluated.  That's probably not what you meant.
09:11:49 <leungbk> dminuoso: So, `./dijkstra +RTS p -RTS`? The executable says `dijkstra: unexpected RTS argument: p`.
09:12:05 <c_wraith> you need to add -rtsopts to the flags when compiling
09:12:21 <leungbk> This is simply a standalone file for a practice coding competition.
09:13:54 <leungbk> c_wraith: I think that's what I meant? I wanted the tuple to be evaled since I needed to construct an updated distance/predecessor/set to use for the next call of `loop`
09:14:32 <c_wraith> you want *the components* of the tuple to be evaluated.
09:14:44 <c_wraith> You're telling it to stop after it gets the (,,) constructor
09:16:30 <monochrom> TIL: cabal repl sets the environment variable HASKELL_DIST_DIR to e.g. /home/trebla/tmp/quv/dist-newstyle/build/x86_64-linux/ghc-8.8.4/quv-0.1.0.0/x/quv
09:16:59 <leungbk> I'm confused. How would I evaluate the components of the tuple without doing something like a simultaneous fold of the tuple's components?
09:17:22 <c_wraith> leungbk: in particular, nothing in the loop causes the second or third elements of the tuple to be evaluated during the loop.
09:17:51 <Cale> leungbk: Either pattern matching on them, or using seq would do it.
09:17:59 <monochrom> I was kind of looking for that because if you use --builddir=foo then it will be s/dist-newstyle/foo/ and I was wondering if I wrote my own tool how would I know that.
09:18:16 <c_wraith> So both of those elements are chains of thunks that refer to the entire history of Set/Map insert calls
09:19:06 <leungbk> c_wraith: So strict-eval would solve the memory issue? That's unexpected to me since Set and IntMap.strict are evaluated strictly afaiu.
09:19:49 * hackage reflex-dom-pandoc 0.6.0.0 - Render Pandoc documents to HTML using reflex-dom  https://hackage.haskell.org/package/reflex-dom-pandoc-0.6.0.0 (sridca)
09:19:50 <c_wraith> The easiest fix is turning on the BangPatterns extension and modifying the lambda to look at (!oldDistances, !oldTree, !oldPredecessors)
09:21:08 <c_wraith> leungbk: that means *when they are forced to be evaluated* that they will be evaluated "fully" (to within the requirements of the type.  Set only evaluates as much as necessary to balance the tree, Map only evaluates the keys as much as necessary to balance the tree and the values to WHNF)
09:21:13 <monochrom> The example I shown was from an exe-only package. I wonder if it's different for a lib package, or I guess more precisely a lib target "cabal repl exe:..." vs "cabal repl lib:..."
09:21:58 <c_wraith> leungbk: but your loop never does anything to cause oldTree or oldPredecessors to be evaluated at all.
09:22:04 <monochrom> c_wraith: Good eyes, I missed that.
09:22:34 <c_wraith> leungbk: all it does with them is throw them into a thunk behind the (,,) constructor
09:23:32 <c_wraith> leungbk: and so when foldl' forces the state to WHNF for the next iteration, the (,,) constructor is evaluated, but no further.
09:24:00 <c_wraith> monochrom: It's the first thing I look for when someone asks about too much memory use :)
09:25:28 <monochrom> I looked for that too, but failed.
09:25:48 <leungbk> c_wraith: Thanks a lot, I think I'm getting a better sense of the issue. I'll need to investigate more on my own.
09:26:05 <monochrom> I stopped after I checked that "nextDist = du + weight" is kosher because "nextDist < ..." happened right away.
09:35:53 <troydm> what's easies way to strip .0 from number?
09:36:26 <troydm> like I have Double, and I want to print it without leading .0
09:41:49 <[exa]> troydm: can you throw a few examples?
09:42:11 <[exa]> 'stripping .0' sounds like 'round' or 'truncate' but no idea if that's precisely what you wanted
09:42:23 <troydm> [exa]: nvm, figured it out
09:42:33 <[exa]> uh ok
09:43:11 <geekosaur> sounds like they discovered printf %g appending ".0" and wanting it not to
09:43:21 <geekosaur> or show
09:45:35 <Clint> people use %g?
09:45:55 <geekosaur> someone asked abou it the other day in here
09:46:42 <Clint> hmm
09:47:11 <geekosaur> of course, there's also "people use printf?" but there's no accounting for taste
09:47:33 <geekosaur> but I think showGFloat has the same behavior
09:49:23 <maralorn> Does anyone know of a Code formater that preserves or even introduces { ; } for all layout blocks?
09:50:20 <geekosaur> does SPJ count?
09:51:01 <c_wraith> he's not very automatic
09:57:07 <maralorn> Who?
09:58:21 <ski> SPJ
10:01:09 <monochrom> haha
10:02:10 <monochrom> I think the real objection is economical. SPJ is too expensive to hire for code formatting.
10:02:42 <maerwald> wow, that would be a boss move...
10:02:56 <maerwald> "what's your code formatter?" - "SPJ"
10:03:01 <dolio> I would never let SPJ format my code.
10:03:03 <monochrom> hehe
10:03:12 <dolio> He uses all kinds of braces and semicolons.
10:03:30 <monochrom> That's exactly what maralorn was looking for.
10:03:42 <maerwald> a man with taste
10:04:06 <monochrom> I used to do that. But only to make an old emacs haskell-mode indenter happy.
10:04:09 <dolio> Oh, I see. :)
10:04:34 <monochrom> But it's really old, today's version works much better now, no need to help it with SPJ format.
10:05:18 <maralorn> Wait, are you telling me he's the only one who likes that code style?
10:05:27 <maralorn> I admit I think ghc and #haskell-onliners are the only two places I have ever seen them used.^^
10:05:28 <Habib> why does cabal v2-install work the first time i install a package then fail subsequent times until i clear the store and the environment file?
10:05:33 <Habib> https://pastebin.com/raw/HB6R1fdw
10:05:36 <Cale> The GHC source code is like a Haskell style guide in the form of a cautionary tale
10:06:31 <dolio> SPJ is the only one I know of. It's possible some of the other original folks like it.
10:06:39 <maerwald> Habib: because env files are awful and no one uses them
10:06:39 <maralorn> You know, that conversation only made me want that feature so much more.
10:06:47 <Cale> I think Richard likes it as well
10:07:13 <Cale> But moreso, the thing I really can't stand is all the incomprehensibly abbreviated names
10:07:51 <maralorn> So, what formatter do you people recommend should I make "Add --spj flag" PR against?
10:08:06 <Habib> maerwald: but cabal uses a default environment file, anyway
10:08:17 <maralorn> Cale: That's true. Those are offensive.
10:08:32 <Habib> if i didn't specify the environment, it'd just mean it affects my default environment file
10:09:12 <dolio> Richard's a new kid, though. :)
10:09:17 <ghoulguy> Habib: What version of cabal-install are you asking about?
10:09:34 <Habib> i'm trying to install some packages to a separate store for strictly ghci use, so i can create some nice helper functions in ghci, then remove them from scope completely and even hide the packages/package-db after i'm done so they don't conflict with my usual package db
10:09:43 <Habib> cabal-install 3.2.0.0
10:09:54 <Habib> sorry, my bad, 3.4.0.0
10:10:30 <monochrom> I think I don't have this problem with 3.2
10:11:03 <dolio> Did Miranda have a non-layout syntax that served as the target for layout? I was kind of wondering if SPJ is the only reason Haskell does.
10:11:36 <Habib> i want to run a :!cabal v2-install --options-for-separate-store packages... at the start of my ghci, so i can always have the right dependencies, use them, then hide them once the helper functions have been defined
10:13:36 <maralorn> otoh, naming variables is one of the three great challenges of programming. so having any policy for it is much more important, than which policy.
10:15:13 <Habib> i think i installed 3.4.0.0 to get access to the 3.4.0.0 format version so i didn't have to specify default-language in my cabal file (it's optional in later version), but ended up deciding i want the default-language explicit anyway, so i guess i could downgrade and try again
10:15:22 <Habib> 3.4.0.0 is in rc stage anyway
10:18:35 <Habib> hmm‚Ä¶ 3.2.0.0 behaves the same
10:20:05 <monochrom> Then again I didn't try for packages like process that already come with GHC. I only tried like hmatrix and vector and random.
10:21:59 <Habib> monochrom: when you say process comes with ghc, do you mean as part of the haskell platform?
10:22:17 <Habib> because i can't import it without installing it
10:22:36 <monochrom> "comes with haskell platform" is true but much weaker than "comes with GHC"
10:22:50 * hackage commander-cli 0.10.1.0 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.10.1.0 (sgschlesinger)
10:23:10 <Habib> i don't understand how it comes with ghc then, if i can't import it without installing it with cabal
10:23:27 <geekosaur> if you installed ghc from some OS package then it may have been split out by the packager
10:23:30 <Habib> what libraries come with ghc then?
10:23:43 <geekosaur> if you install from a tarball or ghcup then you have process and a few other libraries
10:24:07 <Habib> is there an authoritative list of libraries that come with ghc vs. the haskell platform
10:24:10 <monochrom> Everything here comes with GHC 8.10.1: https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/index.html
10:24:43 <Habib> the conflict message does seem to point to a conflict between that version of process and the version of ghc
10:25:00 <Habib> but i don't understand why it only conflicts after it's already successfully installed teh first time
10:25:42 <monochrom> Is there, really, a version of haskell platform that has/uses/whatever GHC 8.10.1 ??!!!
10:26:28 <Habib> and even then, if i install the exact version that comes with ghc 8.10.1, which is 1.6.8.2, it fails
10:26:35 <monochrom> More generally, Haskell Platform is basically an obsoleted concept. There hasn't been any update.
10:26:45 <Habib> monochrom: i don't know, i don't even know if the platform is still around
10:27:13 <monochrom> But your GHC is 8.10.1 so you are not using any kind of Haskell Platform.
10:27:20 <Habib> next question i should ask is why my bloody irc client won't even scroll automatically
10:27:41 <Habib> sorry‚Ä¶ i don't actually want to ask that
10:28:45 <Habib> anyway, regardless, process-1.6.8.2 comes with ghc 8.10.1, which is what i'm on
10:28:49 <AWizzArd> Are Snaplets something that might be called "Middleware" in other servers?
10:28:59 <Habib> yet it succeeds installation the first time, then fails any subsequent installs
10:39:29 <Habib> hmm, looks like i do have process in my default package db
10:40:10 <Habib> i just didn't know it was a default package at the time, so i wanted to ensure it was installed by cabal and that if it tried to install it and it was already installed, it wouldn't fail
10:41:38 <Habib> still, this behaviour isn't expected
10:41:59 <Habib> is System.Process part of Haskell2010?
10:42:13 <geekosaur> no
10:42:41 <geekosaur> it is part of the implementation of ghc, hence of ghc-lib which is part of ghc
10:43:29 <Habib> just checked, it isn't
10:43:50 <Habib> ack, i keep repeating what people have already said
10:44:02 <Habib> i really need to get my irc scroll checked
10:45:31 <Habib> i'm gonna try this on a clean environment with a non-bundled library like aeson
10:47:50 * hackage commander-cli 0.10.1.1 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.10.1.1 (sgschlesinger)
10:52:22 <Habib> hmm, aeson just says ‚ÄúUp to date‚Äù when installing it and it's already there. something weird going on with process, perhaps due to being a bundled library already
10:57:57 <sbp> anybody know if Chris Penner hangs around here?
11:17:06 <dsal> I've seen him now and then.
11:24:40 <snyp> "StateT Maybe a" vs "MaybeT State a" - don't you have to read the implementation to see how they're different?
11:26:37 <geekosaur> no? you know that if the outer MaybeT fails you lose the State inside, whereas if reversed you keep the state, because it's outside
11:28:18 <sbp> dsal: ah. under what nickname?
11:29:09 <lyxia> sbp: he's on slack (functionalprogramming) under his own name.
11:30:26 <snyp> geekosaur: Does "MaybeT State a" ever make sense to use?
11:30:48 <geekosaur> if the state is irrelevant in case of failure, yes
11:34:32 <AWizzArd> Can I use the unicode char `Œº` in data constructors?  I.e.  data TimeUnit = NS | Œºs | MS | S
11:34:54 <geekosaur> it's a letter character, so yes
11:34:59 <ski> > isUpper 'Œº'
11:35:02 <lambdabot>  False
11:35:12 <geekosaur> oh, good point
11:35:14 <PerryThePlatypus> Hey, I wanted to improve my Haskell skillz. I wanted to try LeetCode but unfortunately they do not support Haskell. Any alternatives in mind? I don't need online IDE. 
11:35:18 <geekosaur> has to be uppercase
11:35:57 <AWizzArd> Okay.
11:36:09 <ski> @unmtl StateT s (MaybeT m) a
11:36:09 <lambdabot> s -> m (Maybe (a, s))
11:36:10 <ski> @unmtl MaybeT (StateT s m) a
11:36:11 <lambdabot> s -> m (Maybe a, s)
11:36:13 <ski> snyp ^
11:36:39 <geekosaur> hm
11:37:48 <AWizzArd> > isUpper 'Œú'
11:37:50 <lambdabot>  True
11:38:07 <AWizzArd> > (isUpper 'Œú', 'Œú' == 'M')
11:38:09 <lambdabot>  (True,False)
11:41:37 <ski> > map isUpper "¬µ„é≤ùúá"
11:41:39 <lambdabot>  [False,False,False]
11:43:24 <snyp> @unmtl StateT s (Maybe a)
11:43:24 <lambdabot> err: `StateT s (Maybe a)' is not applied to enough arguments, giving `/\A. s -> Maybe a (A, s)'
11:44:20 <ski> drop the brackets
11:48:50 <sm[m]> @freenode_PerryThePlatypus:matrix.org: exercism, project Euler, code.world
11:48:50 <lambdabot> Unknown command, try @list
11:52:31 * ski looks at sm[m]
11:55:25 * tomsmeding carefully notes that the intended recipient of that message had already left the chat
12:14:04 <sm[m]> urggggh did it again. Apologies. Well maybe someone else cares
12:15:23 <int-e> > (2^^(-1074), (2^^(-537))^2) -- meh.
12:15:26 <lambdabot>  (0.0,5.0e-324)
12:16:25 <geekosaur> have some floating point
12:17:01 <int-e> I guess a ^^ b does 1/(a^(-b)) for negative b, not (1/a)^(-b)
12:17:29 <int-e> > (1/2^1074, (1/2)^1074)
12:17:32 <lambdabot>  (0.0,5.0e-324)
12:24:09 <int-e> (but neither implementation is strictly better than the other, so best to accept the behavior as it is)
12:26:19 * hackage hakyll-alectryon 0.1.1.0 - Hakyll extension for rendering Coq code using Alectryon  https://hackage.haskell.org/package/hakyll-alectryon-0.1.1.0 (lyxia)
12:27:05 <proofofme> Hello.  How do I print this data type to the console?       Maybe [String]
12:27:24 <phadej> print
12:28:11 <proofofme> No instance for (Show (IO (Maybe [String])))
12:28:11 <proofofme>         arising from a use of ‚Äòprint‚Äô
12:28:42 <phadej> do { x <- thatIOAction; print x }
12:29:32 <proofofme> Yes!!!  Thank you phadej
12:36:26 <leungbk> Why does valgrind report an 80-byte leak for a hello-world.hs file with `main = print "hello"` compiled with `ghc hello.hs`? Are there other compilation flags I need to give ghc?
12:38:16 <ski> proofofme : also `print =<< thatIOAction'
12:39:02 <tomsmeding> (not sure if it's good to give beginners =<< instead of the standard >>=)
12:39:04 <monochrom> valgrind is the wrong tool for GHC-generated executables.
12:39:47 <proofofme> ski, that worked as well!  How should I use the standard binding operator instead, tomsmeding?
12:39:58 <tomsmeding> proofofme: thatIOAction >>= print
12:39:59 <tomsmeding> :p
12:40:04 <tomsmeding> it's the same thing, but with the arguments flipped
12:40:05 <ski> you can say .. what tomsmeding said, as well
12:40:07 <ski> yes
12:40:21 <ski> sometimes the ordering for `=<<' reads more nicely
12:40:22 <proofofme> ah! I see
12:40:26 <ski> (also `<=<')
12:40:33 <proofofme> is <=< different?
12:40:37 <ski> yes
12:40:40 <tomsmeding> and >=> and all the plethora of operators that exist
12:40:56 <ski> `<=<' composes two "monadic functions"
12:40:57 <tomsmeding> it's not productive to get lost in the swamp of operators at first I think :)
12:41:02 <tomsmeding> and I think monochrom will agree
12:41:36 <tomsmeding> since >>= is the core operator from the Monad class; =<< is (trivially) defined in terms of >>=
12:41:50 <ski> proofofme : but when you're starting, i think it's good to focus on `do'-notation and `return'/`pure', and then learn how the former maps to `>>=' and `>>' (or perhaps learn about them, before `do')
12:42:29 <tomsmeding> I guess depending on your prior programming experience, or general exposure to mathematics :p
12:42:51 <proofofme>  I've been studying category theory (I'm like 70% of the way through the standard curriculum) and reading some articles.  I'm building a very small scraper script to get more familiar
12:43:28 <tomsmeding> I say understand >>= first, then understand how do-notation is expressed in terms of it :p
12:43:41 <monochrom> If you're from category theory, then you already know join, and you just need "m >>= k = join (fmap f m)"
12:44:11 <monochrom> well, you know join under a Greek name. But it's:
12:44:15 <monochrom> @type join
12:44:17 <lambdabot> Monad m => m (m a) -> m a
12:44:35 <proofofme> hmmm
12:45:58 <monochrom> You probably also already know Kleisli arrows. In that case, that's >=>.
12:46:35 <monochrom> or rather, >=> is the arrow composition for Kleisli arrows.
12:46:36 <sbp> lyxia: thanks
12:46:52 <proofofme> Interesting
12:50:50 * ski idly wonders what CT concepts proofofme's covered
12:51:17 <proofofme> I lightly understand what you said above and made a list to refamiliarize myself
12:52:24 <proofofme> I've watched up to Chapter 7 in Bartosz Milewski's Category Theory playlist
12:52:57 <proofofme> So "a monad is simply a monoid in the category of endofunctors" makes full sense to me now :)
12:53:56 <proofofme> I've also been learning abstract algebra and some number theory.  I am no expert by any means though. 
12:54:33 <monochrom> err typo.  m >>= k = join (fmap k m)
13:02:19 * hackage neuron 1.0.0.0 - Future-proof system for plain-text notes.  https://hackage.haskell.org/package/neuron-1.0.0.0 (sridca)
13:03:49 * hackage lorentz 0.6.2 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.6.2 (gromak)
14:57:28 <dolio> (=<<) is good because it shows how homomorphisms of free algebras `m a -> m b` arise from maps `a -> m b`.
15:01:43 <dolio> Of course, that only depends on `m a` being a free algebra. If you situate it in the category of all algebras, it's `(a -> r) -> m a -> r`, presuming `r` is an algebra.
15:04:58 <dminuoso> proofofme: Now to the next step. An applicative is simply a monoid in the category of endofunctors as well!
15:05:39 <dminuoso> But that category is equipped with a different tensor. In case of Monad it's endofunctor composition, and in case of Applicative it's Day convolution. :)
15:06:03 * monochrom cries
15:06:08 <dolio> In that case it doesn't need to be an endofunctor, though.
15:07:56 <proofofme> interesting!  I am referencing all this stuff right now
15:08:44 <monochrom> I now agree with St. Augustine that you math nerds are pure evil. :)
15:09:32 <hpc> we should make like pythagoras and throw them overboard
15:09:39 <monochrom> Programmers work very hard to code up things, then a math nerd comes along to point out that "it's just a special case of this conceptually simple thing"
15:09:41 <dminuoso> proofofme: As a fun excercise, try to think of other tensors and see whether you discover more such monoids.
15:10:08 <dminuoso> There's at least three more tensors that yield interesting results. 
15:10:44 <monochrom> One time I was TAing in a computer graphics course. In terms of coding up ray tracing for example, intersection test for a ray with a sphere is very different from intersection test for a ray with a cube.
15:11:17 <dminuoso> tomsmeding: I managed a testcase btw: https://gitlab.haskell.org/ghc/ghc/-/issues/18822
15:11:38 <monochrom> Then a math prof friend visited the graphics prof, we brought up that, and the math prof friend pointed out "but a cube is just a sphere under a different norm".
15:12:15 <dolio> Maybe programmers should have looked at what math people were doing decades before, so they wouldn't have to reinvent it.
15:12:36 <dminuoso> dolio: Heh. Or even at what programmers were doing decades before!
15:12:47 <dminuoso> Im looking at you, mongodb developers.
15:12:57 <dolio> Yeah, that too.
15:13:45 <monochrom> I am sympathetic to them, though in disagreement, because as a consequence of the victors writing history, the nosql people never knew that historically databases started out as nosql.
15:14:34 <dminuoso> There's an influx of new programmers, completely oblivious about POSIX, relational algebra, interesting languages...
15:14:57 <monochrom> If you tell them the old name "network database" they will totally misunderstand you because they don't know that "network" simply meant pointers back then.
15:15:20 <monochrom> (They will think you mean, like, cloud.)
15:15:21 <dminuoso> monochrom: If I stare at some of the early steps of MongoDB they are not just repeating it, but repeating it poorly. MongoDB will crash if you use more than 2GiB in your database on a 32 bit architecture.
15:15:22 <dolio> If you squint at the 'algebra' thing above, you see that Lawvere invented CPS for algebra 12 years before Steele and Sussman. :)
15:15:33 <dminuoso> I mean, for a database that's saying quite a lot.
15:15:42 <dminuoso> Or the complete lack of any properties of ACID early on
15:16:08 <dminuoso> It seemed to have been a "Lets see how hard a database can be, if we dont do any reading and just start writing"
15:19:10 <maralorn> dolio: I say this as a mathematician. Normally people (like physicists, programmers) invent something and then after a few decads mathematicians are like "well what you did is btw. this really simple concept, that we invented motivated by what you did"
15:20:11 <monochrom> And while we're at it... I wish I could write "C because (because A, so B)" up there for that sentence that I ended up wording "C because as a consequence of A, B".
15:20:56 <monochrom> So the logical structure of what I was saying is: (A therefore B) therefore C. Marvel at the CPS structure! >:)
15:22:00 <dolio> maralorn: If I were talking to mathematicians I'd be playing the opposite side. :)
15:22:20 <maralorn> ^^
15:22:49 <dolio> They just stole our Martin-l√∂f type theory.
15:23:01 <maralorn> It's not always like that. But in general I think both sides deserve a lot of credit. And in a world where people  tend to idolize abstractness, rigor and brute intelligence. I try to nudge the world view into the direction of valuing intuition, motivation and experience.
15:23:02 <monochrom> heh
15:24:44 <monochrom> That is a minority world from what I saw.
15:25:13 <monochrom> The majority world idolize intuition, experience, and after-the-fact rationalization instead.
15:25:22 <monochrom> Just look at politics.
15:26:34 <dolio> I mean, it wasn't long ago that I was talking in here about how mathematicians are all wrong when they tell physicists they 'aren't allowed to do' various stuff with derivatives because it doesn't work in classical analysis or whatever.
15:27:08 <dolio> Because they went off and studied something different than what physicists are actually doing, but decided the math was the real thing.
15:30:50 <proofofme> So let's say that I have a field of type `Maybe [String]` and want to compare it to elements from input of type [String], and return the index of the first match, if it exists.  Would I use mapM_ to accomplish this?
15:32:43 <monochrom> No. More like fmap.
15:33:19 <monochrom> What does "compare" mean to compare Nothing against ["hello", "hi"] ?
15:34:55 <proofofme> Just ["hello", "hi"], yeah?
15:35:00 <proofofme> is that what you mean?
15:35:11 <dminuoso> So, just out of curiosity proofofme
15:35:16 <monochrom> No. You wrote "compare Maybe [String] to [String]".
15:35:27 <dminuoso> You dabble in non-trivial category theory but seem to be stuck in the beginning steps of Haskell.
15:35:33 <dminuoso> What's your motivation behind learning CT?
15:35:39 <monochrom> So I compare Nothing :: Maybe [String] to ["hello", "hi"] :: [String]
15:35:53 <maralorn> I read up on the Monads are Monoids in the category of Endofunctors thing. A few years ago I was like "A now I get it.". Now I feel that's like saying "a bycicle is just two wheels with pedals."  It's not really wrong but it's a really bad definition and I can think of contraptions that fit the name, that don‚Äòt match at all.
15:36:51 <proofofme> My main motivation is personal fulfillment in learning this stuff, but also applying it professionally to write better code, whether it's Haskell or whatever else I'm using.
15:37:32 <proofofme> I'm really new at non-trivial Haskell
15:37:41 <proofofme> or less-trivial Haskell, I should say
15:37:53 <dminuoso> proofofme: My personal recommendation, stay clear of Category Theory then.
15:38:07 <proofofme> why's that?
15:38:12 <koz_> maralorn: This. I especially feel that a lot of people (especially learners) fixate too much on what a monad _is_, and less on 'why we care in the first place'.
15:38:29 <dminuoso> Unless you do this out of personal enjoyment for CT itself, CT has very little bang for bucks in terms of programming.
15:38:50 <proofofme> I want to learn CT, abstract algebra, and number theory for my own sake
15:38:50 <maralorn> koz_: That also.
15:39:03 <dminuoso> While some of the really advanced folks can use it in some particular situations, I dont think one can appreciate even half the stuff unless you happen to be well versed in multiple fields of maths already
15:39:24 <dminuoso> proofofme: In that case, dont mind me!
15:39:33 <dminuoso> Just wanted to make sure you didn't fall into the trap I (and many others) did. :)
15:39:50 <maralorn> koz_: But unless someone can enlighten me in the error of my ways. It now feels like that is not even something a mathematician would say.
15:40:04 <dminuoso> Because I learned category theory for the sake of having an easier entry into Haskell. Turned out, I understood the joke `a monad is just..`, went to Haskell, and didn't even understand how to use IO at all.
15:40:07 <dminuoso> (True story)
15:40:20 <dolio> What isn't?
15:40:31 <proofofme> haha I feel that
15:41:01 <maralorn> dolio: "Monads are Monoids in the category of Endofunctors"
15:41:48 <dolio> maralorn: It's a one-off sentence in Categories for the Working Mathematician, I think.
15:42:08 <maralorn> Hm
15:42:15 <dolio> And for some reason gets quoted all over.
15:42:39 <maralorn> But what does "A Monoid in the category C" even mean?
15:42:59 <dolio> I think it's quoted somewhere by Wadler, maybe, and that's why it's popular amongst programmers.
15:43:19 <dminuoso> maralorn: A monoid (or monoid object) (M, Œº, Œ∑) in a monoidal category (C, ‚äó, I) is an object M together with two morphisms
15:43:31 <dminuoso> (I ruthlessly copy pasted it, but I would have said the same thing myself
15:43:50 <dminuoso> (well followed by blahblablah(
15:43:53 <maralorn> Ah, okay. Fair enough.
15:44:02 <dolio> In MacLaine I think it comes at the end of explaining how it works.
15:44:45 <dolio> And for Wadler it's a joke that doesn't actually explain anything.
15:45:13 <monochrom> The real numbers are just the complete Archimedian ordered field. >:)
15:45:14 <maralorn> Then the Wikipedia article is just exceptionally bad at making that point. It even has a [Citation needed] next to the claim ‚Ä¶
15:46:15 <maralorn> monochrom: Well that is how we defined them in my first semester, so I am okay with that.
15:46:17 <dminuoso> maralorn, dolio: According to stackoverflow, the particular joking phrasing is actually from: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
15:46:29 <dminuoso> (With a fictional attribution to Wadler)
15:47:07 <dolio> Oh, okay.
15:47:07 <dminuoso> And I think that joke is what got it popular, but the joke is sometimes lost
15:47:18 <monochrom> Any sufficiently insider joke is indistinguishable from sufficiently advanced knowledge.
15:47:26 <dminuoso> monochrom: Haha true.
15:48:45 <maralorn> That page doesn‚Äòt load for me. :-(
15:49:44 <monochrom> Learning monads is not easy. After successfully learning something challenging, people make jokes for relief. I'm sure this happens in every profession. I'm sure similar nerdy jokes are among accountants, lawyers, medical doctors, everything.
15:50:39 <dolio> It seems like the irony of this discussion is that it's not really mathematicians saying it. It's programmers.
15:50:46 <monochrom> But when such insider jokes leak out, they sound like words of deep wisdom to beginners, and beginners misbelieve that they must understand them rather than just go "haha" and take it easy.
15:50:51 <maralorn> Yeah, there is an evolution of jokes about different math jokes which funnieness depends on your own skilllevel.
15:51:05 <maralorn> First you don‚Äòt even get it's a math joke and it's not funny.
15:51:26 <dminuoso> I mean to be fair, the core essence of "a monad is just..." is very valuable and ever present in my head.
15:51:36 <dminuoso> But it's not the category theory definition that I think about
15:51:43 <maralorn> Later you know enough math, to understand it's a joke, but you don‚Äòt know why, so you laugh with the others.
15:51:58 <dminuoso> I rather have a visual/mental model of: https://gist.github.com/dminuoso/d5ab4ba5d8a5142dde9f4d4c736e3ecb 
15:52:17 <maralorn> Then you       know barely enough math to understand the joke and you find it hilarious.
15:52:35 <dminuoso> Just to address your comment about "this is not even something a mathematician would say"
15:53:40 <maralorn> And some years later the knowledge required seems so basic, that you maybe laugh a little.
15:54:32 <monochrom> So, like that one on smbc?
15:54:41 <maralorn> dminuoso: Well I was wrong about that. Apparently that sentence has a very precise meaning if you know monoidal categories and a generelized definition of monoid.
15:55:01 <monochrom> "Did you know that every sum of two primes is greater than 2"
15:55:05 <dolio> It's hard to believe I hadn't heard that quip before 2009, though.
15:55:17 <dminuoso> maralorn: I like Saunders Mac Lanes definition more, but I'd rephrase it into:
15:55:39 <dminuoso> A monad is a monoid in a monoidal category equipped with endofunctor composition as its tensor.
15:55:48 <dminuoso> Err
15:56:00 <dminuoso> A monad is a monoid in the monoidal category of endofunctors equipped with endofunctor composition as its tensor.
15:56:16 <dolio> I'm going to guess it was only written down somewhere permanent in 2009.
15:56:26 <dminuoso> But really, this is neither the conclusion of some large chunk of text, nor is it a particularly funny joke
15:56:34 <dminuoso> So it's pretty valueless
15:57:16 <heebo> if im using ghcup , hie , haskell language server: whats the best build tool to use , stack or cabal?
15:57:22 <dminuoso> As programmers, I think the kleisli category route to think of programmers is a bit more natural to think of.
15:57:27 <hpc> the slightly funnier version goes something like "a monad is a monad in the 2-category of categories"
15:57:29 <monochrom> cabal
15:57:57 <maralorn> dminuoso: Yeah, that gist makes it very clear. I also think for definition I prefer join over bind.
15:58:50 <dminuoso> I think bind is better to think of.
15:59:07 <dminuoso> Then you can think of (<=<) as the principle operation of monads
15:59:14 <dminuoso> You get some pretty elegant laws with that
15:59:31 <monochrom> I like them both. Both have helped me greatly.
15:59:36 <dminuoso> Assoc: f <=< (g <=< h) = (f <=< g) <=< h
15:59:47 <dminuoso> Identity: f <=< return = return <=< f = f
15:59:56 <maralorn> heebo: Note a) hie is deprecated in favor of haskell-language-server and b) the choice of your build tool is largely orthogonal to the rest of the setup. But c) yeah, I'd also say, cabal.
16:00:19 <dminuoso> (All these definitions are of course equivalent)
16:00:38 <heebo> thanks, just getting back into things. ill remove my hie setup in favour of hie
16:00:38 <monochrom> Oh, my consideration is simply "if you use stack, you would not be with ghcup in the first place"
16:00:51 <heebo> er haskell -language server i mean
16:01:03 <maralorn> Well that is the monoid Wikipedia claims makes a monad a monoid ‚Ä¶
16:01:31 <heebo> monochrom: i only used ghcup because its the easiest way to install hls
16:01:31 <dminuoso> maralorn: At the very core, monads and monoids are deeply related :)
16:01:40 <dminuoso> nclatlab has a slightly different take again
16:01:41 <monochrom> Ah
16:02:06 <dminuoso> As a handwaving idea: A monad is a structure that is a lot like a monoid, but that lives in a bicategory rather than a monoidal category. In other words, the concept of a monad is a vertical categorification of that of a monoid.
16:02:37 <dminuoso> Which connects to hpc's joke earlier
16:02:40 <heebo> but i'll get back into cabal i always felt a little uncomfortable with the fact that stack sits on top of cabal and you end up having to maintain cabal files even with a stack setup
16:03:03 <phadej> cabal-install /= Cabal
16:03:09 <phadej> there is no "cabal" (lowercase ;)
16:03:29 <monochrom> We mean cabal-install.
16:03:45 <phadej> stack doesn't sit on top of cabal-install
16:03:50 <dminuoso> maralorn: My largest revelation was to see how Applicative and Monad were related. How Monad has a very deep sense of "sequencing" in all its definitions (in a very handwaving sense), while Applicative has a sort of "diamond" branching notion to it.
16:03:55 <maralorn> phadej: So are they Cabal-files or cabal-install-files?^^
16:04:02 <phadej> maralorn: Cabal-files
16:04:17 <dminuoso> It made me realize how the Applicative superclass constraint of Monad feels somewhat wrong, because it suggests a relationship that feels more accidental 
16:04:20 <monochrom> The confusion comes from the executable name "cabal".
16:04:41 <phadej> it would be very painful if we had two (or more!) non-interoptible package specification formats
16:05:28 <dolio> dminuoso: But do you know that arrows are also related?
16:05:39 <dminuoso> dolio: What do you mean?
16:06:08 <maralorn> dminuoso: I have seen one or two talks about how you can not introspect a Monad, because in a bind anything can happen.
16:06:09 <phadej> dminuoso: it is "accidental", but also always true in the *specific category* of Haskell
16:06:12 <phadej> types
16:06:49 <dolio> dminuoso: Arrows are monoids with respect to profunctor composition (plus an extra thing).
16:07:07 <dminuoso> dolio: Arrow is the one abstraction I've never really understood. :)
16:07:19 <dolio> https://homepages.inf.ed.ac.uk/cheunen/publications/2006/arrows/arrows.pdf
16:07:20 <maralorn> So for me Functor and Aplicative feel kinda close, whereas Monads are really heavy weight.
16:07:29 <phadej> Arrows are very ad-hoc abstraction
16:07:55 <phadej> the `arr` doesn't fit.
16:07:59 <dminuoso> maralorn: The relationship Im getting at, is that each Monad induces a trivial Applicative instance, rather than "Applicative being a sort of precursor to Monad"
16:09:06 <dminuoso> dolio: Cheers! A very brief skim suggests this should be readable with my expertise. Ill crunch that on the weekend
16:09:55 <maralorn> dminuoso: I am not sure I understand. Each Monoid induces a trivial Semigroup instance sounds to me nearly equivalent to "Semigroup being a sort of precursor to Monoid"
16:10:19 <phadej> maralorn: not true.
16:10:24 <dolio> It won't make arrows any more relevant, but it's an amusing fact.
16:10:30 <phadej> Monoid is "Semigroup + unit"
16:10:41 <phadej> but (<*>) and (>>=) are very different
16:11:08 <phadej> or liftA2 (,) and join -- if you look for more "categorical" members
16:11:11 <maralorn> Ah, okay.
16:11:29 <monochrom> What is "precursor"? Does it carry a historical view, or is it simply logical subsumption?
16:11:56 <monochrom> or something a bit different from both?
16:12:16 <maralorn> You are saying we could give a different applicative instance for a Monad, but having another semigroup for a monoid would just violate the definition.
16:12:26 <dminuoso> monochrom: Just a handwaving term
16:12:33 <phadej> maralorn: in Haskell no
16:13:45 <maralorn> phadej: Because of the choosen hierarchy and the laws to combine them?
16:13:46 <dolio> But there are other semigroup structures on various monoids. They're just not the one used in the monoid.
16:13:49 <phadej> but I think that in some category there could be Applicative-like things and Monad-like things for some functor, which aren't compatible
16:14:22 <phadej> dolio: monoid is (carrier set, <>, mempty)
16:14:36 <dminuoso> maralorn: What Im about to say requires some long thinking and building up intuition to make real sense, so take this with a grain of salt and not too literally.
16:14:36 <dolio> I know what a monoid is.
16:15:46 <phadej> there are different applicative strucures for `f` in Haskell too, ZipList and ordinary [] instance
16:16:06 <dminuoso> maralorn: Monad is somehow about `sequencing` (and I mean this more abstract than just effects). Applicative otoh is rather a diamond that branches in parallel and joins again. 
16:16:07 <phadej> but having them different won't be very good idea
16:16:37 <phadej> i.e. if Applicative weren't superclass of Monad, and Applicative [] were ZipList like
16:16:48 <maralorn> I have to say in the last few weeks I kinda got the impression, that having a monoid class was a mistake. I have observed multiple occasions where people assumed the wrong of multiple possible monoid instances for some type and got subtle bugs because of that.
16:17:06 <dminuoso> maralorn: The fact that Applicative usually carries "sequencing semantics" arises from the fact that the superclass constraint demands the Applicative instance and Monad instance be coherent. So as long as we have a Monad instance, the Applicative diamond is a sort of "go left side, and *then* to right side, and *then* join together"
16:17:31 <dminuoso> These coherence rules exist for good reasons, but they do lead to Applicative looking too much like Monad most of the time.
16:17:40 <dolio> No, Applicative is about sequencing, because it's not commutative.
16:20:01 <dminuoso> dolio: Can you elaborate?
16:20:12 <phadej> it can be commutative though :)
16:20:41 <maralorn> e.g. (<>) :: (a -> a) -> (a -> a)
16:21:01 <phadej> f <*> x  can be  (&) <$> x <*> f
16:21:55 <dolio> Monads can be commutative.
16:22:21 <phadej> you cannot really do `k` "first" in `m >>= k`
16:22:27 <phadej> there is dependency
16:22:36 <phadej> and I think that's what is dminuoso is after
16:22:49 <phadej> being too pedantic doens't help
16:23:21 <dminuoso> As a particular example, Haxl is a real-world example of how Applicatives let you explore parallel code.
16:24:34 <dolio> It is an over-generalization to say that Applicative is "about" the use case of haxl.
16:24:53 <phadej> I don't think it's too far fetched
16:25:16 <phadej> most intersting Applicative usages are exploiting the interspectability of Applicative computations
16:25:32 <phadej> haxl is very aggressive, so in a sense a good example
16:25:49 <phadej> optparse-applicative is another one, less controversial maybe
16:26:29 <dminuoso> Overall, Applicative seems very underused. Mostly, we just use the convenient interface of `ap` but with Monad semantics.
16:26:56 <dminuoso> At least for non-library writers.
16:27:44 <phadej> there aren't many non-Monad Applicatives
16:27:50 <dminuoso> It's pretty much that coherence law I referenced earlier that mostly puts Applicative into the shadows
16:27:58 <maralorn> There should be a significant difference between applicative            parsers and monodal parsers, right?
16:28:19 <maralorn> An applicative parser might be much better optimizable?
16:28:28 <phadej> maralorn: Applicative parsers is regex-applicative
16:28:32 <dolio> Anyhow, the commutative point is that Applicative allows for things where `f <*> x` is not the same as `x <**> f` (assuming I got that right). This means that there is a well-defined sequence that the operations have been combined in, even if the semantics decide that is irrelevant.
16:28:35 <dminuoso> maralorn: Better yet, parsers based on selective functors!
16:28:49 <dminuoso> (selective functors are a breed between monadic and applicative)
16:29:05 <dminuoso> With selective parsers, you get static analyzability but dynamic choices of subsequent effects. :)
16:29:24 <phadej> with observable equality (to recognise recursion) you get CFG (check Earley)
16:31:04 <dminuoso> If I can convince my employer to spend a few weeks, I'd love to make a optparse-selective. 
16:32:53 <dminuoso> dolio: I see, well, I'd rather consider that a case of "associativity" than "sequencing" in some abtract sense.
16:33:06 <dolio> I'm not even sure the characterization makes sense with Haxl, because the 'join' part is monad, right?
16:33:23 <phadej> dminuoso: what would you need selective power for there?
16:33:34 <dolio> Sequences are the primordial associative structure.
16:34:49 <dolio> Anyhow, I could maybe agree that Applicative is about sequences of things, and Monad is about nested things, and what Haxl does is take advantage that you can parallelize sequences of things.
16:35:05 <dminuoso> phadej: Oh just parsing differently depending on previous flags. Nothing too fancy really
16:35:36 <dminuoso> It was mostly just "would be nice to have this" cases.
16:37:29 <dminuoso> dolio: At the end this has become a discussion about what particular intutions/mind models we have adapted. My mind model is based on thinking of `Day` and (:.:), or (<*>) and (>>=). One comes with a sequencing of effects, data dependencies, the other does not.
16:37:43 <maralorn> Is there an applicative or selective parsing library?
16:37:58 <dminuoso> maralorn: optparse-applicative is an applicative option parsing library
16:38:06 <dminuoso> https://github.com/J-mie6/ParsleyHaskell
16:38:36 <dminuoso> Is an example of a selective parser combinator library that analyzes and optimizes your parser in TH.
16:39:30 <maralorn> I think you can‚Äòt have a lift instance for monadic parsers, is that right?
16:40:54 <maralorn> Wait that repo has no README and is not on hackage? :-(
16:41:01 <dminuoso> dolio: So what you mentioned about non-commutative applicatives, I realized my mistake. So I'd say you still have conceptual parallel branching, but the combination of results has some sequencing yes.
16:41:17 <dminuoso> But based on that, I would not go as far as saying that "sequencing is the defining characteristic of applicative"
16:41:52 <dminuoso> Consider:
16:42:16 <dolio> The whole difference between `f <*> x` and `x <**> f` in a non-commutative Applicative is that it won't in general be combining the same 'results'.
16:42:17 <dminuoso> We could think of Applicative as being desribed by `f a -> f b -> f (a, b)` as its signature method
16:42:34 <dminuoso> So yeah, there's a clear ordering in the tuple, but the core essence lies in what happens with the `f`
16:42:40 <ghoulguy> If we wanted to speculate on the defining characteristic we could start by staring at the free structure: http://hackage.haskell.org/package/free-5.1.4/docs/Control-Applicative-Free.html#t:Ap
16:43:18 <dminuoso> So `f a -> f b -> f (a, b)` suggests potential branching as opposed to linear data dependencies. static effects as opposed to dynamic effects.
16:43:24 <ghoulguy> it's a sequence of primitives
16:43:32 <ghoulguy> the branching doesn't matter because of the associative-like law
16:43:59 <ghoulguy> I'm late to to the party so you might already be past that
16:44:54 <ghoulguy> it's an ordered sequence of some primitives combined with a pure function to make all the type-indexes match up
16:45:46 <dminuoso> sure, that's just paraphrasing what dolio just said though with more elaborate terms. :)
16:45:55 <ghoulguy> oh, maybe that means dolio is right!
16:46:31 <dminuoso> Well, you are still free to interpret these in parallel
16:46:46 <dminuoso> Or you could interpret the right first, then the left..
16:47:01 <dminuoso> There's nothing about it that forces you into an effect order
16:47:18 <dminuoso> Yes, at the end you have a particular ordering in which you combine the results again
16:47:34 <dminuoso> Ap could have also been defined as
16:47:38 <dolio> If Applicatives are 'about' parallelism, why are there so many examples where you can't do them in parallel, because the order matters?
16:47:47 <dminuoso> Ap :: f a -> Ap f b -> Ap f (a, b)
16:47:57 <ghoulguy> Some applicatives allow you to work in parallel, but that's not inherent to applicatives
16:48:09 <dminuoso> dolio: Because most of the time you have a Monad instance, and then the coherence laws matter.
16:48:12 <dolio> Shouldn't those be illegal?
16:48:23 <dminuoso> And it's the coherence laws that force the Applicative to have the Monad semantics.
16:48:36 <dminuoso> And the monad itself is inherently sequenced because of that data dependency in (>>=)
16:49:04 <dminuoso> dolio: That's a bit more extreme than what I suggested, but yeah, that's the crux of it!
16:49:19 <dminuoso> They are just trivial instances induced by the monad
16:49:21 <dolio> What's the proof that there area no non-monad Applicatives where ordering matters?
16:50:07 <dminuoso> Look, I think you're taking this a bit too exact.
16:50:24 <dminuoso> % :t (<*>)
16:50:25 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
16:50:53 <dminuoso> This f has no sequencing built into its type
16:51:08 <dminuoso> And if we stare at Day we see this deeper again
16:51:11 <c_wraith> There are monads where the order doesn't matter outside of the data dependency.  Maybe, for instance.
16:51:13 <dolio> I think I used one recently, actually. It was basically state composed with writer.
16:51:13 <dminuoso> % data Day f g a where Day :: f x -> g y -> (x -> y -> a) -> Day f g a
16:51:14 <yahb> dminuoso: 
16:51:20 <ghoulguy> Monad doesn't even enforce an "effect order" which is how we get the reverse state examples
16:51:27 <dminuoso> ghoulguy: Of course they do!
16:51:29 <dminuoso> % :t (>>=)
16:51:29 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
16:51:35 <dminuoso> It's buried right into the type here.
16:51:50 <dolio> Also the one people use that collects multiple error messages.
16:51:51 <c_wraith> Reader and Identity for the trivial examples
16:51:51 <dminuoso> You cant run `m b` without having an `a` to begin with
16:52:07 <c_wraith> dminuoso: Proxy?
16:52:16 <ghoulguy> dminuoso: who said I had to "run" m a to get an a?
16:52:29 <ghoulguy> It's my m
16:52:55 <dolio> There were people a while back talking about a sub-monad of IO that could have its operations re-ordered, too.
16:53:11 <dolio> ACIO or something.
16:53:27 <c_wraith> > undefined >>= undefined :: Proxy ()
16:53:30 <lambdabot>  Proxy
16:53:57 <ghoulguy> dminuoso: I think you're making too much out of the data dependency suggested by the type of (>>=) and the lack of that same obvious data dependency in (<*>)
16:53:59 <c_wraith> no values of a, b, Proxy a, or Proxy b
16:54:09 <c_wraith> (as inputs, anyway)
16:54:19 <dminuoso> ghoulguy: Let's take another approach then.
16:54:32 <dminuoso> Can we agree that the signature method of Monad is `m :.: m ~> m` ?
16:54:52 <dminuoso> And equivalently the signature method of Applicative is: m `Day` m ~> m ?
16:55:12 <dminuoso> (Perhaps I shouldnt have used backticks in the first example, that seems mildly confusing)
16:55:43 <maralorn> :t Day
16:55:45 <lambdabot> error: Data constructor not in scope: Day
16:55:50 <dminuoso> % data Day f g a where Day :: f x -> g y -> (x -> y -> a) -> Day f g a
16:55:50 <yahb> dminuoso: 
16:55:55 <maralorn> % :t Day
16:55:56 <yahb> maralorn: f x -> g y -> (x -> y -> a) -> Day f g a
16:56:29 <maralorn> Why is it called Day?
16:56:50 <dminuoso> maralorn: It's named after Brian Day who introduced the day convolution.
16:57:07 <maralorn> huh
16:58:20 <dminuoso> ghoulguy: The abstract, handwaving, sequencing (of effects) semantics are buried into (:.:). If we think of functors as effects in Haskell, the (associative) composition of two functors is almost literally the sequencing of two effects.
17:00:01 <dolio> You know, GHC does not guarantee that IORef reads/writes appear to happen in a certain order, or even a possible interleaving of orders.
17:00:06 <dolio> I made a model of it in Agda.
17:00:33 <nshepperd1> you mean concurrent read/writes?
17:00:39 <dolio> Yeah.
17:00:45 <dminuoso> dolio: Heh, Im waiting for conal to appear and make some note about "IO monad is not even wrong because it has no denotation". :p
17:01:04 <dolio> Well, he'd be wrong about that.
17:01:35 <nshepperd1> huh, I'd expect sequential consistency in the absence of documentation saying there isn't sequential consistency
17:01:46 <dolio> It says there may not be.
17:01:50 <dminuoso> Your point about IORef is interesting, does GHC actually reorder them?
17:01:52 <dolio> That's how I know about it.
17:01:58 <dolio> No, the CPU does.
17:02:01 <dminuoso> Oh
17:02:29 <dminuoso> You mean `writeIORef f 1 >> writeIORef f 2` could leave me with `1`?
17:02:43 <dolio> No, it's more complicated than that.
17:03:12 <maralorn> It's worse on ARM, right?
17:03:14 <dolio> That one would be pretty bad.
17:03:17 <monochrom> No. But funny things happen when one thread goes "write to x; read from y; write to y" and another thread is also playing with x and y.
17:03:28 <nshepperd1> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-IORef.html#g:2 ah
17:03:32 <dminuoso> Oh if its just that..
17:03:43 <dminuoso> I see
17:03:58 <dminuoso> That seems expected
17:04:14 <monochrom> CPU can look at 1st thread and say "looks like x and y are independent, I can change it to "read from y; write to y; write to x""
17:04:24 <dolio> Anyhow, IO is an algebra, and the machine is the model, and does what it wants.
17:04:26 <nshepperd1> well i guess that's fine since you'll probably use tvar for concurrent stuff anyway
17:04:30 <dminuoso> monochrom: Yeah, but that's just memory
17:04:33 <dminuoso> Nothing fancy here
17:04:35 <monochrom> If the 2nd thread has assumptions about 1st thread's order, it's toasted.
17:04:53 <monochrom> I think the IORef doc has a better example than mine.
17:04:56 <nshepperd1> or use atomicModifyIORef if you're a masochist
17:05:06 <monochrom> And then starts rambling about memory barriers
17:05:31 <monochrom> Oh, two IORefs have to be involved, so atomicModifyIORef is beside the point.
17:06:50 <nshepperd1> except for the memory barrier rambling
17:06:53 <dminuoso> Haha, reminds me of C and how endless programmers use volatile thinking it helps with memory orderings.
17:07:18 <dolio> Someone was saying that in here the other day.
17:07:19 <monochrom> https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Data-IORef.html#g:2
17:07:47 <dolio> I decided to go read the C specification, and it didn't say anything about how much a pointer dereference or assignment costs.
17:08:11 <nshepperd1> The c specification barely says anything
17:08:19 <monochrom> Well, "rambling" is my view, I have this very purist opinion that if you need memory barriers you're abusing mutable shared variables.
17:08:28 <dolio> It's pretty long for not saying anything.
17:08:50 <dminuoso> nshepperd1: It says quite a lot, just not the things you hope it says.
17:08:53 <c_wraith> It says lots of things that turn out to not be useful
17:09:11 <nshepperd1> perhaps the c specification should run for political office
17:09:14 <monochrom> I think setting out a grammar is useful.
17:10:41 <dolio> Even the grammar parts are pretty amazing. Like, there could be a 'type too big' error.
17:10:42 <monochrom> The Haskell Report isn't all that better either.
17:11:10 <dolio> No, I wanted to make sure the C one wasn't significantly better than the Haskell one, like was claimed.
17:11:45 <dolio> Like Haskell, most of what it talks about is 'what' and not 'how'.
17:13:37 <koz_> dolio: In many cases for the C Standard, that 'what' is followed by 'the fuck'.
17:13:40 <dolio> I had to read the '17 one, though, because the '18 one was like $100. Maybe it's much improved.
17:14:05 <koz_> (apologies if I broke any channel norms)
17:14:24 <monochrom> hehe
17:14:58 <dolio> I was surprised at how little was specified about the floating point numbers.
17:16:04 <koz_> dolio: Yeah, contrary to popular belief, the C standard requires IEEE 754 precisely nowhere.
17:16:11 <koz_> (C++ I believe does, or at least nowadays)
17:16:22 <dolio> Maybe ISO doesn't want to pay royalties.
17:16:26 <koz_> But then again, C doesn't even require integer representations to be 2s comp.
17:16:32 <koz_> (again, C++ does, as of recently)
17:17:09 <dolio> Yeah. I could see how to really play games with an implementation. You can use sign-and-magnitude with as many padding bits as you want, etc.
17:17:55 <justsomeguy> If I want to define a default class method, do I put the term-level implementation of that method directly in the type class?
17:18:02 <koz_> Also, again contrary to popular belief, char doesn't have to be 8 bits.
17:18:12 <monochrom> That's too easy. Unless you use, like, a dynamically determined middle bit position for the sign bit.
17:18:16 <koz_> (it has to be at least 7, and nothing else can be smaller than it, but otherwise, go nuts)
17:18:33 <koz_> (there are legit computers for sale _today_ which have 9-bit chars)
17:18:33 <dolio> Yeah.
17:19:02 <koz_> justsomeguy: Yeah, it goes under the type signature in the class definition, as if you were just writing a normal function.
17:19:59 <koz_> Ultimate implementation trolling - x86_64, every type is 64 bits wide.
17:20:06 <justsomeguy> koz_: Hmm, ok. I'll try that out.
17:20:08 <koz_> (well, not _that_ ultimate)
17:20:12 <koz_> (but it'd be funny)
17:20:17 <dolio> 64bits is too fast.
17:20:41 <monochrom> GHC comes close to that. Every type is a multiple of 64 bits wide.
17:20:47 <koz_> Something something Atari Jaguar.
17:20:59 <monochrom> Err I guess not really "every".
17:21:44 <monochrom> But for example Word8 is 64 bits for the data constructor, 64 bits for the number.
17:22:39 <koz_> WordNotReally8.
17:22:52 <maralorn> I love how this conversation has drifted from CT to processor behavior.
17:22:55 <{abby}> Word8, the "12" is silent
17:23:25 <koz_> Maybe it's actually short for 'WordMultipleOf8'?
17:23:45 <koz_> maralorn: This is how we roll.
17:24:08 <monochrom> Nah, the real explanation is really boring. Alignment-friendly.
17:24:30 <koz_> monochrom: Yeah, but I can dream!
17:25:13 <monochrom> Right? In popular C implementations, if you malloc(1) you expect alignment to ruin it and you're wasiting at least 7 bytes, too.
17:25:53 <koz_> Not if you have 64-bit char!
17:26:26 <monochrom> That's going to be interesting.
17:26:32 <koz_> UTF-64 lolol.
17:26:49 <monochrom> For, one thing the C standard does require very clearly, is "sizeof(char) = 1".
17:27:03 <koz_> Yes, but 1 can be whatever bit count you want.
17:27:11 <koz_> As long as it's at least 7.
17:27:57 <koz_> You are within your rights as an implementer to decide that sizeof(char) == sizeof(short int) == sizeof(int) == sizeof(long int) == sizeof(long long int)
17:28:09 <monochrom> Yeah, so it's interesting in blowing up the proportion of most people's expectations.
17:29:17 <koz_> I also believe, though I am unsure, that sizeof(float) == sizeof(double) is legal.
17:29:47 <spinnylights> i might be the voice against the choir here a bit but i think the relative vagueness of the c standard is reasonable :P c code needs to compile for a huge variety of different hardware with widely varying characteristics, and if the standard was too specific it would cut certain platforms out
17:30:03 <dolio> Yeah, the person a few days ago was lamenting the Haskell report saying "you should expect a reasonable graph reduction algorithm" or something. But the C spec is full of those kind of 'reasonable expectation' things that don't technically hold force.
17:30:09 <koz_> spinnylights: Yeah, but the POSIX standard is _much_ more restrictive and somehow nobody's died yet.
17:30:32 <koz_> Back the 80s it was an architectural wild west.
17:30:33 <spinnylights> yes but POSIX-compliant operating systems don't run on as wide a variety of hardware as any given c code
17:30:35 <koz_> Implementational too.
17:30:43 <koz_> Nowadays it's _way_ more convergent.
17:31:14 <koz_> dolio: The only reasonable expectation one can have vis a vis C is that you're invoking UB.
17:31:30 <koz_> Since there's like, over 100 sources of UB, some of which are highly surprising and almost impossible to guard against.
17:31:50 <koz_> (I've been bitten by a few, and I do not see how you can possibly ensure you don't violate them in general)
17:31:56 <spinnylights> people write c to control factory equipment, small appliances, etc. etc.‚Äîif you look at the implementation for the specific hardware you're targeting it's generally much more precise about its behavior than the standard is
17:32:26 <spinnylights> i think that's basically by design
17:33:02 <koz_> spinnylights: And I believe said design is absolutely bonkers. The way the standard defines 'portability' translates to 'compiler writers should have the easiest job defining conformant implementations'.
17:33:13 <koz_> Which I argue is literally not how _anyone_ else views 'portability'.
17:33:44 <dolio> I have no real beef with the C standard. But the context was a claim that the standard was/needed to be precise, not the implementation.
17:34:32 <dolio> I mean, the implementation needs to be precise, of course, but that that isn't good enough.
17:34:40 <spinnylights> i don't think portability is as high a priority for c as it is for c++, in the sense that you mean; a lot of the places where c is used, the alternative would be some assembly language, and it's being used for ease of programming, not portability
17:35:17 <spinnylights> c code like that might be portable over some specific class of hardware but it's not usually meant to even run on PCs
17:35:20 <koz_> spinnylights: Then what's the point of the standard?
17:35:40 <spinnylights> if you _do_ need to write portable c code, it's there for you
17:35:53 <spinnylights> it's good to be able to know what's portable and what's implementation-specific
17:36:05 <spinnylights> plus, without it compiler writers wouldn't know what to do :P
17:36:13 <koz_> Which translates essentially to 'essentially nothing' and 'essentially everything'.
17:36:29 <koz_> And I _really_ question the last assertion, considering that most languages lack anything like a standard and their authors seem to be just fine.
17:36:43 <koz_> Or certainly no worse than the authors of compilers for 'standardized' languages.
17:36:57 <spinnylights> well not literally nothing or everything :P i kind of wish that was the case, it might be easier to make a good FFI
17:37:20 <koz_> spinnylights: 'Almost nothing', much like 'almost everything' is almost useless as a claim of anything.
17:37:21 <dolio> I was surprised by the scheme 'proper tail recursion' spec, too.
17:37:34 <koz_> dolio: Yeah, unlike Common Lisp.
17:37:38 <dolio> It's more vague than I'd heard.
17:37:44 <spinnylights> those are not the same kinds of languages :P i doubt those languages are widely used in the embedded world
17:38:07 <monochrom> Ah, atomicModifyIORef includes memory barrier, I didn't notice that.
17:38:14 <spinnylights> maybe you have a good counterexample but it would be surprising to me
17:38:15 <koz_> spinnylights: Perhaps, but being the _only_ option does not imply being the _best_ option. It's a grubby world nobody wants to grub around in.
17:38:37 <koz_> So there's no other options because nobody wants to write languages for that space, not because C is somehow good there.
17:38:40 <spinnylights> well sure :P i don't think c is too many people's favorite language in the world or anything, but the constraints on its design are really severe
17:39:30 <spinnylights> a language like c++ or rust could theoretically take its place but they require much bulkier, harder-to-implement compilers
17:40:00 <koz_> C++ does so because it's the clown car of proglangs and must include literally everything. Except garbage collection because it's badwrongfun somehow.
17:40:16 <spinnylights> writing a c compiler is relatively easy by comparison, which is nice if your language is meant to support a wide variety of esoteric hardware
17:40:21 * ski . o O ( isn't the only element of an ordered singleton set the greatest (and the least) element ? )
17:40:42 <koz_> ski: Isn't every singleton set ordered? Like, vacuously?
17:41:06 <ski> there's only one order on it that you can impose, sure
17:41:17 <ski> (but `Set' is not the same category as `PO')
17:41:27 <spinnylights> and that's partially thanks to the permissive standard :P there's a reason for everything, even if it's not exactly utopian
17:41:53 <koz_> spinnylights: I question the merits of such a standard, if the outcome is 'it's easy to throw together something that may or may not do anything you may or may not expect'.
17:42:10 <koz_> I don't wanna have to play language lawyer when aiming for portability, and C _forces_ you to do this _even when you're not trying_.
17:42:29 <koz_> (again, I got bitten by UB, and portability wasn't even my tenth damned concern)
17:42:59 <koz_> There's no reason for the situation _other_ than an adoption drive (back in the 80s) and legacy (today).
17:44:07 <spinnylights> to be fair, i think claiming that the standard doesn't specify any behavior in particular is overstating your case a bit ;^^ i've written quite a bit of c and any time i've produced ub i've had only myself to blame :P i have yet to find a real compiler bug or anything
17:44:25 <spinnylights> perhaps, i think it's kind of hard to say one way or the other with something like that since the history is so complicated
17:44:42 <koz_> spinnylights: Glad that one of us is lucky like that. I'm not, because I find every bug in everything by breathing.
17:45:01 <koz_> (I'm not joking - I just found a bug in my Real Money Job's nix config by _running nix-build_)
17:45:10 <koz_> (this went unnoticed by everyone for _months_)
17:45:15 <koz_> (well, everyone _else_)
17:45:31 <koz_> And that's basically my life forever with everything.
17:45:33 <spinnylights> i'm not talking about software in general, to be fair :P i've never found a bug compiling c code with gcc
17:45:44 <koz_> spinnylights: Again, compared to me, you lead a charmed life.
17:45:58 <koz_> May you forever continue to be this fortunate.
17:46:10 <spinnylights> if you regularly find bugs in gcc then you're a great boon to the rest of us ^^
17:46:21 <koz_> spinnylights: Trust me, nobody thanks you for doing this kind of work.
17:46:39 <koz_> (believe me, the responses I've had from certain communities for daring to suggest that somehow I am not responsible personally for every bug I find...)
17:47:36 <koz_> But anyway, I'm _way_ off-topic, so to bring it back to Haskell: I recently realized that wai's Application is effectively ReaderT Request (ContT ResponseReceived IO) Response.
17:47:37 <spinnylights> well, if you're really confident, keep fighting the good fight ^^ if you can find the time to submit a patch they may be more receptive in some cases, also
17:48:20 <spinnylights> but yeah, that's true, this is far away from haskelland :P
17:48:28 <koz_> spinnylights: I do when I can, but a lot of the time, I can't really. I've found bugs in LibreOffice and Firefox - good luck trying to figure out how to fix _those_ unless you've been wrangling those codebases intimately for years.
17:48:35 <monochrom> @unmtl ReaderT Request (ContT ResponseReceived IO) Response
17:48:36 <lambdabot> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
17:49:01 <spinnylights> i just patched a bug in firefox's audio backend last week ^^ it's possible
17:49:12 <monochrom> Hrm, what is that ContT doing there?
17:49:12 <spinnylights> sometimes the code's not as gnarly as you would think
17:49:26 <spinnylights> sorry, you're right about all this being off topic though
17:49:39 <koz_> spinnylights: 'Possible' is one thing. It is also 'possible' for me to write a GPGPU-based AV1 encoder, but the number of hours, days, or _months_ it would take me preclude this possibility from being realized.
17:49:48 <koz_> monochrom: Resource handling according to the docs.
17:49:53 <koz_> (no really)
17:50:47 <monochrom> I think I know that idiom, yeah.
17:51:18 <koz_> How would you ensure resource release a la bracket by way of ContT?
17:51:26 <monochrom> (after "resource handling")
17:51:29 <koz_> Like, if this is an idiom, it's one I've never seen.
17:51:57 <monochrom> It doesn't ensure more than bracket does, but it looks nicely syntactically.
17:53:14 <monochrom> Whereas you normally write "withFoo (\h1 -> withBar (\h2 -> ...))" and after 5 levels it is indenting too much to the right...
17:54:34 <monochrom> do { h1 <- ContT (\k -> withFoo k); h2 <- ContT (\k -> withBar k); ... } looks more vertical, sequential, straightline.
17:55:21 <koz_> So what's the ContT-based translation of withFile, say?
17:55:42 <monochrom> withFoo k = withFile "filename" ReadMode k
17:56:06 <monochrom> withBar k = bracket acquire release k
17:56:50 <monochrom> You just slap a ContT (the data constructor) wrapper around each one.  And a runContT at some outer level.
17:57:58 <ski> @hackage managed  -- koz_ ?
17:57:59 <lambdabot> https://hackage.haskell.org/package/managed  -- koz_ ?
17:58:08 <monochrom> Also, this: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
17:58:29 <dolio> So this is an example of a monad where each action causes something in the listed order, and also something in the opposite of the listed order.
17:58:59 <ski> they should add `evalContT = flip runContT return' ..
17:59:07 <monochrom> I would count "in the opposite of the listed order" as "also sequential".
17:59:20 <monochrom> Not that I really want to get into that debate. :)
18:00:31 <monochrom> But an inspiration I drew from is this:
18:01:19 <monochrom> In eager evaluation, "(f . g . h) x" is evaluated in order of: x, h of that, g of that, f of that.
18:01:35 <monochrom> In lazy evaluation, in order of: f, g, h, x.
18:01:42 <monochrom> Which one is "the listed order"?
18:02:13 <monochrom> Instead, what I'm sure is that of the two linear orders, one of them happens. So it's sequential.
18:02:43 * ski . o O ( speculative evaluation )
18:04:22 <monochrom> Taking a step further, suppose in a very strong sense both orders happen together, for example Tardis.
18:04:32 <monochrom> I still say it's sequential.
18:04:55 <koz_> monochrom: Thanks - I will read those, but this is rather cool.
18:05:12 <monochrom> If you don't have a commutative law, then it is sequential, or perhaps you object to that commitment, OK not-not-sequential.
18:05:33 <ski> list monad is still sequential
18:05:46 <monochrom> And by the time you have an anti-commutative law, it's in every sense definitely sequential.
18:05:59 <ski> the interface is sequential
18:06:04 <dolio> I'm on record saying that only commutative things should be considered not sequential.
18:14:20 * hackage prairie 0.0.1.0 - A first class record field library  https://hackage.haskell.org/package/prairie-0.0.1.0 (parsonsmatt)
18:36:31 <monochrom> TIL: f (x :: forall a. a->a) = ... is also allowed under RankNTypes and ScopedTypeVariables
18:36:45 <monochrom> f will get the rightful rank-2 type.
18:43:37 <dolio> That's what we did in ermine, except it wasn't optional.
18:43:50 <dolio> The signature for f did no good. :√æ
18:58:30 <spinnylights> i realize as long as i'm hanging out in this channel i mgiht as well ask :P i'm looking into using haskell for game development, and as far as i can tell aside from the sdl2 bindings (which seem quite nice) there's not much available in terms of libraries?
18:59:20 <spinnylights> at least in terms of like, actively-maintained stuff
18:59:31 <spinnylights> but maybe i'm missing something?
19:02:37 <spinnylights> in theory this https://hackage.haskell.org/package/inline-c seems really handy‚Äîi wouldn't mind working on bindings in general but in this particular case it would be for a series of short, sketchy, fast-as-possible games, so spending a lot of time up front writing bindings would kind of undercut that
19:04:43 <spinnylights> in the abstract haskell seems like a nice language to use for that sort of project because programs can come together in it so fast :P but i'm kind of worried that the lack of library support will limit what i can realistically do without writing a lot of enginey code beforehand
19:05:20 <sm[m]> spinnylights: still here ?
19:05:34 <spinnylights> yaya, i just wrote that stuff :P
19:06:09 <sm[m]> cool. You're right, there's not a lot that's actively maintained. But there is quite a lot of libs and interested folks out there
19:06:32 <spinnylights> yeah, that's the impression i get‚Äîlots of blog posts, some old libraries here and there, etc.
19:06:45 <sm[m]> a.lot of good pieces exist but have not been tied together so you have to do that work
19:07:11 <sm[m]> I'm building a game with sdl right now, I think it's working out
19:07:49 <justsomeguy> How can I determine which type classes can be derived, and which cannot? Do I just have to know, or can I query them somehow?
19:07:57 <spinnylights> i tried to see if i could still use the chipmunk bindings but i think they would need some work before they'll compile under the latest ghc
19:08:15 <spinnylights> what sort of game is it? how much have you had to do yourself?
19:08:17 <dolio> justsomeguy: They're listed in the Haskell report, and GHC has some extras turned on by extensions.
19:08:23 <sm[m]> If you haven't seen, there are: a lot of games on hackage, a games page on the wiki, /r/haskell-game and #haskell-game
19:08:47 <spinnylights> oh there are games on hackage, that's cool, i didn't realize that
19:09:14 <sm[m]> spinnylights: yes, a lot and some even build with modern ghc
19:09:16 <dolio> There are also some extensions that let you derive almost anything in particular ways.
19:09:29 <spinnylights> yeah i should probably check out that channel‚Äîi've come across the wiki page and the reddit a bit
19:09:39 <sm[m]> spinnylights: I'm making breakout, deliberately not using any framework
19:09:43 <spinnylights> anything you would particularly recommend? it would be awesome to have some examples
19:09:46 <spinnylights> nice i love breakout ^^
19:10:50 <spinnylights> yeah in theory you can do a lot with just plain sdl, it's mainly a matter of time :P the goal for this particular project would be to make a series of games spending 1 or maybe 2 days on each one
19:10:53 <dsal> justsomeguy: I often just assume I can't derive classes and write them, but I've found GHC's been able to do some pretty fantastic deriving at times.  There's lots of magic when you're ready for it.
19:11:00 <dsal> Is there a particular class you want derived?
19:11:20 <sm[m]> monadius is great. Dino-rush. lambda-heights. Allure of the stars (also has its own chat room). For game engines, I maintain the oldest, and I would say possible still the most productive: FunGEn
19:11:39 <spinnylights> so i think for that to be realistic i would need to do some sort of simple engine writing beforehand‚Äîif i don't worry about the lack of an easy-available physics library it probably wouldn't be too bad
19:11:50 <spinnylights> awesome thanks, i'll definitely take a look
19:12:14 <sm[m]> spinnylights: I was trying to make the simplest possible game a bunch of different ways. It turns out to be a big project for me but it's still fun
19:12:24 <justsomeguy> dsal: I can't think of a particular example right now; I was just reading about type classes in the textbook I'm learning from, and it piqued my interest.
19:12:40 <sm[m]> once you've done it once or twice I think it's waaaay faster
19:13:07 <dsal> justsomeguy: Very often, there's only one way to do it, so it makes sense that it can be derived.
19:13:18 <spinnylights> yeah i was planning to write a game or two beforehand just since i would end up putting together a lot of the components of a simple engine that way as i went
19:13:39 <sm[m]> I think using fungen would have been much faster
19:13:44 <spinnylights> i just don't want to spend too much time up front :P the goal of the project is partially to teach myself restraint ;^^
19:14:25 <spinnylights> i notice the fungen repo is a few years old now‚Äîyou still keep it up and such?
19:14:45 <spinnylights> i like that it's glut-based, that's nice
19:15:08 <sm[m]> It's basically emergency fixes only and nobody ever used it but afaik still works great
19:15:21 <sm[m]> Very simple deps
19:15:48 <spinnylights> if it still works that's all i really care about :P
19:15:48 <sm[m]> sm-breakout on github is my current WIP
19:16:05 <sm[m]> try the sample games
19:16:30 <spinnylights> yeah i'm checking out the hackage page rn
19:16:48 <spinnylights> "executable game spec" is definitely the dream :P
19:18:08 <sm[m]> it trips me out how long ago this framework was made and how it's still the go to
19:19:55 <spinnylights> kinda makes sense in a way, if it has a lot of useful features
19:20:59 <spinnylights> building the examples rn
19:24:14 <spinnylights> v cool ^^ definitely a good proof-of-concept, i'm looking at the pong code and it's v short and readable
19:25:32 <spinnylights> it's too bad about audio though :/ i wonder how easily this https://hackage.haskell.org/package/csound-expression could be integrated...maybe i'll experiment a bit
19:25:32 <sm[m]> yep I appreciate it more after working with just sdl
19:25:44 <spinnylights> yeah it definitely has more game-specific stuff
19:26:26 <spinnylights> it's nice that you get collision detection, and it seems easier to work with graphics
19:26:36 <sm[m]> and the binaries will work on any machine I think - no need to install sdl separately
19:27:03 <spinnylights> yeah that's great as well, i've been thinking about that in the back of my head
19:27:17 <sm[m]> oh yeah. Isn't there a openAL lib ?
19:27:50 <sm[m]> elerea looks like an interesting new sound lib
19:28:17 <spinnylights> seems kind of uncommon to statically link sdl in c or c++ which can def make distribution a bit of a pain
19:28:42 <spinnylights> oh i see, does seem interesting
19:29:38 <spinnylights> i know csound quite deeply so i automatically gravitate in that direction :P it does have the advantage that it can talk to a wide variety of backends (i like to have JACK support in linux which a lot of generic audio libs overlook)
19:30:32 <spinnylights> and if it could be made to talk to fungen it would provide a very easy means to add procedural sound to your game which is always cool
19:31:26 <spinnylights> i know the csound community is rather fond of haskell but i haven't actually played around with the haskell-related stuff people have made so maybe this is a good time
19:31:30 <sm[m]> I don't there's any integration required, just use both ?
19:31:59 <sm[m]> but I haven't tried
19:32:00 <spinnylights> yeah hopefully it's that straightforward
19:32:11 <spinnylights> i _think_ that should be the case but yeah, i haven't tried yet
19:33:17 <spinnylights> the csound-expression lib seems to have a strong focus on live coding which is def promising for use in a game context
19:34:18 <spinnylights> whoa this library is really fancy 0_0 it even has a cabbage monad
19:34:24 <spinnylights> i should have looked at it sooner :P
19:36:36 <spinnylights> i'm going to see if i can modify the pong example to produce sound using csound-expression, i'll report back :P
19:37:09 <spinnylights> i guess maybe i should share my results in #haskell-game
19:42:20 <sm[m]> spinnylights: live coding is a bit more of a project but I think some good things to look at are ghcid, Tidal package, and the new reloading system used by IHP
19:43:19 <spinnylights> oh yeah, i just mean that if it supports live coding it will probably be up to use in a game context
19:43:33 <spinnylights> in terms of lag etc.
19:43:56 <spinnylights> csound is pretty fast on its own so as long as the library doesn't introduce extra performance issues it should be fine
19:51:08 <koz_> A cabbage monad?
19:53:57 <sm[m]> don't you use vegetable monads ?
19:54:24 <koz_> sm[m]: I prefer fruit.
19:54:44 <Axman6> You can't call them that any more, we prefer differently-abled monads
19:54:45 * koz_ . o O (instance Monad Tomato where)
19:54:54 <spinnylights> makes it easy to put the stems, leaves, etc. together
19:55:12 <spinnylights> v convenient
19:55:58 <spinnylights> unfortunately i seem to be stuck in some kind of extra-deps hell with stack :/ i'm still kind of new to it so maybe i'm not going about this the right way
19:56:22 <koz_> What's the specific extra-deps hell?
19:57:10 <spinnylights> csound-expression doesn't seem to be part of the package set for the resolver fungen uses, so i'm trying to specify the versions of the needed dependencies by hand, but it's a lot of trouble to figure out how to line everything up so there's no version conflicts :/
19:57:47 <spinnylights> i might be able to figure it out if i keep at it but it definitely seems like something an automated tool would be better at
19:58:40 <koz_> Which resolver does fungen use?
19:58:53 <koz_> Are neither of fungen and csound on Stackage?
19:59:31 <spinnylights> lts-6.12
19:59:48 <Axman6> that's... very old
20:00:29 <Axman6> has basically no chance of ever compiling on macOS, since older GHCs have issues with linker changes Apple made
20:00:33 <koz_> That's _hilariously_ ancient.
20:01:05 <koz_> It's like, GHC 7.10.3 I think?
20:01:38 <spinnylights> fungen itself builds and runs fine in my environment (arch linux) but yeah, i don't think the code has been updated in a long time
20:02:11 <spinnylights> i'm trying to use a version of csound-expression that's roughly contemporary with the fungen source but so far no luck :/
20:02:37 <koz_> fungen was last updated in 2016.
20:02:41 <koz_> I wouldn't hope for much.
20:02:45 <spinnylights> @sm[m] does fungen require lts-6.12 or can it build with something more recent?
20:02:45 <lambdabot> Unknown command, try @list
20:03:02 <spinnylights> er :P
20:05:59 <koz_> spinnylights: I'm trying with 8.10.2 right now.
20:06:02 <koz_> Seeing how I go.
20:07:17 <spinnylights> yeah i'm trying with 8.8.3...we'll see
20:08:18 <spinnylights> one of the dependencies for that old version of csound-expression would not build, but let's try with a more recent version
20:09:59 <koz_> Nah, 8.10.2 breaks due to MonadFail.
20:10:11 <Axman6> #MonadFailFail
20:10:33 <spinnylights> darn, csound-expression-5.3.3 and fungen have conflicting dependencies :/
20:10:51 <koz_> spinnylights: What conflicts?
20:10:54 <spinnylights> sm[m]: how hard do you think it would be to bring fungen up-to-date? :P is that overly ambitious?
20:10:57 <Axman6> --allow-newer-yolo
20:11:17 <koz_> spinnylights: There's a mission MonadFail instance required for 8.10.
20:11:22 <koz_> For 8.8, I'm about to find out.
20:12:40 <sm[m]> spinnylights: sorry was afk. I though my I updated it for maybe 8.6 in the git repo. It shouldn't be hard to update
20:13:34 <Axman6> https://matrix.hackage.haskell.org/#/package/FunGEn makes me sad
20:13:46 <spinnylights> ah well i got the build process to start again at least
20:14:26 <koz_> 8.8.4 works.
20:14:36 <koz_> (you need --allow-newer I think, but it works)
20:14:42 <koz_> Oh wait never mind.
20:14:45 <koz_> Same MonadFail issue.
20:14:52 <spinnylights> no worries, if it's easy that would be awesome‚Äîi'm happy to help/submit a patch too
20:15:28 <Axman6> MonadFail issues aren't hard to solve though
20:15:34 <koz_> spinnylights: Basically, you gotta add an instance of MonadFail for IOGame GameAttribute ObjectAttribute GameState TileAttribute
20:15:41 <koz_> That's the most obvious issue.
20:15:42 <sm[m]> I don't have time, even to review right now - travelling. Help welcome
20:16:21 <koz_> Also, the cabal file doesn't indicate Paths_FunGEn, but that's also easy to fix.
20:16:36 <spinnylights> okay i'll take a look
20:16:41 <spinnylights> yeah i just got there myself
20:17:08 <sm[m]> but at least it should be usable with lts-whateveritis
20:17:17 <spinnylights> csound builds okay‚Äîlots of warnings but it came together
20:17:45 <koz_> Is there even an LTS for 8.10.*?
20:17:47 <spinnylights> luckily at least so far the issue is in the worms example so at least that's pretty simple
20:18:01 <spinnylights> not yet i don't think
20:18:24 <sm[m]> it'll be obsolete soon :(
20:18:47 <sm[m]> but I guess it's not exactly stable yet
20:19:07 <sm[m]> (ghc 8.10)
20:19:28 <sm[m]> one of these statements must be wrong eh
20:19:34 <spinnylights> heh :P
20:21:11 <koz_> But yeah, sm[m] is right, this is an easyish fix.
20:21:32 <koz_> It's not like the kind of gore I had to involve myself with when I lifted my Real Job For Real Money codebase to 8.8.
20:21:37 <koz_> That was... *shudders*
20:23:35 <sm[m]> hehe wishful thinking on my part.. I last updated it to ghc 8.0
20:38:31 <ski> @remember monochrom Any sufficiently insider joke is indistinguishable from sufficiently advanced knowledge.
20:38:32 <lambdabot> Done.
20:45:06 <spinnylights> ooh i think i got it ^^
20:45:37 <spinnylights> it was pretty simple in the end, yeah :P
20:46:44 <spinnylights> sm[m]: would you accept a pull request if i submitted one? it's like two lines of code :P
20:47:03 <spinnylights> trivial monadfail instance for iogame
20:52:33 <spinnylights> i'll just go ahead and put one together, it won't take long anyway
21:13:50 <sm[m]> spinnylights: sure! Think I can handle that :)
22:01:38 <hololeap> so, a Traversal cannot be used as a lens, but the types make it seem like Traversals are a subset of Lenses
22:02:23 <hololeap> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
22:02:34 <hololeap> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
22:03:33 <hololeap> since all Applicatives are also Functors, why does it say in the lens docs that a Traversal cannot be used as a Lens
22:04:35 <dolio> Functor f => Applicative f, so (Applicative f => T) < (Functor f => T)
22:06:46 <dolio> Wait, I wrote some of that backwards, didn't I?
22:06:59 <hololeap> right, the set of Applicatives is a subset of the set of Functors
22:07:01 <dolio> Anyhow, the subtyping relationship flips on the left of an arrow.
22:07:22 <hololeap> so shouldn't the same be true for Traversals vs Lenses?
22:08:09 <hololeap> therefore, any Traversal is also a Lens?
22:08:15 <dibblego> it's the other way around
22:08:30 <dolio> Applicative is the subtype.
22:09:35 <hololeap> any Applicative is also a Functor, therefore any Traversal should also be a Lens. what am i missing here?
22:09:49 <dibblego> any Applicative is also a Functor, therefore any Lens should also be a Traversal
22:10:19 <hololeap> but why?
22:10:25 <dolio> Lenses work for every Functor, so they also work for every Applicative.
22:10:33 <dibblego> because the types say so
22:10:53 <dibblego> the constraint is in contravariant position
22:10:55 <hololeap> oh, i get it now
22:11:37 <hololeap> that was a little tricky :)
22:12:27 <dibblego> Applicative f => f a -> b -- this function not only accepts any Applicative, but also any Functor
22:14:00 <hololeap> that's freaky. i never thought about the fact that constraints could be contravariant
22:14:10 <hololeap> although it makes total sense intuitively
22:17:07 <hololeap> dolio: what is a subtyping relationship?
22:17:51 <dolio> A is a subtype of B if every A can be used when a B is required.
22:18:59 <hololeap> i reread the sentence, and you're saying that if it's used in the negative position, the relationship is reversed, aka contravariant
22:19:35 <dolio> Yes.
22:21:27 <hololeap> although, in these cases, the constraint is placed on a variable that appears in the negative and positive positions
22:24:17 <dolio> That part doesn't matter, because what's being subtyped is the type class, basically.
22:24:37 <dolio> You could think of it as the dictionaries being subtypes, if you want.
22:25:31 <hololeap> wait, what are these dictionaries you mentioned?
22:27:48 <dolio> A record that contains the methods and superclasses of the type class.
22:28:42 <dolio> For Functor, {fmap}, and for Applicative, {fmap, pure, (<*>)}, or something.
22:30:01 <spinnylights> sm[m]: submitted ^^ there were a few small config changes needed as well but it should only a take a moment to look over
22:30:30 <hololeap> you know, the more i think about it, the more i see the obviousness of the answer here. i'm not sure what made me think it would be otherwise >_>
22:31:38 <dolio> Well, the fact that it's written `Functor f => Applicative f` probably doesn't help.
22:33:05 <hololeap> it's saying that Functor f is equal to or larger then Applicative :)
22:33:12 <dolio> It even made me give you the wrong answer at first.
22:37:36 <proofofme> One more question:  How do I process a type of `IO (Maybe [String])` line by line?  For now, just to `print` it line by line.  `print =<< allStrings` works, but it doesn't provide the line-by-line control
22:38:24 <Taneb> :t mapM_
22:38:38 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
22:39:20 <Taneb> proofofme: if you make a function of type "Maybe [String] -> IO a" then you can use it with (=<<) like you're doing with print
23:00:46 <Axman6> :t mapM (mapM putStrLn)
23:00:49 <lambdabot> (Traversable t1, Traversable t2) => t1 (t2 String) -> IO (t1 (t2 ()))
23:01:06 <Axman6> :t mapM (mapM putStrLn) `asAppliedTo` (undefined :: Maybe [String])
23:01:08 <lambdabot> Maybe [String] -> IO (Maybe [()])
23:01:32 <Axman6> :t mapM_ (mapM_ putStrLn) `asAppliedTo` (undefined :: Maybe [String])
23:01:34 <lambdabot> Maybe [String] -> IO ()
23:19:49 * hackage Z-Data 0.1.5.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.5.0 (winterland)
23:21:18 <hololeap> type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
23:21:43 <hololeap> could this not be simplified since Star f is already a profunctor?
23:22:06 <hololeap> type Iso s t a b = forall p. Profunctor p => p a b -> p s t
23:26:19 <hololeap> maybe this would conflict with Lens, etc being a subtype of Iso
23:26:30 <hololeap> that must be the reason
23:27:41 <Taneb> hololeap: yeah, that's the reason
23:27:51 <Taneb> We want to be able to compose a lens with an iso
23:28:09 <Taneb> There's another style of lenses called "pure profunctor" lenses
23:28:46 <Taneb> Which I think has type Lens s t a b = Strong p => p a b -> p s t
23:29:56 <hololeap> oh ok
23:30:15 <Taneb> lens doesn't use that because it means you can't define lenses while only depending on base
23:32:37 <hololeap> it's interesting to me that not all Profunctors are Categories, which means some Profunctors don't compose, i would assume
23:33:32 <Taneb> Yeah. The composition here uses the (->) in the middle
23:36:22 <hololeap> could Lenses be generalized to: Lens s t a b = forall cat p. (Category cat, Strong p) => p a b `cat` p s t
23:37:07 <Taneb> Hmm, sort of? But you get something different to a lens
23:37:22 <Taneb> Basically, you'll only be able to define ones that are "id"
23:38:54 <hololeap> (Monad m, Strong p) => Kleisli m (p a b) (p s t) -- could this be useful?
23:39:29 <Taneb> That doesn't give you anything that (->) doesn't, I think
23:40:05 <Taneb> Because the only way you can define one of those is essentially with arr somelens
23:41:29 <xQc> I was trying to define a list recursively. Can someone explain why these two approaches return different result? I think they are defined exactly the same https://pastebin.com/w7BTL1wn
23:41:43 <hololeap> the rabbit hole is deep here :p
23:52:22 <hololeap> myfibs = 1:1:1:2:(1+(0-1)+(2*2)):(1+(0-1)+(2*(1+(0-1)+(2*2)))):(1+(0-1)+(2*((1+(0-1)+(2*(1+(0-1)+(2*2))))))
23:52:29 <hololeap> ...
23:53:25 <olligobber> hololeap, parse error (possibly incorrect indentation or mismatched brackets)
23:54:04 <hololeap> the applicative instance of [] is a cartesian product
23:54:36 <olligobber> added an extra bracket and :[] and got [1,1,1,2,4,8,16]
23:54:39 <olligobber> "fibs"
23:55:26 <hololeap> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
23:56:35 <hololeap> for the list instance of Applicative, it will start with the first values of `f a` and `f b`, along with _every value_ of `f c`
23:56:47 <hololeap> if `f c` is infinite, you can imagine what happens
23:57:20 <xQc> oh. I think i get the error
23:57:30 <xQc> I guess I have to use the ZipList class?
23:59:29 <hololeap> yeah, that might work
23:59:31 * hololeap shrugs
