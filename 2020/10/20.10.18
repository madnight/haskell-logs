00:05:45 <koz_> proofofme: You need to actually import the module where decode is defined.
00:05:53 <koz_> Also, put a type signature on main please.
00:06:00 <proofofme> I did:  import Data.CSV
00:06:26 <koz_> I am not seeing that in the thing you linked.
00:07:26 <proofofme> you mean this in the cabal file:  cassava ^>= 0.5.2.0  ?
00:07:50 <proofofme> https://hackage.haskell.org/package/cassava-0.5.2.0/docs/Data-Csv.html
00:07:52 <koz_> proofofme: No. In your 'code' section, there is no import line.
00:08:12 <koz_> Like 'import Data.CSV' as you described.
00:08:13 <proofofme> ah, I excluded the portion above ...
00:08:26 <proofofme> I excluded from the snippet.  It is there though
00:08:26 <koz_> proofofme: Yeah, we kinda need you not to do that.
00:08:41 <koz_> Please pastebin _the_ _exact_ source file.
00:08:44 <koz_> Omitting nothing.
00:08:52 <proofofme> ok one second
00:08:57 <koz_> Since in this case, it is actually fairly critical.
00:09:19 * hackage multipart 0.2.1 - Parsers for the HTTP multipart format  https://hackage.haskell.org/package/multipart-0.2.1 (ErikHesselink)
00:10:00 <proofofme> https://pastebin.com/XqtKh9Ac
00:10:52 <koz_> "import Data.CSV" <-- contrast with the module's actual name as per https://hackage.haskell.org/package/cassava-0.5.2.0/docs/Data-Csv.html
00:11:44 <proofofme> ah ...
00:11:59 <proofofme> wow ... spent so long on this tonight ...
00:12:09 <koz_> proofofme: Happens.
00:19:14 <proofofme> what's the standard way of handling an `either`?
00:19:33 <koz_> proofofme: What do you mean by 'handling'?
00:20:47 <proofofme> so I have an assignment to `x` which is of type Either String (Vector(Text, Int)).  how do I process `x` and do the same functions as fromRight and fromLeft, but the right way
00:21:18 <koz_> Well, you'd normally case-match.
00:22:02 <koz_> https://gist.github.com/kozross/b3e00bd68bb1ddd91c09be215182f1bc
00:22:02 <proofofme> is there a function analogous to the `maybe` for handling Maybes?
00:22:07 <koz_> :t either
00:22:08 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
00:22:35 <koz_> I don't recommend it here, though, mostly because your Either represents an error condition versus a successful parse.
00:22:44 <koz_> So jamming it all into either is probably not the best idea.
00:23:03 <proofofme> case matching it is then.  Thanks koz!
00:57:49 * hackage arrow-list 0.7.1 - List arrows for Haskell.  https://hackage.haskell.org/package/arrow-list-0.7.1 (ErikHesselink)
00:59:49 * hackage pandora 0.3.1 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.3.1 (iokasimovmt)
01:16:50 * hackage HDBC-postgresql 2.3.2.8 - PostgreSQL driver for HDBC  https://hackage.haskell.org/package/HDBC-postgresql-2.3.2.8 (ErikHesselink)
01:22:18 * hackage uri-encode 1.5.0.7 - Unicode aware uri-encoding  https://hackage.haskell.org/package/uri-encode-1.5.0.7 (ErikHesselink)
02:32:08 <maerwald> is there anything special to consider to make a haskell program work correctly with SIGSTOP? I think there's something weird with async going on or so
03:04:35 <[exa]> maerwald: SIGSTOP should be uncatchable and halt all processes in a process group almost transparently... Chances are that it might break some internal timers etc. Any specific problems?
03:04:58 <maerwald> yes, the program sometimes crashes, sometimes not
03:05:30 <[exa]> btw are you getting a real SIGSTOP or SIGTSTP?
03:05:31 <maerwald> (after waking it up again)
03:06:10 <maerwald> pressing ctrl-z
03:06:32 <[exa]> can you try with explicit `kill -STOP $pid` ?
03:06:53 <[exa]> (but that's a wild guess)
03:08:55 <[exa]> (btw what's the program doing in the meantime?)
03:09:23 <maerwald> running a subprocess
03:11:10 <[exa]> spawned with a fork() ?
03:14:16 <maerwald> execv
03:17:25 <[exa]> btw you can probably `strace -f -p $pid` to see how it acctually crashes (or not) and see if there's some external difference
03:18:40 <[exa]> ...at least before starting to gdb the RTS... :]
03:58:56 <jil> Hi
03:59:37 <jil> 1) What is wrong with the way I use the where keyword in the second proposition here ? https://paste.debian.net/1167668/
04:00:24 <jil> Do you have a prefered paste website for Hskell code ?
04:01:23 <__monty__> jil: Identifiers have to be lowercase. Uppercase is restricted to Types, Typeclasses and Data Constructors.
04:01:24 <ulidtko> jil, sorry you can't have Capitalized variables in Haskell
04:01:54 <jil> ok,  That's clear.  Thank you.
04:02:22 <__monty__> Good luck!
04:05:31 <jil> I'm not satisfied with my 2 propositions.  How would you answer the question in a elegant way without using advanced Haskell trics ?  (I'm only on chapter 4 of "the book programming in Haskell")
04:06:50 <jil> would a lambda to replace the  'take k'  function ?
04:07:23 <ulidtko> jil, do you have maybe another expression for of take k (reverse xs)
04:07:58 <ulidtko> in a lazy language, reversing a list is not a cheap operation.
04:08:50 <merijn> Why would it be any more expensive than in a strict language?
04:11:08 <ulidtko> hmmm, maybe I'm talking nonsense (on the surface, it seems like it) -- but from practice, doing that is frequent source of quadratic memory usage, and associated slowdowns
04:11:15 <jil> ulidtko: I'm only allowed to use library functions
04:11:37 <ulidtko> jil, take another look; the `take` function isn't the only one in standard library
04:12:14 <merijn> ulidtko: I don't see why reverse would use anything other than linear memory, same for linked lists in strict languages
04:12:14 <jil> How do I list all library function in ghci ?
04:12:40 <ulidtko> import Data.List
04:12:45 <ulidtko> Data.List.<tab><tab>
04:13:01 <jil> thank you.
04:13:03 <__monty__> jil: It's hard to tell which those are though. You're defining a function that's very similar to one in the prelude.
04:13:29 <__monty__> If you're allowed to use all of base you need only a single function.
04:14:22 <__monty__> So if you're not restricted to a subset of the library I have my doubts about the pedagogical value of the exercise.
04:15:21 <ulidtko> merijn, frankly I don't "get it" completely why that happens too. perhaps for the same reasons that foldr performs better than foldl?.. something-something thunk tree buildup *hand-waves* -- while there's no foldl/foldr difference in a strict language
04:15:38 <jil> __monty__: I though so.  The pedagogical value is already obtained with what I did.  I want to ga a little fiurther and this how it could  or it is done better.
04:16:26 <jil> and see how ..
04:17:20 <__monty__> jil: Ok, there's a function similar to take which'd achieve something similar to `take . reverse`, there's also splitAt. Then there's another way you could write this with just pattern matching and mutual recursion. A bit like an un-merge, maybe try that as a continuation of the exercise.
04:18:06 <merijn> ugh
04:18:42 <merijn> Does anyone know how I can actually build ghcide? haskell-lsp-types seems to be broken :\
04:20:26 <jil> __monty__: great.
04:21:51 <ulidtko> merijn, I got haskell-language-server built using Stack (version: 0.2.2.0, GHC 8.6.5, GIT hash: cbdf0a4e5936cb17ac7f2d2df672c2fa1e23284d)
04:23:22 <merijn> haskell-lsp-types is failing to build due to missing instances
04:24:50 <ulidtko> pick an older version
04:25:26 <ulidtko> well, unless you want to dive in and help solving the issue
04:25:54 <merijn> It's broken in all versions I've tried
04:26:10 <merijn> So it looks like someone fucked up their upperbounds
04:26:29 <merijn> ah
04:26:37 <ulidtko> --allow-newer to the rescue
04:26:40 <merijn> No
04:27:01 <merijn> Allow newer only helps if they're to tight, I'm pretty sure they're too lax
04:27:12 <ulidtko> ah, I see
04:27:22 <merijn> But it looks like it's the TH issues I complained about with GHC
04:28:00 <merijn> Incorrect ordering TH splices
04:28:13 <ulidtko> TH compilation is so damn fiddly
04:29:02 <merijn> GHC let people get away with breaking the rules and then fixed this bug, so now stuff's broken
04:30:00 <ulidtko> haha, but errors are *helping* people aren't they?
04:30:03 <fendor> merijn, iirc I fixed the incorrect ordering of TH splices
04:31:34 <fendor> arent we using index-state in ghcide?
04:31:48 <merijn> No
04:32:24 <fendor> huh. 
04:32:25 <merijn> I can't actually find the code for haskell-lsp-types in its repo either, so I can't check
04:32:49 <merijn> cabal.project of ghcide doesn't have an index state in it, so...
04:33:30 <fendor> no, it doesn't. The haskell-lsp-types repo got a major rewrite
04:33:52 <merijn> fendor: No, still broken by the looks of it
04:34:18 <merijn> oh, hmm, maybe it's not in head?
04:35:21 <fendor> maybe it got overriden with the latest changes. However, HEAD, e.g. version 1.0, will not compile with it anyways
04:35:32 <fendor> *ghcide will not compile with haskell-lsp version 1.0 anyways
04:35:36 <fendor> right now
04:35:39 <merijn> 0.3.3 didn't compile either, so
04:36:03 <merijn> Hackage release doesn't build either
04:36:53 <phadej> 0.3.3 of what?
04:37:00 <merijn> fendor: If you have maintainer rights maybe set a revision on the 0.22 version of haskell-lsp-types to not build with 8.10
04:37:03 <merijn> phadej: ghcide
04:37:03 <phadej> (there isn't ghcide-0.3.3)
04:37:10 <phadej> at least not on Hackage
04:37:15 <merijn> oh, wait it's the hls 3.3 tag of ghcide repo
04:37:19 <fendor> merijn, I do not, iirc
04:37:33 <merijn> oh, wait
04:37:42 <merijn> I'm still using the GHC prerelease on this machine
04:37:50 <merijn> Maybe switching to the proper one works
04:38:05 <phadej> I was going to ask what GHC are you using
04:38:21 <phadej> https://matrix.hackage.haskell.org/ng/#/package/haskell-lsp-types looks clean, e.g.
04:39:46 <phadej> though, no upper bounds is a time bomb :)
04:39:58 <merijn> oof
04:40:07 <merijn> No debian 8 release of 8.10
04:40:10 <phadej> or no lower-bounds, even worse.
04:40:51 <fendor> setting good bounds is a tough challenge, though
04:41:12 <phadej> lower bounds? not really
04:41:15 <merijn> fendor: Naah, it's easy. Set to whatever you're using to develop, relax as new versions of dependencies are released
04:41:22 <phadej> indeed
04:41:25 <merijn> If anyone needs something wider, they can do the work to test it works
04:41:46 <merijn> packdeps even has an RSS feed to see when your dependencies update
04:42:23 <phadej> it's not like `text` is getting major release every two weeks :)
04:42:25 <phadej> or bytestring
04:42:36 <phadej> not having bounds on those is just laziness
04:43:10 <merijn> phadej: is nuking stuff on .cabal/store/ghc-X all I need to nuke everything cabal v2-build using that version?
04:43:12 <maerwald> merijn: it only seems to support fuzzy search
04:43:13 <jil>     k = div n 2
04:43:29 <fendor> merijn, disagree, on the next release, you still have to test the lower bound somehow
04:43:37 <phadej> merijn: yes
04:43:43 <merijn> fendor: Why?
04:44:11 <phadej> fendor: some lower-bound is still "more correct" that all 10years worth of bytestrings
04:44:32 <phadej> fwiw, I just set lower-bound to whatever I use
04:44:34 <maerwald> in the end: bounds are guesswork
04:44:43 <merijn> maerwald: Yeah, more control would be nice, but it's better than nothing
04:44:44 <phadej> (or say, stackage LTS dictates)
04:44:58 <merijn> maerwald: That's why we have revisions :p
04:45:08 <phadej> "the solution we have is suboptimal, better to have solution at all"
04:45:09 <maerwald> merijn: yeah, to make things more complicated
04:45:11 <phadej> I don't understand
04:45:21 <phadej> better to *not* have solution at all
04:45:28 <phadej> let's just have [0,1,...] versions
04:45:36 <phadej> or better, hashes of contents
04:45:39 <fendor> merijn, well a pr began using an advanced feature of aeson, suddenly the lower-bound was incorrect
04:45:39 <phadej> who care about linearity
04:45:43 <maerwald> I use lower bounds
04:45:58 <maerwald> but they only reflect the version I started with when I created the package
04:46:06 <fendor> I still don't know how I could detect that, except for checking every funcion symbol when it was introduced
04:46:12 <merijn> fendor: 1) this is why I think every library should have @since annotations, 2) then your lowerbound is no longer what you develop against
04:46:34 <maerwald> PVP and all that only works with good tooling and CI
04:46:35 <phadej> yes, having wide lower-bounds have to be justified by actual needs
04:47:02 <phadej> (say, you have stack.yaml which exercises them)
04:47:04 <maerwald> and the tooling has to be convenient and ergonomic, otherwise ppl don't use it
04:47:11 <phadej> it won't be
04:47:17 <maerwald> stack.yaml is easier, so why care about package bounds :)
04:47:27 <phadej> "convenient expressive" - pick one
04:47:36 <phadej> maerwald: for cabal users
04:47:46 <phadej> s/stack.yaml/cabal.project.freeze/
04:47:46 <maerwald> I know, but the reality is, ppl don't
04:48:11 <phadej> anyway, if someone have build problems and the package in question doesn't have bounds
04:48:11 <fendor> merijn, indeed, but how should it be? the library was released a couple of times, should the lower bound in the repo be only the version I developed against and then always set a different lower bound?
04:48:22 <phadej> ... it's their problem
04:48:27 <merijn> fendor: That's what I mostly do
04:48:55 <merijn> fendor: Can always relax them later if someone really needs that
04:49:00 <merijn> (and has tested it works)
04:49:40 <maerwald> phadej: we have hackage trustees cleaning up after everyone :p
04:49:43 <jophish> is Taylor Fausak in here?
04:49:53 <merijn> maerwald: Good way to get them to get a burnout
04:49:57 <maerwald> :D
04:50:08 <fendor> merijn, so, you relax for every release the bounds afterwards?
04:50:21 <fendor> that sounds like a lot of work and error prone
04:50:24 <merijn> No, I update bounds on the latest version
04:50:32 <fendor> but on a new releasr?
04:50:33 <merijn> Older version I leave constrained
04:51:10 <merijn> fendor: I don't have so many dependencies on my package and the rate of PVP breaking release is honestly not so high for lots of packages
04:53:15 <merijn> Like, take directory
04:53:21 <merijn> the last PVP breaking release was in 2016
04:53:30 <merijn> Keeping that bound updated is hardly much work
04:54:03 <maerwald> servant does more of that
04:56:25 <merijn> Let's see if 8.10.2 fixes building stuff
05:03:03 <merijn> \o/
05:03:05 <merijn> builds now
05:18:08 <phadej> maerwald: FWIW, i'm not a trustee anymore.
05:18:16 <maerwald> I noticed 
05:18:28 <maerwald> gwils also 
05:22:54 <phadej> but there are plenty left still :)
05:55:08 <merijn> phadej: is cabal 3.4 still RC?
06:16:58 <merijn> heh
06:17:09 <merijn> text 1.2.4.0 is not buildable with GHC 8.10?
06:17:51 <maerwald> https://github.com/haskell/text/issues/279
06:19:55 <merijn> yeah, just found that, that's annoying, because it seems (TM) to work fine if I relax the bounds, oh well
06:32:06 <phadej> that's the infamous, "compiles but doesn't work"
06:32:21 <merijn> phadej: Worked well enough for me :p
06:32:27 <phadej> merijn: re cabal-3.4, yes, and will stay so until GHC-9.0 is released
06:32:33 <merijn> ah, ok
06:34:08 <merijn> phadej: Updating all my build instructions to something more modern (they still use 2.4 atm), but I'll just stick to 3.2 then
06:34:38 <maerwald> merijn: 3.4 has an important fix if you use lots of source-repository-package things
06:34:52 <merijn> maerwald: define "important"
06:35:15 <maerwald> they're not considered local packages anymore, so don't pull in test dependencies etc
06:43:49 * hackage language-docker 9.1.2 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-9.1.2 (lorenzo)
07:57:15 <AWizzArd> Search for `left 4`: https://github.com/AJChapman/formatting/blob/master/README.md    – why does formatting a 10 via `left 4 ' '` result in " 10" and not "  10" (1 vs 2 spaces)?
07:58:27 <AWizzArd> Ah okay, nevermind. I see that this html. In the raw readme source it *does* have two spaces.
07:58:47 <merijn> AWizzArd: Because html sucks ;)
07:59:00 <merijn> They should've use non-breaking space in the table
07:59:10 <merijn> breaking space are compacted in html
07:59:11 <AWizzArd> merijn: yeah
08:03:38 <merijn> Does anyone know if/how I can pass extra cabal flags for hie-bios to use?
08:08:18 * hackage cabal-install-parsers 0.4 - Utilities to work with cabal-install files  https://hackage.haskell.org/package/cabal-install-parsers-0.4 (phadej)
08:12:15 <merijn> ugh, why are github issues so terrible? I know an issue exists that I talked in and I just can't find it >.>
08:15:43 <phadej> in Cabal issue tracker? :)
08:15:57 <merijn> Yes, although it turns out, I'm in fact, just blind
08:16:25 <phadej> there are just too many issues
08:17:08 <merijn> Infinite yaks :)
08:17:32 <AWizzArd> Ambiguous occurrence ‘putStrLn’    for this use:    main = putStrLn ("Hallo" :: Text)
08:17:40 <merijn> AWizzArd: Well, yes
08:17:42 <AWizzArd> I know that putStrLn is not a method of some type class.
08:18:01 <merijn> It's ambiguous because you, presumably imported the text version of putStrLn
08:18:08 <AWizzArd> But is there a good reason why only on type class methods some dispatching/inference can occur?
08:18:08 <merijn> But the string version is in Prelude
08:18:29 <merijn> AWizzArd: Yes. That reason being: We don't want to go insane
08:18:41 <AWizzArd> (-:
08:18:54 <merijn> AWizzArd: "it's easy, just dispatch on the type!"
08:18:58 <merijn> Which seems easy enough
08:19:02 <AWizzArd> si
08:19:12 <merijn> Until you consider polymorphic types, typeclasses and how they all interact
08:19:16 <phadej> if you want to dispatch on type, write a typeclass :)
08:19:38 <phadej> type-directed-name-resolution doesn't mix well with type-classes
08:19:43 <AWizzArd> phadej: yes yes, that would help, agreed. I just wonder why this magic doesn’t work on non-method functions.
08:20:03 <phadej> or rather, "no one really thought about it, whether these can be mixed"
08:20:11 <AWizzArd> k
08:20:19 <AWizzArd> It just isn’t a trivial thing is what I take away.
08:20:22 <geekosaur> there have been multiple discussions of "type directed name resolution"
08:20:34 <phadej> AWizzArd: boring answer is that "name resolution" happens before type-checking
08:20:54 <merijn> AWizzArd: There's two factors: one beyond the trivial case you list it's very hard to figure out how the resolution should happen
08:20:56 <phadej> and no sane person want to mix them in GHC :)
08:21:00 <phadej> s/mix/combine/
08:21:27 <merijn> AWizzArd: And, much more importantly, if you do figure out the resolution method you now have to *memorise and remember it to read any Haskell ever*
08:21:29 <AWizzArd> pjb: compare this with your `title` uses.
08:21:33 <davean> if it didn't happen before, what would you be type checking?
08:21:54 <merijn> AWizzArd: You end up in Scala implicit territory where reordering imports changes how implicits are resolved and changes the behaviour of code
08:22:09 <merijn> AWizzArd: Which seems like the kinda thing sane people would like to avoid :)
08:22:18 <AWizzArd> merijn: uh, yess, didn’t know that one (:
08:24:43 <merijn> AWizzArd: C++ does support this via overloading and it's *hell*
08:24:55 <phadej> I think you can have sane-ish type-directed name resolution, but in the `putStrLn ("Hallo" :: Text)` it won't work
08:25:09 <merijn> I need 2 more phds to be able to confidently know what overload gets picked in all scenarios
08:25:37 <merijn> So, instead, everyone relies on "it mostly does the right thing, usually, so cross your fingers you don't mess up"
08:25:44 <phadej> e.g. it will effectively stop by saying "there are two functions named putStrLn, I cannot proceed"
08:26:07 <merijn> Of course C++ has the added "fun" that there's also implicit conversions, so it might do a conversion *and then* decide which overload to take
08:26:42 <merijn> I'd rather just add a qualified import and not have to think about ad hoc resolution schemes :)
08:27:03 <merijn> mpickering: ping?
08:27:04 <AWizzArd> merijn: right
08:27:42 <monochrom> Oh, C++ overloading. I thought you were talking about Haskell overlapping instances. :)
08:27:59 <merijn> AWizzArd: Anyway, if you go to the GHC wiki or google for haskell and "type directed name resolution" you should find a bunch of discussions on the topic. But in the end the consensus has always been "this is probably adding more pain than it removes"
08:28:43 <monochrom> IIRC C++'s resolution is very detailedly spelt out but it is lengthy and interwined, it takes lawyers.
08:28:45 <AWizzArd> Oki, makes sense!
08:29:24 <hpc> the @quote-y way to say it is after a certain point, type directed name resolution always resolves the name to "oh jesus" :D
08:30:25 <merijn> It's like "a better Num hierarchy" everyone agrees we should have a better one, but actually making one turns out to be surprisingly hard :p
08:30:38 <monochrom> @quote wrexem resolution
08:30:38 <lambdabot> wrexem says: "Its not my fault that your resolution is messed up because you are blind"
08:30:59 <merijn> monochrom: *everything* takes lawyers in C++
08:31:28 <merijn> I have some C++ code using an initialiser list that worked fine 3 years ago, but it's refusing to compile now and I'll be damned if I know why not...
08:31:42 <phadej> you can stick to core guidelines though, and then life will be easier
08:31:44 <merijn> The code hasn't changed in all that time, so must be something in clang *and* g++
08:32:04 <monochrom> This is why my prof said to keep the old compiler and the old OS.
08:32:23 <monochrom> You may also need to keep the old hardware.
08:35:45 <merijn> monochrom: My own damn fold for not having the compile step in my code so I forgot how I ever compiled it 3 years ago... >.>
08:35:59 <merijn> Automate all the things!
08:36:14 <merijn> s/fold/fault
08:36:19 <merijn> clearly to tired to English
08:36:40 <phadej> having --std... argument helps :)
08:36:53 <phadej> at least C++ has that, so there is a chance to compile old code with new compiler
08:37:00 <merijn> phadej: oh, I always use -std
08:37:11 <phadej> merijn: it helps to write it down too :)
08:38:17 <merijn> phadej: This is a leftover from the dark early days where I just migrated my codebase from python to Haskell
08:39:52 <merijn> phadej: My happiness is proportional to the percentage of orange in this plot: http://files.inconsistent.nl/sloc-time.png :p
08:43:25 <xsperry> to be fair, breaking changes happen in haskell world a lot more than in the C++ world
08:58:19 * hackage hadolint 1.18.1 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.18.1 (lorenzo)
09:07:52 <koz_> merijn: Yeah, both C and C++ _force_ you to become a lawyer in fairly short order.
09:10:49 * hackage cabal-plan 0.7.2.0 - Library and utility for processing cabal's plan.json file  https://hackage.haskell.org/package/cabal-plan-0.7.2.0 (phadej)
09:14:36 <texasmynsted> When I look at tutorials for Template Haskell, they often say "use ghci like this . . ."
09:15:00 <texasmynsted> oh. hmm. Going to try something before I finish my quesiton
09:16:31 <phadej> oh, when time-1.11 got released
09:16:41 <phadej> something to spend the rest of this weekend with
09:18:18 <monochrom> "timely release"
09:18:56 <phadej> 4 days ago already!
09:21:48 <texasmynsted> Okay. I have the TemplateHaskell extension loaded in my cabal file. When I do `cabal repl` I can then do `:m + Language.Haskell.TH` w/o error.
09:22:02 <texasmynsted> But then QuasiQuotes are not understood in the REPL.
09:22:06 <texasmynsted> I get an error. 
09:22:15 <texasmynsted> <interactive>:2:7: error: parse error on input ‘|’
09:22:51 <monochrom> QuasiQuotes is a different extension.
09:22:54 <texasmynsted> Here is an example https://gist.github.com/mmynsted/2056ad4a2b2960dab3808588cca12607
09:24:03 <monochrom> Oh, we call that quote, not quasiquote. Quasiquotes are user-defined, e.g., [myfunc| abc |]
09:24:06 <c_wraith> texasmynsted: in general, ghci doesn't enable an extension just because you loaded a file that has it enabled
09:24:39 <c_wraith> actually, I can't think of any cases where it does so
09:25:28 <geekosaur> it doesn't that I know of. ":showi language" iirc shows what extensions are active
09:25:42 <texasmynsted> okay
09:26:29 <texasmynsted> so it is ignoring my project.cabal file with the language extensions defined
09:27:10 <davean> If you wanted it to respect that, use cabal repl
09:27:49 <geekosaur> "When I do `cabal repl`"
09:28:28 <texasmynsted> Okay, inside of the REPL, if I explicitly do `:set -XTemplateHaskell` then it works as I expect.
09:29:05 <texasmynsted> I guess I need to read up on cabal to see why it is not reading the language extensions from the .cabal file.
09:29:29 <monochrom> It is certainly honoured in build mode.
09:29:40 <texasmynsted> davean, I did use cabal repl
09:30:27 <texasmynsted> Yes, when I build my project the .cabal file is used as I expect. When I just run `cabal repl` is does not
09:31:52 <texasmynsted> hmm. Also did not seem to read it when I did `cabal real --cabal-file thask.cabal`
09:31:58 <maerwald> texasmynsted: did you specifiy the library component?
09:32:34 <maerwald> cabal repl lib:<component>
09:32:42 <texasmynsted> no
09:34:03 * texasmynsted shrug
09:38:50 <texasmynsted> okay
09:39:15 <texasmynsted> At least I can set the extensions directly in the REPL. 
09:39:37 <texasmynsted> I can worry about why it is not loading as I expect another time
09:40:49 <texasmynsted> I am trying to see if it is worth the TH learning curve to use it to read a file of lines where each line has two words, into a list of pairs. 
09:41:43 <texasmynsted> The reason I would want to use TH is because it could learn how TH works, and I would rather read these at compile time anyway.
09:51:13 <merijn> texasmynsted: Also, note that ghci distinguishes "extensions in loaded files" and "extensions in the interactive session"
09:51:24 <merijn> :set and :seti respectively
10:04:34 <monochrom> You know what, I can't reproduce the problem.
10:05:11 <monochrom> "default-extensions:  TemplateHaskell" allows me to use quotes in cabal repl.
10:11:05 <texasmynsted> merijn oh thankyou
10:11:25 <texasmynsted> hm
10:11:33 <monochrom>  :set implies :seti
10:12:05 <monochrom>  :seti is useful when you want the option for your hand-entered things but not for the code you will :load
10:13:28 <texasmynsted> I was using `other-extensions` rather than `default-extensions`. When I use `default-extensions` it works as I would have expected. 
10:13:29 <texasmynsted> :-)
10:15:17 <c_wraith> ah, yes.  other-extensions is purely documentation.  I don't even know why it's there, really.  If there were compilers other than GHC practically available, it might matter...
10:16:18 <geekosaur> supposedly so it can verify that other extensions used in individual source files are supported by the selected compiler before building the project, as I recall it
10:18:04 <monochrom> Another is as in the user guide "In Cabal-1.24 the dependency solver will use [other-extensions] and default-extensions information"
10:18:22 <c_wraith> ... for what?
10:18:35 <monochrom> Heh I don't actually know.
10:26:44 <merijn> c_wraith: You know, for other non-GHC compilers
10:27:32 <merijn> (tbh, I'm in favour of not tying all out tooling to hard to GHC, because that only makes the challenge of making a non-GHC competitor that much more challenging)
10:27:39 <monochrom> But the "dependency solver" thing doesn't seems to be about other compilers.
10:28:37 <merijn> Sure, no clue what that's about it
10:29:18 <monochrom> "Cabal prior to 1.24 will abort compilation if the current compiler doesn’t provide the extensions"
10:29:54 <monochrom> That begins to sound like since 1.24 they have stopped dreaming "there could be another compiler".
10:31:07 <monochrom> Darn. Hugs was so promising.
10:31:36 <c_wraith> and using it between versions of ghc doesn't make that much sense. ghc will fail fast if it encounters extensions it doesn't know anyway
10:31:55 <geekosaur> how aboutother versions of the current compiler, which might have been considered at one point for dependency checking?
10:32:08 <c_wraith> I mean, the first thing it has to do when compiling is a topological sort considering imports.
10:32:16 <monochrom> I know right? It is not like "dependency solver says you need GHC 9.12 so let's download it right now".
10:32:44 <c_wraith> since that's parsing anyway, it can fail on an unknown extension at that point.
10:32:47 <geekosaur> stack...
10:33:40 <c_wraith> stack doesn't do anything like that, though. stack's philosophy is the opposite. it alone determines what to install, dependencies get no say
10:33:51 <MarcelineVQ> is -XPackageImports relevant
10:34:08 <monochrom> Yeah, stack, except stack is usually in the other direction "dependency solver says you need legacy GHC 4.6"
10:34:41 <geekosaur> right, but I can imagine someone thinking "let's provide rough feature parity, but our way instead"
10:35:40 <monochrom> MarcelineVQ: In what context?
10:35:57 <MarcelineVQ> cabal caring about extensions during solving
10:36:08 <monochrom> I think no.
10:36:23 <monochrom> But I really don't know.
10:45:50 <christo> hello
10:46:17 <christo> what is hoogle? 
10:46:32 <christo> is it like: searchable haskell documentation or something? 
10:46:38 <christo> for libs on hackage? 
10:48:07 <geekosaur> yes. you can try an online version covering the standard libraries at hoogle.haskell.org
10:48:39 <geekosaur> but you can also install it locally and index your own packages and their dependencies
10:49:32 <merijn> @hoogle (a -> b) -> [a] -> [b]
10:49:33 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:49:33 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
10:49:33 <lambdabot> GHC.Base map :: (a -> b) -> [a] -> [b]
11:07:03 <christo> ohhh
11:07:39 <christo> thx
11:19:19 * hackage binaryen 0.0.5.0 - Haskell bindings to binaryen  https://hackage.haskell.org/package/binaryen-0.0.5.0 (terrorjack)
11:49:19 * hackage gotta-go-fast 0.3.0.6 - A command line utility for practicing typing  https://hackage.haskell.org/package/gotta-go-fast-0.3.0.6 (callum_oakley)
12:01:02 <Uniaika> (/1
12:01:05 <Uniaika> (hmm.)
12:05:17 <zz01> I am new to the channel and also the language, I am coming from website recommendation this channel is the best and very helpful
12:05:40 <zz01> I would like to learn haskell, but I don't any programming experience in functional programming
12:05:51 <zz01> I have good background in C#
12:06:25 <Uniaika> if you don't want to jump too far from your comfort zone, F# is quite a decent programming language, based on .NET
12:08:59 <ddellacosta> zz01: if you want to get into Haskell, you have some references to crossover ideas that you can start with in C#, like linq https://devblogs.microsoft.com/pfxteam/tasks-monads-and-linq/
12:09:19 * hackage little-logger 0.3.1 - Basic logging based on co-log  https://hackage.haskell.org/package/little-logger-0.3.1 (ejconlon)
12:09:30 <ddellacosta> not that you need to start that way to start learning Haskell
12:10:29 <ddellacosta> but, I think it's pretty cool how C# has that specific connection 
12:10:40 <zz01> ddellacosta: thank you
12:10:51 <ddellacosta> sure thing
12:12:46 <dolio> I'm not sure LINQ is going to help much with learning Haskell.
12:13:20 <ddellacosta> that's fair, more just thinking that getting a feel for some of the ideas in a language they are comfortable with may ease things down the road when the same ideas pop up 
12:17:01 <dolio> It is a good example of how 'monads are just a hack for dealing with purity' is utter nonsense, though.
12:17:35 <ddellacosta> very true
12:18:10 <ddellacosta> I don't think I actually know of monads being used in a language outside of Haskell so effectively
12:18:21 <ddellacosta> *another example of
12:27:58 <c_wraith> They're used all the time in rust, they just can't be abstracted over.
12:30:02 <hpc> rust's Result sugar in particular is like being in a whole-program Either
12:30:30 <dolio> You can't in C#, either, which also shows you that the line people take in here about them only being useful because they can be abstracted over is also wrong. :)
12:32:27 <hpc> it's a little bit of both
12:32:35 <hpc> like how you don't see much CPS in python code
12:32:57 <hpc> even though it has "first-class functions"
12:33:28 <dolio> CPS just makes stack usage worse in python.
12:33:50 <Rembane> Is there an optimization needed to not bloat the stack? 
12:34:11 <hpc> well, that too
12:34:22 <dolio> You need 'proper tail recursion'.
12:34:35 <hpc> still, that hardly stops ruby programmers from doing the same thing
12:35:44 <dolio> Do you mean blocks?
12:35:53 <dolio> Those are a little less aggresive than CPS.
12:37:14 <dolio> It definitely influences the designs people use, tough.
12:37:25 <dolio> Having a good syntax for it.
12:37:26 <hpc> they result in the same sort of code
12:38:02 <Rembane> dolio: Got it. Does this imply that they have proper tail recursion in the Javascript engines, because I see Javascript code that looks awfully lot like CPS 
12:38:38 <dolio> Some might now, but they've been doing CPS a lot longer than that.
12:39:44 <hpc> setTimeout does a nice job of resetting things, in any event
12:40:38 <hpc> or all sorts of browser built-in asynchronous stuff really
12:40:47 <hpc> javascript tends to run in short bursts
12:41:07 <dolio> It's specific stuff that uses that, though, because there's basically no other choice. If you tried to just turn some loops into CPS or something, you'd have a bad time.
12:41:11 <Rembane> That's true. 
12:41:45 <dolio> They're using it for pseudo threading stuff, kind of.
12:46:18 <dolio> Lack of sensible handling for this doesn't make much sense, but that's another topic, I guess.
12:54:39 <dolio> Rembane: By the way, "proper tail recursion," is what Scheme calls it, but I think it's a bad name, because it's not about recursion.
12:55:34 <Rembane> dolio: Is it the transformation of a recursive function that passes some test into a while-function they call proper tail recursion?
12:55:50 * hackage FunGEn 1.1 - A lightweight, cross-platform, OpenGL/GLUT-based game engine.  https://hackage.haskell.org/package/FunGEn-1.1 (SimonMichael)
12:56:25 <monochrom> In Javascript and I suppose Python, you would both CPS and trampoline.
12:56:27 <dolio> It says that it must be possible to perform an unbounded amount of tail calls (in a bounded amount of space).
12:57:20 <monochrom> CPS eliminates non-tail calls. To manually turn tail calls to jumps, you trampoline.
12:57:32 <monochrom> s/ to / into /
13:00:52 <dolio> Specifically, if you only handle recursive procedures, CPS will ruin it, because CPS builds a heap-allocated function that does a ton of tail calls in a way that isn't obviously direct recursion.
13:01:17 <dolio> So you need the tail calls in the continuation to behave well, too.
13:01:29 <Rembane> It's turtles all the way down! 
13:01:37 <dolio> Otherwise you'll have an optimmized loop that builds a function that blows up the stack.
13:01:46 <monochrom> The ridiculous length people would go to obfuscate their source code, just because "high-level" languages don't grow out of "stack is limited, heap is unlimited".
13:02:14 <monochrom> forgetting that "I'm a high-level language, I am in a position to actually redefine what 'stack' and 'heap" mean".
13:03:47 <monochrom> Yeah you will want to do general tail-call optimizations, not just tail-recursion optimizations.
13:04:37 <Rembane> Isn't this what we have good compilers for? Or at least decent runtime systems? 
13:05:06 <dolio> Most people use languages that don't.
13:05:29 <dolio> Because they're industry standard and popular.
13:06:11 <dolio> Languages with good compilers/runtimes are for ivory tower academics.
13:07:12 <Rembane> Well, then I prefer the ivory tower languages.
13:17:07 <sm[m]> g'day all, I have released an update of https://github.com/haskell-game/fungen (simple 2d opengl-based game engine tested with ghc 8.8, 8.10)
13:37:54 <monochrom> gcc does tail-call optimization when -O2 or above. To be sure, C has quite a few gotchas, so gcc is conservative about it. Still, the optimization happens with normal examples I've tried.
13:38:32 <monochrom> In the Python case my recollection is Guido explicitly banned it, on ground of discouraging functional programming.
13:39:18 <dolio> Yeah, gcc is a good compiler, I imagine. I don't think this discussion really applies to it, though.
13:39:38 <dolio> There are other reasons you aren't doing CPS in C.
13:39:54 <koz_> monochrom: Well, not his stated reason, but that was the outcome.
13:39:59 <koz_> (stated reason was stack traces)
13:40:51 <dolio> Maybe he should read about how to do both stack traces and good tail calls. There are decades-old papers on it.
13:41:15 <koz_> dolio: Maybe, but argumentum ad serpentum, rofl.
13:42:49 * hackage FunGEn 1.1 - A lightweight, cross-platform, OpenGL-based game engine.  https://hackage.haskell.org/package/FunGEn-1.1 (SimonMichael)
13:43:52 <dolio> There are also papers on how to do a JVM-like security model with tail calls, so that argument also doesn't work. :)
13:44:05 <monochrom> Haha nice.
13:44:10 <larou> im struggling to define cons opperations on cyclic structures
13:44:45 <larou> im not sure if i can construct a mapping from the structures representation to the valid cons types
13:44:48 <monochrom> This is what they get for deriding "academia ivory tower".
13:44:58 <koz_> dolio: Hence, argumentum ad serpentum.
13:45:28 <larou> like, i can imagine something where i can only insert subsets of a particular shape
13:45:38 <monochrom> Sorry, what is serpentum?
13:45:59 <larou> eg, in a regular 2d plane, i cant just insert an extra vertex, i need to add an entire row or column at the same time
13:46:08 <larou> otherwise it messes up the shape
13:46:12 <koz_> monochrom: Python, snake, bad Latin.
13:46:17 <monochrom> Oh hahaha
13:46:31 <monochrom> Don't worry, I don't know Latin either.
13:46:34 <koz_> Relevant: https://twitter.com/KozRoss/status/1317929052477427712
13:46:56 <larou> erm, so, then, if you have higher genus surfaces - then you get complicated permissible concatinations/insertions
13:47:35 <monochrom> I was thinking "Cleopatra defied Octavia (future Augustus Caeser) by using a snake for suicide. Does that count as her agumentum ad serpentum against him?"
13:47:44 <larou> and since these could deform the shape, eg, changing the genus - then you have a path of successive permissible insertion operator types 
13:47:50 <koz_> Octavia_n_.
13:47:57 <koz_> 'Octavia' would be his daughter.
13:48:05 <monochrom> Oh oops. I knew "ia" had to be wrong.
13:48:09 <larou> and along different paths you would get different resulting shapes, and intermediate insertion types
13:48:13 <dolio> I thought it was his sister.
13:48:25 <koz_> dolio: Also a possibility.
13:48:44 <dolio> I suppose it could be both.
13:49:01 <dolio> Reusing names.
13:49:26 <koz_> Name shadowing!
13:49:29 <larou> and then, you would want to be able to determine the types of the insertion opperations, so that you could create the corresponding insertion operations as values
13:50:01 <larou> depending on which path was taken in successively altering the architecture 
13:50:40 <larou> such as if there was a way to generate elements to insert, such as if they have defaults such as zeros (eg, a zeroed neuron)
13:51:14 <larou> then a type level specification of the path taken over the branching choices of permissible insertion operator types
13:51:32 <larou> could be used to construct initial values of containers of the overall resulting shape
13:53:15 <larou> for example, if i have a higher dimensional torus, then i can take a plane section through it in various ways that give bands along which elements can be inserted to preserve the shape (there needs to be 4 edges to neighbours for each vertex - so you cant just inert a verted at some point without messing up the edges) 
13:54:05 <larou> and eg, you could imagine adding or removing punctures to get higher genus manifolds, again with a correspondingly typed insertion opperator 
13:54:21 --- mode: ChanServ set +o monochrom
13:54:25 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.1.242.183
13:54:25 --- kick: larou was kicked by monochrom (larou)
13:54:31 --- mode: monochrom set -o monochrom
13:54:52 <koz_> Wait, were they fogging?
13:54:55 <monochrom> (Don't hesitate to object, if you want them back.)
13:55:10 <koz_> I didn't see.
13:55:48 <monochrom> HIgh similarity to fogging, yeah.
13:56:04 <monochrom> has been like that for days.
13:56:44 <koz_> Yeah, that's definitely been a thing.
13:56:59 <koz_> So what, it's now called 'larouing'?
13:57:24 <monochrom> I think "fogging" it is. Like "xeroxing" even when you use a Canon. :)
13:57:49 <koz_> monochrom: Sure, can dig.
14:01:10 <Buntspecht> What does "fogging" refers to here?
14:01:58 <monochrom> You would have to look through past IRC logs (eg the urls in the channel topic) and look for the nick "fog".
14:02:41 <monochrom> I guess TLDR they mistook #haskell for personal twitter/blog.
14:02:55 <Uniaika> I another guy who does that
14:03:03 <Uniaika> day-long monologues
14:03:27 <Buntspecht> Oh, I thought it's a specifc term for some kind of bad activity :p
14:03:34 <Buntspecht> like "spamming"
14:03:39 <dolio> It is. :)
14:03:51 <koz_> It's a specific form of spamming.
14:03:56 <koz_> (a subtype, a dare say)
14:04:02 <dolio> Named after the perpetrator.
14:04:03 <koz_> s/a /I /
14:04:39 <Rembane> I'm considering building a larou-fog-bot and putting it in a very lonely chat room.
14:05:21 <koz_> Rembane: Are you truly _that_ bored?
14:07:53 <Rembane> koz_: Not yet, but it struck me that it would be a baller Dr. Evil move. 
14:08:03 <koz_> Rembane: Yes, this.
14:08:16 <Rembane> koz_: I want ... one. Million. Dollars!
14:08:30 <koz_> Rembane: *evil laughter*
14:08:50 <Rembane> ^^
14:21:15 <tomsmeding> the last IP that fog connected from is the same that larou has been connecting from this week
14:22:11 <tomsmeding> though I don't know what the ip address in the origin string of kiwiirc means exactly, it might be the kiwiirc instance
14:38:43 <maerwald> IRC needs threads, like slack has
14:39:18 <maerwald> then it would be one line instead of 1000
14:40:19 * hackage FunGEn 1.1.1 - A lightweight, cross-platform, OpenGL-based game engine.  https://hackage.haskell.org/package/FunGEn-1.1.1 (SimonMichael)
15:53:59 <texasmynsted> I am reading a `tsv` file to get my good/bad URLs into a List of pairs. This looks awkward, especially in the redirectMapToPair bit.
15:54:28 <texasmynsted> The `main` I simply have it printing the list that I want so I can see if it is what I expect...
15:54:48 <texasmynsted> Any suggestions on how to improve this? https://gist.github.com/mmynsted/bc2fc5c083c5d27ebfd5aab8bb8bc6c3
15:58:05 <texasmynsted> I am leaving TH for another day.
15:58:16 <texasmynsted> I am sure it would be a better solution. 
16:05:22 <texasmynsted> Is anybody here?
16:06:05 <koz_> texasmynsted: People are, but might be unresponsive.
16:06:12 <texasmynsted> heh
16:06:17 <koz_> It varies by time of day, and also by what you're asking.
16:06:17 <texasmynsted> I can relate to that
16:09:07 <texasmynsted> One thing that bothers me is there feels like there must be a better way to transform a data to a tuple
16:09:09 <texasmynsted> example
16:09:19 <texasmynsted> (RedirectMap bad good) = (,) bad good
16:10:12 <koz_> You have a FromRecord instance for tuples.
16:10:16 <texasmynsted> where data RedirectMap= RedirectMap { badUrl :: String, goodUrl :: String }
16:10:16 <koz_> So you can just use that.
16:10:24 <koz_> It'd be like
16:10:32 <koz_> (,) <$> parseField <*> parseField
16:10:33 <texasmynsted> oh. Thank you. I will check it out
17:01:22 <cheater> or use arrow
17:01:22 <cheater> s
17:16:21 <texasmynsted> or use arrows?
17:16:41 <koz_> Yeah, from Control.Arrow. However, in this case, I think that's a bit overkill.
17:17:47 <monochrom> Total distraction.
19:04:15 <gnumonik> Is ((LitP . stringL $ "Foo") : [VarP . mkName $ "xs" ]) the TH Pat the corresponds to ("Foo":xs), or am I doing that wrong? 
19:18:26 <koz_> gnumonik: No, because that should type as Q Expr, but what you have types as Q [Expr] I believe.
19:21:45 <gnumonik> er I forgot the ListP at the beginning. But wouldn't it just be a [Pat] as written? If I don't return it, it's not in the Q monad yet right? (Obviously I have to do that eventually to do anything useful with it)
19:22:18 <koz_> Oh, yeah, good point.
19:22:21 <koz_> But you get the idea.
19:22:33 <koz_> You want an application of the (:) constructor.
19:44:17 <proofofme> `print =<< Streams.toList is`   After this portion mentioned in mysql-haskell, how can I grab individual columns?  So for example, how could I print just some field called 'field', for example?
19:44:46 <koz_> That will dump _everything ever_ to stdout.
19:44:51 <koz_> You most probably do _not_ want that.
19:45:00 <koz_> It will also materialize your entire stream into memory first.
19:45:04 <proofofme> correct, just a couple of fields
19:45:08 <koz_> You most probably _also_ do not want _that_.
19:45:21 <koz_> So I would suggest looking at the type of stream it returns, and at the io-streams docs.
19:45:32 <koz_> If you've dealt with streaming before, it should look familiar.
19:45:46 <Squarism> God, im so stuck. I this should be doable with haskell and all its neat libraries / extensions - but I just dont know how. I tried to formulate my problem here : https://paste.ofcode.org/6TcXd6tnxnpqkEaGYNja2M
19:45:47 <proofofme> It returns an InputStream
19:45:57 <Squarism> I think this.... *
19:46:28 <koz_> proofofme: So read the docs around that type in io-streams.
19:47:03 <koz_> Squarism: Do you have a list separated by /?
19:47:36 <koz_> Also, proofofme, InputStream is _a_ type, but _not_ the type mysql-haskell gives back. From my memory, it's something like a pair of field headers and a stream of vectors of values.
19:47:51 <Squarism> koz_, well that should be the address in the end. 
19:47:54 <koz_> And you want something to represent a list separated by /?
19:47:59 <proofofme> yeah, it gives a column definition and InputStream tuple
19:48:26 <koz_> proofofme: So basically, this is what you're dealing with. You'd need to use whatever information is in the column defs to determine what you want.
19:48:46 <koz_> Then, for each element in the stream, fish out what you want, and tear apart the MySQLWhateverItIs sum type to get at the actual data.
19:49:02 <Squarism> koz: Basicall i want to achive lens libraries (get + map) in "mapLeaf"
19:49:40 <Squarism> but using textual addresses. Wrong address or empty slot returns Nothing
19:49:54 <koz_> Squarism: What's the ultimate goal of this thing?
19:56:34 <Squarism> the ultimate goal is : 1. A library user defines a datatype A. 2. All "leafs" in a value of the datatype A will yield "addresses" where data can be added using "setLeaf". 3. All "set" leafs (Any "Step a" value) in the datatype A value. So say A is defined as : data Pr1 = Pr1 { a :: Step Int, b :: Maybe (Step Bool) }. A value could be Pr1 { a = Step 11 "foo", b = Nothing }. "b" is an example of an unset value. 
19:57:30 <koz_> This sounds like something that could be rolled with like, Generic? Or generics-sop maybe?
19:58:18 <Squarism> so in point 2 above, the address "b/just" will be provided as a valid address. User fills in some data sends data + address to server, updates value of Pr1 with setLeaf
19:59:17 <Squarism> koz_, yeah, im trying to play with Generic instance but i feel the level is quite high for me. I just dont see the end solution playing around with it. 
19:59:53 <koz_> So you basically want a 'skeleton' of the data type to use as a 'direction' for something to go into an actual value of said data type?
20:00:04 <koz_> This is 100% a job for Generic or generics-sop.
20:01:30 <Squarism> Do you know of any library that relies heavily on Generic that might be able to give me inspriation?
20:01:53 <koz_> Squarism: generic-lens perhaps?
20:02:56 <Squarism> okey. Ill check it out
20:42:21 <former_ocaml_use> anyone have trouble compiling using "ghc main.hs" on macos catalina? getting this: Undefined symbols for architecture x86_64:  "___darwin_check_fd_set_overflow", referenced from:      _awaitEvent in libHSrts.a(Select.o)
20:47:20 <dsal> former_ocaml_use: Whatever ghc you've got is probably not right.  But that's not a thing people do in general, so something led you down a bad path.  Starting with cabal or stack or nix will got you a lot further a lot faster.  (I use stack and nix, so I don't know much about cabal, but people like it).  In any case, running the compiler directly is uncommon.
20:49:04 <former_ocaml_use> same error when using cabal, tried ghc to make it easier to repro for myself
20:50:35 <dsal> Where do you get the compiler?  I don't know The Cabal Way™, but with stack or nix, the platform-appropriate compiler is part of the build specification and it does the right thing for you.
21:04:50 <former_ocaml_use> hmm I think i got it from haskell-mode
21:05:06 <former_ocaml_use> I'll try reinstalling ghc and stuff
21:10:06 <koz_> Basically on Mac, the correct way is ghcup.
21:10:09 <koz_> Always and forever.
21:10:23 <koz_> This also lets you have multiple GHCs, and manage them individually, as well as update.
21:11:09 <dsal> I use both nix and stack on mac.  :p
21:11:31 <dsal> I've never tried ghcup, though.  So many factions we have.
21:11:39 <koz_> dsal: I'm trying to get into Nix, but only for three reasons.
21:11:51 <koz_> (basically, I want musl-linked fully static 32-bit applications)
21:11:58 <koz_> I'm so far not having much luck with that.
21:12:10 <koz_> Would you be able to tell me what's up with that dsal?
21:12:54 <dsal> nixos itself makes my life much better.  I've not really figured out the whole development mentality yet, though.  But I do have the ability to build stuff in various places and deploy it in others, so that's nice.
21:13:55 <dsal> I don't know anything about musl.  (just had to look it up to see what you were talking about).  I'd think creating a derivation with just those parts you care about would be more straightforward in nix than anywhere else, but I've not tried.  I'm pretty low end on my haskell.
21:14:08 <koz_> This is 100% a Nix problem.
21:14:26 <koz_> dsal: https://gist.github.com/kozross/73ca7429f23852ba5650a1a67524200a
21:14:48 <koz_> Key weirdness: https://gist.github.com/kozross/73ca7429f23852ba5650a1a67524200a#file-error-L159
21:20:48 <former_ocaml_use> installing with ghcup fixed my problem :O  thanks everyone!!
21:21:18 <koz_> former_ocaml_use: No worries. 'ghcup list' is one thing that you may find helpful. :D
21:38:15 <dsal> koz_: My computer's really very slow.  I started that a long time ago.  Between having an incredibly slow computer and a saturated network connection, it's taking me a while to reproduce your error.  I'm very much not an expert, though, so I'll probably just be like "yeah, I got that same error and also don't know what I'm doing."
21:38:28 <koz_> OK, don't worry about it then.
21:38:54 <dsal> There are folks in #nixos who know things, though.  It's a bit hit or miss.  I have really obscure questions that people who don't know the answers to helpfully try to answer.
21:39:00 <koz_> I found this, which may be somewhat enlightening: https://github.com/srid/neuron/blob/master/static.nix
21:39:22 <koz_> This leans on a fork of nixpkgs, so I might try that and see if it gets me someplace.
21:47:37 <former_ocaml_use> anyone here a haskell-mode user? in ocaml you can check the type by cursoring over it and C-c t is there an equivalent?
21:48:17 <aimee2> >
21:59:40 <former_ocaml_use> uh this might be a dumb question, but does anyone know where cabal puts the executable? I see a main.o file in the project root, but nothing else
22:00:02 <koz_> former_ocaml_use: You used cabal new-build I assume? Or cabal build on recent cabal?
22:01:45 <former_ocaml_use> cabal new-build
22:01:51 <bartemius> Hi, everyone!)
22:02:10 <former_ocaml_use> hi!
22:02:20 <koz_> former_ocaml_use: It'll be someplace in dist-newstyle.
22:02:31 <koz_> Named the same way as the name given in the executable stanza in your cabal file.
22:02:40 <koz_> bartemius: Yo.
22:30:58 <sm[m]> cabal exec -- which EXE
22:42:36 <koz_> sm[m]: TIL
22:46:00 <gnumonik> So just out of curiosity: I'm pretty sure you can't write a function in general :: Monad m => (a -> m b) -> m (a -> b). But could you write one for maybe, such that :: (a -> Maybe b) -> Maybe (a -> b)? 
22:46:32 <koz_> gnumonik: Try writing one.
22:46:43 <koz_> (namely, try to write a function of that second type)
22:53:22 <proofofme> I understand why this works:  `maybe (print "Error") (print) =<< Streams.read is`   How can I get something like this to work?  `maybe (print "Error") (print "Hi") =<< Streams.read is`
22:53:42 <gnumonik> I did, but all the fact that I can't figure it out proves is that I can't figure it out. I managed to do it for... Identity. I guess I'll keep trying. 
22:58:37 <Maxdamantus> gnumonik: it is possible, but it's just a case of taking some type with quantified variables and replacing one of the variables with a concrete type.
23:00:07 <Maxdamantus> gnumonik: eg, in `(a -> b) -> (b -> c) -> (a -> c)`, replacing `c` with `Int` to get `(a -> b) -> (b -> Int) -> (a -> Int)`
23:00:15 <Maxdamantus> f x y = 4
23:00:21 <Maxdamantus> er
23:00:24 <Maxdamantus> f x y z = 4
23:01:17 <Maxdamantus> You shouldn't actually be able to do what you wrote for `m = Identity`
23:01:31 <Maxdamantus> but `m = Maybe` is possible.
23:02:09 <Maxdamantus> Wait, nvm, `m = Identity` is also possible.
23:02:17 <gnumonik> f =  Identity $ \x -> runIdentity $ f x 
23:02:58 <gnumonik> er screwd up, should be "func f =  Identity $ \x -> runIdentity $ f x"
23:03:47 <Maxdamantus> The `m = Maybe` solution is a lot simpler.
23:13:26 <edwardk> gnumonik: you can write one that just returns Nothing, nbut it isn't canonical.
23:35:10 <koz_> Does anyone know how to inform Nix about where to find -lgmp and -lffi for a statically-linked Haskell executable?
23:35:19 <koz_> I dunno what exact phrase(s) I need in my default.nix for this.
23:39:44 <Ariakenom> koz_, dont u just include them as dependencies?
23:40:21 <koz_> Ariakenom: If I pastebin you my default.nix, can you show me how?
23:40:53 <Ariakenom> lets try
23:41:26 <koz_> https://gist.github.com/kozross/6f847d3e70e9641551c786b9d8ff18c9
23:47:53 <Ariakenom> add a "buildInputs = [libffi gmp]" in the mkDerivation dict
23:48:32 <koz_> Ariakenom: error: undefined variable 'libffi' at /home/koz/nix-practice/default.nix:17:23
23:49:19 <Ariakenom> nixpkgs.libffi nixpkgs.gmp
23:49:37 <Ariakenom> do you have 3 different nixpkgs in that .nix? :)
23:50:11 <koz_> error: anonymous function at /nix/store/77bfgydlx63813nk3d0ac0w2h8rn6da1-source/pkgs/development/haskell-modules/generic-builder.nix:13:1 called with unexpected argument 'buildInputs', at /nix/store/77bfgydlx63813nk3d0ac0w2h8rn6da1-source/lib/customisation.nix:69:16
23:53:29 <koz_> Ariakenom: This doesn't vom from nix, but still can't find the libraries: https://gist.github.com/kozross/6f847d3e70e9641551c786b9d8ff18c9
23:57:33 <Ariakenom> thats too bad. i dont think i can help more
23:57:34 <Ariakenom> "nix shell" is useful for testing.
23:58:53 <koz_> I'm basing my work on this: https://github.com/srid/neuron/blob/master/static.nix
23:59:08 <koz_> I think those --extra-lib-dirs= are needed, but I have no clue how they're being passed.
