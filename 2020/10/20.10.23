00:26:19 * hackage haxl 2.3.0.0 - A Haskell library for efficient, concurrent,and concise data access.  https://hackage.haskell.org/package/haxl-2.3.0.0 (SimonMarlow)
01:12:19 * hackage Z-Data 0.1.8.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.8.0 (winterland)
01:40:50 <dminuoso> jophish: Yes, it does In 3.4.
01:40:58 <dminuoso> It's --list-bin
01:41:01 <dminuoso> Until then you have two options
01:41:03 <jophish> thanks!
01:41:18 <dminuoso> 1) Under Linux you can do `cabal exec -- which packageName`
01:41:28 <dminuoso> 2) For windows compatibility you can use `cabal-plan`
01:41:41 <dminuoso> (Because 3.4 is fully released yet)
01:41:54 <jophish> ah of course, this is nicest I think: cabal exec -- which packageName
01:42:05 <dminuoso> jophish: If you want to use this inside the CI, make sure to pass -v0
01:42:11 <dminuoso> So cabal doesn't output other stuff
01:42:23 <jophish> wouldn't other stuff be on stderr?
01:42:27 <jophish> or shouldn't perhaps
01:42:43 <dminuoso> In experience you want -v0
01:43:17 <dminuoso> cabal outputs a lot of stuff on stdout, but even when you `build` first, our CI was broken a few times mysteriously because cabal output other stuff
01:43:18 <jophish> right, thanks
01:43:36 <jophish> yeah, I've always found that a little weird
01:43:58 <dminuoso> Might just be an issue due to the way we run our CI. At any rate, specifying -v0 is good.
01:59:03 <merijn> 3.4 is blocked on GHC 9.0 release
02:18:35 <maerwald> @hoogle delete
02:18:36 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
02:18:36 <lambdabot> GHC.OldList delete :: Eq a => a -> [a] -> [a]
02:18:36 <lambdabot> Data.IntMap.Internal delete :: Key -> IntMap a -> IntMap a
02:19:07 <maerwald> > delete 1 [1..]
02:19:10 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
02:21:17 <int-e> > delete 1 [1,1,1]
02:21:20 <lambdabot>  [1,1]
02:21:31 <maerwald> hmm
02:21:41 <maerwald> so it's actually `deleteFirst`
02:21:46 <hc> > length (delete 1 [1..])
02:21:52 <lambdabot>  mueval-core: Time limit exceeded
02:21:55 <int-e> maerwald: yeah, which may be surprising.
02:22:09 <maerwald> Such typesafety :p
02:22:16 <ski> > [0,0,0] \\ [0,0]
02:22:17 <lambdabot>  [0]
02:22:25 <dminuoso> uhh
02:22:26 <maerwald> that's gross
02:22:31 <dminuoso> ouch
02:22:40 <int-e> multisets
02:22:53 <dminuoso> Principle of maximum surprise
02:23:16 <dminuoso> Can't we offload all these things to Data.Surprise.Surprise and out of Prelude?
02:23:21 <int-e> it is what it is
02:23:22 <int-e> no!
02:23:34 <int-e> without warts, what would we complain about?
02:23:43 <dminuoso> Dunno. Other languages?
02:23:43 <int-e> what little curiosities would we discuss?
02:23:47 <int-e> it would be BORING
02:24:24 <int-e> next you'll be taking away NaNs and signed zeros from IEEE floating point numbers
02:25:01 <dminuoso> These are not a problem, but I do want IEEE conform traps
02:25:02 <ski> or `n+k'
02:25:03 <int-e> (was that too much?)
02:25:32 <int-e> ski: I don't miss n+k patterns, somehow.
02:25:50 <merijn> int-e: Abolish value NaN, join us in trapping NaN paradise!
02:26:09 <int-e> > error "it's a trap!"
02:26:11 <lambdabot>  *Exception: it's a trap!
02:26:20 <merijn> int-e: Basically, yes :p
02:26:34 <merijn> int-e: It's even IEEE-754 compliant!
02:26:41 <int-e> merijn: I just wonder how much code that would/will break.
02:26:49 <dminuoso> int-e: Dunno, I have luxury problems rather
02:26:50 <dminuoso> % type f <> g = Either f g
02:26:51 <yahb> dminuoso: 
02:26:52 <dminuoso> I dont want that to work.
02:27:06 <merijn> I'm torn on type operators
02:27:14 <merijn> On the one hand "ugh"
02:27:19 <dminuoso> Type operators are fine, but they should demand a colon!
02:27:24 <merijn> On the other hands, prefixing everything with : is also "ugh"
02:27:28 <dminuoso> I think it used to be that way in 6.x or 7.x
02:27:41 <merijn> Up until mid 7.x, I think
02:27:56 <dminuoso> Right. There's so many places where quantifying over an operator makes so much more sense
02:28:02 <merijn> Personally I'm offended much more by TypeInType and refuse to acknowledge it's existence
02:28:03 <dminuoso> All the profunctor stuff for example
02:29:00 <int-e> (~>) is the perfect type variable for categories and arrows...
02:29:46 <dminuoso> I mean if you look at Servant, it's not even annoying to have colon prefixes for type operators.
02:29:59 <int-e> It
02:30:20 <int-e> It's ugly for commutative things... But then again we can have :*: and :+:...
02:30:52 <int-e> (modulo isomorphisms)
02:31:25 <dminuoso> Overally, I think we'd pull more value from type operator variables than that
02:31:51 <dminuoso> It's a little bit of visual noise vs effectively moving things that make more sense as infix into prefix position
02:53:19 * hackage dropbox 0.0.0 - Dropbox API client  https://hackage.haskell.org/package/dropbox-0.0.0 (Jappie)
02:57:18 * hackage dropbox 0.0.1 - Dropbox API client  https://hackage.haskell.org/package/dropbox-0.0.1 (Jappie)
03:05:49 * hackage dropbox 0.0.2 - Dropbox API client  https://hackage.haskell.org/package/dropbox-0.0.2 (Jappie)
03:13:48 * hackage dropbox 0.0.3 - Dropbox API client  https://hackage.haskell.org/package/dropbox-0.0.3 (Jappie)
03:19:01 <tomsmeding> quick development ^
03:21:45 <dminuoso> Modern development! Release early and release unfinished.
03:22:12 <dminuoso> otoh, I have half a dozen packages awaiting release, but I've never found the time to finis them. :(
03:22:22 <dminuoso> Can't seem to find the middleground here
03:58:21 <maerwald> There's actual research backing up the "release early, release often" mantra. But my impression is that it doesn't normalise for context: most of the time ppl have no idea what they are doing. Then quick feedback is all you got, lol
04:11:49 * hackage dropbox 0.0.4 - Dropbox API client  https://hackage.haskell.org/package/dropbox-0.0.4 (Jappie)
04:11:52 <[exa]> maerwald: people make the best tests
04:18:50 * hackage aws-lambda-haskell-runtime 3.0.5 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-3.0.5 (NickSeagull)
04:28:34 <merijn> There's some people uploading stuff to hackage that doesn't even compile
04:29:02 <merijn> I'm not even talking "dependency bounds are wrong", I mean "straight up syntax error"
04:29:21 <merijn> I wish people would do the bare minimum testing at least, before cluttering shared resources
04:29:54 <merijn> The repo doesn't even exist
04:30:36 <merijn> oh, that was a typo in the cabal file
04:30:49 <merijn> I'm going to bet this person isn't aware of release candidates >.>
04:32:02 <hc> merijn: yeah, it is a bit difficult to acclimate to... indeed, the release canditate feature is not-100%-obvious
04:32:10 <int-e> Hmm, maybe they're using a non-cabal build tool by default :/
04:32:33 <merijn> hc: candidate is the default, though?
04:32:36 <hc> then again, adding some checks to reject stuff that doesn't copmile sounds doable
04:32:45 <merijn> hc: Not really
04:32:49 <hc> merijn: is it? I always explicitly search for it
04:33:02 <merijn> hc: Because then anything depending on native libraries that are not on the builders fails
04:33:09 <merijn> hc: How are you uploading, then?
04:33:10 <hc> merijn: oh, true.
04:33:13 <hc> s/compile/type check maybe?
04:33:25 <int-e> you can't even check whether there's a build plan, because of C dependencies and possible platform-specific packages
04:33:50 <int-e> (not easily at least)
04:34:10 <merijn> hc: The hackage upload page (from clicking the link) has them at the bottom (this should perhaps be at the top, before the upload link/button)
04:34:15 <hc> you could require manual review by maintainers for packages that don't compile on "stardard hardware" then?
04:34:19 <merijn> hc: https://hackage.haskell.org/upload
04:34:42 <int-e> there is an upload page?
04:34:45 <merijn> hc: And "cabal upload" requires you to add --publish to upload a non-candidate version
04:34:49 <merijn> int-e: Yes :p
04:34:56 <int-e> fancy
04:35:12 <hc> int-e: yes, it's actually a very open infrastructure imho
04:35:18 <merijn> Although I just use "cabal upload", since it's integrated with my password manager
04:35:19 <hc> very low entry bar to contributing
04:36:12 <int-e> hc: I never went looking for an upload page... I always just used `cabal upload`.
04:36:24 <hc> ah ok, I see
04:36:41 <hc> I always used cabal sdist, then find to find the tarball and then uploaded it via the file upload feature
04:36:49 <hc> much later did I learn there is an upload command
04:36:55 <int-e> It's just so easy to miss things that you're not looking for.
04:37:04 <hc> true that!
04:37:47 <hc> I tend to judge things these days by how easy/hard they make it for me to learn how to do what I am trying to do. (unless, of course, they require me to learn novel new concepts I haven't heard of before and that actually teach me something:)
04:38:08 <hc> so by this standard, for example, I like hetzner cloud a lot and AWS not so much...
04:55:05 <[exa]> ...there's no testing/review in hackage at all?
04:57:45 <infinity0> i have some 3rd-party code that operates lazily on the front of a String, and some other 3rd-party code that operates lazily on the front of a lazy ByteString
04:58:09 <infinity0> to interoperate the two, i'm keeping my data as a lazy ByteString, but then converting it to a String using LBS.pack/unpack
04:58:26 <merijn> [exa]: No
04:58:43 <merijn> [exa]: Who did you imagine would do that?
04:58:50 <infinity0> however if i do this many many times, i will build up a deep thunk of pack (.. unpack ( .. pack ( ... unpack ) ... etc, is there any way around this?
04:59:08 <merijn> infinity0: Stop...please...you're going to make me cry
04:59:22 <infinity0> so is the answer "no"?
04:59:34 <merijn> The only way that pack/unpack you're using would work is if you are using Char8
04:59:43 <merijn> And if so, I'm going to have to send my hit squad after you
04:59:52 <infinity0> i'm using Char8, that's beside the point of my question though
05:02:29 <merijn> I disagree :) Doing that conversion once is evil enough that I'm quoted for hating on it (https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad). Doing it repeatedly is *terribly* broken
05:03:44 <hc> merijn: lol on that quote
05:03:59 <merijn> Ideally one (or both) of those 3rd party libraries exposes another way of interacting with it, but that's hard to say without knowing which libraries
05:04:02 <merijn> hc: #facts
05:04:38 <infinity0> merijn: that problem doesn't apply to my use case, i'm only interested in the issue mentioned in my question
05:04:51 <arahael> Meh, char8 probably still makes sense in some situations, such as where you have mixed-encoded strings.
05:05:31 <merijn> arahael: No, because then you just have a binary blob and should be operating on ByteString only
05:05:45 <infinity0> the issue is about interoperating between two pieces of code that expect those two different types, yet it would seem the pack/unpack conversion would become more inefficient the more you interleave the operations, which is a shame
05:07:41 <arahael> merijn: I really shouldn't engage #haskell when my glenfiddich is running out. ;)  But I'll persist!  What if you were dealing with an sqlite blob of unspecified encoding?
05:08:29 <merijn> infinity0: It's not about "more inefficient", but about "is this fundamentally broken?". Either one (or both) of those libraries are exposing the wrong type in their API (in which hopefully there's a right one too) *or* what you're doing is just broken and can't work correctly. I dunno which of those is true. But I don't know the answer to "how can I make the broken thing faster"
05:08:40 <merijn> arahael: ByteString
05:08:59 <arahael> merijn: Oh, hang on - char8 isn't actually 8-bit clean is it?
05:09:03 <merijn> arahael: No
05:09:14 <arahael> merijn: Well, then that dies right there.
05:09:15 <merijn> arahael: It's just "lol, let's just drop all non-ascii input"
05:09:28 <arahael> Yeah, I just realised why it's so bad, again.
05:09:43 <infinity0> merijn: "this is fundamentally broken" is a subjective judgement, i don't have the time to go into that type of philosophical debate
05:09:44 <hc> maybe move it to the ByteString.Yolo subpackage to make this more clear?
05:10:03 <merijn> hc: I have campaigned for it's removal multiple times
05:10:26 <infinity0> the fact that you had to write a blog post about it means that "for all real-world situations, it results in incorrect behaviour" is not true, i would really just like to focus on my repeated unpack/pack question in terms of efficiency
05:11:03 <infinity0> you can think about it in terms of some unspecified types A and B if it makes you more comfortable..
05:11:04 <merijn> infinity0: That problem is unsolvable
05:11:11 <hc> infinity0: when you ask a hacker a simple question, you might get a long and possible philospophical answer ;p
05:11:18 <infinity0> fair enough...
05:11:25 <merijn> "I'm repeatedly computing the same thing, how do I make it fast?" 'well...stop doing that'
05:11:45 <merijn> If you're encoding the same string, just, like, save the result and reuse it?
05:12:10 <merijn> And if you're *not* encoding the same string, then I fail to see how you could convert it faster than "converting it"
05:14:29 <infinity0> i'm repeatedly decoding a stream, that's the thing, and it could either be A or B
05:14:36 <arahael> merijn: When someone wants to "focus" on doing something efficiently, they don't always mean in computer time, even if they say that. ;)
05:16:23 <merijn> infinity0: Incidentally, replacing Char8.unpack with "T.unpack . decodeUtf8With lenientDecode" will give you the exact same type with a *much* more robust and *much* less bug-prone behaviour
05:16:34 <infinity0> it's reasonable that a decoding API gives me (leftovers, result), but the two different APIs have different types for "leftovers"
05:17:04 <infinity0> merijn: thanks, yes i thought something like that must be possible, unfortunately it still would be inefficient due to the thunk build-up as if i understand right
05:17:20 <merijn> (since it will 1. work correctly for any UTF-8 unicode, 2. gracefully handle errors if it's *not* UTF-8. As opposed to Char8 which will just silently corrupt your data)
05:17:39 <merijn> infinity0: Any conversion to String is *always* going to be inefficient
05:17:48 <merijn> Given that string easily takes up ~24 byte per character
05:17:54 <merijn> and ruins your cache
05:18:38 <[exa]> merijn: like, the users at least... :D
05:18:54 <infinity0> well laziness could help with that, if only pack was "smart" enough to recognise an "unpack (...)" thunk and actually destructure it instead of building on top of it
05:19:18 <merijn> [exa]: Well, there's the expectation that users do, but it doesn't hold as you see
05:19:22 <arahael> infinity0: You mean fusion? :)
05:19:25 <merijn> infinity0: That's not possible with ByteString
05:19:39 <[exa]> merijn: moderation/banhammer is not available?
05:19:49 <merijn> infinity0: To create a ByteString it *must* be copied in full
05:20:01 <infinity0> sorry, i am talking about Lazy.ByteString here
05:20:05 <merijn> [exa]: In theory, sure, in practice there's no process
05:20:18 <merijn> infinity0: Lazy ByteString is just [Strict.ByteString]
05:20:55 <[exa]> well then it's marvelous that the hackage is in such a good state
05:21:01 <merijn> The chunk size depending on how/what creates the lazy list
05:21:11 <infinity0> right, you only need to copy the first part of it, when creating one lazily
05:21:45 <infinity0> arahael: that only happens at build-time not run-time conditionally AIUI. i'm pretty sure what i mentioned is impossible with today's haskell but i thought perhaps there might be some other strartegy i didn't know about 
05:22:36 <arahael> infinity0: When I deal with haskell, I rarely try to think about compiletime vs runtime. I just accept that all the types are resolved at compile time.
05:23:41 <infinity0> well, i also care about runtime performance
05:24:44 <merijn> infinity0: Which 2 libraries are this?
05:25:04 <infinity0> Serialise vs Read
05:25:10 <merijn> oof
05:25:17 <merijn> As in the Read typeclass?
05:25:22 <infinity0> yeah
05:25:27 <merijn> And you care about performance?
05:25:41 <merijn> Because Read's performance is notoriously *god awful*
05:25:51 <merijn> Just, like, incredibly bad
05:26:16 <infinity0> right, for interactive user session is fine, but having it degrade on a O(n^2) basis sounds bad even for an interactive user session
05:26:20 <merijn> What are you trying to read?
05:27:43 <infinity0> a stream of a bunch of objects, that could either be Serialise or Read
05:28:29 <arahael> When I had to do a Read thing, I made my own read typeclass.
05:28:56 <merijn> infinity0: And you don't control what creates this input (i.e. there's no way to replace Read with something else?)
05:29:22 <infinity0> i could replace Read with perhaps JSON, that is another option i guess. mostly Read is convenient to derive and carries no dependencies
05:30:03 <merijn> If you use Serialise already anyway, why not just derive Serialise?
05:30:07 <infinity0> the underlying question regarding "runtime fusion" was interesting though
05:30:34 <infinity0> i am already deriving Serialise. the idea is to have a fast+binary option but also a easy-friendly-manual option
06:24:05 <dminuoso> maerwald: Is there a way to select a version with ghcup without changing the default?
06:24:22 <maerwald> dminuoso: what do you mean exactly?
06:24:34 <dminuoso> So we have a CI node with multiple GHC versions installed
06:24:43 <maerwald> cabal build -w ghc-8.8.4?
06:25:11 <dminuoso> maerwald: Cunning.
06:25:22 <merijn> That's my local setup too :p
06:25:23 <dminuoso> Can ghcup give me the path?
06:25:36 <maerwald> dminuoso: what path?
06:25:36 <merijn> I just have all ghc's in my path (latest first)
06:25:46 <dminuoso> merijn: The path to an installed ghc
06:25:51 <merijn> So "ghc" defaults to the latest and specific version go to those
06:25:52 <maerwald> dminuoso: ghcup paths are predictable
06:26:02 <maerwald> ~/.ghcup/ghc/8.8.4/bin/ghc or something
06:26:28 <dminuoso> maerwald: Well it'd still feel better if there was a sort of `--list-ghc` command, such I could say `cabal build -w $(ghcup --list-bin ghc-8.6.5)` or some such
06:26:48 <dminuoso> Rather than encoding internals of ghcup into CI job descriptions
06:26:49 <maerwald> You don't trust your PATH?
06:27:06 <dminuoso> maerwald: Again, I have multiple concurrent GHC versions installed
06:27:31 <maerwald> cabal build -w ~/.ghcup/bin/ghc-8.8.4
06:28:59 <dminuoso> I still feel like ghc should offer plumbing commands.
06:29:01 <dminuoso> *ghcup
06:29:20 <merijn> lifehack: https://github.com/merijn/dotfiles/blob/master/dotfiles/bash_env#L24-L28 ;)
06:29:20 <merijn> Needs some tweaking to match ghcup's paths, though
06:29:40 <merijn> dminuoso: So, if you have them all in your path then "ghc-8.8.4" will "just work"
06:29:58 <maerwald> I don't really understand the problem here
06:31:41 <dminuoso> merijn: Ah, indeed they are!
06:31:57 <dminuoso> That's nice and works well
06:32:16 <dminuoso> Has the added advantage that the CI doesnt make assumptions about ghcup being installed
06:32:16 <merijn> dminuoso: Then the trick is just to have the right "default" GHC first so that "ghc" pick the right one (which might not be important for CI)
06:32:22 <dminuoso> It just demands a particular GHC version to be in path
06:32:25 <dminuoso> :)
06:32:37 <dminuoso> merijn: in case of ghcup, ghc itself is a symlink managed by ghcup
06:32:38 <dminuoso> I didnt know that
06:32:43 <dminuoso> I thought ghcup did PATH manipulation
06:33:03 <dminuoso> Cheers this is good
06:33:47 <maerwald> dminuoso: no, you have to modify PATH yourself, that's why we get mac users every day asking here how to do that
06:33:56 <dminuoso> heh
06:33:58 <dminuoso> fair enough
06:34:05 <dminuoso> well, at any rate. merijn's suggested answer is good :)
06:34:49 <maerwald> if you don't want to expose the symlinks, you can just export ~/.ghcup/ghc/<ver>/bin
06:58:19 * hackage path-io 1.6.2 - Interface to ‘directory’ package for users of ‘path’  https://hackage.haskell.org/package/path-io-1.6.2 (mrkkrp)
07:12:19 * hackage urbit-airlock 0.1.0.0 - Talk to Urbit from Haskell  https://hackage.haskell.org/package/urbit-airlock-0.1.0.0 (bsima)
07:39:19 <carter> merijn: you’re off #numerical-haskell just when it’s picking up again ;)
08:30:49 * hackage mu-avro 0.4.0.1 - Avro serialization support for Mu microservices  https://hackage.haskell.org/package/mu-avro-0.4.0.1 (AlejandroSerrano)
08:46:24 <ulidtko> does stack allow to pick only the lib component (and ignore/skip the exe:'s) of a package from extra-deps ?
08:48:55 <ulidtko> i see that stack allows passing flags to extra-deps... but this package has no flag to disable the exe: component
08:53:01 <ulidtko> fork it you say? well maybe, vendoring this one will certainly work, but I don't know how many more deps will need vendoring like that
08:54:01 <lep-delete> i feel like this is impossible but let's say i have a function `f :: (Read a) => String -> [a] -> [a]; f v xs =  read v : xs` is it possible to supply @a at runtime? like from a typerep or smth?
08:54:28 <merijn> lep-delete: Well, tht sounds like a scary terrible idea :)
08:54:47 <lep-delete> eh, maybe, mostly lazy
08:55:32 <lep-delete> (i could go into my specific use-case but i *think* the above should give the general idea)
08:56:25 <ulidtko> lep-delete, the question is, why don't you know the specific `a` at `f` call site
08:56:54 <ulidtko> and where the "runtime" choice of `a` comes from
08:56:58 <merijn> A better question would be "are you really sure you wanna use Read?" :p
08:57:06 <ulidtko> that, too
08:57:07 <lep-delete> no, but Read is the closest
08:57:13 <lep-delete> i would use some binary serialisation
08:57:20 <lep-delete> let me get into my use-case
08:59:20 <lep-delete> i have a data type with more structure than a list but let's use a list for now. i want a program where i can supply a string v, then read a list xs::[a] from a file and have read v:xs written back to that file. now i want to be able to use that program for [Int], [Real], [Maybe Int], you get it w/o recompiling it for every new file
09:00:08 <hyperisco> so I have strings and I want a reasonably unique hash for each string… what is my simplest path? cryponite looks possible but complicated
09:00:31 <monsterchrom> How do I tell your program "I want [Int]"?
09:00:52 <monsterchrom> What is the exact syntax, for starters? (Next will be "what is the semantics of that syntax?")
09:00:54 <lep-delete> either i provide it or read it from a file
09:00:59 <hyperisco> like, md5 :: String -> String would make me happy
09:01:43 <lep-delete> i dont know enough about Data.{Data,Typeable,Dynamic} to say whether it's possible or not
09:01:51 <ulidtko> lep-delete, your serialization format will need to have something like a tagged-union
09:01:51 <monsterchrom> What is the exact syntax, for starters? (Next will be "what is the semantics of that syntax?")
09:02:03 <ulidtko> then you simply case match on it
09:02:15 <ulidtko> here, look, reading images https://github.com/Twinside/Juicy.Pixels/blob/master/src/Codec/Picture.hs#L426-L435
09:02:34 <ulidtko> it's really simple and there's no "high level" "type magic" involved
09:02:40 <lep-delete> sure but a tagged union would need like all possible cases in beforehand, no?
09:02:55 <lep-delete> im aware of the "normal" way
09:02:57 <monsterchrom> What are your "all possible" cases?
09:03:12 <monsterchrom> I was trying to extract that from "what is the exact syntax?"
09:03:37 <ulidtko> yes, of course; otherwise what exactly would you mean by the serialization format ?
09:03:43 <monsterchrom> Anyway talking only in the "abstract" is the root of all evil.
09:04:07 <ulidtko> like, what monsterchrom says, define concretely what you need
09:04:52 <lep-delete> simple example as above, i want the user supply a string value, have it `read` and append it to a list, which is stored `show`ed in a file
09:05:03 <lep-delete> so anything that can be (Read a, Show a)
09:05:21 <lep-delete> or ( ToJSON a, FromJSON a), or whatever
09:05:49 <ulidtko> use Json Value then?
09:05:55 <ulidtko> the untyped thing
09:06:09 <monsterchrom> If you say, "all legal Haskell types", you will be linking the totalily of GHC. You don't want to go there.
09:06:13 <lep-delete> well i have a concrete type for each file
09:06:42 <monsterchrom> HOW MANY TYPES ARE THERE?
09:15:59 <dolio> A proper class.
09:16:09 <monsterchrom> heh
09:16:49 * hackage gopro-plus 0.4.1.0 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.4.1.0 (dustin)
09:20:20 * hackage happstack-server 7.7.0 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.7.0 (JeremyShaw)
09:31:29 <Guest45505> im wondering, how many thread can i open in concurrency within a haskell programm ? do one thread === one CPU core ?
09:32:03 <Rembane> Guest45505: What kind of threads? 
09:32:22 <Guest45505> those that you open by calling forkIO for example
09:33:08 <texasmynsted> I know this is a terrible question but . . . There are many options for writing "shell scripts" using Haskell. Too many for me to select one. 
09:33:42 <c_wraith> Guest45505: So...  this is actually sort of complex, because GHC has a couple options that completely change how threads work.  But in no case is a GHC thread an OS thread
09:33:50 <texasmynsted> If my goal was to improve my Haskell skill, especially for streaming and concurrency, what would you recommend?
09:34:26 <Rembane> texasmynsted: Go for the turtle one! 
09:34:38 <monsterchrom> "Green threads", i.e, many Haskell threads cramped to N cores, you choose N.
09:34:49 <Rembane> texasmynsted: https://hackage.haskell.org/package/turtle
09:34:55 <monsterchrom> Even if you have 64 cores you can tell the RTS to use just 2 cores.
09:35:15 <monsterchrom> In fact "green threads" is more nuanced than that.
09:35:19 <c_wraith> Guest45505: GHC has two different options for runtimes that can be linked in to programs it compiles.  One uses a single thread for all Haskell code, which lets it skip all kinds of locking and synchronization primitives.
09:35:20 <texasmynsted> why turtle. That is . . . not what I expected. 
09:35:54 <c_wraith> Guest45505: the other is what monsterchrom is describing, where it can split the Haskell threads across multiple OS threads.
09:35:54 <monsterchrom> But if you know Java's "green threads", that's what we have too.
09:36:56 <texasmynsted> lol. First thing it says is install Stack. (If I use turtle it will not be with Stack.)
09:37:21 <Rembane> I propose that you can for all practical intents and purposes have an infinite amount of "green threads" and things will work just fine. 
09:37:36 <Rembane> texasmynsted: What was what you expected? 
09:37:39 <Guest45505> monsterchrom ok i see, thats much clearer for me now, thanks
09:39:32 <texasmynsted> Shell-conduit or something?
09:42:17 <Rembane> Cool, I have never used it. :)
09:46:54 <ulidtko> texasmynsted, best option for shell scripts is... bash.
09:47:21 <ulidtko> however -- check out https://www.shellcheck.net it's written in haskell if that gives you the warm fuzzy feeling
09:50:01 <texasmynsted> ulidtko: I agree with you. I just mean for things that "outgrow" a shell script.
09:51:36 <ulidtko> yes, that happens all the time. either rewrite it, or deal with it (shellcheck is really helpful, also following consistent style)
09:53:37 <texasmynsted> Yes, I love shellscript.
09:53:45 <texasmynsted> I mean shellcheck
09:53:55 <texasmynsted> I have it integrated into vim
09:54:20 <ulidtko> as for rewriting options: I sort of fail to see the point to "emulate" bash and try to make it look like shellscript...
09:54:27 <ulidtko> same
09:54:56 <ulidtko> https://hackage.haskell.org/package/HSH-2.1.3 using this one, you can spawn processes and pipes "just like" in bash
09:55:31 <ulidtko> but all the ['extra', 'syntax'] makes you really want to go back to bash instead
09:56:22 <ulidtko> so, a good linter like shellcheck really hits the sweat spot IMO
09:56:48 <ulidtko> (*sweet haha)
09:57:34 <texasmynsted> I am not trying to emulate bash. Rather I am trying to find the best way to interact with shell processes that do not have a haskell module. 
09:58:36 <texasmynsted> hmm. all good points
10:02:19 * hackage happstack-server-tls 7.2.1.1 - extend happstack-server with https:// support (TLS/SSL)  https://hackage.haskell.org/package/happstack-server-tls-7.2.1.1 (JeremyShaw)
10:02:45 <Guest_47> ugh hi I'm a mac user trying to install haskell via ghcup but I keep getting this error message
10:02:47 <Guest_47> dyld: lazy symbol binding failed: Symbol not found: _futimens  Referenced from: /Users/georgewang/.ghcup/bin/ghcup (which was built for Mac OS X 10.13)  Expected in: /usr/lib/libSystem.B.dylibdyld: Symbol not found: _futimens  Referenced from: /Users/georgewang/.ghcup/bin/ghcup (which was built for Mac OS X 10.13)  Expected in:
10:02:48 <Guest_47> /usr/lib/libSystem.B.dylibsh: line 35: 25979 Abort trap: 6           ghcup "$@""_eghcup --cache install ghc recommended" failed!
10:03:24 <maerwald> Guest_47: what's your mac version?
10:03:38 <Guest_47> 10.12
10:03:53 <maerwald> not supported
10:03:57 <Guest_47> oof
10:04:12 <maerwald> I'm not even sure ghc itself will run there
10:04:23 <maerwald> and cabal
10:04:51 <__monty__> Course they will.
10:05:03 <maerwald> __monty__: did you try?
10:05:09 <__monty__> At least, they work for me built with a darwin version of 10.12.
10:05:38 <maerwald> __monty__: I'm talking about the official bindists
10:05:57 <merijn> GHC supports 10.7 or later, iirc
10:06:13 <monsterchrom> Now commences going out of one's way to give ghcup an obscure URL to download from. :)
10:06:28 <merijn> monsterchrom: It's the same URL as the regular macOS one
10:06:56 <merijn> Guest_47: If you're commandline savvy you can just install the bindist yourself from here: https://www.haskell.org/ghc/download_ghc_8_10_2.html#macosx_x86_64
10:07:08 <merijn> Which (at least claims) to work on anything later than 10.7
10:07:27 <Guest_47> aha
10:07:30 <Guest_47> cheers, I'll try that
10:07:52 <merijn> Guest_47: It's just a matter of "./configure --prefix=whatever/path/you/want && make install"
10:08:43 <merijn> Ah, I'm not sure if cabal-install has prebuilt binaries for that, though, although there should be a bootstrap script to compile it with just GHC installed
10:09:37 <__monty__> (If all else fails, nixpkgs has both GHC and cabal-install cached so you could install them with nix.)
10:10:46 <__monty__> Though I guess brew should have both too.
10:29:49 <maerwald> yes, install half another OS just to get GHC :p
10:30:21 <monsterchrom> I was procratinating ghcjs because of that. :)
10:31:43 <jtmar> dumb question: is there any way to get this to work? `data U (a :: ()) where { U :: U (() :: ()) }` It fails with "Expected kind ‘()’, but ‘()’ has kind ‘*’"
10:31:45 <maerwald> I bought 16GB more ram and 250GB more disk space, just so I can run a nix expression, which runs some stuff you could do in 50 LOC bash
10:32:00 <maerwald> (but it's reproducible)
10:33:11 <maerwald> when it doesn't OOM out, it works well
10:34:56 <yushyin> ah yes, I know that problem, but just with cabal build :P
10:36:49 * hackage prolude 0.0.0.4 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.4 (saramuse)
10:41:02 <monsterchrom> data U (a :: ()) where { U :: U '() }
10:56:38 <jtmar> oh, yeah, single quotes, right. thanks.
10:59:04 <monsterchrom> I think basically the parser stage doesn't have access to type/kind checking, so when it sees "X :: Y", it cannot infer "since Y is not Type, I see what you mean by X".
11:09:22 <__monty__> maerwald: Color me skeptical. I've run NixOS just fine with 2GB RAM.
11:11:24 <maerwald> __monty__: yes, I have an expression that needs 6GB of memory (not the stuff it builds/compiles, but the nix-build process itself)
11:11:34 <maerwald> that's some nice memory leak
11:12:30 <__monty__> Then "I bought 16 GB more RAM" is very misleading.
11:14:18 <maerwald> the other half was for hls
11:14:32 <maerwald> but that's crashing now most of the time, so I have free ram for nix
11:15:28 <monsterchrom> You should also discuss the "250GB disk space" and how misleading it also is, while you're at it.
11:15:45 <maerwald> yeah, half for nix, half for docker... they're racing
11:16:05 <maerwald> the fun part about docker is the "prune" command never finishes
11:17:19 <monsterchrom> Evergrowing space usage and neverending time usage.
11:17:31 <maerwald> and when you try to stop it, you can't, because the daemon is blocked, then you kill everything and rm -rf
11:18:20 <maerwald> bonus points for docker: it actually takes less time to "rebuild" than nix
11:18:42 <maerwald> it just downloads gigabytes of trash, nix seems to spend more CPU
11:20:16 <maerwald> I have this theory that half of nix IO load is due to `realpath`
11:34:49 * hackage call-alloy 0.2.1.0 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.2.1.0 (marcellus)
11:44:02 <monsterchrom> w00t Alloy
11:44:50 <monsterchrom> Oh God no, "getInstances". Java abstract factory all over again.
11:47:49 * hackage pandoc 2.11.0.4 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.11.0.4 (JohnMacFarlane)
12:12:19 * hackage faktory 1.0.1.3 - Faktory Worker for Haskell  https://hackage.haskell.org/package/faktory-1.0.1.3 (PatrickBrisbin)
12:21:30 <DigitalKiwi> __monty__: i have nixos on my rpi 3b
12:22:17 <DigitalKiwi> with 32GB micro sd card
12:22:45 <__monty__> DigitalKiwi: Yeah, it's possible, but it's not exactly an incredible UX. I was just not happy with painting nix as requiring 16GB RAM.
12:24:23 <dminuoso> *memory
12:24:29 <blip> Why can't I define `data A = B | Proxy 'B`
12:24:48 <dminuoso> blip: That, arguably, is better asked in #ghc :p
12:25:03 <maerwald> __monty__: if one nix-build process requires 6GB and you have firefox open, you need more than 16GB
12:25:22 <davean> blip: Proxy?
12:25:27 <dminuoso> blip: It seems like an engineering problem, allowing for self-recursive data declarations
12:25:33 <maerwald> correction: the nix-build process needed 6GB, ghc then needed another few
12:25:37 <blip> Sorry, I mean't:  `data A = B | C (Proxy B)`
12:25:46 <dminuoso> blip: Still.
12:25:59 <dminuoso> It doesn't really change, as the initial example is fine too
12:26:14 <davean> blip: Well, at best you'd need DataKinds, and B is a constructor not a type its self
12:26:17 <dminuoso> blip: I'd git blame the ghc source code on the diagnostic.
12:26:27 <dminuoso> All I know is, there's a reason we have a *special* diagnostic for it
12:26:30 <blip> davean: I know, it's promoted
12:26:31 <dminuoso> % :set -XDataKinds
12:26:31 <yahb> dminuoso: 
12:26:35 <dminuoso> % data Foo = Foo Foo
12:26:35 <yahb> dminuoso: 
12:26:40 <dminuoso> % data Foo = Foo 'Foo
12:26:40 <yahb> dminuoso: ; <interactive>:140:16: error:; * Data constructor `Foo' cannot be used here (it is defined and used in the same recursive group); * In the type 'Foo; In the definition of data constructor `Foo'; In the data declaration for `Foo'
12:26:56 <blip> Yeah, that's understandable, the compiler would loop
12:26:57 <davean> I mean you can't generate an infinite type either
12:27:23 <dminuoso> blip: Hold on, in the above, is the B supposed to have a tick or not?
12:27:24 <blip> But if I promote another constructor it's not infinite
12:27:28 <blip> yep
12:27:34 <blip> they are omittable
12:27:36 <dminuoso> blip: But that's the same example.
12:27:47 <dminuoso> Im just aksing because it could be ambgiuous without more context
12:27:56 <dminuoso> Oh, my example was poor
12:28:07 <dminuoso> % data Foo = F 'F
12:28:07 <yahb> dminuoso: ; <interactive>:141:14: error:; * Data constructor `F' cannot be used here (it is defined and used in the same recursive group); * In the type 'F; In the definition of data constructor `F'; In the data declaration for `Foo'
12:28:30 <blip> data Foo = F | X (Proxy F')
12:28:34 <blip> darn
12:28:38 <dminuoso> Note the choice of the word "group"
12:28:43 <blip> data Foo = F | X (Proxy 'F)
12:29:05 <blip> yes, I know that it doesn't work. The question is why.
12:29:31 <dminuoso> blip: Ask Richard Eisenberg? :p
12:30:11 <dminuoso> Almost confident it's an GHC engineering problem
12:30:57 <blip> I'm solving that in a very ugly and unsafe way with Symbols
12:30:59 <dminuoso> blip: See note [Recursion and promoting data constructors]
12:31:12 <dminuoso> in compiler/GHC/Tc/TyCl.hs
12:32:04 <dminuoso> Mmm that note doesnt actually contain something useful
12:32:36 <dminuoso> But perhaps this would loop the kind checker when the data declaration is checked?
12:33:34 <blip> I think it would loop if you would reference the same Constructor
12:33:49 <blip> data A = B (Proxy 'B)
12:34:18 <blip> Or mutal recursion:  data A = B (Proxy 'C) | C (Proxy 'B)
12:34:44 <dminuoso> blip: again, this is probably better asked in #ghc, the ghc dev mailing list or the issue tracker. :)
12:35:13 <blip> dminuoso: ok, thanks. I'll ponder it a bit and ask tomorrow in #ghc
12:35:37 <dminuoso> The mailing list is likely a better candidate 
12:36:06 <blip> ok
12:52:01 <blip> dminuoso: another question, is there a function Foo with following properties:  `data A = B; Foo 'B  = "B" :: Symbol` 
12:52:23 <blip> like ShowType from the type error messages, but which returns a Symbol and not a Text
12:56:04 <dminuoso> blip: There's only the bits for type errors
12:57:18 <blip> hm, i'll try to unsafeCoerce, perhaps it's under the hood the same
12:57:52 <dminuoso> unsafeCoerce on the type level?
12:57:55 <dminuoso> We have that?
12:58:35 <blip> with proxies
12:59:28 <blip> unsafeCoerce :: KnownSymbol a => Proxy ErrorMessage -> Proxy a
12:59:28 <blip> ?
13:01:48 <dminuoso> blip: What's your intention here?
13:02:24 <blip> I want to get the name of a promoted constructor as a Symbol
13:04:30 <ghoulguy> To get constructors as symbols I'd expect you to have to write some TH to actually generate the code
13:05:09 <ghoulguy> Like a: type family AsSymbol (a :: k) :: Symbol -- and then a bunch of generated instances
13:05:58 <blip> If they aren't promoted it would work via generics
13:07:18 <ghoulguy> yeah, looks like it
13:07:20 <blip> Yeah, I'd love to avoid TH
13:08:36 <ghoulguy> >>> data T = C deriving (Generic)
13:08:36 <ghoulguy> >>> :kind! Rep T ()
13:08:37 <ghoulguy> Rep T () :: * = D1 ('MetaData "T" "Ghci3" "interactive" 'False) (C1 ('MetaCons "C" 'PrefixI 'False) U1) ()
13:09:06 <ghoulguy> "T" is a Symbol there
13:09:19 <blip> Yes, and "C" as well.
13:15:06 <blip> I'd want to have `data T = A | B` and a function F (a :: T) which gives F 'B = "B"
13:15:24 <blip> and I think that's not possible with generics
13:19:25 <ghoulguy> GHC.Generics operate on types of kind * -> * and *
13:20:24 <blip> yes, that's the problem
13:20:40 <blip> wrapping in Proxy doesn't help
13:22:13 <blip> well, sounds like TH is the only way foreward
13:22:17 <blip> or a plugin
13:23:41 <ghoulguy> Or just write it out by hand if it's a small number of cases
13:23:58 <ghoulguy> if it's not write it out by hand to make sure you like the API before you invest TH time on it :)
13:24:25 <blip> about 100 promoted constructors :)
13:24:46 <ghoulguy> a job for an editor macro then
13:25:35 <blip> yes, the code would be easily generated. I'd just love to avoid inflating my source files
13:26:04 <ghoulguy> I'd expect the impact of a plugin or TH to be higher
13:26:09 <monsterchrom> "F 'B = ..." makes F either a type family or a term-level function Proxy T -> ... 
13:26:30 <ghoulguy> f :: proxy t -> SomeSymbol
13:27:15 <ghoulguy> err: proxy T
13:27:16 <blip> monsterchrom: I'd prefer to avoid term-level
13:27:23 <ghoulguy> probably nicer to do the type family
13:27:59 <blip> proxy (x :: T)
13:28:04 <ghoulguy> as a term-level it'd be a class method
13:28:27 <blip> yes, but type level guarantees no runtime overhead
13:28:34 <blip> term-level is always a risk
13:28:57 <ghoulguy> type-level means you won't know if you have a knownsymbol constraint to use
13:29:05 <ghoulguy> which might not matter
13:29:18 <ghoulguy> You can always just assert one
13:29:26 <ghoulguy> KnownSymbol (F thing) => 
13:29:44 <ghoulguy> sounds like a mess either way :)
13:30:19 <blip> I think I'll go for the type family
13:30:43 <Uniaika> hello there
13:30:48 <blip> type family Bananas (x :: A) where Bananas B = "B" etc...
13:31:08 <blip> hello
13:38:49 * hackage stack2cabal 1.0.12 - Convert stack projects to cabal.project + cabal.project.freeze  https://hackage.haskell.org/package/stack2cabal-1.0.12 (maerwald)
13:51:42 --- mode: card.freenode.net set +o Sigyn
13:51:43 --- mode: card.freenode.net set +o ChanServ
13:54:12 <pomiiu> Hi everyone. Just found out about ghcup. Is this the new standard way to install GHC?
13:54:22 <monsterchrom> Yes.
13:54:25 <ghoulguy> pomiiu: yup
13:55:38 <pomiiu> There are lots of packages like indent that I think assume stack. Like hindent, which suggests "stack install hindent" to install. Is it just "cabal install hindent" then?
13:56:07 <maerwald> prefer: cabal install --install-method=copy --overwrite-policy=always
13:56:27 <maerwald> which is closer to what stack does too
13:56:28 <monsterchrom> You should just try. Add "--dry-run" for a preview of what would be involved.
13:56:40 <pomiiu> Ah okay. Thanks.
14:29:46 <hc> is there a haskell implementation of youtube-dl? ;-)
14:30:35 <texasmyn_> pomiiu: have you tried brittany?
14:31:34 <texasmynsted[m]_> oops
14:32:25 <texasmynsted> I have tried them all, https://github.com/lspitzner/brittany works very well and worth a look. I do not have enough scroll-back to know about your hindent needs. 
14:33:34 <yushyin> fourmolu/ormolu
14:34:23 <texasmynsted> I guess I have _not_ tried them all. I have not tried ormolu, I think
14:34:44 <texasmynsted> I mean fourmolu
14:37:18 <texasmynsted> darn now I have to try another one. heh
14:41:02 <sm[m]> gotta collect them all!
14:44:58 <pomiiu> Has anyone tried to build hindent recently? I get src/HIndent/Types.hs:78:27: error:    • Could not deduce (MonadFail m) arising from a use of ‘fail’
14:53:04 <maerwald> that shouldn't be hard to fixe
14:53:07 <crestfallen> hi please help me understand "creates the effect of both the original layers", here:     IO(IO ())    'join' can be thought of as combining the effects described by two m-layers, one nested inside the other. combining them into a single m-layer, creates the effects of both the original layers.
14:53:38 <maerwald> :t join
14:53:40 <lambdabot> Monad m => m (m a) -> m a
14:53:44 <maerwald> @src join
14:53:44 <lambdabot> join x = x >>= id
14:53:55 <maerwald> :t (>>=)
14:53:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:54:00 <maerwald> @src (>>=)
14:54:00 <lambdabot> Source not found. Do you think like you type?
14:54:05 <maerwald> something like that
14:54:08 <maerwald> follow the rabbit
14:57:41 <crestfallen> maerwald, thanks, but what does it mean to create the effects of both the original layers. IO() should not be read into, I'm assuming..
14:58:10 <maerwald> I honestly ind that sentence confusing. Seems like someone tried to over-explain stuff
14:58:11 <dminuoso> crestfallen: I frequently like to adopt the notion that `IO T` is a list of assembly instructions, that, if they were executed produced something of type `T`. So `IO (IO T)` is some assembly instructions, that, if they were executed, would give you another list of assembly instructions
14:58:19 <dminuoso> And if those were executed, you'd get something of value T
14:58:42 <dminuoso> Now, `join` is saying "give me a list of assembly instruction that does the first, and then the second" 
14:58:55 <dminuoso> Thereby "combining" these two 
14:59:23 <maerwald> If language is confusing you, throw it away and look at code
15:00:02 <maerwald> > join (Just (Just 2))
15:00:07 <lambdabot>  Just 2
15:00:44 <maerwald> > join Nothing
15:00:48 <lambdabot>  Nothing
15:00:57 <maerwald> > join (Just Nothing)
15:01:00 <lambdabot>  Nothing
15:01:08 <dminuoso> crestfallen: In terms of power, join and (>>=) are completely equivalent. The only reason `join` is not a method of Monad (and an alternative to implement instead of (>>=)) is actually some very interesting interaction with other extensions.
15:01:57 <crestfallen> so Nothing in that last one has no effect, since its extracted from Just Nothing   ?
15:03:50 <crestfallen> I ask, because of this note: An effect is the structural information of a Functor, the part that's not parametric. Does that mean a Nothing is effectual ? -- yes
15:04:16 <maerwald> what are you reading?
15:04:27 <crestfallen> so I'm confused about Nothing as non/effectual
15:04:30 <dminuoso> an "effect" is really just a handwavy and very non-precise idea that comes from already existing intuition
15:04:53 <dminuoso> "effect" is not something useful for understanding what all of this means, it's rather the *result* of having gained some understanding, and making some analogies
15:04:59 <maerwald> This sounds like lecture notes :p
15:05:56 <crestfallen> one moment pls
15:06:34 <maerwald> crestfallen: you can think of `Maybe Int` as having an effect flow (Nothing and Just) and a value flow (Int)
15:07:39 <maerwald> `join` just combines the effects... it's actually pretty boring
15:07:41 <maerwald> :p
15:07:42 <crestfallen> so if we extract Nothing from Just -- join Just Nothing -- what is the result, Nothing, there? just out of curiosity
15:08:12 <maerwald> crestfallen: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-1005
15:08:57 <maerwald> maybe would be nicer to show the pattern matching for join
15:09:31 <crestfallen> not sure I follow, if Just and Nothing are both in the effect flow..
15:10:12 <crestfallen> because my notes have Nothing as effectual, but in this case Nothing is in the parameter
15:11:33 <maerwald> crestfallen: https://paste.tomsmeding.com/lJ9EjYAJ
15:11:58 <maerwald> pretty boring right?
15:13:27 <crestfallen> its boring but then I read about effects .. once again .. and have to be content without understanding it.
15:14:04 <maerwald> that's just jargon... what matters is the typeclass
15:14:17 <maerwald> and that it applies for many more stuff
15:14:50 <maerwald> > join [[1,2,3]]
15:14:52 <lambdabot>  [1,2,3]
15:15:38 <crestfallen> join == concat
15:17:03 <maerwald> > join (+) 8
15:17:05 <lambdabot>  16
15:17:07 <maerwald> xD
15:17:13 <maerwald> ignore that one
15:17:26 <crestfallen> ??
15:17:32 <crestfallen> > join (+) 8
15:17:34 <lambdabot>  16
15:18:48 <maerwald> > join (\x -> \y -> x + y) 8
15:18:50 <lambdabot>  16
15:18:58 <maerwald> so functions are monads too
15:19:37 <crestfallen> god I have notes that seem to be conflicting.. maddening
15:20:48 <maerwald> here's the definition https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-979
15:22:41 <maerwald> Also see this in-depth answer: https://stackoverflow.com/a/5316690
15:23:01 <crestfallen> maerwald, I have this: An 'm a' is an effect; Nothing is not an 'm a'
15:23:16 <maerwald> > Nothing :: Maybe Int
15:23:18 <lambdabot>  Nothing
15:23:21 <maerwald> why not?
15:24:13 <crestfallen> > Nothing :: Maybe Bool
15:24:16 <lambdabot>  Nothing
15:24:34 <crestfallen> interesting. 
15:24:44 <maerwald> stop thinking about effects
15:25:05 <crestfallen> ok that's interesting thanks , I'll read that SO.  appreciate it!
15:25:11 <maerwald> it's just a class: Monad
15:25:46 <crestfallen> maerwald, let me show you one thing...
15:32:54 <crestfallen>  "effect" acquired a second meaning broader than that of "side-effect" -- namely, whatever is introduced through a type constructor which is a Monad instance.
15:33:21 <maerwald> I'm getting headache reading that :D
15:33:28 <crestfallen> :)
15:33:32 <crestfallen> sorry
15:33:42 <maerwald> Is it lecture notes?
15:34:11 <crestfallen> it's SO but it's referring to a Wadler paper
15:34:36 <maerwald> He's maybe a bit too smart to explain it simply :p
15:34:59 <maerwald> "side-effect" is an even more confusing term too
15:35:06 <maerwald> even haskellers get confused about it
15:35:38 <crestfallen> monads encapsulate effects.. so it's something I'll just ignore for a while I gues
15:35:39 <crestfallen> s
15:35:49 * hackage capnp 0.7.0.0 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.7.0.0 (isd)
15:36:01 <maerwald> did you remeber the Monad instance of Maybe?
15:36:12 <maerwald> It starts like this: "instance  Monad Maybe  where"
15:36:27 <maerwald> not "instance Monad Maybe a where"
15:36:52 <maerwald> and in the definition we know nothing about the value
15:36:58 <maerwald> and just do stuff with constructors
15:37:21 <maerwald> if you call constructors effects, then yeah, sure
15:37:57 <crestfallen> maerwald, thanks I'll sort it out
15:38:19 * hackage gopro-plus 0.4.1.1 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.4.1.1 (dustin)
15:40:29 <maerwald> also, we call `Maybe` a type constructor and Just and Nothing a data constructor
15:40:49 <maerwald> often they have the same name, don't mix them up
15:41:39 <maerwald> data Foo = Foo Int
15:45:19 <crestfallen> maerwald, thanks. yeah this was very helpful, what you said at the end: "instance  Monad Maybe  where"    not    "instance Monad Maybe a where." And in the definition we know nothing about the value, and just do stuff with constructors. If you call constructors effects, then yeah, sure 
16:26:50 <JohnnyL> Are there any plans to make haskell for the browser or perhaps a 'mini' version of haskell?
16:27:19 <monsterchrom> Does GHCJS count?
16:28:04 <monsterchrom> And the multitude of functional/typed languages like purescript.
16:29:08 <JohnnyL> ok
16:29:11 <JohnnyL> i'll have to check.
16:31:08 <JohnnyL> Is ghcjs stable? Or is it same shady buggy product?
16:31:27 <monsterchrom> stable
16:37:05 <simon> apparently much better than before
16:37:05 <JohnnyL> ok thanks.
16:37:13 <yushyin> 'same' as what?
16:37:55 <JohnnyL> yushyin: s/same/some
16:38:04 <yushyin> ah
16:38:38 <simon> JohnnyL, haskell for the browser: https://github.com/tweag/asterius#asterius-a-haskell-to-webassembly-compiler
16:40:11 <simon> yushyin, I thought he referred to GHCJS being hard to install and based on GHC 7.x for a long time.
16:42:13 <simon> JohnnyL, apparently less mature than GHCJS, but definitely promising. :)
16:50:42 <JohnnyL> I cannot for the sake of me see the entire industry *not* going pure.
18:07:49 * hackage web-routes-happstack 0.23.12.1 - Adds support for using web-routes with Happstack  https://hackage.haskell.org/package/web-routes-happstack-0.23.12.1 (JeremyShaw)
18:30:29 <texasmynsted> What is the most common/best way to map a function to the first element of a tuple. I see in hoogle things like mapFst, and many others. I could also just write my own function...
18:30:46 <texasmynsted> It feels like Control.Arrow might live in this space.
18:31:13 <MarcelineVQ> first  of Control.Arrow or Control.Bifunctor
18:31:30 <MarcelineVQ> * Data.Bifunctor
18:36:43 <texasmynsted> okay
18:37:37 <Squarism> ghoulguy, it took me ages, but with your help i finally was able to complete the "textual" getter function. Learned a bunch. https://paste.ofcode.org/TrYkpAdAC3BKSzy4mBNSSL
18:39:19 * hackage happstack-hsp 7.3.7.5 - Support for using HSP templates in Happstack  https://hackage.haskell.org/package/happstack-hsp-7.3.7.5 (JeremyShaw)
18:41:06 <texasmynsted> thank you
18:49:54 <Squarism> what is a popular "lens" library that doesn have a much dependencies as ordinary lens lib?
18:50:28 <Squarism> i just got the impression "lens" had tons of dependencies
18:57:56 <ghoulguy> Squarism: I'd suggest just using lens until you're comfortable with it and know what parts you like. After that you'll be able to assess what you don't mind giving up
18:58:25 <ghoulguy> There are a few dependencies, but none of them are that big
18:58:28 <Squarism> okok
19:01:04 <Squarism> ghoulguy, as a follow up to the above problem. I think I actually would be better off to map String -> Lens, in order to both read and write values. Do you think it would be easy to use generics to spit out Maybe (<whatever lens type>)?  
19:02:25 <ghoulguy> You wouldn't make an actual Lens, you'd make a Traversal (a think that might not visit any data)
19:03:26 <Squarism> okok what do you mean with "a think that might not visit any data"
19:03:28 <Squarism> ?
19:03:39 <ghoulguy> The Nothing part of what you have
19:03:51 <ghoulguy> when a particular path doesn't actually reach the value you're interested in
19:07:41 <texasmynsted> What is a reasonable way to combine these? https://gist.github.com/mmynsted/da7bc7a118ded64080d87208a0f5c798
19:08:43 <texasmynsted> other comments welcome. I just want to improve and I have been looking at code too long today.
19:09:22 <texasmynsted> I can't really recall the let/where details for inside a do block
19:10:33 <Squarism> texasmynsted, im not haskell veteran. But I think it would help if you provide more context, types and background.
19:11:20 <texasmynsted> I am just wanting to combine foo and bar
19:11:42 <texasmynsted> foo is Rules UrlPairs
19:11:52 <texasmynsted> bar is Rules ()
19:12:19 <Squarism> you mean Rules is a semigroup / monoid? 
19:12:39 <texasmynsted> Rules --> https://jaspervdj.be/hakyll/reference/Hakyll-Core-Rules.html#t:Rules
19:13:49 <texasmynsted> it forms a Monad, Functor, Applicative, and MonadMetaData if I am reading that right.
19:16:56 <MarcelineVQ> bar uses foo, are you wanting to write one definition that replaces them entirely?
19:17:37 <MarcelineVQ> *replaces foo and bar entirely
19:19:38 <Squarism> ghoulguy, you seem to have an obvious idea in your head there on how to accomplish my above problem. Could you just show a short signature of pseudo code for what you mean? 
19:21:44 <Squarism> or do you mean Traversal as in what is used by over / view in in lens lib? 
19:23:46 <MarcelineVQ> texasmynsted: you should be able to just insert the body you wrote for foo right into bar, e.g. https://gist.github.com/mmynsted/da7bc7a118ded64080d87208a0f5c798
19:25:53 <Squarism> yeah, right. its a Traversal i want to make
19:40:00 <texasmynsted> yes replace both with a single function
19:40:49 <texasmynsted> :-)
19:42:16 <texasmynsted> Nice thank you MarcelineVQ
19:51:19 * hackage happstack-jmacro 7.0.12.3 - Support for using JMacro with Happstack  https://hackage.haskell.org/package/happstack-jmacro-7.0.12.3 (JeremyShaw)
20:33:29 <jtmar> is it possible to define a pattern that works against multiple types? it looks like associated pattern synonyms were never implemented so I'm wondering if there's an alternative
20:50:09 <c_wraith> jtmar: nope.  but you can do the dual, by defining an eliminator in a class
20:51:16 <jtmar> alright then. thanks.
20:59:00 <dolio> You can, actually.
21:00:04 <jtmar> how?
21:00:22 <dolio> https://paste.tomsmeding.com/d8CFDh3q
21:03:15 <dolio> Instead of an associated pattern you'd define an overloaded test function, and alias a view pattern using the test function.
21:13:05 <Squarism> Im not sure I can understand this. https://paste.ofcode.org/iUBMHtVdk2DQtBvxmZzayb
21:13:34 <Squarism> type of "preview ( ff2 . _Just  . ee1 )" is not even a function, but it can be applied to c3
21:20:09 <jtmar> wow, what an awful hack! it works perfectly. I love it.
21:20:25 <hololeap> Squarism: Getting r s a = (a -> Const r a) -> s -> Const r s
21:21:18 <jtmar> only took 34 lines of code to overload two patterns for two types ;)
21:21:20 <hololeap> so, `preview (ff2 . _Just . ee1)` _is_ a function that takes an `s` argument
21:26:11 <MarcelineVQ> Squarism: consider fmap where the Functor is chosen to be a partially applied function type, i.e. where we take f and substitute (r ->):  fmap :: Functor f => (a -> b) -> f a -> f b    to   fmap :: (a -> b) -> (r -> a) -> (r -> b)    m can be chosen similarly
21:32:21 <Squarism> im gonna need to digest this
21:34:58 <MarcelineVQ> Directly  pure 'c' :: Applicative f => f Char   but
21:35:03 <MarcelineVQ> :t pure 'c' `asAppliedTo` 2
21:35:04 <lambdabot> Num a => a -> Char
21:36:09 <MarcelineVQ> :t pure 'c' `asAppliedTo` (2 :: Int) -- or more directly.   f is chosen as  Int ->
21:36:10 <lambdabot> Int -> Char
22:32:40 <hololeap> : fmap (++ " is the number") show 4
22:32:44 <hololeap> :t fmap (++ " is the number") show 4
22:32:45 <lambdabot> [Char]
22:32:50 <hololeap> > fmap (++ " is the number") show 4
22:32:52 <lambdabot>  "4 is the number"
22:38:57 <sureyeaah> How can I create a named socket in unix?
22:41:18 * hackage google-server-api 0.3.3.1 - Google APIs for server to server applications  https://hackage.haskell.org/package/google-server-api-0.3.3.1 (arowM)
22:45:29 * sureyeaah sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/nOXlbNDHbFYDdoFCbhdcMctI/message.txt >
22:45:51 <sureyeaah> ```No instance for (Protocol Unix) arising from a use of socket```
22:53:11 <how_does_this_wo> hey! I'm probably thinking about this wrong, but I'm trying to implement a function
22:53:24 <how_does_this_wo> parse :: String -> [String]
22:53:55 <sureyeaah> I tried `socket :: IO (Socket Unix Stream Default)` and that works. But I'm still not able to create the file based socket.
22:54:13 <how_does_this_wo> where it searches the string for valid patterns and then returns a list of everything it can parse out, and I want to create it lazily obviously so I can stream in the data, so is there a way to yield in parse?
22:55:07 <how_does_this_wo> cause the only other way I can think of doing it is consing the newest parsed element to the front of the list, piping it through a reverse, and then processing it
22:55:36 <how_does_this_wo> but I don't think in that case the laziness can be of any advantage 
22:55:56 <how_does_this_wo> parse :: [String] -> [String] **
23:00:23 <sureyeaah> probably use something like scanl?
23:00:31 <sureyeaah> how_does_this_wo:
