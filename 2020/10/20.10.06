00:28:49 * hackage serverless-haskell 0.12.4 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.12.4 (AlexeyKotlyarov)
01:08:49 * hackage servant-auth-client 0.4.1.0 - servant-client/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-client-0.4.1.0 (domenkozar)
01:13:20 * hackage polysemy-zoo 0.7.0.1 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.7.0.1 (KingoftheHomeless)
01:18:19 * hackage servant-auth-server 0.4.6.0 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.4.6.0 (domenkozar)
01:25:20 * hackage servant-auth-swagger 0.2.10.1 - servant-swagger/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-swagger-0.2.10.1 (domenkozar)
01:48:59 <shaman_king> hi all
01:49:11 <shaman_king> i want to learn more about haskell and beyond
01:56:15 <shaman_king> hi
02:05:20 * hackage aterm 0.1.0.2 - serialisation for Haskell values with sharing support  https://hackage.haskell.org/package/aterm-0.1.0.2 (ChristianMaeder)
02:18:55 <tomsmeding> If I have a type class 'C s a' with an associated type 'type T a', how can I promise that for every instance 'C s a', the type 'T a' will be an instance of class 'D' (i.e. we will have 'D (T a)')?
02:19:36 <tomsmeding> alternatively, can I promise that for a particular instance
02:19:44 <shaman_king> i think thats wrong.
02:20:46 <tomsmeding> how so?
02:26:50 * hackage attoparsec-data 1.0.5 - Parsers for the standard Haskell data types  https://hackage.haskell.org/package/attoparsec-data-1.0.5 (NikitaVolkov)
02:27:40 <cpressey> tomsmeding: I would be surprised if you could say that directly, but maybe you could constraints on 'a' in both C and D?  Or perhaps a smart constructor for D's?
02:27:53 <shaman_king> its wrong
02:27:56 <dminuoso> tomsmeding: MPTC+fundeps instead of associated types, then you could make it a superclass constraints
02:28:21 <tomsmeding> problem is that I don't control D, though I do control C
02:28:21 <dminuoso> Or.. is the superclass constraint possible perhaps?
02:28:46 <tomsmeding> basically, this is a "shim" for D
02:29:29 <tomsmeding> ah yes putting T as a type argument to C and using fundeps might work...
02:29:37 <tomsmeding> interesting visit
02:30:02 <dminuoso> % class D (T a) => C s a where type T a
02:30:02 <yahb> dminuoso: 
02:30:05 <dminuoso> tomsmeding: ^- this seems to work fine
02:30:14 <tomsmeding> oooooooh
02:30:29 * tomsmeding is off to the editor
02:45:22 <tomsmeding> putting 'T a' as an extra type argument to C works very well :)
02:51:33 <tomsmeding> and the fundep is indeed necessary
03:02:11 <kuribas> is there a typeclass to say, type "a" is a record with field "f"?
03:07:44 <jiribenes> kuribas: There's a 'HasField' typeclass in GHC https://downloads.haskell.org/ghc/latest/docs/html/libraries/base-4.14.0.0/GHC-Records.html
03:08:09 <kuribas> jiribenes: right, thanks!
04:19:20 * hackage reanimate-svg 0.12.2.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.12.2.0 (DavidHimmelstrup)
04:21:50 * hackage uniqueness-periods-vector-examples 0.9.0.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.9.0.0 (OleksandrZhabenko)
04:57:42 <quazimod1> so I was playing around with ocaml and found some things quite disappointing
04:58:15 <quazimod1> it took forever to spin up a working code base... and i still have no idea how to split nested submodules into their own files... doesn't appear to be possible
04:59:01 <quazimod1> anyway I'm writing quantitative finance code and am evaluating languages, when reading about ocaml's strictness vs haskell's laziness I found that GHC has a 'strict' option
04:59:26 <quazimod1> i had no idea that this existed, is it commonly used, or compatible with existing libraries
05:00:40 <dminuoso> quazimod1: Not very commonly used.
05:00:53 <quazimod1> i cant wrap my head around it being a drop in option that 'just works'
05:01:22 <dminuoso> Well, ultimately I dont think lazyness is a real issue. Overall lazy by default seems far more preferrable to strict by default.
05:01:38 <quazimod1> dminuoso: far more preferrable?
05:01:41 <dminuoso> Yes.
05:01:50 * hackage futhark 0.17.3 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.17.3 (TroelsHenriksen)
05:01:51 <dminuoso> Code becomes far more modular
05:02:05 <dminuoso> And the downsides are just matters of having to debug a space leak in the odd case.
05:02:28 <dminuoso> But equivalently, if you're too strict, you can have performance issues as well.
05:02:29 <quazimod1> i'm not experience enough with haskell to really understand 'code becomes far more modular'
05:02:44 <quazimod1> i'll take your word for it though
05:03:27 <dminuoso> Don't take my word for it.
05:05:15 <frdg> I am having trouble understanding this error. Can I accumulate values with only Foldable and Monoid instances? https://dpaste.org/ekMY
05:05:41 <dminuoso> quazimod1: The topic has been discussed at ends on reddit or stackoverflow, so Ill just redirect you there. 
05:05:43 <dminuoso> https://www.reddit.com/r/haskell/comments/5xge0v/today_i_used_laziness_for/deia53t/?utm_source=reddit&utm_medium=web2x&context=3
05:06:39 <quazimod1> ah nice
05:10:57 <dminuoso> frdg:                True  -> x <> acc
05:11:16 <dminuoso> frdg: This is where the accident happens. Consider what the type of `x` is
05:12:27 <dminuoso> % :t foldr
05:12:27 <yahb> dminuoso: Foldable t => (a -> b -> b) -> b -> t a -> b
05:12:34 <frdg> x :: a. So I need a function that is `a -> t a -> t a`
05:12:47 <dminuoso> Sure, but that's not possible with t being just Foldable
05:13:18 <frdg> that is what I feared
05:13:58 <dminuoso> Im pondering about this currently, I feel there might be something close
05:14:53 <dminuoso> From the looks of it, Set is the best you have.
05:15:36 <dminuoso> Ah I found it
05:15:39 <dminuoso> So what you're asking for is
05:16:19 <L29Ah> % minimum(1,2)
05:16:20 <dminuoso> intersect :: (Unfoldable t, Foldable t, Eq a) => t a -> t a -> t a
05:16:20 <yahb> L29Ah: 2
05:16:28 <dminuoso> Where Unfoldable is from the package `unfoldable`
05:16:50 <dminuoso> Then, the most efficient way would be to roundtrip through a set, do the intersection, and then unfold it back
05:17:07 <frdg> ok thanks Ill try this.
05:17:09 <ski> @where whyfp
05:17:09 <lambdabot> "Why Functional Programming Matters" by John Hughes in 1984 at <http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html>
05:17:45 <ski> quazimod1 : iirc that ^ has an example of the modularity (with separating generating a search-tree for games, from traversing (and pruning) it)
05:19:33 <ski> quazimod1 : "it being a drop in option that 'just works'" -- i don't think that's the case. i think that for many modules/libraries, turning on `Strict' (or even just `StrictData', depending), will make them not work
05:19:53 <quazimod1> yeah that makes more sense
05:20:32 <dminuoso> quazimod1: Note that there's limits to lazyness being useful though. Just being able to use lazyness doesn't make all occurences of it useful.
05:20:34 <ski> (if you turn it on, when you're compiling them, that is)
05:20:42 <maerwald> ski: I enabled Strict and StrictData for large projects and nothing happened :)
05:20:42 <dminuoso> For instance, lazy bytestrings are very debatable. They are very non-composable.
05:21:06 <maerwald> Strict is only problematic when you write monadic combinators
05:21:50 <quazimod1> yeah i'm too dumb to understand
05:21:51 <ski> i think `Strict' (and `StrictData') are more useful for when you know you'll be working "in a strict way", where you won't really be helped much by non-strictness anyway. and possibly also for converting some preexisting code/library that mostly satisfy those constraints
05:22:20 <dminuoso> If I look back, ever since I started writing Haskell, I haven't been bitten by a space leak yet, but have had numerous occasions where lazyness let me write code far more modular, and more expressive.
05:22:29 <dminuoso> It's even small things like being able to write `zip [1..]`
05:22:38 <ski> maerwald : yea, i'm not saying you'll get bottom directly :) but some things may be way less efficient than one's expecting. it obviously depends on the style of the code, what kind of things it's doing
05:22:51 <maerwald> ski: kazu yamamoto seems to disagree with you https://github.com/yesodweb/wai/pull/752#issuecomment-501531386
05:24:14 <quazimod1> even though i'm dumb it feells to me like selective laziness is better than always lazy
05:24:22 <maerwald> I agree
05:25:47 <ski> maerwald : interesting :) perhaps the kind of things they's doing (or the way they tend to do them) more easily lends itself to strict semantics then. and perhaps that being the case is a bit more common than one'd thing
05:27:05 <ski> yea, i think having a reasonable way to get both worlds, would be good. but it's hard to know how to mix them, being able to succinctly and clearly choose which you want, when, not clear how to design such a language
05:27:24 <quazimod1> doesn't the strict mode do that
05:27:31 <dminuoso> quazimod1: It's debatable at the end. The thing with lazyness, is that its value doesn't kick in until you actually have lazyness by default.
05:27:32 <quazimod1> give you the ability to whitelist lazy
05:29:12 <quazimod1> this may again be more dumb thinking but i get the strong impression that commercial decision makers will avoid laziness
05:29:49 <dminuoso> quazimod1: The best summary is that adding a selective strictness annotation always works, but selective lazyness annotations dont.
05:30:02 <ski> quazimod1 : "doesn't the strict mode do that" -- no, because it turns it on for the whole module
05:30:04 <dminuoso> Lazyness needs to be pervasive to work
05:30:12 <ski> yea, that too
05:30:32 <maerwald> There are some arguments pro composition and compiler optimisations due to non-strict semantics, but in the end: lazyness is a poor streaming method, which is why we go away from lazy bytestring and lazy IO and towards actual streaming libraries, that guarantee proper streaming. Otherwise there's too much cleverness in your code you don't understand yourself
05:30:50 <dminuoso> Lazyness is not just for streaming.
05:30:56 <Habib> can someone help me out w/ understanding prettyprinter?
05:30:56 <maerwald> I didn't say that
05:31:08 <dminuoso> Habib: Just ask!
05:31:14 <ski> what i had in mind was to have a fine-grained selection of strictness and non-strictness. possibly, in some way, reflected in the types (but how to do that, in a not too obtrusive and code-duplicating way, isn't clear)
05:31:43 <ski> i'd like to experiment with a language with call-by-coneed :)
05:31:58 <maerwald> ski: http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#laziness
05:32:47 <quazimod1> I've done a lot of stream programming in javascript
05:32:57 <Habib_> is prettyprinter really a prettyprinter, or is it just a prettyprinting engine?
05:33:06 <dminuoso> quazimod1: So the realization that selective/surgical annotations only work with strictness annotations makes it obvious, that StrictData needs *far* more work if you want to use lazyness at all, as opposed to default with some strictness.
05:33:08 <quazimod1> i dont know how comfy i'd be with implicit streaming vs actual streaming constructs
05:33:12 <dminuoso> Habib_: Yes.
05:33:18 <dminuoso> Habib_: What's the difference?
05:33:50 <maerwald> dminuoso: there aren't many instances where you don't want StrictData 
05:34:00 <quazimod1> dminuoso: so the Strict and StrictData options appear to allow optional laziness using ~, so you'd have 'lazy modules' littered with ~ in a strict by default apporach, is what you're saying?
05:34:05 <dminuoso> maerwald: I dont think that's true. I've had very few places where I needed a bang.
05:34:13 <dminuoso> *far* less instances where I *wanted* lazyness
05:34:28 <Habib_> pretty-simple just prints data types in a nicely formatted way so i can see largely nested values, but prettyprinter seems to be more of a bunch of primitives to let me control everything in a very precise way, but no way to just… print something.
05:34:29 <quazimod1> to be fair i think the vast majority of the time you don't really care which way
05:34:33 <maerwald> You need it very quickly if you store a lot of data in memory
05:34:50 <quazimod1> still, it appears to me that having optional & deliberate laziness makes more sense
05:34:58 <quazimod1> dumb dumb opinions
05:35:06 <ski> maerwald : yea, having explicit suspensions (that `Lazy'), is good to have in a strict language, but are a bit awkward to use (also really needs to be combined with something like <https://srfi.schemers.org/srfi-45/srfi-45.html>. also see <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#lazyinstrict>). there's the pervasiveness argument that dminuoso mentioned
05:35:22 <Habib_> dminuoso: i don't get how anyone is supposed to be able to use prettyprinter in the console for just looking at values without getting lost
05:35:37 <maerwald> quazimod1: also: laziness is harder to reason about. And ppl get it wrong all the time. It's just less intuitive and some of the rules aren't that obvious
05:35:45 <dminuoso> Habib: prettyprinter is not for "just looking at values"
05:35:49 <dminuoso> It's for generating pretty output.
05:35:55 <quazimod1> i guess the other question that I have is, what happens when you have zero laziness... don't you just solve the same problems slightly differently
05:35:59 <Habib> yeah, this is what i mean by pretty printer vs. pretty printing engine
05:36:01 <dminuoso> Think of generating error/warning messages for your prorgram.
05:36:05 <ski> maerwald : "Otherwise there's too much cleverness in your code you don't understand yourself" -- i agree that this is not that good, yea. (but it's not just streams)
05:36:10 <Habib> a pretty printer prints… prettily
05:36:22 <quazimod1> ocaml, despite it's hateful tooling, seems to be a reasonable FP without laziness
05:36:33 <maerwald> but it isn't pure either
05:36:41 <dminuoso> Habib: I see. prettyprinter is a pretty printing engine.
05:36:43 <Habib> dminuoso: error/warning messages, go on…
05:36:50 <quazimod1> that's true, do you need laziness to have purity?
05:37:00 <dminuoso> Habib: https://github.com/quchen/prettyprinter read the README down below :)
05:37:10 <dminuoso> It covers the motivation and uses for this library
05:37:28 <maerwald> quazimod1: you need to be able to make your language non-strict without it overthrowing the entire semantics (modulo bottom)
05:37:35 <dminuoso> (One important aspect is that prettyprinter makes a strict separation between the document that you prettyprint and the layouting
05:37:35 <maerwald> otherwise it's not pure
05:37:40 <Habib> i don't understand why it's recommended in the aelve guide alongside options like pretty-simple and then made out to be the best option (subjectively); they do completely different things
05:37:50 <maerwald> whether the language is actually strict or not doesn't matter for it to be pure
05:38:34 <Habib> dminuoso: can you say more about the separation between the document and the layouting? it seems all its primitives are about layouting.
05:38:38 <quazimod1> maerwald: is there an example that could illustrate that concept?
05:38:47 <dminuoso> Habib: Well, think of pretty-simple as giving an adhoc "prettificiation". Sort of a generic.
05:38:50 <quazimod1> i cant wrap my head around it
05:38:57 <dminuoso> Habib: No they are not! That's the beauty :)
05:39:11 <maerwald> quazimod1: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
05:39:21 <dminuoso> Habib: https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Prettyprinter.html
05:39:26 <dminuoso> Scroll down to "General workflow"
05:39:32 <ski> quazimod1 : "what happens when you have zero laziness... don't you just solve the same problems slightly differently" -- yes. or you don't solve them at all (give up, or work around them, in a more clumsy, less modular/composable way) (or you simulate laziness, with suspensions like the one maerwald linked to)
05:39:44 <dminuoso> So you write up a document, you layout it, and then you render it
05:39:55 <dminuoso> And there's different layout algorithms (you can also write your own)
05:40:15 <Habib> so i could write a layout algorithm that lays out the document in the same way that pretty-simple does?
05:40:25 <ski> quazimod1 : OCaml is quite nice. and SML too. F# is not bad, either, although it lacks the good module system, alas
05:40:26 <maerwald> quazimod1: informally you could say: if your language is pure, the evaulation strategy shouldn't define its semantics
05:40:38 <dminuoso> Habib: pretty-simple is rather a sort of "generic" implementation for anything that has a show instance
05:40:56 <sm[m]> oh wow that's some great docs
05:41:02 <dminuoso> think of it as a "parser" that reads the Haskell Report compliant deriving based Show instances, and then emits some prettyprinter code, layouts it, and renders it to string.
05:41:12 <quazimod1> ski: ocaml's killing me
05:41:13 <Habib> dminuoso: afaiu, pretty-simple just takes what show produces and goes through the string and aligns things based on braces and such
05:41:21 <dminuoso> Habib: right, its very rigid
05:41:24 <dminuoso> but your assessment is right
05:41:28 <dminuoso> they are somewhat orthogonal
05:41:31 <dminuoso> but not entirely unrelated
05:41:37 <quazimod1> > informally you could say: if your language is pure, the evaulation strategy shouldn't define its semantics
05:41:40 <lambdabot>  <hint>:1:51: error: <hint>:1:51: error: parse error on input ‘,’
05:41:41 <quazimod1> gonna have to do more reading
05:41:44 <quazimod1> because i don't fully get that
05:42:51 <quazimod1> "Finally, we observe that call-by-name reasoning principles are unsound in compilers for monadic Haskell" 
05:42:51 <dminuoso> Habib: If you just want some ad-hoc "make show instances more readable" with no effort, use pretty-simple. If you want to generate user-facing output (regardless of whether thats html, markdown, text, whatever), prettyprinter is a great option. :)
05:42:57 <ski> a pretty-printer is a case where laziness can be useful. in a strict language, you can make multiple passes through the data, passing back the top-level outputs from last pass as inputs. (this is basically what attribute-grammars do). with non-strictness, you can just "do a single pass" (syntactically, so less clutter), but you have to be a bit careful to make sure you don't access a late input prematurely
05:43:01 <quazimod1> doesn't that mean that they found that strict is kinda unworkable for monadic haskell
05:43:50 <Habib> dminuoso: okay, i understand that now, i think i was just expecting something more like pretty-simple as that was the comparison being made on the aelve guide
05:44:27 <Habib> i still don't quite understand prettyprinter, but i don't want to dwell on that when it's not what i need anyway
05:44:34 <maerwald> quazimod1: it bottoms out :p
05:44:42 <quazimod1> i don't know what that means!!
05:44:45 <dminuoso> Habib: prettyprinter is one of the finer libraries out there :)
05:44:47 <quazimod1> lol
05:44:53 <quazimod1> FP world is >so weird<
05:45:00 <dminuoso> It has really good ergonomics, and makes writing output fun.
05:45:11 <Habib> i get that impression, but for now, it's just gonna stay over my head i guess
05:45:22 <dminuoso> Fair enough. Just dont be scared, it's very easy to use.
05:45:37 <ski> quazimod1 : where was that quote from ?
05:45:40 <maerwald> quazimod1: the paper explicitly says that semantics for different eval strategies are only equivalent if you ignore error/non-termination etc
05:45:55 <maerwald> bc these will never be equivalent
05:46:00 <quazimod1> ski: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
05:46:03 <quazimod1> in the blurb
05:46:23 <quazimod1> maerwald: that makes intuitive sense to me
05:46:39 <quazimod1> wow haskell really is a research language isn't it
05:46:48 <quazimod1> it's purpose is not commercial in the slightest
05:47:19 <sm[m]> prettyprinter docs always are a bit opaque, even these; they sssume certain knowledge and jargon
05:47:51 <lortabac> quazimod1: it's a research language that is also used commercially
05:47:51 <maerwald> quazimod1: that's how it began... like your first date is exciting, but the truth settles soon enough
05:48:00 <dminuoso> sm[m]: Doesn't any library?
05:48:10 <dminuoso> I mean it's much worse with most of eds libraries.
05:48:32 <maerwald> it's already too widely used to make drastic backwards-incompatible changes
05:48:36 <dminuoso> Can't even use the damn thing without getting confused by half a dozen ncatlab articles.
05:48:40 <maerwald> we can't even get rid of String :)
05:48:58 <sm[m]> many docs are better at defining their terms for a non CS student eg
05:49:12 <Habib> dminuoso: let me try one last time for today :). the question in my mind about the way prettyprinter works is, i don't quite understand the separation between functions like vsep, pretty, <+>, nest, align - which all seem to suggest stuff to do layouting - and the layoutSimple, layoutPretty, etc. functions
05:49:13 <dminuoso> lortabac: That surely can't be a bad thing. PHP was a *toy* language that is also used commercially now.
05:49:23 <quazimod1> maerwald: seen unison language?
05:49:25 <lortabac> dminuoso: :D
05:49:27 <quazimod1> that thing gives me hope
05:49:37 <sm[m]> it wouldn't be hard to give a better intro to pretty printing in plain English. It's probably out there somewhere
05:49:52 <maerwald> quazimod1: never seen it
05:50:05 <dminuoso> Habib: https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf is a very nice read that might be easier than to dive into the implementation.
05:50:09 <quazimod1> it's pretty schmick
05:50:30 <quazimod1> some things in it are non strict
05:50:46 <quazimod1> such as boolean expressions
05:50:49 <Habib> dminuoso: cheers, i'll take a look at this tonight :_
05:50:51 <Habib> :)
05:50:53 <quazimod1> but then again i'm sure that's the case for many languages
05:50:57 <quazimod1> ... all languages?
05:51:08 <dminuoso> Habib: for me, it was just two bindings that instantly explained the entirety of prettyprinter to me
05:51:48 <sm[m]> (Maybe that General workflow section is it ? I'll have to read on a big screen)
05:51:49 <ski> quazimod1 : ah (looked at page 20, which talks about that). that quote is about intermediate representation, in conjunction with generating code to do update-in-place, inside a compiler. it doesn't apply at the user-level of the language
05:52:01 <dminuoso> Habib: Staring at hardline and softline for just a minute made me understand what Doc was about. :)
05:52:07 <kuribas> dminuoso: same for me, I have heared a lot of scary stories about lazyness causing, spaceleaks, but I never experienced it...
05:52:34 <ski> maerwald : "only equivalent if you ignore error/non-termination etc" -- yes, because partiality and non-termination are effects :)
05:52:38 <chreekat[m]1> I also bounced pretty hard off the division of paradigms in that pretty printer lineage
05:52:40 <ski> (side-effects, in Haskell)
05:52:40 <quazimod1> so what i'm getting is that I should use python for my quantitative finance program
05:52:59 <dminuoso> quazimod1: If you feel more comfortable with that, go for it.
05:53:06 <quazimod1> dminuoso: i want to burn python
05:53:15 <quazimod1> the quintessential 'im not a programmer' language
05:53:30 <quazimod1> fuck me the amount of garbage python code i've had to wade through
05:53:31 <dminuoso> quazimod1: All Im saying is, dont let the lazyness distract you from picking the language. It shouldn't matter at all.
05:53:37 <ski> dminuoso : "without getting confused by half a dozen ncatlab articles" -- haha :)
05:54:09 <maerwald> quazimod1: is this about an actual business or some toy program
05:55:01 <dminuoso> quazimod1: If you're not comfortable with Haskell, your main concerns should be "how long until you become comfortable enough to become productive" or "do you have good library support for what you intend to do", or "do you have the ability to hire/train people in the desired language if needed"
05:55:16 <quazimod1> maerwald: it's a project that i'm starting but professionally i work as a consulting tech lead for startups & corporate innovation ventures, i've taken a lot of things into production and this will be no different
05:55:33 <quazimod1> the only difference is that nothing i've done before was purely my choice, my team, or time sensitive
05:55:49 <quazimod1> so we settled with the RoR/Djangos, the typescripts, etc
05:56:10 <maerwald> quazimod1: doing a startup haskell project is very dangerous with little knowledge about the language imo and I'd advise against it
05:56:20 <sm[m]> Haskell may not be the quickest or cheapest to production but it will be the cheapest over the long haul
05:56:20 <quazimod1> and any time any data science/computation was needed someone would appear who wanted to do it in python, which everyone else was familiar with
05:56:29 <dminuoso> I second what maerwald just said. :)
05:56:50 <maerwald> Haskell is something you pick if you know what you're doing.
05:57:17 <kuribas> clojure when you don't...
05:57:21 <maerwald> lel
05:57:26 <quazimod1> i'm not worried about picking up and learning something, im' worried about having to fix another man's mistakes
05:57:40 <sm[m]> bah that has never been my approach :)
05:57:41 <kuribas> at least if you're confused about types
05:57:43 <quazimod1> django & it's 'rest framework' are full of mistakes that you have to fix
05:58:10 <dminuoso> quazimod1: It might take 6 months before you can write solid code though, if you're completely new to Haskell.
05:58:17 <sm[m]> Haskell is the language you can be sure you can refactor yourself way out of wrong decisions
05:58:27 <dminuoso> The curve is difference, you can't just "simply switch". Overall Id say its worth learning
05:58:32 <quazimod1> rails was good to me, to be honest. in fact ruby is the easiest language i've ever used and they're adding static typing to it so it'll be waaay more scalable soon. Shame it's so slow
05:58:34 <sm[m]> s/way//
05:58:46 <maerwald> sm[m]: also depends
05:58:51 <kuribas> yeah, I never understood the argument why clojure would be more "organic", as if it automatically grows with your problems...
05:59:02 <dminuoso> quazimod1: The type system is absolute rubbish. :)
05:59:09 <quazimod1> dminuoso: it's a type system at least
05:59:12 <dminuoso> It's not really
05:59:21 <quazimod1> i don't need it to be brilliant, i need it to stop devs making type mistakes
05:59:25 <maerwald> sm[m]: vertical refactoring isn't much easier (as in: change the way you express effects, exceptions etc)
05:59:36 <dminuoso> The main problem is, Ruby by design and ecosystem promotes reflection techniques and monkey patching so hard
05:59:38 <maerwald> horizontal yes
05:59:40 <quazimod1> dminuoso: have you inspected the rails 3 type system?
05:59:41 <dminuoso> The type system cant keep track of it
05:59:54 <dminuoso> quazimod1: Ive stopped with Ruby 2 years ago in favor of Haskell
05:59:56 <quazimod1> yeah the monkey patching isn't great
06:00:04 <sm[m]> quazimod1: yesod is a good industrial strength "rails" worth looking at - not as easy to use but faster
06:00:06 <kuribas> quazimod1: ruby (and python/perl/clojure/php...) are easy tot get started with, but hard to maintain.
06:00:24 <quazimod1> sm[m]: in 10 years i've never had speed issues with rails tbh
06:00:26 <sm[m]> you might also like to chat out the new IHP
06:00:26 <dminuoso> There's very few popular languages that I consider to have respectable type systems. Rust is one of them.
06:00:38 <kuribas> thanks to monkey patching, you never know what your standard library functions are doing.
06:00:44 <sm[m]> quazimod1: ok, I thought you just said it was slow
06:00:55 <quazimod1> sm[m]: for computation & the like, web server is fine
06:01:34 <quazimod1> dminuoso: i'm 90% settled on writing this thing in rust actually
06:01:41 <quazimod1> that language does not appear to fuck around
06:01:50 <quazimod1> the tooling is easy to use too, as far as i've used it
06:02:07 <maerwald> kuribas: what does ("/foo" </> "/bar") (from System.FilePath) return?
06:02:24 <quazimod1> but it was in reading about stuff that i stumbled on the lazy v strict thing... such a shame ocaml is surrounded by very ... non commercial thinking contributors
06:02:27 <kuribas> maerwald: "/foo/bar"?
06:02:29 <maerwald> no
06:02:53 <kuribas> "/foo//bar" then? :-)
06:03:01 <quazimod1> sm[m]: i don't think i would do any financial computation stuff in ruby, even ruby 3 with the JIT
06:03:06 <maerwald> kuribas: "/bar"
06:03:13 <kuribas> ??
06:03:16 <maerwald> :)
06:03:47 <kuribas> FilePath is a historical smell
06:03:48 <dminuoso> quazimod1: The one thing that Haskell is just pretty good at, reasoning about code like equational reasoning.
06:03:49 <sm[m]> quazimod1: I build a financial app in Haskell, its great
06:03:58 <maerwald> kuribas: https://github.com/haskell/filepath/issues/49
06:04:04 <quazimod1> sm[m]: tell me more
06:04:06 <dminuoso> For financial code, Haskell would be at the top of my list probably :)
06:04:13 <quazimod1> dminuoso: it appears to me that that's the case too
06:04:15 <maerwald> kuribas: just saying... are you *sure* we are doing better wrt sdlib :p
06:04:36 <dminuoso> The better you can reason about code, the more likely your code is correct, the easier you can maintain your code, and it makes refactoring that much easier.
06:04:46 <quazimod1> dminuoso: yeah i guess i got spooked by the lazy thing. It doesn't help that the jane street nerds specifically didn't use haskell because it would make their high speed trading less  predictable... which spooked me again 
06:04:50 <quazimod1> even though i'm nothing near high speed
06:04:52 <sm[m]> smooth evolution from "I have no idea what I'm doing" to "pretty decent architecture that gets the job done"
06:04:56 <kuribas> maerwald: at least it's consistently wrong :)
06:05:01 <sm[m]> over 13 years..
06:05:07 <Uniaika> sm[m]: :D
06:05:10 <dminuoso> quazimod1: One of Haskell's primary use is actually in financial institutions.
06:05:32 <dminuoso> It's not as if Haskell was "made for it" or that its "particularly well suited", but it *is* used there.
06:05:41 <sm[m]> quazimod1: (hledger.org)
06:05:54 <quazimod1> i can understand why, if i was going to analyse existing data it'd be different
06:06:06 <quazimod1> i'm sure lazy or not the throughput would be fantastic & the code very very reliable
06:06:12 <dminuoso> It felt like every third person I met in London as Haskell eXchange was working for some financial institution
06:06:13 <sm[m]> but yes look at cards I for a much more significant financial app
06:06:35 <quazimod1> also whoever mentioned clojure before: i do not need a language that encourages deveolpers to dump their brain thoughts into files thank you
06:06:40 <sm[m]> Cardano. Dangit, phone..
06:06:56 <quazimod1> i will never implement another thing in lisp again
06:06:58 <quazimod1> except emacs
06:07:15 <quazimod1> sm[m]: hey that's cool
06:07:51 <dminuoso> quazimod1: But yeah, dont be spooked by lazyness. Overally I think it makes writing code easier, and the rare space leaks it brings with it can be debugged - for some reason some people trip into space leaks more often than others.
06:07:55 <frdg> now that I think about it, Haskell isn't good for talking about sets because sets should be able to hold different types of elements.
06:08:09 <dminuoso> frdg: Why should it?
06:08:25 <quazimod1> dminuoso: so what do i do, use rust, python, ocaml or haskell for the quant app
06:08:54 <dminuoso> quazimod1: Why are you asking #haskell what you should do?
06:09:00 <dminuoso> That seems like the wrong question
06:09:04 <quazimod1> you're all pretty smart
06:09:13 <frdg> dminuoso: [1,2,foo] is valid mathematically but in haskell this is a type error.
06:09:14 <sm[m]> prototype in all until you see a winner!
06:09:14 <ski> Scheme is cool. CL seems a bit less principled, more focused on getting things done, now. haven't looked at Clojure
06:09:15 <dminuoso> Im not very smart
06:09:20 <dminuoso> Which is why Im using Haskell
06:09:21 <quazimod1> never had any jackassery here that i can remember
06:09:36 <dminuoso> It allows me to write good code *despite* being only average.
06:09:50 <sm[m]> heh same :)
06:09:54 <quazimod1> ski: CL is an abomination
06:09:57 <dminuoso> Of course people here will tell you how good Haskell is
06:10:03 <dminuoso> So Im not quite sure what you hope to hear.
06:10:05 <ski> frdg : "[1,2,foo] is valid mathematically" -- in actual mathematical practice, that doesn't happen (or only very rarely)
06:10:05 <quazimod1> lol
06:10:14 <quazimod1> i'm honestly thinking rust
06:10:17 <kuribas> ski: clojure is trying to be the cool kid, but adopting part of the new developments (purity), and completly trashing the rest (static types).
06:10:54 <dminuoso> frdg: In fact, completely unlimited sets lead to Russels Paradox!
06:11:01 <kuribas> ski: it's also a rather inefficient and clumsy approach to leverage the JVM.
06:11:52 <ski> frdg : the problem is that (due to the influence of Zermelo-Fraenkel set theory), math literature tends to not talk about the distinction between subsets (aka material sets), and sets/types (aka structural sets) .. even though, imho, it's a distinction that's implicitly present, very often
06:12:10 <quazimod1> ski: CL is like a perfect vision of beauty has had that 'the fly' thing done to it 
06:12:33 <ski> quazimod1 : .. yea, i tend to lean more to the Scheme side
06:12:42 <quazimod1> ever seen CLOS
06:12:47 <quazimod1> you _never_ need CLOS
06:12:51 <frdg> ski: ok this is nice to know
06:12:56 <dminuoso> My opinion is, if I wanted to drive a startup, I wouldn't pick a language that I had to learn first, especially if that language was so exotic, that I couldn't reasonably start to become productive in 2 weeks.
06:13:02 <quazimod1> it's okay, great to read about it just to see how else you could do OOP
06:13:21 <quazimod1> instrumented multiple inheritance. Yes please, sign me up. I'll take some flagellation too
06:13:44 <quazimod1> dminuoso: i'm not worried about that, i'm a consulting tech lead, that's all i do
06:13:50 * ski . o O ( "Interface-passing style" by Fare (FranÃ§ois-RenÃ© Rideau) in 2010-02-17 at <https://fare.livejournal.com/155094.html> )
06:13:50 <kuribas> CL was made to bring order in the chaos of all the different lisps, but without rewriting the language.  Scheme was made to rewrite the language, and make it small, elegant and consistent.
06:13:56 <dminuoso> Consulting on a language youd ont even know.
06:14:00 <dminuoso> Not sure whether that its better.
06:14:02 <dminuoso> :)
06:14:07 <quazimod1> dminuoso: getting paid a goddamn lot to do it too :P
06:14:15 <quazimod1> hey man all my customers are happy i make shit happen
06:14:19 <dminuoso> Maybe I should switch jobs
06:14:31 <dminuoso> I could do COBOL consulting perhaps.
06:14:39 <quazimod1> could probably make good money there too
06:14:44 <quazimod1> i know that the banks are having a hard time
06:14:45 <kuribas> quazimod1: cool, then you can start consulting on haskell?
06:14:57 <quazimod1> kuribas: if I took it seriously, yeah 
06:15:02 <dminuoso> Didn't Facebook just kick off some artificial intelligence project aimed to rewrite cobol in traditional languages?
06:15:04 <ski> that "Interface-passing style" is more or less using type classes (sans the uniqueness of instance), or rather, the explicit dictionary-passing implementation of it. (in a Lisp context)
06:15:05 <quazimod1> i wouldn't shy away from it
06:15:15 <dminuoso> frdg: Also, consider that `Set a` has an additional limitation in that it needs to satisfy a `Ord a` constraint (well not the type, but almost all its functions)
06:15:36 <quazimod1> i know i'd be studying my ass off to learn & understand it, and I don't lie to my clients about my understanding of something
06:16:43 <ski> kuribas : how does Clojure fare with STM ? i think i've heard they mentioned at the same time. and do you have any mutability (not counting if they're separated from the rest of the code like with `IORef' in Haskell. yes, that can be done, without static types) ?
06:16:58 <dminuoso> frdg: So that alone mandates the set be uniform, so comparisons even work.
06:17:03 <quazimod1> man 99% of my income is because, outside of IRC tomfoolery, I communicate pretty well and expect my staff to communicate pretty well too, you'd be surprised how well a venture can go with pretty meh commodity devs who are communicating with each other & the stake holders
06:17:06 <dminuoso> Without this, we couldn't have a performant (and thus useful) implementation
06:17:26 <kuribas> ski: I haven't done anything with concurrency in clojure...
06:18:05 <frdg> dminuoso: So what we have in haskell is `uniform sets`?
06:18:46 <dminuoso> or "homogenous" rather. yeah
06:18:52 <kuribas> ski: and yes, clojure has mutability, as it can access java objects.  But most clojure datatypes are immutable.
06:18:57 <ski> frdg : it doesn't happen, for the same reason as in programming. you need to know how to use the data as well. for a list in Haskell, if you have no idea whether an element is an integer, or a string, or another list, you can't do much useful, except passing them on to someone who knows. and even if you can query (like with dynamic typing), this tends to be clumsy, not lead to well-structured developments
06:19:29 <frdg> ok I understand
06:21:13 <sm[m]> quazimod1: do you hire only good communicators, or do you channel  client communications through a few senior people ?
06:21:25 <ski> kuribas : ok. i take that the mutability isn't "warded off / contained", or explicitly marked, with some kind of effect stuff ("tainting" ?), then
06:21:33 <kuribas> ski: nope
06:21:47 <quazimod1> sm[m]: my rule of thumb is to hire good natured & helpful seniors
06:22:23 <maerwald> quazimod1: many ppl hire for "IQ" in tech and then get confused why their team is an unmanagable mess :)
06:22:26 <quazimod1> client comms are tricky sometimes, ofc, especially when you've got arrogant fuckheads on the other side, frequntly happens
06:22:51 <quazimod1> maerwald: dont get me started on 'smart' people
06:22:55 <quazimod1> fucking worthless
06:22:58 <ski> frdg : of course, you can have more exotic things, like a list where the first element is a number, the next is a pair of numbers, the next is a pair of pair of numbers, &c. .. to express many such, you need dependent types (although sometimes one can encode them without)
06:23:35 <sm[m]> yes please don't maerwald :)
06:23:40 <maerwald> :p
06:23:44 <dminuoso> ski: Well, we can still have such things with intermediate data types in Haskell.
06:23:58 <quazimod1> too late i'm starting
06:24:02 <ski> frdg : but generally, you do have some kind of "order" that allows you to know what kind of value you're dealing with, without having to query (at least if you do express some amount of "querying" in terms of "tags", that is sum types)
06:24:14 <sm[m]> quazimod1: interesting but probably
06:24:15 <quazimod1> i have a guy doing ML for us... when he gets "bored" he "starts new projects"
06:24:22 <sm[m]> OT here
06:24:37 <maerwald> yeah, we have OT channels for that
06:24:48 <quazimod1> he's a vestigial remnant of a company that we work with. Soon to be snipped off
06:24:56 <quazimod1> what's OT
06:24:57 <ski> dminuoso : hm, elaborate on what you mean ?
06:25:14 <maerwald> and make sure you don't disclose names :p
06:25:19 <quazimod1> oh right, yeah n/p i'll let it go. Back to haskell. This white paper is hard to read :/
06:25:22 <sm[m]> off topic , at least at this busy time.
06:25:44 <sm[m]> especially if it's a rant :)
06:25:51 <ski> quazimod1 : ML as in SML,OCaml or F# ? or Machine Language ? or Machine Learning ?
06:25:59 <quazimod1> ski: machine learning
06:26:02 <maerwald> sm[m]: we barely rant here, do we? :angelface:
06:26:23 <dminuoso> ski: Well the particular example you named could just be encoded by `data P = S Int | P P P deriving (Eq, Ord)`, and then you can have `Set P` just fine.
06:26:36 <dminuoso> Oh wait
06:26:39 <dminuoso> I see what you mean
06:27:06 <sm[m]> maerwald not too much really :)
06:27:37 <ski> dminuoso : no, the example i had was more like `data DoublingList a = Nil | Cons a (DoublingList (a,a))' (a "non-regular data type", since it's not passing the same type parameters in the recursive call)
06:27:44 <dminuoso> Right
06:29:00 <quazimod1> , where 7!
06:29:09 <quazimod1> ignore
06:29:41 <ski> then, you can throw a `Maybe', like `data BinNumeral a = Nil | Cons (Maybe a) (BinNumeral (a,a))' and now you have a collection of arbitrary (finite) number of elements of `a', represented as a "binary numeral" "sequence of `1's and `0's". each `1' being a perfectly-balanced binary tree of size `2^n', where `n' is the index of the bit
06:29:44 <quazimod1> oh man so out of my depth, ->*  is the reflexive transitive closure of ->
06:29:47 <quazimod1> what the hell does that mean
06:30:03 <ski> quazimod1 : it means that `->*' is zero or more `->' steps
06:30:37 <quazimod1> lol
06:30:40 <quazimod1> nice
06:30:55 <ski> quazimod1 : so, for all `x', you have `x ->* x' (zero steps). and if you have `x -> y' and `y ->* z', then you have `x ->* z' (you can "add in" one more step)
06:31:03 <sm[m]> quazimod1: tip: easy to get lost in CS when learning haskell, common mistake is thinking it's the only way to get productive - it's not
06:31:25 <quazimod1> sm[m]: its the best way to not be productive, in fact you need none of this to ever be productive :P
06:31:46 <quazimod1> i don't know how i'm gonna build a stripe wrapper when my mind's caught up in this mess 
06:31:48 <kuribas> the best way is to start of with really crude haskell
06:31:48 <sm[m]> over the long term I think that's not true :)
06:31:58 <kuribas> then as you learn more to refine it.
06:31:59 <ski> (you could also express the latter rule by saying that if you have `x -> y', then you have `x ->* y' (one step). and if you have `x ->* y' and `y ->* z', then you have `x ->* z' (combine multiple steps with multiple steps. this is transitivity.) (the "zero steps" is reflexivity)'
06:32:36 * ski nods to sm[m]
06:32:36 <sm[m]> kuribas: that's my approach also
06:32:48 <quazimod1> by zero steps are we talking about intermediate transformations,  or computations?
06:32:53 <quazimod1> what is a step, here?
06:33:16 <kuribas> in fact, I find that often when I am stuck in to much refinement, it helps to start of with something dumb and basic, then gradualy rewriting it.
06:33:26 <ski> a "step" is the relation `->' you started with. could be any binary relation on a set. in your case, i presume it's some kind of reduction or transition step
06:33:57 <quazimod1> ski: it's actually page 4 of http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
06:34:42 <ski> from any binary relation `R' on a set, we can construct a binary relation `R*' that includes `R', and is both reflexive and transitive (so is a "partial order"). in fact, `R*' is the "smallest" such relation (doesn't include extra irrelevant cruft). that's why it's called the "reflexive-transitive closure"
06:35:50 <ski> quazimod1 : it's standard to talk about reflexive-transitive closure, when speaking more formally about the (small-step) operational/procedural semantics of programming languages
06:37:02 <ski> yea, in this situation, `x -> y' means that the expression `x' can reduce to the expression `y' "in one step". then `x ->* y' means that it can reduce, in zero or more steps
06:37:07 <quazimod1> i dont have a background in this maths
06:37:17 <quazimod1> does this fall into set or category theory?
06:37:17 <ski> yea, that's why i'm explaining
06:37:37 <ski> it's semantics of programming languages
06:37:37 <quazimod1> so the 'zero' in the zero or more steps is important
06:37:53 <quazimod1> why do we think abouth the zero, rather than 1 or more?
06:38:05 <ski> yea, sometimes you see `->+' for "one or more steps". that's "transitive closure" (without the reflexive part)
06:38:16 <ski> but i think it's more common to want to include the possibility of zero steps
06:38:33 <ski> well, one common use of this is to talk about confluence
06:38:54 <ski> say you have an expression `(2 + 3) * (1 + 4)'. you can imagine doing the additions in either order
06:38:58 <ski> so, you can go
06:39:13 <ski>   (2 + 3) * (1 + 4)  |->  5 * (1 + 4)
06:39:17 <ski> or else you can go
06:39:24 <ski>   (2 + 3) * (1 + 4)  |->  (2 + 3) * 5
06:39:26 <quazimod1> sure
06:39:45 <ski> but regardless of which path we take, we will eventually "converge" again, get back to the same spot
06:39:52 <ski>   (2 + 3) * (1 + 4)  |->  5 * (1 + 4)  |->  5 * 5
06:39:53 <ski> vs.
06:39:54 <quazimod1> skrj
06:39:58 <ski>   (2 + 3) * (1 + 4)  |->  (2 + 3) * 5  |->  5 * 5
06:40:01 <quazimod1> sorry, dvorak, sure
06:40:39 <ski> so, one way to express this is that if you have `x |-> y0' and also have `x |-> y1', then there should exist some `z' such that `y0 |->* z' and `y1 |->* z'
06:41:09 <ski> so, regardless of whether we go left or right, we'll eventually come to a common spot on the path, again
06:41:40 <ski> however, it could be that from `y0' you can get (in some steps) to `y1' itself
06:41:47 <quazimod1> ah sure, and the zero being the case that the y0 was the same as whe z anyway
06:42:58 <ski> so, then we want `z' to be `y1'. so the last part then becomes `y0 |->* y1' and `y1 |->* y1'. the last thing here wouldn't work, if we didn't include "zero steps" as a possibility. we'd have to try to add one step to both (and that's not always possible, depending on how one sets things up. and setting it up so it's always possible is an extra hassle)
06:43:04 <ski> yes
06:43:18 <ski> anyway, this is not category theory
06:43:56 <ski> (not really set theory, either, although it could use some set theory terminology)
06:44:32 <carter> Algebraic combinatorics! ;)
06:45:40 <quazimod1> yeah it didn't feel like category theory but its been a few years since i looked at that, and I never got particularly far into it so idno
06:46:10 <ski> quazimod1 : anyway, if you're interested, you can look at papers like this. and some of the insights or conclusions can be good to know about, from a more practical programming standpoint. but i wouldn't worry too much about not understanding things in such papers, if you're mainly interested in practical programming (e.g. in Haskell, or some other language)
06:47:31 <quazimod1> yeah certainly agree with you, i just get interested
06:47:45 <ski> (btw, that property with `x',`y0',`y1',`z' above, confluence, is sometimes called "diamond property", since if you draw it in a diagram, it looks like a rhombus)
06:49:19 <ski> one way to think about `R*' is that its like a "list of `R's". so `a R* z' means `a R b /\ b R c /\ c R d /\ ... /\ w R x /\ x R y /\ y R z', for some (possibly zero) number of `R' steps (some "list" of `R's)
06:49:57 <ski> (`A*' is also a common notation for a (possibly empty) list of elements of `A'. in Haskell, this is `[A]'. and `A+' for non-empty lists)
06:51:26 <quazimod1> the binary relation in our case can be anything right?
06:51:43 <ski> yes
06:51:58 <ski> as long as it's relating two elements from the same set
06:52:26 <quazimod1> sure but we're free to choose a suitably diverse set right?
06:52:33 <ski> yes
06:52:41 <quazimod1> may i ask why it has to be the same set
06:53:03 <quazimod1> if they're different sets, do we need to draw a ring around the 2 different sets & make a new set
06:53:55 <ski> the "reflexive-transitive closure" and the "transitive closure" are ways to "make" such binary relations transitive, or both reflexive and transitive, by "adding in more related pairs" (as few as possible), until we get a relation that satisfies the desired property
06:54:11 <frdg> \join #prolog
06:55:05 <ski> quazimod1 : you can do that, if you want to. you'd take the "disjoint/discriminated union" (same things as variant/sum type, and part of "algebraic data type") of the two sets/types, to get one that "includes the elements of both"
06:55:23 <ski> this is what a "bipartite graph" does, for the nodes/vertices, e.g.
06:55:31 <ski> frdg : haha :)
06:55:40 <ski> (it's actually ##prolog)
06:56:12 <frdg> heh thanks
06:56:52 <Super_Feeling> hey guys, is haskell is the right way to start learning about fp? the syntax is so hard, that i get confused all the time and concepts don't make sense
06:57:09 <ski> quazimod1 : usually, people would say that you take a "union" of the two sets. but more commonly, that's not what you want. in case there's no common element to the two sets, it makes no difference, but if there might be common elements, then usually you'd want the "sum type" version. in math, people often (clumsily) express this as saying you union a set with "a copy" of another set
06:57:55 <maerwald> Super_Feeling: yes
06:58:11 <ski> (this is another example of people in mathematics usually conflating subsets (/ material sets) with sets/types/sorts (/ structural sets))
06:58:45 <ski> Super_Feeling : is Haskell your first programming language ?
06:59:54 <quazimod1> Super_Feeling: are you me?
06:59:57 <quazimod1> from back in time
07:00:19 * hackage hills 0.1.2.7 - Generate STL models from SRTM elevation data.  https://hackage.haskell.org/package/hills-0.1.2.7 (djf)
07:00:53 <quazimod1> ski: my brain farted when you said that a bartite graph does this 
07:01:01 <ski> heh, why ? :)
07:02:13 <quazimod1> if you have  u0 -> u1 and u1 -> v1 then i'd get it
07:02:21 <quazimod1> but bipartite graphs don't do this
07:03:01 <ski> (note that the edges in an (undirected, non-multi) graph is just a binary relation on the set/type of vertices/nodes)
07:03:01 <quazimod1> so then i dont understand the modelling of the 'includes the elements of both' in a bipartite graph
07:03:40 <ski> for a graph, `->*' would describe paths in the graph
07:04:04 <quazimod1> mmm i can maybe understand
07:04:09 <quazimod1> if we have nodes in groups U & V
07:04:20 <quazimod1> then you could get from v1 to v2 by going into U
07:04:33 <quazimod1> i dont see any bipartite graphs with an edge from a node in V to another node in V
07:04:36 <quazimod1> is that what you mean?
07:04:50 <ski> (well, i suppose i should just say directed. for undirected, you add the requirement that the relation is symmetric. another way to express it is that instead of having edges be ordered pairs, you have them be unordered pairs)
07:05:33 <quazimod1> symmetric meaning goes in both directions?
07:05:37 <ski> yes
07:05:49 <ski> if `x -> y', then also `y -> x'
07:05:54 <quazimod1> yeah ok
07:06:09 <Super_Feeling> ski, no i've done a lot of python, js, go and c++.
07:06:12 <quazimod1> but referring to my earlier qusetion
07:06:21 <Super_Feeling> But i've no clue about fp, since i'm self taught
07:06:37 <ski> yea, for a bipartite graph, we'd have the additional requirement that there's no edges "inside" the two parts of the partition of the vertices
07:07:33 <ski> so it's not that you get exactly a bipartite graph, if you divide your nodes into two kinds/sorts/types/sets. but it's a nice way to think about it, although you still need that extra condition about no "internal edges"
07:07:55 <quazimod1> yeah see that completely threw me off
07:08:19 <quazimod1> otherwise, discounting that that additional rule in bipartite graphs I can understand what you mean now
07:08:34 <ski> Super_Feeling : well, learning another programming paradigm (like functional programming, or logic programming) will be a bit like learning to program all over from scratch again. it's not quite like that, but it's a good mindset to assume, when learning. you will need to unlearn things you're taking for granted
07:08:34 <quazimod1> also graphs are hard & weird
07:09:03 <ski> Super_Feeling : there are of course things that carry over. but it's better to set that aside, for the time being, until you got the basics under your belt
07:09:04 <quazimod1> Super_Feeling: i had a huge chip on my shoulder when it came to my inadequacies re. trying to understand monads
07:09:23 <quazimod1> step 1: pick up haskell & try to build something simple with it
07:09:35 <quazimod1> step 2: read & watch a lot of youtube videos about FP & haskell
07:09:38 <ski> Super_Feeling : do you remember how confused you were, when you learned programming initially, how the concepts didn't make sense ?
07:09:45 <Super_Feeling> exactly, it's like everything we do in oop has no place here in haskell
07:09:47 <quazimod1> the maths theory is an indulgence, you don't need to do it
07:09:49 <Super_Feeling> yes, makes sense
07:10:05 <quazimod1> Super_Feeling: everything you do in oop has no place here
07:10:17 <quazimod1> lol, i guess thats true?
07:10:48 <ski> yea .. for monads, i think most "monad tutorials" out there doesn't help that much (there are a few exceptions), possibly even making it harder to understand
07:11:19 <quazimod1> ski: you know functor is a craaaaazy intimidating name for something that's pretty freaking simple
07:11:52 <ski> the best practice, i think, is to first learn properly how the basic type system works, with type signatures, `data' types, polymorphism, parameterized `data' types, type classes .. before trying to tackle monads. also, start by learning particular monads, not by trying to grasp the general concept
07:12:00 <Super_Feeling> i guess i will continue with "real world haskell"
07:12:21 <quazimod1> Super_Feeling: i'm not really a haskell developer, ski's forgotten more about haskell than I ever knew. But I'd say everything we do in oop kinda sucks anyway
07:12:28 <maerwald> quazimod1: I have the unpopular opinion that monads give way to OOP style programming in haskell
07:12:29 <quazimod1> it's post modernism for programming
07:13:14 <maerwald> The main (informal) property about OOP is, imo, that it clouds control flow
07:13:15 <quazimod1> Super_Feeling: just build basic stuff & work yoru way up
07:13:22 <maerwald> Monads can do the same (especially transformers)
07:13:24 <ski> quazimod1 : well, there are some good modularity things in OOP. but they're not exclusive to OOP. also, "objects are a poor man's closures" (there's also the reverse saying, in OOP circles, "closures are a poor man's objects" ;)
07:14:18 <quazimod1> i dno man
07:14:46 <ski> quazimod1 : yea. perhaps one could have called it `Container' (or something like that) instead of `Functor'. however, that term already have lots of (subtly) different connotations. sometimes it's just better to use a "new" word, that's not encumbered with lots of associations which may be inappropriate
07:14:50 <Super_Feeling> okay so basically start building calculators in haskell, and work your way up lol (that's how i learned cpp)
07:15:01 <quazimod1> oop feels like a group of dudes got together, started echoing each other's anthropomorphisations (or should i say objectomorphisations) and then now por Super_Feeling needs to know 'oop patters' and it still sucks to write complex or big programs
07:15:30 <ski> quazimod1 : furthermore, by using the established (in math) term "functor", we can (more easily) make use of existing theory and insights regarding functors
07:15:44 <quazimod1> ski: not saying it's something to change, not even hinting at that
07:15:45 <quazimod1> just saying
07:15:53 <quazimod1> how hilariously scary that word is vs what is actually happening
07:16:49 <ski> but yes, i understand it can feel intimidating, to see some apparently alien jargon, that one hasn't a clue (based on commonly used terminology) what it might mean. especially if one's not used to doing that
07:17:22 <quazimod1> mostly since it's not even a type of function
07:17:28 <quazimod1> i hear functor i'm like
07:17:31 <quazimod1> scary function
07:17:34 <quazimod1> scary happenings, run
07:17:52 <quazimod1> then you say 'oh yeah that data type is a functor'
07:17:54 <quazimod1> lol wtf?
07:19:19 <ski> maerwald : i'm not sure about the "OOP" part, but i'd agree that sometimes we seem to reach to easily for a monad (which is basically doing imperative programming, although sometimes a very powerful form of imperative programming, and neatly separated from the rest of the language, in Haskell), rather than seek a more "declarative" (or "denotative" as conal prefers to call it) style
07:19:23 <quazimod1> hey here's aweird one, suppose that you have a type that's like a ternary maybe, like Just x, Kinda x, None
07:19:31 <quazimod1> that can't really be a functor can it
07:19:39 <sm[m]> Super_Feeling: you may find https://code.world or 
07:19:39 <sm[m]> @where haskell-via-sokoban good
07:19:40 <lambdabot> https://haskell-via-sokoban.nomeata.de
07:21:13 <quazimod1> dumb question i guess, isuppose it could be a functor depending on semantics
07:21:28 <maerwald> ski: monads are the most expressive tool and must be avoided most, as such
07:21:34 <ski> quazimod1 : well, thing is, it is "a type of function" .. only, a function on the type level
07:21:39 <maerwald> and for pretty practical reasons: they're slow
07:21:40 <sm[m]> ack, missed them
07:21:52 <quazimod1> ski: you talking about fmap?
07:21:55 <ski> no
07:21:58 <quazimod1> or `functor`
07:22:04 <quazimod1> oh, ok new brain fart
07:22:16 <ski> take `Tree'. this is a function that, given a type, produces another type
07:22:24 <quazimod1> the data type maybe is a function at the type level, let me think
07:22:33 <quazimod1> Yeah that's fair
07:22:37 <ski> so, if we pass `Int' to `Tree', we get `Tree Int', the type of trees of `Int' (trees with elements of type `Int')
07:22:39 <quazimod1> hey look at that you made me smarter
07:23:07 <ski> `Tree' could also be said to be a parameterized type, a "type template", an "incomplete/unsaturated type"
07:23:10 <quazimod1> i hadn't really thought about it like that but yeah that's fair
07:23:48 <John20> Hi All, is it correct to say that Haskell language extensions increase the space of valid 'haskell' programs? e.g. if a program is valid in core haskell, it will also be valid with extension A switched on?
07:23:48 <quazimod1> im trying to imagine a type that's a functor but not a type function
07:24:01 <ski> quazimod1 : if you define `data TernaryMaybe a = None | Kinda a | Just a', then `TernaryMaybe' is a functor
07:24:15 <ski> but perhaps you wanted `Kinda' and `Just' to hold items of different types ?
07:24:35 <quazimod1> TernaryMaybe is weird
07:24:48 <sm[m]> broadly but not 100% true I think, John20
07:24:54 <ski> maerwald : yea, there's something to be said for that. <https://en.wikipedia.org/wiki/Rule_of_least_power>
07:25:02 <quazimod1> i wonder if you could throw in an fmap that takes more than 1 function 
07:25:26 <maerwald> ski: that rule isn't popular in here :p
07:25:51 <ski> John20 : mostly. some extensions introduce new keywords, though, which can't be used as identifiers then
07:26:46 <quazimod1> ok it's 1am in sleepy sydney
07:26:58 <quazimod1> time for me to hit the hay, have to wrestle a kangaroo tomorrow
07:26:59 <ski> maerwald : it's about the tradeoff between expressiveness / expressive power (/ "cavalier power") and "reasonability" / reasoning (including refactoring) power (/ "predictive power")
07:27:48 <ski> quazimod1 : "i wonder if you could throw in an fmap that takes more than 1 function" -- see `Bifunctor',`Difunctor' (hrm, `Profunctor' ..)
07:27:53 <ski> @type bimap
07:27:54 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
07:28:02 <ski> @type dimap
07:28:03 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
07:28:07 <John20> Thanks sm[m] and ski. That answers my question
07:28:19 <ski> > bimap (* 2) show (3,4)
07:28:22 <lambdabot>  (6,"4")
07:29:44 <ski> > dimap (+ 2) (+ 2) (^ 2) 3
07:29:47 <lambdabot>  27
07:30:42 <quazimod1> that's cool
07:31:00 <ski> quazimod1 : "im trying to imagine a type that's a functor but not a type function" -- all functors are type functions. but not necessarily vice versa. e.g. `Endo',`IORef',`Comparision' (with `type Comparision a = a -> a -> Ordering')
07:31:35 <ski> quazimod1 : anyway, good night, and have fun with programming, whether in Haskell or otherwhere :)
07:31:55 <quazimod1> btw profunctor is cool
07:32:01 <quazimod1> i hadn't considered that
07:32:17 <ski> note how it goes in "opposite direction" in one type parameter
07:32:25 <quazimod1> i cant imagine a specific use but i'm sure ive come across that
07:32:27 <quazimod1> yeah
07:32:38 <quazimod1> that's neat
07:32:40 <ski> that's known as being "contravariant". there's `Contrafunctor' for contravariant functors (ordinary ones are covariant)
07:32:52 <quazimod1> and like i said, i'm sure there are places where this abstraction could have been a neat solution
07:32:59 <ski> contravariant functors are "consumers". covariant ones are producers
07:33:23 <quazimod1> i dont understand the consumer/producer thing
07:33:23 <ski> a bifunctor is covariant in both parameters. a difunctor (cough, "profunctor") is contravariant in one parameter, and covariant in the other
07:33:45 <ski> (covariance and contravariance also crops up, with subtyping in OOP)
07:34:08 <ski> consider `Tree a', this "produces `a's" in the sense that you can get `a' elements from it
07:34:20 * hackage libfuse3 0.1.1.1 - A Haskell binding for libfuse-3.x  https://hackage.haskell.org/package/libfuse3-0.1.1.1 (yohashi)
07:34:22 <quazimod1> sure
07:34:34 <ski> `Maybe a' is similar, and so is `IO a' (although you can't "escape" from `IO'). you can still `fmap' over `IO', though
07:34:53 <quazimod1> sure
07:35:03 <ski> but if you have `type Predicate a = a -> Bool', then a `Predicate a' is a consumer of `a's, not a producer (same for `Comparision' above)
07:35:08 <quazimod1> also, for another time, i do not understand why you cant 'escape' from IO
07:35:44 <ski> another example is something like `newtype Sink a = MkSink (a -> IO ())', that's used to throw `a' values to somewhere else, perhaps in another concurrently executing thread. that's also contravariant
07:36:03 <quazimod1> oh i see what you mean
07:36:28 <ski> if you have a `Chan a', that's a concurrent channel that you can both write to, and read from, from different threads
07:36:53 <ski> sometimes it may be good to "separate" the read and the write ends, so that you have `ReadChan a' to read `a's from, and `WriteChan a' to write `a's to
07:37:21 <ski> `ReadChan' can be made into a (covariant) functor (so `Functor'), while `WriteChan' can be made into a contravariant functor (`Contrafunctor')
07:37:55 <ski> you can do the same thing with references to mutable cells, like `IORef',`IOArray',`MVar', have separate read and write interfaces to them
07:38:17 <ski> the point of doing this, is if you want to ensure that one part of the program can only read from it, and another part of the program can only write to it
07:38:39 <quazimod1> I think that I understand
07:39:31 <ski> (i think people doesn't do this, that commonly, but it could be done. being able to `fmap' or `contramap' (for contravariant functors) over them could be handy, in some cases. `Chan',`IORef',`IOArray i' are not functors at all, neither covariant nor contravariant, you can't "map" over them)
07:42:41 <quazimod1> this all makes sense
07:42:43 <quazimod1> also i really should seep!
07:42:54 <quazimod1> peace, tomorrow!
07:42:55 <ski> have fun !
07:50:50 <hololeap> @unmtl StateT s (ErrorT e (ReaderT r m)) a
07:50:51 <lambdabot> s -> r -> m (Either e (a, s))
07:51:06 <hololeap> @unmtl ReaderT r (StateT s (ErrorT e m)) a
07:51:06 <lambdabot> r -> s -> m (Either e (a, s))
07:53:06 <hololeap> so, where you place a ReaderT doesn't change anything except the order of input arguments?
07:55:18 <ski> @unmtl ReaderT r (ContT o m) a
07:55:18 <lambdabot> r -> (a -> m o) -> m o
07:55:19 <ski> @unmtl ContT o (ReaderT r m) a
07:55:19 <lambdabot> (a -> r -> m o) -> r -> m o
07:55:28 <ski> @unmtl StateT s (ContT o m) a
07:55:28 <lambdabot> s -> (a -> s -> m o) -> m o
07:55:49 <ski> @unmtl ContT o (StateT s m) a
07:55:50 <lambdabot> (a -> s -> m (o, s)) -> s -> m (o, s)
07:55:57 <ski> hololeap : "depends"
07:57:19 <ski> also, `ReaderT r (LogicT m) a' is not the same as `LogicT (ReaderT r m) a'
07:57:35 <ski> (where `LogicT' is more or less "`ListT' done right")
07:57:39 <ski> @wiki ListT done right
07:57:39 <lambdabot> https://wiki.haskell.org/ListT_done_right
07:58:45 <ski> @hackage logict
07:58:45 <lambdabot> https://hackage.haskell.org/package/logict
08:20:09 <AWizzArd> Using the `req` http client – is there a way to get the request as a String? The headers and body? The data that it will send over the wire?
08:37:54 <dminuoso> AWizzArd: To what end?
08:41:51 <dminuoso> At any rate, judging from the API, you could use req' to do that.
08:45:59 <dminuoso> You dont get any access to the primitives that generate the raw string though.
08:46:03 <dminuoso> That's hidden deep inside https://hackage.haskell.org/package/http-client-0.7.2.1/docs/src/Network.HTTP.Client.Request.html#requestBuilder
08:48:20 <AWizzArd> dminuoso: okay I see, thx. I saw that there *are* tools to analyze the response (but not the request).
08:48:42 <dminuoso> There's also several steps in between that do modifications to the request.
08:49:08 <dminuoso> So req' only gives you access to an early less-modified version of it
08:52:22 <AWizzArd> I found a QQ that lets me write multiline strings: http://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html
08:52:36 <AWizzArd> Is there something that outputs Text or ByteString?
08:53:28 <dminuoso> AWizzArd: there's string-qq
08:53:56 <dminuoso> You could trivially make your own QQ around the one from raw-strings-qq as well)
08:54:12 <dminuoso> It's just a matter of `fmap fromString`
08:54:32 <AWizzArd> dminuoso: perfect, I wasn’t brave enough to ask even for this.
09:11:29 <tomsmeding> AWizzArd: if all you're after is multiline strings, not necessarily the lack of escape sequences, then plain haskell has that :p
09:11:52 <tomsmeding> thing = "this is a\n\
09:11:57 <tomsmeding>       \multiline string"
09:12:13 <tomsmeding> (... with two more spaces)
09:20:51 <AWizzArd> tomsmeding: I considered that, but it’s just not readable.
09:21:08 <AWizzArd> tomsmeding: the [s| ... |] macro works fine.
09:30:29 <maerwald> pretty much all quasiquoters are broken on unicode, aren't they?
09:31:54 <maerwald> https://github.com/audreyt/string-qq/issues/2
09:32:18 <maerwald> ah, it was the old bytestring issue
09:33:08 <maralorn> I have made good experiences with https://hackage.haskell.org/package/interpolate-0.2.1/docs/Data-String-Interpolate.html#v:i
09:33:42 <maralorn> No, wait. That's not the one I meant.
09:34:00 <maralorn> This one. https://hackage.haskell.org/package/string-interpolate-0.3.0.2/docs/Data-String-Interpolate.html#v:i
09:34:05 <maerwald> maralorn: https://github.com/sol/interpolate/issues/14
09:34:07 <maerwald> haha
09:34:10 <maerwald> I'm right
09:34:49 <maerwald> https://gitlab.com/williamyaoh/string-interpolate/-/tree/master#unicode-handling
09:34:54 <maralorn> Gonna test that. now.
09:35:19 <AWizzArd> maralorn: besides what maerwald said this looks even nicer.
09:36:31 <maerwald> nice table https://gitlab.com/williamyaoh/string-interpolate/-/tree/master#features
09:39:38 <maralorn> I remember using string-interpolate in a library of mine and promptly got a PR patching all uses out …
09:39:50 <maralorn> Okay, admittedly it was only one use. So it was kinda useless.
09:40:08 <maerwald> also note that quasiquoters break/confuse hasktags
09:40:20 <maralorn> What's that?
09:40:37 <maerwald> @hackage hasktags
09:40:38 <lambdabot> https://hackage.haskell.org/package/hasktags
09:43:48 <maralorn> Ah, don‘t use that.
09:43:56 <maralorn> I don‘t use that.^^
09:44:05 <maralorn> This was not a recommendation.
09:45:27 <maerwald> it's the only thing that lets you jump to library definitions
09:45:36 <maerwald> (via codex)
09:47:05 <geekosaur> but any kind of quoter or macro processor will generally make tags utilities unhappy unless they do full parses. which ghci does, but then has a lame tags generator
09:48:34 <maerwald> GHC parses isn't exposed I hear
09:50:30 <geekosaur> no, but haskell-src-exts is. and there are plugins. but tags utilities have to combine normal parsing with regex since it generates regexes for a tags-consuming program to use, so it all gets fairly tricky
09:53:06 <geekosaur> of course, if you follow this all too far, you land in the mess of semantic editors
09:58:01 <maralorn> hls will soon have jum to library definitions.
09:59:34 <sm[m]> that's going to be great!
10:01:35 <Guest_62> I'm having problems installing haskell
10:02:13 <Guest_62> i have a mac
10:02:17 <davean> Guest_62: did you install it via ghcup? Or did you do pieces on your own?
10:02:36 <Guest_62> via ghcup
10:02:41 <davean> What went wrong?
10:02:48 <maerwald> PATH
10:02:51 <maerwald> :)
10:03:16 <sm[m]> docs! :)
10:03:32 <maerwald> sm[m]: there's enough info, but ppl don't read it 
10:04:03 <davean> I do not understand why people don't read directions
10:04:15 <sm[m]> it's still a docs fail somehow.. if they're necessary, how do you ensure they are read...
10:04:19 <maerwald> could add a quizz at the end of the installation that tries to figure out if the user has read the instructions
10:04:28 <sm[m]> indeed
10:04:39 <sm[m]> or have the script print the required docs to the console ?
10:04:50 <maerwald> oh, they left
10:04:59 <sm[m]> very wise :)
10:05:18 <sm[m]> maerwald: could the script do whatever docs are telling users to do ?
10:05:27 <davean> thats not reasonable
10:05:38 <maerwald> and it's platform dependent
10:05:39 <davean> Nor desirable
10:05:41 <sm[m]> sometimes, but it's valid question to ask
10:05:52 <sm[m]> I don't say it's easy or always desirable
10:05:55 <maerwald> many mac users here ask how to *open a file*
10:06:27 <sm[m]> PATH in particular trips up almost every new user and is something that really should be more automatable
10:06:36 <ghoulguy> maerwald: When I start ghcup tui, all the outdated GHC versions tend to dominate the screen. This will only get worse over time. Do you think we could come up witha  better order that features the more useful list entries with the outdated stuff below?
10:07:04 <sm[m]> (I'm not pointing the finger at ghcup here, I have the same problem in my docs)
10:07:14 <maerwald> ghoulguy: https://gitlab.haskell.org/haskell/ghcup-hs/-/issues/69
10:07:54 <sm[m]> stack's install script and stack itself print a clear(ish) warning about PATH on the console, that's something at least
10:08:54 <maralorn> simonmic: I despise scripts as replacement for documentation. They keep me stupid.
10:09:29 <maerwald> and unix is so messy, there's no real API to add something to PATH
10:09:41 <davean> Yah, and it varies by shell and other factors
10:09:41 <ghoulguy> maerwald: Thanks. I left some notes.
10:09:46 <davean> PATH is a really complicated variable.
10:09:54 <sm[m]> maralorn: if you stick to that view, we'd never get anywhere
10:10:07 <sm[m]> some abstraction is needed
10:10:25 <maralorn> simonmic: Well I think it depends on the situation. ;-)
10:10:27 <sm[m]> I for one am heartily sick of explaining PATH issues
10:10:29 <maerwald> davean: it's reassuring that the entirety of nix is based on that variable :p
10:10:46 <koala_man> my favorite PATH fun fact is that you can put a literal tilde in it, and only bash will treat it as your home dir
10:10:51 <davean> maerwald: thats hardly true
10:11:06 <maralorn> maerwald: sudo cp .bin/* /usr/bin?
10:11:19 <maerwald> sudo: command not found
10:11:25 <maralorn> Very clean api
10:11:47 <maerwald> I despise scripts that assume I have sudo... and I despise scripts that just run it
10:16:10 <dsal> Running it from inside a command is quite wrong.
10:16:49 <yushyin> to make things more interesting, I use zsh's option to treat PATH as a Set. `typeset -U path; path+=(~/.local/bin)' :)
10:18:56 <sm[m]> this is not helping! :)
10:41:45 <maerwald> I think the solution is to refine the automatic shell detection logic and do the right thing when ppl just hit the ANY key in anger
10:42:37 <geekosaur> then there's getting the running shell to acknowledge it somehow
10:43:11 <geekosaur> and no, kill -9 $PPID won't cut it :)
10:44:32 <maerwald> geekosaur: that reminds me of my coc.nvim bug report for being able to shut down the LSP server. I was told to use kill :)
10:47:19 <dsal> GHC used to have that feature where it deleted bad code...
10:57:22 <maerwald> and then it deledted itself? :)
10:57:36 <monochrom> Haha leave no evidence :)
10:57:52 <dolio> No, GHC passed its own type checker at that point, probably.
11:25:20 * hackage ordinal 0.2.0.0 - Convert numbers to words in different languages.  https://hackage.haskell.org/package/ordinal-0.2.0.0 (wvanonsem90)
11:41:50 * hackage commander-cli 0.10.0.0 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.10.0.0 (sgschlesinger)
12:03:20 * hackage commander-cli 0.10.0.1 - A command line argument/option parser library  https://hackage.haskell.org/package/commander-cli-0.10.0.1 (sgschlesinger)
12:25:06 <tomsmeding> "deleted bad code" as in, if code doesn't typecheck, let's just not run it?
12:25:25 <tomsmeding> that's eerily reminiscent of the behaviour of C compilers in the presence of undefined behaviour
12:25:49 <ski> tomsmeding : no, deleted the source file
12:26:15 <tomsmeding> oh, that's far better
12:26:20 <monochrom> :)
12:26:21 <tomsmeding> good bug
12:29:12 <shaman_king> hi
12:29:16 <shaman_king> i think haskell is shit.
12:29:21 --- mode: ChanServ set +o monochrom
12:29:27 --- mode: monochrom set +b *!*@185.65.134.170
12:29:27 --- kick: shaman_king was kicked by monochrom (shaman_king)
12:31:52 --- mode: monochrom set -bbbb *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.1.242.183 *!*@50-36-180-21.alma.mi.frontiernet.net *!*@gateway/web/cgi-irc/kiwiirc.com/ip.91.217.246.19 *!*@192.95.191.129
12:33:02 --- mode: monochrom set -bo *!*@gateway/web/cgi-irc/kiwiirc.com/ip.147.135.116.81 monochrom
12:52:57 <koz_> 0 to kick in less than 10 seconds, nice.
12:53:36 <monochrom> I was still too slow. :)
12:54:18 <dolio> Yeah, should hav IP banned when they were here yesterday. :)
12:54:42 <geekosaur> they were on different IP
12:54:43 <Uniaika> I say, k-line the whole /16
12:54:49 <dolio> Oh were they?
12:54:51 <geekosaur> and using webchat
12:54:53 <geekosaur> yes
12:55:36 <geekosaur> Uniaika, pity that wouldn't work, 3 different /16s too
12:59:01 <Uniaika> ah damn
12:59:06 <monochrom> In the past 10 days I can only find 185.65.134.*.  But I only grepped for "shaman".  Is there some other things I can look for?
13:00:05 <monochrom> Well, I can do the known right away.
13:00:07 --- mode: ChanServ set +o monochrom
13:00:28 <geekosaur> I looked at the scrollback where monochrom took off the past two days. and I specifically recall him quieting (not banning) his address via webchat
13:00:29 --- mode: monochrom set -b+b *!*@185.65.134.170 *!*@185.65.134.*
13:01:21 <geekosaur> and saw removal of (what I think are) those today before monochrom deopped
13:03:32 <maerwald> and I wanted to know what he had to say...
13:03:55 <geekosaur> all three by "shaman_king" and all basically the same drivel
13:05:05 <monochrom> I haven't used quieting for a long time. And today I didn't touch the quiet list, I removed old bans, some several months old, some one week old.
13:05:54 <monochrom> (The unbans were about 35 minutes ago.)
13:08:24 <monochrom> The ban that I placed on Sep 30 and removed today was for "I'm so h0rny now. Wanna trade. ...", doesn't look like shaman_king.
13:08:44 <geekosaur> ok, yesterday was a kick apparently (I'm looking at ircbrowse which is not good about how/where one joined/parted)
13:09:31 <monochrom> Yesterday they quitted before I was fast enough to kickban.  I didn't place a ban for that.
13:09:46 <monochrom> My ban yesterday was for fog.
13:10:02 <geekosaur> hm
13:10:13 <sm[m]> seems excessive
13:10:16 <geekosaur> I can't tell that from ircbrowse apparently
13:10:41 <geekosaur> also I am just about out of time for today :/
13:14:14 <dminuoso> How do quasiquoters break/confuse hasktags?
13:14:36 --- mode: monochrom set -o monochrom
13:17:20 <maerwald> dminuoso: https://github.com/MarcWeber/hasktags/issues/78
13:18:32 <dminuoso> Mmm curious that hasktags doesnt use haskell-src-exts
13:18:40 <dminuoso> But I guess that's the answer.
13:32:50 * hackage phonetic-languages-ukrainian 0.2.3.0 - Prepares Ukrainian text to be used as a phonetic language text  https://hackage.haskell.org/package/phonetic-languages-ukrainian-0.2.3.0 (OleksandrZhabenko)
13:32:52 <maerwald> sm[m]: cabal.project in hledger doesn't parse :>
13:33:50 * hackage uniqueness-periods-vector-common 0.4.1.0 - Generalization of the dobutokO-poetry-general package functionality  https://hackage.haskell.org/package/uniqueness-periods-vector-common-0.4.1.0 (OleksandrZhabenko)
13:35:04 <sm[m]> maerwald: thanks.. how do I reproduce that ?
13:35:54 <maerwald> cabal build?
13:37:01 <sm[m]> ah cabal build all
13:37:32 <sm[m]> I get cabal: The program 'ghc' version >=7.0.1 is required but it could not be found. But that's not what you mean I guess ?
13:37:54 <sm[m]> cabal-install 3.2 here
13:38:16 <maerwald> https://paste.tomsmeding.com/kJrW4XQR
13:38:21 <maerwald> 3.4 prerelease
13:40:10 <sm[m]> it's complaining about the line 8 here I think ? https://paste.tomsmeding.com/Wgovb0sq
14:04:09 <leungbk> When is it correct to use 'in' with a 'let' expression?
14:05:19 * hackage uniqueness-periods-vector-general 0.4.5.0 - Some kind of the optimization approach to data inner structure.  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.4.5.0 (OleksandrZhabenko)
14:06:42 <koz_> leungbk: Everywhere except do-notation.
14:06:59 <leungbk> Thanks.
14:07:12 <koz_> Do you have a specific example that's throwing you?
14:09:08 <leungbk> I was writing a simple graph algorithm just now, but after your remark I noticed I was one 'in' short.
14:09:34 <koz_> Are you nesting lets or something?
14:13:16 <leungbk> Yeah, I used 'let' to define an inner function and then used 'let' within that inner function. Maybe it would have been better to use 'where' somewhere.
14:13:49 <koz_> Or just define a non-exported top-level function.
14:14:04 <koz_> There's no need to jam everything into one big blob. We have modules with export lists for a reason.
14:14:49 * hackage uniqueness-periods-vector-examples 0.9.1.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.9.1.0 (OleksandrZhabenko)
14:15:22 <monochrom> I simply developed a habit of entering "let <newline> in ???" and then fill it in. (I don't want to go out of my way to configure my editor to automate this.)
14:16:36 <leungbk> I shied away from a separate top-level functio since I needed to read some local variables, and since the function I had defined was recursive.
14:16:36 <leungbk>  
14:16:55 <leungbk> I prob need to rethink it though.
14:16:58 <monochrom> Don't worry, you're doing fine. :)
14:17:52 <monochrom> I understand that when there is a choice, some people's way of thinking prefers let-in, some other's prefers where. Or generally define-before vs define-after.
14:18:09 <monochrom> Very generally bottom-up vs top-down.
14:18:38 <monochrom> Me, I'm a quantum superposition of both.
14:20:50 * hackage typed-encoding 0.5.1.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.5.1.0 (rpeszek)
14:21:04 <pjb> You have to know all those processes, and mix and match them depending on your knowledge.  
14:21:11 <pjb> They are discovery processes.
14:21:21 <pjb> If you know the algorithm you can just code it from a to z.
14:21:48 <pjb> If you don't you need to design or explore, so writing code in all direction is possible.
14:23:00 <monochrom> For that reason, people used to advocate prototyping and then throwing away the prototype and restarting from scratch.
14:23:46 <monochrom> I am really fond of that.
14:24:22 <monochrom> But at some point of time, the next generation decided that they couldn't stand throwing away "hard-earned" code.
14:25:26 <orzo> i'm having a frustration with cabal.  The v2-configure command wants to download a version of a library that i already have installed that works perfectly well to build the project
14:25:39 <orzo> I mean, it wants to download a newer version
14:25:46 <orzo> but i want it to work with what's here
14:25:53 <orzo> it seems like it should be working with what's here
14:26:06 <orzo> because that's the path of least effort for it
14:26:20 <monochrom> Ironically it was the new generation that could easily afford throwing away code wholesale, because they had much more decent VCS (compared to the older generation that believed in throwing away prototypes) such that "throwing away" means you never lost it, you could always refer to it again.
14:27:57 <monochrom> You have to use "cabal freeze" to prevent bringing in a newer version.
14:28:03 <orzo> aha
14:28:33 <orzo> i use v2-* commands
14:28:39 <orzo> does that mean i should have a v2-freeze?
14:28:55 <monochrom> And if you use it later, e.g. now, the generated "cabal.project.freeze" likely selects the newer version, so you have to edit it to select the older version.
14:28:55 <orzo> cabal 3.2
14:29:07 <monochrom> 3.2 means the default is v2.
14:30:29 <orzo> freeze doesn't work like i hoped
14:30:37 <monochrom> There is probably also a way you first tell cabal "roll back your hackage index to this date in the past", and then your "cabal freeze" will be more meaningful in freezing the older version numbers you desire.
14:30:45 <orzo> is there a way to just specify library versions directly?
14:31:37 <orzo> i edited the cabal file to verify the installed library works
14:31:41 <orzo> but i don't want to do that
14:31:53 <monochrom> edit cabal.project.freeze ?
14:32:14 <orzo> so i conigure, freeze, and then edit that to change the lib version?
14:32:19 <sclv> new style encourages using the latest and rebuilding and freezing is the way to avoid that
14:32:21 <monochrom> yeah
14:32:52 <sclv> but going with the nonfrozen latest stuff is a nicer workflow for me tbqh
14:33:13 <orzo> this is all working around a bug in cabal though, right?  I mean shouldn't the default behavior be to do what I want?
14:33:37 <dminuoso> Mmm, I wish we had per-module dependencies. That way I could depend on some of the more nasty packages without pulling in a huge hunk of transitive dependencies if I only need one module.
14:33:43 <monochrom> https://xkcd.com/303/ applies
14:33:56 <monochrom> No, this is considered a feature.
14:34:56 <orzo> My rationale is "do as little as neccessary to get it to build."  What is the rationale for the default behavior?
14:35:04 <monochrom> I liked the v1 way, too.  But I have accepted v2 and accepted that I would need to freeze, and I would need to do that early enough.
14:35:36 <monochrom> "get as many latest bugfixes as possible"?  I don't know.
14:36:11 <monochrom> Also, in v2, "configure" is highly redundant.
14:36:58 <dminuoso> orzo: Btw, v2- without freezing style promotes using PVP bounds. So if your dependencies make large jumps, you're missing a bound.
14:37:16 <dminuoso> If you have tight bounds, think of this as a feature, where you're getting bugfixes automatically
14:37:18 <monochrom> Also, under v2 semantics, I would first let "build" have a go, so I see that it succeeds, before I use "freeze".
14:38:12 <orzo> what's a pvp bound
14:38:33 <monochrom> https://pvp.haskell.org/
14:40:05 <dminuoso> orzo: If you pin versions using ^>=, then cabal will consider the specified version as the earliest compatible version, and allow any newer compatible version.
14:40:15 <dminuoso> There's some tools to automatically generate these bounds
14:40:25 <monochrom> "cabal genbounds" :)
14:40:39 <monochrom> err gen-bounds
14:42:55 <dminuoso> cabal has some lesser know features as well that complement the above notation, like the set notation for bounds
14:43:14 <dminuoso> so you can specify `foo ^>= {1.1.1, 1.2, 1.4}
14:43:39 <dminuoso> I think cabal gen-bounds generates >/<= bounds?
14:44:26 <monochrom> IIRC yes, but equiv to ^>=.
14:44:54 <dminuoso> Sure, ^>= is just more explicit about it. :)
14:45:12 <dminuoso> And with the set notation, it makes it more clear what versions you have tested it with
14:45:31 <monochrom> Actually I have only tried using gen-bounds for a *.cabal file that explicitly says "cabal-version: >= 1.10" or something, so it tries to be friendly to old syntax?
14:46:19 <monochrom> I mean, if you have "cabal-version: 4.2" it may very well take advantage of the new concise syntax.
14:46:33 <monochrom> Ha, let me try.
14:47:54 <dminuoso> I have a baby sleeping in a carrier, Im not gonna hack around on my dev machine since it has a clicky keyboard. ;)
14:48:15 <monochrom> Nah, it always outputs >= && < regardless of "cabal-version: 2.2"
14:48:33 <monochrom> You need a mind-reading interface!
14:49:10 <dminuoso> Emacs has that.
14:49:14 <dminuoso> M-x mind-mode
14:49:53 <dminuoso> https://xkcd.com/378/
14:49:53 <monochrom> Such as the one in the movie "Firefox" in which the USSR invented a fly-by-thinking jet fighter, and the US asked Clint Eastwood to steal it. "But you have to think in RUSSIAN!"
14:50:33 <dminuoso> Haha, I once saw a trailer of that movie.
14:51:09 <dminuoso> It looked so awful
14:52:14 <monochrom> Firefox used to read your mind. Now it just really respects your privacy. >:)
14:52:40 <davean> but not your agency
14:52:41 <dminuoso> http://calpaterson.com/mozilla.html
14:52:57 <dminuoso> Firefox respects your privacy because it's not even on your machine.
14:53:04 <monochrom> haha
14:56:52 <orzo> what's the hot new browser steeling their share?
14:56:59 <dminuoso> Chrome? :)
14:57:20 <orzo> hm
14:57:22 <dminuoso> Followed by Edge now.
14:57:56 <dminuoso> Microsoft's new strategy of just *forcing* edge onto everybodies Windows machine repeatedly, and making it impossible to get rid of, seems to be paying off
14:58:46 <monochrom> No, I think it is not that. Because Firefox users would not switch to Edge, whether Edge is based on Chrome or Microsoft's original rendering engine.
14:59:57 <monochrom> Instead, it is not that the absolute number of Firefox users decreased, but that their percentage decreased, i.e., new users use Edge, Safari, or whatever it is on their new smartphones (definitely not Firefox).
15:00:22 <monochrom> But I should stop.
15:09:24 <orzo> what's the best practice for switching cabal between ghc versions?
15:09:35 <orzo> i think i should have an independent dist folder
15:09:47 <orzo> but this .freeze thing clearly needs to be duplicated too
15:10:03 <monochrom> If it is a temp or frequent change, without any meaningful default, "-w ghc-9.4"
15:10:32 <orzo> well i have basically 2 versions i would like to test with
15:10:44 <orzo> and i don't want to have to rebuild everything when i switch
15:10:53 <orzo> assuming it was built before with the other version
15:11:57 <orzo> even if cabal has some higene in the dist folder, i'd have more peice of mind separating it so i could nuke one without impacting the other
15:12:32 <monochrom> Perhaps the --builddir= option helps you?
15:13:47 <orzo> yeah
15:14:01 <orzo> there's probably no equivelent for .freeze though is there?
15:14:25 <orzo> it's not in the builddir but it is strongly associated
15:14:42 <orzo> i guess i'll need to manually rename it when i switch
15:15:09 <sm[m]> re orzo's original q - does cabal always install the latest version of a package even if there's a good-enough version already installed ? I thought it didn't
15:15:36 <orzo> it probably checks the hackage index
15:15:45 <sm[m]> ie orzo's intuition about path of least effort sounded correct
15:15:51 <orzo> i used it for a long time without even downloading and updating that so i didn't realize it behaved this way
15:15:58 <sclv> the build dirs are kept by version
15:16:00 <sclv> of ghc
15:16:19 <sclv> so it won't rebuild more than necessary when you pass different -w flags
15:16:22 <sm[m]> oh, you upgraded ghc since then perhaps orzo
15:17:55 <orzo> i think the least-effort way makes the most sense for the user, but the new way probably has benifits for the community/eco-system since it makes it more likely maintainers will build against newer libs
15:18:21 <ski> koz_ : also `let's in list comprehensions don't have `in'. (and (toplevel) `let's in the interactor)
15:18:43 <sm[m]> least effort is what it still does I believe
15:18:55 <orzo> not so
15:19:03 <orzo> re me&monochrome's discussion
15:19:06 <orzo> i needed the .freeze file
15:19:13 <orzo> i need to manually edit it
15:19:19 <orzo> the build worked fine 
15:19:26 <orzo> after i did so
15:19:48 <sm[m]> I think ordinarily it will use an installed version if it can. There are lots of reasons it may think it can't use it
15:20:03 <sm[m]> such as a ghc upgrade ?
15:20:05 <orzo> i think it must be just using the latest if it can
15:20:15 <orzo> i did not upgrade ghc
15:20:17 <monochrom> OK, I need to actually test it.
15:20:35 <sm[m]> ok. I was hoping the cabal gods would pronounce on this
15:21:01 <sclv> new-build always calculates a fresh build plan
15:21:09 <sclv> from the latest version of the hackage index it has around
15:21:19 <sm[m]> wow
15:21:20 <sclv> but unless you `cabal update` you don't refresh your indexx
15:21:41 <sclv> and `cabal update` tells you how to pin to an index snapshot if you want to not recalc
15:22:01 <sm[m]> cabal really doesn't prioritise repeatable builds by default does it
15:22:22 <sclv> it gives lots of tools for getting them, but it defaults to not having them
15:22:24 <orzo> actually the .freeze makes it more repeatable, not less
15:22:33 <orzo> as it makes it more explicitly configured
15:22:41 <sm[m]> nod
15:24:05 <sm[m]> personally I think repeatability should be the priority for the default, with adventurous new build plans as a power use option
15:24:08 <orzo> sclv, shouldn't the installed deps take precedence over available-in-index deps?
15:24:44 <sclv> its very hard to say what the "best" install plan is given trying to use installed deps
15:25:01 <sclv> you have to explore every possible path to see which uses the greatest percentage of them or whatever
15:25:13 <sclv> its not a straightforward optimization compared to the normal solver
15:25:34 <sclv> and the payoff isnt very clear -- calculating from scratch is an easier behavior to explain and understand
15:26:02 <orzo> it could just do what i did but automatically
15:26:30 <sclv> like auto-freeze on the first run?
15:26:32 <orzo> which is to just look for installed versions of things its trying to download and freeze them to the insalled version
15:26:54 <sclv> that isn't so simple to automate -- what if those installed versions are incompat
15:27:06 <orzo> it should be an either or thing
15:27:11 <sclv> or some are incompat with some and you have to pick the bigger set
15:27:28 <orzo> either it can use installed versions in every case, or it falls back to downloading according to the index build plan
15:27:31 <sclv> there's a big design space, and again, its not clear what advantage if any therre is
15:28:02 <sclv> that's certainly one behavior, but i doubt its the only one people would like, or even thee one most people would expect or like
15:28:37 <sm[m]> cabal could act more like stack - leaning on the tested stackage snapshots for repeatability, where it makes sense
15:28:48 <sm[m]> <blue sky>
15:28:51 <unclechu> hi. a question about `lens` package. imagine a have complex lens like this one: `_2._Just._3._Just._2._Right .~ 200`.
15:28:52 <unclechu> in case something cannot be reached (like some of these points was `Nothing` or `Left`) can i have `Maybe` or `Either` wrap which would tell me whether something was changed or not?
15:28:52 <unclechu> to be more precise whether something was *able to change* (whole path was reachable)
15:30:15 <orzo> actually, the behavior i think people would want is a --no-download option that completely disabled network operation
15:30:31 <yushyin> You can pin the index you can also use stackage package constrains with cabal if you like.
15:30:54 <orzo> is pinning the index a per-package thing?
15:30:58 <orzo> per-project
15:30:59 <orzo> i mean
15:31:17 <sclv> yes you can put it in the project fil
15:31:19 <sclv> file
15:31:24 <unclechu> instead of having `smth` type i would have either `Maybe smth` where `Just` means that a value was successfully updated  or `Either smth smth` where `Left` means that a value couldn’t be updated
15:31:54 <monochrom> https://cabal.readthedocs.io/en/3.4/cabal-project.html#cfg-field-index-state
15:32:33 <yushyin> https://www.stackage.org/lts-16.17/cabal.config :P
15:32:53 <dminuoso> unclechu: My instint says it's unlikely to exist.
15:33:21 <dminuoso> I'd use `has` separately beforehand
15:34:19 <ski> (perhaps one could get list of updated values ?)
15:36:09 <monochrom> yushyin: In the Haskell Platform and cabal-v1 days, I used to recommend something like that, but using version numbers chosen by Haskell Platform.
15:40:07 <yushyin> Hehe, I don't really recommend it, though. I'm also fine with the behaviour of cabal v2- like it is today. After I update the index (and no pinning) I *do* expect some rebuilds.
15:48:15 <monochrom> cabal v1 reusing installed libs was actually only true in its last days. Over most of v1's life it wantonly brought in newer versions as much as v2 does today.
15:48:57 <monochrom> It is why my historical advice such as http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown existed.
15:50:11 <monochrom> The difference though is v1 did it unsafely, v2 does it safely.
15:56:54 <orzo> how do i use index-state?  The docs show putting a time stamp there, but where do i get the time stamp
15:56:59 <unclechu> dminuoso: i’m trying to define my own operator: `(??~) :: Lens' s a -> a -> s -> Either s s; (??~) lens x s = (if has lens s then Right else Left) (set lens x s)`
15:56:59 <unclechu> but when i try to use it: `((),Just(10,True,Just(20,Right 30))) & (_2._Just._3._Just._2._Right) ??~ 200` i get this: error `Could not deduce (Applicative f) arising from a use of ‘_Just’`
15:57:35 <monochrom> I haven't tried, but I would try just choosing a time in the past I like.
15:58:29 <unclechu> dminuoso: maybe you have any idea what i’m missing?
16:01:51 <monochrom> You know, if you really still like v1 the commands and their semantics, you can still use them, most of them are still available in cabal-install-3.2, or you could even find and use an older cabal-install.
16:02:02 <Axman6> orzo: what's index-state?
16:02:24 <monochrom> Axman6: this one: https://cabal.readthedocs.io/en/3.4/cabal-project.html#cfg-field-index-state
16:08:49 <dsal> > ((),Just(10,True,Just(20,Right 30))) & (_2 . _Just . _3 . _Just . _2 . _Right) ?~ 200 -- unclechu I'm not entirely sure what you're going for there.
16:08:52 <lambdabot>  ((),Just (10,True,Just (20,Right (Just 200))))
16:09:02 <dsal> But in any case, I'd probably start with a smaller example.  :)
16:16:37 <unclechu> dsal: `?~` has a completely different purpose
16:17:07 <dminuoso> 00:33:57           ski | (perhaps one could get list of updated values ?)
16:17:11 <dminuoso> That would be a Fold then.
16:17:12 <unclechu> dsal: it doesn’t wrap the whole value into `Maybe`, only the value deep inside
16:19:11 <dminuoso> unclechu: Dunno, my lens-fu is quite weak. I'd just write it in optics and let their advanced diagnostics figure it out.
16:19:16 <dsal> > ((),Just(10,True,Just(20,Right 30))) & (_2._Just._3._Just._2._Right) .~ 200 -- ok. Like I said, I don't quite understand your goal.
16:19:19 <lambdabot>  ((),Just (10,True,Just (20,Right 200)))
16:20:19 <dminuoso> ski: Or are you suggesting some kind of `ASetter s t a b -> b -> s -> (t, [s])`
16:20:47 <unclechu> dsal: `((),Just(10,True,Just(20,Right 30))) & (_2._Just._3._Just._2._Right) ??~ 200` would give me `Just ((),Just (10,True,Just (20,Right 200)))`
16:20:47 <unclechu> this `((),Just(10,True,Just(20,Left 30))) & (_2._Just._3._Just._2._Right) ??~ 200` would give me `Nothing`
16:21:16 <dminuoso> Which I guess you can concoct if you run the lens with State
16:21:42 <dminuoso> Or.. not quite
16:22:05 <ski> dminuoso : more like `ASetter s t a b -> b -> s -> (t,[b])', then, i think
16:22:40 <ski> although, i suppose i had in mind updating with a function
16:22:40 <unclechu> Setter would not work with `has`
16:22:53 <Axman6> :T has
16:22:56 <Axman6> :t has
16:22:58 <lambdabot> Getting Any s a -> s -> Bool
16:23:57 <ski> the idea was just, if you get a list of the updated values, then you could easily check if this is empty, to see whether any value was updated
16:25:32 <ski> (but perhaps unclechu wanted not to see whether any value was updated, but rather whether "any expected update failed (due to absence of the intended location)", if that makes sense (not sure))
16:26:48 <unclechu> ski: well, yes, i just want to see whether a value is failed to update or not
16:27:24 <ski> (anyway, going from `(t,[b])' to `Maybe t' or `Either s t' is obvious)
16:28:23 <ski> unclechu : even if some other locations was succeddfully updated, at the same time ?
16:28:35 <unclechu> ski: but i missed how do i get to `(t,[b])`?
16:29:16 <ski> i didn't figure that out. it just sounded like something that could be possible
16:29:31 <unclechu> ski: well, my main intention was to check a single update, i didn’t think much about multiple updates
16:29:50 <ski> (in the worst case, by separately extracting the values at the requested locations. but nicer would be to be able to do both at the same time)
16:30:21 <ski> the point is that having zero locations to update is a special case of having multiple locations
16:31:23 <ski> and, afaik, updating with `_Just' and `_Right' is treated like updating zero or one location (depending on whether you have `Nothing'/`Left (...)' or `Just (...)'/`Right (...)')
16:33:29 <ski> but say you have a list of type `[Maybe Int]', or of type `[Either String Int]', and you want to add two to each `Int'. it should be able to get an indication if there was no `Int's there at all to update. but, from what you're saying, it sounds like maybe you'd want to get an indication as soon as at least one (rather than all) of the list elements is of the form `Nothing'/`Left (...)'
16:59:05 <sm[m]> monochrom: re "v1 did it unsafely, v2 does it safely" - I know what you mean, but I'd amend that to "more safely" - it's still going to the net and downloading a new chunk of software, which may or may not compile or have correct bounds, which the user often has not intended. I think this is still a weakness of cabal-install as a practical tool - it's too willing to do risky operations when the user is not wanting anything to
16:59:05 <sm[m]> change
17:05:21 <sm[m]> apt-get update, composer upgrade, brew upgrade - all of these you expect to download and install new software, that's their only purpose; cabal build - not so much, unless you've learned that "build" means "upgrade-and-build"
17:06:49 * hackage XSaiga 1.7.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.7.0.0 (InBetweenNames)
17:19:49 <sh4rm4^bnc> hello, i'm wondering whether JHC compiler could be used to translate a haskell project i'm interested in into portable C code which i could use to compile that project on systems where i dont have a haskell compiler available
17:20:24 <sh4rm4^bnc> ftr, that's the compiler in question http://repetae.net/computer/jhc/manual.html
17:21:06 <sh4rm4^bnc> supposedly it can produce C, but it's not described whether that's portable C or tailored to the system/arch it's been invoked on (e.g. like pypy)
17:21:18 <sm[m]> more precisely, it can mean "build" or "upgrade-and-build" depending on whether you ran cabal update. (I assume cabal doesn't do that automatically like stack does.) This is non-obvious statefulness making cabal more complicated than those tools where the command tells all
17:23:02 <sm[m]> hello sh4rm4^bnc. I'd guess it's worth a try for small amounts of haskell, but unlikely to compile anything off hackage
17:23:39 <ghoulguy> sh4rm4^bnc: As far as I know JHC isn't being maintained. The README does mention something about cross-compiling: https://github.com/jimcrayne/jhc#cross-compiling
17:24:09 <sh4rm4^bnc> sm[m], the project i'm intereted in is https://github.com/diku-kmc/kleenexlang . can i see whether it uses "hackage" ?
17:24:26 <sm[m]> it won't build that
17:25:24 <sm[m]> (because that's a modern haskell codebase, depending on many other modern haskell packages, and JHC is much older)
17:26:25 <sm[m]> and is not GHC. Basically most haskell packages require GHC (and a specific range of versions of it)
17:26:37 <sh4rm4^bnc> ah :/
17:26:56 <ghoulguy> What platform are you targetting?
17:27:54 <sh4rm4^bnc> my own distro sabotage linux (based on musl libc)
17:28:40 <sh4rm4^bnc> once a contributor tried to bootstrap GHC from source but he gave up
17:29:05 <sh4rm4^bnc> i don't know the details, but iirc it was a very involving process
17:29:10 <sm[m]> #ghc might be more help (in a few hours)
17:30:43 <sm[m]> I suspect what matters more is the architecture
17:31:04 <sh4rm4^bnc> we support mips, arm, powerpc... and intel ofc
17:31:44 <sh4rm4^bnc> though in this case it's just me wanting to toy with kleenex, so x86_64 would be sufficient for the experiment
17:31:52 <sm[m]> I believe people sometimes link haskell programs with musl, on intel. Don't know if that works for GHC also
17:32:20 * hackage http-date 0.0.10 - HTTP Date parser/formatter  https://hackage.haskell.org/package/http-date-0.0.10 (KazuYamamoto)
18:14:19 * hackage j 0.1.0.0 - J in Haskell  https://hackage.haskell.org/package/j-0.1.0.0 (vmchale)
19:16:50 * hackage reanimate 1.1.0.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-1.1.0.0 (DavidHimmelstrup)
19:24:49 <jackdk> Does this (or something like it) exist? If it did, I would expect to find it in `lens` but I didn't: `splitting :: Char -> Traversal' Text Text` or something
19:25:47 <jackdk> might even be an Iso'?
19:34:39 <emb> Any recomendations for (post covid) haskell meetups in los angeles, ca?
19:37:20 <LarryTheCow> am also curious ^^^
19:37:21 <Axman6> meetups are somewhat moving away from being location based
19:38:04 <Axman6> jackdk: I'm assuming the pointed to texts are the strings between the given char?
19:38:22 <jackdk> Axman6: yeah, like for slicing and dicing arns
19:43:57 <Axman6> @ :t \c -> iso (Text.splitOn (Text.singleton x)) (Text.intercalate (Text.singleton c)
19:44:14 <Axman6> % :t \c -> iso (Text.splitOn (Text.singleton x)) (Text.intercalate (Text.singleton c)
19:44:14 <yahb> Axman6: ; <interactive>:1:81: error: parse error (possibly incorrect indentation or mismatched brackets)
19:44:18 <Axman6> % :t \c -> iso (Text.splitOn (Text.singleton x)) (Text.intercalate (Text.singleton c))
19:44:19 <yahb> Axman6: ; <interactive>:1:12: error:; Not in scope: `Text.splitOn'; No module named `Text' is imported.; <interactive>:1:26: error:; Not in scope: `Text.singleton'; Perhaps you meant one of these: `Seq.singleton' (imported from Data.Sequence), `S.singleton' (imported from Data.Set), `M.singleton' (imported from Data.Map); No module named `Text' is imported.; <interactive>:1:46: error:; No
19:44:19 * hackage yesod-filter 0.1.0.1 - Automatic filter generator for Yesod  https://hackage.haskell.org/package/yesod-filter-0.1.0.1 (KenzoYotsuya)
19:44:45 <Axman6> % import Data.Text as Text
19:44:45 <yahb> Axman6: 
19:44:48 <Axman6> % :t \c -> iso (Text.splitOn (Text.singleton x)) (Text.intercalate (Text.singleton c))
19:44:49 <yahb> Axman6: ; <interactive>:1:41: error: Variable not in scope: x :: Char
19:44:57 <Axman6> % :t \c -> iso (Text.splitOn (Text.singleton c)) (Text.intercalate (Text.singleton c))
19:44:57 <yahb> Axman6: (Profunctor p, Functor f) => Char -> p [Text] (f [Text]) -> p Text (f Text)
19:45:08 <Axman6> % :t \c -> iso (Text.splitOn (Text.singleton c)) (Text.intercalate (Text.singleton c)) . each
19:45:09 <yahb> Axman6: Applicative f => Char -> (Text -> f Text) -> Text -> f Text
19:47:55 <jackdk> Axman6: yeah using iso and splitOn and intercalate is where we are at too
19:48:59 <Axman6> it is unsatisfying though
20:58:15 <Squarism> ski, you around? I dwelved down the Generic track yesterday. I'm not really sure what route you thought could be fruitful. Did you mean I should analyze the "from valueOfheType" or something else ? https://paste.ofcode.org/aAUKgA5fz5mzUHSQuWCH8u
21:01:26 <ghoulguy> Squarism: What was the goal?
21:02:25 <Squarism> ghoulguy, the ghoul is to be able to address "leafs" (Registration a) of Pr2 using textual addresses. 
21:03:14 <Squarism> Pr2 is just an example type it should work for any type constructed using combinations of records/lists/maybe/either/tuple2
21:03:23 <ghoulguy> What were the addresses?
21:03:42 <ghoulguy> record field names?
21:04:16 <Squarism> say for the Pr2 case valid addresses would be : s1/
21:04:16 <Squarism> s2/just/_2_1/
21:04:16 <Squarism> s2/just/_2_2/just
21:04:44 <ghoulguy> So for a sum type, the address is the constructor name and for a record type the field name?
21:05:05 <ghoulguy> Or do you expect to need the constructor address whether or not there are alternatives?
21:05:18 <ghoulguy> like: data T = C { field1 :: Int }
21:05:20 <Squarism> oh sum types are not allowed other than Maybe / Either
21:05:41 <ghoulguy> Oh, so just, nothing, left, right, and then any record field names?
21:05:54 <ghoulguy> or only just tuple names?
21:05:55 <Squarism> yeqah
21:06:22 <Squarism> tuple2 addresses would be _2_<index>
21:06:37 <Squarism> list addresses would be <index>
21:06:38 <ghoulguy> First step will be to make a data type for your addresses and a parser :: String -> Maybe Address
21:07:00 <Squarism> sounds good.
21:09:14 <ghoulguy> The second issue is that the types of things are going to be tricky
21:09:26 <ghoulguy> Then I'd suggest: class C a where m :: [Address] -> Traversal a WhatHere?
21:09:55 <ghoulguy> We could do: class C a where m :: Typeable b => [Address] -> Traversal a b
21:10:16 <ghoulguy> or we could make the addresses indexed by the type of thing they lookup
21:10:34 <ghoulguy> and move the type matching into address parsing
21:10:48 <ghoulguy> In that case you'd have something like: m :: Address a b -> Traversable a b
21:11:23 <ghoulguy> but you'll have to decide when you want things to fail if an address is provided for something of the wrong type
21:11:32 <Squarism> Oh ok. I think I understand your idea there.
21:12:20 <ghoulguy> Of you could decide what the valid types of things to pull out with an address are
21:12:32 <ghoulguy> m :: Address -> Traversal a Value
21:13:46 <Squarism> Lets call the "target type" (as Pr2 in the example ) TheType'
21:14:24 <Squarism> how do you see the actual probing of a value/allowed type component of an value of TheType' is done?
21:15:04 <Squarism> say TheType' is just Pr3 { fld1 :: Registration SomeType }
21:16:09 <Squarism> given an Address for fld1, how would I check there its a valid address and retrieve the value there?
21:16:14 <Squarism> ghoulguy, ^
21:24:40 <ghoulguy> I'm trying something; this isn't something sensible to do "in general" but I'm seeing where we can start
21:28:34 <ghoulguy> Squarism: Consider this https://paste.tomsmeding.com/OtGxhxea
21:28:37 <Squarism> ghoulguy, cool. Thanks a bunch
21:29:42 <ghoulguy> bugfix: https://paste.tomsmeding.com/YdJDhEKP
21:32:09 <ghoulguy> oops, the first instance was still wrong!
21:32:39 <Squarism> Nice stuff! Elegant.How about arbitrary records, any idea there?
21:33:01 <Squarism> where fld name is the accessor. I guess I need to TH those right?
21:33:14 <ghoulguy> no, you can get field names with GHC.Generics
21:33:41 <ghoulguy> or TH or Data.Generics
21:36:42 <Squarism> I cannot find Data.Generics with google
21:36:51 <ghoulguy> ?hackage syb
21:36:51 <lambdabot> https://hackage.haskell.org/package/syb
21:40:25 <Squarism> ghoulguy, so for the GHC.Generics case (Data.Generics seems to have a bunch of dead links so would prefer GHC.Generics). What should I be looking for to create a Deliver for an Address constructor FieldName String ?
21:41:48 <Squarism> or maybe call it "AField String" for consistency
21:45:00 <ghoulguy> Squarism: Do use generics you'd need something like this: https://paste.tomsmeding.com/29Geypre
21:45:54 <Squarism> ghoulguy, Sweet. I'm gonna try it out right away
21:48:10 <sm[m]> @freenode_emb:matrix.org: there was a LA haskellers meetup for years, maybe it's on meetup.com
21:48:11 <lambdabot> Unknown command, try @list
21:58:34 <shafox> @list
21:58:35 <lambdabot> What module?  Try @listmodules for some ideas.
22:09:06 <Squarism> ghoulguy, man. That actually worked!
22:09:34 <Squarism> Great stuff. Now I have a road to explore. Thanks a bunch.
22:10:19 * hackage dimensional-codata 2014.0.0.2 - CODATA Recommended Physical Constants with Dimensional Types  https://hackage.haskell.org/package/dimensional-codata-2014.0.0.2 (BjornBuckwalter)
22:37:20 * hackage cabal-rpm 2.0.7 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.7 (JensPetersen)
23:26:20 * hackage webby 1.0.0 - A super-simple web server framework  https://hackage.haskell.org/package/webby-1.0.0 (AdityaManthramurthy)
23:33:49 * hackage hw-balancedparens 0.4.1.1 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.4.1.1 (haskellworks)
