00:32:08 <proquint> How do I break a bytestring into 4-bit and 2-bit integers?  I'm trying to print the proquint of a 48-bit number (https://arxiv.org/html/0901.4016)
00:35:15 <proquint> I want to break a 16-bit word into 4-bit, 2-bit, 4-bit, 2-bit, 4-bit numbers and map those numbers to letters.
00:39:36 <int-e> > let rotations xs = cycle . map (zipWith (flip const) xs) . zipWith (flip const) xs . tails . cycle $ xs in rotations "abc" -- hmm, maybe a bit over-engineered
00:39:38 <lambdabot>  ["abc","bca","cab","abc","bca","cab","abc","bca","cab","abc","bca","cab","ab...
01:28:19 * hackage ngx-export-tools-extra 0.5.7.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.7.0 (lyokha)
01:43:28 <dminuoso> 09:41:53     juliusdeane | [03:42:05] what's the process for specifying a dependency from github with cabal2nix?
01:43:32 <dminuoso> Oh, they're gone
01:46:46 <dminuoso> proquint: Use Data.ByteString.unpack and then masking/shifting from Data.Bits
01:46:54 <tomsmeding> proquint: https://paste.tomsmeding.com/W9HxzL4y
01:46:58 <tomsmeding> lol
01:47:48 <dminuoso> tomsmeding: I have a homework assignment, I need to write a fully functional RADIUS library. Do you have a paste ready for me?
01:47:52 <dminuoso> :>
01:48:01 <tomsmeding> :p
01:48:13 <proquint> tomsmending: lol awesome thank you... I stumbled upon the Data.Bits myself but you beat me to the implementation. Thanks!
01:48:25 * tomsmeding tips hat
01:48:49 <tomsmeding> spec is unclear though
01:49:09 <dminuoso> tomsmeding: Do you think you can give me an answer in 5 minutes for that problem as well?
01:49:16 <tomsmeding> not prominent enough that this is strictly about data of an even number of bytes, and the 4-2 sequence does not cycle, only within a single nibble
01:49:20 <tomsmeding> correction, word
01:49:31 <tomsmeding> replace 'nibble' with 'word' in my code proquint 
01:49:33 <dminuoso> The term "nibble" and "word" are so ill defined.
01:49:41 <tomsmeding> nibblewibble
01:49:44 <tomsmeding> dminuoso: no
01:50:00 <dminuoso> oh well. nibble is well defined
01:50:01 <dminuoso> word is not
01:50:09 <tomsmeding> ah that's true
01:50:42 <tomsmeding> dminuoso: it would be nice if I could pull the same trick with writing an automatic differentiation engine, wouldn't it?
01:50:47 <tomsmeding> then my thesis would be simpler
01:50:58 <merijn> dminuoso: It's not :p
01:50:59 <dminuoso> Heh, the difference is my task is just of mechanical nature.
01:51:07 <dminuoso> merijn: It really is.
01:51:10 <merijn> dminuoso: Hell, byte isn't even well defined if you mix in C
01:51:20 <dminuoso> The term byte in general is often misunderstood
01:51:25 <dminuoso> Too many conflate it with octet
01:51:38 <dminuoso> But so many people dont work with DSPs or legacy hardware..
01:52:14 <dminuoso> Fun fact, I've seen an architecture where function pointers were 15 bits.
01:52:18 <tomsmeding> I already have trouble working with modern hardware
01:53:16 <tomsmeding> dminuoso: interesting, did one store function pointers in separate kinds of registers, or are all registers 15 bits, or are they 16 and one bit is just ignored?
01:53:32 <dminuoso> merijn: Anyway. Regarding word, there's two conflating notions. It either is the native size CPUs operate on (which doesnt even make sense on CPUs built in the past 30 years, they have many different word widths, depending on the instructions), or its 16 bits if you enter the world of assembers.
01:55:07 <dminuoso> Because historical reasons, and people writing bad assembly code.
01:57:30 <dminuoso> tomsmeding: I dont know the reasons really, it was directly from some something-not-quite-like-C language specification for a texas instruments DSP.
01:58:08 <dminuoso> (Or maybe it was 31 bits, one of them anyhow)
01:58:37 <tomsmeding> funny things
02:30:19 * hackage uusi 0.0.1.0 - Remove all version constraints of dependencies in .cabal file  https://hackage.haskell.org/package/uusi-0.0.1.0 (berberman)
02:44:20 <merijn> that... doesn't sound like a good feature
03:01:08 <Uniaika> yep'
03:15:34 <thblt> Can I search for typeclasses on Hoogle? Eg, I was wondering if there's a class such as `toBool :: a -> Bool`, but idk how to look.
03:15:55 <thblt> (Hoogle or anything)
03:18:02 <merijn> You can, but that class doesn't exist
03:18:15 <merijn> At least, not in a library that anyone actually uses
03:20:53 <thblt> merijn: thanks :) Is there a query syntax for that? I tried String -> a, and there's a lot of *coerce stuff before `Show a => show…`
03:31:20 * hackage unliftio 0.2.13.1 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.13.1 (MichaelSnoyman)
03:49:59 <thblt> Quick question: To represent a keyboard layout, I use a Map of Map of Map (Map State (Map Key (Map Level Effect))) Is there a built-in way to fold this sort of monster, or a better way to do this?
03:52:42 <dminuoso> thblt: lens/optics lets you fold this rather easily
03:53:58 <thblt> dminuoso: thanks, looking into this
03:57:10 <dminuoso> % let m :: IM.IntMap (IM.IntMap (IM.IntMap String)); m = [(1, [(11, [(111, "foo"), (112, "bar")])])]
03:57:10 <yahb> dminuoso: ; <interactive>:242:52: warning: [-Wname-shadowing] This binding for `m' shadows the existing binding defined at <interactive>:240:52
03:57:15 <dminuoso> m ^.. folded.folded.folded
03:57:19 <dminuoso> % m ^.. folded.folded.folded
03:57:19 <yahb> dminuoso: ["foo","bar"]
03:58:49 * hackage wai-saml2 0.2.1.2 - SAML2 assertion validation as WAI middleware  https://hackage.haskell.org/package/wai-saml2-0.2.1.2 (mbg)
04:00:50 <dminuoso> % let m3 :: IM.IntMap (IM.IntMap (IM.IntMap Int)); m3 = [(1, [(11, [(111, 10), (112, 20)]), (12,[(121, 30), (122, 40)])])]
04:00:51 <yahb> dminuoso: 
04:00:59 <dminuoso> % foldMapOf (folded.folded.folded) Product m3
04:01:00 <yahb> dminuoso: Product {getProduct = 240000}
04:07:08 <thblt> I just need to understand how to bifold :)
04:08:45 <dminuoso> thblt: with lens you can just fuse different folds with summing
04:08:57 <thblt> wow
04:13:36 <dminuoso> thblt: Oh heh in case of lens it's just (<>) in fact
04:15:29 <thblt> I don't have this in Data.Lens?
04:16:20 <dminuoso> % ([1,2,3], [4,5,6]) ^.. (_1.folded <> _2.folded) :: [Int] -- thblt 
04:16:20 <yahb> dminuoso: [1,2,3,4,5,6]
04:16:52 <Uniaika> thblt: it's the traditional semigroup binary operator
04:17:58 <thblt> That's what I got from ghci indeed. 
04:18:27 <dminuoso> thblt: note this might not be the same as bifold though
04:19:03 <dminuoso> (because the order is completely different)
04:20:19 <dminuoso> or it might be, so it could require some careful thought
04:20:26 <dminuoso> (you might have to shift the (<>) in a bit)
04:20:27 <dminuoso> say
04:23:00 <dminuoso>  % [(1,2), (3,4)] ^.. (folded._1 <> folded._2) :: [Integer]
04:23:01 <dminuoso> % [(1,2), (3,4)] ^.. (folded._1 <> folded._2) :: [Integer]
04:23:02 <yahb> dminuoso: [1,3,2,4]
04:23:08 <dminuoso> % [(1,2), (3,4)] ^.. folded.(_1 <> _2) :: [Integer]
04:23:08 <yahb> dminuoso: [1,2,3,4]
04:34:29 <dminuoso> % [(1,2)] ^.. folded._1 :: [Int]
04:34:30 <yahb> dminuoso: ; <interactive>:284:20: error:; * Couldn't match type `Int' with `Integer'; arising from a functional dependency between:; constraint `Field1 (Integer, Integer) (Integer, Integer) Int Int' arising from a use of `_1'; instance Field1 (a, b) (a', b) a a' at <no location info>; * In the second argument of `(.)', namely `_1'; In the second argument of `(^..)', namely
04:34:32 <dminuoso> What's going on here?
04:35:37 <dminuoso> If I give `1` a type ascription, it typechecks.
04:53:49 * hackage mmsyn2 0.3.0.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.3.0.0 (OleksandrZhabenko)
05:09:19 * hackage mmsyn4 0.5.0.0 - The "glue" between electronic tables and GraphViz  https://hackage.haskell.org/package/mmsyn4-0.5.0.0 (OleksandrZhabenko)
05:10:19 * hackage mmsyn5 0.5.0.0 - Various additional operations on lists (some with intermediate Monads)  https://hackage.haskell.org/package/mmsyn5-0.5.0.0 (OleksandrZhabenko)
05:15:39 <thblt> Is it abuse to use the state monad to design a sort of imperative dsl?
05:16:13 <opqdonut> that's what it's meant for
05:16:21 <thblt> thanks :)
05:17:22 <dminuoso> Okay, this is starting to confuse me. How could `f :: _` alter type inference?
05:18:03 <dminuoso> If I add a `f :: _`, GHC produces a type error on the call site to f (in addition to the typed hole error), if I remove it, all compiles.
05:19:04 <hpc> and the error says what type f has?
05:19:54 <dminuoso> hpc: https://gist.github.com/dminuoso/6318be2a36b5428c1ac62def6163aaf9
05:20:06 <dminuoso> Behind the scenes, that error is implemented as:
05:20:39 <dminuoso> instance {-# OVERLAPPABLE #-} TypeError (...) => Is k l where implies _ = error "unreachable"
05:20:54 <hpc> so, valid programs have all their holes filled
05:21:34 <hpc> when you don't have f :: _, it infers the type that the error says and it's all fine
05:21:55 <hpc> when you put the hole there, you're communicating to ghc that you want to write a type signature but don't know what it should be
05:22:04 <hpc> so it produces an error with what it should be, for you to fill in
05:22:54 <dminuoso> hpc: except, the inferred type is less polymorphic 
05:23:09 <dminuoso> Roughly, what I'd expect is:
05:23:25 <dminuoso> attrDefThru :: forall k is. (Is k A_Setter) => Optic' k is DictFile AttrMap -> Parser ()                 
05:23:58 <dminuoso> But adding a typed hole gives me a *much* less polymorphic type:
05:24:11 <lortabac> it looks like a bug or at least an implementation wart
05:24:13 <dminuoso> attrDefThru :: Optic A_Lens js ... -> ...
05:24:24 <dminuoso> See how it monomorphized on the lens type k?
05:24:29 <hpc> ah
05:25:03 <hpc> does it still work if you add that type signature in place of the hole?
05:25:25 <dminuoso> Amusingly *no*
05:25:30 <dminuoso> It errors out with yet another type error
05:25:37 <dminuoso> Im completely baffled here
05:25:53 <dminuoso> no type signature, it compiles. adding the correct type signature, I get overlapping instance errors
05:26:06 <dminuoso> adding a typed hole I get an incorrect instance selection triggering the diagnostic
05:26:56 <dminuoso> My first instinct was this was some weird interaction with MMR, but I disabled that too
05:27:01 <hpc> with no type signature, what does :t tell you?
05:31:06 <dminuoso> attrDefThru :: (Is (Join A_Lens l) A_Setter, Is l (Join A_Lens l), Is A_Lens (Join A_Lens l)) => Optic' l js DictF\ile AttrMap -> Parser ()
05:31:17 <dminuoso> (I did some manual cleanup)
05:33:59 <hpc> there's something in the definition of attrDefThru that's making it too specific for the type you want, i suspect
05:34:41 <dminuoso> Yeah I suppose
05:34:42 <dminuoso> (%) :: (Is k m, Is l m, m ~ Join k l, ks ~ Append is js) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b infixl 9 
05:34:49 <dminuoso> It's time to start chasing tyfams now..
05:34:49 <hpc> that, or something else that's definitely beyond me :P
05:34:57 <dminuoso> Well Im dead sure it's that one
05:35:06 <dminuoso> (Based on how I triggered all of this)
05:35:29 <dminuoso> Im starting to think this could be an optics bug
05:35:48 <hpc> since you're certain on the type of attrDefThru, you can leave the type signature you want and use value-level holes
05:35:48 <dminuoso> The reason is
05:35:53 <dminuoso> mmm
05:37:27 <dminuoso> hpc: Ahhh!
05:37:32 <dminuoso> I understand what's going on.
05:38:13 <hpc> that makes one of us :D
05:38:44 <dminuoso> The above type signature is right.
05:39:05 <dminuoso> (Which still leaves that GHC thwart of typed holes not doing the right thing)
05:42:23 <dminuoso> hpc: Hah indeed! I expected the subtyping in optics to play well with type inference.
05:42:32 <dminuoso> Seems I was wrong and I need to manually cast them 
05:43:19 * hackage mmsyn6ukr 0.8.3.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.8.3.0 (OleksandrZhabenko)
05:44:19 <hpc> nice
06:01:08 <[exa]> is there anyone skilled in deconding cabal dependency errors? https://paste.tomsmeding.com/luHswXER
06:01:25 <[exa]> (this is from `cabal install megaparsec`)
06:02:10 <dminuoso> [__0] rejecting: base-4.14.0.0 (constraint from user target requires==4.13.0.0)
06:02:27 <dminuoso> base and GHC versions are have a 1-to-1 correspondence
06:03:32 <dminuoso> [exa]: What likely happened is this:
06:03:46 <dminuoso> You have some package installed that depends on base-4.14.0.0 in your global thing
06:04:06 <dminuoso> Dont use `cabal install`?
06:05:45 <merijn> [exa]: The problem is "you're using too new a GHC", that's what all base dependencies mean (well, except for the ones meaning you have too old a GHC :p)
06:06:46 <dminuoso> merijn: I dont think that's completely true.
06:07:28 <dminuoso> megaparsec has had a base (>=4.11 && <5.0) bound for nearly a year now
06:07:46 <merijn> base constraint can be limited by a transitive dependency
06:07:55 <dminuoso> mm
06:08:00 <merijn> Also, has update been run? :p
06:08:04 <dminuoso> (constraint from user target requires==4.13.0.0)
06:08:18 <dminuoso> Would be nice if cabal could tell where the constraint really comes from
06:09:27 <merijn> Patches welcome? ;) *ducks*
06:10:12 <dminuoso> Well Im not complaining
06:10:49 * hackage polysemy-methodology 0.1.1.0 - Domain modelling algebra for polysemy  https://hackage.haskell.org/package/polysemy-methodology-0.1.1.0 (locallycompact)
06:21:35 <[exa]> is there a way to list stuff that requires ==4.13.0.0 ?
06:21:49 <[exa]> I mean, a bit better error report would help
06:22:12 <[exa]> btw I'm on ghc 8.8.3 so it's hopefully not "too much new"
06:23:01 <merijn> [exa]: "too new" relative to whatever package(s) you're trying to use
06:23:29 <merijn> [exa]: Did you run "cabal update" recently?
06:23:39 <merijn> And which version of cabal-install do you have?
06:26:19 <dminuoso> Also, why are you using `cabal install` for megaparsec?
06:33:19 * hackage polysemy-methodology 0.1.2.0 - Domain modelling algebra for polysemy  https://hackage.haskell.org/package/polysemy-methodology-0.1.2.0 (locallycompact)
06:34:03 <thblt> I asked recently if there was a tool to make all imports explicit, and remove unused ones: haskell-language-server does it.
06:34:23 <dminuoso> thblt: haskell-language-server itself?
06:35:04 <thblt> dminuoso: I guess so! In my Emacs, lsp-ui offers to do it, so I guess it delegates to the server. Let me check.
06:36:02 <thblt> I don't think I use any other tool. Apparently lsp-haskell calls into hlint too, but I don't think hlint can do that.
06:36:23 <dminuoso> thblt: Id expect lsp-ui to do this.
06:36:59 <dminuoso> Well it could use hls to detect unused ones, but the file modification would be an editor feature
06:37:40 <thblt> dminuoso: well the server should describe the possible modification somehow.
07:01:28 <tvrsky> hi
07:01:43 <tvrsky> how do i begin on haskell?
07:03:14 <dminuoso> tvrsky: Hi! You just did.
07:03:42 <dminuoso> What kind of learning material are you looking for?
07:04:01 <thblt> A nice free intro is LYAH http://learnyouahaskell.com/ (althouh you can buy too)
07:04:38 <tvrsky> well i'm just interested on functional programming, so i'm looking for beginner's guides
07:04:51 <dminuoso> tvrsky: Im quite fond of CIS194, it's modern and well thought of.
07:05:08 <dminuoso> It's also freely available, and comes with well structured excercises that build ontop of each other
07:07:55 <tvrsky> that's awesome
07:07:58 <tvrsky> thank you
07:10:19 * hackage winery 1.3.2 - A compact, well-typed seralisation format for Haskell values  https://hackage.haskell.org/package/winery-1.3.2 (FumiakiKinoshita)
07:13:04 <tvrsky> what are your thoughts on haskell? is it too hard?
07:13:29 <dminuoso> It depends on your background.
07:13:48 <tvrsky> i mean, i'm already familiarized with javascript since i work with it, but i'm a complete newbie to functional programming
07:14:06 <thblt> It's different.  
07:14:20 <dminuoso> tvrsky: Don't expect much of your programming experience to carry over then.
07:14:27 <dminuoso> So it'll feel more like programming all over again.
07:15:43 <merijn> tvrsky: I don't think Haskell is *hard*, but I do think its *different*
07:15:45 <dminuoso> Accordingly, Haskell can give the impression of being "difficult to learn". But that's not because Haskell is inherently difficult, but unlikely "language close to your domain that you can pick up quickly", you're learning how to program from scratch again.
07:16:15 <dminuoso> People often call "unlearning your old mindset"
07:16:26 <merijn> tvrsky: FWIW, my girlfriend with 0 programming experience learned to program haskell just fine. It's just that many people who know 1 programming language expect that learning "any other language" is something easy you do in 2 days
07:17:04 <merijn> tvrsky: So if you go in expecting "this will be about as tricky as learning to program the first time was", then you should be fine
07:17:22 <kuribas> tvrsky: haskell isn't hard, but it's big.  It's more like you have a lot of new concepts, each of which isn't that hard to understand.
07:17:30 <dminuoso> I think the experience is well worth it, even if you keep writing JavaScript in your day job
07:17:41 <dminuoso> Haskell changed how I thought about programming a lot.
07:18:35 <kuribas> tvrsky: you have a lot of scary sounding abstractions, most if which are very simple in concept.
07:18:46 <tvrsky> i'm very excited about this ngl
07:19:25 <kuribas> for example in OO you have the "visitor pattern", but it still leaves a lot to the imagination.  In haskell you have "Foldable", which is a concrete version of the visitor pattern.
07:19:28 <thblt> I agree with dminuoso, but let's not underestimate the intrinsic difficulty of Haskell. It's a very strict language, which may require more effort to grasp than your average python --- you'll write less bugs, but you'll spend more time getting your code to work. 
07:20:01 <thblt> Also, it can be argued that while the base is very minimal, the set of language features + libraries that make something like "practical haskell" isn't small.
07:20:21 <thblt> But it's a very, very exciting langage, and it will make you a better programmer :)
07:20:29 <kuribas> part of that is because you try to write idiomatic code.
07:20:40 <kuribas> it's ok to write everything in IO in the beginning.
07:21:41 <thblt> (It's also ok to write *nothing* in IO if it makes more sense to you this way.)
07:22:10 <kuribas> thblt: but that's harder
07:22:17 <kuribas> if you come from an imperative background
07:22:25 <thblt> I think that's how Haskell from First Principles work, IIRC.   It introduces IO relatively late.
07:22:46 <thblt> kuribas: I'm just saying there are multiple ways, not that my suggestion is better.
07:23:29 <thblt> I think I learned by avoiding IO.
07:23:53 <tvrsky> well gonna start now, so thanks for all the suggestions
07:24:07 <thblt> tvrsky: have fun :)
07:24:28 <kuribas> my point is, you shouldn't feel forced to use best practices when starting out
07:24:54 <kuribas> it's easier to learn the gradually along the way
07:51:15 <[exa]> merijn: anyway thanks for hints, cabal nuke solved it
07:52:17 <[exa]> merijn: (there were weird versions of the package dependencies installed, for no apparent reason, didn't bother solving why :D )
07:53:43 <merijn> Installed packages shouldn't affect the build plan with v2-build anyway
07:55:15 <[exa]> anyway, anyone parsing own token streams with Megaparsec 9? Problem: I have a token stream where tokens cannot be "reconstructed" back to the original form because they are simplified a bit (eg. both "0x12" and "0b00010010" share the representation `TInt 18`) so I was saving the "original string" together with the tokens in the stream. Now there is VisualStream class that forces me to visualize Tokens 
07:55:21 <[exa]> (_not_ the annotated things in the stream). Is there any way to get the old behavior back?
07:57:44 <thblt> Re cabal-install, what's the actual meaning of "build"? Is it now v2-build?
07:57:50 * hackage th-lego 0.2.0.1 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.2.0.1 (NikitaVolkov)
08:02:04 <merijn> thblt: If you have 3.x then build == v2-build
08:02:25 <merijn> If you have <3.0 then build == v1-build (same for everything, of course)
08:02:56 <thblt> merijn:  thanks! (3.2)
08:03:32 <merijn> v2 still works too, but that's mostly to simplify writing portable scripts
08:04:35 <alx741> hello all, I'm using scalpel to do web scraping and using a UTF8 decoder, but characters like "ñ" (n tilde) show up in Data.Text as "\241", does anyone have an idea what could be going wrong?
08:04:59 <merijn> alx741: You are using "show" :p
08:05:13 <merijn> > "ñ" -- this goes through Show
08:05:15 <lambdabot>  "\241"
08:05:17 <merijn> > text $ "ñ"
08:05:19 <lambdabot>  ñ
08:05:47 <merijn> alx741: For example, compare the result of 'Data.Text.IO.putStrLn "ñ"' vs 'print "ñ"'
08:07:57 <dsal> tvrsky: Haskell is the easiest language I work in, in general.  Makes everything else frustrating.
08:09:34 <alx741> argh! of course, I'm using 'print' and so it goes trough 'show', facepalm
08:09:39 <alx741> thank you merijn! :)
08:15:26 <merijn> When did Type first become a synonym for *?
08:16:20 <dminuoso> 8.6?
08:16:30 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/8.6
08:17:03 <merijn> ugh
08:17:14 <merijn> Actually turns out that even -Wcompat is fairly new >.>
08:20:18 * hackage th-lego 0.2.1 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.2.1 (NikitaVolkov)
08:44:48 <monsterchrom> -Wcompat's Halloween costume is -Wombat  :)
08:45:41 <monsterchrom> Hey let's dress up GHC cmdline options for Halloween!  -XRankNType -> XFangNType
08:47:30 <delYsid> Is there a way to convince GHC to look for packages in lowercase dirs?
08:48:13 <delYsid> I'd like to have the Haskell code of a project coexist with a bunch of assets.  However, these assets are organized in lowercase dirs.
08:48:31 <dminuoso> delYsid: Do you mean for vendored packages?
08:48:52 <delYsid> wha?  I probably dont mean that, since I have no idea what that would mean
08:48:53 <dminuoso> Hold on, it's not even remotely GHC's job
08:49:02 <dminuoso> Are you sure you're not conflating cabal and GHC here?
08:50:25 <dminuoso> delYsid: Phrased differently, these assets, are they proper cabal packages?
08:50:30 <thblt> But anyhow, no, Haskell modules Start With An Uppercase Letter
08:51:56 <dminuoso> Or are you talking about GHC finding modules in --make mode?
08:53:31 <hekkaidekapus> thblt: Regarding your import question, see `-ddump-to-file -ddump-minimal-imports`.
08:54:37 <hekkaidekapus> @hackage smuggler -- and <https://github.com/jrp2014/smuggler2/> if you want tools that build on those flags.
08:54:37 <lambdabot> https://hackage.haskell.org/package/smuggler -- and <https://github.com/jrp2014/smuggler2/> if you want tools that build on those flags.
08:55:44 <dminuoso> Are there simpler tools than Cabal if I want to parse, modify and write a .cabal file back?
08:56:12 <merijn> dminuoso: Do you care about full compatibility?
08:56:18 <merijn> Or just, like, 80-90%
08:56:29 <dminuoso> 80-90% is fine
08:56:31 <merijn> https://hackage.haskell.org/package/cabal-install-parsers
08:56:46 <dminuoso> That dependency tree.
08:57:13 <dminuoso> Ah well, with those ergonomics I might as well just use Cabal
08:57:22 <merijn> That's just the dependency tree of Cabal :p
08:57:22 <dminuoso> It's just a wrapper anyhow
09:00:19 * hackage http-io-streams 0.1.6.0 - HTTP and WebSocket client based on io-streams  https://hackage.haskell.org/package/http-io-streams-0.1.6.0 (HerbertValerioRiedel)
09:01:19 * hackage keycloak-hs 2.1.0 -   https://hackage.haskell.org/package/keycloak-hs-2.1.0 (CorentinDupont)
09:57:00 <delYsid> dminuoso: It is GHC that imposes the restriction that module names need to be uppercase, isnt it?
09:58:25 <geekosaur> I think it's also due to dotted name resolution?
09:58:55 <thblt> hekkaidekapus: thanks!
09:58:59 <geekosaur> (foo.bar) is resolved with the dot meaning (.) instead of a name component separator
10:01:44 <tomsmeding> maerwald: apparently an alternative for ALE: https://dev.to/moniquelive/haskell-lsp-bonus-for-vim-4nlj
10:01:49 <tomsmeding> (as found on haskell weekly)
10:02:12 <maerwald> I tried vim-lsp already
10:03:22 <tomsmeding> ah
10:03:46 <maerwald> I'd say it's the worst. Less reliable than LanguageClient-neovim and less features that coc.nvim
10:04:02 <maerwald> but in the end, all LSP clients suck, really
10:04:06 <tomsmeding> less reliable than LC-neovim is pretty damning in my experience :p
10:04:15 <monsterchrom> Module names are capitalized in the Haskell Report.
10:04:17 <maerwald> LC-neovim is the best implementation so far
10:04:55 <monsterchrom> But the motivation is to reduce dot ambiguity, no doubt.
10:05:02 <maerwald> I'm starting to believe LSP (the idea) overall is trash
10:05:39 <tomsmeding> the protocol or the concept of having a unified language integration protocol?
10:05:51 <maerwald> writing an editor plugin for a custom language linter is some work, sure, but uh... all the disadvantages of LSP... really?
10:05:55 <maerwald> Don't outweigh it
10:06:14 <thblt> What are the disadvantages of lsp? I'm pretty happy with it.
10:06:23 <monsterchrom> Oh, LC ≠ lambda calculus. :(
10:06:38 <yushyin> works ok for vscode and other languages, but the haskell support is bad and vim lsp clients are also all bad
10:06:41 <tomsmeding> sorry monsterchrom
10:06:45 <monsterchrom> :)
10:06:45 <thblt> Not having to install each and every possible language support package in $EDITOR is a blessing.
10:06:47 <maerwald> it's broken most of the time, uses shitty json with bad error messages, you have all sorts of process handling issues etc etc
10:07:13 <thblt> yushyin: I understand vim extension language is, er, not the best; is there a project to integrate lsp in the core?
10:07:17 <tomsmeding> maerwald: do you think a different protocol could fix the problems?
10:07:25 <maerwald> server-client architecture for something that's supposed to run blazingly fast inside my editor? What? Why.
10:07:42 <monsterchrom> because your computer is FTL
10:07:47 <tomsmeding> maerwald: see also: xi editor
10:08:05 <yushyin> thblt: I'm not aware of any projects
10:08:06 <tomsmeding> and also the local socket connection is really not what kills performance here :p
10:08:28 <maerwald> no, but all the error handling mess server-client architecture causes
10:09:08 <maerwald> also. I'm ranting. I don't have any better solution, lol
10:09:15 <thblt> maerwald: I'm not sure how you can avoid a client-server model if you want to use the compiler as an editor helper?
10:09:32 <thblt> The good thing with LSP is that you only have one set of client bugs.
10:09:34 <monsterchrom> Perhaps the protocol should consist of continuations, not data.
10:09:36 <tomsmeding> thblt: write the editor in haskell and let it depend on ghc-lib
10:09:48 <tomsmeding> that remark is meant sarcastically
10:09:57 <thblt> tomsmeding: I was afraid for a moment :)
10:10:03 * monsterchrom is going to teach continuations tomorrow. That's why. >:)
10:10:15 <thblt> But hey, that's what Emacs is, just with another language :)
10:10:44 <monsterchrom> http://hackage.haskell.org/package/manatee-editor
10:10:46 <tomsmeding> I guess Yi editor exists
10:10:56 <tomsmeding> or that apparently
10:11:10 <thblt> xi?
10:11:18 <monsterchrom> it doesn't depend on ghc-lib. But at least it's an editor and written in Haskell.
10:11:19 <thblt> No, xi is in rust
10:11:31 <tomsmeding> xi is the thing by that google guy that has a client-server architecture for the editor itself
10:11:34 <tomsmeding> yi is https://github.com/yi-editor/yi
10:11:39 <thblt> Technically Emacs has native modules so you *could* plug ghc-lib directly.
10:11:52 <tomsmeding> "This software is no longer maintained" :(
10:11:53 * geekosaur is not sure manatee ever worked fully, it got blatted onto hackage and immediately abandoned apparently :(
10:12:07 <monsterchrom> Got a bank job. As usual.
10:12:09 <thblt> Which is probably a good example of "just because you can doesn't mean you should"
10:12:25 <maerwald> monsterchrom: they pay well
10:12:28 * tomsmeding nods to thblt
10:12:32 <monsterchrom> The #1 brain drain from #haskell is bank jobs.
10:12:54 <monsterchrom> This is why when someone asks "are there Haskell jobs" I wish I could just say no.
10:13:04 <maerwald> hey... I wanna get paid for my back pain and RSI
10:13:14 <tomsmeding> so that more people remain in #haskell?
10:13:20 <monsterchrom> There are no Haskell jobs. Keep writing and maintaining free Haskell software.
10:13:24 <tomsmeding> :D
10:13:34 <tomsmeding> or enter academia
10:13:42 <maerwald> well, if *good* healthcare was free.. imagine that
10:13:47 <thblt> sounds suspiciously like a job!
10:13:59 <monsterchrom> nah academia is what gives you LinearTypes, not free software that you actually use.
10:14:06 <tomsmeding> accurate
10:14:08 <maerwald> programming is one of the worst things you can do to your health
10:14:22 <maerwald> mental and physical
10:14:27 <maerwald> Why would anyone do it
10:14:35 <tomsmeding> it's fun!
10:14:45 <thblt> Especially when it's not your job.
10:14:48 <thblt> I guess.
10:14:49 <maerwald> I don't know what fun is. I just have obsessions.
10:14:58 <monsterchrom> Oh yeah, for free good healthcare, we need to also tell medical students "nah there are no medical jobs" haha.
10:14:58 <tomsmeding> most things become less fun when it's your job, pair or unpaid
10:15:03 <thblt> If obsessions don't count as fun I'm out.
10:15:07 <maerwald> lolo
10:16:51 <thblt> In all seriousness, I keep wondering if i should leave my job (I teach philosophy in high school, in Fr) to go work in programming, and I always end up at the conclusion that I'll certainly get paid a lot better but I'll probably hate it very, very quickly
10:17:38 <maerwald> thblt: do you know Arnaud Bailly?
10:17:49 <johnw> hate programming? then you're doing it wrong!
10:18:12 <thblt> maerwald: no, whyK
10:18:15 <thblt> who is him?
10:18:20 <maerwald> thblt: frech philosopher, ended up in Singapore in fintech doing haskell :p
10:18:25 <dolio> Most of the industry is doing it wrong.
10:18:37 <maerwald> I happened to work on his codebase long after he moved on
10:18:55 <maerwald> and then understood why
10:19:14 <monsterchrom> Do you also teach Hofstadter stuff in your philosophy class? In Haskell instead of Lisp? >:)
10:19:20 <tomsmeding> maerwald: why he moved to programming or why he moved on?
10:19:28 <maerwald> the latter
10:19:34 <maerwald> he had visions
10:19:39 <maerwald> about software
10:19:42 <maerwald> I mean... lol
10:20:23 <maerwald> If fintech was the right place to exercise visions...
10:20:37 <tomsmeding> then there is a good, working LSP client for vim
10:21:00 <tomsmeding> modus tollens produces the required conclusion
10:21:26 <monsterchrom> Does fintech simply mean blockchain stuff? It's a new term that suddenly popped up a few days ago and suddenly everyone except me knew it like it has always existed.
10:21:37 <maerwald> but they have this obsession with hiring over-qualified ppl, which sometimes has interesting side-effects
10:21:48 <tomsmeding> I understand it as high-frequency trading monsterchrom 
10:21:57 <maerwald> monsterchrom: no, I mean actual fintech, stealing real money
10:22:16 <thblt> Sounds way more honest than blockchain.  
10:22:29 <tomsmeding> also less power usage probably
10:22:46 <thblt> Where you steal money too, but after having had to lie to pretend it was money in the first place.
10:23:27 <maerwald> I dunno. If you apply for a job and get it... didn't you steal it from the other 50 candidates? :)
10:23:44 <monsterchrom> oh, financial technology
10:23:57 <geekosaur> if people behave as if it has value, does it?
10:24:46 <tomsmeding> for most reasonable definitions, yes
10:25:21 <maerwald> But I can say it's interesting to have experienced real fraud once (not from employer, but customer)
10:25:40 <avdb> A-mazing. I got the next three hours to play with Haskell for the first time in a while.
10:26:03 <tomsmeding> avdb: what will you build?
10:30:03 <avdb> tomsmeding: I will be reading Chris' book since I can't even use Haskell properly yet.
10:30:20 <avdb> I'm currently learning very slowlu due to bad time managment.
10:30:23 <avdb> Slowly*
10:30:36 <tomsmeding> as long as you're having fun, learning slowly is not an issue
10:30:56 <carbolymer> I have: `counter <- newTVarIO 0` and in 2 threads I'm doing: `atomically $ modifyTVar' counter ((+)1) >> readTVar counter` and in both threads I'm getting 1 at the same time - WTF?
10:31:09 <maerwald> I'm a strong believer in slow learning
10:31:46 <maerwald> if you learn slow, you forget slow :p
10:31:48 * hackage cassava-streams 0.3.0.5 - io-streams interface for the cassava CSV library.  https://hackage.haskell.org/package/cassava-streams-0.3.0.5 (PeterJones)
10:32:07 <tomsmeding> carbolymer: is the code shareable? https://paste.tomsmeding.com
10:35:31 <carbolymer> tomsmeding, not really, give a minute to re-create minimal example
10:36:09 <tomsmeding> because from your description, #worksForMe :p
10:36:18 <tomsmeding> (i.e. I get 1, 2)
10:39:42 <carbolymer> hmm, maybe it's because it's inside hunit test or ghc flags or idk - working on minimal example!
10:40:13 <dminuoso> I suspect there's an unsafePerformIO you didn't tell us about.
10:40:21 <tomsmeding> are you sure you have the same counter TVar both times?
10:42:15 <carbolymer> tomsmeding, yes, because I'm running 5 threads, over 100 elements (everytime this function I pasted) and I am supposed to get 100 in return - but I get only 95
10:42:23 <carbolymer> which = 100 - nr_of_threads
10:42:29 <carbolymer> which is super weird
10:43:31 <carbolymer> dminuoso, could be - might hidden by hunit internals
10:43:56 <carbolymer> dminuoso, but I'm using pretty straightforward test spec
10:44:38 <tomsmeding> do all the threads execute your code about the same number of times?
10:45:20 * hackage th-lego 0.2.2 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.2.2 (NikitaVolkov)
10:45:45 <carbolymer> tomsmeding, yes, I've added print after each invocation, and this function returns the same value two times at the very beginning
10:46:12 <carbolymer> so, double 1's and numbers from 2-99
10:46:17 <dminuoso> Im quite confident that stm is fine.
10:46:37 <dminuoso> carbolymer: Are you creating the counter using unsafePerformIO perhaps?
10:46:53 <carbolymer> dminuoso, no, newTVarIO
10:46:59 <dminuoso> carbolymer: No from the outside.
10:46:59 <carbolymer> inside IO
10:47:06 <carbolymer> inside test spec
10:47:11 <dminuoso> I stick to my theory "there's unsafePerformIO somehwere"
10:47:54 <tomsmeding> carbolymer: can you post the test spec?
10:48:12 <tomsmeding> despite knowing there's code we don't see
10:48:56 <carbolymer> I can't - I would need to retype it from remote desktop; hold on, working on that example
10:49:14 <tomsmeding> lol ok no worries
10:49:27 <carbolymer> yeah, perks of remote work in financial company
10:49:53 <geekosaur> here we go again with the fintech :p
10:51:11 <monsterchrom> <backseat-driver>Just use ssh X forwarding</backseat-driver>
10:51:20 * hackage polysemy-methodology 0.1.2.1 - Domain modelling algebra for polysemy  https://hackage.haskell.org/package/polysemy-methodology-0.1.2.1 (locallycompact)
10:51:43 * tomsmeding expects at least one of the two platforms involved to run windows
10:52:18 * geekosaur likewise
10:53:29 <monsterchrom> I like to hedge-bet (haha fin again) the fantastically unlikely. I say OS/2 at the company and macOS at home. >:)
10:53:38 <monsterchrom> I guess s/say/bet/
10:54:27 <tomsmeding> does ghc even run on OS/2
10:54:31 <dminuoso> Hey hey, why do people assume that fintech means financial technologies? What do you call companies specializing in making diver fins?
10:54:36 <dminuoso> Surely you can use Haskell for that too
10:54:43 <monsterchrom> Oh oops hehe
10:55:00 <monsterchrom> I don't assume. I googled.
10:55:19 <carbolymer> ok, my minimal example works fine, I need to wrap it in test spec
10:55:27 <geekosaur> should port readily
10:55:31 <monsterchrom> Indeed I couldn't for my life figure out what's "fin" in "fintech", never occurred to me it's "finance"
10:55:43 <dminuoso> or maybe its finnish tech!
10:55:48 <carbolymer> totally
10:55:54 <dminuoso> Finnish company making diver fins.
10:56:01 <dminuoso> With Haskell
10:56:02 <carbolymer> ...for finance
10:56:09 * tomsmeding looked it up and found out that indeed ghc does not officially support OS/2
10:56:25 <geekosaur> neither does much of anyone else
10:56:35 <geekosaur> eCS is still out thre somewhere though
10:56:51 <monsterchrom> Even virtualbox doesn't quite support OS/2 guests, relegating to "community effort".
10:57:06 <tomsmeding> ... hence the remote desktop
10:57:20 <dminuoso> Will GHC run on DOS?
10:57:33 <dminuoso> You know, for the true masochists.
10:57:50 <geekosaur> I think you rapidly hit a memory problem
10:58:23 <tomsmeding> hm, "s390-ibm-linux" is listed as a tier 2 support platform for ghc, but with ? and "No" under GHCi and NCG
10:58:40 <fraktor> So I'm attempting to really wrap my head around some Haskell concepts, and I'm running into a couple of questions I don't know how to google.  What is an example of a functor that is not applicative, or a functor that is not a monad?
11:00:06 <dolio> data ReadRef a = forall e. RR (IORef e) (e -> a)
11:01:38 <tomsmeding> for example, https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Exception.html#t:Handler
11:01:45 <hekkaidekapus> tomsmeding: petersen (currently offline) is quite dedicated to making GHC build on S390.
11:01:59 <monsterchrom> dminuoso: I outdid that inb4.  http://www.vex.net/~trebla/haskell/cont.xhtml#yield  then scroll down to Exercises, look for exercise 5 "When I was a teenager".
11:02:10 * tomsmeding doesn't even properly know what S390 is, nor OS/2
11:02:55 <hekkaidekapus> tomsmeding: <https://fedoraproject.org/wiki/Architectures/s390x>
11:03:48 <monsterchrom> Actually maybe Hugs can run on 16-bit DOS.
11:04:54 <tomsmeding> "so the assumption size_t == unsigned int fails here"
11:05:07 <tomsmeding> the assumption carried from 32-bit systems, I assume
11:07:18 <carbolymer> tomsmeding, dminuoso, shit - I'm unable to reproduce this bug in clean hspec test :s
11:07:34 <monsterchrom> C compilers for 16-bit DOS are also very likely to satisfy size_t = sizeof(unsigned int) = 16.
11:07:41 <tomsmeding> carbolymer: I was kind of fearing that :p
11:07:55 <monsterchrom> err I mean size_t = unsigned int, both 16 bits
11:08:51 <tomsmeding> carbolymer: can you print a line to stdout whenever newTVarIO is executed, and whenever that increment code is executed, showing which thread is doing it and what the new value is?
11:12:16 <dminuoso> carbolymer: run a grep for unsafePerformIO through your code base..
11:12:34 <hekkaidekapus> tomsmeding: For a recent example, see the ‘Archives’ section at <https://koji.fedoraproject.org/koji/buildinfo?buildID=1620850>.
11:12:48 <dminuoso> If STM is giving you race conditions, chances are you've sneaked unsafePerformIO or equivalent in.
11:13:33 <tomsmeding> super fancy hekkaidekapus 
11:14:53 <hekkaidekapus> S390X is an IBM thing and petersen is a RedHat employee, so not really fancy :)
11:15:00 <carbolymer> dminuoso, but how would it help? I'm just running it on isolated test case in hspec test - there's not much going on there
11:19:52 <carbolymer> tomsmeding, I've found a workaround, added a random delay (1ms;5ms) before each async
11:19:58 <carbolymer> damn memory visibility!
11:20:23 <tomsmeding> ... what architecture are you running that on, and how far are these threads apart
11:20:26 <tomsmeding> physically
11:20:48 * tomsmeding is back in an hour or so
11:21:21 <carbolymer> x86_64 inside VM, windows 10 Enterprise is host
11:21:35 <carbolymer> physically? idk
11:37:21 <mastarija> I'm using GHC 8.8.something and I can't expand type alias, I thought this was possible with :kind! command, but it just prints back the same type alias I give it.
11:37:33 <mastarija> Is this an error or am I doing something wrong?
11:37:52 <mastarija> *bug, not error
11:37:58 <geekosaur> known issue, I think
11:38:05 <mastarija> damn
11:38:17 <mastarija> Any workaround?
11:38:28 <geekosaur> with no fix because there are too many arguments about what it should be doing and how
11:38:54 <Uniaika> mastarija: you can do it with :info actually
11:39:38 <mastarija> Uniaika, oh... that's nice
11:39:45 <mastarija> Uniaika, thanx!
11:40:00 <Uniaika> you're welcome :)
11:40:41 <mastarija> Uniaika, oh.. but it doesn't really work I've noticed
11:40:54 <mastarija> When I have a type argument it doesn't work
11:41:08 <mastarija> Or rather, it doesn't show evaluated type with type argument applied
11:42:15 <mastarija> Uniaika, if I do this :info! ( List' Int ) it says parse error, and if I remove parentheses it just lists info for List' and Int separately
11:43:49 <Uniaika> ah yeah, I've only tried on a `type Foo = Int` alias
11:44:59 <Uniaika> if geekosaur can tell you where the discussion is happening regarding what :kind! is supposed to do, maybe could you chime in and plead in favour of a dedicated ghci command?
11:45:33 <geekosaur> I'm looking...
11:51:58 <geekosaur> bah, can't search for ":kind!" sanely
11:52:07 <geekosaur> only 1000+ pages to scan through
11:56:58 <tomsmeding> https://github.com/ghc-proposals/ghc-proposals/pull/79
11:57:24 <tomsmeding> typing 'ghc kind' in my browser address bad pulled it up very quickly, I've been annoyed by this in the past too :p
11:57:28 <tomsmeding> *address bar
11:59:15 <geekosaur> that's a proposal spun off the bug, unless it links the bug too?
12:00:29 <geekosaur> there's a bug discussing why the type alias expansion stuff was removed, iirc it interfered with expanding type families
12:01:31 <geekosaur> https://gitlab.haskell.org/ghc/ghc/-/issues/13795
12:21:06 <texasmynsted> I am sure there is a structure like this.... I have something that forms a Monad and a Functor. I want to apply a function to it if it satisfies some predicate. 
12:23:05 <texasmynsted> I could do this with guards, or with an if/else, or ... hmm. I wonder if there is something in Arrow.
12:25:52 <tomsmeding> @t ifM (> 0) succ
12:25:59 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:26:03 <tomsmeding> % :t ifM (> 0) succ
12:26:04 <yahb> tomsmeding: ; <interactive>:1:1: error: Variable not in scope: ifM :: (a0 -> Bool) -> (a1 -> a1) -> t
12:26:15 <koz_> texasmynsted: Try writing the type of such a thing.
12:26:28 <tomsmeding> % :t let ifM p x y = p >>= \b -> if b then x else y in ifM (> 0) succ
12:26:28 <yahb> tomsmeding: (Ord a, Num a, Enum a) => (a -> a) -> a -> a
12:26:41 <tomsmeding> where ifM is the obvious thing, in various libraries
12:26:44 <koz_> Is your goal something like watIWant :: (Monad m) => (a -> b) -> (a -> Bool) -> m a -> m a
12:26:59 <koz_> Sorry, slight error.
12:27:03 <koz_> Is your goal something like watIWant :: (Monad m) => (a -> a) -> (a -> Bool) -> m a -> m a
12:27:19 <koz_> (Monad implies Functor, so no need to have that there)
12:27:39 * texasmynsted looking up ifM
12:28:14 <tomsmeding> texasmynsted: (probably want to write it yourself if you don't already include a library that has it)
12:29:28 <tomsmeding> this uses the trick that ((->) a) is a monad :p
12:29:33 <tomsmeding> which is not for the faint of heart
12:29:35 <texasmynsted> Okay. Fair enough. 
12:30:36 <dminuoso> Rewriting almost half of a 2k lines code generator in one day.
12:30:50 <dminuoso> The type system has my back once again. :)
12:30:52 <koz_> dminuoso: #JustHaskellThings ?
12:31:12 <dminuoso> koz_: Hehe yeah.
12:31:46 <koz_> Meanwhile I'm in a special kind of parsing hell.
12:32:04 <dminuoso> Haha, my parser is one big blop of adhoc stateful shenanigans.
12:32:14 <dminuoso> megaparsec over State
12:32:15 <koz_> dminuoso: FUNNY YOU SHOULD MENTION THAT
12:32:35 <davean> dminuoso: over state, interesting.
12:32:59 <koz_> So you're in like StateT s Parser?
12:33:18 <dminuoso> type Parser = ParsecT Void String (S.State ParserState)                                                  
12:33:28 <koz_> Ah, OK, the other way around.
12:35:44 <dminuoso> davean: Yeah. Lets you do context-sensitive things easily, or do some adhoc hacks.
12:36:14 <dminuoso> Im doing so I can build up a data structure as Im parsing, avoiding the need to build into some kind of DSL + extra evalutaor
12:48:06 <avdb> Sorry if this question already got asked a million times, but I'm looking for a vim plugin that offers only syntax highlighting? Error correction and stuff is really disturbing to me.
12:48:58 <avdb> Currently using VSCode only with the "Haskell Syntax Higlighting" plugin.
12:49:26 <dminuoso> neovim/haskell-vim ?
12:49:36 <dminuoso> err
12:49:40 <dminuoso> neovimhaskell/haskell-vim ?
12:49:47 <maerwald> yes
12:49:50 <maerwald> neovimhaskell/haskell-vim
12:50:09 <maerwald> make sure to set g:haskell_indent_disable = 1
12:51:18 <koz_> How would I spell 'given parser p, try it, giving Nothing if it fails, and Just its result otherwise, eat whatever input remains either way' in attoparsec?
12:51:58 <maerwald> this sounds like a good exercise for monsterchrom's students
12:52:00 <dminuoso> % :t optional -- koz_ 
12:52:01 <yahb> dminuoso: Alternative f => f a -> f (Maybe a)
12:52:30 <dminuoso> Dunno about attoparsec, you might have to disable backtracking
12:52:39 <koz_> dminuoso: That's why I'm asking.
12:52:49 <avdb> dminuoso: Is it also available for basic vim? Neo got too much features that I don't need.
12:52:57 <maerwald> avdb: yes
12:53:24 <maerwald> yes, neovim is "agile"
12:53:30 <avdb> Ah okay, thanks. Currently checking the github page.
12:53:52 <maerwald> I think ppl wrote better software before git
12:53:59 <koz_> I guess I could use count with a count of 1.
12:54:12 <maerwald> there was a time when a bad release was embarrassing
12:54:16 <maerwald> now with git, no one cares
12:54:31 * hackage addy 0.1.0.1 - A full-featured library for parsing, validating, and rendering email addresses  https://hackage.haskell.org/package/addy-0.1.0.1 (PeterJones)
12:55:19 <dminuoso> koz_: It seems you cant disable backtracking on attoparsec mmm
12:55:24 <ibloom> Is there a good reason why Data.Vector and Data.Vector.Storable are different libraries and different types?
12:55:25 <avdb> maerwald: Do you mean it's better? To be honest I never checked the differences until now.
12:55:30 <koz_> Count with a count of 1 works well enough for me.
12:55:39 <avdb> I used neovim at first but for some reason I reverted back to classic vim.
12:55:49 <maerwald> avdb: no idea. It's broken on my keyboard layout, so I can't reasonably use neovim
12:55:51 <koz_> ibloom: Yes. Vector can store anything, Vector.Storable can only store... well, Storable instances.
12:56:09 <koz_> They're represented differently too - in particular, Storable Vectors are designed for passing to FFI.
12:56:27 <maerwald> also, GUIs are a mess in neovim
12:57:01 <maerwald> too many, but none complete
12:57:08 <maerwald> agile
12:57:10 <dolio> Vim comes with Haskell highlighting.
12:57:15 <dolio> As does neovim, I think.
12:57:32 <ibloom> Is there a way to go between the two types of vectors at zero expense?
12:57:43 <davean> ibloom: what two types?
12:58:10 <koz_> ibloom: Also, what are you trying to do that requires this?
12:58:44 <ibloom> I have regular vectors that I'm freezing from Data.Vector.Mutable and Data.Vector.Storable that come from JuicyPixels
12:58:48 <maerwald> avdb: also, Twinside/vim-hoogle is useful
13:00:02 <koz_> Is there a reason you can't just work with Storable all the time?
13:00:07 <koz_> Storable has mutable versions too.
13:00:28 <maerwald> I also use luochen1990/rainbow for haskell. First installed it for clojure some time ago, but it's nice here too
13:00:33 <avdb> maerwald: I'm not there yet, I still have a hard time understanding Hoogle but still not as bad as cppreference.
13:01:06 <ibloom> Yeah the mutable version of storable is implemented very differently... perhaps I'm missing something.
13:01:57 <davean> Ok, vectors from the 'vector' package, thats a good place to start.
13:02:31 <koz_> ibloom: What do you mean?
13:02:34 <davean> ibloom: what do you mean "implimented very differently"?
13:02:41 <koz_> It's the same as mutable vectors for any other variety basically.
13:02:47 <maerwald> avdb: https://tinyurl.com/yxhxn7m3 my plugin config 
13:03:34 <ibloom> davean: Data.Vector.Mutable is based on read and write for example. Maybe I need to read more.
13:03:47 <koz_> ibloom: What do you mean by 'read more'?
13:03:59 <ibloom> I mean I need to read more of the docs.
13:04:19 <koz_> ibloom: Are you unclear how to move between mutable and immutable vectors, perhaps?
13:04:20 <davean> ibloom: thats not the mutable storable, but if you can't read and write its not mutable - thats what being mutable is
13:05:02 <davean> ibloom: if you don
13:05:08 <dolio> Well, the write part.
13:05:09 <davean> t want read and write you don't want mutable vectors
13:05:23 <davean> dolio: well no, read because mutable ones have a semantic difference in that they're ordered
13:06:04 <ibloom> No no, all of that code is written already, I just have images I'm generating by writing to mutable vectors and others that I'm loading from JuicyPixels and the only way I can find to combine them was to go to and from a list.
13:06:44 <davean> freeze?
13:07:24 <ibloom> If I freeze from Data.Vector.Mutable MVector I get a Data.Vector vector. I need a Data.Vector.Storable vector.
13:08:04 <davean> Right so use the storable version ...
13:08:28 <davean> If you want storable, use storable?
13:09:03 <ibloom> Right, that means I need to rewrite all my mutable code, because the libraries are actually very different as far as I can tell.
13:09:08 <davean> You're code doesn't have to care which it is, use Data.Vector.Generic(.Mutable)
13:09:12 <davean> no, it doesn't
13:09:38 <koz_> ibloom: Not really, no. The APIs of all the mutable vector types are almost exact matches.
13:09:42 <davean> I'm so confused how you're not hearing what is being said
13:10:04 <koz_> The only difference is that your data has to be Storable to be put in a mutable Storable vector. Is that the issue here?
13:10:32 <ibloom> I think I wasn't using the Generic version. Instead I've got an old library.
13:10:46 <davean> old? How old are we talking ... thats not new
13:11:04 <geekosaur> pretty sure they've always had nearly identical APIs
13:11:36 <geekosaur> unless we're talking some JuicyPixels thing
13:11:57 <davean> geekosaur: Data.Vector.Generic.* got added in 2009
13:12:18 <ibloom> I've been importing Data.Vector.Mutable instead of Data.Vector.Generic.Mutable
13:12:41 <ibloom> I'll try that and let you know how it goes.
13:15:10 <ibloom> I see , it looks like I'm actually using STVectors. Sorry, I've been wiring up some old code I hadn't touched in a while.
13:16:17 <koz_> STVector is just a mutable vector specialized to ST.
13:20:14 <scasc> Just a quick question:
13:20:44 * dminuoso patiently waits for the question
13:20:56 * dminuoso scribbles down potential answers
13:21:07 * dminuoso readies the ScopedTypeVariable answer
13:21:08 <scasc> I seem to remember that some recent GHC dropped 32-bit architecture (i386) support, and only supports x86_64 now
13:21:24 <scasc> is that right, or do I misremember?
13:21:42 <maerwald> I don't remember that
13:22:33 <geekosaur> there was discussion of that for windows, I think?
13:22:34 <maerwald> even 9.0.1-alpha1 has 32bit
13:22:34 <dminuoso> https://www.haskell.org/ghc/download_ghc_8_10_1.html#linux_i386
13:22:42 <dminuoso> scasc: We ship i386 builds.
13:23:02 * hackage zxcvbn-hs 0.3.0.0 - Password strength estimation based on zxcvbn.  https://hackage.haskell.org/package/zxcvbn-hs-0.3.0.0 (PeterJones)
13:26:03 <scasc> Thanks. I was quite unsure, that's why I wanted to double check.
13:26:38 <scasc> Didn't find an authoritative source, but of course, I could have checked the distribution packages provided.
13:30:29 <geekosaur> so fwiw there is no i386 download for windows in 8.8.4
13:30:42 <geekosaur> only x86_64
13:35:20 <scasc> I really thought that there was at least a discussion about generally dropping 32-bit support in general? Like I seem to remember that it was brought up that the last 32-bit only Intel processor was a Core Duo, introduced January 2006 (so, 15 years in some months).
13:35:50 <scasc> The discussion might have related a different language/compiler though. I'm really hazy.
13:48:56 <hekkaidekapus> scasc: <https://old.reddit.com/r/haskell/comments/hrytns/announce_ghc_884_now_available/fy7qki5>
13:50:58 <scasc> @hekkaidekapus: yes! That was it!
13:50:58 <lambdabot> Unknown command, try @list
13:51:35 <scasc> And it ben gamari only talked about 32-bit *Windows*.
13:51:49 <hekkaidekapus> So, see what geekosaur said above: it’s only about Windows.
13:53:49 <scasc> (if that step is concluded, then only linux would remain as a Tier 1 x86 patform, as MacOS is already only supported on x86_64)
13:53:51 <scasc> https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms#tier-1-platforms
13:57:14 <merijn> That's because on 32bit windows there's a whole bunch of trickiness with the linker, iirc
13:57:53 <hekkaidekapus> scasc: I don’t know about the update frequency of GHC/Wiki, but if you want to be sure, choose a version and check its download page, say <https://downloads.haskell.org/~ghc/8.10.2>.
13:58:36 <hekkaidekapus> merijn: That, and all the issues linked to in the Reddit post.
13:59:46 <scasc> Hm, i386 only for deb9, not for deb10 or the other linux distros.
14:01:50 <hekkaidekapus> The deb9/deb10 is only an indication of the expected ABI. It does not mean the bindist could not work on other distros.
14:02:08 <merijn> Yeah
14:04:15 <hekkaidekapus> scasc: If unsure, use ghcup. It ships with heuristics to choose a bindist best suited to your distro.
14:04:45 <maerwald> probably not many i386 users though
14:05:07 <hekkaidekapus> Aye.
14:14:36 <scasc> Exploratorily: would dropping x86 (32bit) architecture support in general (for all OSes) open up the way to simplify the GHC codebase or build toolchain?
14:16:31 * hackage mysql 0.1.7.2 - A low-level MySQL client library.  https://hackage.haskell.org/package/mysql-0.1.7.2 (paulrouse)
14:20:58 <monsterchrom> It would.
14:21:42 <monsterchrom> But be careful with your measure of "simplify".
14:22:54 <hekkaidekapus> scasc: x86 is not a bottleneck in that regard, IMO. You can make an informed opinion by exploring these labels: <https://gitlab.haskell.org/ghc/ghc/-/issues?label_name%5B%5D=infrastructure>, <https://gitlab.haskell.org/ghc/ghc/-/issues?label_name%5B%5D=CI>, <https://gitlab.haskell.org/ghc/ghc/-/issues?label_name%5B%5D=hadrian>,
14:22:55 <hekkaidekapus> <https://gitlab.haskell.org/ghc/ghc/-/issues?milestone_title=Make+removal>.
14:23:49 * hekkaidekapus apologises for the URL avalanche.
14:33:26 <monsterchrom> Derp, I have a python file "yield.py". I try to "import yield" to load it. I forgot that this clashes with the reserved word "yield" so python isn't understanding me.
14:33:53 <yushyin> :D
14:33:57 <Rembane> monsterchrom: You can still import it if you jump through hoops but you might want to rename it instead.
14:34:01 <monsterchrom> This is why Haskell makes module names capitalized, and reserved words not. This is exactly right.
14:34:10 <monsterchrom> Yeah
14:34:52 <Rembane> Cunning! 
14:35:45 <monsterchrom> Wait a second, yield-examples.py won't make sense either. This is a stupid language.
14:36:13 <hpc> be a real python programmer, name it __yield__
14:36:23 <monsterchrom> Sorry folks, I'm dabbling in python because I am coding up python yield examples so that I can then teach Racket's shift/reset. :)
14:37:03 <Rembane> monsterchrom: Misspell it instead. yeeld. :D
14:37:27 <monsterchrom> Then again Yield-Example.hs won't make sense either if I plan to "import Yield-Example". Bah stupid languages. Scheme is better in this regard.
14:37:44 <monsterchrom> Haha I'll take that advice.
14:38:32 <texasmynsted> monsterchrom: You are learning python to teach Racket?
14:39:02 * hackage Agda 2.6.1.2 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.6.1.2 (AndreasAbel)
14:39:32 <monsterchrom> More generally, I'm learning programming languages to teach principles of programming languages.
14:40:01 <Rembane> monsterchrom: What's your verdict of programming languages so far?
14:40:02 <monsterchrom> But we use Racket and Haskell to talk about the principles. So it does look like "to teach Racket and Haskell".
14:41:15 <monsterchrom> I don't have strong opinions. I like Haskell myself. But if students learn to deconstruct programming languages a bit and appreciate various features and sacrifices, that's cool for me.
14:41:29 <texasmynsted> Seems to me that Racket and Haskell would be fair better choices for teaching anything than python.
14:41:47 <Rembane> Unless you want to teach Python of course
14:41:55 <texasmynsted> why would  you want to do that?
14:42:19 <Rembane> monsterchrom: That sounds like very good learning outcomes 
14:42:39 <dolio> Maybe you should use Ruby instead. Does it still have callCC?
14:42:41 <Rembane> texasmynsted: It's a very useful language, especially if you want to do some scripting for automating stuff or to do machine learning.
14:42:59 <texasmynsted> I am not convinced
14:43:10 <monsterchrom> To some extent I and my colleagues are converging to defining this "principles of programming languages" course to be basically the lambda-the-ultimate papers explained in modern terms and adjusted to 3rd-year CS.
14:43:19 <yushyin> useful because of tons of libraries
14:43:40 <monsterchrom> Haha I fear Ruby.
14:44:14 <texasmynsted> seems to me haskell has a fair number its self
14:44:25 <monsterchrom> 1970 : C :: 1990 : Python
14:45:03 <monsterchrom> I mean, I know C and Python have very different semantics. But I'm not comparing that.
14:45:31 <monsterchrom> I'm comparing why people use them despite semantics issues. It's only because "has libraries".
14:45:33 <texasmynsted> I am mostly joking. I have considered learning python just to be able to help all the people struggling to learn it 
14:46:10 <monsterchrom> and networking effect
14:46:22 <texasmynsted> I need strict typing to prevent insanity 
14:46:52 <dolio> Why do people spend time with elaborate type hacks in GHC instead of helping to make Idris viable? :þ
14:47:00 <monsterchrom> hehe
14:47:13 <texasmynsted> dolio: hmm. good question
14:47:26 <monsterchrom> You know what, 1970 : C :: 1990 : Python :: 2020 : Haskell.
14:48:06 <monsterchrom> i.e., GHC Haskell enjoys more libraries than Idris does
14:48:46 <monsterchrom> Then again, I haven't checked whether there is a version of wreq for Idris.
14:51:18 <texasmynsted> maybe the ML libraries from python should be ported to other languages.
14:51:54 <dolio> Most of it isn't even python, is it? They're just python wrappers for C code or something.
14:52:14 <monsterchrom> Yeah
14:53:43 <Rembane> texasmynsted: They definitely can be, but that takes much more time than just using them. 
14:53:51 <hpc> dolio: honestly, most of python is just C
14:55:16 <Sgeo> So, this is a long shot and basically completely off topic, but: A lot of FRP stuff is inspired by ActiveVRML, right? Does the ActiveVRML control exist anywhere still?
14:55:25 <dolio> I would imagine the reason things settled on python is that for machine learning you're much less likely to care about language features. You're just scripting the underlying high performance stuff.
15:08:34 <thblt> dolio: that's roughly most of Python use besides scripting, I think :)
15:10:01 * hackage aura 3.2.2 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.2.2 (fosskers)
15:19:12 <thblt> (Eg numpy is 33% C)
15:28:32 * hackage mock-httpd 1.0.0 - A HTTP server for testing HTTP clients  https://hackage.haskell.org/package/mock-httpd-1.0.0 (PeterJones)
15:29:10 <texasmynsted> hmm. Looks like I got disconnected. 
15:31:04 <texasmynsted> dolio: I have wondered why people would care about machine learning but not about effective programming. 
15:32:26 <texasmynsted> What would be wrong with using ML and Haskell or ML and Scala. Why ML and python?
15:32:54 <Rembane> Because numpy and scipy 
15:34:23 <thblt> And because you can't care about everything? Perfectionism is a curse.
15:34:32 <koz_> Also because argumentum ad serpentum makes people think Python is 'intuitive', 'natural' and 'easy to work with'.
15:34:48 <koz_> None of the above are even remotely close to _testable_, much less true, but argumentum ad serpentum.
15:35:44 <thblt> hahaha I love, and officially adopt, "argumentum ad serpentum"
15:35:53 <Uniaika> yeah I love it too
15:36:13 <koz_> thblt, Uniaika: Thank you, I'm glad my British private school education was not for nothing.
15:36:20 <thblt> (But well, testable or not, I honestly think it's true.)
15:37:14 <thblt> Highly dynamic languages are easy to get started on, although hard to write programs on that don't explode in mid-flight.
15:37:42 <koz_> thblt: I would argue that this is _opposite_ of 'easy to work with'.
15:37:47 <koz_> Yes, you can write garbage easily.
15:37:52 <koz_> I don't consider this a virtue.
15:38:15 <thblt> koz_: my argument was about intuitive. I'm on #haskell, I'm not going to argue the virtues of dynamic typing.
15:38:21 <thblt> :)
15:38:40 <koz_> thblt: I dunno. Python grated on my intution badly even when I _wasn't_ a Haskeller.
15:38:50 <texasmynsted> But _why_ do people want to do ML in the first place? It would seem to me because it is useful. Think how much better it would be if the programs using the libraries were equally useful. 
15:40:04 <thblt> koz_: to each their own, I guess. To me, Python is very, very obvious and my goto language for everything .1kslocs and below.
15:40:17 <texasmynsted> I would think if one is willing to learn ML one would be willing to learn Haskell/Scala/WhateverLang.
15:40:26 <thblt> Also because of the stdlib let's be honest.
15:40:48 * texasmynsted shrug
15:40:51 <koz_> thblt: Welcome to the 'it's not testable' part of my claim, and as far as I'm concerned, untestability means talking about whether it's true or not is meaningless. However, if you can get work done in Python, more power to you, because I just want to shower constantly in that language's presence.
15:41:40 <thblt> koz_: I'm not sure it's not testable, but I certainly can't be bothered into implementing a testing protocol :)
15:42:08 <koz_> thblt: You think you can come up with a scientific test for _intuitiveness_? Uhh, glhf with that.
15:42:20 <texasmynsted> Soon we will get to the testing vs types discussion . . . 
15:42:36 <koz_> texasmynsted: Not the sort of testability I am referring to by a country mile.
15:42:38 <thblt> well, if it means something, it's testable.
15:43:10 <koz_> thblt: You think you can come with a _singular_ definition for intuitiveness? Uhh, also glhf with that.
15:43:18 <dsal> thblt: haskell is my goto for just about anything.
15:43:22 <texasmynsted> koz_: what are you referring to?
15:43:31 <koz_> texasmynsted: Testability in the scientific method sense.
15:43:42 <koz_> Not in the 'does my software launch nukes when I didn't ask it to' sense.
15:43:43 <texasmynsted> Python?
15:43:44 <dsal> I've seen a lot of people argue about, e.g., Haskell not being intuitive.  It's usually more like, "Haskell doesn't match the mental model I've trained myself in for the last two decades."
15:43:46 <texasmynsted> Really?
15:44:09 <koz_> texasmynsted: Are you asking me if I really meant what I said?
15:44:11 <koz_> If so, then yes?
15:44:14 <thblt> dsal: I may get there, but the Prelude is an issue. For quick scripts, Python wins for me because of the batteries included aspect.
15:44:17 <koz_> Also what dsal said.
15:44:36 <thblt> dsal: isn't that exactly what an intuition is?
15:44:49 <koz_> Haskell is unashamedly different, and I like it for that. C is not such a good language that we should slavishly adopt its conventions.
15:44:53 <dsal> When you don't like python's batteries, you get to learn one of several competing things to make stuff work, and then your scripts don't work at some point in the future and you don't know how to recreate the environment.
15:45:10 <dolio> texasmynsted: I think there's nothing wrong with doing machine learning in Haskell or ML. I just think the people who gravitate toward machine learning would be the opposite of the kind of person who cares about the language it's done in being 'good'.
15:45:21 <koz_> And those batteries also suck in innumerable ways. Two of which I have encountered personally. As a _user_.
15:45:32 <dsal> thblt: It might be denotation, but connotation implies something closer to "natural."  IMO, haskell is at least as natural as most other languages I've had to use.
15:45:39 <koz_> Python works if your buy-in to argumentum ad serpentum is high enough.
15:46:05 <koz_> (by 'encountered' I mean 'in the last week or so')
15:46:20 <dsal> I used to use twisted quite a lot.  Then I found someone who didn't like twisted made yet another thing to reinvent it and bragged about how much better and more intuitive it was (as long as you ignored the swaths of things I couldn't do with their framework).
15:46:25 <koz_> (and by 'user' I mean 'not a developer')
15:46:33 <texasmynsted> So testable like Coq or TLA+ or minizinc or agda, Idris, etc?
15:46:37 <thblt> koz_: Haha I believe you, big lib implies debatable choices.
15:47:01 <dsal> Python stdlib includes stuff like their async library they recommend nobody ever use, or the execution running stuff that they recommend nobody ever use.
15:47:02 <texasmynsted> maybe I just do not know enough about python
15:47:04 <koz_> thblt: So then 'batteries included' really means 'Big Daddy Guido did things the way he thinks best and you better like it'.
15:47:24 <dsal> Both are *almost* good, but missing just a bit of functionality.  It's recommended you pick up something else external if you want to do any of these things that are included.
15:47:37 <dsal> For all intents and purposes, hackage is stdlib for my programs.
15:47:42 <dolio> texasmynsted: Because machine learning is the opposite of trying to clearly state the solution to a problem. :)
15:47:56 <koz_> dsal: That statement ports to any language and its hosted ecosystem, to be fair.
15:47:58 <texasmynsted> dolio: Ah ha! That makes sense.
15:48:08 <koz_> C.f. JS and npm, Python and pip, etc.
15:48:15 <texasmynsted> Okay I can understand that then.
15:48:15 <thblt> Hence my .1kslocs rule of thumbs. Anything above that, I can $package-manager-and-build-system init something.
15:48:18 <dsal> To be fair, python has more than one.
15:48:42 <dsal> You have to like, easy_install pip to get your virtualenv running.
15:49:05 <dsal> But yeah, once you get into the ecosystem, it kind of works.  Some ecosystems operate more smoothly than others, though.
15:49:23 <thblt> I never use those.
15:49:24 <texasmynsted> I had installed anaconda ages ago. Now it tells me that my "free trial" is about to run out. No idea what it is talking about.
15:49:44 <thblt> (for python i mena)
15:49:45 <thblt> mean
15:49:56 <merijn> Python has like 30 package managers
15:50:01 <merijn> and their all god awful
15:50:15 <koz_> merijn: Very much this.
15:50:16 <merijn> I'd kill for cabal-install anytime I have to deal with pip and virtualenvs >.>
15:50:20 <texasmynsted> sure. Why should they work any better than the language its self?
15:50:25 <thblt> merijn: #emacs would find this reasonable.
15:50:31 * hackage playlists 0.5.1 - Library and executable for working with playlist files.  https://hackage.haskell.org/package/playlists-0.5.1 (PeterJones)
15:50:34 <thblt> :)
15:50:40 <dolio> texasmynsted: I think it's kind of like people who use matlab, although python is way better than matlab's language (last I checked).
15:50:48 <merijn> "Our bad, guys! We fucked up the package manager, but we'll get it right this time!" *proceeds to get it wrong in entirely different ways*
15:51:41 <dsal> 1kloc is massive, though.  My whole GoPro app is only about 1400 lines.  And that's a bunch of commandline tools (resumable upload that has to keep state), syncing to the cloud via AWS magic, local downloads, its web API, syncing down from their cloud, a SQL interface to update data via their API, and other crap (something like 16 commands in the CLI tool)
15:51:43 <texasmynsted> https://xkcd.com/927/
15:51:55 <texasmynsted> Like that but with package managers?
15:52:15 <thblt> merijn: a french tv show, the Shadoks, came up with the motto that given a very low chance of success, failing in all possible ways will get you closer to success ("The more you fail, the more likely you are to win")
15:52:17 * texasmynsted shrug
15:52:26 <thblt> dsal: that's 0.1
15:52:34 <thblt> 100 lines
15:52:56 <thblt> a quick script that may need to gzip stuff or read command line args
15:52:59 <texasmynsted> thblt: That is some good wisdom there
15:54:29 <texasmynsted> The "double your failure rate" idea.
15:54:32 <dsal> thblt: ah, I've not seen fractions of a kloc.  My log management thing is about 80 lines.  Take individual logs from S3 and combine them into a 7z file, deleting the old logs and uploading the fancy compressed one.  I do use the 7z commandline, though.
15:55:31 <thblt> dsal: sorry for the confusion.
15:55:46 <dsal> I originally wrote this thing in go, but it was a lot longer, buggier, and harder to follow.  https://github.com/dustin/papertrails/blob/master/app/Main.hs#L43-L57
15:56:12 <hekkaidekapus> dolio: People who are into research related to Statistics/Image Processing publish stuff developped with Matlab, R, Julia, Python. And once you set a foot into those waters, it’s hard to use another language because “State Of The Art”.
15:58:22 <thblt> That reminds me I have a stupid shebang script to transparently compile haskell scripts with stack
15:58:51 <thblt> Maybe I'll end up doing my scripting with haskell too at some point :)
15:59:46 <sm[m]> thblt: stack's script command works great for that
15:59:55 <dsal> Hmm...  My original v5 mqtt bridge was closer to 150 lines, but I built a language parser to express the bridging configurations.  It's grown since then, though.  I've got multiway bridging with rewrite rules and stuff.  Currently 268 lines...
16:01:06 <dolio> Yeah, I'm no expert, but I imagine the 'program' part isn't complicated in a lot of cases. It's making use of a bunch of already built statistics stuff, which is why you use matlab/R/etc.
16:01:36 <thblt> sm[m]: My old script uses stack, it just recompiles when modified and saves in a cache dir https://github.com/thblt/hsbang
16:01:49 <sm[m]> stack script does that also
16:02:05 <thblt> good to know, thanks!
16:02:09 <dsal> Heh.  Did you reinvent nix?  :)
16:02:50 <sm[m]> stack script --compile, more specifically
16:03:19 <yushyin> I've the same problem with cabal's script command, it does not cache and recompiles every time :/
16:03:20 <thblt> No, not at all! The dependency system is all stack, all what my script did was save the compiled binary and call it instead of the source script.
16:03:40 <sm[m]> yushyin: right, cabal doesn't have this feature yet
16:05:13 <hekkaidekapus> dolio: The statistics part of, say R, is mostly made of wrappers around C and Fortran. One could clean up all the mess around S3 classes, S4 classes,… (S5?) and use Haskell’s FFI. But once you go in that direction, bibliometry and funding will go in your way.
16:08:20 <hekkaidekapus> As in, folks don’t care how they get to the publications as long as there is a fast-and-loose way to get them, as you wrote.
16:10:34 <dsal> almost everything I like about R is ggplot2
16:10:56 <dsal> (all the other parts I relearn every time so I can get back to ggplot2)
16:11:42 <sm[m]> wow, today I learned that stack script --optimize /= stack script --compile
16:11:51 <hekkaidekapus> ggplot2 is great because of the Grammar of Graphics. But once you peel beyong the surface, it’s C all way down.
16:11:56 <nshepperd2> ggplotly is pretty cool. the thing that takes a ggplot2 and turns it into an interactive web chart
16:11:59 <sm[m]> neither are in the user guide
16:14:06 <hekkaidekapus> And writing that Grammar part in R is cumbersome.
16:14:55 <dsal> I've not tried fancier stuff.  I've often wished for ggplot2 and d3 to like, hang out.  I've done a bunch of low-level junk in D3 and high level junk in ggplot2.  Can take a while to express things effectively.  By the time I get to the end, I'm too tired/Stockholmed to file any usability bugs.
16:14:57 <hekkaidekapus> But since there is a wide ecosystem around ggplot2, who cares about the foundations :)
16:15:56 <hekkaidekapus> lol
16:18:48 <hekkaidekapus> Fancier stuff in ggplot2 will involve the family of *apply* functions. Imagine if people used Hashell’s features of filtering and traversing instead of a pure Scheme.
16:19:12 <hekkaidekapus> *poor (not pure)
17:22:20 <ghoulguy> maerwald: Is ghcup 0.1.12 waiting on more testing?
17:55:14 <hyiltiz> no reason we cannot implement the graphics grammer in a haskell DSL tho
17:55:41 <hyiltiz> haskell is much better suited for the task than R; in fact, ggplot only overloads (+)
17:56:06 <hyiltiz> and what ggplot calls + is kinda like the monad bind
17:57:10 <hyiltiz> hadley whichman probably is also well aware of the monadic nature of his DSL; he focuses more heavily on functional these days
17:57:31 * hackage crdt-event-fold 1.0.0.2 - Garbage collected event folding CRDT.  https://hackage.haskell.org/package/crdt-event-fold-1.0.0.2 (rickowens)
18:32:31 * hackage digit 0.10 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.10 (TonyMorris)
19:02:32 * hackage musicw 0.3.6 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.3.6 (dktr0)
20:24:13 <unihernandez22> Hi
20:24:58 <hyiltiz-M> Hello
20:25:05 <yushyin> hello
20:25:33 <hyiltiz-M> Do people not using Matrix see this Avatar icon?
20:25:43 <unihernandez22> https://pastebin.com/JttfKa2t
20:25:53 <unihernandez22> Is there another way to do that?
20:26:02 <unihernandez22> Because it is too slow
20:26:07 <jamestmartin> hyiltiz-M: I don't know what you're talking about, so I'd say probably not
20:26:41 <unihernandez22> It is for these benchmarks https://github.com/jabbalaci/SpeedTests
20:26:43 <sm[m]> hyiltiz-M: not even matrix users see it :) just a place holder H avatar here
20:31:32 <hyiltiz-M> Awesome! I'd hate to clutter everyone's IRC cache with a stupic avatar
20:35:21 <unihernandez22> Can anyone help me? :)
20:37:06 <koz_> unihernandez22: Make your cache a Vector.
20:37:12 <koz_> !! on lists is not very good.
20:37:52 <hyiltiz> unihernandez22: u don't seem to be using memoisation either (tho the cache variable seems to be trying to do so?)
20:41:12 <dibblego> > :t (!!) -- ftw
20:41:12 <dibblego> (!!) -- ftw :: Ixed s => s -> Index s -> Maybe (IxValue s)
20:41:14 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‘:’
20:42:00 <unihernandez22> hyiltiz: The cache are the squares of the digits
20:43:02 <hyiltiz> yeah i see that; but the rec. func. isM isn't re-uisng any of its computations, no?
20:43:21 <unihernandez22> No
20:43:45 <unihernandez22> Because the algorithm must be the same as the other languages, for the benchmark
20:54:35 <dolio> It's not a cache of the squares of digits, though.
20:54:48 <unihernandez22> dolio ??
20:55:03 <dolio> It's a cache of digits raised to themselves as a power.
20:55:15 <unihernandez22> Oh, yes
20:56:55 <dolio> If it is supposed to be squares, using a list is almost certain to be slower.
20:57:49 <unihernandez22> No, I got confused
20:58:08 <unihernandez22> It's suposed to be the digits raised to themselves
20:59:06 <dolio> Well, I'm unsure what would be faster in some of those scenarios. I'd probably bet on the list still being slower, I guess.
20:59:43 <unihernandez22> https://pastebin.com/si3PT0Wr
20:59:48 <unihernandez22> That's a bit faster
21:05:29 <Axman6> unihernandez22: btw, filter (\i -> isMunchausen i) [0 .. 440_000_000] is the same as filter isMunchausen [0 .. 440_000_000]
21:06:34 <unihernandez22> Oh yes, that's because the function was different before
21:08:18 <Axman6> this feels like one of those problems that spending sometime thinking about it would let you drasticly reduce the number of numbers you needed to check
21:08:58 <Axman6> I assume there's some relatively simple relationship between calc n and calc (n+1)
21:09:24 <Axman6> I find this code quite hard to follow though
21:09:45 <Axman6> it feels like it's just a fold over the digits
21:10:42 <unihernandez22> calc is the sum of digits raised to themselves
21:10:49 <unihernandez22> as a power
21:11:33 <Axman6> I would try and make things a little simpler to follow by doing something like calc = sum . map recourse . digits or something
21:11:45 <Axman6> rather than passing in f to recourse
21:13:07 <Axman6> breaking the problem down into smaller, composible parts will make it clearer what the relationship between n and n+1 is, at least
21:13:15 <dsal> That `return 0` is super weird.  If you got rid of that, you could also get rid of the do.  And you could get rid of the lambda in the filter.
21:13:34 <dsal> `main = mapM_ print $ filter isMunchausen [0 .. 440_000_000]`
21:13:55 <Axman6> surprised that return 0 even type checks, but then remembered that main can have type IO a
21:14:06 <Axman6> even though we always use main :: IO ()
21:14:16 <dsal> Ah.  I didn't realize that.  I've never seen that.  Yeah, I always ()
21:15:06 <dolio> I don't think it actually does what is expected, though.
21:15:39 <dolio> It should be `exitSuccess` if you want to do that explicitly.
21:15:49 <Axman6> yeah I'm not convinced it does either... thouggh IU just realised I was parsing cache ! r + f q ad cache ! (r + f q) and not (cache ! r) + (f q)
21:16:27 * Axman6 has had about three hours sleep and struggles to type at the best of times. Good luck everybody
21:18:48 <unihernandez22> dsal, I changed that, but the problem here is the speed
21:19:32 <dsal> Sure, understood.  I'm just looking at all the things.  My brain can translate code without understanding it.  I'm on that level right now.
21:20:43 <Axman6> > let digits 0 = []; digits n = case quotRem n 10 of (n',d) -> d : digits n' in digits 12345 
21:20:45 <lambdabot>  [5,4,3,2,1]
21:21:05 <dsal> I don't understand what you're trying to do.
21:21:22 <Axman6> > let digits 0 = []; digits n = case quotRem n 10 of (n',d) -> d : digits n'; square n = n^n in map square $ digits 12345 
21:21:26 <lambdabot>  <hint>:1:77: error:
21:21:26 <lambdabot>      <hint>:1:77: error: Parse error in pattern: square
21:21:42 <unihernandez22> dsal https://github.com/jabbalaci/SpeedTests
21:22:41 <dsal> Ah, that's helpful.
21:23:29 <Axman6> > let digits 0 = []; digits n = case quotRem n 10 of (n',d) -> d : digits n'; ; square n = n^n in map square $ digits 12345 
21:23:31 <lambdabot>  <hint>:1:79: error:
21:23:31 <lambdabot>      <hint>:1:79: error: Parse error in pattern: square
21:23:43 <Axman6> > let digits 0 = []; digits n = (case quotRem n 10 of (n',d) -> d : digits n') ; square n = n^n in map square $ digits 12345 
21:23:46 <lambdabot>  [3125,256,27,4,1]
21:23:54 <Axman6> > let digits 0 = []; digits n = (case quotRem n 10 of (n',d) -> d : digits n') ; square n = n^n in sum $ map square $ digits 12345 
21:23:56 <lambdabot>  3413
21:24:23 <Axman6> > let digits 0 = []; digits n = (case quotRem n 10 of (n',d) -> d : digits n') ; square n = n^n in map (sum . map square . digits) [1000..] 
21:24:25 <lambdabot>  [4,4,7,30,259,3128,46659,823546,16777219,387420492,4,4,7,30,259,3128,46659,8...
21:24:56 <Axman6> > let digits 0 = []; digits n = (case quotRem n 10 of (n',d) -> d : digits n') ; square n = n^n in filter (\n -> n == sum . map square . digits $ n) [1..] 
21:24:58 <lambdabot>  error:
21:24:58 <lambdabot>      • Couldn't match expected type ‘(c -> c) -> Bool’
21:24:58 <lambdabot>                    with actual type ‘Bool’
21:25:09 <Axman6> > let digits 0 = []; digits n = (case quotRem n 10 of (n',d) -> d : digits n') ; square n = n^n in filter (\n -> n == (sum . map square . digits $ n) [1..] 
21:25:11 <lambdabot>  <hint>:1:155: error:
21:25:11 <lambdabot>      <hint>:1:155: error:
21:25:11 <lambdabot>          parse error (possibly incorrect indentation or mismatched brackets)
21:25:12 <Axman6> > let digits 0 = []; digits n = (case quotRem n 10 of (n',d) -> d : digits n') ; square n = n^n in filter (\n -> n == (sum . map square . digits $ n)) [1..] 
21:25:18 <lambdabot>  mueval-core: Time limit exceeded
21:25:19 <dsal> Doing things on one line is hard.  heh
21:26:33 <Axman6> so an interesting thing about this is that the tail of the result of digits is the same for n and n+1  unless the last digit is 10, which shows there's some caching to be had
21:26:58 <int-e> square n = n^n?!
21:27:06 <Axman6> fight me
21:27:17 <dsal> dimensionate
21:27:28 <Axman6> tetrate?
21:27:49 <unihernandez22> int-e hahaha
21:30:54 <unihernandez22> Ok... I'm going to sleep
21:31:20 <int-e> smurf, frobnicate, foo, bar, baz, xyzzy, barney, fred.
21:32:46 <Axman6> I thought n ^ n was tetration
21:33:04 <Axman6> no
21:33:20 <Axman6> it's smaller than that
21:33:32 <Axman6> (me calls it pentration)
21:33:47 <int-e> nah, tetration is something silly like  n ^^ m = iterate (n^) n !! m
21:33:53 <Axman6> yeah
21:35:09 <unihernandez22> selfpow n = n ^ n
21:35:35 <MarcelineVQ> dupsquare
21:35:43 <Axman6> > 9 ^ 9
21:35:45 <lambdabot>  387420489
21:35:56 <Axman6> join (^)
21:36:18 <int-e> How about `nendo n` because it counts endomorphisms from an n-element set to itself...
21:36:52 <Axman6> sounds like a Star Wars character
21:39:20 <Axman6> unihernandez22: btw, using Vector would make the indexing more efficient, since Arrays allow you to have arbitrary indexes, so there's alwats a conversion between your index and the underlying index into the array. Vector plus uunsafeIndex would be the best once you know it can never index out of bounds
21:41:10 <unihernandez22> Axman6, but I need it without external packages
21:46:04 <unihernandez22> Axman6, I tried directly with a function defined for each digit statically, and the speed doesn't change
21:46:32 <unihernandez22> So that's not the problem
21:47:07 <dsal> Yeah, it's unlikely your problem is that exponentiation is slow, but more that you're doing it more than you need to.
21:49:13 <unihernandez22> dsal, but with other languages it take ~5 seconds
21:49:21 <unihernandez22> And with Haskell 1 minute
21:49:39 <unihernandez22> So I think I'm doing something wrong
21:55:56 <dsal> Let me try it...
22:07:56 <unihernandez22> Ok... Bye
22:08:32 <Axman6> well I got it to 23s using LLVM, but it is still surprising it's unable to optimise it as well as the quite similar C code
22:12:35 <monsterchrom> int-e, Axman6: As in, Lando counts left Kan ("Lan") extensions? :)
22:17:56 <dsal> Yeah, this is strangely slow.  Why can't my computer math faster?
22:46:31 * hackage which 0.2 - Determine the full path to an executable.  https://hackage.haskell.org/package/which-0.2 (abrar)
