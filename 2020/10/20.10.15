00:18:49 * hackage mmsyn2 0.2.0.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.2.0.0 (OleksandrZhabenko)
00:22:19 * hackage nri-prelude 0.1.0.4 - A Prelude inspired by the Elm programming language  https://hackage.haskell.org/package/nri-prelude-0.1.0.4 (JasperWoudenberg)
00:26:49 * hackage bugsnag-hs 0.2.0.3 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.2.0.3 (JasperWoudenberg)
00:28:20 * hackage fakedata-quickcheck 0.1.0 - Fake a -> Gen a  https://hackage.haskell.org/package/fakedata-quickcheck-0.1.0 (Jappie)
01:20:50 * hackage cobot-io 0.1.3.7 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.7 (ozzzzz)
01:45:03 <merijn> @remember RobRix I’m a theoretical computer scientist, in that my programs run best on theoretical computers
01:45:04 <lambdabot> It is stored.
01:50:14 <maerwald> merijn: how convenient for you :p
01:55:41 <dminuoso> Does lens come with some Fold for a maps keys?
01:56:08 <dminuoso> Or is `to keys . each` the way to go?
01:56:15 <phadej> ifolded
01:56:33 <dminuoso> Ah, cheers phadej.
02:05:54 <dminuoso> phadej: Is there an equivalent of asIndex in optics?
02:08:28 <phadej> i don't remember
02:09:48 <phadej> looks like https://github.com/well-typed/optics/issues/321 no
02:54:19 <fendor> I want multiple modules per file :(
02:57:05 <ulidtko> hi all
02:57:09 <ulidtko> cabal question :/
02:57:26 <Zetagon> hello there!
02:57:36 <ulidtko> I'm setting executable-stripping: True -- but the built binaries are still with debuginfo
02:57:44 <ulidtko> Cabal 2.4.0.1
02:57:56 <ulidtko> > foobar/dist-newstyle/build/x86_64-linux/ghc-8.6.5/foobar-0.1.0.0/x/foobar/build/foobar/foobar: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-x86_64.so.1, with debug_info, not stripped
02:57:58 <lambdabot>  <hint>:1:121: error: <hint>:1:121: error: parse error on input ‘,’
02:58:40 <ulidtko> I've checked that the strip program is there (it's a docker container)
03:00:35 <ulidtko> even with explicit cmdline flag, i.e. cabal new-build --executable-stripping -- the built executable is non-stripped
03:03:15 <ulidtko> here, quick demo https://asciinema.org/a/365563?speed=2
03:09:49 <ulidtko> ahhhhh I'm dumb, sorry never mind
03:10:10 <ulidtko> should've read the docs more carefully
03:10:26 <ulidtko> - When installing binary executable programs, run the strip program on the binary.
03:11:46 <[exa]> stripping is usually done by the system install, see `man 1 install`
03:12:09 <[exa]> (for various fun reasons)
03:12:15 <ulidtko> yeah, the doc says *when installing* which I missed
03:12:54 <ulidtko> now I wonder how that will work with Stack's concept of "installing"
03:14:02 <[exa]> not sure, but brace for surprises :]
03:14:40 <ulidtko> hah, it's a boring day when computers don't surprise me :}
03:16:19 * hackage hlint 3.2.1 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.2.1 (NeilMitchell)
03:16:51 <[exa]> you know there are nice surprises with lots of added education value, and then the other kind... :D
04:12:55 <tinga> f :: Complex Int -> Complex Int ;; f x = x + (1 :+ 0)
04:13:01 <tinga> Why does this give  No instance for (RealFloat Int) arising from a use of ‘+’  ?
04:14:04 <phadej> % :t (+) @(Complex _)
04:14:04 <yahb> phadej: RealFloat _ => Complex _ -> Complex _ -> Complex _
04:14:16 <phadej> RealFloat a => Num (Complex a)
04:14:30 <phadej> check the source, probably because of abs
04:23:12 <tinga> Class Num does not have any type restrictions (I'm still a newbie, maybe class declarations never can have type restrictions anyway?)  https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Num.html#Num
04:23:30 <tinga> Whereas the instance declarations all have the type restriction  https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Complex.html
04:24:14 <phadej> yes, to use an instance, you have to satisfy its constraints
04:24:42 <phadej> "Complex a is an instance of class Num when a is an instance of RealFloat"
04:25:04 <tinga> yep, but I don't see why
04:26:04 <tinga> "I just want to add a real 1 to a complex number", and it appears that I can only do that if I instantiate Complex with Float, or write my own real number type?
04:26:11 <phadej> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Complex.html#t:Complex, whe nyou click Source next to Num (Complex a)
04:26:15 <phadej> you are taken to https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Complex.html#line-132
04:26:23 <phadej> and as I expected
04:26:24 <phadej> abs z               =  magnitude z :+ 0
04:26:51 <Guest_39> Hi, im having trouple installing haskell on my mac
04:26:51 <phadej> and magnitude has type
04:26:52 <phadej> magnitude :: (RealFloat a) => Complex a -> a
04:27:08 <phadej> tinga: yes, Num is suboptimal type-class
04:27:17 <Guest_39> is someone able to help?
04:28:08 <Guest_39> im getting a digest error when installing ghcup
04:28:28 <maerwald> Guest_39: which one
04:28:39 <phadej> using Complex to play with gaussian integers would need you to write own "Complex"
04:28:44 <tinga> OK, thanks phadej 
04:28:54 <Guest_39> [ Info  ] verifying digest of: ghc-8.8.4-x86_64-apple-darwin.tar.xz[ Error ] DigestError "24a6bdab3fc845b2605b951d8160d8d02d34dbb81600f3d0aabbbb8d8e8fd4fd" "e80a789e9d8cfb41dd87f3284b75432427c4461c1731d220d04ead8733ccdb5e"
04:29:17 <phadej> maerwald, bgamari ^ do you now what happened?
04:30:45 <maerwald> e80a789e9d8cfb41dd87f3284b75432427c4461c1731d220d04ead8733ccdb5e is the hash from https://downloads.haskell.org/~ghc/8.8.4/SHA256SUMS
04:31:36 <maerwald> so the thing you downloaded is indeed not valid
04:32:41 <Guest_39> is also says:
04:32:48 * hackage th-lego 0.1.0.4 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.1.0.4 (NikitaVolkov)
04:32:55 <Guest_39> [ Error ] Also check the logs in "/Users/Guest_39/.ghcup/logs"
04:33:29 <phadej> I downloaded the tarball and i got the same e80... hash so it's not changed on the server  :)
04:34:01 <phadej> and what the logs say? :)
04:35:07 <Guest_39> im not sure how to check the logs -_- 
04:35:09 <maerwald> Guest_39: you can try to use wget instead: ~/.ghcup/bin/ghcup --downloader wget install ghc 8.8.4
04:39:19 * hackage aeson-commit 1.0 - Parse Aeson data with commitment  https://hackage.haskell.org/package/aeson-commit-1.0 (jonascarpay)
05:16:48 * hackage aeson-commit 1.1 - Parse Aeson data with commitment  https://hackage.haskell.org/package/aeson-commit-1.1 (jonascarpay)
05:19:49 * hackage ptr-poker 0.1 - Pointer poking action construction and composition toolkit  https://hackage.haskell.org/package/ptr-poker-0.1 (NikitaVolkov)
05:22:02 <dminuoso> What am I to make of this diagnostic? https://gist.github.com/dminuoso/a1767ce83e8ff645dfdae7d29aed51e4
05:22:25 <dminuoso> That seems like a buggy GHC heuristic.
05:23:03 <dminuoso> % data Foo = Foo1 Foo1
05:23:03 <yahb> dminuoso: ; <interactive>:14:17: error:; * Data constructor `Foo1' cannot be used here (it is defined and used in the same recursive group); * In the type `Foo1'; In the definition of data constructor `Foo1'; In the data declaration for `Foo'
05:23:34 <dminuoso> This should emit: Not in scope: type constructor or class `Foo1'; Perhaps you meant `Foo' (line 15)
05:23:49 <dminuoso> Or is there some weird Haskell semantics that justify the above diagnostic?
05:26:48 <Ariakenom> tinga, maybe im misunderstanding but. "I just want to add a real 1 to a complex number" your code does that if u change the type to  "f :: RealFloat a => Complex a -> Complex a"
05:28:43 <merijn> dminuoso: heh, which GHC is that?
05:28:56 <merijn> dminuoso: eh, wait
05:29:09 <merijn> dminuoso: Is there an actual V_3GPP type anywhere?
05:29:20 <dminuoso> merijn: No, I forgot to import it.
05:29:31 <Ariakenom> but that doesnt work if u want Int in particular
05:29:37 <merijn> Do you have DataKinds enabled?
05:29:59 <dminuoso> % :set -XNoDataKinds
05:30:00 <yahb> dminuoso: 
05:30:02 <dminuoso> % data Foo = Foo1 Foo1
05:30:03 <yahb> dminuoso: ; <interactive>:17:17: error:; Not in scope: type constructor or class `Foo1'; A data constructor of that name is in scope; did you mean DataKinds?; Perhaps you meant `Foo' (line 17)
05:30:09 <dminuoso> merijn: That's it! Thanks!
05:30:10 <merijn> oom
05:30:13 <merijn> *boom
05:30:14 <dminuoso> Good catch. :)
05:30:30 <merijn> I'm a genius at debugging intuition ;)
05:30:37 <dminuoso> heh
05:30:44 <dminuoso> I mean it was obvious the moment you mentioned it
05:32:11 <dminuoso> I have a pretty cool usecase of data kinds now. :)
05:35:44 <merijn> Inscrutable errors? :p
05:40:01 <dminuoso> merijn: Nah. So I have lots of nullary sum types. To avoid name clashing, they are prefixed by the attribute name
05:40:19 <dminuoso> So I have `ASA_WebVPN_SSL_VPN_Client_Keep_Installation_Enabled` `ASA_WebVPN_Port_Forwarding_Exchange_Proxy_Enable_Enabled` etc 
05:40:29 <dminuoso> It's much easier to just say #Enabled instead. :)
05:41:24 <dminuoso> And use generated IsLabel instances
05:41:46 <AWizzArd> In Snap I can encode variable parts of a route via colon: `:id`.  Are query parameters also encoded in the route? Or are they exclusively captured via rqQueryParams?
05:41:49 <dminuoso> Or `fromLabel @"Foo-Bar"` if you dont want to use OverloadedLabels, or can it
05:41:52 <dminuoso> *or cant
05:42:22 <dminuoso> So that gives rise to some cool combinators together with the optics library
05:42:25 <dminuoso> like
05:42:52 <dminuoso> whenM (Acct_Authentic ./= #RADIUS) (...)
05:43:32 <dminuoso> Err, that should start with an understore. :)
05:43:45 <merijn> dminuoso: I'm a luddite who is still not using optics :p
05:44:25 <phadej> Kowainik :)
05:45:30 <phadej> merijn: are you using lens?
05:45:43 <merijn> phadej: I meant no optics at all
05:46:00 <merijn> regardless of package
05:46:10 <phadej> then it's fine.
05:46:29 <merijn> I mean, I think I have 5 lines of microlens to interact with persistent, but that's it :p
05:47:05 <phadej> interacting with swagger2 using OverloadedLabels and optics is very nice
05:47:22 <phadej> specifically after I fixed the VIM highlighting for overloadedlabels :)
05:47:23 <dminuoso> Indeed, we use that as well. :)
05:47:56 <merijn> phadej: Out of curiosity, are you secretly a bunch of androids who don't need sleep?
05:47:59 <dminuoso> But I didn't start optics/lens them until we started working on this SDN compiler. That project had very deeply nested data, and there were very repeating pattern themes.
05:48:22 <dminuoso> Though, I must admit, ever since I started, optics has appeared popping up in some projects here
05:48:26 <phadej> merijn: I in fact sleep 9+ hours a day
05:48:43 <merijn> phadej: At this rate you're outputting more code than edwardk >.>
05:49:09 <dminuoso> merijn: edwardk's capacitity to put out code is limited by the influx of articles on ncatlab.
05:49:28 <merijn> :p
05:50:14 <merijn> my capacity is limited by "cat petting" having priority over coding >.>
05:50:23 <dminuoso> since when do you have a cat?
05:50:38 <merijn> mid-2016?
05:51:03 <merijn> Ironically, most of my Haskell is after mid-2016
05:51:23 <merijn> OTOH, before this year I spent most of my day at work, where there's no cat... :p
05:51:33 <phadej> is your cat named Haskell
05:51:55 <phadej> or Hask
05:52:37 <merijn> Usually she just gets called panther princess :p
05:53:49 <absence> what's the right way to deal with duplicate record fields across modules? https://repl.it/repls/GruesomeTrustyLocation
05:54:25 <merijn> 1) don't have those, 2) only import them qualified, 3) some complicated mess of extensions and voodoo
05:54:59 <merijn> oh, 4) don't have record field accessors at all (not implemented yet, afaik)
05:55:44 <absence> merijn: the thing is that if i put everything in the same module, it just works, so i thought maybe i was missing something "obvious"
05:55:55 <phadej> enable DuplicateRecordFields in a module you use them too?
05:56:13 <absence> phadej: i tried that, but it doesn't make a difference unfortunately
05:56:42 <merijn> having accesors was a mistake, -XNoFieldSelectors + -XNamedFieldPuns is the way forward!
05:57:01 <merijn> (you know, once NoFieldSelectors finally ships...)
05:57:17 <phadej> also naming types.hs Types.hs will help GHC find it
05:57:25 <hpc> -XBasicallyJustRustADTs
05:58:06 <merijn> hpc: I dunno how those work? how do they differ from ADTs in haskell?
06:00:23 <hpc> mechanically they're practically the same as strict haskell would be, but that combination of extensions makes pattern matching syntax on them very similar as well
06:00:51 <tinga> Ariakenom, yes, I was imprecise, I just meant a non-complex number (add 1 to the real part) and I wanted to write a function that would work for any `a` in `Complex a`
06:01:54 <tinga> Why is it that with type classes the type restriction holds for the whole class instead of just the methods where the restriction is relevant?
06:02:13 <merijn> tinga: What do you mean?
06:03:04 <tinga> Num covers (+), (-), abs, etc., but the RealFloat restriction only exists because of `abs`.
06:03:05 <phadej> because if  you would want different restrictons, you'd rather have separate classes :)
06:03:36 <phadej> better question is "wnhy Num has abs", which has a very boring question: Because in '90s that sounded like a good idea
06:03:44 <tinga> merijn, So if I wanted to only ever use + and - from Num, the RealFloat restriction doesn't matter for me.
06:03:58 <phadej> sorry, boring answer
06:03:59 <merijn> Which RealFloat restriction?
06:04:10 <phadej> merijn: RealFloat a => Num (Complex a)
06:04:31 <merijn> ah
06:04:34 <phadej> see discussion ~100 messages prior
06:05:08 <merijn> tinga: Simple answer: because arbitrarily fine-grained splitting requires tons of manual work with very little to no pay off
06:05:17 <tinga> My question is towards: would type reasoning become impossible or computationally more complex if type classes would be "splittable" according to use,
06:05:18 <merijn> tinga: In short, nobody cares enough
06:05:44 <tinga> I mean, automatic splitting.
06:06:02 <tinga> Maybe I'm being stupid, not sure.
06:06:05 <merijn> tinga: Well, you'd first have to invent a semantics for what "splittable" even means, then you'd have to implement it, then you'd have to update all existing code
06:06:15 <merijn> tinga: Many people hate the Num hierarchy for many reasons
06:06:21 <merijn> A lot of them even valid reasons
06:06:41 <tinga> Since it would only allow more code to be valid, not restrict existing code, no code would have to be changed.
06:06:52 <phadej> bold clam
06:06:54 <phadej> claim
06:06:56 <merijn> tinga: But every proposed alternative has either required: 1) tons of extensions, 2) made code dramatically harder to understand, 3) not much practical use
06:07:17 <tinga> :) Ok, that sounds like a reasonable answer.
06:08:05 <merijn> tinga: Like, sure, Num is broken in all sorts of mathematical ways, but most of the proposed fixes are "more correct", but also 10 times more annoying to use to write, you know, actual code :)
06:08:36 <tinga> Is there a somewhat widely accepted alternative for Num ?
06:08:43 <merijn> No
06:08:55 <merijn> There's about 20 *not* widely accepted alternatives, though!
06:09:22 <merijn> All they cost you is "all interoperability with the rest of Hackage" ;)
06:13:36 <kuribas> merijn: there is the purescript type class hierarchy
06:13:43 <phadej> I don't think anyone tried hard enough to satisfy "algebraists" and "float-pointers" at the same time
06:13:59 <phadej> kuribas: purescript hierarchy lies about floats :)
06:14:43 <kuribas> https://pursuit.purescript.org/packages/purescript-numerics/0.1.2/docs/Data.Num
06:16:02 <phadej> as concrete example, IMO having CommutativeRing like no-members but extra laws class is antipattern in Haskell (and fwiw in PS as well)
06:16:27 <phadej> if you want to have such, you would need to have a member which has extra laws attached to it
06:16:34 <phadej> e.g. + is commutative and .+ isn't
06:16:58 <phadej> ... and we can debate whether that or single + is better to the end of the universe :)
06:20:48 <dminuoso> kuribas: You asked why no newtype around Int, because not all integers are permissable.
06:21:09 <dminuoso> But to be perfectly blunt, the vendor who was responsible for this is an idiot, as integer would have been the right thing here.
06:22:42 <kuribas> dminuoso: newtype with smart constructor?
06:29:04 <Ariakenom> > [0.5, 1.5 .. 2] -- we hating on numbers?
06:29:07 <lambdabot>  [0.5,1.5,2.5]
06:29:21 <merijn> the Enum instance for Float and Double can go die in a fire
06:29:23 <merijn> Stupid ass idea
07:01:36 <zwarag> I'm looking for a `[Int] -> String` which would: `[1,2,3] -> '[1,2,3]'`. According to the following Link `intsToDigits` should do that but I might confuse something :https://hackage.haskell.org/package/percent-format-0.0.1/docs/Text-PercentFormat-Utils.html#v:intsToDigits 
07:02:22 <Taneb> > show [1, 2, 3]
07:02:24 <[exa]> zwarag: why not just combine show and reverse?
07:02:25 <lambdabot>  "[1,2,3]"
07:03:43 <[exa]> zwarag: or perhaps `intercalate`, if you want to do it extra manually
07:04:59 <zwarag> My function actually is: `testFactorize x l = it (printf "factors of %d should be %s", x l ) $ l == factorize x`  where x is 10 and l is [1,2,5,10]    printf is from `import Text.Printf (printf)`
07:05:47 <merijn> zwarag: Presumably that should be "show l"?
07:06:23 <dminuoso> kuribas: 2000 smart constructors? What's the benefit here? And how are you gonna pattern match against smart constructors?
07:06:39 <kuribas> dminuoso: a single one of course :)
07:06:48 <dminuoso> well at any case
07:07:04 <dminuoso> The ADT is gonna stay! :P
07:08:51 <zwarag> mhmm, I cannot figure out how to do `show l` right. I get this syntax error: https://imgur.com/a/fqpkkeS
07:09:32 <[exa]> can you please use pastebin for text?
07:10:50 <zwarag> sure. https://pastebin.com/gBzTdsH1
07:11:27 <dminuoso> zwarag: You probably want to invoke that as `it (printf "..." x (show l)) $ ...
07:11:48 <zwarag> here is also Factorize.hs if it is needed: https://pastebin.com/StUee5Da
07:12:49 * hackage flashblast 0.0.1.0 - Generate lanuage learning flashcards from video.  https://hackage.haskell.org/package/flashblast-0.0.1.0 (locallycompact)
07:12:57 <zwarag> dminuoso: I did try that, but I still get an error: https://imgur.com/a/pkUXthG
07:13:11 <dminuoso> Can you please not use imgur to share textual information?
07:13:22 <dminuoso> Also, that looks unchanged.
07:13:40 <dminuoso> zwarag: essentially, the comma is out of place.
07:13:52 <dminuoso> It doesnt do what you think it does.
07:14:35 <zwarag> ahh now I see. Thank you dminuoso. Is it better/preferred  to post errors in pastebin too?
07:15:16 <dminuoso> Yes. 
07:15:37 <dminuoso> You can use tools such as https://paste.tomsmeding.com/ that allow you to submit multiple files.
07:15:57 <dminuoso> that way you can split code and GHC output, or other data, into separate blocks that can be syntax highlighted appropriately
07:17:28 <AWizzArd> io-streams. When I have an `InputStream ByteString` and want to read JSON objects out of it, how should I do it? Will I have to read byte-wise from this stream and check when a closing `}` is found?
07:31:50 * hackage haskellish 0.2.3.1 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.2.3.1 (dktr0)
08:04:53 <dminuoso> lens/optics question: I have some [(10,Just "abc"), (20, Just "cde"), (30, Nothing)] -- is there a way to take some `each . _Just . each` and combine it with the Int in the tuple as its "Ix"?
08:05:38 <phadej> what you mean by combine
08:06:13 <dminuoso> So I want to fold over each character, while having access to the number.
08:06:15 <dminuoso> Sort of like
08:06:27 <dminuoso> Fold [(Int, Maybe String)] (Int, Char)
08:06:29 <phadej> :t <.
08:06:30 <lambdabot> error: parse error on input ‘<.’
08:06:35 <phadej> :t (<.)
08:06:37 <lambdabot> Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
08:06:43 <phadej> lookup it on lens docs
08:07:05 <dminuoso> phadej: That's spot on! Thanks. :)
08:12:52 <ixlun> Ugh, got disconnected... did my previous question get through?
08:14:26 <monochrom> I think no.
08:14:28 <tomsmeding> ixlun: https://ircbrowse.tomsmeding.com/browse/haskell?events_page=656
08:16:13 <ixlun> Ah, I shall ask again in that case: I was just wondering if anyone knew if there was a way to kill a haskell thread off that was in the middle of a long pure computation?
08:16:25 <merijn> ixlun: Did you create the thread?
08:16:31 <ixlun> Yes
08:16:36 <ixlun> I've tried killThread
08:16:44 <merijn> That doesn't work?
08:17:05 <ixlun> It does but after a significant delay
08:17:35 <ixlun> (although what is strange is that the whole program terminates with SIGKILL)
08:17:40 <merijn> I dunno when async exceptions are checked/handled. Naively I'd guess like pre-emption at GC time
08:18:05 <ixlun> I was wondering if they could only 
08:18:21 <ixlun> only be handled in between IO actions
08:18:33 <merijn> So if you have a tight pure loop that doesn't allocate much, that could take some time
08:18:42 <ixlun> My only other thought was to pepper my pure computation with `yield' but I don't really like that solution
08:18:52 <monochrom> No other way. Short story: Think of cooperative multitasking but automatic insertion of yield points at heap allocation points.
08:18:58 <merijn> ixlun: Oh, wait
08:19:03 <merijn> ixlun: Is this the single-threaded runtime?
08:19:07 <ixlun> Yes
08:19:14 <merijn> Try the multithreaded one
08:19:28 <Ariakenom> async exceptions are checked when allocating
08:19:37 <ixlun> How do I do that, use forkOS rather than forkIO?
08:19:39 <merijn> Sounds like the 1 thread is taking a long time to yield, so the killThread just doesn't get thrown until way later :p
08:19:46 <merijn> ixlun: No, it's a compiletime flag
08:19:52 <monochrom> No, use "ghc ... -threaded ..."
08:19:54 <merijn> ixlun: Use "ghc -threaded"
08:20:07 <merijn> (and run with "+RTS -N2")
08:20:12 <monochrom> forkOS is an orthogonal concern.
08:20:40 <merijn> ixlun: The default runtime only runs one OS thread of Haskell code, regardless of how many forkIO threads you have
08:21:01 <merijn> ixlun: -threaded lets you use multiple OS threads in parallel to run forkIO threads simultaneously
08:21:21 <merijn> (if you use "+RTS -N2" to actually run it with 2 OS threads, that is)
08:21:22 <Ariakenom> with -fno-omit-yields the checks are more often. every function call perhaps
08:21:25 <Ariakenom> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--fomit-yields
08:24:41 <hyperisco> I need to take template files, instantiate variables, and evaluate… any template language with conditionals will do. Suggestions?
08:25:37 <ixlun> Hmm, both of those solutions didn't seem to work unfortunetly :-(
08:26:12 <hyperisco> https://hackage.haskell.org/package/doctemplates looks promising
08:26:22 <tomsmeding> hyperisco: mustache has is-not-null conditionals
08:26:52 <hyperisco> am looking for equality at least on integers
08:27:13 <hyperisco> well I guess I can do is-not-null and just set variables carefully :P
08:28:18 <ixlun> Here is the code in question: https://pastebin.com/wfnsY3pC
08:29:46 <ixlun> `search' is the long operation
08:30:28 <ixlun> thing is. it's not a particularly tight loop either... it's expanding a game tree to depth n... there will be plenty of allocs happening
08:48:49 * hackage byteslice 0.2.4.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.2.4.0 (andrewthad)
08:57:39 <monochrom> Interesting, https://github.com/folidota/GSoC2020  (they only did multiple polynomial quadratic sieve)
09:12:50 * hackage launchdarkly-server-sdk 2.0.2 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-2.0.2 (launchdarkly)
09:13:50 * hackage ptr-poker 0.1.1 - Pointer poking action construction and composition toolkit  https://hackage.haskell.org/package/ptr-poker-0.1.1 (NikitaVolkov)
09:16:19 * hackage stack 2.5.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-2.5.1 (borsboom)
09:36:55 <monochrom> \∩/ tomsmeding's pastebin is in Haskell Weekly News's Show & Tell
09:37:11 <tomsmeding> \o/
09:37:12 <monochrom> and the new ircbrowse too
09:41:12 <Uniaika> \o/
09:41:23 <Uniaika> Taylor is amongst us!
09:45:59 <AWizzArd> I have a ByteString with possibly incorrect JSON, but I want to read as much out of it as possible.   ["{'a':1}", ",{'b':1}", ",{'c':1}", ",{'d'       this should give me a, b and c,  and let me know at which position no correct parsing was possible anymore. Any suggestion?
09:46:59 <phadej> if using unreleased libraries is fine, then https://github.com/phadej/saison can give you the prefix
09:47:26 <phadej> (you'll get a structured stream of tokens with error lingering at the end)
09:48:04 <phadej> but IIRC I don't count bytes, so you don't get absolute position of error
09:49:11 <AWizzArd> phadej: I might be able to re-construct this.
09:49:59 <AWizzArd> phadej: the highlevel goal here is to have a route in Snap that may receive some gigabytes of json objects {} inside a list. I want to insert them into my DB without needing 256 GB of RAM.
09:50:16 <phadej> that's the use case for saison, yes.
09:50:20 <phadej> it's a streaming parser
09:50:45 <AWizzArd> phadej: so currently I read chunks from the InputStream and with those resulting (smallish) ByteStrings I wanna see what I’ve got so far.
09:50:47 <phadej> but I hadn't time (or need) to polish it beyond basic PoC
09:50:54 <AWizzArd> phadej: good, so I can have a look.
09:51:09 <phadej> hmm, and in fact, I don't have "feed me more input" system either
09:51:15 <phadej> so there's a lot to do :)
09:51:41 <phadej> I have an employer though :)
09:51:52 <phadej> (who likes when people need unwritten Haskell code!)
09:52:00 <phadej> yet*
09:52:35 <AWizzArd> (:
09:58:49 * hackage clckwrks 0.26.2.2 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.26.2.2 (JeremyShaw)
10:38:25 <yushyin> https://twitter.com/_julesh_/status/1316756695440293888 :)
10:38:54 <monochrom> haha
10:39:56 <monochrom> titForTatState
10:45:53 <int-e> wild arrows
10:50:19 * hackage flashblast 0.0.1.1 - Generate language learning flashcards from video.  https://hackage.haskell.org/package/flashblast-0.0.1.1 (locallycompact)
10:59:50 * hackage lsp-types 1.0.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/lsp-types-1.0.0.0 (luke_)
11:00:49 * hackage lsp 1.0.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/lsp-1.0.0.0 (luke_)
11:13:49 * hackage stm-incremental 0.1.0.2 - A library for constructing incremental computations  https://hackage.haskell.org/package/stm-incremental-0.1.0.2 (sgschlesinger)
11:17:21 <larou> ok, i think the thing with cycles can be possible
11:17:41 <larou> i think basically the problem is encoding at type level "where a datatype originates"
11:17:59 <larou> so that you can constrain it to be "the one above" in a recursive datatype
11:18:06 <larou> to establish a backwards link
11:18:19 <larou> i think this can be done with "a let binding class"
11:18:36 <larou> that, by class instance uniqueness, is guarantied to be only one
11:19:04 <larou> then you impose the "where it originates" as a constraint, which is parametric over this position in code
11:19:14 <larou> right?
11:20:37 <johnw> how do you specify "position in the code"?
11:26:39 <jsynacek> Hi! I'm having a problem understanding State and >>= together.
11:26:44 <jsynacek> I have this: foo :: State Int [Int]
11:26:48 <jsynacek> foo = get >>= \s -> pure [s+10] >>= \s' -> pure $ s' ++ [7,8,9]
11:27:15 <jsynacek> Can anyone please explain to me how the s' suddenly changes from Int to [Int]? I can't figure it out.
11:27:35 <jsynacek> I mean it's still supposed to be of the same type as the state, right?
11:28:35 <jsynacek> So I would suppose that s and s' should both be Int. But s is Int and s' is [Int].
11:28:35 <verement> :t \s -> pure [s+10]
11:28:37 <lambdabot> (Applicative f, Num a) => a -> f [a]
11:29:45 <monochrom> I don't understand the "change" mental model. There is no change.
11:30:21 <monochrom> "pure x >>= \y -> ..." necessarily satisfies y=x therefore y has the same type as x.
11:30:40 <larou> johnw: it would be some arbitrary label, probably a Symbol, to accompany the instance - that way allowing many such instances, that otherwise would clash
11:30:41 <monochrom> Oh, x is a list this time? Then it is a list this time.
11:30:41 <dolio> You named the variables to confuse yourself. :)
11:31:26 <johnw> larou: I suppose if you used a Nat and yourself ensured monotonicity, you could impose a type-level ordering constraint
11:31:32 <larou> then you would have the downstream reference constrained to reference the corresponding label 
11:31:49 <larou> johnw: hmm, good idea
11:32:18 <larou> maybe that aswell as a label 
11:32:44 <larou> otherwise you would only be able to make one value of the datatype
11:33:05 <larou> or, have to use arbitrarily large first Nat for all the subsequent values 
11:33:30 <geekosaur> jsynacek, note that the only thing that does anything with the state is the `get`; you then produce a list, and then consume a list, and produce another list, carrying the state along without touching it
11:33:44 <larou> or maybe not a Nat
11:33:49 <larou> but like f ()
11:33:54 <larou> for the linked container f
11:34:12 <larou> like, if it were a doubly linked list, a Nat would be ok - but not if it were a tree
11:34:24 <larou> erm, a pointer on (f ())
11:34:44 <jsynacek> geekosaur: Yes, that's it. I totally confused myself.
11:34:50 <jsynacek> geekosaur++
11:35:01 <larou> so the "name" label, has to be the same for every constructor used sequentially to construct the container 
11:35:17 <larou> they are all just different bits of the "same container" 
11:35:42 <larou> and the pointer to the position of the part being referenced would be like the Nat
11:35:54 <larou> not sure how your monotonicity constraint works then..
11:36:26 <larou> i think the doubly linked list example has "the immediately preceding value" expressed via the constraint
11:36:43 <larou> not anything less than the current index
11:37:00 <larou> or did you mean monotinic position, like successive "forwards" positions of a zipper?
11:37:26 <larou> indexing at type level *each* of the positions, not just the cyclic references
11:37:28 <hyperisco> so with the Haskell VSCode extension... 1) any way to insert a suitable import given an identifier? 2) any way to have ctrl+shift+b build the project?
11:38:07 <hyperisco> so far the error underlining hasn't exploded so that is progress
11:38:19 <larou> i guess then you would have something like a tree zipper, and the constraint would be that you would only be able to navigate down and forwards, not upwards and backwards... thats kind of like the ordering of a Nat...
11:39:23 <hyperisco> I hate knowing a name like  getArgs  but not knowing what module it is in
11:39:28 <hyperisco> if the IDE could help me with that it would be a godsend
11:41:27 <monochrom> Tranditionally, people install hoogle locally for that. They probably also get their IDEs to call hoogle.
11:41:49 <jsynacek> hyperisco: vscode has a feature called Tasks. You can use it to run 'cabal build' on ctrl+shift+b.
11:41:58 <monochrom> Me, I just crack open a web browser tab and use the haddock index.
11:42:36 <jsynacek> hyperisco: Check out https://code.visualstudio.com/docs/editor/tasks#vscode
11:42:59 <hyperisco> monochrom, when you have to import hundreds of things a day that adds up hugely
11:43:43 <hyperisco> jsynacek, okay thanks
11:44:02 <hyperisco> how about tabs… I have VSCode set to width 2 but for whatever reason in .hs files it is back to 4
11:47:26 <hyperisco> just need a file-extension-specific override... okay
11:47:49 * hackage implicit-hie 0.1.2.0 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.2.0 (Avi_Dessauer)
11:51:30 <hyperisco> would be nice if you could get the type of a term
11:51:46 <hyperisco> seems you can only get types for imported names
11:52:16 <hyperisco> oh nvm it is working now... now I just wish there was a hotkey instead of hovering
11:52:24 <hyperisco> because going to the mouse is no good
11:53:49 <hyperisco> apparently is a vscode thing if you do ctrl+k+i ... hope this helps someone
11:55:14 <hyperisco> oh damnnnnnn it will auto import names
11:56:35 <hyperisco> ctrl+. while cursored on the name... gives several import options
11:57:02 <hyperisco> Haskell officially has good IDE support in my eyes… well done. where do I insert my money?
11:57:31 <larou> i guess the problem would then be that every version of the container would still have this label 
11:57:51 <larou> maybe a synonym with a quantification would allow it to be polymorphic in this label 
11:58:33 <larou> well, this is why it was called a "Let" class anyway, so that it binds the "name of the value" as a type parameter 
11:58:57 <larou> then you can at least constrain the cyclic references to be to the same container
11:59:07 <larou> but im not sure what would happen when modifying it
11:59:23 <larou> like, i guess you would have to give it a new type label and Let instance
11:59:29 <larou> this seems impossible
11:59:51 <larou> its these kind of considerations that makes it seem like it would be better as a language feature than as a library
12:00:22 <larou> you would have all the knot tying stuff being done under the hood then too
12:09:19 * hackage git-brunch 1.4.2.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.4.2.0 (andys8)
12:10:48 <larou> anyway, having all the tails as different Let instances seems basically impossible to write!
12:11:08 <larou> i guess there is some reflection/local instances magic that could take care of that
12:11:28 <larou> but i dont think you can use implicit params in the same way as actual classes
12:11:39 <larou> seems like a total madness tbh
12:56:50 <monochrom> I solved the keyboard-mouse dilemma by Logitech K400 Plus: keyboard - numpad + touchpad
12:57:50 <monochrom> Actually to a large extent, even a real mouse is much closer to the keyboard if you just get rid of the numpad.
12:58:54 <monochrom> I also have a friend who put the mouse on the left and trained himself to use his left hand for the mouse. Because again it is then close to the keyboard.
12:59:04 <dminuoso> monochrom: I know some people like to use it for their apple tv
12:59:23 <larou> monochrom: was he in a really cramped cubicle or something?
12:59:30 <monochrom> Numpad standing in the way is the #1 cause of programmer hand injuries.
12:59:42 <monochrom> No.
12:59:49 * hackage mattermost-api 50200.9.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.9.0 (JonathanDaugherty)
13:00:48 * hackage mattermost-api-qc 50200.9.0 - QuickCheck instances for the Mattermost client API library  https://hackage.haskell.org/package/mattermost-api-qc-50200.9.0 (JonathanDaugherty)
13:01:19 <larou> anyone want to try to see if this idea of Let bound reification for cycles?
13:01:27 <monochrom> No.
13:01:42 <larou> literally, nobody
13:01:50 * hackage matterhorn 50200.11.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.11.0 (JonathanDaugherty)
13:01:50 * hackage citeproc 0.1.0.2 - Generates citations and bibliography from CSL styles.  https://hackage.haskell.org/package/citeproc-0.1.0.2 (JohnMacFarlane)
13:02:49 <larou> *and all the programmers did become woefull, and the sky did fall*
13:03:15 <monochrom> Yeah dminuoso, K400 really had smart TV browsing in mind, the design and the marketting shows.
13:04:17 <larou> voice activated?
13:04:53 <monochrom> I decided that I am not picky with key tactile or how big the backspace is etc, so I took it for PC and laptop-when-at-home. And I also caught it at a discounted price. This was like 10-15 years ago.
13:05:02 <larou> "hey TV - motivate finance" 
13:06:13 <larou> monochrom: this is the problem... at least when people are commuting, they have such a distressing morning that they are happy to be in their offices 
13:06:19 <monochrom> Anyway, obHaskell, I have been reading "practical type inference for arbitrary-rank types" recently. It's pretty neat. (in preparation for reading "a quick look at impredicativity".)
13:07:17 <geekosaur> "motivate finance"? that sounds more like an hledger-motivate package than a keyboard feature to me
13:07:22 <larou> do any other languages even have arbitrary rank types?
13:07:32 <monochrom> Also, today's HWN lists https://generics.jasperwoudenberg.com/ which helps learning GHC.Generics.
13:08:22 <monochrom> Dynamically typed languages have dependent rank-n types. Change my mind.
13:08:42 <larou> dynamically or dependently? 
13:08:53 <monochrom> yes.
13:10:05 <monochrom> Clearly, C has rank-n types too, just not very polymorphic; and without local functions, not a lot of use cases.
13:10:15 <larou> anyway, i think if i managed to show the idea working it would be easier to convince the GHC people to make a language extension 
13:10:33 <larou> or another language that compiles to haskell or something
13:10:52 <larou> because whatever it ends up as, its not going to be legible
13:11:14 <larou> all constraint continuations everywhere
13:11:21 <larou> the worst...
13:12:22 <larou> like, with this "Let" uniqueness, i think i can use params in the GADT definition to explicate the cycles 
13:13:20 * hackage Z-Data 0.1.7.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.7.0 (winterland)
13:14:19 * hackage numhask-free 0.0.1 - See readme.md  https://hackage.haskell.org/package/numhask-free-0.0.1 (tonyday567)
13:15:57 <dolio> monochrom: It's a waste of time to try to change the mind of anyone who would say something like that. :)
13:25:07 <maerwald> he was right about commuting though
13:37:05 <maerwald> it's quite stressful, especially for an introvert haskeller
13:48:49 <dolio> maerwald: I mean saying, "... dependent rank-n types, change my mind."
13:49:59 <dolio> You can probably shorted it to just the last part.
13:54:24 <monochrom> dolio: Haha yeah. No worries, I was joking.
13:54:58 <monochrom> wait, what commuting?
14:27:37 <koz_> I have a data type Foo, and wanna write a ... whatever you call it that allows a user to create values of Foo with a TH splice.
14:27:48 <koz_> What do I need to read to understand how that works?
14:27:56 <koz_> (quasi-quotation?)
14:30:35 <monochrom> Do you mean the [e| ... ] one? The $(...) one?
14:31:26 <koz_> monochrom: Yeah, the [e|...] one. Like the one inline-c uses?
14:31:39 <monochrom> Or neither, instead a function f :: X -> Q Exp so your users can write $(f ...) ?
14:32:09 <koz_> The [e| ... ] one is what I was after.
14:32:18 <koz_> Dunno proper way to name it, or how to define my own... well, e.
14:33:05 <monochrom> You cannot define your own e. Even though quasi quotation uses a similar syntax [ your_function_name | ... ]
14:33:25 <koz_> OK, I'm clearly missing something here.
14:33:33 <monochrom> However, if you write [e|...], the type is Q Exp
14:33:38 <koz_> Ah.
14:34:00 <koz_> I want the [ your_function_name | ... ] syntax, but dunno how to write the your_function_name in question.
14:37:01 <koz_> Do I just need to write something like foo :: QuasiQuoter (plus definition) or something?
14:37:12 <koz_> And then folks can use [ foo | ... ]?
14:39:58 <koz_> Sorry, [foo| ... |].
14:41:36 <monochrom> So I think I ended up learning from just the user guide and the Language.Haskell.TH.* doc.  Although the user guide used to refer to a haskellwiki page, which in turn also refer to a paper, I found the haskellwiki example too steep, and the paper, well, the user guide already points out that the paper is outdated.
14:41:55 <koz_> monochrom: OK, I think I have enough to go on.
14:42:35 <koz_> What would I use to signal a (compile-time, I assume?) error in TH? I need to fill in the fields of QuasiQuoter corresponding to inappropriate contexts with errors, as per the docs.
14:42:53 <monochrom> And of course, the user guide is too brief, and the Language.Haskell.TH.* doc too reference material. So I learned by trial and error.
14:43:48 <monochrom> For [foo|...] you write foo :: QuasiQuoter, yeah.
14:44:19 * hackage katip-datadog 0.2.0.0 - Datadog scribe for the Katip logging framework  https://hackage.haskell.org/package/katip-datadog-0.2.0.0 (MichaelXavier)
14:46:27 <monochrom> Maybe Q being an instance of MonadFail helps the static error message.
14:46:50 <koz_> So just use fail "Error message goes here"?
14:46:58 <monochrom> Oh, there are also reportError etc right at the beginning of the Language.Haskell.TH
14:47:21 <monochrom> (well, after the long TOC)
14:47:42 <monochrom> Haha "Report an error to the user, but allow the current splice's computation to carry on. To abort the computation, use fail."
14:47:49 * hackage katip-elasticsearch 0.7.0.0 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.7.0.0 (MichaelXavier)
14:47:51 <koz_> So, fail's the way, got it.
14:49:19 * hackage jsonifier 0.1 - Fast and simple JSON encoding toolkit  https://hackage.haskell.org/package/jsonifier-0.1 (NikitaVolkov)
14:51:49 * hackage jsonifier 0.1.0.1 - Fast and simple JSON encoding toolkit  https://hackage.haskell.org/package/jsonifier-0.1.0.1 (NikitaVolkov)
14:54:41 <monochrom> I think TH ends up being one of those things that look like intimidating to learn because there are a lot of things, e.g., Language.Haskell.TH.Syntax is very long and detailed and comprehensive, but it turns out for 90% of use cases you only need to learn 10% of it.
14:55:59 <monochrom> For example, you can ignore all of Language.Haskell.TH.Syntax because you will just need to write [e| $(x) + 1|] instead of meticulously building the AST.
14:58:24 <monochrom> So the only things you really need to know are: There are Q Exp, Q [Dec], etc; Q is MonadIO, so you can always go liftIO (putStrLn "We thank our sponsor NordVPN. Do you need a VPN? ..."); how to prevent variable capture; how to deliberately cause variable capture.
15:00:05 <monochrom> And TH's notion of declaration groups --- this affects visibility.
15:07:44 <int-e> monochrom: that's so triggering
15:08:23 <int-e> (the string literal, I mean)
15:13:50 * hackage jsonifier 0.1.0.2 - Fast and simple JSON encoding toolkit  https://hackage.haskell.org/package/jsonifier-0.1.0.2 (NikitaVolkov)
15:19:41 <koz_> monochrom: ROFL
15:19:48 <koz_> NordVPN - now in your compile-time.
15:20:33 <monochrom> Generally the proliferation of ad blurbs in all things free of charge.
15:26:25 <koz_> If I need to construct an application of a data constructor in an Exp, what do I put in the first argument of AppE?
15:26:43 <koz_> (I assume I need AppE [data constructor goes here] [arguments to it go here]?)
15:28:29 <koz_> Would that be a VarE?
15:30:20 <int-e> koz_: `AppE` is function application on an expression level.
15:31:07 <koz_> I need to construct the equivalent of 'Foo x y z', where 'data Foo = Foo Int String Float'. So how would I build that?
15:31:09 <monochrom> ConE may help
15:31:24 <int-e> if you have `A x y`, that'll be something like AppE (AppE (ConE nameA) (VarE nameX)) (VarE nameY). Which looks better if you use `AppE` as an infix operator, and probably least confusing if you use `appsE`, which takes a list.
15:31:43 <koz_> Ah, I see. Con == constructor?
15:31:55 <monochrom> Yeah, like that, be aware of (((Foo x) y) ... ad infinitum)
15:31:57 <int-e> the latter would be  appsE [ConE nameA, VarE nameX, VarE nameY]
15:32:14 <monochrom> This is why usually [e| Foo ... |] is better.
15:32:27 <monochrom> as in, better for your sanity and hair. :)
15:32:31 <koz_> monochrom: Oh wait, I can do that? Nice.
15:33:27 <int-e> monochrom: please tell us more about those sanity and hair things
15:33:47 <monochrom> Oh, appsE make it easier, that's nice.
15:34:30 <monochrom> But still, handcoding the structure of the AST is very tedious. Too many nitpicking details to watch out for. You have to think like the compiler.
15:35:02 <int-e> But absolutely, use a TH quotation when possible.
15:35:14 <koz_> Noted.
15:35:16 <monochrom> well, "compiler" is broad. You have to think like a Haskell parser.
15:39:41 <monochrom> The downside of [e|Foo x y z|] is of course, as usual, does that "Foo" really refer to the Foo you intend? Similarly for x, y, z. And variable capture issues, etc.
15:40:01 <koz_> monochrom: Whoo, such fun.
15:46:50 * hackage churros 0.1.2.0 - Channel/Arrow based streaming computation library.  https://hackage.haskell.org/package/churros-0.1.2.0 (LyndonMaydwell)
16:28:45 <koz_> Is (:::) a valid name for an infix operator?
16:29:03 <hpc> :t (:::)
16:29:04 <lambdabot> error: Data constructor not in scope: :::
16:29:15 <hpc> it's a valid name for an infix data constructor
16:29:21 <koz_> hpc: What about an infix function?
16:29:25 <hpc> nope
16:29:28 <hpc> ':' is uppercase
16:29:29 <hpc> :D
16:29:37 <ghoulguy> constructors can be functions
16:29:41 <Axman6> because ; is lowercase =)
16:29:41 <monochrom> Since it starts with : it has to stay as a data constructor.
16:29:48 <koz_> Aww.
16:29:50 <hpc> ghoulguy: shush :P
16:30:05 <Axman6> ; is already a function though, it's (>>=) :P
16:30:13 <koz_> Axman6: Rofl.
16:36:47 <monochrom> May I talk you into ∷:
16:36:55 <koz_> monochrom: 
16:36:59 <koz_> LOL
16:37:33 <monochrom> U+2237 then colon
16:37:49 <justsomeguy> seems to be the proportion symbol
16:37:56 <monochrom> yeah
16:38:19 <Cale> ⣶
16:38:33 <justsomeguy> Dominoes or braille?
16:38:43 <Cale> braille
16:40:40 * justsomeguy has always thought it would be cool to have a colorscheme + font that de-emphasizes punctuation, makes ::: a ligature, and emboldens names.
16:40:48 <justsomeguy> ::, even
16:41:42 <koz_> I can write 'foo . bar . baz $ quux'. Suppose I wanted to do the same with (>>>): '_ quux >>> baz >>> bar >>> foo'. What goes in _?
16:43:19 <justsomeguy> Maybe “Data.Function.&”?
16:43:32 <koz_> :t (&)
16:43:34 <lambdabot> a -> (a -> b) -> b
16:43:48 <justsomeguy> It's like the reverse of “($)”.
16:44:03 <justsomeguy> It's... also just my wild guess.
16:44:42 <koz_> Can confirm it is not that, justsomeguy.
16:44:51 <koz_> Someone told me this here a while ago, but I have since forgotten.
16:45:03 <justsomeguy> Sorry ^_^; I tried.
16:46:12 <monochrom> x & f >>> g >>> h
16:46:25 <monochrom> I haven't checked precedence though.
16:46:36 <nshepperd2> % :i &
16:46:37 <yahb> nshepperd2: (&) :: a -> (a -> b) -> b -- Defined in `Data.Function'; infixl 1 &
16:46:42 <nshepperd2> % :i >>>
16:46:42 <yahb> nshepperd2: (>>>) :: forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c -- Defined in `Control.Category'; infixr 1 >>>
16:46:51 <nshepperd2> unfortunate
16:47:03 <koz_> monochrom: Yep, they're both infix 1, though with different associativity.
16:56:43 <OmegaDoug> With megaparsec, how can I parse just three digits? I want to parse "123.123" and believe I should be able to capture the first three digits using "fstThree <- count 3 L.decimal" but that produces the error "unexpected end of input"
16:57:31 <{abby}> decimal is a number, for a digit you want digitChar
16:58:44 <OmegaDoug> {abby} That was exactly it. Thanks.
17:03:02 <dsal> is `count` just `replicateM`?
17:03:19 <koz_> :t count
17:03:20 <lambdabot> error:
17:03:20 <lambdabot>     • Variable not in scope: count
17:03:21 <lambdabot>     • Perhaps you meant one of these:
17:42:49 * hackage refinery 0.3.0.0 - Toolkit for building proof automation systems  https://hackage.haskell.org/package/refinery-0.3.0.0 (ReedMullanix)
18:30:15 <crestfallen> hi in line 29 we have do {ma <- mma; ma}   so this behaves like bind, but there is no indication of (>>= id) . Does that work solely on how mma and ma are named in " mma <- ma "      ?     https://github.com/varreli/haskell/blob/master/monads/joinBind.txt     
18:34:11 <crestfallen> correction {ma <- mma}
18:34:33 <koz_> crestfallen: If you look right above, it explains how bind relates to join. Then, you can read about do-notation to see how it desugars into bind.
18:34:40 <Axman6> I don't understand the quetion, but the names don't matter at all
18:34:54 <koz_> Literally look up the desugaring of do-notation, and rewrite that example with explicit use of return and bind.
18:34:59 <koz_> It'll be quite enlightening.
18:35:18 <Axman6> m do {ma <- mma; ma} becomes mma >>= \ma -> ma, aka mma >>= id
18:35:40 <koz_> Axman6: So much mixed martial arts. :P
18:39:23 <crestfallen> koz_: Axman6: all do notation desugars into bind?
18:39:30 <koz_> crestfallen: Yes, and return.
18:39:49 <crestfallen> hold on please, not what I believed..
18:40:50 <crestfallen> I understand well the unification above you pointed out koz_ .
18:41:41 <crestfallen> ...
18:43:52 <crestfallen> so if you have it looking like this:
18:44:18 <crestfallen> (>>=) (Just (Just 5)) id
18:45:08 <koz_> > Just (Just 5) >>= id
18:45:10 <lambdabot>  Just 5
18:45:44 <Axman6> > Just (Just 5) >>= \just5 -> just5
18:45:46 <lambdabot>  Just 5
18:46:16 <koz_> Axman6: Are you Just-ice? :P
18:46:39 <crestfallen> so does id apply to the first Just in (Just (Just 5)) ?
18:46:50 <crestfallen> and take it away?
18:47:17 <koz_> crestfallen: Let's look at the type of bind.
18:47:24 <koz_> :t (>>=)
18:47:24 <crestfallen> Axman6: that is very interesting: \just5 -> just5 *IS* id , right?
18:47:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:47:43 <koz_> Now, consider the case we were just looking at - what is 'm' here?
18:47:44 <Axman6> Just a >>= f = f a; Nothing >>= _ = Nothing
18:47:59 <koz_> (namely, 'Just (Just 5) >>= id')
18:48:42 <crestfallen> 'm' here is Just
18:49:09 <koz_> crestfallen: Incorrect.
18:49:29 <koz_> You're mixing type and value level.
18:49:39 <koz_> Try again, and think about it carefully.
18:51:11 <koz_> base-4.10 is GHC-8.what?
18:51:18 <crestfallen> oh yeah ok so...
18:52:55 <crestfallen> so in Axman6 's example, 'a' is (Just a) ; it
18:53:07 <Axman6> yep
18:53:10 <crestfallen> it's the inner Just
18:53:18 <Axman6> uh, which example
18:53:35 <crestfallen> Just a >>= f = f a
18:53:42 <Axman6> Just a >>= f = f a; Nothing >>= _ = Nothing  is the definition of (>>=) for Maybe
18:54:03 <crestfallen> so id is applied to the inner (Just a) 
18:54:12 <Axman6> yep
18:55:42 <crestfallen> so Axman6 koz_ when you used this lambda notation Just (Just 5) >>= \just5 -> just5  ...
18:56:00 <koz_> \just5 -> just5 is alpha-equivalent to id.
18:56:16 <koz_> As is \foo -> foo, \bar -> bar, \koz -> koz, etc etc etc.
18:56:29 <crestfallen> that is very interesting. I mean, I know that, but seeing that is awesome.
18:57:35 <crestfallen> so id is not applied to the outer 'container', only Just a, the inner container.
18:58:14 <crestfallen> thanks kindly, today is a success koz_ Axman6 
18:58:37 <koz_> crestfallen: I was leading you there, but yeah. It's _very_ key that you follow the types.
18:58:47 <koz_> This can sometimes mean by-hand substitutions to get what's going on.
18:58:55 <koz_> I do it all the time, and it's actually quite enlightening.
19:00:05 <crestfallen> koz_: yeah thanks. the unification of (>>=) and id , I fully get type-wise. sometimes when I try to visualize function application in the implementation, I visualize it differently from how I understand the types.
19:00:47 <crestfallen> by-hand substitutions I really enjoy koz_ 
19:01:00 <koz_> I actually had to do this recently to get myself out of CPS hell.
19:01:03 <koz_> (at Real Job)
19:02:13 <crestfallen> koz_: you said to literally look up ...
19:02:32 <crestfallen> dang it irssi won't give me scrollback!
19:02:58 <koz_> crestfallen: Yep, in the sense of 'in the thing you pasted'.
19:03:56 <crestfallen> <koz_> Literally look up the desugaring of do-notation, and rewrite that example with explicit use of return and bind.
19:04:07 <koz_> Oh, in that sense.
19:04:24 <koz_> Then I meant 'investigate' or 'find reference materials on'.
19:04:30 <koz_> In the 'look up X in the dictionary' use.
19:05:38 <crestfallen> yeah, you see I thought {ma <- mma; ma} was somehow knowing how to strip off the outer Just, as well as in {y <- x; y} .. somehow
19:06:05 <crestfallen> but of course that is impossible koz_ 
19:06:21 <koz_> crestfallen: Don't let syntax confuse you - the types tell the truth.
19:07:19 <crestfallen> so I'm trying to think of where to find a good explanation of desugared do-notation ... working koz_ ...
19:08:51 <koz_> crestfallen: https://wiki.haskell.org/Typeclassopedia#do_notation
19:08:59 <koz_> The Typeclassopedia is the source of considerable wisdom.
19:09:06 <koz_> There's a desugaring grammar right in that entry.
19:10:14 <crestfallen> hit on academic paper by marlow, peyton-jones, kmett et al :/
19:10:38 <koz_> crestfallen: Yeah, have a read of the link above.
19:10:38 <crestfallen> thanks kindly copy that koz_ 
19:11:25 <crestfallen> I do get your explanation now and Ax*man's
19:15:07 <fraktor> Would it be hypothetically possible to create something like Elm, where web apps are done using FRP and then rendered using a DOM diffing algorithm, to truly native applications?
19:15:20 <koz_> fraktor: Hypothetically yes.
19:15:26 <koz_> Given that Elm does this.
19:15:36 <koz_> However, the practical details of this are... somewhat difficult.
19:16:57 <fraktor> Yeah. Native GUIs don't have the same features for manipulating a DOM that web browsers do. Plus you need a cross-platform GUI library in the first place.
19:20:30 <fraktor> Speaking of which, I haven't done GUI programming in Haskell. Is there a preferred cross-platform library for it?
19:20:40 <koz_> For what definition of 'cross-platform'?
19:21:21 <koz_> If you consider GTK 'cross-platform', then there's some stuff on top of that.
19:21:38 <koz_> I think there's some FLTK stuff as well.
19:25:20 <crestfallen> koz_: also if I may, this is bugging me. how if we write it using prefix notation: 
19:25:23 <crestfallen> (>>=) (Just (Just 5)) id
19:25:44 <koz_> crestfallen: What are you asking? 'how if we write it using prefix notation:' is not a sentence.
19:25:59 <crestfallen> sorry I'm writing it..
19:27:03 <crestfallen> it looks like (m m a) is being applied to id
19:29:06 <koz_> crestfallen: I still don't understand. What do you mean by that?
19:29:19 <koz_> Like, are you saying that you don't get how prefix syntax is being used with an infix function?
19:29:22 <koz_> Or something else?
19:30:33 <crestfallen> sorry my thinking is faulty. (<$>) (*10) [4,5,6]     << yeah the pattern is the same here
19:31:45 <crestfallen> > (*10) <$> [4,5,6]
19:31:47 <lambdabot>  [40,50,60]
19:32:12 <crestfallen> no it's reversed. do you see my point koz_  ?
19:32:22 <koz_> Nothing is reversed.
19:32:38 <koz_> You can make an infix operator prefix by wrapping it in ().
19:32:48 <koz_> And you can make a prefix function infix by wrapping it in ``.
19:33:01 <koz_> Like, are you confused by the prefix-infix distinction?
19:33:12 <koz_> I'm genuinely not sure what you're trying to say, or indeed, what isn't clear to you.
19:35:43 <crestfallen> in this case , the function is listed on the rhs of the infix: (Just (Just 5)) >>= id
19:35:50 <crestfallen> koz_: ^
19:36:08 <koz_> crestfallen: Functions can be arguments to other functions.
19:36:21 <koz_> There's nothing special about 'functions as arguments' versus 'non-functions as arguments'.
19:36:34 <crestfallen> in this case, the function is on the lhs : (*10) <$> [4,5,6]
19:36:46 <koz_> crestfallen: Yeah, and that's no different.
19:36:51 <koz_> :t (>>)
19:36:53 <lambdabot> Monad m => m a -> m b -> m b
19:36:55 <koz_> Sorry
19:37:00 <koz_> :t (>>=)
19:37:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:37:06 <koz_> This takes a function as an argument.
19:37:14 <koz_> :t (<$>)
19:37:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:37:21 <koz_> This also takes a function as an argument.
19:37:26 <koz_> Note where they are positioned.
19:37:36 <koz_> This is literally readable straight out of the type.
19:38:19 <crestfallen> yes the operands have the function in the first and second places respectively
19:38:40 <koz_> crestfallen: So... what's the issue?
19:39:00 <koz_> The reason the arguments are arranged that way is literally written into their types.
19:39:10 <koz_> Is your question '_why_ is it that they're arranged that way?'.
19:39:16 <koz_> The answer is 'because someone decided it so'.
19:39:34 <koz_> There's no (particular) reason why the arguments to bind or <$> are in the order that they are.
19:39:39 <koz_> But that's how they're defined.
19:39:53 <crestfallen> ok fair enough. because yeah I would have thought that the function would have been in the same operand place
19:40:03 <koz_> crestfallen: No, there's no reason for this.
19:40:21 <koz_> Order of arguments is arbitrary. There are some ergonomic issues regarding currying, but in this case, it's arbitrary.
19:40:34 <solonarv> oh! I see what you mean now. This is a reason I often use =<< instead of >>=
19:41:00 <koz_> solonarv: Yeah, and I think there's a flipped fmap too.
19:41:52 <crestfallen> excellent. yeah because technically, despite the context that bind is giving us, in some sense id is being applied to (Just (Just 5)) , right?
19:42:20 <koz_> crestfallen: I don't understand what you're saying. 
19:42:26 <koz_> Bind is defined the way it is.
19:42:29 <koz_> It means what its definition says.
19:42:36 <crestfallen> but if you look at it as     > (>>=) (Just (Just 5)) id       it looks odd
19:42:50 <koz_> Yeah - there's a reason we don't often write infix operators prefix.
19:43:06 <koz_> We can do it, and sometimes it can be more useful or readable that way, but there's a reason why >>= is infix.
19:43:40 <koz_> There's no a priori reason why bind needed to be an infix operator. We could actually do _everything_ prefix!
19:44:27 <crestfallen> yeah, the distinction affects my perception of it, tis all..
19:44:48 <monochrom> Some people want to write everything mixfix.
19:44:57 <koz_> monochrom: These people write Agda.
19:45:04 <monochrom> yeah :)
19:45:17 <crestfallen> like looking at a function and saying, ok this goes here, and that goes there, and this is what the machine is doing :)
19:46:04 <crestfallen> thanks great session koz_  et al
19:48:13 <crestfallen> yeah solonarv 's point makes it more intuitive:
19:48:16 <crestfallen> λ> (=<<) id (Just (Just 5))
19:49:10 <crestfallen> but that's wrong to think of it that way. because id is not applied that way, right koz_     ? 
19:49:26 <koz_> crestfallen: I genuinely don't understand what you're saying or asking.
19:49:35 <koz_> So I have no idea whether it's wrong to think of 'it' 'that way' or not.
19:50:37 <crestfallen> nevermind thanks I'm overthinking it to poor results
19:53:03 <fraktor> I am also quite confused
20:36:48 <larou> i rewrote the "typing the knot" with a "cycle"
20:36:49 * hackage hakyll-process 0.0.1.0 - Hakyll compiler for arbitrary external processes.  https://hackage.haskell.org/package/hakyll-process-0.0.1.0 (jhmcstanton)
20:36:50 <larou> https://pastebin.com/raw/J0e4fa3d
20:38:13 <larou> it gives;
20:38:14 <larou> *DLink> (fromCycle . (toCycle @False)) [1,2,3]
20:38:14 <larou> [1,2,3]
20:38:36 <larou> the regular tying the knot would not be able to do this
20:38:43 <larou> since it could not "detect the cycle"
20:39:03 <larou> ie, it would not support "fromCycle"
20:39:25 <larou> i dont think the type applications machinery it requires was available at the time 
20:39:56 <larou> or maybe even GADTs used this way
20:40:20 <larou> im struggling to write "cons" though
20:41:17 <larou> i think this should work even if it is positioned somewhere other than with the cycle immediately behind it
20:41:36 <larou> so i cant just cast it to a list, cons to the list and cast back
20:41:43 <larou> which would be slow anyway...
20:42:14 <larou> but i cant understand how to link it back together, if it has to somehow itterate over the backwards portion until the cycle
20:42:53 <larou> aswell as the regular iterations over the forwards part, that would basically be the inlined version (cf. fusion) of the to/from list
20:43:20 <larou> where these recursions are supposed to reestablish the links to the updated nodes successively 
20:47:35 <hololeap> the exponential law `x^(m+n) = (x^m)(x^n)` translates into haskell types as `Either m n -> x` ~ `(m -> x, n -> x)`
20:47:41 <hololeap> is this basically correct?
20:49:23 <dolio> hololeap: Yes.
20:49:35 <int-e> :t either
20:49:37 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:49:58 <int-e> :t uncurry either
20:49:59 <lambdabot> (a -> c, b -> c) -> Either a b -> c
20:50:09 <int-e> (one half of the isomorphism)
20:50:18 <int-e> (ignoring bottoms, of course)
20:50:50 <hololeap> int-e: good example :) but what is the other half?
20:51:02 <int-e> :t (. Left) &&& (. Right)
20:51:03 <lambdabot> (Either a b -> c) -> (a -> c, b -> c)
20:51:19 * hackage pandoc 2.11.0.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.11.0.2 (JohnMacFarlane)
20:51:49 <larou> :t (&&&)
20:51:49 <hololeap> right, fanout
20:51:50 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:52:13 <larou> % :t (&&&) @(->)
20:52:13 <yahb> larou: (b -> c) -> (b -> c') -> b -> (c, c')
20:52:53 <larou> :t either
20:52:54 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:53:22 <larou> % :t bimap @Either
20:53:22 <yahb> larou: (a -> b) -> (c -> d) -> Either a c -> Either b d
20:53:51 <larou> is there a way to cast those (->) to `Arrow a' ?
20:54:14 <larou> like something like (&&&) but for Either instead of (,) ?
20:54:30 <larou> (i guess it should work for arbitrary bifunctors)
20:54:45 <hololeap> ah, but `(. Left) &&& (. Right)` means you have to have a value available for both types `a` and `b`, right?
20:54:45 <int-e> :t (|||)
20:54:46 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
20:55:18 <hololeap> doesn't that contradict the semantics of Either?
20:55:51 <larou> that maps from Either to d
20:56:23 <int-e> larou: it's the arrow equiovalent of `either`
20:56:38 <larou> % :t (|||) @Either
20:56:39 <yahb> larou: ; <interactive>:1:1: error: No instance for (ArrowChoice Either) arising from a use of `|||'
20:56:43 <larou> rrg
20:57:06 <int-e> ?!
20:57:06 <lambdabot> Maybe you meant: v @ ? .
20:57:09 <larou> % :t (|||) @(->)
20:57:09 <yahb> larou: (b -> d) -> (c -> d) -> Either b c -> d
20:57:12 <larou> :t either
20:57:14 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:57:17 <larou> oh!
20:57:29 <larou> i was thinking of bimap still, sry
20:58:04 <larou> ah right, that c is like `c^(a+b)`
20:58:36 <hololeap> sorry, i was mixing up my variables in the two definitions. i forgot that an Arrow is usually the variable `a`
20:58:52 <int-e> :t (arr Left >>>) &&& (arr Right >>>)
20:58:54 <lambdabot> Arrow cat => cat (Either a b) c -> (cat a c, cat b c)
20:59:12 <hololeap> :t arr Left
20:59:13 <lambdabot> Arrow a1 => a1 a2 (Either a2 b)
20:59:35 <hololeap> :i ArrowChoice
20:59:38 <int-e> So yes, both of these generalize to arrows.
20:59:45 <larou> bimap would be `(c+d)^(a+b)`
20:59:47 <hololeap> % :i ArrowChoice
20:59:47 <yahb> hololeap: type ArrowChoice :: (* -> * -> *) -> Constraint; class Arrow a => ArrowChoice a where; left :: a b c -> a (Either b d) (Either c d); right :: a b c -> a (Either d b) (Either d c); (+++) :: a b c -> a b' c' -> a (Either b b') (Either c c'); (|||) :: a b d -> a c d -> a (Either b c) d; {-# MINIMAL (left | (+++)) #-}; -- Defined in `Control.Arrow'; instance [safe] Comonad w => ArrowChoice (Cokle
21:00:54 <larou> ah, so (+++) is like bimap
21:01:06 <int-e> no
21:01:17 <int-e> err wait, sorry.
21:01:20 <hololeap> oh, int-e already mentioned (|||)
21:01:22 <int-e> yes, but specifically for Either.
21:01:38 <larou> right
21:01:59 <int-e> hololeap: yes, and I was careful to wrote "arrow" in lower case because it's an extra class.
21:02:50 <larou> is the idea that arrows by pair kind of subsume list
21:03:47 <larou> thinking of how conal was implementing stacks for his "compilers to categories"
21:04:00 <larou> compiling*
21:04:05 <hololeap> arrows by pair subsume list?
21:04:09 <hololeap> what does that mean?
21:04:32 <larou> something about matching on cons being like a pair lens thing
21:04:56 <larou> like, the arrows way would just be to have nested pairs instead of lists
21:05:16 <larou> and then to lens over any element by distributing over pair
21:05:35 <hololeap> can you give a small example?
21:05:48 <larou> i cant actually lens speak
21:06:05 <larou> or arrow speak for that matter
21:06:12 <larou> so no! sorry...
21:06:48 <hololeap> just something pseudo-haskelly to illustrate the point
21:06:56 <larou> i think basically he managed to get quite a lot of expression from just category and arrow
21:07:08 <larou> like, enough to write a compiler of sorts, with this idea of a stack
21:07:21 <larou> erm, ok, i guess something like;
21:07:56 <larou> update 1 (+1) (1,(2,3)) = (1,(3,3))
21:07:59 <larou> ===
21:08:09 <larou> update 1 (+1) [1,2,3] = [1,3,3]
21:09:12 <larou> not that that shows anything about the compiler stack idea
21:09:38 <larou> the talk was here; https://www.youtube.com/watch?v=wvQbpS6wBa0
21:10:53 <hololeap> i know i asked for pseudo-haskell, but what would the type be for `update` in the first example?
21:11:10 <hololeap> i don't understand what the first 1 is for
21:11:23 <larou> well in the list example its the index
21:11:35 <larou> > [1,2,3] !! 1
21:11:38 <lambdabot>  2
21:11:47 <hololeap> oh
21:12:09 <larou> the type signature totally fails for the first example because really, nested pairs are not lists...
21:13:46 <larou> i think in the talk he was flipping the order of the pair around
21:13:50 <hololeap> update 0 = _1 ; update n f = _2 . update (n-1) f
21:13:53 <larou> so that the tail was on the first
21:14:05 <hololeap> (that might not be correct, i didn't test it)
21:15:37 <larou> i dont think you should be dotting? like the update (n-1) is the function passed to _2 right?
21:15:42 <larou> % :t _2
21:15:42 <yahb> larou: (Field2 s t a b, Functor f) => (a -> f b) -> s -> f t
21:15:58 <hololeap> :% t (_2 . _2 . _2 . _1)
21:16:13 <hololeap> broke it
21:16:14 <larou> % t (_2 . _2 . _2 . _1)
21:16:14 <yahb> larou: ; <interactive>:41:1: error: Variable not in scope: t :: ((a3 -> f0 b3) -> s0 -> f0 t0) -> t
21:16:27 <hololeap> % :t (_2 . _2 . _2 . _1)
21:16:27 <yahb> hololeap: (Functor f, Field2 s t a1 b1, Field2 a1 b1 a2 b2, Field2 a2 b2 a3 b3, Field1 a3 b3 a4 b4) => (a4 -> f b4) -> s -> f t
21:17:11 <larou> % :t \f -> (_2 (_1 f))
21:17:11 <yahb> larou: (Field2 s1 t s2 b1, Functor f, Field1 s2 b1 a b2) => (a -> f b2) -> s1 -> f t
21:18:14 <larou> % :t (\f -> (_2 (_1 f))) (+1) (1,(2,3))
21:18:15 <yahb> larou: (Functor f, Num a, Num b1, Num (f b2)) => f (a, (b2, b1))
21:18:19 <hololeap> % :t \n f = let foo n = case n of ; 0 -> _1 ; n' -> _2 . foo (n-1)
21:18:19 <yahb> hololeap: ; <interactive>:1:6: error: parse error on input `='
21:18:19 <larou> % (\f -> (_2 (_1 f))) (+1) (1,(2,3))
21:18:19 <yahb> larou: ; <interactive>:46:1: error:; * Ambiguous type variables `f0', `b0' arising from a use of `print'; prevents the constraint `(Show (f0 (Integer, (b0, Integer))))' from being solved.; Probable fix: use a type annotation to specify what `f0', `b0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; insta
21:18:30 <larou> !
21:18:31 <hololeap> % :t \n = let foo n = case n of ; 0 -> _1 ; n' -> _2 . foo (n-1)
21:18:31 <yahb> hololeap: ; <interactive>:1:4: error: parse error on input `='
21:19:20 <larou> % :t \n -> let foo n = case n of ; 0 -> _1 ; n' -> _2 . foo (n-1)
21:19:21 <yahb> larou: ; <interactive>:1:61: error: parse error (possibly incorrect indentation or mismatched brackets)
21:19:52 <larou> % :t \n -> let foo n = case n of ; 0 -> _1 ; n' -> _2 . foo (n-1) in foo 1 (+1) (1,(2,3))
21:19:52 <yahb> larou: ; <interactive>:1:65: error:; * Occurs check: cannot construct the infinite type: b1 ~ (f b, b1); arising from a functional dependency between:; constraint `Field2 (f b, (f b, b1)) (b, (f b, b1)) (f b, (f b, b1)) (b, (f b, b1))' arising from a use of `foo'; instance Field2 (a, b2) (a, b') b2 b' at <no location info>; * In the expression: foo 1 (+ 1) (1, (2, 3)); 
21:20:07 <larou> this isnt working at all!
21:20:33 <larou> crazy lenses...
21:20:54 <hololeap> % update 0 = _1 ; update n = _2 . update (n-1)
21:20:55 <yahb> hololeap: 
21:20:58 <hololeap> % :t update
21:20:58 <yahb> hololeap: (Eq t, Num t, Field1 a1 b1 a2 b2, Functor f, Field2 a1 b1 a1 b1) => t -> (a2 -> f b2) -> a1 -> f b1
21:21:10 <hololeap> anyway, that's what i was going for
21:21:31 <larou> how is that used?
21:24:58 <larou> % update 1 return (1,(2,3))
21:24:58 <yahb> larou: ; <interactive>:52:1: error:; * Occurs check: cannot construct the infinite type: b ~ (a, b); arising from a functional dependency between:; constraint `Field2 (a, (a, b)) (a, (a, b)) (a, (a, b)) (a, (a, b))' arising from a use of `update'; instance Field2 (a1, b1) (a1, b') b1 b' at <no location info>; * In the expression: update 1 return (1, (2, 3)); In an equat
21:25:21 <larou> how does that even typecheck!?
21:27:38 <larou> i think you would have to make update a function of a class so it could match on the type it was being applied to
21:30:52 <hololeap> yeah this doesn't typecheck well when applied to an actual value
21:32:21 <hololeap> there was a library that could convert (1,2,3,4) to [1,2,3,4] somehow
21:33:47 <larou> you mean (1,(2,(3,4))) ?
21:35:00 <hololeap> i remember it being (1,2,3,4) -> [1,2,3,4]. you would have to convert (1,(2,(3,4))) to (1,2,3,4) first i suppose
21:35:14 <larou> well thats no good!
21:35:20 <hololeap> anyway, possible, but tricky with haskell's type system
21:35:32 <larou> anyway, whats the point in having something that typechecks except when its applied to a value
21:35:59 <hololeap> there isn't one. i made a mistake
21:36:13 <larou> k
21:36:20 * hackage sweet-egison 0.1.1.1 - Shallow embedding implementation of non-linear pattern matching  https://hackage.haskell.org/package/sweet-egison-0.1.1.1 (SatoshiEgi)
21:36:21 <larou> btw did anyone see this>
21:36:22 <larou> https://pastebin.com/raw/J0e4fa3d
21:36:24 <larou> ?
21:36:26 <hololeap> although it should be possible
21:36:33 <hololeap> using type families or something
21:36:37 <larou> i was trying to write cons for a cyclic list
21:36:52 <larou> but got stuck
22:06:33 <hololeap> https://dpaste.com/3FX3PKNAB
22:15:20 * hackage sweet-egison 0.1.1.2 - Shallow embedding implementation of non-linear pattern matching  https://hackage.haskell.org/package/sweet-egison-0.1.1.2 (SatoshiEgi)
23:11:14 <hololeap> @pf runMatchT m = runMaybeT . runReaderT (getMatchT m)
23:11:15 <lambdabot> Maybe you meant: pl bf
23:11:23 <hololeap> @pl runMatchT m = runMaybeT . runReaderT (getMatchT m)
23:11:23 <lambdabot> runMatchT = (runMaybeT .) . runReaderT . getMatchT
23:13:49 * hackage egison 4.1.1 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-4.1.1 (SatoshiEgi)
23:53:30 <fragamus> howdy do we have a way to solve a set of six linear equations 
23:54:16 <fragamus> I kinda want to not use something that would require me to add a bulky external package
23:54:43 <Axman6> what does "external" mean?
23:54:54 <Axman6> I'm sure hmatrix has something?
23:54:56 <fragamus> I just want a sleek all haskell package that solves a system of linear equations
23:55:22 <fragamus> external means someone wrote one in C and then someone else ported it to haskell
23:55:29 <fragamus> I just want all haskell
23:55:37 <fragamus> I will have a look at hmatrix
23:56:05 <fragamus> I don't want one that uses FFI
23:56:16 <Axman6> I believe hmatrix uses lapack
23:57:42 <Axman6> https://hackage.haskell.org/package/linear-1.21.3/docs/Linear-Matrix.html#v:luSolve?
23:57:52 <Axman6> pretty sure there' no C deps for the linear package
23:57:53 <fragamus> I just want to do gaussian elimination on a six by six matrix
23:58:23 <fragamus> yes Linear is nice but it appears to top out at vecors of length 4
23:58:38 <fragamus> vectors even
23:58:54 <Axman6> V is an arbitrary sizex vector
23:59:16 <fragamus> elimination and back substitution
23:59:24 <Axman6> so you want V 6 (V 6 Double) or something
23:59:55 <fragamus> ok lemme try that
