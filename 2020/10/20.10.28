00:35:49 * hackage deriving-show-simple 0 - Derive a Show instance without field selector names  https://hackage.haskell.org/package/deriving-show-simple-0 (FumiakiKinoshita)
00:51:19 * hackage hslua-module-doclayout 0.2.0.1 - Lua module wrapping Text.DocLayout.  https://hackage.haskell.org/package/hslua-module-doclayout-0.2.0.1 (tarleb)
01:13:39 <dminuoso> binary question, when I have a tree of Get primitives, is there a good rule of thumb where to isolate?
01:30:18 <eedgit> Why are these named 'op' / 'e' - is it completely random or does it have some significance? (can't google 'cause its too short :( ) 
01:30:18 <eedgit> https://dpaste.org/cht0
01:30:52 <dminuoso> The 'e' is likely random
01:31:00 <dminuoso> And 'op' is just to suggest this is likely to be used with some kind of "operator"
01:31:06 <dminuoso> Think:
01:31:13 <dminuoso> % foldr (+) 0 [1,2,3,4,5]
01:31:14 <yahb> dminuoso: 15
01:31:49 <eedgit> thank you! I thought that might be operator. Is there a big list of commonly used vars / built in ones
01:31:57 <eedgit> To a novice it's like staring at a bowl of alphabet soup sometimes
01:35:59 <merijn> eedgit: I don't think there is a list, some common ones would be f/g/h for functions, i/j/k for indices, any single letter for just "a value of some polymorphic type"
01:36:31 <merijn> eedgit: oh, and of course the (x:xs) idiom (following from 1 item, multiple itemS you get 1 x, multiple xS)
01:38:49 <merijn> eedgit: I might call the 'e' "acc" (for accumulator or something), but it's not really clear what a "better" name would be.
01:40:17 <eedgit> `acc` is much better thanks
01:47:28 <dminuoso> eedgit: I tend to not like `acc` because it leads to a more imperative thinking.
01:48:17 <dminuoso> https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
01:48:50 <dminuoso> So if we foldr a list, then that second argument really is just what the empty list at the end gets replaced with.
01:54:53 <tomsmeding> "imperative thinking" certainly fits the time of year, does it not?
01:55:28 <merijn> Nothing wrong with imperative Haskell :)
01:57:18 <merijn> https://twitter.com/k0001/status/1295846402648682496 :p
01:59:13 <tomsmeding> lol
01:59:43 <tomsmeding> depends on the domain of course
01:59:59 <Rembane> As long as you don't think imperitavel... yeah... you can program using the style. *nods sagely*
02:01:30 <eedgit> dminuoso that's hurting my head a bit. Is the distinction you're making that it's 'folded' into the end, rather than accumulated in a new variable?
02:03:03 <tomsmeding> eedgit: 'foldr op e l' really just replaces the (:) in l with op, and the [] in l with e
02:03:48 <tomsmeding> foldr op e (1 : (2 : (3 : [])) = 1 `op` (2 `op` (3 `op` e))
02:04:06 <tomsmeding> hence 'e' for "empty list"
02:04:50 <tomsmeding> oh that's what the picture says, lol
02:05:08 <eedgit> ahh ok, think I've got it (*whiteboarding intensifies*)
02:05:11 <eedgit> ty
02:06:11 <tomsmeding> and if you at some point think, hey you can generalise this idea of "replacing constructors" to other data types: welcome to the theory of folds :)
02:09:33 <eedgit> still not entirely sure it's not witchcraft. My original implementation was pretty long but by looking at other solutions I'm down to a handful of variables
02:09:55 <eedgit> Is there a simpler / more native way than flattening and using foldr for rose-trees ?
02:10:32 <dminuoso> eedgit: So, `flattening` *is* already fully descriptive of the fold.
02:11:06 <dminuoso> We could think of Foldable having two equivalent signature methods `toList` and `foldr` (or perhaps foldMap instead of foldr).
02:11:50 <dminuoso> (Im not actually sure why toList is not a method of Foldable)
02:12:54 <dminuoso> But yes, you could essentially rip down the implementation of toList, and use that to implement a foldr directly
02:13:17 <Axman6> is there any optimisations to he had with toList /= foldr (:) []?
02:13:26 <dminuoso> Where, if you look at the above scheme, instead of putting in a `:` you just put in the argument `f` and, and instead of the `[]` at the end you put in the z
02:14:04 <dminuoso> So if you had some implementation `flatten ... = x : ...; flatten ... = []` 
02:14:09 <dminuoso> You could, instead, replace that implementation as
02:14:33 <dminuoso> instance Foldable YourTree where foldr f _z ... = x `f` ...; foldr _f z ... = z
02:14:34 <dminuoso> Mechanically
02:14:39 <dminuoso> (You dont even have to think about it)
02:14:58 <dminuoso> And then the `flatten` you have for free via `toList`
02:15:31 <dminuoso> Axman6: Well, less fusion/deforestation I guess?
02:15:47 <dminuoso> (By "less" I mean "less required")
02:15:57 <Axman6> but surely that would have happened in your foldr definition
02:16:15 <dminuoso> If the foldr has to decompose a list again, that surely hinders optimizations
02:16:44 <dminuoso> If we dont even allow generating a list, we dont have to do deforestation in the first place.
02:17:19 * hackage ukrainian-phonetics-basic 0.1.6.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.6.0 (OleksandrZhabenko)
02:18:19 * hackage mmsyn6ukr 0.8.2.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.8.2.0 (OleksandrZhabenko)
02:22:42 <eedgit> Makes sense, thanks
03:00:49 * hackage th-lego 0.2 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.2 (NikitaVolkov)
03:03:18 * hackage wai-saml2 0.2.1.1 - SAML2 assertion validation as WAI middleware  https://hackage.haskell.org/package/wai-saml2-0.2.1.1 (mbg)
03:32:38 <dminuoso> data ConDecl l where ConDecl l (Name l) [Type l] | ...
03:32:48 <dminuoso> This is from haskell-src-exts, what is this type list?
03:33:07 <dminuoso> Is that possibly for DatatypeContexts?
03:34:56 <dminuoso> Oh shoot me.
03:35:03 <dminuoso> Haskell for beginners.
03:53:42 <tomsmeding> I believe there was a conversation here a few days back with a beginning haskell programmer that had trouble distinguishing [a] on the type level and a singleton list on the value level
03:55:11 <tomsmeding> oh wait I'm misunderstanding your misunderstanding am I not
03:55:30 <tomsmeding> yay
03:55:47 <lortabac> types and data constructors with the same name were my main source of confusion when I was a beginner
03:57:18 <tomsmeding> understandable
03:58:37 <dminuoso> tomsmeding: Haha, I was just wondering "what in the name does a data constructor declaration need a type for"
03:58:45 <dminuoso> My brain stopped working there for a good 5 minutes.
03:59:10 <tomsmeding> it's also kind of confusing
03:59:37 <tomsmeding> "data constructor" is probably a value-level constructor, which takes value-level arguments
04:00:04 <tomsmeding> so on the surface, having no idea about the organisation of haskell-src-exts, I'd assume that those types are the instantiations of the type variables of the data type or something?
04:00:10 <tomsmeding> but that makes no sense in the context of a parser
04:00:33 <tomsmeding> and if it's really a data _type_ declaration, then please do not call that a "data cosntructor"
04:02:56 <dminuoso> tomsmeding: `data Foo = Bar Int`
04:03:01 <dminuoso> Here the `Int` is meant
04:03:16 <dminuoso> (The declaration of the data constructor Bar does take a number of types)
04:03:27 <tomsmeding> lol
04:03:54 <tomsmeding> I guess we can share the bullet
04:20:07 <dminuoso> tomsmeding: Indeed, I was in a similar mindset as you. "This makes no sense"
06:37:05 <hyperisco> I am using dhall as a library and would like to _encode_ data and write it to a file. How can I do that? I see the ToDhall class but I am not sure where to go from there
06:40:49 * hackage keycloak-hs 2.0.0 -   https://hackage.haskell.org/package/keycloak-hs-2.0.0 (CorentinDupont)
06:49:14 <dminuoso> Can you emit newlines with CPP macros?
06:49:32 <Uniaika> should you? :P
06:49:51 <dminuoso> I want to define a bunch of instances with a single macro.
06:49:52 <dminuoso> So yes.
06:50:03 <Uniaika> I think you can
07:07:59 <siraben> Anyone using Emacs and got hlint + LSP to work together?
07:08:05 <siraben> I want to see hlint hints when using haskell-lsp but the manual doesn't seem to say anything about it
07:21:08 <lyxia> hyperisco: there is a Pretty instance, maybe that's the right way?
07:38:08 <tomsmeding> dminuoso: no you can't
07:38:11 <tomsmeding> this is also annoying in C
07:38:34 <tomsmeding> at least -- you can't, unless the haskell CPP is a different one than the regular CPP from C/C++
07:38:58 <dminuoso> I think the CPP is the one from.. well.. I dont know..
07:39:10 <dminuoso> The documentation seemed a bit fuzzy
07:40:16 <tomsmeding> notable is that in C, the only place in the syntax that requires a hard newline is in CPP directives; since CPP macros can't generate new macros, it's therefore unnecessary for macros to be able to generate newliens
07:40:33 <tomsmeding> and it turns out that they actually can't
07:40:45 <merijn> GHC CPP is pretty much unspecified
07:41:14 <merijn> It uses a super hacky setup of non-standard backwards compat flags/modes of the C compiler with a bunch of parsing rules changed to do CPP
07:41:16 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/native-cpp
07:41:21 <merijn> It's 100% vile hacks, basically
07:41:45 <dminuoso> So if I want something clean, it's TH?
07:42:24 <tomsmeding> generate TH with CPP!
07:42:43 <tomsmeding> that's got to be the ugliest combination of extensions yet
07:43:04 <dminuoso> tomsmeding: I can think of one better
07:43:33 <dminuoso> Add RebindableSyntax to change how the Q monad works
07:44:27 <tomsmeding> juicy
07:45:41 <dminuoso> Or maybe we can do something fancy with Arrows
07:46:03 <dminuoso> (Are there still packages in use that even use the Arrows extension?)
07:46:10 <merijn> TH is also ill-defined, but in a less broken and vile way :p
07:46:23 <merijn> As in, at least TH is well-specified if you don't attempt to cross-compile
07:47:04 <dminuoso> merijn: Is that because of reflection, where you could for instance look at `sizeOf (undefined :: Int)`?
07:47:09 <dminuoso> (inside TH)
07:49:33 <merijn> dminuoso: Yeah
07:49:44 <merijn> And then you get hairy questions like "which Int"?
07:49:59 <dminuoso> what do you mean by which?
07:50:12 <merijn> as in "on the target architecture" or "on the build architecture"
07:50:17 <dminuoso> right
07:50:49 <merijn> But if you don't cross-compile it's not ambiguous
07:50:53 <dminuoso> Is that why TH is not allowed in the stage 1 compiler?
07:51:02 <merijn> This is also why cross-compiling TH is probably forever doomed
07:51:48 <merijn> Would've had to have explicit platform support build in from the get-go, but figuring out what it's "supposed" to do is hard
07:53:33 <Ariakenom> async exceptions, yay or nay?
07:53:44 <monsterchrom> \∩/
07:54:09 <merijn> Ariakenom: Depends, do you like going depressed drinking binges?
07:54:14 <merijn> s/going/going on
07:54:44 <noctux> "how I developed a drinking habit with the help of #haskell"
07:55:14 <merijn> Ariakenom: If yes, probably fine. If you have mercy on your liver, probably best avoid them as much as possible :)
07:55:25 <merijn> Also reduces the amount of uncontrollable sobbing in your life
07:55:35 <Ariakenom> :p
07:55:38 <dminuoso> Ariakenom: Can you specify the question?
07:56:00 <Ariakenom> dminuoso: would you prefer if they didnt exist in haskell
07:56:23 <dminuoso> Hard to say, they're quite convenient for killing threads.
07:56:24 <merijn> Ariakenom: I wish we had more control of what/where/when you could throw them
07:56:34 <merijn> But I wish we had first class concurrency too
07:56:49 <dminuoso> Without it, killing threads would require yield points and cooperatoin
07:57:03 <merijn> dminuoso: It still does :p
07:57:06 <dminuoso> heh
07:57:18 <dminuoso> merijn: except GHC takes care of the yield points for me.
07:57:23 <dminuoso> It does a mostly good job
07:57:28 <merijn> Sure, but still!
07:57:36 <dminuoso> okay fine
07:57:50 <dminuoso> Without it, killing threads would require manual yield points and manual cooperation.
07:58:02 <dminuoso> Which is hard to get right
07:58:12 <Ariakenom> I once wrote some concurrent code in python where I added yield points and timeouts everywhere. that would have been much easier in haskell, I tihnk
07:58:19 <dminuoso> I think, a notable fraction of async exception pain is because Control.Exception is messed up
07:58:30 <dminuoso> But if you use UnliftIO.Exception for example, most of that is gone
07:59:05 <Ariakenom> I like asyncs but I havent run into much trouble
07:59:22 <merijn> Ariakenom: That's because there's no trouble, right up until the point everything is broken :p
07:59:31 <merijn> And then it's impossible to debug :p
07:59:56 <dminuoso> Ariakenom: To be exact, Control.Exception doesn't make a clear distinction between async and sync exceptions. That's sadly an antipattern
08:00:04 <Ariakenom> agreed
08:00:17 <dminuoso> We shouldnt hand you tools you can use to accidentally recover from an async exceptoin
08:00:26 <merijn> Naah
08:00:27 <dminuoso> (If you want to shoot yourself in the foot, make your own shotgun)
08:00:39 <merijn> The problem with Control.Exception is that it messed up masking stuff
08:00:46 <dminuoso> merijn: no it *is* a problem
08:01:03 <Ariakenom> veryUninterruptibleIAmBusyMask
08:01:33 <dminuoso> merijn: Oh you mean how mask doesn't actually mask?
08:01:40 <dminuoso> or not completely, anyhow
08:01:59 <Ariakenom> funny thing. in python, Ctrl-C aka SIGINT aka KeyboardInterrupt is basically an async exception. but because asyncs arent a thing in python it can break most anything
08:02:11 <merijn> I meant that catch and co should use uninterruptibleMask for cleanup, but don't
08:02:14 <dminuoso> Perhaps we should rename mask/uninterruptableMask to mask/interruptableMask
08:02:27 <dminuoso> (oh well, they should be flipped on one side)
08:02:28 <merijn> There's a mailing list thread by me from 2013
08:02:41 <dminuoso> merijn: And I propose that catch shouldn't even catch async exceptions.
08:03:04 <merijn> dminuoso: That's a user decision, tbh
08:03:16 <dminuoso> I personally avoid all of that pain since all my apps use unliftio anyway, so I just use UnliftIO.Exception instead of Control.Exceptoin
08:03:23 <dminuoso> which has the "fixed semantics"
08:03:36 <Ariakenom> I at least prefer haskell embracing asyncs to python having it as a broken special case. half way isnt great
08:04:00 <dminuoso> (it takes just a single `f catch (\(e :: SomeExceptoin) -> ...)` and your thread becomes unkillable
08:04:13 <dminuoso> These catch-all points do exist
08:04:27 <merijn> dminuoso: Well, then we should *instead* ban SomeException :p
08:04:36 <merijn> I'm much more on-board for that
08:05:04 <dminuoso> merijn: I dont care about the how really, in the current state of things, it's easier to tweak the combinators to selectively ignore async exceptions if they provide recovery
08:05:20 <merijn> dminuoso: The current state of unchecked exceptions is a stupid mess too
08:05:25 <dminuoso> such that async exceptions are just for acts of violence
08:05:54 <dminuoso> (because if you wanted to use them for communication, just use stm instead...)
08:05:56 <merijn> I should start a patreon to fund me working on a GHC fork full of "non fancy type" breaking extensions :p
08:06:32 <dminuoso> merijn: If only you could *sell* all your grand ideas but one, then you'd have enough money to fund yourself working on the remaining one.
08:06:37 <Ariakenom> merijn's ghc cleaning fund
08:07:25 <merijn> dminuoso: My grand ideas are *good* and as you know, you can't get people to listen to good ideas even if you pay them :p
08:07:57 <dminuoso> Of course, everyone thinks their ideas are good.
08:08:13 <dminuoso> It makes you wonder why nobody will listen to them!
08:08:13 <merijn> Mine actualy, that's why no one listens to them!
08:14:18 <__monty__> Interesting use of moduse tollens.
08:15:48 * hackage happstack-clientsession 7.3.2 - client-side session data  https://hackage.haskell.org/package/happstack-clientsession-7.3.2 (JeremyShaw)
08:22:19 * hackage ukrainian-phonetics-basic 0.1.7.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.7.0 (OleksandrZhabenko)
08:23:19 * hackage keycloak-hs 2.0.1 -   https://hackage.haskell.org/package/keycloak-hs-2.0.1 (CorentinDupont)
08:33:13 <helpmeguys> Is it possible to write a Haskell program that generates the list of all the subsets of the set [1..n] that have as many elements as their complements. Note: the complement of a set contains all the elements in [1..n] that are not members of the given set. Show the outputs for n=6.
08:34:38 <dminuoso> helpmeguys: When you say complement, do you mean that as relative complement with respect to [1..n]?
08:34:58 <helpmeguys> Yes, under that assumption. 
08:35:16 <dminuoso> helpmeguys: The answer is yes.
08:35:49 <helpmeguys> Can I get an example of such a program? 
08:36:30 <dminuoso> You mean a solution to your homework assignment?
08:36:37 <Uniaika> (shots fired)
08:36:39 <helpmeguys> No
08:36:43 <dminuoso> :>
08:36:51 <dminuoso> No but seriously, this does sound like a homework assignment.
08:36:52 <helpmeguys> I am just looking up old questions
08:37:05 <dminuoso> What have you tried?
08:39:05 <helpmeguys> Binary trees
08:39:08 <helpmeguys> And all
08:39:22 <helpmeguys> Cyclic groups
08:40:02 <dminuoso> Maybe I understand the task wrong, but this seems like a very simple one liner..
08:40:29 <helpmeguys> Please
08:40:31 <helpmeguys> Help me
08:40:43 <helpmeguys> I just want to see the code.
08:40:50 <helpmeguys> It will relax my mind
08:41:04 <dminuoso> Dunno, I still think this is a homework assignment.
08:41:13 <ghoulguy> helpmeguys, give it a shot and then paste what you try on a pastebin to share/get help
08:41:21 <ghoulguy> It will help relax your mind
08:41:34 <dminuoso> I mean if this is an old question, you surely have an answer already, or have enough competency to solve this yourself.
08:41:58 <dminuoso> And Im also not sure how binary trees or cyclic groups are even remotely useful here
08:42:54 <dminuoso> It should also be said, that lists dont form proper sets as they have internal ordering.
08:43:14 <dminuoso> So that begs another question whether [1,2] = [2,1] for the purpose of this excercise
08:43:32 <dminuoso> (or what a subset even means)
08:43:41 <ghoulguy> I'm imagining: *Help> homework 4
08:43:42 <ghoulguy> [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
08:44:12 <dminuoso> ghoulguy: For the purpose of golfing, did you do the naive thing?
08:44:46 <ghoulguy> I didn't use anything from Data.List, if that's what you're asking.
08:45:09 <helpmeguys> *Help> homework 4
08:45:17 <helpmeguys> Is that hint?
08:50:47 <ghoulguy> dminuoso, That implementation tries to maximize sharing and minimize retraversing any lists
09:13:43 <typetetris> Can I disable a redundant constraint warning for a single function within a file?
09:13:59 <geekosaur> not currently
09:14:00 <ghoulguy> typetetris: I'd be surprised
09:14:36 <helpmeguys> Please
09:14:38 <helpmeguys> Help me
09:14:47 <helpmeguys> I will study better next time
09:14:50 <helpmeguys> Haskell program that generates the list of all the subsets of the set [1..n] that have as many elements as their complements?
09:14:53 <helpmeguys> I promise
09:14:56 <helpmeguys> I will work hard
09:15:02 <dminuoso> typetetris: A long while ago, the ability to disable diagnostics per region was asked for orphans and overlapping names. The discussion quickly devolved into "lets build this right and put in an entire architecture for this for all diagnostics"
09:15:08 <dminuoso> And then it stopped.
09:15:12 <dminuoso> That was about 10 years ago I think?
09:15:29 <ghoulguy> helpmeguys: study for what?
09:15:39 <helpmeguys> For my diploma
09:15:42 <merijn> dminuoso: I've had this discussion as recent as 2 years ago when I proposed an "ADOPT" macro for orphan instances
09:16:05 <merijn> (yes, I think I'm verry funny)
09:16:05 <dminuoso> merijn: Indeed. I think we're at a stage where it's fine to just hack ADOPT in, and deprecate it if or when we get that architecture
09:16:07 <typetetris> Sometimes ghc complains HasCallStack would be redundant ... but I don't see how it comes into the signature otherwise.
09:16:31 <helpmeguys> Please
09:16:36 <helpmeguys> Can someone tell me :)
09:16:42 <helpmeguys> Haskell program that generates the list of all the subsets of the set [1..n] that have as many elements as their complements?
09:16:44 <dminuoso> Because the benefit of ADOPT greatly outweighs the heavy and unbearable engineering complexity (that nobody wants to do) that nobody needs anyway.
09:17:01 <dminuoso> Out of all the things, I think ADOPT is pretty much the only one where I really want the diagnostics but the ability to selectively disable them
09:17:14 <dminuoso> I've went as far as always using Orphan modules precisely because of this
09:17:17 <typetetris> What is ADOPT?
09:17:27 <dminuoso> typetetris: A proposed addition to suppress orphan instance warnings
09:17:36 <typetetris> Thanks.
09:17:43 <dminuoso> say `instance {-# ADOPT #-} C T`
09:18:47 <dminuoso> merijn: Maybe we should restart the discussion and lobby for "lets fix this now, and deprecate it if this imaginary and impossible infrastructure ever arrives"
09:18:51 <dminuoso> Im up for it
09:19:04 <dminuoso> (the technical implementation should be very simple)
09:19:08 <davean> We kinda got it for overlapping?
09:19:11 <merijn> dminuoso: Good luck :)
09:19:30 <merijn> typetetris: A made up pragma for silencing orphan instance warnings
09:19:43 <dminuoso> davean: No, in case of overlapping it doesn't just suppress a warning, it affects instance resolution
09:19:52 <dminuoso> ADOPT is really just about suppressing a warning
09:20:00 <merijn> typetetris: Because the only current alternative is to disable *all* orphan instances, rather than specific ones
09:20:39 <typetetris> merijn: Yes, a more specific pragma would be better.
09:22:18 <dminuoso> typetetris: The rough argument against it was "yet another syntax change, causing more friction on libraries like haskell-src - and while we're at it, we should have an infrastructure in place where we could selectively disable any diagnostic on arbitrary code regions"
09:22:30 <dminuoso> You know, just the thing that requires tremendous engineering and effort
09:22:45 <dminuoso> Except, we don't really need it for anything but orphan warnings realistically.
09:23:19 <typetetris> dminuoso: .... yeah, sounds like YAGNI
09:24:05 <dminuoso> typetetris: To be fair, GHC has frequently suffered from ad-hoc additions to its syntax like that.
09:24:48 <dminuoso> So rather than "changing the syntax with extra bits every time you come up with the new idea", it's not completely unwise to think about "if we do this, we should find a general solution once and for all"
09:24:54 <typetetris> Is there a timeline for the primops to speed up effect libraries in sight?
09:25:02 <typetetris> Forgot how they have been called.
09:27:50 <lyxia> typetetris: you can look up the proposal and its discussion on Github https://github.com/ghc-proposals/ghc-proposals/pull/313
09:28:28 <helpmeguys> Okay
09:28:33 <helpmeguys> My test is up
09:28:37 <helpmeguys> At-least tell me now
09:28:39 <helpmeguys> :)
09:28:47 <ghoulguy> helpmeguys: What test?
09:29:02 <helpmeguys> FBI Cybersec Command
09:29:15 --- mode: ChanServ set +q *!*@103.108.95.147
09:29:59 <dminuoso> Thank you whoever did that.
09:40:36 <noctux> hmm, ghoulguy, is there actually a "nice" oneliner solution?
09:41:01 <noctux> my most (codeminimal) one was with permutations and nub
09:41:31 <ghoulguy> noctux: If the goal is 'short' then using: filter and subsequences
09:41:53 <noctux> ah, damn it...
09:42:21 <noctux> subsequences actually includes "ac" from "abc"...
09:42:29 <noctux> someone should learn to read docs :P
09:42:33 <noctux> ghoulguy: thanks!
09:42:44 <ghoulguy> I wouldn't use that in general, though
09:43:45 <noctux> sure, was just out of codegolf-interest
09:44:19 * hackage esqueleto 3.3.4.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.4.1 (parsonsmatt)
10:04:45 <devalot> Haskell Cafe is still using mailman 2 and it appears there are issues with SPF and DMARC.  As an example, I posted a message a few weeks ago.  One person responded directly to me and the list.  Neither message is in the archive.  Is it just me or do others have problems with the mailing list?
10:18:19 * hackage keycloak-hs 2.0.2 -   https://hackage.haskell.org/package/keycloak-hs-2.0.2 (CorentinDupont)
10:18:55 <geekosaur> devalot, try in #haskell-infrastructure
10:26:49 * hackage cut-the-crap 2.2.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-2.2.0 (Jappie)
10:32:25 <justsomeguy> Hi there -- I'm on HPFP, chapter 8, learning about the basics of recursion. I'm writing a recursive function to multiply two numbers by repeatedly adding, and having trouble figuring out what I'm doing wrong. It works for positive inputs, but reverses the sign for negative inputs. Would someone mind taking a look at my code and giving me a hint? https://github.com/kingparra/multiply/blob/master/src/Lib.hs
10:33:10 <lyxia> devalot: I've noticed that happening also a few weeks ago.
10:36:27 <justsomeguy> Ah, ok, seems I hadn't considered the case where y is negative.
10:57:13 <typetetris> https://github.com/ghc-proposals/ghc-proposals/pull/313 was touched last time in September ... hopefully it doesn't fizzle out.
11:02:25 <ixlun> Hi all, I was wondering if someone may 
11:02:37 <ixlun> be able to help me with some performance issues
11:03:03 <ixlun> After 1 min of execution I'm getting: total alloc = 60,821,691,232 bytes
11:03:28 <ixlun> so I'm presuming I've got a space leak somehwere
11:05:03 <ixlun> apparently, (!) in https://termbin.com/7iia is responsible for a large part of that
11:05:53 <monsterchrom> IIRC "total alloc" means nothing when taken out of context.
11:06:34 <monsterchrom> The correct first step is to look at "resident memory" only.
11:07:31 <monsterchrom> And the best way is to use the unix/linux programs "top" or "htop" to look at RSS only. Not even "virtual whatever", that's a lie.
11:13:30 <ixlun> Hmm, I don't think it looks that terrible, 
11:13:49 <ixlun> but doesn't the above imply lots and lots of GC is occuring?
11:15:03 <dolio> Space leaks aren't the same as doing lots of GC.
11:15:04 <monsterchrom> Yes, that does.
11:15:12 <monsterchrom> And what dolio said.
11:19:32 <rx_> what column is rss?
11:19:53 <monsterchrom> Sorry, RES
11:24:48 <ixlun> Hmm, I think I need to do some reasrch on optimising Haskell
11:24:48 * hackage polysemy-methodology 0.1.0.0 - Domain modelling algebra for polysemy  https://hackage.haskell.org/package/polysemy-methodology-0.1.0.0 (locallycompact)
11:35:20 * hackage hex-text 0.1.0.2 - ByteString-Text hexidecimal conversions  https://hackage.haskell.org/package/hex-text-0.1.0.2 (chris_martin)
11:52:09 <rx_> hm, so `let double x = 2 * x; let quadruple x = quadruple (double x)` almost crashed my computer
11:52:22 <rx_> why's that?
11:52:31 <rx_> using ghci
11:52:56 <geekosaur> because quadruple calls itself immediately
11:53:19 <rx_> but it's not defined
11:53:30 <geekosaur> it's defined recursively at that point
11:53:41 <rx_> ok
11:53:57 <rx_> can I limit the "heap" space
11:54:05 <geekosaur> let defines things recursively. this is a feature when used appropriately since infinite values are useful when they're productive
11:54:31 <geekosaur> > let ones = 1 : ones in take 10 ones
11:54:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
11:55:28 <geekosaur> there are ways to limit heap but it'll still crash ghci
11:55:30 <rx_> that's haskell after the : ?
11:55:51 <geekosaur> yes
11:56:25 <geekosaur> (x:xs) is the fundamental way of building a list
11:56:34 <rx_> oh yeah
11:56:50 <rx_> I thought it was a separator for a moment
11:56:52 <rx_> thanks
12:00:19 * hackage vimeta 0.3.0.1 - Frontend for video metadata tagging tools  https://hackage.haskell.org/package/vimeta-0.3.0.1 (PeterJones)
12:03:48 <dminuoso> rx_: As a useful note, (:) is actually just a data constructor that happens to look like an operator. :)
12:04:43 <dminuoso> One could assume list was defined as `data [a] = a : [a] | []` - or alternatively as `data List a = Cons a [a] | Nil`. In this second version `Cons` takes the role of (:) :)
12:05:32 <rx_> what does caps mean in hs ?
12:05:43 <rx_> library function?
12:05:54 <geekosaur> initial capital is a constructor, vs. a variable/binding
12:06:08 <rx_> oh ok
12:06:44 <geekosaur> this is important in pattersn so it knows which parts are structural to be matched against, vs. which parts are data that can be bound to
12:07:17 <dminuoso> Oh, I messed up the second declaration. That should have read `data List a = Cons a (List a) | Nil` of course.
12:07:27 <dminuoso> % data List a = Cons a (List a) | Nil
12:07:28 <yahb> dminuoso: 
12:08:10 <geekosaur> when using infix constructors, initial colon (:) is "capital" (borrowed from list syntax)
12:08:24 <rx_> hmm, there is no way out of the quadruple function is there
12:08:46 <geekosaur> not as written. but did you want double (double x) ? 
12:09:00 <rx_> I'm tracing through it but I realize it needs a way out
12:09:09 <rx_> ah no, just going through the haskell wikibook
12:09:37 <rx_> clever question by the author I guess :]
12:09:37 <hyperisco> okay I hate exceptions in Haskell now
12:09:39 <geekosaur> either that, or a way to produce a partial result before it recurses (like the `ones` example)
12:09:54 <hyperisco> so about them checked exceptions
12:09:57 <geekosaur> hyperisco, what took you so long?
12:10:10 <hyperisco> I have never written a program that does IO in Haskell until now lol
12:10:20 <hyperisco> you know how Haskell is also a research language?
12:10:33 <hyperisco> so anyways, every exception is a SomeException right?
12:10:39 <geekosaur> yes
12:10:43 <hyperisco> okay then it is fixed
12:11:12 <hyperisco> I am just in two minds that you either have unityped errors or you have checked errors, and checked errors are not really so useful
12:11:51 <hyperisco> a half-way of unchecked I dunno what type you're throwing is unpleasant
12:12:00 <dsal> I'm a pretty non-fan of checked exceptions.  I've gone from "I hate exceptions in Haskell" to "Eh"
12:12:25 <dminuoso> dsal: Are you opposed to the general idea of it, or to specific implementations of it?
12:12:33 <dminuoso> Because why would you willingly discard information?
12:12:43 <dsal> I've only experienced in Java, and most of what I've done there is get rid of things.
12:13:30 <dsal> It just seems to sprawl without bounds and get wrapped in other thing that make it somewhat lossy.  I don't think it *can't* be done, but the Java experiment was very bad.
12:13:32 <hyperisco> dminuoso, you'd willingly discard information when there is no decisions to be made on the basis of that information
12:13:47 <hyperisco> because, otherwise, it is extra effort to keep around
12:13:49 <geekosaur> ^
12:14:09 <dminuoso> hyperisco: Why do decisions need to be made? Isn't it enough to have some kind of proof your program is right?
12:14:11 <dsal> Yeah, like, I'd be fine with a handler somewhere that could infer what exceptions were in scope.
12:14:19 <hyperisco> and it just seems to be that, for many uses, a string message and maybe a stack trace and maybe a source line suffices
12:14:24 <dminuoso> In a similar sense to how type systems dont make active decisions for you, they just filter out bad programs.
12:14:47 <dsal> i.e., when you go to write an exception handler, it would be aware of the things that might be thrown.  If you're not writing an exception handler, you shouldn't have to say anything.
12:14:52 <dminuoso> "Oops forgot to catch an exception here" can lead to brittle software in production.
12:15:14 <dsal> I've seen far more bugs from "I was forced to deal with an exception here" than forgetting to catch them.
12:15:24 <dsal> Crashes > bad behavior.
12:15:35 <hyperisco> dminuoso, what is the point of having more than one exception type?
12:15:37 <dminuoso> Not sure whether the > denotes badness or goodness.
12:15:48 <rx_> dminuoso, it seems hard to solve just forgetting to do something
12:15:56 <dsal> Heh.  I'd rather have software crash than behave incorrectly.
12:16:19 <dminuoso> dsal: Depends on what the cost of crash recovery is.
12:16:25 <dsal> But I'd be open to  "what kinds of crashes might occur here"
12:17:01 <dminuoso> hyperisco: The same point of having more than one data type?
12:17:03 <dsal> The cost of crash recovery is probably less than the cost of "the software just did the wrong thing that was kind of undefined"
12:17:13 <dminuoso> The ability to pattern match on it, and make decisions.
12:17:26 <dsal> I used to write a lot of erlang, though, where crashing is great.
12:17:26 <hyperisco> dminuoso, I think that is a good hypothesis but my experience is that it does not bear out
12:17:33 <dminuoso> dsal: Id argue that depends greatly on the problem domain of your software.
12:18:06 <dminuoso> hyperisco: So perhaps the right ergonomics haven't been discovered or implemented yet. Im merely suggesting that in principle checked exceptions seems like a desirable thing.
12:18:18 <dsal> Maybe, but I'd think undefined behavior is generally worse than crashed program.
12:18:32 <hyperisco> dminuoso, I found some utility with file system operations, because you can glean the state of the file system (or at least what the state was) by which exception was thrown
12:18:38 <dminuoso> Because I'd rather have my compiler tell me "you have an uncaught exception here" than to discover this at runtime.
12:18:44 <dminuoso> I mean folks, that's precisely why we love our typesystem.
12:18:48 <dsal> dminuoso: I'm not sure I disagree with you in general.  It wouldn't be the only thing Java got very wrong.
12:19:41 <hyperisco> dminuoso, if the ergonomics were sufficient that you could largely ignore it when it is not needed then the cost of having it around would be near zero and I wouldn't complain :)
12:20:15 <dsal> I think most places there's a try block in java, nobody should be dealing with exceptions at all.   A catch block does one of three things:  1. Rewraps an exception to satisfy the type system, 2. possibly does something sensible, 3. introduces a bug.
12:20:21 <dsal> These are the things I'd want to avoid.
12:21:23 <dsal> #2 there is OK.  Most places there's a try block, we probably just want finally.  That's easy to do in Haskell already.  So the checked exceptions system needs to let me ignore exceptions where I need them.  Then I'm happy with the compiler letting me know I introduced a new exception that I've not considered.
12:21:28 <hyperisco> dminuoso, I think type inference demonstrates a strong antagonism to types
12:21:30 <dsal> Hopefully I can also still do partial exception handler.
12:21:41 <dminuoso> dsal: Interestingly, in Haskell we have related issues with recovery mechanisms in Control.Exception - a plain `catch f (\(e :: SomeException) -> ...)` will catch and recover from async exceptions.
12:21:42 <dsal> Wait, what?
12:22:15 <hyperisco> dminuoso, I think it says we want automatic analysis without the expense of explaining ourselves
12:22:35 <dminuoso> hyperisco: I'd say type inference is a compromise.
12:23:13 <dsal> dminuoso: Yeah, I think it can be better.  I'm going to go ahead and say your initial assessment of my opinion is probably right.  Something hurt me, but that doesn't mean all things will.
12:23:26 <hyperisco> and I'd admit that probably the worst annoyance of Java that C# fixed was type inference for variable declarations
12:23:30 <dminuoso> So a system of checked exceptions should, ideally, have a similar model of type inference, where the type checker would automatically deduce what exceptions can be thrown, which exceptions are removed, and so forth.
12:23:56 <dsal> Type inference just prevents you from having to talk about types all over the place.  You *need* to talk about your types in some place.
12:24:02 <dminuoso> In a way where you can suddenly hop in and declare some fact, and then let the checker verify whether this leads to conflicts with all the inferred things
12:24:22 <dminuoso> dsal: Right! The more you elaborate, the better type errors get.
12:24:57 <dminuoso> I mean we see this in multiple levels. It frequently happens that I encounter GHC errors in all the wrong places, because of the way type inference works.
12:25:13 <hyperisco> even on TLDs is a burden
12:25:23 <hyperisco> literally dozens of exception types build up
12:25:51 <hyperisco> are you going to keep typing those all out? unlikely
12:28:34 <hyperisco> probably there is a type synonym at the top of the file for the union of all exceptions thrown by definitions in that file, because then it is much shorter and less noisy
12:29:33 <hyperisco> but then you're weakening all your definitions, and largely forgoing any purpose the feature had in the first place
12:30:51 <hyperisco> I feel like some of you are in the "wouldn't it be great if" stage of the discussion, and I am in the "it wasn't so great" part of the discussion
12:31:31 <hyperisco> but I haven't applied checked exceptions to every domain of programming… like I said, some use in file system APIs. Could be others.
12:31:49 <dolio> Which one wasn't great?
12:33:58 <hyperisco> checked exceptions as a type list / row type
12:34:24 <dolio> In what context? Haskell?
12:34:38 <hyperisco> I was using PureScript but I don't see why the conclusions wouldn't port
12:35:36 <hyperisco> related, that is a language that had a concept of effect rows and removed them, was a hugely breaking change
12:38:13 <dolio> Well, any judgment based on an expectation of GHC type programming doesn't sound relevant, for instance, because I would imagine the point would be to design an exception system with usability in mind, and complicated GHC type hackery is usually the antithesis of that.
12:38:23 <davean> I've used it in a few Haskell projects.
12:38:28 <davean> It wasn't terrible.
12:38:48 <davean> I didn't keep using it.
12:39:15 * geekosaur can't help but think "wasn't terrible" is not a usability milestone to reach for
12:39:23 <hyperisco> there could be a more palatable system out there… but I think we can look at Java and see that isn't it either, though that seems contended. I'm not Java programmer
12:39:45 <dolio> Anything concluded based on Java is also irrelevant.
12:40:13 <davean> http://hackage.haskell.org/package/control-monad-exception is the one I used IIRC.
12:40:24 <hyperisco> you should consider it relevant, because if you exclude yourself from tried examples then how do you avoid repeating them
12:41:04 <hyperisco> your chance of success in designing a better system is lessened if you don't fill these potholes first
12:41:14 <dolio> No, the point is to design a good system, so saying that Java's isn't good doesn't mean that there can't be a good one. This is just the argument that all type systems are bad because Java's is bad.
12:41:29 <hyperisco> that wasn't my argument, but never mind
12:41:51 <davean> Is this discussion going anywhere useful?
12:42:33 <dminuoso> And who knows, perhaps there's some cool ways to build a workable idea into the Haskell type system that either nobody has thought of before, or it hasn't risen to popularity yet.
12:44:08 <dminuoso> I guess the real problem is type inference at the end, it seems like an almost trivial task to build checked exceptions without the backdoors Java has.
12:44:37 <hyperisco> I think it starts with another look at exactly what the problem is and allowing new ideas to come in
12:45:46 <dolio> If the other example is PureScript's Eff, then I think it also isn't a very good example. It was kind of the most bare bones step in that direction, missing a lot of stuff that could potentially make such a system useful. At least, if I recall correctly.
12:46:13 <hyperisco> the need to throw multiple exception types, and now how do we analyse that with types or other static analysis, are the assumptions that need to be revisited
12:46:43 <dminuoso> The last time I had this type of discussion, it was theorized that checked exceptions might perhaps best live in separate type system.
12:47:03 <dminuoso> Id have to dig my logs to find the exact arguments for this
12:47:13 <hyperisco> dolio, it was done away with because it was more work for the programmer without substantial (or I might argue any) payoff
12:48:28 <hyperisco> and it relates because the symptoms are similar… it accumulated effects as a row type, there weren't interesting ways to discharge most of them, so all rows tended to be widened to the union of all effects
12:48:37 <dolio> It was like, 'what if instead of IO there were a bunch of fine grained but still opaque monads, but that's it.' And it turns out that isn't super useful for browser stuff. Just keeping track of FileInput vs. FileOutput in a completely non-acionable way is not useful.
12:48:58 <dolio> Non-actionable, even.
12:49:20 <hyperisco> this concept of effects was without the utility of interpretation, so it isn't to be compared to effect systems
12:50:51 <hyperisco> dolio, no it was even sillier than that, it was more like you had a NOW effect if you called Date.getNow(), and a AJAX effect if you used XmlHttpRequest, and several other made up… lets say "tags"
12:51:26 <hyperisco> the only one I can argue had utility was the EXCEPTION effect, which is caused by  throw  and could be discharged with a  catch
12:51:56 <hyperisco> what is the use of a type… it is found through the ways it is introduced and the ways in which it is eliminated
12:52:01 <dolio> Yeah. Just tracking whether or not you use getNow in particular is not useful.
12:52:40 <hyperisco> the effect rows in PS were almost all with introductions and without eliminations, and so that is how I'd argue they had no use
12:53:00 <dolio> Yeah, but exceptions can be caught.
12:53:08 <hyperisco> they let you look at a definition and say "oh that uses XmlHttpRequest somewhere" and then not do anything about it, seemingly
12:53:17 <dolio> So they are unlike that kind of useless tracking.
12:53:37 <hyperisco> yes, _when_ they can be sensibly caught
12:54:01 <hyperisco> and why would you catch them? because you know what they mean and you can decide something based on that meaning
12:54:24 <hyperisco> and it seems to be that, many times, that just isn't the case
12:55:23 <hyperisco> so a solution should account for the reality that, much of the time, it is an unneeded facility
12:55:47 <geekosaur> that seems to depend on what you're using it for. service? you probably want to catch a lot of stuff for resource management reasons if nothing else. simple client? probably just let it abort
13:02:26 <hyperisco> so I said I hated Haskell exceptions just a while ago… why… well lets ignore the conclusion that all exceptions are a SomeException and can be caught that way
13:02:41 <hyperisco> lets say to catch a thrown exception you had to name the type of that exception exactly
13:03:12 <geekosaur> the ergonomics of that are also something of a problem imo
13:03:23 <hyperisco> then there is a documentation problem of knowing how to catch an exception, because you know not which exception type is thrown or where it is thrown
13:03:50 <hyperisco> and that is something checked exceptions would fix, yes, but so does catching SomeException
13:04:07 <dminuoso> A particularly fancy bit about Haskell and checked exceptions is async exceptions.
13:04:40 <dminuoso> That alone should thwart an attempt at a complete, type-driven, way of checked exceptions.
13:04:54 <dminuoso> I just realized.
13:05:02 <hyperisco> so then we can either assume all IO throws or we could talk about adding the one bit of information to determine if it throws
13:05:21 <dminuoso> hyperisco: It throws. at any time, that means catching doesnt ever remove exceptions
13:05:27 <dminuoso> because after its caught, it could be thrown to you again.
13:05:43 <hyperisco> sure
13:07:14 <hyperisco> just sussing out that there are different facets to what we might consider the problem to be, and it would be smart to not immediately conflate them to necessitate a unified solution
13:11:49 * hackage uuagc 0.9.53.1 - Attribute Grammar System of Universiteit Utrecht  https://hackage.haskell.org/package/uuagc-0.9.53.1 (JeroenBransen)
13:12:09 <dminuoso> I guess the above again recognizes, that async exceptions shouldn't share code with regular exceptions. They should be borderline uncatchable.
13:13:10 <dolio> Yeah, it doesn't make much sense for async exceptions to be checked.
13:13:28 * geekosaur still thinks most non-async exceptions should be ExceptT
13:13:35 <geekosaur> or similar
13:14:28 <geekosaur> except there's a bootstrapping problem between base and mtl if we do that
13:14:48 <hyperisco> indeed that was the term implementation of the checked exceptions I did use
13:15:13 <hyperisco> is as simple as ExceptT and the error type is a variant type, using whatever fancy type features for polymorphic unions
13:17:32 <hyperisco> and as complicated as not all monads work as transformers
13:19:57 <hyperisco> well what do I mean… I mean that stacking ExceptT on another monad does not necessarily give you the semantics you want, which was the case with PureScript's Aff
13:21:49 <hyperisco> why? because if you have an  M a  you can lift it to  ExceptT e M a , but if you take an  ExceptT e M a  you cannot necessarily lower it to  M a
13:22:16 <hyperisco> and you would need to do that if definitions on  M a  themselves took an  M a
13:22:30 <hyperisco> such as… bracketing
13:31:28 <hyperisco> how can I touch a file with Haskell IO? I am on Windows
13:31:39 <hyperisco> I have tried  appendFile path ""  and this seems to leave the file untouched
13:33:04 <hyperisco> I also tried opening the file in append mode, writing the empty string, and closing the handle, and also that left the file untouched
13:33:52 <geekosaur> afaik you need to use system-specific stuff,e.g. there's a touchFile in the unix package and I don't know off the top of my head what the win32 equivalent is
13:34:22 <hyperisco> what if, like a madman, I rename the file
13:36:25 <geekosaur> no idea, sorry
13:54:49 * hackage tasty-rerun 1.1.18 - Rerun only tests which failed in a previous test run  https://hackage.haskell.org/package/tasty-rerun-1.1.18 (Bodigrim)
14:53:19 * hackage keycloak-hs 2.0.3 -   https://hackage.haskell.org/package/keycloak-hs-2.0.3 (CorentinDupont)
14:53:56 <koz_> Does foldM _require_ a Monad constraint to make sense, or could foldA actually exist?
14:57:00 <joel135> hmm
15:02:32 <jle`> :t foldM
15:02:33 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
15:02:43 <jle`> yea that needs to be monady
15:02:58 <jle`> since you have to bind the 'b' to use the (b -> a -> m b)
15:02:58 <koz_> I guess if it was an 'effectful foldMap' it wouldn't?
15:04:00 <jle`> yeah, like traverse_
15:04:06 <jle`> er, traverse
15:04:13 <koz_> Yeah, except a general monoid instead of ().
15:04:23 <jle`> in this case the "next `m b` to use" depends on the result of a previous action
15:04:26 <jle`> :t traverse
15:04:28 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:04:39 <jle`> but for traverse, the "next `f b`" can be decided without any previous actions
15:04:45 <koz_> It'd be like 'foldMapA :: (Applicative f, Monoid m, Traversable t) => (a -> f m) -> t a -> f m'
15:04:46 <Uniaika> (obligatory slides for Traverse: https://clementd-files.cellar-c2.services.clever-cloud.com/lambdalille-traverse.html#1.0 )
15:04:57 <jle`> koz_: that's foldMap with Ap, yeah
15:05:13 <koz_> It's not _quite_ a generalized traverse_.
15:05:17 <koz_> (stronger constraint needed)
15:05:28 <jle`> :t \f -> getAp . foldMap (Ap . f)
15:05:29 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> f a1
15:05:41 <jle`> hm, that's weird
15:05:53 <jle`> it should have the same type as yours
15:05:56 <koz_> Monoid (Ap f a) holds whenever Applicative f, right?
15:06:15 <jle`> (Applicative f, Monoid a) => Monoid (Ap f a)
15:06:39 <jle`> i'm pretty sure your foldMapA is equivalent to traverse_
15:06:58 <koz_> :t traverse_
15:07:06 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:07:24 <jle`> use [b] for m
15:07:24 <koz_> Except that instead of (), we can get back any Monoid m.
15:08:04 <jle`> i think you can implement both in terms of each other
15:10:13 <koz_> I think there's a catch here somewhere.
15:10:13 <jle`> you'd just use Const m or something like that
15:10:13 <jle`> for your Applicative
15:10:13 <jle`> Compose f (Const m)
15:10:21 <koz_> Ah, I see.
15:10:25 <koz_> Yeah that'd work.
15:10:58 <koz_> Would be great to have a helper doing that, admittedly.
15:11:18 <koz_> It reminds me of something I saw in the churros library which permitted a similar generalization.
15:11:42 <jle`> % :t \ff -> fmap getConst . getCompose . traverse_ (Compose . fmap Const . ff)
15:11:42 <yahb> jle`: (Foldable t, Applicative f, Monoid b) => (a -> f b) -> t a -> f b
15:12:01 <jle`> but it'd be easier to write in terms of foldMap
15:12:32 <jle`> % :t \ff -> getAp . foldMap (Ap . ff)
15:12:32 <yahb> jle`: (Foldable t, Applicative f, Monoid a1) => (a2 -> f a1) -> t a2 -> f a1
15:12:52 <jle`> huh you could even flip the Const if you use Ap
15:13:19 <koz_> That's actually interesting - foldMap and foldr can implement each other, but if you throw in effects, you actually can't do that.
15:13:34 <jle`> % :t \ff -> getAp . getConst . traverse_ (Const . Ap . ff)
15:13:35 <yahb> jle`: (Foldable t, Applicative f, Monoid a1) => (a2 -> f a1) -> t a2 -> f a1
15:13:57 <jle`> koz_: well it's kind of up to what you think is the rightful generalization of foldr
15:14:19 <jle`> and foldM isn't necessarily the natural generalization from an applicative standpoint
15:14:26 <koz_> What's another view?
15:14:54 <jle`> maybe foldr :: (f a -> f b -> f b) -> f b -> t a -> f b ?
15:15:10 <jle`> although...i guess that's more of a specialization than a generalization
15:15:45 <koz_> Yeah, it's not actually similar to the foldMapA above, since you gotta stick effects in both negative and positive positions.
15:16:09 <koz_> (in the function argument)
15:16:27 <jle`> hm, i think you can implement foldMapM in terms of foldM
15:16:32 <jle`> you just need Monad in both cases
15:16:36 <jle`> so they can still implement 'each other'
15:16:56 <jle`> and you can always use foldMapA with monads too
15:17:00 <koz_> Yes, that's true.
15:17:09 <koz_> But the reverse direction doesn't (necessarily) hold.
15:17:10 <jle`> so, you can implement foldM with foldMapA :)
15:17:31 <jle`> hm, i wonder if you can implement foldMapA with foldM
15:17:53 <jle`> i thiiink it should be possible actually
15:17:53 <koz_> I mean, yeah. Your starting value is the mempty.
15:18:00 <jle`> just use foldM to get [m a]
15:18:03 <jle`> and foldMapA id
15:18:06 <koz_> Lol.
15:18:09 <koz_> Ah yes.
15:18:13 <koz_> 'Hack everythign into list'.
15:18:21 <koz_> Aka 'how all of Foldable works'.
15:19:12 <koz_> Although realistically, by its very nature, 'toList' falls out of Traversable even if Foldable weren't a thing.
15:19:50 <koz_> (or heck, toX, where X is some linear collection with concatenation and emptiness as concepts)
15:20:07 <koz_> (or heck, it doesn't even technically have to be a _linear_ collection)
15:24:40 <jle`> yeah, Foldable is baby Traversable :)
15:25:37 <koz_> And basically, we get 'emptiness and concatenation' as a special case of Monoid.
15:25:50 <koz_> Basically, it really is all traverse and monoids all the way down.
16:17:31 <crestfallen> Hi .. I understand most of this paste. it clarifies that (->) is not a morphism (I guess a morphism cannot be binary?) ; and that fmap for Functor (-> r) is composition. So generally fmap is a morphism, perhaps the most basic one? https://termbin.com/evcw
16:19:02 <crestfallen> I see how the expansion of (->) r (fmap) is composition.
16:21:56 <crestfallen> so my question is, if the above is correct, are there morphisms more simple than fmap?
16:22:32 <bsima> how do i convert a Decimal to a Float or Int?
16:22:54 <Axman6> what's a Decimal?
16:22:59 <bsima> Data.Decimal
16:23:00 <ghoulguy> probably: realToFrac and truncate
16:23:28 <ghoulguy> truncate or round, depending on which behavior you want
16:24:00 <Axman6> :t realToFrac
16:24:01 <lambdabot> (Real a, Fractional b) => a -> b
16:24:43 <crestfallen> or are there morphisms I've probably come across before?
16:24:49 <bsima> i think realToFrac is what I wanted, thanks
16:25:56 <crestfallen> also I'm trying to see if and how (->) r is partial application
16:26:20 <crestfallen> a bit confused..
16:27:02 <Axman6> it's a partial application of the type (->) but doesn't represent partial application of functions to values - ((->) r) is all functions which can accept an r
16:27:04 <lyxia> crestfallen: I'm not sure what you mean by "morphism"
16:27:25 <crestfallen> https://termbin.com/evcw  lyxia it's the blurb at the top
16:28:07 <crestfallen> all functions which can accept an r Axman6   ...
16:28:15 <lyxia> crestfallen: I don't find that paste particularly good, notably because it starts by using the word "morphism" in an unconventional way, if it makes sense at all.
16:28:44 <crestfallen> really ok. lyxia thanks, what about below the paragraph though?
16:30:38 <lyxia> The important part is that ((->) r) is a mapping from types to types, that's the first condition for something to be in the Functor class in Haskell.
16:31:37 <lyxia> But it's worth mentioning that the Functor class in Haskell is itself a restriction of amuch more general idea of functors in category theory, where they don't necessarily map types to types.
16:32:46 <lyxia> So this paragraph is talking in terms of categories about the very restricted notion of Functor in Haskell, that's bound to mix up ideas and confuse people.
16:33:06 <crestfallen> yeah, i.e. an object doesn't need to be a type. like it can be a group I think lyxia 
16:36:56 <monsterchrom> Who wrote that?
16:37:18 <crestfallen> thanks lyxia and Axman6    monsterchrom one sec
16:37:55 <lyxia> monsterchrom: did you change your nick
16:38:02 <monsterchrom> There is a reason in a 1st-year linear algebra course we don't go "use the Yoneda lemma to prove that every elementary row operation is representable by multiplying by a matrix", even though it is totally true.
16:38:11 <monsterchrom> Yeah Halloween theme
16:38:52 <wretchswollen> I need to find the source monsterchrom . I probably doctored the paragraph to the best of my understanding
16:39:46 <monsterchrom> There is totally no point in bringing up objects and morphism in Haskell. Not even in the context of the Functor type class.
16:40:25 <lyxia> ^
16:40:30 <monsterchrom> Alternatively if the purpose is learning category theory, then learn from a proper category theory book independent of Haskell.
16:40:32 <wretchswollen> ok I read bartosz a bit and it often goes there..
16:40:46 <wretchswollen> I think it might be from that quarter
16:41:04 <monsterchrom> I actually looked in Bartosz's and can't find it.
16:41:16 <wretchswollen> not sure, I certainly didn't write it
16:41:59 <wretchswollen> I'll delete it. I like the exercise of getting to fmap = (.)
16:42:07 <monsterchrom> Bartosz's is a case of "category theory for programmers" so first of all if you are not already a good programmer, one that has written 1000 lines of correct code, you can't use it.
16:42:48 <monsterchrom> I don't understand how one looks at "category theory for programmers" and infers "so this is good for learning both at the same time".
16:43:07 <wretchswollen> yeah it's tough. sometimes things do stick. I got a lot from a lesson on the kleisli operator
16:43:38 <wretchswollen> it helped me understand bind better
16:44:04 <monsterchrom> Then again I also don't understand how there can be undergrad students who look at "prerequisite of this course" and can mentally edit it to "co-requsite of this course" and then email me "can I take your course and the prereq course at the same time? like it makes perfect sense?"
16:44:52 <wretchswollen> I had it easy: I studied Literature and my mom taught me to read well.
16:46:19 <wretchswollen> thanks monsterchrom that takes the load off. but to be honest I'm still thinking about Axman6 's   " ((->) r) is all functions which can accept an r "
16:47:06 <koz_> monsterchrom: I would make a funny joke here, but I don't think I can think of two things where 'pre-X' and 'co-X' both exist
16:47:12 <koz_> Like, are cosheaves a thing?
16:48:09 <wretchswollen> yeah like I tried to sit in on abstract algebra, when pre algebra and calculus was 30 years old
16:48:20 <wretchswollen> were*
16:48:35 <wretchswollen> I meant preCalculus
16:49:47 <wretchswollen> but hey, I'm beginning to understand bind, and yesterday made a huge headway with traversable
16:52:03 <Axman6> data Foo f = Foo { bar :: f Int,baz :: f Bool }; type ReadFoo = Foo ((->) String) -- ReadFoo ~= Foo {bar :: r -> Int, baz :: r -> Bool}. ((->) String) is the functor for functors which can accept Strings
16:54:01 <jcowan> A speculative question:  I realize that Haskell patterns are fixed.  But suppose they were extensible. What would matching against a procedure plausibly mean?
16:54:01 <Axman6> for functions*
16:54:28 <Axman6> jcowan: like view patterns?
16:54:46 <Axman6> or something else
16:56:11 <wretchswollen> working...
16:56:29 <tput> I'm writing an fft as an exercise. I have a vector of values which I need to divide into two sub vectors, composed of every other element. How can I do this *quickly*? Basically I'm looking for a performant stride or slice. I'm happy to change from vector to array or any other similar datatype.
16:57:16 <wretchswollen> thanks Axman6 
16:57:20 <Axman6> tput: one way I've seen this done is how Repa would do it, where you just use functions to reindex into the original array
16:57:25 <koz_> tput: By 'quickly' I assume you mean O(1)?
16:57:50 <jcowan> Are view patterns implemented now?
16:57:51 <koz_> If so, delayed arrays are indeed what you want - you'll be well-served by massiv, I think.
16:58:05 <Axman6> they have been implemented for years jcowan
16:58:06 <tput> yeah, I'd ideally like a reindexed view into the original data structure without copying
16:58:21 <koz_> tput: Ah, then you can use generate from vector.
16:58:37 <koz_> If you wanna be _sure_, then massiv's delayed arrays are what you're after.
16:58:55 <koz_> generate will _likely_ fuse, but I can't promise much.
16:59:05 <Axman6> > let f ((\x -> x `mod` 3 == 0 && x `mod` 5 == 0) -> True) = "FizzBuzz"; f x = show x in map f [1..20]
16:59:08 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","FizzBuzz","16...
16:59:25 <jcowan> Okay, thanks.  I was under the impression they were part of Haskell at one time and then withdrawn.
17:01:35 <tput> at a glance it looks like generate will copy data to a new vector, which isn't ideal. but it might be good enough. I'll give it a try, thank you koz_ 
17:01:42 <koz_> tput: It might fuse.
17:01:52 <koz_> No way to know without looking at what gets emitted.
17:02:07 <koz_> Again, if you want _certainty_, delayed arrays from massiv.
17:02:47 <tput> lol, indeed. rewrite rules are a blessing and a curse. I have used massiv before, but was hoping to avoid the dependency at the moment. Thanks again!
17:03:05 <koz_> No worries. I think your use case is _exactly_ where delayed arrays shine.
17:03:21 <koz_> Massiv also has a bunch of cool things that might be useful for FFTs (stencilling, for example).
17:03:45 <Axman6> is massiv basically Repa 2.0?
17:03:59 <koz_> Axman6: I guess?
17:04:01 <tput> p.s. am I speaking to Domen? I'm definitly on the sidelines of the haskell community, but I'm trying to be a little more involved.
17:04:04 <MarcelineVQ> it's like repa but bigger
17:04:11 <koz_> tput: I am not Domen Kozar.
17:04:18 <koz_> (much as I sometimes wish I was)
17:04:23 <tput> ah, took a guess on the user name, sorry.
17:04:35 <Axman6> koz_: don't let your dreams by dreams
17:04:36 <koz_> Not a bad guess. I'm some variant of 'Koz' everywhere.
17:04:49 <Axman6> be*
17:04:50 <koz_> Axman6: Don't let your grammar by grammar either.
17:04:52 <MarcelineVQ> don't let your memes be beans
17:05:38 <tput> well now it feels like a small puzzle
17:05:58 * Axman6 insists on pronouncing koz_ "cuz" in his mind
17:06:03 <koz_> Basically massiv takes some adjusting to, but it's _really_ good if you genuinely care about speedy arrays.
17:06:07 <koz_> Axman6: LOL
17:06:14 <koz_> I have a cousin with axes for hands.
17:06:23 <koz_> Apparently.
17:06:27 <Axman6> I guess that makes us family
17:06:37 <koz_> LOL
17:08:32 <Axman6> probably a better relative than Axman13, the dumbass blacksheep of the family: https://newgrounds.fandom.com/wiki/Dot_Dot_Dot_-_Animated
17:09:13 <MarcelineVQ> the cutscenes were pretty good
17:09:20 <koz_> Well, new family is always nice to discover.
17:09:36 <koz_> Good work for someone with axes for hands for sure.
17:09:46 <MarcelineVQ> I think mick would be sad to know he's still best known for dot dot dot :>
17:09:55 <Axman6> You only press One ButtEN!
17:10:38 <koz_> Yeah, so you can do it with the flat of the axe.
17:10:43 <koz_> So you don't ruin your keyboard.
17:11:46 <hololeap> i imagined them using a giant keyboard with stumps for keys
17:11:49 <koz_> I think our branch of the family made different strategic choices, as I'm (actually) related to someone who goes by 'daggerman13' online.
17:14:06 <wretchswollen> Axman6, sorry what's the trick to get fizzbuzz to work in ghci . I'm getting "Illegal view pattern" for the lambda part
17:16:43 <tput> :set -XViewPatterns
17:17:30 <wretchswollen> oh thanks tput
17:37:19 * hackage sbv 8.9 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.9 (LeventErkok)
18:10:19 * hackage which 0.1.0.1 - Determine the full path to an executable.  https://hackage.haskell.org/package/which-0.1.0.1 (abrar)
18:37:12 <magnuscake> Hey guys. So I'm currently diving into understanding typeclass and instances and I came across this syntax
18:37:20 <magnuscake> data Trivial =
18:37:27 <magnuscake>   Trivial'
18:37:35 <magnuscake> instance Eq Trivial where
18:37:46 <magnuscake>   Trivial' == Trivial' = True
18:37:53 <magnuscake> My question is why are we using Trivial' instead of Trivial? Don't they technically mean the same thing?
18:38:08 <c_wraith> One is the name of the type, the other is the name of the constructor
18:38:20 <c_wraith> did you misread "data" as "type" in the declaration?
18:38:34 <c_wraith> I wish introductory materials never mentioned "type".  It more or less shouldn't be used.
18:38:48 <magnuscake> Sorry so Trivial' is the type in this case?
18:39:05 <c_wraith> No, Trivial is the type.  Trivial' is the data constructor
18:39:53 <magnuscake> Ah yeah that makes sense
18:40:55 <magnuscake> Yeah it does make it difficult to keep track of type and constructor in the beginning
18:42:18 <c_wraith> The funny thing is that I'm sure that example used that because they think it's too confusing when a type and its constructor have the same name
18:42:40 <c_wraith> Even though I'm sure no one has ever been confused by (,) having the same name as a type and as a constructor
20:16:49 * hackage predicate-typed 0.7.4.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.4.0 (gbwey)
20:38:49 * hackage esqueleto 3.4.0.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.4.0.0 (parsonsmatt)
20:42:26 <juliusdeane> what's the process for specifying a dependency from github with cabal2nix?
22:34:19 * hackage hurl 1.4.2.1 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.4.2.1 (alcinnz)
23:22:49 * hackage persistent-vector 0.2.0 - A persistent sequence based on array mapped tries  https://hackage.haskell.org/package/persistent-vector-0.2.0 (TristanRavitch)
23:39:40 <eedgit> Writing a test for a rotation function, I'm using an auxiliary function (which I think is the best way to keep as much 'pure' ?). Should I be testing for both functions - or is only 1 needed? https://dpaste.org/4NYa
23:43:56 <dsal> The concept of a property is something that's meant to be true about your function.  Neither `streamPop` nor `prop_stream` communicate a whole lot about what they're meant to do.   If `rot` is what you're trying to write, then what interesting properties does it have?
23:55:38 <eedgit> dsal Thanks I'll have a think - is there a more appropriate name? streamPop made sense to me as take->drop->cycle felt like 'popping' the values out using a sliding-window over a 'stream' (the infinite/circular list)
23:56:02 <dsal> e.g., if you replace the implementation of `streamPop` with `flip const` your property holds.  However, if you test `rot` there may be interesting properties such as `rot == transpose . rot`
23:56:33 <dsal> It's just a list of the rotations.  You could call it `rotations` or something.  Naming is hard.
23:58:19 <dsal> > iterate (\(x:xs) -> xs <> [x])  "abc"
23:58:21 <lambdabot>  ["abc","bca","cab","abc","bca","cab","abc","bca","cab","abc","bca","cab","ab...
23:58:21 <eedgit> cool thanks :) 
