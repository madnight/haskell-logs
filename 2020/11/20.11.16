00:00:17 <dminuoso> Finally a non annoying way to use fromIntegral and realToFrac :>
00:01:11 <bahamas> ok, I guess multiline mode doesn't help with multiline strings
00:04:41 <yushyin> dminuoso: lol
00:15:45 <merijn> dminuoso: I will haunt your dreams >.<
00:16:26 <merijn> bahamas: tbh, I would just abandon multiline ghci use entirely, any "support" for it was ad hoc hacked into it
01:05:54 <moet> glguy: ah, i'll have to get back to you on that tomorrow.. 
01:07:36 <Ivan__1> q
01:11:34 <runeks> Anyone know a mirror for https://downloads.haskell.org/~ghc/8.8.3/ghc-8.8.3-x86_64-apple-darwin.tar.xz? I'm getting 20-30 KB/s from that link...
01:12:19 <dminuoso> runeks: https://distfiles.macports.org/ghc/
01:12:26 <dminuoso> Be sure to check the signatures against the ones from haskell.org
01:14:26 <runeks> @dminuoso Thank you! I checked the hash and it matches that of the haskell.org file.
01:14:26 <lambdabot> Unknown command, try @list
01:14:38 <runeks> dminuoso: Thank you! I checked the hash and it matches that of the haskell.org file.
01:18:48 <dminuoso> merijn: What can I say, my code is plastered with putWord8/putWord16be/putWord32be
01:19:02 <dminuoso> And sadly I cant track Word8/Word16/Word32 cleanly through
01:19:49 <dminuoso> So what I realistically do is, I keep them as Word32 and narrow wherever. Validation before serialization will catch potential bugs here.
01:25:57 <merijn> Hopefully ;)
01:29:24 <dminuoso> Well, for deserialization I could use int-cast I guess
02:10:19 <Martinsos> Hi all! I am not so new to Haskell, but I am new to IRC - any best practices to share on how to get most of haskell IRC channel? I am usually on reddit but I heard haskell IRC channel is the best place to learn/ask. I am right now using ERC in Emacs, but I am not sure how to go about it since I can't see the old messages -> do you have IRC turned on all the time? Do you also use ERC in Emacs or do you use smth else? What is your
02:10:19 <Martinsos> workflow about participating in IRC while also getting stuff done? Thanks!
02:11:50 <merijn> Some people stay logged in all the time via a "bouncer" (basically a VPS forwarding to your local machine), but personally I just treat IRC as transient, there is not much point in attempting to keep up with everything that happens
02:15:19 <Martinsos> merijn: do you keep it open in separate window, or if you are using it through emacs do you just keep the buffer in the background and open it every so and so?
02:15:56 <merijn> I don't use emacs at all :p I just have it open in a seperate tmux window
02:16:48 <[exa]> Martinsos: I got permanently running irssi on a server, connecting just with ssh+tmux
02:17:07 <Martinsos> merijn: ok great, thanks a lot :)! I also just realized there are logs at tunes.org, so that is also useful.
02:17:20 <merijn> Also https://ircbrowse.tomsmeding.com/haskell
02:17:23 <Martinsos> merijn++
02:18:00 <Martinsos> @karma Martinsos
02:18:00 <lambdabot> You have a karma of 0
02:18:12 <Martinsos> @karma merijn
02:18:12 <lambdabot> merijn has a karma of 76
02:19:10 <Martinsos> [exa]++
02:21:37 <[exa]> Martinsos: worry not, karma tracks itself here
02:22:16 <Martinsos> [exa]: Aha, what do you mean by that, how does it track itself?
02:24:50 <boxscape> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
02:24:50 <lambdabot> Data.Tuple.Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
02:24:50 <lambdabot> Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
02:24:51 <lambdabot> Control.Wire.Core (&&&!) :: (a -> b) -> (a -> c) -> (a -> (b, c))
02:25:01 <boxscape> hmm it doesn't find the Arrow one
02:29:15 <boxscape> @pl \(^.) -> ((^.bla) &&& (^.foo))
02:29:15 <lambdabot> (line 1, column 3):
02:29:15 <lambdabot> unexpected "^"
02:29:15 <lambdabot> expecting pattern
02:29:23 <boxscape> this is a lambdabot restriction, right?
02:29:31 <boxscape> or pointless restriction, rather
02:33:21 <merijn> pl is rather dumb
02:33:30 <merijn> It doesn't properly parse Haskell, iirc
02:34:13 <boxscape> I see
02:35:27 <merijn> > (\(^.) -> 5 ^. 3) (+)
02:35:29 <lambdabot>  8
02:35:35 <merijn> Seems to work :)
02:40:50 <Martinsos> > 314 + 42
02:40:53 <lambdabot>  356
04:04:53 * hackage Z-Data 0.1.9.0 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.9.0 (winterland)
04:43:52 * hackage vulkan 3.6.15 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.15 (jophish)
04:48:52 * hackage hpqtypes-extras 1.10.3.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.10.3.0 (arybczak)
05:20:07 <tomjaguarpaw> Can I disable the garbage collector temporarily at run time and then re-enable by running some IO action?
05:20:25 <merijn> tomjaguarpaw: Not really
05:20:31 <merijn> tomjaguarpaw: Why?
05:20:37 <tomjaguarpaw> For benchmarking
05:20:52 <tomjaguarpaw> or at least to determine whether it's GC that's taking time in my benchmarks
05:20:57 <merijn> tomjaguarpaw: You can *force* a collection ahead of time
05:21:15 <tomjaguarpaw> Hmm, OK, that will be a good start
05:21:23 <merijn> tomjaguarpaw: That's what criterion does. Fully evaluate all data structures before benchmark, then trigger GC explicitly, then benchmark
05:21:31 <merijn> Which should make major collections unlikely
05:21:45 <tomjaguarpaw> How do I do that?
05:21:51 <merijn> @Hoogle performGC
05:21:52 <lambdabot> Maybe you meant: hoogle google
05:21:55 <merijn> @hoogle performGC
05:21:55 <lambdabot> System.Mem performGC :: IO ()
05:21:55 <lambdabot> BasePrelude performGC :: IO ()
05:21:55 <lambdabot> Pipes.Concurrent performGC :: IO ()
05:23:53 <tomjaguarpaw> merijn: Cool, thanks! I will give it a go.
05:24:03 <merijn> tomjaguarpaw: You can study how criterion works too
05:24:11 <merijn> (or just use criterion if possible :p)
05:40:52 * hackage git-annex 8.20201116 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20201116 (JoeyHess)
06:25:48 <kuribas> How do I model some subtype relation with classes?  For example A contains some B, B contains some C, then I want a function that gives me all C in A.
06:26:17 <kuribas> like "allChildren someA @C"
06:26:37 <kuribas> I could do this with overlapping type-classes, but they aren't recommended?
06:26:58 <merijn> kuribas: tbh, what your asking also sounds "not recommended" :p
06:27:29 <kuribas> merijn: so you would model every combination of subsets?
06:27:53 <merijn> You're going to have to get a lot more specific about what that even means :)
06:29:20 <kuribas> well in lisp we have (select :park :sensor-box), and it would return all sensor-boxes in a park.
06:29:30 <geekosaur> ti sounded more like generics than classes to me
06:31:28 <kuribas> merijn: or you would explicitly compose them?
06:31:54 <kuribas> like parkInverters >>> inverterSensorBoxes
06:32:34 <merijn> kuribas: Are you maybe (accidentally) trying to reinvent the cursor stuff from xml-conduit?
06:33:33 <kuribas> well, I have a containment relation.
06:33:44 <merijn> kuribas: https://hackage.haskell.org/package/xml-conduit-1.8.0.1/docs/Text-XML-Cursor.html
06:34:08 <merijn> This handles exactly queries like "all XML tags with property Y starting from node X" style queries
06:34:19 <merijn> Which sounds similar to what you're doing?
06:34:27 <kuribas> merijn: yeah
06:34:33 <kuribas> merijn: but this goes to the DB
06:35:53 <kuribas> merijn: another example is a class relationship.  Let's say I have a "attribute" type.  (Attribute class tp), meaning I can extract a value of "tp" from an object of type "Object class"
06:36:17 <kuribas> So "get :: Object class -> Attribute class tp -> m tp"
06:36:30 <kuribas> But class has superclasses.
06:37:25 <kuribas> so I want "get :: SuperClassOf class2 class1 => Object class1 -> Attribute class2 tp -> m tp"
06:37:38 <kuribas> but then that only works if I use overlapping instances.
06:37:52 <merijn> I would personally never contemplate going this route
06:37:54 <kuribas> to get the transitive closure of superclasses.
06:38:01 <kuribas> merijn: which route would you go then.
06:38:02 <merijn> This'll all end in tears
06:38:20 <kuribas> tell me which route well end in happiness
06:38:29 <merijn> I don't really know what I *would* do, because I've never attempted this
06:39:09 <merijn> kuribas: I would probably try and encode the accesors as a GADT and then just have transformers that can map them to their containing objects
06:39:12 <kuribas> of course I could invent a "fancy haskell" solution, using type level lists, etc...
06:39:42 <merijn> Any sort of "inheritance" style design with typeclasses always ends in cryptic errors, overlapping/incoherent instance nightmares, etc.
06:41:46 <kuribas> merijn: I could make a custom type error
06:42:02 <merijn> If "Attribute class tp" was a datatype with just the explicit function to make the appropriate lookup you can then define a Category and Profunctor instance and then generalising is just contramap the class type to the more general type
06:42:30 <tomjaguarpaw> Can I get access to RTS statistics at run time? I would like to see if it really is garbage collection that is causing my strange performance.
06:42:36 <merijn> tomjaguarpaw: Yes
06:42:45 <tomjaguarpaw> Where do I look for those?
06:42:51 <merijn> tomjaguarpaw: Somewhere in the GHC.* modules in base
06:43:13 <kuribas> merijn: you mean explicit subtyping?
06:43:34 <merijn> I mean "forgetting the term subtyping entirely"
06:44:01 <kuribas> like: asClass :: IsSubClass a b => Attribute a tp -> Attribute b tp
06:44:15 <kuribas> merijn: the model is already subtyped, I cannot change that.
06:44:25 <tomjaguarpaw> Hmm GHC.Stats, I guess
06:44:32 <merijn> Except, if Attribute is a datatype and has a profunctor instance then you don't even need IsSubClass or anything
06:44:39 <merijn> You just need a function "a -> b"
06:45:24 <kuribas> merijn: but class is just a phantom type to ensure you don't send an attribute to the wrong object.
06:45:53 <kuribas> merijn: so a function a -> b is impossible.
06:46:26 <kuribas> a and b are uninhabited
06:48:34 <merijn> So, that just means you can't use profunctor. You can define a Convertible type with phantom attributes (probably as GADT or data family?) and then have "Convert a b -> Attribute a tp -> Attribute b tp" or something?
06:49:51 <kuribas> what's so bad about overlapping instances?
06:50:21 <hekkaidekapus> tomjaguarpaw: 1) ghc -O2 -eventlog M.hs 2) ./M +RTS -lau 3) Roam Hackage searching the best events analyser for your liking.
06:51:48 <hekkaidekapus> tomjaguarpaw: <https://www.well-typed.com/blog/2019/09/eventful-ghc/>
06:53:11 <merijn> kuribas: Instance selection is implementation defined and may change depending on which instances are defined/exposed in your dependencies
06:53:32 <kuribas> merijn: they are all predefined
06:53:51 <merijn> hekkaidekapus: THat's not at runtime, though
06:53:58 <merijn> hekkaidekapus: At least not *within* the code
06:55:05 <hekkaidekapus> merijn: Not within the code but profiling an executable for GC events may be more helpful.
06:57:23 * hackage prolude 0.0.0.8 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.8 (goolord)
07:05:21 <magicman> The fact that Data.Map.Merge.{Lazy,Strict} exist makes me happy. Thanks to whomever did this. I don't know how long they've been there, but they're great.
07:06:30 <merijn> I think micro-optimising that stuff in containers is David Feuer's baby?
07:21:01 <siraben> Why would you need both lazy and strict map merging?
07:21:49 <merijn> siraben: If you need to combine values for existing keys then how you do that depends on whether you have a strict or lazy map :p
07:22:36 <siraben> I see. Does Data.Map default to strict or lazy?
07:23:02 <merijn> Data.Map exports lazy
07:23:17 <merijn> You need to import Data.Map.Strict for strict
07:23:20 <siraben> I see.
07:23:41 <merijn> (Note that the datatype is the same in both modules, only the functions chance)
07:24:35 <siraben> I've used IntMap to represent the store in a Scheme interpreter. Is that best strict or lazy?
07:26:56 <merijn> siraben: The Map itself is always strict, so strict/lazy refers to the elements stored in it. So lazy map stores the (lazy, unevaluated) computation as value, whereas strict will store the evaluated thing as value
07:27:32 <merijn> So if you have a map storing "small" values (like Int) and you know that computing the value is cheap and/or you will always use all values, then you probably want strict
07:29:15 <siraben> The IntMap can be strict but grow unbounded in size right?
07:29:24 <merijn> because storing an int obviously costs less space than an arbitrary thunk
07:29:42 <siraben> https://github.com/siraben/r5rs-denot/blob/126031d43b222dd1056f93e8fa078317c8701d2d/src/SchemeTypes.hs#L107
07:29:44 <merijn> siraben: strict just means that "values are evaluated to WHNF when you insert them"
07:30:12 <siraben> Sounds like I'd want a strict IntMap then since these values are Scheme values or functions
07:32:16 <tomjaguarpaw> I've just noticed something very amusing. I can't pass +RTS to my executable when invoking cabal v2-exec because it as swallowed by cabal itself.
07:33:08 <merijn> tomjaguarpaw: Use -- before the +RTS
07:33:32 <merijn> tomjaguarpaw: So "cabal v2-exec myexe -- +RTS ..."
07:34:07 <reactormonk> I'm on "which recursion scheme function do I use?". I've got Recursive / Corecursive instances over my AST. I wanna change an annotation (and its type). That annotation depends on the value of the current node and its leaves.
07:34:56 <merijn> tomjaguarpaw: Someone already thought of and solved that problem ;)
07:35:28 <tomjaguarpaw> What a clever person.  And if there are two levels of nesting, -- -- ?
07:35:35 <tomjaguarpaw> I just used -with-rtsopts :D
07:37:13 <merijn> tomjaguarpaw: No clue, I've never had that problem nested doubly before :p
07:45:53 * hackage Z-Data 0.1.9.1 - Array, vector and text  https://hackage.haskell.org/package/Z-Data-0.1.9.1 (winterland)
07:48:27 <kuribas> merijn: I can make this work without overlapping instances.  It's just more ugly.
07:48:51 <kuribas> merijn: I would need a extra phantom type in the multiparam typeclass
07:49:06 <kuribas> merijn: A boolean to signify "stop searching"
08:06:03 <dminuoso> 15:43:39       kuribas | like: asClass :: IsSubClass a b => Attribute a tp -> Attribute b tp
08:06:08 <dminuoso> kuribas: Take a look at optics
08:06:20 <dminuoso> They implement a hierarchy with subtyping, supported by type families
08:06:42 <dminuoso> Including utilities to calculate least upper bounds
08:06:52 <dminuoso> See
08:06:54 <dminuoso> https://hackage.haskell.org/package/optics-core-0.3.0.1/docs/Optics-Internal-Optic-Subtyping.html#t:Is
08:06:58 <dminuoso> https://hackage.haskell.org/package/optics-core-0.3.0.1/docs/Optics-Internal-Optic-Subtyping.html#t:Join
08:07:10 <dminuoso> And https://hackage.haskell.org/package/optics-core-0.3.0.1/docs/Optics-Internal-Optic.html#v:castOptic
08:07:43 <dminuoso> (It's very boilerplaty, but it works because the hierarchy is pretty much fixed in size.)
08:10:27 <kuribas> dminuoso: actually, that should work for my case!
08:11:27 <kuribas> I don't even need type families IMO...
08:12:19 <dminuoso> Depends on what your goals are. Here, the Join type family is useful because if you compose two optics, the resulting optic is their least upper bound
08:12:35 <dminuoso> (i.e. A_Prism composed with A_Lens gives you An_AffineFold)
08:14:12 <kuribas> instance IsA k k; IsA MySubClass b => instance IsA b MyClass
08:14:52 <kuribas> ah no, that's overlapping...
08:30:20 <tomjaguarpaw> Hmm, so according to getRTSStats GC is taking a lot (80%) of the time of the function I want to benchmark
08:30:42 <kuribas> dminuoso: nevermind, these are generated, I could as well generate instance for every possible superclass.
08:30:46 <tomjaguarpaw> Well, about 3% for small input data and 80% for large input data (the input data are expression trees)
08:31:26 <Uniaika> tomjaguarpaw: :o
08:31:49 <dminuoso> kuribas: Im not telling you this is how you should do it, just as an inspiration perhaps.
08:32:06 <dminuoso> The underlying implementation works because the inheritance is given by constraint mixing.
08:32:22 <dminuoso> (So castOptic relies on constraint implications to work properly)
08:33:23 <dminuoso> class Is k l where implies :: (Constraints k p => r) -> (Constraints l p => r)
08:33:34 <kuribas> dminuoso: looks complicated ...
08:33:56 <dminuoso> kuribas: Well the idea is rather simple really
08:34:09 <Uniaika> tomjaguarpaw: would you need mutable datastructures?
08:34:26 <dminuoso> kuribas: Handwavingly, an optic is something of type: type Optic c s t a b = forall p. c p => p a b -> p s t
08:34:30 <kuribas> dminuoso: so my solution would verbose but simple: data SomeClass; instance IsSubClass SomeClass SuperClass; instance IsSubClass SomeClass SuperClassOfSuperClass
08:34:34 <dminuoso> Where c is some constraints
08:35:16 <dminuoso> So `type Lens s t a b = forall p. Strong p => p a b -> p s t`
08:35:34 <dminuoso> And `type Prism s t a b = forall p. Choice p => p a b -> p s t`
08:35:50 <kuribas> for a funny definition of "simple"
08:35:53 <dminuoso> Hold on!
08:36:16 <kuribas> dminuoso: you don't need to convince me, this is meant for haskell newbees.
08:36:34 <dminuoso> `type AffineTraversal s t a b = forall p. Visiting p => p a b -> p s t`
08:36:38 <dminuoso> kuribas: The idea now is:
08:37:11 <dminuoso> Strong and Choice give you Visiting.
08:38:29 <dminuoso> Because: class (Choice p, Strong p) => Visiting p
08:43:24 <dminuoso> kuribas: *sorry there was a typo. The other way around, Visibility implies Choice and Strong.
08:44:37 <kuribas> dminuoso: that's hardly easy...
08:44:41 <dminuoso> So if you plug in something that gives Visiting, then you can also treat this as Choice and Strong
08:45:08 <kuribas> I just feel that most of what is in lens is fluff
08:45:20 <kuribas> it's nice, and cool it's possible, but not that necessary
08:45:41 <kuribas> there's a small core which is very useful, like lenses, prisms, traversals
08:50:32 <tomjaguarpaw> Uniaika: I'm not sure what you mean "Would I need mutable datastructures". Everything I am doing is without mutation
08:50:43 <kuribas> dminuoso: if I want to put emphasis on the benefits of haskell to a non-haskell programmer, and I show them this, they think I am crazy.
08:50:46 <tomjaguarpaw> Are you saying mutable data structures could cause less garbage?
08:51:41 <merijn> tomjaguarpaw: Are you, by any chance, using the threaded runtime system?
08:51:47 <Uniaika> tomjaguarpaw: well, if you're applying a lot of transformations on an immutable datastructure, it produces a lot of garbage, right?
08:51:49 <tomjaguarpaw> Not knowingly
08:52:02 <merijn> Uniaika: That's not really relevant, though
08:52:05 <tomjaguarpaw> I don't have "-threaded" in my cabal file
08:52:08 <Uniaika> merijn: alright
08:52:10 <merijn> Uniaika: GC time doesn't scale with amount of garbage
08:52:21 <Uniaika> merijn: oh? my bad :)
08:52:23 <merijn> Uniaika: GHC's GC scales with "amount of non-garbage"
08:52:30 <kuribas> but ghc is optimized for lots of garbage.
08:52:40 <justsomeguy> What does the “temp->data = value;” in the code sample here https://en.wikipedia.org/wiki/Linked_list#Singly_linked_lists mean? Is this like “data.value = temp”, where ``data.value`` is a record data with a field value?
08:52:42 <tomjaguarpaw> I have large amounts of non-garbage, but perhaps only 1GB
08:52:45 <kuribas> using mutable data can be even worse.
08:52:47 <merijn> Uniaika: For exactly this reason, lazy evaluation produces *tons* of garbage :)
08:53:06 <merijn> tomjaguarpaw: Oh, yes, that can hurt you
08:53:10 <Uniaika> kuribas: TIL, thanks for correcting me
08:53:23 <Uniaika> merijn: I'm interested in knowing more about how non-garbage affects GC times
08:53:24 <merijn> tomjaguarpaw: Is this large amount constant during most of your application?
08:53:49 <tomjaguarpaw> No, it's the benchmark input data
08:54:05 <tomjaguarpaw> So I generate something that's about 1 GB, run a function on it, GOTO 10
08:54:14 <merijn> Uniaika: GHC uses a "copy & compact" collector, so when GC is triggered, we allocate a new heap and copy all "live" (i.e. non-garbage) data to the new heap, and then throw away the entire old heap
08:54:33 <merijn> Uniaika: So if there's only 20 bytes of live data and 20 GB of garbage, you only copy 20 bytes and are done
08:54:57 <Uniaika> oh my, this is indeed genius when you have lots of garbage
08:55:01 <merijn> tomjaguarpaw: Ok, rephrase, this input should be independent of your benchmark, yes
08:55:06 <merijn> Uniaika: It has some other benefits too
08:55:20 <tomjaguarpaw> What do you mean by "independent"?
08:55:59 <merijn> Uniaika: One problem with many GC solutions is "fragmentation" i.e. if all your data is scattered throughout your memory, it can be hard to find space to allocate huge chunks. Compacting avoids this by resulting in zero fragmentation
08:56:24 <merijn> tomjaguarpaw: Well, you can use a compact region to GC you 1 GB ahead of time and make future GC (during your benchmark) essentially free
08:56:52 <merijn> Uniaika: There's another benefit. If all data in your heap is compact at the start of your heap, your allocator becomes *really* cheap
08:56:59 <tomjaguarpaw> Interesting. I have never done that.
08:57:12 <tomjaguarpaw> That sounds nice.
08:57:23 * hackage lz4-hs 0.1.5.1 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.5.1 (vmchale)
08:57:44 <merijn> Uniaika: Basically, your allocator is just "a pointer to the end of the current use region of the heap", allocation is just "increment pointer by 20 bytes". Which is good because lazy languages don't just produce a lot of garbage, they allocate a lot too
08:58:29 <merijn> tomjaguarpaw: Basically, you GC an entire chunk of data into a separate compact region and instead of copying the data on every GC, it only copies the entry point to the region
08:58:58 <merijn> tomjaguarpaw: https://tech.channable.com/posts/2020-04-07-lessons-in-managing-haskell-memory.html
08:59:40 <tomjaguarpaw> Cool, thanks merijn! That could be very handy. Right now I am measuring GC time and subtracting it :P
09:00:30 <merijn> tomjaguarpaw: It will obviously slow down your overall time to run the benchmarks (if you use data only once and need to copy all of it first, that's slower). But it's deterministic at least
09:02:23 <tomjaguarpaw> I don't really mind that. Copying the data will be quick compared to running the function.
09:04:23 <glguy> Anyone what the complexity is of ghc-compat's compactAdd? I'm wondering if it has to copy the whole compact region or if it is able to add incrementally
09:04:53 <merijn> glguy: Sounds like a question for #ghc :)
09:11:47 <Martinsos> I read that ghc recently added a new type of GC, "incremental", that works in a different fashion and should help with avoiding big spikes of GC. How does that fit into the discussion? Can we choose which one we use? Does it affect the strategies around GC?
09:12:13 <merijn> Martinsos: There is a new GC in recent GHCs yes
09:12:38 <merijn> Martinsos: The answer is the if you do not require stable latency, the default one is probably best
09:14:40 <Martinsos> merijn: Makes sense! I am planning to try to build a game as a side project, in Haskell, so that is why I was reading about GC - this new GC should be better for games if I got it correctly, to avoid sudden loss of ticks/frames. So I guess we need to set some flag to use non-default one? 
09:15:34 <merijn> Martinsos: It'd be better for games, yes. Although, honestly I don't think the latency guaranteed by the new GC is good enough for high FPS games
09:16:03 <merijn> At least, not without managing the amount of live data, etc. manually
09:18:26 <Martinsos> merijn: Cool! I am aware Haskell is probably not the best choice for high FPS games due to GC, C++ would or some lower language would be better choice, but I doubt my game will require that level of performance so it should be fine, and I am excited about modeling everything in Haskell.
09:18:42 <merijn> Martinsos: The max pause time for the new one is 20ms, but a 60 FPS framerate gives you 16.6ms *max* per frame
09:19:26 <merijn> Martinsos: OTOH, you could consider writing a dedicated render loop in C that talkes with Haskell code implementing game logic
09:19:41 <merijn> Then you might get logic pauses, without hitting framerate
09:19:59 <Martinsos> Right, I was hoping I could extract some parts into C if needed!
09:20:40 <merijn> And also, just because you *can* hit that latency, doesn't mean you will. If your gamestate is small even the regular collector might be good enough
09:22:16 <Martinsos> Sure, the game will be 2D with lightweight graphics so I don't think it should be an issue. If it will be it will at least be an opportunity to learn more about GC :D.
10:30:59 <sm[m]> people making "normal" (non-AAA, non-huge) games have said even the standard GC was not a problem
10:48:31 <edwardk> merijn: i figure if i'm going to write a game in haskell i'm probably aiming for 30fps and doing a bit of lerping over the last two physics frames (using an approach by gafferongames) to try to hit anything higher.
10:49:12 <merijn> edwardk: I'd probably consider is an excuse to finally learn Rust :p
10:49:21 <edwardk> Martinsos: for 2d, especially with fairly tightly designed game logic and an eye towards unboxing you'll likely be okay
10:50:41 <edwardk> merijn: heh i was working on a toy project to do something in a browser and was going to drive it with ghcjs, so i first stopped and wrote the most optimized version of the basic code path i could in javascript to see if i could even get the gc pauses down to an acceptable level. then i never got around to writing the haskell version.
10:51:04 <edwardk> and then davean decided to do something else anyways so it died =P
10:52:45 <edwardk> hah, it still runs. http://ekmett.github.io/arcade/static/ loads in chrome, wasd, 1-9 spawns stuff, 0 wipes it all out, mouse grabs, q/e raises lowers what you have grabbed. c and b show some debugging info, the menus are basically nonsense.
10:52:59 <edwardk> iirc it doesn't work in firefox
10:53:11 <bollu> does anyone have references to haskell codebases other than GHC that do a lot of analysis / transformations on an AST?
10:54:02 <merijn> bollu: "literally every compiler written in Haskell"? ;)
10:54:07 <bollu> merijn yes, which ones? ;) 
10:54:12 <bollu> ermine doesn't do many transformations
10:54:22 <merijn> What does Idris do?
10:54:28 <davean> edwardk: ... that causes 'lens'
10:54:31 <edwardk> especially in the haskell codebase that we never finished
10:54:31 <bollu> good question. I should check 
10:54:45 <davean> edwardk: The project litterly became 'lens' and there was no way lens was getting done in time :-p
10:55:05 <edwardk> davean: nah, lens was done first. the game engine lens came out of was ~5 years before this
10:55:14 <edwardk> THAT one wasn't getting done on time =)
10:55:25 <merijn> edwardk: I think games pretty much the only reason I'd use Rust, because for the rest of the stuff I ever write GHC's GC is perfectly fine :p
10:55:29 <bollu> hm seems like idris2 is self hosted
10:55:39 <bollu> so I gotta read the original idris if I want to get a sense of Haskellisms
10:55:45 <edwardk> but yeah. rust has me super jealous at times. i look at makepad and weep.
10:56:26 <davean> I'm sad at the state of wasm, particularly because its the new JVM
10:56:29 <merijn> bollu: Agda? But that's not very optimising I guess?
10:56:36 <edwardk> https://makepad.nl/ is written in rust, as an editor for rust, compiling to either native of web assembly, renders using shaders compiled from rust...
10:56:43 <davean> I strongly back having a good wasm backend soon.
10:57:21 <edwardk> the idealized form of a haskell version of the same thing would be a ratsnest of EDSLs that aren't quite up to the same task
10:57:53 <davean> Yah, rust has a MUCH better compilation story.
10:57:56 <edwardk> heck, the makepad stuff can even use webxr to render as a vr scene at this point
10:58:24 <merijn> davean: Their compile times seem to be about as bad as GHC, though :p
10:58:30 <davean> merijn: eh, so what?
10:58:35 <edwardk> merijn: idris 2 has much better compile times
10:58:49 <edwardk> or do you mean rust?
10:58:55 <merijn> edwardk: Wait, we were talking about Rust, no?
10:59:06 <edwardk> ah, thought you might be replying to bollu still
10:59:17 <davean> merijn: I'd be happy to give GHC a few CPU-months if I could get 10% better optimization. 
10:59:22 <merijn> davean: I'm an ADHD millenial, I ain't got the patience for that >.<
10:59:37 <bollu> merijn yeah, I don't think Agda "does much" with the AST. I could be wrong
11:00:37 <davean> merijn: --pay-for-it-to-be-faster $2000
11:01:03 <merijn> davean: I'm a millenial, I ain't got any money ;)
11:01:26 <davean> merijn: not if you pay for the hosts to run slow code you won't!
11:01:48 <edwardk> davean: i'm still working on that fungibility of compilation performance story =P
11:01:50 <monochrom> Oh haha great, in-compiler purchase, "us$0.99 for 1 percentile speedup"
11:02:11 <merijn> davean: See, I've got a super good lifehack to work around that!
11:02:23 <monochrom> The best of both worlds of FOSS and capitalism. Thanks merijn for the great idea. >:)
11:02:27 <merijn> davean: I just don't host or run any code, because of the aforementioned lack of money ;)
11:02:55 <davean> What annoys me is when type checking gets slow.
11:02:57 <edwardk> monochrom: if we have to compile in the cloud and try a rather non-trivial number of constructions using lots of machines that isn't actually an unreasonable approach. it has been kind of my mental model for a while now.
11:03:05 <davean> I very rarely want to compile my code, I often want to type check it.
11:03:44 <dolio> It sounds unreasonable to me.
11:03:45 <edwardk> "how do i spin up 10k machines on tasks like program synthesis and verification and spend them efficiently?" is very much in my line of research.
11:04:03 <electricityZZZZ> edwardk: oh hey, can we dm regarding that?
11:04:05 <monochrom> Err I mean davean! Thanks davean for the great idea >:)
11:04:20 <edwardk> electricityZZZZ: we can, today is going to be a bit busy for me, but i'll try to respond as i can
11:04:26 <electricityZZZZ> cool
11:04:48 <davean> monochrom: I'm already on that idea :-p
11:05:08 <edwardk> in any event, let's just say that existing cloud hosting providers get pissy about providing for that much burst traffic =P
11:05:54 <davean> edwardk: not QUITE true
11:06:11 <monochrom> davean: -fno-code helps for just checking syntax and types.
11:06:19 <davean> monochrom: I'm aware, I do that all the time :)
11:06:25 <davean> As I said, I almost never compile my code.
11:06:33 <davean> Compiling is for releasing!
11:06:39 <monochrom> Although, in the framework of cabal, it is annoying to manually switch it on and off and on again and off again...
11:06:40 <edwardk> davean: i spent much of the last year wrestling with AWS, google cloud, etc. trying to get them to let me exchange money for goods and services.
11:06:51 <edwardk> it appears that capitalism has yet to reach the cloud.
11:07:03 <davean> edwardk: Spot market man.
11:07:15 <monochrom> Haha great, "compiling is for releasing!" is even stronger than "if it type-checks it's correct".
11:09:39 <monochrom> For it means you don't even test your ship/release/deployment step. "I'll gen code on the shipment day!"
11:10:05 <davean> No, you gen code and run the tests and release.
11:10:21 <edwardk> davean: yeah. you just need to beg and plead until they give you access to it at any meaningful capacity.
11:10:38 <edwardk> MIRI has good access to these things, but I was originally doing this on my private accounts
11:10:41 <monochrom> "You know what, this is an open-source project 'release' just means posting the source code on github, so I won't even need to gen code"
11:11:34 <monochrom> "This is known as proof erasure in type theory." >:)
11:15:13 <monochrom> burst traffic sounds like analogous to electricity industry's notion of inductive load
11:20:35 <dminuoso> edwardk: Hiya, a while ago you noted that the main problem witch catching pure exceptions with unsafePerformIO was that "it isn't monotone", followed by a remark "in [pure code] if you make your inputs more defined all that can happen is that at worst your output becomes more defined. in a world with catchPure that is no longer the case"
11:20:53 <dminuoso> I have a vague idea, but I wanted to clarify. What exactly do you mean by monotonicity here?
11:21:55 <monochrom> if input is more defined, then output stays the same or is more defined. For example doesn't change sideways.
11:23:08 <monochrom> For example suppose you have a function f, and f bottom = 4 : bottom, f (1 : bottom) = 4 : 5 : bottom, that's OK, so far so good.
11:23:23 <monochrom> On the input side, 1:bottom is more defined than bottom.
11:23:40 <monochrom> On the output side, 4:5:bottom is more defined than 4:bottom.
11:24:17 <monochrom> But if you have g such that g bottom = 4 : bottom, g (1:bottom) = [].  Now that's bad.
11:25:13 <dminuoso> How exactly is that bad?
11:25:53 <monochrom> [] is not more defined than 4:bottom.
11:26:02 <monochrom> Intuitively, it's a sideway change.
11:27:55 <monochrom> Technically, "more defined" for [Integer] is defined by: the smallest relation that satisfies: everything is equal to or more defined than bottom; x:y is equal to or more defined than a:b iff x is equal to or more defined than a and y is equal to or more defined than b.
11:28:20 <edwardk> dminuoso: this is really the fundamental difference between _|_ and NULL. You can check for null. So you have to worry about NULL being a semantically distinguishable element at every step in your program. Boolean would then have 3 values, True, False, NULL. IN haskell. If a function gives an answer for _|_ it has to give an answer that is 'at least as defined' if you give it True or False, because _|_ is less defined than either.
11:28:49 <monochrom> https://en.wikibooks.org/wiki/Haskell/Denotational_semantics  is a good explanation, except it is wrong about "there is a bottom type".
11:29:09 <Rembane> The table flip operator, because it looks like a flipped table and it flips the table.
11:29:11 <edwardk> it means if you feed a program a partially defined input and get an answer, making the input more defined never hurts you.
11:31:45 <monochrom> Perhaps you're wondering why we care about this relation.
11:31:48 <dolio> The point of things containing ⊥ in denotational semantics is to be approximations of more-defined things. That way you can reason about behavior of infinite things by approximating them with partial definitions.
11:32:06 <dolio> But if you can observe ⊥ and act differently, then that is out the window. It's just a different value.
11:32:10 <edwardk> dolio++
11:32:35 <monochrom> We use bottom to also stand for: The computer doesn't give an answer for now, but perhaps if you throw more computing resource, the computer can finally figure out the answer.
11:32:50 <dolio> Then it's just side effects.
11:34:14 <monochrom> And even: the computer doesn't give an answer now because the input is incomplete for now. Perhaps if the incomplete part of the input arrives later, the computer can also figure out more of the output.
11:34:51 <monochrom> That would be a model for a function that transduces an input lazy list to an output lazy list, for example.
11:35:46 <dolio> And essentially, you should not care about behavior on ⊥ in Haskell in itself, but because it is a methodology for thinking about the behavior on more-defined values.
11:36:02 <dolio> Thinking about ⊥ tells you about how well-defined values are demanded and whatnot.
11:36:20 <monochrom> So "f bottom" means none of the input has arrived yet, but how much f can start working right away?
11:37:18 <wz1000> You also lose the ability to do topology in Haskell
11:37:18 <monochrom> And "f (1: bottom)" means OK one cons cell has arrived, now f can possibly do a bit more work before it's stuck again needing the rest of the input.
11:38:07 <bollu> wz1000 wdym?
11:38:28 <wz1000> functions are no longer continuous
11:38:36 <monochrom> In the case of g, it means g can start outputing the 1st cons cell of the output lazy list right away without needing input, but once you provide some input, it says "I withdraw my previous output, I change my mind, it's the empty list now"
11:38:57 <wz1000> bollu: https://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
11:45:51 <sondr3> drive-by question: is it possible to use the new-* cabal commands by default when using cabal?
11:46:40 <monochrom> Yes if your cabal-install version is 3.0 or 3.2 or 3.4
11:47:02 <bollu> wz1000 sure I've read it
11:47:14 <bollu> wz1000 we need bottoms to get the semi decidability structure 
11:47:21 <bollu> wz1000 so I'm not sure what you mean that we lose topology?
11:47:28 <merijn> monochrom: 3.4 is rather hard, considering that's not released yet :p
11:47:45 <wz1000> bollu: I mean if you make bottom observable
11:47:54 <bollu> wz1000 ah OK, sure. 
11:47:57 <bollu> :) 
11:48:09 <sondr3> thanks monochrom, I couldn't find much by searching
11:49:03 <merijn> sondr3: You should upgrade to 3.0 or 3.2 anyway if you use v2-build, there's been a bunch of improvements and bugfixes in those two versions
11:50:14 <sondr3> I'm on 3.2 already, just haven't been following the Haskell world closely for a while :)  Thanks
11:52:07 <sondr3> Is it then possible to run my executable with cabal run automatically and not have it include the test suite?
11:53:44 <merijn> "maybe?" I'm not quite sure what you mean?
11:53:45 * ski . o O ( non-monotonic logics )
11:54:08 <dminuoso> monochrom: Okay, so some reasoning level I understand what monotonicity means. I just fail to see the impact of breaking that.
11:55:21 <monochrom> Suppose mylazylist is a lazy list, but when evaluated it takes a while to emit the next cons cell and number.
11:55:24 <sondr3> I get a "cabal: The run command is for running a single executable at once.  [...]" message, saying it includes the executable and the test suite, I want cabal run to only run the executable
11:55:27 <dminuoso> Naively, I'd just say "So say I have some `f :: String -> Int` that perhaps failed, it'd be *very* annoying to have to fix their code for a lack of Maybe, or feed IO through potentially half my program just to deal with it sensibly. This idea of monotonicity seems more like philosophical beauty than something I would care about
11:55:54 <monochrom> print (f mylazylist) makes sense.  print (g mylazylist) doesn't.
11:56:10 <merijn> sondr3: What's the exact command you write?
11:56:33 <sondr3> merijn: cabal run
11:56:56 <merijn> sondr3: A package can have many executables in it, the intended use is "cabal run yourExeName"
11:57:24 <dminuoso> 20:23:55       monochrom | But if you have g such that g bottom = 4 : bottom, g (1:bottom) = [].  Now that's bad.
11:57:26 <dminuoso> Mmm
11:57:29 <ski> (in logic programming, you have an analogue of non-monotonic functions : non-steadfast predicates/relations. if you provide more information (in parameters) upfront to it, it can suddenly gain solutions which are not substitution instances of the ones it had with only less information available. it's generally agreed that this hurts reasonability / predictive power)
11:58:06 <dminuoso> monochrom: Are you referring to the same f and g you introduced at the beginning?
11:58:40 <monochrom> "print (f mylazlist)" can do this: print 4 right away, then wait for mylazylist to spit out its first item 1, then print 5 when that happens.
11:59:04 <monochrom> "print (g mylazylist)" cannot do this unless it can roll back time or output transactions.
11:59:06 <dminuoso> I mean the only reason you're saying "it doesn't make sense" is because your equating "bottom induced by infinite computation" and "bottom as pure exceptions"
11:59:14 <monochrom> Yes, same f and g.
11:59:14 <dminuoso> catchPure only deals with the latter
11:59:27 <dminuoso> On a technical level, catchPure doesn't break g.
11:59:41 <dminuoso> It just ruins your paradise of perfect symmetry and beauty
12:00:21 <dminuoso> Because `f (g mylazylist)` would just print [] and be done with it
12:00:27 <dminuoso> After a while.
12:00:30 <sondr3> merijn: fair, it's just annoying since I don't care about the test-suite when I do cabal run :)
12:01:00 <merijn> sondr3: If you write out the name you shouldn't get that, but if you wanna frequently test an executable while developing I've got a lifehack for you
12:01:56 <merijn> sondr3: https://paste.tomsmeding.com/9sTHIIML adjust the path to cabal.project file and executable name as needed, and done!
12:02:40 <sondr3> merijn: awesome, thanks
12:02:55 <merijn> sondr3: For my own programs I have a shell script like that in my path so I can conveniently test/use them while developing, automatically compiling the latest version and then running
12:06:54 <dolio> dminuoso: The justification for 'pure exceptions' is that they are equated with non-terminatiaon bottom.
12:07:26 <dolio> At least as far as the pure calculus is concerned.
12:19:14 <monochrom> dminuoso: Yes OK, it is a more complicated model, but it can work.
12:19:48 <dminuoso> monochrom: I want to stress that Im not arguing why `catchPure` is fine, just trying to understand why there's this strong opposition.
12:21:50 <monochrom> I still like the simpler model most of the time. When in the rare cases I can benefit from the complication, I would rather use explicit Maybe's so it is a non-pervasive opt-in system.
12:23:41 <dminuoso> monochrom: the thing is just, it seems as if the argument is: introducing `catchPure` would allow for "non-sensical" g
12:23:57 <dminuoso> Which is a non-issue, because catchPure couldn't (possibly) solve the halting problem
12:25:02 <dminuoso> I get how it would break monotonicity (meaning more defined inputs do not create more defined outputs), but perhaps Im just not seeing the value of that possible reasoning
12:25:22 <dminuoso> That is, is there a motivating example where its useful to think `oh, if I make this input more defined, the output becomes more defined`
12:25:56 <dminuoso> So far Im getting the impression this is just some "academic purity" in the way of "a practical function"
12:26:24 <dolio> Once you have side effects, you start having to worry about exact evaluation orders.
12:26:30 <dolio> That's not academic.
12:27:01 <dminuoso> Sure, but there's no side effects in pure code.
12:27:17 <dolio> There are once you can catch exceptions and look at them.
12:27:49 <monochrom> You have a pervasive exception system, that's what it is. As usual, the price for a pervasive exception system is documentation: For each value, you have to tell the user: if some input throws an exception, what do you do? and under what circumstance you will throw exceptions.
12:28:53 <monochrom> This community is already pretty unhappy that most IO actions are pretty undocumented on the pretty anticipated IO exceptions.
12:29:04 <monochrom> Now imagine bringing that to all of Prelude.
12:29:17 <dminuoso> But.. I just stumbled over a very convincing example of dfeuer that suggests catchPure is really bad 
12:29:38 <dminuoso> (let a = a in a) `seq` error "hallo!"
12:29:54 <monochrom> Oh that one is even more sinister.
12:30:13 <dminuoso> And he says that in the presence of catchPure this could *sometimes* be defined, othertimes not..
12:30:37 <dolio> Yeah, because GHC also assumes that 'pure exceptions' are equal to non-termination.
12:30:39 <dminuoso> (obviously, because seq makes no assumption about the ordering)
12:31:08 <monochrom> "div 1 0" is the kind that we all agree is an exception, the only contention is on language design: should this be bottom or not.
12:31:13 <dminuoso> dolio: I think its not even that, Id say it's just because `seq` does not guarantee the left side to be evaluated first.
12:31:27 <dminuoso> So its up to whatever the implementation does in the situation
12:31:44 <dminuoso> (Which could vary from place to place if the optimizer was up for it)
12:32:10 <monochrom> "a = a" is a non-termination that is clearly bottom but some compiler optimization can make it detectable, so now you're looking at fragile code optimization getting turned on or off.
12:32:26 <dminuoso> oh, or that
12:35:41 <dolio> Anyhow, if you're just using it to paper over a poorly designed API, then that's one thing.
12:36:14 <dolio> That can't really be justified as treating pure exceptions as actual control flow pervasively.
12:37:03 <dminuoso> Right. It's just that edward made that comment a while ago, and it kept lingering in my head because I couldn't quite argue to myself why he was right.
12:37:14 <_deepfire> Is there a way to pass 'ghci' flags, when it's invoked via cabal repl?
12:37:40 <merijn> --repl-options
12:38:38 <dminuoso> But this last example is motivating enough to me. An example of how/why `catchPure` could have a bad impact on my quality of life
12:39:02 <dolio> Yeah, just `let a = a in a` can get you unpredictable results.
12:39:10 <dminuoso> Right
12:39:34 <dminuoso> Having fallen prey to not respecting the unsafeness of unsafePerformIO once makes me appreciate being careful to do things in pure code you're not supposed to.
12:40:28 <_deepfire> merijn: I'm using cabal 3.0, but cabal repl TARGET -O0 --repl-options=-ghci-script=.ghci.local  -- doesn't have effect
12:41:05 <dminuoso> monochrom, dolio, edwardk: Thank you all for your insights and arguments.
12:41:34 <merijn> _deepfire: Maybe "cabal repl" does something else that renders -ghci-script in effective
12:42:23 <_deepfire> merijn: thank you, nevertheless -- I've missed that option in the long list of cabal's options.. : -)
12:42:49 <merijn> _deepfire: I know that because the original way was using --ghc-options and I broke that :p
12:43:23 <_deepfire> merijn: Oh, yes, I've tried --ghc-options and --ghci-options (which is logical, but doesn't parse..)
12:48:03 <monochrom> Hey --repl-option=-fdefer-type-errors solves my problem, it doesn't [re-]build every hackaage dependency. Thanks merijn
12:50:25 <monochrom> To be fair, manually entering ":set -fdefer-type-error" isn't that bad.
12:58:05 <tomjaguarpaw> c
12:58:31 <koz_> I'm in 'StateT s (Either e) a', and have a function 'f :: s -> Either e s'. Is there something similar to 'modify' that would let me pass 'f', to produce a result of type 'StateT s (Either e) ()'?
12:58:38 <merijn> monochrom: That's why I added --repl-options :p
12:59:04 <monochrom> Oh you. Many thanks and <3 <3 <3
12:59:09 <merijn> monochrom: I added flag filtering for ghc-options so the world wouldn't be rebuild, then that broke ghci's use of ghc-options, so I added --repl-options to fix it
12:59:28 <merijn> repl-options never hit the configuration/hash and thus won't affect dependencies
12:59:41 <monochrom> Yeah, I notice that cabal build --ghc-option=-ferror-span does not affect the hash.
12:59:52 <merijn> monochrom: It's a bit hacky and ad hoc atm
13:00:19 <merijn> It makes for an impressive "power of monoids" showcase, though ;)
13:00:31 <monochrom> That one I understand. I am thankful for the dirty but necessary work.
13:01:23 <merijn> monochrom: If you notice something rebuilding that you think shouldn't you should make a Cabal issue and tag me in it
13:01:31 <merijn> monochrom: https://github.com/haskell/cabal/blob/master/Cabal/src/Distribution/Simple/Program/GHC.hs#L49-L304 ;)
13:02:03 <monochrom> Oh, the only current one that affects me is https://github.com/haskell/cabal/issues/6906
13:02:29 <merijn> I'm particularly proud of the 'from' and 'to' version checks and how they combine monoidally
13:02:30 <monochrom> because I would love so much to have ~/.cabal/config contain "ghc-options: -haddock"
13:03:04 <merijn> And I still think we need "Monoid m => Bool -> m -> m" in base, but it's hard to find a good name for it
13:03:24 <merijn> I've been using various versions of mif, mwhen, etc. in my own code, but a good name is hard
13:03:52 <int-e> :t StateT . (((,) () <$>) .)
13:03:53 <lambdabot> Functor m => (s -> m s) -> StateT s m ()
13:04:36 <koz_> int-e: Lol, that's impressively APLy. Thanks!
13:05:18 <koz_> We should add that to transformers as 'modifyInner'.
13:05:24 <koz_> Or modifyM or something.
13:11:31 <int-e> :t \f -> traverse lift (Identity f) >>= put . runIdentity -- hmm
13:11:32 <lambdabot> (MonadTrans t, Monad m, MonadState s (t m)) => m s -> t m ()
13:12:09 <koz_> That's the mtl version. :P
13:12:23 * hackage phonetic-languages-examples 0.6.0.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.6.0.0 (OleksandrZhabenko)
13:17:35 <int-e> :t (>>= modify) . traverse lift -- ah, that's it.
13:17:36 <lambdabot> (MonadState s (t m), Traversable ((->) s), MonadTrans t, Monad m) => (s -> m s) -> t m ()
13:17:51 <quarters> I was wondering if anyone can recommend any site that help a noob like myself build out a minimal web app like on http://todomvc.com/
13:18:14 <koz_> int-e: The 'Traversable ((->) s)' constraint is a bit onerous, surely?
13:18:36 <int-e> indeed
13:18:50 <int-e> never mind then, I give up.
13:19:00 <koz_> The others were good, though.
13:19:13 <koz_> I mean, if you wanna APL it, you can probably run attempt #2 through @pl.
13:19:23 <koz_> @pl \f -> traverse lift (Identity f) >>= put . runIdentity
13:19:23 <lambdabot> (put . runIdentity =<<) . traverse lift . Identity
13:19:29 <quarters> a haskell noob, rather. I noticed that there isn't a haskell version on that site and while I can try for something similar like the scala one, I figured that wouldn't give me the exposure to the tooling used for building out a haskell backed todo list web app
13:19:48 <int-e> koz_: #2 didn't quite have the right type
13:20:05 <koz_> int-e: Ah, yeah, upon further reading I can see why.
13:21:02 <int-e> :t \f -> get >>= \s -> traverse lift (Identity (f s)) >>= put . runIdentity -- and this is beginning to look awfully clumsy
13:21:04 <lambdabot> (MonadState s (t m), Monad m, MonadTrans t) => (s -> m s) -> t m ()
13:21:23 <int-e> @pl \f -> get >>= \s -> traverse lift (Identity (f s)) >>= put . runIdentity
13:21:23 <lambdabot> (get >>=) . flip flip (put . runIdentity) . (((>>=) . traverse lift . Identity) .)
13:21:31 <int-e> eww.
13:21:42 <koz_> Dat flip . flip.
13:21:48 <koz_> I mean, 'flip flip'.
13:23:07 <Flonk> Say I have a simple BST (https://hastebin.com/bexopesayo.hs) with an insert function. If the element is already in the tree I'd like to save space and return the original tree - at the moment I'm creating a lot of duplicate nodes which is unneccessary. What programming pattern am I looking for?
13:23:30 <int-e> :t \f -> get >>= \s -> lift (f s) >>= put -- yeah the whole traverse idea is just stupid, I guess
13:23:32 <lambdabot> (MonadState s (t m), Monad m, MonadTrans t) => (s -> m s) -> t m ()
13:23:38 <Flonk> Feels similar to exceptions in imperative languages.
13:24:35 <int-e> @pl \f -> get >>= \s -> lift (f s) >>= put
13:24:35 <lambdabot> (get >>=) . flip flip put . (((>>=) . lift) .)
13:24:43 <int-e> still double-flipping
13:25:02 <int-e> flipping out, with a typo?
13:25:22 <koz_> int-e: flipTable = flip flip
13:25:39 <koz_> :t flip flip
13:25:40 <lambdabot> b -> (a -> b -> c) -> a -> c
13:25:54 <koz_> Feels like there should be a bird for this.
13:26:23 <int-e> hmm, flipping the bird?
13:26:56 <koz_> The all-new Yelling Bird combinator.
13:27:56 <int-e> koz_: I'm still wondering whether there's something more natural for this. Or perhaps some obscure lens approach...
13:40:23 <dolio> :t \f -> state (fmap ((,) ()) . f)
13:40:24 <lambdabot> MonadState ((), b) m => (((), b) -> (a, b)) -> m a
13:40:37 <eacameron> Question about TH. I barely know how to get my way around TH. Some libraries (here, postgresql-simple-interpolate) offer intelligent Haskell splicing into quasiquoters and they use haskell-ext-meta/etc. to parse the haskell code. This has numerous downsides though as the parser isn't aware of the all the extensions etc in the file using the QQ. However the thought came to me: Why parse these splices at all?
13:40:53 <dolio> Oh, that won't work, right.
13:40:56 <eacameron> Can't I just take them out and put them in a let binding with a new name and then use the name when building the string later?
13:42:14 <eacameron> This presupposes I'm able to take raw strings in the QQ as supplied by the user and then tell TH: Just splat this verbatim into the output.
13:43:53 <Boomerang> TH doesn't let you "splat" raw strings, you have to build the AST of the Haskell you want to generate
13:45:18 <eacameron> Boomerang: Well that sucks :P
13:46:12 <Boomerang> It does have tools to make it easier, special TH QuasiQuotes [e| ... |], [t| ... |], ...
13:46:37 <eacameron> Boomerang: Yeah sounds like at that point I'd need Template template haskell...
13:47:10 <Boomerang> It might be possible/already exists, but I don't know of such a library
14:12:50 <monochrom> wz1000: Thanks for the synthetic topology link, I also get interested.
14:16:37 <wz1000> monochrom: to model everything with the full expressive power you also need unamb, which is implemented using unsafePerformIO: https://hackage.haskell.org/package/unamb-0.2.7/docs/Data-Unamb.html
14:17:26 <ski> @hackage lvish
14:17:27 <lambdabot> https://hackage.haskell.org/package/lvish
14:18:14 <ski> (Escardó's work's interesting, yes)
14:25:07 * ski . o O ( "Abstract Stone Duality" by Paul Taylor at <https://www.paultaylor.eu/~pt/ASD/> )
14:59:47 <sshine> hm. apparently the 'data-fix' package doesn't have a 'para'.
15:01:14 <sshine> before the package gave its combinators funny new names, it only had 'cata', 'ana' and 'hylo'.
15:02:18 <sshine> I'm wondering if I should just ditch 'data-fix' and go back to a regular, recursive ADT, or try 'recursion-schemes'.
15:03:52 <sshine> another peculiar thing is that if I only want to match one level deep, and not recursively, it seems that I need to do 'Fix.foldFix $ \case { Foo{} -> ...; Bar{} -> ... }' and I suppose that since I'm not referring to the recursive parameters of Foo and Bar, they are lazily discarded?
15:23:53 * hackage nix-tree 0.1.2.0 - Interactively browse a Nix store paths dependencies  https://hackage.haskell.org/package/nix-tree-0.1.2.0 (utdemir)
15:24:45 <dolio> Was there some recent blog post somewhere hyping up recursion schemes or something?
15:26:27 <dolio> Recursion schemes are the things people working on dependent type theory try very hard to avoid having to use. :þ
15:31:09 <aoei> monochrom: lmao (sorry late reply, but you deserve the lols)
15:31:23 <dsal> The paper was from nearly 30 years ago.  It should be the new hotness any day now.
15:32:41 <dolio> I think it's part of a general fallacy among some Haskellers that things that closely match the categorical presentation are automatically nicer. But that is false.
15:33:27 <dolio> In fact, one of the reasons category theorists look for certain structures in categories is so that they can use languages that look more like type/set theory to reason about them.
15:34:42 <dsal> I didn't get very far in my recent recursion excursion.  Part of the problem is Foldable and Traversable do a lot of the magic.  The other is that my use case and uses are just slightly weird.  I can't even remember how, but when I sit down to do something interesting, it's always, "Oh yeah, this is why that won't work."
15:35:08 <dsal> It doesn't help that my implementation is complete and already quite tidy.
15:37:57 <dolio> Recursion schemes can give elegant presentations of some things, don't get me wrong. But there's a reason people came up with recursion and pattern matching, and try to justify them in terms of things like folds.
15:40:06 <hololeap> learning how to think of something from different angles is beneficial, even if the benefits aren't obvious. it gives you more flexibility in your thinking
15:41:39 <hololeap> i think a lot of people learn about recursion-schemes because it is a different angle to dealing with recursion than what they are used to, and after learning it realize that it's not that useful in and of itself. but learning about it isn't a waste of time imo.
15:41:48 <dolio> Yeah, they're cool to study. At least the original paper or two.
15:42:26 <dolio> I think the fact that there are many papers introducing new schemes for recursive definitions that the previous ones didn't handle well is also telling.
15:45:13 <dolio> Anyhow, I ask because it seems that lately there are a lot of 'which recursion-schemes pacakge should I use' type questions here, which I would expect because someone famous said to use one. :)
15:51:00 <sshine> dolio, I don't know if recursion schemes were recently hyped up :)
15:52:02 <sshine> dolio, I guess I had to try for myself that this was a bit of a bother the moment I ran into a recursion scheme that the library (data-fix) didn't support.
15:52:28 <dsal> I was looking at recursion-schemes recently just because it was on my mind and I had a road trip, so I was trying to find explanations I could listen to.  The concepts make plenty of sense.  I've just not actually applied them to anything.
15:52:30 <sshine> dolio, I did ask which of the two to use a few weeks ago.
15:54:50 <sshine> dolio, "there's a reason people came up with recursion and pattern matching": well, you'd still be using pattern matching with data-fix. just not arbitrarily deep. and I guess you wouldn't be using arbitrary recursion much like a foldr wouldn't let you... so as long as you're fine with recursion constrained to certain schemes, it shouldn't make a big difference. except, yeah, suddenly I need to match two 
15:54:56 <sshine> levels deep in my tree and I can't. >_<
15:55:36 <sshine> I think I'm just going to slowly back out and say that I had my experience with it. :)
15:56:06 <sshine> I'd switch from 'data-fix' to 'recursion-schemes' if it weren't because I think that this didn't just prove that I'm spending more energy rather than less.
15:56:28 <dolio> sshine: Yeah, I'm sure there's a something-morphism named for matching two levels deep. :)
15:56:30 <sshine> (also, this being totally researchy, I don't really mind that, it could have been a golden discovery since I happened to actually understand it.)
15:56:43 <sshine> dolio, para. it's in recursion-schemes, but not in data-fix.
15:56:59 <dolio> Well, para gives you the whole underlying value.
15:57:01 <sshine> sure
15:57:22 <dolio> You can publish another paper for one that only gives you the immediate level. :P
15:57:24 <sshine> I mean... I think they're somehow equivalent, so I could *make* a two-level-deep scheme from 'cata'.
15:57:51 <sshine> and I could make it contain a whole bunch of '.'s and 'Fix . fmap f . fmap fmap fmap fmap'
15:58:04 <superstar64> if it's complicated, why not use vanilla recursion?
15:58:08 <dolio> Anyhow, recursion-schemes is probably fine for para, but I wouldn't hesitate to define some pattern synonyms for the one-step match.
15:58:13 <sshine> superstar64, that.
15:58:36 <dolio> Or just ditch the `Fix` version of the type if it's not paying off.
15:59:04 <sshine> dolio, yeah, I ended up defining a bunch of synonyms for my tree, which wasn't less work but made me recall one professor saying you actually want an abstract tree, and I realized, once I did all that boilerplate work, I could actually replace 'data-fix' with anything and not touch the synonyms.
15:59:12 <sshine> dolio, I'm gonna.
15:59:52 <sshine> superstar64, I was trying to find out if it was complicated. it sort of is. :-D
16:01:18 <dolio> :)
16:03:53 <monochrom> Some of the recursion schemes enjoy very handy theorems. If you know your function fits a recursion scheme, then your function enjoys its theorems. This is a proof re-use.
16:05:35 <monochrom> For example for lists: foldr op z . map f = foldr (\x r -> op (f x) r) z.
16:06:16 <monochrom> If you wrote your own recursion instead of that foldr, you may or may not spot that property as easily, and you may or may not have an easy time proving it.
16:08:01 <dolio> Well, as always, my advice is not, "don't use folds ever." It is, "don't try to force yourself to structure all your code around folds regardless of context."
16:08:29 <monochrom> But my overall opinion is: cata and ana and Ralf Hinze's "adjoint folds and unfolds" are all you need to know for 99% of the cases.
16:09:27 <monochrom> Outside that, the rest look like very niche and hair-splitting.
16:10:13 <monochrom> Even the adjoint folds and unfolds, if you have to conjure a very contrived obscure adjoint functor, you're stretching it, the benefit becomes slim.
16:12:55 <lucard> Hello all, im working on the book Haskell programming form first principles, and i was wondering if you guys know any repo with test cases for exercises in the book. Any idea?
16:28:22 * hackage iproute 1.7.10 - IP Routing Table  https://hackage.haskell.org/package/iproute-1.7.10 (KazuYamamoto)
16:32:19 <dsal> lucard: I think you're supposed to write those yourself.
16:32:53 <dsal> Fun Haskell fact: once your code compiles, it does exactly whatever you thought it should do.
16:57:22 * hackage flashblast 0.0.7.0 - Generate language learning flashcards from video.  https://hackage.haskell.org/package/flashblast-0.0.7.0 (locallycompact)
16:59:22 * hackage flashblast 0.0.8.0 - Generate language learning flashcards from video.  https://hackage.haskell.org/package/flashblast-0.0.8.0 (locallycompact)
17:42:37 <justsomeguy> So I just found out that you can use let bindings in list comprehensions, like “[x^2 | let n = 3, x <- [1..n]]”. Is there anything special about them? Why the dedicated syntax?
17:44:13 <davean> justsomeguy: what dedicated syntax?
17:44:54 <dolio> Same reason as let inside do.
17:44:55 <sshine> justsomeguy, let-expressions in list comprehensions are much like let-expressions in do-notation
17:45:36 <sshine> justsomeguy, considering list comprehensions are monadic, it's not very special. but I guess you could ask why remove the "in" inside do notation?
17:46:30 <justsomeguy> Yes, the absence of “in” kind of threw me off.
17:46:55 <davean> justsomeguy: its not removed specificly there
17:47:02 <davean> justsomeguy: theres no 'in' in do notation.
17:48:34 <sshine> justsomeguy, you can think of list comprehensions as being syntax sugar for list monads. and you can extend list comprehension syntax to other monads than list using -XMonadComprehensions: https://gitlab.haskell.org/ghc/ghc/-/wikis/monad-comprehensions
17:49:13 * justsomeguy does a web search for do notation
17:49:35 <dsal> @undo do { results <- web }
17:49:35 <lambdabot> <unknown>.hs:1:22:Parse error: Last statement in a do-block must be an expression
17:50:01 <dsal> damn.  Have to do something with those results.
17:51:26 <sshine> ah
17:51:33 <sshine> I learned something.
17:51:36 <sshine> > do { x <- [1..10]; let {y = 3}; return (x * y) }
17:51:38 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
17:52:09 <sshine> so those inner curly braces aren't necessary if I use do-notation without the curly braces (those are only necessary because I want to one-line it on IRC.)
17:52:57 <sshine> but because let-expressions allow for separate ;-separated bindings (let foo = 2; bar = 3 in ...), I have to disambiguate the ; as a do-separating ; and not a let-binding-separating ;.
17:53:01 <sshine> sheesh. :)
17:53:19 <sshine> do x <- [1..10]
17:53:22 <sshine>    let y = 3
17:53:26 <sshine>    return (x * y)
17:54:11 <sshine> > [ x * y | x <- [1..10], let y = 3 ] -- vs. this
17:54:13 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
17:54:34 <dsal> @undo [ x * y | x <- [1..10], let y = 3 ]
17:54:34 <lambdabot> concatMap (\ x -> let { y = 3} in [x * y]) [1 .. 10]
17:54:43 <dolio> Well, also, the scoping is more suited to the situation. You don't need to nest another do block inside the let.
17:54:53 <dolio> And for comprehensions it'd be even more annoying.
17:59:12 <sshine> justsomeguy, I think the missing "in" comes from do-notation fitting one action per line with implicit monad bind operator in-between each line. so since do-notation has special syntax wrt. interpreting linebreaks, removing the "in" that would otherwise make a let-expression float onto the next line removes an ambiguity that would otherwise occur when the next line is indented the same: is it another 
17:59:18 <sshine> stand-alone action, or is it the continuation of the let-in-binding on the line before?
18:02:47 <sshine> justsomeguy, https://gist.github.com/sshine/0dac23b35e19b1ea0aed7a9e6d215c30
18:03:53 <sshine> justsomeguy, removing the "in" in do-blocks is not so nice because now you have two syntaxes and that's confusing, but not removing the "in" in do-blocks is kinda less nice.
18:05:05 <justsomeguy> Very interesting. Thanks for the explanation, sshine :)
18:05:16 <sshine> yw.
18:06:07 <sshine> (and yeah, the fact that "in" is omissible in list-comprehension syntax is a side-effect of this, I think, since you don't have the actual indentation problem there.)
18:08:01 <sshine> maybe dolio thinks it's more of a problem somehow.
18:08:23 <sshine> I don't really ever use list-comprehensions, so maybe that's the case. :)
18:09:42 <dolio> Well, presumably you can do `[ (y, z) | x <- ... , let y = ..., ...]` But turning that into nested comprehensions is annoying.
18:10:47 <dolio> It would be something like `[ p | x <- ..., p <- let y = ... in [ (y, z) | ... ]]`
18:36:54 <koz_> Someone in here (maybe monochrom?) mentioned recently that the {mega,atto}parsec 'satisfy' can be implemented in the context of Selective (i.e. not full Monad). They claimed this is backed by research - could I please get a link?
18:41:38 <MarcelineVQ> idk if it covers satisfy deeply but https://mpickering.github.io/papers/parsley-icfp.pdf is about parsers which use Selective to inform compile-time decisions
18:42:35 <koz_> MarcelineVQ: Thanks - it's a start.
19:16:41 <monochrom> That was me alright. I learned of Selective from https://dl.acm.org/doi/10.1145/3341694
19:19:07 <monochrom> "satisfy pred = anyChar >>= \c -> if pred c then pure c else empty" is pretty much in line with the ping-pong example.
19:31:15 <Shadowraith> hi! im trying to convert output of a monad to a string (which it already should be) so im confused
19:31:36 <Axman6> that sounds like quite a confused question, cah you share some code?
19:31:39 <Axman6> can*
19:31:48 <Shadowraith> here is what the code is, i want to have it out put to a file
19:31:50 <Shadowraith> yeh ofc
19:31:56 <Shadowraith> http://0x0.st/i51b.txt
19:31:57 <Axman6> @where paste
19:31:57 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
19:32:03 <Axman6> thanks, too quick for me :)
19:32:13 <Shadowraith> ;)
19:32:40 <Axman6> I can;t see anything monadic there
19:32:43 <monochrom> There is no monad in that code.
19:32:45 <Shadowraith> oh what
19:32:52 <Shadowraith> the \x isnt a monad??
19:32:54 <Axman6> it's just a function
19:32:56 <Axman6> no
19:32:59 <Shadowraith> i thought that was a lambda... XD
19:32:59 <monochrom> It's just a lambda.
19:33:00 <Axman6> that's a lambda
19:33:01 <Shadowraith> frk me
19:33:03 <Shadowraith> im sorry
19:33:12 <Shadowraith> i still dont know how to get it to work tho.. Xd
19:33:24 <Axman6> your code is the same as writing: ppLayout x = case x of ...
19:33:33 <Axman6> what isn't working?
19:33:47 <Shadowraith> io $ appendFile "/tmp/.xmonad-layout-log" (ppLayout)
19:33:51 <Shadowraith> trying to do this
19:34:00 <Shadowraith> but its saying something bout a string
19:34:12 <monochrom> What is "io"?
19:34:16 <Axman6> what is the tyoe of appendFile?
19:34:37 <Shadowraith> being honest i have no idea at all, i thought that might have been a normal function
19:34:50 <Axman6> and what type does ppLayout have? (I know the ansxwer, I need to know if you do :)
19:35:00 <Shadowraith> should be string right?
19:35:08 <Axman6> nope, it's definitely a function
19:35:14 <Shadowraith> function is a type?
19:35:18 <Axman6> yes
19:35:25 <Shadowraith> gosh C stop interfering in my head haha
19:35:25 <Axman6> :t toUpper
19:35:28 <lambdabot> Char -> Char
19:35:32 <Axman6> :t show
19:35:33 <lambdabot> Show a => a -> String
19:35:50 <Axman6> I can tell you that ppLayout :: String -> String
19:35:59 <Shadowraith> OH
19:36:04 <Axman6> it needs to be passed a string, which you aren't doing
19:36:06 <Shadowraith> ok i understand that
19:36:14 <Shadowraith> i understand the type now
19:36:21 <Shadowraith> oh so i have to pass it
19:36:25 <Axman6> where are you expecting the string "Hidden Tall" to come from?
19:36:37 <Shadowraith> layouts somewhere...
19:37:55 <Shadowraith> im not exactly sure how to grab that
19:39:14 <monochrom> Who would be providing the input string?
19:40:46 <Shadowraith> xmonad layout, see what i did is because im not using dynamicPP anymore, i stole these lines from my dynamicLogHook function and was trying to do it without dynamicPP
19:42:29 <Axman6> what is dynamicPP?
19:42:39 <Axman6> you're going to have to share more code for us to be able to help you
19:42:58 <Shadowraith> https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-DynamicLog.html
19:43:32 <Shadowraith> im sorry ik, im trying but im not all there yet at all with haskell
19:44:00 <Axman6> that's fine, we're happy to help, but ywe also can't work in the dark. most of us don't use Xmonad
19:44:35 <Shadowraith> ik i appreciate it a ton, if i understood haskell a lil better it would be easier to explain
19:45:11 <Shadowraith> so what dynamicLog does is compile a bunch of different things from the program together into one file (im pretty sure)
19:45:19 <Shadowraith> layouts, workspaces, etc
19:45:48 <Shadowraith> i already have workspaces everywhere, and just want layouts to a file but not 100% sure how to do that
19:45:50 <Axman6> do you want to use dynamicLogWithPP which lets you customise things?
19:46:05 <Shadowraith> if that is the best option then yes
19:46:08 <Axman6> I don't really understand how files come into it
19:46:24 <Shadowraith> i think it exports to a file so that a separate program can use it
19:46:36 <Shadowraith> for my instance: my bar: polybar
19:47:11 <Axman6> I would guess that you can do something like: dynamicLogWithPP def{ ppLayout = \x -> case x of ... }
19:47:57 <Shadowraith> ooh yes i have that now, works with this `dynamicLogWithPP = def { ... }`
19:48:03 <Axman6> that is taking the defaults (which is what defaultPP contains but is deprecated in favout of def from Data.Default), and then overriding ppLayout
19:48:15 <Axman6> no, you shouldn't have an = in there
19:48:31 <Shadowraith> oh i think it gave an error before, lemme try again
19:48:33 <Axman6> def {... } is an argument to dynamicLogWithPP
19:49:03 <Shadowraith> xmonad.hs:465:1: error:
19:49:03 <Shadowraith>     Parse error: module header, import declaration
19:49:03 <Shadowraith>     or top-level declaration expected.
19:49:03 <Shadowraith>     |
19:53:13 <Shadowraith> 465 | dynamicLogWithPP def
19:54:51 <Shadowraith>     | ^^^^^^^^^^^^^^^^^^^^...
19:54:51 <Shadowraith>  
19:55:11 <Shadowraith> just noticed there is a dynamicLogString function?
19:55:21 <Axman6> without seeing more of your file I have no idea what you're going
19:55:59 <Shadowraith> do you want the whole thing?
19:56:04 <Axman6> sure
19:56:13 <Shadowraith> http://0x0.st/i51L.txt
19:56:25 <Shadowraith> its in the log hook
19:57:07 <Axman6> Can you use the paste website from above? syntax highlighting helps a lot
19:57:19 <Shadowraith> oh im sorry that was a keybind i had
19:57:27 <Shadowraith> @where paste
19:57:27 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
19:59:31 <Shadowraith> https://paste.tomsmeding.com/b8Y135W6
19:59:52 <Shadowraith> sorry,was too large to even copy from vim lol so had to use a gui editor :ree:
20:01:23 <Axman6> ok, look more closely at what's happening in the screen1LogHook example, you've forgotten to copy some quite important stuff
20:01:40 <Axman6> what code have you added?
20:02:45 <Axman6> I don't really understand what you're trying to do with dynamicLogString
20:03:09 <Shadowraith> that was just testing, the dynamicLogString (originally dynamicLogWithPP)
20:03:12 <Axman6> but it looks very suspicious since that's the name of something that XMonad defines, so you're shadowing its definition
20:03:24 <Shadowraith> the dbus stuff i want rid of, as to why i commented that out
20:03:52 <Axman6> I think what you want to so is: myLogHook = dynamicLogString def{ ppLayout = \x -> case x of ... }
20:05:12 <Shadowraith> can i append it to the end cuz i need the ewmh line
20:05:19 <Shadowraith> like with a $
20:07:24 <Axman6> try https://paste.tomsmeding.com/CohO6Z58
20:07:49 <Axman6> I don't really understand what you're trying to do with the appendFile call, but it feels like that is probably being taken care of for you
20:08:08 <Shadowraith> shoot i copied the ld instead of \x, that was a testto
20:08:33 <Shadowraith> myLogHook = ewmhDesktopsLogHookCustom (map unmarshallWindowSpace . namedScratchpadFilterOutWorkspace)
20:08:35 <Shadowraith> what about this line?
20:09:02 <Axman6> comment it out? I have no idea what it's doing
20:09:19 <Shadowraith> i need that line, its handling my workspace output
20:09:57 <Axman6> then you may be out of luck, at least as far as I can see. taking a look though
20:11:20 <Axman6> what is this case statement you've written supposed to be doing?
20:11:45 <Shadowraith> where is a case statement?
20:11:48 <Shadowraith> apologies..
20:12:04 <Axman6>  case x of     -- Changes layout name to be displayed
20:12:05 <Axman6>                      "Hidden Tall"
20:12:36 <Shadowraith> gotcha, that is to convert the names of  my layouts to a string for polybar to use
20:12:42 <Shadowraith> with special polybar formats
20:13:09 <Shadowraith> the first string isthe layout being grabbed the secondis what is to be sent to pbar
20:13:16 <Shadowraith> u prob knew that hto
20:13:27 <Axman6> ok, I thnk you might be best off to ask in #xmonad, this is getting very Xmonad specific more than Haskell specific
20:13:50 <Shadowraith> hm ur probably right
20:14:00 <Shadowraith> i originally thought it was more haskell based
20:14:15 <Shadowraith> cuz i thought \x was a monad :joy:
20:16:52 <Shadowraith> hold up maybe this is haskell to
20:17:17 <Shadowraith> lets say the input to the case function is `S.layout`
20:17:43 <Shadowraith> i should be able to get a string then since i have an input
20:20:58 <Axman6> I don't understand the question
20:21:02 <Axman6> what's S.layout?
20:21:36 <Shadowraith> i think that is the layout name
20:22:22 <Axman6> it doesn't show up in your code anywhere
20:22:53 <Shadowraith> S is from a module
20:23:01 <Shadowraith> StackSet
20:23:21 <Axman6> it also seems to be Search?
20:23:42 <Axman6> in fact it is XMonad.Actions.Search in the code you pasted
20:23:59 <Axman6> XMonad.StackSet is W
20:24:09 <Shadowraith> oh goodness then W.layout is prob what i meant
20:27:19 <Shadorain> Btw I'm Shadowraith
20:27:49 <Axman6> :thumbsup:
20:32:16 <Shadorain> So if I'm able to grab what I need which is a string (the name of layout) then I can do whzt I originally wanted which was output the format string to a file 
22:17:59 <Shadowraith> https://hackage.haskell.org/package/xmonad-contrib-0.13/docs/XMonad-Util-Loggers.html
22:18:01 <Shadowraith> check this out
22:18:09 <Shadowraith> there is a logLayout function!
22:18:30 <Shadowraith> i just have to tear it apart and somehow get it to log to a file!
23:39:23 * hackage telegram-bot-simple 0.3.5 - Easy to use library for building Telegram bots.  https://hackage.haskell.org/package/telegram-bot-simple-0.3.5 (swamp_agr)
