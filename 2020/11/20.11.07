00:13:52 * hackage graphql 0.11.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.11.0.0 (belka)
01:32:44 <random> hey guys, is there some way to get all types inside the project which have a specific instance?
01:39:50 <srk> random: with :i in repl
01:40:27 <random> srk: I mean using template haskell or something
01:42:18 <Athas> Is there a non-quadratic 'nub' in base?
01:42:37 <Athas> Or an easy way to write it?  I guess sort following by removing neighbouring duplicates, but I can't find a function that nicely does the latter...
01:43:43 <ski> > (map head . group . sort) "mississippi"
01:43:45 <lambdabot>  "imps"
01:44:06 <Athas> Not a big fan of the partial function, but thanks.
01:45:20 <ski> @type map Data.List.NonEmpty.head . Data.List.NonEmpty.group . sort
01:45:21 <lambdabot> Ord b => [b] -> [b]
01:46:00 <Athas> Ah, nice!
02:12:21 <olligobber> if I type `data Olligobber = Olligobber' into ghci then do `pure Olligobber' nothing happens, but if I type `pure Nothing' it prints Nothing
02:12:39 <olligobber> so my guess is the default instance for Applicative is IO
02:13:03 <olligobber> and I guess if there's no show instance it doesn't print anything?
02:22:47 <tomjaguarpaw> Yes, there are some rules like that
04:28:57 <ironChicken> i'm copying the wx bouncing balls example from <https://wiki.haskell.org/WxHaskell/Quick_start>. there's one very small thing i don't understand. in the expression `varUpdate vballs (bouncing pt:)`, what does that trailing colon do? i assume it's the cons function. so is it being partially applied maybe?
04:30:46 <c_wraith> ironChicken: that's exactly correct
04:30:58 <c_wraith> ironChicken: it's known as a section, and all operators support them
04:31:15 <int-e> > (1:) [2,3]
04:31:17 <lambdabot>  [1,2,3]
04:31:29 <c_wraith> (with the ugly exception of subtraction in one case)
04:31:35 <int-e> recall that [1,2,3] is 1:(2:(3:[]))
04:31:38 <mastarija> but in this case it seems like an error
04:32:12 <mastarija> something is missing, bouncing takes in a point, not a function
04:32:19 <ironChicken> c_wraith: ah yes, i see. that makes sense
04:32:28 <__monty__> mastarija: Bouncing gets a point.
04:32:42 <mastarija> it gets (pt:)
04:32:43 <__monty__> mastarija: The result of `bouncing pt` is the first argument to (:).
04:32:59 <mastarija> ah, you are right
04:33:04 <mastarija> it was weirdly formatted
04:33:05 <c_wraith> mastarija: function application has higher precedence than any binary operator
04:36:49 <c_wraith> hmm.  here's a thought.  Now that there's -XNegativeLiterals, is it worth having an extension to remove prefix - as an operator?
04:37:27 <c_wraith> I'd happily use negate to not have to worry about special rules about - as a section
04:37:33 <__monty__> Would that entail distinguishing (- 1) and (-1)?
04:38:30 <c_wraith> yes, but -XNegativeLiterals already makes (1 + -1) parse differently than (1 + - 1)
04:38:32 <ironChicken> i've just re-written it as `varUpdate vballs (\ps -> (bouncing pt) : ps)` which makes it clearer, to me at least
04:39:48 <__monty__> ironChicken: Parens are rarely a bad idea.
04:39:53 <ski> ironChicken : function application binds tighter than any (normal) operator. that's why you don't have to write `(foo x) + 2 * (bar x y)', you can just write `foo x + 2 * bar x y'
04:40:42 <__monty__> c_wraith: Ah, so just make right-side sections using (-) an error?
04:41:10 <ski> @type (2 + 3 *)  -- i'd like this to not be an error
04:41:12 <lambdabot> error:
04:41:12 <lambdabot>     The operator ‚Äò*‚Äô [infixl 7] of a section
04:41:12 <lambdabot>         must have lower precedence than that of the operand,
04:41:53 <ski> it should be `(2 +) . (3 *)', or `\x -> 2 + 3 * x'
04:42:47 <int-e> > (- 1 +) 2
04:42:50 <lambdabot>  1
04:43:33 <ski> i suppose one might call it a "MultiOperatorSection", maybe ?
04:44:58 <ski> (although, perhaps that name would suggest that one could expect also `(2 + * 3)' to work, which is not what i really had in mind. just the situation, where the "hole", the missing/elided operand occurs either at the start, or at the end, of the tokens wrapped inside the brackets)
04:44:59 <c_wraith> ski: By analogy to TupleSections...  (+ *) === \x y z -> x + y * z    ?
04:45:11 <ski> see above ^ :)
04:45:24 <c_wraith> I mean, that is how TupleSections works
04:46:06 <ski> (and no, not really in analogy to `TupleSections' (i'm not sure they existed, when i first wanted this ..), although i got them in mind, when i wrote the above clarification)
04:46:42 <c_wraith> They've been around for like 10 years now...  Which reminds me I've been using Haskell for longer than that. :)
04:46:58 <ski> one could perhaps argue for something in analogy to `TupleSections', too, as an extension/generalization of what i was arguing for. but i didn't have that in mind
04:47:11 <ski> heh :)
04:49:44 <ski> if you think of an operator section as "leave out the leading, or trailing, operand", then one's easily lead to this generalization, where you, in terms of AST, have one operator nested inside the operand of another, but where the precedences are such that you don't need to wrap in brackets. and then one could easily want to also be able to "leave out" the leading/trailing operand, despite it being nested 
04:49:50 <ski> inside two (or more) operators, not just one
04:51:49 <ski> @type (take 2 . drop 3 .)  -- this is a particular case, which feels annoying, since `.' is an associative operator
04:51:50 <lambdabot> error:
04:51:50 <lambdabot>     The operator ‚Äò.‚Äô [infixr 9] of a section
04:51:51 <lambdabot>         must have lower precedence than that of the operand,
05:08:52 * hackage mmsyn6ukr 0.9.0.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.9.0.0 (OleksandrZhabenko)
06:54:22 * hackage haskell-formatter 2.0.3 - Haskell source code formatter  https://hackage.haskell.org/package/haskell-formatter-2.0.3 (evolutics)
07:21:11 <Franciman> hi, what is the state of wxhaskell? It seems to be abandoned
07:22:12 <merijn> Yes, no, maybe?
07:22:18 <[exa]> Franciman: if you totally don't need precisely wxwidgets, I suggest you go with a more lively toolkit
07:22:38 <[exa]> (if you need them, advice still applies)
07:23:13 <eayus> I'm trying to use the "cryptonite" package to generate random numbers, however I'm always getting the same result of all bytes=256. I'm using the "getEntropy" function from Crypto.Random.Entropy (https://hackage.haskell.org/package/cryptonite-0.27/docs/Crypto-Random-Entropy.html). It doesn't  mention anything about seeding. Anyone have any ideas?
07:23:53 <[exa]> eayus: can you post a minimal (non)working example that does this?
07:24:04 <[exa]> (also, byte value 256 is fishy)
07:24:06 <merijn> That...does not like a function users should be using
07:24:26 <Franciman> [exa], apart from gi-gtk which more lively toolkit is there?
07:24:30 <eayus> I've tried various other functions in the library with the same result
07:24:40 <eayus> I'll make a pastebin, one sec
07:25:26 <[exa]> Franciman: there's been some fuss about declarative gtk in haskell which I looked at briefly and found quite nice. Gtk is probably the sanest wxw alternative.
07:25:44 <Franciman> the problem with gtk is that I need a treeview with a custom model
07:25:55 <Franciman> but it seems to be really hard to create an instance of TreeModel
07:25:56 <Franciman> :<
07:26:01 <[exa]> here https://wickstrom.tech/programming/2018/09/04/declarative-gtk-programming-with-haskell.html
07:26:27 <eayus> Here is a minimal example of the problem https://pastebin.com/ifLkdiYW
07:26:41 <eayus> Using the bytestring and cryptonite libraries
07:26:52 <Franciman> thanx [exa] 
07:27:17 <merijn> eayus: What do you need said entropy for? (i.e. is there no simpler/more robust way to get what you need?)
07:27:27 <[exa]> Franciman: untested though
07:27:37 <merijn> oof
07:27:50 <merijn> cryptonite use /dev/random with higher priority than /dev/urandom 
07:28:17 <[exa]> eayus: can you instead just read from /dev/urandom as recommended by ....just read merijn's message :D
07:28:33 <merijn> eayus: Basically: Isn't it just easier to read N bytes from /dev/urandom (depends on if you need Windows support, I guess)
07:28:44 <eayus> I just need to generate a cryptographically secure random number. I tried using other functions in the library (such as "seedNew"; etc) with same result
07:29:01 <eayus> I could do that, just seems a bit awkward
07:29:21 <[exa]> eayus: try `getEntropy` from System.Entropy
07:30:22 <eayus> Ah now that works
07:30:37 <merijn> Crypto.Entropy seems more of an internal thing as the docs in Crypto.Tutorial don't mention any entropy relates thing at all
07:31:11 <eayus> Maybe, but I was tried to follow the method in Crypto.Tutorial and had the same problem
07:31:17 <[exa]> Franciman: re the treeview model, anything specific?
07:31:45 <Franciman> I have my data structure (which is a bit more involved than a simple list, it's a finger tree that enables me to run interval queries)
07:31:58 <Franciman> I would like to use it as a model for the treeview
07:32:09 <merijn> eayus: Anyway, I wouldn't necessarily trust my crypto to any of the "native Haskell" libraries due to lack of auditing. I like cryptonite's hashing stuff, but that's much less security sensitive (and trivial to test)
07:32:14 <Franciman> so that I don't have to duplicate data (and thus have problems with undo redo etc)
07:34:03 <eayus> merijn: This is only for an assignment, so fortunately I don't have to really account for potential vulnerabilities in the libraries I'm using.
07:34:19 <eayus> However always returning the same random value crossed the line :P
07:36:40 <merijn> eayus: If it just an assignment is cryptographic randomness really a requirement?
07:37:08 <merijn> If you just need "random" there's much easier ways
07:37:28 <[exa]> Franciman: oh so. Well the general advice is 'do not model', it is very problematic :] Btw., Have you seen immediate-mode GUIs?
07:38:00 <Franciman> yes, is there any binding for haskell?
07:38:14 <Franciman> it's interesting, and could be easier to code
07:39:04 <[exa]> well if you can live with rendered output it's the easiest ever. No idea about the binding though (would love to know myself)
07:39:17 <eayus> merijn: Unfortunately the assignment isn't exactly clear, since otherwise I would just be using System.Random. 
07:39:26 <Franciman> I know about imgui
07:39:33 <Franciman> but let's see if there is a binding
07:39:45 <Franciman> what i'd love to avoid is to draw widgets myself
07:39:50 <Franciman> I'm really bad at that :P
07:40:01 <[exa]> the first google is bad. :D
07:40:10 <merijn> eayus: I'd just use System.Random, send an email to the TAs and then you can always replace it later with "something" (even reading /dev/urandom or something)
07:40:15 <Franciman> even hackage
07:40:28 <eayus> merijn: Yeah I think that's the best idea
07:40:38 <[exa]> the problem with imgui is that it's a really C-specific hack
07:41:12 <Franciman> hmm I see
07:41:13 <[exa]> I wondered if we could have something similar atop of State and Lenses instead of the implicit references everywhere, it kinda didn't spawn itself yet
07:41:24 <[exa]> (would be SO COOL with gloss, right? :D )
07:41:43 <Franciman> that'd be cool indeed
07:42:26 <Franciman> last thing to try is fltkhs, it seems cool, but it *forces* you to use stack
07:42:31 <Franciman> I don't want to use stack
07:42:34 <[exa]> oh noes
07:42:36 <merijn> what?
07:42:39 <merijn> No it doesn't
07:42:59 <Franciman> I tried to build it with cabal
07:43:13 <Franciman> and it doesn't work, I get a strange error about the package not boeing registered
07:43:14 <Franciman> being*
07:43:28 <Franciman> I gotta say I compiled with the bundled flag
07:44:33 <merijn> It *should* work with cabal-install
07:45:46 <merijn> Ah, looks like a classic case of "fucked up bounds"
07:46:26 <Franciman> merijn, I asked fgaz 
07:46:41 <merijn> Franciman: Which version of cabal-install are you using?
07:46:42 <Franciman> he said that the Setup.hs does Strange^{TM} things with hooks
07:46:52 <Franciman> and he could reproduce the issue
07:47:03 <Franciman> 3.2.0.0
07:52:35 <tomsmeding> Today I used DataKinds for the first time, and noticed that -Wunticked-promoted-constructors is in -Wall ( https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wunticked-promoted-constructors )
07:53:12 <tomsmeding> I had been under the impression that ' was only used if it's necessary for disambiguation, but I'm probably wrong on that part; do people heed that warning normally?
07:53:24 <tomsmeding> (I assume so because it's in -Wall, but still)
07:53:32 <merijn> tomsmeding: It must be new in -Wall, tbh
07:53:46 <merijn> Because when I used DataKinds I never get that warning
07:53:51 <fgaz> Franciman, merijn: Yeah, the package is copied but not registered. I didn't really read the full Setup.hs, I just saw the registerHook and concluded that it's probably because of it. There isn't really any other way to get that error afaik
07:54:30 <tomsmeding> merijn: ghc 8.8.4 here ü§∑
07:54:58 <fgaz> Of course, the bounds are _also_ fucked up
07:55:13 <merijn> fgaz: Of course, because being a good citizen is hard :p
07:56:18 <merijn> I'm going to write a grumpy old man blogpost and yell at people to stop listening to "Timmy, the ADHD monkey" part of their brain when they bitch about needing to write other-modules and adding upperbounds
07:57:03 <Franciman> I think it's stack's fault
07:57:04 <Franciman> it's hell
07:57:08 <Franciman> in earth
07:57:46 <merijn> I don't like waiting for stop signs or paying taxes either, but goddammit "we live in a society!"
07:58:11 <merijn> Franciman: Stack and FPComplete's encouragement/condoning of lack of upperbounds certainly doesn't help, no
07:58:22 <tomsmeding> merijn: you're going to have to learn some more grumpy old man language :p
07:58:32 <merijn> At least Snoyman was forced to eat his words on committing .cabal files
07:58:52 <merijn> Now they should just disable automatic hpack support in stack >.>
08:01:06 <tomsmeding> hah! but I outsmarted -Wunticked-promoted-constructors:  data LabelType = NodeLabel_ | EnvLabel_ ; type NodeLabel = 'NodeLabel_ ; type EnvLabel = 'EnvLabel_
08:01:40 <merijn> fgaz: Looks at this gorgeous matrix: https://matrix.hackage.haskell.org/#/package/fltkhs/0.8.0.3/
08:01:48 <merijn> tomsmeding: Welcome to 2013 ;)
08:02:14 <merijn> tomsmeding: That's a documented trick for ensuring users of your code aren't forced to enable DataKinds to use your code :p
08:02:26 <tomsmeding> ah lol
08:02:35 <tomsmeding> yay reinvention of old tricks
08:03:22 * hackage miv 0.4.5 - Vim plugin manager written in Haskell  https://hackage.haskell.org/package/miv-0.4.5 (itchyny)
08:04:16 <fgaz> Wait, they didn't switch it off yet? So their build tool does the opposite of their recommendation?
08:05:02 <merijn> fgaz: They didn't stop recommending hpack
08:05:18 <fgaz> merijn re build matrix: I saw that, I saw that :-/
08:05:23 <merijn> fgaz: They merely stopped recommending "don't commit your generated cabal file"
08:05:34 <merijn> fgaz: Did you check the failures?
08:05:45 <Franciman> I'll try to ask fltkhs author if it's possible to support cabal :<
08:05:58 <merijn> Apparently they're using cabal-version 2.0, but then use deprecated fields >.>
08:06:45 <fgaz> merijn: yeah, they don't use build-tool-depends
08:07:12 <merijn> fgaz: Also, which me luck
08:07:19 <merijn> I've decided to embark on a quest
08:07:33 <merijn> The Don Quixotic quest of figuring out run-tool-depends >.>
08:08:13 <fgaz> merijn: well... good luck :D 
08:08:56 <fgaz> hmm, it shouldn't be too different from the current data-files stuff... ...right?
08:10:09 <merijn> fgaz: That's what I thought
08:10:22 <merijn> Then I thought about it for 5 more minutes and realised it is
08:10:24 <merijn> by a lot :p
08:12:55 <fgaz> merijn: what's the biggest problem you ound?
08:15:33 <motte> hi, i'm using the dhall library to parse a config file into haskell and i'm having problems with decoding Lists into Sets - dhall defaults to setIgnoringDuplicates which gives errors when duplicates are found
08:15:45 <motte> this is the relevant instance declaration: https://hackage.haskell.org/package/dhall-1.36.0/docs/src/Dhall.html#line-1410
08:16:04 <motte> my question is, how can i override the declaration in a reasonable way in my own code?
08:17:40 <motte> should i define my own type class for the types i want to be decoded with setIgnoringDuplicates so i can write a more specific instance declaration?
08:33:42 <[exa]> Is there a common name for GADTs that hide an inner type behind typeclass interface?
08:34:21 <[exa]> roughly: data X where ToX :: Someclass a => a -> X
08:34:52 <[exa]> s/name/naming scheme or idiom/
08:36:27 <Franciman> [exa], existential data type?
08:36:52 <[exa]> uh yes that's true, I was asking more like how to name the types
08:37:28 <[exa]> say the typeclass is "Fooable", should the type be say "GenericFoo" or "WrappedFooable"?
08:41:33 <nshepperd> SomeFoo?
08:42:03 <int-e> . o O ( Fooize )
08:42:43 <int-e> Or maybe -ify
08:44:22 * hackage tldr 0.9.0 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.9.0 (psibi)
08:46:08 <[exa]> hm, sounds like SomeX wins
08:46:28 <[exa]> -ize and -ify names are superoverloaded by js libs... in this case Selectize
08:46:32 <[exa]> thanks!
08:59:23 * hackage minizinc-process 0.1.1.0 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.1.0 (LucasDiCioccio)
09:01:27 <ski> [exa] : i commonly go for "Some-" or "-able" (assuming the class doesn't end with "able" ..)
09:04:22 <[exa]> it's for wrapping selda queries now, SomeSelect works perfectly (like, I should have asked myself "what's inside? oh yeah some select")
09:08:32 <ski> (i guess i'm not sure i'm that happy with the naming of `Typeable',`Foldable',`Traversable' .. hmm)
09:13:35 <merijn> fgaz: The basic problem is this. Suppose we (sensibly!) limit ourselves to executables that in cabal packages
09:14:05 <merijn> fgaz: We "just" have to install those in, say, the libexecdir, obtainable via getLibexecDir to keep prefix independence
09:14:40 <merijn> fgaz: Except...what if that executable itself uses getDataDir/etc. to access stuff (or hell, it's own libexecdir with other executables!)
09:15:54 <merijn> fgaz: If we wanna keep things prefix independent we probably wanna combine that in (sub)directories of our package's prefix, but then you need to change the way the installed executables access those files to point to our package's datadir(s)
09:16:39 <merijn> fgaz: Now, that's not unsolvable, but it'll probably require at least *some* thinking on how to get it right
09:17:08 <merijn> fgaz: Where as with build-dependencies we can just assume they're in the global store, because you don't need to package them
09:17:31 <merijn> (build-tool-depends, I should say)
09:19:28 <Cheery> merijn: I figured out how to do the unit removal.
09:20:04 <Cheery> https://www.reddit.com/r/haskell/comments/jmzg57/is_it_possible_to_trim_unit_types_away_from_a_type/
09:20:46 <merijn> reddit's CDN seems to have died :p
09:21:00 <siraben> merijn: how come?
09:21:47 <siraben> Oh it's very slow right now
09:21:53 <merijn> siraben: I get an error
09:22:18 <siraben> "all of our servers are busy right now"
09:23:12 <hekkaidekapus> motte: The setFromDistinctList‚Äôs documentation says: ‚ÄúAn error is thrown if the list contains duplicates.‚Äù You have to ensure you are decoding from a set-like list.
09:23:42 <hekkaidekapus> motte: You can decode a list and convert it to a set in Haskell.
09:24:07 <hekkaidekapus> > S.fromList [1, 1, 2, 3, 3] -- motte
09:24:09 <lambdabot>  fromList [1,2,3]
09:24:47 <Cheery> I lost my mouse to my cat and it's a bit awkward to do stuff with a computer right now. Maybe that thing gets back up or smt.
09:24:48 <fgaz> merijn: why can't we assume they're in the global store?
09:25:54 <fgaz> After all, we do with data files
09:26:20 <merijn> fgaz: Eh, no, we don't
09:26:28 <merijn> fgaz: That's simply their *default* location
09:26:55 <geekosaur> there's some horribly ugly and fragile hacks for data files, iirc
09:27:07 <merijn> fgaz: It's overridable, so that packagers of, say, apt-get etc. can install them wherever is appropriate for their system
09:27:19 <merijn> geekosaur: I wouldn't say that
09:27:28 <merijn> It's about as sensible as you can do
09:27:44 <geekosaur> we may be thinking of different things, I'm thinking of the hack to allow running smething in place before installation
09:28:01 <geekosaur> which iirc only works right with cabal 1.x
09:28:14 <merijn> fgaz: You can't assume thing will be in the store at runtime, because you can't assume there will *be* a store on the machine a user wants to use an executable
09:28:35 <motte> hekkaidekapus: yes, but i'd like that the conversion be done while decoding
09:28:48 <merijn> geekosaur: Eh, I can tell you that every cabal-install between 2.0 and 3.4 has had 0 issues in finding data files of uninstalled executables when using v2-run
09:29:28 <merijn> geekosaur: Because literally everything in my phd project has dependend on that working since 2016 and it never once broke, across all those cabal versions and several systems :p
09:29:29 <motte> hekkaidekapus: i can write a separate instance declaration for every type i plan to keep in a set like this: http://ix.io/2DkK
09:30:05 <matthew-> :t (id,id)
09:30:06 <motte> hekkaidekapus: i'm wondering if there might be a better way
09:30:06 <lambdabot> (a1 -> a1, a2 -> a2)
09:30:23 <matthew-> am I right in thinking the universal quantification is outside the whole thing?
09:30:36 <hekkaidekapus> motte: `list :: Decoder a -> Decoder [a]`. You can do `S.fromList <$> list`.
09:31:01 <matthew-> i.e. (‚àÄA,B.(Tuple ((‚äó ((‚Üí A) A)) (‚äó ((‚Üí B) B))))) ?
09:31:04 <merijn> hekkaidekapus: Well, no, because that exact expression is a type error ;)
09:31:22 <hekkaidekapus> merijn: hehe‚Ä¶
09:31:30 <geekosaur> % :set -fprint-explicit-foralls
09:31:31 <yahb> geekosaur: 
09:31:37 <fgaz> merijn geekosaur I fixed data-files in v2-run in my first SoC iirc
09:31:39 <geekosaur> % :t (id,id)
09:31:39 <yahb> geekosaur: forall {a1} {a2}. (a1 -> a1, a2 -> a2)
09:31:45 <merijn> fgaz: \o/
09:31:56 <merijn> fgaz: Well, now you know it wasn't for nothing!
09:32:20 <fgaz> Not too much of an hack, simply an environment variable which overrides hardcoded Paths_ stuff
09:32:20 <motte> hekkaidekapus: there already exists a decoder for decoding lists that contain duplicate elements - setIgnoringDuplicates
09:33:35 <fgaz> merijn: shouldn't distros use the Cabal interface? Otherwise it's just layering build tools for nothing
09:33:58 <fgaz> Which actually is a thing for rust and go, which don't have the Cabal vs cabal-install separation
09:34:10 <hekkaidekapus> motte: Then, what‚Äôs wrong with lifting S.fromList into your list decoder? IMO, orphans (what you‚Äôre trying to do) and overlapping instances are not worth it in this case.
09:34:26 <merijn> fgaz: How you build doesn't really matter
09:35:04 <merijn> fgaz: The point is that the end result needs to be prefix independent, and installing executables inside "your" prefix which may rely on their own prefix independence isn't obvious
09:35:08 <merijn> Actually
09:35:15 <monochrom> Distros usually use Setup.hs.  Setup.hs usually uses the Cabal interface.
09:35:17 <merijn> How *does* that work for libraries
09:35:37 <merijn> fgaz: Well...maybe the problem is already solved :p
09:35:53 <monochrom> Setup.hs also has a lot of command line options that serve distro packaging needs, e.g., separate steps of building, copying.
09:36:12 <dcoutts> prefix independent libs is awkward for libs with data files
09:36:15 <merijn> I mean, cabal-install literally just calls into Setup.hs, so...
09:36:28 <fgaz> with cabal-install you always have the store as runtime dep though
09:36:29 <fgaz> it doesn't, the store is always a dependency
09:36:29 <fgaz> well, unless you are lucky and you have only statically-linked no-data-files stuff
09:36:32 <merijn> dcoutts: But does it even work right now?
09:36:47 <dcoutts> merijn: I think it works for everything except libs with data files
09:36:54 <merijn> dcoutts: ugh
09:37:14 <merijn> dcoutts: Well, on the bright side, if I solve this for run-tool-depends then fixing the library case seems trivial enough
09:37:30 <merijn> Since the problems seem identical
09:37:59 <dcoutts> one needs a convention on how to find lib data files relative to the exe that uses them
09:38:15 <matthew-> geekosaur: thanks - I didn't know about yahb
09:38:40 <merijn> Well, you need a convention on how to *install* things relative to the executable, finding follows trivially from there ;)
09:39:09 <merijn> dcoutts: Do you happen to know where in Cabal the Paths_ generation stuff (roughly) is?
09:39:32 <fgaz> Or you could also just use the same approach as data files (Paths_), and then both can be fixed together... somehow...
09:39:33 <fgaz> I think there's an issue about overhauling Paths_ generation to make it relocatable somewhere
09:39:59 <merijn> fgaz: It is already relocatable by setting the proper environment variables, I'm pretty sure?
09:40:12 <fgaz> merijn: it's in Cabal/Distribution/Simple/Build/PathsModule.hs
09:40:14 <merijn> Which means packagers just have to indirect via a shell script which sets those correctly
09:40:32 <motte> hekkaidekapus: `S.fromList <$> list` doesn't type check though? not sure how i would use S.fromList with the decoder
09:40:40 <fgaz> merijn: you'd have to set env variables for every dep with data files
09:40:45 <merijn> motte: "fmap S.fromList . list" works
09:41:11 <fgaz> merijn: rather, distros usually just use the Setup.hs interface to install stuff in the right places
09:41:19 <motte> merijn: oh, thanks
09:41:28 <monochrom> May I suggest Windows Registry?  >:)
09:42:10 <dcoutts> merijn, fgaz: what I wanted to do (at some point in the past) was to add a flag --prefix-independent which would "do the right thing" and conflict with any othe config flags that would cause a prefix-dependence. It might require certain conventions (to handle data files etc).
09:42:16 <merijn> fgaz: If that's true (I'm not sure) That's an artifact of the current (mistaken) assumption that there's only a package's install files", rather than "those of the transitive dependencies"
09:42:52 * hackage yesod-auth-hashdb 1.7.1.5 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.7.1.5 (paulrouse)
09:43:08 <hekkaidekapus> > S.fromList <$> pure [1, 1, 2, 3, 3] -- motte
09:43:10 <lambdabot>  error:
09:43:10 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòf0‚Äô arising from a use of ‚Äòshow_M442697496552...
09:43:10 <lambdabot>        prevents the constraint ‚Äò(Show
09:43:19 <merijn> dcoutts: That's seems reasonable
09:43:35 <motte> hekkaidekapus: but i still need to write an overlapping instance?
09:43:42 <merijn> dcoutts: I dread the thought of adding a flag to cabal(-install), though >.>
09:44:11 <dcoutts> Heh, It's not that bad.  This would be primarily a Cabal Setup.hs flag.
09:44:14 <merijn> I don't think any mere mortal understands the weird ass indirection through Setup.hs via Cabal
09:44:19 <monochrom> I have a cunning plan!  The lack of --prefix=foo means prefix independence.
09:44:29 <fgaz> merijn: "assumption that there's only a package's install files" isn't that true though? When using the Setup.hs interface of a specific package
09:44:40 <monochrom> How do you like my idea of subtracting a flag? :)
09:44:53 <merijn> monochrom: That won't work, because --prefix would install everything relative to that, which many distros don't do/want
09:45:06 <dcoutts> monochrom: it needs a bit more than that. All the other file flags have to be '$prefix/' for starters.
09:45:28 <merijn> fgaz: It's not, because if you install an executable in a prefix independent way the transitive dependencies linked in need to be able to find their stuff too
09:46:12 <fgaz> merijn: ah yes, I thought you were referring to the current prefix-dependent way
09:46:12 <dcoutts> monochrom: the benefit of an explicit flag is that it's a clear declaration of intent, so it means it's reasonable for it to impose restrictions, whereas just not specifying --prefix is a bit weak
09:46:34 <fgaz> whoosh
09:46:39 <fgaz> (I think)
09:47:06 <merijn> monochrom: I like your idea of subtracting a flag IFF you field all user questions/complaints pertaining to it on all social media :)
09:47:10 <merijn> Sounds like a fair deal!
09:47:29 <monochrom> Well yeah once again backward compatibility strikes.
09:48:02 <hekkaidekapus> motte: No because of this: list :: Decoder a -> Decoder [a]; S.fromList :: Ord a => [a] -> S.Set a; What do you think is the type of `fmap S.fromList . list`?
09:48:12 <merijn> All problems with Cabal/cabal-install boil down to two categories: 1) backwards compat and 2) people hate robust future-proof design :)
09:48:35 <merijn> (see the relentless moaning about listing modules and upper bounds)
09:49:11 <geekosaur> "I never make mistakes!"
09:49:15 <dcoutts> monochrom: it's not just backwards compat: asking for prefix independence really adds constraints compared to prefix-dependence.
09:49:25 <dcoutts> It's not a bad thing to be explicit about that.
09:54:19 <fgaz> by the way is there any other language / build tool / package manager that can offer prefix independence and supports data files?
09:54:20 <fgaz> and that does that well
09:55:05 <fgaz> ...AppImage I guess :-P 
09:57:31 <geekosaur> docker, sort of?
09:57:46 <geekosaur> more realistically speaking, it's a Hard Problem
10:12:57 <Cheery> merijn: you or smb. told me about this regex library.
10:13:31 <Cheery> I didk check inside it, I find the exact same implementation as mine.
10:13:50 <Cheery> or oh.. it's a bit different
10:17:49 <motte> hekkaidekapus: i'm afraid i still don't understand. http://ix.io/2DkX - i get a duplicate instance declaration error
10:19:24 <hekkaidekapus> motte: Do not define another instance. Could you write out the type of `fmap fromList . list`?
10:20:05 <hekkaidekapus> (Here in the chat)
10:21:18 <motte> Ord a => Decoder a -> Decoder (S.Set a)
10:23:35 <hekkaidekapus> motte: That type tells you then that you can directly decode a Set.
10:25:28 <hekkaidekapus> If you want a mnemonic name for the combinator, write `foo :: Ord a => Decoder a -> Decoder (Set a); foo = fmap fromList . list`
10:27:13 <motte> hekkaidekapus: sure, but i kind of rely on FromDhall instances, as i have many nested types
10:27:35 <motte> hekkaidekapus: some of which contain Sets
10:28:01 <hekkaidekapus> motte: The remaining part is to write a `Decoder Foo`. Since Foo is a record, check Dhall‚Äôs `record`.
10:31:53 <hekkaidekapus> motte: It will something like `record (MkFoo <$> field "baz" strictText <*> field "bar" setIgnoringDuplicates)`.
10:33:12 <hekkaidekapus> You can continue the (<*>) as long as there are more fields in your record type.
10:34:06 <motte> hekkaidekapus: at the end of the day i'll still need to write something like `instance FromDhall Foo` and use my newly written decoder there
10:34:48 <motte> hekkaidekapus: i fail to see how this is better than writing an overlapping instance
10:37:11 <hekkaidekapus> motte: Deriving is not necessary. You will parse directly from Dhall and the result will be a Foo. The parsing happens inside the Decoder.
10:39:42 <hekkaidekapus> motte: The parsing function will be an f = input foo.
10:41:16 <motte> hekkaidekapus: won't i have to write the whole hierarchy of decoders by hand if i'm not using Deriving?
10:42:33 <hekkaidekapus> motte: Yeah, you are targetting a custom data type and for that, you need to define the full decoders indeed.
10:43:02 <[exa]> *evil me:* generate them with template haskell
10:43:10 <[exa]> *realistic me:* generate them with CPP!
10:43:43 <hekkaidekapus> [exa]: TH is a bit too much at this stage, I think.
10:44:25 <motte> but why do it if i have it all working with deriving already? is defining an overlapping instance considered terrible style or something?
10:44:56 <geekosaur> it's a bug waiting to happen
10:46:13 <hekkaidekapus> motte: What you are talking about is called ‚Äòorphan instances‚Äò. It is usually not a great idea.
10:46:34 <hekkaidekapus> And yes, what geekosaur said about overlapping instances.
10:47:39 <hekkaidekapus> The instances are orphans when they are defined in a module other than the class where they belong to.
10:47:58 <hekkaidekapus> s/when/because
10:48:23 <koz_> It's not only a bug waiting to happen - it's GHC error vom you can't make sense of that _will_ happen.
10:48:39 <koz_> (I know because I've had to handle legacy decisions causing this exact problem several times _just this week_)
10:48:59 <koz_> (because people seem to want to shove type classes into every possible hole)
10:49:03 <koz_> (because reasons I guess)
10:51:51 <hekkaidekapus> Second take: The instances are orphan because they are defined in a module other than the one defining the class where they belong to.
10:52:21 <motte> well, i see your point, but i'm pretty reluctant to write a ton of boilerplate just to avoid the orphan instances
10:52:53 <monochrom> https://www.michaelpj.com/blog/2020/10/29/your-orphans-are-fine.html
10:56:32 <hekkaidekapus> motte: Now you have enough data about possible gotchas, it‚Äôs up to you to make up your mind about the trade-offs you can afford.
10:57:36 <motte> hekkaidekapus: indeed, thanks for the help
10:57:50 <hekkaidekapus> yw
10:58:06 <int-e> motte: Hmm, Arbitrary instances are a tricky subject :-/ if you put them in your library, you have a QuickCheck dependency for no particularly good reason, but if you don't, other people cannot reuse the ones you've written... and you probably don't want to split up every library into separate packages for the library, its instances for testing, and the testsuite...
10:58:11 <int-e> uhm
10:58:12 <int-e> monochrom: ^^
10:59:42 <int-e> monochrom: (I know you're not the author of that post. But you brought it up.)
11:00:16 <monochrom> It is not just Arbitrary.
11:01:11 <c_wraith> orphan instances are not a huge problem in code that you don't distribute.  You might need to remove/change them when you update dependencies, but it's not like they're going to break someone else's stuff. You own all your risk.  But putting them into a library takes a lot more thought.
11:01:12 <monochrom> You define a data type, you publish it in a published library. You would also like to publish the lenses and prisms associated with that data type.
11:01:24 <monochrom> Some authors decided to split. Some didn't.
11:01:52 <monochrom> In this case I think the majority chose to split, mytype and mytype-lens.
11:01:52 <c_wraith> But yeah, when the data type and class are in different packages, it's really weird to say one must depend on the other and define the instance.
11:28:52 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.1.0.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.1.0.0 (OleksandrZhabenko)
11:38:53 * hackage ukrainian-phonetics-basic 0.2.0.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.2.0.0 (OleksandrZhabenko)
11:54:53 * hackage uniplate 1.6.13 - Help writing simple, concise and fast generic operations.  https://hackage.haskell.org/package/uniplate-1.6.13 (NeilMitchell)
12:02:23 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.1.1.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.1.1.0 (OleksandrZhabenko)
12:12:23 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.1.2.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.1.2.0 (OleksandrZhabenko)
12:23:53 * hackage json-to-haskell 0.0.1.0 -   https://hackage.haskell.org/package/json-to-haskell-0.0.1.0 (ChrisPenner)
12:31:23 * hackage ghcide 0.5.0 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.5.0 (PepeIborra)
13:04:57 <srid> maralorn: can HLS be installed via nix? without going through the innatities of stack/ raw cabal.
13:05:02 <srid> the `master` branch of it, I mean
13:05:06 <srid> (not the one in nixpkgs)
13:08:28 <srid> incidentally, ghcide 0.5.0 was released
13:25:50 <bqv> srid: pkgs.ghcide
13:26:05 <bqv> there's also the hie-nix repo
13:26:14 <bqv> or infinisil's all-hies repo
13:26:28 <srid> bqv: looking for latest development version
13:26:47 <bqv> also, if i have `gets _mylens` using state and lens, how could i change that to use optics?
13:27:08 <bqv> srid: you could override the sources, potentially
13:27:18 <bqv> i dunno, i tend to just use ghcide
13:27:38 <Cheery> anybody else feel that haskell is horrible once you get to use it?
13:27:49 <koz_> Cheery: Quite the reverse.
13:28:21 <bqv> ^
13:29:11 <Cheery> It's better than C++, or GCC, and I'd say today that even Python is worse.
13:29:13 <geekosaur> depends on how you're using it. (thinking of singletons here ‚Äî dependent Haskell it is not, yet)
13:29:19 <monochrom> Scheme is the one that is horrible once I get to use it.
13:29:35 <koz_> monochrom: Yeah, and it also depends on _which_ Scheme.
13:29:45 <koz_> Since there's a lot of them, and they differ from each other in quite non-trivial ways.
13:30:18 <monochrom> But they are all horrible in fundamental, common ways.
13:30:51 <monochrom> For example function composition and currying become very verbose and cumbersome.
13:31:02 <lortabac> Cheery: what aspect of Haskell you don't like?
13:31:32 <monochrom> For example I keep making mistakes that are mistakes only because of eager evaluation.
13:32:39 <monochrom> For example pattern matching. Sure, every Scheme in practice offers a pattern matching story, but none is anywhere close to as syntactically lightweight as Haskell.
13:33:27 <Cheery> lortabac: I'm tripping on them. I mean, one of them is Text/Lazy text
13:33:41 <Cheery> oh and String on that.
13:33:52 * hackage phonetic-languages-properties 0.2.0.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-properties-0.2.0.0 (OleksandrZhabenko)
13:34:51 <Cheery> then I write tons of LANGUAGE pragmas while I eventually need stuff. But many of those things are relatively sane things like overloaded strings are.
13:34:53 * hackage pcapng 0.1.0.0 -   https://hackage.haskell.org/package/pcapng-0.1.0.0 (MichalGajda)
13:36:05 <Cheery> I fail to like cabal, and setting up projects.
13:37:00 <lortabac> I agree for the pragmas, it's a huge waste of time
13:37:52 <Cheery> I've found all, functional dependencies, GADTs, type families useful
13:38:05 <lortabac> you can put them in Cabal if you want to avoid the pragmas
13:38:18 <lortabac> I mean, in the .cabal file
13:38:24 <Cheery> but them all together make crazy language.
13:38:56 <Cheery> it's like making it impossible for anybody else to touch the code
13:39:11 <Cheery> because he needs to know so much Haskell first.
13:39:37 <lortabac> Cheery: my professional experience with Haskell is the exact opposite
13:40:15 <lortabac> people tend to understand Haskell code bases faster than other languages
13:44:03 <Cheery> lortabac: well there are many good things mixed in, but I'm going to look at a networking library that crashes on a connection issue rather than communicate that it can happen through its type.
13:44:50 <Cheery> then bitch about it because it's so bad when you could figure that happens before you run the program.
13:45:14 <Cheery> overall I like it though.
13:46:00 <lortabac> regarding lazy text, I don't understand the problem
13:46:23 <bqv> but regarding string vs text, I do
13:46:25 <pjb> lortabac: that's just because they understand haskell code bases lazily.
13:46:36 <bqv> lol
13:46:37 <lortabac> :)
13:57:39 <Cheery> I can say it's awe inducing though, that this thing is still working.
13:58:24 <Cheery> and when it works it does good.
14:03:52 * hackage phonetic-languages-examples 0.2.0.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.2.0.0 (OleksandrZhabenko)
14:42:22 * hackage futhark 0.18.2 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.18.2 (TroelsHenriksen)
14:56:23 <daydaynatation> when I do this: runghc -package inline-c-cpp InlineCPP.hs, I got: Variable not in scope: main :: IO a0
14:56:28 <daydaynatation> why
14:56:40 <daydaynatation> It's just a main function in it
15:01:55 <bqv> daydaynatation: does it have type IO a?
15:05:50 <maralorn> srid: I don‚Äòt know. I think writing a default.nix for the hls repo wouldn‚Äòt be to hard.
15:06:53 * hackage type-of-html 1.6.1.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.6.1.0 (knupfer)
15:07:04 <daydaynatation> bqv: it has IO ()
15:07:32 <daydaynatation> bqv: i can compile it with ghc without prob
15:09:13 <daydaynatation> bqv: sorry, just realize the error comes from another source:
15:09:15 <daydaynatation> inline-c-cpp:0:67: error:
15:09:15 <daydaynatation>     ‚Ä¢ Variable not in scope: main :: IO a0
15:09:15 <daydaynatation>     ‚Ä¢ Perhaps you meant ‚Äòmin‚Äô (imported from Prelude)
15:09:59 <bqv> ..are you calling main?
15:10:14 <daydaynatation> yes
15:10:34 <daydaynatation> Does main have to be inside a Main module?
15:10:47 <Tattletale> I believe so, yes
15:10:59 <daydaynatation> I see, let me try
15:11:05 <Tattletale> I've run into issues from GHC when I have main in a module not called Main
15:11:23 * hackage type-of-html 1.6.1.1 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.6.1.1 (knupfer)
15:11:36 <Tattletale> I don't think the file itself needs to be called Main.hs. It just needs that 'module Main' at the top
15:13:04 <daydaynatation> I see
15:20:26 <davean> daydaynatation: Why are you calling main?
15:20:49 <davean> and what are you doing with its return there that its wondering about it type?
15:21:16 <davean> If it *did* have type IO () you'd get a different error
15:21:35 <davean> daydaynatation: so something you're claiming doesn't add up here.
15:23:52 <daydaynatation> davean: let me post it
15:26:11 <daydaynatation> davean: https://pastebin.com/CkXuRvK4 
15:27:26 <Tattletale> so it's not actually calling main explicitly
15:28:23 <daydaynatation> Tattletale: why is that>
15:29:05 <Tattletale> Oh, I was just thinking aloud. I'll try running it locally to see what happens
15:29:26 <davean> But to explain, its because theres no call to main 
15:29:32 <davean> theres just a definition of main, which is fine
15:29:49 <davean> but again we were trying to sort through your claims above, so this helps!
15:42:05 <Tattletale> daydaynatation: I ran into some issues with the compilation due to the missing header files, so I got rid of them.
15:42:13 <Tattletale> Once I did, I could compile with no problem.
15:42:32 <Tattletale> The only C++ code left in cppTest involves std::cout and std::endl
15:43:59 <Tattletale> Note that the std::count code doesn't actually print anything for me. When I run the program, nothing is printed
15:44:10 <Tattletale> *cout
15:50:35 <bqv> the one frustrating thing with haskell(ghc) i find, is that my file structure always ends up with a Namespace.hs and Namespace/ in every folder, and none of my file managers sort those next to each other
15:55:38 <monochrom> Yeah that could be a bit annoying. I imagine that one day if I'm annoyed enough, I may simply move Namespace.hs to Namespace/IndexHTML.hs :)
16:01:09 <sm[m]> bqv: agreed
16:01:43 <sm[m]> I mean, the fact that both are required is tedious
16:05:04 <daydaynatation> Tattletale: thx
16:05:22 <Tattletale> np
16:06:03 <daydaynatation> Tattletale: Did you mean you runghc the file with no problem?
16:06:09 <Tattletale> That's correct
16:06:26 <Tattletale> My guess is that there's something else with your project that is causing the problem
16:06:42 <Tattletale> Note that while I can compile and run the program, it doesn't actually print anything
16:06:46 <daydaynatation> Are you on a mac machine?
16:06:50 <Tattletale> No, Windows
16:06:56 <daydaynatation> wsl?
16:07:04 <Tattletale> No WSL
16:07:17 <daydaynatation> I can also compile without problem
16:07:32 <Tattletale> I used this version of inline-c-cpp: 0.4.0.2
16:07:59 <daydaynatation> me too
16:08:02 <Tattletale> What was the problem you were experiencing daydaynatation?
16:08:48 <daydaynatation> I can ghc myfile, to produce an executable. But I'd like simply use runghc on my file
16:08:52 <daydaynatation> without compiling it first
16:08:57 <Tattletale> Oh
16:09:02 <Tattletale> I was using stack build
16:09:22 <Tattletale> So runghc was complaining about main?
16:09:47 <daydaynatation> inline-c-cpp:0:62: error:
16:09:47 <daydaynatation>  
16:09:59 <daydaynatation>     ‚Ä¢ Variable not in scope: main :: IO a0
16:10:51 <xsperry> runghc needs main as well
16:11:26 <daydaynatation> I have a main
16:11:41 <Tattletale> Here's the pastebin daydaynatation posted earlier: https://pastebin.com/CkXuRvK4
17:13:07 <jcowan> I would like some help seeing if I correctly understand multiple-parameter type classes.
17:13:31 <jcowan> Suppose I have a class Thing instantiated by two types Thing1 and Thing2.
17:14:29 <jcowan> Thing is a commutative group (though I don't need to formalize this) whose operation is *.
17:15:24 <jcowan> Now it is the case that if you multiply a Thing1 by a Thing1, you get a Thing1, and ditto for Thing2.  But if you multiply a Thing1 by a Thing2, you get a Thing1 or a Thing2, depending on the particular objects you are multiplying.
17:15:56 <jcowan> Is Thing a multi-parameter type class?
17:19:53 <davean> No, thats not a type class. Because you need to know what you get back. You could return Either Thing1 Things2 but not Thing1 or Thing2 without it being type level computed
17:20:37 <koz_> You could do it with an associated type I think?
17:20:55 <davean> koz_: not if he can't compute which he gets back at the type level.
17:21:00 <koz_> (but that's outside the scope of MPTCs)
17:21:08 <koz_> Ah, I see.
17:21:25 <koz_> Yeah, reading again carefully, that sounds like something needing dependent types, if the result type depends on a value.
17:21:31 <davean> Right
17:21:33 <koz_> However, the `Either` option is a good one.
17:21:54 <davean> Now I think he's conceptualizing it wrong probably given the other things he said, but who knows. Thats a judgement call!
17:22:14 <davean> I'm putting medium money on an X-Y problem
17:42:51 <jcowan> davean: So you can't just define the * method as of type Thing -> Thing -> Thing?
17:43:45 <koz_> If I wanna do web scraping (or rather, tear apart HTML for pieces), what would you suggest I use?
17:44:17 <koz_> jcowan: Earlier, you said 'Thing' was a type class, not a type.
17:44:19 <koz_> Which is it?
17:45:06 <MarcelineVQ> koz_: tagsoup or taggy prob
17:45:45 <davean> jcowan: Sure, you can do it as Thing -> Thing -> Thing - but only if Thing is a type, as a type class its a *property*
17:45:46 <koz_> MarcelineVQ: Thanks!
17:45:56 * jcowan nods
17:46:05 <jcowan> Eventually this will sink into my brain, I hope, but it hasn't happened yet.
17:46:10 <davean> jcowan: so you have to do it as "(Thing a, Thing b, Thing c) => a -> b -> c"
17:46:19 <davean> but then you'd have to be able to return *any* c
17:46:24 <davean> but you can't return any c
17:46:36 <davean> you have to return the right c given a and b
17:46:52 <jcowan> I know that typeclasses are *for* ad hoc polymorphism, but not how they actually work.
17:46:56 <davean> if you COULD return any c, that would work - thats valid for some type classes
17:47:08 <jcowan> As for example?
17:47:25 <davean> well, for example we can make a IntergerIshMultuplication class
17:47:58 <davean> and if it has fromInteger and toInteger available we can multiple them together (as Integers) and convert them back out to an c of that class
17:48:22 <davean> Integeral a => IntegerMultiplication a
17:48:41 <davean> (IntegerMultiplication a, IntegerMultiplication b, IntegerMultiplication c) => a -> b -> c
17:49:01 <davean> integerMultiplicate a b = fromInteger $ toInteger a * toInteger b
17:49:06 <davean> good idea? Probably not.
17:49:10 <davean> but it serves as an example.
18:01:26 <koz_> What's the recommended library to use if you want an HTTP _client_, for pulling HTML off a website?
18:03:08 <davean> koz_: I certainly won't recomend it, but a lot of people like wreq
18:03:13 <koz_> dave
18:03:21 <koz_> davean: What would _you_ recommend then?
18:03:45 <davean> Nothing in Haskell. Like its hard to even hook DNS to avoid rebind attacks.
18:04:00 <koz_> So like, you suggest rolling your own?
18:04:12 <davean> All I see is deficiencies and the ability to do specific types of HTTP client tasks with them.
18:04:13 <koz_> Or like, borrowing curl or something?
18:04:18 <davean> I'd suggest considering what youre needs are
18:04:23 <davean> O
18:04:34 <koz_> My needs are 'I need to pull HTML off a website, which has HTTPS'.
18:04:49 <davean> I'm guessing I'd recomend wreq for your task, but there is *not* HTTP client I think in Haskell good enough to actually recomend without understanding your problem
18:04:50 <koz_> Streaming would be nice, but isn't strictly required.
18:04:52 <MarcelineVQ> I like req, which is different from wreq
18:05:35 <davean> koz_: That doesn't answer things like "are DNS rebinding attacks a problem for you?"
18:05:44 <koz_> davean: What are DNS rebinding attacks?
18:05:53 <koz_> I've never heard of them.
18:06:11 <MarcelineVQ> http-conduit is backed by conduit, re: streaming
18:06:34 <davean> koz_: They're a common time-of-check-to-time-of-use based attack against HTTP clients
18:06:54 <davean> koz_: they work by returning different IPs for a DNS request based on the count of requests from the IP requesting resolution
18:07:13 <davean> koz_: for example, causing you to request one of AWS's internal IPs and thus charge your account.
18:07:21 <davean> instead of what it looked like when you checked it
18:07:50 <davean> Its a very common threat against HTTP clients, and hence why I picked it as an example of Haskell HTTP client deficiencies
18:08:06 <jcowan> davean: I'll study your example when I am less addled.
18:08:15 <koz_> The thing is, all I know is that I'll need to scrape data off of pages, on the web, at fixed addresses.
18:08:24 <koz_> It's basically 'I need data to feed to my scraper'.
18:08:52 <davean> koz_: right, and if one of those happens to return a redirect, that ends up charging you money, are you happy?
18:09:13 <davean> If you trust the upstream *also* that changes things for example
18:09:19 <koz_> I trust the upstream in this case.
18:09:21 <davean> if you think the upstream is hostile, thats an entirely diferent problem.
18:09:30 <koz_> The upstream is definitely not hostile.
18:11:58 <koz_> And I _guess_ that I wouldn't be happy given your example (the redirect charging me money), however, I consider that highly unlikely.
18:12:07 <koz_> (as in 'hell would freeze over first')
18:38:18 <opticblast> Is there a good way to split a bytestream `n` bytes from its end?
18:39:08 <opticblast> I'm thinking something with the type signature `Int -> Stream (Of ByteString) m () -> Stream (Of ByteString) m ByteString`.
18:41:04 <koz_> opticblast: What if said stream is infinite? Or 50 gigs big?
18:42:06 <koz_> s/50/500/
18:44:01 <opticblast> Why should an infinite stream pose a problem? It should be possible to determine the next step of the resulting stream in bounded time (O(n)?)
18:44:30 <koz_> opticblast: You said 'n bytes from its end'.
18:44:38 <koz_> How do you determine where its end is?
18:44:56 <opticblast> The naive solution would be to, at each step, ask whether the stream has `n` bytes left
18:45:03 <koz_> Sure, and what if that never happens?
18:45:20 <opticblast> Then the return value of the stream will never be requested, so it doesn't matter
18:46:15 <koz_> Well, you could keep taking chunks of n, then feeding them back in as you go I guess?
18:46:29 <koz_> You'd need 2n lookahead but that's OK.
18:47:01 <koz_> Try writing this using 'take' - I think that's the primitive you want.
18:50:03 <opticblast> Wouldn't that have the problem of redoing part of the stream, I think? But `splitAt` works instead
18:50:20 <koz_> Yeah, splitAt would be better.
18:51:05 <opticblast> Thanks.
19:17:51 <xsperry> is there something like "aListOfValidPathCharacters" in System.FilePath or System.Directory?
20:37:22 * hackage pandoc 2.11.1.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.11.1.1 (JohnMacFarlane)
20:39:23 * hackage json-to-haskell 0.1.0.0 -   https://hackage.haskell.org/package/json-to-haskell-0.1.0.0 (ChrisPenner)
21:15:45 <hololeap> xsperry: no, but you can write something that does that pretty easily. it's just filtering from `listDirectory`
21:17:49 <hololeap> assuming that you're looking for files/directories that are filtered using "aListOfValidPathCharacters"
21:20:22 <xsperry> I want a list of characters that can't be used in a filename, taking current OS/filesystem into account (or a common subset that works on most commonly used OSes and fss)
21:23:34 <koz_> Doesn't this depend on OS settings in some cases?
21:23:39 <koz_> (i.e. it'd have to be IO)
22:42:02 <hololeap> xsperry: checking the FS type is the main hurdle here. i don't know of a library for this. other than that, there's the `filepath` module which abstracts over Windows/Posix paths
22:42:55 <hololeap> (checking the FS and having a table of valid characters for each one that's supported)
