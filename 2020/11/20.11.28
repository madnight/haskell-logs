00:47:04 <dminuoso> vfaronov: Works fine for me, this needs more context.
00:50:51 <dminuoso> vfaronov: Are you possibly just observing `strip` doing more work (because by default debug symbols are not stripped by cabal)
00:50:58 <dminuoso> Unless you also specify library-stripping
00:51:28 <dminuoso> Or.. mmm
00:51:42 <dminuoso> Ah no
00:55:12 <dminuoso> vfaronov: https://cabal.readthedocs.io/en/3.4/cabal-project.html#cfg-field-executable-stripping
00:55:21 <dminuoso> "When installing binary executable programs, run the strip program on the binary."
00:55:48 <dminuoso> So it seems this is done just at installation, not building
00:55:53 <vfaronov> dminuoso: after `cabal install --install-method=copy --overwrite-policy=always`, doing `strip` (GNU strip 2.30) without options on the resulting binaries makes them about 1/4 smaller
00:56:10 <dminuoso> vfaronov: compare `objdump -x` between them
00:56:16 <dminuoso> What's their difference?
00:56:31 <dminuoso> Also, if you flip on `-v2` you should verbose output from the strip invocation
01:00:13 * hackage bytestring-tree-builder 0.2.7.6 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.7.6 (NikitaVolkov)
01:02:50 <vfaronov> dminuoso: `-v2` produces lots of output but no mention of strip. `objdump -x` reports a symbol table and a `.debug-ghc-link-info` in the binary (before manual `strip`). Cabal 3.2.0.0
01:03:15 <pjb> It's quite idiotic to use strip.  If you do, then you need to keep a unstripped copy, to be able to debug crashes.  So you actually almost double the required disk space.  There's no win.
01:04:19 <dminuoso> pjb: That's difficult to say, in general.
01:04:38 <dminuoso> But yeah, splitting doesnt even make too much of a difference
01:04:41 <dminuoso> split-sections otoh does.
01:04:52 <[exa]> pjb: sometimes it's equally idiotic to keep 500MB binaries around. :]
01:05:19 <dminuoso> err *stripping doesnt make too much of a difference!
01:05:26 <dminuoso> in one of our projects, split sections is the difference between 100MB and 4MiB, split only brings that further to 3MiB
01:06:40 <[exa]> well not in general case but you can go quite far with a bit of C++ tricks..  I was more reacting to the general idea that stripping is bad‚Ñ¢
01:06:40 <vfaronov> pjb: This is private software that I'll be rebuilding anyway if I have to debug it. I don't care much about binary size either, but I do scp these binaries around a lot, on top of it just feeling cleaner I guess
01:07:29 <dminuoso> vfaronov: have you turned on split-sections in your global cabal config?
01:11:06 <dminuoso> Just to get binary size down to reasonable levels, split-sections does most of the work. strip then just gets rid of debug symbols that could be useful, and its not much
01:14:25 <vfaronov> nope, trying now
01:16:30 <dminuoso> It's something that arguably everyone should enable in their global config
01:16:37 <dminuoso> The reason its not turned on by default is a bit questionable
01:36:44 * hackage bytestring-tree-builder 0.2.7.7 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.7.7 (NikitaVolkov)
01:38:14 * hackage phonetic-languages-simplified-common 0.3.1.0 - A simplified version of the phonetic-languages-functionality  https://hackage.haskell.org/package/phonetic-languages-simplified-common-0.3.1.0 (OleksandrZhabenko)
02:06:33 <vfaronov> dminuoso: wow that helped, thanks
02:07:09 <vfaronov> 104M ‚Üí 10M after split-sections + strip
02:40:45 <xerox_> can anyone compile any version of this? https://github.com/haskell/base16-bytestring
02:43:01 <xerox_> oh nevermind
03:00:13 * hackage derive-storable 0.3.0.0 - Derive Storable instances with GHC.Generics.  https://hackage.haskell.org/package/derive-storable-0.3.0.0 (mkloczko)
03:34:43 * hackage phonetic-languages-simplified-common 0.3.2.0 - A simplified version of the phonetic-languages-functionality  https://hackage.haskell.org/package/phonetic-languages-simplified-common-0.3.2.0 (OleksandrZhabenko)
03:36:22 <matthew-> huh, so haskell doesn't seem to allow partial application of infix ops. Is this just because it's not syntactically clear which arg is being provided, or is there a deeper reason?
03:36:40 <Squarism> Anyone got any clever idea on this. In arbitrary datastructure i want to create an "address" (lens single value Traversal if you will) that can be *serialized*. Ie an isomorph between String and the "address". The "address" should allow getting/setting the value in the arbitrary datastructure.
03:36:58 <Squarism> For an arbitrary*
03:47:43 * hackage phonetic-languages-simplified-properties-lists 0.2.0.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-simplified-properties-lists-0.2.0.0 (OleksandrZhabenko)
03:49:25 <hekkaidekapus> matthew-: ‚Äòinfix ops‚Äô are syntactic sugar for plain old functions. As such, they can naturally be partial applied.
03:49:32 <hekkaidekapus> > (+) 1 2
03:49:34 <lambdabot>  3
03:49:39 <hekkaidekapus> 1 + 2
03:49:52 <hekkaidekapus> > 1 + 2
03:49:54 <lambdabot>  3
03:50:01 <hekkaidekapus> > (+ 1) 2
03:50:03 <lambdabot>  3
03:50:12 <hekkaidekapus> > (1 +) 2
03:50:14 <lambdabot>  3
03:55:36 <dminuoso> matthew-: Of course haskell allows for it.
03:55:48 <dminuoso> matthew-: There's three different ways, one of which has an GHC extension
03:56:02 <dminuoso> A) you can use sections on binary infix operators
03:56:29 <dminuoso> e.g. (1+) or (+1), where the first is just partial application and the second one is shorthand for `\x -> x + 1`
03:57:18 <dminuoso> B) You can use section style for unary functions, allowing you to sort of do postfix operators, e.g. (x&) for some unary function &
03:57:28 <dminuoso> That one is however an implicit GHC extension (no explicit pragma needed)
03:57:42 <dminuoso> Or C) you can put it in parens, and then partially apply like you're used to: ((+) 1)
04:02:50 <nango> I'm writing a DSL for a research project, and I have some experience with Parsec, however I have never written a mini language before and I wante to ask if people think it's better to go with alex+Parsec or it's common just to go all the way with Parsec simply, what are people doing normally ? THX!
04:04:10 <srk> nango: http://dlaing.org/little-languages/ uses trifecta :)
04:04:48 <srk> actually parsers package
04:05:57 <nango> srk thanks this is certainly gold for me right now !
04:05:57 <dminuoso> nango: As a good default Id use megaparsec over parsec.
04:06:07 <dminuoso> trifecta is poorly documented and performs not so well
04:06:15 <dminuoso> It's main usefulness is high quality diagnostics
04:06:49 <dminuoso> (One cool trick is where you implement both a megaparsec and trifecta parser, and if the megaparsec fails, you re-parse with your trifecta parser for a better diagnostic)
04:07:11 <dminuoso> Giving you good performance as well as good diagnostics, at the cost of having to maintain two parsers
04:07:23 <dminuoso> And ensuring they parse the same grammar
04:08:15 <dminuoso> hekkaidekapus: Oh hah, I didnt see your responses. Sorry!
04:08:26 <tdammers> I'd say {mega,atto}parsec on its own > {mega,atto}parsec + alex, if only for the added complexity of the alex dependency
04:09:21 <dminuoso> What's the reason GHC uses alex+happy over say parser combinators? Just historic reasons because nothing else was around?
04:09:27 <dminuoso> Or do they perform notably faster?
04:12:42 <nango> dminuoso thanks, this is very useful, I'll take a deep look before diving into code frenzy, in my case performance is not an issue since it will never be the bottleneck, I care more about context for the user, since it is going to be for chemists and I don't want them seeing weird ghc messages they can't understand.
04:13:24 <dminuoso> Well it's not GHC messages that you'd be worried about
04:13:42 <dminuoso> Unless you're writing an EDSL, but then you wouldn't need a separate parser
04:15:15 <nango> yeah I meant just noisy messages. Alex spits out strictly valid Haskell98, maybe that and historicaly reasons are the reason ? I wouldn't know.
04:16:32 <dminuoso> Part of why the parser errors are so poor in GHC, is because of how our grammar is structured. Figuring out when to error out and what to report in a white space sensitive language is difficult
04:18:13 <dminuoso> But yeah, LALR/GLR parser generators generally have poor diagnostics
04:29:02 <jophish> angerman: how do GHC plugins work with cross compiling?
04:34:14 <hekkaidekapus> dminuoso: No problem. By the way, I use happy when I need to have a BNF-like representation of some grammar, which comes with another goody: getting shift & reduce diagnostics.
04:42:21 <nango> hekkaidekapus thanks, I'll also consider that
04:42:33 <angerman> jophish: they don‚Äôt. hsyl20 is on it :-/
04:42:43 * hackage text-manipulate 0.3.0.0 - Case conversion, word boundary manipulation, and textual subjugation.  https://hackage.haskell.org/package/text-manipulate-0.3.0.0 (BrendanHay)
04:42:43 <jophish> sounds tricky
04:43:00 <angerman> jophish: you essentially need them natively and have ghc load them properly.
04:43:19 <angerman> jophish: feel free to ask hsyl20 in #ghc
04:43:31 <angerman> We have a hack in ghcjs for Plutus. It‚Äôs all terrible :-)
04:43:34 <jophish> you've sated my curiosity for now :)
04:46:30 <jophish> actually I am not out of questions
04:46:38 <jophish> I'm about to write a plugin which inserts the machine word size into code
04:46:43 <jophish> and am concerned now
04:46:50 <jophish> (just kidding of course)
04:49:16 <Squarism> (repost) Anyone got any clever idea on this. For an arbitrary datastructure i want to create an "address" (lens single value Traversal if you will) that can be *serialized*. Ie an isomorph between String and the "address". The "address" should allow getting/setting the value in the arbitrary datastructure. 
04:56:42 <srid> <gentauro "ok. this website is nicely done."> You can generate one like that without writing any code, html or CSS by using https://neuron.zettel.page
05:22:56 <delbmuts_> Hi. I'd like to use servant-websockets with a custom servant monad, but don't know how. Something like: https://paste.debian.net/hidden/c2ecc0b2 How can I `ask` for `state`? Thanks.
05:23:43 * hackage phonetic-languages-simplified-common 0.3.3.0 - A simplified version of the phonetic-languages-functionality  https://hackage.haskell.org/package/phonetic-languages-simplified-common-0.3.3.0 (OleksandrZhabenko)
05:37:42 <angerman> jophish: just use CPP and WORD_SIZE or so. There is a constant for you without resorting to plugins ;-)
05:56:32 <sondr3> is there a way for me to insert a DEL character in a Haskell string? I get a "lexical error in string/character literal at character '\DEL'" error
05:58:13 <hpc> > chr 127
05:58:15 <lambdabot>  '\DEL'
05:58:25 <hpc> what's the whole string?
05:59:01 <sondr3> The whole string is "\n" :p
05:59:40 <hpc> well that doesn't have \DEL in it, so... :P
06:00:13 <sondr3> But that's what the error says, I just copied it, what do you see?
06:00:24 <hpc> "\n"
06:01:12 <hpc> fwiw, i am trying various string literals in ghci with \DEL and not getting any lexical errors
06:02:06 <geekosaur> am suspecting you got a literal DEL character in it somehow
06:02:28 <sondr3> I guess that's the problem, it's invisible in Firefox but a square in VSCode and invisible again in my terminal
06:02:55 <hpc> ah
06:02:58 <sondr3> Yeah, it's a literal DEL character, I guess a \DEL would do the same?
06:02:59 <hpc> yeah, you need to escape it
06:03:55 <geekosaur> no, the escape sequence will work
06:04:10 <geekosaur> it just doesn't like the literal character
06:04:53 * geekosaur actually thinks ghc is overly strict here. Also can't use e.g. private use area characters
06:13:18 <SrPx> Hey all. It has been half a decade since I released a Haskell library. I have one I'd like to publish now. Everything is in a single .hs file. I'm out of touch w.r.t. last developments in packaging. Is there a small tutorial that explains me all I need to do to set up a project around this file and release it? Should I use cabal, stack, for example? 
06:14:18 <hpc> use cabal
06:14:38 <f-a> there was something on the wiki, let me see if I can fish it
06:15:17 <f-a> http://wiki.haskell.org/How_to_write_a_Haskell_program#Structure_of_a_simple_project mhhh
06:16:53 <f-a> SrPx: a tl;dr version        `cabal init`, `cabal build` to see your project is building fine, `cabal haddock` if you want to check the rendered documentation, `cabal sdist` to generate .tar.gx and `cabal upload` to finally upload it (or use the web interface)
06:17:00 <f-a> if you get stuck, ask
06:17:04 <SrPx> perfect ty (:
06:18:06 <f-a> I have never used stack seriously so someone else could chime in
06:18:25 <merijn> f-a: Stack still uses cabal, so packaging is basically the same
06:18:50 <hpc> just different directories and a lot of wondering if your dependencies are in an lts or not
06:18:58 <f-a> merijn: there are things, as cabal users, that I envy of stack. One is ¬´open documentation in browser¬ª
06:19:13 * hackage phonetic-languages-simplified-common 0.3.4.0 - A simplified version of the phonetic-languages-functionality  https://hackage.haskell.org/package/phonetic-languages-simplified-common-0.3.4.0 (OleksandrZhabenko)
06:19:33 <f-a> they might be quite similar with the v2 commands (as ease of use), but the UX is slightly different
06:20:21 <merijn> f-a: Well, I meant that "you still need a cabal file for both" :p
06:20:31 <f-a> amen
06:20:39 <xerox_> SrPx: I think this is a decent introduction to packaging https://cabal.readthedocs.io/en/3.4/getting-started.html
06:20:54 <SrPx> ty <3
06:29:13 <maerwald> stacks as a cli tool does a lot of stuff better than cabal
06:29:33 <maerwald> just look at --help to get an idea
06:48:44 * hackage hedis 0.13.0 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.13.0 (k_bx)
07:36:26 <dminuoso> Squarism: IndexedX?
07:39:04 <dminuoso> Squarism: That is, if you have an IndexedTraversal, you just need to serialize the index.
07:44:44 * hackage heapsize 0.2.0 - Determine the size of runtime data structures  https://hackage.haskell.org/package/heapsize-0.2.0 (PepeIborra)
07:48:43 * hackage derive-storable-plugin 0.2.3.1 - GHC core plugin supporting the derive-storable package.  https://hackage.haskell.org/package/derive-storable-plugin-0.2.3.1 (mkloczko)
07:49:46 <Squarism> dminuoso, oh ok. ill check that out directly
07:52:14 <dminuoso> Squarism: Roughly Im thinking of this https://hackage.haskell.org/package/optics-core-0.3.0.1/docs/Optics-IxTraversal.html#v:element
07:52:19 <dminuoso> element :: Traversable f => Int -> IxAffineTraversal' Int (f a) a 
07:53:22 <dminuoso> And indeed
07:53:24 <dminuoso> https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Combinators.html#v:element
07:53:26 <dminuoso> lens has it too
07:53:48 <dminuoso> Or, the more general form
07:53:50 <dminuoso> elementOf :: Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a 
07:54:36 <Squarism> dminuoso, so how would the serialization to string be done? 
07:55:08 <dminuoso> Serializing the Int?
07:56:48 <Squarism> Hmm.. what does the integer represent? Ie. in say a record holding a list containing records with a field "fld1" ? 
07:58:38 <dminuoso> % probe n = ["foo", "bar","quux"] ^.. elementOf (traverse . traverse) n
07:58:38 <yahb> dminuoso: 
07:58:42 <dminuoso> Squarism: An index.
07:59:10 <dminuoso> Squarism: with elementsOf you can turn an indexed traversal into an (indexed) affine traversal
07:59:25 <dminuoso> See above probe
07:59:52 <dminuoso> That way you can serialize the Int, and recover an affine traversal from it again
08:00:05 <Squarism> okok.. ill try that
08:00:34 <dminuoso> When you said "traversal that targets one element" thats what we call an affine traversal
08:00:50 <dminuoso> lens cant represent it, so they're just traversals with the promise "targets only one element"
08:02:23 <Squarism> I guess It could be worth trying out. Had hoped for something more human readable but i guess beggars cant be choosers. =D 
08:04:45 <dminuoso> Squarism: I dont see any alternative, really.
08:05:06 <dminuoso> The only component in lens that lets you (partially) describe an optic is the index of indexed optics
08:05:17 <dminuoso> The other stuff is just van laarhoven/profunctor encoding, and you cant serialize those
08:06:12 <Squarism> Ill see what can be done with the IndexedTraversal 
08:09:04 <dminuoso> Squarism: Also be sure to look at reindexed.
08:09:15 <dminuoso> In case you have a non-Int index
08:09:41 <dminuoso> (You'll need some sort of injection into Int at the very least)
08:10:26 <ryantrinkle> is it at all plausible to have a "constrained kind", i.e. a kind such that all types in that kind are instances of a particular class
08:10:46 <ryantrinkle> i can't figure out whether that idea is 1) sensible at all; or 2) possible to do in GHC
08:10:52 <hpc> :k Num a => a
08:10:54 <lambdabot> error: Not in scope: type variable ‚Äòa‚Äô
08:10:54 <lambdabot> error: Not in scope: type variable ‚Äòa‚Äô
08:11:10 <hpc> :k (forall a. Num a => a)
08:11:11 <lambdabot> *
08:11:28 <hpc> looks like the constraint isn't reflected in the kind
08:11:34 <hpc> but as it turns out, Constraint is a kind
08:11:36 <hpc> :k Num
08:11:38 <lambdabot> * -> Constraint
08:11:38 <ryantrinkle> hpc: right
08:11:42 <ryantrinkle> yeah i'm familiar with that
08:11:43 <dminuoso> Mmm, you could have an existential buried in a newtype, lifted through DataKinds
08:11:50 <dminuoso> Would that work?
08:12:01 <ryantrinkle> dminuoso: it might! let me see
08:16:35 <SrPx> I'm getting: `cabal-3.2.0.0: can't find source for src/Main in src`, but I do have a `Main.hs` on `/src`
08:16:53 <dminuoso> SrPx: What invocation did you use, and can you share your cabal file?
08:16:54 <SrPx> I also have: `  main-is:             src/Main.hs` inside `executable` on `.cabal`
08:17:02 <SrPx> and `  hs-source-dirs:      src` there too
08:17:08 <SrPx> dminuoso: yes, hold on
08:17:25 <maerwald> main-is: Main.hs
08:17:50 <dminuoso> Ah I guess the error message does tell you
08:17:55 <dminuoso> It looks for "src/Main" inside "src"
08:17:57 <dminuoso> :p
08:18:09 <SrPx> oh lord
08:18:13 <SrPx> makes sense
08:19:49 <SrPx> okay, it builds now!
08:20:11 <SrPx> but there is a problem with `cabal install`
08:20:45 <SrPx> `Couldn't find module Foo` from `src/Main.hs`, but I do have a file called `src/Foo.hs` starting with `module Foo where`
08:21:33 <SrPx> Here is a complete log: https://gist.github.com/MaiaVictor/7040ce60ecaf939943d063071cfd8f07
08:22:46 <ryantrinkle> dminuoso: I think this is roughly what i'm going for https://gist.github.com/ryantrinkle/0e28bc1e458f71fd69462c7581d4ec60
08:23:23 <f-a> if seems you have a ¬´formality¬ª module SrPx 
08:23:26 <f-a> not FormalityLib
08:23:28 <f-a> *Formality
08:23:29 <ryantrinkle> it doesn't really seem like there's anywhere numtype could conjure up the Num dictionary from, though
08:24:06 <SrPx> f-a: no, src/FormalityLib starts with `module FormalityLib where`
08:24:12 <SrPx> `src/FormalityLib.hs`
08:24:29 <SrPx> also shouldn't this error show up on `cabal build` and not `cabal install`? weird
08:24:38 <f-a> In your exposed modules I see 
08:24:40 <f-a> Exposed-modules:      Formality
08:25:05 <SrPx> oh
08:25:18 <SrPx> hmm, but I wanted FormalityLib to be hidden
08:25:21 <SrPx> so I need to expose it, I see
08:25:48 <f-a> well, if you are developing a library, some modules will be exposed, no?
08:25:57 <hololeap> wouldn't the proper place to put those modules be in a "other-modules:" line?
08:26:07 <f-a> specifically, the modules a ‚Äî say ‚Äî executable will use
08:26:14 <f-a> and yeah, what hololeap says
08:27:25 <SrPx> `Formality.hs` (module Formality) is the module I'm trying to export. `FormalityLib.hs` is an huge generated file that shouldn't be exported. `Formality.hs` imports `FormalityLib.hs` and re-exports it with a nicer API, basically
08:28:11 <f-a> ok
08:28:24 <zfnmxt> In this post concerning Data.Singletons, the author states that he understands why the error they're having occurs, but *I* do not understand why (and am experiencing the same error), can anyone explain? https://stackoverflow.com/questions/58758599/creating-a-type-level-structure-that-contains-a-typelit-with-singletons
08:28:27 <f-a> then put FormalityLib in ¬´other modules¬ª like hololeap said
08:28:27 <hololeap> also, using `cabal install` is typically discouraged
08:28:37 <SrPx> hololeap: why?
08:28:47 <SrPx> f-a: I will, thank you (:
08:30:13 <hololeap> SrPx: i think because modern cabal builds all its dependencies within the project dir, and `cabal install` doesn't really accomplish anything other than cluttering up your ~/.cabal directory
08:30:27 <hololeap> but someone else should chime in on that one
08:30:54 <hololeap> it might make sense to use it when your package builds an executable
08:31:27 <SrPx> so, all is working now, and I have a cabal project that builds/installs, and a `fmhs` executable that type-checks formality files (yay) -- the question is, how do I publish it so people install it in their machines, if not using `cabal install` ? hololeap  
08:32:23 <f-a> SrPx: they will have a cabal package and your package listed in theh dependency sections
08:32:25 <monochrom> cabal install is not discouraged.
08:32:43 <SrPx> f-a: I mean, for people to use as a command line tool
08:32:44 <f-a> the build-depends one
08:32:50 <SrPx> not necessarily haskell developers
08:32:58 <f-a> for them, cabal install will do
08:33:07 <SrPx> I see. So I ask them to clone, cd and cabal install?
08:33:08 <hololeap> i thought it was when invoked from within a cabal source dir
08:33:19 <maerwald> it has unexpected semantics at least
08:33:21 <f-a> which will create a symlink in ~/.cabal/bin, so remember to put that in $PATH
08:33:52 <f-a> if you publish your package in hackage, just install cabal, cabal update (if needed) and cabal install yourpackage
08:34:05 <monochrom> That one is not discouraged either. I do that all the time.
08:34:49 <f-a> do that all the time (form the source dir) to obtain which result, monochrom ?
08:35:25 <monochrom> Because that source directory is authored by me, and I'm not uploading it to hackage, and it is an exe I want to use as an end user. As an end user, I'm not going to always cd into that directory and use "cabal run" now, am I?
08:35:51 <SrPx> do I add cabal.project.local files to my repo?
08:35:54 <monochrom> Therefore, inside that directory, issuing "cabal install" so my exe is on the PATH is necessary. What discouraged?
08:36:22 <maerwald> monochrom: it doesn't run `cabal build`, it runs `cabal sdist`,unpacks to a temp folder and builds it there
08:36:47 <f-a> SrPx: I do not do it and do not see a compelling reason to do it
08:37:06 <maerwald> it's not entirely clear to me how much of your cabal.project configuration is honoured when doing `cabal install`
08:37:11 <monochrom> I can also describe a slightly longer story about: If it's my source directory and it contains a library, and sometimes I want to use that library as an end user in a random ghci session.
08:37:16 <f-a> oh, so `cabal install` from local source folders got fixed, good to know
08:37:28 <monochrom> And it's slightly longer only because I need the --lib flag.
08:37:38 <SrPx> f-a: okay
08:37:43 <maerwald> stack does it right, it runs `stack build` and then copies the binary
08:37:59 <monochrom> And I need the --lib flag only because of someone else's ideology or religion that wants to discourage this perfectly common usage.
08:45:20 <hololeap> SrPx: i use cabal.project.local just so i can add custom GHC options that don't need to be shipped with the repo, and also to point to other local projects
08:45:32 <SrPx> okay!
08:45:36 <SrPx> all works, thanks everyone
08:45:41 <f-a> well done
08:45:46 <f-a> what does your exe do, btw
08:46:20 <hololeap> looks like some kind of compiler/interpreter for a custom language
08:46:34 * hololeap shrugs
08:46:43 <SrPx> it is the Formality language! (:
08:47:11 <SrPx> it is a proof assistant like Agda but more minimalistic, way simpler and faster in many senses
08:47:26 <monochrom> Is it a language for ants? Or am I mixing up "formal" with "formic"...
08:47:27 <SrPx> I implemented the whole language in itself, and now I compiled it to Haskell
08:48:14 <SrPx> I don't like the name, it is supposed to be a counterpart to Solidity, the smart-contract language. Formality was initially an internal project & Ethereum Foundation
08:48:23 <SrPx> https://github.com/moonad/FormalityFM/tree/master/bin/hs
08:48:45 <SrPx> here is the Haskell code, in case anyone is curious. I'll make a very cool blog post about this bootstrapping process when I finish the documentation
08:48:59 <SrPx> I also need to finish the Scheme compiler (:
08:49:29 <f-a> excellent SrPx 
08:49:36 <f-a> what is your blog, so I can add it to my rss
08:49:49 <tutorial> !list
08:49:49 <monochrom> tutorial: https://www.haskell.org/ghcup/
08:49:52 <SrPx> I don't have one, this will be the first post :P 
08:50:10 <SrPx> also if you guys have suggestions on what to use to make a minimalist, lightweight blog for these things
08:50:25 <SrPx> one that I can just write some markdown, publish and will give the least amount of work to me
08:50:25 <monochrom> "annealing" comes to my mind when I think of making something solid. (Well, "freezing" came first, but then when you solidify steel you don't call that freezing.)
08:50:28 <tutorial> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
08:50:33 <SrPx> specially don't want to deal with having to host it
08:50:57 <monochrom> oh, "forging" is better
08:53:05 <f-a> SrPx: there is a nice static site generator in haskell, hakyll
08:53:23 <f-a> also in haskell: https://discourse.haskell.org/t/announcing-neuron-zettelkasten-in-haskell/1137
08:53:33 <SrPx> f-a: I'll have a look, but if it just generates a static site there won't be comments and I'll need to host ):
08:53:51 <f-a> some people ¬´attach¬ª Discourse
08:54:17 <f-a> I just have a mailto: comment link at the end of the page (e.g. http://www.ariis.it/static/articles/dodecaphonic-experiment/page.html )
08:54:47 <SrPx> hmm
08:55:30 <f-a> (yeah, welcome to the 90s)
08:55:41 <f-a> check what other folks do
08:57:43 * hackage heapsize 0.3.0 - Determine the size of runtime data structures  https://hackage.haskell.org/package/heapsize-0.3.0 (PepeIborra)
09:08:59 <boxscape> hmm prime.haskell.org seems to be down
09:10:24 <justsomeguy> I'm trying to rewrite ‚Äúelem‚Äù in terms of ‚Äúfoldr‚Äù for practice. Here's what I have so far: ‚Äú  foldr (||) False . foldr (\y ys -> (y == e):ys) []‚Äù. Is it possible for me to move the ‚Äú(||)‚Äù operator into the first ‚Äúfoldr‚Äù?
09:11:57 <geekosaur> yes
09:13:17 <justsomeguy> Ok, I better experiment with this for a bit more and see if I can figure it out, then.
09:15:24 <boxscape> justsomeguy if it helps and if it's not obvious, keep in mind that foldr just replaces (:) with a function and and [] with a constant, so you might consider what f and z would have to be so that `elem x [1,2,3] = 1 `f` 2 `f` 3 `f` z`
09:15:34 <hekkaidekapus> monochrom: Have you heard of cabal-env? It avoid `cabal-install install --lib`‚Äôs pitfalls and, iirc, Oleg would like to get feedback on that as it is the next-generation `c.i. --lib.`
09:16:24 <boxscape> .. or `f 1 (f 2 (f 3 z)))`
09:19:29 <hekkaidekapus> > foldr f z [1, 2, 3]
09:19:31 <lambdabot>  f 1 (f 2 (f 3 z))
09:22:30 <justsomeguy> That does help :). Now I have ‚ÄúmyElem e = foldr (\y ys -> y == e || ys) False‚Äù.
09:24:14 <geekosaur> I'd reverse the alternative just to take advantage of short-circuiting, although I doubt it buys much unless the comparison is expensive
09:28:19 <tomsmeding> this _is_ the right order for short-circuiting, right?
09:28:59 <tomsmeding> > foldr (\y ys -> y == 0 || ys) False [0..]
09:29:01 <lambdabot>  True
09:29:04 <tomsmeding> > foldr (\y ys -> ys || y == 0) False [0..]
09:29:08 <justsomeguy> I think I was confused about whether ‚Äúys‚Äù would be substituted in as an unprocessed list, or the processed list with function applications. I was imagining that the cons cells were being replaced one-by-one, but instead they're replaced all at once, so ‚Äúys‚Äù is a function call stack.
09:29:11 <geekosaur> `y == e || ys' does the compariso first
09:29:11 <lambdabot>  mueval-core: Time limit exceeded
09:30:30 <tomsmeding> justsomeguy: yes that 'ys' is the result of the fold over the rest of the list
09:31:23 <tomsmeding> geekosaur: if you list the comparison first, then as soon as that ever returns true, the thunk for the fold over the remainder of the list need not even be evaluated ;)
09:32:52 <ski> justsomeguy : `ys' becomes the recursive call of `foldr'
09:33:48 <ski> > foldr (\x y -> x - y) z [a,b,c,d]
09:33:51 <lambdabot>  a - (b - (c - (d - z)))
10:16:46 <boxscape> Is there any way to access https://prime.haskell.org/wiki/PolymorphicComponents ? wayback machine doesn't have it, but duckduckgo lists a snippet of its text when searching for it (today it's just a synonym for RankNTypes, but I'd like to read more about what it used to be)
10:24:44 <boxscape> hm, well, https://downloads.haskell.org/ghc/6.10.1/docs/html/users_guide/other-type-extensions.html#universal-quantification still distinguishes between them, I suppose the User Guide ought to be enough specification
10:26:42 <merijn> boxscape: afaict from there it's just a subset of RankN
10:27:26 <boxscape> merijn from the User's guide it sounds like back then neither was a subset of the other, but I'm not sure
10:27:44 <boxscape> wait
10:27:45 <boxscape> I'm wrong
10:27:49 <boxscape> you're right
10:27:59 <merijn> :)
10:28:07 <merijn> Story of my life ;)
10:28:31 <merijn> Which would explain why that extension is gone noe
10:28:53 <merijn> Doesn't seem very useful to have separate dedicated one for constructors
10:30:06 <boxscape> merijn you can emulate RankNTypes using only PolymorphicComponents
10:30:11 <boxscape> that's what I'm doing in Java
10:32:20 <boxscape> i.e. if you have a type `forall r . (forall s . P s -> r) -> r`, you'll have to instead construct a type `data ForallP r = ForallP (forall s . P s -> r)` and then your type becomes `forall r . ForallP r -> r`
10:33:40 <boxscape> merijn I imagine if they were introduced at the same time the motivation was the same as for Rank2Types, to keep type inference for everything when it's enabled
10:34:27 <merijn> Rank2Type inference was never in GHC, though :p
10:34:33 <merijn> And most likely won't ever be
10:34:56 <boxscape> true, but I've heard that was the motivation, at least :)
11:07:13 * hackage phonetic-languages-ukrainian 0.3.0.0 - Prepares Ukrainian text to be used as a phonetic language text  https://hackage.haskell.org/package/phonetic-languages-ukrainian-0.3.0.0 (OleksandrZhabenko)
11:09:43 * hackage polysemy-time 0.1.1.0 - Polysemy effect for time  https://hackage.haskell.org/package/polysemy-time-0.1.1.0 (tek)
11:19:13 * hackage polysemy-test 0.3.0.2 - Polysemy effects for testing  https://hackage.haskell.org/package/polysemy-test-0.3.0.2 (tek)
12:32:43 * hackage advent-of-code-ocr 0.1.1.0 - Parse Advent of Code ASCII art letters  https://hackage.haskell.org/package/advent-of-code-ocr-0.1.1.0 (jle)
12:47:16 <mivael> > let  fromList = Data.Map.fromList;  union = Data.Map.union;  m = fromList [(2,200),(7,700),(3,300)];  n = [(8,800),(5,500)]  in  (union m . fromList) n
12:47:18 <lambdabot>  fromList [(2,200),(3,300),(5,500),(7,700),(8,800)]
12:47:49 <mivael> hello, is this a proper way to insert multiple elements into a Data.Map?
12:48:02 <merijn> mivael: Depends, what should happen on conflict?
12:48:53 <mivael> merijn: assuming we already checked, no conflicts
12:49:03 <merijn> Then sure
12:49:22 <merijn> mivael: Note that there's also unionWith and fromListWith which let you merge conflicts
12:49:34 <dsal> "checked" sounds suspicious.  Whatever checking you did must be duplicating work that would have to happen during this process anyway.
12:49:59 <merijn> dsal: The lack of "create map *or* error" in containers kinda annoys me
12:50:04 <merijn> Maybe I should make a PR...
12:50:17 <mivael> dsal: understood
12:50:32 <koz_> merijn: Would it be something like (Ord k) => [(k,v)] -> Maybe (Map k v)?
12:50:47 <koz_> Or like, Either (k, k) (Map k v)?
12:51:00 <koz_> s/(k, k)/k/
12:51:18 <merijn> koz_: Something like that, yes
12:51:18 <mivael> merijn: I mean should I expect a little performance penalty from creating an additional intermediary Data.Map?
12:51:26 <tomsmeding> merijn: there is traverseMaybeWithKey in Data.Map.Strict, but that's only for removing keys; there's also alterF, but that's only for single keys
12:51:29 <tomsmeding> I agree with your assessment :p
12:51:40 <koz_> I think the 'Either k (Map k v)' formulation is more useful, since then you'd know what caused the conflict.
12:51:51 <merijn> mivael: Yes, but not one I'd bother worrying about until you profile and notice a problem
12:51:58 <koz_> You could even go 'Either (k, v) (Map k v)' formulation for maximum infomativeness.
12:52:05 <merijn> tomsmeding: I guess mergeA does this
12:52:15 <mivael> merijn: thanks!
12:52:18 <tomsmeding> oh different module
12:52:19 <geekosaur> or [k] or [(k,v)]
12:52:29 <merijn> This is some generalised death machinery: https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Map-Merge-Lazy.html#v:mergeA
12:52:36 <koz_> geekosaur: Yeah, but I'd say once you found _one_ clash, you can probably stop. 
12:52:52 <tomsmeding> I guess, but indeed that's quite the hammer
12:54:37 <tomsmeding> I didn't know about mergeA, but I think I've never had the need for this full generality yet
13:14:27 <koz_> For megaparsec's 'space' combinator, if I _don't_ want to support block comments as such, what should I pass for its third argument?
13:18:19 <koz_> Ah, 'empty'.
14:25:27 <cads> anywhere I can read about how to trim down and clean up haskell libraries?
14:25:46 <dminuoso> What do you mean by "trim down and clean up"?
14:25:56 <merijn> cads: As in "I got to many on my system after working for a few months/year?"
14:26:29 <merijn> Also, stack or cabal-install?
14:26:35 <cads> no, like every module seems to have 60 lines of imports 
14:27:01 <merijn> cads: Within your own project, you mean?
14:27:08 <cads> sure
14:27:20 <cads> within code I want to refactor
14:27:29 <merijn> cads: Normally I'd define like a "project" prelude of common imports
14:28:00 <merijn> cads: Take the subset of modules that is in (nearly) every module of your project, define a single module that imports and reexports those
14:28:08 <cads> thinking of doing that locally to modules, if the imports are not shared
14:29:09 <merijn> cads: I mean, if all your modules have 60 imports and there's no common subset then, eh, you're out of luck
14:30:07 <dminuoso> otoh, if all your modules have 60 imports, Id be taking a closer look in general
14:30:33 <dminuoso> On average you might rather see 15-25 perhaps. 60 seems a bit high, especially if it's very consistent
14:31:34 <shapr> cads: if you have unused code, you could try https://github.com/ocharles/weeder
14:34:36 <merijn> GHC already warns about unused imports, though
14:35:00 <dminuoso> merijn: If you stuff it in an export list... then it does not. :(
14:35:21 <merijn> Well, sure
14:35:30 <monochrom> A monolithic design also has the symptom that every module "needs" to import everything else.
14:35:32 <merijn> Because then it's not unused
14:36:06 <dminuoso> merijn: That depends.
14:36:14 <dminuoso> If nothing imports or uses it, then its very much unused.
14:36:28 <dminuoso> For an internal component or non-exposed module that's detectable, so...
14:36:29 <monochrom> As opposed to: A layered design has every module only needs to import things from the layer below.
14:38:12 <cads> oh fun, there is no easy way to find out which unit tests touch this module. The unit tests consist of about 400 random .sh files whose names have nothing to do with modules
14:38:14 <texasmynsted> Sigh. Looks like I am going to have to come up with a project to use "MQTT" with. :-)
14:38:51 <cads> see, I was thinking that the unit tests would help me take this byzantine module and think about it the way the developer does 
14:38:59 <cads> it turns out, they probably do
14:40:23 <cads> what is the plushest and nicest behavior driven testing for haskell?
14:41:09 <cads> and can it help force-convert legacy tests written in .sh?
14:42:22 <cads> autrb2u - allurtestsrbelong2us <- this is what I would like this tool to be called
14:43:09 <cads> or just mmmzig
14:44:31 <shapr> cads: are they golden tests in the shell scripts?
14:48:44 <cads> I will have to read them and classify them a bit - there are 372 of them, many of them are just labeled by the bug fix they address, some of them kick off custom haskell fixtures, and there's probably some delineation between unit and integration testing, but currently all 327 shell files are jumbled together in one directory without any real taxonomy
14:50:10 <dsal> texasmynsted: I use it for everything.  Want to know when the hot tub is ready?  Turn on the 3D printer?  Measure energy consumption from my in-sink boiler? Adjust my car's charge level?  So much stuff...
14:50:29 <texasmynsted> :)
14:51:04 <dsal> Got an alert telling me my refrigerator got too warm after I put a bunch of water in it.
14:51:04 <texasmynsted> You are writing all this with your haskell implementation? Or Ivory or something?
14:51:05 <cads> shapr, I will assume that they're a golden standard in the sense that they do indeed work, and they do indeed flag breaking changes if I mutate the code at random
14:51:21 <cads> I haven't tried that yet - that should be fun
14:51:47 <texasmynsted> What devices are you using?
14:51:58 <dsal> texasmynsted: my mqtt broker is Haskell. Some stuff is if the shelf, some stuff is custom c++ embedded junk.
14:52:04 <shapr> cads: I'd suggest moving the shell scripts into hspec or something
14:52:18 <texasmynsted> Intersting
14:52:32 <texasmynsted> Sounds like killer blog material actually
14:52:53 <cads> shapr, anything even nicer and experimental than hspec?
14:52:54 <shapr> cads: is this a closed source codebase?
14:53:04 <cads> no
14:53:10 <dsal> Sonoff R2 is cool.  Basics are cheap.  Lots of esp32 with custom code.  RTL 433 translating to mqtt.  I built out a bidirectional IR <-> mqtt bridge a few days ago that will work with most things.
14:53:58 <dsal> texasmynsted: my car stuff is github.com/dustin/tesladb and influxer and outfluxer
14:55:38 <texasmynsted> Ha cool!
14:56:16 <texasmynsted> any luck with 8 bit chips?
14:59:27 <dsal> I've not tried.  My gate actuator was done on a board that cost around $5, so going lower doesn't make a lot of sense to me.  :)
14:59:48 <texasmynsted> Yeah, that is a good point
15:00:26 <cads> shapr, ah, there's a note to test maintainers - that takes us to the project documentation site, where we learn that these are indeed the golden standard "this is what the CLI should output" style of test
15:00:39 <cads> the unit tests live in the haskell module hierarchy
15:02:01 --- mode: tolkien.freenode.net set +o ChanServ
15:02:47 <texasmynsted> :-)
15:04:51 <shapr> cads: this sounds like academia-ware
15:05:14 <shapr> or perhaps written by those who speak Haskell as a tertiary language?
15:05:43 * hackage phonetic-languages-simplified-lists-examples 0.1.0.0 - Simplified and somewhat optimized version of the phonetic-languages-examples.  https://hackage.haskell.org/package/phonetic-languages-simplified-lists-examples-0.1.0.0 (OleksandrZhabenko)
15:12:47 <merijn> I wonder if that guy knows you're allowed to have more than 5 functions per package...
15:17:09 <jackhill> win 43
15:17:43 * hackage xcffib 0.11.0 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.11.0 (TychoAndersen)
15:17:46 <shapr> 43 WINS!
15:18:39 <sm[m]> cads: I keep unit tests in the haskell modules under test. Files containing functional tests are in per-command subdirectories, under a subdirectory, but I'm thinking about moving these into the module directories 
15:48:21 <sm[m]> don't know cads, just saw your recent comment
16:03:53 <aneksteind> does there exist a generalization of `Either`, something like `OneOf a b c d` ... that can have an arbitrary number of constructors?
16:05:10 <dminuoso> aneksteind: Well Either is that already.
16:05:19 <dminuoso> Since you can do `Either (Either Int String) Char` and so forth
16:06:21 <dminuoso> Or just plain ADTs.
16:06:54 <dminuoso> That is, `Either (Either Int String) Char` is equivalent to `data T = T1 Int | T2 String | T3 Char`
16:07:05 <dminuoso> (Or the better term here is isomorphic)
16:09:55 <sm[m]> I'm not missing a capitalize function in base, am I ?
16:09:58 <nshepperd> i think aneksteind is asking for anonymous cotuples, the dual of (a,b,c,d)
16:10:11 <dminuoso> Well, (a,b,c,d) is not generalized either.
16:10:23 <dminuoso> We just have all these tuple constructors hacked in manually...
16:11:27 <nshepperd> sure
16:11:41 <nshepperd> it's non generalised with fancy uniform syntax
16:12:13 <erisco> aneksteind, you can get hacking with variants and row types, unadvisable without a high payoff
16:12:16 <dminuoso> Even if we had some fancy uniform syntax for coproducts, pattern matching wouldn't be as pretty
16:13:49 <aneksteind> where can I look into variants (is that similar to C++ variants?) I'm mostly curious what can be done, this isn't for anything in particular
16:14:24 <nshepperd> there's unboxed sums but that syntax feels a bit janky
16:14:32 <aneksteind> I found this: https://hackage.haskell.org/package/haskus-utils-variant
16:14:48 <nshepperd> https://gitlab.haskell.org/ghc/ghc/-/wikis/unpacked-sum-types
16:15:19 <dminuoso> Gah that wiki is so awfully slow
16:15:28 * dminuoso hates gitlab with a passion
16:18:16 <erisco> aneksteind, there seem to be a few packages floating around for it
16:21:48 <koz_> nshepperd: "NOTE (osa): This part is not yet implemented, but the patch is trivial and I'm going to submit it soon)"
16:21:50 * koz_ laughs.
16:27:50 <aneksteind> found this as well for those curious: https://github.com/i-am-tom/learn-me-a-haskell/blob/master/src/OneOf.hs
16:27:56 <Uniaika> koz_: hahaha
16:29:14 <nshepperd> ah yes, the mythical trivial patch
16:29:32 <Uniaika> nshepperd: that is arriving as soon as you have time
16:29:37 <Uniaika> we've all done that
17:43:03 <MarcelineVQ> hey you
17:43:08 <MarcelineVQ> good job today
17:43:22 <MarcelineVQ> it was a tough day but you got through it
17:47:43 * hackage polysemy-resume 0.1.0.1 - Polysemy error tracking  https://hackage.haskell.org/package/polysemy-resume-0.1.0.1 (tek)
18:04:09 <iqubic> jle`: It seems that your advent-of-code-api library has broken. I'm trying to compile it with Cabal and GHC 8.10.2 and I'm getting this error: https://dpaste.com/A64ZXSQZS
18:05:41 <MarcelineVQ> jle`: you monster
18:05:52 <iqubic> What's the issue now?
18:07:43 <Ariakenom> MarcelineVQ: hey
18:07:48 <Ariakenom> you even encouraged others
18:08:05 <Ariakenom> you wrecked today!
18:12:39 <iqubic> From what I can tell, some package updated, and now jle` has a broken package
18:18:24 <ezzieyguywuf> can you all recommend any packages for handling configuration files?
18:18:31 <ezzieyguywuf> or you you typically just roll your own?
18:19:19 <ezzieyguywuf> s/you you/do you /
18:26:44 <koz_> ezzieyguywuf: Depends on format.
18:27:41 <dsal> ezzieyguywuf: It's not a recommendation, but I typically just write the thing I want to express into a file, then I write a parser for that thing that made sense to me.
18:27:48 <dsal> I used dhall once.
18:29:00 <ezzieyguywuf> dsal: I was thinking of something along those lines honestly
18:31:12 <ezzieyguywuf> koz_: I don't have a set format. mostly just "git yur data into my code"
18:31:40 <koz_> ezzieyguywuf: Then just pick one. There's a few conf-like thingoes floating around, or you can use like, YAML, or TOML, or JSON, or w/e.
18:32:10 <koz_> (why do all these formats have four-letter acronyms rofl)
18:33:12 <ezzieyguywuf> I've heard of yaml and json
18:33:56 <hololeap> i've seen toml around in my system config files
18:34:49 <ezzieyguywuf> maybe i'll try that
18:34:54 <ezzieyguywuf> thanks for the tips y'all
18:35:05 <koz_> I think there's a Haskell package for TOML parsing?
18:35:07 * koz_ shruggoes.
18:35:17 <koz_> Dhall is an option, but a pretty nuclear one.
18:35:40 <koz_> (it's a heavy dep, and I'm _still_ not 100% clear on what it does or doesn't do because it keeps moving around and the docs are lacking)
18:36:32 <ezzieyguywuf> koz_: I like to avoid heavy deps, haven't learned lens yet for that reason
18:36:51 <koz_> Hmm.
18:37:06 <koz_> Someone (I think it was glguy?) wrote something for parsing a conf-like format, but I forget.
18:37:11 <koz_> It was pretty lightweight IIRC.
18:37:34 <nshepperd> you can use a plain old ini file
18:37:38 <ezzieyguywuf> I see some configparser-clones
18:37:42 <ezzieyguywuf> but toml sounds nice.
18:37:44 <glguy> Yeah, "config-value" has minimal dependencies
18:38:03 <koz_> That was the one.
18:38:35 <glguy> "config-schema" has a couple more but it's still pretty light. (It's a helper for making it easy to process configurations)
18:39:26 <glguy> There's a live demo https://glguy.net/config-demo/
18:40:21 <ezzieyguywuf> 4 dependencies, nice. https://hackage.haskell.org/package/toml-parser-0.1.0.0
18:40:34 <ezzieyguywuf> lol, one of which is base.
18:40:43 <koz_> ezzieyguywuf: Those are all boot packages.
18:40:46 <koz_> So it's actually 0. :P
18:41:02 <ezzieyguywuf> but also v 0.1.0.0
18:41:04 <ezzieyguywuf> so *shrug*
18:41:25 <koz_> glguy: config-schema is great and so are you.
18:41:32 <ezzieyguywuf> hey it's his!
18:41:41 <ezzieyguywuf> glguy made it (the toml parser I linked)
18:42:19 <ezzieyguywuf> glguy: isyour toml parser good to go? repo looks stale and the version number suggests to me perhaps its incomplete?
18:42:24 <glguy> I need to fix a bug in that toml parser that was pointed out here
18:42:51 <koz_> ezzieyguywuf: Sub 1.0 version numbers mean basically nothing.
18:42:56 <ezzieyguywuf> glguy: is it one of the two issues listed on github?
18:42:58 <glguy> I don't use it for anything, I prefer the config-value stuff I made for my own work
18:43:06 <koz_> (vector is sub-1.0 for example, and I doubt anyone would seriously suggest it's somehow incomplete)
18:45:04 <glguy> Sub-1 doesn't mean anything special in pvp
18:45:31 <iqubic> So jle`'s Advent Of Code API library is not compiling for me. I'm getting this error: https://dpaste.com/A64ZXSQZS
18:45:41 <iqubic> Anyone know what's going on there?
18:46:13 * hackage tweet-hs 1.0.2.2 - Command-line tool for twitter  https://hackage.haskell.org/package/tweet-hs-1.0.2.2 (vmchale)
18:48:19 <hololeap> can you run megaparsec "in reverse"? i'd like to grab the extentions of some files, and some have two-part extensions. if it parsed the string in reverse, it could save me a headache.
18:49:06 <koz_> hololeap: Two-part meaning something like .tar.gz?
18:49:38 <hololeap> koz_: correct, and some of the filename bodies have '.' in them, so System.Posix.Files is getting a little confused
18:49:59 <hololeap> rather, System.FilePath.Posix
18:51:28 <ezzieyguywuf> or reeverse the string is try to parse gz.rat.
18:51:37 <koz_> zg.rat :P
18:51:45 <ezzieyguywuf> lol yea
18:51:47 <hololeap> i know i could do someting like `parse (string (reverse ".tar.gz") <|> string (reverse ".log")) f (reverse s)`
18:51:50 <koz_> And you'd have to re-reverse (verse?) it again.
18:52:03 <ezzieyguywuf> lol, verse.
18:53:21 <ezzieyguywuf> the config-value stuff looks really neat, per the live demo.
18:53:26 <ezzieyguywuf> but also seems like a lot of work, lol.
18:53:43 <koz_> ezzieyguywuf: In what sense? To use, or to implement?
18:54:57 <ezzieyguywuf> use.
18:55:10 <ezzieyguywuf> i.e. b/c of the schema thingy.
18:55:20 <ezzieyguywuf> i mean, once you learn it it's probs not that hard
18:55:38 <koz_> ezzieyguywuf: You don't have to use config-schema though?
18:55:57 <ezzieyguywuf> koz_: oh forrill? maybe I misunderstood tho point of the live demo then
18:56:43 <koz_> ezzieyguywuf: http://hackage.haskell.org/package/config-value-0.8/docs/Config.html#v:parse
18:57:21 <koz_> config-schema makes it more user-friendly and safe, but you can use just that to get 'whatever the hell', and take it apart by hand if you so wish.
18:58:26 <ezzieyguywuf> hrm, I'll take a deeper look.
19:01:34 <ezzieyguywuf> blahh, but config-schema makes it user-friendly and safe, why would I avoid.
19:01:47 <ezzieyguywuf> lol, ok I'll spend moar than 2 seconds on this
19:01:56 <ezzieyguywuf> I am, after all, on my adhd meds
19:08:00 <glguy> ezzieyguywuf, just ping me if you have questions about how to use either
19:08:42 <glguy> If you end up using the config-schema stuff I have examples in https://hackage.haskell.org/package/config-schema-1.2.1.0/docs/Config-Schema-Spec.html
19:09:40 <ezzieyguywuf> glguy: thanks I appreciate the offer.
19:14:13 <ezzieyguywuf> glguy: what file extension do you use for conf files? lol.
19:14:21 <glguy> .cfg :)
19:14:26 <ezzieyguywuf> nice.
19:14:55 <glguy> I have vim syntax highlighting, but that's about it
19:16:18 <ezzieyguywuf> glguy: yea I saw that, that's what had me wondering about file extension
19:16:30 <glguy> I put this at the bottom so vim picks it up -- vim: filetype=config-value
19:17:27 * justsomeguy has a random thought -- syntax highlighting emphasizes the wrong things: keywords and punctuation rather than names.
19:18:14 <glguy> That probably doesn't apply to a configuration language
19:18:26 <ezzieyguywuf> justanotheruser: I've been using nofrils colorscheme in vim for a few months now, pretty happy
19:18:50 <ezzieyguywuf> glguy: vim recognises that at the bottom of the file?! I didn't know vim could do that...
19:19:50 <glguy> https://ibb.co/26yfm2y example from my IRC client configuration
19:20:27 <glguy> highlighting helps notice escapes in string literals, distinguish strings from atoms, etc
19:21:30 <ezzieyguywuf> altought I modified it to highlight strings https://i.imgur.com/yaAppbE.png
19:21:54 <iqubic> I wish I knew why this fails to build with GHC 8.10.2 https://hackage.haskell.org/package/advent-of-code-api
19:22:20 <glguy> iqubic, that packages doesn't list any package bounds; it's intended to decay and fail to build
19:22:33 <iqubic> Really?
19:22:56 <iqubic> So, will I just have to wait for jle` to come around and fix it?
19:23:24 <glguy> or guess at the bounds and submit a PR
19:23:34 <iqubic> Hmm, that sounds difficult.
19:25:29 <iqubic> I was planning on using this to download my data for AOC, as I did last year, but that doesn't look like it will work.
19:26:28 <iqubic> AOC = Advent of Code. I'm planning on making a toolkit of functions for use this year, and I wanted this to be part of it, like it was last year.
19:29:17 <iqubic> Now, seeing as that might not be working this year, I'm going to ask a different question: what does readFile return? I know it's an IO String, but does that string contain a trailing new line or not?
19:31:40 <iqubic> jle`: Do you have any plans on updating you AoC-API that's on Hackage anytime soon?
19:31:58 <iqubic> glguy: Are you going to be creating a haskell leaderboard this year?
19:33:55 <glguy> It's the same one every year
19:34:20 <glguy> 43100-84040706
19:34:33 <iqubic> Do I need to do anything special to join it for this year, if I was on the leaderboard last year?
19:34:39 <glguy> nuh uh
19:34:54 <glguy> You're still there
19:35:05 <iqubic> Oh, you can just see that?
19:35:31 <iqubic> s/that/me/
19:40:17 <kupi> is it a good decision to write this function? if' :: a -> a -> Bool -> a
19:40:36 <glguy> :t Data.Bool.bool
19:40:37 <lambdabot> a -> a -> Bool -> a
19:40:49 <kupi> thanks
19:40:55 <glguy> kupi, 1) it's already defined 2) it generally leads to less-readable code
19:41:36 <kupi> what else you recommend when I >>= a Monad Bool?
19:43:30 <glguy> except in perhaps the most trivial cases: do usefulName <- something; if usefulName then this else that
19:47:53 <solonarv> if you don't want to name the thing you can turn on LambdaCase and write: something >>= \case True -> this; False -> that
19:48:51 <kupi> or something >>= \case True -> this; _ -> that
19:54:19 <kupi> but I prefer >>= bool this that
20:10:14 <ezzieyguywuf> glguy: so I hvaen't gotten to config-schema yet, but I made a basic config file, and parsed it succesfully. but I'm at a bit of a loss as to what to do next. This `Value Position` data I have seems very handy, but how do I interogate it? i.e. "give my the list in section 2"
20:11:20 <glguy> You either write functions to take apart the Value type and find what you wnt
20:11:26 <glguy> or you use the ones I provide for you in config-schema
20:11:42 <ezzieyguywuf> ah hah! config-schema rears its head!
20:11:43 <ezzieyguywuf> thanks
20:13:26 <glguy> ezzieyguywuf, but on its own you interrogate with pattern matching
20:14:27 <glguy> There are some helpers defined for if you're using lens: https://hackage.haskell.org/package/config-value-0.8/docs/Config-Lens.html
20:14:51 <ezzieyguywuf> glguy: I don't really gr0k lens at the moment
20:14:58 <glguy> Well, then ignore that
20:20:00 <koz_> ezzieyguywuf: Pattern matching in general gets you surprisingly far with everything.
20:26:32 <glguy> Prelude Config.Schema Config Data.Functor.Alt> let spec :: ValueSpec [Int]; spec = listSpec (0 <$ atomSpec "default" <!> numSpec) in case parse "[1,default,4]" of Right v -> print (loadValue spec v) >> print (generateDocs spec)
20:26:32 <glguy> Right [1,0,4]
20:26:33 <glguy> Top-level configuration file format:
20:26:33 <glguy>     list of (`default` or integral number)
20:33:23 <ezzieyguywuf> the schema stuff seems to pretty much document itself, after reading the examples
20:34:09 <glguy> If you'll tell me anything that seems poorly explained I'd use that to improve the explanations
20:35:24 <ezzieyguywuf> glguy: I'll let you know
20:36:14 <MarcelineVQ> glguy: hey, good job. you're a great guy, doing all your helpfuol stiff all the time
20:36:40 <glguy> That's nice of you to say, MarcelineVQ.
20:36:55 <MarcelineVQ> you're worth it
20:38:36 <koz_> MarcelineVQ, the L'Oreal rep. :P
20:46:12 <MarcelineVQ> l' gariet  frucitis o la config
20:46:34 <MarcelineVQ> zhuehuee'
20:48:00 <koz_> I think MarcelineVQ is malfunctioning.
20:48:50 <MarcelineVQ> wwww
21:11:51 <xpika> does anyone know a library that handles creations of Lists of Lists that makes it easy to apply breakpoints?
21:12:05 <xpika> > let single = (\y ys -> (\(x:xs)->(y:x):xs) ys) ; break = [("":)] in foldr ($) [""] (map single "hello"++break++map single "world")
21:12:07 <lambdabot>  ["hello","world"]
21:13:51 <xpika> perhaps could be used with the writer monad eg. tall (single 1) ; tell break
21:15:43 * hackage store 0.7.8 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.8 (MichaelSloan)
21:16:03 <koz_> xpika: What do you mean by 'breakpoints' here?
21:16:43 * hackage store-core 0.4.4.4 - Fast and lightweight binary serialization  https://hackage.haskell.org/package/store-core-0.4.4.4 (MichaelSloan)
21:16:44 <xpika> koz_: the boundaries between lists
21:17:57 <xpika> koz_: I don't mean debug breakpoints if that's what you were thinking
21:18:06 <koz_> xpika: Yeah, I was a bit confused there.
21:19:20 <xpika> char 'a'  ; char 'b' ; break ; char '1' ; break ; char '4'
21:19:20 <xpika> => ["ab","1",4"]
21:20:15 <koz_> Are you dealing with general lists? Or are you really dealing with lists of strings? Do you care that it's expressly _lists_?
21:20:38 <xpika> anything that I can convert to a list would be fine
21:23:29 <koz_> Assuming the 'lists of strings' case, you could work with some wrapper around Seq Builder, then write some ops around that?
21:23:45 <koz_> If it's general stuff, Seq (Seq a) maybe?
21:25:27 <xpika> Yeah I could roll my own. But I'm interested if others made a library to do what seems very basic.
21:25:55 <koz_> It's a pretty niche thing honestly.
21:26:02 <koz_> I've yet to ever see need for such a thing.
21:53:26 <xpika> > let single = (\y ys -> (\(x:xs)->(y:x):xs) ys) ; break = ([]:) in foldr ($) [[]] (concatMap (\x -> if odd x then [single x ,break] else [single x]) [1..10])
21:53:29 <lambdabot>  [[1],[2,3],[4,5],[6,7],[8,9],[10]]
21:54:43 * hackage th-utilities 0.2.4.1 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.2.4.1 (MichaelSloan)
21:56:13 * hackage calamity 0.1.22.1 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.22.1 (nitros12)
22:01:04 <xpika> > let single = (\y ys -> (\(x:xs)->(y:x):xs) ys) ; break = (\xs -> if head xs /= [] then []:xs else xs) in foldr ($) [[]] (concatMap (\x -> if rem x 5 == 0 || rem x 3 == 0 then [break,single "fizzOrbuzz",break ] else [single (show x)]) [1..16])
22:01:08 <lambdabot>  [["1","2"],["fizzOrbuzz"],["4"],["fizzOrbuzz"],["fizzOrbuzz"],["7","8"],["fi...
22:05:39 <jle`> iqubic: it works for ghc 8.8 :)
22:05:50 <jle`> but you're welcome to submit a pr too :)
22:06:03 <iqubic> I'm not going to do that.
22:06:09 <iqubic> I know what I'll be doing.
22:08:17 <iqubic> I'll just downgrade to 8.8. Is there any easy way to get cabal to do that?
22:08:39 <jle`> hm, i looked at the error and it seems like it's more likely a servant version mismatch
22:08:48 <jle`> iqubic: yeah, cabal just uses whatever GHC is in your PATH
22:08:59 <iqubic> Cool. That's what I like to hear.
22:09:00 <jle`> so if you have GHC 8.8 in your path then it'll use that atuomatically
22:09:07 <glguy> You'd do: cabal configure -w ghc-8.8
22:09:07 <jle`> but it looks like the problem is probably a servant update that broke it
22:09:30 <iqubic> Now I just have to tell Nix to use GHC 8.8 instead of 8.10.2. That's not too big a deal.
22:10:15 <jle`> looks like it's using servant 0.16
22:10:28 <jle`> so if you use servant 0.16.x with ghc 8.10 it should be ok too
22:10:58 <jle`> i wonder what changed
22:11:44 <iqubic> Oh, it should? Is there a way to get a particular Servant version?
22:11:59 <siraben> What should I use to derive Arbitrary instances?
22:12:09 <siraben> I have a tree and want to generate arbitrary trees for use in QuickCheck
22:12:09 <jle`> iqubic: you can specify in your cabal file or package.yaml
22:12:37 <iqubic> I'm not sure how to do that? Can you tell me what I should add to my .cabal file?
22:14:48 <jle`> 'servant ==0.16.2' where you are listing your servant dependency, i think
22:14:48 <xpika> ok question: A HTML table (without rowspans) has an equal number of fields per row. Would a list of fixed length Vectors be a good option for constructing a table like this safely?
22:15:23 <jle`> xpika: it depends on what sort of operations you'd want to do, i think. but yeah, having something like [Vector n a] would keep each row the same length
22:15:50 <iqubic> jle`: I'm not listing a servant dependency, I'm letting Cabal get that for me.
22:16:29 <jle`> ah hm. you can add that in as a dep then. but also i guess i should have made stricter upper bounds for the library D:
22:17:01 <iqubic> Are you going to update the library, or not?
22:18:11 <iqubic> Also, will your OCR library be broken too, or not.
22:18:15 <iqubic> ?
22:19:26 <ambidextrose> keep rockin' that single-quote, iqubic
22:19:39 <koz_> siraben: You can just write the instance by hand, surely?
22:19:41 <iqubic> What single quote?
22:19:57 <siraben> koz_: `arbitrary = oneof [pure Leaf, Node <$> arbitrary <*> arbitrary <*> arbitrary]`
22:19:58 <siraben> yeah
22:20:07 <koz_> siraben: That's gonna have issues.
22:20:13 <jle`> the ocr library doesn't use servant, so i think it should be fine. but i haven't tested all the bounds for all the deps
22:20:14 <koz_> Mostly because it'll possibly loop forever.
22:20:19 <siraben> koz_:  why?
22:20:24 <siraben> data Tree = Node Int Tree Tree | Leaf deriving Show
22:20:36 <koz_> Because a possible path through that Arbitrary instance is 'Node for all eternity'.
22:20:38 <koz_> So it'll never stop.
22:21:00 <koz_> So you need to bound its depth, probably by using resize.
22:21:09 <koz_> (`div` 2) is a good way to do that.
22:21:26 <koz_> Every time you make a recursive call to 'arbitrary', ensure you wrap it in 'resize'.
22:21:59 <koz_> And also check for the size (by using getSize) before you recurse - if you're at 0 or lower, ensure you get a Leaf.
22:25:06 <siraben> koz_: ok
22:27:32 <siraben> koz_:  s <- getSize then
22:27:34 <siraben> `if s <= 0 then pure Leaf else Node <$> arbitrary <*> resize (s `div` 2) arbitrary <*> resize (s `div` 2) arbitrary`
22:27:36 <siraben> Right?
22:28:04 <koz_> Almost.
22:28:27 <koz_> In the 'else' arm, you want to use oneOf to pick between Leaf and Node.
22:28:37 <koz_> Otherwise you end up with a tree that's perfectly balanced every time.
22:29:04 <siraben> koz_: Ah, I see.
22:29:19 <siraben> How do I force shrinking of the tests to make the smallest counterexample?
22:29:57 <koz_> Did you define 'shrink'?
22:30:08 <koz_> If you didn't define the shrink method, nothing gets shrunk.
22:30:27 <siraben> Ah
22:30:43 <siraben> How do I define shrink?
22:31:00 <siraben> Oh it's in the arbitrary class
22:31:05 <koz_> Leaf is not shrinkable.
22:31:16 <koz_> Node shrinks to its subtrees.
22:32:06 <siraben> Nice, works great.
22:32:10 <siraben> `shrink Leaf = []; shrink (Node x l r) = [Leaf] ++ [l, r] ++ [Node x' l' r' | (x', l', r') <- shrink (x, l, r)]`
22:32:24 <koz_> Nah, you don't want to shrink Node to Leaf like that.
22:32:30 <koz_> It's not a shrink - you're inventing data.
22:32:46 <koz_> shrink (Node _ l r) = [l, r] is fine.
22:33:03 <siraben> Interesting, the QuickCheck docs uses this tree example
22:33:32 <iqubic> jle`: Are you going to update the AoC-API to have strict bounds, or should I just make the required modifications on my end?
22:33:33 <siraben> Hm, using that for shrink seems to produce worse results
22:33:43 <koz_> siraben: In what sense?
22:33:58 <siraben> koz_: longer counterexamples after quickCheck
22:34:03 <koz_> Hmm.
22:34:11 <koz_> Well, in that case, use your original.
22:34:18 <koz_> I guess it's a more aggressive search
22:34:31 <siraben> taking away [Leaf] ++ doesn't seem to make a difference though
22:34:54 <koz_> I always thought 'shrink' was meant to be a reduction, rather than a search.
22:35:01 <koz_> But I guess a search _would_ produce better results.
22:35:26 <siraben> I wish I could pretty print trees...
22:36:06 <koz_> siraben: Like, define a prettyprinter, pass that into (a variant of) forAll?
22:36:11 <siraben> Ah there's already Data.Trees, d'oh
22:36:15 <koz_> (there's one letting you specify the string conversion)
22:41:15 <jle`> iqubic: i might be updating it to make it work with 0.18, it seems like i was just doing a small thing unsafe before
22:41:38 <iqubic> Ah. I see. It's fine if you don't update it.
22:53:44 * hackage advent-of-code-api 0.2.7.1 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.7.1 (jle)
23:07:28 <iqubic> Oh, you just updated it.
23:07:49 <iqubic> jle`: Does this now work with 8.10.2?
23:21:15 <iqubic> Actually, that the wrong question. The question should be: does this now work with the latest servant API, to which the answer is "Yes"
23:23:42 <jle`> hooray :D
23:31:20 <iqubic> I don't actually know if it works. I haven't tested it. I'm just going by what your commit messages say. I trust you to have tested the thing before releasing it.
