00:07:38 <dminuoso> To revisit the earlier discussion. Im not completely sold on the idea that regular expressions are bad. In a lot of situations they are much faster to write, than to either manually parse down String or use parser combinators. Especially for one-off tools that need to be quickly written, they are very handy.
00:07:56 <dminuoso> They are probably *overused*, but I think they have their place in code.
00:17:00 <scasc> yushyin: Thanks, I remembered having seen base versions tabulated somewhere.
00:17:20 <scasc> That could be augmented with release dates for the GHC versions :-)
00:22:24 <[exa]> dminuoso: they are great for user-specified grammar parts where you don't want a full compiler in your program
00:24:21 <[exa]> dminuoso: like, I'd really love a library now with a more transparent interface than regex-base
00:24:41 <dminuoso> [exa]: pcre-heavy has a good interface
00:25:07 <[exa]> will have a look, thanks
00:25:43 <[exa]> the point is that regex-base somehow seems to mainly support the mode of use that sounds wrong to me (eg writing a regex to your program to check a mail)
00:27:14 <[exa]> ok pcre-heavy and pcre-light are cool
00:27:27 <[exa]> is there something similar without external deps? I'm now on regex-tdfa
00:29:56 <dminuoso> [exa]: Mmm, regex-applicative perhaps
00:30:03 <dminuoso> (Which is also a library Im quite fond of)
00:30:23 <[exa]> ok sounds good
00:30:27 <dminuoso> It's a cross between parser combinators and regular expressions, but it gets away with pure haskell instead of QQs
00:30:37 <[exa]> looks good
00:31:34 <[exa]> palpatine voice: goooooood
00:31:38 <lortabac> my personal problem with common regex implementations is the stringy syntax
00:31:44 <fraktor> I've got a question that's kind of a general algorithms question, but I'm planning on attempting to implement it in Haskell. Is here a good place to ask?
00:31:54 <lortabac> I wasn't aware of regex-applicative, it looks good
00:32:02 <[exa]> fraktor: quite possibly yes, you'll get a decent redirect if not :]
00:32:10 <fraktor> Fair enough.
00:32:50 <[exa]> ok that sounds like it.. like, regex strings and QQs have imho no place in good code when you can write it right (and more extensibly) using standard haskell
00:33:09 <fraktor> I've got a problem that is kind of like 1d bin packing, but different. Basically, I have several objects, and bins of several sizes. I can have as many of each kind of bin as I want, but I need to minimize the total amount of space left over in each bin.
00:34:58 <[exa]> fraktor: the objects have 1D size?
00:35:05 <fraktor> For the purpose of this problem yes.
00:35:54 <fraktor> Actually I'll just share the practical application of this: I need to cut several lengths of 2x4, and I can buy boards in pre-determined lengths. I want to minimize waste.
00:35:55 <[exa]> so the input is say objectSizes=[1,2,3,4,10] and you have binSizes=[8,11] and try to minimize the amount of space in used bins that is unfilled, right?
00:36:10 <fraktor> Exactly. But there may be multiple objects of the same size.
00:36:45 <[exa]> this sounds like a knapsack but hopefully it's not that bad. :]
00:37:05 <lortabac> fraktor: do you also want to minimize the number of bins you use? (by putting more than 1 object in a bin)
00:38:48 <[exa]> imho not necessariy (unless shorter boards are proportionally more expensive than longer boards)
00:39:09 <fraktor> All other things being equal, yeah, but I'd rather reduce waste than have fewer boards.
00:39:24 <fraktor> And it's certainly not critical.
00:40:16 <lortabac> if you can afford 1 object for each bin, I'd say you don't need any algorithm at all, you just choose the first bin your object fits in
00:41:55 <fraktor> What if I have objects [1, 2, 2], and I have bins [1, 3]? Then I would end up with [([1], 1), ([2], 3), ([2], 3)], even though [([1, 2], 3), ([2], 3)] is a more efficient packing.
00:42:13 <fraktor> The first packing has 2 units of waste, while the second packing only has 1.
00:42:54 <lortabac> ok I understand now
00:43:19 <[exa]> lortabac: that would generate a lot of waste
00:43:48 <[exa]> fraktor: how many objects/bins do you expect?
00:44:06 <fraktor> Bins, let's say 4, and objects, I'd say about 20.
00:44:21 <fraktor> But I'd like something that scales efficiently if at all possible.
00:44:39 <[exa]> well for now just enjoy the computers and go brute force :D
00:45:09 <lortabac> :)
00:45:43 <fraktor> That's still relatively large, as far as I can tell. Like, I would have to check every ordering of the objects, and then every possible grouping for that ordering, right?
00:47:44 <[exa]> I'm starting to suspect there'd be a dynamic programming solution
00:48:13 <lortabac> you can probably reframe the problem to be solvable with linear programming, by giving a sufficiently big (finite) number of bins
00:48:56 <fraktor> I mean, the largest number of bins would be the number of objects, so I have a hard upper bound. But I'm not that familiar with linear programming.
00:49:12 <[exa]> that's going to just transfer the guesswork to the linear solver :]
00:49:15 <fraktor> And this definitely does seem like the kind of thing that would have a dynamic programming solution, but I'm not sure I could figure it out when I'm this tired lol.
00:50:23 <[exa]> ok technically, lets give it a bit of determinism
00:51:35 <[exa]> 1] it doesn't matter in which order you choose the boards and cut out the parts you want, so you can work the algorithm as iterative nondeterministic "I cut out a first piece and might have either this board left, or that board left"
00:52:23 <fraktor> Are you saying that cutting [2, 1] out of a board is functionally equivalent to cutting out [1, 2]? I'd agree.
00:52:53 <[exa]> then heuristic, 2] cut out the pieces that are most unwieldy first
00:53:06 <[exa]> so that you don't have to generate a lots of waste towards the end of the search
00:53:18 <[exa]> 3] branch bound and hope
00:55:26 <fraktor> I'm trying to think if there are any situations in which doing a grouping of 3 in one board and 1 in another is more wasteful than doing 2 and 2.
00:55:32 <[exa]> anyway this reduces to subset sum, for items of total size W and subset of size S you give it boards of size S and (W-S) and it will either solve the subset or prove that it's easier by subdividing S into pieces
00:56:09 <[exa]> (modulo corner cases)
00:56:28 <tomsmeding> total waste = sum_{b in used boards} length(b) - sum_{o in objects} length(o)
00:56:41 <tomsmeding> so minimal waste <=> minimal total length of boards chosen
00:57:44 <fraktor> tomsmeding: I don't think so. At least not in all cases.
00:58:06 <fraktor> Because I'm not saying "I have chosen these boards, fit these cuts into them." I'm trying to choose which boards to get in the first place.
00:58:25 <tomsmeding> "minimal total length of boards chosen"
00:58:54 <fraktor> Oh! I misread. I thought it was "minimal number of boards chosen." In that case, you're correct.
00:59:21 <tomsmeding> not sure if this observation helps in any way though :p
00:59:45 <fraktor> It's either completely useless or the key to cracking the puzzle
00:59:50 <fraktor> Not sure which
01:00:20 <tomsmeding> it's fairly easy to formulate as an ILP problem
01:00:49 * ski . o O ( "Inductive Logic Programming" ? )
01:00:55 <tomsmeding> integer linear programming :')
01:00:59 <tomsmeding> yay acronyms
01:01:03 <ski> ah
01:01:19 <fraktor> Oh wow, that's hard though
01:01:34 <tomsmeding> ILP problems are NP-complete in general so this proves nothing
01:01:42 <ski> (why's it called "Linear Programming", btw ?)
01:01:53 <tomsmeding> but ILP solvers are notoriously good at solving hard problems faster than expected
01:02:05 <tomsmeding> ski: ILP = LP + branch-and-bound, where LP = linear programming
01:02:32 <tomsmeding> the standard algorithm is solving the problem without the restriction that all variables need to be integral, and then doing branch-and-bound to find a valid ILP solution
01:02:34 <fraktor> I think it's called LP because the underlying systems have linear relationships to each other?
01:02:52 <tomsmeding> (that first step is just solving an LP problem)
01:03:31 <tomsmeding> I'm struggling to understand [exa]'s reduction though; have you just proven that this problem is at least as hard as subset sum?
01:03:43 <[exa]> ski: because it's so np-hard that you can encode programs into that :D
01:04:07 <tomsmeding> oh _that_ was the question, yeah the name is atrocious
01:04:35 <fraktor> tomsmeding: I've never used a linear programming library before, would you be willing to help me encode this into it?
01:04:40 <tomsmeding> [exa]: because if you've proven that, expressing this as an ILP might be fairly optimal :p
01:04:45 <tomsmeding> fraktor: sure
01:04:49 <[exa]> tomsmeding: given some careful choice of board lengths I guess you can solve a good number of subset sum cases with that
01:05:02 <tomsmeding> all, or a good number?
01:05:12 <ski> fraktor : doesn't explain the "programming" part, though
01:05:26 <ski> [exa] : isn't that just for the integer variety ?
01:05:36 <[exa]> tomsmeding: what I wanted to point out, it's better to have a heuristic search written in 10 minutes than pulling in the ILP solver and hoping it's going to reinvent the heuristic
01:05:43 <lortabac> ski: "programming" is not meant as computer programming, but more like "planning"
01:06:06 <tomsmeding> except if you're sadistic and want an exactly optimal solution :p
01:06:31 <fraktor> If nothing else I'll learn how to use an ILP solver.
01:07:05 <tomsmeding> (I have to dig how it worked again too, give me a minute :p
01:07:06 <tomsmeding> )
01:07:58 * ski . o O ( "Why ‚Äúdynamic programming‚Äù?" by Arcane Sentiment in 2010-04-23 <http://arcanesentiment.blogspot.com/2010/04/why-dynamic-programming.html> )
01:10:47 <tomsmeding> fraktor: so the idea of an LP problem (let's start with that) is the following
01:11:00 <tomsmeding> you define a number of real-valued variables, x1,...,xn
01:11:13 <tomsmeding> and 1. give an optimisation function, which is a linear combination of those variables
01:11:31 <tomsmeding> and 2. a list of linear constraints, which are of the form (linear combination of the variables) <= (real constant)
01:11:53 <tomsmeding> then the LP solver gives you an assignment of the variables such that the target function is minimised
01:11:59 <tomsmeding> (s/optimisation function/target function/)
01:12:15 <tomsmeding> ILP solvers can additionally handle the restriction that certain variables may only be integer-valued
01:12:50 <fraktor> I'm really sorry, but something came up and I gotta go
01:12:57 <tomsmeding> np :)
01:13:02 <fraktor> I'll definitely look into this though, thank you
01:13:25 * tomsmeding might still code this up for reason of procrastination
01:13:31 <[exa]> sounds like fedex delivered the boards!
01:13:44 <tomsmeding> :D
01:14:34 <__monty__> s/np/np-hard/ FTFY
01:14:52 <[exa]> anyway the sum problems are cool from the hardness perspective
01:15:15 <[exa]> https://en.wikipedia.org/wiki/3SUM <- most illustrative one I know of
01:16:11 <tomsmeding> ah the log bounds, O(n^2 / (log n / log log n)^(2/3)) lovely <3
01:17:14 <ski> this is an instance of CP (Constraint Programming) (of which CLP, Constraint Logic Programming, is a more nicely integrated form)
01:25:46 <raichoo> Hi everyone, we have rebooted Advent of Haskell 2020 and are currently collecting potential blog articles. www.adventofhaskell.com
01:26:27 <Axman6> hooray!
01:26:49 <Axman6> also I feel like that's a nick I haven't aseen for a very long time...
01:27:32 <raichoo> I've been MIA from twitter for kind of a long time and I'm not posting that much in here :D
01:27:42 <raichoo> But glad someone remembers me nevertheless ^^
01:29:37 <Axman6> hmm, I could possibly make soething for this too
01:29:48 <Axman6> something too. mauybe IRC + pub is a bad idea
01:31:53 <raichoo> Axman6: That would be cool :) Just drop me a mail, all the submissions to advent@antei.de go straight to me.
01:32:20 <merijn> raichoo: Did you mail the Haskell Weekly News guy yet?
01:33:58 <raichoo> merijn: Just blasted things out on social media. We just pushed the website online yesterday. Could you drop me the contact in a DM?
01:34:25 <merijn> raichoo: Contact info is here: https://haskellweekly.news/
01:34:47 <merijn> I think it usually goes out on friday, so if you're fast it could still be added :)
01:35:16 <raichoo> Whoop whoop, thanks for the pointer, will do that right now :D
01:42:23 * hackage wai-extra 3.1.2 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.1.2 (MichaelSnoyman)
02:32:20 <tomsmeding> @tell fraktor https://tomsmeding.com/ss/get/tomsmeding/V5dE2W
02:32:20 <lambdabot> Consider it noted.
02:37:06 <[exa]> tomsmeding: all go to board 1?
02:37:11 <[exa]> (oh okay thats board type 1)
02:37:31 <tomsmeding> zero-based indices :p
02:37:32 <tomsmeding> but yes
02:38:15 <[exa]> what's the ILP library btw?
02:38:27 <tomsmeding> I'm using an external process, https://sourceforge.net/projects/lpsolve/
02:38:33 <tomsmeding> will put the code in a paste in a minute
02:38:39 <[exa]> o good
02:49:06 <tomsmeding> @tell fraktor https://paste.tomsmeding.com/rT6TJbdr (also [exa])
02:49:06 <lambdabot> Consider it noted.
02:49:39 <tomsmeding> lol I realise now that the output for a constant linear combination is borked but it works
02:49:49 <tomsmeding> "<=  + 1"
02:50:02 <tomsmeding> it works thus it's fine
02:50:26 * tomsmeding wonders whether to amend the paste directly in the database
03:01:52 * hackage cut-the-crap 2.3.1 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-2.3.1 (Jappie)
03:12:59 <SirSaul> Hello people, can someone help me with a problem regarding indentation or something like that.
03:13:27 <yushyin> sure, ask away
03:13:59 <SirSaul> I'm quite new to functional programming and following a tutorial on Xwindow https://wiki.haskell.org/X_window_programming_in_Haskell
03:14:21 <SirSaul> Things were fine at first, but the latter pieces of code didn't work, even when I copied them 1:1
03:14:57 <SirSaul> main.hs:15:6: error:    parse error on input ‚Äò=‚Äô    Perhaps you need a 'let' in a 'do' block?
03:15:09 <SirSaul> I assume it's something wrong with the way it's written
03:15:50 <SirSaul> I have all the dependecies btw, the first pieces of code worked fine.
03:16:03 <tomjaguarpaw> Perhaps paste your code on https://paste.tomsmeding.com/
03:16:04 <yushyin> SirSaul: can you paste your code? https://paste.tomsmeding.com/
03:16:27 <SirSaul> The code is in the tutorial link from the haskell website
03:17:10 <tomjaguarpaw> Yes, but it's likely something in the indentation has gone wrong when you have posted that code into your editor
03:17:25 <SirSaul> I see
03:17:27 <SirSaul> I will check
03:17:41 * tomsmeding expects tabs
03:17:53 <SirSaul> https://paste.tomsmeding.com/csO4jTzn
03:18:17 <yushyin> tomsmeding: ghc warns about tabs nowadays
03:18:29 <tomsmeding> SirSaul: that "scr = defaultScreenOfDisplay dpy" line in 'main' needs to be indented ;)
03:18:36 <tomsmeding> yushyin: also without -Wall?
03:18:59 <SirSaul> Alright, yea I don't really know. I work in vim so pretty basic haha
03:19:10 <SirSaul> the syntax is quite new for me.
03:19:19 <SirSaul> feels like coding 1101 again haha
03:19:27 <tomjaguarpaw> It seems that there are a lot of indentation errors, for example in mkUnmanagedWindow
03:19:50 <SirSaul> Yea it's probably because I copied it 1:1 from the web after i tried to write it by hand
03:20:16 <SirSaul> does it matter tabs or spaces? or is either good as long as it is consistent?
03:20:23 <tomsmeding> still, the spaces should've copied along
03:20:26 <tomsmeding> spaces only in haskell
03:20:31 <SirSaul> alright
03:21:08 <tomjaguarpaw> Copying and pasting Haskell code is not easy. You have to make sure you copy the spaces exactly.
03:21:40 <SirSaul> Yea, it's also hard to see properly as I'm not familiar yet.
03:22:36 <tomjaguarpaw> Oh, those indentation errors do also appear on https://wiki.haskell.org/X_window_programming_in_Haskell
03:22:42 <tomjaguarpaw> It may well be that the page is just wrong
03:22:58 <tomsmeding> oh wow
03:22:59 <tomsmeding> yes
03:23:12 <tomjaguarpaw> It hasn't really been edited since 2010 so it could be well out of date and generally unhelpful
03:23:14 <SirSaul> Yes, that why I came here
03:23:21 <SirSaul> I assumed an error on the page
03:23:29 <yushyin> tomsmeding: yes -Wtabs is on by default, even without -Wall
03:23:35 <SirSaul> Actually was trying to someone who could maybe edit the wiki
03:23:36 <tomsmeding> yushyin: üéâ
03:24:04 <tomjaguarpaw> If your goal is to learn Haskell I would recommend against the wiki. It's massively out of date.
03:24:12 <SirSaul> Yea I'm actually looking for some not to hard, not to easy apps to try and make
03:24:13 <yushyin> but it's fine to use tabs in haskell, if you really really want to, it's just easy to get wrong :D
03:24:26 <SirSaul> most haskell things I find are like things add 10 2, or hello world..
03:24:33 <SirSaul> but Im looking for something a bit more.
03:24:44 <tomjaguarpaw> Hmm, I don't know of one personally. Maybe someone else can recommend something.
03:25:20 <tomsmeding> how did that wiki even end up wrong? it's not even a formatting bug, there's really missing indentation in the page source
03:25:21 <SirSaul> I need to up my knowledge and skills before I can truly do something, but just writting add and square functions ins just plain boring
03:25:25 <SirSaul> I know how that works.
03:25:41 <tomjaguarpaw> tomsmeding: The Wiki is just generally broken 
03:26:05 <yushyin> trying to solve AOC is always a nice way to learn a new language
03:26:16 <tomsmeding> or project euler, if that's your thing
03:26:56 <SirSaul> Well, my general idea is trying to write actual OS stuff in haskell
03:27:09 <SirSaul> I've got the knowledge for that, just not for haskell at the moment haha
03:27:27 <SirSaul> so im a noob and somewhat a pro at the same time.
03:27:39 <tomjaguarpaw> (I added a warning at the top of that page)
03:28:25 <SirSaul> great for future coders :)
03:28:39 <tomjaguarpaw> SirSaul: Did you make any progress with the code on that page at all?
03:28:41 <int-e> https://wiki.haskell.org/index.php?title=X_window_programming_in_Haskell&oldid=14607 looks more correct; the next revision reformatted a lot of stuff incorrectly
03:28:58 <SirSaul> Yea' I've got the window running from the first part
03:29:15 <yushyin> I think Programming in Haskell by graham hutton is nice, if you already know about programming but not about haskell
03:29:41 <tomjaguarpaw> Then maybe int-e's suggestion is good.  You could use the code from that version.  Or you could try to fix the indentation yourself - that will be a quick but frustrating way to learn about indentation in Haskell!
03:29:46 <SirSaul> but the latter part after the unfinished window doesn't seem to work, and I'm not yet finding the correct indentation
03:30:25 <SirSaul> I will take a look at that revision int-e
03:31:02 <SirSaul> Thanks people for your quick response and help.
03:34:08 <tomjaguarpaw> Feel free to come back and ask for more help if you run into more problems
03:34:19 <tomjaguarpaw> Hope you find something that works for you!
03:35:22 * hackage servant-openapi3 2.0.1.0 - Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.  https://hackage.haskell.org/package/servant-openapi3-2.0.1.0 (maksbotan)
03:38:26 <int-e> I guess I'll just transplant the old code samples before the indentation edit of doom
03:48:14 <int-e> Oh SirSaul left.
03:49:31 <int-e> tomjaguarpaw: I dropped the allusion to numerous indentation errors, but kept the outdated warning (since I didn't test any of the code)
03:49:39 <tomjaguarpaw> Great, thanks
04:03:44 <tomsmeding> you can't pattern-match on a GADT without a type signature on the result, even if the result doesn't do anything with the existential types in the GADT?
04:05:07 <tomsmeding> ( https://paste.tomsmeding.com/h5VYeItr )
04:10:36 <dminuoso> % :set -XGADTs
04:10:37 <yahb> dminuoso: 
04:10:48 <dminuoso> % data G t where G1 :: T Int
04:10:48 <yahb> dminuoso: ; <interactive>:82:22: error: Not in scope: type constructor or class `T'
04:10:54 <dminuoso> % data G t where G1 :: G Int
04:10:54 <yahb> dminuoso: 
04:11:04 <dminuoso> % f g = case g of G1 -> True
04:11:04 <yahb> dminuoso: ; <interactive>:84:23: error:; * Couldn't match expected type `p' with actual type `Bool'; `p' is untouchable inside the constraints: t ~ Int bound by a pattern with constructor: G1 :: G Int, in a case alternative at <interactive>:84:17-18; `p' is a rigid type variable bound by; the inferred type of f :: G t -> p; at <interactive>:84:1-26; Possible fix: add a type 
04:11:33 <dminuoso> that seems strange
04:14:02 <lortabac> strangely, it compiles if you omit the argument type (with PartialTypeSignatures), but it doesn't if you omit the result
04:14:48 <lortabac> in other words the problem is not 'G t', but 'Bool'
04:16:13 <ski> % let f g = (case g of G1 -> True) :: Bool
04:16:13 <yahb> ski: 
04:17:53 * hackage th-lego 0.2.3 - Template Haskell construction utilities  https://hackage.haskell.org/package/th-lego-0.2.3 (NikitaVolkov)
04:20:58 <lortabac> TBH I find it remarkable that GHC can at least preserve *some* type inference when using rank-n types, type families, GADTs etc.
04:24:23 * hackage ukrainian-phonetics-basic 0.1.8.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.8.0 (OleksandrZhabenko)
04:24:47 <tomsmeding> yes the fact that the problem is the Bool surprised me too
04:25:13 <tomsmeding> if it was the argument, I wouldn't have had trouble in my actual code because the 'g' argument would've had an inferred type from elsewhere
04:27:15 <tomsmeding> (ah but in fact after I fixed something else the argument has an inferred type from elsewhere too, so I don't actually need a type signature. yay!)
04:27:22 <tomsmeding> s/argument/result/
04:27:31 <lortabac> 'f :: G Int -> _; f G1 = True' typechecks
04:27:43 <tomsmeding> so it's the case?
04:27:45 <lortabac> it looks like it needs at least one of the two
04:28:10 <lortabac> yes I removed the case syntax here for brevity
04:28:36 <tomsmeding> oh it works because you put 'G Int'
04:28:43 <lortabac> yes
04:30:52 * hackage morpheus-graphql-core 0.16.0 - Morpheus GraphQL Core  https://hackage.haskell.org/package/morpheus-graphql-core-0.16.0 (nalchevanidze)
04:31:53 * hackage morpheus-graphql 0.16.0, morpheus-graphql-subscriptions 0.16.0, morpheus-graphql-client 0.16.0 (nalchevanidze)
04:36:23 * hackage yaml-unscrambler 0.1 - Flexible declarative YAML parsing toolkit  https://hackage.haskell.org/package/yaml-unscrambler-0.1 (NikitaVolkov)
04:39:23 * hackage servant-swagger-ui 0.3.4.3.36.1 - Servant swagger ui  https://hackage.haskell.org/package/servant-swagger-ui-0.3.4.3.36.1 (maksbotan)
04:40:53 * hackage domain-core 0.1 - Low-level API of "domain"  https://hackage.haskell.org/package/domain-core-0.1 (NikitaVolkov)
04:44:22 * hackage yaml-unscrambler 0.1.0.1 - Flexible declarative YAML parsing toolkit  https://hackage.haskell.org/package/yaml-unscrambler-0.1.0.1 (NikitaVolkov)
05:33:53 * hackage ukrainian-phonetics-basic 0.1.9.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.9.0 (OleksandrZhabenko)
05:51:22 * hackage domain 0.1 - Codegen helping you define domain models  https://hackage.haskell.org/package/domain-0.1 (NikitaVolkov)
06:23:19 <PacoV> Hi there.
06:25:11 <PacoV> I've written a static site generator with Hakyll that handles translations in templates thanks to a functionField.
06:25:41 <PacoV> The logic is simple : it takes two strings (language and the string to translate).
06:25:55 <PacoV> If a translation for the given language exists, it's returned.
06:26:04 <PacoV> Else, it keepd the original string.
06:26:32 <PacoV> My translations are in a map of maps (Map String (Map String Strin)).
06:27:04 <PacoV> I now want to store my translations in a yaml file, not hardcoded in the haskell code.
06:27:27 <PacoV> So, I'm looking for a way to parse that (Map String (Map String Strin)) from a yaml file.
06:27:50 <timCF> Hello! Are there any good libraries for multithreading communication? I'm trying to use STM/MVar but really struggle with `BlockedIndefinitelyOnMVar` and `BlockedIndefinitelyOnSTM` handling. It results from how Haskell runtime is counting references. The biggest issue here is that runtime kills both child and parent threads with async exceptions
06:27:50 <timCF> which are very annoying to handle
06:28:13 <merijn> timCF: The RTS doesn't use reference counting
06:28:24 <PacoV> I'm still a Haskell beginner and can't figure how to extract the content of the yaml file even using the yaml package.
06:28:43 <merijn> timCF: If you get those exceptions then the only thread that can access the MVar is blocking on the MVar (and thus can't ever wake up)
06:29:01 <merijn> timCF: So you have messed up your logic somewhere
06:29:45 <PacoV> Maybe the simple form of my question could be : do you have any working example of reading a (Map )
06:29:49 <merijn> timCF: The runtime doesn't kill "both child and parent", because Haskell threads don't have such a thing as parent threads
06:29:58 <PacoV> Maybe the simple form of my question could be : do you have any working example of reading a (Map String String) from a Yaml file please?
06:30:20 <merijn> timCF: However, if the main thread exits the program stops, even if there are other threads still running
06:31:18 <merijn> timCF: You should probably tell us what you're doing and what you actually want, else we can only guess
06:31:25 <timCF> merijn it's valid situation in some cases. For example some sort of API socket subscriptions which is running in separate thread and is supposed to put value into TChan, but got disconnected, subscription process terminating, parent process considers deadlocked
06:31:46 <merijn> Well, yes
06:31:52 <merijn> That's because it is deadlocked
06:32:08 <merijn> Unless other threads also use the same TChan
06:33:38 <timCF> merijn I'm using `link` function from `Async` everywhere, to link parent and child processes, so I kinda have this category
06:33:56 <merijn> Well, if you don't want you parent to get killed...don't use link?
06:34:06 <merijn> Like...that's what link is for...
06:34:22 * hackage goldplate 0.1.2 - A lightweight golden test runner  https://hackage.haskell.org/package/goldplate-0.1.2 (JasperVanDerJeugt)
06:41:14 <PacoV> Basically need to parse something like http://ix.io/2D7k as a (Map String (Map String String)).
06:47:53 <jollygood2> > splitOn [5] [1..10]
06:47:55 <lambdabot>  [[1,2,3,4],[6,7,8,9,10]]
06:48:07 <jollygood2> is there something like this that will include separator in either list?
06:49:24 <ski> separator ?
06:49:39 <ski> hm
06:49:40 <jollygood2> 5 in the example above
06:50:26 <int-e> https://hackage.haskell.org/package/split-0.2.3.4/docs/Data-List-Split.html#v:onSublist
06:51:16 <jollygood2> close but not quite what I had in mind. f 5 [1..10] should give me [1,2,3,4,5] [6,7,8,9,10]
06:52:09 <jollygood2> and f 3 [1,3,4,3,5]  => [[1,3],[4,3],[5]]
06:54:02 <ski> > unfoldr (\xs0 -> guard (not (null xs0)) >> pure (let (ys,xs1) = break ('c' ==) xs0; (zs,xs2) = span ('c' ==) xs1 in (ys ++ zs,xs2))) "abacabadabacabaeabacabadabacabaf"
06:54:04 <lambdabot>  ["abac","abadabac","abaeabac","abadabac","abaf"]
06:54:35 <ski> > unfoldr (\xs0 -> guard (not (null xs0)) >> pure (let (ys,xs1) = break (3 ==) xs0; (zs,xs2) = span (3 ==) xs1 in (ys ++ zs,xs2))) [1,3,4,3,5]
06:54:37 <lambdabot>  [[1,3],[4,3],[5]]
06:56:51 <jollygood2> interesting
06:57:39 <ski> > let assoc = (fst &&& fst . snd) &&& snd . snd in unfoldr (\xs0 -> guard (not (null xs0)) >> (pure . first (uncurry (++)) . assoc) (span (3 ==) <$> break (3 ==) xs0)) [1,3,4,3,5]
06:57:41 <lambdabot>  [[1,3],[4,3],[5]]
07:02:14 <jollygood2> thanks for interesting solutions, but Data.List.Split can actually do this
07:02:18 <jollygood2> > split (keepDelimsR $ whenElt (==3)) [1,3,4,3,5]
07:02:20 <lambdabot>  [[1,3],[4,3],[5]]
07:02:42 <akegalj> Hey guys. I just run onto article that says effect tracking is useless https://degoes.net/articles/no-effect-tracking . I am not sure has this been discussed in haskell community but I am not sure I understand the point he is making. In a similar way I find it would be beneficial to track exceptions - that way we can at least be sure we are at least handling all exceptions (and compiler can ensure that). 
07:02:48 <akegalj> In short, what is your opinion about this and if this is already discussed somewhere from haskell community can you point me to it?
07:06:52 * hackage kubernetes-client-core 0.3.1.0 - Auto-generated kubernetes-client-core API Client  https://hackage.haskell.org/package/kubernetes-client-core-0.3.1.0 (axeman)
07:07:52 * hackage kubernetes-client 0.3.1.0 - Client library for Kubernetes  https://hackage.haskell.org/package/kubernetes-client-0.3.1.0 (axeman)
07:21:57 <ski> akegalj : i would distinguish between "side-effects" and "effects". the poster correctly notes that e.g. `putStrLn :: String -> IO ()' doesn't have any side-effects, but i'd still claim that it has (`IO'-)effects. and that `IO' "tracks" effects (it's a very crude form a tracking, not fine-grained. also there's other types of effects, e.g. `Maybe',`[]',`Either e',`STM',`ST s',...)
07:23:18 <hololeap_> is there any way to turn `IO [a]` into `LogicT IO a`?
07:27:38 <hololeap> % import System.Directory
07:27:38 <yahb> hololeap: 
07:27:45 <hololeap> % :t \f -> fmap (concat . transpose) . traverse listDirectory >=> mapM_ f
07:27:45 <yahb> hololeap: (FilePath -> IO b) -> [FilePath] -> IO ()
07:27:55 <ski> @type let oneOf = foldr ((<|>) . pure) empty in (oneOf =<<) . lift :: IO [a] -> LogicT IO a
07:27:56 <lambdabot> IO [a] -> LogicT IO a
07:29:48 <hololeap> i'm trying to do a breadth-first scan of a list of directories, and do some kind of IO action on each file, so a file structure like [a/a.txt
07:30:49 <hololeap> ["a/a.txt","a/b.txt","b/a.txt","c/a.txt"] would be processed in the order ["a/a.txt","b/a.txt","c/a.txt","a/b.txt"]
07:31:45 <hololeap> would LogicT be the way to go for this or should i just stick with lists, using transpose to get the order i'm looking for
07:32:22 <hololeap> i'm still pretty unfamiliar with LogicT, so i might be reaching for it when it isn't necessary
07:36:54 <ski> akegalj : i agree that part of the power of `IO' (and other monads and idioms) is having effects be first-class values
07:37:39 <ski> @quote world's.best
07:37:39 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
07:38:07 <ski> @quote SPJ world's.best
07:38:07 <lambdabot> SPJ says: Haskell is the world's best imperative language.
07:38:22 * hackage domain-optics 0.1 - Integration of domain with optics  https://hackage.haskell.org/package/domain-optics-0.1 (NikitaVolkov)
07:39:24 <ski> part of the point of that quip is the first-classness. but another part, i'd argue, is that, because there's no side-effects, we can employ equational reasoning everywhere, commuting, duplicating and discarding, which wouldn't be valid in the presence of side-effects
07:42:33 <ski> re their point about already knowing what side-effects a procedure performs, if one knows what it's intended to do, i'd disagree. you could easily use a library-function that depends on some mutable state being set up to an appropriate, or some thread/process/service being started, and people do add such things to implementations without noting it in the interface
07:43:18 <akegalj> ski: haha, I love quote thing :D Didn't know about that
07:45:00 <ski> so a compiler-enforced checking of what effects an operation could possibly do could be useful then. and having a tool (like compiler ior IDE) infer effects would sometimes not be enough, since we'd want to check expectations (at some interface level, the effects are private, can't leak, say)
07:46:30 <ski> (still, `IO' is a very crude sort of tracking. all-or-nothing. no ability to dicern more specifically what kind of effects can occur. that can sometimes be a problem, yes)
07:47:55 <ski> also, i'd take issue with their "Effect-Tracked Java‚Ñ¢", that it doesn't provide the same (reasoning) convenience as with the Haskell situation .. unless one adds some syntactic salt not only annotating the interfaces of operations, but also requiring each call to a side-effectful operation to be annotated in a way to highlight this
07:49:35 <ski> (Mercury is a language that has such a purity system, where impure (and semipure) calls must be annotated with syntactic salt `impure' and `semipure'. note that the purity system is primarily intended for FFI stuff, though. there's a separate `io' system, which is similar to the `World' that is uniquely passed around in Clean, and still also somewhat (albeit less) similar to `IO' in Haskell)
07:50:29 <ski> the point is that, without some such syntactic salt, you'll have to look up the interface of called operations, to check whether they may have side-effects. rather than seeing it directly there, in the source
07:51:14 <ski> (with IDE support, this could be less of an issue. but then there's a separate argument that perhaps it's a good thing to not have to rely on an IDE .. this can be discussed forward and back)
07:52:17 <ski> with such syntactic salt, you'll be alerted when you're interchanging the order of two side-effecting operations, or duplicating/factoring one, or discarding one, that the effects expressed might not be the same
07:53:14 <ski> btw, note that Java does track exceptions (in a fine-grained manner). exceptions are another kind of side-effect
07:54:03 <akegalj> how does java track exceptions?
07:54:07 <ski> (it's also debatable whether the fine-grained tracking is good or not. note that the `IO' exceptions in Haskell are not tracked in fine-grained way)
07:54:19 <ski> `throws' clause attached to method signatures
07:54:20 <merijn> ski: Which was a massive mistake >.>
07:54:27 <ski> merijn : which ?
07:54:35 <merijn> unchecked exceptions in Haskell
07:55:54 <ski> in Haskell, the `<$>' in e.g. `reverse <$> getLine' is comparable to the aforementioned syntactic salt
07:57:22 <ski> (here, one can argue, that it would be better to annotate just the specific effectful calls, rather than the path down to them in the AST. i have experimented a little with some ideas for a "effect reflection syntax" that would address this)
07:58:59 <akegalj> ski: you are right, I forgot that java tracks exceptions https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html
07:59:50 <ski> akegalj : still, interesting, thought-provoking, blag
08:00:26 <akegalj> ski: yes, thanks for your input. It was interesting read
08:02:15 <ski> akegalj : anyway .. to repeat, the author doesn't appear to make the distinction between "effect" and "side-effect". it's this distinction (present in the implementation code, not just in interfaces) that enables one to tell that one can use powerful equational reasoning & refactoring in the former case, and less powerful such in the latter case
08:04:35 <ski> if you have `do x <- foo; y <- bar; frob x y', in `ST s', say, and you happen to know that the state that `foo' interacts with is independent of the state that `bar' interacts with, then you can of course refactor this to `do y <- bar; x <- foo; frob x y'. but this independence is not tracked (no fine-grained state tracking)
08:06:29 <ski> in some monads or idioms, you may know that their effects are discardable, so that if you don't use the result of an action, then the action may be omitted. or perhaps you know that all effects commute, or possibly that they're duplicable (presumably some caching is going on, then)
08:08:34 <ski> in Mercury, semipure predicate calls commutes with each other (and are also discardable and duplicable, iirc), but doesn't commute with impure ones. semipure ones may e.g. read some mutable state, but may not change it
08:10:33 <akegalj> goes to look at Mercury...
08:11:47 <akegalj> ski: hm, thats interesting distinction between pure and semipure
08:12:00 <ski> (<https://www.mercurylang.org/information/doc-latest/mercury_ref/Impurity.html> is the relevant manual section on that. also see " Using impurity to create declarative interfaces in Mercury" by Tyson Dowd,Peter Schachte,Fergus Henderson,Zoltan Somogyi in 2000-04 at <https://www.mercurylang.org/documentation/papers.html#purity>)
08:16:32 <akegalj> ski: that's enough info atm. I have to groak this info and think about it for a while to form some opinion. Thanks a lot for references and all input <3 . *akegalj* Goes for a walk to reflect 
08:17:53 * hackage generic-data 0.9.2.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.9.2.0 (lyxia)
08:18:23 <hololeap> is there a way to merge two `ConduitT () o m ()` streams, so that they will yield `o`s in the same temporal order that they are produced in both streams?
08:18:59 <hololeap> e.g. writing stdout and stderr to the same file, in the order that each meassage is produced
08:19:09 <hololeap> s/message/line of text/
08:20:03 <merijn> hololeap: That...is not a sensical question :)
08:20:24 <merijn> hololeap: because conduit produces a sequential loop
08:20:37 <merijn> hololeap: There is no "temporal order"
08:20:54 <hololeap> ok, that's kind of what i was afraid of
08:21:17 <merijn> hololeap: If you run the two conduits and dump them into a channel, then you can have another conduit reading from the channel
08:22:14 <merijn> hololeap: What are the original streams?
08:23:11 <hololeap> the stdout and stderr streams shown here: https://hackage.haskell.org/package/conduit-extra-1.3.5/docs/Data-Conduit-Process.html#v:sourceProcessWithStreams
08:23:45 <merijn> Yeah, you'll have to handle those in separate threads
08:24:40 <hololeap> (yeah my original question was messed up)
08:24:58 <hololeap> but, that's a good idea merijn, and i should be able to make it work
09:15:22 * hackage hevm 0.42.0 - Ethereum virtual machine evaluator  https://hackage.haskell.org/package/hevm-0.42.0 (MrChico)
10:26:23 * hackage prolude 0.0.0.6 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.6 (saramuse)
10:43:17 <tomjaguarpaw> Is there a Haskell hashing library where I can take the hash of two hashes and have it produce something sensible? hashable (Data.Hashable) has results that are ... interesting
10:44:34 <opqdonut> usually one xors hashes together to combine them
10:44:52 <opqdonut> googling turns up https://hackage.haskell.org/package/data-hash-0.2.0.1/docs/Data-Hash.html
10:44:58 <opqdonut> with a combine :: Hash -> Hash -> Hash
10:45:19 <opqdonut> I hope you don't need cryptographic hashing?
10:47:23 * hackage base16-bytestring 1.0.1.0 - RFC 4648-compliant Base16 encodings for ByteStrings  https://hackage.haskell.org/package/base16-bytestring-1.0.1.0 (topos)
10:47:41 <tomjaguarpaw> opqdonut: Indeed, no need for cryptographic
10:48:10 <tomjaguarpaw> I was a little wary of that library since it hasn't been updated in 5 years.  Maybe it's OK.
10:48:22 * hackage persistent 2.11.0.1 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.11.0.1 (parsonsmatt)
10:50:05 <tomjaguarpaw> Hmm, combining by rotate and xor doesn't sound very safe
10:50:38 <tomjaguarpaw> I would like 1 `combine` 2 not to collide with 0, for example
10:51:01 <tomjaguarpaw> But maybe it it's post-hashing it's Ok
10:52:44 <sm[m]> maralorn: https://shakebuild.com/faq#why-is-there-a-shake-executable is related
11:01:35 <maralorn> sm: Thank you. The reason was simply that I needed to call it Shakefile.hs with capital S.
11:03:51 <maralorn> I wish there were something like "shake watch"
11:04:04 <maralorn>  * I wish there was something like "shake watch"
11:11:49 <monochrom> "were" is OK. Actually more proper IMO :)
11:15:19 <tomsmeding> yay subjunctive
11:16:04 <tomsmeding> @quickcheck \i -> hash (i :: Int) == i
11:16:04 <lambdabot> Unknown command, try @list
11:16:11 <tomsmeding> @check \i -> hash (i :: Int) == i
11:16:13 <lambdabot>  error:
11:16:13 <lambdabot>  ‚Ä¢ Variable not in scope: hash :: Int -> Int ‚Ä¢ Perhaps you meant ‚Äòhas‚Äô (impor...
11:16:22 <tomsmeding> @check \i -> Data.Hashable.hash (i :: Int) == i
11:16:24 <lambdabot>  error:
11:16:24 <lambdabot>  Not in scope: ‚ÄòData.Hashable.hash‚Äô No module named ‚ÄòData.Hashable‚Äô is imported.
11:16:50 <tomsmeding> okay fine, but tomjaguarpaw this succeeds locally, which explains kind of why combining that with an xor doesn't work :p
11:17:18 <sm[m]> maralorn: I do ls FILES | entr SHAKECMD
11:17:54 <maralorn> sm: I do, too.
11:19:24 <sm[m]> you're right, it does seem like a feature that could be built in, I actually thought it was
11:21:34 <tomjaguarpaw> opqdonut: FWIW Data.Hash also has the property that I am trying to avoid, specifically:
11:21:37 <tomjaguarpaw> *Hash H> let h x y = (H.hash (x :: Int) `H.combine` (H.hash x `H.combine` H.hash (y :: Int)), H.hash y)
11:21:40 <tomjaguarpaw> *Hash H> h 123 45657
11:21:42 <tomjaguarpaw> (Hash {asWord64 = 16277888606689116690},Hash {asWord64 = 16277888606689116690})
11:21:46 <tomjaguarpaw> x `combine` x `combine` y == y
11:22:07 <tomjaguarpaw> I'm at a loss about how to avoid this. It seems to make compositional hashing of trees impossible.
11:27:05 <tomsmeding> @let wangHash = (\x -> x `xor` (x `rotateR` 16)) . (\x -> x * 2057) . (\x -> x `xor` (x `rotateR` 4)) . (\x -> x + (x `shiftL` 2)) . (\x -> x `xor` (x `rotateR` 12)) . (\x -> complement x + (x `shiftL` 15))
11:27:06 <tomjaguarpaw> Python's hash has the property I desire. I'm not sure what the algorithm is though.
11:27:06 <lambdabot>  Defined.
11:27:23 <tomsmeding> > wangHash 123 `xor` (wangHash 123 `xor` wangHash 45657)
11:27:25 <lambdabot>  14571355508018
11:27:41 <tomsmeding> http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
11:27:47 <tomjaguarpaw> > wangHash 123 `xor` (wangHash 123 `xor` wangHash 123)
11:27:50 <lambdabot>  38872050059
11:27:55 <tomjaguarpaw> > wangHash 123
11:27:57 <lambdabot>  38872050059
11:27:59 <tomjaguarpaw> Still not idea
11:28:01 <tomjaguarpaw> l
11:28:01 <tomsmeding> o
11:28:47 <tomsmeding> well
11:28:50 <tomsmeding> that's kind of expected
11:29:01 <tomsmeding> @check \i -> i `xor` i == 0
11:29:01 <tomjaguarpaw> Yes, if xor is the combiner
11:29:02 <lambdabot>  +++ OK, passed 100 tests.
11:29:44 <tomsmeding> so let combine x y = hash (x `xor` permute y)
11:29:51 <tomsmeding> merkle trees?
11:30:10 <tomjaguarpaw> Well, I am basically trying to implement a merkle tree.
11:30:17 <tomjaguarpaw> The question is what hash algorithm I should use.
11:30:25 <tomjaguarpaw> They seem to use one called "tiger hash"
11:32:13 <tomsmeding> is this not basically asking how to construct a hash that takes arbitrary-length input from one that takes fixed-length input?
11:33:01 <tomjaguarpaw> No, it's fixed length plus nesting
11:33:15 <tomjaguarpaw> *arbitrary length plus arbitrary nesting
11:33:32 <tomjaguarpaw> Well, the arbitrary length is a good start, but has other mitigations
11:34:19 <tomsmeding> if you can hash two blocks of data into one block of data, you can trivially hash arbitrary-length data, right?
11:34:54 <tomsmeding> from that perspective, being able to combine two hashes is ~equivalent to being able to handle arbitrary-length data
11:35:28 <tomjaguarpaw> I don't think it's so simple in the presence of the property x `combine` x `combine` y == y
11:35:49 <tomjaguarpaw> The Data.Hashable [a] instance also tracks the length of the list for this reason
11:35:51 <tomsmeding> well you also wouldn't want [x, x, y] to hash to the same as [y]
11:35:59 <tomsmeding> right
11:35:59 <tomjaguarpaw> Correct
11:36:10 <tomjaguarpaw> So Data.Hashable lacks some desirable property
11:36:32 <int-e> well, (x `combine` x) `combine` y would be kind of okay
11:36:46 <int-e> with that particular definition
11:37:59 * int-e wonders how terrible combine x y = 3*x `xor` 5*y  would be, for non-adverserial purposes of course.
11:38:20 <tomsmeding> tomjaguarpaw: I see you say that Python's hash works for you; how do you define 'combine' there?
11:39:29 <tomsmeding> I do believe that something of the form of 'combine x y = (x `rotateL` 15) `xor` (y `rotateR` 2)' is quite usual
11:39:53 <arampa> hi, noob question regarding an assignment: I have a custom data type which represents intervals of Int numbers (e.g., (3,5)) and a function which takes a list and generates an interval based on the values of that list. I get the following error: <interactive>:431:1: error:    ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòprint‚Äô
11:39:53 <arampa> prevents the constraint ‚Äò(Show a0)‚Äô from being solved.      Probable fix: use a type annotation to specify what ‚Äòa0‚Äô should be.      These potential instances exist:        instance (Show a, Show b) => Show (Either a b)          -- Defined in ‚ÄòData.Either‚Äô        instance Show Ordering -- Defined in ‚ÄòGHC.Show‚Äô        instance Show
11:39:54 <arampa> Integer -- Defined in ‚ÄòGHC.Show‚Äô        ...plus 24 others        ...plus 53 instances involving out-of-scope types        (use -fprint-potential-instances to see them all)    ‚Ä¢ In a stmt of an interactive GHCi command: print it
11:40:10 <int-e> @where paste
11:40:10 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
11:40:38 <tomsmeding> should that thing get a proper domain name
11:40:49 <arampa> https://paste.tomsmeding.com/nmri084o
11:41:19 <arampa> the interesting thing is that, if I use this function by itself, i.e., not as part of a typeclass, it seems to work fine
11:41:22 <int-e> tomsmeding: what's improper about it :-P (I imagine it pings you quite a bit though)
11:41:41 <tomsmeding> arampa: the function by itself looks fine; how are you using it to produce that error?
11:42:07 <arampa> https://paste.tomsmeding.com/A37O6NQu
11:42:10 <Uniaika> tomsmeding: 5‚Ç¨ if you manage to get it hosted by haskell.org :P
11:42:24 <tomsmeding> Uniaika: life goals
11:42:52 <tomsmeding> arampa: I assume that you give this definition in a particular instance of that class?
11:42:57 <tomsmeding> which one? :)
11:43:07 <int-e> arampa: that's not the complete code. please also include the error message (as a comment, for example). but as a guess, your custom datatype could use a "deriving Show".
11:44:09 <arampa> https://paste.tomsmeding.com/YX1a14kM
11:44:20 <arampa> this is how I'd use it on an empty list, for example
11:44:27 <tomjaguarpaw> tomsmeding: In Python I would do combine(x, y) == hash((x, y))
11:45:13 <arampa> my goal is to make my Interval type an instance of the Code typeclass. It is already an instance of Show (without using deriving)
11:45:55 <int-e> arampa: you also need to specify what the result type should be; it's impossible for ghc to know which instance of `Code` it's supposed to use.
11:46:40 <int-e> encode [] :: <whatever your type name is>
11:47:20 <arampa> encode [] :: Interval works fine
11:48:31 <arampa> but if I do this https://paste.tomsmeding.com/YCKBD5QM
11:48:33 <int-e> This is a bit obscure, but the `a0` refers to the result type that ghc couldn't infer and is trying to print. The `print` is implicitly added by ghci when evaluating a plain expression
11:49:15 <tomsmeding> tomjaguarpaw: here's how python does tuple hashes as far as I can see: https://github.com/python/cpython/blob/f522a57ec77921ee2e60bd4ccda3c8daa5a43e95/Objects/tupleobject.c#L368
11:49:18 <arampa> and I run it this way, https://paste.tomsmeding.com/b4qkf9SN this is what happens
11:49:21 <int-e> your `encode` is a member of a type class; it could have plenty of different implementations.
11:49:35 <int-e> so you have to specify the type at the point where `encode` is used.
11:50:32 <tomjaguarpaw> tomsmeding: Thanks, yes, I may copy that
11:51:16 <arampa> so, encode [] :: Interval would be enough for my purposes? I do not use this function in any other functions
11:51:41 <arampa> or do you mean that I should define Interval in the type signature?
11:51:45 <arampa> sorry I get a bit confused
11:52:39 <int-e> arampa: encode [] :: Interval  is sufficient. Annotating that `Empty` value is actually pointless; ghc will infer the type from the constructor.
11:54:33 <int-e> arampa: If you type `:t encode`, ghci will tell you that the type of `encode` is `Code a => [Int] -> a`. That doesn't mention Interval at all, which is why ghc(i) needs help to determine the result type.
11:54:56 <arampa> okay I understand, thank you so much!
12:00:31 <fendor> finally, I found someone from university, doing the functional programming course
12:00:40 <fendor> *from my
12:17:57 <JohnnyL> How stable is SDL for haskell?
12:18:40 <dminuoso> JohnnyL: There's sdl2 on hackage that has quite a few downloads.
12:19:08 <dminuoso> It has a couple issues on github, but oh well - this is sdl after all.
12:20:47 <JohnnyL> dminuoso: ok
12:21:26 <JohnnyL> I assume that it all compiles into one big binary.
12:23:53 <dminuoso> What do you mean?
12:24:30 <koz_> dminuoso: I think they are asking 'do I get static linking of my C deps'.
12:24:47 <dminuoso> You can statically link anything you want.
12:28:01 <dminuoso> That is, if you want non-haskell to be statically linked, you can pass `-optl-static -optl-pthread` to ghc. Keep in mind that you very likely need musl or similar if you have any transitive dependency on NSS
12:28:20 <dminuoso> (Since statically linking glibc is not officially supported, and likely leads to quirky bugs)
12:29:14 <dminuoso> (And you must provide these libraries as .a to GHC, which for some libraries like libpg can be a hassle)
12:30:12 <bqv> haskell itself is static by default, right?
12:31:54 <sm[m]> JohnnyL: sdl2 works great and doesn't change much, so I'd say pretty stable
12:36:57 <JohnnyL> It's not sdl2 I'm worried about.
12:39:41 <matthew-> am I right in thinking that when you're doing type inference for a throw-away var, e.g. _ every time you see _ you allocate a fresh type variable (for the purposes of unification)
12:40:19 <bqv> in answer to myself: yes. yes it is
12:44:40 <lyxia> matthew-: yes. you can treat _ like just an unused variable.
12:50:27 <matthew-> lyxia: thanks
12:56:24 <dminuoso> lyxia: Interestingly, it turns out that this is not quite true.
12:56:40 <merijn> JohnnyL: In the end GHC just calls your system linker, so anything you know how to do with C libraries/executables should translate pretty much 1-to-1 to Haskell :)
12:56:50 <dminuoso> But that's probably a bug
12:57:10 <dminuoso> I found an elaborate situation, where annotationg with `_` leads GHC To infer a different type than if not annotated at all.
12:57:21 <merijn> JohnnyL: And by default all the Haskell stuff is already linked statically, so C libraries are all you really need to handle
12:58:27 <bqv> it's like i'm on mute...
12:59:19 <merijn> bqv: That's because not everyone is completely reading the chat and some are just responding to things they see out of the corner of their eyes while playing videogames ;)
13:00:23 * hackage protocol-buffers 2.4.17 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.4.17 (TvH)
13:01:23 * hackage protocol-buffers-descriptor 2.4.17, hprotoc 2.4.17 (TvH): https://qbin.io/chevy-ago-djgz
13:34:23 * hackage compdoc 0.2.0.0 - Parse a Pandoc to a composite value.  https://hackage.haskell.org/package/compdoc-0.2.0.0 (locallycompact)
13:49:01 <grepcake> Hi! Suppose, I have constraints on an existential type parameter and this parameter is not otherwise used in the constructor. How do I bind that type parameter when pattern-matchin? https://gist.github.com/grepcake/141d8f06e4328f3582371f5906eab243 
13:49:45 <grepcake> One way would be to add a dummy parameter to the constructor (Proxy, I guess?), but there a way to do it without adding parameters?
13:51:36 <merijn> Not any ways that I'd recommend
13:53:24 <dminuoso> grepcake: There is an alternate option, but that's still in a language proposal
13:53:50 <grepcake> dminuoso: out of curiosity, what is it?
13:53:50 <dminuoso> (And Im not sure whether you could actually bind that one there)
13:54:17 <grepcake> merijn: is doing things like this a bad practice in general?
13:54:30 <grepcake> Should I pass Dict on the value level instead?
13:55:03 <dminuoso> grepcake: https://github.com/ghc-proposals/ghc-proposals/blob/type-applications-in-patterns/proposals/type-applications-in-patterns.rst
13:55:12 <dminuoso> grepcake: Dict is the only other option that I can see, yes.
13:56:47 <solonarv> ah, I was thinking about typeapps in patterns but couldn't remember if they were already in the language
13:56:58 <grepcake> dminuoso: thanks, pretty interesting. examples seem to imply that it would be possible to bind param in my case
13:57:25 <dminuoso> grepcake: right, Im just not 100% confident about interaction with GADTs and constriants
13:57:44 <dminuoso> (but the `constraints` library is definitely an option)
13:58:13 <grepcake> Yep, appparently I'll stick with it
13:58:19 <dminuoso> Also, since you seem to be meddling with constraints, you could be interested in this: https://hackage.haskell.org/package/constraints-extras-0.3.0.2/docs/Data-Constraint-Extras.html
13:58:33 <dminuoso> (*GADTs)
13:58:59 <dminuoso> Just something to be aware of, I dont know your code whether its useful to you.
13:59:46 <dminuoso> Cale described it best as Pi for constraints.
14:01:56 <grepcake> dminuoso: I'll definitely look into it, thanks!
14:21:48 <bqv> folks, a question
14:22:55 <bqv> would it be possible, through type magic, to have a way of working out what function arity a type has, and then transforming the result of that function type?
14:23:24 <bqv> i.e composing a function to that function regardless of arity
14:24:30 <Ariakenom> well i can call id
14:24:33 <Ariakenom> :t id 
14:24:35 <lambdabot> a -> a
14:24:36 <Ariakenom> 3 times
14:24:42 <Ariakenom> > id id id 1
14:24:45 <lambdabot>  1
14:25:00 <Ariakenom> not 3 times. I meant with 3 arguments
14:25:19 <bqv> of course, but id is a special case
14:25:32 <bqv> it's possible to detect arity through type magic, but it won't work with id-like types
14:25:43 <bqv> so i wonder if the rest is possible with that qualification too
14:25:50 <glguy> It's not particularly special, no. functions don't have arity in general
14:26:08 <bqv> ok say the result is an IO type
14:26:08 <glguy> they always take one argument
14:26:14 <bqv> does that help?
14:26:39 <bqv> can't type-recursion use that as an terminating case?
14:26:47 <glguy> If you restrict yourself to types of a form like that then you can do it with a typeclass
14:27:14 <glguy> class Thing a; instance Thing b => Thing (a -> b); instance Thing (IO a)
14:28:30 <bqv> neato
14:28:32 <bqv> yeah, ok
14:32:54 <merijn> glguy: Sure they do
14:33:02 <merijn> glguy: Functions have arity 1 :p
14:37:16 <JohnnyL> merijn: :)
15:02:52 * hackage commonmark 0.1.1.1 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-0.1.1.1 (JohnMacFarlane)
15:03:52 * hackage commonmark-extensions 0.2.0.3 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-extensions-0.2.0.3 (JohnMacFarlane)
15:06:46 <jcowan> What is it about multi-parameter typeclasses that excluded them from Haskell 98?  Do they make the type system unverifiable in some way, or was it just for lack of use cases at that time?
15:08:44 <Rembane> IIRC there wasn't a lack of use cases, they show up in a paper before 1998. 
15:11:04 <jcowan> Ah, here it is.  "Naive use of MPTCs may result in ambiguity, so functional dependencies were developed as a method of resolving that ambiguity, declaring that some subset of the parameters is sufficient to determine the values of the others." --from the wiki
16:00:22 * hackage poke 0.0.0.1 - Discord verification bot  https://hackage.haskell.org/package/poke-0.0.0.1 (HughSipiere)
16:00:26 <neobit> when working with Servant, this compiles: type Routes = FooRoute :<|> BarRoute :<|> BazRoute :<|> QuxRoute 
16:00:29 <neobit> but this does not: type Routes = FooRoute :<|> (BarRoute :<|> BazRoute) :<|> QuxRoute
16:00:32 <neobit> why is that?
16:03:04 <Uniaika> neobit: (the #servant channel exists for this library)
16:03:45 <Axman6> neobit: it'll be because there's a type class instance which expects :<|> to basically be used as a type level list
16:23:13 <Squarism> Im trying to grasp how Traversals / Lenses work here. An unapplied lens has signature : Control.Monad.Reader.Class.MonadReader Foo m => m (Maybe Int)
16:24:17 <Axman6> Squarism: first thing to remember about MonadReader is that there is an instance for m = ((->) r), and this is one of the most common uses, so you get r -> Maybe Int
16:24:19 <Squarism> I remember theres some magic with (->) and MonadReader. Does the above signature imply its equivalent to : Foo -> Maybe Int ? 
16:24:33 <Axman6> exactly
16:25:13 <Squarism> thanks. Finally i get this wierdness =D
16:52:11 <Axman6> Squarism: figuring out how you ncan make use of this inside a monad with a MonadReader context s quite fun, you basically get a DSL for accessing your app's configuration for free
16:53:56 <Squarism> Axman6, i have used a bunch of monadreader for passing on context. But I find the ((->) a) construct a bit confusing. 
16:54:22 * hackage commonmark 0.1.1.2 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-0.1.1.2 (JohnMacFarlane)
16:54:28 <Squarism> Its not a type but a kind right?
16:55:02 <Axman6> it's a type which isn't fully applied, it has kind * -> *
16:57:33 <Squarism> oh, i see it has a data declaration.
16:58:32 <Squarism> But i cannot write ":t ((->) 1)" in ghci
16:59:23 * hackage commonmark-extensions 0.2.0.4 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-extensions-0.2.0.4 (JohnMacFarlane)
16:59:41 <Squarism> I its definition : data (->) (a :: TYPE q) (b :: TYPE r)
17:00:45 <Axman6> no, only data has types, and (->) isn't data, it's a type, so it has a kind
17:00:52 <Axman6> @kind (->)
17:00:54 <lambdabot> * -> * -> *
17:01:02 <Squarism> "I see" correction 
17:10:46 <Mela> hello
17:12:08 <Mela> I'm a beginner learning Haskell and I have an acute question. Am I in the right place here to ask?
17:12:24 <lyxia> yes
17:12:39 <lyxia> we also take cute questions.
17:12:49 <Axman6> we prefer obtuse question though
17:13:03 <Axman6> like "Why is Haskell so bad?"
17:13:30 <Mela> you may judge whether it's cute
17:14:48 <Mela> so I want to have my own data type to represent an interval of numbers. I define it as "data Interval = Interval (lb, ub) | Empty | Invalid"
17:14:48 <jcowan> "Acute" as in acute suffering, or as in acute intelligence?
17:15:17 <jcowan> Both, I guess
17:15:27 <aldum> acute angle
17:15:46 <Mela> now I wanted to make it so that Interval(lb,ub) redirects to Empty, when ub > lb
17:15:57 <Axman6> Mela: what should the type of lb and ub be? there doesn't seem to be any need for a tuple in there either
17:16:06 <monochrom> I think we saw the same interval question several hours ago as an assignment question. Perhaps show us the whole assignment?
17:16:17 <Mela> oh :p
17:16:26 <Mela> yeah, it's indeed a uni assignment
17:16:28 <Axman6> your lecturer is probably in here by the way
17:16:50 <aldum> lol
17:17:04 <Mela> thing is in another language though, so I thought I'd translate it
17:17:05 <monochrom> I'm OK with homework questions.  I'm just not OK with incomplete butchered misrepresented information.
17:17:36 <Axman6> so be very careful what you ask, and make sure you don't use any code anyone provides to you. We are happy to help you come up with answers, but we don't do your homework for you.
17:17:37 <monochrom> And last time the other student only showed two lines of code every 5 minutes.
17:18:04 <Axman6> Mela: so what have you tried so far, and what ideas have you had?
17:18:15 <Axman6> (I'm also curious what the other language is)
17:18:31 <Mela> gotcha
17:18:39 <Mela> (how do I properly post code in here?)
17:18:44 <Axman6> @where paste
17:18:44 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
17:18:52 <monochrom> I don't get it. If you don't tell people that you aren't telepathic, people simply assume you're telepathic. "Hi I got an error, here is the error message but I'm not going to show you my code". What kind of logic is that.
17:20:07 <aldum> they don't assume telepathy, just have a frame of mind which is very focused on the problem, and don't take the effort to imagine what implicit knowledge they have that you don't
17:20:16 <aldum> I know because I do this a lot
17:29:25 <Mela> hi again
17:30:11 <Mela> I wrote my question in more detail here now (https://paste.tomsmeding.com/kCD7VKFq). I hope this is understandable.
17:30:46 <Mela> https://paste.tomsmeding.com/kCD7VKFq sorry for breaking the link above
17:31:53 <monochrom> cannot be done
17:33:25 <Mela> wow, not at all?
17:33:46 <Axman6> well, it of course can be done, using functions
17:34:11 <monochrom> That's different from the stated question.
17:34:34 <Axman6> it can also be made to look like a constructor by using pattern synonyms
17:34:51 <monochrom> I'm pretty sure the course is not at a point ready for pattern synonyms.
17:34:53 <Axman6> but that's definitely way outside the skope of your course
17:35:00 <monochrom> So why bring it up?
17:35:21 <Axman6> you said it can't be done, but it can
17:36:34 <Mela> right, so what motivates the question is that right now I have a lot of functions where each of them makes this kind of "if m > n, then replace with Empty" check
17:36:48 <Mela> I'm looking for a way to achieve that in one place, since it's repetitive
17:38:08 <monochrom> Write a function f such that f (IV (5,3)) = Empty, f xxx = xxx for other cases.
17:38:19 <monochrom> Then you can reuse f everywhere.
17:38:40 <monochrom> This is not the same as making i1 and i2 equivalent.
17:39:33 <JohnnyL> What platforms would be supported by SDL2 and Haskell?
17:46:41 <texasmyn_> is it possible to alter the pandoc table of contents with a filter? I can't tell from the docs in Hackage but I do not know the Pandoc module well.
17:49:20 <Mela> I'm not sure that I understand. Here's the implementation of 'show' as an example - https://paste.tomsmeding.com/BQhdNEnr
17:52:32 <monochrom> Do you mind writing an ordinary function showIntervalDumb outside "instance Show Intervel".
17:52:53 <monochrom> showIntervalDumb :: Interval -> String.
17:53:40 <Mela> what would be the advantage?
17:53:40 <monochrom> It doesn't do anything smart. It always converts IV(m,n) to "<" ++ (show m) ++ "," ++ (show n) ++ ">"
17:54:03 <monochrom> Then your instance goes "show i = showIntervalDumb (f i)"
17:54:44 <monochrom> Since f already does the smart normalization, showIntervalDumb has nothing to worry about.
17:54:55 <monochrom> And f can also be reused elsewhere
17:56:23 <Mela> oh, I see
17:57:37 <Mela> Do I need an extra function? Couldn't I just write show i = show (f i) as the top priority definition? then after that define show as I usually would?
17:58:07 <monochrom> That's an infinite loop.
17:59:18 <Mela> oh
17:59:58 <Mela> I guess I could not define anything for the case of m > n and put show i = show (f i) as least priority to catch it?
18:02:49 <Mela> alright, but I think using this sort of wrapper function to normalize the intervals is a nice enough solution :D  thanks for helping!
18:06:00 <Mela> I still wonder why my original idea doesn't work in Haskell though. a value constructor ("IV" here) is just another function (that results in a type "Interval" here), no? So why can't I pattern match and put up a rule for a specific case, as long as I assign the proper type (and Empty is an Interval type here)?
18:08:22 <monochrom> You are confusing "a function I can write and rewrite" with "a function that the computer auto-generates for me".
18:08:58 <monochrom> IV can play the role of a function, but that function came from the computer, not you. It's coding is already done, you cannot change it.
18:09:11 <monochrom> s/It's/Its/
18:11:43 <JohnnyL> monochrom: didn't you used to hang in #lisp?
18:11:55 <monochrom> No.
18:12:56 <Mela> yes, that's indeed a new concept to me. I thought I could just add to any function that exists
18:13:31 <Mela> thanks for clarifying!
18:23:45 <JohnnyL> What platforms does Hackage support?
18:33:20 <sm[m]> JohnnyL: all platforms you can install cabal on
18:33:21 <sm[m]> but if you're on Windows, you need to check package dependencies for certain packages that won't build easily there (like "unix")
18:41:20 <JohnnyL> sm[m]: ok
18:42:54 <JohnnyL> It seems linux heavy. I think I'll just write my game in Rust.
18:44:00 <DigitalKiwi> there are a few haskell game engines
18:44:18 <DigitalKiwi> https://wiki.haskell.org/Game_Development
18:50:44 <JohnnyL> broken links and thesises is no real surprise in that link.
19:03:58 <sm[m]> see also #haskell-game. Haskell game devs are undercover but keen!
19:04:16 <sm[m]> ah, you found it
19:11:59 <MarcelineVQ> maybe the real haskell game was the demos we made along the way
19:13:53 * hackage reflex-gadt-api 0.2.0.0 - Interact with a GADT API in your reflex-dom application.  https://hackage.haskell.org/package/reflex-gadt-api-0.2.0.0 (abrar)
19:20:34 <bqv> I'm using UndecidableInstances
19:20:43 * bqv runs
19:23:23 * hackage reflex-gadt-api 0.2.0.1 - Interact with a GADT API in your reflex-dom application.  https://hackage.haskell.org/package/reflex-gadt-api-0.2.0.1 (abrar)
19:24:51 * DigitalKiwi shuns bqv
19:58:53 * hackage dependent-sum-aeson-orphans 0.3.0.0 - JSON instances for DSum, DMap, and Some  https://hackage.haskell.org/package/dependent-sum-aeson-orphans-0.3.0.0 (abrar)
20:24:35 <bqv> refactoring haskell code is honestly the most fun part of haskell
20:56:53 * hackage update-nix-fetchgit 0.2.3 - A program to update fetchgit values in Nix expressions  https://hackage.haskell.org/package/update-nix-fetchgit-0.2.3 (jophish)
21:16:23 * hackage citeproc 0.1.1.1 - Generates citations and bibliography from CSL styles.  https://hackage.haskell.org/package/citeproc-0.1.1.1 (JohnMacFarlane)
23:35:57 <loximann> Hi! I need some help... I am using Fedora 33. When I run ghci, all the packages installed via the operating system are hidden. Can anyone give me a hand?
23:46:22 <loximann> Uhm, is this channel active at all?
23:46:51 <Uniaika> yep but it's still the morning for many europeans :)
23:47:04 <Uniaika> and night for americans
23:47:12 <loximann> True :-D
23:47:32 <Uniaika> loximann: I am also a fedora user, btw
23:47:38 <loximann> Uniaika certainly :-D (I am located in Helsinki ;-) )
23:47:53 <loximann> So much in common :-D
23:48:25 <Uniaika> ei, I'm not Finnish :P
23:48:29 <Uniaika> so
23:48:36 <Uniaika> don't install haskell packages with dnf
23:48:38 <Uniaika> just don't
23:48:54 <Uniaika> you install them with cabal, stack, nix, watever
23:49:02 <loximann> OK? But it has worked fine. And in two other systems it has been fine
23:49:53 <Uniaika> Debian is 5 years late compared to everybody and Arch has decided to do nonsensical policies with dynamic linking :P
23:50:02 <Uniaika> This is not a reliable way to install libraries
23:50:26 <loximann> OK, thanks
23:50:45 <loximann> Still, it would be good to know why it works in a couple of my systems and it doesn't on this one
23:50:55 <Uniaika> it's not that it *doesn't work*
23:51:02 <Uniaika> it's just that it won't *reliably*
23:51:26 <Uniaika> on the long term you're better off with a cabal store, even a cabal project! 
23:51:56 <Uniaika> with stack, you can invoque a REPL with arbitrary packages, for instance
23:52:00 <Uniaika> a bit like nix
23:53:26 <loximann> I don't know, I have been fine for a long long time with my old-fashioned way, so far I have been happy with ghc and ghci for my needs... I would prefer not to change that workflow
23:54:16 <loximann> I understand the rationale for using cabal/nix/whatnot, but for me coming where I am coming from, I feel more comfortable with more minimalistic tools
23:55:51 <sclv> cabal _is_ the most minimalistic tool
23:56:01 <sclv> using system packaging is way more fragile and complex
23:56:18 <Uniaika> loximann: yes but here you are, with a broken setup :)
23:56:58 <sclv> in any case your question is rather vaguee
23:57:14 <loximann> OK, I can formulate it more properly :-)
23:57:20 <sclv> do the packages show up unhidden in `ghc-pkg list`?
23:57:34 <loximann> Yeah, I mean not in parentheses
23:57:51 <sclv> ok and how do you launch ghci?
23:58:03 <loximann> Just type ghci on the console
23:58:34 <sclv> that's strange
23:58:41 <sclv> have you tried `ghc-pkg check`?
23:59:06 <loximann> No, I run it without arguments now and nothing happened?
23:59:09 <sclv> my one guess is you accidentally have a ghc environment file somewheree
23:59:46 <sclv> https://ghc.gitlab.haskell.org/ghc/doc/users_guide/packages.html
