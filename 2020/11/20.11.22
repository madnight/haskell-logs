00:37:23 * hackage Z-IO 0.1.9.0 - Simple and high performance IO toolkit for Haskell  https://hackage.haskell.org/package/Z-IO-0.1.9.0 (winterland)
02:55:46 <gagbo> Hello, I'm a stack noob that needs help. In my dependencies I have unix-time (https://hackage.haskell.org/package/unix-time) and it can't compile because of this https://github.com/HardySimpson/zlog/issues/119 basically.
02:56:09 <gagbo> So how can I set CFLAGS in the recipe of a dependency of my project ?
03:00:07 <[exa]> interesting, I see no reason why the package would force -Werror
03:01:31 <gagbo> it's weird yeah, but that's the only thing from my output, I didn't see any compilation error.
03:02:00 <[exa]> can you grep you stack project config for -Werror ?
03:03:43 <gagbo> https://imgur.com/QEv7TtJ
03:03:46 <gagbo> I'll do
03:05:37 <[exa]> btw if that's an error message please pastebin it, I can't read images here
03:05:51 <[exa]> ideally with the compiler command, if present
03:08:13 <gagbo> oh right it was just mostly to show the context. I don't think IÂ have the compilation command I'll try to change that
03:12:04 <gagbo> welp, apparently it was something else, trying to rebuild doesn't block on unix-time, sorry for the noise
03:12:47 <merijn> Why do you need unix-time anyway?
03:12:54 <merijn> Why not use time?
03:13:21 <merijn> It's the far more common (and thus better tested) package
03:17:05 <gagbo> I'm trying to use taffybar, not really my choice
03:17:30 <tomsmeding> gagbo: that "error" is really ghc misinterpreting the output of the preprocessor warning as an error
03:17:48 <tomsmeding> but it doesn't actually _treat_ it as an error, just print it like one
03:17:53 <gagbo> I see
03:18:22 <tomsmeding> if it was the fault of -Werror, you would've seen the C preprocessor throw an error, and see [-Werror=cpp] instead of [-Wcpp]
03:19:02 <tomsmeding> but that's kind of esoteric knowledge from the C-land that haskell programmers should (ahem) not need to deal with :p
03:20:18 <tomsmeding> gagbo: for finding out what exactly makes the build fail, I recommend passing -j1 to 'stack build'
03:20:46 <tomsmeding> (usually after first doing a couple of parallel builds to build all the non-failing packages, so only the failing one remains)
03:21:09 <tomsmeding> s/all/the topological prefix of/? how is that even called
03:23:08 <PacoV> Hello there
03:23:15 <Uniaika> salut PacoV 
03:24:54 <ski> tomsmeding : hm, maybe some lower (closed) subset
03:25:37 <PacoV> Hey, I'm looking for someone to move my hackage account to the uploader group? Is this possible ?
03:27:17 <PacoV> Account is under another name I can give via MP.
04:32:22 * hackage zydiskell 0.2.0.0 - Haskell language binding for the Zydis library, a x86/x86-64 disassembler.  https://hackage.haskell.org/package/zydiskell-0.2.0.0 (nerded)
06:02:53 * hackage rss-conduit 0.6.0.1 - Streaming parser/renderer for the RSS standard.  https://hackage.haskell.org/package/rss-conduit-0.6.0.1 (koral)
06:09:57 <halbGefressen> Hello, I want to solve sudokus. For that purpose, I tried to write a function that for a given sudoku returns every possible valid number placement option in form of another sudoku.
06:11:35 <halbGefressen> Now, how do I recursively apply this function with >>= until it either returns a valid sudoku or an empty clause? 
06:13:28 <Rembane> halbGefressen: That sounds really fun! What is the type of your function?
06:14:50 <ski> halbGefressen : should it, given a position, attempt to fill that position in every possible way ?
06:14:55 <halbGefressen> https://paste.gnome.org/pebsnonzq
06:15:11 <halbGefressen> Sudoku is the type [[Int]]
06:15:46 <Rembane> The implementation of the list monad should IIRC give you every possible Sudoku 
06:16:51 <halbGefressen> And if I manually bind advanceStep exactly n times to my sudoku where n is the number of 0s in the sudoku, it will return the solution or the empty list. Now how would I wrap this into a function using the do notation?
06:17:31 <merijn> tbh, [[Int]] is probably a bad datatype for sudoku. I'd probably use either "Array (Int, Int) Int" or "Map (Int, Int) Int"
06:17:45 <merijn> (that's not really an answer, but worth considering)
06:18:25 <halbGefressen> I know, actually it is part of a university homework challenge (normally I would do it with backtracking, but I just wanted to mess around a little :))
06:26:49 <kuribas> you know about this pearl?  https://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
06:27:16 <halbGefressen> Thanks, I'll definitely look into it!
06:27:37 <ski> halbGefressen : you have lots of useless/redundant nondeterminism
06:27:39 <kuribas> halbGefressen: if that solves your challenge, better try solving it first yourself :)
06:28:20 <ski> (also, your second `$' is useless. and you could move the `filter' guard into the list comprehension)
06:28:52 <kuribas> the interesting bit here is how they reduce the search space by reordering the operations
06:30:03 <kuribas> I benchmarked my CPS version of ExceptT on my parser library, and it gave me a 15% improvement :)
06:30:50 <kuribas> not that much, but still something, and completely for free :)
06:31:02 <ski> halbGefressen : eventually, every hole will have to be filled. it's not really useful to count filling A first, and then B, as generating separate solutions to filling B first, and then A. doing this results in duplicate solutions, and doing this *repeatedly* will cause an exponential blow-up
06:31:51 <halbGefressen> I know, thats exactly my problem
06:32:10 <ski> so .. "Don't do that, then !" ?
06:32:27 <halbGefressen> Thats my problem, I don't know how to do it in this manner xD
06:33:11 <halbGefressen> It can solve 2x2 sudokus, but with 3x3 it just computes into eternity
06:33:15 <ski> pick one location to fill in. don't use nondeterminism for that. (you still have nondeterminism for *how* you're filling it, of course), then continue from there
06:34:15 <kuribas> the solution to avoid combinatorial explosion is to prune *early*.
06:35:10 <ski> an improvment then would be to, if possible, pick a location for which there is only one way to fill it in. (or, even better, to pick a location that's impossible to fill, if that kind of situation is possible in your scheme. "fail earlier, fail fast" is the slogan, followed by "delay choices")
06:36:50 <halbGefressen> Would it be a good idea to implement the DPLL algorithm for SAT and then just reduce my sudoku to SAT?
06:37:29 <kuribas> that's cheating :)
06:37:57 <kuribas> but it would work
06:38:12 <ski> dunno what the DPLL algorithm is
06:39:42 <Feuermagier> how do I find the index of the first 0 in a [[Int]]?
06:39:54 <halbGefressen> It's basically an algorithm to determine a solution to a boolean term given its conjunctive normal form
06:40:13 <halbGefressen> ahh, another sudoku solver :)
06:40:39 <Feuermagier> halbGefressen, what are you doing here? :D
06:41:05 <ski> @type findIndex
06:41:06 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
06:41:28 <ski> hm
06:43:00 <Feuermagier> halbGefressen, take a look at https://en.wikipedia.org/wiki/Mathematics_of_Sudoku + http://www2.imm.dtu.dk/pubdb/edoc/imm5625.pdf
06:44:39 <kuribas> it's fairly trivial to turn a sudoku in something that a SAT solver can solve, but it's not interesting.
06:46:22 <Feuermagier> halbGefressen, if you want, you can throw AC-3 at it and then brute-force on. but you'll have to change your datatype to something more sensible (I'd probably take a Map)
06:47:06 <Feuermagier> halbGefressen, there's also https://wiki.haskell.org/Sudoku#Backtrack_monad_solver
06:47:20 <halbGefressen> yea, I read that a little as well
06:47:26 <halbGefressen> but i wanna do it myself haha
06:49:10 <ski> two observations that can be used to prune, inform the choices, are (a) there can't be duplicates in a row (/ column / block); (b) every value has to appear in a row (/ column / block). so, for each cell, you can keep track of the values which could still conceivably appear in it (not being forbidden by (a)), and if a value can only occur in one of the cells in a row (/ ...), then it must occur there
06:50:19 <Feuermagier> halbGefressen, If you are looking for the proper approach I suggest taking a look at chapter 6.1 of "Artificial Intelligence A Modern Approach" by Stuart Russell (page 378 for sudokus)
06:50:59 <ski> the latter (b) part can be generalized. if there are two cells (in the same row / ...) where only `3' and `5' can occur, then you can remove `3' and `5' from the possibilities from the other cells (in the same row / ...)
06:53:51 <ski> this can lead to a Constraint Programming (CP) approach to solving it, where each cell keeps track of a domain of possible values, and there are (a) and (b) constraints that, when a change (shrinking) occurs in the domain of one of the cells involved in the constraint, then (possibly) the constraint will propagate some further shrinking to some of the other cells in the constraint
06:54:27 <Feuermagier> since my question probably disappeared; how can i find the (y,x) index of an element in a 2d list? [[int]] -> int -> maybe (int,int)
06:55:16 <ski> then, after all constraints have propagated a change, you start looking for a cell to nondeterministically fill (e.g. a cell with a minimal number of possibilities)
06:56:23 * hackage servant 0.18.2 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.18.2 (maksbotan)
06:57:24 * hackage servant-server 0.18.2, servant-http-streams 0.18.2, servant-foreign 0.15.3, servant-docs 0.11.8, servant-client-core 0.18.2, servant-client 0.18.2 (maksbotan)
07:01:32 <ski> Feuermagier : well, one approach is to `zip' with indices, and then filter
07:02:38 <Feuermagier> ski, interesting; maybe elemIndex zipped with thew lists.
07:05:28 <Feuermagier> * Couldn't match expected type `[[Int]] -> Int -> Maybe (Int, Int)'
07:05:29 <Feuermagier>                   with actual type `Maybe a0'
07:05:38 <Feuermagier> ^why does this happen?
07:05:42 <ski> missing arguments ?
07:06:06 <Feuermagier> isn't my return Maybe (Int,Int)?
07:06:23 <Feuermagier> shouldn't i be able to just return nothing?
07:08:09 <ski> show code ?
07:08:23 <Feuermagier> findIndex :: [[Int]] -> Int -> Maybe (Int,Int)
07:08:24 <Feuermagier> findIndex = Nothing
07:08:40 <ski>   findIndex xss x = Nothing
07:09:07 <Feuermagier> *oh*
07:09:09 <Feuermagier> thx
07:09:27 <ski> (missing arguments, as i thought)
07:25:00 <Haskellovic> twoThirdsAverageWinners :: [(String, Int)] -> [String]
07:25:02 <Haskellovic> - snd (head xs)) = helper (tail xs) average ([] : fst (head xs)) (toPositiv (average - snd (head xs)))
07:25:49 <Haskellovic> Can someone tell me why the helper function expects this 
07:26:00 <Haskellovic> [([[String]], Int)]
07:26:04 <Haskellovic> for gs
07:26:35 <Haskellovic> when i want [(String, Int)
07:26:42 <Haskellovic> when i want [(String, Int)]
07:31:03 <Feuermagier> how can I "unpack" a maybe?
07:32:16 <geekosaur> usually with pattern matching
07:35:32 <Feuermagier> fromJust is what i needed. thx anyway!
07:36:08 <geekosaur> fromJust is rarely what you want
07:36:29 <geekosaur> at least if what you want includes your program not crashing
07:36:35 <Feuermagier> geekosaur, I already checked nothing earlier. It will not occur.
07:39:48 <hekkaidekapus> > maybe 0 (+ 1) <$> [Just 1, Nothing] -- Feuermagier
07:39:51 <lambdabot>  [2,0]
07:41:05 <Feuermagier> hekkaidekapus, what?
07:41:31 <hekkaidekapus> > fromMaybe 0 <$> [Just 1, Nothing]
07:41:33 <lambdabot>  [1,0]
07:41:53 <Feuermagier> I still have no idea what that does :D
07:42:00 <Feuermagier> what does <$> do?
07:42:08 <merijn> <$> is just fmap as operator
07:42:16 <merijn> and fmap for lists is just map
07:43:20 <hekkaidekapus> > map (+ 1) [5 .. 9]
07:43:22 <lambdabot>  [6,7,8,9,10]
07:43:26 <hekkaidekapus> > fmap (+ 1) [5 .. 9]
07:43:28 <lambdabot>  [6,7,8,9,10]
07:43:39 <hekkaidekapus> > (+ 1) <$> [5 .. 9]
07:43:41 <lambdabot>  [6,7,8,9,10]
07:43:50 <hekkaidekapus> > (+ 1) `map` [5 .. 9]
07:43:53 <lambdabot>  [6,7,8,9,10]
07:43:58 <hekkaidekapus> > (+ 1) `fmap` [5 .. 9]
07:43:59 <lambdabot>  [6,7,8,9,10]
07:47:22 <Feuermagier> I want to call a function with different arguments (1 to 10 for example). if it returns aomething else than an empty list, I want to short circuit return that. if it only returns an empty lists, I return that as well.
07:47:38 <Feuermagier> I'm sure there's a really elegant way to do this
07:48:23 <hekkaidekapus> Feuermagier: Show us what you wrote so far.
07:48:36 <hekkaidekapus> @where paste -- Feuermagier
07:48:36 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
07:49:16 <Feuermagier> hekkaidekapus, sec, i'll need to formulate a simple example.
07:49:30 <hekkaidekapus> Take your time.
07:52:22 <ski> @let asumMap :: (Foldable t,Alternative i) => (a -> i b) -> (t a -> i b); asumMap = (getAlt .) . foldMap . (Alt .)
07:52:23 <lambdabot>  Defined.
07:52:37 <ski> @let label :: (Traversable t,Enum n) => n -> t a -> t (n,a); label n = (`evalState` n) . traverse (\a -> (,a) <$> get <* modify succ)
07:52:39 <lambdabot>  Defined.
07:52:46 <ski> > label [2,3,5,7]
07:52:48 <lambdabot>  error:
07:52:48 <lambdabot>      Ambiguous occurrence âlabelâ
07:52:48 <lambdabot>      It could refer to
07:52:53 <ski> > L.label [2,3,5,7]
07:52:55 <lambdabot>  error:
07:52:55 <lambdabot>      â¢ No instance for (Typeable a0)
07:52:55 <lambdabot>          arising from a use of âshow_M582103790923675916012806â
07:52:57 <Feuermagier> https://pastebin.com/QuDwgYk9 I want to call this function with the ints 1 to 10. If it returns something else than the empty list, I want to short-circuit return that. If I never get a result, I want to return an empty list as well. hekkaidekapus 
07:53:03 <ski> oh, right ..
07:53:03 <merijn> ski: More efficiently implemented as "getLabel . coerce fold" ;)
07:53:11 <ski> > label 0 [2,3,5,7]
07:53:14 <lambdabot>  error:
07:53:14 <lambdabot>      Ambiguous occurrence âlabelâ
07:53:14 <lambdabot>      It could refer to
07:53:32 * ski sighs
07:53:34 <ski> > L.label 0 [2,3,5,7]
07:53:36 <lambdabot>  [(0,2),(1,3),(2,5),(3,7)]
07:53:43 <ski> @let findIndexElem :: Alternative i => (a -> i b) -> ([a] -> i (Int,b)); findIndexElem p = asumMap (\(i,x) -> (i,) <$> p x) . label 0
07:53:44 <lambdabot>  .L.hs:167:56: error:
07:53:44 <lambdabot>      Ambiguous occurrence âlabelâ
07:53:44 <lambdabot>      It could refer to
07:53:49 <ski> @let findIndexElem :: Alternative i => (a -> i b) -> ([a] -> i (Int,b)); findIndexElem p = asumMap (\(i,x) -> (i,) <$> p x) . L.label 0
07:53:51 <lambdabot>  Defined.
07:53:53 <ski> > (findIndexElem . findIndexElem) (guard . (0 ==)) [[1,2,3],[4,5,0],[0,8,9]] :: Maybe (Int,(Int,()))
07:53:55 <lambdabot>  Just (1,(2,()))
07:53:58 <ski> > (findIndexElem . findIndexElem) (guard . (0 ==)) [[1,2,3],[4,5,0],[0,8,9]] :: [] (Int,(Int,()))
07:54:01 <lambdabot>  [(1,(2,())),(2,(0,()))]
07:55:03 <hekkaidekapus> Feuermagier: Guards work with boolean expressions.
07:55:20 <merijn> hekkaidekapus: With patterns too :p
07:55:25 <ski> Feuermagier : `findIndexElem' ^ is another way to do it
07:55:50 <Feuermagier> hekkaidekapus, can I generate the range of indexes to call with on the fly?
07:56:01 <hekkaidekapus> merijn: Ok. But that `otherwise []` is not ok :p
07:56:03 <merijn> > let {foo x | Just y <- x = show y; foo _ = "Nothing" } in foo (Just 2)
07:56:05 <lambdabot>  "2"
07:56:59 <ski> merijn : this `getLabel' is from ?
07:57:14 <hekkaidekapus> Feuermagier: Generating indexes on the fly would better be done with zip.
07:57:43 <merijn> ski: eh, getAlt I meant :)
07:57:51 <Feuermagier> ski, i found https://codereview.stackexchange.com/questions/58954/getting-the-index-x-y-of-a-char-in-a-2d-list-in-haskell
07:58:33 <hekkaidekapus> Oh, wait! Reading the backlog, I see you have been at this for a while already. And ski has already answered the âgenerate indexesâ question. :)
07:58:42 <ski> merijn : oh, you meant `asumMap'/`altMap'/`foldMapA'
07:58:51 <Feuermagier> hekkaidekapus, but do those short circuit?
07:58:51 <merijn> yeah
07:59:22 <ski> (i thought you meant my `label')
07:59:47 <hekkaidekapus> ski: Is your findIndexElem a follow-up to an earlier convo with Feuermagier?
07:59:54 <ski> yes
08:00:00 <Feuermagier> yes
08:00:12 <hekkaidekapus> Feuermagier: Read what ski just wrote.
08:00:43 <ski> (from an hour, to an hour and a half, ago)
08:00:46 <hekkaidekapus> (And ask questions if you get stuck.)
08:01:05 <Feuermagier> hekkaidekapus, i have that problem with the indexes solved
08:01:28 <hekkaidekapus> Feuermagier: No, take a step back and follow skiâs code.
08:02:21 <ski> hekkaidekapus : i was curious about how to express a solution to the problem, in terms of composing a function with itself, in order to deal with the nested lists. (similarly to `map . map',`mapM . mapM',`mapM_ . mapM_',`zipWith . zipWith',`liftA2 . liftA2',&c.)
08:03:29 <ski> Feuermagier : `label n' is just a generalization of `zip [n ..]', for the fun of it. you can use plain `zip' instead, since you're dealing with lists anyway
08:03:53 <hekkaidekapus> ski: heh I guess that will be a bit hard to explain given that there was a hiccup with (<$>) :p
08:04:52 <Feuermagier> ski, are we still at the index-function or on my "find first valid result from function" problem? - or are they both similar in a way I miss?
08:06:28 <dminuoso> Is there an ExceptT but with Cont inside?
08:07:10 <dminuoso> I want to add exceptions to this monad, but with a a higher guarantee of fusion..
08:07:59 <dminuoso> Or should I rather just use ContT with callCC, and hide this behind newtypes?
08:09:01 <ski> Feuermagier : the former. i haven't really thought about the latter, yet
08:12:00 <ski> dminuoso : hm .. maybe something like `newtype ExceptT e m a = MkExceptT (forall o. (e -> m o) -> (a -> m o) -> m o)' ?
08:12:19 <dminuoso> ski: Yeah
08:12:30 * ski notes that this is invariant in `m'
08:13:00 <dminuoso> What do you mean by invariant here?
08:13:09 <dminuoso> I mean, I understand the meaning of it, just not the implication you are trying to make
08:13:43 <Feuermagier> ski, i refined my example a bit, but still dont have a solution: https://pastebin.com/4MdnjxhK I want "extract from example" to return the first element that "example" returns, which is unequal to 0. the [Int] it gets are the Integers to try.
08:14:10 <Feuermagier> if all inputs fail, we just return 0
08:15:10 <geekosaur> what happens if the first element succeeds? (which would be 0)
08:15:14 <siwica> I am getting back into Haskell programming and just realized that Intero for Emacs does not seem to be maintened anymore. Which Emacs-mode/IDE are people using nowadays to write Haskell? Anything you guys can recommend?
08:15:23 <geekosaur> this seems like a time to use Maybe
08:15:59 <Feuermagier> geekosaur, if the first element piped into "example" gives a result unequal to 0, we return the acquired result
08:16:20 <merijn> siwica: Almost all IDE-like effort has been consolidated into haskell-language-server pretty much
08:16:42 <ski> Feuermagier : oh, seems `asumMap' also happens to be the answer to your second question ;)
08:16:44 <Feuermagier> siwica, IntelliJ with Haskell plugin performas adequate for me
08:17:14 <Feuermagier> ski, enlighten me
08:18:28 <siwica> merijn: Alright, thank you! Never did anything with language-server. Guess I'll have to take a look.
08:18:37 <siwica> Anything people can recommend for Emacs in particular?
08:19:26 <merijn> siwica: I'd recommend looking into the language server stuff anyway, because IMO LSP is pretty much the only sane way forward :p
08:20:34 <ski> > let example 7 = [7]; example _ = [] in fromMaybe [] (asumMap ((\xs -> if null xs then Nothing else Just xs) . example) [1 .. 10])
08:20:38 <lambdabot>  [7]
08:20:39 <ski> > let example 7 = [7]; example _ = [] in fromMaybe [] (asumMap ((\xs -> if null xs then Nothing else Just xs) . example) [1 .. 5])
08:20:43 <lambdabot>  []
08:20:49 <siwica> merijn: Yeah, I was told so two years ago, but never really listened, unfortunately :)
08:20:55 <ski> Feuermagier ^
08:21:02 <maerwald> merijn: yes, but in the end... the problems I have with language linters etc since the rise of LSP have doubled as compared to the era before
08:21:24 <merijn> maerwald: I don't really have any issues, tbh
08:21:33 <merijn> Depends on the language, I suppose
08:21:52 <Feuermagier> ski, <B
08:22:07 <ski> > let example 7 = 7; example _ = 0 in fromMaybe 0 (asumMap ((\x -> if x == 0 then Nothing else Just x) . example) [1 .. 10])
08:22:09 <lambdabot>  7
08:22:10 <ski> > let example 7 = 7; example _ = 0 in fromMaybe 0 (asumMap ((\x -> if x == 0 then Nothing else Just x) . example) [1 .. 5])
08:22:12 <lambdabot>  0
08:22:13 <maerwald> I tried LSP over the years again and again (for multiple languages) and in the end I just disabled it. I end up spending more time on the tooling than on coding when I use it
08:25:05 <ski> Feuermagier : `asumMap' encodes "try one thing after another". used with `Maybe', it'll abort on the first successful try
08:25:33 <Feuermagier> ski, it is exactly what I need, but what package is that from?
08:29:50 <dminuoso> ski: Does the invariance of m have any impact? I mean in case of `ContT m a`, it's also invariant in m. 
08:32:31 <Feuermagier> ski, found the package. How do you even find these functions?
08:33:14 <hekkaidekapus> @hoogle asumMap
08:33:15 <lambdabot> Relude.Foldable.Fold asumMap :: forall b m f a . (Foldable f, Alternative m) => (a -> m b) -> f a -> m b
08:33:47 <hekkaidekapus> But the one ski used is defined a few lines above.
08:33:55 <hekkaidekapus> (In lambdabot)
08:34:55 <hekkaidekapus> So, best to scroll up (again!) and take another look at skiâs code :d
08:35:07 <Feuermagier> is there something like a fromJust with expectOrElse?
08:35:52 <ski> Feuermagier : hm, i guess <https://hackage.haskell.org/package/relude-0.7.0.0/docs/Relude-Foldable-Fold.html#v:asumMap>. but it's also available as <https://hackage.haskell.org/package/fused-effects-1.1.0.0/docs/Control-Effect-NonDet.html#v:foldMapA> and as (in deprecated `util') <https://hackage.haskell.org/package/util-0.1.17.1/docs/Util.html#v:altMap>
08:36:32 <ski> (also, <https://hackage.haskell.org/package/relude/docs/Relude-Foldable-Fold.html#v:foldMapA>,<https://hackage.haskell.org/package/util/docs/Util.html#v:foldMapA> does something different)
08:37:56 <hekkaidekapus> @where hoogle
08:37:56 <lambdabot> http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle â See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
08:38:39 <ski> Feuermagier : "How do you even find these functions?" -- well, it's a combinator which i've found myself wishing was defined in `Control.Applicative' or `Data.Monoid' or something, already. i hoogled around a little bit to see what people had called it, and decided i probably liked the `asumMap' name most
08:38:56 <hekkaidekapus> Feuermagier: Use hoogle (the second URL in ^) to search for exact names or type signatures.
08:39:32 <hekkaidekapus> You can also build it locally or talk to lambdabot.
08:39:46 <hekkaidekapus> @hoogle (Foldable f, Alternative m) => (a -> m b) -> f a -> m b
08:39:47 <lambdabot> Util altMap :: (Alternative p, Foldable f) => (a -> p b) -> f a -> p b
08:39:47 <lambdabot> Relude.Foldable.Fold asumMap :: forall b m f a . (Foldable f, Alternative m) => (a -> m b) -> f a -> m b
08:39:47 <lambdabot> Control.Effect.NonDet foldMapA :: (Foldable t, Alternative m) => (a -> m b) -> t a -> m b
08:41:06 <ski> dminuoso : `ExceptT e' is an `MFunctor', but `ContT o' isn't. the CPS version of `ExceptT e' above can't be, either. so it would fail a "drop-in replacement" test, if you care about `mmorph' stuff
08:42:11 <Feuermagier> ski, can you paste again how you defined that function?
08:42:27 <ski> <ski> @let asumMap :: (Foldable t,Alternative i) => (a -> i b) -> (t a -> i b); asumMap = (getAlt .) . foldMap . (Alt .)
08:43:14 <ski> that uses `Alt' from `Data.Monoid'
08:43:32 <Feuermagier> interesting. thx!
08:44:04 <ski> @hoogle (b -> m c) -> (a,b) -> m (a,c)
08:44:04 <lambdabot> Data.Tuple.Extra secondM :: Functor m => (b -> m b') -> (a, b) -> m (a, b')
08:44:05 <lambdabot> Extra secondM :: Functor m => (b -> m b') -> (a, b) -> m (a, b')
08:44:05 <lambdabot> Control.Functor.HT mapSnd :: Functor f => (b -> f c) -> (a, b) -> f (a, c)
08:46:51 <ski> `\(i,x) -> (i,) <$> p x' from `findIndexElem' above could be the pointless `uncurry ((. p) . fmap . (,))', or simply `secondM p'
08:47:24 <Feuermagier> ski, where is that "Alternative" from?
08:48:12 <Feuermagier> the first result on hoogle is from quickcheck
08:48:19 <ski> (.. but i figured i'd preferably not make it pointless to that extent, in my definitions above, in the interest of it being more intelligible)
08:48:26 <ski> @index Alternative
08:48:26 <lambdabot> Control.Applicative
08:50:03 <ski> dminuoso : .. hmm, i wonder whether (co)yonedaing it would help with keeping it covariant
08:50:14 <Feuermagier> @index Alt
08:50:14 <lambdabot> Data.Monoid
08:50:47 <ski> (`@index' has a limited database, iirc. but it can sometimes be useful)
08:50:55 * tomsmeding (hmm, 'yonedaing')
08:53:42 <Feuermagier> ski, I have some kind of bug with the import of "Alt": i do "import Data.Monoid (getAlt, Alt)", but I get: * Data constructor not in scope: Alt :: i b -> Alt i b
08:53:42 <Feuermagier>     * Perhaps you want to add `Alt' to the import list in the import of
08:53:43 <Feuermagier>       `Data.Monoid'
08:54:06 <tomsmeding> import Alt(..)
08:54:23 <tomsmeding> meaning write "import Data.Monoid (getAlt, Alt(..))"
08:54:41 <Feuermagier> oh, thx! - what does that syntax mean?
08:54:44 <ski> or `Alt (Alt,getAlt)' (or `Alt (..)')
08:54:47 <tomsmeding> as you wrote it, the "Alt" there is the _type_ Alt; appending (..) also imports the constructors of the type
08:55:17 <tomsmeding> which you can indeed also list individually as ski did
08:55:27 <tomsmeding> (well, constructors and record accessor functions)
08:56:22 <ski> (same thing is used to import a type class, with methods)
08:57:13 * hekkaidekapus whispers, âPunning is a misfeatureâ but is not ready for a flamewar ;)
08:57:31 <ski>   newtype ExceptT e m a = MkExceptT (forall n o. Monad n => (forall x. m x -> n x) -> (e -> n o) -> (a -> n o) -> n o)  -- dminuoso, something like this. (haven't checked whether that `Monad m' is required)
08:58:03 * ski doesn't like naming the data constructor the same as the type constructor, fwiw ..
08:58:30 <hekkaidekapus> Ah, Iâm not that alone :D
08:59:18 <ski> i tend to use `data Foo = MkFoo ...'. iirc monochrom has suggested `FooOf'
08:59:48 <hekkaidekapus> Prefix vs Suffix.
09:00:15 <ski> (also `unFoo'/`runFoo'/`getFoo')
09:00:25 <hekkaidekapus> The former is better for grepping, I guess. I usually use the latter.
09:00:35 <ski> (oh, also `appFoo')
09:02:23 <tomsmeding> also the run*/exec*/eval* mess that mtl gives you
09:02:25 <ski> (punning for record fields (when matching/constructing) is another thing. but the punning present between the fields and the field extraction/selection/projection functions is also bad)
09:03:08 <ski> yea, although the `execFoo' and `evalFoo' don't tend to be raw projections, that i know of
09:04:28 <ski> (also, `Control.Monad.Cont' ought to export `evalCont = (`runCont` id)' and `evalContT = (`runContT` pure)' ..)
09:04:28 <hekkaidekapus> NoFieldSlectors is being implemented as we speak. Wholesale banning projections will be easier with that.
09:05:08 <ski> yes, i've got the memo for that :)
09:05:50 <ski> i think i'd possibly like an alternative syntax for projections, e.g. like in the MLs
09:06:32 <hekkaidekapus> That ship has also sailed for now, the community settled on RecordDotSyntax.
09:06:53 <ski> so, instead of `x pt' : `#x pt' (SML) or `pt .x' (OCaml), or something along those lines
09:07:16 <c_wraith> RecordDotSyntax is an abomination that we really didn't need
09:07:29 <ski> (yea, i recall looking at `RecordDotSyntax', and not being particularly happy about it)
09:07:44 <hekkaidekapus> c_wraith: No argument from me :D
09:08:14 <ski> (the postfix is nice. yet another overloading of the dot is not)
09:08:23 * hekkaidekapus guesses we are in the âlooserâ camp ;)
09:08:48 <tomsmeding> is RecordDotSyntax the intended alternative syntax for projections if you enable NoFieldSelectors?
09:09:58 <hekkaidekapus> tomsmeding: If Iâm not mistaken, all new record extensions are being implemented so that they interact well with each other.
09:10:00 <ski> (the postfix would be especially nice with "message-dispatching"/"copattern" syntax)
09:10:19 <tomsmeding> hekkaidekapus: that's what one would hope :p
09:10:33 <c_wraith> NoFieldSelectors is amazing for generic-lens, so I'm happy with it
09:11:09 <hekkaidekapus> tomsmeding: I have the bookmark, hooray! <https://gitlab.haskell.org/ghc/ghc/-/issues/18598>
09:11:33 <merijn> c_wraith: NoFieldSelectors is great for having records in sumtypes too
09:12:34 <tomsmeding> hekkaidekapus: ah those three extensions are the ones we're getting?
09:13:01 <merijn> tomsmeding: The intention of NoFieldSelectors is "no projections"
09:13:08 <hekkaidekapus> Yep, you get one, you loose one too ;)
09:13:15 <tomsmeding> is it, or is it "allow alternative projections"?
09:13:29 <merijn> tomsmeding: You can already write your own projections
09:13:42 <tomsmeding> okay fair, s/alternative/alternative auto-generated/
09:13:53 <merijn> tomsmeding: The problem with field selectors is that you basically can't safely use records for sumtypes
09:14:01 <merijn> tomsmeding: Since your projections will be partial
09:14:07 <tomsmeding> very true, but they're sometimes handy for pure product types
09:14:18 <merijn> Which sucks, because there are many reasons to want record syntax for constructing/destructing even for sum types
09:14:59 <tomsmeding> mind, I'm not arguing _against_ any of this, just trying to understand the intention :p
09:15:21 <merijn> The intention is "both"
09:16:14 <tomsmeding> makes sense
09:21:45 <sondr3> I'm writing a parser with megaparsec and I'm having some trouble getting a part of it to work; I want to parse multiple lines either to EOF or untill a line begins with a certain sequence of chars
09:23:52 <sondr3> Right now I have `T.pack <$> many anySingle <* notFollowedBy (string b <|> string ("\n" <> b))` but it still includes the `b` in the parsed text
09:51:16 <tomsmeding> sondr3: not very familiar with megaparsec (only parsec), but this would be a use for manyTill, right?
09:51:45 <tomsmeding> also is megaparsec's `string` fixed in that it either succeeds as a whole or fails as a whole? With parsec you have to write `try (string b)`
09:51:58 <merijn> This parser looks rather weird anyway
09:52:09 <merijn> "many anySingle" will just literally eat all your input
09:52:16 <merijn> Which can't be what you intended
09:53:10 <tomsmeding> (also, your usage of <|> suggests that you don't know whether anySingle consumes the final newline or not; if it does, use `string b`, otherwise use `string ("\n" <> b)` :p)
09:53:28 <sondr3> yeah, it's even worse now, I haven't been able to figure out how to write a "read anything unless the line starts with 'blah'"
09:53:32 <tomsmeding> (oh but it must, because otherwise it doesn't work at all)
09:53:54 <tomsmeding> sondr3: `manyTill anySingle (lookAhead (string b))` ?
09:54:49 <sondr3> tomsmeding: THANK YOU, that worked
09:55:10 <merijn> tomsmeding: I think lookahead consumes input on failure, though? Which may or may not be relevant
09:55:13 <tomsmeding> 'many' iterates until it sees input that its argument does not parse
09:55:44 <tomsmeding> merijn: correct, but perhaps that doesn't matter here because megaparsec's `string` is really parsec's `try . string`?
09:56:04 <tomsmeding> though I wouldn't know :p
09:56:39 <tomsmeding> sondr3: if you get trouble with lines that start with a prefix of `b`, try using `try (string b)` instead of `string b`
09:57:30 <tomsmeding> sondr3: as I said, 'many' iterates until its argument fails to parse, so for 'many' to stop consuming input you'll have to make its argument fail
09:57:43 <tomsmeding> you didn't, you applied the stopping criterion "outside" the 'many'
09:58:22 <tomsmeding> so I expect `many (notFollowedBy (string b) >> anySingle)` to work too, but just use `manyTill` :p
09:58:25 <sondr3> Yeah, I kinda knew that but got desperate when nothing worked x)
09:59:43 <sondr3> Thanks a lot, I'm still trying to wrap my head around monadic parsers
10:00:19 <merijn> sondr3: Have you read the Real World Haskell chapter on parsec?
10:00:30 <merijn> sondr3: The high level gist/design should be basically the same
10:00:55 <tomsmeding> ah I see that megaparsec's `string` is indeed parsec's `try . string` merijn 
10:01:00 <tomsmeding> https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec.html#v:tokens
10:01:05 <sondr3> No, I've followed markkps tutorial on megaparsec, I should probably take a look
10:01:39 <tomsmeding> sondr3: that means that you won't have to do `try (string b)`, just disregard that :)
10:01:43 <tomsmeding> in parsec you do
10:08:52 <maerwald>  yeah, string parsers in megaparsec backtrack automatically
10:08:54 <maerwald> it's confusing
10:09:33 <maerwald> still find attoparsec API to be the cleanest
10:10:15 <koz_> maerwald: Because attoparsec backtracks everything?
10:10:20 <maerwald> yeah
10:15:51 <hekkaidekapus> Since weâre on the parsing topic, let me shamelessly plug âA Typed Recursive Ascent-Descent Backend for Happyâ <https://pp.ipd.kit.edu/uploads/publikationen/knothe20bachelorarbeit.pdf>. I find that very cool :P
10:16:21 <hekkaidekapus> And we have a pull request, folks! <https://github.com/simonmar/happy/pull/174>
10:23:45 <boxscape> hmm how come with -XTypeOperators, we can use operators both for type constructors and values, but type constructors still can't use lowercase identifiers?
10:24:03 <boxscape> iow is it just for historical reasons or is there some thought behind it?
10:24:34 <tomsmeding> because then they look like type variables?
10:24:59 <boxscape> but doesn't the same argument apply if you type `data a ^^^ b`, tomsmeding?
10:25:08 <boxscape> or wait
10:25:09 <boxscape> I misread
10:25:11 <boxscape> you're right
10:25:16 <boxscape> thanks :)
10:25:25 <tomsmeding> :)
10:26:10 <tomsmeding> nice operator though, ^^^; I wonder what it means
10:26:28 <koz_> The Chernobyl cat operator.
10:27:11 <tomsmeding> most appropriately used in prefix form, as (^^^) ?
10:27:54 <ski> boxscape : it used to be that infix type operators had to start with a `:'. otherwise they'd be infix type variables (e.g. `second :: Arrow (~>) => (b0 ~> b1) -> ((a,b0) ~> (a,b1))')
10:28:16 <boxscape> ski oh, interesting, I just tried to see if operators can be type variabless
10:28:27 * ski misses being able to do that
10:28:54 <boxscape> I suppose the effort to unify the term and type levels should bring that back if/when it happens
10:28:57 <ski> s/infix type operators/infix type constructor operators/
10:31:28 <ski> (i didn't really think having to start the type constructors with `:' was that onerous .. but i guess some people did ?)
10:32:35 <boxscape> I imagine the major reason for the change was so you can do it in type family names rather than type constructor names
10:32:44 <geekosaur> yeh, they didn't like to think of e.g. :+
10:35:09 <sunmaster> Hello all together
10:36:08 <boxscape> hi
10:36:39 <sunmaster> Is there any - more or less - easy description how the type derivation in haskell works? 
10:39:57 <sunmaster> I know that there is a description using the formal language of semantics.
10:43:39 <gehmehgeh> hmm, is it just me or doesn't https://hackage.haskell.org/package/hood build with cabal? "could not resolve dependencies" it says
10:51:53 <hekkaidekapus> gehmehgeh: It depends on the GHCâs version youâre using.
10:52:51 <hekkaidekapus> That package hasnât been updated in a while, so it doesnât build with the latest versions but there are build plans for old GHCs.
11:02:33 <gehmehgeh> hekkaidekapus: hmm, thanks
11:03:16 <hekkaidekapus> What does `ghc --version` output on your side?
11:08:01 <geekosaur> more precisely the dependency FPretty has no version for later than base 4.11, which corresponds to ghc 8.4 I think
11:10:53 * hackage ngx-export-tools-extra 0.5.9.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.9.0 (lyokha)
11:11:08 <hekkaidekapus> Yeah, I havenât digged that far but what you say is consistent with <https://matrix.hackage.haskell.org/#/package/hood> and the `tested-with:` indication in hood.cabal.
12:01:08 <hekkaidekapus> maerwald: Have you seen this? <https://taylor.fausak.me/2020/11/22/haskell-survey-results/>
12:01:28 <f-a> magnifique
12:01:41 <hekkaidekapus> hahahaâ¦
12:02:16 <f-a> for real, I plan to do some basic cluster analysis and I was waiting for the .csv
12:02:22 <hekkaidekapus> f-a: TrÃ¨s intÃ©ressantÂ ! Why the French, though?
12:03:15 <hekkaidekapus> f-a: First task in your analysis: drop interpolation when the data is dirty.
12:04:22 <merijn> I'm the 1% :>
12:04:33 <merijn> (that uses mercurial...)
12:05:07 <hekkaidekapus> merijn: No, the % is measleading.
12:06:30 <merijn> hekkaidekapus: How so?
12:06:37 <hekkaidekapus> You have to add the caveat that itâs in the subset of lost data.
12:07:38 <hekkaidekapus> Anyway, Pijul and Mercurial might have equal numbers of users. Maybe they are the same.
12:08:49 <merijn> I fail to see how that's relevant?
12:09:10 <f-a> mhhh, headers changed
12:09:43 <gentauro> geekosaur: hey, you tip worked yesterday with regard of hidding `xmobar` in one of my workspaces (the one where I run win10 from VirtualBox) :-)
12:09:49 <texasmynsted> Far lower number than I expected for "Which installation methods do you use for your Haskell compiler?" = "ghcup"
12:10:14 <maerwald> that was multiple-choico too no?
12:10:24 <maerwald> so data loss too
12:10:39 <hekkaidekapus> merijn: Basically, 0.8K of answers were discarded wherever there were multiple choices. So, when you say 1%, is it out of the ~1.4K people that took the survey?
12:11:35 <merijn> When I say 1% I say "the number in the graphs" without any further generality
12:11:42 <hekkaidekapus> heh
12:11:55 <f-a> hekkaidekapus: I suppose/suspect you are Taylor Fausak yourself?
12:12:13 <hekkaidekapus> f-a: Nope.
12:12:36 <hekkaidekapus> Just a statistical pedant ;)
12:12:45 <f-a> ok, I was going to ask some que- even better hekkaidekapus 
12:12:56 <maerwald> well, it basically renders this years result unusable for most purposes
12:13:47 <tomsmeding> 2020 strikes again
12:13:51 <hekkaidekapus> maerwald: Agreed. IMO, there should have been two pages, one with the full data and another one for â¦ playing around.
12:14:00 <shapr> maerwald: make your own survey next year?
12:14:43 <maerwald> shapr: hmm, I wouldn't want a competing one though. I think channeling makes it more representative
12:14:59 <f-a> both open ended are not there too
12:15:20 <wz1000> why is ApplicativeDo so low in the list of language extensions?
12:15:40 <maerwald> because it's confusing as hell?
12:15:48 <shapr> not enough advertising? :-D
12:15:57 <wz1000> how is it confusing?
12:16:13 <maerwald> have you seen the compile errors?
12:16:34 <wz1000> do you have an example?
12:16:38 <monochrom> ApplicativeDo is too dumb. So it's pretty fragile, very tiny details you thought unimportant is important for it.
12:17:35 <monochrom> Or at least that's my hypothesis. I never know.
12:17:51 <wz1000> PolyKinds being so much higher than TypeInType is pretty weird
12:18:12 <merijn> Why? PolyKinds is reasonable, TypeInType is an abomination unto the lord >.>
12:19:02 <wz1000> It is pretty much the same thing now, isn't it?
12:19:10 <texasmynsted> Interesting that Idris and Agda were not mentioned in the survey as "other languages"
12:19:30 * texasmynsted shurg
12:19:36 <wz1000> merijn: yeah, user guide says its PolyKinds + DataKinds
12:19:40 <MarcelineVQ> People who also answer "Strongly Agree" to "I can easily reason about the performance of my haskell code" probably would also want ApplicativeDo enabled by default.
12:19:52 <MarcelineVQ> With all the implied subtext there that you might want to infer.
12:20:02 <texasmynsted> I am surprised that so many Haskell users are from the USA
12:20:16 <monochrom> There is a difference between writing {-# LANGUAGE TypeInType #-} and GHC doing it at a hidden stage but doesn't expose it as a source-code-level rule.
12:20:30 <tomsmeding> texasmynsted: I think the other ones just don't participate as much in the english-language online community
12:20:42 <texasmynsted> oh. yes I did not think of that
12:20:48 <hekkaidekapus> shapr: âmake your own survey next year?â What do you think about people working together as suggested in <https://lobste.rs/s/xgquet/2020_state_haskell_survey#c_kaf6au>?
12:21:13 <shapr> that sounds even better
12:21:30 <texasmynsted> So many python users
12:21:42 <shapr> hekkaidekapus: in that same thread Taylor did mention it's just him doing the survey
12:22:00 <MarcelineVQ> I usually assume everyone who writes haskell professionally is in australia, everyone who complains about other haskeller's is in canada, and everyone who complains about haskell code is in germany.
12:22:31 <shapr> US Haskell jobs are increasing in the past year
12:22:35 <hekkaidekapus> shapr: Yes, I also saw you commented there. But Taylor did not really welcome working together with the proponent. 
12:23:04 <hekkaidekapus> (Since the offer was standing since last year.)
12:23:45 <shapr> Perhaps someone else could offer to take over the survey?
12:24:39 <texasmynsted> Wow. I would love a Haskell job. Ah the dream
12:25:49 <Iceland_jack> hello hello
12:26:00 <maerwald> wz1000: https://gitlab.haskell.org/ghc/ghc/-/issues/13511
12:26:04 <shapr> hi Iceland_jack
12:27:40 <maerwald> There was another case where strictness annotations are needed to make something build with ApplicativeDo, I forgot (because I never use it)
12:27:40 <Iceland_jack> o/
12:28:17 <texasmynsted> Iceland_jack: Nice nick
12:28:23 <Iceland_jack> oh thanks
12:28:29 <texasmynsted> Who is cooler than cool?
12:29:34 <merijn> Anyone with a GHC error mentioning them by name? ;)
12:31:07 <Iceland_jack> I used to find them by accident, now I can't find them on purpose
12:31:22 <maerwald> wz1000: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-patterns
12:34:47 <f-a> hekkaidekapus: what do you understand from the warning? is the .csv already clean or else? 
12:36:01 <hekkaidekapus> f-a: My opinion is that the questions where some data points are missing should have been removed from the results.
12:36:56 <hekkaidekapus> Instead, the resultsâ URL not only kept them, but went on to do interpolation (a linear one from the look of it).
12:37:03 <MarcelineVQ> merijn: that would never happen :>
12:37:58 <hekkaidekapus> f-a: And interpolating with such a high number of NAs is even worse than mixing dirty and clean data.
12:38:04 <monochrom> If you call yourself skolem, some error messages will mention your name.
12:38:27 <f-a> hekkaidekapus: sorry where do you see interpolation?
12:38:58 <hekkaidekapus> f-a: At <https://taylor.fausak.me/2020/11/22/haskell-survey-results/>
12:39:24 <f-a> oh you mean in the graphs, I see
12:39:30 <hekkaidekapus> Yep.
12:39:32 <f-a> > summary(s$startedAt) Min.               1st Qu.                Median
12:39:32 <f-a> "2020-10-31 18:23:10" "2020-11-01 17:17:21" "2020-11-02 05:46:14"
12:39:34 <lambdabot>  error:
12:39:34 <lambdabot>      Variable not in scope: summary :: t0 -> t2 -> b1 -> cerror: Variable not...
12:39:34 <lambdabot>      â¢ Data constructor not in scope: Min
12:39:38 <f-a> not sure they have been removed
12:43:49 <f-a> also there are surveys completed in 7 secondsâ¦ :s
12:46:06 <hekkaidekapus> f-a: I reckon you are playing around with the raw data. Have fun! I will not participate; if you want datasets to play with in Haskell, go to NCBI, OpenStreetMap or something :) (As I said, a statistical pedantâ¦)
12:46:48 <f-a> hekkaidekapus: worse than that, I am playing in R
12:46:57 <hekkaidekapus> heh
12:47:52 <hekkaidekapus> Thatâs self-torture then. R ships with a dozens datasetsâ¦
12:47:53 <f-a> but if we remove the offending answers (first 24 hours), what are your gripes?
12:49:14 <hekkaidekapus> The âNon Available Problemâ is my gripe. It has extensive literature and I donât fill digging for some refs now.
12:49:46 <hekkaidekapus> s/fill/feel/
12:50:10 <f-a> hekkaidekapus: well, I am using Gower distance, and (in some cases, of course) using asymmetric binaries to Â«solveÂ» the problem (if we are talking about the same problem, that is)
12:51:58 <hekkaidekapus> Have fun. Iâd like to pursue further, but that would be better suited for #haskell-offtopic and Iâm not going there.
13:17:16 <wz1000> Does anyone know what the different colors on the graphs mean in the survey?
13:18:21 <f-a> wz I suspect the pale violet means: including Â«buggedÂ» submissions
13:18:28 <f-a> * wz1000 
13:18:42 <maerwald> I think it means the previous year
13:19:11 <maerwald> But I think I'm wrong
13:19:31 <maerwald> Since single-select doesn't have two colors
13:19:40 <f-a> yeah that was my reasoning
13:20:02 <wz1000> In either case, is it cumulative? (As in, does pale violet include the dark violet as a subset?)
13:20:26 <f-a> it has to be, wz1000 
13:20:55 <f-a> as the spurious surveys can only add
13:24:01 <maerwald> the gender result is somewhat troubling
13:27:10 <maerwald> I think we're below average
13:28:31 <maerwald> "A National Public Radio report in 2013 stated that about 20% of all U.S. computer programmers are female.[39] In open source fields, only 10% of programmers are women."
13:29:30 <maerwald> Haskell scores 3%
13:30:10 <maerwald> Could be an objective for the haskell foundation
13:35:52 <merijn> maerwald: Well, there's confounding factors too, like "where is the survey circulated"
13:35:54 <maerwald> "I think that Haskell libraries provide a stable API." -- 42% agree, wat?
13:36:09 <merijn> maerwald: That depends which libraries you depend on :p
13:36:19 <maerwald> The only stable library must be Aeson
13:36:39 <maerwald> even servant constantly changes API
13:37:58 <maerwald> cabal hell, stack, nix-style builds etc are all because of this
13:53:57 <dminuoso> Let's say you have some ADT which can be serialized `data D = T Text | ...`, where serialization encodes Text into UTF8. The protocol format puts an upper limit of say 251 bytes of the resulting ByteString - is there even a point to having a separate validation routine here, or should I just add exceptions to my serializer?
13:54:35 <koz_> dminuoso: 'Resulting bytestring' means the whole thing, ro just the Text part?
13:55:15 <dminuoso> The Text part. All other things I can analyze beforehand (almost all other things have fixed size, and ByteString is easy enough to check its length)
13:55:55 <koz_> The only other thing I can think of is making some kind of 'BoundedText' newtype wrapper (or a builder I guess) to check the size in UTF-8 bytes as you go.
13:56:03 <koz_> But that sounds much more annoying.
13:56:14 <dminuoso> Well an UTF-8 backed string would be ideal :p
13:56:24 <koz_> dminuoso: There's a UTF-8 rope package I think?
13:56:31 <koz_> And short-text exists.
13:56:32 <dminuoso> https://hackage.haskell.org/package/text-utf8
13:56:36 <koz_> (though both have limited APIs)
13:56:46 <dminuoso> https://hackage.haskell.org/package/text-short
13:56:46 <koz_> s/short-text/ShortText/
13:56:48 <dminuoso> Mmm
13:56:51 <koz_> Yeah dat one.
13:56:59 <dminuoso> Actually, text-short might actually be interesting to look at
13:57:08 <koz_> It depends how much text manip you require.
13:57:15 <koz_> Its API for that is _much_ more limited.
13:57:23 <koz_> (though not necessarily out of necessity)
13:57:28 <monochrom> If the serializer throws exception, it will be hard to catch unless the serializer is in IO and pretty eager about text-too-long.
13:57:45 <koz_> monochrom: Yeah, that's a valid point actually.
13:57:53 <koz_> (I've been bitten by similar issues in the past)
13:58:14 <dminuoso> monochrom: what do you mean by "hard to catch"? If this is some ExceptT (possibly as a ContT variant), then that seems easy to catch in pure code
13:58:36 <monochrom> Oh, then that one is easy to catch. I keep forgetting ExceptT.
13:59:44 <dminuoso> I'd write this with my own `newtype ExceptT e m a = ExceptT { runExceptT :: forall o. (e -> m o) -> (a -> m o) -> m o) }`
14:00:10 <koz_> 'e -> m o' made me lol.
14:02:05 <monochrom> I normally don't separate out "isValid :: X -> Bool" and "useItAssumeValid :: X -> Y".  I simply have one single "use :: X -> Maybe Y".
14:02:09 <dminuoso> So the idea of ShortText is not bad, but since this is a library it could annoy users with dealing yet-another-text data type
14:02:36 * dminuoso wishes Text was UTF-8 backed
14:02:42 <koz_> dminuoso: You can always do a newtype wrapper which tracks the byte length as UTF-8 over Text, but it sounds annoying AF.
14:03:14 <dminuoso> I guess, deferring validation to serialization is my best bet.
14:03:25 <dminuoso> Unless I want to encode twice
14:03:31 <dminuoso> Or find elaborate tricks to memoize and reuse the result
14:03:40 <dminuoso> But that seems a bit more challenging
14:05:25 <Uniaika> What was the rationale for Text to be UTF-16 backed?
14:05:56 <Uniaika> also, how are we supposed to write "name-that-contains-hyphens"-adjective?
14:06:07 <Uniaika> do we remove the last hyphen?
14:06:13 <maerwald> "We're currently investigating the feasibility of changing Text's internal representation to UTF-8 and if you need such a Text type right now you might be interested in using the spin-off packages text-utf8 and text-short."
14:06:25 <Uniaika> maerwald: ð
14:06:35 <koz_> maerwald: They've been investigating this feasibility for precisely this end of forever now.
14:08:36 <monochrom> You can meaningful create a betting pool for: Which one of the following will happen first?  The next Haskell standard?  Text concluding its study of using UTF-8?
14:08:51 <koz_> monochrom: I think your best bet in such is not to play at all.
14:09:04 <monochrom> Yeah hehe
14:09:14 <Uniaika> haha
14:09:29 <maerwald> we'll have linear and dependent types way before that and still deal with String as default text type, yes
14:09:42 <monochrom> Here, I think this one is really worth playing:  The next Haskell standard?  Text concluding its study of using UTF-8?  Physicists unifying quantum mechanics and gravity?
14:09:55 <koz_> monochrom: My money is on that last one.
14:09:58 <Uniaika> same
14:10:04 <koz_> The first two involve considerably more cat-herding.
14:10:57 <dminuoso> My money is on the impossibility of a GUT.
14:11:14 <koz_> dminuoso: IANAP (I Am Not A Physicist).
14:11:39 <dminuoso> Neither am I, which is why I'm betting money.
14:11:54 <maerwald> Use your money for something useful instead
14:12:03 <monochrom> My experience with computer people is this.  They talked about "I wish for a LaTeX plugin for IRC" for 30 years.
14:12:21 <dminuoso> I spent some of it on this very fancy flipdot display out of a tram in Berlin.
14:12:39 <koz_> monochrom: That bikeshed colour _sure_ needs pinning down!
14:12:45 <Uniaika> fuck it
14:12:51 <Uniaika> I'm gonna bribe the haskell folks in charge
14:12:59 <Uniaika> they're all researchers anyway so they're paid peanuts
14:13:05 <monochrom> And to rub salt into the face of the insult, Pidgin actually achieved that. So they moved the goalpost to "but I mean for my IRC client, not Pidgin, who uses Pidgin?"
14:13:05 <Uniaika> a good 2 grands should suffice
14:13:06 <dminuoso> oh yeah, bribes can be a good way to spend money
14:13:11 <Uniaika> plus the promise of a tenure
14:13:14 <koz_> Uniaika: GLHF. I think the folks who are in charge of Text are full-time Haskell devs.
14:13:16 <Uniaika> that will get 'em in my pocket
14:13:21 <dminuoso> monochrom: Im not sure I'd *want* to use LaTeX for anything.
14:13:32 <Uniaika> koz_: I'm gonna suggest that we have non-blockchain positions open
14:13:33 <Uniaika> ;-D
14:13:35 <dminuoso> But given its domain, there aren't many alternatives...
14:13:43 <monochrom> Well yeah, I hung out in math channels back then.
14:13:54 <dminuoso> oh heh
14:13:55 <dminuoso> I see
14:14:21 <monochrom> There, people obnoxiously wrote "A \cap B" like it was more readable than "A union B".
14:14:58 <Uniaika> uh, I thought it was "cup"?
14:15:05 <monochrom> err, \cup, yeah
14:15:10 <koz_> Yeah. \cap is intersection.
14:15:13 <Uniaika> ah great I'm not mad
14:15:16 <Uniaika> *crazy
14:15:22 <dminuoso> Guess that actually proved monochrom's point.
14:15:25 <Uniaika> well, I'm a bit crazy, but not that kind
14:15:28 <merijn> I can write \cup and have it actually work :p âª
14:15:28 <monochrom> :)
14:15:49 <Uniaika> âª <- if I enter "cup" in Kitty's unicode selector, I get the union character
14:15:51 <merijn> Hijacked the CJK input to turn LaTeX into unicode :)
14:15:52 <Uniaika> this is pretty neat
14:15:58 <hekkaidekapus> merijn: Is that UTF8 or UTF16? :p
14:15:59 <Uniaika> merijn: you bloody monster
14:16:06 <dminuoso> So perhaps what we really need, is a suitable IRC client on iOS, so you can just draw these fancy symbols with your Apple Pencil.
14:16:16 <dminuoso> Right in the middle of your input buffer
14:16:35 <dminuoso> That seems far more reasonable than LaTeX in IRC.
14:16:39 <Uniaika> ludicrous
14:16:43 <Uniaika> preposterous
14:17:04 <maerwald> hmm, we need latex support on tomsmeding paste
14:17:25 <merijn> hekkaidekapus: Mu
14:18:06 <Uniaika> merijn: :D
14:19:53 <hekkaidekapus> Uniaika: On a serious note, do you think text should be handled differently than numbers?
14:19:55 * ski regularly writes things like âA âª Bâ in ##math
14:20:11 <Uniaika> ski: nice
14:20:23 <Uniaika> hekkaidekapus: I have no enlightened opinion 
14:20:27 <Uniaika> I mean
14:20:30 <hekkaidekapus> ski: You also do that here. :d
14:20:33 <Uniaika> I have a preference for grapheme clusters
14:20:44 <Uniaika> which I got to use in Elixir natively
14:20:49 <ski> hekkaidekapus : sometimes yes
14:22:08 <hekkaidekapus> Uniaika: Because we have a plethora of integer types, a handful of floating & complex numbers ones.
14:22:38 <Uniaika> hekkaidekapus: darling, in the end, everything is 1 and s0 ð
14:22:42 <Uniaika> *0s
14:22:44 <hekkaidekapus> And no one would think about a âcanonical, undisputableâ number type.
14:23:21 <hekkaidekapus> text (the package) is not even in the report.
14:24:14 <Uniaika> the report is worthless
14:24:20 <Uniaika> there, I said it
14:24:20 <hekkaidekapus> heh
14:25:01 <hekkaidekapus> Thatâs monochromâs bet: it is so worthless that it will never be updated again.
14:25:22 <monochrom> That is not my reason.
14:25:35 <hekkaidekapus> (kidding)
14:26:03 <monochrom> Err, on second thought, my reason still implies it's worthless.  So, just the tiny difference of "I can explain why it's worthless" but it's true.
14:27:19 <monochrom> Reason it's worthless: It handwaves both type checking ("oh it's just familiar HM plus type classes") and dynamic semantics ("oh it's just familiar non-strict lambda calculus")
14:28:03 <monochrom> Now, suppose you want to update it to, say, merely FlexibleContext.
14:28:15 <merijn> monochrom: Also, while there are things people want to add, nobody wants to do the actual work of standardising them to specify how it should work :p
14:28:50 <monochrom> You can't, because you have to explain the rules of FlexibleContext, and that requires the Haskell Report to have rules for even vanilla 2010 classes.
14:29:15 <monochrom> Well the Haskell Report contains no such rule, so you can't even add your extra rules.
14:29:49 <hekkaidekapus> Who was talking about clergy vs engineers last time? :P
14:31:19 <hekkaidekapus> If we go the rigourous report way, we end up with ML.
14:32:18 <Uniaika> I never understood FlexibleContext
14:32:31 <Uniaika> I don't understand most of the stuff that's required for MTL and stuff!
14:32:34 <Uniaika> fuck!
14:32:39 <sondr3> question about parsing, say you want to parse a path but it should not contain double slashes, do you make this illegal while parsing or do an error check after having read the whole path?
14:32:43 <Uniaika> I don't even understand my own purpose on this damned earth
14:33:27 <dminuoso> monochrom: The Haskell Report is surprisingly silent about some of the semantics of typeclasses.
14:33:53 * hackage elm2nix 0.2.1 - Turn your Elm project into buildable Nix project  https://hackage.haskell.org/package/elm2nix-0.2.1 (domenkozar)
14:34:15 <Uniaika> sondr3: do an error check after having parsed it all, so you can point on all the occurences of double-slashes, and not the first one that triggers a parsing failure
14:34:38 <hekkaidekapus> dminuoso: I see you are back at it again. :d
14:34:44 <dminuoso> hekkaidekapus: Heh!
14:35:00 <dminuoso> I've pondered about the issue for a real long while, and Im really not sure
14:35:23 <hekkaidekapus> dminuoso: What is it now, a month since you typeclasses exposed hunt?
14:35:39 <dminuoso> Well, it was only on and off...
14:35:42 * ski . o O ( "No SML below us" -- <https://schemers.org/Miscellaneous/imagine.txt> )
14:36:19 <hekkaidekapus> lol
14:38:19 <hekkaidekapus> I would say, as long as Haskell desugar to a language as principled as Core, let all loose innovations break loose in the surface syntax.
15:13:22 * hackage massiv 0.5.6.0 - Massiv (ÐÐ°ÑÑÐ¸Ð²) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.6.0 (lehins)
15:14:52 * hackage massiv-test 0.1.5 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.5 (lehins)
15:16:18 <dolio> Why do you need the Haskell report if it's just going to say that Haskell is GHC?
15:16:36 <monochrom> :)
15:21:11 <hekkaidekapus> lol See also the GHC20XX proposal.
15:21:52 <hekkaidekapus> Some people fork compilers, we fork the report.
15:24:30 <koz_> :t uncurry
15:24:31 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:34:59 <dolio> I mean, that probably makes sense, if it does what I think it does. Why not have some additional 'default language' levels that turn on a bunch of GHC stuff that is generally safe and useful, if that's the only tangible difference including them in the report makes?
15:35:26 <Lycurgus> since Algol, she's gotta have it
15:37:02 <Lycurgus> only lumpen langs don't have a report
15:45:03 <hekkaidekapus> dolio: â[GHC20XX] can be used as a language extension [â¦] but also as a language versions in places where Haskell98 or Haskell2010 is valid.â
15:46:25 <hekkaidekapus> Thatâs a low-key way of saying letâs throw away any attemps of making a new report geared to the âgreaterâ Haskell.
15:46:52 <dminuoso> hekkaidekapus: I thought everyone has given up on any further Haskell reports.
15:47:05 <hekkaidekapus> It seems so.
15:47:25 <hekkaidekapus> But thatâs betting on GHC being forever maintained.
15:47:26 <stu002> Is there an idiomatic way to create a haddock hyperlink to a local file in the library source tree? I'd like to refer to the README and other markdown files from the package haddock docs 
15:48:19 <dminuoso> hekkaidekapus: Well, what other implementation is keeping up with GHC extensions anyway?
15:48:38 <dminuoso> hekkaidekapus: I mean it's largely a management and manpower problem
15:48:53 <merijn> UHC implements a handful, iirc
15:49:18 <dolio> A new report isn't going to happen by making average users type more crap at the top of their files.
15:49:29 <dminuoso> hekkaidekapus: https://reasonablypolymorphic.com/blog/haskell202x/
15:49:31 <hekkaidekapus> Iâm not disputing the practical considerations of focusing on GHC right now.
15:49:58 <dminuoso> hekkaidekapus: Different people, different team, different job.
15:50:01 <dminuoso> It's not about "focusing on GHC"
15:50:36 <merijn> Haskell' needs a cat herder :p
15:51:24 <hekkaidekapus> If you are a compiler hacker in 2050, starting from a spec is far more interesting than reviving a 60 years old project.
16:05:59 <hekkaidekapus> dminuoso: I read the page you linked. The main point there is a need of Benefactor Dictator For Life. Letâs say that I am a bit skeptic. ;)
16:07:06 <dminuoso> And funding.
16:07:08 <dolio> I don't understand the argument. First off, it's inappropriate for a language standard to specify things down to an intermediate language level. That means every compiler has to make a ton of decisions exactly like GHC down to a very low level. If you just want documentation of what GHC does, there's already a bunch of papers and wikis and users guides that actually describe GHC already.
16:08:57 <hekkaidekapus> dolio: If you check the backlog, you will see that I expressed a few hours ago that I am not fond of rigourous standards.
16:09:43 <hekkaidekapus> My argument here is that taking over Haskell98 and Haskell2010 by a backdoor is a sneaky way of handling matters.
16:13:11 <hekkaidekapus> As to why very detailed standard are not my cup of coffee, things end up set in stone, drastic changes practically impossible.
16:14:10 <dminuoso> Unrelatedly, is there some cool trick to traverse over a data structure and fail if it has more than one target?
16:14:31 <dminuoso> Beyond the very obvious toList and pattern matching on its length
16:14:33 <dolio> Also, if you want an active standard process, you need to make new viable Haskell implementations. The standard process is useful as a way of codifying the commonalities of multiple implementations. That's how it originated. The standards process being useless is a symptom of GHC being the only viable choice.
16:16:05 <dminuoso> dolio: Perhaps, it could arguably also help in that regard. If we had a new vision of what "standard haskell" in the current state of haskell could be, it would reduce the willingness to flip on extensions and stick to "standard haskell" - perhaps opening up doors for newer implementations
16:16:12 <dminuoso> Right now hackage is extension wild west.
16:16:52 <dolio> You mean, like specifying a bunch of standard GHC extensions that are considered good enough to be mainstream?
16:16:57 <dolio> The 'sneaky' thing?
16:17:02 <hekkaidekapus> heh
16:17:19 <dminuoso> Not necessarily just that. But at least part of it, yes.
16:17:49 <dminuoso> Haskell has resulted from academics doing research and trying out ideas. GHCs extensions are just that process.
16:18:06 <dminuoso> I dont see anything fundamentally wrong as GHC extensions as precursors of haskell report features.
16:18:59 <Axman6> unpopular opinion: extensions are just language feature flags #facebookdev
16:19:32 <hpc> how else would you develop new language features, anyway?
16:19:52 <Axman6> laborious committee process like C++
16:20:14 <hpc> even then you have an implementation of it somewhere before it gets standardized
16:20:42 <hekkaidekapus> hpc: Letâs do that then.
16:21:07 <hpc> and then make that implementation optional
16:21:18 <hpc> and then to make it easy to use, make it enabled with a comment at the top of the file
16:21:21 <hpc> :P
16:21:57 <hekkaidekapus> How many compilers are Report2010-compliants?
16:22:50 <Axman6> probably up to one
16:23:02 <hekkaidekapus> Thatâs a bummer.
16:23:22 <hekkaidekapus> No standard process possible with a singleton.
16:26:18 <hekkaidekapus> stu002: I am not aware of such a Haddock feature.
16:27:01 <hekkaidekapus> You can distribute the README by setting the `extra-files` in .cabal.
16:27:59 <hekkaidekapus> Some programmers make Haskell modules containing only documentation. Therein, the full extent of the Haddock syntax is available.
16:28:22 <dolio> Anyhow, my point is, don't think about this in a backwards way. Forcing people to demand the release of another 'official standard' before they can type less garbage in their files isn't going to create more Haskell implementations. Because the implementations created the standard, not the other way around.
16:29:38 <dminuoso> One prohibiting factor for new implementations to arise, is that without supporting most extensions, you couldn't use much of hackage. Transitively you quickly depend on a lot of extensions.
16:30:11 <hekkaidekapus> dolio: Point taken.
16:31:01 <hekkaidekapus> stu002: For instance, this module has not a single Haskell identifier: <https://hackage.haskell.org/package/dhall-1.36.0/docs/Dhall-Tutorial.html>
16:31:05 <dminuoso> And part of why so packages so freely depend on extensions without caring about interoperability, is because there's not even some principle Haskell2020 that you could even adhere to
16:31:21 <dminuoso> The best we have is Haskell2010, and that's very limiting
16:31:32 <dolio> Even if there was, there would be no reason to not use GHC's extensions beyond 2020.
16:31:47 <dolio> Because there is no other compiler to use.
16:32:13 <dminuoso> I guess it's a vicious circle.
16:34:07 <monochrom> At this point, you can compare (another Haskell compiler competing with GHC) with (a new manufacturer of photocopiers competing with existing brands)
16:34:21 <dminuoso> But I stand by my opinion that with a modern Haskell 202x standard, it would be easier to get people away from just using off-standard GHC extensions.
16:34:34 <dminuoso> Without a standard you can't even try
16:35:28 <monochrom> Users now have so much expectations of a Haskell compiler or a photocopier (now called "office document centre") that only GHC and only the existing very experienced manufacturers can live up to those expectations.
16:36:30 <monochrom> Indeed look at the feature creeps into GHC that bring it further and further away from very simple Haskell, and the feature creeps that turned simple photocopiers to monstrous know-it-alls.
16:37:04 <dolio> I don't think you need to compile hackage to be a useful Haskell compiler, incidentally. There's probably like 0.1% of hackage or less that matters.
16:37:19 <dolio> Maybe less.
16:37:56 <dminuoso> Ability to compile a notable portion of hackage is what a new implementation would require for good adoption.
16:38:15 <dminuoso> Unless this was an industry implementation for some special use
16:38:26 <dolio> PureScript compiles 0% of hackage, I expect.
16:38:33 <dminuoso> PureScript is not Haskell though.
16:38:44 <dolio> And yet people use it.
16:39:05 <monochrom> But purescript compiles 100% of the purescript library repository :)
16:39:34 <hekkaidekapus> dminuoso: Thatâs a tall order. Look at head.hackage and all the cycles going there to test new GHC features against a few Hackage packages.
16:39:43 <dminuoso> If you tell me "this is a haskell compiler", and yet it cant compile most packages dubbed as "haskell package", then why should I buy your implementation?
16:39:59 <dolio> monochrom: That's probably wrong, too.
16:40:08 <dolio> They keep making major language changes.
16:40:15 <dolio> Or at least, did in the past.
16:40:26 <monochrom> There is the expectattion that if you called your compiler "purescript compiler" people don't expect it to be compatible with any of Hackage, whereas if you call it "Haskell compiler" people suddenly do.
16:40:48 <monochrom> Ah OK, oh well.
16:41:18 <dolio> dminuoso: Why would anyone buy it, period. The problem is, there's nothing that isn't GHC that has a tangible reason for people to use it. The tangible reason to not use GHC comes first.
16:41:59 <dminuoso> That's a fair point.
16:42:02 <hekkaidekapus> dolio: You seem to be okay with monocultures.
16:42:15 <dminuoso> I don't think dolio suggested he's *okay* with the situation.
16:42:48 <hekkaidekapus> I got the point about implementations preceding standardisation.
16:42:51 <dolio> I'm describing what the reality is, yes.
16:43:13 <dolio> If you don't like it, you need to change the reality.
16:43:32 <stu002> @hekkaidekapus thanks for that
16:43:33 <lambdabot> Unknown command, try @list
16:43:51 <hekkaidekapus> stu002: yw
16:44:22 <dminuoso> Perhaps its actually projects like Frege that could drive alternate implementations.
16:44:57 <dminuoso> A reason not to use GHC is because you might want more free interop with the JVM if inline-java is not enough.
16:45:06 <monochrom> I suddenly have a feeling that the Haskell Report died because Paul Hudak died.
16:45:09 <dminuoso> At the very least that's a large industry.
16:45:25 <dolio> If there were a real alternative to GHC that did something way better, but didn't implement all of GHC's stuff, there'd be people saying, "hey, can you make stuff compatible with this other thing? Maybe we should standardize it."
16:45:59 <dminuoso> dolio: Yeah. Frege fits that description exactly I guess.
16:46:20 <dolio> But making the alternative is the significant work, and just asking people to behave as if that other thing existed won't make the work happen, and eventually people will notice that you're asking them to do a lot of work conforming to your morality for no real benefit.
16:47:18 <monochrom> Yeah, hell, when I write in C I code to folklore x86-64 C, not the C standard.
16:47:54 <dminuoso> Heh, barely anyone ever adheres to the C standard
16:48:19 <monochrom> When I teach Haskell to students I shamelessly say "lazy evaluation" not what the Haskell Report tries to avoid to say.
16:48:38 <monochrom> (BTW IMO the Haskell Report also fails in its attempt to shy away from lazy evaluation.)
16:48:45 <dminuoso> Most of C appears to be not even folklore C but "whatever I imagine"-C
16:48:51 <hekkaidekapus> Standards are for compiler implementors anyway.
16:49:04 <monochrom> (For example explain to me why else "seq" is called "seq" not merely "strict" or "strictify")
16:49:07 <dminuoso> hekkaidekapus: That's a pretty inadequate bar, honestly.
16:49:14 <hekkaidekapus> heh
16:49:23 <dminuoso> If only language implementors can read it, how should a language user understand your language?
16:50:33 <dminuoso> If you take this to the extreme you end with something like C++ where not even the C++ committee understands what some of their standard means.
16:51:31 <dminuoso> [13] is a great source for inconclusive debates
16:51:55 <hekkaidekapus> I bet LLVM and GCC coders have a great grasp of the standard (those not on the C++ committee).
16:52:07 * hekkaidekapus is just hyperboling at this point.
16:52:24 <int-e> monochrom: you like puns, how would you like an independent Haskell implementation without type literals and type-in-type shenanigans? :)
16:52:47 <monochrom> Hrm, why is pun involved in that?
16:53:12 <monochrom> Oh hahahahaha
16:53:21 <int-e> (More seriously though, without another relevant Haskell implementation, the point of a standard is rather moon.)
16:53:28 <int-e> moot.
16:53:48 <hekkaidekapus> Define: relevant.
16:54:03 <hekkaidekapus> Implementing the previous standard?
16:54:12 <int-e> No, actually in use.
16:54:29 <monochrom> I have a weak reason for wishing for a standard even though there is only one implementation. Much more precise, reliable documentation of what the hell the implementation does.
16:54:58 <dolio> Weren't you the one that said GHC is better documented than the actual standard? :Ã¾
16:55:03 <dminuoso> int-e: okay it took me a minute to get the pub. quite cute 
16:56:16 <monochrom> I think I didn't say quite that quite directly. What I really think though is GHC is less worse than the Haskell Report.
16:56:57 <monochrom> And GHC's is somewhat better than "less worse" (but not a lot better) if you also include the papers it cites.
16:57:41 <monochrom> For example if you're looking for the typing rules of GHC 9's RankNTypes, you'd better read that bidirectional inference paper.
16:58:00 <dolio> Yeah.
16:58:01 <monochrom> rules that should have been in a standardized document.
16:58:55 <dolio> It'd be nice if their wiki gave a compilation of how it works, since you never know what all from the past is relevant.
16:59:51 <Axman6> The top story on lobste.rs has the title "Booting from a vinyl record" and I was sad to see it wasn't haskell related
17:00:13 <monochrom> heh
17:02:59 <monochrom> err, the bidirectional inference paper for pre-9 RankNTypes; the quick-look paper for post-9 RankNTypes and impredicativity.
17:03:26 <monochrom> but the latter tells you that they assume you have read the former, so you're still toasted.
17:05:02 <monochrom> What I fear is that if a comittee were formed to add these to Haskell Report, a very vocal, counterproductive minority would argue "cannot go with these rules verbatim, we need to allow different compilers to make different trade-offs"
17:05:36 <monochrom> And that will land you with: either no change to the Haskell Report, or the C standard.
17:07:26 <dolio> Yeah, that would probably be useless.
17:08:31 <dolio> Although what would the situation be if it were standardized? GHC keeps changing what you're allowed to do.
17:08:42 <dolio> Would the standard keep shifting?
17:11:32 <monochrom> That's a tough one. My preference is GHC changes quickly, the standard changes slowly to summarize the sweet spots GHC has found.
17:11:36 <dolio> I think a lot of the development has been allowing it to infer strictly more cases, but sometimes it has switched trade-offs.
17:13:53 <dolio> Oh, and of course, keeping multiple, distinct checking algorithms around in a single implementation wouldn't be very nice. :)
17:14:04 <dolio> So that wouldn't be a solution.
17:16:54 <monochrom> Windows 95 managed to have two kernels inside it haha
17:18:36 <monochrom> to be sure, you would be fair to point out "that exactly shows what wrong with it"
17:21:30 <dolio> Lots more workers, too.
18:29:25 <boxscape> :o are there no operator sections on the type level?
18:29:48 <boxscape> % :kind (+ 4) 6
18:29:48 <yahb> boxscape: ; <interactive>:1:2: error: Operator applied to too few arguments: +
18:30:25 <boxscape> I can see why it's not a thing for type families (since we don't have unsaturated ones yet) but it seems like it should work for type constructors at least
18:30:39 <boxscape> but it's syntax error from what I can tell :(
18:33:16 <monochrom> There is no type-level lambda, therefore no type operator sections.
18:33:22 * hackage sr-extra 1.85 - Module limbo  https://hackage.haskell.org/package/sr-extra-1.85 (DavidFox)
18:34:45 <monochrom> OK, one of them is OK, (Int :+:) is just (:+:) Int, uncontroversial. I guess no one got around to implement it.
18:35:29 <boxscape> hm, maybe I'll look into it once we have unsaturated type families, which I think might make it worth it
18:37:18 <sleblanc> I like XMonad's approach to configuration, where it "recompiles" itself when you update your configuration file. How does XMonad do it?
18:51:17 <sim590> I have this code: https://paste.debian.net/1173920/ which makes use of lenses. It is a multi constructor data type. One of which doesn't have private key, hence using (view privateKey) asks me to put the Monoid constraint on my function. How can I solve that?
18:53:18 <sim590> Is there a way to call some Lens magic functions that would return (Maybe v) instead of the plain (view privateKey) ?
18:56:17 <dibblego> you'd use a Traversal
18:59:15 <sim590> dibblego: hmmmmmm. OK. 
18:59:22 <sim590> I'm a bit new to lenses.
19:00:15 <dibblego> _StartUpRemoteUser :: Prism' (UserInfo v b) (v, b)
19:00:26 <dibblego> _StartUpRemoteUser_privateKey :: Traversal' (UserInfo v b) v
19:04:41 <sim590> OK. I didn't understand the types you wrote... I'm sorry. However, I found that I can use (^?) instead of view. I really need to a good course on lenses.
19:04:51 <sim590> I've watched and read already, but not enough.
19:06:24 <dibblego> or use preview
19:10:11 <dibblego> https://gist.github.com/tonymorris/1bbc3aff874a97722d78cb9a9154c494
19:12:59 <sim590> So that's what makePrisms and makeLenses expand to (partly)?
19:16:52 <dibblego> yes
19:17:05 <dibblego> makePrisms makes that prism among other things
19:59:16 <ezzieyguywuf> in hledger do I have to use $ for dollars, or can I use "USD" like in beancount?
20:02:15 <jle`> ezzieyguywuf: there are no built-in currencies i believe, either are valid currency labels
20:02:23 <ezzieyguywuf> jle`: ðï¸
20:02:23 <jle`> so there is no special-casing for dollars
20:02:27 <ezzieyguywuf> gotcha
20:02:37 <ezzieyguywuf> I'm used to the USD now, so I think I'll just go with that
20:07:08 <MarcelineVQ> there's a #hledger channel too that's quite helpful
20:07:20 <MarcelineVQ> in particular due to sm[m] 
20:15:50 <texasmynsted> Where may I find more information about how to best unit test modules. Specifically if you use something like hunit, how do you test code in a module that is not exported?
20:22:29 <hololeap> is hledger really more useful than a spreadsheet?
20:23:08 <MarcelineVQ> idk but it's pretty nice
20:23:36 <sleblanc> hololeap, for one, hledger supports currencies and ad-hoc commodities
20:23:57 <hololeap> i took a look at it once and didn't understand what was so good about it. i'm sure i didn't give it enough of a chance.
20:24:22 <sleblanc> hololeap, I hope no one is trying to sell it to you
20:24:56 <hololeap> no, i was just looking for a ledger program, and i like haskell. seemed like a natural choice to check it out.
20:26:20 <hololeap> it seems popular enough, though
20:26:29 <MarcelineVQ> I find it really convenient to edit plaintext files rather than work in a spreadsheet, especially to add more-specific/sub accounts on the fly
20:29:58 <jle`> hololeap: for me i sort of juts treat it like spreadsheet with built in command line tools for querying and stuff
20:30:30 <jle`> so i don't have to implement it all myself
20:32:28 <jle`> it makes it more simple to do double-entry accounting too
20:38:01 <dsal> texasmynsted: You don't test stuff that's not exported.  You can't import it to test it.  What kind of testing are you doing?  hunit style is usually my second choice.
20:44:12 <sm[m]> hail hololeap! It's a good question, I think each is good at certain things
20:45:15 <texasmynsted> Have some routines to read TSV files for redirects and things. I only export the data and the functions needed. I wanted to add and test some validation. I have a redirect so two URLs per record.
20:45:54 <texasmynsted> I want to validate that the first URL is relative, not absolute and does not start with /. I would not export this validation function but I would like to test it.
20:47:14 <texasmynsted> How would you handle this?
20:52:30 <texasmynsted> It seems like if it is exported it is a bit more like an integration test than a unit test.
20:52:46 <texasmynsted> I do not care what it is called though
20:58:44 <dsal> My first choice is usually property tests.  Define what a kinds of things make up a valid relative URL.  Verify you parse it as such.
21:01:10 <dsal> You can get a massive amount of test coverage (usually including things you didn't think of) this way.  I assume you've got a RelativeURL type.  You just need an Arbitrary instance and a way to serialize it to a string in the format the parser wants.  Then you just ask if there's any valid RelativeURL that can't be parsed as a RelativeURL.
21:08:39 <dsal> Your test could be something like this:
21:08:40 <dsal> @check read . show >>= (===)
21:08:42 <lambdabot>  +++ OK, passed 100 tests.
21:09:36 <dsal> I use that kind of thing when I hand-write read or show (or do some other kind of parser/serialize thing).
21:19:25 <texasmynsted> :-)
21:19:47 <texasmynsted> nice
21:19:49 <texasmynsted> thank you
21:21:53 * hackage time 1.11.1 - A time library  https://hackage.haskell.org/package/time-1.11.1 (AshleyYakeley)
