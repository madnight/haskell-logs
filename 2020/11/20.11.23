00:26:22 * hackage mu-protobuf 0.4.0.3 - Protocol Buffers serialization and gRPC schema import for Mu microservices  https://hackage.haskell.org/package/mu-protobuf-0.4.0.3 (AlejandroSerrano)
00:27:49 <Xnuk> What are the benefits of the Monad concept in other language, if you have to explain?
00:31:09 <merijn> almost none, since most other languages don't have typeclasses nor type inference
00:31:47 <Xnuk> Lots of people say "Monad is good and important concept", but I still think Monad is just one of typeclasses satisfying `(>>=)` and `return`.
00:33:05 <Xnuk> merijn: I completely agree
00:34:22 * hackage typesafe-precure 0.7.10.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.7.10.1 (igrep)
00:34:57 <dminuoso> 09:31:25          Xnuk | Lots of people say "Monad is good and important concept", but I still think Monad is just one of typeclasses satisfying `(>>=)` and `return`.
00:35:01 <dminuoso> You're thinking just right. :)
00:35:18 <dminuoso> The usefulness of monad comes from not using it, but writing code polymorphically over it.
00:36:55 <dminuoso> Well and not having to remember different names for functions that all follow the same shape, the same reason we have say `<>` and `mempty`
00:37:23 * hackage hlint 3.2.3 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.2.3 (NeilMitchell)
00:38:11 <Xnuk> dminuoso: "The usefulness of monad comes from not using it" Can I steal your words
00:38:14 <[exa]> Xnuk: 'first-class overloaded code sequencing with assignment' is the main feature the other languages should be after, imo
00:38:31 <dminuoso> Xnuk: Oh haha sorry. That was supposed to read "not from using it"
00:39:12 <tomsmeding> 23:16:42        maerwald | hmm, we need latex support on tomsmeding paste
00:39:17 <tomsmeding> I await your case maerwald 
00:39:28 <dminuoso> tomsmeding: I think it was cheek-in-tongue..
00:39:34 <tomsmeding> :p I think so too
00:39:35 <dminuoso> Considering the surrounding discussion. :p
00:39:46 <dminuoso> Oh haha. tongue-in-cheek
00:39:57 <dminuoso> Doing it the other way is anatomically difficult
00:40:08 <tomsmeding> kind of
01:00:22 * hackage servant-openapi3 2.0.1.1 - Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.  https://hackage.haskell.org/package/servant-openapi3-2.0.1.1 (maksbotan)
01:14:12 <dminuoso> For associated tyfams, would you rather write `f :: n ~ TyF t => Proxy t -> n -> ...` or `t :: Proxy t -> TyF t -> ...`?
01:18:57 <kuribas> I don't understand how you can make effects independent of the order.
01:19:18 <kuribas> For example ExceptT and StateT, at one point you have to decide which one takes precedence right?
01:19:42 <kuribas> like, is state passed when throwing an exception?
01:20:20 <kuribas> both are valid IMO
01:40:44 <merijn> kuribas: Hence why the typeclassy mtl approach doesn't work so well
01:41:49 <kuribas> merijn: you mean the typeclasses don't show the order?
01:42:07 <merijn> yeah
01:43:09 <kuribas> That's why I never write functions that have mtl typeclass constraints.
01:43:20 <kuribas> I just use them as convenience inside my own transformer stacks.
01:44:20 <kuribas> where I already *know* the order, so it doesn't matter.
01:47:18 <cads> does ghc have installation directions hidden somewhere in the manual?  I may be missing it  https://downloads.haskell.org/ghc/latest/docs/html/users_guide/
01:47:37 <cads> the 6.2 instructions had it as chapter 2 https://downloads.haskell.org/~ghc/6.2/docs/html/users_guide/users-guide.html
01:49:10 <Uniaika> cads: https://www.haskell.org/ghcup/
01:52:14 <cads> thanks Uniaika 
01:52:27 <Uniaika> you're welcome
01:52:48 * cads likes that there are clear wsl instructions 
01:53:27 <cads> so the idea is that haskell platform takes care of install, so GHC docs don't need to have an install chapter?
01:55:33 <merijn> cads: tbh, the install instructions on *nix of GHC itself are basically just "./configure --prefix=path/to/install && make install" and in the README, so that doesn't really warrant a user guide thing. And the windows story is still a bit of a mess
01:56:08 <cads> g h c u p - a slightly perverse claim :D
01:59:10 <merijn> rats...I just realised I need to refactor my code to handle connections to multiple databases, that's gonna suck >.>
01:59:38 <cads> merijn, I did see that, but of course I managed to encounter a totally inexcplicable make issue, and wished I had something more to sanity check that I had not missed some dependency or important config parameter
01:59:58 <merijn> cads: Which platform? Linux?
02:00:03 <cads> WSL
02:00:16 <cads> so yes/no
02:00:17 <merijn> ah, yeah, that's probably rather untested ;)
02:00:57 <cads> well I will give credit to gh-ketchup, because the WSL solution /worked/ https://www.haskell.org/ghcup/
02:01:48 <cads> and it's right there under my unobservant nose. It felt really good as a user experience to finally see something that I had some reason to believe will work <3
02:02:08 <maerwald> gh-ketchup?
02:02:46 <cads> for some reason I see ghcup and my brain turns it into gh-ketchup
02:03:04 * cads shrugs
02:03:35 <Uniaika> cads: fantastic hahaha
02:03:41 <cads> usually if I'm making a wierd mnemonic or nick-name that's a sign that I like it and will remember it
02:04:13 <cads> Uniaika, whoever put that wsl line there has my specific thanks and admiration!
02:04:17 <Uniaika> < merijn> rats...I just realised I need to refactor my code to handle connections to multiple databases, that's gonna suck >.> // RIP üíÄ
02:04:31 <Uniaika> cads: h√©h√©, you may ask for maerwald I think?
02:04:44 <guest112`> is ghc available on linux distro on arm?
02:04:56 <merijn> guest112`: Yes *
02:05:06 <merijn> * - some masochism maybe required
02:05:08 <Uniaika> *conditions may apply
02:05:12 <guest112`> merijn: I tried archlinuxarm, there's no ghc yet
02:05:19 <maerwald> https://downloads.haskell.org/~ghc/8.10.2/ghc-8.10.2-armv7-deb10-linux.tar.xz
02:05:25 <Uniaika> guest112`: which ARM arch?
02:05:44 <guest112`> Uniaika: arm v8
02:05:46 <Uniaika> if it's armv7 there is a bindist, as maerwald showed
02:05:47 <Uniaika> ah
02:05:56 <guest112`> aha
02:06:10 <maerwald> I think angerman is currently the only one doing ARM love?
02:06:14 <merijn> guest112`: arm is a tier2 architecture, so it requires some amount of DIY involved, depending on exactly which architecture, etc.
02:06:36 <guest112`> maerwald: it's debian only?
02:07:14 <Uniaika> hmm I think it's for debian derivatives too, guest112` 
02:07:16 <maerwald> well, who cares... just have to fix your dynamic libs
02:07:17 <guest112`> merijn: is it in debian's repo? could I use apt to install
02:07:41 <angerman> PSA: Do not use arm for anything critical right now. The rts is seriously broken wrt correctness.
02:07:57 <guest112`> dynamic libs on arm, I think that's a lot
02:08:13 <angerman> Head with the llvm backend is ok, it you don‚Äôt use perf.
02:09:13 <angerman> If you must use older GHCs. Ensure you use single threaded only.
02:10:05 <cads> merijn, do you think WSL will become the primary path for haskell on windows?
02:10:15 <angerman> Patched 8.6.5 that‚Äôs somewhat usable https://github.com/input-output-hk/ghc/tree/release/8.6.5-iohk
02:10:46 <angerman> Ghc 9.2 will likely be pretty good on arm.
02:12:44 <arahael> angerman: Sweet. :)
02:13:13 <cads> Uniaika, this is the commit that adds the line  -  thanks Julian Ospald / ! https://gitlab.haskell.org/haskell/ghcup-hs/-/commit/8c4cde3d14ca79e8dac95cc3fd63581be2cda4b2
02:13:42 <cads> though I am not 100% on the attribution - could be a that Julian applied a patch
02:15:15 <maerwald> lol
02:15:39 <cads> lol, was it really you, maerwald ?
02:16:38 <maerwald> gitlab shows nickname if you hover over the real name
02:19:27 <aplainzetakind> So I can't handle encoding: https://gist.github.com/aplainzetakind/155843dab732f0aeffb5bb0e3b679021
02:19:46 <aplainzetakind> When I try this out I gen invalid utf8 bytes.
02:19:57 <aplainzetakind> s/gen/get
02:20:06 <dminuoso> Of course, not every byte sequence is valid UTF8.
02:20:23 <dminuoso> With md5 in the pipeline, you're essentially generating pseudo random bytes
02:20:53 * tomsmeding expects you want to encode the bytes as hexadecimal
02:21:09 <aplainzetakind> That makes sense.
02:22:00 <dminuoso> aplainzetakind: Check out base16-bytestring
02:22:09 <dminuoso> (Or base64-bytestring)
02:23:43 <aplainzetakind> How do I get from String to those?
02:24:41 <aplainzetakind> Ah I need this only to decode?
02:24:48 <aplainzetakind> No encode.
02:24:56 <merijn> You probably just wanna show the resulting Digest
02:25:28 <dminuoso> https://hackage.haskell.org/package/cryptonite-0.27/docs/src/Crypto.Hash.Types.html#line-86
02:25:34 <merijn> That's what works for cryptonite
02:25:34 <dminuoso> That seems to run it through base16-bytestring already indeed.
02:25:41 <aplainzetakind> merijn: Argh, it has Show. OK.
02:25:46 <merijn> And this seems to use the same API
02:26:58 <aplainzetakind> Yes using show in place of T.unpack . T.decodeUtf8 . md5DigestBytes just works.
02:27:00 <aplainzetakind> Thanks.
02:32:42 <cads> maerwald, thank you thank thank you for caring about wsl users!
02:33:19 <maerwald> I think native ghcup on windows could be a thing too, but I haven't had anyone knowledgable about msys2 speak up on how to do it.
02:33:45 <maerwald> And handling that right basically determines most of the user experience.
02:34:08 <cads> imo anything that does linux on windows and uses mingw/msys rather than wsl is now a smell
02:34:26 <cads> but I don't REALLY know what I am talking about, lmao
02:34:36 <cads> just using that internally
02:35:12 <cads> but it makes sense from the perspective of how much msft is investing in it, and how much more comfortable it is
02:36:04 <cads> does ghcup compete with stack? Or can I see it as part of?
02:37:08 <maerwald> cads: not really. I personally use stack and ghcup together in some docker images to build static executables (because ghcup provides alpine bindists that stack doesn't)
02:37:28 <maerwald> you can tell stack to use system GHCs and then use ghcup to manage them
02:38:16 <maerwald> but stack doesn't help you much when you want to use cabal with multiple GHCs
02:38:58 <maerwald> so you could say cabal + ghcup is kind of a substitute for stack for some use cases
02:39:03 <cads> and how much user share can we estimate it pulls? Is it well enough accepted for Darcs installation instructions to mention it? Currently they mention stack, and cabal. IMO these aren't the beginning of the story in windows, but ghcup is.
02:39:25 <cads> https://darcsbook.acmelabs.space/chapter02.html#installing-darcs
02:43:12 * tomsmeding is a happy user of ghcup, please spread
02:43:34 <maerwald> I'm not sure, the last haskell survey result had a data bug, but it's probably somewhere between 9-20%
02:44:13 <cads> oo, we have a survey?
02:44:17 <maerwald> https://taylor.fausak.me/2019/11/16/haskell-survey-results/#s2q1
02:44:26 <maerwald> https://taylor.fausak.me/2020/11/22/haskell-survey-results/#s2q1
02:44:34 <cads> and up to 1/5th is really something
02:49:28 <cads> Hmm, I notice that the haskell call to action calls users to type a haskell expression, but now download a haskell installer or binary package
02:51:04 <cads> If we look at go-lang.org - it has a code tester plus download button. Rust-lang.org has a download button, and then a notably accessible download page with a) Large flat download buttons in attention catching colors   b) a curl line for deploying rustup.
02:51:23 <cads> this is what windows user see https://imgur.com/a/ZI4UsBT
02:53:02 <maerwald> cads: you may want to comment on https://gitlab.haskell.org/ghc/ghc/-/issues/18104
02:53:22 <cads> could we borrow this "flat buttons mean actions" motif, and give haskel.org a awesome, rounded, regal purple button saying "Download Haskell" or "Get Started", and make similar updates for the download page?
02:53:45 <maerwald> And https://github.com/haskell-infra/www.haskell.org/issues/12
02:55:03 <cads> lol @ issue 12
02:55:15 <cads> sounds like I need to make a proposal, is all
02:55:22 <cads> thanks!
02:58:39 <merijn> cads: People can't agree on what installer should be used :p
03:01:36 <maerwald> everyone has an opinion, but no one has time :p
03:02:03 <cads> makes it very very easy for anyone with the time
03:05:42 <cads> unless the other folks think they still get an opinion ;)
03:07:08 <cads> like, sorry, but this the new download button, lmao https://imgur.com/a/tVkTeak ;)  
03:07:25 * cads is partially kidding of course
03:11:59 <tomsmeding> oh, can I order the Hask category? that would be neat
03:12:49 * cads thinks the hask category is the first category they ever heard of
03:13:28 <tomsmeding> I believe it's not a particular interesting one, but don't ask me about category theory lol
03:15:02 <cads> maerwald, I'm very interested in your docker workers - was trying to set that up earlier today when I thought that the installer story was broken for WSL
03:15:47 <cads> I was going to have a ghc docker machine that I send builds to
03:18:03 <cads> maerwald, also at this juncture I'm thinking about adding buttons, not forcing a choice on the installers. Although adding buttons kind of foregrounds the issue that we don't really have buttons for windows, I'm not against making buttons point to what we've got
03:18:36 <cads> ie, that design can even remain in draft status till we figure out what the buttons are
03:22:27 <maerwald> cads: here's an example https://git.io/Jk6OS
03:26:26 <cads> I'm currently building design references from:   https://go-lang.org, https://rust-lang.org, https://typescriptlang.org, https://quarkus.io - these are four examples of programming platforms, whose web pages visually eliminate uncertainty and reduce the stress of getting started.. Other examples are welcome!
03:27:43 <cads> maerwald, thanks! I did not know that I could fork a gist. But I do now, and I'm not ashamed :)
04:11:12 <sondr3> when writing parsers in Haskell where parsing depends on a sequence you parsec earlier on is there a way to avoid using state? The parser has a 'boundary' that is the end of a multiline string that you find in the beginning of parsing
04:16:31 <tomsmeding> that's what monadic parsing is for, right?
04:17:05 <tomsmeding> do { sep <- choice [string "'", string "\""] ; body <- parseMultilineBody sep ; string sep ; return body }
04:17:27 <tomsmeding> of course changed to your particular situation sondr3 
04:17:53 <tomsmeding> your state is on the call stack, sort of
04:18:39 <tomsmeding> now, if you'd need to know which separator was used in a completely different part of the thing you're parsing, then you probably need some kind of state
04:20:36 <sondr3> Yeah, the separator is shared between many entries when parsing where each entries separator must be an exact match to the first found separator 
04:23:11 <tomsmeding> is that only within the actual multiline string you're parsing? If so, can you not somehow write that parseMultilineBody function?
04:23:19 <tomsmeding> note that it gets the used separator as an argument sondr3 
04:24:46 <sondr3> The spec says that the content is "any sequence of characters that neither begins with boundary nor NEWLINE boundary", I've been able to make a parser with state where it works
04:25:01 <sondr3> But it feels kinda icky and I
04:25:19 <sondr3> new keyboard, bear with me x)
04:25:58 <sondr3> *and I can't get hspec-megaparsec to agree with me when using ParsecT and not just Parsec
04:33:23 <tomsmeding> sondr3: which spec?
04:33:51 <Iceland_jack> :t curr
04:33:52 <lambdabot> error:
04:33:52 <lambdabot>     ‚Ä¢ Variable not in scope: curr
04:33:52 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòcurry‚Äô (imported from Data.Tuple)
04:33:53 <Iceland_jack> :t curry
04:33:54 <lambdabot> ((a, b) -> c) -> a -> b -> c
04:34:05 <Iceland_jack>  curry :: ((a, b) -> c)
04:34:05 <Iceland_jack>       -> (a -> b -> c)
04:34:19 <tomsmeding> neat, isn't it?
04:34:37 <sondr3> tomsmeding: https://github.com/google/hrx, looked like a simple and useful thing to use when learning parsing in Haskell, it's just the boundary stuff that's tripping me up
04:35:26 <tomsmeding> sondr3: can't you do this recursively?
04:36:16 <sondr3> tomsmeding: the thought have struck me, yeah
04:39:00 <sondr3> I'll try doing it recursively, thanks for being a rubber duck tomsmeding :)
04:39:19 <tomsmeding> or even in a kind of continuation-passing style; parseComponent :: Maybe Boundary -> Parsec HRX ; parseComponent Nothing = parseNewBoundary >>= parseAfterBoundary ; parseComponent (Just bnd) = parseBoundary bnd >> parseAfterBoundary bnd ; parseAfterBoundary :: Boundary -> Parser HRX ; parseAfterBoundary bnd = do { item <- pComment bnd <|> pFile bnd <|> pDirectory bnd ; HRX rest <- parseComponent
04:39:19 <tomsmeding> (Just bnd) ; return HRX (item : rest) }
04:39:22 <tomsmeding> or something like that?
04:39:32 <tomsmeding> s/ ; /\n/g
04:39:43 <tomsmeding> pseudocode though :p
04:39:46 <tomsmeding> that's CPS-like
04:41:12 <sondr3> Looks like Haskell to me :P thanks!
04:41:30 <boxscape> % type TypeOf :: forall t . forall (a :: t) -> *; type family TypeOf t where TypeOf @t a = t
04:41:30 <yahb> boxscape: 
04:41:31 <boxscape> % :kind! TypeOf (Just True)
04:41:31 <yahb> boxscape: *; = Maybe Bool
04:41:34 <boxscape> I like that this works
04:41:50 <boxscape> feels almost like using a dynamically typed language in a way
04:43:58 <boxscape> % type TypeOf' :: forall t . t -> *; type family TypeOf' a where TypeOf' @t a = t -- I suppose my kind sig is more complicated than it has to be
04:43:58 <yahb> boxscape: 
04:45:53 * hackage sr-extra 1.85.1 - Module limbo  https://hackage.haskell.org/package/sr-extra-1.85.1 (DavidFox)
04:46:26 <boxscape> % Just True :: TypeOf (Just True) -- :)
04:46:26 <yahb> boxscape: Just True
04:50:04 <hseg> hi. is there some way of dumping all bindings made in ghci?
04:50:34 <hseg> have had a long ghci session, would like to save some of the more useful ones for tomorrow
04:51:03 <geekosaur> not really
04:51:16 <hseg> pity
04:51:23 <boxscape> % :show bindings
04:51:23 <yahb> boxscape: type Ghci6.Fam :: forall k (a :: k) (b :: k). a :~: b; type family Ghci6.Fam; type Ghci7.Fam :: forall k (a :: k) (b :: k). a :~: b; type family Ghci7.Fam; type Ghci8.Fam :: forall k (a :: k) (b :: k). a :~: b; type family Ghci8.Fam; type Ghci9.Fam :: forall k (a :: k) (b :: k). a :~: b; type family Ghci9.Fam; type Fam :: forall k (a :: k) (b :: k). a :~: b; type family Fam; type Foo :: *; data Foo = ...; foo
04:51:33 <boxscape> hseg does that work?
04:52:08 <boxscape> wait
04:52:09 <boxscape> it doesn't
04:52:20 <boxscape> it doesn't give you the definition, only the type
04:52:21 <boxscape> :(
04:52:43 <hseg> which is enough to ctrl-r back to the definition
04:52:46 <hseg> thanks!
04:52:51 <boxscape> np
04:52:57 <boxscape> glad it help
04:52:58 <boxscape> s
04:53:52 <hseg> well, up to a point, but i'll take what i can get
05:03:42 <tomsmeding> hseg: try ~/.ghc/ghci_history?
05:04:22 <tomsmeding> though it seems it only writes that file upon closing ghci, so that's going to be a scary close :p
05:04:28 <hseg> yup
05:04:41 <hseg> and it's of bounded length
05:04:52 <hseg> oh well
05:04:53 <tomsmeding> oh true
05:04:57 <hseg> not too much was lost
05:05:12 <hseg> and needed to rewrite what was lost anyway
05:07:06 <hseg> recommendations for improvement on http://ix.io/2FbY ?
05:07:40 <hseg> (trying to compute the cycle notation of a permutation s, written out as [s 1, s 2, ..., s n]) 
05:07:48 <ski> Xnuk : "Escaping Hell with Monads" by Philip Nilsson in 2017-05-08 at <https://philipnilsson.github.io/Badness10k/escaping-hell-with-monads/> might be interesting
05:10:14 * lmw hugs ski
05:10:29 <hseg> ski: neat exposition
05:11:37 <ski> dminuoso : "The usefulness of monad comes from not using it" -- actually i think this (the original, unintended, formulation), is partially true, if you interpret it as expressing effects through monads, instead of by having side-effects in the language
05:11:45 <ski> heya lmw :)
05:17:45 <sondr3> I like how DuckDuckGo displays a little `Safe Haskell: Trustworthy Language: Haskell2010` beneath some Hackage packages
05:18:43 <Iceland_jack> :D
05:19:12 <ski> (in other words, part of the usefulness of expressing effects through monads (and idioms / applicative functors), rather than through side-effects, is that this clearly (in both types/interfaces, and in code) delineates and distinguishes where effects can occur, rather than potentially every call having a side-effect, thereby helping/improving refactoring and other reasoning)
05:22:44 <hseg> ie a particular case of "sufficiently well-typed programs can only go limitedly wrong"
05:26:33 <hseg> TIL: import Module as M imports all names from M as well as qualified versions qualified by M -- particularly useful when only a couple of names overlap
05:47:49 <tomsmeding> I recommend using an unqualified import with an "as" binding very sparingly
05:48:32 <tomsmeding> it suggests that this module exports names that collide with other things (otherwise you wouldn't need the "as"), and thus probably exports names that are fairly generic and hard to trace back to the module
05:48:48 <tomsmeding> which _usually_ makes it hard to understand the code without IDE support
05:49:01 <tomsmeding> but this is a very subjective recommendation, use your own judgement :)
05:49:31 <tomsmeding> in particular 'import Data.Text as T' is very bad IMO
05:57:20 <PacoV> Hi.
05:58:07 <tomsmeding> hseg: a pattern that I (and other people) do use is something like 'import qualified Data.Map.Strict as Map ; import Data.Map.Strict (Map)'
05:58:27 <tomsmeding> re:your IS.IntSet
06:02:01 <tomsmeding> PacoV: üëã
06:26:40 <qwfpmluy> what are the best resources for learning about the different ways of doing `deriving` (deriving via, standalone deriving, ...) in haskell?
06:28:32 <boxscape> I think the User Guide, starting here, is a decent resource https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-derived-instances-for-newtypes
06:29:01 <boxscape> (actually standalone deriving is a bit further up)
06:31:33 <Uniaika> I wonder if Kowainik didn't make a short guide on that
06:31:53 <lyxia> qwfpmluy: https://kowainik.github.io/posts/deriving
06:32:05 <Uniaika> glorious, thanks lyxia 
06:32:17 <lyxia> Uniaika: :P
06:32:30 <Uniaika> :9
06:32:44 <hseg> tomsmeding: fair. i use unqualified imports more frequently in ghci for this reason
06:33:18 <tomsmeding> ghci is playground anyway :)
06:34:20 <qwfpmluy> boxscape lyxia thanks!
06:34:58 <hseg> exactly
06:35:05 <hseg> any other recs?
06:35:18 <hseg> feel my recursion is a bit ad-hoc
06:38:22 * hackage prolude 0.0.0.10 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.10 (saramuse)
06:54:15 <boxscape> hmm, I'm idly wondering if there is some way to take a non-IO value and unsafeCoerce it to print a non-empty string to the terminal
06:54:24 <boxscape> I suppose there has to be
06:58:19 <tomsmeding> hseg: I haven't even tried to compile this, but theoretically this should do the same as yours? https://paste.tomsmeding.com/FbLBhrVM
06:58:45 <tomsmeding> using ! instead of !? I do assume that the permutation is valid, i.e. doesn't contain out of bounds values
07:00:36 <dminuoso> boxscape: Do you mean Debug.Trace.trace ?
07:00:44 <dminuoso> That's not quite unsafeCoerce though.
07:01:43 <boxscape> dminuoso well, basically what I'm looking for (for no particular reason) is something like (unsafeCoerce (23874893274 :: Integer) :: IO ()), which, when bound to main, prints "hello" to the terminal, or whatever
07:02:06 <merijn> boxscape: You are a bad person and you should feel bad >.>
07:02:07 <dminuoso> How is that even remotely related to unsafeCoerce... ?
07:02:14 <boxscape> merijn sorry :(
07:02:15 <merijn> dminuoso: l33t ahx
07:02:20 <merijn> s/ahx/hax
07:02:39 <dminuoso> boxscape: Why should that print "hello" and not "goodbye"?
07:02:42 <merijn> dminuoso: Like those people who write C, but main is a char* whose values happen to be sensible code
07:02:52 <boxscape> dminuoso because the number is carefully chosen
07:03:01 <boxscape> (though my example is random)
07:03:11 <dminuoso> boxscape: Maybe you should elaborate on that "carefully chosen"
07:03:17 <dminuoso> because so far you didn't mentoin this
07:03:33 <dminuoso> All I got was "I want `unsafeCoerce a` to turn it into a printing thing"
07:03:35 <dminuoso> :p
07:03:37 <merijn> dminuoso: He wants to figure out how to pick a value, such that unsafeCoerce leads toe xecutable code
07:03:51 <boxscape> dminuoso The essence of my wondering is exactly how to find such a value (and I suppose a type that supports it)
07:04:10 <dolio> I think that might not even be possible.
07:04:19 <dminuoso> boxscape: unsafePerformIO does it for you.
07:04:19 <boxscape> hmm what makes you say that?
07:04:28 <dminuoso> Or.. wait no. IO is that thing.
07:05:11 <tomsmeding> boxscape: I think the problem you're going to run into is that a valid valid of type IO a is going to have lots of pointers in it
07:05:14 <dminuoso> boxscape: For starters you have no knowledge of the hepa
07:05:20 <dminuoso> *heap
07:05:23 <dolio> Because there'd be no closure layout for an integer that actually matches an IO thing.
07:05:35 <dolio> Or any other type, really.
07:05:39 <boxscape> hmm okay
07:05:54 <tomsmeding> a ByteArray# could perhaps accidentally match something?
07:06:01 <dminuoso> ByteArray# lives on the heap too.
07:06:08 <tomsmeding> sure, but an IO value does too
07:06:20 <tomsmeding> and embedded pointers will go wrong though
07:08:30 <dminuoso> My feeling tells me boxscape lied about the "for no particular reason" part.
07:08:35 <hseg> tomsmeding: yeah, that looks great! my code is an object example of tunnel-visioned use of One Trick(TM)
07:08:42 <dminuoso> boxscape: Are you trying to be really sneaky?
07:08:43 <hseg> thanks!
07:08:47 <boxscape> dminuoso your feelings are lying to you :P
07:09:25 <boxscape> I was watching a stephanie werich talk about dependent haskell and somehow ended up using unsafeCoerce on a bunch of values with yahb, but I'm not sure how I got there
07:09:51 <boxscape> s/werich/weirich
07:10:11 <hseg> for some reason i have been avoiding let..in expressions in favor of where clauses recently
07:10:24 <dminuoso> boxscape: Can you provide a link to the talk, perhaps indexed at the right time
07:10:30 <merijn> hseg: I've always done that, let..in is hard to format nicely and almost never necessary
07:10:51 <tomsmeding> hseg: you could even replace the otherwise-line of 'peel' with 'uncurry (:) (peel <$> orbit (IS.findMin remaining) IS.empty)', but that's not making it better :p
07:10:54 <boxscape> dminuoso er, I can, but it won't help much because it has nothing to do with unsafeCoerce
07:10:55 <boxscape> https://youtu.be/n-b1PYbRUOY?t=1878
07:11:21 <Iceland_jack> qwfpmluy: you can use :instances to list possible instance to derive for -XDerivingVia
07:11:36 <Iceland_jack> newtype LL a = LL [[a]] deriving (Functor, Applicative) via Compose [] []
07:11:51 <Iceland_jack> :instances Compose [] [], lists (possible) instances to derive
07:12:24 <Iceland_jack> newtype Age = A Int deriving newtype Num
07:12:24 <Iceland_jack>     ={equivalent}
07:12:24 <Iceland_jack> newtype Age = A Int deriving Num via Int
07:12:38 <Iceland_jack> -XDerivingVia generalizes -XGeneralizedNewtypeDeriving
07:13:34 <Iceland_jack> *generalises??
07:13:42 <Iceland_jack> I must obey UK 
07:13:53 <boxscape> then use -XGeneralisedNewtypeDeriving
07:13:54 <hseg> i think this recursion pattern of :: (s -> (a,s)) -> (s -> Bool) -> s -> [a] should generalize, no?
07:14:03 <Iceland_jack> I think GND somewhat recently added -XGeneralisedNewtypeDeriving, UK spelling
07:14:21 <boxscape> yeah
07:14:39 <tomsmeding> :t unfoldr -- hseg
07:14:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
07:14:48 <hseg> merijn: that must be it
07:15:09 <hseg> ok, so peel can be written as an unfoldr
07:16:50 <tomsmeding> interesting, you're right
07:17:46 <hseg> also, IntSet is missing lookupMin :: IntSet -> Maybe Key
07:17:55 <ski> @where strategic-deriving
07:17:55 <lambdabot> I know nothing about strategic-deriving.
07:19:01 <ski> @where+ strategic-deriving "Strategic Deriving" by Veronika Romashkina,Dmitrii Kovanikov in 2020-09-21 at <https://kowainik.github.io/posts/deriving>
07:19:02 <lambdabot> Good to know.
07:19:16 <merijn> hseg: That's just "fmap fst . minView" ? :)
07:19:56 <hseg> sure... it did encourage me to reverse the iteration of my algorithm
07:20:09 <hseg> (i.e. replace "seen" by "to-process")
07:21:40 <hseg> also, considering the rest of containers have lookups, it's an annoying hole
07:25:45 <hseg> tomsmeding: also, orbit's output is flipped from what peel wants
07:25:58 <hseg> it returns (seen, orbit)
07:26:15 <tomsmeding> oh that's too bad, I wrote it that way to make the <$> nice and compact :p
07:27:23 <hseg> no problem -- just add a flip on the unfoldr
07:29:23 <tomsmeding> :t flip flip
07:29:25 <lambdabot> b -> (a -> b -> c) -> a -> c
07:29:44 <hseg> cool!
07:29:53 <dminuoso> flip flip looks cute and useful
07:30:09 <dminuoso> Just dont know what for.
07:30:24 <hseg> it reverses operators
07:30:39 <xerox_> :t flip flip flip
07:30:40 <lambdabot> (a1 -> ((a2 -> b -> c1) -> b -> a2 -> c1) -> c2) -> a1 -> c2
07:30:47 <hseg> > flip flip (++) ", world" "hello"
07:30:50 <lambdabot>  error:
07:30:50 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[Char]
07:30:50 <lambdabot>                                      -> ([a0] -> [a0] -> [a0]) -> c‚Äô
07:30:51 <maerwald> :t flip . flip . flip
07:30:52 <lambdabot> (a -> b -> c) -> b -> a -> c
07:30:59 <xerox_> that's what I was after
07:31:09 <tomsmeding> you know what's more fun? iterating 'flip' converges https://paste.tomsmeding.com/SefRZrAn
07:31:11 <hseg> > flip flip ", world" (++) "hello"
07:31:14 <lambdabot>  "hello, world"
07:31:31 <dminuoso> Also, random occurences of `flip const id` in your code are good to ensure the reader is paying full attention.
07:32:08 <tomsmeding> nah, should replace that 'id' with an arbitrarily complex expression
07:32:09 <hseg> :t flip const id
07:32:10 <lambdabot> c -> c
07:32:19 <hseg> neat
07:32:22 <hseg> :t id id id id id
07:32:23 * ski seconds the `where' over `let'-`in'
07:32:24 <lambdabot> a -> a
07:32:51 <dminuoso> ski: Ive started to become quite fond of `let` in pattern guards.
07:33:07 <dminuoso> for small bits, this can create less noise than where
07:33:08 <ski> that's not `let'-`in', though
07:33:21 <dminuoso> sure, just introducing this as a third alternative option
07:33:25 <ski> @type map `flip` "foo"
07:33:27 <lambdabot> (Char -> b) -> [b]
07:33:36 <merijn> dminuoso: What do you need let for in pattern guards?
07:33:36 * ski nods
07:33:50 <dminuoso> merijn: foo x | let y = ... = ...
07:33:58 <dminuoso> Same reason you'd use where
07:34:05 <merijn> dminuoso: You can just do "| y <- .."
07:34:13 <boxscape> "merijn: Like those people who write C, but main is a char* whose values happen to be sensible code" I can't help but look into this now :/
07:34:22 <dminuoso> merijn: We had this discussion before. <- has more potential for bugs
07:34:40 <merijn> boxscape: You haven't heard about IOCCC?
07:34:42 <merijn> boxscape: https://www.ioccc.org/
07:34:49 <dminuoso> i.e. `foo x | F x <- ...` vs `foo x | let Foo x = ...`
07:34:52 <dminuoso> err
07:34:57 <dminuoso> `foo x | F x <- ...` vs `foo x | let F x = ...`
07:35:10 <boxscape> merijn I've heard of it but tbh I haven't really looked at any of their programs in detail
07:35:15 <dminuoso> The former will behave differently if we suddenly introduce another contructor to F's type
07:36:01 * ski . o O ( `blah | let f x = ..x..,... = ...' )
07:36:23 <dminuoso> mm, is that allowed?
07:36:33 <dminuoso> % blah | let f x = x^2 = f 10
07:36:34 <yahb> dminuoso: 
07:36:38 <dminuoso> Oh cool. TIL
07:37:33 <ski> @wiki Obfuscation
07:37:33 <lambdabot> https://wiki.haskell.org/Obfuscation
07:39:13 <ski> % let blah y | let f x = x^2,(f . f -> z) <- y = z in blah 2
07:39:13 <yahb> ski: 16
07:40:49 <ski> % let blah (f . f -> z) | let f x = x^2 = z in blah 2
07:40:49 <yahb> ski: ; <interactive>:19:11: error: Variable not in scope: f :: b0 -> c1; <interactive>:19:15: error: Variable not in scope: f :: a -> b0
07:40:52 <ski> too bad
07:42:19 <boxscape> % let {f | let Nothing = Just 4 = True | otherwise = False} in f
07:42:19 <yahb> boxscape: True
07:42:20 <boxscape> % let {f | Nothing <- Just 4 = True | otherwise = False} in f
07:42:21 <yahb> boxscape: False
07:42:22 <boxscape> nice
07:43:15 <boxscape> I suppose instead of let guards you could use pattern guards with a lazy pattern
07:43:26 <boxscape> % let {f | ~Nothing <- Just 4 = True | otherwise = False} in f
07:43:27 <yahb> boxscape: True
07:43:29 <ski> yes
07:45:22 <ski> dminuoso : hm, you mean it will suddenly skip to the next alternative, in such case ?
07:46:39 <ski> `let' in list comprehensions is occasionally useful, too. but sometimes i find myself using `... <- [...]' (singleton list), instead
07:49:07 <dminuoso> ski: Yes.
07:49:37 <dminuoso> It can be what you want, but if not it can cause subtle bugs. With let you get an incomplete pattern match warning, so if the "skip" behavior is what you want you can opt-in still
07:50:03 <ski> yes
07:51:02 <dminuoso> <- just saves me a few characters with nothing to gain :)
07:53:15 <ski> i see
07:57:05 <hseg> tomsmeding: http://ix.io/2Fde is my latest version
07:57:28 <hseg> still feels like orbit could be improved, and am not too happy about the required plumbing
07:57:35 <hseg> but it's a marked improvement
07:58:17 <tomsmeding> hseg: IS.notMember
07:58:34 <hseg> d'oh! missed it
08:00:12 <tomsmeding> hseg: why not this? orbit x rs = if x `IS.member` rs then (x :) <$> orbit (nextMap ! x) (IS.delete x rs) else (rs, [])
08:00:16 <hseg> seems like the underlying logic for orbit is some takeWhileM :: (a -> m Bool) -> f a -> m [a]. not too certain on f
08:00:18 <Iceland_jack> :t (??)
08:00:19 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:00:20 <tomsmeding> why look ahead once
08:00:22 <Iceland_jack> :t (??) (??)
08:00:25 <lambdabot> Functor f => a -> f (a -> b) -> f b
08:00:36 <Iceland_jack> where flip = (??) @((->) _)
08:02:08 <hseg> bc it kills the search immediately
08:02:31 <hseg> since the first element has already been deleted by the unfolding
08:02:45 <tomsmeding> oh right
08:03:13 <tomsmeding> but then I'd say fix the unfolding :p
08:04:10 <hseg> ofc
08:04:53 <ski> Iceland_jack : `flip' used to have that type, in lambdabot. (and `(.)' in lambdabot used to be `fmap')
08:06:52 * hackage implicit-hie 0.1.2.4 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.2.4 (Avi_Dessauer)
08:08:09 <hseg> http://ix.io/2Fdl even more plumbing, but it works now
08:09:31 <hseg> frankly, orbit feels like a unfoldWhileM :: (a -> m Bool) -> (a -> m a) -> m [a] 
08:10:58 <hseg> actually, should be :: (a -> Bool) -> m a -> m [a]
08:11:29 <ski> @hoogle m (Maybe a) -> m [a]
08:11:30 <lambdabot> Control.Monad.Loops unfoldM :: Monad m => m (Maybe a) -> m [a]
08:11:30 <lambdabot> Data.Typeable gcast1 :: forall c t t' a . (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))
08:11:30 <lambdabot> BasePrelude gcast1 :: (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))
08:13:05 <hseg> hrm... no, that's not quite right
08:13:43 <hseg> orbit :: State (Int, IntSet) [Int]
08:14:23 <ski> not `orbit :: Int -> State IntSet [Int]', then ?
08:14:52 <hseg> you're right
08:14:57 <hseg> thanks
08:15:41 <hseg> right, basically want some kind of iterateUntilM :: (a -> a) -> (a -> m Bool) -> a -> m [a]
08:17:27 <hseg> and indeed, given *more* plumbing could just use unfoldM :: (a -> m (Maybe a)) -> a -> m [a]
08:17:58 <ski> @hoogle Monad m => (a -> m (Maybe a)) -> a -> m [a]
08:17:59 <lambdabot> Control.Monad.Extra iterateMaybeM :: Monad m => (a -> m (Maybe a)) -> a -> m [a]
08:32:05 <ski> hseg : why the name `cycnot' ?
08:32:38 <hseg> cycle notation
08:33:09 <sm[m]> g'day haskellers
08:34:50 <ski> oh, "notation"
08:35:10 * ski was thinking "not" as in negation, and it didn't seem to make sense
08:35:37 <ski> heyo, sm[m]
08:35:55 <hseg> h
08:35:57 <hseg> ah
08:36:23 <ski> ok. so each of the computed permutations are cycles
08:36:35 <hseg> yup
08:36:57 <hseg> basically i'm breaking up the permutation into cycle
08:36:59 <hseg> cycles
08:37:10 <ski> right
08:37:28 * ski was just checking it seems to make sense, for the empty permutation
08:39:26 <ski> hm .. reminds me i was investigating a sort of arithmetic on permutations. addition, multiplication, power/exponential
08:40:00 <hseg> oh?
08:42:22 * hackage gi-gobject 2.0.25 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.25 (inaki)
08:52:54 <ski> hseg : if ‚åúœÄ : A!‚åù and ‚åúœô : B!‚åù, then ‚åúœÄ + œô : (A + B)!‚åù is defined by ‚åú(œÄ + œô) (Œπ‚ÇÄ x) = Œπ‚ÇÄ (œÄ x)‚åù and ‚åú(œÄ + œô) (Œπ‚ÇÅ y) = Œπ‚ÇÅ (œô y)‚åù; ‚åúœÄ √ó œô : (A √ó B)!‚åù is defined by ‚åú(œÄ √ó œô) (x‚ÇÄ,x‚ÇÅ) = (œÄ x‚ÇÄ,œô x‚ÇÅ)‚åù; and ‚åúœô ^ œÄ : (B·¥¨)!‚åù by ‚åú(œô ^ œÄ) f = œô ‚àò f ‚àò œÄ‚åù
08:54:46 <hseg> ok, so basically specializing (|||), (***) and promap to the case that the maps are isos?
08:57:10 <ski> furthermore, you can define ‚åú0 : 0!‚åù as the empty permutation, and ‚åú1 : 1!‚åù as the identity permutation given by ‚åú1 () = ()‚åù. then you can for each positive integer ‚åún‚åù define ‚åúc‚Çô : n!‚åù as the cyclic permutation given by ‚åúc‚Çô i = i+1  ‚áê  i+1 < n‚åù and ‚åúc‚Çô (i‚àí1) = 0‚åù
08:59:29 <hseg> yeah -- the unique permutations on the initial and terminal objects. cyclics are more ad-hoc
09:01:48 <ski> hseg : yes. now the question is how these operations behave, wrt cycle decomposition, e.g. if we work with permutations upto isomorphism on the carrier (so that e.g. ‚åúc‚ÇÇ √ó c‚ÇÉ = c‚ÇÜ‚åù but ‚åúc‚ÇÇ √ó c‚ÇÑ = c‚ÇÑ + c‚ÇÑ = 2 √ó c‚ÇÑ‚åù (where ‚åú2 = 1 + 1‚åù))
09:02:33 <hseg> "perms mod carrier iso" = cycle types, no?
09:03:10 <ski> i think so (if my guess of the meaning of "cycle types" is correct)
09:04:47 <hseg> cycle type is basically the multiset of lengths of the cycle decomposition
09:05:21 <hseg> product of cyclics will be cyclic iff lengths coprime
09:05:45 <hseg> and in general will decompose into gcd*c_lcm
09:06:12 <ski> multiplication distributes over addition. so, to understand multiplication, in terms of cycles, it suffices to understand how to multiply single cycles with each other. as you saw, we can't cancel even multiplication with non-zero permutation. exponentiation of cycles is even more interesting, it can yield a sum of cycles of different lengths
09:06:27 <ski> hseg : right
09:08:20 <b7471> hi
09:08:23 <ski> e.g. ‚åúc‚ÇÇ ^ c‚ÇÇ = 2 + c‚ÇÇ‚åù
09:08:27 <hseg> well, that's unsurprising -- exponentiation is just composition
09:08:29 <ski> hello b7471
09:08:32 <hseg> yo
09:08:41 <b7471> is this the official channel for the programming language haskell
09:08:43 <b7471> ?
09:08:44 <ski> composition on both sides
09:08:46 <hseg> yes
09:08:48 <ski> yes, b7471
09:09:19 <__monty__> b7471: You just joined in the middle of discrete math 101 or 201, not sure.
09:09:39 <hseg> discrete math coffee talk, more like
09:09:52 <b7471> its okay
09:10:07 <b7471> i am having big trouble with haskell
09:10:40 <ski> mhm ?
09:12:37 <hseg> ski: no, i meant you can embed m! in n! for m=<n, and in particular have œÄ^œÉ=œÄ^1‚àò1^œÉ where the composition is the usual one in (m^n)!
09:13:15 <hseg> in particular, it is unsurprising that the composite of two cycles has pretty wild structure
09:13:29 <b7471> is there any book on how to understand the language 
09:13:32 <b7471> _
09:13:33 <b7471> ?
09:17:46 <ski> hseg : yes, that embedding is basically ‚åúœÄ ‚Ü¶ œÄ + id‚Çò‚Çã‚Çô‚åù, right ? hm, your ‚åú1‚åù is identity (on any carrier). hmm
09:17:55 <ski> b7471 : there's several books
09:18:30 <b7471> more university class ,oriented
09:18:34 <hseg> yup. though s/in particular/also have/
09:18:57 <ski> @where PIH
09:18:57 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
09:19:14 <ski> @where HPFFP
09:19:14 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
09:19:14 <hseg> b7471: https://www.cis.upenn.edu/~cis194/spring13/ is pretty good as well
09:19:20 <ski> yes
09:21:10 <ski> hseg : oh, the embedding you used was from ‚åú1‚åù to ‚åúœÄ‚åù respectively to ‚åúœô‚åù ?
09:22:44 <hseg> ski: sorry, mixed two unrelated things. firstly you have the enlarging embeddings. but more relevantly, you also can embed n!,m! into n^m! by exponentiation against the identity
09:23:18 <ski> b7471 : fwiw, i learned using "Haskell: The Craft of Functional Programming" by Simon Thompson
09:23:46 <hseg> and these embeddings decompose exponentiation and commute with each other (basically because of associativity)
09:25:07 <ski> @where HTAC
09:25:07 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
09:25:11 <ski> @where wikibook
09:25:11 <lambdabot> http://en.wikibooks.org/wiki/Haskell
09:27:59 <ski>   œô ^ œÄ  =  f ‚Ü¶ œô ‚àò f ‚àò œÄ  =  (œô ‚àò) ‚àò (‚àò œÄ)  =  (œô ^ 1) ‚àò (1 ^ œÄ)
09:28:02 <ski>                            =  (‚àò œÄ) ‚àò (œô ‚àò)  =  (1 ^ œÄ) ‚àò (œô ^ 1)
09:28:04 <ski> i see
09:30:37 <ski> b7471 : do you have any particular question, or maybe some code you're struggling with ?
09:31:06 <b7471> ski yes i dont know where to begin
09:31:14 <b7471> i mean i cant even declare a variable
09:31:23 <b7471> and we have homework to do
09:31:42 <ski>   x :: Int
09:31:45 <b7471> i couldnt even install a compiler or interpreter in windows 10 or something like that
09:31:50 <ski> will declare `x' to be a variable of type `Int'
09:31:54 <ski>   x = 42
09:32:01 <ski> will define it to be `42'
09:32:11 <b7471> i am using a online interpreter ripl dot it
09:32:27 <Lycurgus> tell the instructor ur skipping the dumb hassell or haskell or whatever and doin a practical lang instead
09:32:52 <b7471> we are expected to create a function , that takes 4 arguments 
09:33:17 <b7471> and only if the 4 arguments are the same , the funktion should output: true
09:33:19 <Lycurgus> do it in one of FP php pkgs, that have currying
09:33:31 <ski> b7471 : hm. tried <https://www.haskell.org/platform/#windows> ?
09:33:31 <xerox_> when I try to run the haskell-language-server over ghcup I get this, anybody knows why? I'm stumped https://paste.tomsmeding.com/6zEhhfAi
09:34:07 <b7471> i cant install chocoletey thing on windows
09:34:12 <ski> b7471 : hm, something like
09:34:13 <b7471> there is no setup or something
09:34:22 * hackage resourcet-pool 0.1.0.0 - A small library to convert a Pool into an Acquire  https://hackage.haskell.org/package/resourcet-pool-0.1.0.0 (brandonchinn178)
09:34:28 <ski>   allFourEqual x y z w = ..x..y..z..w..
09:34:45 <b7471> ?
09:35:00 <koz_> b7471: Chocolatey requires you to use PowerShell. Its site has fairly clear instructions on what you gotta do.
09:35:02 <Sose> isn't there a Windows installer for Stack atleast? and you could use stack to download and run GHC?
09:35:19 <Sose> never installed any haskell tools on windows myself tho.. 
09:35:33 <Uniaika> I think there is indeed a windows installer for stack
09:35:39 <b7471> Sose you will never be able to
09:35:42 <maerwald> xerox_: is that an error even?
09:35:42 <koz_> Perhaps - I don't really recall.
09:35:43 <b7471> not in this age
09:35:49 <ski> b7471 : that would be the start of a function `allFourEqual' that accepts four inputs (parameters/arguments), named `x',`y',`z',`w'. then, after the `=' sign, you'd have to fill in a `Bool'ean expression for checking whether they're all the same/equal
09:35:56 <koz_> b7471: You're literally talking to a minimum of one person who has.
09:36:00 <koz_> (if not more)
09:41:06 <xerox_> maerwald: it starts back up trying ot compile, over and over, after that message
09:41:11 <b7471> i will first watch the online lecture and the try again
09:41:19 <b7471> to understand all of this
09:41:22 <b7471> i hope
09:41:32 <b7471> i will be able within one year 
09:41:37 <b7471> to make sense of all this
09:41:46 <b7471> ist really horrible and bad
09:43:29 <ski> b7471 : you're welcome to ask questions here, if anything is unclear
09:45:47 <xerox_> maerwald: coc.nvim helpfully says "the server has crashed 5 times I won't run it again", vscode just goes head on never stopping
09:45:48 <b7471> how to read the variable 
09:45:51 <b7471> that i declared
09:45:57 <b7471> the variable x
09:46:29 <b7471> :t x
09:46:30 <lambdabot> Expr
09:46:49 <geekosaur6> if you're in ghci or equivalent, just enter x at the prompt
09:48:44 <maerwald> xerox_: no idea, I don't use HLS on ghcup codebase frequently
09:49:05 <maerwald> maybe try to write a different hie.yaml
09:49:14 <xerox_> I was looking for some way to figure out where imported stuff is from
09:49:26 <xerox_> not married to it, just what I thought of, is there anything else I could use?
09:55:13 <ski> b7471 : if you have an interactor, where you can enter expressions and get feedback, you should probably be able to just write the variable name `x' in there (assuming `x' is defined globally in your source file)
09:55:44 <b7471> i am using an online interpreter
09:55:47 <ski> it seems <https://repl.it/> requires a login ?
09:55:50 <b7471> called ripl .it
09:55:50 <ski> yes
09:56:02 <b7471> am i logged in
09:56:31 <ski> if you're using <https://repl.it/>, i'd guess so ?
09:57:10 <ski> (when i click on "Start coding", it asks me to sign up)
09:58:12 <maerwald> xerox_: let me try
09:58:14 <b7471> i signed up to that
09:58:23 <b7471> now i am experimenting with it a bit
09:58:36 <ski> if you write
09:58:38 <b7471> i declared a few variables as you told me to
09:58:39 <ski>   x :: Int
09:58:41 <ski>   x = 42
09:59:01 <b7471> yes a was successful in adding two variables together
09:59:06 <ski> in the part of the editor where you write programs, that should define `x' as a variable in global scope
09:59:31 <ski> if you write e.g.
09:59:44 <ski>   cube :: Int -> Int
09:59:50 <ski>   cube x = x * x * x
10:00:26 <b7471> what does this mean: cube :: Int -> Int 
10:00:33 <ski> then this should define a function, called `cube'. the `x' here is unrelated to the previous `x'. this `x' here is a local parameter name, local to the `cube' function definition
10:00:44 <xerox_> maerwald: I am getting implicit-hie to see if it creates an entry for 3rdparty/
10:00:57 <b7471> ok?
10:00:59 <ski> it means that `cube' is a function that consumes an `Int' as input parameter, and produces an `Int' as output result
10:01:10 <b7471> aha
10:01:14 <b7471> ok
10:01:21 <ski> you could define e.g.
10:01:26 <ski>   isEven :: Int -> Bool
10:01:34 <ski>   isEven n = n `mod` 2 == 0
10:02:13 <maerwald> xerox_: I don't seem  to have this problem
10:02:16 <ski> to define a function (a "predicate"), that given an `Int' as input, gives a `Bool'ean result, being `True' if the input was an even integer, and `False' otherwise (i.e. when it was odd)
10:02:19 <monochrom> xerox_: If you mean "I imported 10 modules, one of them gives me f, I want to find out which", I first try ":info f", usually it's good enough. Bu its can answer can be cryptic. When I feel like a big hammer, I use GHC's -ddump-minimal-imports
10:03:18 <maerwald> xerox_: but I have a cabal.project.local with this content https://paste.tomsmeding.com/Qo3YwsbF
10:03:24 <b7471> and what would this expression mean: fourEqual :: Int -> Int -> Int -> Int -> Bool
10:03:25 <ski> b7471 : so the type of the input parameter comes before (to the left of) the `->', and the type of output result comes after (to the right of) it, in a type signature of a function
10:03:29 <b7471> thats our homework
10:03:52 <ski> yes, that means that it accepts four inputs, all of type `Int', and gives back a `Bool'ean as output
10:04:17 <maerwald> xerox_: also make sure 8.10.2 is the default ghc symlink... I believe there were issues with hls when the project ghc isn't the default one
10:04:17 <b7471> ok i will try to enter that on ripl
10:04:23 <ski>   fourEqual :: Int -> Int -> Int -> Int -> Bool
10:04:27 <ski>   fourEqual x y z w = ..x..y..z..w..
10:04:57 <ski> (you'll have to replace `..x..y..z..w..' by some actual code expression that checks when those four inputs are all equal)
10:05:21 <ski> (of course you can choose other parameter names than `x',`y',`z',`w', if you prefer)
10:06:03 <shapr> xerox_: Are the same person who wrote GoA?
10:06:16 <ski> the lines with `::' in them are called "type signatures". then lines with `=' in them are "defining equations" (or simply "definitions")
10:06:51 <xerox_> shapr: I am hi buddy (:
10:07:02 <shapr> hi hi hi! I haven't seen you since AngloHaskell!
10:07:07 <xerox_> I know!
10:07:14 <xerox_> that was a good time
10:07:31 <shapr> Yeah, lots of fun. It's been a few years though
10:08:03 <shapr> xerox_: 20th anniversary of #haskell in ~20 weeks!
10:08:03 <xerox_> many years at this point in fact‚Ä¶ how time flies
10:08:07 * shapr hops cheerfully
10:08:16 <shapr> xerox_: are you writing Haskell for a living these days?
10:08:17 <xerox_> hopefully on a monocycle
10:08:28 <shapr> haha, yes!
10:08:32 <xerox_> nope! for fun, setting it up to do advent of code :D
10:08:41 <shapr> that does sound like fun!
10:09:11 <shapr> xerox_: do you write code for a living?
10:09:12 <xerox_> how about you?
10:09:24 <shapr> I have a Haskell job, it's great fun!
10:09:33 <shapr> I'm working for SimSpace
10:10:19 <xerox_> looks like serious business
10:11:08 <maerwald> I'm picking rust for a new project, but getting devs doesn't seem any easier than haskellers lol (unless you're a bank)
10:11:22 <maerwald> so there's that
10:12:16 <xerox_> shapr: so yeah I have been programming for a living but I'm not at this very moment in time
10:12:33 <shapr> you saved up enough money to coast for a few years? :-D
10:13:31 <xerox_> thereabouts (:
10:14:14 <shapr> yeah, writing code pays well
10:14:35 <xerox_> maerwald: gen-hie doesn't see 3rdparty on its own, nor your .local magically saves the day, more digging required...
10:14:51 <maerwald> xerox_: which cabal version?
10:14:52 <maerwald> oooh
10:15:07 <maerwald> you must be running 3.2
10:15:14 <maerwald> upgrade to 3.4 prerelease
10:15:53 <xerox_> ok!
10:29:04 <xerox_> maerwald: that helped but the 3rdparty stuff still produces the same errors
10:29:17 <maerwald> but that doesn't matter I think
10:30:23 <xerox_> it keeps going in a loop
10:31:00 <maerwald> ignore the loop, does it actually work? :p
10:34:32 <xerox_> maerwald: nope, both editors hang or give no answers, while running the same neverending output as before in the debug logs
10:35:08 <maerwald> :D
10:37:04 <monochrom> At least it's quiescent now. >:)
10:37:30 <monochrom> (The next best thing you can hope for, if you can't prove termination.)
10:38:30 <hseg> ok, a little refactoring later: http://ix.io/2Feg
10:39:10 <xerox_> I will propose as next best thing having dinner instead, yeah
10:47:49 <hseg> http://ix.io/2Fek
10:48:35 <hseg> http://ix.io/2Fel
10:49:36 <monochrom> dinner and wine are always good
10:57:58 <domenkozar[m]> I'm using async to start two concurrent threads. The first thread is doing stuff and feeding things to a channel. The second one is consuming from channel and doing things based on those message. How could I make the second thread exit once channel is emptied and the first thread is also exited?
11:04:11 <__monty__> domenkozar[m]: Can you send an exit message?
11:04:12 <monochrom> The message type has to include a "quit" case. The first thread has to send the "quit" message.
11:04:42 <monochrom> Lest it's the "does quiescent imply termination?" question again.
11:05:35 <dminuoso> domenkozar[m]: Do you want the second thread to terminate as a "nothing more to do" case, or rather immediately if the first one dies?
11:06:04 <dminuoso> Also, do not forget to consider the case of the first thread receiving an async exception.
11:06:54 <monochrom> Ah yeah, I forgot that too. But it's easy to fix: foo `finally` send quit message
11:09:17 <monochrom> I want to point out that humanity has not thought up any other solution. They have only thought up other packagings of this same solution.
11:10:33 <monochrom> For example Unix and C. The writer process has two commands at its disposable, "write" and "close". The writer has to issue "close" at some point of time. Sometimes this is masked by "if the process dies, the OS calls close for you", but it's there.
11:11:04 <domenkozar[m]> dminuoso: in "nothing to do case"
11:11:09 <monochrom> Well that isn't much different from having two kinds of meessage at your disposal, is it?  s/close/send quit message/
11:11:44 <dminuoso> domenkozar[m]: Then the usual technique is to, indeed, decorate the "things" you feed into the channel with some outer signaling layer
11:11:47 <geekosaur> "send quit message" is just "close" at a higher protocol level
11:11:55 <monochrom> And on the reader side, like wise. You have a "read" command, but it has two kinds of outcomes, "normal" message and "EOF".
11:12:03 <dminuoso> data Message = Done | Do Thing
11:12:06 <dminuoso> And then you have a channel of Message.
11:12:30 <domenkozar[m]> dminuoso: so that the last message is Done?
11:12:33 <dminuoso> Yes.
11:12:43 <domenkozar[m]> hmm that's simple and clever :)
11:12:59 <domenkozar[m]> thanks dminuoso !
11:13:19 <dminuoso> To be fair I just rephrased what monochrom, __monty__ and geekosaur also said above.
11:13:56 <domenkozar[m]> ah indeed, thanks monochrom & __monty__  :)
11:14:29 <__monty__> I definitely don't mind my nick being mentioned in the same breath as those other ones : )
11:23:49 <texasmynsted> If you look at the source here --> https://jaspervdj.be/hakyll/reference/src/Hakyll.Web.Redirect.html#createRedirects 
11:24:04 <texasmynsted> There is a function "redirectToHtml :: Redirect -> String"
11:25:04 <texasmynsted> I do not like the string being used, but I think I have no way to replace it short of writing all my own Redirect logic. Right? The Writable type class already has an instance defined. 
11:27:13 <hseg> ok, final version http://ix.io/2FeB. pretty happy with it, but would welcome improvements
11:31:03 <jcd> I'm trying to make a String into the type "HTTP String", what's the best way to do this?
11:31:30 <dminuoso> That depends on what HTTP even is..
11:31:35 <dminuoso> And what you want it to mean
11:31:48 <geekosaur> depending on where you're doing this, possibly "pure"
11:31:53 <jcd> A user-defined data type.
11:32:01 <dminuoso> jcd: How is the data type defined?
11:32:11 <jcd> data Person = Person
11:32:11 <jcd>   { firstName :: String
11:32:11 <jcd>   , lastName :: String
11:32:11 <jcd>   , age :: Int
11:32:11 <jcd>   , hometown :: String
11:32:11 <dminuoso> Did you define it, or does it appear in a library?
11:32:13 <geekosaur> but that depends on what it is and what instances it has
11:32:30 <jcd> Ignore that ^, still learning the emacs keychords
11:32:43 <dminuoso> @where paste -- jcd 
11:32:43 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
11:36:17 <jcd> https://paste.tomsmeding.com/J6ffGVxv
11:36:28 <jcd> Thank you in advance
11:38:36 <jcd> I want to take input from an arbitrary source, mark it as an HTTP message, and then process the HTTP data structure accordingly.
11:38:37 <geekosaur> that code seems somewhat off
11:39:13 <jcd> tell me about it haha
11:39:46 <geekosaur> readHTTPMessage already does what you want, although it has a pointless "do". I'm not sure what it's supposed to be doing, though
11:43:40 <kuribas> what would be a good alternative to bash?  Something not heavy, but likely installed on any system?
11:43:48 <kuribas> and not python
11:44:07 <kuribas> wait, wrong channel...
11:44:17 <chreekat[m]> Haha
11:44:57 <chreekat[m]> But since you asked, I don't think there is a good alternative, not for scripting the Unix shell anyway
11:45:29 <geekosaur> zsh, but I'm not sure that's an improvement.
11:45:32 * kuribas moving the discussion to #haskell-offtopic
11:45:49 <sm[m]> aw
11:45:49 <geekosaur> and, well, if there were something bettter, there wouldnt be so many bad shell scripts out there
11:46:27 <sm[m]> I think it's bash or python, unless you think writing perl in 2020 is a good idea
11:46:42 <geekosaur> some of us still do
11:47:16 <kuribas> sm[m]: I never found it a good idea :)
11:48:03 <sm[m]> bash + shellcheck
11:48:24 <sm[m]> well.. would you consider make to be an option ?
11:48:46 <maerwald> kuribas: POSIX shell 
11:48:48 <geekosaur> make's going to use bash underneath
11:48:55 <kuribas> I was trying out gauche-scheme, which is nice, but it's sadly not installed on centos...
11:49:31 <sm[m]> o well if you're going to be installing things.. stack scripts can be nice
11:49:34 <kuribas> I'd use haskell, but 2GB isn't exactly lightweight...
11:49:39 <maerwald> other than that, your only option is perl... there's hardly any system out there without it, because gcc toolchain needs it
11:49:47 <kuribas> sm[m]: haskell stack?
11:50:24 <sm[m]> yes
11:51:18 <maerwald> how is that not 2GB?
11:52:27 <kuribas> maerwald: it is
11:52:42 <sm[m]> I didn't assert that.. but I think it could be.. use system-packaged stack & ghc & haskell deps, tell stack script to use those
11:53:17 <maerwald> kuribas: static haskell binary?
11:53:53 <dminuoso> Mmm, I have a mundane task of running some wget commands to scrape a website. What's the least effort to quickly have a thread pool of 5 things to parallelize this a bit?
11:54:14 <kuribas> maerwald: could be, but then it has to be compiled on the same OS.
11:54:35 <maerwald> kuribas: what do you mean?
11:54:52 <kuribas> dminuoso: gnu parallel?
11:55:23 <kuribas> maerwald: I mean linux binaries aren't portable across distros.
11:55:27 <maerwald> they are
11:55:32 <kuribas> because of glibc differences
11:55:34 <maerwald> static binaries
11:55:35 <maerwald> I said
11:55:47 <kuribas> even static binaries
11:55:50 <maerwald> nope
11:55:51 * sm[m] meant "I think it could be economical with space, using less than 2G"
11:55:53 <maerwald> they use musl
11:56:04 <maerwald> how do you think ghcup works across all distros? :p
11:56:43 <maerwald> I even have a github workflow you can copy paste
11:56:45 <sm[m]> now we must ask which platforms are to be supported
11:56:47 <kuribas> maerwald: you use musl?
11:56:50 <maerwald> yes
11:56:57 <kuribas> hmm, nice.
11:57:05 <dsal> jcd: it'd be good to start with type signatures, but in your case `readHTTPMessage = HTTP_Message` so you might as well just use `HTTP_Message` directly.
11:57:06 <kuribas> I should try that...
11:57:27 <maerwald> kuribas: https://github.com/hasufell/stack2cabal/blob/master/.github/workflows/release.yaml#L32
12:01:29 <kuribas> maerwald: I don't see musl there?
12:01:37 <maerwald> kuribas: alpine docker image
12:01:40 <maerwald> it uses musl
12:02:48 <maerwald> so you have two options... you try to use static-haskell.nix and configure stuff for over a week, or just spend 5 minutes with alpine installing some deps :p
12:03:25 <dminuoso> With what I know now, static-haskell.nix is very easy to use
12:03:31 <dminuoso> Assuming you're already confident with nix.
12:03:33 <maerwald> I tried, it didn't work
12:03:44 <maerwald> then a month later someone from Russia found the bug
12:03:57 <maerwald> that's basically how nix is every time
12:04:26 <dminuoso> Do you have any link to that?
12:04:56 <maerwald> https://github.com/nh2/static-haskell-nix/issues/85
12:05:04 <kuribas> maerwald: that's how *any tooling* is.
12:05:13 <maerwald> kuribas: nah, nix is particularly bad 
12:07:33 <nh2> maerwald dminuoso: "Someone from Russia" is quite the odd desccription for qrilka; Kirill is my colleague and a core stack developer.
12:07:49 <maerwald> that was a meme
12:07:56 <maerwald> I know who he is
12:08:09 <nh2> ah sorry, I didn't know that one
12:09:12 <maerwald> If a tool requires me to regularly consult experts, then it's a bad tool :p
12:09:14 <dminuoso> Also, if I look at this bug, it looks like a stack bug.
12:09:19 <dminuoso> Not a nix or static-haskell-nix bug.
12:12:10 <maerwald> I must be cursed then, because whenever I use nix I hit all sorts of bugs and ppl keep telling me those aren't nix bugs :D
12:12:53 <nh2> Well, I have to consult Ben and the Simons regularly for my problems but I'd never call GHC a bad tool :)
12:13:23 <maerwald> here's another one https://github.com/input-output-hk/haskell.nix/issues/229
12:14:07 <dminuoso> maerwald: And that is a very very old GHC issue.
12:14:21 <dminuoso> One that you can just as easily trip into with your favoured alpine containers...
12:14:45 <maerwald> dminuoso: that's weird, because I thought nix is reproducible
12:15:33 <dminuoso> maerwald: Nix is not a silver bullet. The software that is executed by nix has access so things like environment variables.
12:15:53 <dminuoso> It's why things like flakes is coming
12:15:54 <maerwald> then docker seems like a better abstraction, because it doesn't depend on my local environment
12:16:12 <dminuoso> Well, Id argue it's a user error because nix can give you pure environments
12:16:27 <ni291187> Hello
12:16:31 <maerwald> following the README instructions surely isn't a user error
12:17:04 <maerwald> (and I did that for static-haskell-nix as well)
12:17:12 <dminuoso> Well it's still a very old GHC bug
12:17:14 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/issues/8118
12:17:44 <maerwald> dminuoso: can you guess  what the fix is?
12:17:54 <nh2> maerwald: In any case, here's a thing I'm currently trying to do with nixpkgs and Alpine: Build static GTK executables. I got the C part working in nixpkgs (screenshots in https://github.com/nh2/static-haskell-nix/issues/50#issuecomment-558569895 and below) but not yet the Haskell part. I'd like to do the same with Alpine so I can use it with plain stack. Do you know if that's possible?
12:18:36 <maerwald> I haven't done static gtk yet, would have to try. I have a haskell gtk project I could try it on
12:19:11 <geekosaur> gtk likes loading stuff dynamically though
12:19:22 <maerwald> dminuoso: setting the locale is not the fix btw :p
12:19:41 <maerwald> geekosaur: you mean it dlopens?
12:19:49 <geekosaur> yes
12:19:53 <maerwald> blergh
12:19:56 <nh2> maerwald: I would try with plain C first as a stepping stone, if you want to give it a shot I made a mini GTK app with 1 button in C here: https://github.com/nh2/static-haskell-nix/tree/c-static-gtk3-apps/meson-tutorial-gtk
12:19:59 <dminuoso> maerwald: For your particular occurence I do not know. But at its very core it's a GHC bug.
12:20:04 <dminuoso> Or "issue" rather
12:20:20 <maerwald> dminuoso: LOCALE_ARCHIVE=/usr/lib/locale/locale-archive nix-script
12:20:47 <lightwave> Newbie here... I‚Äôve tried to learn Haskell many times... but it trailed off everything because I often got distracted into busy projects because I could learn enough to understand even the short hello world program...  Is there a good book that focus on learning by example?  Most resources out there seem to be theory heavy upfront...
12:20:49 <dminuoso> nix tends to make such problems more apparent because it's more radical 
12:21:17 <dminuoso> @where cis194 -- lightwave 
12:21:17 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:21:18 <sm[m]> @where HTAC , lightwave 
12:21:18 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:21:20 <maerwald> dminuoso: apparently not, because I'm the only one hitting that bug
12:21:28 <nh2> geekosaur: Do you know if it always dlopens stuff, or only for specific functionality? Because my basic button example works so far here: https://github.com/nh2/static-haskell-nix/releases/tag/c-static-gtk3-apps-button-example-2020-11-23
12:21:40 <kuribas> lightwave: learn you a haskell
12:21:47 <maerwald> and that's usually when ppl start saying it's a user error, although all I did wat following the instructions :o
12:22:08 <kuribas> lightwave: http://learnyouahaskell.com  It's focussing a lot on examples.
12:22:09 <geekosaur> specific functionality. in particular there's a mode where it can load a UI from a file and then iirc it dlopen()s the components iidentified in the file
12:22:31 <dminuoso> 21:19:58       maerwald | dminuoso: LOCALE_ARCHIVE=/usr/lib/locale/locale-archive nix-script
12:22:35 <geekosaur> since the components may not be linked into the executable
12:22:40 <dminuoso> Id argue the more proper solution is
12:22:45 <dminuoso> LOCALE_ARCHIVE="${pkgs.glibcLocales}/lib/locale/locale-archive"
12:22:49 <lightwave> Thanks!
12:23:07 <dminuoso> Presumably this happens inside travis ci?
12:23:15 <nh2> geekosaur: Are you referring to e.g. when you make UIs with `glade` (which IIRC saves them to XML files)?
12:23:24 <geekosaur> yes
12:23:29 <maerwald> dminuoso: no, on my computer
12:23:50 <geekosaur> I haven't played with gtk in some years though, something may have changed since I last did it
12:23:51 <maerwald> my project is glade, seems like a perfect test then
12:25:15 <monochrom> "learn by examples" fails for Haskell as soon as you need I/O because Haskell's I/O story requires accepting a tiny little bit of theory upfront.
12:25:17 <nh2> geekosaur: thanks, I've written it down in https://github.com/nh2/static-haskell-nix/issues/50#issuecomment-732405876 and will try it out; I've used glade in the past but only from Python
12:26:47 <hseg> maerwald: that's why we need a diverse OS/packaging ecosystem. done properly, it serves to fuzz test programs
12:27:05 <monochrom> I say that out of real observations here. There were beginners who tried "learn by examples", it quickly degenerated to cargo culting in vain because the beginners could not grasp the difference between "map putStrLn myListOfString" and "mapM_ putStrLn myListOfStrings" because they didn't learn the prerequisite theory.
12:27:11 <maerwald> hseg: who's doing that properly?
12:27:35 <boxscape> what's the function to see what the class of a particular unicode character is again?
12:27:55 <geekosaur> generalCategory
12:27:56 <hseg> can't think of anyone off the top of my head right now
12:28:06 <maerwald> I know of maybe two distros where I'd call a subsections of the packaging done properly. And then there's still a huge part around it that's just outright bad
12:28:55 <boxscape> % generalCategory <$> "Íì±‚àÉ"
12:28:56 <yahb> boxscape: [OtherLetter,MathSymbol]
12:28:58 <boxscape> thanks geekosaur
12:29:49 <dminuoso> maerwald: Do you have old packages installed through nix-env?
12:29:58 <maerwald> dminuoso: no, I wiped it out several times
12:30:53 <hseg> fair. that's the immediate counterargument -- it's quite possible the fuzzing benefits are outweighed by the costs of disjoint projects trying to interface with each other
12:30:59 <dminuoso> maerwald: Mmm, I dont quite understand the state of affairs.. but the underlying cause is a quite interesting change in glibc: https://sourceware.org/glibc/wiki/Release/2.27#Statically_compiled_applications_using_locales
12:31:20 <maerwald> hseg: it gets worse when distros start breaking other distros (yes, there are ways to achieve that)
12:31:20 <dminuoso> At any rate, the problem shouldn't be apparent anymore. You aren't on an old nix channel, are you?
12:31:55 <maerwald> dminuoso: I have no idea. I'm just running a shell script that does nix stuff
12:32:16 <hseg> wait what?
12:32:57 <hseg> are you referring to socially-leading distros making bad decisions that then get cargo-culted?
12:33:06 <hseg> or distros using each other's patches blindly?
12:33:45 <dminuoso> maerwald: Mmm, yeah. This particular bug is still a sad thing, in part it was ignored because a) there's a workaround (that you have to dig for) and b) it doesn't really apply to nixos users..
12:33:59 <maerwald> hseg: famous instance is skype being broken on gentoo, because debian messed with SONAMEs of a library and the developers built skype on debian. The fix wasn't hard, but yeah.
12:34:23 <hseg> :-o
12:34:50 <maerwald> rockstar attitude of packagers
12:35:05 <maerwald> (debian has a history of that...)
12:35:15 <dminuoso> To be fair, it's not like you're paying for any of it. These are just volunteers..
12:35:34 <maerwald> dminuoso: I know. I did packaging for 5 years.
12:37:23 <maerwald> And there's not much between internal hierarchy fights on the one side and yelling users on the other... such rewarding work :D
12:38:01 <dminuoso> Like you just did. :-)
12:38:07 <dminuoso> Well, at least it wasn't directed at them
12:38:57 <maerwald> I don't have any expectations of nix devs
12:39:15 <maerwald> It's when users have expectations and voice them aggressively
12:39:29 <maerwald> I just move on and pick another tool 
12:40:53 * hackage numhask 0.7.0.0 - A numeric class heirarchy.  https://hackage.haskell.org/package/numhask-0.7.0.0 (tonyday567)
12:45:22 <maerwald> nh2: I think we're out of luck. I can't find static library files of gtk+3 in alpine
12:45:39 <nh2> maerwald: can we build them?
12:50:56 <maerwald> https://mail.gnome.org/archives/gtk-list/2018-January/msg00006.html
12:54:25 <nh2> maerwald: that's a bit outdated, see https://github.com/nh2/static-haskell-nix/issues/50#issuecomment-554589400 -- the author of that email merged my fixes to GTK accidentally breaking its static build in https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/1172
12:55:23 <nh2> (it did also work before in autotools, they probably broke it by accident when moving to meson)
12:56:43 <nh2> the backport for gtk3 is https://gitlab.gnome.org/GNOME/gtk/merge_requests/1196 -- should be in gtk3 >= 3.24.13, so the alpine package should have that fix
12:58:31 <hekkaidekapus> nh2, maerwald: <https://gitlab.alpinelinux.org/alpine/aports/blob/master/main/gtk+3.0/APKBUILD>
13:01:08 <nh2> maerwald hekkaidekapus: Yes (thanks!), 3.24.23, so that should have my fix in. So you'd just have to pass the "-Ddefault_library=both" flag to get `.a` files
13:01:32 <Uniaika> hey everyone
13:01:47 <hekkaidekapus> hello
13:01:47 <Uniaika> what can I read in order to better understand fundeps errors in GHC?
13:03:13 <Uniaika> s/in/with/
13:12:07 <nh2> Uniaika: I don't have a great resource on understanding the error messages, but do you know https://ocharles.org.uk/posts/2014-12-14-functional-dependencies.html | https://www.fpcomplete.com/haskell/tutorial/fundeps/ | https://gvolpe.com/blog/functional-dependencies-and-type-families/ ? They show _some_ fundeps errors and explain those
13:12:53 * hackage numhask-space 0.7.0.0 - Numerical spaces.  https://hackage.haskell.org/package/numhask-space-0.7.0.0 (tonyday567)
13:13:45 <Uniaika> nice
13:14:00 <Uniaika> thanks a lot nh2 
13:17:46 <dminuoso> Uniaika: One thing that helped me is understand how GHC reasons in the presence of fundeps.
13:18:51 <nh2> dminuoso: Would be good to know how you did learn to understand that reasoning though :)
13:19:51 <Uniaika> on a related topic, I have this line of code : https://github.com/Kleidukos/Intrigue/blob/main/src/Intrigue/Eval.hs#L52
13:19:59 <Uniaika> that generates this error: https://github.com/Kleidukos/Intrigue/runs/1444428807?check_suite_focus=true#step:5:18
13:22:42 <Raman> ?src reverse 
13:22:42 <lambdabot> Source not found. Do you think like you type?
13:23:00 <uninitializedPtr> > let main :: IO ()
13:23:02 <lambdabot>  <no location info>: error: not an expression: ‚Äòlet main :: IO ()‚Äô
13:23:09 <uninitializedPtr> > this_main :: IO ()
13:23:11 <Raman> ?src
13:23:11 <lambdabot> src <id>. Display the implementation of a standard function
13:23:11 <lambdabot>  error: Variable not in scope: this_main :: IO ()
13:23:23 <Raman> ?src map 
13:23:23 <lambdabot> Source not found. Abort, Retry, Panic?
13:23:23 <uninitializedPtr> > printStrLn 42
13:23:25 <lambdabot>  error:
13:23:26 <lambdabot>      ‚Ä¢ Variable not in scope: printStrLn :: t0 -> t
13:23:26 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
13:23:36 <geekosaur> @src consults a database which contains lies and is not complete
13:23:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:23:37 <Uniaika> > print 42
13:23:39 <Raman> abort
13:23:39 <lambdabot>  <IO ()>
13:23:41 <uninitializedPtr> ?src src
13:23:41 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:23:43 <uninitializedPtr> ?src src
13:23:43 <lambdabot> Source not found. Are you on drugs?
13:23:46 <uninitializedPtr> > ?src src
13:23:48 <lambdabot>  error:
13:23:48 <lambdabot>      ‚Ä¢ Variable not in scope: src
13:23:48 <lambdabot>      ‚Ä¢ Perhaps you meant ‚Äòscc‚Äô (imported from Data.Graph)
13:23:55 <Raman> ?src Eq
13:23:55 <lambdabot> class Eq a where
13:23:55 <lambdabot>     (==), (/=) :: a -> a -> Bool
13:24:16 <Raman> ?reverse 
13:24:16 <lambdabot> Unknown command, try @list
13:24:22 <uninitializedPtr> @list
13:24:22 <lambdabot> What module?  Try @listmodules for some ideas.
13:24:30 <Raman> @list
13:24:30 <lambdabot> What module?  Try @listmodules for some ideas.
13:24:40 <uninitializedPtr> @list null
13:24:40 <lambdabot> No module "null" loaded
13:25:00 <uninitializedPtr> class Nothing where Nothing
13:25:07 <uninitializedPtr> > class Nothing where Nothing
13:25:11 <dminuoso> Use a private message if you want to experiment.
13:25:45 <Raman> ?src Show 
13:25:45 <lambdabot> Source not found. You speak an infinite deal of nothing.
13:26:04 <Uniaika> dminuoso: do you have any idea how I can investigate the error I pasted above?
13:26:18 <nh2> geekosaur: good tip, dynamic loading occurring here: https://github.com/nh2/static-haskell-nix/issues/50#issuecomment-732434989
13:26:42 <dminuoso> Uniaika: Yes
13:27:01 <Uniaika> dminuoso: \o/
13:27:51 <nh2> maerwald: FYI ^
13:31:13 <dminuoso> Uniaika: Consider: class Monad m => MonadState s m | m -> s
13:31:54 <Uniaika> yes
13:31:58 * Uniaika considers
13:32:14 <dminuoso> Given `instance ‚ÄòMonadState (HashMap Text AST) EvalM‚Äô` we have `EvalM -> (HashMap Text AST)`
13:32:33 <Uniaika> yep'
13:33:14 <dminuoso> The line that says:
13:33:16 <dminuoso> constraint ‚ÄòMonadState (HashMap Text (EvalM AST)) EvalM‚Äô
13:33:28 <dminuoso> Means GHC is trying to satisfy this constraint
13:33:59 <Uniaika> which is not ‚ÄòMonadState (HashMap Text AST) EvalM‚Äô
13:34:04 <dminuoso> Right
13:34:07 <Uniaika> but what I don't understand is how I got myself into that
13:34:22 <dminuoso> Type inference.
13:34:26 <Uniaika> damnit.
13:34:27 <dminuoso> % :t ask
13:34:28 <yahb> dminuoso: MonadReader r m => m r
13:34:36 <Uniaika> in my case it's 
13:34:37 <dminuoso> See how ask is *fully* polymorphic in both m and r?
13:34:39 <Uniaika> % :t get
13:34:40 <yahb> Uniaika: MonadState s m => m s
13:34:43 <dminuoso> Oh. same story
13:34:54 <Uniaika> but yeah I see
13:35:10 <Uniaika> dminuoso: would type applications solve my problem?
13:35:23 <dminuoso> Uniaika: type annotations would help narrow it done
13:35:30 <dminuoso> Right now type inference is way too unbounded
13:35:45 <dminuoso> If you type annotate `n` that might give you a clue
13:35:53 <dminuoso> err wait
13:36:56 <dminuoso> My bet is its:             let arguments = eval <$> arguments'
13:37:12 <dminuoso> That's broken
13:37:23 <Uniaika> ooh
13:37:23 <Uniaika> okay
13:37:32 <Uniaika> thanks for the insight!
13:39:03 <dminuoso> Ah not quite
13:39:05 <dminuoso>             let env = (fromVector $ V.zip parameters arguments) <> env'
13:39:07 <dminuoso> This is the offending line
13:39:20 <dminuoso> Everything else stems from its inferred tpe
13:39:33 <Uniaika> changing fmap for traverse seems to have fixed it
13:39:42 <Uniaika> (as in: the other errors now appear in ghcid)
14:04:26 <dminuoso> Uniaika: Generally, if GHC has mismatching types and you cant make sense of it, start by adding type ascriptions or annotations. 
14:04:40 <Uniaika> dminuoso: got it
14:04:45 <Uniaika> I will try to remember
14:05:33 <dminuoso> Uniaika: In larger code, the error could have easily come from the other case-of branch as well, but only manifested in the other branch. Smaller code and type signatures are your only methods sadly
14:05:41 <dminuoso> Unless we ever get type error slices
14:08:50 <dminuoso> (And type error slices would only help much if they were integrated into your editor well, say via hie)
14:09:54 <dminuoso> (Or it would present some really interesting challenges on visualizing them)
14:31:49 <superstar64> has anyone played with something like this before? `data Term f = Fix (f (Term f) | Variable String | Application (Term f) (Term f) | Abstraction String (Term f)`, basically it's `Data.Fix.Fix` but with extra constructors
14:43:53 <int-e> superstar64: probably not, because you can build the extra constructors into `f` instead.
14:45:13 <int-e> data TermF f x = Variable String | Application x x | Abstraction String x | Extension (f x)
14:45:35 <int-e> type Term f = Fix (TermF f)
14:45:47 <int-e> superstar64: ^^ that should be isomorphic to what you have.
14:46:06 <superstar64> seems much uglier to pattern match on though
14:48:45 <int-e> superstar64: There are pattern synonyms. What you may gain from the reformulation is a better understanding for how this relates to Fix, what folds look like... just an overall better fit with existing theory.
14:49:45 <superstar64> welp, i guess i'll rewrite my beta reduction then
14:50:22 * hackage numhask-array 0.8.0 - Multi-dimensional array interface for numhask.  https://hackage.haskell.org/package/numhask-array-0.8.0 (tonyday567)
14:50:47 <maerwald> on nice, lol https://ppig.org/files/2015-PPIG-26th-Sarkar1.pdf
14:50:53 <int-e> superstar64: I probably wouldn't do that. I would rename the 'Fix' though... as suggested it does feel more like an extension point for the data type to me.
14:50:54 <maerwald> so syntax highlighting does help
14:51:09 <int-e> superstar64: It's okay to have specific ad-hoc types.
14:52:00 <int-e> superstar64: I guess what I'm really getting at is that the relation to Data.Fix.Fix feels superficial.
14:54:19 <superstar64> my code might be cleaner if i use recursion schemes anyway
14:55:05 <int-e> superstar64: your choice, obviously... and you should know best what the tradeoffs are
14:56:00 <superstar64> it's 40 lines that i start writing a few hours ago
14:56:05 <superstar64> it's not a big deal
15:08:22 * hackage zeolite-lang 0.9.0.0 - Zeolite is a statically-typed, general-purpose programming language.  https://hackage.haskell.org/package/zeolite-lang-0.9.0.0 (ta0kira)
15:19:53 * hackage bitvec 1.1.0.0 - Space-efficient bit vectors  https://hackage.haskell.org/package/bitvec-1.1.0.0 (Bodigrim)
15:37:48 <sondr3> I'm having some trouble with a parser I'm writing, I want it to parse a multiline string until it either reaches EOF or a specific text. I have been able to get one or the other but not a parser that does both
15:38:32 <sondr3> I got some help earlier and have `T.pack <$> someTill anySingle (lookAhead (string b) <|> string ("\n" <> b))`, but this fails if the string ends with EOF
15:38:46 <sondr3> And I've been looking at my code for too long now :P
15:38:49 <sondr3> ;;;;;
15:39:16 <sondr3> bah, sorry, getting used to Colemak and Moonlander at the same time
15:40:38 <monochrom> I would not use most parser combinator libraries for "anything at all except until this specific string" (unless that specific string is one single character)
15:43:32 <monochrom> A minority of parser combinator libraries feature non-determinism for ambiguous grammars, at the expense of speed. Those would be a good fit.
15:48:23 <sondr3> monochrom: do you happen to know hw 
15:48:43 <sondr3> *how I'd get the rest of the input from megaparsec?
15:50:12 <sondr3> looks like I might be able to use getInput and friends
15:57:41 <sm[m]> hey friends.. what's the function f [a] that is equivalent to a <|> a <|> a <|> ... ?
15:58:43 <hpc> foldr1 (<|>)?
15:58:44 <hpc> ;)
16:02:58 <sm[m]> hpc: seems to work, thanks! :)
16:03:57 <dibblego> asum1 ?
16:04:17 <hpc> you probably want to figure out what to do if the list is empty
16:04:20 <dibblego> https://hackage.haskell.org/package/semigroupoids-5.3.4/docs/Data-Semigroup-Foldable.html#v:asum1
16:05:55 <hpc> oh wait, empty is in Alternative...
16:06:17 * hpc has used up all his smart for the day
16:14:23 <sm[m]> I'm writing a shortest-path function, doing a breadth-first search of a directed graph. Man, I always struggle to put together these recursive searchy functions
16:15:05 <sm[m]> (replacing fgl's sp which isn't doing what I want)
16:16:19 <c_wraith> is the graph cyclic?
16:24:08 <sm[m]> c_wraith: eh.. yes
16:26:06 <sm[m]> and thanks dibblego - that's the one I was looking for
16:26:24 <sm[m]> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Foldable.html#v:asum
17:09:32 <hekkaidekapus> sondr3: Still around?
17:09:39 <sondr3> hekkaidekapus: yep
17:10:46 <hekkaidekapus> Check out this: <https://paste.tomsmeding.com/o2idJSR9>
17:11:30 <hekkaidekapus> The idea is to break down your big parser into small parsers.
17:12:27 <sondr3> oh vey, this looks exactly like what I was asking him about earlier, must've completely missed it
17:12:32 <hekkaidekapus> And try to be specific about what you want to parse, instead of a overly general `anySingle`.
17:13:29 <hekkaidekapus> I left `anySingle` in the example but that should really be replaced by something more fitting to your input.
17:14:48 <hekkaidekapus> By the way, the import declarations should give you enough indications of places where to go and read haddocks.
17:14:57 <sondr3> I've been learning that a lot the last few days, haha, I'm just not very experienced with FP and monadic parsing
17:15:36 <sondr3> Thanks a bunch for your example, I'll look at it in detail tomorrow when I'm more alive
17:15:45 <hekkaidekapus> np
17:17:19 <sondr3> Looks a lot better than the monstrosity I've cooked together now x)
18:10:30 <cads> Is it correct to think about monoids and applicatives as just linear categories internal to category Hask itself?
18:11:27 <cads> Amd can we think of haskell type classes as kind of taking a total space that is hask, and fibering it down to these internal categories?
18:16:01 <cads> I guess the second question is really two question. i) is it a correct/effective process to take haskell and fiber it into type classes? ii) and can these fibers be related to categories and theories internal to hask
18:16:19 <cads> to take hask and fiber it*
18:23:23 * hackage aspell-pipe 0.6 - Pipe-based interface to the Aspell program  https://hackage.haskell.org/package/aspell-pipe-0.6 (JonathanDaugherty)
19:51:41 <MarcelineVQ>  good job, you who is reading this, great work today
19:56:37 <Axman6> @hoogle (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
19:56:38 <lambdabot> Linear.Vector liftU2 :: Additive f => (a -> a -> a) -> f a -> f a -> f a
19:56:38 <lambdabot> Data.Geometry liftU2 :: Additive f => (a -> a -> a) -> f a -> f a -> f a
19:56:38 <lambdabot> Data.Geometry.Vector liftU2 :: Additive f => (a -> a -> a) -> f a -> f a -> f a
19:57:22 <MarcelineVQ> liftA2
19:58:11 <MarcelineVQ> taller cousin of liftA1, aka fmap
20:00:15 <Axman6> except I'm after the alternative version
20:00:30 <Axman6> apply the function if both exist, give me the one if one exists
20:01:39 <MarcelineVQ> \f x y ->litftA2 f x y <|> x <|> y   :>
20:01:47 <Axman6> yeah
20:18:15 <jackhill> win 43
21:10:52 * hackage formatn 0.0.1 - Number text formatting.  https://hackage.haskell.org/package/formatn-0.0.1 (tonyday567)
21:23:22 * hackage readme-lhs 0.8.0 - Literate programming support.  https://hackage.haskell.org/package/readme-lhs-0.8.0 (tonyday567)
21:42:23 * hackage box 0.6.1 - boxes  https://hackage.haskell.org/package/box-0.6.1 (tonyday567)
22:14:53 * hackage box-csv 0.0.3 - See readme.md  https://hackage.haskell.org/package/box-csv-0.0.3 (tonyday567)
22:17:23 * hackage box-socket 0.1.1 - See readme.md  https://hackage.haskell.org/package/box-socket-0.1.1 (tonyday567)
23:52:35 <dminuoso> % f (1|2) = 1
23:52:35 <yahb> dminuoso: ; <interactive>:54:6: error: parse error on input `2'
23:52:45 <dminuoso> Is this type of choice pattern enabled by some extension?
23:52:56 <dminuoso> https://hackage.haskell.org/package/haskell-src-exts-1.23.1/docs/Language-Haskell-Exts-Syntax.html#t:RPat suggests its existence
23:54:46 <dminuoso> Oh.
23:54:50 <dminuoso> % :set -XRegularPatterns
23:54:51 <yahb> dminuoso: Some flags have not been recognized: -XRegularPatterns
23:55:59 <dminuoso> Mmm what is this
23:57:12 <dminuoso> Strange, so cabal seems to know about it but GHC does not
