00:16:36 <merijn> bqv: Good news, I've got a whole list for you, then ;)
00:28:34 <dminuoso> Is there a name for an invertible map?
00:29:07 <opqdonut> dminuoso: I've seen bimap used
00:29:35 <opqdonut> looks like boost and guava use that term, at least
00:29:39 <opqdonut> https://en.wikipedia.org/wiki/Bidirectional_map
00:29:56 <opqdonut> oh, even a haskell package http://hackage.haskell.org/package/bimap-0.4.0/docs/Data-Bimap.html
00:30:17 <opqdonut> unfortunately there's a risk of confusion with https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html#v:bimap
00:30:18 <dminuoso> Ah that seems to fit. I guess bimap in the sense of bijective map
00:30:24 <opqdonut> yeah
00:30:29 <opqdonut> or bidirectional map
00:30:36 <dminuoso> Gotcha, I just need a descriptive term for haddock, so "bijective map" it is
00:30:41 <dminuoso> Thanks!
01:22:52 * hackage protocol-buffers-descriptor 2.4.15 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.4.15 (k_bx)
01:23:52 * hackage hprotoc 2.4.15 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.4.15 (k_bx)
01:40:52 * hackage HsOpenSSL 0.11.5 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.5 (VladimirShabanov)
01:49:17 <kuribas> regarding the "simple haskell movement", would servant be considered "fancy"?
01:49:30 <c_wraith> very much so
01:49:40 <kuribas> then what is the alternative?
01:50:10 <dminuoso> scotty?
01:50:11 <kuribas> for creating a REST API with formal specification?
01:50:14 <c_wraith> there's nothing else that does everything servant does
01:50:28 <dminuoso> "with formal specifications" is very tough in a haskelly sense without enabling extensions
01:50:34 <dminuoso> You'd have to do a runtime OpenAPI thing
01:50:41 <dminuoso> (Which I guess is contrary to what haskellers usually do)
01:50:59 <c_wraith> I mean, I don't give simple haskell much credit, because no one can agree on what's simple anyway
01:51:20 <dminuoso> Or just not do HTTP REST APIs.
01:51:30 <dminuoso> Which I guess is the real crux, it's a very poor language
01:51:46 <kuribas> would, say, f# be better than simple haskell?
01:52:09 <dminuoso> define "better"
01:52:53 <kuribas> I mean in a company context where the steep learning curve of haskell is a problem.
01:53:18 <c_wraith> and there are things no one would ever call simple (like Data.Generics.Labels from generic-lens) that are worth far more than they cost
01:53:49 <kuribas> c_wraith: yeah.  Isn't that because most of the complexity is in the library implementation though?
01:54:00 <kuribas> generic-lens doesn't seem so hard to use
01:54:01 <maerwald> kuribas: servant is for cases where you want to autogenerate clients (or consume the haskell types directly). Most cases of servant I've seen in production do neither. That falls under the "unnecessary complexity" category
01:54:37 <kuribas> maerwald: indeed.  If you make a non-REST web-app, I would say servant is a mistake.
01:54:41 <c_wraith> kuribas: it's *very* easy to use.  The complexity isn't hidden away exactly, though, as it relies on things like IncoherentInstances 
01:55:11 <maerwald> But ppl don't choose their tools based on careful cost-benefit analysis, especially in haskell. They base it on the latest reddit thread about dependent types :)
01:55:46 <kuribas> I absolutely agree that a lot of haskell is overly complicated, for example database libraries.
01:55:54 <maerwald> It's almost as if haskellers get anxiety attacks if they don't keep up with the latest esoteric approaches
01:56:14 <kuribas> maerwald: I think it's more like having a nice new shiny toy to play with
01:56:43 <maerwald> for some, for others its burnout, trying to keep up with the design space... and it's already too large imo
01:57:04 <kuribas> I just think that many extensions, like overloadedLabels, type-applications, aren't that complicated, mostly syntactic sugar.
01:57:29 <maerwald> But most programmers only care about a use case they can tackle with a new language feature. They don't consider the whole design space the feature opens and what the impact on the ecosystem is
01:58:02 <kuribas> maerwald: well, there is no shortage to java jobs, so if you want a simple language, that mostly does the job, you can go to java.
01:58:15 <maerwald> That's a way to make a language fail. But we can argue about whether or not C++ is a failure. I consider it one
01:58:35 <maerwald> kuribas: Java isn't simple at all
01:59:10 <maerwald> Getting generics right in Java isn't easy. Inheritance is massively complicated
02:01:19 <kuribas> whatever language you pick, you need to take a subset that fits beset with your workflow.
02:01:23 <maerwald> Simple also doesn't mean "dumb". How many ppl know that you can use guards in a case expression? You don't see it often. Many don't know all haskell2010 features.
02:02:17 <dminuoso> c_wraith: IncoherentInstances?
02:02:17 <kuribas> also, if you use "simple" haskell, then you are limited to "simple" libraries.
02:02:21 <dminuoso> Why/how is this useful?
02:02:35 <dminuoso> Ive been trying to understand the justification for that extension
02:03:00 <int-e> > let x | let y = 42 in y in x
02:03:02 <maerwald> I'm not arguing for either. I'm arguing that ppl have no real process on how to choose complex vs simple haskell for a problem at hand.
02:03:03 <lambdabot>  <hint>:1:25: error: <hint>:1:25: error: parse error on input ‘in’
02:03:09 <c_wraith> Think of it as "even more overlapping instances"
02:03:15 <int-e> > let x | let y = 42 = y in x
02:03:18 <lambdabot>  42
02:03:22 <maerwald> simple vs complex haskell is a nonsense decision
02:03:27 <dminuoso> c_wraith: Sure, but IncoherentInstances gives me in effect random choice of instances.
02:03:50 <dminuoso> This would make sense if the instances are equivalent, but at that point why have them at all
02:04:02 <int-e> (That we have `let` inside guards is one Haskell2010 feature I was blissfully unaware of until... hmm, 2 months ago?)
02:04:21 <dminuoso> int-e: Indeed, Im quite fond of it :)
02:04:37 <[exa]> oh wow
02:04:42 <c_wraith> dminuoso: not when you carefully set up your instances so that the only type variable that's treated incoherently also doesn't matter to the behavior.
02:04:54 <int-e> let x | y <- 42 = y in x -- I prefer these most of the time
02:05:20 <dminuoso> int-e: That requires an extension *and* has subtly different meaning. It can more easily lead to bugs.
02:05:20 <maerwald> kuribas: but what I read in the current reddit thread is somewhere between naive and arrogant, imo
02:05:44 <c_wraith> dminuoso: pattern guards are part of Haskell 2010, too
02:05:48 <dminuoso> Oh
02:05:58 <int-e> dminuoso: well, the let thing can also lead to subtle bugs... for pretty much the same reason.
02:05:58 <merijn> dminuoso: Everyone always forgets that
02:06:04 <dminuoso> int-e: Say, you have some `newtype T = T Int`, with some `let x | letT t <- x ...`, if you later refactor that into a data type, it will compile just fine but might not mean what you want it to
02:06:24 <dminuoso> In that example no, because a let will generate missing pattern errors
02:06:29 <dminuoso> uhh
02:06:35 <dminuoso> `let x | T t <- x ...`
02:06:46 <dminuoso> `let x | let T t = x ...`
02:06:54 <dminuoso> If you switch T from newtype to data, one of them will warn the other will not
02:07:05 <merijn> I like how the survey blindly copies all GHC -X flags as extensions and thus includes things that are, in fact, already enabled by default because their Haskell2010 :p
02:07:31 <int-e> Well, I did have variable patterns in mind.
02:07:36 <merijn> maerwald: I agree. I see value in "simple Haskell", it's just that blindly saying "these extensions are ok" and "these are not" is way to simplistic for defining simple Haskell :p
02:08:05 <merijn> It's mostly a matter of "do these extensions 'pull their weight'", which unfortunately isn't something you can define a simple universal heuristic for
02:08:11 <idnar> dminuoso: do you mean switch and add more constructors?
02:08:17 <dminuoso> idnar: Right
02:08:25 <int-e> In any case, the point was that it's really easy to miss a corner of the Haskell syntax for years without missing anything.
02:08:26 <kuribas> merijn: that's my take on it too.
02:08:27 <idnar> dminuoso: ahh
02:09:30 <kuribas> merijn: avoid fancy haskell if you can, use it if you can't
02:09:33 <maerwald> I think snoyman approaches the problem from the right angle. Problem focused. But I just think his decisions are mostly wrong :)
02:09:52 <yushyin> haha
02:10:34 <[exa]> merijn: people can still vote against the defaults :]
02:14:36 <merijn> [exa]: I meant that they are not extensions
02:14:48 <idnar> regarding fancy Haskell, it's perfectly possible to make an overcomplicated inscrutable mess without extensions; if you can't easily bring a junior colleague up to speed on the code you're writing (in any language) then consider simplifying the code and/or revising your hiring practices
02:15:10 <merijn> [exa]: Like -XPatternGuards is not an extension in Haskell2010. It's an extension to Haskell98 which (hopefully) no one writes anymore
02:15:25 <maerwald> idnar: not hiring practices... mentoring practices
02:16:07 <idnar> maerwald: well, both :)
02:16:09 <kuribas> idnar: not making an inscrutable mess should be a no-brainer in any language, but sadly it isn't...
02:16:10 <maerwald> if you can't get a junior up to speed, then that's a management and team failurea
02:17:16 <int-e> kuribas: I'm not sure what you mean by no-brainer... it usually requires quite some thought :P
02:17:39 <kuribas> I think getting someone up to speed with an application is way easier in haskell, due to the type system.
02:17:50 <kuribas> int-e: right :)
02:18:24 <kuribas> int-e: I guess what I meant was, taking the effort to clean up technical dept...
02:18:28 <[exa]> merijn: yeah, but it will show how many people may be unaware of the fact
02:18:43 <kuribas> int-e: the effort itself is non trivial of course
02:19:01 <int-e> kuribas: I knew what you meant.
02:19:18 <lucente> I'm having hard time solving this tulpa problem: [(String, Int)] -> [String] where I'm checking whenever [("A", 100)] whenever the Int is greater that 0 I add its tulpa's string to an output. Example [("A", 100), ("B", -1), ("C",36) = ["A", "C"]
02:19:20 <__monty__> I agree, I can't count the number of times I've had to look for a function in a python project, which turns out to be a __call__ method on an object that's "cast" to something else three times before use 😭
02:19:34 <hc> win3 0
02:19:37 <hc> sry
02:20:04 <idnar> kuribas: yeah, it seems like people don't want to take responsibility for the social aspects of programming, but instead replace that with some mindless overly simplistic rules
02:21:09 <__monty__> lucente: Maybe split the problem into pieces. Can you just get rid of the tuples with a value <= 0?
02:22:35 <idnar> kuribas: I can understand why, given the dysfunctional culture at many companies, but…
02:23:14 <lucente> I need to solve it as it's defined [(String, Int)] -> [String]
02:23:45 <lucente> would be glad if you gave me an exp of what you mean
02:23:50 <__monty__> lucente: Sure, but if you can't solve the entire thing at once, divide and conquer.
02:24:01 <maerwald> idnar: yep and with the presented attitude "if you can't understand my haskell, you need to try harder" we're not exactly making positive advertisement
02:24:02 <kuribas> idnar: I came from such a company, and I never want to go back
02:24:23 <kuribas> idnar: I got fired after 6 month for saying my opinion
02:24:34 <__monty__> lucente: Try turning your input from [("A", 100), ("B", -1), ("C",36)] into [("A", 100), ("C",36)].
02:24:52 <maerwald> kuribas: doesn't take six months for me (saying my opinion) :)
02:25:21 <kuribas> maerwald: and getting fired?
02:25:29 <maerwald> haha
02:28:18 <kuribas> idnar: I see that with a colleage of mine.  He's a brilliant programmer, the program architecture is very nice.  However there is hardly any documentation, he's the only one that knows the framework he wrote himself. 
02:28:53 <kuribas> idnar: he also wants to write everything in that framework.
02:29:31 <kuribas> it's just that the code he writes is for himself
02:29:51 <maerwald> in some industries that might be okay
02:30:03 <maerwald> because you don't maintain software everywhere
02:32:56 <idnar> maerwald: yeah; my position is usually more like "if you can't understand my haskell (or python, or…), let me explain it to you" and if I can't do that I probably need to change my code, not my colleagues
02:32:58 <kuribas> this isn't a one-time script, it's a long running daemon.
02:33:58 <kuribas> idnar: I'd say if you cannot understand my code (and you are a capable programmer), I need to either rewrite it or add documentation.
02:34:13 <xsperry> > (map fst . filter ((>0) . snd)) [("A", 100), ("B", -1), ("C",36)]
02:34:15 <lambdabot>  ["A","C"]
02:34:39 <xsperry> > [x | (x,y) <- [("A", 100), ("B", -1), ("C",36)], y > 0]
02:34:42 <lambdabot>  ["A","C"]
02:34:46 <__monty__> xsperry: Providing solutions doesn't help much with learning.
02:37:22 * hackage core-text 0.3.0.0 - A rope type based on a finger tree over UTF-8 fragments  https://hackage.haskell.org/package/core-text-0.3.0.0 (AndrewCowie)
02:38:22 * hackage unbeliever 0.10.0.8, core-program 0.2.6.0, core-data 0.2.1.9 (AndrewCowie)
02:46:23 * hackage vulkan 3.6.12 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.12 (jophish)
02:47:22 * hackage hsemail 2.2.1 - Parsec parsers for the Internet Message format (e-mail)  https://hackage.haskell.org/package/hsemail-2.2.1 (PeterSimons)
02:48:51 * hackage update-nix-fetchgit 0.2.2 - A program to update fetchgit values in Nix expressions  https://hackage.haskell.org/package/update-nix-fetchgit-0.2.2 (jophish)
03:24:22 * hackage registry 0.2.0.0 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.2.0.0 (etorreborre)
04:25:29 <miladz68> hi everyone
04:26:59 <miladz68> I have a code that I cannot make to type check. can someone help me here. I also dont know how to copy the code here. I was told this is the best place to ask these kinf of questions if not I would be happy to be pointed to the right place
04:27:08 <dminuoso> @where paste
04:27:08 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
04:28:03 <miladz68> thank you for your responses. here is the code https://paste.tomsmeding.com/dV1xjvgF
04:28:29 <dminuoso> miladz68: Feel free to use the button "+ Add another file" and then include the type error there
04:29:59 <miladz68> I added the error
04:30:08 <dminuoso> miladz68: Ah I see!
04:30:16 <dminuoso> miladz68: You can't have `Con a` like that
04:30:25 <dminuoso> You could say `Con Int` instead
04:30:31 <dminuoso> % newtype Fix f = Fix (f (Fix f))
04:30:31 <yahb> dminuoso: 
04:30:40 <dminuoso> % data Mex a = Con Int | Ad a a
04:30:40 <yahb> dminuoso: 
04:30:58 <dminuoso> % v :: Fix Mex; v = Fix (Con 12)
04:30:58 <yahb> dminuoso: 
04:31:17 <miladz68> what if I want Con to be generic and not specific on Int ?
04:31:33 <dminuoso> % ex :: Fix Mex; ex = Fx (Fx (Con 2) `Ad` Fx (Con 3))
04:31:33 <yahb> dminuoso: ; <interactive>:23:21: error:; * Data constructor not in scope: Fx :: Mex a2 -> Fix Mex; * Perhaps you meant one of these: `F#' (imported from GHC.Exts), `Data.Functor.Foldable.Fix' (imported from Data.Functor.Foldable), `Ghci7.Fix' (imported from Ghci7); <interactive>:23:25: error:; * Data constructor not in scope: Fx :: Mex a0 -> a2; * Perhaps you meant one of these: `F#' (imported fr
04:31:49 <dminuoso> miladz68: Then you must add another type parameter
04:31:56 <dminuoso> % data Mex t a = Con t | Ad a a
04:31:56 <yahb> dminuoso: 
04:32:11 <dminuoso> % ex :: Fix Mex; ex = Fix (Fix (Con 2) `Ad` Fix (Con 3))
04:32:11 <yahb> dminuoso: ; <interactive>:25:11: error:; * Expecting one more argument to `Mex'; Expected kind `* -> *', but `Mex' has kind `* -> * -> *'; * In the first argument of `Fix', namely `Mex'; In the type signature: ex :: Fix Mex
04:32:13 <dminuoso> err
04:32:16 <dminuoso> % ex :: Fix (Mex Int); ex = Fix (Fix (Con 2) `Ad` Fix (Con 3))
04:32:16 <yahb> dminuoso: 
04:32:40 <miladz68> Ok thanks 
04:33:39 <miladz68> another question though. I Seem unable to understand how ghc resolves types, what is the best place to learn about this? is there a book ?
04:34:26 <dminuoso> miladz68: Mmm, the best literature I know of is Pierces TaPL
04:34:33 <merijn> miladz68: From a basic "I wanna write Haskell" perspective or from "I wanna make this myself" perspective?
04:34:35 <dminuoso> But depending on what you want to learn it could be a bit heavy
04:35:03 <merijn> TaPL is more for the latter perspective :p
04:35:07 <dminuoso> Although..
04:35:12 <dminuoso> Actually there is a very very good talk
04:35:22 <dminuoso> miladz68: https://www.youtube.com/watch?v=x3evzO8O9e8
04:35:34 <dminuoso> There's nobody more qualified to explain how GHCs type inference works than SPJ himself. :)
04:35:44 <merijn> miladz68: For practical "writing Haskell" is sufficient to think of as an equation solver
04:36:15 <miladz68> I want to know how haskell type system works why my code didn't type check and how to write more advanced type level haskell code
04:36:48 <merijn> miladz68: The most confusing effect of that equation solving is that, unlike stuff you see in Java/C++/etc. the type checking is bidirectional
04:36:56 <dminuoso> miladz68: the specific example I can talk you through
04:37:03 <dminuoso> It's not complicated, it's rather simple, actually
04:37:10 <dminuoso> % newtype Fix f = Fix (f (Fix f))
04:37:10 <yahb> dminuoso: 
04:37:11 <kuribas> isn't type checking more like logic programming, but without backtracking?
04:37:17 <dminuoso> % data Mex a = Con a | Ad a a
04:37:17 <yahb> dminuoso: 
04:37:29 <dminuoso> % t :: Fix Mex; t = Fix (Con 2)
04:37:30 <yahb> dminuoso: ; <interactive>:29:28: error:; * No instance for (Num (Fix Mex)) arising from the literal `2'; * In the first argument of `Con', namely `2'; In the first argument of `Fix', namely `(Con 2)'; In the expression: Fix (Con 2)
04:37:35 <merijn> kuribas: I would argue the "logic programming without backtracking" is just "solving systems of equations"
04:38:00 <kuribas> makes sense
04:38:14 <kuribas> as unification is assigning values to variables
04:38:17 <merijn> miladz68: FWIW, I think wanting to "writing more advanced type level Haskell" is a beginners mistake that leads to more pain than productivity :)
04:38:18 <dminuoso> miladz68: For a somewhat detailed guide, check out the video of the talk I linked earlier.
04:38:40 <miladz68> dminuoso please continure. I want to if I can make sense of it
04:38:47 <dminuoso> Alright
04:39:06 <dminuoso> miladz68: What's the type of the *data* constructor `Fix` in the above expression bound to t?
04:39:11 <dminuoso> Monomorphized
04:39:16 <dminuoso> That is
04:39:24 <dminuoso> t :: Fix Mex; t = (Fix :: _) (Con 2)
04:39:27 <miladz68> merjin I am not a complete beginner, I have been wrestling with haskell for 2 years on and off
04:39:32 <dminuoso> What goes into the hole _ there?
04:39:54 <miladz68> let me check with the compiler
04:40:00 <dminuoso> Id rather you use your head
04:41:14 <dminuoso> If you say "I dont know" that's fine, I can go one step back
04:41:16 <miladz68> dminuoso Fix :: Fix f is it corect ?
04:41:29 <merijn> miladz68: Even then, though. I'd consider myself an expert and even in my biggest codebase of like 10k LOC of Haskell, there's maybe 3 lines of advanced type level stuff?
04:41:36 <miladz68> i would appreciate going an step back
04:41:39 <dminuoso> Alright
04:41:44 <dminuoso> Let's start with a simpler example:
04:41:50 <merijn> Well, maybe a bit more if we count GADTs without type level shenanigans
04:41:53 <dminuoso> Just 'c'
04:42:08 <dminuoso> We could play human type inference engine, using intuitive rules we somehow carry in our head
04:42:31 <dminuoso> We know that 'c' :: Char
04:42:31 <miladz68> merjin Oh OK. then i want to learn to understand the type system more
04:42:55 <dminuoso> Then, the data definition of `data Maybe a = Nothing | Just a` gives us `Just a :: a -> Maybe a`
04:43:17 <miladz68> dminuoso, I understan this
04:43:40 <dminuoso> So if we apply `Just` to 'c', that means ((Just :: Char -> Maybe Char) 'c') :: Maybe Char
04:43:45 <miladz68>  Just :: a -> Maybe a
04:44:20 <miladz68> good so far
04:44:25 <dminuoso> miladz68: So one of the type inference rules GHC uses, is for instance, if we know `f :: S -> T` for some arbitrary choics of S and T, and we know that `x :: S`, then we can *deduce* that `f x :: T`
04:45:06 <dminuoso> Anyhow, lets go back!
04:45:46 <miladz68> I didnt get this part So one of the type inference rules GHC uses, is for instance, if we know `f :: S -> T` for some arbitrary choics of S and T, and we know that `x :: S`, then we can *deduce* that `f x :: T`
04:46:58 <dminuoso> miladz68: If `f is a function from S to T, and x is something of value S, then the expression `f applied to x` has type T
04:47:06 <dminuoso> It's a deducible fact
04:47:23 <miladz68> I understand that
04:47:53 * hackage lsp-types 1.0.0.1 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/lsp-types-1.0.0.1 (luke_)
04:48:03 <dminuoso> miladz68: That rule can go in both directions, if it somehow figures out `f x :: T`, it can deduce that `f :: _ -> T`
04:49:06 <miladz68> I think I understand that
04:49:29 <miladz68> I understand it actually, makes sense
04:51:11 <miladz68> dminuoso please continue if you can
04:51:32 <dminuoso> miladz68: So all of this was just unrelated, just wanted to nudge you into the mindset of GHC here.
04:51:58 <miladz68> dminuoso I understand so far
04:52:00 <dminuoso> Lets start off with a simpler but related example
04:52:09 <dminuoso> % f :: Maybe Char; f = 2
04:52:09 <yahb> dminuoso: ; <interactive>:30:22: error:; * No instance for (Num (Maybe Char)) arising from the literal `2'; * In the expression: 2; In an equation for `f': f = 2
04:52:12 <dminuoso> What happened here?
04:52:29 <dminuoso> So the first thing to understand, is that numbers are *polymorphic* values
04:52:48 <dminuoso> What this code really says is:
04:52:56 <dminuoso> f :: Maybe Char; f = fromInteger 2
04:53:04 <dminuoso> So now, if we look at
04:53:05 <dminuoso> % :t fromInteger
04:53:06 <yahb> dminuoso: Num a => Integer -> a
04:53:31 <dminuoso> This will instantiate the tpye variable `a` at `Maybe Char`, and that's *fine*, the type signature allows for this
04:53:43 <dminuoso> but that creates a constraint `Num (Maybe Char)` that we need to solve
04:53:58 <dminuoso> So GHC will look up in its knowledge base, but fail to find a matching instance
04:54:21 <dminuoso> >> This will instantiate the tpye variable `a` at `Maybe Char`,
04:54:30 <dminuoso> The reason GHC does this, is what I explained earlier
04:54:35 <dminuoso> from the type annotation
04:54:39 <dminuoso> f :: Maybe Char
04:54:40 <miladz68> dminuoso let me digest this. this is getting interesting
04:54:42 <dminuoso> It then sees
04:54:51 <dminuoso> fromInteger 2 :: Maybe Char
04:55:07 <dminuoso> So it knows the return type of `fromInteger` must be Maybe Char
04:55:39 <miladz68> dminuoso, so far so good. I understand
04:56:41 <dminuoso> miladz68: Afterwards, you should really watch the video I linked. Its a wonderful talk :)
04:57:00 <dminuoso> miladz68: To introduce a new language, to make the *choice* of a type variable of a polymorphic thing apparent, we will write:
04:57:05 <dminuoso> % id @Int 1
04:57:05 <yahb> dminuoso: 1
04:57:13 <dminuoso> The @Int means "set the type variable to Int"
04:57:24 <dminuoso> So if we have `id :: a -> a`, then `id @Int :: Int -> Int`
04:57:25 <dminuoso> So far so good?
04:57:48 <miladz68> dminuoso good so far
04:58:23 <dminuoso> miladz68: GHC does this internally everywhere, so it's not bad in this discussion.
04:58:33 <dminuoso>  % t :: Fix Mex; t = Fix (Con 2)
04:58:39 <dminuoso> Let's think about what happens here
04:58:52 <dminuoso> First thing, we note that `f :: Fix Mex`
04:59:05 <dminuoso> And we see `t` being bound to `Fix` applied to something
04:59:15 <dminuoso> So using the same reasoning from above, we can therefore deduce
04:59:27 <dminuoso> % newtype Fix f = Fix (f (Fix f))
04:59:28 <yahb> dminuoso: 
04:59:30 <dminuoso> % :t Fix
04:59:30 <yahb> dminuoso: f (Fix f) -> Fix f
04:59:39 <dminuoso> Since we know that's the type of Fix
05:00:02 <dminuoso> To solve for this, we set `f` to some as-of-yet unknown type, call it _t
05:00:13 <dminuoso> So our Fix has type `_t (Fix _t) -> Fix _t`
05:00:22 <dminuoso> We then know that
05:00:32 <dminuoso> Con 2 :: _t (Fix _t)
05:00:40 <dminuoso> (Because it appears as an argument to Fix)
05:00:49 <dminuoso> And we know that `Fix (Con 2) :: Fix _t`
05:01:31 <dminuoso> And we also know that `Fix (Con 2) :: Fix Mex`
05:01:41 <dminuoso> So we can deduce that `_t = Mex`
05:01:51 <dminuoso> If we go plug that knowledge in we notice that:
05:02:00 <dminuoso> Con 2 :: Mex (Fix Mex)
05:02:27 <dminuoso> So recall, how a numbers are polymorphic with that fromInteger:
05:02:34 <dminuoso> Con (fromInteger 2) :: Mex (Fix Mex)
05:03:11 <dminuoso> From the above data type definition we also have: Con :: a -> Mex a
05:04:02 <miladz68> I still cannot see the error 
05:04:06 <dminuoso> Hold on, almost there!
05:04:13 <dminuoso> miladz68: Did you follow so far?
05:04:22 <miladz68> dminusoso Yes
05:04:58 <dminuoso> So since that Con takes a type variable, we too instantiate some as-of-yet unknown type variable
05:05:06 <dminuoso> So `Con :: _u -> Mex _u
05:05:16 <dminuoso> so (fromInteger 2) :: _u
05:05:39 <dminuoso> But, we just established:
05:05:41 <dminuoso> 14:01:39       dminuoso | Con 2 :: Mex (Fix Mex)
05:05:45 <dminuoso> So we know that _u = Fix Mex
05:05:55 <dminuoso> % :t fromInteger 
05:05:56 <yahb> dminuoso: Num a => Integer -> a
05:06:07 <miladz68> Ok
05:06:08 <dminuoso> Here too we set `a` to some as-of-yet unknown type called _v
05:06:23 <dminuoso> So our use of fromInteger has type `Num _v => Integer _v`
05:06:25 <dminuoso> err
05:06:28 <dminuoso> So our use of fromInteger has type `Num _v => Integer -> _v`
05:06:49 <dminuoso> 14:04:55       dminuoso | so (fromInteger 2) :: _u
05:06:55 <dminuoso> 14:05:23       dminuoso | So we know that _u = Fix Mex
05:07:05 <dminuoso> so we have `(fromInteger 2) :: Fix Mex`
05:07:14 <dminuoso> So we know that `_v = Fix Mex`
05:07:37 <dminuoso> We're all done now, but we need `Num (Fix Mex)`
05:07:38 <miladz68> there is no instance for fromInteger 2 :: Fix Mex ?
05:07:45 <dminuoso> But no such instance exists
05:07:50 <dminuoso> So GHC bails out
05:08:41 <dminuoso> miladz68: If you type annotated `2 :: Int` you'd get a better diagnostic. The problem in your case is that numbers are *so* polymorphic, that they keep the type inference going much longer. :)
05:09:09 <miladz68> dminusoso wow, I actually understand it :). thanks. you saved me a week of frustrations
05:09:17 <dminuoso> miladz68: Btw, in that above algorithm, if we are left with any "as-of-yet unknown types" at the end, we will just quantify them back!
05:09:28 <dminuoso> for instance if we wrote:
05:10:01 <dminuoso> `f x = x` we'd say `x :: _u`, so `f :: _u -> _u`, done! Then we generalize back, give the type variable some random name, and then we have `f :: x -> x`
05:10:23 <dminuoso> miladz68: And that in principle is how type inference in GHC works.
05:10:28 <dminuoso> Do watch the video! :)
05:11:20 <miladz68> dminusoso I wil for sure. I feel much confortable with GHC now. Thanks a lot. 
05:12:32 <dminuoso> miladz68: Interesting to note, the consequences of this type inference algorithm, is that GHC can make wrong assumptions about types, sometimes giving unification errors in really strange places.
05:13:42 <dminuoso> (The consequence is not that it will fail to report on errors, but it can lead GHC to just assume a fact, and then go on and keep applying inference rules with that fact)
05:13:59 <dminuoso> If it doesnt work out it *will* error out, but not necessarily in the place you expect it to
05:14:15 <dminuoso> So adding type annotations helps limit how far inference can go
05:14:26 <dminuoso> (So if you ever have strange type errors you cant figure out, add type annotations/ascriptions!)
05:14:57 <miladz68> dminusoso like adding ::Int next to  2 in my example
05:15:01 <dminuoso> Right.
05:15:11 <miladz68> dminusoso and one more question, did you learn all this by watching that one video ? 
05:15:20 <dminuoso> % t :: Fix Mex; t = Fix (Con 2)
05:15:20 <yahb> dminuoso: ; <interactive>:36:28: error:; * No instance for (Num (Fix Mex)) arising from the literal `2'; * In the first argument of `Con', namely `2'; In the first argument of `Fix', namely `(Con 2)'; In the expression: Fix (Con 2)
05:15:24 <dminuoso> % t :: Fix Mex; t = Fix (Con (2 :: Int))
05:15:24 <yahb> dminuoso: ; <interactive>:37:24: error:; * Couldn't match type `Int' with `Fix Mex'; Expected type: Mex (Fix Mex); Actual type: Mex Int; * In the first argument of `Fix', namely `(Con (2 :: Int))'; In the expression: Fix (Con (2 :: Int)); In an equation for `t': t = Fix (Con (2 :: Int))
05:15:48 <dminuoso> miladz68: No, just things you pick up :)
05:15:57 <dminuoso> And other folks in here who helped explain
05:16:13 <dminuoso> (Though I did use the video to understand some subtleties of the type inference involving GADTs)
05:17:15 <miladz68> I will watch the video and try to use my brain more instead of the compiler
05:18:26 <dminuoso> miladz68: http://dev.stephendiehl.com/fun/006_hindley_milner.html is also a good read
05:18:46 <dminuoso> And if you want to dive into the theory and formal methods, Pierces Types and Programming Languages is an excellent read
05:21:22 <merijn> miladz68: Honestly, just doing type inference by hand on a piece of paper helps tons
05:21:38 <miladz68> dminusoso I will check them out both. I think I will checkout the book first. probably will more than a few months for someone without much background is CS theory
05:22:14 <dminuoso> As a cute excercise:
05:22:19 <dminuoso> % :t id
05:22:19 <yahb> dminuoso: a -> a
05:22:22 <dminuoso> % :t flip id
05:22:23 <yahb> dminuoso: b -> (b -> c) -> c
05:22:25 <dminuoso> % :t flip
05:22:26 <yahb> dminuoso: (a -> b -> c) -> b -> a -> c
05:22:35 <dminuoso> Figure out why `flip id` has the type it has! :)
05:23:01 <miladz68> merjin thank sounds exactly like what I would be interested in but I need to see  examples of how it is done
05:25:18 <miladz68> dminusoso I can't believe that example you just mentioned. why is it so ? ok don't tell me. let me think
05:26:24 <merijn> miladz68: It helps to rename the type variables of id and 'flip' so they are unique and then just working out the equations
05:26:56 <dminuoso> merijn: Start like I did. Swap out type variables for "as-of-yet unknown types", perhaps start them with an underscore like I did?
05:27:12 <dminuoso> Write it down on paper or an editor :)
06:12:36 <daydaynatation> I have installed the array package, yet when i try to load it into ghci, it still says it's in a hidden package
06:12:56 <daydaynatation> import Data.Array
06:13:32 <dminuoso> daydaynatation: What do you mean by "installed the array package" exactly?
06:13:49 <daydaynatation> cabal install array
06:13:56 <daydaynatation> cabal install array --lib
06:14:09 <dminuoso> Yeah uh, and how did you start ghci?
06:14:17 <daydaynatation> cabal repl
06:14:38 <dminuoso> Is your cwd inside a cabal project?
06:15:02 <daydaynatation> dminuoso: i see where the problem is. stupid me. i can simply run ghci
06:15:21 <daydaynatation> I had the habit of running stack ghci before
06:17:01 <miladz68> dminuoso :t flip :: (a -> b -> c) -> b -> a -> c   now :t id :: z -> z   so taking z as z=b->c replacing it into id we get id :: (b->c) -> (b->c) replacing into filp we get flip :: ( (b->c) -> b ->c) -> b -> (b->c) -> c and :t filp id :: b->(b->c) ->c
06:17:30 <dminuoso> miladz68: That seems a bit short
06:18:29 <merijn> You're skipping a step there, yeah :p
06:18:51 <dminuoso> miladz68: Let me give you a gist for the first step :)
06:20:20 <miladz68> All did was to interpret id as :t id :: (b->c) -> b-> c and replace it into flip
06:20:34 <miladz68> dminuoso thanks
06:21:51 <tomsmeding> miladz68: sure, but why choose b->c? :)
06:23:11 <miladz68> :tomsmeding because b->c would type check, but I don't know how ghc figures that out. Is that the missing step ?
06:23:34 <tomsmeding> it is :)
06:24:22 <miladz68> tomsmeding i will think more about it then
06:24:25 <tomsmeding> you're applying 'flip' to 'id'; this means that the first argument of 'flip', which has type 'a -> b -> c', must match the type of 'id', which is 'z -> z'
06:28:11 <merijn> miladz68: You get "a -> b -> c = z -> z" which in turn leads to the equations "z = a" and "z = b -> c". Typechecking then consists of validating that none of your equations contradict each other
06:28:39 <merijn> "z = a" and "z = b -> c" is fine IFF "a = b -> c"
06:29:34 <miladz68> merjin thanks. I now see how ghc worked it out.
06:30:35 <dminuoso> miladz68: Im preparing a more slightly more formal write up
06:30:37 <dminuoso> That will probably help
06:30:46 <miladz68> what is this process called ? type checking ? type inferrence ?
06:31:03 <miladz68> dminuoso thanks alot.
06:32:18 <dminuoso> miladz68: type inference is an integral part of type checking
06:33:29 <dminuoso> The important realization is that types are not a value level property, they are of syntactical nature. Values dont have types
06:33:32 <dminuoso> Expressions have types
06:33:37 <merijn> dminuoso: Eh, I disagree
06:33:49 <merijn> You can do type checking without inference, so clearly it's not an "integral part"
06:34:06 <merijn> It's just that both use the same machinery in Haskell
06:34:26 <dminuoso> merijn: You cant do much type checking without at least some type inference, really.
06:34:45 <dminuoso> Say, at the very minimum you likely want some kind of [App] inference rule
06:35:08 <dminuoso> I mean yeah. technically you could, its just that such a type system wouldn't do much for you
06:35:56 <dminuoso> Without inference, this could not be checked for instance: f :: Int; f = (g :: Char -> Float) (x :: Char)
06:36:07 <dminuoso> (Or you'd have to just accept it)
06:36:47 <merijn> wut
06:37:01 <merijn> How does that require inference?
06:37:32 <dminuoso> merijn: how do you infer what the type of `g applied to x` is?
06:37:39 <dminuoso> How do you *know* it?
06:38:00 <merijn> You are conflating the English/logical meaning of infer with "type inference"
06:38:34 <merijn> "Char -> Float" applied to "Char" = "Float" isn't inferring anything
06:38:42 <dminuoso> Of course it is.
06:39:09 <dminuoso> You have to encode the machinery into the type checker to *know* it can do that
06:39:13 <dminuoso> And that's inference
06:39:30 <merijn> You literally have to encode the machinery to type check into any type checker...
06:39:34 <dminuoso> In the above, `g x :: Char` is an inferred type
06:39:39 <merijn> That's what type checker are
06:39:40 <dminuoso> It's certainly not specified
06:39:56 <dminuoso> Hence my statement: type inference is an integral part of type checking
06:40:30 <merijn> Your usage of type inference does not conform to any common usage of type inference like in, say, TaPL
06:41:36 <dminuoso> It's quite as per TaPL
06:43:50 <dminuoso> merijn: The reason you're allowed to assume `g x :: Char` in Haskell, is as per [App] rule in the damas milner type inference
06:44:05 <merijn> I refer you to the fact that type inference is discussed on...page 317 of TaPL and not needed for type checking, e.g. the simply typed lambda calculus
06:44:12 <merijn> Which, according to your definition, it would be
06:44:36 <merijn> dminuoso: There are type checking rules for function application too
06:45:09 <merijn> "Char -> Float" applied to "Char" = "Float" is a rule in even the simplest lambda calculus and doesn't require inference, just an application rule (which you need anyway)
06:45:30 <merijn> You only need inference for function application if you don't annotate functions with their argument types
06:45:37 <merijn> Which you already did
06:46:38 <merijn> I refer you to rule E-AppAbs on page 72 of TaPL :)
06:46:57 <merijn> oh, wait, that's the wrong one, hold on
06:47:43 <merijn> T-Abs and T-App on page 103
06:47:46 <dminuoso> merijn: an application rule *is* an inference rue
06:48:03 <merijn> TaPL disagrees
06:49:02 <merijn> type inference is the "act of computing a principal type for a term in which some or all annotations are left out"
06:49:19 <lortabac> IIRC most type systems presented in TAPL require no inference at all
06:49:29 <merijn> The fact that you can piggyback inference off of the typing rule for abstraction is orthogonal
06:49:31 <lortabac> STLC, System F...
06:49:53 <merijn> Consider the fact that you can't infer RankN types for functions, but you can still type check them
06:50:42 <merijn> You can think of the T-App rule as "a logical inference", but that's not what any of the literature means when they talk about type inference
06:52:21 <dminuoso> 15:47:42         merijn | TaPL disagrees
06:52:23 <dminuoso> Im really curious.
06:52:31 <dminuoso> What you call type inference, TaPL calls type reconstruction
06:52:54 <merijn> It even says "type inference, see type reconstruction"
06:52:54 <dminuoso> The term "type inference" for these "logical inference rules" is used from the beginning throughout the entire book
06:54:00 <lortabac> dminuoso: are you sure? that's not what I remember from reading that book
06:54:12 <dminuoso> lortabac: Im staring at it right now.
06:54:58 <lortabac> it is true that some people prefer saying "type reconstruction" or "synthesis" to avoid ambiguity
06:55:04 <dminuoso> I guess the book is really ambiguous about this
06:55:16 <dminuoso> At some point TaPL says "type reconstruction, sometimes also called type inference"
06:55:50 <dminuoso> but at the same type introduces "inference rules"
06:55:57 <dminuoso> Which are not for type reconstruction, i.e. type inference
06:56:10 <dminuoso> Ah well at any rate
06:58:13 <miladz68> dminuoso and merjin I managed to fix my the problem in my original question. There was something about haskell's type system that I could not get for about a year now. THANK YOU GUYS !!! https://paste.tomsmeding.com/ufeE5VEv
07:05:02 <dminuoso> miladz68: https://gist.github.com/dminuoso/79855d359ea2d21a8184e235870ecb44
07:05:13 <dminuoso> miladz68: Note that ~ denotes equality of types. :)
07:06:38 <dminuoso> Please reload, just corrected a mistkae.
07:15:54 <miladz68> dminuoso Thanks a million time
07:16:46 <miladz68> dminuoso I cannot view secret gist since github has banned people from Iran :(
07:16:52 <dminuoso> miladz68: Hold on
07:17:05 <dminuoso> miladz68: https://paste.tomsmeding.com/zyYW4txr
07:24:15 <miladz68> dminuoso that is just beautiful. It all makes sense now. Haskell type system undestanding unlocked
07:30:56 <dolio> "Inference rules" are indeed not the same thing as "type inference". They merely use the same word.
07:32:56 <hyperisco> type inference is based on inference rules xd
07:33:18 <dolio> You could present type inference using inference rules, but not every inference rule has to do with type inference.
07:51:00 <tomsmeding> where lies the boundary between type checking and type inference? Determining that '(f :: Char -> Bool) ('c' :: Char)' has type Bool may not be "type inference", but what about inferring the type of '\(f :: Char -> Bool) (x :: Char) -> f x'?
07:51:30 <merijn> tomsmeding: There's no inference there either since all intermediate types are annotated
07:51:53 <tomsmeding> what if 'x' had no annotation?
07:51:57 <merijn> "\f -> (f (x :: Char) :: Bool)" would require inference
07:52:03 <ziman> hello, what's the idiomatic way to match on impossible values in pattern clauses? currently i'm using an empty case expression but is there anything shorter, like agda's ()? i can't google up anything somehow
07:52:26 <merijn> 'f :: Char -> Bool' in that example, but the argument type of 'f' nor its result type are specified
07:52:41 <merijn> tomsmeding: You have to reconstruct the argument and return type from context there
07:52:51 <tomsmeding> so it becomes type inference if there is a variable with no annotated type?
07:53:42 <tomsmeding> where annotating the type of a function is understood to also annotate the types of its arguments
07:53:45 <merijn> For example
07:54:41 <dminuoso> ziman: Void + absurd?
07:55:52 * hackage git-annex 8.20201103 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20201103 (JoeyHess)
07:55:58 <ziman> my argument does not belong in Void, it belongs in a GADT with indices that make it empty
07:56:48 <dolio> Can't you just leave the case out, then?
07:57:59 <ziman> it's an annoying coincidence: it's an instance with a single method with a single clause, so when i leave the clause out, it complains that i did not provide the definition for the method
07:58:42 <dolio> Well, I don't think there's anything you can do but empty case, then.
07:58:56 <ziman> right, thank you :)
07:59:05 <ziman> it's not too bad, i was mostly curious
08:04:52 * hackage validationt 0.3.0 - Straightforward validation monad  https://hackage.haskell.org/package/validationt-0.3.0 (typeable)
09:04:15 <ulidtko> what was the deal again with the mtl variation of lazy-IO problem?..
09:05:42 <ulidtko> i have this crappy piece of code built around an ExceptT-ReaderT-StateT-IO stack
09:05:46 <dolio> Huh?
09:05:53 <ulidtko> ... and in it, one action with liftIO's doesn't run any of the side effects
09:06:47 <ulidtko> https://files.slack.com/files-pri/T7F1A4ZHB-F01DGL8QAPR/image.png if you can see that
09:07:40 <ulidtko> I do see the `trace` around the invocation of reportSubstepTimings
09:07:55 <ulidtko> I also see the invocation happening in ghci debugger (duh)
09:08:14 <ulidtko> but I don't the any output from the body of it
09:08:30 <ulidtko> could this be caused by laziness somehow?..
09:10:55 <ulidtko> I've read the Michael Snoyman's stance on this, pretty agreeable https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/
09:12:05 <dolio> Well, your image of (presumably) code is hidden behind a login screen.
09:12:18 <ulidtko> sorry about that, one second
09:12:44 <dolio> trace is also not what people are usually talking about when they say lazy IO.
09:12:59 <ulidtko> http://deaddrop.ftp.sh/il6g41Ic9QJg.png this should be publicly visible
09:13:24 <ulidtko> yeah, please see the code
09:14:15 <ulidtko> I've all of: liftIO . putText; traceIO; unsafePerformIO -- none of them run
09:14:51 <davean> why would they run?
09:14:58 <davean> Nothing there seems to want them to run
09:15:05 <ulidtko> haha
09:15:10 <ulidtko> I want the to run ;)
09:15:15 <ulidtko> pretty desperately in fact
09:15:22 <ulidtko> *them
09:15:53 <davean> so A) wow thats a lot of seperate ways to do unsafePerformIO, why not pick one? B) make it so that moving on at all is dependent on them being run, force them.
09:16:03 <davean> seq, bang, whatever
09:16:12 <dolio> Just don't use unsafePerformIO.
09:16:31 <davean> yah, I mean yes, its not a good thing to use
09:16:36 <davean> and you're using it wrong,
09:16:43 <merijn> @quote not.a.bug
09:16:43 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
09:16:51 <ulidtko> yes, I know -- I won't -- those are just for you to see how frustrated I got
09:16:52 <davean> but even if you were using it right, none of what your doign there depends on the result of the computation
09:17:15 <davean> yah, but I'm confused why you thought these would run - theres no demand.
09:17:26 <ulidtko> you can see the callsite
09:17:44 <ulidtko> maybeReportTimings <$!> zipWithM step [1 ..] execs
09:17:50 <davean> Yah
09:17:57 <davean> That doesn't ask for it to run
09:18:16 <davean> Bangs on the wrong side.
09:18:54 <davean> ulidtko: >> won't inspect the ()
09:19:02 <davean> ulidtko: it knows its (), why would it look?
09:19:14 <ulidtko> well it's a pattern match
09:19:22 <ulidtko> right?
09:19:44 <ulidtko> should force the thing at whnf if I'm not mistaken
09:19:53 <davean> ok, so whats whnf
09:19:59 <ulidtko> *to whnf
09:20:04 <ulidtko> weak-head-normal-form
09:20:05 <davean> whnf of the monad sure
09:20:12 <davean> yes, I'm asking you to think about whnf
09:20:19 <davean> and why it specificly is the one that *doesn't* force this
09:20:42 <ulidtko> ahhhhhhhh
09:20:48 <ulidtko> okay
09:21:09 <ulidtko> so it forces only the toplevel constructor
09:21:33 <davean> Thats what whnf is
09:21:35 <davean> yep
09:21:50 <davean> and now you have your answer
09:22:18 <ulidtko> that actually just improved my understanding, thanks for the questions!
09:22:26 <davean> Thats why I did it :)
09:22:34 <ulidtko> appreciated
09:24:24 <davean> Now, for ethical reasons I'm required to tell you again you shouldn't use unsafePerformIO, the IRB gets on me if I don't.
09:24:45 <ulidtko> I seriously won't, pinky-promise ;)
09:25:01 <ulidtko> just temporary (tm) for debug
09:25:36 <davean> I believe that like drugs, theres a minimum age on unsafePerformIO usage, and its somewhere over 3 years contributing to GHC :)
09:28:41 <Cheery> https://github.com/cheery/haskell-rady
09:28:54 <Cheery> is this enough for a published library, or do you think it'd need something else?
09:30:02 <monochrom> (>>) does not do pattern matching on ().
09:30:19 <davean> right, I think we got that with the whnf discussion?
09:31:00 <monochrom> I was less certain about that.
09:31:18 <davean> Could have been more explicite I guess
09:32:48 <monochrom> Actually, it's like this.  Suppose you look at "f (MyCtor x y) = 0", then WHNF is relevant.  But suppose it's "g _ = 0", then you don't even get to the point of WHNF.
09:33:09 <monochrom> And (>>) is like "x >>= \_ -> y"
09:33:12 <dolio> :t (>>)
09:33:14 <lambdabot> Monad m => m a -> m b -> m b
09:33:23 <dolio> (>>) cannot do pattern matching on ()
09:35:08 <monochrom> Now, that is true or false depending on this trolling: Does "seq x ()" count as pattern-matching on x? >:)
09:36:25 <monochrom> i.e., evilthen x y = x >>= \a -> seq a y
09:37:08 <ulidtko> I actually tried () <- maybeReportTimings suspecting exactly that, but then it simply didn't compile due to the MTL wrappers garbage :/
09:37:40 <ulidtko> monochrom, why is that evilthen ? sorry i don't get it
09:38:03 <monochrom> Because I'm the author and I'm evil.
09:38:22 <ulidtko> whoooosh, that's indeed pretty evil
10:28:22 <tomsmeding> davean: over 3 years _contributing to GHC_? That's quite a tall order
10:29:43 <tomsmeding> monochrom: you're not even a monsterchrom anymore
10:30:17 <koz_> How do you add kind signatures to type variables in type class definitions?
10:30:59 <dminuoso> koz_: What do you mean?
10:31:26 <dminuoso> % class Functor' (f :: * -> *) -- this?
10:31:26 <yahb> dminuoso: 
10:31:33 <koz_> Yes that. Thanks!
10:32:27 <tomsmeding> ghc will probably ask you to use Type from Data.Kind, not *
10:32:36 <koz_> tomsmeding: Yeah, that's all fine.
10:32:52 * tomsmeding actually likes * better for aesthetic reasons
10:33:54 <dminuoso> tomsmeding: For what its worth, I think TypeOperators was a mistake.
10:34:27 <koz_> tomsmeding: I'm the opposite, but that's mostly because I prefer actual language words to APL.
10:34:39 <dminuoso> % :set -XNoTypeOperators
10:34:39 <yahb> dminuoso: 
10:34:44 <dminuoso> % type T (+) = ((+), (+))
10:34:45 <yahb> dminuoso: ; <interactive>:48:8: error:; Unexpected type `(+)'; In the type declaration for `T'; A type declaration should have form; type T a = ...
10:34:51 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-operators
10:34:54 <dminuoso> Is this a documentation bug?
10:35:19 <dminuoso> Or did Haskell2010 get rid of operators as type variables?
10:35:23 <tomsmeding> % :Set -XHaskell98
10:35:24 <yahb> tomsmeding: unknown command ':Set'; use :? for help.
10:35:26 <tomsmeding> % :set -XHaskell98
10:35:26 <yahb> tomsmeding: 
10:35:32 <dminuoso> % type T (+) = ((+), (+))
10:35:33 <yahb> dminuoso: ; <interactive>:51:8: error:; Unexpected type `(+)'; In the type declaration for `T'; A type declaration should have form; type T a = ...
10:35:39 <tomsmeding> awwww
10:35:40 <dminuoso> Apparently a documentation bug then
10:35:55 <tomsmeding> or ghc stubbornly refuses to implement it
10:41:57 <tomsmeding> it's indeed a documentation bug; from Haskell98 at https://www.haskell.org/onlinereport : `"type" <simpletype> "=" <type>`; `<simpletype> -> <tycon> <tyvar_1> ... <tyvar_k>`; `<tyvar> -> <varid>`; `<varid> -> (small {small | large | digit | ' })_<reservedid>`
10:42:35 <tomsmeding> and a parenthesised operator does not match the unicode version of [a-z]([a-zA-Z0-9']*)
10:42:52 <dminuoso> Well Im confident that this was legal in GHC up until 8.x I think?
10:43:15 <dminuoso> It seems like an odd bug
10:44:30 <tomsmeding> my above argument holds unchanged for haskell2010 :p
10:44:45 <jle`> i remember it was true at one point
10:45:19 <tomsmeding> perhaps a ghc implementor thought "why not, it's unambiguous"?
10:45:54 <dminuoso> Well its just odd to explicitly state that it was legal Haskell98
10:46:27 <dolio> It's not that odd for someone to be mistaken.
10:47:10 <tomsmeding> probably a conflation of "in the old days" and "Haskell98"
10:50:11 <fendor> can I give cabal a global configuration to use a global store for multiple users?
10:50:16 <fendor> on a remote server
10:51:30 <geekosaur> that sounds like it's inviting permissions issues
10:51:49 <fendor> probably. so, can't really share the package database across multiple users?
10:52:15 <geekosaur> nope
10:53:16 <geekosaur> betting it'd also uncover bugs if you did find ways around the permissions
10:53:32 * geekosaur wonders how well it handles concurrent access, for one
10:54:26 <fendor> well, concurrent accesses might already happen since cabal invocation might happen in parallel
10:55:34 <dminuoso> Linux as a multi-user. Hah. As if anyone ever does that!
10:55:58 <dminuoso> It's quite interesting how most installations have become de-facto single user.
10:56:36 <geekosaur> servers… although the nature of "user" has changed a bit
10:57:11 <fendor> Then I guess I will v1-install and instruct everyone to use ghci directly
10:57:40 <dminuoso> geekosaur: Right. Instead, we separate with virtualization or containerization nowadays.
10:57:52 <tomsmeding> will it be read-only? that sounds like it would be easier to ensure
10:57:53 <dminuoso> Presumably the reason for this is that the "user" has changed from human to mcahine
10:58:25 <geekosaur> or remote session, which might be either
11:01:42 <dminuoso> And of course there's the proliferation of computers.
11:01:53 <sh9> exit
11:02:25 <dminuoso> Where once time sharing was done to multiplex rare computers to few people, nowadays the personal laptop is more than enough
11:02:50 <dminuoso> So time sharing is rarely necessary anymore unless for supercomputers.
11:24:07 <monochrom> "cabal itself is already parallel" still makes this assumption: two different cabal-install processes install two different packages, therefore even different directories.
11:24:45 <monochrom> So now imagine two users doing "cabal install --lib random-1.2.0.0" at almost but not quite the same time.
11:25:13 <monochrom> and all options and flags and configs are identical so they really hash to the same directory.
11:27:14 <monochrom> "almost but not quite the same time" means imagine a timing that maximally maximize race conditions.
11:27:50 <miguelnegrao> Hi all. Any hints on to get aeson to encode Maps using nested arrays like [["1","2"]]. I need to interchange maps between haskell (aeson) and purescript (argonaut). 
11:28:34 <monochrom> I haven't checked, but the least worst scenerio is both use open(... O_CREAT) so at least one of the two processes bail out early.
11:29:21 <monochrom> Because the alternative---they both write to the same foo.so file "successfully"---is even worse.
11:30:17 <monochrom> Err need O_EXCL too for the least worst scenerio
11:30:38 <monochrom> See? Just don't count on it.
11:31:55 <geekosaur> except linkers expect to be able to overwrite an existing file
11:32:27 <monochrom> Ah, then it's maximally racing fun.
11:32:37 <geekosaur> and my worry is the wider this gets, the more possibilities for concurrency bugs to show
11:34:36 <monochrom> miguelnegrao: Perhaps use an intermediate step of Map.toList
11:35:14 <monochrom> i.e., encode instead the asoociative list [(key1, val1), (key2, val2), ...]
11:36:43 <miguelnegrao> monochrom: yes, that is always a possibility. thanks
11:37:25 <miguelnegrao> monochrom: was trying to avoid creating additional data types, but i guess it will be needed.
11:42:56 <solonarv> miguelnegrao: that doesn't create an additional data type, though
11:43:53 <merijn> miguelnegrao: "avoiding the creation of datatypes" is a good way to write code you regret a year from now ;)
11:43:55 <geekosaur> and we're mostly in favor of more data types because it means the compiler can help you more
11:44:06 <miguelnegrao> solonarv: yes, I know, but I need to create an additional data type record field is changed from map to [(A,B)] to send in json.
11:44:14 <merijn> geekosaur: Also, easier to refactor later if you make them semi opaque
11:44:15 <solonarv> also, yes, creating datatypes is very cheap and easy and you need not be afraid of it
11:44:34 <miguelnegrao> yes, no big deal, indeed.
11:45:46 <solonarv> tangent: I am now wondering why there isn't an 'IsList Value' instance in aeson
11:46:26 <geekosaur> someone just brought that up on -cafe, I think
11:47:02 <geekosaur> fromList is total, toList isn't (or vice versa?)
11:47:28 <geekosaur> they want to split IsList so those aren't both needed
11:47:35 <argent0> Hi, why does this test pass? https://bpa.st/XB6Q
11:47:43 <fendor> How can I garantuee that every user has a specific package in its package scope for interactive developing without having to duplicate the cabal store for every user? Global install is messy...
11:47:46 <argent0> 1 == 2
11:48:30 <solonarv> I approve of splitting IsList in general but I'm not sure how it's relevant in this case (to be clear I was proposing the instance where 'type Elem Value = Value', i.e. lists <=> JSON arrays_
11:49:29 <fendor> argent0, cabal test knows that something has failed by looking on the return code of the executable
11:49:33 <maerwald> fendor: cabal environments?
11:49:44 <argent0> fendor: ok, I'll check that out
11:50:14 <solonarv> er, s/Elem/Item/
11:50:17 <fendor> argent0, e.g. your output is not shown, since your exit-code is 0. What it shows is that the tests ran and the exit code was zero, so everything is fine
11:50:30 <solonarv> oh right that does make toList partial
11:50:32 <fendor> maerwald, how would that work out? I would still need a global store modification
11:51:29 <fendor> afaict
11:51:36 <solonarv> having a global store (i.e. one shared by all users) isn't necessarily a problem, as long as the same package doesn't end up getting installed concurrently and nobody manually modifies the store
11:51:38 <argent0> fendor: thanks
11:52:09 <solonarv> these admittedly aren't trivial preconditions so they might not hold in your case
11:52:11 <miguelnegrao> my issue comes from aeson encoding Map Int String as {"1": "hello"} and purescript argonaut (from memory) as [[1,"hello"]]. I wonder why each one chose to encode it this way. Is it essentialy the same or any advantage of one over the other representation ?. 
11:52:41 <fendor> solonarv, can I configure that somehow? I think they hold, as I only need two packages, basically, tasty and tasty-hunit. Once installed, no user should have to install other packages
11:53:33 <fendor> *the preconditions
11:55:10 <solonarv> fendor: you can pass command-line arguments to cabal telling it which directory the store should be in, and I think you can also set that in a config file somewhere
11:55:21 <maerwald> fendor: cabal-env --name myenv --install optics
11:56:23 <solonarv> miguelnegrao: have you tried monochrom's suggestion?
11:56:23 <fendor> maerwald, but then it references my local cabal store, right?
11:56:42 <fendor> solonarv, true, I will look into it
11:57:20 <miguelnegrao> solonarv: yes, I will use their sugestion.
11:58:11 <tomsmeding> fendor: make the shared directory non-writable for the users?
11:59:20 <fendor> tomsmeding, that's a good idea, that avoids the problems
11:59:26 <fendor> thanks!
11:59:42 <tomsmeding> if it's read-only, you shouldn't have trouble
12:00:01 <tomsmeding> also note the channel you're in, we're fond of read-only things :p
12:02:09 <fendor> tomsmeding, lost connection, dont know if I send it, but I think that is a good idea, thank you!
12:02:26 <tomsmeding> 👍
12:02:38 <tomsmeding> we're #haskell, we're fond of read-only things ;)
12:05:48 <maerwald> I think this is a solved problem with nix... providing interactive environments you can use cabal in
12:05:54 <maerwald> But then you have to use nix...
12:06:17 * bqv /mode +m
12:06:26 <bqv> Now your channel is readonly!
12:08:23 <hekkaidekapus> maerwald: This is fendor, the person who is implementing `cabal-plan why-depends`. So, Nix is ok, I think.
12:10:07 <bqv> hekkaidekapus: that wasn't very readonly
12:10:24 <hekkaidekapus> lol
12:11:10 * hekkaidekapus bqv-wx
12:11:40 <fendor> maerwald, hekkaidekapus, in this case, I am afraid I can't use nix, as it is not my server :(
12:12:11 <hekkaidekapus> I suspect. You are administering some uni box, I guess.
12:12:47 <fendor> yes, but I barely have any rights
12:12:50 <monochrom> Oh that's the perfect excuse for me to op myself so I can declare state of emergency err I mean make read-only properly with "+q *" haha
12:13:32 <hekkaidekapus> hahaha… Boots on the bot :)
12:15:08 <merijn> That was my complaint with Nix too
12:15:23 <merijn> The main usecase I'd want it is restricted uni machines, but it's impossible to install there :p
12:16:54 <hekkaidekapus> merijn: You can tame a NixOS install inside a container.
12:17:25 <merijn> That's moving the goalpost to getting the container working and somehow configuring it to flawlessly pass through hardware :p
12:17:31 <bqv> merijn: you could with proot or some other permissionless chroot thing
12:17:59 <bqv> Theres even a fuse permissionless overlayfs somewhere
12:18:15 <merijn> hah...as if fuse is installed or usable
12:18:21 * hackage reflex-ghci 0.1.4.2 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.4.2 (abrar)
12:18:28 <bqv> Honestly I reckon nix outside nixos is just masochism though
12:18:39 <bqv> Ditto guix
12:21:43 <dolio> I thought people generally said the opposite. Nix is good, but NixOS isn't.
12:23:13 <hekkaidekapus> I’d say, NixOS is good for coding. For general Linuxing, I find it not so good.
12:26:50 <fendor> I like the ideas and it is really cool once it works, but indeed, it is a lot of work and a lot of pain to setup stuff
12:27:44 <geekosaur> they made configuration a packaging problem
12:33:36 <bqv> dolio: definitely agree with that, but that's not to say there's much you can do with nix without depending on nixpkgs, which is built around the idea of nixos
12:34:41 <dolio> Yeah, I think it has to do with what hekkaidekapus said. It's okay for a build system, but you might not want your whole computer experience to work that way.
12:35:45 <dolio> I guess it could be possible to be better for the former if you weren't trying to enable the latter, though.
12:58:31 <koz_> I'm a bit unclear on what this instance is saying: http://hackage.haskell.org/package/attoparsec-0.13.2.4/docs/Data-Attoparsec-Internal-Types.html#t:IsString
12:58:54 <koz_> Does the 'a' refer to the _first_ type parameter of 'Parser i a' in the instance?
13:00:39 <geekosaur> the i there is what all the others call a
13:01:24 <geekosaur> I think. haddock has been known to drop stuff on the floor, leading to odd types
13:01:39 <c_wraith> I'm a bit annoyed by there being overlapping instances there.
13:01:56 <geekosaur> and I don't see how that can work as haddock is showing it, hm
13:02:27 <geekosaur> I also distrust the a ~ ByteString one, on general principles
13:02:36 <c_wraith> well yes.  implicit encoding is bad.
13:02:40 <koz_> Yeah, I just realized that this actually compiled a mistake of mine.
13:02:59 <koz_> I did a small refactor, it stopped compiling, and I was like 'oh wait, wat, why did this compile?'.
13:03:08 <geekosaur> ah, I get it, different Parser there
13:03:35 <geekosaur> qualifieid vs. unqualified. so it's the same a and there's a "hidden" Text
13:04:06 <koz_> OK, easily fixed then. Thanks - I was wondering what was up there.
13:04:13 * geekosaur peeked at the source link
13:04:31 <c_wraith> yeah, that's annoying that the docs just show them as "Parser" when in order to be properly kinded, those have to be some other type
13:05:02 <c_wraith> I guess the instances don't overlap, though.
13:05:05 <c_wraith> So that's nice.
13:29:39 <bqv> wouldn't it be nice to have a String class, so you don't have to pack and unpack strings constantly and generally have all three string libraries available
13:30:00 <dolio> Like IsString?
13:30:12 <bqv> what are the operations of that
13:30:22 <bqv> i didn't think it had any outside GHC internal
13:30:34 <dolio> It's for overloading strings mostly.
13:30:56 <bqv> yeah, i meant like one where you could switch between string types painlessly
13:31:01 <geekosaur> I think they're thinking of MonoFoldable/MonoTraversable
13:31:18 <geekosaur> let's just say they're not highly regarded
13:31:24 <bqv> :(
13:31:39 <dminuoso> bqv: Well there is text-encoding
13:31:46 <dminuoso> err text-conversions
13:31:59 <dolio> What does 'switch' mean here?
13:32:04 <geekosaur> when things work, they work well. but when they don't work, they're truly terrible
13:32:42 --- mode: card.freenode.net set +o ChanServ
13:33:07 <dolio> The API surface of strings is probably too large to overload in a single class nicely. It's more of a module parameterization thing.
13:33:07 <bqv> dolio: well, for example, say I'm interacting with a library that requires Text, and another that requires ByteString, but my internals generally just use String
13:33:18 <dminuoso> bqv: Take ByteString out of that equation
13:33:26 <dminuoso> ByteString is *binary* data, not textual data
13:33:41 <bqv> that doesn't solve the issue, though
13:33:44 <dminuoso> Once you learnt to accept this, it becomes just a String <> Text issue
13:33:50 <bqv> I can't mandate that others write packages properly
13:33:54 <bqv> i'm not god :D
13:34:02 <dolio> You can not use them.
13:34:19 <bqv> hmm
13:34:32 <dminuoso> bqv: From experience, ByteString is usually used correctly. So if a library exposes ByteString to you, it means decoding is *your* problem
13:35:10 <bqv> so basically the current state of affairs is optimal?
13:35:21 <dminuoso> Well String/Text is not optimal
13:35:26 <dminuoso> But ByteString is frequently misunderstood.
13:35:30 <merijn> No, but the optimal state doesn't involve "less string types" :)
13:35:34 <merijn> If anything we need more :p
13:36:06 <dminuoso> Text8, Text16..
13:36:13 <davean> bqv: no, we should get a lot of String out of the ecosystem
13:36:26 <davean> bqv: the previlence of String is definately a lasting problem we have
13:36:44 <davean> But there are some tools to use them better and be more polymorphic over them also
13:36:56 <davean> We have a lot of tools for that in type class heirarchies
13:37:15 <davean> f you think in properties types move to the edge more.
13:37:29 <dminuoso> bqv: Im in fact quite glad people expose ByteString often, forcing you to deal with de/encoding.
13:37:48 <bqv> hmm
13:38:05 <bqv> so now the impression i'm getting is that avoiding String as much as possible is best?
13:38:15 <dminuoso> It depends on what you do, really.
13:38:36 <dminuoso> String is not nearly as bad as some people make it out to be, GHC has some good optimizations for it
13:38:48 <dolio> Part of the reason String is so persistent is that it isn't really that bad for a lot of stuff.
13:38:50 <sm[m]> +1
13:39:09 <MisterG> well ... https://www.youtube.com/watch?v=6a6xfFmwFwM
13:39:19 <dolio> Because not every use of strings is some super performance critical thing.
13:39:31 <sm[m]> String is simple, conserving developer brain cycles, which is often the priority
13:39:52 <bqv> but I see the idea. If bytestring has the purpose outlined by dminuoso, and text is the de-facto textual data type, taking string out of the picture makes the whole thing ideal
13:40:16 <sm[m]> if text were as easy to use as String, then maybe
13:40:29 <dminuoso> I'd move to rename ByteString to ByteBuffer though, so we dont get as many confused beginners.
13:40:30 <davean> I find them easier personally, they have better characturistics
13:40:38 <davean> dminuoso: thats ... sensible
13:40:55 <davean> dminuoso: That might actually fix a lot of the screwups I see
13:40:55 <bqv> ^
13:40:56 <sm[m]> dminuoso: or Bytes
13:41:15 <davean> I never realized they'd think of the "String" in "ByteString" as textual.
13:41:22 <davean> That ... thats shocking to me
13:41:41 <bqv> davean: well consider other languages, there isn't always the distinction
13:41:45 <bqv> in fact the rarely is
13:41:59 <bqv> and in particular for FFI stuff, you would generally end up using bytestring for text
13:42:46 <davean> bqv: because with FFI you *specificly* have to talk about encoding always
13:42:51 <davean> its inherent to being FFI
13:43:05 <bqv> exactly, but that doesn't make it any less textual data
13:43:25 <dminuoso> davean: Anyway, the term "string" is really fuzzy and hard to define correctly.
13:43:26 <bqv> coming from a closer to baremetal language, you'll be thinking of that
13:43:39 <davean> dminuoso: its a Rope, only worse.
13:43:44 <bqv> lmao
13:43:45 <davean> (No it isn't)
13:44:05 <dminuoso> Well, a rope is made of strings..
13:44:08 <davean> Haskell really could use a better Rope package
13:44:12 <dminuoso> In both senses of both words!
13:44:50 <dminuoso> I mean if a "string" is understood as a sequence of characters, that begs the question of "what a character" even is.
13:44:58 <dolio> Hasn't Ed made one?
13:45:01 <bqv> well anyway, sm[m], what are the main inconveniences of Text? (does overloadedstrings allow concatenation with `++`?)
13:45:12 <dminuoso> bqv: Annoyance with String is all, really.
13:45:22 <dminuoso> Or if you want to deal with non-unicode textual data
13:45:29 <bqv> hm
13:45:34 <sm[m]> bqv: the biggest is just the dance required to import it
13:45:56 <bqv> cool. in that case i'll just build the habit of not using String
13:46:05 <dminuoso> bqv: Also, its backed by utf16 currently. That might not be ideal for some special uses.
13:46:21 <davean> dolio: Yah, I'll I'll be the first one to tell harmless his sucks :)
13:46:29 <dminuoso> (There exist text-short and text-utf8 packages if those are needed)
13:46:30 <dolio> Hahaha.
13:46:31 <sm[m]> it can have unpredictable performance (cf recent reddit post)
13:46:32 <bqv> heh
13:46:37 <dolio> I guess that's why he wrote another one for coda.
13:46:55 <dminuoso> bqv: At any rate `text` is a very safe default when dealing with non-trivial amounts of textual data.
13:47:06 <dminuoso> Without any major deficits
13:47:40 <sm[m]> and it's harder to do list-like construction/operations with it
13:48:21 <sm[m]> there's lazy and strict variants to deal with
13:48:48 <dminuoso> It's similar to how Vector is a good default if you need a memory efficient array with cheap random access
13:48:53 <sm[m]> literals require OverloadedStrings, which may interfere with other things.. etc.
13:49:12 <dminuoso> sm[m]: You can just write `T.pack "foo"` in those places though
13:49:16 <dminuoso> It's not a big issue
13:49:40 <sm[m]> sure, but all of these things add up and make it less convenient than String
13:49:47 <bqv> ack.
13:49:55 <sm[m]> convenience is a big issue in my book
13:50:29 <bqv> well, i suppose at any rate, if bytestring is out of the picture in almost every context, it isn't so heinous
13:50:29 <dminuoso> sm[m]: Heh, Im debating between convenience of Int everywhere, or proper cross-platform support in an upcoming library right now.
13:50:40 <dminuoso> I really want this to have a guaranteed 32 bits..
13:50:51 <dminuoso> (And Word32 will cause a lot of fromIntegral friction)
13:50:54 <bqv> back when i started haskell the string types were my biggest headache i reckon
13:51:01 <sm[m]> of course, when you need what text provides, String becomes the inconvenient/wrong one
13:51:39 <dminuoso> bqv: The prevalence of String is arguably one of the biggest warts in Haskell. :(
13:51:58 <sm[m]> myself, I don't seem to have really needed text in my haskell career yet. I guess I'd need to be storing large amounts of it and wanting to save memory
13:52:03 <dminuoso> In a perfect world, we could use backpack to switch between String and Text, depending on what we want
13:52:19 <bqv> backpack?
13:52:25 <davean> sm[m]: its not about memory, the performance of string is abismal even in small pieces of code
13:52:27 <sm[m]> though I've been benefitting from it's use in many libs, probably
13:52:31 <dminuoso> bqv: Are you familiar with ML functors?
13:52:46 <bqv> i'm familiar with haskell functors, at least
13:52:52 <dminuoso> Different thing entirely :)
13:52:56 <sm[m]> davean: everyone says this, but I haven't experienced it in my code
13:53:03 <bqv> i have a vague comprehension of category theory
13:53:10 <bqv> i won't pretend to be a master
13:54:12 <tomsmeding> dminuoso: are those parametrised modules?
13:54:20 <dminuoso> tomsmeding: Yeah
13:54:24 <tomsmeding> bqv: Futhark also has those, if you just so happen to know that language :p
13:54:56 <dminuoso> bqv: Roughly and havingly, backpack lets you parametrize a package by another.
13:55:07 <dminuoso> *handwavingly
13:55:19 <bqv> interesting
13:55:45 <dminuoso> So rather than depending on some modules, you depend on some signature. And backpack can fill that signature in with some matching stuff.
13:56:54 <justsomeguy> Roughly speaking, what does a signature consist of? Is it a type signature for functions that are members of the module, or something?
13:57:04 <sm[m]> davean: ..and I've seen a few other folks say the same, so I think it must depend. Perhaps it's more apparent when working with large strings ? I ported hledger from String to text and the difference was not huge. 
13:57:07 <bqv> that's actually very cool
13:57:39 <davean> sm[m]: Oh yes, its walking the spine thats so slow - O(n) vs. O(1)
13:57:42 <dminuoso> justsomeguy / bqv: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#module-signatures
13:59:12 <bqv> excellent
13:59:23 <sm[m]> so perhaps when working with many small strings, text is not such a win; and I think that's a pretty common case
13:59:28 <tomsmeding> sm[m]: "not huge" -- do you remember roughly how much it did save?
13:59:49 <davean> sm[m]: It adds up on total volume of string, not length of any given
14:00:08 <dminuoso> bqv: In case you ever encounter it in the future, ML functors are roughly the same thing (albeit much more powerful), giving you parametrized modules (that is functions returning *modules*)
14:00:25 <dminuoso> (or, you could think of backpack as a simpler form of ml-functors)
14:00:40 <bqv> i see, fair enough
14:01:35 <sm[m]> tomsmeding: I see "most hledger types have been converted from String to Text, reducing memory usage by 30%+ on large files". I don't remember the time change, perhaps it was similar
14:01:39 <dolio> It is essentially the same thing, but you need to do the management in cabal files and such, not just as constructs in the language.
14:02:03 <dminuoso> dolio: They are limited because it's static in cabal, ml functors you can just apply to different things at the same time.
14:02:15 <davean> sm[m]: remember the GC has to walk strings also
14:02:19 <tomsmeding> sm[m]: neat, thanks! nice factoid
14:02:21 <davean> sm[m]: so just HAVING strings in memory hurts performance
14:02:44 <dolio> You can apply a backpack 'functor' to multiple modules, too.
14:02:47 <dminuoso> Oh?
14:03:17 <hekkaidekapus> bqv, justsomeguy: <https://github.com/haskell-backpack/backpack-str/blob/master/str-sig/Str.hsig>
14:03:25 <dolio> Yeah, but it all happens in the cabal file.
14:03:26 <davean> sm[m]: if you just allocate a large string and do something else in your program, your performance suffers a lot
14:03:28 <bqv> i was about to ask a question but i think i just answered it with text-show
14:03:50 <dolio> Or whatever you're using. I guess there's some just-GHC way to use it, but I ignored that mostly.
14:03:52 <davean> sm[m]: its the very *existance* of strings in the program that cause issues
14:04:14 <sm[m]> davean: ok, but I'm reporting my experience so far. Issues have been minimal
14:04:31 <sm[m]> I think people are too quick to condemn String, without measuring or considering context
14:04:45 <davean> I messure religiously
14:05:09 <sm[m]> I mean, People at large, not you of course. Which gives String and haskell an unnecessarily bad rep
14:05:25 <davean> Maybe, most people don't understand Haskell performance it seems.
14:06:14 * monochrom disbelieves in simpletonic "rule of thumb", "best practice", "code smell".
14:07:06 <dminuoso> We have a latency critical application. We have String in all kinds of places, except in the code generation where we just use `prettyprinter`. All our performance issues were of algorithmic nature, and the odd lack of sharing.
14:07:33 <davean> dminuoso: oh interesting. I'd LOVE to know about your lack of sharing
14:07:40 <davean> that sounds very interesting
14:08:01 <dolio> dminuoso: http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
14:08:13 <dolio> Search for "using both insantiations at once"
14:08:22 <bqv> sm[m]: but surely it's pretty reasonable to want to avoid marshalling between Text and String all the time, which is undeniably less efficient than any alternative. then at that point, your use of which one all but depends on what libraries you use
14:10:36 <sm[m]> bqv: you're right
14:11:27 <dminuoso> davean: Oh it's really not that interesting. It's just when you defeat MMR by being very explicit with type annotations..
14:11:46 <ski> bqv : ML functors is something else
14:11:49 <ski> @where on-functors
14:11:49 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
14:12:13 <davean> dminuoso: Oh! Thats 2 slides of my talk!
14:12:25 <davean> dminuoso: I specificly focus on that and when to be how strict
14:12:32 <davean> and how much to unpack and why
14:12:40 <sm[m]> bqv: that is to say, if your data is not big enough to require text, then easy interop with the libs you're using is probably the best way to choose
14:12:41 <dminuoso> davean: Did you hold that talk already?
14:12:52 <davean> No, thrusday at Haskell Exchange
14:12:58 <davean> I was recently tricked into it
14:13:06 <dminuoso> Ah, are they still selling tickets?
14:13:10 <dminuoso> Seems so, mmm.
14:13:15 <davean> I'm currently desperately getting the talk together if you want to review it
14:13:39 <dminuoso> I could take a peek, sure
14:14:02 <dminuoso> I kind of missed this years Haskell eXchange because it was so rushed..
14:14:17 <dminuoso> (Guess it's still the aftermath of the bankruptcy)
14:15:55 <sm[m]> bqv: if you're interested, http://hackage.haskell.org/package/foundation-0.0.25/docs/Foundation-String.html is a third option, but it doesn't seem to have got much traction
14:17:10 <bqv> heh, yeah, if it would require explicit marshalling then i don't see myself using it much either
14:18:21 * hackage registry 0.2.0.1 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.2.0.1 (etorreborre)
14:18:50 <sm[m]> there'll always be some marshalling/conversion, since different types of text-like data arise in the wild. Ideally we'd minimise it though
14:20:39 <sm[m]> maybe the aforementioned http://hackage.haskell.org/package/text-utf8 has superseded that foundation type
14:24:50 <bqv> so this is one where backpack would be nice
14:25:04 <bqv> because you have the same ABI, but different types
14:25:08 <bqv> so mixing and matching won't work
14:25:19 <bqv> *API
14:30:21 <hekkaidekapus> bqv: Yes, the String case is a poster-showcase of what Backpack can do.
14:30:39 <bqv> well, text, in that case, but yeah
14:30:52 * hackage pandoc 2.11.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.11.1 (JohnMacFarlane)
14:51:20 <bqv> geekosaur: do you also dislike classy-prelude?
14:55:53 <dminuoso> hls-haskell/emacs question: I have a multi-component cabal project, it seems that setting up the cradle fails because it does not know which sub-component to use for my source code (it seems to always use the same component)
14:56:24 <dminuoso> Is there a way to tell hls to pin to a particular target?
15:02:25 <hekkaidekapus> dminuoso: Are you aware of #haskell-ide? I hear it is the place where prompt answers are provided for questions like yours.
15:03:04 <Uniaika> -> #Haskell-ide-engine, hekkaidekapus 
15:03:25 <hekkaidekapus> Uniaika: oopsie, thank you for the correction.
15:06:57 <dminuoso> hekkaidekapus: Ahh, cheers. I was not :)
15:28:05 <irc_user> I was looking at some elm vs purescript discussions and I see a lot of people talking about how you have to write a lot of boilerplate in elm because of lack of type classes. What exactly is the boilerplate that one would have to write in the absence of type classes?
15:29:55 <dminuoso> irc_user: So imagine you wanted to compare two lists for equality. What function would you use?
15:30:45 <irc_user> Hmm sorry I'm not totally into functional yet, but I would probably iterate over them? dminuoso 
15:31:02 <dminuoso> I mean fundamentally, the statement is incorrect since anything you can do with typeclasses, you can do with explicit dictionary passing
15:31:10 <dminuoso> But what typeclasses buy you is coherence
15:31:35 <dolio> Well, also, adding dictionary arguments for everything you're 'overloading' by is boilerplate.
15:32:05 <irc_user> "dictionary"?
15:32:26 <dminuoso> Say I hand you a `Set Thing`, and you give some `Set Thing` back. If you're just a library author, you can know about my Thing, so withot some funky tricks you cant operate on that Set with a different Ord
15:34:11 <dminuoso> irc_user: GHC implements typeclass instances as dictionaries/records. So when you write `f :: Num a => ...` then under the hood this becomes a function taking a `Num a` record, that contains all the method implementations.
15:34:22 <dminuoso> (In the absence of optimizations)
15:34:25 <bqv> > showsPrec 0 "test"
15:34:27 <lambdabot>  <[Char] -> [Char]>
15:35:05 <dolio> Also, having to manually specify how to build dictionaries for `List a` out of dictionaries for `a` every place you want the former is boilerplate.
15:36:21 <dminuoso> Consider the initial example: You will need a comparing function, so some `eqList :: (a -> a -> Bool) -> [a] -> [a] -> Bool`. You have to write this explicitly, and provide it with an appropriate equality function on the elements
15:36:37 <dminuoso> You cant reuse any of that if you want equality on maps too
15:36:49 <dminuoso> And this promotes great error because there's no assurance we will all agree on the equality functions
15:37:14 <dminuoso> (Leading go incoherence, where you and I might use conflicting implementations, while sharing some data)
15:38:02 <irc_user> Ohhh, so it would be kind of like generics/traits?
15:38:07 <dminuoso> So without typeclasses, you will need to remember how all these eq functions are called, and you can't just automatically derive them. If you have parametrized data types, you will need to write manual higher order equality functions, and explicitly pass more eq functions inside
15:39:06 <ski> > showsPrec 0 "bqv" ""
15:39:08 <lambdabot>  "\"bqv\""
15:39:42 <bqv> figured it out, i just opened ghci
15:39:48 <bqv> trying to migrate from prelude to protolude
15:39:58 <bqv> monoids are ..definitely nicer
15:40:24 <irc_user> I think I see, thank you! I definitely have some more reading to do but this will be great to refer back to. 
15:40:26 <dminuoso> irc_user: Another motivating example is.. lets say you want to add numbers.
15:40:56 <dminuoso> Unless you have some other elaborate overloading mechanism, you can't use (+), because what type would (+) even have?
15:41:19 <dminuoso> So you'd have `addInt :: Int -> Int -> Int`, `addInteger :: Integer -> Integer -> Integer`, `addFloat :: Float -> Float -> Float`, etc..
15:42:04 <dminuoso> (The moment you ponder about this for a while, you'd probably end up with something like `add :: Num a -> a -> a -> a` with some `data Num a = Num { numAdd :: a -> a -> a, ... }`
15:42:08 <ski> it's especially "merge" functions (like `union :: Ord a => Set a -> Set a -> Set a') that benefit from knowing the same ordering was used to build the two input sets
15:42:16 <dminuoso> Which brings you back to all the other problems above
15:43:07 <ski> (if not for that, one could attempt to bundle the ordering relation inside the set)
15:44:17 <irc_user> I see, this makes a lot of sense now, thank you for the descriptive examples
15:51:52 * hackage reflex-dom-retractable 0.1.4.0 - Routing and retractable back button for reflex-dom  https://hackage.haskell.org/package/reflex-dom-retractable-0.1.4.0 (NCrashed)
16:01:07 * hekkaidekapus doesn’t mean to snitch but poor Ben in #ghc bearing with our old acquaintance larou :)
16:06:10 <dminuoso> hekkaidekapus: larou is markov chaining #nixos as well
16:06:22 <dminuoso> Are they an old acquainance?
16:06:27 <hekkaidekapus> heheheheh…
16:07:18 <hekkaidekapus> Yeah, tomsmeding had some data that they may be fog reincarnated.
16:07:51 * hackage reflex-dom-retractable 0.1.5.0 - Routing and retractable back button for reflex-dom  https://hackage.haskell.org/package/reflex-dom-retractable-0.1.5.0 (NCrashed)
16:08:02 <dminuoso> well fog seemed like a real person
16:08:17 <hekkaidekapus> hahahahaha… AI gone wrong :D
16:08:49 <bqv> i used inline-c for my program
16:08:50 <bqv> i'm regretting it
16:08:56 <bqv> and loving it at the same time...
16:09:26 <dminuoso> hekkaidekapus: Gosh, if I stare at whats been written in both #nixos and #ghc...
16:09:27 <bqv> but i think i'm going to have to rip it out and use something else
16:09:31 <gobbleguy> Let's keep the turing-test speculation out of this channel though
16:09:36 <dminuoso> That's gotta be a markov chain generator.
16:11:02 <bqv> it can't be purely markov
16:11:08 <bqv> it responded to your questions accurately
16:11:49 <gobbleguy> bqv: please
16:12:09 <bqv> i mean in terms of grammar! not sense...
16:12:24 <gobbleguy> bqv: can you read my messages?
16:12:31 <bqv> oh
16:15:22 * hackage reflex-dom-retractable 0.1.6.0 - Routing and retractable back button for reflex-dom  https://hackage.haskell.org/package/reflex-dom-retractable-0.1.6.0 (NCrashed)
16:51:16 <koz_> If I'm looking at profiteur results, and am like, 100 functions deep, is there a way to get the 'top' thing to be somethign 100 functions deep, and not like, main?
16:53:13 <dminuoso> koz_: Can you rephrase the question?
16:53:44 <koz_> dminuoso: Profiteur gives you a graphical view of how much time you spend where.
16:53:57 <koz_> And this gets subdivided as you 'descend' into functions called by other functions.
16:54:02 <koz_> I'm like, 100 such descents in.
16:54:12 <koz_> And as a result, I have huge amounts of visual noise from the graphical view.
16:54:16 <koz_> I wanna eliminate that noise.
16:54:22 <dminuoso> koz_: Ohh haha. Lacking that information, that sentence read like completely gibberish.
16:54:42 <koz_> dminuoso: Sorry, I've been chasing parser bugs all day and seem to be incapable of forming sentences.
16:55:36 <koz_> Found it, never mind.
16:55:40 <koz_> Handy zoom button.
17:31:20 <bqv> dminuoso: can i have a nix shellFor with c2hs in it?
18:17:22 * hackage reflex-ghci 0.1.5.0 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.5.0 (abrar)
18:31:53 <bqv> forget it. just using a v1-sandbox instead
19:05:15 <jle`> / 1
19:16:53 * hackage scheduler 1.5.0 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.5.0 (lehins)
19:41:52 * hackage massiv 0.5.5.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.5.0 (lehins)
20:54:26 <bqv> so I have some class MyClass a b | a -> b
20:55:10 <bqv> does that mean i can elsewhere use the type (MyClass a b) => b
20:55:28 <bqv> in lieu of b directly, with a being concrete
20:55:37 <bqv> and if so, what extension do i have to enable to make that happen
20:57:06 <ski> it means you're allowed to mention just `a' without `b' in a type, constrained by `MyClass a b'
20:58:17 <bqv> hmm
20:58:23 <bqv> ok so that's not my problem
20:58:29 <ski> because `a' (functionally) determines `b', so the presence of `a' means that `b' will be unique, fixed by `a'
20:58:38 <ski> the relevant extensions are `MultiParamTypeClasses' and `FunctionalDependencies'
20:58:39 <bqv> yeah
20:59:27 <bqv> it seems my problem is that i'm trying to do this in a foreign import :D
21:00:01 <ski> the Functional dependency `a -> b' here, on `MyClass a b c' (say. add an extra `c', just to make it more general) means logically that `forall a. unique b. exists c. MyClass a b c' : for every `a', there can be at most one `b' such that there's some `c' with `MyClass a b c'
21:01:06 <bqv> what I'm basically trying to achieve is a typelevel function
21:01:22 <ski> this is also logically equivalent to `forall a b0 b1 c0 c1. (MyClass a b0 c0,MyClass a b1 c1) => b0 = b1' : if you have two possible instances, with the same `a', then the `b's also must agree, be the same, never mind the `c's
21:01:23 <bqv> which that would do, but i can't use constraints in foreign
21:01:35 <bqv> or perhaps i can alias it...
21:01:43 <bqv> no, because a constraint is part of the type
21:02:06 <ski> hm. i don't think you can have type-clas-constrained foreign imports
21:03:03 <bqv> ok, turn it around then, can i instance a class with an implicitly typed second parameter?
21:03:19 <gobbleguy> IF you have a specific thing you're trying to do it might be worth just asking about that
21:03:20 <ski> i don't know what you mean by that
21:04:20 <ski> "what I'm basically trying to achieve is a typelevel function" -- do you mean like a `type' / `data' family (possibly an associated type) ?
21:05:11 <bqv> yeah
21:05:15 <bqv> but that doesn't work
21:05:21 <bqv> because of the foreign issue
21:06:11 <bqv> so now perhaps i'd like to omit the second type parameter of an instance (and have it inferred from the definition)
21:07:31 <ski> i guess you could possibly make an overloaded operation that takes operations from the dictionary and passes them explicitly to a foreignly imported operation
21:07:52 <ski> omit it, where ? in a type signature ?
21:09:15 <bqv> yes, say `instance MyClass MyA b where member = myForeignImport`
21:09:37 <ski> where `member' has what type ?
21:09:54 <bqv> b
21:10:02 <bqv> oh
21:10:12 <ski> also, `MyClass MyA b' doesn't seem to satisfy the FD `a -> b' on `MyClass a b'
21:10:41 <bqv> can't b be inferred?
21:10:42 <ski> (unless maybe if the kind of `b' only admits one possibility, being a singleton kind)
21:11:26 <ski> if you say `instance MyClass MyA b where ...' you're claiming that, for all `b's, `MyClass MyA b' is an instance 
21:11:40 <bqv> right, implicit forall
21:12:04 <bqv> darn.
21:12:08 <bqv> guess i'll do it the boring way
21:13:30 <ski> hm. i was thinking maybe you could do `instance MyClass MyA _ where ...', using `PartialTypeSignatures', but it seems that's not allowed
21:14:13 <bqv> heh
21:18:32 <ski> (hm, also it seems it doesn't work, if `b' is a `data' kind with just one (parameterless) constructor)
21:19:36 <bqv> data as opposed to * ?
21:19:39 <bqv> first i've seen
21:19:44 <ski> yes
21:19:53 <bqv> what do they signify?
21:21:10 <ski> can be used to "tag" (GADT) `data' constructors, e.g. to indicate some kind of "state" or current "mode" in which something is used
21:21:34 <ski> you should probably first look into `GADTs'
21:21:48 <bqv> hm, i see
21:22:08 <bqv> i've seen GADTs before, just not solid on the theoretical background
21:23:13 <ski> a very simple example could be an indexed state monad, which keeps track of (in the types) whether something is "open" or "closed". certain state-operations can only be done in certain states
21:24:54 <ski> (there are nicer examples, but i can't recall any, off the top of my head, atm)
21:25:19 <bqv> np :)
21:27:20 <ski> hm, i guess another example is to have a finite map, where the values associated with different keys, in the same map, can have different types. each key will know the type of the corresponding value
21:28:27 <ski> (or more generally, each key determines a "tag", and you have a value type that given a tag determines what type the corresponding value will have. so the tag doesn't have to be the value type itself, but it could determine it)
21:28:58 <bqv> hm
21:29:43 <ski> @hackage dependent-map
21:29:44 <lambdabot> https://hackage.haskell.org/package/dependent-map
21:30:51 <ski> the key type will generally be a GADT, and the value type could also be one. `Identity' is another common choice for it
21:33:30 <bqv> heh, obsidian systems. i know of them from another context
21:33:34 <ski> so if you have `data Key :: * -> * where Name :: Key String; Address :: Key String; Age :: Key Int' then `DMap Key Identity' can have at most three associations. one mapping `Name' to a `String' value, one mapping `Address' to a `String' value, and one mapping `Age' to an `Int' value
21:34:26 <ski> (in this case the "tag" is just an ordinary (concrete) type, of kind `*'. so this is not an example of `DataKinds')
21:35:54 <bqv> i follow, vaguely enough
21:38:12 <ski> `DMap' is a way to have a "heterogenous" finite map. `DMap k v' is roughly `[exists i. (k i,v i)]' (except more efficient, presumably using a search tree instead of a list), where the index `i' is the "tag", each different association pair can have a different `i'
21:41:07 <ski> by pattern-matching on the value of `GADT' `k i', we can recover `i', discovering which specific index/tag was used in an association. this happens when we compare the given key with the keys in the map, discovering the `i's are the same, in case the two keys are equal
22:05:52 * hackage generic-functor 0.2.0.0 - Deriving generalized functors with GHC.Generics  https://hackage.haskell.org/package/generic-functor-0.2.0.0 (lyxia)
22:56:16 <bqv> TIL: it's possible to write a file between the time GHC attempts to compile it and displays the error, so the displayed code doesn't match the error it shows
23:17:42 <suzu_> big unlucky
23:17:57 <bqv> oh no it was fine, i noticed it instantly
23:29:26 <gtk> What is: 'type instance' in 'type instance G.Mutable Vector = MVector' ?
23:30:26 <opqdonut> type families
23:30:33 <suzu_> it means that the type 'G.Mutable Vector' resolves to 'MVector'
23:30:48 <opqdonut> it's a language extension that lets you, basically, define type-level functions
23:30:54 <suzu_> ^
23:32:34 <gtk> So G.Mutable is a type function which takes in Vector and output MVector?
23:35:52 * hackage protocol-buffers-descriptor 2.4.16 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.4.16 (k_bx)
23:35:55 <opqdonut> gtk: yeah
23:36:06 <gtk> opqdonut: and then 'data family MVector s a'. 
23:36:43 <gtk> opqdonut: Can I understand that MVector is also a type level function?
23:36:52 * hackage protocol-buffers 2.4.16, hprotoc 2.4.16 (k_bx): https://qbin.io/wu-ms-aaza
23:36:56 <opqdonut> yeah
23:37:11 <gtk> which takes in s and a and produces a new type?
23:37:13 <opqdonut> except now it's a _data_ family, not a _type_ family, which is slightly different
23:37:29 <opqdonut> yeah, exactly, the difference is that it results in a new type, not an existing type
23:37:39 <gtk> i see!
23:49:54 <int-e> > let step m d = M.fromListWith (+) $ do (v,n) <- M.assocs m; [(v,n),(v+d,n)] in foldl step (M.singleton 0 1) [55,38,29,29,20,20,18,16,16,15,14,13,12,11,11,11,11,10,10,10,10,9,9,9,8,8,7,7,7,6,6,6,6,6,6,5,5,5,4,4,4,4,4,3,3,3,3,3,3,3,3] M.! 269
23:49:56 <lambdabot>  16976480564070
