00:48:23 * hackage optparse-declarative 0.4.1 - Declarative command line option parser  https://hackage.haskell.org/package/optparse-declarative-0.4.1 (kakkun61)
02:02:45 <tomsmeding> @unpl fix(((True:).).(.flip(flip.(ap.).flip flip head.(((.).flip((.).(:))).))tail).ap fix)((.tail).((False:).))
02:02:45 <lambdabot> fix (\ x x0 -> True : (fix >>= \ x2 -> x >>= \ x3 -> return (x2 x3)) (\ y0 b0 -> (tail >>= \ x5 -> return (((:)) (head b0) (x0 y0 x5))) b0)) (\ x x0 -> False : x (tail x0))
02:28:45 <bliminse> what is that monster? that's going too far with pointfree xD
02:39:52 <int-e> unfortunately @unpl overshoots a bit with the reader monad here.
02:42:20 <tomsmeding> it generates prime numbers (easily verifiable by running it), but I gave up figuring out how
02:42:27 <tomsmeding> (source: XorSwap's message above)
02:43:08 <tomsmeding> you can Î²-reduce all the reader monad stuff away fairly easily
02:43:35 <bergsans> Perhaps more of interest to people learning Haskell, but I wrote a post with annotated code for how to make a game-ish demo with Haskell and Gloss: https://herebeseaswines.net/essays/2020-11-01-making-a-small-game-with-gloss
02:50:12 <int-e> @pl fix (\go g -> True : (\f -> fix f (go f)) (\h xs -> head xs : (g h (tail xs)))) (\f ys -> False : f (tail ys))
02:50:13 <lambdabot> fix (((True :) .) . (. ((liftM2 (:) head .) . flip flip tail . ((.) .))) . ap fix) (((False :) .) . (. tail))
02:55:36 <int-e> What it does is build functions that replace the first element of a list by False, then preserve the next n elements (starting with n = 0, that is, (\f ys -> False : f (tail ys))), and then apply a continuation to the rest of the list. So the fixed point of that will replace every (n+1)st element of a list by False. And you can extend the length of the unmodified part by tweaking the...
02:55:42 <int-e> ...continuation, that's the (\h xs -> head xs : (g h (tail xs))) part. Tie this together in the right way and you have a prime sieve.
02:55:52 <int-e> > fix (\go g -> True : (\f -> fix f (go f)) (\h xs -> head xs : (g h (tail xs)))) (\f ys -> False : f (tail ys))
02:55:55 <lambdabot>  [True,True,False,True,False,True,False,False,False,True,False,True,False,Fal...
02:56:48 <int-e> (as hinted by XorSwap, this starts at 2, so the primes are 2,3,not 4,5,7,11,13...)
02:57:35 * int-e has written similar code before, actually, though for plain lambda calculus...
02:59:11 <int-e> Anyway, I think  fix (\go g -> True : (\f -> fix f (go f)) (\h xs -> head xs : (g h (tail xs)))) (\f ys -> False : f (tail ys))  is probably the best pointful form of this.
02:59:34 <int-e> It's still not very readable, obviously :P
03:06:16 <Guest_47> Hello! While trying to install Haskell with ghcup on my Mac I got the following error: Build failed with NonZeroExit 77 "./configure" ["--prefix=/Users/niko/.ghcup/ghc/8.8.4"]
03:06:47 <Guest_47> Can someone give me advice to how successfully install Haskell?
03:08:10 <merijn> Which version of macOS?
03:09:37 <Guest_47> Catalina 10.15.7
03:39:28 <PerseusPlease> hi. I was wondering if anyone could help me with a problem I'm having. I'm getting the error "Non type-variable argument in the constraint: MonadError String m (Use FlexibleContexts to permit this)", which isn't helping me much as I think I already have that enabled.
03:39:50 <jophish> How can I disable tests for a source-repository-package? 
03:40:42 <merijn> jophish: You can add cabal settings (like "test: False") for individual packages by having "package foo\n   tests: False" in cabal.project(.local)
03:40:51 <merijn> (Or whatever the right field/config name is)
03:40:55 <PerseusPlease> https://gist.github.com/abc-mikey/b9c73c5cc5d2065d7a68b28939ac27b4
03:40:55 <jophish> ah, thanks!
03:41:55 <merijn> PerseusPlease: Did you double check you saved the file after adding that? :p
03:42:24 <PerseusPlease> merijn, yes saved. also I only get that error when I actually call function from ghci
03:42:42 <PerseusPlease> also reloaded with :load app/NetStrings.hs
03:42:46 <merijn> PerseusPlease: Oh!
03:43:01 <merijn> PerseusPlease: That's because the pragma only enables it in the file, *not* in ghci itself :p
03:43:11 <merijn> PerseusPlease: Use ":seti -XFlexibleContexts"
03:43:19 <PerseusPlease> ahhhhhhhh...!
03:43:24 <PerseusPlease> that's the magic
03:43:40 <PerseusPlease> I tried {-# LANGUAGE FlexibleContexts #-}
03:43:52 <merijn> Yeah, that doesn't work in ghci
03:53:11 <florian_> Hi there ! Do you have any opinion about Agda ?!
03:54:39 <__monty__> florian_: It's cool stuff.
03:56:26 <florian_> monty : So do you use it ? and in which context do you use it ?
03:57:54 <__monty__> Not anymore, basically just took a look at it. It's viable as a way to do computer checked proofs.
03:58:25 <__monty__> It's interesting for dependent types and for its syntax.
04:10:22 <florian_> Do you see any value to use Agda to dev a game or application ?
04:13:47 <akegalj> florian_: I think Idris is orianted more to suite that niche
04:16:03 <__monty__> florian_: It would be a really cool project. But Agda's implementation is really not ready to produce performant code, at least last time I looked at it. Idris is kind of an Agda with a practical implementation but slightly less interesting and currently in flux because Idris 2 will be so different.
04:19:28 <maerwald> Agda and game development?
04:20:02 <maerwald> are you gonna write an entire ecosystem of game dev libraries from scratch? :D
04:20:19 <akegalj> Also, my impression is that Agda's comunity is more focused on proof checking. As a result, Agda contains a lot of libraries to serve that goal. I don't think many people experimented with agda and game dev
04:21:11 <__monty__> I did a tiny experiment to see if using dependent types to make it impossible to design impossible levels could work.
04:21:14 <int-e> Hmm, a "game" can be so many things.
04:21:39 <__monty__> Wouldn't call it game dev by any stretch of the imagination though.
04:21:41 <int-e> . o O ( Minesweeper )
04:21:52 <akegalj> or chess
04:22:34 <florian_> monty : Ok so Agda give a huge Type system that can be really interesting for an game or app, but the efficiency of the implementation is not good enough for that ? ( is want you try to said ? )
04:23:19 <florian_> maerwald : yes
04:23:27 <__monty__> florian_: Yes, unless you have the resources to develop a compiler and library ecosystem, Agda isn't a practical choice as the implementation language.
04:23:32 <akegalj> florian_: If it some turn based game, then it might work out
04:24:11 <__monty__> If it's just for a hobby project though, I'd say it'd be way more interesting than writing it in python or something.
04:24:35 <int-e> It might be an interesting experiment... but what practical benefit do you expect?
04:25:03 <__monty__> Enlightenment, obviously : )
04:25:31 <int-e> __monty__: I get that, but what practical benefit do you expect. :-P
04:26:32 <int-e> (I honestly think that the "experiment" part covers the potential enlightenment.)
04:26:52 <maerwald> florian_: let me know when you've completed your first game in Agda
04:28:07 <florian_> int-e : build stuff in a really elegant way and have a proof that your logic system do what you expect, no ? 
04:28:10 <int-e> Hmm, is "the incredible proof machine" a game? :)
04:28:13 * ski . o O ( "The Next Mainstream Programming Languages: A Game Developers's Perspective" (slides) by Tim Sweeney in 2005 at <http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf> )
04:29:13 <florian_> maerwald : haha why ?
04:30:52 <ski> (section from page 27 mentions dependent types, a bit)
04:31:37 <int-e> haha, 30fps@720p
04:31:38 <florian_> ski : thanks a lot ! It's seems really interesting !
04:32:28 <ski> Carmack has also talked a bit about functional programming, from a game programming perspective
04:32:44 <__monty__> Yeah, that's a good talk.
04:33:20 <__monty__> florian_: It'd be a lot more practical to do an implementation and a model of your logic in either a proof assistant or a model checker.
04:34:22 <int-e> ski: is that 27 hex... (ouch)
04:35:57 <int-e> But he uses "dependently-typed" as a proxy for a ranged integer type, which is a rather narrow extension of the type system. And I suspect he wants the compiler to infer the ranges, rather than the programmer to write them, most of the time? Hard to say.
04:36:09 <florian_> monty : Because Agda is not a proof assistant ?
04:36:44 <__monty__> florian_: It kinda is, the assistance is just fairly minimal, at least as compared to coq for example.
04:37:50 <maerwald> ski: you mean that one twitter post years ago?
04:37:57 <ski> florian_ : <https://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php>,<https://www.youtube.com/watch?v=1PhArSujR_A>
04:38:05 <ski> maerwald : no idea
04:38:21 <__monty__> florian_: I'd recommend setting out to learn Agda and write something really simple, like tic-tac-toe or something. That'll probably give you enough insight into why no one here is going "Woohoo, yeah!!! Agda for games!"
04:38:34 <florian_> monty : Ok, do you use coq ? Do know a language/software/system to do model checking ? 
04:38:50 <ski> int-e : "Reliability" section
04:39:30 <__monty__> I don't, not enough time, I'd like to though. Model checker I'm most interested in is TLA+.
04:40:06 <int-e> ski: Oh you mean the whole section, not the single slide.
04:40:16 <ski> int-e : yes. it's not too fancy. but it does include Pi 
04:40:20 <ski> yep
04:40:38 <int-e> I should figure out whether there are any dependently typed programming success stories out there.
04:40:53 <florian_> ski : thanks I will check that !
04:41:18 <__monty__> Well, compcert was certified using dependent types (coq), at least in part, no?
04:41:28 <ski> (mind that Carmack isn't talking about dependent types, that i recall. but it could still be interesting)
04:41:36 <__monty__> That's kinda the certified software poster boy, no?
04:41:55 <__monty__> Yeah, Carmack mostly talks about haskell iirc.
04:43:03 <florian_> monty : I start to do implementation of Boolean, Natural numbers, List, Binary Tree, Tree, Custom types: and i'm like .. "OOoo ! it can be really awesome for my day to day work"
04:45:11 <merijn> maerwald, ski: FWIW, Tim Sweeney (of Epic Games) gave a keynote at POPL about his expectations for the "next big language in games"
04:45:22 <merijn> Lemme see if I can find the slides
04:45:45 <__monty__> merijn: Already linked by ski ^
04:45:50 <ski> merijn : another than the one i linked to, above ?
04:46:17 <merijn> oh, hah, that was just off screen
04:46:24 * ski . o O ( <https://en.wikipedia.org/wiki/ATS_(programming_language)> )
04:47:49 <florian_> monty : thanks a lot for the TLA+ reference !
04:49:28 <florian_> ski : thank for the ATS ref ! you give me so much interesting sources
04:50:20 <ski> (i haven't really looked much at ATS. but it seemed possibly relevant, in the discussion)
04:56:13 <maerwald> merijn: pretty odd that he makes an argument for lazy evaluation while this will be his biggest problem when doing actual gamedev in haskell
04:56:30 <merijn> maerwald: Well, he's not arguing for lazy in the last slides
04:57:02 <merijn> maerwald: His point is that "complicatedly juggling initialisation order of global state is a mess" due to eager evaluation
04:57:05 <maerwald> my suspicion is that he has only looked at the language and the syntax and is trying to borrow nice ideas, rather than having actually used it
04:57:17 <maerwald> (which is good)
04:57:57 <merijn> maerwald: did you read the 2nd to last slide(s) on "Why haskell is not my favourite"?
04:57:58 <int-e> The next Haskell will be strict? :)
04:58:06 <merijn> int-e: I hope not
04:58:07 <maerwald> merijn: I'm half-way through
04:58:12 <maerwald> int-e: I hope so
04:58:18 <merijn> maerwald: Ah, he addresses that literally at the end :)
04:58:32 <merijn> int-e: I would hope "strictness polymorphic" that sounds much more interesting
04:59:03 <maerwald> and linear types and dependent types so only a handful of ppl around the world can code it
04:59:04 <int-e> if it means what I think it means it sounds like a recipe for exponential code explosion
04:59:51 <int-e> And don't get me wrong, I love laziness. But it is rather expensive.
05:00:36 <int-e> And it's not always possible to make up for that with more clever algorithms that would be really awkward to implement without laziness.
05:00:44 <maerwald> my idea of the perfect language is this: let some academics come up with the most fantastic featureful stuff and then let a community of pramatic programmers cut down feature by feature until they're satisfied. No feature is allowed to be added, ever :)
05:01:36 <merijn> maerwald: tbh, I'm not sold on dependent types
05:01:55 <int-e> maerwald: Force the academic to implement FFI. Implement everything you need in C++. ;-)
05:02:30 <merijn> maerwald: But strictness polymorphic would be nice, like, why do we need foldMap and foldMap' instead of a single foldMap that can be instantiated strict or lazy as needed dependent on whether you give it a strict or lazy function
05:02:50 <maerwald> merijn: I'd much rather have a Lazy type
05:03:19 <maerwald> I don't think it'll be easy to reason about programs when they're strictness polymorphic
05:03:21 <ski> like in OCaml,SML,Scheme ?
05:03:22 <int-e> I feel unqualified to muse about dependent type. I struggle to think of a compelling use for them that scales beyond toy examples... I imagine it'll require a *very* moderate use of dependent types, or a genius software engineer who gets them just right for a particular domain. Possibly both.
05:04:05 <int-e> I imagine it's very easy to use dependent type to code yourself into a corner where you're constantly fighting the types you created.
05:04:34 <int-e> But... yeah sadly that's all speculation.
05:04:50 <maerwald> int-e: that's fine... I don't care how other ppl shoot themselves in the foot. The problem is when I have to use libraries that do that weird stuff. And that will inevitably happe
05:04:58 <int-e> I'd really love to see some experience reports.
05:05:14 * ski . o O ( "Ornamental Algebras, Algebraic Ornaments" by Conor McBride in 2010-08-09 at <http://personal.cis.strath.ac.uk/~conor/pub/OAAO/Ornament.pdf> )
05:05:17 <int-e> Maybe it works well for specific domains like compilers at least? That's quite conceivable.
05:06:26 <int-e> maerwald: Oh yes, the ecosystem will become far more fragmented than it already is.
05:08:07 <int-e> The beauty of the ML type system is that if you can capture a property in those types, it's almost always worth it (though you can go overboard with newtypes, I think). It doesn't require much discipline to benefit from.
05:08:54 <maerwald> To me, types aren't worth to encode logic into. I only want to encode my data in it.
05:09:11 <int-e> Hmm. I should say HM (Hindley-Milner). And a couple of Haskell's extensions have that property as well, notably GADTs.
05:09:54 <__monty__> int-e: Or, Damas-Hindley-Milner : )
05:12:27 * int-e goes look at ski's link
05:14:51 <juri_> ski: o/
05:20:26 <maerwald> I don't really understand when he talks about parallelism, effects free and Monads
05:20:27 <ski> hello juri_
05:20:30 <maerwald> merijn: ^
05:21:01 <merijn> maerwald: Ah, you'd like a position paper I wrote a few years ago :)
05:21:36 <merijn> maerwald: Where I argue a bunch of these Haskell effects libraries are doing it wrong by stuffing everything in the "functional" (in the sense of functional vs non-functional requirements) type
05:21:40 <maerwald> seems like a misunderstanding about what purity is, looking at the slide
05:22:00 <merijn> maerwald: What I want is multiple orthogonal/independent type systems
05:22:03 <int-e> ski: Hmm, weird.
05:22:13 <ski> which ?
05:22:15 <maerwald> merijn: like Java exceptions
05:22:19 <int-e> ski: the ornaments
05:22:23 <merijn> maerwald: So the fact that the result of "div" throws and the fact that "div" returns "Int" are separate
05:22:46 <maerwald> I agree
05:22:51 <merijn> maerwald: Similarly, I don't want the strictness polymorphism in my "foldMap :: Monoid m => (a -> m) -> [a] -> m" type
05:23:06 <merijn> I want a *completely separate* type that indicates the strictness of arguments
05:23:33 <ski> int-e : the explicit representation thing he does is fiddly/awkward. but having a way to express such relationships, and possibly derive ornamented types in such a way, seems like it could be useful
05:23:46 <merijn> maerwald: And then for things like "strictness polymorphism" or "throwing exceptions" you can leave the inferred default 95% of the time. But explicitly write a "this doesn't throw signature" when needed and get a type error if it doesn't match
05:23:55 <int-e> ski: yeah but the whole paper is on a level I fail to care about
05:24:29 <maerwald> merijn: I think that's basically how the borrow checker in rust works. It "communicates" with the type system, but it's not completely wired in, afaik
05:24:30 <merijn> maerwald: So you can annotate when you explicitly need something strict/lazy or well "exception polymorphic" (I suppose), but still have the power of annotating your meaning when desirable
05:25:32 <int-e> ski: well, that's unfair. the abstract and introduction are okay. :P
05:25:36 <ski> int-e : yea. it would be nice with a more practical take on it
05:25:52 * hackage ormolu 0.1.3.1 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.1.3.1 (mrkkrp)
05:26:21 <maerwald> merijn: is that position paper public?
05:26:38 <merijn> maerwald: It was an off-the-cuff thing at a tiny workshop, so...maybe? :p
05:27:49 <int-e> ski: How would I use this? How would user code transition from the plain to the ornate version and back? Also, he's kind of doing the opposite of what the introduction does, adding structure to the length to get a list, rather than taking a list and keeping track of the length...
05:27:59 <int-e> ski: (Rhetorical questions.)
05:28:26 <merijn> maerwald: I did write this like 6 years ago in, like, an afternoon so I'm not sure how well thought or argued it is :p
05:28:29 <merijn> maerwald: http://grammarware.net/text/2014/oopsle-pre.pdf
05:28:42 <ski> yes. it's half-baked
05:28:52 * hackage vulkan 3.6.11.1 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.11.1 (jophish)
05:29:15 <merijn> maerwald: No one wanted to pay me to do research in it, sadly :p
05:29:49 <maerwald> maybe you can make it blockchain relevant and then get your funding?
05:29:52 * hackage VulkanMemoryAllocator 0.3.7.1, vulkan-utils 0.1.2.1 (jophish): https://qbin.io/gaps-hiking-36kp
05:32:35 <merijn> maerwald: Maybe, if I was willing to move abroad to some other university, but I'm not willing to move :p
05:32:41 <ski> merijn : hm, (reading the abstract) reminds me of Racket's support for multiple languages, and of typed macros
05:32:46 <merijn> That's also why I'm not getting paid to do haskell yet :p
05:34:35 <maerwald> I think you're basically making an argument for Java, which allows easily extending the type system
05:34:51 <maerwald> (lets ignore for a moment that the language sucks)
05:38:52 * hackage polysemy-fs 0.1.0.0 - Low level filesystem operations for polysemy.  https://hackage.haskell.org/package/polysemy-fs-0.1.0.0 (locallycompact)
05:43:17 <ski> in Mercury, they use "inst"s ("instantiation states") as a separate mechanism (distinct from types) to track how much initialized a value it, but can also be used for simple refinements (like non-empty lists, lists of even number of elements, &c.). i wonder whether something like that could also be used to track different representations of data, e.g. for matrices (sparse, triangular, &c.), graphs
05:45:18 <merijn> So, eh, if you wanna see if this could work, get someone to fund me ;)
05:45:43 <merijn> (although, maybe wait until I finish my defense...)
05:54:01 <texasmynsted> soo fourmolu. I do not recall this happening before, but now when I use it from vim it messages that it loaded my config file. While accurate, I do not need that in my source file. 
05:54:14 <texasmynsted> Is there as setting, that I can not see, that makes this stop?
06:04:17 <refried_> does `newtype` have a runtime representation, or does it just use the underlying type?
06:05:35 <tomsmeding> texasmynsted: :D
06:05:45 <tomsmeding> does it output that on stdout? if so, boo fourmolu
06:05:55 <tomsmeding> if not, 2>/dev/null :p
06:06:41 <texasmynsted> I was just looking... It is a message that really should only show in some kind of debug mode, even on stderr
06:07:26 <ski> refried_ : the latter
06:07:29 <texasmynsted> yes, stderr
06:07:37 <refried_> thanks ski
06:08:34 <ski> (that's the point of it, more or less, over a single-argument single-constructor `data' type. this also has ramifications for strictness/bottoms)
06:28:04 <fendor> tasty usually does not have some expectation such as hspec's shouldThrow?
06:28:25 <merijn> fendor: Eh, you probably want tasty-hunit?
06:28:35 <fendor> merijn, does not have it either, afaict?
06:28:45 <fendor> unless I am blind
06:29:18 <merijn> fendor: Easy enough to implement, though: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-tests/BroadcastChan/Test.hs#L74-L83
06:30:25 <fendor> merijn, well, obviously. So, time for tasty-hunit-expect-exception?
06:31:05 <fendor> Or rather, I would prefer tasty-hspec-expectations
06:37:25 <merijn> fendor: I mean, that's just a matter of making a PR to tasty-hunit to add it
06:37:31 <merijn> Dunno why I didn't get around to that
06:37:50 <fendor> indeed, maybe I should just try that. 
06:38:11 <fendor> Just feels odd that such an expectation is not available in one of the most common testing frameworks
06:43:07 <merijn> tasty is just a runner/combiner, so it's more the absence in hunit/tasty-hunit
06:52:08 <fendor> still suprises me, that neither hunit not tasty-hunit define it
06:58:18 <Squarism> I notice type System.IO.FilePath = String. Is there some representation of file that separates directory and filename?
06:59:38 <dminuoso> Squarism: directory gives you the separation in its semantics
06:59:55 <Squarism> ok, ill look into that
07:00:45 <dminuoso> (But sadly this is not communicated in types)
07:01:32 <fendor> Squarism, there is also hpath
07:01:34 <Squarism> dminuoso, yeah. Looking at package "directory" i cannot directly see what could be useful for me
07:01:58 <geekosaur> can't be, really; take a look at how streams are represented on windows, or forks on os x
07:01:59 <dminuoso> Squarism: Well it offers you functions like splitFileName and so on
07:02:10 <maerwald> Yes, hpath uses ByteString as filepath and doesn't use directory package at all
07:02:16 <maerwald> Everything is built on top of unix
07:02:23 <geekosaur> (a "file" can be a "directory", as haskell or applications see it)
07:03:39 <dminuoso> Or conversely, a directory *is* a file in unix + derivates.
07:04:30 <maerwald> separating directory from file is nonsense wrt *filepaths*. The `path` package does that though
07:05:00 <Squarism> ok. Ill look into hpath and path
07:05:22 <dminuoso> Squarism: What's the problem domain
07:05:30 <maerwald> But you'll get surprising results, since only an actual IO call can tell you whether something is a directory or not and a second later that truth might have changed
07:05:53 <maerwald> It makes sense for *user input*
07:06:02 <maerwald> but you should have a separate type for user input
07:06:22 <Squarism> just rolling a typical bash-like script. Searching for files grouping them by directory / filename-pattern
07:06:58 <maerwald> Then you don't really need that on type level. It's enough to have that as constructors
07:07:26 <maerwald> https://github.com/hasufell/hsfm/blob/master/src/HSFM/FileSystem/FileType.hs#L91
07:07:42 <maerwald> I'm not sure that was a particularly good idea, but it worked
07:09:53 <maerwald> when it comes to filesystem, you don't really want to store much information in memory, but look at it as late a possible and then you end up not needing much data types anyway
07:10:59 <maerwald> (and don't go the lazy IO route)
07:12:22 <Squarism> I try to use haskell instead of bash when doing small ad hoc jobs. Even there well typed things help me.
07:13:11 <maerwald> well, as long as the types don't lie :)
07:13:23 <maerwald> when they represent outdated filesystem information, they lie
07:13:46 <dminuoso> In addition, the notion of a "filesystem" is confusing and depends on the implementation.
07:13:50 <Squarism> splitting a path into directory + filename I feel would be basic functionality. But maybe its not
07:14:03 <dminuoso> Squarism: Consider what we said earlier
07:14:08 <dminuoso> directories under linux *are* files
07:14:26 <dminuoso> And `directory` offers you the functionality to split into basename and filename
07:14:33 <dminuoso> Using `splitFileName`
07:14:44 <Squarism> yes yes. 
07:14:56 <dminuoso> To track such information in the type system would be worthless, since by the time you interact with the file system again, it could have changed
07:14:57 <dminuoso> for instance
07:14:58 <maerwald> Squarism: you want `dirname`, but a path is agnostic of directory vs filename
07:15:15 <dminuoso> if you know that `"foo" :: Directory`, the moment you interact with the filesystem again that could no longer be true
07:15:27 <dminuoso> Maybe someone deleted the directory "foo" and replaced it with a symlink to a non-directory
07:16:33 <Squarism> dminuoso, you mean this right https://hackage.haskell.org/package/directory ? 
07:16:35 <dminuoso> So all that remains is that "foo" is just a filepath information
07:16:40 <merijn> All filesystem operations are just TOC-TOU races
07:16:46 <dminuoso> And that remains true
07:16:51 <dminuoso> whether "foo" still points at something remains to be seen 
07:16:54 <dminuoso> (or what it points at)
07:17:27 <dminuoso> So "being a directory" is not a property of the filepath, its a property of the (stateful and concurrent) filesystem.
07:18:04 <dminuoso> Some of the documentation of `directory` is just misleading
07:18:16 <maerwald> avoid directory package if you can :p
07:18:19 <dminuoso> splitFileName splits a path into two paths, one that would describe a directory containing the other.
07:18:24 <dminuoso> but both are *still* paths
07:19:22 <maerwald> https://hackage.haskell.org/package/path-0.8.0/docs/Path-Posix.html
07:19:33 <maerwald> this uses a Dir/File type for paths
07:19:42 <maerwald> so if you like that misconception, go with that
07:20:34 <dminuoso> merijn: Somehow I wish we would move to transactional filesystems. :(
07:20:57 <dminuoso> maerwald: Im curious, why do you dislike `directory`?
07:21:20 <maerwald> dminuoso: it's too cross-platform 
07:21:47 <maerwald> which usually means most of the functions work most of the time
07:21:58 <maerwald> and for some subset of scenarios, they don't
07:22:14 <dminuoso> so if if you're inside that subset, then dont use it?
07:22:24 <maerwald> https://github.com/haskell/directory/issues/110
07:22:28 <maerwald> example
07:22:53 <geekosaur> you often don't have a say as to whether you're in the subset or not
07:22:59 <maerwald> more: https://github.com/haskell/directory/issues/109
07:23:04 <maerwald> hard to predict behavior
07:23:12 <geekosaur> you gjust get a possibly unpleasant surprise
07:23:20 <maerwald> knowledge of atomicity is darn important
07:23:22 <dminuoso> Well, I just like the filepath manipulation API of directory.
07:23:32 <dminuoso> For filesystem interaction I'd default to unix anyway
07:23:56 <maerwald> yep, except that doesn't have high-level API like recursive copy or deletion
07:24:00 <dminuoso> geekosaur: Sure, but that's rather an argument about cross-platform in general
07:24:11 <dminuoso> (In the sense that cross-platform filesystem interaction is brittle)
07:24:24 <dminuoso> maerwald: Like I said, I just use it for file*path* manipulation
07:24:32 <dminuoso> Computing file paths, splitting them, etc
07:24:41 <dminuoso> Or do you mean `unix`?
07:24:47 <maerwald> yes
07:24:48 <hpc> the need for cross-platform filesystem interaction doesn't go away just because windows is bad, in any event
07:25:15 <merijn> hpc: What, precisely, is the argument for windows being bad?
07:25:22 <hpc> the linked issues
07:25:36 <maerwald> merijn: file locking is really nuts
07:25:46 <dminuoso> file locking is nuts in the linux world too
07:25:53 <dminuoso> since it's essentially just advisory locks
07:25:55 <hpc> just fix those bugs and move on, imo
07:25:59 <dminuoso> you dont get any real promises about a flock
07:26:10 <merijn> file locking in linux is so retarded I can't imagine a way windows could be worse, tbh
07:26:14 <dminuoso> (unless you can somehow prove no other process outside your control will touch your file)
07:26:18 <dminuoso> merijn: indeed.
07:26:32 <hpc> merijn: you'll love the discussion on that 110 issue then :D
07:26:49 <merijn> hpc: Is it *bad* or is it *different*?
07:27:10 <maerwald> you just retry deletion until your virus scanner is finished
07:27:34 <hpc> one of the edge cases of one way of deleting a directory holds onto that file path until every handle to it is closed
07:27:53 <hpc> so you can't make a new file with that name, even though the name isn't currently present on the filesystem
07:27:58 <dminuoso> maerwald: Anyhow. If your argument is `unix lacks higher level API` that doesnt make unix bad, perhaps the desire to have "high level APIs" or worse "high level cross-platform APIs" is doomed from the get go
07:28:00 <Uniaika> 1/
07:28:08 <Uniaika> (woops)
07:28:14 <maerwald> dminuoso: yes, I wrote that high-level API
07:28:20 <dminuoso> Which package?
07:28:40 <Uniaika> oh btw, `transpose` is now leak-free thans to the work of David Feuer and myself
07:28:59 <dminuoso> merijn: Did you order a DNA sample of dfeuer by the way?
07:29:00 <maerwald> dminuoso: hpath-directory on RawFilePath and hpath-io on Path
07:29:03 <dminuoso> We need him cloned.
07:29:24 <merijn> hpc: You can't say something useful about a single operation like that without considering the design that lead to it. Like "is files being open blocking deletion" a bad design? Not necessarily, imo. It's different than what people are used to on unix, but there's definitely sense to it
07:29:42 <hpc> that's different
07:29:51 <hpc> this is files being deleted blocking creation
07:29:57 <dminuoso> At the end filesystems are complex beasts that I really dont like working with.
07:29:58 <Uniaika> dminuoso: for the moment I'm acting as a surrogate, I'm the one who put together his patch and test :P
07:30:03 <dminuoso> Relational databases are so much more pleasant.
07:30:11 <hpc> the file is already gone from the filesystem
07:30:15 <merijn> hpc: Is it? AFAICT the deletion is blocked because someone has the file open and locked
07:30:18 <hpc> it's not present and locked
07:30:54 <dminuoso> Clearly we need filesystems with STM semantics and get rid of these silly race conditions.
07:30:56 <merijn> At what point is a file "no longer present" in your opinion?
07:31:31 <merijn> dminuoso: This is why I tell people they should just use SQLite for all their applications, then you can just let their code deal with it and that's better tested than yours anyway :p
07:31:54 <geekosaur> so a file's path is part of its metadata on windows but not on unix. this is a reasonable choice imo
07:32:03 <maerwald> merijn: https://www.sqlite.org/src/info/89f1848d7f
07:32:24 <merijn> maerwald: That does not in anyway affect the truth of my statement
07:32:26 <dminuoso> merijn: Indeed, Im a big fan of sqlite myself too.
07:32:30 <merijn> I didn't say it was flawless
07:32:41 <merijn> I said it was more battle tested than anything any of us have ever written
07:32:42 <maerwald> merijn: no, this was just an example of windows 
07:32:51 <maerwald> and that sqlite retries
07:33:02 <merijn> maerwald: I am still not convinced that's necessarily *bad* design
07:33:05 <maerwald> see `winDelete`
07:33:08 <maerwald> I didn't say it is
07:33:29 <merijn> Right, but hpc (and lots of people when windows comes up) do
07:33:52 <dminuoso> Anyhow. Maybe someone here knows, Im looking for a package to facilitate generating multiple Haskell modules, but ideally with utilities like `reify` that could let me reflect on already generated code.
07:33:54 <merijn> afaict most of the "windows is bad" people just mean "windows != posix and I hate having to read docs"
07:35:08 <merijn> Windows is (at worst) of "average engineering quality comparable to linux, etc.. More realistically, imo, the engineering of most of windows is orders of magnitude better than linux
07:35:52 <maerwald> here's anothe example of haskell code handling windows file deletion issues https://github.com/input-output-hk/cardano-wallet/blob/master/lib/core/src/Cardano/DB/Sqlite/Delete.hs
07:36:05 <dminuoso> merijn: I still think much of the bad reputation windows has had, is millions of uneducated users installing shitty drivers, and then blaming microsoft for BSODs.
07:36:26 <merijn> dminuoso: Yes
07:36:38 <merijn> dminuoso: Also, just all drivers being shitty
07:36:51 <maerwald> I get xserver crashed with nvidia drivers
07:37:09 <merijn> IMO, the biggest mistake in Windows engineering for 95/98 was MS assuming that every 3rd party vendor would be as careful with code running in kernel space as they were
07:37:24 <maerwald> but then again, xserver is one of the worst codebases out there :p so not sure I'd blame nvidia
07:37:43 <dminuoso> Speaking of x, its sad to see its developed has essentially completely stopped
07:37:59 <dminuoso> Since RH has switched to wayland, that's the last industry funding/work gone.
07:38:00 <dminuoso> :(
07:39:09 <maerwald> wayland has no concept of window icons :p
07:39:25 <maerwald> window managers have to implement a lot of logic to get window icons
07:39:39 <dolio> What does this have to do with Haskell?
07:39:54 <dminuoso> dolio: `directory` is bad.
07:39:55 <dminuoso> :p
07:40:02 <dolio> Wrong.
07:40:13 <dminuoso> dolio: No, that's how this all started.
07:40:18 <dolio> I mean, that may be true, but it has nothing to do with Wayland.
07:41:37 <hekkaidekapus> We might get a wayland-monad as a successor to xmonad from the discussion :P
07:42:04 <dolio> I thought someone mentioned that already existed somewhere a while back.
07:42:12 <dminuoso> hekkaidekapus: waymonad already is a thing
07:42:17 <hekkaidekapus> Ah, dunno!
07:42:18 <dminuoso> ttps://github.com/waymonad/waymonad
07:42:56 <hekkaidekapus> heheheheâ¦ The discussion is doomed then :D
07:42:56 <dminuoso> Though work on that one has dried up too
07:44:03 <maerwald> also, my impression of `directory` was that it wasn't written with POSIX or freedesktop spec in mind, so things like https://github.com/haskell/directory/issues/102 pop up now and then
07:45:41 <dminuoso> Im unsure what your point really is. The bug was fixed.
07:45:47 <maerwald> yes, I fixed it :p
07:45:52 * hackage ghc-lib-parser 0.20201101 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20201101 (shayne_fletcher)
07:46:32 <maerwald> but what about other functions
07:46:51 * hackage ghc-lib 0.20201101 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20201101 (shayne_fletcher)
07:46:56 <maerwald> if your main concern is cross platform, I think these things will happen
07:49:20 <maerwald> your mental model is the intersection of windows and linux, not POSIX
08:36:52 * hackage polysemy 1.4.0.0 - Higher-order, low-boilerplate free monads.  https://hackage.haskell.org/package/polysemy-1.4.0.0 (TheMatten)
08:37:51 * hackage polysemy-plugin 0.2.5.2 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.5.2 (TheMatten)
08:44:52 * hackage ghc-lib-parser-ex 0.20201101 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20201101 (shayne_fletcher)
09:16:22 * hackage time-compat 1.9.4 - Compatibility package for time  https://hackage.haskell.org/package/time-compat-1.9.4 (phadej)
09:55:15 <gentauro> Â«6. Which language extensions would you like to be enabled by default? (https://haskellweekly.news/survey/2020.html)Â»: {-# LANGUAGE Safe #-} xD
09:55:35 * gentauro some people just want to see the "Hello, world" burn xD
09:59:37 <fendor> what is the safe language extension even?
10:00:32 <c_wraith> no one really knows
10:00:50 <c_wraith> by which I mean "I've tried to understand it and failed, therefore it's impossible"
10:03:11 <c_wraith> It's a system for marking code as safe.  A safe module can only import other safe modules, or ones that have been marked as trustworthy and you've decided to trust
10:03:56 <fendor> and what is the final purpose? To import dynamically unsafe code?
10:04:04 <c_wraith> But what "safe" actually means is a bit of a mystery to me.  Does it mean type safety, memory safety, freedom from malicious code?
10:04:43 <geekosaur> to mark code which doesn't need to be considered for safety, by some definition of safety which is not itself well defined
10:04:55 <geekosaur> so you in theory can focus on the less safe parts
10:05:18 <monochrom> For example System.IO.Unsafe is not marked as safe, and it is where unsafePerformIO comes from. So you don't allow yourself to use unsafePerformIO, or transitively import from other modules that use unsafePerformIO.
10:05:47 <c_wraith> unless they're trustworthy, of course, which muddles the whole thing
10:06:09 <monochrom> This is why the whole scheme didn't get traction.
10:07:15 <c_wraith> Debug.Trace is explicitly marked as Unsafe.  
10:07:31 <c_wraith> What's unsafe about it?
10:08:05 <maerwald> unsafePerformIO?
10:08:18 <monochrom> It turns out that cultural peer pressure to write pure-functional code and crowd knowledge of which libraries are being naughty are more trustworthy (pun!) than this marker system.
10:08:58 <c_wraith> maerwald: it uses it, but it doesn't export it.  Or anything that can do its job, as far as I can tell.
10:09:14 <monochrom> Also cultural consensus of which usages of unsafePerformIO are acceptable (such as Debug.Trace's)
10:09:58 <c_wraith> I would have marked Debug.Trace as Trustworthy
10:10:21 <c_wraith> But yeah, this is just evidence no one can agree on what Safe actually means
10:10:36 <monochrom> It is useful during development. But it shouldn't stay when shipping production code.
10:11:02 <c_wraith> Sure, but I don't want to have to turn off Safe in half the modules in my program just to debug something
10:11:07 <monochrom> You have f :: Int -> Bool you simply don't expect it to cause some messages on stderr
10:11:22 <monochrom> No disagreement there.
10:13:04 <c_wraith> and sure, I could mark the module I'm debugging as Trustworthy, but then you're back to the status quo, relying on code review (automated via linter or manual) to notice you're doing something sketchy
10:13:26 <monochrom> A simple use of CPP and -DDEBUG the way C programmers have figured out is far simpler and more reliable.
10:13:57 <dsal> I was reading https://www.snoyman.com/blog/2020/10/haskell-bad-parts-1 and found it a little less satisfying.  Don't use `sum` because it's implemented with foldMap and something something.   Just use RIO fo reverything.
10:14:26 <maerwald> RIO :D
10:14:26 <monochrom> #ifdef DEBUG \n import Debug.Trace \n #else \n import AllDebugTraceFunctionsAreNoop #endif
10:14:27 <c_wraith> "don't use sum because it's bad to rely on the optimizer getting the case right that it gets right every time"
10:14:47 <maerwald> I don't even think RIO is bad... it's just not very exciting overall
10:15:21 <c_wraith> RIO is fine.  I'd probably use it, if I were starting an application from scratch.  At least assuming it doesn't drag any of the monotraversable stuff in with it
10:15:30 <dsal> I use unliftio some.  I've not abandoned life as I know it for that religion, though.  Too many little religions out here.
10:16:46 <dsal> I don't like advice where "the simple obvious thing is wrong (in rare cases you probably don't care about)" turns into "always invent your own `sum` when you're adding stuff together"
10:16:52 * hackage quickcheck-instances 0.3.25 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.25 (phadej)
10:17:02 <monochrom> This is why I keep saying that programmers are basically clergy-would-be-but-want-more-money. Just look at Larry Wall.
10:17:22 <koz_> monochrom: Were you the coiner of 'category theology' that time?
10:17:27 <c_wraith> I'm not sure we want more money.  Look at catholic cathedrals.
10:17:29 <monochrom> No.
10:18:02 <dsal> I don't want money, I just want people to do things the right way, but people all have their own wrong ideas of what the right way is.
10:18:52 <suzu_> i'd like money
10:18:54 <suzu_> how do i get the money
10:19:10 <c_wraith> sell your soul to google.
10:19:11 <monochrom> Simply s/do things/find the meaning of life/ and see my point. :)
10:19:14 <maerwald> "The code passes all integration tests. And then someone in Russia with a weird Windows code page set and a Cyrillic character in their name files a bug report 2 years later about how they canât build anything"
10:19:19 <maerwald> Those russians, hahaha
10:19:31 <koz_> maerwald: Vodka, bear, balalaika.
10:19:49 <Rembane> Gopnik programmer memes
10:20:00 <koz_> Rembane: Squat while coding.
10:20:12 <koz_> Who needs standing desk when you have squatting desk?
10:20:40 <Rembane> koz_: Totally. Much better for code and life. 
10:21:06 <maerwald> "instead of readFile, I recommend using readFileUtf8, which is available from rio."
10:21:07 <koz_> Just checked - the desk height for that would be about the height of a chair.
10:21:13 <maerwald> That isn't logical
10:21:26 <maerwald> so we just assume utf8 now?
10:22:09 <monochrom> Why are you wasting your time on Snoyman drivels? :)
10:22:13 <dsal> I got lost in that thing.  I started paying a little less attention to Snoyman when he reviews a Scott Adams book.  It's not a good logical stance, but I can't take anyone seriously who'd take Scott Adams seriously.
10:22:29 <koz_> Yeah, I agree with monochrom here.
10:22:40 <koz_> Just let him live in his weird fantasy world.
10:23:08 <Rembane> Someone has to live in that world, I'm grateful that I don't. 
10:23:14 <koz_> Rembane: Likewise.
10:23:18 <monochrom> To be sure, sometimes he makes some good points. So heed the good advice, and don't worry about the rest.
10:24:23 <MarcelineVQ> this is why anonymity is powerful, you can examine positions instead of people
10:26:16 <MarcelineVQ> s/can/must
10:27:10 <maerwald> I always treat files as bytes and try to delay interpreting content as long as possible.
10:27:41 <maerwald> and often times, you don't need to know much about the contents
10:29:31 <maerwald> anything that does stuff with files more than treating them as bytes has no place in the stdlib
10:30:22 * hackage commonmark 0.1.1 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-0.1.1 (JohnMacFarlane)
10:31:22 * hackage commonmark-extensions 0.2.0.2 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-extensions-0.2.0.2 (JohnMacFarlane)
10:44:03 <maerwald> https://hackage.haskell.org/package/Win32-2.10.0.0/docs/System-Win32-File.html what happened to documentation :(
10:44:42 <maerwald> There's one link to MS docs, which is a proper 404
10:46:06 <geekosaur> "everyone who cares is on unix" happened to documentation, afaict
10:49:50 <suzu_> c_wraith: google sucks
10:49:54 <suzu_> maybe i'd sell my soul to facebook
10:49:58 <suzu_> they actually use haskell there
10:50:12 <hpc> i think that has less to do with it being windows and more to do with it being as thin a C wrapper package as it's possible to be
10:50:37 <maerwald> even ffi bindings should have documentation IMO
10:50:51 <koz_> I'm with maerwald on that one honestly.
10:51:22 <koz_> You don't wanna be doing a two-way diff in your head in a context that delicate.
10:52:04 <hpc> there's opengl-related packages with that level of thinness/documentation as well
10:52:13 <hpc> not saying it should be that way, just what i have observed being correlated
10:54:22 * hackage binary-instances 1.0.1 - Orphan instances for binary  https://hackage.haskell.org/package/binary-instances-1.0.1 (phadej)
10:54:38 <dminuoso> c_wraith: Haha that's interesting, I hadn't looked at RIO ever sine I started haskell. Turns out, after nearly 2 years I've slowly converged on exactly that in many of my apps.
10:54:58 <maerwald> at lest copyFile exists... on Linux, you have `sendfile`, but not all kernels have it
10:55:42 <dminuoso> Though I think I prefer monad-logger as the logging interface.
11:01:04 <suzu_> i use katip a lot
11:05:03 <hekkaidekapus> maerwald: âThis library is just a direct binding to Windows API calls and as such contains no documentation. The documentation for functions can be found in the equivalently named functions on MSDN [URL]â.
11:05:25 <hekkaidekapus> Source: <https://github.com/haskell/win32/blob/master/README.md>
11:05:55 <maerwald> That sentence isn't on the hackage page: https://hackage.haskell.org/package/Win32
11:07:12 <hekkaidekapus> maerwald: The Hackageâs Markdown parser needs an update. See <https://github.com/haskell/hackage-server/pull/904> and the related issues.
11:07:30 <maerwald> I think the README isn't included in the cabal file
11:08:39 <hekkaidekapus> maerwald: Ah, ok.
11:09:19 <hekkaidekapus> A pull request then?
11:09:41 <maerwald> yeah, once my RSI is better
11:09:56 <hekkaidekapus> lol
11:11:44 <maerwald> Yeah, suggestions welcome...
11:11:57 <monochrom> Use a speech recognizer.
11:12:20 <monochrom> "computer, open github.com"
11:12:33 <tomsmeding> "OK Google, open open github.com"
11:13:21 <maerwald> is there a good open source speech recognizer? :)
11:13:27 <hekkaidekapus> koz_ was talking about standing desks a few scroll back.
11:13:34 <maerwald> I have one
11:13:56 <maerwald> a 350 bucks ergonomic keyboard too
11:14:09 <hekkaidekapus> Type matrix?
11:14:37 <maerwald> I think it's since I learned touch typing, but how do you unlearn that :)
11:15:27 <dsal> The problem with text to speech is that you have to learn how to say all those things you type all the time.
11:16:03 <dsal> "Lens for Speech Recognition"
11:18:22 <maerwald> you could teach it klingon and then use klingon words for symbols
11:19:59 <juri_> haskell Hol vlyaj torgh. 
11:20:31 <dsal> If I wanted to yell angrily at my computer, I'd write more JavaScript.
11:21:20 * tomsmeding wonders how well speech recognisers deal with mixing two languages; it sounds like a good way to increase information bandwidth for speakers of multiple languages
11:23:11 <tomsmeding> doing so you also get the advantage of being able to say that you do code-switching while coding
11:25:47 <dsal> I alternate between ASCII and UTF-8 while I'm entering code.
11:27:30 <tomsmeding> difference with my suggestion is that generally, one natural language does not generally fully subsume another ;)
11:28:14 <maerwald> also: https://haskellweekly.news/survey/2020.html
11:30:24 <hekkaidekapus> maerwald: As to the survey, in another channel, the admin put the URL into /topic.
11:30:44 <hekkaidekapus> monochrom: Would you mind? ^^^
11:31:32 --- mode: ChanServ set +o monochrom
11:32:00 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Survey 2020: https://haskellweekly.news/survey/2020.html' by monochrom
11:32:16 <hekkaidekapus> Nice!
11:33:44 <tomsmeding> ð even longer topic :)
11:34:19 --- mode: monochrom set -o monochrom
11:34:25 <MarcelineVQ> data is good I guess, though answering what exensions should be default last time I did the survey didn't make any more extensions the default :>
11:34:34 * hekkaidekapus is trying to increase participation to the survey from IRC folks. That way, the surveyâs results might be less biased towards fellows who have loud-speakers on Twitter/Reddit/â¦
11:34:51 <tomsmeding> maerwald: "I think it's since I learned touch typing" -- assuming you mean the home-row-centric qwerty typing style, interesting, I never learned that and have my own homebrew kind of finger movement which is somewhat less static
11:34:58 <tomsmeding> I wonder how I will fare
11:35:22 * hackage cut-the-crap 2.3.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-2.3.0 (Jappie)
11:35:32 * tomsmeding already filled in the survey from the haskell-cafe announcement :p
11:35:35 <MarcelineVQ> I still look at my fingers even though I don't need to, habits are weird
11:36:49 <Rembane> Maybe you have really pretty fingers? 
11:37:03 <MarcelineVQ> it's possible
11:38:22 <yushyin> having blank keycaps helps, it took my about a month to get used to my redox keyboard
11:40:48 <yushyin> a long and very frustrating month that was
11:42:03 <MarcelineVQ> a qong ang frusttating momfh
11:42:31 <tomsmeding> as for the IRC topic, does #haskell-offtopic even exist?
11:43:04 <Rembane> tomsmeding: Yes
11:43:24 <tomsmeding> alis doesn't know about it
11:44:05 <gobbleguy> tomsmeding, channels set +s (secret) don't show up in alis
11:44:21 <tomsmeding> ah
11:45:15 <gobbleguy> I would guess that's because it's intended for #haskell regulars to have a place to be offtopic, not a place for people looking to be offtopic to go in general
11:48:12 <juri_> ourvey completed.
11:48:22 <juri_> survey, even.
11:48:35 <tomsmeding> both?
11:48:59 <juri_> there are two?
11:49:08 <tomsmeding> no, was just joking about the typo :p
11:50:25 <juri_> :)
11:55:26 <hekkaidekapus> MarcelineVQ: Yeah, I am not really fond of the survey but it has gained oversized importance in various places, so better to icrease its inclusiveness than to ignore it and still get indirectly impacted by its results.
11:55:39 <hekkaidekapus> Viz: <https://mail.haskell.org/pipermail/ghc-steering-committee/2020-October/001822.html>
11:56:21 <MarcelineVQ> sure, it's a useul thing to have to guage user metrics if nothing else
11:57:53 <juri_> I am disappointed there's not a selection for more than 30 years programming experience.
11:57:56 <MarcelineVQ> fwiw I'm not a big fan of OverloadedStrings on by default and find it interestings it's sitting right at the top
11:58:29 <ski> MarcelineVQ : i used to only look at the keyboard, when typing, only glacing up at the screen now and then to check for mistakes
11:59:39 <dminuoso> OverloadedStrings has caught me by surprise a few times.
12:00:23 <dminuoso> For Text I'd love it, but sadly there's illplaced instances like `IsString ByteString` or `(a ~ Tokens s, IsString a, Eq a, Stream s, Ord e) => IsString (ParsecT e s m a)`
12:00:53 <ski> (and i never learned the "proper touch typing", either. but i use more fingers than two, although pinkies not that often)
12:00:54 <tomsmeding> how does "Other" have 212% of the votes
12:02:34 <maerwald> tomsmeding: I don't have qwerty, I use workman, which is a modification of colemak, focussing on "finger roll" (same hand use during typing a word)
12:03:02 <koz_> tomsmeding: Russia-style voting?
12:03:51 <MarcelineVQ> vote bald, vote not-bald, vote bald, vote not-bald?
12:04:14 <koz_> MarcelineVQ: LOL, that, and winning elections with 110% of the vote.
12:04:31 <dminuoso> koz_: Oh that sounds more like an US election then.
12:04:37 <MarcelineVQ> Oh, that's everywhere :>
12:04:47 <koz_> dminuoso: No, that's winning elections with _10%_ of the vote instead.
12:05:16 <dminuoso> I wonder, has someone does the math what the lowest popular vote is one could have but still win the electoral college in the US?
12:05:38 <koz_> dminuoso: Nate Silver might have?
12:05:43 <koz_> It sounds on-brand for him.
12:05:58 <mgalese> https://www.npr.org/2016/11/02/500112248/how-to-win-the-presidency-with-27-percent-of-the-popular-vote
12:06:18 <mgalese> Despite the slug, it's 23 percent
12:06:19 <MarcelineVQ> y'all be trippin, this is a channel for talking about typing
12:07:11 <dminuoso> mgalese: Well and thats assuming faithful electors! 
12:07:14 <tomsmeding> typing on workman, evidently
12:07:24 <koz_> MarcelineVQ: Yes.
12:07:26 <dminuoso> Presumably you could get near 0% of the popular vote and still become president.
12:07:32 <koz_> For more than one definition of 'typing'.
12:07:34 <dminuoso> If all the electors were faithless
12:07:37 <mgalese> And more on topic,  ---  is there a way to use Deriving Via with a specific member of a record?
12:07:39 <tomsmeding> maybe I should switch to a better layout at some point but I probably won't
12:07:57 <koz_> tomsmeding: I already needed almost a month to adjust to the layout differences of the ErgoDox EZ.
12:08:07 <koz_> And that's only a _minor_ deviation from qwerty.
12:08:12 <mgalese> As in, if I had a record with a member "seqNo :: SequenceNo", deriving an Ord instance based on the SequenceNo type
12:08:17 <koz_> So I totally get why switching is hard.
12:08:30 <dminuoso> mgalese: No, you derive via a different type that can be coerced to
12:08:50 <dminuoso> mgalese: So if there no Coercible between the two, then you cant have deriving via
12:09:20 <dminuoso> And a field of a data does not have the same runtime representation as the struct holding it, unless it was the only member
12:09:31 <dminuoso> s/struct/data/
12:09:56 <dminuoso> So you'd have to write out that instance by hand
12:10:22 * hackage haskell-gi-base 0.24.4 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.24.4 (inaki)
12:11:03 <mgalese> Yeah, I meant more "morally" like Deriving Via.  It just feels wrong to have an instance definition where every member f is nothing more than  f = f . field   
12:11:40 <dminuoso> Not that I know of generally. For single member instances you could rig TH easily
12:11:52 <dminuoso> *single method
12:11:54 <dminuoso> gosh
12:12:38 <dminuoso> mgalese: Ive grown used to it honestly. You happen to see this often with classy lenses.
12:17:44 <maerwald> tomsmeding: I'm considering to switch to dvorak, because it's optimized for alternating hands, which, I believe, reduces strain in your hand, because typing a single word is always distributed over both hands
12:18:20 <maerwald> that might be a bit slower than the rolling finger model, but you probably don't notice that below 60wpm anyway
12:18:21 <tomsmeding> not knowing much about the space, that sounds better ergonomically, indeed
12:19:03 <maerwald> and if you do programming at more than 60wpm, I'm not sure I want to run your code :)
12:19:40 <idnar> maerwald: it also reduces hand travel distance which reduces wrist strain
12:19:55 <maerwald> idnar: nah, workman has better travel distance than dvorak
12:20:24 <[exa]> random though, possibly a dumb question-- is there some straighforward way to use lens-ish accessors on mutable stuff, like MVectors?
12:20:48 <koz_> [exa]: You could write getters, but the setting half would be a problem.
12:20:55 <idnar> maerwald: ah well, I assumed switching from qwerty
12:21:07 <koz_> Since mutable 'setters' don't return a new structure, they return ().
12:22:18 <idnar> maerwald: guess that's what I get jumping in late ;)
12:22:33 <maerwald> idnar: another note is that workman is heavier on the left hand than dvorak
12:28:53 <yushyin> a different layout was not for me, I tried and failed hard :D. I was already used to write with 10finger touch typing. So I'm back to qwerty with a custom layer for symbols.
12:29:37 <maerwald> switching was rather quick for me, but it's still several weeks of pain and non-productivity
12:29:55 <maerwald> also, how do you explain that to your colleagues?
12:30:19 <maerwald> that you need 6x the time for a regular PR
12:31:09 <maerwald> get half the salary for the transition period? :o
12:32:03 <maerwald> might as well learn coding on a unicycle
12:33:08 <yushyin> maerwald: but I'm quite happy with my symbols layer and make good use of it while programming https://paste.xinu.at/LBy8/#n66
12:33:09 <maerwald> (although, you might actually get funding for that, if you promise to make a youtube video about it)
12:33:43 <yushyin> can recommend ^^
12:33:45 <maerwald> yushyin: here's my layout https://configure.ergodox-ez.com/ergodox-ez/layouts/LMBRq/latest/0
12:34:04 <koz_> [insert some kind of 'strong typing' joke here]
12:35:02 <yushyin> maerwald: nice!
12:38:57 <maerwald> yushyin: so basically, when you press your left ring finger, yo right hand homerow is on -<>=
12:39:08 <maerwald> which is your most common haskell symbols
12:43:02 <yushyin> true! unfortunately I write haskell the least often
12:47:07 <[exa]> koz_: well technically setters can return the "reference" MVector
12:47:16 <koz_> [exa]: Yeah, they could indeed.
12:47:21 <[exa]> koz_: the problem is where to put the ordering effect
12:47:40 <koz_> Yeah, that'd pose a problem.
12:47:56 <koz_> Since you end up with 'm blah', and you need 'blah'.
12:50:37 <[exa]> hm, googling reveals `traverseOf` and `mapMOf`
12:50:42 <[exa]> this is gonna be a long evening
13:16:47 <Tuplanolla> Upon seeing the 2020 State of Haskell Survey, I realized I haven't really used Haskell in 2020.
13:17:55 <suzu_> what have you been using instead?
13:18:09 <Tuplanolla> It has been a year of OCaml.
13:40:22 * hackage integer-logarithms 1.0.3.1 - Integer logarithms.  https://hackage.haskell.org/package/integer-logarithms-1.0.3.1 (phadej)
13:41:40 <Tuplanolla> I hope to be pleasantly surprised when I pick Haskell up again.
13:43:39 <[exa]> If you could change one thing about Haskell, what would it be?
13:43:48 <[exa]> "one more compiler"
13:44:36 <Tuplanolla> I want easily predictable performance from the compiler and the executables it produces.
13:44:54 <hpc> both-directions-typesafe rust ffi
13:44:57 <Tuplanolla> (Note that I did not say "good performance".)
13:45:13 <hpc> (importing haskell in rust, and importing rust in haskell)
13:49:55 <maerwald> Tuplanolla: I'm not sure easily predictable performance is even possible with lazy evaluation
13:50:12 <maerwald> so it might not just be a compiler issue, but a language limitation
13:51:46 <Tuplanolla> Indeed.
13:52:22 <Tuplanolla> That's the one thing I would change.
13:52:31 <maerwald> lenient evaluation?
13:55:15 <Tuplanolla> Get rid of lazy evaluation, if that's what it calls for.
13:57:41 <davean> Tuplanolla: why would you want that?
13:57:47 <davean> Tuplanolla: You'd just want worse performance?
14:01:07 <Tuplanolla> I don't like surprises.
14:01:50 <davean> Tuplanolla: vs. only good surprises?
14:02:29 <Tuplanolla> That's not realistic.
14:03:43 <hoppfull> I'm having some challenges with template haskell. I want to run a side effect during compilation. I know template haskell should be a last resort but it's an important part of my toolbox. I want to read a decode a json file and have its value checked and instantiated at compile time. So I have an effect loadmyfile :: IO MyType. I want to turn it
14:03:44 <hoppfull> into MyType. So I was thinking I need to call $$(runIO loadmyfile) but I get error Expected type: Q (TExp HelloConfig) Actual type: Q HelloConfig. I don't know how to solve this.
14:04:21 * hackage bitcoind-rpc 0.2.0.0 - A streamlined interface to bitcoin core using Haskoin types and Servant  https://hackage.haskell.org/package/bitcoind-rpc-0.2.0.0 (IanShipman)
14:05:21 * hackage bitcoind-regtest 0.2.0.0 - A library for working with bitcoin-core regtest networks  https://hackage.haskell.org/package/bitcoind-regtest-0.2.0.0 (IanShipman)
14:06:05 <c_wraith> hoppfull: if you're on a sufficiently new ghc, https://hackage.haskell.org/package/template-haskell-2.16.0.0/docs/Language-Haskell-TH-Syntax.html#v:liftTyped
14:07:37 <c_wraith> hoppfull: if you're not on a sufficiently new version of GHC, you can combine lift (right above that) with the TExp constructor
14:08:04 <koz_> If I'm trying to push a revision, what does this response from Hackage mean? 'The new x-revision must be 1'
14:08:10 <hoppfull> c_wraith, thank you, I just created a new project and have lts-16.20. I think it's GHC-8.8.2
14:39:30 <davean> Tuplanolla: In my experience I can calculate performance as "How fast would the strict version be, ok thats the slowest it can be"
14:40:29 <Tuplanolla> You have never used the lazy state transformer by accident?
14:41:12 <davean> No?
14:42:44 <Tuplanolla> It's really easy to accumulate thunks with it, until you run out of working memory.
14:52:36 <dolio> I accidentally did that once like 15 years ago when I was first learning. Then it hasn't been a serious problem since.
14:55:38 <davean> Also they're *semanticly* different
14:55:46 <davean> so You just can't have the one when you're using the other
14:55:52 <davean> Thats litterly different *meaning* of code
14:56:09 <davean> So sure, if you implimented the Lazy State in strict, it also would perform the same way
14:56:11 <davean> ask for what you mean
14:56:14 <davean> thats ... all?
14:56:34 <dolio> It might not have been accidental. I don't recall if there was a 'strict' one at the time. I don't really recall thinking it was a big deal, though.
14:56:34 <davean> Like Strict and Lazy state are litterly entirely different things, conceptually.
14:57:07 <davean> dolio: sure
14:57:13 <davean> I'm more addressing Tuplanolla's point
14:57:28 <davean> but comparing one alg in strict and an entirely different one in lazy isn't a comparison
14:57:48 <davean> you should know which alg you're using, and you'll get the strict performance or better in a non-strict language.
14:58:05 <davean> (Well, coefficients can differ, though not usually much - interesting discussion that)
14:59:49 <davean> Shortest path is also faster than all-pairs shortest path, unless you want all pairs shortest path
15:08:14 <hoppfull> I have a Q MyType. Is there no way of getting MyType out? Am I missing something here? Am I supposed to coerce it or something? runQ only seems to evaluate the expression at runtime.
15:08:45 <dolio> Q is a monad, right?
15:09:56 <hoppfull> Yeah
15:10:18 <hoppfull> So what's the point of template haskell?
15:10:39 <dolio> To generate Haskell code programatically at compile time.
15:10:39 <hoppfull> I got the impression I could read files and stuff on compile time with runIO
15:17:44 <cheater> that's not what runIO is for
15:17:47 <cheater> :t runIO
15:17:48 <lambdabot> error: Variable not in scope: runIO
15:17:48 <dolio> Well, in the error message you mentioned above, it wasn't even complaining about the Q part, it was complaining that the things inside the Q didn't match.
15:21:48 <dolio> Ergo, you don't need to 'get something out' of Q, you need to use it like any other monad.
15:43:31 <unihernandez22> Hi
15:44:22 * hackage GPipe-GLFW 1.4.1.4 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.4.1.4 (plredmond)
16:52:04 <Raito_Bezarius> can I unpack Maybe [a] into [a] using prelude?
16:52:12 <Raito_Bezarius> saying that None â [] and Some l â l
16:52:42 <c_wraith> why Prelude in particular?
16:52:54 <Raito_Bezarius> hm, rather base libraries then
16:53:23 <c_wraith> :t fromMaybe []
16:53:24 <lambdabot> Maybe [a] -> [a]
16:53:30 <Raito_Bezarius> thanks, c_wraith !
17:08:29 <koz_> foldMap (: []) works too I think?
17:11:32 <MarcelineVQ> that'd be  Maybe a -> [a]   but foldMap id  should be fine
17:13:50 <MarcelineVQ> > fold (Just [3]) -- I like to write fold instead of foldMap id tho
17:13:52 <lambdabot>  [3]
17:14:44 <koz_> MarcelineVQ: You could do 'foldMap pure' as well.
17:14:49 <MarcelineVQ> 'just prelude'  would be  maybe [] id   tho
17:14:54 <koz_> But fold is the slickest.
17:15:04 <koz_> 'foldMap id' is Prelude-only-able.
17:15:38 <MarcelineVQ> watch this shit
17:15:43 <MarcelineVQ> > concat (Just [3])
17:15:45 <lambdabot>  [3]
17:17:57 <koz_> MarcelineVQ: Ooooooo
17:18:01 <koz_> SpoooOOOky
17:18:40 <hololeap> was concat always Foldable t => t [a] -> [a]?
17:20:12 <davean> no, foldable didn't always exist, why?
17:42:32 <edwardk> clearly it should be redefined to 'foldMap toList', as the toList definition for list is the identify function, and then it can be (Foldable f, Foldable g) => f (g a) -> [a]
17:43:02 <edwardk> missed opportunity
17:43:43 <edwardk> we could kill so many catMaybes with that
17:47:02 <dolio> In Haskell 1.4 it was `MonadPlus m => [m a] -> m a`
17:57:52 * hackage gargoyle 0.1.1.0 - Automatically spin up and spin down local daemons  https://hackage.haskell.org/package/gargoyle-0.1.1.0 (abrar)
17:58:52 * hackage gargoyle-postgresql-nix 0.3.0.0, gargoyle-postgresql 0.2.0.0 (abrar): https://qbin.io/joint-mixer-6yez
17:59:52 * hackage gargoyle-postgresql-connect 0.1.0.0 - Connect to gargoyle-managed postgresql instances  https://hackage.haskell.org/package/gargoyle-postgresql-connect-0.1.0.0 (abrar)
18:04:06 <hololeap> i just remembered it being [[a]] -> [a], but maybe this was a simplification presented to beginners
18:05:57 <davean> ew, ugly, who uses lists? :-p
18:10:37 <dsal> Is this #lisp?
18:11:05 <davean> Apparently.
18:11:19 <davean>  /part
18:11:21 <nshepperd> hee, foldMap toList is a nice trick (but wait, is it efficient? maybe it should be toList . foldMap toDiffList)
18:11:25 <davean>  /join #haskell
18:24:05 <Raito_Bezarius> Dis there a way to easily debug when megaparsec seems to do an infinite loop?
18:24:08 <Raito_Bezarius> -d
18:24:19 <Raito_Bezarius> I tried to put dbg but it's quite tedious as I have many parsers
18:27:09 <dolio> It was [[a]] -> [a] in Haskell 98 and 2010, I think.
18:30:55 <sm[m]> Raito_Bezarius: add a bunch of dbg, trace, or just an error call. Reload in ghci to see changes faster
18:31:19 <Raito_Bezarius> sm[m]: unfortunately adding a bunch didn't give me anything
18:31:33 <Raito_Bezarius> I think it was in the internals of makeExprTable
18:31:35 <Raito_Bezarius> or something
18:31:43 <sm[m]> move them around until you narrow down where it gets stuck
18:31:54 <sm[m]> or, comment out code until it stops doing that
18:32:08 <Raito_Bezarius> I was wondering of a method which can "enable" some verbose mode in megaparsec in general
18:32:26 <Raito_Bezarius> this method of moving out things does not seem to scale well with a lot of parsers alas
18:32:38 <Raito_Bezarius> but maybe this is a proficiency thing
18:32:50 <Raito_Bezarius> (and I'm already using ghci+parseTest+reload)
18:33:03 <hololeap> \
18:33:22 <hololeap> dolio: good to know. i remember seeing that in a tutorial somewhere.
18:34:24 <sm[m]> in hledger, I do it in two ways. 1, include debug/trace statements in most parsers, which activates only with --debug=N. 2, insert such statements temporarily where needed, for quick troubleshooting in GHCI
18:35:25 <hololeap> Raito_Bezarius: just found this https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec-Debug.html
18:36:01 <hololeap> from here https://hoogle.haskell.org/?hoogle=debug%20package%3Amegaparsec
18:36:04 <sm[m]> Raito_Bezarius: 1 (permanent, optional tracing) is handy to see the big picture, and for troubleshooting user installations. 2 (temporary tracing) is good for targetted debugging
18:36:34 <Raito_Bezarius> hololeap: this is the dbg I spoke about afaik
18:37:07 <Raito_Bezarius> if a dbgAll would exist and would recursively set dbg to all subparsers that'd be nice
18:37:13 <Raito_Bezarius> but I suppose it'd create too much verbose output
18:37:29 <sm[m]> yes that would be nice, and yes would need to be optional
18:37:44 <Raito_Bezarius> I agree that would have to be optional
18:38:30 <sm[m]> you might need a bit more practice, it shouldn't take too many traces & ghci reloads to narrow down the problem
18:38:45 <Raito_Bezarius> in fact, some minutes after I realized what was going on
18:38:53 <sm[m]> heh
18:38:54 <Raito_Bezarius> but I admit that with too much tiredness in the blood, it's quite hard
18:39:03 <Raito_Bezarius> so I was wondering of a better way :p
18:39:10 <Raito_Bezarius> thanks for the advice sm[m] though :)
18:39:39 <sm[m]> I think both ways have their uses.. and stepping in a debugger would also be a nice option, not so easy for us alas
18:44:23 <Raito_Bezarius> is there a way to create record using Applicative syntax?
18:45:47 <gobbleguy> Raito_Bezarius: this is doing that: https://github.com/glguy/irc-core/blob/v2/src/Client/Configuration/ServerSettings.hs#L421-L430
18:46:11 <gobbleguy> with the ApplicativeDo and RecordWildCards extensions
18:46:37 <Raito_Bezarius> thanks gobbleguy !
18:47:00 <sm[m]> and you know about doing it with function syntax I guess: Foo field1val field2val ...
18:47:22 <Raito_Bezarius> oh right, sm[m] 
18:47:25 <Raito_Bezarius> nice :-)
18:47:50 <sm[m]> but RecordWildCards requires less maintenance as your record changes. Might also be more error-prone/less-readable for some
18:51:23 * sm[m] loves RecordWildCards
18:58:25 <xsperry> what would make it more error-prone?
19:00:06 <dsal> NamedFieldPuns
19:03:27 <dsal> Er, that'd make it less error prone.
19:07:30 <dsal> gobbleguy: You can reduce the redundancy of the `fromMaybe "" <$> optSection'` there
19:08:16 <dsal> Actually, more than that.
19:36:52 * hackage macrm 1.0.0.5 - Alternative rm command for macOS that remove files/dirs to the system trash  https://hackage.haskell.org/package/macrm-1.0.0.5 (satosystems)
19:48:20 <dsal> Woah, that's a lot of code.
19:49:53 <MarcelineVQ> system $ printf "mv %s %s" file dest
19:50:19 <dsal> https://github.com/dustin/trash/blob/master/trash.m <-- I wrote this in objc using the native support for trashing.
19:50:37 <MarcelineVQ> kernel support for trashring?
19:52:08 <dsal> The ~/.Trash thing is kind of special and the behavior of dragging files in is a little magic.  The second time you drop a file in with the same name, e.g., you get some anti-collision stuff and such.
21:19:24 <jackdk> Where do the names `Star` and `Costar` come from? (The ones that appear in `profunctors`)
21:32:01 <int-e> jackdk: I guess a combination of notation, namely F^*, and an affinity for movie references.
21:33:50 <int-e> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html called them UpStar for F^* and DownStar for F_*
21:47:41 <jackdk> so the Costar thing is a pun, like Biff/Tannen?
21:51:46 <int-e> jackdk: well, maybe :)
21:52:00 <int-e> but there is also an actual duality
22:11:31 <danso> i see this pattern often in my code where i end up in many nested `case` expressions 
22:11:34 <danso> https://github.com/ninedotnine/soucc/blob/main/src/TypeChecker/TypeChecker.hs#L61-L75
22:12:05 <danso> usually `do` notation makes these go away, but here it only works for the outer monad (State) 
22:12:12 <danso> and i would like it to work with Either as well
22:12:31 <danso> i'm sure i've read about the cure for this problem on a blog somewhere, but i don't know how to find it now. help? 
22:13:46 <jackdk> danso: sounds like a job for monad transformers, specifically ExceptT
22:14:19 <jackdk> if I understand you correctly, you can temporarily work with a transformer, you don't have to use it all over your program
22:14:56 <jackdk> `run_globals defns = runExceptT $ do ...` etc
22:15:53 <danso> thanks, i will start reading 
22:16:10 <danso> this occurs in many places in my program; maybe it would be appropriate to use ExceptT throughout
22:38:24 <danso> does it make a difference whether i use `StateT s (Either e a)` or `ExceptT e (State s) a` ? 
22:52:35 <int-e> danso: They're isomorphic as types, but the latter has a handy Monad instance that propagates errors (approximately what your `case`s do)
22:52:58 <int-e> (or exceptions, whatever)
22:54:29 <int-e> danso: Err
22:55:14 <int-e> danso: Sorry, I misread because the former is wrong... you must have meant StateT s (Either e) a.
22:55:51 <int-e> danso: In which case, the main difference is that the former will forget the state on an exception/error.
22:56:12 <danso> ah i see i mistyped 
22:56:17 <danso> oops
22:56:33 <danso> okay, i definitely want to keep the state
22:56:36 <danso> thanks int-e 
22:57:14 <danso> curious, why does that happen?
23:00:07 <int-e> @unmtl StateT s (Either e a)
23:00:08 <lambdabot> err: `StateT s (Either e a)' is not applied to enough arguments, giving `/\A. s -> Either e a (A, s)'
23:00:12 <int-e> @unmtl StateT s (Either e) a
23:00:13 <lambdabot> s -> Either e (a, s)
23:00:51 <int-e> Because StateT puts the resulting state into the monadic return value and Either's Left doesn't have one.
23:01:02 <int-e> @unmtl ErrorT e (State s) a
23:01:02 <lambdabot> s -> (Either e a, s)
23:02:12 <int-e> Whereas this always has a state. (ErrorT is a bit weird and deprecated, but @unmtl doesn't know ExceptT)
23:03:07 <danso> ah thanks, the ErrorT left me confused
23:21:35 <energizer> what is the name of the function that takes f : X -> Y and Either X Null, if a is Null returns Null otherwise `f a`?
23:22:52 <energizer> (forgive my word choice, i'm not experienced with this kind of stuff)
23:24:21 <energizer> for example, it takes addOne and either a number or null, and if it's null returns null, but otherwise increments the number
23:25:09 <energizer> f addOne null = null; f addOne 3 = 4
23:25:39 <danso> what you're talking about is basically fmap
23:25:56 <danso> but you seem to be mixing a few different ideas here
23:26:03 <energizer> oh?
23:26:25 <danso> @t fmap
23:26:25 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
23:26:34 <danso> @type fmap
23:26:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:27:05 <danso> is your `Null` defined like `data Null = Null` ? 
23:27:24 <danso> i think you most likely mean Maybe instead of Either
23:27:52 <energizer> Maybe sounds like like it's in the right direction
23:28:13 <danso> also fmap on Either maps a function over the right side, not the left one
23:28:37 <danso> fmap on maybe is 
23:28:50 <danso> fmap f (Just a) = Just (f a)
23:28:56 <danso> fmap f Nothing = Nothing 
23:29:05 <energizer> yeah that's what i mean ^
23:29:40 <danso> if you want to get cute you could use <$> or <&> 
23:29:57 <dminuoso> In fact, <$> is very typical 
23:30:05 <danso> a <&> f is the same as `fmap f a` 
23:30:31 <dminuoso> With a bit of squinting <$> behaves a bit like ($), which is possibly why they both have a dollar in their name.
23:33:05 <energizer> how is <$> used here?
23:33:31 <danso> f <$> a 
23:33:52 <danso> `<$>` is the same as `flip <&>` 
23:33:56 <danso> @type <$>
23:33:58 <lambdabot> error: parse error on input â<$>â
23:34:02 <danso> @type (<$>)
23:34:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:35:34 <energizer> ok i get it
23:36:06 <dminuoso> c.f.:
23:36:09 <dminuoso> :t ($)
23:36:11 <lambdabot> (a -> b) -> a -> b
23:37:38 <energizer> is <$> or <&> more used?
23:37:48 <dminuoso> <$> by far
23:38:07 <dminuoso> Depending on the project and situation you might either see fmap or <$> being used more
23:38:12 <dminuoso> Sometimes its handy to use both at the same time
23:38:20 <dminuoso> fmap f <$> g
23:39:25 <danso> haskellers are pretty inconsistent on this point, you can see
23:39:51 <danso> <$> is preferred over <&> but >>= is preferred over =<< 
23:40:00 <dminuoso> Dunno about that
23:40:05 <dminuoso> I prefer =<< by far :p
23:40:24 <danso> and i prefer <&> ! 
23:40:26 <dminuoso> In fact, =<< often arises when I write code with <$> first, just to realize it should have been bind instead.
23:40:35 <danso> i don't think either of us are in the majority though :^)
23:40:37 <dminuoso> I found <&> to be useful in writing decoders :)
23:41:06 <dminuoso> f x 1 = getWord32 <&> Something
23:41:10 <dminuoso> f x 2 = getWord32 <&> AnotherThing
23:41:22 <dminuoso> For a sufficiently large f this aligns much more nicer
23:41:30 <danso> one of the haskell survey questions should have been >>= vs =<<
23:41:43 <danso> pity we just missed it
23:41:50 <dminuoso> Didn't get the memo
23:46:12 <energizer> why is it called <&> ?
23:46:50 <dminuoso> energizer: Presmuably because (&) is a flipped ($)
23:47:01 <dminuoso> % :t ($)
23:47:02 <yahb> dminuoso: (a -> b) -> a -> b
23:47:04 <dminuoso> % :t (<$>)
23:47:04 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
23:47:07 <dminuoso> % :t ($)
23:47:08 <yahb> dminuoso: (a -> b) -> a -> b
23:47:10 <dminuoso> % :t (<$>)
23:47:11 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
23:47:30 <dminuoso> % :t (<&>)
23:47:30 <yahb> dminuoso: Functor f => f a -> (a -> b) -> f b
23:47:31 <dminuoso> Sorry
23:47:33 <dminuoso> :)
23:47:38 <dminuoso> % :t (&)
23:47:38 <yahb> dminuoso: a -> (a -> b) -> b
23:49:13 <energizer> alright, so why are they called & and $ ?
23:49:26 <danso> dminuoso, the survey is definitely still open
23:49:29 <danso> i believe it was posted today
23:49:50 <danso> energizer, because they're common things to do, so they should be short
23:50:49 <energizer> $ kinda looks like flipping, yknow
23:51:32 <energizer> & is like 'and' but i'm not sure if fmap is related to 'and'
23:51:36 <dminuoso> Well you have to call them something..
23:51:55 <dminuoso> There's very limited ASCII characters available
23:52:55 <energizer> yeah sometimes notation is just "gotta pick something" and sometimes there's a hidden connection to some concept
23:53:00 <danso> i think you have misunderstood
23:53:05 <danso> $ is apply 
23:53:09 <danso> as in function application
23:53:14 <danso> f(x) is f $ x 
23:53:16 <dminuoso> energizer: I dont think there's a particular reason for those choices on function application.
23:53:35 <danso> & is apply with its arguments flipped, so x & f is f(x) 
23:53:57 <energizer> mhmm
23:54:09 <danso> the parallel is that <$> is fmap and <&> is fmap with its args flipped
23:54:22 <dminuoso> energizer: You could ask on haskell-cafe though, if you're curious.
23:54:32 <energizer> ok that does make it clearer. thanks.
23:54:36 <dminuoso> It's possible someone there knows of a connection, perhaps they were burrowed from another language
23:54:52 <dminuoso> Or maybe from some field in mathematics
23:55:15 <dminuoso> Though I think the primary reason would be
23:55:39 <dminuoso> There aren't many other characters ASCII characters left that suggest different things
23:56:06 <dminuoso> -+*^ are already used for arithmatic
23:56:13 <danso> i don't know of languages that predate haskell that use an operator for fn application
23:56:25 <dminuoso> @ cant be used as a standalone operator because its used for as-paterns
23:56:32 <danso> i suspect the same as you. what else would it be? @? #? ~? 
23:56:53 <dminuoso> So what you're left with is #, $ and &
23:57:04 <danso> @-patterns were only added into ghc in the last few years, i think
23:57:04 <lambdabot> Unknown command, try @list
23:57:12 <dminuoso> Oh, then include @ in that list
23:57:23 <danso> $ definitely predates it by at least 15 years
23:57:26 <dminuoso> Out of those, perhaps $ renders less widely and reads better than the rest.
23:57:41 <energizer> coulda been `??`   ?
23:57:47 <dminuoso> Sure, could have.
23:58:06 <dminuoso> But then you'd ask "why chose ?? and not $" :)
23:58:12 <energizer> heheh
23:58:30 <danso> is ? actually used for anything other than implicit params? 
23:58:45 <danso> it might not be an allowed operator character
23:58:51 <dminuoso> % f ? g = f + g
23:58:51 <yahb> dminuoso: ; <interactive>:324:1: warning: [-Wname-shadowing] This binding for `f' shadows the existing binding defined at <interactive>:168:1
23:58:53 <dminuoso> Seems fine
23:59:14 <danso> hm, i don't recall ever seeing it used
23:59:43 <dminuoso> ? is used a lot in lens operators
23:59:52 <dminuoso> Think it's usually for things that deal with Maybe
