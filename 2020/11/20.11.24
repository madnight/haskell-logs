00:04:32 <merijn> Maybe some obscure old compiler :p
00:05:14 <merijn> dminuoso: https://mail.haskell.org/pipermail/haskell/2004-February/013720.html
00:05:40 <xerox_> what is the policy for personal projects on gitlab.haskell.org?
00:06:06 <dminuoso> xerox_: Id venture this is best asked in #ghc or the GHC mailing list as the responsible people for that gitlab are there
00:06:18 <xerox_> aye aye
00:07:10 <dminuoso> merijn: Heh yeah seems that way. I also found a publication, but nothing so far in the GHC code..
00:07:21 <dminuoso> At any rate, I have somethingy you're gonna *love*
00:07:38 <xerox_> *presents puppy*
00:07:45 <dminuoso> merijn: https://github.com/DaveGamble/cJSON/blob/master/cJSON.h#L162
00:07:52 <dminuoso> You should be able to appreciate that one
00:18:34 <merijn> dminuoso: I think I just linked that to my brother :p
00:19:25 <dminuoso> merijn: Did you also see the related issue?
00:19:31 <dminuoso> Or try and git blame that?
00:19:52 <merijn> No, because I already have enough things to be depressed about
00:20:08 <dminuoso> https://github.com/DaveGamble/cJSON/issues/255 https://github.com/DaveGamble/cJSON/commit/65541b900c740e1d527cd4f1935eec3740d4d95a
00:20:12 <dminuoso> It'll make you happy!
00:20:41 <dminuoso> It's not even just poor reasons. It's a plain "I cant say why"
00:22:04 <dminuoso> "because of inaccuracies when reserving memory" memory allocates are usually fuzzy!
00:22:19 <dminuoso> Maybe malloc should take a float :>
00:25:06 <n0042> Hello fellow Haskellians, Haskellites, Haskellers, and users of Haskell in general. I am interested in reading some articles on writing highly optimized Haskell, if anyone has any they are fond of. 
00:26:41 <dminuoso> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/sooner.html
00:26:45 <n0042> I am currently taking a class that is designed for people using imperative languages (in particular C++ and Java), but they offer the option of using Haskell, and I'm having trouble getting it to meet the time and space requirements. I know it's possible, or they wouldn't offer the option. I'd like to read up on tips and tricks to write Haskell in
00:26:46 <n0042> a very time/space-conscious way
00:26:54 <dminuoso> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/profiling.html#profiling
00:27:15 <n0042> Thank you friend. I'll start there.
00:27:36 <merijn> dminuoso: You forgot the all important "+RTS -sstderr"
00:27:57 <merijn> n0042: Compile with -rtsopts and run with "+RTS -sstderr" to get GC diagnostics
00:29:44 <dminuoso> n0042: Writing efficient Haskell is usually a mixture of ensuring inlining/specialization/fusion occurs, identifying sharing opportunities, chosing the right data structures ([] vs Vector), etc
00:30:01 <dminuoso> And controlling strictness
00:30:46 <dminuoso> But the above articles are a good starting point
00:30:47 <n0042> The way the class works means I know which flags will be used to compile the code I turn in (ghc -O), but beyond that it's all down to how I choose to write it. Those are the kinds of tips I need, for sure.
00:30:58 <n0042> I'll read those articles and look into more Data structure types. Thank you.
00:31:08 <dminuoso> The class will compile your code with `ghc -O`?
00:31:13 <n0042> yessir
00:31:36 <aloiscochard[m]> hey there, I'm wondering if there is vim/emacs users that are still using codex? of if everyone moved to the LSP stuff?
00:31:48 <dminuoso> aloiscochard[m]: Most IDE efforts have moved to LSP stuff.
00:32:12 <dminuoso> n0042: should be fine then.
00:33:06 <dminuoso> n0042: Out of curiosity, is this some high performance task, or are you just struggling with basic performance compared to off-the-mill Java/C++?
00:34:03 <acagastya> Hi, I was trying out how to write the finobacci function in haskell, <https://0x0.st/iRe7.hs> but I am getting stack overflow for `fib 2`.  I don't understand why.
00:34:34 <merijn> acagastya: You're infinite looping
00:34:38 <dminuoso> acagastya: Spaces dont affect associativity
00:34:41 <merijn> acagastya: fib n calls "fib n"
00:34:43 <dminuoso> Use parens
00:34:58 <merijn> acagastya: You're not calling "fib (n-1)"
00:36:03 <n0042> dminuoso: It's a Data Structures and Algorithms class, and the goal for most of the assignments is to force you to use the right data structure in a really time/space-conscious way. I'm having a little trouble translating the solutions I'd have chosen in C into idiomatic and performant Haskell
00:36:16 <acagastya> All right.  So, what I wrote was actually evaluating `-3 + 2 * fib n`, right?
00:36:35 <dminuoso> n0042: I see, so that can be a bit more tricky.
00:36:38 <acagastya> (Thanks, merijn, dminuoso.)
00:37:13 <dminuoso> n0042: Algorithms are usually implemented differently in a pure functional setting, so naive approaches tend to perform poorly.
00:37:30 <dminuoso> n0042: What kind of algorithms are these?
00:37:50 <merijn> acagastya: well, no more like "how do I compute 'fib 5'? well, first I compute 'fib 5'. How do I compute 'fib 5'? repeat" :p
00:38:58 <n0042> Well an example of one I am having trouble getting under the time requirement is a network  packet simulation. All input and output has to be done during runtime (no command line arguments). It inputs the number of packets, the size of the "buffer", and the arrival time and time-to-process for each packet, and you have to calculate the time at
00:38:58 <n0042> which each packet will begin processing
00:38:58 <acagastya> I don't know why I was under the impression `fib n-1` will first compute `n-1` and then call `fib`.
00:39:24 <n0042> My solution is just a smidge too slow, even with the extra time they allot for using Haskell instead of C. It's close though. I just need to learn more about optimizing Haskell code.
00:39:34 <merijn> acagastya: Simple rule to remember is that function application *always* binds tighter than operators
00:39:52 <xerox_> acagastya: fib $ n-1 does
00:39:53 <merijn> n0042: Are you doing something naive like using a list like an array?
00:39:59 <dminuoso> n0042: Out of curiosity, can you share your code? Perhaps we could give you some rough hints and pointers.
00:40:19 <dminuoso> Want to stress that I dont intend to spoonfeed, but perhaps nudging you in the right direction is easier then
00:40:37 <merijn> dminuoso: Like seeing if there's any lists/String anywhere ;)
00:40:41 <dminuoso> ;)
00:40:58 <n0042> Actually I implemented an array inside a data structure that keeps track of the read/write head, as a Queue, but I'm sure I made the rest of the function too inefficient. I used lists for processing input/output and for some intermediate steps
00:41:15 <merijn> n0042: Ah! How di you implement you array?
00:41:21 <n0042> Using lists elsewhere probably defeated the purpose of using an array.
00:41:27 <dminuoso> When you say "array"
00:41:29 <dminuoso> what do you mean exactly?
00:41:33 <n0042> I hesitate to share the code as the class is still in progress
00:41:55 <n0042> like: `listArray (0,3) (replicate 4 0)` kind of array.
00:42:05 <n0042> which I then just treated like something I could read-write to at will
00:42:12 <merijn> ah
00:42:17 <merijn> ok, for reading that's fine
00:42:25 <merijn> for writing...it depends
00:43:19 <n0042> When you write to it with the `//` it must create a new array, right? Is that "expensive"?
00:43:44 <merijn> It has to copy the entire thing. For an array of 4 elements that's probably not so bad, but not ideal
00:43:56 <n0042> Can be up to 10^5, so that's probably my error
00:44:22 <dminuoso> n0042: Run it through the profiler
00:44:22 <n0042> It passes all the tests until the last one, which is a buffer size of 10^5 processing 10^5 "packets"
00:44:27 <merijn> n0042: oof, yes
00:44:47 <dminuoso> n0042: Because its very likely it could have told you already :)
00:45:00 <merijn> n0042: Incidentally, the vector package has proper mutable arrays inside, if you only need 1 dimensional arrays
00:45:18 <n0042> Excellent. Profiling and Vectors seem like good places to start
00:45:22 <n0042> Thank you all very much
00:46:05 <merijn> But yeah, profile :p
00:46:06 <merijn> oh
00:46:12 <merijn> dminuoso: You forgot the most important thing
00:46:38 <merijn> n0042: If you're using GHC 8.10, lemme mention out performance lord & saviour: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
00:47:17 <dminuoso> merijn: Cool, I think I saw the initial works from matthew a while ago
00:47:22 <dminuoso> was waiting for this
00:47:37 <dminuoso> Though the text based profiling is *fine*
00:47:51 <dminuoso> but an interactive flamegraph is just tons better obviously
00:48:19 <n0042> I'm using 8.8.4. Perhaps that's a good reason to upgrade soon though
00:48:26 <merijn> dminuoso: The flamegraph isn't his, that's just the speedscope.app website
00:48:38 <dminuoso> Ah
00:48:39 <merijn> dminuoso: hs-speedscope is just turning the event log into output for it
00:48:48 <merijn> Although there's still room for improvement
00:48:57 <merijn> For one it currently doesn't track foreign calls, sadly
00:49:17 <dminuoso> Ive stopped profiling our largest project because all that's left is a gazillion "improve 0.1% here" spots.
00:49:31 <dminuoso> Too much effort for too little value. At this point Im largely I/O bound. :p
00:50:08 <dminuoso> Im still amazed by how fast GHC generated code is
00:53:49 <n0042> My biggest hurdle for testing the performance for this class is actually feeding it input in a way that simulates the test conditions. They've got some automated system that inputs during runtime, like a person sitting at a keyboard. No command-line arguments.
00:54:08 <n0042> Would be easier if everything was command line arguments
00:54:32 <dminuoso> 09:27:34           merijn | n0042: Compile with -rtsopts and run with "+RTS -sstderr" to get GC diagnostics
00:54:39 <dminuoso> Oh
00:54:40 <dminuoso> Mm
00:55:37 <merijn> Well, you can use --with-rtsoprts to permanently enable those ;)
00:56:09 <dminuoso> mmm can you output the profiling data to stderr as well?
00:57:09 <acagastya> Is this called a function signature?  If not, what is it called?  `fib :: Int -> Int`
00:57:34 <n0042> Type declaration, I think
00:57:46 <n0042> But basically a function signature
00:58:24 <dminuoso> Type signature / type annotation
00:58:32 <dminuoso> Syntactically it also happens to be a declaration.
00:59:08 <dminuoso> Haskell does not have the notion of "function signatures" that have some kind of forward declaring behavior
00:59:13 <dminuoso> Like in C
00:59:54 <n0042> For the first couple weeks I was just writing everything with type inference and asking ghci for the type using `:t`
00:59:58 <dminuoso> With some considerations, you can just attach a type signature/ascription to anything. `f (x :: Int) = x * 2`
01:00:13 <dminuoso> Though that requires ScopedTypeVariables :p
01:00:18 <idnar> I never know where to put cost centres for profiling
01:00:25 <n0042> Felt real proud of myself when I didn't have to do that all the time any more.
01:01:14 <merijn> idnar: You just use -fprof-auto? :p
01:01:19 <dminuoso> n0042: For advanced users, you can just insert a typed hole, that works nicely with ghc or ghcid. 
01:01:32 <merijn> idnar: Or better yet, just use --enable-profiling with cabal :p
01:01:41 <n0042> That sounds fancy. Can you give me an example? I'm intrigued
01:01:42 <dminuoso> n0042: say you're in the middle of an expression deep down in code, and you want to know the type of some sub-expression, you can just do `.... f (x :: _) ....`
01:01:56 <dminuoso> And then GHC will generate a diagnostic, telling you the type of x 
01:02:01 <n0042> Oh that is cool
01:02:25 <dminuoso> This doesnt just work for singular things, but entire expressions too
01:02:32 <dminuoso> say `(f x) :: _`
01:03:17 <n0042> I've been really surprised at how good the interactive programming environment is since I started with Haskell. ghci is fantastic
01:03:24 <dminuoso> Though its my experience, if you have to do this its because you're not sure. Just move it to a binding and give it a permanent type singature
01:03:38 <idnar> merijn: -fprof-auto just changes the problem to "I never know where to put INLINE"
01:04:15 <n0042> dminuoso: Noted. That's a sweet trick, thank you
01:04:43 <merijn> dminuoso: That's a type hole, not a typed hole :p
01:04:58 <dminuoso> -_-
01:05:10 <dminuoso> I still need to implement -fno-typed-holes
01:05:49 <merijn> How so?
01:06:09 <dminuoso> I use optics a lot in this project, and for convenience I use the underscore based renamer
01:06:18 <dminuoso> So I have a lot of fields that start with `_foo`
01:06:23 <merijn> So?
01:06:52 <dminuoso> well, if you use these field accessors and make a typo `_fo v` then you get a very annoying diagnostic and not even a "did yu mean _foo" error
01:07:24 <dminuoso> Id rather it tells me "_fo not in scope"
01:07:36 <merijn> dminuoso: That sounds more like "I need to improve the diagnostics", not "implement a way to disable typed holes" :p
01:08:23 <idnar> dminuoso: switch to generic-optics ;)
01:09:07 <acagastya> When should I use `.` and when do I use `$`?
01:12:16 <n0042> If I understand it correctly, `.` actually combines two functions while `$` just alters precedence. I've only needed to use `.` for I/O so far. Would be interested in hearing the answer to that.
01:16:10 <guest112`> is Except a typeclass?
01:16:46 <guest112`> why Control.Monad.Error is no longer suggested?
01:20:30 <idnar> n0042: btw, if your editor has LSP support then with haskell-language-server you can get subexpression types on-hover
01:20:57 <n0042> Fancy! Good to know
01:21:08 <idnar> (among many other useful things)
01:26:23 <dminuoso> idnar: I dont think that is the real solution here
01:26:35 <dminuoso> lenses generated into OverloadedLabels seems more sane
01:27:03 <dminuoso> That's how swagger2 does it, and it's not bad
01:27:44 <idnar> dminuoso: oh hmm, generic-lens has that, I wonder why generic-optics doesn't
01:28:15 <dminuoso> idnar: Also, why would I use generics over TH here?
01:28:24 <dminuoso> The TH code is likely to be much faster
01:29:05 <dminuoso> Also, its controllable and configurable
01:29:33 <dminuoso> With Generics you're, essentially, tied to whatever the implementation has, unless you start flinging newtypes and type families at it
01:31:22 <idnar> dminuoso: there's a paper explaining how they got it to ~the performance of TH, but yes there's various up/downsides
01:32:30 <dminuoso> With TH I can just dump the splice, and splice it manually by copy and paste.
01:32:44 <dminuoso> Can you reify Generics code like that?
01:33:08 <dminuoso> But, Ill check out the paper
01:33:44 <dminuoso> Oh I think you misunderstood
01:33:52 <dminuoso> Im not talking about the *generated* lens, Im talking about the compilation time overhead
01:33:57 <dminuoso> Generics are crazy slow
01:34:46 <idnar> dminuoso: huh, TH is _much_ slower to compile IME
01:35:37 <idnar> dminuoso: I guess maybe It Depends‚Ñ¢
01:36:52 <dminuoso> Im not sure how Generics could be faster, really.
01:40:21 <idnar> oh re: labels, "I intend to add support for this for generic-optics too, but it isn‚Äôt implemented yet."
01:40:46 <idnar> guess that explains it
01:54:59 <maerwald> my experience with aeson th vs generics is that th is slower afair
01:58:04 <maerwald> but that's anecdotal evidence 
01:59:21 <tdammers> slower to compile, or slower to run?
01:59:29 <tdammers> oh wait
01:59:41 <tdammers> note to self, read scrollback before blurting out word vomit
02:08:08 <kuribas> OTOH generics is pure haskell, also TH sometimes has weird effects on declarations, TH doesn't work with cross-compiling, etc...
02:09:49 <dminuoso> maerwald: Well and it depends on the quality of TH code
02:10:26 <maerwald> dminuoso: also, you should be using openapi3, not swagger2 :)
02:10:36 <dminuoso> Generics is probably easier to get right both in compilation time as well as runtime overhead, but TH is easier to make it deterministic and *definitely* obtain a particular result
02:10:51 <dminuoso> maerwald: Yeah, there was some reasons.. dont really recall them.
02:11:04 <maerwald> it's pretty much the same api
02:11:10 <dminuoso> Oh, it wasn't released at the time
02:13:57 <dminuoso> maerwald: interesting, it looks almost identical in terms of dependencies and module structure
02:14:03 <kuribas> maerwald: question, is there an easy way to download a docker image and compile to a musl binary?
02:14:21 <maerwald> kuribas: yes
02:14:22 <dminuoso> perhaps its a drop-in replacement?
02:14:27 <dminuoso> Will try
02:14:33 <maerwald> dminuoso: yeah, upstream was unresponsive so they forked
02:14:38 <kuribas> maerwald: which can be done on differents OSes? windows, linuxes, ...
02:14:50 <dminuoso> Cool, I remember OpenAPI 3.0 has some things that 2.x failed to represent
02:15:06 <maerwald> dminuoso: yes, oneOf
02:15:14 <dminuoso> Right, that's the one
02:15:40 <dminuoso> Silly Haskellers and their sum types
02:15:48 <maerwald> kuribas: I have never used docker on windows
02:15:56 <dminuoso> Does openapi3 has allOf support?
02:15:58 <kuribas> maerwald: well, linuxes then?
02:16:25 <dminuoso>  (k ~ A_Lens, a ~ Maybe [Referenced Schema], b ~ Maybe [Referenced Schema]) => LabelOptic "oneOf" k Schema Schema a b
02:16:27 <dminuoso> Looks like, sweet
02:16:52 <maerwald> kuribas: https://gist.github.com/hasufell/f0893abfbba63ac4ea40feb0520946ee
02:17:00 <maerwald> something like that
02:17:19 <kuribas> maerwald: right, thanks!
02:28:36 <kuribas> I wonder if something exists between monad and applicative.
02:28:53 <kuribas> for example: say you have two forms, and the result of the second form depends on the first form.
02:29:09 <kuribas> however you know the second form will be always there.
02:29:45 <kuribas> it's not an applicative, because the second form depends on the first.  But not a monad either, because the existance of the second form is independent of the result of the first.
02:30:15 <merijn> kuribas: So...Selective Functors? :p
02:30:23 <merijn> kuribas: Did you live under a rock last year? ;)
02:30:44 <kuribas> seem so ;-P
02:30:54 <merijn> kuribas: https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf
02:30:57 <kuribas> thanks :)
02:31:09 <n0042> The vocabulary of learning Haskell has got to be one of the neatest things I've ever experienced. Thank you both for that
02:31:29 <merijn> kuribas: In fact, I think you are literally describing Selective with your optional 2nd form :p
02:31:36 <bulters> I come here only for the vocab ;-)
02:32:24 <kuribas> merijn: the second for is not optional
02:32:50 <merijn> kuribas: First one, whatever, reading is hard :p
02:33:04 <kuribas> any, sounds interesting, I'll have a look
02:33:16 <bulters> @merijn: wouldn't it be an Invariant Functor?
02:33:16 <lambdabot> Unknown command, try @list
02:33:18 <kuribas> *anyway*... writing is hard :)
02:33:34 <bulters> since it's always there, disregarding the first form?
02:34:16 <bulters> (disclaimer: I understand sh*t about formal type theory....)
02:35:07 <[exa]> invariant functor sounds a bit more like Const
02:35:07 <merijn> various functor types don't really have much to do with type theory, though :p
02:35:26 <bulters> merijn: hence, my disclaimer
02:35:33 <bulters> I don't even know where it starts and ends!
02:35:44 <n0042> haha
02:35:52 <kuribas> merijn: now that I think about it, what I describe is just an applicative, but where the second form returns a function that takes the result of the first form.
02:36:23 <n0042> You and me both bulters. I'm looking around for some good introductory resources at the moment
02:36:41 <bulters> n0042: at what "level are you reading" right now?
02:36:47 <merijn> For type theory? Benjamin Pierce's Types and Programming Languages
02:37:30 <n0042> thanks merijn, that sounds appropriate
02:37:53 <bulters> Thanks merijn, that sounds really appropriate
02:38:33 <__monty__> bulters: It's not just a type theory introduction, it's *the* type theory introduction : )
02:38:54 <bulters> ok... thanks you all... you just REALLY destroyed december for my wife...
02:39:13 <__monty__> bulters: Oh, you hadn't heard about Advent of Code yet?
02:39:25 <n0042> bulters: I'm not sure how to answer that question. At a lower level than many of the people in here, I'm sure. 
02:39:25 <merijn> __monty__: hah
02:39:28 <bulters> __monty__: sure did! That's what she gave me the approval for :P
02:39:31 <kuribas> merijn: for example: liftA2 (,) form1 (form2 $ \form1Value -> form2Value)
02:39:37 <merijn> __monty__: Life hack, my SO is doing Advent of Code :p
02:40:15 <bulters> merijn: smart... now I just have to find a way to get a tax lawyer interested in AoC :')
02:40:34 <__monty__> I'm expecting a lot more participation due to lockdowns and such.
02:41:07 <bulters> __monty__: absolutely... last year we had 21 participants in our office, right now the internal slack channel is at 40.
02:41:49 <kuribas> merijn: so form2Value depends on what form1 returns
02:42:10 <bulters> n0042: wouldn't be too surprised... I think I managed to forget everything about type theory I learned in uni (some 15 years ago)... that's what industry does to you ;-)
02:42:42 <__monty__> kuribas: That sounds a lot like a monad though.
02:43:07 <kuribas> __monty__: no, because the monad doesn't know that form2 will exist
02:44:12 <__monty__> I'm not sure what you mean. They always occur in pairs? Why does it need to know, optimization?
02:45:28 <kuribas> __monty__: form2 is always there, it's just that it's contents changes based on form1.
02:45:49 <n0042> bulters: Still looking to get my first job in the "industry"! Lots to learn.
02:45:59 <kuribas> __monty__: no, if you have a UI, you want the second form to be already there.
02:46:17 <bulters> n0042: That's really exciting... You're up for a real rollercoaster ride I'd reckon...
02:46:34 <bulters> especially starting in a time where remote work is "the norm"
02:47:08 <n0042> The world does seem to have gone mad
02:47:23 <n0042> But I'm not going to complain about remote work. My room is a nice office
02:47:37 <bulters> I hired an office, just for me...
02:47:53 <n0042> Like, you rented a place?
02:48:00 <bulters> yeah, an empty office...
02:48:05 <bulters> friend of mine had one "left"...
02:48:25 <bulters> 5 minute bike ride away, pay like 250 euros per month, including internet, heating, cleaning, etc
02:48:32 <n0042> Is your whole organization gone remote?
02:48:36 <bulters> yep..
02:48:42 <n0042> wow
02:49:12 <bulters> We allow 10% of the staff to be in the office per day
02:49:22 <bulters> to allow for proper distancing
02:49:36 <n0042> I wonder what the total cost of the whole Covid thing is when you calculate business disruptions like that, world-wide.
02:49:44 <merijn> We have...1 or 2 people in the office?
02:49:54 <merijn> n0042: Uncountable, most likely
02:50:07 <dminuoso> Dunno, Im fairly sure it will be measurable
02:50:14 <dminuoso> But it depends on the exact metric
02:50:39 <merijn> dminuoso: I think there's so many indirect effects it's probably not actually measurable in any accurate way
02:51:28 <bulters> We expect to lose 1.5mio (eur) on the fact that we have to work remotely only.
02:52:15 <bulters> So that doesn't factor in added productivity (by some), lost productivity (in others), added supportive costs (extra monitors, physical therapy, new desks for some, etc)
02:52:42 <nr3rsl> Hi guys, i'm looking for haskell programmers to work in portugal any one?
02:53:58 <bulters> ok, so alter from Data.Map.Strict requires (Maybe a -> Maybe a) as first arg, but I just want to update 1 element to a fixed value. Any pointers?
02:54:45 <merijn> bulters: What's wrong with alter?
02:55:03 <bulters> there's nothing wrong with alter... I think... just me using it wrong
02:55:32 <n0042> I am almost certainly not qualified to be taking Haskell jobs nr3rsl but out of curiosity what kinds of things are you hiring people to work on?
02:56:26 <bulters> maralorn: M.alter (Just (left + right)) result m <-- I'd have to wrap the (Just (left + right)) into something that makes it a Maybe a -> Maybe a right?
02:56:33 <bulters> erm... merijn ... mea culpa
02:57:14 <merijn> "Just (left + right)" is a value, not a function. Where are left/right coming from?
02:58:47 <maralorn> You know ‚Ä¶ My first name is "Malte". For a second there I was so confused by this message that I considered it was an accidental highlight because of "M.alter" ‚Ä¶
02:59:28 <bulters> merijn: https://gist.github.com/bulters/661a7389d3684826e20791c7019d3bf8
03:00:05 <bulters> (AoC 19, day 2, did stupid implementation earlier, now following random redditor suggesting of optimizing by using Data.IntMap.Strict)
03:00:15 <merijn> bulters: eh, I think you just want M.insert?
03:00:37 <merijn> alter is for updating a value you haven't looked up yet
03:00:55 <bulters> makes perfect sense...
03:01:04 <merijn> "alter f k" says "replace the value for key 'k' by using the function 'f' to generate the new value"
03:01:26 <merijn> Where 'f' gets Nothing (if no value) or Just (if there's one there) and returns Just (new value) or Nothing (deleted)
03:02:18 <bulters> \o/ Thanks!
03:21:33 <maerwald> is there a structure such as a Map that can be GCed as you go instead of after traversal?
03:23:20 <kuribas> merijn: I guess what I want is flipped (<*>) with the effects reversed.
03:23:44 <kuribas> merijn: so >*< :: f a -> f (a -> b) -> f b
03:26:31 <ski> > [(^ 2),(^ 3)] <*> [4,5]
03:26:32 <lambdabot>  [16,25,64,125]
03:26:33 <ski> > [4,5] <**> [(^ 2),(^ 3)]
03:26:35 <lambdabot>  [16,64,25,125]
03:29:14 <bulters> merijn: did the trick, thanks. For 'closure' (the mental variant): would using alter entail using something like \x -> Just (left + right)?
03:33:14 <kuribas> :t <**>
03:33:15 <lambdabot> error: parse error on input ‚Äò<**>‚Äô
03:33:22 <kuribas> :t (<**>)
03:33:23 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
03:34:37 <kuribas> nice
03:38:13 <ski> bulters : yes. `adjust' would also have worked (but is also slightly overkill, since you don't depend on the old value, just overwrite)
03:40:49 <bulters> ski: thanks! 
03:41:51 <dminuoso> 12:21:11         maerwald | is there a structure such as a Map that can be GCed as you go instead of after traversal?
03:42:05 <dminuoso> Mmm, I wonder whether that's even possible without a substructural type system
03:42:15 <dminuoso> (Unless the map does manual memory management)
03:42:51 <dminuoso> From GC roots perspective, as long as there's something pointing to the original map, you cant GC the nodes that have gone from your perspective
03:43:28 <maerwald> yeah, it's a similar problem with copying bytestrings
03:44:19 <dminuoso> maerwald: The closest thing you're asking for exists in Clean, where operations can be turned into mutation
03:44:29 <dminuoso> (Which would be better than just "garbage collecting what you just freed"
03:45:13 <dminuoso> Because with a linear (or affine) type system you could reason, that after the traversal nothing else can see the value you just touched
03:45:29 <ski> i guess if you have the only reference to the root, then after you've traversed all but one direct subtree, you'll discard the root, so that GC could possibly pick it up, as you descent further ?
03:46:19 <ski> (hm, or possibly you'll directly pick apart the root node, into constituents, before traversing further, so that GC could pick it up anytime after that)
03:46:56 <ski> s/linear (or affine)/uniqueness/
03:49:32 <ski> Mercury does implement CTGC (compile-time GC), which first tries to reuse discarded (unique) nodes for creation of new nodes (preferably sharing some slots, so they don't all need to be updated), and otherwise statically insert a deallocation call of the node
03:50:32 <ski> (haven't looked in that detail at what the Clean implementation does, but wouldn't surprise me if it does that, as well)
03:51:45 <ski> e.g. if you append two lists in Clean, the first of which is unique, it'll just update-in-place the final tail of the first to point to the second, rather than allocating new nodes for the first list, copying it
03:52:32 <dminuoso> From what I hear, that alone gives Clean the advantage over GHC with all its fancy simplifier psases
03:52:41 <dminuoso> In terms of performance, given some benchmarks.
03:56:38 <ski> it has a fancy bounded uniqueness polymorphic system, so that the same (source) append can be used in the different modes (i think some of them will use the same generated code, while others will use separate code (e.g. not allocating, but updating))
03:57:22 * hackage deferred-folds 0.9.12 - Abstractions over deferred folds  https://hackage.haskell.org/package/deferred-folds-0.9.12 (NikitaVolkov)
03:57:30 <ski> in Mercury, it's just ad hoc overloading of the modes, no uniqueness variables with bounds
03:57:50 <nr3rsl> Hi guys, i'm looking for haskell programmers to work in portugal any one?
04:00:46 <bulters> Can vouch for PT as a country... Brilliant place to live...
04:01:02 <nr3rsl> yes it is :)
04:01:13 <nr3rsl> but no haskell guys :(
04:01:50 <drdo> nr3rsl: What kind of work?
04:05:19 <nr3rsl> its related to trains
04:06:13 <nr3rsl> join a big team 20+
04:24:53 <maerwald> functional safety?
04:26:19 <Uniaika> < nr3rsl> but no haskell guys :( // hahaha we have one of yours in my company! 
04:26:32 <Uniaika> he went back to Portugal when France went into quarantine
04:27:31 <Uniaika> nr3rsl: long story short, if you want to hire people for a team, hire a couple of experts and then people who are willing to learn
04:27:47 <Uniaika> you don't need to hire a team full of experts
04:28:52 <maerwald> Uniaika: yeah, for knowledge, only the team maximum is relevant, for motivation the sum :)
04:29:53 <Uniaika> :)
04:30:27 <maerwald> (also, the most knowledgable guys are usually harder to motivate)
04:32:43 <dminuoso> Say Im folding/traversing a Data.Graph.tree, I want to keep track of the current path, as a sort of `traverse :: (NonEmpty a -> f b) -> Tree a -> f (Tree b)`, can I create this out of combinators trivially?
04:32:57 <dminuoso> Or should I build this by hand?
04:36:38 <nr3rsl> i'm looking for people that is independent we are hiring juniors also but we need experienced people in the beggining 
04:37:29 <dminuoso> nr3rsl: Try also haskell-cafe
04:38:52 <Rembane> nr3rsl: On premise or remote? 
04:39:16 <nr3rsl> right now its ok to be remote due this covid situation
04:39:41 <nr3rsl> but in the future we would like to have a team in the office
04:39:56 <nr3rsl> but its important to have the same timezone
04:40:04 <nr3rsl> ie pt uk
04:40:58 <sshine> do you mean it important to have a mostly overlapping working day? or is it important to live in UTC+0 regardless of global latitude? :)
04:41:22 * hackage massiv 0.5.7.0 - Massiv (–ú–∞—Å—Å–∏–≤) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.7.0 (lehins)
04:43:07 <Digit> hi.  is yi the only haskell extensible text editor written in haskell?   is yi /it/?  :)
04:43:33 <sshine> Digit, I haven't seen another one.
04:43:42 <merijn> There was another one, but I don't think either really gets used
04:43:43 <dminuoso> There was also rasa
04:43:49 <merijn> leksah?
04:43:52 <sshine> Leksah!
04:44:01 <maerwald> leksah was using y
04:44:03 <maerwald> yi
04:44:16 <maerwald> or some gtk thing
04:44:28 <sshine> yi means 1 in Chinese.
04:44:29 <maerwald> I don't think it had its own editor implementation
04:45:13 <sshine> if someone makes a sequel, it should be called "er" (‰∫å).
04:45:46 <maerwald> I'd call it baozi =)
04:46:36 <sshine> or taozi üçë :P
04:48:30 <maerwald> shen jian bao
04:48:44 <maerwald> (there must be a monad metaphor here)
04:49:20 <maerwald> but tbf, they look like functors to me, with this little opening at the top
05:11:36 <sshine> @pl \x y -> [x,y]
05:11:36 <lambdabot> (. return) . (:)
05:11:39 <sshine> definitely fancier.
05:13:40 <sshine> > ((. (:[])) . (:)) 1 2
05:13:42 <lambdabot>  [1,2]
05:14:17 <sshine> that's the "big robot monkey on top of small monkey" operator
05:14:42 <maerwald> PR rejected.
05:15:09 <sshine> √≥_√í
05:15:11 <merijn> :p
05:17:15 <acagastya> Hi, the first line of my file is `import Data.List.group` -- but I am getting `error: parse error on input ‚ÄòData.List.group‚Äô`.
05:17:47 <geekosaur> the correct syntax would be: import Data.List (group)
05:18:31 <geekosaur> and "Data.List.group" is not a legal module name
05:19:42 <acagastya> All right, it looks like it worked.  Thanks, geekosaur!
05:21:11 <yushyin> not the most helpful error message
05:21:52 <geekosaur> everything around qualified names is not the most helpful in ghc
05:22:09 <acagastya> In my defence, that is what <https://wiki.haskell.org/99_questions/Solutions/8> said.
05:22:53 <hpc> if you did import qualified Data.List, in the body of your code you would write "Data.List.group" to refer to that function
05:24:03 <hpc> you can refer to identifiers by the module they come from, but imports always have to be modules, not identifiers
05:26:59 <geekosaur> kinda sounds like someone did a quick and very dirty "fix" of the wiki for FTP
05:28:52 <hpc> probably
05:31:58 <ski> seems that page doesn't mention `import'
05:32:49 * ski sighs
05:33:02 <hekkaidekapus> @index group
05:33:03 <lambdabot> GHC.OldList, Data.List, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString, Data.ByteString.Char8
05:33:10 <ski> i can't rightly comprehend how people can think
05:33:13 <ski>   compress (x:xs) = x : (compress $ dropWhile (== x) xs)
05:33:18 <ski> is more reasonable than
05:33:23 <ski>   compress (x:xs) = x : compress (dropWhile (== x) xs)
05:34:23 * hekkaidekapus wonders whether lambdabot is using the GHC 8.10 series.
05:34:33 <geekosaur> @version
05:34:33 <lambdabot> lambdabot 5.3.0.1
05:34:33 <lambdabot> git clone https://github.com/lambdabot/lambdabot
05:34:41 <geekosaur> hm
05:34:52 <geekosaur> thought that also output ghc version
05:35:01 <merijn> > System.Info.compilerVersion
05:35:03 <lambdabot>  error:
05:35:03 <lambdabot>      Not in scope: ‚ÄòSystem.Info.compilerVersion‚Äô
05:35:03 <lambdabot>      No module named ‚ÄòSystem.Info‚Äô is imported.
05:35:06 <merijn> aww
05:35:23 <hekkaidekapus> Because Data.List, when unqualified, spews warning under 8.10.x.
05:35:25 <merijn> @import System.Info
05:35:25 <lambdabot> Unknown command, try @list
05:35:35 <merijn> I forget how to add imports >.>
05:35:40 <geekosaur> yahb has 8.10 iirc
05:35:50 <merijn> % System.Info.compilerVersion
05:35:50 <yahb> merijn: Version {versionBranch = [8,10], versionTags = []}
05:35:51 <geekosaur> @let import System.Info
05:35:53 <lambdabot>  Defined.
05:35:58 <merijn> > System.Info.compilerVersion
05:36:01 <lambdabot>  Version {versionBranch = [8,10], versionTags = []}
05:36:04 <merijn> There you go
05:36:15 <hekkaidekapus> % head [1]
05:36:16 <yahb> hekkaidekapus: 1
05:36:58 <hekkaidekapus> % -set -Wall
05:36:58 <yahb> hekkaidekapus: ; <interactive>:60:7: error:; * Data constructor not in scope: Wall :: ASetter s t a b -> b -> s -> t; * Perhaps you meant one of these: variable `all' (imported from Prelude), variable `BSL.all' (imported from Data.ByteString.Lazy), variable `BS.all' (imported from Data.ByteString)
05:37:05 <hekkaidekapus> % :set -Wall
05:37:06 <yahb> hekkaidekapus: 
05:37:10 <hekkaidekapus> % head [1]
05:37:10 <yahb> hekkaidekapus: ; <interactive>:62:1: warning: [-Wtype-defaults]; * Defaulting the following constraints to type `Integer'; (Show a0) arising from a use of `print' at <interactive>:62:1-8; (Num a0) arising from a use of `it' at <interactive>:62:1-8; * In a stmt of an interactive GHCi command: print it; 1
05:37:42 <hekkaidekapus> % :q
05:37:43 <yahb> hekkaidekapus: 
06:03:22 * hackage prolude 0.0.0.11 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.11 (saramuse)
06:16:26 <dminuoso> Im converting a file into a tree by parsing line-by-line. The knowledge where the next node goes comes from ambient state, is there a general trick for building a tree like that? Just have some `data Tree = Tree (IORef [Tree])` that I walk around and attach nodes at the right spots?
06:19:28 <merijn> dminuoso: ooh...lemme know when you figure it out, I have a similar-ish problem :p
06:21:23 * hackage quickcheck-arbitrary-template 0.2.1.1 - Generate QuickCheck Gen for Sum Types  https://hackage.haskell.org/package/quickcheck-arbitrary-template-0.2.1.1 (mchaver)
06:24:59 <dminuoso> https://hackage.haskell.org/package/uniplate-1.6.13/docs/Data-Generics-Uniplate-Zipper.html
06:25:07 <ski> what's the traversal order for serializing the tree ?
06:25:44 <dminuoso> ski: Mmm good question. I think it doesn't matter.
06:26:06 <dminuoso> Ah no, it will be depth first
06:26:13 <nr3rsl> i'm looking for people that is independent we are hiring juniors also but we need experienced people in the beggining (if you are intrested private msg pls)
06:26:22 <ski> are you trying to avoid a (multiply) recursive parsing ?
06:27:29 <ezzieyguywuf> is this standard syntax or a language extension? `inp,outp :: Maybe String -> Flag`
06:28:04 <dminuoso> ezzieyguywuf: standard haskell
06:28:05 <geekosaur> standard syntax
06:28:29 <ezzieyguywuf> oh wow! does it have a fancy name? I've never seen it before.
06:28:35 <geekosaur> you can declare multiple names that way, it's just not considered the best of style except in some cases
06:28:46 <ezzieyguywuf> ah, ok
06:28:53 <geekosaur> better is considered to keep name declarations and definitions together
06:29:49 <merijn> If you wanna define a type, for a tuple it can work well
06:30:22 <merijn> "a, b :: Int; (a, b) = (1, 2)" that's a dumb example, of course, but you get the idea
06:30:29 <merijn> ezzieyguywuf: Lemme blow your mind further :p
06:30:47 <merijn> ezzieyguywuf: You can define module variables using pattern matching just fine
06:31:04 <geekosaur> you did there
06:31:08 <merijn> "[x,y,z] = [1,2,3]" at the module top level is perfectly legal
06:39:56 <dminuoso> ski: Mmm. That question made me think.
06:48:07 <hekkaidekapus> dminuoso: You could also give tries a try.
06:48:23 <dminuoso> Not sure whether you just wanted to make that pun..
06:48:31 <hekkaidekapus> heh
06:48:54 <hekkaidekapus> Ok, seriously, why not a trie?
06:49:31 <merijn> So, I basically have this tree encoded as a Vector. I was hoping I could somehow (abuse) pattern synonyms to represent it as an ADT style true, but I can't quite make that work, it seems?
06:49:55 <dminuoso> hekkaidekapus: Generating a tree from a recursive algorithm is easy, but the data I have make a recursive parser tough to write.
06:51:08 <dminuoso> But.. perhaps Zipper from uniplate is the real solution here
06:51:23 <dminuoso> So my parser essentially drives a Zipper around, and constantly runs `replaceHole`
06:51:48 <dminuoso> The alternate option is I try and transform the data and implement a recursive parser.
06:53:10 <hekkaidekapus> Which bring you back to deciding how you want to traverse.
06:54:22 <dminuoso> Maybe I misunderstood, what is the purpose of that question, hekkaidekapus?
06:56:15 <hekkaidekapus> It was just an idea: if you represent the data as a multi-keyed map, each step forming a key, you could later merge it into a trie.
06:56:30 <hekkaidekapus> But maybe that‚Äôs not how your data is organised.
06:57:02 <acagastya> What is this line supposed to mean?  `quicksort :: Ord a => [a] -> [a]`.  Specifically, `Ord a =>`
06:57:19 <xerox_> acagastya: means whatever type 'a' ends up being, it has to have an Ord instance, it's a constraint
06:59:43 <acagastya> Okay.  When I just type `quicksort :: [a] -> [a]` and have the implementation -- it does not work -- it gives an error.  Why?
06:59:50 <solonarv> the fact that 'a' is a type variable means "the caller of this function can choose to replace   a   with any type"; the   Ord a =>   bit means "... as long as there exists an   Ord a   instance"
07:00:04 <merijn> acagastya: Presumably because you're using < :p
07:00:07 <merijn> :t (<)
07:00:09 <lambdabot> Ord a => a -> a -> Bool
07:00:10 <merijn> :t (<=)
07:00:11 <solonarv> this is needed because the implementation of quicksort uses functions like   <=   or   <   and so on
07:00:11 <lambdabot> Ord a => a -> a -> Bool
07:00:13 <xerox_> acagastya: because the implementation uses some methods from the ord class on the elements of the list, in this case to compare them
07:00:43 <xerox_> hence its argument can't be a list of things that are not comparable
07:00:45 <acagastya> `<=` and `<` are functions?
07:00:54 <xerox_> they are!
07:01:31 <acagastya> Wow -- I have so much to unlearn to learn Haskell.
07:01:32 <xerox_> if you type :info Ord on ghci you'll see all the functions in the Ord class at the top of the output
07:01:45 <xerox_> followed by a decently long list of the instances already in scope
07:02:27 <dminuoso> hekkaidekapus: Roughly the data is organized like this: https://gist.github.com/dminuoso/e05c57c211a4b544052dc26f99e9266f
07:02:42 <dminuoso> (I've cleaned it from a lot of the other baggage)
07:03:09 <dminuoso> So each line containing a number is a node in that tree
07:03:14 <acagastya> I have been thinking how would the minds of the beginners to programming evolve, if they were taught Haskell as their first PL.  The way to think abstractly is so different from what I am used to!
07:03:17 <xerox_> they might seem special because they are operators and hence use infix syntax, i.e. you put them between tha arguments instead of before the argument with standard functions, but that's just syntax
07:03:42 <merijn> acagastya: Operators are just "functions that you write infix"
07:03:51 <xerox_> you *can* use them with the standard function application too tho, with parens:
07:03:55 <xerox_> > (<=) 2 5
07:03:57 <lambdabot>  True
07:03:58 <acagastya> Like a `mod` b, merijn?
07:04:04 <merijn> Can even define your own
07:04:12 <dminuoso> hekkaidekapus: oh and these numbers could be even more nested, so you could have .11.2, and so forth
07:04:18 <dminuoso> these would represent further nested nodes
07:04:20 <merijn> > let x ‚òÉ y = (x-y) * (y-x) in 3 ‚òÉ 5
07:04:22 <lambdabot>  -4
07:04:29 <xerox_> what a cutie of an operator
07:04:33 <dminuoso> if a number starts with `.` its a child of the previos absolute number
07:04:53 <dminuoso> I mean yeah, with a recursive parser I'd have to do a lot of lookahead
07:04:59 <merijn> xerox_: Everyone loves unicode snowman :p
07:05:18 <xerox_> it's basically seasonal too
07:05:42 <hekkaidekapus> dminuoso: I see. So, it‚Äôs not only about data representation, it‚Äôs also about parsing strategy.
07:06:10 <dminuoso> hekkaidekapus: Maybe, I dont know. Until now I parsed it into a sort intermediate language with a sketchy interpreter
07:06:50 <hekkaidekapus> Maybe write down a grammar and be done with parsing.
07:07:24 <dminuoso> well the raw parsing is done, I was just really lazy since ParsecT is a monad transformer..
07:07:30 <dminuoso> so I tohught "why not do more work while Im parsing"
07:07:52 * hackage req 3.8.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.8.0 (mrkkrp)
07:08:51 <dminuoso> For some bizarre reason, in this week I've this type of "how do I generate a tree properly from a flat file" in three completely unrelated projects
07:08:54 <hekkaidekapus> I would go with the Happy route to record steps taken wwhile parsing and use those to represent the final tidy data.
07:09:09 <dminuoso> "steps taken"?
07:09:21 <hekkaidekapus> Production rules.
07:12:15 <dminuoso> I see, so concretely that could mean annotating the data with fully resolved paths, where I might have a list of nodes each with a sort of path `data Node a = Node { nodeLabel a, nodePath :: NonEmpty Int }`
07:12:22 <dminuoso> as the result of the parser
07:12:38 <dminuoso> And then it's just a matter of folding [Node] into a free
07:12:41 <dminuoso> *tree
07:12:56 <hekkaidekapus> Yep.
07:13:17 <hekkaidekapus> The bulk of the work is in writing the grammar.
07:18:20 <dminuoso> Mmm, oh. I dont even have to do the folding myself
07:18:25 <dminuoso> https://hackage.haskell.org/package/tries-0.0.6.1/docs/Data-Trie-Class.html#v:fromFoldable
07:18:28 <dminuoso> Cute
07:19:02 <hekkaidekapus> \o/
07:19:53 <hekkaidekapus> There is also generic-trie (hey glguy) and multi-trie.
07:19:57 <dminuoso> hekkaidekapus: Guess you didn't just want to make a pun after all. Thanks for trieing.
07:20:07 <hekkaidekapus> hahaha‚Ä¶
07:20:20 <n0042> XD 
07:20:51 <arianvp> I have a question about overlapping instances
07:21:00 <arianvp> https://github.com/haskell-servant/servant/issues/1367
07:21:23 <arianvp> why would these two instances overlap?    There is no `ToJSON` instance for `WithStatus n a`
07:22:13 <dminuoso> arianvp: instance context is not considered for selection
07:22:25 <arianvp> aaaah
07:22:36 <arianvp> so I need to add an explicit `overlaps` here?
07:22:53 <dminuoso> Well
07:22:55 <dminuoso>     instance MimeRender ctype a => MimeRender ctype (WithStatus _status a)
07:22:58 <dminuoso>     instance [overlappable] ToJSON a => MimeRender JSON a
07:23:07 <dminuoso> Imagine you're tryng to match `MimeRender JSON (WithStatus 201 ())`
07:23:10 <dminuoso> This matches *both*
07:23:30 <dminuoso> Compare the instance heads
07:23:32 <dminuoso> MimeRender ctype (WithStatus _status a
07:23:37 <dminuoso> MimeRender JSON a
07:23:54 <dminuoso> Both match, and none is more specific.
07:25:12 <arianvp> hmm
07:25:34 <arianvp> so I should make a   instance MimeRender JSON a => MimeRender JSON (WithStatus _s a) instead ?
07:25:42 <arianvp> (for each content type)
07:25:56 <arianvp> and mark that as overlapping?
07:26:27 <dminuoso> Well you wouldnt have to mark it as overlapping, as the other instance is already overlappable
07:26:46 <dminuoso> (for overlap to work, either overlapping or overlappable is enough)
07:26:51 <arianvp> ah
07:26:57 <arianvp> thanks!
07:29:26 <arianvp> *sends a fix*
07:29:31 <dminuoso> arianvp: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/instances.html?highlight=overlapping
07:29:46 <dminuoso> Also https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/instances.html?highlight=overlapping#instance-overlap
07:32:22 * hackage unbounded-delays 0.1.1.1 - Unbounded thread delays and timeouts  https://hackage.haskell.org/package/unbounded-delays-0.1.1.1 (RoelVanDijk)
07:33:53 <arianvp> I must say the GHC error message is horrible for this
07:34:13 <arianvp> well in hindsight I understand it now
07:34:37 <arianvp> it would be nice if it hid the context and highlight the parts that are in conflict
07:34:45 <dminuoso> Is it horrible?
07:34:56 <dminuoso> Well, it'd be misleading to hide the context
07:36:09 <dminuoso> GHC *does* tell you that there's two matching instances for the constraint `MimeRender JSON (WithStatus 201 ())`
07:37:16 <arianvp> I got sidetracked into wondering "But WIthStatus" doesnt _have_ a ToJSON why would it overlap? but now that I know the contexts aren't considered it makes sense
07:37:27 <arianvp> perhaps a note in the error message explaining that would be a nice nudge =)
07:39:01 <dminuoso> Do you have a suggestion?
07:40:42 <dminuoso> The crux is, GHC cant really know why it has the problem that it is.
07:40:56 <dminuoso> If you look at the full algorithm described in https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/instances.html?highlight=overlapping#overlapping-instances
07:41:18 <dminuoso> (Which by the way is still incomplete, but that's another story)
07:41:22 * hackage cli-extras 0.1.0.1 - Miscellaneous utilities for building and working with command line interfaces  https://hackage.haskell.org/package/cli-extras-0.1.0.1 (abrar)
07:42:09 <dminuoso> Then the algorithm is far more involved than than just "ignore context and find the best intsance"
07:44:47 <dminuoso> But admittedly, we see people stumbling over this nearly every day.
07:45:02 <dminuoso> (And interestingly this behavior is not specified in the Haskell report either)
07:45:12 <Uniaika> hi Iceland_jack :)
07:45:16 <Uniaika> how are you?
07:45:19 <arianvp> I dont think the error message needs to explain exactly what's happening with 100% accuracy
07:45:30 <arianvp> but it's nice (rust does this as well) when an error lists a "Common cause"
07:45:51 <arianvp> "Hey; you might not realise it but the context is not considered when deciding if something overlaps"
07:45:52 <Uniaika> it's very useful
07:45:55 <dminuoso> I recall an issue on ghc gitlab about this
07:46:27 <arianvp> It's up to the user to decide if that hint applies to their situation; but at least it gives them food for thought
07:47:16 <dminuoso> Feel free to open an issue on ghc gitlab about this
07:48:05 <dminuoso> The idea is certainly not unreasonable, especially given how frequently we get people thinking that instance context is taken into consideration for instance selection, just to trip into GHC diagnostics or surprising bugs.
07:48:37 <arianvp> :+1:
07:48:43 <arianvp> i'll try to not forget to open a ticket :)
07:50:33 <Uniaika> lambdabot needs a !remindme
08:02:22 * hackage cli-git 0.1.0.1 - Bindings to the git command-line interface  https://hackage.haskell.org/package/cli-git-0.1.0.1 (abrar)
08:06:53 * hackage cli-nix 0.1.0.1 - Bindings to the nix command-line interface  https://hackage.haskell.org/package/cli-nix-0.1.0.1 (abrar)
08:07:53 <Taneb> Is there a way to make GHC start profiling a program at a certain point? I've got a program with an expensive one-time setup followed by a loop that I want to opimize the hell out of
08:08:03 <merijn> Taneb: Yes!
08:08:33 <merijn> Taneb: https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Profiling.html#v:startProfTimer
08:08:53 <Taneb> Oooh, nice
08:09:17 <merijn> Taneb: Consider also: https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Exts.html#v:traceMarker-35-
08:09:54 <merijn> If you hack up mpickering's hs-speedscope to be trace marker aware (if it isn't yet?) then you can use that with speedscope
08:12:29 <mpickering> merijn: You can isolate a profile between two markers with the 0.2 release
08:16:51 <merijn> Taneb: Well, there you go ;)
08:23:35 <Raman> question from a haskell newbee --- how do experienced haskell programmers pronounce the "=>" as it appears in type declarations?
08:26:54 <monochrom> I don't pronounce it at all.
08:27:26 <Raman> :-) asking because I would like to teach Emacs to speak haskell to me (https://github.com/tvraman/emacspeak)
08:27:41 <xerox_> an extra long pause before reading the rest of the type
08:28:18 <Raman> a long line like => (a->b->c) ->...can sound pretty mysterious when spoken by TTS;-) haskell mode helps some with emacspeak given font-lock which I map to voice changes.
08:29:04 <Raman> pause sounds interesting, for now I have it saying "is type of" which likely is good for a beginner but will get long soon enough 
08:29:49 <monochrom> => is ASCII art for ‚áí, do you have a favourite name for that?
08:29:55 <Raman> if I get far enough along with Haskell, I'm hoping to write a simple audio-formatter in haskell fo rhaskell, will come asking for pointers if I make it that far
08:30:22 <Raman> I could say double-arrow I suppose -- already saying "arrow" for ->
08:30:46 <monochrom> That's a good solution.
08:31:10 <merijn> Raman: constraint or implication wouldn't be quite accurate, could be reasonable
08:31:19 <[exa]> Raman: I'd read that as 'implies' but it's more like a reverse prolog :- which I have no idea how to read 
08:31:36 <Raman> will try various of these out over the next few weeks as I continue to learn. I assume that when the time comes there are haskell lib that can parse haskell code to give me back some type of AST?
08:31:47 <merijn> I mean, in terms of speaking "constrains" might be useful
08:32:14 <merijn> Like "Ord a constrains a -> a -> Bool" for "Ord a => a -> a -> Bool" seems decent
08:32:26 <[exa]> yeah 'implies' sounds curry-howardish in this context
08:32:28 <Raman> :-) gets spoken as smiley by emacspeak -- I remember finding some page on the web 15 years ago approx that listed ascii combinations for popular emoji 
08:32:49 <merijn> Raman: I mean, technically GHC itself is a library that can give you an AST :p
08:34:18 <Raman> that's good to know -- asume for now that I know nothing (which is pretty much true re haskell) working through the realworld haskell book,  have it open in emacs, along with a bunch of haskell-mode buffers and  an inferior-haskell buffer. Also have lambdabot running in a separate emacs buffer after I embarrassed myself here yesterday and had it say rude things in response:-)
08:34:46 <Raman> AFK, back in a few. I'll see responses when I come back 
08:35:53 <[exa]> woah, lambdabot action I missed? /me opens logs
08:38:01 <woodpecker-with-> How's the performance of the AD library?
08:38:16 <woodpecker-with-> Any benchmarks?
08:46:59 <Iceland_jack> hi Uniaika
08:47:00 <davean> woodpecker-with-: its good.
08:47:08 <Iceland_jack> making soup
08:47:47 <davean> woodpecker-with-: if its optimized for what you want or not is another question.
08:48:23 * hackage reflex-external-ref 1.0.3.0 - External reference with reactivity support  https://hackage.haskell.org/package/reflex-external-ref-1.0.3.0 (NCrashed)
08:58:46 <Raman> so Like "Ord a constrains a -> a -> Bool" for "Ord a => a -> a -> Bool" sounds nice when spoken with some additional intonation. Depending on the context, implies might sound good too -- thanks all! I'll go back to reading, or I will just end up hanging out here chatting. When the time comes, I'll ask how I hand ghci a line of code and get an AST back
09:04:23 * hackage reflex-external-ref 1.0.3.1 - External reference with reactivity support  https://hackage.haskell.org/package/reflex-external-ref-1.0.3.1 (NCrashed)
09:08:01 <dminuoso> % runQ [| \x -> x ^ 2 |] 
09:08:01 <yahb> dminuoso: LamE [VarP x_3] (InfixE (Just (VarE x_3)) (VarE GHC.Real.^) (Just (LitE (IntegerL 2))))
09:22:28 <xerox_> LamE
09:23:13 <APic> EsounD
09:31:32 <texasmynsted> one thing I do not recall seeing in the Haskell survey was detail about why kinds of applications people build with Haskell. I think there was something like "command line apps", but that is more of an interface than mission. 
09:37:53 * hackage monad-logger 0.3.36 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.36 (MichaelSnoyman)
09:48:43 <dsal> texasmynsted: I write almost everything I need in Haskell.
09:48:45 <gehmehgeh> hm, I'm looking for a package that contains a datatype that allows an opperation such as "[1,2,3] ++ [4,5,6]" in O(1) time. Is that sort of thing already built into Haskell? Is there some sort of default package for that? We'd obviously need a reference to the last element of the left list
09:49:13 <gehmehgeh> Basically a doubly linked list
09:49:24 <kuribas> gehmehgeh: DList?
09:49:31 <texasmynsted> nice
09:49:47 <kuribas> gehmehgeh: https://hackage.haskell.org/package/dlist
09:50:02 <kuribas> gehmehgeh: btw, DList stands for difference list.  It's not a doubly linked list.
09:50:19 <kuribas> gehmehgeh: it's more like a tree constructor, where you flatten the tree in the end.
09:50:28 <dsal> texasmynsted: mostly network services, e.g., mqttd and web stuff.  A lot of cli stuff because that's how I do things. Data manipulation tools, etc...
09:50:31 <gehmehgeh> kuribas: oh! I had thought Dlists only allow "append" in constant time, that is "cons", but at the end side
09:50:48 <gehmehgeh> I have used dlists in the past
09:50:52 <texasmynsted> mqttd?
09:50:57 <kuribas> gehmehgeh: what do you mean with "only"?
09:51:05 <kuribas> gehmehgeh: that's basically what it does.
09:51:15 <dsal> texasmynsted: mqtt broker.  See mqtt.org (I think)
09:51:18 <texasmynsted> There is no way to replace an existing type class instance, right?
09:51:35 <gehmehgeh> kuribas: I thought (I could be mistaken) that this would still take O( length of [4,5,6]) in our example?
09:51:51 <gehmehgeh> Wait, I'm sorry, I'm uninformed...
09:51:56 <texasmynsted> oh, wow. mqtt is very interesting.
09:51:57 <gehmehgeh> let me check
09:52:04 <kuribas> gehmehgeh: I think the last list is shared
09:52:28 <texasmynsted> Idris has named instances, but Haskell does not. That is right?
09:52:42 <gehmehgeh> kuribas: hmm, in that case...
09:52:49 <dsal> texasmynsted: it really is!  I've written a client, a broker, a bridge to replicate data across mqttd instances, various transformation tools, etc...
09:53:07 <dsal> I don't know idris... What's a named instance?
09:53:18 <kuribas> > take 4 Data.DList.toList $ (Data.DList.fromList [1, 2, 3] <> Data.DList.fromList [4..])
09:53:20 <lambdabot>  error:
09:53:20 <lambdabot>      Not in scope: ‚ÄòData.DList.toList‚Äô
09:53:20 <lambdabot>      Perhaps you meant ‚ÄòData.Set.toList‚Äô (imported from Data.Set)
09:53:41 <texasmynsted> Having more than one type class instance for the same type, and selecting it by name. 
09:53:46 <kuribas> gehmehgeh: DList is linear in the length of the output.
09:54:12 <kuribas> gehmehgeh: but lazy, so only as much as is actually requested.
09:54:28 <dsal> It's a little weird to think of <> on a list as O(n) since it's not evaluated until you get there 
09:54:43 <texasmynsted> I am actually surprised how I can not recall how things work in haskell. If there is an existing instance for a type class, for a particular, type I am unable to replace it. Correct?
09:54:54 <kuribas> dsal: yeah, linear on the amount that you evaluate.
09:55:30 <texasmynsted> dsal: is your project open?
09:55:37 <dsal> texasmynsted: right, you'd end up with overlapping instances
09:55:39 <texasmynsted> It sounds really neat
09:55:54 <monochrom> Yes, it takes a bit more sophistication to state computation costs when laziness is involved. It is a function of both input size and demand size.
09:55:54 <kuribas> texasmynsted: you normally want typeclass instances to be unique.
09:55:56 <dsal> texasmynsted: I have... Several at github.com/dustin
09:56:27 <monochrom> But a simplifying convention is that if you only talk about input size, then you assume full evaluation.
09:56:40 <texasmynsted> There is a module that I use, from somebody else. I want to modify how it works. I think my only option is to fork it.
09:57:01 <texasmynsted> Forking it would likely not be worth the effort for the change I want.
09:58:44 <dsal> What's the class?  Can you just newtype?
09:58:56 <monochrom> The least surgical solution is you endow your own newtype wrapper. Then you can pin your favourite instance code to your newtype wrapper.
09:59:11 <monochrom> But this is also the most annoying. :)
09:59:23 <texasmynsted> What I want to do is really simple: I will show you.
10:00:24 <texasmynsted> See the text block at the end of this page? https://jaspervdj.be/hakyll/reference/src/Hakyll.Web.Redirect.html#createRedirects
10:00:40 <texasmynsted> I want to change 'redirectToHtml'
10:01:03 <texasmynsted> I should easily be able to do that if I replace 'instance Writable Redirect'
10:01:44 <dsal> Yeah, a newtype of Redirect is probably straightforward.
10:03:04 <texasmynsted> Thank you. It sounds like I need to try this. 
10:04:05 <monochrom> This leads me to the crazy idea of advocating maximally orphaned instances!
10:04:55 <monochrom> If every instance is in its own module, you can now freely mix and match, you can freely refuse to import whichever instance you don't want.
10:06:23 <texasmynsted> so Scala style then
10:07:28 <monochrom> Then again there can be a subtle problem. Some instances assume you have already accepted some other instances, lest there would be unpleasant surprises.
10:07:30 <dsal> Can we get compiler warnings telling us our instances aren't orphans?
10:08:23 <monochrom> However, my really favourite idea is named instances.
10:08:44 <texasmynsted> so actually Idris style?
10:08:49 <monochrom> Yeah
10:08:52 * hackage hakyll-contrib-i18n 0.1.0.0 - A Hakyll library for internationalization.  https://hackage.haskell.org/package/hakyll-contrib-i18n-0.1.0.0 (pcoves)
10:09:17 <monochrom> The part I'm most proud of is how I maximized the puns in naming it: https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html
10:09:27 <dolio> Idris and scala are the same style, possibly aside from idris having fewer weird rules for what automatically gets used.
10:10:19 <texasmynsted> Knowing which instance is used, with Scala, can be an issue.
10:13:37 <monochrom> I hope you see how I managed to make "tl;dr" a legit acronym for this :)
10:27:59 <dminuoso> hekkaidekapus, ski: Thanks again for your insight on the tree building. The intermediate step and then building a trie is the way to go here. :)
10:28:23 * hackage nix-thunk 0.2.0.2 - Lightweight dependency management with Nix  https://hackage.haskell.org/package/nix-thunk-0.2.0.2 (abrar)
10:36:36 <sshine> did you see Java 15 almost has ADTs?
10:38:33 <gentauro> sshine: like `sum types`? Hold my beer
10:38:36 <koz_> sshine: 'Almost has X' for all X is a good description of Java as a language.
10:39:01 <koz_> (well, 'Almost has X, but ten times as long with twice the caveats' might be more accurate)
10:39:07 <sshine> gentauro, https://openjdk.java.net/jeps/360
10:40:19 <dminuoso> With Haskell I learned the value of ADTs. I cant see myself programming in a language without.
10:40:23 <gentauro> koz_: ¬´COBOL was‚Ä¶ ‚Ä¶and that‚Äôs bad enough.¬ª replace COBOL with any language that is not Haskell. Source: https://sigkill.dk/writings/languages.html (Athas blog)
10:40:30 <sshine> dminuoso, now you can code Java!
10:40:37 <koz_> gentauro: Lol.
10:40:42 <gentauro> dminuoso: for me it's the `sum types`
10:40:56 <gentauro> at the moment ¬´I'm trapped¬ª in a C# freelance gig
10:41:07 <koz_> gentauro: I am so, so sorry.
10:41:09 <dminuoso> sshine: Mind my asking, why aren't they full sum types?
10:41:12 <dminuoso> What's their limitation?
10:41:12 <gentauro> I want to sigkill myself for every key stroke xD
10:41:21 <sshine> dminuoso, they're made in a funny way.
10:41:28 <dminuoso> Also, do you get depressed when discriminating Java sum types? Do you get refinement?
10:41:43 <dminuoso> Can we have full blown GADTs?
10:42:05 <gentauro> sshine: thx for the link, but my eyes began to bleed as soon as they saw the Java syntax
10:42:41 <sshine> dminuoso, sealed classes are a way to whitelist which sub-classes are allowed to inherit. so for an 'Expr' class you can have 'Add', 'Mul', etc. Since you have a fixed list known at compile-time, you can now do pattern matching on instanceof. but since it's still made in such a sketchy way on top, limitations apply.
10:43:10 <koz_> sshine: Does this allow compile-time exhaustiveness checking?
10:43:16 <gentauro> sshine: did they went for the .NET (C#) "way of doing it"?
10:43:16 <koz_> I'm going to assume 'no'.
10:43:22 <gentauro> cos that's really really bad
10:43:34 <dminuoso> sshine: Oh so the switch/case construct is just a bit of syntax sugar around multi-way if instanceof?
10:43:37 * dminuoso sighs
10:44:02 <gentauro> you test for "types". So you need to check if it's a `int`, a `char` a ‚Ä¶ (any `type` that is not nullable goes)
10:44:10 <gentauro> I can't make myself use that
10:44:16 <dminuoso> I see, so you cant have `char + char`?
10:44:34 <sshine> dminuoso, I'm pretty sure that's how it must be.
10:44:55 <dminuoso> So it's a union and not disjoint union of types...
10:44:56 <dminuoso> Mmm
10:45:02 <dminuoso> well, I guess you can get around that with helper classes
10:45:34 <dminuoso> Just in the style of Java. Introduce more noise so your developers can be busy writing Java.
10:45:43 <sshine> I learned today that Scala's None (aka Nothing) is defined like this: case object None extends Option[Nothing] with Product with Serializable
10:46:04 <htmnc> if I have like, a list of Maybe Int, is the type of that [Maybe Int]? if so how do I generically say hey this is a functor of a functor of a type or whatever like F G a?
10:46:11 <gentauro> dminuoso: it's very much like this `with | :? System.DivideByZeroException as ex -> printfn "Exception! %s " (ex.Message); None` -> https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/exception-handling/the-try-with-expression
10:46:22 <sshine> htmnc, yes.
10:46:46 <koz_> :t [Nothing, Maybe (1 :: Int)]
10:46:46 <htmnc> sshine, thank you :) 
10:46:48 <lambdabot> error:
10:46:48 <lambdabot>     ‚Ä¢ Data constructor not in scope: Maybe :: Int -> Maybe a
10:46:48 <lambdabot>     ‚Ä¢ Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Data.Maybe)
10:46:51 <dminuoso> htmnc: It implicitly is a functor by virtue of this instance:
10:46:51 <gentauro> it's `all` types, not a subset you specify in a sum-type
10:46:52 <gentauro> :(
10:46:53 <koz_> Argh.
10:46:57 <koz_> :t [Nothing, Just(1 :: Int)]
10:46:59 <lambdabot> [Maybe Int]
10:47:16 <sshine> htmnc, could you give an example of what you mean by a functor of a functor?
10:47:17 <htmnc> so I can say like :t Just Just (1::Int)
10:47:30 <htmnc> :t Just Just (1::Int)
10:47:32 <lambdabot> error:
10:47:32 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚ÄòInt -> t‚Äô
10:47:32 <lambdabot>                   with actual type ‚ÄòMaybe (a0 -> Maybe a0)‚Äô
10:47:44 <sshine> :t Just (Just (1 :: Int))
10:47:46 <lambdabot> Maybe (Maybe Int)
10:48:18 <sshine> :t Just Just
10:48:20 <lambdabot> Maybe (a -> Maybe a)
10:48:28 <dsal> :t pure pure
10:48:30 <lambdabot> (Applicative f1, Applicative f2) => f1 (a -> f2 a)
10:48:36 <dminuoso> % getCompose . fmap (+1) . Compose $ [Just 1, Just 2, Nothing] -- htmnc 
10:48:37 <yahb> dminuoso: [Just 2,Just 3,Nothing]
10:48:41 <dminuoso> Or
10:48:51 <sshine> 'Just Just 1' does not work because function application is left-associative, so that becomes '(Just Just) 1'... now, 'Just Just' is fine, but it isn't a function, but rather, a function 'Just :: a -> Maybe a' wrapped in a Maybe.
10:49:20 <dminuoso>  (fmap . fmap) (+1) [Just 1, Just 2, Nothing]
10:49:22 <dminuoso> % (fmap . fmap) (+1) [Just 1, Just 2, Nothing]
10:49:23 <yahb> dminuoso: [Just 2,Just 3,Nothing]
10:49:39 <htmnc> sshine, I was thinking about how to abstract doing a map on two arrays with a binary operation, like if I had F a -> F b -> F c I could do fmap on the F a giving my F b -> F c and then fmap again
10:49:45 <sshine> > join (Just (Just (1 :: Int)))
10:49:47 <lambdabot>  Just 1
10:50:39 <htmnc> I mean I'm missing a step there
10:51:02 <dminuoso> htmnc: Oh I see. What you're asking for is Applicative!
10:51:07 <htmnc> yeah!
10:51:14 <koz_> :t liftA2
10:51:17 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:51:28 <dminuoso> htmnc: Functor is for "mapping over things with unary functoins" and applicative generalizes this to n-arity functions (where n ranges from 0 to arbitrary)
10:51:55 <htmnc> !!! that's exactly what I was thinking about!
10:51:59 <htmnc> thank you!!
10:52:13 <koz_> htmnc: I advise reading the Typeclassopedia entry on Applicative.
10:52:18 <koz_> You will find many useful things. :D
10:52:22 <htmnc> will do
10:53:11 <htmnc> honestly the more I learn about Haskell stuff the more I wish I could find jobs that used it for things like backend
10:53:54 <maerwald> htmnc: why
10:54:08 <koz_> htmnc: It's possible - I do Haskell for Real Job For Real Money.
10:54:11 <maerwald> backend is all the same in the end
10:54:20 <maerwald> do something cool with haskell instead
10:54:27 <maerwald> don't use it for your day job
10:54:35 <dminuoso> Dunno, we're using Haskell in our backend and it's fun.
10:54:47 <koz_> maerwald: I respectfuly disagree. I love the fact I get paid to write Haskell.
10:54:48 <dminuoso> It's fun writing reliable code.
10:55:11 <dminuoso> Also the "backend" classification is mildly useless
10:55:14 <dminuoso> everything is a backend to something.
10:55:30 <maerwald> I just meant... from all the thing I can imagine doing in haskell... backend seems like a boring choice 
10:55:34 <koz_> Backend is anything which doesn't scribble on the screen.
10:55:51 <koz_> (seems to be the general take I read from its many uses)
10:56:22 <dminuoso> I guess only very few people use Haskell to run some UI directly..
10:56:37 <htmnc> maerwald, because I've worked with people who coerce things in really upsetting ways
10:56:40 <dminuoso> Unless you work for Obsidian
10:56:47 <htmnc> koz_, bless you
10:56:55 <maerwald> dminuoso: gtk is ok in haskell though
10:57:07 <dminuoso> maerwald: Sure, but I doubt it's used much. :)
10:57:23 <dminuoso> That doesn't mean anything negative
10:57:31 <dminuoso> just that most haskell developers aren't focused on UI stuff
10:57:52 <maerwald> dminuoso: yeah, most ppl think everything that does network requests must be a html page :p
10:58:03 <dminuoso> heh
10:58:14 <maerwald> so GTK apps that interact with APIs are rare
10:58:22 <dminuoso> Ive started a quest to reduce the number of stupid HTTP based APIs we have in our core.
10:58:23 <koz_> htmnc: Thank you. I didn't know you were a priest!
10:58:46 <htmnc> LOL just using the turn of phrase
10:59:31 <dminuoso> maerwald: I guess everybody has their own drug. I find high performance networking to be exciting currently.
10:59:46 <dminuoso> so writing Haskell to support that goal is fun
10:59:57 <maerwald> dminuoso: yeah and probably challenging
11:00:26 <dolio> Is the objection just that not all programming should be classified as either "front end of a web app" or "back end of a web app"? :)
11:01:07 <merijn> dolio: But then how will Hacker News understand what you're talking about? :o
11:01:24 <koz_> merijn: I would consider them _not_ understanding a point of pride.
11:01:26 <dolio> Don't care. :)
11:01:35 <merijn> koz_: That was the joke
11:01:45 <merijn> koz_: Are you familiar with n-gate?
11:01:51 <koz_> As in, deliberately write your first two paragraphs to be maximally exclusionary to people who browse HN un-ironically.
11:01:53 <koz_> merijn: No?
11:02:24 <merijn> koz_: Oh, you will appreciate this...it's "HN's daily #1 post...abridged": http://n-gate.com/hackernews/
11:03:09 <koz_> "In accordance with their tradition, the Electronic Frontier Foundation has created a new website to tell us how fucked we are by advertisers, while containing almost no advice for fixing any of it." OOOF, I'm a fan already!
11:03:32 <koz_> Thanks merijn - you have made my day a little brighter.
11:04:21 <dmj`> dminuoso: Re: UIs, OpenGL and Haskell work very well together. Just have fun cross-compiling.
11:04:47 <koz_> I believe there's nice Vulkan bindings too?
11:05:59 <texasmynsted> Isn't there a command in the REPL to write the session to a file?
11:06:15 <texasmynsted> I seem to recall there is but not how to do it. I do not see it in the help
11:06:56 <dmj`> texasmynsted: sadly, no.
11:07:02 <texasmynsted> hm
11:07:09 <texasmynsted> Maybe I dreamed it
11:07:28 <ezzieyguywuf> what's the difference between cabal and cabal-install?
11:07:37 <dminuoso> texasmynsted: head -n 10 ~/.ghc/ghci_history | tac
11:07:44 <dminuoso> I admit it's cheap, but effective...
11:07:54 <ezzieyguywuf> I'm tryig to use my package manager to install a minimal haskell build system, i.e. I can install the ghc binary from there, as well as cabal and cabal-install
11:08:03 <ezzieyguywuf> but I'm not sure if I need one or both of the cabal ones
11:08:06 <dminuoso> ezzieyguywuf: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
11:08:23 <maerwald> ezzieyguywuf: Cabal is a library, cabal-install an executable
11:08:25 <texasmynsted> ooh nice
11:08:31 <texasmynsted> Thank you dminuoso
11:08:45 <merijn> dminuoso: Writing that has saved me so much time over the past year :p
11:08:58 <ezzieyguywuf> maerwald: ah hah, thank you, so I'll install cabal-install and it should (hopefully) pull in cabal
11:09:02 <dmj`> koz_: yea but Vulkan is hard, need to learn OpenGL first
11:09:20 <maerwald> ezzieyguywuf: you shouldn't need to care whether it pulls in Cabal or not
11:09:23 <dminuoso> ezzieyguywuf: Huh what is your goal?
11:09:37 <maerwald> I don't see that the question entailed stack, lol
11:10:04 <dminuoso> For just a haskell build system you need `cabal-install` and `ghc`. Don't forget to run `cabal update` too, possibly regularly, so your index is up to date.
11:10:40 <maerwald> Yeah, if you want to interface with Cabal the library, I urge you not to
11:10:49 <dminuoso> cabal-install can deal with .cabal the file format and CABAL the spec. Whether or not it uses Cabal-the-library should not be relevant to you
11:10:49 <ezzieyguywuf> dminuoso: that link is helpful thank you.
11:11:04 <ezzieyguywuf> maerwald: you're right I shouldn't need to care.
11:11:17 <ezzieyguywuf> dminuoso: my goal is to have my package manager manage ghc and cabal for me
11:11:27 <maerwald> what package manager is that
11:11:37 <ezzieyguywuf> maerwald: portag
11:11:40 <ezzieyguywuf> *portage
11:11:41 <maerwald> bad idea
11:11:49 <maerwald> don't do it
11:12:08 <ezzieyguywuf> maerwald: why is it a bad idea?
11:12:50 <maerwald> ezzieyguywuf: gentoo can't handle GHC properly
11:12:50 <maerwald> it's a mess with the slots (and subslots)
11:12:50 <maerwald> you can't reasonably have multiple GHC versions
11:12:50 <maerwald> which you need
11:12:50 <ezzieyguywuf> maerwald: I figure it's worth a shot. It has a USE=binary option that simply pulls in the binary from upstream, i.e. y'all
11:12:57 <ezzieyguywuf> maerwald: ah, I see
11:13:02 <maerwald> yes, but if you install a library, what GHC is it built against?
11:13:04 <ezzieyguywuf> maerwald: why do I need multiple ghc versions?
11:13:19 <maerwald> because that's a very common thing/problem in haskell
11:13:44 <dminuoso> Whether ezzieyguywuf needs multiple GHC versions is for them to decide though...
11:14:03 <maerwald> Using portage for that will just give you pain 
11:14:20 <ezzieyguywuf> maerwald: anything installed by portage (which is all of cabal-install's dependencies) are built using the system ghc
11:14:28 <ezzieyguywuf> but, then again, the system ghc will be the only one I have...
11:14:32 <dminuoso> Disclaimer: maerwald is the author of the tool he's trying to get you to use. :p
11:14:57 <maerwald> dminuoso: nah, 5 years of gentoo development are just trying to save them from pain I know well enough
11:15:14 <dminuoso> maerwald: Ah I see. I had a Gentoo phase too when I was a kid. :(
11:15:22 <maerwald> the only distro that manages haskell well is NixOS, but then you have to use ...NixOS :D
11:15:24 <merijn> I was saved as a kid
11:15:32 <merijn> Someone gave me a FreeBSD shell instead :p
11:15:41 <maerwald> merijn: too chaotic
11:16:21 <merijn> maerwald: How so?
11:16:38 <ezzieyguywuf> ok
11:16:44 <ezzieyguywuf> maerwald: you convinced me :)
11:16:51 <ezzieyguywuf> you and epsilonKnot over in #gentoo-chat
11:16:57 <ezzieyguywuf> so ghcup it is
11:17:14 <maerwald> merijn: the tooling is like someone threw a bomb into a unix kitchen and then started yelling and laughing like a maniac and told you to pick what you like
11:17:26 <merijn> maerwald: wut?
11:17:34 <dminuoso> A long long time in the future, there will a trilogy of movies. "OS Wars", followed by "Linux Strikes Back" and "Return of the last BSD". And then a bunch of OSes nobody really wants to use, but they're marketed well so the movies will sell.
11:18:01 <ezzieyguywuf> or ghcup-hs I guess...
11:18:11 <maerwald> merijn: also, the linker on BSD...
11:18:18 <merijn> maerwald: It's like the opposite, where the tooling is consistent and actually documented, but everyone wrote unportable linux shite and you have to fix the piece yourself... >.>
11:18:41 <dminuoso> I agree. FreeBSD is the last OS that actually shipped with a manual good enough to learn and operate your system with.
11:18:56 <merijn> maerwald: Counterpoint: the linux linker :p (I guess some distros now ship gold, which is less braindead, but still)
11:18:58 <dminuoso> With Linux it's largely "hope there's a man page", otherwise dig around in archive.org, use the source, apply patches..
11:19:16 <merijn> dminuoso: Still ships with it, even. The Handbook is like a solid 70-80% of the reason I prefer it
11:19:50 <maerwald> dminuoso: most source code is self-documenting and it's saying "I'm shite"
11:19:52 <maerwald> :D
11:20:27 <merijn> maerwald: See, if you only use linux, then I agree with you :p
11:20:43 <merijn> Anyway, that's drifting -offtopic
11:21:13 <maerwald> ezzieyguywuf: btw... gentoo *could* ship a GHC with no haskell dependencies (and that would solve lots of problems)
11:21:42 <merijn> maerwald: That applies to all linux distros insisting on packaging haskell libs :\
11:22:02 <maerwald> I think OpenSUSE does that?
11:22:08 <glguy> Does it make sense for distros to ship haskell libs to be to build the haskell executables the distros ship?
11:22:24 <merijn> glguy: imo, no
11:22:25 <maerwald> glguy: many distros tried, because of pando
11:22:31 <maerwald> c
11:22:36 <maerwald> but they failed nicely
11:22:51 <glguy> better to have the distro rebuild all of the Haskell deps for each haskell executable shipped then?
11:23:05 <maerwald> better ship static binaries and give up!
11:23:06 <merijn> glguy: What's the benefit over shipping 100+ haskell library packages used by pandoc vs just shipping staticall linked pandoc?
11:23:21 <Clint> we do ship statically linked pandoc
11:23:22 <glguy> merijn: ideally the community could come up with two executables worth installing?
11:23:25 <Clint> but we need the libraries to build them
11:23:28 <merijn> glguy: It just pisses of users
11:23:44 <merijn> glguy: Two executables that happen to share the exact transitive dependency resolution?
11:23:58 <glguy> No, not exact, just overlapping
11:24:05 <merijn> glguy: Because if they depend (transitively) on different versions of the same lib, you still gotta build things
11:24:21 <Clint> that is why stackage makes things easier
11:24:40 <merijn> glguy: The main advantage in the C world is that you can independently update libraries, but GHC doesn't allow that anyway
11:25:19 <maerwald> Clint: ?
11:25:43 <merijn> Clint: Stack makes things *simpler* (it's failure model for build plans is just "it works" or "it does not, tough shit") not *easier*.
11:26:04 <merijn> And in the 2nd case, good luck ever fixing it to work
11:26:12 <glguy> It makes things easier for packagers if the developers are all targetting the same resolver, though
11:26:18 <dminuoso> The only mentality where all of this works is nix.
11:26:19 <ezzieyguywuf> maerwald: like I said, the ghc installation isn't really an issue, I can use portage to install the upstream binary
11:26:21 <merijn> glguy: Sure
11:26:40 <merijn> glguy: And if we all just use a single programming language and compiler for everything optimisation would be a breeze! :D
11:26:40 <maerwald> I don't think gentoo ever followed stackage though
11:26:51 <ezzieyguywuf> I guess it's the cabal-install that's an issue, since either (a) y'all don't provide a binary, or (b) gentoo doesn't provide an option to install said binary
11:27:02 <merijn> dminuoso: s/where all of this works/where all of this works *in theory*
11:27:05 <ezzieyguywuf> maerwald: what do you mean "followed stackage"?
11:27:15 <maerwald> ezzieyguywuf: used the version defined in stackage
11:27:22 <dminuoso> merijn: well it works in practice too, largely. Of course its not perfect, but tell me one package manager that is.
11:28:26 <ezzieyguywuf> you're right, it's getting its  binary from https://slyfox.uni.cx for some reason...
11:28:44 <maerwald> that's not what I meant, but anyway
11:29:11 <ezzieyguywuf> oh wait nvm, it comes from downloads.haskel.org
11:29:11 <maerwald> https://www.stackage.org/
11:29:19 <maerwald> stackage is just a package set
11:29:31 <maerwald> NixOS follows it 
11:29:39 <maerwald> most distros don't
11:30:34 <Clint> Debian tries
11:30:38 <Clint> but developers don't make that easy
11:31:13 <maerwald> they start packaging libs too? *sigh*
11:31:31 <Clint> there's no other way to build haskell apps
11:31:39 <maerwald> on linux there is
11:31:45 <merijn> Clint: Sure there is. You just build the binary and ship it, done
11:31:45 <maerwald> debian is not a source distro
11:31:53 <maerwald> they don't need to mess with libs
11:32:04 <sshine> maerwald, they've been doing that for a long time.
11:32:11 <merijn> Clint: Why would you need to package each Haskell library independently?
11:32:25 <sshine> merijn, so you don't need to compile them.
11:32:32 <sshine> merijn, so they work together.
11:32:37 <merijn> sshine: Distros *already* ship binaries
11:32:43 <sshine> merijn, it's a binary snapshot :) that idea in itself isn't bad.
11:32:53 <merijn> sshine: So why not ship the final executable and call it a day
11:33:08 <sshine> merijn, aren't we talking libraries?
11:33:14 <Clint> why would you hide all the libraries you've already packaged?
11:33:27 <maerwald> hint: dynamic linking doesn't really work well in haskell and doesn't give you the same capabilities C does
11:33:31 <sshine> Clint, who is hiding libraries?
11:33:35 <merijn> sshine: Installing pandoc installs 100+ dependencies that all update super frequently
11:33:41 <Clint> sshine: merijn is objecting to shipping libraries
11:33:50 <maerwald> *for haskell*
11:34:08 <sshine> Clint, via debian/ubuntu's package manager?
11:34:13 <sshine> Clint, yeah that's crazy. :P
11:34:14 <merijn> sshine: It's causing *massive* amounts of frustration and pissing of Arch/etc. users and none of them blame their distro, they all blame Haskell
11:34:31 <merijn> Clint: I'm objecting to shipping *haskell* libraries
11:34:58 <merijn> It's dumb. There's 0 actual reuse happening, it triggers tons of cascade updates, pisses off users, and has no pragmatic benefits
11:35:04 <Clint> right, so we would need to build them and then hide them to not ship them
11:35:24 <Clint> which is absurd
11:35:25 <sshine> merijn, I'm saying the intent is good. but I don't think that snapshot-based OS package managers are fit for frequent micro-updates. I think it creates an unnatural discrepancy between those who make libraries and those who use them via the OS.
11:35:51 <merijn> Clint: No, why would you "need to hide them" just ship the final pandoc/whatever executable and don't ship any libraries at all, no need to hide them
11:36:08 <glguy> libraries can do things like install supporting data files and such
11:36:29 <glguy> it's not just a matter of copying an executable, right?
11:36:51 <Clint> merijn: because you need the build dependencies packaged to build the final pandoc/whatever executable
11:37:14 <merijn> glguy: 1) packagers already control where Cabal puts those files, so they just need to ship those too, which is the same like shipping anything else 2) we should fix cabal-install's prefix independence (which is on my to do list)
11:37:59 <merijn> Clint: No you don't, you can just cabal build the pandoc executable without packaging dependencies. Just use a freeze file/local mirror of package versions if you care about auditing (not that anyone is auditing Haskell libs now)
11:38:49 <Clint> merijn: not in debian, you can't
11:39:00 <merijn> Clint: Why not?
11:39:10 <Clint> because all build dependencies have to be packaged and reproducible
11:39:20 <Clint> and buildable without network
11:39:21 <merijn> That's not "can't" that's "won't" and that's on them
11:39:29 <merijn> Clint: You can build without network fine
11:39:44 <merijn> cabal-install doesn't need a network
11:39:48 <Clint> right, i can do whatever i want if i don't care about distribution rules
11:40:05 <Clint> but you're all outraged because people are following the rules you don't care about
11:40:41 <merijn> Clint: If people self-impose dumb restrictions they don't get to bitch about the effect of those restrictions
11:40:46 <merijn> It's one or the other
11:40:56 <glguy> This feels like a more hostile conversation than it needs to be
11:41:09 <Clint> that's true
11:41:17 <Clint> i will abscond
11:41:39 <sshine> can't have that self-imposed dumb bitching. ;)
11:42:01 <merijn> Yeah, my bad. I just get so tired of people complaining about Haskell building being hard because they're making it hard :\
11:42:14 <glguy> The value in the conversation could just be in better understanding of what the limitations are and what's possible
11:42:18 <glguy> doesn't have to be a fight
11:42:24 <sshine> merijn, I'm not complaining, but I *could* be complaining, because it tends to be. ;)
11:42:28 <sm[m]> +1
11:42:33 <maerwald> Clint: do you have a link to that distro policy?
11:42:56 <sshine> merijn, also, distros distributing libraries is just a trap.
11:43:18 <merijn> sshine: In what way?
11:43:28 <sshine> merijn, well, you get stale snapshots.
11:43:43 <merijn> (or, I guess I should say "which specific flaw of many did you have in mind?" :p)
11:44:10 <sshine> merijn, and if the distro doesn't have the library you're looking for, you have to choose between either not using it, or completely losing the benefit of having snapshots maintained for you.
11:44:51 <merijn> Clearly the solution is to abandon software and become a gardener >.>
11:44:58 <sshine> I'm working on it.
11:45:02 <maerwald> merijn: do you have a nice spot?
11:45:08 <sshine> my cats are trying hard to prevent it from happening.
11:45:17 <merijn> maerwald: I have a garden, for now... :p
11:45:25 <merijn> Yes
11:45:42 <merijn> We should talk about cats, rather than packaging. Cats are clearly superior to software packaging
11:46:09 <Rembane> I want cats to do software packaging.
11:46:51 <Clint> maerwald: https://www.debian.org/doc/debian-policy/ch-source.html
11:47:18 <glguy> Clint: Is there a way to subscribe to some kind of stream to find out when I do something dumb that makes it hard to package my program in debian?
11:47:19 <maerwald> Rembane: you need more OCD than the average programmer to be a good packager :p
11:47:29 <maerwald> not sure cats qualify
11:48:14 <merijn> So, speaking of cats and somewhat staying on topic...
11:48:36 <Rembane> maerwald: That's a good point. What if packaging is like pushing things down from tables? :)
11:48:44 <merijn> Tragically, my lambdacats.org forward to, well, the lambdacats died a few years ago
11:48:49 <merijn> BUT!
11:48:54 <glguy> Clint: Also since you're listed as the packaging maintainer for glirc, I'll note that I did see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=801522 and I made a man page ^_^
11:49:01 <merijn> I just discovered someone has a mirror of the original images!
11:49:13 <maerwald> Rembane: that reminds me more of haskell library maintainers pushing their API changes downstream like a cat stuff from the table
11:49:24 <ezzieyguywuf> oh neat, ghcup install Haskell Language Server
11:49:55 <Rembane> maerwald: :D
11:50:45 <Clint> glguy: you could subscribe to https://tracker.debian.org/pkg/glirc for some subset of events
11:51:35 <glguy> thanks
11:52:35 <merijn> https://lambdacats.github.io/ \o/
11:53:43 <ezzieyguywuf> is the CHANGELOG.md thing necessary?
11:54:13 <glguy> Are you making something for other people to use?
11:54:15 <merijn> ezzieyguywuf: For what?
11:54:37 <ezzieyguywuf> merijn: cabal init created it
11:54:41 <merijn> ezzieyguywuf: CHANGELOG will be linked from Hackage for packages uploaded there
11:54:44 <ezzieyguywuf> I'm just wandering why it does that.
11:55:00 <merijn> ezzieyguywuf: Which makes it easy for people to see what changes from version to version
11:55:24 <merijn> ezzieyguywuf: See the changelog under the dependencies here: https://hackage.haskell.org/package/lens
11:56:16 <merijn> ezzieyguywuf: So is it *actually* necessary? No. Is it good to nudge people into including one by default? Yes.
11:56:41 <merijn> I mean, a license isn't *technically* necessary either :p
11:56:42 <ezzieyguywuf> merijn: ah, I see. thank you for that explanation.
11:56:54 <ezzieyguywuf> I tend to go to the projects git page first and search around there for history info.
11:57:30 <merijn> ezzieyguywuf: Yeah, but if you wanna just quickly check "did 4.16 add anything breaking since 4.15" having a convenient source of that without digging through git is nice :p
11:57:47 <ezzieyguywuf> didn't cabal use to build things in a hidden directory? I see "dist-newstyle" in my project dir now. am I misremembering? was this always the case?
11:58:16 <merijn> ezzieyguywuf: It *used* to use "dist/" so maybe you ignored that in the past, but didn't add dist-newstyle?
11:58:35 <ezzieyguywuf> hm, maybe that's it
11:58:42 <ezzieyguywuf> or I've been using stack for a while, maybe stack hides it
11:58:54 <merijn> Stack uses .stack-work, I think?
11:58:59 <maerwald> yeah, stack has a better default
11:59:09 <maerwald> non-hidden work dir is not a good default
11:59:25 <merijn> maerwald: Well, there's an open issues for discussing the "new" final naming of dist-newstyle on github :p
11:59:36 <ezzieyguywuf> I don't mind it, I'm used to 'build' dir with cmake
11:59:37 <maerwald> nice, the bikeshedding I needed 
12:00:29 <merijn> maerwald: https://github.com/haskell/cabal/issues/5731
12:02:11 <maerwald> too much bikeshedding :p
12:08:05 <merijn> Rats
12:08:14 <merijn> I have inadvertently made my own life annoying
12:08:14 <koz_> Such shed, much bike.
12:08:41 <merijn> Damn these types >.>
12:09:22 <sm[m]> ezzieyguywuf: changelog link is extremely useful, thanks for adding it
12:09:33 <sm[m]> I wish it was mandatory
12:13:18 <ezzieyguywuf> should I just put cabal update on a daily chron job?
12:13:38 <dminuoso> Dunno, should you?
12:13:46 <merijn> ezzieyguywuf: Naah
12:14:03 <dminuoso> If you have it daily, you will be annoyed very regularly that builds break
12:14:07 <merijn> ezzieyguywuf: It warns you if you haven't updated in 20 days or so, and even that isn't necessarily bad
12:14:08 <dminuoso> Because transitive dependencies are suddenly broken
12:14:24 <dminuoso> Sure, they get fixed promptly, but it adds a lot of friction
12:14:34 <dminuoso> A monthly job for this is more sensible
12:15:03 <dminuoso> (With the odd additional manual invocation)
12:28:24 <hekkaidekapus> Speaking of distros, Fedora has some facilities to be friendly to Haskell/Rust/Go. Debian & co. could be inspired by that.
12:29:13 <hekkaidekapus> For Rust, libraries as basically shipped as sources.
12:30:06 <hekkaidekapus> For Haskell, there is a Modularity repository where everything gets updated in lockstep.
12:30:29 <hekkaidekapus> And you can pull conflicting versions of the same package from that repo.
12:31:21 <hekkaidekapus> So, if you want binaries (or don‚Äôt want to be building stuff frequently), you just activate said repo.
12:31:44 <maerwald> yeah, I'm probably going to switch to Fedora sometime soon too
12:32:10 <dminuoso> hekkaidekapus: Btw I think I settled on list-tries. It's a very complete tries library, and I trust the author
12:32:27 <hekkaidekapus> dminuoso: Cool!
12:33:24 <hekkaidekapus> re Fedora, the base ‚Äòbase‚Äô repositories are Stackage-based, so if you‚Äôre in the Stackage mindset, that will be enough for you.
12:33:57 <hekkaidekapus> (Credits to petersen and tristanC who do the heavy lifting.)
12:47:09 --- mode: ChanServ set +o Sigyn
12:57:27 <ezzieyguywuf> shouldn't I want to know if a cabal update breaks builds? i.e. b/c I should update my cabal file (lol, so many cabals!) such that it doesn't fail?
13:03:59 <ezzieyguywuf> aside from getArgs at GetOpt, are there other command-line flag "managers" in base?
13:04:10 <ezzieyguywuf> or what are some common libraries perhaps not in base?
13:04:22 <merijn> ezzieyguywuf: optparse-applicative
13:05:14 <ezzieyguywuf> merijn: thanks for the recommendation I'll take a look.
13:05:47 <hekkaidekapus> ezzieyguywuf: Run `cabal freeze` to lock versions your dependencies.
13:07:00 <hekkaidekapus> You might also write `index-state: 2020-11-24T12:00:00Z` in cabal.project to let cabal use a specific index.
13:07:52 <ezzieyguywuf> hekkaidekapus: so this supports the idea of keeping the cabal index up-to-date though, right? because it forces me to use these features as-needed to ensure my stuff works
13:08:51 <dminuoso> +1 for optparse-applicative
13:08:58 <hekkaidekapus> Yeag, `cabal update` will be harmless for the project configured that way, and it will still be able to use latest versions for other projects.
13:09:02 <dminuoso> One of the sweetest libraries around, despite its quirky implementation. :p
13:11:20 <ezzieyguywuf> üòç optparse-applicative has some very nice features!
13:11:53 <fendor> is there some *nice* library to aggregate a csv file and visualise it as some simple graphs? Or am I going to be quicker and more painless with R?
13:12:06 <maerwald> I found it easier designing a cli interface in shell, than in optparse-applicative :p
13:12:19 <texasmynsted> dsal: What happened to your site? http://bleu.west.spy.net/~dustin/
13:13:11 <merijn> maerwald: That's on you :p
13:13:29 <maerwald> it's still too verbose
13:14:00 <merijn> It's a bit more verbose than necessary, but it's an insignificant amount
13:14:15 <maerwald> depends how big your cli interface is
13:14:25 <ezzieyguywuf> "it's still too verbose" optparse-applicative?
13:14:36 <merijn> Plus, for bigger/more complicated setups you want some custom wrapping anyway
13:14:52 <merijn> maerwald: I'm guessing ghcup is orders of magnitude smaller than mine :p
13:14:59 <aplainzetakind> Isn't Data.PQueue.Max.deleteFindMax supposed to pop a largest element from the queue?
13:15:04 <dminuoso> The initial overhead is small, and you get robust parsing, a fine help screen and shell completion...
13:15:08 <dminuoso> And it scales well
13:15:42 <merijn> Yeah, I'm willing to invest the tiny bit more code of optparse and be future proof for any expansion
13:15:48 <dminuoso> Perhaps optparse could need some additional combinators to bootstrap a miniature cli..
13:15:50 <dminuoso> That could help
13:15:51 <maerwald> merijn: Main.hs (where all the parser stuff is) is 1.7kLOC
13:16:23 <ezzieyguywuf> WOW!!!!
13:16:24 <maerwald> most of it because brittany likes newlines
13:16:29 <ezzieyguywuf> i try to keep my source files smaller than that, lol
13:16:48 <dminuoso> maerwald: What's your point here?
13:16:56 <dminuoso> optparse-applicative is a library, eys
13:17:11 <merijn> I think I have about 2k worth of optparse parsing code, possibly more :p
13:17:13 <maerwald> my point is that it's less code in shell 
13:17:23 <maerwald> which is an odd observation
13:17:29 <merijn> maerwald: But that's for about ~50 subcommands
13:17:32 <sm[m]> ezzieyguywuf: also cmdargs, docopt
13:17:37 <merijn> Across 3 executables
13:18:00 <merijn> I dislike cmdargs, ties your internal reprsentation to tightly to the external one
13:18:14 <ezzieyguywuf> sm[m]: saw cmdargs, that's what you're using in hledger :-P, haven't seen docopt though, I'll check it out.
13:18:47 <maerwald> haskell doesn't have a good alternative to optparse-applicative, but pythons click is much better 
13:18:51 <merijn> ezzieyguywuf: docopt (and even cmdargs) imo only scale to really small commandlines
13:19:10 <merijn> oof
13:19:15 <merijn> Click is godawful >.>
13:19:18 <dminuoso> I found click to be frustrating
13:19:19 <dminuoso> Hah
13:19:21 <maerwald> it's the best
13:19:25 <merijn> I suspect maerwald values very different things than I do
13:19:39 <maerwald> I used it with coconut, it was just intuitive
13:19:41 <merijn> optparse is super reusable, which is great :>
13:20:22 <glguy> Clint: neat, I got that notification :)
13:20:43 <dminuoso> python click is just tons of non-obvious decorators where it's not clear how they all interact
13:20:58 <maerwald> yes, you shouldn't know
13:21:28 <dminuoso> yes because why would you care to understand how components that you plug in interact with each other..
13:21:52 <maerwald> dminuoso: that's defined by the API
13:21:56 <maerwald> you have to understand that
13:21:59 <maerwald> not the internals
13:22:02 <maerwald> I dont care about them
13:22:03 <dminuoso> It's also very non-composable
13:22:44 <maerwald> that's python for you
13:22:55 <Chousuke> not having to understand the internals is all fine and good while things work :P
13:22:58 <maerwald> Tried to fix that with coconut
13:23:09 <maerwald> But all it did was causing pain for the next guy maintaining my crap :p
13:23:25 <ezzieyguywuf> i'm eating a coconut
13:23:25 <dminuoso> Let's just write a Haskell-to-Python compiler.
13:23:27 <dminuoso> In Python.
13:23:30 <dminuoso> For maximum pleasure
13:23:51 <merijn> maerwald: Right, but I value composability :p
13:24:48 <maerwald> merijn: I value stuff that doesn't piss me off :p
13:25:04 <merijn> I don't believe that for one second
13:25:17 <koz_> dminuoso: Snaked for your pleasure? :P
13:25:19 <merijn> You seem pissed of at technology and libraries nearly 24/7 :p
13:25:33 <merijn> So if you value not being pissed off, you seem to be doing something wrong :p
13:25:51 <Chousuke> I don't think there's anything related to computers that doesn't piss me off at least somewhat
13:26:29 <merijn> anyhoo, enough technology for tonight
13:26:59 <maerwald> merijn: I don't like stuff that leaks implementation details. Because there's too much of it, I can't be bothered with all of it. Just get it out of my sight :p
13:28:15 <maerwald> coconut leaks hard too, though
13:28:29 <Chousuke> An abstraction leaking implementation details is not the same thing as an abstraction that's transparent (ie. understandable) though
13:28:46 <maerwald> ah, classic topic: which one is lens?
13:30:00 <glguy> DigitalKiwi: What versions of things do I not support that are causing glirc to need special treatment?
13:31:51 <aredirect> Hi I want to take another look at haskell again, completely lost on which system to use
13:32:12 <aredirect> should i use cabal? haskell platform? distro packages? ghcup? stack? 
13:32:35 <triteraflops> most distro packages basically just use cabal anyway
13:32:47 <triteraflops> I prefer distro packages because it's a one stop shop for updates
13:32:47 <koz_> aredirect: What OS are you on?
13:33:03 <aredirect> ubuntu, i dropped the idea of the distro packages before because of arch
13:33:10 <dminuoso> aredirect: Both cabal-install and stack are fine choices. They differ slightly.
13:33:12 <koz_> aredirect: Use ghcup and don't look back.
13:33:13 <dminuoso> Use ghcup to install them
13:33:37 <DigitalKiwi> glguy: random 1.2.0 i think
13:33:41 <aredirect> can I have a system wide default installation with ghcup?
13:33:48 <maerwald> aredirect: kind of
13:33:53 <maerwald> but with hacks
13:34:03 <aredirect> what I want is, having a system wide haskell where i can write scripts and run them
13:34:07 <maerwald> it's meant to be user-wide installation, where do you want to put it?
13:34:14 <aredirect> and another one that has an enviornment per project
13:34:42 <aredirect> but the mos annoying thing when used stack it keeps downloading and consuming disk sizes which is in my case not that big
13:34:43 <triteraflops> Ideally, pacman would have some kind of cabal integration, so that haskell applications can be searched for and installed with a pacman frontend and cabal backend
13:34:53 <DigitalKiwi> and let me see i think irc-core has something too but i have to build it
13:35:05 <dminuoso> aredirect: That sounds like a curious requirements.
13:35:07 <dminuoso> What's the usecase
13:35:54 <aredirect> i develop in other languages e.g python which is available cross the system and when i want to develop a complete isolated project i fallback to virtualenv
13:36:10 <aredirect> but all my automation scripts work by default on the system installation outside of the venv
13:36:14 <DigitalKiwi> glguy: base64-bytestring >=1.0.0.1 && <1.1 on irc-core
13:36:19 <maerwald> aredirect: you can set GHCUP_INSTALL_BASE_PREFIX=/var/local for example, then it will install into /var/local/.ghcup
13:36:28 <maerwald> but it's up to you how you deal with file permissions
13:36:55 <aredirect> maerwald, ah don't want to ruin that i wish there was a minimal way
13:37:14 <aredirect> probably can be fine with stack if it stops downloading the world and using my disk space?
13:37:35 <DigitalKiwi> it's possible there are others too maybe i'm not sure but that might be it and the happy 1.2
13:37:57 <maerwald> aredirect: that is quite a minimal way, no? :p
13:38:06 <glguy> Oh, I regularly run 'cabal outdated' but that wasn't checking my libraries, just the top-level client
13:38:14 <aredirect> and can have a stack project called globalhs on my system and be done with it but i'd want that data downloaded to be cached and reused in every new project
13:39:21 <maerwald> eh?
13:39:50 <maerwald> both stack and cabal share installed libs across projects
13:40:06 <aredirect> hmm why then stack keeps redownloading ghc over and over?
13:40:13 <maerwald> yeah... xD
13:40:24 <maerwald> -> cabal 
13:40:27 <koz_> aredirect: Because the GHC version depends on the resolver.
13:40:32 <DigitalKiwi> glguy: this is the one we have right nowcopying path '/nix/store/l6rch8hzai15wwcacwcj2bscqcfpcqxh-base64-bytestring-1.1.0.0' from 'https://cache.nixos.org'...
13:40:53 <aredirect> is there a way to have that pinned koz_ for all of the projects?
13:40:53 <maerwald> koz_: which is sad, because you can just lift that restriction and stuff still works
13:41:03 <koz_> maerwald: Except when it doesn't.
13:41:11 <koz_> aredirect: Always set the same resolver in your stack.yamls.
13:41:18 <koz_> There may be soem kind of config as well, I dunno.
13:41:24 <koz_> Stack is documented like a saddle fits a cow.
13:41:56 <maerwald> right, only for cowboys
13:42:14 <aredirect> i was quitefond of haskell platform but i saw warning somewhere
13:42:25 <aredirect> and the main website just confuses the hell out of me
13:42:37 <maerwald> there is no haskell platfrom anymore really, except some distros have packages with that name
13:42:47 <glguy> DigitalKiwi: supporting the older random needed a code change, so that won't go out until next release
13:43:10 <dsal> texasmynsted: google app engine deprecated my build and shut it off.  I've got around to writing a new web server.
13:43:23 <aredirect> maerwald, did you see this page? https://www.haskell.org/downloads/
13:43:37 <aredirect> i swear i saw ghcup once on the website before :D
13:43:54 <maerwald> aredirect: yeah, it's a never ending topic
13:44:21 <aredirect> koz_, per project or globally? i don't want to keep track of which resolver i don't even know features after ghc 2010 i guess that was sthe version i used
13:44:34 <koz_> aredirect: 'GHC 2010' is not a thing.
13:44:36 <koz_> are
13:44:54 <koz_> aredirect: stack.yaml is per-project. There may or may not be some global thing stack uses.
13:45:02 * koz_ points to his comment regarding how Stack is documented.
13:45:15 <maerwald> aredirect: https://github.com/haskell-infra/www.haskell.org/issues/12 https://github.com/haskell-infra/www.haskell.org/issues/21
13:45:33 <aredirect> ah haskell 2010 koz_ my bad 
13:45:34 <maerwald> (and some more)
13:45:45 <koz_> aredirect: Every version of GHC supports Haskell2010.
13:46:00 <koz_> (well, every version you should even remotely consider using)
13:46:57 <aredirect> koz_, ah for sure i think i used to use hugs at certain point
13:47:21 <koz_> aredirect: In that case, just pick a version and go.
13:47:24 <aredirect> maerwald, indeed that page is confusing
13:47:39 <koz_> I _think_ LTSes for Stack only go as high as 8.8 for now?
13:47:44 <triteraflops> wait, clean isn't lazy, is it?
13:47:51 <DigitalKiwi> glguy: D:
13:48:03 <triteraflops> maybe that's how it gets away with using uniqueness types to do IO
13:48:05 <aredirect> koz_, yeah i'd have to check a version and see how to use it everywhere :(
13:48:15 <DigitalKiwi> glguy: ty, i'll put that comment in then and should appease the reviewer :D
13:48:17 <aredirect> but all of this is just too much even for someone who used haskell in the past :(
13:48:38 <koz_> aredirect: Tools require learning. That's pretty universal IMHO. 
13:48:39 <aredirect> guess I can explain monads easier than explaining the download page
13:49:04 <koz_> *insert obligatory statement about monoids in the category of endofunctors*
13:49:12 <koz_> *insert obligatory inquiry about what the problem is*
13:49:31 <aredirect> koz_, sure as long as you have a clear path that's not confusing for these tooling not 4 different paths 
13:49:42 <aredirect> koz_, hehe it'll never get old :D
13:52:01 <maerwald> aredirect: feel free to comment on those issues
13:52:29 <maerwald> the infra part is a bit more bureaucratic though, I guess
13:52:44 <maerwald> we can't have anarchy there either, obviously
13:53:27 <aredirect> maerwald, probably we need cargo there :D
14:26:23 * hackage gi-gtk 4.0.3 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-4.0.3 (inaki)
14:33:52 * hackage reflex-localize 1.0.0.0 - Localization library for reflex  https://hackage.haskell.org/package/reflex-localize-1.0.0.0 (NCrashed)
14:34:53 * hackage haskell-gi 0.24.6 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.24.6 (inaki)
14:35:53 * hackage reflex-localize-dom 1.0.0.0 - Helper widgets for reflex-localize  https://hackage.haskell.org/package/reflex-localize-dom-1.0.0.0 (NCrashed)
14:36:53 * hackage haskell-gi-base 0.24.5, haskell-gi 0.24.7 (inaki): https://qbin.io/person-smoke-zz5q
16:51:23 * hackage servant-exceptions 0.2.0 - Extensible exceptions for servant APIs  https://hackage.haskell.org/package/servant-exceptions-0.2.0 (ch1bo)
16:52:23 * hackage servant-exceptions-server 0.2.0 - Extensible exceptions for servant API servers  https://hackage.haskell.org/package/servant-exceptions-server-0.2.0 (ch1bo)
17:10:27 <ezzieyguywuf> how do I use the haskell language server that ghcup asked me of I wanted to install?
17:13:26 <koz_> ezzieyguywuf: Do you have an editor with support for it?
17:13:47 <ezzieyguywuf> koz_: i think so - vim.
17:13:57 <ezzieyguywuf> (with ALE plugin)
17:14:11 <koz_> ezzieyguywuf: So the answer is 'no unless you wanna run a garbage Node.js slurry', because ALE's support was broken last I checked.
17:14:14 <ezzieyguywuf> do I need to initialize the server myself?
17:14:17 <koz_> (incomplete LSP implementation)
17:14:28 <ezzieyguywuf> oh dang
17:18:37 <sm[m]> ezzieyguywuf: the easy way is install vs codes Haskell extension
17:19:03 <koz_> sm[m]: Which naturally involves using VS Code.
17:19:21 <sm[m]> right!
17:20:17 <sm[m]> If only to get a bunch of binaries installed, see how it works, decide if you need it etc.
17:20:49 <ezzieyguywuf> vs codes?
17:20:58 <koz_> ezzieyguywuf: It's an IDE.
17:21:01 <koz_> People seem to like it.
17:21:05 <koz_> I don't understand those people.
17:21:06 <sm[m]> VS Code's
17:21:20 <ezzieyguywuf> oh, I don't think I have that
17:21:47 <sm[m]> I'm an emacs guy but vs code plus hls is extremely good
17:22:12 <sm[m]> If you want to try out hls , it is the easy way
17:22:28 <koz_> sm[m]: Former Emacs, current (Neo)vim, and VS Code left me inordinately and utterly unimpressed.
17:22:48 <koz_> It's a giant slurry which barely functions, makes no sense, and eats resources like it's some kind of factory.
17:23:01 <sm[m]> ymmv
17:23:11 <koz_> Precisely, which is why I insist on mentioning it. :P
17:23:16 <Axman6> I'm a big fan of VS Code these days, heaps of extensions, is actively maintainerd and its performance is improving all the time
17:23:25 <sm[m]> I find it pretty light. Hls is the one eating ram
17:23:27 <koz_> Axman6: Can it run as fast as my Neovim?
17:23:33 <koz_> Because last I checked, it wasn't even close.
17:23:42 <Axman6> it runs fast enought that I haven't noticed any performance issues
17:23:55 <Axman6> HLS on the other hand...
17:23:56 <koz_> Axman6: I guess my mileage truly does vary, because I found it intolerably slow.
17:24:23 <sm[m]> it's not the speed king for typing. Nobody installs it for that
17:24:51 <ezzieyguywuf> i was never into the big IDE thing
17:24:57 <sm[m]> Hls ui is noisy and jittery sometimes. Even so - extremely useful
17:25:01 <koz_> sm[m]: What do you mean by 'not the speed king for typing'? I don't understand?
17:25:08 <ezzieyguywuf> I tried IDE whenever I was messing around in android, but even then I ended up reverting back to vim
17:25:14 <Axman6> my only problem with HLS is how much RAM it uses
17:25:34 <ezzieyguywuf> i think I'll stop toying with languag server thingy for now, lol
17:25:35 <Axman6> our dev laptops are 64GB for a reason (it's not just HLS, but that definitely doesn't help)
17:26:02 <Axman6> we do also have an enormous codebase though (and technically this is DAML Studio, not HLS, but they share a lot)
17:26:27 <Digit> yesterday, watching a talk on "the last programming language" got me itching to move from my text editor being extensible in lisp, to one extensible in haskell.  n_n  ... will be a while before i get feature parity to emacs in yi.
17:28:48 <sm[m]> koz_: you keep saying vs code is slower than X, I assume you mean for typing and ui response, I agree and also am saying it's somewhat beside the point
17:29:00 <koz_> sm[m]: Not to me it isn't.
17:29:11 <koz_> Again, YMMV is a perfectly valid response to my criticism.
17:29:29 <sm[m]> I understand. We don't need to keep arguing here :)
17:29:33 <koz_> :D
17:29:34 <int-e> the more times change, the more they stay the same... another round of editor wars...
17:29:40 <ezzieyguywuf> so with optparse-applicative, if you have 50 arguments/flags, then you have some `data MyArgs = Opt1 | Opt2 |....Opt50`?
17:29:54 <koz_> ezzieyguywuf: I mean... you _can_, but I don't think you have to.
17:29:55 <int-e> This should be the first rule of programming: don't talk about editors.
17:30:26 <sm[m]> vs code is extremely good at some things and in some aspects. End of my point.
17:30:33 <monochrom> May I talk about email and usenet news clients? >:)
17:30:39 <koz_> monochrom: :P
17:30:49 * monochrom plans to talk about using emacs for email and usenet news.
17:31:00 <ezzieyguywuf> koz_: what's another way to do it?
17:31:01 <Digit> int-e: n_n  this is much more peaceful and ammicable an editor/ide discussion than the wars of old.  n_n
17:31:14 <int-e> monochrom: or browsers... lynx, links, elinks, or w3m :P
17:31:32 <koz_> ezzieyguywuf: What do your 50 flags mean? Can they co-occur? What do they describe? How do you represent this data? Etc etc
17:31:36 <monochrom> I almost used emacs for web browser too.
17:31:38 <Digit> is there a web browser written in haskell?  that'd be cool.  :)
17:31:41 <koz_> There is no One True Answer to these questions.
17:31:54 <MarcelineVQ> Sure there is, it's the one I say
17:31:58 <int-e> Digit: It is. But it's still not going anywhere :P
17:32:39 <monochrom> What saved me from this depravity 20 years ago was that emacs did not have real concurrency.
17:33:03 <ezzieyguywuf> koz_: I was using 50 as an example. I currently only have 1 flag, for a filename. I guess my main question is - is the `data MyOpts = FileName String` approach the only way to use an optparse-applicative parser to parse the arguments
17:33:30 <koz_> ezzieyguywuf: No, in the same way as the 'data MyOpts = FileName String' approach would not be the only way to use a megaparsec parser.
17:33:45 <monochrom> Whenever its web browser was waiting for responses, the editor window become unresponsive. That disillusioned me to realize that emacs was not an OS afterall.
17:33:53 <koz_> Like... it's _your_ data, structure it however you want. Your internal representation doesn't have to precisely match the data you get fed.
17:35:43 <ezzieyguywuf> ok let me ask the question differently. Let's say I wanted to add my own "--help" option (just for the sake of argument, I know optparse-applicative has this built-in sorta). I don't really need `data MyData = FileName String | Help`, because if someone passes "--help" I want to display the help info then immediately exit, i.e. do nothing else
17:36:01 <ezzieyguywuf> so how would I accomlish that using optparse-applicative?
17:36:36 <sm[m]> ezzieyguywuf: do the docs not cover it ?
17:37:09 <sm[m]> I'm not being snarky, I want to know if o-a's docs are good enough yet
17:37:50 <ezzieyguywuf> sm[m]: the docs are really good, but from what I can tell they don't cover this.
17:38:04 <sm[m]> I found it hard to use but haven't given it a serious try recently
17:38:14 <ezzieyguywuf> sm[m]: or else, it's just not the intended use-case. or else (and this can definetely be the case) I just don't understand the docs enough to see how to do it.
17:38:26 <sm[m]> hard to learn, I meant to say
17:38:40 <koz_> ezzieyguywuf: Write a parser which only parses '--help'. Exec that. If it succeeds, great; if not, try a different one which gets your filename?
17:38:49 <ezzieyguywuf> koz_: ah hah.
17:38:54 <ezzieyguywuf> simple. elegant.
17:39:21 <koz_> This may be of use: http://hackage.haskell.org/package/optparse-applicative-0.16.1.0/docs/Options-Applicative.html#v:execParserPure
17:39:39 <ezzieyguywuf> hrm...or maybe using a <|> somewhere, I remember the documentation talking about that.
17:39:43 <koz_> (and some of the functions underneath that)
17:39:50 <ezzieyguywuf> koz_: I was just perusing that!
17:39:50 <ezzieyguywuf> lol
17:39:51 <sm[m]> I will say that you can always do your own preprocessing of args, I do it for exactly that case (short circuit to usage message with --help)
17:39:51 <koz_> You could use <|> I guess.
17:40:27 <koz_> Basically, a good habit to get into is 'break your problem into the smallest possible pieces, and only glue them together if you have to'.
17:40:36 <ezzieyguywuf> I think that (a) optparse-applicative is likely powerful enough to do whatever I want, and (b) I should just start with my one dinky flag and try more as the need arises
17:40:45 <koz_> A lot of the time I find folks instead think 'I need to build an all-singing, all-dancing monolith' and then find it very hard.
17:40:49 <koz_> (myself included)
17:40:50 <ezzieyguywuf> koz_: I think that's a good idea.
17:42:04 <koz_> And yes, start with one flag and work upwards.
17:42:12 <koz_> At least with one flag, you've got the functionality you need right now.
17:43:09 <ezzieyguywuf> precisely
17:47:13 <koz_> How exactly does the Alternative instances of the optparse-applicative Parser work? Is it backtracking?
17:47:31 <ezzieyguywuf> hope you're not asking me, lol
17:48:00 <koz_> ezzieyguywuf: Nope - this is a general question to Knowledgeable Folks.
17:48:42 <ezzieyguywuf> nice.
17:49:22 <int-e> . o O ( https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it )
17:49:55 <koz_> int-e: You never know when you need Alternative! :P
17:50:38 <int-e> koz_: refactoring is easy(-ish) with strong types
17:50:54 <koz_> Yup!
17:51:04 <int-e> anyway, it's a good principle, but hard to follow :)
17:51:14 <MarcelineVQ> *impossible
17:51:29 <koz_> sm[m]: You said earlier you wanted feedback on the way optparse-applicative is docced: it'd be nice if the Alternative behaviour for Parser was explained somewhere, because I can't seem to find it.
17:51:30 <int-e> (and hard to apply when you write code for others rather than yourself)
17:52:16 <sm[m]> thx, noted
17:52:26 <koz_> sm[m]: Would you be able to tell me?
17:52:37 <koz_> I'm genuinely curious but the digging through implementation would take too long.
17:52:44 <sm[m]> sorry, I don't know either
17:57:24 <ezzieyguywuf> hrm, this section has me a bit confused: https://github.com/pcapriotti/optparse-applicative#running-parsers
17:58:21 <ezzieyguywuf> if `opts :: ParserInfo Sample`, and `info :: Parser a -> InfoMod a -> ParserInfo a`, then how does the code snippet type-check?
17:59:04 <ezzieyguywuf> it seems to me that `fullDesc <> progDesc "Print a greeting for TARGET"` would be `InfoMod String`
17:59:35 <koz_> ezzieyguywuf: The whole thing in brackets is one argument.
17:59:44 <koz_> That whole thing is an InfoMod.
18:01:03 <ezzieyguywuf> koz_: but it seems to me that the typo of the whole bracketed area is "InfoMod String"
18:01:15 <ezzieyguywuf> ahh wait nvm
18:01:16 <koz_> Why would it be?
18:01:18 <ezzieyguywuf> I was being dumb
18:01:21 <koz_> What component of that suggests this?
18:01:28 <koz_> I'm pretty sure the 'a' type param is phantom there.
18:03:04 <ezzieyguywuf> I missed that `progDesc` takes a String as an argument
18:06:06 <ezzieyguywuf> lol, the movie I'm watching has a character named Haskell
18:14:47 <guest1125> how to get epoch time in haskell?
18:15:27 <Axman6> https://hackage.haskell.org/package/time-1.11.1/docs/Data-Time-Clock-POSIX.html?
18:17:21 <guest1125> getCurrentTime :: IO UTCTime
18:17:39 <Axman6> getPOSIXTime :: IO POSIXTime?
18:18:13 <guest1125> every call on those functions will get different values, wow
18:18:22 <guest1125> actions
18:18:48 <guest1125> get time through IO
18:19:00 <Axman6> yes...
18:19:19 <Axman6> by definition it pretty much has to run in IO
18:19:20 <guest1125> but could make it out of IO?
18:19:34 <Axman6> have you used IO before?
18:19:56 <guest1125> yes
18:20:07 <Axman6> do { now <- getPOSIXTime; let result = f now; print result }
18:20:49 <guest1125> I mean IO POSIXTime -> POSIXTime
18:20:52 <ezzieyguywuf> is there anything in base that can turn "~/Some/Path/" into "/home/me/Some/Path"?
18:21:20 <Axman6> guest1125: that's not something you can do, but in the code I wrote above, now :: POSIXTime
18:22:22 <guest1125> Axman6: I'd like name some files with the time when they're created, so I have to do it all in IO?
18:23:15 <Axman6> of course, there is nothing pure about the current time
18:23:32 <guest1125> ok
18:24:35 <Axman6> do { now <- getPOSIXTime; let fileName = "foo-" ++ show now ++ ".txt"; writeFile fileName content }
18:24:44 <Axman6> if you're writing files you're already working in IO
18:26:07 <guest1125> what about using time as seed to generate random number? is a good idea?
18:26:18 <Axman6> it's an idea :)
18:26:37 <Axman6> there's lots of "it depends" responses to that question
18:28:48 <frdg> it helped me to shift my thinking from the idea that I have to do something _in_ IO to realizing that what I am doing _is_ IO.
18:29:48 <guest1125> is anyone familiar with the term "double-barrelled CPS"?
18:29:55 <guest1125> what is it?
18:30:26 <Axman6> never heard the term, where did you find it?
18:30:36 <guest1125> twitter...
18:35:23 <guest1125> "As I've told you youngsters before, that type system can be done with double-barrelled CPS, and the folks at Microsoft have already tried it out at http://sml.net. I'll have a paper to show you when I get to that point!"
18:35:24 <Axman6> twitter is a lot of context to have to process
18:35:46 <Axman6> ask for the paper
18:36:05 <guest1125> there's not one yet
18:36:54 <guest1125> he is a scheme player, good at compiler stuff
18:38:36 <Digit> i dont think https://www.urbandictionary.com/define.php?term=CPS was helpful.  nsfw.
18:46:13 <koz_> Digit: It's a real pro move to look for compsci terms on UD.
18:50:25 <monochrom> Wait, what is double-barrelled CPS? I ought to teach it to my students and confuse them!
18:50:35 <keltono> seems to come from this paper
18:50:37 <keltono> https://www.cs.bham.ac.uk/~hxt/research/HOSC-double-barrel.pdf
18:51:05 <Digit> koz_: sometimes you get lucky.  n_n
18:52:03 <keltono> the key excerpt being
18:52:05 <keltono> > This transform is double-barrelled in the sense that it always passes two continuations.
18:52:07 <lambdabot>  <hint>:1:36: error: <hint>:1:36: error: parse error on input ‚Äòin‚Äô
18:52:25 <keltono> whoops
18:54:39 <monochrom> Ah, thanks.
18:57:04 <guest1125> would it be useful for something?
18:57:12 <Sonolin> hmm so I'm playing with FRP and I'm probably not getting things but this doesn't seem too helpful for things that aren't very interactive (like turn based games/roguelikes)?
18:58:39 <guest1125> Sonolin: what FRP is short for?
18:58:46 <Sonolin> functional reactive programming
18:59:22 <guest1125> Frech Representitive?
19:00:07 <guest1125> representative
19:00:19 <Axman6> I was thinking recently what it would look like to implement election vote counting systems in FRP to get live data from results (We use the HAre-Clarke system here, so the processing is actually quite interesting)
19:01:24 <guest1125> Axman6: could it avoid election fraud?
19:12:56 <koz_> Sonolin: Basically FRP is intended for highly interactive or async systems.
19:13:14 <koz_> If your case _isn't_ one of those two, it's probably not worth it.
19:13:31 <koz_> (like, nothing is stopping you from using FRP for something like that, but it's likely more trouble than it's worth)
19:13:38 <Sonolin> yea I can see how that can be useful, probably not the best for my case
19:13:58 <Sonolin> something to look at if I add multi threading and/or realtime capabilities in the future, though
19:14:51 <koz_> Sonolin: Multi-threading is an implementation detail. Asynchrony not so much.
20:08:23 <Axman6> guest1125: I doubt it, but it would make for a fun way to visualise things
20:13:56 <Axman6> guest1125: did you sort out youyr time/file naming issues?
20:13:59 <Axman6> your*
20:15:23 * hackage language-dickinson 1.4.1.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.4.1.0 (vmchale)
20:50:11 <triteraflops> Clean uses uniqueness types to do all of its IO. It seems to work fine and is about a billion times easier to understand than monads, no offence.
20:50:35 <triteraflops> Also, it allows destructive updates! There has got to be some kind of catch. What's the catch?
20:51:12 <koz_> triteraflops: Who says monads are about IO?
20:51:15 <Axman6> what makes you think we don't have destructive updates?
20:51:19 <koz_> Also this.
20:51:35 <triteraflops> koz_: haskell implements IO with monads. Therefore monads are about IO.
20:51:43 <triteraflops> They aren't just about IO, but they are about IO.
20:52:06 <dsal> Monads are about IO?
20:52:44 <triteraflops> Have you actually done any IO in haskell? Yes, IO and monads are obviously related.
20:52:48 <dsal> IO is one of the monads I use in my code, but most of the monads I use aren't IO.
20:53:06 <dsal> My mom and I are related, but I'm not my mom.
20:53:06 <koz_> What dsal says, pretty much.
20:53:12 <Digit> would it be fair to say, IO is implemented with monads, but not all monads have anything to do with IO?
20:54:09 <triteraflops> In my first question I didn't even say IO was the only thing monads do. 
20:54:43 <triteraflops> You understand the question and you know it. If you can answer it, answer it. Save me your mindless pedantry.
20:54:50 <triteraflops> This is why people don't like haskell.
20:55:18 <dsal> Asserting people understanding you doesn't make it so.  You can do IO without monads in Haskell.
20:55:33 <koz_> Applicative can easily be enough to do all the IO you need.
20:55:38 <triteraflops> dsal: how in the hell would you do that? Safely?
20:55:40 <koz_> (I've seen a few cases like this)
20:55:41 <dsal> Or even a functor.
20:56:01 <koz_> It's a question of how much power the interface requires.
20:56:11 <triteraflops> Only a subset of IO problems could be solved like that.
20:56:14 <koz_> Sometimes you truly need the full power of monad to describe the IO you wanna do.
20:56:17 <koz_> Sometimes, you don't.
20:56:25 <Axman6> triteraflops: we had IO in Haskell before monadic IO
20:56:47 <triteraflops> Axman6: and it was referentially transparent?
20:57:06 <Axman6> I believe so, I can't remember what it looked like
20:57:08 <triteraflops> It doesn't even matter. Modern haskell IO uses monads generally.
20:57:28 <triteraflops> Clean does not, and is still referentially transparent. It uses uniqueness types.
20:57:34 <triteraflops> Is there some kind of catch?
20:57:57 <koz_> Given that this isn't #clean? I'm not sure anyone really knows here.
20:57:58 <Axman6> I also disagree that monads are difficult to understand, particularly when it comes to IO - it is just an imperative language like any other bog standard language
20:58:58 <koz_> Also, a word of diplomatic advice? Accusing us of 'mindless pedantry', and opening your so-called question with a very strong subjective claim, which _by your own admission isn't even the point_?
20:59:04 <koz_> Not the best way to get responses.
20:59:37 <ocamler> hey, simple question, how can i declare type  ```Maybe Bifunctor [a] [a]```
20:59:39 <Axman6> generally the phrase "of offence" is used when someone intends to cause offence
20:59:46 <ocamler> this is giving me a compile error that I don't fully understand
21:00:00 <Digit> Axman6: monads are difficult to understand, for many, given the explanations.  would be nice if disagreeing with those who find monads a slippery concept was enough to help them find it easy to understand though.  
21:00:01 <Axman6> ocamler: I have no idea what that's supposed to represent, it's certainly not valid though
21:00:10 <koz_> ocamler: You've got a slight mixup here. 'Bifunctor' is a type class.
21:00:18 <ocamler> ohhh
21:00:22 <koz_> I too am not very sure what you're after here.
21:00:25 <ocamler> I see
21:00:36 <koz_> Digit: I feel it's a problem of people focusing too much on 'what is a monad' and less on 'why we care'.
21:00:48 <Axman6> ocamler: what's the intent you're after?
21:00:48 <ocamler> well I want some sort of wrapping type similar to a tuple, where I can fmap on either the first or second of the tuple
21:01:01 <koz_> The answer to the question of 'what is a monad' is both uninteresting (unless you're a cat theorist) and doesn't really get you anywherre in terms of how to use them and what they enable.
21:01:13 <koz_> ocamler: (a,b) is already a Bifunctor.
21:01:17 <Axman6> sounds like Bifunctor to me
21:01:17 <triteraflops> Let's try this again. Haskell uses monads to do IO. (You know what I mean. Save it.) Clean uses uniqueness types, and gets away with it. Is there some kind of catch?
21:01:20 <koz_> You don't need to do anything to make that a thing.
21:01:26 <triteraflops> A downside of using uniqueness types instead?
21:01:53 <Axman6> ocamler: what's the Maybe in there supposed to be for?
21:01:54 <dsal> haskell has the same problem git used to have back in the day.  People focus on the weirdest things because they're the most interesting and then everyone thinks they have to understand it weirdest-first.
21:02:03 <koz_> ocamler: Are you trying to write a data type, or a function that's meant to operate across multiple kinds of data?
21:02:11 <Digit> s/uses/can use/  ... might help rubbing "pedants" the wrong way.
21:02:39 <dsal> triteraflops: "you know what I mean" is not a very constructive way to explain yourself.
21:02:40 <Axman6> triteraflops: I don't know enough about uniqueness types to be able to comment, I wonder if the work on linear types in Haskell might give us somethig similar though? (I would be surprised if it would replace our use of monadic IO or monads for requencing)
21:02:48 <dsal> There are multiple effect systems in haskell.
21:03:03 <koz_> Axman6: AFAIK, uniqueness types and linear types aren't the same thing, though they are similar.
21:03:04 <triteraflops> Axman6: yes, it would, actually.
21:03:09 <dsal> There's also that thing lexi-lambda is working on.
21:03:12 <koz_> However, I would be the first to admit that I dunno enough.
21:03:16 <Axman6> eff?
21:03:30 <dsal> Yeah, I forgot what the underlying theory was behind that.
21:03:31 <Axman6> koz_: yeah I figured as much
21:03:31 <ocamler> koz_ i just replaced that code with some functions that I wrote on my own, like `mapFirst :: (a -> b) -> (a, c) -> (b, c)`
21:03:33 <dolio> Uniqueness types don't really make sense for IO.
21:03:52 <dsal> :t first
21:03:54 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:04:04 <dsal> @hoogle first
21:04:04 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
21:04:04 <lambdabot> Data.Bifunctor first :: Bifunctor p => (a -> b) -> p a c -> p b c
21:04:04 <lambdabot> Text.PrettyPrint.Annotated.HughesPJ first :: Doc a -> Doc a -> Doc a
21:04:07 <Axman6> @hoogle Bifunctor f => (a -> b) -> f a x -> f b x
21:04:08 <lambdabot> Data.Bifunctor first :: Bifunctor p => (a -> b) -> p a c -> p b c
21:04:08 <lambdabot> Data.Bifunctor.Apply first :: Bifunctor p => (a -> b) -> p a c -> p b c
21:04:08 <lambdabot> Protolude first :: Bifunctor p => (a -> b) -> p a c -> p b c
21:04:15 <dolio> At least, not for one of the purposes of IO in Haskell.
21:04:35 <triteraflops> dolio: that's what I thought, but like I said, Clean gets away with it. I'm still wrapping my head around it. I'm reading this: https://www.mbsd.cs.ru.nl/publications/papers/cleanbook/CleanBookI.pdf
21:04:40 <koz_> dsal: Delimited continuations IIRC?
21:04:46 <dsal> Yeah, that's the thing.
21:05:19 <dolio> triteraflops: Yeah. It's making the world-passing hack safer. But it makes the semantics worse.
21:05:23 <koz_> It's actually quite an old idea - that you can use delconts for effects.
21:05:34 <koz_> dolio: Wait... is that basically it?
21:05:38 <koz_> It's just RealWorld but safer?
21:05:44 <dolio> Yeah.
21:05:49 <koz_> Huh, TIL.
21:06:03 <Axman6> well that doesn't sound like an improvement at all
21:06:09 <triteraflops> dolio: makes the semantics worse?
21:06:10 <koz_> Is it some kind of linearity in the RealWorld value or something?
21:06:19 <dsal> koz_: Well, I meant new for haskell.  She said it required a new primitive.
21:06:26 <koz_> dsal: For efficiency.
21:06:27 <triteraflops> dolio: like a usability and code cleanliness thing?
21:06:46 <koz_> Because for many effects you don't need full continuation capture, but with the situation as it currently stands, you have to do it every time.
21:06:51 <koz_> Which makes effect systems slow.
21:07:32 <koz_> triteraflops: Are you familiar with the RealWorld trick?
21:07:39 <koz_> (aka how IO actually works under the covers?)
21:08:24 <dolio> triteraflops: If you really think about it, it doesn't make sense to explain effects by passing around a 'world', because that can't explain the difference between an infinite loop that prints things and one that doesn't. They both have the same result value (bottom). So you actually need to add I/O to the semantics of all functions, even though only the ones that pass around a 'world' actually have effects.
21:08:29 <triteraflops> koz_: I had just assumed IO was inherently unsafe and implementation-dependent under the covers, and did not dig deeper.
21:09:15 <dolio> So it is a failure for partitioning things into a pure semantics and a separate IO semantics.
21:10:12 <koz_> triteraflops: Basically, I would suggest reading Lazy Functional State Threads (the paper). You'll likely see parallels _very_ quickly, and it's eminently readable.
21:10:45 <dolio> If you're just implementing what IO does in a compiler, though, that doesn't matter.
21:11:20 <koz_> dolio: That's actually one of Edward's critiques from that thing he wrote where he came up with the Churched free monad.
21:11:22 <triteraflops> Ah yes, I'm pretty sure clean will let me make a function with no return value that internally prints a thing, yeah.
21:11:30 <triteraflops> That's a major sownside.
21:11:33 <triteraflops> *downside
21:13:12 <triteraflops> If the file handle only exists inside that function, it can be unique and still have unmanaged side effects.
21:13:40 <triteraflops> unless somehow, a world object has to be passed into every file handle creation...
21:14:09 <dolio> Arrays are a better use case, because they don't have this problem.
21:14:32 <triteraflops> I had hoped somebody just knew the answer. There was a decent chance.
21:14:33 <dolio> If you make an infinite loop that does stuff with an array, it doesn't really matter that it's modifying memory forever.
21:14:37 <triteraflops> I'll just keep reading
21:15:52 * hackage advent-of-code-ocr 0.1.0.0 - Parse Advent of Code ASCII art letters  https://hackage.haskell.org/package/advent-of-code-ocr-0.1.0.0 (jle)
21:16:24 <ocamler> how do you guys/girls deal with function arguments being in the wrong order, for example I want to map over a list [k] with this function: `findWithDefault :: Ord k => a -> k -> Map k a -> a` however the last argument wrong, is there a better way than writing a helper function for each one of these?
21:16:36 <dibblego> @type flip
21:16:38 <lambdabot> (a -> b -> c) -> b -> a -> c
21:16:53 <dsal> Or a section
21:16:56 <dibblego> > flip (-) 7 9
21:16:58 <lambdabot>  2
21:17:46 <ocamler> but in this case wouldn't i need a type of `(a -> b -> c -> d) -> (a -> b -> d -> c)`
21:19:16 <triteraflops> flip (findWithDefault some_a) some_map k should work
21:19:23 <glguy> ocamler, either with a locally defined function or a lambda expression
21:19:29 <triteraflops> if you curry the a argument first
21:20:06 <glguy> [findWithDefault a k m | k <- ks] -- or even a list comprehension can work nicely
21:20:06 <ocamler> ohhh that makes sense, thanks
21:21:16 <jle`> ocamler: i'd often use a lambda too
21:21:31 <jle`> map (\k -> findWithDefault a k m) ks
21:24:28 <triteraflops> Ah, my guess was right. You /do/ have to pass a world into the file handle open function.
21:24:37 <triteraflops> and world is unique.
21:24:41 <Axman6> almost always a lambda is more obvious than combinations of composition and flips
21:25:05 <triteraflops> You can't do any further IO unless you extract the world from the io-performing function after it returns.
21:25:23 <triteraflops> In this way, you can tell apart functions that do IO and functions that do not.
21:25:39 <triteraflops> world or a file handle must be passed into a function that does IO!
21:25:42 <Axman6> or at least, functions which may do IO?
21:25:43 <triteraflops> very interesting
21:25:49 <triteraflops> well, yes
21:26:04 <triteraflops> you could pass world in and output world again, and not actually use it
21:26:11 <triteraflops> though the same is true of the monad approach
21:26:23 * hackage skylighting-core 0.10.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.10.1 (JohnMacFarlane)
21:26:23 <Axman6> I'm just being a pedant :)
21:26:27 <triteraflops> lol
21:26:44 <koz_> triteraflops: That's why I suggested the Lazy Functional State Threads paper.
21:26:55 <koz_> The idea sounds _very_ similar to what it does, but safer.
21:27:23 * hackage skylighting 0.10.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.10.1 (JohnMacFarlane)
21:27:27 <triteraflops> You know I still don't see a downside to the Clean approach.
21:27:39 <triteraflops> Still waiting for the other shoe to drop lol
21:30:07 <Axman6> "No one uses clean, therefore it can't be very good" <- usually said about Haskell
21:30:50 <ocamler> uh this is a weird compile error, `Couldn't match expected type ‚Äò[Char] -> [String]‚Äô              with actual type ‚Äò[[Char]]‚Äô`
21:30:55 <ocamler> oh nvm
21:30:56 <ocamler> sorry
21:31:05 <Axman6> you got this, I believe in you
21:31:34 <ocamler> lol thank you :)
21:35:07 <triteraflops> Axman6: well, yeah, exactly, right?
22:15:27 <ocamler> hey quick question, I feel like this is simple idk why it doesn't work
22:15:33 <ocamler> ```next :: Int -> [Int]
22:15:49 <ocamler> next :: Int -> [Int]next = undefinedminimum :: Int -> Int -> Intminimum k x  | k < 0 = inf  | k == 0 = 0  | k > 0 = min $ next x
22:15:51 <ocamler> oops
22:16:01 <ocamler> next :: Int -> [Int]next = undefinedminimum :: Int -> Int -> Intminimum k x  | k < 0 = inf  | k == 0 = 0  | k > 0 = min $ next x
22:16:03 <ocamler> sorry
22:16:09 <ocamler> `next :: Int -> [Int]next = undefinedminimum :: Int -> Int -> Intminimum k x  | k < 0 = inf  | k == 0 = 0  | k > 0 = min $ next x`
22:16:38 <ocamler> https://pastebin.com/BdHKv9y9
22:16:47 <ocamler> I'm wondering why this isn't compiling
22:18:08 <ocamler> this is the error message https://pastebin.com/wP3YGaLN
22:19:38 <ocamler> nvm I solved it, sorry about the noise lol
22:19:40 <xerox_> :t (min,minimum)
22:19:42 <lambdabot> (Foldable t, Ord a1, Ord a2) => (a1 -> a1 -> a1, t a2 -> a2)
22:32:51 <ocamler> Is there an easy way of memoizing an Int -> Int -> Int -> Int function
23:28:23 * hackage conduit 1.3.4 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.3.4 (MichaelSnoyman)
23:35:34 <guest112`> Axman6: yes, I think I can solve the time naming file issue
