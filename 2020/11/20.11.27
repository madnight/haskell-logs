00:11:29 <ski> @type \f -> put =<< f =<< get
00:11:30 <lambdabot> MonadState a m => (a -> m a) -> m ()
00:11:36 <ski> @type \f -> put =<< lift . f =<< get
00:11:38 <lambdabot> (MonadState a (t m), Monad m, MonadTrans t) => (a -> m a) -> t m ()
00:11:41 <ski> @type (\f -> put =<< lift . f =<< get) :: Monad m => (s -> m s) -> StateT s m ()
00:11:43 <lambdabot> Monad m => (s -> m s) -> StateT s m ()
00:12:27 <ski> kupi : my mind went to `modifyM', and indeed there's a <https://hackage.haskell.org/package/cabal-debian-5.1/docs/Debian-Debianize-Prelude.html#v:modifyM>
00:12:54 <ski> (also i found <https://hackage.haskell.org/package/boots-0.2.0.1/docs/Control-Monad-Factory-Class.html#v:withEnv>)
00:31:53 <guest1127> I remember there's a haskell book called "xxx principle" but I forget that name
00:32:21 <guest1127> there're some lambda contents in it
00:32:52 * hackage deferred-folds 0.9.15 - Abstractions over deferred folds  https://hackage.haskell.org/package/deferred-folds-0.9.15 (NikitaVolkov)
00:52:41 <ski> opqdonut : "yes","or more expressive, however you want to look at it" -- no (see above)
00:52:51 <opqdonut> I saw your explanation, thanks
00:52:58 <ski> ok
02:42:06 <jonathanx> Anyone know how to do a custom 404 page in servant? I'm using Servant.HTML.Blaze :)
02:43:22 <Entroacceptor> jonathanx: I've found https://geekingfrog.com/blog/post/custom-404-with-servant
02:44:34 <jonathanx> Entroacceptor: yeah, found it too, but I can
02:44:41 <jonathanx> *'t get it to compile
02:45:37 <jonathanx> The blog post doesn't seem to be the actual code, seeing as there's a type definition with lowercase name and then weird indentation in the custom404
02:45:48 <jonathanx> I tried fixing it up but couldn't get it to work
02:47:18 <Entroacceptor> Geekingfrog: is that ^ your?
02:51:39 <dminuoso> jonathanx: Mmm, that style looks very off too.
02:51:48 <dminuoso> Seems wrong
02:52:03 <dminuoso> jonathanx: What'd you'd do is roughly this
02:52:18 <jonathanx> I solved it
02:52:24 <dminuoso> throwIO (err404{ errBody = "..." })
02:52:26 <jonathanx> had to return the 404 page
02:52:33 <dminuoso> Where body contains the content tha tyou want
02:52:53 <dminuoso> (Or maybe not throwIO, depends on how you run things - I dont use the Handler monad)
02:53:17 <jonathanx> I'll write to the geekingfrog person and ask them to update the blog post
02:53:20 <jonathanx> :)
03:20:23 * hackage hercules-ci-agent 0.7.5 - Runs Continuous Integration tasks on your machines  https://hackage.haskell.org/package/hercules-ci-agent-0.7.5 (RobertHensing)
03:49:32 <itai33[m]> say i have some complex record structure, what is the best way to ensure that when i modify some record `a`, other records `b` `c` etc that "depend" on it are rebuilt? assuming this dependence needs to interact with IO as well
04:05:12 <tomsmeding> itai33[m]: what do you mean with "are rebuilt"? Values are immutable; do you mean that those things live in an IORef or something?
04:12:51 <tomsmeding> unrelated question to this channel: if I have a data type with an existential type variable, or a (kind of equivalently) a GADT, that I want to unwrap in a monadic computation, I can choose between a case statement or a monadic bind with return: https://paste.tomsmeding.com/CqAEGdEx
04:12:57 <tomsmeding> is there a nicer way than this?
04:14:27 <tomsmeding> if one is still at the start of the function, a pattern guard also works, but sometimes you're halfway a do-block :p
04:15:24 <merijn> RankN eliminator?
04:17:03 <tomsmeding> what's that?
04:17:26 <merijn> tomsmeding: Like...a function? :p
04:17:38 <tomsmeding> so, switch to CPS form?
04:17:42 <merijn> Yeah
04:18:12 <tomsmeding> that introduces a new indent level, doesn't it?
04:18:21 <tomsmeding> in which case a simple 'case' also works :p
04:18:38 <merijn> Well, don't use existentials directly, then ;)
04:18:51 <tomsmeding> hah
04:19:13 <tomsmeding> "doctor, it hurts if I do this"
04:19:26 <tomsmeding> I'll just do the return trick :p
04:47:31 <royal_screwup21> how do I compile a function on here to check for errors?
04:47:55 <tomsmeding> what do you mean with "on here"?
04:48:16 <royal_screwup21> on this channel, I believe you can eval code 
04:48:40 <tomsmeding> you can, using lambdabot, but all the ~1000 other participants also see that ;)
04:48:52 <tomsmeding> I recommend installing GHC locally on your computer
04:49:40 <tomsmeding> or use something like https://repl.it/ if you don't want to / aren't able to do that for whatever reason
04:49:52 <royal_screwup21> hmm I'm trying to reproduce an error
04:49:57 <royal_screwup21> https://ideone.com/xvAVO5
04:50:25 <tomsmeding> import Data.List
04:50:26 <royal_screwup21> I don't quite get why the above isn't compiling
04:50:29 <tomsmeding> ;)
04:50:44 <tomsmeding> 'sort' and 'groupBy' are both in Data.List, not in the Prelude
04:50:46 <royal_screwup21> why do I need that? does it contain the sort function?
04:50:50 <royal_screwup21> ah
04:50:54 <royal_screwup21> ty
04:51:22 <tomsmeding> see also the documentation of the Prelude (https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html) and of e.g. data.List (https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html)
04:52:00 <tomsmeding> (you can use the 's' key on that page to open a search box in the base library, which includes these modules and more)
04:57:03 <royal_screwup21> hmm it still isn't compiling :(  https://ideone.com/DWO72R
04:58:16 <merijn> Because map returns a list...
04:58:27 <royal_screwup21> ahh gotcha, thanks 
04:58:33 <tomsmeding> :t map length . groupBy (==) . sort @String
04:58:35 <lambdabot> error:
04:58:35 <lambdabot>     Pattern syntax in expression context: sort@String
04:58:35 <lambdabot>     Did you mean to enable TypeApplications?
04:58:39 <tomsmeding> :t map length . groupBy (==) . sort
04:58:41 <lambdabot> Ord a => [a] -> [Int]
04:58:50 <tomsmeding> which in your case is [String] -> [Int]
04:59:04 <tomsmeding> (ignore the @ stuff)
04:59:11 <geekosaur> use yahb for TypeApplications
04:59:37 * tomsmeding notes that down
05:02:54 <royal_screwup21> I have [[int]] and I want to map it to [Int]. For each sublist, I want to convert it to 1 if that sublist contains a "2". If it doesn't, convert to 0 
05:03:02 <royal_screwup21> what's the easiest way to do this in haskell?
05:03:34 <royal_screwup21> 2* (i mean the integer 2 ofc, not the string "2")
05:04:41 <opqdonut> :t elem
05:04:42 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
05:05:06 <opqdonut> > map (elem 2) [[1,3],[2],[1,2,3],[]]
05:05:09 <lambdabot>  [False,True,True,False]
05:08:12 <royal_screwup21> I've tried something like this: `sum . map (\x -> bool_to_int (elem 2 x)) . map charFreqs' strings`
05:08:20 <hc> > map (fromEnum . elem 2) [[1,3],[2],[1,2,3],[]]
05:08:22 <lambdabot>  [0,1,1,0]
05:08:25 <royal_screwup21> (I also want to sum up all the ints at the end)
05:08:35 <hc> > sum $ map (fromEnum . elem 2) [[1,3],[2],[1,2,3],[]]
05:08:37 <lambdabot>  2
05:09:21 <hc> > sum $ concat [[1,3],[2],[1,2,3],[]]
05:09:24 <lambdabot>  12
05:10:03 <geekosaur> hm. what do you want to have happen if the sublist contains multiple 2s?
05:10:36 <royal_screwup21> that's ok, it just needs to contain 1 two. If it has mutliple 2s, it's still counted once 
05:11:36 <n0042> That is a really cool way to use fromEnum. 
05:12:04 <n0042> I would have used recursion to build a new list. Always cool to see these one-liners and learn a new trick
05:13:26 <royal_screwup21> is there a built in way to get the char freq from a string?
05:13:52 <royal_screwup21> a char counter basically, for strings 
05:14:09 <tomsmeding> > length (filter (== 'a') "abcabcaabc")
05:14:12 <lambdabot>  4
05:14:48 <tomsmeding> not built in, but the basic elements are powerful enough :)
05:15:14 <sshine> > Data.Map.fromListWith (+) (zip "hello world" [1,1..])
05:15:17 <lambdabot>  fromList [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
05:15:23 <royal_screwup21> ok cool ty :)
05:15:36 <royal_screwup21> what's the difference between . and $, in simple terms?
05:15:49 <sshine> f . g = \x -> f (g x)
05:16:12 <tomsmeding> f $ x = f x
05:16:14 <sshine> f $ x = f x
05:16:14 <sshine> hehe
05:16:33 <itai33[m]> tomsmeding: 
05:16:37 <royal_screwup21> so x is a concrete value?
05:16:43 <itai33[m]> shit sorry
05:16:49 <tomsmeding> can be whatever f wants as an argument
05:16:59 <sshine> . composes two functions, $ applies a function to an input
05:17:04 <tomsmeding> which may be a concrete value like an Int, or maybe f takes a function as argument, who knows
05:17:07 <sshine> royal_screwup21, functions are concrete values, too :)
05:17:15 <royal_screwup21> so basically, I'm trying this: `map(\x -> elem 2 x) $ map charFreqs' ["hello", "world"]` -- it works 
05:17:31 <royal_screwup21> but when i replace $ with .  I get a full blown traceback 
05:17:57 <tomsmeding> :t ($)
05:17:59 <lambdabot> (a -> b) -> a -> b
05:18:00 <tomsmeding> :t (.)
05:18:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:18:18 <sshine> map (\xs -> elem 2 xs) . map charFreqs' $ ["hello", "world"]
05:18:19 <tomsmeding> read those 4 times and try to understand them :p
05:18:22 <itai33[m]> tomsmeding:  with regards to my previous question, i want both to use this to cache potentially hard calculations and calculations of `b` and `c` that involve IO. the record is immutable, but it describes the state of a brick application so it is updated using an event monad whenever a "thing" happnes
05:18:39 <itai33[m]> I don't know what IORef is i'm looking into it now
05:18:57 <sshine> 'map f . map g $ xs' is what you're trying to do, royal_screwup21?
05:18:57 <tomsmeding> itai33[m]: if you're not using an IORef, you probably don't want to
05:19:18 <itai33[m]> what is it?
05:19:29 <tomsmeding> a mutable reference to a value :p
05:19:33 <tomsmeding> well, mutable in IO
05:19:38 <royal_screwup21> sshine yup, the `f` there maps a sublist to to True/False if it contains a 2
05:19:50 <itai33[m]> yeah I don't really think i need that
05:19:58 <itai33[m]> is my question clear at least?
05:20:12 <royal_screwup21> I don't really get why it doesn't work when I compose with . 
05:20:16 <tomsmeding> itai33[m]: I think it can be even clearer if you can give a piece of code that illustrates the problem
05:20:25 <geekosaur> you're not composing
05:20:27 <sshine> royal_screwup21, it is because of operator precedence rules.
05:20:42 <sshine> royal_screwup21, don't complicate your life :) use parentheses.
05:21:03 <itai33[m]> tomsmeding: i have been called for things irl i'll work up a minimal working example and tag you, thanks!
05:21:07 <sshine> royal_screwup21, map (\xs -> elem 2 xs) (map charFreqs' ["hello", "world"])
05:21:27 <tomsmeding> itai33[m]: 👍
05:21:42 <sshine> royal_screwup21, but since you're mapping twice in a row, why not: map (\xs -> elem 2 (charFreqs' xs)) ["hello", "world"]?
05:22:30 <n0042> I have been able to get some pretty whacky functions to map like that. It's surprising how flexible the language can be
05:22:54 <sshine> royal_screwup21, but if you're only interested in knowing if there is at least one of those strings for which 'elem 2 . charFreqs'' is true, why not: any (\xs -> elem 2 (charFreqs' xs)) ["hello", "world"]?
05:23:54 <royal_screwup21> ty :0
05:23:57 <royal_screwup21> :)*
05:24:56 <royal_screwup21> is there any easy to convert bool to int?
05:24:59 <royal_screwup21> I tried this: *Main> bool_to_int True = 0
05:25:00 <royal_screwup21> *Main> bool_to_int False = 1
05:25:15 <royal_screwup21> bool_to_int (elem 2 [1,2])
05:25:15 <royal_screwup21> *** Exception: <interactive>:39:1-21: Non-exhaustive patterns in function bool_to_int
05:25:22 <royal_screwup21> I don't get it 
05:25:35 <n0042> > fromEnum True
05:25:36 <sshine> > (fromEnum False, fromEnum True)
05:25:37 <lambdabot>  1
05:25:38 <lambdabot>  (0,1)
05:25:58 <royal_screwup21> hmm ok ty
05:26:04 <royal_screwup21> what's wrong with my way though
05:26:13 <geekosaur> your function would have workedin ghc
05:26:25 <geekosaur> but ghci needs it to all be in the same line
05:26:39 <tomsmeding> (or use the :{ and :} ghci commands)
05:26:43 <sshine> in GHCi you don't have the same freedom to write multi-line definitions by default.
05:26:45 <royal_screwup21> ah
05:27:24 <sshine> > let boolToInt b = if b then 1 else 0 in boolToInt False
05:27:26 <lambdabot>  0
05:30:12 <royal_screwup21> could someone explain to me why this doesn't work?  groupBy (==) . sort "hello"
05:30:16 <royal_screwup21>  • Couldn't match expected type ‘a -> [a1]’
05:30:17 <royal_screwup21>                   with actual type ‘[Char]’
05:30:17 <royal_screwup21>     • Possible cause: ‘sort’ is applied to too many arguments
05:30:18 <royal_screwup21>       In the second argument of ‘(.)’, namely ‘sort "hello"’
05:30:18 <royal_screwup21>       In the expression: groupBy (==) . sort "hello"
05:30:19 <royal_screwup21>       In an equation for ‘it’: it = groupBy (==) . sort "hello"
05:30:19 <royal_screwup21>     • Relevant bindings include
05:30:20 <royal_screwup21>         it :: a -> [[a1]] (bound at <interactive>:50:1)
05:30:33 <geekosaur> ugh, lease don't paste into the channel
05:30:40 <royal_screwup21> ok sorry
05:30:44 <geekosaur> and you are missing parentheses
05:31:11 <geekosaur> or a $, which you apparently still don't understand (so use parentheses instead)
05:31:24 <tomsmeding> > (groupBy (==) . sort) "hello"
05:31:29 <lambdabot>  ["e","h","ll","o"]
05:44:29 <asheshambasta> Is there a way to somehow tell where cabal is looking for packages inside a nix-shell? It seems like cabal reports that it cannot find obvious packages like xmonad-contrib etc from within a nix-shell on my system
05:47:22 <arifordsham> H! I would love some opinions on this blog post I wrote: https://arifordsham.com/is-haskell-fast/
05:56:37 <dminuoso> What's the right protocol to write a FromJSON instance in aeson, such that unknown/unparsed fields lead to a parse error?
05:56:57 <dminuoso> I want to reduce the amount of brittleness by forbidden people give me keys in objects I dont understand.
05:57:33 <dminuoso> (Aside from roundtripping the parsed object back to Value and comparing for equality)
05:58:46 <dminuoso> Gah, I guess aeson really wants me to use Generics/TH. :(
06:04:08 <itai33[m]> tomsmeding: this is a minimal working example:
06:04:08 <itai33[m]> https://gist.github.com/iyefrat/dd1d6f124f298a053dad6824681a7795
06:05:09 <itai33[m]> the idea is that i want that whenever i modify words for any reason, it automatically triggers everything else that needs to change as well, so i don't have to remember to change it 
06:05:32 <itai33[m]> also the records are nested if that matters
06:07:24 <itai33[m]> now that i have written out this minimal example,  i feel like the most straightforward way is to just create a collection of "rebuild" functions for each record field, but I wonder if there is a better way
06:10:11 <itai33[m]> because for example, if i have some rebuild chain a -> b -> c,  what i need to do when b changes is the same whether or not i change b or a, and it feels pointless to write the same code for that twice which is what i'm trying to avoid
06:46:19 <lyxia> dminuoso: have you seen "rejectUnknownFields"
06:48:46 <merijn> dminuoso: Clearly the solution is not to use JSON ;)
06:49:24 <merijn> itai33[m]: Sounds like you want FRP :)
06:49:34 <geekosaur> yaml? }:>
06:49:47 <merijn> geekosaur: I will send assassins after you >.>
06:49:58 <merijn> Dhall or bust!
06:51:25 <maerwald> yes, yaml is great
06:52:36 <maerwald> or sqlite
06:52:58 <itai33[m]> merjin: my searches have lead me to reading this paper, is it related?
06:52:58 <itai33[m]> https://dl.acm.org/doi/pdf/10.1145/503272.503296
06:54:06 <merijn> itai33[m]: I was thinking of: http://conal.net/papers/push-pull-frp/
06:55:08 <itai33[m]> do you know what the difference between the two approaches are?
06:55:31 <itai33[m]> also what is a good FRP library
06:56:04 <itai33[m]> cause for AFP it seems i will have to write it myself almost as adaptive is undocumented and out of date
06:56:12 <itai33[m]> merijn: 
06:57:12 <merijn> I have no clue what adaptive functional programming is supposed to be, tbh
06:58:50 <Squarism> Im trying to familiarize myself with Lens package (https://hackage.haskell.org/package/lens). There is a nice diagram on provided hackage page "the core of the hierarchy of lens-like constructions". Im cannot see how these "relations" are reflected in the code definitions of the named types. Other than being "functionally/structurally similar". Bare in mind, I still consider myself a learning haskeller so assume I might be missing something.
07:04:31 <itai33[m]> merijn: well at any rate thanks for the paper i'll look into it
07:05:10 <merijn> Squarism: It's captured by things like "this optic require Applicative", "this one requires Functor", since all Applicatives are also Functors, this kinda "subtyping" follows from that
07:05:47 <merijn> Squarism: That said, lens isn't the most accessible code to understand even for non-beginners :p
07:11:03 <Squarism> merijn, ah ok. How do you define "optic" ?
07:11:34 <merijn> Squarism: "optic" is just a generalisation of lenses
07:23:57 <monochrom> Lenses make sense for product types but not sum types. Prisms were invented for sum types. So people needed a word that covers both. But sometimes people also use "lens" to cover both because the library package is already called "lens", too late to change.
07:27:46 <Sonolin> is there an easy way (with stack) to create a static exe for windows?
07:30:05 <Squarism> monochrom, thanks
07:31:31 <maerwald> static exe on windows? is that even a thing?
07:34:05 <Sonolin> hmm idk honestly haha I'm just trying to get my app building for windows properly without having to bundle sdl and all that
07:39:14 <hpc> maybe if sdl was packaged as an msi
07:39:18 <hpc> and you packaged your thing as an msi
07:39:47 <hpc> just knowing how every other piece of windows software is packaged though, i don't think you have much of a choice
07:44:53 * hackage hocon 0.1.0.0 -   https://hackage.haskell.org/package/hocon-0.1.0.0 (aleperaltabazas)
07:54:01 <sm[m]> g'day all
07:54:23 * hackage hocon 0.1.0.1 - Small library for typesafe's configuration specification  https://hackage.haskell.org/package/hocon-0.1.0.1 (aleperaltabazas)
07:54:39 <f-a> hello sm[m] 
07:54:55 <sm[m]> Sonolin: for non-SDL apps I do an ordinary stack build, and the exe works on other windows machines. For an SDL app, perhaps including SDL DLLs in the same directory is enough ?
07:55:30 <Sonolin> good to know thanks sm[m]
07:55:58 <sm[m]> you could also ask #haskell-game, the sdl2 issue tracker, or look at haskell SDL games like dino-rush
07:59:09 <sm[m]> see interesting windows build command at https://github.com/jxv/dino-rush#readme
08:00:19 <f-a> mhhh does it bundle libraries?
08:01:24 <sm[m]> I suspect that pacman -S means "static" and yes.. not sure
08:02:04 <hpc> -S is synchronize
08:02:09 <sm[m]> ack
08:02:23 <hpc> which apparently means pull from remote repositories?
08:03:18 <f-a> embitters me that — in general, for every language — deploying for multiple platforms still seems a Sisyphus’ task
08:04:18 <hpc> the good news is that means it's a language-independent problem
08:07:29 <sm[m]> I still think Sonolin should test that build command, since it mentions the SDL libs and might be doing something useful with them
08:08:27 <sm[m]> ohh.. it's just installing them so stack build can see them
08:08:38 <sm[m]> but who knows what can work on windows
08:09:30 <f-a> oh.
08:13:58 <nango> haskell newbie here: Is there any haskell extension that would allow me to
08:15:55 <gallo`> adsf
08:17:09 <Sonolin> so I got it building in appveyor this morning (I used that pacman command mentioned above and it worked)... I'm trying to dl wine since I don't have a windows pc
08:17:41 <Sonolin> but where does stack exec -- pacman put the dlls? I don't see them in .stack-work... I'm guessing they are installed somewhere on the C drive?
08:18:16 <sm[m]> Sonolin: yes, check pacman docs I guess. Maybe it has a verbose flag
08:21:27 <Sonolin> oh I see it just uses the pacman from mingw its probably in wherever mingw is installed
08:29:43 <nango> How could I write the following in GADTs? `data Show a ⇒ MyCoolType` I.e., a datatype without any constructor, but still I'd like a constraint. In my particular case it is useful to use datatypes as tags. In GADTs I only know how to do it using constraints in the constructors, but not otherwise. Thx!
08:31:21 <merijn> nango: You don't, because that's 99% certainly not what you want
08:32:05 <merijn> Usually when people *say* "I want to put a datatype on my context" what they *mean* is "I want a way to avoid writing the constraint on all functions on my datatype"
08:32:26 <merijn> However, that's not what the context there lets you do
08:33:19 <nango> Ok, I guess it's a missconception on my side. You mean that I should make sure that this kind of information gets propagated everywhere in the pertinent functions 
08:34:07 <merijn> nango: You will have to do that anyway, yes
08:34:36 <merijn> If you write "data Show a => MyCoolType = ..." you *still* need to add "Show a =>" to each function that uses show
08:34:56 <merijn> So the only thing you've accomplished is stopped some uses of your datatype, without getting any benefit
08:35:48 <nango> ok, I did not know that, I guess this is related to why `DatatypeContexts` is a misfeature, silly me
08:36:20 <merijn> That's pretty much why it was removed from the 2010 Report, yeah
08:37:34 <nango> thank you! ;)
08:48:01 <tomsmeding> itai33[m]: it seems merijn got to you first :)
08:49:05 <tomsmeding> FRP indeed came to my mind too when you initially described what you wanted, but I'm completely unfamiliar with it so I felt uncomfortable suggesting it
08:49:35 <tomsmeding> also it sounds that maybe, depending on how complicated your system is, there may be a simpler/different way to program it that doesn't require this "automatic updating"?
08:59:23 * hackage git-annex 8.20201127 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20201127 (JoeyHess)
08:59:33 <nango> merijn: sorry to bother, however this works:
08:59:54 <nango>  
08:59:54 <nango> data Whatever a where
08:59:54 <nango>   Whatever ∷ Show a ⇒ a → Whatever a
08:59:54 <nango>  
08:59:57 <nango> lala ∷ Whatever a → String
09:00:00 <nango> lala (Whatever b) = show b
09:00:04 <merijn> Right, but that's something else entirely :)
09:00:25 <merijn> GADTs enable existential quantification which lets you do some things like that
09:00:44 <nango> ok, however is this bad practice, or is it completely fine ? 
09:00:55 <merijn> Although existential quantification also can get you into a bunch of trouble :p
09:01:03 <merijn> @where existential-antipattern
09:01:03 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
09:02:51 <nango> ok, I'll take a look thx again !
09:05:39 <dolio> I think the majority of the trouble you'll run into is people quoting that blog at you here.
09:05:54 <dolio> Which doesn't itself describe much trouble you'll have.
09:06:28 <merijn> It depends
09:06:31 <tomsmeding> "Of course, the expansion is smaller than the original."
09:06:40 <tomsmeding> that's clickbait
09:06:45 <tomsmeding> for lack of a better word
09:06:58 <merijn> Not all uses of existential quantification match the antipattern
09:07:35 <dolio> People will cite that article even when it doesn't match.
09:08:14 <dolio> Also the article barely even says why to not use the 'anti-pattern'. It just says not to.
09:08:20 <merijn> dolio: Sure, but in this case it was more of a "be aware of pitfalls before throwing existentials all over"
09:16:34 <tdammers> IIRC that article describes a fairly specific use case of existentials, namely, heterogenous lists
09:30:31 <f-a> http://www.ariis.it/static/articles/2020-haskell-survey-analysis/costruzione/grafici/php/answerOverview.png Philoupap made some visualisation for the Haskell survey
09:31:44 <f-a> (all the graphs http://www.ariis.it/static/articles/2020-haskell-survey-analysis/page.html#bonus )
09:34:18 <benjamin-l> why is it that '<$>' binds differently from '$', so that things like 'f <$> g $ x' don't work?
09:45:10 <ski> tdammers : fwiw (sortof re the existential question), Idris' pattern-matching binds with alternative branches is interesting, <http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#pattern-matching-bind>
09:47:32 <ski> (also i'm reminded of the `let'-`try' / exception pattern-matching in O'Caml, <https://caml.inria.fr/pub/docs/manual-ocaml/patterns.html#sss:exception-match>,<https://web.archive.org/web/20161027043544/http://mjambon.com/extend-ocaml-syntax.html#lettry>, idea from "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <https://www.cs.tufts.edu/~nr/cs257/archive/nick-benton/exceptional-syntax.pdf>)
09:48:15 <Orbstheorem> Hi o/ How can I expand a shell path in haskell? (e.g. "$XDG_CONFIG_HOME/foo" or "~someuser/somefile")?
09:51:05 <ski> benjamin-l : `$' has lower precedence than `<$>'. (and even if that wasn't the case, in case they had the same precedence (rather than the ordering being reversed), the right-associativity of the former wouldn't square with the left-associativity of the latter)
09:52:02 <ski> benjamin-l : in any case, why not just write `f <$> g x' ?
09:52:53 <ski> (or, in case your `x' is actually a non-atomic expression, why not `f <$> (g x)' ? hm, there's also `(fmap f . g) x', i suppose)
09:52:59 <vfaronov> Hi all! I've compiled a program, and it errors with:
09:53:03 <vfaronov> > Weighted.hs:89:21-57: Non-exhaustive patterns in Just ((k, b), c)
09:53:05 <lambdabot>  <hint>:1:47: error: <hint>:1:47: error: parse error on input ‘in’
09:53:07 <vfaronov> Problem is, there are only 43 lines in Weighted.hs, and I don't see a pattern like that in my code. Any ideas on how to debug this? -O0 instead of -O2 doesn't help
09:53:17 <ski> (er .. sorry, i meant of course `f <$> g (x)')
09:54:10 <Orbstheorem> vfaronov: That error is precisely because such pattern is missing.
09:54:44 <Orbstheorem> vfaronov: Share the code maybe?
09:55:27 <Orbstheorem> Above line `47`, there should be a function that is missing the pattern.
09:55:28 <geekosaur> we'd have to see the code, yeh. I'd suspect CPP without any other evidence, since it can throw line numbering off
09:55:42 <benjamin-l> ski: mainly it's just for convenience if there's a long chain of nested functions
09:55:47 <benjamin-l> is using ($) a lot bad style?
09:56:00 <Orbstheorem> benjamin-l: IMHO yes, it makes your code unreadable :(
09:56:38 <geekosaur> Orbstheorem, the point is the error is reported on line 89 of a 43-line file
09:57:05 <geekosaur> something is expanding (buggy) code into their file
09:57:14 <Orbstheorem> geekosaur: Oh sorry, I misread lambdabot's message as part of the OP.
09:57:17 <Orbstheorem> x)
09:57:36 <ski> benjamin-l : "is using ($) a lot bad style?" -- imho, yes. i very rarely use `$' at all (`BlockArguments' has gotten rid of most of my remaining uses of it)
09:58:31 <ski> benjamin-l : i often see newbies write `foo (bar x $ baz y z)' for no good reason at all, when `foo (bar x (baz y z))' or `(foo . bar x) (baz y z)' would have been clearer/better, imho
09:58:45 <Orbstheorem> benjamin-l: Personally I like explicit parenthesis or something like `let foo = a . b . c . d in foo bar`.
09:58:56 <Orbstheorem> s/like/prefer/
09:59:21 <benjamin-l> ooh, I didn't know about BlockArguments
10:00:32 <geekosaur> it's newish
10:01:32 <benjamin-l> this wouldn't get rid of most of my ($) uses, so I think I'm doing something else wrong
10:02:44 <benjamin-l> I end up using ($) pretty frequently to, for example, chain different transformations together. An example from the thing I'm currently working on: `ExceptT $ fmap (first MyError) $ try $ ...'
10:02:59 <benjamin-l> in order to lift an IO exception into a custom error in ExceptT
10:03:18 <benjamin-l> is there a better way to do this type of thing?
10:04:34 <geekosaur> xmonad layoutHooks use that pattern a lot
10:04:49 <vfaronov> ah... mystery solved: it refers to another, similarly-named Weighted.hs in third-party code, got me confused
10:05:23 <benjamin-l> the IO exceptions scare me because they're not expressed in the type system
10:05:28 <monochrom> BlockArguments is for "f (\x -> g x)" -> "f \x -> g x" and "f (do ...)" -> "f do ..."
10:05:53 <benjamin-l> I'm used to rust, where pretty much anything that can fail will return `Result<T, E>', and I'm trying to mimic that kind of pattern in haskell
10:05:53 <monochrom> But "f (g x)" has to stay "f (g x)", "f g x" has always meant something else.
10:06:08 <benjamin-l> but maybe I'm looking at this the wrong way and the IO exceptions aren't that bad
10:06:49 <monochrom> IO exceptions are good when it's from opening a file for example.
10:07:18 <monochrom> From "2nd item of a list but the list is empty" of course no one likes IO exceptions.
10:09:23 <ski> benjamin-l : `foo x $ bar y z w $ bleh t $ barf' should most probably be `(foo x . bar y z w . bleh t) barf',`(foo x . bar y z w) (bleh t barf)', or, if you insist, `foo x . bar y z w . bleh t $ barf' or `foo x . bar y z w $ bleh t barf'
10:11:39 <ski> (or just simply a plain honest `foo x (bar y z w (bleh t barf))', of course. brackets are nothing to be afraid of. it's when you get bracketted expressions that span multiple (many ?) lines, possibly ending with many closing brackets next to each other, that you might want to look for a nicer reformulation)
10:12:53 <mastarija> Can anyone explain a bit how aeson parses Value type into some generic value a? I've been playing with generics creating a simple "Opaque" type, and encoding some generic value to Opaque was easy, however my brain is stuck on the reverse process.
10:12:57 <mastarija> https://github.com/mastarija/opaque/blob/dev/lib/Data/Opaque.hs
10:13:12 <mastarija> I can't even begin thinking about how to do it.
10:13:37 <mastarija> I tried looking at aeson, but it's a bit too complex for me to grasp :/
10:13:52 <monochrom> For best mental model, do not think in terms of $, even if you read it and write it all the time. Think in terms of "f (g x)", then consider "f $ g x" syntax sugar.
10:14:19 <koz_> mastarija: Do you want an intro to how Generic works in general?
10:14:23 <koz_> Or specifically how Aeson uses it?
10:14:37 <mastarija> I understand generics, in general
10:14:40 <monochrom> Always have an abstract syntax tree deep down in your heart. Then you won't be confused by quirky character-based syntax.
10:14:47 <benjamin-l> monochrom: yeah, that's pretty much what my mental model is. the $ is just something that lets me write less parens
10:15:06 <mastarija> koz_, but what I don't get is how aeson constructs a parser for a generic value
10:15:16 <monochrom> Ah OK, cool, you already know.
10:16:01 <koz_> mastarija: A Rep can be thought of as a 'skeleton', expressed as sums, products, and 'leaves'.
10:16:16 <koz_> Aeson has instances for each 'leaf', because they're simple (relatively) to parse.
10:16:16 <monochrom> But perhaps we can call $ syntax dollar, syntax money, monopoly money.
10:16:43 <koz_> Then, if you can parse a and b, you can parse their sum (try one, then the other), and their product (do one, if it works, do the other, glue em together).
10:16:47 <koz_> That's more-or-less it.
10:17:12 <ski> benjamin-l : anyway, the point in favor of `(f . g . h . i) x' (or `f . g . h . i $ x') over `f $ g $ h $ i $ x' is that in the former, `.' is associative, which means that you can factor out, "fold", any subsequence of the composition chain / "pipe" into its own (named) function. (and obviously the reverse as well, "unfolding" a definition that is a composition back into the chain it's used in)
10:19:02 * ski guesses it's too much to hope for, for `$' to be changed to left-associative ..
10:19:11 <mastarija> koz_, I mean, I don't know where to begin if I want to generate Rep from my Opaque data structure. My idea was to do something like Opaque -> Maybe Rep a, but I don't know how to construct rep.
10:19:23 <koz_> You don't. You derive Generic and it happens for you.
10:19:33 <ski> (point being to discourage / prevent people from writing `f $ g $ h $ i $ x' in the first place)
10:19:37 <koz_> Hand-building Reps isn't something you should be doing unless you know _exactly_ what you're doing.
10:19:50 <koz_> The fact you're asking these kinds of questions suggests that you don't, and that's OK.
10:20:32 <mastarija> koz_, I think there's a misunderstanding 
10:21:09 <mastarija> With a concrete value Generic a => a I can get Rep and construct Opaque / Val from it 
10:21:27 <mastarija> But if I only have a type of a, how do I construct Rep a from Opaque?
10:21:44 <mastarija> So I can convert it to actual "a"
10:22:13 <koz_> That depends on what Opaque looks like. If you can go from a -> Rep a -> Opaque, surely you can go the other way by just... doing the same thing in reverse?
10:22:15 <geekosaur> koaz_, if I understood their original question properly, they're trying to learn exactly how to hand-build it
10:22:58 <geekosaur> trying to understand how aeson does it
10:23:00 <koz_> I guess I don't understand the ultimate goal here.
10:23:13 <geekosaur> understand how aeson works?
10:23:15 <koz_> Oh well, someone who knows Generics better than me can probably field this one then.
10:23:44 <mastarija> Goal is to implement Generics a => a -> Opaque and Generics a => Opaque -> a
10:23:57 <mastarija> I implemented first one, but second one is giving me trouble
10:24:02 <geekosaur> anyway, mastarija, this is deepish wizardry
10:24:22 <monochrom> Sorry, what is the definition of Opague again?
10:24:37 <mastarija> Because I don't have actual Rep a tree to work on, I only have a type of a, so I don't know how to map Opaque to A
10:24:42 <mastarija> Just a sec
10:24:45 <mastarija> https://github.com/mastarija/opaque/blob/dev/lib/Data/Opaque.hs
10:24:49 <geekosaur> so it's not surprising it's giving you trouble. I have some idea of how I'd do it but would be hesitant to do so when I know aeson can work with a derived Generic instance and do it for me :)
10:25:33 <mastarija> But I mean, I see aeson instances for building parser, but I understand nothing there :D
10:26:10 <geekosaur> generics in haskell are a fairly advanced technique, yes
10:26:19 <mastarija> geekosaur, basically I'm trying to implement mini aeson
10:26:45 <geekosaur> yes,, that was what I told koz_ more or less
10:26:50 <mastarija> and am wondering how to construct machinery to do Generics a -> Value -> Maybe a
10:27:04 <monochrom> Ah, you are learning how Aeson does "instance Generic t => From/ToJSON t" because you're coding up the same thing.
10:27:12 <mastarija> Yes
10:28:02 <mastarija> monochrom, I figured out ToJSON, but FromJSON is giving me trouble
10:28:25 <geekosaur> basically, Generics gives you a data structure representing the structure of a type. you enumerate that to find out what fields to look for and how to combine them
10:29:18 <monochrom> Aeson decides to use a record with an extra tag field for sum types. If you have "data X = C1 Int | C2 String deriving Generic", Aeson will convert C1 10 to {tag="C1", field=10}, C2 "hello" to {tag="C2", field="hello"}, or a variation of that, I forgot the details.
10:30:24 <monochrom> For FromJSON, or generally writing your own "instance Generic t => Read t", what I did is add a Proxy type.
10:31:55 <mastarija> geekosaur, I did similar thing with tags and fields for sums
10:32:57 <mastarija> geekosaur, so what's this Proxy type for?
10:33:07 <geekosaur> that was monochrom
10:34:28 <mastarija> sorry :D
10:37:12 <monochrom> mastarija: https://paste.tomsmeding.com/o66Pqbiu
10:37:59 <monochrom> Basically I pulled it off with the line "conName (M1 Proxy :: C1 c Proxy ())" when I need to know which constructor name string to expect
10:38:02 <mastarija> monochrom, thanks! I'll study that
10:38:24 <monochrom> where the type variable "c" is obtained from the context and ScopedTypeVariables
10:38:50 <mastarija> monochrom, that was actually my main concern, I couldn't figure out how to get stuff form just the type
10:39:00 <monochrom> :)
10:39:17 <mastarija> many thanks :D
11:08:51 <Sonolin> oh I found out you can grep for '.dll' in exe to find needed dlls... for my sdl2 haskell app it just needed the relevant SDL2 dll files... nice!
11:09:19 <Sonolin> I wish I could statically link SDL2 into the app (I know this is possible since there is a libSDL.a file from mingw) but that should suffice
11:10:51 <hpc> apparently there's a dumpbin command that can give you that info as well
11:10:55 <hpc> it's basically windows ldd
11:15:48 <itai33[m]> tomsmeding: for my perpouses i can invoke all of the "automatic" stuff by hand with explicit update functions rather than say, lens setters or something (after that point the effort saved is rather small). I'm mainly interested at this point in the theoretical stuff
11:16:48 <tomsmeding> ah makes sense! In that case, by all means look into FRP I think :p
11:17:38 <tomsmeding> I'd probably just write helper functions to write to the struct that also update the other necessary fields
11:18:46 <itai33[m]> yeah i'll probably do this as well and perhaps change it into something fancier later on
11:19:12 <itai33[m]> although i think that adaptive functional programing might be a better fit here, FRP might be "too powerful tm"
11:19:25 <itai33[m]> also someone needs to update the adaptive library it looks useful
11:19:28 <itai33[m]> (that someone being me(
11:33:25 <Sonolin> one things FRP really helped me zone in on was having functions of "State -> State" rather than doing everything in state monad
11:34:05 <Sonolin> then you can do like `getInput :: Event` and then pass it off to something like `consume :: Event -> Env -> Env`
11:36:55 <itai33[m]> Sonolin: what did you use for FRP?
11:37:58 <Sonolin> itai33[m] I tried out reactive-banana but ended up not using it since I wasn't really doing any realtime stuff.. the combinators seem really powerful & cool for that stuff though
11:40:35 <Sonolin> fyi if you're using stack it seems to install out of the box with `lts-14.27` - the newer lts ran into some versioning issues with the latest reactive-banana from hackage
11:41:25 <itai33[m]> thanks but i'm using cabal
11:43:59 <plakband> I'm having a hard time properly tricking the CPP into substuting a string, i.e. turning the flag -DPATH=foo into a substitution PATH -> "foo". It seems that quotes break the CPP in all sorts of ways. Can anybody give me some pointers, ideally an example of where this works?
11:45:01 <geekosaur> -DPATH='"foo"' from the shell, otherwise the shell itself eats one layer of quoting
11:49:07 <geekosaur> unfortunately, last time I checked (cabal-install 2.x) there was no reliable quoting within cabal files
11:49:28 <geekosaur> quoting is fairly tricky in general
11:51:27 <plakband> So it seems... I tried the '"foo"' thing, if you're saying that /should/ work, it might be the case that the quotes get lost somewhere down the line in the rest of the build process
11:56:39 <plakband> alright, turns out it was... '"\"foo"\"'
11:56:53 <geekosaur> ew.
11:56:59 <plakband> oh I mean '"\"foo\""'
11:57:03 <plakband> of course
12:02:54 <sm[m]> Sonolin: maybe hacky but another option: you can embed binary files into your executable (file-embed) and unpack them into current directory or \windows at startup
12:06:34 <Sonolin> interesting idea, but I think I'd rather just go with the zip
12:07:04 <Sonolin> I'm still trying to find the paths in appveyor to these DLLs but I think I finally found them... C:\Users\appveyor\AppData\Local\Programs\stack\x86_64-windows\*\mingw64\lib\*.dll
12:09:18 <sm[m]> you may know it, but github actions also works well for building windows binaries
12:13:46 <Sonolin> oh I didn't know that... good to know
12:23:34 <nango``> :w 
12:56:53 * hackage readme-lhs 0.8.1 - Literate programming support.  https://hackage.haskell.org/package/readme-lhs-0.8.1 (tonyday567)
13:00:09 <monochrom> I hate quoting and escape codes.
13:04:48 <maerwald> tell us what you like instead :P
13:05:39 <merijn> Cats are pretty good :p
13:06:25 <maerwald> started using bat though: https://github.com/sharkdp/bat
13:07:18 <ski_> the escaping character ought not to be escaped in terms of itself
13:07:56 <merijn> maerwald: That's gonna give the cat -v guys an aneurysm...
13:09:11 <maerwald> hope their insurance covers that
13:09:28 <aldum> lol, bat is good stuff tho
13:09:36 <merijn> UNIX was made in the US, so...probably not :p
13:27:00 <ambidextrose> what's the command to cabal install dependencies from within a repository. so for example, it looks at the cabal file in a project and locally downloads all dependencies listed
13:46:43 <androzanimedium> Hello, I have a usage question about the ixset/ixset-typed package, is this the right channel or should I go to #happs?
13:49:05 <maerwald> can
13:52:23 * hackage box-socket 0.1.2 - Box websockets  https://hackage.haskell.org/package/box-socket-0.1.2 (tonyday567)
15:05:23 * hackage nuha 0.3.0.0 - Multidimensional arrays, Linear algebra, Numerical analysis  https://hackage.haskell.org/package/nuha-0.3.0.0 (jodak)
15:17:52 * hackage hocon 0.1.0.2 - Small library for typesafe's configuration specification  https://hackage.haskell.org/package/hocon-0.1.0.2 (aleperaltabazas)
15:22:23 * hackage web-rep 0.7.2 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.7.2 (tonyday567)
16:48:52 * hackage rrule 0.1.1 - Recurrence rule parser and formatter  https://hackage.haskell.org/package/rrule-0.1.1 (MitchellVitez)
18:00:52 * hackage rollbar-client 0.1.0 - Core library to communicate with Rollbar API.  https://hackage.haskell.org/package/rollbar-client-0.1.0 (sestrella)
18:01:53 * hackage rollbar-cli 0.1.0, rollbar-yesod 0.1.0, rollbar-wai 0.1.0 (sestrella): https://qbin.io/stop-wy-dowu
18:37:10 <dsal> Wow, more people want LambdaCase than OverloadedStrings?
18:38:15 <yushyin> I don't, I want MultiWayLambda :D
18:55:08 <gentauro> dsal: I want `SafeHaskell` :D
18:55:11 <ryantrinkle> dsal, yushyin: how about OverloadedLambda ;)
18:55:14 <gentauro> I hope it gets in :P
18:55:43 * gentauro it would probably break 99% of all packages in Haskell xD
18:56:59 <dolio> Gets in what?
18:57:52 <yushyin> GHC202X
18:58:27 <dolio> Well, then it wouldn't break any packages, because 0% of them are using GHC202X.
18:58:41 <yushyin> :)
19:00:27 <yushyin> https://github.com/ghc-proposals/ghc-proposals/blob/ghc2021/proposals/0000-ghc2021.rst there it is
19:00:54 <dolio> LambdaCase is way more obvious to add to that than OverloadedStrings, too, because there are few downsides if you just don't use lambda cases.
19:01:08 <dolio> Whereas overloaded strings can require you to annotate your strings in some cases.
19:01:43 <dolio> So the latter could end up being a nuisance when on by default.
19:03:09 <dsal> -XDangerHaskell
19:03:24 <ryantrinkle> awwwww: > "asdf"@Text
19:03:24 <ryantrinkle> <interactive>:8:1: error: Cannot apply expression of type ‘p0’ to a visible type argument ‘Text’
19:03:30 <ryantrinkle> sad that syntax doesn't work
19:04:25 <ryantrinkle> (i was hoping it'd function like :: but binding as tightly as posible instead of as loosely as possible)
19:07:05 <yushyin> id @Text "asdf"
19:07:09 <yushyin> :D
19:12:14 <ryantrinkle> yushyin: nice :)
19:17:23 <dolio> Need to get augustss' (::Text) thing.
19:20:45 <gentauro> everytime I see GHC202X I'm remember this tweet -> https://twitter.com/edwinbrady/status/1163816732902883329
19:20:48 <gentauro> xD
19:24:04 * monochrom prefers: OverlordLambda
19:24:36 <monochrom> Like, OverlordStrings? Puff :)
19:25:21 <dolio> Is that what TCL has?
19:46:31 <gentauro> why can't both OverlordLambda and OverlordStrings be added?
19:46:40 <gentauro> I mean, they aren't mutual exclusive …
19:49:03 <koz_> {-# LANGUAGE OverloadAllOfTheThings #-}
19:55:35 <gentauro> I'm still guessing when GHC202X would be usefull
19:55:42 <gentauro> I can't find a scenario xD
19:58:20 <pavonia> Is OverlordLambda the final boss of a Haskell video game?
19:58:25 <ryantrinkle> gentauro: well, the hard part about OverloadedLambda is that it doesn't exist (yet/afaik) http://conal.net/blog/posts/overloading-lambda
19:59:22 <ryantrinkle> implemented here: https://github.com/conal/concat
19:59:33 <ryantrinkle> i haven't looked at how well it works lately, though
19:59:38 <gentauro> ryantrinkle: so it's a M$ thing? It only exists in a PowerPoint until customers buy it? :o
19:59:51 <ryantrinkle> hahahaha lazy software development ;)
20:01:16 <gentauro> more like `Snake oil` sales gimic ;)
20:02:49 <ryantrinkle> yeah i guess it doesn't count as lazy evaluation if the thing you ultimately deliver is still wrong
20:03:20 <gentauro> or just doesn't exist xD
20:03:57 <gentauro> if Haskell ever becomes that popular that all the `douchy` M$ employees will move over. Just imagine that?
20:04:00 <gentauro> :|
20:31:04 <monochrom> dolio: Yeah, I thought of tcl too :)
20:31:28 <monochrom> pavonia: Lambda the Ultimate Level Boss by Guy Steele or something :)
20:33:40 <monochrom> Actually if you Google for "lambda the ultimate imperator" you'll get very good results :)
20:46:45 <ezzieyguywuf> how do I add a package to ghci? i.e. cassava so that I can import Data.Csv
20:59:17 <glguy> ezzieyguywuf, either add it to your packages' .cabal file and 'cabal repl' or for a standalone repl do: 'cabal repl --build-dep casava'
20:59:34 <glguy> cabal repl --build-dep cassava 8
20:59:49 <glguy> (two "s"s)
21:01:16 <gentauro> ok. this website is nicely done. I wish I had UI/UX skills :( https://www.srid.ca/
21:09:43 <ezzieyguywuf> glguy: thanks!
21:17:24 <ezzieyguywuf> in the cassava documentation, "data Person = Person { name :: !Text , salary :: !Int }", what do the exclamation marks mean? "strict"? if so, is it necessary to make thing strict in order for cassava to work?
21:19:37 <jle`> ezzieyguywuf: it's a strictness annotation yeah, and cassava shouldn't require them i believe
21:19:45 <ezzieyguywuf> jle`: ok thank you.
21:30:41 <ezzieyguywuf> how is this a syntax error? "data SecuData = SecuData { TransactionDate :: Text }
21:30:44 <ezzieyguywuf> "
21:30:53 <ezzieyguywuf> the compiler says there is a parse error on TransactionDate
21:31:08 <ezzieyguywuf> oh, b/c uppercase
23:04:47 <vfaronov> any idea why Cabal might not be stripping installed executables? i.e. running `strip` manually reduces their size
23:04:59 <vfaronov> explicit `executable-stripping: True` in cabal.project doesn't seem to help
