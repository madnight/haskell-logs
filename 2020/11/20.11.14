00:21:49 <dsal> I got this far tonight:  Cofree is a functor from the category of functors to the category of comonads that is right adjoint to the forgetful functor from the category of comonads to the category of functors that forgets how to extract and duplicate, leaving you with only a Functor.
01:21:23 * hackage jalaali 1.0.0.0 - Jalaali calendar systems  https://hackage.haskell.org/package/jalaali-1.0.0.0 (behrang)
02:46:21 <kuribas> if I return (pure foo :: IO Foo), does foo get evaluated to WHNF?
02:46:51 <merijn> That does nothing to foo
02:48:21 <kuribas> if I have "withFile fp mode $ \h -> foo", how do I ensure the result of foo is in WHNF
02:48:22 <kuribas> ?
02:49:13 <maerwald> why do you care?
02:49:19 <merijn> eh, with lots of pain and effort
02:49:27 <merijn> Allow me to recommen a better solution
02:49:34 <merijn> Don't use lazy IO so it doesn't matter
02:49:57 <kuribas> well it will work if the argument is in WHNF
02:50:07 * SweetAmy19 19/f looking for older. This is me naked: https://imagetwist.com/c60gumtcigj7/nude5.jpg Do you like my pussy?
02:50:27 <merijn> It's that time of year where freenode gets spammed again?
02:50:45 <maerwald> Christmas is a lonely time
02:51:32 <hc> kuribas: could you give a bit more context? what are you trying to do?
02:51:46 <kuribas> hc: I am writing an xml parser on top of hexpat
02:52:52 <merijn> Just read the entire file strictly, presumably any (sane) XML file will be a few MB max anyway
02:53:06 * SweetAmy19 19/f looking for older. This is me naked: https://imagetwist.com/c60gumtcigj7/nude5.jpg Do you like my pussy?
02:53:31 <merijn> @where ops
02:53:31 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
02:53:35 <kuribas> merijn: well, it's supposed to be a "streaming parser".
02:53:54 <SweetAmy19> 19/f looking for older. This is me naked: https://imagetwist.com/c60gumtcigj7/nude5.jpg Do you like my pussy?
02:53:57 <merijn> kuribas: Well, there's a reason conduit & co were invented
02:54:12 <kuribas> merijn: conduit will be supported as well :)
02:58:07 <kuribas> merijn: what about pure $! foo ?
02:59:52 <kuribas> that should first evaluate foo no WHNF, then return it from the IO action.
03:01:16 <kuribas> merijn: it can be still handy to parse a huge file in constant space.  I know LazyIO is quick and dirty, but sometimes that's all you need :)
03:02:37 <kuribas> that seems to work: pure undefined >> pure 3 => 3
03:02:37 <kuribas>  
03:02:46 <kuribas> (pure $! undefined) >> pure 3 => *** Exception: Prelude.undefined
03:08:52 <kuribas> merijn: note that my function is safe, because to ensure that the xml contains no errors it has to read the whole file.  Well at least the portion that needs to be parsed.
03:09:14 <kuribas> merijn: so evaluating to WHNF will ensure a complete read.
03:26:16 <HaskellYogi> Hello all, I am unable to use the if statement given in the code here. https://pastebin.com/BvTCXhLr Can someone suggest an alternative
03:26:56 <kuribas> HaskellYogi: what's the value of total when flag is False?
03:27:29 <kuribas> HaskellYogi: you need to invert it: let total |flag = ... | otherwise = ...
03:28:11 <kuribas> and modVal is indented wrong
03:28:13 <HaskellYogi> when false is false I want  total = (modChr char) - (getKeyToInt key ) when true  total = (modChr char) + (getKeyToInt key )
03:29:02 <HaskellYogi> @kuribas  modval is part of let statement
03:29:02 <lambdabot> Unknown command, try @list
03:29:55 <kuribas> so let total | flag = (modChr char) + ... | otherwise = (modChr char) - ...
03:30:13 <kuribas> HaskellYogi: and put modVal on the same column as total
03:30:40 <HaskellYogi> okay let me invert and see
03:30:48 <kuribas> HaskellYogi: alternatively let total = if flag then ... else ...
03:30:56 <kuribas> but I prefer guards
03:32:25 <kuribas> HaskellYogi: or a third way: total = (if flag then (+) else (-)) (modCHar char) (getKeyToInt key)
03:32:52 <kuribas> wether that's clearer is debatable
03:33:30 <HaskellYogi> Thanks a ton this works https://pastebin.com/dBj3F4m1 I learned something new today
03:34:33 <kuribas> HaskellYogi: indentation is a bit weird, but that should work
03:35:20 <HaskellYogi> why do you say @kuribas, can you please show me the right way, so that I can improve
03:37:09 <kuribas> there is not a "right way", but I prefer this: https://gist.github.com/kuribas/a5226405be7c9209bc1978236b93b660
03:37:09 <HaskellYogi> modval and total are in the same column
03:37:22 <kuribas> where is a bit more idiomatic IMO
03:37:58 <merijn> I would say that most (like, 90%) people only use let when they absolutely have to because "where" can't work
03:38:23 <merijn> Properly indenting let always becomes an ugly mess
03:38:54 <HaskellYogi> Ok got it, so where would have done, makes sense. 
03:39:19 <kuribas> let is more lispy, or ocamly...
03:39:47 <merijn> Also, note that the parenthesis are redundant
03:40:18 <merijn> function application *always* binds tighter than operators do, so "(modChr char) + (getKeyToInt key )" is the same as "modChr char + getKeyToInt key"
03:40:31 <HaskellYogi> Thanks @kuribas and @merijn will take care in future
03:41:20 <HaskellYogi> I just use that, cause I read some where that it makes the intent clear to someone reading your code
03:42:02 <merijn> HaskellYogi: In cases where it's ambiguous (like mixing many operators) then it can be useful, yes
03:42:45 <merijn> But since function application always wins from operators it's best to just get used to that quickly :)
03:44:17 <kuribas> I never know which of (>>=), (<$>), (<*>), binds more tightly
03:44:33 <kuribas> so there parens are more clear.
03:51:21 <Feuermagier> how do I find the (integer in a list) closest to a (target integer) elegantly?
03:52:29 <merijn> Feuermagier: Do you care about it staying a list?
03:52:35 <Feuermagier> nope
03:53:19 <Feuermagier> i guess i can just brute force elements out of it and compare each time, then pass the so-far-best through recursively through
03:53:33 <merijn> Feuermagier: Put it into a Set and use lookupLE and lookupGE? :)
03:53:48 <merijn> Feuermagier: https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Set.html#v:lookupLE
03:54:08 <merijn> Then it becomes a matter of checking which of those 2 items has the smallest difference from your target
03:54:23 * hackage uusi 0.2.0.0 - Tweak dependencies in .cabal files  https://hackage.haskell.org/package/uusi-0.2.0.0 (berberman)
03:57:34 <Feuermagier> merijn, very interesting - thx!
04:02:36 <kuribas> :i <$!>
04:03:06 <kuribas> no strict fmap?
04:05:53 <merijn> Feuermagier: That's O(log n) complexity too! (well, there's an initial O(n log n) for creating the set, but afterwards all queries are O(log n))
04:07:33 <Feuermagier> merijn, nice! - however i'm still unsure if haskell can actually be a productive language :)
04:08:37 <merijn> Whether it *can* be productive isn't really up for debate, since many people are productive in it :p The question is more whether *you* can be productive in Haskell :)
04:08:40 <kuribas> Feuermagier: it can be!  If it will be for you depends on how eager you are to learn, and if the language suits you well.
04:09:53 <kuribas> IMO in the beginning you are less productive than in other language,  but after some threshold you become more productive.
04:11:41 <Feuermagier> merijn, thats a good point. choosing the right tool for the job i guess. right now i'm still in the learning phase. i hope to take concepts away for my other languages (like rust, which shares the majority of its functional part with haskell)
04:12:27 <merijn> I'm...not sure I agree with Rust sharing the majority :p
04:14:18 <int-e> merijn: majority(functional_part(rust)) subset Haskell
04:14:23 <int-e> is how I'd parse it
04:14:27 <Lycurgus> Feuermagier, you wholly misappraised haskell, it's far and away the premier functional language in this time in the strict sense
04:14:49 <merijn> Unrelatedly
04:15:04 <Lycurgus> you really shouldn't compare it to other langs since it's something of sui generis
04:15:39 <merijn> A few weeks ago there was a post on /r/haskell for exhaustive conversions between two types, but I forgot the name/URL. Anyone remember?
04:16:04 <merijn> Lycurgus: I disagree, there's a ton of languages you can easily compare Haskell with
04:16:40 <merijn> SML, Miranda, Clean, Lazy ML...
04:17:01 <Lycurgus> merijn, i didn say you couldn't I said you shouldn't
04:17:06 <merijn> It's not like Haskell was invented in a vacuum. Like a solid 2/3rd of the report are just straight up copied from other languages
04:17:49 <merijn> Let's not go put Haskell on a pedestal as some unique divine deliverance on programming >.>
04:18:33 <Lycurgus> nothing comes close in that set to the qualities of haskell in term of acceptance and development of a practical ecosystem, ocaml and the others in a second tier
04:18:53 <Lycurgus> *terms
04:19:17 <Feuermagier> right now I just can't identify that target "group of projects" I'd choose haskell for. But maybe I'll see that once I know it better. 
04:19:38 <Lycurgus> but to Feuermagier's point, the time to become acculturated to the lang and that ecosys maybe prohibitive in some cases
04:19:50 <solonarv> heh, that's the situation I'm in regarding rust (and is why I have yet to properly learn it)
04:19:52 <Lycurgus> *may be
04:21:22 <merijn> Feuermagier: tbh, personally I'd choose Haskell for "everything that's not realtime/games/GUI" :p
04:21:48 <arahael> merijn: That makes me sad!  Why not GUI?
04:21:57 <merijn> If I ever embarked on one of those categories I'd probably consider Rust
04:22:11 <merijn> arahael: So far none of the GUI things I've seen seem worth the hassle
04:22:12 <arahael> merijn: I mean, I haven't found a way to use Haskell well for GUI, but I'm still figuring this out.
04:22:16 <arahael> merijn: Yeah, same. :(
04:22:22 <arahael> merijn: But _why_. ;)
04:22:32 <Uniaika> never forget: https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/dcsgk7n/
04:22:47 <merijn> I don't think nice Haskell gui stuff is impossible, it's just not been done yet
04:22:56 <merijn> And I don't wanna be the one that does it :p
04:23:05 * Lycurgus 's spin https://eg.meansofproduction.biz/eg/index.php/Troika
04:23:06 <merijn> I'd rather writing a GUI in something simpler and then call Haskell from that :p
04:24:02 <arahael> merijn: "simpler".  Honestly, I suspect that GUi should be done in "whatever" the native framework proposes, for various reasons.
04:25:27 <merijn> Anyway, back to solving *my* problems. I've got a bijection between my type and string/text, are there existing things for nicely encoding that, or should I hack something together using my own Map/typeclass?
04:26:01 <Lycurgus> i'd be surprised if there wasn't 
04:26:21 <merijn> So would I, but the only stuff I've found has ugly TH death machines
04:26:26 <merijn> I was hoping something fairly lightweight
04:26:38 <Lycurgus> ur scared of th?
04:26:52 <merijn> No, but it slows down my built and is unnecessary
04:27:22 <Lycurgus> i c
04:27:56 <Feuermagier> merijn, the rust and the haskell compiler are equally aggeressive regarding types. (however since rust has no garbage collection the compiler will force you to RAII, whereas in haskell you don't have to worry about it)
04:29:11 <merijn> Feuermagier: For 95% of programs (possibly more...) GC isn't something to worry about it
04:30:00 <merijn> I like Rust (conceptually, at least), but *in practice* the overhead of GC isn't a problem for stuff I write, therefore ownership and RAII does nothing but "make life more complicated" for no good reason
04:30:22 <Feuermagier> merijn, whats the state of haskell on multithreading?
04:30:30 <merijn> Easy-peasy
04:31:06 <Feuermagier> merijn, i assume races are impossible cause functional?
04:31:53 <merijn> Since everything is immutable by default you can't have races unless you "opt-in" to them
04:32:15 <merijn> Feuermagier: There's a bunch of different mutable types you can use in concurrent code, some of which are racy
04:32:27 <merijn> But then you need to decide to explicitly include those racy types in your code
04:32:37 <merijn> (IORef is one example that's racy)
04:33:02 <merijn> And of course GHC has the best (only real?) software transactional memory implementation
04:33:03 <Feuermagier> interesing. but I gess i'm not at that stage yet. maybe in a few weeks
04:33:18 <Feuermagier> merijn, what is that?
04:34:28 <merijn> Feuermagier: Basically you get shared mutable variables with the ability to make atomic updates to them (like, not atomic on the invididual variable, but "this entire set of operations on multiple variables happens atomically")
04:34:36 <Ariakenom> i agree. haskell's concurrency is great
04:36:14 <merijn> Feuermagier: You should browse through the modules under Control.Concurrent in base: https://hackage.haskell.org/package/base-4.14.0.0 and the STM package: https://hackage.haskell.org/package/stm
04:36:30 <Feuermagier> thx!
04:36:32 <merijn> Feuermagier: The STM package should also have a link to the paper that explains it in detail
04:37:10 <merijn> Oh, and maybe stuff like
04:37:13 <merijn> @hackage async
04:37:13 <lambdabot> https://hackage.haskell.org/package/async
04:37:15 <Feuermagier> the more you guys explain the workings of this language, the more i like it :)
04:37:59 <int-e> . o O ( it's a trap! )
04:38:43 <Ariakenom> "Parallel and Concurrent Programming in Haskell" is great. im not sure if you can just jump into the chapter on stm but I will link it
04:38:44 <Ariakenom> https://web.archive.org/web/20171114084950/http://chimera.labs.oreilly.com/books/1230000000929/ch10.html
04:40:05 <Ariakenom> looks like its mostly readable on its own
04:40:23 <littleEngine> hey.. are there any ideas in the community about functional machine learning
04:41:49 <littleEngine> i dont mean deep learning in haskell but more like genetically searching for some pure function
04:42:06 <merijn> bah...keeping my parser and pretty printer in sync feels like a solved problem, but I can't seem to figure out how to encode it
04:43:29 <Ariakenom> there's some on inferring a value (ex function) from its type. in contrast to inferring a type from a value like we do currently 
04:45:01 <littleEngine> hmm.. seems impossible without some extra information on the function
04:45:17 <Ariakenom> forall a. a -> a
04:45:47 <littleEngine> id
04:45:55 <merijn> littleEngine: That sorta stuff is generally done on the AST level
04:47:24 <merijn> hmm...there's no real way to talk about constructors in a first class way, is there?
04:47:25 <Ariakenom> didnt we have a bot that does this?
04:47:39 <merijn> @free a -> a
04:47:39 <lambdabot> Extra stuff at end of line
04:47:43 <merijn> hmm
04:47:56 <merijn> wrong command maybe
04:48:45 <Ariakenom> I found a link https://www.hedonisticlearning.com/djinn/
04:50:11 <merijn> @djinn a -> a
04:50:11 <lambdabot> f a = a
04:50:23 <merijn> @djinn (a -> b) -> [a] -> [b]
04:50:23 <lambdabot> Error: Undefined type []
04:50:27 <merijn> bleh
04:51:38 <littleEngine> im trying to make a learner for musical instruments where an instrumet is a composition of a deformation, an instrument_logic , and a Listen function
04:52:27 <littleEngine> Deform :: Player_state x Instrument_state --> instrument_state
04:52:57 <littleEngine> Instrument_logic :: Instrument_state -> Instrument_State
04:53:25 <littleEngine> Listen :: InstrumentState -> Audio_chunk
04:54:28 <Feuermagier> how do i set a double to infinite?
04:54:49 <merijn> Same way as every language with IEEE-754
04:54:54 <merijn> > 1/0 :: Double
04:54:56 <lambdabot>  Infinity
04:55:20 <Feuermagier> well, yes, but usually there's a static variable like "MAX_INTEGER"
04:55:24 <merijn> > -1/0 :: Double
04:55:26 <lambdabot>  -Infinity
04:55:53 <ski> > maxBound :: Int
04:55:55 <lambdabot>  9223372036854775807
04:56:01 <merijn> There isn't one, currently. I usually just do "infty :: Double; infty = 1/0" in my code
04:56:06 <merijn> ski: That doesn't work for Double
04:56:09 <ski> yes
04:56:12 <merijn> > maxBound :: Double
04:56:14 <lambdabot>  error:
04:56:14 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘maxBound’
04:56:14 <lambdabot>      • In the expression: maxBound :: Double
04:56:15 <carter> merijn: did you message me on ci ?
04:56:21 <merijn> carter: Yeah
04:56:29 <carter> Which channel?
04:56:43 <merijn> carter: Or rather, I replied on twitter
04:57:03 <carter> Derp
04:57:08 <merijn> but it was basically "no, this doesn't exist yet" :p
04:57:10 <Ariakenom> note that the conversions like realToFrac are broken on inf 
04:57:30 <merijn> Ariakenom: Well, what could they possibly sensibly be?
04:57:54 <Ariakenom> fair. more broken than necessary. they should error
04:58:03 <carter> There’s some changes to fractional I need to flesh out
04:58:20 <merijn> ugh...why does dispatching on constructors gotta be impossible >.>
04:58:46 <merijn> I'm gonna go make my own language! With first class constructors/patterns and booze. In fact, forget the language!
04:59:29 <int-e> merijn: how do you even type that
04:59:53 <merijn> int-e: You "just" need a type level way of indicating constructor of a type X
05:00:15 <carter> merijn: what’s the thing g you wanna do ?
05:00:52 <carter> merijn: btw it seems like Travis ci is slow rolling oss repos and gh actions is way more reponsivr ?
05:00:53 <int-e> merijn: and how do you use the constructor in the end? aren't you in the variadic function business now?
05:01:02 <merijn> carter: link a parser and pretty printer together sensibly. But my type has constructors with differing arguments. You'd wanna do something like "Constructor X -> Parser X"
05:01:03 <carter> Dependent types ?
05:01:17 <merijn> But that doesn't work if your constructors have differing types
05:01:31 <merijn> int-e: I don't wanna use it directly
05:01:36 <merijn> I just wanna use it to dispatch
05:01:49 <merijn> carter: Travis has been slow for ages
05:02:24 <merijn> int-e: Basically I wanna select a pretty printing/parsing strategy "per constructor", but that doesn't work if you can't talk about constructors, only compound values
05:02:31 <merijn> (but I gotta run for a sec)
05:02:50 <carter> Interesting point !
05:11:48 <int-e> carter: Travis got acquired by Idera in January 2019 and let a good number of developers go in February 2019... they're also getting rid of the free OSS plan in favour of their trial plan and possibly exceptions on a case by case basis... https://www.theregister.com/2020/11/02/travis_ci_pricng/
05:12:03 <Feuermagier> If I have datatype [(String, Int)] and do [(s, i)] on it, is "s" a list of strings then?
05:12:16 <int-e> Slow-rolling fits well into that picture.
05:12:39 <ski> no, `s' is a `String', if `[(s,i)]' has type `[(String,Int)]'
05:13:06 <Feuermagier> how do i get the list of strings out of that then?
05:13:31 <solonarv> well, there isn't exactly a list of strings "in there"
05:13:40 <solonarv> you would instead be constructing a new list
05:14:13 <ski> Feuermagier : list of strings out of what ?
05:14:34 <Feuermagier> just the strings in that tuple
05:14:38 <solonarv> assuming   xs :: [(String, Int)]  , here are some ways to do that:   map fst xs  , or:   [ s | (s, _) <- xs ]
05:14:42 <Feuermagier> *list of tuples*
05:15:05 <ski> if `[(s,i)]' has type `[(String,Int)]', then `[s]' is a list of `String's. `[]' is also a list of `String's, as is `[s,s]'
05:15:32 <siraben> Anyone playing around with Linear Haskel + Nix?
05:15:35 <siraben> Haskell*
05:15:44 <siraben> linear-base doesn't seem to be in nixpkgs yet
05:15:52 <ski> if you have some list of type `[(String,Int)]', and you want to get the list of `String's from the first component of the pairs, then what solonarv said
05:18:38 <carter> int-e: yeah I guess I need to migrate all my crap to gh actions
05:20:23 * hackage hakyll-convert 0.3.0.1 - Convert from other blog engines to Hakyll.  https://hackage.haskell.org/package/hakyll-convert-0.3.0.1 (AlexanderBatischev)
05:23:41 <merijn> carter: Sounds like you should write a GitHub Actions backend for haskell-ci, so I don't have to ;)
05:33:51 <carter> The yaml wasn’t that hard
05:36:08 <hoppfull> Hello, I'm studying mathematics in university (first year) and I'm not impressed by MATLAB. It's undoubtedly an excellent ecosystem but an ugly imperative language. Implementing algorithms in Haskell is usually a 1:1 correspondence to the mathematical equations which is impressive. I wonder if there are any good libraries that can replace MATLAB
05:36:09 <hoppfull> for an aspiring mathematician. It should have functions for working with linear optimization, differentiation and integrals and probably more stuff that I do not yet know about
05:38:38 <Axman6> Feuermagier: Since it probably clear from the explanation you got, if you have xs :: [(String, Int)] and you pattern match on xs, say like case xs of [(s,i)] -> ... then you are matching on a string with exactly one tuple of a String and an Int. if uou want to extract all the strings from xs, you can use map :: (a -> b) -> [a] -> [b] with fst :: (a,b) -> a, or in your case fst has type (String, Int) -> String. so map fst :: [(a,b)] -> [a] or 
05:38:38 <Axman6> [(String,Int)] -> [String]
05:41:14 <Axman6> hoppfull: sadly there's no large cohesesive library which does that, but we do have a lot of the pieces to do it - things like hmatrixget you a lot of the linear algebra basics, massiv too I think (I've never used it, but have used Repa which I think inspired it quite a lot). it's usually not too hard to glue the pieces together. for differentiation we have the ad (automatic differentiation) package, not sure about integration but I'm sure yo
05:41:14 <Axman6> u can find something on hackage
05:41:24 <jpds> hoppfull: I think you're looking at either R/numpy, those are what are typically used in industry
05:43:14 <hoppfull> Axman6: Alright, cool! :)  Thank you!
05:48:16 <hoppfull> jpds: Thanks for your input.
05:52:47 <hoppfull> jpds: Gave me the idea to check and see if Haskell has R-interop and it seems like there is a library for it! :)
05:56:23 * hackage update-nix-fetchgit 0.2.5 - A program to update fetchgit values in Nix expressions  https://hackage.haskell.org/package/update-nix-fetchgit-0.2.5 (jophish)
06:12:22 <kuribas> wohoo!  Just testing my xml parser library, and it seems to work the first time!
06:12:45 <kuribas> Just had to change the library to return the parse location when failing.
06:12:58 <kuribas> It seems that sometimes, "it works when it compiles", is true.
06:15:12 <kuribas> the more I do haskell, the more I think dynamic languages suck...
06:17:52 <Feuermagier> how do I go from [Int] to Map(int, amountThatIntOccuredInTheList)?
06:18:12 <Zetagon> kuribas: I'm dipping my toes in emacs-lisp, and I have to say that lisps are pretty cool :)
06:18:40 <kuribas> Zetagon: that sounds very postive, emacs-lisp is pretty much the worst lisp...
06:19:39 <kuribas> Zetagon: you should have a look at scheme instead
06:19:49 <Zetagon> Yeah, the little I have written in it have used few data structures so those pain points haven't really affected me. It's mostly very interactive stuff, but I have just discovered the nice stuff about macros
06:20:09 <Zetagon> but scheme doesn't have emacs with it :P
06:20:37 <Zetagon> But yeah I am curious about Racket, and turnstile which does some cool stuff with macros and types
06:20:38 <kuribas> very true :)
06:20:56 <kuribas> there was an effort to rewrite emacs in GUILE scheme, but it never took off.
06:21:11 <ski> @type M.fromList . map (head &&& length) . group . sort  -- Feuermagier ?
06:21:12 <lambdabot> Ord a => [a] -> M.Map a Int
06:21:34 * ski . o O ( Edwin )
06:21:53 <Feuermagier> ski, interesting
06:22:16 <Feuermagier> what does  (head &&& length) do?
06:22:29 <ski> > (head &&& length) "sssss"
06:22:31 <lambdabot>  ('s',5)
06:22:34 <Zetagon> damn that is a neat solution
06:22:37 <Feuermagier> wow
06:23:10 <Feuermagier> what do the "." do?
06:23:18 <ski> function composition
06:23:39 <ski> > (sum . map (^ 2)) [0 .. 7]
06:23:41 <lambdabot>  140
06:23:46 <ski> > sum (map (^ 2) [0 .. 7])
06:23:48 <lambdabot>  140
06:24:06 <ski> > sum (map (^ 2) [0 .. 7]) :: Expr
06:24:07 <lambdabot>  0 + 0 * 0 + 1 * 1 + 2 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7
06:24:18 <Feuermagier> why do we group and sort?
06:24:20 <kuribas> @type M.fromListWithKey (const (+)) . map (,1)
06:24:21 <lambdabot> (Ord b, Num a) => [b] -> M.Map b a
06:24:27 <ski> > group "mississippi"
06:24:29 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
06:24:33 <ski> > (group . sort) "mississippi"
06:24:35 <lambdabot>  ["iiii","m","pp","ssss"]
06:25:25 <Feuermagier> aaaah
06:26:51 <Zetagon> kuribas: emacs-lisp is far from a bad language. it has the advantage of being a lisp so a lot of things can be improved with libraries. It has borrowed a lot of functionality from common lisp for example with cl-lib. But yeah it's not the best language either
06:27:39 <kuribas> Zetagon: I find it aweful, because: no propper lexical scope, though that's fixed in later versions, no namespaces, one global interpreter thread, etc...
06:28:17 <Zetagon> Name spaces are done by prefixing the package name :P
06:28:27 * ski idly notes "aweful" used to be a positive description
06:29:03 <Zetagon> Actually it technically has two namespaces, one for functions and one for variables
06:29:35 <kuribas> ski: isn't that awesome?
06:31:08 <kuribas> ski: or do you mean like a century ago?
06:31:19 <Zetagon> wiktionary seems to agree with ski
06:31:29 <ski>   awful  [..]  2. Exceedingly great; usually applied intensively.  [..]  4. (now rare) Inspiring awe; filling with profound reverence or respect; profoundly impressive.  5. (now rare) Struck or filled with awe.  [..]  7. Worshipful; reverential; law-abiding.
06:31:43 <ski> kuribas : or more, perhaps
06:37:52 * hackage hakyll-convert 0.3.0.2 - Convert from other blog engines to Hakyll.  https://hackage.haskell.org/package/hakyll-convert-0.3.0.2 (AlexanderBatischev)
07:15:52 * hackage hexpat-streamparser 0.0.1 -   https://hackage.haskell.org/package/hexpat-streamparser-0.0.1 (KristofBastiaensen)
07:16:03 <kuribas> there you go :)
07:18:52 * hackage byte-count-reader 0.10.1.2 - Read strings describing a number of bytes like 2Kb and 0.5 MiB  https://hackage.haskell.org/package/byte-count-reader-0.10.1.2 (danielrolls)
07:22:18 <fendor> cabal does not like literate haskell files
07:22:21 <fendor> or is it ghc?
07:23:40 <kuribas> fendor: they do
07:23:47 <kuribas> fendor: did you name it .lhs?
07:24:42 <fendor> kuribas, but the error messages are not of the same quality. ghc just says:`unlit' failed in phase `Literate pre-processor'. pointing to the first line. Some lines above, you can read the actual errors
07:27:42 <fendor> but it is rather hidden, compared to the rich error messages we usually get
07:36:27 <merijn> fendor: If you like literate programming: https://entangled.github.io/ :>
07:37:39 <Zetagon> or org-mode
07:38:45 <fendor> oh wow, that looks really cool. However, I don't really care for it, but there seems to be a cabal bug related to literate haskell files and I trying to get a minimal reproducible example
07:54:21 <Feuermagier> whats the difference between $ and . ?
07:55:19 <sm[m]> check their type signatures Feuermagier
07:55:39 <Feuermagier> OH, these are FUNCTIONS, lol
07:55:45 <sm[m]> once you've used them a bit it becomes clear. & is also useful
08:26:52 * hackage stack-clean-old 0.2.1 - Clean away old stack build artefacts  https://hackage.haskell.org/package/stack-clean-old-0.2.1 (JensPetersen)
08:30:00 <maerwald_> > head . take 2 [1..] -- Feuermagier 
08:30:02 <lambdabot>  error:
08:30:02 <lambdabot>      • Couldn't match expected type ‘a -> [c]’ with actual type ‘[a0]’
08:30:02 <lambdabot>      • Possible cause: ‘take’ is applied to too many arguments
08:30:20 <maerwald_> > head $ take 2 [1..]
08:30:22 <lambdabot>  1
08:38:38 <orion> Hi. I am tasked with implementing a voting system in Haskell for a "Moose lodge". Is there any prior art in this area?
08:39:58 <orion> As an academic exercise, I am leaning towards trying to define a DSL to describe any generic voting system, but that may be a bit ambitious.
08:40:51 <Zetagon> That sounds pretty cool though, it would make it easier to compare a bunch of systems right?
08:41:00 <merijn> Zetagon: Would it, though?
08:41:39 <Zetagon> I dunno, it would at least implementing different systems easier right? I have no idea how to actually do it
08:41:49 <merijn> I don't think it would
08:42:10 <merijn> You can't even really define a generic ballot without including "basically everything"
08:42:23 <systemfault> face
08:42:30 <systemfault> oops, wrong browser.
08:44:52 * hackage polysemy-methodology-composite 0.1.4.0 - Functions for using polysemy-methodology with composite.  https://hackage.haskell.org/package/polysemy-methodology-composite-0.1.4.0 (locallycompact)
08:44:55 <orion> merijn: Hm, interesting. What do you mean by "basically everything"? Do you mean it in the spirit of the universal quantifier?
08:48:22 * hackage ormolu 0.1.4.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.1.4.0 (mrkkrp)
08:51:46 <Zetagon> I'm thinking that there are many different voting systems so it's hard/impossible to generalize over all
08:54:23 <orion> Okay, that's a more precise of saying that I intended.
08:54:29 <orion> wat of*
08:54:32 <orion> way of**
08:54:39 <carter> merijn: so many prjects need to migrate off Travis ci .
09:02:09 <hekkaidekapus> orion: There is <https://hackage.haskell.org/package/hjugement-protocol> whose maintainer hangs out in another channel. If you are interested, I can bribe him so that he joins #haskell :)
09:06:11 <orion> hekkaidekapus: Thanks! The inspiration for this idea came from this podcast: https://www.cryptography.fm/4
09:07:56 <orion> It's an interesting coincidence that the package you mentioned is based in part on research done at INRIA. The aforementioned podcast episode is also based on research done at INRIA.
09:08:05 <hekkaidekapus> orion: I have no clue in voting systems, I’m afraid listening to that podcast would be a good use of time. Let’s see if I can drag said maintainer into here.
09:08:41 <hekkaidekapus> Since it’s the weekend, he might be slow to react, let’s see.
09:09:37 <orion> hekkaidekapus: The tl;dl of the podcast is that the same formal methods used to verify the Signal and TLS protocols have been used to verify the French tax code.
09:10:01 <carter> Huh
09:10:08 <orion> If formal methods can be used to verify the French tax code, surely they can be applied to a simple Moose-lodge style voting system.
09:11:56 <hekkaidekapus> I guess, yes.
09:12:22 <hekkaidekapus> (So French are screwed; no evasion possible, huh?)
09:13:23 * hackage witch 0.0.0.0 - Convert values from one type into another.  https://hackage.haskell.org/package/witch-0.0.0.0 (fozworth)
09:13:46 <orion> While tax evasion might be eliminated, it might also allow a citizen to provably compute the lowest amount of taxes possible.
09:14:25 <hekkaidekapus> I’m kidding, don’t mind me on the subject.
09:14:49 <orion> I have my own views on the nature of taxation, but it's probably out of scope for this channel. ;)
09:15:57 <hekkaidekapus> orion: The maintainer is julm
09:16:05 <julm> hi there :)
09:16:10 <hekkaidekapus> Hi, julm!
09:19:11 <orion> Hi julm. I have a task before me that I'd like to accomplish using Haskell. I am to implement a voting system for a "Moose-like" lodge. Members get to vote on other members, but it's not a simple majority.
09:19:55 <merijn> carter: Yeah, like all of mine, which is why you should fix github actions so I don't have to ;)
09:20:59 <orion> julm: I was inspired by this podcast episode: https://www.cryptography.fm/4 -- Researchers at INRIA used formal methods to verify the French tax code. hekkaidekapus told me about hjugement-protocol, which I also see is inspired from research done at INRIA.
09:22:09 <orion> So my thinking is, if the entire French tax code can be modeled/encoded in this way, certainly a simple lodge voting system can be modeled also.
09:22:21 <merijn> :ls
09:23:32 <orion> My initial thinking is that a DSL may be appropriate. I have sought prior art in this area, and hekkaidekapus was very kind enough to point me to your package and connect us. :)
09:29:22 <Feuermagier> how do i take the symmetric difference of two lists (all entries of list b who are not also in list a)?
09:30:56 <merijn> Feuermagier: You turns them into sets and use those instead ;)
09:30:57 <hekkaidekapus> > [1 .. 10] \\ [1 ..5] -- Feuermagier
09:30:59 <lambdabot>  [6,7,8,9,10]
09:31:29 <merijn> :t (\\)
09:31:29 <Feuermagier> hekkaidekapus, so many interesting operators :D
09:31:30 <lambdabot> Eq a => [a] -> [a] -> [a]
09:31:56 <merijn> hekkaidekapus: Docs make no mention of symmetric different, though?
09:32:33 <hekkaidekapus> merijn: Nope. A principled solution is via Set as you said.
09:32:42 <julm> orion: ok, I've indeed initiated a few libraries on this topic, first https://hackage.haskell.org/package/hjugement implementing the voting method "Majority Judgment" designed by two mathematicians claiming it's the best one, and https://hackage.haskell.org/package/hjugement-protocol implementing the voting cryptographic protocol Helios-C, designed by several mathematicians and already implemented by Inria 
09:32:42 <julm> in OCaml https://www.belenios.org/
09:32:44 <merijn> > [1 .. 10] \\ [5 .. 15]
09:32:47 <lambdabot>  [1,2,3,4]
09:32:51 <merijn> That's wrong
09:33:17 <hpc> it's correct for the parenthetical part of the question
09:33:17 <merijn> @hackage containers -- Feuermagier
09:33:17 <lambdabot> https://hackage.haskell.org/package/containers -- Feuermagier
09:33:29 <merijn> hpc: Ah, right
09:34:02 <merijn> Feuermagier: If you wanna do anything other than "loop in sequence" with data, you probably want data structures from either containers or vector instead of lists :)
09:34:48 <Feuermagier> merijn, if time complexity isnt relevant i can just use the version of hekkaidekapus, right?
09:35:12 <Feuermagier> that one is rather beautiful :P
09:35:30 <merijn> Feuermagier: Depends whether you want symmetric difference (as you said) or your instructions in the parenthesis (which are left-biased difference, rather than symmetric)
09:36:05 <merijn> Feuermagier: Set has the same exact operator, though :p https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Set.html#v:-92--92-
09:36:14 <julm> orion: the description/links of the packages should help a lot to figure out how all this work, though the meta fields of those packages are not up-to-date: you'll find the latest code on https://code.sourcephile.fr/judgmentphile.git
09:36:23 <Feuermagier> merijn, since i didn't know that there's a difference, now i'm concerned
09:36:48 <merijn> Feuermagier: difference is "everything in A that is not in B"
09:36:55 <Feuermagier> yes
09:37:04 <merijn> Feuermagier: Symmetric difference is "everything in A *and* B that is not in both"
09:37:07 <Feuermagier> whats left / symmetric then?
09:37:41 <julm> julm: there you'll also find that I've initiated a CLI tool and a Purescript Web client
09:37:52 <merijn> > let symmetricDiff xs ys = (xs \\ ys) ++ (ys \\ xs) in symmetricDiff [1..10] [5 .. 15]
09:37:55 <lambdabot>  [1,2,3,4,11,12,13,14,15]
09:37:57 <hekkaidekapus> Feuermagier: left: first container; right: the second.
09:38:03 <julm> s/julm/orion/
09:38:12 <merijn> As opposed to
09:38:25 <merijn> > [1..10] \\ [5 .. 15]
09:38:29 <lambdabot>  [1,2,3,4]
09:39:43 <orion> julm: Thank you for the information!
09:40:38 <julm> orion: however I've not worked on all this in 2020, the MJ lib is quite mature, the Helios-C lib is beta, the CLI is working but would need a refresh, the Purescript only implements cryptographic functions
09:41:45 <orion> julm: This link on the hjudgement package README does not appear to be working: http://libgen.io/book/index.php?md5=BF67AA4298C1CE7633187546AA53E01D
09:42:28 <orion> This too leads to a 404: https://www.lamsade.dauphine.fr/sites/default/IMG/pdf/cahier_377.pdf
09:42:53 <Uniaika> orion: it's libgen.is nowadays
09:42:54 <julm> yeah, libgen is dead, try https://sourcephile.fr/recherches/Jugement_Majoritaire/2011_-_Balinski_et_Laraki_-_Majority%20Judgment_-_Measuring%2C_Ranking%2C_and_Electing.MIT_Press.pdf
09:42:58 <dsal> Feuermagier: it's better not to think of "a lot of operators".  They're just functions.
09:43:12 <merijn> :t difference
09:43:13 <lambdabot> error:
09:43:13 <lambdabot>     • Variable not in scope: difference
09:43:13 <lambdabot>     • Perhaps you meant one of these:
09:43:24 <merijn> aww...there's no named version for lists?
09:44:27 <dsal> Occasionally you'll want to make a function you use a lot and give it a convenient name.  If it doesn't have letters, it's infix by default, but you can apply any binary function infix or prefix.
09:44:48 <merijn> dsal: eh
09:45:01 <merijn> dsal: You can apply non-binary functions infix and/or as operator too :p
09:45:17 <dsal> > (\\) [1..10] [5..15]
09:45:19 <lambdabot>  [1,2,3,4]
09:45:34 <merijn> dsal: I mean that you can use ternary functions as operator too
09:45:45 <merijn> (or anything else, really)
09:47:26 <dsal> Some folks try to learn Haskell by learning the exceptions to rules before rules.  It's a uphill battle.  I'm just coming in from the other angle.  Operators don't exist, but there are a couple ways to call your function.
09:47:59 <merijn> operators aren't even exceptions to the rules...they're literally defined in the rules >.>
09:48:22 <merijn> An operator is just "any function whose name consists entirely of operator symbols"
09:48:40 <dsal> They're just functions is my point. Not another thing.
09:48:52 * hackage witch 0.0.0.2 - Convert values from one type into another.  https://hackage.haskell.org/package/witch-0.0.0.2 (fozworth)
09:48:58 <merijn> dsal: Except when they're constructors ;)
09:49:24 <merijn> (although, I suppose, you could argue constructors are merely a subset of functions...)
09:49:55 <dsal> Haha.  Yeah.  The more stuff that feels the same, the easier it all gets for me.
09:50:57 <dsal> I like that + isn't special.  Even in, like c++ where you can overload operators, + still feels special.
09:51:16 <merijn> operator overloading in C++ is a nightmare
09:51:39 <dsal> I've abused Num horribly, but only in lambdabot 
09:51:54 <merijn> tbf, + doesn't even have to involve Num
09:52:06 <merijn> > let 2 + 2 = 5 in 2 + 2
09:52:07 <lambdabot>  5
09:52:32 <dsal> Haha. Yeah. You just proved Haskell is a terrible language.
09:53:04 <monochrom> It's gospel to me.
09:53:27 <merijn> monochrom: Lambda calculus is gospel, Haskell is apocrypha :p
09:53:41 <dsal> Any language that doesn't let you say 2+2=5 is restricting the way you're thinking.
09:53:49 <Rembane> merijn: Why does that let-expression work? 
09:53:59 <hyperisco> that's why I prefer Ruby
09:54:10 <merijn> Rembane: It's define a new + function with a partial pattern
09:54:11 <monochrom> (+) being just another user-definable value name, therefore shadowable user-definable value name, means fewer things are second class in Haskell than in other languages.
09:54:14 <merijn> > let 2 + 2 = 5 in 2 + 3
09:54:16 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
09:54:23 * hackage flatbuffers 0.3.0.0 - Haskell implementation of the FlatBuffers protocol.  https://hackage.haskell.org/package/flatbuffers-0.3.0.0 (dcastro)
09:54:41 <merijn> Rembane: Note the non-exhaustive pattern error :)
09:55:26 <Rembane> merijn: I completely missed that error. That's really nice! :D
09:55:26 <monochrom> There is no tenable philosophical reason to insist "alphabetical identifiers are user-definable, punctuation identifiers aren't" or "prefix is, infix isn't", apart from 1970 parsing couldn't handle it.
09:55:56 <dsal> > let _ + _ = "five" in 2 + 2
09:55:58 <lambdabot>  "five"
09:57:03 <Rembane> ^^ I once saw two of my friends hacking away at something in ghci, and when one of them went to get candy or something the other one wrote let (-) = (+) in the repl and cleared the screen, hilarity ensued.
09:58:07 <monochrom> I came from an older background, seeing all kinds of privileges that the language/compiler reserves for themselves and denying the user. So I enjoy these liberations a lot.
09:59:02 <dsal> Yeah, it's crazy how many things are just for smart language creators.
09:59:03 <hpc> Rembane: i once defined microwave numbers, where the value of a number is based on how many seconds it would be if you typed those digits in a microwave
09:59:04 <julm> orion: for the second link: https://sourcephile.fr/recherches/Jugement_Majoritaire/2017-02_-_Balinski_et_Laraki_-_Majority_Judgment_vs_Majority_Rule.LAMSADE_377.pdf
09:59:12 <hpc> so 160 == 200, 199 > 200, etc
09:59:31 <monochrom> Let's start with BASIC. There, even procedure/function names are not user-definable. They give you SIN() then you have SIN(). They give you PRINT then you have PRINT. You wanna write your own version? You're stuck with GOSUB, no name, only a line number, and no parameter, no return value, no nothing.
10:00:19 <monochrom> Then let's move on to Pascal. There, functions/procedures are mostly liberated, except writeln(), you could not have defined this polymorphic procedure yourself.
10:00:42 <monochrom> It's for that reason I really admire Haskell's type class.
10:00:58 <orion> julm: Thank you.
10:02:09 <merijn> ugh
10:02:16 <merijn> Past me should've written more tests
10:03:23 <Rembane> hpc: Nice! :D That must be analogous to rotary dial numbers.
10:05:43 <monochrom> I take great pride in telling my students "in Haskell if the library didn't provide Bool, you could have defined it yourself, and it would be as optimized as the 'built-in' one".
10:05:58 <monochrom> You can't say this about a lot of other languages.
10:06:52 <monochrom> GHC takes one step further and makes even many code optimizations user-definable, i.e., rewrite rules.
10:07:32 <monochrom> Our vector library and its stream fusion, you cannot pull it off in Scala, not even close.
10:08:21 <Rembane> I like that, more power to the programmer.
10:10:06 <hekkaidekapus> As to custom rewrite rules, there is retrie which is lighter than stream fusion frameworks.
10:11:09 <monochrom> Control flow is another privilege that is liberated in Haskell and Scheme, though by different mechanisms. (laziness in haskell, macros in scheme)
10:11:46 <monochrom> Yes, in programming language topics I'm a social justice warrior.
10:11:57 <hekkaidekapus> heh
10:11:59 <Rembane> hekkaidekapus: https://hackage.haskell.org/package/retrie <- this one? 
10:11:59 <monochrom> Don't worry, on many other topics I take conservative stances.
10:12:14 <hekkaidekapus> Rembane: yep.
10:12:25 <Rembane> hekkaidekapus: Cool, thanks 
10:13:05 <monochrom> Also I'm not an extreme social justice warrior. I recognize that there are trade offs, you seek a good balance not "democratize everything".
10:13:19 <hekkaidekapus> Rembane: Not every weekend-haskeller can implement stream fusion, but with retrie one can get hands dirty with equational reasonning.
10:13:50 <Rembane> hekkaidekapus: That's really good. 
11:05:32 <scasc> I need a quick heads-up. I can't quite figure out how to use `time` library's `iso8601ParseM ( https://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Format-ISO8601.html#v:iso8601ParseM ) to read and parse a date "2020-11-14"
11:05:56 <merijn> scasc: Which part gets you stuck?
11:08:56 <scasc> According to the `class ISO8601` documentation that format corresponds to the instance `ISO8601 Day`, so a concrete tpye of the function would be `(MonadFail Maybe, ISO8601 Day) => String -> Maybe Day.
11:09:50 <scasc> However, while `Day` is defined in another module, it does not seem to be exported, so I cannot do `(iso8601ParseM "2020-01-01" ) :: Maybe Day`
11:10:28 <merijn> Eh, it is exported? I'm pretty sure I use it in my code
11:10:29 <scasc> I'm pretty sure I'm overlooking something stupid. Or I'm too tired.
11:11:57 <merijn> Data.Time.Calendar.OrdinalDate has it
11:12:31 <merijn> Alternatively, you can extract the Day from a UTCTime
11:12:39 <scasc> Prelude Data.Time.Format.ISO8601 Data.Time.Calendar.OrdinalDate D> (iso8601ParseM "2020-01-01" ) :: Maybe Data.Time.Calendar.OrdinalDate.Day
11:13:05 <scasc>      Not in scope:
11:13:05 <scasc>       type constructor or class ‘Data.Time.Calendar.OrdinalDate.Day’
11:13:24 <merijn> eh, hold up
11:13:30 <scasc> (GHCi, obviously)
11:13:34 <merijn> Which version of time are you using?
11:14:55 <scasc> I thought 1.9.3
11:15:06 <scasc> Yeah, ghc-pkg tells me 1.9.3.
11:15:24 <merijn> OrdinalDate.Day only exists as of 1.11 :p
11:15:36 <merijn> There's a Day in Data.Time.Calendar in 1.9
11:16:25 <merijn> (that Data.Time.Calendar.Day is also in 1.11, but appears to be *different* from OrdinalDate.Day and the 2nd is the only instance in 1.11)
11:16:38 <merijn> The changelog of time is a bit vague about why that happened, though
11:17:01 <scasc> Oof. Yeah, this happens when you just look at the latest documetation on hackage, but have an older GHC set with ghcup. :-/
11:17:27 <merijn> ah, no
11:17:46 <merijn> It appears (fortunately) that it's the same Day in 1.11
11:18:01 <merijn> So just import Data.Time.Calendar.Day
11:18:43 <merijn> scasc: time is separate from GHC and can be updated, so the version of time you use depends on your cabal file/dependencies, not GHC :p
11:19:19 <merijn> > Data.Time.Format.ISO8601.iso8601ParseM "2020-01-01" :: Maybe Data.Time.Calendar.Day
11:19:22 <lambdabot>  error:
11:19:22 <lambdabot>      Not in scope: ‘Data.Time.Format.ISO8601.iso8601ParseM’
11:19:22 <lambdabot>      No module named ‘Data.Time.Format.ISO8601’ is imported.error:
11:19:22 * hackage streamly-lmdb 0.2.0 - Stream data to or from LMDB databases using the streamly library.  https://hackage.haskell.org/package/streamly-lmdb-0.2.0 (shlok)
11:19:26 <merijn> bleh
11:19:40 <merijn> That works on my machine with time 1.9, anyway
11:25:52 * hackage crdt-event-fold 1.2.1.1 - Garbage collected event folding CRDT.  https://hackage.haskell.org/package/crdt-event-fold-1.2.1.1 (rickowens)
11:31:54 <sim590> I'm playing with fundamental notions in the haskell wikibook. I've just looked at foldMap (which I never really used before). I'm now understanding that it's sufficient to provide a definition of foldMap in order to make a type an instance of Foldable. I see how foldMap can be written in terms of foldr. However, the inverse is not feasible it seems. Am I right? We cannot write foldr in terms of
11:31:56 <sim590> foldMap since it would require foldr to have the requirement of Monoid in its signature. Therefore, how is foldMap sufficient to make an instance of Foldable, hence providing me a free implementation of foldr? I'm a bit puzzled. I must be missing something.
11:32:46 <merijn> sim590: It helps to realise that the FOldable API is (basically) just "toList"
11:33:05 <merijn> sim590: So you can trivially implement anything by turning it into a list and then using the list version :p
11:33:46 <merijn> foldr f z xs = Data.List.foldr f z (foldMap (\x -> [x]) xs)
11:34:43 <merijn> :t foldMap (\x -> [x])
11:34:44 <lambdabot> Foldable t => t a -> [a]
11:35:50 <merijn> That's dumb and inefficient, but it is "sufficient" :)
11:35:51 <sim590> Oh............................................................. I see.
11:35:59 <scasc> merijn: thanks
11:36:10 <scasc> (sorry, had to be AFK)
11:36:30 <merijn> scasc: When GHC says stuff isn't in scope and Haddock says it is, the first step is always "double check your version" ;)
11:37:11 <scasc> I just spun up ghci btw, without a cabal file or using cabal repl, so it took some (relatively) random library from the global package database, I guess?
11:38:14 <merijn> scasc: Probably the one that ships with GHC (because GHC's dependencies and maybe Cabal's should be the only ones in the global package db)
11:38:34 <merijn> The rest should be in the global store
11:40:24 <sim590> merijn: So when we create an instance of Foldable with foldMap, does GHC actually has to make this implementation of foldr by converting to lists? Is it what GHC does? You mentionned that it is not so much efficient, so therefore it may be preferable to implement the Foldable instance with foldr directly instead?
11:40:42 <merijn> sim590: GHC doesn't do anything automatically
11:40:54 <merijn> sim590: But you can provide default implementations when defining a class
11:41:25 <merijn> sim590: For example: 'class Eq a where x == y = not (x /= y); x /= y = not (x == y)"
11:42:01 <merijn> sim590: Note that those two functions call each other. Now, when you define "class Eq MyData where MyData x == MyData y = x == y", you're done
11:42:14 <merijn> Because /= will call ==, which you just defined and it works out
11:42:48 <merijn> sim590: So Foldable has default implementations writting using (for example) foldMap, so when you only define foldMap those default implementations get used
11:43:18 <merijn> sim590: You can see this in the source: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Foldable.html#Foldable
11:43:24 <scasc> "Probably the one that ships with GHC" -- that's what I was referring to when I referenced GHC version above :-) -- Anyway, as I thought it was something stupid: looking at the wrong documentation version
11:50:42 <tomjaguarpaw> How do I find out the number of bits in an Int?
11:51:13 <merijn> :t finiteBitSize
11:51:14 <lambdabot> FiniteBits b => b -> Int
11:51:26 <merijn> :t finiteBitSize (2 :: Int)
11:51:28 <lambdabot> Int
11:51:46 <tomjaguarpaw> Huh?
11:52:03 <tomjaguarpaw> How come lambdabot said Int?
11:52:06 <geekosaur> > finiteBitSize (2 :: Int)
11:52:06 <tomjaguarpaw> Anyway, thanks merijn!
11:52:08 <lambdabot>  64
11:52:08 <merijn> > finiteBitSize (2 :: Int)
11:52:10 <lambdabot>  64
11:52:12 <geekosaur> because he asked :t
11:52:15 <tomjaguarpaw> Oh :t
11:52:18 <tomjaguarpaw> I see, thanks.
11:52:25 <merijn> tomjaguarpaw: Because I'm tired and not paying attention :p
11:52:40 <tomjaguarpaw> Nor me, clearly :D
11:53:13 <geekosaur> and I made my own (meta) dumb there so I guess that's three >.>
11:54:14 <merijn> Anyway, whenever your question is "something, something bits" the answer is, invariably "Data.Bits"
12:00:40 <Entertainment> My ~/.stack directory is 10.9 GiB. What do people do to manage this?
12:01:16 <sim590> merijn: OK. So I realize that the more general approach is to reduce the signature (a -> b -> b) to (b -> b) by partially applying f to all elements of `t a`. Then, those functions (b -> b) are wrapped into a type Endo which is a Monoid with (<>) = (.). Then, by since we now have monoid, it can be used with foldMap and the result is consistent with what we'd expect to happen.
12:02:32 <merijn> sim590: 
12:02:43 <merijn> Entertainment: Nuke it once or twice a year? :p
12:02:53 <merijn> That's what I do with cabal-install's store, anyway
12:03:24 <geekosaur> there's some tools to manage it also, I saw one go by on hackage's feed a couple hours ago
12:03:35 <Entertainment> merijn: Thanks, seems simple enough. I've been learning Haskell for a year now so I gues it's time.
12:03:49 <merijn> There was a "work in progress" GC for cabal-install, but it's still a bit ad hoc
12:04:55 <merijn> Entertainment: Basically, for every LTS/snapshot you use stack installs a corresponding GHC and any libraries you use. But since there's no real way for stack to know which projects are on your filesystem that you still work on, there's no real way to effectively "garbage collect" old GHCs/packages (same problem for cabal-install)
12:05:28 <Entertainment> I have a CACHEDIR.TAG file in there to stop .stack from getting backed up, otherwise I think I would have noticed it before now.
12:05:41 <merijn> There's some effort into developing tools for that, but practically speaking you can usually just nuke the package database and let them recompile any dependencies you need as needed (I'm not entirely sure which exact directory to nuke for stack, though!)
12:06:05 <merijn> I assume .stack is safe, but maybe some stack user should chime in and confirm first :p
12:18:12 <sm[m]> Entertainment, merijn : yeah the easy way is to rm -rf ~/.stack, but as with ~/.cabal you lose some config that way. Instead I run ncdu ~/.stack and just delete the big stuff (old installed GHCs and the haskell deps build for them)
12:18:29 <sm[m]> s/build/built/
12:19:24 <merijn> sm[m]: With cabal you wanna nuke ~/.cabal/store/ghc-XXX nowadays
12:19:31 <merijn> sm[m]: Then you don't lose any config
12:19:50 <sm[m]> ok, similar with stack
12:20:35 <sm[m]> rm -rf ~/.stack/{programs,snapshots} will delete all installed ghcs and haskell deps
12:46:23 * hackage criterion 1.5.8.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.5.8.0 (ryanglscott)
12:59:52 * hackage aspell-pipe 0.5 - Pipe-based interface to the Aspell program  https://hackage.haskell.org/package/aspell-pipe-0.5 (JonathanDaugherty)
13:00:29 <fraktor> I'm working on writing a Discord bot in haskell, but the library I'm using, discord-haskell, basically handles the event loop for me. Is there a good way to also be able to receive commands (either from a command-line program or a web frontend) that will update the configuration for the bot?
13:04:26 <merijn> Put the configuration in an STM variable shared between threads?
13:04:53 <merijn> One thread runs the event loop, the other listens to stuff on the commandline or wherever
13:11:29 <fraktor> I'm not sure how I feel about introducing shared state...
13:11:44 <merijn> Well, how else would you possibly update anything?
13:12:21 <fraktor> What I would ideally like is to be able to accept either a Discord event or a message event, and then handle that accordingly, but I'm not sure if that's something I can do with this API.
13:12:29 <fraktor> (part of me was hoping that the author was in this channel and could help out lol)
13:12:35 <merijn> Alternatively, have a single Chan that has events (from the discord library and/or the commandline) and then you can have 1 thread from the discord event loop writing to the Chan and 1 thread listening to the commandline writing to the Chan
13:15:31 <fraktor> Oh that sounds neat
13:16:42 <fraktor> So I would wrap it in a type like "data Message = Discord DiscordMsg | CommandLine CommandMsg" or something like that?
13:18:47 <merijn> For example
13:19:22 <merijn> And then make "Chan Message" with 1 thread reading from (and handling) messages and 2 (or more) threads writing messages to that Chan
13:27:07 <Feuermagier> how do i turn a list of 'a' into a list of (indexOfaInList, a)?
13:28:06 <Rembane> Feuermagier: zip [0..] listOfA
13:28:23 <Feuermagier> thx
13:28:35 <Rembane> np
13:33:29 <Feuermagier> ok, so now I want to sort by a function applied on a, group all with the same result and return a list of only the indexes we just added from the first of our result group
13:34:00 <Rembane> Feuermagier: How much of that code do you already have ?
13:34:06 <Feuermagier> the sort :D
13:34:13 <Rembane> :D
13:34:53 <Feuermagier> thinking clear enough to write that sentence was already something :D
13:35:41 <Feuermagier> actually, I think I can get the group as well
13:36:12 <Feuermagier> and with a bit of luck the return... maybe
13:36:24 <Feuermagier> i think writing that sentence was indeed the hardest part
13:36:41 <hpc> Feuermagier: https://en.wikipedia.org/wiki/Rubber_duck_debugging ;
13:36:43 <hpc> ;)
13:42:37 <Feuermagier> when exactly can I leave the variable passed to my function unnamed (I've seen variables passed never mentioned occasionally and just left implicitly at the end it seems)
13:44:08 <Rembane> Pointfree style is good to look into
13:44:23 <Rembane> https://wiki.haskell.org/Pointfree
13:44:50 <c_wraith> You always *can*.  It's just strongly recommended that you not do so.
13:45:56 <Rembane> I'm a strong proponent of pointfree style, but I hate readable code. 
13:46:02 <c_wraith> Well.  You always can if there's some sort of destructor available for any data types you might need to pull apart..
13:59:24 <Feuermagier> ok, so the sortby turns out to be harder than expected. I want to sort a [(Int, [Int])] by the length of the ĺist in the tuples.
14:01:41 <Rembane> Feuermagier: You do not have a list in the tuple 
14:02:19 <Feuermagier> Rembane, its a list of tuples. the tuples is of type (Int,[Int])
14:02:51 <Feuermagier> the 2nd position of the tuple is a Int list
14:04:54 <Rembane> Feuermagier: Sorry, I failed at reading. 
14:05:10 <fuzzypixelz> anyone here uses emacs?
14:05:14 <Rembane> Feuermagier: sortBy (comparing snd) should do what you want 
14:05:20 <Feuermagier> Rembane, np, you're helping me here :)
14:05:32 <Rembane> Feuermagier: ^^
14:05:44 <Feuermagier> Rembane, if I just compare snd, does it autotake length?
14:05:47 <fuzzypixelz> if so, can you please explain to me how to automagically infer the type of a haskell function?
14:07:22 <Rembane> Feuermagier: No, it seems like I'm a bit tired, lets try that again: sortBy (comparing (length . snd))
14:08:16 <Feuermagier> thx again!
14:08:51 <Rembane> np
14:12:46 <Feuermagier> Rembane, linter recommends "sortOn (length . snd) px"
14:14:04 <monochrom> sortOn is defined in terms of that combination of sortBy and comparing. So it depends on which one you prefer to memorize.
14:15:04 <Rembane> Feuermagier: Use that instead, their semantics are equivalent. :) 
14:15:18 <Feuermagier> excellent
14:15:22 * hackage hascard 0.5.0.0 - A TUI for reviewing notes using 'flashcards' written with markdown-like syntax.  https://hackage.haskell.org/package/hascard-0.5.0.0 (Yvee1)
14:22:31 <Feuermagier> can I just groupBy in the same way? - groupBy (length . snd) x - doesn't seem to work
14:22:48 <Rembane> Feuermagier: Nope, wrong types 
14:25:52 * hackage QuickCheck 2.14.2 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.14.2 (NickSmallbone)
14:25:58 <Feuermagier> Rembane, how do i get the boolean out of that and merge on equal?
15:51:23 * hackage hakyll-filestore 0.1.8 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.8 (aergus)
17:24:22 * hackage stylist 2.3.0.0 - Apply CSS styles to a document tree.  https://hackage.haskell.org/package/stylist-2.3.0.0 (alcinnz)
17:57:36 <dsal> Feuermagier: η-reduction works just like your basic algebra classes:     `f a = g something a`   -- you can remove the a from the right side of both.  `f = g something`  (there are cases where it's not quite that simple, but that's the basic idea)
19:39:52 <ensyde> .
20:00:53 * hackage oidc-client 0.6.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.6.0.0 (ShoKuroda)
20:39:32 <p0a> Hello, why does my prgram hang after reading a file? https://paste.tomsmeding.com/SStWMb8v
20:39:44 <p0a> It does what it's supposed to, but it never terminates
20:46:05 <p0a> Ah I think I spotted the bug, it was a precedence issue around unless/>>
21:01:38 <dsal> is `buf == B.empty` meant to do the same thing as `null b`?
21:07:42 <jle`> dsal: (if you mean B.null)
21:09:53 <dsal> Oh, I was thinking of it as being Foldable, but it's improperly kinded.
21:26:23 * hackage swiss-ephemeris 1.2.1.0 - Haskell bindings for the Swiss Ephemeris C library  https://hackage.haskell.org/package/swiss-ephemeris-1.2.1.0 (lfborjas)
21:43:51 <p0a> dsal: I wanted to write a program that does not load the file in memory so that it works with big files
21:44:27 <p0a> Initially I wanted to also take care of exceptions (I'm used to error checking in C) but I realized that it'd only be for the shake of nicer error messages, since there's nothing to recover from/to.
21:44:44 <p0a> ...I don't know why I'm telling you this. You didn't ask. :P sorry
21:45:06 <dsal> Heh, makes sense.  But have you considered conduit?
21:46:02 <p0a> No, but I'll take a look, thanks 
21:49:38 <dsal> Oh, conduit will make the thing you're describing quite easy.  :)
22:04:55 <jophish> Why doesn't Foldable's null have the type: null :: Foldable t => t a -> Maybe (t Void)
22:07:30 <MarcelineVQ> What is that expressing?
22:08:04 <jophish> It's a proof that the 't' is empty by filling it with Void
22:09:27 <glguy> jophish, that probably wouldn't be very useful, and wouldn't prove anything about whether or not the argument was empty
22:09:33 <MarcelineVQ> Ah that makes more sense to me written that way, not sure you gian much though
22:10:46 <jophish> glguy: sorry, I'm not sure I understand, how could it return a Void is a non empty 't'?
22:11:50 <glguy> null :: [a] -> Maybe [Void]; null _ = Just []
22:12:07 <glguy> the value that the [Void] is there doesn't prove anything about the argument being empty
22:12:39 <glguy> perhaps that's useful for some particular application, but it wouldn't be worth making Foldable more complicated in general
22:13:12 <jophish> Ah I see, in this case I wasn't envisioning null being a member of the Foldable type class
22:13:43 <glguy> If it wasn't you wouldn't be able to implement null
22:14:06 <jophish> yeah, I suppose that answers my question then :)
22:14:27 <jophish> anyway this will have to do lol: null' t = if null t then Just (unsafeCoerce t) else Nothing
22:14:53 <jophish> or if you're willing to add a functor instance, (error "what" <$ t) instead of unsafeCoerce
22:18:02 <jophish> or I suppose you could have it as part of Foldable with some law to go with it
22:20:57 <p0a> "Exceptions can only be caught in the IO monad and, because of laziness, might not be thrown exactly where you expect."
22:21:06 <p0a> Do you always catch them at the outmost level of execution?
22:21:33 * p0a is reading https://wiki.haskell.org/Dealing_with_binary_data
22:43:09 <p0a> "Warning: Multiple files use the same module name:"
22:43:11 <p0a> Why does this occur?
22:44:00 <nitrix> Might have something to do with multiple files having the same module name, but I could be wrong :P
22:48:32 <p0a> I have a myMain = do input <- BL.readFile testFile ; forever $ putStrLn $ runGet deserializeRow input
22:48:54 <p0a> it keeps printing the first row repeatedly. How can I do `runGet' until I run into eof?
22:49:33 <p0a> is it untilM_ I should use?
22:52:37 <p0a> this is my entire source code, https://paste.tomsmeding.com/7ji4QuHa
23:07:29 <p0a> there's also https://www.snoyman.com/blog/2016/12/beware-of-readfile to warn me against what I'm trying to do
23:07:39 <p0a> I'll give up for now
23:14:01 <jophish> Why do people not hang around...
23:27:47 <xsperry> too late.. but probably more than one file did not specify module name, so multiple ones defaulted to Main
