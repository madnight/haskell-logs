00:39:22 * hackage gloss 1.13.2.1 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.13.2.1 (BenLippmeier)
00:49:22 * hackage minizinc-process 0.1.2.0 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.2.0 (LucasDiCioccio)
02:07:57 <bqv> i'm looking for lenses over the store comonad
02:08:09 <bqv> the only trace of that being a thing is one stackoverflow post from long ago
02:09:23 <bqv> is there no library that considers this
02:18:22 * hackage buffet 1.0.1 - Assembles many Dockerfiles in one.  https://hackage.haskell.org/package/buffet-1.0.1 (evolutics)
02:47:10 <siraben> bqv: you're looking for a lens library that uses the store comonad encoding?
02:48:35 <bqv> I'm looking for a way to create a lens over a `Store b a`
02:49:00 <bqv> I realise the problem is that comonads aren't, by default, writable
02:49:08 <bqv> Hm
02:51:22 * hackage yesod-core 1.6.18.6 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.18.6 (MichaelSnoyman)
02:53:08 <siraben> bqv: https://www.schoolofhaskell.com/user/tel/lenses-from-scratch ?
02:53:52 * hackage yesod-eventsource 1.6.0.1 - Server-sent events support for Yesod apps.  https://hackage.haskell.org/package/yesod-eventsource-1.6.0.1 (MichaelSnoyman)
02:56:46 <bqv> siraben: I don't quite follow
02:57:13 <siraben> quaestor: what do you mean by comonads aren't writable?
02:57:23 <siraben> They are exactly the categorical dual of monads
02:58:31 <bqv> Would fmap on a Store change every value or just one
02:58:55 <bqv> I meant no way of changing just one value
02:59:54 <siraben> bqv: store comonad does not, IIRC. You probably want to look at the van Laarhoven encoding of Lenses
03:00:02 <siraben> That gives you the full Lens s t a b
03:00:10 <siraben> `type Lens s t a b = Functor f => (a -> f b) -> (s -> f t)`
03:00:37 <bqv> Ok
03:01:15 <siraben> bqv:  oh, I have a notes on different ways to implement lenses, see https://github.com/siraben/fp-notes/tree/master/lens
03:02:16 <siraben> some notes*
03:03:17 <bqv> Awesome
03:14:36 <mi23523523> Hello. Can someone give example of grading decimals ?
03:15:00 <mi23523523> This: (2567.54257)^(257.525472457) kind of thing seems not to work
03:16:02 <xerox_> :t (^)
03:16:04 <lambdabot> (Integral b, Num a) => a -> b -> a
03:16:06 <xerox_> :t (**)
03:16:07 <lambdabot> Floating a => a -> a -> a
03:17:24 <ClaudiusMaximus> :t (^^)
03:17:26 <lambdabot> (Fractional a, Integral b) => a -> b -> a
03:18:48 <ClaudiusMaximus> > (2567.54257)**(257.525472457)
03:18:50 <lambdabot>  Infinity
03:19:47 <mi23523523> thank you
03:20:11 <mi23523523> but it seems that with decimals the grading doesn't work so well
03:21:24 <mi23523523> Kaiepi, who are you ?
03:21:28 <mi23523523> Are you from Tartu ?
03:21:58 <Kaiepi> no?
03:22:06 <Kaiepi> i've been a lurker for a while
03:22:07 <mi23523523> alright
03:22:22 <mi23523523> I know a Kaie from Tartu
03:31:38 <siraben> What's a grading decimal?
03:43:46 <gtk> class Convertible a b | a -> b where... I don't understand why a -> b is necessary
03:44:14 <gtk> because in the instance definition, we are clear what b is
03:48:21 <fendor> gtk, to guide type inference. It basically says, if you know a, you know b, and iirc, it means that there should only be one instance per a. 
03:49:52 <gtk> only one instance per a!
03:50:04 <gtk> why the doc don't mention this
03:50:08 <gtk> this is the key!
03:50:24 <gtk> thx fendor
03:50:45 <fendor> gtk, the relevant docs are functional dependencies
03:51:04 <fendor> https://wiki.haskell.org/Functional_dependencies
03:51:16 <fendor> *are from
03:51:18 <gtk> i know. I just think that the dependencies are obvious during instance definition
03:52:05 <fendor> unfortunately, not. Take for instance the array typeclass. It has two parameters, the index type and the value type. They have no dependency, though
03:52:19 <fendor> would be sad if you could only have one index type per value type or vice versa
03:52:43 <gtk> good point
03:57:51 <chisui_> Hello, is there a way to embed haskell expressions inside of QuasiQuotes without writing your own haskell parser?
04:30:02 <chreekat[m]> Template Haskell? 
04:31:48 <frdg> I just came back to my stack project and GHCID is giving me an error that it cannot find a module that it should be able to find. I am able to run the program successfully with `stack run` and I can load everything into GHCI just fine, so the problem must be GHCID. Here is the error: https://dpaste.org/xmq7
04:33:28 <frdg> here is the output if I use the -v flag like it says: I really cant make any sense of it. https://dpaste.org/rjri
04:38:50 <fendor> frdg, try executing "stack exec -- ghci -isrc -iapp ~/haskell/fishing-web-app/app/Main.hs" directly, the error message will probbaly be helpful
04:41:14 <frdg> fendor: I get the exact same error that ghcid gave.
04:41:37 <fendor> then I guess that is a stack error
04:42:18 <fendor> maybe hpack did not regenerate the cabal file correctly? Or did you update the .cabal file manually?
04:42:38 <frdg> I update the cabal file manually
04:43:28 <fendor> frdg, can you maybe share the error message?
04:43:44 <fendor> is it this: can't find file: stack exec -- ghci -isrc -iapp ~/haskell/fishing-web-app/app/Main.hs 
04:44:16 <frdg> https://dpaste.org/cD9k
04:46:03 <fendor> and this module exists as src/Base.hs? maybe ghcid is not executed in  ~/haskell/fishing-web-app but some root directory of it?
04:46:14 <fendor> *parent directory
04:47:14 <frdg> no it exists in `app/Base.hs`
04:47:20 <fendor> same thing basically
04:52:24 <fendor> frdg, however, if you can re-produce it locally, it definitely is not ghcid specific
04:53:19 <avdb> I just learned about monads but they seem really "performance intensive", is it really the ideal solution?
04:54:09 <maerwald> you're right... inlining and specialization sometimes helps
04:54:31 <maerwald> https://neilmitchell.blogspot.com/2019/10/monads-as-graphs.html is interesting
04:54:51 <maerwald> and https://www.youtube.com/watch?v=0jI-AlWEwYI
04:54:54 <frdg> fendor: yes this is surely good to know. I have reinstalled stack since I last worked with this project. It is just strange that I can compile and run it.
04:56:09 <fendor> frdg, I would rather suggest to nuke the .stack-work/ folder and see if that helps
04:57:54 <frdg> fendor: same error after removing that folder
05:20:09 <Ariakenom> avdb, there performance is great afaik. what do u mean?
05:46:41 <maerwald> Ariakenom: it isn't, that's why free monads are slow too and applicative has more ways for the compiler to optimise
05:47:10 <maerwald> this is a basic problem for effects systems as well
05:48:35 <Ariakenom> free monads yes. but normal concrete ones are not
05:49:09 <maerwald> yes they are, because tho next effect depends on the valuee
05:50:52 <maerwald> also relevant https://www.vidarholen.net/contents/blog/?p=859 wrt transformers slowing down your program by 10% 
05:51:47 <maerwald> it's also true intuitevely, because it's the most expressive tool, where effects depend on values
05:53:04 <maerwald> that limits statical analysis too as described in Neils blog post
05:55:20 <Ariakenom> the relevant comparison here,, I would think, would be between side effects and IO. And I've never seen any claim that IO is slow. (not that side effects would work in haskell but still)
05:55:37 <maerwald> for it to perform well at all, you need to rely on GHC to do a lot of nice optimisations. If they break, for esoteric reasons, you're left with bad performance
05:56:04 <merijn> maerwald: that's only for polymorphic do blocks/monadic actions
05:56:06 <geekosaur> IO is known to have slow cases. they're usually hidden by ghc optimizations and by I/O itself being slow
05:56:35 <merijn> There's too many wish-washy words and descriptions in this discussion for it to be remotely useful, though
05:57:21 <merijn> For one, I call BS on the claim that "Applicative gets better optimised than Monad" beyond "some people have implemented more efficient Applicative instances"
05:57:51 <merijn> The amount of optimisation GHC does, doesn't make use of class laws, afaik, so that can't matter
05:59:02 <merijn> "transformers is 10% slower" is also impossibly general. 10% slow than what? What's your baseline? What's the code? Without precision about what performance/numbers we're tracking, what we're comparing against, this is just some IRC masturbation about our favourite/unfavourite abstractions
05:59:14 <maerwald> merijn: see the link
05:59:37 <maerwald> I was very specific
05:59:42 <merijn> I see 0 mentions of "transformers" when searching that page
05:59:50 <maerwald> then you didn't read it properly
06:00:11 <merijn> I didn't read, I searched
06:00:14 <maerwald> "Converting them to a cleaner ReaderT led to a 10% total run time regression, so I had to revert it."
06:00:16 <Ariakenom> search 10% or readert
06:00:17 <merijn> Anyway, I found it
06:00:55 <merijn> "10% between functions and ReaderT" <- was that using polymorphic mtl style code or using transformers? Do you have a sample? 10% regression in what? wallclock time? memory?
06:01:17 <maerwald> run time regression
06:02:42 <maerwald> ReaderT is a transformer, not mtl
06:02:58 <maerwald> I didn't look at the PR though
06:03:13 <merijn> Yes, but you can use ReaderT in a stack and still write intermediate code using mtl
06:03:23 <merijn> In fact, lots of people do
06:09:07 <maerwald> "instances can perform analysis of computations before they are executed, and thus produce shared optimizations." :)
06:15:07 <merijn> My point is that that's just a matter of "<*>" is a different function than >>=
06:15:49 <merijn> There's no reason you couldn't do the same thing transformers IFF users restrict themselves to <*>
06:16:22 <merijn> And if they can't restrict themselves to <*> the entire discussion is moot, since that means they can't implement it without using Monad anyway
06:17:26 <merijn> So "Applicatives are faster than monads" is true in the same vacuous sense that "return 42" is faster than "doing actual computation", which is great if returning 42 is all you need, but utterly pointless if you need something else
06:18:15 <maerwald> And I've read a lot that <*> often outperform `ap`
06:20:14 <merijn> That's an artifact of ap not being a class method and predating AMP, being implemented using >>=
06:21:01 <merijn> We could easily make it either a class method or change it to be <*>, but then everyone who defined Applicative using `ap` has their code break
06:21:12 <merijn> There's also literally no reason to use "ap" ever
06:22:58 <[exa]> hm, what's the easiest way/package/function to convert string-ish numbers to unixtime? (even ignoring the about the amount of ambiguity hidden in that task)
06:23:23 <maerwald> [exa]: there are a few fuzzy time parsers
06:23:39 <[exa]> in particular, I just found that `Data.UnixTime.parseUnixTime "%Y-%m-%d" "2020-10-32"` is the same as for "2020-10-0" with no error reported
06:23:58 <maerwald> @hackage fuzzy-dates
06:23:59 <lambdabot> https://hackage.haskell.org/package/fuzzy-dates
06:24:00 <[exa]> at least the errors would be cool
06:24:16 <merijn> [exa]: Where is Data.UnixTime from?
06:24:23 <merijn> And why are you not using Data.Time?
06:24:56 <[exa]> package `unix-time`
06:25:15 <[exa]> it was here in the project, expected no shenanigans
06:26:07 <merijn> [exa]: Seems easiest to just parse a UTCTime using "time" and then use utcTimeToPOSIXSeconds ?
06:27:12 <[exa]> merijn: will try, thanks
06:32:25 <__monty__> Isn't Data.Time anything but lax/fuzzy?
06:33:55 <[exa]> oh that at least knows how to fail on Oct 32th
06:34:26 <merijn> __monty__: Hence my suggestion to use that, rather than unix-time?
06:37:49 <__monty__> Lacking reading comprehension. For some reason I thought [exa] was asking for a lax time parser.
06:38:11 * [exa] googinling what's a lax parser
06:38:39 <[exa]> like, ideally I'd love to have the time parser from gnu date
06:39:23 <__monty__> [exa]: It's a parser that's not strict about the input format it accepts. Think HTML in browsers, at least older browsers.
06:40:46 <[exa]> oh good, thanks
06:42:03 <maerwald> yes, see fuzzy-dates
06:44:32 <[exa]> eyebrow very raised
06:49:52 <tobiasBora> Hello, I'd like to know, is there a function like MonadFail m => String -> Maybe a -> m a, that basically fails with String if a is Nothing, else returns a?
06:51:51 <maerwald> :t \x -> maybe (fail x) pure
06:51:52 <lambdabot> MonadFail m => String -> Maybe a -> m a
06:52:04 <[exa]> tobiasBora: `fromMaybe . fail` could work
06:52:30 <[exa]> (modulo some operand grouping)
06:53:13 <[exa]> oh ofc I'm missing return, maerwald has it right. :]
06:54:05 <maerwald> :t flip maybe pure . fail
06:54:07 <lambdabot> MonadFail f => String -> Maybe a -> f a
06:54:22 <tobiasBora> Cool, thanks a lot!
06:54:47 <tobiasBora> I have so much trouble to parse stuff like flip maybe pure . fail
06:55:01 <maerwald> stick to the lambda thing then
06:55:15 <maerwald> this is just eta reduction, which is good for top level functions
06:57:05 <tochicool> does anyone know why this will not type check? let g f = bimap f f in g id ((),False)
06:59:08 <fendor> oh, isn't that because of Monomophism Restriction?
06:59:19 <tobiasBora> You parent it like "((flip maybe) pure) . fail" = "\x -> ((flip maybe) pure) (fail x)" = "maybe (fail x) pure" I guess. But when you read stuff like "flip maybe pure . fail", is it like trivial for you, or you still have to think about this kind of expressions to understand them? I still miss intuition to parse Haskell code quickly$
06:59:44 <merijn> tobiasBora: The solution is to give it a name and dump it in a where block
07:00:23 <maerwald> it isn't intuitive, it's just hand-optimisation so it can better inline. I almost always start with lambdas and explicit arguments
07:01:06 <merijn> tochicool: Because that requires a RankN type
07:01:38 <merijn> tochicool: A question: What is the type of 'g'?
07:04:52 * hackage minizinc-process 0.1.2.1 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.2.1 (LucasDiCioccio)
07:07:08 <tochicool> merijn: i think ghc is inferring: Bifunctor p => (a -> d) -> p a a -> p d d - but i'm not sure how to type the more general function
07:08:03 <merijn> tochicool: Basically, what your example needs is some way of expressing that your input function works "for all possible input types" (as 'id' does), right?
07:09:29 <merijn> One way to type your specific example would be "Bifunctor p => (forall a . a -> a) -> p b c -> p b c" (the forall indicating that the function is 'a -> a', for, well, all possible 'a')
07:10:09 <merijn> tochicool: This use of "forall" is a rank 2 type, which requires an extension for GHC to use
07:11:01 <merijn> Additionally, they're no inferrable (well, technically Rank2 is inferrable, but higher ranks aren't. However the inference for rank 2 types is so horrific that GHC does not implement it)
07:11:18 <avdb> I'm confused, is combining functions commutative? For example, if I have f(g(x)), is it the same as g(f(x))?
07:11:44 <merijn> avdb: Not in general, no
07:12:41 <avdb> https://imgur.com/PCYZBJy.png
07:12:43 <__monty__> avdb: A simple example would be incrementing and doubling.
07:13:06 <avdb> I just tried, it is indeed not the same, seems like I found misinformation in a video on YouTube!
07:13:19 <avdb> Or maybe it only applies to non-numerical functions or something
07:13:27 <__monty__> Nope.
07:13:30 <merijn> avdb: nope
07:13:43 <merijn> avdb: Consider 'f :: Int -> Bool' and 'g :: Char -> Int'
07:13:52 <merijn> Those can only go one way around :)
07:14:16 <avdb> https://imgur.com/PCYZBJy.png
07:14:28 <merijn> avdb: There are classes of functions that are commutative, but you'd have to specify you're only talking about that specific class of functions
07:14:47 <avdb> Oops wrong screenshot, do you need the video?
07:14:48 <tochicool> merijn: ok thanks, what i have in mind is something like g :: Bifunctor f => (f :: forall a b . a -> b) -> p a a -> p (f a) (f a)
07:15:02 <avdb> https://www.youtube.com/watch?v=ZhuHCtR3xq8
07:15:04 <avdb> 11:50
07:15:19 <merijn> tochicool: You can't write a sensible "forall a b . a -> b"
07:15:21 <avdb> Sorry for being a little spammy, I need to make sure that I understand it
07:15:35 <merijn> tochicool: The only possible ones are "undefined" and "unsafeCoerce"
07:16:41 <merijn> tochicool: Note that something like "(Bifunctor f, Applicative g) => (forall . a -> g a) -> p b c -> p (g b) (g c)" can work
07:16:50 <merijn> tochicool: But "insufficient info" :)
07:17:02 <__monty__> avdb: I doubt he's making a mistake. He may be relying on the fact that the type "a -> a" only has a single possible implementation (disregarding errors and undefined etc.).
07:17:46 <avdb> __monty__: Thanks for the correction, I knew something was off!
07:20:22 * hackage ihaskell-hvega 0.3.2.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.3.2.0 (DouglasBurke)
07:21:22 * hackage hvega 0.11.0.0 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.11.0.0 (DouglasBurke)
07:24:57 <hekkaidekapus> merijn: The Rank-N topic apart, it seems this would suffice for tochicool’s immediate question: `f ∷ a → b; bimap f f`.
07:26:30 <merijn> hekkaidekapus: Not in his ((), False) example
07:27:30 <hekkaidekapus> merijn: Right, didn’t scroll back enough.
07:32:40 <tochicool> merjin: ok thanks :) so there really is no way to get that to work..
07:33:58 <tochicool> merijn++
07:34:15 <__monty__> avdb: I'm at 21:00 and he still hasn't said anything about commuting?
07:35:33 <__monty__> avdb: At 24:20 he even explicitly says commutation isn't a necessary condition.
07:43:25 <avdb> __monty__: I made up commuting as an example, ge only said that if you combine f with g like f(g(x)) and g(f(x)) that it's the same thing
07:58:08 <merijn> tochicool: If you have a more concrete example it might be possible, but it depends on what *exactly* you're trying to do
08:11:28 <__monty__> avdb: Hmm, I think you should rewatch. He said they're different afaict.
08:24:53 * hackage type-of-html 1.6.1.2 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.6.1.2 (knupfer)
09:02:23 <nut> is there a tool to find functions with the largest number of lines of code within package?
09:11:07 <merijn> Doubt it
09:11:24 <merijn> Also, how is the lines of code of a function defined? Like, do where blocks count?
09:20:36 <Franciman> hi maerwald are you here?
09:20:53 * hackage aeson-iproute 0.2.1 - Aeson instances for iproute types  https://hackage.haskell.org/package/aeson-iproute-0.2.1 (sickmind)
09:22:23 * hackage persistent-iproute 0.2.5 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-iproute-0.2.5 (sickmind)
09:42:06 <tochicool> merijn: if `mapBoth f = bimap f f` it would be nice to be able to write expressions like `mapBoth (< mempty) (Sum 0, "foo")` without having to duplicate the function like so: `bimap (< mempty) (< mempty) (Sum 0, "foo")`
09:45:34 <koz_> :t join bimap
09:45:35 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
09:45:41 <koz_> tochicool: ^
09:47:53 <merijn> koz_: No
09:48:00 <nut> is there Haskell equivalent of fseek?
09:48:03 <merijn> koz_: You have the same input type 'c'
09:48:12 <merijn> @hoogle hSeek
09:48:13 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
09:48:13 <lambdabot> GHC.IO.Handle hSeek :: Handle -> SeekMode -> Integer -> IO ()
09:48:13 <lambdabot> UnliftIO.IO hSeek :: MonadIO m => Handle -> SeekMode -> Integer -> m ()
09:48:23 <merijn> nut: ^^
09:48:28 <nut> nice
09:48:33 <koz_> merijn: Ah, good point.
09:48:51 <merijn> tochicool: That *can* work
09:50:13 <merijn> tochicool: Crucial difference is that (<mempty) always returns bool
09:51:11 <merijn> tochicool: "(Monoid b, Ord b, Monoid c, Ord c) => (forall a . (Monoid a, Ord a) => a -> Bool) -> p b c -> p Bool Bool"
09:52:16 <nut> merijn: i couldn't find the fread equivalent though
09:55:16 <tochicool> merijn: :D ofcourse, not as general as i would have liked but that's sufficient for my usecase
09:55:24 <tochicool> merijn: thanks
09:59:00 <geekosaur> nut: https://downloads.haskell.org/ghc/latest/docs/html/libraries/base-4.14.1.0/System-IO.html#v:hGetBuf
09:59:49 <geekosaur> or one of the other GetBuf functions in that section
10:00:27 <merijn> nut: There's a bunch, hGet and hGetSome are most likely what you want
10:00:54 <merijn> nut: And then you presumably want either the version from the text or bytestring package, depending on the file contents
10:01:30 <merijn> geekosaur: hGetBuf seems a bit low level for most usecases, tbh
10:01:46 <geekosaur> there's that also. probably bytestring if you're reading chunks instead of lines
10:02:21 <nut> I'm translating some code from c++ to Haskell. Wondering how to choose these IO functions to make it fast and correct
10:03:21 <merijn> nut: I mean, given the fact that the actual IO to disk will probably dominate I wouldn't worry too much about "fast", as it doesn't take much to be as fast as the disk for most straightforward stuff
10:03:57 <merijn> nut: Presumably you just want blobs of binary data if you're translating C++?
10:04:22 <nut> Yes, it's a zipped dictionary file
10:05:00 <merijn> nut: Then you'll want hGet/hGetSome from bytestring
10:05:16 <merijn> https://hackage.haskell.org/package/bytestring-0.11.0.0/docs/Data-ByteString.html#v:hGet
10:05:30 <nut> The dictionary file format is so designed to make load time short. So it contains many offset info
11:03:46 <wz1000> Is there any canonical way to read/write a file and simultaneously get its modification time?
11:04:17 <davean> wz1000: simultaneously?
11:04:27 <davean> Thats not something you can do on POSIX, they're seperate calls.
11:04:35 <wz1000> after the operation has completed, but atomically
11:04:38 <geekosaur> that'd have to be a system call and neither unix nor windows offers such
11:04:49 <davean> Right
11:04:59 <davean> well, you can do it on linux or FreeBSD with ZFS
11:05:08 <davean> but that involves special kernel extensions
11:05:16 <davean> not at *all* a portable or standard thing.
11:05:48 <davean> And they can only do it via transactional filesystemness.
11:06:25 <davean> Are you willing to cosplay a kernel developer? No? You can't have that.
11:06:45 <Ariakenom> filesystems have terrible semantics. race conditions everywhere
11:09:13 <Ariakenom> the common approach is to ignore them
11:18:53 <davean> Ok, so you can do it on Linux and FreeBSD via ZFS Transaction Groups, you can do it on Linux via FANotify with root permissions, you can do it on linux with user permissions and inotify if you believe inotify won't drop any events which isn't guarrenteed, you can do it on Windows Post-Vista via NTFS transactions (Much weaker than ZFS transaction groups?), you can do it on ext3+ with journaling by
11:18:55 <davean> hooking the journal kernel side ... Its not that you can't do it, its that its insane to do it given the fact that all the ways of doing it are super special case.
11:19:15 <davean> and it certainly isn't a Haskell question to get it done! If you want to get this done, get involved with the OS you're on.
11:20:08 <davean> https://www.kernel.org/doc/html/latest/filesystems/journalling.html
11:20:10 <davean> don
11:20:18 <davean> 't worry, it starts out with "The journalling layer is easy to use.
11:20:23 <davean> " you'll be fine ;)
13:09:22 <koz_> How does one satisfy this kind of constraint? http://hackage.haskell.org/package/constraints-extras-0.3.0.2/docs/Data-Constraint-Extras.html#t:Has-39-
13:09:31 <justsomeguy> Is there a way to search for all functions in the base package that take a list as its first argument?
13:10:07 <justsomeguy> (Or, failing that, would it be easier to read the source code for base?)
13:11:31 <koz_> The reason I care is that I want an Eq instance to be available for (my particular concretized) DMap from here: http://hackage.haskell.org/package/dependent-map-0.4.0.0/docs/Data-Dependent-Map.html#t:Eq
13:13:26 <justsomeguy> Ok, it seems everything I want is in GHC.List.
13:15:14 <xsperry> justsomeguy, no AFAIK, but if you know full type of the function you can use hoogle
13:15:42 <geekosaur> hoogle ought to be fine with "[a] -> b", shouldn't it?
13:22:49 <justsomeguy> I wanted to match signatures like “:: [a] -> (a -> b) -> [b]”, but also things like “:: [a] -> a”... pretty much anything beginning with ``:: [a｣ as its first argument. It looks like I can't do that, but that's OK, since I found what I was looking for.
13:23:10 <justsomeguy> (Whoa, weird formatting error there.)
13:37:25 <zeta_0> has anyone here gotten haskell-language-server working correctly? i'm having some issues!
13:37:58 <Uniaika> zeta_0: do tell us!
13:38:02 <Uniaika> which version are you using?
13:39:24 <zeta_0> Uniaika: haskell-language-server version: 0.4.0.0 (GHC: 8.6.5), it's binary is recognized, so the PATH is set as well.
13:40:38 <Uniaika> zeta_0: any reason you're not running on the latest version of HLS?
13:41:50 <zeta_0> whenever I ran gen-hie, it made a hie.yaml file with path and component set for Main.hs, but not Setup.hs, and whenever I open Main.hs, it gives me a prompt to install hie, it's not recognizing hls.
13:43:16 <zeta_0> Uniaika: this is the only version of hls in nixos 20.09: https://search.nixos.org/packages?channel=20.09&from=0&size=30&sort=relevance&query=haskellPackages.haskell-language-server
13:44:19 <zeta_0> also, does hls work on single haskell files like ghcide does?
13:45:04 <Uniaika> hls and ghcide have merged
13:45:33 <Uniaika> zeta_0: maybe ask your question on #Haskell-ide-engine, you'll be closer to the maintainers
13:46:22 <zeta_0> Uniaika: ok, i'll go ask there instead!
13:48:39 <newbi> evening. im having problems with filtering list of characters. can someone give me some insight?
13:49:25 <newbi> i have to use list comprehension to search for digits in a list of characters. im having problem with finding digits, its always some kind of error
13:49:52 <monochrom> @where paste
13:49:52 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
13:50:57 <newbi> f1 xs = [x |x<-xs, x<-[0..9]]
13:52:21 <newbi> https://paste.tomsmeding.com/NEgGvtvH
13:52:48 <monochrom> x<-[0..9] does not mean checking whether x is one of [0..9].
13:53:12 <newbi> i tried isDIgit but its always some kind of error
13:53:49 <monochrom> OK, post your isDigit version, that one has a much much better chance.
13:54:48 <newbi> https://paste.tomsmeding.com/xjzt6Tu8
13:55:05 <monochrom> You need to import it from Data.List
13:57:32 <newbi> i think i did but it still shows the same error
13:58:14 <monochrom> Post the most up to date complete code.
13:58:22 <monochrom> Every byte counts.
13:58:39 <newbi> its the same line of code, i just added "import Data.List"
13:59:11 <monochrom> Order matters too. Just "adding" is not enough and I can't see where you added it.
13:59:26 <newbi> i added it above the function
13:59:35 <newbi> f1 xs = [x |x<-xs, isDigit(x)]
13:59:38 <monochrom> And the exact verbatim error message?
13:59:54 <monochrom> Because it works for me, I can't see what error you got.
13:59:56 <comerijn> Also, isDigit isn't *in* Data.List, so...
14:00:04 <monochrom> Oh oops, sorry. Data.Char
14:00:26 <newbi> yesss
14:00:33 <comerijn> monochrom: pfft, you n00b ;)
14:00:35 <newbi> it works! thank you so much
14:03:23 * hackage technique 0.2.5 - Procedures and Sequences  https://hackage.haskell.org/package/technique-0.2.5 (AndrewCowie)
14:13:22 <koz_> :t foldM
14:13:25 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
14:14:16 <newbi> im still having problems with this one https://paste.tomsmeding.com/OpsTZZjd
14:14:32 <newbi> it can filter a string but it cant filter a list
14:14:42 <newbi> what can i do so it can
14:18:07 <Feuermagier> how can I elegantly switch on number ranges? eg: 0 to 10 do a; 11 to 20 do b
14:18:50 <hekkaidekapus> newbi: What are the types of x and y in `x = 'a'; y = 5`?
14:19:26 <newbi> x is char and y is int
14:19:41 <koz_> Feuermagier: Guards, probably?
14:19:52 <hekkaidekapus> newbi: What about `z = '5'`?
14:20:01 <newbi> still char heh
14:20:35 <hekkaidekapus> newbi: And `xs = [1, 2]`?
14:20:53 <newbi> its a list of integers
14:21:13 <hekkaidekapus> So, can I do `xs = [1, '2']`?
14:21:17 <newbi> oh okay when i put everything in commas it works. but can you have a mixed list?
14:21:24 <newbi> its like a mixed list
14:21:32 <newbi> i dont know if you can do that
14:21:38 <Feuermagier> koz_, sry, a bit new :) - guards are the: func 0 = a; func 1 = b; func n = something; - right?
14:21:50 <koz_> Feuermagier: No, that's different.
14:21:52 <koz_> Let me paste.
14:22:11 <hekkaidekapus> newbi: You cannot. A list is a collection of elements of the same type.
14:22:43 <newbi> thank you :)
14:22:58 <hekkaidekapus> newbi: In your pasted code, you want `f1 ['a','2','4','b','4']`.
14:23:17 <koz_> Feuermagier: https://gist.github.com/kozross/c866e0fcf9736131ebf8548f425b3f69
14:23:47 <koz_> There's no requirement to use the && and comparisons either - any predicate would work.
14:23:47 <Feuermagier> koz_, thank you! - looks exactly like what i need :D
14:24:36 <Feuermagier> koz_, if doAThing returns the function I assume I can rely on it being executed top to bot?
14:24:55 <koz_> Feuermagier: What do you mean 'returns the function'?
14:25:41 <Feuermagier> koz_, well, actually, I think everything in haskell "returns" 
14:26:02 <koz_> Feuermagier: Basically, if your guards are non-overlapping, this doesn't matter.
14:26:08 <Feuermagier> koz_, just meant that it won't fall through if matched
14:26:14 <Feuermagier> exactly
14:26:22 <koz_> If your guards _are_ overlapping, I believe top-to-bottom, but I would argue overlapping guards are probably a bug.
14:26:36 <koz_> We avoid 'fall-through' by having 'otherwise' at the end, which is a synonym for 'True'.
14:33:24 <comerijn>  guards are always top to bottom
14:33:41 <comerijn> Incidentally, if you have incomplete guards it will fall through to the next matching pattern
14:33:50 <comerijn> Which can be very useful in a bunch of cases
14:36:44 <koz_> @pl \f g x -> fmap (>>= f) (g x)
14:36:44 <lambdabot> (.) . fmap . (=<<)
14:37:08 <koz_> Lol, so I can replace that with (.) . (<$>) . (=<<), sick.
14:37:16 <koz_> Are we J now?
14:43:19 <comerijn> What?
14:43:28 <comerijn> That's, like, 15 characters
14:43:40 <comerijn> That's like 3x the size of the average J program :p
14:43:47 <koz_> comerijn: Lol.
14:44:05 <koz_> It's all those parens.
14:44:12 <koz_> It's like, LispJ.
14:55:18 <koz_> :t compare 1 2
14:55:19 <lambdabot> Ordering
14:55:24 <koz_> > compare 1 2
14:55:26 <lambdabot>  LT
14:55:31 <koz_> > compare 2 1
14:55:34 <lambdabot>  GT
14:55:42 <koz_> OK, I'm not forgetting the order.
15:00:27 <Feuermagier> I want to build a string by calling an evaluation function on each position of a list. how can I extend the list up to a fixed size, or alternatively handle nonexistant entries in the array?
15:01:33 <comerijn> Feuermagier: Do you have a sensible element to pad with if it's too short?
15:01:37 <Feuermagier> 0
15:01:43 <Feuermagier> (its a list of integers)
15:02:01 <comerijn> > take 10 ([1..5] ++ repeat 0)
15:02:03 <lambdabot>  [1,2,3,4,5,0,0,0,0,0]
15:02:19 <Feuermagier> ooh, fancy
15:02:29 <comerijn> Feuermagier: Just pad with infinite zeroes at the end and take however many elements you need :p
15:04:27 <Feuermagier> can I pad at front as well?
15:05:17 <comerijn> That's trickier, because you'll need to know in advance how many elements to pad with
15:05:36 <Feuermagier> I guess I can simply reverse my list
15:08:46 <koz_> Cale: Any chance you could tell me how one satisfies a 'ConstraintsFor F (ComposeC Show Identity)'? I'm trying to use a custom GADT F in the context of 'DMap F Identity' and a Show instance for it.
15:08:50 <koz_> (same with Eq)
15:22:16 <bqv> Hey, how best can I get a "Maybe monad"-style effect in polysemy?
15:23:07 <bqv> I'm looking at NonDet, but I'm not quite sure how to use it
15:23:58 <bqv> I gues I'm looking for a function :: Maybe a -> Polysemy.Sem r a
15:24:02 <bqv> Of some sort
15:25:21 <bqv> I see at least NonDet gives Sem an alternative instance, but how to drop a maybe into NonDet?
15:28:21 <bqv> I could embed Maybe...
15:28:36 <bqv> Feels oof tho
15:29:06 <bqv> Probably the easiest solution to be honest
15:30:34 <bqv> Or maybe I should just handle the errors properly. Ugh
15:32:29 <jcowan> Is there any usable workaround for the fact that a constructor can't appear in two or more types?
15:32:55 <hpc> naming them different things?
15:33:08 <jcowan> yeah, maybe I deserve that.
15:33:15 <hpc> if they're in different modules, import them qualified
15:33:34 <hpc> or if you can't do that, prefixing them with the type maybe
15:33:43 <jcowan> I'm assuming of course that they are in fact the *same* constructor (same number and types of arguments, not just a coincidence of names
15:33:57 <hpc> like if Foo and Bar both have constructor Object, name them FooObject and BarObject instead
15:34:30 <jcowan> Which means that the system can't recognize the isomorphism.
15:35:15 <hpc> if you want both constructors to be the same value, use a function or type class or something along those lines
15:35:23 <hpc> constructors can't be polymorphic in the type they construct
15:35:29 <bqv> Classy
15:35:54 <hpc> (also i definitely phrased that first suggestion for maximum humor :D)
15:36:23 * hackage json-to-haskell 0.1.1.0 -   https://hackage.haskell.org/package/json-to-haskell-0.1.1.0 (ChrisPenner)
15:44:51 <Feuermagier> how can I get element n out of a list?
15:45:02 <bqv> Feuermagier: list !! n
15:45:14 <bqv> % 1
15:45:14 <yahb> bqv: 1
15:45:26 <bqv> % ["a", "b", "c"] !! 1
15:45:26 <yahb> bqv: "b"
15:45:31 <bqv> % ["a", "b", "c"] !! 3
15:45:31 <yahb> bqv: "*** Exception: Prelude.!!: index too large
15:45:33 <bqv> % ["a", "b", "c"] !! 0
15:45:33 <yahb> bqv: "a"
15:45:37 <Feuermagier> I have a list of 10 elements and want to perform a different operation on each position and sum the results
15:45:41 <koz_> [insert obligatory warning about indexing lists being both slow and unsafe]
15:45:48 <comerijn> tbh, random access on lists is bad
15:45:54 <bqv> Feuermagier: sounds like a fold
15:46:07 <Feuermagier> bqv, havent heard of that yet
15:46:10 <koz_> bqv: Or a foldMap. :P
15:46:22 <hpc> Feuermagier: zipWith ($) sounds more suitable
15:46:50 <hpc> % zipWith [(+ 5), (* 2), id] [100, 1000, 10000]
15:46:51 <yahb> hpc: ; <interactive>:16:9: error:; * Couldn't match expected type `a1 -> b -> c' with actual type `[a0 -> a0]'; * In the first argument of `zipWith', namely `[(+ 5), (* 2), id]'; In the expression: zipWith [(+ 5), (* 2), id] [100, 1000, 10000]; In an equation for `it': it = zipWith [(+ 5), (* 2), id] [100, 1000, 10000]; * Relevant bindings include it :: [b] -> [c] (bound at <interacti
15:46:59 <hpc> % zipWith ($) [(+ 5), (* 2), id] [100, 1000, 10000]
15:47:00 <yahb> hpc: [105,2000,10000]
15:47:10 <bqv> koz_: that's just a spicy fold :D
15:47:13 <Feuermagier> interesting
15:47:21 <koz_> bqv: Spicy be good.
15:47:47 <hpc> Feuermagier: think functional :D
15:48:23 <Feuermagier> the results of the oerations are gonna be strings, how do i build a continous one out of the results?
15:48:37 <koz_> > "foo" <> "bar"
15:48:40 <lambdabot>  "foobar"
15:48:52 <koz_> Do you mean continuous in that sense?
15:48:56 <Feuermagier> yes
15:49:48 <koz_> If you're gonna use a fold, then you can combine with (<>). If you're going to use foldMap, it does it for you if you project into String.
15:50:27 <Feuermagier> koz_, alright. i'll implement the zipWith for now and then see how i get on
15:54:15 <Feuermagier> why does this not work?: zipWith [(+ 5), (* 2), id, id, id] pad(reverse(digits n))
15:55:02 <koz_> Feuermagier: Please be more specific. What do you mean by 'not work'? Does it not compile? Does it run, but not how you want? Something else?
15:55:35 <Feuermagier> oh, ofc. sec
16:00:03 <jcowan> hpc: Right, I understand that.  But is that a principled restriction?
16:00:26 <Feuermagier> I have a function "constructDigit :: String -> Integer -> String" - I want to call it in the zipWith with a constant string and the zipped-towards integer. What's the syntax for that?
16:02:03 <Axman6> I have no idea what you're asking for
16:02:11 <Axman6> perhaps give us some example inputs and expected outputs
16:02:27 <hpc> not anything specific, but...
16:02:51 <Axman6> Feuermagier: also zipWith [(+ 5), (* 2), id, id, id] pad(reverse(digits n)) doesn't work because you actually wrote (((zipWith [(+ 5), (* 2), id, id, id]) pad(reverse(digits n))
16:03:02 <hpc> so, you've got code that has some identifier, "foo" - you want it to refer to the same thing everywhere you use it, and not have some extra piece of context deciding for you
16:03:08 <Axman6>  (((zipWith [(+ 5), (* 2), id, id, id]) pad) (reverse(digits n))) *
16:03:10 <hpc> like what type it's supposed to be and so forth
16:03:42 <hekkaidekapus> > ZipList [(+ 5), (* 2), id] <*> ZipList [100, 1000, 10000]
16:03:43 <lambdabot>  ZipList {getZipList = [105,2000,10000]}
16:03:51 <Axman6> pad is being passed as an argument to zipWith
16:04:08 <hpc> and constructors are defined as part of their data definition, to produce data of that type
16:04:11 <Feuermagier> so, I want to turn [0,1] into [constructDigit "a" 0, constructDigit "b" 1]
16:04:26 <hpc> which is more obvious if you look at data definitions with GADTSyntax
16:04:40 <hpc> data Maybe where Nothing :: Maybe a; Just :: a -> Maybe a
16:04:47 <hpc> for example
16:04:50 <Axman6> so zipWith constructDigit ["a","b"] [0,1]?
16:05:00 <Feuermagier> yes
16:05:07 <Feuermagier> that works?
16:05:08 <Axman6> need more examples to see how that should be generalised
16:05:15 <hpc> and then if you define some other data type using Nothing as a constructor, you have two definitions
16:05:35 <hpc> and when definitions have overlapping names, that's an error
16:05:35 <Axman6> > zipWith f [a,b] [0,1] :: [Expr]
16:05:37 <lambdabot>  [f a 0,f b 1]
16:06:25 <hpc> basically the same reason you can't define functions multiple times either
16:16:33 <Feuermagier> so, zipWith constructDigit ["a","b"] [0,1] works now. However I want the [0,1] part to be the return of a function (pad :: -> Integer)
16:18:21 <hekkaidekapus> zipWith constructDigit ["a", "b"] (pad …)
16:18:42 <Feuermagier> ah, one more parenthesis
16:19:03 <hekkaidekapus> zipWith constructDigit ["a", "b"] xs where xs = pad …
16:19:14 <bqv> pointfree ftw
16:19:51 <hekkaidekapus> let xs = pad … in zipWith constructDigit ["a", "b"] xs
16:58:01 <Echosolace> Hey all, I'm still plodding along through learn you a haskell and I have a question about the groupby function, specifically, why the group by function is grouping together more than just pairs of items. Does anyone know why the following works out as it does?
16:58:06 <Echosolace> let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3] 
16:58:21 <Echosolace> groupBy (\x y -> (x > 0) == (y > 0)) values
16:58:30 <Echosolace> [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]  
16:59:22 <Axman6> Echosolace: groupBy is notoriously confusing, it groups runs of values together when _the first_ element  combined with the others return true
16:59:55 <Axman6> > groupBy (\x y -> y > x) [1,2,3,4,3,2,3,2,1,2,3,2,1]
16:59:57 <lambdabot>  [[1,2,3,4,3,2,3,2],[1,2,3,2],[1]]
17:00:31 <Echosolace> That's comforting to hear. Let me try to understand that.
17:00:32 <Echosolace> Thanks.
17:01:11 <Axman6> it's basicallt a repeated use of: case xs of (y:ys?) -> takeWhile (f y) ys
17:01:19 <Axman6> without the typos...
17:06:32 <Echosolace> Ok, interesting. So in my example, element 0 (first element in the list, -4.3) gets compared with -2.4, is true and gets grouped, then -4.3 gets compared again with -1.2 and also gets grouped. Is that correct?
17:10:02 <Echosolace> Sounds like it. Thanks for the help.
17:18:42 <bqv> looking for a datatype
17:18:59 <bqv> must be short, blonde, and located in the penn state area
17:19:15 <bqv> no, but seriously, i'm thinking of a write-only-list sort of thing
17:19:55 <bqv> so far the closest i can think of is an IntMap where every entry is a Maybe and the delete operation is banned
17:20:32 <bqv> my requirement is kinda that there's a unique index for every item added across the lifespan of this container
17:23:58 <bqv> the type i'm thinking of is i guess isomorphic to `IntMap (Maybe a)` and `[Maybe a]`, and I've gone for the former so far because i would need random access
17:24:09 <bqv> just wondering if there's a better encoding
17:38:29 <jle`> bqv: by write-only do you mean like append-only?
17:38:46 <jle`> you can just use whatever data type you want and only export the operations that are allowed
17:39:14 <jle`> pure datatypes are all persistent so you can't really truly have 'no undo', since you can just hold a reference to previous values
17:42:18 <bqv> jle`: yes, i do
17:42:22 <bqv> and yeah i know
17:42:31 <bqv> i was just wondering if this was an already packaged thing
17:54:31 <xenon-> I need to create a relatively simple website for my personal use, and I want to give FRP a try. what library do you recommend?
18:05:26 <jchia> xenon: Why do you need FRP for a website?
18:06:54 <xenon-> I don't NEED it, I want to give it a try
18:09:46 <bqv> jle`: what would you call, such a structure?
18:40:41 <Axman6> xenon-:  obilisk seems to the the simplest way to start with FRP using Reflex I believe
19:12:57 <siraben> is anyone aware of a good tutorial on how to implement tail-call optimization in Haskell?
19:13:19 <Axman6> what do you mean?
19:13:57 <Axman6> TCO isn't a necessary optimisation in Haskell because the way that function calls work basically give you that for free
19:14:15 <Axman6> (GHC Haskell)
19:21:02 <siraben> Axman6: Ah as in, if I'm making a compiler for a functional language and want to implement TCO myself
19:21:22 * hackage json-to-haskell 0.1.1.1 -   https://hackage.haskell.org/package/json-to-haskell-0.1.1.1 (ChrisPenner)
19:21:25 <Axman6> that's a very different question :P
19:21:44 <Axman6> just jump to the code, BAM, done
19:21:48 <siraben> Just reading my old question it wasn't clear semantically, heh. Note to self: people can't read your mind!
19:21:57 <siraben> Yes but I have to recognize tail-calls right?
19:22:46 <Axman6> this really depends a lot on your language
19:24:06 <siraben> Axman6:  say it's https://github.com/jozefg/pcf/
19:24:38 <texasmynsted> https://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
19:24:41 <siraben> Technically a naïve graph reduction machine always uses tail jumps in the opcode interpretation however the stack context grows with recursive calls, so no
19:25:05 <siraben> texasmynsted:  Yes I'm aware of what TCO is, I'm looking to implement it in a functional compiler.
19:25:44 <texasmynsted> By default, haskell has lazy evaluation. 
19:26:13 <siraben> To constraint the question further, suppose it's a strict, impure and functional language (like Scheme).
19:28:02 <siraben> Oh I forgot, Lambda the Ultimate GOTO!
19:32:01 <dsal> I spent way too much time making software nobody else is ever going to need generally available today.
19:34:24 <Axman6> good work
19:35:17 <dsal> I guess I did the same thing yesterday, so maybe this is just normal.
19:36:55 <justsomeguy> What does the Haskell report mean when it says declarations withing let expressions are mutually recursive?
19:37:02 <dsal> I got to try optparse-generic today, though.  I'm not sure if I like it, but I'm more sure than before I never tried it.
19:37:32 <dsal> justsomeguy: things defined in let can reference each otehr
19:37:37 <dsal> s/other/otter/
19:37:52 <justsomeguy> Ahh, ok, that helps.
19:39:08 <justsomeguy> Otters should definitely be able to reference each other; they form a tight-knit community.
19:39:22 <dsal> ha.  mnemonic
19:39:42 <justsomeguy> :)
19:41:52 <P1p> hi
19:42:13 <dsal> Oh cool, stack changed the way they specify resolvers in stack.yaml and broke default.nix
19:45:27 * hackage json-to-haskell 0.1.1.2 -   https://hackage.haskell.org/package/json-to-haskell-0.1.1.2 (ChrisPenner)
19:46:23 * hackage crdt-event-fold 1.2.0.0 - Garbage collected event folding CRDT.  https://hackage.haskell.org/package/crdt-event-fold-1.2.0.0 (rickowens)
19:56:09 <P1p> hello everyone
19:56:32 <P1p> join #haskell
19:57:31 <P1p> yo
19:57:36 <P1p> there you are
19:57:42 <p0kerf4ce> woah thats a lot of people
19:57:46 <P1p> ik
19:57:59 <P1p> no talkin tho
19:58:09 <p0kerf4ce> were prolly bein hacked rn
19:58:28 <P1p> jump back to e
19:59:44 <Axman6> you ok?
20:01:34 <Axman6> > let a = 1 : b; b = 2 : a in a -- justsomeguy
20:01:36 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
20:22:10 <justsomeguy> That's a good example, thank you.
20:45:22 * hackage vty 5.32 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.32 (JonathanDaugherty)
21:24:20 <suzu_> > let x = 1:2:x in x
21:24:22 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
23:04:55 <Squarism> how would you map a list such that all but last element are mapped using f and last element is mapped using g?
23:16:25 <opqdonut> Squarism: the straightforward answer is: map f (init xs) ++ [g (last xs)]
23:17:01 <opqdonut> but you can write a custom recursive function mapInitLast :: (a->b) -> (a->b) -> [a] -> [b] that does the same a bit more efficiently
