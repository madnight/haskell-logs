00:01:07 <idnar> bqv: or replace a traversed with an itraversed
00:04:18 <idnar> https://www.reddit.com/r/haskell/comments/60fha5/affine_traversal/
00:06:40 <dibblego> what is the operation on affine traversal that cannot be performed without it?
00:16:00 <bqv> idnar: currently constructed the traversal by composing a lens and a prism (hence affine), so no traversed to replace. I think I can get away with some dirty tricks if I fudge that lens hard, though
00:23:57 <bqv> Ok yeah, got it. Made the lens indexed by Maybe idx, then applied the prism, then reindexed with fromJust
00:25:40 <bqv> Feck, that doesn't work
00:25:51 <bqv> Now I have imaginary functional dependencies
00:26:12 <bqv> I should cut my losses and use optics…
00:49:48 <bqv> Hm, got it. 
00:50:17 <bqv> If I use Data.Tuple.Lazy, I can do fromJust in the ilens
00:50:47 <bqv> Never gets evaluated, but its enough to give me a sensible indexedlens
00:51:02 <bqv> And the prism is index preserving
00:53:01 <dminuoso> 09:47:30           bqv | [06:43:38] Why were affine traversals removed from lens?
00:53:25 <dminuoso> bqv: To implement affine traversals with the van laarhoven encoding, you'd need to split Applicative into Pointed and Ap, such that affine would use Pointed only
00:53:28 <dminuoso> % :i Traversal
00:53:29 <yahb> dminuoso: type role ReifiedTraversal representational nominal representational nominal; type ReifiedTraversal :: * -> * -> * -> * -> *; newtype ReifiedTraversal s t a b = Traversal {...}; -- Defined in `Control.Lens.Reified'; type Traversal :: * -> * -> * -> * -> *; type Traversal s t a b = forall (f :: * -> *). Applicative f => (a -> f b) -> s -> f t; -- Defined in `Control.Lens.Type'
00:53:55 <dminuoso> So you'd have `type AffineTraversal s t a b = forall f. Pointed f => (a -> f b) -> s -> f t`
00:55:22 <bqv> That doesn't seem prohibitive, surely have (Pointed, Ap) => Applicative and it's nondestructive?
00:56:11 <dminuoso> Well, the usefulness depends on how many things have Pointed instances...
00:57:25 <dminuoso> With profunctor this is SIMPLER since you can say: type AffineTraversal s t a b = forall p. (Strong p, Choice p) => a `p` b -> s `p` t
00:58:28 <bqv> Hmm
00:58:34 <dminuoso> bqv: So the issue with Pointed is just, you'd have to modify the Applicative class
00:58:49 <bqv> Fair
00:58:54 <dminuoso> such that `class Pointed f => Applicative f where (<*>) :: f (a -> b) -> f a -> f b`
00:59:03 <dminuoso> so this is not a change you can simply ship in a library
00:59:18 <dminuoso> You'd have to provide your own applicative class, which is then not compatible with Applicative, and so on..
00:59:56 <bqv> Another FMA-level reshuffle
01:00:43 <dminuoso> So if you dont do that superclass, then you cant compose an affine traversal with say a traversal and obtain a traversal.
01:00:57 <dminuoso> So you get a lot of inelegancy from that
01:05:17 <dminuoso> bqv: For additional thoughts, refer to http://oleg.fi/gists/posts/2017-03-20-affine-traversal.html
01:08:21 <bqv> I was linked that earlier, interesting
01:09:03 <dminuoso> bqv: phadej has quite a few entries on optics and profunctor optics, you should check the rest of his blog
01:54:56 <idnar> bqv, dminuoso: the laws are also awkward because `(Pointed f, Ap f) => f` doesn't necessarily follow the Applicative laws (see thread at <https://www.reddit.com/r/haskell/comments/60fha5/affine_traversal/>)
01:55:46 <dminuoso> What laws?
01:58:10 <idnar> https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Applicative.html#t:Applicative
01:58:47 <dminuoso> No I meant, in what sense wouldnt that follow the applicative laws?
02:02:04 <idnar> in the sense that you can define lawful Pointed and Ap instances that don't combine to fulfil the Applicative laws
02:02:23 <dminuoso> well that isnt really saying much
02:02:41 <merijn> idnar: lawful Pointed instances are trivial
02:02:45 <merijn> There are no laws
02:02:48 <dminuoso> laws are a contracts between the programmer and the compiler
02:02:52 <dminuoso> its your job to ensure coherence
02:03:08 <dminuoso> If you write Pointed an Ap instances that dont follow laws, that's on you
02:03:40 <idnar> the thread covers the issues with various solutions to that, I don't think I can adequately summarize it
02:04:54 <idnar> err I meant to link https://www.reddit.com/r/haskell/comments/60fha5/affine_traversal/df6830k/
02:14:52 * hackage js-chart 2.9.4 - Obtain minified chart.js code  https://hackage.haskell.org/package/js-chart-2.9.4 (jonascarpay)
02:32:22 * hackage ghc-typelits-extra 0.4.1 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.4.1 (ChristiaanBaaij)
02:33:42 <dminuoso> Well, these are just ergonomics and elegancy issues
02:34:10 <dminuoso> There could be things just Pointed, things just Ap, and things that are Applicative (which satisfy laws common to both)
02:34:24 <dminuoso> or rather, there's an interaction between these laws
02:35:33 <dminuoso> the thread is an interesting read tho
02:39:09 <dminuoso> % (:+) :: Char -> Int -> Char
02:39:09 <yahb> dminuoso: ; <interactive>:36:1: error:; * Couldn't match type `Complex Int' with `Char'; Expected type: Char -> Int -> Char; Actual type: Int -> Int -> Complex Int; * In the expression: (:+) :: Char -> Int -> Char; In an equation for `it': it = (:+) :: Char -> Int -> Char
02:39:14 <dminuoso> Huh
02:39:19 <dminuoso> % (:+++++) :: Char -> Int -> Char
02:39:19 <yahb> dminuoso: ; <interactive>:37:1: error: Data constructor not in scope: (:+++++) :: Char -> Int -> Char
02:39:37 <dminuoso> Why is this looking in the data constructor namespace?
02:40:02 <dminuoso> Or is value level : always understood to be constructors?
02:40:06 <merijn> Because it starts with a :
02:40:08 <merijn> Yes
02:41:05 <merijn> : is the "capital" operator symbol
02:41:06 <dminuoso> Ah fair enough, +: it is then.
02:41:20 <dminuoso> merijn: Ah I guess its similar to how : is for type constructors in the type level?
02:47:05 <invaser> Hi! Does anyone have a good guide to project management with cabal and testing in Haskell?
02:47:28 <dminuoso> invaser: What do you mean by project management exactly?
02:47:59 <invaser> dminuoso: idk, probably some materials on how to work with cabal, best practices etc
02:48:45 <dminuoso> invaser: cabal has a very comprehensive and good documentation
02:49:04 <invaser> that's probably a good place to start
02:49:14 <dminuoso> mmm, not as much for testing though it seems
02:50:46 <invaser> i'm writing my coursework with haskell, so I'm quite excited to start working on it! Though it's the first time I needed to manage project that's more that a single file, so I thought I need to learn about stack before starting
02:53:26 <dminuoso> invaser: so essentially a test-suite is similar to an executable component in cabal
02:53:52 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.1.4.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.1.4.0 (OleksandrZhabenko)
02:55:54 <dminuoso> invaser: See also https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=test-suite#test-suites
02:56:59 <dminuoso> That's for configuring a test suite in .cabal files
02:57:04 <dminuoso> You can execute them with `cabal test`
02:57:38 <dminuoso> (Well, the linked section has it all)
02:57:41 <dminuoso> It's not much though
03:29:52 * hackage generic-aeson 0.2.0.11 - Derivation of Aeson instances using GHC generics.  https://hackage.haskell.org/package/generic-aeson-0.2.0.11 (ErikHesselink)
03:33:09 <merijn> invaser: You have seen https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html already?
03:46:20 <invaser> merijn: No, I haven't
03:47:24 <merijn> invaser: In general the cabal docs there are quite complete, but you probably wanna distill it down to something more minimal and directly usable for a course
03:48:00 <invaser> Ok, but I intend to use stack though. Are cabal docks relevant to it?
03:48:08 <merijn> ah, then no :p
03:48:18 <merijn> Or, well, a bit
03:48:45 <merijn> invaser: Actually, if you're gonna write anything about Haskell tooling for others, make sure you read this first: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07 :)
03:51:14 <merijn> invaser: Chapter 4/7/10 of those cabal docs are relevant to points 1 & 2 from that gist, and thus also relevant for stack users (if only as reference for .cabal files)
04:00:52 * hackage magicbane 0.5.0 - A web framework that integrates Servant, RIO, EKG, fast-logger, wai-cli…  https://hackage.haskell.org/package/magicbane-0.5.0 (myfreeweb)
04:04:41 <dminuoso> Id like to see the transitive dependency tree on magicbane.
04:05:26 <merijn> You mispelled transitive dependency *forest* :p
04:06:41 <dminuoso> heh
04:11:00 <dminuoso> Does GHC haskell expose exit(2) somewhere?
04:11:39 <merijn> unix has it
04:12:08 <dminuoso> https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Process.html#v:exitImmediately
04:12:10 <dminuoso> Perfect, thanks
04:23:52 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.2.0.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.2.0.0 (OleksandrZhabenko)
04:25:13 <bqv> hey, the lens operator `^@?`
04:25:22 <bqv> is there a non operator form of it
04:25:27 <bqv> or do i have to manually fold and head
04:26:41 <dminuoso> "non operator"?
04:26:56 <dminuoso> You can use ^@?! 
04:27:07 <dminuoso> but you must use non yourself I guess?
04:27:23 <dminuoso> so: f . non blah ^@?! s
04:27:28 <bqv> i mean word form
04:27:32 <bqv> trying to avoid the operators
04:27:43 <bqv> e.g. ^. -> view
04:27:47 <bqv> .~ -> set
04:27:48 <dminuoso> well sure
04:27:51 <dminuoso> you can just look at the implementation
04:27:58 <dminuoso> they're just simple ifoldrOf
04:28:06 <dminuoso> s ^@? l = ifoldrOf l (\i x _ -> Just (i,x)) Nothing s
04:28:17 <dminuoso> Also, you can bind it to a name yourself if you want
04:28:48 <bqv> damn, that's a pretty spicy expression though
04:30:41 <dminuoso> % :t foldr
04:30:42 <yahb> dminuoso: forall {t :: * -> *} {a} {b}. Foldable t => (a -> b -> b) -> b -> t a -> b
04:30:53 <dminuoso> % :t ifoldrOf
04:30:54 <yahb> dminuoso: forall {i} {r} {s} {a}. IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r
04:31:02 <dminuoso> % :t foldrOf
04:31:03 <yahb> dminuoso: forall {r} {s} {a}. Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r
04:31:06 <dminuoso> Do you see how they are similar?
04:31:29 <dminuoso> % :t foldrOf id
04:31:29 <yahb> dminuoso: forall {s} {r}. (s -> r -> r) -> r -> s -> r
04:31:33 <dminuoso> % :t foldr
04:31:33 <yahb> dminuoso: forall {t :: * -> *} {a} {b}. Foldable t => (a -> b -> b) -> b -> t a -> b
04:31:59 <dminuoso> % :t foldrOf folded
04:31:59 <yahb> dminuoso: forall {f :: * -> *} {a} {r}. Foldable f => (a -> r -> r) -> r -> f a -> r
04:36:57 <tomsmeding> are those hidden type parameters?
04:52:49 <bqv> ah
04:52:52 <bqv> i can use pre
04:52:54 <bqv> and ipre
04:52:57 <bqv> that's way nicer
04:53:44 <bqv> wait
04:53:47 <bqv> that's what preview is
04:53:53 <bqv> goddammit
04:54:06 <bqv> dminuoso: ipreview
05:12:08 <tomsmeding> dminuoso: "Id like to see the transitive dependency tree on magicbane."
05:12:09 <tomsmeding> https://tomsmeding.com/f/hackage-magicbane.png
05:13:24 <tomsmeding> (actual version resolution not performed, just taken the list of links on hackage.haskell.org/package/$pkgname/dependencies)
05:13:51 <merijn> That doesn't work for conditional ones :)
05:14:21 <tomsmeding> also true
05:16:08 <tomsmeding> the bash script has 42 lines though, not going to change that
05:17:59 <int-e> "only" 160 packages
05:18:11 <int-e> (but that's an actual install plan)
05:18:20 <hekkaidekapus> You can build it locally and `cabal-plan dot-png`.
05:18:48 <tomsmeding> I was attempting to get a graph _without_ building the thing :p
05:18:57 <int-e> I don't find graphviz generated images all that useful at this scale
05:19:07 <tomsmeding> int-e: the image is completely useless
05:19:14 <tomsmeding> did I ever say it was useful? :)
05:19:21 <int-e> did I write "completely useless"?
05:19:38 <int-e> (two can play that game)
05:19:44 <tomsmeding> fair point :)
05:19:46 <hekkaidekapus> `cabal-plan dot` only then. And import the graph in any other former of your liking.
05:20:40 <int-e> tomsmeding: it's embarrassing how many edges end in ghc-prim at the bottom :P
05:21:02 <tomsmeding> lots of packages that perform hacks? :p
05:21:03 <int-e> Conclusion: Haskell sucks at abstraction.
05:21:09 <maerwald> lol
05:21:46 <tomsmeding> 45 edges to be exact
05:22:03 <tomsmeding> aeson base ghc-prim integer-gmp integer-simple bytestring deepseq binary hashable text template-haskell pretty integer-logarithms transformers semigroups tagged transformers-compat generic-deriving th-abstraction bifunctors base-orphans distributive contravariant void data-fix strict these vector haskell-src-exts th-orphans th-lift ekg-core cryptonite basement memory data-default-class psqueues
05:22:03 <tomsmeding> zlib warp text-show http-client network-uri cereal clock QuickCheck
05:22:23 <tomsmeding> I guess most make sense?
05:22:44 <maerwald> are there any good resources on how to convert your haskell data appropriately for C?
05:22:57 <maerwald> despite primitive types
05:23:12 <bqv> like storable or..?
05:23:18 <maerwald> I'm thinking just string and use json under the hood :p
05:23:38 <bqv> spicy modern marshalling
05:23:41 <bqv> web scale
05:23:52 <maerwald> yes, can also make it a microservice later
05:23:56 <bqv> :D
05:24:31 <dminuoso> tomsmeding: good lord
05:25:21 <dminuoso> tomsmeding: to be fair, you should probabl do transitive reduction.
05:25:54 <tomsmeding> meaning, if a->b->c and a->c, don't display a->c ?
05:26:02 <dminuoso> yeah, cabal-plan can do that for you with -tred
05:26:17 <dminuoso> (or rather, given those two a->b->c would be hidden)
05:26:42 <tomsmeding> with a->b->c I meant a->b and b->c
05:26:47 <tomsmeding> hiding those loses information, right?
05:26:56 <tomsmeding> can I use cabal-plan without actually building the thing?
05:27:02 <dminuoso> well, so assume you have `a->c`, `a->b` and `b->c`
05:27:10 <dminuoso> with transitive reductions the last would be gone
05:27:29 <dminuoso> tomsmeding: you can abort as soon as it starts building
05:27:32 <dminuoso> you just need the cabal plan
05:28:18 <int-e> dminuoso: is that fair? you depend on a package explicitly if you use its functionality. with your suggestion, all the edges to ghc-prim would be gone... (I guess the question is what you want to express... for building plan purposes, transitive reduction is fine; for semantic dependencies, the transitive edges carry information)
05:28:24 <tomsmeding> interesting choice to remove b->c, I guess it makes sense if you're not interested in the dependencies' subtrees, just where everything comes from in relation to the top package
05:28:46 <int-e> (all -> all except the integer-gmp one, I'd guess)
05:29:19 <dminuoso> int-e: it depends on what knowledge you hope to gain. tred is usually helpful with dependency graphs because you don't necessarily care which packages exactly depend on integer-gmp, because as soon as *any* depends on it, you have it.
05:29:36 <dminuoso> (so you might rather be interested which package "first" depends on it from top-to-bottom)
05:30:11 <int-e> so yeah, it depends on what you're trying to do
05:31:25 <tomsmeding> interesting, I can't even seem to get a build plan
05:31:56 <int-e> I had to go back to ghc-8.6.5
05:33:27 <bqv> goddammit, no wonder i've been getting cursed type errors
05:33:33 <bqv> i've been using two lens libraries by accident
05:33:58 <bqv> one of these optics is not like the other
05:34:31 <hekkaidekapus> tomsmeding, int-e: give stack2cabal a try, otherwise the package is not in a good shape. <https://matrix.hackage.haskell.org/#/package/magicbane>
05:35:11 <int-e> meh
05:36:43 <int-e> though tbf I wasn't going to compile it anyway
05:36:45 <dminuoso> hekkaidekapus: what does stack2cabal do?
05:37:10 <dminuoso> I mean in order to find a build plan, it shouldnt be necessary
05:37:16 <maerwald> dminuoso: it creates a cabal.project and cabal.project.freeze based on stack.yaml
05:37:25 <hekkaidekapus> It converts a stack resolver into a cabal.freeze and creates a .cabal file.
05:37:26 <dminuoso> For the above excercise, hpack should be fine
05:37:40 <dminuoso> (because losing constraints actually would help)
05:37:47 <maerwald> dminuoso: depends, if there are git repos defined in stack.yaml, hpack won't be enough
05:37:59 <dminuoso> ah
05:38:19 <int-e> mmm -- This file has been generated from package.yaml by hpack version 0.34.2.
05:38:36 <int-e> (that's from the package description on hackage)
05:39:49 <hekkaidekapus> int-e: Yeah, if you look at <https://github.com/myfreeweb/magicbane>, there is no magicbane.cabal. I guess it is generated as part of the upload process.
05:41:01 <tomsmeding> fwiw dependency graph using cabal-plan: https://tomsmeding.com/vang/Wsf6Q2/deps.png; I thought I could improve my graph by making it left-to-right as well but it's a similar mess
05:41:40 <tomsmeding> (ghcup is cool)
05:42:50 <hekkaidekapus> (Went down from 20.9M to 5344k.)
05:43:34 <dminuoso> Mmm, I feel like there could be more transparency with regard to build plans and transitive dependencies.
05:43:45 <dminuoso> It's too easy to lose track of how much you pull in time after time
05:44:23 <tomsmeding> perhaps this kind of functionality should be more accessible? Confronting people with the transitive dep graph may be helpful
05:44:44 <tomsmeding> though it's probably hard because the build plan may be different for any particular base version and such
05:44:52 * hackage morley 1.9 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.9 (gromak)
05:45:13 <dminuoso> Well you cant do that on hackage, because transitive dependencies depend on a particular build plan
05:45:28 <dminuoso> right
05:45:52 * hackage lorentz 0.7.1 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.7.1 (gromak)
05:48:01 <maerwald> well, start by telling me how I get a build plan with stack
05:48:22 <maerwald> I actually need that. One reason would be to compare its build-plan with a cabal generated one
05:53:40 <dminuoso> maerwald: hekkaidekapus linked a tool above to do that
05:53:51 <dminuoso> or..
05:53:53 <dminuoso> no mmm
05:55:56 <maerwald> dminuoso: yes, I maintain that. But you still have no guarantee that you have the exact same build plan
05:56:16 <maerwald> e.g. one problem is that cabal may treat git repos a little different
05:58:04 <hekkaidekapus> In short, it would be good if there were a stack-lib published somewhere.
05:58:23 <maerwald> that too
06:03:40 <maerwald> and if stack and cabal can agree on an API :)
06:03:47 <maerwald> (lolo)
06:05:42 <tomsmeding> microsoft attempted to make windows and linux agree on an API
06:05:52 * hackage purescheme-wai-routing-core 0.1.1.0 - Simple Routing functions for Wai Applications  https://hackage.haskell.org/package/purescheme-wai-routing-core-0.1.1.0 (frincon)
06:05:59 <hekkaidekapus> You mean, update the Cabal spec?
06:06:06 <tomsmeding> the thought may not be as ridiculous as it sounds
06:06:10 <xenon-> hi. I'm trying to use aeson to reason third party json file, and I'm getting key not present error, because fields start with upper case letter, unlike fields in haskell object. how can I get around this?
06:06:37 <xenon-> s/reason/read
06:06:39 <dminuoso> xenon-: write out the instance manually
06:07:05 <xenon-> that is the only way? 
06:07:40 <dminuoso> Its possible you can tweak the generic options
06:08:28 <xenon-> did some googling while asking the question.. this seems promising. http://hackage.haskell.org/package/aeson-casing-0.2.0.0/docs/Data-Aeson-Casing.html
06:08:38 <dminuoso> xenon-: Refer to https://hackage.haskell.org/package/aeson-1.5.4.1/docs/Data-Aeson.html#t:Options
06:09:04 <dminuoso> xenon-: honestly, Id just write out the instance by hand
06:09:24 <dminuoso> It's doesnt take much effort, and it makes this contract explicit
06:09:48 <dminuoso> But, you can override fieldLabelModifier for the generic json parser options
06:09:49 <dminuoso> To do what you want
06:10:34 <dminuoso> There's a few reasons to do manual implementatoins
06:10:57 <dminuoso> 1) Multiple versions. You cant do this trivially with the typeclass+generics approach, without a lot of inelegance
06:11:32 <dminuoso> 2) It lets you decouple your haskell code from external representation (and codify this interface with Haskell, rather than implicit generics)
06:13:24 <xenon-> I'm using older aeson version, there's no Data.Aeson.Casing
06:13:26 <dminuoso> The latter can be done if you have separate data types for just the external representation, but this works better if you're the one defining the JSON API, rather than trying to conform to some outside format
06:13:38 <xenon-> I'll try that option, if that fails I'll just write manual instance
06:14:36 <tomsmeding> xenon-: side note: "there's no Data.Aeson.Casing" might be because that's in a different package (aeson-casing)?
06:15:34 <lortabac> dminuoso: IMHO both versioning and external representation should be dealt with by defining multiple data types
06:15:55 <xenon-> tomsmeding, oh
06:16:25 <lortabac> encoding any logic into the deserialization part means doing Python in Haskell (with worse syntax)
06:16:26 <tomsmeding> though please heed dminuoso's recommendations :p
06:17:23 * hackage purescheme-wai-routing-core 0.1.2.0 - Simple Routing functions for Wai Applications  https://hackage.haskell.org/package/purescheme-wai-routing-core-0.1.2.0 (frincon)
06:17:36 <dminuoso> lortabac: Im willing to argue that this is incorrect. In case of python style code, you usually implicitly decode into Python structures, but it's still not really de-serialized.
06:18:01 <dminuoso> Either you have an additional layer where you transform your "jsonDeserializedIntoDict" data into some domain specific objects with error handling
06:18:20 <dminuoso> Or, which is more common and much worse, you just use this the basis of control flow
06:18:24 <dminuoso> Whatever the user specifies
06:18:56 <dminuoso> We're better off in Haskell because we can actually meaningfully parse the data into domain specific data types and have error handling. In Python you get "whatever"
06:19:48 <lortabac> dminuoso: what I meant is: it is better to keep the JSON instances straightforward and define one data type for each version (or each layer of the application)
06:20:01 <dminuoso> JSON is not a protocol format, the act of "destructuring the payload" needs to be done either way. With Python you just do it on dicts/lists/numbers/whatever, in Haskell you do it on `data Value = ...`
06:20:03 <lortabac> rather than encoding versioning logic into the JSON instances
06:20:05 <dminuoso> Ah
06:20:11 <cohn> speaking of DSLs, does Haskell have a good tokenizer library?
06:20:19 <dminuoso> cohn: attoparsec/megaparsec?
06:20:59 <dminuoso> Do you need it streaming?
06:21:05 <xenon-> tomsmeding, thanks, that worked! I'll prolong learning how to write custom instance when I need it
06:21:52 * hackage purescheme-wai-routing-core 0.1.3.0 - Simple Routing functions for Wai Applications  https://hackage.haskell.org/package/purescheme-wai-routing-core-0.1.3.0 (frincon)
06:23:16 <lortabac> dminuoso: I prefer implementing 'UserV1 -> UserV2' or 'DBUser -> APIUser' rather than 'Value -> Value'
06:23:39 <dminuoso> lortabac: Not quite sure what you mean by that
06:23:48 <cohn> dminuoso: nah, just curious
06:24:25 <dminuoso> cohn: also, there's alex if you want something like flex
06:25:07 <cohn> oh nice, thanks dminuoso!
06:30:43 <lortabac> dminuoso: you gave two reasons not to use aeson's generic helpers, I'm saying it doesn't matter because deserialization is not the best place to achieve versioning or decoupling
06:31:48 <dminuoso> lortabac: It depends on the details, I guess. If you have just represntation format changes, then this is better done in code than extra data types.
06:33:54 <lortabac> I don't know, generic aeson instances work in 95% of cases for me, if a field name changes I generally change it in the data type
06:36:58 <tanksgiving> hi
06:37:20 <dminuoso> Amusing nickname. :>
06:37:28 <dminuoso> Hi.
06:37:42 <tanksgiving> how you mean?
06:37:49 <dminuoso> I find your nickname amusing.
06:38:28 <tanksgiving> can you explain?
06:38:45 <dminuoso> Explain amusement?
06:38:52 * hackage aeson-commit 1.3 - Parse Aeson data with commitment  https://hackage.haskell.org/package/aeson-commit-1.3 (jonascarpay)
06:38:53 <tanksgiving> yes
06:39:12 <dminuoso> amusement /əˈmjuːzm(ə)nt/
06:39:13 <dminuoso> 1. the state or experience of finding something funny.
06:39:21 <bahamas> is there any haskell library that models stochastic processes? I'm asking, because I'm hoping I will understand them better if I see them expressed as Haskell code rather than the mathematical notation
06:40:09 <dminuoso> bahamas: There is https://hackage.haskell.org/package/stochastic
06:40:28 <dminuoso> Also https://hackage.haskell.org/package/probability
06:40:52 * hackage js-chart 2.9.4.1 - Obtain minified chart.js code  https://hackage.haskell.org/package/js-chart-2.9.4.1 (jonascarpay)
06:40:58 <dminuoso> You might also find this of interest https://hackage.haskell.org/package/monad-bayes
06:41:51 <bahamas> thanks. I knew about probability, but not stochastic
06:42:28 <bahamas> I think it might help me if I try to encode the concepts as Haskell myself
06:42:52 * hackage elynx-markov 0.5.0 - Simulate molecular sequences along trees  https://hackage.haskell.org/package/elynx-markov-0.5.0 (dschrempf)
06:43:52 * hackage elynx 0.5.0, tlynx 0.5.0, slynx 0.5.0, elynx-tree 0.5.0, elynx-tools 0.5.0, elynx-seq 0.5.0, elynx-nexus 0.5.0 (dschrempf)
06:48:07 <tanksgiving> hi guys
06:59:52 * hackage mcmc 0.3.0 - Sample from a posterior using Markov chain Monte Carlo  https://hackage.haskell.org/package/mcmc-0.3.0 (dschrempf)
07:30:12 <maerwald> https://www.sciencedirect.com/science/article/abs/pii/S0096055101000066 hmmm... I'm a poor student. Is there an open draft or a blog post explaining this?
07:30:26 <maerwald> (lenient evaluation)
07:30:27 <merijn> *cough* scihub
07:30:40 <merijn> Also, did you try google scholar yet?
07:31:01 <merijn> Google Scholar is usually pretty good at turning up PDFs strewn about the web
07:31:11 <maerwald> well, I'm asking quite general... doesn't have to be this paper
07:32:19 <merijn> Both recommendations still apply ;)
07:33:14 <merijn> Also, even as non-poor non-student people shouldn't be paying for papers or I will haunt you for the rest of your life >.>
07:33:44 <merijn> maerwald: Google immediately turns up a copy on psu.edu: https://scholar.google.com/scholar?q=%22Lenient+evaluation+is+neither+strict+nor+lazy%22
07:34:32 <maerwald> oh
07:35:15 <merijn> I have about 80% success rate turning up free PDFs by just copy pasting titles into Google Scholar
07:35:46 <mniip> oh, you have to click "all 8 versions"
07:35:46 <maerwald> I just completely missed the hanging pdf link
07:36:07 <mniip> I was able to download a pdf off sciencedirect though
07:36:17 <mniip> may or may not be because I'm on campus
07:36:34 <merijn> mniip: Sometimes, depends on which version it lists first
07:48:52 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.2.1.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.2.1.0 (OleksandrZhabenko)
08:21:31 <Ferdirand> base has Data.Complex, but does it has something for perplex numbers (aka split complex/hyperbolic numbers) ?
08:22:51 <merijn> I've never heard of those, so probably not?
08:42:39 <tomsmeding> wouldn't be hard to build, wouldn't it?
09:19:07 <dminuoso> maerwald: "poor student" meaning what exactly?
09:19:19 <dminuoso> You have lost your bookmark to sci*cough*hub?
09:53:18 <maerwald> I was just trying to trigger merijn into explaining it to me :p
11:04:53 * hackage polysemy-extra 0.1.1.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.1.0 (locallycompact)
11:37:17 <samlamamma> I currently install ghc through my distro's package manager. Can you instead use Cabal or Stackage to upgrade ghc? My ghc gets updated quite slowly
11:37:37 <maerwald> samlamamma: https://www.haskell.org/ghcup/
11:38:11 <geekosaur> not presently, but there's ghcup. or stack can install ghc for its own use, and you can get to it indirectly via stack exec
11:39:33 <geekosaur> ghcup is probably the best way currently
11:39:54 <maerwald> merijn: I'm not too convinced of lenient. So all it gives over strict is recursively defined data structures. Then again, I see papers solving that problem in strict languages anyway
11:41:59 <samlamamma> Thank you! Currently installing :-)
11:42:31 <maerwald> and the paper makes a few good argument pro lazy, in fact
11:44:47 <maerwald> evaluating arguments in parallel sounds like a cool thing though
11:46:49 <dminuoso> maerwald: In principle, that's non-strictness though.
11:46:54 <maerwald> yes
11:46:58 <maerwald> lenient is non-strict
11:47:06 <dminuoso> Right, Im just saying GHC could do this as well
11:47:12 <maerwald> potentially
11:47:27 <dminuoso> The language has considerations for that, in fact.
11:47:33 <maerwald> But the error behavior would be more like a strict language that a lazy one
11:47:41 <maerwald> *than
11:47:52 <dminuoso> The way seq is defined for instance, does not guarantee that in   x `seq` y   x is forced *before* y.
11:48:06 <dminuoso> The report is very careful in that regard, as is the ghc/base implementation
11:48:31 <dminuoso> (That was done to allow for implementations speculatively forcing x)
11:48:36 <dminuoso> perhaps in parallel
11:52:24 <samlamamma> Quick question: ghcup asked me if I wanted haskell language server, I said YES. Then I updated my ghc using ghcup, do I then also need to update HLS through ghcup?
11:53:09 <maerwald> samlamamma: it manages HLS too, yes
11:53:38 <maerwald> I don't think hls currently has a self-updater either
11:58:04 <samlamamma> Yeah, I was just confused because it said the latest version was installed of HLS. Turns out it downloaded all of the binaries of HLS for the varying GHCs that it supports
11:58:18 <maerwald> yes
11:59:24 <samlamamma> OK, gonna restart Emacs and try out HLS :-)!
12:00:20 <maerwald> this is why my IRC client doesn't run inside my editor :p
12:01:00 <Uniaika> :'')
12:02:04 <geekosaur> mine runs in my browser, which is almost as bad >.>
12:02:15 <dminuoso> geekosaur: those three can be the same!
12:02:52 <geekosaur> yes, which makes even less sense
12:02:54 <maerwald> Yeah, I also prefer the github online editor
12:03:05 <maerwald> with a fake gpg sig
12:03:14 <geekosaur> admittedly most things in the browser only require reloading a page, not the whole browser
12:03:22 <geekosaur> except once a week…
12:06:20 <monochrom> every software evolves until it contains an email client and an operating system
12:06:55 <maerwald> systemd already has an email client right?
12:07:06 <davean> Clearly the correct approach is for your editor and web client to run inside your IRC client.
12:07:11 <monochrom> wait what? hahaha
12:08:01 <dminuoso> Microsoft went the other way, start with the browser and then build the editor inside it.
12:08:16 <maerwald> davean: just need a tmux wrapper in weechat and you're good to go
12:08:55 <monochrom> davean: That would be http://hackage.haskell.org/package/manatee
12:09:41 <monochrom> The author believed that an IDE for Haskell needed: a web browser for the docs, an editor for the code, and an IRC client for #haskell
12:10:25 <davean> They were mostly right. They just missunderstood IRC
12:10:37 <davean> its for #ghc to report the compiler bugs
12:10:45 <monochrom> haha
12:11:01 <dminuoso> Love how manatee doesnt even come with haddocks on hackage.
12:11:22 * hackage prolude 0.0.0.7 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.7 (saramuse)
12:11:32 <monochrom> perhaps because gtk build difficulty on hackage
12:11:47 <monochrom> Plus it's also pretty old code.
12:12:06 <monochrom> As usual, the author joined a bank and never showed up here again.
12:12:58 <davean> Haskell does drive people to banking
12:13:12 <dminuoso> We drive networking with haskell
12:14:45 <monochrom> #haskell is like little colony depicting in the movie The Island
12:15:22 <monochrom> Every once in a while, we welcome a beginner with "yay you're finally rescued from the poisonous imperative world outside! It's safe here."
12:16:10 <Rembane> And then they get snatched up by a bank.
12:16:10 <monochrom> Also every once in a while, a lottery sends one of us to "the FP banking paradise" and whoever are sent will be never seen here again.
12:25:52 * hackage ghc-check 0.5.0.2 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.5.0.2 (PepeIborra)
12:28:07 <maerwald> xD
12:29:15 <maerwald> haskell is just a way to get better salary now without 20 years of Java industry experience... true laziness?
12:29:37 <pjb> Yes.
12:30:13 <Uniaika> wonderful
12:42:37 <merijn> monochrom: Are you sure that's not a secret sacrifice to the old ones?
12:55:22 * hackage phonetic-languages-examples 0.3.2.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.3.2.0 (OleksandrZhabenko)
13:04:28 <Feuermagier_> How hard is Djikstra in Haskell? - I've implemented it in other languages successfully, but am new to Haskell would like to try an implementation.
13:05:54 <merijn> *Dijkstra
13:06:20 <merijn> It depends on what data structure you wanna implement it on?
13:09:28 <Feuermagier_> merijn, I know barely anything about datastructures in haskell. I'll probably have to learn about them in the process.
13:09:46 <merijn> What did you use in other languages?
13:10:01 <koz_> Feuermagier_: I think what merijn wants to know is 'how did you want to represent your graph?'.
13:10:07 <koz_> Like, adjacency matrix, adjacency list, some other thing?
13:10:10 <merijn> That, yeah
13:10:20 <koz_> (algebraic graph if you wanna flex)
13:10:23 <merijn> koz_: Clearly CSR is superior :p
13:10:27 <koz_> CSR?
13:10:53 <merijn> Compressed Spare Row (usually a representation for sparse matrices, but then again, what is a graph if not a sparse matrix)
13:11:05 <koz_> Ah, so 'not terrible adjaceny matrix'.
13:11:24 <koz_> s/adjaceny/adjacency/
13:11:37 <koz_> (that word's spelling annoys me)
13:11:45 <koz_> (it should be 'ajasensy')
13:12:47 <Feuermagier_> I'll probably go for an adjecenjy matrix or list
13:20:08 <justsomeguy> Is there something special about singly-linked lists that makes it easier to use without direct mutation than arrays or doubly-linked lists? There seems to be a special emphasis on the list type, and I'm trying to figure out why.
13:20:23 <koz_> justsomeguy: Mostly legacy. Lists were all the rage back then.
13:20:36 <merijn> That's an oversimplification
13:20:47 <merijn> Linked lists are basically "loops as data structure"
13:20:56 <merijn> Loops are common, therefore lists are common
13:21:40 <koz_> Someone said (I think it was solonarv?) that lists are a great control structure, but a terrible data structure.
13:21:43 <merijn> justsomeguy: doubly-linked lists are hard/annoying to build if you don't have mutation, because well, if how are you going to set all "next" *and* "previous" links simultaneously
13:22:29 <dolio> They're not a terrible data structure.
13:22:55 <koz_> dolio: My quote may be lacking context.
13:23:00 <koz_> (and in fact, likely is)
13:27:19 <dolio> Well, that is the essence of the problem. It makes no sense to call something a "terrible data structure" without context. And lists are fine for a lot of common uses.
13:28:37 <dolio> You don't always need to access both sides or index into or find something in a collection of things, or any number of other operations that are suboptimal on lists.
13:30:26 <justsomeguy> I guess it may be easier to share parts of a list that are unchanged, since you don't have to keep them contiguously in memory, and you can just change the linkages between cons cells.
13:31:05 <crdrost> for that matter there is a duality between data structures and the control structures that consume them, it doesn't make sense to say that the control structure is great but the data structure is terrible, they're the same thing
13:40:32 <dolio> Sharing is the definite difference between singly linked lists and the other two examples. Tails of immutable singly linked lists can be shared. Nothing in the structure of an immutable array or doubly linked list can be shared.
13:40:53 * hackage phonetic-languages-examples 0.3.3.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.3.3.0 (OleksandrZhabenko)
13:41:52 * hackage uniqueness-periods-vector-examples 0.14.3.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.14.3.0 (OleksandrZhabenko)
13:43:52 * hackage semibounded-lattices 0.1.1.0 - A Haskell implementation of semibounded lattices  https://hackage.haskell.org/package/semibounded-lattices-0.1.1.0 (xuhao)
13:47:58 <justsomeguy> This is reminding me of how commits in git can be changed while still being mostly immutable.
13:49:07 <merijn> dolio: Sure it can, you just can never mutate it afterwards :p
13:49:43 <merijn> And the use for a datastructure where you can never insert/delete something is rather small
13:50:14 <justsomeguy> Do the "links" in a singly-linked list point backwards (or forwards)?
13:50:18 <dolio> No sharing can happen with only one person.
13:50:40 <merijn> justsomeguy: That's a matter of perspective :p
13:53:28 <dolio> 'I shared the cake with myself by eating the whole thing.' :P
13:56:18 <pjb> Well, if you sell the cake to yourself, you can also have it, but not entirely, since then you'll have to pay to the state value added tax, and income tax.
13:58:50 <monochrom> For Dijkstra's algorithm, the input graph format being as a bunch of adjacency lists is fairly uncontroversial, and it really doesn't matter what you use for "list" because you're just traversing it in one direction.
13:59:38 <monochrom> The hard part though is what you use to track "has this vertex been visited?" and to track the priority queue.
14:00:23 <monochrom> To be fair, the priority queue part is annoying even in imperative languages with mutable data structures.
14:01:27 <monochrom> Because you have to support the operation "look up by vertex (emphatically not by priority) and bump down it's priority".
14:01:54 <koz_> monochrom: Yeah, changeKey is something that I remember my own data structures course being incredibly glib about.
14:01:55 <monochrom> Most textbooks, especially the imperative ones, simply gross over it.
14:02:07 <koz_> monochrom: 'Gross' over it is 100% the right term.
14:03:04 <monochrom> Well, they don't gross over "if you already have the address of the node, how to bump down its priority".  But they simply refuse to mention "how to find that address in the first place".  It's bordering on scamming.
14:03:36 <monochrom> IMO only Ralf Hinze's "priority search queue" does justice to this topic.
14:06:30 <koz_> monochrom: It goes beyond 'bordering'. I'd argue it's more 'crossing the border then setting up camp on the other side'.
14:06:50 <koz_> The argument I saw amounts to basically yelling 'POINTERS LOL' and that's about it.
14:08:18 <justsomeguy> To insert an element into the middle of a list, don't you still have to do mutation (of previous cons cells link to the next element)? It seems to me that there is still some mutation, even though you can share more of the structure.
14:08:29 <koz_> justsomeguy: You copy everything preceding it.
14:08:37 <koz_> Then tail-share the rest.
14:09:52 <justsomeguy> This is kind of fun :)
14:16:49 <lucente> hey, I have completed tic-tac-toe, expect for some minor errors in loop. Could you give me a hand? Particular problem is explained right on the end of comment inside the code. Code: https://ideone.com/XuLTsy
14:22:59 <hekkaidekapus> lucente: Add these 3 lines at the top of your file:
14:23:01 <hekkaidekapus> module Main ( main ) where
14:23:10 <hekkaidekapus> main :: IO ()
14:23:19 <hekkaidekapus> main = pure ()
14:25:35 <merijn> lucente: 10 dollars says the missing 8,8 is due to lack of final newline and line-buffered stdout :p
14:25:42 <merijn> Try using putStrLn instead of putStr
14:25:43 <lucente> hekkaidekapus, done. I write haskell in emacs and load it to ghci.. so I don't get my hands on working with main
14:27:27 <hekkaidekapus> lucente: Those lines are fixing this error: `The IO action ‘main’ is not defined in module ‘Main’` from your pasted code.
14:28:36 <merijn> lucente: As for some general other tips: "ticktack" would probably look nicer if you ditch the if/then/else and use guards, the parentheses on line 59 are all redundant (although, even better would again be to get rid of the if/then/else)
14:29:27 <hekkaidekapus> And `concat . map = concatMap`.
14:29:44 <merijn> I'm guessing the inverted output is due to a logical error in the order you traverse the list, but I'm too lazy to be bothered to think it through
14:33:43 <lucente> merijn, putStrLn gave me the same result
14:34:48 <lucente> hekkaidekapus, my def of concat works alright
14:35:36 <hekkaidekapus> Yeah, it is just a superficial observation along the lines of redundant brackets.
14:36:07 <lucente> thanks for the input guys, however the problem with reversed tic tacs and my under competence the lacks of borders still remains
14:37:52 * hackage co-log-json 0.0.1.0 - Structured messages support in co-log ecosystem.  https://hackage.haskell.org/package/co-log-json-0.0.1.0 (AlexanderVershilov)
14:38:21 <lucente> I have added the main dec as you pointed out however it is not needed when compiled in ghci. The code doesn't look as something the authors had been dreaming of while they were creating it, but at the moment I just want to make it functional.
14:39:16 <hekkaidekapus> Oh, someone else wrote the code?
14:39:55 <hekkaidekapus> By the way, do: `main = pp (ticktack (8, 8) [(1, 1), (8, 8), (2, 2), (3, 3), (4, 2), (3, 2)])`
14:40:42 <hekkaidekapus> to make main useful a bit. But if it is not your code, let’s stop here. Rather, ask what you don’t understand.
14:42:47 <hekkaidekapus> Here is a question for you for instance: why did adding main::IO() fix the compilation error?
14:43:25 <koz_> Another question: is this homework?
14:43:31 <hekkaidekapus> heh
14:43:43 <lucente> hekkaidekapus,  I meant authors of Haskell
14:45:21 <lucente> hekkaidekapus, The very output from the input you posted above is shown in comment section in the code. Because for some reason the compiler won't process the input I give to it. The output shown in comment is equal to what my terminal pops out
14:46:00 <hekkaidekapus> lucente: You have 2 questions so far. We are waiting…
14:46:49 <lucente> It fixed the comp error, because the web compiler required it. Most likely because it doesn't use ghci, so it needs to be declared at the start
14:46:50 <koz_> hekkaidekapus: Async (Answer, Maybe Answer) :P
14:47:18 <lucente> Not gonna lie, it's a homework.
14:48:28 <lucente> Have to point out I am more into structuraly interpreted languages such as C. Haskell really makes my life a hell for anything but math calculations.
14:49:51 <hekkaidekapus> Let’s stick to Haskell. So, what is the web compiler? Is that how you are supposed to turn in the assignment?
14:50:25 <davve> i learned erlang in my functional programming class
14:50:28 <davve> good times
14:51:36 <davve> haskell is something i stumbled onto by xmonad, which gave me an appreciation for it and i totally agree, it's easy to do math, but general programming is possible too: you came to the right place here! :)
14:52:24 <hekkaidekapus> lucente: ghci is an interpreter (aka an interactor). It ‘evaluates’ stuff as you type in. The error you pasted comes from compilation (aka calling ghc one way or another).
14:52:39 <lucente> hekkaidekapus, nah, don't play games. Although thanks guys for trying to help
14:53:24 <lucente> not like I have been around computers since age 10
14:54:00 <hekkaidekapus> Well then, I’m done.
14:54:35 <lucente> davve, I have to say that Haskell looks the most elegant from everything I have ever had my hands on
14:59:21 <lucente> I wish I could somehow teach myself to manage my time smarter and organize the week so I don't end up working on assignments a day before deadline or so. I have already started to use org-mode, but most of the time I lack to will to do things, mainly because I can't find a reason why to do them. Like if everything was meaningless and my life was leading to wrong direction.
15:01:50 <monochrom> I have that procrastination problem too.
15:02:23 <monochrom> Fortunately, Haskell is nicer to work with, and gives me more incentive than average to not procrastinate work related to it.
15:03:32 <Axman6> lucente: hey, pro tip, it's _very_ likely your lecturer is in this channel. Maybe a_ stop being a dick and b) be greatful when people give up their time to help you when they have absolutely nothing to gain by doing it, mmkay?
15:07:03 <lucente> As long as I am concerned I was acting nothing but politely. If someone feels otherwise I am sorry for their misinterpretation of my words. Again I have thanked to everyone who tried to help.
15:07:11 <hekkaidekapus> Axman6: Aye. The worst part is that I just learnt that <https://ideone.com> is really an online compiler!
15:09:12 <Axman6> "nah, don't play games" to someone who is actively helping you, "not like I have been around computers since age 10", lack of humility that you might not actually know everything; we were all using computers when we were 10. none of that is polite
15:11:01 <Axman6> hekkaidekapus: https://godbolt.org is where the real fun is - compare the results from different languages, disassemble them, look at instruction timings etc, it's amazing
15:11:01 <lucente> the hekkaidekapus asked me if I know what compiler is. Firstly would be nice to find out who the initiator was
15:11:52 <koz_> Axman6: Godbolt is really very cool.
15:12:11 <merijn> koz_: Indeed
15:12:16 <hekkaidekapus> Axman6: Yeah, godbolt, that I am aware of. Nice tech!
15:12:25 <merijn> godbolt is a superpower ;)
15:12:32 <koz_> It helped me discover I was inadvertently tripping UB one time.
15:12:42 <koz_> (because honestly, C loves UB)
15:12:53 <Axman6> if hekkaidekapus was asking that then I would assume that was because you appeared not to know. All I saw was asking what "web compiler" you were using, which as far as I can see you didn't answer
15:13:53 * hackage composition-prelude 3.0.0.2 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-3.0.0.2 (vmchale)
15:15:50 <arahael> whats haskell like on apple silicon now? all good or some issues still being resolved?
15:16:58 <hekkaidekapus> arahael: Page angerman because he is the most invested in that (beside Ben), it seems.
15:17:45 <lucente> Axman6, again you are accusing me of actions you have poor knowledge of. The only web compiler was the one I posted in the message. Not like any of this would matter anymore. For the next time just try not to get so harsh on someone in my pants, mkay?
15:22:29 <arahael> hekkaidekapus: thanks!
15:23:13 <arahael> angerman, ben_m:  whats haskell like on apple silicon these days, now that M1 has been released for some apple systems?
15:24:30 <hekkaidekapus> bgamari ^^^
15:24:56 <bgamari> arahael, we are working on it
15:25:07 <bgamari> arahael, I hope that 9.0 will ship with support via the LLVM backend
15:25:37 <Axman6> nice - are there any plans for a native AArch64 backend for GHC?
15:25:38 <bgamari> and angerman is currently working on a native code generator backend which should improve compilation time significantly
15:25:46 <Axman6> <3
15:26:55 <hekkaidekapus> Axman6: <https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3641>
15:26:56 <arahael> bgamari: ah, in the mean time, whats it like developing for the "legacy" intel backend while on apple silicon?
15:27:13 <bgamari> moreover, I just pushed a bunch of fixes which should improve stability in general on ARM and other weak memory models
15:27:15 <Axman6> LLVM doesn't have any form oif ASM -> ASM optimisation utility right?
15:27:33 <arahael> nice, bgamari!
15:27:36 <bgamari> s/other weak memory models/other architectures with weak memory models/
15:27:45 <bgamari> that will certainly ship with 9.0 
15:27:54 * bgamari needs to start backporting
15:27:57 <bgamari> Axman6, it doesn't
15:28:09 <bgamari> arahael, this is a question for angerman
15:28:29 <bgamari> arahael, I did a bit of early bring-up work but frankly I try to avoid apple like the plague
15:28:52 <bgamari> angerman both has a better idea of what he's doing and enjoys it more
15:29:01 <arahael> bgamari: yeah, my day job is ios using swift, so it pays the bills and keeps me invested.
15:29:09 <bgamari> :)
15:29:28 <bgamari> I was able to get an amd64 GHC running on the DTK pretty easly
15:29:30 <bgamari> easily*
15:29:42 <bgamari> building GHC wasn't so easy though due to dependencies
15:29:50 <bgamari> IIRC gmp was problematic
15:29:56 <Axman6> DTK?
15:29:58 <arahael> awesome, i'll be keen to hear from him, i presume his nick's alerted him already!
15:30:17 <Axman6> he's gonna be... so angry
15:30:39 <arahael> Axman6: apple dev kit, it is/was under nda though.
15:30:40 <koz_> Angeryman.
15:30:51 <bgamari> Axman6, the test hardware that we had access to
15:34:37 <angerman> First of all BigSur on arm64 comes with Rosetta, our x86_64 compiler still work.
15:34:53 <arahael> angerman: Yeah, including using it for development?
15:34:53 * hackage data-validation 0.1.2.0 - A library for creating type safe validations.  https://hackage.haskell.org/package/data-validation-0.1.2.0 (sambolias)
15:35:37 <angerman> arahael: well I can use it to build a x86_64 -> arm64 cross compiler. And then a native one.
15:35:53 <arahael> Ah, very very nice.
15:36:00 <angerman> arahael: so I’d say yes. It’s not ideal, but I’m pretty certain it’s workable.
15:36:24 <angerman> Over time we’ll have native arm64 compilers for arm64
15:37:02 <angerman> arahael: here’s a native 9.1 build: https://dl.dropbox.com/s/jskw2pjpkhquj4g/ghc-9.1.0.20201110-aarch64-apple-darwin.tar.xz
15:37:10 <arahael> Awesome, I'm going to get the system then, though not sure when - could still be early next year.
15:38:35 <angerman> I’ll try to get an M1 Mini as soon as I can, but we’ll it’s currently unavailable here ;-)
15:39:24 <arahael> Mine will be an MBP, most likely.  Already have a fallback linux headless desktop I don't intend on replacing.
15:40:11 <arahael> But for serious building stuff, yeah, the mini sounds absolutely appropriate.
15:42:47 <arahael> angerman: Big Sur also works well as well, as far as the haskell ecosystem is concerned?
15:43:27 <arahael> (Ie, ignoring brew, and all that, which I understand are still adapting)
15:47:06 <angerman> A lot of infrastructure is still missing. And eventually you’ll have to deal with x86_64 it arm64 only slices :-/
15:47:47 <arahael> Could you elaborate? 
16:48:14 <angerman> Well we’ve had fat binaries before. But ghc (and some other compilers) are not naitive multitarget compilers. As such they can’t produce fat binaries by default.  As such you’ll end up with only x86_64 or arm64 libraries. Which will become annoying when linking.
16:48:42 <angerman> Unless of course you are very careful to always have the right architecture slices.
16:51:55 <jchia1> Among things like (but not limited to) polysemy, freer, freer-simple, fused-effects, which ones are better in terms of ease-of-use and expressiveness? (I don't really care about performance.)
16:56:55 <jchia1> I just see that among free, freer-effects, fused-effects & polysemy, free has the most dependent packages on hackage.
16:57:07 <jchia1> way more than the others
17:12:53 <arahael> Ah, I see, thanks angerman - it sounds like for x86_64, it'll be relatiely smooth, and if I play with the ARM-native builds, there's still some interim pains to overcome but it sounds pretty surmountable and there's progress.
19:15:13 <jle`> jchia1: so far i've been happy with tranformers and mtl
19:15:45 <jle`> but it depends on the details of your usage 
19:16:26 <jchia1> I just want to start trying out things like free & freer without wading too deep in theory.
19:16:37 <jchia1> and without having to write a lot of code
19:16:48 <jchia1> compared to doing the same thing with mtl
19:17:35 <jchia1> jle`: Compared to writing mtl code that does the same thing
19:58:53 * hackage rank2classes 1.4.1 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.4.1 (MarioBlazevic)
20:09:22 * hackage grammatical-parsers 0.5 - parsers that combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.5 (MarioBlazevic)
22:01:23 * hackage tesla 0.3.0.1 - Tesla API client.  https://hackage.haskell.org/package/tesla-0.3.0.1 (dustin)
22:03:39 <GreeboSnabble> Is there a functor like "flip" Const ?
22:04:25 <GreeboSnabble> Basically newtype Const2 a b = Const2 {getConst2 :: b}
22:05:02 <Axman6> Tagged?
22:06:19 <Axman6> @hoogle Tagged
22:06:19 <lambdabot> module Data.Tagged
22:06:19 <lambdabot> Data.Tagged newtype Tagged s b
22:06:19 <lambdabot> Data.Tagged Tagged :: b -> Tagged s b
22:07:09 <GreeboSnabble> Thanks
22:24:22 <Axman6> :t _1 Tagged
22:24:23 <lambdabot> error:
22:24:23 <lambdabot>     Data constructor not in scope: Tagged :: a0 -> f b0
22:24:34 <Axman6> % :t _1 Tagged
22:24:35 <yahb> Axman6: ; <interactive>:1:4: error: Data constructor not in scope: Tagged :: a0 -> f b0
22:25:18 <Axman6> % import Data.Tagged
22:25:19 <yahb> Axman6: 
22:25:21 <Axman6> % :t _1 Tagged
22:25:21 <yahb> Axman6: forall {k} {s1} {t} {b} {s2 :: k}. Field1 s1 t b b => s1 -> Tagged s2 t
22:28:05 <bqv> how do i construct a half-simple prism
22:28:16 <Axman6> "half-simple"?
22:28:48 <bqv> looking for an optic that's a prismatic getter but identity setter
22:29:14 <bqv> i'd suggest the type but i'm not sure on it
22:29:18 <Axman6> sounds like you're out to break some laws bucko
22:29:20 <jle`> what operations would it support?
22:29:42 <bqv> well, the intention is to compose it with a lens i have already
22:30:15 <jle`> what operations would you want the result of that composition to support?
22:30:19 <bqv> that lens is a Lens (Maybe a) (Maybe b) (f (Maybe a)) (f (Maybe b))
22:30:49 <bqv> get -> failable retrieval
22:31:00 <bqv> set <- Maybe value
22:31:20 <jle`> get :: Thing' s a -> s -> Maybe a    ?
22:31:29 <jle`> set :: ?
22:32:19 <bqv> get :: Thing' s a -> s -> Maybe a, set :: Thing' s a -> Maybe a -> Thing' s a
22:32:22 <bqv> (?)
22:32:36 <bqv> wait
22:32:58 <jle`> remember set for normal lenses is set :: Optic' s a -> a -> s -> s
22:33:07 <bqv> yeah no, that's right. just, my current lens fits that, but the problem i'm trying to solve it getting it to behave sensibly with the ^? family of operations
22:33:24 <jle`> do you have an example of a specific thing you want to do?
22:35:59 <bqv> so with my current lens, i'll call it "focus": if i do ``inhabited ^.. focus._Just`` i get a list of one value, if i do ``uninhabited ^.. focus._Just`` i get an empty list. That's the get behaviour i'm after. if i do ``inhabited & focus .~ Just v`` the value is set to v, and if i do ``inhabited & focus .~ Nothing`` the value is cleared. That's the set behaviour i'm after
22:36:38 <bqv> focus :: IndexedLens' k (w (Maybe (k, a))) (Maybe a)
22:39:41 <bqv> my current mental summary of what i want to acheive is lens composition of _Just, but only over the getter
22:40:02 <bqv> that's an asymmetrical lens, but i think it's still a valid one
22:40:11 <bqv> well, valid optic, at least
22:40:25 <c_wraith> aren't you just describing exactly the behavior of at?
22:40:40 <bqv> quite possibly, how would i use that here?
22:40:56 <c_wraith> No idea, it was more that you can use it as a model for your type
22:41:04 <c_wraith> > M.fromList [(1, "a"), (2, "q")] ^.. at 1 . _Just
22:41:06 <lambdabot>  ["a"]
22:41:09 <c_wraith> > M.fromList [(1, "a"), (2, "q")] ^.. at 3 . _Just
22:41:11 <lambdabot>  []
22:41:27 <c_wraith> > M.fromList [(1, "a"), (2, "q")] & at 1 .~ Just "hi"
22:41:29 <lambdabot>  fromList [(1,"hi"),(2,"q")]
22:41:33 <c_wraith> > M.fromList [(1, "a"), (2, "q")] & at 1 .~ Nothing
22:41:35 <lambdabot>  fromList [(2,"q")]
22:41:45 <c_wraith> I mean...  that's the properties you want, right?
22:42:01 <bqv> yes...
22:42:07 <c_wraith> :t at
22:42:08 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
22:42:39 <bqv> :t at undefined
22:42:41 <lambdabot> (At m, Functor f) => (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
22:43:06 <c_wraith> I mean, the class stuff is making that complicated for no reason
22:43:24 <c_wraith> Strip that away, and you've got a type like  Lens s t (Maybe a) (Maybe b)
22:44:27 <c_wraith> or  Lens' s (Maybe a)  if you can't change types
22:45:36 <bqv> see the frustrating part is that my current lens has that type
22:45:56 <bqv> but then if i try ``inhabited ^.. focus`` i get [Just val] instead of [val]
22:46:13 <bqv> so i feel like there's some constraint applied one functor too high or something
22:46:14 <c_wraith> Oh, you want to skip the _Just part?
22:46:20 <c_wraith> That's not going to work
22:46:28 <bqv> oh
22:48:15 <c_wraith> the problem there is that you can't have traversal-like behavior (skipping Nothing values with toListOf) at the same time as you have lens-like behavior (setting to Nothing to delete)
22:48:49 <c_wraith> Nothing is either a target or it isn't.  You can't have it both ways
22:48:55 <bqv> ack, so this is logically impossible
22:49:03 <bqv> half a day wasted..
22:49:14 <bqv> so I suppose my best plan would be to separate the getter and setter, then
22:50:00 <c_wraith> Or just use _Just when needed.  But yes, separating them is certainly attested.  lens has both the Ix and At classes to handle the traversal and lens cases
22:50:35 <bqv> well, the problem is that the indexedlens's index cell is a partial function
22:50:46 <bqv> so in the situation that the value is Nothing, the index is undefined
22:50:50 <bqv> i was trying to avoid that
22:56:53 <bqv> ok nevermind, got this to with with some other form of type abuse
22:58:23 * hackage uniqueness-periods-vector-examples 0.14.4.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.14.4.0 (OleksandrZhabenko)
23:21:37 <dsal> That thing where you make a beautiful generic function for a bunch of things you're doing, then realize you only really need this generic form in ~one case.
23:29:49 <MarcelineVQ> dsal: every single time
23:30:01 <bqv> that's the fun part
23:30:51 <MarcelineVQ> Functional programming lets me do all these amazing things [that I don't need to do].
23:33:18 <dsal> Then you try to show your friends and they're like.  eh.  "No, but it's typesafe!"
23:35:26 <dsal> I'm a little sad about how much of my Haskell makes me feel good about how it works in a way that my friends can't appreciate.   Not *clever* code, but just like, code that looks understandable, but works for a really satisfying reason.
23:39:11 <MarcelineVQ> I show my friends and they go "why is there a function in that type?" and I'm like.. "because I want to look more clever than I am"
23:40:41 <bqv> lmao
23:55:54 <bqv> I find Haskell and rust are both refreshingly different, but with rust, while the borrow checker provides security, it feels ultimately restrictive, whereas haskell's type expressibility, while somewhat strict, feels ultimately freeing 
23:57:21 <bqv> Now I'm off to enable functionaldependencies and at least 5 other extensions
