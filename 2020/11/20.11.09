00:11:28 <asheshambasta> In any given cabal project, given I have default-extensions in some of my .cabal files, is HLint supposed to use these extensions while parsing?
00:12:23 <asheshambasta> One of my modules using LambdaCase seems to be confusing HLint where it reports a parse error, while GHC accepts it.
00:13:09 <asheshambasta> It reports an error with `interpret \case ...` and not with `interpret $ \case ...`
00:14:47 <merijn> asheshambasta: HLint doesn't know about Haskell extensions or, really, anything about the AST/semantics
00:15:11 <merijn> asheshambasta: It implements its own Haskell parser which may or may not be compatible with any syntax extensions
00:15:18 <merijn> (afaict)
00:16:08 <asheshambasta> I see, I was concluding it did based on following this as an example https://github.com/ndmitchell/hlint/blob/master/.hlint.yaml#L10
00:16:33 <merijn> HLint doesn't parse cabal files or anything, afaik
00:16:58 <merijn> So perhaps they work if the extensions are in the module as pragma
00:17:26 <merijn> (Incidentally, this is why imo using default-extensions is a bad idea, now all your tools need to somehow be able to parse cabal files)
00:19:17 <asheshambasta> Yeah, that's true. However, at the same time, I'd expect cabal files to define other fundamental things about my project too: where to find the modules, which modules to expose & not, where to find the Main module etc. I personally don't particularly find it problemmatic for the cabal file to also tell which extensions should be turned on by default.
00:20:01 <asheshambasta> I guess what I'm trying to say is: if cabal files contain that information (which defines the project itself, in its dir. structure, modules etc.), why not also extensions I'd like turned on by default?
00:20:24 <merijn> Well, for example, because now hlint doesn't work :p
00:20:57 <merijn> Unless you duplicate the extension list into an hlint configuration file (at least, judging by that hlint link it does support a ton of extensions)
00:20:58 <asheshambasta> Doesn't that mean HLint should parse the cabal file more than that the cabal file shouldn't contain x?
00:21:47 <merijn> asheshambasta: Try adding support for that to hlint and you'll soon learn why it doesn't support that yet :p
00:22:18 <asheshambasta> because parsing cabal files is hard?
00:22:26 <merijn> Cabal is a *big* dependency to have for a tool like hlint, it also means you need to upgrade hlint a lot
00:22:39 <merijn> It will also make the hlint codebase a ton more complicated
00:23:45 <merijn> Parsing cabal files is easy, IFF you depend on Cabal.
00:23:55 <asheshambasta> yeah, fair point. However, like you said, maintaining a separate HLint.yaml file is also going to be more boilerplate and ceremony.
00:24:59 <merijn> Besides, having to put all the extensions in each Haskell file is a good way to make people think harder about adding extensions, which is a good thing imo
00:26:02 <asheshambasta> I also agree with that, but there are some extensions that I almost always need. And these add just to the noise of what needs to be done before writing any module.
00:27:56 <asheshambasta> However, I see that in the example above, it seems to be more of an issue with hlint's parser than an issue of it being aware of the LambdaCase extension.
00:28:06 <asheshambasta> (it accepts `interpret $ \case`)
00:45:05 <dminuoso> merijn: What are the chances of splitting Cabal into a cabal-the-file parser and Cabal-the-library?
00:45:28 <dminuoso> That is, if someone provided the work for it, do you reckon it would stand a chance of landing upstream?
00:45:53 <sclv> i don't see the advantage
00:46:10 <dminuoso> well, tools could parse the file for information extraction or manipulation
00:46:23 <sclv> pulling the parser in requires pulling in the data structures which pulls in a ton of cabal anyway
00:46:30 <dminuoso> Mmm
00:46:59 <merijn> sclv: There's some bonus, though
00:47:07 <merijn> You can just get the fields without semantics stuff
00:47:22 * hackage cobot-io 0.1.3.11 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.11 (ozzzzz)
00:47:37 <merijn> dminuoso: btw, phadej already made https://hackage.haskell.org/package/cabal-install-parsers
00:47:51 <merijn> Or rather, I guess hvr did and he works on it now
00:48:46 <dminuoso> merijn: Which depends on Cabal.
00:48:57 <dminuoso> Not sure what you win that way
00:49:30 <dminuoso> I mean if its just data type definitions, surely that can all be moved into simple Types modules.
00:49:42 <int-e> dminuoso: AIUI it provides the parsers that are otherwise buried inside cabal-install, so the project-level stuff.
00:50:08 <int-e> But maybe I understood incorrectly?
00:50:15 <merijn> It does a bit of both
00:50:25 <dminuoso> int-e: https://hackage.haskell.org/package/cabal-install-parsers-0.4/docs/src/Cabal.Package.html#readPackage
00:50:34 <merijn> dminuoso: Pulling out those parsers is hard, though :)
00:51:03 <dminuoso> This is not very high level. :p
00:52:26 <int-e> the biggest files are ... Index (so package index) and Project (project file stuff, including mapping the packages to OS directories)
00:53:01 <int-e> Which is about what I expected/remembered.
00:53:43 <int-e> But yes, it's on top of Cabal, while dminuoso wants a split below.
00:57:55 <kuribastard> how do f# computation expressions compare to monads?
00:58:30 <kuribastard> it looks like it's a generalization of do notation.
00:58:36 <kuribastard> but without laws
00:59:28 <kuribastard> those languages intend to make it easier than haskell, but without laws, won't it become harder in the end?
00:59:58 <kuribastard> if it would support indexed monads, that would be an advantage though...
01:02:52 * hackage ukrainian-phonetics-basic 0.2.0.1 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.2.0.1 (OleksandrZhabenko)
01:08:27 <xpika> Should there be a Monoid instance for Monad m => Kleisli m a a in the vein as Endo a in Data.Monoid?
01:11:50 <Taneb> xpika: http://hackage.haskell.org/package/monoid-extras-0.5.1/docs/Data-Monoid-Endomorphism.html there's this in monoid-extras
01:12:01 <Taneb> Whawt you're after is "Endomorphism (Kleisli m)"
01:12:12 <Taneb> (it works for any category)
01:15:45 <Feuermagier> what does the :set operator do? - and where does it belong (seen it in a stackoverflow post)
01:18:10 <xpika> Taneb: Thanks
01:19:24 <xpika> question: Are Monads Monoids?
01:21:26 <xpika> wikipedia doesn't seem to suggest it. https://en.wikipedia.org/wiki/Monad_(category_theory)
01:21:46 <Taneb> xpika: the short answer is "no", but there's a long answer which has "yes" as the conclusion
01:22:47 <Taneb> So as monoid as is conventionally understood is a set with an associative binary operation that has an identity
01:22:59 <Taneb> By this definition, a monad is not a monoid (it's not even a set)
01:23:30 <Taneb> But through the power of category theory, this definition can be generalized to a "monoid object on a monoidal category"
01:24:38 <Taneb> A monoidal category is a category with a bifunctor * and special object 1 such that A * (B * C) is isomorphic to (A * B) * C and A * 1 is isomorphic to A is isomorphic to 1 * A
01:24:43 <maralorn> xpika: There is the sane definition of Monoid, which every mathematician knows. According to that one a Monad is not a Monoid. And then there is a category theory definition of Monoid, which I think out of 30 professors at my department max. 2 know, and as Taneb explains, that one works for Monads.
01:25:15 <Taneb> We can make the category of sets a monoidal category with * being ordered pairs and 1 being a singleton set (like () )
01:26:34 <Taneb> A monoid object is an object M in a monoidal category, with morphisms 1 => M and M * M => M, with certain sensible laws corresponding to associativity and identity
01:26:52 <Taneb> If we choose the category of sets as our monoidal category we get the traditional definition of monoids
01:28:06 <Taneb> Now, let's take another category, the category whose objects are functors from set to set and whose morphisms are natural transformations
01:28:36 <Taneb> This can be made monoidal, taking * to be composition of functors and 1 to be the identity functor
01:28:45 <Taneb> Monoids in *this* category are exactly monads
01:29:00 <Taneb> (this is where the joke "monads are just monoids in the category of endofunctors, what's the problem?" comes from)
01:29:12 <Taneb> xpika: I don't know how useful this is but I hope it's at least interesting
01:29:22 * hackage libfuse3 0.1.2.0 - A Haskell binding for libfuse-3.x  https://hackage.haskell.org/package/libfuse3-0.1.2.0 (yohashi)
01:31:59 <xpika> Taneb: No, it's good. I realized the other day that since I could make a monoid out of monads that I could use the fold function for instance to fold a list of Kleisli arrows
01:33:00 <Feuermagier> how can I concatenate strings with space, but only if the concatenated-with string is not empty? - (so I dont get double spaces)
01:33:23 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.1.3.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.1.3.0 (OleksandrZhabenko)
01:35:52 * hackage phonetic-languages-properties 0.3.0.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-properties-0.3.0.0 (OleksandrZhabenko)
01:42:54 <xpika> > (\x y -> unwords . words $ [x,y]) "hello " " world"
01:42:56 <lambdabot>  error:
01:42:56 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
01:42:56 <lambdabot>      • In the first argument of ‘\ x y
01:43:10 <xpika> > (\x y -> unwords . words $ (x++y)) "hello " " world"
01:43:12 <lambdabot>  "hello world"
01:43:54 <xpika> > (\x y -> unwords . words $ (x++y)) "hello " " new  world"
01:43:56 <lambdabot>  "hello new world"
01:45:15 <Feuermagier> xpika, interesting! thanks!
01:46:00 <xpika> >"hello" ++ " "++dropWhile (==' ') "  world"
01:47:02 <xpika> > "hello" ++ " "++dropWhile (==' ') "  world"
01:47:03 <Feuermagier> xpika, can I apply this to a list of Strings, so that it concatenates the entire list like "concat"?
01:47:04 <lambdabot>  "hello world"
01:48:02 <xpika> Feuermagier: yes
01:49:45 <Feuermagier> xpika, is there something like a "concatenateWithFunction f" - function? - I don't quite get how to syntactically correctly apply this
01:50:39 <xpika> >>= does that
01:50:54 <xpika> or concatMap which is the same thing
01:57:46 <Feuermagier> like this?: concatMap (\x y -> unwords . words $ (x++y)) ["u ", " ", " z"]
01:57:51 <Feuermagier> > concatMap (\x y -> unwords . words $ (x++y)) ["u ", " ", " z"]
01:57:53 <lambdabot>  error:
01:57:54 <lambdabot>      • Couldn't match expected type ‘[b]’
01:57:54 <lambdabot>                    with actual type ‘[Char] -> String’
01:58:26 <cr0ssw1nd> hey hoe
02:08:52 * hackage phonetic-languages-examples 0.3.0.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.3.0.0 (OleksandrZhabenko)
02:10:04 <Feuermagier> xpika, can I apply that dropWhile you used from back to front of a string somehow?
02:14:45 <xpika> >  dropWhileEnd isSpace "hello world   "
02:14:47 <lambdabot>  "hello world"
02:21:39 <kuribastard> :t dropWhileEnd
02:21:41 <lambdabot> (a -> Bool) -> [a] -> [a]
02:36:06 <kuribastard> ouch this burns: "Seriously: the PHP people at least know their languages won’t protect them from anything. We should bring some of that humility back to Haskell."
02:41:42 <Uniaika> lol yeah I read that one too
02:43:25 <maerwald> where was that
02:44:36 <kuribastard> https://www.snoyman.com/blog/2020/11/haskell-bad-parts-2
02:45:56 <maerwald> well yeah, it's a popular opinion that types protect you from bugs and ppl get overly enthusiastic about it
02:47:13 <kuribastard> types don't protect you from bugs, but they help you to maintain abstraction barriers.  It's having proper abstractions that save you from stupid bugs.
02:47:25 <maerwald> I even disagree with that
02:47:29 <Uniaika> maerwald: yeah in the end, we have a case of overly enthusiast zealot 
02:47:33 <kuribastard> maerwald: I know
02:48:06 <merijn> I have a simple heuristic for maerwald's opinion on most topics. Just invert the popular opinion ;)
02:48:19 <maerwald> merijn: that's not very useful
02:48:27 <Uniaika> but is it true though? :P
02:49:12 <kuribastard> it's being able to clearly specify business logic that makes your program less faulty.  It does prevent you from implementing the wrong specs, not understanding the customer requirements, etc...
02:49:20 <maerwald> kuribastard: types don't construct *architecture*. They are usually more low-level than that.
02:49:33 <kuribastard> erm "doesn't"
02:50:27 <kuribastard> but then, just as it's a poor decision to run your programs under a desk, I think it's a poor decision to run your long running service using a dynamic language.
02:50:54 <kuribastard> maerwald: that's exactly why they are useful
02:51:05 <maerwald> good architecture facilitates porper abstraction barriers
02:51:37 <kuribastard> it doesn't come with a large overhead like OO inheritance hierarchies.
02:52:04 <maerwald> I don't follow that thought
02:52:31 <maerwald> bashing OO isn't hard
02:58:17 <maerwald> "Deprecate partial functions" ... ok, please provide a proper languagu for that, because Haskell isn't
02:58:28 <maerwald> little extreme imo
02:59:59 <Uniaika> *some* famous partial functions' types *can* be patched with NonEmpty a instead of [a]
03:00:25 <maerwald> I am a fan of partial head. 
03:00:49 <maerwald> Sometimes you have local proof (inside the same function, but haskell isn't expressive enought to know)
03:01:02 <Uniaika> yes that is indeed right
03:01:11 <maerwald> I don't wanna bother with Maybe types just to satisfy someone elses OCD
03:01:50 <Uniaika> maerwald: Same, but that's why I prefer an upstream NonEmpty rather than a downstream Maybe
03:03:25 <int-e> I for one dislike NonEmpty a; it should be a subtype of [a] but we don't have subtypes.
03:04:39 <maerwald> in general seems like a rant about stdlib, which is mostly true
03:05:14 <xpika> consensus is that if your serious: don't use the default prelude
03:05:42 <int-e> consensus?!
03:05:50 <maerwald> That's what I see quite often: strong types, but the implementation is still naive (e.g. see the 'path' package)
03:06:34 <int-e> I suppose you can reach a consensus that the Prelude doesn't get things right.
03:06:42 <int-e> You 
03:07:00 <int-e> I don't think you can reach a consensus on what it should do instead.
03:11:11 <maerwald> The "checked exceptions" discussion is the worst. And ppl believing haskell actually has checked exceptions. No, Either is not that. ExceptT neither and even if you add open unions, you still need to be careful to always catch all inner IO actions
03:12:16 <int-e> isn't that another thing that wants subtyping
03:12:54 <int-e> (I guess it can be expressed as constraints if you want to... and you have a kind of subtyping on that level)
03:13:04 <Squarism> anyone know of clean "algorithm" to construct a tree from a list of elements containing something like : data KeyedNodes a = KeyedNodes { id::String, parentId::String, content::a } ?
03:13:29 <maerwald> int-e: I don't think this is a "type level expressivity" option at all
03:13:30 <Squarism> oh, parentId should ofc be Maybe String
03:13:44 <maerwald> GHC doesn't know what exeptions a function may throw. Fix that first
03:14:44 <tomsmeding> Squarism: make a Data.Map (Maybe String) [String] from parent -> children with a single pass over the list in O(n log n), then build the tree recursively in O(n log n) ?
03:15:19 <int-e> maerwald: Oh, sure, it would require quite a different setup for IO. It wouldn't even be a monad... but some indexed thing instead.
03:15:57 <merijn> int-e: I disagree, I think the issue is orthogonal
03:16:01 <kuribastard> Squarism: you can use a lazy map Data.Map (Maybe String) Tree
03:16:16 <merijn> Exceptions shouldn't be in the current types (system) at all
03:16:30 <merijn> We should have a new separate type system and types for that
03:16:34 <tomsmeding> oh kuribastard's version is nicer indeed
03:16:59 <kuribastard> merijn: when are you going to design a new language?
03:17:11 <kuribastard> merijn: can it have indexed monads?
03:17:33 <maerwald> well, I leave up the "how" wrt checked exceptions to the scientists :p
03:17:38 <int-e> merijn: sure, that's an option...
03:17:57 <maerwald> I can just give my users experience that all options currently suck
03:18:07 <maerwald> and that Java ain't that bad wrt exceptions
03:18:44 <merijn> kuribastard: As soon as someone pays me :)
03:19:12 <maerwald> merijn: only fintech has the money, so figure out a way to sell your idea to them
03:19:34 <merijn> fintech wants me to move too, so that's out :p
03:20:11 <maerwald> You need a Gandalf kicking you out of your house :p
03:21:37 <maerwald> but currently, shouldn't be that hard
03:21:47 <maerwald> where can you move now anyway
03:22:45 <merijn> maerwald: Well, even if I was willing to move, most fintech is located in countries I would be unwilling to move to :p
03:23:59 <maerwald> you mean Cayman Islands? *chuckle*
03:24:08 <beleon> hi! can you help me out on creating a Monad instance for my type? It's a Monad around the parsec Parser Monad that is supposed to keep track of indentation characters used while parsing. I can't quite figure out how to get the result of >>= out of the Parser Monad. Here's the code: https://gist.github.com/beleon/97273023d3b95fb62d28da6bec273aeb
03:25:13 <merijn> maerwald: I meant the US/UK, but close enough :p
03:25:20 <maerwald> And SG
03:26:49 <kuribastard> beleon: don't, use a newtype and GeneralizedNewtypeDeriving instead
03:27:00 <kuribastard> beleon: and mtl
03:27:14 <kuribastard> beleon: it will give you all the instances for free
03:27:29 <dminuoso> *cunning GeneralizedNewtypeDeriving
03:27:44 <dminuoso> Every mention of the extension in documentation and diagnostics calls it cunning.
03:27:47 <dminuoso> We should too. :>
03:28:30 <beleon> hm, but how would the automated derivation know how to merge the ParserBoxInfo?
03:29:07 <dminuoso> beleon: You'd use <|> instead
03:30:51 <beleon> dminuoso: but wouldn't <|> also be derived?
03:31:04 <dminuoso> Only if you GND Alternative
03:32:04 <kuribastard> beleon: you can make your own monoid instance
03:32:15 <beleon> right, so i'd simply define that myself and derive everything else?
03:32:54 <dminuoso> Sure
03:33:17 <dminuoso> beleon: Right now your code is violating an implicit assumption:
03:33:23 <dminuoso> Coherence between Applicative and Monad
03:33:34 <dminuoso> (Because `ap` and `<*>` have conflicting definitoins)
03:34:27 <dminuoso> So they implement different effects. That alone is reason enough to bury the "merging" behavior as you call it into Alternative instead (which is where we in fact place this behavior into)
03:35:45 <beleon> i see. will the derived monad instance automatically make use of the custom alternative instance?
03:36:12 <dminuoso> No, the lattice looks a bit differnece
03:36:14 <dminuoso> Hold on
03:36:44 <dminuoso> https://wiki.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png
03:36:47 <maerwald> how reasonable is it to create a C API for your haskell library?
03:36:55 <idnar> dminuoso: is that like the _dreaded_ monomorphism restriction?
03:37:03 <dminuoso> idnar: haha, sorta
03:37:13 <dminuoso> beleon: As you can see, Alternative/MonadPlus are subclasses of Applicative/Monad respectively.
03:37:27 <merijn> maerwald: It depends
03:37:43 <maerwald> do we even have means to do so or will I have to write a C wrapper
03:37:44 <dminuoso> So it's assumed there's coherence all along `Functor>Applicative>Monad` and there's coherence between `Alternative>MonadPlus`
03:37:46 <merijn> maerwald: You'll have to link the RTS with final executable to
03:37:54 <dminuoso> (By coherence I mean their implementations must agree)
03:38:17 <merijn> maerwald: The current FFI can export Haskell symbols as C symbols just fine the same as importing
03:38:29 <dminuoso> So if you GND only up until Monad, you dont get Alternative/MonadPlus
03:38:48 <merijn> maerwald: If you wanna include it as standalone library into a C executable you need a bit of boilerplate to setup the RTS, but it's pretty straightforward
03:39:24 <merijn> maerwald: I made a minimal example of having a C entry point with Haskell code: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
03:39:43 <beleon> what does MonadPlus give me? So I would need custom instances for Alternative and MonadPlus that are coherend?
03:40:04 <merijn> maerwald: If you wanna compile the C code independently of cabal you need to do a bit more work (figuring out how to link the RTS, for one), but it should be fairly straightforward (if annoying)
03:41:11 <maerwald> so you can't create a real proper .so lib?
03:41:16 <dminuoso> beleon: Nobody can really agree on what MonadPlus/Alternative really are in terms of laws..
03:42:01 <merijn> maerwald: Define "real proper"
03:42:18 <maerwald> it has all the symbols you need
03:42:28 <dminuoso> beleon: https://gist.github.com/dminuoso/59aef9dfe15a5e9bed68850ffe6c6641
03:42:34 <dminuoso> roughly you can imagine this relationship
03:43:17 <merijn> maerwald: You can make a .so just fine, it just depends on 1) the RTS so you need to link that to I dunno if you can pre-link that into the package .so, but the RTS is just another .so, so... 2) any foreign code calling the lib needs to initialise the RTS + GC roots like the C code in that gist
03:44:00 <merijn> maerwald: If you get a static copy of the RTS you can, presumably, link it into your .so to get a completely standalone .so, but I haven't tried that
03:44:21 <beleon> dminuoso: right, i think i got it ... more or less :) thanks for the explanation
03:44:34 <merijn> In general, I try to just get GHC to do the final link so I don't have to figure it out
03:44:58 <merijn> But I don't see any theoretical problems, the only practical problem is "figuring out the exact linker flags"
03:45:10 <merijn> I vaguely recall monochrom having a post about this
03:45:59 <dminuoso> beleon: As a random example about laws, you might think `empty <*> m = empty` holds
03:46:05 <dminuoso> But Backwards puts a nail into that one
03:46:38 <merijn> maerwald: https://www.vex.net/~trebla/haskell/so.xhtml
03:47:19 <merijn> maerwald: oh, looks like cabal 2.0+ have explicit support for it too
03:50:52 * hackage restartable 0.1.0.0 - Minimal live coding library for model-view-event-update applications.  https://hackage.haskell.org/package/restartable-0.1.0.0 (MichalGajda)
03:51:15 <maerwald> interesting
03:53:48 <Squarism> tomsmeding, maybe a stupid question, but how would that recursive function look?
03:54:17 <beleon> dminuoso: hm, the compiler complains: newtype ParserBox a = ParserBox (ParserBoxInfo, (Either String (Parser a))) deriving (Functor, Applicative, Monad): Can't make a derived instance of ‘Functor ParserBox’ (even with cunning GeneralizedNewtypeDeriving), any idea why?
03:54:40 <dminuoso> beleon: Ah yes.
03:55:32 <Squarism> tomsmeding, forget it. Its obviously starts with the root.
03:55:33 <dminuoso> beleon: You could if ParserBoxInfo was a monoid...
03:55:46 <dminuoso> Though.. its hung on Functor already mmm
03:56:32 <dminuoso> beleon: Try using `ExceptT String Parser A` instead?
03:57:53 <dminuoso> beleon: Functor at least can be derived with DeriveFunctor :P
04:01:08 <beleon> dminuoso: nah, can't get past functor (using DeriveFunctor) with ExceptT
04:02:45 <beleon> but i could add Monoid instance for ParserBoxInfo. Would that help?
04:10:33 <absence> does anyone know what the status of ghc 9 is? the web site suggests release candidate was more than a month ago, but that seems inaccurate as the latest available download is alpha
04:10:53 <merijn> "the web site" = ?
04:11:06 <tomsmeding> Squarism: :)
04:11:14 <absence> merijn: the status page on gitlab
04:11:26 <absence> https://gitlab.haskell.org/ghc/ghc/-/wikis/status/ghc-9.0.1
04:12:17 <merijn> absence: Anyhoo, the best way to stay up to date is to just subscribe to the ghc-devs mailing list
04:15:23 <absence> merijn: yes, i did check the archive, but only found the alpha announcement
04:26:22 <cr0ssw1nd> why Debug.Trace.traceStack could truncate stacktraces?
04:26:54 <cr0ssw1nd> I built and ran my server (uses Servant framework) in profiling mode
04:27:10 <cr0ssw1nd> but when I do traceStack, I get only this:
04:27:10 <cr0ssw1nd> 2020-11-06T19:02:09.179431846Z CallStack (from -prof):
04:27:11 <cr0ssw1nd> 2020-11-06T19:02:09.179447969Z   Galley.API.Update.handleOtrResponse (src/Galley/API/Update.hs:(957,1)-(961,48))
04:27:11 <cr0ssw1nd> 2020-11-06T19:02:09.179457081Z   Galley.API.Update.CAF:eta2_r5zv4 (<no location info>)
04:27:29 <Feuermagier> how do I get from a [char] to Data.Text.Internal.Text?
04:29:50 <tdammers> Feuermagier: assuming you mean [Char]: `Data.Text.pack`
04:30:09 <tdammers> https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text.html#g:6 documentamatation
04:33:21 <Feuermagier> tdammers, I'm unsure; the compiler says [Char]
04:33:32 <Feuermagier>  * Couldn't match expected type `Data.Text.Internal.Text'
04:33:32 <Feuermagier>                   with actual type `[Char]'
04:35:03 <Feuermagier> If I unpack, I get a String out of the [Char]
04:35:11 <Feuermagier> but still not a Text
04:38:23 * hackage restartable 0.2.0.0 - Minimal live coding library for model-view-event-update applications.  https://hackage.haskell.org/package/restartable-0.2.0.0 (MichalGajda)
04:39:12 <absence> Feuermagier: use pack, not unpack (or enable the OverloadedStrings language extension)
04:39:30 <absence> (if it's a string literal that is)
04:41:07 <tdammers> Feuermagier: [Char] and String are literally the same thing (String is a type alias for [Char])
04:41:58 <tdammers> if you have a Text but want a String, use `unpack`; in the other direction, use `pack`
04:58:00 <Redrum020> halo
04:59:53 <Redrum020> someone herE?
05:00:26 <Redrum020> ?
05:05:09 <cr0ssw1nd> is there any relation between SCC annotation and call stack generated by `traceStack` ?
05:15:31 <tomsmeding> cr0ssw1nd: did you compile with -fprof-auto?
05:16:03 <tomsmeding> (I believe stack and cabal do that when you enable profiling using their usual interface)
05:17:00 <cr0ssw1nd> tomsmeding, yeah, I added --profile to stack
05:17:15 <cr0ssw1nd> there is stack trace when I put it in another places
05:17:35 <cr0ssw1nd> and technically in that place it is also stacktrace, just really short one
05:18:46 <cr0ssw1nd> I am meditating on this piece of docs right now: https://www.taran.space/tmp/lenovo-fedora-20201109-141414-140279452.png
05:19:12 <cr0ssw1nd> from here https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/profiling.html
05:20:13 <merijn> uh
05:20:29 <merijn> Probably browse to some newer version of the guide?
05:20:37 <merijn> 7.6.3 is ancient xD
05:21:33 <merijn> (that's unrelated to your question, but 7.6.3 is like a decade old...)
05:21:52 * hackage restartable 0.3.0.0 - Minimal live coding library for model-view-event-update applications.  https://hackage.haskell.org/package/restartable-0.3.0.0 (MichalGajda)
05:21:54 <cr0ssw1nd> oh
05:22:05 <cr0ssw1nd> yeah, I haven't noticed, thanks
05:22:24 <cr0ssw1nd> actually I am thinking now that "HasDebugCallStack" could be related
06:30:34 <Eugleo> Hey fellow Haskellers! How do I properly convert from Pico to Scientific and back?
06:31:10 <merijn> Depends on your definition of "proper"
06:31:15 <merijn> But you probably want
06:31:17 <dminuoso> unsafeCoerce?
06:31:20 <merijn> :t realToFrac
06:31:21 <lambdabot> (Real a, Fractional b) => a -> b
06:31:25 <dminuoso> Both get you there!
06:31:36 <merijn> :t realToFrac :: Pico -> Scientific
06:31:37 <lambdabot> error:
06:31:37 <lambdabot>     Not in scope: type constructor or class ‘Scientific’
06:31:45 <Eugleo> merijn: Thought it would. Thanks
06:32:03 <Eugleo> Forgot that Scientific was Fractional
06:32:31 <Eugleo> So I went Pico ->(realToFrac) Fractional ->(round) -> Integral ->(fromIntegral) Scientific
06:32:42 <Eugleo> And "proper" is then anything better than this :-D
06:32:50 <merijn> Yeah, that's weird
06:33:06 <merijn> Scientific is an instance of Fractional, so you can do that directy
06:35:30 <Eugleo> Ok, and how do I go back from Scientific to Pico? Never heard about fracToReal or somehting similar
06:36:23 <dminuoso> % :t toRational
06:36:23 <yahb> dminuoso: forall {a}. Real a => a -> Rational
06:36:31 <dminuoso> Clearly.
06:36:42 <merijn> Pico (aka Fixed) is an instance of Fractional to and Scientific is an instance of Real
06:36:49 <dminuoso> oh
06:36:52 <dminuoso> or just realToFrac again
06:36:54 <merijn> So the way you go back is: also realToFrac
06:37:19 <dminuoso> I just remember this: add fromIntegral and realToFrac until it compiels
06:37:25 <dminuoso> Close your eyes, and just pretend there's no narrowing going on
06:37:50 <Eugleo> dminuoso: Just added realToFrac to my arsenal. Was pretty surprised when fromIntegral didn't cut it
06:38:05 <Eugleo> merijn: Thanks a lot
06:38:10 <dminuoso> merijn: what was the library forsafe numeric conversions?
06:38:58 <dminuoso> Ah, it was int-cast https://hackage.haskell.org/package/int-cast-0.2.0.0/docs/Data-IntCast.html
06:56:57 <dminuoso> Mmm, there is no extension to allow *modifying* a field with a function, is there?
06:58:03 <dminuoso> Something akin to %~ from lens
07:04:08 <typetetris> I have overlapping instances and get an "two instances involving out-of-scope types" error. Can I ghc somehow convince to prefer the one, I am controlling?
07:05:52 * hackage uusi 0.1.0.0 - Remove all version constraints of dependencies in .cabal file  https://hackage.haskell.org/package/uusi-0.1.0.0 (berberman)
07:06:10 <Feuermagier> how do I split a tuple of two integers for a function that takes those two integers as parameters seperately?
07:06:55 <dminuoso> % :t curry
07:06:55 <yahb> dminuoso: forall {a} {b} {c}. ((a, b) -> c) -> a -> b -> c
07:06:57 <dminuoso> % :t uncurry
07:06:57 <yahb> dminuoso: forall {a} {b} {c}. (a -> b -> c) -> (a, b) -> c
07:06:59 <dminuoso> Feuermagier: ^-
07:07:02 <Feuermagier> thx!
07:07:18 <dminuoso> typetetris: depends, can you share the code?
07:08:20 <dminuoso> typetetris: Generally the solution is, newtype it.
07:09:41 <typetetris> dminuoso: It already worked now, had `cts` first instead of `(ct ':cts)`. Seems the Overlappable had `(ct ': cts)` instead of `cts`. https://www.irccloud.com/pastebin/GeBOy4jx/
07:10:50 <dminuoso> typetetris: That looks interesting, what change are you making there?
07:12:16 <typetetris> `Verb 'POST 204 '[JSON] NoContent` produced docs claiming to have a response body of empty string. Looked odd, wanted to fix that. (Using servant-docs).
07:12:40 <typetetris> That one could be replaced by PostNoContent, but if you need headers, it can't.
07:13:31 <dminuoso> Haha, we have the same exact problem with servant + OpenAPI
07:13:43 <dminuoso> Or rather, a similar
07:13:45 <samlamamma> Is anyone here experienced with implementing structural type system?
07:16:23 <dminuoso> typetetris: Oh! That could explain it, we should just use *NoContent instead.
07:16:34 <dminuoso> That could get rid of a few weird instances :)
07:16:43 <dminuoso> Cheers
07:16:53 <typetetris> dminuoso: Doesn't work for me with Headers. I have endpoints with no response body but they set headers.
07:18:23 <typetetris> and trying to use `PostNoContent` on endpoints without headers gives me this ... https://www.irccloud.com/pastebin/GSgegDGy/
07:21:11 <gehmehgeh> What's the most idiomatic way to use threed dimesional arrays in Haskell? (Or 2x2 matrices for time being)?
07:21:14 <gehmehgeh> *three
07:22:50 <dminuoso> gehmehgeh: vector of vector
07:22:58 <dminuoso> I guess?
07:23:44 <dminuoso> All the usual suspects dont have support for multi dimensional matrices
07:23:48 <bqv> will someone save me some searching
07:24:18 <bqv> what's the lens operation i could use to get an element but also it's index
07:24:24 <bqv> (index, element), or something
07:24:32 <dminuoso> So vector of vector just means you cant have a convenient API of using a Vec3 as index
07:24:54 <dminuoso> bqv: iview
07:25:00 <dminuoso> But it requires an indexed optic of course
07:25:15 <bqv> wonderful
07:25:18 <bqv> ty
07:25:29 <int-e> :t iview
07:25:30 <lambdabot> MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)
07:25:32 <int-e> :t withIndex
07:25:34 <lambdabot> (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)
07:25:35 <int-e> hmm.
07:26:13 <dminuoso> Or yeah that
07:26:18 <dminuoso> % "foobar" ^.. ifolded.withIndex
07:26:19 <yahb> dminuoso: [(0,'f'),(1,'o'),(2,'o'),(3,'b'),(4,'a'),(5,'r')]
07:27:39 <dminuoso> Oh my
07:28:04 <dminuoso> % :i IndexedFold
07:28:05 <yahb> dminuoso: type role ReifiedIndexedFold nominal nominal nominal; type ReifiedIndexedFold :: * -> * -> * -> *; newtype ReifiedIndexedFold i s a = IndexedFold {...}; -- Defined in `Control.Lens.Reified'; type IndexedFold :: * -> * -> * -> *; type IndexedFold i s a = forall (p :: * -> * -> *) (f :: * -> *). (Indexable i p, Contravariant f, Applicative f) => p a (f a) -> s -> f s; -- Defined in `Control.Lens.Ty
07:28:32 <dminuoso> iview through an IndexedFold, it's sad lens lets you do this :(
07:33:28 <bqv> man lenses make my head hurt
07:34:03 <bqv> why are people so twisted on monads when lenses are a thing
07:35:14 <int-e> Because you can use Haskell without touching lenses, but you're kind of forced to use at least one monad on occasion?
07:35:35 <bqv> yeah
07:35:43 <int-e> Monads also have a longer history of being scary.
07:35:44 <dminuoso> bqv: Also, if you find lenses a bit too hard to use, you can also try optics
07:35:52 <dminuoso> It offers better readable types and much improved diagnostics
07:36:11 <maerwald> and good documentation
07:36:16 <bqv> any functional difference?
07:36:18 <dminuoso> Part of what makes lens so harsh is that it leaks implementation details in types
07:36:23 <maerwald> bqv: yes, some
07:36:35 <bqv> hm
07:36:35 <dminuoso> bqv: It's a bit safer and doesn't allow some things, also it's missing a few parts left and right
07:36:40 <dminuoso> Overall it's mostly a drop in replacement
07:36:49 <dminuoso> (modulo replacing . with %, and unsafe combinators)
07:37:10 <bqv> fair enough
07:37:11 <dminuoso> for example, optics doesnt allow you to `view` through a fold
07:37:28 <int-e> . o O ( please describe lens in a sentence )
07:38:18 <bqv> something something coalgebras costate comonad...
07:38:22 <dminuoso> "First class selectors for dealing with nested data, like css-selector/xpath"
07:39:18 <gehmehgeh> dminuoso: hmm, so how would implement something as simply as an array 10x10 array? That is 100 elemnts, selectable by coordinates (x,y) such that x and y are in {0,9} ?
07:39:22 <gehmehgeh> *simple
07:39:37 <dminuoso> gehmehgeh: By writing your own index functions
07:39:39 <gehmehgeh> still Vector of VEctor?
07:39:42 <dminuoso> Yes.
07:39:42 <gehmehgeh> hm
07:39:45 <gehmehgeh> ok
07:39:48 <gehmehgeh> will do. Thanks
07:39:52 <dminuoso> For just a matrix, you could use any of the matrix libraires instead too
07:40:12 <dminuoso> like hmatrix if you want a BLAS/LAPACK backed matrix
07:40:26 <gehmehgeh> hmmm
07:40:47 <dminuoso> For higher dimensional tensors, it depends. Do you need this with dynamic/arbitrary dimensions?
07:40:50 <dminuoso> Or just fixed 3d?
07:41:51 <gehmehgeh> At the moment, I'm just experimenting
07:42:28 <gehmehgeh> I was thinking about a fixed 10x10 matrix for now, though
07:42:55 <dminuoso> bqv: "coalgebras of the costate comonad" is not just a joke, it's also a sad truth of lens. There's of course folks like edwardk who like being directly exposed to the internals of optics, others like me are not fond of having to decode failed constraints into "what optic did I build, what optic is expected" left and right.
07:43:49 <bqv> i thought i saw a ghc plugin somewhere that improved the errors a bit
07:44:04 <bqv> maybe i just saw the optics library you mentioned
07:44:04 <dminuoso> That's the thing, you can do this in all (ghc-extended) haskell without plugins
07:44:14 <bqv> hm
07:44:15 <dminuoso> optics uses just the standard ghc facilities 
07:44:43 <dminuoso>     • A_Fold cannot be used as A_Getter
07:45:25 <dminuoso> * No instance for (Monoid Int) arising from a use of `folded'
07:46:08 <dminuoso> I'll take the former over the latter
07:46:48 <dminuoso> Also, with optics you can just say `f % g :: _` and let GHC infer the type for you. And it wont give you some constraint algebra you have to do in your head, but straight up tell you
07:46:53 <dminuoso> "This is an AffineTraversal"
07:47:08 <dminuoso> (Okay bad example, since lens cant represent affine traversals)
07:47:23 <bqv> to be honest, i am rather interested in the implementation details anyway, so i'm not against the arcane type signatures
07:47:38 <bqv> but it does obviously make debugging basically black magic until i'm a master of profunctors
07:48:28 <dminuoso> btw, lens already does a mixed van laarhoven/profunctor implementation
07:48:47 <dminuoso> the implementation of optics is not more complicated than that of lens, really
07:49:10 <dminuoso> (I guess much of the weirdnesses of lens are about generalization and performance)
07:49:25 <dminuoso> and very opaque naming
07:50:10 <dminuoso> Dont get me wrong, I dont have any fundamental problems with lens, but I like not having to decipher type errors. :)
07:50:15 <dminuoso> And I like type inference being on my side
07:51:05 <bqv> isn't there a lot of stuff that's targeted at compatibility with lens specifically - would those translate?
07:51:47 <dminuoso> Well you can translate lenses from VL to optics forth and back
07:52:07 <dminuoso> at least some
07:52:22 * bqv . o O ( lens isos? )
07:52:33 <dminuoso> Or.. well one direction anyway
07:52:35 <dminuoso> foldVL :: (forall f. Applicative f => (a -> f u) -> s -> f v) -> Fold s a 
07:52:37 <dminuoso> e.g.
07:52:52 <dminuoso> traversalVL :: TraversalVL s t a b -> Traversal s t a b
07:53:40 <dminuoso> It would be kind of nice if such packages were written with backpack to have switchable optics implementation
07:54:00 <bqv> yeah..
07:54:12 <gtk> what is the file extension for Happy grammer file?
07:55:11 <dminuoso> bqv: But honestly, if you write a library, I'd be careful not to expose lenses as part of the main package
07:55:31 <dminuoso> If you wanted to do this at all, try and make a `lib-lenses` package instead, that way someone else can make `lib-optics` too if they desired
07:55:47 <dminuoso> And users who dont want to drag in the transitive dependencies can use it without lens/optics
07:55:53 <bqv> oh, huh. ok
07:57:41 <idnar> dminuoso: one nice thing about `lens` is that you don't need to depend on it to export lenses
07:58:18 <dminuoso> idnar: otoh optics-core is very light on dependencies
07:58:38 <dminuoso> (microlens otoh can be too small)
08:30:41 <tomsmeding> gtk: seems to be .y https://github.com/simonmar/happy/blob/master/tests/issue91.y
08:36:27 <bqv> in a single haskell file you can have execution going left to right, right to left, top to bottom... but can it go bottom to top?
08:40:16 <tomsmeding> bqv: if you can have it right-to-left, you can always add newlines
08:40:40 <bqv> oh no
08:40:57 <tomsmeding> also https://hackage.haskell.org/package/rev-state
08:41:13 <cr0ssw1nd> what is "(a -> b)" in "myFunction (a -> b) arg1 arg2 arg3" = something" ?
08:41:24 <cr0ssw1nd> never have seen this syntax before
08:41:30 <merijn> ViewPattern, probably?
08:41:41 <tomsmeding> ViewPatterns
08:43:05 <cr0ssw1nd> thank you
08:44:27 <Uniaika> §22
09:18:00 <sm[m]> bqv: heh.. can it go diagonally ? in a spiral ?
09:18:26 <bqv> These are the real questions
09:24:37 <geekosaur> it goes in whatever direction gets the job done. Haskell has an entry point like C/C++ ("main") rather than top-to-bottom like Python
09:25:09 <tomsmeding> diagonal? https://paste.tomsmeding.com/DN6jjjhM
09:25:23 <tomsmeding> we can do diagonal
09:25:32 <tomsmeding> (that's generated code by the way)
09:26:06 <geekosaur> next it'll be haskell poetry >.>
09:27:22 * hackage phonetic-languages-examples 0.3.1.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.3.1.0 (OleksandrZhabenko)
09:28:22 <sm[m]> excellent tomsmeding
09:30:11 <bqv> is there an easy lens op to get just the indexes, rather than (index, element) with iview/^@. ?
09:30:58 <maerwald> bqv: you can always use `to`
09:31:50 <maerwald> https://hackage.haskell.org/package/optics-core-0.3.0.1/docs/Optics-Getter.html#v:to
09:32:58 <bqv> well, not sure that helps so much
09:33:05 <bqv> i have an indexedlens
09:33:22 <bqv> just wanna get an index out of it without having to & fst it
09:36:01 <samlamamma> Pure FP noob here. I need to traverse a circular graph in a DFS manner. How do I check if I've visited a node before? Basically I need object identities which doesn't depend on the shape of the whole data.
09:39:16 <merijn> What data structure do you have your graph in?
09:39:34 <merijn> i.e. can't you just "make up" a unique identity per node and call it a day
09:40:01 <maerwald> > iviews (ito id) (\i _ -> i) ('i', 'x') -- bqv 
09:40:03 <lambdabot>  'i'
09:40:47 <bqv> oh, nice
09:40:54 <bqv> iviews ilens const
09:41:12 <bqv> no convenient operator though i guess
09:41:16 <bqv> ah well
09:41:25 <maerwald> stop complaining :p
09:41:28 <samlamamma> merijn: Yeah, I was thinking I can just add an integer to each and use that as its identity. I'm curious what the idiomatic choice is
09:41:32 <bqv> :D
09:42:12 <merijn> samlamamma: You need some form of node identity for graphs and if you don't have a particular one you need "just assign incrementing integers" is about as sensible as it can be
09:43:14 <samlamamma> Hey, fair enough. 
09:56:53 * hackage clash-prelude 1.2.5 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.2.5 (QBayLogic)
09:57:53 * hackage clash-ghc 1.2.5, clash-lib 1.2.5 (QBayLogic): https://qbin.io/nasa-ebooks-5888
10:01:53 * hackage uniqueness-periods-vector-examples 0.14.2.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.14.2.0 (OleksandrZhabenko)
10:45:03 <bqv> y'know when you get to that stage where you have 3 distinct but overlapping refactors going on at the same time
10:45:07 <bqv> or is that just me
10:46:45 <Uniaika> :'D
11:00:31 <merijn> hmm, vector has no foldMap?
11:02:36 <tomsmeding> bqv: be happy you're using haskell
11:03:15 <bqv> i am, i just worry that i use haskell as an excuse to refactor more than write actual code
11:07:54 <fendor> maerwald, my gf is a fan of ghcup, great work!
11:08:22 * hackage cachix 0.5.1 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.5.1 (domenkozar)
11:09:01 * monochrom <3 maerwald and ghcup too
12:13:27 <koz_> :t comparing
12:13:29 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:14:02 <koz_> merijn: Why? Vector (at least the basic one) shoudl be Foldable? Or is there missing context here?
12:20:40 <merijn> Storable vector doesn't have a Foldable instance
12:21:26 <monochrom> Right, but mono-traversable can help.
12:21:43 <merijn> monochrom: There's no reason it can't be Foldable, though
12:22:06 <koz_> merijn: Ah, yeah.
12:22:10 <merijn> oh, wait, no
12:22:18 <koz_> Unfortunately it can't be.
12:22:20 <merijn> Because you can't limit the argument
12:22:22 <monochrom> Perhaps you mean: There is no reason Foldable stays within the restriction of single-parameter type class therefore imposes a parametricity restriction.
12:22:27 <koz_> We need a Storable constraint to basically do anything.
12:22:44 <merijn> Anyway, there's no reason for it not to export it's own foldMap
12:22:52 <merijn> It exports a billion other folds
12:23:05 <monochrom> Yes, that I can stand behind.
12:23:36 <monochrom> But mono-traversable does it. You can accept this compromise for now.
12:24:00 <merijn> monochrom: I just did VS.toList and foldMapped that :p
12:24:30 <monochrom> That one may actually fuse.
12:24:46 <merijn> Frankly I don't particularly care about the performance anyway
12:27:20 <koz_> merijn: Do any of the Vector types export (something akin to) foldMap?
12:27:25 <hekkaidekapus> merijn: <https://github.com/haskell/vector/pull/337>
12:27:28 <koz_> (well, other than the basic one via being Foldable)
12:28:00 <koz_> Never mind, hekkaidekapus answered my question.
12:28:07 <merijn> hekkaidekapus: Unless to goes onto Hackage in, -15 minutes that's not particularly useful to me, though ;)
12:28:40 <hekkaidekapus> hahaha… Admit it, you wanted to let some steam off ;)
12:31:12 <davean> koz_: why 15 minutes? :)
12:31:42 <hekkaidekapus> (Wrong nick)
12:31:50 <geekosaur> merijn, and I see -15
12:31:58 <merijn> davean: Because that's 15 minutes ago is when I wrote the code to work around the lack of foldMap
12:32:19 <monochrom> TEN3T
12:34:38 <merijn> So...I've got a pro-tip for people
12:35:12 <merijn> If you're going to spend 1.5 hours trying to work out why your "real" code deviates from your validation code in a super subtle and weird way...
12:35:28 <merijn> Maybe first check your validation code is correct
12:36:10 <monochrom> Heh I use that to illustrate Bayes theorem.
12:36:26 <merijn> Also, somewhat relatedly
12:36:46 <merijn> Use more newtypes for your integers if you're gonna have like 5 different values of the buggers
12:37:48 <monochrom> It goes like "you're an experienced programmer, your probability of making a bug is really small. The new intern is writing test cases, their false alarm probability is small but bigger than your bug probability. Your code fails their test case. What's the probability that it's really your fault?"
12:38:26 <Rembane> 7
12:39:20 <hekkaidekapus> merijn: The tip is drawn from validated-literals?
12:40:08 <dsal>  The worst thing is finding compiler bugs after years of conditioning that it's not the compiler.
12:42:37 <merijn> dsal: Oh, I've got a good way to fix that!
12:42:57 <merijn> dsal: Just try Intel's OpenCL FPGA tools!
12:43:03 <dsal> ha
12:43:27 <merijn> After 2 months your first instinct for any bug is "I bet they fucked up the compiler again"
12:43:46 <merijn> hekkaidekapus: That's for literals, not so much runtime values :)
12:43:54 <merijn> hekkaidekapus: Hence, the name ;)
12:44:20 <monochrom> Use a just-in-time compiler to turn run-time values into compile-time literals.
12:44:27 <monochrom> Just look at xmonad.
12:45:03 <hekkaidekapus> merijn: I was teasing you because there are no bug reports for the package ;)
12:45:17 <monochrom> or javascript eval >:)
12:45:27 <merijn> hekkaidekapus: That's because no one's using it :p
12:46:19 <hekkaidekapus> By the way, it’s not the first time you’re into Vector.foldMap; <https://github.com/haskell/vector/issues/263#issuecomment-643812468>
12:46:49 <merijn> I know, that's cause past me is a genius with impeccable taste
12:47:06 <hekkaidekapus> heh
12:48:21 <merijn> "newtype Index = Index { getIdx :: Int }" now, if I only had thought of that earlier I'd have saved myself a bunch of annoying debugging >.>
12:49:44 <tomsmeding> merijn: "I don't think tree fold ever does less operations."
12:49:54 <merijn> tomsmeding: That's true
12:49:56 <tomsmeding> a binary tree with n leaves has n-1 interior nodes
12:49:58 <tomsmeding> qed
12:50:51 <merijn> I'm unsure if you're agreeing or disagreeing?
12:51:21 <koz_> > takeWhile (/= ':') "foo:bar"
12:51:22 <lambdabot>  "foo"
12:51:41 <tomsmeding> merijn: I'm agreeing, and proving that your "I think" can be removed :p
12:52:17 <merijn> tomsmeding: Past me is not only a genius with impeccable taste. He's also modest and likes to hedge his claims, except when he doesn't.
12:52:45 <tomsmeding> and present you is also fond of tautologies? :)
12:53:06 <merijn> Tautologies and showers
12:53:07 <koz_> Tautologies are delicious with chocolate syrup.
12:53:15 <koz_> Showers are less so.
12:53:32 <tomsmeding> is that latter statement from experience?
12:53:43 <koz_> tomsmeding: I'll let you figure that one out. :P
12:56:23 * hackage phonetic-languages-examples 0.3.1.1 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.3.1.1 (OleksandrZhabenko)
12:59:48 <merijn> Excellent. My newtype refactor to avoid similar mistakes in the future actually causes a type error on the bug \o/
13:01:17 <tomsmeding> 🎉
13:08:05 <hekkaidekapus> The takeWhile above by koz_ reminded me something I saw in the backlog. merijn, why did you shy away of Data.Sequence when someone asked about a takeWhile going from right to left?
13:09:14 <merijn> What?
13:09:23 <merijn> I didn't ask about takeWhile?
13:09:47 <hekkaidekapus> No, someone asked you about it.
13:10:44 <merijn> The only vaguely related thing I recall is someone wanting to do left padding?
13:11:03 <merijn> How long ago is this backlog? :p
13:11:48 <hekkaidekapus> yesterday
13:12:15 <merijn> That's about 12 hours outside my short term memory storage :p
13:12:32 <hekkaidekapus> L4 anyone?
13:13:28 <gtk`> Is the Rio library still being actively developed?
13:14:56 <hekkaidekapus> merijn: <https://ircbrowse.tomsmeding.com/browse/haskell?id=113736&timestamp=1604876499#t1604876499>
13:16:47 <tomsmeding> can't have an infinite Seq?
13:16:56 <hekkaidekapus> Nope.
13:17:03 <bqv> if i have a Getter
13:17:06 <tomsmeding> so then you can't do the same trick anyhow
13:17:06 <bqv> and i have a Setter
13:17:14 <bqv> can I make a Lens'
13:17:24 <bqv> without going the roundabout route
13:17:51 <bqv> i can't quite decipher the types enough to work out if that's possible
13:18:18 <hekkaidekapus> tomsmeding: In the grand scheme of things, yes. But I doubt the code involved in that convo wouldn’t fare well with a takeWhileR.
13:23:43 <gtk`> cabal install Quickcheck give this error: fdTryLock: invalid argument (Invalid argument) 
13:23:52 <gtk`> any hint?
13:25:51 <merijn> hekkaidekapus: I don't really see how Seq fits there, tbh?
13:32:17 <hekkaidekapus> gtk`: Are you on Windows?
13:33:15 <hekkaidekapus> merijn: I’m suggesting Seq in case the real use case was to view a list in the right-left direction.
13:33:37 <merijn> The question was how to pad to a fixed length, though?
13:34:49 <hekkaidekapus> Yeah, so if the list is built right-leftly, I can pad at the front with Seq.
13:36:37 <tomsmeding> but then you still have to compute (desired length) - (current length) to determine the amount of padding, right?
13:37:15 <tomsmeding> in which case you could just as well have used `take desired (replicate (desired - length my_list) ++ my_list)`
13:38:04 <tomsmeding> hm, except if it can happen that the list is _longer_ than the desired length and you want to truncate
13:38:31 <hekkaidekapus> How are the asymptotics of that? (Haven’t checked, have just a hunch)
13:38:46 <tomsmeding> linear? :p
13:39:01 <bqv> dminuoso?
13:39:08 <tomsmeding> whereas using Seq would even be n log n
13:39:13 <bqv> Resident lens expert...
13:39:48 <merijn> I know the asymptotics of thinking about complicated alternatives and their complexity are higher than my simple O(1) reflex reaction :p
13:41:34 <hekkaidekapus> Empty |> 0 |> 0 |> 0 |> 5 |> 4 |> 3 |> 2 |> 1 -- Is that so bad?
13:42:44 <bqv> Yikes
13:43:39 <tomsmeding> talking about aesthetics, performance, or time spent typing? :p
13:44:05 <hekkaidekapus> All of them :)
13:44:59 <tomsmeding> looks nice, is probably slower than `reverse (take 8 ([1..5] ++ repeat 0))`, and takes longer to type except if you use editor macros
13:45:22 * hackage hls-plugin-api 0.5.0.0 - Haskell Language Server API for plugin communication  https://hackage.haskell.org/package/hls-plugin-api-0.5.0.0 (jneira)
13:45:28 <tomsmeding> ("slower" -> assuming you convert to a list again afterwards)
13:46:04 <hekkaidekapus> #haskell, where typing happens :P
13:47:45 <invaser> Hi, it seems that I've found a bug in syntax highlighter for vscode
13:48:35 <invaser> if you write this code `t = [f| f <-""]` (without space between `f` and `|`) everything that comes after the list comprehension isn't highlighted
13:49:21 <[exa]> invaser: sounds like it's mistaking it for some kind of template haskell construct?
13:49:21 <invaser> should I report it in Haskell externsion repo or in syntax highlighter one?
13:49:53 <invaser> [exa]: yes, it seems like it, though the code runs perfectly ok
13:50:28 <invaser> I'm new to the bug reporting, so I thought I should ask here first where should I report this :)
13:50:53 <[exa]> invaser: I'd start with syntax highlighter, at worst they tell you that the problem is not at their side (maybe the compiler flags get reported wrong)
13:51:18 <[exa]> if you want to be triple sure, try to run the syntax highlighter standalone on the problematic snippet
13:52:40 <[exa]> btw if you're new, it's good to follow a "template", like say this one https://github.com/JustusAdam/language-haskell/issues/176
13:52:52 * hackage j 0.2.0.0 - J in Haskell  https://hackage.haskell.org/package/j-0.2.0.0 (vmchale)
13:53:22 <[exa]> (uh wait that actually looks like the same issue :D )
13:54:11 <invaser> [exa]: haha yeah, just saw it myself
13:55:05 <[exa]> the 'wontfix' label is sad, obviously there's no way to tell the highlighter if the file should have +TemplateHaskell or not
13:56:32 <[exa]> (grumpy voice:) what would we expect from an IDE anyway
13:56:45 <jackdk> Does this have a well-known name? `data FooBar a b = Foo a (Maybe b) | Bar b`? i.e., you might have `a`, you might have `b`, but you definitely don't have neither
13:58:57 <monochrom> "inclusive or" is close, but no one really say that.
13:59:09 <[exa]> jackdk: why not make the type symmetric, like JustA a | JustB b | Both a b ?
13:59:44 <monochrom> And yeah it is usually nicer to make it symmetry like that.
13:59:46 <nshepperd2> isn't that called These
14:00:08 <jackdk> haha yes it is These. thanks nshepperd2 
14:01:27 <monochrom> I am beginning to suspect that "These" is a poorly chosen name.
14:01:43 <[exa]> monochrom: I just rediscovered what it does for the 3rd time
14:01:52 * hackage cabal-fmt 0.1.5.1 - Format .cabal files  https://hackage.haskell.org/package/cabal-fmt-0.1.5.1 (phadej)
14:01:55 <[exa]> remember once asking for it here myself
14:03:43 <monochrom> You tell people "I have an apple, or an orange, or both", people will respond "that sounds like 'and/or'" or "that sounds like 'inclusive or'".  No one is going to respond "that sounds like 'these'".
14:04:07 <monochrom> If you go on to tell people "someone named this situation 'these'" people will be like "wait what?"
14:05:22 <[exa]> naming is hard
14:05:29 <[exa]> can we do better than say.. EitherBoth ?
14:05:43 <dolio> Yeah, These is better.
14:08:38 <[exa]> :[
14:13:13 <dminuoso> bqv: with optics or with lens? And what do you mean with roundabout vote?
14:15:17 <dminuoso> 23:10:35     monochrom | [22:01:05] I am beginning to suspect that "These" is a poorly chosen name.
14:15:47 <dminuoso> I think it's a good name because it's somewhat suggestive, but not too concretely so.
14:16:21 <dminuoso> Maybe as a type constructor is a dumb name as well, you wouldn't say "I have maybe apple"
14:17:05 <monochrom> But I say "Maybe I have an apple" all the time.
14:17:43 <Rembane> monochrom: Are Schrödinger apples an important part of the food you eat?
14:19:11 <dminuoso> monochrom: Strangely, if you have an issue with naming, why not complain about MonadChronicle ;)
14:19:31 <dminuoso> Nothing but cute workplay
14:19:32 <monochrom> I haven't heard of MonadChronicle.
14:19:35 <dminuoso> https://hackage.haskell.org/package/monad-chronicle-1.0.0.1/docs/Control-Monad-Chronicle.html#t:MonadChronicle
14:19:44 <dminuoso> It's essentially an mtl style for These
14:19:49 <dminuoso> as a monad transformer
14:20:08 <dminuoso> Or rather, there's ChroncicleT that is essentially a TheseT, and MonadChronicle as a tagless final encoding
14:54:27 <jackdk> I have used These in the past, and said to people "I either have This thing, That thing, or These things" and it doesn't seem too bad
15:15:16 <monochrom> I wouldn't object ThisThatThese or ThisOrThatOrBoth
15:15:34 <monochrom> "These" alone?  Where is "this" and "that" in that?
15:15:59 <Axman6> AOrBOrAxB >_>
15:16:41 <Axman6> also, I feel like These answers thew question of "Which of these do I have? A or B or Both?
15:16:44 <Axman6> "
15:17:27 <monochrom> You have a data type that has 3 cases, and in all likelihood, all 3 cases have equal probability. And you decide that the name of the whole data type is monopolized by only 33.3% of the cases.  This I don't understand.
15:18:18 <monochrom> It also answers the question of "which of these do I have? A xor B?"
15:18:19 <Axman6> nah, it's A x B / (A + B + AxB) of the values though "{
15:18:35 <monochrom> It also answers the question of "which of these do I have? Just A or Nothing?"
15:18:59 <monochrom> All of these could have equal claim to the name These.
15:19:18 <dolio> The name reminds you that it's the type with the "This, That, These" constructors, and that's good enough, and isn't a huge waste of horizontal space.
15:20:38 <monochrom> I would be OK with the contraction "Thiaese".
15:20:38 <davean> monochrom: clearly the right name is NonEmptyCan or Can1
15:22:01 <dolio> As an added advantage, it teaches people that the name of the type has nothing to do with 'probability' of constructor occurrence.
15:22:17 <davean> dolio: Thats a thing to teach?
15:22:22 <dolio> Apparently.
15:23:37 * hekkaidekapus proposes an inclusive Celleux :)
15:23:40 <Axman6> clearly the These constructor of These's probability approaches 1 as the inhabitants of a and b grow
15:24:54 <hekkaidekapus> Bayes again? :p
15:29:25 <GreeboSnabble> Hi all, quick question:
15:29:46 <GreeboSnabble> Has anyone thought of making functions a typeclass?
15:30:14 <GreeboSnabble> Lists, Data.Map, regular functions a -> b could all be instances
15:30:27 <monochrom> I think that's what C++ did.
15:31:12 <Axman6> and Scala does some weird crap like that with its PartialFunction type
15:31:12 <GreeboSnabble> Idk, but it seems like function notation would be nicer than (!!) or M.lookup
15:32:06 <dibblego> scala.PartialFunction is pretty broken, but it is still used today in production systems
15:32:15 <Axman6> it sure is -_-
15:32:43 <monochrom> I bet it would be type inference really difficult, for both compilers and humans. C++ isn't affected because it has very limited type inference.
15:32:54 <monochrom> s/it would be/it would make/
15:33:16 <merijn> monochrom: Also, C++ compiler writers just said "fuck this, you sort it out" :p
15:33:49 <merijn> That's why I have to stupid stuff like calling object methods like "foo.template my_method(bar);" >.>
15:36:38 <JohnnyL> What is the mosted complicated Category Theory structure in Haskell?
15:36:59 <Axman6> Void
15:37:03 <monochrom> Why?
15:37:16 <dibblego> 12
15:37:25 <merijn> JohnnyL: Define "in Haskell"
15:37:44 <JohnnyL> merijn: Ability to use in Haskell.
15:37:57 <Axman6> and complicated?
15:37:59 <merijn> I would personally define the set of "category theory structures *in* Haskell" as empty >.>
15:38:07 <JohnnyL> So functor would be more compliated than a morphism.
15:38:17 <JohnnyL> complicated sorry.
15:38:26 <Axman6> do we have a lattice of complications?
15:38:28 <merijn> But functors are morphisms in the category of categories! >.<
15:38:57 <dibblego> I can only imagine complicated to mean, those structures which most programmers look at and proclaim, rightly or wrongly, "that's complicated"
15:39:08 <JohnnyL> You can say robust.
15:39:14 <Axman6> I'm sure some horologists would like to know the answer to that...
15:39:25 <JohnnyL> Or the ability to be more detailed without repetition.
15:39:54 <monochrom> You know what, functors suffer more restrictions than other categories' morphisms, so actually I think functors are simpler, than say, morphisms in Set.
15:43:27 <JohnnyL> monochrom: A morphism is *any* structure that preserve it's mapping.
15:43:56 <JohnnyL> Okay. Thank you for playing Jeopardy.
15:43:57 <JohnnyL> hahaha.
15:46:03 <Axman6> I'm not really sure what answer you were after with your question
15:47:06 <monochrom> This is why I asked why.
15:49:26 <JohnnyL> Maybe this is a better for question for math since I am asking for what computational Categorical Structure that can be classified in CA exists in Haskell. 
15:51:05 <monochrom> Axman6: Actually, I'm now interested in how horologists come into this.  What would some of them be interested in?
15:51:29 <dolio> Set (or an analogue) is always the most complicated thing in a way, because it has all of the structure you ever want to talk about, and structure in any other category is defined by reflection from Set.
15:52:33 <JohnnyL> dolio: Wow, are you way off.
15:56:14 <monochrom> No, dolio is right on.
15:56:57 <monochrom> Instead, wrong descriptions such as "structure that preserve it's mapping" are the ones that are way off.
15:57:29 <monochrom> even after, especially after, auto-correcting "it's" to "its"
15:57:51 <JohnnyL> monochrom: Description of what?
15:58:08 <dibblego> morphism
15:58:11 <monochrom> You forgot what you wrote? Already?
15:58:11 <JohnnyL> monochrom: How do you say monochrom is right about set?
15:58:36 <JohnnyL> monochrom: Hm,the act of forgetting shouldn't be confused with the ability to scroll up.
15:59:08 <JohnnyL> Common, you guys want to say Splunge.. Just say it. SPLUNGE! hahaha.
15:59:16 --- mode: ChanServ set +o monochrom
15:59:20 --- mode: monochrom set +b *!*@unaffiliated/johnnyl
15:59:20 --- kick: JohnnyL was kicked by monochrom (JohnnyL)
16:00:12 --- mode: monochrom set +b-bo $a:JohnnyL *!*@unaffiliated/johnnyl monochrom
16:01:16 --- mode: ChanServ set +o monochrom
16:01:26 --- mode: monochrom set -b+b-o $a:JohnnyL *!*@unaffiliated/johnnyl monochrom
16:01:54 <MarcelineVQ> idk if that was neccesary :> you could just respond with a custom "oh no it's retarded" meme
16:02:06 <monochrom> I don't know of that meme.
16:02:24 <monochrom> Actually I know very very few memes.
16:03:33 <MarcelineVQ> https://imgur.com/a/PqP3Lvv
16:05:28 <dolio> Kickban seems more appropriate.
16:22:19 <Axman6> monochrom: a lattice of complications
16:28:13 <Axman6> re: the horology comment
16:28:50 <ilja> Hello! Does anybody knows why Elm don't provide public interface for type classes? Seems like it's so useful thing
16:29:34 <dolio> My impression is they think they are 'too complicated' or something.
16:32:17 <Axman6> Elm feels like the Go of the Haskell world to me, a simplification of things people already know how to use, which goes just a little too far and loses a lot of power
16:33:24 <ilja> Interesting is that community and demand for Elm is pretty big in spite of inferior design decisions 
16:33:53 <Axman6> I wouldn't say inferior.
16:34:22 <Axman6> it's supposed to a language aimed at people with no experience in FP, not those with plenty; it raises the skill of the community from the bottom
16:35:12 <Axman6> I don't think it takes most people long to say "I just wrote the same thing half a dozen times, why can't I abstract this?" and then start looking at options like GHCJS or purescript
16:36:13 <ilja> I'm just curious are there good Elm alternatives but with classes? I did tried replica/concur - looks cool, but I don't think it's ready for commercial usage
16:36:34 <Axman6> purescript?
16:37:48 <ilja> Maybe, it looks pretty similar to Haskell, maybe it's a bit easier option for haskeller then elm
16:43:49 <jackdk> so you know how many people can move from one imperative language to another because they're used to the idea that commands are executed in sequence and you break up your program using procedure calls? moving between haskell/ml/elm/purescript/nixlang/dhall starts to feel like that
16:44:26 <jackdk> it takes time, though, and is hard to see when you've just come through the paradigm shift into elm or into haskell or whatever
16:50:08 <jackdk> ilja: so you know how many people can move from one imperative language to another because they're used to the idea that commands are executed in sequence and you break up your program using procedure calls? moving between haskell/ml/elm/purescript/nixlang/dhall starts to feel like that. it takes time, though, and is hard to see when you've just come through the paradigm shift into elm or into haskell or whatever
16:54:43 <ilja> jackdk well, maybe for me it's just better to use some client framework like miso - basically I'm looking for possibilities to write frontend with minimal friction 
16:55:17 <ilja> unfortunately elm looks like too much friction for me
16:55:46 <ilja> maybe you can recommend me good client side frameworks just in haskell?
17:12:26 <Guest_36> Getting this error message while building ghcup: "_eghcup --cache install ghc recommended" failed!. Can someone help?
17:31:27 <sm[m]> paging maerwald 
17:42:53 * hackage predicate-typed 0.7.4.3 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.4.3 (gbwey)
17:53:52 * hackage hsaml2 0.1.1 - OASIS Security Assertion Markup Language (SAML) V2.0  https://hackage.haskell.org/package/hsaml2-0.1.1 (DylanSimon)
17:54:13 <GreeboSnabble> Is there a way to put a constraint on a type parameter without using it up?
17:54:42 <GreeboSnabble> Like (Ord k) => M.Map k 
17:55:22 <GreeboSnabble> Except I want it to be  of kind * -> * -> *
17:55:59 <erisco> no, constraints cannot be lifted
17:56:26 <GreeboSnabble> Thanks :\
18:39:48 <hololeap> % :t handle
18:39:48 <yahb> hololeap: forall {e} {a}. Exception e => (e -> IO a) -> IO a -> IO a
18:39:54 <hololeap> % :t handle print
18:39:54 <yahb> hololeap: ; <interactive>:1:1: error:; * Ambiguous type variable `a0' arising from a use of `handle'; prevents the constraint `(Exception a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Exception NestedAtomically -- Defined in `Control.Exception.Base'; instance Exception NoMethodError -- D
18:40:04 <hololeap> i don't understand this
18:40:20 <hololeap> any Exception is also an instance of Show
18:44:04 <glguy> hololeap: you have to pick one exception type in particular
18:44:27 <glguy> and you've lost the ability to specify which one you're picking
18:47:30 <glguy> % :set -XAllowAmbiguousTypes
18:47:31 <yahb> glguy: 
18:47:46 <glguy> % let f :: forall e. Exception e => IO () -> IO (); f = handle @e print
18:47:46 <yahb> glguy: 
18:48:29 <glguy> % f @SomeException (fail "glguy")
18:48:29 <yahb> glguy: user error (glguy)
18:54:17 <hololeap> is there any way to do this without enabling AllowAmbiguousTypes for the whole module?
18:56:25 <glguy> hololeap: put a type signature on print
18:56:55 <glguy> % :t handle (print :: SomeException -> IO ())
18:56:56 <yahb> glguy: IO () -> IO ()
18:57:23 * hackage vulkan 3.6.13 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6.13 (jophish)
19:07:52 <GreeboSnabble> Is there a type level version of const?
19:08:07 <GreeboSnabble> like typeConst :: * -> * -> *
19:08:42 <c_wraith> Control.Applicative.Const ?
19:09:19 <c_wraith> Haskell doesn't have type-level lambdas, so newtypes like that are as close as you get
19:11:06 <GreeboSnabble> Thanks, looks pretty good
19:12:23 <hololeap> glguy: cool, seems to work
19:12:39 <hololeap> ideally, i would also like to log the exception type
19:17:38 <jle`> hololeap: you can use SomeException for that
19:17:44 <jle`> but that would catch all exceptions
19:17:53 <jle`> which is sort of not recommended unless you know how it could go wrong
19:18:17 <jle`> hololeap: remember the goal of `handle` is to "peel off" specific exception types; the function you give it will tell it which exception types to catch
19:20:22 * hackage reflex-gadt-api 0.2.1.0 - Interact with a GADT API in your reflex-dom application.  https://hackage.haskell.org/package/reflex-gadt-api-0.2.1.0 (abrar)
19:23:05 <hololeap> jle`: my approach for right now is just to log the exception and have the program abort
19:24:15 <hololeap> there aren't too many exceptions that would happen. IO is really the only one i can imagine
19:27:03 <hololeap> and i don't have any plan currently for handling those, thus just log them and quit, which i should be able to do with any exception, assuming it happens within the `handle` block
19:31:49 <jle`> yeah, if you give `handle` a `SomeException -> IO a`, then it will handle all exceptions
19:31:59 <jle`> if you give it a `IOException -> IO a`, it will handle only IOException
19:32:03 <jle`> etc.
19:32:15 <jle`> so handle is type-directed, like `read`
20:49:38 <bqv> :t (.*)
20:49:39 <lambdabot> error:
20:49:39 <lambdabot>     • Variable not in scope: .*
20:49:39 <lambdabot>     • Perhaps you meant one of these:
20:49:53 <bqv> :t Data.Composition.(.*)
20:49:54 <lambdabot> error:
20:49:54 <lambdabot>     Not in scope: data constructor ‘Data.Composition’
20:49:54 <lambdabot>     No module named ‘Data’ is imported.
20:50:18 <bqv> Data.Composition (.*) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
20:50:34 <bqv> What a goddamn specific function
20:50:58 <bqv> (only came across it thanks to pointfree)
20:52:04 <bqv> (but I think this pointfree transformation is too heinous even for me)
20:57:21 <jle`> fwiw the syntax is (Data.Composition.*)
20:57:49 <jle`> :t (Prelude.+)
20:57:50 <lambdabot> Num a => a -> a -> a
21:12:52 * hackage happy-hour 0.0.0.2 - Generate simple okay-looking bar plots without much effort  https://hackage.haskell.org/package/happy-hour-0.0.0.2 (Monoid_Mary)
21:19:46 <siraben> Is there a Haskell library to automatically benchmark and compare two functions?
21:20:40 <ammar2> siraben: criterion
21:21:32 <siraben> ammar2: thanks
21:22:02 <Axman6> there's acouple of alternatives but criterion is still the goto
21:38:29 <sm[m]> timeit is also good for simple timing
21:45:20 <Axman6> just learned about https://hackage.haskell.org/package/bench, looks like a nice `time` replacement
22:44:00 <bqv> Why were affine traversals removed from lens?
22:46:57 <dibblego> they have no purpose
23:07:10 <bqv> Well, say I have an affinetraversal to an (index, value) pair, how do I make that into an indexed(affine)traversal?
23:07:32 <bqv> I see withIndex, but it seems wrong
23:30:23 <bqv> No, right, withIndex is the reverse of what I want
23:46:22 * hackage ukrainian-phonetics-basic 0.2.0.2 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.2.0.2 (OleksandrZhabenko)
23:54:41 <idnar> bqv: they need classes that are a bit tricky to fit in, so the hassle isn't worth the benefit
23:57:36 <bqv> Ah ok
23:59:33 <idnar> bqv: I think you want https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Indexed.html#v:indexing maybe
