00:00:22 <dminuoso> Question, when exposing some third party HTTP API with servant, would you rather just expose the servant API type, or provide a servant-client wrapper?
00:00:52 <jle`> in the past i have done both
00:02:27 <dminuoso> I guess there's not much value in exposing an API, since you'd have to stuff it into servant at the end anyway
00:02:59 <dminuoso> Did you have some other considerations?
00:03:22 <jle`> there are things you can do with the API other than just calling it maybe
00:03:27 <jle`> like generating documentation or other stuff
00:03:54 <jle`> also maybe they could integrate it into their other servant stuff maybe
01:11:13 * hackage kesha 0.1.0.0 - Haskell implementation of nix-hash  https://hackage.haskell.org/package/kesha-0.1.0.0 (jmackie)
01:38:08 <tomsmeding> 05:41:03          int-e | Util, what a great public module name
01:38:17 <tomsmeding> it's the Util module in the 'util' package, to make it even nicer
01:59:23 * dminuoso longs for {-# LANGUAGE GuessCode #-}
02:01:31 <idnar> dminuoso: like Hoogle+?
02:12:46 <tomsmeding> when encountering an unknown identifier that does occur in hoogle's database, automatically depend on that package and import the containing module?
02:25:31 <mouseghost> smh who wrote these docs :C 
02:27:32 <tomsmeding> which docs mouseghost?
02:28:24 <mouseghost> for lens package uh.. i guess i need to learn more haskell, or im looking at the wrong thing, or this is exactly what it is (and im just trying to understand why for some reason)
02:28:51 <mouseghost> namely ^. and Getting type def
02:29:11 <tomsmeding> the type signatures in lens are not quite known for being easily understandable for beginners :)
02:29:26 <mouseghost> ;___;
02:29:34 <tomsmeding> I suspect other members of the channel have opinions on this, dminuoso?
02:30:04 <tomsmeding> (with which I want to say that it's not your fault that you're having trouble :p)
02:30:07 <mouseghost> though, is it true that when it comes to type definition, arguments passed satisfy the equation on the right hand side of eq. sign?
02:30:23 <tomsmeding> what do you mean exactly?
02:30:26 <tomsmeding> example perhaps?
02:30:31 <mouseghost> type Getting r s a = (a -> Const r a) -> s -> Const r s
02:30:57 <mouseghost> uh i got even more confused :D
02:31:02 <tomsmeding> what do you mean with "satisfy equation on the right hand side"?
02:31:14 <tomsmeding> there's no = sign on the right-hand side, so also no equation :p
02:31:33 <tomsmeding> but a type definition using 'type' means that the left-hand side, in this case 'Getting r s a', can be 1-to-1 replaced with its right-hand side
02:31:42 <tomsmeding> whenever you see Getting applied to three type arguments
02:31:58 <mouseghost> ohh
02:32:17 <mouseghost> thanks :o
02:32:41 <tomsmeding> this in contrast, of course, to 'newtype' and 'data', which create new data types
02:32:51 <tomsmeding> 'type' is just a type synonym
02:33:40 <mouseghost> i see i see
02:56:34 <mouseghost> if theres a type def like :: a -> a, it means that just the type is the same, right :V?
02:58:06 <dminuoso> tomsmeding: optics is a great library for beginners.
02:58:15 <dminuoso> Or, mouseghost rather.
02:58:33 <mouseghost> mouseghosts hm
02:58:53 <dminuoso> optics wraps optics behind newtypes, making it much easier to read the types
02:59:00 <dminuoso> So rather than
02:59:02 <dminuoso> type Getting r s a = (a -> Const r a) -> s -> Const r s
02:59:06 <dminuoso> You have something like
02:59:22 <dminuoso> to :: (s -> a) -> Getter s a 
02:59:25 <dminuoso> Where Getter is a proper newtype
02:59:37 <dminuoso> No confusion, it's optics problem how that is represented
02:59:45 <dminuoso> And for things that work over any getter you have
02:59:48 <dminuoso> view :: Is k A_Getter => Optic' k is s a -> s -> a 
03:00:35 <mouseghost> o_o
03:00:37 <dminuoso> And you get nice diagnostics based on that, where GHC will error out like "A_Getter cannot be used as A_Setter", rather than constraint errors
03:00:54 <dminuoso> Compare the above to the lens equivalen
03:01:48 <mouseghost> thanks hm
03:02:57 <dminuoso> view :: MonadReader s m => ((a -> Const r a) -> s -> Const r s) -> m a 
03:03:05 <dminuoso> view :: MonadReader s m => Getting a s a -> m a 
03:03:22 <dminuoso> These two are the same, and depending on how GHC runs, you will see the former in GHC diagnostics
03:03:41 <mouseghost> yeah i understand
03:05:10 <mouseghost> dminuoso, do parentheses always imply a function then? and hence do all type synonyms have these implicit ()?
03:05:33 <dminuoso> No, parens are just to control how things associate
03:05:40 <dminuoso> Similarly to value level
03:06:10 <mouseghost> hm
03:07:43 <mouseghost> thanks
03:08:41 <mouseghost> ill take a look at that optics package; im wondering, can packages be compatible then?
03:09:08 <mouseghost> nvm this doesnt make sesne
03:09:09 <mouseghost> sense
03:10:33 <mouseghost> thanks uwu
03:10:59 <nitrix> Finally someone speaking my language.
03:14:26 <mouseghost> nitrix, :3
03:21:34 <maerwald> mouseghost: what do you mean with compatible
03:22:43 * hackage arch-hs 0.5.0.0 - Distribute hackage packages to archlinux  https://hackage.haskell.org/package/arch-hs-0.5.0.0 (berberman)
03:23:06 <mouseghost> maerwald, that, given a package b depending on a package c, i could use package d if types matched or something
03:23:20 <maerwald> you may want to check https://hackage.haskell.org/package/optics-vl
03:23:35 <maerwald> which allows you to convert between lens and optics
03:24:48 <dminuoso> mouseghost: optics comes with primitives to build stuff from van laarhoven on most things (where its possible)
03:25:33 <mouseghost> o-o thanks
03:51:32 <mouseghost> btw, why is it called van laarhoven
03:53:28 <dminuoso> Twan Van Laarhoven is the person who came up with the original idea and encoding.
03:53:38 <dminuoso> https://www.twanvl.nl/blog/haskell/cps-functional-references
03:53:41 <dminuoso> type RefF a b = forall f. Functor f => (b -> f b) -> (a -> f a)
03:53:52 <dminuoso> Which looks an awful lot like `Lens'` :)
03:53:59 <dminuoso> type Lens' s a = Lens s s a a
03:54:06 <dminuoso> type Lens s t a b = forall f . Functor f => (a -> f b) -> s -> f t
03:54:07 <dminuoso> So
03:54:24 <dminuoso> We call this particular encoding of "lenses" (a term not known back then) as van laarhoven encoding, as tribute to him
03:54:58 <mouseghost> i see, i couldn't find the proper van laarhoven hence i asked :P thanks
04:32:14 * hackage polysemy-path 0.2.0.0 - Polysemy versions of Path functions.  https://hackage.haskell.org/package/polysemy-path-0.2.0.0 (locallycompact)
04:40:13 * hackage aeson-injector 1.1.5.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.1.5.0 (NCrashed)
04:54:02 <sondr3> How are people structuring their AoC projects for Haskell? I did it last year with a separate binary for each day but didn't really enjoy how I structured it
04:57:01 <tomsmeding> haskell files and a Makefile :p https://git.tomsmeding.com/AOC/tree/2019
04:57:12 <tomsmeding> less cruft more better
05:09:29 <sondr3> Very KISS, I like it
05:12:48 <tomsmeding> (In the unlikely case that I find myself wanting to use a library not in the core GHC package, I'll use cabal :) )
05:13:43 * tomsmeding guesses that 'random' is the most likely candidate for such a library
05:17:56 * tomsmeding will be finishing his thesis in december so won't have much time for AoC anyway :(
05:23:53 <__monty__> Heh, most exiting thing about my AoC setup is I might go with Megaparsec rather than ReadP this year >.<
05:25:31 <solonarv> I'll probably just steal jle's framework this year :p
05:25:46 <xerox_> I do a simple cabal project with a library and many executables
05:41:15 <merijn> I'll do the same as last year, finish 5 days of puzzles and then get to busy with work :p
05:45:20 <sondr3> First year where all my exams are done before AoC, 
05:45:45 <sondr3> so I'll probably give up when I start spending many hours on each problem *
06:13:49 <__monty__> merijn: Similar, though I try to beat more days each year.
06:14:20 <__monty__> sondr3: That'd mean I have to stop on day 1 -_-
06:18:14 <merijn> __monty__: I had to focus on getting a paper done last year, this year I still have 2 chapters of thesis rewriting that conflicts with useful things, like AoC :p
06:51:43 * hackage jvm-batching 0.2.0 - Provides batched marshalling of values between Java and Haskell.  https://hackage.haskell.org/package/jvm-batching-0.2.0 (FacundoDominguez)
07:16:47 <timCF> Hello guys! Any DHall users there? How do I create `newtype` in DHall? And how to derive `Show` instance for custom types like enums?
07:18:50 <timCF> Because without `newtype` signatures of functions and types are looking kinda disappointing, everything is like `Text -> Text -> Text -> Text`
07:39:22 <kupi> how to ignore a specific rule in a specific function with hlint?
07:39:50 <kupi> i think redundant lambda can improve readibility if there are many parameters and the result is intended as a function
07:40:13 <kupi> equalP' f k = \w x y z -> f w x y z == k instead of equalP' f k w x y z = f w x y z == k
07:42:32 <kupi> i know there is:  {- HLINT ignore "Redundant lambda" -}, but this makes it to ignore for other functions
07:45:29 <merijn> kupi: hlint is full of questionable recommendations
07:45:58 <merijn> It is a very opinionated tool, so if your opinions are different from Neil Mitchell, you'll have to customise it heavily
07:48:08 <__monty__> timCF: Maybe try #dhall.
08:57:17 <maerwald> merijn: you can't really customize it, can you?
09:17:10 <tomjaguarpaw> You can customize it with a yaml file, can't you? https://neilmitchell.blogspot.com/2017/04/hlint-20-with-yaml-configuration.html
09:27:47 <kupi> i did
09:27:48 <kupi> - ignore: {name: Redundant lambda}
09:40:16 <ezzieyguywuf> glguy: with config-schema, let's say I want tho config file to require one or more top-level sections, each with the same specification. In other words, to use the example from the documentation, let's say that "name", "age" etc were all underneath a section "Person1", and I wanted to allow an arbitrary number of persons, "Person2", "Person3", etc... would the only way to accomplish this be to 
09:40:22 <ezzieyguywuf> create a list at the top-level?
09:40:58 <glguy> Yeah, you could have a top-level list
09:41:34 <ezzieyguywuf> glguy:  https://dpaste.com/FF6PKHXHJ
09:41:59 <ezzieyguywuf> glguy: so would doing something as I've posted here be impossible? i.e. without using a list, let the user specify an arbitrary number of PersonN?
09:43:55 <ezzieyguywuf> I think it'd have to look like this https://dpaste.com/E2JT7RLMW or this https://dpaste.com/E2JT7RLMW
09:43:59 <ezzieyguywuf> unless I'm missing something
09:44:04 <glguy> I'll look now
09:44:54 <Sonolin> I just realized BSD-3 requires me to include the license of the dependency when I distribute in binary form... is there an easy way to get all these licenses via stack? Or at least a way to just retrieve all the dependencies' source code?
09:44:54 <glguy> ezzieyguywuf, I think you want this: https://hackage.haskell.org/package/config-schema-1.2.1.0/docs/Config-Schema-Spec.html#v:assocSpec
09:45:06 <glguy> >> Specification for a section list where the keys are user-defined. Values are matched against the underlying specification and returned as a list of section-name/value pairs.
09:46:27 <ezzieyguywuf> glguy: 👍️ I think you're right! thanks again for your prompt response and your help.
09:46:46 <glguy> ezzieyguywuf, Do you have a usecase in mind, or are you in the learning phase first?
09:46:53 <ezzieyguywuf> glguy: I have a use-case
09:47:09 <ezzieyguywuf> glguy: I could post an example of what I'm after if you'd like
09:47:18 <glguy> sure
09:52:18 <ezzieyguywuf> glguy: I think something like this https://dpaste.com/C7QAL6VTG
09:53:07 <__monty__> timCF: You can define values of type Type, which is what you'd want to do I think, e.g., https://github.com/dhall-lang/dhall-lang/blob/v19.0.0/Prelude/XML/Type.dhall
09:54:14 <__monty__> timCF: There's no way I know of to derive implementations of functions in dhall.
09:54:51 <glguy> ezzieyguywuf: one note, unquoted "atoms" and quoted "strings" are intended to be distinct
09:55:19 <glguy> ezzieyguywuf: Are you using this with hledger, perhaps?
09:55:45 <ezzieyguywuf> glguy: yes, with hledger. and I'm aware of the atom vs. string distinction, but I didn't think I could use a string as a section name
09:55:56 <glguy> I was looking at the MatchStrings
09:56:10 <glguy> like line 16 would be a problem
09:56:10 <ezzieyguywuf> glguy: ah, yes those should be quoted
09:56:27 <ezzieyguywuf> MatchStrings should be a list of strings, no atoms
09:56:50 <ezzieyguywuf> line 3 would be a problem, due to the apostrophe, no?
09:57:12 <glguy> Yeah, there were multiple problems, I was just trying to be specific
09:57:43 <glguy> You could definitely express that fragment in config-schema, though
09:59:30 <ezzieyguywuf> glguy: right. (fixed the errors btw https://dpaste.com/CRFUTYMZE). so assocSpec here would return [("walgreens", MyReturnData), ("sheetz", MyReturnData), ("amazon", MyReturnData)]
09:59:46 <ezzieyguywuf> right?
10:00:01 <glguy> Yeah
10:00:25 <glguy> and then if you wanted to do the "automatically added" part you'd (fmap autoadd) over that list to fold in the name
10:01:11 <ezzieyguywuf> right. well, I'm storing it as a Data.List.NonEmpty, so I take the name as the starting point then concat the (possibly empty) list from MatchStrings
10:02:47 <ezzieyguywuf> glguy: what's the difference between, say, optSection and optSection'? I see that one has a "HasSpec" requirement on 'a', but I don't really understand the distinction.
10:03:21 <glguy> One uses the element type to pick the schema and the other takes a manually specified one
10:04:42 <ezzieyguywuf> glguy: so `name  <- reqSection  "name" "Full name"` I gues (a) the type of `name` is inferredd to be Text, and (b) Text has a HasSpec instance?
10:04:55 <glguy> yeah
10:05:07 <ezzieyguywuf> gotcha.
10:06:25 <glguy> fmap (\(n,(x,y,z,w)) -> (n NonEmpty.:| x, y, z, w)) <$> assocSpec (sectionsSpec "entry" ((,,,) <$> (fromMaybe [] <$> optSection "MatchStrings" "doc") <*> reqSection "MuxedDescription" "doc" <*> reqSection "DebitAccount" "doc" <*> reqSection "CreditAccount" "doc")) :: ValueSpec [(NonEmpty Text, Text, Text, Text)]
10:06:54 <glguy> You'd want to use a record, maybe some ApplicativeDo, real names, etc.
10:07:17 <glguy> but that would match the example you pasted
10:07:35 <maerwald> Sono
10:07:45 <maerwald> Sonolin: cabal-plan license-report
10:08:05 <Sonolin> maerwald thanks!
10:08:14 <ezzieyguywuf> glguy: neat thank you!
10:08:18 <Sonolin> I don't seem to have cabal installed, can I execute that through stack?
10:08:32 <maerwald> probably not
10:08:42 <ezzieyguywuf> stack install caball?
10:08:46 <ezzieyguywuf> though that's probably a bad idea..
10:08:54 <maerwald> I'm suspecting cabal-plan needs the plan.json, which only cabal generates
10:10:03 <Sonolin> hmm ok... I mean I'm pretty sure stack uses cabal somehow under the hood, but I'll look into it thanks for the help
10:10:21 <geekosaur> it doesn't in general
10:10:29 <geekosaur> it's an alternative to cabal
10:11:10 <Sonolin> ah ok
10:11:19 <Sonolin> looks like cabal-plan is on stackage I'll try installing that I guess
10:15:06 <sm[m]> Sonolin: you can of course stack install cabal-install. But usually it's quicker to find a binary package
10:16:24 <maerwald> don't use stack to install cabal, because you don't know whether you will get an up2date version
10:16:53 <sm[m]> sigh maerwald you are here to test me :)
10:16:58 <maerwald> :D
10:17:07 <maerwald> running property tests over you
10:18:14 <sm[m]> as with cabal, stack has rules for picking which version to install by default so to be sure of getting the latest you should specify that version
10:20:19 <sm[m]> neither tool has a "get me the latest" flag alas
10:21:42 <monochrom> In the case of cabal-install, that depends on exe vs lib
10:23:11 <monochrom> "cabal install <pkg>" (such that it installs the exes of pkg) gets you the latest by default, you have to saying something to override.
10:23:51 <monochrom> "cabal install --lib <pkg>" (such that it installs the library of pkg) tends to prefer an installed version and report "up to date".
10:28:55 <sm[m]> monochrom: only if you do cabal update first
10:29:37 <sm[m]> otherwise you can't be sure. Maybe later cabal has changed, I'm speaking of commonly installed versions
10:46:52 <avdb> Is there a way I can use elem on two lists instead of recursing through the first list element by element?
10:47:14 <koz_> avdb: What do you mean? Do you want to do a list intersection or something?
10:47:37 <monochrom> Yeah it depends on what problem you are solving.
10:48:16 <monochrom> You should spell out your one single case rather than expecting a 2-hour lecture that covers all cases.
10:48:23 <avdb> koz_: I want to know if [1,2,3,4,5] contains any element of [1,2,3] for example, instead of doing `elem 1 [1,2,3] ...` for every single element.
10:50:50 <monochrom> That really requires a nested loop. Although you can use library functions so you don't have to handcode your own recursion tediously.
10:51:12 <avdb> I don't like the idea of library functions for small programs ...
10:51:27 <monochrom> Unless you further know that both lists are sorted under a known total order.
10:51:47 <koz_> avdb: You can use Sets. Take the set difference between (the Set based on) [1,2,3] and (the Set based on) [1,2,3,4,5,6]. Set diff is 'all elements in A that are not also in B'. If you get back the same as the first set, then there are none; otherwise, the one(s) you're missing are in there.
10:52:10 <koz_> avdb: Prelude is a library. containers comes with GHC itself (it's a boot library).
10:52:14 <koz_> I don't see the issue.
10:52:54 <monochrom> You like handcoding your own "mysum [] = 0; mysum (x:xs) = x + mysum xs" boilerplate instead of simply "foldr (+) 0" and be done with it?
10:53:02 <avdb> Alright, I wasted enough time on this problem already so let's stop being stubborn.
10:53:13 <koz_> monochrom: You mean foldl' (+) 0 right? 
10:53:16 <ezzieyguywuf> glguy: in the example you provided, how come `optSection "MatchStrings" "doc"` doesn't need `listSpec` somewhere?
10:53:35 <monochrom> well let's say I really like the foldr version for some reason
10:53:46 <glguy> ezzieyguywuf: there's an instance HasSpec a => HasSpec [a]
10:53:50 <koz_> monochrom: Sure. This is a demo of why libraries are usually the better call for common problems :P
10:53:51 <glguy> and instance HasSpec TExt
10:54:16 <monochrom> any (`elem` [1,2,3]) [1,2,3,4,5]   -- done
10:55:35 <ezzieyguywuf> glguy: ah, so the `ValueSpec [Text]` is deduced, i get it. if I wanted to write that one line in applicative-do with a type annotanio, it'd be `matches <- optSection "MatchString" "doc" :: Maybe [Text]`, right?
10:55:49 <monochrom> another way: not (null (intersect [1,2,3,4,5] [1,2,3]))
10:55:50 <ezzieyguywuf> or `Maybe [ValueSpec Text]`?
10:56:03 <glguy> ezzieyguywuf: ValueSpec (Maybe [Text])
10:56:39 <ezzieyguywuf> hmmm, very nice. glguy thanks again.
11:02:23 <avdb> Jesus Christ. Even with external libraries this exercise is extremely difficult. I need to tell the difference between uppercase messages and lowercase messages. Sounds easy right?
11:03:03 <avdb> Problem is that "1,2,3" should return False while "1,2,3 GO!" should return True (since it doesn't contain lowercase characters).
11:03:16 <avdb> Can someone please help me? I already spent more than 5 hours on this problem.
11:03:48 <monochrom> > any isUpper "1,2,3 GO!"
11:03:51 <lambdabot>  True
11:03:59 <monochrom> isUpper is in Data.Char
11:04:06 <avdb> I know.
11:04:17 <monochrom> But even writing your own recursion takes only 1 minute. What 5 hours.
11:04:21 <avdb> Man I should've asked for help earlier but it feels like cheating.
11:04:28 <ezzieyguywuf> (it is cheating)
11:04:30 <avdb> I didn't know about `any`
11:04:43 <ezzieyguywuf> well, asking for help isn't cheating
11:04:47 <ezzieyguywuf> asking for answers is cheating
11:05:05 <avdb> Not if you tried really hard I guess.
11:05:08 <avdb> monochrom: Thanks.
11:05:44 <monochrom> Why I'm more successful than you is because I invested those 5 hours on reading Prelude and Data.List and Data.Char from cover to cover, instead of invested in false confidence in my own competence.
11:06:27 <glguy> and then years of using it?
11:06:28 <avdb> Where can I learn more about STL functions? There's Hoogle but I find it very difficult to read.
11:07:05 <monochrom> Yes glguy, years of taking only 1 second to recall "that's just another foldr"
11:07:14 <ezzieyguywuf> oh nice, `concat (Maybe [a])` produces an empty list or a list, that's so handy!
11:07:25 <glguy> STL is a C++ library. I like using http://cppreference.com/ to read about it
11:07:26 <monochrom> GHC comes with complete documentation.
11:07:48 <monochrom> It is somewhere on your harddisk already, too.
11:07:55 <avdb> glguy: I meant standard library functions in Haskell like (++) and index for example.
11:08:12 <monochrom> People spent lifetimes searching hoogle and not even 1 minute searching their own hard disk
11:08:32 <monochrom> But I guess that's the definition of "I am too proud to be an introvert"
11:08:42 <avdb> monochrom: I know, I really do know. Where did you find it?
11:09:21 <xerox_> https://www.stackage.org/haddock/lts-16.23/base-4.13.0.0/Prelude.html
11:09:33 <avdb> You can stop making me out for stupid right there by the way, I already acknowledged my mistake.
11:16:13 <maerwald> monochrom: accessing my hard disk takes longer than a HTTP request :p
11:16:47 <avdb> maerwald: You can find GHC's documentation in .ghcup/share/doc/ :)
11:17:00 <avdb> (If you didn't know already, trying to be helpful)
11:17:11 <maerwald> should probably try that :D
11:17:43 <maerwald> the vim hoogle plugin is also quite handy
11:18:01 <maerwald> so I use vim hoogle and codex (via hasktags)
11:18:16 <maerwald> both are limited, but they don't crash my PC like LSP
11:21:06 <frdg> if I move my ~/.stack directory will my existing stack projects get confused?
11:21:23 <Sonolin> they will probably re-download all the dependencies and stuff 
11:21:42 <Sonolin> but you can always move it back 
11:21:45 <frdg> ok that is fine
11:26:18 <avdb> monochrom: I finally realize that I could've used filter all along to filter symbols and numbers. Facepalm.
11:27:10 <frdg> Sonolin: you were correct that it is re-downloading all the stuff. My question now is what happened to the old downloaded stuff?
11:27:26 <maerwald> frdg: you moved it
11:27:30 <Sonolin> yea it goes in .stack
11:27:35 <maerwald> :D
11:28:25 <frdg> I dont see why if I only moved it, it has to redownload though.
11:29:05 <geekosaur> you mean, you moved it and then moved it back and it's still redownloading?
11:29:19 <_deepfire> So, I'm thinking of implementing  reifyType :: Typeable a => Q Type  myself, because apparently TH doesn't have anything that can be used to make it.
11:29:29 <frdg> and by redownload I mean I am trying to run the program and it is compiling everything again
11:34:32 <frdg> oh wait a second I see what is going on now. It compiles into ~/.stack...this directory is not what I thought it was
11:34:37 <Sonolin> frdg ~/.stack contains the GHC snapshot & dependencies for stack projects... if you move that folder, then it will redownload everything to a new "~/.stack" folder
11:36:14 <ezzieyguywuf> glguy: hah, it works! I took your example and prettified it a bit with applicative-do etc, to make it more legible. https://dpaste.com/6H9HE8UVM
11:36:43 <ezzieyguywuf> glguy: I can see now the appeal of the config-value and config-schema approach to configuration. very nice, very neat.
11:37:39 <avdb> I finally fixed my problem but my codebase is a mess since I mixed up pattern matching with guards, how do I create a guard case for an empty list?
11:37:53 <avdb> `null (x:xs)` doesn't look good
11:37:57 <avdb> I doubt it even works lol
11:38:06 <geekosaur> that can't be null
11:38:15 <frdg> Sonolin: this is clear to me now thanks
11:38:25 <avdb> geekosaur: wdym?
11:38:27 <monochrom> Give null the actual list you care about?
11:38:52 <geekosaur> because you built a new list (x:xs) which by construction is not null
11:39:00 <ezzieyguywuf> avdb: "my codebase is a mess since..." maybe clean up the code first?
11:39:04 <avdb> Oh. Thanks.
11:39:12 <avdb> ezzieyguywuf: That's what I'm asking help for ...
11:39:38 <avdb> I don't know how to fix most stuff since I only used what I know but I promise to read the documentation on my hard-drive after this!
11:39:40 <geekosaur> foo xs | null xs = ... | ... -- although I'd use patterns unless guards are needed (note also that you can combine them)
11:39:56 <glguy> ezzieyguywuf: yeah, I think that cleaned up nicely
11:40:13 <avdb> I will just go with lst instead of (x:xs) and replace xs with tail
11:40:27 <geekosaur> foo [] = ...; foo (x:xs) | someConditionOn x = ... | otherwise = ...
11:41:09 <ezzieyguywuf> avdb: if you post your code perhaps we can provide some better tips
11:41:25 <avdb> geekosaur: What about where xs = tail lst? :)
11:41:26 <hololeap> avdb, null (x:xs) = False ; null [] = True
11:41:30 <avdb> ezzieyguywuf: Second
11:41:34 <hololeap> that's all there is to know about `null` (on lists)
11:41:46 <ezzieyguywuf> hrm, I'm a bit skeptical of my use of PartialMatch, but it does get the job done...
11:42:04 <glguy> ezzieyguywuf: if you used (matchSpec = sectionsSpec "match") instead of an "" there, the output of (generateDocs descrMatchSpec) makes more sense
11:42:36 <ezzieyguywuf> glguy: I was just about to start messing with generateDocs, so I'll try it both ways to see the differenc
11:42:43 <avdb> http://codepad.org/yUeYsJQ4
11:42:45 <avdb> Here you go!
11:43:24 <ezzieyguywuf> glguy: I must say, very nicely documented and organized code base, quite the pleasure to work with it.
11:44:03 <glguy> Thanks, I'll have that message for next time I'm feeling down :)
11:44:47 <ezzieyguywuf> glguy: lol, no problem
11:45:23 <ezzieyguywuf> avdb: I think Data.List.Uncons may help clean that up a bit
11:45:56 <ezzieyguywuf> although I wonder whether you truly need to split the list into head and tail...
11:47:05 <avdb> ezzieyguywuf: I don't, the solutions about work as well :P
11:47:23 <Sonolin> avdb using pattern matching would clean that up
11:47:35 <Sonolin> upperString [] = False
11:47:39 <Sonolin> upperString (x:xs) = ...
11:47:45 <hololeap> avdb: `upperString` could be simplified in a number of different ways
11:48:02 <ezzieyguywuf> Sonolin: also ned upperString (x) =...
11:48:03 <avdb> Sonolin: Alright, Alright, I first need to make sure it passes `stack test` though
11:48:17 <avdb> ned?
11:48:25 <ezzieyguywuf> uhrm, upperstring [x] =... well, whatever it is for a singlton
11:48:27 <ezzieyguywuf> *need
11:48:44 <ezzieyguywuf> also, that was intended for Sonolin sorry.
11:48:47 <Sonolin> ezzieyguywuf ? I don't think so, upperString (x:xs) should take care of that since xs can still be an empty list
11:48:55 <hololeap> % upperString :: String -> Bool ; upperString [] = False ; upperString xs = all isUpper xs
11:48:55 <yahb> hololeap: 
11:49:08 <ezzieyguywuf> Sonolin: ah hah, your type-fu obviously surpasses mine
11:49:13 <hololeap> % upperString "ABCD"
11:49:14 <yahb> hololeap: True
11:49:19 <hololeap> % upperString "aBc"
11:49:19 <yahb> hololeap: False
11:49:22 <hololeap> % upperString ""
11:49:22 <yahb> hololeap: False
11:49:51 <ezzieyguywuf> %upperString "1,2,3 GO!"
11:49:57 <ezzieyguywuf> drat
11:50:01 <ezzieyguywuf> % upperString "1,2,3 GO!"
11:50:02 <yahb> ezzieyguywuf: False
11:50:56 <avdb> hololeap: So there's any and all ... thanks ... didn't know that ...
11:51:55 <hololeap> avdb: yes, and `all f []` always returns True, which is why you need the special case for the empty list
11:52:05 <hololeap> if you want the empty list to return False, that is
11:52:30 <monochrom> I wonder if you really benefit from upperString [] = False
12:18:41 <avdb> > all isUpper ""
12:18:44 <lambdabot>  True
12:19:12 <ezzieyguywuf> > all [isUpper "", not null ""]
12:19:15 <lambdabot>  error:
12:19:15 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
12:19:15 <lambdabot>                    with actual type ‘[Bool]’
12:19:16 <avdb> Thanks!
12:19:19 <avdb> Ouch
12:19:23 <ezzieyguywuf> dang
12:19:42 <avdb> all isUpper xs && not null xs?
12:20:09 <ezzieyguywuf> yea that
12:22:21 <avdb> > upperString xs = (all isUpper $ filter isLetter "  ") && (not $ null "  ")
12:22:23 <lambdabot>  <hint>:1:16: error: <hint>:1:16: error: parse error on input ‘=’
12:22:31 <avdb> > (all isUpper $ filter isLetter "  ") && (not $ null "  ")
12:22:33 <lambdabot>  True
12:22:50 <avdb> This is supposed to return false :$
12:24:53 <Sonolin> don't need the filter
12:25:02 <avdb> I do for whitespace
12:25:14 <Sonolin> > all isUpper " "
12:25:17 <lambdabot>  False
12:25:27 <avdb> Ouch!
12:26:35 <avdb> Nope. I do. Otherwise "WATCH OUT!" won't return True.
12:26:53 <Sonolin> well you can do 
12:26:59 <Sonolin> > any isUpper "WATCH OUT!"
12:27:01 <lambdabot>  True
12:27:20 <avdb> > any isUpper "WaTCH OUT!"
12:27:23 <lambdabot>  True
12:27:34 <Sonolin> but if you truly want the filter you'll have to refactor that so you're checking not null on the filtered string as well
12:27:34 <avdb> Is supposed to return false since one letter is lowercase
12:28:24 <Sonolin> something like this
12:28:26 <Sonolin> > let xs = filter isLetter "WATCH OUT!" in all isUpper xs && not (null xs)
12:28:29 <lambdabot>  True
12:28:37 <Sonolin> > let xs = filter isLetter " " in all isUpper xs && not (null xs)
12:28:39 <lambdabot>  False
12:29:16 <avdb> Now we broke response for numbers only
12:29:26 <avdb> all isUpper "12234"
12:29:29 <avdb> > all isUpper "12234"
12:29:31 <lambdabot>  False
12:30:01 <Sonolin> you'll have to change the filter than
12:30:17 <Sonolin> gotta go but you should be able to figure it out, you're close
12:30:33 <avdb> I really am ... what a headache 
12:34:58 <sondr3> That's a harsh name change :p
12:44:09 <sondr3> I'm about to add an environment to my toy language, previously my state has been either `Map String Val` or `[(String, Val)]`. Should I look into using something like the Reader or State monad?
12:47:41 <Rembane> sondr3: State monad is good if you have many functions, otherwise a f :: SomeStateType -> (SomeStateType, a) works for quite a while 
12:49:40 <dminuoso> State monad also helps against accidents. When you write `\x -> let (x', v) = f x in ...` you can easily mix up x and x' over time
12:49:49 <dminuoso> Or when you tend to have multiple values of type SomeStateType around
12:49:59 <dminuoso> And it can be more expressive
12:50:26 <dminuoso> Since it opens up the realm of applicative/monad combinators like traverse
12:50:50 <solonarv> if your toy language has only immutable bindings then you don't actually need the full power of State, you can continue using Reader
12:51:22 <solonarv> note that 'Reader E a' is the same thing as 'E -> a', and 'State S a' is the same thing as 'S -> (a, S)'
12:54:29 <monochrom> Environment does not behave like State.
12:55:08 <monochrom> You can still use state to emulate environment. But that requires understanding both.
12:58:06 <dminuoso> And you can use environment as state if you have IO.
13:22:54 <mang0[m]> hi
13:38:12 <ezzieyguywuf> is there something like `mGetFile :: FilePath -> Maybe Text` is Base that returns Nothing if the file doesn't exist?
13:38:26 <ezzieyguywuf> I see `Data.Text.IO.readFile` but this just throws an exception
13:38:52 <ezzieyguywuf> or rather, should I check for existence of the file some other way?
13:39:22 <f-a> ezzieyguywuf: it seems one of those oops which are better handled by- yes, use 
13:39:24 <f-a> @hoogle FilePath -> IO Bool
13:39:25 <lambdabot> System.Directory doesPathExist :: FilePath -> IO Bool
13:39:25 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
13:39:25 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
13:39:46 <f-a> if you want the -> Maybe String, capture that exception
13:39:53 <maerwald> ezzieyguywuf: no, you catch the excpetion isDoesNotExistError
13:40:27 <maerwald> cehcking for existence before accessing the file is an anti-pattern :)
13:40:28 <ezzieyguywuf> so I've been operating under the general rule of thumb that I should prefer to use Maybe rather than exceptions when programming is haskell
13:40:51 <maerwald> yes, you can turn the exception into a Nothing
13:41:27 <ezzieyguywuf> how do you catch an exception in haskell?
13:41:56 <maerwald> https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Exception.html#v:handle
13:42:43 <ezzieyguywuf> ah hah, I see
13:42:47 <ezzieyguywuf> maerwald: thank you.
13:50:59 <ezzieyguywuf> I'm still struggling - I understand how catch/handle are supposed to work, but how do I know if I'm accounting for every possible exception?
13:51:04 <ezzieyguywuf> or is that impractical?
13:51:16 <maerwald> ezzieyguywuf: https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Error.html#v:isDoesNotExistError
13:51:21 <maerwald> you only care about that one
13:51:32 <maerwald> and possibly https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Error.html#v:isPermissionError
13:52:05 <maerwald> so you check the error in the handler with those two functions
13:52:17 <ezzieyguywuf> isDoesNotExistError returns a bool, but handle expects an `e -> IO a`
13:52:30 <maerwald> yes, you should be able to figure this out :p
13:53:19 <maerwald> look at the whole type signature and specialize the `a`
13:53:32 <ezzieyguywuf> lol, I should be able to figure this out...
13:54:12 <monochrom> ezzieyguywuf: http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#subtyping
13:54:28 <ezzieyguywuf> hrm, the documentation for catch is helpful here
13:54:38 <ezzieyguywuf> monochrom: ah, I'll have to check that out
14:00:27 <maerwald> ezzieyguywuf: https://gitlab.haskell.org/haskell/ghcup-hs/-/blob/master/lib/GHCup/Utils/Prelude.hs#L183 this is similar to what you need to do
14:01:26 <maerwald> so instead of `pure ()` you probably want something else
14:08:57 <dminuoso> 22:50:37  ezzieyguywuf | I'm still struggling - I understand how catch/handle are supposed to work, but how do I know if I'm accounting for every possible exception?
14:09:20 <dminuoso> ezzieyguywuf: It depends. Are you catching someone elses exceptions, or is the exception throwing part under your control?
14:11:02 <dminuoso> https://simonmar.github.io/bib/papers/ext-exceptions.pdf is a great read either way. If you get to control the exceptions, you can put them in this hierarchy and then have fine control over how to catch exceptions. If it's someone elses exceptions, it depends on their exception hygiene.
14:11:38 <dminuoso> That publication is a little more formal and detailed version of monochrom's tutorial
14:11:47 <dminuoso> But very readable
14:22:11 <iqubic> monochrom has a tutorial?
14:28:00 <iqubic> What's the status on the Monad of No Return proposal?
14:28:02 <iqubic> https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/monad-of-no-return
14:30:18 <ezzieyguywuf> dminuoso: catching someone else's (base's) exception
14:31:09 <dminuoso> ezzieyguywuf: So that's one of the sad parts of Haskell. It's usually not communicated or documented what IO exceptions can be thrown.. :(
14:31:16 <dminuoso> There's of course the sledge hammer of catching SomeException...
14:31:27 <dminuoso> But then you also must make sure not to recover from async exceptions..
14:31:48 <maerwald> and then you realize there's a library for that... and then you confuse the imports in your codebase
14:32:01 * dminuoso just uses Async.Exception and has banned Control.Exception
14:32:07 <dminuoso> That addresses that second part. :p
14:32:14 <dminuoso> errr
14:32:17 <dminuoso> *UnliftIO.Exception
14:32:24 <ezzieyguywuf> I just watch to (a) try to open a file. if fail, tell user. (b) try to Config.parse said file (from config-value). if fail, tell user. (c) try to Config.Schema.loadFile said parsed file (from config-schema). if fail, tell user
14:33:04 <ezzieyguywuf> I'd like a different message to the user depending on where the failure occurs. I was thinking of runExceptT since Config.parse and loadFile both return an Either
14:33:40 <ezzieyguywuf> but then for the first step, I guess I have to catch/handle, and convert to an IO (Either Text Text)
14:33:56 <ezzieyguywuf> and I guess also I need to convert the Left of Config.parse to be consistent
14:34:07 <maerwald> yes, please mix ExceptT with IO and open unions and then get confused by your own code
14:34:20 <maerwald> I also thought it's cool
14:34:24 <ezzieyguywuf> yea already confused
14:34:29 <ezzieyguywuf> so I guess this is a bad idea, lol
14:34:36 <maerwald> now I need 2 exception handlers, one for IO, one for exceptT
14:34:46 <maerwald> and then the code still crashes, lol
14:35:12 <dminuoso> Well the question is whether you can recover from it, or whether you just want to produce a sensible diagnostic.
14:35:45 <ezzieyguywuf> if any of those three operations fail, the program needs to exit and tell the user why
14:40:43 <ezzieyguywuf> actually I think only one of the three, the first, is even an IO action
14:40:57 <ezzieyguywuf> the other two are pure functions that return an Either, so ExceptT is definitely not the right call here
14:41:38 <ezzieyguywuf> i think I'll just start with the nested case statements
14:41:46 <ezzieyguywuf> and then post it and see if we can clean it up any
15:23:48 <iqubic> So, I have a cabal project, and I'd like to turn on -Wall for every file. Currently I'm just adding "{-# OPTIONS_GHC -Wall #-}" to the top of every file, but I feel there's some configuration I can add to my .cabal file to do this for me. Is that true?
15:31:13 <solonarv> it is true, yes; you can also add it to cabal.project or cabal.project.local (I would recommend one of the latter two)
15:31:35 <sclv> also your cabal file itself you can toss in a ghc-options: -Wall
15:31:52 <sclv> in the lib or executable stanzas
15:32:20 <iqubic> sclv: That's what I was looking for.
15:35:37 <hekkaidekapus> iqubic: To expand a bit, i) if there is a single package in the project, you can edit the .cabal file to use the `ghc-options` field for any components (library, executable,…). The field is like any other, `build-depends` for instance. ii) If there are many packages in the project, consider using a `cabal.project`. There, use a `package` stanza under which you will use the same field.
15:36:08 <iqubic> It's a single project.
15:36:14 <hekkaidekapus> Further reading: i) <https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-ghc-options>, ii) <https://cabal.readthedocs.io/en/3.4/cabal-project.html#package-configuration-options>
16:00:49 <cads> hey all, is there software that helps a code auditor manage the reading of a large and complex code base?
16:19:20 <wz1000> cads: what exactly do you want this software to do?
17:04:31 <ezzieyguywuf> so here's what I ended up with https://dpaste.com/2BDW9J64Y
17:05:01 <ezzieyguywuf> it seems to me that the nested-case statements is poor form
17:05:10 <ezzieyguywuf> but I'm open to thoughts/suggestions
17:22:14 <jle`> i wouldn't say it's necessarily bad, but you could pull out a bit of the boilerplate and make it a little more readable maybe with ExceptT
17:22:53 <jle`> which basically just integrates the IO sequencing and the Left/Right pattern matching into its >>=/Monad instance
17:25:10 <jle`> a small note, print . show should probably be just print, or putStrLn . show
17:25:29 <jle`> unless you really want the escaped string
17:25:34 <ezzieyguywuf> jle`: I changed all those to Systex.Exit.die, but thanks
17:25:41 <dmj`> ezzieyguywuf: you'll need to unify the different types of errors if you want to use do syntax for the Either monad, since it's defined on Monad (Either e). 
17:26:21 <jle`> idris has some nice syntax for bailing out of a do block with patterns like this
17:26:27 <jle`> that i wish haskell had sometimes
17:26:40 <dmj`> yea, we need a new haskell
17:26:50 <ezzieyguywuf> dmj`: I started doing that yesterday, but it started getting hairy. maybe I just was trying to do too much at once, may be worth a shot now.
17:27:08 <ezzieyguywuf> I was using either to try "unify" the Left types
17:27:21 <dmj`> ezzieyguywuf: data MyError = MyError1 String | MyError2 String, etc. 
17:27:24 <dmj`> ezzieyguywuf: yea, exactly.
17:27:29 <ezzieyguywuf> but it ended up looking like `either (pure . Left . changeType) (pure . Right)
17:27:34 <ezzieyguywuf> which seemed non-ideal
17:27:54 <jle`> all of those are some form of die, right?
17:27:58 <jle`> so you can write a function like
17:28:11 <jle`> rightOrDie :: (e -> Stirng) -> Either e a -> IO a
17:28:29 <jle`> er, or maybe e -> IO a
17:28:51 <ezzieyguywuf> yea, here's how it looks right now https://dpaste.com/C29QTVVF7
17:29:01 <ezzieyguywuf> jle`: ah hah, this makes sense
17:29:01 <jle`> fData <- rightOrDie TextIO.putStrLn =<< getFileData
17:29:17 <ezzieyguywuf> lol, "rightOrDie" seems so agrressive
17:29:31 <jle`> vData <- rightOrDie displayException $ parse fData
17:29:56 <dmj`> ezzieyguywuf: you shouldn't do any IO until the very end imo. At that point you're just checking if you have the config, or die'ing. 
17:30:04 <jle`> hm, actually i just noticed that only one of your either's are in IO
17:30:11 <ezzieyguywuf> jle`: yea
17:30:15 <ezzieyguywuf> jle`: I noticed that earlier too
17:30:16 <jle`> so you really could just use normal Either do notation for everything after getFileData
17:30:22 <jle`> but it might be confusing to mix the two do's
17:30:23 <dmj`> ^ this
17:30:27 <ezzieyguywuf> right
17:30:34 <ezzieyguywuf> thus my conundrum - maybe just leave it as-is
17:30:41 <jle`> two do or not two do
17:31:04 <jle`> i think personally i would do something like rightOrDie, since we're just in the main subroutine anyway
17:31:07 <ezzieyguywuf> lol
17:33:11 <dmj`> ezzieyguywuf: which IOExceptions do you care about besides the file missing ? I'd just slap a doesFileExist before the T.readFile
17:34:44 <ezzieyguywuf> dmj`: I guess permissionerror too
17:35:01 <ezzieyguywuf> and someone said checking for file existence prior to opneing it was an anti-pattern or something
17:35:24 <dmj`> I wonder what their rationale was
17:35:33 <dmj`> Sounds made up to me
17:35:57 <dmj`> Checking the existence of a file before reading it does not sounds like a good practice :) 
17:36:07 <dmj`> does sound ** lol
17:37:33 <dsal> It depends on why you're checking.  Many people don't consider race conditions.
17:38:23 <dsal> e.g., I check for the existence of a file I intend to create to know that I don't need to do the work of downloading and building it in an application where there's no conflict.  But if you're doing that in, e.g., /tmp to avoid collisions, you're going to have a security problem.
17:44:14 <dsal> If you're using it as an IO guard to protect against an inability to read the file, you *still* might not be able to read the file, so it's not saved you any work.  It may have given you a better error message for one of the reasons you can't read the file, but it's preemptive diagnosis at that point.
17:45:13 <cads> wz1000, you sound skeptical. not a fan of code review?
17:45:58 <dsal> I would not have got code review from your question.
17:46:11 <wz1000> cads: I don't understand what kind of software you are looking for
17:46:14 <dsal> At work, we have a thing that does what's described and we have a thing that does code review.  They're only very loosely related.
17:46:50 <cads> dsal, two different and conceptually isolated systems? that's fascinating!
17:47:37 <dsal> You're talking about things that don't sound related.
17:47:49 <dsal> Perhaps back to wz1000's question.  What do you expect this software to do?
17:48:45 <dsal> github has semantic for what I think of as reading lots of source code:  https://github.com/github/semantic
17:48:51 <cads> dsal, how is code review not related to reading and understanding code?
17:49:07 <cads> or even to auditing it?
17:50:51 <cads> wz1000, I think of auditing as the process of reading a code base and verifying both through formal and qualitative means that it meets certain quality standards
17:51:55 <cads> and I think of code review as almost a microcosm of that process - the audit happens with smaller scope and less oversight and for different reasons, but essentially you still have a knowledge management scenario where a few different actors might be looking at the code
17:52:46 <cads> the system I'm thining of could for instance help split up the work of reading code, maybe assigning sections for people to read and check
17:53:33 <wz1000> OK, but how do you want to use software to do this? Anything from note-taking software and mind-mapping tools, to model checkers and theorem provers fit your criteria
17:53:54 <cads> perhaps it It could keep track of which sections of the code you've read, and help schedule a systematic reading of a large code base without losing your place
17:54:47 <cads> wz1000, and the reason I ask is to learn of methods I don't know about
17:56:12 <cads> dsal, you mentioned that you have one system at work that does "what's described" - does it help act as a task planning aid for systematic reading of code?
17:56:29 <cads> what was the system you had in mind, and how does that work?
17:56:33 <dmj`> cads: I found this pleasant for reading large code bases https://github.com/alexwl/haskell-code-explorer
17:57:47 <cads> dmj`, nice!
18:00:10 <dsal> cads: "code review" has a more common connotation than what you're describing.  I'd call the thing you're describing "Code perusal" or something.  Review is often change-oriented.
18:00:36 <cads> I know that
18:01:42 <dsal> So, we have one thing that is used for understanding code.  It's normally about "What is *this* thing and where is it defined and where is it used and what does it use?" and questions like that.  Github's semantic project seems like it's on the road to that type of system.
18:02:52 <dsal> We have another thing for "code review" which involves understanding the changes someone is trying to issue against the codebase.  Sometimes you end up having to dive into the codebase to see what the larger ramifications of a change are, but often it's just the change and enough context to make sense of it.
18:04:12 <cads> Sometimes I do a "code review" of historic commits - especially when I'm joining a project. I can really quickly get into the flow of what work in a given repo looks like, by reviewing - in this static sense
18:04:42 <cads> probably reviewing /w a pair coding partner would be much much faster, if they already know the code
18:06:03 <cads> and part of that is that tacit knowledge - you can ask them "what the fuck is this?! where is the even used?!"  and they say "oh, funny story about that... yeah it's a total kuldge, but it's used here, it's been in the code base for 6 months, it really saved our bacon, and we're too scared to refactor it
18:07:01 <cads> that kind of knowledge is VERY HARD to deduce while cold reading... even though a lot of it comes from very mundane observations of the code that could in theory be datamined
18:07:04 <dsal> Sure.  Our code review tool links to the other tool to give you that kind of context.
18:07:39 <cads> so if you are not sure about the context that a review is happening, within seconds you can be looking at libnrary docs and code samples?
18:07:51 <dsal> I've used opengrok in the past on similar things.  This might be a good jumping off point:  https://github.com/oracle/opengrok/wiki/Comparison-with-Similar-Tools
18:08:05 <cads> ah thanks!
18:08:27 <cads> I've recently found Zeal - it's not great, but for lirbaries that have docsets, it can be pretty nice
18:08:53 <cads> dsal, can you share the vendor with me?
18:09:01 <dsal> Which vendor?
18:09:54 <cads> of "code intel gatehering" tool you mention - don't tell me it' an in-house solution?!
18:10:07 <dsal> Yeah, it's all in house.
18:10:23 * cads doffs his cap to you and nods approvingly
18:10:29 <cads> but also I'm hearbroken, lol
18:10:55 <cads> ah well, I will follup up these leads
18:11:11 <dsal> Here's a talk from ~8 years ago describing an older version:  https://www.youtube.com/watch?v=KTJs-0EInW8
18:11:23 <cads> dsal, are you familiar with the zotero reference management system?
18:12:08 <dsal> No, I don't generally spend that much time in fancy stuff.  I write Haskell because my brain can't keep up with a lot of stuff and I want to keep things simple.
18:13:12 <cads> lol, my brain can't keep up with a lot of stuff and as a result I overengineer systems for effectively knowing things without actually knowing them
18:14:22 <cads> doesn't really work out that well though
18:22:19 <cads> dsal, regarding code explorer, it turns out that I have this docker file ready to install it! https://gist.github.com/maxsu/098e896fb820b577b52214633861f5bb
18:24:59 <cads> maerwald, I have pared down the dependencies to the absolute minimum, exploited ENV and ADD statements to separate the configuration from the code, and upgraded to the latest ubuntu and alpine images... once I have docker up and running here, I'll even test it!
18:25:25 <cads> so far I have tested a script-only version in windows alpine-WSL, and it works!
18:27:14 <cads> maerwald, I am also considering dropping the debian target from the build. I can build in Alpine, and then deploy to alpine, and even make alpine a very comfortable work environment. It's so much faster and responsive than ubuntu WSL that I don't want to go back
18:28:38 <cads> since I run infrastrucutre on alpine docker anyways, why not make alpine into my haskell workstation?
18:37:06 <dsal> That sounds like a really awful nixos.
18:37:45 <cads> I mean, 60 packages / 200mb worth of installation happens in about 10 second
18:39:15 <cads> also I am thinking that nixos would actually like to live on Alpine WSL
18:39:46 <cads> alpine being super light, with just one job: "get out of the way"
18:40:44 <cads> nix would probably love that, compared to, say, an ubuntu base. Maybe clearl linux would be even better?  But the clear linux WSL machine is still vaporware afaik
18:42:23 <dsal> I use a nixos base most of the time.
18:43:00 <cads> what is that based on?
18:43:08 <dsal> What do you mean?
18:43:53 <iqubic> Nixos is linux distro.
18:44:59 <cads> last I saw, I think nixos was still typically hosted on gentoo. And two year ago when I saw my friend playing around with it in a VM, they were working in an arch vm
18:45:30 <cads> so I guess didn't know it was a standalone distro now - probably has been for years
18:46:59 <iqubic> It has.
18:47:29 <dsal> New release last month.
18:49:55 <cads> have you followed intel's clear linux?
18:50:17 <dsal> I first heard of it a few seconds ago.
18:52:04 <cads> stateless/declarative/atomic deployments, plus it is incredibly fast, due to very agressive compiler flag optimization by the intel crew. In prhoronix's bencmarks it regaruly goes 10 or even 25% faster than other kernels
18:52:27 <cads> it's definitley inspired by nix
18:53:08 <iqubic> Nixos has a stable version with releases every 6 months, and an unstable version that's rolling release. I'm using the rolling release version, but I can easily switch.
18:53:35 <dsal> Yeah, why am I running a stable release?
18:53:57 <iqubic> I don't know. If you want to switch to the unstable channel, you can.
18:54:10 <cads> I don't know if clear has a stable release channel or if it's just rolling release 
18:54:48 <cads> haven't actually gotten to use, just read about it 
18:56:04 <cads> how well does nixos play /w containers and kubernetes? Is there any support available?
18:56:47 <iqubic> There's plenty of support.
18:56:53 <cads> we have nix expressions for that stuff
18:57:07 <iqubic> Yeah.
18:57:13 <dsal> Yeah, I think I'm running docker somewhere.  I just don't when I can avoid it.
18:57:27 <cads> iqubic, who offers nixos training ?
18:57:31 <iqubic> I'm sure there's a section of the nix manual that explains how to do that.
18:57:39 <iqubic> cads: I have no idea.
18:57:51 <cads> you said plenty of support
18:58:32 <iqubic> Ah. What I meant was "nixos has plenty of support for containers"
18:58:32 <dsal> This is #haskell
18:58:44 <dsal> (quick reminder since nobody's mentioned haskell in pages)
18:59:01 <iqubic> cads: If you want help, just ask in #nixos
18:59:11 <iqubic> dsal: Are you doing AoC this year?
18:59:24 <dsal> Oh man, it's about to start isn't it?  I certainly enjoy it.
19:01:12 <iqubic> It's starting in "7192.944941526s" If you understand how to read the string representation of a NominalDiffTime
19:01:23 <iqubic> That's a little under two hours
19:05:44 <ezzieyguywuf> here's where I ended up using rightOrdie. https://dpaste.com/D8TVSCMTK . I'm actually not sure if it's much better than the nested-case statements, due to the need for the type annotations on displayException
19:11:18 <jle`> ezzieyguywuf: hm, you didn't need to do it before?
19:11:22 <monochrom> If you turn on ScopedTypeVariables, then you can consider: rightOrDie (\(e :: ParseError) -> displayException e) (parse fData)
19:11:40 <ezzieyguywuf> jle`: for some reason, I don't think I did. actually maybe I did...
19:12:32 <ezzieyguywuf> yea didn't need it before
19:12:33 <ezzieyguywuf> weird
19:12:40 <jle`> or also rightOrDie (displayException @ParseError) (parse fData)
19:13:29 <ezzieyguywuf> I think I'll leave the nested case, but wrap them in a "getConfigInfoOrDie" function. that way, it's very clear when reading main what is going on
19:13:36 <iqubic> Is it just me, or is hoogle down?
19:13:53 <Melanie> it's down for me too!
19:13:53 <monochrom> jle`: No. Although I haven't read the code before, based on what's said informally here, the code before used handwritten inline pattern matching instead of rightOrDie, so there was an explicit "e" variable that you can easily attach ":: ParseError" to.
19:15:01 <jle`> it's a bit puzzling to me https://dpaste.com/C29QTVVF7
19:15:08 <ezzieyguywuf> monochrom: this is the code without rightOrDie https://dpaste.com/ERPKZS98H
19:15:46 <ezzieyguywuf> I can post the full code if you'd like to compile and check, but it's a few modules big
19:15:57 <monochrom> OK I can't explain that then.
20:38:23 <emmanuel_erc> So kind of a beginner question (but not beginner enough for haskell-beginners perhaps): How does Haskell's concurrency model compare to that of Javascript's?
20:38:46 <dolio> JavaScript doesn't have one?
20:40:10 <emmanuel_erc> I was in a meteing today and the opposing model smirked (dejectedly) at the suggestion that Haskell is well acclaimed for it's concurrency model and then went on to talk about how amazing Javascript's model.
20:40:11 <dolio> I guess Haskell doesn't really have one, either. GHC does.
20:40:19 <emmanuel_erc> dolio: Fair point.
20:42:20 <emmanuel_erc> dolio: But you can implement concurrent programs in Javascript though?
20:44:43 <dolio> There are many libraries in JS for doing some kind of concurrency. Probably one for every year or so, which completely revolutionizes the last one, which was thought to be the best thing ever.
20:46:27 <dolio> For a long time it was essentially that you write almost everything with callbacks, which is barely a 'model'. It's close to just writing your own scheduler.
20:46:56 <emmanuel_erc> bleh
20:47:16 <dolio> I think some stuff has finally gotten beyond that, but I'm not an expert.
20:52:31 <dolio> Is this the same guy who talks about how bad Haskell is at every opportunity without knowing anything about it? Or am I thinking of someone else?
20:58:26 <siraben> Why do JS people put up with manually writing CPS, heh
21:02:15 <dolio> Incidentally, one of the newer JS frameworks is react, as in reactive programming, as in functional reactive programming.
21:02:48 <dolio> At least, I think.
21:02:50 <cads> hey I want  to instrument some code so that I can run input/output tests on the code, and /derive/ from  that a set of mock interfaces complete with test data recorded from integration testing runtime
21:03:47 <cads> the idea is that the tests should be able to run about 10 to 100 times faster if we distill them to exercising the units indepdently against in-memory test case cashes
21:03:52 <cads> caches*
21:04:53 <emmanuel_erc> dolio: This is the same guy
21:05:00 <dolio> Hahaha.
21:05:01 <emmanuel_erc> I'm going to be leaving this job soon.
21:05:08 <emmanuel_erc> I can't stand his idiocy any longer.
21:06:23 <cads> it would be awesome to combine this approach with automated test case minimization
21:07:13 <cads> lol, in effect this is test case minimization for minimzing your tests from tests against a binary blob 
21:07:22 <cads> into unit tests ;)
21:08:56 <cads> but these unit tests also don't look like ordinary unit tests - they're just masses of empirically derived intermediary values that we pipe into our modules along mock interfaces
21:11:33 <emmanuel_erc> dolio: Why did you figure it was the same guy?
21:13:28 <dolio> Sounded familiar.
21:15:50 <emmanuel_erc> dolio: Fair enough
21:21:37 <emmanuel_erc> I do wonder how JS concurrency does measure to Haskell's. More specifically, are there any real, reliable benchmarks to compare, instead of dudes in their mid 30s puffing their chetsts.
21:30:38 <Tario> greetings
21:32:20 <iqubic> @define allPairs xs@(_ : tail) = [(x, pair) | x <- xs, pair <- tail]
21:32:23 <lambdabot>  Defined.
21:32:33 <iqubic> > allPair [1..5]
21:32:36 <lambdabot>  error:
21:32:36 <lambdabot>      • Variable not in scope: allPair :: [a0] -> t
21:32:36 <lambdabot>      • Perhaps you meant ‘allPairs’ (line 182)
21:32:42 <iqubic> > allPairs [1..5]
21:32:44 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,2),(3,3),(3,4),(3,5),(4,...
21:33:11 <iqubic> glguy: I think you'll find it doesn't have both (1,2) and (2,1) magically.
21:33:44 <glguy> > allPairs [1..2]
21:33:47 <lambdabot>  [(1,2),(2,2)]
21:34:30 <iqubic> Oh, weird. It has (2,2), but not (2,1)? How does this work?
21:36:39 <int-e> > [(x,y) | x:xs <- tails [1..3], y <- xs]
21:36:42 <lambdabot>  [(1,2),(1,3),(2,3)]
21:36:50 <iqubic> Yeah, that's good.
21:37:33 <int-e> it's a useful pattern
21:37:43 <int-e> though not the most efficient way to go about that problem
21:38:23 <iqubic> I'm talking about the first Advent Of Code problem.
21:38:44 <int-e> that's what I thought
21:38:55 <iqubic> [x*y | x:xs <- tails input, y <- xs, x+y == 2020]
21:39:08 <iqubic> Is that not the most efficient.
21:39:17 <glguy> no
21:39:22 <int-e> no, it's possible to do better
21:39:57 <iqubic> Oh? How?
21:44:23 <siraben> linear time solution
21:46:49 <int-e> though hmm, with only 200 input values it hardly matters
21:47:37 <siraben> true, don't overoptimize!
21:47:47 <mniip> siraben, linear? or pseudolinear (linlog)
21:49:32 <siraben> mniip: assuming O(1) element access, this is like the classic problem about finding all pairs that sum to a given value right?
21:50:47 <mniip> sounds like you're assuming an upper bound on number sizes
21:51:44 <mniip> anything where you use an input as an index into some array it's usually a good sign it's merely pseudopolynomial
22:06:13 <nitrix> I'm assuming that list comprehension gets gnarly as soon as you get to part #2, where you need a 3-tuple?
22:06:39 <iqubic> Not really.
22:07:03 <iqubic> If you want to know my solution to part 2, just let me know.
22:07:20 <int-e> nitrix: 1313400 triples are okay
22:07:23 <nitrix> Go ahead. I ended up choosing prolog for this year.
22:07:23 <iqubic> There's certainly a clean way of doing it.
22:07:29 <iqubic> [x*y*z | x:xs <- tails input, y:ys <- tails xs, z <- ys, x+y+z == 2020]
22:08:13 <iqubic> Oh, int-e and I had the same amount of numbers in our input.
22:09:07 <nitrix> So the tail of the tail. I guess the list monad combined with list comprehensions can be quite awesome. You get you depth-first search and back-tracking.
22:09:32 <dsal> I just went with `[x * y | x <- xs, y <- xs, x + y == 2020 ]` -- don't need all those fancy tails.  It's roughly instant anyway.
22:09:35 <nitrix> I had this in prolog:  solution(S) :- entry(A), entry(B), entry(C), A + B + C =:= 2020, S is A * B * C.
22:09:50 <dsal> I guess it's possible to get the wrong answer.
22:09:56 <nitrix> It's quadratic (?) but I didn't worry too much about it for now.
22:10:34 <nitrix> I was honestly more worried that they'd throw a wrench and have duplicate entries.
22:12:00 <dsal> Yeah, if the dumbest thing gets the answer in a reasonable amount of time, I check it in and then think about other things I might want to do.
22:12:44 <nitrix> Or, sorry, a number that added to itself would give 2020 (so 1010), to catch people doing the pairing naively instead of actually trying matching two entries together.
22:13:20 <int-e> nitrix: not on day 1
22:13:21 <int-e> :)
22:14:09 <dsal> It's not uncommon to get the wrong answer for your real input when you get the right answer for the test.
22:49:21 <aplainzetakind> Wasn't there a #haskell-aoc?
22:58:42 <Sose> I just went with `part2 l = head [ a*b*c | a <- l, b <- l, c <- l, a+b+c == 2020]` :D but yeah I guess it's possible to be more efficient
23:00:26 <Sose> also it makes me feel a little bad that it's possible on bad inputs that head will result in a runtime exception
23:02:00 <int-e> Sose: welcome to the wonderful world of throwaway code
23:13:31 <nshepperd2> i used 'head' but in retrospect it was probably better to just return the list itself so you would notice if it wasn't as expected (eg. more than one answer) so you could debug it instead of submitting something wrong
23:14:11 <nshepperd2> or possibly use `the :: Eq a => [a] -> a`
23:15:30 <koz_> The?
23:16:05 <iqubic> What is the?
23:16:34 <opqdonut> I assume `the xs = case nub xs of [x] -> x; _ -> error "not unique"`
23:16:48 <koz_> An appropriate phrasing would also be 'what the?'/
23:17:05 <nshepperd2> https://paste.zlkj.in/uploads/c1fe9333fe8d9a85/the.txt -- this is
23:18:41 <nshepperd2> oh, maybe it could be generalized for foldable
23:22:04 <iqubic> So, jle` found this bug in Data.Vec:         https://hackage.haskell.org/package/vec-0.3/docs/src/Data.Vec.Lazy.html#product
23:22:14 <iqubic> How did this pass the tests?
23:22:56 <int-e> fun!
23:23:02 <jle`> who tests the testers?
23:26:47 <int-e> iqubic: what tests?
23:27:37 <iqubic> I assume you could just use quickcheck to see if this is equivalent to the product function from base.
23:27:39 <int-e> (as far as I can see, there are a few tests in `vec`, but nothing comprehensive)
23:30:25 <int-e> despite the evidence I feel like bugs like this never happen ;-)
23:30:47 <int-e> (there's something quite unreal about this)
23:35:21 <jle`> Foldable instances seem to have a lot of room for bugs
23:35:51 <jle`> last major ecosystem bug i found was in containers actually in the toList instance of IntSet or IntMap
23:38:09 <jle`> s/instance/implementation
