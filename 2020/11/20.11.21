00:03:17 <jophish> Woo, got some vulkan ray tracing running!
00:03:37 <jophish> 60Hz of blue background!
01:20:10 <siraben> jophish: using what library?
02:01:54 <jophish> siraben: mine :D (vulkan)
02:10:29 <siraben> jophish: nice!
02:23:37 <jophish> siraben: thanks, next up actually tracing the rays against something other than the background :)
02:24:04 <jophish> although technically I'm not even generating any rays at the moment. but the blue is being generated by a shader in a ray tracing pipeline :)
02:29:27 <tomsmeding> 07:34:00         ski | ("is an Alternative" or "is Alternative" ?)
02:29:38 <tomsmeding> I have some more alternatives for you: "implements Alternative" and "is an instance of Alternative"
02:42:40 <Orbstheorem> When pantry finds a git extra-dep in stack.yaml, where does it clone it to? Does it keep a copy of the repo or just compiles the lib and deletes it afterwards?
02:53:49 * tomsmeding always uses his best friend `find` to find out where programs put things
03:17:53 <ziman> what's the recommended build system these days (preferably with a future perspective)? stack+hpack? cabal-install-v2?
03:19:16 * Lycurgus recommends ur own judgment
03:20:56 <Franciman> ziman, it depends, the thing is that probably cabal is good enough
03:21:33 <Franciman> so you wouldn't need the extra things stack gives to you (but also consider that sometimes you need some features not supported by stack, for example backpack)
03:22:05 <Franciman> for me the most attractive thing of stack is stackage, i.e. a curated set of packages which somebody^{TM} guarantees that work well toghether
03:22:07 <Franciman> together
03:22:22 <Franciman> but you should probably consider your own judgment 
03:22:44 <Franciman> as Lycurgus said
03:22:48 <xerox_> I like the stackage site to do hoogle searches, very clean
03:23:40 <Franciman> soon^{TM} vabal will support stackage files (which are essentially cabal freeze files) and you will use them without stack
03:24:40 <ziman> thank you :)
03:24:55 <Franciman> but since vabal is not really useful to anyone, I am considering first rewriting part of its logic in prolog
03:25:30 <ziman> i find it tricky to find sufficiently up-to-date information on the various build systems because the landscape keeps changing
03:25:41 <Franciman> I understand
03:25:58 <Franciman> my personal approach is: go with cabal until you find something incredibly wrong you can't fix
03:26:04 <Franciman> and this has never happened to me lately
03:26:13 <Franciman> especially after the v2-thing became the default behavior
03:26:30 <ziman> since i like "simple" things (as in fewest dependencies etc.), i'll go for cabal and see what happens
03:26:41 <Franciman> yes that's my base motive too
03:26:55 <ziman> assuming that cabal is the "simplest" choice here
03:27:56 <Franciman> for me it is true
03:28:33 <Franciman> anybody has their preferences, tho
03:33:35 <jophish> I use hpack+cabal
03:34:03 <jophish> listing modules manually is work for a computer, not a human
03:34:11 <jophish> but cabal works much better with nix
03:37:18 <ski> tomsmeding : hm, yea. i guess i didn't want to change it too much
03:37:55 <tomsmeding> ski: I wasn't entirely serious, I agree with your assessment :p
03:38:44 <srk> 7/81
03:38:52 * srk oop
03:38:53 <tomsmeding> > 7/81
03:38:56 <lambdabot>  8.641975308641975e-2
03:58:43 <maerwald> jophish: cabal-fmt can automatically add modules
04:17:23 <jophish> maerwald: TIL! thanks
04:17:33 <jophish> although I do also like how hpack uses yaml
04:19:23 <maerwald> yeah, cabal file format is weird
04:19:41 <maerwald> you can't change anything without reformatting the entire file
04:19:48 <jophish> I wonder how well a PR to cabal which adds yaml support would go down...
04:19:57 <jophish> well, I don't wonder lol. It would be panned
04:20:24 <jophish> but I'd like to see it happen, and then for the .cabal format to be phased out over the next infinity years
04:20:35 <maerwald> anything would be better than current format, but you have to support both forever and that's additional maintenance burden
04:20:44 <jophish> or, for cabal to be able to run hpack behind the scenes
04:20:51 <maerwald> that's never gonna happen :p
04:20:52 <jophish> I think stack can do this
04:21:12 <jophish> yeah, for sure the .cabal format will be preserved forever
04:21:16 <jophish> :(
04:21:22 * hackage beam-automigrate 0.1.0.1 - DB migration library for beam, targeting Postgres.  https://hackage.haskell.org/package/beam-automigrate-0.1.0.1 (abrar)
04:21:41 <jophish> but it could be frozen, and any new features solely added to the yaml/hpack interface
04:22:24 <jophish> maerwald: thanks for all the hard work you do for Haskell in nixpkgs BTW, it's appreciated!
04:22:44 <maerwald> I wasn't aware I'm contributing to nixpkgs
04:22:56 <jophish> oops!
04:23:14 <jophish> I've become confused with maralorn 
04:23:26 <maerwald> I gave up on nix 6 years ago, when I realized the community has no quality standards.
04:23:28 <jophish> too much decaf in my coffee
04:24:42 <maerwald> now I'm just glad when I'm not pestered with it at work :p
05:08:43 <maralorn> jophish: Funny, this is the second time someone confused our nix in few days.
05:08:44 <maralorn> jophish: And thank you!
05:37:45 <jophish> maralorn: I made a test for HLS (in vim, but doesn't have to be). It works quite reliably now I've worked the kinks out. Do you think that this would make a reasonable addition to the nixos tests in nixpkgs: https://github.com/expipiplus1/dotfiles/blob/f41836bb61d98502236a7ea6522dbc24830af439/tests/vim-diagnostic-list.nix
05:37:49 <jophish> it's quite niche
05:37:54 <jophish> but it would be good to get HLS tested there
05:52:01 <wygulmage> Question about Async: When would I want to use `cancel` rather than `uninterruptibleCancel`?
05:53:19 <merijn> "It Depends"
05:54:55 <wygulmage> I was trying to think of a use case for `cancel` and I couldn't think of one, but I'm not very good at thinking in terms of concurrency.
05:55:22 <merijn> wygulmage: Well, when waiting for succesful cancellation isn't important
05:55:57 <merijn> wygulmage: The cancellation always happens (since async exceptions are blocked during "throwTo")
05:56:25 <wygulmage> Doesn't `cancel` also wait?
05:57:16 <merijn> wygulmage: cancel waits without exceptions masked, so with cancel the final "waitCatch" (which confirms the termination of the cancelled thread) can itself be interrupted by a cancel of the thread
05:57:31 <merijn> Suppose thread A spawns async B, which spawn async C
05:57:36 <merijn> B cancels C
05:57:52 <merijn> "cancel" waits to receive the exception C got (via waitCatch)
05:57:52 * hackage heap-console 0.1.0.1 - interactively inspect Haskell values at runtime  https://hackage.haskell.org/package/heap-console-0.1.0.1 (TheMatten)
05:58:13 <merijn> wygulmage: The difference between cancel and uninterruptibleCancel is that the latter masks async exceptions during the wait
05:58:36 <merijn> so with uninterruptibleCancel, A can't cancel B while B waits for the final exception from C
05:58:52 <wygulmage> Oh, I see. That makes sense. So if you want to immediately kill the thread waiting for the other to cancel, you you plain `cancel`. Thanks!
05:58:54 <merijn> With cancel, A can cancel B while before it receives the final exception of C
05:59:39 <merijn> wygulmage: The reason for uninterruptibleCancel might be if you care about races with cancellation of C
05:59:55 <merijn> i.e. imagine I cancel C, but C gets killed by another exception before it receives the cancel
06:00:13 <merijn> If it's important that I check that final exception, then you need uninterruptibleCancel to guarantee you will see it
06:00:22 <merijn> If you just need C dead and don't care, cancel should be fine
06:03:01 <wygulmage> Thanks, merijn; that's much more straightforward than I expected.
06:05:32 <merijn> wygulmage: Basically, there's two levels of masking interrupts. "mask" which blocks async exceptions but unblocks them while blocking on (say) MVars, etc. (to help make it easier to avoid deadlocks)
06:05:56 <merijn> And then there's uninterruptibleMask which will blocks them, even when the code blocks on stuff like MVars
06:08:27 <wygulmage> Right. I got the use of 'uninterruptibleMask' for cleanup/finalizers, but I wasn't thinking of the return from the child thread in those terms.
06:14:18 <merijn> iirc, async just has an outer handler that writes any exceptions to a TVar/MVar that the parent thread can access
06:14:38 <Uniaika> I should use 'ki' one day
06:15:40 <Feuermagier> how can i check if number is contained at most once in a list?
06:17:05 <merijn> Turn it into a map with numbers as keys and counts as values?
06:17:11 <merijn> :t M.fromListWith
06:17:13 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
06:17:54 <merijn> > M.fromListWith (+) . map (,1) $ "Hello World!"
06:17:56 <lambdabot>  fromList [(' ',1),('!',1),('H',1),('W',1),('d',1),('e',1),('l',3),('o',2),('...
06:18:01 <Feuermagier> merijn, intersting idea! - that should even allow me to check multiple numbers for occurance without additional cost
06:18:01 <fendor_> > ((< 2) . length . filter (== 1)) [1,2,3,4,1]
06:18:03 <lambdabot>  False
06:18:26 <fendor_> > (\x -> (< 2) . length . filter (== x)) [1,2,3,4,1] 4
06:18:28 <lambdabot>  error:
06:18:28 <lambdabot>      • No instance for (Num [[Integer]]) arising from the literal ‘4’
06:18:28 <lambdabot>      • In the second argument of ‘\ x
06:18:40 <fendor_> > (\x -> (< 2) . length . filter (== x)) 4 [1,2,3,4,1]
06:18:42 <lambdabot>  True
06:18:45 <merijn> fendor_: Mine is more robust and cheaper for repeated queries ;)
06:18:51 <fendor_> absolutely
06:19:15 <merijn> It could've been even easier if we didn't have a bad Monoid instance for Map >.<
06:19:25 * merijn hisses at containers
06:19:52 <merijn> No clue which monkey decided on that nonsense
06:20:13 <merijn> But I have no hopes if it ever getting fixed :\
06:22:11 <Feuermagier> where in my dependencies do i have to add map to use it? (the import says "could not load map; is member f hidden package")
06:23:03 <merijn> Feuermagier: Add "containers" to build-depends in your cabal file
06:25:41 <Feuermagier> tgrl wsgi•   build-depends:
06:25:41 <Feuermagier>     base == 4.*
06:25:42 <Feuermagier>     containers
06:25:58 <Feuermagier> like this?   build-depends:
06:25:58 <Feuermagier>     base == 4.*
06:25:58 <Feuermagier>     containers:
06:26:11 <merijn> you need a comma between them, iirc
06:32:20 <Feuermagier> ah, that was it
06:32:21 <Feuermagier> thx
06:37:39 <Feuermagier> merijn, how would I check every entry in the map for my "only once" condition?
06:38:14 <merijn> Feuermagier: Pretty sure there are some index maps/folds
06:38:22 <merijn> and also filters?
06:38:27 <Feuermagier> rgr. will take a look at those
06:38:39 <merijn> Feuermagier: Just filter out everything with value 1 and check if the result is empty
06:41:18 <zyklotomic> is there any reason why ghc doesn't automatically derive functor and applicative
06:41:18 <aldessa> are there any haskell libraries for dynamic programming or integer programming that can be recommended? i'm trying to pack n cuboids and think i can formulate it as an integer programming problem
06:41:40 <zyklotomic> *if you define monad
06:42:07 <Uniaika> hmm
06:42:20 <Uniaika> maybe we could put a rule for Monad
06:42:26 <maralorn> jophish: Well, more tests are better tests! Of course the first step would be to get the hls unit tests working in nixpkgs, (as well as dependencies like ghcide, etc,.) I am nearly there for hls but there are two tests which run into timeouts so I disabled them for now.
06:42:42 <Uniaika> zyklotomic: historically, Applicative was not so tightly linked to Monad
06:42:47 <Uniaika> now it is the case
06:42:51 <Uniaika> this could indeed change
06:42:53 <zyklotomic> yeah, I am following the historical aspect of it
06:43:05 <zyklotomic> is it a matter of not having gotten to it yet?
06:43:15 <zyklotomic> or is there a reason why we might not want it to behave that way
06:43:19 <Uniaika> zyklotomic: can you open a ticket on https://gitlab.haskell.org/ghc/ghc/-/issues/new ?
06:43:54 <zyklotomic> I'm just a beginner, I'm not very confident on how valid this opinion is though lol
06:44:34 <geekosaur> deriving applicative might be because some types have more than one valid applicative (see ZipList)
06:44:44 <merijn> zyklotomic: You can't automatically derive Applicative
06:45:08 <merijn> Functors are possible because lawful functors are unique
06:45:36 <zyklotomic> I understand that they might not be unique, but what if you just wanted to use the Monad definition
06:45:40 <merijn> Uniaika: What would that ticket be for?
06:45:47 <merijn> zyklotomic: You can
06:46:13 <zyklotomic> It is just a minor question, I was wondering why it wasn't the default to be able to do something like filling that boiler plate in fro you
06:46:13 <merijn> If you implement Monad you can just define Applicative as "<*> = ap"
06:46:22 <zyklotomic> the "pure = return", "(<*>) = ap"
06:46:28 <Uniaika> merijn: become a URL we can link to people where GHC developers explain why we can or cannot automagically derive Applicative and Functor when one only derives Monad
06:46:41 <merijn> zyklotomic: Because it'd 1) break things and 2) return is planned to be removed from the class
06:47:05 <merijn> Uniaika: You can derive functor even without Monad :p
06:47:11 <merijn> Just enable -XDeriveFunctor
06:47:19 <maralorn> jophish: I am not very experienced with nixos tests, but the test you suggested seems a bit brittle. It looks like it would fail if e.g. the error message was improved or something in the plugin layouts.
06:47:34 <Uniaika> merijn: but can you derive Monad without Functor? :P
06:47:43 <jophish> yeah, I certainly wouldn't want to use it as it is!
06:47:48 <Uniaika> that's what I was talking about
06:47:50 <sondr3_> I'm writing a parser in Haskell to practice and want to test private parts of the code, in Rust this is easy by either testing in the same file as the code, or declaring things to be pub(crate). How can I do something like this in Haskell?
06:47:51 <zyklotomic> yeah my question isnt' the automagically part
06:48:06 <jophish> tbh, posting the link to my specific test was irrelevant,
06:48:24 <zyklotomic> but like why it can't fill in the "(<*>) = ap" for you by default, how would it break things merijn 
06:48:26 <merijn> sondr3_: Are you using cabal-install or stack?
06:48:38 <sondr3_> merijn: cabal
06:48:51 <zyklotomic> i'm asking cause i dont see where, not that i disagree
06:48:52 <merijn> sondr3_: Ok, then you can't quite do the same, but there's some tricks
06:49:08 <merijn> sondr3_: So, in recent versions of the cabal spec you can define multiple internal libraries
06:49:22 <sondr3_> I'm open to move to Stack tbh, I've had a bunch of annoyances with cabal
06:49:25 <merijn> sondr3_: So you could define the core logic in an internal library that exports all internals
06:49:51 <merijn> sondr3_: then your public library can re-export the "public" parts of the internal lib and your tests can depend on the internal version
06:50:09 <sondr3_> merijn: Ooh, that's clever, thanks
06:50:58 <merijn> sondr3_: I'm just not sure how well/if stack supports that, hence the question :)
06:51:27 <merijn> sondr3_: https://cabal.readthedocs.io/en/latest/cabal-package.html#sublibs
06:51:48 <sondr3_> merijn: Ah, fair. Thanks for the pointer, I'll give it a go
06:51:58 <yushyin> are multiple *internal* libraries that recent?
06:52:12 <yushyin> oh 2.0
06:53:34 <merijn> yushyin: No, but stack is...opinionated on what part of Cabal they wish to support
06:53:43 <merijn> sondr3_: btw, I'm curious which annoyances you had with cabal-install?
06:54:56 <Uniaika> merijn: I think you can insert verbatim stuff in package.yaml?
06:55:23 <merijn> package.yaml /= stack
06:55:26 <sondr3_> merijn: Mostly getting cabal repl to properly use my project local .ghci file, I want to set OverloadedStrings and load a module
06:55:48 <merijn> sondr3_: Oh, I just have those extensions set in my global .ghci file :)
06:55:50 <yushyin> merijn: yes :/ I switched back from stack to cabal because of similar reasons
06:56:16 <merijn> package.yaml is hpack and hpack is a huge mistake, imo
06:56:32 <sondr3_> merijn: Yeah I'm considering doing the same, it'd just be nice to have it work locally
06:56:55 <Uniaika> merijn: my bad indeed
06:57:38 <merijn> Uniaika: stack automatically uses hpack if needed, leading many people to consider it part of stack, but even Snoyman now recommends against relying on only package.yaml and recommends committing the generated .cabal file
06:58:33 <Uniaika> merijn: oh yeah we do it at work now
06:58:51 <Uniaika> latest stack versions give you a warning
07:00:08 <merijn> Like, I get why people like hpack, because they get to be lazy. But there's a reason why cabal-install doesn't allow you to be lazy. Being lazy turns your package management, distribution, and archiving into a huge unfixable clusterfuck
07:00:16 <merijn> This is why pip and npm are such insane messes
07:00:41 <zyklotomic> huh what makes npm and pip bad
07:01:37 <merijn> zyklotomic: Have you ever worked on code locally and tried to reproduce that environment on another machine?
07:02:00 <merijn> It's so bad everyone now just uses dockers, because it's easier to just copy your entire machine then figuring out how to package/distribute things
07:02:02 <zyklotomic> yeah, nix
07:02:41 <zyklotomic> i was on that boat too until nixOS
07:02:46 <zyklotomic> or is that a different issue
07:02:57 <zyklotomic> have you heard of nix?
07:02:59 <merijn> zyklotomic: Right, but the reason Nix works is the same thing cabal insists on
07:03:01 <et09> i need to fully wipe my stack installation i think
07:03:09 <merijn> zyklotomic: "rigidly specify exactly everything you depend on"
07:03:21 <zyklotomic> wait pip doesn't?
07:03:29 <merijn> zyklotomic: Which is the exact thing people complain about
07:03:33 <et09> getting these errors like uh, ghc failed a sanity check, cannot find snapshot
07:03:37 <zyklotomic> that's kinda shocking, I never realized
07:03:43 <merijn> et09: eh...that's bad :D
07:03:46 <et09> but deleting .stack, .ghc, /usr/local/bin/stack doesn't seem like enough 
07:04:30 <Uniaika> peculiar
07:04:32 <et09> my core problem is that i'm trying to install a recompile-able xmonad + xmobar + xmonad-contrib + xmonad-utils 
07:04:38 <Uniaika> HAHAHA
07:04:41 <Uniaika> :D
07:04:49 <merijn> zyklotomic: If you manually install something into your virtualenv (another massive hack!), pip will happily let you use it without you adding it to requirements.txt
07:05:02 <et09> i.e. xmonad --recompile
07:05:52 <zyklotomic> merijn: i've kinda forgotten it works that way
07:06:49 <zyklotomic> like manually installing, declaratively installing gives such a peace of mind
07:07:21 <merijn> v2-build is lightyears ahead of pip/virtualenv/npm :)
07:08:09 <zyklotomic> i *think* cargo also uses this saner behavior
07:08:42 <sondr3_> Cargo is really nice, my absolute favorite package manager
07:09:08 <zyklotomic> i like rustc more than i like cargo, not that it is bad
07:09:16 <zyklotomic> the enumerated warnings are really user friendly
07:10:40 <sondr3_> My favorite part of using Rust is that with rustup I get a package manager, formatter, linter and auto-updating all in one
07:11:20 <zyklotomic> rustup is really nice, even with nixos, i still prefer rustup
07:11:42 <merijn> boo to autoformatters
07:12:08 <zyklotomic> my first experience with autoformatters was Go
07:12:11 <zyklotomic> and I thought I was crazy
07:12:17 <yushyin> with ghcup we ahve a similar toolchain installer
07:12:18 <zyklotomic> or going bonkers 
07:12:27 <sondr3_> Yay to autoformatters, now I don't have to think about formatting and the whole ecosystem feels much more cohesive 
07:12:35 <merijn> My argument against autoformatters: https://twitter.com/comerijn/status/1257804634833420292
07:13:14 <merijn> "not thinking about formatting" is just as bad as "not thinking about naming"
07:13:15 <zyklotomic> that's valid, though i'll give Go a free pass
07:13:39 <merijn> It's on brand for Go
07:13:50 <sondr3_> I see both sides, I personally don't care, I like not having to think about it
07:14:00 <hpc> my first experience with autoformatters was java, where to be fair, i wasn't thinking about naming either :P
07:14:02 <Feuermagier> how do I zipWith, but only with one of the arguments changeing?
07:14:04 <zyklotomic> yeah, like I can say Go is the only language it would seem to make sense for 
07:14:06 <merijn> Which is "solve every problem by making the exact opposite of the right choice" :p
07:14:16 <sondr3_> Especially when contributing to other peoples packages
07:14:20 <merijn> Go got 2 things right
07:14:22 <maerwald> merijn: it's twice as bad if you're one of those people who memorize code based on the structure and someone else decides to run an autoformatter over it
07:14:27 <merijn> 1) cross-compilation support from day 1
07:14:32 <merijn> 2) lightweight threading
07:14:53 <merijn> Possibly 3? I think they default link static too?
07:15:01 <maerwald> I think more important than reading code is... navigating code :)
07:15:10 <maerwald> (because most stuff you don't actually wanna read)
07:15:11 <merijn> that too
07:15:24 <hpc> 2 is kind of iffy as well, doesn't their lightweight threading not give you very much control over the threads themselves?
07:16:00 <merijn> hpc: Well, at least even *they* designers of "the most backwards language since the 80s" realised that OS threading as default was dumb
07:16:06 <merijn> Gotta give them credit for that :p
07:16:15 <zyklotomic> Feuermagier: what do you mean
07:16:20 <hpc> yeah true
07:16:21 <zyklotomic> could you give an ex
07:16:31 <yushyin> zyklotomic: sondr3_: hls uses ormolu, so there you go.
07:16:50 <sondr3_> I use ormolu too, 
07:16:51 <Feuermagier> zyklotomic, compine x with every argument out of [list] by function f - cycle through the list, keep x
07:17:36 <sondr3_> It's my absolute least favorite formatter, Britanny looks better but I get the feeling that it has some deep architectural problems
07:18:15 <merijn> Feuermagier: Can you give an example of an input and output
07:19:02 <yushyin> sondr3_: just don't think/care about it :P you said it yourself
07:19:51 <Feuermagier> merijn, x=3, [0,1,2] function = "*" result=[0,3,6]
07:20:25 <merijn> You don't need zipWith, just map :p
07:20:26 <sondr3_> yushyin: Haha, I know, at least I mostly agree with rustfmt, I just don't like how ormolu puts the comma at the end of lines and not the beginning :(
07:20:35 <Feuermagier> merijn, essentially zipWith, but with one argument just being [x,x,x,x,x...]
07:20:48 <merijn> > map (3*) [0,1,2]
07:20:50 <lambdabot>  [0,3,6]
07:20:52 <Feuermagier> *oh*
07:21:08 <Feuermagier> THX!
07:21:09 <zyklotomic> wait you can do that?
07:21:18 <zyklotomic> i've been doing (*3) the entire time
07:21:22 <zyklotomic> oh right
07:21:27 <merijn> zyklotomic: you can do both
07:21:34 <zyklotomic> yeah it never occured to me
07:21:40 <merijn> It matters, actually
07:21:51 <merijn> > map (/2) [1..10]
07:21:53 <lambdabot>  [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
07:21:58 <merijn> > map (2/) [1..10]
07:22:00 <lambdabot>  [2.0,1.0,0.6666666666666666,0.5,0.4,0.3333333333333333,0.2857142857142857,0....
07:22:05 <zyklotomic> oh or the ugly
07:22:10 <zyklotomic> > map ((/) 2) [1..10]
07:22:11 <lambdabot>  [2.0,1.0,0.6666666666666666,0.5,0.4,0.3333333333333333,0.2857142857142857,0....
07:22:19 <zyklotomic> lol
07:22:25 <zyklotomic> but (*) is ass 
07:22:36 <zyklotomic> *comm 
07:23:08 <sondr3_> be nice to (*)
07:28:42 <Feuermagier> how do I elegantly check if an entire list of bools is true if I "and" it?
07:29:14 <merijn> :t and
07:29:15 <lambdabot> Foldable t => t Bool -> Bool
07:29:31 <ski> Feuermagier : did the list come from `map' ?
07:29:35 <merijn> :t getAll . foldMap All
07:29:36 <lambdabot> Foldable t => t Bool -> Bool
07:30:47 <ski> @type all
07:30:48 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:31:12 <sondr3_> How do I combine parsers in Megaparsec? I have `char '<' *> takeWhile1P Nothing (== '=') <* char '>'` which discards the chars, and I can't figure out how to combine them
07:31:23 <Feuermagier> ski, yes. I have 3 seperate lists generated by 3 seperate functions
07:31:31 <dminuoso> all p = getAll #. foldMap (All #. p)
07:31:35 <ski> @src all
07:31:35 <lambdabot> all p = and . map p
07:31:37 <ski> @src any
07:31:37 <lambdabot> any p = or . map p
07:31:44 <dminuoso> Curious that this uses foldMap
07:32:04 <ski> Feuermagier : if you have `and (map p xs)', you can say `all p xs'
07:32:04 <dminuoso> sondr3_: In what way do you want to combine then?
07:32:13 <ski> > liftA2 (^) [0,1,2,3] [0,1,2,3]
07:32:14 <lambdabot>  [1,0,0,0,1,1,1,1,1,2,4,8,1,3,9,27]
07:32:15 <merijn> dminuoso: "getAll (coerce fold)" :p
07:32:20 <merijn> eh
07:32:23 <merijn> add a . there
07:32:31 <sondr3_> dminuoso: so the output becomes "<===>", now it is just "==="
07:32:35 <ski> > [m ^ n | m <- [0,1,2,3],n <- [0,1,2,3]]
07:32:38 <lambdabot>  [1,0,0,0,1,1,1,1,1,2,4,8,1,3,9,27]
07:32:40 <dminuoso> ski: The "output"?
07:32:42 <dminuoso> Err sondr3_.
07:32:47 <zyklotomic> won't a regular fold work?
07:32:49 <ski> > [[m ^ n | n <- [0,1,2,3]] | m <- [0,1,2,3]]
07:32:52 <lambdabot>  [[1,0,0,0],[1,1,1,1],[1,2,4,8],[1,3,9,27]]
07:32:58 <merijn> :t fold
07:33:00 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:33:03 <merijn> :t foldMap
07:33:04 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:33:19 <merijn> zyklotomic: You can do it with a regular fold, sure. But monoids are cool
07:33:29 <ski> > let pam = flip map in [0,1,2,3] `pam` \m -> [0,1,2,3] `pam` \n -> m ^ n
07:33:32 <lambdabot>  [[1,0,0,0],[1,1,1,1],[1,2,4,8],[1,3,9,27]]
07:33:41 <merijn> zyklotomic: Also, monoids compose better
07:33:42 <dminuoso> sondr3_: Also, your `takeWhile1P Nothing (== '=')` should just be `some (char '=')`
07:33:47 <sondr3_> dminuoso: I meant what it returns x) the signature is `parser :: Parser Text`
07:34:11 <dminuoso> sondr3_: Ah. So the most naive way is to use the monadic interface.
07:34:21 <dminuoso> But that's not necessary
07:35:21 <sondr3_> I've never done parser combinators before, so the code is surely weird :P
07:35:35 <dminuoso> sondr3_: https://gist.github.com/dminuoso/6fcd4ffac6afc5a7a4ec9f39052dd986
07:35:44 <dminuoso> Note that its usually awkward to return exactly what you parsed.
07:36:27 <Feuermagier> ski, thx! - that works for me
07:36:34 <dminuoso> I want to emphasize that you dont have to use the do/monadic interface here, you can do this with applicative too, but this is probably more readable
07:37:03 <dminuoso> Oh, actually that code is off..
07:37:15 <sondr3_> dminuoso: I'm all ears for suggestions and tips
07:37:30 <dminuoso> takeWhile1P is right after all
07:37:42 <zyklotomic> oh foldMap is essentialy Writer?
07:37:55 <ski> Feuermagier : it sounded like perhaps, by "how do I zipWith, but only with one of the arguments changeing?","compine x with every argument out of [list] by function f - cycle through the list, keep x", you also had in mind possibly choosing `x' in each possible way, from a list. (hence the above lambdabot queries)
07:38:10 <dminuoso> sondr3_: reload my gist
07:38:41 <dminuoso> sondr3_: So I dont know what you're doing exactly, why do you need the parser to return the exact string it just parsed?
07:39:25 <et09> ugh i don't get this
07:39:40 <et09> xmonad --recompile, stack exec xmonad -- --recompile show it can't find XMonad, Xmonad.Util, etc.
07:39:51 <sondr3_> dminuoso: I'm learning parsing?Haskell by parsing a format called HRX, and it requires "boundaries" (the <===>) to be the same width in the same document
07:39:52 <et09> even after i just installed all of them with stack install 
07:40:14 <dminuoso> sondr3_: I see! :)
07:42:48 <dminuoso> sondr3_: Perhaps you could write two combinators, firstBoundary :: Parser Int; and boundary :: Int -> Parser ()
07:43:19 <dminuoso> Alternatively, you could bury the boundary length inside the state of your parser
07:43:44 <dminuoso> say some `Maybe Int` that starts at Nothing, and `boundary :: Parser ()` then, if its Nothing, would determine the length, and if its `Just n` demand exactly n equals.
07:44:31 <sondr3_> Yeah, I've been thinking about doing that, seems to be the easiest way in my head
08:02:07 <idnar> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
08:02:08 <lambdabot> Data.Tuple.Extra uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
08:02:08 <lambdabot> Extra uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
08:02:09 <lambdabot> Data.Tuple.HT uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
08:20:48 <sondr3_> dminuoso: when using State in megaparsec do I need the `mtl` package? I can't figure out how to modify state with the examples
08:28:43 <sm[m]> et09: you need to ask #xmonad, but I'm guessing xmonad --recompile is special/not smart enough to detect the environment provided by stack exec
08:31:58 <et09> i got it working after following these steps - https://brianbuccola.com/how-to-install-xmonad-and-xmobar-via-stack/
08:34:21 <sm[m]> et09: nice, that should be made prominent for xmonad users
08:38:51 <et09> man 15gb hard drive on this and 11gb already used after install, 4gb for stack 
08:41:46 <et09> and i think the hd is soldered into the motherboard lol.  doomed 
08:41:49 <sm[m]> maybe there's a ghc version/old-ghc libs in there you can delete ? ncdu is good
08:42:07 <et09> ncdu?
08:42:27 <sm[m]> yup, great tool
08:42:32 <et09> oo nice
08:42:37 <et09> i have cli scripts that do similar 
08:42:50 <et09> well it's 2.2gb /programs, 1.3gb /pantry, 442mb /snapshots
08:43:06 <et09> only one ghc version i think ...
08:43:13 <sm[m]> rats
08:43:30 <et09> no matter 
08:43:36 <et09> this is a random toy project anyway 
08:43:51 <MarcelineVQ> sounds about right: ghc, hackage index, libraries
08:43:54 <et09> ill dig up like a 32/64gb ssd if i wanna throw snes games on here or something
08:44:03 <sm[m]> what kind of machine has a 15G drive ?
08:44:14 <et09> you don't want to know 
08:44:42 <et09> hp chromebook 11 g5, ~2015 
08:45:31 <MarcelineVQ> You could probably compile on a larger computer and move the executable +​ settings to your smaller storage device
08:46:33 <MarcelineVQ> dunno how reasonable that is for xmonad in terms of seeing the effects of particular changes
08:51:05 <sm[m]> "suboptimal" I think we could say 
08:52:12 <merijn> stack generally installs multiple GHC's, so that quickly racks up space
08:53:29 <maerwald> merijn: if it had a way to garbage collect, but...
08:53:43 <sm[m]> et09 checked, and only has the one
09:18:50 <et09> if it were that serious i'd just use a c tiling window manager hah 
09:19:15 <et09> i just got this chromebook for free like 5 years ago and had to do a hardware mod (removing a screw -_-)  to install linux on it
09:19:23 <et09> and never got around to it until this week 
09:19:49 <maerwald> just use i3 then
09:24:43 <zyklotomic> huh? why do you have to roll your own xmonad
09:24:56 <zyklotomic> i've been ok enough with the ones in my distro's repos
09:25:35 <maerwald> the entire point of xmonad is "code as configuration", no?
09:25:46 <zyklotomic> and if I really needed to, i would feel comfortable enough directly changing the package manager build-file, not sure about your use case though
09:26:03 <zyklotomic> maerwald: yeah, but it can still read my xmonad.hs file in my home dir
09:26:46 <zyklotomic> i'm not sure about its inner workings, but it has always been able to read my ~/xmonad/xmonad.hs file
09:28:02 <zyklotomic> so i don't think it's as intense/hard core as some other WM's where you have to modify the actual source code
09:58:14 <dminuoso> sondr3_: It's easiest with mtl.
09:58:54 <sondr3_> dminuoso: Yeah, managed to get it to work with it :)
09:59:02 <dminuoso> Great! :)
10:25:47 <merijn> maerwald: Not really
10:26:19 <merijn> maerwald: The point of xmonad is more like "we made a DSL/library for writing custom window managers and are suckering people into writing Haskell window managers by telling them its configuration"
10:27:35 <zyklotomic> thats a pretty hilarious take
10:27:52 <merijn> zyklotomic: It's true, though :)
10:31:51 <zyklotomic> I will admit that is what exposed me to Haskell
10:32:04 <zyklotomic> so inadvertently or not (idk tbh), Xmonad did its purpose
10:32:25 <zyklotomic> it definitely is good publicity for the language
10:32:28 <monochrom> My view is they were too lazy to design and implement a proper config format.
10:32:39 <zyklotomic> ...and called it a feature
10:32:41 <merijn> monochrom: Compromise: It was both
10:32:58 <merijn> monochrom: Can you blame them? Dhall hadn't been invented yet!
10:33:15 <monochrom> They could have invented dhall or better.
10:33:45 <geekosaur> the problem with monochrom's view is that spencer was a dwm user and explicitly cloned dwm
10:33:55 <dsal> et09: I have a chromebook pixel I pulled the screw out of.  It runs nixos+xmonad now.
10:33:58 <geekosaur> "because haskell was better at doing edsls"
10:34:03 <merijn> geekosaur: That's the suckless one?
10:34:10 <geekosaur> yeh
10:34:37 <zyklotomic> i guess theres dozens of us! dsal 
10:34:38 <merijn> I wonder if they're still around, or if they've given up in the onslaught of terrible software :p
10:34:56 <geekosaur> dunno
10:35:23 <geekosaur> they've not exactly lived up to their name at times, thoguh; they've had some pretty terrible bugs
10:36:04 <merijn> To be fair, the main motivation/ideology wasn't "less buggy"
10:36:23 <merijn> It was simpler, clearer, and less resource intensive
10:36:49 <zyklotomic> and have it "suck less"
10:36:53 <monochrom> All three were destroyed by migrating to Haskell and GHC.
10:37:00 <merijn> monochrom: ;)
10:37:25 <merijn> monochrom: And yet Haskell still sucks less than C :p
10:37:36 <merijn> Hell, Haskell is a better C than C :p
10:46:48 <tomsmeding> I'm happily using suckless' st terminal
10:46:58 <tomsmeding> one datapoint :p
10:47:06 <merijn> There's no way to make terminals suck less :p
10:47:20 <tomsmeding> ¯\_(ツ)_/¯
10:47:59 <tomsmeding> would be interesting to meet a person that actually uses ii
10:48:18 <merijn> tomsmeding: Out of morbid curiosity? :p
10:48:23 <tomsmeding> yes :p
10:49:02 <merijn> tomsmeding: There's two kinds of people. People who like terminals, and people who've read the APUE chapter on terminals and know how they work and what kinda weird abomination they are >.>
10:49:37 * tomsmeding doesn't know what APUE is, but I know how ansi escape sequences work, does that count?
10:50:07 <merijn> tomsmeding: Advanced Programming in the UNIX Environment
10:50:23 <merijn> The bible for anyone who wants any hope of writing remotely robust portable posix code :)
10:51:48 <dolio> Seems to me the problem is that people generally want to replace terminals with something worse, rather than better.
10:52:38 <merijn> dolio: Doesn't that hold for basically every technology? :p
10:53:13 <dolio> Probably.
10:53:14 <merijn> dolio: See TypeInType ;)
10:59:25 <qqqqqq> 6Lets praise Allah; 3he is our God, thee one; he is the god of Moses; Noah; Jesus & Mohammed; he sent us our Book 7 Quran, 10Monotheism is cleared by all prophets ~ 6 We get heaven & happiness on earth by praying to the one god 6& by Saying No God except Allah & that Mohammed is the messenger of Allah. 4 treat others as u like to be treated 10---------;{@
11:00:17 <Uniaika> *sigh*
11:00:56 <tomsmeding> well it is nice and colourful
11:01:08 <[exa]> the last part actually made some sense
11:01:16 <tomsmeding> except for the ;{@
11:01:19 <[exa]> I give 3 stars out of 5 and ban
11:01:25 <merijn> [exa]: Agreed, we should bring back ascii roses
11:01:27 <Uniaika> nah the rose was decent, [exa] 
11:01:31 <Uniaika> I've seen worse
11:01:33 <[exa]> lol
11:01:34 <tomsmeding> oh that's a rose?
11:01:37 <Uniaika> yeah
11:01:44 * tomsmeding is too young for this shit
11:01:51 <Uniaika> lol, how old are you? tomsmeding 
11:01:53 <merijn> tomsmeding: Usually in MUDs they'd use that for flowers/roses
11:01:55 <hpc> all i saw was an unmatched squiggly brace
11:02:05 <merijn> Man...I miss MUDs...
11:02:06 <dolio> Missed an opportunity to color the rose correctly.
11:02:14 <tomsmeding> lol I'm 22 Uniaika 
11:02:25 <Uniaika> tomsmeding: :D
11:02:26 <Uniaika> nice
11:02:28 <merijn> they were like MMOs, but before the massive exploitation of the modern games industry
11:02:28 <Uniaika> some young blood
11:02:30 <tomsmeding> I didn't have IRC in my life until recently
11:02:33 <hpc> but it's in a comment so i guess that's fine :P
11:02:36 <[exa]> merijn: let's waste a month playing ishar?
11:02:48 <Uniaika> tomsmeding: I'm 25 myself
11:03:14 <merijn> [exa]: I don't know ishar. I mostly played Aardwolf which was a *heavily* (to the point of unrecognisability) modified ROM 2.4
11:03:36 <[exa]> tomsmeding: Uniaika: worry not, I'm 33 and I have no idea whether there's any correlation between age and knowledge of MUDs :D
11:03:38 <merijn> It's still up (or was a year ago), but I got kicked out of the clan :(
11:03:49 <[exa]> o noes
11:03:50 <Uniaika> [exa]: :D
11:04:01 <merijn> [exa]: I'm 34, so that's about the tail end of the MUD era in terms of age :p
11:04:53 * hackage candid 0.1 - Candid integration  https://hackage.haskell.org/package/candid-0.1 (JoachimBreitner)
11:07:35 <[exa]> merijn: like, my mud carreer peaked at like 16--18
11:07:55 <merijn> Mine probably right before WoW :p
11:08:00 <merijn> From one drug to another ;)
11:08:01 <[exa]> lol
11:08:11 <[exa]> that may correspond well, yes
11:30:47 <Feuermagier> %C08,13 how does one actually write in color here?
11:33:54 <hpc> depends on the client
11:34:02 <geekosaur> that %C thing is specific to xchat and only if color is enabled (check its settings). at  low level it's control-C,and up to the client to specify how to get that (the webchat I'm using doesn't seem to support it at all)
11:34:18 <Feuermagier> hexchat here
11:35:47 <geekosaur> then you needto enable the color escapes. I don't recall where that is in the settings
11:36:16 <geekosaur> (I usually edit the settings files directly while it's not running, there are a lot of settings it doesn't expose in the ui)
11:37:03 <Feuermagier> IRC really has everything one could need
11:41:36 <[exa]> Feuermagier: pls don't color
11:42:08 <Feuermagier> [exa], why?
11:42:42 <[exa]> one shall typeset with a single ink, even IRC
11:46:40 * Uniaika can show why colourful IRC can be a pain :>
11:47:07 * Feuermagier is interested
11:47:23 <Uniaika> 14,6 KIKOO FEUERMAGIER  !!!!!! :o)))))))))))))))) 
11:47:24 <Uniaika> 10,3 KIKOOOOOOOOOOOO FEUERMAGIER  !!!!!!!! :o)))))))))))) 
11:47:24 <Uniaika> 7,4 KIKOO FEUERMAGIER  !!!!!! :o)))))))))) 
11:47:25 <Uniaika> 13,11 KIKOOOOOOO FEUERMAGIER  !!!!!!!!!!!!! :o)))))))) 
11:47:27 <Uniaika> 12,2 KIKOOOOOOOOO FEUERMAGIER  !!! :o)))))))))))))))) 
11:47:43 * Feuermagier is amused
11:48:11 <maerwald> lol
11:48:19 <monochrom> Yikes Uniaika sacrified themselves to show you.
11:48:33 <Feuermagier> how honorful
11:48:47 <Feuermagier> may he rest in peace
11:51:13 <zyklotomic> wait woah you can do that?
11:51:19 <zyklotomic> that worked for me, i was not ready for that
11:51:36 <merijn> You can do that, but clearly you shouldn't >.>
11:51:49 <Uniaika> Feuermagier: that's the last time I'm helpful :>
11:51:51 <zyklotomic> i have never ever seen colored in my 4 (albeit short) years of irc
11:52:00 <ben_m> what's next, embedded images, emoji and voice chat? 
11:52:07 <zyklotomic> woah woah slow down
11:52:21 <zyklotomic> maybe  a few decades down the road
11:52:34 <zyklotomic> i don't think that's possible right now
11:53:07 <zyklotomic> is there a clean way to compose functions that share tails?
11:53:19 <geekosaur> some clients translate emoji
11:53:19 <zyklotomic> f: a -> b -> c, g: b -> c -> d
11:53:33 <geekosaur> (it's a bad idea here, it'll do weird things to code)
11:53:38 <zyklotomic> where the b and the c arguments are the same
11:53:54 <zyklotomic> where the tail is the head of the next*
11:54:02 <Feuermagier> can I use emojis for variable or function names in haskell?
11:54:26 <maerwald> like haskell isn't obscure enough already
11:54:33 <Uniaika> ben_m: you could have avatars with Hexchat I think
11:54:41 <Uniaika> emojis are already here
11:55:04 <geekosaur> also there's emoji in unicode which probably pass through and are displayed by Unicode-capable clients
11:55:08 <merijn> > let x ☃ y = x*y + x + y in 3 ☃ 4 -- I dunno, can you?
11:55:10 <lambdabot>  19
11:55:21 <geekosaur> depends on the character class. I suspect they're symbols so would have to be operator syntax
11:55:44 <Feuermagier> merijn, my god, what have I done...
11:55:53 <merijn> > generalCategory '💩'
11:55:55 <lambdabot>  OtherSymbol
11:56:02 <merijn> Symbol, so valid operator :)
11:56:17 <merijn> > let x 💩 y = x*y + x + y in 3 💩 4 -- I dunno, can you?
11:56:18 <lambdabot>  19
11:56:28 <Feuermagier> *oh god*
11:56:39 <zyklotomic> oh right i was reading the other the day, almost any unicode is a valid operator
11:56:43 <merijn> Feuermagier: For details see chapter 2 of the Haskell 2010 report :p
11:56:50 <merijn> zyklotomic: Not really
11:57:01 <merijn> zyklotomic: Only the unicode characters with "symbol" class
11:57:28 <merijn> > generalCategory '∑'
11:57:30 <lambdabot>  MathSymbol
11:57:37 <Feuermagier> 🐧
11:57:40 <zyklotomic> ah
11:57:44 <merijn> > generalCategory 'Σ'
11:57:46 <lambdabot>  UppercaseLetter
11:57:48 <zyklotomic> and then there's this abomination https://github.com/vasilevp/aboriginal lol
11:58:22 <merijn> Note how the sum symbol is an operator, but capital sigma is a letter and thus only in function names
11:59:36 <zyklotomic> that makes sense
11:59:50 <Feuermagier> KDE replaces each one of those emjois with high-res color-images, which do not fit one bit into IRC
11:59:53 <zyklotomic> i'm surprised they thought to make this distinction
12:00:03 <merijn> zyklotomic: Fun related trivia
12:00:26 <Feuermagier> we don't have lambda, but we have 🦙
12:00:38 <merijn> The fact that GHC compiles this package https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html is technically a violation of the Haskell Report
12:01:45 <merijn> Constructor names must start with a capital letter and non-constructor names must start with a lowercase letter or _
12:01:52 <merijn> Notice the flaw?
12:02:09 <gentauro> anybody here using `xmobar`?
12:02:25 <gentauro> I would like to hide it for one of my `workspaces`
12:02:26 <gentauro> :)
12:02:54 <gentauro> (by default, but maybe show it with some Xmonad shortcut)
12:02:56 <merijn> GHC (technically wrongly) lets non-constructor names start with "non-uppercase letters or _", rather than lowercase letter of _ :p
12:03:00 <merijn> > isUpper 'ಠ'
12:03:02 <lambdabot>  False
12:03:04 <merijn> > isLower 'ಠ'
12:03:06 <lambdabot>  False
12:03:25 <gentauro> merijn: you can't use lowercase greek letters for constructors
12:03:26 <merijn> > isLetter 'ಠ'
12:03:29 <lambdabot>  True
12:03:32 <gentauro> but you can use the uppercase
12:04:05 <merijn> gentauro: 1) you can use lowercase greek letters for constructors, just not the first one, 2) I didn't say that? :)
12:04:31 <zyklotomic> gentauro: if you want immediate relief, i think the default is modifier-b
12:05:26 <geekosaur> gentauro, I think https://github.com/geekosaur/xmonad.hs/blob/pyanfar/xmonad.hs#L142 is as close as you get
12:05:28 <zyklotomic> i'm not sure about how to make it a rule though
12:05:37 <zyklotomic> oh ^ maybe geekosaur has it
12:05:54 <zyklotomic> merijn: that is one great hidden gem lol
12:06:12 <geekosaur> (note also the avoidStruts on the following line, for all the other workspaces)
12:07:22 <zyklotomic> is there a way around this following pattern? "segment str . viterbi hd $ str"
12:07:39 <zyklotomic> where str has to be used as an argument for both `segment' and `viterbi'
12:08:29 <dminuoso> liftA2 (.) segmetn (viterbi hd) $ str
12:08:34 <dminuoso> Not sure that's any better though.
12:08:58 <dminuoso> Or: (.) <$> segment <*> vierbi hd $ str
12:09:14 <dminuoso> no wait, that's not the same
12:09:14 <merijn> or...crazy idea
12:09:15 <zyklotomic> yeah I have liftA2 ominously imported before I asked
12:09:21 <gentauro> geekosaur: thanks, I will give it a try :)
12:09:22 <merijn> Write a lambda/put it into a let/where binding
12:09:55 <zyklotomic> but is `liftA2 (.)' kinda a bit too crazy?
12:09:56 <dminuoso> or.. it is the same. I really dislike using the monadic interface of Reader
12:10:00 <merijn> I know, I know...it's outrageous...but it's so crazy it just might work!
12:10:05 <gentauro> geekosaur: funny enough, it's to run a vm with `win 10` xD
12:10:09 <dminuoso> zyklotomic: It is.
12:10:10 <zyklotomic> i think i abuse `liftA2 (.)' too much
12:10:24 <merijn> zyklotomic: Probably
12:10:47 <dminuoso> One of the issues with overusing Applicative in the middle of code, is that it's sometimes not immediate obvious which instance is being used.
12:10:56 <merijn> Here's a great tip from coming back to a huge codebase with 6 month to 1 year intervals: Putting stuff in let/where and giving stuff names is a pretty great idea
12:11:23 <merijn> liftA2 (.) is a great way to hate yourself
12:11:57 <zyklotomic> yeah ok, I sane-ed up a lil and deleted it
12:12:04 <zyklotomic> thanks y'all
12:12:07 <dminuoso> zyklotomic: Personally Id just write parens.
12:12:19 <dminuoso> segment str (vierbi hd str)
12:12:24 <dminuoso> perhaps with a let/where binding
12:12:32 <dminuoso> There's no need to try and get cute her
12:12:38 <dminuoso> It certainly doesnt *improve* readability
12:12:51 <zyklotomic> yeah, I was just wondering if there was a way to avoid that double invoctaion of str somehow
12:13:02 <dminuoso> zyklotomic: since its named, it will be shared anyhow.
12:13:08 <dminuoso> (likely)
12:13:25 <zyklotomic> yeah, but aesthectically.... think about the a e s t h
12:13:35 <dminuoso> aesth?
12:13:47 <zyklotomic> i'm jokin tho /s
12:13:52 <tomsmeding> @pf \str -> segment str (viterbi hd str)
12:13:52 <lambdabot> Maybe you meant: pl bf
12:13:55 <tomsmeding> @pl \str -> segment str (viterbi hd str)
12:13:55 <lambdabot> ap segment (viterbi hd)
12:14:24 <dminuoso> 21:10:33      merijn | Here's a great tip from coming back to a huge codebase with 6 month to 1 year intervals: Putting stuff in let/where and giving stuff names is a pretty great idea
12:14:27 <dminuoso> This.
12:14:39 <tomsmeding> also if you use ap, think thrice and make a sacrifice
12:14:40 <zyklotomic> yah, i'm going to stick with that
12:14:50 <dminuoso> There's no single better general purpose technique to improve readability than to move things into let/where bindings.
12:15:00 <dminuoso> If the code becomes too complex, use more bindings.
12:15:39 <dsal> A lot of my programming was in RPL ("reverse polish lisp", a forth-like language on my HP48).  I almost never used variables. heh
12:15:50 <zyklotomic> i tihnk i'm at the stage of learning in haskell where I want to know whether there are "better" ways to do what I'm doing
12:16:00 <zyklotomic> whether going out of my way to worry about that is a worthwhile pursuit idk
12:16:03 <dsal> Never leave that stage.
12:16:10 <tomsmeding> zyklotomic: http://pointfree.io/
12:16:18 <tomsmeding> infinite supply of unreadability
12:16:36 <dsal> But sometimes something like liftA2 is obviously beneficial.  Something obscuring things doesn't help much.
12:17:13 <dsal> making things pointfree is helpful when you have   `\f x -> g 3 x` or something.
12:17:42 * ski . o O ( s/pointfree/pointless/ )
12:17:57 <tomsmeding> hence the naming of @pl
12:18:05 <zyklotomic> tomsmeding: ohhh
12:18:18 <dsal> In that case, you look and see the x on both sides, and you remove it.  Then you see `\f -> g 3` and then you're like, why did I even have a lambda there?
12:18:18 <dminuoso> tomsmeding: Oh.. haha really?
12:18:21 <dminuoso> I always wondered about that one
12:18:38 <ski> @help pl
12:18:38 <lambdabot> pointless <expr>. Play with pointfree code.
12:18:55 <dminuoso> zyklotomic: I found GHC to be a great source for ideas how to make readable code
12:19:12 <dsal> Actually, I'm being a bit dumb.  But in general, you can try a couple things and whichever makes the most sense to you wins.
12:19:17 <dminuoso> It is surprisingly readable
12:19:22 <dsal> Also, that  metric will change over time.
12:19:35 <zyklotomic> yeah, because like idk how to describe the feeling, but the cliche adage
12:19:42 <zyklotomic> "the more you know, the more you don't know"
12:19:55 <dminuoso> Perhaps this is a process people need to go through
12:20:15 <dminuoso> You dont know why certain styles are unmaintainable unless you use them. Or it teaches why they could be useful
12:20:28 <zyklotomic> yup fair, no shortcut
12:20:31 <dminuoso> Without it, you'd just be a victim to do whatever random folks on freenode told you
12:21:00 <geekosaur> that said, "a little knowledge is a dangerous thing"
12:21:31 <merijn> So is a lot of knowledge ;)
12:22:39 * ski . o O ( <https://www.vex.net/~trebla/humour/tautologies.html#6> )
12:22:57 <merijn> I saw Vanessa's tweet over "being the Dickens of code" and my initial reaction was "I'm the H.P. Lovecraft of code", in that my code describes a slow descent into gibbering madness that unsettles the reader and makes them question their place in the universe... >.>
12:24:57 <merijn> monochrom: I've got an addendum to your xkcd link on that page ;)
12:25:16 <merijn> monochrom: https://www.smbc-comics.com/comic/2014-09-02
12:29:41 <dsal> zyklotomic: I ask @pl for suggestions sometimes and if they're obviously better, I use them.  hlint also gives good recommendations sometimes.  Only rarely does it give really bad advice, IMO.
12:30:04 <zyklotomic> yeah hlint has really helped
12:30:20 <zyklotomic> i, just seconds ago, as a matter of fact, wondered
12:30:29 <dsal> hlint got mad at me for using [Char] somewhere.  I said what I meant.
12:30:29 <merijn> hlint's advice is contentious :p
12:30:31 <zyklotomic> how did I write such a clean loc, "oh wait hlint did"
12:30:46 <dsal> Yeah, all opinions are bad.  Code formatters can be pretty awful.
12:31:10 <dsal> But when I had no idea what I was doing, some opinions were better than my own much of the time.
12:31:11 <dminuoso> I dont linters at all.
12:31:37 <dminuoso> They tend to create noise for disagreeing on my style, and then I spend more time tweaking the linter rules than it improves my code
12:31:47 <dminuoso> Because I refuse to blindly obey hlint
12:32:13 <dsal> I run it on occasion and it sometimes points out a dumb thing I did in refactoring.
12:32:20 <merijn> hlint is great
12:32:25 <merijn> If you're Neil Mitchell :)
12:32:38 <glguy> hlint is great for adding cpp noise to your code as you block out regions that it can't handle
12:33:01 <dsal> I think it's pretty good if you're learning and you want some degree of code review without bugging humans constantly.
12:33:02 <zyklotomic> as long as it's easy to tell the linter to shut up where you want to? i haven't gotten to the stage where I trust my style more
12:33:08 <zyklotomic> yeah
12:33:11 * ski . o O ( "He is also known for crediting his computer \"Shalosh B. Ekhad\" as a co-author" <https://en.wikipedia.org/wiki/Shalosh_B._Ekhad> )
12:33:25 <glguy> The problem with leaning on it as a new user is you don't know which suggestions are ones you should have avoided
12:35:10 <dsal> I guess it depends on how you approach it.  I never look at it to ask if my code is good.  Just another opinion.  Sometimes interesting ones.
12:35:44 <hpc> the trouble with hlint is there's not much it can do to catch things that matter
12:35:57 <hpc> compared to say, shellcheck which is almost compiler levels of valuable
12:36:27 <zyklotomic> i think at least as a very very novice, doing things like map (\x -> x+3), it was invaluable
12:36:54 <zyklotomic> it should get recommended more
12:37:14 <dminuoso> zyklotomic: As you can see there's a lot of disagreement in the past few minutes already.
12:37:17 <zyklotomic> and well, you'll know when you don't need it 
12:37:53 <zyklotomic> dminuoso: :p, well specifically from the perspective of a complete noob though
12:38:10 <[exa]> hlint is GREAT for newbies
12:38:25 <monochrom> hlint is a very misleading name.
12:38:35 <monochrom> hlint is hardly comparable to C lint.
12:38:36 <[exa]> yeah, hhint
12:38:44 <dminuoso> At work I have a colleague who runs his python linter in the CI. So if you submit a merge request, and you use an underscore in a place that the linter things is "terrible style", it is undeployable.
12:38:56 <maerwald> hlint is annoying in CI
12:39:03 <monochrom> Whereas C lint points out very real mistakes, hlint is merely style nitpicking.
12:39:04 <dsal> Yeah, it never tells me my code is wrong, just stuff like, "Hey, `fmap f . fmap g` is `fmap (f . g)`
12:39:05 <dminuoso> So Im fairly allergic to linters. Beginners trust them too much
12:39:05 <dsal> "
12:39:10 <sszark> has hackage always not had a SSL certificate? or is that a mistake
12:39:31 <dminuoso> sszark: What do you mean? The website?
12:39:35 <monochrom> The damage is that beginners look at the name "hlint" and don't know it's a blatant lie.
12:39:39 <zyklotomic> yah i was going to say that double fmap rule was eye opening
12:39:47 <glguy> I agree they're annoying in CI, but if you accept the assumption that it's a good idea to use it at all it doesn't seem like a bad idea to enforce people clean up the suggestions
12:39:57 <hpc> sszark: it just doesn't redirect to https
12:40:04 <zyklotomic> dsal: i notice that when i'm writing javascript too now, it's crazy
12:40:08 <glguy> having long-running lint suggestions clouds seeing the new arguably useful ones, right?
12:40:36 <sszark> oh i see, that makes sense i guess hpc 
12:40:43 <maerwald> well, the problem is if you disagree with most hlint suggestions and the ones that I don't disagree with are not worth the time
12:40:53 <monochrom> Like, there is a reason I write "\x -> f x" when teaching beginners. Shut up, hlint.
12:41:11 <merijn> sszark: hackage does have SSL, but there's no autoforward
12:41:22 <monochrom> No, actually, I should speak like hlint does.  Why don't you shut the f* up, hlint.
12:41:35 <glguy> relying on autoforward isn't a great plan. explicitly use https if that's what you want
12:41:35 <dminuoso> Also, you should name it TLS. SSL is usually used to refer to the old versions of the protocol suite. :)
12:41:36 <merijn> sszark: There was an email about setting up an autoforward the past week
12:41:47 <merijn> sszark: Anyway, hackage doesn't need SSL for security anyway
12:42:00 <merijn> (well, assuming you got cabal-install from a trusted source :p)
12:42:31 <maerwald> merijn: and how do you verify the hackage index?
12:42:37 <merijn> maerwald: It's signed
12:42:56 <maerwald> with a human key?
12:43:01 <merijn> maerwald: You need an uncompromised cabal-install first, but you can't download that from Hackage anyway
12:43:12 <dsal> Transport isn't going to verify your index
12:43:35 <merijn> maerwald: Hackage uses TUF, so, eh, look up the details yourself? https://theupdateframework.io/
12:44:39 <triteraflops> I decided linear programming is a good idea, and would like to experiment further with it. How "ready" is linear haskell? Could it plausibly be used on a real world project without anything catching fire?
12:45:00 <merijn> triteraflops: Considering it requires an unreleased GHC "no" :p
12:45:17 <triteraflops> lol
12:45:21 <triteraflops> irp
12:45:22 <triteraflops> rip
12:46:03 <merijn> You could, conceivably, build something non-trivial by grabbing a build from CI and using head-hackages, but it's very much a "DIY ductape and wire" kinda stage"
12:46:50 <triteraflops> "
12:47:52 <triteraflops> Well, what about Idris? I know I should ask #idris, but what the hey.
12:48:03 <merijn> Does Idris even have linear types?
12:48:11 <triteraflops> idris2 does
12:50:49 <MarcelineVQ> there's no no-fire gurantees on any software
12:50:59 <merijn> MarcelineVQ: Of course
12:51:08 <merijn> MarcelineVQ: There's no guarantees for your hardware either :p
12:51:29 <merijn> At some point you need to settle for a realistic threat model
12:51:43 <hpc> that's the nice thing about hardware, the fires are literal
12:51:46 <merijn> I would recommend following James Mickens' threat model :p
12:52:32 <monochrom> Just use a nitrogen chamber.
12:52:36 <merijn> I refer to the threat model table on page 2 of https://www.usenix.org/system/files/1401_08-12_mickens.pdf (although, in all honestly I highly recommend reading the entire thing)
12:52:47 <merijn> s/honestly/honesty
12:53:32 <monochrom> Use the subtraction method. s/in all// is a more efficient fix. :)
12:54:53 * hackage zio 0.1.0.2 - App-centric Monad-transformer based on Scala ZIO (UIO + ReaderT + ExceptT).  https://hackage.haskell.org/package/zio-0.1.0.2 (bebarker)
12:54:54 <hpc> oh man, that pdf is great
12:55:23 <merijn> hpc: Good news for you
12:55:35 <merijn> hpc: He wrote like 10 more editorials and gave several equally amazing talks
12:56:00 <merijn> The Night Watch is especially nice if you've ever done any systems stuff
13:03:23 * hackage pandoc-crossref 0.3.8.4 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.8.4 (lierdakil)
13:04:31 <triteraflops> I just learned about Clean. Looks like that's the way to go for building a real thing today using linear types.
13:04:49 <merijn> Clean doesn't have linear types, I don't think?
13:04:57 <merijn> Pretty sure they only have uniqueness types, no?
13:05:03 <ski> correct
13:05:05 <triteraflops> isn't that the same thing?
13:05:06 <c_wraith> Uniqueness types are a lot more useful anyway
13:05:11 <ski> triteraflops, nope
13:05:15 <merijn> Although, if you wanna built CRUD applications for Windows, Clean is good ;)
13:06:41 <triteraflops> ski: so what's the difference?
13:07:43 <c_wraith> a linear function says "this function uses this argument exactly once".  A function with a unique constraint says "this value is passed to this function and not use anywhere else"
13:08:16 <ski> (Mercury's another language with uniqueness. although, in that case, not put into the types, but rather the "insts" (instatiation states). Rust also has stuff that is of a somewhat similar ilk)
13:09:10 <triteraflops> hm, kind of moves the bubble over.
13:09:49 <triteraflops> uniqueness puts constraints on other functions and linearity is a constraint only on that function
13:10:00 <ski> triteraflops : with uniqueness, you know that the value haven't been duplicated in the past (but you're allowed to duplicate in the future). with linearity/affinity, you're promising not to duplicate it in the future (but it might already have been duplicated in the past)
13:10:09 <c_wraith> more generally, uniqueness puts the constraint on the caller.  But yes.
13:11:34 <triteraflops> But they're kinda solving the same problem, of compile-time duplication awareness and avoidance
13:12:00 <ski> (difference between linearity and affinity is that affinity allows you to (implicitly) discard, while linearity doesn't (you could still pass explicitly to a waste disposal facility))
13:12:40 <triteraflops> Then there's C++'s move semantics, which are just silly.
13:12:51 <triteraflops> I still don't understand them.
13:13:02 <triteraflops> too complicated
13:13:56 <[exa]> there's no move
13:15:28 <merijn> move semantics are ok, they're pretty straightforward it's the rvalue reference stuff that's a confusing mess :)
13:15:34 <ski> it seems to me there's an interesting language trapped inside C++ lvalue & rvalue references, move semantics, perfect forwarding, wanting to be released
13:15:57 <c_wraith> C++ is long past mere lvalues and rvalues.  now it has a whole hierarchy
13:16:03 <merijn> pvalues!
13:16:21 <merijn> lvalue references, rvalue references!
13:16:21 <ski> (wg 70
13:16:26 <triteraflops> copy elision
13:16:30 <merijn> I think we have like prvalues too?
13:16:38 <triteraflops> yeah that too
13:16:47 <merijn> triteraflops: copy elision is obsoleted by move semantics and rvalue references
13:17:05 <triteraflops> well, good for C++
13:17:08 <triteraflops> lol
13:17:16 <triteraflops> I gave up on it a while ago
13:17:26 <[exa]> there are 3 in fact, standard section 7.2.1 specifies just lvalue, xvalue and prvalue
13:17:38 <merijn> move semantics are just a more formal and structured way of considering copy elision without worrying whether copy elision will trigger by the compiler, since it's now specified
13:17:50 <[exa]> copy&move elision are completely orthogonal concepts related to function call semantics
13:18:03 <merijn> anyhoo
13:18:16 <merijn> This conversation is triggering, so time to stop coding/ircing ;)
13:22:03 <triteraflops> wth, there's like 5 people in #cleanlang. Why isn't this language more popular?
13:24:01 <merijn> Because I think the only people using it are all at the Radboud Universiteit :p
13:24:38 <merijn> It's mostly a research language, I don't think there's a very big community working on libraries, packages, etc.
13:24:40 <ski> Clean isn't bad
13:25:00 <merijn> ski: I didn't say it was, I just said it didn't have any users ;)
13:25:24 <merijn> You need critical mass for libraries and you need libraries for users
13:25:37 <[exa]> Evil me: Clean isn't popular because it didn't target the web.  Realistic me: Well, yeah
13:25:51 * ski . o O ( "Recently, researchers have experimented with new I/O combinators based on monads." -- <https://web.archive.org/web/20140303101716/http://www-fp.dcs.st-and.ac.uk/%7Ekh/papers/io-tutorial/io-tutorial.html> )
13:26:18 <merijn> Every year at the NL-FP day we still have the mandatory one or two Clean talks :p
13:26:50 <dsal> How many days of dirty talks?
13:27:14 <ski> merijn : ah, sorry. i didn't mean that to sound like being an opposing point to what you said, just as a general sentiment response to triteraflops
13:32:31 <ski> Clean has an interesting integration of `Dynamic' with pattern-matching, allowing them to trivially implement e.g. `dynApply'; <https://clean.cs.ru.nl/download/html_report/CleanRep.2.2_10.htm#_Toc311798086>
13:33:16 <monochrom> As a general heuristic, if you language doesn't use C syntax, it won't be popular.
13:33:38 <merijn> monochrom: SQL? :P
13:34:12 <monochrom> Hey, that's a great idea, perhaps the no-sql movement started with hating SQL syntax!
13:35:36 <monochrom> Also it's just a heuristic. Python deviates partly from C syntax, and it's still popular.  Although, Python probably shows you the largest extent of deviation you can afford.
13:36:39 <monochrom> Namely, if you still stick to the "f(x,y,z)" syntax, if you only replace {;} by layout, you will be OK.
13:37:15 <monochrom> Whereas Lisp's "(f x y z)" and SML's "f x y z" prove to be going too far.
13:41:56 <ski> perhaps we just have to draw it out more
13:54:38 <c_wraith> I think this is why codeworld doesn't expose the Prelude at all.  It provides a set of base functionality that uncurries everything so that people don't have to not use commas
13:57:32 <ski> :(
14:01:56 <monochrom> Haha this is great. My wild guess theory is right on.
14:02:39 <monochrom> Perhaps I really understand human nature! Long live cynicism!
14:09:52 * hackage timerep 2.0.1.0 - Parse and display time according to some RFCs (RFC3339, RFC2822, RFC822)  https://hackage.haskell.org/package/timerep-2.0.1.0 (koral)
14:11:01 <maerwald> I wonder how long the haskell survey results take
14:11:11 <maerwald> it's been a week since it's closed I think
14:45:59 <texasmynsted> sounds like somebody needs to write a haskell program to tabulate the results
14:51:31 <redmp> is there a way to define a relation on types, such that i can query either side and get the other?
14:52:02 <redmp> i'm contemplating storing a list of pairs of types and then defining lookup for the left item and lookup for the right item..
14:54:02 <texasmynsted> redmp: How would you use this? I am curious
14:55:52 <texasmynsted> You could make a list of two-item ring buffers.
14:56:43 <texasmynsted> hmm. maybe that is not helpful. I really do not know what you want to do
14:56:52 * hackage rowdy-yesod 0.0.1.1 - An EDSL for web application routes.  https://hackage.haskell.org/package/rowdy-yesod-0.0.1.1 (parsonsmatt)
14:57:11 <ski> redmp : how about a multi-parameter type class (possibly with functional dependencies) ?
14:58:28 <redmp> ah, sorry, i was unclear.. the querying is a type level thing. I'm going to be querying at compile time
14:59:29 <ski> so do you think MPTCs, perhaps with FDs, could be helpful ?
14:59:59 <redmp> it might be? i'm not usually very successful when i try to use MPTCs
15:00:21 <redmp> i was thinking of a type level list and a type level lookup function because i think of that as being simpler
15:00:27 <redmp> MPTC would be nice because it's open
15:04:13 <ski> i guess it depnds on how you're intending to use it, as texasmynsted said
15:07:28 <redmp> err, i'm trying to represent a relation between types as a type family so that i can type some functions in terms of each domain from the other.. ie. FooOf BarType would give me the FooType from the Foo domain which corresponds to BarType... and then i could also say BarOf FooType to get back
15:12:57 <redmp> and then i can say things like `toFoo :: a -> FooOf a` and `fromFoo :: FooOf a -> a` or something
15:13:18 <redmp> those would have to be typeclass methods, i think
15:20:07 <ski> redmp : hm, you could have injectivity to ensure it's invertible. however, i wonder if there's a nice way to ensure that `FooOf' is the inverse of `BarOf'
15:20:38 <ski> yea. you're probably looking at associated type families, then
15:30:47 <ski>   class (a ~ FooOf (BarOf a),Bar (BarOf a)) => Foo a where type BarOf a = b | b -> a; toBar :: a -> BarOf a; fromBar :: BarOf a -> a; toBar = fromFoo; fromBar = toFoo
15:30:50 <ski>   class (b ~ BarOf (FooOf b),Foo (FooOf b)) => Bar b where type FooOf b = a | a -> b; toFoo :: b -> FooOf b; fromFoo :: FooOf b -> b; toFoo = fromBar; fromFoo = toBar
15:31:09 <ski> redmp : i wonder whether something like that could be helpful ?
15:33:01 <redmp> https://termbin.com/5l4q
15:33:21 <redmp> ^ this implements the list approach that i described
15:33:31 <redmp> taking a look at your class based approach now..
15:34:47 <redmp> oh wow, ski, those classes convey the whole embedding/extraction thing
15:39:03 <ski> (i used `TypeFamilies',`TypeFamilyDependencies',`FlexibleContexts',`UndecidableSuperClasses')
16:18:43 <feego> hi, I'm having a little trouble seeing why (+) <$> [1,2] <*> [3, 4] wouldn't be [4, 6]
16:18:56 <feego> or why <*> for lists isn't defined that way
16:21:58 <frdg> feego: You can use ZipList to get the behavior you are seeking. ZipList comes with an applicative instance that will zip the lists together like you were expecting. 
16:22:18 <feego> yeah, i understand that, but i'm curious why <*> wasn't defined like that
16:23:12 <maerwald> would it violate applicative laws?
16:24:02 <kadoban> IIRC then there'd be no Monad instance.
16:24:40 <feego> can you elaborate on that?
16:25:44 <kadoban> Well, I don't think ZipList has a Monad instance that follows the rules. So then there'd be no list monad, or if there were it'd have to be the other one, the nondeterminism one?
16:26:37 <dsal> feego: Do you not find the cartesian product to be valid?
16:27:38 <dsal> > liftA2 (,) [1..5] [1..5] -- I've used stuff like this quite a bit.  It doesn't seem like an unreasonable default, especially since it uses all its inputs.
16:27:39 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
16:27:51 <ski> > return 0 :: ZipList Integer
16:27:53 <lambdabot>  error:
16:27:53 <lambdabot>      • No instance for (Monad ZipList) arising from a use of ‘return’
16:27:53 <lambdabot>      • In the expression: return 0 :: ZipList Integer
16:28:59 <ski> feego : it's expected that if you have a `Monad' instance, then `(<*>) = ap' (or at least close to that ..) (and `pure = return')
16:29:06 <kadoban> If you only look at Applicative I think they're both pretty valid. Can only pick one (or zero) to be the default though. Could just require a newtype wrapper to get any. But since Monad came first, it was probably obvious to use the Monad that actually existed. Then once you've picked that an Applicative becomes more of a thing, you have to be consistent with that.
16:29:46 <feego> hm ok
16:30:26 <ski> > pure 0 :: ZipList Integer
16:30:30 <lambdabot>  ZipList {getZipList = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:31:21 <ski> > let zap = zipWith ($) in repeat (+) `zap` [1,2] `zap` [3,4]
16:31:24 <lambdabot>  [4,6]
16:34:08 <dsal> zapplicative
16:56:04 <hekkaidekapus> maerwald: “I wonder how long the haskell survey results take.” The data is tampered with anyway: <https://github.com/haskellweekly/haskellweekly/issues/61>
16:57:43 <hekkaidekapus> I mean, sh*t happens, but we’re talking about a poll. Tossing 0.8K data points (0.4K) like that is, … I don’t know.
16:58:02 <hekkaidekapus> *(0.4K at best)
17:08:35 <maerwald> Seems it's not usable then
17:12:54 <hekkaidekapus> If it were something related to Python or Java, it would be possible to statistically correct for the N/A. I am curious to see how the problem—a stark one imo—will be presented in the results announcement.
17:51:18 <conjunctive> Hi, how do I go about building documentation for all of my dependencies with cabal? I've set Documentation to true for my global cabal config, but :doc still isn't working for third-party packages in GHCI.
18:06:42 <futuba> Hi! I am doing CS194 exercise 2 here: https://www.seas.upenn.edu/~cis194/fall16/hw/08-functor-applicative.html
18:06:52 <futuba> Would somebody be able to walk me through how you would go through func2?
18:32:21 <koz_> futuba: What do you mean by 'how would you go through func2'?
18:32:45 <futuba> to simplify it as an applicative or functor instance?
18:33:03 <futuba> the task is to take func2 xs = xs >>= (\x -> xs >>= \y -> return (x,y)), and rewrite it without monad bind
18:33:07 <koz_> futuba: That's tantamount to straight-up asking for an answer.
18:33:14 <futuba> i'm not sure how to approach it
18:33:25 <koz_> OK, so let's think about it this way.
18:33:26 <futuba> well the answer is here: https://www.seas.upenn.edu/~cis194/fall16/sols/08-functor-applicative.hs
18:33:33 <futuba> but i'm not sure how i would go about getting there
18:33:38 <koz_> Suppose instead of a (Monad f) constraint, you had (Functor f)
18:33:42 <futuba> right
18:33:51 <koz_> Now, this meand you've only got fmap to work with.
18:33:56 <futuba> yep
18:34:07 <koz_> And you have an 'f a', and you gotta get an 'f (a, a)'.
18:34:12 <futuba> yeah
18:34:18 <koz_> Now, the only thing you can use is fmap.
18:34:29 <koz_> So suppose we were to write 'func2 xs = fmap _ xs'.
18:34:33 <koz_> What type does the hole have?
18:35:46 <futuba> so fmap is a->b->(f a->f b)
18:35:57 <futuba> and func2 is f a -> f (a, a)
18:36:36 <futuba> is that possible?
18:36:46 <koz_> What do you mean?
18:37:00 <futuba> oh, i guess you can do a -> (a, a)
18:37:02 <koz_> You have 'func2 :: (Functor f) => f a -> f (a, a)'
18:37:10 <koz_> And we've got 'func2 xs = fmap _ xs'.
18:37:13 <koz_> What type is the hole?
18:37:20 <futuba> yeah, a->(a, a) should work
18:37:26 <koz_> OK, can you write such a function?
18:37:35 <futuba> \x->(x, x)
18:37:50 <koz_> So that's the approach.
18:37:55 <futuba> but that's not correct
18:38:02 <koz_> Why not?
18:38:12 <futuba> func2 is not equivalent to fmap \x->(x, x) xs
18:38:21 <futuba> func1 is equivalent to that
18:38:52 <futuba> func2 [1,2] gives you [(1,1),(1,2),(2,1),(2,2)]
18:39:03 <futuba> it's right for the Just monad
18:39:05 <futuba> *Maybe
18:39:22 <koz_> So what does this tell you?
18:39:26 <koz_> Is Functor enough?
18:39:36 <futuba> no
18:39:49 <koz_> OK, so now let's try Applicative. This gives us two new tools to play with.
18:39:54 <koz_> Which are pure and <*>.
18:40:12 <koz_> And see if that gets you anyplace.
18:40:37 <koz_> There's not much I can do beyond saying 'consider your tools carefully and try things' which wouldn't just straight-up give you the answer.
18:41:08 <futuba> right, like when I read the answer i understood why it works, but i don't know how to get from that to the answer
18:41:29 <koz_> Yeah, which is why I'm telling you there's no magic formula.
18:41:37 <futuba> oh
18:41:40 <koz_> Do you see what func2 is doing in an abstract sense.
18:41:41 <koz_> ?*
18:41:42 <lambdabot> Maybe you meant: v @ ? .
18:42:05 <koz_> To make it easier, consider func2 specialized to Maybe.
18:42:12 <futuba> yeah, so I was trying that
18:42:15 <koz_> What's actually being done here?
18:42:20 <futuba> and func1 func2 and func3 were all identical
18:42:28 <koz_> Yeah, but that's in terms of _results_.
18:42:31 <koz_> I wasn't asking for that.
18:42:47 <koz_> They do very different things, it just so happens that they have the same result if f ~ Maybe.
18:42:55 <futuba> oh
18:42:56 <monochrom> No way func1, func2, func3 are the same.
18:43:55 <futuba> yeah, i guess i am having a little trouble understanding what func2 is doing abstractly
18:44:24 <futuba> it's like unwrapping it twice and then making a pair out of it kind of?
18:44:26 <monochrom> There is no need to stay abstract. Use f=[] to find out.
18:44:58 <koz_> (in fact, you already did, and your example of 'func2 [1,2]' holds all the answers you need)
18:45:27 <monochrom> Use a long list to see more of the trend.
18:45:28 <futuba> yeah, i understood what it does for [(1, 2)]
18:45:37 <futuba> i guess for list and maybe i see what it does
18:47:06 <monochrom> Now just rewrite func2 and func3 using Applicative only. Use what you know about what <*> does when f=[].
19:05:46 <boxscape> is there some way to have ghc reduce type family applications in type errors?
19:07:12 <boxscape> I suppose -fprint-expanded-synonyms is supposed to do it... but it doesn't do it for my example:
19:07:31 <boxscape> % type family X2 a where X2 Int = String
19:07:32 <yahb> boxscape: 
19:07:47 <boxscape> % :set -fprint-expanded-synonyms
19:07:48 <yahb> boxscape: 
19:07:59 <boxscape> % type family X3 a :: Maybe (X2 Int) where X3 a = '()
19:08:00 <yahb> boxscape: ; <interactive>:75:49: error:; * Expected kind `Maybe (X2 Int)', but '() has kind `()'; * In the type '(); In the type family declaration for `X3'
19:08:22 <boxscape> I would expect this to print "Expected kind `Maybe String'" somewhere
19:09:17 <boxscape> or, well, I suppose the flag is actually only about type synonyms, not type families
20:15:47 <futuba> i can't understand the idea of x <$> p <*> q pattern
20:15:54 <futuba> does anyone have some intuition please?
20:16:28 <dsal> I think it's very intuitive when you think about it in terms of Maybe.
20:16:47 <dsal> Each step takes an the previous step's value if it's Just, otherwise short circuits to Nothing.
20:17:56 <futuba> sorry, can you explain what the steps are?
20:19:04 <dsal> > (,) <$> Just 2 <*> Just 3
20:19:06 <lambdabot>  Just (2,3)
20:19:29 <dsal> Each thing might return Nothing or Just a value, and I want to either get Nothing, or just `x` in your case.
20:19:46 <dsal> > (,,) <$> Just 1 <*> Just 2 <*> Just 3
20:19:48 <lambdabot>  Just (1,2,3)
20:19:50 <dsal> > (,,) <$> Nothing <*> Just 2 <*> Just 3
20:19:52 <lambdabot>  Nothing
20:20:09 <futuba> hm so i should think like the first argument is the function
20:20:17 <futuba> and then the other arguments are the things you apply the functions to?
20:20:39 <dsal> > (+) <$> Nothing <*> Just 2
20:20:42 <lambdabot>  Nothing
20:20:44 <dsal> > (+) <$> Just 11 <*> Just 2
20:20:48 <lambdabot>  Just 13
20:22:21 <dsal> > (+) <$> Right 11 <*> Right 2
20:22:24 <lambdabot>  Right 13
20:22:26 <dsal> > (+) <$> Left "boo" <*> Right 2
20:22:29 <lambdabot>  Left "boo"
20:22:41 <koz_> The way I like to think about it is this.
20:22:51 <koz_> If you have 'f x y', you're computing in a 'pure' context.
20:23:04 <koz_> But what if x and y have effects too?
20:23:12 <koz_> For example, IO, or Maybe, or w/e?
20:23:15 <koz_> We wanna compute there too.
20:23:29 <koz_> So in that case, we can use the Applicative nature of (many) effects, and instead write
20:23:33 <koz_> f <$> x <*> y
20:23:36 <dsal> :t (+) <$> pure 1 <*> pure 2
20:23:37 <lambdabot> (Applicative f, Num b) => f b
20:24:17 <koz_> A way to make this even more clear:
20:24:20 <koz_> :t ($)
20:24:22 <lambdabot> (a -> b) -> a -> b
20:24:25 <koz_> :t <*>
20:24:27 <lambdabot> error: parse error on input ‘<*>’
20:24:32 <koz_> :t (<*>)
20:24:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:24:39 <koz_> Notice how those are quite similar?
20:24:50 <futuba> yeah
20:24:55 <futuba> hm interesting
20:25:01 <dsal> :t (<$>) -- for completeness
20:25:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:25:29 <koz_> In this case, it's best vieweed as having the type '(Functor f) => (a -> b) -> (f a -> f b)
20:25:30 <koz_> '
20:25:50 <koz_> (i.e. you are 'promoting' a function that works on non-effectful values to a function that works on effectful ones)
20:26:09 <koz_> You will also note that (<$>) is fmap.
20:26:22 <koz_> (we have it there to make stuff of this form easier to write)
20:27:10 <futuba> right
20:27:11 <futuba> ok
20:27:58 <koz_> Also work noting - any Applicative is also a Functor.
20:28:02 <koz_> s/work/worth/
20:28:28 <futuba> right
20:28:38 <futuba> another question, what is the point of using >>?
20:28:52 <koz_> futuba: For that, we can compare with >>=
20:28:55 <koz_> :t (>>=)
20:28:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:29:00 <koz_> :t (>>)
20:29:01 <lambdabot> Monad m => m a -> m b -> m b
20:29:06 <koz_> What's the difference there?
20:29:11 <futuba> there's no a
20:29:27 <koz_> Precisely - we don't use the 'a' to produce the m b.
20:29:33 <koz_> However, 'm a' still has an effect.
20:29:48 <koz_> So when we use >>, both _effects_ still occur, but we just ignore the _value_ from the first one.
20:29:57 <futuba> ohh
20:29:58 <koz_> (in fact, you can define >> using >>=)
20:30:08 <futuba> but for Maybe and List monad, there's no point right?
20:30:13 <koz_> Also, given the nature of your questions: have you read the Typeclassopedia?
20:30:18 <futuba> I have not
20:30:20 <koz_> For 'Maybe', there very much _is_ a point.
20:30:27 <futuba> but I am aware of the typeclass defiitions
20:30:34 <koz_> I would recommend that you read the Typeclassopedia.
20:30:41 <futuba> I think I saw it and found it too scary :))
20:30:44 <koz_> A lot of your questions are answered by it, in great detail.
20:30:47 <koz_> Yeah, it's not a light read.
20:30:53 <koz_> But patience and time gets you everywhere.
20:31:11 <futuba> what's the best way to get practice with these things?
20:32:03 <futuba> i feel like typeclassopedia will get me the necessary theory, but i kind of feel like i need to think through code and stuff to really understand them
20:32:03 <koz_> futuba: Write more Haskell.
20:32:09 <futuba> yeah, but how :)
20:32:15 <koz_> Think of a thing you wanna make.
20:32:17 <koz_> Then write that.
20:32:24 <koz_> Do the exercises the Typeclassopedia comes with.
20:32:30 <koz_> (all, or nearly all, of them are code)
20:32:40 <koz_> Ditto the exercises you asked about earlier.
22:01:23 * hackage uusi 0.2.1.0 - Tweak dependencies in .cabal files  https://hackage.haskell.org/package/uusi-0.2.1.0 (berberman)
