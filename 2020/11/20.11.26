00:00:16 <incertia> when i learned about Proxy my entire world changed
00:00:19 <koz_> :t flip const map
00:00:22 <lambdabot> c -> c
00:00:25 <koz_> LOL
00:00:48 <dminuoso> I think I should get three points for tripping koz_ up twice in a row.
00:01:03 <incertia> that and DataKinds
00:01:08 <incertia> it's so galaxy brained
00:01:21 <xerox_> % :t flip const unsafePerformIO
00:01:21 <yahb> xerox_: forall {c}. c -> c
00:01:29 <koz_> incertia: Type :: Type is the real galaxy brain idea.
00:01:41 <dminuoso> xerox_: Oh I have an idea.
00:01:46 <dminuoso> flip const unsafeCoerce
00:01:57 <koz_> :t flip const unsafeCoerce
00:01:59 <lambdabot> error: Variable not in scope: unsafeCoerce
00:02:09 <dminuoso> % import Unsafe.Coerce
00:02:09 <yahb> dminuoso: 
00:02:14 <dminuoso> % :t flip const unsafeCoerce
00:02:15 <yahb> dminuoso: forall {c}. c -> c
00:02:17 <dminuoso> This looks really dangerous.
00:02:50 <jle`> `flip const unsafeCoerce` is pretty much the same as `unsafeCoerce`, ironically
00:02:56 <jle`> just with a more specialized type
00:03:04 <dminuoso> Okay enough of flip const. What other elaborate ways of doing.. nothing can you think of?
00:03:23 <koz_> dminuoso: fmap id
00:03:23 <jle`> % map ($ 10) [unsafeCoerce, flip const unsafeCoerce]
00:03:24 <yahb> jle`: ; <interactive>:92:1: error:; Ambiguous occurrence `map'; It could refer to; either `Data.List.NonEmpty.map', imported from `Data.List.NonEmpty'; or `Prelude.map', imported from `Prelude' (and originally defined in `GHC.Base')
00:03:33 <jle`> D:
00:03:37 <koz_> dimap id id also works
00:03:39 <jle`> % Prelude.map ($ 10) [unsafeCoerce, flip const unsafeCoerce]
00:03:39 <yahb> jle`: [10,10]
00:03:50 <dminuoso> koz_: well those are very obvious
00:03:50 <jle`> koz_: you mean dimap id id id
00:04:00 <koz_> jle`: Rofl.
00:04:01 <dminuoso> `dimap id id id` is slightly more running
00:04:05 <dminuoso> cunning.
00:04:10 <jle`> dimap id id wouldn't work i think
00:04:16 <jle`> % Prelude.map ($ 10) [unsafeCoerce, flip const unsafeCoerce, dimap id id id]
00:04:16 <yahb> jle`: [10,10,10]
00:04:42 <jle`> % Prelude.map ($ 10) [unsafeCoerce, flip const unsafeCoerce, dimap id id id, const 10]
00:04:43 <yahb> jle`: [10,10,10,10]
00:05:35 <incertia> const 10 the big brain id
00:05:53 <dminuoso> % :t fix ($)
00:05:53 <yahb> dminuoso: forall {a} {b}. a -> b
00:05:55 <dminuoso> Mmm.
00:06:32 <jle`> how to heat up a CPU
00:06:56 <dminuoso> Yeah. Who said pure code didn't have side effects.
00:07:22 <incertia> oh god you can't even C-c out of it
00:07:45 <incertia> that's so cursed
00:07:52 <koz_> LOL
00:08:20 <jle`> % fix($)fix
00:08:26 <yahb> jle`: [Timed out]
00:09:05 <dminuoso> :t fix (const fix)
00:09:06 <lambdabot> (a -> a) -> a
00:09:13 <dminuoso> Okay that looks like something now
00:10:11 <dminuoso> % fix (const fix) $ \t -> (1, fst t + 1)
00:10:11 <yahb> dminuoso: (1,2)
00:10:20 <dminuoso> Great. So we have a more elaborate way of doing fix
00:11:03 <n0042> I'd like to take a moment to applaud whoever decided to name the Vector function `snoc`.
00:11:11 <n0042> That is pretty swell.
00:11:26 <dminuoso> n0042: snoc is just cons in reverse
00:11:31 <n0042> Exactly
00:11:34 <jle`> yeah, it's instantly understandable :)
00:11:34 <koz_> n0042: It's 100 IQ wordplay relative some of the stunts Edward pulls.
00:11:37 <koz_> :t confusing
00:11:39 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
00:12:01 <dminuoso> koz_: Haha, it took me a year to get why confusing was called confusing
00:12:06 <dminuoso> Then it hit me
00:12:22 <dminuoso> lens is filled with so many puns
00:12:32 <koz_> Or, alternatively, Joker and Clown.
00:12:39 <koz_> (that's actually a two-level reference)
00:13:19 <dminuoso> Well if you dont know Stealers Wheels
00:13:52 <dminuoso> The curious thing though is
00:13:56 <dminuoso> % :t const fix
00:13:56 <yahb> dminuoso: b -> (a -> a) -> a
00:13:59 <dminuoso> % :t fix
00:13:59 <yahb> dminuoso: (a -> a) -> a
00:14:15 <dminuoso> Ah I guess `b ~ (a -> a) -> a`
00:15:07 <jle`> fix (const x) = x
00:15:12 <jle`> % fix (const "hello")
00:15:13 <yahb> jle`: "hello"
00:15:33 <dminuoso> % :t fix . const
00:15:33 <yahb> dminuoso: c -> c
00:15:36 <dminuoso> There we go!
00:15:43 <jle`> neato
00:16:10 <jle`> % Prelude.map ($ 10) [unsafeCoerce, flip const unsafeCoerce, dimap id id id, const 10, fix . const]
00:16:11 <yahb> jle`: [10,10,10,10,10]
00:16:42 <koz_> Procrastination a la #haskell.
00:17:40 <aplainzetakind> I'm trying get a handle on conditional compilation with cabal flags by means of an over-architectured advent of code project: https://gist.github.com/aplainzetakind/ba5b0fa3af4ef7f3deec77c5e025b746 trying to build this, cabal tells me this module imports itself. Why does this happen? (Removing CPP and commenting out ifdefs works fine.)
00:18:01 <jle`> woo hoo, over-architected advent of code projects
00:18:40 <jophish> No semigroup instance for Product :(
00:18:46 <koz_> jle` is uniquely qualified to talk about this!
00:18:46 <jophish> (Data.Functor.Product.Product)
00:18:56 <koz_> jophish: I think you want a different Product.
00:19:07 <jophish> koz_: I do?
00:19:14 <jophish> thank you
00:19:27 <koz_> jophish: I _assume_ you're after the monoid (*, 1)?
00:19:50 <jophish> nope, in fact I'm quite sure that one has a semigroup instance!!!
00:20:04 <dminuoso> What would the implementation be?
00:20:07 <koz_> OK, well, I'm unsure what instance you're expecting this one to have.
00:20:15 <jophish>  Pair a1 b1 <> Pair a2 b2 = Pair (a1 <> a2) (b1 <> b2)
00:20:26 <jle`> Pair x1 y1 <> Pair x2 y2 = Pair (x1 <> x2) (y1 <> y2)
00:20:31 <jle`> ah beat me to it
00:20:35 <koz_> Jinx!
00:20:37 <jophish> you typed it very fast!
00:21:07 <dminuoso> Probably forgotten then? Make a merge request .
00:21:12 <jle`> yeah, there should really be one
00:21:31 <dminuoso>  (MonadZip f, MonadZip g) => MonadZip (Product f g)
00:21:54 <jle`> i think there is the approriate Alt instance
00:21:55 * koz_ wishes it was ApplicativeZip
00:22:18 <dminuoso> Together with ApplicativeComprehensions?
00:22:53 <koz_> dminuoso: This.
00:23:33 <jle`> jophish: if it matches the specific behavior you want, you can try using Ap as a wrapper
00:23:58 <dminuoso> koz_: To be fair, I recently started longing for caseS
00:24:08 <dminuoso> Which I think fits in that hole
00:24:14 <koz_> caseS?
00:24:26 <dminuoso> selective case-of
00:24:35 <koz_> dminuoso: I don't follow, sorry.
00:24:51 <dminuoso> koz_: a selective functor equivalent for do-notation
00:25:50 <koz_> Wait, that's a thing?
00:25:54 <dminuoso> No
00:25:56 <dminuoso> branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c 
00:26:11 <dminuoso> So sort of cross between `branch` and `case-of`
00:26:51 <dminuoso> https://gist.github.com/dminuoso/7acab978112cc0f0a7f0288bd87d3378 you can write this currently
00:27:19 <koz_> Huh, interesting.
00:27:58 <dminuoso> But it only works for a+b and its hard to composable
00:28:41 <koz_> How would you generalize that beyond Either though?
00:28:47 <koz_> I don't think you can really.
00:29:42 <dminuoso> I think you could write a version of `branch` that works with generics
00:30:09 <dminuoso> over arbitrary sum types
00:30:42 <koz_> gbranch
00:32:45 <jophish> jle`: you think I'm made of Applicative instances?!
00:33:51 <n0042> =$ 
00:34:43 <koz_> jophish: I sure am.
00:37:28 <jophish> :D
00:44:23 * hackage typson-esqueleto 0.1.0.0 - Typson Esqueleto Integration  https://hackage.haskell.org/package/typson-esqueleto-0.1.0.0 (aaronallen8455)
01:11:29 <bifunc2> What are some popular ways to create fixed-length containers, where the length is fixed in the type?
01:12:29 <dminuoso> There really aren't any.
01:12:33 <[exa]> bifunc2: like this? https://hackage.haskell.org/package/fixed-vector
01:12:55 <dminuoso> (By that I mean they aren't very popular)
01:13:05 <[exa]> yeah that's very true
01:13:16 <bifunc2> why are they not popular?
01:13:35 <bifunc2> btw is this related to dependent types? i heard dependent types are not yet in haskell, at all
01:13:37 <[exa]> once you get the sizes into the typesystem, everyone starts to demand more "smart" operations from it, and you end up requiring dependent types
01:13:40 <dminuoso> This takes you straight into dependent typing
01:13:40 <[exa]> which is hard
01:14:50 <bifunc2> ok maybe it's best for now to assert equal lengths at runtime
01:15:56 <[exa]> bifunc2: making runtime fail as soon as possible on detected error usually gives a good assurance that the handling is right, esp. if you have at least a single automated integration test
01:18:00 <[exa]> the other approach is to write the code so that the error is not representable, e.g. make a tiny layer that always handles the sizes rightâ„¢ and build upon it
01:50:34 <merijn> dminuoso: Yes there are, sized Vector :)
01:50:53 <merijn> https://hackage.haskell.org/package/vector-sized is pretty great
01:53:14 <dminuoso> https://packdeps.haskellers.com/reverse/vector-sized
01:53:16 <dminuoso> yes, very popular.
01:58:15 <dminuoso> Also, vector-sized has a very defty dependency footprint
01:58:21 <dminuoso> Since it pulls in adjunctions
01:59:28 <dminuoso> And that gives you half the kmettiverse 
01:59:51 <dminuoso> Anyway. They asked for "popular" not "great"
02:01:48 <merijn> dminuoso: packdeps only lists stuff on hackage, though
02:01:56 <merijn> I use it in a bunch of code that's not on hackage
02:02:55 <dminuoso> Sure, but it's not like there's gonna be incredible widespread usage of a package everywhere except hackage
02:03:09 <dminuoso> Think it's a good indicator to answer "popularity"
02:39:52 * hackage hspec-slow 0.2.0.1 - Find slow test cases  https://hackage.haskell.org/package/hspec-slow-0.2.0.1 (Jappie)
03:03:52 <boxscape> Hm, the `data X = forall a . MkX (Y a)` encoding is usually preferred for existentials over the `forall r . (forall a . Y a -> r) -> r` encoding, right? I'm asking because I just wrote something fairly simple where the first one seems more verbose, but I guess maybe it becomes easier to keep track of things with the first encoding as your what
03:03:52 <boxscape> you're doing gets more complex?
03:12:07 <merijn> boxscape: I usually prefer writing existentials as GADTs, because it looks cleaner
03:12:40 <boxscape> merijn so that would be effectively the same as the first encoding but with GADT syntax?
03:18:53 * hackage phonetic-languages-constraints 0.4.0.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constraints-0.4.0.0 (OleksandrZhabenko)
03:19:53 * hackage postgresql-binary 0.12.3.2 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.12.3.2 (NikitaVolkov)
03:20:44 <tomsmeding> boxscape: you can convert the existentials method to the CPS method, but not the other way round
03:21:12 <tomsmeding> that is to say: given a function that returns an existential with the X method, you can use it in a context that uses the Y method for existentials
03:21:23 * hackage postgresql-binary 0.12.3.3 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.12.3.3 (NikitaVolkov)
03:21:34 <tomsmeding> but if you have a function in CPS form using Y, then you can't use it in a function that wants to return an X-style existential
03:21:41 <tomsmeding> at least, that's my experience :p
03:21:51 <tomsmeding> which makes me prefer X, despite its additional verbosity
03:22:06 <boxscape> hm, I see, interesting
03:22:15 <dminuoso> I guess CPS style fuses better?
03:23:01 <dminuoso> Also it's a little less annoying if you pass things around, since you dont need to constantly wrap/rewrap your thing
03:23:51 <boxscape> yeah, that makes sense
03:26:29 <dminuoso> 12:21:12     tomsmeding | but if you have a function in CPS form using Y, then you can't use it in a function that wants to return an X-style existential
03:26:32 <dminuoso> Can you elaborate?
03:27:23 <tomsmeding> I haven't proven anything, just what I empirically found
03:27:27 <dminuoso> If you have `f :: forall r. (forall a . Y a -> r) -> r; then you can just do `f MkX` to get back into the X representation
03:27:29 <dminuoso> No?
03:27:36 <tomsmeding> wait
03:27:50 <tomsmeding> I'm dumb
03:27:51 <tomsmeding> yes
03:28:13 <tomsmeding> thank you
03:28:18 <boxscape> oh yeah that does work
03:39:39 <bifunc2> [exa] vector-sized library seems to be working like magic
03:39:55 <bifunc2> so if all i need are fixed length vectors, this seems like the library to use
03:40:00 <bifunc2> seems quite popular too
03:40:25 <bifunc2> i no longer see a reason to use normal vector and do runtime asserts
03:41:00 <dminuoso> "quite popular" according to which metric?
03:41:10 <dminuoso> Anyway, popularity is not necessarily an indicator of quality
03:41:19 <dminuoso> An unpopular library can be of high quality, and popular libraries can be of low quality
03:41:25 <maerwald> 14k downloads 
03:41:36 <dminuoso> That can easily mean it's a transitive dependency of some popular package
03:41:44 <maerwald> yes, that means the lib is popular
03:41:53 <dminuoso> Depends on how you look at it
03:42:20 <maerwald> it isn't all that complicated
03:42:23 <dminuoso> If a single popular package has vector-sized as a *transitive* dependency, is vector-sized popular?
03:42:26 <dminuoso> hard to say
03:42:48 <dminuoso> Id say popularity means a lot of people use your package as a direct dependency
03:42:49 <dminuoso> not transitive
03:43:08 <kindaro> Is there a file in `~/.cabal` that contains the list of all versions of all installed packages?
03:43:26 <dminuoso> Most people dont use ghc-prim, but everyone has it in their dependency tree. Is it a popular library?
03:43:28 <kindaro> Or, should I say, stored packages.
03:44:05 <maerwald> dminuoso: 14k downloads is a pretty good indicator of popularity. If you think it isn't, you should probably bring up proof :)
03:44:34 <dminuoso> maerwald: https://packdeps.haskellers.com/reverse/vector-sized
03:44:49 <maerwald> packdeps isn't exhaustive
03:44:50 <dminuoso> 14 packages on hackage depend on it
03:44:52 <dminuoso> out of tha
03:44:54 <dminuoso> I only recognize 1.
03:45:01 <dminuoso> On the entire of hackage, only one package I recognize depends on it.
03:45:12 <dminuoso> That in my book makes it a very unpopular library
03:45:29 <dminuoso> Of course its not exhaustive, its an indicator.
03:45:35 <dminuoso> But one that better represents popularity
03:46:24 <maerwald> servant-client just has 100 reverse deps, the other 10k it doesn't show :D
03:46:36 <maerwald> downloads are much more reliable metric
03:46:43 <dminuoso> Hard to say
03:46:48 <bifunc2> i don't have any great definition of this, my friend :) i just looked  at https://hackage.haskell.org/package/vector-sized-1.4.2 and saw 100 d/ls in last 30 days. more than most libraries :P
03:46:55 <bifunc2> s/this/popular
03:47:03 <[exa]> bifunc2: that may be automated downloads :D
03:47:26 <[exa]> one of my R libs has 400 installs per month but I'm fairly sure it has precisely 10 users.
03:47:33 <maerwald> [exa]: that even out for all of hackage (automated downloads)
03:47:44 <maerwald> so it's not a particularly strong argument
03:47:45 <boxscape> hm looks like vector-sized uses CPS-style existentials
03:48:01 <dminuoso> 12:46:02       maerwald | servant-client just has 100 reverse deps, the other 10k it doesn't show :D
03:48:05 <kindaro> How can I list all packages and versions available in Cabal store?
03:48:13 <dminuoso> maerwald: I guess the difference is servant-client is very likley to have users who do not share their product on hackage
03:48:26 <maerwald> why is that a *difference*?
03:48:40 <dminuoso> a container library can be reasonably expected to be used by other liraries
03:48:59 <dminuoso> its not just executables that need vectors
03:49:13 <dminuoso> kindaro: find.
03:49:40 <[exa]> maerwald: yeah just wanted to point out that the number may be biased
03:49:40 <maerwald> dminuoso: servant-client is not an executable :D
03:49:50 <dminuoso> maerwald: No, but it likely is used by executables
03:50:03 <dminuoso> There's relatively little API wrappers on hackage
03:50:15 <maerwald> dminuoso: look at the reverse deps and you'll see lots of libraries :)
03:50:37 <maerwald> so this seems more like an assumption rather than an observation
03:50:42 <dminuoso> You just switched your argument
03:50:49 <dminuoso> maerwald: Your point was "servant-client just has 100 reverse deps, the other 10k it doesn't show"
03:51:10 <maerwald> yes, I didn't make any assumptions of what the users are
03:51:33 * dminuoso is too tired for this
03:52:52 <maerwald> (and I wrote a library that uses servant-client as a library)
04:05:56 <hc> i can confirm that it is ;p
04:06:09 <hc> nvm, wrong channel
04:07:18 <Uniaika> :O
04:09:44 <ski> boxscape : if you just want to pass it on to the caller, which is likely to unwrap, then the CPS encoding is probably better. if you want to store it in some data structure, then the "existential data constructor" encoding is probably better 
04:10:37 <boxscape> I see
04:10:39 <boxscape> thanks
04:19:13 <dminuoso> And, given that you can convert freely between them, nothing stops you from just switching between the representations
04:19:57 <boxscape> right, that makes sense
04:23:08 <dminuoso> Question, does anyone else favor case-of over maybe? I find myself never favoring `maybe`
04:23:22 <dminuoso> (Or fromMaybe)
04:26:12 <boxscape> depends on how complex the expressions are; something simple like `maybe False (>0)` I wouldn't write with case-of, typically
04:27:33 <maerwald> dminuoso: I also prefer case of
04:27:47 <maerwald> maybe and friends are for cases where I know ahead of time what I'm gonna type
04:28:20 <dminuoso> What do you mean by "where I know ahead of time what I'm gonna type"?
04:28:57 <maerwald> Usually I don't know what I'm doing, is what I'm saying. So I pattern match on something and then switch stuff back and forth. That's more "linear" than doing complicated expressions
04:30:26 <maerwald> that's also the reasons I prefer lambdas as argument to fmap etc instead of writing pointfree function arguments
04:31:35 <n0042> lambdas are nice
04:32:18 <maerwald> n0042: I had a tech challenge where they told me they don't like it, because I'm not using pointfree style enough and that wouldn't be "senior haskell"
04:32:23 <maerwald> dodged a bullet :D
04:32:31 <boxscape> oh no
04:33:00 <opqdonut> :D
04:33:17 <boxscape> @pl \d ogde a bullet -> a bullet d odge d
04:33:17 <lambdabot> const . (flip =<< (flip .) . flip flip odge . (flip .) . flip flip)
04:33:48 <maerwald> right, run your code through that before handing in your tech challenge :D
04:35:01 <boxscape> In my company we only accept challenges written in umlambda
04:35:20 <opqdonut> boxscape: :D
04:35:20 <boxscape> erm
04:35:21 <boxscape> unlambda
04:38:39 <dminuoso> maerwald: Next time just introduce a random `fix . const` in the challenge.
04:38:52 <maerwald> omg, such senior
04:38:56 <dminuoso> ;)
04:40:03 <dminuoso> Obligatory https://aphyr.com/posts/342-typing-the-technical-interview
04:40:14 <boxscape> was just thinking of that
04:40:58 <maerwald> that post made some ppl believe haskell is dynamically typed (I'm not joking)
04:41:24 <boxscape> oh no
04:43:23 * hackage deferred-folds 0.9.13 - Abstractions over deferred folds  https://hackage.haskell.org/package/deferred-folds-0.9.13 (NikitaVolkov)
04:44:40 <n0042> That is a pretty funny page lol
05:07:22 <maerwald> is there an easy way to figure out if a given function *actually* makes use of constraints other than satisfying types?
05:07:42 <maerwald> (like: calling a class function)
05:08:05 <maerwald> (which then could warrant a redesign of the types/constraints)
05:14:23 * hackage headroom 0.3.2.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.3.2.0 (xwinus)
06:01:27 <dminuoso> maerwald: Mmm, it shoulds like a diagnostic that fits into GHC
06:01:29 <dminuoso> *sounds
06:01:44 <dminuoso> Some sort of warn-unused-constraints
06:02:18 <dminuoso> I dont know the implementation details of the type checker, it doesn't seem impossible in principle to track which constraints you used to discharge other obligations
06:10:52 * hackage deferred-folds 0.9.14 - Abstractions over deferred folds  https://hackage.haskell.org/package/deferred-folds-0.9.14 (NikitaVolkov)
06:13:22 * hackage lsp 1.0.0.1 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/lsp-1.0.0.1 (luke_)
06:22:07 <dminuoso> maerwald: Anyway, interesting. If I dont case-of, I usually have some `note` function instead.
06:22:47 <dminuoso> Or I move it into pattern matching on separate functions, where I might have `fooEither (Left ...) = ...; fooEither (Right ...) = ...'` and use that as a continuation
06:23:00 <dminuoso> But either/maybe seems just strange to me for some reason I cant explain
06:23:21 <boxscape> do you use foldr?
06:24:19 <dminuoso> sure
06:24:24 <boxscape> hm
06:25:06 <boxscape> So an aversion to Church encodings of non-recursive types but not to those of recursive types, to overly extrapolate
06:25:18 <dminuoso> Yes, very much.
06:27:37 <dminuoso> The non-recursive types encode a choice, list does not
06:27:57 <dminuoso> Or I guess that depends on the perspective
06:28:32 <dminuoso> since a list could be `n + (n^2) + (n^3) + (n^4) + ....`  
06:28:59 <dminuoso> Maybe it's just that to me it's not clear which side of `maybe` does what
06:29:14 <dminuoso> Perhaps I also just lack the intuition because I dont use it
06:29:21 <c_wraith> doesn't the type tell you?
06:29:30 <maerwald> dminuoso: if I convert a maybe to some other type (e.g. Either), I find maybe to be quite idiomatic... but I can't stand fromMaybe
06:29:33 <c_wraith> :t maybe
06:29:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:29:53 <c_wraith> there's only one case either of those arguments can apply in.
06:30:11 <dminuoso> c_wraith: Sure, but when you look at `maybe foo bar h`, then it's just not obvious to me
06:30:19 <c_wraith> Now, I understand that complaint about bool....
06:30:27 <dminuoso> Mmm
06:30:47 <maerwald> I always mix up second and third parameter of foldr/foldl :p
06:30:53 <hpc> dminuoso: there's a way to remember it as a specific instance of a more general thing
06:31:00 <hpc> data Maybe a = Nothing | Just a
06:31:08 <hpc> the parameters for maybe go in the same order as the data definition
06:31:15 <dminuoso> hpc: Sure, the first constructor comes first. But that requires memorizing the data definition
06:31:16 <hpc> same for foldr, they go in the same order
06:31:33 <hpc> dminuoso: the smallest constructor is first
06:31:52 <hpc> (for deriving Ord and such)
06:31:55 <dminuoso> hpc: so what about These?
06:32:02 <dminuoso> What type signature would `these` have?
06:32:39 <dminuoso> these :: (a -> d) -> (b -> d) -> (a -> b -> d) -> These a b -> d
06:32:40 <c_wraith> intuition says: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c
06:32:44 <dminuoso> these :: (b -> d) -> (a -> d) -> (a -> b -> d) -> These a b -> d
06:33:03 <dminuoso> According to your definition, Id have to look up the definition of These, and I couldnt infer it from the size
06:33:04 <maerwald> easy: this, that, these
06:33:06 <maerwald> xD
06:33:46 <hpc> it derives Ord so you can check in ghci
06:34:06 <dminuoso> Well if I have to look it up, I might as well just check hoogle
06:34:09 <boxscape> % :i These
06:34:09 <yahb> boxscape: ; <interactive>:1:1: error: Not in scope: `These'
06:34:14 <boxscape> :/
06:34:22 <dminuoso> % import Data.Strict.These
06:34:23 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Data.Strict.These'; It is not a module in the current program, or in any known package.
06:34:30 <dminuoso> % import Data.Functor.These
06:34:30 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Data.Functor.These'; Perhaps you meant; Data.Functor.Base (from recursion-schemes-5.1.3); Data.Functor.Const (from base-4.14.0.0); Data.Functor.Plus (from semigroupoids-5.3.4)
06:35:05 <dminuoso> hpc: I get your point, Im not saying its not discoverable, Im just suggesting that from just staring at its usage, it might not be obvious
06:35:11 <hpc> sometimes
06:35:16 <dminuoso> But arguably the same could be said about `foldr`
06:35:23 <c_wraith> and every function
06:35:23 <hpc> but then for example, how would you write a fold over a tree?
06:35:30 <dminuoso> hpc: easy! foldMap!
06:35:34 <dminuoso> ;)
06:35:37 <hpc> heh
06:37:01 <hpc> but yeah, if you know the structure it's pretty easy, foldTree leaf branch Leaf = leaf; foldTree leaf branch (Branch value left right) = branch value (foldTree left) (foldTree right)
06:37:19 <hpc> or something similar depending on what type of tree you're dealing with
06:39:13 <hpc> i wonder if there's anything that writes these functions automatically
06:40:34 <c_wraith> recursion-schemes?
06:40:48 <merijn> c_wraith: That's not automatic
06:40:54 <c_wraith> it has TH
06:40:56 <merijn> That's just "reusing handwritten ones"
06:41:28 <c_wraith> every library is reusing something someone wrote by hand...
06:42:42 <merijn> c_wraith: Right, but I meant as opposed to DeriveFunctor. I guess TH counts, but I didn't know recursion-schemes had that, because my brain doesn't like recursion schemes :p
06:43:18 <c_wraith> And I don't like using TH. :P
06:43:23 * dminuoso likes TH
06:43:38 <c_wraith> I like *writing* it.  But I don't like writing code that uses it.
06:43:47 <merijn> I like TH, but they fucked up the specification
06:43:53 <dminuoso> There is a specification?
06:43:56 <dminuoso> :>
06:44:02 <merijn> dminuoso: My point
06:44:25 <dminuoso> My main annoyance with TH is just one: staging restriction
06:44:29 <merijn> TH should've had a clear "target" and "host" distinction for everything
06:44:31 <hpc> hmm, that technically writes it but by way of free shennanigans
06:44:43 <dminuoso> Having to fiddle with extra modules just to satisfy the staging restriction is sometimes frustrating
06:44:59 <dminuoso> Especially because we cant have circular module references
06:45:01 <merijn> dminuoso: Staging is annoying, but you can workaround it
06:45:19 <hpc> like if i was using [] and had to pick between foldr and whatever recursion-schemes gives me, recursion-schemes would be harder to use
06:45:29 <merijn> dminuoso: In contrast to the lack of distinction between target/host which makes cross-compiled TH fundamentally impossible
06:45:41 <dminuoso> merijn: cross compiling is not something I care about
06:45:49 <merijn> (well, the Asterius guys seem to be attempting to fix/work around it via heroic amounts of work)
06:45:51 <hpc> i just want to write data Foo ..., makeFold 'Foo, and get foo :: whatever -> Foo ... -> ...
06:45:56 <merijn> dminuoso: Not *yet*
06:46:06 <dminuoso> Perhaps
06:46:16 <merijn> dminuoso: Compiling windows executables from linux/etc. would've been nice :p
06:46:20 <dminuoso> Is that some reference to the dominion of ARM processors?
06:46:22 <dminuoso> Oh
06:46:27 <merijn> dminuoso: ARM too
06:46:54 <merijn> dminuoso: Everything is just slightly more inconvenient without cross-compilation
06:47:27 <merijn> And proper cross-compilation support isn't even that hard. It's just a herculean task to retrofit cross-compilation support if you didn't engineer it in from the beginning
07:04:23 * hackage migrant-core 0.1.0.1 - Semi-automatic database schema migrations  https://hackage.haskell.org/package/migrant-core-0.1.0.1 (TobiasDammers)
07:06:53 * hackage migrant-core 0.1.0.2 - Semi-automatic database schema migrations  https://hackage.haskell.org/package/migrant-core-0.1.0.2 (TobiasDammers)
07:07:54 * hackage migrant-sqlite-simple 0.1.0.2, migrant-postgresql-simple 0.1.0.2, migrant-hdbc 0.1.0.2 (TobiasDammers)
07:08:03 <avdb> Does ghc-mod still work in 2020?
07:08:11 <avdb> I can't install it: https://dpaste.com/4D4N4GM7X
07:09:51 <merijn> No
07:10:01 <merijn> Development stopped, like, 2+ years ago
07:10:09 <merijn> And the repo says it's deprecated as user tool
07:10:16 <merijn> You want ghcide/haskell-language-server
07:11:27 <avdb> Lol I found a 2020 blog post suggesting the usage of ghc-mod. Embarrassing.
07:14:06 <merijn> heh
07:14:08 <merijn> Where?
07:14:53 <merijn> avdb: See the note here: https://github.com/DanielG/ghc-mod#legacy
07:15:35 <avdb> haskell-ide-engine has been archived as well -_-
07:15:41 <avdb> Industry moves too fast
07:15:51 <merijn> avdb: haskell-ide-engine merged with ghcide
07:16:05 <merijn> avdb: haskell-language-server is basically the continuation of hie
07:16:50 <merijn> avdb: It's moving fast as of this year due to all the tooling projects finally converging on a single collaboration with actual people paid to work on it :p
07:17:20 <merijn> Instead of being 10 independent, unmaintained personal hacks :p
07:18:28 <avdb> True
07:18:58 <avdb> Would you recommend hlint or ale?
07:19:14 <avdb> Can't really choose, ale got a lot of forks is all I know
07:20:24 <merijn> How are hlint and ale alternatives?
07:20:40 <maerwald> ale *uses* hlint
07:21:07 <maerwald> https://github.com/dense-analysis/ale/blob/master/ale_linters/haskell/hlint.vim
07:21:27 <merijn> ALE is a plugin for asynchronously running linters/LSP servers, it doesn't actually "do" anything
07:22:10 <avdb> Oh oops
07:22:19 <avdb> Do I still need the LSP if I use ale?
07:22:51 <maerwald> good luck with LSP clients in vim
07:22:59 <maerwald> I tried all and then I disabled it
07:23:12 <maerwald> It makes my productivity worse
07:23:34 <maerwald> Maybe other editors have a better experience, I don't know
07:23:46 <merijn> maerwald: ALE *is* an LSP client
07:23:49 <maerwald> yes
07:23:58 <merijn> avdb: ALE is working fine for me, tbh
07:24:22 * hackage phonetic-languages-simplified-properties-lists 0.1.2.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-simplified-properties-lists-0.1.2.0 (OleksandrZhabenko)
07:27:25 <dminuoso> Is there a newtype wrapper for reverse Ord?
07:28:02 <dminuoso> I just want to do something like `sortOn (Reverse . fst)`
07:28:14 <geekosaur> Down?
07:28:32 <dminuoso> geekosaur: Ah cheers!
07:39:29 <texasmynsted> Morning
07:49:11 <n0042> Morning to you as well
07:49:16 <n0042> Happy thanksgiving!
07:53:18 <maerwald> :t Down
07:53:20 <lambdabot> a -> Down a
07:53:40 <maerwald> :t Up
07:53:42 <lambdabot> error:
07:53:42 <lambdabot>     â€¢ Data constructor not in scope: Up
07:53:42 <lambdabot>     â€¢ Perhaps you meant one of these:
07:54:04 <maerwald> only going down, how depressing
07:55:28 <dminuoso> Would it help if Down was renamed to Depress?
07:55:51 <hc> lol
08:21:00 <zfnmxt> I'm having some trouble with type families and ambiguous variables during type inference: https://www.pastery.net/gfxvnp/
08:22:03 <zfnmxt> I don't know how to constraint things further so that b0 can be resolved.
08:22:23 * hackage phonetic-languages-simplified-properties-lists 0.1.3.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-simplified-properties-lists-0.1.3.0 (OleksandrZhabenko)
08:22:25 <zfnmxt> s/constraint/constrain
08:25:31 <boxscape> zfnmxt have you tried supplying b to left with -XTypeApplications?
08:39:55 <zfnmxt> boxscape: Did you mean something like this? https://www.pastery.net/gfxvnp+sjqkje/#sjqkje
08:40:23 * hackage reflex-dom-retractable 0.1.7.0 - Routing and retractable back button for reflex-dom  https://hackage.haskell.org/package/reflex-dom-retractable-0.1.7.0 (NCrashed)
08:43:23 * hackage reflex-localize 1.0.1.0 - Localization library for reflex  https://hackage.haskell.org/package/reflex-localize-1.0.1.0 (NCrashed)
08:43:54 <boxscape> zfnmxt is Func a type family?
08:44:21 <boxscape> or a type?
08:45:57 <zfnmxt> boxscape: It's a GADT: https://github.com/aleatory-science/frechet-dsl/blob/c7185e3aa1894e2cf3f45be4ee7506b5ad695a7d/src/Frechet/Ast.hs#L15
08:46:30 <boxscape> zfnmxt is that a private repository? I'm getting a 404
08:47:25 <zfnmxt> Ah, crap. Forgot about that. Here's the relevant line: https://www.pastery.net/gfxvnp+sjqkje+xwaqdc/#xwaqdc
08:49:23 * hackage reflex-localize 1.0.2.0 - Localization library for reflex  https://hackage.haskell.org/package/reflex-localize-1.0.2.0 (NCrashed)
08:52:58 <boxscape> zfnmxt so I think the problem right now is that it doesn't know that n is 0, because of how you're matching on the fromSing call. Let me see if I can remember how to do that better...
08:53:45 <zfnmxt> boxscape: I suspected that might be a problem (and I remain confused about `Nat` in general--why aren't there `SZero` and `SS` constructors to match on?)
08:54:04 <boxscape> zfnmxt yeah I tend to avoid the built-in Nats for that reason
08:54:29 <zfnmxt> Is there a reason the built-ins don't export (or...lack?) the constructors?
08:55:16 <boxscape> zfnmxt I believe they're built to be efficient, e.g., if you have 1000 :: Nat, you don't want to carry around 1000 constructors if you don't need them
08:55:40 <boxscape> zfnmxt it might be worth switching to a library that provides Z/S nats though for this, or rolling your own
08:56:19 <boxscape> with that I believe you could just do `case n of SZ -> left`
08:56:35 <zfnmxt> boxscape: I'll try!
08:57:26 <boxscape> (zfnmxt: this for example, which has singletons integration https://hackage.haskell.org/package/singleton-nats-0.4.5/docs/Data-Nat.html)
09:02:46 <zfnmxt> boxscape: That fixed it :)
09:02:52 <boxscape> nice
09:03:07 <zfnmxt> Thanks a lot for the help!
09:03:13 <boxscape> np
09:19:22 <zfnmxt> boxscape: Unfortunately, I spoke too soon. It only works for the `n = SS SZ` case (I changed it so that `nth` is 1-indexed) if you type `nth` as `nth :: forall n x xs. Sing n -> HList (x ': xs) -> Lookup (x ': xs) n` (and it doesn't work for any case with a larger n). So it seems like the explicit `x ': xs` type pattern is what enabled the inference.
09:19:34 <zfnmxt> https://www.pastery.net/gfxvnp+sjqkje+xwaqdc+rzupwz/#rzupwz
09:25:42 <boxscape> zfnmxt try `left @_ @(S Z)`? probably won't fix it but might give you a better error message
09:28:33 <zfnmxt> boxscape: That doesn't type, does it?
09:28:49 <boxscape> zfnmxt hm, it's possible I confused something
09:29:31 <boxscape> oh, yeah, I think I did
09:29:47 <zfnmxt> left only takes `a :: Type` and `b :: Type`
09:30:10 <boxscape> right, hm
09:30:17 <zfnmxt> (Maybe I should've said it doesn't kind :P)
09:30:32 <boxscape> same thing since ghc 8.0 :)
09:31:47 <zfnmxt> There's no way to have GHC print out the constraints it has generated so far during type inference or something, right?
09:32:01 <zfnmxt> I just want to see what's going on; it's all so opaque :(
09:32:01 <ski> i think you need to match on `xs'
09:32:40 <boxscape> zfnmxt if you use typed holes (i.e. replace left with _) it will show you the constraints it has in context at that point
09:33:11 <boxscape> not sure if that's quite what you're asking for but it might be
09:33:13 <ski> `Sing n' allows you to match on `n'. i think you also need something to match on `xs'
09:33:50 <zfnmxt> ski: That worked!
09:34:40 <zfnmxt> boxscape: That's a nice trick too.
09:35:24 <ski> what worked ?
09:35:46 <zfnmxt> ski: Matching on xs. At least for the `(SS SZ)` case.
09:35:59 <ski> how did you match on it ?
09:37:10 <zfnmxt> https://www.pastery.net/gfxvnp+sjqkje+xwaqdc+rzupwz+hwbecb/#hwbecb
09:37:14 <ezzieyguywuf> can I use something like runExceptT here to simplify this code, and/or avoid the nested case statements? https://dpaste.com/4WBWJH8WA
09:37:16 <ski> (also, where's `Sing' (and `fromSing') from / how's it defined ?)
09:37:29 <avdb> https://dpaste.com/9D4WFUTP5
09:37:32 <avdb> Help please?
09:37:53 <avdb> Can't install these programs with cabal.
09:37:55 <zfnmxt> ski: Data.Singletons; that's a whole bag of worms there though.
09:41:25 <merijn> ezzieyguywuf: "yes"
09:41:51 <merijn> avdb: hdevtools has been dead since 2016
09:41:59 <merijn> Actually, longer
09:42:10 <merijn> But 2016 is about the last time my personal fork of it worked
09:42:12 <zfnmxt> ski: And again that only worked for the `(SS SZ)` case :'(
09:42:54 <ezzieyguywuf> merijn: even though the two "Left"s have different types?
09:43:04 <merijn> ezzieyguywuf: oh, I hadn't seen that
09:43:15 <ezzieyguywuf> merijn: so I guess in that case no?
09:43:27 <merijn> ezzieyguywuf: Easily solved by mapping them to the same type first ;)
09:44:13 <ezzieyguywuf> merijn: lol, fair enough.
09:44:26 <merijn> :t Data.Bifunctor.first
09:44:27 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
09:44:56 <ezzieyguywuf> ?_?
09:45:19 <merijn> Either is a Bifunctor :p
09:45:35 <merijn> > :t first isDigit
09:45:38 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input â€˜:â€™
09:45:43 <merijn> :t first isDigit
09:45:45 <lambdabot> (Char, d) -> (Bool, d)
09:45:52 <merijn> oh, wrong first
09:46:00 <merijn> :t Data.Bifunctor.first isDigit
09:46:01 <lambdabot> Bifunctor p => p Char c -> p Bool c
09:46:12 <merijn> :t Data.Bifunctor.first isDigit (Right True)
09:46:13 <lambdabot> Either Bool Bool
09:48:30 <avdb> merijn: Another outdated package
09:49:13 <geekosaur> stuff dependent on ghc internals goes stale quickly
09:50:11 <merijn> Like I said, the only editor tooling that's still relevant is ghcide and haskell-language-server
09:50:19 <merijn> You can assume everything else is dead
09:51:02 <ski> ezzieyguywuf : you'll likely need to unify the exception types. something like
09:51:33 <ski>   runProgram (FileName fname) = (either TextIO.putStrLn return =<<) . runExcept $ do
09:51:59 <ski>     csvLines <- ExceptT (either pack id <$> parseCSVFromFile (unpack fname))
09:52:52 <ski>     csvData <- ExceptT (processRawCSV ((fmap . fmap) pack csvLines))
09:53:06 <ski>     lift (processCSV csvData)
09:54:27 <ezzieyguywuf> ski: merijn: thanks to you both, this has been helpful
09:54:35 <gehmehgeh> I've read the docs and I've been googling a bit, so please bear with me if this question has been asked before: how do you pass ghc options to *just* your own code (not the installed libs) with cabal? I'd like to do some profiling, but when I pass those options with "--ghc-options" it affects _every_ package
09:55:01 <merijn> gehmehgeh: You can specify them in the cabal file?
09:55:07 <gehmehgeh> how? where?
09:55:14 <merijn> gehmehgeh: ghc-options field? ;)
09:55:15 <gehmehgeh> "ghc-options" it says isn't a recognized option
09:55:18 <gehmehgeh> no
09:55:51 <merijn> gehmehgeh: https://github.com/merijn/paramtree/blob/master/paramtree.cabal#L33
09:56:12 <merijn> (capitalisation there shouldn't matter, that's just a personal quirk)
09:56:32 <monochrom> gHc-optionS:
09:57:23 <gehmehgeh> cabal is still claiming "Build profile: -w ghc-8.10.2 -O1"
09:57:30 <gehmehgeh> when I put a "ghc-options" line there
09:57:31 <monochrom> When I was learning this back then, I spent an afternoon reading the relevant chapter in the cabal user's guide from top to bottom.
09:57:51 <merijn> gehmehgeh: So?
09:58:00 <gehmehgeh> Shouldn't it reflect my changes?
09:58:02 <merijn> gehmehgeh: build-profile isn't a specification of options
09:58:07 <gehmehgeh> Saying "-O2" instead of..
09:58:16 <gehmehgeh> Well, that is counterintuitive
09:58:29 <gehmehgeh> Because you can pass "-O2" directly to cabal and will reflect that
09:58:38 <merijn> Build profile is, presumably reflecting whether you set "optimisation: 2" in ~/.cabal/config
09:58:48 <ski> ezzieyguywuf : any luck ?
09:58:59 <gehmehgeh> I actually put -O2 in ~/.cabal/config :D
09:59:15 <monochrom> For -O2, with only a few exceptions, you shouldn't set in *.cabal at all.
09:59:19 <merijn> gehmehgeh: Doing that would involve parsing flags from ghc-options would involve cabal actually knowing all GHC options
09:59:40 <merijn> gehmehgeh: Also, setting -O2 on everything is great way too spend *a lot* of time waiting for compilation for very marginal gains
10:00:03 * ski . o O ( `SuppressUnusedWarnings ((<=?@#@$$) a6989586621679473158 :: TyFun Nat Bool -> Type)' )
10:00:05 <merijn> -O2 isn't recommended unless you *know* -O2 is significantly better than -O1
10:00:15 <gehmehgeh> ij
10:00:18 <gehmehgeh> ok
10:01:02 <gehmehgeh> You know what's a bit eerie? I also tried putting "-Werror=incomplete-patterns" there with the result that some dependencies won't build anymore...
10:01:26 <merijn> Well, sure
10:02:30 <merijn> Turns out that not every random dependency on the internet has the same engineering standards :p
10:03:05 <gehmehgeh> Still...
10:06:46 <gehmehgeh> monochrom, merijn: Thanks for the help :)
10:19:35 <avdb> Is there a Haskell function that does "f n [x] = [x,x,x, ... x]", basically returning a list of the original element multiplied with n?
10:19:41 <koz_> :t replicate
10:19:43 <lambdabot> Int -> a -> [a]
10:19:52 <koz_> > replicate 10 "foo"
10:19:54 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo"]
10:20:01 <avdb> Thanks!
10:20:23 <avdb> Been stuck on this problem for longer than a month lol
10:20:37 <yushyin> lol
10:20:41 <xerox_> @hoogle Int -> a -> [a]
10:20:42 <lambdabot> Prelude replicate :: Int -> a -> [a]
10:20:42 <lambdabot> Data.List replicate :: Int -> a -> [a]
10:20:42 <lambdabot> GHC.List replicate :: Int -> a -> [a]
10:20:52 <xerox_> if you can give your idea a type sometimes you can find them like that
10:21:02 <avdb> I didn't bother to try Hoogle yet, I'm still too much of a noob :P
10:21:46 <koz_> avdb: You can roll 'replicate' recursively without too much trouble.
10:25:05 <avdb> koz_: I know, I need to practice recursion a lot because I still suck at it!
10:25:47 <koz_> avdb: Basically, the trick is to treat it like a proof by induction. First, what's the simplest case you could ever see? Then, assuming you have a smaller answer, how do you get a bigger answer?
10:26:52 <avdb> I do indeed always handle  the base cases like x == 0 and x == 0, afterwards I start on the otherwise case
10:27:10 <koz_> So for 'replicate', what's your base case?
10:27:15 <avdb> Matching types is also a pain but that's where Haskell shines
10:27:23 <avdb> Wait I'll send you a paste of my program
10:28:39 <avdb> http://codepad.org/KHd73y9L
10:29:21 <avdb> koz_: Here you go, not sure if I should handle "arr == []" yet
10:30:09 <merijn> You should avoid using "== []" that won't work for lists that are missing an Eq instance
10:30:23 <koz_> Yeah, 'null' or pattern matching is what you want.
10:31:30 <avdb> Ah lol that's why the last element doesn't print I suppose
10:31:52 <avdb> merijn: I did but forgot to change it in my paste, ALE suggested it :)
10:32:44 <timCF> Hi guys! Often I do operate with some value of monadic type, for example `Either a b` but inside some other monad `m` for example `IO`. To apply a function to internal `b` value I often write constructions like `(foo <$>) <$> x`. Is there other better/simpler way?
10:33:09 <koz_> timCF: So you have IO (Either a b) as the type you're trying to work with?
10:33:17 <timCF> Yes
10:33:49 * tomsmeding would write `fmap foo <$> x`, but that's the same
10:34:06 <timCF> `(foo <$>) <$> x` works but looks ugly
10:34:18 <merijn> eh
10:34:23 <merijn> "fmap foo <$> x"? :p
10:34:34 <timCF> well, it's the same)
10:34:40 <tomsmeding> looks nicer
10:34:47 <ski> timCF : maybe `ExceptT a', depending ?
10:34:58 <timCF> I was looking for something like magic `<$$>` if it exists haha
10:35:09 <tomsmeding> % let <$$> = fmap . fmap
10:35:10 <yahb> tomsmeding: ; <interactive>:27:5: error: parse error on input `<$$>'
10:35:11 <ski>   (fmap . fmap) foo x
10:35:14 <tomsmeding> % let (<$$>) = fmap . fmap
10:35:14 <yahb> tomsmeding: 
10:35:23 <tomsmeding> % :t (<$$>)
10:35:23 <yahb> tomsmeding: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
10:35:57 <timCF> well, looks like it will work?
10:36:06 <tomsmeding> if it doesn't seem to exist, why not write it :)
10:36:33 <ski> timCF : are you often short-circuiting the `Left's ?
10:37:05 <timCF> what do you mean?
10:38:18 <ski> like `do x <- foo; case x of Left e -> return (Left e); Right v -> do y <- bar v; case y of Left e -> return (Left e); Right w -> ...'
10:41:11 <timCF> yeah, I recognize this pattern. Nowdays I'm trying to use `first` `second` and `bimap` to control flow, but often this external IO-like monad complicate things
10:41:56 <ski> if you find yourself doing that, then it sounds like `ExceptT' would be helpful
10:42:18 <ski> and then you could write `foo <$> ExceptT x'
10:43:35 <timCF> Oh, monad transformers :) I'm already writing Haskell code for a while but still not fully understand them, hahah
10:44:00 <tomsmeding> someone on reddit noticed that ghc's unused variable warnings seem to have inconsistent behavour regarding transitive propagation of unusedness: https://www.reddit.com/r/haskell/comments/k1dggw/surprising_unused_variable_warnings/
10:44:05 <tomsmeding> is this a known thing?
10:44:16 <timCF> But this particular case you desribed happens very often in real code, so maybe it will be easier to understand it for me) Thanks!
10:48:35 <ski> timCF : the related `MaybeT' is also useful in similar circumstances
11:06:53 * hackage data-as 0.0.0.2 - Simple extensible sum  https://hackage.haskell.org/package/data-as-0.0.0.2 (incertia)
11:12:11 <timCF> Thanks! I actually have one more noob question. I do often use phantom types to make source code stricter. For example `newtype MoneyAmount a = MoneyAmount Rational'. That's nice because now I can specify the kind of person who owns the money, for example `data Customer` and then `x :: MoneyAmount Customer'. Now I want to go futher and specify the kind of balance money represent `newtype MoneyAmount a b = 
11:12:17 <timCF> MoneyAmount Rational' and then `data Debit; data Credit' and then `x :: MoneyAmount Customer Debit'. That's cool, but I can swap types and it still will be valid term `x :: MoneyAmount Debit Customer' and I even can use just some random types there like `x :: MoneyAmount Int Int' which does not make any sense. I'm not sure how do I call the thing I want, but I kinda want some sort of Class restrictions for 
11:12:23 <timCF> types which can go to N-th position in phantom type. I do want something like this (pseudo code) `(OwnerType a, AccountType b) => newtype MoneyAmount a b = MoneyAmount Rational'. Is there the way to achieve something similar?
11:15:11 <hpc> data kinds, perhaps?
11:15:24 <monochrom> timCF: You can enable DataKinds, and maybe you also need KindSignatures. Then you can write: "data CD = Credit | Debit", "newtype M (a :: CD) = ...".  Now "M Credit" and "M Debit" are legal, "M Bool" is not.
11:17:29 <timCF> @monochrom hmmm, that's interesting, especially the meaning of `data CD = Credit | Debit` it looks like a type with 2 constructors, but it's definitely not what I do want. I want 2 types of CD class with 0 constructors
11:17:29 <lambdabot> Unknown command, try @list
11:18:08 <monochrom> That's the magic of DataKinds. You now also have a kind called CD, and it has two types, Credit and Debit.
11:18:57 <monochrom> And the type called Credit has no possible value, not even bottom, because its kind is CD not *
11:19:19 <timCF> monochrom: hmm, interesting. But how I do define normal types with constructors in case this extension is enabled?
11:19:33 <monochrom> You get both
11:20:05 <timCF> monochrom: by default it creates both type CD and kind CD?
11:20:09 <monochrom> Yeah
11:20:33 <avdb> Is there a way to just return
11:20:44 <ski> just return what ?
11:20:46 <avdb> Didn't mean to send that, stupid tmux
11:20:47 <monochrom> I don't like this because sometimes you don't want one of them. Also too many name clashes for humans. (Oh the computer has no problem.)
11:21:02 <monochrom> But it does the job. It just has side effects.
11:21:07 <avdb> It's hard when you confuse Ctrl+w for Vim with Ctrl+b for Tmux
11:21:12 <timCF> monochrom: so there is no way to have just kind?
11:21:17 <monochrom> No.
11:21:42 <monochrom> Just don't use the version you don't want. :)
11:22:05 <timCF> monochrom: ehhh.. But it's still much better that having blind phantom types `MoneyAmount a b`
11:22:23 <timCF> monochrom: thanks!
11:22:25 <monochrom> I think the GHC people did this to avoid creating an extra reserved word such as "kind".
11:22:36 <xerox_> what's the paper that explains this?
11:22:47 <tomsmeding> note that GHC wants you to write 'Credit and 'Debit on the type level, as opposed to Credit and Debit on the value level
11:23:06 <merijn> tomsmeding: Only when ambiguous
11:23:06 <monochrom> I don't know, but maybe the GHC user's guide has a citation.
11:23:43 <avdb> Is there a way to get the index of an element in a list comprehension?
11:24:01 <merijn> Zip it with an list of indices? :p
11:24:20 <avdb> I want [x | x <- lst] but without the odd indexes of lst
11:24:33 <tomsmeding> merijn: also if not ambiguous: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wunticked-promoted-constructors is enabled with -Wall
11:24:44 <merijn> tomsmeding: That's new
11:24:56 <merijn> Wonder when that got added
11:24:57 <tomsmeding> perhaps, but it's true now nevertheless :p
11:25:12 <tomsmeding> I believe we two actually talked about this before in this very channel :p
11:25:22 <monochrom> [x | (x,i) <- zip lst (cycle [True,False]), i]
11:25:55 <avdb> You mean [(x,y) | x <- lst, y <- index, mod (snd y) 2 == 0] ?
11:26:03 <monochrom> No. I mean what I wrote.
11:26:11 <monochrom> What you wrote provably does something else.
11:26:27 <tomsmeding> merijn: https://ircbrowse.tomsmeding.com/day/haskell/2020/11/07?id=111296&timestamp=1604764844#t1604764844
11:26:29 <avdb> monochrom: Thanks. Doing exercises to learn new built-in functions is much more useful than reading books for me.
11:26:42 <monochrom> Let's see what's so wrong:
11:26:59 <avdb> That was my own function. I was planning on creating tuples with the index as the second element.
11:27:07 <avdb> And just filtering the odd ones.
11:27:46 <monochrom> With a moment of thought, you don't need full natural numbers, you just need cycle [True,False]
11:28:26 <monochrom> GÃ¶del was damaging in teaching us to always work with natural numbers only.
11:28:37 <tomsmeding> did he?
11:28:38 <monochrom> Turing was damaging in teaching us to always work with strings only.
11:28:48 <ski> oh, there's an IRC Browse on the run again
11:29:13 <monochrom> Oh very strongly. Look up GÃ¶del numbering. An XY problem in avoiding even strings.
11:29:27 <monochrom> or generally arrays.
11:29:40 <tomsmeding> he certainly did cool tricks with natural numbers, but did he teach us to work with natural numbers only? I don't think so :)
11:29:42 <opqdonut> there are also the folklore functions "evens (x:xs) = x:odds xs; odds (_:xs) = evens xs"
11:30:14 <opqdonut> which are useful if you only need every second element (and don't need to generalize to e.g. every third)
11:30:18 <xerox_> the GHC manual did have a citation http://dreixel.net/research/pdf/ghp.pdf
11:30:19 <monochrom> Scott Aaronson had great fun mocking GÃ¶del numbering.
11:30:29 <merijn> ski: tomsmeding apparently wanted to do a bunch of work no one was feeling like, so we tricked him into running a copy now that Chris' is gone :p
11:30:51 <tomsmeding> it compiles on a recent ghc now too :)
11:31:46 <monochrom> Along the line of "I have a mathematician friend who is learning programming, he didn't learn arrays but he wanted to do arrays, so he thought up this great idea, represent [a,b,c] by 2^a 3^b 5^c. That's GÃ¶del numbering."
11:32:22 <xerox_> zipWith (^) primes 
11:32:26 <tomsmeding> obligatory mention of https://esolangs.org/wiki/Fractran
11:32:50 <opqdonut> gÃ¶del numbering predates pretty much all programming so we can forgive it for being a bit esoteric :P
11:33:05 <opqdonut> I think I've seen a version of gÃ¶del's proof that uses a more modern encoding
11:33:40 <xerox_> did they use capt'n'proto or protocol buffers
11:33:41 <monochrom> Well OK, you are right that maybe he didn't intend to teach us to use natural numbers only. But the empirical effect is he ended up achieving that.
11:34:13 <opqdonut> xerox_: json and unicode, obviously ;)
11:34:57 <jollygood2> @hoogle Random a => [a] -> IO a
11:34:58 <lambdabot> Rando pickOne :: [x] -> IO x
11:34:58 <lambdabot> System.Random.Pick pickOne :: [x] -> IO x
11:34:58 <lambdabot> Basement.Monad unsafePrimToIO :: PrimMonad prim => prim a -> IO a
11:35:04 <monochrom> Namely, we all understand that GÃ¶del numbering is completely non-essential and replaceable (by strings, even ASTs) for his proofs, but most people still teach the GÃ¶del numbering versions of the proof exclusively.
11:35:08 <jollygood2> anything in base?
11:35:32 <tomsmeding> jollygood2: the Random class itself isn't even in base :p
11:35:50 <jollygood2> s/base/package that ships with ghc
11:36:15 <tomsmeding> unfortunately no, 'random' is the usual package, though there are others with more high-performance generators
11:36:37 <tomsmeding> also, 'Random' itself is not from a package that ships with ghc, so my point stands :p
11:36:44 <dolio> I'm not sure that's on GÃ¶del. It's kind of the mathematician equivalent of programmers who want to write everything 'close to the machine.'
11:36:54 <jollygood2> Random doesn't ship with ghc?
11:37:00 <monochrom> My thesis supervisor's sentiment is in http://www.cs.toronto.edu/~hehner/God.pdf and I totally agree, today even the purest mathematicians have the tools to obsolete the GÃ¶del encoding.
11:37:13 <tomsmeding> jollygood2: it's from the 'random' package :p
11:37:28 <jollygood2> that doesn't answer my question
11:37:53 <tomsmeding> ... which doesn't ship with ghc, no
11:38:30 <tomsmeding> because ghc ships only with the packages that ghc depends on, and ghc doesn't need to generate random numbers
11:38:41 <monochrom> OK yeah dolio, your take is right.
11:38:56 <monochrom> Oh well, so much for blaming it on celebrities.
11:40:02 <monochrom> Oh, random-1.2 is fast and high-quality IMO, even when you use split heavily.
11:40:19 <jollygood2> I don't care about speed
11:40:33 <monochrom> Actually the high-quality part can be objectively quantified by the statistics tests they took, e.g. Die Hard 1.
11:40:34 <jollygood2> I just didn't want to depend on more packages than I need to
11:41:04 <monochrom> Its dependency is minimal too. Just splitmix (the actual generator)
11:41:05 <tomsmeding> the Random class is from the 'random' package, which ghc does not depend on, so you'll need that one at least -- and that ships with a RNG too, so it's all you need
11:41:07 <dolio> Similar phenomenon to everyone insisting on ZF(C) as a formal foundation, and getting really obstinate about not using one that lets you write down things similar to what mathematicians actually say in a more direct way. Despite having very little experience actually working formally. :)
11:41:22 <merijn> monochrom: As always the blame lies with "people being people"
11:41:53 <monochrom> IKR? I'm supposed to be cynical about all humanity.
11:41:54 <merijn> There's a super fast RNG in base if you don't care about quality :p
11:42:00 <merijn> "4"
11:43:07 <dolio> I actually saw someone on MathOverflow recently talking about how the nonsensical propositions in ZF enable 'clever hacks', and that's a good thing. Which makes even less sense than when programmers advocate for it. :)
11:43:20 <jollygood2> randomPick xs = (xs!!) <$> randomRIO (0, length xs)
11:43:28 <tomsmeding> I mean, if quality is not a great issue, you can write a 128-bit LCG without a large amount of effort or code, which will work fine :p
11:43:40 <int-e> merijn: with the xkcd stamp of approval?
11:43:50 <jollygood2> length xs - 1
11:44:11 <merijn> int-e: Exactly
12:19:23 * hackage ukrainian-phonetics-basic 0.3.1.1 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.3.1.1 (OleksandrZhabenko)
12:20:40 <sondr3> I want to read a directory and filter out files based on it's extension, I get all the contents fine with `listDirectory`, but as soon as I filter the list it becomes empty
12:20:58 <sondr3> I'm probably missing something to do with the IO monad
12:21:36 <monochrom> Show actual code?
12:21:40 <shapr> sondr3: can you pastebin your code?
12:21:41 <monochrom> @where paste
12:21:41 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
12:21:43 <geekosaur> @where paste
12:21:43 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
12:23:20 <Uniaika> nf: nice reverse host
12:23:32 <nf> thanks :)
12:23:42 <sondr3> monochrom: geekosaur: https://paste.tomsmeding.com/dboZf8Up
12:24:07 <avdb> How do I create on liner if then else cases in Haskell like in C? If I'm not wrong it should be possible with something like "x == foo? Nothing : Maybe a"
12:24:36 <monochrom> > "aaaa" `isSuffixOf "a"
12:24:38 <lambdabot>  <hint>:1:20: error: <hint>:1:20: error: parse error on input â€˜"â€™
12:24:38 <geekosaur> sodr3, looks to me like you have your isSuffixOf reversed
12:24:48 <tomsmeding> `if x == foo then Nothing else Just a`? avdb 
12:24:53 <shapr> > if 0 == 1 then "world broken" else "not equal"
12:24:55 <lambdabot>  "not equal"
12:25:05 <geekosaur> it's looking for filenames which are suffixes of "hrx"
12:25:16 <sondr3> geekosaur: doh
12:25:44 <avdb> tomsmeding: There was a method with symbols if I'm not wrong, might've just dreamed about it though.
12:25:56 <avdb> If then else is already short enough but I don't like the verbosity
12:26:14 <sondr3> geekosaur: yep, that was it. Thanks :facepalm:
12:26:31 <shapr> avdb: pattern match? applicative?
12:26:36 <Uniaika> nf: and I realise just now that you already follow me on Twitter :P
12:26:54 <tomsmeding> avdb: `let cond ? (x, y) = if cond then x else y`
12:27:05 <tomsmeding> but if-then-else is more readable :p
12:27:05 <shapr> :-D
12:27:14 <nf> Uniaika: ;D
12:28:24 <int-e> :t bool
12:28:25 <lambdabot> a -> a -> Bool -> a
12:28:34 <shapr> whoa, I like mario lang's github profile pic
12:29:38 <int-e> > bool "nay" "aye" (0 == 1)
12:29:40 <lambdabot>  "nay"
12:30:31 <shapr> that's neat
12:31:11 <koz_> Yep, bool is handy sometimes.
12:31:13 <koz_> Related:
12:31:16 <koz_> :t maybe
12:31:18 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:31:19 <koz_> :t either
12:31:21 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:31:34 <int-e> :t foldr
12:31:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:31:37 * koz_ mumbles something about Boehm-Beraducci encodings.
12:32:14 <shapr> does anyone have a tutorial for doing advent of code with nix? I'm mostly a nix newbie.
12:32:50 <int-e> that question doesn't feel well-typed to me
12:32:55 * tomsmeding thought nix was a language for package configuration description, not for general-purpose programming
12:33:05 <tomsmeding> not that you can't use it for that
12:33:18 <tomsmeding> I guess
12:33:25 <tomsmeding> may be slow
12:33:40 <tomsmeding> anyone up for doing AOC in dhall?
12:33:43 <koz_> tomsmeding: You can use it to set up a programming environment, along with your (non-Haskell) deps.
12:33:48 <shapr> tomsmeding: I have nixOS installed, but I'm still coming to grips with how to do development with it
12:33:51 <koz_> I _guess_ that's what's being asked.
12:34:20 <shapr> lucky for me, chessai got my most recent app working with nix: https://github.com/shapr/fermatslastmargin/blob/master/shell.nix
12:34:36 <shapr> but is that all I need to use any library from hackage?
12:34:51 <sm[m]>  tomsmeding: definitely not :)
12:34:57 <shapr> I've read that some of nix+haskell means I'm limited to a single version of the libraries, is that true?
12:35:24 <sm[m]> but I think glguy should use dhall. Slow him down a bit.
12:35:53 * hackage ukrainian-phonetics-basic 0.3.1.2 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.3.1.2 (OleksandrZhabenko)
12:35:59 <shapr> sm[m]: haha!
12:36:45 <avdb> Can you mix list comprehensions with if statements in haskell?
12:37:07 <koz_> avdb: You mean, you want to have conditional logic _in_ the list comprehension?
12:37:08 <avdb> [x | x <- lst, if x == foo then succ x else x]
12:37:11 <avdb> Yes!
12:37:29 <shapr> you can also do pattern matches inside the list comp
12:37:39 <avdb> how?
12:38:18 <shapr> or for extra insanity, there's TransformListComp: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs#L65
12:38:21 <ski> there are no `if' statements in Haskell
12:38:32 <shapr> but I think I'm the only person who's used TransformListComp in the past few years :-P
12:39:00 * ski was just reading about them a bit, earlier today
12:39:12 <tomsmeding> there are 'if' expressions, though
12:39:12 <ski> (looking at some of ProfTeggy's papers)
12:39:13 <shapr> ski: I should try some monad comprehensions
12:39:20 <avdb> ski: if then else grrr
12:39:36 <avdb> I don't know how to use Monads, Functors or any of those exotic tools
12:40:05 <ski> avdb : do you want to, conditionally, either collect `x' or `succ x', with `x' being drawn from `lst' ?
12:40:12 <shapr> avdb: oh functors are so cool!
12:40:14 <avdb> Yes
12:40:22 <shapr> avdb: it's like "apply this function inside this container"
12:40:30 <shapr> avdb: have you used map?
12:40:46 <ski> > [if x `mod` 3 == 0 then succ x else x | x <- [0 .. 9]]
12:40:49 <lambdabot>  [1,1,2,4,4,5,7,7,8,10]
12:40:51 <avdb> Not yet ...
12:40:52 <shapr> > map (* (-1)) [1..9]
12:40:54 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9]
12:40:54 <avdb> Thanks
12:40:54 <ski> something like that ?
12:41:12 <shapr> > map (+1) [5..9]
12:41:14 <lambdabot>  [6,7,8,9,10]
12:41:19 <shapr> :t map
12:41:21 <lambdabot> (a -> b) -> [a] -> [b]
12:41:36 <ski> > [y | x <- [0 .. 9],let y = if x `mod` 3 == 0 then succ x else x]  -- another way to say the same thing
12:41:38 <shapr> avdb: map says "give me a function, and a list, and I'll apply the function to each element in the list, and give you the result"
12:41:39 <lambdabot>  [1,1,2,4,4,5,7,7,8,10]
12:41:54 <avdb> I also intentionally ask my questions it in a totally different manner so that I have to edit the code and use my brains :P
12:41:56 * tomsmeding is happy in this instance that the Haskell legacy hasn't made fmap and map the same thing -- sucks with explaining
12:42:44 <ski> > [y | x <- [0 .. 9],let y | x `mod` 3 == 0 = succ x | otherwise = x]  -- yet another variation
12:42:45 <shapr> avdb: that's smart, using your brain is good but takes work
12:42:46 <lambdabot>  [1,1,2,4,4,5,7,7,8,10]
12:43:05 <avdb> Oh wow ... you can play with the x on the left hand side? Learned something new today about haskell ...
12:43:17 <ski> tomsmeding : they were the same thing, in the past
12:43:28 <koz_> avdb: If you've seen set comprehensions, this will feel very familiar.
12:43:33 <ski> hm, on the left-hand side of what ?
12:43:42 <avdb> Of list comprehensions
12:43:53 <ski> do you mean, before the first `|' ?
12:44:05 <ski> you can put any expression there
12:44:13 <ski> including `if'-`then'-`else' expressions
12:44:14 <tomsmeding> ski: were they? I've only heard the complaints from people that wanted 'map' gone and have 'fmap' called 'map' for consistency, but maybe those were also not aware that this hasn't always been like that?
12:45:46 <shapr> ski has been writing Haskell longer than I have!
12:46:07 <ski> tomsmeding : <http://www.ki.informatik.uni-frankfurt.de/doc/html/Haskell1.4/standard-prelude.html#$tFunctor>
12:46:24 <shapr> wow, that's old school
12:46:25 <ski> tomsmeding : also check out `MonadPlus', just below
12:46:36 <shapr> I didn't get into Haskell until .. ghc4? ghc5? something like that
12:46:55 <shapr> What was the hot new ghc in ~2000 ?
12:47:08 * shapr checks
12:47:09 <tomsmeding> fascinating, (++) in MonadPlus
12:47:11 <shapr> ah, april 2001
12:47:32 <tomsmeding> makes sense though
12:47:46 <ski> oh and `sequence'&`accumulate' in place of `sequence_',`sequence'
12:49:01 <ski> (i remember noting that in Winstanley's monad tutorial <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html>)
12:49:53 <dminuoso> 21:45:45            ski | tomsmeding : <http://www.ki.informatik.uni-frankfurt.de/doc/html/Haskell1.4/standard-prelude.html#$tFunctor>
12:50:11 <dminuoso> Academia is one of the few places that knows how to maintain long lived websites, which I think is both a blessing and a curse.
12:50:51 <ski> shapr : are you sure ?
12:51:00 * ski can't recall
12:51:47 <monochrom> dminuoso, I think it's more like "is enabled to"
12:52:18 <ski> shapr : you said anniversary's in April ?
12:52:25 <shapr> yup
12:52:27 <int-e> dminuoso: don't worry, we're working on solutions for that anomaly: https://www.scottaaronson.com/blog/?p=5094
12:52:38 <shapr> April 30th
12:52:52 <int-e> also... it often happens that a bunch of stuff just disappears when a professor retires or moves to another university
12:52:59 <ski> yes
12:53:05 <shapr> int-e: that part makes me sad
12:53:16 <shapr> I still have an ancient smalltalk <-> haskell bridge
12:53:30 <ski> or when the department decide to do a "site revamp"
12:54:12 <tomsmeding> making the thing less usable in the process
12:54:20 <ski> shapr : that was when you came here ?
12:56:29 <shapr> ski: I think a month later
12:56:58 <shapr> someone else created the channel, but the channel was empty and nobody had joined for weeks, so I talked the freenode admins into letting me take ownership
12:57:17 <monochrom> Namely, a corporate knows too, and it actually knows all too well, precisely why they consciously kill old websites, because they deeply understand that keeping legacy websites is anti-bean-counting.
12:57:34 <ski> yea, i remember you've said that. but for some reason, i always figured it'd been around a bit longer than a month
12:57:41 <shapr> so I probably started writing Haskell in May or June of 2001
12:57:50 <shapr> ski: I don't remember :-(
12:58:48 <monochrom> A university is more enabled because it attracts fewer bean-counting people, and sometimes more people who think along the line "who dares to take down John Conway's website now!"
12:58:52 <ski> i remember i hadn't been on hawiki too long, before finding the `HaskellIRC' page, and came here. and i found the Wiki, because someone mentioned it on <news://comp.lang.functional>
13:00:46 <ski> (but i don't recall when i turned up here, in 2001)
13:01:54 <shapr> ski: I don't think we had logs then either
13:02:04 * tomsmeding is barely three years older than this channel then apparently
13:02:14 <ski> i remember it was on OpenProjects, then
13:02:18 <shapr> I do know that Igloo and Heffalump were early joins to this channel, so they might remember?
13:02:23 <shapr> tomsmeding: welcome?
13:02:24 <ski> dunno when clog showed up
13:02:28 <tomsmeding> :D
13:02:32 <shapr> :-D
13:03:20 <shapr> I'd actually gotten angry at Haskell and gave up and went to learn Scheme, but then my girlfriend at the time had spent time and money to buy me Haskell books for my birthday, so I tried to pick up Haskell again.
13:03:52 <ski> blackdog,arjanb, hmm .. if i think about it, i might be able to remember more names
13:04:39 <koz_> shapr: Thank her for me. :P
13:04:47 <shapr> haha
13:04:49 <koz_> (if you two are still on speaking terms)
13:04:50 <Rembane> shapr: So that you know Haskell is all because of her? :D
13:04:53 * hackage typson-core 0.1.0.1 - Type-safe PostgreSQL JSON Querying  https://hackage.haskell.org/package/typson-core-0.1.0.1 (aaronallen8455)
13:04:58 <shapr> Rembane: pretty much, yeah
13:05:09 <koz_> True story: I got into CompSci because I was ridiculously attracted to one of my TAs.
13:05:16 <koz_> (no seriously)
13:05:27 <Rembane> koz_: Seems legit. Did you ask them out on a date?
13:05:33 <koz_> She wasn't interested.
13:05:38 <shapr> too bad
13:05:40 <koz_> Ehh.
13:05:44 <Rembane> Must've been a disappointment and saved lots of time. 
13:05:55 <Rembane> shapr: Was it you who did the APL implementation in Haskell?
13:06:02 <koz_> I'm glad she wasn't, because our worldviews were about a million miles apart.
13:06:03 <shapr> not me, no
13:06:07 <koz_> And it would have ended in tears.
13:06:18 <shapr> though I would like to read that APL implementation
13:06:30 <Rembane> Then I'm mixing you up with someone 
13:06:47 <Rembane> shapr: If I stumble upon it I promise to send it to you 
13:06:51 <shapr> yay!
13:07:14 <shapr> I built ghcLiVE long years ago, and more recently Fermat's Last Margin
13:07:22 <shapr> and some smaller tools like sandwatch
13:07:54 * ski eats a sandwich
13:07:58 <Igloo> shapr: Remember what?
13:08:11 <shapr> Igloo: when did you join #haskell the first time? 
13:08:13 <koz_> ski: Ah yes, the product type of foods.
13:08:28 <shapr> Igloo: also, how's life treating you? Do you get paid to write Haskell?
13:08:53 <shapr> I'm tempted to rebuild ghcLiVE in a terminal with sixel http://okbob.blogspot.com/2020/08/gnome-terminal-with-sixel-support.html
13:09:12 <Igloo> I don't know exactly
13:09:21 <Igloo> I write a few bits here and there  :-)
13:09:30 <shapr> Igloo: ski and I were trying to figure out when #haskell really got going
13:09:51 <shapr> I know I took over founder-ness some weeks / months after the channel was registered, but I don't remember exactly when.
13:10:03 <Rembane> When was this? 
13:10:07 <shapr> sometime in 2001
13:10:08 <ski> 2001
13:10:10 <Rembane> Nice 
13:10:13 <ski> fun times :)
13:10:22 * hackage typson-beam 0.1.0.1 - Typson Beam Integration  https://hackage.haskell.org/package/typson-beam-0.1.0.1 (aaronallen8455)
13:10:30 <shapr> Fewer people here, but all sorts of adventures too
13:10:33 <Rembane> I joined nine years later IIRC 
13:10:41 <Igloo> Chanserv says "Registered : Apr 30 22:22:56 2001 (19y 30w 4d ago)"
13:10:54 <shapr> Igloo: 20th anniversary party coming up!
13:11:07 <Rembane> Sweet! 
13:11:16 <tomsmeding> missed the 22:22:22 opportunity there 19 years ago
13:11:18 <ski> iirc i'd ambush newbies, asking them about Haskell or so
13:11:53 <Igloo> But will we still have to party at home alone, shapr?  :-)
13:12:06 <ski> shapr : my vague memory tells me ten to twenty regulars, around the start. does that sound reasonable ?
13:12:15 <shapr> yup
13:12:23 <ski> we're not alone, in #haskell !
13:14:10 <shapr> ski: oh hey, I wrote an email to the haskell .. cafe? so we can find that!
13:14:30 <shapr> That's how I got people to show up, I told 'em there were smart academics here having good conversation.
13:14:36 <shapr> and when they arrived, it was true!
13:14:52 <ski> hm, i don't recall seeing that
13:16:25 <shapr> Might have been the main haskell mailing list, I forget
13:16:53 * hackage phonetic-languages-simplified-properties-lists 0.1.3.1 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-simplified-properties-lists-0.1.3.1 (OleksandrZhabenko)
13:19:28 <xerox_> I wonder where TheHunter ended up
13:19:47 <ski> yea ..
13:19:59 <ski> and mmorrow,vixey
13:20:14 <shapr> I know where blackdog works ...
13:20:35 <shapr> I tracked down TheHunter some years ago, he was still writing code, but I think not Haskell anymore.
13:21:05 <shapr> > 51 / 3
13:21:08 <lambdabot>  17.0
13:22:46 <ski> i remember at some point i used to obsessively read all the scrollback ..
13:23:23 * hackage typson-esqueleto 0.1.0.1 - Typson Esqueleto Integration  https://hackage.haskell.org/package/typson-esqueleto-0.1.0.1 (aaronallen8455)
13:23:24 <shapr> That was humanly possible in the early years.
13:24:01 <shapr> I used to check the user list when I got on and welcome new people
13:24:25 <ski> yea, i remember that, too
13:24:33 <hpc> checking the user list used to be humanly possible too
13:24:42 <ski> (remember me doing that, quite possibly after seeing you do it)
13:25:52 * hackage typson-selda 0.1.0.0 - Typson Selda Integration  https://hackage.haskell.org/package/typson-selda-0.1.0.0 (aaronallen8455)
13:26:03 <b7471> Hello
13:26:12 <shapr> hi b7471
13:26:12 <ski>   hello
13:26:27 <b7471> i have a small question
13:26:33 <shapr> ooh, I have a small answer!
13:26:39 <b7471> if a have a if else loop in haskell
13:26:48 * ski was thinking about something similar .. :)
13:26:59 <shapr> hpc: yeah, it's been a few years since that was reasonable
13:27:01 <b7471> and i want to print three variables 
13:27:04 <b7471> how do i do this
13:27:13 <Rembane> b7471: What's an if-else-loop?
13:27:17 <ski> perhaps you could show your current code ?
13:27:34 <b7471> orderTriple(x,y,z)= if x>y && z>y then x else y
13:27:40 <ski>   loop x = if ..x.. then ... else loop (..x..)  -- something like this ?
13:27:48 <b7471> orderTriple :: (Int,Int,Int) -> Int
13:28:03 <ski> hm, i see no loop in there
13:28:13 <b7471> i dont want to output just x , but all the three numbers
13:28:22 <ski> @index trace
13:28:22 <lambdabot> Debug.Trace
13:28:28 <ski> @type Debug.Trace.trace
13:28:30 <lambdabot> String -> a -> a
13:28:44 <b7471> the function should compare three numbers and "show" them in their orders
13:29:05 <b7471> three numbers for example 1,3,2  should show 1,2,3
13:29:35 <ski>   orderTriple (x,y,z) = trace (concat ["x = ",show x,"\ny = ",show y,"\nz = ",show z,"\n"]) (if x>y && z>y then x else y)
13:29:46 <ski> try something like that, after importing `Debug.Trace'
13:29:54 <shapr> hpc: do you write Haskell for money?
13:30:57 <ski> b7471 : but be sure to remove `trace' from the code, afterwards !
13:31:35 <b7471> in the code i used cant i just type: then (x,y,z) else (z,x,y) ?
13:32:20 <hpc> shapr: yes, but unfortunately i have to write it in other languages instead ;)
13:32:36 <ski> b7471 : oh, sure. you can change the result of the function from being a single `Int' to being a triple of `Int's, if you want to
13:32:49 <ski> (but you'll need to change the type signature, to reflect that, naturally)
13:33:12 <b7471> how do i print three variable instead of just one (then x else... )
13:33:50 <ski> what if you try what you just said ?
13:33:54 <ski> <b7471> in the code i used cant i just type: then (x,y,z) else (z,x,y) ?
13:36:50 <ski> shapr : fwiw, #haskell is still the channel i like most, i'd say
13:38:29 <shapr> ski: I'm glad, I spent a bunch of years working on the culture.
13:38:45 <shapr> not so much the past few though, I've reached the point of "time to write code instead of organize community"
13:38:55 <shapr> though I'm tempted to apply to the Haskell Foundation, see if I can help out
13:40:26 <b7471> well it is a bit of an improvement.
13:40:36 <b7471> but i guess i will have to learn a bit more
13:40:49 <b7471> this haskell thing
13:41:21 <shapr> b7471: it's fun
13:41:43 <ski> shapr : occasionally i may boast a little in other channels about how friendly and welcoming i found #haskell, when i started chatting (and still do), and how i've since attempted to bring some of the same spirit also to other channels in which i've chatted a bit more
13:42:43 <ski> b7471 : got it to type-check, at least ?
13:43:11 <shapr> ski: Yeah, I attribute the root of that friendly culture to SPJ
13:43:47 <b7471> ski what_
13:43:55 <b7471> pardon?
13:44:10 <ski> it's quite possible. he's a very amiable fellow
13:44:35 <b7471> i dont understand english that well
13:44:38 <ski> b7471 : i mean your `orderTriple' function, after you changed it, according to your last suggestion
13:44:51 <b7471> well i tryed it
13:44:58 <ski> did you get an error ?
13:45:02 <b7471> and it says Error whatever...
13:45:05 <b7471> yes
13:45:11 <ski> what was the error ?
13:45:42 <b7471> just a second
13:46:11 <ski> shapr : i think it's quite likely been an important factor for the success that Haskell's had
13:47:03 <b7471>                      with actual type `(Int, Int, Int)'     * In the expression: (x, y, y)       In the expression: if x > y && z > y then (x, y, y) else y       In an equation for `orderTriple':           orderTriple (x, y, z) = if x > y && z > y then (x, y, y) else y    | 46 | orderTriple(x,y,z)= if x>y && z>y then (x,y,y) else y    |                                        ^^^^^^^ Failed, no mod
13:47:16 <b7471> lol
13:48:00 <ski> b7471 : yes, you need to change both branches of the `if'-`then'-`else' (both the expression after the `then', and the expression after the `else'), to have the same type
13:48:18 <ski> you can't have one of them giving back a number, and the other three numbers
13:48:33 <b7471> https://pastebin.com/PnsM6Z7U
13:48:38 <ski> the caller of your function wouldn't know what to expect back
13:49:55 <b7471> hmm
13:50:29 <ski> what if the caller would try to do e.g. `1 + orderTriple (2,3,4)' .. if your code was allowed, it would add `1' to a number, in case the `else' branch was taken, but try to add a number to a triple (which doesn't work, what does that even mean ?), in case the `then' branch was taken
13:51:23 <ski> could you repeat your type signature for `orederTriple', btw ?
13:52:23 * hackage ipfs 1.1.5.1 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.1.5.1 (expede)
13:52:44 <b7471> haskell is not like these other languages
13:53:01 <b7471> maybe i not understanding it anyway
13:53:04 <b7471> its getting late
13:53:21 <b7471> and so i wish you guys a good night
13:53:28 <ski> it's a different programming paradigm
13:53:43 <ski> it always takes more time to learn a new paradigm, than to learn yet another language in one you already know
13:53:56 <ski> learning a new one is a bit like learning to program from scratch all over
13:53:57 <shapr> b7471: it's worth learning!
13:54:09 <ski> good night, b7471. happy Haskell learning !
13:54:13 <b7471> well we shall see
13:54:18 <b7471> thanks guy
13:54:24 <b7471> goodbye
13:54:33 <b7471> thanks guys*
14:11:05 <incertia> is it possible to derive/write instances for type families?
14:11:44 <incertia> i have data Test = A | B and type family F (t :: Test) where F 'A = Int, F 'B = Double
14:12:08 <incertia> is it possible to get Eq (F t) and/or Show (F t)?
14:12:28 <hpc> data Test = A | B deriving (Eq, ...)
14:12:52 <hpc> oh wait, misread
14:13:31 <hpc> F acts more like a type alias than a data type
14:13:44 <hpc> so you should already have Eq (F t), for a specific value of t
14:14:18 <incertia> right but when i stick it in a data type and try to derive ghc complains
14:14:44 <incertia> data MyData t = MyData { yolo :: F t } deriving (Show, Eq)
14:17:24 <hpc> i think it can't figure out those are the only instances of F
14:19:08 <hpc> a brute-force way past this could be GADTs
14:19:43 <hpc> data MyData t where MyA :: F 'A -> MyData 'A; MyB :: etc etc
14:19:53 <hpc> deriving (Show, Eq)
14:20:21 <incertia> yeah problem here is there are more records in the actual case
14:20:26 <incertia> which need lenses
14:20:32 <ski> % data F a = F a a
14:20:33 <yahb> ski: 
14:20:36 <ski> % data MyData t = Show (F t) => MyData { yolo :: F t }
14:20:36 <yahb> ski: 
14:20:45 <ski> % deriving instance Show (MyData t)
14:20:46 <yahb> ski: 
14:21:04 <hpc> oh right, that's a thing
14:23:38 <incertia> oh cool
14:39:37 <incertia> ok new problem is writing FromJSON
14:40:43 <incertia> to expand a bit we have some JSON from some web service and it includes some similar structure all over the place but the actual data is different
14:41:23 <incertia> namely you have this object "difficulties": {"easy": ..., "normal": ..., ...} and the values are different depending on context
14:41:37 <dminuoso> Is there some library that lets be dump a Forest/Tree from containers straight into a dot file, or some other handy visualization?
14:41:40 <koz_> incertia: Are they of (possibly) different types?
14:41:50 <dminuoso> My graph is just so wide that drawForest/drawTree dont help much
14:41:59 <incertia> one area tells you if the level is present or not and another tells you the actual level stats
14:42:22 <incertia> the types are the same within each grouping
14:42:48 <koz_> incertia: So what you're saying is that "easy": might be a JSON string sometimes, and a JSON object sometimes, etc?
14:42:57 <koz_> Or is "easy" _always_ a JSON string, but might look different?
14:43:12 <koz_> (well, the thing associated with "easy"...)
14:43:18 <koz_> (gah natural language and my own laziness)
14:43:20 <incertia> it might be Bool
14:43:23 <incertia> it might be Object
14:43:36 <koz_> Easy hack: parse it the 'targets' into Value.
14:43:42 <koz_> Then take them apart however you want.
14:43:49 <incertia> but you are guaranteed it's either all Bools or all Objects
14:44:07 <incertia> and i have a FromJSON for the object
14:44:17 <incertia> LevelData
14:44:28 <koz_> What does LevelData look like?
14:44:50 <incertia> a bunch of records
14:45:01 <koz_> Is it a sum type?
14:45:05 <koz_> Or just a big record/product?
14:45:10 <incertia> data LevelData = LevelData { levelDuration :: Double, levelWhatever :: Integer, ... }
14:45:14 <koz_> Ah, I see.
14:45:18 <incertia> so ez FromJSON here
14:45:32 <koz_> So it's 'difficulties' that causes issues?
14:45:43 <koz_> How do you represent (the equivalent info) in LevelData, or is this undecided?
14:46:05 <tdammers> so... data DifficultyData = DifficultyLevel LevelData | DifficultyBool Bool -- ?
14:46:21 <incertia> so now there is data LevelInfo t = LevelInfo { _infoEasy :: ObjectType t, _infoNormal :: ObjectType t }
14:46:24 <koz_> You could do a big sum like that, I guess.
14:46:24 <incertia> etc
14:46:32 <incertia> i want to represent this via type families
14:46:37 <incertia> because why not
14:47:03 <koz_> Yeah, you're going to have a fun time.
14:47:12 <koz_> Is the set of possible ts closed?
14:47:18 <incertia> yes
14:47:25 <koz_> Then I would advise a different route.
14:47:56 <koz_> Write a separate `FromJSON` for LevelInfo t for each t you care about.
14:48:15 <incertia> i can do that?
14:48:15 <koz_> If you see common behaviours, abstract out into a function.
14:48:18 <koz_> Why not?
14:48:25 <koz_> 'instance FromJSON (LevelInfo Bool) where...`
14:48:26 <koz_> Then
14:48:34 <koz_> 'instance FromJSON (LevelInfo Text) where...'
14:48:35 <koz_> etc.
14:48:40 <koz_> If the set of types is closed, why not?
14:48:57 <incertia> holy shit you're right
14:49:10 <koz_> Zero tyfams needed.
14:49:22 <incertia> maybe something changed between what i was trying to do with Show/Eq and now
14:49:28 <incertia> probably ExistentialQuantification?
14:49:37 * koz_ shrugs because he dunnos.
14:50:17 <incertia> now i just have duplicated code lol
14:50:27 <koz_> Then refactor out common behaviour using a function.
14:50:39 <koz_> You are in a function language, HOFs exist, use them.
14:50:39 <incertia> but that's parseJSON
14:50:49 <koz_> Well, it's not 100% duplicated right?
14:50:55 <koz_> There has to be some variance.
14:51:07 <koz_> s/function/functional/ argh
14:51:59 <incertia> https://gist.github.com/incertia/3df23f63d1e4b17bfd5eaa6c16953fc0
14:52:32 <incertia> the issue is essentially collapsing both into instance FromJSON (LevelInfo t) causes ghc to complain
14:52:36 <koz_> In that case, 'instance (FromJSON a) => FromJSON (LevelInfo a) where...'.
14:52:54 <koz_> Since you're basically going 'parse it however, YOLO'.
14:53:46 <dminuoso> incertia: Unrelatedly, you might be interested in RecordWildCards for parseJSON, otherwise you risk subtle line shift bugs, especially if you extend the data types.
14:54:04 <koz_> Yeah, this is one time where RecordWildCards is actually useful.
14:54:38 <incertia> instance FromJSON (DiffType t) => FromJSON (LevelInfo t) suggests UndecidableInstances
14:54:42 <incertia> which is highly dubious
14:54:52 <koz_> It's not really.
14:55:15 <incertia> it doesn't seem so here but it would be nice to not have to turn this on
14:55:16 <koz_> The name is scary, but the reality is that the Paterson conditions are _very_ restrictive.
14:55:23 <koz_> Your instance is terminating, so what's the problem?
14:55:30 <dminuoso> incertia: It requires UndecidableInstances because GHC is overly conservative. The worst that can happen if you toggle it on, that GHC might get stuck type checking
14:55:32 <dminuoso> That's all.
14:55:39 <koz_> Like, _very very_.
14:55:54 <koz_> Edward proposed a different algorithm to the Paterson conditions, but that didn't go anywhere, sadly.
14:57:14 <dminuoso> koz_: Do you have a reference for that?
14:57:24 <incertia> guess it makes sense to get rid of the ExistentialQuantification and just use UndecidableInstances then
14:59:01 <koz_> dminuoso: https://github.com/ghc-proposals/ghc-proposals/pull/114
14:59:25 <koz_> (as an extension obv, because you know, Haskell2010 etc etc)
15:05:58 <hekkaidekapus> dminuoso: Is `Data.Tree` a hard or lax requirement?
15:12:47 <dminuoso> hekkaidekapus: Mmm, well my data is in Tree currently. What do you have in mind?
15:13:16 <hekkaidekapus> Suggesting an fgl export.
15:14:19 <hekkaidekapus> fgl is an almost zero-cost intermediate step because you already have all its deps.
15:14:34 <hekkaidekapus> Then have fun with graphviz.
15:17:22 * hackage phonetic-languages-common 0.1.2.0 - A generalization of the uniqueness-periods-vector-common package.  https://hackage.haskell.org/package/phonetic-languages-common-0.1.2.0 (OleksandrZhabenko)
15:18:00 <dminuoso> Mmm, fgl always intimidated me, but Ill give it a try
15:19:23 <hekkaidekapus> You will touch its easiest parts: just building a graph, for instance going for `Data.Graph.Inductive.Graph`. Once you have the graph,
15:19:40 <hekkaidekapus> all is left is letting the other library do its part.
15:20:19 <hekkaidekapus> There you can also deal with just dumping a .dot, no need to draw cute diagrams at first.
15:20:22 <ryantrinkle> is there a way to get a type signature like `forall (a :: (k1, k2)). a` to unify with `'(t1, t2)`?
15:20:34 <ryantrinkle> i get Couldn't match type â€˜a1â€™ with â€˜'(aOut0, bOut0)â€™
15:21:28 <shapr> dminuoso: algebraic graphs?
15:21:46 <shapr> that's what weeder is using
15:21:49 <shapr> well, weeder 2.0
15:21:56 <hekkaidekapus> Does `alga` have a GraphViz interface?
15:22:04 <shapr> oh, don't know
15:22:12 <shapr> good point
15:22:47 <hekkaidekapus> Yeah, were not it for .dot files, Iâ€™d have gone with alga too.
15:24:19 <dminuoso> hekkaidekapus: Ah alright. I found some chunk of code I can just copy and paste from stackoverflow
15:24:38 <hekkaidekapus> Cheers!
15:24:47 <dminuoso> https://stackoverflow.com/questions/13355968/elegant-way-to-convert-a-tree-to-a-functional-graph-library-tree
15:33:41 * hekkaidekapus notices that I kept in mind `alga` which is the repositoryâ€™s name on GitHub. On Hackage, thatâ€™s another library; there I have to remember `algebraic-graphs`. ;)
15:33:44 <sm[m]> awkward
15:34:45 <hekkaidekapus> heh Now, thatâ€™s a timing, sm[m] :d
15:36:12 <sm[m]> I just got rid of fgl since sp was giving a silly result. Probably I was holding it wrong but still, I didn't find fgl too friendly
15:37:00 <hekkaidekapus> Whatâ€™s sp?
15:37:02 <ryantrinkle> doing the same thing with closed type families Fst and Snd (defined the obvious way) works
15:37:10 <sm[m]> shortest path
15:37:55 <hekkaidekapus> Ah. fgl has a 2 decades old baggage.
15:38:17 <sm[m]> with an edge directly from 0 to 2 it was saying the shortest path was 0,1,2
15:39:19 <hekkaidekapus> Weird. How was the graph built?
15:40:16 <sm[m]> uh, by me with mkGraph IIRC ? And I thought it was working fine for a few months. Sorry don't have code in front of me
15:40:47 <hekkaidekapus> <https://github.com/haskell/fgl/issues/67>
15:41:52 <sm[m]> I looked for issues and apparently more than one edge between nodes will confuse it (but it won't warn you) and maybe also it doesn't do directed edges.. not sure
15:43:03 <hekkaidekapus> The internal representation assumes single edges for all nodes. The fix is to brek old code and thatâ€™s not yet done.
15:43:35 <sm[m]> yes that's the one. Let's assume that was my problem. I realized it was easier to write an sp tailored to my needs
15:43:43 <sm[m]> hekkaidekapus: do you work on fgl ?
15:44:24 <hekkaidekapus> Nope; had just noticed that a few months ago. Check out algebraic-graphs for the latest shiny (and sound) library for graphs.
15:45:18 <sm[m]> I feel like maybe it didn't have a shortest-path when I looked, but I might be wrong
15:46:28 * hekkaidekapus_ hmmâ€¦ Sound is a bit exaggerated. fgl is also sounds; the code is just too clunky; type synonyms everywhereâ€¦
15:46:36 <koz_> algebraic-graphs is pretty nice.
15:48:05 <shapr> I could never get into fgl, I really tried
15:52:12 <hekkaidekapus_> sm[m]: <https://hackage.haskell.org/package/algebraic-graphs-0.5/docs/Algebra-Graph-Label.html#t:ShortestPath>
15:54:23 * hackage phonetic-languages-properties 0.3.0.1 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-properties-0.3.0.1 (OleksandrZhabenko)
15:57:53 * hackage phonetic-languages-general 0.3.0.1 - A generalization of the uniqueness-periods-vector-general functionality.  https://hackage.haskell.org/package/phonetic-languages-general-0.3.0.1 (OleksandrZhabenko)
16:04:19 <hekkaidekapus_> shapr: It turns out pangraph can bridge between alga and fgl, thus there is a â€¦ path from alga to graphviz. (Not going the rabbit hole of checking with real code at the moment, but the possibility is there.)
16:05:07 * hekkaidekapus_ notes that pangraph might have been another opportunity to put backpack at workâ€¦
16:15:53 * hackage phonetic-languages-examples 0.6.2.1 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.6.2.1 (OleksandrZhabenko)
16:30:14 <monochrom> Every year at this time I share with you: pumpkin catmorphism http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
16:31:15 <sm[m]> hekkaidekapus_: thanks
16:33:51 <hekkaidekapus_> yw
16:34:48 <hekkaidekapus_> monochrom: ty :p
16:35:22 * hackage language-dickinson 1.4.1.1 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.4.1.1 (vmchale)
17:59:22 * hackage capnp 0.8.0.0 - Cap'n Proto for Haskell  https://hackage.haskell.org/package/capnp-0.8.0.0 (isd)
18:07:34 <shapr> hekkaidekapus: neat, I hadn't heard about pangraph, I'm interested in graph description languages.
18:28:37 <kupi> hi
18:29:10 <kupi> i would like to get Maybe (Int, Int) from that regex, i can't even get the string values, i get empty string
18:29:10 <kupi> https://gist.github.com/theqp/8d38a3997deb3f15f17b1b5be1e996a9
18:29:16 <kupi> what do i do wrong?
18:34:27 <koz_> Use regexp. This sounds like something a {mega,atto}parsec parser could do a lot more easily.
18:34:38 <koz_> This in particular worries me: import qualified Data.ByteString.Lazy.Char8 as C
18:47:35 <kupi> koz_: this one? https://hackage.haskell.org/package/regex-examples-1.1.0.0#readme
18:47:47 <kupi> the site is down and i can't reach the toturial
18:48:00 <koz_> Yeah... is your input data a C-string?
18:48:07 <kupi> yes
18:48:15 <koz_> Wow, in that case, my sympathies.
18:48:42 <kupi> i am practicing with real world haskell
18:49:30 <kupi> that used Text.Regex.Posix, but that is outdated
18:50:05 <kupi> regex-tdfa seems to be the new equivalent 
18:56:07 <kupi> i have found this https://stackoverflow.com/a/5591628
18:56:16 <kupi> and updated my code accordingly
18:57:07 <kupi> and still get an empty list
19:00:46 <koz_> Does \\D mean 'not a digit'?
19:01:29 <kupi> this says yes
19:01:31 <kupi> https://www.regextester.com/99203
19:02:07 <kupi> what's even more weird is this: https://gist.github.com/theqp/98373e203483c65fbd93152a795a91f9
19:03:25 <kupi> nvm, the last element may be the whole match
19:08:04 <kupi> i found the root of them problem: https://www.regextester.com/ lies in it's title, it does not match posix regexes
19:52:23 * hackage box 0.6.2 - boxes  https://hackage.haskell.org/package/box-0.6.2 (tonyday567)
21:51:59 <ADG1089> haskell web framework to take 3 file uploads and process them (like pandas in python) and return a SQL query?
22:32:52 * hackage cloudi 2.0.1 - Haskell CloudI API  https://hackage.haskell.org/package/cloudi-2.0.1 (okeuday)
23:13:45 <triteraflops> Someone here mentioned haskell can do destructive updates. I think I remember something about this now. It basically does it with a monad of some sort, right?
23:13:53 <triteraflops> or in-place updates
23:14:11 <triteraflops> you know you got a big honking hunk of memory and you change one byte of it
23:14:36 <triteraflops> Please don't make a new copy of this 2-gigabyte data structure lol
23:14:57 <opqdonut> triteraflops: ST is the monad you're thinking about
23:15:11 <opqdonut> for safe invisible local mutation
23:15:16 <opqdonut> if you want global mutation, it's IO
23:15:26 <triteraflops> well, IO is a license to kill
23:15:38 <triteraflops> I would not resort to it unless absolutely necessary
23:16:09 <triteraflops> If everything happens in IO, there's no actual reason for me to use haskell at that point
23:16:48 <triteraflops> local mutation though
23:17:10 <triteraflops> so you make the monad, it does things, then you evaluate the monad, and that's the end of this series of mutations
23:17:20 <triteraflops> or wait
23:17:33 <triteraflops> Can I use ST to do things like persistent process state?
23:18:02 <triteraflops> a data structure that changes a tiny bit every 16.66666667 milliseconds?
23:18:39 <opqdonut> no
23:18:41 <opqdonut> that's IO
23:18:42 <opqdonut> that's not pure
23:18:46 <triteraflops> shit.
23:18:49 <triteraflops> but....
23:18:56 <opqdonut> and anyway, it's fine if "everything happens in IO"
23:19:01 <opqdonut> haskell is the best imperative programming language
23:19:05 <triteraflops> lol
23:19:12 <opqdonut> it is, try it
23:19:27 <opqdonut> and anyway, you can then isolate some nice pure parts out of the IO and e.g. test them with quickcheck
23:19:35 <triteraflops> but what would the advantages even be at that point?
23:19:41 <opqdonut> types
23:19:45 <opqdonut> performance
23:19:51 <opqdonut> tooling (gotta love the profilers)
23:20:33 <triteraflops> OK, so I'll give that a maybe.
23:21:01 <triteraflops> I can have two persistent systems that have nothing to do with each other. And they must both be IO?
23:21:30 <triteraflops> or that are weakly interacting, like audio and video
23:21:39 <opqdonut> well they can both be giant ST transactions too I guess, but then you won't be really able to interact with the outside world while updating them
23:22:00 <triteraflops> I'll give that a maybe too
23:22:05 <opqdonut> yeah if you have audio/video it must be IO. ST is for local mutation, think in-place quicksort. The computation as a whole must be pure
23:22:21 <triteraflops> That is the haskell party line
23:22:35 <triteraflops> OK, so there is a reason I'm asking these questions.
23:22:48 <triteraflops> Have you ever heard of a language called Clean?
23:22:51 <triteraflops> It'd Dutch.
23:22:55 <triteraflops> *It's
23:23:35 <opqdonut> yes, clean inspired haskell a bit I think
23:23:51 <opqdonut> not sure if it's still maintained/relevant tho
23:23:56 <triteraflops> So, clean is a more complicated language than haskell.
23:24:00 <triteraflops> It is, yeas
23:24:14 <triteraflops> It adds an extra property to types, uniqueness.
23:24:15 <triteraflops> brb
23:24:33 <opqdonut> yeah I know of linear/uniqueness typing
23:25:35 <ski> "clean inspired haskell a bit I think" -- neither
23:25:38 <opqdonut> you might be interested in https://gitlab.haskell.org/ghc/ghc/-/wikis/linear-types
23:25:44 <ski> and yes, it's still maintained
23:26:14 <opqdonut> anyway I think you'll find it's possible to write very nice haskell programs that are "IO-heavy", and you can usually isolate quite a bit of the code into pure functions anyway
23:26:27 <ski> the Clean folks was part of the same fuzzy group of people that were researching lazy pure functional programming languages as the Haskell folks
23:26:41 <opqdonut> but of course if you just want to take a principled stance against the haskell IO model then yeah, it's limited :)
23:27:00 <triteraflops> back
23:27:25 <ski> people decided it would be better to try to compromise, cooperate, settle on some standard language, instead of everyone, or every small group having their own variant language
23:27:34 <triteraflops> I am indeed very interested in linear types
23:27:52 <triteraflops> It seems more granular than relegating all persistent state to IO
23:28:08 <ski> and so Haskell was formed by a committee
23:28:37 <opqdonut> one way to keep these two mutable "threads" separate in haskell would be to use something like `ReaderT AudioRef IO` for the audio actions and `ReaderT VideoRef IO` for the video actions
23:29:00 <ski> however, the Clean folks were doing something sufficiently different (uniqueness), that they didn't want to part with, and which the other's couldn't agree to incorporate at the time. and so Clean became its own separate thing
23:29:01 <opqdonut> with AudioRef and VideoRef being e.g. newtypes over IORef
23:29:20 <opqdonut> then you could have the type system verify that these two threads of computation are separate
23:29:37 <triteraflops> ski: I think the Clean folks were on to something.
23:29:39 <ski> opqdonut : note that uniqueness is distinct from linearity and affinity, though
23:29:52 <opqdonut> oh, I thought uniqueness was linearity
23:30:01 <triteraflops> I've heard that before, but they're all solving the same problem, it seems to me
23:30:12 <opqdonut> oh ok I see the difference now, reading wikipedia
23:30:31 <opqdonut> > Uniqueness guarantees that a value has no other references to it, while linearity guarantees that no more references can be made to a value.
23:30:34 <lambdabot>  <hint>:1:65: error: <hint>:1:65: error: parse error on input â€˜,â€™
23:30:43 <opqdonut> meh, need to remember not to use > as blockquote
23:31:36 <triteraflops> I don't get it. Sounds like the same thing to me.
23:31:52 <triteraflops> One thing, one ref
23:31:58 <opqdonut> linearity means "you can't duplicate references, but your caller might've"
23:32:07 <opqdonut> uniqueness means "nobody can have duplicated this reference"
23:32:23 <triteraflops> so linearity is ... weaker?
23:32:37 <opqdonut> yes
23:32:49 <opqdonut> or more expressive, however you want to look at it
23:33:02 <triteraflops> brb
23:33:24 <ski> triteraflops : did you see my (late) response to you, two days ago ?
23:36:29 <triteraflops> back
23:36:44 <triteraflops> ski: UM.
23:37:02 <ski> opqdonut : "oh, I thought uniqueness was linearity" -- with uniqueness, you know the reference to the value hasn't been duplicated in the past (but you're allowed to duplicate it in the future (unless you promise to return a unique reference back)). with affinity, you're not allowed to duplicate it in the future (but it may have been duplicated in the past). linearity is like affinity, except that affinity 
23:37:08 <ski> allows discarding, with linearity you must explicitly pass your garbage to some waste disposal
23:37:11 <triteraflops> how do I search backwards in a channel in irssi?
23:37:33 <opqdonut> triteraflops: /lastlog searchterm
23:38:55 <ski> "<triteraflops> I've heard that before, but they're all solving the same problem, it seems to me" -- they're certainly related in some sense (iirc the Linear Haskell paper showed how you could, at least in some cases, encode uniquess with it, via CPS). not sure one could say they're solving the same problem, though, but they are at least in the same rough ballpark of ideas
23:39:06 <ski> triteraflops : see <https://ircbrowse.tomsmeding.com/day/haskell/2020/11/25?id=153176&timestamp=1606303143#t1606303143>
23:39:34 <ski> (if anyone else wants to check, the start of that conversation was as <https://ircbrowse.tomsmeding.com/day/haskell/2020/11/25?id=152688&timestamp=1606279789#t1606279789>)
23:41:11 <ski> triteraflops : in Irssi, you could do something like
23:41:23 <ski> /window new
23:41:31 <ski> /lastlog -window #haskell triteratops
23:42:18 <ski> to get all lines mentioning your nickname, into a separate Irssi window. can be useful to check the timestamp for when some interesting message or conversation occured
23:42:30 <ski> but it won't show you adjoining lines
23:42:54 <opqdonut> I just use "/lastlog -5 whatever" in the channel window to get search results with context
23:43:18 <opqdonut> and "/lastlog -clear" to reset the window to what it was showing before
23:44:02 <ski> (oh, i guess i hadn't noticed `-clear')
23:45:06 <ski> /scrollback goto -2 <hours>:<minutes>
23:45:27 <opqdonut> nice
23:45:57 <ski> (`2' being the relevant number of days, in this case), should work to scroll you back to some particular time then, like when my response was
23:46:46 <ski> (three hours and eighteen minutes later in the day than now, two days ago)
23:48:28 <ski> "so linearity is ... weaker?" -- no. they're sort of opposite. one is a guarantee that duplication hasn't happened in the past. the other is a guarantee that duplication won't happen in the future
23:50:02 <ski> (also, it's probably better to compare uniqueness to affinity here. since linearity also adds nondiscardability. the "opposite" of that would be "the reference hasn't been discarded in the past" .. well, duh, you don't say !)
23:57:01 <kupi> i feel dumb for declaring this function, is there an alternative? https://gist.github.com/theqp/cd8c2a33e368e1267ae4278ccb5541ff
23:57:08 <kupi> hoogle did not give any results
23:57:18 <kupi> would modifyT be a good name?
