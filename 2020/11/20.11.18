01:36:13 <tomsmeding> funny how lambdabot apparently considers '@' to be the line end when reading from hoohle?
01:36:18 <tomsmeding> *hoogle
03:01:22 * hackage subG 0.3.0.0 - Some extension to the Foldable and Monoid classes.  https://hackage.haskell.org/package/subG-0.3.0.0 (OleksandrZhabenko)
03:09:52 * hackage http-conduit-downloader 1.1.3 - HTTP downloader tailored for web-crawler needs.  https://hackage.haskell.org/package/http-conduit-downloader-1.1.3 (VladimirShabanov)
03:54:19 <boxscape> is there a way to make this type family work? Or alternatively, another way to construct and store a proof that one symbol is less than another? https://gist.github.com/JakobBruenker/7e9cae27d2e7d5ef0f9bf93a640a2a42
04:00:02 <nshepperd> at the type level? proofs have to be values
04:00:31 <dminuoso> boxscape: https://hackage.haskell.org/package/constraints-0.12/docs/Data-Constraint.html#v:withDict
04:01:13 <boxscape> I'll take a look at that, thanks
04:02:57 <PacoV> Hi.
04:03:05 <boxscape> hi
04:03:07 <dminuoso> Mmm, promoted gadts... what are these constraints even?
04:03:16 <dminuoso> Does the kind system support constraints too?
04:03:36 <boxscape> dminuoso I don't really think so but it's where my path led me
04:03:54 <dminuoso> The diagnostic certainly reads strangely
04:04:37 <dminuoso> boxscape: Im curious, what are you trying to do here? What is that tyfam supposed to be used for?
04:05:25 <PacoV> I'm looking for someone who know the Hakyll library. I'd like to know if it's possible to use a url field to generate a route. I went to #hakyll but it's been dead for hours so I give here a shot.
04:05:27 <nshepperd> i don't think promoted GADTs are really a thing
04:05:59 <boxscape> dminuoso I'm trying to have an expression type that stores the free variables in that expression at the type level, in an ordered list. So if you combine two expressions, I take the union - and while trying to write that function I had to construct a new proof that one symbol is smaller than another
04:06:24 <boxscape> dminuoso though in retrospect maybe I wouldn't be able to construct a type-level value of that type to begin with
04:07:08 <dminuoso> % data Foo a where MkFoo Int -> Foo Int
04:07:08 <yahb> dminuoso: ; <interactive>:186:24: error: parse error on input `Int'
04:07:12 <dminuoso> % data Foo a where MkFoo :: Int -> Foo Int
04:07:13 <yahb> dminuoso: 
04:07:41 <nshepperd> there's no type level equivalent of  GADT case expressions so even if you could make that 'proof' it would be impossible to do  anything useful with it
04:07:58 <dminuoso> % type family TyF (s :: *) :: Foo s
04:07:58 <yahb> dminuoso: 
04:08:05 <boxscape> RIght, that makes sense, I thought that a case expression is basically needed here
04:08:07 <merijn> boxscape: RIP your sanity :p
04:08:31 <dminuoso> % type instance TyF Int = MkFoo 1
04:08:32 <yahb> dminuoso: ; <interactive>:191:31: error:; * Expected kind `Int', but `1' has kind `GHC.Types.Nat'; * In the first argument of `MkFoo', namely `1'; In the type `MkFoo 1'; In the type instance declaration for `TyF'
04:08:33 <dminuoso> Mmm
04:08:40 <dminuoso> % data Foo a where MkFoo :: Foo Int
04:08:41 <yahb> dminuoso: 
04:08:45 <dminuoso> % type family TyF (s :: *) :: Foo s
04:08:45 <yahb> dminuoso: 
04:08:48 <dminuoso> % type instance TyF Int = MkFoo
04:08:48 <yahb> dminuoso: 
04:08:55 <boxscape> merijn mind you, I would never use haskell type level machinery I'm not allowed to just give up on at the moment :)
04:09:09 <boxscape> for anything I'm not allowed *
04:09:12 <dminuoso> nshepperd: At least its liftable...
04:09:53 <boxscape> dminuoso is that even a GADS under the hood?
04:09:58 <boxscape> GADT, rather
04:10:07 <boxscape> or wait
04:10:10 <boxscape> yes it is
04:11:36 <boxscape> Hmmm maybe I could do it if I were to make my own type-level String type
04:28:50 <boxscape> Is there an UnsafeCoerce for the type level?
04:44:24 * tomsmeding shudders
04:56:20 <ziman> is there an (probably associated) type family that would give me the inner type of a newtype?
04:58:20 <ziman> `Coercible` helps me only when I know the inner type already
04:59:29 <idnar> which crc32 lib do I want?
05:00:52 <idnar> ziman: https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Wrapped.html#t:Unwrapped
05:01:20 <ziman> oh, right, generics, thanks!
05:01:39 <dminuoso> 13:28:28     boxscape | Is there an UnsafeCoerce for the type level?
05:01:56 <dminuoso> You want what?
05:02:27 <boxscape> I'm about 5% certain that it could help me out :)
05:02:50 * Uniaika cocks her musket
05:03:49 <hc> idnar: depends on what you're trying to do
05:04:53 * hackage haskoin-store 0.38.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.38.3 (jprupp)
05:07:20 <hc> idnar: the zip library seems to be using the digest package ( https://hackage.haskell.org/package/digest )
05:07:53 <idnar> hc: I'm implementing this madness: https://docs.kraken.com/websockets/#book-checksum
05:08:34 <hc> ah okay, so you specifically need CRC32. Then I'd say what works for the best zip library available for haskell (afaict) might work for you as well :)
05:10:22 <dminuoso> Wait.. CRC32 is used as a poor mans MAC_
05:10:33 <dminuoso> That's gross.
05:12:18 <idnar> dminuoso: it's more of an actual checksum
05:13:33 <hc> dminuoso: "TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection."
05:13:51 <hc> I'd say one layer of transport security should be enough (though, arguably, tls might not be the best choice;=)
05:14:44 <dminuoso> Im honestly a bit unsure what the CRC32 even helps with.
05:14:52 <hc> nothing, afaict ;p
05:15:23 * hackage subG 0.4.0.0 - Some extension to the Foldable and Monoid classes.  https://hackage.haskell.org/package/subG-0.4.0.0 (OleksandrZhabenko)
05:17:46 <dminuoso> "to verify that your data is correct and up to date"
05:18:08 <idnar> there's an incrementally updated data structure shared between server and client, this lets the client detect an incorrectly applied update
05:18:08 <idnar> but this whole API is madness
05:18:11 <dminuoso> If you feed the CRC32 with bad data, you still get a valid CRC hash...
05:18:46 <dminuoso> So the only thing this seems to protect against, is a modification in transport. But like hc pointed out, TLS gives us the guarantee of no modification already.
05:19:26 <dminuoso> 14:17:46        idnar | there's an incrementally updated data structure shared between server and client, this lets the client detect an incorrectly applied update
05:19:28 <dminuoso> oh
05:19:38 <dminuoso> So this is a poor mans merkle tree?
05:19:49 <dminuoso> With CRC32 instead of a cryptographic hash?
05:19:57 <idnar> sort of
05:20:05 <dminuoso> Shameful. They should just dub it "a blockchain" and make that much more money.
05:20:11 <dminuoso> And trick investors
05:20:22 <hc> lol, true
05:20:43 <int-e> cyclic redundancy blockchain?
05:21:18 <dminuoso> I mean to be absolutely fair, a merkle tree with CRC is a perfectly valid thing to do.
05:21:34 <dminuoso> It just has a much larger attack surface.
05:21:48 <dminuoso> And it gives less guarantees
05:22:14 <dminuoso> If you have a high volume/low latency situation, then it's possible a cryptographic hash might just be too expensive
05:23:23 <int-e> secretly you've always wanted mutable Merkle trees
05:23:49 <hc> =)
05:23:57 <dminuoso> Oh boy. "mutable merkle trees"
05:24:08 <dminuoso> int-e: Can I expect a publication from you about this? :>
05:24:09 <hc> you might even sell it
05:24:27 <hc> too bad the mit paper generator only lets you choose the authors, not title
05:24:32 <dminuoso> https://github.com/EdgyEdgemond/mutable_merkle
05:24:35 <dminuoso> Good lord. This already exists.
05:24:55 * dminuoso scratches his head
05:25:37 <boxscape> hm, I think I can use the symbols library and 26 individual comparison cases (or 64 for upper and lower case + digits) to get a comparison type I can construct at the type level :)
05:25:46 <boxscape> for symbols
05:26:57 <int-e> dminuoso: that's just a persistent data structure, I think
05:27:38 <int-e> (and every update changes the root hash (with high probability, blah), which is how it's supposed to work)
05:27:46 <dminuoso> int-e: I think it's rather sort of like `git rebase -i`, where it just recalculates/resigns the entire tree
05:28:34 <int-e> dminuoso: But it's a tree and you can still reuse the subtrees that haven't changed.
05:29:17 <int-e> (though hmm, the structure has to be very rigid for this to work; so it will have rewrite the whole tree on occasion at least)
05:29:27 <int-e> hve -> have to.
05:29:37 <dminuoso> "sub-trees", you partial nodes from above
05:29:45 <dminuoso> (or partial sub-trees above the mutation points)
05:30:04 <dminuoso> which is pretty much what git rebase does
05:30:38 <int-e> Oh, you're looking at the whole repo as a tree, not just the commit objects as a blockchain.
05:30:42 <dminuoso> right
05:31:07 <dminuoso> (so perhaps rather in the sense of a zipper)
05:31:19 <dminuoso> We could have zippers for merkle trees I guess
05:31:26 <int-e> indeed
05:31:54 <dminuoso> It's an interesting thought. Coupled with lazyness, that could have some nice properties
05:32:23 <dminuoso> Could lead to relatively cheap mutations, even closer to the root, if you dont need the hashes on all the leafs all the time
05:32:36 <dminuoso> I dont just dont have any problems that require merkle trees, sadly
05:32:56 <int-e> I really think the persistent data structure analogy is perfect. The property that is problematic is that they want to ensure that if they have the same key-value map, they also end up with the same root hash, which means they need to have the same underlying tree structure regardless of the history of insertions and deletion.
05:33:23 <int-e> (or is it just keys? I didn't pay enough attention)
05:34:07 <dminuoso> Well, if the hash differs, they wont have the same "ancestory"
05:34:20 <dminuoso> Dunno if merkle trees exist in both directions
05:34:53 <dminuoso> (say where the root of the tree is the cumulative signing of all leafs, or in the other direction where the leafs are the cumulative signing of the entire path from the root)
05:36:21 <dminuoso> oh wait, it's just the first
05:36:27 <int-e> Typeable is based on Merkle trees <-- can't remember seeing it put like that anywhere.
05:38:27 <int-e> (It's not a pure Merkle tree in that there are several node types, and they have varying degree. And you never look at paths from the root, only at the root identity, so... it's not perfect.)
05:43:30 <int-e> Hmm, if you make a perfectly size-balanced binary tree (L <= R <= L+1, where L is the size of the left child and R is the size of the right child) then insertions and deletions should take the usual O(log(n)) time, and you get the property that the tree shape is determined by the number of nodes. In other words, you *can* avoid having to update the whole tree for a single insertion or deletion.
05:46:53 * hackage zydiskell 0.1.0.0 - Haskell language binding for the Zydis library, a x86/x86-64 disassembler.  https://hackage.haskell.org/package/zydiskell-0.1.0.0 (nerded)
06:03:52 * hackage graphula-core 2.0.0.1 - A declarative library for describing dependencies between data  https://hackage.haskell.org/package/graphula-core-2.0.0.1 (PatrickBrisbin)
06:17:52 * hackage flashblast 0.0.9.0 - Generate language learning flashcards from video.  https://hackage.haskell.org/package/flashblast-0.0.9.0 (locallycompact)
07:45:26 <dolio> dminuoso: No, but I think it's close enough. That kind of thing can never be absolutely the case in GHC's type checking, because it doesn't exactly work by 'unification'. A local constraint could always be introduced that allows you to solve an equation between a rigid variable and something else.
07:46:04 <dolio> But it's much longer to say whatever is completely accurate, and is no better for intuition.
07:47:48 <tomjaguarpaw> I'm confused what I'm supposed to do when my package has a library and an executable.  The executable depends on the library, naturally, but if I put it in build-depends then cabal says The package has an extraneous version range for a dependency on an
07:48:07 <tomjaguarpaw> internal library: packagename -any && ==0.0.0.0. ...
07:48:13 <merijn> tomjaguarpaw: Yeah, ignore that
07:48:20 <tomjaguarpaw> Oh OK
07:48:37 <tomjaguarpaw> It's one of those, is it?
07:49:17 <merijn> tomjaguarpaw: Essentially cabal now supports multiple libraries per package too, and one of the (planned, non-existent) features is to allow packages to depend on only *some* libraries of other packages
07:49:54 <merijn> tomjaguarpaw: A weird interaction between code preparing for that future and the current "simply depending on a library in the same package" triggers that warning
07:51:08 <merijn> tomjaguarpaw: I think it's something like "the version is fixed by being in the same package, but other code is inferring it as a constraint and then later on those facts result in 'hey, this (inferred) constraint is extraneous!'"
07:56:44 <tomjaguarpaw> Aha, I see, two constraints from different places
08:06:17 <merijn> Which cabal-install, btw? I think it might be fixed in one of the newest ones
08:07:11 <merijn> 3.2 or 3.4 release candidate, but not 100% I remember that correctly
08:12:02 <hekkaidekapus> merijn: It is not yet fixed, AFAIR. Paging fgaz ^^^
08:14:25 <fgaz> multiple libraries? it pretty much works for source packages
08:15:21 <merijn> fgaz: It was about the "extraneous constraint" warning when your executable depends on a library in the same package
08:15:46 <hekkaidekapus> <https://github.com/haskell/cabal/issues/5119> and <https://github.com/haskell/cabal/issues/5660>
08:16:46 <fgaz> hekkaidekapus: afaik those two tickets have nothing to do with each other
08:17:49 <hekkaidekapus> If an executable depends on a sublib and the warning is emitted, does that not relate to 5660?
08:18:34 <fgaz> this also happens with the main library I think
08:18:54 <fgaz> also 5660 refers to public sublibs
08:19:08 <fgaz> that warning gets triggered on any sublib
08:19:21 <the-smug-one> Hi, I solved a small toy problem for fun in Haskell and uploaded it to my website. It's very "explicit" (passing around state of visited vertices, etc.) and I want to know if there's obvious ways to make it more idiomatic. The link is here: https://jsjolen.github.io/#/structuraltyping the function is isSubtypeOf I'd really appreciate any eyes on it :-).
08:19:40 <hekkaidekapus> fgaz: Right. So, the discussion above was merely about 5119.
08:19:53 <fgaz> According to one of the first comments in #5119, the cause was https://github.com/haskell/cabal/pull/4383
08:25:09 <fgaz> merijn hekkaidekapus: I just read your messages more thoroughly, and yes, I see what you mean, sorry, it was indeed in preparation to public sublibraries
08:25:46 <hekkaidekapus> No problem.
08:27:13 <hekkaidekapus> fgaz: I pinged you since you seem to have taken over A. Williams’s work on public sublibs (beside Oleg, of course).
08:32:47 <p0a> Hello in f >>= g, is it guaranteed that all of the side effects of f will take effect before g's?
08:34:03 <p0a> I'm looking at mapM magic (take 10 [1..]) >>= mapM_ print . takeWhile (< 18) where magic x = print x; return x*2, for example
08:34:12 <tdammers> p0a: there are no side effects
08:34:58 <int-e> ordering of effects (if any) depends on the monad
08:35:17 <int-e> In IO, effects of f will happen before effects of g, with the exception of lazy IO.
08:35:31 <tdammers> there is some kind of implied ordering to >>=, but it's a bit more subtle than "happens before/after"
08:35:49 <int-e> so your code will print 1..10, then 2,4..16.
08:35:53 <p0a> Why is my example not lazy?
08:36:27 <tdammers> it could be lazy, depending on how `magic` is implemented
08:36:52 <p0a> Why is this magic not lazy then?
08:37:04 <tdammers> why do you think it's not?
08:37:18 <int-e> It is lazy. It returns an IO value. It has no effect by itself.
08:37:51 <tdammers> it could return an IO value that specifies a lazy-IO operation though
08:37:56 <int-e> The effects happen when an IO value is run... either from the main function or from another Haskell thread. And that execution sequentializes IO effects.
08:38:00 <tdammers> (lazy IO /= lazy evaluation!)
08:38:41 <Ariakenom> lazy IO isnt different from threads in that sense
08:38:45 <int-e> lazy IO is based on a dirty hack that suspends an IO action to be run when its result is needed
08:39:08 <int-e> :t System.IO.Unsafe.unsafeInterleaveIO
08:39:10 <lambdabot> IO a -> IO a
08:39:24 <Ariakenom> so its not important to bring up as an exception
08:39:29 <p0a> AH, I thought Lazy IO dependent on lazy evaluation or something like that 
08:39:32 <tdammers> my point is that "lazy IO" and an expression being lazy are two different and somewhat unrelated things
08:39:45 <p0a> depended*
08:40:06 <p0a> it's a good point tdammers, I didn't know that 
08:40:15 <int-e> p0a: Oh, it does. Lazy evaluation provides a mechanism to detect when a value is needed.
08:40:31 <tdammers> ^ yeah, this is how they are related, hence "somewhat" unrelated
08:40:45 <p0a> int-e: so the hack is the suspension?
08:40:51 <int-e> yes
08:41:13 <tdammers> without lazy evaluation, lazy IO would be completely transparent, because the value would be demanded immediately, and the "suspension" mechanism used in lazy IO would be undone straight away
08:41:25 <p0a> lazy IO is not visible in the type system though, right?
08:41:29 <tdammers> nope
08:41:37 <tdammers> :t Data.Text.readFile
08:41:38 <lambdabot> error:
08:41:38 <lambdabot>     Not in scope: ‘Data.Text.readFile’
08:41:38 <lambdabot>     No module named ‘Data.Text’ is imported.
08:41:52 <tdammers> @let import qualified Data.Text.IO
08:41:53 <lambdabot>  Defined.
08:41:57 <tdammers> @let import qualified Data.Text.Lazy.IO
08:41:58 <lambdabot>  Defined.
08:42:02 <tdammers> :t Data.Text.IO.readFile
08:42:04 <lambdabot> FilePath -> IO Data.Text.Internal.Text
08:42:10 <tdammers> :t Data.Text.Lazy.IO.readFile
08:42:11 <lambdabot> FilePath -> IO Data.Text.Internal.Lazy.Text
08:42:11 <int-e> :t T.readFile
08:42:13 <lambdabot> error:
08:42:13 <lambdabot>     Not in scope: ‘T.readFile’
08:42:13 <lambdabot>     Perhaps you meant one of these:
08:42:31 <Ariakenom> lazy IO is not popular, recommended or important. although I think its interesting and I've used it for some things
08:42:53 <tdammers> it is important to know that it exists, because you can easily cause some surprising and subtle bugs with it
08:42:53 * hackage phonetic-languages-general 0.3.0.0 - A generalization of the uniqueness-periods-vector-general functionality.  https://hackage.haskell.org/package/phonetic-languages-general-0.3.0.0 (OleksandrZhabenko)
08:43:03 <p0a> I'm trying to learn a bit on conduit 
08:43:15 <int-e> @where L.hs
08:43:15 <lambdabot> what lambdabot has in scope is at https://silicon.int-e.eu/lambdabot/State/Pristine.hs
08:44:10 <int-e> . o O ( nobody needs text )
08:44:45 <dminuoso> lazy IO tends to be useful for short "Im writing a 30 lines one-off program"
08:45:02 <dminuoso> Especially when all you want is in base, so you dont even need cabal to get access to conduit and friends
08:45:21 <p0a> ah I know, it's mapM that guarantees the sequence
08:45:33 <p0a> That's what makes it print 1..10 before going to the doubles 
08:45:51 <int-e> . o O ( And lazy IO is terrible if you want to read the first 100 bytes of all files in your home directory. )
08:46:35 <int-e> (it's a good way to run out of file descriptors)
08:46:59 <p0a> hehe maybe the kernel is lazy too int-e 
08:47:12 <Ariakenom> dminuoso: yeah, like the upcoming #adventofcode
08:48:08 <dminuoso> Ariakenom: Right. If you want to beat those "solution within 30 seconds" folks, then you can't afford to spend a second on creating a cabal project or managing build-depends.
08:49:05 <int-e> main = interact $ ...  is the way to go for rapid one-time-tool development ;)
08:49:41 <Ariakenom> int-e: indeed. the beginning of almost all of my advent coding
08:50:31 <int-e> Ariakenom: right... main = interact $ unlines . return . show . solve . lines
08:51:04 <Ariakenom> ex. interact (show.sum.map read.map words)
08:51:05 <int-e> Ariakenom: (most common `main` from my AoC solutions last year)
08:51:22 <int-e> s/map//
08:51:25 <int-e> err
08:51:29 <int-e> the second, not the first
08:51:53 <int-e> And not having spaces around . is ugly.
08:51:59 <boxscape> Do all haskell packages that are used within a project have to be compiled with the same version of ghc? More specifically, I was wondering if the cached nix haskell binaries are separate for each ghc version
08:52:03 <Ariakenom> for me not because its fast but because its easy dminuoso 
08:52:17 <Ariakenom> int-e: both true
08:52:49 <int-e> (I don't feel strongly about $ ... vs. (...))
08:53:30 <boxscape> With multiline expressions I strongly prefer $
08:53:54 <tdammers> not having spaces around . isn't just ugly, it's also a potential source of bugs
08:54:31 <hekkaidekapus> (Which will be disallowed in future GHC releases.)
08:54:34 <dminuoso> boxscape: Yes
08:54:36 <tdammers> because foo.bar parses as "foo compose bar", but Foo.bar parses as "identifier bar in namespace Foo"
08:54:39 <maralorn> boxscape: Yes and yes
08:54:43 <dminuoso> boxscape: The ABI is unstable
08:54:45 <boxscape> okay, thanks
08:54:49 <int-e> Ariakenom: https://paste.debian.net/1173010/ :-)
08:55:09 <texasmynsted> This might be bike-shedding but I have created haskell templates and noticed that sometimes I have the main files start with a capital and sometimes with a lower case character. 
08:55:19 <dminuoso> boxscape: You can find some of the reasons here https://wiki.haskell.org/Shared_libraries_and_GHC
08:55:27 <maralorn> And even if the former wouldn‘t be true in some specific circumstances, the later i.e. nix builds would probably always depend on the used ghc version.
08:55:28 <boxscape> thanks
08:55:44 <texasmynsted> The modules are always stared with an upper case. What is more common?
08:56:08 <texasmynsted> and why?
08:56:19 <dminuoso> texasmynsted: It's more common that the files/directories follow the casing used in the modules.
08:56:28 <hekkaidekapus> tdammers: foo.bar might also mean field bar of record bar in RecordDotStuff…
08:56:37 <dminuoso> I cant speak for why people do it, perhaps its just consistency
08:56:53 <texasmynsted> So start with an upper case character then?
08:56:58 <p0a> texasmynsted: afiak there's OSes where capital and lowercase make no difference, and it was even proposed for the linux kernel
08:57:07 <p0a> talking about filenames 
08:57:20 <texasmynsted> I am talking specifically about file names.
08:57:21 <tdammers> I like to use lowercase filenames for main, to emphasize the fact that they are not intended to be imported
08:57:35 <sm[m]> I thought all files except the main one had to be capitalised, like the module name
08:57:43 <dolio> That depends on the filesystem, not the OS.
08:57:45 <texasmynsted> tdammers: Ah perfect! Thank you.
08:57:52 <sm[m]> except on case-vague filesystems, of course
08:57:57 <p0a> dolio: thanks, I misspoke
08:58:37 <texasmynsted> I care more that I write the file name deliberately rather than care how the filesystem sees it.
08:58:44 <Ariakenom> int-e: return!? let me show my reaction with a smiley (:[])
08:59:13 <int-e> Ariakenom: I expected you to suggest `pure`
08:59:18 <Ariakenom> but that's very consistent :D
08:59:30 <Ariakenom> yeah but the smiley is funnier
08:59:41 <texasmynsted> tdammers: So is your test suite main file also lower case for the same reason?
08:59:49 <sm[m]> texasmynsted: capitalise all files except main ones
08:59:52 <int-e> Ariakenom: it's hard to type :P
09:00:10 <maerwald> I saw a job posting of a company transitioning from haskell to Go... it made me wonder what happened there. :D
09:00:12 <int-e> while `return` vs. `pure` is a sign of age
09:00:26 <texasmynsted> Okay then the same would go for test "main" files.
09:00:34 <sm[m]> yep
09:00:38 <texasmynsted> :-)
09:00:39 <texasmynsted> Thank you.
09:00:45 <sm[m]> if you look at projects you'll see that's the pattern
09:01:07 <tdammers> int-e: I oscillate back and forth between religiously using 'pure' and consistently using 'return' for things that are monads and reserving 'pure' for non-monad functors
09:01:37 <p0a> I think allowing for bugs is a feature that helps prop development, which may explain why some shy away from haskell
09:01:47 <p0a> not that haskell code can't have bugs
09:02:05 <texasmynsted> tdammers: why not use pure everywhere it applies. It makes more sense.
09:02:14 <int-e> > fix error -- is it bad that this still amuses me?
09:02:15 <boxscape> p0a -fdefer-type-errors :)
09:02:16 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:02:20 <tdammers> texasmynsted: I do that too, but I go through phases.
09:02:30 <texasmynsted> Hehh I understand
09:03:09 <maerwald> p0a: was that in response to me?
09:03:23 <Ariakenom> my first instinct in do-notation is to type return, but I always use pure
09:03:27 <p0a> maerwald: yeah 
09:03:57 <int-e> tdammers: yeah I tend to use `return` for monads, but I think that if I had learned Haskell 10 years later I'd be in the pure `pure` camp.
09:04:03 <maerwald> the only thing I can think of is that they have some low-latency requriements, which GHCs GC cannot deliver
09:05:13 <tdammers> maerwald: it can, just not consistently :P
09:05:47 <maerwald> I remember this is a problem in "real-time" ads bidding I think
09:06:04 <tdammers> oh yes
09:06:04 <p0a> maerwald: my opinion is not molded by experience or shapen by facts, just something I conjured out of thin air. :P 
09:06:15 <tdammers> I definitely wouldn't use Haskell for the tight parts of that
09:06:39 <tdammers> although the parallel GC could probably do it just fine, but it's still kind of icky that reasoning about perf in Haskell is so bloody hard
09:06:48 <maerwald> tdammers: could write it in rust, make a nice C interface and use it in haskell
09:07:04 <tdammers> yeah, write it in whatever performs well enough, and then orchestrate it from Haskell
09:07:12 <tdammers> C, C++, rust, golang, whatever
09:07:26 <maerwald> but a more reasonable assumption might be: their CTO fled the country :p
09:07:32 <tdammers> yeah
09:07:40 <tdammers> IME, it's usually unreasonable expectations
09:07:43 <maerwald> and they were left with an esoteric haskell stack and one junior dev
09:07:58 <boxscape> oh no I upgraded to ghc 8.10 and now the type level code I spent today writing doesn't work anymore
09:08:01 <tdammers> yep. the "unreasonably enthusiastic junior dev" problem
09:08:23 * hackage array-chunks 0.1.2.0 - Lists of chunks  https://hackage.haskell.org/package/array-chunks-0.1.2.0 (andrewthad)
09:08:48 <idnar> is there something like `take` that takes from the end?
09:09:03 <maerwald> not lazily
09:09:05 <maerwald> :p
09:09:16 <merijn> :t \n -> reverse . take n . reverse -- *ducks*
09:09:17 <lambdabot> error:
09:09:17 <lambdabot>     Ambiguous occurrence ‘reverse’
09:09:17 <lambdabot>     It could refer to
09:09:25 <merijn> wut
09:09:27 <merijn> @undefine
09:09:27 <lambdabot> Undefined.
09:09:31 <merijn> :t \n -> reverse . take n . reverse -- *ducks*
09:09:33 <lambdabot> Int -> [a] -> [a]
09:09:52 <maerwald> that's probably fine for small lists
09:09:59 <tdammers> https://hackage.haskell.org/package/extra-1.7.8/docs/Data-List-Extra.html#v:takeEnd
09:10:14 <merijn> maerwald: For big ones to if you do it infrequently enough :p
09:10:37 <tdammers> for very big ones, "infrequently enough" means "once per universe"
09:11:04 <boxscape> not even that if you're dealing with [0..]
09:11:17 <boxscape> unless you count a non-terminating evaluation as "once"
09:11:42 <tdammers> right yeah, if you don't need it to terminate, then you can spawn as many of these as you want
09:12:06 <maerwald> You add RAM as you go
09:12:46 <p0a> that's what scalable means
09:13:00 <idnar> oh I need it reversed anyway and I'm starting with a Map so toDescList + take
09:13:25 <hekkaidekapus> If the list is finite, see also Data.Sequence.
09:13:31 <p0a> What is an example of a simple monad transformer?
09:13:46 <maerwald> p0a: none
09:13:52 <idnar> IdentityT :P
09:14:06 <maerwald> but there are plenty examples of non-simple transformers :p
09:14:11 <p0a> are monad transformers like natural transformations?
09:14:20 <tdammers> there's this concept of theoretical size of information, I don't remember the details, but the idea is to calculate how small you could theoretically make a data store for a given amount of information until you hit the limitations of the speed of light (or quantum physics? it's been a while)
09:14:39 <tdammers> which implies that the amount of information that can be stored in a finite universe is also finite
09:15:10 <koz_> Something something Bekenstein bound.
09:15:16 <maerwald> p0a: check out ExceptT, most other transformers are non-sense anyway
09:15:45 <p0a> maerwald: thank you 
09:16:23 * hackage json-syntax 0.1.2.0 - High-performance JSON parser and encoder  https://hackage.haskell.org/package/json-syntax-0.1.2.0 (andrewthad)
09:16:31 <tdammers> maerwald: ExceptT Dynamic RWST Dynamic Dynamic Dynamic IO, a.k.a. the "I give up" monad
09:17:23 * hackage say-my-name 0.1.0.0 - Require explicit type application for some type variables.  https://hackage.haskell.org/package/say-my-name-0.1.0.0 (mnoonan)
09:18:40 <maerwald> at least we can say that the design space of monads has been exhaustively researched in haskell
09:19:20 <maerwald> many tears have been shed, but it is what it is
09:21:10 <koz_> maerwald: Press F in chat for monads.
09:24:27 <int-e> > let ekat n xs = last $ zipWith const (replicate n xs ++ tails xs) (tails xs) in map (ekat 3) ["", "ab", "abc", "abcd"]
09:24:29 <lambdabot>  ["","ab","abc","bcd"]
09:25:11 <int-e> . o O ( cotake )
09:25:22 * hackage array-builder 0.1.1.0 - Builders for arrays  https://hackage.haskell.org/package/array-builder-0.1.1.0 (andrewthad)
09:26:23 <random> hey guys
09:26:42 <random> is there a way to get all types used by a Servant API?
09:26:46 <random> like, a ready made library or something?
09:30:36 <texasmynsted> Could with write what you can in Haskell and what you must, in C/Rust.
09:30:50 <texasmynsted> oh yikes. I missed much scrollback
09:31:43 <maerwald> Yeah, I think exploring rust and haskell in a single stack is interesting.
09:31:44 <idnar> does `Scientific` preserve trailing zeroes?
09:33:29 <texasmynsted> Yes, that is my plan at least
09:35:52 <texasmynsted> I tried two almost the same projects. One in Haskell and one in Rust. Just to see how they feel and compare. Rust feels verbose and awkward when encountering complexity.
09:35:55 <merijn> idnar: Probably not
09:36:45 <texasmynsted> But when getting closer to the metal language options shrink dramatically.
09:40:30 <merijn> Pet peeve "C is not close to the metal"
09:40:53 * hackage spake2 0.4.3 - Implementation of the SPAKE2 Password-Authenticated Key Exchange algorithm  https://hackage.haskell.org/package/spake2-0.4.3 (rkrishnan)
09:42:01 <dolio> What do you mean? It allows perfectly for my 128-bit machine characters.
09:43:00 <merijn> dolio: Sure, but that wasn't even what I was getting at
09:43:11 <dolio> Yeah, I know.
09:43:26 <hekkaidekapus> |> coefficient (scientific 010 2)
09:43:36 <hekkaidekapus> |> 10 -- idnar
09:43:45 <merijn> C is close to the metal...as long as you don't acknowledge your "metal" changed into a superscalar, deeply pipelined, out of order, speculatively executing CPU about 2 decades ago :p
09:43:59 <texasmynsted> merijn: What do you use for close to the metal projects? Mostly I see C an assembly.
09:44:32 <int-e> vhdl?
09:44:38 <merijn> What I use is C or C++, but don't go around those are much closer to the metal than Haskell or Rust
09:44:54 <dolio> C is heavily-optimized-for.
09:45:02 <merijn> texasmynsted: See also: https://queue.acm.org/detail.cfm?id=3212479
09:45:13 <merijn> Which is conveniently titled "C Is Not a Low-level Language" ;)
09:45:18 <texasmynsted> I have found C++ is too bulky and difficult to control.
09:45:39 <merijn> texasmynsted: In my experience there are two C's
09:45:48 <texasmynsted> okay. I am listening
09:46:22 <merijn> texasmynsted: 1) C, the language that 90% of C programmers *think* they are writing, and 2) C the actual language as defined by the spec and that compilers attempt to implement
09:46:35 <merijn> These two things are, surprisingly *massively* different
09:47:13 <merijn> But you don't notice those difference and if no one ever told you anything about modern CPU design *nor* modern compilers, then I can understand how you might imagine that 2 is like 1
09:47:21 <p0a> the interface with the metal is the compiler, not the language 
09:47:50 <int-e> . o O ( 2) is the thing that turns every C program into a puzzle whether it contains undefined behavior or not )
09:47:55 <texasmynsted> p0a +1
09:48:32 <merijn> p0a: Right, but that just means it becomes impossible to know what code does without also knowing which *exact* version of which *exact* compiler people were using
09:48:38 <int-e> . o O ( or, more realistically, into a puzzle to figure out *why* it contains undefined behavior )
09:48:51 <merijn> The point of having a spec is that you can write code and know what it does *without* error prone trial and error
09:48:56 <dolio> Yeah, the answer is almost always, "it does," no? :)
09:49:07 <texasmynsted> what p0a says aligns with my experience. Typically a manufactured chip has a compiler that will compile a "subset" of C for the chip.
09:49:11 <merijn> dolio: Some cases are super fun, though
09:49:21 <merijn> dolio: Like "whether this code is undefined is implementation defined"
09:49:26 <merijn> dolio: No joke!
09:49:51 <dolio> Really? I didn't notice that when I was reading, but I didn't think too hard.
09:49:58 <merijn> texasmynsted: Right, but then you're not writing C, you're writing a custom ad hoc underspecified DSL that happens to resemble C
09:50:09 <texasmynsted> yes. I understand your point now.
09:50:19 <merijn> dolio: Signed integer overflow is UB, right?
09:50:25 <dolio> Yeah.
09:50:37 <merijn> dolio: Fun fact: the signedness of "char" is implementation defined :)
09:50:42 <dolio> Oh, and you don't know how big they are.
09:51:09 <merijn> dolio: So you can construct code the is signed overflow if char is signed, but whether it is, is implementation defined
09:51:15 <texasmynsted> most things are "implementation defined". The sizes are defined by the chipset
09:51:24 <merijn> texasmynsted: I wish
09:51:29 <dolio> Ah, yeah.
09:51:46 <merijn> If we took the C spec as-is and said "all undefined behaviour is implementation defined" we'd be massively better off
09:52:06 <int-e> implementations with sufficient fire-proofing use unsinged characters
09:52:07 <texasmynsted> Or turn it around. 
09:52:31 <texasmynsted> Okay. I am all in. What language do you propose? 
09:52:46 <merijn> int-e: That's massively inconsistent, though, because all other integers without a sign specifier default to signed
09:52:49 <texasmynsted> Because it will not be C and it will not be Rust and it will not be Haskell.
09:52:53 <int-e> ("unsinged" may be my most common typo when writing C)
09:52:58 <merijn> texasmynsted: For what purpose?
09:53:43 <int-e> merijn: Yes, I agree that was an awful choice.
09:53:54 <texasmynsted> Firmware development. Close enough to the metal that the only code running on the chip is what it specifically written. 
09:54:04 <merijn> texasmynsted: Ivory? :)
09:54:06 <geekosaur> I think I made my editor autofix that one
09:54:09 <int-e> 5 compiler writers in a room, all trying to ensure that their own compiler is standards-compliant.
09:54:13 <merijn> texasmynsted: Haskell based DSL that generates C
09:54:14 <dolio> I think the point was not, "don't use C," but, "don't perpetuate myths about C."
09:54:29 <merijn> dolio++
09:54:53 * texasmynsted facepalm
09:55:27 <Chousuke> I don't see why you couldn't use Rust for firmware development. People seem to be rather interested in doing just that.
09:55:30 <dolio> Because the myths are part of what keep people from developing viable alternatives to C.
09:55:31 <texasmynsted> I have never heard of Ivory. I need to check this out.
09:55:33 <merijn> texasmynsted: dolio: Well, to be fair "don't perpetuate myths" was the mainpoint, but "don't handwrite C whenever you can possibly help it" was a solid 2nd point
09:55:43 <texasmynsted> Is it strict?
09:56:05 <merijn> texasmynsted: It was developed specifically for embedded/systems stuff where you want statically validated properties, but the tooling requires C
09:56:28 <srk> only ivory-backend-c
09:56:36 <merijn> texasmynsted: https://ivorylang.org/ivory-concepts.html
09:56:38 <srk> which uses language-c
09:56:51 <srk> there are other backends for verification purposes
09:57:01 <texasmynsted> Soooo you are writing in a "different" C DSL.
09:57:08 <Chousuke> I mean, the fact that often you *have* to use C for firmware development doesn't mean C is particularly well suited for the task. That's just how it happens to be, for mostly historical reasons. :/
09:57:14 <texasmynsted> that compiles to a C DSL
09:57:23 <merijn> texasmynsted: No, you are writing in *Haskell* DSL :)
09:57:48 <texasmynsted> Okay. You are writing in a Haskell DSL that compiles to a C DSL. 
09:57:53 * hackage zydiskell 0.1.0.1 - Haskell language binding for the Zydis library, a x86/x86-64 disassembler.  https://hackage.haskell.org/package/zydiskell-0.1.0.1 (nerded)
09:57:55 <srk> compiles to C
09:57:56 <merijn> texasmynsted: Developed by a company that develops tools specifically for crypto/embedded stuff
09:57:58 <texasmynsted> And this is better why?
09:58:03 <srk> safe
09:58:18 <srk> and.. embedded in Haskell! :)
09:58:25 <maerwald> why is it safe?
09:58:28 <merijn> texasmynsted: Because that compiler and the people who wrote it are better at C than you are
09:58:35 <srk> (bunch of other things as well)
09:58:45 <texasmynsted> Because if this can sell, the F*** Rust.
09:58:45 <merijn> maerwald: No null pointers (or really heap allocation, tbh)
09:59:02 <p0a> is there heap allocation in firmware?
09:59:04 <texasmynsted> s/the/then/
09:59:05 <maerwald> that's not much to throw around "safe" 
09:59:13 <p0a> I have never programmed anything like firmware, I don't even know what it is
09:59:14 <merijn> maerwald: Define "safe"
09:59:23 <srk> p0a: yup, ivory-tower uses heap for FreeRTOS tasks 
09:59:29 <merijn> maerwald: Definitely safer than hand-written C
09:59:31 <maerwald> merijn: formally verified at least
09:59:33 <merijn> maerwald: Sure, that's not a high bar
09:59:49 <merijn> maerwald: It plugs into formal verification tools as possible backends, that's one of the points/goals :p
10:00:01 <texasmynsted> Example: I have written firmware to control the hardware in a water meter and let the water meter communicate over radio.
10:00:13 <merijn> maerwald: Per the Ivory webpage: "The C language backend supports rendering Ivory assertions for static checking with the CBMC model checker. The SMACCMPilot project build system includes integration for CBMC verification of the SMACCMPilot source code."
10:00:17 <merijn> We also provide our own symbolic simulator for verifying Ivory assertions using CVC4.
10:00:32 <texasmynsted> I have written code for the head unit in automobiles
10:00:40 <maerwald> ok, you're all hired :p
10:00:40 <p0a> srk: I had no idea how 'large' firmware can be. I didn't know OSes run on them. I know very little about it :P 
10:00:49 <texasmynsted> That is what I mean by firmware
10:01:13 <merijn> texasmynsted: Iirc Ivory was originally developed for crypto/firmware applications for DARPA/US Dept of Defense
10:01:46 <merijn> texasmynsted: So it's *very* much intended for stuff like "car firmware"
10:01:53 <texasmynsted> maerwald: Excellent. What are we building?
10:02:04 <maerwald> a stupid backend :D
10:02:13 <p0a> nice!
10:02:15 <merijn> Oh, that's easy
10:02:20 <merijn> I've build tons of those
10:02:40 <srk> p0a: depends, I'm typically using STM32 MCUs ranging from 8kb to 512kb SRAM (64kb - 1/2Mb flash)
10:02:48 <texasmynsted> maerwald: More specifically please. That pretty much describes everything.]
10:03:09 <maerwald> I dunno... is there anything other than backends out there?
10:03:17 <merijn> p0a: It depends on your chip too
10:03:35 <monochrom> merijn: Do you happen to know why they chose the name Ivory? Is it about "yes this is from the ivory power, bite me"? :)
10:03:37 <merijn> p0a: Embedded chips powerful enough to run regular linux or pretty cheap
10:03:43 <merijn> monochrom: Probably?
10:03:50 <srk> it's explained in one of the papers
10:04:05 <merijn> monochrom: Considering there's an associated language mentioned on their website called "tower"...
10:04:06 <srk> something like 'to bring embedded development down from ivory tower'
10:04:14 <monochrom> hahaha neat
10:04:26 <monochrom> thanks merijn and srk
10:05:10 <merijn> monochrom: That's why the clash people had to figure out something else to name clash ;)
10:05:20 <merijn> (statement not actually based in facts)
10:05:30 <monochrom> hahahahaha name clash
10:06:17 <texasmynsted> Hmm. I would love to see people describe their experience with various commodity chips. 
10:06:40 <merijn> I'm just sad Habit died
10:07:03 <monochrom> In other news, today I showed my students the fibonacci joke "This Fibonacci joke is as bad as the last two you heard combined." and the originating tweet URL https://twitter.com/sigfpe/status/776420034419658752
10:08:40 <merijn> heh, so according to reddit Haskell job openings it's "hard to find people with 5+ years experience", so clearly I need to start demanding rockstar salary by now >.>
10:09:26 <Ariakenom> texasmynsted: A colleague had an awesome patch for an avr8. It just rearranged members in a struct.
10:10:01 <texasmynsted> merijn: You should.
10:10:24 <Ariakenom> the compiled code was smaller because the members were in nicer locations. he find out where to place them by trying all of them in a script
10:10:34 <texasmynsted> Where do you work?
10:11:03 <Ariakenom> we needed that because we were running out of flash storage on them
10:11:06 <merijn> texasmynsted: Well currently I don't write Haskell to begin with, or rather, at least not officially :p
10:11:14 <texasmynsted> What?
10:11:17 <texasmynsted> That is crazy
10:11:25 <texasmynsted> What do you write?
10:12:00 <maerwald> IRC
10:12:04 <texasmynsted> So like many of us Haskell is your guilty pleasure?
10:12:04 <maerwald> look at his IRC stats
10:12:07 <maerwald> :p
10:12:07 <merijn> maerwald: shush
10:12:08 <texasmynsted> LOLOL
10:12:13 <p0a> Ariakenom: can't you just pack a struct?
10:12:27 <merijn> maerwald: dminuoso is still in first because (thank god) Chris Done's ircbrowse stats got lost
10:12:46 * tomsmeding . o O ( it will grow over time )
10:12:50 <texasmynsted> I think you could argue you are promoting your haskell mentoring 
10:13:02 <Ariakenom> p0a: it wasnt to reduce memory. it was to reduce code size :D
10:13:26 <merijn> texasmynsted: Currently C, C++, Fortran90, Python, within the organisation probably "basically everything besides, like, PHP and perl" :p
10:13:32 <texasmynsted> His handle must not be chrisdone
10:13:57 <texasmynsted> Fortran90. Interesting. 
10:14:12 <merijn> texasmynsted: That's for the lucky people not dealing with Fortran77 :p
10:14:33 <p0a> Ariakenom: I'm confused, but I believe you :)
10:14:42 <texasmynsted> I am trying to determine where you work where Fortran90 would be used. . . 
10:14:54 <merijn> texasmynsted: Oh, I still write Haskell stuff at work, because no one's around to tell me no :p
10:16:57 <texasmynsted> Well it sound interesting 
10:18:59 <texasmynsted> I like how some people say they use Haskell for "prototyping"
10:20:26 <dolio> Haskell is too mainstream for prototyping.
10:20:34 <dolio> Prototype your Haskell stuff in Agda.
10:20:55 <texasmynsted> or Idris
10:21:20 <dolio> Yeah. Although if you prototype in Idris you might find you can just use the prototype. :þ
10:21:57 <texasmynsted> yes. That is the point. A Haskell prototype likely works better and is more maintainable than the target language 
10:22:22 <monochrom> Programmers seldom grow out of their prototypes.
10:22:31 <merijn> Prototype in Haskell, because we all know prototypes become production and never stop, so now they gotta hire more haskellers to support it
10:22:36 <merijn> Boom. Haskell shop
10:22:44 <monochrom> Especially, a lot of FOSS software is intentionally forever in beta.
10:23:13 <texasmynsted> If only I could think of an app to write.
10:23:13 <merijn> monochrom: My FOSS isn't in beta. It's "free as in puppies"
10:23:27 <texasmynsted> If I could ever think of one I would do it.
10:23:40 <geekosaur> does it breed like them, too?
10:23:44 <merijn> monochrom: You can pick it up for free, but you'll have to pay to get it fixed ;)
10:23:50 <monochrom> Namely, those who follows ESR's bazaar model. The bazaar model is euphemism for intentional perpetual beta.
10:23:54 <dolio> Commercial software doesn't really seem that different from the inside.
10:24:18 <dolio> You only believe it's not still in beta because you bought it.
10:24:30 <texasmynsted> The difference is in that you paid for it.
10:24:32 <geekosaur> there is that, isn't there?
10:26:57 <dolio> I guess people pay for beta commercial software these days, too.
10:27:05 <merijn> monochrom: You might like PHK's take: https://queue.acm.org/detail.cfm?id=2349257 :)
10:27:10 <monochrom> Right, I don't contend that.
10:27:40 <dolio> At least video games. Lots of people buying perpetual beta games. :)
10:29:22 <texasmynsted> I buy books from manning that are not even to alpha stage yet
10:38:22 <maerwald> video games is a brutal industry anyway
10:38:58 <texasmynsted> video game industry is a gold rush
10:42:59 <idnar> hekkaidekapus: aha
10:45:25 <hekkaidekapus> idnar: Are you parsing stuff? I’m wondering whether you are actually after Data.Fixed.
10:47:20 <idnar> hekkaidekapus: JSON numbers, kinda
10:47:43 <hekkaidekapus> Parsing it is, then.
10:51:22 <hekkaidekapus> @hackage scientific-notation <== idnar: Check out that.
10:51:22 <lambdabot> https://hackage.haskell.org/package/scientific-notation <== idnar: Check out that.
10:51:27 <idnar> hekkaidekapus: I'm implementing this madness: https://docs.kraken.com/websockets/#book-checksum
10:53:00 <idnar> hekkaidekapus: ooh this is handy
10:55:44 <idnar> hekkaidekapus: thanks!
10:56:42 <dminuoso> idnar: You could also look at https://hackage.haskell.org/package/scientific-0.3.6.2/docs/Data-Scientific.html which is what aeson uses
10:56:52 <hekkaidekapus> You’re welcome. That Kraken thing has speed requirements. You will appreciate this line: “The scientific-notation parser outperforms the scientific parser that ships with aeson by a factor of five on small numbers.”
10:57:21 <hekkaidekapus> dminuoso: Raced :) ^^^
11:03:03 <idnar> hekkaidekapus: yeah, for what I'm doing, it's very useful to have a fast parse to something I can do trivial ops on; I need a more complicated conversion after that, but the converted values often go unused so I don't have to pay
11:04:18 <idnar> dminuoso: I am currently parsing to that :)
11:07:42 <idnar> hekkaidekapus: blah, I could do with an Ord instance though
11:09:09 <hekkaidekapus> The parsed numbers are not meant to be used as such. Refer to the ‘Consume’ section of haddocks instead.
11:23:59 <mastarija> I'm having some trouble writing instances for generics.
11:24:18 <mastarija> I have these two instances
11:24:20 <mastarija> instance {-# OVERLAPPABLE #-} EncOpaque' v => EncOpaque' ( S1 s v ) where
11:24:27 <mastarija> instance EncOpaque' v => EncOpaque' ( S1 ('MetaSel ( 'Just f ) x y z ) v ) where
11:24:54 <mastarija> problem is that in the second I want to get name of the field 'f'
11:25:05 <mastarija> for that I have to use Selector class
11:25:15 <mastarija> if I do something like this:
11:25:37 <mastarija> instance ( Selector s , EncOpaque' v ) => EncOpaque' ( S1 s v ) where
11:26:09 <mastarija> then i can't match instance to specific case where s is 'MetaSel ( 'Just f ) x y z 
11:26:20 <jle`> i would recommend trying to avoid overlappable instances if possible
11:26:32 <jle`> but in your case it looks like you just need a Selector ('MetaSel ('Just f) x y z) constraint
11:26:50 <mastarija> oh
11:26:53 <mastarija> I'm an idiot
11:27:12 <mastarija> I was trying things like ( Selector s , s ~ ( 'MetaSel ( 'Just f ) x y z ) , EncOpaque' v )
11:27:13 <glguy> You could avoid the overlap by expanding the other instance to match on Nothing
11:27:27 <jle`> yeah, or enumerate whatever you would want to exclude
11:27:46 <mastarija> glguy, yes that was the next step but I had a brain freeze on this problem
11:27:52 <mastarija> thanks
11:28:25 <jle`> np :)
11:28:41 <jle`> hm, why is there no type family to compare Type's :'(
11:28:46 <jle`> there is an Ord instance for TypeRep
11:28:49 <jle`> so it should be possible
11:29:52 * hackage bank-holidays-england 0.2.0.6 - Calculation of bank holidays in England and Wales  https://hackage.haskell.org/package/bank-holidays-england-0.2.0.6 (dten)
11:32:01 <mastarija> jle`, quick question, with your suggested solution I'm getting a simplifiable constraint warning
11:32:45 <jle`> what's the warning?
11:32:52 <mastarija>  The constraint `Selector ('MetaSel ('Just f) x y z)' matches instance (SingI mn, SingI su, SingI ss, SingI ds) => Selector ('MetaSel mn su ss ds
11:33:16 <mastarija> jle`, SingI is not exported from Generics module so I can't use it
11:33:27 <jle`> hm, that's interseting. i guess it's saying that you can use those constraints instead of Selector
11:33:30 <jle`> is it from the singletons library, maybe?
11:33:44 <mastarija> No, I think it's something ad hoc from Generics module
11:34:09 <mastarija> I also thought it's from singletons, but generics defines its own SingI class
11:34:11 <jle`> whoops
11:34:19 <jle`> then yeah, you can't really do anything about that
11:34:24 <jle`> that i know of
11:34:28 <mastarija> :D
11:34:34 <mastarija> thanks anyway
11:34:53 <jle`> np D:
11:37:05 <glguy> mastarija: just merge the two instances into one
11:37:05 <mastarija> jle`, when I enable GADTs (and MonoLocalBinds) the warning goes away
11:37:14 <jle`> oh nice
11:37:31 <glguy> Check if selName is "" and branch on that
11:38:19 <mastarija> glguy, I was thinking about it, but it kind of seemed messy and I'd had to do a lot of extra work in other instances
11:38:25 <mastarija> Dunno, will think about it
11:44:59 <gehmehgeh> Am I correct in that Data.Map doesn't have a function to see whether or not a Data.Map is empty? Meaning, you *have* to compare with an empty Data.Map?
11:45:08 <merijn> It does
11:45:18 <gehmehgeh> ah?
11:45:20 <merijn> Probably "null"?
11:45:23 <merijn> :t M.null
11:45:28 <lambdabot> M.Map k a -> Bool
11:45:30 <gehmehgeh> ah!
11:45:33 <gehmehgeh> Thank you!
11:45:41 <gehmehgeh> (Sorry, I was a bit confused)
11:46:10 <gehmehgeh> I *did* look at https://hackage.haskell.org/package/containers-0.3.0.0/docs/Data-Map.html, but missed it somehow..
11:46:15 <gehmehgeh> Thanks :)
11:46:18 <davean> gehmehgeh: Is there something that could have made that more obvious?
11:46:25 <merijn> gehmehgeh: Note the "module Data.Map.Lazy" line there
11:46:37 <merijn> gehmehgeh: That indicates a re-export of stuff from Data.Map.Lazy
11:46:59 <merijn> gehmehgeh: There's some work in haddock to make re-exports more obvious, but it's not done yet, I think?
11:47:27 <merijn> gehmehgeh: So most of the actualy API of Map is Data.Map.Lazy and Data.Map.Strict
11:47:34 <gehmehgeh> davean: no, it was my fault. I simply overlooked the word "empty" in one instance of the website. THis normally doesn't happen to me ;)
11:48:18 <gehmehgeh> It even says: "O(1). Is the map empty?"
11:48:44 <merijn> gehmehgeh: Comparing with == would be bad, because that doesn't work if your values aren't an instance of Eq :)
11:48:45 <glguy> davean: naming it isEmpty instead of null could help
11:48:54 <gehmehgeh> merijn: That's exactly right.
11:49:00 <gehmehgeh> merijn: This is actually why I asked.
11:49:17 <merijn> glguy: On the one hand, yes. On the other hand "null" is consistent across a whole bunch of packages and Foldable currently
11:49:58 <glguy> Yeah, it's a shame we got stuck with that name due to inertia
11:50:15 <merijn> It's a shame that we're stuck with lots of things due to inertia :)
11:50:34 <monochrom> One of the rare instances when Scheme is admirable because it allows the name to be "null?"
11:51:02 <dolio> Yeah, I wish we could put question marks in names.
11:51:12 <merijn> Braindead specification of Enum, god awful Enum instance for Double, lack of API for safely handling over-/underflow in numerical conversions
11:51:31 <dminuoso> Given `f :: a -> (Word32 -> P -> b) -> b`, I wanted to move `(Word32 -> P -> b) -> b` into a type alias, but that suddenly requires RankNTypes, is there a different route without demanding that extension everywhere?
11:51:37 <davean> ∅?
11:51:38 <merijn> The inability to mix qualified imports and import lists
11:52:02 <merijn> dminuoso: "add a type variable to the alias"?
11:52:08 <dolio> You can mix those, I think.
11:52:20 <merijn> dolio: You can, but what that does is dumb as hell
11:52:31 <davean> merijn: So I REALLY don't like our numerical tower.
11:52:33 <merijn> dolio: That just means you only import those names qualified
11:52:42 <dolio> Oh, I see what you mean.
11:52:43 <merijn> davean: I don't like it, but fixing that is less obvious
11:52:50 <merijn> davean: So I'm willing to firgive that
11:52:56 <monochrom> merijn: Are we listing a few warts of Haskell now?
11:53:24 <merijn> dolio: Haskell would be so much better if I could write "import qualified Data.Map as M (Map)" and having "Map" imported unqualified :(
11:53:33 <davean> merijn: I think theres a few obvious ones. It depends on if you're willing to evolve it (it doesn't seem we are) or insist on jumping to a perfect solution.
11:53:55 <merijn> davean: I haven't seen any "improvements" that were "strictly better"
11:53:55 <monochrom> I just have one to gripe about, all the others I really don't mind. This one: The tendency of the community to pretend that it is a dependently typed language.
11:53:58 <dolio> I think most of the 'perfect solutions' are probably actually not that good.
11:54:05 <merijn> monochrom: Oh, definitely
11:54:09 <merijn> dolio++
11:54:26 <davean> merijn: well making it so most Num instances don't have undefineds ...
11:54:27 <dminuoso> merijn: Mmm, I dont like that either. 
11:54:40 <dolio> They generally assume that borrowing dozens of mathematical classificationsn is good.
11:54:41 <monochrom> Ah yeah that would be a nice feature merijn.
11:54:41 <merijn> I don't want "mathematically accurate" I want "useful for practical things in the real world" :p
11:54:49 <dminuoso> Ah, perhaps I can just stick it in a newtype, that would only require RankNTypes on the definition site
11:55:18 <merijn> Who gives a fuck that double operations aren't associative? Just let me safely turn Int64 into Int32 in a remotely safe and sane way...
11:55:52 <monochrom> But I think I have a better syntax. Here is the full form, and you can omit various parts: import Data.Map (Map, (!)) qualified as M (null, insert)
11:56:11 <merijn> monochrom: That would require a change to the parser, etc.
11:56:21 <monochrom> likewise for hiding, e.g., import Data.Map hiding (null) qualified as M hiding (insert)
11:56:41 <monochrom> Yeah I know, but it is both more complete and less ambiguous
11:56:42 <merijn> Qualified re-exports would be a killer feature too, tbh
11:56:56 <monochrom> I mean s/less ambiguous/more guessable/
11:56:58 <geekosaur> but it's not an incompatible change
11:57:14 <geekosaur> I think qualified re-exports require help from the linker though
11:57:17 <merijn> geekosaur: Which one?
11:57:43 <geekosaur> monochrom's suggested import syntax
11:57:53 <merijn> monochrom: Actually, I have a major objection to your proposed syntax
11:59:08 <merijn> monochrom: You violated the key principle (that IMO should be a core value in syntax design) of "accommodate a non-awkward way of linewrapping this when import lists get long..."
11:59:21 <dolio> Didn't one of the recent versions add an option for 'qualified' later in the import?
11:59:27 <merijn> Haskell's current syntax fails that horribly too
11:59:49 <merijn> dolio: All that does is let you write "import Data.Map qualified" instead of "import qualified Data.Map"
11:59:56 <dolio> Right, okay.
11:59:57 <davean> merijn: Don't like int-cast?
11:59:58 <merijn> gratuitously breaking all haskell source/parse thigns
12:00:37 <monochrom> I think my proposal respects that principle.
12:00:37 <merijn> davean: The fact that it's not built into Num is gross negligence
12:01:01 <merijn> monochrom: How do you line wrap when the import list becomes, like, 10 entries long?
12:01:17 <davean> merijn: but we don't have to build it into Num, and I don't think it makes sense to. A lot don't have sensible conversions?
12:01:33 <merijn> davean: Also, no, int-cast's intCastMaybe isn't good enough
12:02:09 <merijn> Ideally you have "intCastDynamic :: (Integral a, Integral b) => a -> Either (a, b) b"
12:02:20 <merijn> i.e. don't just fail, give me the max possible value + remainder
12:02:37 <merijn> That's much more useful
12:03:01 <monochrom> https://paste.tomsmeding.com/Fxc7LZRQ
12:03:13 <merijn> davean: We have fromIntegral in Num
12:03:16 <davean> monochrom: its built in to https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bits.html Because thats where it makes some sense.
12:03:38 <merijn> eh, fromInteger, I mean
12:03:54 <merijn> Why is having only an unsafe fromInteger better/more sensible then a checking variant?
12:04:18 <merijn> monochrom: Yeah, that's a super ugly and awkward way to line wrap :p
12:04:46 <monochrom> OK, what is a nicer way to line-wrap?
12:04:51 <davean> merijn: why is "negate" there too? Because Num is broken.
12:04:55 <merijn> I haven't thought of one yet
12:05:14 <merijn> davean: Didn't you *just* say that "it's broken" wasn't a reason to not improve things? :p
12:05:40 <monochrom> What is super ugly and awkward about it?
12:05:45 <davean> merijn: yes, but you asked why "fromInteger" is there, I think "Num wasn't thought out, and is fundimentally broken" is the reason.
12:06:04 <merijn> davean: "to convert numerical literals" is why
12:06:17 <merijn> But converting numerical literals in a silently corrupting way is bad
12:06:19 <juri_> davean: try looking at Rational sometime.
12:06:25 <davean> juri_: Trust me I have
12:06:35 <merijn> Actually, what we *really* need is https://hackage.haskell.org/package/validated-literals built into base
12:06:37 <davean> MOST of my problems programming Haskell these days come from our Numeric classes being wrong.
12:06:45 <merijn> or rather, GHC
12:06:49 <davean> You simply can't be generic in your number type with Haskell's tower.
12:06:55 <davean> Because all the classes are just lies.
12:07:49 <unfixpoint> I'm having problems with some data type that uses RankNTypes.. I'm trying to abstract the way I connect to a database with holding `(Connection -> IO a) -> IO a` in a reader thing.
12:08:02 <unfixpoint> I condensed the problem to this: https://pastebin.com/raw/geEHaeFk
12:08:27 <merijn> unfixpoint: That's not a RankNType, that's an existential
12:08:40 <merijn> Which means the forall is in the wrong place
12:08:58 <merijn> Because it's current location already has an implicit one in haskell
12:09:09 <monochrom> I'm pretty sure all you need is exposing the "a" as a type parameter.
12:09:09 <unfixpoint> Though the errors slightly changed, now it says '(Connection -> IO a1) -> IO a1' cannot be matched with '(forall a. (Connection -> IO a) -> IO a)' but in the actual problem it is 'a' cannot matched 'a0'
12:09:31 <monochrom> data R a = R ((Connection -> IO a) -> IO a)
12:10:08 <koz_> Am I the only person who mis-spells Data.Vector's (!?) as (?!) all the time?
12:10:34 <monochrom> Heh. Yesterday I kept misspelling "dictionary" as "directory".
12:10:52 <koz_> monochrom: Lol... some similarities there for sure.
12:11:12 <merijn> unfixpoint: Anyway, RankN isn't what you want here, you either want existential quantification or just a parametric 'R' as monochrom suggests
12:11:14 <unfixpoint> monochrom: Not sure if it will work?
12:11:51 <unfixpoint> But when I write it GHC yelled at me I should be using RankN. Is Existential implied by RankN
12:11:53 <unfixpoint> ?
12:12:22 <merijn> No, they're different things
12:12:47 <merijn> unfixpoint: "GHC tells you to enable extension X" is only loosely correlated with "actually needing/wanting X"
12:12:53 <monochrom> That's an XY problem.
12:13:10 <merijn> unfixpoint: GHC guess you need RankN from what you *wrote*, not from what you *want*
12:13:22 <monochrom> Are you an expert?  Because GHC suggestions assume you're an expert and you merely made a typo.
12:13:47 <gumbish> XY problem?
12:13:59 <tomjaguarpaw> I think that's a YX problem.
12:14:05 <monochrom> It never realizes that 99% of these errors are because you made a wrong design and you tried an overkill.
12:14:08 <merijn> gumbish: https://xyproblem.info/
12:14:10 <unfixpoint> monochrom: I'm not trying to argue this, not an expert
12:14:37 <unfixpoint> tomjaguarpaw: What do I actually want to do?
12:14:39 <geekosaur> ghc has to guess what you intended from what you wrote. In this case its guess was wrong
12:15:59 <merijn> unfixpoint: That depends what your intention for 'R' is
12:16:00 <geekosaur> It doesn't try very hard because it can't really know what you intended, it just went by what would make what you wrote syntactically correct. But only syntactically, not semantically
12:17:16 <unfixpoint> The 'R' basically holds information how to connect among other things (ie. has other fields as well)
12:17:53 <merijn> unfixpoint: Right, but why does the 'a' have to be hidden? Why does monochrom's suggestion of just writing 'R a' not work?
12:18:06 <unfixpoint> I could in theory have a `data R = R { connectInfo :: (Host,Port,Creds) , ... }` actually
12:18:53 * hackage haveibeenpwned 0.2.0.0 - Library for checking for weak/compromised passwords.  https://hackage.haskell.org/package/haveibeenpwned-0.2.0.0 (abrar)
12:19:16 <unfixpoint> It was a question, I'm not sure whether it will work.
12:19:58 <merijn> unfixpoint: You can certainly do *that*, because I have, but that sounds more like something where you'll want existentials, depending on the exact design
12:20:44 <unfixpoint> geekosaur: I'm sure someone meant well with those error messages (probably a lot of work), but maybe it should only try what is possible or make sure that the error is actually what it says.
12:21:07 <merijn> the error is what it is, the suggested fix isn't always
12:21:12 <unfixpoint> merijn: I see, I'll try where I get from here.
12:21:29 <monochrom> This is why IMO such "helpful" hints are evil.
12:21:33 <merijn> unfixpoint: I like to call that "OO" Haskell
12:21:48 <monochrom> And I say that the poeple who promoted those hints are do-gooders.
12:21:52 * hackage haveibeenpwned 0.2.0.1 - Library for checking for weak/compromised passwords.  https://hackage.haskell.org/package/haveibeenpwned-0.2.0.1 (abrar)
12:21:53 <unfixpoint> Wait, why OO-Haskell?
12:21:55 <merijn> unfixpoint: persistent uses it, so maybe you wanna have a alook at what they do
12:22:30 <merijn> unfixpoint: Because having a datatype that exposes abstract API that you can use without knowing its internals is basically just OO interfaces? :)
12:22:54 <dminuoso> Unsure what that has to do with "object oriented" though
12:23:02 <dminuoso> That's just encapsulation. :)
12:23:09 <unfixpoint> I guess that's true, yeah. I always considered typeclasses as that
12:23:52 <merijn> unfixpoint: I find typeclass rather "entirely unlike OO" the more you consider them :)
12:24:06 <merijn> unfixpoint: You might wanna look at this and the code that uses it to get inspiration? https://github.com/yesodweb/persistent/blob/a819276a883b89ac898bf61ff7a1cc8a8bf3cd50/persistent/Database/Persist/Sql/Types/Internal.hs#L79-L181
12:24:21 <unfixpoint> The interface part though.
12:24:28 <dminuoso> merijn: Arguably, the core theme that makes OO OO, is one of two things. It's either smalltalk-esque message passing, or its subtyping. Or a combination of both. The "methods" and "internals/externals" is just language ergonomics that has nothing to do with object orientation.
12:24:47 <unfixpoint> merijn: ty!
12:24:59 <merijn> unfixpoint: And how it gets used: https://github.com/yesodweb/persistent/blob/master/persistent-sqlite/Database/Persist/Sqlite.hs#L222-L278
12:25:22 <dminuoso> That is, whether you write `f->g()`, `f.g()`, `f(g)`, `g f` these are just visual considerations, trying to nudge your thinking into one direction
12:25:32 <boxscape> it's weird, sometimes programming with type families actually feels more convenient than with regular functions, because they already support visible dependent as well as relevant quantification without Singletons
12:26:12 <boxscape> Though I imagine I'll lose that feeling once I actually start writing term-level functions that use these type families ....
12:28:31 <unfixpoint> Not sure if he's right (he was kind of arrogant) but my prof claimed the invention of *information hiding* and his language (Eiffel) sure was/is OO
12:29:03 <unfixpoint> Then again just because an XY-language introduces a feature doesn't mean it's inherent to XY-languages
12:29:09 <boxscape> OO means many different things to different people, especially the person who came up with the term
12:29:11 <ski> abstract data types is also about "information hiding" (and is different from OO)
12:29:33 <dminuoso> unfixpoint: information hiding can appear at many different levels. it can happen across systems, architecturally, across libraries, modules
12:30:39 <ski> with parametric polymorphism and type classes, you can say `maximum :: Ord a => [a] -> a'. you can't really say that, with OO
12:30:59 <dminuoso> Well.. you can..
12:31:22 <dminuoso> elixir protocols explore that mixture
12:31:52 <ski> with bounded polymorphism, you can say something akin to that. but that's assuming you also have (bounded) parametric polymorphism
12:32:01 <unfixpoint> interface Ordering<X> { maximum :: List<X> -> X } or something. I haven't OO'ed for a while
12:32:19 <ski> right, the `<X>' there implies parametric polymorphism
12:32:50 <unfixpoint> Lol true, so which OO-language doesn't have parametric polymorphism then?
12:33:02 <dminuoso> C++ for starters
12:33:05 <merijn> unfixpoint: Some do (in some forms)
12:33:19 <monochrom> The <X> was definitely alien to OO.
12:33:20 <merijn> unfixpoint: Java/C# generics are (basically) parametric polymorphism
12:33:21 <dminuoso> The existence of template specializations puts a nail into that coffin.
12:33:50 <merijn> oh, wait, the question was "which doesn't"
12:33:58 <merijn> Python :p
12:34:12 <dolio> Java didn't have it until version 5.
12:34:42 <monochrom> Java learned <X> from Wadler's Pizza. Not even from C++.
12:34:42 <boxscape> seems kind of weird to even ask the question of whether a language without static typing has parametric polymorphism
12:34:57 <ski> OO bundles methods with an object. type classes doesn't do that
12:35:01 <boxscape> It's quite possible that the correct answer is "no" but it almost feels to me like it should be "undefined"
12:35:01 <monochrom> perhaps apart from borrowing the notation
12:35:52 <monochrom> A dynamically typed language has maximum polymorphism and non-existent parametric.
12:36:04 <boxscape> I see
12:36:22 <monochrom> (To remind you that there are many different, conflicting polymorphisms, too.)
12:36:32 <dminuoso> unfixpoint: Also recall, there's two different notions of "object-oriented". One is the heritage ranging all the way back to smalltalk, and the other with simula (they both have possibly more ancient ancestors)
12:36:51 <ski> @where on-understanding
12:36:51 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
12:37:38 <dminuoso> Often nowadays people understand it as the second, as class with inheritance and everything that belongs to it, though the original idea largely influenced by Alan Kay and others is more about message passing.
12:38:33 <dminuoso> Very broadly where program parts are conceptual objects with internal state, exchanging messages and thus interacting with each other
12:38:55 <dminuoso> A style certainly not respected by Java enthusiasts as much
12:38:56 <boxscape> https://i.imgur.com/iag7eoN.png
12:38:58 <unfixpoint> I understand it as the latter then, message passing is separate to me. But I'm young it seems (certainly did I never program in Java 5)
12:40:52 <ski> given `interface Counter { int tick(); void reset(); }' in Java, the object type `Counter' corresponds in Haskell to `exists a. Counter a *> a', assuming `class Counter a where tick :: a -> IO Int; reset :: a -> IO ()', alternatively corresponds to `exists a. (a,a -> IO Int,a -> IO ())'
12:41:22 <dolio> You can tell most OO folks don't care about the smalltalk perspective, because if they did, they'd be all about proper tail calls.
12:41:36 <dolio> Instead they use loops they borrowed from C.
12:42:33 <ski> `exists a. Counter a *> a' expresses "bundling methods with object state". but in Haskell, we can also express e.g. `exists a. (Ord a,Widget a) *> [a]' where we bundle not an individual object with methods, but rather attach them to a whole collection of objects
12:44:31 <ski> (in the case of `exists a. (a,a -> IO Int,a -> IO ())', a shorter way (normally implemented by closures) to express this is `(IO Int,IO ())' .. but this method of removing the existential doesn't always work, e.g. if some method take multiple `a's as input (so-called "binary methods", like a comparision. also see "clone methods"))
12:45:27 <unfixpoint> Why *> instead of =>? Never used the singletons but in this case is it not the same?
12:45:41 <ski> not at all the same, rather the "opposite"
12:46:42 <boxscape> does it actually have to do with singletons?
12:46:43 <unfixpoint> So given [a] we can Ord and Widget it? Instead of Given that we can Ord, Widget an a we have [a]? Wat?
12:47:23 <unfixpoint> Idk, I didn't know (*>) as type operator so I looked it up on Hoogle 
12:47:31 <dminuoso> unfixpoint: It's not, it's pseudo haskell
12:47:48 <ski> if you have `foo :: Blah => ...', then the caller/consumer/user of `foo' must provide evidence of `Blah', before being able to call/use `foo' (with type `...'). and the callee/implementor/producer of `foo' can simply take the evidence of `Blah' for granted, can e.g. call methods (and other operations relying on those methods) from `Blah'
12:47:52 <boxscape> (the singletons version is just the lifted version of Applicative's *>)
12:47:59 <dminuoso> If we had exists in addition to forall, then it'd make sense to have a *> variant of => instead
12:48:27 <dminuoso> Not even sure who introduced the syntax of *>, but I wouldn't be surprised if it was ski themselves. :)
12:48:39 <monochrom> It's related to: "for all positive x, P(x)" = "for all x, positive x implies P(x)", but "for some positive x, P(x)" = "for some x, positive x and P(x)"
12:49:06 <monochrom> You simply don't use "implies" in the existential version.
12:49:44 <ski> if you have `foo :: Blah *> ...', then the callee/producer/implementor of `foo' can simply take the evidence of `Blah' for granted (and also use the value of type `...'). but the caller/user/consumer of `foo' must produce evidence of `Blah' (together with constructing a value of type `...')
12:49:49 <ski> dminuoso : yes
12:50:40 <monochrom> So given that "and" is somewhat analogous to multiplication, and it would be nice to keep the ">" part, some of us chose the pseudocode *> notation.
12:51:05 <ski> the distinction `Blah => ...' vs. `Blah *> ...' is similar to the distinction `T -> U' vs. `(T,U)', and the distinction `forall a. ..a..' vs. `exists a. ..a..'
12:51:28 <boxscape> can you encode *> analogously to how you can encode exists?
12:51:42 <ski> and yes, this `*>' is just pseudo-code that some of us sometimes use to express this "dual" concept to `=>'
12:51:53 * hackage phonetic-languages-examples 0.6.1.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.6.1.0 (OleksandrZhabenko)
12:52:17 <dminuoso> boxscape: Sure, as we can encode exists with forall.
12:52:28 <boxscape> okay, neat
12:52:29 <dminuoso> boxscape: So in that encoding => takes the role of *>
12:52:38 <boxscape> oh, that's pretty straightforward
12:53:29 <ski> yes, you can write `data cxt *> a = cxt => Provide a' alternatively `data cxt *> a where Provide :: cxt => a -> cxt *> a'
12:53:34 <monochrom> Like this?  "data X = forall a. Show a => X [a]" becomes "forall a. Show a => ([a] -> c) -> c"
12:53:44 <ski> (compare `Provide' with `(,) :: a -> b -> (a,b)')
12:53:55 <monochrom> Now, allow me to replace => by ->.  Hell, there was a GHC version that did this by mistake. >:)
12:54:17 <monochrom> "forall a. Show a -> ([a] -> c) -> c
12:54:36 <monochrom> "forall a. (Show a, [a] -> c) -> c"
12:54:50 <ski> a value of type `cxt *> a' is like a pair of evidence for (a "dictrionary"/"vtable" for) `cxt', together (bundled) with a value of type `a'
12:55:50 <boxscape> monochrom do you mean this (timestamped) video rae uploaded a few days ago where it happened or a much older ghc version? https://youtu.be/l5veKgGxXd4?t=262
12:56:07 <boxscape> or, let's say, the bug in this video or a bug from an older ghc version
12:56:09 <dminuoso> boxscape: Note, the above things are mashed into the library `constraints` with slightly altered ergonomics
12:56:14 <geekosaur> much older version
12:56:17 <ski> unfixpoint : makes any sense ?
12:56:18 <boxscape> ah, that library keeps coming up
12:56:32 <boxscape> geekosaur I see
12:56:55 <unfixpoint> Not yet
12:56:58 <monochrom> Yeah, a few years ago.
12:57:03 <unfixpoint> I'll re-read
12:57:36 <monochrom> I don't know whether that video uses the GHC version I have in mind. Too lazy to check.
12:57:53 <dminuoso> boxscape: Roughly, constraints just gives you a bare data: Dict :: Constraint -> * where Dict :: a => Dict a
12:58:02 <boxscape> monochrom it uses something pretty close to HEAD so you've answered the question with your previous comment :)
12:58:04 <monochrom> But certainly not >= 8.6 when I noticed it.
12:58:13 <dminuoso> (So it comes with *just* the constraint, not the value ski used above)
12:58:34 <boxscape> dminuoso I see
12:58:53 <dminuoso> And it turns out GHC has this cool behavior that when you pattern match on that, the dictionary is brought into scope and it can be used to discharge obligations for it
12:59:20 <boxscape> right, that's what we talked about earlier today when I wasn't able to do it in a type class :)
12:59:26 <boxscape> type family
12:59:26 <boxscape> rather
12:59:39 <ski> unfixpoint : `forall' vs. `exists' flips the rôle of caller/user/consumer and the rôle of callee/implementor/producer. with `forall a. ..a..', the caller picks the type to use in place of `a', while the callee have to make do with whatever choise was made (can't even know, in general, which choice was made). with `exists a. ..a..' the callee picks the concrete type that is forgotten, hidden by `a', 
12:59:45 <ski> and the caller has to be prepared for any choice (and can't know which was chosen, in general)
13:00:45 <dminuoso> boxscape: The old version has this cool and mindboggingly simple implementation of:
13:00:54 <dminuoso> withDict :: Dict a -> (a => r) -> r; withDict d r = case d of Dict -> r
13:00:56 <unfixpoint> It makes sense but why does one end up needing a library like `constraints`
13:01:17 <dminuoso> Which might look like magic at first glance. :)
13:01:36 <boxscape> does look fairly strange, yeah
13:02:04 <boxscape> but I think it makes sense to me
13:02:23 <ski> unfixpoint : similarly, `cxt => a' vs. `cxt *> a' also flips that rôle, wrt how `cxt' is treated. with `=>', the caller has to provide evidence of `cxt', and the callee can just assume the evidence will be provided to it. with `*>', the callee has to provide the evidence for `cxt', while the caller can rely on it being given / handed to it, along with the value
13:02:49 <unfixpoint> I imagine these are ad-hoc solutions to the crappy module system?
13:03:43 <dminuoso> It's quite surprising that constraints has *that* many downloads..
13:04:09 <ski> @where on-understanding-revisited
13:04:09 <lambdabot> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
13:04:37 <ski> has a discussion on OO vs. Abstract Data Types (and mentions relation of both to existentials), iirc
13:06:34 <p0a> I was told to look into ExceptT 
13:06:36 <ski> unfixpoint : "So given [a] we can Ord and Widget it? Instead of Given that we can Ord, Widget an a we have [a]? Wat?" -- having a value of type `exists a. (Ord a,Widget a) *> [a]' means that you have a list of values of some (common) unknown/forgotten/hidden type `a', about which you only know that it's an instance of `Ord' and `Widget' (so you can only really process the values in the list, by passing them 
13:06:42 <ski> to the methods of those two type classes)
13:06:48 <p0a> is it from mtl or transformers?
13:07:38 <dminuoso> p0a: mtl provides Monad* typeclasses, transformers provides *T type constructors.
13:07:43 <dminuoso> Though mtl re-exports some of transformers.
13:07:48 <ski> unfixpoint : otoh, `exists a. (Ord a,Widget a) => [a]' would be very different. you'd still have a list of values of a (common) unknown type, but now, to be able to access them, you must now magically somehow conjure up `Ord' and `Widget' instances (for this type `a' that you know nothing about) .. i hope you can see that this is fairly useless
13:07:59 <p0a> dminuoso: got it, thank you 
13:09:31 <hekkaidekapus> idnar: Now that I got a real machine handy, take a look at this: <https://paste.tomsmeding.com/llmymcm4>.
13:10:52 <unfixpoint> Yeah, I wouldn't know when I'd need that
13:12:12 <ski> `*>' typically goes with `exists', like `=>' typically goes with `forall'
13:13:08 <unfixpoint> By typically you mean freenode#haskell or in general (eg. research)?
13:13:40 <dminuoso> Mmm, how many other languages have type systems involving quantification and constraints?
13:14:18 <ski> Clean,Mercury
13:15:02 <dminuoso> unfixpoint: Note, this exists and *> is not even Haskell. It's just a pseudo haskell some of us pretend existed.
13:15:30 <ski> unfixpoint : by "typically", i mean that, in practice, most of the times you'd want to express `*>', is in direct conjunction with expressing `exists'; and most of the times you want `=>', it's in direct conjunction with `forall'
13:15:52 * hackage graphula 2.0.0.1 - A declarative library for describing dependencies between data  https://hackage.haskell.org/package/graphula-2.0.0.1 (PatrickBrisbin)
13:16:02 <dminuoso> ski: Mm, can you actually express the `exists a. (Ord a,Widget a) => [a]` confusion with a forall encoding?
13:16:11 <dminuoso> (that is the forall continuation encoding)
13:16:23 <dminuoso> Ah I think you should be able to
13:16:55 <dminuoso> presumably it'd be: (forall a. [(Ord a, Widget a) => a] -> b) -> b
13:16:55 <ski> and yes, `exists' and `*>' are not valid Haskell (even with extensions) (maybe we'll get `exists', some day. there was another Haskell implementation which had limited support for it). regardless, imho, it's useful to reason in terms of `exists' and `*>', in pseudo-Haskell code, before getting to encoding it (in one of two main ways), in Haskell (with extensions)
13:17:16 <dminuoso> or... no that doesnt look quite right
13:17:37 <ski> dminuoso : not sure what you mean by "express the [..] confusion"
13:17:49 <dminuoso> ski: `exists a. (Ord a,Widget a) => [a]`
13:18:04 <ski> what is the confusion that you want to express ?
13:18:12 <dminuoso> ski: Can you express that term in haskell with forall
13:18:20 <ski> (or do you just mean to express that type, in Haskell with extensions ?)
13:18:23 <dminuoso> Right
13:18:31 <dminuoso> All extensions allowed.
13:18:36 <ski>      exists a. (Ord a,Widget a) => [a]
13:18:53 <ski>   =  forall o. ((exists a. (Ord a,Widget a) => [a]) -> o) -> o
13:19:09 <ski>   =  forall o. (forall a. ((Ord a,Widget a) => [a]) -> o) -> o
13:19:35 <ski> (that's using `RankNTypes')
13:19:35 <dminuoso> Ah indeed.
13:20:10 <dminuoso> Oh! And thus answering a question that arised over a year ago, for which I never got a satisfactory answer
13:20:16 <ski> oh ?
13:21:19 <dminuoso> Don't even know the context, but I was wondering about the meaning of `forall a. (ctxt ... => ...)` as opposed to `forall a. ctxt ... => ...`
13:22:34 <dexterfoo> foldr (\i m -> Map.insert i "value" m) Map.empty [1..100]
13:22:35 <dexterfoo> Should i use foldr or foldl'? The Map is strict
13:23:24 <ski> dminuoso : er, the precedence i'm using, those two should be the same thing
13:23:59 <Guest42> Hi, I  have a lambda calucus question.  I have to show that if s ⇒βi
13:23:59 <Guest42>  s' and s' is in head normal form then  s is also in head normal form. Can someone help ?
13:24:06 <ski> ("quantifiers extend/scopes as far right as possible")
13:25:56 <ski> ⌜⇒βi⌝ being ?
13:26:51 <dminuoso> ski: Mmm. Im having a hard time remembering it might have been 2 years ago in fact, my logs dont reach that far back.
13:28:38 <boxscape> dminuoso do you remember if ctxt is supposed to depend on a?
13:28:39 <dminuoso> Roughly, I was looking into where forall and => could go, and there were some combinations I just couldn't make sense of
13:28:53 <dminuoso> Similar to, but not quite like: withDict :: HasDict c e => e -> (c => r) -> r
13:29:54 <ski> ok
13:30:13 <ski> (boxscape : presumably ?)
13:30:18 <Guest42> =>βi  is the smallet relation that is reflexive and s.t if s => s' then  λx.s ⇒β λx.s
13:30:18 <Guest42> , 
13:30:26 <Guest42> and if
13:30:50 <boxscape> I was thinking maaaybe it could have been forall a . ctxt ... => ... vs cxt => forall a . ..., but of course that wouldn't make sense in that case
13:30:56 <dminuoso> It arised from the question whether: (Show a => a -> IO ()) -> IO ()  was the same as  forall a. (Show a => a -> IO ()) -> IO ()
13:31:01 <Guest42>  s ⇒β s
13:31:02 <Guest42> and t ⇒β t
13:31:02 <Guest42> alors s t ⇒β s
13:31:03 <Guest42> 0
13:31:03 <Guest42> t
13:31:03 <dminuoso> That was the story, and my logs do reach that far. :)
13:31:04 <Guest42> 0
13:31:04 <Guest42> et (λx.s)t ⇒β s
13:31:05 <Guest42> 0
13:31:05 <Guest42> [t
13:31:06 <Guest42> 0/x
13:31:19 <dminuoso> Guest42: please use a pasting service, you can find one linked in the topic
13:31:28 <tomsmeding> copying from a pdf? ;)
13:31:35 <Guest42> yeah
13:31:36 <ski> dminuoso : definitely not the same
13:32:22 * hackage phonetic-languages-examples 0.6.2.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.6.2.0 (OleksandrZhabenko)
13:33:14 <boxscape> % testing42 :: (Show a => a -> IO ()) -> IO (); testing42 = undefined
13:33:14 <yahb> boxscape: 
13:33:16 <boxscape> % :t +v testing42
13:33:16 <yahb> boxscape: forall a. (Show a => a -> IO ()) -> IO ()
13:33:21 <boxscape> is that not the second one?
13:33:39 <boxscape> seems like ghc infers them to be the same?
13:33:52 <boxscape> s/infer/does something to them
13:34:14 <ski> Guest42 : hm, so beta-reducing some number of parallel subexpressions (including reducing under lambda)
13:35:17 <ski> boxscape : in that context, the former is interpreted to have an implicit/elided `forall', and so is equivalent to the latter (with some caveats like `ScopedTypeVariables' ..)
13:35:44 <boxscape> ski so that means the context in dminuoso's question was implied to be different?
13:36:06 <ski> boxscape : but consider `data Foo a = MkFoo {testing42 :: (Show a => a -> IO ()) -> IO ()}' vs. `data Foo a = MkFoo {testing42 :: forall a. (Show a => a -> IO ()) -> IO ()}' -- these are not the same
13:36:15 <boxscape> ah, that's fair
13:36:15 <unfixpoint> I will never understand how ScopedTypeVariables is not default
13:36:25 <koz_> unfixpoint: Because Haskell2010 doesn't have it.
13:36:28 <dminuoso> unfixpoint: historical reasons.
13:36:31 <dolio> dminuoso: Those types are the same.
13:36:36 <unfixpoint> Yeah, I know.. but wtf
13:36:38 <koz_> dminuoso: Was about to say 'hysterical raisins'.
13:36:40 <ski> `(Show a => a -> IO ()) -> IO ()' is a type expression with a free (type) variable. `forall a. (Show a => a -> IO ()) -> IO ()' isn't
13:36:54 <dminuoso> dolio: I know
13:36:54 <koz_> unfixpoint: Hysterical raisins is an explanation of many wtf phenomena, Haskell or otherwise.
13:37:01 <dolio> Oh, okay.
13:37:05 <boxscape> apparently there's some infelicities with ScopedTypeVariables that, if the stars align just right, might be fixed before something like it becomes standard, but I don't quite remember what they were
13:37:06 <Guest42> => is the beta parrallell reduction 
13:37:11 <ski> imho, the behaviour of `ScopedTypeVariables' is the opposite of what it ought to be ..
13:37:22 <dminuoso> dolio: I copied the line that, roughly, was at the starting point of all of this.
13:37:30 <dminuoso> % foo :: forall a. (Show a => a -> IO ()) -> IO (); foo = undefined
13:37:30 <yahb> dminuoso: 
13:37:32 <ski> Guest42 : single-parallel-step, yes
13:37:36 <dminuoso> % bar :: (forall a. Show a => a -> IO ()) -> IO (); bar = undefined
13:37:36 <yahb> dminuoso: 
13:38:00 <Guest42> ski: i think the i notes how many steps
13:38:04 <unfixpoint> At least it makes me crack up everytime because I always misspell it. So it will suggest me NoScopedTypevariables too. I don't even play video games but I know about no scoping >.>
13:38:07 <Guest42> but i'm not sure
13:38:52 <dexterfoo> any help with my question about foldr/foldl'?
13:38:58 <ski> Guest42 : hm, just noticed the ⌜i⌝ isn't there in what you wrote after "the smallet relation that"
13:39:24 <Guest42> yeah beause  I think I made a mistake
13:40:45 <Guest42> I have to write what it is in a paste website thing. I'll send the link once I'm finished
13:41:24 <unfixpoint> Use foldl' as you want to fold everything, but you could also just use fromList I think.
13:41:38 <ski> boxscape : imho, with `foo :: forall a. ..a..; foo = ...', the `a' bound by `forall a.' in the signature ought not to be in scope in the body `...'; while with `foo :: ..a..; foo = ...' (and an extension), it could make sense for `a' to be in scope in `...'
13:42:14 <dminuoso> dexterfoo: hard to say in general without knowing the details
13:42:21 <c_wraith> dexterfoo: foldl', for two reasons.  1) there's no meaningful result from evaluating just some of the list.  2) The result is a single value that you want to not have referring to previous versions of itself
13:42:49 <dminuoso> dexterfoo: Roughly, foldr is a good and safe default (because of how it plays with lazyness), foldl' is more rarely a better choice unless you know you will force the entire structure anyway.
13:43:17 <dexterfoo> dminuoso: thank you. i pasted a line of code that builds a Strict Map
13:43:21 <c_wraith> dexterfoo: and FWIW, in that case the fact that it's Data.Map.Strict is irrelevant.  It will do the exact same thing with Data.Map.Lazy
13:43:26 <dminuoso> dexterfoo: the example seems contrived.
13:43:31 <ski> (should there be two versions of `TypeApplications', one only allowing it with values which have been given a type with explicit `forall's ?)
13:44:07 <dminuoso> ski: There's an accepted proposal to provide value level binders.
13:44:43 <dminuoso> With a syntax like `f @a x = ...`
13:44:46 <ski> i recall hearing about it, i think, but it not being finished then
13:45:05 <unfixpoint> TIL `id @(forall a. a -> a) 101` won't work
13:45:50 <unfixpoint> dminuoso: Can you not have `f (x :: a) = ...`, does it not bind `a`?
13:45:55 <dminuoso> dexterfoo: but yeah, for inserting into a map, a foldl' is likely the better candidate
13:45:59 <ski> yea, makes sense (apart from it appearing confusingly similar to as-patterns). so `foo :: forall a. ..a..; foo @a = ..a..' would make sense, but those would be two different `a' type variables
13:47:08 <ski> % id @(forall a. a -> a) id 101
13:47:08 <yahb> ski: 101
13:47:22 <dexterfoo> thank you unfixpoint dminuoso c_wraith
13:47:32 <ski> % id @(forall a. a -> a) False
13:47:32 <yahb> ski: ; <interactive>:211:24: error:; * Couldn't match expected type `a1 -> a1' with actual type `Bool'; * In the second argument of `id', namely `False'; In the expression: id @(forall a. a -> a) False; In an equation for `it': it = id @(forall a. a -> a) False
13:47:44 <unfixpoint> TypeApplication is meant to apply though, what is the proposal?
13:47:59 <dminuoso> https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0155-type-lambda.rst
13:48:12 <unfixpoint> Binding with `::` is good enough :S
13:48:53 <ski> unfixpoint : doesn't specify ordering too clearly
13:50:27 * ski . o O ( `(map _) [] = []; map_f@(map f) ((f -> y):(map_f -> ys)) = y:ys' )
13:50:30 <Guest42> we define an internal parralel reduction rule inductively by with the following rules: https://imgur.com/a/heRxIIw  Intuitively it the parralel reduction we forbid to reduce the redex in head. Show that if s => s'  and s' in normal head form then s is in normal head form. 
13:51:24 <Guest42> Intuitively it is the parrallel reduction where we forbid*
13:51:24 <dminuoso> unfixpoint: GHC uses a variant of System F as its intermediate language, which essentially provides binders for type variables. So rather than `\x.x` you'd write `/\t.\x^t.x`. TypeApplications exist both to elaborate programs during type checking, as well as providing a more convenient and explicit way to do this on the Haskell level.
13:51:47 <hekkaidekapus> ski: Bring back PatternSignatures?
13:51:50 <dminuoso> unfixpoint: The above proposal just brings this to a conclusion and makes the TypeApplications consistent with that.
13:52:42 <ski> hekkaidekapus : yea, i'd like being able to say `map (f :: a -> b) (xs :: [a]) :: [b] = ...' (including result ascription)
13:53:10 <dminuoso> Also, the pattern type signatures of ScopedTypeVariables is relatively noisy because it adds an unnecessary dimension
13:53:17 <hekkaidekapus> ski: I agree. That sentence is the title of a proposal, IIRC.
13:53:26 <ski> (or `map @a @b (f :: a -> b) (xs :: [a]) :: [b] = ...', if combined with the above proposal)
13:53:55 <hekkaidekapus> (But I was rejected I don’t recall for what reasons.)
13:54:29 <dminuoso> unfixpoint: In the lambda cube, we say that polymorphism gives us terms binding types. So why not provide proper binders for what we semantically already have. :)
13:54:44 <dolio> At the very least, there needs to be another way of accomplishing that, because that syntax is awful.
13:54:47 <unfixpoint> Wait how did you get `id @(forall a . a -> a ) id 101` to work?
13:55:07 <unfixpoint> Do I need newer GHC than 8.4.4?
13:55:31 <hekkaidekapus> ski: Result ascription has another proposal, dunno its state.
13:55:48 <unfixpoint> why is my GHC so old.. 
13:55:52 <ski> Guest42 : hm, so no beta at top-level (nor in operator position, if top-level is an application, continuing heriditarily)
13:55:55 <dminuoso> hekkaidekapus: Is result ascriptions akin to how we ascript tyfams?
13:56:19 <ski> unfixpoint : you forgot to pass `id' as argument
13:56:21 <dminuoso> (also, can we get separate type family kind signatures?)
13:56:23 <hekkaidekapus> dminuoso: See ski’s example.
13:56:36 <dminuoso> hekkaidekapus: Ah indeed it looks like it.
13:57:08 <ski> (the MLs have result ascriptions)
13:57:47 <hekkaidekapus> dminuoso: Isn’t TF kind signatures realised by StandaloneKindSigs?
13:57:55 <unfixpoint> Yeah, but even so. It gives "GHC doesn't yet support impredicative polymorphism" for me
13:57:59 <dminuoso> unfixpoint: You just need to flip on ImpredicativeTypes
13:58:11 <boxscape> just pretend it supports them
13:58:13 <dminuoso> A notoriously buggy extension
13:58:26 <dminuoso> It crashes GHC, or your program, or who knows.
13:58:32 <p0a> Guest42: This channel is about Haskell...
13:58:33 <boxscape> though HEAD now has a new implementation, so that's nice
13:58:36 <unfixpoint> I'd rather not enable something that is "extremely flaky support"
13:58:42 <ski> iirc, there was a new idea for how to implement it, recently
13:59:02 <dolio> I don't think ImpredicativeTypes crashes anything.
13:59:07 <dolio> It just doesn't work very well.
13:59:10 <unfixpoint> Aaanyway, I should focus on other things for now. Thanks for all the help and interesting discussions
13:59:26 <boxscape> ski https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3220
13:59:31 <unfixpoint> Thanks for the papers too, I'll check them later
13:59:45 <chkno> Is there a better way to do a lint-style check for partial function usage than   egrep -wr '!!|fromJust|head|init|last|maximum|minimum|read|tail'  ?
14:00:23 <dminuoso> chkno: You could also use a different prelude I guess.
14:00:44 <unfixpoint> Solve Halting problem first
14:01:12 <dminuoso> chkno: You also forgot `throw` btw :)
14:01:19 <ski> Guest42 : how do you define "normal head form" ?
14:01:40 <unfixpoint> And `read` ;)
14:01:57 <unfixpoint> It's there haha
14:02:01 <unfixpoint> I go
14:02:07 <Guest42> head normal form is a λ-term that has a top-level abstraction where the body does not have λ-subterms that can have β-reductions applied to them. 
14:02:59 <justsomeguy> Is that like weak head normal form?
14:03:49 <dolio> It is like it, but not the same.
14:04:02 <ski> that definition is a bit unclear, to me
14:04:03 <boxscape> is there a way to have ghc warn you about missing equations in type families?
14:04:19 <boxscape> (closed type families)
14:04:26 <ski> does it mean that ⌜x⌝ is not in head normal form (since it's not a λ-abstraction) ?
14:04:55 <Guest42> i think so
14:05:01 <dminuoso> dolio: Dunno, issues like this are not reassuring https://gitlab.haskell.org/ghc/ghc/-/issues/17332
14:05:17 <ski> (is there a more formal definition available ?)
14:05:44 <boxscape> dminuoso that was before quick look though
14:05:50 <dminuoso> boxscape: Sure.
14:06:43 <dolio> dminuoso: Ah, that's pretty weird. I'm not exactly sure what some of those types even mean.
14:06:53 <ski> is ⌜λ x ↦ x (λ y ↦ (λ z ↦ z) y)⌝ not in head normal form (since the body does contain a β-redex) ?
14:07:55 <Guest42>  A head normal form is a term that does not contain a beta redex in head position, i.e. that cannot be further reduced bya head reduction  a head reduction
14:08:44 <Guest42> yeah I think 
14:09:03 <Guest42> at least thats what I understand from the definition
14:09:24 <dminuoso> dolio: They are just things out of `constraints`
14:09:42 <dolio> No, those aren't the parts I'm confused about. :)
14:10:51 <dolio> I guess the `forall a. a` has `a :: Constraint`, but I'm not sure why GHC thinks it has one of those.
14:11:32 <dminuoso> data Dict c = c => Dict
14:11:34 <dolio> It seems like the Bottom declaration doesn't actually need it to be a superclass, either, because it's never given an instance.
14:12:13 <dminuoso> Well that's the point of it.
14:12:35 <ski> Guest42 : does that mean it's the union of all abstractions ⌜λ x ↦ M⌝, with the smallest subset of λ-terms that contain all variables ⌜x⌝; and all applications ⌜M N⌝, provided ⌜M⌝ is already in this subset ?
14:12:48 <dminuoso> Think the more recent version uses Any instead of forall a. a as a superclass
14:13:13 <dminuoso> Without that superclass, you could write instances for it
14:13:19 <boxscape> hmm so the case expression with (forall a . a) means that now every possible constraint is fulfilled in that scope?
14:13:58 <boxscape> I guess there's no case expression
14:14:00 <boxscape> pattern guard
14:14:33 <dminuoso> Or.. mmm.
14:14:41 <boxscape> ..so therefore, the Bottom constraints is part of the set of all constraints and therefore you can call "no"?
14:14:54 <dolio> Yeah.
14:15:00 <boxscape> ok
14:18:02 <ski> (hm, shouldn't it require `aux :: (forall a. a) => Dict (forall a. a)', if anything ?)
14:18:51 <dolio> Presumably. For some reason it thinks it just has such an instance in that case, though.
14:19:22 <dolio> But I guess not when trying to define instances for Bottom.
14:20:36 <dolio> Or, who knows what's going on. I guess ImpredicativeTypes was enabling some code path that makes no sense.
14:22:14 <ski> mm
14:23:33 <dolio> I guess it wouldn't be too surprising if it's just a bunch of checks sprinkled throughout the code that no one has bothered thinking about in conjunction with other developments (like quantified constraints).
14:28:27 <hekkaidekapus> dolio: Is the awful syntax you were talking about earlier this one: `foo :: F = bar`?
14:29:13 <iqubic> So, I'm trying to compile a haskell project using Cabal and GHC 8.8.4 I have this cabal file: https://dpaste.com/H5CTS2V6R
14:29:14 <dolio> hekkaidekapus: The one where you put all the types on the same line as the arguments. It eats way too much horizontal space.
14:29:22 * hackage rosebud 0.1.0.0 - Common rose tree/forest functions  https://hackage.haskell.org/package/rosebud-0.1.0.0 (jship)
14:29:29 <iqubic> Here's the error I'm getting: https://dpaste.com/4JTTNNPTC
14:29:52 <iqubic> Anyone know what the issue is here?
14:30:18 <hekkaidekapus> dolio: So, it turns out the proposal is accepted but not yet implemented, including ascribing arguments.
14:30:43 <dolio> I don't care if it's an option. I just want another option, because I'll never use that one. :)
14:30:56 <hekkaidekapus> ski: One pet peeve down: <https://github.com/ghc-proposals/ghc-proposals/pull/228>
14:31:05 <anon1252> iqubic: Slightly offtopic but what font is that?
14:32:27 <hekkaidekapus> dolio: If I’m getting what you want, annotating the result if okay, but ugly for arguments.
14:32:29 <iqubic> What font is what?
14:32:57 <anon1252> iqubic: Sorry, nevermind, I thought it was a screenshot but it's not so I've got it. 
14:33:12 <iqubic> anon1252: I posted a total of 0 images, so whatever font it is must be coming from your computer.
14:33:12 <dolio> I just don't want any other feature to require you to use this sort of annotation.
14:33:20 <hekkaidekapus> heh
14:33:21 <iqubic> I have no idea what font your computer is using.
14:33:29 <dolio> I want to be able to write signatures on their own line.
14:34:06 <iqubic> So, anyone know why my thing won't compile?
14:34:54 <hekkaidekapus> Euh, haven’t re-read the full proposal but I don’t think there is another feature requiring to use the new syntax. It’s just an option.
14:35:41 <dolio> Yeah, that's fine.
14:35:42 <koz_> iqubic: 4.12 is 8.6.
14:35:44 <koz_> Not 8.8.
14:40:56 <hekkaidekapus> @where boot-libs-versions -- iqubic
14:40:56 <lambdabot> <https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history>
14:41:23 <iqubic> koz_: How shall I change my cabal file?
14:41:32 <koz_> iqubic: Change your base pin.
14:41:44 <koz_> To match the version that comes with GHC 8.8.4.
14:42:25 <iqubic> I don't know how to do that. Can you teach me?
14:43:07 <koz_> iqubic: Your version of base is set by '^>= 4.12.0.0' in your cabal file. It should be ^>= 4.13.0.0. 
14:43:17 <iqubic> Thanks.
14:43:53 <boxscape> ^>= 4.12.0.0 matches anything below 4.13? or anything below 5?
14:43:57 <ski> hekkaidekapus : one down ?
14:44:01 <koz_> boxscape: Neither of these.
14:44:04 <boxscape> oh
14:44:32 <koz_> The exact meaning of ^>=-style bounds is explained in the Cabal docs.
14:44:44 <boxscape> (I meant at least 4.12.0.0 and below x, but I'll check the docs)
14:44:54 <hekkaidekapus> ski: Isn’t the ML-style annotations question resolved by that proposal?
14:46:08 <hekkaidekapus> And even the PatternSignatures one?
14:46:29 <boxscape> "^>= x.y.z.u == >= x.y.z.u && < x.(y+1)"
14:47:07 <boxscape> so... ^>= 4.12.0.0 == >= 4.12.0.0 && < 4.13
14:47:31 <hekkaidekapus> boxscape: Yeah, basically the version after ^>= means it will not break PVP.
14:47:38 <boxscape> ok
14:48:34 <hekkaidekapus> iqubic: For future fixes, you could bookmark the URL I pasted above.
14:48:39 <koz_> I keep misreading PVP as 'player-versus-player', rofl.
14:48:57 <koz_> Haskell has the Battle Royale approach to package versioning, clearly.
14:49:22 <ski> hekkaidekapus : oh. yes, i think so. i was just thinking you meant you commented or added something to that discussion, but couldn't find a recent addition
14:49:48 <hekkaidekapus> Nope, I don’t do GitHub comments ;)
14:50:18 <hekkaidekapus> The remaining task is to scale down STV.
14:50:51 <ski> (preferably flipping when it binds tyvars over the body, and when it doesn't)
14:51:50 <hekkaidekapus> Aye. But that would be nearly impossible given its wide adoption.
14:51:53 <ski> (i think i remember, when i first read about it, i was thinking they must've made a mistake in the docs, meaning the opposite of what was written .. until i tested it)
14:52:30 <ski> yes. so an alternative extension with the opposite behavious would be what one might reasonably hope for, i think
14:53:27 <hekkaidekapus> Absolutely. And then set in motion a decade-long process to deprecate STV :D
14:53:53 <ski> well, how long have we had STV, now ?
14:53:56 * ski can't recall
14:54:05 <hekkaidekapus> Me, neither.
14:54:22 <ski> anyway, better late, than never
14:55:21 <hekkaidekapus> In the Users’ Guide, STV is there since 6.8.1.
14:58:22 * hekkaidekapus sees where ski got the confusion: “But I was rejected I don’t recall for what reasons.” s/I was/ It was/
14:59:43 <ski> (no. i noted that at the time, and internally typo-corrected it as you indicate)
15:00:25 <hekkaidekapus> Ah, ok.
15:00:45 <ski> (for some reason, i've noticed that i, unnervingly often, write "i" when i mean "it")
15:01:37 <hekkaidekapus> heh Those pesky keyboards :d
15:02:34 <ski> (.. and some other annoying typos, like the "the the" class of typos (you pause after writing a word, to think, and then when you continue, you repeat the last word). also, sometimes, when thinking ahead about how to formulate myself, i write out a later planned word, in place of the current one that i intended)
15:04:22 <ski> (and no, i don't think i'm simply failing to press the "t" key in the "it". it may be related to another class of typos, where i write another word, that, when pronounced, sounds more or less similar to the intended word)
15:05:56 <ski> (.. some kind of mess-up, in the internal sentence-structure to keypress serialization)
15:05:56 <hekkaidekapus> Maybe it’s the cerebral chemistry being quicker than the bio-mechanical anatomy. By the time a typo is spotted, some other body part has already initiated an irreversible action.
15:07:01 <hpc> i wonder if they make joke keyboards that don't have a backspace or delete key
15:07:34 <ski> it's interesting to read a transcript of what someone has spoken, including "er"s, half-formed sentences, changing midway through, &c.
15:08:44 <ski> hm. perhaps they could brand those keyboards "Dijkstra"
15:09:36 <justsomeguy> ski: I do a lot of that, too. My worst sin is writing in inconsistent tense (past, present, future), because I've rephrased my comment in the chat box five or six times before sending.
15:09:44 <ski> (another example of an annoying typo is writing "now" in place of "not" (or vice versa))
15:10:32 <ski> yea, rephrasing (incompletely/inconsistently) is dangerous
15:11:25 * justsomeguy also sometimes habitually replaces English words with similar sounding command names since he's more used to typing them, which is hilarious.
15:11:43 <ski> hm, yea. i've noticed that too
15:11:55 <ski> e.g. writing "type" in place of "typo"
15:12:20 <ski> partly a muscle-memory thing, i'd guess
15:12:58 <boxscape> any idea why `Fam alt MkR = alt` here doesn't produce an error? (using ghc 8.10) https://gist.github.com/JakobBruenker/a1b8c66abcb1c05e9bf4ff55e73fa6c8
15:13:31 <ski> (or, writing an english (usually short) word in place of a similar-looking swedish one)
15:15:01 <ski> boxscape : hm, i'd guess it's interpreted as `Fam @a @b @b alt MkR = alt' ?
15:15:35 <boxscape> oh, hm, I suppose that makes sense
15:15:47 <ski> so, in that case, that `MkR' has kind `Relation b b'
15:16:16 <boxscape> I think I only considered that the pattern matching could influence what the invisible args are, and forgot that the result could as well
15:16:22 <boxscape> thanks
15:19:16 <ski> well, well, `alt :: Relation a c' is consistent with `alt :: Relation a b',`MkR :: Relation b c', if `b = c'
15:19:48 <boxscape> right, that makes sense
15:20:51 <ski> (that "well, well, " being an (inadvertent) example of the "the the" class of typos mentioned above)
15:20:53 * hackage th-lift-instances 0.1.18 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.18 (BennoFuenfstueck)
15:22:38 <boxscape> What apparently also confused me is that I encountered this in a situation where MkR was slightly different and made b ~ c impossible, but not in a way that was obvious to the type checker
15:23:55 <boxscape> (specifically, MkR took a proof that b < c)
15:28:18 <ski> hmm, it's curious that a polymorphic type family isn't blind in the `forall'
15:28:44 <boxscape> what do you mean by "blind" here?
15:29:41 <ski> not being able to match on the kind bound by the `forall'
15:30:18 <boxscape> I think that's what Richard Eisenberg et al call "relevant" vs "irrelevant"?
15:30:28 <ski> you can't write `notId :: forall a. a -> a; notId @Int n = n + 1; notId x = x'
15:30:35 <boxscape> he's complained before that the "forall" on the kind level really should be called "foreach" to match up with the value level plans
15:31:03 <ski> in relation to type (and `data') families, specifically ?
15:31:47 <boxscape> Well, I'm fairly certain that relevancy is a concept applicable to type families, I'm less certain if I saw Richard complain about it in that context
15:32:40 <ski> (since i'd think parametricity would also sensibly apply to polymorphic types)
15:32:52 <ski> mhm
15:33:13 <boxscape> Yeah, hm, I suppose relevancy can break parametricity
15:33:20 <ski> iow, i guess i'd expect your `Fam' to use `foreach' instead, but to also be able to use `forall' on the type-level
15:33:35 <boxscape> yeah that makes sense
15:34:28 <ski> that could have helped catch your confusion in the pasted code, preventing `Fam alt MkR = alt' to work, unless you used `foreach'
15:34:46 <boxscape> that's true
15:35:15 <ski> (btw, i think the "blind" terminology might come from Japaridze's computability logic)
15:35:21 <boxscape> although even then I think in a value level function with foreach the result (as supposed to matching on other arguments) couldn't influence the invisible arguments like that? I'm not sure
15:35:47 <boxscape> s/supposed/opposed
15:37:22 <ski> i'm still not totally sure what you mean by "the result [..] couldn't influence the invisible arguments like that" -- i suspect you mean the "back-propagation" of unification of tyvars, to specialize the (implicit type-)parameters, based on the type inference/checking on the body
15:37:55 <boxscape> that.. sounds it like should be what I mean
15:38:41 <dolio> The whole system is kind of inconsistent.
15:38:55 <dolio> Like, type families already let you match on things that you aren't normally allowed to match on.
15:38:58 <glguy> unclechu: You around?
15:39:04 <ski> hmm .. consider something like `sameNat :: foreach (m :: Nat) (n :: Nat). Maybe (Equal m n); sameNat = Just Refl; sameNat = Nothing'
15:39:12 <glguy> I was playing with a module based on your wanting a reusable, type-level Map https://gist.github.com/glguy/98331ca1c3876a188e5380b9d0da5751
15:39:28 <glguy> It's not "light-weight", but I thought it was cool that it worked
15:39:54 <ski> where the definition would be expanded into `sameNat @n @n = Just (Refl @Nat @n); sameNat @_ @_ = Nothing'
15:40:34 <ski> dolio : yea. we sortof pretend `*'/`Type' is a(n open) sum type, in families
15:40:42 <dolio> So it's kind of hard to draw analogies between the two levels, because they don't work the same in many ways.
15:41:36 <boxscape> right, but the eventual goal of folks like Richard is to unify them, so.. I guess I was analogizing with that hypothetical future value level
15:41:51 <boxscape> though of course that's not fully specified at this point
15:42:14 <dolio> And even in more uniform systems, parametricity gets kind of fuzzy and unsatisfying when you talk about applying it to types.
15:42:30 <boxscape> ski intuitively I would expect sameNat not to compile in a Haskell with foreach, but maybe it should, I'm not sure. Hm, would it compile in agda?
15:42:50 <ski> (and this is one argument against the terminology "type constructor" (vs. "data constructor"), i suppose .. also, with `DataKinds', with say `data Tag = E | D', `Tag' being a kind, what do we call `Tag',`E',`D' ? calling the latter two "type constructors" would seem to be confusing, possibly ? .. oh, well)
15:43:28 <ski> boxscape : in Agda, with implicit parameters, yes
15:43:37 <boxscape> okay, fair enough
15:43:54 <ski> or, well
15:44:12 <ski> you'd have to actually do recursion on the `Nat's, not being able to use non-linear patterns
15:44:31 <ski> (so not with that exact implementation. but you could implement it)
15:44:35 <boxscape> ok
15:48:23 <energizer> usually arrays are indexed by natural numbers. is there something like an array but indexed by some other type
15:48:52 <energizer> like strings or whatever
15:48:55 <ski> > listArray (LT,GT) [-1,0,1]
15:48:57 <lambdabot>  array (LT,GT) [(LT,-1),(EQ,0),(GT,1)]
15:49:23 <ski> perhaps you want some form of trie ?
15:49:46 <ski> @type listArray (LT,GT) [-1,0,1 :: Integer]
15:49:48 <lambdabot> Array Ordering Integer
15:49:54 <ClaudiusMaximus> Ix is a class for mapping values of a type to natural numbers for use as array indices
15:50:06 <ski> (an array indexed by values of type `Ordering')
15:50:22 <ski> @type listArray
15:50:23 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
15:51:16 <energizer> there should be the property that a<b<c means b is a valid index whenever a and c are
15:51:37 <ski> @type range
15:51:38 <lambdabot> Ix a => (a, a) -> [a]
15:51:49 <ski> gives values in a kind of "interval"
15:52:08 <ski> (for two-dimensional arrays, it gives indices in a "rectangle")
15:52:22 <ClaudiusMaximus> @type inRange -- tests, and i can never remember the argument order
15:52:24 <lambdabot> Ix a => (a, a) -> a -> Bool
15:52:27 <ski> > range ((-1,-1),(2,3))
15:52:29 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(-1,2),(-1,3),(0,-1),(0,0),(0,1),(0,2),(0,3),(1,-1),(...
15:53:17 <ClaudiusMaximus> (it has a name that sounds infix, but it is flipped w.r.t. infix usage)
15:54:46 <ski> in other words, `range (lo,hi)' should give a list of all indices `i', where ⌜lo ≼ i ∧ i ≼ hi⌝, where the ordering here is not lexicographic ordering in case of tuples, but rather the product order (a partial order, not a total/linear one)
15:57:28 <ski> (ClaudiusMaximus : i wonder how that happened ..)
15:58:56 <boxscape> %! ghc --version
15:58:56 <yahb> boxscape: [Segmentation fault]
15:58:57 <boxscape> cool
16:03:07 <boxscape> % :kind! Fam MkR (MkR :: Relation Int Int) -- so this is fine
16:03:07 <yahb> boxscape: forall {k} {a :: k}. Relation a Int; = 'MkR
16:03:08 <boxscape> % :kind! Fam MkR (MkR :: Int Int) -- But I do find it a bit confusing that this has no output
16:03:09 <yahb> boxscape: 
16:03:46 <boxscape> I guess I'll try installing HEAD and see if it's fixed there
16:06:41 * ski . o O ( <https://lambdacats.github.io/fixed-in-head/> )
16:07:56 <boxscape> :)
16:08:45 <hpc> whenever someone says "it's fixed in head", i read it as "it's fixed in my imagination"
16:09:52 * hackage witch 0.0.0.3 - Convert values from one type into another.  https://hackage.haskell.org/package/witch-0.0.0.3 (fozworth)
16:30:11 <monochrom> That's half true because clearly there is no release plan other than imagination.
16:38:48 <boxscape> ski: FWIW this fails in agda, but I'm not sure if the same caveat applies here that you mentioned about Nats https://pastebin.com/jKsJpPVd
16:39:44 <boxscape> guess I should look up non-linear pattern
16:39:55 <dolio> You need to prove it by cases.
16:40:56 <boxscape> dolio right, that would have been my intuition but from my conversation with ski it initially sounded like this would work (and it would in Haskell type families, I think)
16:46:45 <dolio> Yeah, an analogous type family would work. That it does work is a massive difference in expectation of what they mean, more or less.
16:47:02 <dolio> Like, type families are assuming that all the things they operate over have decidable equality.
16:47:27 <boxscape> Oh, that's interesting
16:48:01 <dolio> I guess in some ways it's not even that, though.
16:49:10 <dolio> Because the actual behavior is like, 'if you ever figure out that m = n, then `foo m n` reduces to one thing, and if you figure out that m /= n, it reduces to another.'
16:50:17 <boxscape> oh, yeah.. I thought it would work in agda if you wrote {a} {.a}, but with your it doesn't sound like it, and indeed, it says "Failed to infer the value of dotted pattern".
16:50:31 <boxscape> s/with your/with your explanation
16:50:41 <dolio> No, .a is for when you match on a proof that two things are equal.
16:51:14 <boxscape> RIght, okay
16:51:26 <boxscape> So it's very different from saying @a @a in a type family
16:51:49 <dolio> Yeah.
16:55:59 <dolio> Anyhow, if you don't want things to get stuck, which is important in Agda, then decidable equality is kind of important for justifying that sort of matching.
16:56:41 <dolio> Whereas type families are kind of based on the idea of adding things that get stuck, and specifying certain scenarios where they become unstuck, with no guarantee that all scenarios are covered.
16:57:58 <boxscape> hmm I wonder how this pretend-dec-eq-ness will work when you try to match on unsaturated type families once those are merged
16:58:06 <boxscape> I guess maybe it'll just get stuck
17:03:22 <ski> boxscape : yes, you'd need `sameNat {false} {false} = just refl; sameNat {true} {true} = just refl; sameNat = nothing', pretty sure
17:04:09 <boxscape> yeah, that does work
17:06:52 <p0a>  /quit bye
17:34:53 * hackage citeproc 0.2 - Generates citations and bibliography from CSL styles.  https://hackage.haskell.org/package/citeproc-0.2 (JohnMacFarlane)
18:06:41 <guest1119>  case parse (spaces >> symbol) "lisp" input of ...
18:06:49 <guest1119> what "lisp" and input here mean?
18:07:02 <guest1119> parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
18:07:14 <guest1119> from https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec.html
18:08:08 <guest1119> also, what do Stream s Identity t constraint? constraint for s? not t?
18:11:09 <glguy> "lisp" is the name of the input
18:11:24 <glguy> Often that's a filename or some other description
18:16:06 <Axman6> s appears to be the type of impot that's being parsed, to probably usually a String or Text
18:16:14 <Axman6> input*
18:25:08 <Axman6> guest1119: does that help at all?
18:30:56 <guest1119> Axman6: yes
18:31:12 <guest1119> but why we would give input a name?
18:31:25 <guest1119> case (parse numbers "" "11, 2, 43") of
18:31:37 <guest1119> numbers = commaSep integer
18:32:06 <guest1119> this give "11, 2, 43" a "" name?
19:29:53 * hackage aeson-gadt-th 0.2.5.0 - Derivation of Aeson instances for GADTs  https://hackage.haskell.org/package/aeson-gadt-th-0.2.5.0 (abrar)
19:50:39 <hololeap> i have a function: tryE :: MonadUnliftIO m => m a -> ExceptT IOException m a
19:51:45 <hololeap> how reasonable is it to use this wherever possible (and deal with the ExceptT monad) vs. keeping IOExceptions from the IO monad implicit and dealing with them closer to the `main` function
19:52:36 <hololeap> converting to `ExceptT ...` makes the possibility of an exception more explicit
19:54:30 <hololeap> but then again, i could just try to remember that any IO operation has the possibility of throwing an IOException
19:59:03 <glguy> Doing this will mean you have two places to catch IOExceptions, still in IO and also in ExceptT, and your code will be slower
20:00:37 <hololeap> yeah, it's also more typing
20:01:17 <hololeap> i did it in one place and then realized it's kind of an all-or-nothing approach. you can't really mix it with the default.
20:01:44 <hololeap> well, you can...
20:46:53 * hackage yesod-core 1.6.18.7 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.18.7 (MichaelSnoyman)
21:33:57 <n0042> Hello folks. May I ask what is probably a pretty common newbie question? I have done a lot of research on it and am starting to feel a little stumped at having not found the proper answer
21:35:51 <n0042> I have a situation where I need to take an unknown # of lines from stdin (no more, no less, finite but unknown until runtime). I have tried a hundred different ways of trying to use getLine programmatically so that it collects exactly n-amount of lines, after n is known. Is there a good article I can read on this? 
21:36:33 <zyklotomic> what have you tried so far
21:37:55 <n0042> So far my most promising approach has been to get the initial number of lines with getLine (because that input is known) parse it and extract the number, and then try to run getLine that amount of times. 
21:38:21 <glguy> that sounds right
21:38:21 <zyklotomic> i'm just a beginner, but maybe replicateM might help
21:38:26 <dsal> It'd be easier to show code and describe the confusion than to describe the problem.
21:38:41 <glguy> ?paste
21:38:41 <lambdabot> A pastebin: https://paste.debian.net/
21:38:42 <zyklotomic> replicateM n getLine
21:39:01 <n0042> I have not tried replicateM. I'll try that.
21:39:03 <glguy> zyklotomic, maybe, but n0042 ought to be able to do this without any library functions first
21:39:35 <glguy> n0042, Do you have any attempts yet? What have you tried?
21:39:54 <n0042> I did try: "take n (repeat getLine)" and wound up with a list of getLine functions that I then wasn't sure how to turn into values
21:40:16 <n0042> I also tried recursive-do as described in the ghc docs, but that didn't want to compile the way I was trying to do it.
21:40:51 <glguy> recursive-do is something you don't need
21:40:51 <dsal> Showing code (and errors/confusion) is more informative than describing code.
21:41:07 <glguy> You can paste your code on a pastebin so that people can see what you've got
21:41:18 <n0042> I'll use pastebin real quick to show you what I've got so far. uno momento
21:41:26 <glguy> showing code will help us see what you do know how to do 
21:43:46 <dsal> Some confusion seems to be between functions and actions.  replicating `getLine` will make a bunch of `getLine` actions, but it won't get lines.  There's a path from there, but it's probably not what you want.
21:45:11 <zyklotomic> on a seperate thread, i have a question about folds vs monads
21:45:22 <zyklotomic> hope you guys don't mind juggling the convo a bit
21:45:33 <glguy> go for it
21:45:51 <zyklotomic> is there any deeper relationship b/w them? I was reading https://mail.haskell.org/pipermail/beginners/2014-August/013993.html
21:46:05 <zyklotomic> as a result of a google search, after noticing that foldl was kinda like State
21:46:42 <zyklotomic> then I was writing another function that folded with a monoid (list appending)
21:46:52 <glguy> There's not much relating folds to monads
21:46:53 <zyklotomic> and it basically was Writer (i think)
21:47:00 <zyklotomic> are these just coincidences?
21:47:18 <zyklotomic> I should generally prefer using folds right
21:47:33 <zyklotomic> I can show an example
21:47:59 <n0042> https://pastebin.com/zwuqHsSY
21:48:24 <glguy> zyklotomic, foldl is similar to traverse used with State
21:48:26 <n0042> Here's sort of what I got so far. It's for an assignment but there's no need to get into the assignment itself. I already have that part figured out. It's just the I/O that's confusing me
21:48:30 <glguy> but that's not much about being a monad
21:48:39 <zyklotomic> https://paste.debian.net/1173146/ 
21:48:54 <zyklotomic> wait yeah, you're right, I probably shouldn't have jumped to monad
21:48:57 <glguy> that's more about foldl being related to State specifically in the context of foldable types
21:50:18 <glguy> :t \f t -> runState(traverse (state . f) t)
21:50:20 <lambdabot> Traversable t => (a -> s -> (b, s)) -> t a -> s -> (t b, s)
21:50:34 <glguy> :t foldl
21:50:35 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:50:58 <glguy> :t scanl
21:51:00 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
21:51:08 <glguy> :t mapAccumL
21:51:09 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
21:51:23 <zyklotomic> or actually, I mean, what about Writer and State
21:51:39 <zyklotomic> would you like classify them as some kind, or am I looking into this too much
21:51:49 <zyklotomic> and it is just a nice coincidenec
21:52:13 <zyklotomic> where the behavior is "traversing"
21:52:15 <glguy> there's no deep connection that I can think of
21:52:43 <zyklotomic> ah fair enough, thanks for entertaining my q
21:53:05 <dsal> n0042: what do you want `results` to be?
21:53:36 <dsal> From the application, it looks like you want it to be a single string.
21:54:40 <n0042> So, results is going to print a line for each "packet" showing the time it was processed or if it was processed. That's all going to be handled by the program logic which i've got covered, and it'll just print off a list of strings. But to get there I need to collect the strings which contain the arrival time and time-to-process for each packet,
21:54:40 <n0042> which is the programmatic input part. 
21:55:16 <dsal> Do you understand what `repeat getLine` means?
21:55:23 <dsal> :t repeat getLine
21:55:26 <lambdabot> [IO String]
21:55:58 <n0042> Yeah it's a list of getLine functions. I was trying to find some way to call getLine a certain amount of times in a row.
21:56:05 <n0042> But I'm not sure I'm on the right track
21:56:12 <dsal> It's a list of actions that produce strings.
21:56:53 <dsal> What type would make more sense here?
21:57:24 <dsal> (it's often easier to think about what you want than to struggle with the parts you have)
21:57:33 <n0042> Strings themselves, I suppose. 
21:58:06 <dsal> What does "Strings themselves" mean?
21:58:19 <n0042> The assignment's program flow is: Input buffer size and number of packets -> input line for each packet -> calculate the processing time for each packet or if it was dropped -> output a line for each packet.
21:58:22 <dsal> (Haskell is an ideal language to speak here to avoid misunderstanding)
21:58:44 <n0042> The input/output is pre-determined and I can't change how it works because it's an automated system that collectes from stdin during runtime.
21:59:00 <dsal> None of these details are relevant to what you're trying to do.
21:59:04 <n0042> We got to choose our language though and I figured it's be a good way to dive in head first with haskell
21:59:45 <zyklotomic> i'm saying in case no one pointed out the distinction, `repeat getLine` is returing a list of the actions, but nothing is executing those actions
22:00:10 <dsal> But taking a step back and identifying what you actually want might make this easy.
22:00:14 <n0042> I know. I'm not sure how to execute those actions once I have them.
22:00:22 <zyklotomic> yup that is the crux (i think)
22:00:32 <dsal> Stating clearly what you want would speed things up a lot.
22:01:01 <n0042> What I want is to get n-lines from stdin, separated by newline characters.
22:01:20 <n0042> As [Char] types
22:01:39 <n0042> Which I will then parse into [Int] types
22:01:59 <dsal> OK, closer...  Less English, more Haskell.  How would you describe the above in Haskell?
22:02:07 <dsal> :t getLine -- e.g.
22:02:08 <lambdabot> IO String
22:02:16 <n0042> Well, a single line is easy: line <- getLine
22:02:20 <dsal> So, `getLine` is `IO String`
22:02:26 <dsal> What type are you looking for
22:02:27 <dsal> ?
22:03:20 <n0042> String
22:03:29 <zyklotomic> bigger
22:03:42 <n0042> [String]?
22:03:43 <zyklotomic> think a bit higher
22:03:45 <zyklotomic> yup
22:03:59 <dsal> Closer, but it isn't pure.
22:04:03 <dsal> You're doing IO to get there.
22:04:18 <n0042> I am intrigued. Tell me more.
22:04:25 <dsal> :t getLine
22:04:26 <lambdabot> IO String
22:04:53 <dsal> That's not a String.
22:04:59 <n0042> line <- getLine results in String.
22:05:11 <n0042> according to my REPL, the type of line is String after that
22:05:25 <dsal> Eh.  That's slightly confusing.
22:05:42 <n0042> Which is why I thought I might be able to turn [getLine] into [String] somehow
22:05:56 <zyklotomic> the <- does some magic lol
22:06:18 <dsal> It's also not a complete useful expression.  The repl lets you do things that don't fully make sense.
22:06:30 <dsal> @undo do { line <- getLine }
22:06:31 <lambdabot> <unknown>.hs:1:23:Parse error: Last statement in a do-block must be an expression
22:06:38 <dsal> @undo do { line <- getLine; putStrLn line }
22:06:38 <lambdabot> getLine >>= \ line -> putStrLn line
22:07:56 <dsal> How about this.  Let's say you want to create a new thing called `getLines`.  What does is its type?
22:08:11 <n0042> :t getLine
22:08:13 <lambdabot> IO String
22:08:19 <n0042> so... [IO String] ?
22:08:44 <LKoen> IO [String] ?
22:08:49 <dsal> That's not super useful, though, as you found out, because now instead of having one action, you have a list of actions.  What would one action look like?
22:10:10 <dsal> So, there's a super easy way to go from `[m a]` to `m [a]` but I don't think it's necessarily a good path.  It might be more useful for you to consider writing a function that takes the `n` and returns the actual thing you need.
22:10:46 <dsal> (which is technical `replicateM`, but you'd get pretty far along if you write this yourself)
22:10:51 <n0042> I must admit I'm having a hard time with Haskell's I/O. That is exactly what I'd like to do.
22:11:16 <dsal> You're having a hard time because you're trying to use it without understanding it or your goal.  :)
22:11:21 <n0042> I have really enjoyed using this language for my assignments so far. It's a real pleasure to write and work with.
22:11:57 <dsal> It continues to get better as you learn more of it.  But some things that you can kind of hand wave will eventually require a bit more understanding.  In particular, expressing the type of the thing you want.
22:13:19 <n0042> Well my goal is to take input, calculate some results, and print outputs. The "calculating some results" part is the actual assignment, and I've already worked it out, and was the fun part. The I/O part is throwing me for a loop because it should have been trivial. It's like two different languages when it comes to program logic and I/O
22:13:21 <dsal> Also, though it's still partial, I'd write what you have so far something like:  `[bufferSize, numPackets] <- map read . words <$> getLine` -- but that's next week's episode.
22:14:02 <n0042> I am the sort of person who likes to understand this stuff from first principles where possible. Do you have any good resources for understanding how replicateM works on a more intuitive level? I'd like to learn this.
22:14:29 <dsal> Haskell Programming From First Principles will get you there quickly.
22:14:56 <dsal> @src replicateM
22:14:56 <lambdabot> replicateM n x = sequence (replicate n x)
22:15:11 <zyklotomic> the weird part about haskell is, the hard stuff becomes easy and the "easy" stuff becomes hard
22:15:17 <zyklotomic> *when you're first learning it
22:15:35 <zyklotomic> like IO basically
22:15:44 <dsal> I'd by that with the addendum.  After a while, most things are easy.
22:16:27 <n0042> I recently joined a study group for that book, but we haven't started yet.
22:16:27 <zyklotomic> but i'm sure the fun never gets old
22:16:48 <n0042> It really is a fun language. The list comprehensions are my favorite in any language I've used so far.
22:17:11 <dsal> I generally recommend that book.  It's a slow path, which I think will get you somewhere useful the fastest.
22:18:08 <zyklotomic> list comprehensions are cool indeed
22:18:29 <dsal> I somehow don't use list comprehensions that much in haskell.
22:18:50 <zyklotomic> I use them in ghci most often tbh
22:18:53 <dsal> I often forget they exist.  heh.
22:18:57 <n0042> So far everything I've written has been a mixture of list comprehensions and the recursive-go pattern.
22:19:04 <n0042> But I'm still doing pretty basic stuff
22:19:14 <zyklotomic> when I switched to Linux from a Mac, ghci replaced the Spotlight calculator if you know what spotlight is
22:19:21 <n0042> recursive-go makes my inner LISP programmer happy
22:19:29 <zyklotomic> basically just quickfire calculator that you can type some math into
22:19:29 <dsal> what's recursive-go?
22:20:14 <n0042> Where you wrap a function in a "go" function scoped in a "where" statement that requires parameters that don't make sense to call outside the function. Usually to do something in a list-processing kind of way
22:20:30 <dsal> Oh.  Just recursion.  :)
22:20:58 <zyklotomic> I've been struggling to know what to call that practice lol
22:20:59 <dsal> Usually there's a higher level abstraction that does the thing already
22:21:04 <n0042> Yes, but in Scheme or something you'd have to wrap it in a macro to make it look decent.
22:21:19 <zyklotomic> some things are just kinda un-pronuncable in Haskell lol
22:21:32 <zyklotomic> like all the weird operators and when someone decides to roll their own custom operator too
22:22:04 <dsal> > maximumOf (folded . _Right) [Left 1, Right 2, Left 3, Right 4, Left 5, Right 3]
22:22:06 <lambdabot>  Just 4
22:22:57 <dsal> Operators are just functions.  The really common ones have fairly common names.  Or we just don't say them much.
22:24:20 <n0042> I am still trying to wrap my head around some of them. You used two I'm unfamiliar with in that snippet you posted: (.) and <$>
22:24:29 <dsal> > sum (digitToInt <$> "123")
22:24:31 <lambdabot>  6
22:24:39 <dsal> . and $ are *super* common
22:24:45 <dsal> :t (.)
22:24:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:24:47 <zyklotomic> with time
22:24:47 <dsal> :t ($)
22:24:49 <lambdabot> (a -> b) -> a -> b
22:25:04 <dsal> . is just how you compose functions.
22:25:12 <dsal> @src (.)
22:25:12 <lambdabot> (f . g) x = f (g x)
22:25:18 <zyklotomic> <$> is fmap
22:25:20 <dsal> That's it.
22:25:27 <n0042> Oh
22:25:28 <zyklotomic> it is like a generlaized map
22:25:44 <dsal> IMO, map shouldn't exist, but at least a few people think it's not bad.
22:25:57 <dsal> > fmap (+1)  [1..5]
22:25:59 <lambdabot>  [2,3,4,5,6]
22:26:04 <dsal> >  (+1) <$>  [1..5]
22:26:06 <lambdabot>  [2,3,4,5,6]
22:26:10 <n0042> ($) I have used plenty to get rid of parentheses, but <$> was a new one. That's pretty sweet
22:26:29 <dsal> $ should be used sparingly.  :)
22:26:35 <dsal> :t ($)
22:26:36 <lambdabot> (a -> b) -> a -> b
22:26:39 <dsal> :t (<$>)
22:26:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:26:42 <zyklotomic> dsal: I find myself using fmap on lists unconsciously, cause you type that before the list and you don't register that you're getting a list mentally yet
22:27:00 <n0042> <$> is just infix fmap... got it.. that's pretty neat
22:27:05 <zyklotomic> yup
22:27:11 <dsal> @src (<$>)
22:27:11 <lambdabot> f <$> a = fmap f a
22:27:38 <zyklotomic> but I'm guessing it's existence is legacy cruft
22:27:39 <n0042> And you said ($) should be used sparingly? I have been using it willy-nilly on the assumption that people don't like parentheses as much as I do. What's the general guideline there?
22:27:54 <dsal> If you're composing functions, use .
22:28:15 <zyklotomic> when would you say it's acceptable to use $
22:28:28 <dsal> At the end of a bunch of .s  :)
22:28:49 <n0042> take 5 $ repeat 10
22:28:53 <n0042> or something like that
22:29:01 <n0042> to avoid take 5 (repeat 10) ?
22:29:06 <dsal> > replicate 5 10
22:29:07 <lambdabot>  [10,10,10,10,10]
22:29:24 <dsal> : take 5 . repeat
22:29:30 <dsal> :t take 5 . repeat
22:29:30 <zyklotomic> (take 5 . repeat) 10 hon oh you beat me to it
22:29:31 <lambdabot> a -> [a]
22:29:49 <zyklotomic> but it's not that much cleaner i'm gonna oh, wait ig you can put a $ instead of the paren
22:30:02 <dsal> > take 5 . repeat $ 10
22:30:04 <zyklotomic> i'm clearly not a very good user of $ lol
22:30:05 <lambdabot>  [10,10,10,10,10]
22:30:17 <n0042> Oh nice
22:30:18 <dsal> Save yo #
22:30:20 <dsal> Save yo $
22:30:21 <dsal> damnit
22:30:34 <n0042> Okay I see how (.) works now
22:30:43 <zyklotomic> i'm going to go out on a limb though and say that sometimes
22:30:52 <zyklotomic> take 5 $ repeat 10 is just easier to read
22:31:12 <zyklotomic> or my brain hasn't been molded enough
22:31:43 <dsal> > let f = show . sum . take 5 . repeat  in   f 10
22:31:45 <lambdabot>  "50"
22:32:58 <n0042> For something a little different, do any of you know if it's true that last is an O(n) function? Like, if you wanted to use a list as a Queue, would it really be O(n) to call last to dequeue? 
22:33:08 <dsal> > let f = nub . sort show . sum . take 11 . repeat  in   f 13
22:33:11 <lambdabot>  error:
22:33:11 <lambdabot>      • Couldn't match expected type ‘b -> [a2]’ with actual type ‘[a0]’
22:33:11 <lambdabot>      • Possible cause: ‘sort’ is applied to too many arguments
22:33:14 <dsal> stupid keyboard
22:33:17 <dsal> > let f = nub . sort . show . sum . take 11 . repeat  in   f 13
22:33:19 <lambdabot>  "134"
22:33:20 <n0042> I sort of assumed that the built-in list object would have a tail pointer, but hoogle says that's O(n)
22:33:39 <dsal> @src (:)
22:33:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:33:42 <dsal> boooo
22:33:49 <dsal> a list is just a head and a tail.
22:33:51 <n0042> Whoah that bot has atittude
22:34:24 <dsal> It's a cons list.  You said you're familiar with lisp.
22:34:36 <n0042> Right, a singly-linked list with a head pointer
22:35:08 <n0042> So to get the last element you would have to traverse all the way down the list, hence O(n).
22:35:43 <n0042> But there's no reason you couldn't have the low-level logic include a tail pointer so that last is O(1).
22:35:48 <dsal> Lists are great, but if you need other performance characteristics, there are better data structures.
22:35:59 <dsal> There are many, many reasons you can't do that.
22:36:05 <dsal> But if you disagree, write one.
22:36:18 <dsal> Haskell has very little magic.  You can write most of what you see.
22:36:34 <dsal> Even many of the super fancy compiler optimizations are library-definable.
22:37:26 <n0042> My plan was to use Data.Array but that seems kind of un-functional. What would you suggest?
22:37:34 <dsal> Vector?
22:37:38 <dsal> Seq?
22:37:40 <MarcelineVQ> for what?
22:37:50 <n0042> To simulate a Queue, or circular buffer
22:38:25 <dsal> Lists are fine for many of these things, but there are specific structures.
22:41:07 <zyklotomic> is it a bad practice to append to the front of a list instead tehn
22:41:12 <zyklotomic> to get around the time complexity of ++
22:41:19 <dsal> It's the best.
22:41:23 <n0042> Seems like the opposite. Bad practice to append to the rear
22:41:26 <dsal> No better place to put something.
22:41:35 <dsal> ++ is another one of those language warts.
22:41:43 <MarcelineVQ> lists make pretty good queues in haskell  https://rafal.io/posts/haskell-queues.html
22:42:18 <zyklotomic> dsal: so lists make a pretty bad monoid?
22:42:20 <MarcelineVQ> This doesn't explain super in depth, but the idea is to use two lists with one in reverse to create your queue
22:42:37 <dsal> zyklotomic: ++ vs. <>
22:42:41 <n0042> Thank you very much
22:42:44 <dsal> lists are fine for what they do
22:43:43 <MarcelineVQ> There's a lot of queue-like things around though so you'd probably just want to use whatever and optommize later, Seq that dsal mentioned is a fair all-around option for accessing either end of.
22:44:24 <n0042> Oh wow, Haskell has built-ins for everything
22:44:34 <dsal> built-in?
22:45:14 <n0042> Stuff you don't have to roll on your own. 
22:45:24 <MarcelineVQ> dsal: people who don't already know don't know what you mean when you say you don't like map and ++. They won't realize you mean you don't like that there's both fmap and map and just want one, or relatedly that ++ and <> are the same for lists so just <> is fine
22:45:35 <dsal> Oh.  Not built-in, just already implemented..
22:45:44 <n0042> Yes, thank you
22:46:08 <dsal> MarcelineVQ: that's true.  People should understand me better.  heh
22:46:24 <n0042> You've both been very helpful, thank you.
22:47:10 <dsal> The functional data structure stuff is amazing.  That queue thing was amazing to see.
22:47:56 <zyklotomic> MarcelineVQ: wait, I don't think ++ and <> are the same
22:48:03 <dsal> :t (++)
22:48:05 <lambdabot> [a] -> [a] -> [a]
22:48:06 <dsal> :t (<>)
22:48:07 <lambdabot> Semigroup a => a -> a -> a
22:48:11 <MarcelineVQ> The okasaki paper is a bit of a hard read if you're new to it all but it's pretty great, interesting how little progress there's been since it at as well
22:48:13 <zyklotomic> which was what dsal meant
22:48:32 <dsal> ++ doesn't need to exist in Haskell.  Or, perhaps, <> should be ++
22:48:40 <dsal> Same as map vs. fmap
22:49:26 <MarcelineVQ> Where your Semigroup is [a] then <> = ++
22:49:55 <zyklotomic> <> should be ++ i think
22:50:05 <zyklotomic> ++ looks more natural
22:50:24 <zyklotomic> idk about fmap vs map though if you had to pick one of the two
22:50:52 <dsal> Sure.  It's just one of those things that is too much legacy code.
22:50:53 <zyklotomic> MarcelineVQ: I meant the implementation, I'm not sure if they behave the same
22:51:02 <zyklotomic> I get that they're isomorphic
22:51:15 <dsal> How could they behave differently?
22:51:15 <zyklotomic> mconcat xss = [x | xs <- xss, x <- xs]
22:51:27 <zyklotomic> (++) []     ys = ys
22:51:29 <zyklotomic> (++) (x:xs) ys = x : xs ++ ys
22:51:41 <dsal> @quick \l1 l2 -> (l1 ++ l2) === (l1 <> l2)
22:51:41 <lambdabot> Not enough privileges
22:51:53 <dsal> @check \l1 l2 -> (l1 ++ l2) === (l1 <> l2)
22:51:55 <lambdabot>  +++ OK, passed 100 tests.
22:51:55 <MarcelineVQ> That is the implementation :>  http://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-306
22:52:22 <zyklotomic> my bad im barking up the wrong tree
22:52:34 <zyklotomic> I looked into Data.Monoid
22:54:10 <zyklotomic> wait so that wasnt disagreeing with lists being a somewhat inefficient monoid then
22:54:27 <n0042> So when I asked about lists with tail-pointers dsal said "There are many, many reasons you can't do that." I have implemented a few linked lists in C and I've done some LISPing, but I'm far from an expert. I would be interested in hearing some of those reasons. Is it a performance thing, from the days of yore? Thanks again for answering my
22:54:27 <n0042> questions. You folks are all very helpful.
22:55:19 <n0042> I've learned more just hanging out in here for an hour than in the last two days combined. You guys are great.
22:55:59 <glguy> n0042, the issue is that things aren't mutable, so you can't use a reference to the last element to add to the end of a list
22:56:26 <glguy> Unless you build a mutable structure explicitly with mutable references that's accessed using IO actions
22:57:48 <zyklotomic> I was also thinking, what about [1..]
22:58:26 <dsal> let a = 1:a in take 5 a
22:58:32 <dsal> > let a = 1:a in take 5 a
22:58:34 <lambdabot>  [1,1,1,1,1]
22:59:39 <dsal> > let a = 'x':a in length a
22:59:46 <lambdabot>  mueval: ExitFailure 1
22:59:52 <dsal> boo.  Too many exes.
23:00:32 <MarcelineVQ> how many, would you say?
23:00:33 <dsal> n0042: A lot of these questions get a lot easier when you try to do the thing you think is probably easy.  :)
23:01:35 <n0042> That's good advice in general, for sure
23:01:46 <dsal> > let a = 'x':a in take 5  (a <> "and then y")
23:01:48 <lambdabot>  "xxxxx"
23:02:40 <dsal> I just made a list of infinite length and appended a list to the end of it.  Please adjust pointers accordingly.  :)
23:08:40 <n0042> Is the `<> "and then y"` part ever evaluated? 
23:09:28 <n0042> lazy evaluation is pretty wild. I'm still trying to wrap my head around that part.
23:11:21 <ClaudiusMaximus> n0042: it's evaluated, just enough to push it down 5 cells:  (x : xs) <> ys = x : (xs <> ys)  happens 5 times during the evaluation of the result, after which take drops it
23:16:02 <n0042> Yeah, I have no idea how you'd do the pointers for that. That's a mind-bender.
23:16:32 <dsal> It's really easy to follow if you don't try to think about how you'd write it as a singly linked list in C.
23:16:55 <n0042> Conditioning is hard to break '=D 
23:17:06 <n0042> But thank you for bearing with me. I really appreciate it
23:17:32 <dsal> What is `a`?   It's a list where the head is 'x' and the tail is some other stuff.  If you only need the head, you're done.  If you need the tail, you look at that.  Oh, it's `a, that's a list where...
23:28:03 <n0042> If I replace `take 5` with `tail` that sequence generates `x`s forever. That is wild.
23:33:15 <dsal> @src tail
23:33:15 <lambdabot> tail (_:xs) = xs
23:33:15 <lambdabot> tail []     = error "Prelude.tail: empty list"
23:35:21 <dsal> :t tail . tail . tail
23:35:23 <lambdabot> [a] -> [a]
23:36:09 <dsal> Or you could `drop ∞` and get to that appended bit.
23:36:23 <dsal> @src drop
23:36:23 <lambdabot> drop n xs     | n <= 0 = xs
23:36:23 <lambdabot> drop _ []              = []
23:36:23 <lambdabot> drop n (_:xs)          = drop (n-1) xs
23:36:35 <dsal> drop isn't partial.
23:36:48 <dsal> I wonder why `tail` isn't `drop 1`
23:37:03 <dsal> @check \l -> tail l === drop 1 l
23:37:05 <lambdabot>  *Exception: Prelude.tail: empty list
23:37:17 <dsal> 👍
23:37:33 <n0042> That's what I was trying to do. I was trying to see what I could put in there to get to the appended part
23:37:34 <dsal> Partial functions aren't awesome.
23:37:55 <dsal> It's an infinitely long list, do you'd have to drop infinite items first.
23:40:09 <n0042> I was trying to get a better grip on the "let" and "in" syntax earlier today, and that was a pretty useful practical example. Thank you.
23:42:34 <dsal> This is one of the things I like about the book mentioned earlier.  If you think about eager evaluation in C or something, you'll find haskell confusing.  If you stop pretending you know things, it'll make a lot more sense.
23:43:22 <dsal> (also worth noting that list isn't mentioned for like, several chapters, and you make it yourself)
