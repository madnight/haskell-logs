00:01:52 * hackage ghc-check 0.5.0.3 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.5.0.3 (PepeIborra)
00:10:38 <maerwald> bqv: restrictive is good
00:11:00 <maerwald> it gives you clear rules to reason about
00:11:30 <maerwald> after enabling a few advanced haskell extensions, I doubt most ppl are able to reason about what's going on anymore
00:11:49 <bqv> Heh
00:14:07 <nshepperd> well, restrictiveness is necessary for clear rules for reasoning but not sufficient imo
00:15:26 <maerwald> Rust rejects a lot of perfectly well-formed memory-safe programs. It doesn't attemtp to be a memory safety checker. I think that's why it's so successful
00:16:32 <maerwald> It's a smart balance between ergonomics and complexity
00:49:02 <dminuoso> @quote monochrom dialectic
00:49:02 <lambdabot> monochrom says: Programming is a dialectic class struggle between the author and the user.  My freedom is your slavery. Your ignorance is my strength.
00:50:29 <dminuoso> Even Haskells type system is balanced between ergonomics and expressiveness. Once you start encoding logic into the type system, you very quickly get into dependent typing, and then you spend a lot more time convincing your compiler of seemingly obvious truths.
00:51:12 <maerwald> IME haskellers tend to pick complex solutions a little more eagerly
00:51:26 <dminuoso> Not just them, that's a programmers disease.
00:51:42 <maerwald> Go devs? :D
00:52:12 <dminuoso> lispers will macro their way through trivial problems, rubyists will use reflection left and right, C++ folks will stack their logic into thick layers of template instantiation rules
00:52:20 <dminuoso> All of them resorting to these tools rather quickly
00:52:44 <maerwald> and that's all fun as long as it's a hobby
00:52:56 <dminuoso> or until you depend on their hobby :p
00:53:25 <dminuoso> Perhaps its in that sense go is actually a good language, because it just doesn't have any tools to go crazy.
00:53:50 <dminuoso> It just forces a lot of boilerplate/manual labor on you, but it doesn't actually let you come up with meaningful abstractions
00:54:02 <maerwald> I could do go maybe 3 months a year. But any more, I'd get so bored that I'd just quit.
00:54:44 <maerwald> but fast compilation times is great
00:54:46 <dminuoso> Well yeah, it's difficult to find the good balance, bringing us back to monochrom's quote above.
00:54:52 <maerwald> something we'll probably never see
00:54:59 <merijn> maerwald: I think that depends where you look too
00:55:07 <dminuoso> To be fair, if you write go-style code, Haskell compiles similarly fast
00:55:18 <merijn> A lot of the people who write blogposts are writing them about the overcomplicated type level stuff
00:55:26 <merijn> No one writes about "boring" Haskell
00:55:28 <dminuoso> iow go is just fast to compile precisely because the language has barely any interesting semantics to speak of
00:55:45 <maerwald> merijn: and the basics are already quite expressive
00:56:14 <maerwald> dminuoso: but it enables rapid development
00:56:19 <merijn> Extensions and type level stuff are like spices
00:56:28 <merijn> A little can go a *long* way
00:56:37 <dminuoso> maerwald: I think the "rapid development" is in a different sense. The main goal of go seems to be to hire people and train them for a language as fast as humanly possible.
00:56:37 <maerwald> in haskell, I have one checkout per branch, because switching branches wastes about 30 minutes time at worst
00:56:48 <dminuoso> Not to be highly productive in it
00:57:22 <dminuoso> The lack of abstractions puts an upper limit to how far you can write software, it requires tremendous amounts of discipline.
00:57:39 <dminuoso> Like, only very few C projects ever become large *and* maintainable
00:57:48 <dminuoso> postgres is the only one that comes to mind, in fact
00:58:00 <merijn> dminuoso: SQLite?
00:58:06 <dminuoso> merijn: I have not seen their source code.
00:58:37 <merijn> dminuoso: I've skimmed through it (not the amalgamation, of course) and it seems reasonable enough
00:58:49 <dminuoso> merijn: Fair enough, did you also skim through postgres code?
00:58:53 <dminuoso> Just for comparison?
00:58:56 <merijn> No
01:00:27 <dminuoso> maerwald: But yeah, if you stray away from non-Haskell2010, hit a lot of inline pragmas, keep large modules, the GHC compilation times are bad.
01:00:39 <dminuoso> How well does LSP work for these projects?
01:00:50 <dminuoso> From my experience, it's blazing fast even for our largest project
01:01:46 <merijn> dminuoso: LSP worked well on my phd stuff before I broke the ghcide setup again >.>
01:02:28 <merijn> then again, I think that code is a stress test for editor tooling :p
01:02:51 <merijn> multiple components, internal libraries, C FFI, CAPI FFI, Template Haskell :p
01:04:34 <maerwald> And go has ccache style build cache
01:04:43 <maerwald> even caches tests
01:04:56 <maerwald> dream on, haskellers :p
01:07:20 <asheshambasta> https://gist.github.com/asheshambasta/3597d25f179fc2729286c4b02387f282#file-cabal-err-L9-L10 -- is cabal complaining about the http-types version mismatch? And if so, ther _is_ no mismatch?
01:07:30 <asheshambasta> there*
01:09:02 <merijn> asheshambasta: There is a mismatch
01:09:15 <merijn> Look at the letters after the version number
01:09:39 <asheshambasta> I don't understand :-( 
01:09:46 <merijn> asheshambasta: The hash is different, which means it has two different plans for http-types
01:09:48 <dminuoso> There's possibly a mismatch in build flags
01:10:01 <merijn> asheshambasta: i.e. mismatch in either compilation flags or transitive dependencies
01:10:11 <dminuoso> increase verbosity of cabal 
01:10:17 <dminuoso> 2 should be enough I think?
01:10:58 <asheshambasta> So, the cabal file of prelude-polysemy (a package I'm trying to use as dependency), doesn't have any version bounds on http-types, nor does it have any flags. So I'd assume they're the same? 
01:11:10 <dminuoso> Increase verbosity of cabal
01:16:50 <asheshambasta> dminuoso: what should I be looking for in the output? I've tried `-v3` and `--minimize-conflict-set`
01:17:42 <dminuoso> are you by any chance still using cabal v1-?
01:17:48 <asheshambasta> it seems to start with a bunch of `trying` & `rejecting` outputs for packages that look unrelated to this issue (at the start of the output, and eventually outputting almost the same thing at the end)
01:18:07 <asheshambasta> dminuoso: no, I'm trying with `cabal new-repl ...`
01:18:09 <dminuoso> well, gist the output
01:18:26 <dminuoso> Just want to know whether cabal perhaps can tell why exactly its rejecting the packages
01:19:14 <dminuoso> Also, what is prelude-polysemy?
01:19:59 <asheshambasta> https://gist.github.com/asheshambasta/3597d25f179fc2729286c4b02387f282#file-cabal-detailed-err (I've taken the last few lines which seemed relevant to me)
01:25:20 <merijn> Where is the prelude-polysemy cabal file? Because I don't see such a package anywhere
01:25:43 <dminuoso> Arguably this is still a cabal diagnostics bug
01:26:09 <dminuoso> It's frequently very hard to decipher why cabal cant find a build plan. In principle I understand that cabal can't tell you the exact reason because it's just a sat solver..
01:26:10 <merijn> dminuoso: Add it to milestone _|_ :p
01:26:18 <dminuoso> But in this case..
01:26:24 <dminuoso> [__3] trying: servant-reflex-0.3.6/installed-9BB... (dependency of fht-api)
01:26:29 <dminuoso> What does "servant-reflex-0.3.6/installed-9BB..." mean exactly?
01:26:45 <dminuoso> Is that a vendored package?
01:27:06 <dminuoso> that is, what does installed-XYZ mean here
01:27:18 <asheshambasta> merijn: its a local dependency, I'll push it to GHub.
01:27:30 <merijn> the XYZ (I'm guessing) is just the v2 hash
01:27:48 <merijn> Not sure what installed means
01:27:59 <dminuoso> [__4] rejecting: jsaddle-0.9.7.0/installed-ITO... (conflict: prelude-polysemy => http-types==0.12.3/installed-F2x..., jsaddle => http-types==0.12.3/installed-8Tx...)
01:28:08 <dminuoso> This should at least contain the information to see where the conflict arises from
01:28:24 <dminuoso> mmm
01:28:28 <merijn> dminuoso: Patches welcome ;)
01:28:45 <asheshambasta> https://github.com/asheshambasta/prelude-polysemy/blob/master/prelude-polysemy.cabal
01:30:03 <dminuoso> asheshambasta: do you have any cabal.project / cabal.project.local file in use?
01:30:09 <dminuoso> that would set additional constraints
01:30:24 <dminuoso> Also, can you edit the previous gist to contain the *entire* output of cabal -v2 ...?
01:31:08 <asheshambasta> in the package that depends on prelude-polysemy, yes, however, the .local files are empty (I need to add them to make a dante-method work), and the cabal.project only contains the paths to each subprojects.
01:31:48 <asheshambasta> here's the project in its entirety: https://github.com/asheshambasta/flowerpower/tree/showcase/servant-reflex-dependency
01:32:19 <merijn> Fascinatingly, http-types has a super small dependency list
01:36:16 <dminuoso> asheshambasta: can you supply the entire output of `cabal -v2 new-repl`?
01:36:26 <dminuoso> And perhaps crank up the verbosity to 3
01:36:43 <dminuoso> (Dunno if that helps, but Im hopeful cabal will at *some* point talk about the constraints/build flags)
01:37:16 <dminuoso> Also, you could move your cabal new store away, hopefully cabal wont talk about weird hashes but versions/build flags instead
01:38:32 <asheshambasta> https://gist.github.com/asheshambasta/3597d25f179fc2729286c4b02387f282#file-cabal-full0-err
01:39:48 <merijn> oh...this is inside Nix
01:39:53 <merijn> Well, good luck, then :p
01:40:02 <dminuoso> The nix part shouldnt matter
01:40:12 <dminuoso> asheshambasta: can you hide the cabal store for this?
01:40:31 <dminuoso> (just rename `.cabal/store/{ghc-version}` or just `.cabal/store`)
01:41:24 <merijn> dminuoso: Is the store actually there in a nix-shell, though?
01:41:35 <dminuoso> merijn: the nix-shell doesn't sandbox you
01:41:44 <dminuoso> It, roughly, just manipulates the PATH
01:42:03 <dminuoso> But the cabal stuff, unless managed otherwise, is located by default at ~/.cabal
01:42:14 <dminuoso> this is not a nix-build
01:42:51 <asheshambasta> https://gist.github.com/asheshambasta/3597d25f179fc2729286c4b02387f282#file-cabal-full1-err
01:43:00 <merijn> Which version of cabal-install is this, btw?
01:43:23 <dminuoso> asheshambasta: did you rename the cabal store in your home directory?
01:43:30 <asheshambasta> dminuoso: yeah
01:43:40 <dminuoso> Ah
01:43:56 <dminuoso> strange, it still seems to see them
01:44:12 <asheshambasta> merijn: 3.0.0.0
01:45:25 <dminuoso> asheshambasta: can you also nuke/rename your dist-newstyle directory?
01:47:06 <dminuoso> Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal
01:47:08 <dminuoso> update' to download it.
01:47:14 <dminuoso> Ah, you should run `cabal v2-update` btw
01:47:18 <merijn> oh, lol
01:47:21 <merijn> dammit
01:47:40 <merijn> if that's it I'm gonna be mad for missing it
01:47:50 <dminuoso> Well, on the initial problem it was not there
01:48:00 <dminuoso> they renamed the store, so they have to redownload the index
01:48:09 <dminuoso> It was my mistake for not mentioning this
01:48:15 <dminuoso> (In th emiddle of -v3 its easily missed)
01:48:29 <dminuoso> But also rename/nuke your dist-newstyle
01:48:39 <dminuoso> I found the dist-newstyle caches to be surprisingly brittle
01:48:52 <dminuoso> I've had half a dozen "delete dist-newstyle and rebuild, and then it compiles" bugs already
01:48:52 * hackage casa-types 0.0.2 - Types for Casa  https://hackage.haskell.org/package/casa-types-0.0.2 (MichaelSnoyman)
01:48:54 <dminuoso> this week
01:48:57 <asheshambasta> this is with dist* nuked: https://gist.github.com/asheshambasta/3597d25f179fc2729286c4b02387f282#file-cabal-full2-err
01:49:13 <merijn> dminuoso: Really? I've not had that in...months, possibly years
01:49:47 <dminuoso> merijn: Yeah
01:50:08 <dminuoso> merijn: Yesterday I had a much much worse bug 
01:50:29 <maerwald> just never switch branches, ever, then you have less cache bugs
01:50:54 <maerwald> IME, stack was wores when switching branches though
01:51:06 <dminuoso> merijn: bunch of servant endpoints. in the tests using servant-client I called endpoint A, then B, then A again. On the second A call it *hung* inside of servant mysteriously.
01:51:09 <dminuoso> Here comes the real beauty now:
01:51:32 <dminuoso> recompiling my library with -threaded, it worked again
01:51:36 <dminuoso> removing -threaded, it still worked.
01:52:05 <dminuoso> So I have a piece of software with a real quantum mechanical weirdness bug that I dont know whether its fixed
01:52:27 <maerwald> have you tried turning it on and off again? :D
01:52:57 <bqv> Dipping my nose into arrows (again). I have a decent understanding, this time, but the static/dynamic example intrigues me. What precisely is different between such a static arrow and e.g. the state monad
01:53:03 <dminuoso> Perhaps cabal 3.2 is just buggy and brittle?
01:53:15 <maerwald> I'm running 3.4 rc since a while
01:53:18 <maerwald> it's better
01:53:41 <bqv> dminuoso: test using nix, for hermeticity?
01:53:53 <dminuoso> bqv: We have a large dependency footprint
01:54:01 <bqv> Ah
01:54:13 <dminuoso> After the nth conflict and fixing numerous haskell packages, I was just sick of it.
01:54:39 <dminuoso> Updating dependencies in such a scenario is just really painful
01:54:53 <dminuoso> So we build with cabal v2-* instead
01:55:41 <dminuoso> asheshambasta: out of curiosity, can you share your cabal config?
01:56:26 <merijn> dminuoso: eh
01:56:34 <merijn> dminuoso: -threaded is a no-op for libraries
01:57:29 <dminuoso> merijn: Isn't it great?
01:57:31 <merijn> bqv: tbh, I'd consider Arrows pretty much obsolete and not really worth investing too much time in :)
01:57:49 <dminuoso> Yesterday was not good for my trust in cabal/ghc.
01:57:51 <bqv> merijn: oh? Obsoleted by what?
01:57:56 <dminuoso> bqv: profunctors
01:57:59 <dminuoso> largely
01:58:02 <dminuoso> and applicative
01:58:02 <merijn> bqv: A mix of Applicative/Profunctor/Category
01:58:08 <bqv> Huh, cool
01:58:33 <dminuoso> judging from the past 12 months, the only use case for arrow seems to be using some older frp libraries
01:58:34 <merijn> bqv: basically, unlike Applicative/Monad which were useful in tons of places, Arrow just never turned out to be very useful
01:58:56 <bqv> fair enough
01:59:17 <dminuoso> asheshambasta: can you share the output of `ghc-pkg list` inside the nix-shell?
01:59:24 <merijn> bqv: Consider this: Arrow predates Applicative by a few years, yet Applicative is *everywhere* and Arrow is not ;)
01:59:35 <dminuoso> asheshambasta: Im a bit clueless, so this is just poking for information.
01:59:47 <bqv> Wait it does?
01:59:50 <bqv> Woe
01:59:56 <dminuoso> Applicative is relatively new
02:00:09 <merijn> bqv: The first Arrow paper is from 2000, the first Applicative paper is from 2004, iirc
02:00:17 <dminuoso> (Though to be absolutely fair, there isnt a lot of purely applicative code)
02:00:26 <dminuoso> most applicative code is just monadic in disguise
02:00:37 <bqv> Mm
02:01:04 <dminuoso> like, from a consumer perspective you might opt to use the applicative interface of some type, that happens to also be a monad
02:01:12 <dminuoso> And coherence laws ensures they are the same for that
02:01:20 <merijn> bqv: Similarly, monadic IO didn't make it into Haskell until (I think?) the 5th revision of the report, something like 6 years into the language's existence
02:01:28 <dminuoso> e.g. writing `Foo <$> parserA <*> parserB` is often just monadic
02:01:35 <asheshambasta> dminuoso: https://gist.github.com/asheshambasta/3597d25f179fc2729286c4b02387f282#file-ghc-pkg_list-txt
02:02:02 <bqv> merijn: ha, that's astonishing
02:02:10 <dminuoso> asheshambasta: that looks very wrong.
02:02:26 <merijn> bqv: but monadic IO and Applicative spread like wildfire, because they're objectively great at solving very common problems. Arrow was envisioned as doing the same, but it never really caught on practically
02:02:36 <dminuoso> asheshambasta: ghc-pkg should be largely empty
02:02:45 <dminuoso> No idea why cabal new-* even picks those up
02:02:47 <dminuoso> (is that by design)
02:02:58 <dminuoso> asheshambasta: if you empty that, your package will compile again
02:03:18 <merijn> bqv: In the first versions of Haskell you had "main :: [IOResponse] -> [IORequest]", where you got a lazy list of IOResponse as input while you generated a lazy list of IORequests as output
02:03:26 <asheshambasta> I ran this inside the nix-shell, did you mean that I run this outside?
02:03:28 <bqv> I mean the part of arrows that was interesting was the static/dynamic thing that apparently saves on space complexity - but I think you can basically do that with a tuple anyway, its just syntax sugar
02:03:47 <bqv> merijn: sheesh
02:04:30 <merijn> bqv: So you'd insert something like 'ReadFile "foo"' as result and that'd result in (eventually) appending 'FileRead "foo" {- data here -}' to the input, which is a massive pain to work with, obviously :p
02:04:57 <bqv> Yeah :|
02:05:05 <merijn> bqv: Well, the idea with Arrow was that you can "inspect" stuff without running any code, but Applicative gives you the same
02:05:15 <merijn> :t (<*>)
02:05:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:05:40 <merijn> bqv: Note that both arguments of <*> are 'f ?', so you can inspect the 'f' part of both sides
02:05:44 <merijn> :t (>>=)
02:05:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:06:17 <merijn> As opposed to >>= where the 'm' is on only the left side (you need to call a function and do stuff first, before you get an 'm' back)
02:07:39 <bqv> Huh... that doesn't seem all that innovative
02:08:53 <dminuoso> asheshambasta: no
02:09:21 <merijn> bqv: http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf :)
02:09:50 <bqv> Nah I get applicative, I just thought there was more to Arrow
02:10:16 <merijn> bqv: I mean there is, but the typeclass definition ruins it by having 'arr'
02:10:17 <merijn> :t arr
02:10:18 <lambdabot> Arrow a => (b -> c) -> a b c
02:10:43 <merijn> bqv: Requiring the ability to lift arbitrary functions into the arrow ruins like half the interesting usecases
02:10:52 <bqv> Heh
02:11:25 <merijn> Because now anything that functions can't be turned into is ruled out
02:11:47 <merijn> bqv: Category is in that sense more interesting
02:11:55 <merijn> :t (Control.Category..)
02:11:56 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
02:12:00 <merijn> oof
02:12:08 <merijn> I forgot about the kind polymorphism
02:12:16 <bqv> Ha
02:12:20 <merijn> Pretend everything before the . is missing ;)
02:12:25 <bqv> Very generic
02:12:26 <merijn> :t Control.Category.id
02:12:28 <lambdabot> forall k (cat :: k -> k -> *) (a :: k). Category cat => cat a a
02:12:38 <dminuoso> asheshambasta: So ghc-pkg is the database for "available packages"
02:12:45 <dminuoso> you can register packages there, etc
02:12:59 <dminuoso> it's how manual ghc and cabal v1- worked
02:13:07 <merijn> so you have (simplified): 'id :: Category cat => cat a a' and '(.) :: Category cat => cat b c -> cat a b -> cat a c'
02:13:32 <dminuoso> cabal v2- still uses this interface, but instead of maintaining this "global package database", cabal v2- generates a sort of transient package database based on its build plan, and tells ghc to use that instead.
02:13:32 <merijn> bqv: That's like half the composition stuff of Arrow, without needing to support functions
02:13:46 <bqv> Yeah, that makes sense
02:13:59 <dminuoso> asheshambasta: it seems as if the build planning consults ghc-pkg, which I think is strange because you're using new-style
02:14:02 <merijn> bqv: Do you know about contravariant functors?
02:14:14 <bqv> Yeah, via profunctors
02:14:56 <merijn> bqv: Right, so profunctors are basically contravariant on one side and functors on the other side (which also mirrors a bunch of Arrow stuff, but again, without 'arr')
02:15:28 <merijn> bqv: So you can get most (all?) of the functionality of Arrow by mixing Category + Profunctor, but now you don't have to deal with that PITA 'arr'
02:15:54 <bqv> Neat. So it's totally deprecated
02:16:25 <merijn> Aside from some niche FRP libraries I don't think any modern/widely used library uses it
02:16:45 <dminuoso> asheshambasta: out of curiosity, if you use v2-repl instead of new-repl, does it still give the same errors?
02:17:09 <bqv> Heh
02:18:16 <asheshambasta> dminuoso: seems like it, yeah
02:19:25 <dminuoso> asheshambasta: Seems like that's the regular behavior then
02:19:31 <dminuoso> asheshambasta: do you use cabal v1- anywhere?
02:21:55 <dminuoso> asheshambasta: Anyhow. As an immediate hotfix, nuke/rename your ~/.ghc/{version}/environments/
02:22:02 <dminuoso> And stop using cabal v1- I guess
02:22:20 <dminuoso> It's possible there is a more eloquent hotfix, possibly via cabal.project.local where you specify a custom package.db
02:23:44 <dminuoso> Im not actually sure what the right thing is, whether this is a bug, etc. At the very least I'd perhaps file an issue on cabal for documentation.
02:24:15 <dminuoso> (Naively it seems unreasonable for cabal v2-* to consider the ghc-pkg database for its build plan)
02:24:28 <dminuoso> It does so in 3.2.0.0 as well, I checked.
02:25:01 <dminuoso> Because by doing so, it's not really nix-style. cabal should *dictate* the package.db, not amend it.
02:25:49 <merijn> dminuoso: Actually, v2 *intentionally* disregards the package database
02:25:57 <dminuoso> merijn: evidently not?
02:26:01 <merijn> v1 used to consider it
02:26:24 <dminuoso> `cabal v2-build` specifically interrogates ghc-pkg before build planning
02:26:29 <dminuoso> Just run with -v3 in your projects and see
02:26:54 <merijn> The fact that it consults it doesn't mean it's used for buildplan resolution
02:27:54 <asheshambasta> dminuoso: should running `cabal v2-update` have an adverse effect on the system as a whole within `nix-shell`?
02:28:02 <dminuoso> asheshambasta: yeah
02:28:05 <asheshambasta> It seems like the packages that used to build earlier no longer build for me 
02:28:17 <dminuoso> asheshambasta: two things:
02:28:26 <dminuoso> a) that means you were lazy on your constraints
02:28:33 <dminuoso> b) cabal told you how to restore to the old index state
02:28:57 <dminuoso> (when you ran `cabal v2-update`)
02:29:25 <asheshambasta> dminuoso: what can be done to fix it? 
02:29:32 <tomsmeding> b)
02:30:27 <dminuoso> merijn: you're right though, Im making an educated guess that this is the cause
02:30:34 <asheshambasta> dminuoso: well, I ran `nix-shell --run 'cabal v2-update'` and then upon realising that this could cause issues, I killed it before it finished. It seems it had enough time to do some damage.
02:30:54 <dminuoso> merijn: but the fact that ghc-pkgs happens to list two entries for http-types, and the fact that the solver keeps talking about "installed-" packages..
02:30:59 <dminuoso> It's an educated guess.
02:31:17 <asheshambasta> dminuoso, tomsmeding: for `b`, what can be done? Cabal doesnt' seem to be telling me how to restore the old state.
02:31:26 <dminuoso> asheshambasta: you should have let it run its course.
02:31:40 <dminuoso> asheshambasta: try running it again, and see if cabal state is healthy enough to report how to revert it
02:31:53 <dminuoso> if not, you have to bite the bullet and update your constraints
02:31:59 <dminuoso> but, you should be doing this anyway :)
02:32:11 <asheshambasta> or maybe this is unrelated though, I can run `nix-shell --run 'cabal new-repl' ` in other packages, just not in ~/.xmonad anymore (cannot find xmonad-contrib for some reason)
02:33:03 <asheshambasta> What does cabal v2-update do exactly? It seems to be calling hackage to update some index, but within a nix environment, do you want it to talk to hackage directly?
02:33:30 <dminuoso> asheshambasta: the nix-shell merely provides cabal-install the binary
02:33:35 <dminuoso> beyond that, there's nothing nixy about it
02:34:30 <tomsmeding> where does cabal even store the previous index states
02:34:52 <merijn> tomsmeding: It doesn't, the index is append only
02:34:59 <merijn> tomsmeding: So storing the previous index makes no sense
02:35:17 <merijn> tomsmeding: You can just "ignore the last part of the index" and achieve the same effect
02:35:26 <tomsmeding> makes sense
02:35:31 <dminuoso> asheshambasta: so there's two thoughts here:
02:35:43 <merijn> tomsmeding: In fact, that's literally what the index-state entry in cabal.project does :p
02:35:55 <merijn> It simply skips all entries after a certain timestamp
02:36:08 <tomsmeding> can't you then run the cabal update command with a random timestamp just before the concerned update command
02:36:16 <dminuoso> asheshambasta: either you want nix, but then you have to use `nix` instead of `cabal-install`. Then you could use callCabal2nix with shellFor (giving you interactive shells)
02:36:46 <dminuoso> asheshambasta: Or you want to do this with cabal. In order to get semi-deterministic builds, you have to either pin all versions - or if you're fine with automatic PVP conform updates, keep PVP conform package version constraints.
02:37:04 <dminuoso> If you maintain clean version constraints, `cabal v2-update` is fine
02:37:19 <dminuoso> (A good mind model could be to regularly run `cabal v2-update`, forcing yourself to adhere to proper constraints.
02:37:28 <dminuoso> And if your dependencies suck in that regard, dont use brittle dependencies.
02:38:14 <bqv> The nix shell might be a haskell shell, in which case all remote stores will be disabled in cabal
02:38:24 <dminuoso> bqv: no
02:38:37 <dminuoso> nix-shell merely sets up an environment with packages present.
02:39:01 <bqv> dminuoso: and environment variables
02:39:08 <dminuoso> Say `nix-shell -p ghc` ensures that you have a shell with a ghc in path. Roughly, nix-shell will synthesize a bin/ directory, containing symlinks to /nix/store
02:39:18 <dminuoso> And put that bin/ directory onto your PATH
02:39:27 <dminuoso> (There's a few more involved things, but roughly that's the extend of it)
02:39:40 <bqv> Don't forget the environment variables. Enter a ghc shell, it sets NIX_GHC etc.
02:39:50 <dminuoso> If you want *pinning*, you have to go the nix + callCabal2nix + shellFor route
02:40:03 <bqv> Thats what I meant
02:40:23 <bqv> Thats the only viable route for a haskell shell at this point
02:40:42 <bqv> And since he has a shell.nix I assume its that
02:40:44 <dminuoso> Dunno, Im quite happy with `nix-shell -p cabal-install haskell-language-server`
02:40:53 <dminuoso> No, they are using this ^-
02:40:56 <dminuoso> As am I
02:40:58 <bqv> Oh, ok
02:41:11 <dminuoso> (well I have a slightly more elaborate shell.nix)
02:42:22 <bqv> I only keep using nix because it's way easier to maintain modified dependency packages via nix, than via cabal, tbh
02:42:47 <bqv> But that means installing in a v1-sandbox
02:42:54 <dminuoso> v1?
02:43:00 <bqv> Need sandbox
02:43:00 <dminuoso> nix does not use cabal-install
02:43:34 <dminuoso> in fact, sandboxes are long gone I think?
02:43:47 <bqv> shellFor, install in v1-sandbox to pin deps to nix version, then v1-build outside nix continues to use them
02:43:51 <dminuoso> ah
02:43:52 * hackage update-nix-fetchgit 0.2.4 - A program to update fetchgit values in Nix expressions  https://hackage.haskell.org/package/update-nix-fetchgit-0.2.4 (jophish)
02:43:56 <dminuoso> I see
02:45:00 <bqv> Might be able to achieve the same with a freezefile or something, idk
02:45:09 <bqv> Sandbox was just easier
02:46:35 <dminuoso> well, why sandbox at all?
02:46:51 <dminuoso> I mean shellFor *does* effectively give you a sandbox
02:47:09 <dminuoso> Id have to look at the implementation, but Id assume it just registers the nix versions with ghc-pkg
02:47:15 <dminuoso> Such that you can just say `ghci`
02:47:30 <bqv> oh, there was a reason…
02:47:30 <dminuoso> Potentially even `cabal v2-repl` or `cabal v2-build
02:48:01 <bqv> I can't remember now, but there was something that didn't work with that
02:48:07 <bqv> Oh!
02:48:13 <bqv> It was the libraries
02:48:18 <bqv> Native libs
02:48:23 <bqv> Something was funky
02:49:15 <bqv> Or was it cpphs
02:49:25 <bqv> Cpphs wasn't finding anything
02:49:54 <bqv> I dunno. In the end, taking nix at least partially out the picture made it all simpler
02:52:49 <asheshambasta> dminuoso: yeah, this kind of makes sense, and I've been lazy with version constraints.
02:57:22 <dminuoso> Perhaps, cabal should receive commands to manage dependencies. That way, you could say `cabal add-depends-on=foo some-component`, and if no constraints are supplied, cabal could just pin it on whatever fits in the build plan.
02:58:06 <dminuoso> this style of "add dependencies now and constraints later" always backfires 
02:58:08 <dminuoso> :p
03:11:40 <asheshambasta> dminuoso: yeah, and its something I still struggle with. A large part of it is also just being lazy.
03:11:56 <asheshambasta> I have to get around to doing it more. 
03:28:50 <maerwald> PVP and semver only work with good tooling and CI
03:29:20 <maerwald> e.g. https://dependabot.com/rust/
03:30:09 <merijn> I just set the bound to ^>= the latest release whenever I add a dependency
03:31:01 <merijn> maerwald: https://github.com/haskell-CI/hackage-matrix-builder/issues/72 https://github.com/haskell-CI/hackage-matrix-builder/issues/77
03:31:26 <merijn> The matrix builder is already pretty good, but it needs better notification tooling
03:31:41 <maerwald> dependabot does a bit more
03:32:19 <maerwald> generally, dependency bounds are unmaintained, except for popular packages like aeson
03:32:38 <merijn> dependabot probably also has more engineering manpower :p
03:41:49 <maerwald> merijn: do you know if the cabal file format has a formal grammar?
03:42:17 <merijn> maerwald: https://cabal.readthedocs.io/en/latest/buildinfo-fields-reference.html ?
03:42:40 <merijn> So, "mostly"
03:45:40 <maerwald> https://github.com/dependabot/dependabot-core/issues/2745
04:22:10 <tomsmeding> why does the readme at https://github.com/dependabot/dependabot-core list the languages that they support >=3 times, each time with a different order, and forgetting one in one of the places?
04:23:02 <tomsmeding> ah no they don't forget one, but the order point still stands
04:31:50 <dminuoso> Do you mean in the Setup?
04:33:52 * hackage phonetic-languages-constaints 0.1.0.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constaints-0.1.0.0 (OleksandrZhabenko)
04:39:52 * hackage deep-transformations 0.1 - Deep natural and unnatural tree transformations, including attribute grammars  https://hackage.haskell.org/package/deep-transformations-0.1 (MarioBlazevic)
04:46:29 <tomsmeding> dminuoso: I do
04:46:47 <tomsmeding> and the "What's in this repo" section
04:53:45 <xenon-> hi. is there a built-in function that will do this? [[1,2,3],[10,20,30],[100,200,300]] => [1,10,100,2,20,200,3,30,300]
04:53:55 <merijn> :t concat
04:53:57 <lambdabot> Foldable t => t [a] -> [a]
04:54:01 <merijn> :t mconcat
04:54:03 <lambdabot> Monoid a => [a] -> a
04:54:11 <merijn> oh, wait, interleaving
04:54:13 <merijn> hmm
04:54:16 <xenon-> yes
04:54:27 <merijn> I think sequence does that, in obscure ways?
04:54:36 <merijn> > sequence [[1,2,3],[10,20,30],[100,200,300]]
04:54:39 <lambdabot>  [[1,10,100],[1,10,200],[1,10,300],[1,20,100],[1,20,200],[1,20,300],[1,30,100...
04:54:56 <merijn> ah, hmm, what am I thinking off, then
04:55:12 <merijn> :t transpose
04:55:13 <lambdabot> [[a]] -> [[a]]
04:55:20 <merijn> That one should work
04:55:26 <merijn> > transpose [[1,2,3],[10,20,30],[100,200,300]]
04:55:28 <lambdabot>  [[1,10,100],[2,20,200],[3,30,300]]
04:55:38 <merijn> Then you just gotta mconcat the result
04:58:00 <xenon-> > mconcat $ transpose [[1,2,3],[10,20,30],[100,200,300]]
04:58:02 <lambdabot>  [1,10,100,2,20,200,3,30,300]
04:58:11 <xenon-> > concat $ transpose [[1,2,3],[10,20,30],[100,200,300]]
04:58:13 <lambdabot>  [1,10,100,2,20,200,3,30,300]
04:58:53 * hackage miv 0.4.6 - Vim plugin manager written in Haskell  https://hackage.haskell.org/package/miv-0.4.6 (itchyny)
05:13:22 * hackage language-oberon 0.3 - Parser, pretty-printer, and more for the Oberon programming language  https://hackage.haskell.org/package/language-oberon-0.3 (MarioBlazevic)
05:30:52 * hackage minizinc-process 0.1.3.0 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.3.0 (LucasDiCioccio)
05:48:29 <Iceland_jack> hi
05:49:26 <Uniaika> heya Iceland_jack 
05:49:53 <Iceland_jack> Hope everone is fine
05:50:10 <BatRumbata> so far so good
05:50:10 <BatRumbata> :D
05:50:15 <Iceland_jack> > (drop <> take) 3 "hello"
05:50:17 <lambdabot>  "lohel"
05:50:53 <Iceland_jack> I loved 'drop <> take' ever since I saw it here https://stackoverflow.com/questions/16378773/rotate-a-list-in-haskell
05:51:04 <hc> heh, that's cool :)
05:51:18 <Iceland_jack> I remember the first thing that got me really excited with Haskell was an instance of Semigroup (.. -> Ordering)
05:51:34 <Uniaika> yeah "drop <> take" is dope
05:52:32 <Iceland_jack> A similar elaboration happens in http://www.cse.chalmers.se/~josefs/publications/svenningsson2015combining.pdf which is one of my all time favs
05:54:33 <Iceland_jack>  
05:54:33 <Iceland_jack>             while 
05:54:33 <Iceland_jack> =           from While
05:54:33 <Iceland_jack> = \c     -> from (While :$ to c)
05:54:36 <Iceland_jack> = \c s   -> from (While :$ to c :$ to s)
05:54:44 <Iceland_jack> = \c s i -> from (While :$ to c :$ to s :$ to i)
05:54:44 <Iceland_jack> = \c s i -> from (While :$ Lam (to . c . from) :$ Lam (to . s . from) :$ to i)
05:55:37 <bqv> How on earth
05:56:12 <Iceland_jack> Those function instances (Syntactic (a->b))
05:56:19 <Iceland_jack> Are magic
05:56:22 * hackage language-Modula2 0.1 - Parser, pretty-printer, and more for the Modula-2 programming language  https://hackage.haskell.org/package/language-Modula2-0.1 (MarioBlazevic)
05:56:44 <bqv> Iceland_jack: my god that sly monoid instance
05:57:10 <Uniaika> sweet hell
05:57:10 <bqv> :t drop <> take
05:57:12 <lambdabot> Int -> [a] -> [a]
05:57:32 <Uniaika> monoid instances can lead to surprisingly interesting code
05:58:09 <bqv> Most of the time, bugs where things work that shouldn't, I track down to monoids
05:58:20 <Iceland_jack>            drop      <> take
05:58:21 <Iceland_jack> = \n    -> drop n    <> take n
05:58:21 <Iceland_jack> = \n as -> drop n as <> take n as
06:00:31 <Iceland_jack> It's worth noting
06:01:08 <Iceland_jack> deriving via (->) a `Ap` b instance Semigroup b => Semigroup (a->b)
06:01:08 <Iceland_jack> deriving via (->) a `Ap` b instance Monoid    b => Monoid    (a->b)
06:02:23 <bqv> Haskell doesn't like infinite types
06:02:39 <bqv> But does that include all infinite forms?
06:02:59 <merijn> bqv: You can trivially bypass that restriction via newtypes
06:03:26 <bqv> Ok, but without newtypes?
06:03:52 <nshepperd> what's an infinite form
06:03:56 <Iceland_jack> what do you mean by infinite form?
06:04:57 <bqv> I'm noting that (->) is an indexed type, so I'm wondering if you could make an infinite tree out of it
06:05:06 <bqv> And what that would even do
06:05:22 <bqv> With newtypes it wouldn't be callable
06:06:13 <merijn> bqv: I mean like "newtype Infinite a = Infinite (a -> Infinite)" works just fine
06:07:00 <merijn> nshepperd: Well, imagine [[[[a]]]], except nested, well, infinitely many times :)
06:07:16 <merijn> "newtype Infinite = Infinite [Infinite]"
06:08:12 <bqv> Ok how about another way, is there a way to create a function that takes an infinite number of args?
06:08:26 <bqv> :t fix const
06:08:27 <lambdabot> error:
06:08:27 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ b -> a
06:08:27 <lambdabot>       Expected type: (b -> a) -> b -> a
06:08:36 <bqv> Heh
06:08:50 <dminuoso> bqv: yes.
06:08:54 <dminuoso> with typeclasses
06:09:06 <bqv> Now we're cooking
06:09:46 <merijn> bqv: The first one takes an infinite number of arguments modulo unwrapping :p
06:10:20 <bqv> I know, its just less cool if you have to unwrap :D
06:10:47 <nshepperd2> well, with type classes you can make a polymorphic value which can become a function taking any given finite number of arguments
06:11:03 <dminuoso> % lift (,) (Just 1) (Just 2)
06:11:03 <yahb> dminuoso: Just (1,2)
06:11:07 <nshepperd2> which you may or may not consider to count as taking infinite arguments
06:11:08 <dminuoso> % lift (,,) (Just 1) (Just 2) (Just 3)
06:11:08 <yahb> dminuoso: Just (1,2,3)
06:11:11 <dminuoso> % lift (,,,) (Just 1) (Just 2) (Just 3) (Just 4)
06:11:12 <yahb> dminuoso: Just (1,2,3,4)
06:11:14 <dminuoso> It's magic. :)
06:12:31 <hekkaidekapus> xenon- meets Iceland_jack:
06:12:39 <hekkaidekapus> > let xs = [[1,2,3],[10,20,30],[100,200,300]]; rotate = drop <> take; go = ZipList . head in (,,) <$> go xs <*> go (rotate 1 xs) <*> go (rotate 2 xs)
06:12:41 <lambdabot>  ZipList {getZipList = [(1,10,100),(2,20,200),(3,30,300)]}
06:13:20 <dminuoso> hekkaidekapus: Okay you're golfing in an odd direction
06:13:26 <hekkaidekapus> heh
06:13:46 <nshepperd2> deliberately golfing off the course
06:13:50 <dminuoso> That's not quite the output asked for.
06:14:15 <hekkaidekapus> The morning was rough this side :)
06:14:44 <dminuoso> hekkaidekapus: We might have to revoke your golf greencard.
06:15:48 <hekkaidekapus> dminuoso: I already won <https://twitter.com/TheMasters/status/1326232433373704194>
06:16:14 <dminuoso> hekkaidekapus: But, you're onto something
06:16:16 <dminuoso> % traverse ZipList [[1,2,3],[10,20,30],[100,200,300]]
06:16:16 <yahb> dminuoso: ZipList {getZipList = [[1,10,100],[2,20,200],[3,30,300]]}
06:16:20 <dminuoso> % sequence $ traverse ZipList [[1,2,3],[10,20,30],[100,200,300]]
06:16:20 <yahb> dminuoso: [ZipList {getZipList = [1,2,3]},ZipList {getZipList = [1,2,30]},ZipList {getZipList = [1,2,300]},ZipList {getZipList = [1,20,3]},ZipList {getZipList = [1,20,30]},ZipList {getZipList = [1,20,300]},ZipList {getZipList = [1,200,3]},ZipList {getZipList = [1,200,30]},ZipList {getZipList = [1,200,300]},ZipList {getZipList = [10,2,3]},ZipList {getZipList = [10,2,30]},ZipList {getZipList = [10,2,300]},Zip
06:16:25 <dminuoso> Uhh, wait
06:16:31 <dminuoso> maybe this is easier with ala
06:17:03 <Iceland_jack> unf
06:17:06 <dminuoso> % sequence $ ZipList (ZipList <$> [[1,2,3],[10,20,30],[100,200,300]])
06:17:06 <yahb> dminuoso: ; <interactive>:70:1: error:; * Could not deduce (Monad ZipList) arising from a use of `sequence'; from the context: Num a bound by the inferred type of it :: Num a => ZipList (ZipList a) at <interactive>:70:1-67; * In the expression: sequence $ ZipList (ZipList <$> [[1, 2, 3], [10, 20, 30], [100, 200, 300]]); In an equation for `it': it = sequence $ ZipList (ZipList <$> [[1, 2, ...
06:17:07 <Iceland_jack> I'm spooked
06:17:18 <Iceland_jack> >Monad ZipList
06:17:20 <Iceland_jack> state of sin
06:17:23 <dminuoso> oh
06:17:28 <dminuoso> % sequenceA $ ZipList (ZipList <$> [[1,2,3],[10,20,30],[100,200,300]])
06:17:28 <yahb> dminuoso: ZipList {getZipList = [ZipList {getZipList = [1,10,100]},ZipList {getZipList = [2,20,200]},ZipList {getZipList = [3,30,300]}]}
06:17:42 <dminuoso> That looks good, now we just need to run sequenceA with ala. I dont know how to do that
06:18:10 <hekkaidekapus> Now, who’s golfing :P
06:18:58 <dminuoso> % ala ZipList traverse [[1,2], [10,20]]
06:18:59 <yahb> dminuoso: [[1,10],[2,20]]
06:19:05 <dminuoso> Getting close there
06:19:55 <dminuoso> hekkaidekapus: But thanks, I had never considered to traverse with ZipList
06:19:58 <dminuoso> That's quite a thought.
06:20:35 <dminuoso> Mmm, I guess `transpose = ala ZipList traverse` ?
06:29:44 <Iceland_jack> yeah
06:30:06 <Iceland_jack> tranpose = transposeOf traverse <-- doesn't lens have
06:33:43 <dminuoso> transposeOf l = getZipList #. l ZipList
06:33:46 <dminuoso> Yeah makes sense
06:36:22 * hackage cobot-io 0.1.3.12 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.12 (ozzzzz)
06:38:57 <bqv> :t (#.)
06:38:59 <lambdabot> error:
06:38:59 <lambdabot>     • Variable not in scope: #.
06:38:59 <lambdabot>     • Perhaps you meant one of these:
06:39:21 <dminuoso> bqv: its just coerce
06:39:25 <nshepperd> > transposeOf each ([1,2,3],[456])
06:39:27 <lambdabot>  [(1,456)]
06:39:30 <bqv> oh k
06:39:35 <nshepperd> oooh
06:40:20 <dminuoso> % transposeOf _2 ("foo", "bar")
06:40:20 <yahb> dminuoso: [("foo",'b'),("foo",'a'),("foo",'r')]
06:40:26 <dminuoso> Crazy
06:41:02 <hekkaidekapus> @hackage coercible-utils -- bqv
06:41:02 <lambdabot> https://hackage.haskell.org/package/coercible-utils -- bqv
06:51:53 * hackage pantry 0.5.1.4 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.5.1.4 (MichaelSnoyman)
06:56:11 <nshepperd> spooky
07:17:22 * hackage ki 0.1.0 - A lightweight, structured concurrency library  https://hackage.haskell.org/package/ki-0.1.0 (mitchellwrosen)
07:36:54 <bqv> polysemy plugin giving me GHC panics
07:37:07 <bqv> i don't lose much by turning it off, i guess
07:37:34 <merijn> polysemy seems way too complicated and brittle to use, tbh
07:37:51 <bqv> really? i rather like it
07:38:19 <bqv> i mean, it does basically make TypeApplications a requirement
07:38:27 <bqv> as well as like 5 other extensions, iirc
07:38:44 <bqv> but it does beat juggling monad stacks, and i never really liked MTL
07:38:46 <merijn> I don't like TypeApplications and think it's too brittle too :p
07:38:51 <bqv> ha
07:40:41 <bqv> although, i seem to have actually ended up with an impossible to solve type error though
07:40:48 <bqv> no wonder the plugin panicked
08:01:01 <maerwald> merijn: it isn't complicated, the API is nice... but if you get errors, then pray to god
08:01:35 <merijn> maerwald: By complicated I didn't necessarily mean "to use"
08:01:41 <maerwald> I found it surprisingly intuitive, compared to other stuff I tried (like freer)
08:01:42 <merijn> maerwald: But it's implementation
08:01:45 <maerwald> yeah
08:02:02 <merijn> I'm not convinced it justifies it's "weight"
08:02:25 <maerwald> freer took 4 months effort for ppl to figure out how to do some basic IO
08:02:28 <maerwald> xD
08:02:55 <maerwald> or was it longer: https://gitlab.com/queertypes/freer/-/issues/7
08:02:56 <merijn> I'm in the "just use IO" camp anyway
08:04:07 <maerwald> I tried mtl style, but when I look at the type signatures, I know as much as IO, which says "well, there might be some effects"
08:04:26 <dminuoso> "queertypes" :)
08:05:38 <dminuoso> Im curious, it has been my observation that the LGTB scene is very prominent in functional programming.
08:05:40 <dminuoso> Why is that?
08:05:49 <merijn> maerwald: https://twitter.com/k0001/status/1295846402648682496
08:06:06 <pjb> dminuoso: we're too successful, so they try to distract us.
08:06:14 <Taneb> dminuoso: I think it's "people who feel like outsiders but can't explain why growing up tend to gravitate towards niche interests"
08:06:22 <dminuoso> Are people in functional programming just more honest about themselves, as they are about their programs?
08:06:39 <dminuoso> Taneb: Mmm
08:06:43 <bqv> dminuoso: i imagine it's also partially just that tech is very lgbt
08:06:47 <pjb> nope it's a minority of psyops.
08:07:07 <pjb> Look the time we lose on those questions instead of on haskell!!!
08:07:31 <Taneb> pjb: clearly all the questions about Haskell have already been answered ;)
08:07:36 <dolio> The premise didn't really make sense to me when I read something about it. It was like, "someone said free monads are slow, but if you do a ton of work optimizing them they won't be." Which doesn't sound like an argument for designing everything around that. :)
08:08:23 <dminuoso> Taneb: So I'd find more LGTB folks generally in niche interests/fields/hobbies?
08:08:59 <pjb> It's just a psyop to eliminate the best from the gene pool.
08:08:59 <Taneb> dminuoso: I believe, with admittedly only anecodtal evidence, that's the case
08:09:13 <dolio> Like, that seems predicated on already being in the 'free monads are the best thing ever and should be used for everything' camp.
08:10:22 <dminuoso> Taneb: The question though, why would they gravitate towards niche interests?
08:10:53 * hackage clckwrks 0.26.3 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.26.3 (JeremyShaw)
08:10:54 <Taneb> dminuoso: because we don't tend to feel we fit in with mainstream stuff
08:11:26 <bqv> if you allow for transitivity, people with more autistic traits will always gravitate to niche interests, and people with autism are clinically significantly more likely to have an unusual relationship with sexuality/gender
08:11:44 <dminuoso> bqv: Can you cite any publications on that?
08:12:02 <bqv> not off the top of my head, but i can guarantee it won't be hard to find one
08:12:09 <bqv> it's well known
08:12:15 <dminuoso> How scientific
08:12:18 <dminuoso> "It's well known"
08:12:33 <bqv> by "it's well known" i mean i see people throwing new papers around about it all the time
08:12:42 <bqv> not that "it's something i saw on facebook"
08:12:43 <dminuoso> Fair enough, I just dont read those review papers
08:12:49 <p0a> Hello when I read tutorials/books there's typically many versions of a function presented (improvements) 
08:13:13 <p0a> How can I have multiple versions in my project? I typically set up a project where I test/learn the code I'm reading 
08:13:31 <p0a> Should I just have multiple files under src/ (stack projects)
08:13:43 <p0a> That works right?
08:14:52 * hackage phonetic-languages-constaints 0.2.0.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constaints-0.2.0.0 (OleksandrZhabenko)
08:15:16 <merijn> p0a: Well, you can also just have them in the same file, just named differently
08:15:31 <bqv> dminuoso: here's two from the UK national autism society site:
08:15:43 <bqv> https://pubmed.ncbi.nlm.nih.gov/30392630/
08:15:44 <dminuoso> Taneb: One additional thing that I kept thinking of, was whether it's also that functional programming generally attracts an audience of more educated, intelligent and open minded people.
08:15:46 <bqv> https://pubmed.ncbi.nlm.nih.gov/26753812/
08:15:58 <dminuoso> Such that they're more friendly and accepting
08:16:22 <dminuoso> This seems to hold true especially of Haskell, based on my observations in this and other communities, as well as various meetups
08:16:23 <merijn> dminuoso: Or, maybe it's selection bias from who shapr badgered into joining when he started #haskell :p
08:16:55 <bqv> yeah i do think you have a sampling problem
08:18:17 <Uniaika> I've seen a lot of LGBT and neuroatypical people in the areas of FP and nice hardware hacking
08:18:20 <Uniaika> *niche
08:18:21 <Uniaika> bleh
08:18:49 <maerwald> neuroatypical... :D
08:18:55 * maerwald pretends to be normal
08:19:27 <Uniaika> maerwald: what, you're not wearing a blue tie doing Java at IBM! How quaint!
08:19:43 <maerwald> well, my random observation was that ppl at the rust meetup in berlin were pretty... shy?
08:19:56 <maerwald> In haskell meetups I felt that less so
08:20:01 * p0a hates meetups
08:20:23 <maerwald> but then again... there were actual rustc devs at the meetup
08:20:38 <maerwald> *panic attack*
08:20:42 <p0a> lol
08:21:56 <Uniaika> Rust as well has attracted quite a diverse community 
08:22:01 <Uniaika> it's pretty nice
08:22:22 <maerwald> I'd guess edward would give even seasoned haskellers at a meetup a little bit of imposter syndrome feeling :p
08:22:44 <Uniaika> I met edward at ZuriHac 2019
08:22:51 <Uniaika> very impressive dude
08:23:05 <merijn> Uniaika: I think you mean very impressive robot
08:23:22 <maerwald> yeah, basically: take my job, because you can do it better :p
08:23:25 <bqv> sounds like he passes the turing test
08:23:31 <merijn> We all know edwardk is an android. That's how he manages to be so productive, he doesn't require sleep
08:24:13 <dminuoso> merijn: edwardk once wore a "fully functional and programmed in multiple techniques" t-shirt
08:24:20 <dminuoso> Think that's a hint?
08:24:24 <arianvp> is there no function in haskell to get the domain or fqdn of a host?
08:24:29 <arianvp> e.g. the output from  hostname -f ?
08:24:32 <arianvp> or hostname -d ?
08:24:40 <maerwald> did you check network-bsd?
08:25:14 <bqv> @hoogle gethostbyname
08:25:14 <Uniaika> p. sure I used hostname resolution in Haskell some years ago
08:25:14 <lambdabot> Network.BSD getHostByName :: HostName -> IO HostEntry
08:25:46 <merijn> Is there even a sensible API for getting fqdn?
08:25:53 <merijn> bqv: That seems like the opposite
08:26:08 <merijn> C has gethostname(), but I'm not sure if that's FQDN
08:26:22 * bqv shrug
08:26:35 <maerwald> close enough
08:26:53 <merijn> Uniaika: hostname resolution is not the same as "what's the FQDN of this host?"
08:27:19 <merijn> arianvp: I recommend modifying your desire so that getHostName is sufficient :p
08:27:32 <arianvp> I think it's the uname syscall
08:28:08 <Uniaika> erf, my bad
08:28:17 <merijn> arianvp: uname should be in the unix package
08:28:40 <p0a> https://pubs.opengroup.org/onlinepubs/009695399/functions/getnameinfo.html
08:29:15 <arianvp> ah no I think it parses /etc/hosts to get the domain part
08:29:27 <arianvp> looking at the strace of "hostname --fqdn"
08:29:32 <bqv> @hoogle getnameinfo
08:29:32 <lambdabot> Network.Socket getNameInfo :: [NameInfoFlag] -> Bool -> Bool -> SockAddr -> IO (Maybe HostName, Maybe ServiceName)
08:29:34 <bqv> is a thing
08:29:38 <arianvp> it first calls uname to get the hostname; and then parses /etc/hosts
08:30:24 <maerwald> https://hackage.haskell.org/package/network-bsd-2.8.1.0/docs/Network-BSD.html#v:getHostEntries
08:46:17 <p0a> does anyone else use haskell-mode on emacs? How do you make the indentation behave?
08:47:25 <maerwald> you don't
08:47:29 <maerwald> never works correctly
08:47:32 <p0a> This is how it looks: https://paste.tomsmeding.com/gP3DZmu2 I wanted to align <$> with <*>
08:47:44 <p0a> lol alright. What's the solution? Don't use emacs? :P 
08:49:51 <tomsmeding> automatic indentation for haskell is a complex topic anyhow
08:50:16 <tomsmeding> writing a parser being difficult and all, but also people not agreeing on how stuff is to be formatted
08:50:20 <maerwald> yeah, on vim it's probably worse and would sometimes keep re-indenting, even if you revert it
08:50:23 <maerwald> weird stuf
08:52:14 <dsal> p0a: It'll do that if you put the (,,) on the line above.
08:52:26 <dsal> One of the problems is that everyone else's code is uglier than mine would be if the tools just did what I wanted.
08:53:15 <p0a> dsal: okay, thank you. I wanted to make sure, I guess ad-hoc solutions is what I have to employ 
08:53:39 <dsal> My haskell-mode and stylish-haskell setups don't disagree too much.
08:58:18 <boxscape> would you say there's a relationship between purely functional programming and not using null references?
08:58:33 <hc> I think so
08:58:52 <boxscape> I guess trying to do something with a null reference that you can't do usually results in side effects?
08:59:26 <hc> you don't have/use regularily references in purely functional programming languages ;)
08:59:39 <hc> at least not directly; it's all hidden away by smart compilers
08:59:41 <maerwald> hc: why not?
08:59:48 <hc> maerwald: less need
09:00:17 <hc> maerwald: due to referential transparency mostly, i think
09:00:23 <maerwald> boxscape: only practically. I don't think it matters theoretically?
09:00:59 <boxscape> Just thinking about whether I can find a good segway to talk about avoiding null pointers in a talk about purely functional programming :)
09:01:12 <boxscape> er
09:01:14 <boxscape> segue
09:01:37 <maerwald> that is, it isn't obvious to me why you can't have a purely functional programming language with null pointers
09:02:21 <p0a> scheme right?
09:02:30 <hc> maerwald: because what's the use of a null pointer when you don't have pointers/references in the first place?
09:02:31 <boxscape> I guess having "null pointers" doesn't necessarily mean regular variables/constant can have a value of null, which is how I was thinking about it
09:02:48 <maerwald> hc: I'm not talking about the use, but the definition
09:02:53 <maerwald> I don't think there's a hard correlation
09:03:02 <hc> agree, it's a soft correlation ;)
09:04:02 <hc> maerwald: do pointers/references make sense in a purely functional language?
09:04:04 <Chousuke> null pointers aren't really the problem, it's when any pointer type can have null values that you run into trouble
09:04:18 <timCF> Hello guys! I know it sounds stupid, but I'll ask anyway. For whatever reason my linker is extremely slow, when stack do linking phase - I literally can have time for a cup of tea or two. Maybe I'm missing something. How to make it fast?
09:04:47 <boxscape> Chousuke so you're saying the type of the pointer should indicate whether it can point to null?
09:05:17 <bqv> p0a: i think you can do it by modifying the c-indent family of variables
09:05:32 <bqv> but i just avoid asking emacs to indent for me
09:05:39 <bqv> because it always does it 'wrong'
09:05:42 <Chousuke> boxscape: essentially, yes. Or in other words, just support Optional/Maybe
09:05:48 <boxscape> yeah, that makes sense
09:05:51 <hc> maerwald: i'm not saying by any means i'm right about this... i merely want to understand it :)
09:05:58 <p0a> bqv: what do you do instead?
09:06:05 <bqv> use my spacebar? :p
09:06:15 <p0a> hc: yes they do
09:06:21 <p0a> hc: You can have tape and ... pointers on it 
09:06:28 <hc> timCF: i'm regularily waiting for 5 minutes for the rust linker to finish in release/optimizing mode
09:06:41 <maerwald> hc: purely function is defined as: call-by-name, call-by-need and call-by-value are weakly equivalent in that language (modulo bottom)
09:06:54 <maerwald> I don't see why you can't meet that criteria with null pointers
09:07:14 <hc> maerwald: what use would a null pointer be if you can never assign another value to the variable that holds it?
09:07:21 <maerwald> because it's bottom if you deref it
09:07:31 <hc> hmm, so an error case?
09:08:05 <bqv> hc: i mean i'm currently using a pointerlike thing using the Store comonad, and as it happens my keys are 'Ptr a' so i'm abusing nullptr to be a zero value rather than Maybe-ing it
09:08:07 <p0a> hc: what use are pointers if you can't manipulate the pointees?
09:08:16 <maerwald> what matters is that the expressions are equivalent under different eval strategies if there is NO bottom
09:08:28 <int-e> p0a: they allow sharing
09:08:46 <hc> p0a: precisely. they aren't of any use as far as i can see it
09:08:50 <p0a> int-e: Not sure what you mean :) but I was trying to say that hc's point is not a good point
09:09:13 <int-e> pah, context
09:09:26 <bqv> i prefer lualatex
09:09:29 <hc> okay, different question: *how* do i make a pointer of something in haskell?
09:09:32 <p0a> hc: Haskell is not "without side effects"
09:09:42 <timCF> hc, do you think it's normal for dev environment, without O2 flag, which is supposed to be fast I guess..
09:09:44 <hc> p0a: i know about iorefs 
09:10:04 <maerwald> p0a: IO has no side effects =)
09:10:25 <maerwald> the only side effect in haskell is unsafePerformIO (yes, that breaks the language)
09:10:26 <p0a> maerwald: yeah it's fair to say that. C has no side effects either 
09:10:38 <maerwald> p0a: it does
09:10:42 <p0a> Ah I see, alright. I misunderstood you 
09:10:57 <int-e> Oh, I think I see... Well, most haskell implementations pass values by reference which are pointers. There's hardly a point in exposing this implementation detail to the user.
09:11:21 <maerwald> but they could
09:11:29 <int-e> Unless you bring actual mutation to the table, for which you'll need IO or ST.
09:12:09 <boxscape> maerwald non-terminating programs don't count as side-effecting either?
09:12:35 <maerwald> boxscape: dunno, that term is a bit more fuzzy
09:12:53 <int-e> boxscape: the usual formal semantics will treat that case as bottom.
09:13:01 <bqv> IO at least has the side effect of p***ing me off a lot
09:13:07 <int-e> the structure of bottoms... is rarely captured formally.
09:13:07 <boxscape> oh, right, I guess that makes sense
09:14:19 <hekkaidekapus> boxscape: If your talk is not geared to any particular language, you can mention ATS about sound pointer manipulation.
09:14:20 <hc> bqv: oh i thought that was io's main purpose? ;p
09:14:34 <hc> timCF: nah, that should be much faster
09:14:55 <bqv> hdh
09:14:57 <bqv> heh*
09:15:21 <int-e> hope dat helps?
09:15:22 <int-e> :)
09:15:38 <boxscape> hekkaidekapus it is geared towards, of all things, Java :)
09:15:44 <hekkaidekapus> For NULL, you handle it as a Maybe like Chousuke said, specifically using a dataview.
09:15:48 <maerwald> boxscape: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.106.364&rep=rep1&type=pdf
09:15:51 <p0a> If I do import Data.Text (Text) followed by import qualified Data.Text as T, does it make sense?
09:16:02 <maerwald> it doesn't properly define side effect either
09:16:07 <bqv> p0a: yes
09:16:12 <p0a> thank you bq
09:16:22 <boxscape> maerwald huh, interesting
09:17:09 <maerwald> functional is clear (based on lambda calculus), purely functional as well (eval strategy equivalence), but side effect is somewhere off
09:18:41 <maerwald> If you take a radical stance you could maybe say haskell is purely functional with side effects
09:19:10 <hekkaidekapus> boxscape: Ok, forget ATS then! The dataview stuff is neat, a Maybe at the pointer level; it might be for a follow-up talk ;)
09:19:24 <boxscape> it certainly sounds interesting
09:38:23 * hackage wai-rate-limit 0.1.0.0 - Rate limiting as WAI middleware  https://hackage.haskell.org/package/wai-rate-limit-0.1.0.0 (mbg)
09:38:27 <dminuoso> int-e: heh. "most haskell implementations". how many are still alive and in actual use?
09:38:59 <int-e> dminuoso: but those are two different questions
09:39:09 * int-e wonders whether ndm still uses winhugs, for example
09:39:18 <maerwald> do eta and frege count?
09:39:22 * hackage wai-rate-limit-redis 0.1.0.0 - Redis backend for rate limiting as WAI middleware  https://hackage.haskell.org/package/wai-rate-limit-redis-0.1.0.0 (mbg)
09:39:30 <dminuoso> int-e: wait, ndm used winhugs?
09:39:56 <dminuoso> maerwald: Id say yes.
09:40:29 <int-e> dminuoso: The ones I'm aware of are ghc and ghcjs, but I'm not really keeping track anymore. hugs, nhc are not maintained, jhc is probably unmaintained as well...
09:40:55 <int-e> dminuoso: ndm liked it because it reloaded code much faster than ghci
09:41:05 <bqv> yhc never even got off the ground, huh...
09:41:11 <maerwald> also, pH counts as well
09:41:14 <dminuoso> I mean frege itself seems like a pure haskell implementation
09:41:18 <dminuoso> eta is a dialect tho
09:41:27 <dminuoso> Or are there relevant differences between frege and haskell?
09:42:05 <maerwald> https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.106.364&rep=rep1&type=pdf
09:42:20 <maerwald> it's lenient haskell
09:42:37 <int-e> dminuoso: I guess I was allowing for crazy possibilities like somebody writing a Haskell implementation targeting pure lambda calculus or things like sed.
09:43:16 <int-e> dminuoso: actually ghcjs is an interesting case here as well
09:43:57 <dminuoso> int-e: I dont even understand how ghcjs does memory management.
09:44:09 <dminuoso> afaik js does not provide you with raw memory access
09:44:23 <dminuoso> Do you have two "nested" garbage collectors?
09:44:28 <int-e> Right, I just realized I don't know that either... does it use arrays for a simulated heap or does it use javscript objects?
09:46:29 <int-e> Well, let me see if I can build that thing and find out...
09:46:54 <bqv> nested garbage collectors
09:46:56 <dminuoso> int-e: https://www.haskell.org/haskell-symposium/2013/ghcjs.pdf
09:47:01 <bqv> that sounds like a special kind of hell
09:47:16 <dminuoso> According to that (possibly dated) paper, plain JS objects
09:47:41 <int-e> Right, "representing every Haskell heap object as a plain JavaScript object"
09:47:47 <dminuoso> So that would suggest, there's only the JS garbage collector
09:47:51 <bqv> makes the most sense
09:47:59 <bqv> besides, purescript manages fine
09:48:08 <dminuoso> PureScript is strict.
09:48:14 <bqv> entirely?
09:48:15 <dminuoso> That changes things
09:48:16 <dminuoso> Yes
09:48:34 <bqv> i thought there was some laziness somewhere... meh
10:02:07 <bqv> good lord it compiled
10:02:11 <bqv> for the first time in a week
10:07:56 <p0a> what does {..} mean?
10:08:05 <p0a> I see stuff like `return Authority {..}' 
10:08:13 <dminuoso> p0a: RecordWildCards
10:08:24 <dminuoso> It's the sane and useful part of that extension.
10:08:31 <p0a> alright 
10:08:53 <dminuoso> (The not-so-useful part is when you use {..} for pattern matching, as in `f (Foo{..}) = ...`
10:09:21 <p0a> I am not sure about that, I understand what {..} does now though 
10:09:39 <monochrom> Why is that not so useful?
10:10:25 <dminuoso> It can create subtle to find bugs
10:10:43 <dminuoso> It invisibly introduced identifiers that can shadow other things.
10:11:08 <dminuoso> NamedFieldPuns is a safer, albeit slightly more verbose, alternative
10:11:38 <koz_> I agree on the 'subtle to find bugs' definitely. I've been bitten by this a lot.
10:13:33 <dminuoso> RecordWildCards on expression otoh is quite handy, especially for larger records. In the setting of parsers, `Foo <$> parseA <*> parseB <*> parseC` can easily lead to mistakes, especially if there's a lot of fields
10:13:50 <dminuoso> (You could accidentally switch parseB and parseC for example, without noticing if the types line up)
10:14:07 <dminuoso> It also gets increasingly difficult identifying which fragment corresponds to what field
10:14:34 <monochrom> That one I know and agree.
10:14:51 <dminuoso> if you hoever used (possibly Applicative-) do expressions `do { fA <- parseA; fB <- parseB; fC <- fieldC; pure Foo{..} }` it makes it more explicit without sacrificing too much extra typing
10:16:11 <dminuoso> Amusingly, I sometimes accidentally write `Foo{..}` in a pattern instead of `Foo{}`. Since I often have RecordWildCards enabled for the above mentioned use case, that has hidden a nasty bug before.
10:16:36 <dminuoso> muscle memory can be an annoying thing :)
10:17:16 <monochrom> I have been writing a fair amount of Scheme lately.
10:17:36 <dminuoso> Curious, what's the reason?
10:17:36 <monochrom> Then I went to write some for loops in C. I started "(for i=0;"
10:17:47 <monochrom> "wait, that doesn't look right"
10:18:02 <dminuoso> heh
10:18:22 <p0a> why do you write Scheme if you know Haskell?
10:18:47 <monochrom> I am a substitute teacher for a course that uses Scheme.
10:18:49 * dminuoso bets is a Scheme course
10:18:54 * dminuoso was right
10:18:56 <p0a> Alright lol
10:19:15 <monochrom> Don't worry, there will be Haskell.
10:19:19 <p0a> hehe
10:19:23 <monochrom> THERE WILL BE BLOOD
10:19:32 <dminuoso> monochrom: So out of curiosity. Do you have previous Scheme experience?
10:19:34 <p0a> make a u-turn on the last week before finals
10:19:39 <monochrom> yes
10:20:10 <dminuoso> From substituting Scheme courses? ;p
10:20:43 <monochrom> Not just that. A few years ago, my course had both Scheme and Haskell too.
10:21:04 <dminuoso> Do you get to decide what's in your course, or how does that even work?
10:21:18 <dminuoso> Is there a board that decides on what's on course?
10:21:19 <monochrom> But I'm too annoyed at eager evaluation and uncurrying, so I dropped it.
10:21:55 <p0a> When I substitute taught
10:22:04 <monochrom> For better or worse, there is no board for this, I have liberty to add or drop topics at a whim.
10:22:05 <p0a> I realized that nobody is checking on me, so yeah, you can teach whatever you want 
10:22:28 <dminuoso> So the students are truly at your merci
10:22:34 <dminuoso> Or.. mercy.
10:22:53 <dminuoso> Guess that
10:23:00 <dminuoso> Guess that's how Darth Vader must feel.
10:23:14 <monochrom> Although, if I am the intended instructor right on the first day, I have no guilt choosing my favourite topics; but if I'm a substitute teacher stepping in in the middle, I've got to honour the original intention of the original teacher.
10:23:21 <dminuoso> Except, and that's as far as I can tell, he doesn't do functional programming.
10:23:36 <dminuoso> That makes sense
10:23:57 <p0a> I ironically had more freedom instructing as a TA 
10:24:25 <dminuoso> monochrom: So that begs the question, if you have complete autonomy, what exactly is in your job description?
10:24:45 <dminuoso> "Teaching what you like, when you like it to whomever you like"?
10:24:48 <p0a> when you're a teacher you have to follow the syllabus (especially if the course is split among many teachers)
10:25:04 <dminuoso> Or are you at least expected to deliver something compsci related?
10:25:04 <p0a> Also student expectation is that you _will_ go on board and copy notes from the book
10:25:10 <p0a> It can't be otherwise
10:25:27 <monochrom> It goes like "develop course material, deliver lectures, admin duties"
10:26:11 <dminuoso> So you could teach about the various ways of cooking fish and get away with it?
10:26:18 <p0a> Not without tenure dminuoso 
10:26:19 <dminuoso> As long as you produce course material for it?
10:26:39 <p0a> The trick is that there's nobody that can really evaluate you dminuoso you're literally the top head 
10:27:12 <p0a> Those above you have a very vague idea on the subject
10:27:41 <tomsmeding> on... normal schools, I believe, there's this thing variously called "learning outcomes" that are stipulated beforehand and are to be followed by the teacher
10:28:00 <p0a> yeah but those metrics are largely irrelevant 
10:28:03 <tomsmeding> though maybe that's a fancy coming from places where there are actually multiple people teaching the same course
10:28:11 <dminuoso> You mean the curriculum?
10:28:27 <p0a> I think he means the tests that students take
10:28:29 <tomsmeding> I guess, though people also use that word for something on a higher level
10:28:32 <tomsmeding> no!
10:28:35 <tomsmeding> I do not mean the tests
10:28:52 <tomsmeding> the test is derived from the learning outcomes
10:28:53 <koz_> tomsmeding: In my entire experience as a TA in a place with 'learning outcomes', over damn near a decade, I met literally _one_ person who actually followed them.
10:28:57 <p0a> The curicculum is just cargo cult nonsense
10:28:58 <dminuoso> tomsmeding: Well, my girlfriend at least has to follow the federal curriculum
10:29:03 <monochrom> Strangely enough I think they don't have very strong and clear language about course content, maybe only weak language; instead, it's the hiring qualification that clearly insists "must have experience in this course".
10:29:04 <dminuoso> So her syllabus has to fit inside that
10:29:24 <dminuoso> monochrom: I see, you should become a hobby cook then.
10:29:28 <dminuoso> :)
10:29:28 <koz_> (or more precisely, designed anything in their classes around them)
10:29:42 <tomsmeding> (in particular, I know two teachers well on two very different schools, and there the situation is, at least ostensibly, as I just described)
10:29:59 <dminuoso> But this likely varies from state to state across countries even
10:30:23 <p0a> My experience teaching is that we placed large emphasis on testing and teaching for the test
10:30:27 <dminuoso> At least here, education is a federal responsibility, so they decide on the core topics of the curriculum
10:30:34 <dminuoso> the school then outlines the exact curriculum
10:30:48 <dminuoso> and the teacher then has, essentially, unchecked and unlimited freedom to plan his or her syllabus
10:30:56 <dminuoso> with the assumption they follow the schools curriculum
10:31:11 <p0a> with the contraint of time, the teacher has very little freedom
10:31:17 <Rembane> So the trick is to not follow the curriculum and hope that noone notices? :)
10:31:28 <tomsmeding> seems so
10:31:30 <p0a> Rembane: the students will notice and complain :P
10:31:31 <tomsmeding> :)
10:32:32 <Rembane> p0a: Ach! Those pesky students! :D
10:32:44 <p0a> It's all off-topic I guess but I have very strong opinions on this and could talk about it forever
10:33:18 <tomsmeding> perhaps indeed off-topic :p
10:33:21 <p0a> I might be making the mistake of judging the entire situation from my own experience...
10:33:37 <p0a> right, I'll go back to the megaparsec tutorial :P 
10:37:05 <dminuoso> Rembane: she could, probably
10:37:16 <cohn> p0a: do you have a link to that tutorial?
10:37:38 <p0a> cohn: sure 
10:37:42 <dminuoso> As long as she doesn't do this in a class that graduates, it will largely go unnoticed. 
10:38:04 <p0a> cohn: https://markkarpov.com/tutorial/megaparsec.html
10:38:34 <Rembane> :D
10:39:38 <p0a> cohn: I'm afraid it might be too simple for you :) I am learning the very basics 
10:40:06 <cohn> i've never used it so I'd imagine it'll be just right.  ; )
10:40:09 <cohn> p0a: thanks!
10:45:11 <p0a> cohn: you're welcome 
10:45:22 * hackage polysemy-vinyl 0.1.0.0 - Functions for mapping vinyl records in polysemy.  https://hackage.haskell.org/package/polysemy-vinyl-0.1.0.0 (locallycompact)
10:53:46 <gecko_> clear
11:04:52 * hackage phonetic-languages-constaints 0.2.1.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constaints-0.2.1.0 (OleksandrZhabenko)
11:14:23 * hackage approx 0.1.0.0 - Easy-to-use reasonable way of emulating approx in Haskell.  https://hackage.haskell.org/package/approx-0.1.0.0 (kishaloy)
11:34:53 * hackage strict-tuple 0.1.4 - Strict tuples  https://hackage.haskell.org/package/strict-tuple-0.1.4 (mitchellwrosen)
12:02:04 <Uniaika> maerwald: new hls release!
12:03:46 <maerwald> I have RSI, provide a PR
12:04:30 <maerwald> also trying to fix kinesis firmware
12:05:43 <koz_> maerwald: Why the Kinesis firmware fix?
12:07:16 <maerwald> just trying to make tap and hold work lol, probably need to order that usb to usb converter from that dude in japan
12:08:47 <maerwald> https://www.1upkeyboards.com/shop/controllers/usb-to-usb-converter/ 
12:09:15 <maerwald> coding makes it worse, because of modifier keys youre pressing all the time
12:27:59 <frdg> in the expression `\x y -> foo` are `x` and `y` the free variables?
12:30:28 <koz_> frdg: x and y are bound in the body of that lambda.
12:32:46 <frdg> oh so `foo` is the free variable?
12:33:15 <dminuoso> Yes.
12:33:40 <dminuoso> frdg: The term `free` is used as opposed to `bound`
12:33:45 <monochrom> Is foo a variable? Or is foo just there to stand for an arbitrary expression?
12:33:46 <frdg> because the free variable in a lambda expression is one that comes from outside the lambdas scope
12:33:58 <dminuoso> frdg: no. 
12:34:05 <dminuoso> it just means "not bound"
12:34:12 <dminuoso> The reason is not important
12:34:47 <frdg> ok I see. When this lambda is applied to two variable those variables become bound to x and y.
12:36:24 <dminuoso> frdg: no, it's rather.. when you take the expression `\x y -> x y z` then x and y are bound (by the binders to the left of the arrow), but z is not
12:37:31 <dminuoso> So in lambda calculus its *abstraction* that binds, not application.
12:37:43 <dminuoso> i.e. (λx.M) binds x in M
12:38:00 <frdg> ok. I am having trouble coming up with a lambda that has a free variable and makes sense. 
12:38:41 <dminuoso> frdg: It's common to call `λx` or `λx.` as a/the binder
12:39:21 <dminuoso> (so abstraction binds, application substitutes bound variables)
12:40:28 <frdg> I think I understand bound variables now but still not free. in `\x y -> add x y` is `add` a free variable? 
12:41:00 <frdg> add isn't much of a variable though
12:41:03 <dminuoso> frdg: see monochrom's question
12:41:09 <dminuoso> If `add` is a variable, then yes.
12:41:10 <monochrom> If you understand "bound", then simply use "free = not bound".
12:41:43 <monochrom> Buy one get one free. Or rather, buy one bound, get one free.
12:42:52 <frdg> ok. Just for final clarification, say add is another lambda. Add would be a free variable correct?
12:42:56 <dminuoso> frdg: Just take this phrasing at face value: "In a lambda abstraction (λx.E), x is _said_ to be bound inside E. Phrased differently, inside E all occurences of x are said to be bound"
12:43:10 <dminuoso> The binding has no intrinsic meaning than that statement
12:43:17 <dminuoso> Its use comes from how we define substition
12:43:33 <dminuoso> or rather, in both alpha and eta conversion
12:43:55 <dminuoso> alpha conversion is the act of renaming *bound* variables
12:44:09 <dminuoso> eta reduction is the act of substituting *bound* variables with another expression
12:44:47 <dminuoso> concretely
12:45:47 <dminuoso> (λx.E[x]) -α-> (λy.E[y]) is the process of replacing the (bound) variables x in E to y, such that in the resulting expression y is bound in E (by the surrounding abstraction)
12:47:22 <frdg> ok I understand well enough. This is helpful.
12:47:41 <dminuoso> Oh, and above that should have read `beta reduction` not `eta` reduction. my keyboard is a bit flakey
12:48:25 <dminuoso> (well to be fair, there's further uses of these terms. like we call a lambda expression without free variables a combinator
12:48:42 <dminuoso> so `\x y -> add x y` is not a combinator because it has a free variable inside
12:48:52 <bqv> though eta reduction is a thing
12:50:39 <frdg> I cant think of why a combinator could be useful. To me a combinator would be either identity or function application.
12:51:41 <tomsmeding> frdg: consider: \f -> (\x -> f x) 1
12:51:57 <tomsmeding> in that inner lambda, \x -> f x, 'f' is free and 'x' is bound
12:52:20 <dminuoso> frdg: it's just a name for it.
12:52:31 <tomsmeding> if you leave out the surrounding stuff and just look at the following in isolation: \n -> add n
12:52:35 <dminuoso> frdg: when studying systems, sometimes certain things have properties.
12:52:38 <tomsmeding> then 'add' is free and 'n' is bound ;)
12:52:43 <dminuoso> and we tend to name these certain things
12:53:37 <frdg> tomsmeding: these were nice examples. It is clear to me now.
12:54:44 <dminuoso> frdg: As a teaser, GHC has the notion of supercombinators which is related:
12:54:47 <dminuoso> https://wiki.haskell.org/Super_combinator
12:55:10 <frdg> ill read this
12:55:24 <dminuoso> (The impact of this is largely related to performance/optimization topics in GHC)
12:56:45 <dminuoso> frdg: If we ignore bits and pieces, we could actually make one first realization: we can always float a combinator out right until the top level in haskell.
12:56:57 <dminuoso> But how would we even express what expression we can float out?
12:57:10 <dminuoso> Well, it's easy. If the expression is a combinator, then we can float it out as it
12:57:12 <dminuoso> *as is
12:57:25 <dminuoso> (This you probably do manually regularly in Haskell)
12:58:04 <frdg> by float it out you mean un-nest it?
12:58:40 <dminuoso> I mean it in the sense of let-floating
12:58:52 <dminuoso> https://wiki.haskell.org/Lifting_pattern
12:59:27 <frdg> ohh the opposite of lift
12:59:41 <dminuoso> no, this is also called "lifting"
12:59:44 <frdg> no. lift
12:59:46 <dminuoso> (a terribly overused word)
13:00:38 <riddle00> .
13:00:43 <koz_> Haskell is the strongest proglang.
13:00:44 <dminuoso> So the term "combinator" just lets us have a clear terminology. if you were to write in GHC, and wondering "when can I float an expression to the top and give it a name", I'd say "you can do this if it is a combinator"
13:00:46 <koz_> All we do is lift.
13:01:09 <dminuoso> Or equivalently, if you identify a particular expression to be a combinator, you know you can float it out all the way to the top (or half the way) and give it a name.
13:01:11 <dminuoso> And it's fine
13:01:31 <frdg> now I really understand why we could float a combinator.  Like tomsmeding's example `consider: \f -> (\x -> f x) 1`. we could not float the inner lambda because it relies on f.
13:02:12 <frdg> but we could float f itself
13:02:28 * tomsmeding . o O ( "f itself"? )
13:05:06 <dminuoso> We tend to do this sort of reasoning in our heads when we refactor code, but compilers dont have heads, they have to be implemented with algorithms. So they need to know what mechanical transformations they are allowed to do and what not
13:12:22 * hackage tasty-hspec 1.1.6 - Hspec support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-hspec-1.1.6 (mitchellwrosen)
13:41:51 --- mode: card.freenode.net set +o ChanServ
13:41:51 --- mode: card.freenode.net set +o Sigyn
13:55:27 --- mode: card.freenode.net set +o Sigyn
14:47:57 <bqv> type Optic p q i j k l s t a b = p i j a b -> q k l s t
14:48:00 <bqv> Oh my.
14:50:26 <sm[m]> hey all. When I see "modules" discussed, as in https://www.stephendiehl.com/posts/exotic01.html, I always have a hard time understanding their essence. I know how they differ concretely from say a function, but what's the essential difference ?
14:51:15 <dminuoso> sm[m]: It's a function returning a module.
14:52:06 <sm[m]> "The big idea of modules is to break code up into reusable components called modules.". That definition also works for functions, classes, files, packages
14:52:43 <dminuoso> sm[m]: Well the novelty begins when you think of a module being parametrized by a signature, or even another module.
14:53:05 <sm[m]> dmininuoso: functions also can do that
14:53:12 <dminuoso> No they can not
14:53:28 <dminuoso> By module I mean the actual module itself.
14:54:15 <dminuoso> Sorry, I conflated a few things when I mentioned signatures above
14:54:36 <dminuoso> Am I right in assuming you want to clarify what ML functors are about?
14:54:45 <sm[m]> not at all :)
14:55:04 <Axman6> bqv: you could abstract out that -> too
14:55:44 <dminuoso> Axman6: can you?
14:55:53 <dminuoso> or, does that make any sense?
14:56:14 <bqv> Optic p q i j k l s t a b = y (p i j a b) (q k l s t)
14:56:19 <sm[m]> I'd like to understand whether there is something to the abstract idea of "module" that is different from say functions, classes, files, or anything else that is a way of breaking software into smaller pieces
14:56:21 <Axman6> type OOptic f p q i j k l s t a b = f (p i j a b) (q k l s t)
14:56:36 <Axman6> dminuoso: probably not :)
14:56:59 <bqv> I'm glad I've never done anything wacky enough to require such an alphabet soup type
14:57:00 <dminuoso> sm[m]: modules contain things not expressible within the language itself
14:57:03 <dminuoso> sm[m]: say a type
14:57:21 <bqv> (10 type parameters!)
14:57:33 <dminuoso> unless you meddle with singletons or in a dependently typed language, you can't trivially parametrize some code over a type
14:57:52 <sm[m]> dminuoso: I see that's a distinction in haskell, where a function can't define its own types, but not in other languages
14:58:14 * sm[m] imagines classes defined in a function
14:59:00 <bqv> (Wait, that's illegal)
14:59:33 <dminuoso> sm[m]: well the point is to turn this namespace that identifiers and types occupy into first-class values, but in a third universe.
14:59:55 <dminuoso> that's not just limited to haskell
15:00:12 <bqv> sm[m]: I always found it deeply upsetting that its possible to defun inside another function in lisps
15:00:16 <dminuoso> parametrizing a module over some implementation is, often, not sensibly
15:00:22 <bqv> That reminds me of that
15:01:12 <bqv> Also python, I guess, but that's what you get with yolotyping
15:01:13 <dminuoso> But if we consider a module as a wholesale bundle containing everything there is about an implementation - namely functions *and* types, we can use that
15:03:18 <sm[m]> so a module is a bag of types, values, and operations on them ?
15:03:22 <dminuoso> say we have both modules M and N defining a type t to be either String or Text, along with functions `f and h` producing and consuming that type t. If we parametrize some third module over a module that exposes t, f and h, we have a sort of modularity you couldn't have achieved before
15:03:51 <dminuoso> sm[m]: Id consider operations as just values.
15:04:02 <dminuoso> there's also other noise in haskell like typeclasses, instance, tyfams, etc
15:04:09 <dminuoso> But yes.
15:04:17 <dminuoso> Fundamentally it's a bag of types and values
15:04:25 <sm[m]> yes, I'm trying to think abstractly, not about haskell specifically
15:05:19 <dminuoso> sm[m]: Perhaps it could be useful to think of a module as a bag of *all* the things you can get from it through an import.
15:05:36 <dminuoso> That is described a bit less suggestive
15:05:44 * sm[m] thinks more about the difference between modules and functions. A language could make those the same perhaps
15:05:51 <dminuoso> (So it's a bag/list of "exported entities")
15:06:10 * sm[m] thinks about modules and objects (eg in smalltalk)
15:06:15 <dminuoso> If the entities is *just* values, like say in Python or JavaScript, it becomes just a boring dictionary
15:06:22 <bqv> Are we going down the reflection route
15:06:25 <dminuoso> And then the notion of module is really lacking and not interesting
15:06:54 * sm[m] thinks about modules vs libraries
15:06:55 <dminuoso> nix follows that route very heavily, where you just import more nix expressions
15:07:03 <bqv> Not sure whether to make another lisp joke or switch to ruby
15:07:10 <dminuoso> So you might be interested into looking how module nix code is often structured
15:07:17 <dminuoso> as a counter example
15:07:28 <monochrom> Yes, objects can be multiple-instance modules. Especially when your module has an internal mutable state.
15:08:12 <dminuoso> sm[m]: Oh and regarding libraries, this all depends on how you define things. But generally Id say a library is a bunch of modules. So it's a collection of exported things. :p
15:08:23 <monochrom> DNS functions on unixes used to be a module. Now they have to make them an object for re-entrancy and concurrency.
15:08:37 <dminuoso> But, it could be conceivable to turn libraries into first class values too
15:08:49 <dminuoso> And then have libraries parametrized by modules, libraries parametrized by other libraries..
15:09:52 <dminuoso> (strictly speaking, libraries *are* often parametrized by build flags or similar things)
15:11:02 <sm[m]> we seem to have a number of different things for making software modular, and they're not all called module. And the meaning of "module" seems to drift a bit
15:12:33 <sm[m]> in ocaml, "module" is a well-defined and important concept. In ghc haskell, it's well-defined but simpler and in practice a synonym for "file". In other languages I think it has some other meanings
15:13:22 <dminuoso> modules in Haskell are more than files though
15:14:00 <dminuoso> "A module defines a collection of values, datatypes, type synonyms, classes, etc. (see Chapter 4), in an environment created by a set of imports (resources brought into scope from other modules). It exports some of these resources, making them available to other modules. We use the term entity to refer to a value, type, or class defined in, imported into, or perhaps exported from a module. "
15:14:05 <sm[m]> I believe you but is that visible in practice ?
15:14:28 <dminuoso> Of course it is. Do you not export/import things across modules?
15:14:54 <bqv> Ghc limits modules to 1 per file
15:14:59 <bqv> Its not in the spec
15:15:12 <sm[m]> yes, and conceptually it's as if exporting/importing files. Same thing in practice
15:15:13 <sm[m]> ie in ghc haskell, module and files are one to one
15:15:14 <dminuoso> Indeed, in fact the Haskell2010 report doesn't even have a notion of "files" anywhere
15:15:19 <dminuoso> That's an implementation detail
15:15:34 <sm[m]> I thought so, that's why I'm saying ghc haskell
15:15:39 <sm[m]> I remember seeing multiple, perhaps nested modules defined in a single file somewhere
15:16:13 <sm[m]> perhaps that was ocaml
15:16:13 <dminuoso> There are some GHC proposals in that area
15:16:28 <bqv> Interesting how ghci just ignores an IO (IO a)
15:16:33 <dminuoso> And we had a talk during Munihac a while ago with some of the GHC developers about it
15:17:46 <sm[m]> I think my working definition is: a module is an importable/exportable chunk of software
15:17:52 <gtk> All primitive types are unlifted – can’t contain bottom. what does it mean bottom? why is it important or meaningful to contain a bottom?
15:17:54 <dminuoso> sm[m]: https://github.com/goldfirere/ghc-proposals/blob/local-modules/proposals/0000-local-modules.rst
15:18:16 <dminuoso> gtk: bottom is a name for "can contain error or infinite computation"
15:18:35 <sm[m]> ie, a chunk of software whose visibility can be controlled
15:18:53 <dminuoso> gtk: phrased differently, if its unlifted then it *definitely* is defined and has a value
15:19:03 <sm[m]> thanks dminuoso
15:19:15 <dminuoso> (in the implementation it means we dont need to represent it in a way that allows for bottom)
15:20:05 <dminuoso> gtk: Roughly, you could pretend unboxed and unlifted to mean the same thing. We have both because there's things that happen to be boxed but unlifted
15:20:08 <dminuoso> ByteArray# comes to mind
15:20:29 <dminuoso> (So ByteArray# uses a boxed representation, but it cannot ever contain bottom)
15:21:24 <gtk> So ByteArray# can not contain error?
15:21:24 <gtk>  
15:21:44 <bqv>     • No instance for (Show (IO b0)) arising from a use of ‘print’
15:21:48 <bqv> Uh, what
15:22:49 <Rembane> bla >>= print 
15:22:52 <Rembane> Should work better 
15:23:07 <dminuoso> gtk: right
15:23:11 <gtk> dminuoso: bottom means can contain error; so if ByteArray# don't contain bottom, it means the opposite of can contain error?
15:23:15 <monochrom> bqv, if you have "foo :: IO (IO Int)", perhaps you have better luck telling ghci to "x <- foo", so as to sidestep the thorny question "how to print x :: IO Int"
15:23:20 <dminuoso> gtk: Id rather say "bottom means not defined"
15:23:33 <dminuoso> the reason I chose this phrasing is, becaue it could also be an infinite computation
15:24:00 <bqv> Rembane: mm, seems it was hiding an error
15:24:11 <gtk> is this infinite computation? [1..] dminuoso 
15:24:21 <dminuoso> `length [1..]` is
15:24:40 <bqv> monochrom: I just didn't realise... I did <&> instead of >>= but couldn't tell cause it was just silent
15:24:43 <dminuoso> It will not ever return a value, from a semantics position that however is indistinguishable from `error "foo"`
15:24:55 <dminuoso> In both cases you don't get a value back
15:26:28 <dminuoso> gtk: So in short: If its unboxed, its also necessarily unlifted
15:26:31 <gtk> dminuoso: i still dont see the point of distinguishing lifted or primitive
15:26:36 <dminuoso> (because it requires boxing in order to have bottom)
15:27:08 <dminuoso> gtk: So boxing just means you have an additional level of indirection in memory
15:27:21 <dminuoso> we need that boxing in order to represent say thunks
15:27:37 <dminuoso> without that box, at best you could just have a value right there.
15:27:49 <gtk> dminuoso: i sort of get boxed vs. unboxed; it seems boxed are in the land of haskell. but lifted is more baffling to understand
15:28:03 <dminuoso> gtk: the term "lifted" is not interetsing
15:28:09 <dminuoso> it's "unlifted" that is interesting
15:28:37 <dminuoso> Like I said, the only reason to talk about lifted/unlifted is because of things like ByteArray#
15:29:01 <gtk> when would you use Int# instead of just Int?
15:29:06 <dminuoso> In GHC, ByteArray# exists on the heap, so that requires an indirection (thus boxing!)
15:29:32 <dminuoso> But that's just an implementation issue, in principle we dont need to represent a thunk that could, possibly evalutae to error or infinite computation
15:29:59 <monochrom> You have to consider how to implement laziness, and how to still have non-lazy, actual integers, in order to see you need both lifted and unlifted.
15:30:30 <monochrom> If you have time, any of those lengthy STG papers/tutorials has it.
15:30:31 <gtk> so unboxed are not lazy?
15:30:37 <dminuoso> indeed.
15:30:45 <dminuoso> they're just there, directly in memory
15:30:59 <gtk> I'm begging to see through the cloud
15:31:01 <dminuoso> if you had a pointer to an unboxed value, you could just read from that pointer
15:31:07 <gtk> beginning
15:31:13 <monochrom> If you have less time, https://github.com/takenobu-hs/haskell-ghc-illustrated is of reasonable length.
15:32:20 <dminuoso> If it wasnt for things like ByteArray#, we wouldnt even have lifted/unlifted, we'd just have boxed/unboxed
15:32:36 <dminuoso> (and implicitly know that boxed meant lifted, and unboxed meant unlifted)
15:33:37 <monochrom> Yeah the 2nd axis is just because some non-lazy primitive things are too big so they must still sit on the heap.
15:34:30 <dminuoso> So if you want the really short answer, replace "lifted" with "boxed", and "unlifted" with "unboxed", and then move on.
15:34:30 <gtk> Is there any good tutorials on how GHC works? 
15:34:36 <dminuoso> That's an approximation that's perfectly fine
15:34:41 <monochrom> "box" means exactly what Rust means by Box<T>.
15:34:44 <dminuoso> gtk: monochrom linked a pretty good book above
15:34:47 <monochrom> (How convenient!)
15:34:58 <gtk> I've tried to read the wiki. But it's a bit daunting.
15:35:09 <gtk> dminuoso: ok i'll chck it
15:35:15 <dminuoso> well. "book"
15:35:20 <dminuoso> its rather a pdf with some slides
15:35:26 <monochrom> This is supposed to be daunting. Especially for people who have never written a compiler.
15:35:40 <dminuoso> an industry grade compiler
15:35:54 <dminuoso> With decades of research in its code base
15:35:57 <monochrom> Nah, doesn't have to be that far.
15:36:15 <dminuoso> oh
15:36:19 <dminuoso> I read that statement wrong
15:36:26 <dminuoso> Or you understood my remark wrong
15:36:30 <dminuoso> Either way
15:37:03 <gtk> Do you guys all take a complier theory class first right before understanding this stuff
15:37:09 <monochrom> Having written a compiler, even a toy one, even for an imperative eager language, primes your mind to anticipate patience, craziness, and cool tricks when you level up to a harder compiler or language.
15:37:12 <dminuoso> No, I dropped out of school
15:38:00 <dminuoso> monochrom: heh, it wasnt until I wrote my very own kernel that I understood how to be mindful of writing cache aware code.
15:38:33 <dminuoso> It's quite amazing how writing cache and pipeline aware code can easily bump up performance by a factor of 10.
15:39:15 <Rembane> dminuoso: Why did you write your own kernel?
15:39:37 <dminuoso> Rembane: The short answer, I wanted to understand what `return 0;` returned to in main in C.
15:39:58 <Rembane> dminuoso: That sounds like quite a rabbit hole. Nice! :D
15:41:10 <monochrom> A "computer organization" class is the minimum requirement for this stuff.
15:41:34 <monochrom> If you don't know jack about stack, heap, registers, addresses, you have no chance.
15:41:43 <gtk> I'm at the beginning chapters of the dragon book on compilers
15:41:57 <dminuoso> In retrospect, the dragon book is not that good of a book
15:42:14 <dminuoso> It doesn't cover the really interesting parts of a compiler, in my opinion
15:42:16 <gtk> It's dated?
15:42:27 <hekkaidekapus> sm[m]: GHC/Haskell has an extension to the Haskell-2010’s module system. It’s of course Backpack whose concern is about modular development, in the incremental and separate flavours. Haskell-2010 is grosso modo about the incremental flavour—what you called ‘module~file’.
15:42:32 <dminuoso> But, if you're completley new to the subject, it's worth a read I guess.
15:42:39 <dminuoso> gtk: being dated is not the problem at all
15:42:45 <monochrom> And my "know stack" does not mean you've heard of it and can parrot talking about "non-tail call uses stack". I mean you have screwed around with the stack pointer register.
15:42:54 <monochrom> at the asm level
15:44:14 <bqv> :t GHC.Generics.to
15:44:15 <lambdabot> GHC.Generics.Generic a => GHC.Generics.Rep a x -> a
15:44:20 <bqv> This shadows lens :|
15:44:43 <bqv> (it's reexported by protolude!)
15:44:50 <monochrom> Oh, Appel's "modern compiler implementation in ML" is much better.
15:45:24 <dminuoso> gtk: Also consider Types and Programming Languages if you are interested in compilers more. Sadly the dragon book doesn't really talk about types
15:45:26 <gtk> monochrom: let me check that out too
15:45:57 <dminuoso> And Appel is indeed a good read
15:46:09 <gtk> I hope I dont need to understand too deeply about lambda calculus
15:46:22 <gtk> I mean that would defintely kill me if i have to learn that too
15:46:42 <dminuoso> Lambda calculus is very simple *shrugs*
15:48:40 <gtk> dminuoso: great moment of solitude for you
15:49:26 <monochrom> lambda calculus is simple or complex depending on how many theorems you're required to prove about it.
15:50:25 <monochrom> it's rather like playing the piano or many (though not all) musical instruments.
15:50:46 <dminuoso> Or like category theory. Can explain it to 8 year old kids
15:50:57 <monochrom> If I just ask you to evaluate (\x. x x)(\y. y y) or just play one C major scale, that's simple.
15:50:59 <gtk> monochrom: that Appel book can be easily translated to Haskell right?
15:51:26 <monochrom> But proving confluence or playing a Liszt piece... You quickly learn that humanity can take any simple thing and turn it into a monster.
15:52:50 <gtk> Profunctors, contravariant...too damn difficult. I can't imaging how people managed to write stuff like the Lens library. I mean from beginner to that level, it's hard to find the path
15:53:04 <dminuoso> gtk: what's your overall goal?
15:53:24 <monochrom> It did take ekmett some 10 years, no?
15:53:29 <dminuoso> gtk: Also, https://patrickmn.com/software/the-haskell-pyramid/
15:53:40 <dminuoso> Understanding the basics of lens is actually wonderfully simple.
15:53:59 <dminuoso> When I was a beginner, ertes-w had a series of simple excercises, leading me to come up with lenses myself easily
15:54:04 <monochrom> When I was a kid I was like "I can't imagine how I would make it to university. I keep hearing it's really hard."
15:54:26 <monochrom> When I got into university I was like "I can't imagine how I would make it to PhD, I keep hearing it's really hard".
15:54:29 <monochrom> Then I got a PhD.
15:54:35 <dminuoso> Now I just look at optics-core and realize "oh well, profunctor optics really isn't *too* different from van laarhoven lenses..."
15:54:46 <dminuoso> monochrom: So what's hard for you now?
15:55:02 <monochrom> Getting tenure? I think I'm too old for that now. :)
15:55:25 <gtk> monochrom: do you teach haskell?
15:55:31 <gtk> at your university?
15:55:33 <monochrom> You just have to build up one step at a time.
15:55:36 <dminuoso> monochrom: Huh? How old are you?
15:55:39 <monochrom> 50
15:55:53 <dminuoso> Somehow I always imagined you to be 30.
15:56:01 <dminuoso> You *read* like you're 30!
15:56:02 <monochrom> Me too.
15:56:09 <Uniaika> oh damn
15:56:30 <dminuoso> gtk: Anyhow, take a look at my last link
15:56:34 <dminuoso> Let it sink in, and dont rush into things.
15:56:45 <gtk> got it
15:56:52 <dminuoso> Focus on getting productive, not trying to absorb all the things you think are necessary
15:56:56 <monochrom> I decided that I should just not worry about age (apart from watching out for health, of course).
15:57:24 <dminuoso> Mmm, that formally puts you into risk category on covid, doesnt it?
15:57:40 <dminuoso> Somewhat relatedly, are you still teaching currently? In presence?
15:58:01 <monochrom> Don't worry, I stay home, online teaching.
15:58:37 <monochrom> I have always kept a child-like curious mind. That helps a lot.
15:58:52 <monochrom> (towards imposting a young person)
15:59:04 <dminuoso> imposting?
15:59:08 <dminuoso> Is that a word?
15:59:14 <monochrom> I don't know!
15:59:17 <Uniaika> impersonating maybe?
15:59:27 <Rembane> Impostorating! 
15:59:27 <monochrom> imposter syndrome -> imposting
15:59:28 * Rembane nods 
15:59:42 <dminuoso> imposternizing
15:59:58 <Rembane> Postmoderinising imp e
16:00:20 <gtk> Simon jones also imposting a child. he doesn have to though,haha
16:01:06 <dminuoso> How does one impost a young person with that.. etymology monochrom?
16:01:16 <dminuoso> You should make an entry in merriam webster
16:01:49 <dminuoso> Or is this some obscure form of Canadian humor?
16:02:21 <jackdk> Does anyone know if the isos with the following types have a canonical name anywhere? `Iso' (Compose f Identity a) (f a)` and `Iso' (Compose Identity f a) (f a)`
16:02:22 <monochrom> perhaps simply ESL
16:04:16 <dminuoso> jackdk: categories calls them idl and idr
16:04:28 <dminuoso> https://hackage.haskell.org/package/categories-1.0.7/docs/Control-Category-Monoidal.html
16:04:46 <dminuoso> Not sure whether that's "canonical"
16:05:08 <dminuoso> But I'd suspect they'd always go with `idr` `identityR` or some such.
16:05:47 <dminuoso> (or you could call them lambda/rho)
16:15:37 <bqv> Anyone used lazyio?
16:18:11 <sm[m]> has anybody seen automated tests for a vty/brick app ? I tried with expect and empty but did not get there - https://github.com/simonmichael/hledger/tree/master/tests/ui
16:41:52 * hackage polysemy-extra 0.1.2.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.2.0 (locallycompact)
16:46:35 <bqv> Ooh..
16:48:53 * hackage polysemy-vinyl 0.1.1.0 - Functions for mapping vinyl records in polysemy.  https://hackage.haskell.org/package/polysemy-vinyl-0.1.1.0 (locallycompact)
17:29:52 * hackage implicit-hie 0.1.2.1 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.2.1 (Avi_Dessauer)
17:31:23 * hackage implicit-hie-cradle 0.3.0.0 - Auto generate hie-bios cradles  https://hackage.haskell.org/package/implicit-hie-cradle-0.3.0.0 (Avi_Dessauer)
17:58:14 <bqv> Translating imperative code to funct
17:58:21 <bqv> onal is a pain
17:58:58 <bqv> requires full redesign, not just porting
18:01:03 <sm[m]> it's often said that you can replicate imperative code in haskell. It's true, but not often done. If the techniques were better known it might be used a bit more
18:02:19 <bqv> I mean you can, it's just not ergonomic to write or efficient to run
18:18:19 <koz_> bqv: I dunno why you claim the latter. ST is pretty efficient IIRC.
18:19:50 <bqv> My gut feeling is it wouldnt be as effective as the pure haskell approach, since its kinda a mixture of both, but im happy to be corrected
18:21:05 <koz_> bqv: If you need mutability (which is what I guess the problem in translation would be), you can have it with ST.
18:21:28 <koz_> And it's pretty efficient as far as I'm aware.
18:23:44 <bqv> For the specific example im looking at (nasty nested for loops) i wouldnt doubt, but if i were to try and use it for the whole port im doing, id have to find an analogue for pointers too, as well as any freaky memory tricks, so i think its fair to assume it'd be less effective without some pretty sharp optimizing
18:24:19 <koz_> Uhh, we have pointers in GHC.
18:24:22 <koz_> Of various stripes even.
18:24:41 <koz_> And you can have 'nasty nested for-loops' in ST using ... wait for it... 'for'? :P
18:24:50 <koz_> (or for_ if you just need mutation)
18:25:23 <koz_> Like, I admit that it's not the nicest way to write Haskell, but it's neither particularly hard, nor particularly inefficient.
18:25:49 <bqv> *shrug* i'll take your word for it, still steering clear
18:37:53 <jophish> Perhaps I'm having a moment, but is there a nicer way of using values at compile time in quasiquotes than: $(lift [q|...|]). For example, lets say I have a quasiquoter doing string interpolation (so [q|$x$y|] becomes `x <> y`) but I'd like to evaluate that at compile time 
18:38:03 <jophish> $(lift foo) seems pretty weird
18:38:35 <jophish> I mean, I guess I could incorporate the lift into the output of the quoter, but $([q|...|]) also looks quite clumsy
18:42:19 <koz_> If you have QuasiQuotes turned on, and 'q' is a quasiquoter you defined, you can just do [q|..|]?
18:43:40 <jophish> [q|$x$y|] will insert the expression `x <> y` (for this interpolating quasiquoter), but what I really want is a string literal with contents equal to `x <> y`
18:44:03 <jophish> stage restrictions notwithstanding
18:44:44 <jophish> I suppose perhaps a simpler example is, can I write a quasiquoter [file|x|] which will become the results of: `readFile x`
18:44:55 <jophish> instead of becoming literally `readFile x`
18:45:50 <jophish> This is tantamount to getting the RHS of declarations in a splice
18:45:53 <jophish> which GHC doesn't support
18:46:13 <jophish> so perhaps this two stage process (i.e. $([q|...|])) is necessary
18:51:40 <jophish> Seems quite relevant: https://stackoverflow.com/questions/48489622/why-is-there-no-representation-for-th-in-th
19:19:53 * hackage implicit-hie 0.1.2.2 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.2.2 (Avi_Dessauer)
19:46:54 <zeta_0> hey there i'm trying to get hls to work in emacs, but it's throwing this error? `Command "hie-wrapper --lsp -d -l /tmp/hie.log" is not present on the path.
19:46:54 <zeta_0> `, I thought that is automatically set by default? https://github.com/emacs-lsp/lsp-haskell
19:48:22 <zeta_0> note, i installed hls with nix, from nixpkgs, and the binary is there, so I have no idea what the issue is!
19:48:42 * glguy wonders if hls works with the spacemacs haskell lyaer
19:49:08 <zeta_0> i'm using plain generic emacs!
19:49:33 <glguy> I'm not; I'm using spacemacs :)
19:54:23 * hackage implicit-hie 0.1.2.3 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.2.3 (Avi_Dessauer)
19:56:25 <zeta_0> here's my lsp-config that i'm using in my .emacs config: https://dpaste.org/U7Lb , any tips on how to fix this: `Command "hie-wrapper --lsp -d -l /tmp/hie.log" is not present on the path.
19:56:25 <zeta_0> ` issue?
19:56:43 <zeta_0> lsp-haskell config that is!
19:58:40 <zeta_0> i ran hie-gen as well, so that should't be an issue, and I installed hls with nix, and hls's binary is in the path, so i'm not sure where to go from here.
20:57:17 <glguy> The answer is that it's very easy to get it working with spacemacs, as it turns out
22:04:22 <dsal> @hoogle ((<&>))
22:04:22 <lambdabot> Prelude undefined :: forall (r :: RuntimeRep) . forall (a :: TYPE r) . HasCallStack => a
22:04:22 <lambdabot> Control.Exception.Base absentSumFieldError :: a
22:04:22 <lambdabot> Text.Printf errorShortFormat :: a
22:04:40 <dsal> Hmm...  I'm trying to remember a thing that exists...
22:05:19 <dsal> There's a thing like <|> but not applicative.
22:06:54 <dsal> Ah, it's <!>
22:08:47 <dsal> Nah, still not what I want.  I think I'm trying to be too fancy.
22:31:31 <Echosolacre> Hey all, I'm still a beginner and I am wondering how to read this... on :: (b -> b -> c) -> (a -> b) -> a -> a -> c. Is this to say that the typeclass of on is defined by a binary function which maps to a unary function which maps to a twice and then outputs c? 
22:31:46 <Echosolacre> http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Function.html
22:31:53 <Echosolacre> I'm following the above.
22:32:08 <Echosolacre> Going through LYAH and this on function is throwing me a bit.
22:32:40 <Echosolacre> Any thoughts would be greatly appeciated.
22:43:35 <jackdk> I think you have the idea right, but avoid using the word "typeclass" to describe this, because that's a specific concept in haskell
22:44:08 <jackdk> I think it's clearer if you add parens that are not strictly necessary: `on :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)`
22:44:10 <jackdk> gtg
22:48:33 <Echosolacre> I have a really basic question about what Jackdk just said. When you look at (b -> b -> c) -> (a -> b) -> (a -> a -> c), I think of it like there is a function that takes a variable, maps it to the same variable, and then outputs a different variable. (b -> b-> c).
22:48:42 <Echosolacre> Sorry, this understanding is probably way off.
22:48:54 <Echosolacre> How do you guys read these sections of the code?
22:49:55 <Echosolacre> '->' is plain speak is "map to", no?
22:50:06 <Echosolacre> plain speak for*
23:02:25 <c_wraith> I generally don't read code in words.
23:02:30 <c_wraith> They're too limiting
23:53:14 <dminuoso> jackdk: btw did you settle on a name for those isos?
