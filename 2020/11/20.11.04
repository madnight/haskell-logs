00:53:55 <bqv> gosh it's remarkably hard to make the impossible happen
00:54:13 <bqv> ghc: panic! Loading temp shared object failed
00:57:43 <idnar> bqv: reminds me of that ghc bug where if typechecking failed it would delete the source file
00:57:53 <bqv> D:
00:57:58 <bqv> that sounds AWFUL
00:58:13 <merijn> to be fair, that was never released :p
00:58:25 <bqv> phew
00:58:39 <dminuoso> bqv: No it's quite good actually
00:58:49 <dminuoso> What better way to force you to write good code.
00:59:00 <dminuoso> It either does the right thing or not exist at all!
00:59:07 <bqv> how very ..rusian
00:59:49 <[exa]> "make bad code irrepresentable" has never gone further!
01:00:27 <dminuoso> Also it ensures you never leave your working free in an uncompilable state.
01:00:49 <dminuoso> Can we bring it back in?
01:00:50 <[exa]> is this the future?
01:02:28 <[exa]> dminuoso: not everyone will really like it, I suggest -XPenance
01:03:15 <bqv> -fno-sacrilege
01:03:48 <[exa]> :]
01:06:01 <maerwald> merijn: prelude made it impossible to ship that patch
01:24:42 <dminuoso> [exa]: Will it be part of glasgow-exts?
01:25:11 <dminuoso> Also, perhaps we could enable it by default with TypeInType
01:29:35 <typetetris> Is there a compiler/rts option to always open stdin and the like in binary mode?
01:35:04 <nshepperd> sounds like https://github.com/munificent/vigil
01:36:46 <merijn> typetetris: Eh...there is no such thing?
01:36:57 <merijn> typetetris: Do you mean unbuffered, maybe?
01:42:24 <__monty__> Or maybe raw or cbreak terminal mode?
01:44:17 <merijn> Way to flex that obscure pseudo-terminal knowledge :p
01:45:14 <typetetris> `https://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO.html#v:hSetBinaryMode`
01:46:12 <__monty__> merijn: That's what happens when you arm people with APUE : )
01:46:14 <typetetris> Just had a pesky problem, where a program failed writing to stdout as the encoding associated with stdout was not able to represent all chars. An alternative to binary mode would be, to an encoding with replacement chars as default.
01:46:55 <merijn> Or setting the right encoding? :p
01:47:19 <arahael> How would binary mode fix that?
01:47:34 <typetetris> arahael: binary mode sets char8 as encoding, which never fails.
01:47:43 <arahael> typetetris: So it corrupts the data?
01:47:58 <typetetris> merijn: Yes. We tried. Didn't work. with-utf8 was the rescue.
01:52:04 <tomsmeding> typetetris: does it work if you redirect the output to a file? So keep stdout in the usual text mode, but avoid actually writing it to the terminal
01:52:28 <tomsmeding> (i.e. is haskell the problem or the terminal)
01:53:22 <merijn> typetetris: eh, char8 doesn't fail, it just corrupts your output :p
01:53:41 <merijn> typetetris: What are you outputting and to what?
01:53:45 <typetetris> tomsmeding: We had a clear `<stdout>: invalid argument (invalid character)` exception. So the handle being set to an encoding not able to handle the output was the culprit.
01:54:09 <tomsmeding> haskell threw that exception? ah
01:54:11 <maerwald> ah I remeber that, you have to force encoding in your main, there's a ghc ticket
01:54:11 <typetetris> merijn: Log output to be consumed by human readers. A replacement char here and there doesn't hurt.
01:54:22 <typetetris> tomsmeding: yes
01:55:08 <tomsmeding> what maerwald said, or perhaps (to avoid changing your program) pipe the output of your program through another program first that fixes up invalid characters (that may or may not work)
01:55:14 <merijn> I mean, you can just use the IO functions from ByteString to write out stuff
01:55:16 <tomsmeding> (not sure about windows' semantics in that regard)
01:55:27 <typetetris> maerwald: And remember not only to use `setLocalEncoding` but also `hSetEncoding` (or some such) on all three `stdin`, `stdout` and `stderr`. That is at least unexpected for the haskell beginner comming from c :)
01:56:13 <typetetris> merijn: Thats true. It is an existing codebase and up to now, there hasn't been fancy chars in the output.
01:56:30 <dminuoso> typetetris: Set the correct locale?
01:57:24 <maerwald> typetetris: https://gitlab.haskell.org/ghc/ghc/-/issues/8118
01:57:28 <tomsmeding> I have a hard time believing that bytestring IO functions will avoid this exception
01:57:32 <typetetris> dminuoso: The program is sadly called in a convoluted process and our attempts to push `LANG` and `LC_CTYPE` settings to it failed. I know, thats bad, but it is what it is.
01:57:50 <maerwald> This is a ghc bug
01:57:52 <typetetris> tomsmeding: Yes.
01:58:05 <tomsmeding> it's not windows? what -- since when has binary mode done anything on unix-like systems?
01:58:42 <dminuoso> tomsmeding: Perhaps you should focus on unconvolving that process instead?
01:58:57 <dminuoso> I mean if the underlying problem is that you cant feed the locale through, then I'd rather fix
01:58:59 <merijn> tomsmeding: Why? The ByteString IO functions don't do any encoding/decoding
01:59:00 <tomsmeding> typetetris: ^
01:59:05 <tomsmeding> not me dminuoso ;)
01:59:19 <dminuoso> oh. 
02:00:15 <typetetris> dminuoso: Time pressure and other not so good reasons.
02:01:05 <dminuoso> "Let's finish this bridge" - "But we the supports are not strong enough to hold it" - "We're already lagging behind, let's open it now and fix it later"
02:01:44 <tomsmeding> merijn: I was confused as to where in the stack the error was actually thrown, I stand corrected
02:01:51 <maerwald> most of the time programmers don't code anything really important, which is why our engineering practices are shite
02:01:57 <dminuoso> typetetris: Are you, by any chance, operating inside docker containers?
02:02:19 <typetetris> dminuoso: Not that I know of. But I also don't know the whole process.
02:02:23 <dminuoso> maerwald: And even if they do, human lives lost due to "it was a software issue" is acceptable.
02:02:54 <maerwald> dminuoso: no, because as soon as human lives are on the line, you have to comply to standards and regulations
02:03:01 <dminuoso> It's as if people have been so desensitized, that it's completely normal that "software is often wrong" and not "programmers make mistakes"
02:03:10 <dminuoso> maerwald: Haha, you certainly have not worked in healthcare.
02:03:18 <maerwald> dminuoso: automotive.
02:03:56 <maerwald> https://en.wikipedia.org/wiki/ISO_26262
02:04:01 <dminuoso> Hospitals are prime examples of IT done *extremely* poorly. If your hospital gets sacked by ransomware, then it's clearly not the fault of shitty IT admins running unpatched exchanges, windows xp machines with the poorest security.
02:04:12 <dminuoso> We had a death in Germany just this year because of that.
02:04:22 <dminuoso> No heads ever rolled.
02:04:23 <maerwald> that's just poorly regulated
02:06:26 <dminuoso> maerwald: Or conversely, data privacy. If you leak half your customer database, you get a slap on the wrist at best
02:06:30 <dminuoso> Customers wont even care
02:06:38 <typetetris> I still think its a mistake to use `String -> Handle -> IO ()` functions using external environment variables to detect, what actual bytes to write to the handle. I will avoid that in the future. Respecting locale is a thing, only if writing to a terminal, in my opinion. And then it should be ok, to have replacement chars. Shouldn't fail to strange settings of the user.
02:06:49 <maerwald> privacy and security is less regulated than safety
02:06:49 <daydaynatation> what's the difference between: newtype instance vs. type instance
02:06:53 <dminuoso> Clients have very low expectancy of software quality
02:07:03 <dminuoso> maerwald: Its not even about regulation, its about client expectancies.
02:07:23 <maerwald> regulations is the *only* thing that can change the market
02:08:08 <maerwald> formal methods is recommended in 26262, but not mandatory... if they made it mandatory, then Porsche, Daimler and co would invest millions into it, just so that they can ship their products
02:08:17 <typetetris> maerwald: In germany there is "MÃ¤ngelhaftung" and if clients would enforce that, most software companies would change there tactics fast. But the clients don't enforce that right *they already have*.
02:08:29 <typetetris> s/there/their/
02:08:40 <dminuoso> daydaynatation: Huh.. newtype instance - I didn't even know that was a thing.
02:09:33 <daydaynatation> dminuoso: lots of it used in the vector package
02:09:47 <dminuoso> https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/newtype_deriving.html#a-more-precise-specification
02:09:55 <dminuoso> Is the only mention of this I can find
02:10:24 <daydaynatation> dminuoso: Data.Vector.Uboxed.Base
02:12:30 <dminuoso> daydaynatation: Judging from the ergonomics, Id say that it's an alternate perhaps older way to do GND + via
02:12:44 <dminuoso> So I'd say:
02:12:47 <dminuoso> newtype instance MVector s () = MV_Unit Int
02:14:31 <dminuoso> Yeah no idea. It looks 
02:14:37 <dminuoso> Undocumented.
02:15:05 <daydaynatation> It's pretty hard to understand how the package is designed
02:16:20 <dminuoso> daydaynatation: Ah.. I think... this is for associated newtypes
02:16:30 <dminuoso> err.. newtype families?
02:16:36 <dminuoso> Is that a thing?
02:16:46 <dminuoso> A quick skim of ghc suggests its like data instances
02:17:20 <dminuoso> daydaynatation: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/type-families.html
02:17:22 <dminuoso> Indeed
02:17:29 <dminuoso> So these are instances of data families
02:17:59 <dminuoso> In Data/Vector/Unboxed/Base.hs you can find `data family MVector s a`
02:18:14 <dminuoso> `newtype instance MVector s () = MV_Unit Int` then is an instance for that family
02:18:46 <daydaynatation> so it's the same as data instance MVector s ()...?
02:19:10 <dminuoso> Well, except for data vs newtype differences
02:19:47 <daydaynatation> i see..
02:19:52 <daydaynatation> that's the key
02:19:55 <daydaynatation> thx!
02:19:55 <dminuoso> a data family is roughly a type family to an anonymous data type, and apparently you can point it either at an anoymous newtype or data (which is boxed and can have multiple constructors)
02:22:53 <dminuoso> % data family Foo a
02:22:53 <yahb> dminuoso: 
02:23:03 <dminuoso> % newtype instance Foo Int = F1 Int
02:23:04 <yahb> dminuoso: 
02:23:08 <dminuoso> % coerce (F1 1) :: Int
02:23:09 <yahb> dminuoso: 1
02:23:26 <dminuoso> % data instance Foo Float = F2 Int | F3 Char
02:23:26 <yahb> dminuoso: 
02:23:30 <dminuoso> % coerce (F2 1) :: Int
02:23:31 <yahb> dminuoso: ; <interactive>:71:1: error:; * Couldn't match representation of type `Foo Float' with that of `Int' arising from a use of `coerce'; * In the expression: coerce (F2 1) :: Int; In an equation for `it': it = coerce (F2 1) :: Int
02:25:18 <dminuoso> Well this is cool, thanks daydaynatation! TIL.
02:28:22 * hackage mysql-haskell 0.8.4.3 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.8.4.3 (winterland)
02:29:02 <daydaynatation> dminuoso: so all these techniques are for generic programming right?
02:29:22 * hackage mysql-haskell-openssl 0.8.3.1 - TLS support for mysql-haskell package using openssl  https://hackage.haskell.org/package/mysql-haskell-openssl-0.8.3.1 (winterland)
02:30:31 <dminuoso> daydaynatation: In principle you can get away without data families, you could just create data types manually and them use tyfams or mptc+fundeps
02:32:14 <dminuoso> daydaynatation: Think of it as an open GADT, perhaps.
02:32:25 <dminuoso> (Or similar to it)
02:33:02 <bqv> ugh. i figured out the issue
02:33:20 <bqv> it's https://github.com/haskell/cabal/issues/7082
02:34:44 <daydaynatation> dminuoso: I might not be using these techniques myself but when reading existing code, there are everywhere
02:36:29 <bqv> dminuoso: heh
03:27:22 * hackage servant-blaze 0.9.1 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.9.1 (maksbotan)
03:43:12 <bqv> i feel like toEnum . fromEnum should be provided by default somewhere
03:43:29 <bqv> perhaps not.
03:53:17 <tomsmeding> it feels like a dangerously general operation
03:54:35 <dminuoso> Id argue Enum in general is dangerous
03:54:39 <dminuoso> % :t fromEnum
03:54:39 <yahb> dminuoso: Enum a => a -> Int
03:54:41 <dminuoso> Err
03:54:44 <dminuoso> % :t toEnum
03:54:45 <yahb> dminuoso: Enum a => Int -> a
03:54:51 <dminuoso> This lacks MonadFail :(
03:55:24 <tomsmeding> not sure whether MonadFail is the right thing here, but yes partial function :p
03:56:41 <bqv> is it realistic to avoid partial functions entirely, in a project of any substantial size?
03:57:40 <idnar> http://hackage.haskell.org/package/relude-0.7.0.0/docs/Relude-Extra-Enum.html#v:safeToEnum
03:57:57 <tomsmeding> possible, yes, realistic I think no, unless you want to admit a proliferation of data types
03:58:26 <tomsmeding> if you have a sum type with a number of constructors, and your application gets big enough, you'll have situations where only certain of those constructors are valid in a particular place
03:59:24 <tomsmeding> you could make it all total by either adding a new datatype with the constructor subset and converting when the domain restriction happens, or by moving the restrictions to the type level with some GADT trickery
03:59:36 <bqv> i wonder if that relude function would even work for me. my enum instances are mostly written for me by c2hs now :|
03:59:38 <tomsmeding> both can work on a small scale but at some point it hurts readability/understandability I think
03:59:49 <bqv> yeah, agreed
04:00:50 <tomsmeding> though perhaps you can attempt to see head/fromMaybe/toEnum as a different "class" of partial functions than the case I described, but that's getting firmly and deeply in the subjective realm :p
04:01:29 <bqv> i actually hit the problem you described earlier
04:01:49 <bqv> my solution was undefined, which is... kinda worse
04:01:51 <merijn> Enum is a terrible class anyway :p
04:01:59 <merijn> If anything I'd just recommend avoiding Enum :p
04:02:21 <bqv> as usual, next to impossible if you FFI at all
04:02:48 <merijn> How so?
04:03:28 <bqv> C enums would have to be sent back and forth somehow
04:03:45 <bqv> any haskell sum type eventually ends up as a number
04:04:18 <bqv> you could i guess have checks at every marshal in, but that's no better than Enum with safeToEnum
04:04:23 <merijn> I fail to see how that requires the Enum class, though?
04:04:56 <bqv> well what would be an alternative?
04:06:14 <dminuoso> bqv: I tend to have my own Enumerable typeclass that adds a MonadFail constraint to toEnum
04:06:32 <dminuoso> For things where want to keep a mapping to numbers (usually I use this for protocol de/serializatoin)
04:06:38 <merijn> Just writing a single function to convert, safeToEnum only works for bounded types and makes a bunch of assumptions about the underlying Enum instance (and I'd be war to make any assumptions of those)
04:06:52 <dminuoso> (The reason for using a typeclass is mostly convenience, it could just be plain functions)
04:07:24 <dminuoso> And that typeclass is not about *enumerating* from/to, it's just for mapping into something
04:07:32 <bqv> oh yeah, just, generally i considered any function to be of vastly the same nature as Enum anyway
04:09:04 <dminuoso> bqv: class (t ~ MappedInto f, Show t) => EnumMapping f where type MappedInto t; mappingTo :: f -> t; mappingFrom :: MonadFail m => t -> m f
04:09:07 <dminuoso> Is roughly what I use
04:10:14 <bqv> pretty general, fair enough
04:10:16 <dminuoso> oh heh, that hsould be `type MappedInto s`
04:10:30 <dminuoso> or f, rather. bah, my code is not copy pastable for other reasons
04:10:51 <bqv> curious why the Show constraint at that level
04:12:19 <merijn> For the error to MonadFail, presumably
04:12:26 <dminuoso> Mmm. Good question, I guess there is no need for it there
04:13:05 <dminuoso> bqv: The reason I have it that general, is because Im writing a protocol library here, so some enums are mapped into Word8, others into Word32, etc..
04:13:15 <dminuoso> (So that helper typeclass is then used in my Get/Put code)
04:13:29 <bqv> ah fair
04:13:58 <dminuoso> It was either that, or sprinkling fromIntegral left and right, not knowing if I accidentally narrow data.
04:14:11 <merijn> Or...just write individual Get/Put operations? >.>
04:14:28 <dminuoso> merijn: That would have worked too, of course. The typeclass was really just for convenience.
04:14:58 <dminuoso> It reduces some boilerplate in some areas. :)
04:15:00 <merijn> dminuoso: The convenience of being unable to have multiple versions in your codebase? >.>
04:15:07 <dminuoso> merijn: That's perfectly fine for me.
04:15:12 <dminuoso> It's an internal typeclass I dont ever expose.
04:15:28 <dminuoso> And these things do *not* ever change
04:15:45 <bqv> merijn: as a fan of a strictly typed language, surely you appreciate restriction :D
04:16:04 <dminuoso> bqv: No, it's an annoying restriction since if you ever have multiple protocol versions, you need to start using newtype wrappers
04:16:17 <dminuoso> But in my case, the protocol is standardized and hasnt changed in 20 years. :p
04:16:23 <merijn> You fool! You fell victim to one of the classic blunders - the most famous of which is "never get involved in a land war in Asia" and "Never go in against a Sicilian when death is on the line", but only slightly less well-known is this: "Never use typeclasses for (de)serialisation"! Ha ha ha ha ha ha ha! Ha ha ha ha ha ha ha!
04:16:25 <dminuoso> (It was only ever ammended)
04:16:29 <bqv> heh
04:16:40 <dminuoso> merijn: I dont use typeclasses for get/put itself.
04:16:45 <dminuoso> Or actually, that's not true
04:16:49 <dminuoso> I have my own Get/Put typeclasses!
04:16:51 <dminuoso> Again, for convenience
04:17:07 <dminuoso> But I know what price I pay, the cost is lower than the extra effort and annoyance from writing functions instead.
04:17:29 <dminuoso> There is ever only a single protocol encoding of `Foo
04:17:38 <dminuoso> And, should it ever be different, I can turn it into functions easily
04:20:22 * hackage servant-multipart 0.12 - multipart/form-data (e.g file upload) support for servant  https://hackage.haskell.org/package/servant-multipart-0.12 (maksbotan)
04:37:40 <idnar> merijn: hahaha
04:39:06 <idnar> @type \f x -> coerce (f (coerce x))
04:39:08 <lambdabot> error:
04:39:08 <lambdabot>     â¢ Variable not in scope: coerce :: t1 -> t3
04:39:08 <lambdabot>     â¢ Perhaps you meant âcoercedâ (imported from Control.Lens)
04:39:32 <bqv> unsafeCoerce?
04:39:49 <merijn> unsafeCoerce is different and, well, unsafe :p
04:39:57 <idnar> no, I want the safe one
04:39:58 <bqv> thought that was his plan
04:40:01 <bqv> fair
04:40:03 <int-e> :t Data.Coerce.coerce
04:40:05 <lambdabot> Coercible a b => a -> b
04:40:32 <idnar> @type \f x -> Data.Coerce.coerce (f (Data.Coerce.coerce x))
04:40:33 <lambdabot> (Coercible a1 b, Coercible a2 t) => (t -> a1) -> a2 -> b
04:41:08 <merijn> I think you could juse coerce f? :p
04:41:48 <merijn> :t Data.Coerce.coerce :: (Coercible a b, Coercible c d) => (a -> c) -> (b -> d)
04:41:49 <lambdabot> error:
04:41:50 <lambdabot>     Not in scope: type constructor or class âCoercibleâ
04:41:50 <lambdabot> error:
04:42:05 <merijn> :t Data.Coerce.coerce :: (Data.Coerce.Coercible a b, Data.Coerce.Coercible c d) => (a -> c) -> (b -> d)
04:42:07 <lambdabot> (Coercible a b, Coercible c d) => (a -> c) -> b -> d
04:42:09 <merijn> boom
04:42:25 <idnar> oh yes duh
04:42:51 <int-e> @let import Data.Coerce
04:42:52 <lambdabot>  .L.hs:80:1: error:
04:42:52 <lambdabot>      Data.Coerce: Can't be safely imported!
04:42:52 <lambdabot>      The module itself isn't safe.
04:43:06 <tomsmeding> safe haskell rears its head!
04:43:18 <Uniaika> <3 <3
04:43:19 <int-e> Fun, I thought it was supposed to be safe by now.
04:43:30 <idnar> either way, awkward to use without -XTypeApplication I guess
04:43:34 <Uniaika> int-e: with a name like thatâ¦ ? :P
04:43:43 <int-e> Uniaika: why not?
04:43:49 <merijn> Pretty sure Data.Coerce should be Trustworthy, not Safe
04:44:02 <int-e> merijn: well, base *is* trusted
04:44:09 <Uniaika> int-e: the name screams "force your hand" :P
04:44:17 <merijn> Actually, it's explicitly Unsafe
04:44:23 <int-e> merijn: the matter of fact is... that.
04:44:31 <merijn> int-e: Package trust and Trustworthy is different
04:44:48 <int-e> merijn: package trust means to trust all Trustworthy modules in the package
04:44:53 <merijn> trusted packages are "those packages whose Trustworthy modules should be treated as actually trustworth"
04:45:07 <int-e> so if it *were* marked Trustworthy, lambdabot would allow it to be imported
04:46:28 <int-e> you *can* get coerce in lambdabot anyway, via profunctors, but I forgot the precise definition; it was somewhat convoluted.
04:47:27 <int-e> @let import Data.Profunctor.Unsafe
04:47:29 <lambdabot>  .L.hs:114:1: error:
04:47:29 <lambdabot>      Data.Profunctor.Unsafe: Can't be safely imported!
04:47:30 <lambdabot>      The package (profunctors-5.5.2) the module resides in isn't trusted.
04:47:34 <int-e> Ah.
04:47:42 <int-e> Okay, I take it back :)
04:48:24 <int-e> Uniaika: In any case, *that* module is marked Trustworthy btw... despite the name.
04:49:53 <int-e> (for historic reasons, really... it uses coerce noawadays, to unwrap and rewrap newtypes deep inside data structures, but it used to be based on unsafeCoerce)
04:51:15 <int-e> I still expect that coerce is leaked through the lens ecosystem *somewhere*.
04:51:43 <idnar> :t coerced
04:51:44 <lambdabot> (Profunctor p, Functor f, Coercible s a, Coercible t b) => p a (f b) -> p s (f t)
04:52:03 <int-e> oh, that simple.
04:52:11 <idnar> :)
04:52:15 <int-e> thanks
04:53:06 <idnar> from just now: <lambdabot>     â¢ Perhaps you meant âcoercedâ (imported from Control.Lens)
04:54:56 <int-e> :t \f -> runIdentity . coerced (Identity . f . runIdentity)
04:54:57 <lambdabot> (Coercible b1 a, Coercible c b2) => (b1 -> b2) -> a -> c
04:56:28 <fendor> is it just me or is the cabal index pretty big? 800MB in .cabal/packages?
04:57:10 <idnar> is Coercible symmetric?
04:57:51 <int-e> fendor: yes, but well... it contains all .cabal files every uploaded to hackage, and a bit of extra stuff
04:58:14 <dcoutts> fendor: that's uncompressed locally. It only downloads the compressed version which is 90M.
04:58:25 <int-e> idnar: yes.
04:58:31 <fendor> dcoutts, oh well, on the server it still takes 800mb
04:58:33 <merijn> .cabal/package holds all the downloaded tarballs too
04:58:35 <int-e> and it's downloaded incrementally
04:59:05 <int-e> But for small VPSs it is big.
04:59:14 <fendor> just by invoking `cabal update`
04:59:24 <fendor> but admittedly, cabal 3.0.0.0, maybe something has changed?
04:59:34 <int-e> Regardless, this is normal :-/
05:00:31 <merijn> fendor: Well, what would you propose to change about it?
05:00:46 <merijn> fendor: You need an index of all packages to do dependency resolution
05:00:52 <fendor> merijn, nothing, I am just asking if that is to be expected
05:01:22 <mietek> Is the new Haskell Foundation website on github somewhere?
05:01:23 <merijn> fendor: Well, it has entries and hashes for every package (version) ever released, so...kinda
05:01:34 <fendor> not claiming it is bad or anything, I dont know how anyone else does it
05:01:55 <fendor> just wondering, because it seemed huge, but if it is ok, then it is ok
05:01:58 <dminuoso> fendor: They all do it the same, really.
05:02:02 <merijn> fendor: There doesn't seem to be a lot of reason to even have cabal on machines that aren't compiling, though?
05:02:14 <merijn> dminuoso: Naah
05:02:17 <merijn> dminuoso: Some do it much worse!
05:02:22 <dminuoso> heh
05:02:47 <fendor> merijn, the server is a playground for students, so it compiles stuff, but if every student has to download this index, it is 300 * 800MB which sums up quiet quickly
05:03:08 <fendor> but we solved it by having a read-only cabal store for every student, so that should be fine now
05:03:44 <dcoutts> fendor: you could share the package cache, without sharing the store, if that helps
05:03:52 <dcoutts> the download cache I mean
05:04:21 <dcoutts> it might be useful for your use case to have two stores, a shared read-only one and a local writable one
05:04:34 <fendor> dcoutts, yeah, that would solve the problem, too. Currently, we share both now, the store dir and index since students should not be able to download arbitrary packages anyways
05:04:51 <fendor> or rather, not be able to do it by accident
05:06:01 <dcoutts> fendor: there's a --offline flag, which I think you can also use in the ~/.cabal/config
05:06:18 <dcoutts> just causes any download attempt to fail, doesn't change the solver
05:06:35 <fendor> dcoutts, does that work with v2-*? did not seem to work for me when playing around with it
05:09:46 <merijn> fendor: I think it should? If not that sounds like a bug?
05:12:20 <fendor> merijn, hm, maybe it was a bug for cabal 3.0.0.0? I can try again later
05:17:18 <tomsmeding> quick question: does this datatype already exist in a commonly-used library? data PairOf f g t = PairOf (f t) (g t)
05:18:47 <dminuoso> tomsmeding: Yes.
05:18:56 <dminuoso> It's in base somewhere
05:19:20 <dminuoso> Err GHC
05:19:21 <dminuoso> tomsmeding: https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Generics.html#t::-43-:
05:19:22 <tomsmeding> that's what I was hoping with "commonly-used library" :p
05:19:34 <tomsmeding> oh right
05:19:41 <dminuoso> Oh and :*:
05:19:43 <tomsmeding> well :*: then
05:20:02 <dminuoso> tomsmeding: I do recall we had something outside generics as well
05:20:05 <tomsmeding> a Generics import will look decidedly strange in this file, but I guess the semantics work :p
05:20:20 <dminuoso> tomsmeding: http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Functor-Product.html
05:20:21 <dminuoso> There
05:20:31 <dminuoso> That's what I wanted :)
05:20:41 <tomsmeding> ah that's neater
05:20:43 <tomsmeding> thanks!
05:21:19 * tomsmeding notes in my memory that Data.Functor.Sum also exists
05:22:08 <tomsmeding> `Pair` collides with a constructor I already have in scope lol
05:22:50 <dminuoso> Qualified imports is a thing.
05:24:23 <tomsmeding> which is what I'll do :)
05:27:33 <fendor> merijn, https://paste.tomsmeding.com/O4uOK0Xv looks wrong to me? Ignore the permission errors, unless they hide the issue, they are caused by the read-only cabal store, so downloading is forbidden
05:28:56 <merijn> Does it actually go to the network?
05:29:29 <fendor> afaict yes
05:29:34 <merijn> hmm
05:29:39 <merijn> Then I dunno
05:30:51 <Franciman> hi, dost anybody use gi-gtk-declarative?
05:31:12 <fendor> so, locally, I can reproduce it by invoking `cabal repl --offline -b hpath` where hpath is a package I haven't downloaded yet. https://paste.tomsmeding.com/RFlwkwVP
05:40:23 <fendor> maybe the message is just wrong, might play around with it later
05:52:03 <tomsmeding> tcpdump/wireshark, or strace | grep "connect"?
06:07:43 <hekkaidekapus> fendor: There are two other options. 1) Disable the package index in ~/.cabal/config by commenting out the `repository hackageâ¦` stanza. 2) Write `active-repositories: :none` in cabal.project; this requires a bleeding-edge cabal-install.
06:16:11 <newbies> Hello!
06:16:25 <yushyin> hello newbies
06:17:20 <newbies> i have just got Haskell Platform
06:17:41 <newbies> where do i start
06:18:14 <opqdonut> I can plug my course: https://haskell.mooc.fi/
06:18:35 <opqdonut> (open, free, no signup, no deadlines)
06:19:50 <newbies> Thanks!
06:19:56 <newbies> i'm familiar with ML is it the same
06:20:50 <opqdonut> very similar, but the syntax is a bit different
06:21:04 <opqdonut> purity is probably the biggest concrete difference
06:21:08 <opqdonut> followed by laziness
06:22:40 <merijn> newbies: Going from ML to Haskell should be fairly easy
06:22:45 <merijn> @where tutorial
06:22:45 <lambdabot> http://www.haskell.org/tutorial/
06:23:24 <merijn> newbies: The tutorial was written for people coming from (S)ML, so that's probably the shortest intro you can get
06:23:43 <gtk> Are there still people using ML?
06:23:55 <merijn> Most of the other texts/books will waste a lot of time on basics you should already get from ML (pattern matching, recursion, etc.)
06:24:14 <merijn> gtk: Ocaml is an ML dialect and some diehards still use SML :)
06:25:14 <gtk> ML syntax is the reason I start learning Haskell. It's just neat and beautiful
06:26:20 <merijn> opqdonut: Purity is different, then again most people don't really have difficulty with purity per se as much as they struggle getting used to recursive thinking and ADTs, both of which you also need to learn for ML :p
06:28:30 <hekkaidekapus> There is also <https://dr-knz.net/haskell-for-ocaml-programmers.html> for a quick introduction to Haskell from an OCaml perspective.
06:29:06 <merijn> hah
06:29:11 <merijn> A colleague wrote that :p
06:30:31 <hekkaidekapus> \O/
06:30:36 <hekkaidekapus> Poss, R?
06:30:57 <merijn> Well, ex-colleague I guess, but yeah
06:31:48 <newbies> No [cradle] found for file.hs. Proceeding with implicit cradle
06:32:15 <newbies> what is this mean
06:32:20 <newbies> VScode
06:32:27 <merijn> You're using hls, I guess?
06:33:28 <merijn> newbies: Basically, the haskell language server needs to know how to compile your code to typecheck, etc. this config is called a cradle. It's saying you didn't write an explicit one, to it's using an implicit (auto-generated) one
06:34:15 <newbies> where do i have to config  it
06:34:22 * hackage less-arbitrary 0.1.0.2 - Linear time testing with variant of Arbitrary class that always terminates.  https://hackage.haskell.org/package/less-arbitrary-0.1.0.2 (MichalGajda)
06:34:30 <merijn> If it works, you don't have to :p
06:34:51 <newbies> '=D 
06:35:04 <newbies> i just wanted to know
06:35:06 <merijn> it's basically an info/debug message in case things break/don't work
06:35:17 <newbies> i see
06:35:24 <merijn> newbies: https://github.com/mpickering/hie-bios
06:36:16 <newbies> Thanks 
06:36:38 <yushyin> the implicit cradle never worked for me, not even once.
06:36:49 <merijn> yushyin: For simple projects it works for me
06:37:28 <yushyin> and 99% of the time it's just c&p from the cabal file
06:38:27 <hekkaidekapus> yushyin: You can also `cabal install implicit-hie && gen-hie > hie.yaml`
06:41:32 <yushyin> hekkaidekapus: thanks for the hint
06:41:48 <hekkaidekapus> np
06:42:50 <tomsmeding> how do people even pronounce 'hie'? as an acronym, eich aye ee? 'hy'? 'hee'?
06:43:06 <hekkaidekapus> Hi :P
06:43:31 <tomsmeding> implicit-greeting
06:55:03 <__monty__> tomsmeding: The latter for me, probably because of mother tongue induced brain damage.
06:55:32 <merijn> ;)
06:55:50 <merijn> __monty__: Like always typo-ing photos as photo's? ;)
06:57:15 <tomsmeding> __monty__: exactly the same for me :p
06:57:43 <__monty__> merijn: I do stumble but don't usually make that error. Commas are what trip me up the most.
06:58:32 <merijn> I mess up ' all the time in plurals, and of course a lot of "spatie fouten"  in the reverse direction :p
06:59:34 <hekkaidekapus> And if the brain damage is French-induced, the âhâ could be unspoken, landing you at ie, id est in Latin :D
06:59:36 <tomsmeding> the people that use spaces correctly in NL can be put together in one building even with corona separation rules
06:59:45 <merijn> tomsmeding: :p
07:10:17 <yushyin> guess I'm the odd one, I use a shwa for the e in hie
07:14:48 <bqv> disproportionately amused by the naming of Relude's "flap"
07:18:03 <Cheery> I either forgot how haskell language server works, or then it stopped working out of sudden.
07:20:24 <jonathanx> I'm headed home from work soon, have been spending too much time trying to figure out how to get auto rebuild on stack run (preferable with a browser refresh) going. I tried steeloverseer, but no cigar. Any suggestions?
07:20:46 <jonathanx> (auto rebuild as in rebuild on file changes)
08:07:00 <justsomeguy> jonathanx: Personally I use http://eradman.com/entrproject/ and the "tab reloader" firefox plugin. There are probably better ways to do it, though.
08:49:09 <dsal> Dumb lens question.   I'm working with aeson and want to modify two keys.  I've got    `v & deep values . _Object . at "k1" ?~ "XXX"`   I also want to modify "k2" the same way.  Is there a sensible way to do compose two of these `at`s so I can do them in the same place?
08:52:42 <Taneb> dsal: there's not a super great solution here, although there's a not-nice solution, Control.Lens.Unsound.adjoin does what you need
08:53:24 <dsal> This doc makes me feel bad:   Are you looking for failing?
08:55:04 <Taneb> "failing" can do "if you don't find anything in the first place, try the second"
08:55:12 <Taneb> But I see what you mean
08:56:05 <dsal> Hmm...  This seems newer than my lens.
08:57:43 <dsal> I guess I can just do something ugly in the short term.  It feels like something that should be possible.  It's really just "replace all occurrences of keys xs with these values" which feels like it's right there.
08:59:15 <dsal> A tiny helper function does the thing at least.
08:59:29 <dsal> `v & deep values . _Object %~ fixit`
09:23:52 * hackage Color 0.3.0 - Color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.3.0 (lehins)
09:33:08 <dsal> Actually, this is only working for setting string values.  It won't even let me set array values, which is bizarre to me.
09:34:00 <dsal> I'll just do the maximum gross thing.
09:34:09 <hc> switch to python? ;p
09:36:27 <dsal> ha
09:36:45 <bqv> can think of worse things to write in than python...
09:37:42 <koz_> bqv: The fact that a worse option than X exists does not make X a good option, for any value of X.
09:39:13 <geekosaur> they did say "maximum"
09:39:28 <koz_> geekosaur: So what, x86 asm? :P
09:39:39 <pjb> koz_: since the demise of display postscript, only X knows to do remote.
09:39:57 <geekosaur> 1802 asm, I think :p
09:54:31 <dsal> I feel like lens let me down a little here. https://www.irccloud.com/pastebin/Z5CZWFIL/gross.hs
09:56:32 <koz_> Well, lens isn't Rick Astley.
09:59:02 * dsal starts new library
09:59:43 <monochrom> hahaha koz_
09:59:45 <koz_> dsal: Is going to be named lens-rick?
10:00:03 <koz_> monochrom: I try.
10:00:05 <dsal> Yeah.  It'll solve all problems in a simple, natural way.
10:00:17 <koz_> dsal: It'll never tell a lie and hurt you?
10:00:50 <dsal> If you think about it, when a lens shatters, it becomes very dangerous to everything around it.
10:01:27 <DigitalKiwi> safety-lens
10:01:37 <monochrom> never gonna set you up, never gonna rickroll you
10:01:57 <DigitalKiwi> the docs page on hackage goes to youtube
10:11:05 <bqv> safety-lens sounds almost realistic
10:12:03 <DigitalKiwi> yeah i was actually trying to be helpful someone not me should make it
10:15:22 <bqv> though i imagine ed would be unhappy at lens being called unsafe
10:46:52 * hackage persistent 2.11.0.0 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.11.0.0 (parsonsmatt)
10:47:51 * hackage persistent-mysql 2.10.3 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.10.3 (parsonsmatt)
10:48:52 * hackage persistent-postgresql 2.11.0.0 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.11.0.0 (parsonsmatt)
10:49:52 * hackage persistent-template 2.9.1.0 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.9.1.0 (parsonsmatt)
10:50:52 * hackage persistent-sqlite 2.11.0.0 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.11.0.0 (parsonsmatt)
10:51:52 * hackage persistent-mongoDB 2.11.0.0 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.11.0.0 (parsonsmatt)
10:53:21 * hackage persistent-test 2.0.3.4 - Tests for Persistent  https://hackage.haskell.org/package/persistent-test-2.0.3.4 (parsonsmatt)
10:58:22 * hackage loc 0.1.3.10 - Types representing line and column positions and ranges in text files.  https://hackage.haskell.org/package/loc-0.1.3.10 (chris_martin)
10:59:12 <justsomeguy> Is there a way to visualize recursion trees for haskell functions? (Or, if not, what's a good tool for creating those diagrams by hand?)
10:59:22 * hackage citeproc 0.1.1 - Generates citations and bibliography from CSL styles.  https://hackage.haskell.org/package/citeproc-0.1.1 (JohnMacFarlane)
11:01:57 <sm[m]> justsomeguy: is the stack trace printed by error (at least from a profiling build) suitable ?
11:06:11 <justsomeguy> sm[m]: Hmm, let me see.
11:07:39 <sm[m]> If not there are tools for it, somewhere, but I don't know if they work for complex code
11:09:52 <justsomeguy> It's really just a few toy example functions that I'm using for my notes on recursion.
11:10:45 <sm[m]> A profile, perhaps improved by profiterole, could be another option
11:12:15 <justsomeguy> This is interesting. I have not looked into profiling until now.
11:13:09 <justsomeguy> Thanks for the hints, sm[m], I must go now :)
11:13:16 <sm[m]> np
11:25:52 * hackage blanks 0.5.0 - Fill-in-the-blanks - A library factoring out substitution from ASTs  https://hackage.haskell.org/package/blanks-0.5.0 (ejconlon)
11:40:22 * hackage servant 0.18.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.18.1 (maksbotan)
11:41:22 * hackage servant-server 0.18.1, servant-http-streams 0.18.1, servant-docs 0.11.7, servant-client-core 0.18.1, servant-client 0.18.1 (maksbotan): https://qbin.io/sport-ui-myce
11:49:37 <matthew-> hmm, this is probably a dumb question, but am I right in thinking of a list as a sum type with 1 type parameter?
11:49:57 <gobbleguy> sounds right
11:49:58 <Uniaika> matthew-: nah you're right
11:50:05 <bqv> lispy
11:50:35 <Uniaika> % :i []
11:50:36 <yahb> Uniaika: type [] :: * -> *; data [] a = [] | a : [a]; -- Defined in `GHC.Types'; instance Alternative [] -- Defined in `GHC.Base'; instance Applicative [] -- Defined in `GHC.Base'; instance Eq a => Eq [a] -- Defined in `GHC.Classes'; instance Functor [] -- Defined in `GHC.Base'; instance Monad [] -- Defined in `GHC.Base'; instance MonadPlus [] -- Defined in `GHC.Base'; instance Monoid [a] -- Defined in `GHC.Base
11:50:49 <Uniaika> yep', sounds about right matthew- :)
11:52:14 <matthew-> ok, thanks.
11:52:25 <crdrost> Yeah a list can be thought of as f(x) = 1 + x f(x), which you might manipulate to f(x) = 1/(1 - x), which has as a Taylor series f(x) = 1 + x + x^2 + x^3 + ...
11:59:16 <matthew-> hmm, just trying to get some terminology right in my head. In the type [Int], for example, it feels _application_ of [] and Int. What word is used here? Because it seems I'm looking for something other than sum or product
11:59:22 * hackage hdocs 0.5.5.0 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.5.5.0 (AlexandrRuchkin)
11:59:49 <jle`> application isn't wrong, i think
12:00:02 <jle`> like how if you apply 'negate' to '1', you get -1
12:00:08 <geekosaur> application is correct; [Int] can also be written ([] Int)
12:00:35 <matthew-> ok, so [] :: * -> *, so it is application, just at the type level
12:00:41 <geekosaur> similarly for Maybe Int which doesn't have the mixfix notation
12:00:57 <matthew-> ok, this makes sense
12:02:05 <hekkaidekapus> (But [] is overloaded. At the value level, it stands for the empty list.)
12:03:57 <matthew-> hekkaidekapus: yes, this is exactly the thing that I'm trying to straighten out in my head
12:04:28 <jle`> yeah, this is an unfortunate haskell namespacing thing that isn't unique to lists
12:04:36 <jle`> @let data MyType a = MyType a
12:04:38 <lambdabot>  Defined.
12:04:50 <geekosaur> it's not so different from: data Foo a = Foo | Bar a (Foo a)
12:04:57 <jle`> here we have MyType as a type construfctor, and also MyType as a data constructor
12:04:59 <jle`> whoops
12:06:17 <matthew-> yes, I'm just trying to figure out if I can implement type inference of lists as builtins without going the whole hog of ADTs and recursive types
12:08:09 <matthew-> if I add TypeApp then I guess I should really rework TypeArrow to be l -> r -> TypeApp(TypeApp(Const("->"), l), r)
12:08:22 <ski> you could probably special case any particular single (possibly recursive) algebraic data type, in a language you're designing
12:10:10 <matthew-> ski: well if I have empty list constructor and cons as builtins, then I think I can get away with just starting the type inference env with suitable types for both of those functions. I'm just trying to get clear how to actually represent list foo as a type
12:13:52 <ski> specify that empty list has elements of any type you like; and that non-empty list construction takes a value of some type and a list with elements of that type, and gives a list with elements of that type
12:14:52 * hackage hsdev 0.3.4.0 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.4.0 (AlexandrRuchkin)
12:15:58 <ski> to express the above in Haskell terms, given `data List a = Nil | Cons a (List a)', you specify that `Nil :: List a' and `Cons :: a -> List a -> List a' (where `a' is a type variable, `Nil' and `Cons' being polymorphic operations where `a' can be (consistently) replaced by any specific type)
12:16:38 <ski> matthew- : however, you'll presumably also want some way to do a case-distinction on whether a list is empty or not (and in the latter case, access the head element, and the tail list)
12:18:06 <matthew-> yes - I'm doing pattern matching too
12:18:28 <matthew-> presumably I just use normal inference and then unify the type of the pattern with the type of the expr
12:21:21 * hackage reflex-gadt-api 0.1.0.0 - Interact with a GADT API in your reflex-dom application.  https://hackage.haskell.org/package/reflex-gadt-api-0.1.0.0 (abrar)
12:25:59 <ski> matthew- : yea, should work (in absense of existentials, GADTs, higher-rank). while patterns are more restrictive than expressions, their (type, in this case) behaviour should correspond to each other, on the overlap
12:28:00 <hekkaidekapus> To go overboard, if more powerful patterns are needed, views could come into play. (But thatâs another can of worms :)
12:28:57 <matthew-> ski : cool. I guess it's more: for each fv(pattern), treat as Abs, so introduce new type var. Infer type of branch body, which will constrain these fresh vars. With that info, infer the type of the pattern. And then finally check the pattern type unifies with the case expression type
12:31:01 <matthew-> and yes, I'm definitely keeping this simple - no higher-rank types, GADTs or other madness ;)
12:32:50 <ski> you could infer the type of the branch pattern before the type of the branch expression
12:33:07 <ski> matthew- : HM ?
12:37:34 <ski> matthew- : btw, if you've not seen it, perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~amoeller/mis/typeinf.p(s|df)>,<https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493> could be interesting
12:40:57 <hekkaidekapus> matthew-: You can introduce a match construct which takes 2 argumentsâa pattern and a valueâand either fails or substitues variables in the pattern with values in the value.
12:42:32 <hekkaidekapus> How to define that construct is discussed in details in Types and Programming Languages.
12:42:41 <hekkaidekapus> @where TaPL
12:42:41 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
12:44:01 <ski> i sortof dislike view patterns ..
12:44:22 <hekkaidekapus> ski: Thatâs for me?
12:45:15 <hekkaidekapus> I was really going overboars: it is âviewsâ in the Idris sense.
12:45:25 <hekkaidekapus> *overboard
12:47:44 <matthew-> ski: (sorry, was afk). Yes, HM
12:48:15 <ski> i dunno the Idris sense
12:48:55 <matthew-> yeah, I have physical TAPL and ATTPL back from PhD days some years back...
12:50:03 <matthew-> ski: thanks for the paper pointer; reading now
12:51:18 <hekkaidekapus> ski: <https://paste.tomsmeding.com/ifpl4FiR>
12:52:44 <bqv> sequence behaves nicely with IO, right?
12:53:26 <ski> "nicely" means ?
12:53:52 <ski> hekkaidekapus : why the index ?
12:53:56 <bqv> i feel like there are gotchas somewhere
12:54:08 <bqv> but i can't imagine how
12:54:27 <bqv> if i'm talking nonsense, just means i'm overly paranoid. nevermind :)
12:54:41 <ski> it's not tail-recursive, if that's what you were wondering about
12:55:33 <bqv> having trouble figuring the implications of that
12:56:22 <dsal> Is there an easy way to get GHCI to run in a different Monad?
12:56:29 <ski> if you use it on a really long list, it'll use a lot of stack
12:56:37 <dsal> In particular, my own transformer stack over IO
12:56:57 <bqv> hm, ok
12:57:07 <geekosaur> dsal: there's a command line option
12:57:32 <ski> not afaik, dsal. i guess you might be able to do some wrapper on each invocation
12:57:43 <hekkaidekapus> ski: The index transforms input is some preferred forms which can then be inspected with âcovering functionsâ, another Idriss-ism. But I guess Iâm way off-topic now.
12:58:26 <ski> hekkaidekapus : i wonder whether that has any similarity to the (non-dependent) "active patterns" in F#
12:58:32 <dsal> hmm...  Yeah, running my own ghci would be kind of neat if I had an easy way to do that.  The way I'm doing it isn't hard enough.
12:58:58 <hekkaidekapus> ski: Unfortunately, I dunno F# ;)
12:59:26 <geekosaur> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function note that the type can be something other than IO, although the example is still in IO
13:00:01 <geekosaur> hm, not qute although it has that C a => so as long as it resolves to IO you're good to go
13:00:08 <geekosaur> so a stack over IO should work
13:00:23 <ski> i mean, you could make an `IORef S', and then a combinator that used that, having type `StateT S IO a -> IO a', updating, then wrapping each invocation in the interactor with that combinator
13:02:52 * hackage esqueleto 3.4.0.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.4.0.1 (parsonsmatt)
13:04:35 <ski> hekkaidekapus : it's like defining a set of complete, non-overlapping, pattern synonyms, using a single common definition that acts like a view pattern resulting in a corresponding data type with constructors being the alternatives
13:05:50 <hekkaidekapus> ski: hmmâ¦ The set still mirrors the canonic constructors?
13:06:13 <ski> no, could be any you like
13:06:33 <hekkaidekapus> In that case, thatâs like Idrisâ views then.
13:07:18 <hekkaidekapus> (With the non-dependent caveat, of course.)
13:10:05 <ski> there's two variants. one is defining an active pattern with just a single alternative, which can fail to match. the body will signal failure, by computing a `Maybe'. the other one is having a set of alternatives, and the single body will inspect the input value, do whatever branching (e.g. using conditionals) that it likes, and "return the alternative" that it elected should match
13:11:26 <ski> (ah, acually, there was also a non-failing single-pattern version. see <https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns>)
13:14:09 <hekkaidekapus> Those alternatives are the closest sibling to views in Idris. Now, to avoid syntactic clutter, there is a with builtin to choose which alternative to use when inspecting the input.
13:14:42 <hekkaidekapus> oh, oopsy. Meant to highlight with ;)
13:15:08 <hekkaidekapus> (And thanks for the URL, will take a look.)
13:23:56 <koz_> Where is the Data.Unique.Tag that dependent-map's docs refer to located?
13:24:00 <koz_> The link misses on Hackage.
13:26:38 <hekkaidekapus> koz_: <https://hackage.haskell.org/package/prim-uniq-0.2/docs/Data-Unique-Tag.html>
13:26:51 <hekkaidekapus> (Found by following the source.)
13:27:19 <koz_> Nice, thank you!
13:27:25 <hekkaidekapus> yw
13:29:07 <koz_> So if I were to use DMap with that Tag, I guess I need to have k ~ Tag s for some s?
13:29:09 <dsal> geekosaur: thanks for the link.  I should eventually do something useful here.
13:29:11 <koz_> What would be suitable for s?
13:30:17 <dsal> My yak was "I want to look at some of this data I've stored."  Data is JSON from an upstream API, except I removed a few fields that are huge and temporary.  Then the unmarshaling fails because they're required.  So I change how I remove them.  Then I want to make a lens through the marshaled data and realized I don't have a marshalerâ¦
13:30:27 <dsal> I'm not sure what I *started* doing, but I found a bunch of things I can make better.
13:31:26 <fresheyeball> how do I explicitly import a pattern?
13:31:30 <fresheyeball> I can't figure it out
13:31:39 <koz_> fresheyeball: import Foo.Bar (pattern Baz)
13:31:48 <koz_> You have to have PatternSynonyms on.
13:32:19 <fresheyeball> oh odd
13:32:31 <fresheyeball> ok yeah, if I have the language pragma on in the importing file I can import explicitly
13:32:42 <koz_> Yeah, that caught me out recently too.
13:32:42 <fresheyeball> but if I have it off, I can only import impplicitly 
13:41:52 <tomjaguarpaw> Hedgehog checkParallel runs the tests in parallel in ghci but not in a compiled program. Am I doing something obviously wrong?
13:47:42 <koz_> tomjaguarpaw: Did you build with -threaded and tell the RTS to use all your cores?
13:56:24 <tomjaguarpaw> Ah, that does the trick, thanks
13:56:43 <tomjaguarpaw> Strangely though the wall clock time is not reduced, despite it running the tests in parallel
13:57:35 <Axman6> Welcome to the joys of parallelism
13:58:03 <tomjaguarpaw> That's strange. What's the overheard then?
13:58:38 <tomjaguarpaw> I wonder if it's the Hedgehog code that renders the output
13:58:41 <tomjaguarpaw> It updates a *lot*
13:59:10 <Axman6> it would depend on your program. it could be GC - try running it without parallel GC. Also try running with +RTS -s (I think, see +RTS --help for all the optiosn) to get a report from the RTS on things like productivity
14:01:26 <Axman6> lots of tiny tests are unlikely to get much speedup from parallelism with other overhead, it could very well be the hedgehog coordination. feel free to share some code
14:02:11 <tomjaguarpaw> Thanks, says 1.2s GC and 1s MUT
14:02:26 <Axman6> looks like GC then. there are eays to reduce that though
14:02:41 <Axman6> like judt making it allocate a big enough heap it doesn't need to GC
14:02:42 <tomjaguarpaw> Productivity 45.4% of total user
14:02:49 <Axman6> that's pretty bad
14:03:04 <Axman6> stop making so much garbage!
14:03:27 <tomjaguarpaw> Hah, I'm doing 10k random samples for each of about 15 property tests
14:03:53 <tomjaguarpaw> 1.6 GB allocated on the heap, so I guess I can make the heap big enough
14:05:29 <tomjaguarpaw> GC is now 0.375s but MUT is now 2.2s!
14:05:36 <tomjaguarpaw> I don't even understand what MUT si
14:05:45 <tomjaguarpaw> Perhaps something in Hedgehog is doing mutation
14:07:13 <tomjaguarpaw> Well they run fast enough anyway. I was just confused. Thanks Axman6 and koz_
14:07:56 <koz_> Axman6: How does one disable parallel GC again?
14:08:35 <Axman6> there's a flag... >_>
14:08:39 <hekkaidekapus> koz_: ghc -qg
14:08:41 <Axman6> I don't remember, I've never done it
14:08:55 <koz_> hekkaidekapus: Thanks!
14:09:22 * hackage gopro-plus 0.4.1.2 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.4.1.2 (dustin)
14:10:11 * hekkaidekapus waves at dsal.
14:10:33 * dsal uploads GoPro footage of yak shaving
14:10:51 <hekkaidekapus> lol
14:11:09 <dsal> I think my actual motivation was "I saw a thing on optics yesterday, so I want to at least touch a lens."
14:11:30 <hekkaidekapus> dsal: changelog: Unreleased changes ;)
14:12:06 <dsal> The lens that allows me to manipulate data within a JSON blob of a known type is kind of neat, though.
14:12:25 <dsal> Yeah, ...1 to ...2 just added a few instances.  I guess I could've mentioned that.
14:12:33 <dsal> I don't feel like I've added all the instances, though.
14:13:17 <hekkaidekapus> Did you switch to optics or you did some lensy stuff?
14:13:44 <dsal> I'm still using lens.
14:14:28 <hekkaidekapus> Ah, cheers! (Just saw the commit.)
14:14:29 <dsal> I just made a lens on a thing that comes out of the DB as a ByteString where I can manipulate the structured that ByteString represents.
14:15:58 <dsal> It's not stuff I *need* to do, but stuff I'd like to be able to do someday.      dbresult & someblob . variations . whatever ?~ "stuff"
15:11:07 <nshepperd> using lenses for text manipulation is fun
15:14:26 <nshepperd> i made a little library with functions like: take a parser and return a traversal of each matching substring
15:18:52 * hackage Win32 2.10.1.0 - A binding to Windows Win32 API.  https://hackage.haskell.org/package/Win32-2.10.1.0 (TamarChristina)
15:26:30 <Axman6> nshepperd: link? that sounds familliar
15:27:00 <Axman6> lens-regex is super cool too
15:27:39 <nshepperd> it's not anything i uploaded
15:27:47 <nshepperd> maybe i should tho
15:36:26 <bqv> d.nnr
15:37:05 <bqv> is it possible in any context to use foreign imports in typeclass instances?
15:37:23 <bqv> (without resorting to templatehaskell, which is probably pretty heatheny :D)
15:37:28 <glguy> The foreign imports will be top-level definitions
15:37:50 <glguy> you can then use the identifiers declared there in your instance declarations
15:38:08 <bqv> so that's a no
15:38:22 * hackage massiv-io 0.4.0.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.4.0.0 (lehins)
15:38:42 <bqv> was hoping for a type parameter'd foreign import
15:39:01 <bqv> actually, might still be able to...
15:39:10 <bqv> who likes void pointers...
15:40:35 <monochrom> I don't see any limitation apart from barely inconvenient syntax.
15:49:42 <xe4> where can I ask questions about using stylish-haskell with my text editor?
17:01:00 <fresheyeball> \q
17:24:28 <Axman6> xe4: asking here is fine, but I can't guarantee you'll get a good answer
17:58:06 <bollu> What are the precise semantics of bang-patterns? Consider |let foo' = let !x = error "ERR" in \y -> y|. Can GHC reduce this to |let foo' = \y -> y|
17:58:22 <jcowan> Why are there so few instances of class Map?  Or am I just not seeing them in Hoogle?
17:59:14 <koz_> jcowan: Wait, _class_ Map?
18:00:22 <jcowan> koz_: https://hackage.haskell.org/package/collections-api-1.0.0.0/docs/Data-Collections.html#g:4
18:00:32 <koz_> Ah, OK. TIL.
18:01:41 <jcowan> but apparently type Map is the only instance.  You'd think a list of pairs would be an instance too.
18:02:28 <jcowan> I guess it's because it doesn't meet the (informal) big-O constraints
18:02:49 <koz_> jcowan: You can do something like 'newtype AssocList (k :: Type) (v :: Type) = AssocList [(k,v)]', then write an instance against that?
18:03:52 <jcowan> hmm, no, there are no O(...) constraints
18:04:35 <jcowan> But yes, that makes sense, I'm just surprised it's not already the case.
18:08:22 <Axman6> I've never heard of that package, why do you believe it's something you should care about?
18:08:33 <Axman6> is it used by anything?
18:08:58 <jcowan> No idea.  What I'm investigating is whether the whole idea of a map class actually makes sense or not.
18:14:20 <davean> lens kinda has a Map class, in pieces
18:23:10 <dolio> Pieces is probably better anyway. I'm not sure you want a huge class with all the things you can do with a map.
18:39:46 <davean> dolio: I agree, I expect jcowan will find its not by chance that package isn't well known or maintained
18:40:43 <davean> Decomposed heirarchies with sensible laws for piece piece and addition work very well and are more general.
18:46:48 <c_wraith> What is the breakdown for Map, roughly?  At + Foldable?
18:49:18 <c_wraith> well, I guess you have all of Traversable if you want it
18:49:58 <c_wraith> That misses out on things like the union/intersection operators, but does lens have stuff for those?
18:52:43 <c_wraith> I guess I could just read https://hackage.haskell.org/package/lens/docs/Data-Map-Lens.html
18:53:13 <c_wraith> Nothing appears to directly address union/intersection stuff
18:53:43 <ddellaco1> it's very strange how I'm just now trying to figure out how to use lens with Maps, and I come here and everyone is talking about it
18:54:42 <ddellaco1> in particular how to manipulate the keys. Didn't occur to me to look at Data.Map.Lens, thank you
19:00:35 <jcowan> Map should be a Set (of assoociations)
19:04:45 <dolio> That sounds like something that would show up in Oleg's examples of violations of the Liskov principle.
19:07:41 <monochrom> Instead, Set is a special case of Map: Set X is Map X ()
19:08:30 <monochrom> That is, comparing Set operations with Map operations.
19:25:53 * hackage tonatona 0.1.2.1 - meta application framework  https://hackage.haskell.org/package/tonatona-0.1.2.1 (qnoyxu)
19:27:22 * hackage tonalude 0.1.1.1 - A standard library for Tonatona framework.  https://hackage.haskell.org/package/tonalude-0.1.1.1 (qnoyxu)
19:28:22 * hackage tonatona-servant 0.1.0.4, tonatona-persistent-sqlite 0.1.0.2, tonatona-persistent-postgresql 0.1.0.2, tonatona-logger 0.2.0.2, tonaparser 0.1.0.1 (qnoyxu)
19:33:50 <Axman6> ddellaco1: http://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-At.html is probably what you want to use
19:34:35 <justsomeguy>  Out of (idle) curiosity, is there a language extension to add syntax support for first-class sets and maps, like python has? The closest thing I'm aware of is OverloadedLists, but being able to write something like {1:"this",2:"that"} is really nice.
19:35:01 <Axman6> I thnk overloaded lists with tuples is as close as it gets
19:35:28 <sshine> justsomeguy, you can make a quasi quoter? ;)
19:35:33 <Axman6> % [(True,"Hello"),(False,"bye")] :: Map Bool String
19:35:34 <yahb> Axman6: ; <interactive>:75:35: error:; Not in scope: type constructor or class `Map'; Perhaps you meant one of these: `M.Map' (imported from Data.Map), `Max' (imported from Data.Semigroup)
19:35:41 <Axman6> % [(True,"Hello"),(False,"bye")] :: M.Map Bool String
19:35:41 <yahb> Axman6: ; <interactive>:76:1: error:; * Couldn't match expected type `M.Map Bool String' with actual type `[(Bool, [Char])]'; * In the expression: [(True, "Hello"), (False, "bye")] :: M.Map Bool String; In an equation for `it': it = [(True, "Hello"), (False, "bye")] :: M.Map Bool String
19:35:51 <justsomeguy> Well, it's still pretty good. I guess Haskell compensates by not needing so much syntax in other places. -- wait, quasiquoters can do that?
19:36:00 <Axman6> % :set -XOverloadedLists
19:36:01 <yahb> Axman6: 
19:36:03 <Axman6> % [(True,"Hello"),(False,"bye")] :: M.Map Bool String
19:36:03 <yahb> Axman6: fromList [(False,"bye"),(True,"Hello")]
19:36:42 <Axman6> justsomeguy: quasi quoters are basically just functions from String to Haskell
19:37:07 <sshine> justsomeguy, I don't think you'd like that. you could make it so that you have [map|{a: 1, b: 2}], but I'd question the trade-off.
19:37:20 <Axman6> so you could have [map|{foo: True, bar: 7}|] but it's pretty ugly IMO
19:37:49 <Axman6> you could I guess just do [map|foo: True, bar: 7|]
19:37:57 <ddellaco1> Axman6: thanks. I ended up just doing some fmap ugliness for the time being, going to revisit tomorrow
19:38:00 <sshine> justsomeguy, there is some technical trade-off, but the big trade-off, I think, is you're not really coding Haskell. :-P
19:38:43 <justsomeguy> Hmm, maybe this is something that I should be solving with an editor macro, instead.
19:39:28 <justsomeguy> (Or not solving at all, since it's not a big deal :^p)
19:39:40 <Axman6> % let a ==> b = (a,b)
19:39:40 <yahb> Axman6: 
19:39:45 <dolio> It seems like OverloadedLists is completely adequate.
19:40:00 <Axman6> % [True ==> "Hello", False ==> "bye"] :: M.Map Bool String
19:40:00 <yahb> Axman6: fromList [(False,"bye"),(True,"Hello")]
19:40:34 <sshine> justsomeguy, you could do a similar reasoning with regexes. Perl has $x =~ m/(foo)*/ syntax and in Haskell the nicest alternative (I think) is regex-applicative which is more like 'many (string "foo")' -- so takes up more space, but the style is combinator composition.
19:41:30 <sshine> justsomeguy, wrt. Maps and syntax support, if you already accept the syntactic weight of composing combinators, is just 'fromList' and the many parentheses around tuples.
19:42:38 <justsomeguy> Right, it's not bad at all.
19:42:59 <sshine> justsomeguy, and if you think 'fromList' is too heavy, OverloadedLists can remove it. but you'd still want a syntactically consistent way to address the remaining values in a way that is similar to how you adress other things.
19:43:08 <sshine> justsomeguy, it depends on the perspective.
19:43:38 <sshine> justsomeguy, combinators aren't always the shortest. but the benefit of being able to compose things is so high.
19:46:30 <texasmynsted> I am not really sure how to search for or even describe what I am looking for... Is there something I can use to "grep" a bunch of files for a token using a parser like megaparsec or something rather than regexp?
19:46:36 <sshine> justsomeguy, e.g. in Perl if you want to combine two regexes, you need to be aware of not accidentally embedding user-input strings into your regex, since Perl regexes are a bit too powerful (e.g. allow general recursion and exponential compute holes, since they're not regular).. so m/$regex1$regex2/ is fine as long as $regex1 and $regex2 weren't dirty. if anything is dirty you want \Q$dirtybit\E. with 
19:46:42 <sshine> regex-applicative I'm not familiar with a way to make those accidents.
19:47:06 <Axman6> texasmynsted: well, there is https://hackage.haskell.org/package/lens-regex-0.1.1/docs/Text-Regex-Lens.html...
19:47:29 <texasmynsted> that sounds like it uses regexps
19:47:34 <Axman6> it does
19:48:01 <Axman6> I'm sure I've seen something which does a similar things
19:48:11 <texasmynsted> I was looking for an alternative to regexps. (I do not think regexps are easy to read, maintain, or debug.)
19:48:27 <sshine> texasmynsted, regex-applicative / Megaparsec? :)
19:48:31 <Axman6> https://hackage.haskell.org/package/replace-attoparsec?
19:48:45 <texasmynsted> I am looking for a token in the YAML header of markdown files.
19:48:47 <sshine> Axman6, neat.
19:49:17 <texasmynsted> oh intersting. 
19:49:18 <sshine> texasmynsted, like a tag or something?
19:49:34 <texasmynsted> yes. like "isUnpublished=true"
19:50:17 <texasmynsted> like I have a bunch of markdown files. Some I do not want published so I want them added to an exclude list for rsync
19:50:23 <Axman6> Can't decide is this is cool or gross: streamEditT (char '{' *> manyTill anyChar (char '}')) (fmap T.pack . getEnv) "- {HOME} -"
19:52:02 <sshine> > "isUnpublished=true" `isInfixOf` "I'm not sure what a token in the YAML header of a Markdown file looks like, but if it contains isUnpublished=true, maybe this qualifies?"
19:52:04 <lambdabot>  True
19:53:03 <texasmynsted> YAML header starts with --- and ends with ---
19:53:09 <texasmynsted> At the top of the file
19:53:25 <Axman6> this sounds like you could just use pandoc
19:53:34 <Axman6> "just"
19:53:43 <texasmynsted> maybe but I am trying to get a list of files.
19:53:45 <sshine> "one does not just..."
19:53:48 <Axman6> I mean you're describing a format pandoc knows about
19:54:43 <texasmynsted> Pandoc seems well suited to filtering/altering/rendering markdown files, but I am not sure how to get it to just search for tokens and add or not a file name to a list
19:55:12 <texasmynsted> I could convert each file to the AST then search the AST, then ?
19:55:24 * texasmynsted hoogles `isInfixOf`
19:56:43 <texasmynsted> oh. isInfixOf is usef.
19:56:49 <texasmynsted> I mean useful
19:57:34 <sshine> if you want to build a mostly sufficient Markdown header parser, but not pull out a big gun, ask yourself how little you can get away with. isInfixOf won't let you blog about what you're doing right now. :-P
20:09:57 <texasmynsted> I think that finding the token is less the issue. More of the issue is searching all the files.
20:10:52 <Axman6> if you can search one file, and you can get all the file names, then you just traverse
20:16:31 <sshine> texasmynsted, https://gist.github.com/sshine/4e8673ad48b3f6098e4dbe097a9dfe5f
20:17:15 <texasmynsted> WOW! Thank you!
20:17:30 <texasmynsted> Now I understand. :-)
20:17:44 <justsomeguy> That is very nice and easy to read, even for a noob like me.
20:18:14 <sshine> it started as a one-liner so I could paste it on IRC.
20:18:33 <Axman6> yuno bytestring
20:19:06 <sshine> Axman6, good point, thanks.
20:19:50 <pjb> perhaps I would use isPublished instead, to avoid double-negativesâ¦
20:20:43 <Axman6> texasmynsted: just becareful that you don't write a blog post about this and forget to publish the file because you have the string "isUnpublished=true" in it :P
20:20:59 <texasmynsted> LOL
20:21:07 <koz_> isUnpublished=false is _definitely_ likely to lead to confusion.
20:21:40 <texasmynsted> preventPublish: true
20:22:11 <sshine> pjb, good idea :) except I don't know if "isUnpublished=true" is the same as "isPublished=false" :-D
20:22:25 <Axman6> I worked at a place which had a script that could update itself, and its check to see if it had downloaded a complete file was to check if it had a specific string, which was placed at the end of the file
20:22:50 <Axman6> the way it checked that was to just grep for... that string... inside the file that was doing the update
20:23:08 <sshine> koz_, yeah, I'd definitely stick to assuming that things aren't published by default, and I have to put "isPublished=true"... it seems that publishedness is a property, whereas unpublishedness is more like the absence of a property.
20:23:19 <Axman6> so you had ... grep COMPLETEFILE thefile... #COMPLETEFILE <EOF>
20:23:34 <Axman6> so, if it downloaded enought o pass the grep line, it would pass the test
20:23:46 <koz_> texasmynsted: notFitForHumanConsumption=true
20:24:04 <Axman6> literally any other regex given to grep that matched would have made it ok
20:26:05 <sshine> texasmynsted, if you ever start wondering "Hey, why do I put all my files into linked lists of single characters?", you can reload the page.
20:26:06 <pjb> Axman6: its a classic; you can do it by not using the target string in the regexp, but a regexp that matches it, such as:  grep -e '[C]OMPLETEFILE' "$0"
20:26:11 <justsomeguy> Hmm... It's interesting how that is. I had to debug a script that had a ton of checks that something is not true (if ! [ condition ]; then .. ; fi), and even though I was expecting it the negation, I found it hard to read because I instinctively assumed the condition was checking for True -- had to do a double take every time.
20:26:25 <Axman6> pjb: yep, exactly
20:26:45 <sshine> texasmynsted, (the only difference is "BS." and some import/overloading machinery)
20:27:31 <sshine> pjb, [h][e][h][e].
20:27:55 <pjb> or even '\h\e\h\e'
20:27:56 <texasmynsted> lol
20:28:18 <sshine> TCL has a pretty decent regex implementation.
20:28:59 <sshine> it's powerful yet not unreasonable. and the library functions around it are actually useful. unfortunately, in TCL, everything is a string.
20:29:02 <Axman6> is Haskell89's type system turing complete?
20:29:10 <texasmynsted> :-)
20:29:13 <c_wraith> No
20:31:32 <dsal> I'm super happy to ~never use regex.
20:32:13 <Axman6> nah they're great in text editors
20:32:23 <Axman6> but should never be in code
20:32:39 <dibblego> and text editors are not great
20:33:00 <texasmynsted> I do not like regexp. I only use them when I must.
20:33:04 <sshine> dsal, $you =~ m/never/ use regex?
20:33:24 <texasmynsted> Thanks again sshine 
20:36:38 <dsal> Axman6: Oh, yeah, that's a good point.  I do occasionally use them to find stuff with my editor or grep or whatever.  Just not in programs.
20:37:06 <Axman6> I've always wanted lenses over haskell courde to use in a text editor
20:38:09 <sshine> dsal, I went to buy a drill hammer at the hardware store since my percussion drill wasn't cutting through. the salesman wanted to sell me one that shared a battery type with a very good electric screwdriver, because, you know, screwing in things using a percussion drill is... reckless. yet, that is what I do because I'd rather hold two oversized powertools when I am dancing on a ladder two oversized 
20:38:12 <dibblego> aka, an editor without the strings!
20:38:15 <sshine> powertools plus an appropriately sized one.
20:39:09 <dsal> A regex isn't an oversized powertool.  It's the sawzall you use for everything because it's all you have.
20:39:11 <sshine> s/(?<=ladder )/rather than /
20:39:23 <dsal> My neighbor was trying to cut up a tree with his sawzall.  Awful time he had.
20:39:31 * Axman6 wants to know what a drill hammer is
20:39:53 <sshine> Axman6, it's a small jackhammer for concrete walls and ceilings.
20:40:06 <MarcelineVQ> hammer drill :>
20:40:12 <sshine> Axman6, it punches and doesn't drill.
20:40:38 <sshine> Axman6, a percussion drill does both, but it doesn't punch as hard.
20:41:05 <sshine> so if you ever move into a solid concrete building and want to put up anything on your wall, you may need a drill hammer.
20:42:21 <dsal> I like having the right tool for the job.  I have a tiny chopsaw specifically for cutting brass casings into smaller brass casings. https://usercontent.irccloud-cdn.com/file/WU4zyLxR/minichop.jpg
20:42:27 <dsal> When I need to parse stuff in Haskell, I pretty much just use megaparsec.  Sometimes attoparsec.  Rarely read.  I used regexes once and ended up regretting it (but learning proper parsers).
20:42:37 <sshine> percussion drills often let you choose "punch, punch and drill, drill only" and the "drill only" works perfectly as an overweight, trigger-happy electric screwdriver.
20:42:58 <sshine> in this scenario, Megaparsec is the percussion drill.
20:43:39 <sshine> dsal, I'd use a percussion drill for that. haha, j/k.
20:44:20 <dsal> Heh, I used a dremel to do that once, free hand.  It technically worked.  But that was really dumb.
20:48:11 <sshine> dsal, I used regex-applicative once to see how a very regex-like task would look like. and then I re-did it with Megaparsec, and it seemed nothing significant was gained. https://dev.to/piq9117/haskell-enforcing-naming-convention-with-parsec-1f2h#comments -- but regex-applicative is a nice library nonetheless.
20:48:30 <MarcelineVQ> sshine: around here you'd call a percussion drill a hammer drill, you're describing a rotary hammer though yeah? humans aren't so hot at creating discerning names :O
20:48:33 <sshine> s/gained/gained from using regex-applicative in the first place/
20:49:58 <sshine> MarcelineVQ, I'm using google translate. in my language "borehammer" = drill hammer = its main feature is that it punches, in spiute of "drill" being a part of its name. I guess "drill" refers to the long, thin shape of the thing that punches, rather than the action.
20:50:44 <dsal> sshine: That's kind of weird.  It doesn't look like a regex language.
20:51:41 <sshine> MarcelineVQ, whereas "slagboremaskine" = percussion drill = its drilling function is strong, and its punching function is weak, and combined you get through a lot of materials without wrecking them (e.g. bricks, but it's too crude for bathroom tiles and too weak for concrete).
20:53:09 <MarcelineVQ> so literal :> slag bore mchine
20:53:13 <sshine> dsal, the meat of the task is pretty much exactly the same in regex-applicative and megaparsec.
20:53:29 <sshine> MarcelineVQ, haha yes, this is a good name. punch drill machine.
20:53:31 <dsal> Yeah, both seem like fine ways to do parsing.
20:54:01 <sshine> dsal, yeah. and sometimes you realize, "shit, what I'm doing is not regular." and it'd be neat if all you had to do was break out of applicative style, but not switch library. :-P
21:05:54 <sshine> dsal, I think that regex gets a bad rep for the classical syntax. regex-applicative unscrews that a bit (in spite of not really being that useful in a lot of cases). another example where I think something built on top of just regex (leveraging the limit) is Kleenex: https://github.com/diku-kmc/kleenexlang#use
21:06:23 <sshine> that last sentence missed a superlative.
21:50:00 <ten>  /Help
22:40:23 * hackage shakebook 0.13.1.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.13.1.0 (locallycompact)
22:50:23 * hackage gopro-plus 0.4.1.3 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.4.1.3 (dustin)
22:57:52 * hackage shake-plus 0.3.3.1 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.3.3.1 (locallycompact)
23:38:34 <scasc> I was doing a quick search on both Wikipedia and haskell.org (including the wikis), but couldn't find a good tabulated overview of GHC versions with release dates (and ideally with corresponding "base" library version numbers).
23:39:16 <scasc> Do you know of a good overview of release dates? (I have an idea where I could compile it from, but I'd appreciate not having to do it myself :-)
23:43:03 <yushyin> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history
