00:29:23 * hackage futhark 0.18.3 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.18.3 (TroelsHenriksen)
00:30:37 <daydaynatation> cabal install gtk -f have-quartz-gtk, what does the -f mean?
00:30:52 <c_wraith> it sets a flag
00:31:36 <c_wraith> the cabal file uses the flag in conditionals that can affect lots of things.  in this, most likely the native dependency
00:31:51 <daydaynatation> I see.
00:32:03 <c_wraith> I'd take that flag to mean it's the quartz version of gtk, rather than the X version
00:32:25 <c_wraith> (because even on OS X, you can run an X server and build GTK for X)
00:32:53 <daydaynatation> I've successfully build and installed gtk with the above command
00:33:23 * hackage ghc-exactprint 0.6.3.3 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.3.3 (AlanZimmerman)
00:33:26 <daydaynatation> but when I try cabal install threadscope which requires gtk, it not only requires me to build gtk again, but it also failed
00:36:27 <merijn> Oh, let me guess you have cabal-install 3.0 or later?
00:37:46 <merijn> See, this why we should've banned feature flags from Hackage years ago to stop people from building things that are just cursed and broken >.>
00:39:28 <daydaynatation> merijn: yes, version 3.2
00:42:14 <merijn> daydaynatation: You are getting hosed by gtk abusing things in ways they're not supposed to and that accidentally working for years...
00:43:09 <merijn> daydaynatation: Try the following: clone threadscope from github, change directory to it, then use "cabal install --projectfile=cabal.project.osx"
00:45:54 <merijn> daydaynatation: Essentially, flags were never intended to and shouldn't affect the public API/build setup of packages, but people abuse them for that anyway. Which worked fine in old cabal-install's because it would use "whatever version was already installed" (like the gtk you installed just now). But in >3.0 the buildplan doesn't depend on what's already installed
00:49:22 <tomsmeding> can't you tell cabal to set a flag on some particular package in the dependency tree?
00:49:37 <merijn> tomsmeding: In cabal.project, yes. Not in your cabal file
00:49:42 <tomsmeding> ah right
00:49:44 <merijn> tomsmeding: And that is intentional
00:50:05 <merijn> So people can't use flags to control what feature/API is exposed
00:50:09 <tomsmeding> to be fair, is there another way for packages like gtk to have public "parameters"?
00:50:13 <merijn> But, of course, that's not stopped anyone
00:50:43 <merijn> tomsmeding: Make a core library that's wrapped by gtk-quartz and gtk-x11
00:51:16 <merijn> Also, the (now mostly stalled) work on backpack
00:51:16 <tomsmeding> because this feels like a so-called desire path :p
00:52:15 <merijn> tomsmeding: You need to invert your interface so instead of conditionally depending on something you wrap. See persistent and the various persistent-postgres, persistent-sqlite, etc. wrappers
00:52:28 <merijn> Selda does the same, diagrams does that
00:52:37 <tomsmeding> yeah I've seen the pattern
00:52:45 <benschza> Good morning everyone! I've been exploring Arrows and Yampa, and have reached a type error that I'm struggling to interpret. The resulting type seems so close, but I'm using this as a project to continue learning Haskell, so I'm in the deep end. `Expected type: SF (SF () State) (Event (SF () State))` and `Actual type: SF State (Event (SF () State))` - here's a gist: https://gist.github.com/BenSchZA/57f1f46ec8e2ecc0f304ede813e5f4eb I think my 
00:52:46 <benschza> question is two fold, what am I missing, and how can I improve my translation of Arrow proc notation into pure Arrow notation. Appreciate any guidance!  
00:53:29 <merijn> benschza: I think there's, like, a handful of people who actually know/understand Arrow notation :p
00:53:52 * hackage phonetic-languages-constaints 0.3.0.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constaints-0.3.0.0 (OleksandrZhabenko)
00:54:34 <merijn> tomsmeding: The only other option is to modify Cabal to allow people to specify constraints on their *transitive* dependencies, which is clearly a nightmare 
00:55:09 <tomsmeding> benschza: this is probably ghc doing type inference and showing the error far from where it actually occurred. Suggestion: add lots of manual type signatures on your intermediate values, and see where it doesn't match up with reality
00:55:47 <tomsmeding> merijn: indeed that would be interesting if you have two dependencies A and B that both depend on different configurations of a single package C
00:55:53 <benschza> tomsmeding: Thanks! I'll give that a try.
00:56:08 <[exa]> benschza: btw if you didn't use a type hole yet, now is the time :]
00:58:02 <benschza> [exa]: I'll have to Google that :) Thanks for the pointer.
00:58:13 <merijn> tomsmeding: In the end, I understand why the desire path is there, but some things are required/blocked for a reason, see also: people complaining about needing to write out module lists, people complaining about maintaining upperbounds, etc.
00:58:42 <tomsmeding> true enough
00:58:45 <merijn> As always, these problems are "trivial" if you just throw long term stability/usability under the bus
00:59:06 <merijn> But if you think about how things should work long term, it just can't work
00:59:16 <[exa]> benschza: basically you add ` :: _  ` after anything and the compiler reports on what it thinks should be in place of the _
00:59:41 <[exa]> (same for values)
01:07:01 <daydaynatation> merijn: cabal complain that it doesn recognize --projectfile=...
01:07:12 <daydaynatation> is it the right flag? I checked ont he user guide, couldn't find
01:07:15 <merijn> oh, maybe it's --project-file?
01:08:12 <daydaynatation> thx
01:20:17 <maerwald> was there a cabal helper tool that bumps version bounds of your package?
01:20:55 <merijn> I think someone was working on one at some point?
01:21:33 <maerwald> https://hackage.haskell.org/package/cabal-bounds
01:30:57 <dminuoso> Is there a safe variant of fromIntegral anywhere?
01:31:16 <dminuoso> I need runtime verification, not static.
01:31:35 <merijn> dminuoso: I recommend a strong whisky and crying :)
01:32:02 <maerwald> Glendronach 21
01:32:19 <merijn> Sadness goes better with Islay
01:32:25 <dminuoso> maerwald: Does that go well with Cola or better in tea?
01:32:29 <maerwald> dude
01:32:39 <merijn> dminuoso: I know you're joking and I'm still mad
01:33:03 <dminuoso> merijn: I have quite a few whiskey fans, it triggers them every time. ;)
01:33:31 <dminuoso> Or *whisky I guess
01:33:31 <merijn> Whisky cola is fine, but just use shitty whisky >.>
01:33:38 <maerwald> so you're a whisky?
01:34:00 <merijn> Good whisky in cola ruins both your whisky and your cola (and your wallet) :p
01:34:03 <dminuoso> Maybe the problem is that whisky connoisseurs don't use high quality cola for mixing their whisky.
01:34:26 <[exa]> "high-quality cola" please elaborate
01:34:33 <dminuoso> On a slightly more serious note, Im pondering getting these "cooling stones" for whisky.
01:34:40 <dminuoso> But not for cooling it, but for heating rum.
01:35:14 <dminuoso> Getting rum up to 25-28 degrees brings out quite a few flavors
01:35:31 <merijn> I recommend we move this to offtopic :p
01:35:35 <dminuoso> Indeed.
01:40:53 * hackage polysemy-extra 0.1.3.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.3.0 (locallycompact)
01:51:01 <dminuoso> merijn: on a more serious note, am I expected to just manually compare with maxBound?
01:51:20 <dminuoso> Why is there no freaking numeric conversion with error handling in base?
01:51:51 <dminuoso> Is it just assumed that narrowing cant possibly happening? Or that when it happens, its semantics (what are they?) are obviously what you want?
01:51:55 <merijn> dminuoso: On a more seriouse note, I had to handroll it and you get awkward conversion too
01:52:14 <dminuoso> Dont people ever deal with numbers? :(
01:52:26 <dminuoso> Im so close to just use Integer everywhere.
01:52:28 <merijn> dminuoso: I welcome any suggestions/things in GHC that improve this
01:52:51 <merijn> dminuoso: It's somewhere down on my yak shaving list
01:57:52 * hackage phonetic-languages-constraints 0.3.0.1 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constraints-0.3.0.1 (OleksandrZhabenko)
02:05:53 * hackage polysemy-extra 0.1.4.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.4.0 (locallycompact)
03:09:22 * hackage phonetic-languages-constraints 0.3.1.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constraints-0.3.1.0 (OleksandrZhabenko)
03:38:18 <trcc> Hi. I am trying to figure out why the haskell visual studio code extension fails to detect my stack installation. I have just followed the very initial steps of "Start your new project" here: https://docs.haskellstack.org/en/stable/README/. WHen I open the folder in vscode then I get: "ghcide: unable to load package `ghc-prim-0.5.3` compiler [1,1]". Any ideas? 
03:39:30 <benschza> [exa] and tomsmeding: thanks to your pointers I got the types right for the Arrows/Yampa problem.
03:41:23 * hackage phonetic-languages-examples 0.4.0.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.4.0.0 (OleksandrZhabenko)
04:15:00 <nshepperd2> > fromIntegral 12345678 :: Word8
04:15:02 <lambdabot>  78
04:17:05 <Taneb> This is because 12345600 = 256 * 48225 and Word8 wraps
04:21:38 <nshepperd> seems reasonable
04:24:21 <Taneb> Dumb idea: Word6.644ish, that wraps at 100
04:26:53 * hackage phonetic-languages-constraints 0.3.2.0 - Constraints to filter the needed permutations  https://hackage.haskell.org/package/phonetic-languages-constraints-0.3.2.0 (OleksandrZhabenko)
04:32:16 <nshepperd> heh
04:38:23 <pjb> nshepperd: seems idiotic. That's how you destroy rockets.
04:39:09 <merijn> pjb: Well, what do you propose, then
04:39:22 <pjb> bigints.
04:39:34 <merijn> That seems rather unrelated
04:39:47 <pjb> yeah‚Ä¶
04:40:22 <pjb> It should signal an error.
04:41:57 <merijn> Feel free to define proper semantics for that
04:42:03 <merijn> Many people have tried and failed :)
05:01:53 * hackage vulkan-utils 0.1.3 - Utils for the vulkan package  https://hackage.haskell.org/package/vulkan-utils-0.1.3 (jophish)
05:07:34 <xerox_> will ghc run on the arm macs straight away?
05:08:27 <merijn> Who knows
05:08:40 <jophish> do the GHC team have one of the dev boxeS?
05:08:48 <merijn> Probably not
05:09:12 <merijn> ARM has tier 2 support, currently, iirc
05:10:36 <merijn> So the answer to "will GHC run on ARM macs?" is "that depends how much effort you will contribute to that cause" ;)
05:12:03 <merijn> I know angerman is doing a lot of stuff w.r.t Aarch64 support in GHC
05:13:01 <angerman> xerox_: yes; jophish: yes, I have a DTK on my desk.
05:13:33 <angerman> xerox_: you can use rosetta2, ghc works well enough to build a native ghc.
05:14:09 <angerman> here's a fully native, GHC-9.1 with an arm64 NCG: https://dl.dropbox.com/s/jskw2pjpkhquj4g/ghc-9.1.0.20201110-aarch64-apple-darwin.tar.xz
05:14:38 <jophish> I wonder how the code signing thing is going to impact nixos
05:14:43 <angerman> We'll likely need a bit of time to get this (a) merged into master, (b) backported into 9.0 and maybe earlier.
05:15:13 <angerman> jophish: it's ok. thefloweringash and I did test, and manage to produce identical binaries. However "nixos" and darwin don't mix well :p 
05:15:22 * hackage apecs-stm 0.1.4 - STM stores for apecs  https://hackage.haskell.org/package/apecs-stm-0.1.4 (jonascarpay)
05:15:25 <angerman> darwin + nixpkgs, will need some more work, but we'll get there.
05:15:46 <jophish> I guess you had to share a key?
05:16:00 <angerman> no. adhoc signatures don't need keeys.
05:16:15 <jophish> oh, so they always use the same key
05:16:38 <angerman> it's just some integrity hash.
05:16:42 <jophish> right
05:17:02 <angerman> I think thefloweringhash did provide some more details in the nixpkgs comments on the issue.
05:17:26 <angerman> if you want to use GHC or nix right away on an arm64 mac, maybe hold off for at least a month.
05:17:35 <angerman> it's possible, but it's going to be painful.
05:17:46 <jophish> heh, I'm probably not getting a mac again any time soon
05:17:57 <angerman> your loss :p 
05:18:10 <Uniaika> that being said there is Rosetta right?
05:18:13 <angerman> apple sg doesn't seem to want to sell M1 mac minis :-/ 
05:18:18 <jophish> used one for quite a while, but coming back to Linux was always such a relief ;)
05:18:28 <jophish> also the keyboard suck :)
05:18:37 <angerman> did I say mac mini?
05:19:17 <jophish> ah, keyboard is probably similar then
05:20:51 <angerman> macOS to me is a glorified desktop environment to run terminals that are connected to linux machines üôä
05:20:55 <xerox_> angerman: grand
05:21:48 <jophish> s/1000$ facebook machine/1000$ ssh machine/
05:22:21 <xerox_> angerman: how long did it take to build?
05:22:39 <angerman> xerox_: sorry can't comment on that. Once I get my hands on a proper m1 mac mini, I can.
05:22:53 <jophish> NDA?
05:23:08 <angerman> DTKs come with limits.
05:23:34 <xerox_> ah ok
05:23:39 <jophish> angerman: can you build me a ghc distribution starting now, upload it the second you are done
05:24:20 <angerman> lol.
05:24:39 <angerman> I'll just say this much: you can develop on ghc on apple arm machines :-) 
05:24:56 <angerman> without wanting to jump out of the window.
05:25:02 <xerox_> I'm just hoping to develop *with* ghc, so that's good
05:25:25 <angerman> well you've seen the early benchmarks I guess?
05:25:33 <xerox_> nope!
05:25:43 <angerman> most of your time developing in haskell is spent looking at the screen, not actually compiling software.
05:25:47 <angerman> xerox_: macrumors.com
05:25:59 <xerox_> oh I thought you meant ghc specific benchmarks
05:30:08 <dminuoso> angerman: Oh dunno, that kind of depends on what project you're working on.
05:30:43 <dminuoso> Depending on what you do with GHC, the feedback loop can be awfully slow there
05:30:49 <dminuoso> (Working on GHC)
05:31:17 <angerman> dminuoso: yea, but xerox_ explicitly said he's developing *with* ghc :D
05:31:47 <angerman> xerox_: well they give you a machine to compare to. Is GHC fast enough on that machine? If the answer is yes, then it's likely fast enough on an apple silicon machine.
05:32:13 <dminuoso> angerman: With the llvm backend, the new apple silicon should work out of the box, no?
05:32:24 <dminuoso> Or are you hinting at apple silicon support in the native backend?
05:32:25 <angerman> almost. 
05:32:49 <angerman> there are some minor changes we need in the llvm backend primarily around configure logic.
05:32:59 <angerman> trhe llvm pipeline is just very slow.
05:33:17 <angerman> substantially so, that a NCG makes sense.
05:35:18 <xerox_> angerman: (:
05:35:23 * hackage magicbane 0.5.1 - A web framework that integrates Servant, RIO, EKG, fast-logger, wai-cli‚Ä¶  https://hackage.haskell.org/package/magicbane-0.5.1 (myfreeweb)
05:44:22 * hackage phonetic-languages-examples 0.4.1.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.4.1.0 (OleksandrZhabenko)
06:45:52 * hackage VulkanMemoryAllocator 0.3.8 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.8 (jophish)
07:17:09 <raichoo> Bumping this again here: We are sill looking for contributors for "Advent of Haskell" 2020. www.adventofhaskell.com Would be really cool to get a couple more people on board for this project. I know it's a close call ^^
07:37:22 * hackage moss 0.2.0.0 - Haskell client for Moss  https://hackage.haskell.org/package/moss-0.2.0.0 (mbg)
07:44:59 <Franciman> Hi raichoo, unfortunately I think that haskell is the past, the future is going outside and enjoying the real world. That's why there should be an anti technocratic revolution spreading across the world
07:45:01 <Franciman> but thanks
07:45:13 <maerwald> :D
07:56:02 <zincy_> Franciman: It was but then 2020 happened
07:56:27 <Franciman> damn, so haskell is the future again?
07:57:30 <zincy_> Anything that involves being a hermit is the future
07:57:41 <frdg> I am having trouble with `stack exec` not being able to find a module that it should be able to find, yet I am able to compile and run my program. I cannot use GHCID because of this issue. Here is a full outline of the problem that I posted 4 days ago on SO:
07:57:42 <frdg> https://stackoverflow.com/questions/64738525/stack-can-not-find-a-local-module-that-it-should-be-able-to-find
07:58:01 <Franciman> :D
07:58:13 <Franciman> ah, maerwald I wanted to ask you a few things about ghcup when you have some time to lose
07:58:57 <raichoo> Anything that gives people a bit of fun over the holidays while being isolated.
07:59:02 <maerwald> Franciman: what is it?
07:59:22 <maerwald> raichoo: so what changed compared to 2019? :p
07:59:59 <Franciman> nothing really important, but have you made any further step towards the idea of implementing part of vabal?
08:00:20 <maerwald> no practical achievements so far
08:00:32 <Franciman> because I wanted to ask you how you determine for each ghc what is the base it supports
08:00:45 <Franciman> do you do it by hand, or you have some fancy script I could use?
08:01:17 <maerwald> that's by hand and recorded: https://gitlab.haskell.org/haskell/ghcup-hs/-/blob/master/ghcup-0.0.3.yaml#L97
08:01:27 <Franciman> arg
08:01:35 <merijn> frdg: oh, I think I know :)
08:01:49 <maerwald> Franciman: it's static information anyway
08:01:51 <merijn> frdg: Can you try replacing ~ with /home/whatever in your filepath?
08:01:58 <maerwald> it doesn't change
08:02:01 <frdg> sure
08:02:10 <Franciman> yes, but ok I understand vabal is not used by anybody, but I keep forgetting to update them
08:02:34 <merijn> Franciman: You mean you forget to relax your upperbound on base?
08:02:52 <Franciman> yes
08:03:00 <Franciman> and update vabal's metadata
08:03:07 <merijn> Franciman: Let me introduce you to your saviour with regards to upperbounds :p
08:03:11 <maerwald> lol
08:03:18 <maerwald> < 10000
08:03:26 <Franciman> lol
08:03:26 <merijn> Franciman: https://packdeps.haskellers.com/feed?needle=paramtree
08:03:52 <merijn> Franciman: (replace package name as needed) and get an RSS feed of out of date upperbounds (including base)
08:04:07 <Franciman> thanks
08:04:09 <Franciman> that's cool
08:04:19 <Franciman> raichoo, no sorry, you're right
08:04:38 <merijn> Franciman: As soon as one of you (direct) dependencies releases a version outside your current upperbound it appears in the RSS feed :)
08:04:38 <Franciman> but the doctor said I can't stay sat down for more than 40 minutes in a row
08:04:39 <frdg> merijn: same error
08:04:45 <Franciman> that's what I meant, in a less pompous way
08:04:49 <merijn> frdg: ah, then I dunno
08:04:51 <maerwald> Franciman: you also have RSI? 
08:05:05 <frdg> ill add that to my SO post though.
08:05:27 <Franciman> yes, that one too
08:05:39 <maerwald> the beauty of programming
08:05:51 <Franciman> but also tendonitis in various parts of the arms
08:05:56 <Franciman> and posture problems
08:06:05 <monochrom> I have a cunning plan. Build a large keyboard on the floor. You walk to step on the keys to type.
08:06:06 <Franciman> and circulatory issues to hands
08:07:01 <maerwald> yeah, I bought 2 ergonomic keyboards, parts to replace the firmware/boards, all sorts of trackballs and wrist crap etc
08:07:04 <monochrom> Although, this may be merely transfering hand RSI to leg-foot RSI.
08:07:25 <maerwald> yeah, since I use a 3-foot pedal, my feet hurt
08:07:37 <Franciman> maerwald, :<
08:07:41 <maerwald> I think that's an improvement though
08:07:42 <maerwald> :D
08:07:52 <maerwald> feet you can just cut off and be done
08:07:58 <Franciman> lol
08:11:21 <maerwald> Franciman: https://www.youtube.com/watch?v=fdD7CgN5FGg
08:11:37 <maerwald> it seems he recovered and didn't need surgery
08:11:53 <maerwald> (I can't but stop wondering if he's an emacs user)
08:13:02 <maerwald> I think ppl with heavy alt/ctrl key bindings are at higher risk
08:13:39 <Franciman> thanks
08:13:46 <Franciman> I do think that too
08:14:04 <maerwald> my vim keybindings are very ctrl heavy :/
08:14:04 <Franciman> at least you need to take some care, and presso ctrl/alt with the opposite hand
08:14:10 <Franciman> press*
08:14:41 <maerwald> yes, my problems got worse when I started using workman keyboard layout (similar to colemak)
08:15:15 <maerwald> which focuses on finger rolling (same hand movements). dvorak is supposed to maximize alternating hands, so that might help you too
08:16:51 <frdg> merijn: all of a sudden it just worked and I don't know why.
08:17:19 <raichoo> Franciman: Sorry to hear that, I hope it'll get better?
08:17:47 <frdg> merijn: maybe you were right. But I tried what you said at least 4 times and it didn't work.
08:18:00 <Franciman> hm i see maerwald sorry to hear that
08:18:01 <Franciman> it sux
08:18:05 <Franciman> raichoo, thanks
08:18:16 <Franciman> sorry i was a bit rought
08:18:19 <Franciman> rough*
08:18:33 <raichoo> Happens, don't worry.
08:19:07 <maerwald> Franciman: but I do recommend Kinesis advantage 2 keyboard (at least if you have finger strain)
08:19:24 <maerwald> the concave design makes a huge difference
08:19:45 <maerwald> I wouldn't be able to type without it (and cbd)
08:21:54 <Franciman> cool thanks, I keep it noted
08:21:55 <frdg> merijn: I am perplexed but it had to have been the file path you suggested because I have been going at this for days and had not tried that. If you want the 50 bounty you can answer the question otherwise ill put the answer up in an hour or so.
08:22:08 <Franciman> now sorry my time for computer is left :P
08:22:10 <Franciman> thanks maerwald 
08:22:13 <Franciman> ttyl
08:23:55 <merijn> frdg: Basically, bash doesn't expand ~ within '', and when stack exec invoke ghci that path is still not expanded. So it was just a wild guess that ghci does not perform ~ expansion (most programs don't, the shell usually handles that) :)
08:25:59 <frdg> I see. It all happened so fast but I think I might have opened a new eshell instance in emacs and tried again and that is why it didn't work at first. Thanks though.
08:26:23 * hackage tracing 0.0.5.2 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.5.2 (mtth)
08:34:04 <frdg> I can't recreate this success in a regular terminal though. I am getting the same error as before. In a new instance of eshell it is also failing. wtf I really do not know what I did.
08:35:10 <frdg> if I restart ghcid in the shell that is working then it continues to work.
08:37:36 <frdg> I can also get it to work with ~ in this shell
08:49:04 <frdg> I have solved the problem. If I run `ghcid -c 'stack exec ...` from within the directory that Main.hs is in it is able to find the module. If I start it from anywhere else it says it cannot find the module. The problem was not with ~ I don't think.
09:11:42 <glguy> maerwald: I've asked before but if you answered I missed it. Is there anything I can do to help ghcup 0.1.12 to get out of rc?
09:12:09 <maerwald> glguy: it just has TUI improvements, I wanted to tackle a few other issues, but haven't gotten around it
09:12:56 <maerwald> https://gitlab.haskell.org/haskell/ghcup-hs/-/issues/84
09:13:44 <maerwald> so you can say this bindist works for ubuntu < 18.02
09:13:47 <maerwald> or something
09:14:52 <glguy> maerwald: But currently all you can say is that it works for Linux_Ubuntu in general?
09:16:03 <glguy> Oh, no. I see you already say different things about '16.04', '18.04' and unkonwn_versioning:
09:16:15 <maerwald> glguy: yeah, we only have EQ
09:30:53 * hackage phonetic-languages-general 0.2.0.0 - A generalization of the uniqueness-periods-vector-general functionality.  https://hackage.haskell.org/package/phonetic-languages-general-0.2.0.0 (OleksandrZhabenko)
09:35:52 * hackage csv-conduit 0.7.2.0 - A flexible, fast, conduit-based CSV parser library for Haskell.  https://hackage.haskell.org/package/csv-conduit-0.7.2.0 (MichaelXavier)
09:45:53 <maralorn> When cabal tries to find a valid build plan, does it try all possible flag constellation for all dependencies? Or does it only try the default flags of every dependency?
09:47:32 <int-e> maralorn: it tries toggling the automatic flags, but not the manual ones
09:48:53 * hackage phonetic-languages-examples 0.4.2.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.4.2.0 (OleksandrZhabenko)
10:13:52 * hackage uniqueness-periods-vector-general 0.5.3.0 - Some kind of the optimization approach to data inner structure.  https://hackage.haskell.org/package/uniqueness-periods-vector-general-0.5.3.0 (OleksandrZhabenko)
10:31:52 * hackage uniqueness-periods-vector-examples 0.14.5.0 - Usage examples for the uniqueness-periods-vector series of packages  https://hackage.haskell.org/package/uniqueness-periods-vector-examples-0.14.5.0 (OleksandrZhabenko)
10:37:23 * hackage polysemy-methodology 0.1.6.0 - Domain modelling algebra for polysemy  https://hackage.haskell.org/package/polysemy-methodology-0.1.6.0 (locallycompact)
11:03:40 <kritzefitz> In parsec (string "a" >> mzero) `mplus` string "ab" behaves differently than mzero `mplus` string "ab". Does that violate the laws for mzero or am I misinterpreting the laws for mzero?
11:06:39 <glguy> kritzefitz: I think you're misunderstanding the laws
11:06:52 <glguy> because MonadPlus doesn't have very many
11:07:14 <kritzefitz> I'm specifically talking about v >> mzero =  mzero.
11:08:14 <glguy> I think parsec doesn't satisfy the laws as written in Haddock, but also that people often don't agree on how MonadPlus should actually behave
11:09:09 <glguy> IO also fails the laws as implemented there
11:09:20 <kritzefitz> Good point
11:09:30 <electricityZZZZ> is anyone here also in #rust? can i get a #rust invite?
11:09:45 <glguy> electricityZZZZ: You're looking for ##rust
11:10:15 <electricityZZZZ> oh wow ok freenode should change their error message
11:10:36 <glguy> #rust automatically forwards to ##rust except you weren't logged in so you weren't allowed in
11:10:49 <glguy> (because ##rust requires login for whatever reason)
11:11:48 <electricityZZZZ> ok. yeah #rust on irc.mozilla had problems with haxxorz or something so they are a little more paranoid
11:23:19 <gtk> when i instance NFData and define the rnf function, what happens if I dont really evalute the value till normal form?
11:23:40 <gtk> but WHNF instead?
11:24:16 <jle`> then it will only evaluate to WHNF
11:24:29 <monochrom> breaks a lot of people's hearts
11:24:43 <monochrom> baby jesus cries
11:24:55 <gtk> Then it would be against the will of NFData
11:25:05 <gtk> isn't that a big sin?
11:25:15 <monochrom> cardinal sin
11:25:47 <Uniaika> most certainly
11:26:57 <monochrom> https://www.google.ca/search?q=cardinal+zin+zinfandel&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjpuJSX3v3sAhVKOs0KHb-sB_MQ_AUoAXoECBYQAw&biw=1173&bih=622
11:28:37 <monochrom> Actually I guess just https://www.google.com/search?q=cardinal+zin
11:30:23 <monochrom> Ah, add &tbm=isch for the images.
11:37:52 <koz_> :t any
11:37:53 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:01:23 * hackage polysemy-vinyl 0.1.2.0 - Functions for mapping vinyl records in polysemy.  https://hackage.haskell.org/package/polysemy-vinyl-0.1.2.0 (locallycompact)
12:37:14 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Survey 2020: https://haskellweekly.news/survey/2020.html'
12:37:14 --- topic: set by monochrom on [Sun Nov 01 11:31:39 2020]
12:44:14 <dminuoso> Mmm, I have a large code base that I need a quick feedback loop. How can I disable code generation in GHC to speed it up?
12:45:35 <lortabac> -fno-code
12:46:10 <dminuoso> Mmm, if I add that to cabal it propagates to dependencies it seems
12:46:16 <dminuoso> and `primitive` fails to build
12:47:22 <dminuoso> lortabac: Mmm, but I can get around that. Cheers, that's so much faster.
12:47:29 <dminuoso> Feels like 5-10 times. :)
12:52:54 * hackage minizinc-process 0.1.4.0 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.4.0 (LucasDiCioccio)
12:53:10 <sshine> dminuoso, so you just run type checker?
12:53:18 <dminuoso> sshine: Yeah
12:53:23 <sshine> why didn't I think of that.
12:53:49 <dminuoso> This is 150 modules, and Im modifying a common dependency of them all...
12:53:53 <sshine> most of the times I run GHC I just want to know if I made type errors.
12:54:09 <geekosaur45> tbh I thought the typechecker was the slowest part of ghc these days
12:54:09 <dminuoso> I think ghcid/hie do something similar
12:54:11 <sshine> ah :) so you're really feeling it.
12:54:20 <sshine> yes, they must.
12:55:09 <koz_> Is Data.Text.span (effectively) a combination of Data.Text.takeWhile and Data.Text.dropWhile?
12:56:10 <dminuoso> geekosaur45: From experience, not really. Degenerate projects seem to take a lot of time in the simplifier.
12:56:38 <dminuoso> At least most of them. It's of course not hard to write programs that take a long time to type check
12:57:01 <dminuoso> As an example I frequently notice, megaparsec!
12:57:26 <sshine> koz_, it appears that the implementation is more low-level: https://hackage.haskell.org/package/text-1.2.4.0/docs/src/Data.Text.Internal.Private.html#span_ -- it resembles those of takeWhile/dropWhile -- are you asking if takeWhile/dropWhile would fuse to something equally efficient?
12:57:44 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/issues/17370
12:58:11 <koz_> sshine: I'm asking if 'span pred foo == bimap (takeWhile pred) (dropWhile pred) (foo, foo)'
12:58:22 <davean> geekosaur45: the optimizer is FAR slower than the type checker IME
12:59:15 <sshine> koz_, according to the haddock, it appears so.
12:59:37 <koz_> sshine: Maybe I'm just bad at reading comprehension then, lol.
12:59:38 <davean> geekosaur45: compare -O0 to -O2, and if you do -fno-code its faster yet again
13:00:13 <sshine> koz_, 'takeWhile p' would be "the longest prefix (possibly empty)", and 'dropWhile p' would be "the remainder of the list".
13:00:25 <dminuoso> I guess its in the nature of the simplifier, because depending on code, it can blow up the Core size between passes *a lot*
13:00:30 <dminuoso> And there's a lot of passes
13:00:31 <koz_> Yeah, the key word there is 'prefix'.
13:00:38 <dminuoso> (I think it defaults to 30 passes max?)
13:00:42 <koz_> So yeah, just me being bad at reading comprehension.
13:00:47 <monochrom> also "longest"
13:00:56 <sshine> koz_, for Data.List,span, it even says "span p xs is equivalent to (takeWhile p xs, dropWhile p xs)" :)
13:01:08 <koz_> sshine: Yeah, but Data.Text _doesn't_.
13:01:14 <koz_> Which is probably part of what threw me.
13:01:22 <sshine> koz_, ah. yeah.
13:01:37 <dminuoso> I'm starting to burn already, so I thought "it could be cool to start writing this with continuations.. and maybe ContT would be nice too."
13:01:39 <sshine> koz_, I think I read that on the inside of my skull. one should be careful of that.
13:01:46 <dminuoso> Not even an hour and I cant read my own code anymore. :(
13:32:50 <shapr> Anyone building a hoogle server as a separate step from haddocks produced by CI?
13:34:41 <Uniaika> nope, not here
14:33:22 * hackage minizinc-process 0.1.4.1 - A set of helpers to call minizinc models.  https://hackage.haskell.org/package/minizinc-process-0.1.4.1 (LucasDiCioccio)
14:43:15 <fendor> is there some global setting I can use to limit the memory usage of ghci? 
14:43:37 <fendor> so that every invocation of ghci has a memory limit
14:46:23 <Axman6> Yes, but it's quite complex, you need to write programs that use less memory :P
14:59:59 <fendor> Axman6, tell that to the students that write endless recursive functions :P
15:01:59 <Axman6> Hmm, at ANU we used to have a system which would play student's final assignments off against each other (I can't remember the game now), and I believe we had limits on execution time and memory usage
15:03:31 <Axman6> jackdk: do you know anything about the thing I'm talking about? Or was it after/before your time?
15:04:40 <fendor> the issue is, students can use the server for developing their solutions...
15:04:52 <fendor> so I think I want to limit the memory of every ghci invocation on that server
15:05:13 <fendor> I guess the limits of the user system should do that automagically?
15:05:26 <fendor> iirc, you can configure the memory limit on a per user basis?
15:05:49 <Axman6> I believe so, but I have no idea how
15:06:00 <jackdk> Axman6: the versions I was working on were less sophisticated. The runner used System.timeout, the NFData class, and an IORef to enforce time limits on the program runtime
15:06:15 <fendor> well, time to ask the sys admin. not my job after all
15:06:22 <jackdk> sure this isn't an OS-level problem? I remember everyone crashing the student server the night before a concurrent systems assignment was due
15:06:32 <jackdk> then they put in process limits
15:06:42 <jackdk> fendor: yeah, I think that's a good idea
15:07:27 <jackdk> https://github.com/ndmitchell/spaceleak might have some haskell-side ideas for fiddling with this
15:07:41 <fendor> yeah, I agree, it should be solved on the os level. I just though, maybe there are some low haning fruit. But additionally, I just saw some students somehow installed hls on the server and use it for a remote vscode session. 
15:08:10 <fendor> I am not worrying about space leaks in particular, students write bad code, that is to be expected, but the server should not give them all the memory
15:09:24 <jackdk> Yes, but space leaks -> eating memory, and the technique for catching them sooner is to bound the stack size that the rts is allowed to use. Perhaps that part is applicable to how students invoke GHCi
15:10:43 <fendor> maybe. Let's see whether we can limit the overall memory
15:17:08 <aldessa> hey, where can i get recursion puzzles? i thought it would be nice to have some puzzles for recursion schemes
15:50:33 <hekkaidekapus> fendor: When we have needs like yours this side, we handle it at the OS level by putting setting limits for every user.
15:51:05 <hekkaidekapus> Ony a systemd-capable Linux, this will do:
15:51:36 <hekkaidekapus> systemd-run --user --scope -p 'MemoryHigh=XXXG' -p 'CPUQuota=YYY%' $argv
15:52:58 <hekkaidekapus> Usually, ghc and ghci are symlinks to the previous command where `$argv = ghc(i)`.
15:54:28 <Axman6> to figure out cpu%, see Erlang (the person, not the language's) work on sharing resources :P
16:32:52 <taio> Hello; I have a question about the understanding of instances: Since instances are automatically (implicitly) loaded from modules, it is not possible to manually determine which instance is to be used. consequently "orphaned" instances lead to conflicts. But why didn't a rule be introduced that local instances within a module are preferred over global ones? If the functions are called in another module, the local 
16:32:54 <taio> instances are always used for these functions.
16:34:14 <Axman6> there is only allowed to be one instance of a class for a type
16:34:30 <Axman6> and that mean globally
16:34:48 <Axman6> s*
16:38:31 <taio> I know ... but I asked whether it would be unproblematic to introduce local instances that would be preferred for all functions of the respective module.
16:39:18 <monochrom> Your mechanism allows two code paths to see and use two different instances for the same type and the same class.
16:39:42 <monochrom> Any mechanism that achieves that will have to answer the following question:
16:40:45 <monochrom> On one code path I use one Ord instance of Int to build a binary search tree containing Ints. Clearly, this binary search tree makes sense only under the comparator I used when it's built.
16:41:34 <monochrom> I now pass this binary search tree to the other code path. It uses, nay, assumes, a different comparator. Now it tries to use this other incompatible comparator to try to do BST lookup.
16:41:45 <monochrom> WHAT THE HELL IS WITH THAT?
16:44:24 <monochrom> https://open.kattis.com/problems/outofsorts
16:48:14 <taio> this situation would only occur if I used the functions from that module where local instances are defined. If I don't want these alternative implementations, then I won't use the functions.
16:49:32 <monochrom> I'm passing one data structure from one module to another. What function?
16:50:05 <monochrom> The recipient module is using its own function to try to make sense of this binary tree.
16:50:14 <monochrom> And that's exactly the wrong thing to do.
16:52:09 <monochrom> Alternatively, tell me how your mechanism forbids me from doing what I said I planned to do.
16:54:31 <SrPx> What is a good / efficient structure to represent bitstring? I.e., equivalent of: `data Bits = Empty | Bit0 Bits | Bit1 Bits` ? With fast pattern-matching, concatenation and equality?
16:55:20 <SrPx> And appending of a bit*
16:56:01 <taio> the instance would be selected indirectly via the functions:
16:56:02 <taio> Module M1 has its own instance for Ord T, which overshadows the global instance Ord T ONLY for functions of this module. the module M1 has the sorting function s.
16:56:15 <taio> Everywhere outside of this module where I call s from M1, the local instance Ord T is used. That is predictable and known. I don't understand what's problematic about that.
16:56:44 <hpc> SrPx: store it in ByteString and build your operations on that
16:57:05 <SrPx> but isn't ByteString slow for concatenation and appending?
16:57:32 <SrPx> says cons is O(n) on docs https://hackage.haskell.org/package/bytestring-0.11.0.0/docs/Data-ByteString.html
16:58:34 <monochrom> The BST insert function is in M1. Which comparator does it use? The BST lookup function is outside M1. Which comparator does it use?
17:00:13 <taio> ok i think i understand what you mean now. In my module M1 I could use a function of another module, which expects this global instance Ord T in order to work as expected.
17:01:07 <monochrom> You could. But people won't.
17:02:02 <monochrom> If I s/Ord/Monad/ to create another example, you will have a hard time convincing people to "don't do that".
17:03:15 <monochrom> If M1 has its own instance Monad (State s), and outside M1 there is another, you really can't convince people to "don't write '>>=' both inside M1 and outside; or if you do, don't let the two pieces of code ever see each other".
17:04:36 <monochrom> People will really be writing code like M1.a1 Outside.>>= some_f, where M1.a1 is defined with M1.>>=
17:04:46 <monochrom> Hilarity shall ensue.
17:13:44 <taio> hmmm ok;
17:13:46 <taio> another idea:
17:13:47 <taio> A mechanism is introduced to take over an existing type class - possibly under a new name - in another module so that the methods are in a different namespace.
17:13:49 <taio> The advantage would be that all existing instances are also taken over, but can be overwritten by new instances according to the existing rules.
17:13:50 <taio> The selection would be made via the namespace.
17:20:50 <unclechu> hey, can someone remind me what `|` means here? `type Demote k = (r :: Type) | r -> k`
17:21:26 <taio> for example like this: adopt Ord as My Ord
17:21:28 <taio> instance My Ord ... where ...
17:26:08 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html
17:27:30 <monochrom> (highest density of puns in a title ever, heehee)
17:27:47 <dsal> unclechu: It's just a sum type like Bool
17:27:49 <dsal> @src Bool
17:27:49 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:29:00 * dsal suddenly very distracted by that deriving list
17:29:07 <dsal> I'm glad I don't have to write base
17:30:58 <solonarv> dsal: no, that is not a sum type (cc: unclechu )
17:31:34 <solonarv> that's an injectivity annotation (InjectiveTypeFamilies), which uses similar syntax to FunctionalDependencies
17:31:53 <dsal> I just noticed `type` there.  Been writing wrong language all day.
17:31:57 <monochrom> fancy
17:32:44 <dsal> Sorry for spreading my confusion.
17:32:45 <solonarv> both   (r :: Type)   and   r -> k   would be illegal syntax in that position of a   data   declaration
17:32:50 <monochrom> Yeah I suffer a bit of language mix-up too. After having written a fair amount of Racket, I wrote in C "(for i=0"
17:32:57 <monochrom> and "(if i==0"
17:33:54 <dsal> solonarv: Yeah, I'm at my least smart of the day.
17:34:03 <dsal> I was writing go all day.
17:34:29 <solonarv> same tbh, I've been up for 20 hours now and had a bunch of various brain-using things to do all day
17:34:39 <monochrom> Further in the past, when I was writing both Java and Haskell, I wrote "public class Ord where"
17:35:07 <monochrom> Aw, up for 20 hours, that kills, you need sleep.
17:35:14 <unclechu> solonarv: thanks
17:35:20 * dsal is having a sleep deprivation conversation in another chat
17:36:07 <taio> ok thanks for answering...
17:36:13 <monochrom> Actually a short nap helps tremendously.
17:38:17 <monochrom> My experience leads me to hypothesize that if you are working hard and sleep-deprived like this, if you are OK with taking short naps, your body switches to the uber-sleep mode, giving you the much fabled superpower of uber-sleep.
17:38:23 <hekkaidekapus> Another sleepless here: taio, fancy a paper?
17:41:36 <taio> hm I'm not an academic. it's just an idea of mine. and I wonder if that would be possible or unproblematic.
17:43:06 <hekkaidekapus> taio: ‚ÄúType classes in Haskell‚Äù by C.V. Hall, K. Hammomd, S.L.P. Jones and P.L. Wadler <http://web.mit.edu/ghc/old.ghc/programatica/tools.old/semantics/Overloading/Related/p109-hall.pdf>
17:44:29 <hekkaidekapus> You can skip the gnary parts and you will still get the gist of why you wanted to do was fundamentally problematic.
17:45:54 <hekkaidekapus> Caveat: That paper covers what is now known as ‚ÄòHaskell 98‚Äô. Since 1998, there have been many additions to instance resolution mechanics.
17:46:58 <hekkaidekapus> *S.L. Peyton Jones
17:47:05 <taio> well Idris has "named implementations" and it seems to work, to have proven itself.
17:47:35 <hekkaidekapus> Idris is a whole other beast.
17:48:46 <unclechu> i have a GADT `Stdout ‚à∑ Œ± `OneOf` '[ 'Play, 'Render ] ‚áí Backend Œ±` (where `OneOf` is a type family which constrain an element to be in a list).
17:48:48 <unclechu> i want to define a type-class which would convert type-level values to runtime values so i defined it like this: `class ToVal (Œ± ‚à∑ œÑ) where toVal ‚à∑ Proxy (Œ± ‚à∑ œÑ) ‚Üí œÑ`
17:48:49 <unclechu> but this `instance ToVal ('Stdout ‚à∑ Backend 'Play) where toVal Proxy = Stdout` fails with `it has an unpromotable context ‚ÄòOneOf Œ± '[ 'Play, 'Render]‚Äô`
17:48:56 <unclechu> can i do something about it?
17:52:49 <unclechu> i cannot define any type with that constrainer constructor: `type Test = '[ 'Stdout ] :: [Backend 'Play]` fails with ‚Äúunpromotable context‚Äù
17:54:20 <unclechu> constrained*
18:08:03 <blankhart> let is treated as a core language construct rather than as sugar for a lambda and application in some presentations like write you a haskell.  is let generalization the reason for this? are there others?
18:09:48 <monochrom> That and recursion.
18:10:13 <dolio> What does it mean to be a 'core language construct'? The dynamic semantics in Haskell are given in terms of other things, but the type checking is different.
18:10:27 <dolio> In the Haskell report, I mean.
18:11:13 <blankhart> fair, i was just referring to type checking
18:14:34 <blankhart> monochrom, is the recursion point that you need to separate out let in order to have proper binding groups? i am not quite there yet in studying this so the question may be premature
18:14:56 <blankhart> but that is what i took you to mean
18:15:16 <blankhart> oh nevermind i think i see
18:15:43 <blankhart> you can't have a recursive (anonymous) lambda
18:16:14 <monochrom> :)
18:16:18 <unclechu> correct me if my assumption if i‚Äôm wrong: using GADTs with constraints on type-level is currently impossible in haskell?
18:16:25 <unclechu> is my assumption is wrong*
18:16:42 <unclechu> if my assumption*.. you get it
18:25:01 <bqv> unclechu: per my simple understanding, yes
18:25:35 <unclechu> bqv: okay, thanks
18:26:12 <unclechu> bqv: is there any chance you know whether it is supported in idris for instance?
18:26:30 <bqv> No clue :p
18:45:50 <unclechu> to overcome this i added additional *promotable* type `data SBackend = SStdout | ...etc`
18:46:27 <unclechu> and added a type class `class SBackendVal (Œ± ‚à∑ Operation) (Œ≤ ‚à∑ SBackend) where sBackendVal ‚à∑ Proxy Œ≤ ‚Üí Backend Œ±`
18:51:30 <MarcelineVQ> "<unclechu> bqv: is there any chance you know whether it is supported in idris for instance?" constraints on the actual "data ..." line or constraints on the data constructors that follow it? Could be more fruitful to say what/why you're wanting to do instead of whether it's possible
18:59:49 <MarcelineVQ> That being said though yes you can use gadts with constraints at the type level in idris
19:00:25 <MarcelineVQ> Do you need that class or would a type family do the job you're after?
21:03:01 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Survey 2020: https://haskellweekly.news/survey/2020.html'
21:03:01 --- topic: set by monochrom on [Sun Nov 01 11:31:39 2020]
21:11:23 <jakob_> bqv this is not what you suggested i suppose? https://pastebin.com/m5gh6TrS
21:11:53 <bqv> ah, not quite
21:12:11 <jakob_> i thought so ;)
21:12:45 <jakob_> do you have a hint what you would go for 
21:13:32 <dsal> bqv's suggestion involved making a newtype called TypeOf
21:14:11 <bqv> jakob_: think i overthought that one, pastebin.com/z4SvV5wr
21:15:24 <dsal> I still think the is* model is probably not great.
21:16:05 <bqv> hard to tell, without more info
21:17:00 <jakob_> dsal yes, the maybe version might be helpful indeed. I'll try it after i got this one working
21:17:46 <dsal> e.g.:
21:17:48 <bqv> it's probably simpler codewise, thanks to makePrisms
21:18:05 <dsal> > myInteger (MyDouble 3)
21:18:07 <lambdabot>  Nothing
21:18:12 <dsal> > myInteger (MyInteger 3)
21:18:14 <lambdabot>  Just 3
21:18:17 <dsal> :t myInteger
21:18:18 <lambdabot> MyNum -> Maybe Integer
21:18:24 <dsal> :t isJust . myInteger
21:18:25 <lambdabot> MyNum -> Bool
21:19:12 <bqv> i just suggested the more direct route because it's a lot less boilerplate
21:20:30 <dsal> Sure, it's a shorter path to the stated goal.  I just don't like the goal.  :)
21:20:49 <bqv> simple questions get simple answers :p
21:21:03 <dsal> Yeah, I'm trying to remember how to write a prism by hand.
21:21:12 <bqv> :t prism
21:21:13 <lambdabot> (Choice p, Applicative f) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
21:21:14 <bqv> :t prism'
21:21:15 <lambdabot> (Choice p, Applicative f) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
21:24:07 <jakob_> bvq https://pastebin.com/d30J3Usw thanks for the hint.
21:30:29 <koz_> :t confusing
21:30:31 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
21:30:57 <Axman6> :t confusing traverse
21:30:58 <lambdabot> (Applicative f, Traversable t) => LensLike f (t a) (t b) a b
21:33:23 <bqv> confusing is confusing
21:33:59 <bqv> aiui it's effect isn't visible at type-level so it's weird
21:35:22 <Axman6> it's secret make go faster juice
21:35:41 <bqv> :D
21:38:58 <koz_> :t confusing fmap
21:38:59 <lambdabot> Applicative f => LensLike f (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f) a) (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.
21:38:59 <lambdabot> Functor.Yoneda.Yoneda f) b) a b
21:42:52 <bqv> :t lens . has . confusing . elements
21:42:53 <lambdabot> error:
21:42:53 <lambdabot>     ‚Ä¢ Couldn't match type ‚ÄòGen a‚Äô
21:42:53 <lambdabot>                      with ‚Äò(a0
21:42:59 <bqv> darn
21:43:04 <bqv> that worked on a repl
21:43:43 <bqv>   :: (Traversable t1, Functor f) => (Int -> Bool) -> (t1 a -> b -> t2) -> (Bool -> f b) -> t1 a -> f t2
21:45:34 <koz_> What package(s) did those identifiers come from?
21:45:43 <koz_> I think lambdabot might have something else for one or more of them.
21:45:55 <koz_> :t is
21:45:56 <lambdabot> error:
21:45:56 <lambdabot>     ‚Ä¢ Variable not in scope: is
21:45:56 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
21:45:59 <koz_> :(
21:46:01 <bqv> they'll all be from lens, for me
21:46:04 <Axman6> % :t lens . has . confusing . elements
21:46:04 <yahb> Axman6: ; <interactive>:1:26: error:; * Variable not in scope: elements :: a -> LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda (Const Control.Monad.RWS.Any)) (Data.Functor.Yoneda.Yoneda (Const Control.Monad.RWS.Any))) s s a0 a0; * Perhaps you meant one of these: `Q.elements' (imported from Test.QuickCheck), `Lens.elements' (imported from Control.Lens), `element' (imported from
21:46:23 * hackage trade-journal 0.0.2 -   https://hackage.haskell.org/package/trade-journal-0.0.2 (JohnWiegley)
21:46:46 <koz_> A better question: what does 'lens . has . confusing . elements' do?
21:47:06 <bqv> that's above my pay grade
21:47:39 <dsal> has confuses me without needing confusing
21:48:12 <koz_> :t has
21:48:13 <lambdabot> Getting Any s a -> s -> Bool
21:48:27 <koz_> Isn't that just like, generalized member?
21:48:44 <koz_> (also, 'Getting Any' makes me giggle)
21:49:03 <bqv> it's true if the prism matches
21:49:04 <bqv> that's all i know
22:14:50 <dminuoso> jakob_: Do you want to extract all values matching that constructor?
22:15:07 <dminuoso> Or just determine whether any value in the list was constructed with the given constructor?
22:17:00 <jakob_> dminuoso i don't care about the values, just about the constructors
22:18:07 <bqv> if you wanna get real spicy, you could probably use Typeable to get the constructor name
22:18:29 <dminuoso> % anyLeft xs = any [x | Left x <- xs ]
22:18:30 <yahb> dminuoso: ; <interactive>:88:18: error:; * Couldn't match expected type `a1 -> Bool' with actual type `[a]'; * In the first argument of `any', namely `[x | Left x <- xs]'; In the expression: any [x | Left x <- xs]; In an equation for `anyLeft': anyLeft xs = any [x | Left x <- xs]; * Relevant bindings include; xs :: [Either a b] (bound at <interactive>:88:9); anyLeft :: [Eithe
22:18:51 <dminuoso> oh
22:19:01 <dminuoso> % anyLeft xs = not (null [x | Left x <- xs ])
22:19:01 <yahb> dminuoso: 
22:20:13 <dminuoso> % anyLeft' = has (folded . _Left) 
22:20:14 <yahb> dminuoso: 
22:21:09 <bqv> % anyLeft [Left 1, Right 2]
22:21:09 <yahb> bqv: True
22:21:12 <bqv> neat
22:21:20 <bqv> list comprehensions are magic
22:21:43 <dminuoso> They're really just a bit more mathy looking interface for Monad.
22:21:50 <dminuoso> (And some MonadPlus)
22:22:21 <bqv> yeah, i've used list in do form
22:22:30 <bqv> but i didn't realise you could guard in a comprehension
22:23:29 <jakob_> dminuoso nice! List comprehensions for the win :) 
22:23:32 <jakob_> thx 
22:32:08 <dsal> I almost never use comprehensions for some reason.
22:32:42 <bqv> i used a do list yesterday
22:32:54 <bqv> because feels nicer than comprehension form
22:33:01 <bqv> and i needed a guard
22:33:19 <dsal> Haskell and emacs both seem to have this thing in common where there are so many things I can't even remember what all the things are.  Not so much that I don't know how to use them, but that I forget they exist.
22:33:35 <dsal> Yeah, do + guard is pretty awesome for lists.
22:33:48 <jakob_> about list comprehensions: i thought they were implemented in terms of map and concat? Nothing to to with monads
22:34:19 <bqv> if that were the case, what dminuoso did would be impossible, i think
22:36:01 <jakob_> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
22:36:22 <dsal> haskell tutorials often confuse what a thing is with what you can do with the thing.
22:36:33 <bqv> dsal: i find azure cloud also has that feature. unfortunately it comes in the "everything is constantly broken in an obscure way, and what isn't broken is only working due to the most unsightly of hacks" edition
22:37:03 <dsal> I can't even read the "new features we've added to AWS" emails anymore.
22:37:47 <dsal> Does lambdabot have an undo for list comprehensions?
22:38:05 <dsal> @miscomprehend [x | x <- [1..], odd ]
22:38:05 <lambdabot> Unknown command, try @list
22:39:41 <dsal> @undo do { Just x <- xs; pure x }
22:39:41 <lambdabot> xs >>= \ a -> case a of { Just x -> pure x; _ -> fail ""}
22:40:52 <dsal> > let xs = [Left 1, Right 2, Left 3, Right 4] in do { Right x <- xs; pure x }
22:40:54 <lambdabot>  [2,4]
22:41:12 <dsal> > let xs = [Left 1, Right 2, Left 3, Right 4] in [ x | Left x <- xs ]
22:41:14 <lambdabot>  [1,3]
22:43:45 <dsal> I used this mechanism of guarding yesterday, and still don't ever think about it.
22:50:15 <suzu_> thats pretty cool
22:50:40 <bqv> "miscomprehend" lmao
22:53:23 <koz_> uncomprehend, surely?
22:53:30 <koz_> Which would be like... 'misunderstand'?
22:58:11 <dsal> It was the nearest word I could find at the time.
22:59:16 <dsal> I can't find that thing I thought I did yesterday.  It's the one where you use are in a monad and you want a maybe monad real quick that's also a guard, so you    `Just x <- pure (some maybe monad stuff)`
23:00:07 <dsal> @undo do { Just x <- pure someMaybeMonadStuff; do x }  -- I guess that's the same, but it feels different.
23:00:07 <lambdabot> pure someMaybeMonadStuff >>= \ a -> case a of { Just x -> x; _ -> fail ""}
23:00:42 <dsal> Also, I just said `do x` when I meant `pure x`
23:01:30 <dsal> @undo do { Just x <- pure maybeGetMeSomeAction; x }
23:01:30 <lambdabot> pure maybeGetMeSomeAction >>= \ a -> case a of { Just x -> x; _ -> fail ""}
23:02:09 <dsal> If I'm ever seen in public again, that's gonna be on my shirt.
23:02:57 <bqv> ha
23:04:05 <dsal> This is another case of undo killing magic, though.
23:05:19 <bqv> @pf \a -> case a of { Just x -> x; _ -> fail "" }
23:05:19 <lambdabot> Maybe you meant: pl bf
23:05:28 <bqv> @pl \a -> case a of { Just x -> x; _ -> fail "" }
23:05:28 <lambdabot> (line 1, column 17):
23:05:28 <lambdabot> unexpected '{'
23:05:28 <lambdabot> expecting variable, "(", operator or end of input
23:05:46 <bqv> i get it, because pointless. oh you.
23:06:06 <bqv> @pl \a -> case a of Just x -> x; _ -> fail "";
23:06:07 <lambdabot> (line 1, column 26):
23:06:07 <lambdabot> unexpected '>'
23:06:07 <lambdabot> expecting operator
23:06:21 <dsal> That's weird.  It doesn't seem to like case.
23:06:42 <bqv> indeed
23:07:18 <dsal> :t   fromMaybe (fail "")
23:07:20 <lambdabot> MonadFail m => Maybe (m a) -> m a
23:08:00 <bqv> nice
23:19:42 <bqv> dsal: is AWS any less blackbox-y than azure?
23:20:18 <bqv> tbh even if it is it's still a cloud and at this point i think i just hate clouds
23:20:24 * bqv young man shouts at cloud
23:27:14 <dsal> Haha.  I don't know azure at all. I know a little AWS and some of Google cloud from the inside.  I use aws some.
23:44:19 <z0> hi. when using ghcid with the -l flag, is it possible to get coloured hlint output?
23:48:49 <dminuoso> jakob_: map and concat are the Monad interface of list.
23:48:57 <dminuoso> map is just fmap, and concat is join
23:49:11 <dminuoso> and equivalently concatMap (the combination of those two) is just (=<<)/(>>=)
23:49:52 <dminuoso> dsal: also, you can just undo list comprehensions
23:50:04 <dminuoso> @undo [x | Just x <- xs]
23:50:04 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) xs
