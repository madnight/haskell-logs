00:00:09 <dminuoso> % :t (?~)
00:00:10 <yahb> dminuoso: ASetter s t a (Maybe b) -> b -> s -> t
00:00:23 <danso> i could see it working as the function `Maybe a -> a -> a` 
00:00:23 <dminuoso> % :t (^?)
00:00:23 <yahb> dminuoso: s -> Getting (First a) s a -> Maybe a
00:07:02 <energizer> that's like regex
00:32:14 <merijn> Don't forget !? from containers
00:36:37 <tomsmeding> Accelerate has (?) for the infix if-operator of the EDSL: https://hackage.haskell.org/package/accelerate-1.3.0.0/docs/Data-Array-Accelerate.html#v:-63- (warning, large page)
00:47:32 <tomsmeding> programming language documentation pages are the best browser benchmarks nowadays
00:52:21 * hackage cobot-io 0.1.3.9 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.9 (ozzzzz)
01:45:22 * hackage sdl2 2.5.3.0 - Both high- and low-level bindings to the SDL library (version 2.0.6+).  https://hackage.haskell.org/package/sdl2-2.5.3.0 (OliverCharles)
02:22:22 * hackage postgresql-libpq 0.9.4.3 - low-level binding to libpq  https://hackage.haskell.org/package/postgresql-libpq-0.9.4.3 (phadej)
03:12:33 <dminuoso> Is using equality constraints as "type level let-bindings" a sane thing to do?
03:13:02 <dminuoso> in particular to sort of "bind the result of a tyfam"
03:13:24 <dminuoso> e.g. `forall m s. (m ~ MappedInto s, Foo s, Bar m, Quux m) => ...`
04:09:30 <matthew-> is there a ghc command or something that'll tell me how an expression is being bracketed?
04:10:36 <matthew-> in res = Subst $ Map.map (apply (Subst s1)) s2 `Map.union` s1, I'm assuming the s2 is an arg to Map.map, and not an arg to Map.union
04:10:39 <merijn> matthew-: No, but you can query the precedence of operators via ":i"
04:11:19 <merijn> matthew-: Easy answer, infix precedence is *always* lower than function application
04:12:09 <merijn> matthew-: infix precedence ranges from 0 to 9, function application has precedence 10 (and record syntax has 11, but that's a bit niche), so 's2' is indeed an argument to Map.map
04:12:18 <matthew-> ahh yes, I remember that rule.
04:12:22 <matthew-> cool, thank you very much.
04:12:33 <merijn> % :i `elem`
04:12:34 <yahb> merijn: type Foldable :: (* -> *) -> Constraint; class Foldable t where; ...; elem :: Eq a => a -> t a -> Bool; ...; -- Defined in `Data.Foldable'; infix 4 `elem`
04:12:46 <Uniaika> I feel like the bracketing is Subst $ (Map.map (apply (Subst s1)) s2) `Map.union` s1
04:13:08 <Uniaika> that's my intuition
04:13:22 <merijn> matthew-: So ":i `Map.union`" in ghci should tell you its precedence
04:13:52 * hackage haskoin-core 0.17.1 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.17.1 (jprupp)
04:18:55 <typetetris> ... is there any benefit to learning arrows and this "arrow style" ? Looking into the niv source code it seems to be some kind of obfuscation technique to scare people away.
04:19:14 <merijn> typetetris: Not really
04:19:24 <merijn> typetetris: Arrow as an abstraction is mostly obsolete
04:19:47 <typetetris> If it is obsolete, what is its replacement?
04:20:18 <merijn> Category from Control.Category, Applicative, and Profunctor all replace different aspects of it
04:21:10 <merijn> There's no real "this replaces all of Arrow" thing, it's mostly that Arrow had rather limited applicability and different aspects of it have been subsumed by more useful abstraction (like those 3)
04:21:57 <typetetris> merijn: Is there some introductory material for the combination of those three things? (Like the papers mentioned in https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation for arrows for example)
04:22:32 <merijn> No clue, I'm just parrotting people from here :p
04:24:09 <matthew-> merijn: yup, I would really like an editor mode where it does all those lookups for me and draws in the parens - would aid code comprehension imo
04:37:17 <matthew-> when implementing a language - a mini-haskell if you like - is there any downside to treating every let as if it's a let-rec ?
04:38:14 <matthew-> (from a DHM type-inference pov)
04:38:20 <ski>   let x = foo 42 in let x = bar 3 x in let x = baz (frob x) in ..x..
04:38:40 <merijn> matthew-: Have you heard of our Lord and Saviour TaPL? ;)
04:38:43 <merijn> @where tapl
04:38:43 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
04:38:56 <matthew-> yeah, I have it in front of me, along with Advanced...
04:39:43 <merijn> matthew-: I recall there being a discussion of the difficulty with recursive bindings at some point in TaPL, but I don't quite recall where, tbh
04:41:11 <matthew-> I have working DHM based on constraint generation as in Advanced Topics in .... Inference for recursive functions is just fine, it's just the recursive call must be the same monotype. Only the let-binding gets generalised to the principle type
04:41:55 <matthew-> if you treat let rec x = foo as let x = fix (\x -> foo) then it seems to me like you don't need let on its own
04:42:34 <jophish> 'cabal.project.local file already exists. Now overwriting it' 
04:42:48 <jophish> Wtf cabal, I spent ages writing that... 
04:42:49 <merijn> You never *need* let, you can always achieve it via lambda binding
04:43:04 <merijn> jophish: It makes a backup
04:43:17 <merijn> Should be in cabal.project.local~
04:43:30 <jophish> Ah I see
04:43:33 <matthew-> aye, true. So then my puzzlement is why does eg ML have both let and let rec?
04:43:38 <merijn> jophish: Also, it only does that if you run configure, whose explicit only purpose is to create cabal.project.local?
04:43:51 <jophish> Oh
04:44:15 <jophish> Configure generates an empty project.local, even though I'm setting a flag
04:44:18 <merijn> jophish: Also, if you cared about persisting whatever you wrote in .local it should probably be in cabal.project? :)
04:44:48 <jophish> merijn: I don't want it in version control
04:44:49 <merijn> jophish: Is that flag already set in cabal.project maybe?
04:44:59 <jophish> Nope
04:45:08 <jophish> I'm setting it to not the default too
04:45:09 <ski> matthew- : convenience. ability to do the example i had above, with that ordering of subexpressions
04:45:10 <merijn> hmm, what's the command?
04:45:17 <jophish> Sorry for my terseness, I'm on mobile
04:46:00 <jophish> Cabal configure -fgeneric-instances
04:46:37 <jophish> https://github.com/expipiplus1/vulkan/blob/68638aceeb5526b3bf53674f06dc24243d7fda32/.github/workflows/ci.yml#L89
04:46:41 <merijn> jophish: That is not a cabal flag?
04:47:19 <matthew-> ski: gotcha - that makes sense - it's about allowing control of the scope of the binder then.
04:47:23 <jophish> It's a flag for a package in this project
04:47:27 <jophish> Hahah, did I get it wrong! 
04:47:49 <ski> matthew- : you can also imagine things like `let (m,n) = (n,m+n) in ..m..n..' .. or having a `case' or conditional as the body of the defining equation, in a more complicated case
04:48:21 <merijn> jophish: So you wanna set that flag for CI?
04:48:55 <ski> matthew- : if you combine two declarations into one, you can combine them sequentially, collaterally, or recursively
04:48:57 <merijn> jophish: Alternate simpler idea: Why not have a dedicated separate project file for the CI config and setting the flag in there?
04:53:18 <bqv> d.nnr
04:53:29 <bqv> *hello
04:53:35 <ski> hello
04:53:38 <bqv> oh, ski
04:53:42 <bqv> fancy seeing you here
04:54:06 <bqv> have you ever used Foreign.Marshal.Alloc? bizarrely, malloc causes ghc to error with undefined, but mallocBytes doesn't
04:54:36 <merijn> Malloc with what argument?
04:54:47 <bqv> malloc doesn't require an argument
04:54:57 <bqv> Storable a => IO (Ptr a)
04:55:03 <bqv> :t malloc
04:55:04 <ski> perhaps the `Storable' instance is incorrect ?
04:55:04 <lambdabot> error: Variable not in scope: malloc
04:55:07 <merijn> Well, what result type, I mean
04:55:08 <bqv> ack.
04:55:12 <ski> @type Foreign.Marshal.Alloc.malloc
04:55:14 <lambdabot> Foreign.Storable.Storable a => IO (GHC.Ptr.Ptr a)
04:55:26 <bqv> it's a custom storable
04:55:38 <bqv> i would be hardpressed to see how the instance is wrong
04:56:16 <bqv> and like i said, if i just use mallocBytes (sizeof <type>) instead, it works fine
04:56:32 <ski> not your instance then, i take it
04:56:55 <bqv> ah, it is my instance. I have it setup using hsc2hs
04:57:04 <bqv> i checked the value of sizeOf and alignment using trace, they're fine
04:57:08 <bqv> (best i can tell)
04:57:13 <jophish> Merijn, and then mv project.ci project.local during the build instead of configure? 
04:57:32 <matthew-> ski: thank you, that all makes sense
04:57:44 <merijn> jophish: eh, or just use --project-file to point it at the right one? ;)
04:58:00 <jophish> Ah, even better
04:58:10 <merijn> jophish: Almost as if this was an anticipated usecae ;)
04:58:40 <ski> bqv : "error with undefined", as when forcing `undefined' ?
04:58:59 <bqv> yes
04:59:09 <bqv> specifically shows me an undefined coming from Alloc.hs
04:59:18 <bqv> (in Foreign.Marshal)
05:00:03 <merijn> bqv: Can you pastebin your Storable instance somewhere?
05:01:49 <bqv> https://termbin.com/7z9jm
05:01:54 <bqv> merijn: happy to oblige
05:02:11 <merijn> bqv: You fucked up sizeof :)
05:02:17 <merijn> You pattern match
05:02:17 <bqv> oh no
05:02:20 <bqv> why
05:02:35 <merijn> sizeOf shouldn't evaluate it's argument, it's only for type inference
05:02:48 <merijn> sizeOf is usually called with undefined as argument (which is what malloc does)
05:02:59 <bqv> oh balls. hence i end up forcing that undefined
05:03:07 <bqv> gotcha. thanks
05:03:09 <merijn> bqv: So malloc calls "sizeOf undefined" and then crashed on the pattern match ;)
05:03:33 <merijn> Nowadays people would use "Proxy" to control the type inference, but that didn't exist when Storable was defined
05:03:55 <bqv> i remember delving into that once
05:07:18 <kuribas> :t asTypeOf
05:07:20 <lambdabot> a -> a -> a
05:49:52 * hackage http-rfc7807 0.1.0.0 - RFC7807 style response messages  https://hackage.haskell.org/package/http-rfc7807-0.1.0.0 (PeterTrsko)
05:52:02 <dminuoso> merijn: Interestingly, sizeOf *should* not be fed with undefined.
05:52:07 <dminuoso> In most cases there are proper values around
05:53:04 <dminuoso> Storable is quite unusable for flexible length things, even if you implement sizeOf to use it, `with` will feed you an undefined rather than the argument.
05:53:24 <dminuoso> alloca = allocaBytesAligned (sizeOf (undefined :: a)) (alignment (undefined :: a))
05:59:39 <bqv> lucky for me, i'm just interfacing a pretty basic C library
05:59:48 <bqv> either way, thanks friends, it works!
06:11:47 <idnar> merijn: nowadays I use TypeApplications instead of Proxy :P
06:19:09 <dminuoso> idnar: Congratulations, you now rely on an unstable API
06:19:48 <dminuoso> Do you have polykinds? Then you better also explicitly quantify those, or you dont have compatibility with 8.8
06:19:52 <dminuoso> (Or was it 8.10?)
06:20:06 <dminuoso> And you must constantly live with the fact that GHC can just change the order of type variables,
06:23:02 <davean> dminuoso: Yah the type variable order thing with TypeApplication is insane :(
06:23:25 <davean> I only use type application with explicite forall
06:23:42 <dminuoso> davean: Indeed. I tend to only use it for Proxy
06:23:43 <idnar> dminuoso: that certainly sounds like me! I think it won't reorder if you have explicit `forall`, and not working on a library means I care less about compat
06:24:30 <davean> idnar: it won't reorder the type variables listed in the forall, correct.
06:25:13 <idnar> but I basically have every extension on at this point :P
06:25:20 <dminuoso> idnar: Next up, you can only apply visible type arguments
06:25:28 <dminuoso> In some situations that can be really annoying
06:25:51 <merijn> idnar: Right, but almost no one has explicit forall in their code and most people don't consider "type variable order" part of their public API for PVP purposes
06:27:20 <idnar> merijn: yeah, my comment was firmly tongue-in-cheek :)
06:27:22 <dminuoso> I mean if you use it for Proxy, then TypeApplications is completely benign and great. If its internal, well you have enough weapons to hurt yourself anyway, but for public API its best to just use Proxy
06:27:24 <dminuoso> oh
06:27:53 <dminuoso> idnar: Its interesting how Haskell seems to be split into two kinds of people
06:28:16 <dminuoso> Those who progressively end up with nearly all extensions enabled, and those who fight against any extension.
06:28:21 <dminuoso> I seem to belong to the former group
06:28:30 <dminuoso> Rarey do I have a module with less than 8 extensions...
06:29:07 <dminuoso> TypeFamilies, ScopedTypeVariables, RankNTypes are currently my favourite ones..
06:29:27 <davean> I'm kinda in the middle
06:29:37 <idnar> I ran into an awkward spot with GADTs and skolems where I had to use a proxy to make it work
06:30:22 <dminuoso> % let f = id in f @Int 1
06:30:23 <yahb> dminuoso: ; <interactive>:329:15: error:; * Cannot apply expression of type `a0 -> a0'; to a visible type argument `Int'; * In the expression: f @Int 1; In the expression: let f = id in f @Int 1; In an equation for `it': it = let f = id in f @Int 1
06:30:27 <dminuoso> It's easy to hit the limits of TA :)
06:31:20 <dminuoso> davean: Where do you draw the line?
06:31:48 <dminuoso> Are there particular extensions you dont like? Or is there a maximum number of extensions?
06:32:06 <merijn> I prefer non-infectious extensions
06:32:21 <merijn> i.e. where the consumer of the code doesn't need the extension
06:33:48 <dminuoso> merijn: Question, do you ever use OverloadedStrings?
06:33:51 <dminuoso> say for text
06:34:02 <dminuoso> (I know you can use T.pack, but lets face it, who does it)
06:34:16 <geekosaur> OerloadedStrings is not something where use internally forces use externally
06:34:26 <dminuoso> Ah
06:34:27 <merijn> I don't really like it, but yes
06:34:28 <geekosaur> it's a convenience externally
06:35:51 * hackage prolude 0.0.0.5 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.5 (saramuse)
06:39:52 * hackage primitive-unlifted 1.0.0.0 - Primitive GHC types with unlifted types inside  https://hackage.haskell.org/package/primitive-unlifted-1.0.0.0 (andrewthad)
06:41:52 * hackage persistent 2.10.5.3 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.5.3 (parsonsmatt)
06:47:26 <bqv> dminuoso: I used to
06:47:36 <bqv> I used to avoid every and all extensions
06:47:46 <bqv> That meant a lot of pack
06:47:53 <bqv> And a lot of unpack
06:48:26 <bqv> Sometimes in that order...
06:49:03 <dminuoso> bqv: What about packages that impose FlexibleContexts/FlexibleInstances on you?
06:49:14 <dminuoso> Especially since 8.10 it's getting increasingly harder to avoid extensions
06:49:29 <dminuoso> (The change itself is welcome, but the impact could be undesirable)
06:49:32 <bqv> Never had the pleasure of one back then
06:50:15 <bqv> Nowadays of course, my haskell files come with lists of extensions like I'm ordering รก la carte
06:50:33 <bqv> If I can't have none, not much point being skiddish
06:51:27 <bqv> I would care about portable haskell, but ghc has a pretty unholy monopoly thats really not going anywhere anyway 
06:59:52 * hackage wai-log 0.3.0.0 - A logging middleware for WAI applications  https://hackage.haskell.org/package/wai-log-0.3.0.0 (jonathanjouty_scrive)
07:05:07 <PacoV> Hi there.
07:05:41 <yushyin> Hi PacoV
07:06:03 <PacoV> I've multiple functions of type "a -> mb" and a list of "[a]".
07:06:28 <PacoV> At the moment I do "mapM_ function list" for each function.
07:06:56 <PacoV> Is there a way to call every function with the list as arguments (and discard the result)?
07:08:03 <dminuoso> PacoV: That's still traverse_/mapM_
07:08:23 <dminuoso> traverse ($ xs) [f, g, h]
07:08:26 <dminuoso> traverse_ ($ xs) [f, g, h]
07:09:05 <dminuoso> % traverse_ ($ "foo") [putStr, putStr, putStr]
07:09:05 <yahb> dminuoso: foofoofoo
07:09:10 <PacoV> Ok, I'll have a look at traverse.
07:09:17 <merijn> dminuoso: That's just a single item, though, not a list of items
07:09:22 <dminuoso> PacoV: traverse/traverse_ are just mapM/mapM_
07:09:34 <PacoV> Ho, so, not enough.
07:09:38 <merijn> :t \fs as -> mapM_ (sequence fs) as
07:09:40 <lambdabot> (Monad m, Traversable m, Foldable t) => m (a -> b) -> t a -> m ()
07:09:44 <dminuoso> merijn: huh?
07:09:44 <merijn> boom
07:09:54 <merijn> dminuoso: He wants to apply a list of functions to a list of values
07:10:13 <dminuoso> Guess there's two ways to read this..
07:10:43 <merijn> % mapM_ (sequence [print, print]) [1..5]
07:10:43 <yahb> merijn: ; <interactive>:331:1: error:; * Could not deduce: Item (m (a0 -> b0)) ~ (a1 -> IO ()); from the context: (Monad m, Traversable m, Show a, IsList (m (a2 -> b)), IsList (t a2), Num (Item (t a2)), Enum (Item (t a2)), Foldable t, Item (m (a2 -> b)) ~ (a -> IO ())); bound by the inferred type for `it':; forall (m :: * -> *) a a2 b (t :: * -> *). (Monad m, Traversable m,
07:11:20 <merijn> ugh, how do I reset yahb?
07:11:31 <dminuoso> It's ghci
07:11:33 <dminuoso> So :q
07:11:37 <merijn> % :q
07:11:38 <yahb> merijn: 
07:11:40 <merijn> % mapM_ (sequence [print, print]) [1..5]
07:11:41 <yahb> merijn: [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
07:11:59 <merijn> that's not right..
07:12:22 <dminuoso> well..
07:12:27 <merijn> :t sequence [print, print]
07:12:29 <lambdabot> Show a => a -> [IO ()]
07:12:36 <merijn> ah
07:12:37 <dminuoso> this is just ap..
07:12:56 <merijn> % mapM_ (sequence_ [print, print]) [1..5]
07:12:57 <yahb> merijn: ; <interactive>:2:8: error:; * Couldn't match type `()' with `m b0'; Expected type: a0 -> m b0; Actual type: a0 -> (); * In the first argument of `mapM_', namely `(sequence_ [print, print])'; In the expression: mapM_ (sequence_ [print, print]) [1 .. 5]; In an equation for `it': it = mapM_ (sequence_ [print, print]) [1 .. 5]; * Relevant bindings include it :: m () (bou
07:13:11 <dminuoso> % sequence ([print, print] <$> [1...5])
07:13:11 <yahb> dminuoso: ; <interactive>:3:11: error:; * Couldn't match expected type `Over p0 f0 s0 t0 a1 b0 -> m a' with actual type `[a0 -> IO ()]'; * In the first argument of `(<$>)', namely `[print, print]'; In the first argument of `sequence', namely `([print, print] <$> [1 ... 5])'; In the expression: sequence ([print, print] <$> [1 ... 5]); * Relevant bindings include it :: m [a] (bound at <inter
07:13:11 <PacoV> It looks just about what I need.
07:13:11 <merijn> ok, I give up on making it work :p
07:13:28 <dminuoso> % sequence ([print, print] <*> [1...5])
07:13:28 <yahb> dminuoso: ; <interactive>:4:12: error:; * No instance for (Show (Over p0 f0 s0 t0 a0 b0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In the expression: print; In the first argument of `(<*>)', namely `[print, print]'; In the first argument of `sequence', namely `([print, print] <*> [1 ... 5])'; <interactive>:4:31: error:; * No insta
07:13:34 <PacoV> Thanks!
07:13:36 <dminuoso> huh
07:13:42 <dminuoso> % sequence ([print, print] <*> [1...5] :: [Int])
07:13:42 <yahb> dminuoso: ; <interactive>:5:11: error:; * Couldn't match type `IO ()' with `Int'; Expected type: [Int]; Actual type: [IO ()]; * In the first argument of `sequence', namely `([print, print] <*> [1 ... 5] :: [Int])'; In the expression: sequence ([print, print] <*> [1 ... 5] :: [Int]); In an equation for `it': it = sequence ([print, print] <*> [1 ... 5] :: [Int]); <interactive>:5:11:
07:13:48 <dminuoso> *shrugs*
07:14:01 <dminuoso> merijn: makes you wonder how we get anything done, if we cant even solve beginner problems
07:14:11 <merijn> I'd just use bindings :p
07:14:24 <dminuoso> and probably not structure your code to end up in that place
07:14:37 <dminuoso> I've never written sequence anywhere
07:15:06 <dminuoso> Indeed, none of my haskell projects have a single occurence of i
07:16:43 <dminuoso> % :t sequence_ $ [putStr, putStr] <*> ["foo","bar"] -- merijn 
07:16:43 <yahb> dminuoso: IO ()
07:16:44 <dminuoso> Did you mean that?
07:16:58 <merijn> no
07:17:12 <merijn> The problem is that I meant a double sequence or something weird
07:17:15 <dminuoso> Then I really dont understand what you're trying to write
07:17:24 <merijn> :t sequence_ . sequence [print, print]
07:17:25 <lambdabot> Show a => a -> IO ()
07:17:30 <merijn> That
07:17:30 <dminuoso> huh
07:17:32 <dminuoso> % :t sequence_ [print, print]
07:17:32 <yahb> dminuoso: Show a => a -> ()
07:17:41 <dminuoso> % :t sequence_
07:17:41 <yahb> dminuoso: (Foldable t, Monad m) => t (m a) -> m ()
07:17:51 <dminuoso> oh
07:18:12 <merijn> First one for the "a ->", second for the internal IO
07:18:13 <dminuoso> % :t sequence [print, print]
07:18:13 <yahb> dminuoso: Show a => a -> [IO ()]
07:18:14 <dminuoso> Right
07:18:55 <dminuoso> but how exactly is that different from
07:18:58 <dminuoso> % :t sequence_ $ [putStr, putStr] <*> ["foo","bar"]
07:18:58 <yahb> dminuoso: IO ()
07:19:14 <dminuoso> In both cases you generate the cartesian product
07:19:21 <dminuoso> apply, and then sequence
07:19:37 <dminuoso> yours is just a bit more hidden
07:25:22 <daydaynatation> Are there any sort function on Data.Array?
07:25:32 <bqv> But its pointfree
07:26:01 <PacoV> Okay, I'll use dminuoso's version as the "m ()" has the right type in the end.
07:28:47 <daydaynatation> Just found out that there is no sort function for Vector neither...
07:29:11 <merijn> daydaynatation: You want vector-algorithms :)
07:29:18 <merijn> @hackage vector-algorithms
07:29:18 <lambdabot> https://hackage.haskell.org/package/vector-algorithms
07:29:26 <daydaynatation> ah ha
07:29:45 <daydaynatation> merijn: how about array-algorithms? does it exist?
07:29:51 <merijn> No clue
07:30:19 <merijn> Unless you need generalised indexing via Ix vector is generally better
07:30:54 <daydaynatation> I'm just doing some comparison between Haskell and C++, for learning's sake
07:31:22 <daydaynatation> I guess Haskell's array is way too different from C++ array
07:31:28 <merijn> daydaynatation: right, if you just want 1D arrays/vector like C/C++ then you probably want vector
07:33:57 <daydaynatation> btw, does cabal hell still exits? I use ghcup to install ghc and cabal and then cabal install everything in the global scope. Is this the usual way of installing packagings with cabal? or do people cabal install some kind of sandbox
07:35:22 <merijn> daydaynatation: Actual cabal hell has been gone for close to a decade. What people *now* call cabal hell is simply "I'm depending on ancient unmaintained packages and the dependency solver can't find a solution", which doesn't really have a solution
07:35:44 <bqv> With nix, you can jailbreak...
07:36:00 <merijn> daydaynatation: As for sandboxing individual projects, as of cabal-install 3.0 that is unncecessary
07:36:43 <maerwald> you can use stack2cabal too
07:36:44 <merijn> daydaynatation: Basically, every installed package is tagged with a hash of its source, exact version and compile flags, and the hashes of it's transitive dependencies
07:36:45 <daydaynatation> Wow, great to know! So I just cabal install globally and it just works? Nix is too complicated
07:36:53 <maerwald> @hackage stack2cabal
07:36:54 <lambdabot> https://hackage.haskell.org/package/stack2cabal
07:37:06 <merijn> daydaynatation: So you can have infinitely many different configurations/versions of the same package installed
07:37:08 <maerwald> in case you can't build with cabal
07:40:32 <merijn> daydaynatation: cabal-install will select the right/matching versions from the global store when building a project. So you end up with builds happening "as if" they're in a sandbox, except you don't need to manage sandboxes/virtualenvs, as they all share a single global store
07:41:07 <merijn> daydaynatation: See also https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html (despite the nix url, doesn't actually have anything to with nix other than "the general idea")
07:41:38 <merijn> (note that the v2- prefix is optional in cabal 3.0 and later, as all the commands default to v2-)
07:41:51 <yushyin> yes, it's misleading
07:41:54 <daydaynatation> Thanks!
07:42:26 <merijn> yushyin: Patches welcome ;)
07:42:33 <dolio> What's misleading?
07:42:37 <yushyin> the name
07:43:01 <merijn> dolio: "nix local builds" tends to mislead people into thinking it's about Nix
07:43:11 <dolio> It says "nix-style local builds".
07:43:20 <merijn> dolio: Not in the url
07:43:36 <dolio> Maybe read the actual page instead of just the url.
07:43:56 <merijn> dolio: And even nix-style has repeatedly led to confusion here
07:46:34 <yushyin> but is there a better and more descriptive name? I have no idea.
07:46:54 <bqv> Nix is popular in haskell anyway, no?
07:47:20 <merijn> bqv: eh...
07:47:32 <merijn> bqv: There's certainly a very vocal group of fans :)
07:47:50 <merijn> I wouldn't say they're remotely close to a majority, though
07:48:15 <dolio> I think a lot of people like the vague idea, and the implementation in cabal is likely to be preferable for most people.
07:48:17 <bqv> The nix folk make it seem like haskell's rife with nixerse..
07:48:48 <merijn> dolio: I like the *idea* of Nix, they're making it very hard to like the *execution* of Nix, though ;)
07:49:08 <dolio> Right, that's what I was getting at. :)
07:49:32 <merijn> I wish someone would make Nix, but like, not sucking :p
07:49:33 <bqv> Believe me I agree...
07:50:20 <yushyin> cabal v2-* works well for me, I am quite happy with it
07:50:23 <bqv> But the way I normally phrase it, I like nix, I just hate nixpkgs and nixos
07:50:33 <dolio> Of course, the cabal one only really does anything for Haskell things.
07:50:39 <bqv> But sadly nothing compares and I have stockholm syndrome
07:53:18 <chreekat[m]> It's the other way around maybe - lots of Haskellers active in Nix community as well
07:53:37 <dolio> bqv: I've heard some of the Haskell power users complaining about the language as well.
07:53:51 <dolio> Although I couldn't give specifics myself.
07:54:28 <tdammers> I think the most common complaint about nix-the-language is that it's thoroughly untyped
07:54:51 <chreekat[m]> E.g. The nixpkgs support for Haskell has had a lot of work put into it, and it's not even the only implementation available
07:55:15 <tdammers> and that that makes it really hard to make things discoverable
07:55:24 <monochrom> In an alternate universe, the nix language is thoroughly typed. In ##scheme, they complain that it's thoroughly typed. :)
07:56:12 <tdammers> IME, lispers tend to have marginally higher tolerance for typed languages than haskellers have for untyped languages
07:56:30 <dolio> I don't think it was about types. It was about some inconsistencies with how things worked or something. Special cases that would confuse people.
07:56:55 <tdammers> some of that is linked to the unitypedness though
07:57:01 <dsal> It's a weird language, for sure.
07:57:15 <chreekat[m]> My complaint is the thoroughgoing reliance on fix points for enabling extension. I mean, i don't really have a better idea, but i grokked monads well before i grokked fixpoints, and they still bend my head some. Error messages suffer, too
07:57:19 <tdammers> personally, I think making an entirely new language for this was a mistake
07:58:07 <chreekat[m]> I guess if it still bends my head, i don't actually grok them :)
07:58:44 <tdammers> packaging things for, well, any platform really, is not something most developers love to do, it's something we want to get over with ASAP. having to learn an entire programming language, and a badly documented one at that, creates a harsh barrier
07:59:20 <dolio> Well, I can tell you that not inventing a new language doesn't avoid that part. :)
07:59:44 <monochrom> I haven't studied nix. But if enabling extensions is equivalent to OOP subclassing and virtual methods and late binding, then semantically a fix point (over open recursion, even) is necessary. What you can argue over is whether the syntax should expose or hide this fact.
08:00:16 <tdammers> an entirely new language *can* be the right choice, but it has to pull its weight and be completely non-frightening
08:04:28 <maerwald> tdammers: packaging requires more discipline than the average programming imo. Having followed NixOS from its early beginnings, my opinion is that it never reached a critical mass of quality dedicated packagers
08:04:44 <maerwald> much more drive by contributions
08:05:10 <dolio> I'm mainly thinking of SBT in Scala, which was an embedded language in Scala, but it was pretty hard to figure out how to do anything that didn't happen automatically.
08:06:40 <dolio> Because the documentation didn't really tell you how.
08:07:52 * hackage hakyll-typescript 0.0.2.0 - Typescript and javascript hakyll compilers.  https://hackage.haskell.org/package/hakyll-typescript-0.0.2.0 (jhmcstanton)
08:24:22 <tauli> Does anyone know where cabal get's the authors name and email from when initialising a new package? doesn't seem to be in .cabal/config
08:24:49 <monochrom> .gitconfig
08:27:21 <tauli> do i have to refresh some cache? changed ~/.gitconfig but cabal still writes the old email adress
08:27:50 <tauli> am on macOS with cabal 3.2.0.0
08:28:15 <monochrom> works for me
08:29:53 <c_wraith> tauli: does `git config user.name` show the changed version?
08:30:33 <tauli> it's `git config user.email` but yes, that's changed
08:31:59 <tauli> ok, changing user works, but not with the email address
08:32:23 <tauli> maintainer in the .cabal is set to some old mail address
08:33:00 <monochrom> OK I didn't test maintainer. I tested cabal init.
08:33:32 <monochrom> Oh, that's maintainer.
08:33:53 <tauli> yep, when i do `cabal init` the maintainer field of the generated .cabal file is set some old mail address i don't know where cabal get's that from
08:40:33 <tomsmeding> tauli: also `git config --global user.email`?
08:42:27 <tomsmeding> you can also run `strace -f -o log.txt cabal init` and search the produced log.txt for "gitconfig" to see which file it's using
08:42:41 <tomsmeding> (assuming linux; dtruss on mac, no idea on windows)
08:43:08 <tomsmeding> (oh you said macOS; something something dtruss :p )
08:47:22 * hackage hakaru 0.7.0 - A probabilistic programming language  https://hackage.haskell.org/package/hakaru-0.7.0 (z)
08:50:31 <tauli> the culprint was ~/.darcs/author
08:50:40 <tauli> thanks for all the pointers
08:51:42 <Uniaika>  /7
09:10:32 <tdammers> maerwald: exactly. packaging is hard and thankless work - it needs to be made as painless as possible
09:11:35 <maerwald> yes, thats why most distros strictly separate configuration from packaging. In nix, its all the same
09:29:03 <dsal> It's just that all other systems are so much worse.
09:29:22 * hackage hnix 0.11.0 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.11.0 (AntonLatukha)
09:36:24 <maerwald> dsal: did you use another system?
09:36:40 <maerwald> (most of them are proprietary)
09:41:40 <dsal> I've used tons of different unix systems since the 90s.
09:42:29 <dsal> nix is weird from a unix perspective, but it's super nice from a packaging perspective.  docker is popular these days, but gross in many ways, including just not being great software.
09:42:50 <monochrom> I no longer ask for great software.
09:43:12 <yushyin> monochrom: you just write it yourself? ;)
09:43:14 <dsal> I end up just writing all my own software these days because everything is just so depressingly bad.
09:43:22 <monochrom> Nah, I don't write great software either.
09:44:40 <dsal> There are a few bits of software I use that actually seem pretty good.  Even then, a little questionable.  Given its complexity, Ableton Live does a pretty good job.  I don't think I could write something similar.   But there are so many of these javascript things like zigbee2mqtt that just barely work well enough that I can not think about them most of the time.
10:13:19 <invaser> Hi, can someone take a look at the problem I have in #haskell-beginners?
10:13:30 <invaser> Or I can copy it here
10:15:38 <gobbleguy> invaser: you can bring it here
10:16:04 <gobbleguy> This channel is fine for "beginner" questions, too.
10:17:07 <invaser> Ok, so I'm trying to make parser to do this: parse (string "z1" <|> pure "") "" "zet" should be Right "", and not Left ...
10:17:56 <invaser> I get why this code doesn't what I want it to, because it's already read "z" and exception arises only on second char
10:18:12 <dminuoso> invaser: parsec does not backtrack by default
10:18:22 <dminuoso> Wrap the left part in `try (...)`
10:18:55 <invaser> a-ha, it's `try`, tyty
10:20:25 <dminuoso> invaser: So while `l <|> r` encodes a choice for parser combinators, it itself does not guarantee `l` would backtrack on failure (that is "unconsume" already consumed tokens)
10:21:26 <dminuoso> Some libraries always backtrack by default, others backtrack only certain primitives, and parsec *never* backtracks by default
10:21:57 <invaser> dminuoso: So, in layman's terms, it works only when it determines that left parser can't parse the string on the first char?
10:23:05 <dminuoso> invaser: Unless you denote the left side can backtrack, say `try l <|> r`
10:23:23 <davean> dminuoso: Mostly my stance is I'm entirely willing to turn on extensions but I look for ways not to and have a highish standard for if they improve things. So I'm not in the "limit them like crazy" camp and I'm not "just enable them", I've used almost all the extensions when I had a good reason, but I'm just careful about it and give it a lot of consideration if I'm missing a better way to
10:23:25 <davean> approach the problem and if the extension is acting as a crutch to a poor conceptualization of the problem and actually just enabling a more complicated system than is needed (which is often the case)
10:24:16 <dminuoso> invaser: The fundamental problem is that parser combinators cant do automatic lookahead
10:24:43 * davean stares at that statement for a bit.
10:24:54 <dminuoso> *monadic!
10:24:56 <davean> They certainly don't. I'm not convinced they can't.
10:24:56 <dminuoso> ;)
10:25:08 <dminuoso> davean: They cant if they are monadic.
10:25:11 <monochrom> Oh, monadic, yeah.
10:25:18 <dminuoso> With selective or applicative parser combinators you can.
10:25:37 <davean> dminuoso: You can't *in general* but many of the combinators are selective or applicative.
10:25:40 <monochrom> BUT! I have realized that given anyChar, you can stay Applicative for CFG.
10:25:40 <davean> dminuoso: so sometimes you can.
10:26:11 <monochrom> And academically we have found that anyChar needs Selective only, not full monadic.
10:26:27 <monochrom> Err sorry!  s/anyChar/satisfy/
10:26:36 <davean> dminuoso: so saying they can't isn't quite true
10:26:49 <davean> dminuoso: Saying there are grammers they can't for is true, but thats kinda always true in a way.
10:27:02 <davean> Also not really relivent to most parsers
10:27:12 <daydaynatation> in a type class method, if i write  aMethod:: (Random a, V.Unbox a) => ... does it mean a needs to by both Random and V.Unbox ? Or a needs to be one Or the other
10:27:28 <davean> Both
10:27:31 <monochrom> Oh sorry again, haha, full CFG still needs unlimited lookahead.  LL(k) are the restricted ones that can be done in fixed lookahead.
10:27:40 <davean> For all a such that a is in Random and in Unbox ...
10:28:09 <daydaynatation> ok
10:28:10 <monochrom> But yeah we really design our grammars to be LL(k), even LL(1), don't we.
10:28:22 <davean> monochrom: VERY much so, and on purpose conciously.
10:28:51 <monochrom> So yeah most parsers don't even need full-on Applicative.  Also, I mean s/Applicative/Alternative/
10:29:34 <monochrom> Gosh does IRC allow me to edit past messages? :)
10:29:50 <davean> monochrom: No, IRC makes you life with your decisions.
10:30:15 <davean> IRC promotes honesty and transparency
10:30:19 <davean> not lies and deception.
10:31:16 <dminuoso> davean: fair enough
10:32:42 <davean> dminuoso: we have Applicative => Monad and Applicative Do
10:32:44 <davean> dminuoso: etc
10:32:46 <dminuoso> davean: I mean in principle you could do automatic lookahead inside combinators as far as possible, not quite sure what the runtime penalty is
10:33:24 <davean> Honestly no one tries to write high performance parsers in Haskell because the basics are usually fast enough - look at aeson, its dog slow and no one seems to care.
10:33:52 <dminuoso> The package description says its "high performance"!
10:33:55 <davean> The only person maintaining a faster version just abandoned theirs
10:34:00 <davean> dminuoso: Many people lie.
10:34:04 <dminuoso> davean: Also, https://github.com/J-mie6/ParsleyHaskell
10:34:22 <davean> We have Haskell JSON parsers far faster than aeson.
10:34:24 <dminuoso> So someone is trying to write optimizing high performance parser combinators.
10:34:25 <dminuoso> :)
10:36:32 <dminuoso> davean: But yeah, the example of aeson is pretty good, I notice this in my day job time after time
10:36:37 <dminuoso> How performance if often not important.
10:36:54 <tomsmeding> the question is, do we have a json parser library that 1. parses more quickly, and 2. compiles more quickly?
10:37:08 <dminuoso> We have one project where latency is key, but generally we couldn't care less if aeson takes 5ms to parse some incoming request or not.
10:37:25 <dminuoso> tomsmeding: haha, aeson is not good on either metric
10:37:35 <davean> Right. I know people who DID do high performance JSON stuff in Haskell, etc
10:37:35 <tomsmeding> my point :p
10:37:42 <davean> and like they have a ring buffer between cores, etc
10:37:48 <davean> and you can do all this in Haskell.
10:38:01 <davean> No one even switches which JSON parsing package they use to get a reasonable one ususally though.
10:38:32 <dminuoso> Plus, if performance was so critical, I wouldn't touch JSON with a 3.048m pole to begin with
10:38:35 <davean> tomsmeding: Hum, I think we have ones that are faster in both actually, I'd have to double check, I don't pay attention to compile times because they're so not important but I THINK it does.
10:38:41 <dminuoso> CBOR would be a far better candidate
10:39:25 <dminuoso> My only annoyance with aeson is that its interface is bad and typeclass heavy
10:39:36 <davean> Honestly I do mind the performance.
10:39:53 <daydaynatation> is IO action lazy by default? If so how can i force it to be strict? 
10:39:59 <dminuoso> daydaynatation: yes and no
10:40:04 <tomsmeding> davean: compile times are in nigh-all cases less important than runtime performance, but damn they are annoying :p
10:40:09 <davean> But thats because the more requests per core per second I can handle the less scaling overhead I get 
10:40:17 <dminuoso> daydaynatation: So Haskell is non-strict in *values*, that is the computatoin of `IO ()` itself can be lazy
10:40:24 <dminuoso> But the action itself is (in general) strict
10:40:30 <dminuoso> There are things like lazy IO, which are terrible
10:41:17 <davean> What the IO action *does* is generally not lazy, how the IO action *gets defined* is non-strict.
10:41:31 <daydaynatation> i'm time an action with time :: IO a -> IO a which wraps an anction between CPUTimes
10:41:53 <daydaynatation> the reuslts doesn't look right, so i'm guessing it could be related to laziness
10:42:17 <dminuoso> daydaynatation: can you share the code and results?
10:42:27 <dminuoso> That might be easier than to work with some vague description
10:42:51 <davean> daydaynatation: Though thats most likely not related to laziness
10:43:03 <davean> daydaynatation: Why doesn't it look right?
10:43:06 <daydaynatation> dminuoso: which paste site should I use?
10:43:43 <geekosaur> @where paste
10:43:43 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
10:45:05 <daydaynatation>  
10:45:05 <daydaynatation> https://paste.tomsmeding.com/qgA1JMgU
10:46:00 <daydaynatation> result is here: https://paste.tomsmeding.com/hyrFyOzz
10:46:22 <daydaynatation> list operations are so much faster than vector
10:46:45 <koz_> Not something we hear often.
10:48:33 <daydaynatation> I'm a beginner in Haskell, the code is very awkard
10:49:08 <davean> Oh, well
10:49:18 <davean> Thats not an IO action really that you're doign there?
10:49:41 <davean> What you were *trying* to time was a pure computation.
10:50:11 <daydaynatation> I did generate a random number in the action
10:50:21 <davean> Yah, and that part gets computed, but thats not where the time is taken
10:50:38 <tomsmeding> @hackage criterion-measurement
10:50:38 <lambdabot> https://hackage.haskell.org/package/criterion-measurement
10:50:43 <davean> The IO part *does* get executed here, but the sorting is optional depending on if oyu use it or not because its not IO
10:50:58 <tomsmeding> (which depends on aeson.......)
10:51:25 <davean> I should see how long it would take me to convert the parts of hackage I sit on top of off of aeson.
10:51:45 <davean> I bet I could do that in ... 30 hours? Thats a lot of code and a fairly significant change really, but it seems quite doable.
10:51:46 <daydaynatation> ok..let me digest. but do you understand why the list operations is quicker?
10:51:57 <davean> daydaynatation: yes, I do, because you never check that its sorted.
10:52:11 <davean> so *all* you're really testing is that it generates a random list
10:52:15 <davean> Which is the IO part
10:53:20 <davean> I have to go, or I'd comment on the code and ways to improve it :/
10:53:38 <daydaynatation> thanks!
10:53:49 <tomsmeding> it's not accurate, but for this you can kind of see IO as being defined as 'data IO a = IO a'
10:54:16 <tomsmeding> that 'r <- action' evaluates 'r' to WHNF (do you know that term?), which is the IO constructor, but not the 'a' inside
10:54:38 <tomsmeding> so if you force 'fmap f (some IO action)', then that f is never evaluated yet
10:54:59 <tomsmeding> since the head (as in WHNF) of the result is already evaluated to IO
10:55:12 <dminuoso> Im not convinced that IO model is helpful in any way.
10:55:18 <dminuoso> It's very suggestive in the wrong ways
10:55:30 <tomsmeding> okay maybe it is
10:55:40 <davean> Also, I want to point out that the action tested here *does not use a reason to be IO*
10:55:56 <davean> Random number generation does not require IO
10:56:02 <daydaynatation> If i leave IO out of it, how do people time pure code?
10:56:10 <davean> daydaynatation: the timing needs to be in IO
10:56:11 <dminuoso> My referred analogy of `IO T` is `list of assembly instruction that, if executed, would produce a result of type T`
10:56:17 <tomsmeding> (fixing it is easy, by the way: either force 'r' using Control.DeepSeq.force, or use a primitive from criterion-measurement)
10:56:36 <dminuoso> Which seems to work rather well, and helps accept IO as being something opaque
10:56:46 <davean> tomsmeding: those will make the list variant look worse performance wise than they REALLY are.
10:56:51 <davean> erg, have to go.
10:57:02 <geekosaur> we generally use the criterion package, which knows how to work around laziness doing things like deferring all computation you thought had already taken place into the timed part
10:57:10 <tomsmeding> davean: not if you only force the final result :p
10:57:37 <tomsmeding> geekosaur: or if you want to only use the timing primitives and not the whole benchmarking+reporting suite around it, use the criterion-measurement package :p
11:00:54 <sm[m]> Aha.. SPJ "The Launch of the Haskell Foundation", streaming on youtube in 40h - https://www.reddit.com/r/haskell/comments/jml10v/haskell_exchange_2020_opening_keynote_the_launch/
11:00:57 <tomsmeding> daydaynatation: fix 1: https://paste.tomsmeding.com/165QyyNN
11:02:03 <daydaynatation> cool! thx let me check
11:06:52 <daydaynatation> it does look better! but the two tests take similar time
11:07:09 <daydaynatation> tomsmeding: let me dig deeper. thx!
11:08:11 <tomsmeding> daydaynatation: or using criterion-measurement: https://paste.tomsmeding.com/uSMMDfGo
11:09:16 <tomsmeding> in the end it does basically the same thing in this case, but the advantage is that 1. you get more info than just the time (see the rest of the Measured data type), 2. the '1' can be increased to repeat the measurement, and 3. you're forced to choose how strictly you want to evaluate the result, here using nfIO
11:09:51 <tomsmeding> and if you want nice reports and fancy stuff, use the full criterion library :p
11:10:55 <daydaynatation> Thanks tomsmeding 
11:10:57 <tomsmeding> if you'd have a normal pure value, not an IO action, you could use 'nf' instead of 'nfIO'
11:11:19 <tomsmeding> good luck :)
11:12:09 <daydaynatation> tomsmeding: I don't see criterion code in your last paste
11:12:27 <daydaynatation> tomsmeding: Perhaps wrong diff?
11:12:29 <tomsmeding> oh crap yes :')
11:13:14 <tomsmeding> https://paste.tomsmeding.com/z3fyxybh
11:13:19 <tomsmeding> (ignore the Lib/Main test/main replacements)
11:13:40 <tomsmeding> (using 'measure' doesn't return the actual function value, hence I removed that)
11:14:06 <daydaynatation> tomsmeding: Always a pleasure to learn a new Lib!
11:36:53 <bqv> Friends how would you debug ffi-heavy haskell?
11:37:25 <maerwald> debug what
11:37:56 <bqv> Well see I have an issue. My program exits
11:38:07 <bqv> But not in failure, just exits
11:38:17 <bqv> No clue why, need to get interactive
11:38:26 <bqv> But I reckon its in the C code
11:38:52 <sm[m]> reckon yer right, pardner
11:39:02 <geekosaur> since FFI is typically in IO, I do a lot of logging around the FFI calls. that said, if something in C is calling exit(), you can't typically intervene and it won't return control to Haskell
11:39:31 <geekosaur> the best you might do is an atexit handler that prints something while it's on the way out
11:39:38 <bqv> I've narrowed it down to the call, but now I wanna peek into that call
11:39:52 <bqv> But... gdb? Haskell?
11:40:03 <bqv> Is that even realistic?
11:40:10 <monochrom> Can you add fprint(stderr's to the C code?
11:40:16 <geekosaur> you'd be able to trace back to the start of the call, at least
11:40:19 <bqv> The c code isn't mine :D
11:40:25 <bqv> Its a library
11:40:43 <bqv> Eh, I suppose I could recompile it
11:40:49 <sm[m]> yes, people successfully use gdb for this kind of thing I believe
11:40:57 <bqv> Thats a nuclear option though
11:41:21 <bqv> sm[m]: is there a trick to it or will it work ootb?
11:41:56 <pjb> nowadays we have the sources almost all the time, so you can just edit and recompile the library to help debug.
11:41:57 <sm[m]> I don't know gdb unfortunately.. someone here will know, otherwise try #ghc
11:42:18 <pjb> Sometimes there are already various DEBUG defines you can set to add traces.
11:42:29 <sm[m]> sometimes it's easier to read code and think about what could be going wrong
11:42:56 <pjb> Depends on the kind of bug.  
11:43:35 <bqv> Ack, there's another complication
11:43:40 <pjb> But one problem with reading the code (when it's you who wrote it), is that if there's a bug, it's because you have bad expectation about what it does, so reading again only makes you think about the bad interpretation, not the actual real one.
11:43:53 <pjb> Hence running it with prints. Here the problems usually jump to the eyes.
11:44:11 <bqv> The program has to be executed by another certain launcher...
11:44:23 <bqv> That makes gdb a pain
11:44:56 <pjb> You can wrap your program in a shell script, to log the arguments and environment set up by the launcher.  Then you can replicate them in gdb.
11:45:25 <bqv> Its IPC
11:45:30 <bqv> And setuid
11:45:34 <bqv> Not environment
11:45:48 <pjb> gdb can also attach to a process that's already run, eg. if your launcher sets up pipes and communicate with your program.
11:45:56 <pjb> gdb attach command is great!
11:46:21 <bqv> yeah, that would be the plan, so it would just be a matter of getting it to break immediately on launch so I can catch it
11:46:58 <tomsmeding> can't you just put 'threadDelay 1000000' at the start of your haskell program
11:47:07 <tomsmeding> or well, perhaps add a zero
11:47:19 <bqv> Ahah, true
11:49:00 <tomsmeding> also if you want to postpone gdb for some reason (perhaps the library doesn't have debug symbols?), you can also run your program under 'strace -f -o log.txt'
11:49:10 <tomsmeding> and then grep the produced log.txt for the process ID if your program
11:49:32 <tomsmeding> (also -ff may be useful instead of -f, see the strace man page)
11:49:55 <tomsmeding> also maybe ltrace? though that's a bit hit and miss sometimes
11:50:11 <bqv> Oh that's a good point, yeah ltrace sounds an extremely easy win if it works
11:54:46 <bqv> You're kidding. Adding ltrace made the bug vanish
11:55:14 <maerwald> lolo
11:55:29 <maerwald> the beauty of debugging
11:55:57 <bqv> Extraordinary and inconvenient
11:56:07 <tomsmeding> does the library you call spawn new processes/threads?
11:56:17 <maerwald> space leak gone as soon as you enable heap profiling :p
11:56:32 <sm[m]> how about strace 
11:56:38 <bqv> No processes, but threads yes
11:56:51 <tomsmeding> I bet something in your system receives a signal, and thus quits, and there is a wrapper around that that swallows the non-zero exit code
11:57:07 <tomsmeding> where "system" is collection of processes that your launcher starts
11:57:39 <bqv> ha! Strace works too...
11:58:22 <tomsmeding> "works" as in prevents the exit?
11:58:26 <bqv> Yes
11:58:31 <tomsmeding> fascinating
11:58:35 <tomsmeding> try gdb and valgrind
11:58:59 <bqv> those are far more complicated, i don't think i can try them right now
11:59:15 <tomsmeding> "can" as in want to, or understand how to?
11:59:32 <sm[m]> presumably it's not being killed by the OOM killer
11:59:35 <bqv> it's just problematic because this is a display compositor, so it being STOPped means my pc is unusable
11:59:42 <bqv> i need a second machine to gdb it
11:59:46 <bqv> as i discovered a few minutes ago
11:59:47 <tomsmeding> oof
11:59:55 <tomsmeding> well, you can switch to a different tty :p
12:00:03 <bqv> you'd think...
12:00:06 <bqv> but no :p
12:00:11 <tomsmeding> assuming the ctrl-alt-FN thing still goes through
12:00:23 <bqv> had to ssh in via phone to kill gdb
12:01:30 <bqv> is the class of bugs that vanish under strace/ltrace known?
12:01:44 <bqv> or will i just have to wait to see what gdb does
12:02:06 * bqv !
12:02:10 <bqv> i can qemu this
12:02:12 <sm[m]> space leaks often vanish when you add haskell tracing. Not sure about your situation there
12:03:00 <sm[m]> but that's why I asked about memory usage
12:03:00 <bqv> sm[m]: i've compiled with and without executable profiling enabled
12:03:04 <bqv> i don't think it affected anything
12:03:16 <bqv> is that what you had in mind, or a specific kind?
12:03:31 <tomsmeding> FWIW, you can simulate ctrl-alt-FN over ssh by running 'sudo chvt N'
12:03:43 <bqv> ah, yes
12:03:44 <sm[m]> bqv: no I haven't suggested haskell profiling (since it sounded like a FFI/c-related issue)
12:04:01 <tomsmeding> run gdb in a tmux, start the thing, observe screen freeze, chvt over ssh, tmux a, and continue?
12:04:37 <bqv> hmm
12:04:45 <bqv> maybe worth a try
12:05:04 <tomsmeding> (I was honestly surprised that chvt over ssh works)
12:05:43 <sm[m]> bqv: I don't think this is your issue but I was hinting to watch it in top once to make sure it's not being killed for using all memory - since this is pretty common with haskell apps
12:06:21 <bqv> i imagine that would be logged in dmesg too, anyway, right?
12:06:30 <tomsmeding> (and because I use an external display with the laptop lid shut, switching to a different tty over ssh made the systemd-inhibit process I have running nonfunctional, thus immediately sending my laptop to sleep...)
12:06:47 <sm[m]> perhaps, probably so
12:09:02 <bqv> tomsmeding: nice! it worked
12:09:07 <tomsmeding> :D
12:09:10 <tomsmeding> and?
12:09:22 <bqv> not helpful, because it works in gdb too :D
12:09:22 <tomsmeding> convoluted hacks are best hacks
12:09:31 <tomsmeding> ๐
12:09:37 <tomsmeding> #fixed
12:09:51 <bqv> this is bizarre. am i just consigned to always run this with a debugger attached
12:09:53 <tomsmeding> is it reproducible outside tracing tools?
12:09:59 <bqv> to collapse the bug's wavefunction or something
12:10:05 <tomsmeding> does it happen always or just sometimes
12:10:09 <bqv> it is, yes, it's perfectly reproducible
12:10:24 <bqv> without strace/ltrace/gdb, the program always exits within a second
12:10:42 <bqv> exitcode 0, no relevant error logged
12:10:57 <tomsmeding> exitcode 0 also of your haskell process, or only of the launcher around it?
12:11:09 <bqv> oh, that's a good point! i hadn't checked.
12:11:31 <tomsmeding> c.f. my remark above that I bet something is getting a signal and the exit code is getting swallowed :p
12:11:37 <tomsmeding> I've seen this before
12:11:50 <tomsmeding> (I think)
12:12:08 <geekosaur67> +RTS -v0 ?
12:12:25 <geekosaur67> (C call interrupted by RTS itimer)
12:12:38 <bqv> ha
12:12:41 <bqv> you were right
12:12:44 <bqv> it's getting USR1
12:12:48 <bqv> but it is exiting with 0
12:13:18 <bqv> does haskell die on SIGUSR1?
12:13:59 <geekosaur67> anything that doesn't specifically handle it will die
12:14:17 <tomsmeding> $ man 7 signal
12:14:22 <tomsmeding> SIGUSR1 has 'Term' as the default action
12:14:34 <bqv> that seems extreme
12:14:39 <tomsmeding> USR1 is a really weird one to get though
12:14:46 <tomsmeding> most signals have Term as default, only a few don't
12:15:19 <bqv> i feel like it's the launcher sending it
12:15:23 <tomsmeding> SIGHUP, or SIGBUS/SIGSEGV, SIGPIPE, I would've expected
12:16:12 <bqv> i'll try adding a System.Posix.Signals handler
12:18:14 <tomsmeding> if the process doesn't actively catch USR1 somehow, it shouldn't exit with code 0 due to it, but rather code 138
12:18:22 <tomsmeding> (128 + (10 == SIGUSR1))
12:18:43 <bqv> i checked by using bash -c "prog; echo $?"
12:18:52 <bqv> it echoed 0, but maybe that's a bash quirk
12:19:28 <bqv> hang on, maybe it wasn't recieving it, maybe it was sending it
12:19:37 <monochrom> I don't know whether it's relevant. It may be safer to use the threaded runtime system (give -threaded to GHC at link time). This eliminates a SIGVTALRM that may interfere with some syscalls.
12:19:58 <bqv> i'm already using -threaded by necessity
12:20:07 <merijn> oh, oh, oh
12:20:13 <monochrom> Ah OK.
12:20:13 <tomsmeding> bqv: is your program starting X? maybe https://www.x.org/archive/X11R6.8.1/doc/Xserver.1.html#sect11 ?
12:20:18 <merijn> People are talking posix signals! My time to shine!
12:20:21 <merijn> You're all wrong
12:20:28 <bqv> tomsmeding: wayland, unfortunately
12:20:39 <monochrom> That sounds like s/shine/roast/, merijn. :)
12:20:42 <merijn> No clue what was being discussed, but per my usual heuristic it's a safe bet
12:20:47 <bqv> lmao
12:21:06 <merijn> 'cause no one ever gets signals right
12:21:15 * tomsmeding dies from apprehension
12:21:18 <monochrom> To be fair, on certain other topics, I'm the one to say "as usual, all of you were wrong"
12:21:22 * hackage foldl 1.4.10 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.4.10 (GabrielGonzalez)
12:21:34 <merijn> as for the safety of -threaded and signals the answer is pretty simple.
12:22:11 <merijn> While I haven't actually audited the signal handling code in GHC's RTS yet, I've concluded from discussions in #ghc that it's impossible to predictably and correctly handle posix signals in any runtime
12:22:45 <monochrom> Is that just the worst case? Or is that also the average case.
12:23:06 <tomsmeding> for that statement to be correct you'll have to define "any runtime" more precisely
12:23:12 <merijn> monochrom: The average case it "it'll probably approximate what you intended"
12:23:14 <bqv> oh
12:23:17 <bqv> tomsmeding: wait, yes it is
12:23:17 <tomsmeding> not saying that posix signals are a great design, but they _can_ work
12:23:21 <bqv> because xwayland
12:23:23 <merijn> tomsmeding: Either of the existing threaded/unthreaded runtimes
12:23:34 <monochrom> I have accepted approximations.
12:23:38 <tomsmeding> bqv: yes xwayland seems to inherit the same sigusr1 shenanigans from a quick web search
12:23:45 <bqv> (also i checked source, as i suspected, my program is sending USR1, not recieving it
12:23:48 <monochrom> (E.g., when I said "I no longer ask for great software")
12:24:07 <merijn> Basically, the threaded RTS *and* the "unthreaded" (confusingly) use multiple threads
12:24:31 <monochrom> But there is also the angle that I am not using POSIX per se, I am using specifically Linux.
12:24:35 <merijn> But do absolutely nothing to control which threads get signals, which means you have zero predictability of what gets interrupted when and what you can safely do in your handler
12:25:26 <merijn> monochrom: linux has never made anything from posix *more* robust :p
12:25:34 <bqv> ooh you bastard
12:25:36 <tomsmeding> so the runtime needs to handle the signal internally, then raise an asynchronous haskell exception or something at the earliest opportunity _outside_ the actual signal handler, at which point the haskell-level signal handler can run
12:25:40 <bqv> installing the USR1 handler fixed it
12:25:43 <tomsmeding> I assume the ghc runtimes do that?
12:25:49 <tomsmeding> bqv: yay!
12:26:07 <bqv> that's kinda frustrating because now i'm not entirely sure what's even happening here
12:26:11 <bqv> but oh well, it's solved at least
12:26:17 <merijn> tomsmeding: Essentially, what I've concluded from work a few years ago on signal handling in a multi-threaded runtime is that there's only one possible way you can get any kind of predictable behaviour
12:27:08 <merijn> You mask all signals in every thread, then have a single dedicated thread blocking on sigwait() (or it's pthread equivalent) and then have that thread set up the relevant flags/whatever to run user code
12:27:12 <merijn> Anything else is insanity
12:27:31 <bqv> but wait, even in haskell?
12:27:44 <merijn> bqv: In all languages
12:27:52 <geekosaur67> signals happen at a level below haskell
12:27:54 <bqv> won't the runtime behave vaguely predictably due to lightweight threads
12:27:56 <tomsmeding> bqv: some process in your tree, say P, assigns a SIG_IGN handler for SIGUSR1, and has another child process that still has the terminating SIG_DFL on SIGUSR1; then P starts xwayland, which detects SIG_IGN, sends SIGUSR1 to its parent which flows down to the other child, which terminates, which wreaks havoc
12:27:58 <tomsmeding> hypothesis
12:28:04 <tomsmeding> completely unproven :D
12:28:18 <merijn> bqv: Yes, but those haskell threads are stilling running on pthreads at some point
12:28:28 <merijn> s/stilling/still
12:28:30 <christo> in haskell you can have 2 threads running simmultaneously right? 
12:28:30 <bqv> hmm
12:28:38 <christo> or n threads
12:28:38 <merijn> christo: Sure
12:28:50 <christo> i might be make a version of tetris in haskell
12:28:55 <bqv> i mean moot point because i am using forkOS
12:28:58 <merijn> christo: GHC does N:M multi-threading, so your multiplex N haskell threads on top of M OS threads
12:29:00 <bqv> and -threaded
12:29:00 <christo> and do all the music running at the same time with euterpea
12:29:04 <tomsmeding> so merijn while you have a point about unpredictability of signals, it was _not_ actually the problem here ;)
12:29:05 <monochrom> merijn: I think every expert agrees on that strategy, yes.
12:29:08 <merijn> bqv: forkOS doesn't spawn OS threads
12:29:25 <merijn> bqv: forkOS just prevents your Haskell thread from migrating between OS threads
12:29:35 <bqv> right, bound thread
12:29:57 <bqv> but then given i have the bound thread running exclusively ffi code, i have at least 2 threads
12:29:59 <christo> in js i use canvas to draw, in haskell is there an equivalant? thx merijn
12:30:00 <bqv> right?
12:30:11 <merijn> christo: gloss, maybe?
12:30:39 <christo> and in terms of networking, are there api's for that in haskell? 
12:30:40 <monochrom> No, forkOS has to spawn a fresh OS thread. What you want to not-guarantee is that this doesn't mean Haskell code will run on that OS thread.
12:30:42 <christo> gloss? i'll look into it
12:30:44 <merijn> bqv: That depends, for example are the safe foreign imports or unsafe foreign imports
12:30:55 <merijn> christo: the "network" package? :p
12:31:03 <bqv> er, hard to say
12:31:06 <merijn> christo: It's basically a thin wrapper over posix sockets
12:31:08 <bqv> i'm using inline-c
12:31:08 <monochrom> Still, in practice, Haskell code will run on that OS thread, even though this fact is not future-proof.
12:31:24 <christo> so in theory i can make an online tetris in haskell ?
12:31:31 <merijn> monochrom: No, forkOS explicitly does not spawn a fresh OS thread
12:31:38 <christo> or tetris client
12:31:43 <monochrom> Therefore, I find "forkOS doesn't spawn an OS thread" is at best academic scaremongering, at worst a downright lie.
12:32:20 <merijn> monochrom: forkOS spawns a bound thread, it doesn't affect the number of OS threads in existence
12:33:18 <monochrom> Then you wouldn't have enough number of OS threads for sufficiently many independent C calls.
12:34:08 <merijn> monochrom: What? How are those two things remotely related to each other?
12:35:21 <monochrom> Do you mind taking a look at my answer already written up at http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml ?  You can scroll down to the section "thread-local FFI calls"
12:35:53 <geekosaur67> those are I/O manager threads, and it'll block waiting for one to become available if needed
12:36:28 <geekosaur67> separate pool from forkIO / forkOS threads
12:37:00 <bqv> strange. the signal handler definitely solves the issue, but when i change the handler to do "something", it doesn't do that thing (but still solves the issue)
12:37:30 <c_wraith> as I understand it, the only guarantee forkOS makes is that all safe FFI calls it makes will be on the same OS thread.  Nothing about having exclusive access to that OS thread.
12:37:48 <merijn> c_wraith: That's what the GHC docs say, yes
12:38:21 <c_wraith> does the RTS actually give a stronger guarantee at this time?
12:38:38 <merijn> Possibly, according to monochrom 
12:39:55 <bqv> surely forkOS twice then has to spawn at least one thread (or reuse one), because the resultant bound threads can't be the same or you'd run into concurrency problems
12:40:23 <tomsmeding> unless there's already one laying around
12:40:53 <bqv> exactly, yeah
12:41:07 <merijn> bqv: Why would you run into concurrency problems?
12:41:32 <merijn> bqv: I don't see any conflict in having two bound threads on the same OS thread
12:41:34 <geekosaur67> I don't think anything guarantees there won't be a block waiting for an available thread to run your FFI call on
12:41:35 <bqv> merijn: envision a situation where both FFI threads block indefinitely
12:41:40 <tomsmeding> bqv: the only reason I can think of that that happens (handler solves issue but doesn't run itself), is that some process between you and the SIGUSR1-sender detects that the SIGUSR1 handler is not SIG_DFL and therefore installs its own handler
12:41:47 <merijn> bqv: Well, "don't do that, then" :)
12:41:49 <bqv> lmao
12:41:50 <tomsmeding> but that would be obscure
12:41:52 * hackage HDBC-postgresql 2.4.0.0 - PostgreSQL driver for HDBC  https://hackage.haskell.org/package/HDBC-postgresql-2.4.0.0 (ErikHesselink)
12:42:24 <merijn> bqv: Actually, that's already a problem if only one of them blocks indefinitely
12:42:34 <bqv> tomsmeding: that sounds bizarre
12:42:39 <monochrom> Huh? I thought the whole point of "safe FFI call" is it can block all it wants and no one else is held waiting.
12:42:43 <merijn> bqv: If monochrom is right (which at casual glance of the code is probably true)
12:42:46 <tomsmeding> bqv: I'm kind of hoping it's not true
12:42:50 <merijn> bqv: Then that can't happen
12:43:14 <merijn> monochrom: It looks like you are probably correct per the code, but that's not what GHC guarantees per the docs
12:43:26 <monochrom> The docs are outdated.
12:43:38 <merijn> Now, maybe the docs are wrong and don't provide strong enough guarantees
12:44:05 <monochrom> There is even an old version of the doc that positive guaranteed you would have only one capability, ever.
12:44:13 <monochrom> Now look at -N100.
12:44:31 <merijn> monochrom: once you do a safe foreign call the capability is unlocked
12:44:33 <bqv> signal() is a syscall, i can strace this...
12:44:43 <merijn> So if you have another thread then safe foreign calls can never block Haskell code, sure
12:44:47 <tomsmeding> bqv: watch for sigaction() instead I think
12:45:08 <merijn> But I'm pretty sure that you can run out of safe call threads if you keep spamming enough blocking safe calls
12:45:09 <tomsmeding> though things might detect being ptrace'd >:D
12:45:51 <merijn> bqv: I hope to god that signal() isn't called
12:46:13 <merijn> signal is broken and deprecated for two decades, it should be sigaction() as tomsmeding points out
12:47:25 <bqv> i see a lot of rt_sigaction
12:47:32 <bqv> none refer to usr1
12:47:50 <tomsmeding> welcome to the world of strace, where you suddenly see the loads of crap that everything executes
12:47:59 <bqv> in fact there's no reference to usr1 at all
12:48:04 <bqv> unless it's numeric
12:48:09 <monochrom> I like signal() when I'm just tell it to SIG_IGN or SIG_DFL.  It's dreadful to have to fill out a form for just those.  And I always have trouble deciding whether the other fields really matter or not for those cases.
12:48:14 <bqv> 128?
12:48:38 <tomsmeding> bqv: 10
12:49:04 <tomsmeding> monochrom: glibc's surface signal(3) probably calls sigaction(2) under the hood
12:49:04 <bqv> nothing for that either
12:49:07 <bqv> bizarre
12:49:15 <merijn> monochrom: Those two are defensible, but as soon as you install an actual handler it's unusably broken
12:49:32 <monochrom> Right, I know that.
12:50:05 <monochrom> I'm a good kid, I use sigaction and make careful decisions about the options, when it's my handler.
12:50:34 <bqv> ah wait
12:50:45 <monochrom> And those fields are actually useful for handlers.
12:51:11 <bqv> no, even with strace i should at least see the handler installed, right?
12:51:19 <bqv> what is going on...
12:51:26 <tomsmeding> with 'strace -f' yes
12:51:31 <bqv> why -f?
12:51:34 <bqv> i don't fork
12:51:37 <geekosaur67> follow forks
12:51:41 <tomsmeding> your children do
12:51:45 <geekosaur67> but the parent does, you said?
12:51:51 <tomsmeding> that
12:51:54 <tomsmeding> sorry
12:52:02 <bqv> i'm running `launcher -- strace program`
12:52:11 <bqv> so strace's immediate child should be traced
12:52:12 <tomsmeding> use -f anyway to be sure :p
12:52:22 <bqv> but then i end up tracing x11 ;_;
12:52:28 <bqv> that's ..not pretty
12:52:32 <tomsmeding> which might very well be the culprit
12:52:37 <tomsmeding> use -ff perhaps
12:52:47 <bqv> see you in a minute or two...
12:52:49 <tomsmeding> splits out the log for separate processes
12:53:10 <monochrom> -fff and -ppp...
12:54:11 <bqv> oh good god that's too many processes
12:54:27 <bqv> but at least now i have some hits for USR1
12:54:53 <bqv> 149, to be exact
12:54:53 <monochrom> P.S. I am a robot and I always tried to train myself to have 10 levels of consistent strength for the range from ppp to fff.
12:55:05 <tomsmeding> you may also like --trace for strace, or just rely on good-old grepping (better)
12:55:28 <bqv> yeah, it's ok, i'm in emacs, so i can just smartly grep through this
12:55:55 <tomsmeding> monochrom: I have the fortune of not being classically trained so I just take those dynamics markings as a general guideline :D
12:55:59 <bqv> but i have truly no idea how to interpret any of it
12:56:07 <monochrom> Yeah data scientists recommend saving all data and worrying about mining later.
12:56:31 <tomsmeding> how many lines is 'grep USR1 *'
12:56:39 <tomsmeding> $ grep USR1 * | wc -l
12:56:44 <bqv> 149
12:56:44 <monochrom> Oh, I think classical music people also take liberty. They too are against my robotic way.
12:56:55 <tomsmeding> bqv: pastebin plz
12:57:14 <monochrom> Or at least, fff for one piece don't have to be the same as fff for another piece.
12:57:25 <tomsmeding> makes sense
12:57:45 <tomsmeding> some composers are less liberal with their fff's I'd think, rather calling that f or ff
12:57:55 <monochrom> This is why I'm better off as a computer scientist or programmer or the like.
12:58:12 <tomsmeding> apparently unicode has symbols for them ๐ ๐
12:58:31 <monochrom> If the code says "x = 1" then it is 1, what do you mean musicality allows you to change it to 2.
12:58:58 <tomsmeding> something with physicists and pi?
12:59:08 <bqv> termbin.com doesn't like recieving this many lines...
12:59:12 <tomsmeding> 149?
12:59:19 <bqv> oh no i was gonna send the full thing
12:59:20 <tomsmeding> sounds like a crappy pastebin, try mine
12:59:26 <dsal> bqv: I think you're just supposed to dump them into irc if you have too many lines.
12:59:26 <tomsmeding> oh lol
12:59:35 <bqv> it's only 1.9mb
13:00:02 <tomsmeding> tar cz * | curl --data-binary @/dev/stdin https://tomsmeding.com/gooi/things.tar.gz
13:00:50 <bqv> i can't tell if that succeeded or not
13:00:55 <tomsmeding> did it print a URL
13:01:05 <bqv> oh, yes
13:01:13 <bqv> https://tomsmeding.com/vang/IZn8dA/things.tar.gz
13:01:19 <bqv> also https://tomsmeding.com/vang/9OW8PN/things.tar.gz
13:02:21 <tomsmeding> identical?
13:02:28 <bqv> yeah lol
13:02:33 <bqv> i did it twice by mistake
13:02:57 <tomsmeding> (link is valid for 24 hours btw)
13:03:15 <tomsmeding> cabal > stack I approve
13:03:23 <bqv> :D
13:05:58 <tomsmeding> why does process 1691973 write out "wl_display_create() = 0x00007f4770000c80" c h a r a c t e r  b y  c h a r a c t e r
13:06:10 <bqv> that's coming from haskell, tbf
13:06:33 <bqv> i think it might be because i build that string using a monoid
13:06:43 <bqv> (execWriter)
13:06:52 <tomsmeding> ah no it's just String being String I think
13:06:58 <bqv> heh
13:07:05 <tomsmeding> but that's your haskell, apparently?
13:07:23 <bqv> yes
13:07:35 <bqv> (that's a hilarious sideeffect, btw)
13:07:53 <tomsmeding> (line 1427 in your log)
13:08:01 <bqv> yeah i found it
13:12:17 <bqv> so the launcher sets handlers using sigaction on USR1
13:12:19 <tomsmeding> merijn: apparently the haskell runtime uses signalfd4(2) and immediately after masks the signal
13:12:25 <bqv> it's using that x11 mechanism
13:12:27 <tomsmeding> (TIL sigalfd4)
13:12:39 <bqv> perhaps the haskell runtime is clearing something it shouldn't?
13:13:22 <tomsmeding> what process are you starting directly after you attach a handler to SIGUSR1 in haskell code?
13:13:36 <tomsmeding> (process 1692017)
13:14:19 <bqv> i don't see anything fork-like happening around there
13:14:36 <bqv> the immediate next line is basically a call to wl_display_create()
13:14:45 <bqv> then a load of c marshalling
13:15:15 <bqv> (actually, none of my code specifically creates any processes, but the launcher does, and the library might)
13:15:33 <tomsmeding> ah
13:16:15 <bqv> oh
13:16:37 <bqv> would it matter if the handler was within a forkOS bound thread that's blocked indefinitely?
13:16:45 <bqv> i thought because it's haskell code, it wouldn't be bound
13:16:51 <bqv> but maybe it's blocked for that reason?
13:17:04 <tomsmeding> ยฏ\_(ใ)_/ยฏ
13:17:29 <tomsmeding> I'm actually not all that familiar with the intricacies of forkOS, defer to the other people that contributed earlier :p
13:18:11 <tomsmeding> AH
13:18:52 <tomsmeding> okay I was wrong, that signalfd4 is not the haskell rts, that's whatever library you're using
13:19:03 <bqv> oh, that's interesting
13:19:22 <tomsmeding> early on there is an rt_sigaction that binds a handler to USR1; that'll be your code, because quickly after there is that c h a r a c t e r call to wl_display_create()
13:20:11 <tomsmeding> later, though, at :13587-13588, your own haskell process (but I think the library, really) makes a signal FD and then SIG_BLOCK's USR1 in your process
13:20:22 <tomsmeding> hence your handler doesn't fire
13:20:49 <bqv> what on earth
13:20:58 <geekosaur67> that's documented
13:21:05 <geekosaur67> go read the signalfd4 manpage
13:21:31 <tomsmeding> geekosaur67: I think bqv is not reacting to the syscalls' behaviour, but the behaviour of the library he's using
13:21:40 <bqv> yeah
13:22:00 <bqv> oh interesting, i think i know what call's doing that
13:22:08 <bqv> maybe if i put the handler after that then
13:22:23 <geekosaur67> I expect it just lists out all the non-SIG_DFL signals and does the signalfd4() thing on them
13:22:29 <geekosaur67> so it's just not expecting your handler
13:22:47 <bqv> well actually, to be honest that's perfectly reasonable behaviour, i was just confused as to how it was occuring
13:22:58 <bqv> but as long as nothing's broken, i can live with just setting an ignore handler
13:22:59 <tomsmeding> geekosaur67: it specifically only does it for CHLD and USR1
13:23:36 <tomsmeding> probably that's the best approach bqv 
13:24:27 <tomsmeding> note that process 1691972 also puts a SIG_BLOCK on USR1 at line 3922, but that's for a different process (not sure which)
13:24:50 <bqv> yes, by my guess, one is for my process, one is for Xwayland
13:26:01 <tomsmeding> ah at some point your haskell process (but really the library probably) forks to 1692017, puts a SIG_IGN handler on USR1, and then exec's Xwayland
13:26:17 <tomsmeding> so it's not the block that's the culprit, it's that overwrite
13:26:21 <tomsmeding> I think
13:26:30 <tomsmeding> (line 13615)
13:26:59 <bqv> I actually estimate i might be able to still hook into the signal, because it looks like it's fed into the wayland event loop
13:27:24 <bqv> it'll just look bizarre that i set the signal to ignore on one line and then hook into it using a completely different mechanism a few lines below
13:27:35 <bqv> thanks, wayland
13:27:57 <tomsmeding> that's what a code comment is for :)
13:28:23 <tomsmeding> nice search, thanks for the evening entertainment bqv 
13:28:32 <bqv> bah, nah, didn't work
13:28:37 <bqv> hehe, no problem
13:30:11 <tomsmeding> so in hindsight, strace/ltrace/gdb probably "fixed" the problem by handling signals or something?
13:33:19 <bqv> yeah, exactly
14:12:28 <Cheery> Is there any libraries written for text layouting/typesetting in haskell?
14:13:33 <Uniaika> hmm, not that I know of
14:14:02 <dsal> HaTeX
14:14:12 <Cheery> I am curious because I wnoder what structure of something like XML/HTML is necessary.
14:14:28 <dsal> If it doesn't exist... that's probably fine.
14:14:44 <Cheery> HaX
14:15:10 <Cheery> there's luispedro's hex
14:15:34 <Cheery> it says not complete
14:20:27 <Cheery> Hm. I could port my reimplementation
14:22:45 <Cheery> hatred, haskell typesetting
14:23:17 <jackdk> is there a canonical two-type-arg version of `Proxy`?
14:23:55 <gobbleguy> Proxy (x,y)? :)
14:25:31 <kupi> hi
14:25:50 <jackdk> gobbleguy: ha. I'm considering a type like `data P p q f g a b = P (p a (f b)) (q b (g a))`, with the idea that generally you have `p ~ q ~ (->)` but if you need to give up roundtripping, you can kill one side or the other by putting a `data Proxy2 a b = Proxy2` in for `p` or `q`
14:25:55 <kupi> here https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Foldable.html#foldlM how foldr is called with 4 parameters? when I click the definition it only shows 3
14:26:43 <jackdk> kupi: note the function `return` is passed in, so the result of the fold is itself a function
14:27:02 <jackdk> Cheery: consider looking at pretty-printer libraries and/or pandoc?
14:28:23 <kupi> so f a b is the same as (f a) b?
14:28:57 <PerseusPlease> hi. 
14:29:37 <jackdk> kupi: if you're talking about function application, yes. It associates to the left
14:30:20 <PerseusPlease> Super basic question. For a given module (in this case Data.Binary.Get) how do I know what name needs to go in build-depends? I haven't been able to assign rhyme or reason to it so far
14:30:29 <PerseusPlease> ?
14:31:27 <jackdk> PerseusPlease: this one? https://hackage.haskell.org/package/binary-0.10.0.0/docs/Data-Binary-Get.html
14:32:20 <PerseusPlease> yep. but could just as well apply as a question to any of the modules I've included so far, I've been able to guess on the others but they often don't make sense
14:34:48 <jackdk> The package name is `binary`. If you click "Contents" in the top-right, it takes you to the top-level page for that package. The name also appears in the top-left of a module's documentation (`binary-0.10.0.0: Binary serialization for Haskell values using lazy ByteStrings`) and in the URL on hackage haddocks
14:35:21 <PerseusPlease> thank you!
14:35:32 <PerseusPlease> that will make life much easier.
14:36:13 <jackdk> welcome
14:38:42 <monochrom> The URL already contains the package name.
14:49:29 <dibblego> foldr takes 1 parameter
14:50:41 <PerseusPlease> monochrom, ah yes so it does, now that I know what I'm looking for.
14:52:35 <koz_> Is there a way to get all transitive deps of a Hackage package?
14:53:18 <N3RGY> koz_: maybe cabal-dependency-licenses ?
14:53:33 <monochrom> Yikes haha
14:54:15 <monochrom> But I use "cabal freeze" (but I have to first write a foo.cabal that has a build-depends line for the starting point)
14:55:05 <monochrom> So yeah, basically hacks and hammers that solve a much bigger problem and get you the transitive closure as a side effect.
14:55:15 <koz_> OK, a different question: I have a .prof that says a particular function is eating a lot of time. However, I assume it's being called _by_ something. Is there an easy way to tell what's calling said function? I can't quite make sense of the .prof layout.
15:07:11 <hekkaidekapus> koz_: 1) Transitive deps as a graph: `cabal-plan dot`.
15:07:29 <koz_> hekkaidekapus: Just as a list is fine.
15:07:35 <hekkaidekapus> 2) .prof visualisation: <https://github.com/jaspervdj/profiteur>
15:08:20 <hekkaidekapus> 3) Nowadays, GHC has so-called โeventsโ, read more at <file:///home/tchouri/Downloads/eventful%20GHC-Alp%20Mestanogullari_2019-09-24.html>
15:08:39 <hekkaidekapus> oops!
15:08:43 <hekkaidekapus> <https://www.well-typed.com/blog/2019/09/eventful-ghc/>
15:09:39 <monochrom> Oh, cabal-plan is a much better tool for this.
15:09:51 <monochrom> I keep forgetting that it exists.
15:09:52 <koz_> profiteur looks great!
15:10:03 <koz_> (I am disappoint it wasn't named 'profiterole')
15:11:14 <koz_> Let me try profiteur.
15:14:00 <koz_> hekkaidekapus: Is cabal-plan a separate thing?
15:14:05 <koz_> Like, where do I get it?
15:14:21 <hekkaidekapus> Itโs part of phadej-verse :)
15:14:42 <koz_> Lol, the Phadej Extended Universe.
15:14:50 <hekkaidekapus> Rather haskellari-verse :P
15:15:50 <Cheery> Is there a function to clear out ()s from a type?
15:16:06 <Axma45768> ()'s are a type...
15:16:12 <Axma45768> you can't just remove them
15:16:19 <Cheery> eg. ((), a) -> a
15:16:31 <Axma45768> @djinn ((), a) -> a
15:16:31 <lambdabot> f (_, a) = a
15:16:57 <Cheery> ok, then (((), a), ()) -> a
15:17:19 <hekkaidekapus> koz_: <https://github.com/haskell-hvr/cabal-plan> (Another oops! Itโs hvr-verse actually.)
15:17:22 <Cheery> I mean I'd want a routine that does this, so I don't need to.
15:17:35 <koz_> hekkaidekapus: Thank you so much!
15:17:41 <hekkaidekapus> np
15:19:18 <hekkaidekapus> (Both profiteur and cabal-plan are also on Hackage.)
15:20:22 * hackage hackage-security-HTTP 0.1.1.1 - Hackage security bindings against the HTTP library  https://hackage.haskell.org/package/hackage-security-HTTP-0.1.1.1 (HerbertValerioRiedel)
15:20:33 <Axma45768> Cheery: what would the type of the function you want be?
15:21:54 <Cheery> well it could be (a -> Canon a), or Canon a b => a -> b
15:22:56 <Axma45768> I think the answer to your question is "no", it doesn't currently exist, but it looks like you might have a way to get there (though what should happen in the ((),()) case) 
15:23:14 <Cheery> it should become ()
15:26:36 <Axma45768> should like it may be doable with a type family, but I'm unsure what the base case would be; since both () -> () and !() -> !() both need to be there
15:26:44 <Axma45768> give it a go and see if you can make it work
15:40:15 <bradparker> Hi all, can anyone direct me to some resources that explain why http://hackage.haskell.org/package/servant-server-0.18/docs/Servant-Server.html#v:serve needs both the `Proxy api` argument and the `Server api` argument to "get hold of" `api`?
15:40:25 <bradparker>  I remember reading some discussion about why the `Server api` argument wasn't enough (something about it being a type-family iirc) but I can't find my way back to it, can't remember the gist ...
15:47:08 <gobbleguy> bradparker: Server is type Server api = ServerT api Handler
15:47:23 <gobbleguy> ServerT is an associated type family of the HasServer class
15:47:31 <gobbleguy> type families are not injective
15:47:59 <gobbleguy> so that means just knowing what they evaluated to you can't definitively determine their arguments
15:49:27 <gobbleguy> If I told you 'not x == False' you could work out what x was, but if I told you 'null xs == False' you wouldn't be able to tell me what xs was. not is injective, null is not
15:55:07 <bradparker> Great, thanks for that :). `ServerT SomeApi => SomeArg -> Handler SomeResult` has lost a lot of information about `SomeApi`
15:56:26 <bradparker> Many possible arguments, with things like `"namespace" :> ...` and `Get '[JSON] ...` can get the same result
15:58:15 <bqv> man i sure have missed haskell
15:58:31 <bqv> haven't quite missed the analysis paralysis
15:58:36 <bqv> but i've missed these beautiful types
16:01:39 <Axma45768> gobbleguy: that's a great explanation, nice work
16:03:05 <gobbleguy> Using glirc?
16:03:57 <Axman6> I'm using glirc
16:03:59 <gobbleguy> If you want to avoid my conservative nickname fallback code you can add more nicknames to your list of alternatives :)
16:04:14 <Axman6> I was surprised how good that fallback was actually
16:04:34 <Axman6> gobbleguy = glguy?
16:04:36 <gobbleguy> yeah
16:04:50 <Axman6> everything makes sense
16:04:57 <gobbleguy> turn on "show-accounts: yes" so you don't have to guess :)
16:05:20 <gobbleguy> >>> 16:01 Axma45768(axman6): gobbleguy: that's a great explanation, nice work
16:09:36 <monochrom> Yikes, gobbleguy, is it Thanksgiving turkey theme now? :)
16:10:06 <monochrom> "Yeah after Steam Halloween Sale we're looking forward to Steam Autumn Sale!"
16:10:27 <Axman6> it's Spring tho
16:10:38 <gobbleguy> I just want IRC to be fun ^_^ What's more fun than seasonal nicknames?
16:10:47 <koz_> Axman6: Damn that Northern Hemisphere centrism.
16:11:17 <Axman6> i reckon, bloody seppos
16:11:24 <gobbleguy> Does Steam show that it's an Autum Sale in the southern hemisphere?
16:11:30 <gobbleguy> +n
16:12:11 <Axman6> our internet isn't fast enough to get steam
16:12:39 <gobbleguy> Warm-water Autumn Sale!
16:49:47 * Axman6 considers /nick Axmurderman6
17:04:51 * hackage ttc 0.3.0.0 - Textual Type Classes  https://hackage.haskell.org/package/ttc-0.3.0.0 (TravisCardwell)
17:06:22 * hackage predicate-typed 0.7.4.2 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.4.2 (gbwey)
17:06:34 <bqv> writing to a tchan is nonblocking, right?
17:06:48 <bqv> linked list, surely it is
17:23:10 <edwardk> for some reason whenever i see tchan i think 4chan
17:24:10 <bqv> if we assume the *chans are counting in base32 it's a possibility
17:26:37 <monochrom> Yes TChan is a mutable linked list.
17:40:38 <dmwit> What does "blocking" mean to you in the context of STM?
17:42:24 <dmwit> Perhaps one sensible meaning would be "calls retry explicitly" (as opposed to retrying because of staleness in the transaction log).
17:43:12 <dmwit> If that's the meaning you like, then you can just read the whole source of `writeTChan` (it's only four lines long!) and see that it doesn't mention retry.
17:43:17 <dmwit> https://hackage.haskell.org/package/stm-2.5.0.0/docs/src/Control.Concurrent.STM.TChan.html#writeTChan
17:45:51 <dsal> e.g., go chan writes block until something is ready to receive from the channel.
17:46:07 <dsal> But yeah, reading STM code makes me a little teary eyed.
17:49:38 <bqv> i think my question makes less sense than i realised, reading that
18:13:31 <dsal> STM is super composable, so you can make such an exchange (with timeout) if you need it.
18:14:54 <dsal> Which, I guess is just TMVar
18:17:52 * hackage gargoyle-postgresql 0.2.0.1 - Manage PostgreSQL servers with gargoyle  https://hackage.haskell.org/package/gargoyle-postgresql-0.2.0.1 (abrar)
18:42:35 <ski> "type families are not injective" -- unless declared to be
19:10:18 <monochrom> Hahaha, go chan has writer's block, haskell MVar has reader's block.
19:11:00 <ezzieyguywuf> I'm going to try converting my beancount journal to hledger today
19:11:01 <ezzieyguywuf> wish me luck!
19:11:34 <monochrom> More puns in #haskell-offtopic
19:18:47 <MarcelineVQ> ezzieyguywuf: ask in #hledger if you get stuck
19:22:19 <ezzieyguywuf> MarcelineVQ: ๐
19:41:52 * hackage crdt-event-fold 1.1.0.0 - Garbage collected event folding CRDT.  https://hackage.haskell.org/package/crdt-event-fold-1.1.0.0 (rickowens)
21:15:13 <bradparker> ski: thanks :) (TIL https://gitlab.haskell.org/ghc/ghc/-/wikis/injective-type-families). So it's more accurate to say that the the `Proxy api` argument is needed because the type family `ServerT` is not injective.
21:54:22 * hackage egison-pattern-src 0.2.1.2 - Manipulating Egison patterns: abstract syntax, parser, and pretty-printer  https://hackage.haskell.org/package/egison-pattern-src-0.2.1.2 (coord_e)
21:55:24 * hackage egison-pattern-src-th-mode 0.2.1.2, egison-pattern-src-haskell-mode 0.2.1.2 (coord_e): https://qbin.io/look-gothic-x917
22:40:10 <bqv> phew
22:40:15 <bqv> been fiddling with types for 5 hours
22:40:21 <bqv> finally got it to compile again
22:40:56 <yushyin> the pleasure of haskell :)
22:41:04 <bqv> indeed :D
23:37:08 <dminuoso> The annoying part of this, it promotes yak shaving!
23:37:25 <dminuoso> "Refactor half your codebase? Easier done than said"
23:43:23 <bqv> I couldn't care less. Programming is my hobby, I'll happily shave yaks all day long
