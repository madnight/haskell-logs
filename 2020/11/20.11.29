01:08:44 * hackage ede 0.3.0.0 - Templating language with similar syntax and features to Liquid or Jinja2.  https://hackage.haskell.org/package/ede-0.3.0.0 (BrendanHay)
02:14:43 * hackage implicit-hie 0.1.2.5 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.2.5 (Avi_Dessauer)
04:07:38 <Iolen> ░▓░▓░▓░▓░▓░▓░▓░▓░▓░ Hello ..... ░▓░▓░▓░▓░▓░▓░▓░▓░▓░
04:13:00 <Iolen> ░▓░▓░▓░▓░▓░▓░▓░▓░▓░ Everyone invited to new chat place at: http://iaaaaa.mywebcommunity.org/ 
04:13:01 <Iolen> Thank You for attention ! ░▓░▓░▓░▓░▓░▓░▓░▓░▓░
04:14:29 <__monty__> ,where mods
04:15:16 <__monty__> @ops
04:15:16 <lambdabot> Maybe you meant: pl oeis docs
04:15:53 <__monty__> Anyone remember the correct command?
04:15:56 <__monty__> @where ops
04:15:56 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
04:16:04 <__monty__> Success \o/
04:16:11 <siraben> it's a bot, spammed multiple channels
04:16:28 <f-a> yup, multiple people reporting on #freenode
04:16:53 <dcoutts> hmm, I don't seem to have my op rights
04:18:07 <__monty__> dcoutts: You can always have chanserv op you if you have the correct flags.
04:28:13 --- mode: ChanServ set +o dcoutts
04:28:16 <dcoutts> yay
04:28:27 --- kick: Iolen was kicked by dcoutts (Iolen)
04:28:30 --- mode: ChanServ set -o dcoutts
04:37:14 * hackage ede 0.3.1.0 - Templating language with similar syntax and features to Liquid or Jinja2.  https://hackage.haskell.org/package/ede-0.3.1.0 (BrendanHay)
04:50:22 <avdb> Am I allowed to ask people to make my spaghetti code better? I wrote a small program but there's a lot of repetition and I don't know how to make it shorter ...
04:51:29 <f-a> avdb: sure, but maybe run hlint first
04:51:54 <avdb> I use ALE but it doesn't detect anything
04:51:57 <avdb> http://codepad.org/nIz9DRYA
04:52:18 <avdb> ALE is a collection of linters including hlint right?
04:53:02 <f-a> no idea what ALE is to be honest
04:53:27 <avdb> https://github.com/dense-analysis/ale
04:54:35 <f-a> ok
04:54:52 <f-a> instead of guards, why not pattern match?
04:55:21 <f-a> also is `seconds` really a parameter?
04:55:34 <f-a> *really needed
04:55:58 <avdb> It's indeed probably possible to make it point-free
04:56:14 <avdb> Can I add the numbers to the data types instead of the function?
04:56:33 <f-a> of course
04:57:02 <avdb> Wasn't sure if pattern matching would work, just `ageOn Mars = undefined`?
04:57:19 <avdb> If I do that I'm still writing out the function multiple times
04:57:26 <f-a> data Plantet = PlanetTag Float      and data PlanetTag = Mars | …
04:57:56 <f-a> pattern matching would work, yeah
04:58:03 <avdb> Wait let me first fix the pattern matching
04:58:23 <f-a> what does ageOn computes, exactly?
04:59:27 <f-a> (to rephrase, why `ageOn :: Planet -> Float -> Float` instead of `ageOn :: Planet -> Float`)
05:05:54 <avdb> "Given an age in seconds, calculate how old someone would be on the following planets"
05:06:21 <f-a> oh, now I see
05:06:24 <avdb> No idea, I'm on Exercism and they recommended to use "ageOn :: Planet -> Float -> Float"
05:06:36 <f-a> ok
05:06:45 <avdb> You need to first calculate someone's age on earth and convert it to the other planets if necessary
05:07:32 <f-a> I would probably write
05:07:50 <f-a> where earthAge = seconds * 3155760
05:08:06 <f-a> and put `earthAge` in planet == Earth = earthAge rather
05:08:50 <avdb> I can't make it point-free by the way
05:08:53 <avdb> I don't know why
05:08:56 <avdb> This is what I currently have
05:09:01 <f-a> do you *need* to make it pointfree?
05:09:21 <avdb> http://codepad.org/OTevDnrJ
05:09:32 <avdb> I don't need to I just want it to be shorter
05:10:24 <avdb> Do where bindings work with pattern matching?
05:11:11 <f-a> why `(*) 0.2408467 $ ageOn Earth`
05:11:22 <f-a> instead of `0.24 * ageOn Earth`?
05:12:06 <f-a> and no, where spans over guards but not patterns. But you can be crafty like this
05:12:28 <avdb> So I can't pattern match anymore?
05:12:38 <avdb> If I use where
05:12:39 <f-a> you can with a case … of
05:12:40 <f-a> one second
05:14:35 <f-a> http://www.ariis.it/link/t/paste21061-0 there, something like this
05:14:50 <f-a> emh, bar the typos
05:16:43 <avdb> Is that the *best* possible solution?
05:18:01 <f-a> it is clear, it is not redundant. You *have* to write those 84.016846 numbers down somewhere in your program, whether inside a function or in a helper function or in a datatype
05:18:25 <avdb> There is improvement so I will stick with your solution, in real projects it's probably better to work with a database for such stuff
05:18:29 <avdb> Right?
05:19:03 <f-a> you can have an helper function like
05:19:03 <f-a> factor :: Planet -> Float
05:19:04 <f-a> factor Mercury = 13 
05:19:06 <f-a> ⁝
05:19:43 <f-a> and then ageOn becomes
05:19:44 <f-a> ageOn p a = let ageEarth = a * 2 in ageEarth * factor p
05:19:46 <avdb> You mean to make it easier to separate data from the function?
05:20:05 <avdb> That's even better imo
05:20:19 <f-a> or even use an assoc list. My point is, *somewhere* the data has to be written
05:20:26 <avdb> assoc?
05:20:29 <avdb> Never heard of that before
05:20:38 <f-a> sorry, it is just a 
05:20:53 <f-a> [(Pluto, 18), (Earth, 1) …] list
05:21:15 <avdb> Oh yea exactly what I first thought when I started the exercise, it's just that I'm bad with ADT :P
05:21:31 <f-a> but it was just a thought, the helper function is better (GHC can warn you if you miss a constructor, etc.)
05:22:15 <f-a> just relax and remember that one of the strong points of Haskell is easy refactoring
05:22:36 <f-a> if you come up later with a more elegant solution, you can refactor easily thanks to types, inference
05:30:47 <avdb> Alright, I just used a factor helper function and it looks much better now since it's a one line function
05:31:19 <avdb> I installed GHC and Cabal with ghcup, any idea how I can install Stack?
05:31:59 <Sose> avdb: I've installed ghc and cabal with ghcup and just used Stack's own install script for Stack and everything seems to work fine
05:34:05 <avdb> Sose: Thanks, but can Stack update itself?>
05:34:38 <Sose> I think it can with `stack upgrade`
05:34:57 <Sose> pretty new to haskell myself and I just installed everything recently so I haven't had the need to upgrade much :)
05:52:44 <delbmuts_> Hi again, is there a function "Reader Int a -> (ResourceT IO) a"? I'd like to get rid of the "undefined" in https://paste.debian.net/hidden/2b257950 but don't know how. Thanks.
05:57:10 <frdg> `toHtml :: blaze-markup-0.8.2.5:Text.Blaze.ToMarkup a => a -> Html` What is the best way to go about finding a type that satisfies this constraint? Is there something like `:type` in ghci where I can enter a constraint and get back Types that satisfy it?
05:57:36 <dminuoso> delbmuts_: That looks like a strange thing to do.
05:57:48 <dminuoso> delbmuts_: What's the intention?
05:58:36 <ski> delbmuts_> :t transPipe
05:58:56 <dminuoso> Also, your binding `server = ws` shouldn't check, right?
06:00:14 <delbmuts_> dminuoso: I'd like to access my custom servant `State` in the WebSocket function.
06:00:42 <dminuoso> so far so good.
06:00:43 <delbmuts_> dminuoso: AFAICT ghc isn't complaining.
06:01:32 <dminuoso> ah hold on, ServerT is a tyfam right
06:03:34 <dminuoso>   type ServerT (WebSocketConduit i o) m = ConduitT i o (ResourceT IO) ()
06:03:36 <dminuoso> I see
06:03:38 <delbmuts_> ski: transPipe :: Monad m => (forall a. m a -> n a) -> ConduitT i o m r -> ConduitT i o n r -- https://hackage.haskell.org/package/conduit-1.3.4/docs/Data-Conduit.html#v:transPipe
06:06:59 <delbmuts_> The fact that `m` does not appear on the right side bugs me a little.
06:07:08 <dminuoso> delbmuts_: Why not just add ResourceT to your AppM?
06:07:22 <dminuoso> Then you can just use transPipe the same way as hoistServer
06:08:32 <delbmuts_> Around or inside the ReaderT? (Would that matter?) I think I tried it, but I'll try again. :)
06:08:40 <dminuoso> I guess your main mistake is presuming that there's no ResourceT in your version of conduit
06:09:19 <dminuoso> (I mean it seems like you're trying to throw away your MonadResource interface for no good reason)
06:09:46 <dminuoso> Well, so servant-websockets assumes your monad to be
06:09:50 <dminuoso> ConduitT i o (ResourceT IO) ()
06:10:24 <dminuoso> You get to provide a natural transformation `m ~> n`, with n ~ ResourceT IO, so it must be:
06:10:32 <dminuoso> m ~> ResourceT IO
06:10:34 <dminuoso> If you had
06:11:00 <dminuoso> yourPipe :: ReaderT State (ResourceT IO) ()
06:11:34 <dminuoso> Then you could trivially write `ReaderT State (ResourceT IO) ~> ResourceT IO` with just `flip runReaderT ($)`
06:14:59 <delbmuts_> dminuoso: I'll need some time to digest that. Thank you! :)
06:17:13 * hackage hnix-store-core 0.3.0.0 - Core effects for interacting with the Nix store.  https://hackage.haskell.org/package/hnix-store-core-0.3.0.0 (imalsogreg)
06:21:12 <avdb> Sorry if this is a stupid question, but what's the best resource to understand Monads? I read the Haskell Wiki article on how it works and checked Computerphile's video on it but I don't think I fully get it yet.
06:26:53 <ski> delbmuts_ : `transPipe trans' can't possibly work, with that signature of `trans'
06:27:31 <[exa]> avdb: you actually hit the most problematic problem of monads, explaining them is problematic. it's only going to be better now. :D
06:27:46 <[exa]> avdb: anyway, what did you try so far
06:27:47 <ski> oh, actually, it can .. sorry, i misread
06:28:14 * hackage hnix-store-core 0.3.0.1 - Core effects for interacting with the Nix store.  https://hackage.haskell.org/package/hnix-store-core-0.3.0.1 (imalsogreg)
06:30:45 <[exa]> avdb: one thing that helps (with practical intuition) is to checkout the "monad DSLs" like IO. Get how the `IO ()` in types work, try to explain the differences between say "map vs mapM" and "if vs when" etc, and looking how the thing is constructed from >>= and >> using the 'do' notation.
06:31:42 * hackage hnix-store-remote 0.3.0.0 - Remote hnix store  https://hackage.haskell.org/package/hnix-store-remote-0.3.0.0 (srk)
06:32:46 <[exa]> avdb: and then there's the technical path, going from Functor (and fmap) to Applicative (with pure + <*>), where the jump to Monad (with >>=) becomes quite natural
06:35:02 <Sose> avdb: I'm at the point where I'm starting to slowly "get them"... reading about monads didn't really help me at all in the beginning. it was doing exercises and writing functor/applicative/monad instances and using them that started the process of having some understanding of them. I don't know what's the general opinion on http://mightybyte.github.io/monad-challenges/ as a resource but I found it quite enlightening 
06:35:02 <Sose> personally. no reading, just code exercises and some tips to guide you.. after doing those reading about monads makes more sense also
06:41:14 <avdb> [exa]: I found a blog that used pictures to explain Functors (Maybe, Just, Nothing, etc.) a while ago, but stopped because I thought they had nothing to do with monads
06:41:48 <avdb> Sose: After that I tried a tutorial that constructed Monad but the code was outdated :(
06:49:40 <ambidextrose> what's the best haskell book to read for someone who really does not understand all the type system notation?
06:50:34 <avdb> ambidextrose: I'm currently reading "Haskell: Programming from first principles" ...
06:51:03 <avdb> I tried "Real World Haskell" as well but it was a disaster since it throws you directly into the pool without warning
06:51:04 <erisco> if you literally just want to know about the notation there is the haskell report 2010 and the ghc user guide
06:51:06 <ambidextrose> avdb, i looked at that one, it seemed good
06:51:16 <ambidextrose> erisco, i might try those two
06:53:03 <sondr3> We used Programming in Haskell for our FP course at Uni (https://www.cs.nott.ac.uk/~pszgmh/pih.html), and I really enjoyed it. One of my favorite programming books
06:53:20 <ski> PIH is often recommended/lauded in here
06:53:37 <sondr3> Short and to the point, builds up gradually and has tons of exercises that really help you grasp concepts
06:53:44 <sondr3> I can imagine :)
06:54:46 <tomjaguarpaw> Is there a version of trace that doesn't update its thunk once it is evaluated? I would like to use such a thing to probe properties of various containers.
06:55:27 <avdb> sondr3: Is that the university of Computerphile?
06:55:41 <ambidextrose> sondr3, i might look at that one too
06:55:58 <Uniaika> tomjaguarpaw: not that I know of
06:56:12 <sondr3> avdb: Yeah, the author of the book is in quite a few of their videos
06:56:22 * ambidextrose wishes he'd done his research project in 2015 in haskell and not python
06:56:32 <tomjaguarpaw> ambidextrose: Don't we all?
06:57:03 <ambidextrose> i've been trying to learn haskell for 10 years just by reading other peoples' code from time to time and enough is enough. i've seen what the RTS can do, it's pretty insane
06:57:15 <ambidextrose> i'm going to stop writing in anything else
06:59:05 <ambidextrose> also decided to try switching to archlinux since my research system had a virus in systemd
06:59:32 <sondr3> That's a new one, fair warning; Haskell on Arch is somewhat painful
06:59:39 <geekosaur> arch + haskell = pain though; at least, avoid arch's haskell packages
06:59:45 <ambidextrose> i think i'm going to switch to something that uses sysvinit... i can't understand the attitude of arch users
07:00:01 <ambidextrose> systemd is awful: every ubuntu i have has viruses in systemd
07:00:22 <sondr3> Void Linux was really nice when I used it but NixOS is awesome
07:00:40 <ambidextrose> everyone's using nix but tbh i think the idea skirts the real issue of package management and language design
07:01:11 <ambidextrose> something like hoogle/agda could be checking/proving/downloading types instead of cabal, hackage, or nix
07:01:24 <ambidextrose> the type system could do the work of package management
07:02:02 <sondr3> No idea how a type system would be able to do dependency resolution :P
07:04:56 <sondr3> Unrelatec, I'm parsing different kinds of numbers with megaparsec, is there a way to do this `(try (lexeme pComplex) <|> try (lexeme pRational) <|> try (lexeme pDouble) <|> try (lexeme integer)` with less repetition?
07:05:32 <ambidextrose> sondr3, the types are the dependencies
07:06:40 <xerox_> :t asum
07:06:43 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
07:07:43 * hackage urbit-api 0.2.0.0 - Talk to Urbit from Haskell  https://hackage.haskell.org/package/urbit-api-0.2.0.0 (bsima)
07:08:42 <xerox_> asum . map (try . lexeme)
07:11:27 <sondr3> xerox_: thanks, much better
07:11:41 <xerox_> 👍
07:19:04 <[exa]> avdb: oh well, the functor hierarchy... technically "Functors" are kindof overloaded containers ("boxes") that have a clearly defined way of transforming the elements inside, with `fmap`. (e.g. list is a functor, using normal `map`). Then you add functionality -- Applicative allows you to reasonably merge a box of functions with a box of parameters (to get a box of results). Monads additionally allow 
07:19:10 <[exa]> fusing boxes with functions that produce more boxes from their contents. Demonstration:
07:26:11 <[exa]> (I'm writing a gist, decided that I'm telling this to so many people that gist shall help)
07:26:50 <avdb> How do I match calling a function without arguments with guards?
07:27:29 <Rembane> avdb: f | ... = ...
07:27:31 <avdb> i.e. if I have foobar x and somebody calls foobar without arguments I want to return something
07:27:38 <Rembane> avdb: foobar x | ... = ...
07:27:48 <Rembane> avdb: Wait a minute, without arguments? 
07:27:48 <avdb> Rembane: Three dots?
07:27:51 <avdb> Yes
07:27:58 <Rembane> avdb: Why would they do that? And what's the type of x? 
07:28:05 <avdb> [Char]
07:28:23 <Rembane> avdb: They can give you the empty string as argument. 
07:28:30 <avdb> null x didn't work
07:28:44 <Rembane> avdb: foobar "" = error "You have given me the empty string."
07:28:55 <avdb> Oh wait I see why
07:28:58 <avdb> Nvm
07:29:03 <Rembane> No worries, good luck! 
07:29:09 <geekosaur> avdb, you can't do that trivially. There's a typeclass hack that can sort of do it, but you're trying to defeat partial application which is deeply baked into Haskell
07:30:01 <merijn> hmm
07:30:14 <merijn> Publishing new docs to Hackage doesn't seem to override the current ones?
07:34:20 <erisco> my string is empty; my stack has overflow'n; my core has been dumped
07:36:42 <avdb> geekosaur: Nevermind, the problem is with running last x on an empty list, is there a safer alternative function?
07:38:24 <hpc> not really - the best you can do is do something that doesn't require getting the last element of a list
07:38:50 <hpc> or write something that's [a] -> Maybe a
07:39:17 <hpc> (and then still have to figure out what to do with Nothing)
07:42:58 <avdb> Sigh, fixed it by reordering the guards instead of making my fuctions safer.
07:43:44 <erisco> > let f = getLast . foldMap (Last . Just) in (f [1,2,3], f [])
07:43:47 <lambdabot>  (Just 3,Nothing)
07:43:53 <erisco> I am sure there is some lens shenanigans
07:44:50 <erisco> avdb, imo that is the wrong kind of safeness
07:45:32 <erisco> there is a sort of security safeness of what happens if there is a bug in the program
07:45:49 <avdb> erisco: Wdym? I'm currently trying to test my work with stack but every time I run "stack test" in a different folder it starts installing ghc-tinfo6
07:45:52 <erisco> but that is already taken care of
07:46:24 <avdb> erisco: It's actually the base case, testing if the string was empty before proceeding, so that I can't run into problems with last
07:47:05 <erisco> > let f = alaf Last foldMap Just in (f [1,2,3], f [])
07:47:08 <lambdabot>  (Just 3,Nothing)
07:47:41 <avdb> What?
07:49:09 <merijn> :t Last
07:49:11 <lambdabot> Maybe a -> Last a
07:49:12 <erisco> I made some inferences of what you meant by "make my functions safer"... perhaps too much of a leap
07:49:27 <merijn> erisco: Seems less confusing to avoid alaf :p
07:49:36 <merijn> :t foldMap (Last . Just)
07:49:38 <lambdabot> Foldable t => t a -> Last a
07:49:46 <merijn> > foldMap (Last . Just) []
07:49:49 <lambdabot>  Last {getLast = Nothing}
07:49:53 <avdb> I can't use Functors yet
07:49:55 <erisco> I am pointing out that "safety" from a memory security standpoint is already a nonissue here
07:49:56 <merijn> > foldMap (Last . Just) [1..5]
07:49:58 <lambdabot>  Last {getLast = Just 5}
07:50:49 <erisco> and if the point is to be arbitrarily defined for empty lists regardless of whether it makes sense or not, that isn't really an admirable notion either, in my opinion
07:51:43 <erisco> avdb, no functors required… my first example uses Foldable and the second uses Foldable dressed up with lens
07:52:34 <erisco> > foldMap f [a,b,c]
07:52:37 <lambdabot>  error:
07:52:37 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M195412351796...
07:52:37 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:53:02 <erisco> hm, well anyways you can think of it as  f a <> f b <> f c
07:53:31 <erisco> then you just have to figure what Monoid can give you the result you're after, in this case Last
07:54:19 <erisco> > foldMap f [a,b,c] :: Expr
07:54:23 <lambdabot>  f a <> f b <> f c <> mempty
07:56:44 * hackage xcffib 0.11.1 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.11.1 (TychoAndersen)
07:58:01 <erisco> can also go through Alternative
07:59:13 <erisco> > let f = foldr (flip(<|>).pure) empty in [f [1,2,3], f []] :: [Maybe Int]
07:59:16 <lambdabot>  [Just 3,Nothing]
07:59:32 <erisco> > let f = foldl (flip((<|>).pure)) empty in [f [1,2,3], f []] :: [Maybe Int]
07:59:35 <lambdabot>  [Just 3,Nothing]
08:01:06 <erisco> not sure what the cuter formulations of that are
08:02:53 <fendor> If I want to show some students how to write a rest service, which library is a good start? I would currently just go with servant and the servant cookbook, as I think the latter is a really helpful resource
08:02:56 <boxscape> hmm `(forall a . P a -> Q a, forall a . Q a -> P a)` is equivalent to `forall a . (P a -> Q a, Q a -> P a)`, right?
08:05:34 <maerwald> fendor: I don't think servant is a good start
08:05:59 <maerwald> if those aren't advanced haskellers at least
08:06:40 <fendor> two months course so far. So, no, they are not
08:06:51 <maerwald> then I'd pick snap or scotty
08:07:24 <fendor> snap really confuses me... I always found servant to be simpler than snap, as you can just copy examples
08:07:37 <fendor> scotty seems like a great idea though
08:18:53 <tomjaguarpaw> Is there a version of $! that is infixl 9, so it more closely matches function application?
08:24:55 <boxscape> this seems kind of weird http://ix.io/2FWN
08:24:57 <boxscape> to be fair it's using ImpredicativeTypes, for all I know it might be different with quick look impredicativity
08:25:32 <boxscape> or maybe it actually makes perfect sense if you think about it, I'm not really sure yet
08:37:01 <delbmuts_> Now it compiles, but does not work as I would expect, i.e., the servant endpoint does not output the state. Still, progress. :) https://paste.debian.net/hidden/70b56d6e
08:37:29 <delbmuts_> s ki: thanks for having a look
08:39:51 <delbmuts_> dminuoso: TBH, I don't get how to use `trans'` (`flip runReaderT ($)`) in above code.
08:41:57 <merijn> boxscape: "Doesn't work with ImpredicativeTypes" in any GHC pre 9.0
08:42:13 <merijn> boxscape: ImpredicativeTypes is "not even broken" in any older GHCs
08:42:27 <boxscape> hm, okay
08:42:48 <boxscape> so you would expect it to compile with a working version of IP?
08:42:51 <boxscape> uh
08:42:51 <boxscape> IT
08:43:44 <merijn> boxscape: GHC 9.0 (or is it 9.2?) will have a redone version of ImpredicativeTypes that has, you know, some actual defined semantics
08:45:08 <boxscape> looks like it's been merged into master
08:48:09 <dminuoso> delbmuts_: That should be ($a) for some choice of a.
08:48:40 <dminuoso> err sorry
08:48:45 <dminuoso> just `flip runReaderT a`
09:18:13 <avdb> Is there a way to define a list of all symbols, like you can with [0..9] for all numbers?
09:19:12 <Rembane> avdb: [0..] gets you all numbers, but I don't know if that's what you want.
09:19:46 <monochrom> generate all characters, then use isSymbol or something to filter it
09:26:17 <avdb> monochrom: I totally forgot about those functions ...
09:29:43 * hackage csound-expression-dynamic 0.3.6 - dynamic core for csound-expression library  https://hackage.haskell.org/package/csound-expression-dynamic-0.3.6 (AntonKholomiov)
09:30:43 * hackage csound-expression 5.3.4, csound-expression-typed 0.2.4 (AntonKholomiov): https://qbin.io/sussex-head-e181
09:33:44 * hackage csound-expression-opcodes 0.0.5.0 - opcodes for the library csound-expression  https://hackage.haskell.org/package/csound-expression-opcodes-0.0.5.0 (AntonKholomiov)
09:35:14 * hackage csound-sampler 0.0.10.0 - A musical sampler based on Csound  https://hackage.haskell.org/package/csound-sampler-0.0.10.0 (AntonKholomiov)
09:35:35 <delbmuts_> Looks like my test client wasn't working as I'd expected. :) https://paste.debian.net/hidden/1de4954a/ Thanks all.
09:36:14 * hackage csound-catalog 0.7.4 - a gallery of Csound instruments.  https://hackage.haskell.org/package/csound-catalog-0.7.4 (AntonKholomiov)
09:37:13 * hackage csound-controllers 0.1.1.0 -   https://hackage.haskell.org/package/csound-controllers-0.1.1.0 (AntonKholomiov)
09:41:18 <Squarism> Has anyone managed to set up an editor that handles basic type inspection? If so, what editor / approach have you been using?
09:43:44 <hekkaidekapus> boxscape: Indeed, it is already merged. For your example, the error is much better: <https://paste.tomsmeding.com/2KUFPpym>.
09:44:54 <hekkaidekapus> And from the proposal: “[impredicative instantiation] never looks at abstractions, pattern matching, lets, or any other expression.”
09:55:01 <shapr> Squarism: do you mean the Haskell language server?
09:55:20 <jil> hello
09:55:26 <shapr> Squarism: I have this setup for emacs and it's great! https://github.com/haskell/haskell-language-server
09:55:28 <shapr> hi jil
09:57:46 <jil> I'm still learning the basic of  haskell and I run into this error that I don't undestand.  Why is the simple function not working ? https://dpaste.org/nwxq
09:58:31 <shapr> :t foldr (+) 0
09:58:33 <lambdabot> (Foldable t, Num b) => t b -> b
09:58:56 <dolio> You gave it 1 where it expected a list.
09:58:57 <shapr> jil: how would you read the type of the function you pasted?
09:59:09 <dolio> And also gave it too many arguments.
09:59:17 <shapr> jil: How would you explain this? fsum :: Num a => [a] -> a
10:00:07 <jil> ok, I'm still confused about passing argument as list.  Thank you.
10:00:48 <monochrom> That's no different from writing any list in any context.
10:00:59 <jil> shapr that means that for all numerical type a  fsum expect a list of a and returns an object of type a
10:01:17 <solonarv> '1 2' isn't a list, it's just two integer literals
10:01:23 <solonarv> do you know how to write a list?
10:01:35 <jil> [1 2] ?
10:01:37 <shapr> jil: yeah, what solonarv said, how would you write a list?
10:01:41 <shapr> yes, that's a list
10:01:55 <shapr> but you need a comma between the elements
10:02:10 <jil> [1,2] then.
10:02:25 <jil> or (1:(2:[]))
10:02:37 <shapr> :t [1,2]
10:02:39 <lambdabot> Num a => [a]
10:02:46 <shapr> :t (1:(2:[]))
10:02:48 <lambdabot> Num a => [a]
10:03:04 <shapr> jil: have you used :t or :type in ghci?
10:03:26 <shapr> I use :t to figure out the type of things all the time
10:04:52 <jil> yes shapr, it's realy a syntaxic erro as I forgot how to write a list and did not understand the error "non type  variable argument in the constraint : Num (t1 -> t2)"
10:05:18 <jil> [1,2] == (1:(2:[]))
10:05:22 <shapr> > foldr max 0 [1,3,9,6]
10:05:28 <lambdabot>  9
10:05:50 <jil> > [1,2] == (1:(2:[]))
10:05:52 <lambdabot>  True
10:05:54 <shapr> yay!
10:06:05 <shapr> jil: you got it!
10:06:58 <jil> :t max
10:07:00 <lambdabot> Ord a => a -> a -> a
10:07:34 <shapr> ok, now back to figuring out how to get started with haskell.nix for me
10:07:47 <jil> thank you shapr
10:07:55 <jil> what haskell.nix ?
10:08:10 <shapr> jil: it's a way to compile haskell with NixOS
10:08:20 <shapr> jil: I'm glad to help, do you have more questions?
10:09:57 <jil> not really .  Thank you.  I'll get back to my book "programming in Haskel" from Graham Hutton.  Its great
10:10:09 <shapr> oh yeah! that's a great book!
10:10:23 * shapr checks his bookshelf
10:10:35 <shapr> oh, my copy is still in one of my book boxes.
10:10:40 <dsal> shapr: nix-build -A $project.components.exes.$project    or   nix-env -f default.nix -iA $project.components.exes.$project
10:10:49 <dsal> That's about all I do with it.  heh
10:11:00 <shapr> dsal: is that for haskell.nix? if yes, how do you start a new empty project?
10:11:11 <dsal> stack new and then copy in the file.
10:11:25 <shapr> I want to use cabal, and I don't have cabal in scope
10:11:36 <shapr> cause that's the point of nix, right?
10:11:54 <dsal> Yeah, but for that, cabal2nix might be better.  You can bootstrap with a nix-shell, I suppose.
10:12:45 <shapr> dsal: I don't know enough. I do know we're using haskell.nix at work so I want to start using it myself
10:13:20 <dsal> I've only used haskell.nix with stack.  I just copy the same default.nix around for projects I've already started with stack.
10:13:28 <dsal> I thought cabal2nix was the way when you're using cabal.
10:13:37 <shapr> maybe? I don't know!
10:14:03 <dsal> Yeah, says it works with cabal, so I guess it's the same process.
10:14:04 <shapr> We did switch our CI build from stack to haskell.nix
10:14:26 <dsal> `nix-shell -p cabal-install` and then do whatever you normally do to start your project.  Add default.nix, and it should be good.
10:14:29 <shapr> but from what I've read, haskell.nix gives you access to all the library versions on hackage, not just the blessed subset you get from a stack release
10:14:53 <dsal> Yeah, there's a daily derivation build of all the things.  Happens around 18:00 my time, I think. heh
10:15:10 <shapr> bah: cabal: The program 'ghc' version >=7.0.1 is required but it could not be found
10:15:21 <shapr> How do I get cabal-install and ghc 8.10.2 in scope at the same time?
10:15:29 <dsal> Weird.  You can add more stuff after -p
10:15:38 <shapr> oh
10:16:35 <dsal> You can also have a shell.nix that lists all those things, but starting a project is almost a bootstrap problem, so it might be easier just to make an alias or something.
10:17:15 <dsal> I'm kind of hybrid.  I use regular stack, but with its nix extensions.  Then I use haskell.nix (and cachix) to build for various places I deploy.
10:18:05 <shapr> I have a variety of disagreements with stack
10:20:07 <shapr> jil: what got you started with Haskell?
10:23:11 <dsal> My only problem with stack is that migrating away from it seems to get me a variety of disadvantages.  I tend to work with `stack test --file-watch` running.   I've not even figured out how to run tests with haskell.nix other than to explicitly name them in a build and then run the thing that got built.  i.e., there's no 'run the thing in this project' that seems to work.
10:26:51 <shapr> dsal: I use entr for all those same things
10:28:57 <hekkaidekapus> dsal: haskell.nix’s motto is ”If it works with cabal-install/stack, it should work here, too.” Based on that, I would say, enter a shell with stack inside (instead of generating Nix stuff with stack) and `stack test`. (But I’m no expert.)
10:29:21 <dsal> Maybe for the file-watch part, but not for the "just build this project" part.  The project name is constructed in haskell.nix and you can't just ask for whatever the current ones.
10:30:01 <merijn> hekkaidekapus: Mottos don't always reflect reality ;)
10:30:19 <dsal> `nix-shell --command 'stack test'` doesn't get me much further than `stack test` which is already using nix components.  :)
10:30:38 <hekkaidekapus> merijn: The maintainers are quite eager to fix bugs that contradict the motto.
10:30:49 <dsal> The annoying part of haskell.nix is the -A ............ part.
10:31:13 <shapr> dsal: what does that mean?
10:31:16 <shapr> why is that annoying?
10:31:20 * shapr wants to learn!
10:31:34 <dsal> i.e., I have a lot of haskell projects and when I'm working with stack, I type the same command in each directory.  With haskell.nix, I have to type a unique command for each project in each directory that's specific to the project.
10:34:08 <hekkaidekapus> (Which is the point of Nix: specify exactly every steps and don’t rely on global state—here ~/.stack…)
10:34:11 <dsal> I would really like to know what the right way to run tests is for haskell.nix.  I mostly like the model, but it only seems to build things and then just kind of drop them on the floor.  Ideally, CI would mostly just be copying an activation file and not lots of custom editing.  The per-project custom stuff has caused me a lot of problems in the past when a common part broke everywhere and I had to repeat the fix.
10:34:45 <dsal> Global state is the opposite of what I said.
10:35:01 <hekkaidekapus> Maybe I misunderstood.
10:35:15 <dsal> I have to go into my project directory or I don't get the default.nix file.  But then I also have to type a command specific to that project while in the project directory.
10:35:30 * hekkaidekapus barely knows how stack works.
10:35:35 <dsal> With stack (and I presume cabal, though I've not used it directly very much), I can enter the project directory and just type "stack test"
10:35:58 <iqubic> Yeah, I have no idea how to run tests in haskell when using nix.
10:38:01 <dsal> The haskell.nix documentation sort of handwaves the names of attributes it defines, but I find only some of them work (maybe).  It'd be super convenient if it just listed what was possible in a given project.
10:38:59 <dsal> e.g., it does suggest it *can* build tests, but none of my guesses as to what they're called seem to get me anywhere.
10:39:39 <hekkaidekapus> dsal: I see you aren’t in #haskell.nix. You could ping maintainers there and there is almost always answers, timezones permitting.
10:39:53 <dsal> Thanks!
10:40:00 <hekkaidekapus> np
10:41:01 <iqubic> What is haskell.nix? Is that just nix on haskell?
10:41:35 <hekkaidekapus> iqubic: <https://github.com/input-output-hk/haskell.nix>
10:41:55 <iqubic> Ah. I see.
10:41:58 <hekkaidekapus> It’s another Nix infrastructure for Haskell.
10:42:57 <dsal> It's been useful for me to get builds out on nixos systems.
10:43:52 <shapr> iqubic: I *think* the default haskell+nix infrastructure only offers you a single choice of haskell compiler and library versions, and haskell.nix does not
10:43:57 <shapr> but I'm not certain of that
10:44:13 <iqubic> No, I can easily change my compiler. That's not too hard.
10:44:46 <dsal> haskell.nix just makes any cabal or stack project also a nix project.
10:45:09 <dsal> Or as it says at the top of the doc I'm looking at:  haskell.nix can automatically translate your Cabal or Stack project and its dependencies into Nix code.
10:45:12 <xerox_> is there an id :: a# -> a# ? if that makes any sense
10:45:15 <jollygood2> hi. I have incomplete-patterns set, but this isn't trigger compiler warning: [month, day, year] <- sepEndBy integral (char '.')
10:45:16 <jollygood2> how come?
10:45:45 <merijn> jollygood2: Because Parser is an instance of MonadFail
10:46:08 <merijn> jollygood2: And pattern match failures in do notation use "fail" from MonadFail (usually "parse failure" in parsers)
10:46:13 * hackage config-value 0.8.1 - Simple, layout-based value language similar to YAML or JSON  https://hackage.haskell.org/package/config-value-0.8.1 (EricMertens)
10:46:20 <shapr> iqubic: how do I get ghc 8.10.2 and a particular version of something like the github library?
10:46:29 <iqubic> I don't know.
10:46:38 <shapr> oh, how do you change your compiler?
10:47:14 <jollygood2> merijn, is there a "stronger" incomplete-pattern warning, that will trigger that regardless if the instance is MonadFail?
10:47:35 <merijn> incomplete-uni-patterns, maybe?
10:47:41 <iqubic> shapr:  Also not sure.
10:47:48 <iqubic> I just know that I can.
10:47:54 <shapr> iqubic: oh, ok
10:47:59 <shapr> well if you figure out, I'd like to know :-)
10:49:58 <jollygood2> "The flag -fwarn-incomplete-uni-patterns is similar, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:"
10:50:03 <jollygood2> doesn't look like that is it
10:50:57 <merijn> jollygood2: You have a pattern bindings that allows only a single pattern...
10:51:07 <jollygood2> I do? :D
10:51:16 <jollygood2> let me try
10:51:36 <merijn> "[month, day, year] <- ..." that's a pattern and it's binding stuff, and it has only one pattern...
10:51:50 <jollygood2> still, the wording makes it seem like it will catch LESS than warn-incomplete-patterns will. I'll still try it
10:52:09 <merijn> jollygood2: It catches *different* things
10:52:29 <geekosaur> because it doesn't imply -Wincomplete-patterns?
10:52:30 <merijn> jollygood2: i.e. it only covers lambda patterns and (presumably?) do notation patterns and nothing else
10:52:57 <merijn> jollygood2: Whereas -Wincomplete-patterns covers only patterns that are *not* uni-patterns
10:54:45 <jollygood2> I've set it
10:54:50 <jollygood2> I still don't get the warning
10:56:02 <geekosaur> that may be because of MonadFail, and the answer is probably no because MonadFail overrides
10:56:30 <merijn> geekosaur: tbh, with the original desugaring of Monad it might not have worked either way
10:56:38 <boxscape> hekkaidekapus thanks, that's interesting
10:56:44 <solonarv> failable patterns in a 'do' binding cause a type error when the monad in use isn't MonadFail
10:56:56 <jollygood2> no warning:   do [_,_] <- (pure [1,2] :: IO [Int]); return 10
10:57:08 <merijn> solonarv: Right, but he has a parser, so he has a MonadFail
10:57:13 <merijn> jollygood2: IO is MonadFail, though
10:57:52 <jollygood2> right.. my second question was how to get this warning in MonadFail context.. and the answer seems to be, you can't
10:58:03 <merijn> That could very well be
11:01:13 <hekkaidekapus> boxscape: I suspect that was a contrived example extracted from a larger program. If you are hell-bent on using impredicativity in pattern position, you could 1) wait for type-level lambdas :d 2) hack ViewPatterns in your code.
11:01:19 <hekkaidekapus> to, to' :: A -> B
11:01:26 <hekkaidekapus> to fg         = (fst fg, snd fg)
11:01:33 <hekkaidekapus> to' (to -> x) = (fst x, snd x)
11:01:58 <boxscape> hekkaidekapus it wasn't; I was just trying to figure out whether that particular equation holds in predicate logic and haskell's type checker seemed a convenient way to prove it
11:02:14 <hekkaidekapus> Ah, ok.
11:02:54 <boxscape> but thanks for the tip anyway :)
11:03:05 <hekkaidekapus> \o/
11:08:08 <xerox_> @hoogle Word32# -> Word#
11:08:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:08:09 <lambdabot> GHC.Exts unsafeCoerce# :: forall (k0 :: RuntimeRep) (k1 :: RuntimeRep) (a :: TYPE k0) (b :: TYPE k1) . a -> b
11:08:09 <lambdabot> GHC.Prim unsafeCoerce# :: a -> b
11:14:28 <dminuoso> Why does hoogle produce unsafeCoerce at all here?
11:14:35 <dminuoso> That seems rather silly
11:15:13 <jollygood2> it matches :)
11:15:18 <hpc> the real question is why it doesn't produce it all the time :D
11:15:29 <merijn> hpc: Because it's not in the top hits :p
11:15:44 <boxscape> is Word# even Lifted?
11:16:03 <dminuoso> jollygood2: Arguably unsafeCoerce should be special cased, as it matches any function...
11:16:17 <dminuoso> And it's almost assuredly not the thing you want when you look for `S -> T`
11:16:31 <dminuoso> And for those who do want it, it's safe to assume they are fully aware of its existence..
11:16:32 <monochrom> Word# is not lifted.
11:16:32 <solonarv> % :k Word#
11:16:33 <yahb> solonarv: TYPE 'WordRep
11:16:33 <boxscape> % (unsafeCoerce :: Word32# -> Word#)
11:16:33 <yahb> boxscape: ; <interactive>:41:2: error:; * Couldn't match a lifted type with an unlifted type; When matching types; b0 :: *; Word# :: TYPE 'WordRep; Expected type: Word32# -> Word#; Actual type: a0 -> b0; * In the expression: (unsafeCoerce :: Word32# -> Word#); In an equation for `it': it = (unsafeCoerce :: Word32# -> Word#)
11:16:36 <boxscape> it doesn't match
11:16:36 <solonarv> nope, not lifted
11:16:50 <monochrom> Err nevermind
11:17:18 <boxscape> hm, I think you were right?
11:17:21 <boxscape> monochrom
11:17:23 <dminuoso> I mean it matches from the perspective Hoogle because it likely doesnt take kinds into consideration
11:17:23 <boxscape> why never mind?
11:17:38 <boxscape> hm I suppose so
11:18:45 <dminuoso> I mean a fully correct hoogle would likely be hard to implement right, in the presence of tyfams and other things.
11:19:17 <monochrom> Heh so unsafeCoerce is safer than I thought
11:19:44 * dminuoso holds monochrom's beer
11:20:03 <boxscape> % f :: Word32# -> Word#; f = unsafeCoerce# -- this is what you want for true power
11:20:04 <yahb> boxscape: 
11:20:51 <merijn> boxscape: I think you miswrote "real ultimate power" ;)
11:21:06 <boxscape> perhaps :)
11:22:03 <dminuoso> % let k = flip const unsafeCoerce# in runCont (pure 1) k
11:22:04 <yahb> dminuoso: 1
11:22:09 <dminuoso> Looks safe to me!
11:23:01 <dminuoso> `fix . const` is my favourite combinator of the month however.
11:23:11 <merijn> :t fix . const
11:23:13 <lambdabot> c -> c
11:23:17 <iqubic> What does that do?
11:23:22 <dminuoso> Try it out!
11:23:30 <merijn> iqubic: id :p
11:23:41 <iqubic> @let id' = fix . const
11:23:43 <lambdabot>  Defined.
11:23:52 <iqubic> > id' 34
11:23:55 <lambdabot>  34
11:24:01 <iqubic> How is that just id?
11:24:09 <boxscape> @src fix
11:24:09 <lambdabot> fix f = let x = f x in x
11:24:15 <dminuoso> iqubic: Surely you've been long around to figure this one out yourself.
11:24:19 <iqubic> I have.
11:24:29 <boxscape> fix (const 4) = let x = (const 4) x in x
11:25:24 <hpc> alternatively, if you formulate it as fix f = f (fix f):
11:25:34 <hpc> fix (const 4) = const 4 (const 4 (const 4 (...
11:26:08 <dminuoso> what I find curious is how these simple functions const, id, fix are all somehow connected in strange and interesting ways
11:26:33 <dminuoso> or equivalently their type versions Const, Identity, etc
11:26:41 <boxscape> you're getting dangerously close to doing combinator calculus
11:28:07 <boxscape> hmm I wonder which one(s) you need in addition to fix for functional completeness 
11:28:43 <boxscape> (hm is functional completeness the right term here? I actually only know it from logic)
11:29:23 <dminuoso> boxscape: Heh that reminds me of that revelation that, in principle, Applicative gives you a full SK(I) combinator calculus almost directly. It's just the type system that is in the way.
11:29:31 <boxscape> I was just thinking about that :)
11:29:42 <solonarv> const and ap are all you need if you throw away types
11:29:52 <solonarv> I don't think you can write fix using them though
11:30:01 <dminuoso> why not?
11:30:37 <dminuoso> You can express Y in SKI
11:30:37 <solonarv> well, you can write fix if you ignore types, but if you try to type-check that expression you end up with an infinite type
11:30:48 <solonarv> SK(I) is untyped so that works
11:31:03 <boxscape> I wonder if you can get rid off one of them if you have Y as a given
11:31:05 <dminuoso> Right, that's what I was saying with "the type system is in the way"
11:31:40 <dminuoso> solonarv: Im almost convinced you can just do it with newtypes
11:31:50 <dminuoso> Like, you can write a lambda style Y combinator with newtypes too
11:31:58 <solonarv> oh, I'm sure you can
11:32:05 <dminuoso> (Ignoring simplifier panics that get triggered if you dont disable optimizations in GHC)
11:32:42 <dminuoso> To me the newtypes are just noise demanded by the type system, they wouldnt invalidate such an implementation
11:36:08 <solonarv> yes, \a -> s i i (s (k a) (s i i)) is a fixed-point combinator
11:36:25 <solonarv> (you can rewrite that lambda to use only combinators but I'm too lazy for that)
11:36:40 <boxscape> we have a tool to do it
11:36:42 <boxscape> @pl \a -> s i i (s (k a) (s i i))
11:36:42 <lambdabot> s i i . flip s (s i i) . k
11:36:53 <solonarv> :t let s = ap; i = id; k = const in \a -> s i i (s (k a) (s i i))
11:36:54 <boxscape> now just replace . by C and flip by B, IIRC
11:36:55 <lambdabot> error:
11:36:55 <lambdabot>     • Occurs check: cannot construct the infinite type: a0 ~ a0 -> b
11:36:55 <lambdabot>       Expected type: ((a0 -> b) -> b) -> a0 -> b
11:37:22 <dminuoso> s (k (s i i))(s (s (k s) k) (k (s i i)))
11:37:26 <dminuoso> Copied straight out of google!
11:37:28 <solonarv> but unsurprisingly you get this type error, which is basically the same one that the lambda-calculus Y combinator has
11:37:46 <dminuoso> solonarv: mmm you know what, we can convince it!
11:37:55 <solonarv> yes, with newtypes !
11:38:08 <dminuoso> % let s = ap; i = id; k = const in unsafeCoerce (\a -> s i i (s (k a) (s i i))) 
11:38:09 <yahb> dminuoso: ; <interactive>:1:58: error:; * Occurs check: cannot construct the infinite type: a0 ~ a0 -> b0; Expected type: ((a0 -> b0) -> b0) -> a0 -> b0; Actual type: (a0 -> b0) -> a0 -> b0; * In the second argument of `s', namely `i'; In the expression: s i i (s (k a) (s i i)); In the first argument of `unsafeCoerce', namely `(\ a -> s i i (s (k a) (s i i)))'; * Relevant bindi
11:38:17 <dminuoso> Oh boy, needs more unsafeCoerce!
11:38:26 <solonarv> you need to sprinkle them around inside the expression, yeah
11:38:41 <hpc> build it like idris intermediate representation
11:38:50 <hpc> every subexpression is unsafeCoerced :D
11:38:51 <solonarv> the root of the issue is self-application
11:38:52 <dminuoso> I got an idea, GHC has the right extension for that
11:38:54 <boxscape> % let s = unsafeCoerce ap; i = unsafeCoerce id; k = unsafeCoerce const in unsafeCoerce (\a -> s i i (s (k a) (s i i)))
11:38:55 <yahb> boxscape: ; <interactive>:2:22: error:; * Ambiguous type variable `m0' arising from a use of `ap'; prevents the constraint `(Monad m0)' from being solved.; Probable fix: use a type annotation to specify what `m0' should be.; These potential instances exist:; instance Monad m => Monad (WrappedMonad m) -- Defined in `Control.Applicative'; instance ArrowApply a => Monad (ArrowMon
11:38:58 <boxscape> makes senes
11:39:01 <dminuoso> % (x!) = unsafeCoerce x
11:39:01 <yahb> dminuoso: ; <interactive>:3:2: error: Expression syntax in pattern: x !
11:39:05 <dminuoso> % (x&) = unsafeCoerce x
11:39:05 <yahb> dminuoso: ; <interactive>:4:2: error: Expression syntax in pattern: x &
11:39:07 <dminuoso> Mmm
11:39:11 <dminuoso> % (&) = unsafeCoerce x
11:39:12 <yahb> dminuoso: ; <interactive>:5:20: error: Variable not in scope: x
11:39:14 <dminuoso> % (&) = unsafeCoerce
11:39:14 <yahb> dminuoso: 
11:39:16 <dminuoso> There!
11:41:51 <boxscape> maybe someone made a deepUnsafeCoerce quasiquoter that wraps every subexpr in unsafeCoerce
11:49:12 <boxscape> although I guess you'd just end up with a bunch of ambiguous type variables typically
11:49:45 <dminuoso> boxscape: easily addressed with some sort of type checker plugin
11:49:53 <boxscape> fair point
12:02:14 * hackage xmobar 0.37 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.37 (JoseAntonioOrtegaRuiz)
12:11:33 <sondr3> That's a new error when launching cabal repl: `/tmp/bios-wrapper5424-294: line 4: : No such file or directory`
12:12:23 <sondr3> Isn't bios used in HLS? Not sure why it interferes with cabal
12:18:50 <merijn> sondr3: WHich version of cabal-install?
12:20:31 <sondr3> merijn: cabal-install version 3.2.0.0, though I just waited a bit and now it works again
12:30:48 <iqubic> jle`: Thank you for updating your AoCAPI. I have verified that it works with the lastest version of servant and GHC.
12:31:10 <iqubic> I can successfully get an error of "Left (AoCReleaseError 117187.692251649s)"
12:31:52 <iqubic> I don't understand what the number is, and the docs state it's a NominalDiffTime, but IDK what that is.
12:31:58 --- mode: tolkien.freenode.net set +o ChanServ
12:32:27 <koz_> iqubic: NominalDiffTime represents a separation in time that's not pinned to anything specific ("five minutes ago", "tomorrow", "five years from now" etc).
12:32:45 <koz_> It's encoded as (possibly fractional) seconds.
12:33:33 <iqubic> Right. And in this case it's telling me how long I'll need to wait until AOC 2020 starts
12:34:21 <iqubic> But the important part isn't that number, but that the jle's updates that he made yesterday actually work.
12:37:00 <iqubic> Looking at Haskell's Time support, and I'm wondering something; What's the difference between a NominalDiffTime and a DiffTime?
12:37:35 <merijn> iqubic: DiffTime is *clock* time
12:37:43 <merijn> iqubic: NominalDiffTime is monotonic time
12:37:49 <koz_> NominalDiffTime ignores leap seconds.
12:37:55 <iqubic> So then what's UTCTime?
12:38:02 <koz_> UTCTime is a specific time.
12:38:08 <koz_> Not a difference between two times.
12:38:08 <iqubic> Right, I see.
12:38:13 <iqubic> Ah, I see.
12:38:29 <merijn> iqubic: i.e. 5 minutes of NominalDiffTime might be 1 hour and 5 minutes of DiffTime :p
12:38:40 <merijn> Due to daylight savings time
12:38:41 <iqubic> I see.
12:39:06 <merijn> It's pedantic, but time is complex enough that pedantry is warranted :p
12:39:29 <iqubic> Does Haskell support timezone conversions, or not?
12:39:47 <merijn> Sure, as much as anything does
12:39:58 <merijn> Well "Haskell" not so much
12:40:02 <merijn> But the time library, sure
12:40:21 <iqubic> Right.
12:40:31 <merijn> iqubic: See ZonedTime
12:40:39 <iqubic> I'll look at that later.
12:40:52 <merijn> iqubic: Which is essentially "a time + a time zone"
12:41:11 <merijn> ugh
12:41:16 <appostasiamo> ciao
12:41:23 <merijn> time doesn't have geographic timezone names?
12:41:35 <appostasiamo> !list
12:41:36 <monochrom> appostasiamo: https://hackage.haskell.org/
12:41:44 * xerox_ chuckles
12:41:46 <koz_> merijn: Nope.
12:42:00 <koz_> (speaking as someone who actually had to look up this info recently)
12:42:01 <merijn> Ok, I retract my statement :p
12:42:15 <merijn> time on supports UTC offsets, not timezones :p
12:42:29 <merijn> s/on/only
12:42:29 <xerox_> postgres does timezone conversion well
12:42:53 <merijn> xerox_: I don't believe that :p
12:43:00 <xerox_> it's true!
12:43:04 <merijn> Because there's literally no way to do timezone conversion *well*
12:43:11 <merijn> The best you can manage is *not terrible*
12:44:25 * hekkaidekapus awaits the future vs. past times distinction…
12:44:34 <merijn> hekkaidekapus: For example :p
12:44:48 <hekkaidekapus> heh… I saw you coming :p
12:45:23 <merijn> I'm coming to take away the programming license of anyone who says "you should always convert datetime to UTC" >.>
12:45:34 <hekkaidekapus> lol
12:45:48 <merijn> A little knowledge is a dangerous thing!
12:46:34 <hekkaidekapus> In the line of “Fear the person of one book.” s/book/universal time/
12:47:11 <merijn> hekkaidekapus: It's especially relevant with all of the EU reconsidering daylight savings time in the near future
12:47:39 <dminuoso> iqubic: https://wiki.haskell.org/wikiupload/9/90/Time-diagram.png
12:47:49 <hekkaidekapus> merijn: Wait, isn’t the decision already made?
12:48:21 <merijn> hekkaidekapus: AFAIK the decision to stop has been made, but nothing has been finalised about which permanent time will be used by which country
12:48:48 <ddellacosta> dminuoso: that's great, filing it away, thanks
12:49:03 <hekkaidekapus> iirc, each country has the leeway in phasing it out.
12:49:19 <merijn> hekkaidekapus: Eh, last news article I saw said end 2021 :p
12:50:36 <hekkaidekapus> merijn: Ok, then. It’s not like I’m running for a seat in the EP ;) (If I did, it’d be under the Pirates banner, of course. :P )
12:56:31 <hekkaidekapus> @where cabal-stack-disambiguation
12:56:31 <lambdabot> "The Cabal/Stack Disambiguation Guide" at <https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07> by Merijn
12:57:02 <hekkaidekapus> merijn: Time for a ‘Future vs Past Time disambiguation’ gist?
12:58:42 <merijn> hekkaidekapus: I'll get right on that after I finish rewriting 8 thesis chapters...before tomorrow 10 AM >.>
12:59:13 <hekkaidekapus> UTC time, oc.
13:03:13 * hackage hedis 0.13.1 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.13.1 (k_bx)
13:03:57 <dminuoso>  21:46:49        merijn | hekkaidekapus: It's especially relevant with all of the EU reconsidering daylight savings time in the near future
13:04:05 <dminuoso> Its going to be a very interesting near future
13:04:31 <hekkaidekapus> lol
13:04:31 <dminuoso> Negative leap second, DST changes... 
13:04:52 <dminuoso> I reckon we'll reap the benefits in years to come
13:05:01 * hekkaidekapus thought dminuoso went for the pun…
13:07:51 <dminuoso> Is there a typeclass for things that have an empty constructor like Nothing or []?
13:08:03 <merijn> Alternative? :p
13:10:04 <hpc> also Monoid depending on what kind you need
13:10:05 <boxscape> dminuoso https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html#t:Default
13:10:47 <boxscape> I guess Pointed, as well
13:11:03 <boxscape> I guess Pointed, as well
13:11:04 <boxscape> whoops
13:11:07 <boxscape> I wanted to say
13:11:08 <boxscape> wait no
13:11:14 <boxscape> Pointed is different
13:14:19 <ddellacosta> MonadThrow?
13:14:20 * ddellacosta ducks
13:21:38 <dminuoso> Mmm I guess Default is that thing
13:25:21 <ryantrinkle> for QuantifiedConstraints, it seems like sometimes it needs a little help; e.g., i have a `type family Object cat a :: Constraint` and `class Object cat a => Object' cat a with instance Object cat a => Object' cat a`, and finally an expression that uses it via a quantified constraint `forall x. obj x => Object' cat x`
13:25:39 <ryantrinkle> now if I just try to use `Object cat a` for some particular `a`, it doesn't work
13:26:11 <ryantrinkle> but defining: `with :: forall c r. c => (c => r) -> r` `with x = x`
13:26:23 <ryantrinkle> and prefixing with `with @(Object' cat a)`
13:26:30 <ryantrinkle> now it can find the Object cat a instance
13:26:35 <ryantrinkle> any advice on how to clean this up?
13:27:19 <ryantrinkle> (it's necessary to go through the `class` because the type family can't be partially applied)
13:55:49 <JavaSucksMan> How can I restrict access to the full IO monad while still provide access to things like IORef that, aren't referentially transparent but don't actually do IO (from the OS point of view)?
13:56:11 <dolio> Use ST?
13:56:43 <koz_> You can also work in PrimMonad I guess?
13:56:56 <JavaSucksMan> I guess,,, and use #RealWorld# to get at IORefs?
13:57:08 <hpc> you'd use STRef
13:57:28 <koz_> I think there's a generalization of *Ref in primitive if you wanna go down the PrimMonad route IIRC.
13:59:13 <JavaSucksMan> PrimMonad looks interesting.... thanks
14:27:51 <dsal> JavaSucksMan: It sounds like you were describing ST.
14:28:55 <monochrom> @quote monochrom Bond
14:28:55 <lambdabot> No quotes match.
14:29:21 <dsal> That's pretty deep.
14:29:26 <monochrom> Oh, this:
14:29:30 <monochrom> @quote monochrom 007
14:29:30 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
14:29:31 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
14:30:03 <monochrom> That last one may have been better off as The RealWorld# Is Not Enough
14:31:20 <maerwald> everything is IO. GHC just creates a perfect illusion for us
14:32:13 <monochrom> I have a feeling that it's the opposite, IO is an illusion.
14:32:31 <maerwald> that's what academics like to believe :p
14:34:54 <monochrom> Rumour goes that if you assume an anti de Sitter space and do a holographic projection of the world to a surface, then the IO monad and the IO comonad are unified.
14:35:11 <dminuoso> The IO comonad? ...
14:35:23 <monochrom> I'm making it up. >:)
14:35:26 <erisco> oh yeah I have one of those on my coffee table
14:36:05 <monochrom> But a comonad allows you to do the much-wanted M a -> a
14:36:12 <dminuoso> % :t unsafePerformIO
14:36:12 <yahb> dminuoso: IO a -> a
14:36:15 * dminuoso chuckles
14:36:20 <erisco> it is true that you can use comonads to add purity to impure languages
14:36:38 <erisco> so then it is moreso a question of what you like by default, like strictness
14:40:22 <erisco> I feel like "everything is" statements are as broad as they are meaningless
14:40:58 <maerwald> they aren't really statements
14:41:12 <monochrom> Yes if you restrict to those that are really, seriously, provably true.
14:41:44 * hackage intricacy 0.7.2.1 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.7.2.1 (mbays)
14:41:45 <monochrom> If you allow them to be statistically true of a majority, then you have useful statements.
14:43:59 <monochrom> But why do you like to suddenly discuss "everything is" sentences?
14:44:25 <maerwald> Because programmers generally have a hard time with non-formal truths? :p
14:44:57 <erisco> it started with "everything is IO" and then continued with the negation
14:45:00 <arw_> yes. but even formally, most "everything is" sentences will be tautologies ala "everything is isomorphic to itself"
14:45:06 <maerwald> erisco: and both is true
14:45:19 <erisco> when A and not A are both true, what do you have
14:45:37 <maerwald> erisco: there's more than just classical logic
14:45:59 <erisco> well I'm asking you, I didn't make any logical judgement about it :P
14:46:59 <monochrom> I think programmers have no trouble believing and insisting non-formal truths like "pure FP is impractical" and "non-tail recursion uses call stack space".
14:47:28 <maerwald> erisco: https://aeon.co/essays/the-logic-of-buddhist-philosophy-goes-beyond-simple-truth 
14:47:36 <monochrom> Or maybe that's exactly what you mean.
14:48:06 <maerwald> it's also formally explained there, kinda
14:49:07 <JavaSucksMan> When A and not A are both true, you have.....trivial completeness ;-)
14:49:54 <maerwald> https://en.wikipedia.org/wiki/Many-valued_logic
14:50:18 <JavaSucksMan> or paraconsistant logics
14:50:38 <erisco> if you can assume A and successfully describe the world, and, as a separate endeavour, assume not A and also successfully describe the world, what importance does A or not A have
14:51:01 <maerwald> erisco: the part that the reader missed :D
14:51:31 <maerwald> if you think about it, it's gone
14:52:00 <maerwald> the paradox of the ineffible
14:52:31 <maerwald> or just "aesthetic truth" to be more classic
14:52:59 <maerwald> because again: none of those were actually statements
14:56:00 <erisco> "aesthetic truth" sounds like a euphemism for politics
14:56:12 <maerwald> no
14:56:46 <maerwald> there's a few centuries of philosophy research about it :p
14:56:49 <monochrom> "reality" is.
14:57:44 * monochrom contemplates "what would go into a book titled Political Haskell?"
14:57:54 <maerwald> I think it's important to talk about non-formal properties of e.g. languages as well. Such a property is how it "feels". And if you ask most programmers, it's actually something you can talk about
14:58:34 <monochrom> Yes. For example "productivity".
14:58:49 <monochrom> "power"
14:59:06 <monochrom> "readability"
15:00:14 <erisco> why did my blood pressure go up
15:00:45 <maerwald> Such discussions have a tendency to derail into gibberish... (are we there yet?), but formal discussions have their own as well: bikeshedding.
15:01:14 <erisco> oh there is nothing like a perfectly rational, coherent, formal discussion about absolutely nothing significant
15:01:22 <monochrom> Yes, we have long understood PEBKAC
15:01:27 <MarcelineVQ> re: feeling. haskell's use of whitespace has ruined me for other languages
15:02:02 <erisco> but on the other hand, I feel like these feelings (hah) need to be put in their place
15:02:04 <MarcelineVQ> all I can use now is haskell-like things
15:02:33 <erisco> because it seems to be, and I've encountered this, that some project their preferences as matters of fact
15:03:00 <erisco> like where you ought to put your commas and braces and whether it is okay to have single-letter variable names and how many lines per file and on and one
15:03:49 <erisco> if I like putting my commas first rather than last on a line and someone says it is unreadable, that is their experience of it
15:04:27 <maerwald> yes, commas have caused engineering teams to split up :D
15:04:46 <erisco> are you leading or trailing?
15:05:01 <monochrom> This is why SPJ is leading. >:)
15:05:46 <ski> i think i always did leading, because of the aesthetics
15:05:54 <ski> (i like to line things up)
15:06:03 <maerwald> My policy wrt formatting is similar to the WTFPL license text
15:07:40 <maerwald> I barely even care what formatting ppl use in PRs... I mean. If you're an open source project and someone contributes... it's time for celebration, screw formatting :p
15:07:49 <monochrom> Is that basically centre-align every line, except left-align for the last line?
15:08:17 <erisco> my first foray into programming didn't involve whitespace
15:08:18 <ski> erisco : "when A and not A are both true, what do you have" -- linear logic ?
15:08:51 <MarcelineVQ> human involvement
15:09:58 <erisco> then a mentor showed me how to format my html elements and boy was web development so much easier
15:10:01 <maerwald> if you calculated the times engineering teams have discussed non-sente topics like formatting, maybe you could calculate the wasted time or the economical damage :p
15:10:06 <erisco> practically took all the challenge out!
15:12:43 * hackage pg-extras 0.0.1 - PostgreSQL database performance insights.  https://hackage.haskell.org/package/pg-extras-0.0.1 (pawurb)
15:13:52 <monochrom> https://twitter.com/HisCursedness/status/788690145822306304
15:15:07 <xerox_> that's beautiful modulo a couple columns
15:16:49 <maerwald> monochrom: lol, ok... I guess I do care about it *somewhat*
15:16:50 <erisco> when you take leading delimiters to their ultimate conclusion you also lead with semicolons
15:17:03 <erisco> I had a hard time seriously staying on board with that, though I tried :P
15:17:52 <monochrom> That's what SPJ does. Lead with semicolons. And the leading semicolons are vertically aligned with { and }
15:18:11 <monochrom> <pun>Follow the lead of SPJ!</pun>
15:18:34 <erisco> really? well great minds and all that
15:18:49 <maerwald> there should be a haskell formatter that turns your code into SPJ style
15:19:31 <monochrom> The trouble is that only SPJ does it, in all of the Haskell community. So yeah we simply call it the SPJ style.
15:20:09 <xerox_> always liked that style
15:20:16 <monochrom> I used to do that a bit, but only because an old generation of auto-indentation editor plugin was dumb.
15:20:21 <erisco> I have a style I don't see others using
15:20:46 <erisco> it is kind of regressive, but it started with whatever editor I was using at the time as a workaround
15:20:47 <maerwald> we need AI in formatters
15:20:57 <erisco> now I just like it
15:21:29 <erisco> here you can see by example https://hackage.haskell.org/package/control-dotdotdot-0.1.0.1/docs/src/Control-DotDotDot.html#DotDotDot
15:21:59 <dolio> Dissapointing that almost no one replying to that tweet recognized that the problem is that the compiler requires all that extra garbage to be added to the code that is already easy to understand.
15:22:04 <monochrom> Yes please Markov chain that tells me how many leading spaces I need for the next line. :)
15:22:25 <xerox_> yuck
15:23:06 <monochrom> dolio, that's a doctrine of the layout-insensitive religion.
15:23:58 <monochrom> Either that, or layout parsing is really tricky.
15:24:28 <dolio> It probably is when you write your parsers in C like most people do.
15:24:38 <dolio> That's why they have compiler books that are like 70% parsing.
15:24:40 <hekkaidekapus> The code in that tweet is fine. The right margin should be the place to stuff boilerplate; if you don’t like boilerplate, increase the column count where the margin starts. By the way, 80 or 120? :p
15:24:44 <maerwald> ok, I'm a believer in inconsistent formatting... I don't mind if ppl exercise different styles in one codebase. Because it's all *information*. Why would you hide it? Scared your pattern recognition apparatus overloads? That's more likely to happen due to the actual code
15:25:51 <erisco> my elitism is saying it is people who have only experienced one style, either because they are new or stubborn
15:26:09 <monochrom> newborn or stubborn  \∩/
15:26:22 <hekkaidekapus> :d
15:27:05 <erisco> I don't know how you can care that much once you have some practice in a variety of different syntax styles
15:27:18 <erisco> and, lord help you, mathematics
15:27:38 <alx741> hello all, I think some months ago I read about a framework (new one?) that advocates for server-side rendering but also provides a list of principles of what it believes makes for good modern web frameworks (server side rendering being one of them), does anyone knows which framework that would be? I'm really after that list of principles but can't recall its name :/
15:28:02 <maerwald> I think it's the hope that consistent formatting will somehow make the team more productive...
15:28:04 <monochrom> I say that layout parsing is tricky because the rules in the Haskell Report are almost as long as C++ rules for disambiguating multiple inheritance of a comon field, which is infamous for being tricky and complex and "no one actually understands in full".
15:28:15 <sondr3> alx741: IHP maybe?
15:28:18 <Axman6> alx741: maybe miso?
15:28:26 <Axman6> maybe Maybe?
15:28:39 <sondr3> Either maybe
15:29:49 <alx741> sondr3: I remember the web page of it had such a list's name, but IHP doesn't so perhaps they've changed it?
15:30:21 <alx741> Axman6: I've checked but there is no mention of such a list
15:30:40 <maerwald> so the language is sound, but the parser not? :D
15:31:14 <maerwald> purely functional programming language, that should parse... mostly
15:31:15 <alx741> I remember it had a name, similar to how OOP has the 'SOLID' principles (it was a nice sounding name), I can't remember and it's driving me crazy :p
15:31:29 <erisco> is the list longer or shorter than the list of physicists who truly understand quantum mechanics?
15:31:52 <dolio> Haskell's layout sensitivity is a lot more complicated than the sensitivity in that tweet.
15:32:13 <erisco> oh wait, I merged conversations
15:32:39 <Axman6> alx741: was it PHP, Purescript, Haskell, Postgresql?
15:32:43 <erisco> thought that was a list of people who fully understood C++ parsing
15:33:17 <monochrom> Ah OK fair, dolio.
15:33:25 <sondr3> Axman6: lol, nice acronym
15:33:39 <dolio> I guess a problem is people only knowing Python as an example. If they did know Haskell, they could realize that languages could adopt optional layout sensitivity to avoid breaking existing code, so there's no excuse for perpetuating the braces and semicolons.
15:33:51 <Axman6> MPHPGA - Make PHP GReat Again
15:34:00 <dolio> The requirement, that is.
15:35:03 <alx741> Axman6: I believe it was a Haskell web framework, hence I'm asking here... but I do realize that could also be a memory fluke
15:35:25 <Axman6> it wasn't yesod?
15:36:05 <alx741> Axman6: pretty sure it wasn't because that's what I currently use
15:36:38 <alx741> Oh well maybe I remember on my sleep :)
15:36:49 <alx741> *I'll
15:39:07 <monochrom> Yes, I wish Python supported {;] so I could write one-liners on the REPL when it's a really short one-liner. The advantage of one-liners on the REPL, when it's short, is that I can actually edit any of it before I press enter.
15:40:06 <monochrom> If the REPL forces you to press enter 5 times, it means you're screwed whenever you realize you made a typo before the 1st enter.
15:40:18 <Axman6> need more heredocs
15:42:21 <erisco> just deconflict the keys
15:42:39 <erisco> shift+enter has been a way to put newlines in text fields
15:42:39 <sondr3> Anyone know of a good way to go from a char to its UTF8 symbol? E.g. '\955' to λ
15:42:50 <shachaf> monochrom: The other option would be an environment that supports multiple-line inputs and still has the advantages of a REPL.
15:43:01 <shachaf> sondr3: UTF-8 as in the encoding in bytes?
15:43:07 <Axman6> sondr3: I don't understand the question
15:43:51 <erisco> "UTF8 symbol" isn't a thing I have heard of
15:44:08 <sondr3> Uh, so I have a bunch of characters that I'm reading, and I want to go from their decimal value to its glyph
15:44:28 <Axman6> how are you reading them?
15:44:33 <erisco> so you have a ttf or something?
15:44:34 <sondr3> Megaparsec :D
15:44:43 <monochrom> You know what, show actual code.
15:44:57 <monochrom> @where paste
15:44:57 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
15:46:13 <monochrom> But I guess a possible short answer is that if you use putChar or putStr or putStrLn you will see your λ alright, if you use print you don't, and that's by design.
15:46:41 <sondr3> I'm writing a Scheme implementation and it writes characters as `\#VAL` (or `\#xHEX`) and uses this as an example: `#\x03BB  ;λ(if character is supported)`
15:46:49 <monochrom> If you use show you don't either, and print uses show, that's why.
15:47:30 <monochrom> Actually I think I can use yahb to show you. But you should also do your experiment in ghci to confirm.
15:47:40 <monochrom> % print '\955'
15:47:40 <yahb> monochrom: '\955'
15:47:46 <monochrom> % putChar '\955'
15:47:46 <yahb> monochrom: λ
15:47:46 <erisco> it just sounds like there is confusion on encodings versus code points versus glyphs
15:48:02 <monochrom> Yeah there's also that. But that would be a 1-hour lecture.
15:48:04 <erisco> and maybe the answer can be found in understanding what each of those are
15:48:20 <erisco> there is that Joel Spolsky article
15:48:35 <monochrom> a 1-hour lecture that could be saved by reading joeysoftware's article on this topic, but who still remembers there is such a thing
15:48:37 <sondr3> ¯\_(ツ)_/¯
15:48:51 <nitrix> Not very Haskell-y but I can't think of a better place to ask: Is there terminology to distinguish whether two things compare equal after evaluation vs. them being actually the same expression?
15:49:03 <monochrom> People now only know that emojies "just work"
15:49:47 <erisco> they got added to computers about a decade ago, weren't you aware?
15:50:09 <nitrix> As in, `1 + 1 = 2`. Clearly there's "equality" but these two things isn't the same. I don't know if mathematics/logic cares to name those?
15:50:15 <erisco> that was roughly my experience when I first saw one on a mobile phone :P
15:50:53 <nitrix> I guess I'm asking for something beta-reduction related.
15:51:01 <alice_> how does ghc garbage collection work
15:52:11 <hekkaidekapus_> > chr 955 -- sondr3
15:52:13 <lambdabot>  '\955'
15:52:21 <hekkaidekapus_> > ord 'λ'
15:52:24 <lambdabot>  955
15:52:28 <erisco> nitrix, there definitional equality which would say  2 = 1 + 1  only when 2 is defined by 1 + 1
15:53:39 <erisco> and a common name for the other sort is slipping my mind
15:53:51 <nitrix> erisco, So the terminology I'm after is "definitional equality"? What are the other options, judgmental equality?
15:53:52 <MarcelineVQ> nitrix: extentional equality
15:54:19 <nitrix> erisco, And, Google just happily told me what I'm after. Apparently I want to look into "homotopy theory" :D
15:54:31 <MarcelineVQ> Though that's not specifically about if they're evaluated first
15:54:33 <erisco> well there are all sorts of equalities
15:54:59 <MarcelineVQ> nitrix: https://en.wikipedia.org/wiki/Extensionality would be my first stop
15:54:59 <sondr3> hekkaidekapus_: Is there a way to do that in reverse? I haven't been able to find anything/figure it out
15:55:04 <nitrix> MarcelineVQ, I think you're closer. I'm doing predicate logic.
15:55:39 <hekkaidekapus_> sondr3: What reversal?
15:56:04 <Axman6> alice_: that's a fairly broad question, do you have a more specific question?
15:57:25 <erisco> I find univalence particularly mind-bending and pray one day I have the motivation to learn more
15:57:52 <MarcelineVQ> erisco: try cubical agda :>
15:58:14 <MarcelineVQ> https://gallais.github.io/blog/first-cubical-experiment.html
15:58:17 <sondr3> hekkaidekapus_: How do I do what putChar does only `Char -> String` instead of `IO ()`. I want to use this in my Show instance for characters
15:58:24 <erisco> well I'd want to understand more basically what role cubical type theory is playing
15:58:37 <MarcelineVQ> it's like regular type theory but it's a cube
15:58:38 <Axman6> :t (:"")
15:58:39 <lambdabot> Char -> [Char]
15:58:54 <erisco> ah, can't believe I didn't think of it!
15:59:07 <MarcelineVQ> yes the tough things are sometimes obvious in retrospect
15:59:30 <nitrix> MarcelineVQ, Yeah, I think you nailed it. Extensional vs Intentional equality. Thank you sir :)
15:59:55 <erisco> it seems like, just from looking at univalence, that that really is the fundamental equality worth concern over, as programmers
16:00:23 <erisco> and sure there is room to do the same thing differently, but univalence says that isn't making anything new
16:00:26 <hekkaidekapus_> > 'λ' : "" -- sondr3: In case you didn’t see that Axman6 is replying to you.
16:00:31 <lambdabot>  "\955"
16:01:08 <hekkaidekapus_> > pure 'λ' :: String
16:01:10 <lambdabot>  "\955"
16:01:14 <monochrom> This is devolving into more and more XY problems piled upon each other.
16:01:39 <monochrom> This is what's wrong with not posting actual code.
16:01:40 <Axman6> and that String, when printed, will produce a string with the lambda in it
16:02:02 <monochrom> As a beginner, you realize that everything you say about your code has nothing to do with your code.
16:02:06 <Axman6> uh, will print a lambda, is probably a better way to say it
16:03:03 <Axman6> % let representChar c = showe c ++ ": " [c] in putStrLn % representChar '\955'
16:03:04 <yahb> Axman6: ; <interactive>:16:23: error:; * Variable not in scope: showe :: a -> [a1]; * Perhaps you meant one of these: `show' (imported from Prelude), `shows' (imported from Prelude); <interactive>:16:57: error:; * Couldn't match expected type `String -> IO ()' with actual type `[a0]'; * Possible cause: `representChar' is applied to too many arguments; In the second argument of `(%)', namel
16:03:09 <erisco> I'd take a univalence t-shirt, is all I'm saying, if someone was looking to raise money for some Haskell community project ;)
16:03:10 <Axman6> % let representChar c = show c ++ ": " [c] in putStrLn % representChar '\955'
16:03:10 <yahb> Axman6: ; <interactive>:17:33: error:; * Couldn't match expected type `[a] -> [Char]' with actual type `[Char]'; * The function `": "' is applied to one argument,; but its type `[Char]' has none; In the second argument of `(++)', namely `": " [c]'; In the expression: show c ++ ": " [c]; * Relevant bindings include; c :: a (bound at <interactive>:17:19); representChar :
16:03:18 <Axman6> % let representChar c = show c ++ ": " ++ [c] in putStrLn % representChar '\955'
16:03:18 <yahb> Axman6: ; <interactive>:18:59: error:; * Couldn't match expected type `String -> IO ()' with actual type `[Char]'; * Possible cause: `representChar' is applied to too many arguments; In the second argument of `(%)', namely representChar '\955'; In the expression: putStrLn % representChar '\955'; In the expression: let representChar c = show c ++ ": " ++ [...] in putStrLn % representCha
16:03:50 <sondr3> I mean, my code is `show (Character a) = show a`, not sure how useful that is
16:03:52 <monochrom> I don't think multiple % on the same line means multiple lines.
16:03:57 <Axman6> % let representChar c = show c ++ ": " ++ [c] in putStrLn $ representChar '\955'
16:03:57 <yahb> Axman6: '\955': λ
16:04:01 <Axman6> I'm bad at this
16:04:38 <monochrom> And this is what's wrong with $ too :)
16:06:09 <hekkaidekapus_> (And that’s a contrived putChar…)
16:07:08 <Axman6> % let representChar c = show c ++ ": " ++ [c] in  representChar '\955'
16:07:08 <yahb> Axman6: "'\\955': \955"
16:08:50 <Axman6> % let representChar c = show c ++ ": " ++ [c] in  representChar '\DEL'
16:08:50 <yahb> Axman6: "'\\DEL': \DEL"
16:08:58 <Axman6> % let representChar c = show c ++ ": " ++ [c] in  putStrLn $ representChar '\DEL'
16:08:58 <yahb> Axman6: '\DEL': 
16:09:05 <Axman6> :o
16:09:37 <hekkaidekapus> Better to take the 1 hour lecture, I’d say :p
16:11:09 <hekkaidekapus> (Next instalment: how to write ‘real’ Show instances…)
16:11:21 <Axman6> deriving Show
16:11:29 <Axman6> NEXT!
16:11:35 <hekkaidekapus> lol
16:12:02 <JavaSucksMan> that maintain read and show being inverses ;-)
16:12:24 <Axman6> or, deriving Show via Hex Foo because DerivingVia is the best 
16:17:18 <sondr3> `parseTest pExpr "#\\x03BB"` -> `#\λ`, yey, thanks all for helping
16:18:27 <nitrix> FYI for the channel, Advent of Code 2020 starts soon :)
16:19:35 <hekkaidekapus> sondr3: In short, Show ought to be used for producing actual Haskell values. If you want to format values for pretty looking-and-feeling, use a formatter or a pretty printer. For instance, <https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Prettyprinter.html>.
16:20:01 <Axman6> yeah don't misuse show please
16:21:12 <erisco> else you'll get pulled over and have to do a read test
16:23:15 <Axman6> we don't like law breakers around 'ere
16:25:08 <sondr3> Fair points, I guess that makes a lot of sense. Coming from Rust I miss Debug/Display, I didn't realize that Show wasn't the same as Display
16:25:52 <Axman6> Show is sort of more about serialisation than printing, but is usually used for the latter
16:30:55 <monochrom> The conflation all began with "42" being a suitable format for all of: serialization, dev's eyes, end-user's eyes.
16:31:18 <Axman6> we should just learn to read CBOR
16:31:46 <monochrom> You can bet that from that example people have only 33% chance of making the correct bet.
16:32:23 <dolio> I'm kind of skeptical that compositional pretty printing would actually work out well.
16:32:44 <erisco> so it didn't work out well in prettier printing?
16:33:23 <dolio> Well, what I mean is pretty printing where how it's done is cobbled together from a dozen instances written by people who don't communicate.
16:33:32 <dolio> Which is the point of Show.
16:34:23 <dolio> 'Show valid Haskell for the value' is a spec you can adhere to and when you combine things, you get output that makes some sense.
16:34:29 <monochrom> You know, a pretty printing library is totally unnecessary unless you have an AST that you want to output in a nicely indented format.
16:35:10 <dolio> 'Show an easy to understand representation of the value' seems much less likely to succeed.
16:35:16 <monochrom> If you are just outputting to a one-line format, even if the input is an AST, all you need is your own recursive X->String function.
16:35:44 <erisco> the only real features of prettier printing, from what I recall, is that of indentation
16:35:51 <monochrom> You don't even need your own bloody class. You only need to think up one single function name.
16:37:55 <hekkaidekapus> printf?
16:39:41 <iqubic> How does one make a haskell project with multiple directories?
16:40:02 <Axman6> mkdir foo bar
16:41:22 <iqubic> I'm running into this error:
16:41:23 <iqubic> https://dpaste.com/BCPQ2TU98
16:41:43 <iqubic> I have a cabal project with a src directory, and inside that I have a Lib folder.
16:42:09 <iqubic> And in src/Lib/ I have Parser.hs.
16:42:33 <koz_> What's the module declaration in Parser.hs?
16:43:08 <iqubic> module Parser where ....
16:43:29 <koz_> iqubic: It's the issue.
16:43:30 <Axman6> needs to be module Lib.PArser
16:43:35 <Axman6> as the error says
16:43:36 <iqubic> Ah.
16:43:37 <koz_> Your module declaration has to match the folder structure.
16:43:40 <koz_> Exactly.
16:43:59 <koz_> (minus the src, because I assume your .cabal has 'hs-source-dirs: src' in it)
16:44:00 <monochrom> Unless you really intend the module name to be Parser
16:45:12 <monochrom> then play with https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-hs-source-dirs
16:45:29 <monochrom> For best results, read the whole chapter carefully.
16:45:55 <justsomeguy> I found this reverse function that is implemented in terms of foldr “rev l = foldr (\x r -> r . (x:)) id l []”, but am having a hard time figuring out what the evaluation steps are. What happens after I get to “((((id . (4:)) . (3:)) . (2:)) . (1:)) []”?
16:46:27 * justsomeguy thinks he misunderstands what the composition operator does.
16:46:28 <monochrom> id . (4 :) = (4 :)
16:46:44 <koz_> :t (2:)
16:46:46 <lambdabot> Num a => [a] -> [a]
16:46:49 <monochrom> (4 :) . (3 :) = (\r -> 4 : 3 : r)
16:46:59 <monochrom> I think you can do the rest.
16:47:02 <iqubic> monochrom: Are you telling me that Parser is a bad name for a module?
16:47:22 <koz_> iqubic: We aren't sure if the issue is that your module is misnamed or if your folder structure is not what you're after.
16:47:24 <monochrom> No. I am saying it is up to you. You make a decision, then either way there is a solution.
16:47:36 <koz_> I assumed the former, monochrom is presenting the solution in case of the latter.
16:48:03 <monochrom> But it's safe to bet if you wrote "module Parser" then that's what you want.
16:48:04 <iqubic> I want it to be called Lib.Parser, because it's in the Lib folder and called Parser.hs
16:48:18 <monochrom> OK then it's "module Lib.Parser"
16:48:23 <koz_> Yep.
16:48:39 <iqubic> No, I wrote 'module Parser', because I have no idea how to do multi-directory haskell projects.
16:49:20 <iqubic> When I import the module from other files, I want to write: "import Lib.Parser"
16:49:28 <monochrom> That's why life is a gamble.
16:49:34 <koz_> hs-source-dirs can contains as many directories as you like.
16:49:49 <koz_> You don't have to limit yourself to just one.
16:50:28 <iqubic> hs-sourc-dirs will only have one directory, src. This file is located at src/Lib/Parser.hs
16:50:34 <Axman6> needs to be module Lib.PArserbut that would be a very unusual layout for the project
16:50:51 <Axman6> uh, "but that would be a very unusual layout for the project"
16:51:38 <monochrom> btw justsomeguy what you're seeing is a special case of how to express foldl as a foldr
16:51:57 <iqubic> Two things: 1) I'm renaming it to from Lib to Common, and 2) This is for Advent Of Code, so I don't care how unusual the layout is.
16:52:30 <iqubic> I'm making my own simple library of functions to use during Advent, and I want to compartmentalize things.
16:52:34 <monochrom> because reverse is a special case of foldl: reverse = foldl (\a x -> x : a) []
16:52:57 <justsomeguy> The foldl version is much easier to read ^_^.
16:53:41 <Axman6> yes
16:53:58 <Axman6> > foldl (flip (:)) [] "abcd"
16:54:01 <lambdabot>  "dcba"
16:54:05 <monochrom> justsomeguy: https://ertes.eu/tutorial/foldr.html  >:)
16:55:57 <iqubic> I still can't believe Ertes is gone.
16:56:16 <iqubic> Also, that tutorial was how I learned to master foldr.
16:57:42 <iqubic> Alright. I finally managed to make multi-directory thing work properly.
16:57:52 <iqubic> Thanks everyone.
16:59:21 <monochrom> I wouldn't call it multi-directory cabal project. On two counts: 1. this is just one package, not even a project of 3 packages; 2. you only have "hs-source-dirs: src", not even "hs-source-dirs: src1 src2 src3 src4/part1 src4/part2"
17:00:43 <iqubic> Right. I see.
17:00:49 <iqubic> That makes sense.
17:22:41 * justsomeguy finished typing out the reduction process for “let rev l = foldr (\x r -> r . (x:)) id l []  in  rev [1,2,3,4]”, and feels like he understands it now.
17:22:46 <justsomeguy> https://gist.github.com/kingparra/e5aeac3f540ef2e2172be9f16cf15b8c
17:23:29 <justsomeguy> I think I'll do that foldr tutorial now.
17:24:28 <dsal> > foldr f a [b, c, d] :: Expr -- justsomeguy 
17:24:30 <lambdabot>  f b (f c (f d a))
17:25:16 <ski> @where folds
17:25:17 <lambdabot> <http://en.wikipedia.org/wiki/File:Fold-diagrams.svg>,<https://cale.l5.ca/share/Folds.svg>
17:25:48 <ski> hm, oh. it was deleted from WP
17:26:00 * ski looks at Cale
17:26:55 <justsomeguy> This is great; Total folding immersion time!
17:27:50 <ski> @where evolution  -- "Yet another senior Haskell programmer (leaned so far right he came back left again!)"
17:27:51 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
17:42:06 <dsal> as justsomeguy descends deep into the catamorph
17:42:19 <_deepfire> Does TH have something that would allow:?  reifyType :: Typeable a => Q Exp
17:51:33 <hekkaidekapus> ski: <https://commons.wikimedia.org/wiki/File:Foldr1-diagram.svg>
17:55:40 <_deepfire> Err, reifyType :: Typeable a => Q Type, of course.
17:58:10 <ski> oh, ty, hekkaidekapus
17:58:19 <ski> although, it's only one of the diagrams
17:59:38 <hekkaidekapus> Yeah, the other link has all them. Maybe another upload to Commons is warranted.
18:01:45 <hekkaidekapus> (The user name is gone, too.)
18:12:14 <ski> @hoogle reifyType
18:12:15 <lambdabot> Language.Haskell.TH reifyType :: Name -> Q Type
18:12:15 <lambdabot> Language.Haskell.TH.Syntax reifyType :: Name -> Q Type
18:12:15 <lambdabot> TH.ReifySimple reifyType :: Name -> Q TypeInfo
18:12:32 <ski> @hoogle Typeable a => Q (TType a)
18:12:33 <lambdabot> Data.Ecstasy defStorage :: HasWorld world m => world ('WorldOf m)
18:12:33 <lambdabot> Data.Ecstasy.Internal defStorage :: HasWorld world m => world ('WorldOf m)
18:12:33 <lambdabot> Data.Ecstasy.Internal defStorage :: (HasWorld world m, Generic (world ('WorldOf m)), GDefault 'True (Rep (world ('WorldOf m)))) => world ('WorldOf m)
18:19:44 * hackage polysemy-extra 0.1.7.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.7.0 (locallycompact)
18:27:18 <hekkaidekapus> I have a Dhall record `{ x.x1 = "foo", y.y1 = "bar", z.z1 = "qux" }` out of which I want to make a Data.Map. I don’t know the labels `x1, y1, z1` beforehand. Any ideas?
18:33:58 <jle`> hekkaidekapus: what map do you want from that?
18:34:57 <hekkaidekapus> I guess that’s part of the question. Let’s say "x <> x1" as a key.
18:36:14 <hekkaidekapus> (Using Prelude.Map.keyText)
18:36:44 * hackage polysemy-path 0.1.0.0 - Polysemy versions of Path functions.  https://hackage.haskell.org/package/polysemy-path-0.1.0.0 (locallycompact)
18:36:52 <hekkaidekapus> But that relies on having a map to begin with…
18:37:36 <koz_> I think what jle` is asking is 'what should the value type of the Map be'?
18:37:43 <hekkaidekapus> Anyway, dirty hacks (through YAML for instance) are welcome.
18:37:46 <koz_> The Dhall record can have values whose types are arbitrary.
18:38:05 <hekkaidekapus> values are Text.
18:38:30 <koz_> So your goal is a Map Text Text?
18:39:27 <koz_> This won't work? http://hackage.haskell.org/package/dhall-1.36.0/docs/Dhall-Map.html#v:toMap
18:39:31 <monochrom> I have a feeling that your dhall parser library already has it. Since aeson already has it.
18:39:32 <hekkaidekapus> koz_: Typing the result in Haskell is easy. The tricky part is finding a way to apply `toMap` on an irregular record.
18:40:08 <koz_> hekkaidekapus: What do you mean by 'irregular'?
18:40:15 <koz_> I thought you said that the values are all Text?
18:40:20 <koz_> Or is that the desired outcome?
18:40:25 <hekkaidekapus> monochrom: aeson hacks are welcome, too.
18:41:16 <hekkaidekapus> koz_: toMap { x = "foo", y = "bar", z = "qux" }` is okay. But toMap on the OP is not.
18:41:49 <monochrom> In aeson if you request "decode to the Value type" you get an Object case that has a hashmap from Text to Text. The keys are the actual, dynamically discovered field names.
18:42:01 <koz_> monochrom: Text to Value.
18:42:15 <monochrom> Oh! oops. That.
18:42:45 <hekkaidekapus> Ok, will try that, thanks.
18:42:55 <hekkaidekapus> YAML ideas?
18:43:14 * hekkaidekapus dislikes JSON with a passion…
18:43:32 <monochrom> This is really not JSON-specific.
18:43:44 <monochrom> I can just as well tell the same story for cassava.
18:44:02 <Axman6> YAML is JSON though
18:44:17 <hekkaidekapus> JSON is YAML, rather.
18:44:20 <Axman6> I should look a Dhall more
18:44:43 <monochrom> cassava is relational database
18:44:46 <monochrom> THERE
18:44:46 <Axman6> I guss
18:44:54 <Axman6> guess*
18:45:11 <jle`> hekkaidekapus: so you're saying you have a dhall reord as an `Expr`? or as a Text/String ?
18:45:35 <monochrom> OK actually just one relational table. You need several csv for an interesting database.
18:46:04 <Axman6> enter frames
18:46:26 <Axman6> (which IIRC also has a dsv backend for parsing, for super fast parsing)
18:46:28 <jle`> s/reord/record
18:46:39 <hekkaidekapus> jle`: The record is an expression.
18:47:23 <jle`> er by that do you mean a Expr type in the dhall library?
18:47:41 <jle`> or an expression as a syntactical idea within dhall
18:48:10 <hekkaidekapus> A Dhall expression. No YAML2Dhall or JSON2Dhall shenanigans yet.
18:48:28 <jle`> so you have it as text, you mean
18:48:33 <jle`> in dhall syntax
18:48:38 <hekkaidekapus> yep
18:50:11 <jle`> hm, i guess you could manually turn it into nested Map's, and then flatten it out in the end
18:50:17 <jle`> by parsing it into a haskell Expr
18:50:40 <Guest648> can anyone help me on kubernetes
18:50:59 <Axman6> does that have anything to do with Haskell?
18:51:10 <koz_> Guest648: Sir, this is a Wendy's^W^W#haskell.
18:51:12 <jle`> your nested map type could be `Free (Map Text) Text`, a nested map with Text as keys and Text leaves
18:51:23 <Guest648> ohhh shit sorry wrong group
18:51:23 <jle`> (a rose tree)
18:51:31 <koz_> jle`: Ah, you mean the same trick Beam uses?
18:51:32 <hekkaidekapus> jle`: Ah, that’s neat!
18:51:42 <jle`> Free should be called Rose anyway
18:51:45 <hekkaidekapus> Free is the key.
18:52:09 <jle`> you don't need to use Free specifically per se, but it does have some neat utility functions for building up and squashing down nested layers
18:52:12 <koz_> jle`: Isn't Free more general though? Rose is a special case where f is some linear collection-ish thing.
18:52:38 <jle`> hm, that's fair :)
18:52:52 <jle`> the name Free just feels a little more mystifying than it needs to be
18:53:07 <jle`> and a lot of other things are free in different ways
18:53:26 <koz_> Yeah, naming is something of an issue sometimes
18:53:34 <hekkaidekapus> Thank you, jle`! I know what you mean (I could go with Generics, too). I was just looking the problem from a Dhall perspective, not a Haskell’s.
18:53:43 * koz_ remembers how like, only recently someone in here freaked out about UndecidableInstances.
18:53:58 <monochrom> Rose tree and Free are great ways of thinking of each other.
18:54:14 <jle`> yeah, if you want to get it into haskell land then i'd probably start with getting it into an Expr
18:54:29 <koz_> monochrom: Rose Free. :P
18:54:37 <jle`> actually the Dhall module has a few tools for parsing Expr's into Haskell types in a type classy way, pretty much equivalent to FromJSON/ToJSON
18:54:47 <jle`> but i'm not sure if they would be too useful here
18:55:19 <hekkaidekapus> jle`: No, here they are useless because of the expression’s irregularity.
18:55:27 <hekkaidekapus> I have to hand-parse the thing.
18:55:47 <Guest648> what are we talking about here
18:55:51 <Guest648> im a haskell pro i can help
18:55:54 <jle`> i meant, you could parse it into a Free (Map Text) using some of the tools there maybe. but yeah, maybe doing it by hand would be the cleanest way
18:56:13 <jle`> Record's are actually already expressed in dhall as a Map Text
18:56:24 <Axman6> Guest648: What is Haskell?
18:56:33 <hekkaidekapus> jle`: Regulat ones, yes.
18:56:41 <hekkaidekapus> *Regular
18:57:01 <Guest648> haskell is a functional programming language axman6
18:57:13 <Axman6> what does that mean?
18:57:17 <jle`> ah yeah, literals i suppose
18:57:31 <koz_> Axman6: Are you attempting the Church-Turing test? :P
18:57:43 <texasmynsted> Hmm. Type Driven Development with Idris is on sale at manning for a couple more hours.
18:57:53 <hekkaidekapus> jle`: Because when you have a map in Dhall, it is trivial to flatten it as a list, and then Data.Map.fromListXXX will do the rest.
18:57:53 <Guest648> it means taking java and inverting it
18:57:55 <Axman6> koz_: that would be telling. You're next
18:58:10 <Axman6> yes, Java is disfunctional
18:58:39 <jle`> hekkaidekapus: by a map in Dhall, do you mean a List { key : Text, val : a } ?
18:58:52 <hekkaidekapus> Yes.
18:59:14 <Guest648> i learned haskell when i was 7
18:59:24 <hekkaidekapus> jle`: And that’s the type of toMap for a record.
18:59:31 <Guest648> i am a haskell prodigy 
18:59:38 <jle`> oh wow i totally forgot that ToMap was a dhall primitive
18:59:45 <jle`> fancy stuff
18:59:46 <koz_> Guest648: 7? Not the womb? Disappoint.
18:59:58 <jle`> yeah, i see what you mean
19:00:00 <hekkaidekapus> jle`: yeah, built-in!
19:00:16 <Guest648> my mom named me cabal
19:00:44 <koz_> Guest648: I thought she named you Guest648?
19:01:14 <texasmynsted> Anybody here read "Type-Driven Development with Idris"?
19:01:26 <koz_> texasmynsted: I did.
19:01:34 <texasmynsted> What is the verdict?
19:01:43 <koz_> It's a great resource if you want to learn Idris.
19:01:51 <koz_> (although you'll need the v2 errata)
19:01:54 <koz_> (at least now)
19:02:10 <Guest648> yes but the haskell book is much better written by the holiest guy named Christopher Allen
19:02:16 <texasmynsted> So it not longer applies?
19:02:34 <koz_> texasmynsted: It is, if you use the v2 errata.
19:02:36 <Guest648> neffective methods and materials have made Haskell unnecessarily hard for many people to learn, but I find Haskell so pleasant to use that I want to help people learn it. I've spent the last two years actively teaching Haskell online and in person. Along the way, I started keeping notes on exercises and methods of teaching specific concepts and techniques that worked. Those notes eventually turned into my guide for learning Haskell. I'm still
19:02:36 <Guest648>  learning how to teach Haskell better by working with people locally in Austin, Texas, as well as online.
19:02:44 <koz_> Edwin posted to this effect just today in fact!
19:03:05 <koz_> Guest648: Were you implemented in Haskell too?
19:03:27 <Guest648> chris allen is the pope for my religion
19:03:35 <texasmynsted> Are you quoting Chris ALlen?
19:03:52 <Guest648> you mean father allen
19:03:56 <koz_> texasmynsted: Gotta cite the implementer.
19:03:58 <texasmynsted> Are you talking about "Haskell from first principles?"
19:04:01 <Guest648> he is a pope after all
19:04:08 <koz_> It's like --version except for chatbots. :P
19:04:37 <Guest648> amazing book you guys should make sure to buy the bible 
19:04:55 <koz_> Guest648: Do you have time to hear about our lord and saviour Nyarlathotep?
19:05:05 <texasmynsted> Sigh
19:05:29 <texasmynsted> I guess I do not really have time for another book to add to the stack
19:06:36 <texasmynsted> I do not really _need_ to learn Idris right now
19:06:55 <Guest648> just read our bible
19:07:04 <Guest648> haskell from first principle covers everything
19:07:40 <texasmynsted> I have the book. 
19:07:43 <texasmynsted> thanks
19:07:47 <Guest648> its the best
19:07:51 <koz_> Guest648: Clearly you have a great desire to ponder the mysteries of our lord and saviour Nyarlathotep.
19:08:07 <justsomeguy> I'm going through hpfp right now and taking notes. Sometimes I really appreciate it and sometimes I hate the verbosity, or think something could be explained better a different way (type classes). It's been kind of a love/hate relationship. Maybe after I finish it I'll write a review.
19:08:21 <Guest648> he doesnt hold a pencil to my pope His holiness Christopher allen
19:08:38 <koz_> Nyarlathotep holds every pencil in his holy tentacles.
19:08:39 <texasmynsted> Really the greatest model for programmer is "keyboard cat" https://www.youtube.com/watch?v=J---aiyznGQ
19:10:42 <texasmynsted> What about Julie?
19:11:17 <koz_> texasmynsted: What about her?
19:11:51 <Guest648> you sir are trolling
19:12:00 <Guest648> i do not appreciate such gestures
19:12:06 <texasmynsted> Guest648: Seems to have much "praise" for Chris but said nothing about Julie.
19:12:17 * koz_ would like to make some kind of mirror joke here, but it makes itself.
19:12:25 <hekkaidekapus> koz_: <https://paste.tomsmeding.com/FajoLeow> for when you will decide to give Dhall a close look.
19:12:55 <koz_> hekkaidekapus: I figured I never wanted to, and now I'm even more certain. :D
19:12:56 <Guest648> no julie left his holiness
19:13:04 <Guest648> and joined chris martin 
19:13:55 <koz_> Guest648: Was your father Andrei Markov by any chance?
19:13:57 <Guest648> my loyalty lies only to His holiness Martin
19:14:16 <hekkaidekapus> koz_: Be happy in your weakly typed gardens, C (I mean JSON) and Python (err. YAML). :p
19:14:30 <koz_> hekkaidekapus: Who said I liked any of those things?
19:14:42 <koz_> Something something argumentum ad serpentum.
19:14:48 <hekkaidekapus> heh
19:14:58 <texasmynsted> Yes, Chris Martin and Julie Moronuki's site is impressive. 
19:15:16 <Guest648> when will chris allen give a sermon in this channel
19:15:39 <texasmynsted> Guest648: Who are you?
19:15:49 <koz_> Guest648: The only one who gives sermons here is the Most Holy SPJ.
19:15:52 <Guest648> a loyal follower
19:15:55 <koz_> But alas, it has never occurred.
19:16:04 <texasmynsted> I have never seen SPJ here
19:17:21 <koz_> (also, shouldn't it be SP-J?)
19:17:51 <hekkaidekapus> SLP-J
19:18:55 <hekkaidekapus> Since Idris was brought up, did you notice `it : …`, koz_?
19:19:12 <koz_> hekkaidekapus: Am I missing something?
19:19:21 <Guest648> can somoene please help me in kubernetes
19:19:30 <Axman6> no
19:19:35 <koz_> Guest648: Can you get me a double chocolate ice cream?
19:19:45 <Guest648> only if u help me first
19:20:07 <koz_> Is your problem with Haskell?
19:20:08 <hekkaidekapus> koz_: In the paste, there is an expression `it` typed `{ x : { x1 : Text }, …`, à la Idris.
19:20:18 <koz_> hekkaidekapus: Ah! No, I didn't notice that.
19:20:21 <koz_> Interesting.
19:20:27 <Guest648> thats not how you reduce hekkaidekapus
19:20:29 <Guest648> tbats wrong
19:20:34 <Guest648> you dont know your lambda calclus
19:20:38 <Guest648> read the haskell book
19:20:48 <hekkaidekapus> koz_: See, close look I was saying… :d
19:21:10 <kupi> i think the "do" here is redundant in the example, am i wrong? https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Exception-Base.html#v:handle
19:21:33 <texasmynsted> Guest648: I think you are looking for twitter
19:21:45 <koz_> texasmynsted: Or treatment.
19:21:53 <texasmynsted> why not both?
19:22:04 <Guest648> what treatment would i need?
19:22:17 <koz_> texasmynsted: I don't think they coincide well. :P
19:22:27 <koz_> Guest648: Do you want me to answer sincerely?
19:22:32 <Guest648> yes
19:22:38 <koz_> Guest648: Too bad.
19:23:36 <Guest648> what is chris allens irc
19:23:51 <dsal> He uses the same one the rest of us use.
19:24:15 <dsal> At least he used to.  I've not seen him around in a while.
19:24:23 <koz_> Guest648: I'll tell you if you fax me some chocolate ice cream.
19:24:51 <texasmynsted> I think it is bitemyapp
19:25:14 <Guest648> no
19:25:20 <Guest648> it doesnt exist
19:25:56 <texasmynsted> Perhaps you simply do not have enough faith 
19:27:30 <Guest648> oh my god you are right!
19:27:40 <MarcelineVQ> kupi: not neccesarily redundant, they just happen to be giving an example that uses  do
19:28:56 <MarcelineVQ> Actually I think I see what you mean since there's that $ there too
19:31:45 <kupi> "do io" is the same as "io" right?
19:31:49 <monochrom> You know, "handle (\NonTermination -> exitWith (ExitFailure 1)) $ do ..." is much more convincing and common.
19:31:57 <monochrom> Yes.
19:33:29 <koz_> . o O ("do or do not, there is no try")
19:34:03 <monochrom> I write "do try" all the time :)
19:34:06 <int-e> DONT GIVE UP
19:43:43 * hackage uusi 0.3.0.0 - Tweak dependencies in .cabal files  https://hackage.haskell.org/package/uusi-0.3.0.0 (berberman)
19:45:00 <dsal> @undo do io
19:45:00 <lambdabot> io
19:45:08 <dsal> ^ kupi 
19:45:17 <Axman6> @undo do do do io
19:45:17 <lambdabot> io
19:45:51 <kupi> @undo do x <- oi1; y <- io2; return (x+y)
19:45:51 <lambdabot> oi1 >>= \ x -> io2 >>= \ y -> return (x + y)
19:46:21 <koz_> Axman6: lol
19:46:40 <kupi> nice but I would prefer liftA2 (+) io1 io2
19:46:56 <dsal> Sure, but that means something different.
19:47:14 <koz_> 'do do do io' <- truly the time when do-notation is considered harmful
19:47:30 <dsal> @undo do harm
19:47:30 <lambdabot> harm
19:47:37 <kupi> dsal: what is the difference?
19:47:57 <dsal> :t liftA2
19:47:58 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:48:22 <koz_> @undo do the wrong thing
19:48:22 <lambdabot> the wrong thing
19:48:28 <dsal> You'll have the same effect, but it's not un`do`ing.
19:48:45 <dsal> koz_: some mistakes can't be undood
19:49:02 <koz_> dsal: This.
19:49:09 <int-e> @. pl undo do x <- oi1; y <- io2; return (x+y)
19:49:09 <lambdabot> (`fmap` io2) . (+) =<< oi1
19:49:27 <int-e> . o O ( that went perfectly )
19:49:27 <kupi> is there a separate program I can use this "undo"?
19:49:32 <koz_> int-e: That is a truly shocking combo and I am impressed.
19:49:42 <kupi> til not i have done undo a lot of times by hand
19:49:46 <kupi> *til now
19:49:51 <dsal> kupi: /query lambdabot 
19:50:11 <koz_> Do undo others as they undo you.
19:50:23 <dsal> haha.  That's perfect.
19:51:04 <kupi> dsal: most undos are multilines so i can't send it to lambdabot
19:51:09 <kupi> *dos
19:51:29 <dsal> @undo do { line1 ; x <- line2; pure awesome }
19:51:29 <lambdabot> line1 >> line2 >>= \ x -> pure awesome
19:51:29 <int-e> why do you want to undo so much?
19:51:44 <koz_> :t pure fail
19:51:46 <lambdabot> (MonadFail m, Applicative f) => f (String -> m a)
19:51:56 <kupi> because it creates bigger namespaces than it should
19:51:58 <koz_> int-e: Mistakes were made.
19:52:03 <kupi> most of the times
19:52:07 <dsal> do creates namespaces?
19:52:15 <kupi> yes
19:52:15 <int-e> people use do notation because most find it more readable than the bindful version
19:52:18 <dsal> do is just a syntax
19:52:53 <kupi> @undo x <- m1; y <- m2 x; return m2
19:52:53 <lambdabot> <unknown>.hs:1:3:Parse error: <-
19:53:00 <kupi> @undo do x <- m1; y <- m2 x; return m2;
19:53:00 <lambdabot> m1 >>= \ x -> m2 x >>= \ y -> return m2
19:53:02 <koz_> 'Do creates namespaces' is a take I didn't think I'd hear today.
19:53:16 <dsal> You cannot undo that which has not been dood.
19:53:21 <kupi> here x can be accessed in m2
19:53:27 <kupi> * return
19:53:30 <kupi> but not used
19:53:46 <dsal> That's not a namespace, though.
19:53:51 <kupi> maybe i use the wrong word but the scope has more variables than it should
19:54:02 <kupi> also the code is longer than it shold be
19:54:09 <dsal> You just made a new scope and reused the same name.  It doesn't matter whether you're using do or not there.
19:54:33 <int-e> koz_: well the same effect can be achieved through lambdas... which is what @undo produces
19:54:36 <kupi> it's simply just m1 >>= m2
19:54:45 <dsal> @. pl undo do x <- m1; y <- m2 x; return m2
19:54:45 <lambdabot> (m2 =<< m1) >> return m2
19:55:20 <kupi> what is .pl?
19:55:30 <dsal> . is compose
19:55:38 <dsal> pl is to render pointless
19:55:58 <kupi> @. pl undo do x <- m1; y <- m2 x; return y;
19:55:58 <lambdabot> m2 =<< m1
19:56:09 <monochrom> You don't have namespacing unless you have special syntax for accessing names outside the default namsepace.
19:56:10 <kupi> that is the reason i want to undo
19:56:28 <dsal> Oh, that's more pl than undo.
19:56:40 <int-e> yeah, namespace != scope
19:56:57 <monochrom> If you write "\x -> \x -> ???" inside the ??? you have absolutely no syntax that gives you the 1st x. Therefore this is not namespacing.
19:57:17 <koz_> Yay name shadowing.
19:57:37 <kupi> is there a way to send lambdabot multiple lines in a command?
19:57:43 <monochrom> Whereas if you write "\null -> ???" inside the "???" you can still write "Prelude.null" for the global null, now that's namespacing.
19:58:11 <int-e> koz_: no
19:58:16 <int-e> hmmm
19:58:20 <int-e> kupi: 
19:58:57 * dsal listens to monochrom's "Now that's what I call namespacing, volume Prelude"
19:59:00 <int-e> ("hmmm" was me wondering how I managed to mess up this name)
19:59:14 <koz_> int-e: Lotsa folks with k-names?
19:59:16 <dsal> kupi: ; is a newline
19:59:41 <int-e> > let foo x y | x <- x+1, y <- y+2 = x*y in foo 1 1 -- yay shadowing
19:59:43 * hackage newtype-zoo 1.2.1.0 - Newtype Wrapper Zoo  https://hackage.haskell.org/package/newtype-zoo-1.2.1.0 (SvenHeyll)
19:59:43 <lambdabot>  6
19:59:47 <dsal> kupi: but in general, describing an abstraction of your problem will be much easier than pasting a bunch of code verbatim.
20:00:24 <dsal> pl isn't all knowing, either.  It just knows a bunch of dumb tricks.  Not every trick, though.
20:00:42 <monochrom> It's also pretty old.
20:01:03 <monochrom> It's, like, before Applicative.
20:01:26 <kupi> is there a separate program for those tricks? hlint does not know all of those dumb tricks
20:01:51 <int-e> @hackage pointless
20:01:51 <lambdabot> https://hackage.haskell.org/package/pointless
20:02:11 <int-e> @hackage pointfree
20:02:11 <lambdabot> https://hackage.haskell.org/package/pointfree
20:02:18 <int-e> that one, sorry. I misremembered the name.
20:02:39 <int-e> Or rather, the package is not named properly :-P
20:32:34 <kupi> what have i done?
20:32:35 <kupi> (getRecursiveContents >=>) . filterM . fix . const . (`ap` getModificationTime) . (`ap` getFileSize) . (`ap` getPermissions) . (liftA3 .)
20:33:04 <monochrom> Transcendence
20:33:16 <Axman6> made difficult to read code
20:35:06 <kupi> this was the original code but i am not satisfied with it https://gist.github.com/theqp/08eb2d8780c638b892019b3b5ad23963
20:36:30 <int-e> . o O ( Where is liftA4 when you "need" it... )
20:36:52 <Axman6> I prefer your original code
20:37:11 <kupi> me too
20:37:13 * hackage numhask-free 0.0.2 - Numerical free algebras  https://hackage.haskell.org/package/numhask-free-0.0.2 (tonyday567)
20:37:28 <monochrom> @type fix . const
20:37:30 <lambdabot> c -> c
20:37:45 <monochrom> IIRC earlier today we established that fix . const = id
20:38:06 <kupi> what
20:38:26 <monochrom> > (fix . const) "hello"
20:38:29 <lambdabot>  "hello"
20:38:35 <monochrom> > (fix . const) False
20:38:37 <kupi> it was id all along?
20:38:37 <lambdabot>  False
20:38:38 <int-e> . o O ( check = liftA4 liftA3 p getPermissions getFileSize getModificationTime )
20:39:16 <MarcelineVQ> :<
20:39:32 <Axman6> beautiful
20:40:47 <int-e> @hoogle liftA4
20:40:47 <lambdabot> Control.Applicative.HT liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
20:40:47 <lambdabot> Util liftA4 :: Applicative p => (a -> b -> c -> d -> e) -> p a -> p b -> p c -> p d -> p e
20:40:47 <lambdabot> Rank2 liftA4 :: Apply g => (forall a . p a -> q a -> r a -> s a -> t a) -> g p -> g q -> g r -> g s -> g t
20:41:25 <int-e> Util, what a great public module name 
20:42:29 <Axman6> it's probably a decade old and and in something like missing-h
20:42:54 <Axman6> I remember the days when there was some very common packages which just added functions people thought were missing in base packages
20:44:39 <int-e> that probably only stopped once all the good names were taken, like https://hackage.haskell.org/package/extra
20:45:20 <int-e> (seriously it hasn't stopped. the novelty has worn off though)
21:11:43 * hackage numhask-free 0.0.3 - numerical free algebras  https://hackage.haskell.org/package/numhask-free-0.0.3 (tonyday567)
21:14:13 * hackage hinterface 2.0.1 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-2.0.1 (SvenHeyll)
21:18:20 <koz_> Haskell is the strongest language; all we do is lift.
21:19:29 * Clint slowclaps.
21:22:17 * koz_ bowbows.
21:36:18 <int-e> write pure code, it's easy; no lifting required
22:39:22 * suzu_ scratches chin and nods
23:49:45 <hololeap> % :t (\(a,fb) -> (a,) <$> fb) 
23:49:46 <yahb> hololeap: Functor f => (t1, f t2) -> f (t1, t2)
23:49:53 <hololeap> is there a name for this?
23:51:18 <merijn> strong, iirc
23:53:10 <dminuoso> hololeap: looks like first from Arrow
23:53:22 <jle`> it's sequence in base, but yeah i think formally it is strength/strong/etc.
23:54:04 <dminuoso> Or yeah, Strong is better
23:54:04 <jle`> > sequence (3, Just "hi")
23:54:07 <lambdabot>  Just (3,"hi")
23:54:29 <jle`> but i don't really like using sequence for it because it's a weird positional fluke kinda
23:54:41 <jle`> and i try to avoid using Foldable/Traversable for tuples when i can
23:55:02 <jle`> > bitraverse pure id (3, Just "hi")
23:55:05 <lambdabot>  error:
23:55:05 <lambdabot>      • Variable not in scope:
23:55:05 <lambdabot>          bitraverse
23:57:23 <hololeap> jle`: you're right, it's just sequence. i got mixed up and thought (,) needed to be an Applicative, e.g. a Monoid in the first value
23:58:50 <dminuoso> Well it does.
23:58:54 <dminuoso> instance Monoid a => Applicative ((,) a)
23:59:11 <dminuoso> Oh.
