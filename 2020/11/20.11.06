00:00:02 <sclv> https://ghc.gitlab.haskell.org/ghc/doc/users_guide/packages.html#package-environments rather
00:00:18 <loximann> Indeed renaming ~/.ghc as ~/.ghc_hide fixed that!
00:00:22 * hackage morloc 0.33.0 - A multi-lingual, typed, workflow language  https://hackage.haskell.org/package/morloc-0.33.0 (arendsee)
00:00:56 <sclv> w00t
00:02:09 <loximann> I guess the environment file .ghc_hide/x86_64-linux-8.8.4/environments/default was broken somehow
00:02:16 <loximann> I'll look into that. Thanks :-)
00:02:34 <sclv> cabal can write to it depending on the version and configuration
00:04:42 <loximann> Weird. All the packages seem to be listed in the environment file
00:08:19 <loximann> Alright, apparently there was a left over cache lock? I removed .ghc/x86_64-linux-8.8.4/package.conf.d/package.cache.lock and it all seems to work
00:11:12 <loximann> Thanks a lot for your help! :-D
00:16:36 <Uniaika> have a nice one, loximann :)
00:22:23 * hackage yesod-auth 1.6.10.1 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.6.10.1 (MichaelSnoyman)
00:24:16 <jchia> Without using temp files or writing to another file, how can I remove lines with a certain prefix from a UTF-8 text file using only memory that scales with the size of the prefix or at most the size of the longest line? I know the idea but want to know how to express it elegantly in Haskell.
00:24:59 <jchia> i can even simplify the problem and say the file encoding is latin-1.
00:25:33 <pjb> read line, write line or not, repeat.
00:25:37 <jophish> sed '/^prefix/d'
00:26:05 <jchia> jophish: I know sed can do it. I just want to do it simply in Haskell
00:26:08 <pjb> The trick is that either you open the file twice, or you just between the read position and the write position.
00:26:17 <jchia> pjb: If I write to the file while reading, will I get data corruption?
00:26:22 <pjb> Nope.
00:26:31 <pjb> Because you are only _removing_ lines.
00:26:45 <jchia> pjb: open with two handles, one for read one for write?
00:27:10 <pjb> Well, you have to be careful, because if you remove a small line, while copying a big following lines, indeed you would have an overlap.
00:27:22 <pjb> Better to use fixed buffers.
00:28:26 <pjb> The simpliest is to use a temporary file.
00:29:30 <jchia> I'll just do it the naive way. It's not a real problem I have to solve as the file is not that big. Just wondering if there is an elegant way to do it with a low memory footprint.
00:30:03 <pjb> If the file can be read entirely in RAM, then indeed, read, split, delete, write.
00:30:21 <pjb> In that case you may use a single file, if you have access to a truncate(2) syscall.
00:30:23 * hackage yesod-persistent 1.6.0.5 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.6.0.5 (MichaelSnoyman)
00:30:40 <pjb> It's not in POSIX, but in BSD and Linux.
00:33:06 <merijn> pjb: Why even bother "removing lines"?
00:33:34 <pjb> fixed-size record files are easier to work with.
00:33:39 <merijn> You just gotta keep track of the end of the last "keep" line and copy the next "keep" line after there
00:33:50 <merijn> You can never overlap data you care about that way
00:34:02 <merijn> Since you only ever copy data "forward"
00:34:40 <merijn> jchia: It can be done, whether it's worth the effort is the real question
00:39:19 <tomsmeding> can be a nice learning task I guess, it's not too hard to do it this way
00:39:36 <tomjaguarpaw> Is there a simple and well-maintained CI setup for Haskell packages that people recommend these days?
00:39:45 <tomjaguarpaw> I have been using Travis, but the writing is on the wall.
00:39:52 * hackage yesod-auth-oauth 1.6.0.2 - OAuth Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-oauth-1.6.0.2 (MichaelSnoyman)
00:44:08 <merijn> Github Actions? :p
00:50:48 <Uniaika> tomjaguarpaw: GitHub Actions
00:52:16 <tomjaguarpaw> I mean is there simple and well-maintained Haskell code to use the CI service :D
00:53:44 <dminuoso> tomjaguarpaw: gitlab-ci+gitlab-runner
00:53:53 <dminuoso> Jenkins
00:54:01 <dminuoso> Anything that can run a single `cabal build` works for 95% of hackage.
00:54:09 <dminuoso> (Or stack equivalent)
00:55:13 <dminuoso> Fundamentally, my gitlab ci jobs do nothing more than `cabal build ...; cp $(cabal-plan list-bin ...) ...`
01:04:52 <jophish> tomjaguarpaw: https://github.com/expipiplus1/exact-real/blob/master/.github/workflows/ci.yml#L6-L49
01:05:04 <jophish> seems to work well enough for me
01:05:17 <jophish> or were you asking about a CI service API in haskell?
01:05:33 <merijn> tomjaguarpaw: Or update Haskell-CI with a Github actions backend :p
01:06:05 <merijn> dminuoso: The Haskell-CI travis tests are more in depth than simply checking if "cabal build" works, though
01:06:17 <merijn> dminuoso: they also test sdist, different confiurations, etc.
01:06:47 <dminuoso> merijn: all easily written into a shell script.
01:07:12 <jophish> I've been working on a couple of scripts which allow me to comment "/bump major" on a PR and have a bot push a commit updating the changelog and version number, https://github.com/expipiplus1/update-nix-fetchgit/pull/46
01:07:20 <merijn> Right, but the point of haskell-ci was to not have to rewrite that shell script every time ;)
01:07:28 <dminuoso> Write it once, share it across projects
01:07:32 <jophish> and another script which watches master for changes to the version, and pushes a tag
01:07:36 <dminuoso> Chances are, your CI needs need custom tailoring *anyhow*
01:07:44 <jophish> and another script which watches tags and makes a release when a new tag comes along
01:07:49 <dminuoso> The idea that there's this "general CI setup that works for all" is a bit silly
01:07:55 <merijn> dminuoso: that's what haskell-ci *is* and probably why he asked for something like that for "not travis" :p
01:08:05 <dminuoso> ah..
01:08:08 <jophish> https://github.com/expipiplus1/action-automation
01:08:15 <dminuoso> I stick to my point. Just write it yourself, its not that hard...
01:08:17 <dminuoso> :p
01:09:03 <merijn> dminuoso: Writing a github actions version is on my (continuously growing) "post-thesis" todo list already :p
01:09:13 <jophish> Is travis really going anywhere, I mean I certainly wouldn't use it for anything new over something integrated with gitlab or github, but surely it's got some life left?
01:10:06 <Taneb> jophish: I'd heard they're removing free support for open source
01:10:14 <jophish> seriously?
01:10:16 <jophish> wow
01:10:23 <jophish> How's things, Taneb ?
01:10:35 <dminuoso> jophish: you dont read news, do you?
01:11:01 <Taneb> dminuoso: it's not exactly the kind of thing that makes it into newspapers
01:11:15 <dminuoso> travis CI was bought off by a company that has made a habit of "buy company, fire all senior staff, and milk the cashcow for as long as you can"
01:11:30 <dminuoso> and as it turned out, a week later most of the senior staff was laid off..
01:11:50 <jophish> dminuoso: I can't read, sorry
01:12:09 <dminuoso> Taneb: oh I meant tech news I guess :)
01:12:43 <jophish> I get all my news from /r/copypasta
01:13:10 <dminuoso> There is such a sub?
01:15:02 <jophish> To be fair, it was the first news outlet to call the race for Biden
01:20:41 <int-e> jophish: how would you know if it's the only one you read
01:22:00 <int-e> (also, the name suggests that it'll at best be second, if they're quick enough to copy and paste)
01:27:08 <merijn> dminuoso: Man, there's subs for everything :p
01:28:15 <kuribastard> applicative do looks nice for pararallelizing stuff.  It should be enough to have a parallel (<*>) method, and let the desugaring handle the paralellism, right?
01:28:45 <kuribastard> For example batching queries to a database.
01:28:55 <merijn> kuribastard: Congratulations you have reinvented Facebook's Haxl :p
01:29:43 <merijn> kuribastard: http://events.techcast.com/bigtechday10/Garmisch-1345/?q=Garmisch-1345
01:29:55 <kuribastard> merijn: ah cool, I could use that :)
01:30:10 <kuribastard> merijn: so simply relying on the desugaring isn't enough?
01:30:54 <merijn> It depends on how far you wanna go
01:31:02 <merijn> And what you mean by "desugaring"
01:31:22 <merijn> But Simon's talk there is mostly about batching database queries, so... :p
01:32:12 <kuribastard> nice, that could be pretty helpful
01:34:24 <kuribastard> merijn: that slides is pretty nice :)
01:37:52 <kuribastard> it syncronises the slide with the video
01:38:01 <kuribastard> I haven't seen that before
01:43:53 * hackage ukrainian-phonetics-basic 0.1.10.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.10.0 (OleksandrZhabenko)
01:44:44 <jchia> Is anyone experiencing Haskell Language Server taking >= 30GB RSS (resident set size) when editing a few files that are a few hundred lines in total long? I have a beefy machine but I wonder whether people with less RAM regularly encounter OOM problems when running HLS.
01:45:05 <jchia> The RAM usage does not start up that big, but it grows.
01:45:13 <merijn> Might be a leak?
01:45:25 <merijn> Which version of hls? I know there were some leaks in earlier versions
01:46:00 <merijn> ooh!
01:46:08 <merijn> Pijul 1.0 release!
01:46:24 <jchia> I'm running hls that I built from a Sep 10 commit.
01:46:27 <merijn> (although, I guess they rebranded?)
01:59:23 * hackage cobot-io 0.1.3.10 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.3.10 (ozzzzz)
02:11:50 <tomjaguarpaw> jophish: Thanks. I will respond to your email soon.
02:12:53 * hackage phonetic-languages-properties 0.1.1.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-properties-0.1.1.0 (OleksandrZhabenko)
02:24:57 <mikevdg> Where is the "do" notation processed? Is it something the compiler knows specially about and is built in to the grammar of Haskell, or is it done using some funky function definition foo?
02:26:02 <merijn> mikevdg: It's syntactic sugar, so part of the syntax/grammar, yes
02:26:35 <merijn> mikevdg: The desugaring is pretty straightforward: https://en.wikibooks.org/wiki/Haskell/do_notation
02:27:01 <mikevdg> Does Haskell have a mechanism for letting you define your own syntactic sugar, or would that involve breaking ghc open and modifying it?
02:27:22 * hackage phonetic-languages-examples 0.1.1.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.1.1.0 (OleksandrZhabenko)
02:27:39 <merijn> mikevdg: You can either break open GHC, or you can use QuasiQuotes
02:29:14 <mikevdg> Hey thanks
02:30:04 <jophish> int-e: ! hahah
02:30:11 <jophish> you're quite right
02:30:39 <jophish> micahsovereign[m: consider looking at -XRebindableSyntax too
02:46:16 <Cheery> when I define type family Trim a where Trim ...
02:46:30 <Cheery> is it possible to associate functions to the items?
02:47:12 <dminuoso> Cheery: use a typeclass with an associated type
02:48:11 <Cheery> so I had this problem while days ago and it got back.
02:48:17 <merijn> dminuoso: How does do that?
02:48:23 <jophish> n
02:48:42 <Cheery> https://www.reddit.com/r/haskell/comments/jmzg57/is_it_possible_to_trim_unit_types_away_from_a_type/
02:48:45 <kuribastard> merijn: yes, haxl is exactly the functionality I wanted to implement.  That'll save me a lot of work :)
02:48:48 <merijn> associated types aren't really any different from regular type families, tbh
02:50:03 <kuribastard> merijn: I already was designing a complicated system for doing dependency analysis, before it occured to me that applicative does that exactly, but for free.
02:51:25 <Cheery> merijn: what do you mean? does this thing I have desugar into something else?
02:52:18 <merijn> Cheery: I was refering to dminuoso's suggestion, which afaict can't actually fix your problem
02:53:02 <merijn> Cheery: oh, those functions in that reddit post aren't possible
02:53:27 <merijn> Cheery: Because the implementation depends on their input type which only works if you have either a typeclass or some kinda witness, like a GADT
02:59:41 <Cheery> merijn: well is there some other way to remove units from a type?
03:00:05 <merijn> eh "a function"?
03:00:55 <Cheery> I get a type, and I'd like it to drop units deep in that type.
03:01:32 <merijn> There's no (sane) way of doing that in general
03:03:12 <Cheery> I accept datakinds
03:03:48 <Cheery> merijn: I accept datakinds, it's ok if it's not entirely sane
03:04:06 <merijn> I don't know how to do it the insane way either
03:04:16 <merijn> It's probably possible, but you're on your own
03:04:50 <Cheery> yeah.. well I try figure out. I think it can be done.
03:05:02 <merijn> I'd recommend either: 1) "well don't return stuff you don't want/need then", or 2) accepting life
03:06:00 <Cheery> https://github.com/cheery/haskell-rady
03:06:55 <Cheery> for example: the aa(b|c) corresponds to ((),((),Either () ()))
03:07:09 <Cheery> trim it, you get Either () ()
03:08:29 <Cheery> well I'll try those datakinds.
03:09:19 <Cheery> merijn: the point is, there's a good usecase
03:12:22 * ski . o O ( `Either (Either Void ()) (Either (Either Void Void,Either () ()) (Either () ((),()),Either () (Either () Void)))' )
03:17:21 <kuribastard> Cheery: the real question is, why do you want this?
03:17:32 <kuribastard> Cheery: it sounds like an XY problem
03:19:32 <jollygood2> hi. what library do you recommend using for displaying graphs on a webpage?
03:22:18 <tomsmeding> merijn: pijul 1.0 where? also what rebrand?
03:22:31 <Uniaika> it's anu.dev now, tomsmeding 
03:23:00 <tomsmeding> oh wow
04:12:02 <Cheery> kuribastard: if you have structures defined with a regex, it's nice to take the actual regex, then form a type from it.
04:12:27 <Cheery> kuribastard: however, the type will have units because all parts of a regex do not carry information on match.
04:12:58 <Cheery> Tool to trim all the units away from the type would be convenient.
04:16:53 * hackage reflex 0.7.2.0 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.7.2.0 (abrar)
04:30:38 <lortabac> Cheery: there is a trick to avoid the problem of overlapping instances
04:30:52 * hackage http2-client 0.10.0.0 - A native HTTP2 client library.  https://hackage.haskell.org/package/http2-client-0.10.0.0 (LucasDiCioccio)
04:31:01 <lortabac> it is verbose, but it should work, I have used it on more than one occasion
04:31:42 <Cheery> lortabac: what is that trick?
04:31:53 * hackage cachix-api 0.5.0 - Servant HTTP API specification for https://cachix.org  https://hackage.haskell.org/package/cachix-api-0.5.0 (domenkozar)
04:31:54 <lortabac> Cheery: you define an auxiliary data type, where each constructor corresponds to one equation in the Trim type family
04:32:36 <lortabac> then you define an auxiliary type family that maps from the input of Trim to this auxiliary data type
04:33:13 <lortabac> and a type class with one instance for each of the constructors
04:34:06 <merijn> tomsmeding: The new nest seems to be buckling under the load, though xD
04:34:13 <Cheery> in this case the problem is the ((),a) etc.
04:34:17 <tomsmeding> r.i.p.
04:34:49 <tomsmeding> when I checked it an hour ago it was still pretty quick
04:35:10 <tomsmeding> I guess populatity is a good thing :)
04:35:11 <Cheery> lortabac: ok, I'm not sure if I figured what you mean, but I'll try this.
04:35:43 <merijn> Cheery: The solution is to not build ((),a) in the first place if 'a' is what you want
04:35:46 <kuribastard> Cheery: I don't get why you would need types for this.
04:36:01 <kuribastard> Cheery: If I need something more typed and complicated, I would use parsec.
04:38:48 <lortabac> Cheery: if you need help you can ping me
04:39:02 <kuribastard> Cheery: and if the interface provided by the regex library is not convenient, you just create your wrapper on top of it.
04:39:58 <lortabac> Cheery: TBH I don't know whether this is a good idea or not, I just wanted to say that it's technically possible
04:41:27 <Cheery> lortabac: well it may be easier to see that once done.. I want to try this. Ok. I start.
04:42:18 <Cheery> Ok, so lets take a simpler version of Trim that produces the problem. I think it's enough to take the pair.
04:42:52 * hackage cachix 0.5.0 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.5.0 (domenkozar)
04:46:22 * hackage compdoc-dhall-decoder 0.2.0.0 - Allows you to write FromDhall instances for Compdoc  https://hackage.haskell.org/package/compdoc-dhall-decoder-0.2.0.0 (locallycompact)
04:49:32 <Cheery> lortabac: now I have data Aux = DropLeft | DropRight | KeepBoth | Keep, and type family TrimAux a that maps inputs of Trim to Aux
04:50:55 <lortabac> Cheery: I think you need to include the arguments as well
04:51:27 <Cheery> you mean it needs to be a GADT?
04:51:39 <lortabac> something like data Aux a b = Dropleft a | DropRight a etc.
04:51:57 <lortabac> otherwise you would lose information
04:53:59 <lortabac> TrimAux is identical to Trim on the LHS, but returns an Aux on the RHS
04:54:13 <merijn> Cheery: Basically you can't pick "what function implementation to use" based on the type, so having a type family compute the right type doesn't let you magically specify the right logic to implement said function
04:54:36 <merijn> (well, you can pick implementation based on types...when you use a typeclass)
04:55:52 * hackage HsOpenSSL 0.11.5.1 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.5.1 (VladimirShabanov)
04:56:23 <lortabac> then each class instance matches one of Aux's constructors and mimic Trim's behavior at value level
04:56:30 <merijn> Is there a way to make executables (of Haskell dependencies) available at runtime?
04:56:32 <Cheery> lortabac: how about the typeclass? class Foo (a::Aux)
04:56:51 <Cheery> hmm..
04:59:01 <lortabac> in general you need a very good reason to go through all this painful contorsion, I have only every needed this trick when implementing Servant extensions
05:02:30 <tomsmeding> Cheery: not sure if it's relevant for you, but I was reading a paper and saw a reference, and recalled how you'd been talking here today about typed regular expressions
05:02:34 <tomsmeding> https://github.com/sweirich/dth/tree/master/regexp exists
05:03:06 <tomsmeding> note also the popl17 talk apparently
05:05:40 <Cheery> tomsmeding: thanks. I will look in.
05:05:48 <kuribastard> merijn: does haxl support mutating queries?
05:06:48 <Cheery> lortabac: is there a text I can read about this one? I mean, it's data in a typeclass.
05:07:10 <Cheery> Foo Nil, Foo (Cons x y) etc...
05:07:17 <lortabac> the GHC user guide -- DataKinds chapter
05:09:47 <jophish> merijn: using Nix?
05:10:59 <bqv> ^
05:13:08 <Cheery> lortabac: once I have what you proposed me to make, how would I use it?
05:13:22 * hackage discord-register 0.0.1 - Discord verification bot  https://hackage.haskell.org/package/discord-register-0.0.1 (HughSipiere)
05:13:29 <Cheery> to implement trim :: a -> Trim a, and fill :: Trim a -> a.
05:14:47 <jophish> Cheery: I haven't been paying attention, but is Trim a bijection?
05:16:50 <Cheery> jophish: nope. The idea is to take a type built from algebraic elements, and produce a corresponding type with no units in it.
05:17:04 <lortabac> I don't know what 'fill' is supposed to do, but 'trim' should become a method of the class
05:17:31 <Cheery> ok, lets forget about 'fill' for a moment then, and look at the trim.
05:17:34 <jophish> Cheery: ok, so would fill be :: a -> ((), a) or :: a -> (a, ())
05:17:40 <jophish> (or any other of the infinity options)
05:17:58 <Cheery> jophish: yup.
05:18:01 <lortabac> instance Trim ('DropLeft a) where trim ((), a) = a
05:18:06 <lortabac> etc.
05:18:15 <jophish> Ah I see
05:18:36 <lortabac> maybe I got some details wrong, but I hope you get the idea
05:18:43 <jophish> Yeah, I get the gist of it
05:18:50 <merijn> jophish: No, not using Nix, because the goal is have this be usable by actual mortals :)
05:20:42 <jophish> merijn: perhaps then you could do some custom setup stuff to call cabal install to put the dependency binaries in some install location?
05:20:45 <lortabac> Cheery: upon reflection, the arguments in Aux's constructors are probably useless, because 'trim' behaves the same whatever the type
05:22:53 * hackage patch 0.0.3.2 - Data structures for describing changes to other data structures.  https://hackage.haskell.org/package/patch-0.0.3.2 (abrar)
05:23:31 <lortabac> Cheery: which means you'll probably need AllowAmbiguousTypes and TypeApplications
05:23:55 <lortabac> as I said, it requires a lot of boilerplate
05:26:22 <Cheery> this looks fun.
05:30:58 <Cheery> Right now it says that it can't deduce (x::Aux) from the method declaration
05:33:20 <Cheery> adding a "proxy" helped. :)
05:35:16 <lortabac> yes, if you use proxies you don't need AllowAmbiguousTypes and TypeApplications
05:41:09 <jollygood2> I need line graph on a web page, ideally the kind that lets you see arbitrary points by hovering a mouse over it. any recommendations?
05:41:41 <Cheery> that kind of thing, I still didn't get it through, but I continue later: https://bpa.st/TYMQ
05:42:23 <Cheery> lortabac: thanks for help, there's bit more tools to try. I think I understand the problem in the "simple" way to do this though.
05:43:13 <Cheery> when I try to create the instance (F a, F b) => F (a,b), it's unable to figure out whether to use this instance on ((),b) or not.
05:44:16 <ski> they overlap
05:44:38 <Cheery> the closed type family does not "figure" it out, but it waits until Trim (a,b) resolves either a or b
05:45:12 <ski> try using only the former, but see if you can check if `Trim a' or `Trim b' is `()', and if so, then `Trim (a,b)' should be the other one
05:45:49 <ski> hm
05:47:43 <lortabac> Cheery: if you use my workaround, the instances are only selected on Aux, where they never overlap
05:48:00 <lortabac> there are no instances (a, b) etc.
05:48:22 <lortabac> in fact that's the whole point of this trick
06:09:22 * hackage bytebuild 0.3.7.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/bytebuild-0.3.7.0 (andrewthad)
06:30:53 * hackage reflex-vty 0.1.4.1 - Reflex FRP host and widgets for VTY applications  https://hackage.haskell.org/package/reflex-vty-0.1.4.1 (abrar)
06:32:02 <merijn> oooh, that sounds cool
06:42:22 * hackage miv 0.4.4 - Vim plugin manager written in Haskell  https://hackage.haskell.org/package/miv-0.4.4 (itchyny)
07:06:19 <isBEKaml> Hello, I was looking for ghcup and was a little surprised to _not_ see it listed among the Downloads on haskell.org
07:06:27 <isBEKaml> Is that not officially supported anymore? 
07:06:44 <isBEKaml> https://www.haskell.org/downloads/
07:07:34 <merijn> Define officially supported
07:07:57 <merijn> I'm not sure it ever was on there?
07:08:17 <merijn> https://www.haskell.org/ghcup/
07:08:23 <isBEKaml> merijn: if it's listed on https://www.haskell.org/ghcup/ under the domain haskell.org - it is :-)
07:08:26 <merijn> Probably someone should updat ethe downloads page
07:10:02 <aldessa> Hi, when programming FPGAs in Clash what would be the best way to formally verify properties of the thing you compile?
07:10:24 <merijn> aldessa: Whiskey and crying are my favourite methods :>
07:10:56 <aldessa> merijn, lockdown is hitting hard I see
07:11:03 <isBEKaml> also, ghcup pollutes my home dir. It doesn't respect XDG_HOME_DIR :-(
07:11:14 <merijn> aldessa: You might wanna try #clash-lang
07:11:25 <aldessa> thanks merijn
07:11:25 <int-e> merijn: 90% proof spirit?
07:11:47 <merijn> isBEKaml: If you are super pedantic about how you organise your environment you can just grab the GHC bin dists and cabal yourself and leave them wherever you want
07:12:08 <merijn> isBEKaml: https://www.haskell.org/ghc/download_ghc_8_10_2.html#binaries
07:12:17 <aldessa> ghcup auto installs haskell language server which is pretty great
07:13:17 <merijn> isBEKaml: Both GHC and cabal are "good citizens" in terms of multiple versions playing nicely together
07:14:00 <merijn> isBEKaml: Personally I just manually install multiple GHC bin dists in $HOME myself, because I'm a grumpy curmudgeon who dislikes tools dictating my environment :p
07:15:05 <isBEKaml> merijn: I install compiled tools into ~/bin myself and don't want to go searching for tools where I don't look in
07:16:14 <aldessa> why not .bin?
07:17:21 <isBEKaml> just my preference
07:19:43 <aldessa> that's fair
07:24:04 <merijn> You'd at least need a corresponding /lib directory too
07:24:11 <merijn> GHC isn't just an exectuable
07:24:51 <isBEKaml> I dump everything into a separate pkgs directory and symlink the bins into ~/bin
07:25:12 <isBEKaml> so pkgs/ghc/bin/ghc gets symlinked into ~/bin/ghc
07:25:27 <isBEKaml> no more fudging with paths
07:37:13 <merijn> Anyone know if the hackage matrix builder has an RSS feed somewhere? I suspect not?
07:40:52 * hackage reflex 0.8.0.0 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.8.0.0 (abrar)
07:43:55 <oioi6912730> hi! small qn about mail libraries
07:44:27 <oioi6912730> would anybody know of any libs to fetch with IMAP and/or interact with maildir folders
07:45:08 <oioi6912730> I haven't been able to find anything still maintained for IMAP from google/hackage
07:53:50 <absence> i have some code that compiles until i enable TypeFamilies. anyone knows what's wrong, and what i have to change to make it work? https://repl.it/repls/SickConstantComputergraphics
07:54:33 <merijn> Well, what's the error?
07:55:56 <merijn> Unrelatedly: also note that you can never do anything useful with SomeRecord's contents
07:56:24 <absence> merijn: click the run button
07:56:25 <dolio> It's because TypeFamilies turns on MonoLocalBinds, I think.
07:56:53 <dolio> So 'test' must be monomorphic, but nothing determines its type.
07:56:56 <absence> merijn: also this code is just some garbage i threw together to reproduce the error :)
07:57:09 <absence> dolio: oh!
07:57:45 <absence> dolio: i think i've been bitten by that before...
07:58:56 <dolio> That's not exactly what the error says, but if I put NoMonoLocalBinds in the language pragma, it works.
07:59:55 <absence> dolio: is there a good reason why it enables MonoLocalBinds? i.e. should i just disable it, or change the code to work when it's enabled?
08:00:49 <dolio> I think it makes inference more feasible for type family related stuff.
08:07:19 <absence> dolio: i see, thanks!
08:17:22 * hackage reflex-fsnotify 0.2.1.2 - Reflex FRP interface for watching files  https://hackage.haskell.org/package/reflex-fsnotify-0.2.1.2 (abrar)
08:24:53 * hackage reflex-process 0.3.1.0 - Reflex FRP interface for running system processes  https://hackage.haskell.org/package/reflex-process-0.3.1.0 (abrar)
08:36:52 * hackage persistent-test 2.0.3.5 - Tests for Persistent  https://hackage.haskell.org/package/persistent-test-2.0.3.5 (parsonsmatt)
08:37:52 * hackage reflex-dom-core 0.6.1.0 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-core-0.6.1.0 (abrar)
08:40:53 * hackage reflex-ghci 0.1.5.1 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.5.1 (abrar)
08:43:52 * hackage reflex-dom 0.6.1.0 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.6.1.0 (abrar)
08:44:55 <maerwald> merijn: next time someone asks about xdg: https://gitlab.haskell.org/haskell/ghcup-hs#xdg-support :p
09:20:45 <gattytto> hello :D  
09:25:03 <gattytto> I'm having issues trying to build the test suite for github/haskell-servant/example-servant-minimal because of some errors in the test/AppSpec.hs file. https://gist.github.com/gattytto/a43c8ca49936c86a6f9ed68380118bf3
09:25:22 <gattytto> can I get some help? I have already changed ServantError for ClientError as noted in the servant lib docs 
09:34:00 <glguy> gattytto: https://hackage.haskell.org/package/servant-client-core-0.18.1/docs/Servant-Client-Core-ClientError.html#t:ClientError says FailureResponses has two fields; you have only one in your error message snippet
09:34:11 <glguy> FailureResponse (RequestF () (BaseUrl, ByteString)) Response
09:35:33 <gattytto> I'm trying to build the test suite that comes with the example project so I get those errors, does this mean the lib changed? 
09:36:45 <gattytto> this is the file https://gist.github.com/gattytto/5ae5f997d107d051a6a0e9875e654c82
09:38:14 <glguy> gattytto: If it doesn't build then yeah the API changed and no one ran the example test suite since then
09:42:48 <monochrom> Nice maerwald
09:50:41 <gattytto> glguy: could you hint me on how to solve this? I'm very new to haskell so this is quite (very) advanced for me
09:51:12 <glguy> afaik, servant is a pretty rough place to start if you're new to Haskell
09:51:35 <maerwald> use scotty 
09:52:25 <gattytto> I'm trying to fix the test suite to include this project as a "demo" project for the inclusion of haskell to the Eclipse CHE web IDE
09:54:14 <gattytto> for my personal learning curve I'm still reading books about haskell, not yet even tried writing any code outside of ghci prompt
09:56:02 <monochrom> IMO servant is not for very new to Haskell.
09:56:37 <monochrom> Hell, most of the web programming libraries, therefore web programming itself altogether, is not for very new to Haskell.
09:57:59 <gattytto> yeah, I'm not trying to learn from it (I mean yeah but with no success), but I'm trying to add the project as a general over-look of haskell because not only newcommers to haskell will want to use this eclipse CHE ide so I thought it would be un-sufficient to add a hello world example to the ide 
09:58:33 <gattytto> this is the demo project you get to when you click on a "example stack" for haskell in the IDE home screen 
09:59:44 <geekosaur> you might do better to ask the servant folks to update their demo, telling them why
09:59:48 <hekkaidekapus> gattytto: Could you provide a link to that IDE you’re talking about?
10:00:24 <gattytto> I have made an issue in their repo but it's been idling for more than a week so I thought to come here and maybe advanced users find it easier to fix the test suit 
10:00:32 <gattytto> hekkaidekapus yes che.openshift.io 
10:01:10 <gattytto> you can make a free acount and get 7gb of ram and 2gb of disk to create projects, I'll share here now a devfile spec to get to the current workspace I'm working with 
10:01:11 <hekkaidekapus> Thanks. And another one for the issue report?
10:01:20 <gattytto> https://github.com/haskell-servant/example-servant-minimal/issues/11
10:01:21 <monochrom> IMO a short console application is sufficient.
10:01:55 <monochrom> The purpose is to show how Haskell fits into Eclispe, not show off Haskell.
10:02:56 <monochrom> If it needs to also show how to do dependencies on libraries on hackage, consider simply pulling in random and printing a few random numbers.
10:03:02 <gattytto> actually my attempt is to provide a demo that uses all of the available functions that I included in the commit, like the debugging extension, code hints, peek definition and so on
10:05:08 <monochrom> Printing a few random numbers can do that, too.
10:05:31 <gattytto> hekkaidekapus if you create an account in che.openshift.io then you can go to this link che.openshift.io/f?url=https://raw.githubusercontent.com/gattytto/example-servant-minimal/8.8.4/devfile.yaml you get to the project
10:05:34 <monochrom> Or do random permutation of a list if you need it longer and harder to debug.
10:06:03 <monochrom> (and recursive)
10:06:28 <hekkaidekapus> gattytto: You should follow the advice glguy and monochrom gave you. By the way, that CHE URL redirects to a login page and I gave up at that point. Also, there is a Haskell IDE community wherein people cooridnate their work at <https://github.com/haskell/haskell-language-server>.
10:07:20 <monochrom> How long does it take to download servant (and its transitive dependency closure) and compile them all?
10:07:22 <gattytto> yes hekkaidekaups it requires to have an account which is free 
10:07:31 <monochrom> I don't imagine it is any less than 30 seconds.
10:07:36 <gattytto> well.. a couple minutes in openshift
10:07:53 <gattytto> because the extensions work with docker image sidecars
10:08:05 <monochrom> If I were to open up Eclipse for the first time and watch its Haskell demo, I am not going to wait 30 seconds for merely compiling.
10:08:09 <gattytto> and I have built ghcide from source in the sidecar build process so it has the sources, it just builds them
10:08:31 <hekkaidekapus> gattytto: Yeah, and I’m not going to create that account. Are you a CHE developer?
10:09:24 <gattytto> che is a project of the eclipse fundation, it's an open sourced project. I'm only a committer memeber since recently. Openshift is a free (and offers paid service of course) tier provided by redhat 
10:11:00 <gattytto> the sidecar includes both haskell-language-server and ghcide built from source, and the environment is included in 3 versions: 8.8.4, 8.10.1 and 8.10.2 and all the components are build from source for their respective version
10:11:53 <hekkaidekapus> gattytto: That sounds fantastic. So, why don’t you change the demo to something simpler?
10:13:52 <hekkaidekapus> The demo should maybe just focus on explaining the setup. Servant is just another Haskell project. Once folks have a working setup, they will figure out how to use it with any projects of their liking.
10:13:53 <gattytto>  I wanted to include a more realistic demo than just hello world because I think haskell deserves it after I saw all the work made in the extensions for the linting and debugging
10:14:18 <gattytto> and having a web api demo using servant worked except for the test suite
10:14:34 <monochrom> So suppress the test suite.
10:15:08 <monochrom> Also I am one of those conservative old-geezers who disagree with realistic=web
10:15:18 <gattytto> I thought it could damage the purpose of the demo author, since I'm not the author of that code I thought it would be disrespectful to just cut off a part of it
10:17:00 <monochrom> It's called "workaround". It means a temporary limitation you put in now but will remove when you figure out how.
10:17:45 <monochrom> An ironically in this the context of "realistic" and "debugging".
10:18:25 <gattytto> that too I wanted to include debug configurations for the test suite too 
10:23:52 <hekkaidekapus> Another thing slightly unrelated: <https://github.com/haskell-servant/example-servant-minimal> does not commit the .cabal file. I’m aware of stack2cabal (kudos maerwald) and hpack, but a missing .cabal is already a blocker for further sleuthing.
10:25:24 <monochrom> Oh, that's a crime. :)
10:25:29 <gattytto> yes I noticed, but doing "stack build" creates the .cabal by itself
10:25:56 <koz_> gattytto: Yeah, because stack magics in hpack as well.
10:26:00 <gattytto> I have added the build tasks for those packages in the sidecar Dockerfile so it's invisible to the users
10:26:01 <texasmynsted> How do I import the styles from the pandoc module --> https://hackage.haskell.org/package/pandoc-2.11.1/docs/Text-Pandoc-Highlighting.html#t:Style
10:26:19 <koz_> And yes, every time you don't include .cabal files, god kills a kitten, and Snoyman vociferously disagrees with you.
10:26:27 <texasmynsted> oh wait
10:27:41 <gattytto> I hope to get some PR that fixes the test suite soon for this project, it's the only missing piece to add the demo stack to the IDE
10:27:51 <texasmynsted> nm
10:27:57 * texasmynsted facepalm
10:28:08 <texasmynsted> one of those days
10:28:23 <gattytto> meanwhile I'll keep reading my haskell books for dummies so I get some idea of what's going wrong
10:28:38 <geekosaur> it'll take more than that
10:28:47 <hekkaidekapus> gattytto: Good luck!
10:28:52 <geekosaur> but both errors are the same problem from two different directions
10:29:34 <gattytto> geekosaur thank you for the hint
10:29:57 <geekosaur> one thing has too many parameters, the other too few
10:50:15 <comerijn> hekkaidekapus: At least nowadays we can point out that even Snoyman doesn't support "not committing .cabal files" anymore ;)
10:51:17 <hekkaidekapus> koz_: heh… That’s what koz_ was talking about. And god bless kittens :)
10:51:29 <koz_> hekkaidekapus: Yep, this is me doing my daily jibe. :P
11:24:23 * hackage type-of-html 1.6.0.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.6.0.0 (knupfer)
12:03:34 <Cheery> ok. My approach was borked.
12:08:23 * hackage ukrainian-phonetics-basic 0.1.11.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.1.11.0 (OleksandrZhabenko)
12:24:23 * hackage phonetic-languages-properties 0.1.2.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-properties-0.1.2.0 (OleksandrZhabenko)
12:24:57 <dminuoso> merijn: cant we just get rid of hpack once and for all? :<
12:27:07 <merijn> I wish
12:27:55 <Cheery> if it can't decide (Foo k0) yet I intended it to be Foo (F x)
12:28:07 <Cheery> is there a way I can give it that thing?
12:28:21 <Cheery> Foo being a constraint there
12:28:56 <Cheery> say.. foo :: (Foo k x) => x
12:45:52 * hackage phonetic-languages-examples 0.1.2.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.1.2.0 (OleksandrZhabenko)
12:49:11 <nut> Do people need to perform charset conversion in Haskell? Something similar to g_convert from glib?
12:52:26 <geekosaur> generally we go from or to unicode, so we use the text-icu ibrary
12:52:55 <Cheery> oh no :D I did it and it's horrible
12:57:53 * hackage libarchive 3.0.1.1 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-3.0.1.1 (vmchale)
13:03:07 <nut> When I run ghci, why do I need to add -package somepackage in order to be able to load it?
13:03:27 <nut> I just installed text-icu with cabal install text-icu
13:03:57 <nut> and if I run ghci, and import Data.Text.ICU, it says hidden package
13:04:42 <nut> Is it because when I cabal install, i didn't use --lib flag?
13:04:44 <geekosaur> with new-style install it's stored in an environment, not just generally available, because that makes messes when multiple versions of packages are around
13:05:00 <nut> ok
13:05:05 <geekosaur> --lib would make it generally available and then get you in trouble if you install a different version with --lib later
13:05:37 <nut> Ok so generally speaking, --lib is not recommended
13:05:52 <geekosaur> in general you want to work in terms of a specific package or environment so cabal can keep straight what versions of what libraries should be visible
13:05:53 <nut> cabal keeps warning me about it
13:06:50 <solonarv> if you want a ghci with a specific package (or set thereof) you can run 'cabal repl -b text-icu'
13:07:26 <nut> solonarv: even if i'm not in any cabal package?
13:07:44 <nut> solonarv: I often use ghci outside of any package
13:08:25 <nut> Is there any sanity checks for cabal to see if i've messed up the environment?
13:08:59 <Uniaika> nut: yep it seems to run well outside of a cabal project
13:09:49 <geekosaur> cabal itself will sanity check if you use cabal repl instead of ghci directly. there's little that can be done if you go around cabal though
13:13:06 <geekosaur> ghc will grab anything it thinks it can and possibly confuse itself in the process, which is why we have tools like cabal and stack that each try to keep ghc in check in different ways
13:26:50 <nut> i see. so better use cabal repl
13:58:25 <cohn> how do you destructure a list containing a type? 
13:59:02 <cohn> so e.g. a list like: [(Foo Int String), (Foo Int String)]
13:59:29 <cohn> where foo is defined like: data Foo = Foo Int String
14:07:53 <ski> cohn : match on the data constructor
14:09:11 <ski> cohn : is the list of known length ?
14:09:19 <cohn> no
14:09:34 <ski> so, you're doing recursion, walking the list ?
14:11:06 <cohn> yes
14:11:22 <cohn> I solved it using 2 functions but I have to imagine it could be simplified
14:11:31 <ski> so, if you had something like `data Foo = MkFoo Int String', then you'd probably go something like
14:11:43 <ski>   processFoos :: [Foo] -> ...
14:12:01 <ski>   processFoos [              ] = ...
14:12:22 <ski>   processFoos (MkFoo n s:foos) = ..n..s..(processFoos foos)..
14:12:40 <ski> (`Foo' here is the type (constructor), `MkFoo' is the data constructor)
14:13:32 <ski> but yea, depending on what you're doing to the `Foo's in the list, there may be a simpler ior clearer way to do it
14:13:56 <cohn> I tried something similar to that pattern matching but got errors.
14:14:03 <ski> type errors ?
14:14:04 <cohn> I'll keep trying. Thanks ski!
14:14:22 <ski> any code you'd like to show ?
14:14:23 <cohn> actually no, it was a parsing error. 
14:14:42 <cohn> I've already overwritten it. : (
14:14:45 <ski> okay
14:14:47 <cohn> I can try to recreate it
14:15:41 <ski> if you want to, i could take a look at your two functions. and the other version too, if you feel like trying to revive it
14:18:23 <cohn> ski: oh!!! I see exactly what you did above. The pattern (MkFoo n s:foos) matches the head of the list, then assigns the tail to "foos"
14:18:30 <cohn> man, I didn't know you could do that
14:20:04 <cohn> ok, that worked perfectly. Thanks so much!
14:21:05 <cohn> that makes me question a lot of other code I wrote that I could probably simplify...  lol
14:22:44 <ski> cohn : not "assigns", but "binds". but, yes. you can nest patterns inside each other
14:23:32 <cohn> wow, that's *really* powerful.
14:23:40 <cohn> not sure why I never saw that before
14:23:40 <ski> (assignment usually implies overwriting the current value in a location with some (possibly) different value. there is no overwriting here)
14:23:45 * cohn shrugs
14:24:05 <ski> if you had had `data Foo = SimpleFoo String | ComplexFoo Int String', then you could have done
14:24:14 <ski>   processFoos :: [Foo] -> ...
14:24:34 <ski>   processFoos [                   ] = ...
14:25:14 <ski>   processFoos (SimpleFoo    s:foos) = ..s..(processFoos foos)..
14:25:25 <ski>   processFoos (ComplexFoo n s:foos) = ..n..s..(processFoos foos)..
14:25:50 <ski> so, two non-empty list cases, depending on whether the current/first element is simple or complex
14:26:10 <cohn> ya, that makes sense. really cool stuff
14:26:59 <ski> this is the kind of thing that makes pattern-matching a breeze to work with, as contrasted with a gnarly maze of nested `if'-`then'-`else's (and possibly also `let'-`in's)
14:27:09 <cohn> exactly!
14:27:20 <cohn> ditto for the `case` statement
14:27:33 <ski> yea, but you can also nest patterns with `case'
14:27:46 <ski>   processFoos foos0 = case foos0 of
14:27:54 <ski>     [                   ] -> ...
14:28:07 <ski>     SimpleFoo    s : foos -> ..s..(processFoos foos)..
14:28:16 <ski>     ComplexFoo n s : foos -> ..n..s..(processFoos foos)..
14:28:47 <cohn> that does come in handy
14:29:03 <ski> (and that `case' could be nested inside some other expression, if you wanted to. and you could have some other expression (other scrutinee) between the `case' and the `of', than just the direct formal parameter `foos0')
14:30:22 <cohn> oh nice! that's good to know
14:30:49 <cohn> fwiw, I'm coming from a Python world so having to get used to types plus FP patterns like this.
14:31:02 <cohn> sorry if I sometimes ask dumb/obvious questions.
14:31:04 <cohn> :D
14:31:35 <ski> algebraic data types (also called sum types, variant types, discriminated/disjoint union types, variant record types), with pattern-matching, are really great
14:31:46 <ski> no worry :)
14:32:59 <ski> it's too bad that only few languages supports them. imho, you really need both them, and record types (aka product types, object types, "class types"). sometimes one is more appropriate, sometimes the other. it depends on what you're doing
14:33:22 <ski> (in a formal sense, they are "duals" of each other. "opposites" in a sense)
14:33:25 <cohn> ya
14:33:40 <cohn> duals... man that brings back memories of linear programming
14:33:56 <cohn> or maybe nightmares...  ; )
14:34:02 <ski> (but i've heard rumors that more languages will be gaining them. e.g. C#, and hopefully more)
14:35:00 <ski> heh, okay :)
14:37:00 <ski> (unfortunately, it's common in OO (which is all about record/product/object types), to claim that `switch' is bad. (pattern-matching can be viewed as `switch' on steroids.) it's not bad, it's just that sometimes product types are more appropriate. and sometimes, sum types are more appropriate)
14:38:09 <cohn> agreed. 
14:39:26 <ski> (.. and then, when you really need sum types in OO languages, you're often left with only clumsy ways of simulating them. like either using `switch' with downcasts, or `if'-`else's with downcasts. or (more blessed), the VisitorPattern (which is basically a Continuation-Passing / Church Style encoding of sum types))
14:40:34 <ski> let's say you want to have some type. and you want to be able to construct values of this type, of some number of different alternative forms. and you also want to be able to query values of this type for "properties"
14:41:30 <ski> if the alternatives that you want to support are relatively fixed, but the properties are likely to be modified, or get extended with new ones, then you probably want sum types
14:42:07 <ski> if the properties are relatively fixed, but the alternatives you want to support are likely to be modified, or extended, then you probably want product types
14:42:53 <ski> for each alternative, you need to implement the property (the "method") on that alternative. so, you can draw a table, where the rows are different alternatives, and the columns are different properties
14:43:37 <ski> and each cell contains the implementation of the property of that column, for the alternative that is the row
14:44:53 <ski> then, if you slice this table into rows, you're grouping all the property implementations, for a single alternative, together. this is the product type road. such an alternative is called a "class", in the OO world, and the properties are called "methods" (or "member functions" or perhaps some other term as well)
14:46:20 <ski> so, to add another alternative, you just define a new class, defining all the methods/properties for it. but, to add a new property, you need to add a method to all the existing alternatives/classes (all the classes/alternatives implement the same interface. or maybe they inherit from a common base class, which is likely often abstract)
14:47:02 <ski> so, adding a new property is harder, more error-prone, since you need to modify existing code, and possibly take into account interactions with that code
14:47:50 <ski> on the other hand .. if you instead slice the table into separate columns, then each column is the implementation of a single property, for all the different alternatives. this is called a "pattern-matching function"
14:47:54 <cohn> gonna take me a minute to digest all of that... :D
14:48:37 <ski> now, adding a new property is simple, you just add a new pattern-matching function, handling all the data constructors (the alternatives) in separate defining equations of the function
14:49:19 <ski> however, adding (or modifying) a new alternative is more involved, since now you need to go and change all existing pattern-matching functions that takes an input of data type
14:49:46 <ski> so .. it is a trade-off. neither is fundamentally better than the other. it depends on what you expect
14:50:14 <ski> also, then there's issues like recursion in your type that complicates this picture. but the above is the basic summary of the difference
14:51:55 <ski> cohn : as an example : define a type `Shape', meant to describe a simple geometric shape. and say you want to support rectangles (with width,height) and circles (with radius) as possible alternatives. as properties, you want to support circumference and area
14:52:17 <cohn> right
14:53:19 <ski> exercise for you : define `Shape' as a product/record type, with circumference and area as fields/methods. and define functions ("constructors"/"classes" in OO terminology) `rectangle' and `circle', taking width & height, respectively radius, and giving you back a `Shape'
14:53:55 <cohn> ok
14:54:55 <ski> then, define `Shape' again, but this time as a sum/variant type (algebraic data type), having `Rectangle' (with width & height arguments/components) and `Circle' (with radius component) as alternatives (data constructors), and then define the properties `circumference' and `area' as pattern-matching functions on `Shape'
14:55:15 <cohn> afk for a sec.
14:59:02 <ski> the observe how the four implementations of circumference/area for rectangle/circle are distributed differently in these two different implementations. then you could try maybe adding a new alternative, maybe triangle (say you give the three side lengths. use Heron's formula for area), as well as adding a new property. hm, maybe the radius of the largest circle you could inscribe inside it (or of the 
14:59:08 <ski> smallest circle you could circumscribe around it). you'd have to think a little about how to do it for the triangle, i guess
15:00:37 <ski> anyway, this is just a suggestion. you don't have to do it, if it sounds too involved. perhaps you can think of some other interesting alternative or property. one cool property would be a method to actually render the shape on some graphical canvas or something. but then you'd have to dive into some graphical library
15:05:39 <ski> btw, the trade-off i expressed, between product/record types, and sum/variant types, is quite similar to the notion of shallow vs. deep embedding of an embedded domain-specific language (EDSL)
15:05:46 <ski> @wiki Embedded domain specific language
15:05:46 <lambdabot> https://wiki.haskell.org/Embedded_domain_specific_language
15:10:43 <ski> (however, often the "shallow" embedding is just expressed as implementing the type of your EDSL expressions as the "main interpretation". for a parser, this might be a function of type `String -> Maybe (a,String)' (where `a' is the parse result of the parser). however, sometimes one also want to compute other "properties" or "alternative interpretations", which would then be other 
15:10:49 <ski> fields/methods/slots/components, alongside the main one, in a product/record type. e.g., for a parser, you might want (for optimization purposes) a (`nullable') `Bool' to express whether a parser can succeed, while consuming no input, and a (`first') `[Char]', to express what the initial character could possibly be, if the parser is to have any chance of succeeding)
15:14:52 * hackage sexp-grammar 2.3.0 - Invertible grammar combinators for S-expressions  https://hackage.haskell.org/package/sexp-grammar-2.3.0 (EugeneSmolanka)
15:16:52 * hackage persistent-documentation 0.1.0.2 - Documentation DSL for persistent entities  https://hackage.haskell.org/package/persistent-documentation-0.1.0.2 (parsonsmatt)
15:33:13 <cohn> ski: ok, product type implementation:  https://dpaste.org/M7vG
15:33:36 <cohn> working on the sum type.
15:34:48 <ski> > pi
15:34:50 <lambdabot>  3.141592653589793
15:35:29 <ski> (seems to me the rectangular circumference, and the circular area, isn't quite right)
15:37:40 <cohn> yep, easy fix
15:38:26 <ski> btw, note that `rectangle' is corresponding to an OO class (it contains the implementations of the methods `circumference' and `area'), and also corresponds to its class constructor (it takes the parameters `width',`height', which acts like (private) instance variables)
15:38:44 <ski> (and similarly for `circle' with its `radius' parameter)
15:41:31 <ski> (and if you think you want mutable state in your objects, it's quite easy to have the "class constructor" (the function producing your object) to allocate some mutable cell(s), with `IO', and have some methods (with `IO Something' as return type) read from and write into it -- at least once you're a bit familiar with how `IO' works, and can figure out how to use `IORef' (or `IOArray', if you prefer))
15:43:30 <ski> i think it's good to explicitly point out how one can "do OO", at least to some extent, in Haskell. of course, if you want implementation inheritance, possibly even with open recursion, then it'll be a little bit more involved (but quite possible) to get that. but simple OO coding, like this, is not that hard
15:44:05 <cohn> fixed:  https://dpaste.org/cSsn
15:44:28 <ski> that looks fine :)
15:44:55 <cohn> yea, I've briefly messed with UArray and STUArray
15:44:56 <ski> (fwiw, i think most of your round brackets are redundant)
15:45:03 * ski nods
15:45:18 <cohn> probably are but OCD is what it is.  heh
15:46:02 <ski> (the only ones that aren't are the ones around `width+height')
15:46:07 <cohn> ya
15:46:19 <ski> any luck on the sum type version ?
15:46:32 <cohn> working on it now.
15:46:39 <ski> take your time
15:51:00 <ski> (btw, perhaps it's obvious, but if you wanted a method to take any additional parameters, you'd simply stuff a function into the corresponding field in the record)
15:54:40 <cohn> ok, sum type version:  https://dpaste.org/5Fvz
15:54:53 <cohn> brb.
15:55:24 <cohn> I added the `2` suffix since both types are defined in the same file.
15:56:42 <ski> yea, i figured
15:56:49 <ski> looks great ! :)
15:58:01 <ski> now note how the "table" of the four alternative-property implementations ({circumference,area} * {circle,rectangle}) are distributed differently, in these two implementations
15:59:13 <ski> with the "alternative rows" `rectangle' and `circle' in the product (OO) version, and the "property columns" `circumference' and `area' in the sum ("FP") version
15:59:39 <ski> (and if you feel like it, you could try adding some new alternative, ior some new property)
16:00:17 <ski> but, anyway, hopefully this small exercise gives you at least a somewhat better feel and understanding for the difference, the trade-off, i was mentioning above
16:02:34 <ski> (btw, note that nested pattern-matching for sum types, corresponds, dually, to constructing a nested record (constructing an object (implementing some interface), where some method also constructs some object (implementing some interface)))
16:03:14 <ski> oh .. and it would also be nice if one could use an alternative syntax for records, something like
16:03:56 <ski>   codata Shape = Circumference :: Double & Area :: Double deriving Show
16:03:59 <ski>   
16:04:08 <ski>   rectangle :: Double -> Double -> Shape
16:04:33 <ski>   #Circumference (rectangle w h) = 2 * (w + h)
16:04:57 <ski>   #Area          (rectangle w h) =      w * h
16:05:47 <ski> (one might call this "message-dispatching" syntax (compare with pattern-matching syntax). the language Agda supports something like this, called "copatterns" there)
16:06:35 <ski> (`rectangle' is defined, above, in terms of what each field/method of a call to `rectangle' is to be)
16:17:59 <cohn> b
16:18:42 <cohn> yes, it's very helpful. thank you!
16:49:23 * hackage git-brunch 1.4.4.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.4.4.0 (andys8)
16:51:41 <ski> cohn : yw :)
17:59:27 <bqv> ski: do you know polysemy?
18:00:32 <bqv> Actually, belay that
18:00:44 <bqv> I should just avoid IO, then this is easy
18:00:57 <bqv> DSL time
21:48:22 * hackage gjk2d 0.1.0.3 -   https://hackage.haskell.org/package/gjk2d-0.1.0.3 (suzumiya)
23:33:52 * hackage githud 3.2.2 - Heads up, and you see your GIT context  https://hackage.haskell.org/package/githud-3.2.2 (gbataille)
23:34:52 * hackage arch-hs 0.4.0.0 - Distribute hackage packages to archlinux  https://hackage.haskell.org/package/arch-hs-0.4.0.0 (berberman)
