00:34:45 <bqv> Do any of you have tricks to make cloud-like dev a ...better experience? Is it just suffering from horizon to horizon, or is there hope somewhere?
00:35:28 <dminuoso> From experience, and Im saying this as a company that is building out their own data center, cloud rarely offers reasonable advantages.
00:36:51 <dminuoso> You have unpredictable costs, and a cost scaling that favors the cloud provider not you (cloud is only cheaper if you need to scale *down* not *up)
00:37:01 <dminuoso> You have semantics that dont fit into traditional tooling 
00:38:16 <dminuoso> But really, the cost part is amazing. You first get tricked into thinking "this is cheaper because the cost scales with usage", just to realize this works in both directions later on...
00:38:31 <dminuoso> (And it turns out, bare metal is just cheaper if you need to scale up)
00:39:13 <bqv> Excellent
00:39:56 <bqv> Saved so I can parrot that to my coworkers someday…
00:40:38 <dminuoso> Another thing is, most problems don't have a high variability in terms of performance needs
00:41:08 <dminuoso> You usually have a narrow corridor in which you fluctuate. For most problems you dont need to randomly scale between "10 users today, 20 million tomorrow
00:42:07 <dminuoso> Also, cloud providers heavily force you into a vendor lockin
00:43:07 <dminuoso> You want their elastic computing resources? You better also use their elastic storage solution. And their elastic backup solutions. Oh and any analystics only works with their tools now
00:43:18 <dminuoso> You want to build and deploy? You're forced onto their tooling too
00:44:02 <dminuoso> And that doesn't even begin to discuss the data privacy needs.
00:44:53 * hackage lentil 1.4.1.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.4.1.0 (fffaaa)
00:45:18 <dminuoso> Fun fact, most of Amazons profits actually comes from AWS, not Marketplace.
00:45:24 <dminuoso> They are *that* darn profitable.
00:46:53 <merijn> dminuoso: Well, it also depends on how much fancy stuff you buy into
00:47:25 <merijn> My brother just got hired at a new place after doing AWS for a long time and his first reaction was "wow...you guys are wasting a lot of money on AWS..."
00:47:44 <merijn> People just don't wanna think about performance engineering
00:48:01 <dminuoso> merijn: Sure, AWS can be done cheaply with great care. But amazon counts on you not doing that.
00:48:15 <dminuoso> And if you're lazy, bare metal is just cheaper.
00:48:20 <merijn> I'm gonna go out and estimate that a solid 80-90% of all workloads can *easily* be handled by a single (beefy) machine
00:48:25 <dminuoso> Indeed.
00:48:32 <dminuoso> That is the silver bullet.
00:48:41 <merijn> "ooh, no, we've got big data"
00:48:56 <merijn> Fucking BS...there's like maybe 3 companies that have big data
00:49:11 <dminuoso> merijn: Much of the "cloud or kubernetes" problem space addresses problems virtually noone has.
00:49:22 <merijn> The rest just have incompetent software engineers and/or are too cheap to bother
00:49:23 <dminuoso> Like, kubernetes is an incredibly amazing thing
00:49:35 <dminuoso> If your problem is "how do I manage hundreds of services deployed to tens of thousands of nodes"
00:49:42 <dminuoso> Problems everybody has in their day jobs, right?
00:49:43 <merijn> dminuoso: oh, lemme look up a quote I saw recently
00:49:44 <dminuoso> ;)
00:50:18 <merijn> dminuoso: https://twitter.com/rothgar/status/1317524239218397185
00:50:42 <dminuoso> Haha that's a good one
00:51:22 <dminuoso> Its the same with "high availability"
00:51:24 <merijn> All the latest hype "ecosystems" are just pointless for most people
00:51:38 <dminuoso> A well maintained single node has better high availability than piss-poor "Im gonna slap HAProxy ontop of this"
00:51:52 <merijn> dminuoso: It's like people adopting Hadoop
00:52:17 <merijn> Spoiler: 80% of hadoop solutions I've seen/encountered are *slower* than a single node solution
00:52:53 <dminuoso> (not to mention that high availability is a too broad term, what does that even mean? automatic failover? do we need active/active? active/passive? Or maybe we have differences wrt to writing/reading? Or maybe we want load sharing instead?
00:53:18 <kuribas> merijn: brilliant
00:53:20 <dminuoso> Trying to get the automatic failover right tends to introduce a lot of moving parts
00:53:41 <dminuoso> like, if you add haproxy, you again have a single point of failure, and it must detect non-operatoinality
00:54:01 <kuribas> merijn: wasn't there a company that rewrote all their scala code using hadoop in pure haskell running on a single machine, and found that everything was faster?
00:54:33 <dminuoso> merijn: here we strive for a particular model of load sharing and automatic failover
00:55:13 <merijn> dminuoso: Good failover requires robust software, but nobody has that :p
00:55:29 <merijn> kuribas: I wouldn't be surprised
00:55:31 <dminuoso> if service A needs to talk to service B, we just replicate service B a few times. A then maintains a pool of possible B targets, and implements load sharing by randomizing which B target to talk to
00:55:43 <kuribas> merijn: ah, it was this one: https://tech.channable.com/posts/2019-10-04-why-we-decided-to-go-for-the-big-rewrite.html
00:55:44 <dminuoso> If B emits failures, we mark them as temporarily dead and remove them from the pool for a while
00:55:59 <dminuoso> so the high availability comes from *engineering*
00:56:04 <kuribas> merijn: ah, spark, not hadoop
00:56:06 <dminuoso> not "add random software ontop of it"
00:56:20 <merijn> During my internship we were asked to benchmark Apache Spark (runs on Hadoop) and GraphX (runs on Spark) and found *negative* scaling
00:56:32 <merijn> i.e. it got slower the more nodes you added to the cluster
00:56:47 <dminuoso> merijn: The usual cost of implementing the above, about 50 lines of haskell. Reliable failover with some good load sharing!
00:56:52 <merijn> kuribas: Spark runs on hadoop :p
00:57:05 <dminuoso> Only requirements: stateless services!
00:59:14 <kuribas> I wonder how many problems cannot be solved on a single instance.
00:59:20 <kuribas> or at least subdivided easily
01:00:47 <merijn> kuribas: One of my favourite graph processing papers was just a bunch of guys going: So we bought a machine with 1 TB RAM and filled it with TBs of high speed SSDs and our graph processing framework outperforms clusters of 100s of servers
01:00:54 <dminuoso> kuribas: DNS servers!
01:01:15 <dminuoso> If you operate an authoritative name server, it is required to have at least two of them.
01:01:51 <merijn> dminuoso: I mean, back in the early 2000s there were people hobbying on MUDs that supported hot copy-over, but major companies in 2020 can't manage to update stuff without downtime >.>
01:03:27 <kuribas> merijn: I have been lectured many time how great our lisp platform is, in that you can hot-patch everything in real-time.  But when the system goes down, it takes two hours to restart.
01:03:33 <kuribas> which happened a few times already
01:04:06 <merijn> Wow...
01:04:18 <merijn> 20+ Haskell openings in EU
01:04:56 <kuribas> maybe I should apply there...
01:05:03 <kuribas> I wonder if they allow 4/5
01:05:22 <dminuoso> merijn: facebook has hot code replacement with haskell :P
01:05:43 <dminuoso> but in general, updating a live system is complicated
01:06:12 <dminuoso> Especially if there's multiple parts, because you cant generally execute an update atomically
01:06:23 <merijn> kuribas: THat's what negotiation is for ;)
01:06:38 <dminuoso> What does 4/5 mean?
01:06:45 <kuribas> dminuoso: 4 day workweek
01:06:47 <merijn> dminuoso: I assume 32 hour work week
01:06:52 <kuribas> yes
01:07:01 <dminuoso> ah
01:07:24 <merijn> Looks like they're mostly in Scandinavia so, that's probably negotiable
01:09:12 <dminuoso> merijn: Oh and regarding our earlier discussion with "single node", my current project involves a "servant api + postgres" server.
01:09:42 <dminuoso> Since all but one systems only need read-only, we've decided to duplicate the servant+postgres onto every sever that needs to talk to my API
01:09:58 <dminuoso> So there's one master servant+postgres, and everything else receives postgres streaming replicatoin
01:11:18 <dminuoso> so if any node fails, everyone else can still talk to their local API running on a local database
01:11:41 <dminuoso> that way, we remove the network dependency from the service, and have higher resilience of any single node failing
01:12:14 <dminuoso> (this service is a mission critical piece in our infrastructure, we just cant take the chance of a singular node going down at the wrong time(
01:13:44 <kuribas> dminuoso: that's why most of our code is written with lists instead of structs, because structs cannot be updated easily.
01:14:17 <kuribas> dminuoso: but it decreases readability, because (car foo) isn't clear on what car means.
01:15:07 <kuribas> I feel it's a lot of effort to solve a problem that is not a problem (hot reloading).
01:15:35 <kuribas> with a stateless service we could just restart the app in seconds.
01:39:43 <tomsmeding> kuribas: no wonder you're longing to program in haskell
01:39:53 <kuribas> tomsmeding: yeah :)
01:47:47 <benschza> Are there any Arrows or Yampa gurus online today? :) Solved the purely Haskell related type issue I had yesterday with all of your help, but have another query somebody with Yampa experience could probably advise on. 
02:06:17 <dminuoso> Why cant I have recursive imports
02:06:19 <dminuoso> *sigh*
02:07:01 <dminuoso> *circular
02:07:20 <merijn> dminuoso: I know, right
02:07:31 <merijn> dminuoso: Take time off work to fix it in GHC! :>
02:08:04 <dminuoso> merijn: Oh I had a large discussion with Ryan and some other about it a while ago. Let me summarize the feasibility for you:
02:08:06 <dminuoso> Yeah uh.. no.
02:08:45 <dminuoso> That's one of the things C/C++ at least got right.
02:08:52 <dminuoso> Or semi right, anyhow.
02:09:48 <merijn> What? Not having modules or imports at all? :p
02:10:39 <dminuoso> Well, separating declaration and definition lets you set up circular things easily
02:11:26 <dminuoso> (the problems are essentially deferred to the linker)
02:12:25 <dminuoso> and our linkers *can* handle circular linking
02:12:34 <dminuoso> (say via --start-group)
02:57:59 <royal_screwup21> hello
02:58:22 <royal_screwup21> I'm trying to understand what snippet does and how to run the runFSM functions: https://ideone.com/iHDBvv
02:58:30 <royal_screwup21> could someone give me a quick example?
03:08:57 <ski> call it on an `FSM state input output', and a list of successive `input's ?
03:10:50 <royal_screwup21> ski ah hmm...could you give me a bare bones example of something I could copy-paste into ghci? :)  I'm not really sure I understand what's going on in that snippet (i'm a complete beginner)
03:12:05 <ski> start by defining an example FSM
03:12:54 <ski>   exampleFSM :: FSM Int Char Char
03:13:05 <ski>   exampleFSM = FSM start trans accept out
03:13:08 <ski>     where
03:13:17 <ski>     start = ...
03:13:32 <ski>     trans state input = ..state..input..
03:13:40 <ski>     accept = [...]
03:13:52 <royal_screwup21> ski thanks, I will try that out :)
03:13:53 <ski>     out = ...
03:14:26 <ski> (seems `runFSM' doesn't use the `out' part .. so you could probably set it to `undefined', so far)
03:15:37 <ski> you could use other types (e.g. user-defined) for the state type, and the input and output symbol/token types, if you wanted to
03:15:49 <ski> e.g. you could define
03:16:26 <ski>   data ExampleState = S0 | S1 | S2 | S3 | S4 deriving (Eq,Show)
03:16:37 <ski> and then use `ExampleState' in place of `Int'
03:16:58 <royal_screwup21> ahh I see, for now I'd prefer using the built in types to keep things simple :)  
03:17:04 * ski nods
03:17:58 <vilpan> merijn: you mentioned 20+ Haskell openings in EU. Is there a dedicated site/aggregator?
03:19:37 <royal_screwup21> ski I've got this so far https://ideone.com/pH4Czq do I have to define my custom arbitrary function for trans?
03:20:22 <ski> yes
03:20:47 <royal_screwup21> hmm
03:22:39 <ski> `trans' needs to be able to handle the state `0', and any states that can be reached from that state (by using `trans')
03:23:19 <Uniaika> (“fuck the state” – trans people)
03:23:32 <royal_screwup21> ski I just did trans state input = state + 1 
03:25:33 <ski> hm, in that case you don't really have *finite* number of states, do you ?
03:25:47 <ski> @quote is.no.state
03:25:47 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
03:28:26 <ski> royal_screwup21 : you could cap the state at some number, like `9' e.g.
03:28:50 <ski> > iterate (\n -> min 9 (n + 1)) 0
03:28:53 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
03:32:01 <royal_screwup21> ski I've found an example like so https://ideone.com/UKDuIo all I want to do is run it against the runFSM function, just to get a feel fro what's happening 
03:35:11 <ski> royal_screwup21> runFSM isEven [Zero,Zero,One,Zero,One]
03:35:36 <ski> (btw, i would write `Moore (const ())')
03:38:07 <royal_screwup21> ski thanks a lot for the pointers :)  
03:38:24 <royal_screwup21> I don't quite understand what's going on in this line: `out    = Moore $ const ()`
03:40:06 <ski> replace it by :
03:40:12 <ski>   out    = Moore (const ())
03:40:14 <ski> or
03:40:25 <ski>   out    = Moore (\_ -> ())
03:40:28 <ski> or
03:40:33 <ski>   out    = Moore moore
03:40:35 <ski>     where
03:40:41 <ski>     moore _ = ()
03:41:01 <ski> royal_screwup21 : do any of those three versions make it clearer ?
03:41:26 <royal_screwup21> so it's a function that takes something and returns...()?
03:41:37 <royal_screwup21> what is the ()? Is it null in haskell?
03:41:53 <royal_screwup21> (hard to google :(  )
03:41:54 <ski> oh, well, i suppose you'd have to put the `moore _ = ()' part after the `where' above where you define `trans'
03:42:06 <ski> there is no "null" in Haskell
03:42:22 <ski> `()' is the empty tuple, the zero-tuple
03:42:39 <ski> just like `(x,y)' is the two-tuple, the pair, containing `x' and `y' as components
03:42:43 <royal_screwup21> ah ok
03:43:04 <ski> an `n'-tuple has `n' components. a pair, a two-tuple has two components, a zero-tuple has zero components
03:43:52 <royal_screwup21> yup gotcha, thanks :)
03:44:08 <royal_screwup21> I don't really get that definiton though: 
03:44:08 <royal_screwup21> data OutFunc state input output
03:44:09 <royal_screwup21>   = Moore (state -> output)
03:44:09 <royal_screwup21>   | Mealy (state -> input -> output)
03:44:25 <royal_screwup21> like, how am I meant to instantiate it and then apply it?
03:44:38 <ski> (if you have done any linear algebra with matrices and vectors, you could compare the zero-tuple to an "empty" vector with no coefficients in it, being a vector in ⌜ℝ⁰⌝, a zero-dimensional vector space)
03:45:20 <royal_screwup21> so I know I can do something like `thing = Moore (\x -> x)`
03:45:36 <royal_screwup21> but now how do I actually run it against an input?
03:46:50 <ski> the type `()' corresponds more or less to the type `void' in C,C++,Java,C#. also to empty `struct' type (`struct {}', no components), in C,C++,C# (or rather, extensions that allow it). it has a single value (also written `()', in Haskell)
03:47:25 <ski> you'd typically use `()' as an output (or part of an output), when you don't have any interesting information to put there
03:47:40 <royal_screwup21> yup all that makes sense, it's just an empty tuple 
03:48:21 <ski> `thing = Moore (\x -> x)' would not work, if you have `isEven :: FSM EvenState Binary ()'
03:48:50 <royal_screwup21> ski I just created an arbitrary function, not related to isEeven
03:49:05 <royal_screwup21> I just want to understand how to run `thing` some input
03:49:14 <ski> because then your `state' type is `EvenState' and your `output' type is `()', and your moore function should have type `state -> output', that is `EvenState -> ()', but `\x -> x' does not have this type
03:49:48 <ski> <royal_screwup21> but now how do I actually run it against an input?
03:49:54 <ski> i already answered this :
03:49:56 <ski> <ski> royal_screwup21> runFSM isEven [Zero,Zero,One,Zero,One]
03:50:43 <royal_screwup21> but that's the runFSM function. I want to run `thing` which of type `thing :: OutFunc output input output` 
03:52:51 <ski> oh
03:53:27 <ski> well, it could be a `Mealy' transition function
03:53:55 <ski> so, i think you'd have to provide both a state and an input
03:54:12 <ski> er, s/transition/output/
03:54:29 <ski> you could try to define
03:54:44 <ski>   output :: OutFunc state input output -> state -> input -> output
03:55:14 <royal_screwup21> hmm so I've done this on ghci: thing = Moore (\x -> x). My understand is that I've defined a function (wrapped in a variant) that takes an x and returns back an x 
03:55:17 <ski> and then you could call `output thing E0 Zero', e.g.
03:55:29 <royal_screwup21> basically, how do I run that function?
03:55:55 <ski> you need to pattern-match, to extract the function from the variant alternative, from the data constructor
03:56:03 <royal_screwup21> ahh ok
03:56:19 <ski> but in general, it could be either a `Moore' or a `Mealy', and you should most probably cover both cases
03:56:19 <royal_screwup21> that makes sense, thanks!
03:56:34 <ski> and defining a function like `output' may help with this
03:56:38 <royal_screwup21> I'm not really sure what the point is of having it in the fsm...
03:56:55 <royal_screwup21> the runFSM function doesn't seem to use it
03:57:08 <royal_screwup21> is it just there to confuse the beginner?
03:57:32 <ski> well, according to the definitions at <https://en.wikipedia.org/wiki/Mealy_machine> and <https://en.wikipedia.org/wiki/Moore_machine>, those two kinds of finite state machines both contain output functions, not just transition functions
03:57:58 <ski> i dunno why `runFSM' is as it is
03:58:02 <ski> one could have imagined
03:58:44 <ski>   runFSM :: Eq state => FSM state input output -> [input] -> ([output],state,Bool)
03:59:05 <royal_screwup21> that makes a lot more sense yup
03:59:21 <dminuoso> What does the Bool track?
03:59:40 <ski> so that it doesn't only give you the resulting `state' (with a `Bool'ean for telling whether it's an accepting state) after feeding in the list of `input's, but so that you'd also get a corresponding list of `output's
03:59:53 <ski> dminuoso : whether the resulting state is an accepting state
04:00:25 <dminuoso> Ah
04:14:31 <royal_screwup21> I'm looking at a dataype like so: `data BinState = S0 | S1 | S2 deriving (Enum, Eq, Show)`
04:14:51 <royal_screwup21> is the name completely random, or is there logic to it? binary implies 2 but there's 3 variants
04:17:24 <dminuoso> royal_screwup21: Bin could also stand for bin.
04:17:33 <dminuoso> Or its an abbreviation
04:17:39 <royal_screwup21> bin as in bin-packing?
04:17:43 <Uniaika> royal_screwup21: what's the context?
04:18:11 <dminuoso> royal_screwup21: bin as in bucket
04:18:16 <dminuoso> trash bin
04:18:54 <ski> what's the corresponding FSM ?
04:20:35 <bqv> is it ocaml that has that curious semantic of needing to pass () to a member function to call it
04:20:47 <royal_screwup21> the correspoding fsm is this: https://ideone.com/fb90Ir
04:21:06 <ski> bqv : not that i recall
04:21:20 <bqv> what language am i thinking of then...
04:25:20 <ski> bqv : hm, maybe F# ?
04:25:31 <bqv> oh
04:25:33 <bqv> yes
04:25:35 <bqv> that's the one
04:26:19 <bqv> i suppose that's just a "feature" of working under the CLR
04:27:06 <kuribas> that's true for any language with side effects
04:27:14 <ski> kuribas : no
04:27:21 <dminuoso> https://github.com/cdepillabout/pretty-simple/blob/master/Setup.hs
04:27:37 <dminuoso> Gaah! For that bit of code, this is dragging Cabal into the setup for dependencies..
04:27:44 <kuribas> how would you otherwise know when to exectute the side-effects?  For example "f ()" vs "f"
04:28:09 <ski> see e.g. <https://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html>. the body of a parameterless method is not evaluated until it is called
04:28:47 <ski> a method call is a different construct than an ordinary function call
04:30:09 <ski> royal_screwup21 : hm, ok. doesn't really seem to be related to binary something, apart from accepting bits as inputs
04:31:33 <bqv> ocaml is a fascinating language. why isn't it more used?
04:31:59 * bqv . o O ( same reason haskell isn't )
04:32:43 <ski> OCaml has one of the more interesting object type, and class, system
04:33:27 <ski> it can handle "binary methods" and "cloning methods", that is a method which accepts, or returns, a method of the same type as the object on which it's invoked on
04:34:11 <ski> when these are used, the object type that results from a subclass need not be a subtype of the type that results from the corresponding superclass
04:36:21 <bqv> it is used less widely than even haskell, though
04:36:30 <bqv> are there shortcomings?
04:36:36 <bqv> or is it just nerd tax
04:37:03 <Uniaika> tooling 
04:37:14 <ski> (so if class `C' has a method `m' of type `Self -> bool', then an object instantiated from this class will have `C -> bool' as type of this method. then, if `D' is a subclass of `C', then the type of the method `m' for an object instantiated from this class will be `D -> bool')
04:38:57 <bqv> Uniaika: howso?
04:55:08 <ggole> The OO parts of OCaml are neat, but they don't see much use in practice
05:00:20 <kuribas> how does it compare to F# ?
05:00:32 <kuribas> in F# it's useful because .NET uses OO
05:01:16 <carbolymer> I have a dozen of executables in my stack project, can I tell stack to *not* build them and not copy them, during stack build --test ? installing of executables takes longer than execution of tests....
05:05:34 <maerwald> use `stack test`?
05:07:37 <ggole> They're pretty different, not that I've ever seriously used F#.
05:08:41 <carbolymer> maerwald, stack test is the same as stack build --test
05:08:55 <maerwald> that's a bummer
05:15:34 <bqv> ggole: i don't think anyone has
05:18:29 <carbolymer> even `stack build --test project:test:project-lib` builds and copies executables god knows why
05:29:47 <royal_screwup21> what's the time complexity of adding an element to the a list, like `x: my_list`?
05:30:20 <royal_screwup21> for context, I am wondering what's the complexity of `before` and `after` functions here https://ideone.com/jqgyfk
05:30:21 <bqv> cons is O(1)
05:30:42 <bqv> anything else needs a scan
05:38:12 <royal_screwup21> hmm
05:39:07 <royal_screwup21> I'm looking at an impl of ziplist, which I'm told has parallels to a doubly linked list. I understand lists in haskell, and I know what doubly linked lists are, but I fail to see what the impl has to do with a dll 
05:39:15 <royal_screwup21> https://ideone.com/baFQja
05:43:20 <lyxia> you can move both forward and backwards in constant time
05:45:59 <royal_screwup21> if I have a list [1,2,3] and I want to append 4 to it - how can I do this?
05:46:06 <royal_screwup21> I want the output to be [1,2,3,4]
05:46:34 <xerox_> @hoogle [a] -> [a] -> [a]
05:46:34 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
05:46:34 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
05:46:34 <lambdabot> GHC.Base (++) :: [a] -> [a] -> [a]
05:46:53 * hackage phonetic-languages-examples 0.5.0.0 - A generalization of the uniqueness-periods-vector-examples functionality.  https://hackage.haskell.org/package/phonetic-languages-examples-0.5.0.0 (OleksandrZhabenko)
05:47:01 <royal_screwup21> hmm is there a O(1) way to do it 
05:47:30 <xerox_> unfortunately, in general no
05:49:46 <dminuoso> royal_screwup21: btw, thats better called a zipper than a ziplist
05:50:04 <royal_screwup21> dminuoso why do you say that?
05:50:06 <dminuoso> We have a newtype ZipList which provides an alternate Alternative instance for [], but it's unrelated to your thing
05:50:23 <dminuoso> (or zipper list, list zipper, those are fine names)
05:50:59 <dminuoso> (The general idea is usually called zippers and extends well to trees as well as lists)
05:51:19 <dminuoso> in case of lists the implementation is just trivial and obvious
06:00:21 <ski> royal_screwup21 : i would not make that `Show' instance for `ZipElem'
06:01:05 <royal_screwup21> ski why not?
06:03:43 <ski> because it doesn't output valid Haskell expressions of type `ZipElem a'. because it doesn't handle precedence correctly. because that `show' can't be pre-inverse of a `read', because `read' is supposed to ignore extra wrapping brackets
06:04:10 <ski> `Show' is not intended for pretty-printing
06:05:14 <ski> > read "(((False)))" :: Bool
06:05:16 <lambdabot>  False
06:06:11 <ski> if you define
06:06:29 <ski>   toZipList :: [a] -> a -> [a] -> ZipList a
06:06:51 <ski>   toZipList ls x rs = ZL (reverse ls) x rs
06:07:06 <ski> then you could do
06:07:15 <ski>   instance Show a => Show (ZipList a)
06:07:18 <ski>     where
06:07:38 <ski>     showsPrec p (ZL ls x rs) = showsPrec (p > 10)
06:07:57 <ski>                              $ showString "toZipList "
06:08:10 <ski>                              . showsPrec 11 (reverse ls)
06:08:15 <ski>                              . showsChar ' '
06:08:21 <ski>                              . showsPrec 11 x
06:08:22 <ski>                              . showsChar ' '
06:08:27 <ski>                              . showsPrec 11 rs
06:10:06 <ski> and then `show (insertBefore 0 (insertAfter 1 (insertBefore 2 (newZipList 3))))' would evaluate to `"toZipList [2] 0 [1,3]"'
06:10:48 <royal_screwup21> ski hmm yeah you're right 
06:10:58 <royal_screwup21> it seems really weird 
06:11:03 <royal_screwup21> the currrent impl
06:12:12 <ski> that `Show' instance would generate mostly readable output, getting relatively close to what your pretty-printing intended, while still generating a valid Haskell expression
06:12:39 <royal_screwup21> ski I'm not sure I understand what's wrong with wrt to precedence 
06:12:48 <ski> of course, you can do your own pretty-printing as well (or instead), if you like. but please don't put that pretty-printing into `Show'
06:13:07 <royal_screwup21> so if the ziplist is [1, 2] 3 [5]. Then when I run "before", I should get "1" 
06:15:14 <royal_screwup21> that is, will it turn into [2] 1 [3,5]
06:15:48 <ski> `Show' instances are intended to work together with each other. if you declare an instance for a type, then it will automatically be combined with other existing instances, like for `Maybe',`[]',`Ratio',&c. whenever the user asks to show an input of a type combining your data type with these other types .. you have to consider how such interactions can look like. if you deviate from generating Haskell 
06:15:54 <ski> expressions in `Show', then you will get weird mixes of Haskell and non-Haskell syntax, as a result of such combinations
06:16:25 <ski> royal_screwup21 : "so if the ziplist is [1, 2] 3 [5]" -- what do you mean by this ? do you mean `ZL [1,2] 3 [5]', or do you mean `ZL [2,1] 3 [5]' ?
06:16:46 <ski> (it's not at all clear which you intended)
06:16:51 <royal_screwup21> the former 
06:17:39 <ski> so, yes, `before (toZipList [2,1] 3 [5])' will return `toZipList [2] 1 [3,5]'
06:18:07 <ski> iow, `before (ZL [1,2] 3 5)' will return `ZL [2] 1 [3,5]' -- this is the same thing
06:20:41 <royal_screwup21> ski the core idea behind this impl is that preprending an element to a list is inexpensive, whereas append is expensive -- am i thinking correctly?
06:25:23 <ski> royal_screwup21 : yes, that's correct
06:25:28 <royal_screwup21> ok cool :)
06:25:37 <royal_screwup21> thanks for much for all your help - much appreciated 
06:27:14 <ski> "I'm not sure I understand what's wrong with wrt to precedence" -- hmm, not the best example, but consider `NotFocus (-3) % Focus 2', of type `Ratio (ZipElem Int)'. if you `show' this, you would presumably get `" -3  % (2)"', where that negation isn't protected by brackets, while precedence indicates that it ought to be
06:28:21 <ski> i'm sure you can construct better (that is, worse) examples, but i was trying to think of one that's in the base library
06:29:28 <merijn> ski: eh...did you use ZipList for a list zipper? That seems needlessly confusing, given the existing ZipList...
06:29:41 <ski> the point is that `Show' is supposed to protect parts (like your `x' in `NotFocus x' and `Focus x') with wrapping brackets, if required to force the intended reading, due to precedence of operators
06:29:59 <geekosaur> merijn, royal_screwup21 did and was already told about the collision
06:30:03 <merijn> ah
06:30:11 <ski> merijn : "<dminuoso> royal_screwup21: btw, thats better called a zipper than a ziplist","<dminuoso> We have a newtype ZipList which provides an alternate Alternative instance for [], but it's unrelated to your thing"
06:32:05 <ski> royal_screwup21 : usually, except in very simple cases, when you're writing a `Show' instance manually, you should define `showsPrec', not `show'
06:33:39 <ski> you can define `show' if each possible value is "atomic", never requires wrapping brackets. e.g. `data Bool = False | True' has only "constant data constructors", none of them are parameterized, they don't take arguments, don't have components
06:36:26 <ski> royal_screwup21 : oh, and sorry. `showsChar' above should be `showChar'
06:36:53 <royal_screwup21> :)
06:38:40 <ski> sometimes it makes sense to not expose the implementation (in your case the `ZL' data constructor) in the `Show' instance. but then, imho, one ought to output an expression in terms of the exported operations, the public API, of the module (assuming the data type itself is exported)
06:39:33 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
06:39:35 <lambdabot>  Defined.
06:40:02 <ski> > tabulate (0,7) (\i -> i^2 + 1)
06:40:03 <lambdabot>  error:
06:40:04 <lambdabot>      Ambiguous occurrence ‘tabulate’
06:40:04 <lambdabot>      It could refer to
06:40:08 <ski> > L.tabulate (0,7) (\i -> i^2 + 1)
06:40:10 <lambdabot>  array (0,7) [(0,1),(1,2),(2,5),(3,10),(4,17),(5,26),(6,37),(7,50)]
06:41:14 <ski> that's an example. `Array' is an abstract data type, so its `Show' instance displays an array value in terms of the `array' operation for constructing them (note that i called `listArray', now `array', above. `listArray' is another operation for constructing them)
06:41:18 <ski> @type array
06:41:19 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
06:41:21 <ski> @type listArray
06:41:22 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
06:42:24 <ski> (`listArray' assumes the elements come in a standard order. `array' doesn't assume that, you can list index-element pairs in any order)
07:01:04 <motte> hi, how can i find all possible combinations of a nested list? the result should contain only one element from a given index
07:01:31 <motte> e.g. [[1,2], [4,5]] should turn into [[1,2], [1,5], [2,4], [2,5]]
07:02:17 <merijn> > traverse sequence [[1,2], [4,5]]
07:02:18 <lambdabot>  error:
07:02:19 <lambdabot>      • Ambiguous type variables ‘f0’,
07:02:19 <lambdabot>                                 ‘a0’ arising from a use of ‘show_M31303913069...
07:02:21 <merijn> aww
07:04:14 <xerox_> > sequence [[1,2],[4,5]]
07:04:16 <lambdabot>  [[1,4],[1,5],[2,4],[2,5]]
07:04:28 <merijn> rats, it *is* just sequence?
07:04:57 <motte> oh i messed it up, the result should be [[1,4], [1,5], [2,4], [2,5]]
07:05:02 <xerox_> ding!
07:05:46 <merijn> xerox_: I thought that first, but thought the type didn't match >.>
07:08:50 <motte> huh it really is sequence
07:09:44 <bqv> well what d'you know, it really is just sequence
07:11:24 <bifunc2> What's a good way to find a bytestring b between two bytestrings b1, b2? (b1 < b < b2)
07:11:36 <bifunc2> is there any library for this?
07:11:44 <bifunc2> (of course, Nothing, if none exists)
07:13:34 <Uniaika> bifunc2: like, a substring?
07:13:55 <ski> find common prefix, then take middle point of next two bytes (assuming the first one has at least one more) ?
07:14:15 <hekkaidekapus> > traverse permutations [[1, 2], [4, 5]] -- motte: <== Not what you asked about but may come handy.
07:14:17 <lambdabot>  [[[1,2],[4,5]],[[1,2],[5,4]],[[2,1],[4,5]],[[2,1],[5,4]]]
07:18:34 <motte> hekkaidekapus: haha that's exactly what i was currently working on
07:19:01 <hekkaidekapus> oh, sorry for the spoiler!
07:19:48 <motte> hekkaidekapus: it's good, thanks
07:27:23 <motte> so now i'm trying to run length $ traverse permutations on [[a]], where the length of the outer list is 9 and the length of the inner list is 4 and this very quickly takes away all of my ram
07:28:27 <pjb> motte: permutations is exponential…
07:29:06 <motte> pjb: yes, i realize that, but couldn't haskell discard the already calculated part of the list?
07:30:14 <pjb> I don't know what prevents it to do that.
07:31:47 <pjb> motte: but you can compute it directly as the factorial of the length of the original lists.
07:33:14 <merijn> motte: Where are you running that? i.e. in ghci?
07:34:23 <bifunc2> ski thank you this is the key
07:34:56 <motte> merijn: yes, ghci
07:35:53 <motte> merijn: seems to be the same when i compile it
07:36:59 <motte> although i'm very surprised to see that it uses all of my 8 threads..?
07:38:01 <comerijn> Did you compile with -O2?
07:40:22 <motte> comerijn: yes
07:41:18 <comerijn> Ok, then no clue without seeing code :)
07:43:04 <hekkaidekapus> motte, comerijn: with `print $ length $ traverse permutations [[(1 :: Int) .. 4], [5 .. 13]]`
07:43:18 <hekkaidekapus> I get: 
07:43:21 <hekkaidekapus> 8709120
07:43:32 <hekkaidekapus> 0.81user 0.04system 0:00.86elapsed 99%CPU (0avgtext+0avgdata 155892maxresident)k
07:45:30 <dsal> dminuoso: re: big data: http://dustin.sallings.org/2014/02/04/bigdata.html
08:00:05 <baidobz> Hi everybody, I'm trying to run an IO action, that returns Either, for each element in a list and would like to stop evaluation as soon as one is Left. I tried using fmap and sequence but the later actions are still evaluated and the calculation does not short-circuit. Is the issue that bind in IO is strict?
08:05:15 <tomsmeding> baidobz: can you share the relevant piece of code? It may indeed be that your issue is that bind in IO is strict
08:09:15 <ski> baidobz : fwiw, in general, instead of `sequence (fmap f xs)', you can do `mapM f xs'. but from what you're saying, it sounds like you want to use `ExceptT'. but let's see the code ?
08:10:01 <tomsmeding> I suspect that the relevant code looks like 'sequence <$> mapM action list'
08:10:04 <mtothem> How can i import a local haskell module to my xmonad.hs?
08:10:10 <ski> (something like `runExceptT (mapM (ExceptT . f) xs)')
08:10:29 <ski> mtothem : `import MyModule' ?
08:11:29 <ski> tomsmeding : hm, sounds likely
08:12:13 <mtothem> I've been trying to do that. but it doesn't work for some reason. it does in other projects. so maybe xmonad does something differently i'm thinking
08:12:25 <ski> what is the other file named ?
08:12:41 <mtothem> `colorscheme.hs` ski 
08:12:58 <ski> try naming it `ColorScheme.hs', and do `import ColorScheme' ?
08:13:26 <tomsmeding> (the initial letter of a module name must be a capital letter, the "S" doesn't matter)
08:13:52 <mtothem> `Could not find module ColorScheme`
08:13:53 <ski> (unless it's the main module of an executable)
08:14:11 <tomsmeding> (or you're using a case-insensitive file system, like is the default on macOS)
08:14:13 <ski> you renamed the file ?
08:14:17 <ski> yea
08:17:33 <baidobz> tomsmeding: ski: This is what I'm playing around with now: https://pastebin.com/A2MhUdC8
08:18:29 <tomsmeding> baidobz: yes try ski's suggestion with ExceptT
08:18:29 <baidobz> Basically I would like to short-circuit the processing of the list elements in IO upon any error
08:18:51 * ski low fours tomsmeding
08:18:51 <tomsmeding> (import Control.Monad.Except from the 'mtl' package)
08:19:19 <ski> baidobz : but first replace `sequence (map f xs)' by `mapM f xs'
08:19:39 <tomsmeding> (not necessary, it means the same, but it's neater)
08:19:42 <baidobz> Great I'll try that, thank you
08:21:24 <ski> baidobz : you could change the signature to `runFoo :: Text -> ExceptT MyErr IO Text', if you like to
08:22:34 <ski> (if it's likely that you'd want to call `runFoo' in a context where you'd want to continue doing some possibly-aborting execution (assuming the `runFoo' invocation didn't abort), then i'd do that)
08:23:21 <baidobz> Indeed that worked! How come it does not work with a plain map and sequence? Where does the short-circuiting logic come from?
08:24:01 <tomsmeding> ExceptT explicitly stops executing remaining monadic actions if a Left occurs
08:24:05 <baidobz> The bind of MonadError?
08:24:26 <tomsmeding> normally, the mapM (or in your original version, the 'sequence') would first evaluate all monadic actions, and only when those are complete return the resulting list
08:24:28 <tomsmeding> yup
08:24:52 <ski> it comes from using the `ExceptT' version of `sequence'/`mapM', which ultimately comes from the `Applicative' / `Monad' instance for `ExceptT' being short-circuiting
08:26:52 <ski> (`traverse' (or `sequenceA') is a version of `mapM' (or `sequence') which only requires `Applicative', not `Monad'. back when `sequence'/`mapM' was defined, `Applicative' didn't exist yet, so now you have both those, and `sequenceA'/`traverse')
08:27:37 <ski> baidobz : `MonadError' doesn't come to play here
08:31:49 <baidobz> Super interesting. I'm looking at the Haddock and mtl's sources to try and find the relevant definition in the code now
08:32:40 <tomsmeding> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Except.html#line-212
08:32:47 <baidobz> I guess it's in transformers
08:32:59 <baidobz> Yes! Thanks :)
08:33:43 <tomsmeding> it's refreshing how readable basic definitions like these are, the short-circuiting is actually evident in the definition of >>= (which is only 5 lines)
08:33:58 <tomsmeding> contrast with e.g. C++ standard libraries...
08:34:32 <baidobz> Indeed it's very simple and clear
08:35:10 <baidobz> I used to do lots of template meta-programming in C++ and I don't miss it
08:36:11 <baidobz> Thanks a lot for your quick help!
08:37:17 <baidobz> Can I also ask: is there a situation (different Monad?) where my naive approach with sequence would work out similarly due to laziness or does sequence/mapM always evaluate all monadic actions?
08:37:50 <comerijn> baidobz: The ordering of effects is independent of laziness
08:37:57 <ski> it always executes all the actions (performing all the effects)
08:38:21 <comerijn> baidobz: The Monad/Applicative instance of, say, IO are always in sequential order
08:38:23 <ski> but yes, non-strictness is a separate thing
08:39:10 <solonarv> well, no.   sequence [System.Exit.exit, putStrLn "hello"]   will not output   hello   to the terminal, for a counterexample
08:39:21 <comerijn> baidobz: So yes, sequence and mapM guarantee that all the actions are done by the time the sequence/mapM is done
08:39:25 <comerijn> solonarv: >.>
08:39:43 <comerijn> solonarv: That's not a contradiction, anyway
08:39:53 * hackage polysemy-methodology-composite 0.1.0.0 - Functions for using polysemy-methodology with composite.  https://hackage.haskell.org/package/polysemy-methodology-composite-0.1.0.0 (locallycompact)
08:40:10 <comerijn> solonarv: exit happens in sequential order with the rest :p
08:40:11 <solonarv> depending on which   Monad   instance is being used, the later ones may or may not be exexucted, or evaluated
08:40:25 <solonarv> (however the *order* does not depend on which instance is in play)
08:40:51 <ski> oh, good example. i suppose one should say that each action is executed, provided all the previous ones terminated normally
08:41:23 * hackage polysemy-methodology-composite 0.1.1.0 - Functions for using polysemy-methodology with composite.  https://hackage.haskell.org/package/polysemy-methodology-composite-0.1.1.0 (locallycompact)
08:41:36 <solonarv> they're executed in order, but an action might say "exit immediately, nothing after me gets executed" or even "everything after me happens twice" or "everything after me happens on another thread"
08:41:55 <ski> (obviously when executing `do foo; undefined; bar', `bar' will not be executed, at least in general)
08:42:22 <ski> yes, which is exactly what `ExceptT' does (the "nothing after me gets executed" part)
08:42:53 * hackage polysemy-methodology-composite 0.1.2.0 - Functions for using polysemy-methodology with composite.  https://hackage.haskell.org/package/polysemy-methodology-composite-0.1.2.0 (locallycompact)
08:43:03 <solonarv> yep; the other two can be accomplished by Cont / ContT, and probably also by a number of other monads
08:43:18 <ski> yep (i see how one could accomplish it)
08:43:50 <baidobz> Great points, that makes sense
08:43:53 * hackage cabal-file 0.1.1 - Cabal file access  https://hackage.haskell.org/package/cabal-file-0.1.1 (JensPetersen)
08:46:47 <motte> hekkaidekapus: >[[(1 :: Int) .. 4], [5 .. 13]]
08:46:51 <ski> in `do n <- [1 .. 9]; d <- [2 .. n-1]; guard (n `mod` d == 0); return (n,d)', for some choice of `n' (namely `1'), everything after `d <- [2 .. n-1]' will be executed zero times (iow, we abort that choice of `n'), and for some other choices of `n', what's after will be executed several times
08:47:54 <ski> (and then, similarly, for different choices of `d', what comes after the `guard' invocation may be executed once or not at all)
08:48:05 <ski> > do n <- [1 .. 9]; d <- [2 .. n-1]; guard (n `mod` d == 0); return (n,d)
08:48:07 <lambdabot>  [(4,2),(6,2),(6,3),(8,2),(8,4),(9,3)]
08:48:31 <motte> hekkaidekapus: the list i was talking about was more like replicate 9 [1..4]
08:48:48 <ski> (it computes composite numbers less than ten, paired with possible proper divisors)
08:50:07 <motte> hekkaidekapus: so main = print $ length $ traverse permutations $ replicate 9 [1..4] , which quickly eats all my ram, even with -O2
09:02:22 * hackage beam-automigrate 0.1.0.0 - DB migration library for beam, targeting Postgres.  https://hackage.haskell.org/package/beam-automigrate-0.1.0.0 (abrar)
09:09:48 <Martinsos> join /nickserv
09:41:52 * hackage stack-all 0.1 - CLI tool for building across Stackage major versions  https://hackage.haskell.org/package/stack-all-0.1 (JensPetersen)
09:55:33 <kwantuM> hey, I was wondering if someone could explain what the (I# x#) syntax means. I was looking at the data.bits source
09:56:06 <glguy> kwantuM: in that context # is just another letter
09:56:33 <glguy> I# is a constructor and x# is a variable there.
09:56:53 <glguy> The convention is that unboxed things have a # in their names
09:56:53 <kwantuM> so why is the # used?
09:57:00 <kwantuM> oh okay, thanks!
10:02:17 <hekkaidekapus> motte: Yeah, that will blow up quickly. The oneliner we are using is useful for short lists. Perhaps approach your problem from another perspective. Define a list (a set, really) and build up permutations σ₁, σ₂, σ₃… based only on indices. Then work on those σs to pick elements from the set as you like.
10:22:23 * hackage telegram-bot-simple 0.3.4 - Easy to use library for building Telegram bots.  https://hackage.haskell.org/package/telegram-bot-simple-0.3.4 (swamp_agr)
11:40:23 <sm[m]> friends.. could you guess why doing writeIORef in this yesod test suite blocks the test ? https://paste.tomsmeding.com/HfUbmN1S
11:42:22 <sm[m]> the test causes this line to run, which presumably reads from the IORef: App {appOpts = opts, appJournal} <- getYesod
11:43:12 <sm[m]> or rather, that appJournal IORef does get read from, during the test
11:44:04 <tomsmeding> add more putStrLn until you find the exact statement that blocks :p
11:44:28 <sm[m]> and yes, if I comment out the read it's fine. The write followed by the read soon after causes it to block
11:46:11 <sm[m]> probably is this running in threaded mode. Perhaps I need atomicWriteIORef..
11:47:23 <sm[m]> no change. Darn.
11:52:23 <sm[m]> well, I've read https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-IORef.html carefully but nowhere does it say that IORef operations can block. Is it normal ?
11:54:04 <sm[m]> I don't even have to writeIORef - if I newIORef with this value, then try to read, it also hangs. Hmm.
11:55:27 <monochrom> AFAIK writeIORef doesn't block.
11:55:47 <monochrom> and even more strongly, it doesn't block other threads either
11:57:51 <moet> can i add a `{-# WARNING .. #-}` pragma on a function body in a class instance?
11:58:06 <moet> gets a parse error currently, so i guess the answer is no, but i just wanted to confirm
11:59:48 <monochrom> Does the GHC user's guide say something about this?
12:00:47 <sm[m]> monochrom: thanks
12:02:02 <sm[m]> I think what I'm writing must have a circular reference or an infinite loop, but darned if I can see it.. 
12:02:06 <moet> monochrom: it's kind of unclear, but it says "You can attach a warning to a function, class, type, or data constructor, with the following top-level declarations"
12:02:36 <moet> and "You can only attach to entities declared at top level in the module being compiled"
12:03:04 <moet> which might be construed to mean that it doesn't include a typeclass instance function because that's "declared" elsewhere, in the module where the typeclass is located?
12:56:11 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Survey 2020: https://haskellweekly.news/survey/2020.html'
12:56:11 --- topic: set by monochrom on [Sun Nov 01 11:31:39 2020]
12:56:11 --- names: list (clog renzhi livvy Kaeipi Gurkenglas leungbk` merijn vicfred avdb shadowdao cosimone rprije conal royal_screwup21 heatsink jonatanb moet cr3 britva bliminse w1gz star_cloud cantstanya stree _ashbreeze_ geekosaur jakalx howdoi teardown zincy__ berberman_ lestrrat chaosmasttter alp pavonia Tario hyperisco nados TommyC todda7 texasmynsted APic vfaronov raichoo __monty__ machined1od acarrico electricityZZZZ hnOsmium0001 dbmikus__ kav nbloomf Chi1thangoo zaquest)
12:56:11 --- names: list (quinn Ariakenom benjamingr__ veverak fendor__ ech baidobz bidabong wtw Tuplanolla reallymemorable texasmynsted_ elfets revprez_anzio polyphem xff0x Sgeo kritzefitz mtothem bitmapper lucasb motte darjeeling_ Amras st8less urodna Beetstra1 hiroaki DavidEichmann jchia raehik AlterEgo- p8m jchia_ ambiso9 Deide dmiles kish` perrier-jouet shatriff hekkaidekapus dennisb roconnor carlomagno cow-orker dustinm Ferdirand coot m0rphism Franciman gehmehgeh kuribas jedws)
12:56:11 --- names: list (Audentity_ thebnq Varis danvet mananamenos alx741 zoran119 feliocrat takuan echoreply thc202 monochrom jathan day denisse verement elliott_ mputz ChaiTRex haasn theDon xsperry lagothrix Unhammerd tinwood sim590 devalot nahcetan Lord_of_Life zebrag DataComputist aizen_s psydruid jb55 grol DeadComaGrayce[m HiRE_ jokester_ pfurla fryguybob komasa nckx pong recon_- jelleke lightandlight glguy L29Ah ft dftxbs3e Cale DTZUZU taurux brettgilio asnyx jedai phaul)
12:56:11 --- names: list (jlamothe gareth__ pieguy128 s00pcan ystael ephemera_ sdrodge nek0 z0k gxt dexterlb amiri kjak leah2 ski ericsagnes falling-edge[m] toppler datajerk Alleria_ hive-mind coco krjst dave_uy thunderrd justanotheruser shutdown_-h_now alexelcu clynamen angerman wwwww tabemann shailangsa tomboy64 nf dominicusin[m] themsay[m] Noughtmare[m] jeffcasavant[m] raoul maralorn johnnyboy[m] PotatoHatsue ttc ComaGrayce[m] jesser[m] PotatoHatsue|T loprakoa[m] jkaye[m] jtojnar)
12:56:11 --- names: list (wanaks[m] fgaz micahsovereign[m hnOsmium0001[m] theduke mikr[m] chreekat[m] berberman[T] texasmynsted[m]1 TekShifter[m] wi[m] drozdziak1 wrunt[m] camlriot42 zerstroyer[m] elpfen[m] unclechu betrion[m] Fernando-Basso[m michaelpj dyniec[m] lambdaclan kaychaks_riot srid tersetears[m] ThaEwat sureyeaah siraben hsiktas[m] Ericson2314 lnxw37d4 iinuwa kadoban alexfmpe domenkozar[m] rednaZ[m] dmj` pqwy[m] sm[m] miseenplace[m] jlv rann entel xsarnik0 betawaffle Jajik)
12:56:11 --- names: list (feepo affinespaces bjs Ekho so parisienne higherorder cbarrett conjunctive albethere Boarders mudri eacameron terrorjack PatrickRobotham_ jlpeters integral dsal hamishmack chpatrick lolmac Nascha tsrt^ parseval Codaraxis_ cgfbee systemfault kaychaks agander_m graingert stylewarning cstrahan liszt_ mort eedgit26 rprosper- andjjj23 runawayfive earthy wayne Kneiva voidcontext exarkun drewr arkeet` lemald pdxleif crtschin connrs Cerise deu WzC oleks lkurusa jol)
12:56:11 --- names: list (chindy nemesit|znc Ivan__1 PragCypher aidecoe seanparsons mniip Axman6 phaazon m4lvin incertia valdyn mupf styledash sakirious Maxdamantus @Sigyn tomjaguarpaw xnyhps xcin solarus PHO_ bonz060 riatre sim642 Bigcheese drdo Forkk robotmay ruffy_ TimWolla ggVGc jophish lpsmith tabaqui idupree bspar ego dumptruckman NinjaTrappeur denucat nshepperd infinisil entropygain dequbed zyeri DigitalKiwi vnz miklcct Blkt yorick i7c jess liquorice ibloom metadave jackdk totbwf)
12:56:11 --- names: list (joshmeredith heyj topos jared-w AndreasK dsturnbull rodlogic__ cemerick caasih jbetz trevorriles J_Arcane SegFaultAX zymurgy mceier poljar1 SolarAquarion acertain kip martin02 hyiltiz-M rawles _flow_ noCheese joeyh_ thonkpod opqdonut heredoc Orbstheorem digia bobbytables bsima Flonk remexre aplainzetakind wagle gnumonic_ tstat orcus rdivacky noan unlink_ dexterfoo seveg fredcy Athas jackhill hc Reiser strangeglyph ManiacTwister fl0_id Madars bendo enikar tms_)
12:56:11 --- names: list (dilinger yumh PyroLagus sm yushyin Klumben e @ChanServ raid_ sphalerite immae ezzieyguywuf liff hyiltiz bqv ByronJohnson gawen andi- coeus gluegadget alinab banjiewen_ nh2 pasukon NemesisD jetpack_joe rizary FMJz____ sclv ebutleriv edmundnoble nlofaro wildsebastian ^[ koankeeper tchar carter eruditass elvishjerricco d0liver natim87 drbrule alunduil johs ReinH__ edwinb pepeiborra ocharles joel135 SrPx Kamuela mankyKitty pent JSharp bitonic fiadliel mcfilib_)
12:56:11 --- names: list (amatecha__ tiru chessai teehemkay whez verlet64_ enemeth79 billstclair adamse Raito_Bezarius dusty_pacer ixian Taneb sveit otulp BIG_JIMMY_D ghuntley kyagrd__ glowcoil dani- hazard-pointer m-renaud kristjansson milessabin taktoa[c] rslima_____ srhb koz_ PlasmaStar tdhttt nshepperd2 gecko_ centril dddddd dan64 Benzi-Junior samebchase- dcoutts__ mud Benett Neuromancer dxld nurupo Bergle_2 gremax drewolson glamas blackdog polux20013 sdx32 hexagoxel c_wraith)
12:56:11 --- names: list (Philonous Firedancer_ atomi cjh` Entroacceptor mantovani reda swater shapr Guest60204 greymalkin obiwahn haveo xe4 uberj Sparadox mikolaj exferenceBot jkarni fiddlerwoaroof jvanbure heath gargawel supki lieven esotericalgo xlei keltono lazyshrk alanz mpickering Firedancer runeks jonrh iphy Cir0X benwr____ nick_h ProofTechnique aristid lxsameer hongminhee lockshaw gienah Jonno_FTW nerdypepper matthew- [df] spoonm eagleflo Graypup_ t36s acro cyphase bind jmsx)
12:56:11 --- names: list (iteratee jvsg xts Logio puffnfresh_ robogoat Putonlalla DustyDingo suppi arianvp tylerjl towel whataday debugloop dixie relrod dale p3n_ zopsi_ byorgey tromp vk3wtf tessier grumble apoc mozzarella sulu jrqc dcoutts_ bgamari Jon _deepfire NieDzejkob davl johnstein pacak rzmt twk- sajith cods dopplergange caubert stiell c-rog Cathy simplegauss outerpassage joeytwiddle bcmiller gambpang_ clever luigy forell troydm Igloo sagax esph tmciver atk lambdabot Wamanuz2)
12:56:11 --- names: list (tomku gentauro russruss84 sarahzrf RusAlex theorbtwo meck duairc brown121407 michalrus beka vodkaInf1rno ircbrowse_tom cyberlard lortabac aweinstock lukelau_ sea-gull marek tdammers ziman fr33domlover anoe pierrot jtcs_ jzl irclogger_com tumdedum pounce tasuki cjay mikolaj_ kipras`away sud0 coddinkn Jello_Raptor xintron Lowl3v3l AWizzArd lyxia cheater Qudit314159 _xor infinity0 is_null jhuizy SupaYoshi codedmart Majiir Tene werneta mapperr rotaerk aoei)
12:56:11 --- names: list (dredozubov waskell zfnmxt dustypacer dysfigured Nikotiini tomsmeding avn Patternmaster hwabyong dibblego tanuki hodapp bcoppens jamestmartin klardotsh arw daenth samebchase jameekim1 mrus M2tias Tristan- elcaro bwe vjoki weechat_2 Faye LittleFox mystfox copypasteque_ madnight fiQ2 mstruebing davean benschza nisstyre loc nullheroes stux|RC-only jpds ashnur thi drupol joehillen PotatoGim gabiruh daGrevis Foritus thecoffemaker ridcully rdivyanshu ryjm averell)
12:56:11 --- names: list (Inoperable brisbin jassob johnw hvr ps-auxw munsel eedgit atraii hackage dolio Uniaika kini Xnuk nh amosbird quintasan questionmarkking dminuoso xarian_ rkrishnan MasseR niklasb_ adaj zgrep duckonomy zzz Tourist geal NGravity shachaf Dykam dh add^_ Squarism statusbot haskell_enthusia malthe msgctl Zemyla piele electrocat anderson deni djanatyn reyu Eliel vimto1 cp- totte yahb MindlessDrone arahael TMA Kaivo noecho hpc edwtjo tv jdt rookie101 fre adamCS dwt)
12:56:11 --- names: list (rotty jrm Ranhir sajith_ qz vancz pie_ [exa] sqrt2 oldsk00l maerwald connrs_ sujeet Papa le_jonge mmaruseacph2 micro hiredman ViCi {abby} SquidDev aib pharaun Deewiant ring0` e2 asm89 absence abuss chirpsalot Chobbes kqr srk hyperfekt Vq kozowu typetetris chrpape` Katarushisu cocreature newhoggy davetapley scav benl23 gaze__ simony gregberns_ alexknvl buggymcbugfix edwardk bradparker ajmcmiddlin dgpratt Adeon idnar tnks yogani wpcarro lally grfn moobar)
12:56:11 --- names: list (PoliticsII______ Tritlo adius bjobjo feuerbach spamlessj TheScoop mflux Someguy123 sis7_ Takumo vqrs noexcept_ mursu nikola3 jiribenes xacktm incognito9999 Randy Iroha balbirs a3f operand lucas8 magog kkd rom1504 beaky lisq farn__ eldritch hexic Adluc saidinwot1 nyaomi a3Dman ekleog cheers wz1000 nitrix CitizenSnips Geekingfrog aldum StoneToad_ marble_visions cynick bob_twinkles agrif icebreaker jonatan cohn tv- quaestor jtobin wraithm cpape Khisanth Moyst)
12:56:11 --- names: list (stefan-_ oats int-e carldd patrick1 urdh esg CindyLinz quicksilver Clint bollu dwts orzo comboy myme ornxka landonf rednaZ2 noctuks Guest2620 reactormonk canta ben_m bandali koala_man kaol peutri gekh petersen ishutin_ evanjs eyenx noctux keep_learning Solarion laxask uwap_ tristanC lep-delete rkvist obfusk tureba Cheery magicman blissful mrchampion tolt wowi42_ morbeus RecursiveG nopf davve dqd saurik rembo10 m1dnight_ karolus thaumavorio filwisher dagnabbit)
12:56:11 --- names: list (s4msung epta EvanR janne energizer electrostat Drezil ahf lnx kloeri `slikts pjb lexi-lambda cvlad- Wojciech_K jjhoo megaTherion suzu_ andreas31 darthThorik Rembane Cthalupa Techcable RoguePointer mr_yogurt freeside neobit concept2 jluttine Tspoon stvc seliopou madog jle` ptrcmd jemurray mac10688 mawk ent lassulus auri_ ArsenArsen aurieeeh haritz Unode interruptinuse mp___313 avp sshine dpl Arguggi LambdaDuck catern kosmikus Chousuke Ankhers statusfailed)
12:56:11 --- names: list (rodgzilla divVerent turq gothos ammar2 newsham carbolymer)
13:00:16 <sm[m]> dminuoso: good idea, but I think I've found it. My "simple" value-generating action is going wrong when called with unusual programmatic arguments. Not exactly sure why it hangs but I can see it going off the rails
13:00:28 <sm[m]> ie, it was the value and what the code under test does with it, nothing to do with the IORef activity
13:01:41 <sm[m]> tests breaking stuff already  \o/
13:10:53 * hackage hyper-haskell-server 0.2.3.0, hyper-extra 0.2.0.0, hyper 0.2.1.0 (HeinrichApfelmus): https://qbin.io/longer-equal-cbm8
14:30:03 <PatrcikGrey> Hello everyone, nice to meet all of you, I tried to google it but failed, so maybe some of you will know the answer:
14:30:35 <PatrcikGrey> Do you know any successful uses of haskell in object detection?(especially people detection) 
14:31:53 <PatrcikGrey> Tried to find some libraries/code/companies but its pretty weak compared to c++, however I would really want to do it in functional way.
14:39:44 <texasmynsted> What is object detection?
14:40:23 * hackage polysemy-methodology 0.1.7.0 - Domain modelling algebra for polysemy  https://hackage.haskell.org/package/polysemy-methodology-0.1.7.0 (locallycompact)
14:42:21 <texasmynsted> Maybe just use an object detection lib from C and call that from Haskell?
14:43:53 * hackage polysemy-extra 0.1.5.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.5.0 (locallycompact)
14:45:53 * hackage polysemy-extra 0.1.6.0 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.6.0 (locallycompact)
14:47:52 * hackage polysemy-extra 0.1.6.1 - Extra Input and Output functions for polysemy..  https://hackage.haskell.org/package/polysemy-extra-0.1.6.1 (locallycompact)
15:04:20 <edwardk> PatrcikGrey: hrmm
15:04:44 <edwardk> PatrcikGrey: https://www.youtube.com/watch?v=Zlt6EJVdUN8 was written in haskell
15:04:53 <edwardk> not people
15:05:02 <edwardk> but 3d shape recognition, motion planning, etc.
15:06:52 <edwardk> there's also http://lumi.guide/ the folks there are doing stuff for figuring out numbers of bikes in parking garages with computer vision / haskell
15:08:08 <edwardk> PatrcikGrey: neither is exactly what you want, which sounds like you're looking for something like, what, opencv bindings?
15:09:52 * hackage polysemy-vinyl 0.1.3.1 - Functions for mapping vinyl records in polysemy.  https://hackage.haskell.org/package/polysemy-vinyl-0.1.3.1 (locallycompact)
15:21:41 <moet> PatrcikGrey: i've used the opencv bindings, of which there are several. You'll have to do some work to wrap them for a "functional" style if that's what you're after.
15:22:53 * hackage polysemy-vinyl 0.1.4.0 - Functions for mapping vinyl records in polysemy.  https://hackage.haskell.org/package/polysemy-vinyl-0.1.4.0 (locallycompact)
15:44:14 <xe4> is there an equivalent of headMay for Vector?
15:44:50 <glguy> xe4: v !? 0
15:44:56 <edwardk> !?0
15:45:02 <edwardk> beat me to it
15:45:24 <glguy> and instead of pulling in a dependency for headMay there's listToMaybe in base
15:45:26 <edwardk> clearly the solution is first to install lens...
15:45:38 <glguy> Like it wasn't already installed o.O ?
15:45:48 <edwardk> it is gauche to assume =)
15:46:15 <xe4> hey! that worked, thanks glguy and edwardk for paying attention to the channel :) 
15:47:54 <xe4> maybe I should use List until it proves to be a problem
15:50:00 <sm[m]> how would you convert a UTCTime (or a POSIXTime, AKA NominalDiffTime, AKA seconds since epoch) to a ClockTime ?
15:50:10 <sm[m]> in a total way ?
15:51:42 <sm[m]> to construct a ClockTime, you need an Integer. POSIXTime/NominalDiffTime doesn't have an Integral instance, so toInteger is out
15:52:24 <sm[m]> I solved this before by read . show, which is crap
15:54:06 <sm[m]> aha.. I can round it
15:57:54 <sm[m]> though, that'll be accurate only to a second. properFraction could work better
16:03:47 <sm[m]> does that look sane ? utcTimeToClockTime https://paste.tomsmeding.com/3lmo5ohU
16:07:34 <sm[m]> approved by scientific ghci testing
16:13:32 <sm[m]> https://github.com/haskell/old-time/issues/11
16:18:23 * hackage polysemy-methodology-composite 0.1.3.0 - Functions for using polysemy-methodology with composite.  https://hackage.haskell.org/package/polysemy-methodology-composite-0.1.3.0 (locallycompact)
16:20:22 <MarcelineVQ> surely there's a more constructive tagline for that than to repeat the package name
16:24:37 <sm[m]> I want to check if a file exists, and I don't want to ever get an IO error. I suppose that's not guaranteed by System.Directory.doesFileExist, right
16:24:56 <sm[m]> eg if filesystem disappeared or something
16:32:31 <monochrom> Expecting programmers to know how to describe a thing without using code or "meaningful" names? :)
16:34:34 <int-e> sm[m]: what if the FS disappears between the test and whatever you did the test for?
16:35:03 <int-e> . o O ( doesFileCertainlyExist _fn = return False )
16:37:27 <sm[m]> int-e: that's what I'm saying.. if I want to guard against such things I think I need to catch IOException, not just rely on it returning False
16:38:06 <c_wraith> int-e: that's just a naming problem.  a name like probablyExistedAtSomeTime lets it be more useful.
16:38:15 <sm[m]> oh.. well yes now you make things more difficult for me :)
16:39:34 <int-e> sm[m]: I liked my function, because it's not going to throw an IO error. :P
16:41:01 <sm[m]> there's a fine line here and I think you have gone too far :)
16:41:02 <int-e> computers just have too many ways to fail
16:41:27 <sm[m]> main = exitFailure
16:42:12 <int-e> main = main -- partially correct; TODO: imrpove running time
16:42:53 * hackage charter 0.1.1.0 -   https://hackage.haskell.org/package/charter-0.1.1.0 (ChrisPenner)
16:43:02 <int-e> (though that joke doesn't quite work with blackhole detection)
16:44:05 <MarcelineVQ> then there's the case where something else entirely threw the IO error during your IO action
16:44:34 <bqv> sm[m]: technically, you should be catching IOException anyway, right?
16:44:54 <bqv> they can strike at any time!
16:44:59 <bqv> when you least expect it...
16:45:03 <bqv> except in pure code.
16:45:40 <sm[m]> bqv I suppose you're right, and in fact I only use this in the context of Yesod which does that
16:46:27 <sm[m]> so catching exceptions in here is probably trying too hard. I am also just afraid of anything exception related at this point, I feel it's going to bite me.
16:47:33 <bqv> heh
16:51:53 * hackage charter 0.1.1.1 -   https://hackage.haskell.org/package/charter-0.1.1.1 (ChrisPenner)
17:52:53 * hackage isbn 1.1.0.2 - ISBN Validation and Manipulation  https://hackage.haskell.org/package/isbn-1.1.0.2 (charukiewicz)
19:18:32 <mtothem> How can i properly import a variable from a module? https://termbin.com/u31f It works like intended if i have it same scope (no module). But i get these errors when i import this module and try to use it. https://termbin.com/6y8p9
19:19:09 <glguy> mtothem, you need to export more stuff
19:19:21 <glguy> module Colorscheme     ( gruvboxVoid, ColorScheme(..) ) where
19:20:02 <mtothem> Oh, do i need to include all the fields as well?
19:21:34 <glguy> mtothem, If you put the (..) it will export the value constructor and field selectors
19:21:45 <glguy> without them it only exports the type constructor
19:22:43 <mtothem> That makes sense, thanks a lot glguy 
19:38:52 <joebobjoe> does anybody have a problem with TOML
19:41:04 <joebobjoe> what is a better alternative
19:48:45 <pavonia> joebobjoe: Better in what way?
19:49:12 <joebobjoe> I don't know, the language is not obvious to me
19:50:22 <glguy> For configuring my IRC client I made this: https://hackage.haskell.org/package/config-value
19:50:43 <joebobjoe> from the v1.0.0-rc.3 spec: "Dotted keys define everything to the left of each dot as a table."
19:50:49 <glguy> It has a sister library that handles defining schemas, generates documentation, produces error messages for missing fields, etc
19:51:47 <joebobjoe> but you can make constructs like: [[a]] then [a.b] on the next line
19:52:02 <joebobjoe> thanks glguy I'll look
19:52:45 <glguy> *TOML> parseTOML "[a.b.c]\nd = 10\ne=20\n"
19:52:45 <glguy> Right [("a",Table [("b",Table [("c",Table [("d",Integer 10),("e",Integer 20)])])])]
19:55:20 <joebobjoe> *TOML> parseTOML "[[a]]\n[a.b]\n"
19:55:28 <joebobjoe> I thought it was a bot
19:56:00 <joebobjoe> maybe a.b is not a "key"?
19:56:09 <glguy> *TOML> parseTOML "[[a]]\n[b.c]\n"
19:56:10 <glguy> Right [("a",List [Table []]),("b",Table [("c",Table [])])]
19:56:19 <glguy> I'm just using a GHCi session to run those
19:56:53 <joebobjoe> oops
19:57:09 <joebobjoe> you changed a.b to b.c
19:57:20 <glguy> yeah, what you wrote was invalid
19:57:34 <glguy> *TOML Text> parseTOML (Text.unlines ["[[a]]", "x=1", "[[a]]", "y=2"])
19:57:34 <glguy> Right [("a",List [Table [("x",Integer 1)],Table [("y",Integer 2)]])]
19:58:06 <glguy> You can't define a to be both a list and a table
19:59:02 <joebobjoe> what is the error exactl?
19:59:33 <glguy> You tried to use 'a' as a list and as a table; you have to pick one or the other
20:00:00 <joebobjoe> try it
20:00:05 <joebobjoe> it works
20:00:23 <joebobjoe> and I was wrong
20:00:32 <joebobjoe> the a in the a.b is actually referring to a table
20:00:37 <joebobjoe> the spec is right
20:00:51 <joebobjoe> its just the last table in the array of tables whose last member was [[a]]
20:04:27 <glguy> Ah, I didn't know about that particular behavior
20:06:03 <joebobjoe> non-obvious
20:06:11 <joebobjoe> obvious to Tom I guess
20:07:36 <jollygood2> is there any library in haskell for analyzing live video image [from a webcam]? I need to detect some relatively simple objects
20:12:48 <joebobjoe> glguy: how do I get into the same *TOML Text> environment as you?
20:13:24 <glguy> It's a library I made, but I'll have to fix it up for that case we were just talking about
20:13:38 <glguy> cabal repl --build-dep toml-parser
20:16:07 <jollygood2> I did some googling, and I could just find linux-only webcam packages 
21:02:23 <Guest_30> when I set up ghc, I met a problem: Make sure to clean up "/var/folders/zh/j3p4n0757pn_41f22p0hjzcm0000gn/T/ghcup-ivgyrr" afterwards. How could I do?
21:26:38 <bqv> I just did :t in a nix repl by accident
21:26:48 <bqv> and was surprised when it worked...
21:26:54 <bqv> Ish
21:43:53 * hackage brick 0.57.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.57.1 (JonathanDaugherty)
22:33:06 <dsal> How relevant is recursion-schemes as a library?  It seems like catamorphisms are covered really well by Foldable.  Is there something similar for anamorphisms?
22:34:11 <MarcelineVQ> 12 relevant
22:35:53 <dsal> Heh.  I have a cool data structure that's a functor, foldable, traversable, monoidal, etc...  I guess trying to see if I can figure out the fixed point of it would be helpful.
22:36:33 <MarcelineVQ> it'd be the neutral value of the monoid yeah?
22:37:14 <dsal> I understand the goals a lot better than I understand the details at this point.
22:37:51 <MarcelineVQ> a fixed point is 'of' some operation, iiuc, so it'd depend anyway
22:38:04 <dsal> e.g., the base functor with an extra type is still still a bit confusing to me.
22:39:19 <MarcelineVQ> What's that? :>
22:40:18 <dsal> https://hackage.haskell.org/package/recursion-schemes-5.2.1/docs/Data-Functor-Base.html
22:40:32 <dsal> e.g., `data ListF a b` is the base functor for `[a]`
22:54:12 <MarcelineVQ> ah neato, abstracting the recursive structure to make it not-recurvise
22:55:11 <hololeap> dsal: the idea is that you can take a self-referencing recursive structure, like `data Stream a = Stream a (Stream a)`, and replace that self-reference with a type variable, e.g. `data StreamF a b = StreamF a b`
22:56:00 <hololeap> and thus `Fix (StreamF a)` = `Stream a`
22:59:10 <hololeap> anamorphims are covered by `unfold`-like functions
23:04:14 <hololeap> dsal, is your data structure recursive?
23:09:08 <dsal> Yeah.  I've got this:  `data SubTree a = SubTree { subs  :: Maybe a,  children :: Map Filter (SubTree a) } deriving (Show, Eq, Functor, Traversable)`
23:10:57 <dsal> I understand unfold is an anamorphism, I'm just wondering if there's a class for that.
23:14:05 <dsal> I had originally hand-written Functor and Traversable before I figured out ghc would just do it for me.
23:15:06 <dsal> Oh, `b` is just "me" there?
23:17:17 <bliminse> dsal: there's no Unfoldable class as far as I know, only thing close is the actual Corecursive class in the recursion-schemes package itself
23:17:22 <hololeap> more or less... it allows for an algebra (StreamF a b -> b) to be used for the catamorphism
23:17:42 <hololeap> and, dually, a coalgebra (b -> StreamF a b) to be used for the anamorphism
23:18:08 <dsal> Makes sense.  I guess I should see if I can even implement this.
23:18:57 <hololeap> the problem that i see is that `SubTreeF a b` would need to be functorial in b, but it's wrapped in a Map
23:19:41 <hololeap> so, you might not be able to plug it into the recursion-schemes layout
23:20:00 <dsal> Yeah, I was noticing the lack of Map there.
23:20:35 <hololeap> still, it is very much possible to write a custom (cata/ana)morphism function for it
23:21:09 <hololeap> well, i can't guarantee it, since i haven't tried
23:22:04 <dsal> Well, this type is "done" -- I'm just trying to understand recursion-types.  This might not be the best place to start, but I don't have a lot of just like, proper data types.
23:24:20 <hololeap> wait, Map does have a Functor instance! i was thinking of SEt
23:25:33 <dsal> Oh.  I thought you meant something specific to recursion-schemes
23:27:14 <sshine> with stack.yaml, is it possible to add an extra-deps package from github using a tag rather than a commit hash?
23:30:42 <hololeap> dsal: so, yeah, you could experiment with something like this: https://dpaste.com/CEJU47SDL
23:32:36 <dsal> Oh thanks, that's helpful.  I was getting a little lost at the F
23:34:59 <dsal> Huh.  I wonder why I wasn't deriving Foldable.
23:43:48 <hololeap> you can even derive Recursive and Corecursive: https://dpaste.com/CWZDFZV4H
