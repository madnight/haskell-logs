00:49:54 * hackage numhask-array 0.5.1 - n-dimensional arrays  https://hackage.haskell.org/package/numhask-array-0.5.1 (tonyday567)
01:27:40 <alc> exitWith :: ExitCode -> IO a 
01:27:43 <alc> what this a is?
01:28:43 <electrocat> any `a` :p
01:28:59 <electrocat> The type of `main` is technically also `IO a`
01:29:19 <alc> electrocat: wait, it's not IO ()?
01:29:25 <alc> main :: IO ()
01:29:43 <electrocat> if you make it `a` ghc won't complain
01:31:18 <alc> electrocat: but this type variable a need show up before return it, like f :: a -> b is not valid, f :: a->b->a is valid
01:31:50 <alc> electrocat: with forall, how this exitWith is defined?
01:32:06 <alc> every type variable has to come from somewhere
01:32:14 <electrocat> not exactly
01:32:30 <alc> like?
01:32:30 <electrocat> i don't now the exact reason, but i suspect it's because these functions exit
01:32:38 <electrocat> so techinally their value is bottom
01:32:42 <electrocat> which has any type
01:32:53 <Athas> Is there a standard type 'data AllEq a = AllEq a' that defines an Eq instance where all values are equal?
01:33:09 <alc> electrocat: that wouldn
01:33:33 <alc> that wouldn't be insane? 'cause IO () and IO Int and IO String are totally not same type
01:33:48 <electrocat> the point is that the type doesn't matter
01:33:51 <alc> exitWith can return IO () or IO String or IO Int?
01:33:56 <electrocat> because it won't produce a value
01:35:37 <electrocat> lets say exitWith returns IO String, and you try to do something with that string
01:35:50 <electrocat> that's type safe because the value will never be produced
01:36:44 <alc> electrocat: but that's not even possible, you can only return 0-255 in POSIX systems
01:37:16 <alc> you can't return a String to your system
01:37:31 <electrocat> the string won't be returned to the system, it will be returned to the program
01:38:30 <alc> ok
01:38:51 <electrocat> > 
01:38:53 <lambdabot>  <hint>:1:1: error: lexical error at character '\DEL'
01:39:09 <electrocat> > exitWith 0 >> return "String"
01:39:11 <lambdabot>  error:
01:39:12 <lambdabot>      Variable not in scope: exitWith :: Integer -> m a0
01:39:30 <electrocat> type of that expression is `IO String` while exitting
02:35:19 <alc> @let ml = [Just 3, Nothing]
02:35:20 <lambdabot>  Defined.
02:36:12 <alc> how to print that every element by order? fmap print ml is wrong
02:36:28 <beka> is there a standard way of dealing with the fact that haskell by default doesnt like `MonadReader Int a` as a constraint b/c of `Int`?
02:37:33 <beka> like, if I want to implement, say, an arithmetic+globalvars evaluator in a generic fashion, i might write   `eval :: MonadReader Int m => Expr -> m Int`   but haskell doesn't like this without extensions
02:38:34 <merijn> beka: The standard way is: 1) don't use it, or more commonly 2) just enable FlexibleContexts
02:38:40 <beka> one might modify Expr and go a little further to say, like,   `eal :: (Num a, MonadReader a m) => Expr a -> m a`   but..
02:39:02 <merijn> Or, just use ReaderT directly
02:39:05 <beka> merijn: ya, (2) for sure, but is there a more elegant solution? or is it just not something people do very often anyway?
02:39:19 <merijn> beka: What's inelegant about 2?
02:39:50 <beka> merijn: well, i mean maybe its fine! i dunno! but its an extension so maybe it's the sort of thing that people have good arguments against, etc.
02:40:18 <merijn> beka: FlexibleContexts is perfectly fine, the rules for typeclasses as specified by the Report are overly restrictive
02:40:34 <merijn> beka: Note that you're already (indirectly) using the MultiParamTypeClasses extension too
02:40:45 <beka> ya
02:40:51 <electrocat> FlexibleContexts should be enabled by default :p GHC is overly strict without it.
02:41:20 <merijn> electrocat: No, I think GHC's approach of defaulting to "Haskell as specified" (well, mostly, anyway) is the right way to go
02:41:54 <electrocat> I agree, I guess haskell should've been specified that way.
02:41:57 <merijn> beka: The problem is that without any major GHC competitors the motivation to standardise a new version of Haskell keeps getting stranded (see, repeated Haskell Prime failures in the past 10 years)
02:43:30 <electrocat> I just don't see why is was so strict in the first place, it doesn't make type inference harder
02:43:33 <electrocat> I wonder what the reason was
02:50:19 <merijn> electrocat: To be fair, it was standardised 22+ years ago, when we knew quite a bit less :p
02:53:03 <merijn> beka: Anyway, FlexibleInstances/FlexibleContexts are perfectly fine extensions to enable
02:54:33 <merijn> beka: Honestly, most extensions are perfectly safe (although some of those safe ones are unsafe in the sense that they'll tempt you into trying to do typelevel stuff that will your make your live hell :p)
02:55:19 <merijn> But I think Flexible* are probably the least controversial extensions possible, together with, like, ScopedTypeVariables
03:49:31 <tomjaguarpaw> Is there a typeclass that provides just the extract :: w a -> a part of Comonad?
03:55:07 <dibblego> I'd recommend a data type instead
04:00:54 * hackage opentelemetry 0.0.0.1 -   https://hackage.haskell.org/package/opentelemetry-0.0.0.1 (DmitryIvanov)
04:05:48 <fendor> can I compare the build-plan produced by stack and the build-plan produced by cabal?
04:17:36 <edwardk> Copointed
04:20:54 * hackage quiet 0.1 - Generic deriving of Read/Show with no record labels.  https://hackage.haskell.org/package/quiet-0.1 (JacobStanley)
04:29:46 <ladyfriday> is there a version of `span` which includes the first non-satisfying element, or do I need to handle that myself?
04:38:10 <alc> ll = ["abc", "efg" , "hij"]
04:38:29 <alc> how to get the element prefix with "ef" from ll?
04:40:11 <alc> l2 = fmap (isPrefixOf "ef") ll
04:40:37 <alc> i3 = elemIndex True l2
04:41:21 <olligobber> alc, filter (isPrefixOf "ef") ll
04:41:47 <alc> olligobber: right!
04:41:48 <olligobber> maybe need to use flip isPrefixOf
04:44:59 <ladyfriday> tail (concatMap (" " ++) listOfStrings) -- I feel like there's definitely a nicer way to do that, I can't find a function for it though - what am I missing? (ie. I want ["a", "b", "c"] -> "a b c")
04:45:21 <MarcelineVQ> ladyfriday: intersperse or intercalate
04:45:40 <MarcelineVQ> unwords would work for that example too
04:49:08 <ladyfriday> perfect, thank you
04:49:41 <ladyfriday> interestingly, having used all of those before I completely failed to find them ;)
05:00:45 <olligobber> ladyfriday, exact same thing has happened to me
05:14:24 * hackage laop 0.1.0.0 - An inductive matrix definition library à la LAoP  https://hackage.haskell.org/package/laop-0.1.0.0 (bolt12)
05:17:52 <Uniaika> thank god, finally someone who puts the diacritic on the 'a'
05:30:38 <w1n5t0n> hey all, what's the simplest way to get a string of N random digits?
05:31:52 <merijn> :t take 10 (randoms (mkStdGen 5)) :: [Int]
05:31:54 <olligobber> replicate N '4'
05:31:54 <lambdabot> [Int]
05:31:59 <merijn> > take 10 (randoms (mkStdGen 5)) :: [Int]
05:32:02 <lambdabot>  [7777369639206507645,5955775402155530247,1962392218752443914,-37061251645795...
05:32:41 <merijn> > take 10 (randomRs (0, 9) (mkStdGen 5)) :: [Int]
05:32:43 <lambdabot>  [1,1,9,0,6,7,6,8,8,9]
05:32:52 <olligobber> > take 20 $ (`mod` 10) $ randoms $ mkStdGen 5 :: [Int]
05:32:54 <lambdabot>  error:
05:32:54 <lambdabot>      • No instance for (Integral [Int]) arising from a use of ‘mod’
05:32:54 <lambdabot>      • In the expression: (`mod` 10)
05:33:02 <merijn> olligobber: That one is bad :)
05:33:13 <olligobber> merijn, probably
05:33:14 <merijn> olligobber: It's biased and ruins the uniformity of the distribution
05:33:47 <olligobber> I imagine it's for similar reasons as this:
05:33:49 <merijn> Then again, I'm not sure how well the properties of Random are :)
05:33:55 <olligobber> > 10^100 :: Int
05:33:57 <lambdabot>  0
05:34:27 <merijn> olligobber: Well, it's also because the number of unique Int values is not a multiple of 10
05:34:39 <merijn> olligobber: Therefore *some* values are (slightly) more likely than others
05:34:48 <olligobber> merijn, yes, it is 2^64
05:34:54 * hackage quiet 0.2 - Generic deriving of Read/Show with no record labels.  https://hackage.haskell.org/package/quiet-0.2 (JacobStanley)
05:35:04 <olligobber> and 2^64 divides 10^100
05:35:23 <merijn> If you care about randomness quality you probably wanna use mwc-random anyway
05:35:50 <merijn> w1n5t0n: There's also the generators from QuickCheck, depending on what you need said sequences for
05:35:56 <olligobber> I prefer `replicate N 4'
05:36:04 <w1n5t0n> what if I don't care about the distribution evenness but just want to make sure that two consecutive numbers are never the same?
05:36:30 <merijn> w1n5t0n: It's only about adjacent numbers? Or do you want unique permutations?
05:37:30 <merijn> You'd have to write something yourself, but it should be fairly easy with randoms/randomRs
05:37:51 <w1n5t0n> yeah it should be pretty simple, I'm just still wrapping my head around randomness in haskell
05:38:00 <w1n5t0n> thanks though, what you sent above does the trick for now
05:38:24 * hackage ghc-lib-parser 0.20200201 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200201 (shayne_fletcher)
05:38:26 <olligobber> you could take a random infinite list of digits, filter all repetitions, and then take N digits
05:38:27 <merijn> You can just use randomRs to generate an infinite list of 0-9 digits, then write a fold that filters out adjacent duplicates and then use take on that result to get the right length
05:38:33 <olligobber> ^
05:39:22 <merijn> w1n5t0n: Which part are you trying to grok? Random is (essentially) based on a PRNG like most other languages. The main difference is that in Haskell you don't really get to hide the PRNG seed/state
05:39:24 * hackage ghc-lib 0.20200201 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200201 (shayne_fletcher)
05:39:31 <merijn> (Well, unless you're in IO)
05:40:49 <olligobber> you could hide it with a state monad
05:42:22 <merijn> w1n5t0n: So StdGen just represents "the PRNG state" and generating a random value you gives you back the generated value and a new StdGen (i.e. the new PRNG state)
05:42:50 <w1n5t0n> yeah I get how it works, I'm just looking for best practices to actually use it in my programs
05:42:52 <Rembane> I'm very fond of the MonadRandom approach. https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html
05:42:56 <w1n5t0n> ie. without having to do much restructuring
05:43:52 <merijn> w1n5t0n: Well, randoms/randomRs generate infinite random lists, so if you just need a sequence of random values in a non-monadic setting, that might be good
05:44:31 <ladyfriday> is there a reason that Default isn't implemented for Bool? I'm sure there must be, I can't find anything from a quick google though
05:44:41 <merijn> ladyfriday: What would the default bool be?
05:44:51 <merijn> Also, Default is a godawful class and you shouldn't use...
05:45:17 <merijn> For exactly the reason of my previous question :p
05:46:54 * hackage replace-megaparsec 1.2.1.0 - Find, replace, and edit text patterns with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.2.1.0 (JamesBrock)
05:49:12 <ladyfriday> merijn: False, for the same reason the default for numeric types is 0
05:49:45 <merijn> ladyfriday: The fact that different people want different defaults for different types is the reason why Default is terrible
05:50:07 <MarcelineVQ> i.e. the default of a value should depend on the operation you're doing with it
05:50:08 <ladyfriday> notice I cunningly avoided any real reasoning :3
05:50:32 <merijn> ladyfriday: I noticed, hence why I reiterated
05:50:38 <MarcelineVQ> If it should exist at all. this is what things like monoid capture
05:52:21 <ladyfriday> I don't really have strong feelings about it, it just seemed like an odd omission
06:06:16 <maerwald> 0, in some contexts is success, in others not :)
06:06:30 <maerwald> maybe 1 would be a better default
06:07:09 <maerwald> becuase dividing by the default would be safer
06:07:38 <maerwald> but then again, 23 is also a safe default
06:09:06 <maerwald> Default is nice for initializing data with random defaults, where you know it'll be filled with reasonable values later
06:10:58 <freeside> the nice thing about standards is how many there are to choose from
06:11:34 <drew__b> what's a good web framework to use if i want to do user auth?
06:11:50 <drew__b> it seems like it's first class in yesod, but that framework makes a lot of decisions for me
06:12:11 <drew__b> i have experience with servant, but their docs say to use basic auth (which seems bad if you're speaking to a client)
06:12:54 <maerwald> snap is another option
06:14:06 <drew__b> yeah i've heard that. It seems like that repo is not updated very often
06:14:16 <drew__b> not sunsetted, but seems like it's close to it?
06:14:23 <merijn> Why?
06:14:25 <drew__b> is that incorrect?
06:14:40 <maerwald> it is incorrect
06:14:42 <merijn> I don't get this idea of "repo isn't updated often" == unused/deprecated
06:14:44 <drew__b> https://github.com/snapframework/snap/commits/master
06:14:55 <maerwald> but the last release is quite a while ago
06:15:08 <drew__b> well it could indicate there isn't as much contribution as other projects
06:16:00 <drew__b> i'm open to all suggestions though. Do you have experience with snap?
06:16:16 <drew__b> another helpful mod in the haskell discord mentioned snap as well
06:16:25 <drew__b> talked about an auth snaplet
06:17:07 <merijn> I don't really do webdev, so my opinion on which framework is rather useless. I just get confused by the assumption that "infrequent updates" == "unused", hell, one of the libraries I took over maintenance for hadn't been updated in 9 years, because it still worked fine :)
06:17:42 <freeside> stability is due to a couple things ... fewer bugs, and less bit-rot
06:17:49 <drew__b> i mean if it were something like MTL, i wouldn't care when it was updated as long as it worked on my version of GHC
06:18:29 <maerwald> if there are no new feature and no redesign of API, then the only thing that remains is fixing bugs and updating deps
06:18:30 <drew__b> but in other languages, certain web frameworks tend to "win" in the sense that they have overwhelming community support
06:18:38 <drew__b> but in haskell that doesn't seem to be the case
06:18:53 <drew__b> yeah that's true @maerwald
06:18:56 <merijn> drew__b: I think that's also because large parts of the community aren't doing webdev
06:19:02 <drew__b> definitely
06:19:36 <maerwald> but that's the only thing that drives in the bucks $$$ ;P
06:20:21 <merijn> maerwald: Have you told Standard Chartered and the other UK Bank, I'm not sure they know... ;)
06:21:08 <maerwald> I know, they are looking for quant devs
06:21:57 <Clint> yesod moves a lot faster than snap or happstack
06:22:11 <maerwald> And is definitely a *framework*
06:23:26 <maerwald> I think chrisdone deleted the repo, but at some point he rewrote lpaste with yesod and it was like ~150 LOC only (a full pastebin service)
06:24:16 <drew__b> @Clint can you elaborate?
06:24:16 <lambdabot> No module "can you elaborate?" loaded
06:24:34 <Clint> drew__b: in what way?
06:24:37 <drew__b> you mean the performance is better?
06:24:48 <drew__b> or that the project gets more features faster?
06:24:52 <Clint> the latter
06:25:01 <drew__b> yeah snoyman's stuff seems to be top notch
06:25:13 <drew__b> it just seems like way more of a buy-in than other frameworks
06:25:19 <drew__b> and i'm not sure i care too much for persistent
06:25:31 <drew__b> it's a lot of dark magic that I'm not familiar with tbh
06:25:51 <mniip> Any haskell ppl at fosdem by the way?
06:26:26 <maerwald> drew__b: it's a pattern. Most of his libraries are very opinionated abstractions. Very few have "library" character
06:26:37 <maerwald> You either love or hate it
06:26:41 <mniip> Hmm I guess if anyone, they wouldnt be able to reply right now..
06:27:14 <drew__b> conduit seems like it's not very controversial
06:27:17 <drew__b> but yeah, i see what oyu mean
06:27:19 <maerwald> it is
06:27:54 * hackage laop 0.1.0.1 - An inductive matrix definition library à la LAoP  https://hackage.haskell.org/package/laop-0.1.0.1 (bolt12)
06:27:59 <merijn> drew__b: Ok, I can weigh on this part
06:28:12 <merijn> drew__b: You should avoid persistent
06:28:40 <merijn> mniip: ongy was just asking me in offtopic, so I assume he is ;)
06:30:52 <ph88> is there a typeclass for all datatypes that are guaranteed to use pinned memory that is safe to pass to C ?
06:31:07 <merijn> ph88: Nope
06:34:24 * hackage ghc-lib-parser-ex 0.20200201 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200201 (shayne_fletcher)
06:35:35 <ph88> merijn, what about this class https://hackage.haskell.org/package/memory-0.15.0/docs/Data-ByteArray.html#t:ByteArrayAccess ??
06:36:30 <merijn> Dunno, haven't used it
06:37:09 <ph88> i thought this class gave that guarantee, but actually it doesn't say so in the docs and also because it can use String i find it doubtful that it would only use pinned memory
06:38:24 * hackage ghc-lib-parser-ex 0.20200201.1.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200201.1.0 (shayne_fletcher)
06:39:24 * hackage opentelemetry 0.0.0.2 -   https://hackage.haskell.org/package/opentelemetry-0.0.0.2 (DmitryIvanov)
06:49:07 <merijn> ugh...so does anyone have a decent style for linewrapping function calls with lots of arguments? I can't seem to find one that works for me >.>
06:52:39 <Uniaika> merijn: pass a list/map of arguments to the function, benefit from the fact that you can write them on several lines
06:52:42 <Uniaika> win-win
06:52:57 <merijn> Uniaika: That only works if they're the same type
06:57:47 <Uniaika> damnit, indeed
06:57:52 <Uniaika> works better in Erlang :/
07:04:23 <alc> https://paste.ubuntu.com/p/ZYsRBB45ys/
07:04:33 <alc> why line 13, parse error?
07:04:52 <alc> parse error on input `let'
07:07:09 <Uniaika> alc: you forgot to add a do to the else
07:07:13 <alc> ghc doesn't support multiple let in do notation?
07:07:51 <Uniaika> I don't know about that particular point (although I think yes it does support it)
07:08:24 <alc> you're right
07:08:52 <alc> multiple monadic actions need to be in one do notation
07:16:22 <merijn> alc: Also, you can bind multiple variables per let...
07:16:29 <merijn> So you don't need the repeated let
07:16:33 <drew__b> is there no more #haskell-stack channel?
07:18:24 * hackage ghc-typelits-presburger 0.3.0.0 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  https://hackage.haskell.org/package/ghc-typelits-presburger-0.3.0.0 (HiromiIshii)
07:19:24 * hackage singletons-presburger 0.3.0.0 - Presburger Arithmetic Solver for GHC Type-level natural numbers with Singletons package.  https://hackage.haskell.org/package/singletons-presburger-0.3.0.0 (HiromiIshii)
07:22:24 * hackage neat-interpolation 0.3.2.6 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.3.2.6 (NikitaVolkov)
07:23:17 <sm> drew__b: what makes you say that ?
07:31:14 <drew__b> i can't seem to join it
07:31:54 <alpha22> :t id
07:31:56 <lambdabot> a -> a
07:33:54 <geekosaur> it's there and has people in it
07:34:11 <sm[m]> drew__b: I can.. maybe you need to be registered with NickServ ?
07:34:47 <sm[m]> (if so, that should be changed)
07:35:22 <MarcelineVQ> most clients will tell you why you can't join a channel, if you can't, so watch out for that
07:36:11 <sm[m]> yes but IME it's always in a hidden background window
07:37:21 <MarcelineVQ> yes, though typically one that gets colored or flashes to get your attention
07:37:54 * hackage neat-interpolation 0.4 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.4 (NikitaVolkov)
07:38:35 <sm[m]> ha I wish. erc & Riot user here
07:41:05 <drew__b> @sm[m] that was it
07:41:06 <lambdabot> Unknown command, try @list
07:45:54 <albet70> hi
07:56:13 <heath> https://github.com/ocramz/xeno/ needs a maintainer
07:56:51 <merijn> heath: Consider mailing haskell-cafe?
07:57:35 <heath> oh, I missed the PR. sorry about that. dmitry kyrlov is taking over
08:04:24 * hackage type-natural 0.8.3.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.8.3.0 (HiromiIshii)
08:25:54 * hackage brick 0.51 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.51 (JonathanDaugherty)
09:06:24 * hackage type-natural 0.8.3.1 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.8.3.1 (HiromiIshii)
09:08:32 <EvilTerran> hey folks - got a logic puzzle for you
09:09:28 <EvilTerran> I've been trying to prove that the monad laws in terms of bind (return x >>= f = f x; m >>= return = m; (m >>= f) >>= g = m >>= (\x -> f x >>= g)) are equivalent to those in terms of join (join . return = id; join . fmap return = id; join . join = join . fmap join)
09:10:11 <d34df00d> Just write that in Idris and follow the holes.
09:10:23 <EvilTerran> I got the two identity laws pretty easily, and managed to prove that associativity in terms of bind implies that in terms of join, but I got stuck going the other way on associativity
09:11:07 <EvilTerran> d34df00d, I must admit I've never used Idris, but that's an interesting idea
09:12:06 <merijn> Or all the way to Coq ;)
09:14:37 <mniip> Hey d34df00d
09:14:44 <d34df00d> mniip: sup.
09:15:00 <mniip> Any chnace you're at fosdem?
09:15:46 <d34df00d> Nah, saving my corporate-sponsored trips for other stuff.
09:15:55 <mniip> Kk
09:15:59 <d34df00d> Say hi to all the cool folks there for me.
09:16:05 <mniip> Ok
09:16:42 <mniip> There was a guy doing a talk about monads i n python
09:17:02 <mniip> That was... oddly enough not bad
09:17:30 <d34df00d> Were there burritos as a handout?
09:17:51 <mniip> No :(
09:18:03 <electrocat> Free burrito o.O
09:18:07 <electrocat> see what i did there?
09:18:17 <d34df00d> Freer burrito!
09:18:20 <mniip> Free as in speech
09:36:54 * hackage nix-diff 1.0.8 - Explain why two Nix derivations differ  https://hackage.haskell.org/package/nix-diff-1.0.8 (GabrielGonzalez)
09:44:24 * hackage hie-bios 0.4.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.4.0 (fendor)
09:56:31 <monochrom> curry burrito = applicative
09:57:10 <monochrom> http://currito.com/
10:21:14 <maerwald> is it gluten free?
10:34:32 <tom__> What is a good library for parsing env variables for a servers config, i.e db connection params for a servant app
10:53:03 <dmj`> tom__: envy
10:53:05 <dmj`> @package envy
10:53:06 <lambdabot> http://hackage.haskell.org/package/envy
10:53:35 <tom__> Already just started using it before I saw your reply hehe
10:53:37 <tom__> looks great
10:53:49 <dmj`> tom__: sweet
10:54:36 <tom__> dmj`: Do you know of a good way of propagating env vars from one environment to another remote machine via ssh
10:55:16 <tom__> Currently I am using systemd and have a env file linked to that within my remote ec2
10:55:37 <dmj`> tom__: when I deploy the vars are either in a docker file, or set in the environment inside a systemd unit, or globally in the root users .bashrc
10:55:51 <GreyFaceNoSpace> hey guys
10:55:52 <dmj`> usually systemD though
10:55:57 <dmj`> GreyFaceNoSpace: hey
10:56:10 <tom__> dmj`: thanks
10:56:27 <tom__> dmj: Do you find packaging your binary in docker helpful?
10:56:40 <tom__> I struggle to understand the value for a statically linked binary
10:56:53 <dmj`> tom__: normally in my repo I have a bunch of different config files locally, and then when I deploy only the ones marked prod get put into the systemD config
10:56:53 <tom__> when it comes to deployment that is
10:57:16 <tom__> cool
10:57:40 <dmj`> tom__: I don't use statically linked haskell binaries (you can't because glibc can't be truly statically linked), but now with nix you can use musl
10:58:13 <dmj`> tom__: so that's an option, but using nix for deployments will copy the closure of dependencies your package requires, making them available at runtime
10:58:37 <mpickering> Anyone know of a function converting a `Data.Graph` graph into a dot graph?
11:01:12 <dmj`> mpickering: if you use fgl there's fgl-visualize
11:03:16 <GreyFaceNoSpace> let t = [x|x<- length(b !! i),i <- [0..(length b) - 1]]    can someone help me figure out how to fix this? i am still trying to learn haskell. says i is out of scope/
11:03:31 <mpickering> right but I don't :) I can write it myself but I find it hard to believe it doesn't already exist
11:04:07 <GreyFaceNoSpace> b is a list of lists and i am trying to store the length of each individual list in t
11:04:12 <glguy> GreyFaceNoSpace: reorder things so that i <- comes to the left of its uses
11:04:43 <dmj`> mpickering: yea a bit surprising
11:07:16 <GreyFaceNoSpace> glguy, still not working with this : let t = [x| i <- [0..(length b)-1], x <- length (b !! i) ]
11:07:46 <GreyFaceNoSpace>  Couldn't match expected type ‘[t]’ with actual type ‘Int’
11:09:24 <nshepperd> today's fun trick: using Compose IO IO to write two-step computations
11:10:07 <GreyFaceNoSpace> i dont understand whats wrong with my logic?
11:10:10 <Mrbuck> It is really dissapointing that haskell community never developed a good frameworks for statistics/datascience or even scientific computation
11:10:45 <nshepperd> outer IO does some kind of set up, producing inner IO which executes the thing
11:14:45 <nshepperd> Compose lets you combine these Applicatively, resulting in IO (IO a) which does all the set up steps first before proceeding to the inner steps
11:15:45 <nshepperd> GreyFaceNoSpace: the thing to the right of <- in that needs to be a list
11:16:09 <GreyFaceNoSpace> nshepperd yes thank you i fixed it
11:16:28 <nshepperd> cool
11:19:19 <tom__> dmj`: Thanks, how would you write a getEnv function here? https://pastebin.com/raw/3cFxjWkN
11:19:42 <tom__> Also kinda confused about this comment in the Readme:    -- unsetEnvironment (toEnv :: EnvList ConnectInfo)  -- remove when done
11:20:36 <tom__> Does that remove the environment variables the actual process env i.e outside of the Haskell runtime (sorry linux noob)
11:22:32 <dmj`> If you unset it, it won’t be usable in that process any longer.
11:22:45 <dmj`> decodeEnv shouldn’t need any arguments
11:23:06 <tom__> ah right 
11:23:46 <tom__> Sorry for the dumb question
11:24:08 <tom__> so decodeEnv *was* my getEnv function. Awesome library :)
11:28:07 <tom__> dmj`: Say my env consists of the product type for the postgres params and other stuff say a stripe key.
11:28:32 <tom__> How would you get around the need to nest record types
11:28:34 <dmj`> tom__: I wrote the initial version in 2 days, then glguy rewrote it in like 2 mintes
11:29:02 <dmj`> tom__: nesting should be fine
11:29:06 <tom__> for someone reason in my head nested records should be avoided
11:29:09 <tom__> is that false? 
11:29:15 <tom__> Dont know where I got that idea from
11:29:23 <dmj`> tom__: nah its kosher
11:29:28 <Rembane> tom__: They are a bit messy to work with, but otherwise they are fine. 
11:29:40 <Rembane> tom__: With lenses I don't think about records at all. 
11:29:55 <dmj`> tom__: Give each record a FromEnv, and it will recursively call FromEnv on fields in the nesting that have that instance
11:30:09 <dmj`> and GHC will complain otherwise
11:30:33 <dmj`> GHC.Generics is the most underrated feature of Haskell and the community has only tapped like 10% of its potential
11:30:57 <dmj`> No reason we couldn't have a Ruby on Rails framework built with just GHC.Generics
11:36:24 * hackage adjunction 0.0.0.0 - See README for more info  https://hackage.haskell.org/package/adjunction-0.0.0.0 (MatthewFarkasDyck)
11:44:36 <tom__> dmj`: Do I need to the FromEnv instances if I am never going to try and write to my process's environment 
11:45:04 <dmj`> tom__: yea, you only need a ToEnv to write to it
11:45:16 <dmj`> similar to aeson
11:52:19 <tom__> dmj`: Sorry to be a pain but what is the correct way of doing this?
11:52:19 <tom__> https://pastebin.com/tkgbW58y
11:52:37 <tom__> Also why use a Word16 for the port and not an Int in the example?
11:54:06 <erisco> tom__, a Word16 exactly matches the port range, is my guess
11:54:41 <tom__> erisco: Had a suspicion it was that so just checking
11:54:43 <geekosaur> it's what all network related stuff uses for ports, because of the underlying API
11:54:58 <geekosaur> which perhaps should be hidden, but Word16 is still the correct range, so
11:55:36 <geekosaur> (well, Word16 without zero, but we can't represent that sanely as a type)
11:56:47 <geekosaur> as to the other, I'm not even sure what it's trying to do. but fromEnv is given a parameter everywhere it's used except there
11:58:39 <dmj`> tom__: instance FromEnv Env where fromEnv _ = Env <$> fromEnv Nothing <*> fromEnv Nothing
11:58:48 <dmj`> the Nothing is the default I guess, that was added by someone
12:01:02 <tom__> Thanks
12:01:21 <dmj`> tom__: kind of ugly, didn't used to be like that
12:01:28 <tom__> I guess I was confused about how I am going from a list of strings to a nested data structure but then I realised its just like aeson
12:01:50 <pleasehelpme1234> Hi I'm just starting with haskell could anyone give me a hand with something?
12:01:59 <dmj`> pleasehelpme1234: sure
12:02:08 <dmj`> tom__: yea, tries to be ;)
12:02:29 <pleasehelpme1234> How do you test your program? Let's say I have something like this:
12:02:36 <pleasehelpme1234> checksum :: Int->Int->Int->Boolchecksum a b c = a + b == c
12:02:42 <pleasehelpme1234> how do I run this?
12:03:04 <pleasehelpme1234> I tried ghc -o ex1a ex1a.hs and it says IO action main is not defined
12:03:25 <pleasehelpme1234> answers on reddit say to put something like "module foo where" but that gives me another error
12:03:36 <dmj`> pleasehelpme1234: main = print $ checksum 1 2 3
12:03:46 <dmj`> pleasehelpme1234: if you don't specify a module, Main is assumed
12:04:02 <dmj`> pleasehelpme1234: and Main requires a main :: IO () function to be present
12:04:36 <MarcelineVQ> it would be a good idea to fire up  ghci  and  :load ex1a.hs  since then you can play with it interactively as well  and your source file and be reloaded easily via  :r
12:04:40 <Duality> hi all
12:04:45 <Duality> i am learning haskell
12:04:52 <Duality> and i am learning about lists
12:05:05 <pleasehelpme1234> So it just compiled it but didn't print the result
12:05:13 <pleasehelpme1234> dmj`
12:05:25 <dmj`> pleasehelpme1234: can you paste your code in a gist and put the link here
12:05:26 <tom__> dmj`: Strange, my example doesn't throw an error if you fail to supply the stripeSecret env var?
12:05:33 <Duality> and you can do: init [1, 2, 3] and it would give back [1, 2]
12:05:46 <Duality> that is fine but i am wondering why is it called init?
12:05:55 <dmj`> tom__: what's the value for it?
12:06:00 <Duality> i am trying to make a connection here in my brain :)
12:06:04 <erisco> Duality, short for "initial"
12:06:18 <Duality> erisco: why is it initial though
12:06:30 <geekosaur> initial and last are related the way head and tail are related, but reversed
12:06:55 <geekosaur> that is, head gives you the first element, tail everything else; so last gives you the last eleemnt, and initial everything else
12:07:22 <Duality> i know what the functions do that is fine :) but i am just curious why it is called init/initial
12:07:25 <erisco> And all of them are heinous :P
12:07:31 <Duality> heinous?
12:07:42 <dmj`> means bad
12:07:48 <MarcelineVQ> pleasehelpme1234: did you run your compiled program?
12:07:48 <geekosaur> mumble mumble naming mumble hardest problem in CS mumble
12:07:58 <dmj`> geekosaur: :)
12:08:03 <MarcelineVQ> ./ex1a
12:08:07 <Duality> erisco: why are they bad
12:08:21 <pleasehelpme1234> oh that's how you do it 
12:08:23 <pleasehelpme1234> thanks
12:08:24 <erisco> Duality, head and tail are partial, and init and last are slow
12:08:40 <Duality> i haven't learned about that yet
12:08:47 <dmj`> Duality: its just non intuitive naming as well
12:09:12 <MarcelineVQ> pleasehelpme1234: yeah but there's faster ways to go about things, in particular by doing your testing of checksum in ghci
12:09:29 <pleasehelpme1234> like in the terminal?
12:10:23 <erisco> Duality, one day you'll ask why we have a type called Joker and another called Clown
12:10:25 <MarcelineVQ> yes by typing  ghci  and then you would  :load ex1a.hs  which makes the things in ex1a.hs available to you, and your source file can be reloaded easily via  :r
12:10:32 <Duality> erisco: oh i see partial is a function that has undefined result/behaviour for certain input cases?
12:10:59 <erisco> Duality, and the answer is a Stealer Wheeler song
12:11:36 <tom__> dmj`: Not sure I understand  but "stripe_secret" 
12:11:40 <erisco> Duality, yes, so you will see with all of them they do not like empty lists
12:12:00 <fragamus_> which sortWith should I use for my certain to be not empty list
12:12:02 <dmj`> tom__: if it doesn't fail, then a value was retrieved for it, can we print that value
12:12:26 <Duality> erisco: and what do you meen by slow? like they take a lot of time for certain cases?
12:12:30 <pleasehelpme1234> MarcelineVQ you are my saviour I don't know why but I can never work out how to test programs in new languages hahaha. Thanks a lot that's gonna be very useful
12:13:08 <erisco> Duality, init and last both require traversing the whole list. In the case of init, it also has to reallocate the whole list spine, save the last element.
12:13:16 <geekosaur> lists are linked lists, not vector or array like things
12:13:54 <erisco> So, these are functions I'd use in a pinch, or on the REPL
12:13:57 <geekosaur> a list cell is either [] or a pair of pointers, one to an element, the other to the next list cell
12:15:25 <geekosaur> so lists are slow in general
12:15:42 <erisco> but they're so lovely to program with
12:16:15 <tom__> dmj`: Thanks we got there, I was being silly I had left my parser's type annotation specialised to DBConfig instead of Env so the stripeSecret wasn't being parsed at all
12:16:17 <tom__> :)
12:16:25 <erisco> Treat them like chocolate. Good in small amounts.
12:16:29 <dmj`> tom__: *phew* :)
12:16:43 <dmj`> thought my shi* was broke
12:16:45 <tom__> hehe yay
12:17:54 <mawk> hi
12:19:54 * hackage neat-interpolation 0.5 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.5 (NikitaVolkov)
12:21:41 <dmj`> mawk: hi
12:24:09 <tom__> With Servant is there a way of abstracting out the AuthResult Claim{..} from each argument to your authenticated handlers and instead just have a specific field inside the claim?
12:25:28 <mawk> I like maths, what is a good tutorial to learn haskell
12:25:44 <mawk> I had numerous CS classes too
12:26:08 <mawk> a friend recommended "real world haskell"
12:26:34 <dmj`> mawk: https://www.seas.upenn.edu/~cis194/fall16/
12:26:51 <mawk> thanks
12:27:05 <dmj`> real world haskell I'd do after you got the basics
12:27:20 <dmj`> @typeclassopedia is good too
12:27:21 <lambdabot> Unknown command, try @list
12:27:27 <dmj`> @google typeclassopedia
12:27:29 <lambdabot> http://www.google.com/url?q=https://wiki.haskell.org/Typeclassopedia
12:27:29 <lambdabot> Title: Уведомление о переадресации
12:27:30 <mawk> I did some caml before, and wrote a compiler for a ml-inspired language
12:27:38 <mawk> but no idea how that helps with haskell syntax
12:28:07 <dmj`> mawk: it probably doesn't help w/ haskell syntax, although some things might similar
12:28:33 <mawk> this is the language for which I did the compiler : https://www.lrde.epita.fr/~tiger/tiger.html
12:28:34 <dmj`> mawk: quick syntax run down here: https://learnxinyminutes.com/docs/haskell/
12:28:35 <mawk> I keep painful memories
12:28:49 <mawk> I started since a week with "learn you a haskell" but I don't find it very good
12:28:52 <mawk> thanks
12:29:20 <dmj`> mawk: you could rewrite your compiler in Haskell :)
12:29:30 <mawk> lol
12:29:36 <mawk> it was C++
12:32:18 <solonarv> Duality: mot "undefined behavior" in the C sense, "partial" just means "may fail to return a value" - by looping forever, or throwing an error/crashing instead
12:32:58 <dmj`> mawk: you'd learn a /lot/ of Haskell if you wrote a compiler
12:33:16 <dmj`> mawk: haskell is great for lexing / parsing
12:33:26 <mawk> yes I figure
12:33:29 <dmj`> mawk: and for represnting ASTs and rewriting them
12:34:13 <mawk> I see
12:34:19 <mawk> I'm interested in more practical stuff too, like how it could improve locking or concurrency or whatever
12:34:29 <mawk> but let's learn it first
12:34:56 <geekosaur> @where parconc
12:34:57 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
12:35:18 <mawk> nice
12:37:35 <boxscape> I need to make a roughly million element long ByteString, out of segments with length of roughly 1000. For the creation of those segments I need some sort of random access data structure. What's the best way to go about this? I was thinking have some sort of array for the segments, make strict bytestring builders out of them and then mappend those?
12:38:24 * hackage arduino-copilot 1.4.0 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.4.0 (JoeyHess)
12:38:49 <DigitalKiwi> mawk: they have that book in ML
12:39:06 <boxscape> hmm, although technically it doesn't *need* to be a bytestring, a ForeignPtr Word8 would also work...
12:39:16 <boxscape> maybe that's a better way to go about this
12:41:54 * hackage Fin 0.2.9.0 - Finite totally-ordered sets  https://hackage.haskell.org/package/Fin-0.2.9.0 (MatthewFarkasDyck)
12:42:30 <boxscape> Is there a good way to get a 2D array that I can get a ForeignPtr to?
12:43:50 <solonarv> boxscape: a bytestring is basically just a ForrignPtr Word8 anyway
12:43:55 <solonarv> (and a length + offset)
12:45:04 <boxscape> solonarv hm, well I noticed a minute ago that the gloss function that takes a ForeignPtr is O(1), whereas the function that takes a ByteString is O(n), so unless there's a way to get a ForeignPtr from a ByteString in O(1), it would still be better to use that function, I think
12:45:37 <solonarv> what gloss functions are those?
12:46:12 <boxscape> solonarv  and bitmapOfByteString
12:46:14 <boxscape> whoops
12:46:20 <boxscape> bitmapsOfForeignPtr
12:46:22 <boxscape> is the first one
12:46:31 <boxscape> s/bitmaps/bitmap
12:47:10 <solonarv> ah, the difference is in the description
12:47:47 <solonarv> bitmapOfForeignPtr *uses* the data pointed at by the ForeignPtr, bitmapOfByteString copies it
12:47:58 <boxscape> right, that makes sense
12:48:08 <solonarv> gotta admit I have no idea why they would differ in that way...
12:48:43 <solonarv> anyway, there are functions in Data.ByteString.Internal to convert between ByteString and the (ForeignPtr Word8, Length, Offset) triple
12:48:52 <boxscape> ah, good to know
12:48:58 <boxscape> I'll take a look
12:49:40 <solonarv> also, scroll to the bottom for my favorite doc comment of all
12:49:57 <boxscape> hah, yeah, I've seen that before :D
12:53:44 <tom__> Is this correct behaviour for addJulianMonthsClip in the Time library? if I add a month to today, 2020-02-02 then I'm getting 2020-03-03
12:54:01 <boxscape> Hm, well, using ByteString.Internals toForeignPtr and using the corresponding gloss function reduces the image creation from half a second to imperceptible, so that's nice
12:57:37 <boxscape> though that leaves me with my original question - what should I use if I need a 1D array I want to convert into a ByteString builder?
12:58:27 <solonarv> each element turns into one chunk of bytestring, right?
12:58:57 <solonarv> I would probably default to Vector
12:59:03 <boxscape> okay
13:00:25 <boxscape> does it make sense to use an unboxed vector here?
13:00:38 <solonarv> depends, what is the element type?
13:00:47 <boxscape> Word8
13:00:53 <solonarv> then yes, it makes sense
13:00:55 <boxscape> ok
13:01:00 <boxscape> thanks
13:07:30 <tom__> lesson learned: Don't use the calendar from the Roman era your customers probably arent
13:09:24 * hackage vector 0.12.1.2 - Efficient Arrays  https://hackage.haskell.org/package/vector-0.12.1.2 (CarterSchonwald)
13:12:04 <mawk> israel customers ?
13:15:20 <geekosaur> they were using julian vs. gregorian
13:15:54 * hackage laop 0.1.0.2 -   https://hackage.haskell.org/package/laop-0.1.0.2 (bolt12)
13:22:52 <geekosaur> that said, calendars from the other end of the Roman era would have lacked July and August…
13:29:24 * hackage laop 0.1.0.3 -   https://hackage.haskell.org/package/laop-0.1.0.3 (bolt12)
13:48:15 <tom__> Israel use Julian? Interesting.
13:51:08 <tom__> If you are using Servant how do you return an errors list in your JSON responses for every JSON endpoint?
14:05:24 * hackage ghc-lib-parser-ex 8.8.4.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.4.0 (shayne_fletcher)
14:24:54 * hackage mongoDB 2.6.0.1 - Driver (client) for MongoDB, a free, scalable, fast, documentDBMS  https://hackage.haskell.org/package/mongoDB-2.6.0.1 (VictorDenisov)
14:36:39 <GreyFaceNoSpace> hey guys. back with another question. sorry if i am boring you or my questions are too newby.   let f u = [x| ((x:xs):zs) <- u]    has a type of f:: [[[t]]] -> [t] ... can someone explain how? I know why we get [t] as an output. but how did we infer that the input list is [[[t]]].
14:37:14 <GreyFaceNoSpace> do the parentheses affect the type of ((x:xs):zs)
14:37:15 <GreyFaceNoSpace> ?
14:37:23 <GreyFaceNoSpace> if so, why?
14:37:45 <dmj`> tom__: depends on the response code
14:37:50 <erisco> GreyFaceNoSpace, what is the type of x, xs, and zs?
14:38:01 <GreyFaceNoSpace> they are polymorphic
14:38:12 <GreyFaceNoSpace> so t 
14:38:26 <erisco> They're not that polymorphic
14:38:45 <GreyFaceNoSpace> well i thought it was a list of type t
14:38:54 <erisco> xs for example must be a list, and so must zs
14:39:05 <GreyFaceNoSpace> but the compiler says its [[[t]]]
14:39:38 <GreyFaceNoSpace> why? why cant it just be that xs and zs are of the same type and concatenated to []
14:39:45 <GreyFaceNoSpace> just like 1:2:3:[]
14:39:46 <erisco> :t (:)
14:39:48 <lambdabot> a -> [a] -> [a]
14:39:54 <erisco> because the second argument to : is a list
14:40:06 <GreyFaceNoSpace> how did we know that?
14:40:13 <erisco> because that is what the compiler said the type was
14:40:18 <GreyFaceNoSpace> oh
14:40:27 <GreyFaceNoSpace> i am asking if i am trying to do the compiler's job
14:40:31 <GreyFaceNoSpace> and infer the types myself
14:40:40 <GreyFaceNoSpace> how can i do that?
14:40:50 * erisco thinks of McBride again
14:41:16 <erisco> you can infer the types yourself, yes, and is typically what the programmer is doing to make sense of their program
14:41:38 <erisco> I inferred xs and zs must be lists, for example
14:42:05 <GreyFaceNoSpace> ok...so x:xs:zs .... to me x and xs are the first to elements of the list and zs is the tail
14:42:20 <GreyFaceNoSpace> two* elements of the list
14:42:21 <solonarv> you can't infer the type of (:) out of nowhere, you have to look it up
14:42:21 <erisco> (x:xs):zs is not the same as x:xs:zs
14:42:33 <GreyFaceNoSpace> erisco, ah
14:42:35 <solonarv> when you do this lookup, you learn that (:) :: a -> [a] -> [a]
14:42:47 <jackdk> dminuoso: I think I was tinkering with you on this before the weekend started. I have found success! By using argDict instead of the Has' class machinery, I can get to a (Show a) instead of (Show (Identity a)): https://www.irccloud.com/pastebin/agJqnKXj/DProduct.hs
14:44:11 <GreyFaceNoSpace> i still dont get it
14:44:29 <GreyFaceNoSpace> can someone just slowly explain to me how i can infer the type here. step by step
14:44:31 <GreyFaceNoSpace> so i can learn it
14:45:52 <GreyFaceNoSpace> (:) :: a -> [a] -> [a]   ... this means that it gets two arguments. 1 is of type a and the other is of type a list
14:46:30 <GreyFaceNoSpace> with this understanding. it must mean that x is of type a and xs is of type [a] and zs is of type [[a]] 
14:46:48 <erisco> lets start with  u :: t1  and you tell me if you can figure out some way to refine  t1
14:47:30 <erisco> way to do that is to see how  u  is used
14:47:48 <erisco> is there a place that  u  is used that requires it to have a more specific type than "any type"?
14:47:57 <GreyFaceNoSpace> u is a list that has many (x:xs):zs
14:48:07 <erisco> so then  u :: [t2]
14:48:16 <GreyFaceNoSpace> (x:xs):zs is of type [[t]] 
14:48:18 <erisco> can you refine  t2?
14:48:25 <GreyFaceNoSpace> therefor u must be of type [[[t]]]
14:48:44 <erisco> that's all the compiler is doing for you
14:48:45 <GreyFaceNoSpace> why did u decide that u has a different type of data?
14:48:46 <GreyFaceNoSpace> t2
14:49:13 <GreyFaceNoSpace> or did you want to emphasize that the list of u has different dimensions ?
14:49:26 <erisco> you told me  t2 ~ [[t]]
14:49:32 <GreyFaceNoSpace> oh
14:49:33 <GreyFaceNoSpace> ok
14:49:43 <GreyFaceNoSpace> i think i get it now
14:49:49 <GreyFaceNoSpace> can you give me some more examples?
14:49:56 <erisco> :t curry id
14:49:58 <GreyFaceNoSpace> i can exercise on
14:49:58 <lambdabot> a -> b -> (a, b)
14:50:20 <GreyFaceNoSpace> this is a function that takes 2 arguments a and b and returns a tuple of a and b
14:50:35 <erisco> what is the type of curry and id in that expression?
14:51:01 <erisco> :t curry
14:51:02 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:51:03 <erisco> :t id
14:51:04 <lambdabot> a -> a
14:51:06 <erisco> that is the starting point
14:51:12 <GreyFaceNoSpace> uhh
14:52:19 <GreyFaceNoSpace> what is this
14:52:19 <GreyFaceNoSpace> lol
14:52:42 <GreyFaceNoSpace> f g u v = g (u,v) ?\ 
14:53:08 <GreyFaceNoSpace> f takes a function g and two args u and v and applies g to u and v ?
14:53:19 <GreyFaceNoSpace> as a tuple?
14:53:33 <GreyFaceNoSpace> is that correct?
14:53:38 <erisco> yes
14:53:49 <ChaiTRex> GreyFaceNoSpace: that's what that function definition says, yes.
14:54:16 <GreyFaceNoSpace> can i get some more please? just like these examples you generated?
14:54:35 <ChaiTRex> @src curry
14:54:35 <lambdabot> curry f x y = f (x, y)
14:54:43 <ChaiTRex> @src uncurry
14:54:43 <lambdabot> uncurry f p = f (fst p) (snd p)
14:55:21 <GreyFaceNoSpace> thank you guys
14:55:40 <GreyFaceNoSpace> for being patient with me
14:56:13 <d34df00d> Alright, i want something funny again and I can't even properly formulate the question.
14:57:04 <solonarv> GreyFaceNoSpace: here is a step by step type inference of yuor 'f' example: https://gist.github.com/Solonarv/4669853b2d9c919bef4381a20117f29b
14:57:18 <d34df00d> So let's say I have a function that takes a list of ints and calculates some statistics over it in one pass (like min/max/avg/stddev). Now let's say I want to configure what statistics do I calculate at function call site, ensuring I don't waste cycles on what the caller hasn't requested. What's the most elegant _and_ performant way to express this?
14:58:43 <solonarv> sounds vaguely foldl-ish
14:59:07 <solonarv> @hackage foldl
14:59:08 <lambdabot> http://hackage.haskell.org/package/foldl
14:59:45 <d34df00d> > http://hackage.haskell.org/package/foldl-1.4.6/docs/Control-Foldl-ByteString.html
14:59:47 <d34df00d> Yay.
14:59:48 <lambdabot>  error:
14:59:48 <lambdabot>      Not in scope: ‘ByteString.html’
14:59:48 <lambdabot>      No module named ‘ByteString’ is imported.
14:59:49 <erisco> that's an extrapolation from the classic average example isn't it
15:00:54 <d34df00d> solonarv: would you expect the compiler to be able to CSE common computations away in case they both are enabled?
15:01:19 <erisco> once upon a time I knew where some relevant literature was
15:01:21 <d34df00d> Moreover, can I somehow force the compiler to generate different specialized versions of my function for different statistics enabled?
15:01:26 <d34df00d> Without resorting to TH, of course.
15:01:30 <GreyFaceNoSpace> solonarv, thank you kind sir, I will have a look at it after i am done with the exercise i am doing right now
15:01:52 <d34df00d> I tried doing something dependently-typish, but it quickly turned out to be a hell.
15:02:31 <erisco> d34df00d, the approach I am aware of is to teach the compiler how take two traversals of a list and make it one
15:03:04 <d34df00d> erisco: and how do you do that?
15:03:47 <erisco> I am just trying to remember if "fusion" is exactly the right thing
15:04:11 <erisco> I'd take a boo around here anyways https://hackage.haskell.org/package/stream-fusion
15:04:17 <solonarv> d34df00d: no, I would not expect CSE to magically fix those things
15:04:38 <d34df00d> :(
15:04:52 <solonarv> foldl is basically exactly what you want
15:04:55 <erisco> though last updated in 2017 I am not sure if it has been supplanted
15:04:56 <d34df00d> Anyway, worth giving it a shot, thanks.
15:04:59 <solonarv> except that it might be too strict
15:05:07 <solonarv> but it should be easy to make a lazy variant of it
15:05:08 <d34df00d> solonarv: I desperately need strictness here, so that's good.
15:05:46 <d34df00d> So I came across this ( https://chrispenner.ca/posts/wc ) blog post, and I learned I can further improve the single-threaded version ( https://github.com/0xd34df00d/hwc ).
15:06:08 <d34df00d> But now I really want to investigate making it into a proper `wc`, with options for different statistics etc.
15:06:16 <d34df00d> And not waste time on what I don't need to compute.
15:06:54 * hackage musicScroll 0.1.2.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.1.2.0 (RubenAstudillo)
15:07:33 <slack1256> Now supporting VLC (lol) xD
15:15:24 * hackage haeredes 0.5.2 - Confirm delegation of NS and MX records.  https://hackage.haskell.org/package/haeredes-0.5.2 (MichaelOrlitzky)
15:20:35 <dmj`> if github had chat ... 
15:20:46 <d34df00d> Why if you have freenode?
15:20:56 <dmj`> why have slack if you have freenode?
15:21:02 <d34df00d> Totally second this.
15:21:08 <dmj`> lol
15:21:35 <dmj`> look, you wanna be famous? Make a ton of bay area money? put a GUI on some old linux utility
15:22:08 <d34df00d> Sorry but I want to do haskell, but I can only GUI in C++ with Qt.
15:22:24 <dmj`> just extern "C" all the thing
15:22:38 <dmj`> then ffi into that, problem solved
15:22:38 <slack1256> I just did a gtk app on haskell
15:22:49 <dmj`> slack1256: how was the experience
15:22:57 <d34df00d> dmj`: that's a tad painful with C++.
15:23:01 <slack1256> dmj`: https://hackage.haskell.org/package/musicScroll-0.1.2.0 
15:23:03 <solonarv> there are haskell bindings to most of the big UI frameworks afaik
15:23:04 <slack1256> Actually really nice
15:23:09 <dmj`> d34df00d: why?
15:23:18 * solonarv has never used any of them
15:23:26 <d34df00d> solonarv: I looked at Qt ones a few years ago.
15:23:34 <d34df00d> It's like writing C++ in Haskell.
15:23:35 <d34df00d> Do not want.
15:23:49 <solonarv> yeah
15:24:22 <d34df00d> dmj`: you need to write actual C code to wrap/unwarp calls to C++ methods.
15:24:22 <solonarv> I'll probably be making my own UI framework on top of reflex + sdl2
15:24:23 <GreyFaceNoSpace> guys sorry for bothering you again. but do you happen to have experience with proving haskell code through structural induction?
15:24:31 <dmj`> d34df00d: you should check out miso, for writing GUIs, its pleasant, at last, more pleasant than others.
15:24:31 <slack1256> I think qtah-qt5 lets you use qt-creator. 
15:24:32 <d34df00d> There's inline-c-cpp as well as smth else, but it's fragile.
15:24:44 <dmj`> d34df00d: yea, that's fine
15:24:59 <d34df00d> Dunno, it's boring for me.
15:24:59 <slack1256> With gi-gtk you can crate glade files and just load the widgets you care on the haskell side and modify them.
15:25:09 <d34df00d> And I'm not at that level as to write tools to automate that.
15:25:19 <d34df00d> Since it's gonna be a fun project that'll distract me from the primary goal.
15:26:02 <dmj`> d34df00d:  I have tools to automate that process
15:26:22 <dmj`> d34df00d: if you give me a C function signature from some header file I can give to you an FFI declaration
15:26:37 <dmj`> d34df00d: bridge the gap
15:27:01 <d34df00d> But it's gonna be a C function that you will have to write yourself.
15:27:08 <d34df00d> That proxies stuff to the right C++ things.
15:27:34 <dmj`> d34df00d: yea that's very common practice, C++ developers expose a C interface for interoperability
15:27:58 <d34df00d> Qt doesn't do that.
15:28:11 <d34df00d> Although they have to do this in some form for the Python bindings.
15:28:18 <d34df00d> That are kinda semi-officially if not officially supported.
15:28:38 <d34df00d> I never thought about that route, probably worth investigating how they do this for Python.
15:28:48 <dmj`> well, some people just don't care about interop, depends on if you're a monopoly or not
15:29:04 <d34df00d> But, on the other hand, their python stuff looks a lot like C++ stuff. Again, do not want that in Haskell.
15:29:13 <d34df00d> And writing idiomatic wrappers gonna be tedious.
15:29:31 <dmj`> d34df00d: are you sure no one in haskell has done this
15:30:08 <d34df00d> I haven't updated my world view for quite a while here, but last time I researched this nobody did proper Qt bindings that would be pleasant to use.
15:30:39 <dmj`> IIRC there was elementary support for haskell and C++
15:30:45 <dmj`> cabal might have had something
15:30:56 <dmj`> they said the same for objective-c, there's even a ghc page about objective-c
15:31:01 <dmj`> clang compiles it natively
15:31:04 <dmj`> d34df00d: https://github.com/serokell/qtah
15:31:41 <dmj`> d34df00d: we need like more than just Qt, we have opengl stuff, sdl, but maybe we need to go higher like making haskell first class for Unity / Unreal engines
15:32:37 <solonarv> that would be pretty cool
15:33:09 <solonarv> I wonder if there is a Haskell-to-CLR compiler
15:33:33 <dmj`> I just don't understand, its like these companies either don't care or are malicious in their lack of interoperability. Like SwiftUI not exposing it's events API
15:33:59 <dmj`> solonarv: this is wild https://hackage.haskell.org/package/clr-inline
15:35:27 <d34df00d> dmj`: check out inline-r.
15:35:42 <dmj`> d34df00d: I've seen it. Looks cool
15:35:45 <solonarv> dmj`: but I wanted the other direction
15:35:47 <d34df00d> Hm, serokell folks are everywhere lately.
15:35:49 <dmj`> d34df00d: but R itself is slow
15:35:52 <d34df00d> I should ask if they hire.
15:36:08 <dmj`> R is more like a DSL than a real language
15:36:09 <solonarv> that's what you would need to write Unity scripts in Haskell (or at least it would help a lot)
15:37:17 <dmj`> solonarv: we should see if there is some C lib or C++ lib that is being used under the hood for unity, and if they expose a C# interface because its more palatable for maintastream
15:39:08 <solonarv> unfortunately Unity is quite proprietary and so it's not easy to inspect for that sort of thing
15:39:50 <dmj`> solonarv: the only interface into unity is its scripting API? they don't give you a library / object files?
15:39:52 <mawk> lol "serokell"
15:40:03 <mawk> my gf is taking seroquel
15:40:04 <solonarv> dmj`: I haven't dug very deeply into it, tbh
15:41:09 <d34df00d> dmj`: I heard it has great libraries for stats (unsurprisingly) and some great charts libraries.
15:41:14 <d34df00d> R that is.
15:41:17 <d34df00d> Not Unity.
15:42:09 <dmj`> d34df00d: yea has like ggplot
15:43:51 <dmj`> solonarv: even if we had a perfect Haskell <> SwiftUI binding, I don't think we'd be able to use the live update feature XCode Catalina provides
15:44:55 <dmj`> solonarv: XCode would be obviated if they gave a clean API 
15:45:39 <dmj`> mawk: she should apply :P 
15:46:47 <solonarv> hm, I think among the popular-ish game engines Godot is probably the best candidate for adding Haskell as a scripting language
15:47:47 <dmj`> the big players just aren't going to promote haskell.
15:48:06 <dmj`> We'd almost need to create a large tech company, like another FAANG, that just provides a Haskell interface. Similar to what Apple did with Objective-C
15:48:13 <solonarv> yes, and the big players are also too proprietary for the open source community to contribute a Haskell interface
15:48:14 <dmj`> Some obscure strange lang.
15:48:42 <dmj`> We need to make a big player then
15:48:42 <solonarv> ah, and it looks like this is already a thing:
15:48:42 <solonarv> @hackage godot-haskell
15:48:43 <lambdabot> http://hackage.haskell.org/package/godot-haskell
15:49:21 <dmj`> we've been looking at the problem backwards, finding solutions for problems that already exist and writing bindings, we need to find the problems first.
15:50:13 <d34df00d> Dunno why you'd say that. I always first got the hammer and then was looking for nails.
15:50:52 <AWizzArd> Type (synonym) families: are there “only” three diffeent variants? Open, Closed and Associated?
15:50:55 <dmj`> d34df00d: it's from paul graham, ycombinator guy. He's premise is look for problems, not solutions. Haskell, like blockchain, is a solution, not a problem.
15:50:57 <dmj`> s/He's/His
15:51:09 <solonarv> AWizzArd: one might even say there are only two: open and closed
15:51:17 <dmj`> d34df00d: we've always known the solutions
15:51:17 <solonarv> associated are just a special case of open
15:51:55 <dmj`> AWizzArd: GHC lifts associated to be open type families, kind of a sham
15:52:09 <AWizzArd> solonarv: So, does open mean it is just kind of syntactic sugar?
15:52:40 <AWizzArd> dmj`: okay, so just syntax
15:53:17 <dmj`> AWizzArd: yea, closed was introduced later, and it's a nice way to implement various Prelude functions at the type level
15:54:01 <AWizzArd> Closed means that nobody (without the source and without recompilation) can extend it to add other cases?
15:54:12 <dmj`> AWizzArd: from a programmer's perspective associated is nicer to deal with.
15:54:33 <dmj`> AWizzArd: yes, can never be extened. The second you see the 'where', you know you're closed
15:54:38 <dmj`> extended*
15:54:40 <AWizzArd> dmj`: why is the associated syntax nicer to deal with?
15:55:05 <dmj`> AWizzArd: easier to not forget about it
15:55:46 <dmj`> tie it to a typeclass, then if you have instances that do recursive things, the type family will be there
15:57:04 <AWizzArd> dmj`: can open&associated be mixed freely?
15:57:20 <AWizzArd> Or am I locked in, in one specific syntax, as soon as I decide to go for one?
15:59:00 <dmj`> AWizzArd: if its associated, you're locked into that typeclass and supplying definitions for its member functions, unless they have specified defaults
16:00:05 <dmj`> but from GHC's perspective, the associated type families get floated out
16:00:08 <AWizzArd> But if I write that original definition of the type synonym outside then it can’t be added inline?
16:00:43 <dmj`> AWizzArd: you can add it to the context of any instance, if its open
16:00:59 <AWizzArd> dmj`: so I understand it in such a way that ghc is doing some checks that associated families are indeed restricted to one specific class, but as soon as this check succeeded, it rewrites the code as if the other syntax has been used?
16:03:58 <dmj`> AWizzArd: that's right
16:06:11 <AWizzArd> dmj`: If I may ask more about TF: what does "injective" mean in this context? Is that a bit comparable to functional dependencies, where I can have any "result type" of a family operation only once?
16:06:43 <AWizzArd> In maths it's clear, for a function from A -> B I know that whenever I see that f(a1) = f(a2) then for sure  a1 = a2.
16:08:26 <AWizzArd> type instance Foo Int = Bool   <- now Bool is taken. There can not be another
16:08:33 <AWizzArd> type instance Foo String = Bool
16:08:59 <AWizzArd> Does this make sense? Does this have to do with injectivity?
16:10:39 <dmj`> injective should mean that every element of the domain maps onto the codomain, if there is a 1-1 correspondence you have a bijection. 
16:11:40 <AWizzArd> In english "codomain" would be the B  in  f: A -> B?
16:12:19 <dmj`> the domain is A, codomain is B
16:12:28 <dmj`> AWizzArd: so per your fun deps example
16:12:29 <AWizzArd> Isn't that surjectivity? If it is possible to "recreate" B from calls of f(a), then f is surjective.
16:12:56 <AWizzArd> But if it is injective then two pairwise different a will "hit" two different bs
16:12:59 <AWizzArd> no?
16:12:59 <dmj`> surjective and injective is bijective
16:13:04 <AWizzArd> si
16:13:19 <AWizzArd> I just wonder if my intuition of injective families makes sense.
16:13:51 <dmj`> let's go back to your fun deps example
16:13:59 <dmj`> class Foo a b  | a -> b
16:14:15 <dmj`> instance Foo String Int; instance Foo String Bool
16:14:38 <dmj`> this won't compile because it's not mapping to a unique element in the codomain
16:15:14 <AWizzArd> Okay, then I think I gave the example     | b -> a
16:16:31 <dmj`> that's ok to do, but its not injective 
16:18:13 <dmj`> injective functions can't allow the two elements in the domain to map to the same element in the codomain
16:18:23 <AWizzArd> I agree.
16:18:41 <AWizzArd> dmj`: you gave these two examples:   instance Foo String Int; instance Foo String Bool
16:18:58 <AWizzArd> Shouldn’t those be   instance Foo Int String; instance Foo Bool String   instead?
16:19:39 <AWizzArd> I may start (i.e. domain) at an Int or Bool, both are fine. But I can not both times end up (codomain) with a String.
16:21:08 <dmj`> right, injective means each element in the domain is mapped to a unique element in the codomain (doesn't have to be a 1-1 correspondence though) 
16:21:36 <dmj`> if there are elements in the codomain that lack an arrow pointing to them, its not surjective
16:21:47 <AWizzArd> agreed
16:23:59 <AWizzArd> dmj`: good, thank you. This helped!
16:24:28 <dmj`> AWizzArd: np
16:31:35 <ChaiTRex> @undo [0, -1 .. -n]
16:31:35 <lambdabot> [0, -1 .. -n]
16:32:10 <ChaiTRex> > map (enumFromThenTo 0 (-1)) [0 .. 3]
16:32:12 <lambdabot>  [[0],[],[],[]]
16:32:29 <ChaiTRex> > map (enumFromThenTo 0 (-1) . negate) [0 .. 3]
16:32:32 <lambdabot>  [[0],[0,-1],[0,-1,-2],[0,-1,-2,-3]]
16:33:12 <ChaiTRex> > inits [0, -1 .. -3]
16:33:12 <lambdabot>  [[],[0],[0,-1],[0,-1,-2],[0,-1,-2,-3]]
16:33:47 <ChaiTRex> > tails [-3 .. 0]
16:33:50 <lambdabot>  [[-3,-2,-1,0],[-2,-1,0],[-1,0],[0],[]]
17:08:24 <pacak> Suppose you have a Bounded Enum datatype: data Foo = A | B | C | D | ... and you want to make a mapping Foo -> Char. How would you go about ensuring on a type level that each Foo maps to a unique Char?
17:16:42 <solonarv> pacak: there isn't really a good way to do that, I think
17:20:37 * hackage lzlib 1.0.0.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.0.0 (vmchale)
17:30:00 <jle`> this sounds maybe like a 'what problem are you trying to solve' kind of thing
17:30:01 <safinaskar> is there some irc channel for discussing small programming languages? i. e. channel for people who know lots of programming languages?
17:32:10 <pacak> jle`: Not a very practical one, that's for sure :)
17:33:01 <jle`> there might be a structural way, but the 'dumb' way would just be to include the proof as a separate function
17:33:24 <jle`> fooUnique :: (foo x == foo y) -> (x == y)
17:33:42 <jle`> but this is anynoying in Haskell because we don't have promoted Char's
17:34:23 <jle`> or it might be easier as not (x == y) -> not (foo x == foo y)
17:34:32 <jle`> there might be some interesting structural ways, however, like using a two-way Map to define your function
17:36:07 <pacak> Some context - I'm writing a small interactive console program that takes one of 4 possible commands by doing a pattern match. A collegue of mine insist on doing it "the right way" by introducing a datatype and a bunch of extra code....
17:38:46 <jle`> hm. yeah in that case i would probably not write it directly as a Foo -> Char
17:38:55 <jle`> but rather as some data structure that matches foo's and char's one to one
17:38:58 <jle`> like a two-way map, maybe
17:39:04 <jle`> and then your final function would use that data structure
17:43:18 <srid-irccloud> ghcide + coc.vim is nice. https://funprog.srid.ca/rib/ide-support.html
17:44:22 <pacak> srid-irccloud: Template Haskell?
17:44:39 <srid-irccloud> ?
17:45:08 <pacak> Can it support TH?
17:46:12 <srid-irccloud> it works fine with TH
17:46:31 * srid-irccloud just not with some cabal file settings (like language pragmas)
17:46:39 <srid-irccloud> (that's not a /me)
17:48:01 <pacak> Interesting.
17:48:23 <pacak> I'm using hie + coc + nvim and it supports everything...
17:49:03 <suzu> hie + vscode
17:49:10 <suzu> used to use spacemacs + intero but switched
17:49:50 <srid-irccloud> hie and ghcide are joining hands: https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html
17:50:06 <pacak> Eventually.
17:51:37 <suzu> yay
17:51:42 <suzu> more ide support makes me happy
18:02:58 <slack1256> For traditional OOP GUI apps is the mvc pattern the usual structure?
18:05:51 <dmj`> slack1256: it's the wild west
18:08:23 <dmj`> slack1256: some have MVVM
18:08:34 <dmj`> like M$ silverlight
18:09:24 * hackage lens-csv 0.1.0.0 -   https://hackage.haskell.org/package/lens-csv-0.1.0.0 (ChrisPenner)
18:19:24 * hackage hackport 0.6.4 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.6.4 (solpeth)
18:20:17 <ChaiTRex> Is head . Map.keys the best way to get the key of a singleton map?
18:20:53 <slack1256> ChaiTRex: Seems reasonable if you want the keys.
18:21:04 <slack1256> You need to know it is a singleton though
18:21:14 <ChaiTRex> slack1256: OK, makes sense. Thanks.
18:21:31 <dmj`> ChaiTRex: listToMaybe to be safe
18:22:40 <slack1256> ChaiTRex: Also use Foldable
18:23:03 <ChaiTRex> dmj`: Oh, no, I have to check Map.size anyway.
18:23:15 <ChaiTRex> slack1256: How would I use Foldable?
18:24:25 <slack1256> > foldr1 (\a acc -> Just a) (singleton 'b')
18:24:27 <lambdabot>  error:
18:24:27 <lambdabot>      • Variable not in scope: singleton :: Char -> [a]
18:24:27 <lambdabot>      • Perhaps you meant one of these:
18:24:57 <ChaiTRex> :t foldr1
18:24:59 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
18:25:19 <slack1256> No, that's not right.
18:25:59 <ChaiTRex> > foldr1 (\a acc -> a) (singleton 'b')
18:26:01 <lambdabot>  error:
18:26:01 <lambdabot>      • Variable not in scope: singleton :: Char -> [a]
18:26:01 <lambdabot>      • Perhaps you meant one of these:
18:26:15 <ChaiTRex> > foldr1 (\a acc -> a) (Data.IntMap.singleton 'b')
18:26:18 <lambdabot>  error:
18:26:18 <lambdabot>      • Couldn't match type ‘Char’ with ‘Int’
18:26:18 <lambdabot>        Expected type: IS.Key
18:26:26 <ChaiTRex> > foldr1 (\a acc -> a) (Data.IntMap.singleton (1, 'b'))
18:26:28 <lambdabot>  error:
18:26:28 <lambdabot>      • Couldn't match type ‘(Integer, Char)’ with ‘Int’
18:26:29 <lambdabot>        Expected type: IS.Key
18:27:17 <slack1256> Data.Map.foldr (\a acc -> a) undefined (Data.Map.singleton 'a' '3')
18:27:21 <d34df00d> pacak: what your IDE setup can do? I'm also using coc + hie, and I'm curious if it's possible to (1) show the type of a selected subterm, (2) case-split, and (3) try to fill a typed hole?
18:27:24 <slack1256> > Data.Map.foldr (\a acc -> a) undefined (Data.Map.singleton 'a' '3')
18:27:26 <lambdabot>  '3'
18:27:43 <ChaiTRex> slack1256: How would I get 'a' from that?
18:27:43 <slack1256> > Data.Map.foldrWithKey (\key a acc -> key) undefined (Data.Map.singleton 'a' '3')
18:27:46 <lambdabot>  'a'
18:27:50 <ChaiTRex> Ahh, thanks.
18:28:34 <d34df00d> Some form of intelligent autocomplete would also be nice (like proposing to substitute a term from the environment that has a type matching a function argument's type).
18:29:19 <heatsink> I made a skeleton project with a test suite containing no tests.  `cabal test` works but `stack test` hangs when it runs testsStub.  What could I be doing wrong?
18:29:26 <heatsink> The cabal file is https://gist.github.com/cirodrig/5bc36d04094db19c5b375aebe3e91f4c
18:29:27 <pacak> d34df00d: I had (1) working before switch to bios based version, (2) is known to be broken at the moment - there's a ticket as far as I remember, not sure about (3)
19:22:27 <reactormonk> I wanna parse some rather simple text-based data. What's a good parser-combinator library nowadays? trifecta?
19:25:42 <solonarv> megaparsec is my default
19:27:19 <ChaiTRex> :t foldl
19:27:21 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
19:31:24 * hackage lzlib 1.0.0.1 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.0.1 (vmchale)
20:11:36 <ChaiTRex> If I'm building an infinite tree (some branches are leaves, but there are paths through the tree that are infinitely long) with a finite number of possible subtrees, how can I do common subtree elimination while I'm generating the tree lazily?
20:15:17 <ChaiTRex> I can't think of a way to, for example, keep a Map of all seen subtrees, because when you go down one branch lazily updating the Map as you go, the updated Map isn't shared with other branches.
20:16:26 <ChaiTRex> Hmm, I guess I could use a Map as the tree.
20:31:27 <ChaiTRex> No, then you have to take the space and time to fill in all the keys with thunk values.
20:34:25 <jle`> ChaiTRex: you could reify the tree maybe, by having the nodes point to 'subtree ID'
20:34:43 <jle`> what is your tree structure?
20:38:21 <ChaiTRex> jle`: It's a tree where the branches are a distinct dealt card each. The cards are dealt and reshuffled after all of them are dealt, but you have to determine where the shuffle happens. The leaves are ShuffleAt Int and Impossible. Otherwise, a subtree has n branches for n possible cards.
20:40:33 <ChaiTRex> jle`: One example of where the subtrees are the same are the subtrees after the card sequences 1 2 3 and 1 2 3 1 2 3. You know the exact same information after either of those.
20:41:03 <ChaiTRex> jle`: So I want the subtree to be the same location in memory rather than duplicating stuff.
20:41:40 <ChaiTRex> jle`: (with a 3-card deck)
20:46:54 * hackage sized 0.3.0.1 - Sized sequence data-types  https://hackage.haskell.org/package/sized-0.3.0.1 (HiromiIshii)
20:47:09 <ChaiTRex> jle`: Here's the code with an example where it finds the cards are shuffled just before the first dealt card: https://ideone.com/B1rrXY
21:00:06 <jle`> ChaiTRex: ah yeah, my idea would be to, instead of ShuffleTree recursing directly on another ShuffleTree, it can recurse on ShuffleTreeID
21:00:19 <jle`> Branches Set.IntSet (Map.IntMap ShuffleTreeID)
21:00:34 <jle`> and your whole tree is `Map ShuffleTreeID ShuffleTree`
21:00:55 <ChaiTRex> jle`: The Map argument to go is the ID essentially of the subtree.
21:01:51 <ChaiTRex> jle`: Is there a way to memoize go somehow, since it generates all subtrees?
21:01:56 <jle`> er sorry, what point are you trying to make by that? are you saying that this makes my idea not work?
21:02:13 <ChaiTRex> jle`: Well, I'd have to convert the Map to the ID type.
21:02:18 <jle`> right
21:02:23 <jle`> that's the reification process
21:02:37 <jle`> it's similar to how fgl implements its graphs
21:03:00 <jle`> ah, if you have a tree that recurses infinitely onto itself ... isn't that basically a graph?
21:03:15 <jle`> so you can just use a directed graph data structure instead of an infinite tree
21:03:59 <ChaiTRex> jle`: Yeah, it's a tree view of a graph, I think.
21:04:08 <alc> what're parser and DSL?
21:04:10 <ChaiTRex> jle`: The graph would be finite, so hmm.
21:04:20 <jle`> yeah, it might be just best to represent it as a graph
21:04:22 <alc> and meta-programming?
21:04:24 <jle`> and then use a tree to 'view' it
21:04:42 <jle`> which is basically 'identify all nodes from this one'
21:05:14 <ChaiTRex> jle`: Is fgl a good library?
21:05:31 <jle`> it's the 'standard' of graph libraries in haskell :)
21:05:46 <jle`> there are some competitors but none have really seem much widespread testing and usage as fgl
21:05:49 <jle`> if that counts for anything
21:05:59 <jle`> it does have a bit of a learning curve though
21:06:12 <ChaiTRex> jle`: Ahh.
21:07:06 <ChaiTRex> jle`: Thanks for the help.
21:07:11 <jle`> np :)
21:07:17 <ChaiTRex> alc: Are you wondering what those mean?
21:08:34 <alc> ChaiTRex: very wondering!
21:09:16 <ChaiTRex> alc: Parser turns a String into some data. For example, the read function is a kind of parser.
21:09:36 <alc> ChaiTRex: DSL?
21:10:16 <ChaiTRex> alc: DSL is domain-specific language. It's like a sublanguage inside a language that makes programming for some specific topic easy.
21:10:30 <alc> ChaiTRex: and meta-programming?
21:10:50 <ChaiTRex> alc: Metaprogramming is where you program something that writes part of a program for you.
21:11:04 <alc> ChaiTRex: are those three things related?
21:11:26 <ChaiTRex> alc: Well, you can have a DSL that makes writing parsers easy.
21:11:52 <ChaiTRex> alc: You can use metaprogramming to write a program that creates a program or library to parse something.
21:12:19 <ChaiTRex> alc: You can have a DSL that makes metaprogramming easy.
21:12:25 <alc> ChaiTRex: it looks like create a new language?
21:12:34 <ChaiTRex> alc: You mean DSLs?
21:12:43 <alc> ChaiTRex: yes
21:13:08 <ChaiTRex> alc: Well, almost. It's a sublanguage. Like you'd still be writing Haskell, just your new subset of it.
21:13:53 <alc> ChaiTRex: is there a classical simple DSL example in haskell?
21:14:12 <ChaiTRex> alc: I don't know of one.
21:14:51 <alc> I heard that lisp can only use seven lines to do an interpreter, that sounds magic!
21:15:22 <ChaiTRex> alc: Yeah, Lisp is easy to parse, which makes it much simpler.
21:15:46 <alc> ChaiTRex: to do DSL is not easy in haskell?
21:16:00 <Finianb1> it's very easy in haskell 
21:16:02 <ChaiTRex> alc: Some DSLs are pretty easy.
21:16:09 <Finianb1> it's super powerful for DSLs 
21:16:50 <alc> Finianb1: is there a good article about it?
21:17:06 <Finianb1> I don't remember any off the top of my head 
21:17:22 <alc> create a language is so excited!
21:18:11 <alc> ChaiTRex: there's infix-expression, prefix-expression in haskell, I wonder if there's suffix-expression
21:18:46 <alc> with DSL, we can do that?
21:21:46 <ChaiTRex> alc: You potentially could, you'd just need a function to evaluate it.
21:22:00 <ChaiTRex> alc: Like eval a b c f
21:22:24 <ChaiTRex> alc: That would be hard to do, though.
21:22:58 <ChaiTRex> alc: It's easier to go along with Haskell's way of doing things and use infix and prefix.
21:24:52 <shafox> with nix, i want to use the ghc882 or 881, how do I go about it ? 
21:38:24 * hackage hw-excess 0.2.2.3 - Excess  https://hackage.haskell.org/package/hw-excess-0.2.2.3 (haskellworks)
21:43:54 * hackage mailbox-count 0.0.3 - Count mailboxes in a SQL database.  https://hackage.haskell.org/package/mailbox-count-0.0.3 (MichaelOrlitzky)
21:55:24 * hackage hw-balancedparens 0.3.0.4 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.3.0.4 (haskellworks)
22:22:24 * hackage either-list-functions 0.0.2.0 - Functions involving lists of Either  https://hackage.haskell.org/package/either-list-functions-0.0.2.0 (chris_martin)
