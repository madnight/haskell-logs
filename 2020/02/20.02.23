02:11:09 <fog> I cant get the OpenGL bindings to install on windows, I cant remember the error but I have tried on several occasions and at this point I just need an alternative
02:12:00 <fog> is there anything else I can use to raster a sequence of frames and display them on the screen?
02:13:09 <fog> I can write to .gif fairly easily, but it needs to be a streaming thing...
02:13:30 <fog> like, to display each frame as it is calculated
02:14:49 <fog> I dont need shape primitives, shaders or textures or most of the things OpenGL provides, just to raster pixels 
02:15:57 <fog> I'm not sure about SDL or wxWindows... I can remember having trouble installing those also
02:16:32 <fog> I think there was something like Cairo, but idk the best way
02:16:37 <int-e> I wonder whether SDL could be an option. (The use case could be from an SDL poster, but it is an additional C library and I don't know whether the bindings work on Windows)
02:18:11 <fog> yeah, I guess thats the issue, its always going to be some FFI, and the build/bindings need to be maintained and working  
02:18:32 <int-e> I don't think cairo renders anything by itself; it needs a toolkit library too.
02:19:15 <int-e> (To the screen, that is. It can produce PNGs, but then you're in the same territory as with GIF.)
02:19:48 <fog> I guess part of the reason for wanting a very simple and stable is to make an API built over it that does not depend on any special features that might not be available under an alternative backend
02:19:53 <dminuoso> Cale | [04:43:34] Yeah, it's just that e.g. in C's ad-hoc polymorphism, you can define many versions of a function and have them selected based on the type of the usage,
02:19:59 <dminuoso> Are you sure you weren't referring to C++ there?
02:20:11 <dminuoso> C does not have any ad-hoc polymorphism facilities that I am aware of.
02:20:55 <fog> thats why .gif seemed ok, since it was just for eg. fluid simulations, which are naturally pixel-like
02:21:35 <fog> and that the rastering to screen pixels seemed to be the most bare bones approach
02:21:56 <int-e> Oh well, I'm really out of my depth. Maybe somebody with actual Windows programming experience will chime in.
02:23:30 <fog> the obsidian folk seemed to be advocating for web-gl, which has the advantage of being cross platform
02:24:19 <fog> dminuoso: sounds like that would need C++ template machinery 
02:25:16 <Tuplanolla> Remember when you could just poke the address of the pixel?
02:25:37 <int-e> Nowadays poking is not PC.
02:28:08 <fog> Tuplanolla: sounds like thats where the FFI becomes nesacary, I think the thing with OpenGL is that it actually has drivers, I guess nothing else is that sophisticated
02:29:51 <fog> but yeah, if they are to leverage graphics card shaders and primitives then maybe I can write something like a very basic pixel driver just using FFI memory managment via C
02:30:45 <fog> but, a hackage library would be infinitely preferable!
02:34:24 <fog> hmm, im finding "game engines" as common alternatives to OpenGL
02:34:26 <fog> http://hackage.haskell.org/package/godot-haskell
02:34:34 <fog> seems like severe overkill though
02:40:36 <fog> and Qt; https://hackage.haskell.org/package/qtah-qt5
02:47:05 <fog> ah, that requires signup...
03:25:09 <Oblomov2020> lyxia followup question on generic-data-surgery; I made a gist with the problem at https://gist.github.com/meditans/d3b5970d7d1d7cb0f4af98091a41f2c1 I'm interested in understanding why the two types defined in there don't match
03:45:49 <Nelspike> Hey there o/
03:48:51 <ski> hello Nelspike
03:50:40 <Nelspike> Good to be around
03:51:15 * ski idly wonders whether Nelspike had a question, at this time
03:51:38 <Nelspike> Not at all for now, just saying hi :D  Am about to start getting into Haskell
03:51:47 <ski> that's nice :)
03:51:59 <ski> do you have any textbook, or tutorial, to follow ?
03:52:17 <Nelspike> Just a little tutorial, going to follow this: http://learnyouahaskell.com/introduction
03:52:24 <ski> okay, LYAH
03:52:30 <Nelspike> That's how I actually ended up here
03:52:48 <ski> jfyi, LYAH is often considered not that good to use, nowadays
03:53:02 <ski> (it's been likened with a "four-hour long film trailer")
03:53:20 <Nelspike> Oof - What would you use instead? :D
03:54:02 <ski> there's no exercises (so no reinforcment, feedback checking that you've learned things), and it doesn't explain things that well, i'm told
03:54:22 <ski> well, for exercises, you can try
03:54:26 <ski> @where CIS194
03:54:26 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
03:54:39 <ski> (yes, the 2013 spring edition)
03:55:35 <ski> i'm not too sure if there's a good tutorial replacement by LYAH, on the web
03:55:45 <ski> s/by/for/
03:56:10 <Nelspike> Oh, nice! That looks pretty good, thank you so much
03:56:16 <ski> if you have access to an uni library, then maybe you could borrow some textbook. or, if you're willing to buy
03:56:42 <ski> there are some books that are often suggested
03:56:49 <Nelspike> Been out of Uni for a long time unfortunately :/  I'd possibly buy something, but myabe at a later point in time
03:57:09 <ski> yea, i understand
03:57:14 <ski> @where wikibook
03:57:14 <lambdabot> http://en.wikibooks.org/wiki/Haskell
03:57:17 <ski> might be useful
03:57:27 <ski> Â¡where HTAC
03:57:30 <ski> @where HTAC
03:57:30 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
03:57:52 <ski> @where PIH
03:57:52 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
03:58:02 <ski> is well regarded, if you later want to get a book
03:58:10 <ski> also i've heard people liked
03:58:13 <ski> @where SoE
03:58:13 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
03:58:42 <Nelspike> Thank you so much for all the references o/ It looks like I can get myself busy for the next weeks with all of this haha
03:58:42 <ski> i learned from "Haskell: The Craft of Functional Programming" by Simon Thompson, which i also think is good
03:58:52 <Chousuke> I've always found that the best way to learn something is to just be forced to use it. Tutorials and other things mostly work for reference and to give you ideas.
03:59:06 <ski> @where HR
03:59:06 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/> (broken ?),<https://web.archive.org/web/20190528043209/https://homepages.cwi.nl/
03:59:06 <lambdabot> ~jve/HR/>
03:59:12 <ski> @where RWH
03:59:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:59:18 <Nelspike> Books can definitely help Chousuke, but it's as you said
03:59:24 <Nelspike> First you need some exposure
03:59:28 <ski> the last one is a bit dated (out-of-date library APIs)
04:00:04 <ski> Nelspike : you can still try LYAH (it has pretty pictures, after all). just be aware that it has limitations
04:00:10 <Nelspike> That's what I'm trying to achieve at first, maybe get some exercises down and whatnot. Because I'm actually a little bit into FP already, I did Dr. Scheme before, and I tend to actually use a lot of HOFs when doing my daily stuff in Typescript
04:00:17 <ski> Nelspike : you're welcome to ask beginner questions in here
04:00:33 <Chousuke> Nelspike: Yeah. Books expose you to the ideas so you have something to think about when you solve problems, but it's actually the act of using whatever you're learning to solve one of *your* problems that solidifies the knowledge. :)
04:00:37 <Nelspike> Awesome, thank you so much! I'm most possibly starting with that, and then following that lecture list
04:00:52 <fishooter> hi, I'm following the tutorial at https://wiki.haskell.org/Implement_a_chat_server
04:01:09 <fishooter> in the bottom there is a reader thread implemented
04:01:16 <fishooter> is it necessary to write
04:01:17 <Nelspike> Thank you for the useful resources, ski \O/ 
04:01:26 <ski> Nelspike : there's also a #haskell-beginners channel. but beginners questions are definitely welcome also in this channel. this channel is typically more busy (might get help faster, but might also get lost in noise), while that other one is slower
04:01:27 <fishooter> _ <- forkIO $ fix $ \loop -> do
04:01:27 <fishooter>     (_, _) <- readChan chan
04:01:28 <fishooter>     loop
04:01:34 <ski> that other channel is intended for
04:01:35 <ski> @where HPFFP
04:01:36 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
04:01:37 <fishooter> or is it sufficient to only have
04:01:54 <fishooter> forkIO $ fix $ \loop -> do
04:01:54 <fishooter>     readChan chan
04:01:55 <fishooter>     loop
04:01:55 <ski> however, also people not following that book are welcome to ask in there, afaiui
04:02:06 <fishooter> ie without the collection of unused variables?
04:02:33 <ski> Nelspike : Dr. Scheme (nowadays Dr. Racket) is good
04:03:18 <ski> Nelspike : no problem ! :)
04:03:59 <ski> fishooter : the latter ought to be fine
04:04:21 <merijn> Why not simply "forever"?
04:04:25 <ski> @type forever
04:04:27 <lambdabot> Applicative f => f a -> f b
04:04:51 <fishooter> ski: thank you :)
04:09:05 <fishooter> ski: and why do we even add communication between the threads? or rather, I'm confused about the fact that the thread write to thread channel, but they do not read? how can then they communicate?
04:13:27 <ski> hm, i dunno about this example, fishooter. perhaps this thread is just to empty a channel ?
04:16:26 <fishooter> ski: I guess
04:16:50 <fishooter> ski: what would happen if there wasn't the monadic fix?
04:23:23 <ski> fishooter : there is no monadic `fix' being used i that snippet
04:23:47 <ski> (the monadic one being called `mfix'. `fix' is just the usual one)
04:24:07 <fishooter> I think it's just a function to make sure that the looping is well typed for forkIO
04:24:17 <fishooter> ie (a->a)->a
04:25:10 <fishooter> thanks for feedback
04:25:18 <fishooter> and what is the meaning of operator $! ?
04:25:20 <ski> (`mfix' is for "value recursion", in a monadic computation. e.g. if you want to allocate a bunch of `IORef's, acting as graph nodes, which is to (possibly) be cyclic, and you want to initialize it right away, not having to back-patch it after the fact. although, this tends to be more crucial when such back-patching isn't available)
04:26:32 <fishooter> is that just infix bang?
04:26:33 <ski> `fix' above is just used to do what `forever' does, building a cyclic/recursive action, that (when executed) repeatedly does something. the monadic results/values themselves aren't recursively built, just the action itself
04:26:43 <tom__> What are the advantages of newtypes over type synonym. I am I correct in saying you should generally prefer newtype as they can be exported?
04:26:43 <ski> @src ($!)
04:26:43 <lambdabot> f $! x = x `seq` f x
04:27:11 <merijn> tom__: type synonyms do literally nothing
04:27:39 <merijn> tom__: They're textual aliases for something else and IMO should only be used for shortening long/awkward types (like complicated callback signatures)
04:28:36 <ski> the meaning of `f $! x' amounts to the meaning of `f x', provided `x' is not bottom. if it is, then `f $! x' is also bottom
04:28:39 <merijn> tom__: newtypes on the other hand create, well, new types. Those types are the exact same as the original at runtime, but the compiler will force you to pattern match/use the right type at compile time before eliminating the newtype-ry
04:29:00 <tom__> merijn: Thanks for the great explanation :)
04:29:08 <adam_wespiser> newtypes give you the ability to sometimes coerce the underlying representation: lookup newtype coersion, or derivingVia for a fully explaination, but the basic idea is two representationally equally newtypes can "borrow" typeclass methods from other newtypes
04:29:49 <ski> fishooter : operationally, you can think of demanding the value of `f $! x' to, additionally (over demanding `f x'), demand the value of `x' (maybe before the call, maybe during, maybe after. but eventually, at least)
04:30:27 <ski> tom__ : `type' synonyms can be exported
04:30:45 <ski> (unfortunately not abstractly, though ..)
04:30:58 <tom__> ski: Ah that is good to know
04:31:07 <tom__> What do you mean by not abstractly?
04:31:23 <ski> tom__ : one way to think about type synonyms is to think of them as "type macros"
04:31:43 <fishooter> ski: ok, I'm confused why it's used there. At first I thought it's a limitation for the number of connections accepted (it's set to two)
04:31:52 <fishooter> but youcan actually connect with multiple clients
04:31:58 <fishooter> and it still works
04:32:06 <fishooter> I just had to try it out :)
04:32:16 <ski> tom__ : if you define `type Age = Int', then you can't just export `Age', you're also exporting the fact that `Age = Int'. so, a client importing `Age' will know that it's the same as `Int' (this is unlike type synonyms in SML and OCaml, e.g.)
04:32:44 <ski> tom__ : if one could export type synonyms abstractly, then some uses of `newtype' could be replaced by that
04:34:33 <ski> tom__ : in fact, Hugs (another Haskell implementation. an interpreter written in C) has an extension to (effectively) export type synonyms abstractly. see "Restricted Type Synonyms" at <https://www.haskell.org/hugs/pages/users_guide/restricted-synonyms.html>,<https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.3.5> for details
04:35:06 <ski> fishooter : not sure what your "it" in "it's used there" refers to
04:35:23 <tom__> ski: Thanks that makes sense
04:35:50 <ski> (hm, i wonder whether you can export them abstractly, with Backpack ..)
04:36:16 <ski> tom__ : btw, "export abstractly" is related to the notion of "Abstract Data Types", yes, in case you were wondering ..
04:38:18 <Mrbuck> hi ski  you know both math and haskell and I remember you have been learning since 6 ...What are you now?
04:38:59 <Mrbuck> Professor or employee or different?
04:40:20 <fishooter> ski: I'm trying to understand why this piece of code uses $!
04:40:22 <fishooter> mainLoop sock chan $! msgNum + 1
04:40:32 <Mrbuck> offtopic since I am banned inofftopic for a year for no reason.Unban me
04:40:42 <fishooter> it seems unncessary, because msgNum should be always defined
04:40:47 <fishooter> and never bottom
05:23:54 <devserge> list
05:56:24 <idnar> @type \a -> Just <$> a <|> pure Nothing
05:56:26 <lambdabot> Alternative f => f a -> f (Maybe a)
05:57:39 <idnar> @hoogle Alternative f => f a -> f (Maybe a)
05:57:40 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
05:57:40 <lambdabot> Distribution.Compat.Parsing optional :: Alternative f => f a -> f (Maybe a)
05:57:40 <lambdabot> Text.Parser.Combinators optional :: Alternative f => f a -> f (Maybe a)
05:58:39 <idnar> neat!
06:16:19 <Gurkenglas> I've opened https://www.gwern.net/hakyll.hs in VSCode and ghcide, and it says that it can't find lots of those imported modules. How should I fix that?
06:19:53 <maerwald> Any good idea about short-circuting a function similar to Excepts (the open-variant version of ExceptT), but without it being an exception? I feel like I need something like MonadChronicle for that and make it an open variant
06:20:07 <maerwald> or ContT lol
06:20:11 <maerwald> ugh
06:24:17 <Gurkenglas> maerwald, link to Excepts? https://hoogle.haskell.org/?hoogle=Excepts doesn't look right
06:24:33 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant-Excepts.html
06:25:00 <maerwald> this allows me to short-circuit with whatever error I want, but I can't short-circuit with a "warning" or a success
06:25:10 <maerwald> That's what These/MonadChronicle does
06:35:04 <maerwald> ah, I have an idea... I just make it an exception and catch it at the top of the function then turn it into a value
06:35:05 <Gurkenglas> It looks to me like These doesn't actually short circuit: If it did, Stream (b -> These [e] b) could be turned into b -> These [e] Void and then b -> Stream e, but the way http://hackage.haskell.org/package/these-0.7.1/docs/src/Data-These.html#line-272 works means it doesn't know to lazily feed out es as they are encountered
06:35:33 <maerwald> so the top-level signature will not contain this exception
06:37:01 <Gurkenglas> maerwald, but then doesn't that abort any subroutine that throws a warning along the way?
06:37:20 <maerwald> subroutine?
06:38:10 <Gurkenglas> not a standard term afaik, something that is wrapped in an exception catcher
06:41:12 <Gurkenglas> Is there a term for functions foo :: m -> n () where m is a monoid, n is a monad, and foo x >> foo y = foo (x <> y)?
06:48:28 <fishooter> hi, the installation guide in https://github.com/ivan-m/haskell-docs does not make any sense to me
06:48:37 <fishooter> I've update my ~/.cabal/config file
06:48:56 <fishooter> but the command haskell-docs is not available, even after shell restart
06:49:01 <fishooter> what else should I do?
06:49:19 <fishooter> the guide seems incomplete
06:56:35 <maralorn[m]> fishooter: Thatâ€˜s true.
06:56:54 <maralorn[m]> You probably need a "cabal new-install haskell-docs" or something like that.
06:59:46 <aveltras> how can i get the following to compile ?
06:59:51 <aveltras> https://www.irccloud.com/pastebin/y1uSh00F/
07:03:15 <maralorn[m]> aveltras: The compiler expects that your implementation of getSession can return anything which fulfills the SessionStorage type class.
07:03:40 <maralorn[m]> One workarend would be to make HasSession also parametric over the return type of getsession.
07:04:49 <maralorn[m]> class SessionStorage storage => HasSession env storage where
07:05:24 <maralorn[m]> instance HasSession Env RedisSessionStorage
07:05:56 <maralorn[m]> aveltras: If you change those two lines, I think it might work.
07:06:03 <aveltras> im trying it right now, but then how can i keep call sites agnostic of the storage type ?
07:06:08 <maralorn[m]> (But I defer that to the compiler.)
07:12:35 <maralorn[m]> aveltras: I think they kinda are. You can probably write most of your code just with a SessionStorage storage => constraint.
07:14:05 <maralorn[m]> aveltras: I am a bit confused about it myself, because I think Iâ€˜d know how to solve this in Rust. So there certainly has to be a way in Haskell.
07:15:40 <aveltras> im trying to implement a session type using Has typeclasses with RIO right now but im not sure how to handle it when the thing that the has constraint targets in the environment is a typeclass and not a concrete implementation
07:30:58 <fishooter> maralorn[m]: I've installed haskell-docs, but the command is still not available in shell
07:35:45 <maralorn[m]> fishooter: Is the directory it got installed to in your PATH?
07:51:21 <polyphem> hi , i am writing a library with stack as build system , now i want to do profiling , i ran "stack build --profile" and it rebuild my lib and all its dependencies with profiling support , now  my question : How can i use my library out of "stack ghci" with profiling , i don't have a executable to pass +RTS -p to ?
07:51:23 * hackage hOpenPGP 2.9.4 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.9.4 (ClintAdams)
07:53:17 <sm[m]> polyphem: maybe stack --profile ghci ?
07:55:32 <sm[m]> or: stack --profile --library-profiling ghci
07:56:56 <gaussblurinc1> Hi! Could anybody help with naming? A tuple of functions that do following: f: F[T] -> List[T] and g: List[T] -> F[T] with assumptions that these transforms make sense.
07:57:13 <polyphem> sm[m]: tried that , it loads without error but doesnt produce .prof file ; iv i had an exe , i could run : "stack exec -- myexe +RTS -p" to activate .prof-file generation in the runtimesystem
07:57:45 <polyphem> s/iv/if/
07:57:59 <sm[m]> to generate a prof file you need an executable I guess
07:58:22 <geekosaur> you would need a profiling builld of ghci, I think
07:58:26 <MarcelineVQ> gaussblurinc1: an isomorphism perhaps
07:58:31 <polyphem> sm[m]: but how does poeple do profiling of libs then ??
07:58:59 <sm[m]> run an executable that calls the lib ? even a small one
07:59:33 <sm[m]> main = Lib.doStuff
07:59:58 <sm[m]> some folks profile their tests, perhaps
08:00:23 <geekosaur> you generally want that anyway unless the lib is truly selfcontained, because anything ghci does will mess it up
08:00:31 <polyphem> sm[m]: ok , have to build a wrapper exe then ... thought i could do it directly out of ghci
08:00:46 <gaussblurinc1> MarcelineVQ: Yeah, maybe. But I need names for them :(
08:00:59 <MarcelineVQ> gaussblurinc1:  to  and  from
08:01:16 <MarcelineVQ> I thought you wanted a name for the tuple ;>
08:01:38 <MarcelineVQ> in which case iso could be fine, it'd be hard to say more without more context
08:02:15 <gaussblurinc1> MarcelineVQ: F is a Tree in my case, kind of Tree ( not binary )
08:02:35 <MarcelineVQ> toList  and  fromList  are common names that are slightly more descriptive
08:02:55 <sm[m]> ghci is more suitable for quick & dirty interactive testing - run things and see how long they take
08:05:19 <gaussblurinc1> MarcelineVQ: thanks a lot for help! :)
08:07:21 <maralorn[m]> gaussblurinc1: I think categorically speaking what you are doing looks very much like a natural transformation. (But Iâ€˜d also go with toList or listToTree or something like that.)
08:08:38 <gaussblurinc1> maralorn[m]: Agree. I am thinking about `flatten` name. Not obvious :( 
08:22:50 <madnight> I have a function that only works when I insert a print statement ...
08:26:48 <fishooter> maralorn[m]: ah, it wasn't. Thanks!
08:26:49 <madnight> https://pastebin.com/raw/5FP4vmFM
08:27:24 * hackage dhall-fly 0.2.3 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.2.3 (axeman)
08:28:14 <maralorn[m]> madnight: Maybe a lazyness problem?
08:28:25 <madnight> I added a BangPattern like so: return $! fileData   without effect
08:29:02 <maralorn[m]> madnight: That might not be enough. Maybe try deepseq?
08:29:20 <adam_wespiser> you could try ~(fileData, _)
08:29:55 <maralorn[m]> If filedata is a lazy datatype forcing itâ€˜s head might not force the rest of it.
08:30:01 <adam_wespiser> but that might not work, you need to somehow force this...
08:33:43 <madnight> adam_wespiser: nope neither ! nor ~ helps. maralorn[m]: Okay I'll give deepseq a try
08:34:32 <adam_wespiser> the other option, and how I would solve this, is to use Data.Text.IO: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-IO.html
08:35:17 <nshepperd> huh, cool. with a type checker plugin I can declare type families in 'type family Log :: Nat -> Nat' style and have them reduce to the actual implementation when applied to something
08:36:02 <nshepperd> and thereby write higher order type level functions like 'Map :: (k1 -> k2) -> [k1] -> [k2]' which actually work
08:36:24 <nshepperd> as in Map Log '[1,2,3] is allowed
08:37:04 <nshepperd> i assume this is unsafe and breaks the type system somehow though
08:40:51 <madnight> maralorn[m]: adam_wespiser: thx for your help, deepseq ($!!) works
08:41:42 <maralorn[m]> I am using TH to generate some type class instances. But I donâ€˜t seem to be getting the instances I want. Any hints on how to debug that? e.g. print the template Haskell output, print existing instances.
08:42:29 <adam_wespiser> you want "-ddump-splices" : https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html#ghc-flag--ddump-splices
08:44:50 <solonarv> nshepperd: it breaks the type system if your plugin has a bug ;)
08:44:56 <solonarv> otherwise it should be fine
08:46:34 <geekosaur> most such type system plugins are working around limitations in the typechecker, not limitations in the underlying type system
08:46:35 <nshepperd> hm, it doesn't quite work though, because eg. Typeable (Map Log '[1,2,3]) reduces to (Typeable Map, Typeable Log, Typeable '[1,2,3]) in the constraint solver before my plugin gets to it
08:46:59 <nshepperd> so that seems like it could cause unsound results
08:51:36 <nshepperd> yeah ok this makes sense. the compiler assumes that the application of Map in Map Log '[1,2,3] is pattern matchable due to already being saturated but actually it's non-injective so it'll be wrong
08:54:04 <maralorn[m]> adam_wespiser: Can you tell me how I call that with cabal?
08:55:12 <adam_wespiser> for downloading Data.Text.IO ?
08:56:24 <maralorn[m]> adam_wespiser: Uh, no. I mean the ghc option.
08:56:55 <maralorn[m]> When I use cabal new-build --ghc-option -ddump-splices I donâ€˜t seem to be able to find them anywhere.
08:57:46 <MarcelineVQ> unless you -ddump-to-file they go to stdout or stderr or something
08:58:12 <maralorn[m]> MarcelineVQ: Thx, figured it out
08:58:43 <adam_wespiser> sorry, I should have explained that!
08:58:56 <adam_wespiser> :)
09:04:54 * hackage gothic 0.1.4 - A Haskell Vault KVv2 secret engine client  https://hackage.haskell.org/package/gothic-0.1.4 (MichelBoucey)
09:05:54 * hackage cayley-client 0.4.12 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.4.12 (MichelBoucey)
09:06:31 <polyphem> sm[m], geekosaur : ok , got what i want ... build a wrapper exe that can handle +RTS -p , now i ve got my  .prof file ; thank you for help
09:06:54 <polyphem> s/build/built/
10:04:25 <Ukari> "abc" <> "d", "abc" ++ "d", which is better for string?
10:04:47 <monochrom> Same. Toss a coin.
10:06:29 <maerwald> Ukari: ++ makes it clear it's a string, even if OverloadedStrings is enabled
10:13:19 <xavo[m]> speaking of OverloadedStrings, are the from\w+ functions for overloaded literals called at runtime or compile time?
10:13:57 <xavo[m]> always wondered if the extension actually gave any sort of perf advantage compared to calling Text.pack myself, for example
10:14:00 <monochrom> Most likely run time.
10:14:08 <xavo[m]> damn
10:14:16 <monochrom> Only notational advantage.
10:14:33 <maerwald> xavo[m]: it's IsString class
10:15:05 <maerwald> Which is a wart and may change semantics in the future (especially for BytesString, since the instance is unsound)
10:15:32 <xavo[m]> I know how it works, just not sure if it's optimized at compile time
10:15:37 <maerwald> quasiquotation is a better course of action right now
10:15:47 <xavo[m]> hm, ok
10:15:55 <xavo[m]> fwiw the haskell 98 report says that the literal 3 is desugared to fromInteger (3::Integer)
10:16:12 <xavo[m]> so I wouldn't be surprised if it worked like that for the rest of the literals
10:16:35 <xavo[m]> maybe I'll ask on #ghc later
10:16:51 <xavo[m]> idk if that's the kind of thing you can ask there
10:17:08 <monochrom> Yes, it's good to ask this there.
10:18:05 <nshepperd1> how *are* string literals represented in machine code? does it generate a hundred top level closures for generating each cons cell
10:20:28 <nshepperd1> i guess i can find out with one of the many -ddump options
10:20:43 <geekosaur> they're stored in a packed representation which is dynamically unpacked (and memoized, I think, at least absent IsString)
10:21:03 <adam_wespiser> you can always inspect the LLVM or Asm output and check! 
10:21:34 <monochrom> Yeah, I just tried, one CAF for main1="hello"#, another CAF for x=unpackCString# main1
10:21:51 <nshepperd1> ah, cool
10:24:13 <nshepperd1> so for a Text literal it'll do that then do the conversion
10:26:43 <monochrom> Oh this one gets a bit more optimized.  x = Data.Text.unpackCString# main1; main1 = "hello"#
10:27:02 <geekosaur> hypothetically they could IsString the C... more or less that
10:27:06 <monochrom> Perhaps someone wrote a rewrite rule for that.
10:27:28 <nshepperd1> yeah, i was thinking that a rewrite rule could fuse the loops
10:28:48 <geekosaur> hm, I'm thinking about it in the wrong direction :(  yeh, rewrite rule
10:31:14 <adam_wespiser> Here's the Literal type from GHC, this is what's used in Core to represent literals: https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/basicTypes/Literal.hs#L118
10:33:35 <adam_wespiser> (it's a Bytestring)
10:34:12 <Cale> dminuoso: ah, yeah, I got them switched around somehow. It does make more sense that C++ would have that kind of thing :P
10:38:46 <maerwald> Illegal promoted term variable in a type: errors -- GHC is calling the cops on me
10:39:45 <maerwald> have constraint: error ~ '[some, stuff] and wanted to use it in a type application: @(foo :' error)
10:39:52 <maerwald> am I too optimistic?
10:40:32 <geekosaur> I wanna see you explain that to the responder :)
10:40:39 <monochrom> Yes :)
10:41:04 <monochrom> In general, any use of dependent typing in Haskell is too optimistic :)
10:41:18 <maerwald> but I was almost there...
10:41:32 <geekosaur> supposedly, so is ghc. supposedly
10:41:52 <monochrom> I think I'm growing into a lateral dual of you.  You speak cynically about functional purity in Haskell.  I, dependent typing.
10:42:58 <Phyx-> @tell fog sdl works, or at least the sdl2 bindings. If you let me know know the error you get with opengl I may be able to help you. It should work
10:42:59 <lambdabot> Consider it noted.
10:42:59 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant-Excepts.html -- just tried to define some handy combinators to "hide" exceptions with a default value and then all the type families shat... err, shattered over my head
10:44:00 <maerwald> I even managed to make the type checker not terminate
10:44:17 <maerwald> at least the program won't run!
10:44:27 <maerwald> still type safe, so to speak
10:45:45 <monochrom> Safety only promises that.  For actually running and being productive, that's for liveness.
10:46:19 <monochrom> (Learned the distinction kind-of-the-hard-way when in grad school for formal methods.)
10:46:51 <monochrom> Incidentally there is a topological interpretation as well, one of them is open sets, the other is closed sets, I forgot which is which.
10:47:44 <rindolf> Hi merijn and all! Can you finally save ghc's reputation and make the ghc program here: https://www.shlomifish.org/Files/files/dirs/euler630/ not slower than the cpython3 one with a similar algo?
10:50:19 <maerwald> what's the point of such a comparison if you summon the best haskellers to compete with a probably mediocre python implementation :P
10:52:38 <rindolf> maerwald: i wrote the py code - it may still be mediocre though. Anyway, currently the ghc -O2 code is slower than cpython3 and more so in comparison to pypy3
10:53:11 <maerwald> oh well, if you wrote it, you should write the haskell impl too!
10:53:12 <adam_wespiser> how much slower?
10:54:59 <adam_wespiser> I don't have the time to make this faster, but I can generally tell you that there are a couple of different approachs: The first, is performance testing with "Cost Centers" do determine where the bottlenecks are
10:57:13 <adam_wespiser> next, you can try inlining things, but to do that, you really need to inspect the generated Core
10:58:13 <madnight> python often makes heavy use of C extensions (e.g. for number crunching tasks), thus some python programms can be very fast (C like speed)
10:59:37 <rindolf> maerwald: there already is a haskell impl there and i improved its speed a little
11:00:17 <maerwald> rindolf: I get 5% improvement with {-# LANGUAGE Strict #-}
11:00:29 <maerwald> not much really
11:01:04 <rindolf> maerwald: ah
11:02:06 <rindolf> adam_wespiser: 25s for ghc vs. 12.4 s for cpython3
11:04:55 <rindolf> maerwald: thanks - 24s now
11:17:24 * hackage homplexity 0.4.6.0 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.6.0 (MichalGajda)
11:20:32 <maerwald> rindolf: mkLines seems to be the cost center
11:21:01 <maerwald> https://git.io/Jv0d2
11:22:46 <rindolf> maerwald: i see - thanks
11:29:55 <johnw> does anyone know if the category of F-Algebras and F-Algebra homomorphisms is closed and cocartesian?
11:30:45 <johnw> it's not hard to show that it's cartesian, and has initial and terminal objects
11:31:48 <maerwald> rindolf: ah, I tracked it down to M.fromListWith
11:34:25 <rindolf> maerwald: ah
11:46:11 <motherfsck> Howdy, I'm new to haskell (very comfortable in C and python).  I'm currently looking up simple example algorithms and re-writing them in different ways.  Right now I'm working through a naive implementation of n choose k, trying to remove the comprehensions, learning about guards.
11:46:20 <motherfsck> I'm not sure how the failure case should work though.  I have some example code here and would *greatly* appreciate any guidance though.  I'm sure I'm overlooking something simple. https://ideone.com/ynxg7T
11:47:16 <motherfsck> I can see where the problem happens.
11:47:43 <motherfsck> I just dont know how to replicate the behavior of the comprehension
11:54:08 <ski> motherfsck : in `failing', `x' is a list, and `xs' is a list of lists
11:54:19 <maralorn[m]> How can I use ScopedTypevariables in instance declarations?
11:54:22 <nshepperd> rindolf: i suspect the difference is mainly that python is using a mutable hash map instead of a persistent tree for the map
11:55:23 <nshepperd> which i'm sure is much faster for 2500^2/2 = 3.125M elements
11:55:50 <ski> motherfsck : redundent brackets around `x:xs' and `head xs'
11:56:29 <motherfsck> thanks
11:56:44 <ski> motherfsck : also the `<' is a bit inefficient. but perhaps it was there in the original formulation you're comparing to (in other language)
11:56:45 <geekosaur> maralorn[m]: IIRC you can't
11:57:40 <ski> motherfsck : fwiw .. i did this exercise in Prolog, and C, for fun, some years ago. the main fun was the C version, with `goto' out of, and into, a `for' loop
11:57:42 <maralorn[m]> geekosaur: What?
11:58:08 <maralorn[m]> Thatâ€˜s unfortunate.
11:58:08 <ski> (the Prolog was trivial, of course. just for comparision with how much simpler it was)
11:58:09 <maralorn[m]> Is there some kind of general workaround?
11:58:23 <Gurkenglas> motherfsck, x = [i | i <- [1..(n - k + 1)]] <- you wanted to make x be the different i in that list in turn, but you defined x to be that whole list
11:58:25 <geekosaur> there's the InstanceSigs extension but IIRC ScopedTypeVariables doesn't work there
11:58:49 <ski> Gurkenglas gives it away
11:59:26 <Gurkenglas> It's an exercise? I thought he was asking for what mistake he made :(
11:59:55 <motherfsck> Gurenglas, it's both. Self guided exercise, that has some obvoius mistakes I don't see
12:01:01 <maralorn[m]> geekosaur: Yeah, just tried it.
12:01:17 <maralorn[m]> didnâ€˜t work.
12:01:20 <motherfsck> Also, Gurkenglas, Do you mean x = [1..(n-k+1)]? 
12:01:51 <Gurkenglas> Given that he talked as though he wrote failing himself, and people didnt call him out on it, imma not feel so bad ^^ and looks like i didnt give it away after all
12:02:14 <maralorn[m]> Is there another reason for that then no one got around to proposing that feature?
12:02:30 <geekosaur> not that I'm aware of
12:02:31 <maralorn[m]> I feel like the Code I am trying to write is completely reasonable.
12:03:55 <ski> well spotted, motherfsck
12:04:32 <motherfsck> 1. I did write the failing myself, not the success one a co-worker wrote that (we're in a book club working through chapter 4 of learnyouahaskell).
12:04:33 <geekosaur> although it seems to me that the class's method signature is the one that really matters and having a specific behavior on a particular instance is violating the class's contract in some sense
12:04:37 <ski> motherfsck : did you see yet the problem i hinted at ?
12:04:43 * motherfsck looks above
12:06:02 <motherfsck> Gurkenglas's suggestion doesn't change the result, but does make me think that I need to iterate over that list.  and Ski, the `<`?
12:06:10 <geekosaur> well, I guess STV shouldn't change the contract, only behavior inside the instance method. so a hack might be to define the instance method to call some function, and then STV the function's signature
12:06:48 <geekosaur> maybe this should work but I susepct InstanceSIgs is currently fairly simple and doesn't support this
12:06:55 <maralorn[m]> geekosaur: I think actually, that the typeapplication I tried wasnâ€˜t necessary.
12:07:06 <maralorn[m]> So it doesnâ€˜t matter.
12:07:31 <maralorn[m]> Now I have a magical: Functional dependencies conflict between instance declarations.
12:07:35 <maralorn[m]> This is fun.
12:10:05 <ski> motherfsck : consider again `x < head xs'
12:10:10 <ski> what do you think that does ?
12:14:05 <motherfsck> Hm, comparing a list to the head of a list, which happens to be a list
12:15:31 <ski> yep
12:15:51 <ski> and you know how list comparisions work, in Haskell ?
12:18:38 <motherfsck> I should have looked it up, but I was working on the assumption it checks the elements in order until it hits a false
12:20:43 <ski> motherfsck : it uses lexicographic ordering, not a pointwise ("parallel"/"locksynch") one
12:21:00 <ski> (the idea is to have a linear order, not a mere partial order)
12:21:29 <ski> (perhaps it's "lockstep" people say .. hm)
12:23:51 * motherfsck goes off to look that up
12:24:49 <motherfsck> ok, comparison is made on the first element that differers then
12:26:57 <motherfsck> which is what I would have said if I were actually able to turn my thoughts into words.
12:27:54 <ski> do you see (one reason) why your code doesn't do what you intended, now ?
12:30:59 <motherfsck> I'll need a minute to think it through, I'm slow at this and I haven't figured out how to properly plumb in some sort of logging where I can visualize the values.
12:31:36 <motherfsck> And, the fact that my children are heathens doesn't help with my concentration
12:34:35 <maerwald> rindolf: I'm down to 15s
12:35:18 <rindolf> maerwald: ah, nice
12:35:24 <maerwald> I think the old implementation was ~19s on my laptop
12:35:46 <ski> motherfsck : take your time
12:36:23 * ski idly notes ChanServ's out for a walk
12:40:01 <geekosaur> they announced this yesterday, services moving to a new machine
12:40:10 <geekosaur> hm, we forgot to op someone up
12:41:39 <iqubic> Yeah.
12:43:23 --- mode: weber.freenode.net set +o ChanServ
12:43:33 * ski hugs ChanServ
12:48:49 <maerwald> rindolf: https://github.com/hasufell/euler630-mniip
12:49:02 <maerwald> basically just using hastables in ST
12:49:13 <maerwald> But it's still not that nice
12:51:31 <maerwald> the package https://hackage.haskell.org/package/hashtables has multiple implementations, ST.Basic was the fastest for me
12:53:51 <maerwald> so the cost center is down from 82 to 70 % at least
12:54:17 <maerwald> alloc is from 67 to 20
12:54:52 --- mode: ChanServ set +o dibblego
12:54:55 --- mode: ChanServ set -o dibblego
12:55:44 <motherfsck> ski, ok so, there is something about the comprehension that I missed.  For multiple items in a comprehension, they are nested loops. something like [result | thing one, for everything in thing two, bool]
12:56:17 <ski> yes
12:56:31 * motherfsck facepalm
12:56:36 <nshepperd> maerwald: try HC.mutate, seems to be faster than lookup-and-insert
12:56:42 <maerwald> ah
12:59:06 * ski idly glances in motherfsck's general direction
12:59:53 <motherfsck> I knew it felt like a problem with iteration.
13:00:15 <motherfsck> i am not a smart man.
13:00:50 <motherfsck> I was under the impression that I would have to recur on the failure case, I needed to iterate over the list though.
13:01:25 <rindolf> maerwald: thanks, i'll try to check it out tomorrow - now i'm going to sleep
13:01:31 <motherfsck> thanks ski
13:01:31 <rindolf> maerwald: gn
13:03:28 <maerwald> nshepperd: hm, it returns a different result now though xD
13:04:23 <nshepperd1> err
13:04:50 <nshepperd1> it shouldn't :p
13:06:21 <ski> motherfsck : so, what's the new version ?
13:06:31 <ski> also, yw
13:08:21 <motherfsck> Oh, I don't have it yet. But I'm working on the assumption that I'm going to have to do something in the where clause
13:08:34 <motherfsck> I'll definitely share it once i have an idea
13:08:47 <maerwald> nshepperd: ah, works now... saved 1 sec
13:10:14 <motherfsck> maybe a second function with the nuber of elements in x. Not sure yet
13:10:55 <maerwald> 13.9 vs 11.8 sec, not too bad
13:11:18 <maerwald> surprising that 3/4th of the cost is just insertions/lookups
13:11:43 <ski> motherfsck : are you familiar with `map' ?
13:12:50 <motherfsck> yea. So map the recursion over x
13:13:06 <ski> there's multiple way to do it, of course
13:13:11 <ski> but that might be one way
13:15:55 <motherfsck> thanks again, I gotta step away for a bit now though
13:16:55 <ski> motherfsck : feel free to ask more later, if i'm around
13:18:08 --- mode: weber.freenode.net set +o ChanServ
13:20:25 <maerwald> hexagoxel: https://gist.github.com/hasufell/8a2f41ede7977504da7913da85d1660e#file-foo-hs-L11 type level lists in brittany are not line-broken at all it seems
13:20:44 <maerwald> my exception type level list is growing a bit out of hands
13:24:46 <quark17> I put ghcup on my mac, and can run the cabal and ghc that it installed, but when I install a library with "cabal install", the ghc can't find that package.  do i need to tell cabal to install into a particular location, or ghc to look in a particular location?
13:25:29 <sclv> if youâ€™re using cabal 3 the workflow is fundamen differentl
13:25:44 <sclv> You need to learn about new-build
13:25:45 <geekosaur> cabal3 installs libraries to its own cache and expects you to use a cabal file to specify the libraries you need. there's cabal v1-install but that can create messes
13:30:13 <quark17> maybe my question is: what's the best way to put ghc on a mac and install a few libraries?  I used to install ghc on macports and everything just worked, but it that's currently broken on Catalina, and I have no idea when that'll be fixed, so I thought I'd explore other things, but I'm having no luck.  I figured the Platform would also "just work" so that's why I tried it.  it does appear to be cabal v3.  
13:30:35 <glguy> quark17: I prefer using ghcup on my macs to install GHC versions
13:30:52 <sclv> So you did everything right by using ghcup
13:31:05 <sclv> You just need to learn new install
13:31:18 <sclv> Or use v1-install for now
13:31:30 <sclv> same commands, behind a v1 prefix
13:32:27 <quark17> what does it mean to "learn new install"?
13:33:48 <glguy> I means "start using cabal-install-3.0.0.0" and just type commands like "cabal build"
13:34:43 <quark17> I used "cabal install regex-compat" and the command succeeded.  but then "ghc ... -package regex-compat ..." says it can't find the package.
13:35:31 <monochrom> If you want the latter to work, the former needs to be s/install/v1-install/ , which is what they were talking about.
13:35:57 <sclv> in the new system you donâ€™t manually install libs
13:36:03 <monochrom> However, most people prefer per-project-visible packages, that's what "new install" is for.
13:36:17 <sclv> Just build packages that depend on them and the deps are managed for you
13:36:55 <sclv> its documented in the last section of the cabal users guide
13:37:20 --- mode: ChanServ set +o Sigyn
13:37:33 <monochrom> I would have fully migrated to the per-project way if not for unpredictable doc locations.
13:37:34 <quark17> i'm looking at a v3 document and it says just to use "cabal install"
13:37:40 <maerwald> quark17: what are you trying to do? you want a ghci session with some libraries?
13:38:12 <glguy> quark17: You won't need to run the "ghc" command any more
13:38:26 <maerwald> cabal repl --build-depends regex-compat
13:38:37 <maerwald> will open a ghci session with regex-compat
13:38:44 <quark17> I have source code with its own makefile that runs "ghc", and I just want to type "make" in this source and build it :)
13:39:58 <quark17> eventually, I'd be curious to learn how to edit the makefile to build in a better/newer way, but first I'd just like to build
13:41:30 <quark17> looks like "cabal v1-install" is allowing that
13:41:53 <maerwald> quark17: cabal install --lib regex-compat
13:42:24 <monochrom> Hrm, that --build-depends flag is handy, thanks.
13:42:25 <maerwald> but that might cause you trouble sometime later. You should be aware that this creates a file ~/.ghc/x86_64-linux-8.6.5/environments/default
13:42:37 <maerwald> if you have trouble with cabal later, consider deleting that file
13:42:56 <quark17> maerwald: I did that command you said, but then the ghc command would fail.
13:43:13 <maerwald> fail how
13:43:31 <quark17> <command line>: cannot satisfy -package regex-compat
13:44:04 <maerwald> mind linking to the package you're trying to build?
13:44:39 <quark17> https://github.com/B-Lang-org/bsc/tree/master/src/comp
13:45:06 <maerwald> oh boy
13:49:38 <maerwald> I wonder if a sandbox will do
13:51:48 <Gurkenglas> I've opened https://www.gwern.net/hakyll.hs in VSCode and ghcide, and it says that it can't find lots of those imported modules. How should I fix that?
13:53:09 <monochrom> I saw this at line 10-11:
13:53:19 <monochrom> Debian dependencies:
13:53:19 <monochrom> $ sudo apt-get install libghc-hakyll-dev libghc-pandoc-dev libghc-filestore-dev libghc-tagsoup-dev libghc-yaml-dev imagemagick s3cmd git libghc-aeson-dev libghc-missingh-dev libghc-digest-dev tidy gridsite-clients
13:53:36 <monochrom> Perhaps you can infer hackage packages from that.
13:53:49 <maerwald> quark17: I get the same error
13:58:07 <maerwald> quark17: hah, I got it
13:58:22 <maerwald> GHC="ghc -package-env default" make
13:58:45 <quark17> maerwald: v1-install works for me.  I only use cabal to install packages for ghc, so i don't expect to have problems.  it'd be interesting to learn how to modernize that build (or make it worth for different types of build?)
13:58:54 <quark17> maerwald: oh, hm
13:59:19 <maerwald> that will pick up the libs from 'cabal install --lib ...' from the file ~/.ghc/x86_64-linux-8.6.5/environments/default
14:08:38 <xavo[m]> oh man
14:08:43 <xavo[m]> after learning a bit more about the rest of optics outside of lenses
14:09:39 <xavo[m]> going through some old code and I found a bit where I did the ReaderT/IORef thing
14:10:27 <xavo[m]> but to do what's essentially `set` with `traversed`, I pulled out `for_` and `%=` and then wrapped it all up in (&~)
14:10:51 <xavo[m]> what was I doing
14:11:37 <xavo[m]> (sorry, `over`, not `set` in this case)
14:24:08 <Arney> xavo[m]: how does one right cursive :o
14:27:20 <hexagoxel> maerwald: https://gist.github.com/hasufell/8a2f41ede7977504da7913da85d1660e#gistcomment-3186737
14:27:57 <maerwald> I would just ignore the ' prefix
14:27:58 <Arney> well, that's easy to remember :o
14:28:05 <maerwald> and indent as if it was a regular list
14:28:16 <Arney> test
14:28:45 <Arney> test
14:28:48 <hexagoxel> maerwald: what did you expect me I did? I just copied over the list layouter of course :p
14:28:49 <Arney> :o
14:38:35 <hexagoxel> maerwald: will merge into master once tests are green
14:38:41 <maerwald> thanks!
15:27:30 <jol> Could someone help me out to see what I'm doing wrong? I'm sure it's something very dumb. I've just created a new project with `stack new` and added a git repo in extra-deps. stack's/ghc's output as well as stack.yaml.lock seem to indicate that the repo was recognized. However, trying to import a module from it tells me that the module could not be found. Here's a pastebin:
15:27:33 <jol> http://dpaste.com/3WQGH8T.txt
15:28:38 <maerwald> jol: did you edit your cabal file?
15:28:56 <jol> No. Isn't it generated by stack based on stack.yaml?
15:29:12 <maerwald> no
15:29:27 <maerwald> do you have a package.yaml?
15:29:44 <jol> Sorry, package.yaml. Yes.
15:29:55 <maerwald> delete it and edit the cabal file directly
15:31:02 <jol> What should I do with the cabal file?
15:31:22 <jol> Was I supposed to add the git repo as a dependency in package.yaml?
15:31:23 <maerwald> then see https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
15:31:37 <maerwald> no, just add optparse-applicative to build-depends
15:34:41 <solonarv> in 'packagename.cabal', you say "I need package foo, version blah"
15:35:09 <solonarv> in stack.yaml you can specify "here is an additional location where you can find packages: (a git repository, a local folder, a tarball, ...)"
15:35:50 <MarcelineVQ> more broadly https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
15:37:38 <jol> That clears things up. Thank you all so much. :)
15:42:05 <travv0> you still need to add the dependency to your package.yaml, the extra-deps just tell it where to get it from
15:42:20 <travv0> whoops i was scrolled up
15:42:43 <maerwald> package.yaml just adds more confusion
15:50:31 <jol> solonarv: Thank you for mentioning the ability to use a local folder in stack.yaml's extra-deps. Pantry's documentation doesn't mention that.
15:51:14 <zeta_0> could someone explain to me the strictness flag: ! and how it forces evaluation with a simple example?
15:53:15 <maerwald> zeta_0: https://downloads.haskell.org/~ghc/8.8.2/docs/html/users_guide/glasgow_exts.html#bang-patterns-and-strict-haskell
15:53:16 <jol> zeta_0: (\ !x -> True) undefined causes an exception, but (\ x -> True) undefined returns True.
15:54:16 <jol> That's `(\ !x -> True) undefined` and `(\ x -> True) undefined`.
15:54:45 <opticblast> Is there a way to lift values of type StateT s Identity a to StateT s IO a, or am I going about this the wrong way?
15:55:24 * hackage dhall-fly 0.2.4 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.2.4 (axeman)
15:56:14 <jol> You can lift from one layer of a stack to another. Like from IO to `StateT s IO`, but the ones you mentioned are completely different stacks.
15:56:48 <opticblast> To avoid the XY problem: I have a bunch of functions defined for State and I want to use them in a StateT context
15:57:17 <opticblast> Is that possible or will I have to change all their definitions?
15:57:29 <jol> Not possible, change all their definitions.
15:57:45 <glguy> state . runState :: MonadState s m => State s a -> m a
15:58:20 <jol> I think I've just been proven wrong. That's neat.
16:00:06 <zeta_0> maerwald jol : so strictness is the opposite of laziness?
16:00:16 <jol> Yes.
16:00:23 <opticblast> Huh. That's neat. Thanks
16:04:52 <zeta_0> so lets say i have a data type TodoItem which contains a record, and one of it's fields is: { tiItem :: !Index }, what does thes strictness ! mean in this case?
16:09:44 <Axman6> it means that if the constructor for the record is evaluated, that field will also be evaluated
16:09:45 <glguy> zeta_0: Strictness Flags Whenever a data constructor is applied, each argument to the constructor is evaluated if and only if the corresponding type in the algebraic datatype declaration has a strictness flag, denoted by an exclamation point, â€œ!â€. -- https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-710004.2.1
16:14:23 <zeta_0> thanks it's making a little more sense, so are strictness flags ! mostly needed when you need better performance? so laziness slows things down?
16:15:49 <glguy> No strictness is needed when you've determined that it benefits you to evaluate something more strictly than might be by default. Laziness isn't necessarily slower, but it can be. It's case by case if you'd want to potentially store thunks in a data structure or not
16:16:21 <glguy> and in addition the additional strictness from a strict field won't deeply eliminate laziness from that field, it just forces the outermost constructor
16:28:43 <zeta_0> oh see, thanks for the info guys
16:29:00 <[rg]> is the lexical syntax of haskell still this short? https://www.haskell.org/onlinereport/haskell2010/haskellch10.html
16:30:03 <adam_wespiser> yes, but there are some language pragma that will affect parsing
16:30:55 <Axman6> it's worth keeping in mind that that grammar doesn't really account for indentation
16:31:03 <[rg]> thats all good
16:31:11 <[rg]> I'm just happy it's short
16:31:52 <[rg]> whats haskell like for server programming?
16:32:00 <adam_wespiser> really good
16:32:15 <adam_wespiser> check out Servant, I think it's an awesome way to build servers
16:32:28 <adam_wespiser> err, specifically REST Api's
16:32:54 * hackage rings 0.1.1.1 - Ring-like objects.  https://hackage.haskell.org/package/rings-0.1.1.1 (cmk)
16:33:35 <[rg]> ok, it looks like haskell is quite nice
16:33:43 <[rg]> the catch is just the math I guess
16:33:59 <Axman6> Haskell is absolutely fantastic for writing servers in, the incredibly lightweight concurrency means you just write code which handles a single connection, and then fork a new thread per connection. 10's of thousands of theads (and therefore connections) works fine
16:34:09 <Axman6> what maths?
16:34:57 <[rg]> what's a monad?
16:34:58 <[rg]> lol
16:35:28 <Axman6> who cares?
16:35:41 <Axman6> everyrthing's a monad, if you've ever programmed you've used dozens of monads
16:36:26 <adam_wespiser> is a monad composed with another monad a monad? :P
16:36:30 <[rg]> I mean, that doesn't really help
16:36:35 <Axman6> ever had to deal with null values containing null values? monad. ever done simething with all the elements of one array matched with all the elements of another array? monad. Ever printed something to a screen? monad
16:36:44 <[rg]> you have to admit that haskell tends toward the academic side
16:36:59 <zaifir> [rg]: Computing involves a lot of mathematics.  It's not just Haskell, and it's a positive thing.
16:37:26 <[rg]> zaifir, yes that is true
16:37:31 <Axman6> [rg]: The people paying me to write haskell in my last three jobs weren't academics
16:37:54 <adam_wespiser> Definitely academic: that's one of ghc aims, to be a production worthy compiler capable of language research
16:37:56 <Axman6> just because we actually call a spade a spade doesn't make us academics
16:38:31 <[rg]> in my experience it seems to be a bit more, like for C code, you don't have to be an expert in automata theory, but even the principles are more "accessible"
16:38:49 <Axman6> no, more familliar
16:38:51 <[rg]> adam_wespiser, ok
16:38:54 <Axman6> familiar*
16:39:03 <[rg]> that does make sense
16:39:07 <adam_wespiser> well, you don't need a graduate degree to use Haskell, or even to contribute to ghc
16:39:30 <zaifir> [rg]: The semantics of C programs can be really, really complicated!  As Axman6 says, the patterns may just be more familiar.
16:39:35 <[rg]> where do I start? I'm familiar with miranda
16:39:45 <Axman6> I've always liked this as an introduction to how simple monads actuallty are, and how often you've probably used them: https://codon.com/refactoring-ruby-with-monads
16:40:17 <[rg]> zaifir, you do have a valid point, but I think it glosses over the obvious
16:40:17 <zaifir> [rg]: Hutton's _Programming In Haskell_ is an excellent intro.
16:40:36 <[rg]> even my prof has said he didn't bother keeping with haskell
16:40:44 <[rg]> and he's an expert
16:41:13 <[rg]> alumi with a lot of famous people
16:41:13 <zaifir> [rg]: I'm not sure what you're trying to say.
16:41:43 <adam_wespiser> yea, does that mean therefore we, being less academically qualified, cannot keep up with Haskell?
16:42:13 <Axman6> [rg]: You might weant to tell Facebook their sigma system, which halved the number of servers they needed for spam filtering, is a failure then
16:42:15 <[rg]> no, it means that, you can't have an argument to say, it's like learning c code
16:43:09 <Axman6> I've seen children learn Haskell, it's a very simple language, it just gives you the power to build arbitrarily complex systems, which many languages fail to do
16:43:39 <zaifir> [rg]: Do you think C is easier than Haskell?  If so, why?
16:43:45 <adam_wespiser> I think Haskell's "killer feature" so to speak, is the ability to refactor
16:44:41 <Axman6> C is deceptively complex, and _extreemely_ difficult to write well.
16:45:19 <[rg]> zaifir, the procedural style, and the use of it to manipulate state
16:46:27 <zaifir> [rg]: OK.  But now you want to learn Haskell, correct?
16:46:58 <[rg]> yeah
16:47:22 <zaifir> [rg]: Well, good! :)
16:48:48 <[rg]> yes
16:50:52 <jle`> [rg]: for what it's worth you really don't need to know any 'math' to do haskell
16:51:08 <jle`> so i wouldn't quite call it a catch
16:51:54 <[rg]> ok, I get what you guys are saying, and I agree
16:52:16 <monochrom> I say that you need the aptitude.  http://www.vex.net/~trebla/haskell/prerequisite.xhtml
16:52:55 <[rg]> maybe this makes more sense if I say that I want to understand, e.g. you don't need to know how a computer(compiler) works to program
16:53:00 <[rg]> but I want to know
16:53:18 <jle`> [rg]: right, that's the true curse of haskell
16:53:22 <jle`> not that you will need to learn the math
16:53:27 <jle`> but that you would *want* to learn it ;)
16:54:16 <jle`> it'll turn you into a person who wants to learn math just for the sake of learning it, without practical application. and that in itself is somewhat of a scary thought
16:54:20 <zaifir> [rg]: Maybe you'd be interested in SICP, then, as well.
16:54:54 <zaifir> jle`: Becoming a person who *wants* to learn is a scary thought? :)
16:55:08 <jle`> it can be
16:55:20 <jle`> some people already have a delicate relationship with time management in their life
16:55:27 <[rg]> well you see, I don't have time for sicp :/
16:55:29 <jle`> adding another component can throw off a lot of productivity
16:56:19 <adam_wespiser> it's true, I've never learned Latex because I'm convinced I'll never **need** it
16:57:05 <zaifir> [rg]: It's worth appending to your read queue.  But indeed, ars longa, vita brevis.
16:58:41 <[rg]> im unsure of scip, I feel like I'd get more out of wirth material, anyways can we talk about the type system?
16:58:55 <[rg]> just so I can dip my toes or whatever the analogy is
16:59:59 <Axman6> HAskell's type system is also very simple (though can be made more complex, particularly with extensions). You should view the type system as a second language, which dances hand in hand with the program, both keeping the other one in check
17:00:29 <[rg]> can you show me how a polynomial would be defined?
17:00:43 <jle`> a type encoding a polynomial?
17:00:49 <[rg]> would you go as far as using an algebraic data type for this?
17:00:56 <[rg]> or just use a list of tuples?
17:01:05 <jle`> a polynomial i would probably just encode as [Int]
17:01:13 <jle`> or [Double]
17:01:32 <jle`> where the first item is the 0th degree, the second item is the 1st degree coefficient, the second is the 2nd, etc.
17:01:40 <jle`> but lists are an algebraic data type, remember
17:01:48 <jle`> data List a = Nil | Cons a (List a)
17:01:56 <[rg]> oh wow
17:01:58 <jle`> so the answer to your question is 'yes'
17:01:58 <Axman6> yeah, where each element c represents c*x^(index of c)
17:02:35 <[rg]> ok, this is from hoare's work?
17:02:54 <adam_wespiser> No, this is from: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&rep=rep1&type=pdf
17:02:58 <[rg]> I saw a book in the library called programmers algebra or something like that
17:03:05 <Axman6> you can also make this type al instance of the Num class so you can use standard operators on them - addition is just zipWith (+) for example
17:03:06 <[rg]> it had a lot of definitons like this
17:03:20 <Axman6> (uh, not quite, that will lose information)
17:03:27 <adam_wespiser> It's a power series representation of infinite lists, along with all the operations
17:04:06 <[rg]> Axman6, what will it lose?
17:04:36 <Axman6> zipWith drops the end of the longer list (which it of course must if you look at its type)
17:04:40 <Axman6> :t zipWith
17:04:42 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:04:54 <jle`> > zipWith (+) [1,2,3] [5,6,7,8]
17:04:56 <lambdabot>  [6,8,10]
17:05:00 <jle`> whoops
17:05:11 <Axman6> you need a version of zipWith which keeps the remainder, which means it must have type (a -> a -> a) -> [a] -> [a] -> [a] 
17:05:47 <jle`> > zipWith (+) ([1,2,3] ++ repeat 0) [5,6,7,8]
17:05:49 <[rg]> why would they do that?
17:05:50 <lambdabot>  [6,8,10,8]
17:06:13 <[rg]> it makes sense for zipWith to just append the longer part
17:06:29 <Axman6> how can it?
17:06:57 <jle`> [rg]: remember lists in haskell are homogeneous, they must contain elements all of the same type
17:07:08 <Axman6> :t zipWith
17:07:10 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:07:13 <[rg]> ok
17:07:30 <jle`> [rg]: so you cannot append the longer part if the longer-part items are a different type than the resulting list's elements
17:07:32 <Axman6> if the list of a's is longer, you need to be able to turn the a's into c's
17:07:43 <[rg]> does haskell have type synonyms
17:07:54 <Axman6> yes
17:07:58 <[rg]> and, why does the notation use a b c?
17:08:04 <jle`> those are variables
17:08:09 <jle`> you can use whatever variable names you want
17:08:11 <zaifir> [rg]: You might get a better sense of all this by reading something like _Programming In Haskell_, or another good basic Haskell text.
17:08:19 <Axman6> but it also has the much more powerful newtype, which lets you make a completely new type from an existing one
17:08:52 <jle`> [rg]: (floopy -> boopy -> scoop) -> [floopy] -> [boopy] -> [scoop] is equivalent
17:08:53 <[rg]> zaifir, I've seen expressions like (* -> * -> *) -> [*] -> [*] -> [*] which seems a bit more intuative
17:09:13 <jle`> [rg]: the problem with that is that you can't differentiate between what variables should be the same, and what should be separate
17:09:37 <Axman6> [rg]: but conveys far less information
17:09:37 <Cale> It would have to be (* -> ** -> ***) -> [*] -> [**] -> [***] in the old Miranda notation
17:09:40 <jle`> when you read (a -> b -> c) -> [a] -> [b] -> [c], the important thing is that the first argument of the input function is the same type as the elements in the second argument's list
17:10:07 <[rg]> Cale, yep
17:10:24 <jle`> sometimes it can be useful to use readable variable names
17:10:35 <jle`> instead of being forced to write *, **, ***
17:10:47 <Axman6> List<C> zipWith<A,B,C>(C Func<A,B>, List<A>, List<B>)
17:10:54 * hackage selective 0.4 - Selective applicative functors  https://hackage.haskell.org/package/selective-0.4 (snowleopard)
17:10:55 <jle`> also it's a little easier to distinguish between a and b, than between ***** and ******
17:11:01 <zaifir> [rg]: Many books use Î±, Î², Î³, etc. for type variables.
17:13:14 <[rg]> Axman6, can you show me a type synonym of a polynomial? 
17:13:47 <Axman6> type Polynomial a = [a]
17:13:55 <Axman6> not very useful
17:14:35 <Axman6> newtype Polynomial a = Polynomial [a] is slightly more useful, because not all lists should be treated as polynomials, and polynomials shouldn't be treated as lists in a lot of places
17:15:30 <[rg]> ok, thanks
17:23:43 <[rg]> what platform are you guys on?
17:27:46 <MarcelineVQ> platform? :>
17:28:29 <[rg]> minor thing but the windows binaries are not signed?
17:57:01 <zeta_0> error couldn't match ByteString with String? https://hastebin.com/higacicife.makefile
17:57:22 <zeta_0> what am i supposed to replace "add" with?
18:01:22 <MarcelineVQ> at a blind guess you might need OverloadedStrings, there's really not enough context to say
18:01:59 <jle`> it is unclear where 'symbol', etc. are from
18:02:02 <MarcelineVQ> in particular a full error is much more useful than part of it
18:02:13 <jle`> and Add, descriptionAndTagsParser, etc.
18:02:24 <jle`> so much could be happening here, heh
18:02:40 <jle`> but yeah, a full error message would probably reveal almost all the information needed
18:02:59 <jle`> it will tell us exactly where the error is happening
18:03:06 <jle`> or at least a better clue than what we have no
18:03:08 <jle`> *now
18:23:02 <monochrom> Beginners have the talent of exactly cutting away the most important part. It's like they actually know.
18:24:16 <zeta_0> here's the corresponding import: import qualified Data.ByteString.Char8 as B
18:25:10 <zeta_0> couldn't match expected type B.ByteString with actual type [Char]?
18:25:49 <zeta_0> sorry i took so long to respond
18:35:21 <adam_wespiser> :t pack
18:35:22 <lambdabot> error:
18:35:22 <lambdabot>     â€¢ Variable not in scope: pack
18:35:23 <lambdabot>     â€¢ Perhaps you meant one of these:
18:36:04 <adam_wespiser> you might need `pack` from Data.ByteString.Lazy.Char8
18:36:22 <adam_wespiser> https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Lazy-Char8.html#v:pack
18:36:52 <zeta_0> atomi: so replace symbol with pack?
18:37:13 <zeta_0> sorry that was meant for adam_wespiser
18:39:10 <adam_wespiser> something like: symbol . pack $ "add"
18:39:31 <adam_wespiser> but I cant be sure without the full error message and knowledge of the type of "symbol"
18:39:33 <zeta_0> adam_wespiser: i replaced symbol with B.pack and it throws another error: couldn't match expected type with ParsecT ?
18:40:15 <adam_wespiser> what's the type of symbol?
18:41:20 <zeta_0> adam_wespiser: Query.symbol :: ByteString -> Parser ()
18:42:01 <adam_wespiser> yea, and if the type of "add" is String, then you can compose "symbol . pack" and get something of type "String -> Parser"
18:42:43 <Axman6> zeta_0: if you weant people to help, you have to stop keeping information from them - share all the code and the whole error message. it looks like there are several ways to solve your problem but we can't know without more information
18:43:16 <zeta_0> ok i'll pastebin the whole file, one second
18:44:23 <zeta_0> https://hastebin.com/vegutufige.sql
18:46:24 <zeta_0> on all the Strings it is throwing the error message could not match expected type B.ByteString with actually type [Char]?
18:51:25 <Axman6> right, unless you have turned on the OverloadedStrings language extension, "foo" has type String
18:52:08 <adam_wespiser> Can anyone explain why happened to Cloud Haskell? It was working, but now it's not?
18:53:09 <zeta_0> Axman6: oh that worked, the errors went away, thanks
18:53:17 <zeta_0> adam_wespiser: thanks as well
18:55:34 <Axman6> adam_wespiser: I don't think there's much active development on it for a while, I guess it never found a killer app or someone willing to extend it beyond the initial proof of concept
18:56:52 <Axman6> the fact it required the exact same binary to everywhere to be able to send closures always seemed like qwuite a big limitation to me, it meant that something like mapreduce was never going to be as flexible as something JVM based where you could send new code to the system
18:58:13 <adam_wespiser> i didn't realize it had that limitation
19:02:31 <adam_wespiser> I know there is some cool compiler tricks behind cloud haskell, like StaticPointers pragma, and it makes distributed programming a little easier for some applications
19:29:42 <topos> phadej https://github.com/phadej/binary-tagged this package is super cool. I'm glad it exists!
19:30:10 <zeta_0> how do i import a module from a different directory? in my case it is a sub-directory?
19:31:18 <Cale> zeta_0: Generally, you name the modules in a way which correspond to which path the compiler is going to look for them in
19:31:37 <Cale> So you'd put the module A.B.C in A/B/C.hs
19:35:53 <zeta_0> Cale: ok, in the root directory of my project I have Main.hs which is going to run the my app, and a src/ directory which contains my modules, but Main.hs is not recognizing them
19:36:17 <Cale> Yeah, if you want to have a src directory, put Main.hs inside it
19:36:23 <monochrom> Maybe you should put them in the same directory.
19:40:19 <Cale> If you have, e.g. src/Main.hs and src/MyApp/Types.hs (which starts with "module MyApp.Types where"), then from Main.hs you should be able to import MyApp.Types and GHC will know how to find it.
19:43:28 <zeta_0> Cale monochrom : thanks, i need organize my code better, i did a cabal init so i have files all over the place
19:45:37 <zeta_0> ok, i organized and fixed it, thanks again for the help
19:59:42 <zeta_0> Cale: hello there, i sent you a message
20:09:37 <zeta_0> '
20:10:35 <zeta_0> Cale: nevermind, i'll continue project in a while
20:39:54 * hackage test-fun 0.1.0.0 - Testable functions  https://hackage.haskell.org/package/test-fun-0.1.0.0 (lyxia)
21:05:54 * hackage quickcheck-higherorder 0.1.0.0 - QuickCheck extension for higher-order properties  https://hackage.haskell.org/package/quickcheck-higherorder-0.1.0.0 (lyxia)
21:06:20 <Io> Hey guys whats up, I'm learning Haskell yet I have a doubt that has been troubling me for a while already. Im working on an exercise from RealWorldHaskell. I'm defining a TypeClass called JSON which has fromJValue and toJValue. My question is, how does the compiler know what Im trying to convert from when all JValues are of type JValue and the function to convert the JValue is defined inside the type instances(Integer, Int, Double, String, etc.)
21:07:50 <pavonia> It infers it either from the input or result type of the conversion functions
21:10:17 <Io> So what should I place inside the JValue instance? because if I don't define it, it complains. 
21:10:46 <Io> Right now fromJValue returns Either JsonError a
21:11:22 <pavonia> Perhaps you should paste some real code, so we can see what exactly you are trying to do
21:11:54 <monochrom> This smells like you're going too fast and you should have nailed basic "toy" examples before attempting this.
21:12:39 <Io> You may be right, the book just goes so fast.
21:13:17 <monochrom> The problem with "I learn best from dive-in oh-so-real-world projects".
21:13:22 <Io> If you do have a recommendation for any other book i would appreciate it
21:14:41 <Io> this is an example instance of JBool which is a constructor for JValue
21:14:44 <Io> instance JSON Bool where
21:14:44 <Io>   toJValue = JBool
21:14:44 <Io>   fromJValue (JBool b) = Right b
21:14:44 <Io>   fromJValue _         = Left "Not a JSON boolean."
21:15:09 <Axman6> > read "True" :: Bool
21:15:12 <lambdabot>  True
21:15:16 <monochrom> Hudak's "Haskell School of Expression" or Bird's "Thinking Functionally with Haskell" or Graham's "Programming in Haskell" or https://en.wikibooks.org/wiki/Haskell
21:15:25 <Axman6> > read "\"Hello\"" :: String
21:15:29 <lambdabot>  "Hello"
21:15:35 <Io> instance JSON Double where
21:15:36 <Io>   toJValue = JNumber
21:15:36 <Io>   fromJValue = jValueToDouble id
21:15:40 <Io> the problem is here 
21:16:01 <Io> instance JSON JValue where
21:16:01 <Io>   toJValue = id
21:16:01 <Io>   fromJValue = Right
21:16:08 <Axman6> > read "\"Hello\"" -- We didn't tell the coimpiler what type so I can't know which instance to use, but will probably default to ()
21:16:11 <lambdabot>  *Exception: Prelude.read: no parse
21:17:11 <Io> so whenever i have a jValue and invoke fromJValue it returns an empty Right?? Yet when I do it it magically works
21:17:23 <Axman6> what determines which instance is used is ho the value returned in the code is used - if the compiler can't tell what type you wanted to use, it will give you an error, because it can't know, even if it has access to the JValue
21:17:54 <Axman6> fromJValue = Right is the same as fromJValue jvalue = Right jvalue
21:18:09 <Axman6> remember that Right is a function of type b -> Either a b
21:18:30 <Axman6> so in this caxe it's bsing used as JValue -> Either String JValue
21:18:33 <Axman6> case*
21:19:08 <Io> yes, but how does it know the implementation? it is returning for Integer, Right 6 for example
21:19:16 <Axman6> fromJValue = Right  is just alpha reduction, the _function_fromJValue is the _function_ Right 
21:19:38 <Axman6> you haven't mentioned integers anywhere
21:20:26 <fog> @tell Phyx- the error from OpenGL is something like; "glut init error"
21:20:26 <lambdabot> Consider it noted.
21:23:31 <ski> s/alpha reduction/function extensionality/
21:24:28 <Io> Thanks for everything guys I appreciate it, I guess I'll give it a shot with another book. Feel a little bit lost on this Chapter. Really appreciate it
21:26:02 <monochrom> eta
21:27:17 <ski> (not quite the same, although related)
21:28:13 <ski> Io : "so whenever i have a jValue and invoke fromJValue it returns an empty Right??" -- example of that ?
21:29:13 <monochrom> That's from a gross misunderstanding of "fromJValue = Right".  See also eta reduction and function extensionality :)
21:30:18 <ski> hm ?
21:30:45 <monochrom> "empty Right" = I see "Right" without parameters so it must be empty.
21:31:05 <ski> hm, maybe
21:31:27 <monochrom> The problem with rational people trying to understand intuitive people.
21:32:08 <Io> I know it is not empty... What I mean is that it is not performing any conversion.
21:32:11 <ski> is that intuitive people doesn't make intuitive sense ?
21:32:26 <monochrom> intuitive nonsense
21:32:29 <Io> It is not doing anything just kindo f unboxing it
21:32:46 * ski is still not sure what Io's example is
21:33:19 <shiraeeshi> lo, are you invoking jvalue to jvalue conversion? or jvalue from jvalue?
21:33:22 <monochrom> The code isn't actually runnable (full of compile-time errors) so there is not going to be any example.
21:33:38 <Io> Im just pasting it from the book 
21:34:15 * ski . o O ( "Code From The Book" )
21:34:39 <Io> so when I do toJValue on an integer, It applies the constructor as intended...
21:35:06 <ski> Io : i still don't understand "how does the compiler know what Im trying to convert from when all JValues are of type JValue"
21:35:25 <Io> but when I do fromJValue on the contructed JValue I'm supposed to get back the initial value. Does that make sense?
21:36:22 <ski> you're supposed to get back `Either' a `String', or a value of the type you're attempting to convert back to
21:36:37 <ski> in case it's the same type, it should be the latter, yes
21:36:49 <ski> (but wrapped in a `Right', due to the `Either')
21:37:17 <Io> Im going to paste the whole thing maybe it is easier
21:37:20 <Io> {-# LANGUAGE FlexibleInstances #-}
21:37:20 <Io> module Chapter6.JSONClass where
21:37:21 <Io> import Flow
21:37:21 <Io> import Control.Arrow
21:37:21 <Io> import Data.Either
21:37:21 <Io> data JValue
21:37:23 <Io>   = JString
21:37:27 <ski> use a paste site ..
21:37:27 <Io>       { getString :: String
21:37:29 <Io>       }
21:37:31 <Io>   | JNumber
21:37:33 <Io>       { getNumber :: Double
21:37:35 <Io>       }
21:37:36 <iqubic> PLEASE STOP THIS!!!
21:37:37 <Io>   | JBool
21:37:39 <Io>       { getBool :: Bool
21:37:40 <iqubic> STOP IT NOW.
21:37:41 --- mode: ChanServ set +q *!*@186.167.242.247
21:37:41 <Io>       }
21:37:47 <iqubic> USE A PASTE SITE!
21:38:16 --- mode: ChanServ set +o monochrom
21:38:18 --- mode: monochrom set -q *!*@186.167.242.247
21:38:19 <Io>     }
21:38:21 <Io>   deriving (Eq, Ord, Show)
21:38:23 --- mode: ChanServ set +q *!*@186.167.242.247
21:38:42 <monochrom> I guess we have to wait a little longer.
21:39:06 <ski> please find a paste site to use
21:39:19 --- mode: monochrom set -q *!*@186.167.242.247
21:39:20 <glguy> Io: Your client is sending your paste one line at a time every couple seconds. You might just reconnect to flush that out
21:39:21 <Io>     -- filterMapRights fromJValue const a |> JAry |> Right
21:39:24 <Io>   fromJValue _ = Left "Not a JSON array."
21:39:26 --- mode: ChanServ set +q *!*@186.167.242.247
21:39:29 <pavonia> lol
21:39:42 --- mode: ChanServ set -q *!*@186.167.242.247
21:39:53 <glguy> crisis averted
21:40:38 <Io> im sorry..
21:40:40 <Io> https://justpaste.it/5fd2j
21:40:44 <ski> thank you
21:44:44 <Io> this may be better https://www.codepile.net/pile/ye0EjXMn
21:45:45 <ski> (makes my browser freeze a bit)
21:46:29 <Io> what site do you use
21:46:31 <Io> usually
21:47:05 <ski> the former seems to work
21:48:29 <Io> well, if you run that, you may see that when you use to 
21:48:55 <Io> toJValue it works perfectly but fromJValue doesn't really, It always tries to convert to a number.
21:49:11 <ski> give a specific example
21:49:15 <Axman6> filterMapRights is almost certainly the wrong thing to be using for your JObj instance bet, you want to fail if you get any failures, not ignore them
21:49:18 <monochrom> What do I run?
21:50:09 <ski> yea, you're also ignoring in `JSON (JAry a)'
21:50:11 <Io> I understand, I was trying different approaches, but if you run toJValue Jbool  |> fromJValue 
21:50:26 <Io> you get Left not a JSON number
21:50:57 <monochrom> What the hell is "Flow"? Is "|>" from there?
21:51:26 <Io> yes sorry well is the same as fromJValue $ toJValue True
21:51:29 <ski> that example looks like a type error, Io
21:51:33 <Axman6> you haven't provided enough information to be able to tell what type fromJValue is trying to decode (i.e. which instance of JSON is being used)
21:51:53 <Axman6> I would expect if it's trying to decode an Integer from a Bool that that should fail though
21:51:53 <Io> Ok, how should I do it?
21:52:03 <ski> Io : so, what if you try `fromJValue (toJValue True) :: Either JSONError Bool' ?
21:52:12 <boxscape> monochrom here's a cheat sheet https://github.com/tfausak/flow#cheat-sheet
21:52:25 <Axman6> you have to tell the compiler _which_ fromJValue you want it top use
21:52:27 <Axman6> to*
21:53:03 <Io> @ski. Yeah that works perfect
21:53:03 <lambdabot> Unknown command, try @list
21:53:27 <monochrom> "compose f g x" complelely defeats the purpose of compose.
21:53:37 <ski> Io : commonly, which instance to use is determined by the context. but if you're just giving `fromJValue (toJValue True)' in the interactor, with no surrounding context, that will either error out with an ambiguity, or else default to some type being used (probably not the one you intended)
21:53:50 <Axman6> Io: now if you try fromJValue (toJValue True) :: Either JSONError Integer, that should fail with Left "Not a number" because the JValue which the toJValue instance for Bool produced doesn't produce a number
21:53:59 <Io> wow that is it
21:54:31 <Io> so how do i make sure it always can always know ? should I cast it everytime with double semicolons?
21:55:01 <Axman6> the toJValue True produces JBool True, then the fromJValue instance for Integer sees that it didn't get a JNumber and fails - you're using two _different_ instances of the JSON class
21:55:05 <ski> Io : so, in practice, most times, a type ascription like `:: Either JSONError Bool' there won't be needed. but in your case, testing that expression, in isolation, in the interactor, it's needed, to guide it to the intended version of `fromJValue' that you wanted to use
21:55:25 <Io> Amazing
21:55:33 <Io> Thanks a lot!
21:56:56 <Io> What confused me was the JSON instance for JValue
21:57:35 <Axman6> rewrite it : fromJValue jvalue = Right jvalue
21:57:47 <Axman6> it will always succeed
21:58:16 <Io> thanks a lot, 
21:58:23 <ski> (the rewrite it back)
21:58:28 * ski . o O ( `T_PAAMAYIM_NEKUDOTAYIM' )
21:58:34 <olligobber> ugh, this writer is not acting like I wanted...
21:58:37 <Io> I must say this is by far the most amazing language I have ever seen!
21:58:44 * ski smiles
22:00:06 <olligobber> for some reason if I get all the values out of each writer and append them, I get a different thing to when the writers get bound together
22:00:51 <Axman6> olligobber: got some code?
22:01:45 <olligobber> Axman6, https://gist.github.com/olligobber/7b752caedf2b70d2c1589aacb02a74e9
22:02:03 <iqubic> ski: PAAMAYIM_NEKUDOTAYIM is the "has type of" operator, right?
22:02:56 <ski> in some other language, maybe
22:03:01 <suzu> isnt that php
22:03:03 <suzu> lol
22:03:14 <suzu> `::` is paamayim nekudotayim
22:04:03 <iqubic> suzu: That's what I was referencing
22:04:10 <suzu> :P
22:04:22 * ski has no idea what it's used for, in PHP
22:04:39 <olligobber> Axman6, I'll put the failing test case in its own file so I have a mwe
22:07:29 <zeta_0> hello there, i am trying to get a cli tool working, i was wondering if you guys could help me out?
22:08:23 <iqubic> zeta_0: What CLI tool is it?
22:10:32 <zeta_0> iqubic: uhh, i don't understand it well enough to explain, let me pastebin the problem, one second'
22:11:57 * ski idly wonders what the point of `flow' is
22:13:01 <iqubic> Flow is strange. Just use the existing combinators.
22:15:56 * ski . o O ( "And by using idioms common in other programming languages, we can allow people who aren't familiar with Haskell to guess at the meaning." )
22:16:28 <xavo[m]> I remember looking for those operators before I knew about (&) and played around with Elm and its (|>)
22:16:54 <iqubic> But & and $ are really cool.
22:16:54 <xavo[m]> but after finding out about (&) and (<&>) I don't really see any use for them anymore 
22:17:37 <xavo[m]> yeah, exactly, which is why I don't see any reason to use (|>) (<|) - that was ambiguous
22:17:40 * ski thinks `$' is overused
22:17:44 <iqubic> Is <&> just `flip <&>`
22:17:45 <iqubic> ?
22:17:55 <iqubic> ski: I love $, and hate parens.
22:17:59 <xavo[m]> flip fmap, yeah
22:18:05 <boxscape> ski what would be the advantages of using it less?
22:18:15 * ski is sortof the opposite, then
22:18:19 <dansho> <$3
22:18:21 <boxscape> I don't like parens but I also don't like the shape of $
22:18:32 <iqubic> Right. `<&> = flip <$>`
22:18:33 <ski> less eye pain, boxscape
22:19:00 <ski> also, prefer `f . g . h $ x' to `f $ g $ h $ x'
22:19:06 <iqubic> Why?
22:19:13 <boxscape> ski out of curiosity, do you think (foo (bar baz)) or (foo $ bar baz) is better?
22:19:14 <ski> (although, i usually prefer `(f . g . h) x' to either of those)
22:19:31 <ski> the former, definitely, in case `foo',`bar',`baz' are just simple names, boxscape
22:19:34 <boxscape> I also prefer . to $ usually
22:19:37 <iqubic> Why do you use `(f . g . h) x`
22:19:45 <ski> to avoid using `$'
22:20:06 * Axman6 has started to prefer using f . g $ h x
22:20:21 <boxscape> ^ that's what I usually do too
22:20:21 <iqubic> Axman6: You are a heathen.
22:20:25 <ski> but use `f . g . h $ x' over `f $ g $ h $ x' since in the former you can factor out either `f . g' or `g . h' into a separate definition
22:20:34 <ski> (function composition is associative)
22:20:41 <iqubic> Right.
22:21:15 <xavo[m]> `f $ g $ h x` here, usually
22:21:43 <ski> a few brackets are nothing to be afraid of
22:22:11 <ski> it can get annoying if you have them spanning many lines, especially if you get a whole heap of closing brackets at the end, though
22:23:12 <ski> i may use `return $' or `print $' or the like, occasionally. but then i (normally) don't use any more `$' in that expression
22:23:25 <boxscape> do you like -XBlockArguments ski?
22:23:27 <ski> (`($ blah)' is another thing)
22:23:28 <ski> yes
22:23:31 <boxscape> I do too
22:23:57 <olligobber> well of course as soon as I put it in its own file it works
22:25:10 * ski anyway questions that the quoted sentence from the haddock is a good thing ..
22:25:14 <xavo[m]> re: flow, why would you bother making $ and & more readable? the rest of your code is still gonna have >>= and <&> and ?~ and <+= in it
22:25:57 <iqubic> xavo[m]: Those are cool lens operators.
22:26:03 <boxscape> it's nice though that >>= and =<< are symmetrical whereas $ and & aren't
22:26:06 <olligobber> ah, but it doesn't quite work
22:26:08 <boxscape> (and >> and << aren't)
22:26:38 <ski> yea, and `<*>' ought to have been named `<$>', imho
22:26:47 <boxscape> true actually
22:26:56 <xavo[m]> iqubic: thanks I think so too
22:26:56 <xavo[m]> boxscape: true, but still
22:27:09 <ski> (i recall using that, before `Applicative' became a thing)
22:27:40 <boxscape> xavo[m] yeah I don't think it makes sense to use non-standard operators at this point when the others are already established
22:27:42 <ski> (`(<*>)' would of course be `liftA2 (,)')
22:28:03 <xavo[m]> I feel like if you're so unfamiliar with haskell you don't know about $ you won't understand the monadic stuff anyway
22:28:14 <ski> yea
22:28:19 <xavo[m]> monads being the archetypal foreign thing
22:28:28 <xavo[m]> boxscape: agreed
22:28:39 <olligobber> found the problem, erroneous "D.liftAndLeft" in DNF.hs
22:29:11 <ski> @quote what.burrito
22:29:11 <lambdabot> hodapp says: I'm not sure I understand what burrito even means here... could someone explain it in terms of monads or something?
22:32:03 <boxscape> I find a burrito join a lot easier to conceptualize than a burrito bind
22:32:41 <boxscape> (still hoping we can sort out the role situation and make join part of the Monad class one of these days)
22:33:07 <Axman6> If you have a burrito containing incredients, and a way to take ingredients and turn them into another type of burrity, then you can make another type of burrito
22:33:18 <Axman6> o*
22:33:28 <xavo[m]> oh, what?? I always assumed join was part of the typeclass
22:33:40 <ski> nope
22:33:40 <boxscape> you would think so, but no https://gitlab.haskell.org/ghc/ghc/wikis/roles2
22:33:47 <ski> @src join
22:33:47 <lambdabot> join x = x >>= id
22:33:57 <xavo[m]> damn
22:33:59 <ski> is just a regular definition
22:34:00 <boxscape> of course that doesn't mean you *can't* implement >>= in terms of join as long as you're willing to write a pretty small amount of boilerplate code
22:34:22 <boxscape> or rather, define a Monad instance in terms of join
22:34:30 <xavo[m]> yeah
22:34:36 <ski>   ma >>= amb = join (fmap amb ma)
22:34:38 <ski>     where
22:34:46 <ski>     join (..) = ..
22:34:55 <xavo[m]> that's
22:35:15 <xavo[m]> actually, explains why beginner me had a hard time writing a Monad instance lmao
22:36:13 <xavo[m]> always found join easier to conceptualize than bind so I tried to write that first, iirc
22:37:19 <boxscape> yeah I feel similar for most Monads
22:38:18 <olligobber> yeah, join should be in the typeclass
22:38:38 <boxscape> it just can't be right now unfortunately
22:40:01 <boxscape> well, it could, but not without issues
22:41:54 <fog> so im starting to use the haskell SDL2 bindings
22:42:00 <fog> installed via; https://www.reddit.com/r/haskellgamedev/comments/4jpthu/windows_sdl2_is_now_almost_painless_via_stack/
22:42:21 <fog> can i search hackage for packages with this lib as a dependency?
22:43:02 <fog> alternatively, does anyone know of a (streaming) graphing package which uses this backend?
22:58:40 <fog> ah, I found some packages on the wiki; https://wiki.haskell.org/SDL
23:00:59 <gaze__> once you have knots tied in a datastructure, how do you debug it?
23:01:09 <gaze__> or print it in a meaningful way
23:01:22 <fog> how do you mean?
23:01:39 <jackdk> fog: https://packdeps.haskellers.com/reverse/sdl2
23:01:51 <fog> thanks jackdk
23:02:37 <fog> nothing that looks like a graph lib though....
23:03:09 <fog> gaze__ what do you mean to debug a cyclic datastructure?
23:03:38 <gaze__> print it or explore it or debug code that explores it.
23:03:53 <gaze__> if you just naively print it, it'll loop
23:03:54 <fog> ah, you might want to detect the cycle
23:04:03 <gaze__> is that what I wanna do?
23:04:10 <gaze__> seems too general
23:04:22 <fog> well then you could match on that in the show instance
23:05:29 <fog> otherwise you have to lazily consume it, meaning you have to know how to navigate over it, eg, if it was a cyclic list, you would want to take as many values as it contains before it loops, so you would need to know the length in advance
23:05:42 <fog> if you can match on the cycle, you could determine this algorithmically
23:05:56 <gaze__> I'm just wondering what people who write code for GHC do
23:06:07 <gaze__> there's knots tied everywhere
23:06:11 <gaze__> and it's all very complex
23:06:19 <gaze__> I wonder how you write new code and debug it
23:06:24 <fog> do you just mean recursive datatypes?
23:06:50 <fog> maybe we need a concrete example
23:07:19 <gaze__> https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/tying-the-knot
23:07:35 <fog> what i was meaning was if you had a tree as a list of trees, then you could place reference to the whole tree as a value in one of the lists
23:07:49 <fog> which is the version where you cant detect the cycle
23:08:26 <fog> but if instead you have a list of Either Tree Tree, then you can use Left for regular branches, and Right for cycles
23:10:13 <fog> cant really comment on that ghc link, sorry
23:11:06 <fog> a better introduction is https://wiki.haskell.org/Tying_the_Knot
23:12:13 <fog> see the text box underneath; How to build a cyclic data structure. 
23:26:20 <fog> hmm, there is reflex + sdl2; https://hackage.haskell.org/package/reflex-sdl2
23:26:32 <fog> maybe there is a graphing package written using reflex..
23:27:08 <fog> actually, that might be good because then it could use webgl instead for cross platform support
23:28:59 <fog> maybe something like; https://hackage.haskell.org/package/diagrams-reflex
23:29:48 <fog> yay, graphs; https://archives.haskell.org/projects.haskell.org/diagrams/gallery/Chart.html
23:31:47 <fog> hmm, might be difficult to do the frp streaming :(
23:33:46 <fog> was wanting something like; https://plot.ly/javascript/streaming/
23:34:52 <fog> oh, we actually have that; https://glutamate.github.io/plotlyhs/
23:38:18 <fog> not sure if it handles the streaming though, it seems to output the data to html...
