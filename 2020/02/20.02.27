00:02:44 <shachaf> It's polite to actually include the error rather than paraphrase it.
00:02:59 <shachaf> But in this case it seems pretty clear. You typed "toS" into that program, and the computer doesn't know what it means.
00:08:49 <maerwald> dminuoso: I use $ after lift/return etc, but parens in many other places. I feel you don't need to be concistent overall
00:09:16 <lumiere> shachaf the thng is i just copied the first lines from a working compiler 
00:10:07 <dminuoso> When you are teaching Haskell to students, it's better if you stick to some convention - otherwise your students will constantly stumble if the expected code format constantly diverges.
00:10:21 <dminuoso> The less they have to spend on mentally parsing the code, the more they can spend on understanding the semantics
00:10:36 <dminuoso> If you know what you are doing, you can do whatever really.
00:10:52 <dminuoso> It's not about what you should do in production code, but in code you want to use as teaching material.
00:12:36 <lumiere> hey i'm a total haskell newb and been trying to learn it i wanted to try my hand at a parser https://gist.github.com/anooppoommen/670b6e4daf5c094d8d8a556d375fea56 could someone please help me debug this
00:17:00 <lumiere> hey could someone explain what this one line would do  either (Left . toS )  (return $ AT.parseOnly (parser <* AT.endOfInput) t)
00:22:47 <agander_m> dminuoso: Are you teaching haskell?
00:23:59 <fishooter> thank you very much for feedback :) I'll incorporate the suggestions
00:30:48 <dminuoso> agander_m: Yes. I'm like one of those Ori priests, spreading the knowledge.
01:17:01 <cocreature> what is the easiest way given a type signature to construct an expression of that type? `error "foobar"` doesn’t do the trick for something like `Lens s t a b -> Lens s t a b` since that would be impredicative. just something like `f = f` doesn’t work if it has ambiguous type variables. I could in principle do something like `f = f @… @_` but I feel like there must be a simpler solution to
01:17:02 <cocreature> getting GHC to accept this
01:17:06 <cocreature> I don’t actually care about the expression
01:24:59 <boxscape> probably not a great solution you could enable -XImpredicativeTypes
01:25:13 <merijn> That's a terrible idea
01:25:39 <merijn> Nobody should *ever* enable -XImpredicativeTypes until like 8.12 or something when the stuff is actually working
01:27:54 <iqubic> What the heck are Impredicative Types?
01:28:25 <boxscape> https://wiki.haskell.org/Impredicative_types
01:28:50 <merijn> iqubic: Basically "I wanna store polymorphic (i.e. RankN functions) inside a datatype
01:29:01 <iqubic> I see.
01:29:05 <merijn> iqubic: So stuff like "Maybe (forall a . Ord a => a -> a)"
01:29:15 <dminuoso> I've just had a brilliant idea! I need to run a local hackage mirror on my laptop, such that working offline while on the train works simpler!
01:29:17 <iqubic> And why is that an issue?
01:29:30 <boxscape> type inference is hard
01:29:36 <merijn> iqubic: I don't know, because I don't understand why impredicative types is hard
01:29:47 <iqubic> Ah. I see.
01:29:49 <dminuoso> Not just hard, until recently nobody evey knew what impredicative types in the presence of type inference even meant.
01:29:57 <merijn> ^^
01:30:30 <merijn> This is why I said you shouldn't use -XImpredicativeTypes, because it's not even broken, no one could even tell you whether it's broken, because nobody knows what it means :p
01:30:54 <dminuoso> iqubic: Impredicative types are types where you can instantiate a type variable with a quantified one - even with itself!
01:31:02 <iqubic> I know this now
01:31:18 <boxscape> so *is* there a way to write a simple expression of an arbitrary type? (without -XI.T.)
01:31:37 <merijn> boxscape: What does "an arbitrary type" mean?
01:31:40 <dminuoso> Well to be fair, RankNTypes are a limited form of impredicative types.
01:31:54 <dminuoso> -XImpredicativeTypes just gives you completely unlimited ones
01:32:02 <boxscape> merijn that's just me poorly rephrasing cocreature's question
01:32:40 <iqubic> @let f = maybe Nothing (\g -> (g [3], g "Hello")) :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])
01:32:43 <lambdabot>  .L.hs:266:7: error:
01:32:43 <lambdabot>      • Illegal polymorphic type: forall a. [a] -> [a]
01:32:43 <lambdabot>        GHC doesn't yet support impredicative polymorphism
01:32:46 <cocreature> I’m just too scared to enable ImpredicativeTypes :)
01:32:52 <iqubic> Well. That's nice.
01:33:02 <iqubic> I got the error I was looking for.
01:33:07 <cocreature> it does seem to do the right thing on my simple example but I’m fairly sure it will blow up in my face
01:33:34 <timCF> Hi guys! Is there any way to export **all** modules from Haskell (Stack) library? I just have really a lot (hundreds) modules generated by proto-lens tool from Google Protobuf files. It's very inconvenient to write them all manually in **exposed-modules** section.
01:34:07 <dminuoso> timCF: Have your generation code also generate the export code?
01:34:12 <iqubic> dminuoso: The above example shows impredicative polymorphism nicely.
01:34:21 <iqubic> f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])
01:34:24 <iqubic> f (Just g) = Just (g [3], g "hello")
01:34:25 <iqubic> f Nothing  = Nothing
01:34:41 <lortabac> timCF: stack supports hpack natively
01:35:02 <lortabac> hpack generates a .cabal file for you
01:35:05 <dminuoso> iqubic: The problem is not about the code, its about type inference.
01:35:09 <merijn> I would honestly just look into options that don't involve having hundreds of modules
01:35:11 <iqubic> That's the example I feed to lambdabot, using `maybe` + lambdas to do it in one line
01:35:14 <merijn> That sounds like stupid design
01:35:23 <dminuoso> iqubic: The intermediate language core for example allows impredicative types *completely* - but the reason it can do that, is because it has no type inference.
01:35:37 <iqubic> Right. Makes sense.
01:35:38 <dminuoso> iqubic: It's the relationship between type inference and impredicative types that is at the core of the problem
01:35:47 <boxscape> heh, core
01:35:47 <iqubic> Correct.
01:36:18 <dminuoso> That being said, some impredicative types you can get with newtypes
01:36:57 <dminuoso> % newtype Ordable a = Ordable (forall a. Ord a => a -> a)
01:36:57 <yahb> dminuoso: 
01:37:13 <dminuoso> % f :: Maybe Ordable -> Maybe ([Int], [Char]); f = undefined
01:37:13 <yahb> dminuoso: ; <interactive>:16:12: error:; * Expecting one more argument to `Ordable'; Expected a type, but `Ordable' has kind `k0 -> *'; * In the first argument of `Maybe', namely `Ordable'; In the type signature: f :: Maybe Ordable -> Maybe ([Int], [Char])
01:37:23 <dminuoso> % newtype Ordable = Ordable (forall a. Ord a => a -> a)
01:37:23 <yahb> dminuoso: 
01:37:25 <dminuoso> % f :: Maybe Ordable -> Maybe ([Int], [Char]); f = undefined
01:37:25 <yahb> dminuoso: 
01:38:10 <iqubic> This looks a lot like existential types.
01:38:29 <timCF> @dminuoso sure, but to export modules from Haskell library, atm I have to write them manually to **exposed-modules** section of **package.yaml** file, here is working real example https://github.com/google/proto-lens/blob/7bb31dc868161a756b2744676425ac8f7e5860fa/proto-lens-tutorial/person/package.yaml#L18-L20
01:38:29 <lambdabot> Unknown command, try @list
01:38:39 <dminuoso> iqubic: It's not.
01:38:46 <dminuoso> Not even close
01:38:47 <iqubic> Oh? How so?
01:38:57 <dminuoso> iqubic: Ordable requires a fully polymorphic thing.
01:39:00 <timCF> dminuoso just imagine that it's not 2 but 200 modules here
01:39:43 <boxscape> doesn't existential mean the forall is on the left of the constructor?
01:39:46 <dminuoso> iqubic: If you receive an Ordable and crack it open, you hold a polymorphic function in your hand that you can instantiate at different types.
01:40:09 <dminuoso> iqubic: If you received an existential, it's monomorphic - someone else made that choice, but you dont know which
01:40:20 <iqubic> Right. I see.
01:40:49 <dminuoso> iqubic: My code is the same as `f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])` except with a newtype in between
01:41:00 <iqubic> Yeah. I get it.
01:41:12 <iqubic> What do existential types look like again?
01:41:30 <iqubic> Like what's the syntax for them?
01:41:47 <boxscape> % data Exi = forall a . Exi a
01:41:47 <yahb> boxscape: 
01:42:04 <lortabac> timCF: try removing the "expose-modules" section
01:45:10 <svipal> sup
01:46:33 <boxscape> % data Showable = forall a . Show a => Showable a
01:46:33 <yahb> boxscape: 
01:46:49 <boxscape> % map (\(Showable x) -> show x) [Showable "asf", Showable 45, Showable 'c']
01:46:49 <yahb> boxscape: ["\"asf\"","45","'c'"]
01:46:55 <boxscape> here's an example iqubic ^
01:47:44 <timCF> lortabac not working without it :(
01:48:55 <lortabac> timCF: weird, hpack should add all the modules in the source directory automatically
01:50:08 <lortabac> oh wait, those are generated files
01:51:15 <lortabac> they are not there yet when hpack is executed
01:53:05 <lortabac> timCF: maybe you should split the code generation phase from the rest
01:54:35 <dminuoso> iqubic: By the way, this impredicative types is why ($) would not work with runST. The fact that it does is because ($) is special cased in GHC.
01:54:50 <dminuoso> % :t runST
01:54:50 <yahb> dminuoso: (forall s. ST s a) -> a
01:54:52 <iqubic> Right. I know that.
01:54:54 <dminuoso> % :t ($)
01:54:54 <yahb> dminuoso: (a -> b) -> a -> b
01:55:18 <dminuoso> iqubic: So this would reqiure instantiating `a` at `forall s. ST s a`, which requires impredicative types.
01:56:05 <timCF> lortabac that's true, *src* modules are exported, but modules generated by proto-lens are located somewhere else in *.stack-work*
01:56:46 <lortabac> timCF: I would split it in two projects, one for code generation and one that uses the generated code
01:57:24 <timCF> thanks
01:58:51 <opticblast> I have a question about lenses. If I have a map in a field in a state, is there a way to access the value for a given key using a single expression?
01:59:25 <opticblast> I've tried using use (mapfield . at key), but that gives a very long type error
01:59:44 <opticblast> (or rather, I tried the line `val <- use (mapfield . at key)`
02:00:23 * hackage hailgun 0.4.3 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.3 (k_bx)
02:00:24 <phadej> that should give you Maybe MapValue
02:00:48 <phadej> not just MapValue... it maybe (pun intended) related to that
02:01:42 <opticblast> That was my first problem, but even if I match on Just/Nothing, there's a type error
02:02:38 <opticblast> There's something here about an "IxValue"?
02:04:06 <opticblast> When I use a typed hole, it says that `val <- use (mapfield . _)` requires _ to have the type (Maybe Value -> Maybe Value -> Map Key Value -> Maybe Value)
02:04:31 <opticblast> But I don't see any lens-type with the shape a -> f a -> a -> f b
02:04:45 <opticblast> I mean, a -> f a -> b -> f a
02:06:13 <phadej> IxValue should reduce to the value in the Map; try to add type annotations to things you expect to have a type
02:06:30 <phadej> e.g. when you do `case val of` ... to `case val :: Maybe IThinkTheTypeIs of`
02:09:46 <Poscat[m]> Hi all. Are there any (preferably servant) bindings to the hackage server?
02:09:55 <Poscat[m]> server API*
02:11:12 <dminuoso> Poscat[m]: hackage-server exposes Distribution.Client that you can use.
02:11:17 <dminuoso> Poscat[m]: It's how hackage-mirror works for example
02:12:46 <dminuoso> Poscat[m]: https://github.com/haskell/hackage-server/blob/master/exes/MirrorClient.hs and https://github.com/haskell/hackage-server/blob/master/hackage-server.cabal#L396-L404
02:14:02 <Poscat[m]> Ah thanks. I thought it only contains the server XD
02:16:11 <svipal> is there any way to include local files with inline-c
02:16:33 <svipal> extra-include-dirs doesn't work
02:16:46 <svipal> (using stack)
02:20:35 <opticblast> Huh. It wasn't the lens after all. My types were wrong somewhere else.
02:20:41 <opticblast> phadej: Thanks.
02:22:34 <agander_m> dminuoso: good work. Does ‘spreading the knowledge’ include blogging? I’d be interested to read if so
02:22:54 <dminuoso> agander_m: No. Im just training some coworkers.
02:24:02 <kuribas> how useful is redis?
02:24:18 <kuribas> sorry, offtopic
02:26:54 * hackage hailgun 0.5.0 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.5.0 (k_bx)
02:33:26 <svipal> for now I'm looking at just doing verbatims on loaded files , but seems bd
02:56:21 <BrisbaneJosh> Not sure if anyone can help me, I am actually using Elm but if I ask this question in Elm chat I'll just be told it's "pointless" but I have the need to essentially construct a pair from a single argument in a variety of places in my codebase and I want to create a helper/utility for this but am unsure what it should be called
02:56:27 <BrisbaneJosh> The signature is basically
02:56:28 <BrisbaneJosh> a -> Pair (a -> b) (a -> c) -> Pair a c
02:56:36 <BrisbaneJosh> or in elm it would be 
02:56:58 <BrisbaneJosh> : a -> ( (a -> b), ( a -> c) ) -> (a, c)
02:57:23 <BrisbaneJosh> Can anyone reccomend a name for a function like this? I feel like I've seen this signature or signatures like it before, but I can't think where or in what context
02:58:50 <__monty__> :t &&&
02:58:51 <lambdabot> error: parse error on input ‘&&&’
02:59:00 <__monty__> @hoogle &&&
02:59:00 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
02:59:00 <lambdabot> Data.Tuple.Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
02:59:00 <lambdabot> Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
02:59:53 <__monty__> > flip (uncurry &&&)
02:59:55 <lambdabot>  error:
02:59:55 <lambdabot>      • No instance for (Typeable a0)
02:59:55 <lambdabot>          arising from a use of ‘show_M826034654072575771915096’
03:00:23 <__monty__> :t flip (uncurry (Data.Tuple.Extra.&&&))
03:00:25 <lambdabot> a -> (a -> b, a -> c) -> (b, c)
03:01:20 <__monty__> BrisbaneJosh: ^
03:01:23 * hackage language-avro 0.1.2.0 - Language definition and parser for AVRO files.  https://hackage.haskell.org/package/language-avro-0.1.2.0 (FlavioCorpa)
03:02:56 <BrisbaneJosh> Many thanks!
03:03:28 <tdammers> maybe it's just me, but I find it telling that the Elm solution to a hard problem seems, again, to be calling it "pointless" and insisting that you shouldn't be wanting this particular thing
03:03:40 <__monty__> np, (I'm not sure whether there's not a simpler way though.)
03:04:14 <tdammers> anyway, I'd just write that combinator myself
03:04:17 <BrisbaneJosh> I think in general it's the Elm mindset of "Always for the beginners first, everyone else can sort themselves out"
03:04:29 <tdammers> fan f g x = (f x, g x)
03:04:34 <BrisbaneJosh> It's not so much that it's hard to implement that function in elm, it's very simple, 
03:04:39 <BrisbaneJosh> yeah exactly tdammers
03:04:43 <BrisbaneJosh> that's what I've got
03:04:48 <BrisbaneJosh> I'm just struggling on naming
03:04:56 <__monty__> fanout's a decent name.
03:05:14 <BrisbaneJosh> calling it something like "toPair" was my first thought but it seems wrong
03:05:17 <tdammers> ah yes, naming. one of two hard problems in programming, the other being cache expiration and off-by-one errors
03:05:35 <BrisbaneJosh> fanout does appear to be the perfect name I think
03:06:11 <BrisbaneJosh> at least it's what I'm going to use in this situation, especially seeing as I can't just compose with flip/uncurry as elm removed them from the standard library and I've been too lazy to re-implement
03:06:15 <tdammers> I was pondering "both", but I believe that's already taken; or fan(out)2, the "2" refering to the arity of the tuple
03:06:29 <tdammers> but I guess a pair is fundamental enough to make it the canonical shape for this
03:06:53 <tdammers> also say what? they removed flip and uncurry from the standard library?
03:07:00 <BrisbaneJosh> yeah the pair part I think I'll assume and I could have a "fan"/"fanout" '3'+ for anything greater
03:07:00 <tdammers> jeez
03:07:03 <BrisbaneJosh> if I ever find the need for it
03:07:09 <tdammers> exactly.
03:07:21 <BrisbaneJosh> well they stopped exposing flip/uncurry. They're still used internally but they're no longer accessible.
03:07:29 <tdammers> that's even worse
03:07:37 <tdammers> but doesn't surprise me at all
03:07:45 <BrisbaneJosh> Easy enough to re-implement and I think there's even a "Core-Extra" library that re-adds them, but it feels like a hassle I don't wanna include in every project I work with
03:07:59 <tdammers> "we are smart enough to use these advanced functions, but they are not safe for you, so we won't let you. it's for your own good, trust us."
03:08:25 <BrisbaneJosh> I also still want "eq" to be exposed, so I don't need to use (==) to check for equality when "eq" is so much shorter and nicer when partially applying, but that's just another minor gripe really
03:08:31 <tdammers> a.k.a. calling your users dumb
03:08:36 <BrisbaneJosh> tdammers hit the nail on the head there
03:08:51 <tdammers> which shows quite some hubris for someone who isn't smart enough to implement proper typeclasses
03:09:23 <svipal> I use flip something like once per day at minima
03:09:25 <BrisbaneJosh> Though they are absolutely focusing on using Elm as a tool to teach functional programming to JS developers and hey, it's how I was finally intrigued enough to end up here asking about stuff so...?
03:09:54 <tdammers> personally, I think trying to force anything you built into an intended use case tends to end badly
03:10:25 <__monty__> It's just too bad that a language with pretty great tooling explicitly refuses to cater to non-beginners.
03:10:29 <tdammers> e.g., when I first wrote https://sprinkles.tobiasdammers.nl/, I envisioned it as a tool for creating lightweight HTML frontends for JSON APIs
03:10:36 <tdammers> and it's still a great tool for that
03:10:58 <tdammers> but it turns out that with just one small addition, I could turn it into a pretty decent static site generator
03:11:16 <tdammers> I didn't plan for that to happen, but when I noticed the opportunity, I made it happen
03:11:32 <tdammers> and now it turns out that that's one of the most important use cases for some people
03:11:37 <idnar> can I use -XDerivingStrategies with -XStandaloneDeriving?
03:11:46 <tdammers> idnar: yes
03:11:53 <tdammers> the two are orthogonal
03:12:07 <tdammers> you can standalone-derive with a strategy
03:13:45 <BrisbaneJosh> honestly many many many thanks to you tdammers. You've solved a problem I probably would have over-thought for days and also now I get to go have a look at Sprinkles, Kudos!
03:13:54 <idnar> I guess what I meant was "does the syntax for the latter also support strategies?" anyway, great!
03:15:41 <idnar> I might have too much love for extensions https://usercontent.irccloud-cdn.com/file/RYvamql5/image.png
03:15:57 <__monty__> Jikes!
03:16:15 <__monty__> AllowAmbiguousTypes by default?
03:17:30 <idnar> it's pretty tame; I'm using TypeApplications all over
03:22:24 * hackage hailgun 0.5.1 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.5.1 (k_bx)
03:33:53 <boxscape> Considering we allow lambda expressions to have almost any natural number of arguments, if you were to design it from scratch, would you allow zero-argument lambdas?
03:34:48 <opqdonut> we already have zero-argument lambdas: they're called non-lambda expressions :)
03:35:18 <opqdonut> if you have zero-argument functions, you need special function call syntax to disambiguate between referring to the function and calling it
03:35:24 <opqdonut> I don't think that would fit a haskell-like syntax
03:35:58 <opqdonut> also, in a pure lazy language you don't really need zero-argument functions in addition to lazy constants
03:38:26 <boxscape> I don't think you need special syntax, (\ -> exp) would simply be equivalent to exp
03:39:53 <Cale> boxscape: I'm not sure there's a good reason to allow it
03:40:05 <fishooter> if I have some type, and I specify that it's instance of Functor, and provide an implementation of fmap, and it all type checks, does that automatically imply that it satisfies functor laws?
03:40:34 <boxscape> The only reason I can think of is consistency (i.e. why make 0 a special case), but I admit that might not be good enough
03:40:43 <Cale> A better question is perhaps how we might design a syntax for function expressions which gives the full power of top level function declarations
03:40:53 <dmj`> fishooter: just because it type checks doesn't mean its valid
03:41:09 <Cale> fishooter: You also need that fmap id = id
03:41:11 <dmj`> fishooter: fmap = undefined will typecheck for instance
03:41:28 <boxscape> What a great question, I happen to proposed something along those lines which I know you know about Cale :)
03:41:30 <fishooter> dmj`: yes, if we omit the case of undefined, is it true?
03:41:30 <Cale> (but the other functor law comes from parametricity, if that works)
03:41:35 <boxscape> happen to have*
03:41:43 <dmj`> fishooter: no
03:41:44 <Cale> boxscape: haha
03:42:15 <dmj`> fishooter: instance Functor (Maybe a) where fmap f (Just x) = Nothing; fmap _ Nothing = Nothing
03:43:10 <dmj`> typechecks but isnt valid
03:43:14 <dminuoso> dmj`: That instance declaration wont kindcheck.
03:43:17 <dmj`> instance Functor Maybe *
03:43:26 <dmj`> dminuoso: yea, should just be Maybe, my b
03:43:41 <dmj`> instance Functor Maybe where fmap f (Just x) = Nothing; fmap _ Nothing = Nothing
03:43:52 <dmj`> typechecks and breaks laws
03:44:29 <dmj`> fishooter: morale of the story is to not break the law
03:44:32 <dminuoso> boxscape: Well what is the semantics of a 0-argument lambda?
03:44:39 <dminuoso> boxscape: What is its type?
03:44:41 <fishooter> dmj`: ok, makes sense, thank you :)
03:44:44 <dminuoso> boxscape: How does it fit into type inference rules?
03:44:50 <boxscape> dminuoso (\ -> exp) is the exact same thing as exp, same typing rules
03:44:57 <dmj`> fishooter: I fought the law, and the law won
03:45:02 <dminuoso> boxscape: That seems rather arbitrary.
03:45:10 <fishooter> does there exist some extension / test code which would automatically check if the laws are truly satisfied?
03:45:27 <Cale> boxscape: I'm so torn on the impact of that proposal, because it'd be so nice to have lambdas that can do everything top-level functions can, while on the other hand, the details regarding multiple patterns, and the fact that it's not a 100% perfect replacement for \case is kind of upsetting.
03:45:34 <fishooter> or is it some undecidable problem or something like that :)
03:45:45 <dminuoso> boxscape: Why not box it? One of the semantics of a lambda is that it creates a box (so it creates a barrier for WHNF
03:45:59 <boxscape> Cale yeah that's understandable
03:46:02 <Cale> boxscape: I wish we could somehow get everything and not have to have some annoying compromise
03:46:56 <boxscape> dminuoso hm, is there a difference between (\x -> \y -> exp) and (\x y -> exp) along those lines?
03:47:13 <dminuoso> boxscape: Yes.
03:47:18 <dminuoso> boxscape: It's precisely that.
03:47:24 <boxscape> I see
03:47:42 <dminuoso> boxscape: You can see the difference if you pattern match on the first argument, feed it bottom and force its evaluatoin
03:48:26 <boxscape> true
03:49:01 <Cale> > seq ((\(x:xs) y -> x+y) undefined) 0
03:49:04 <boxscape> Cale I might have to put something about this in the proposal actually
03:49:04 <lambdabot>  0
03:49:10 <Cale> > seq ((\(x:xs) -> \y -> x+y) undefined) 0
03:49:14 <lambdabot>  *Exception: Prelude.undefined
03:49:59 <boxscape> regarding guards + no args
03:51:11 <Cale> boxscape: Better figure out how it interacts with Linear Haskell
03:51:16 <Cale> lol, just kidding
03:51:23 <dmj`> fishooter: equational reasoning will help you prove the laws, turn the left side into the right
03:51:24 <boxscape> oof
03:52:19 <Cale> The whole linear haskell thing has not been good for my mental health
03:59:42 <Cale> boxscape: These little details are really important though, because the whole thing is really about ergonomics -- you could otherwise always use let to define a function locally using the top-level syntax
04:00:36 <Cale> (I mean, things like whether you need to go through and edit all your pattern matches)
04:01:11 <Cale> I suppose one nice thing is that if you're anonymising what was a let-bound function, you *won't* need to edit the patterns
04:02:53 <boxscape> Cale Yeah I don't disagree, it's unfortunate that pattern syntax was different in functions and case expressions from the beginning
04:03:41 <merijn> I find myself using case instead of function patterns more and more often (unless the function has only one argument, and even then...)
04:04:05 <Cale> It's nice not to have to repeat the function's name over and over, for one
04:04:07 <Rembane> Me too, I'm very fond of LambdaCase. 
04:04:17 <merijn> Rembane: I use use regular case-of
04:04:17 <Rembane> bla >>= \case ... 
04:04:27 <Rembane> merijn: I mix them! 
04:04:29 <Cale> and to edit every line just to add one additional parameter
04:04:37 <merijn> Cale: Exactly
04:04:55 <merijn> Cale: Also often easier to linewrap :p
04:06:11 <AWizzArd> EDSL example by Oleg: https://mail.haskell.org/pipermail/haskell-cafe/2008-February/039639.html
04:06:29 <AWizzArd> Should it really be data Expression = ?   Should it not be   data Expression a =?
04:06:53 <AWizzArd> Because below he uses `repr` in a typeclass. And `constant` returns a  `repr Int`
04:07:39 <Taneb> AWizzArd: he's not defining an instance Exp Expression
04:07:51 <Taneb> class Exp is something you can do instead of data Expression
04:09:00 <AWizzArd> Taneb: ah okay, it is a replacement.
04:11:34 <boxscape> Cale fwiw I think you could even replace regular case expression by doing something like `arg & \of pat1 -> exp1; pat2 -> exp2`, though I don't really foresee that being adopted widely (but doing so would mean that you can stick to only one pattern synatx, I believe)
04:13:49 <boxscape> (might be worth putting an example of this in the proposal though I guess)
04:15:59 <dminuoso> I never understood why people like LambdaCase
04:16:33 <boxscape> presumably because it lets you get rid of code perceived as boilerplate
04:23:35 <tdammers> I love lambdacase
04:23:43 <tdammers> mainly for the action >>= \case idiom
04:24:17 <tdammers> it allows me to feed monadic actions directly into a pattern match, without having to introduce a named variable that provides little or no explanatory value
04:24:46 <tdammers> or, more pragmatic point of view; you can write case expression of..., but case monadicAction of... doesn't work
04:24:58 <tdammers> because the latter matches on the action itself, not its result
04:25:58 <tdammers> the rest I can live without, but the >>= \case thing is really really nice
04:27:00 <cocreature> ">>= \x -> case x of" doesn’t really seem that much more complex to me
04:27:22 <cocreature> LambdaCase looks cute but I’m not sure it’s worth having special syntax for in a syntax that already has tons of syntax
04:31:49 <dminuoso> Indeed, that's my thinking as well
04:39:59 <dmj`> nice you can still use gaurds with lambda case
04:40:29 <__monty__> I've wondered why case syntax isn't `case 1 -> ...; 2 -> ... of`, that way you could do `case of x` and `(case of) =<< x`.
04:40:31 <dmj`> getLine >>= \case x | x == "hey" -> putStrLn "hey" | otherwise -> pure ()
04:40:36 <dmj`> @typ getLine >>= \case x | x == "foo" -> putStrLn "hey" | otherwise -> pure ()
04:40:39 <lambdabot> IO ()
04:41:11 <merijn> __monty__: That's exactly what lambdaCase solves :p
04:47:56 <__monty__> merijn: I mean that the original syntax goes against my intuition of what "case of" means.
04:49:13 <Cale> well, in any case, it's not really English
04:50:33 <[Leary]> If I were designing Haskell, `\` would just initiate a block of cases in the first place. We're technically pattern matching in every lambda already, why not do it properly?
04:50:59 <boxscape> [Leary] https://github.com/ghc-proposals/ghc-proposals/pull/302
04:53:42 <yushyin> boxscape: I like the proposal. at first I was not quite convinced, but after I had read through it, I thought it was good after all
04:54:03 <boxscape> nice :)
04:55:52 <boxscape> Cale it seems strange to me that this didn't cross my mind sooner but I think I should probably be more explicit about the exact semantics in the proposal, so.. expect another smallish edit I guess
04:56:32 <[Leary]> Like with LambdaCase`s `\case`, `\ of` looks stupid and should not be necessary. You should be able to write it to be backwards compatible with Haskell lambda syntax.
04:57:31 <boxscape> [Leary] that was the original idea, but since backwards compatibility requires some unusual layout rules, people in the discussion have been more in favor of \of
04:58:11 <boxscape> (see alternatives section)
05:00:39 <__monty__> Weird to call it backwards-compatible if older GHCs wouldn't work with it...
05:01:30 <boxscape> it would also be guarded behind an extension. The perfectly correct way to say it is "Some code that would work without the extension wouldn't work with it"
05:01:43 <[Leary]> Compatible with old code, not old compiler.
05:02:08 <[Leary]> Which is to say, you should be able to enable it without breaking anything.
05:03:13 <boxscape> s/with it"/with it, assuming \ always introduces layout"/
05:19:13 <AWizzArd> In my servant middleware I have access to the request. In the request I have a vault. In the middleware I’ve added data to the vault. Now: how can I access the request (i.e. vault) inside handlers? phadej maybe?
05:29:39 <alp> AWizzArd, servant comes with a "Vault" combinator
05:30:09 <alp> it's actually the 'Vault' type itself
05:30:13 <alp> https://hackage.haskell.org/package/servant-0.17/docs/Servant-API-Vault.html
05:30:49 <alp> having 'Vault :> ...'  will give you an argument of type Vault to the corresponding (group of) handler(s)
05:34:31 <AWizzArd> alp: ah good, so this comes into the route, and it results in a "magic" new parameter, which is the vault.
05:34:35 <AWizzArd> Excellent.
05:36:23 * hackage file-embed 0.0.11.2 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-0.0.11.2 (MichaelSnoyman)
05:39:45 <alp> AWizzArd, well, my "perception" of it is similar to all the other bits of a request that an endpoint might need. 'Capture "foo" Int :> ...' vs 'Vault :> ...' doesn't make much of a difference, wrt how the "combinator" gets turned into an argument to the handler. I don't know if you're familiar with type families, but that's the mechanism used in servant to tell the library how a given combinator should be interpreted, in terms of how it 
05:39:45 <alp> affects the type of the corresponding handler(s)
05:39:51 <boxscape> Finally managed to translate this definition https://i.imgur.com/TvThlYP.png of an isomorphism from HoTT into haskell: https://gist.github.com/JakobBruenker/6ac7e325a7eac87096e2ce7c177056fd
05:40:45 <alp> when we see 'Vault :> something', we say that thhe handler will take a Vault argument and whatever 'something' (the rest of the API type) says it should take/return.
05:40:51 <boxscape> if anyone has feedback, I welcome it
05:40:54 <alp> likewise for Capture, ReqBody, ...
05:44:03 <StianL> Does anyone know of haskell repositories with issues tagged as suitable for beginners?
05:45:04 <__monty__> StianL: https://github.com/jgm/pandoc/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22
05:46:14 <StianL> __monty__: Thanks!
05:46:55 <Cale> boxscape: Your scientists were so preoccupied with whether or not they could, they didn't stop to think if they should :D
05:48:16 <phadej> AWizzArd: API = Vault :> ... not pretty, but this is how it is now
05:48:56 <phadej> (not pretty as Vault is impl detail)
05:49:34 <boxscape> Cale rationally I couldn't agree more, but emotionally I knew this had to be done
05:49:49 <Cale> hahaha
05:57:31 <tabaqui1> is there a way to reconstruct ThreadId from any numeric or string representation?
05:57:52 <tabaqui1> I see that Conctrol.Concurrent.ThreadId type exposes no Read or Num instances
05:58:47 <merijn> tabaqui1: No
05:58:56 <merijn> tabaqui1: Because that'd be unsafe
05:59:21 <tabaqui1> sure it is, but we have a lot of unsafe api
05:59:30 <merijn> tabaqui1: The numerical value of a threadid may be recycled, so allowing that would allow you to accidentally interrupt the wrong thread
06:00:05 <tabaqui1> I'll be carefull, I promise :)
06:00:36 <merijn> tabaqui1: That's nice, but that doesn't magically make such an API available
06:00:56 <tabaqui1> allright, so it doesn't exist
06:00:59 <tabaqui1> merijn: thanks :)
06:01:11 <merijn> tabaqui1: Since ThreadId isn't "just an id", it's in fact, the actual thread (i.e., the thread won't be GCed as long as the id is alive)
06:01:37 <merijn> You could maybe use a weak pointer to look up a threadid based on an identifier?
06:02:31 <tabaqui1> well, I have to workaround it somehow
06:03:12 <tabaqui1> probably, I'll use weak pointers or keep TIds in some IORef set structure
06:05:44 <lhurttila> Is it posible to use list comprehension inside a custom datatype?
06:05:56 <boxscape> what do you mean by that?
06:06:18 <tabaqui1> lhurttila: enable MonadComprehensions and use it with any Monad
06:07:12 <tabaqui1> [ f i j | i <- getI, j <- getJ, i > j ] is essentially "do { i <- getI; j <- getJ; guard (i > j); return (f i j) }"
06:07:50 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/e48300b101b6f662fae38789156c0722/pasted.txt
06:09:53 <lhurttila> could you change the (Int,Int) tuple inside connections with something like (Typex _ _ [(_, (x, y), _)]) | x <- [0..2], y <- [0..2]
06:10:13 <tabaqui1> sure, why not?
06:10:22 <tabaqui1> err, no actually
06:10:40 <tabaqui1> do you want to use it as pattern?
06:12:18 <tabaqui1> you can construct new data with LC, if you fill the holes. But you cannot use it as a pattern for matching
06:13:05 <lhurttila> I'm actually trying to change those x and y from a whole bunch of Typexs with one function with type [[Typex]] -> [[Typex]]. Point is to keep the structure but update those values
06:14:35 <lhurttila> and I also want to keep the other values in every Typex unchanged
06:19:01 <tabaqui1> update f old = old { connections = f $ connections old }?
06:19:16 <tabaqui1> or use lenses
06:19:25 <merijn> So, what's the shortest/simplest way to define "foldMapM :: (Foldable f, Monad m, Monoid r) => (a -> m r) -> f a -> m r"?
06:20:51 <merijn> hmm, maybe "getAp $ foldMap (coerce f)"?
06:22:10 <tabaqui1> hoogle shows 6 libraries implementing such function
06:22:20 <tabaqui1> do you want the optimal one?
06:23:47 <merijn> I only see 2 on hoogle and both are huge Prelude replacements I have no interest in...
06:25:38 <tabaqui1> merijn: check this one https://hackage.haskell.org/package/Agda-2.6.0.1/docs/Agda-Utils-Monad.html#v:mapM-39-
06:26:52 <tabaqui1> this one is nicier https://hackage.haskell.org/package/util-0.1.17.1/docs/Util.html#v:foldMapA
06:27:20 <tabaqui1> it is your proposition, actually
06:28:37 <tabaqui1> % :i \f -> fmap fold . traverse f
06:28:38 <yahb> tabaqui1: ; <interactive>:1:1: error: parse error on input `\'
06:28:43 <tabaqui1> % :i (\f -> fmap fold . traverse f)
06:28:43 <yahb> tabaqui1: ; <interactive>:1:2: error: parse error on input `\'
06:28:49 <tabaqui1> % :t (\f -> fmap fold . traverse f)
06:28:49 <yahb> tabaqui1: (Monoid b, Traversable t, Applicative f) => (a -> f b) -> t a -> f b
06:39:19 <kritzefitz> Is there some trick necessary to get GHC.TypeLits.^ into scope? `import GHC.TypeLits ((^))` says it doesn't exist.
06:40:36 <kritzefitz> Ah, apparently I need to write `import GHC.TypeLits (type (^))`.
07:00:13 <koolkid> Hello! I'm a beginner at haskell and have stumbled upon this one annoying error I can't figure the solution to. When you guys have time take a look at my function I made, https://gist.github.com/richyk1/490e05dabb325fb8f60a82bef842901c . The purpose of the function is the read a list of people from a file and compare them with a person given in the
07:00:14 <koolkid> first argument and give a boolean on whether that person exists in the file or not. Thanks in advance
07:00:50 <tabaqui1> koolkid: just remove in and rearrange lines
07:01:11 <tabaqui1> if you use do-syntax, you have to define let-variables as simple as:
07:01:15 <tabaqui1> foo = do
07:01:19 <tabaqui1>   let x = 5
07:01:24 <tabaqui1>   pure x
07:01:37 <koolkid> ohh
07:01:50 <tabaqui1> uh, and you don't even need this do, so just remove do and keep the rest
07:01:55 <koolkid> niceee, i got a ton of other errors, but i'm glad I got this one out the way
07:03:14 <tabaqui1> no, forget my last sentence - you need do-syntax, but you have to change the signature
07:05:33 <koolkid> is there any way to return IO () without invoking a function like writeFile ?
07:05:44 <tabaqui1> return ()
07:07:39 <Iceland_jack> You can write (do ..; return ()) but also (Data.Functor.void do ..)
07:07:39 <Iceland_jack>  
07:08:17 * ski . o O ( obligatory remark that that `void' ought to be renamed )
07:08:37 <boxscape> what's a good name? unit?
07:08:47 <Iceland_jack> dummy = fmap \_ -> ()
07:08:49 <MarcelineVQ> discard :>
07:08:58 <boxscape> ah I was just about to suggest discard too
07:09:16 <ski> boxscape : how about `ignore' ?
07:09:19 <koolkid> thanks for the answers !
07:09:25 <ski> `discard' isn't bad, either
07:09:26 <boxscape> yeah that seems alright too
07:09:31 <ski> (iirc, `ignore' is used by SML)
07:10:56 <ski> (i don't care if it's called `void' in an FFI module. but please not in `Data.Functor' and `Control.Monad')
07:11:07 <MarcelineVQ> i'm okay with calling it   () $>   as well
07:11:22 <boxscape> shouldn't it be?`() <$`?
07:11:28 <boxscape> :t (<$)
07:11:29 <lambdabot> Functor f => a -> f b -> f a
07:11:55 <MarcelineVQ> ye, mixed up my <><><
07:11:55 <Iceland_jack> fmap mempty
07:12:08 <ski> @hoogle (<><><)
07:12:09 <lambdabot> No results found
07:12:19 <boxscape> @hoogle ><>
07:12:19 <lambdabot> No results found
07:12:22 * ski is disappointed
07:12:23 <boxscape> yet another fish operator
07:12:26 <MarcelineVQ> vicious fishes
07:18:01 <atwm> @version
07:18:01 <lambdabot> lambdabot 5.2
07:18:01 <lambdabot> git clone https://github.com/lambdabot/lambdabot
07:18:29 <atwm> @type map
07:18:31 <lambdabot> (a -> b) -> [a] -> [b]
07:21:08 <hseg> why is GHC unhappy with coerce @(Vector n Rational) @(Vector n (Sum Rational)) ?
07:21:23 <hseg> Couldn't match type ‘GHC.Real.Ratio Integer’ with ‘Sum Rational’
07:23:23 <yorick> if I have a cabal file, how do I make things like extra-source-files and license-file look in a parent directory?
07:23:32 <glguy> What's the type role on that Vector?
07:24:35 <geekosaur> yorick, .. is parent directory like . is current directory
07:25:20 <geekosaur> you can also use it with a path, e.g. extra-source-files: ../lib
07:25:58 <hseg> hrm. don't see in haddocks, is there some way to tell cabal to load a ghci without dying from my file's errors?
07:26:02 <yorick> geekosaur: oh, I see, my build process was throwing away the parent directory, but the child directory contained symlinks
07:30:54 <boxscape> is there a way to make this work? I'm not sure where I could add the SingI a1 constraint and where I could get a1 https://pastebin.com/qeMfSSJL
07:31:22 <boxscape> basically I'm trying to make a function like `Proxy (f :: a ~> b) -> a -> b`
07:31:52 <Iceland_jack> boxscape: This compiles for me, but I have extensions enabled
07:31:58 <boxscape> oh, ok
07:32:06 <boxscape> good to know
07:32:21 <boxscape> Iceland_jack which ghc version are you on?
07:32:29 <Iceland_jack> 8.10.0.20191123
07:32:33 <boxscape> ok
07:45:52 <dmwit> hseg: Is this unboxed vector (a data family, and so a restrictive type role) or boxed vector?
07:46:11 <hseg> boxed: https://hackage.haskell.org/package/vector-sized-1.4.0.0/docs/Data-Vector-Sized.html
07:47:22 <dmwit> mmm
07:47:27 <dmwit> You can ask about the role with :i in ghci.
07:47:39 <dmwit> You can probably get the file to load with -fdefer-type-errors.
07:47:46 <Iceland_jack`> I think this is the answer to the Singletons question?
07:47:55 <dmwit> I wouldn't be surprised if sized-vector is forced to have a restrictive type role.
07:48:01 <Iceland_jack`> foo :: forall a b (f :: a ~> b). SingFun f => a -> b
07:48:01 <Iceland_jack`> foo = fromSing (sing @f)
07:48:21 <Iceland_jack`> where SingFun (f :: a ~> b) = (SingI f, Good a, Good b)
07:48:29 <dmwit> It's typical for higher-kinded arguments to get a restrictive role, unfortunately.
07:48:36 <Iceland_jack`> where Good a = (Demote a ~ a, SingKind a)
07:48:53 <boxscape> Ah, thanks Iceland_jack`
07:50:20 <hseg> dmwit: gimme a sec
07:50:54 <dmwit> Richard has thought some about what to do about this. So have I, and I suppose others. But the solutions seem fairly complicated, and the need for solutions seems pretty sparse, so...
07:51:34 <hseg> right
07:52:04 <hseg> in unrelated news, backpack keeps having horrible ux re errors
07:52:23 <hseg> forgot to add an identifier to the signature's export list, giving me
07:52:29 <Iceland_jack`> I really want a beefed up roles system
07:52:32 <hseg> <no location info>: error:
07:52:33 <hseg>     The identifier toN does not exist in the local signature.
07:52:35 <hseg>     (Try adding it to the export list of the hsig file.)
07:52:43 <hseg> with no provenance info whatsoever
07:53:01 <Cale> Iceland_jack: I think I like John Ericson's idea of replacing the role system with a system that allows users to specify the types of coercions directly
07:53:11 <Cale> (and have GHC check them)
07:53:21 <merijn> I like the role systeml
07:53:28 <merijn> It's just stupid the default is unsafe :\
07:54:53 <Iceland_jack`> What is the unsafe default?
07:55:11 <Iceland_jack`> Cale: I remember serveral proposals, you're talking on of the GHC proposals then?
07:55:14 <Iceland_jack`> *one
07:55:19 <hseg> wait wait wait. -fdefer-type-errors requires rebuilding the world?
07:55:26 <Cale> Iceland_jack: I'm not sure if it's a fully baked proposal yet
07:56:34 <Cale> https://github.com/Ericson2314/ghc-proposals/blob/coercions-without-roles/proposals/0000-coercions-without-roles.rst
07:57:42 <Cale> That's rather technical though...
07:58:00 <Cale> The part under "Surface language" is the interesting bit
07:58:02 <geekosaur> hseg, it wouldn't surprise me, alhtough it's arguable. (it does change semantics, but from failure to compile to compiling with bottoms)
07:58:14 <Cale> (or the bit which explains what he's talking about :)
07:58:57 <hseg> well, at least it gives me more errors to work with
07:59:06 <Cale> The idea being that we don't really need roles at all, if we just have ways to tell GHC directly what ought to be coercible
07:59:34 <hseg> btw, -fdefer-type-errors isn't enough to get ghci to start up atm
07:59:42 <Iceland_jack`> Is it ever the case that we want a type to be Coercible in different incompatible ways?
08:01:06 <hseg> while i'm working on that, a different question: GHC dislikes me implementing a signature data Monomial (n::Nat) with the pair of type synonyms type Monomial' (n :: Nat) = Vector n (Sum Rational); type Monomial n = Monomial' n
08:01:32 <Cale> Iceland_jack: Well, the main issue right now is that it's impossible to say anything subtle about how the role of a variable of kind * -> * might vary with the role of its argument
08:02:18 <kritzefitz> IIRC it is possible to use TypeApplications in patterns to bind new type variables the pattern brings into scope. However, I get a syntax error when I try to do it. Is there an extension that needs to be enabled to do this (besides TypeApplications)?
08:02:33 <Ericson2314> Cale: Iceland_jack`: so in https://github.com/ghc-proposals/ghc-proposals/pull/276#issuecomment-532799166 a commet on tree owl's proposal
08:02:35 <Iceland_jack`> kritzefitz: It's not yet implemented
08:02:54 <Iceland_jack`> Do I remember correctly that roles were once intended to belong in kinds
08:02:56 <kritzefitz> Iceland_jack`, alright. Thanks!
08:03:01 <Ericson2314> I outlined what I think is a sane baby-stetps plan to get from the status quo via tree owl's proposal
08:03:22 <Ericson2314> in particular, the first steps actually come with a proof sketch that things will be OK
08:04:04 <Ericson2314> basically "we never needed nth co anyways"
08:04:32 <Ericson2314> and that in turn should make the post tree owl's my half of the plan a lot less scary
08:04:59 <Iceland_jack`> I am excited for it
08:06:38 <Iceland_jack`> It's all a very bizarre way of programming
08:07:34 <Iceland_jack`> It's frustrating that Functor doesn't imply a representational argument
08:07:44 <Iceland_jack`> I don't know what the best way to get there is
08:08:15 <Iceland_jack`> It bubbles up to Traversable, where you have an Applicative quantified in a method type
08:08:44 <Iceland_jack`> and all of a sudden you can't coerce its parameter, which means we can't coerce Traversable or Monad + join
08:08:58 <Iceland_jack`> *derive
08:09:09 <Iceland_jack`> or Distributive
08:09:25 <Iceland_jack`> which makes deriving Representable bothersome instead of a joy
08:14:48 <hseg> annoying that GHC's warning interface is so coarse-grained. why can't i annotate the location of the potential warning with a pragma saying "trust me *here*"
08:14:50 <hseg> ?
08:16:39 <boxscape> hseg https://gitlab.haskell.org/ghc/ghc/issues/602
08:16:41 <boxscape> opened 15 years ago
08:19:47 <hseg> :facepalm: then again, nontrivial, needs research, research cost probably outweighs annoyance
08:20:25 <geekosaur> th rework of warnings around 8.0 was intended in part to make it easier to do this, iirc
08:22:41 <hseg> hm. we'll see
08:27:54 * hackage language-ats 1.7.8.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.8.0 (vmchale)
08:42:23 * hackage HPi 0.6.0 - GPIO, I2C and SPI functions for the Raspberry Pi.  https://hackage.haskell.org/package/HPi-0.6.0 (WJWH)
08:51:12 <boxscape> hmm is there some way to get a SingI instance for `f .@#@$$$ g` (i.e. (f :: a ~> b) composed with (g :: a ~> b)) if I have a SingI instance for f and one for g?
08:54:03 <boxscape> I suppose the question is equivalent to asking "can I get a singleton for the composition if I have a singleton for f and g"
08:55:24 * hackage sqlite-simple 0.4.17.0 - Mid-Level SQLite client library  https://hackage.haskell.org/package/sqlite-simple-0.4.17.0 (sigrlami)
08:56:24 <boxscape> wait
08:56:27 <boxscape> that should be trivial
08:56:35 <nvd> It's (%.), right?
08:56:38 <boxscape> right
08:57:01 <boxscape> (I actually forgot what the right prefix was so thanks)
09:00:31 <dminuoso> `f .@#@$$$ g`
09:00:33 <dminuoso> Is that a thing?
09:00:38 <dminuoso> That looks a lot like comic swearing...
09:00:45 <nvd> singletons library is madness
09:01:24 <dminuoso> data (a6989586621679545603 :: (~>) b6989586621679545427 c6989586621679545428) .@#@$$$ (a6989586621679545604 :: (~>) a6989586621679545429 b6989586621679545427) :: (~>) a6989586621679545429 c6989586621679545428 infixr 9 
09:01:26 <dminuoso> It's so clear now.
09:01:38 <dminuoso> data ($@#@$) :: forall a6989586621679545421 b6989586621679545422. (~>) ((~>) a6989586621679545421 b6989586621679545422) ((~>) a6989586621679545421 b6989586621679545422) infixr 0 
09:01:39 <dminuoso> Th eheck
09:02:43 <boxscape> dminuoso TH generated defuntionalized versions of operators
09:03:18 <boxscape> @#@ suffix to make sure it doesn't overlap with anything real, a number of dollar signs to indicate how many arguments it takes
09:03:18 <lambdabot>  suffix to make sure it doesn't overlap with anything real, a number of dollar signs to indicate how many arguments it takes
09:03:28 <boxscape> where one dollar sign means it takes 0 arguments for some reason
09:03:38 <boxscape> and wow I didn't know about that lambdabot command
09:04:06 <geekosaur> it's @@, edit corrected
09:04:14 <boxscape> ah
09:04:16 <geekosaur> expands commands in-line and echoes back
09:04:22 <boxscape> I see
09:45:10 <nshepperd2> ah yes, ($@#@$), the confused robot operator
09:45:58 <Iceland_jack`> Every new operator must cite Haskell as prior work
09:46:46 <boxscape> oh got home from work and I see we're still talking about singletons operators, nice
09:51:54 <boxscape> unfortunately I think %. isn't quite what I want because instead of producing a singleton for `a ~> c`, it produces a function that takes a singleton of type a and produces a singleton of type c
09:52:15 <boxscape> so I guess I need a function of type `(a -> b) -> (a ~> b)`
09:52:46 <boxscape> is that a thing?
09:53:54 <boxscape> looks like TyCon1 maybe. But I might be getting confused with what I'm allowed to do with unmatchable functions.
09:57:05 <Iceland_jack`> You can produce a singleton with sing?
09:58:22 <Iceland_jack`> sing :: SingI f => SLambda f
09:58:27 <Iceland_jack`> sing @(_ ~> _)
09:58:36 <boxscape> ah, I'll try that, thank you
09:58:57 <boxscape> (I think my comment about TyCon1 was completely wrong btw, whoops)
10:00:50 <boxscape> (the function I actually need is (Sing a -> Sing b) -> Sing (a ~> b))
10:08:24 <boxscape> hmm I'm not sure if sing helps me with that
10:08:35 <boxscape> since then I'm still left with basically the same problem of getting the SingI instance
10:14:29 <Zemyla> So I'm writing a function that required an Ord instance to keep things in Maps and tell them apart easier, but it can do with just an Eq. And the algorithn itself takes time O(length ls * length (uniq ls)).
10:15:37 <Zemyla> And I realized that that's how long it takes to replace each value with an (Int, value) pair uniquely identifying them.
10:17:09 <Finianb1> I heard that GHC with certain extensions enabled isn't even guaranteed to halt 
10:17:24 <Finianb1> Does anyone know any examples of this? Or whether it's even true? 
10:17:41 <boxscape> Finianb1 afaik if you leave out bugs that can only happen if you set -freduction-depth=0
10:17:47 <Finianb1> Ah ok 
10:17:49 <boxscape> which by default is 200
10:18:03 <boxscape> and means it only reduces types 200 times (or something along those lines) before aborting
10:18:09 <boxscape> 0 means it doesn't check
10:18:33 <boxscape> Finianb1 in addition you have to use something like UndecidableInstances
10:18:56 <Finianb1> So it never reduces types or does it infinitely with 0?
10:19:03 <boxscape> Finianb1 and then I think an instance like `instance A => A` should do it (assuming you have (A => ...) somewhere else)
10:19:09 <boxscape> Finianb1 infinitely
10:19:47 <Finianb1> Oh 
10:20:08 <boxscape> (the "undecidable" in the name of the extension is a hint that it can lead to not halting)
10:20:08 <Finianb1> Yeah that explains that 
10:21:54 <Finianb1> Will it segfault? 
10:22:08 <boxscape> I don't think so
10:22:18 <boxscape> maybe it'll run out of memory at some point, I'm not sure
10:22:47 <Finianb1> Ah 
10:32:38 <boxscape> (turns out the solution to my problem was using SLambda directly rather than sing)
10:32:53 <Zemyla> :t \t -> fmap fst $ runState (traverse (\a -> state $ \s@(n, l) -> foldr (\k@(_,b) r -> if a == b then (k, s) else r) (let { !m = n + 1; k = (n, a) } in (k, (m, k:l))) l) t) (0::Int, [])
10:32:55 <lambdabot> (Traversable t, Eq b) => t b -> (t (Int, b), Int)
10:33:27 <Zemyla> This is what I'm planning, only with fixed pairs that have strict unpacked Ints.
10:34:15 <Zemyla> Words, rather. I don't know why Haskell uses Int for things that can't be negative, like length.
10:34:56 <Zemyla> :t \t -> fmap fst $ runState (traverse (\a -> state $ \s@(n, l) -> foldr (\k@(_,b) r -> if a == b then (k, s) else r) (let { !m = n + 1; k = (n, a) } in (k, (m, k:l))) l) t) (0::Word, [])
10:34:58 <lambdabot> (Traversable t, Eq b) => t b -> (t (Word, b), Word)
10:36:33 <Zemyla> As a bonus, it also (a) prunes away all but O(k) element addresses, and (b) tells you how many unique values you have afterward.
10:45:17 <nshepperd2>  because wrapping around to 2^64-1 for things that can't be negative is worse than going to -1
10:47:27 <nshepperd2> you really want a newtype around Int that throws an exception on negative for things like that
10:50:04 <jsomedon> heard there is haskell2020? is this like a bunch of new syntax and whatnot
10:50:46 <boxscape> there's a half-hearted effort to make a new haskell standard that incorporates some of the most commonly used change that have been made to ghc since Haskell2010 came out
10:51:25 <jsomedon> so is haskell rolling out new version each 10-year-ish? to me the pattern looks like haskell98(roughly 2000) -> haskell2010 -> hasekll2020
10:51:49 <boxscape> well, that's the idea I guess, but it seems unlikely at this point that a report will be released in 2020
10:51:58 <jsomedon> I see
10:52:00 <Finianb1> ah I misconfigured SSL 
10:53:35 <Finianb1> can you guys see my messages now? 
10:56:03 <boxscape> yes
10:58:23 * hackage vty 5.27 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.27 (JonathanDaugherty)
11:10:53 * hackage bytebuild 0.3.4.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/bytebuild-0.3.4.0 (andrewthad)
11:18:24 * hackage byteslice 0.2.2.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.2.2.0 (andrewthad)
11:22:23 * hackage aeson-yaml 1.0.6.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.6.0 (patrick)
11:27:24 * hackage small-bytearray-builder 0.3.4.0 - Serialize to bytes  https://hackage.haskell.org/package/small-bytearray-builder-0.3.4.0 (andrewthad)
11:44:40 <monochrom> Oh noes, 8.8.3 already!
11:47:12 <monochrom> Heh ghcup hasn't known about it. :)
11:48:05 <maerwald> monochrom: it's a lie
11:48:24 <koz_> maerwald: Like the cake.
11:50:13 <monochrom> Hrm, the list is cached. Is the cache updated regularly?
11:51:22 <maerwald> https://gitlab.haskell.org/ghc/ghc/issues/17874 there was some confusion
11:51:29 <maerwald> I'm still not sure if this is a proper release now.
11:51:40 <monochrom> Ah OK
11:51:53 <maerwald> it showed up in downloads before there was a release page
11:52:12 <monochrom> On haskell-cafe bgamari said he needed to hot-swap a binary.
11:52:41 <bgamari> maerwald, it is
11:52:48 <maerwald> oh ok
11:52:55 <monochrom> :)
11:53:06 <bgamari> maerwald, things were sorted out a few hours after I made the original announcemnet
11:53:24 * hackage bencode 0.6.1.0 - Parsers and printers for bencoded data.  https://hackage.haskell.org/package/bencode-0.6.1.0 (PeterSimons)
11:54:54 <geekosaur> suppose at some ppoint I should upgrade
11:55:42 <maerwald> no freebsd tarball :/
11:58:59 <hugbubby> can someone here tell me how to print an IO Bool to stdout without asking me to read fifty pages of backstory on category theory and another ten monad tutorials
11:59:25 <merijn> hugbubby: "foo >>= print" (assuming "foo :: IO Bool")
11:59:34 <hugbubby> Thank you
12:00:13 <hugbubby> god. it works. I'm experiencing such relief
12:00:20 <bgamari> hugbubby, or if you would rather use `do`: do x <- foo; print x
12:00:21 <merijn> On a related note category theory is mostly useless for learning Haskell and doesn't really have anything to do with IO :p
12:01:43 <geekosaur> @where iotut
12:01:43 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
12:01:46 <hugbubby> now that "stack build" works, how do I run my program. stack exec seems to be expecting a "CMD", but I just want to run the main.hs file I've defined in app/
12:02:31 <hugbubby> Found stack run, it's lit
12:05:00 <mastarija> Does anyone know of any good papers involving FRP and networking. I'm interested in FRP state synchronization for multiplayer video games.
12:05:37 <merijn> mastarija: That seems incredibly hard, so I'm going to bet such a paper doesn't exist yet
12:05:53 <koz_> mastarija: I certainly haven't seen anything, and I deep-dove that literature probably a month or so ago?
12:06:04 <koz_> The issue here goes kinda beyond FRP.
12:06:24 <koz_> (the kind of dirty trickery required to _not_ have hideous latency for such games, especially if they're real-time, is pretty extreme)
12:06:27 <mastarija> Well, I'm preparing to write my thesis possibly on this topic so I'm trying to find some previous attempts
12:07:24 <koz_> mastarija: Sounds like a pretty great idea. I don't think anyone's attempted this kind of thing.
12:07:26 <mastarija> merijn: can I have a short version of why this is hard?
12:07:37 <koz_> mastarija: The problem is that latency murders you.
12:08:01 <koz_> So what (especially real-time) games do is allow local state to diverge, provided that you _eventually_ verify consistency with a server.
12:08:10 <koz_> This is why when the connection is bad, the game 'bounces'.
12:08:22 <koz_> (since the server is 'correcting' your view of the game state to what it 'should' be)
12:08:32 <koz_> How to deal with this in the context of FRP is ... unknown at best.
12:08:38 <merijn> mastarija: Because most low latency games rely on local prediction and retroactively correcting what happened, so you have (basically) two independent simulations
12:08:52 <merijn> mastarija: One of which (the client) is doing all sorts of latency and movement prediction
12:08:54 <mastarija> Yes, but I'm kind of thinking I could kind of send "delta" signal packages and retroactively calculate current state
12:08:58 <merijn> It seems very hard to integrate those two
12:09:13 <koz_> mastarija: Latency _still_ murders you. It's not about how much data.
12:09:17 <koz_> It's the fact you gotta send at all.
12:09:25 <mastarija> Yes,
12:09:51 <mastarija> I mean, I do have some ideas
12:09:58 <koz_> It's a very interesting research idea - basically, you wanna look at how they do this kind of thing in non-FRP settings, and see if FRP can be extended to fit them.
12:10:11 <koz_> I'm _fairly_ sure nobody's done this, and it has some seriously cool implications if you can make it work.
12:10:32 <mastarija> Hehe, now I'm kind of excited
12:10:37 <koz_> You and me both.
12:11:04 <solonarv> it seems to me like there is nothing making it impossible in principle, but it will be very hard
12:11:27 <mastarija> Well, I'll be making a simple game with deterministic physics
12:11:28 <koz_> solonarv: I agree. The devil as ever is in the details though.
12:11:33 <mastarija> Just as a proof of concept
12:11:40 <hugbubby> I'm confused. Hard with haskell or hard in general? Because good realtime games exist
12:11:46 <mastarija> Haskell
12:11:49 <koz_> hugbubby: Hard with FRP.
12:11:59 <mastarija> Oh. misunderstood the question
12:12:01 <mastarija> :D
12:12:13 <koz_> That's the hard part - FRP systems haven't been designed with this in mind.
12:12:19 <koz_> (neither in theory nor in practice I believe)
12:12:24 * hackage dejafu 2.1.0.3 - A library for unit-testing concurrent programs.  https://hackage.haskell.org/package/dejafu-2.1.0.3 (barrucadu)
12:14:04 <mastarija> Well, I've scoured the web, consulted with IRC and now it's time to nag my mentor :D
12:14:53 <jle`> due dilligence achieved 
12:15:03 <koz_> Yeah, this is definitely due diligence done. :P
12:15:17 <koz_> But yeah, feel free to chime more at us - I, for one, am quite curious about what you plan to do.
12:17:04 <monochrom> Hey dejafu looks interesting.
12:19:36 <monochrom> It might be fun to show my students the basic idea behind it, i.e., instantiate MonadConc one way for production code, another way for more exhaustive testing (almost verification by that point).
12:19:40 <mastarija> koz_: Well, I have a grid based game in mind. User movement is locked to the grid but there are projectiles and stuff that can move around freely in deterministic fashion. I'm thinking of syncing the "game starting" time between all the clients and sending timestamped signals to all other clients.
12:20:26 <mastarija> koz_: this seems like a viable solution, although it might involve some backtracking and recalculation to sync the state
12:20:28 <koz_> mastarija: Again, latency. I seriously say - look at how existing games handle this problem, specifically big multiplayer FPSes.
12:20:33 <sm[m]> wow, how about starting with pong
12:20:38 <koz_> Your problem isn't how much state you can crunch.
12:20:57 <koz_> It's the fact that sending traffic down a wire has a fixed time cost you can't fix unless you are literally God.
12:21:38 <koz_> Also, that value is by _no_ means identical, or even similar, for different clients.
12:21:43 <koz_> s/value/cost/
12:21:47 <mastarija> Yes, I can do prediction of client interaction. And then retroactively fix the state.
12:22:21 <merijn> mastarija: I think the problem is that I don't think anyone's ever thought about how "retroactively fixing the state" is supposed to fit into FRP :p
12:22:25 <mastarija> Obviously I need to do more reading on this topic, but thanks :D
12:22:25 <koz_> mastarija: In that case, the tasks are: 1) figure out how to integrate this into FRP, preferably theory-first; and 2) try it and see if the constant factors murder you.
12:23:12 <koz_> Consider also how this scales up to more clients - it's not impossible that they diverge in different ways.
12:23:19 <koz_> (due, again, to differences in latency)
12:23:27 <koz_> (which are totes possible and can be quite severe)
12:26:34 <mastarija> Latency is "fixed" by syncing clocks with the server, Snappines by predicting user movement, and state by checking if client time is greater than the time of last received timestamped signal from the server. In that case I rollback the game state in deterministic fashion, apply newly arrived signals and render.
12:26:54 <mastarija> koz_: Although this is very vague idea at the moment
12:27:04 <earthy> https://www.deconstructconf.com/2019/ayla-myers-multiplayer-game-networking-the-brute-force-approach may be of help
12:27:09 <koz_> 'Synching clocks with the server' <-- I hope you've read at least _one_ book on distributed systems, which explain just how challenging an idea this is in a distributed setting. :P
12:27:50 <mastarija> I have, but I have better and more retarded idea in mind to solve this for my intended purpose :P
12:28:30 <koz_> This is actually a major tricky bit, since 'time' is a key notion for FRP, and is an annoyance in a distributed setting.
12:28:39 <mastarija> Well, I have dreams.
12:28:47 <koz_> I suspect _very_ strongly your future thesis will have at _least_ a chapter on this exact issue.
12:29:04 <mastarija> Yes I think so too.
12:29:44 <mastarija> earthy: thanks for the link
12:29:56 <sm[m]> mastarija: did you find TeaTime, time modelling in the Croquet VR system ? Might be of interest
12:30:10 <sm[m]> even though not FRP
12:35:06 <hseg> unclear on the interaction bw backpack and roles. have a sig demanding data Monomial (n::Nat) [note, ghc seems to infer n is nominal], can i implement it with type Monomial n = Vector n Int where role Vector phantom nominal ? 
12:35:45 <hseg> hrm. writing it out, basically the question boils down to can i implement a type expecting a nominal param with a type having a phantom param
12:35:58 <hugbubby> if I have an array [IO ()], how do I compress that into one IO ()
12:36:39 <hugbubby> or take the first IO () and concatenate it with the rest
12:36:49 <dsal> hugbubby: That's a list.
12:36:54 <dsal> :t sequenceA
12:36:55 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
12:37:05 <merijn> :t sequence_ `asAppliedTo` ([] :: [IO ()])
12:37:06 <lambdabot> [IO ()] -> IO ()
12:37:54 <mastarija> sm[m], I'm trying to find that article / paper but I'm not finding anything on TeaTime website or in searches. Do you maybe have a link
12:39:09 <hseg> docs seem to suggest phantom < rep'al < nom'al, so this should be accepted...
12:39:58 <hseg> except ghc still complains
12:40:16 <hugbubby> sequenceA doesn't work, sequence_ does
12:40:18 <hseg> "• Type constructor ‘Monomial’ has conflicting definitions in the module and its hsig file"
12:41:33 <zeta_0> geekosaur: i was finally able to get vscodium working in xmonad
12:41:40 <sm[m]> mastarija: I'm thinking of https://en.wikipedia.org/wiki/Croquet_Project#Synchronization_architecture, and David Reed's papers mentioned there
12:42:10 <mastarija> sm[m], thanks!
12:42:37 <geekosaur> how? mght be woorth a note to the list or the wiki
12:43:10 <sm[m]> which seem to be at https://www.deepplum.com/dpr/ now
12:44:13 <hseg> ... how do i get ghci to spit out the role annotations?
12:44:28 <hseg> :info sometimes works and sometimes doesn't
12:47:43 <sm[m]> mastarija: pretty nice time syncronisation demoed in the video at http://www.croquet.zone 
12:49:46 <sm[m]> well, I'm not finding the relevant papers. I used to read Alan Kay and David Smith (https://en.wikipedia.org/wiki/David_A.Smith(computer_scientist))'s blogging about them. They must be somewhere
12:51:23 <sm[m]> I guess you could just email him
12:57:48 <hseg> hrm. how do i use error in an impredicative context?
12:58:18 <hseg> eg need to error out instead of returning a cps'd function
13:06:18 <jle`> example?
13:07:41 <hseg> error "h" :: (forall r. (Int -> r) -> r) -> Int is rejected due to "requiring impredicative polymorphism"
13:07:53 <koz_> Is there a package that provides a _non-empty_ set? Kinda the Data.Set analog to Data.List.NonEmpty?
13:07:55 <sm[m]> aeson's toJSON instance for Integer uses scientific notation for large integers. Would anyone know why ?
13:08:17 <koz_> sm[m]: I suspect it might have something to do with them using Data.Scientific for Number in Value?
13:08:29 <sm[m]> aha, thanks
13:08:41 <koz_> I've been grubbing about in Aeson rather more than I'd like lately.
13:08:44 <koz_> (for Work Things)
13:08:56 <sm[m]> also, I could be confused but I feel sometimes it's wrong. I've seen ...e254 which I think should have been ...e-1
13:09:20 <jle`> :t error "h" (forall r. (Int -> r) -> r) -> Int
13:09:22 <lambdabot> error: parse error on input ‘->’
13:09:25 <jle`> :t error "h" :: (forall r. (Int -> r) -> r) -> Int
13:09:27 <lambdabot> error:
13:09:27 <lambdabot>     • Cannot instantiate unification variable ‘a0’
13:09:27 <lambdabot>       with a type involving foralls: (forall r. (Int -> r) -> r) -> Int
13:09:44 <jle`> hseg: hm, sounds like a different error ?
13:09:49 <hseg> meh, am satisfying the completeness checker unnecessarily, so it doesn't really matter -- ghc isn't smart enough (nor shouldn't it be) to know odd x \/ even x = True
13:10:01 <hseg> no, that's the error i'm getting
13:10:21 <hseg> lambdabot is just truncating the part i was referring to 
13:10:32 <jle`> i guess you can make it an errory function
13:10:36 <jle`> :t \_ -> error "h" :: (forall r. (Int -> r) -> r) -> Int
13:10:39 <lambdabot> error:
13:10:39 <lambdabot>     • Cannot instantiate unification variable ‘a0’
13:10:39 <lambdabot>       with a type involving foralls: (forall r. (Int -> r) -> r) -> Int
13:10:46 <hseg> tried that
13:10:49 <jle`> :t (\_ -> error "h") :: (forall r. (Int -> r) -> r) -> Int
13:10:51 <lambdabot> (forall r. (Int -> r) -> r) -> Int
13:10:54 <jle`> yay
13:10:57 <hseg> ... wtf
13:11:05 <jle`> before the type annotation was only referring to the lhs of ->
13:11:09 <jle`> :t \_ -> 3 :: Int
13:11:12 <lambdabot> p -> Int
13:11:16 <jle`> the :: Int only refers to the 3, not the \_ -> 3
13:11:20 <jle`> * rhs
13:11:23 <koz_> Seems nonempty-containers has my back.
13:11:33 <jle`> neat library :)
13:11:37 <hseg> no, my wtf was re the type error vanishing with parens
13:11:44 <koz_> jle`: 'errory' is best adjective.
13:11:55 <koz_> jle`: Are you trying to compete with Edward for Haskell ecosystem presence?
13:12:03 <hseg> also, note \_ -> x /= const x in this regard
13:12:05 <jle`> hseg: do you see the difference that the parens offers?
13:12:11 <jle`> :t \_ -> 3 :: Int
13:12:12 <lambdabot> p -> Int
13:12:17 <jle`> :t (\_ -> 3) :: Int
13:12:19 <lambdabot> error:
13:12:20 <lambdabot>     • Couldn't match expected type ‘Int’
13:12:20 <lambdabot>                   with actual type ‘p0 -> Integer’
13:12:25 <jle`> :t (\_ -> 3) :: Bool -> Int
13:12:27 <lambdabot> Bool -> Int
13:12:41 <jle`> :t \_ -> 3 :: Bool -> Int               -- maybe more relevant here
13:12:43 <lambdabot> error:
13:12:43 <lambdabot>     • No instance for (Num (Bool -> Int)) arising from the literal ‘3’
13:12:43 <lambdabot>         (maybe you haven't applied a function to enough arguments?)
13:12:44 <hseg> which i just realized is because const x needs to unify, leading us back to our original mess
13:13:02 <jle`> koz_: heh i'm nowhere near there, and there are people further along than me :)
13:13:10 <jle`> you'll get there soon tho
13:13:17 <hseg> oh ffs. precendence rules. ofc
13:13:30 <koz_> jle`: Glad you have such faith in me. :P
13:14:14 <hseg> jle`: ty
13:14:42 <sm[m]> Scientific does not seem very industrial strength
13:15:02 <koz_> sm[m]: I'm glad I'm not the only one who thinks so, but unfortunately, Aeson forces my hand.
13:15:03 <hseg> ok, one problem down, one to go
13:15:26 <koz_> (and yours too, seemingly)
13:15:26 <hseg> am trying to implement a backpack signature data Monomial (n::Nat)
13:15:41 <hseg> tried type Monomial (n::Nat) = Vector n Int
13:15:59 <hseg> tried type Monomial' (n::Nat) = Vector n Int; type Monomial = Monomial'
13:16:04 <koz_> Als, jle`, is the correct pronunciation of 'NESet' 'nee-set'?
13:16:08 <hseg> tried type Monomial' (n::Nat) = Vector n Int; type Monomial (n::Nat) = Monomial' (n::Nat)
13:16:14 <hseg> all are rejected
13:16:14 <koz_> Well, 'ni-set'.
13:16:20 <sm[m]> koz_: yes, it seems so. I'm using Decimal internally, but want to export that as JSON, which involves Scientific.
13:16:28 <sm[m]> Decimal and Scientific seem quite similar
13:16:42 <koz_> sm[m]: I'm not precisely sure what choices motivate the choice of Scientific in Aeson.
13:16:49 <hseg> can't be because of roles, since Vector has roles phantom nominal
13:16:59 <jle`> i say it like 'any-set' in my mind, heh
13:17:19 <koz_> jle`: Yeah, I guess that also works. I render it as 'nee-set', probably due to my anime predilections.
13:17:21 <jle`> like 2NE1
13:17:30 <hseg> the type Monomial = Monomial' try fails because Monomial' isn't fully applied
13:17:43 <hseg> and the others because Monomial isn't eta-reduced
13:17:51 <hseg> how do i move forward?
13:18:22 <jle`> koz_: submit a patch to call it NiiSet
13:18:57 <koz_> jle`: That requires a mascot.
13:19:04 <koz_> Like, a moe Cantor or something.
13:19:46 <koz_> (inb4 metamathematics gets a slice-of-life anime adaptation)
13:20:03 <koz_> (I can't say I'm _totally_ against the idea)
13:20:51 <nshepperd2> hseg: why would you be able to implement 'data Monomial (n::Nat)' with a type synonym?
13:21:00 <hseg> can't i?
13:21:19 <nshepperd2> seems unlikely
13:21:19 <hseg> ... is it just constraints that can be implemented with synonyms?
13:21:52 <hseg> user's guide: Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms
13:22:02 <hseg> with the restriction that a type synonym must be fully eta-reduced, e.g., type T = ... to be accepted
13:23:43 <koz_> Also, jle`: https://github.com/mstksg/nonempty-containers/issues/5
13:24:31 <nshepperd2> afaict "data Monomial (n::Nat)" indicates that Monomial is a data type
13:24:43 <nshepperd2> which means it has to be generative
13:26:07 <koz_> jle`: ... Never mind, I ought to learn to read.
13:26:32 <koz_> Sorry I ever doubted your ability to anticipate my needs.
13:26:35 <nshepperd2> which means when you write 'type Monomial = X', X needs to be resolve to either a data type or a data type applied to something
13:26:42 <hseg> nope - that's hs-boot syntax, see user guide cited above
13:26:57 <hseg> and yes, Monomial eventually resolves to a data type
13:27:01 <nshepperd2> no
13:27:09 <hseg> (through several layers of synonyms)
13:28:01 <nshepperd2> "type Monomial = Monomial'" does not resolve to a data type
13:28:39 <hseg> Monomial = Monomial', Monomial' n = Data.Vector.Sized.Vector n Int = Data.Vector.Generic.Sized.Internal.Vector Data.Vector.Vector n Int
13:28:42 <nshepperd2> Monomial' is an unsaturated type synonym, and doesn't resolve to anything
13:29:08 <nshepperd2> it's not enough for 'Monomial n' to resolve to a data type
13:29:34 <nshepperd2> anyway the answer is to wrap that Vector in a newtype
13:29:52 <tabaqui1> The one who invents Data.Fixed is a genius
13:30:20 <hseg> ugh. so i *need* the newtype wrapper?
13:30:43 <hseg> damned if i don't eta reduce, damned if i do?
13:31:21 <maerwald> monochrom: should be done
13:33:21 <jle`> koz_: i wrote that with you in mind
13:33:39 <koz_> jle`: Lol, so you knew I'll get a Haskell job?
13:33:50 <koz_> Is your middle name Cassandra?
13:34:01 <koz_> Or, perhaps more appropriately, Nostradamus?
13:34:10 <nshepperd2> hseg: looks like it
13:34:49 <hseg> oh well. here's to a bunch of wrapping/unwrapping
13:35:06 <hseg> or more accurately, coercions
13:35:26 <koz_> Nothin' wrong with some Haskell coercions.
13:37:50 <hseg> sure. just are a bit more visible than i'd like them
13:38:30 <hseg> especially in instances such as these - am introducing a newtype just to satisfy ghc's paranoia re type-level lambdas
13:38:42 <hseg> only to immediately coerce it away
13:43:54 <koz_> How do I import patterns? Specifically trying to import IsEmpty and IsNonEmpty from Data.Set.NonEmpty, but GHC ain't having it.
13:44:12 <koz_> Currently phrased as import Data.Set.NonEmpty (IsEmpty, IsNonEmpty, [some other stuff]).
13:45:12 <jle`> pattern FooPattern
13:45:30 <jle`> or if they are associated with a data type, import Blah ( MyType(MyPattern) ) (or just BLah(..)) works too
13:45:47 <koz_> jle`: So in this case, I'd need 'import Data.Set.NonEmpty (pattern IsEmpty, ...)'?
13:45:53 <koz_> Because that gives me a parse error.
13:46:07 <jle`> did you enable -XPatternSynonyms
13:46:11 <koz_> .. sigh.
13:46:26 <koz_> Yep, that made it all better.
13:46:46 <jle`> although i probably should re-export Seq there, and have those patterns be asosicated with Seq
13:46:54 <jle`> so you can import Seq(..) and have it work
13:46:56 <jle`> hm
13:46:57 <solonarv> -XExplicitNamespaces should be enough, tbw
13:46:59 <solonarv> * btw
13:47:19 <koz_> solonarv: All about the byways. :P
13:50:08 <xandru> Anyone know how I would use recursion schemes for an AST of the sort `Statement = K Statement | Assign Expr` `Expr = K | S Expr Expr` that is, both Statement and Expr are recursive, but Expr can occur in Statement? If I just do `Statement r = K r | Assign Expr` and `type Expr = Fix (ExprF)`, would that work?
13:52:45 <jle`> xandru: looks like there is no mutual recursion
13:53:05 <jle`> so StatementF r = K r | Assign Expr, and type Statement = Fix (STatementF) works
13:53:13 <jle`> but if you're using recursion-schemes it might be simpler to just do the TH method
13:53:24 <jle`> er well, fsvo simpler
13:53:38 <jle`> so you don't have to work directly with Fix
13:55:10 <iqubic> I like that better.
13:56:05 <xandru> @jle` I'm using the data-fix package since it seemed to me less complex, but I might give recursion-schemes another look
13:56:05 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
13:56:29 <jle`> ah, data-fix is fine too
13:56:38 <jle`> just thought you were using recursion-schemes from the wording of your question
13:57:30 <xandru> yeah, sorry for the confusion, I have always called it that since I think that's the terminology
13:59:07 <koz_> There's a missed naming opportunity here. Could have been named 'getafix'. :P
14:00:22 <sm[m]> Maybe my brain is friend. https://hackage.haskell.org/package/Decimal-0.5.1/docs/Data-Decimal.html provides roundTo for limiting the number of decimal digits. How would you limit the number of significant digits overall ?
14:00:40 <sm[m]> friend, ha. I like that.
14:01:58 <koz_> Speaking of Data.Fix, could someone answer me a small question: cataM, anaM and hyloM all have Monad constraints. Would they still be possible with only Applicative, and if so, what would this mean for the resulting recursion schemes?
14:02:48 <jle`> cataM/anaM etc. don't really have any 'mathematical'/theoretical founding, they are mostly convenience functions over special catamorphisms that you might write by hand
14:02:50 <jle`> hm
14:03:35 <hseg> ... weird. the same declaration is accepted in GHCi but rejected by GHC
14:03:58 <hseg> oh wait. coerce needs the constructors to be in scope, right?
14:04:09 <jle`> hm i don't think there would be an applicative cousin of cataM
14:04:14 <koz_> jle`: What blocks this?
14:04:19 <koz_> Is it because you need fish?
14:04:29 <lyxia> yes
14:04:47 <jle`> koz_: conceptually, the you need to know the results of each later to be able to know what to do next
14:05:06 <jle`> so an anaM for example might return a differently-sized tree for different results of actions
14:05:08 <jle`> *each layer
14:05:14 <koz_> Yeah, and for this, you need Monad.
14:05:19 <koz_> Because Applicative can't do that.
14:05:46 <jle`> but also i mention the first thing because there isn't really a canonical idea of what cataM/anaM "should" even be, based on the underlying theory
14:05:54 <jle`> they're just useful wrappers for common usage patterns
14:06:12 <jle`> but there is more than one way to implement cataM i think, based o the type
14:06:24 <koz_> jle`: What's another one?
14:06:36 <koz_> I only know the one I've always seen, which is fish-based rather than (.)-based.
14:07:00 <hseg> nope, that didn't fix things
14:07:14 <koz_> (that pun though)
14:07:23 <hseg> (context: coerce @Rational @(Sum Rational) is failing in GHC but not GHCi)
14:07:41 <jle`> well, one thing you need to decide is your function (t (m a) -> m (t a))
14:07:55 <koz_> Where t, m are what?
14:07:58 <jle`> or T (m a) -> m (T a), to make it more clear what is fixed
14:08:02 <koz_> OK, yeah.
14:08:08 <jle`> Monad m => F (m a) -> m (F a), where F is the base functor
14:08:18 <koz_> One option is F is a Traversable.
14:08:22 <jle`> so the data-fix library decides to do this by requiring F to be Traversable and using 'sequence'
14:08:42 <koz_> That's the most obvious.
14:08:53 <jle`> but you have different options maybe for different F
14:09:13 <jle`> and in general even if F is traversable you can do the silly \xs -> sequence xs >> sequence xs
14:09:16 <jle`> which still matches the right type
14:09:32 <koz_> Ah, so you do everything twice.
14:09:37 <jle`> yeah, which might be waht you want
14:09:41 <koz_> Yeah, I see what you mean.
14:09:45 <hseg> hrm. coerce @Rational @(Sum Rational) actually works, but coerce @(Vector 3 Rational) @(Vector 3 (Sum Rational)) doesn't
14:09:57 <koz_> hseg: You can't coerce through a data fam like that.
14:09:58 <jle`> but in general you just need a F (m a) -> m (F a), and ther emight be more than one useful choice for any given F
14:10:00 <koz_> For _extremely_ good reason.
14:10:12 <koz_> jle`: Doesn't it mean that this ought to be a parameter?
14:10:27 <hseg> ... oh right
14:10:40 <hseg> indeed -- Vector's last param is nominal
14:10:42 <jle`> koz_: yeah, if there is a parameter then it becomes more stable
14:10:47 <jle`> koz_: oh yeah, another option is to sequence in reverse
14:10:55 <jle`> :t fmap forwards . traverse Backwards
14:10:57 <koz_> jle`: Lol.
14:10:57 <lambdabot> error:
14:10:57 <lambdabot>     Variable not in scope: forwards :: t b0 -> b
14:10:57 <lambdabot> error:
14:11:03 <koz_> I guess that'd work, silly as it is.
14:11:05 <jle`> @let import Control.Applicative.Backwards
14:11:06 <lambdabot>  Defined.
14:11:08 <jle`> not silly, maybe very useful :)
14:11:10 <jle`> @let import Control.Applicative.Backwards
14:11:11 <koz_> I find it weird that there isn't any theory for this.
14:11:11 <lambdabot>  Defined.
14:11:13 <jle`> :t fmap forwards . traverse Backwards
14:11:15 <lambdabot> (Traversable f1, Applicative f2) => Backwards f1 (f2 a) -> Backwards f2 (f1 a)
14:11:23 <jle`> hm that isn't what i wanted
14:11:28 <jle`> :t forwards . traverse Backwards
14:11:30 <lambdabot> (Traversable t, Applicative f) => t (f b) -> f (t b)
14:11:36 <jle`> % import Control.Applicative.Backwards
14:11:36 <yahb> jle`: 
14:11:57 <jle`> % (forwards . traverse Backwards) [putStrLn "hi", putStrLn "bye"]
14:11:57 <yahb> jle`: bye; hi; [(),()]
14:12:51 <koz_> It seems like a pretty natural thing to want.
14:12:58 <koz_> (I can think of at _least_ one obvious case)
14:15:21 <hseg> ... http://ix.io/2cRg wtf?
14:18:34 <hseg> hrm. if i remove the explicit foralls, ghc stops complaining
14:18:59 <koz_> hseg: I'm guessing this _might_ be a Backpack thing.
14:19:00 <jle`> koz_: i think it's maybe fine just as like, a common use case
14:19:09 <hseg> probably
14:19:11 <jle`> and not necessarily something that *needs* a canonical method
14:19:17 <jle`> or a canonical way
14:19:18 <koz_> jle`: Wouldn't it be nice though?
14:19:30 <koz_> Or at the very least, some actual laws.
14:19:31 <jle`> what good would having a canonical way do?
14:19:39 <jle`> s/do/give you
14:20:17 <koz_> It's be nice to have some guideline to 'this is what will happen if you wanna use recursion schemes with effects'.
14:20:22 <koz_> Kinda like what you have with Traversable, say.
14:20:38 <nshepperd2> hseg: build with -fprint-explicit-foralls and the difference might become apparent
14:20:51 <koz_> Amusingly, the 'Traversable/Monad' choice is what Cofree does for unfoldM.
14:21:00 <koz_> Which I can't help but think is relevant, somehow.
14:21:20 <hseg> nshepperd2: nope, no difference
14:21:30 <koz_> hseg: Not even in error message?
14:21:33 <hseg> nope
14:22:17 <koz_> Same for Free, although foldM wants an NT.
14:22:33 <koz_> Well, foldFree, which isn't _exactly_ foldM I guess?
14:22:41 <nshepperd2> i guess -fprint-explicit-kinds is the other possibility
14:23:32 <nshepperd2> it's probably not -fprint-explicit-runtime-reps
14:24:47 <maerwald> carter: I want a monad transformer of STE :>
14:24:53 <koz_> maerwald: STE?
14:25:02 <maerwald> http://hackage.haskell.org/package/monad-ste-0.1.0.0
14:25:03 <carter> monad-ste is a nice little package of mine
14:25:14 <nshepperd2> my guess is adding the explicit forall is affecting type application visibility or polykindedness
14:25:30 <maerwald> was just trying out http://hackage.haskell.org/package/STMonadTrans-0.4.4/docs/Control-Monad-ST-Trans.html and am now annoyed by the lack of MonadThrow
14:25:51 <carter> maerwald:  you like my having throw but not catch? :)
14:26:09 <carter> theres only one possible throw instance for pure looking things
14:26:37 <carter> maerwald:  its deeply weird (at least in my mind) to have state token State# anywhere but the bottom of the stack
14:26:48 <carter> cause you can't really roll back effects 
14:28:35 <carter> maerwald:  am i making sense?
14:28:51 <maerwald> I'm going for error :P
14:28:54 <carter> nshepperd2:  https://hackage.haskell.org/package/monad-ste koz_  
14:29:04 <carter> maerwald: ?
14:29:09 <maerwald> in this case it's fine if the code crashes
14:29:18 <maerwald> but error is annoying because it depends on evaluation
14:30:24 <carter> maerwald:  https://hackage.haskell.org/package/monad-st-0.2.4.1/docs/Control-Monad-ST-Class.html 
14:31:38 <carter> maerwald:  st monad trans isn't a prim monad
14:31:58 <jle`> koz_: hm, i guess the approach i saw as more compelling was 'there are many ways to use recursion schemes with effects'
14:32:01 <carter> maerwald:  just newtype STE as a monad trans
14:32:10 <jle`> but i guess that's just two different opinions kinda
14:32:24 <koz_> jle`: Sure, that's not hard to believe. I agree with you that One True Way isn't probably what we want.
14:32:49 <koz_> However, it _would_ be nice if, for any given choice(s), we'd actually know what to expect, in the same way that, say, Traversable can give us.
14:36:04 <hseg> (;_;) i have UtilA, UtilB, and ImplB, with dependencies UtilA -> ImplB -> UtilB. ghc forces me to keep UtilA and UtilB separate so as to avoid cyclic deps
14:36:50 <hseg> is there some tool that will give me the dependency graph of my project?
14:37:01 <hseg> broken down by component+module?
14:37:12 <hseg> am losing track with all the backpacking
14:37:31 <koz_> hseg: https://docs.haskellstack.org/en/stable/dependency_visualization, but this depends on stack, which AFAIK doesn't support Backpack.
14:37:49 <hseg> right
14:37:53 <hseg> plus am using cabal
14:38:07 <koz_> Maybe this? https://github.com/yav/graphmod/wiki
14:38:31 <koz_> Old but possibly relevant: https://stackoverflow.com/questions/3431225/tools-for-generating-haskell-function-dependency-control-flow-graph
14:39:08 <hseg> that generates only module-level deps
14:39:34 <hseg> hrm...
14:40:53 <hseg> could write a quick scraper for .cabal that grouped stuff by component
14:41:18 <hseg> don't know enough dot to know how to write hierarchical graphs
14:42:55 <hseg> ah, just need to wrap things in a subgraph{}
15:08:08 <NemesisD> does anyone know how i could derive show on a singleton `Sing` type?
15:09:19 <jle`> deriving instance Show (MySingleton a) ?
15:13:29 <hseg> graphmod is really nice, thanks for the pointer
15:13:42 <electricityZZZZ> i'm reading some programmers who are better at writing code than i am saying that you should rarely use a list. is that accurate? if so, i am seeing in the introductory haskell materials the assumption that i am using lists pretty much everywhere in my code
15:13:45 <hseg> now all i need is to add component ownership data and i'm golden
15:14:23 <jle`> electricityZZZZ: you should never use lists for storing data
15:14:28 <jle`> but for other purposes it's pretty common
15:14:40 <jle`> well, 'never' is a strong word. just that it's not usualyl a good idea
15:14:54 <electricityZZZZ> for instance this opinion http://www.imn.htwk-leipzig.de/~waldmann/etc/untutorial/list-or-not-list/
15:14:57 <jle`> lists are pretty common in haskell as a normal control flow kind of thing
15:15:04 <electricityZZZZ> the rust community also is list-allergic
15:15:07 <boxscape> is there a shorter way to write this? `foo x fax fax' | Refl <- fax @x, Refl <- fax' @(f @@ x) = Refl`
15:15:25 <jle`> electricityZZZZ: right, that's more or less what i mean
15:15:29 <jle`> electricityZZZZ: lists are very common in haskell
15:15:34 <jle`> but for control flow purposes, like iteration
15:15:44 <jle`> but they're not used for data storage
15:15:58 <electricityZZZZ> right, so in simple terms lists are good for LIFO/FIFO queues it looks like
15:16:01 <jle`> so i wouldn't say you should rarely use a list. because lists are extremely common for control flow in haskell
15:16:04 <boxscape> I guess ideally I'd want a way to to TypeApplication in a ViewPattern
15:16:15 <jle`> ah, using them as stacks is also a good application
15:16:25 <jle`> but that's not as common
15:16:26 <electricityZZZZ> so i guess this means that it is being assumed that my computations are stream-oriented?
15:16:31 <jle`> electricityZZZZ: well, i mean something more like:
15:16:37 <jle`> > mapM_ print [1,2,3]
15:16:39 <jle`> er
15:16:39 <lambdabot>  <IO ()>
15:16:41 <jle`> % mapM_ print [1,2,3]
15:16:42 <yahb> jle`: 1; 2; 3
15:16:51 <jle`> let's say i want to print a bunch of things
15:16:51 <boxscape> so I could have something like `foo x (@x -> Refl) (@(f @@ x) -> Refl) = Refl`
15:17:00 <jle`> i would put that bunch of things in a list literal and mapM_ print them
15:17:13 <jle`> or if i wanted to do something for every number from 0 to 10
15:17:34 <electricityZZZZ> so if i don't "store data in a list" then what am i doing when data is in a list...?
15:17:38 <jle`> % mapM_ print [1..10]
15:17:38 <yahb> jle`: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
15:18:12 <jle`> electricityZZZZ: in other languages, arrays are more often used for things like, "multi-slotted variables"
15:18:23 <jle`> for example if you have a bunch of users to keep track of in your application
15:18:28 <jle`> you wouldn't have them in a list of users
15:18:34 <jle`> even though it might make sense to use an array of users in another language
15:19:02 <jle`> for a better example of my number case, often times i'll have something like:
15:19:27 <jle`> forM_ [0..] $ \i -> do putStrLn ("Doing this the " ++ show i " time); doSomething; doSomethingElse
15:19:37 <jle`> which is like:
15:19:42 <jle`> forever $ do doSomething; doSomethingElse
15:19:54 <jle`> it's like 'forever', except i also get the time that i'm currently doing the thing
15:20:16 <jle`> the first time it'll print out 0, then 1, then 2, etc.
15:20:21 <jle`> whereas forever, you don't get the current iteration count
15:20:29 <iqubic> Nice.
15:20:51 <jle`> electricityZZZZ: but yeah, if you want to think of a situation where you wouldn't use list, think of the situations where you would normally use an array in a language like java or c
15:20:52 <iqubic> Isn't forM_ just a flipped mapM_?
15:21:08 <jle`> yes
15:21:50 <electricityZZZZ> list is for sequential (or maybe rolling windowed) memory access while arrays are for random access
15:22:24 <jle`> yeah, that's a fair assessment i think. the same would apply in haskell as well
15:22:47 <jle`> except we have other data structures than array for nice random access too
15:22:58 <electricityZZZZ> hashmap etc
15:24:07 <jle`> the actual advice in the article you linked i would agree with, but i don't quite agree with the intensity of its conclusion 
15:24:15 <jle`> it gives a good description of when to use lists, and when not to use lists
15:24:23 <jle`> but i don't think the 'when to use lists' part is all that rare
15:24:44 <jle`> i'd say it comes up as an everyday thing in haskell
15:25:04 <electricityZZZZ> this is a common rust introduction found in the rust community: https://rust-unofficial.github.io/too-many-lists/
15:25:26 <electricityZZZZ> you can skip to the "obligatory public service announcement" section for a similar story
15:25:53 <jle`> i might say that lists are a little more useful in haskell than in rust, which the article sort of also implies too
15:26:16 <jle`> haskell lists have fusion (maybe rust lists do too?) which makes consuming and building and composing list transformers very memory-efficient
15:26:31 <jle`> but only if you use them in the 'right way'
15:27:12 <electricityZZZZ> i'm guessing also that haskell libraries and soforth are going to presuppose, much or most of the time, that i am working with lists?
15:27:21 <koz_> electricityZZZZ: Depends on what library.
15:27:27 <koz_> vector, for example, presupposes no such thing.
15:27:36 <electricityZZZZ> well, yes, because it's vector :)
15:27:45 <jle`> electricityZZZZ: ideally they would only expect lists in situations where lists make sense
15:28:10 <koz_> electricityZZZZ: Yeah, but the point is that a statement liek that is lacking necessary context to be useful.
15:29:08 <electricityZZZZ> example: select the most commonly used types in from the 50 to 100 most frequently used haskell libraries, these types will be working on lists or supposing that i hand them lists
15:29:48 <koz_> Uhh, that's a _resounding_, _screaming_ 'no'.
15:30:04 <koz_> For example, you'll nary ever see a list in mtl, and that library is in damn near everything.
15:30:22 <electricityZZZZ> ok
15:30:56 <koz_> Other popular libraries provide some interfaces to lists, but don't really _expect_ data this way (containers, unordered-containers, vector come to mind).
15:31:20 <koz_> What jle` says is basically right - lists are definitely somewhat niche, and we have better options in many cases, but being list-allergic in all cases isn't necessarily useful.
15:31:29 <koz_> I _suspect_ your _actual_ question was more like:
15:31:39 <koz_> "What is a sensible heuristic in Haskell for when I want lists versus when I don't?"
15:33:18 <electricityZZZZ> well, my question actually was "will i be, by library availability and convention, coerced to use lists much more often than i will want to in haskell?" because i was supposing that "greybeards say one ought (almost) never to use lists"
15:33:35 <koz_> The answer is 'probably not, leaning toward definitely not'.
15:33:50 <koz_> However, absent more information (such as what you plan to do and how), I'm not sure that question has a good answer.
15:35:39 <koz_> (so thus, my answer's not very good :P)
15:36:26 <electricityZZZZ> i'm intermittently sniffing out haskell and the philosophies of haskellers is i guess the story in my case
15:36:39 <jackdk> question: do hackage uploads support hpack, or does the output of cabal sdist still include a cabal file (I'm reviewing a package, personally I loathe yaml)
15:37:05 <maerwald> god no. Of course you need a cabal file.
15:37:39 <tdammers> hpack needs to go away
15:38:10 <tdammers> it's not worth it, it makes people lazy, and introduces another toolchain dependency without a convincing reason
15:38:39 <jackdk> I agree with all of the above, but am reviewing someone else's package. 
15:40:38 <maerwald> also, cabal files should be committed to the repo, no matter what workflow someone uses, otherwise cabal users can't use source-repository
15:41:16 <electricityZZZZ> i compilled hnes and was impressed to not notice GC pauses in a few minutes of playing
15:41:59 <koz_> electricityZZZZ: Do you typically notice GC pauses?
15:42:03 <koz_> And so, in what language?
15:42:05 <tdammers> maerwald: frankly, that is a bit of a bullshit argument
15:42:25 <tdammers> maerwald: I would argue that "source-repository" is a misfeature, though I don't see a good alternative for the use case either
15:43:13 <maerwald> I don't see why it would be a misfeature
15:43:25 <maerwald> not everyone publishes to hackage
15:56:30 <electricityZZZZ> koz_: oh nevermind gc i have gc trauma and probably worry about it too much
15:56:44 <koz_> electricityZZZZ: Uhhh, OK.
16:09:51 <tdammers> maerwald: it's a misfeature because it essentially means that the git repo must contain the same stuff you would normally put in an sdist
16:10:20 <tdammers> maerwald: and the "not everyone publishes on hackage" thing is of course the use case for which I cannot think of an alternative
16:10:50 <maerwald> npm has the same problem no? Dunno how/if they solved it
16:10:55 <tdammers> maerwald: in a just world, we would all run our own private package repositories, and just push to and pull from those
16:11:06 <tdammers> no idea what npm does there
16:11:38 <tdammers> all I know is, at one job we ran a private maven repo for the company, and we would push our own clojure libraries there, and it was absolute bliss
16:11:44 <maerwald> a repo could provide a cabal hook file that creates an sdist from itself
16:11:55 <tdammers> apart from the fact that we were using clojure, of course
16:12:03 <maerwald> lol, never again
16:12:17 <maerwald> I still dream of brackets
16:12:26 <tdammers> I had such high expectations; boy were those shattered
16:12:41 <maerwald> Missed one on line 575 and the thing still compiled and ran, but did something completely different
16:13:00 <tdammers> they promised me "it's like haskell, only better", but when it comes down to it, it's basically python with slightly more efficient syntax
16:13:16 <tdammers> and metaprogramming, but in the absence of a type checker, that is a misfeature
16:13:42 <koz_> I think someone said that Clojure is what you get if you built a language (and ecosystem) entirely on good-sounding statements. :P
16:13:47 <maerwald> I only did clojurescript... and the frontend would often crash on "minor" bugs
16:13:49 <koz_> (or something to that tune)
16:13:58 <koz_> (I forget the exact wording, but it was better than mine)
16:14:16 <maerwald> like, customer facing pages going blank because you missed a bracket somewhere and the compiler didn't care
16:14:29 <tdammers> yay, live reloading
16:14:50 <tdammers> you can live-reload your code in a fraction of a second, now you get super fast feedback cycles
16:15:05 <maerwald> "is the page still blank sir?"
16:15:12 <tdammers> unfortunately, they are absolutely worthless, because after 1-5 reloads, you have absolutely no idea anymore what is running right now
16:15:31 <tdammers> so you have to restart the whole thing, and that takes *minutes*
16:15:35 <tdammers> might as well use ghc then
16:15:52 <maerwald> like miso? :>
16:16:29 <tdammers> somewhat, yeah
16:16:40 <tdammers> except there is no alternative
16:17:45 <iqubic> is miso worth learning?
16:18:10 <maerwald> dmj` would probably say yes :P
16:18:29 <maerwald> I don't know why I would want access to the haskell ecosystem in a frontend though
16:19:15 <maerwald> I'd rather have something where using large javascript libraries with shitty APIs isn't too much of a nightmare
16:19:17 * dmj` steps into the room
16:19:22 <dmj`> iqubic: yes
16:19:25 <maerwald> lol
16:19:26 <koz_> dmj`: Like the Kool-Aid man?
16:19:31 <iqubic> Why do you say that?
16:19:32 <dmj`> koz_: \o/
16:19:49 <dmj`> iqubic: knowledge is power
16:20:02 <dmj`> the more you know, the more you know
16:20:12 <koz_> dmj`: Or more like https://en.wikipedia.org/wiki/Bear_Surprise?
16:20:32 <iqubic> But I could just spend my time learning Reflex and Reflex-DOM.
16:20:37 <dmj`> iqubic: so, it's easier to use than javascript, you don't have to worry about manual DOM manipulation, and its fast, and does some modern nice things for you.
16:20:49 <iqubic> Nice.
16:20:51 <dmj`> iqubic: if your frontend doesn't handle DOM manipulation for you, you have been failed.
16:21:20 <dmj`> iqubic: miso lets you focus on your application, not the browser
16:21:40 <iqubic> So you think reflex-DOM isn't very good?
16:22:50 <dmj`> iqubic: I haven't really used it, try both. Miso started as an experiment in virtual DOM and grew into a great architecture that exposed a simple API.
16:23:33 <iqubic> I like that. Where's the documentation/getting started guide?
16:23:37 <dmj`> iqubic: the reason applications in the browser are perceived as slow is because people destroy DOM elements willy nilly and it causes a cascading accidentally quadratic layout recalculation
16:24:04 <iqubic> Yeah. I take it Miso doesn't do that?
16:24:20 <dmj`> iqubic: you can think of miso as like accelerate, except miso is a shallow embedding
16:24:35 <iqubic> I don't know what accelerate is.
16:24:51 <iqubic> I want to learn this. Where's the guide?
16:24:58 <dmj`> iqubic: its an embedded DSL for array programming
16:25:38 <iqubic> Ah. I see.
16:25:58 <dmj`> iqubic: when you construct terms in miso's view syntax you're actually constructing a javascript object, not Haskell. When an event happens, miso's runtime (diff.js) sees the newly generated view, diffs it w/ the old one.
16:26:29 <dmj`> iqubic: measures are put into place to minimize heap allocations (any usage of var) in javascript.
16:26:35 <iqubic> Can you point me to a guide, where I might learn how to use this api?
16:26:52 <dmj`> https://github.com/dmjio/miso/blob/master/README.md
16:27:40 <maerwald> the starter guide requires the user to use nix... 
16:27:54 <maerwald> could as well tell them to install gentoo from stage1
16:27:57 <dmj`> iqubic: it's almost too easy, there's not much at all to teach. People have built full applications with it for their companies w/o any help.
16:28:34 <dmj`> maerwald: well stack dropped support, and installing ghcjs from scratch is a pain
16:29:25 <carter> maerwald: I have to agree.  What’s in the hackage source dist should be essentially just be whatever happens by invoking cabal sdist after a repo clone. All else is toxic.
16:29:48 <dmj`> iqubic: miso stores mutable references on a pure rose tree in js.
16:29:56 <iqubic> Nice.
16:30:03 <iqubic> Does it use GHCJS?
16:30:06 <dmj`> iqubic: yea
16:30:13 <iqubic> How do I run the code to test it?
16:30:32 <dmj`> iqubic: git clone https://github.com/dmjio/miso && cd miso/sample-app && nix-build
16:30:42 <iqubic> Oh. Nice.
16:30:45 <iqubic> Sounds good.
16:30:59 <maerwald> is ghcjs still maintained?
16:31:03 <dmj`> iqubic: the hash is pinned so you'll be fine
16:31:08 <iqubic> And all the libraries are on Hackage?
16:31:40 <maerwald> carter: I can't even think of a use case why someone would not want this
16:31:52 <dmj`> iqubic: most
16:32:15 <dmj`> iqubic: but you really don't need a lot on the front end, remember every dep. will cost you in time sent to the client.
16:32:15 <iqubic> `nix-env -iA cachix -f https://cachix.org/api/v1/install` fails for me.
16:32:20 <iqubic> warning: unable to download 'https://cachix.org/api/v1/install': HTTP error 502; retrying in 2652 ms
16:32:22 <dmj`> maerwald: somebody maintains it
16:32:23 <iqubic> error: unable to download 'https://cachix.org/api/v1/install': HTTP error 502
16:32:40 <iqubic> It tries to download the thing a few times, and then fails.
16:32:52 <dmj`> iqubic: well, you can omit the cachix step
16:33:00 <dmj`> iqubic: not sure why its doing that
16:33:15 <iqubic> But won't omitting that step make builds take longer?
16:33:47 <dmj`> iqubic: it will just take longer to get the deps, after you have them its just as fast
16:33:56 <iqubic> Right. I see.
16:34:38 <dmj`> iqubic: also, early WASM stuff is showing that its actually slower for applications that use the DOM (which is 99% of websites), because the overhead in calling between the two runtimes
16:34:58 <iqubic> Does that impact me?
16:35:04 <dmj`> iqubic: not yet
16:35:08 <dmj`> iqubic: no
16:40:08 <dmj`> iqubic: we have a slack too
16:40:14 <iqubic> I see.
16:40:18 <iqubic> Nice.
16:40:29 <dmj`> join the resistance
16:41:38 <iqubic> does Miso work with Firefox?
16:45:22 <iqubic> is Miso considered an FRP library?
16:46:08 <dmj`> iqubic: it supported by all major browsers
16:46:13 <iqubic> Nice.
16:46:46 <dmj`> iqubic: it's not considered FRP
16:47:02 <iqubic> Well. I'm having issues entering a shell here.
16:47:09 <dmj`> `nix-shell -A env`
16:47:31 <dmj`> `nix-shell -A env --run 'cabal configure --ghcjs && cabal build'`
16:48:10 <iqubic> error: attribute 'env' in selection path 'env' not found
16:49:33 <iqubic> My shell.nix is just a single line `(import ./.).env`
16:51:14 <dmj`> oh, just delete your shell.nix
16:51:27 <dmj`> or, make it this `(import ./default.nix).env`
16:51:38 <dmj`> then call `nix-shell`
16:51:40 <iqubic> Ah. I see.
16:51:41 <dmj`> the above commands work for me
16:53:37 <iqubic> error: unable to download 'https://miso-haskell.cachix.org/qmqammgx7j6q5ji9c9g95hvw4388fikj.narinfo': HTTP error 502
16:53:43 <iqubic> And now I'm getting errors.
16:54:44 <iqubic> dmj`: This seems to be a nix thing. People in #nixos are mentioning that they can't get to other cachix sites.
16:58:10 <dmj`> iqubic: I'd ping domenkozar[m] :)
16:58:25 <dmj`> iqubic: but again, cachix is completely optional
16:58:30 <iqubic> I know. I know.
16:58:39 <iqubic> But I don't know how to turn it off.
16:59:05 <dmj`> are you on OSX or some linux that isn't NixOS
16:59:31 <iqubic> No.
16:59:42 <dmj`> iqubic: /etc/nix/nix.conf <- try removing it from here
16:59:44 <iqubic> I'm on NixOS proper.
16:59:48 <dmj`> oh ..
17:00:00 <dmj`> iqubic: then you'll have to remove it in your /etc/nixos/configuration.nix probably
17:00:11 <dmj`> iqubic: or however cachix sets it on nixos
17:00:16 <iqubic> I didn't set it in my configuration.nix.
17:00:36 <iqubic> I ran this to set up my cache: `nix-env -iA cachix -f https://cachix.org/api/v1/install`
17:02:10 <dmj`> iqubic: when you build, try nix-build --option build-use-substitutes false
17:02:18 <iqubic> I will.
17:12:56 <dmj`> iqubic: how did it go
17:13:08 <iqubic> It worked.
17:13:42 <iqubic> So it turns out that domenkozar[m] mucked up a dns config somewhere.
17:15:03 <iqubic> Either that or an nginx config.
17:15:07 <jle`> miso is the medicine to make the frp blues go away
17:16:49 <dmj`> those nix people always be mucking up dns
17:17:15 <dmj`> jle`: "frp got you down? have a bowl"
17:18:54 * hackage deepseq-instances 0.1.0.0 - Candidate NFData Instances for Types in base  https://hackage.haskell.org/package/deepseq-instances-0.1.0.0 (TravisWhitaker)
17:21:31 <iqubic> jle`: Do you like frp?
17:21:46 <jle`> it's neat
17:22:00 <iqubic> Yeah. That's my though too.
17:22:22 <iqubic> dmj`: Can miso deal with routing and different URLs at the same host?
17:23:04 <dmj`> FRP would be great for programming games on the client / server, but only w/ WebGL / OpenGL-like frameworks
17:23:20 <dmj`> iqubic: yes
17:23:23 <dmj`> iqubic: it does routing
17:23:31 <dmj`> iqubic: routes are shared too
17:24:10 <iqubic> dmj`: I want to make games and stuff. I'm not sure how great Miso is at manipulating the JS canvas.
17:24:56 <dmj`> iqubic: the GHCJS FFI is great, miso works well with it
17:24:59 <dmj`> iqubic: https://fizruk.org/fpconf-2017-talk/miso-aframe-demo/dist/demo.jsexe/index.html
17:25:01 <iqubic> Nice.
17:25:29 <iqubic> Is that done in Miso?
17:25:34 <iqubic> Where's the source?
17:30:10 <dmj`> https://github.com/dmjio/miso#examples
17:30:16 <dmj`> has links and source of them all
17:30:45 <dmj`> iqubic: https://www.polimorphic.com/ is all miso too
17:41:53 <energizer`> Hello. Does Haskell have good statistical packages, the kind that R has?
18:30:18 <Guest63310> energizer`: try this: https://hackage.haskell.org/packages/search?terms=statistic
18:32:03 <Guest63310> also: https://hackage.haskell.org/packages/search?terms=probability
18:43:44 <iqubic> dmj`: It looks like Miso is using the MVC design pattern Is that right?
19:31:37 <iqubic> Where's the documentation for Miso's runApp and startApp functions?
19:31:52 <iqubic> Also, I'd love to know what (<#) does.
19:32:06 <iqubic> And noEff too.
20:59:17 <new2this3223> Hi I'm new to Haskell and have a quick question, is there someone I can message?
20:59:35 <iqubic> Just send the message to this channel
20:59:59 <iqubic> No need to send your question to a single user
21:00:18 <new2this3223> okay cool I'm wondering if I have two (a -> b) functions, is it possible to merge them into one?
21:00:20 <Axman6> There's over a thousand poeple you can message, all at once! The first rule of IRC is: Don't ask to ask, just ask
21:00:43 <Cale> new2this3223: Merge them in what way?
21:00:57 <Cale> pair f g x = (f x, g x)
21:00:58 <Cale> like that?
21:00:58 <Axman6> new2this3223: that depends on what a and particularly what b are - what do you weant the result to be?
21:01:12 <Axman6> want*
21:01:26 <new2this3223> I have (test1 a = 1) and (test2 b = 2) and I want a function where I can give it either a or b and get the appropriate result
21:01:46 <iqubic> Well, what are the types of a and b?
21:01:57 <Cale> > let pair f g x = (f x, g x) in pair (map toUpper) reverse "hello"
21:01:59 <lambdabot>  ("HELLO","olleh")
21:02:04 <new2this3223> strings
21:02:33 <Cale> new2this3223: How is your new function supposed to decide whether to use test1 or test2?
21:02:45 <iqubic> So, if you get a as the input you want to return 1, and if you b as the input you want to return 2 as the output?
21:03:03 <new2this3223> iqubic that's right
21:03:22 <new2this3223> Cale: I can see why that would be an issue but in my case there would never be a conflict
21:03:39 <new2this3223> the value can only come from one of the two
21:03:59 <Cale> new2this3223: Well, test1 and test2 are actually functions of all strings, right? So you *could* give any string to either function
21:04:10 <Cale> (or to both)
21:04:33 <new2this3223> they're actually only defined for those specific a and b values
21:04:43 <Axman6> that doesn't sound good
21:05:25 <iqubic> Yeah. I don't think it's good to have a function that's only defined for a some inputs.
21:05:29 <iqubic> > head []
21:05:32 <lambdabot>  *Exception: Prelude.head: empty list
21:05:43 <iqubic> Oh no... Run time error.
21:05:50 <Axman6> > fix error -- defined for all values to fix any error
21:05:52 <Cale> Well, sometimes such functions are okay
21:05:53 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
21:06:09 <iqubic> :t error
21:06:10 <lambdabot> [Char] -> a
21:06:55 <Cale> But in any case, you can't distinguish that some function isn't defined at any given point. If applying a function to some value doesn't terminate or crashes, then anything which applies it to that value is also going to not terminate or crash.
21:07:24 <Cale> It might be better to think of it as that the function *is* defined for all the other inputs, it's just defined not to terminate.
21:08:06 <Cale> It sounds like you might be better of working with Data.Map or some such
21:08:10 <Cale> off*
21:08:29 <new2this3223> i think i see how to work around this, thanks everyone
21:08:42 <Cale> Data.Map is a data structure for working with sets of (key, value) pairs, and supports operations like union
21:08:51 <Cale> and lookup
21:09:22 <new2this3223> that might be perfect here, thanks
21:09:36 <Cale> > M.singleton "hello" 1 <> M.singleton "world" 2
21:09:39 <lambdabot>  fromList [("hello",1),("world",2)]
21:09:49 <Cale> > M.lookup "world" (M.singleton "hello" 1 <> M.singleton "world" 2)
21:09:51 <lambdabot>  Just 2
21:09:56 <Cale> > M.lookup "ummmm" (M.singleton "hello" 1 <> M.singleton "world" 2)
21:09:58 <lambdabot>  Nothing
22:36:44 <sshine> I got a question that I don't know the answer to: why is `liftM f m1 = do { x1 <- m1; return (f x1) }` and not `liftM = fmap` in base?
22:37:43 <sshine> is it just because of the definitional similarity you get between liftM, liftM2, etc.?
22:38:24 <sshine> in that case, why isn't `liftM2 = liftA2`?
22:38:47 <monochrom> They were historical definition that tried to be independent of Functor and Applicative.
22:39:37 <monochrom> On the upside if you have implement Monad then for Functor and Applicative you just go "fmap=liftM", "liftA2=liftM2" and you are assured there is no circularity!
22:39:58 <monochrom> s/have implement/have implemented/  # bloody English, also I'm drunk
22:40:11 <sshine> I guess that's a pretty good feature. :)
22:40:58 <monochrom> Also ap is in the same shoe when you compare with <*>
22:41:47 <monochrom> The initial invention/discovery of Applicative was "hey ap gets surprisingly many things done, don't need >>=..."
22:44:24 <monochrom> Similarly there is an "fmapDefault" in Data.Traversable that uses sequenceA or traverse (I forgot which) so for Functor you can just go fmap=fmapDefault.
22:47:13 <sshine> ah yes, I saw that before.
22:50:26 <iqubic> A drunkard on IRC sounds interesting.
22:51:08 <iqubic> :t ap
22:51:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
22:51:23 <iqubic> Oh. It's literally the same as <*>
22:51:42 <sshine> "ap" is incidentally the only sound my niece makes these days.
22:52:25 <Axman6> you should teach her to say <*> then
23:10:09 <sshine> Axman6, I was thinking just the same!
