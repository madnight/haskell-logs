01:14:10 <Athas> carter: hey, thanks for raising these issues with the linear types proposal.
01:15:08 <Athas> I've always had a really bad gut feeling about that proposal, but as a GHC outsider, I never felt I had very good concrete arguments, or the social inertia, to do more than grumble concernedly.
01:22:21 <zincy_> With postgres-simple how do you conditionally add a FILTER WHERE clause in a query based on a Maybe in one of the params to the query?
02:31:12 <alc`> why Data.ByteString.Char8.words can't handle Mandarin?
02:31:36 <alc`> > import qualified Data.ByteString.Char8 as E
02:31:39 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
02:32:01 <alc`> > Data.ByteString.Char8.words "abc efg"
02:32:03 <lambdabot>  error:
02:32:03 <lambdabot>      • Couldn't match expected type ‘BSC.ByteString’
02:32:03 <lambdabot>                    with actual type ‘[Char]’
02:35:23 <alc`> which encoding OverloadedString use to turn ByteString to String?
02:35:26 <alc`> ascii?
02:35:32 <alc`> not UTF-8?
03:11:38 <[exa]> alc`: ...but OverloadedStrings does not convert BS to Strings?
03:12:30 <[exa]> alc`: (the other question is the encoding used in the actual source code)
03:15:59 <Arahael>  [exa] My understanding is that OverloadedStrings doesn't itself do conversions.
03:16:25 <Arahael> [exa]: It merely provides an alternative impelmentation of string literals that allows them to be effectively polymorphic, using the typeclass.
03:17:05 <alc``> [exa]: UTF-8
03:17:35 <alc``> Data.ByteString.Char8.words "abc"
03:17:53 <alc``> what this "abc"'s encoding? if enable OverloadedStrings?
03:18:10 <alc``> "abc" won't turn be ByteString?
03:18:16 <Arahael> alc``: Haskell strings are unicode, i think they are effectively UTF-32.
03:18:52 <Arahael> alc``: ByteString is not really an encoding, it's more of a packed list of bytes.
03:19:18 <alc``> Arahael: String after encoding become ByteString, not right?
03:19:58 <alc``> Data.ByteString.Char8.words "abc", with enable OverloadedStrings, this "abc" is not ByteString?
03:20:07 <alc``> "abc" is a String, right?
03:21:28 <Arahael> alc``: With overloaded strings? No, it's an IsString type.
03:21:59 <Arahael> > :t "foo"
03:22:01 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:22:11 <alc``> :t "abc"
03:22:12 <lambdabot> [Char]
03:22:25 <Arahael> Ok, lambdabot doesn't have -XOverloadedStrings set.
03:22:58 <[exa]> alc``: AFAIK it becomses something like `fromString "abc"` where "abc" :: [Char]
03:23:06 <Arahael> Try it yourself in ghci after doing `:set -XOverloadedStrings`
03:23:18 <alc``> Arahael: already did it
03:24:13 <alc``> Arahael: after enable OverloadedStrings, Data.ByteString.Char8.words "abc" works fine, but not fine when the String is Mandarin, so I asked here
03:24:22 <alc``> you can try it too
03:24:51 <alc``> E.words "abc d" == ["abc","d"]
03:25:01 <alc``> E.words "你好" == ["`}"]
03:25:14 <Arahael> alc``: I wouldn't expect it to work, anyway. What were you expecting?
03:25:45 <alc``> Arahael: it should have the same behavior when it handles Mandarin
03:26:02 <Arahael> alc``: Take the first 8 bits of the character, and split by whitespace?
03:26:07 <alc``> just return ["你好"]
03:26:16 <Arahael> alc``: How do you represent those in 8-bit characters?
03:26:18 <alc``> Arahael: right
03:26:33 <Arahael> alc``: Note: char8 is not utf-8. It's just... char8.
03:26:47 <alc``> wait
03:27:00 <alc``> you mean I get it totally wrong?
03:27:36 <Arahael> alc``: See https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Char8.html
03:27:47 <Arahael> alc``: It truncates chars to 8 bits.
03:28:36 <alc``> Arahael: why there's no words in Data.ByteString...
03:29:00 <alc``> there's map in Data.ByteString, I assume it can implement words based on that map
03:29:51 <alc``> there's even an example for splitOn within Data.ByteString, but it's called tokenise and not a official function, why?
03:30:39 <alc``> haskell does't expect us to handle ByteString directly?
03:30:49 <Arahael> alc``: Remember, ByteString is not an encoding.  How do you determine what a "word" is if you don't have an encoding?
03:30:50 <[exa]> alc``: the problem is that if you don't specify the encoding, there will be none. Check out implementations of pack or fromString (all going to packChars)
03:31:05 <[exa]> alc``: see https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/src/Data.ByteString.Internal.html#packChars
03:31:58 <[exa]> alc``: but you may want to import package utf8-string which seems to do what you expect
03:31:59 <Arahael> alc``: Incidentially, regarding utf-8, you probably want to use https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
03:32:37 <Arahael> alc``: I also always recommend people read this to understand encodings in the broader sense: https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/
03:33:19 <[exa]> alc``: I guess this is what you want:  Data.ByteString.Lazy.UTF8> words $ "你 好"
03:33:22 <[exa]> ["\20320","\22909"]
03:33:42 <Arahael> alc``: (The joelonsoftware article is not haskell, but the concepts still apply.)
03:34:03 <Arahael> [exa]: You inserted a space in there.
03:34:12 <[exa]> yes, just to make it interesting
03:34:26 <alc``> [exa]: Arahael ok, I will try it
03:35:22 <[exa]> oh yes, with a bit more care (the previous example was in fact string, sorry):
03:35:22 <alc``> [exa]: bytestring package is not coming with ghci?
03:35:37 <[exa]> Data.ByteString.Lazy.UTF8.fromString "你 好" --> "\228\189\160 \229\165\189"
03:35:57 <[exa]> alc``: no, why?
03:36:26 <alc``> [exa]: Data.ByteString.Lazy.UTF8 can work on ByteString?
03:36:33 <alc``> UTF8.words
03:37:32 <fendor> How can I install all executables of a project with cabal? 
03:38:01 <[exa]> alc``: afaik yes, it should even work with XOverloadedStrings as you want
03:39:11 <alc``> [exa]: what this bytestring package's name in debian?
03:39:17 <alc``> libghc-bytestring-dev isn't
03:39:29 <[exa]> alc``: no idea, I'm installing them with cabal
03:39:48 <[exa]> libghc-utf8-string-dev/testing,unstable 1.0.1.1-8+b3 amd64
03:39:55 <[exa]> this seems vital
03:42:25 <alc``> [exa]: yeah, it is
03:45:53 * hackage junit-xml 0.1.0.0 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/junit-xml-0.1.0.0 (JasperWoudenberg)
04:03:23 <alc``> [exa]: how can I get the Word8 integer for whitespace?
04:03:47 <alc``> I'd like to write a bytestringWords, that only work on utf-8 encoding bytestring
04:03:47 <[exa]> > 32
04:03:50 <lambdabot>  32
04:03:56 <[exa]> here it is :]
04:04:05 <alc``> I need that Word8 number for whitespace
04:04:10 <alc``> ok
04:04:21 <[exa]> :t isSpace.b2c --this should work too
04:04:24 <lambdabot> error:
04:04:24 <lambdabot>     • Variable not in scope: b2c :: a -> Char
04:04:24 <lambdabot>     • Perhaps you meant ‘bcc’ (imported from Data.Graph)
04:04:40 <[exa]> b2c is in some deep bytesting library
04:05:00 <Arahael> alc``: question: what is a "word" in mandarin?
04:05:58 <[exa]> Arahael: I didn't want to poke that far originally :]
04:06:02 <alc``> Arahael: actually a "word" is like "这是一句话"
04:06:25 <alc``> Arahael: 你明白了吗?
04:06:53 <alc``> 这 is a character I assume
04:09:06 <Arahael> alc``: not really.
04:09:28 <Arahael> alc``: i mean, kind of.  but not really.
04:10:44 <alc``> Arahael: there's no white space usage in Mandarin, unless there're other langeuages in it
04:11:33 <alc``> you can't say "这是 一句话"
04:13:14 <Arahael> alc``: my point is to be wary of using "words".
04:14:20 <alc``> Arahael: in my case, just split string like "Arahael: 你好", I want pick up that 你好 from this string
04:15:03 <Arahael> ah, then yeah, just use splitOn isSpace
04:16:58 <roigpd> I'd like to debug Haskell code with a debugger (breakpoints etc). I found out about haskell-mode which has a haskell-debug command. However, this doesn't seem to work for me. Is this known to be broken? Or could there be some version mismatch?
04:17:23 <roigpd> (I meant the haskell-mode package for emacs)
04:19:19 <roigpd> I get errors like "Unable to parse module from string: [/tmp/X.hs:3:3-15]"
04:30:11 <__monty__> roigpd: Ghci has tracing built-in afaik. Are you sure you want a debugger though? Stepping through the implementation details of lazy evaluation is *not* like what you're used to with debuggers for java or similar languages.
04:57:53 <fendor> In a test component, can I access the "other-modules" from a library I depend on?
04:58:09 <mysnns> Hi, I'm trying to self-learn functors and applicatives by implementing a BST, however I'm getting an error implementing the last match for the <*> operator: https://gist.github.com/Mysterise/318a1a390121b654476c61459ffcb5b7
04:58:35 <mysnns> First line of the error msg: Occurs check: cannot construct the infinite type: b ~ Tree b
05:01:39 <roigpd> __monty__: Yes, I am aware that the haskell debugger is a bit different from other debuggers. So indeed all I'm asking for is a nice interface to the ghci debugging features.
05:05:25 <merijn> mysnns: On line 15, 't :: Tree a'
05:05:47 <merijn> mysnns: "Node :: Tree a -> a -> Tree a -> Tree a"
05:06:02 <merijn> mysnns: But you're passing "f <$> t" as second argument to node
05:06:39 <merijn> mysnns: And "f <$> t :: Tree b" so it's inferring you're trying to build "Tree (Tree b)", but then your left and right hand trees are wrong
05:06:51 <merijn> fendor: no
05:06:58 <fendor> damn it
05:07:02 <fendor> merijn, thx
05:07:20 <merijn> fendor: You can, however, in recent Cabal versions define internal libraries
05:07:33 <fendor> merijn, internal libraries seem to be rather buggy
05:07:47 <merijn> fendor: So you could define an internal library, exporting all modules. Have your tests depend on that, then hav e apublic library reexporting everything
05:07:53 <fendor> this pr is trying to turn an internal library into a common stanza but I am running into the reason for private libraries :)
05:08:00 <merijn> fendor: internal libraries are fine, it's multiple public libraries which is broken :)
05:08:40 <fendor> merijn, when is it a private internal library?
05:09:18 <merijn> fendor: That should be the default, but I haven't used it much, so take anything I say with a grain of salt ;)
05:09:46 <mysnns> @meri
05:09:46 <lambdabot> Maybe you meant: vera more
05:10:02 <fendor> merijn, ok, yeah, because that seems broken: https://github.com/haskell/cabal/issues/6483
05:10:04 <mysnns> merijn I see, thanks for that catch. I'm not sure how to proceed here
05:11:37 <merijn> mysnns: Hard question, I'd have to think what the Applicative for trees even means >.>
05:14:00 <reactormonk> Do proposals for the stdlib go to ghc-proposals as well?
05:20:41 <merijn> reactormonk: libraries@ mailing list, usually
05:22:26 <mysnns> merijn Yeah it is a little hard to think about. I've changed that line to `(Node l f r) <*> (Node l' a r') = Node (l <*> (Node l' a r')) (f <$> a) (r <*> (Node l' a r'))`
05:22:44 <mysnns> which I think should be fixing that error before but now it's giving me `cannot construct the infinite type: a ~ f0 a` :/
05:26:10 <merijn> mysnns: THe "infinite type" thing means "you're trying to define a type as something using itself" i.e. you original version inferred to 'a' = 'Tree a' (which is infinite, because that'd mean 'a' = 'Tree (Tree a)' etc. until infinity
05:27:27 <mysnns> merijn ah you just made me realise I shouldn't be fmap-ing there, changing the middle bit to `(f a)` fixes it
05:27:28 <mysnns> thank you!
05:27:29 <[exa]> mysnns: why not just (l <*> l')  ?
05:28:09 <mysnns> [exa] I want the entire tree to be passed down, not just the left branch
05:28:32 <mysnns> a little like when you do product on two lists of length 3 and get a size 9 list back
05:28:51 <[exa]> trying to think about how that would work
05:29:07 <[exa]> the usual tree instances are more like zipWith
05:30:16 <[exa]> also I'm not sure if you're not completely ignoring the contents of l' and r' in this case
05:31:20 <mysnns> The only reason for having the l' and r' in this case is so I can rebuild that entire `Node` again
05:33:10 <mysnns> I'm not sure how else you can access the `a` value within `Node` while still referring to that entire `Node` data, if that makes any sense
05:33:40 <[exa]> like it probably makes sense, but intuition kindof tells me that `Node Nil f Nil <*> Node undefined a undefined` should hit the undefined :]
05:33:41 <mysnns> for example, currently I have `(Node l f r) <*> (Node l' a r') = Node (l <*> (Node l' a r')) (f a) (r <*> (Node l' a r'))`
05:34:20 <mysnns> but ideally I want `(Node l f r) <*> (Node _ a _ as t) = Node (l <*> t) (f <$> a) (r <*> t)`
05:34:38 <mysnns> `(Node l f r) <*> (Node _ a _ as t) = Node (l <*> t) (f a) (r <*> t)` *
05:35:21 <mysnns> By that, do you mean the result should be `Node Nil (f a) Nil` ?
05:35:54 <[exa]> mysnns: that sounds quite a bit like `fmap ($a)`, just the other way around
05:37:14 <[exa]> I mean, the stuff doable with your applicative instance can be perfectly done using Functor + a single pattern match
05:38:06 <mysnns> i'm still very new to Haskell so I'm not exactly sure how, could you show an example?
05:38:23 * hackage hanabi-dealer 0.6.0.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.6.0.0 (SusumuKatayama)
05:39:24 <[exa]> mysnns: what happens if you do `Node Nil (+1) Nil <*> (a binary tree with numbers [1..100] with 50 in root)`
05:39:51 <[exa]> and how is that different from `fmap ($ 50) (Node Nil (+1) Nil)`
05:40:32 <[exa]> mysnns: I need to go AFK for ~hour, will be back
05:41:53 * hackage haskoin-core 0.10.1 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.10.1 (jprupp)
05:50:08 <mysnns> [exa] I'm not familiar with `fmap ($ 50)`, particularly the dollar operator there (i'm only aware of it being used for function application)
05:50:41 <mysnns> but with your example I suppose there wouldn't be much difference, because you have Nil for both branches of the tree so the behaviour is nothing special
05:51:58 <Rembane> :t ($)
05:52:00 <lambdabot> (a -> b) -> a -> b
05:52:02 <Rembane> :t ($ 50)
05:52:03 <lambdabot> Num a => (a -> b) -> b
05:52:26 <Rembane> That wasn't the most pedagogical type signature I've seen, but maybe it gives some intution?
05:52:57 <Rembane> > ($ 50) odd
05:52:59 <lambdabot>  False
05:54:11 <mysnns> ideally the behaviour I was going for was to essentially traverse the entire tree of functions to apply all of its functions to all of the values of the given tree, although that structure probably doesn't make any sense
05:55:26 <Rembane> Do you have two trees? One with functions and one with values? 
05:55:39 <mysnns> That's correct
05:56:31 <tomjaguarpaw> Does PolyKinds or DataKinds somehow infect every module?  Someone said something about this the other day ...
05:59:05 <mysnns> Rembane as for the semantics of `($ 50)` would it be right to think of it as a partially applied function application, that has the `a` from the `(a -> b) -> a -> b` applied?
06:00:45 <Rembane> mysnns: Exactly! 
06:02:13 <mysnns> Hmm I thought you needed to 'curry' the function from left to right, so in this case I thought you would only be able to partially apply `(a -> b)` before applying `a`
06:05:19 <Rembane> mysnns: Generally you do, but you can use sections to apply the right argument instead: http://wiki.haskell.org/Section_of_an_infix_operator
06:10:54 * hackage haskoin-node 0.9.16 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.16 (jprupp)
06:12:22 <mysnns> Rembane Learned something new, thanks for the link! I assume this is only relevant for infix operators that have position sensitive arguments? For example, you wouldn't care about this to section (+1) vs (1+) as either way that's incrementing
06:13:01 <mysnns> But for `$` there's a big difference in `($ 50)` vs `(50 $)`
06:13:35 <hpc> yep
06:14:15 <hpc> ($ 50) is the gateway drug to continuations btw
06:14:27 <hpc> something to look forward to
06:16:07 <Rembane> mysnns: No worries. You can get more fun by infixing functions. 
06:16:19 <Rembane> > (`elem` 7) [1,7,4,5]
06:16:21 <lambdabot>  error:
06:16:21 <lambdabot>      • No instance for (Num [[Integer]]) arising from the literal ‘7’
06:16:21 <lambdabot>      • In the second argument of ‘elem’, namely ‘7’
06:16:28 <Rembane> :(
06:21:40 <tomjaguarpaw> Is there some way of asking GHC to reduce type synonyms/type families when showing inferred types?
06:23:54 * hackage ghci-dap 0.0.14.0 - ghci-dap is a GHCi having DAP interface.  https://hackage.haskell.org/package/ghci-dap-0.0.14.0 (phoityne_hs)
06:25:24 * hackage haskell-debug-adapter 0.0.33.0 - Haskell Debug Adapter.  https://hackage.haskell.org/package/haskell-debug-adapter-0.0.33.0 (phoityne_hs)
06:42:21 <merijn> Is there a convenient ByteString to base64 string function somewhere?
06:42:32 <erisco> As I have maintained, variables are the worst. Who has taken combinators seriously for compilers?
06:46:05 <tomjaguarpaw> erisco: Interesting ... I've just written a type-level SKI implementation
06:46:52 <d34df00d> So you've proven that Haskell's type system is Turing-complete then!
06:47:13 <merijn> d34df00d: With the right extensions it is
06:47:22 <merijn> UndecidableInstances, for example
06:48:21 <tomjaguarpaw> d34df00d: Actually it's a typed SKI implementation
06:48:31 <tomjaguarpaw> so I believe it should not be Turing complete
06:48:45 <d34df00d> Hm then yes.
06:48:52 <tomjaguarpaw> I don't think I can express Y, for example
06:48:56 <d34df00d> Hold on.
06:48:56 <tomjaguarpaw> Well, let's try ...
06:49:09 <d34df00d> On the other hand, why not. "Typed" doesn't imply "non-turing complete".
06:49:26 <tomjaguarpaw> Well I suspect it's equivalent to typed lambda calculus
06:49:29 <d34df00d> If it were total typed one in a language with provable termination, then sure.
06:49:38 <d34df00d> You mean STLC?
06:50:08 <tomjaguarpaw> Polymorphic lambda calculus actually
06:50:12 <tomjaguarpaw> since it is polykinded
06:50:27 <tomjaguarpaw> Simply-typed SKI combinators wouldn't be very useful ...
06:52:00 <erisco> Is this the year I pay for an ACM subscription
06:52:17 <merijn> erisco: for what?
06:52:24 <erisco> access to papers
06:52:34 <merijn> Please don't >.>
06:52:51 <merijn> Especially not after they signed a pledge against open access
06:57:14 <p0lyph3m> paywall , what a nice bussiness model ....
06:57:42 <d34df00d> sci-hub lol
06:57:50 <erisco> you pay for things, that is how a business operates
06:58:50 <Chousuke> there are degrees to that. Sometimes you pay for things you shouldn't need to pay for because you have no other option :P
06:58:50 <merijn> erisco: Except for the part where ACM doesn't pay for any part of the paper except digital hosting
06:59:44 <Chousuke> not all businesses exist to extort money out of people. Some actually provide value in proportion :)
07:00:17 <erisco> merijn, something that could be said for any distributor of digital goods
07:00:58 <merijn> erisco: Not really, all other distributors of digital good pay the author/creator
07:01:19 <merijn> Steam, Spotify, Netflix, etc. they all pay the creators of the content on there
07:01:58 <merijn> Not only do the ACM and other publishers not pay for that content, it's also almost exclusively funded by tax payer money
07:04:29 <p0lyph3m> in germany situation is absurd ... education and universities are paid for by the public ... the fee for the results (research papers) then are collected by paywall hosting services .... 
07:18:32 <erisco> so they're a dinosaur trying to survive the meteor that is the Internet
07:22:33 <geekosaur> more or less. some are better at it than others :)
08:14:53 * hackage mmsyn7ukr 0.13.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.13.0.0 (OleksandrZhabenko)
08:37:24 * hackage mmsyn7ukr 0.13.0.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.13.0.1 (OleksandrZhabenko)
08:49:23 * hackage bson 0.4.0.0 - BSON documents are JSON-like objects with a standard binaryencoding.  https://hackage.haskell.org/package/bson-0.4.0.0 (VictorDenisov)
08:58:36 <thblt> With Turtle, how do I run a subprocess and capture its stdout as a String (or something close enough)?
09:01:17 <um1b0zu> So at this point, is it worth just learning WAI as a webserver language?
09:01:44 <davean> um1b0zu: its an API?
09:01:59 <um1b0zu> I'm not sure. API is a very loaded term
09:02:07 <um1b0zu> Like... WARP?
09:02:26 <thblt> Err, I've found a way that was basically: you don't need turtle. Sorry for the noise.
09:02:38 <um1b0zu> I'm trying to find a good server language to learn, but it looks like it's between Yesod and Snap, but there's also just WAI.
09:02:46 <davean> um1b0zu: how is it a loaded term? Its exacly an API and its not really a language
09:03:43 <um1b0zu> I guess I'm asking wrong. What's a good standard webserver language for Haskell?
09:03:52 <monochrom> Haskell.
09:03:59 <um1b0zu> I tried this out a few years ago but it looks like Spock isn't maintained anymore?
09:04:04 <davean> Maybe he wants a framework?
09:04:11 <um1b0zu> ah "Framework"
09:04:16 <davean> I'm really confused by his "language" thing
09:04:38 <monochrom> Looks to me the solution to avoiding a loaded term is to make another term loaded.
09:04:40 <davean> um1b0zu: Personally I like WAI with libraries, Servant is popular and very good for what it is.
09:05:13 <monochrom> And while we are at it I witnessed students a few days ago discussing the line between API and framework.
09:05:40 <davean> monochrom: At least thats discussable, though the idea of "line" seems missaplied there
09:05:55 <monochrom> Oh, "line" is my wording.
09:05:58 <davean> but API is ... API. I'm really confused what the confusion is there thats actually got a real definition
09:06:22 <davean> and that definition is clearly exactly what WAI is
09:07:32 <davean> frameworks are more a social construct, but we know they have an API, an actual implimentation, and we suspect they're extensive in supporting things in the area they're designed to enable?
09:08:56 <merijn> davean: See, the problem is that your thinking sensibly and logically
09:09:08 <merijn> davean: API hasn't meant API in ages!
09:09:23 <merijn> davean: Now it means a "web URL where you dump and get random schemaless JSON"
09:09:36 <davean> merijn: ... ok
09:09:48 <davean> That would be a pretty insane thing to change its definition to
09:10:20 <merijn> davean: You'd think so, but that's only because you're once again comitting the fallacy of thinking logically!
09:10:44 <davean> merijn: have you seen http://hackage.haskell.org/package/aeson-filthy ? ;)
09:11:13 <davean> Those "schemaless JSONs" can be pretty nasty
09:11:17 <merijn> davean: Now I'm sad :(
09:11:53 <davean> merijn: I really felt a need to share the emotions you were giving me back at you
09:15:25 <polyphem> thblt: inshell/inproc functions of turtle ?!
09:15:39 <davean> merijn: Its actually a pretty good library for the horror it deals with
09:20:09 <tdammers> if only that JSON were actually schemaless
09:20:20 <tdammers> instead, the schema is implicit
09:21:01 <tdammers> but, yeah, in the web dev world, "API" pretty much means that
09:21:13 <tdammers> except that it doesn't have to be a single URL, and usually isn't
09:21:40 <tdammers> an API is essentially a website, or part of a website, that serves mostly JSON instead of mostly HTML
09:22:45 <davean> While I don't debate those can be APIs, I dislike this brave new world where we've conflated with what can be an API with what an API must be.
09:23:14 <tdammers> same
09:23:30 <tdammers> I long for the days when words meant what they meant
09:41:53 <nshepperd> a framework is like an API but more orwellian
09:49:39 <fendor> where does stack install its local dependencies? E.g. when I have an executable depending on a library, where is the library installed, such that a flag `-package package-0.1.0` can be found?
09:49:45 <fendor> can I use ghc-pkg for that?
09:50:20 <fendor> scratch my last sentence, that was just floating around in my bran
09:50:21 <davean> fendor: I don't know much about stack - but why do you think that should exist? In general it doesn't have to
09:50:21 <fendor> brain
09:50:41 <fendor> davean, after building the library should exist, imo?
09:51:01 <davean> It had to exist to build the executable, it doesn't have to keep existing after the build is done.
09:51:15 <davean> the executable lives independently of it
09:51:22 <davean> (module so options and exceptions)
09:52:33 <fendor> I doubt stack is going to just delete it after trying to build it?
09:52:37 <davean> fendor: perhaps it would be clearer to say that build time and run time dependencies are disjoin 
09:53:41 <fendor> yeah, but I want to know why it might fail to find the local library specified by `-package package-0.1.0`
09:54:13 <geekosaur> to answer your question, it's under .stack-work somewhere and you should use stack to expose it (stack ghc ... with an appropriate stack.yaml specifying the package should be exposed)
09:54:30 <fresheyeball> https://hackage.haskell.org/package/text-metrics-0.3.0/docs/Data-Text-Metrics.html
09:54:32 <geekosaur> there being no guarantee it's exposed in a useful way under .stack-work
09:54:55 <geekosaur> stack does its own package management and you do things its way or you don't do them
09:54:56 <fresheyeball> I am using the levenshtein function and getting a runtime exception in GHCjs
09:55:04 <fresheyeball> I can't get the same exception to work in ghci
09:55:25 <fresheyeball> is there a better library for measuring text distance?
09:55:32 <fendor> geekosaur, thanks! but stack doesnt expose it atm in an easy to read fashion, right?
09:55:40 <geekosaur> correct
09:55:55 <geekosaur> which is why I told you how to do it the stack way, and said nyou have to do it the stack way
09:56:01 <fendor> but there was some work to change that, iirc...
09:56:07 <d34df00d> fresheyeball: on a somewhat related note, do you care about proper Unicode handling in your case? That is, do you need to properly consider edit distance between, say, two different three-byte symbols as 1 and not 3?
09:56:32 <fresheyeball> d34df00d: it's a type ahead search, so I don't think so
09:56:42 <fresheyeball> but if it's cheap enough, obviously its better to be more general
09:56:44 <d34df00d> If you don't (and the answer of "3" would be fine for you), I'd shamelessly advertise my https://hackage.haskell.org/package/edit-distance-linear
09:56:47 <davean> fresheyeball: it seems pretty important in that case
09:56:58 <d34df00d> (note the readme for caveats)
09:57:12 <davean> fresheyeball: that would make a 3-octet Unicode char less likely than a 1-octet one for no other difference
09:57:18 <fresheyeball> d34df00d: oh damn, this is you!
09:57:23 <fresheyeball> I asked at the right time!
09:57:36 <fendor> geekosaur, ah, so `stack exec -- ghc-pkg list`
09:57:48 <d34df00d> If you don't care about space that much (and for your task you probably don't), I'd recommend the edit-distance package.
09:57:50 <geekosaur> only if it's so exposed with a stack.yaml
09:58:00 <geekosaur> otherwise it's not in a package database
09:58:03 <d34df00d> (at least, as an alternative)
09:58:19 <geekosaur> stack deliberately hides its packages to avoid collisions
09:58:28 <geekosaur> and not in the "ghc-pkg hide" way
09:58:48 <fresheyeball> d34df00d: so one lame thing here, is that you are using Bytestrings
09:58:58 <fresheyeball> Which means slow.... on GHCjs
09:59:18 <d34df00d> Oh, didn't know that... That's funny, the intent is to avoid the overhead of unicode handling with Text.
09:59:35 <d34df00d> I know nothing about ghcjs really, sadly.
09:59:37 <fendor> geekosaur, it is not hidden, or it should not be... I am not even sure what I am looking for :)
09:59:46 <fresheyeball> d34df00d: well with `Text` we can get GHCjs to store it at runtime as a plain old JavaScript string
09:59:53 <geekosaur> fendor, you are ignoring most of what I said
10:00:11 <fendor> geekosaur, sorry, not intended.
10:00:13 <geekosaur> this is not cabal, it is not a standard ghc package database. it is stack, which does things its own way
10:00:34 <fendor> yes, I understand
10:00:36 <geekosaur> it does not do things in a way convenient for what you want
10:00:46 <fresheyeball> d34df00d: actually I don't see anything about your function and means it can't be Text
10:00:53 <fresheyeball> its just specialized
10:01:05 <geekosaur> it builds package ddatabases for ghc based on stack.yaml, and if you don't list the packages you want there then they are not in a package database
10:01:10 <d34df00d> Hmm.
10:01:19 <d34df00d> I could probably refactor that out.
10:01:30 <geekosaur> they are stashed away where they can't cause collisions with other builds of the same package
10:01:35 <fendor> yes, but this is not what I am looking for.
10:01:37 <davean> fresheyeball: could d34df00d just use {-# SPECIALIZE #-}?
10:01:51 <fresheyeball> davean: what does that do?
10:01:52 <d34df00d> fresheyeball: thanks for the idea, I'll see how it performs if I factor out the specific text type and allow both ByteString and Text.
10:02:03 <d34df00d> davean: nope, currently my function is explicitly monomorphic.
10:02:07 <davean> fresheyeball: compiles Type-Specific variants for the function for each listed signature
10:02:17 <fendor> I am looking why cabal-helper produces build-flags such as `-package package-0.1.0-wdjfhwejkfh` but cant find such packages
10:02:25 <d34df00d> fresheyeball: I even can do this later today if I"m not lazy lol.
10:02:31 <fresheyeball> d34df00d: nice
10:03:01 <fresheyeball> davean: so its a pragma that says, hey ghc, it would be faster if this was a family of specialized functions instead of this general one
10:03:04 <fresheyeball> ??
10:03:11 <davean> fresheyeball: yes
10:03:17 <geekosaur> the addendum is a build hash, and it should be present somewhere under .stack-work but this is not certain if you haven't done a build involving it since the last time you cleaned .stack-work
10:03:20 <fresheyeball> davean: cool, so yes potentially
10:03:21 <davean> It allows you to basicly template out code by type signature
10:03:23 <fendor> however, I dont understand stack at all and therefore I am just poking helplessly in the dark, hoping to find something by accident
10:03:26 <geekosaur> because packages are linked statically
10:03:39 <geekosaur> and the build hash isn't a stack thing, it's a ghc thing
10:03:43 <fresheyeball> d34df00d: could write this generally and use that pragma to respecialize 
10:04:19 <geekosaur> if you do things the stack way, stack will ensure the package is available. if not, you get no promises
10:04:41 <geekosaur> it may not even store them with conveniently decodable names
10:05:00 <d34df00d> davean: I've stumbled upon some cases where SPECIALIZE makes it slower though.
10:05:22 <geekosaur> ghc will look in the package db that stack builds specifically for the stack ghc ... command
10:05:24 <d34df00d> In particular, I'm working on some composable (at semi-type-level) folds now, and the performance there is totally unpredictable for me.
10:05:32 <d34df00d> But I think I completely bored this channel out with this stuff lately anyway.
10:05:39 <davean> d34df00d: I mean, it can if it shouldn't be specialized
10:05:50 <davean> d34df00d: SPECIALIZEation explodes code size by ... specializing
10:06:02 <davean> if you blow out your L1 and microop caches you'll suffer
10:06:40 <fendor> geekosaur, ok, I *thought* stack populates a custom package-db and passes this to ghc for local packages, e.g. for library components. Do I understand it correctly that this is not the case / there is happening more than that?
10:06:57 <geekosaur> there is more happening than that
10:07:18 <geekosaur> and there's no guarantee that the paackage db is sitting arond for you to use outside of stack
10:07:22 <davean> if you're doing semi-type-level stuff your code size explosion will be large - its the wrong place to use it
10:07:34 <davean> thats different than this example though
10:08:05 <fendor> well, but how does a tool such as cabal-helper do it, then? Just based on internal behaviour that just so happens to work from time to time?
10:09:00 <d34df00d> davean: what I'm having in mind is SPECIALIZEing https://github.com/0xd34df00d/hwc/blob/master/src/Data/WordCount.hs#L71
10:09:17 <fendor> I suppose, I should just leave it to people who understand this better...
10:09:37 <d34df00d> Since `wc` is called only once, it probably doesn't matter how many other wc's are there.
10:10:23 * hackage integer-roots 1.0 - Integer roots and perfect powers  https://hackage.haskell.org/package/integer-roots-1.0 (Bodigrim)
10:10:56 <davean> fendor: I think your clinging to your assumptions in the face of what people are telling you and you need to accept that something you assum eis true might not be and not just continue assuming what oyu tihnk is true is true
10:11:07 <davean> d34df00d: to be clear, 'wc' slows down when specialized, how?
10:11:36 <d34df00d> davean: {-# SPECIALIZE wc :: BS.ByteString -> Tagged 'Words #-}, for instance.
10:12:16 <davean> That does seem like it might
10:12:28 <davean> You've got Statistic a res st comp
10:12:31 <d34df00d> And wc @'Words is slower than wc @('Words '::: 'Bytes), which in turn is slower than wc @('Words '::: 'Bytes '::: 'Words), which is beyond my understanding.
10:13:16 <davean> d34df00d: You've got a very complicated dictionary structure here
10:13:24 <Athas> That is cool code, but I'm a bit amused at the README terming it "more or less idiomatic Haskell".
10:13:33 <Athas> (I'd come down on the "less" side!)
10:13:47 <fendor> davean, I mean, didnt I just do that? Accept that I dont understand what is happening?
10:14:25 <davean> fendor: you accepted that you weren't integrating knowlege, not that it was because your assumptions were wrong and you keep trying to proced on the grounds of them.
10:14:25 <d34df00d> davean: isn't that essentially a triple of a thunk (dunno how {-# LANGUAGE Strict #-} plays with `initState`) and two functions?
10:15:18 <davean> d34df00d: also, did you inline it or not?
10:15:20 <d34df00d> Athas: ah, that was about some previous version that I didn't try to modularize lol. You might like https://github.com/0xd34df00d/hwc/blob/04c7b6c5ffae80a2062a8de6a8196e6c07ae9bd9/src/Data/WordCount.hs more :)
10:15:32 <d34df00d> davean: I tried {-# INLINE wc #-}, it makes things worse.
10:15:48 <d34df00d> I tried looking at the core also, but nothing criminal there.
10:15:54 <d34df00d> But I'm def not a pro in reading core.
10:15:58 <Athas> d34df00d: apart from RecordWildCards being against my religion, yes, I do like that!
10:16:29 <d34df00d> Athas: oh crap, still wrong hash (it has a tiny bug), but you get the idea :)
10:16:32 <merijn> mmap'ed bytestrings <3
10:16:56 <Athas> So are you going to write another of those (\x->beating C with x) posts?  I thought that was a pretty fun time.
10:16:56 <davean> d34df00d: I'd have to double check a few things but I'm not convinced specializing on 'res' doesn't introduce new dictionary passing
10:17:18 <d34df00d> davean: uh, now I'm lost. How can specializing introduce more dictionaries passing as opposed to less dictionaries passing?
10:18:15 <davean> d34df00d: by increasing the number of abstracted types something works on
10:19:11 <davean> d34df00d: as long as fixing 'res' fixes everything else it shouldn't matter
10:19:14 <d34df00d> Hmm.
10:19:21 <svipal> yo. It's that time of the year again
10:19:33 <d34df00d> But in this case, the compiler knows all of the types, so it can even inline everything can't it?
10:19:37 <davean> I just don't fel like working throuhg your type inference on a bouncing train where its hard to stay on a line :-p
10:19:40 <svipal> How do I pass C compilation flags to ghc ?
10:20:15 <d34df00d> Why does it need to introduce anything abstract here? I expect SPECIALIZE to generate fully monomorphic functions without anything abstract.
10:20:16 <merijn> svipal: Which C compilation flags and why to GHC?
10:20:51 <svipal> Wno-deprecated, cause I get deprecated errors in my cbits that stop my compilation for some reason
10:21:17 <d34df00d> Athas: I already did (in fact it was in response to someone else's post where they didn't manage to achieve C-like performance).
10:21:17 <svipal> I meant from ghc to gcc.
10:21:48 <d34df00d> But I think what would be more interesting is this sort of modularization where the compiler would be able to peel all those abstractions off.
10:21:59 <merijn> svipal: You can specify C compiler options using cc-options in your cabal file
10:22:22 <d34df00d> Also, since different statistics (and their states) are isolated, it's definitely beneficial from local reasoning side and all that stuff we love.
10:22:42 <svipal> thanks merijn.
10:22:44 <d34df00d> So I sort of deeply care about understanding how the compiler sees my code and why the damn performance is behaving so funny.
10:25:42 <heatsink> d34df00d: One phenomenon that can happen is that by optimizing some parts of the code, you get more impedance mismatch between parts of the code
10:27:51 <heatsink> If the program goes back and forth between polymorphic and monomorphic code, it could be repeatedly boxing values and building class dictionaries
10:29:00 <davean> Yah, I'm trying to build it now so I can get the compiler to just do the looking for me
10:29:17 <davean> this does seem a risky thing to specialize
10:31:48 <d34df00d> heatsink: I thought about that, but it's unlikely in this case. That function is the single entry, and doesn't SPECIALIZE imply recursively specializing everything invoked from the specialized function?
10:32:13 <davean> Absolutely not, that would be insnae!
10:32:21 <heatsink> it only specializes that definition
10:32:40 <davean> That ... god, you might not have the disk space for that
10:32:44 <davean> the universe might not
10:33:06 <d34df00d> Crap.
10:33:08 <d34df00d> That explains a lot.
10:33:28 <davean> Now I understand why you thought it would reduce, not increase dictionary passing
10:33:33 <d34df00d> Hold on.
10:33:35 <d34df00d> > Moreover, given a SPECIALIZE pragma for a function f, GHC will automatically create specialisations for any type-class-overloaded functions called by f, if they are in the same module as the SPECIALIZE pragma, or if they are INLINABLE; and so on, transitively.
10:33:37 <lambdabot>  <hint>:1:9: error: parse error on input ‘,’
10:33:53 <davean> d34df00d: note the caviates there
10:33:59 <d34df00d> I definitely remember reading this, and here it is.
10:34:29 <d34df00d> davean: I don't see them on that page :(
10:34:35 <d34df00d> At least the ones that'd apply.
10:35:18 <davean> d34df00d: uh, are your benchmarks in the tests?
10:35:27 <d34df00d> davean: nope, they require a huge file.
10:35:31 <d34df00d> I'm not committing that.
10:35:35 <davean> where are they?
10:35:44 <d34df00d> http://eforexcel.com/wp/wp-content/uploads/2017/07/1500000%20Sales%20Records.zip I downloaded this file.
10:35:47 <d34df00d> unzipped
10:36:01 <d34df00d> And then did `for i in `seq 1 10`; cat unzipped >> test.txt`
10:36:06 <d34df00d> So you'd get 1.8 gig file.
10:36:08 <davean> Thats not so big, why not commit it? Or git-lfs it at least
10:36:26 <d34df00d> You might want to put that on tmpfs or smth to ensure there's no IO.
10:36:37 <d34df00d> Hmmm... haven't thought about git-lfs, I'll do that.
10:36:54 <d34df00d> davean: you do build with -fllvm right?
10:37:01 <davean> d34df00d: not usually
10:37:19 <d34df00d> I haven't really tested without it though.
10:37:22 <d34df00d> So dunno if that reproduces.
10:37:37 <davean> I can but there are long standing problems with -fllvm and often my code regresses performance wise with it
10:37:55 <davean> so you know, wanting to not have wrong calculations and faster code, I've started ignoring it
10:38:30 <davean> oh, you use bytestring-mmap? brave man
10:38:55 <d34df00d> Yes I am!
10:38:58 <merijn> davean: What's wrong with that?
10:39:07 <d34df00d> Rrrreferential transparency broken.
10:39:11 <d34df00d> But I only observe it once so I don't care.
10:39:16 <davean> merijn: Oh I just had to do a major engenering effort to get away from it due to it corrupting stuff
10:39:42 <merijn> d34df00d: No it doesn't, only if you modify the data does it violate that
10:39:49 <d34df00d> Yes, exactly.
10:40:13 <d34df00d> But, again, if I consume the string just once I can't tell if the data has been modified or not.
10:40:19 <d34df00d> So it's effectively referentially transparent.
10:40:23 <d34df00d> Is there a proper term for this?
10:40:29 <d34df00d> (at least that's my mental model)
10:40:42 <monochrom> observational equivalence :)
10:40:49 <davean> d34df00d: should your tests build?
10:40:57 <d34df00d> davean: nope.
10:41:03 <davean> d34df00d: that explains that
10:41:07 <d34df00d> They are old and I haven't settled with the internal API.
10:41:09 <monochrom> "I haven't observed an unobservable inequality"
10:41:09 <d34df00d> Sorry about that.
10:41:23 <d34df00d> monochrom: that's too many negations.
10:42:17 <polyphem> virtual liniarity :)
10:44:04 <davean> d34df00d: ugh, this could use a proper benchmark :(
10:49:30 <davean> d34df00d: so ... just putting SPECIALIZE on wc drops its time for me without -fllvm
10:50:27 <davean> d34df00d: and thats with your -fllvm setting
10:50:42 <davean> So I can't preproduce your initial claim
10:50:53 * hackage mmsyn7ukr 0.14.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.14.0.0 (OleksandrZhabenko)
10:51:03 <d34df00d> davean: uh, sorry, I'll put out a benchmark once I get home today.
10:51:33 <d34df00d> davean: just curious, what are your times with/without SPECIALIZE?
10:51:37 <davean> anyway the drop isn't big, about 70ms but its reliable.
10:51:48 <d34df00d> Interesting.
10:51:57 <davean> 1.45-1.47 without, 1.38-1.40 with
10:52:05 <davean> 20 runs each
10:52:26 <d34df00d> I can reproduce this on all of the machines I have (i7 3930k, i7 4770, i7 6700).
10:52:28 <davean> you want a more accurate messurement, get a benchmark, I'm not a stats envirment :-p
10:52:32 <d34df00d> That's interesting.
10:52:56 <d34df00d> davean: and you build with ghc 8.8.2, right?
10:53:37 <davean> yes
10:53:58 <d34df00d> Anyway, can you give it a shot with `('Words '::: 'Bytes '::: 'Words)`?
10:54:02 <d34df00d> Just out of curiosity.
10:54:13 <d34df00d> That's in app/Main.hs in the type application for wc.
10:56:01 <davean> I'd have to add the specializes
10:57:41 <davean> 1.46s
10:58:09 <davean> without the specialize
10:58:13 <davean> I should do my reading though
10:59:59 <mac10688> I have a list of items type YesNo = Yes | No | Other String; and I have type NestedData = [Maybe YesNo]. Is there a clean way to pull out possible string values from that NestedData type?
11:00:25 <mac10688> something like filter (Other . Just) or something like that
11:01:26 <geekosaur> [ s | Just (Other s) <- someNestedData ]
11:01:34 <mac10688> nice!
11:01:38 <mac10688> thanks :)
11:05:15 <d34df00d> That's really interesting.
11:05:22 <d34df00d> Something wonky going on my systems.
11:05:33 <d34df00d> I blame Gentoo that I'm running — that's the common factor!
11:09:53 * hackage accelerate-kullback-liebler 0.1.2.0 - Kullback-Liebler divergence  https://hackage.haskell.org/package/accelerate-kullback-liebler-0.1.2.0 (vmchale)
11:14:49 <Athas> Woah, that package is on hub.darcs.net.  Retro!
11:20:23 <[exa]> mac10688: `Maybe YesNo` is the new level of certainity I want from my programs :]
11:24:07 <mac10688> lol thanks [exa] . That's not actually the types I'm working with, I just wanted a simple example
11:25:58 <[exa]> :]
12:14:25 <sm> darcs ftw!
12:15:28 <merijn> sm: Have you looked at Pijul?
12:19:05 <sm> merijn: I listen for activity.. I tried it out a few years ago
12:19:29 <sm> there was a good discussion of it on HN recently
12:20:50 <sm> I'm no darcs booster, but this morning #ghc chat log was full of head-exploding branch management talk, and I couldn't help but miss darcs a little
12:21:15 <merijn> sm: Hopefully Pijul will succeed as better performing darcs :)
12:21:40 <sm> that's been the story for a long time now :)
12:22:45 <merijn> sm: Well, last year they said they finished their proof-of-concept implementation and are convinced about the algorithms. They started working on the first "real" version a few months ago
12:24:05 <sm> it's a long road to making a successful VCS, that's for sure
12:24:21 <merijn> The current git monoculture still makes me sad :\
12:24:21 <sm> darcs itself keeps having bursts of activity from two devs, sometimes I wonder if it could ever rise again
12:25:05 <merijn> sm: As long as we have a GitHub monopoly I only see Mercurial have any shot of making a come back. Everything else will first have to implement a convincing replacement for github
12:26:42 <sm> that's easier than building the VCS I think. There are a bunch of those, given a compelling VCS and programming ecosystem I think it would happen fairly quickly
12:26:57 <merijn> sm: You'd think that
12:27:00 <sm> or you'd get plugged in to source hut 
12:27:12 <[exa]> hm, are there any interesting features of darcs/hg that are better/more useful than those of git?
12:27:13 <merijn> sm: Yet bitbucket has been fucking it up for a decade now :p
12:27:57 <[exa]> I was trying both mercurial and hg several times (mostly because students used it) but never got the idea how it even works
12:28:05 <merijn> [exa]: darcs and pijul are fundamentally different approaches to VCS, so yes. Mercurial is pretty much identical to git, but with less sucky UI :p
12:28:07 <[exa]> s/hg/darcs/
12:28:07 <sm> yet there's also gitlab, source hut, darcs hub, probably a bunch of other hubs
12:28:32 <merijn> sm: I said an alternative that was *as good* as Github :)
12:29:02 <merijn> sm: The reason git one was because you needed it to use github and github was one of the hosting sites that sucked the least
12:29:10 <sm> yes, I'm saying given a compelling VCS and programming ecosystem that polish could happen quickly
12:29:38 <merijn> [exa]: darcs (and pijul) get rid of the entire notion of causal history
12:30:38 <merijn> [exa]: You have to shift your viewpoint to patches which can be independent (think non-overlapping diffs) or dependent (diffs that touch parts touched by previous diffs)
12:31:41 <[exa]> hm good
12:31:51 <merijn> [exa]: The order in which patches were authored is not relevant, only whether there's a dependency between patches. Patches with non dependencies and no conflicts ar (trivially) orthogonal
12:31:53 * hackage ansi-terminal 0.10.3 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.10.3 (mpilgrem)
12:32:37 <merijn> [exa]: So consider having 5 independent bug fix branches in git. Now you wanna develop a new feature on top of the fixed code while you wait for your PRs to get merged
12:32:49 <[exa]> so basically (viewed from git) darcs pathces form a DAG that is as wide as possible, which adds a bit of flexibility into picking parts of changesets
12:33:06 <merijn> [exa]: In git your only option is to locally merge all 5 those branches into master, write your code, then later rebase on the merged upstream master
12:33:42 <[exa]> yes, understood now
12:33:47 <sm> incidentally, does anyone know who manages the Haskell matrix bridge ? It's currently disabled, needs a restart or something
12:33:59 <merijn> [exa]: In a patch based approach there are no branches, so merging is a nonsensical concept (assuming the simple case of no conflicts) so you can write new patches "on top of" those 5 branches, without being actually on top
12:34:09 <[exa]> merijn: I guess there's a way to explicitly say "this is a snapshot" because well softwares have releases.. :]
12:34:32 <merijn> [exa]: Well, it's actually a graph and applying a set of patches means finding a path through that graph
12:34:48 <merijn> [exa]: darcs had (has?) some crippling complexity issues there
12:35:06 <merijn> [exa]: Snapshot are "patch sets" i.e. a defined set of selected patches
12:35:35 <merijn> [exa]: So named patch sets would replace branches
12:35:41 <[exa]> which may be huge technically as I see
12:36:23 <merijn> [exa]: But a funny thing is that a single patch can be in multiple patch sets simultaneously (I mean, why not?) so cherrypicking commits between patch sets is trivial (as opposed to git where you have to duplicate the commit in each branch)
12:36:29 <wildtrees> sm, I think on the matrix side for their #haskell they did a rename of their channel or something, and it broke the irc bridge to here 
12:36:39 <sm> yes
12:37:39 <sm> all the other haskell channels use a simpler kind of bridging, and they're fine. #haskell has an actual Haskell matrix room ("plumbed" bridging or something)
12:38:01 <[exa]> merijn: that's entirely because of the hashtree nonsense though
12:38:23 <[exa]> (the duplication)
12:38:29 <merijn> [exa]: Well, yes, but the DAG is pretty fundamental in most of the distributed VCSs (besides pijul and darcs)
12:38:32 <davean> [exa]: uh, not really - git keeps tree states not patches
12:39:06 <[exa]> davean: still it stores deltas right?
12:39:13 <davean> [exa]: not in a meaningful way
12:39:18 <davean> [exa]: only as a method of ocmpression
12:39:27 <davean> it in *no way* stores deltas as it relates to code state
12:39:41 <[exa]> hm that's true in fact
12:39:43 <davean> *only* as it applies to compression
12:40:28 <davean> Honestly the tree state thing is what I like about the model more, because I work with the resultant state *not* the patches, but it works much less well for certain things.
12:40:46 <[exa]> merijn: anyway thanks for explanation, I had those in one heap with mercurial, now it seems honestly more worth checking out
12:40:50 <davean> darcs does no match how I interact with code, git does, but it also makes git much weaker for things that aren't exactly code
12:41:23 <[exa]> well git is kindof release-oriented right. :]
12:41:36 <merijn> [exa]: If you Google about patch algebras there's quite some stuff on the basic theory of things
12:42:11 <[exa]> anyway anyway, slightly related to this discussion
12:42:28 <[exa]> is there finally some kind of patch for wdiff? :D
12:42:31 <merijn> [exa]: Pijul's main claim to fame is that they (claim to, anyway) have efficient algorithms (darcs has some O(n^2) stuff)
12:42:59 <[exa]> merijn: diff is O(n^2), what's the problem? :D
12:43:36 <davean> [exa]: size of n?
12:43:49 <davean> [exa]: diff is O(n^2) on an n I can hide under my bed
12:44:12 <[exa]> yes, "a few lines"
12:45:29 <davean> also diff's coefficient is tiny
12:46:39 <[exa]> pijul is not packaged for debian??
12:46:52 <davean> [exa]: can it be?
12:47:07 <[exa]> IDK, I'd go for it
12:47:45 <sm> it isn't ready for real world use
12:50:49 <merijn> It's reaching the point where it's ready for curiously testing/playing, though :p
12:51:44 <sm> ttps://news.ycombinator.com/item?id=22021309 is the recent discussion I mentioned, FWIW
12:51:50 <sm> https://news.ycombinator.com/item?id=22021309
12:54:42 <[exa]> oh it's in rust
12:55:57 <merijn> I'm also (naively) hoping for success of the "Mercurial oxidation plan"
12:56:18 <sm> merijn: oh, how far along is that ?
12:56:44 <merijn> sm: Speeding up, now that python3 support is finally dealt with, afaik
12:56:49 <heatsink> Are they rewriting mercurial in rust?
12:56:53 * hackage boolector 0.0.0.11 - Haskell bindings for the Boolector SMT solver  https://hackage.haskell.org/package/boolector-0.0.0.11 (DeianStefan)
12:56:54 * [exa] thinks people should learn modern c++
12:57:11 <heatsink> good luck trying to get people to agree on what modern c++ is
12:57:17 * sm thought haskell was modern c++
12:57:52 <[exa]> sm: bingo
12:57:56 <monochrom> haskell is C++ 2020 and Python 5 :)
12:58:01 <merijn> I know modern C++, it sucks :p
12:58:27 <merijn> I've been rapidly replacing it with Haskell in my phd codebase and my happiness is through the roof ;)
12:58:30 <[exa]> heatsink: anything after c++11 and after everyone agreed that Qt approach is totally wrong :D
12:59:12 <merijn> From 70% C++ to 51% haskell, 32% C++ now :p
12:59:27 <merijn> Admittedly, that's also due to adding *a lot* of Haskell :p
12:59:34 <[exa]> merijn: what's the project about? (just curious, feel free to ignore)
13:00:19 <merijn> [exa]: Ostensibly about writing fast GPU algorithms. Realistically (and what the Haskell code deals with) it's about "how the fuck do you do large scale benchmarking and meaningfull data analysis?!?"
13:02:43 <[exa]> hm cool
13:02:53 <monochrom> That's a lot of yak shaving.
13:03:05 <merijn> monochrom: Well, yes :p
13:03:12 <merijn> monochrom: Reproducible science and all that!
13:03:41 <[exa]> re data abalysis, is there anything better for plotting than Chart now?
13:03:46 <[exa]> *analysis
13:04:29 <merijn> [exa]: I don't think so. I'm still using my original matplotlib code (although stripped down since all the data is now preprocessed in Haskell)
13:05:02 <[exa]> (I'm sorry for categorizing plotting&analysis into 1 bucket but you know how it goes...)
13:05:28 <merijn> [exa]: I rarely plot tbh, since I've got too much data to really fit usefully into a graph
13:07:21 <[exa]> anyway if you're using mathplotlib certainly _do_ try ggplot someday
13:07:59 <[exa]> I know how terrible can a suggestion involving R sound, but it's worth it
13:12:26 * hackage hpath-posix 0.13.1 - Some low-level POSIX glue code, that is not in 'unix'  https://hackage.haskell.org/package/hpath-posix-0.13.1 (maerwald)
13:15:49 <merijn> Intriguing...
13:15:58 <merijn> My code prints "Floating point exception"
13:16:11 <merijn> Which is odd, because I'm not actually doing any floating point stuff...
13:19:07 <heatsink> I've seen that before
13:19:15 <merijn> Ooh!
13:19:25 <heatsink> I think it was a system library incompatibility
13:19:37 <merijn> Doubtful, the system hasn't changed in...years
13:20:22 <heatsink> idk then
13:30:53 * hackage mmsyn7ukr 0.14.0.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.14.0.1 (OleksandrZhabenko)
14:12:07 <whatisRT> I've heard and read multiple times that people are of the opinion that more and more language extensions will get added and at some point we might be in a situation where ghc extensions will basically become a huge mess. Is anyone aware of a citable source for that?
14:15:33 <lyxia> The opinion that it's already the case is also common.
14:16:40 <whatisRT> Yeah, but I didn't want to be the one saying it ^^
14:26:06 <muesli4> Hi, I'm switching an application from gtk3 to gi-gtk. How do I do postGUISync in gi-gtk (i.e. run the stuff in the GUI thread)?
14:43:33 <parsnip> is there a science to writing tests?
14:43:41 <parsnip> asking for a front end dev.
14:45:44 <sondr3> you mean the frontend dev does not write tests already?
14:47:17 <sondr3> but for realsies, outside of QuickCheck I find writing tests fairly straight forward in Haskell
14:47:35 <sondr3> even as a newbie, it might not be as easy to grok as Jest, but I was able to get up and running for Advent of Code very quickly
14:47:36 <sim590> Does haskell works fine for writing programs to be compiled on all platforms? As for Prelude and simple standard functions, I guess that it is totally fine, but what about things like creating a component communicating as backend with some frontend over a Rest/Json API?
14:48:32 <sim590> In short, I want to make backend for some small apps for managing some simple grocery list which would run on both Android and iOS.
14:49:10 <rom1504> it seems you are confused
14:49:24 <rom1504> the backend usually doesn't run on the platform of the frontend
14:49:46 <rom1504> do you want to do the frontend or the backend in haskell ?
14:49:56 <rom1504> (the second choice seems like a better idea)
14:51:45 <sim590> rom1504: No, I am not confused. The thing is that I would have two different apps (one for the client and the other for the cashier), but both client and cashier apps would share code, hence the backend/frontend model.
14:52:10 <rom1504> so you do want to use haskell for your frontend ?
14:52:29 <sim590> The frondend would be running react native communicating with some local backend using rest/json api.
14:52:48 <sim590> The local backend is shared between both apps.
14:53:05 <sim590> This part would be written potentially in haskell.
14:53:16 <rom1504> local backend : why ?
14:53:37 <sim590> rom1504: Because two apps share code, so it's simpler to have some unified component with which communicating.
14:53:53 <parsnip> the cashier and customer are using clients
14:53:58 <sim590> parsnip: Yes
14:54:13 <sim590> The cahier has his app running and is serving the physical client in the store.
14:54:28 <parsnip> it's weird to call the customer a client
14:54:32 <rom1504> I find it surprising to run the backend and frontend on the same device
14:54:34 <sim590> Both the cashier and the physical client are communicating with QR codes.
14:54:42 <rom1504> but I guess you can do that indeed
14:54:47 <parsnip> i would recommend not calling the customer a client
14:55:07 <parsnip> not in the asymmetric sense
14:55:12 <sim590> rom1504: Why? It's about consistent structure. Less rewriting.
14:55:24 <parsnip> both cashier and customer are using client apps
14:55:26 <sim590> parsnip: alright, I can call him a custommer.
14:55:33 <sim590> parsnip: exactly.
14:55:37 <parsnip> a male, no less
14:55:42 <sim590> Sure! :)
14:55:58 <parsnip> women can buy men's underwear, fyi
14:56:12 <sim590> For their man, yeah, sure!
14:56:16 <Rembane> And the other way around. 
14:56:20 <rom1504> from a quick search, looks like haskell doesn't run on mobile
14:56:23 <sim590> But anyway, we're not talking clothes, but food ^^
14:56:26 <rom1504> unsurprisingly
14:56:30 <sim590> rom1504: :(
14:56:35 <parsnip> ah, so it's men's food?
14:56:42 <sim590> parsnip: Yeah. Big steaks.
14:56:45 <parsnip> no salads, i expect
14:56:51 <sim590> Never.
14:57:08 <parsnip> "she'll have the salad, no chicken".
14:57:09 <rom1504> if you were to run a remote backend though then you can run it on a supported platform (linux for example) and everything will work
14:57:22 <rom1504> including the fact that you most likely want a remote backend anyway
14:58:36 <sim590> rom1504: yeah but I don't want people to need connectivity for using the app. It is about creating list of stuff to buy and you don't always have connectivity.
14:58:57 <sim590> Also, we don't have to bare with server workload. It's not necessary. Every client can do their computing themsleves.
14:59:17 <sim590> We don't need any central architecture.
14:59:29 <rom1504> https://wiki.haskell.org/Android you can hacking stuff
14:59:31 <rom1504> *try
14:59:50 <rom1504> https://wiki.haskell.org/IPhone
15:00:10 <rom1504> might work
15:02:11 <hseg> how do i get cabal to tell me which component is responsible for a signature dependency?
15:02:38 <hseg> cabal is complaining it can't satisfy a certain signature, but am using a multi-component project
15:02:57 <sim590> rom1504: Interesting. I will have a look at those links.
15:03:02 <solonarv> sim590: you *can* run Haskell on Android, but it's kind of a pain
15:03:14 <solonarv> I have no idea about iOS
15:03:28 <parsnip> sim590: I'm sort of enjoying Flutter. it uses Dart, if you don't hate OOP too much.
15:03:51 <parsnip> sim590: https://cone.tangential.info/
15:05:59 <sim590> parsnip: What language does it require us to use?
15:06:04 <sim590> Python?
15:06:06 <parsnip> Dart.
15:06:10 <sim590> Oh 
15:06:12 <sim590> right
15:06:14 <sim590> The Google language
15:06:18 <sim590> Is it?
15:06:21 <parsnip> Yes.
15:06:36 <solonarv> "the" google language? I thought there were like at least 2 or 3 of those
15:06:40 <parsnip> Is Haskell the Microsoft language?
15:06:42 <sim590> Well, we're already thinking about either using haskell or python.
15:06:58 <parsnip> haskell and python for a phone app?
15:07:09 <parsnip> I mean, it's possible.
15:07:11 <sim590> solonarv: ( ͡° ͜ʖ ͡°)
15:08:17 <parsnip> Note that your Flutter app will work on a number of platforms, and compares with React/ React native.
15:08:29 <sim590> parsnip: Python for the mobile client's backend, yes. We thought it would be best not to use javascript for backend concern.
15:08:43 <parsnip> sim590: I'm referring to the front end now.
15:08:50 <solonarv> not using JS is a very good idea, but idk that replacing it with python is really a huge improvement
15:09:06 <sim590> parsnip: aight. Well, now we are looking into react native and like it so far.
15:09:15 <parsnip> Fair enough.
15:09:29 <parsnip> I don't know javascript, so i went with flutter.
15:09:51 <parsnip> "which would you rather learn, dart of javascript?" "dart"
15:09:53 <parsnip> *or
15:10:08 <sim590> we asked ourselves the same question and preferred javscript.
15:10:12 <parsnip> :)
15:10:18 <sim590> :D
15:11:01 <sim590> Plus, it seemed wrong to use the dark side's language.
15:11:48 <parsnip> I mean, you're already targeting android or ios.
15:11:57 <sondr3> you could potentially use ReasonML with their bindings to React Native
15:12:07 <sondr3> if you want a better langauge than JS/TS
15:12:12 <sim590> Because （　ﾟДﾟ） dart-h vador, you know :)
15:12:54 <parsnip> is dart-h a haskell to dart compiler?
15:17:20 <sim590> parsnip: haha. Would be fun. :)
15:19:06 <phaazon> I just found a way to use loop
15:19:16 <phaazon> my life feels fulfilled
15:19:19 <phaazon> I can die in peace now
15:32:57 <zzo38> Is there a auto super class extension?
15:35:34 <muesli4> zzo38: meaning what?
16:05:24 * hackage sbv 8.6 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.6 (LeventErkok)
16:06:53 * hackage bz2 1.0.0.0 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-1.0.0.0 (vmchale)
16:17:23 * hackage bz2 1.0.0.1 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-1.0.0.1 (vmchale)
20:32:54 * hackage tangle 0 - HKD record builder  https://hackage.haskell.org/package/tangle-0 (FumiakiKinoshita)
20:49:53 * hackage standalone-derive-topdown 0.0.0.2 - This package will derive class instance along the data type declaration tree. (Deprecated)  https://hackage.haskell.org/package/standalone-derive-topdown-0.0.0.2 (songzh)
21:49:53 * hackage extensible 0.7.1 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.7.1 (FumiakiKinoshita)
22:08:53 * hackage githud 3.2.1 - Heads up, and you see your GIT context  https://hackage.haskell.org/package/githud-3.2.1 (gbataille)
22:37:28 <nickromancer> Weee
22:59:23 * hackage aura 2.0.4 - A secure package manager for Arch Linux and the AUR, written in Haskell.  https://hackage.haskell.org/package/aura-2.0.4 (fosskers)
23:04:19 <Frogulis> Hi all, I am trying to use the optparse-applicative library to set up some basic command line arguments by following the example given on that library's Hackage page. I am using a fairly default cabal setup, and I am running my project with a command like `cabal v2-run myProject -- --alpha blah --beta 23 --gamma`, however I receive an error from
23:04:19 <Frogulis> cabal telling me that I have "unrecognized 'v2-run' option '--gamma' and so on. I've pasted my .hs files at https://pastebin.com/QEf9VGMR, appreciate any help
23:05:53 <Frogulis> As a note, running without any arguments successfully displays the default values for those parameters
23:36:10 <glguy> Frogulis: try: cabal v2-run -- --gamma
23:36:56 <glguy> Also in the current version if cabal-install (3.0.0.0) run defaults to v2-run. If you're not already using that version you should
23:39:35 <Frogulis> glguy: same error when running that command, which seems pretty at-odds with the documentation. i'll try upgrading to 3.0.0.0 though
