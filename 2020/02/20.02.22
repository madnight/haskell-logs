00:00:54 * hackage pandora 0.2.1 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.1 (iokasimovmt)
00:09:39 <coot> Any body is using `haskell-ide-engine` with `vim`; could you recommend language protocol server plugin? I tried the recommended ones without luck.
00:46:47 <maerwald> coot: coc.nvim has broken process handling and kept spawning hie instances to memory exhaustion. I wouldn't use it. LanguageClient-neovim has less features and has buggy visuals ime
00:47:10 <maerwald> I would just give up
00:48:39 <coot> @maerwald thanks; I couldn't get even `LanguageClient-neovim` to work, so I gave up with it.
00:48:39 <lambdabot> Unknown command, try @list
00:49:06 <maerwald> it kinda works though, given that hie works (which is unlikely anyway)
00:49:39 <maerwald> LanguageClient-neovim + ghcide might be worth a try
00:50:08 <maerwald> and then make sure your cradle files do the right thing
00:50:27 <maerwald> I don't know who thought LSP is a good idea, but here we are :)
01:05:37 <zceejkr> Good morning everyone. A question if I may. I have a type class like so: class B b => A a b | a -> b where ... Now I create an instance like so for example: instance A [Int] Int where ... I also have another typeclass C. And for every type t which has an instance of A (as the first param, [Int] in my example), I can create an instance of C for t. That is: to implement the functions needed by C, I only need to compose the A and B
01:05:37 <zceejkr> functions. How do I do this in code, so that as soon as I define an instance of A for t, I also get the C instance for free?
01:10:38 <linduxed> yesterday i got into a discussion originating in an observation about another language (elixir, so still functional and immutable), and how one can/should interact with interfaces/data. i was curious what haskell developers thought on the subject:
01:10:54 <linduxed> let's say you have a simple stateless library that the application interacts with, for instance something that calculates ELO ratings. the idea of a Player is a rather central concept to working in this domain, so is generating a Result and eventually an updated Player.
01:11:24 <linduxed> the question here is: should one hide the records behind function interfaces, or is it OK to let these record types be available outside of the library? the argument i've faced is that "letting the types loose" runs the risk of them "entangling themselves in the rest of the application"
01:11:50 <linduxed> so there's a worry about too tight coupling to a library, if the library provides the types and one does not primarily interact through functions that are to be considered opaque interfaces, the return values of which one should not look into (one only puts them back into library functions)
01:12:19 <linduxed> how does the haskell ecosystem go about managing this? are types surfaced, or does one prefer to provide interfaces for generating the values?
01:16:18 <maerwald> structured types are all over the place and libraries not composable if you mean that
01:18:34 <linduxed> maerwald: i'm not sure how to interpret your response, as it relates to what i wrote. could you elaborate?
01:19:55 <maerwald> you say if you expose the "internal" types of a library as API, right?
01:19:59 <linduxed> in the conversation i was the proponent of "providing data" to the users of the library, as that gives them more flexibility to pattern match and do various other powerful operations
01:20:17 <maerwald> Or have non-trivial types at all in your API
01:21:15 <linduxed> the alternative that was proposed was to always ask for data through an API, and also only manipulate the data through an API. this was proposed to avoid the situation that types that come from a library get too entangled in the client application, which would then making changes (for the purpose of disentangling or removing the library) very difficult
01:21:42 <linduxed> (i objected that this can also happen if the API changes, not just the types, but we agreed to run with the dichotomy)
01:22:15 <maerwald> yeah, I don't see how that solves composability, except for low-level libraries that have all similar API anyway
01:22:31 <maerwald> In haskell there's another problem: how your API expresses effects
01:23:03 <linduxed> maerwald: yes, my side of the argument was that one could surface some core types that are integral to interacting with the library, and one could consider those types to be a part of the API, simply a different kind of constructor
01:24:17 <linduxed> maerwald: i think it's important to note that the other person in the argument didn't care much for composability in this case, just the problems of proliferation of a foreign type, if various parts of the application would suddenly care about and use a type that came from outside
01:25:37 <maerwald> If it isn't about composability, then about what? API breaking changes to the data?
01:26:02 <linduxed> the other person suggested that boundaries should be set up where types/complex data should be allowed up to a certain point only in the application, after which that had been translated to either internal types that the application has control over, or tranform to "rawer" types
01:26:27 <linduxed> maerwald: indeed, breaking changes were the central concern
01:26:38 <maerwald> these can happen in functions as well
01:26:42 <linduxed> right!
01:26:59 <maerwald> I don't see how distinguishing data and functions here is relevant tbh
01:27:13 <linduxed> but the argument was that functions have the opportunity to hide some of those breaking changes behind the interface
01:27:26 <maerwald> Data too
01:27:35 <maerwald> E.g. newtypes
01:27:57 <linduxed> thereby shielding the end user of a library in at least some of the situations, where the data would not (if one coupled against the data)
01:28:28 <maerwald> The same is possible with data, so I don't see the argument
01:28:30 <linduxed> maerwald: hmmm, interesting point. considering the conversation was about structs in elixir specifically, i'm wondering how the idea of newtypes transfers
01:28:37 <maerwald> yeah, no idea
01:28:51 <maerwald> https://wiki.haskell.org/Newtype
01:29:24 * hackage github-webhooks 0.12.0 - Aeson instances for GitHub Webhook payloads.  https://hackage.haskell.org/package/github-webhooks-0.12.0 (onrock_eng)
01:29:28 <linduxed> i've used newtypes in my very simple exercise haskell code, never actually worked with haskell, so don't know how newtypes would be applied in those scenarios
01:30:03 <linduxed> structs over in elixir are just maps where one key has a specific name, and the value indicates the module it originates from
01:30:35 <linduxed> it's a very rudimentary way to introduce something resembling data types in a dynamic language
01:31:02 <maerwald> the newtype wraps the internal type/struct, but doesn't expose it, then the external function API uses that newtype and the user only sees a constructorless newtype in the API
01:31:41 <linduxed> right, that does provide all of what was mentioned
01:32:24 <linduxed> it seems like the above mentioned discussion only has relevance when there's an absence of a system like newtypes
01:32:37 <maerwald> it isn't hard to emulate
01:34:43 <maerwald> and then we are back to getters and setters lol
01:35:15 <maerwald> Your friend is a Java dev? :>
01:36:26 <olligobber> my code has getters and setters
01:36:38 <linduxed> no, erlanger for the past couple of years. being an elixir dev, primarily, there are definitely different views on how applications/library ought to be structured
01:36:52 <linduxed> despite being on the same virtual machine
01:37:07 <olligobber> https://github.com/olligobber/DivisibilityRegex/blob/master/UnionFind.hs#L18
01:38:47 <maerwald> linduxed: I have a different proposition: hiding data makes your API sloppy and not well-thought out
01:40:06 <maerwald> if you need to hide your data, because you are messing around with it and have getters, setters and others stuff you still have two datas: one how your user imagines your it (even if it isn't in the API) and one how it actually is. Why is it different?
01:42:23 <maerwald> relevant to this discussion might be the difference between lens (transparent API) and optics (opaque API)
01:42:42 <maerwald> but not sure if you are familiar with those?
01:46:26 <linduxed> lenses i'm slightly familiar with: those are the generators for deep getters and setters, right?
01:46:33 <linduxed> optics i'm not familiar with at all
01:46:58 <maerwald> optics does the same
01:48:20 <maerwald> but uses newtypes (kinda, simplified)
01:49:56 <maerwald> in the case of optics... what it actually improved were compiler error messages
01:49:58 <linduxed> hmmm, interesting! so one could potentially have a library generate optics for usage of code outside of the library, and the users of the optics would know nothing about what is actually being dug into?
01:50:21 <linduxed> ah, yes, i've heard that lenses have very complicated error messages
01:51:08 <maerwald> hm, not sure what you mean with "would know nothing". Composability is still a problem and you still have to know which library you use
01:52:34 <maerwald> it's just that there are different possible implementations of lenses (I know nothing about the CT and theory behind it) and the authors could just replace said implementation without changing the API at all
01:52:43 <maerwald> not sure that's really going to happen, so
01:54:04 <maerwald> it's not something that "evolves"
01:55:12 <maerwald> which goes back to my point about messing with your internals too much... why do you need to :>
01:58:25 <maerwald> it could be a sign of 1. constantly changing domain requirements, 2. not well-thought out design, 3. sloppy workflow
01:59:03 <maerwald> all of those are bad
01:59:57 <linduxed> thank you for all of your comments, maerwald!
02:00:44 <linduxed> i really liked this part: "you still have two datas: one how your user imagines it and one how it actually it"
02:00:48 <linduxed> rings true to me
02:03:04 <Mrbuck> any one here into computer vision domain...I am still banned in haskell offtopic channel for morethan a year
02:06:04 <int-e> olligobber: Fun code. But that regex for divisibility by 2 looks a bit silly; [0-9]*[02468] would work (possibly wrapped in (...)? if you care about accepting the empty string). I actually played around with the special case of divisibility by 7 a couple of months ago and ended up with http://paste.debian.net/1113236/ which generates a regular expression of size 10793 (including anchors).
02:32:15 <fishooter> hi, I'm implementing a simple game in haskell using Graphics.Gloss
02:32:46 <fishooter> the play function can use an "advanceWorld" function, as last parameter
02:32:48 <fishooter> https://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss-Interface-Pure-Game.html#v:play
02:33:21 <fishooter> however, when I print the float, it keeps being the same number, I thought it would be seconds since start, any ideas?
02:33:45 <fishooter> it prints 3.3333335e-2
02:39:57 <Tuplanolla> Might be the time difference between frames, fishooter.
02:41:32 <fishooter> ah, yes, it must be :) didn't think of that. 1/30 = 3.33e-2 :)
02:53:19 <zceejkr> Reposting this question, I hope this is okay:
02:53:28 <zceejkr> I have a type class like
02:53:29 <zceejkr>           so: class B b => A a b | a -> b where ... Now I create an instance
02:53:29 <zceejkr>           like so for example: instance A [Int] Int where ... I also have
02:53:29 <zceejkr>           another typeclass C. And for every type t which has an instance of A
02:53:32 <zceejkr>           (as the first param, [Int] in my example), I can create an instance
02:53:35 <zceejkr>           of C for t. That is: to implement the functions needed by C, I only
02:53:38 <zceejkr>           need to compose the A and B functions. How do I do this in code, so that as soon as I define an
02:53:41 <zceejkr>           instance of A for t, I also get the C instance for free?
02:55:39 <__monty__> zceejkr: Maybe generic deriving or deriving via? Please use a pastebin (not .com) for such questions in the future.
02:58:27 <zceejkr> __monty__: thank you, will check it out. And apologies for the mess.
03:38:24 * hackage miso-from-html 0.1.0.0 - Convert HTML to miso View syntax  https://hackage.haskell.org/package/miso-from-html-0.1.0.0 (DavidJohnson)
03:45:43 * ski idly glances at zceejkr
03:50:58 <olligobber> int-e, yeah, it doesn't generate the best regex, but it works
04:36:24 * hackage reanimate 0.2.0.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.2.0.0 (DavidHimmelstrup)
06:06:24 * hackage prettyprinter-graphviz 0.1.1.1 - a prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-0.1.1.1 (GeorgeThomas)
07:48:43 <maxsu> Has anyone played with jupyer with ihaskell?
07:52:59 <maxsu> I'd like to use it to develop and publish business report type stuff
07:53:44 <maxsu> but a severe issue I've had with notebooks is that it's hard to test and debug them
07:56:58 <[exa]> notebooks are good for reproducibility tutorial-style aid, not even marginally for reports
08:03:50 <maxsu> [exa], that hasn't stopped vendors trying to turn notebooks into reproducible and transparent reports, web apps, and even mobile stuff, lol
08:04:21 <maxsu> [exa], not that I disagree - what about them is the worst for reports?
08:05:31 <maxsu> https://medium.com/capital-fund-management/automated-reports-with-jupyter-notebooks-using-jupytext-and-papermill-619e60c37330
08:05:32 <[exa]> depends if you use them more because of the formatting, or because of automation
08:05:50 <maxsu> heh
08:05:54 <[exa]> automated reports are a waste of resources, much better to export raw data
08:06:35 <[exa]> and for formatting I'd just export latex
08:07:23 <[exa]> anyway I'm probably biased on that matter
08:11:16 <maxsu> I have in mind this thing that takes your notebook, spins up a docker container around it, and then turns it into a microservice
08:11:41 <maxsu> I don't know if it's something I've seen or just a fever dream - but probably the first
08:12:45 <geekosaur> why do I feel like you're reinventing hypercard?
08:12:55 <maxsu> lol, imagine your whole company's infrastructure is notebooks all the way down
08:12:58 <maxsu> how evil
08:13:42 <maxsu> http://www.pybloggers.com/2016/01/jupyter-notebooks-as-restful-microservices/
08:14:47 <maxsu> lol, this has such evil and chaotic energy to it
08:15:14 <[exa]> maxsu: people have kubernetes clusters with separate configurations just for notebooks
08:15:42 <maxsu> I'm thinking of making one so I can stop using cocalc
08:19:40 <maxsu> I feel all this is just a little crazy, considering it's still impossible to get good debugging in a notebook
08:20:54 <maxsu> and the visual advantage disappears once it's a microservice, since those notebooks look just as ugly as raw microservice code
08:22:32 <[exa]> maxsu: ok with cocalc it starts to sound scary
08:23:33 <maxsu> https://hub.packtpub.com/introducing-voila-that-turns-your-jupyter-notebooks-to-standalone-web-applications/
08:23:34 <maxsu> lol
08:24:01 <maxsu> apparently jupyter notebooks let us do something called "Literature Programming" ;)
08:24:48 <[exa]> literate haskell?
08:26:05 <maxsu> it's like literate programming, but rather than being just able to read, you've also gone to college for a degree in letters
08:27:26 <[exa]> degree in letters?
08:27:41 <maxsu> like a masters in english literature
08:28:22 <maxsu> litterature programming is apparently much refined
08:29:08 <[exa]> I'm still thinking mostly latex
08:30:40 <maxsu> they're aiming it as just another easy way for nontechnical business folks to make wysywig charts and forms, tbh
08:31:31 <maxsu> plus it's all in a markdown format, and you can run the ihaskell kernel if you want
08:31:52 <maxsu> so in that way it's kind of isomorphic to literate programming anyways
08:34:12 <maxsu> this feels like an extension of the literate programming model, where you work on the code behind things like a web dashboard as if it's a live document
08:35:49 <maxsu> but there's also that awesome visualization component, where you create interactive images inline with your code
08:53:50 <berndl> What is the relationship between Traversal and Traversable?
08:54:44 <sixto> Hello
08:55:30 <[exa]> berndl: Traversable is the property of data, Traversal is the datatype of a lens that usually goes through Traversable stuff
08:55:41 <[exa]> (very roughly)
08:55:41 <sixto> Can some one help me with a excercise
08:56:03 <[exa]> sixto: we're not doing it for you but we can give a lot of advice
08:57:55 <sixto> yeah
08:58:00 <sixto> thats what i want 
08:58:13 <sixto> because i am lost on how to know if is a digit
08:58:14 <berndl> [exa]: I don't understand the "Traversable is a property of data" part.
08:58:21 <sixto> Define a function that takes a string and returns the sum of all numbers ocurring in it. 
08:58:38 <sixto> i was trying someting like this 
08:58:39 <sixto> functionTwo x = [y| y <- x, y `elem` [0..9]]
08:59:26 <[exa]> berndl: e.g. lists are traversable because they are "kindof containers" and there is a straighforward way to go through them in order. Functions are not very traversable OTOH
08:59:28 <geekosaur> berndl, in Haskell "a property of data" is encoded as part of its type, when possible
08:59:42 <Zemyla> Okay, every value e that's an instance of MArray (STUArray s) e (ST s) is also an instance of IArray UArray e.
09:00:07 <[exa]> sixto: so what shold it return for "asd123b 5"?
09:00:09 <Zemyla> I wish that we had a base class like Unboxed e => IArray UArray e and Unboxed e => MArray (STUArray s) e (ST s).
09:00:15 <geekosaur> and Traversable is a typeclass, which ascribes a particular property to values of types which are its instances
09:00:48 <sixto>  "asd123b 5" => 5
09:00:53 <[exa]> sixto: I'd assume 128, but perhaps the "asd123b" doesn't count as a number
09:00:55 <[exa]> oh okay
09:01:13 <sixto> yeah i need toidentified what is a number
09:01:52 <monochrom> > let functionTwo x = [y| y <- x, y `elem` [0..9]] in functionTwo "asd123b 5"
09:01:56 <lambdabot>  error:
09:01:56 <lambdabot>      • No instance for (Num Char) arising from a use of ‘functionTwo’
09:01:56 <lambdabot>      • In the expression: functionTwo "asd123b 5"
09:02:02 <berndl> The relationship seems to be this one: traverse :: Traverse (t a) (t b) a b
09:02:19 <monochrom> Ah, use ['0' .. '9'] instead.
09:02:41 <[exa]> sixto: the building blocks: first you can just use 'words' to split stuff to words. Then you can use 'all' in 'filter' to check that the thing is fully out of digits, i.e. a number. That should give you a list of strings that only contain numbers
09:03:14 <[exa]> after that, 'map','sum' and 'read' can get you the final result easily
09:03:19 <nshepperd2> > isDigit '一'
09:03:22 <lambdabot>  False
09:03:28 <nshepperd2> fair enough
09:03:37 <[exa]> nshepperd2: how indecent
09:04:47 <sixto> i am new in this languaje in java or python i would look to split for space in the string
09:05:01 <[exa]> sixto: that's what 'words' function does
09:05:09 <sixto> ok
09:08:16 <sixto> ok now i have to put a fillter there
09:08:59 <[exa]> yes, check the list of functions I wrote above (also also, there's isDigit as nshepperd2 hinted)
09:09:17 <sixto> i would prefer not to use isDigit
09:09:52 <[exa]> ok, then the method with ⌜`elem` ['0'..'9']⌝ is probably the best
09:09:53 <sixto> yea i know i have to sum and the end when i have a list with the numbers
09:10:34 <sixto> but how identifie like "sixto2 from 2 22 222" => 226 should be the result
09:10:50 <sixto> 248
09:11:06 <sixto> 250
09:11:20 <ggVGc> how could I profile compilation? e.g to find out how to make my project compile faster
09:11:25 <ggVGc> I'd have to profile ghc eh
09:12:02 <[exa]> sixto: ok now you should have something like ["sixto2","from","2","22","222"], so just apply a filter with a function that recognizes numbers
09:15:01 <sixto> isDigit is not reconice and i think i have to import thats why i am avoiding that one
09:16:25 <[exa]> sixto: import Data.Char should do it
09:17:34 <sixto> i could do it but is there a function that is already implemented that could help me?
09:18:27 <[exa]> you can look at how isDigit is implemented
09:19:03 <[exa]> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Unicode.html#isDigit
09:19:05 <sixto> ok nice tip
09:19:15 <[exa]> anyway your method with `elem` is pretty good too, why not use it?
09:19:43 <sixto> gonna try givme a couple min
09:26:39 <sixto> functionTwo x = [y| y <- words x, y `elem` [1..9]]
09:26:51 <sixto> i am getting 
09:26:57 <sixto> ejercicios.hs:5:44: error:
09:27:00 <sixto> ^^^^^^
09:27:53 <sm[m]> ggVGc: I’d ask #ghc for advice. One easy step is to make it verbose and watch the output to get an idea of which files/constructs are taking time
09:29:04 <sm[m]> Eg modules with lots of generics? Lots of TH-generates code ? Unusually large case statements ?
09:30:11 <sm[m]> Unnecessarily large modules ? Unnecessarily interdependent code ?
09:56:33 <idnar> @hoogle Monad m => m Bool -> m ()
09:56:35 <lambdabot> Control.Monad.Extra whileM :: Monad m => m Bool -> m ()
09:56:35 <lambdabot> Extra whileM :: Monad m => m Bool -> m ()
09:56:35 <lambdabot> Control.Monad.Tools doWhile_ :: Monad m => m Bool -> m ()
10:39:30 <sixto> Hello could some one help me, i want to sum a list of string but i know they are numbers
10:39:37 <sixto> functionTwo x = [y| y <- words x, all isDigit y]
10:39:58 <sixto> but functionTwo x = sum [y| y <- words x, all isDigit y] give error
10:41:03 <ChaiTRex> sixto: Change y to read y just before |
10:44:04 <sixto> what do read? there
10:44:15 <ChaiTRex> :t read
10:44:16 <lambdabot> Read a => String -> a
10:44:43 <ChaiTRex> sixto: turns a String into some other type, like a numeric type.
10:47:35 <sixto> Ty it work wonderfull
11:03:24 * hackage paint 2.0.0 - Colorization of text for command-line output  https://hackage.haskell.org/package/paint-2.0.0 (lovasko)
11:22:11 <Tuplanolla> I recall SPJ mentioning, in passing, that some part of GHC did not have any comments, except for one "now for the tricky bit". Does anyone remember where this was?
11:25:26 <Uniaika> Tuplanolla: I'm pretty he said that at last year's ZuriHac
11:26:00 <Tuplanolla> I thought it might have been in Wearing the Hair Shirt, but I can't find a PDF of it.
11:29:54 * hackage mmsyn7ukr 0.15.2.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.15.2.0 (OleksandrZhabenko)
12:03:49 <dsal> Working on a project using dhall.  Emacs decides to canonicalize the dhall format.  I don't understand why it's so hateful.
12:08:23 <sm[m]> dsal: you know we'll tell you to compare with -Q, and it's going to be your own fault.. 
12:09:43 <dsal> What's -Q?
12:10:55 <dsal> The format is just so bizarre to me, that I have a hard time believing the project wasn't infiltrated by someone trying to prevent adoption.
12:23:59 <sm[m]> dsal: emacs -Q turns off all config files - standard troubleshooting step, the first thing you'll hear in #emacs
12:24:21 <dsal> Ah.  This is a dhall minor mode that runs 'dhall format' on save.  That'd be totally reasonable if 'dhall format' were at all reasonable.
12:25:05 <sm[m]> ah
12:26:12 <glguy> What does it look like?
12:28:51 * sm[m] has noticed that dhall examples hurt the eyes a bit 👀
12:29:18 <dsal> I've got a config that looks like this: https://usercontent.irccloud-cdn.com/file/mS0Zy4vG/before
12:29:28 <dsal> dhall format makes it look like this: https://usercontent.irccloud-cdn.com/file/xCm9xrWS/after
12:30:51 <Uniaika> I could understand such formatting for pretty-printing stuff like `jq`, but for configuration files that's just ridiculous
12:31:09 <merijn> It's indenting a bit zealously, but it doesn't look so bad
12:31:27 <merijn> Uniaika: Why?
12:31:34 <dsal> Yeah, maybe.  It's meant to be a kind of yaml replacement, sort of, but a simple function call should like, take fewer lines.
12:31:59 <dsal> merijn: I like being able to see my code on my screen.  Putting everything on its own line makes a page of config suddenly require a lot of scrolling.
12:34:52 <sm[m]> They’re optimizing for minimal diffs and easy mechanical editing instead I guess
12:36:08 <Uniaika> merijn: way too much indentation
12:36:55 <Uniaika> (also I think it's ridiculous to put a single-word type signature on a separate line)
12:37:46 <dsal> I often put more than one thing on a line of code.  Maybe the name of a function and its parameter, possibly two parameters...
12:43:26 <Nolrai> So, is there a way to grab the data criterion collects before it writes it to a file? It just seems silly to have to parse the file it makes just to get the data back into my benchmark runner.
12:57:58 <merijn> Nolrai: Sure, you just gotta stop using the default main implementation of criterion and call the relevant stuff yourself
12:59:26 <merijn> hmm, apparently they didn't expose a nice hook for that
13:00:31 <merijn> Nolrai: https://hackage.haskell.org/package/criterion-1.5.6.2/docs/Criterion.html#g:4
13:03:29 <Nolrai> Thanks I missed those ones at the very bottom. Maybe I should have just stuck with Gage..hmm.
13:03:44 <Nolrai> Oh well down the rabit hole I go.
13:17:24 * hackage squeather 0.4.0.0 - Use databases with the version 3 series of the SQLite C library  https://hackage.haskell.org/package/squeather-0.4.0.0 (OmariNorman)
13:20:40 <xavo[m]> hey, what resources do y'all recommend for learning more about the family of optics?
13:21:03 <xavo[m]> I'm pretty comfortable with the view/set/over uses of lenses but the rest is a mystery to me
13:25:26 <dsal> xavo[m]: https://leanpub.com/optics-by-example
13:25:49 <wildtrees> xavo[m], check out prisms for sum types, they are quite useful 
13:26:09 <maerwald> 420 pages
13:26:13 <maerwald> wat
13:26:58 <xavo[m]> dsal: nice, I've seen this but wasn't sure how good it was, ty
13:26:59 <dsal> What kind of pages would you prefer?
13:27:31 <dsal> xavo[m]: It's pretty good relative to all the other stuff I've found.  :)
13:27:35 <maerwald> Dunno, sounds like it would be too verbose to follow 
13:27:41 <dsal> I'm a more casual optician.
13:28:42 <dsal> maerwald: Depends on how you like to absorb concepts.  It walks through concepts in a pretty useful way.  There've been a few updates (including at least one new chapter) since I got it a while back, though.
13:33:57 <dsal> Heh, I just got an email telling me there's an update to that book.
13:58:24 * hackage split 0.2.3.4 - Combinator library for splitting lists.  https://hackage.haskell.org/package/split-0.2.3.4 (BrentYorgey)
14:19:09 <tty1> Hi haskell noob with a quick question. Since haskell compiles to binary (I think, when using GHC at least) does that mean that when compiled as a library it can/does compile to a *.so or other native library binary and looks indistinguishable from a C/C++ static/dynamic library and can be included in C code?
14:19:24 <merijn> tty1: Correct
14:19:40 <merijn> tty1: In fact, the FFI lets you export C ABI compatible symbols to call
14:20:38 <tty1> sweet!
14:20:44 <merijn> tty1: I can recommend chapter 8 of the Haskell report (that describes the FFI) and the GHC user guide section on the FFI. If you know C/C++ and how linking works there it should all be rather straightforward for you
14:20:49 <merijn> @where report
14:20:49 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:21:25 <tty1> thanks not just yet, but soon.
14:21:29 <merijn> tty1: You need to do a bit of extra work to call stuff from C/C++ (initialising the RTS so that GC works, etc.) but that's just like 1 or 2 function calls
14:21:35 <tty1> thats all i needed to know for now
14:22:26 <merijn> tty1: I have a minimal (and by that I mean untested and years old ;)) minimal example of calling Haskell with a C based main(): https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
14:22:37 <tty1> merijn:so it wont look indistinguishable from an ordinary shared library? A consume will have to take different steps to interact with the library (those two function calls) but it is minimal
14:22:48 <tty1> oh cool thanks
14:25:37 <maerwald> merijn: add to that example how to expose types :>
14:25:47 <merijn> maerwald: hmm?
14:25:53 <maerwald> data types
14:26:16 <merijn> maerwald: Easy "you can't, because the C ABI doesn't support struct or unions"
14:26:25 <maerwald> :(
14:27:24 <merijn> maerwald: The C ABI only allows the normal primitive types (which are auto marshalled) and pointers. Now, you can interact with pointers from Haskell using Storable, but there's no such thing as "portable" Storable instances
14:31:08 <merijn> I'm actually not even sure you can portably (i.e. from different implementations) access struct or unions in standard C. I'm erring on the side of "no"
14:39:36 <nshepperd> standard C doesn't even know how big a byte is
14:40:13 <merijn> It does :p
14:40:15 <merijn> "1" :p
14:40:32 <ChaiTRex> That's how big a char is.
14:40:43 <merijn> ChaiTRex: Bytes == char in C
14:40:45 <mark_stopka> Hi!
14:40:53 <ChaiTRex> A likely story.
14:40:58 <merijn> ChaiTRex: Wanna bet? :)
14:41:21 <merijn> I'll bet you 100 dollars that the C spec says 1) char == byte and 2) the bit size of bytes is implementation defined
14:41:43 <mark_stopka> I am new to Haskell, I am just building first piece of software using Stack, and I was wondering if there is a way to disable some features like I would do with cmake for instance...
14:42:14 <mark_stopka> I am going to run the application in Docker so integration with journald is totally useless...
14:44:18 <ChaiTRex> Why would I bet? I said it was a likely story.
14:45:09 <merijn> ChaiTRex: A sarcasm detection misfire, maybe? :)
14:45:58 <mark_stopka> This is how the dependency is defined in the code:
14:46:00 <mark_stopka> #ifdef LINUX
14:46:10 <maerwald> merijn: so there is not point in uint8_t?
14:46:46 <merijn> maerwald: uint8_t *must* be exactly 8 bits IFF it exists
14:46:56 <merijn> maerwald: But implementing uint8_t is not required by the spec
14:47:16 <merijn> In fact, if your implementation cannot support uint8_t you are not allowed to define it
14:47:43 <monochrom> <dad joke> There is no point in uint8_t because it is not a pointer </dad joke>
14:48:07 <merijn> maerwald: But uint8_t is a type an not otherwise used in the rest of the spec. The entire spec is defined in terms of char/byte (which are explicitly defined to be the same thing)
14:48:50 <merijn> char is "the smallest addressable type" (and I have seen implementations with 32 bit chars on DSP chips, which leads to "sizeof(int) == 1", so that's fun...)
14:49:37 <monochrom> Is 100 dollars enough to buy a copy of the C standard from the standard body? :)
14:49:53 <nshepperd> i thought the spec would probably phrase it in terms of words or something
14:49:57 <merijn> monochrom: No, I'm a cheap bastard so I just use the final pre-spec draft
14:50:41 <maerwald> what if the final final spec defines bytes?!
14:52:53 * hackage mmsyn6ukr 0.6.3.1 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.6.3.1 (OleksandrZhabenko)
15:30:25 <xavo[m]> I like this tagline
15:30:43 <xavo[m]> that's two separate things lmao
15:31:46 <xavo[m]> or it a "there exists" situation
15:31:59 <xavo[m]> s/it/is it/
15:42:38 <hiptobecubic> hackage aeson 1.2.3.4 - A package for handling json data or a deep learning framework for generating spicy mexican food recipes
15:45:07 <monochrom> haha
15:54:40 <sm> mark_stopka: haskell packages often provide cabal flags for choosing build options. They'll be listed on the package's hackage page
15:54:46 <petersen> Is there any problem with building cabal-install-2.4.1 with Cabal-2.4.0? (I mean it builds but...)
15:57:27 <petersen> Well it builds so ship it!? ;-)
15:59:26 <sm> http://hackage.haskell.org/package/cabal-install-2.4.1.0 says it depends on Cabal-2.4.1, so I wonder how it built
16:00:08 <sm> or do you mean you used cabal-install 2.4.0 to build/install cabal-install 2.4.1 ?
16:00:30 <mark_stopka> sm: same way you would install new gcc :)  
16:02:52 <petersen> sm: hehe yeah I know - I mean after tweaking the bounds :)
16:03:33 <petersen> I build for Fedora with Cabal
16:04:40 <petersen> My assumption is that Cabal-2.4.1 probably has some fixes and improvements for they prefer people to use that... but ghc never shipped 2.4.1 :-(
16:04:49 <petersen> s/for/so/
16:08:09 <sm> petersen: hmm.. I'd better let a cabal dev answer that one
16:08:33 <petersen> mark_stopka: you asked about ghc-8.8.2 on  #fedora-haskell - you can do `dnf module install ghc:8.8` today though if you want
16:08:42 <petersen> sm: sure, thanks :)
16:08:44 <sm> because an older Cabal came with your ghc, does that mean you can't build with a newer Cabal ?
16:09:14 <petersen> sm: I "can" but don't want to :-)
16:09:52 <mark_stopka> petersen, thanks! But I had a second follow up question to that... when EPEL 8? :D
16:10:24 <petersen> I mean if I cabal-install cabal-install that is fine but reboot strapping ghc to ghc-2.4.1 seems a bit tedious - maybe one can just do a drop-in replacement...
16:10:53 <petersen> mark_stopka: great check - soonish I hope
16:11:07 <mark_stopka> sm: the chicken and egg issue is so super common for package maintainers, I was openSUSE package maintainer and "the bootstrap problem" is well known topic :)
16:11:10 <petersen> oops great question, I meant
16:12:13 <petersen> sm: the problem for me is distro kind of encourages only one Cabal lib
16:12:46 <mark_stopka> good old days of moving from gcc3 to gcc4 :D
16:13:22 <mark_stopka> petersen: I think the problem with multi-version is pain for pretty much everything
16:13:30 <petersen> mark_stopka: unfortunately there isn't even a Copr yet ;-(  older Fedora packages might work I should test that
16:13:52 <petersen> mark_stopka: yeah unless nixos...
16:14:27 <petersen> mark_stopka: I think you can pass cabal flags to stack
16:14:44 <petersen> or better put them in stack.yaml
16:15:24 <mark_stopka> yeah, sadly the dependency in question does not handle flags, I created an issue for the upstream folks, let's see
16:15:32 <petersen> okay
16:15:55 <mark_stopka> do you know if I can change --bin-path to something other than ~/.local/bin?
16:15:59 <mark_stopka> for stack?
16:16:37 <mark_stopka> i tried stack path --bin-path=/usr/local/bin but no joy
16:17:55 <petersen> hmm
16:18:13 <petersen> Honestly i haven't tried... there is `local-bin-path`
16:19:06 <petersen> stack path --local-bin, perhaps?
16:21:18 <petersen> But the distro install story is not so great with cabal-install or stack I think... often easier just to copy
16:21:55 <mark_stopka> Hmm, --local-bin did not work for me, but stack path --local-bin-path=/usr/local/bin did
16:21:57 <mark_stopka> thx!
16:22:40 <petersen> okay
16:22:48 <petersen> cool
16:23:12 <sm> stack --help and stack CMD --help are your friend
16:23:56 <sm> the user guide is your friend too, but just a bit scattered
16:24:16 <sm> but its heart's in the right place
16:24:23 <petersen> Yes
16:24:37 <mark_stopka> sm: --help did not tell me there has to be `=` sign =)
16:25:23 <sm> mark_stopka: you mean --local-bin-path PATH wasn't equivalent to --local-bin-path=PATH ?
16:25:35 <mark_stopka> (base)[root@a888c71d18cb /usr/src/cardano-node]$ stack path --local-bin-path /usr/local/bin
17:03:39 <koz_> What's backwards (.) again?
17:03:47 <suzu> >>>
17:04:27 <ChaiTRex> @pl g f x = f (g x)
17:04:28 <lambdabot> g = fix (flip (.))
17:04:41 <koz_> Uhhh.
17:05:14 <hpc> fascinating
17:05:17 <suzu> @t (>>>)
17:05:17 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
17:05:23 <suzu> :t (>>>)
17:05:26 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
17:05:33 <suzu> :i Category
17:05:36 <hpc> oh, because it's missing the actual name of the thing
17:05:41 <suzu> eh whatever
17:05:44 <suzu> `->` is in Categroy
17:05:44 <hpc> @pl \g f x -> f (g x)
17:05:45 <lambdabot> flip (.)
17:05:50 <suzu> so `>>>` will be flip .
17:07:40 <MarcelineVQ> koz_: (˙)
17:08:07 <ChaiTRex> suzu: No, it'll be flip (.)
17:08:20 <suzu> yes
17:09:36 <koz_> MarcelineVQ: Lol.
17:13:35 <Axman6> @hoogle readMay
17:13:36 <lambdabot> Safe readMay :: Read a => String -> Maybe a
17:13:36 <lambdabot> ClassyPrelude readMay :: (Element c ~ Char, MonoFoldable c, Read a) => c -> Maybe a
17:13:36 <lambdabot> BasicPrelude readMay :: Read a => Text -> Maybe a
17:13:46 <Axman6> @hoogle readMaybe
17:13:47 <lambdabot> Text.Read readMaybe :: Read a => String -> Maybe a
17:13:47 <lambdabot> Text.Read.Compat readMaybe :: Read a => String -> Maybe a
17:13:47 <lambdabot> Protolude readMaybe :: Read a => String -> Maybe a
17:16:18 <MarcelineVQ> Axman6: you've gone mad with power
17:28:14 <dmwit> :t let x = (.x) in x
17:28:16 <lambdabot> error:
17:28:16 <lambdabot>     • Occurs check: cannot construct the infinite type:
17:28:16 <lambdabot>         a1 ~ (a1 -> c1) -> c1
17:28:24 <dmwit> :t fix (flip (.))
17:28:25 <lambdabot> error:
17:28:25 <lambdabot>     • Occurs check: cannot construct the infinite type:
17:28:25 <lambdabot>         b ~ (b -> c) -> c
17:28:42 <dmwit> oh lol
17:28:46 <dmwit> ?pl \g f x -> f (g x)
17:28:46 <lambdabot> flip (.)
17:28:57 <dmwit> The original question was wrong.
17:29:18 <koz_> dmwit: How was my original question wrong?
17:29:32 <dmwit> ChaiTRex's translation of your question into lambdabot-ready syntax was wrong.
17:31:14 <koz_> dmwit: Ah, OK.
17:35:24 * hackage acts 0.3.1.0 - Semigroup actions and torsors.  https://hackage.haskell.org/package/acts-0.3.1.0 (sheaf)
17:44:54 * hackage pretty-simple 3.2.2.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.2.2.0 (cdepillabout)
18:05:54 * hackage stack-templatizer 0.1.0.2 - Generate a stack template from a folder.  https://hackage.haskell.org/package/stack-templatizer-0.1.0.2 (lysergia)
18:59:24 * hackage vinyl 0.12.1 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.12.1 (AnthonyCowley)
19:14:22 <Poscat[m]> Is hoogle down?
19:14:41 <Poscat[m]> wait it's online now
19:14:42 <Poscat[m]> nvm
19:14:55 <xavo[m]> works on my end as well
19:15:35 <xavo[m]> and if not you can probably throw up a local copy although I don't remember how off the top of my head lol
19:18:00 <koz_> xavo[m]: 'Throw up' is a hilarious way of phrasing that.
19:18:13 <koz_> Just like, vomit Hoogle onto your computer.
19:20:21 <xavo[m]> oh lol I didn't even notice, I say "throw up" in terms of servers without thinking about it at all
19:20:43 <xavo[m]> probably somewhere between "put up" and "throw together", haha
19:33:54 * hackage Frames 0.6.2 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.6.2 (AnthonyCowley)
19:50:38 <argent0> Hi, If I have `clas Foo a b` and how do I define a "bigger" `class Bar a b` such that `instance Bar a b => Foo a b`? This requires `FlexibleInstances` b.c. Foo isn't a type constructor.
19:54:28 <pavonia> What is the actual use case for this? That instance seems too general
19:56:12 <argent0> `class Foo a b` means that a has a (Map Int b). `class Bar a b` means that `a` has a (Map Int b) and a (Map b [Int]). I.e an inverse
19:57:24 <argent0> So renamed would be: `class HasMap a b` means that `a` has a (Map Int b). `class HasReversibleMap a b` means that `a` has a (Map Int b) and a (Map b [Int]). I.e an inverse
19:59:50 <solonarv> ah I see, you just make Bar a subclass of Foo
20:00:01 <solonarv> 'class HasMap a b => HasInvertibleMap a b where ...'
20:00:01 <argent0> so far I've been doing `class (HasMap a b) => HasReversibleMap a b where reverseLookup ....` but then I've be careful when writing the code for `instance HasMap a b` so that it keep tracks of the inverse
20:01:18 <pavonia> But that instance enforces that all maps are also reversible
20:05:09 <argent0> solonarv, pavonia: thanks for the help
20:18:46 <Cale> argent0: It may help to realise as well that when your Haskell implementation is trying to decide which instance to use, it can't rely on the absence of instances, because those might occur in future modules (either ones which haven't been compiled yet or ones which haven't been written yet)
20:19:03 <Cale> argent0: So if you write an instance like  instance Bar a b => Foo a b
20:19:22 <Cale> to the algorithm that decides which instance to use, that looks like  instance Foo a b
20:19:26 <Cale> i.e. it always applies
20:19:40 <Cale> Only after committing to the instance will it try to satisfy the constraints on the left of the =>
20:23:55 <argent0> Cale: interesting, that explains the error I was getting. What should I read to learn how the haskell type checker works? I've come to the conclusion that Much of the erroneuos code I write is because I don't understand some detail about how the type checker works.
20:24:23 <argent0> And all the extensions that change how the type checker works...
20:25:51 <Cale> Well, it is pretty involved once you include all the things, but maybe it would be good to start with some papers about Hindley-Milner types -- but those won't cover type classes and constraints
20:27:33 <adam_wespiser> yea, the paper that really helped me grok the TC was "Typing Haskell In Haskell"
20:28:06 <Cale> I'm not sure what I read in regard to instance resolution to first understand it... probably it's more like I had enough conversations with other people about why it has the properties it has before I actually read anything formal
20:28:37 <Cale> There's like the OutsideIn(X) paper if you want a fairly complete story, but it's... big
20:29:08 <Cale> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf
20:29:36 <argent0> Cale, adam_wespiser: I'll check those out
20:30:59 <Cale> argent0: Apart from that, the GHC user's guide is a nice resource on the extensions, make sure to check out what it has to say about them. It'll also often link to more resources (though perhaps it could be better about that)
20:31:41 <Cale> Almost every extension has at least one paper written about it, and usually Simon Peyton Jones is on the authors list :)
20:32:02 <Cale> Philip Wadler also has a lot of good beginner papers on Haskell from long ago
20:32:53 <Cale> http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html -- bunch of early papers on type classes here
20:33:13 <Cale> (and some more recent stuff as well)
20:33:35 <adam_wespiser> Jannis Limperg has a really good article on Extensions, and does a nice job organizing them in a coherent way: https://limperg.de/ghc-extensions/ 
20:34:53 * hackage hpp 0.6.2 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.6.2 (AnthonyCowley)
20:35:13 <argent0> Cale, adam_wespiser: Thanks for the info. I'll check those out too
20:35:37 <adam_wespiser> Cale: I haven't seen that typeclass paper collection, adding it to my resources list :)
20:36:20 <argent0> the book "Thinking with types" also covers the TC tangentially.
20:36:25 <Cale> adam_wespiser: It's worth checking out the rest of Wadler's publications as well
20:37:04 <adam_wespiser> I've been working through the early Haskell papers at a pretty lazy pace, it's really interesting stuff
20:37:12 <Cale> He wrote a lot of very easy to read papers about Haskell early on which were vital tutorial material back when I was getting started :)
20:38:47 <adam_wespiser> yea, Walder's "How to make ad hoc polymorphism less ad hoc" really made it click for me
20:39:32 <Cale> The only thing I don't like about that paper is the title, which although it's cute, it made a lot of people refer to type classes as a kind of ad-hoc polymorphism
20:40:47 <Cale> The nice thing about type classes vs. most ad-hoc polymorphism is that because of that additional organisation, decisions about which instance to use can be deferred, and so just using type class polymorphic stuff gets you more type class polymorphic stuff
20:42:02 <adam_wespiser> My reading on the name was the it was in reference to the "Expression Problem", and the "ad hoc" part being Haskell typeclasses could be extended by having a library user write new instances for there datatypes 
20:43:56 <Cale> Yeah, it's just that e.g. in C's ad-hoc polymorphism, you can define many versions of a function and have them selected based on the type of the usage, but you can't use such an ad-hoc polymorphic thing to define another one in one go (without repeating all the cases you want)
21:08:07 <pounce> how do i make random floats?
21:08:25 <adam_wespiser> not sure, have you checked out "System.Random" ?
21:08:45 <pounce> yeah, ive been using it for Ints, is it the same where i specify a range?
21:10:44 <adam_wespiser> I think you can you randomR: https://hackage.haskell.org/package/random-1.1/docs/System-Random.html#v:randomR
21:11:03 <adam_wespiser> 'Random a' is defined for float
21:14:21 <adam_wespiser>  let gen = mkStdGen 0 in take 10 $ randomRs (0 :: Float, 1 :: Float) gen
21:17:12 <pounce> humm
21:17:24 <pounce> is there a way to truncate floats when `show`ing them
21:17:36 <pounce> i want to show at most 4 decimal places
21:17:54 <adam_wespiser> you want either `round` or `truncate`
21:19:27 <pounce> hum, i suppose i could do things this way
21:20:17 <adam_wespiser> what you probably want is a nice sprintf
21:20:58 <pounce> ugh
21:21:14 <adam_wespiser> this example is exactly what you are talking about: http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html#v:printf
21:21:40 <solonarv> there are some functions in the 'Numeric' module for showing floats with various knobs to tweak, too
21:22:27 <pounce> is showFFloat included in ghc?
21:22:30 <pounce> err, yes that solonarv 
21:23:12 <adam_wespiser> yea, do a `stack install hoogle` and you can check on the cmd line
21:23:23 <pounce> oh, huh
21:23:28 <pounce> ive been hoogling in my browser
21:23:46 <adam_wespiser> that works too
21:24:30 <pounce> how do i turn a ShowS into a String, does application to "" work
21:25:36 <pounce> hum, or i could shows the rest of my things and compose them... that would probably be better
21:25:57 <adam_wespiser> yes, since `type ShowS = String -> String`, it should work
21:26:57 <pounce> ok got it to work, thank you!
21:27:50 <adam_wespiser> :)
