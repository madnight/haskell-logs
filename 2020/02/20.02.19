00:44:27 <dminuoso> @tell deni If you like I can give you some pointers on how to add logging seamlessly to servant handlers. It's a bit obscure, but it's certainly not difficult.
00:44:27 <lambdabot> Consider it noted.
00:55:23 * hackage fusion-plugin 0.2.0 - GHC plugin to make stream fusion more predictable.  https://hackage.haskell.org/package/fusion-plugin-0.2.0 (pranaysashank)
02:56:43 <merijn> So...I have a set of values where each value is associated with a (possibly overlapping) range of keys. What's a good data structure for letting me query for key K give me all values whose range(s) include K
03:04:10 <merijn> Oh, looks like I already have a package with an IntervalMap in my dependencies \o/
03:16:00 <limelier> hey guys, small question 
03:16:41 <limelier> im on ubuntu 19.10, and i was trying to set up some stuff to work with haskell in vscode. haskell-stack seems to be misbehaving, though, and i can't install stuff like hlint or intero
03:17:34 <limelier> https://gist.github.com/limelier/bb69f139a30c3a67c9d228b7bc297368 any ideas?
03:25:46 <ooo_miguel> Given something like : data A = W B | X | Y Int | Z String;  data B = U Int | V;  How can I enumerate all possible values of type A to a given "depth".. want to get something like [W (U 1), W V, X, Y 1, Z "foo"] here
03:26:17 <ooo_miguel> I already have some data-type that I want to enumerate like that
03:26:27 <ooo_miguel> the data A above is just a simplified example
03:28:06 <limelier> sorry, Internet cut out. hope I didn't miss anything 
04:04:23 * hackage jukebox 0.4.3 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.4.3 (NickSmallbone)
04:04:46 <aviD> limelier try it again that the stack error I get when I'm disconnected to from wifi
04:08:53 <limelier> oh, maybe it didn't like my hotspot. I'll try again on different Internet later
04:59:29 <sshine> limelier, I don't know if this is the case, but lts-15.0 was released just 3 days ago. maybe try 'stack install intero --resolver=lts-14.27'?
05:04:29 <limelier> sshine: this worked, thank you!
05:05:33 <sshine> limelier, I suspect this means you probably want to stick to GHC 8.6.x for your intero-based projects.
05:05:51 <sshine> limelier, (even though I don't have experience with intero, even ghcid is pretty stubborn about these things.)
05:06:18 <limelier> sshine, i don't really know what that means yet but i'll try, haha
05:06:31 <sshine> limelier, it just means you have to put 'resolver: lts-14.27' in your stack.yaml for your project, too. :)
05:06:37 <limelier> aight
05:07:49 <limelier> i'm guessing there's probably a way to update the packages once i'm able to do it, right?
05:08:34 <sshine> limelier, able to do what?
05:08:39 <limelier> able to, uhh
05:08:47 <limelier> install the 15.0 versions
05:10:39 <sshine> limelier, yes, you could just try and update the resolver in stack.yaml after a while. but depending on what you're doing, you probably don't really need to.
05:11:11 <limelier> alright, thank you for the help
05:12:19 <sshine> limelier, typically you want a newer resolver because the packages you work with have gone out of sync. and in this case, because GHC 8.8 is out. but my guess is you're not going to need any 8.8-specific features right away. :)
05:12:38 <limelier> i'm just learning haskell, really
05:12:43 <limelier> and i wanted to set up vscode to work nicely with it
05:12:58 <sshine> ok
05:13:08 <sshine> I haven't tried the devcontainers method that was announced recently.
05:14:26 <sshine> my Emacs LSP support is super funky. hints show up, but in a completely unreadable way. I kinda just went back to ghcid for now.
05:15:15 <sshine> it worked very nicely in VSCode, but for some reason, I can only accept using VSCode when I'm with a language like Java or C# or Elm.
05:16:33 <limelier> i'm just sort of piling these onto my editor https://dev.to/egregors/vscode-for-haskell-in-2020-5dn8
05:16:35 <limelier> seems reasonable
05:17:55 <limelier> though i ran into another problem after installed intero, trying to install the other packages i need (hlint, etc) - "Unable to load cabal files for snapshot" 
05:18:04 <sshine> ah yes, this was written Jan 30, 2020, and lts-15.0 was released Feb 16, 2020. :)
05:18:36 <sshine> I guess the tutorial should have had --resolver=lts-14 to avoid this.
05:19:20 <limelier> https://gist.github.com/limelier/bb69f139a30c3a67c9d228b7bc297368
05:20:27 <sshine> limelier, what's your $(stack --version)?
05:21:13 <sshine> I'm surprised if it isn't 2.1.3, but on the other hand, that command appears to work fine here.
05:21:24 <limelier> 1.7.1 x86_64, apparently
05:21:52 <sshine> ok, stack upgrade
05:22:16 <sshine> and make sure ~/.local/bin is in your PATH so that $(which stack) gives something like ~/.local/bin/stack afterwards.
05:22:19 <limelier> weird that the ubuntu repo would have an outdated version, but... i guess that's not surprising
05:22:40 <sshine> I think all package managers suffer from this curse.
05:23:27 <limelier> looks like after the upgrade i don't need to change the resolver anymore >.>
05:23:44 <sshine> the first thing you have to do when you get started with any programming language is: find out what the package manager is called, and decide if you want to install it manually or if you can install an outdated version of it via the system package manager and install a recent version of it using itself. :P
05:24:21 <sshine> some package managers are kind enough to check if they're up-to-date the first time you run them.
05:24:38 <limelier> i mean
05:24:52 <limelier> a lot of programming languages don't really have a package manager
05:25:17 <limelier> at least i'm pretty sure java, c/c++, and c# don't
05:25:42 <sshine> don't what?
05:25:48 <limelier> have one
05:25:55 <sshine> oh, right.
05:26:14 <limelier> maybe i just hang around the wrong crowd (of languages), lol
05:26:16 <sshine> I mean, for languages that have one and where it is the norm to use them.
05:26:27 <sshine> I think C# has a package manager. :)
05:26:37 <sshine> NuGet?
05:26:55 <limelier> oh, you might be right. i haven't used C# in quite a while, never really got that far with it
05:27:36 <yushyin> meson with its wrap system and wrapdb.mesonbuild is ok for c/c++, not really a package manager but close.
05:28:02 <limelier> im the kind of programming noob that has never even used anything other than STL with C++
05:28:12 <limelier> mostly school stuff
05:28:30 <limelier> i think that's gonna change this semester though since the java courses seem... surprisingly in-depth and up to date
05:32:23 <phadej> teaching Java in CS programmes is like teaching Matlab in Math programmes
05:32:33 <Rembane> An insult? 
05:32:37 <phadej> probably necessary, but not as introduction
05:32:51 <limelier> well, it wasn't an introduction
05:33:09 <boxscape> limelier Java has maven with its repository, not sure if it technically qualifies as a package manager but it's not much different 
05:33:18 <limelier> this is a course in the 4th semester
05:34:06 <limelier> oh shoot i'm dumb. i was just about to go off on how the course is modern enough to mention maven and gradle but i didn't figure that maven is basically a package manager. derp
05:36:20 <adsfadf> @pl reverse(init xs)
05:36:21 <lambdabot> reverse (init xs)
05:36:39 <adsfadf> @pl \xs -> reverse(init xs)
05:36:40 <lambdabot> reverse . init
05:36:49 <adsfadf> @pl \xs -> xs ++ reverse(init xs)
05:36:49 <lambdabot> ap (++) (reverse . init)
05:45:47 <ooo_miguel> can I somehow auto-derive a class later? someting like: data A = A deriving Show... versus data A=A; instance Show A deriving; ?
05:45:48 <merijn> So, I have this top level list of type "stuff :: Foo x => [(String, x)]", now in part of the code I just need the strings so I just do "map fst stuff" but then I get ambiguous type errors on the instance of Foo, despite said instance being irrelevant. Any good suggestions how I can avoid that nonsense?
05:46:09 <merijn> ooo_miguel: I'll take "What is standalone deriving?" for $100 :)
05:47:31 <yushyin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#stand-alone-deriving-declarations
05:47:52 <ooo_miguel> merijn: oh thanks. :)
05:48:20 <ooo_miguel> tell me your bank account!
05:58:26 <Rembane> merijn: The stupidest solution is to not put x there in the first place, is that possible?
05:59:13 <merijn> Rembane: Not without a lot of refactoring, which is why I haven't done that
06:01:59 <boxscape> ...unsafeCoerce? :)
06:03:42 <boxscape> actually it's not trivial even with unsafeCoerce
06:06:40 <Rembane> merijn: Got it. I was hoping for a Gordian knot. 
06:07:14 <Rembane> merijn: Can you hide the x using existential quantification? 
06:07:34 <merijn> Rembane: Right now I've "solved" it by defining a dummy type with a wrong instance of Foo so I can annotate with that type so it compiles but that is...icky
06:09:04 <Rembane> merijn: That's a lovely hack and I can totally see why you want a less icky solution.
06:09:22 <Lears> If the instance is actually irrelevant, then you can construct the Strings and xs separately in the first place and zip them up later.
06:09:43 <merijn> I could annotate with an actual type with the proper instance, but those are all defined in modules depending upon this one, so then I'd have to struggle to break the cycle
06:10:12 <merijn> Lears: Not really, because the pairs are defined as pairs in a bunch of places so I can never get them separately
06:10:44 <merijn> Or rather, splitting them up is 1) a lot of code churn splitting all the independent definitions and 2) actually breaks the nice link between name and value it was intended to guarantee
06:10:54 * hackage tar-bytestring 0.6.2.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.2.0 (maerwald)
06:11:12 <boxscape> Okay this is a very icky solution as well but to expound on my previous point it *is* possible to construct a Data.Constraint.Dict, unsafeCoerce it to a Foo instance, match on it, and use stuff
06:59:53 * hackage criterion 1.5.6.2 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.5.6.2 (ryanglscott)
07:02:56 <argent0> hi. Regarding fused-effects, how can I code a "state effect" with a diffrente interface? Eg: https://gist.github.com/argent0/09e432cd9d6083a4ac991e36ada001c0. In other words: what should hmap, thread and alg look like?
07:37:34 <sacoku_> close
08:11:24 * hackage base64-lens 0.3.0 - Optics for the Base64 library  https://hackage.haskell.org/package/base64-lens-0.3.0 (topos)
08:22:31 <ezzieygu1wuf> if I have `newtype MyIndices = [Int]`, what must I do such that `length someMyIndices` works as expected? I tried adding `deriving (Foldable)` to the newtype declaration but received an error "Cannot derived well-kinded instance..."
08:22:50 <merijn> ezzieygu1wuf: That's a syntax error
08:23:01 <merijn> Or should be, at any rate
08:23:16 <merijn> ezzieygu1wuf: There's no constructor there
08:23:50 <merijn> ezzieygu1wuf: And Foldable requires a type of kind "* -> *", your newtype has kind *
08:24:15 <ezzieygu1wuf> I meant `newtype MyIndices = MyIndices [Int]`
08:24:47 <ezzieygu1wuf> hm, is there something else I can derive that will provide the expected behaviour?
08:24:52 <merijn> ezzieygu1wuf: Anyway, why not just define your own length?
08:25:23 * hackage bzip-signature 0.1.2.0 - Backpack signature for BZip compression  https://hackage.haskell.org/package/bzip-signature-0.1.2.0 (vmchale)
08:25:51 <ezzieygu1wuf> merijn: just trying to avoid reinventing the wheel
08:27:55 <ezzieygu1wuf> I guess I could just pattern-match to un-MyIndices the list of Int...
08:31:26 <Zemyla> Oh, if you were using a one-letter name for a qualified import of Data.Sequence, and you were already using S for Data.Set, which would you pick?
08:32:13 <slack1256> sqlite-simple vs direct-sqlite? what is the goto option?
08:32:25 <solonarv> Zemyla: I guess Q, if I really had to? but I'd just import it as Seq
08:32:39 <solonarv> (and import Data.Sequence.Seq unqualified)
08:32:54 * solonarv doesn't like single-letter qualified imports
08:32:59 <Zemyla> Yeah, I use Q too.
08:38:23 <jle`> ezzieygu1wuf: you can't use 'length' because it only works for parameterized types
08:38:23 * hackage composite-aeson 0.6.2.0 - JSON for Vinyl/Frames records  https://hackage.haskell.org/package/composite-aeson-0.6.2.0 (dridus)
08:38:29 <merijn> slack1256: sqlite-simple is just a higher level wrapper around direct-sqlite
08:38:35 <jle`> ezzieygu1wuf: so one thing you can do is write `newtype MyIndices a = MyIndices [a]`
08:38:42 <jle`> deriving Foldable
08:38:45 <jle`> and that would work
08:38:52 <jle`> remember the type of 'length':
08:38:54 <jle`> :t length
08:38:55 <lambdabot> Foldable t => t a -> Int
08:39:24 * hackage composite-swagger 0.6.2.0, composite-opaleye 0.6.2.0, composite-ekg 0.6.2.0, composite-base 0.6.2.0, composite-aeson-refined 0.6.2.0 (dridus)
08:39:26 <jle`> fundamentally length will only work on osmething where you can have `t a` of it.  So you'd have to be able to have `MyIndices a`. in your original type, that wouldn't make sense
08:40:25 <jle`> but probably the better way is to define your own length function that handles the unwrapping explicitly, yeah
08:42:14 <slack1256> merijn: Thanks
08:42:30 <slack1256> That's why it has higher DLs.
08:43:35 <merijn> slack1256: So I'd say "use sqlite-simple", since it actually exposes the direct-sqlite connection should you ever need to drop down to something using direct-sqlite
08:43:55 <slack1256> Cool!
08:48:54 * hackage git-annex 7.20200219 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20200219 (JoeyHess)
09:38:10 <MrET> Hello ppl!! OMG there is free money and Bitcoin here!! : https://freebitco.in/?r=599908
09:38:20 <limelier> seems legit
10:45:54 * hackage fx 0.4 - Revamped effect system  https://hackage.haskell.org/package/fx-0.4 (NikitaVolkov)
11:05:42 <maerwald> oh, another effects system? :>
11:06:25 <dsal> It's revamped.
11:24:12 <maerwald> how do you map a getter into a functor? Basically like `mapped` and not a Prism
11:35:58 <jle`> maerwald: do you mean like fmap (view theGetter) ?
11:36:11 <jle`> or like mapped . theGetter
11:36:17 <Uniaika> < maerwald> oh, another effects system? :> // Those things pop like YavaScript frameworks…
11:37:27 <jle`> we'll look back on this era fondly in five years
11:38:00 <jle`> the wild west of effects systems
11:38:41 <jle`> 'i fought alongside your father in the effects wars'
11:39:25 <maerwald> jle`: yeah, basically like: fmap (view getter) (view getter x)
11:40:24 * hackage lol 0.7.0.0 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.7.0.0 (crossroads1112)
11:42:07 <maerwald> Uniaika: maybe we should have a hackage for fun projects and one for things that should actually work :P
11:42:42 <Uniaika> isn't that hackage and stackage? :P
11:42:57 <maerwald> I knew you would say that... but let's say something more sane
11:43:29 <hyperisco> I hear good things about eff
11:43:39 <maerwald> jle`: the only ways I see is to use Prisms, explicit fmap (like above) or `non`
11:43:53 <maerwald> hyperisco: the one heavily based on typeclasses?
11:44:16 <hyperisco> I only hear. Haven't used it.
11:45:54 * hackage lol-cpp 0.2.0.0 - A fast C++ backend for <https://hackage.haskell.org/package/lol lol>.  https://hackage.haskell.org/package/lol-cpp-0.2.0.0 (crossroads1112)
11:48:21 <koz_> Hi jle` ! How's the PhD writing treating you?
11:48:43 <Uniaika> I'm going to wait until *at least* 8.12 before using an effect system…
11:48:54 * hackage lol-apps 0.3.0.0 - Lattice-based cryptographic applications using <https://hackage.haskell.org/package/lol lol>.  https://hackage.haskell.org/package/lol-apps-0.3.0.0 (crossroads1112)
11:48:55 <merijn> koz_: Man...talk about committing social faux pas... >.>
11:49:09 <koz_> merijn: ??
11:49:18 <Uniaika> koz_: *never* ask a PhD student how it's going!
11:49:20 <Uniaika> :o 
11:49:21 <koz_> LOL
11:49:26 <Uniaika> (because it's never going well)
11:49:28 <koz_> I'm a former PhD student myself.
11:49:36 <merijn> koz_: Then you should know man!
11:49:39 <koz_> Should really know better, yeah.
11:49:47 * koz_ hangs head in shame.
11:51:10 <Uniaika> koz_, to make atone for your sins, the People's Tribunal of the Land of Haskell sentences you to a complete reading of phdcomics.com
11:51:14 <Uniaika> argh
11:51:16 <Uniaika> -make
11:51:33 <koz_> Uniaika: LOL
11:51:38 <koz_> You assume I haven't already.
11:52:01 <Uniaika> koz_: if you did, you'd knew that one shall never ask a PhD student about how it's going :P
11:52:11 <Uniaika> you saw the words and laughed at the silly pictures
11:52:19 <Uniaika> but did you *really* read it?
11:52:19 <merijn> In fact, this entire conversation is giving me anxiety >.>
11:52:28 <Uniaika> merijn: ah, sorry mate
11:52:29 <koz_> Yeah, we should stop and talk about something else.
11:52:34 <Uniaika> let's talk about something else
11:52:49 <Uniaika> who's excited for 8.12?! :D
11:52:51 <koz_> Any news on when the next GHC will hit?
11:53:03 <koz_> Or have I missed that boat?
11:53:07 <maerwald> nah
11:54:34 <koz_> I'm looking forward to it.
11:55:09 <Uniaika> I just got 8.8 on stackage so honestly I'm good :P
11:55:37 <koz_> Yeah, I'm _less_ looking forward to the 'update all my libraries with new bounds'.
11:55:56 <maerwald> you shouldn't have upper bounds to begin with :P
11:56:09 <koz_> maerwald: Lol.
11:56:16 <maerwald> I'm only half joking.
11:56:21 <koz_> maerwald: I realized that.
11:57:31 <Uniaika> maerwald: I'm interested in your reasoning. Is it specific to PVP?
11:58:14 <maerwald> I think PVP doesn't work very well. One thing is that you can't distinguish between "I know this doesn't work with later versions" vs "I just added this upper bound, because I don't know better"
11:58:30 <maerwald> Semver has similar problems. And ppl work around it with tooling that auto-bumps and whatnot
11:59:31 <maerwald> the job of an ecosystem isn't to never have build failures. That's my opinion. If you need that, create "channels"
11:59:34 <merijn> maerwald: Oh, you actually can now
11:59:50 <merijn> maerwald: The caret bound notation was introduced for that
12:00:16 <maerwald> huh?
12:00:33 <merijn> maerwald: Have you seen the ^>= bound notation yet?
12:00:40 <maerwald> Yes, it's sugar for >= x.y.z && < x.(y + 1)
12:00:48 <fizbin> Uniaika: So you aren't seeing any issues with stackage lts 15.0 ?
12:00:50 <maerwald> I don't see how that solves the semantic difference
12:01:08 <merijn> maerwald: It's not sugar, it's intended to mean "this works with the PVP API of this number"
12:01:22 <maerwald> Yes and the solver won't allow newer bounds
12:01:29 <merijn> maerwald: The goal (long-term) is to let allow-newer only relax *those* bounds and not explicit < bounds
12:01:31 <maerwald> The solver has no idea why you added that upper bound
12:01:38 <maerwald> Ah
12:01:47 <maerwald> But that's not implemented right now, right
12:01:50 <merijn> maerwald: So you can use < to signal "definitely doesn't work"
12:01:51 <fizbin> I may jump to lts 15+ just so I don't have to keep pulling in network-3.1 as an exception.
12:01:56 <merijn> maerwald: It might be already? I'm not sure
12:02:02 <maerwald> not sure that will make it more usable
12:02:13 <maerwald> most ppl will not know the difference 
12:02:30 <merijn> maerwald: "For instance, --allow-newer’s ^-modifier allows to relax only ^>=-style bounds while leaving explicitly stated <-constraints unaffected."
12:02:38 <merijn> maerwald: Seems to imply it's already implemented
12:02:54 <Uniaika> fizbin: nope
12:03:26 <merijn> maerwald: But this is the kinda stuff that's still mostly in the not quite as well documented dogfooding stage, I think
12:03:38 <maerwald> so that lives completely outside of the PVP specification it seems
12:03:44 <Uniaika> fizbin: I don't know about 'network', but I heard 'time' got updated ;)
12:04:25 <maerwald> https://pvp.haskell.org/ not in version syntax
12:04:48 <fizbin> Uniaika: In lts-15.0, stack jumped to network-3.1.1 instead of the 2.8.x.x versions they used through all the 14.* lts.
12:05:19 <maerwald> Uniaika: another reason is https://github.com/haskell/pvp/issues/10
12:05:35 <fizbin> We've been on network >= 3 for quite some time because of some nasty bugs in earlier versions that could leave our server dead and unresponsive.
12:06:10 <maerwald> see there are two kinds of breaking changes: API visible and runtime visible
12:06:43 <maerwald> this is especially a problem with lower level libraries
12:07:41 <maerwald> And then in the end: more ways to define how you broke your API means... you're gonna keep breaking it :P
12:07:58 <maerwald> While the solution is: don't break it.
12:08:09 <merijn> maerwald: It depends
12:08:12 <fenedor> I remember, there was some relatively recent comparison of Haskell Database libraries, can someone remember the name of that article?
12:08:50 <merijn> fenedor: I haven't seen in, but I can assume it basically said "use postgres-simple or sqlite-simple" :p
12:09:41 <merijn> opaleye is ok I've heard, iff you use postgres. And Selda looks like it might be useful, but in general I've learned my lesson and will probably stick to the -simple's next time
12:10:12 <fenedor> merijn, I remember that the conclusion was that all orm impls were lacking. However, I would like some haskell features, like type safe queries and stuff like that. Also dont want to write basic boilerplate queries by hand
12:10:48 <merijn> fenedor: Yeah...that's exactly the reason why I used persistent and am now telling you to just use -simple and write the boilerplate by hand :p
12:11:08 <Uniaika> maerwald: I am deeply sorry but I don't have the bandwidth right now to process the text :)
12:11:23 <Uniaika> (it's 9PM here)
12:11:29 <maerwald> Here too
12:11:40 <maerwald> Write a haskell parser to parse it
12:11:41 <maerwald> :p
12:13:02 <fenedor> merijn, I have read that persistent is lacking. Hmpf, that sounds not very promising. What are people doing that use haskell in production? I can not imagine that they copy paste the basic insert and select statement for each datatype in a database
12:13:04 <nshepperd1> orms are bad
12:13:28 <nshepperd1> just write SQL by hand
12:14:51 <nshepperd1> (when is haskell getting native multiline strings?)
12:14:58 <Uniaika> maerwald: hey, I just found out that one of my old apps was using VueJS for the frontend :P
12:15:03 <Uniaika> I *wasn't* expecting this
12:15:19 <Uniaika> nshepperd1: Ask Santa for Haskell2030 :>
12:16:06 <fenedor> meh, they cant be *that* bad since they are industry standard in at least java. And again, maintaining easy to write, boilerplate queries does not sound very nice
12:16:49 <merijn> fenedor: According to Github I'm currently a top 10 contributor to persistent on account of fixing/extending persistent-sqlite to do what I want because migrating away from it too something done by hand in sqlite-simple is too much work now >.>
12:17:12 <nshepperd1> Java is where all harmful abstractions come from though
12:17:26 <merijn> nshepperd1: 1) there are quasiquoters for that 2) are you aware that you can escape newlines to write long strings across multiple lines? :)
12:17:48 <Cale> nshepperd: You can use QuasiQuotes for multiline strings. I also have a little quasiquoter for use with postgresql-simple that lets me write ?foo in the string, and it will insert a ? in that place, and add the identifier foo to a tuple which gets generated alongside the string
12:18:07 <fenedor> merijn, does that mean you are adding all the features to make persistent viable? *,*
12:18:08 <merijn> Cale: Does postgres not support named wildcards?
12:18:43 <merijn> fenedor: No, I'm still lacking quite a bit of things I'd like but can't afford/justify implementing
12:19:21 <Cale> merijn: I'm not sure, but in this case, the identifier is a Haskell identifier
12:20:11 <merijn> fenedor: Additionally, I'm doing A LOT of stuff using persistent's rawQuery, i.e. just handwriting SQL
12:20:51 <merijn> fenedor: I've effectively implemented my own (somewhat inefficient) wrapper/querying system, it would've been nicer/better if I had done that using SQL directly
12:21:13 <fenedor> I can see the reason for handwriting SQL, it makes a lot of sense, unless you can encode the whole sql into haskell somehow. However, I would appreciate some boilerplate reduction
12:21:54 <merijn> fenedor: tbh, implementing your own boilerplate reduction is rather simple, imo
12:22:03 <Cale> fenedor: If you want to embed all of SQL into Haskell, have a look at beam
12:22:05 <fenedor> you are even #9 contributor :)
12:22:29 <merijn> Cale: Just looking at the type signatures in beam's documentation makes me want to claw my eyes out
12:22:32 <Cale> hahaha
12:22:39 <merijn> Screw that shit
12:23:04 <[exa]> fenedor: hand-generating SQL in some practical way is still better than ORM
12:23:42 <fenedor> [exa] I am afraid of introducing bugs and doing stuff improperly
12:23:55 <Cale> The thing which bothers me about beam moreso than the type signatures is the fact that after all that, it doesn't even construct a proper syntax tree
12:24:22 <fenedor> merijn, how would you implement your own boilerplate reduction? based on type-classes, or TH, or something?
12:24:57 <Cale> (well, looking at it again, maybe someone has addressed that now, hmm!)
12:25:52 <Cale> Ah, there's a separate AST with instances of the type classes, and then an instance for a wrapper around ByteString.Builder
12:25:57 <merijn> fenedor: I'd probably go for typeclases or (probably better) explicit encoder/decoders (to ease migrations)
12:26:27 <Cale> It was kind of funny that they have all these syntactic types, and they're all just glorified ByteStrings :D
12:26:47 <fenedor> merijn, so, a bit the elm approach? How does reduce boilerplate for e.g. a simple insert of a value into the db?
12:27:58 <merijn> fenedor: You can define like "Encode a" type and implement a single "insert :: Encode a -> a -> Sql ()" or whatever. And then start out with a really simple encoder that just inserts a bunch of wildcards in a query or something
12:29:37 <merijn> fenedor: Along those lines I have a Query datatype and most queries (except some trivial ones) are defined in terms of those. Started out as basically "query text + query parameters" but has grown more complex over time: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Query.hs#L53-L61
12:30:30 <Ripple> Hello, learning Haskell currently looking at functors. One of the functor laws is fmap (f . g)  ==  fmap f . fmap g. This looks like algebra where multiplication distributes over addition. Is this a 'superficial similarity' or is it more fundamental? Can you 'factor out' fmaps in composition?
12:31:20 <merijn> Ripple: Assuming the Functor implementation is, indeed, lawful you can factor out fmaps, yes
12:32:40 <Cale> You usually want to combine fmap f . fmap g -> fmap (f . g) because that involves one fewer traversal of whatever data structure is involved.
12:33:29 <fendor> merijn, thx, that looks usable. 
12:33:51 <fendor> does usage of TH make sense to e.g. typecheck queries?
12:33:54 <Ripple> Thanks merijn. So, not only algebraic datatypes, but there is a whole 'algebra of types'. That will be interesting to look at next. : )
12:35:23 <Ripple> Cale: Yes, I realised it reduced the traversals. Now I realise (even more) that the "lawfulness" of 'things' enable more powerful compositions.
12:36:38 <Cale> Ripple: Yeah, so even if you don't know which Functor instance your code is going to be used with, you can make that refactoring and not have to worry
12:37:09 <argent0> how would one extend a fused-effect state? To read the state only through some funcions
12:37:10 <Cale> (though that's a pretty limited example of the usefulness of type classes having laws)
12:39:10 <Cale> argent0: I'm not all that familiar with fused-effects, but what is the type of the thing you want?
12:39:28 <Cale> (I'm not sure I understand your question)
12:39:30 <argent0> for example, here is what I've come up with: https://gist.github.com/argent0/09e432cd9d6083a4ac991e36ada001c0 Cale
12:39:45 <Ripple> And a quick search (with better terms ; ) shows that not only sum and product types, but functions are 'exponentiation' and recursive datatypes are 'Taylor series'. That will give me something to do. : )
12:44:24 * hackage Chart-fltkhs 0.1.0.5 - A backend for the Chart library for FLTKHS  https://hackage.haskell.org/package/Chart-fltkhs-0.1.0.5 (empowerg)
13:21:56 <argent0> made it work: https://gist.github.com/argent0/09e432cd9d6083a4ac991e36ada001c0
13:39:59 <hseg> am trying to define a typeclass FiniteSupport :: (* -> * -> *) -> Constraint with method supp :: p a b -> [a]. Two problems: Would like to make Map an instance, but would need to add a Ord a constraint -- unclear how to do so
13:41:50 <hseg> also, would like to write a default signature supp :: (Finitish a, Ring b) => p a b -> [a] that filters the domain of (f::p a b) by whether f evaluates to 0 
13:42:16 <hseg> but again, class gets the wrong type for this to be possible
13:43:29 <hseg> ... nm, rereading the material on constrained typeclasses shows this is possible with an associated type parametrized over p
13:44:14 <olligobber> hseg, Map.keys :: Map k a -> [k] does not require Ord k
13:44:38 <hseg> oh
13:44:48 <hseg> well, i was overly pessimistic
13:47:11 <hseg> btw, is Data.Map guaranteed to represent finite maps?
13:47:23 <solonarv> another possibility would be to change the class head to something like: class FiniteSupport f k | f -> k where support :: f a -> [k]
13:47:47 <solonarv> it's "guaranteed" in the sense that it will silently break if it ever has more than maxBound :: Int entries
13:47:52 <solonarv> at least that's what the docs say
13:48:23 <hseg> hrm
13:48:37 <hseg> not exactly what i'm after, but good enough for now
13:49:01 <hseg> frankly, am less than happy with this project
13:49:17 <solonarv> it's also spine-strict, so a map of that size can't possibly fit into memory anyway
13:49:23 <solonarv> so you should never actually run into it
13:49:41 <olligobber> unless you have more than 2^64 bytes of memory...
13:49:58 <hseg> have been bumping into infelicity after hasochism after torturous numeric hierarchy :/
13:50:43 <olligobber> 16 exabytes of ram lol
13:50:47 <solonarv> I'm going to sensibly assume that by the time machiens with that much memory are available, they will not have a larger word size than 64 bits anyway
13:52:10 <solonarv> by the time you get to 2^256 bytes of memory you start to run into problems with funny descriptions like "your coputer doesn't fit into the observable universe" ;)
13:53:17 <merijn> solonarv: I'd want more than 64 bits of address space even if I didn't have more than 64 bits worth of actual data
13:53:59 <solonarv> but I'm not talking about address space, I'm talking about the amount of memory you are actually using
13:54:02 <hseg> any reason to use associated types over type families?
13:54:17 <solonarv> associated types *are* type families
13:54:29 <solonarv> just with a bit of syntax sugar sprinkled on top to tie them to a type class
13:54:56 <hseg> ok. what sugar? what do i lose moving to the top level?
13:55:33 <merijn> solonarv: You said you'd assume there word sizes wouldn't be bigger than 64 bit, but that'd be a problem if you had address spaces bigger than 64 bits
13:55:52 <merijn> hseg: Nothing, just syntax
13:55:52 <solonarv> I think it's just the ability to write instances of the type family inside instance declarations for the type class
13:56:20 <solonarv> possibly GHC will warn you if you forget to write an instance for an associated type (but it can't possibly do that for a standalone type family)
13:56:34 <hseg> ah. so keeping instances together, warnings, and the ability to write defaults?
13:56:36 <solonarv> merijn: no, I said the word size surely *would* be greater than 64bit
14:00:33 <merijn> solonarv: Perhaps you meant to say that, but you didn't ;)
14:04:35 <solonarv> oh indeed, no idea how that "not" slipped in there
14:06:04 <hseg> any way to import multiple libraries at once in ghci?
14:07:32 <hseg> also, brittany seems unwilling to touch class code
14:07:50 <hseg> which is annoying - i installed a formatter for a reason, dammit
14:15:04 <solonarv> hseg: :m + Module1 Module2 Module3 ...
14:15:24 <hseg> any reason GHCi doesn't abort a computation on CTRL-C? just realized a typo caused an infinite loop, would want to abort, fix, reload
14:15:28 <hseg> ty
14:16:43 <maerwald> I'm trying to write a quasi quoter for versions, but I'm failing https://git.io/JvBgn
14:18:50 <glguy> maerwald: Is the right 'lift' in scope there?
14:19:14 <maerwald> lol, you are right
14:19:25 <merijn> maerwald: Why are you writing lift instances yourself?
14:19:38 <maerwald> what else to do?
14:20:08 <merijn> maerwald: As of GHC 8.0 there's -XDeriveLift
14:21:22 <maerwald> merijn: those are types from a library
14:21:58 <solonarv> StandaloneDeriving to the rescue!
14:22:14 <merijn> ^^
14:22:34 <glguy> Also this exists now: instance Lift Text -- Defined in ‘Data.Text’
14:23:11 <glguy> Instead of defining the orphan instance you're better off just defining a local implementation of lift you need if you're just using it on line 26
14:23:56 <maerwald> but my code already works :P
14:24:06 <glguy> myLift (Str t) = [| Str t |]; myLift (Digits w) = [| Digits w |]
14:24:34 <glguy> Well, I guess you do use that instance in the instance you wrote for Version
14:24:41 <glguy> back to derive and standalone deriving 
14:25:01 <glguy> lift (Version {..}) = [| Version {..} |] is cute, though :)
14:25:15 <maerwald> People have complained about my overuse of RecordWildCards
14:25:46 <glguy> and while I'm providing help that doesn't change the behavior of your code: (\s -> quoteExp' . T.pack $ s)    is just  quoteExp' . T.pack!
14:26:19 <maerwald> That's a concious choice.
14:26:21 <glguy> Left e  -> error . show $ e -- should be using fail
14:27:12 <maerwald> interesting, what's the difference for TH code?
14:28:01 <glguy>   fail s     = report True s >> Q (Fail.fail "Q monad failure")
14:28:09 <maerwald> the compile-time message is slightly different, but otherwise the same
14:28:15 <glguy> It integrates into template Haskell's reporting
14:29:15 <glguy> and it means that (mkV some_stuff) `seq` ()  doesn't blow up just because it got evaluated
14:33:28 * hackage docker 0.6.0.3 - An API client for docker written in Haskell  https://hackage.haskell.org/package/docker-0.6.0.3 (denibertovic)
14:37:35 <maerwald> I'm starting to like quasiquoters
14:37:53 <maerwald> also lets me avoid OverloadedStrings
14:38:18 <hseg> maerwald: oh, why?
14:38:24 <maerwald> why what?
14:38:44 <hseg> what's so nice about qqs?
14:38:57 <hseg> haven't had a lot of experience with them
14:38:59 <maerwald> Good for smart constructors
14:39:08 <hseg> would like to hear an elevator pitch
14:39:11 <maerwald> where you know it must work at compile time
14:39:19 <hseg> ? how do they give you smart constructors?
14:39:28 <maerwald> You have to define them
14:39:38 <hseg> sure, but how do they help
14:40:00 <solonarv> they run at compile time, which means the checks a smart constructor usually makes can be done at compile time as well
14:40:35 <maerwald> https://github.com/commercialhaskell/path/blob/master/src/Path/Include.hs#L194 is an example
14:40:46 <solonarv> suppose you want to write bytestring literals but don't want to have any characters > \255
14:40:50 <hseg> oh... so you optimize the runtime checks away
14:41:12 <maerwald> you just await an annoying fromJust for literal values you pass to a smart constructor
14:41:20 <solonarv> with a QQ you can check this at compile time, without a QQ (and yes, also with OverloadedStrings) you only get the error at runtime
14:41:20 <maerwald> s/await/avoid/
14:41:54 <hseg> nice
14:43:03 <hseg> hrm. am having an impedance mismatch in my design
14:43:12 <maerwald> Imagine OverloadedStrings failing at runtime... lol. But I think that was actually proposed for the ByteString instance, which is awful anyway
14:43:48 <solonarv> with the type signature fromString has, there's just no good solution
14:44:03 <maerwald> removing it is a good solution
14:44:07 <solonarv> you either have literals that fail at runtime, or you have literals that do subtlly wrong things
14:44:11 <hseg> otoh, want to use Map like (->) -- that's what Representable is for. otoh, want to express the fact that Map, unlike (->) has finite domain
14:44:25 <hseg> (indeed, want the stronger constraint that Map has finite support)
14:44:36 <solonarv> finite support, you mean - the domain is not necessarily finite
14:44:45 <hseg> right
14:44:56 <solonarv> 'Map Integer a' has infinite domain after all
14:45:05 <hseg> right, misspoke
14:45:38 <hseg> but so i have a class FiniteSupport :: (*->*->*) -> Constraint
14:46:46 <hseg> and there's a class Representable :: pi t. (Rep t -> *) -> Constraint (iiuc the quantifiers correctly)
14:46:51 <maerwald> There's also a quasiquoter package for regexes :>
14:47:24 <hseg> nice. so you save the regex->dfa compilation time
14:47:44 <maerwald> https://hackage.haskell.org/package/regex-tdfa-quasiquoter-0.2.1.0/docs/Text-Regex-TDFA-QuasiQuoter.html#v:re
14:47:50 <hseg> btw, can't find where Map's Representable instance is defined
14:51:16 <solonarv> hseg: that's because Map doesn't have a Representable instance
14:51:29 <solonarv> Map k a is the same as k -> Maybe a
14:51:44 <solonarv> but Representable wants 'Rep f -> a'
14:51:46 <hseg> ...
14:51:48 <hseg> dammit
14:52:17 <hseg> ok, ok. can still deal with this
14:52:49 <hseg> that impedance mismatch is what i wrote eval :: p a b -> (->) a b for
14:53:10 <hseg> with instances where p ~ (->), p ~ Map
14:53:18 <hseg> (given appropriate constraints)
14:56:28 <hseg> ok, and i can use the (->) instance in this code consuming types with finite support + an eval instance for Representables to be able to use Representables
14:56:33 <hseg> so this works out ok
15:00:37 <hseg> nm, spoke too soon
15:01:03 <hseg> we'll see if i even want this later
15:09:11 <hseg> ... ugh. so either i reimplement Representable with the exact design i need, or i try to shoehorn Map into an instance. problem: instance i'd want would have index :: Ring a => f a -> Rep f -> a 
15:09:27 <hseg> which doesn't work
15:10:34 <hseg> reason i want to work with Representable instead of directly with Map: so that i can change the exact choice of variant of ->
15:13:03 <hseg> ofc, if i'd track how many entries my map has, could say Rep (Map k n) = n
15:13:09 <hseg> but that way lies madness
15:14:42 <hseg> ... ofc, i could always replace Map k v by Vector (k,v) 
15:15:01 <hseg> but that still doesn't solve my problem
15:16:55 <hseg> and since i'm expecting my maps to be rather sparse, do not want to use a Vector v with an iso k ~ Integer
15:18:24 * hackage serverless-haskell 0.10.1 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.10.1 (AlexeyKotlyarov)
15:19:01 <hseg> morally, Map k v ~ k -> Maybe v ~ Pointed v => k -> v, but even were i to be able to do that, would still want support :: Map k v -> [k] because it'd be much more sparse
15:21:56 <hseg> hrm. what about data MapFiniteSupport k v where MFS :: Pointed v => Map k v ?
15:22:58 <hseg> could shamelessly claim Rep (MFS k) ~ k, no?
15:23:32 <hseg> ... no. tabulate/index wouldn't be able to use the constraint
15:23:37 <hseg> *sigh*
15:23:53 <hseg> hasn't *anyone* wanted something like this before?
15:24:23 * hackage hpc-lcov 1.0.0 - Convert HPC output into LCOV format  https://hackage.haskell.org/package/hpc-lcov-1.0.0 (leapyear)
15:25:13 <hseg> like, there is http://hackage.haskell.org/package/universe/docs/Data-Universe.html, but that only covers finite *types*
15:25:27 <hseg> not arrows with finite support
15:27:58 <jle`> koz_, Uniaika, merijn: haha, it's somewhat of a meme now http://phdcomics.com/comics/archive.php?comicid=47
15:28:09 <jle`> but i don't mind the question in this case, i'm pretty much wrapping up :)
15:28:59 <hseg> jle`: congratulations!
15:29:05 <jle`> thank you!
15:30:17 <koz_> jle`: LOL, and congrats!
15:30:50 <jle`> that comic has a popularity index of 4811 apparently http://phdcomics.com/comics/most_popular.php
15:31:09 <hseg> ... they actually kept track of that
15:31:47 <jle`> well, it makes sense to keep some metric of popularity. the funny thing is that they publish it
15:31:59 <jle`> but i guess transparency is key
15:32:00 <jle`> koz_: thanks :)
15:33:18 <hseg> only just noticed the emergency button. hilarious way of ensuring accesssibility
15:33:24 <hseg> + useful
15:33:28 <hseg> i guess
15:34:25 <hseg> oh wait. the Pointed constraint is a red herring, can add that to the instance context for Representable
15:34:38 <hseg> in fact...
15:35:02 <hseg> dammit
15:35:21 <hseg> the wrong parameter is constrained for that to work
15:36:16 <hseg> + would somehow need to incur an Ord k constraint to be able to use findWithDefault
15:36:28 <jle`> Map is weird
15:36:33 <jle`> from a mathematical standpoint
15:36:46 <jle`> it pretends to act like it's contravariant on k
15:36:55 <jle`> but then we have things like M.keys
15:37:00 <jle`> er, M.mapKeys
15:38:18 <hseg> yeah, that makes little sense theoretically
15:38:52 <jle`> it's hard to really nail it down, other than just what it literally is -- a univalent relation
15:39:11 <hseg> right
15:39:24 <pikajude> hey, isn't there a library somewhere that generates import statements for every file in a directory?
15:39:36 <pikajude> or am i thinking of hspec-discover?
15:39:51 <hseg> but i'm seriously at wit's end here -- how do i represent maps of finite support?
15:40:10 <jle`> hm, isn't Map already a map of finite support?
15:40:10 <hseg> or is my design wrong? am trying to implement Laurent polynomials
15:40:16 <hseg> yes
15:40:37 <hseg> except i want to hide the fact i'm using Map
15:40:46 <hseg> thought of using Representable
15:40:53 <hseg> but ofc that's the wrong interface here
15:41:04 <jle`> well, what sort of interface do you want to expose?
15:41:15 <pikajude> is there something like hspec-discover but just for modules instead
15:41:17 <pikajude> that would be cool
15:41:22 <jle`> you can just have it be a newtype wrapper over a IntMap Double if you are really want to hide the mapness
15:42:27 <hseg> some variant of {support, fromFunc, eval}
15:42:45 <jle`> fromFunc as in, from a literal Double -> Double ?
15:42:56 <hseg> right, that's obviously wrong
15:43:40 <hseg> but don't know what the right type i'm looking for here is
15:44:01 <jle`> the right type will depend on what you are using it for
15:44:29 <jle`> newtype wrapper over Map will get you support, eval
15:44:47 <hseg> my test case for the right semantics is: f * g = fromFunc $ \m -> sum [eval f k * eval g l | k <- support f, l <- support g, k <> l == m]
15:45:32 <hseg> ... i suppose i could replace fromFunc by fromList in the required interface
15:45:38 <jle`> fromFunc is not going to work because there are Double -> Doubles that aren't encodable as Laurent polynomials
15:46:26 <jle`> substitute Double for your field of choice
15:47:36 <hseg> and then have something like f * g = fromList . map (sum . map fst) .  groupBy snd $ [ (eval f k * eval g l, k <> l) | k <- support f, l <- support g] 
15:48:48 <hseg> that looks like it can work
16:11:44 <hseg> ... ofc, that map should be bimap (fromJust.getFirst) getSum . foldMap (\(k,v) -> (First (Just k), Sum v))
16:11:49 <hseg> yeesh that's ugly
16:11:55 <Jonathan56> How would one `map` a table in the `hashtables` package?
16:12:08 <Jonathan56> \/ mutate
16:12:34 <Axman6> is it a Functor?
16:12:51 <Jonathan56> fromList then toList sounds inefficient.
16:13:02 <Jonathan56> No, it is not a functor.
16:13:08 <Axman6> also you almost certainly don;t want to use that package. look at the unordered-containers package, that's the go to for hashtable like things
16:13:52 <hseg> is there no Foldable f => (a -> b) -> (a -> c) -> f a -> (b,c) ?
16:13:58 <Jonathan56> I was actually looking for an IO table.
16:14:36 <Axman6> hseg: that's just fmap with more steps
16:14:43 <Axman6> Jonathan56: why?
16:15:10 <hseg> Axman6: ... no, note that's not f (b,c) in the result
16:15:17 <Jonathan56> Because the code is necessarily in IO anyway.
16:15:39 <hseg> but yeah, it's just \bp cp -> foldMap (bp &&& cp)
16:16:31 <Axman6> Jonathan56: that doesn't sounds like a good enough reason to me
16:16:32 <hseg> ... wonder if Foldable has fusions for (,) like it has for eg Sum/Product/Any/All
16:16:33 <Jonathan56> It is for a cache system to cache images which are loaded off of the disc.  Since it takes IO to actually load the image, it seems reasonable to allow IO to load it from the hashtable.
16:16:40 <Axman6> Jonathan56: are you currently learning Haskell?
16:16:50 <Jonathan56> Axman6: I expected you to say that...
16:17:14 <Jonathan56> No, I would say I know Haskell.
16:17:43 <Jonathan56> But, I cannot say I am an expert...
16:17:50 <Jonathan56> (:
16:19:46 <hseg> hrm. annoying that i can't tell ghc "fold this via this newtype's instance"
16:19:57 <hseg> so i'm stuck wrapping/unwrapping the newtype manually
16:20:13 <Axman6> :t ala
16:20:15 <lambdabot> (Functor f, Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
16:20:23 <iqubic> What does ala do?
16:20:31 <Axman6> :t ala Sum
16:20:33 <lambdabot> Functor f => ((b1 -> Sum b1) -> f (Sum b2)) -> f b2
16:20:41 <iqubic> Is that a fold?
16:21:30 <Axman6> :t ala Sum foldMap
16:21:32 <lambdabot> (Foldable t, Num b) => t b -> b
16:22:33 <hseg> nice
16:22:38 <hseg> lens though?
16:22:43 <iqubic> Wait... how does that work?
16:22:52 <hseg> coercions iirc
16:23:10 <hseg> since newtypes coerce safely
16:23:32 <iqubic> :t ala Sum
16:23:33 <lambdabot> Functor f => ((b1 -> Sum b1) -> f (Sum b2)) -> f b2
16:23:39 <iqubic> :t foldMap
16:23:41 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:23:47 <iqubic> Huh???
16:24:05 <Axman6> :t ala Sum traverse
16:24:07 <lambdabot> Traversable t => t b -> t b
16:24:15 <iqubic> HOW?!?!
16:24:28 <Axman6> > ala Sum traverse [1,2,3,4,5] -- I have no idea what this will do
16:24:32 <lambdabot>  [1,2,3,4,5]
16:24:50 <Axman6> well there you go
16:24:53 <jle`> the answer to how: typeclasses
16:25:02 <iqubic> > ala Sum foldMap [1..5]
16:25:06 <lambdabot>  15
16:25:47 <jle`> hseg: you can do it without anything extra by writing `coerce fold`, with enough type annotations
16:26:49 <jle`> hseg: also the function you asked about cannot exist for all Foldable
16:27:04 <jle`> the forall f a b c. Foldable f => (a -> b) -> (a -> c) -> f a -> (b, c)
16:27:10 <hseg> why not?
16:27:32 <jle`> consider writing it for a Foldable like Maybe
16:27:38 <jle`> or more extreme, a Foldable like Proxy
16:27:48 <hseg> oh, forgot the Monoid b, Monoid c constraints
16:27:51 <jle`> the implementation that you gave earlier requires Monoid b, c
16:28:30 <jle`> ah. so you are looking for something like a double-foldmap
16:28:35 <hseg> yep
16:28:37 <jle`> not a double-extract
16:28:42 <hseg> no
16:29:27 <hseg> but what i really want is fold :: [(k,v)] -> [(k,v)] via (First k, Sum v)
16:29:50 <iqubic> Why not just dump that into a Map?
16:29:59 <jle`> hm, so like foldMap (bimap First Sum)
16:30:12 <hseg> yeah, but unwrapping at the end
16:30:30 <hseg> iqubic: i'm abstracting over the use of Map
16:30:30 <jle`> you can be sneaky i suppose with coerce fold
16:30:51 <hseg> iqubic: bc I might want to change underlying key-value store type
16:30:56 <jle`> coerce (fold @[] @(First k, Sum v))
16:31:15 <hseg> :t coerce (fold @[] @(First k, Sum v))
16:31:16 <Axman6> <3 Data.Coerce
16:31:17 <lambdabot> error: parse error on input ‘@’
16:31:22 <hseg> :(
16:31:24 <jle`> lambdabot no @
16:31:26 <jle`> but yahb @
16:31:35 <Axman6> %:t coerce (fold @[] @(First k, Sum v)) 
16:31:39 <jle`> type variables
16:31:43 <Axman6> % :t coerce (fold @[] @(First k, Sum v)) 
16:31:44 <yahb> Axman6: ; <interactive>:1:26: error: Not in scope: type variable `k'; <interactive>:1:33: error: Not in scope: type variable `v'
16:32:04 <hseg> % :t coerce (fold @[] @(First _, Sum _))
16:32:04 <yahb> hseg: (Num w1, Coercible b ([(First w2, Sum w1)] -> (First w2, Sum w1))) => b
16:32:28 <jle`> heh the signature is ugly but i'm assuming that type inference or a type annotation on the reuslt will give you want you want
16:32:55 <hseg> % :t coerce (fold @[] @(First _, Sum _)) @([Int,Int]) @([Int, Int])
16:32:56 <yahb> hseg: ; <interactive>:1:1: error:; * Cannot apply expression of type `b0'; to a visible type argument `([Int, Int])'; * In the expression: coerce (fold @[] @(First _, Sum _)) @([Int, Int]) @([Int, Int])
16:32:57 <jle`> % let foldFirstSum :: forall k v. Num v => [(k, v)] -> (k, v); foldFirstSum = coerce (fold @[] @(First k, Sum v))
16:32:57 <yahb> jle`: ; <interactive>:6:77: error:; * Occurs check: cannot construct the infinite type: k ~ Maybe k arising from a use of `coerce'; * In the expression: coerce (fold @[] @(First k, Sum v)); In an equation for `foldFirstSum': foldFirstSum = coerce (fold @[] @(First k, Sum v)); * Relevant bindings include foldFirstSum :: [(k, v)] -> (k, v) (bound at <interactive>:6:62)
16:33:04 <jle`> oh man, it's the wrong First
16:33:15 <jle`> % let import qualified Data.Semigroup
16:33:15 <yahb> jle`: ; <interactive>:7:5: error: parse error on input `import'
16:33:21 <jle`> % import qualified Data.Semigroup
16:33:21 <yahb> jle`: 
16:33:29 <jle`> % let foldFirstSum :: forall k v. Num v => [(k, v)] -> (k, v); foldFirstSum = coerce (fold @[] @(Data.Semigroup.First k, Sum v))
16:33:29 <yahb> jle`: ; <interactive>:9:85: error:; * Could not deduce (Monoid (Data.Semigroup.First k)) arising from a use of `fold'; from the context: Num v; bound by the type signature for:; foldFirstSum :: forall k v. Num v => [(k, v)] -> (k, v); at <interactive>:9:5-59; There are instances for similar types: instance Monoid (First a) -- Defined in `Data.Monoid'; * In 
16:33:37 <jle`> hm
16:33:47 <jle`> so that's a problem with your original desire
16:34:03 <jle`> you cannot do the fold via (First k, Sum v)
16:34:08 <jle`> because the list might be empty
16:34:22 <jle`> hooray for type safety
16:34:41 <jle`> imagine how embarassing that would be to run into during production :)
16:34:44 <hseg> hrm. but if the list is empty, i don't want any results
16:34:54 <hseg> ... oh wait
16:35:02 <hseg> yeah, see what's happening here
16:35:15 <jle`> like pair programming with the compiler :)
16:35:18 <hseg> too bad group is not :: [a] -> [NonEmpty a]
16:35:44 <shachaf> Too bad group is not :: [a] -> [NonEmptyListOfElementsThatAreAllEqual a]
16:35:56 <hseg> and that NonEmpty isn't an instance of a SemiFoldable which would accept a Semigroup constraint on the output
16:36:27 <hseg> heh. wonder if the Agda guys run into these problems, and whether they have some sort of proof-monkeypatching mechanism
16:36:39 <jle`> % let foldFirstSum :: forall k v. Num v => NonEmpty (k, v) -> (k, v); foldFirstSum = coerce (fold1 @[] @(Data.Semigroup.First k, Sum v))
16:36:39 <yahb> jle`: ; <interactive>:17:84: error:; * Couldn't match representation of type `[(Data.Semigroup.First k, Sum v)]' with that of `NonEmpty (k, v)' arising from a use of `coerce'; * In the expression: coerce (fold1 @[] @(Data.Semigroup.First k, Sum v)); In an equation for `foldFirstSum': foldFirstSum = coerce (fold1 @[] @(Data.Semigroup.First k, Sum v)); * Relevant bindings include foldFirstSum
16:36:48 <jle`> ah, so close.
16:37:15 <jle`> % let foldFirstSum :: forall k v. Num v => NonEmpty (k, v) -> (k, v); foldFirstSum = coerce (fold1 @NonEMpty @(Data.Semigroup.First k, Sum v))
16:37:15 <yahb> jle`: ; <interactive>:19:99: error:; Not in scope: type constructor or class `NonEMpty'; Perhaps you meant one of these: `NonEmpty' (imported from Data.List.NonEmpty), `NonEmptyF' (imported from Data.Functor.Base)
16:37:21 <jle`> % let foldFirstSum :: forall k v. Num v => NonEmpty (k, v) -> (k, v); foldFirstSum = coerce (fold1 @NonEmpty @(Data.Semigroup.First k, Sum v))
16:37:21 <yahb> jle`: 
16:37:22 <hseg> ok, NonEmpty is Foldable
16:37:29 <jle`> it's Foldable1 here, which is the important thing
16:38:00 <jle`> % foldFirstSum $ (1, 3) :| [(2,5), (6,7), (10,1)]
16:38:00 <yahb> jle`: (1,16)
16:38:24 <hseg> nice!
16:38:57 <jle`> IcelandJack has that extension he has been pushing to make this sort of stuff a lot simpler
16:39:00 <jle`> but ... at what cost
16:39:05 <hseg> ApplyingVia?
16:39:15 <hseg> what's wrong with it?
16:39:24 <jle`> complexity in the language maybe
16:39:39 <hseg> yeah, but is coerce @(...) that much simpler?
16:39:49 <jle`> there's less magic
16:39:56 <hseg> point
16:40:12 <hseg> the more we manage to keep from baking in, the better
16:40:32 <hseg> would be nice if we'd be able to write ApplyingVia in the language, though
16:42:35 <habbah> thoughts on conduit vs pipes vs streamly?
16:42:44 <jle`> hseg: btw not sure if you were aware, but there is a group that returns [NonEmpty a] in base
16:42:46 <jle`> habbah: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List-NonEmpty.html#v:group
16:42:52 <hseg> just noticed
16:43:25 <jle`> habbah: i haven't used streamly seriously yet, but over my years i've sort of settled on slightly preferring conduit style to pipe style
16:43:43 <jle`> but honestly i would probably be happy with any of them on a given streaming IO problem
16:44:44 <iqubic> What's the difference between the conduit and pipe styles?
16:51:08 <Axman6> Personally I've managed to make many working applications with conduit and never managed to with pipes, so for me, that's the difference.
16:57:02 <iqubic> I wrote my AoC IntCode interperter to use Conduit
16:59:36 <iqubic> So basically I had "(Monad m) => String -> ConduitM Int Int m (IntMap Int)"
16:59:47 <iqubic> as the main entry point for that.
17:06:15 <hseg> hacky, but just realized i can make the equivalent of Identity an instance of Profunctor, by specialization
17:06:18 <hseg> a la
17:06:27 <hseg> :t (id :: (a -> a) -> (a -> a))
17:06:29 <lambdabot> (a -> a) -> a -> a
17:07:06 <hseg> (what I'm *actually* doing being slightly different from this, but this is a good enough approximation)
17:14:59 <hseg> nm, doensn't work and not sure it should
17:17:30 <iqubic> :t id . id
17:17:32 <lambdabot> c -> c
17:17:41 <iqubic> :t id . id . id . id
17:17:43 <lambdabot> c -> c
18:01:44 <bloodaxe> so what cool things is everyone  working on?
18:05:16 <haskellbeginner> trying to learn haskell 
18:05:42 <bloodaxe> same, I'm going through learn you a haskell for the greater good rn
18:05:47 <haskellbeginner> guess that isn't cool
18:06:20 <bloodaxe> every hour spent in functional programming bliss is better than 1 second of imperative programming hlel
18:06:22 <bloodaxe> *hell
18:09:11 <haskellbeginner> yeah i'm leaning on that book too 
18:11:39 <dmwit> (Is the implication here that 59 minutes of functional programming bliss is worse than 1 second of imperative programming hell?)
18:14:33 <bloodaxe> you could say that
18:35:13 <dmj`> sounds like anything would be better than imperative hell
18:35:33 <dmj`> there are levels to hell though
18:35:44 <dmj`> OCaml is purgatory, JavaScript is like the third level of hell
18:38:29 <koz_> @pl \x -> (x,x)
18:38:29 <lambdabot> join (,)
18:39:57 <monochrom> :)
18:46:43 <iqubic> That's just using the ((->) e) monad instance.
18:46:57 <iqubic> join f x = f x x
18:47:03 <iqubic> that's what it's doing.
18:47:11 <koz_> iqubic: Lol, thanks.
18:47:28 <iqubic> So I guess you can see how "join (,)" will work.
18:54:46 <dmj`> could `foo %= (+1)` be considered imperative hell ?
18:55:13 <koz_> dmj`: Uhh, you're already in MonadState. Do you consider MonadState 'imperative hell'?
18:55:23 <dmj`> if it looks like a duck ... 
18:55:58 <dmj`> state monad isn't imperative, but lens + MonadState can give you some real soupy code
18:55:59 <koz_> I mean, you're welcome to think that way, but that's a pretty strong definition of 'imperative hell'. :P
18:56:18 <koz_> Well, I agree with the soupy code, but I don't think it's MonadState's fault. :P
18:56:22 <dmj`> it looks imperative ... 
19:03:24 * hackage named-sop 0.3.0.0 - Dependently-typed sums and products, tagged by field name  https://hackage.haskell.org/package/named-sop-0.3.0.0 (sjsch)
19:10:55 <nshepperd> haskell for the greater good huh
19:11:47 <mouse07410> I use VS Code with Haskell Language Server (with HIE) and GHC-8.6.5 on MacOS. I'm having problems with "false positive" error reports. Is this the right place to see help?
19:12:44 <Axman6> the HIE repo would be the first place I would be looking for help
19:12:55 <Axman6> what sort of false positives?
19:13:20 <mouse07410> I'd like to show - what's a good way to do it?
19:15:12 <Axman6> screenshot and imgur?
19:15:40 <koz_> :t (=<<)
19:15:42 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:15:44 <Axman6> sometimes HIE can get stuck and stop showing new errors, I usually just restart VS Code when that happens
19:15:50 <koz_> I can never remember which way this thing points.
19:16:19 <Axman6> koz_: it passes things into the function, so it oints towards the function
19:16:24 <Axman6> points*
19:16:25 <koz_> Ah, OK.
19:16:35 <nshepperd> dmj`: The way i see it, haskell is powerful enough to let you choose a preferred hell of your own design. See Language.Basic
19:18:48 <nshepperd> koz_: I visualize the shape of =<< as some kind of machine pulling something out of the thing on the right and squeezing it into the thing on the left
19:21:58 <mouse07410> Added the error message to gist: https://gist.github.com/mouse07410
19:24:11 <mouse07410> It shows the error itself, and the two very small/simple files - Main.hs and Lib.hs. HIE (or HLint) seems to dislike "print" statements in Main.hs that output result of (trivial) functions defined in Lib.hs and imported to Main.hs.
19:24:36 <koz_> I'll try and remember that.
19:24:44 <mouse07410> Perhaps this would be a better URL:  https://gist.github.com/mouse07410/5bc59d635be5569532ecbeec759ce399
19:25:34 <mouse07410> https://gist.github.com/mouse07410/5bc59d635be5569532ecbeec759ce399
19:26:56 <mouse07410> Also, that code builds (with Stack or Cabal, tried both) and runs correctly (as expected - it's rather trivial).
19:31:07 <mouse07410> Restarting VSCode did not help.
19:38:24 <dmj`> nshepperd: I guess having a choice is a luxury
19:46:00 <mouse07410> Here's the code line: `print $ splitMore 2 s`
19:46:40 <mouse07410> "splitMore" is imported. Here's how it is defined:  splitMore :: Int -> String -> String
19:47:41 <mouse07410> This is what HIE says about the "print $ ..." line:  _ :: Integer -> [Char] -> ghc-prim-0.5.3:GHC.Types.Any
19:47:58 <mouse07410> And this: Variable not in scope: splitMore :: Integer -> [Char] -> a2
19:48:12 <mouse07410> Could somebody please help making sense of this?
19:49:22 <xavo[m]> seems like the Integer -> [Char] -> Any tysig is coming from splitMore
19:50:35 <xavo[m]> but since it's not importing splitMore properly, it infers `Read a => Integer -> String -> a` for it
19:55:11 <mouse07410> Thanks. But how should it be imported? Could you please take a loog at the https://gist.github.com/mouse07410/5bc59d635be5569532ecbeec759ce399 to see the complete source? (less than 20 lines in total)
19:56:07 <xavo[m]> your import looks fine here
19:57:36 <xavo[m]> could it be that HIE's barfing on Lib.hs, not compiling it, and then not seeing it in Main.hs? chunk'' is referencing splitAt, which doesn't seem to be in your file anywhere
19:57:54 <mouse07410> Exactly. And it compiles/builds/runs fine too. 
19:58:34 <xavo[m]> really? huh
19:58:35 <mouse07410> But "splitAt" is in base GHC.list
19:59:02 <mouse07410> Oh yes. Should I post the output here, or amend the gist?
19:59:16 <xavo[m]> oh, my bad, i've just never seen splitAt before lmao
19:59:26 <mouse07410> :-)
20:03:05 <xavo[m]> nope, I have no idea
20:03:26 <xavo[m]> the one other thing I'd try would be setting verbose flags everywhere but I'm sure that's been tried already
20:04:36 <mouse07410> Problem is - it compiles and runs (no, I don't complain that it works ;). And I probably wouldn't make heads or tails from a debugging output of HLint or such...
20:05:25 <xavo[m]> is there any way to see where HIE thinks Lib is?
20:10:00 <mouse07410> Hmm. Good question - I don't know (offhand).
20:49:11 <dminuoso> What's the use of the Setup.hs that `cabal-install init` appears to always generate?
20:50:39 <iqubic> I don't know. I think the only thing in that file is just an import and "main = defaultMain" along with the proper type signature.
20:51:02 <iqubic> That's the default. But I've never seen any project that changes the default.
20:51:19 <glguy> dminuoso: You can customize the build process there
20:51:34 <glguy> e.g. https://github.com/glguy/irc-core/blob/v2/Setup.hs
20:52:38 <dminuoso> glguy: But that necessitates using `runhaskell/runghc` rather than cabal-install, right?
20:52:43 <glguy> no
20:59:05 <dminuoso> I see. Is the Simple build system used by cabal-install internally by default?
20:59:42 <dminuoso> The Setup.hs does not appear to be necessary unless you specify a custom-setup-script
21:00:01 <glguy> Right, the Setup.hs is used if you use a Custom build
22:21:26 <snyp> What's the point of MonadReader?
22:31:26 <dminuoso> snyp: MonadReader generalizes the idea of having some "readonly environment" in a monadic context.
22:32:17 <snyp> That's what the Reader monad does, right? 
22:34:27 <iqubic> Yes.
22:34:42 <dminuoso> snyp: Well the Reader monad is just an example of it.
22:36:07 <iqubic> Imagine you have a program that can be configured with a textual configuration file. Like a bashrc or vimrc or .emacs or something. You can use the reader monad to access values from that config, in a readonly fashion.
22:36:14 <iqubic> snyp: ^^^
22:37:37 <snyp> True. But why MonadReader? Reader itself seems enough.
22:38:20 <dminuoso> snyp: MonadReader gives you a way to talk about things that have a readonly environment in general
22:38:37 <dminuoso> snyp: say for instance you have a monad stack, or maybe just a custom monad that has some notion of an environment.
22:38:46 <snyp> Is it ever used irl?
22:38:57 <snyp> Reader and ReaderT, yes.
22:39:04 <dminuoso> Absolutely. The most common use case is to have some common interface for ReaderT in monad stacks
22:39:38 <dminuoso> Say you have some `StateT S (ReaderT E B)` for some base monad b, and you want to be able to say `ask`
22:42:46 <dminuoso> snyp: But really, it might be helpful to understand what mtl is really about nowadays
22:43:10 <dminuoso> snyp: The point of MonadX is to be able to write code like `doThing :: MonadX m => ... m ...` such that it works for any kind of monad that implements MonadX
22:43:29 <dminuoso> Irrespective of what that monad is, and how it has that. It's become an effect library
22:43:57 <dminuoso> `MonadState T m => ... m ...` says "I need a monadic state T"
22:44:11 <dminuoso> `MonadWriter T m => ... m ...` says "I need to be able to write a log"
22:44:27 <dminuoso> `MonadLogger m => ... m ...` says I work with any monad that is capable of logging
22:45:11 <fog> apparently weak learners can be gated over to give a strong learner from the ensemble, a technique known as "boosting" which is equivalent to gradient descent. I found a haskell lib; https://github.com/dpkatz/HaskellGBM
22:46:15 <fog> its over a "faster" version of boosting from here; https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf
22:47:08 <fog> here is the theory; http://papers.nips.cc/paper/1766-boosting-algorithms-as-gradient-descent.pdf
22:47:13 <snyp> dminuoso: hmm.. So some transformers are not content with simply requiring another monad, but only monads that implement a specific typeclass?
22:48:36 <dminuoso> snyp: No.
22:48:53 <dminuoso> snyp: MonadX ... are basically effect typeclasses that are orthogonal to transformers.
22:49:09 <snyp> *sigh* I see
22:49:09 <dminuoso> snyp: Transformers are about adding monadic effects to other monads (say adding state effect to IO)
22:49:34 <dminuoso> So `StateT T` is about adding `T` to some arbitrary other monad.
22:49:49 <dminuoso> `StateT T []` adds a stateful T to list-computations
22:51:07 <dminuoso> snyp: Consider some `newtype Foo a = Foo (IORef T -> IO a)` - now we could write a `MonadState T` instance for this.
22:51:14 <dminuoso> There's no State monad involved.
22:54:25 <snyp> I'm pretty noob still - don't know IORef. But yes, I kind of get what you're saying.
22:55:29 <dminuoso> An IORef is just a mutable reference. A python variable that you can mutate like `c = 1; c += 10` can be modelled with `c <- newIORef 1; modifyIORef c (+ 10)` in haskell.
22:56:16 <dminuoso> It just requires IO because an IORef can be thought as a pointer to memory.
22:58:42 <snyp> dminuoso: I see
23:06:52 <iqubic> My favorite use of MonadState is this:
23:07:04 <iqubic> :t (+=)
23:07:06 <lambdabot> (MonadState s m, Num a) => ASetter' s a -> a -> m ()
23:07:49 <iqubic> That's for if you want to have something that you can maninulate in the same way as the python variables dminuoso was talking about.
23:08:22 <iqubic> but it requires lens. So it might not be that applicable to your use case.
23:12:54 * hackage commander-cli 0.1.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.1.0.0 (sgschlesinger)
23:34:14 <siraben> Is there an implementation of lens from scratch that I can read to learn more about?
23:37:49 <idnar> @pl \f x -> void (f x) >> pure x
23:37:49 <lambdabot> (`ap` pure) . (((>>) . void) .)
23:38:26 <idnar> @pl \f x -> f x $> x
23:38:27 <lambdabot> (($>) =<<)
23:38:49 <idnar> @pl \x -> f x $> x
23:38:49 <lambdabot> ($>) =<< f
23:39:37 <idnar> @type \x -> f x $> x
23:39:39 <lambdabot> error:
23:39:39 <lambdabot>     • Variable not in scope: ($>) :: t0 -> t -> t1
23:39:39 <lambdabot>     • Perhaps you meant one of these:
23:42:37 * tdammers mumbles something about packages named 'optics'
23:58:54 * hackage indexed-containers 0.1.0.1 - Simple, no-frills indexed lists.  https://hackage.haskell.org/package/indexed-containers-0.1.0.1 (zliu41)
