00:00:09 <MarcelineVQ> boxscape: interesting
00:03:27 <zincy_> boxscape: Sorry, I was confused :)
00:21:23 * hackage tasty-golden 2.3.2.1 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.2.1 (RomanCheplyaka)
00:23:24 * hackage fusion-plugin-types 0.1.0 - Types for the fusion-plugin package.  https://hackage.haskell.org/package/fusion-plugin-types-0.1.0 (pranaysashank)
01:00:54 * hackage wai-extra 3.0.29.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.29.1 (MichaelSnoyman)
01:24:50 <fishooter> hi, I know that to print a list of strings I can use something like
01:24:52 <fishooter> mapM_ print ["a", "b"]
01:24:57 <fishooter> but if I have 
01:25:07 <fishooter> x = map print ["a", "b"]
01:25:20 <fishooter> how can I make it to evaluate that x to also print the items?
01:25:38 <[exa]> fishooter: 'x' is now a list of IO actions, the easiest way to run all of them in sequence is 'sequence'
01:25:43 <xavo[m]> sequence
01:26:06 <xavo[m]> oh you got there first
01:26:30 <boxscape> (or sequence_ for the immediate mapM_ equivalent)
01:26:45 <[exa]> or perhaps sequenceA
01:26:53 <[exa]> so many possibilities
01:26:59 <boxscape> or sequenceA_
01:27:39 <merijn> traverse :p
01:27:56 <[exa]> or 'mapM_ id' for added evil
01:28:16 <boxscape> > "mapM_ id" < "sequence_"
01:28:19 <lambdabot>  True
01:28:24 <boxscape> seems reasonable
01:28:29 <xavo[m]> flip for_ id
01:28:32 <boxscape> wait
01:28:40 <boxscape> I wanted to calculate the length -.-
01:28:50 <boxscape> > length "mapM_ id" < length "sequence_"
01:28:51 <[exa]> boxscape: you calculated the greatness instead
01:28:54 <lambdabot>  True
01:28:56 <boxscape> indeed
01:29:05 <idnar> is there a function to remove an element from a Map, but giving me the element back?
01:29:07 <merijn> fishooter: Anyway, as you've seen in the second example it's perfectly legal to store IO actions inside datastructures. You can use something like sequence/sequence_ for "run all actions in this Foldable" but you could also selectively get elements out and only run those
01:29:16 <merijn> idnar: Yes, but I forget the name :)
01:29:40 <idnar> a combined lookup and delete IOW
01:29:44 <[exa]> idnar: so you want a function say `(Map k v) -> k -> (v, Map k v)` ?
01:30:04 <idnar> [exa]: yeah
01:30:14 <fishooter> merijn: thanks :) and how can it be written "more low level" by using fold or something like this?
01:30:22 <merijn> This one exist: Map k v -> (Maybe v, Map k v)
01:30:34 <fishooter> because I looked up the definition of sequence and it seems circular :D
01:30:35 <idnar> probably `Maybe v` yeah
01:30:46 <fishooter> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html#traverse
01:31:58 <xavo[m]> well, that's the default definition for when you're writing typeclass instances and don't want to fill in both
01:32:03 <merijn> fishooter: To show a contrived example: "main = readLn >>= \n -> map print [1..] !! n"
01:33:04 <merijn> fishooter: "map print [1..]" produces an (infinite) list of type [IO ()], so if we get a single element from that list (with !!) we get an element of type "IO ()" which we can combine with >> and >>= as usual
01:33:21 <[exa]> idnar: anyway you can easily construct such functions using liftA2, say `liftA2 (,) M.lookup M.delete` should do roughly what you want
01:33:27 <fishooter> merijn: yes, that's a nice example
01:34:06 <fishooter> and can I do it with something simpler than sequence?
01:34:10 <[exa]> idnar: (I'm not sure if that one has a name already (didn't find it))
01:34:23 <boxscape> % foldr (\x a -> a >> print x) (pure ()) [1..5]
01:34:23 <yahb> boxscape: 5; 4; 3; 2; 1
01:34:29 <boxscape> hm reversed
01:34:30 <xavo[m]> fishooter: you can get to the instances for individual types under the list of fns in the typeclass
01:34:46 <boxscape> % foldr (\x a -> a << print x) (pure ()) [1..5]
01:34:46 <yahb> boxscape: ; <interactive>:204:18: error:; * Variable not in scope: (<<) :: f () -> IO () -> f (); * Perhaps you meant one of these: data constructor `Seq.:<' (imported from Data.Sequence), data constructor `:<' (imported from Control.Lens), `<#' (imported from GHC.Exts)
01:34:46 <merijn> fishooter: "sequence" is just getting every element from the list one at a time and tieing them together with >>
01:34:50 <xavo[m]> source link to the left of Traversable [], for instance
01:34:53 <boxscape> okay that was dumb
01:35:22 <merijn> fishooter: "sequence (x:xs) = do { v <- x; vs <- xs; return (v:vs) }"
01:35:25 <idnar> [exa]: yeah, I just wanted to avoid traversing twice; this map is tiny though so it's unimportant
01:35:51 <merijn> fishooter: Eh, crap, the "vs <- xs" should be "vs <- sequence xs" ;)
01:36:06 <idnar> updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
01:36:08 <boxscape> I keep forgetting that (<<) is not a function (at least I think it's not?)
01:36:11 <merijn> fishooter: So "do the first IO action, then recurse to do the rest, then return both lists"
01:36:14 <boxscape> % :t (>>)
01:36:14 <yahb> boxscape: Monad m => m a -> m b -> m b
01:36:14 <merijn> boxscape: Yes it is
01:36:17 <fishooter> merijn: ah, ok! nice
01:36:17 <merijn> :t (<<)
01:36:19 <lambdabot> error:
01:36:19 <lambdabot>     ‚Ä¢ Variable not in scope: <<
01:36:19 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
01:36:25 <merijn> what?
01:36:39 <boxscape> %!kill
01:36:45 <boxscape> I forget how that works
01:36:47 <[exa]> idnar: I wouldn't worry about that, `delete` needs to rebuild the tree spine after modification anyway which is several times slower than traversing it
01:36:49 <boxscape> % :q
01:36:49 <yahb> boxscape: 
01:36:53 <boxscape> % :t (<<)
01:36:54 <yahb> boxscape: ; <interactive>:1:1: error:; * Variable not in scope: <<; * Perhaps you meant one of these: data constructor `Seq.:<' (imported from Data.Sequence), data constructor `:<' (imported from Control.Lens), `<#' (imported from GHC.Exts)
01:37:12 <merijn> idnar: updateLookupWithKey is the one I was thinking of, yeah
01:37:17 <boxscape> @hoogle (<<)
01:37:17 <lambdabot> Text.XHtml.Frameset (<<) :: (HTML a) => (Html -> b) -> a -> b
01:37:17 <lambdabot> Text.XHtml.Strict (<<) :: (HTML a) => (Html -> b) -> a -> b
01:37:17 <lambdabot> Text.XHtml.Transitional (<<) :: (HTML a) => (Html -> b) -> a -> b
01:37:27 <boxscape> merijn it seems like it should exist but I can't find it
01:37:32 <idnar> unordered-containers doesn't have this one though
01:37:56 <merijn> idnar: unordered-containers isn't Map, though :p
01:37:59 <fishooter> merijn: and the base case is 
01:38:12 <merijn> fishooter: "sequence [] = return []" :)
01:38:15 <fishooter> sequence [] = () ?
01:38:22 <fishooter> ah, ok
01:38:28 <idnar> merijn: true!
01:39:03 <merijn> fishooter: Because "sequence :: Monad m => [m a] -> m [a]" so you the return value needs to be a list in some Monad, so "return []" for empty list with no extra effects
01:40:00 <fishooter> makes sense, how can I search for this definition myself?
01:40:24 <merijn> fishooter: If you browse the documentation on hackage there is a source link on the right of the page
01:40:40 <merijn> fishooter: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:sequence
01:41:06 <merijn> fishooter: At the bottom there you see "instance Traversable []" followed by a Source link which takes you to the definition of the class for []
01:41:31 <merijn> fishooter: (Which doesn't show sequence directly, since sequence has a default definition using traverse)
01:41:39 <boxscape> is there a difference between (*>) and (>>)? (assuming the usual definitions?)
01:41:57 <merijn> boxscape: Nothing
01:41:59 <fishooter> what im confused about, is that traverse uses sequenceA, and sequenceA uses traverse
01:42:01 <boxscape> okay
01:42:21 <boxscape> merijn then I guess the question for (<<) is, should it behave like (flip (>>)) or like (<*)
01:42:29 <merijn> fishooter: Those are the *default* definitions, you need to define one of them :)
01:43:24 <merijn> fishooter: If you look a bit up on the page you'll see that the *minimum* definition of Traversable is "traverse | sequenceA" so your instance needs to define *at least* sequenceA *or* traverse (else it'll loop infinitely because they call each other)
01:43:56 <fishooter> that's what I suspected :) but where can I find the def for IO and Traversable?
01:44:16 <merijn> fishooter: You'll want Traversable and [] for example
01:44:32 <merijn> fishooter: Traversable works for any Applicative (and IO just happens to be an Applicative)
01:44:51 <fishooter> aha
01:44:54 <merijn> fishooter: So Traversable instances are for data structures like lists, Map, etc.
01:44:56 <fishooter> so the def is this? https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html#line-237
01:46:10 <merijn> fishooter: That's what list does, yes. Which is similar to what I wrote for sequence, except there's an additional 'f' function and it uses foldr/liftA2 instead of manually writing out the recursion
01:48:23 <fishooter> ah, I think I got it
01:48:25 <fishooter> thanks! :)
01:50:06 <fishooter> could I say that
01:50:20 <fishooter> mapM = sequence map
01:50:21 <fishooter> ?
01:51:05 <merijn> fishooter: "mapM f xs = sequence (map f xs)"
01:53:31 <fishooter> I'm trying to write it somehow :-D 
01:53:33 <fishooter> f=mapM
01:53:40 <fishooter> g=sequence . map
01:53:46 <fishooter> but that doesn't type check
01:54:56 <merijn> fishooter: "sequence . map" -> "\f -> sequence (map f)"
01:55:13 <merijn> fishooter: So you'd need like "\f -> sequence . map f"
01:58:00 <fishooter> aah, ok, tricky
02:00:08 <fishooter> is it correct to say that x and y are isomorphic?
02:00:09 <fishooter> x = mapM_
02:00:09 <fishooter> y = \f -> sequence_ . map f
02:02:10 <MarcelineVQ> equivalent is the word there
02:02:21 <int-e> fishooter: It's even described that way in the Haskell report: "mapM_ f is equivalent to sequence_ . map f"
02:03:23 <int-e> (Though that was for lists, but it's still true with the Traversable versions.)
02:04:27 <int-e> Err, Foldable is all it needs.
02:04:55 <int-e> mapM_ f = sequence_ . fmap f
02:05:37 <boxscape> :t \f -> sequenceA_ . fmap
02:05:40 <lambdabot> (Foldable ((->) (f a1)), Applicative f) => p -> (a1 -> a2) -> f ()
02:05:42 <boxscape> :t \f -> sequenceA_ . fmap f
02:05:44 <lambdabot> (Foldable t, Applicative f, Functor t) => (a1 -> f a2) -> t a1 -> f ()
02:06:12 <boxscape> is there a name for the Applicative version of mapM_?
02:06:47 <boxscape> also isn't Functor a superclass of Foldable?
02:07:08 <boxscape> hm, no
02:07:33 <merijn> boxscape: There are things which are Foldable which aren't functors :)
02:07:52 <boxscape> I see
02:07:53 * hackage jord 1.0.0.0 - Geographical Position Calculations  https://hackage.haskell.org/package/jord-1.0.0.0 (CedricLiegeois)
02:07:55 <merijn> The most obvious example is Set
02:08:21 <boxscape> that makes sense
02:08:24 <int-e> :t for_
02:08:26 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
02:08:55 <int-e> boxscape: That's your mapA_, only flipped.
02:08:59 <boxscape> oh it's traverse_
02:09:02 <boxscape> :t traverse_
02:09:04 <int-e> Ah right.
02:09:04 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
02:09:14 <int-e> I should've remembered :-/
02:16:24 <xavo[m]> how isn't Set a Functor, now that I think about it?
02:16:42 <xavo[m]> like, map id = id, and
02:16:55 <Taneb> xavo[m]: you can break Set's invariants with an operation like "fmap"
02:17:13 <xavo[m]> map (f . g) would equal map f . map g since if g produced the same value for two elements of the set, then so would f
02:17:14 <boxscape> xavo[m] if you do `fmap (const 4)` on a set containing 100 elements, you would expect that there should only be one element (a 4) in it afterwards
02:17:22 <boxscape> so it doesn't preserve the structure
02:18:03 <xavo[m]> *f.g
02:18:18 <xavo[m]> how so?
02:18:20 <merijn> xavo[m]: You need an Ord constraint on the result
02:18:29 <merijn> xavo[m]: Which you can't force with Functor
02:18:34 <xavo[m]> right
02:18:40 <xavo[m]> ah that's true
02:19:01 <boxscape> or, if you don't have an Ord constraint, you can't make sure that the set you get out of fmap will actually be a set containing each element at most once
02:19:04 <xavo[m]> (sorry, slow bridge or something it feels like)
02:20:26 <xavo[m]> boxscape: didn't even think about the constraints, ty
02:22:08 <xavo[m]> oh, that's @ merijn too
02:35:23 * hackage reanimate-svg 0.9.8.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.8.0 (DavidHimmelstrup)
02:54:23 * hackage laop 0.1.0.6 -   https://hackage.haskell.org/package/laop-0.1.0.6 (bolt12)
03:21:44 <fishooter> how would you simplify this code?
03:21:45 <fishooter> https://repl.it/repls/AwkwardSeriousCommands
03:23:48 <julianleviston> generally, it‚Äôs good advice to move the non-IO parts to a place separated from the IO parts.
03:24:33 <julianleviston> it‚Äôs also good advice to take the parts that seem the same and make functions out of them
03:24:46 <julianleviston> do you see the repeated pieces?
03:26:05 <julianleviston> (not only extracting to functions, but you can extract to definitions)
03:27:16 <julianleviston> I‚Äôve got an extremely basic question about versioning and docs. I‚Äôm trying to find out what functions are available in a non-current version of Megaparsec ‚Äî but hackage only seems to track the latest, and hoogle seems to be the same.
03:27:40 <julianleviston> Is there any way I can use these tools with a specific version of Megaparsec?
03:28:38 <Uniaika> fishooter: this piece of code is actually quite nice. 
03:29:12 <Uniaika> you should simplify code that is actually needlessly complex. :) 
03:29:23 <fishooter> Uniaika : it just seems a bit repetitive
03:29:33 <Uniaika> fishooter: and it's alright :)
03:29:54 <fishooter> okay then :)
03:29:56 <Uniaika> it's not like you've got a `main` with 500 lines in it
03:33:11 <julianleviston> You could cut it in half by putting the check for ‚Äú/‚Äú inside the p clause
03:36:39 <julianleviston> the maybeFound <- bit could refactored to just repoFind (takeDirectory p), because it seems to already be returning an IO (Maybe RepoPath)
03:40:57 <julianleviston> I‚Äôm curious why hoogle and hackage don‚Äôt have all previous versions as well as the current ones.
03:41:35 <Taneb> Hackage does have all previous versions? Unless Haddock generation failed for that particular version or they've been explicitly removed
03:43:19 <julianleviston> No I just don‚Äôt know how to find it.
03:43:48 <Taneb> If you go to the index page for the library you care about on Hackage, on the right there's a big list of versions
03:43:54 <merijn> julianleviston: You click the link for the older version?
03:43:59 <julianleviston> Like‚Ä¶ I look up megaparsec, and I get verson 8, with no navigation. I guess I have to know the version I‚Äôm after and mangle the URL ‚Äî but what about hoogle?
03:44:10 <julianleviston> where do I find that link?
03:44:18 <merijn> julianleviston: Right on the page of the package?
03:44:31 <julianleviston> I don‚Äôt see it.
03:44:40 <MarcelineVQ> What are you looking at?
03:44:48 <julianleviston> I‚Äôm looking at this https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html
03:44:56 <merijn> julianleviston: That's not the package page
03:45:06 <boxscape> julianleviston click contents on the top right
03:45:07 <merijn> How did you get on that page?
03:45:15 <julianleviston> Oh. My. God.
03:45:33 <julianleviston> I pretty much always google to get those pages. lol. I rarely look at teh package page. Thankyou :)
03:45:42 <int-e> julianleviston: also, hoogle seems to give the package name first, which is also a link
03:45:52 <julianleviston> How did I not connect these two things in my mind before. :sigh:
03:46:01 <merijn> julianleviston: Google is terrible at finding hackage links, tbh it always indexes super old versions
03:46:20 <julianleviston> I feel so stupid
03:46:25 <merijn> :)
03:46:29 <int-e> julianleviston: That's how we learn.
03:46:31 <julianleviston> thanks :)
03:46:49 <julianleviston> lol yeah I know :)
03:46:55 <julianleviston> but this was SO obvious.
03:47:07 <int-e> in retrospect
03:48:02 <julianleviston> Well I knew about that page, and I‚Äôve seen it many many times, and I knew what the version numbers were. However, when I‚Äôm on a particular version, there‚Äôs no navigation to it, so I just didn‚Äôt put 2 and 2 together.
03:48:04 <merijn> julianleviston: There's tons of stuff people never realise, like the fact that the "index" page in the top right takes you to an alphabetically sorted list of all functions/types or the fact that pressing 's' lets you search the current package (for new enough package docs, anyway)
03:48:58 <julianleviston> I didn‚Äôt know about s. I knew about the index, and the source links, and stuff, but yeah.
03:49:54 <julianleviston> now to find out what version of megaparsec I‚Äôm using
03:49:57 <berndl> That 's' feature is pretty nice. I didn't know about it too.
03:52:38 <julianleviston> anyone know how to work out what version of a package you‚Äôre using (I‚Äôm using stack)
03:52:46 <julianleviston> Oh I guess I should look up the lts thingie.
03:52:57 <merijn> berndl: It's been around in haddock for about 2 years know, so by know most major packages have had their docs built with it :)
03:53:05 <lortabac_> julianleviston: try 'stack ls dependencies'
03:53:40 <julianleviston> oh beautiful
03:53:43 <julianleviston> thankyou!
03:54:02 <merijn> s/by know/by now
03:54:20 <julianleviston> I still find devving in haskell quite painful if I don‚Äôt know the libraries I‚Äôm using so well.
03:54:39 <julianleviston> Always end up with 10 to 20 web pages open with docs and source
03:54:40 <merijn> julianleviston: I don't know how to do it with stack, but you can build and install local copies of docs too
03:54:53 <julianleviston> local hackage? yeah
03:55:17 <merijn> julianleviston: No, without running a full hackage, just the HTML docs
03:55:26 <julianleviston> oh right
03:55:45 <merijn> Then you know they match the version you're developing
03:56:14 <merijn> (tbh I don't know how to do it with v2-build either, so right now I'm relying on Hackage again)
03:56:17 <julianleviston> stack haddock maybe
03:56:35 <julianleviston> or are you not meaning haddock? I honestly don‚Äôt know the difference.
03:57:12 <boxscape> haddock is a tool to generate html docs from haskell source code. hackage is a package repository that also hosts haddock docs
03:57:14 <merijn> haddock is the program building docs, yeah. But normally "cabal haddock" (and presumably "stack haddock") build docs for the current package, not all your dependencies
03:57:41 <merijn> With "documentation: True" cabal builds docs for all your dependencies too
03:57:57 <merijn> (Except I don't know how to find them with v2-build :p)
03:58:03 <idnar> @hoogle (f a, f b) -> f (a, b)
03:58:04 <lambdabot> Data.Functor.Adjunction zipR :: Adjunction f u => (u a, u b) -> u (a, b)
03:58:04 <lambdabot> Data.Bitraversable bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
03:58:04 <lambdabot> Data.Bitraversable bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
03:58:17 <julianleviston> ah okay.
03:58:58 <julianleviston> so local hackage is just a copy of remote hackage locally‚Ä¶ which hosts haddock docs locally that you can also build. Nice.
03:59:17 <merijn> julianleviston: hoogle is available as commandline tool too :p
03:59:17 <idnar> @hoogle f a -> f b -> f (a, b)
03:59:18 <lambdabot> Control.Concurrent.Async.Lifted concurrently :: MonadBaseControl IO m => m a -> m b -> m (a, b)
03:59:18 <lambdabot> Control.Concurrent.Async.Lifted.Safe concurrently :: forall m a b . (MonadBaseControl IO m, Forall (Pure m)) => m a -> m b -> m (a, b)
03:59:18 <lambdabot> Control.Invertible.Monoidal pairADefault :: Applicative f => f a -> f b -> f (a, b)
03:59:30 <idnar> hmm
03:59:32 <boxscape> (see "stack hoogle")
03:59:43 <MarcelineVQ> idnar: bisquence is right for the first one, the latter is liftA2 (,)
03:59:43 <julianleviston> yeah I knew that but I‚Äôve never installed it. To be honest I find Haskell‚Äôs tooling kind of crashy
03:59:46 <merijn> idnar: That's just "liftA2 (,)"
04:00:22 <julianleviston> Like‚Ä¶ for example, I always hear editor support is stellar, but I‚Äôve literally never been able to build it for my editors (vscode is what I‚Äôm using at the moment)
04:00:49 <merijn> julianleviston: Where did you hear editor support is stellar?
04:00:51 <sm[m]> "crashy" is a bit harsh :) I wouldn't call that "crashy"
04:00:51 <MarcelineVQ> I've not heard that, depends what editor support means hehe
04:00:57 <merijn> I don't think I've ever heard anyone say that :p
04:01:03 <julianleviston> merijn: redis I guess
04:01:04 <merijn> ghcide is making progress
04:01:15 <julianleviston> not redis reddit lol
04:01:17 <Taneb> merijn: "stellar" as in "like the stars" as in "far away" :D
04:01:19 <idnar> I actually need f (g a) -> f (g b) -> f (g (a, b))
04:01:25 <julianleviston> my fingers typed redis when I told them to type reddit.
04:01:27 <merijn> julianleviston: Editor support is one of the few areas where I'd say tooling is lacking
04:01:36 <merijn> idnar: Looks like you want Data.Functor.Compose
04:01:39 <Taneb> (it is getting better)
04:01:44 <boxscape> % :t uncurry (liftA2 (,))
04:01:44 <merijn> :t Data.Functor.Compose.Compose
04:01:44 <yahb> boxscape: Applicative f => (f a, f b) -> f (a, b)
04:01:46 <lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
04:01:50 <merijn> ugh
04:01:53 <merijn> That type...
04:01:58 <merijn> % :t Data.Functor.Compose.Compose
04:01:58 <yahb> merijn: forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
04:02:02 <merijn> aww
04:02:06 <MarcelineVQ> :t liftA2 (liftA2 (,))
04:02:08 <lambdabot> (Applicative f1, Applicative f2) => f1 (f2 a) -> f1 (f2 b) -> f1 (f2 (a, b))
04:02:19 <merijn> MarcelineVQ: That's what Compose does :p
04:02:24 <julianleviston> I‚Äôm still massively non-plussed about how difficult it is to upgrade ghc versions on projects, TBH
04:02:43 <merijn> idnar: "newtype Compose f g a = Compose { getCompose :: f (g a) }" with corresponding Functor/Applicative instances if f and g are Functor/Applicative
04:02:49 <julianleviston> invariably so many dependencies break, but it‚Äôs probably because I‚Äôve got way too many packages in my experimental projects
04:02:57 <julianleviston> trying to cram too much stuff in.
04:03:01 <MarcelineVQ> by the time you've wrapped and unwrapped everything..
04:03:03 <merijn> julianleviston: It depends on how quickly you update
04:03:08 <merijn> MarcelineVQ: coerce
04:03:24 <julianleviston> I really would like to use GHC 8.10.1 but it‚Äôs not out yet.
04:03:42 <boxscape> a release candidate or something like it is out
04:03:45 <MarcelineVQ> merijn: what would that look like?
04:03:46 <merijn> julianleviston: 8.8 is lagging a bit due to the MonadFail change causing people to lag updating
04:04:15 <boxscape> nix e.g. has 8.10, but doesn't have template-haskell for it, if I'm understanding it correctly
04:04:18 <merijn> MarcelineVQ: Depends on the context
04:04:21 <idnar> merijn: so getCompose (liftA2 (Compose foo) (Compose bar))?
04:04:31 <idnar> err
04:04:33 <julianleviston> 8.10 is still in beta, isn‚Äôt it? beta 2?
04:04:37 <MarcelineVQ> merijn: what would that look like in the context of this conversation? :>
04:04:44 <boxscape> julianleviston that might be right, yeah
04:04:47 <merijn> idnar: "getCompose $ (,) <$> Compose foo <*> Compose bar" for example
04:04:53 <sm[m]> it's easy to use the 8.10 rc1 with stack, at least
04:05:06 <merijn> MarcelineVQ: I meant that whether it's worth it depends on how the wrapped values are created
04:05:22 <julianleviston> Yeah but I guess I don‚Äôt just mean to use it, but also to have all the packages I depend on work with it too
04:05:24 <merijn> MarcelineVQ: Anyway, I don't think the wrapping is so bad
04:05:35 <boxscape> julianleviston I've gone over to just building from source when I want to experiment with the newest features :) though obviously not very feasible for actual projects
04:05:37 <merijn> MarcelineVQ: It's a bit more verbose but, imo, easier to read
04:05:47 <MarcelineVQ> What am‚Äã I gaining over liftA2 twice?
04:05:55 <merijn> julianleviston: I mean, I'm still mainly using 8.6.5
04:06:13 <julianleviston> boxscape: I couldn‚Äôt work out how to get dependencies to work with source-built GHCs
04:06:17 <merijn> MarcelineVQ: Not much (besides readability) if it's just one expression, if you do this more frequently...
04:06:39 <sm[m]> julia	nleviston: here's me using 8.10, with a lot of deps working: https://github.com/simonmichael/hledger/blob/master/stack-8.10.yaml
04:06:46 <MarcelineVQ> er, what am I gaining readabilitywise? That's why I asked about what it would look like here
04:06:47 <merijn> julianleviston: Usually it takes a few months after GHC release until the ecosystem has adapted/updated
04:07:07 <merijn> MarcelineVQ: Did you see the message to idnar?
04:07:21 <boxscape> julianleviston if you're on linux or mac or the windows subsystem for linux, if you're willing to use nix, it's very straightforward: https://ghc.dev/
04:07:29 <merijn> MarcelineVQ: I don't find "liftA2 (liftA2 (,)" particularly simple to read
04:07:39 <julianleviston> Yeah I really should use nix.
04:07:42 <boxscape> julianleviston or wait
04:07:48 <merijn> > length "liftA2 (liftA2 (,)) foo bar"
04:07:50 <lambdabot>  27
04:07:56 <idnar> oh my f isn't Applicative, let me fix that
04:07:57 <boxscape> julianleviston do you mean dependencies for building ghc or for your projects?
04:08:01 <MarcelineVQ> Alright, I don't agree there but I understand you now
04:08:07 <merijn> > length "getCompose $ (,) <$> Compose foo <*> Compose bar"
04:08:09 <julianleviston> well I don‚Äôt need it quite yet ‚Äî gotta write this parser first, and I have to wait until hint is updated anyway
04:08:10 <lambdabot>  48
04:08:36 <merijn> MarcelineVQ: You can avoid the explicit Compose wrapping with coerce, but that works best if you have, say, a list or data structure
04:09:37 <julianleviston> boxscape: I know how to build GHC itself. lol.. I‚Äôve actually contributed to it :)
04:09:43 <boxscape> ah, fair enough :)
04:10:18 <julianleviston> boxscape: but the project dependencies I have I couldn‚Äôt work out how to use them with my freshly built copies of GHC when I was working oni t
04:10:23 <julianleviston> boxscape: I‚Äôm a simple folk :)
04:10:44 <boxscape> that makes sense
04:11:06 <julianleviston> I wish it was simpler. I utterly love the architecture of GHC tho. It‚Äôs a thing of beauty.
04:11:37 <julianleviston> I love that you can use GHC itself as a library, too
04:12:16 <julianleviston> by ‚ÄúI wish it was simpler‚Äù I mean the package management and versioning story. I know it used to be a complete nightmare by comparsion.
04:12:51 <julianleviston> I guess backpack is (still?) coming, or‚Ä¶ here‚Ä¶ or something right? that‚Äôll solve all our issues? haha
04:13:04 <merijn> backpack is for something else entirely
04:13:18 <julianleviston> oh I thought it was a module and dependency system
04:13:35 <merijn> No, backpack is for polymorphic modules
04:13:45 <julianleviston> yeah
04:13:46 <merijn> It doesn't really deal with dependencies at all
04:13:50 <julianleviston> ah okay.
04:13:54 <julianleviston> for some reason I see them as the same thing
04:14:15 <julianleviston> my abstraction lens it too defocused maybe :)
04:14:37 <julianleviston> like‚Ä¶ ‚Äúwhen you say x, what do you mean by that in this context, exactly?"
04:15:35 <merijn> julianleviston: A lot of the breakage when new GHC's come out is due to people having upper bounds on their dependencies (which lots of other languages do much less) which means that new releases need dependency bumps. The advantage is that when new releases, in fact, are broken then you haven't broken old package permanently
04:16:10 <julianleviston> yeah I‚Äôd rather that clean break than a vague ‚Äúworks sometimes‚Äù break
04:16:43 <merijn> julianleviston: Basically, you have two choices: 1) upperbounds on dependencies, every new release takes time since upperbounds need to be bumped everywhere but breaking changes in dependencies are fine, or 2) no upperbounds, breaking releases of dependencies break released library version forever, but no bounds bump propagation delay
04:17:03 <julianleviston> or don‚Äôt use versions, but that‚Äôs much harder
04:17:09 <idnar>     ‚Ä¢ Can't make a derived instance of ‚ÄòApplicative Stamped‚Äô
04:17:09 <idnar>         (even with cunning GeneralizedNewtypeDeriving):
04:17:13 <idnar> aww
04:17:16 <merijn> julianleviston: Then you're just always fucked :)
04:17:25 <sm[m]> lortabac_: that stack ls dependencies command is great, thanks
04:17:37 <julianleviston> I don‚Äôt think I meant what you meant by not using versions
04:17:56 <merijn> julianleviston: What did you mean, then?
04:18:20 <julianleviston> I mean not redefining things
04:18:37 <julianleviston> also, finer grained identities
04:18:52 <merijn> julianleviston: We don't currently have the tooling to make that work, though
04:18:53 <julianleviston> but I have yet to put my money where my mouth is when it comes to that, so it‚Äôs possible I don‚Äôt know what I‚Äôm talking about
04:19:02 <julianleviston> yeah sorry pie in the sky hypothetical
04:19:26 <merijn> I'm open to better alternatives, but in pragmatic reality I prefer option 1 over option 2 :p
04:21:09 <idnar> are any of the applicative laws free theorems?
04:22:46 <julianleviston> idnar: do you mean http://hackage.haskell.org/package/free-5.1.3/docs/Control-Applicative-Free.html
04:23:08 <Taneb> I presume idnar means https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf
04:23:08 <julianleviston> or am I misunderstanding the question
04:23:15 <MarcelineVQ> julianleviston: the free laws are the laws you get 'for free' due to parametricity iiuc
04:24:28 <julianleviston> I swear I‚Äôve read this paper but it‚Äôs not ringing any bells yet
04:24:34 <julianleviston> MarcelineVQ: thanks
04:24:53 <Taneb> An example is, if I have a function "f :: forall a. a -> [a]", I know that all the elements of the output must be the same as the value I gave it as input, and no matter what I give it, the output will have the same length
04:25:33 <idnar> like how fmap f . fmap g = fmap (f . g) is free given fmap id = id
04:27:43 <idnar> so you only have to prove the latter in Haskell
04:28:40 <Ianulus> It's called theorems for free:
04:28:42 <Ianulus> https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf
04:29:00 <Ianulus> https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/
04:30:12 <Ianulus> Oh, that first link was pasted before ;)
04:41:09 <julianleviston> I love that Wadler often presents simple-seeming ideas that are actually mindblowing
04:41:36 <julianleviston> I really have to get back to his agda book sometime
04:42:15 <julianleviston> I find his material so much more approachable than‚Ä¶ others
04:45:48 <Ianulus> You know that in medieval Latin, writers often expressed stuff in an excessively complicated way, just to prove how smart they were...
04:46:57 <tdammers> people still do that in modern German
04:50:07 <boxscape> hmm https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html says that the max size for tuples is 100 yet it is actually 62
04:53:50 <boxscape> I find it somewhat amusing to me that it says "This limitation is easily subvertible, so please ask if you get stuck on it", just because it's pretty hard to imagine that someone will find a legitimate usecase for tuples with size > 100 and that GHC will be changed to allow this because one person has such a usecase and asked
04:59:35 <fishooter> how do I encode Null terminate character, i.e. \0 as Word8?
04:59:57 <fendor> boxscape, wasnt there also somewhere an issue regarding tuple size and simd? where 64 tuples where required and the type was generated but you could not actually call the code?
05:00:17 <fishooter> I'm writing a git parser, and the header is separated by \0
05:00:23 <fishooter> from the body
05:00:52 <boxscape> fendor https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/src/GHC.Tuple.html "Manuel says: Including one more declaration gives a segmentation fault"
05:01:21 <boxscape> fishooter I believe that's just `0 :: Word8`?
05:01:25 <boxscape> > ord '\0'
05:01:28 <lambdabot>  0
05:02:02 <boxscape> fendor ah wait I missed the part about simd
05:02:22 <fishooter> aah, ok. I thought I could convert Char to Word8
05:02:23 <boxscape> haven't read about that in relation to tuples
05:02:29 <fishooter> but that doesn't work unfortunately
05:02:45 <boxscape> > fromIntegral (ord '\0') :: Word8 -- fishooter
05:02:49 <lambdabot>  0
05:02:57 <fendor> boxscape, https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#v:packInt8X64-35-
05:03:26 <fishooter> ok, thanks!
05:03:52 <fendor> 64 tuple that you can not construct, afaict
05:03:55 <Eugleo> Hey. What's the latest and greatest IDE experience for VSCode/Atom/similar non-emacs non-vim editor?
05:04:10 <boxscape> fendor ah, neat
05:04:56 <Eugleo> It's been a year since I've programmed in Haskell, then I've been using https://github.com/dramforever/vscode-ghc-simple
05:05:00 <fendor> Eugleo, imo, ghcide or hie
05:05:46 <Eugleo> I'll look into them. What are the differences, roughly? Ghcide sounds more lightweight, is that it?
05:06:02 <Ianulus> fendor: BTW thanks for your help last night. all-hies working now with vscode as expected (after compiling for hours).
05:06:06 <argent0> hi, I'm trying to write an entity-component-system effect using fused effects. But having trouble with the carrier code. Concretely, I want to update a Reader value and continue the computation (simulating the state effect, wiht a different interface). But the `Reader` content isn't updating. Any idea what could be the problem?
05:06:11 <merijn> fishooter: You can't convert Char to Word8 and anyone who says otherwise is lying and should be arrested >.>
05:06:36 <fendor> Ianulus, oh no, did you not se cachix? with cachix it takes only a minute or two
05:06:47 <argent0> here's the code so far: https://bpaste.net/Y7PA
05:07:08 <boxscape> > fromIntegral (ord '„ÇÅ')
05:07:11 <lambdabot>  12417
05:07:19 <boxscape> > fromIntegral (ord '„ÇÅ') :: Word8
05:07:22 <lambdabot>  129
05:08:44 <boxscape> merijn you can, it's just not injective :P
05:09:14 <Uniaika> % ord '„ÇÅ'
05:09:14 <yahb> Uniaika: 12417
05:09:30 <Ianulus> fendor: I added it to configuration.nix as per instructions, and it started compiling on nixos-rebuild. Maybe I missed some instruction on adding a channel? I'm not too experienced with NixOS.
05:11:03 <fendor> Ianulus, poor you. I dont know how it works with configuration.nix, but maybe it is worth an issue to clarify stuff? It should not have taken a few hours
05:14:07 <Ianulus> fendor: I'm a little reluctant to open issues when I don't know much about the system.
05:14:33 <Ianulus> fendor: but this line looks to me like it should compile:
05:14:45 <Ianulus> let   all-hies = import (fetchTarball "https://github.com/infinisil/all-hies/tarball/master") {};
05:15:32 <Ianulus> As I understand NixOS, binary cache connection is set up through channel, no?
05:16:16 <fendor> cachix works a bit differently, I think. Did you try to set it up? E.g. `cachix use all-hies`
05:17:26 <Ianulus> I didn't since I didn't know about cachix until five minutes ago ;)
05:17:58 <fendor> I should have mentioned it :/ https://github.com/Infinisil/all-hies#cached-builds
05:20:50 <Ianulus> That's okay. It compiled while I was sleeping. Biggest issue is that it blew up my .vmdk to 40 GB.
05:21:19 <julianleviston> thanks for the help all :wave
05:25:07 <fendor> Ianulus, yeah, you should probably only install hie for the versions you actually use. E.g. only ghc 8.6.5 or something like that
05:26:37 <Ianulus> @fendor: I did ghc882 ghc864 ghc865
05:26:38 <lambdabot> Unknown command, try @list
05:27:12 <fendor> Would not have expected this to be 40GB big
05:29:06 <boxscape> what was the size of the .vmdk before?
05:29:22 <Ianulus> It isn't, I guess it's due to transient output during compilation, and .vmdk's don't automatically shrink back down.
05:29:35 <Ianulus> about 15GB
05:29:40 <boxscape> I see
05:37:24 * hackage taskell 1.9.3.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.9.3.0 (smallhadroncollider)
05:42:32 <Ianulus> fendor: Also, It's completely my fault, since cachix ist prominently featured in the all-hies readme.
05:45:24 * hackage debian 4.0.2 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-4.0.2 (ClintAdams)
05:53:36 <hseg> I'm looking to express the fact that my function has finite support (i.e. it is equal to 0 everywhere except for finitely many inputs). Has this been done?
05:54:46 <fishooter> how can I change the ByteString from Data.ByteString.Lazy to String?
05:54:56 <hseg> (can't just blithely pass the function around, since i want to do f * g = \m -> sum [f k * g l | k <- dom f, l <- dom g, k+l=m]
05:54:57 <fishooter> I've only found toString method in Data.ByteString.UTF8
05:55:05 <fishooter> by those seem not compatible
05:55:18 <hseg> relying on the fact that all other inputs can be ignored
05:56:23 <__monty__> fishooter: toStrict
05:57:11 <__monty__> Oh, you want a String? Yeah then you're gonna need something that handles the appropriate encoding.
05:57:33 <__monty__> Don't use ByteStrings for text unless you know what you're doing.
05:58:34 <Ianulus> hseg: Isn't this a pullback? Maybe research how to handle pullbacks in Haskell.
05:59:32 <hseg> Ianulus: that's a bit of a red herring
05:59:37 <boxscape> it seems like something that should be fairly easily encodable as a map but I don't know how that encoding would relate to a pullback
05:59:46 <hseg> Ianulus: and am not even sure that that is correct
06:00:28 <hseg> boxscape: right, so i'd want something like (Representable f, Rep f ~ Finite n) ish
06:00:38 <fishooter> __monty__: haha, well I'm not sure what I'm doing, but I need it for zlib 
06:00:54 <hseg> boxscape: which can be weakened to just Representable f, but I'd still need dom
06:01:04 <fishooter> I'm implementing a simple git client, and git compresses its objects
06:01:11 <hseg> ... does Data.Map always have finite support?
06:01:14 <Ianulus> hseg: Me neither, I'm just learning this stuff myself. Sorry.
06:01:30 <fishooter> and I'd like to lazily load header of the object and convert it to string, so that I know which object type it is
06:02:03 <hseg> Ianulus: np
06:02:14 <hseg> ... gotta duck out, brb
06:03:00 <solonarv> hseg: Data.Map breaks when it has more than maxBound::Int entries
06:03:21 <__monty__> fishooter: If you know it's ascii or utf8 one of the decode* functions from the text package might be best suited.
06:04:35 <fishooter> yes it is ascii.
06:04:41 <solonarv> hseg: if the support is *finite* as in "finite cardinality", and it isn't too large, you can just carry along a Set which says what the domain is
06:18:27 <fishooter> how can I make a sequence of parsing steps in a do-block, so that if one fails Nothing is returned, and if previous steps succeed the Just value is unpacked?
06:18:39 <fishooter> example: https://repl.it/repls/FortunatePiercingSemicolon
06:18:58 <fishooter> I'd like to get the object type, but spacePos is of type Maybe Int
06:19:35 <fishooter> I need to unpack it's value before I can use take
06:19:57 <fishooter> so basically, I want parsing to proceed only if all steps are ok, and if not, Nothing is returned
06:21:07 <tdammers> look into Maybe's Monad instance
06:21:18 <tdammers> if you need that on top of some other monadic type, consider MaybeT
06:21:36 <tdammers> you can also use EitherT or ExceptT/ErrorT in case you want to attach error information to the failure
06:21:50 <__monty__> elemIndex returns Maybe Int so the binding to spacePos should already result in an Int.
06:22:03 <fishooter> I don't need to attach other error that's fine
06:22:16 <fishooter> basically I'd like to build the grandfather example: https://en.wikibooks.org/wiki/Haskell/Understanding_monads#Motivation:_Maybe
06:22:22 <tdammers> alright then, Maybe/MaybeT it is
06:22:25 <fishooter> but with different types of Maybes
06:22:34 <tdammers> different types of maybes?
06:22:43 <__monty__> fishooter: Replace `spacePos` with `(spacePos :: _)` and typecheck the code.
06:23:00 <tdammers> > Just [1,2,3] >>= listToMaybe
06:23:03 <lambdabot>  Just 1
06:23:09 <tdammers> :t Just [1,2,3]
06:23:10 <lambdabot> Num a => Maybe [a]
06:23:11 <tdammers> :t listToMaybe
06:23:13 <lambdabot> [a] -> Maybe a
06:23:22 <fishooter> tdammers: well, I have Maybe Int for the pos, and I want to have Maybe GitObject at the end
06:23:32 <tdammers> that's fine, the bind operator can deal with that
06:23:39 <tdammers> see my example right above
06:24:18 <tdammers> > Just 1 >>= \x -> case x of { 1 -> Just "hello"; _ -> Nothing }
06:24:21 <lambdabot>  Just "hello"
06:24:36 <tdammers> see, I can have a Maybe Int on the left of the >>=, and an Int -> Maybe String on the right
06:24:38 <tdammers> no problem
06:24:42 <__monty__> fishooter: No, spacePos is already of type Int, not Maybe Int.
06:24:44 <tdammers> :t (>>=)
06:24:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:25:33 <fishooter> __monty__: ah, because it has already been bound right?
06:26:08 <__monty__> Yes, it's already been passed to bind, in the desugared version.
06:26:36 <fishooter> ah I see, so I needed to use
06:26:37 <fishooter> let objType = B.take spacePos raw
06:26:43 <fishooter> now it typechecks
06:26:44 <fishooter> thanks!
06:34:23 * hackage hafar 0.1.0.0 - Affine arithmetic library for Haskell  https://hackage.haskell.org/package/hafar-0.1.0.0 (j_jaager)
06:40:25 <fishooter> hmm, the decodeUtf8 makes it into Data.Text.Internal.Text, not String
06:43:13 <Uniaika> is that really a problem? ;)
06:43:25 <fishooter> seems that "UTF8.toString . B.toStrict" did the trick
06:43:31 <Poscat[m]> Hi all. Are there any workarounds of this bug https://github.com/haskell/cabal/issues/1906 for stack?
06:43:59 <fishooter> Uniaika: I don't know, I guess I'd rather work with Strings since they are builtin
06:44:24 <Poscat[m]> The bug is that c2hs import hook are completely ignored by cabal which can lead to wrong build order.
06:44:39 <Uniaika> fishooter: they are the shittiest of the builtins, trust me
06:44:56 <Uniaika> Text is as standard as String and performs better
06:45:17 <fendor> I am experimenting with TH and uniplate, and this doesnt compile: https://gist.github.com/fendor/c626bbe62cc7fc5e3fc845196de146be
06:45:38 <boxscape> fishooter epending on what you're doing, not using String gets more palatable if you use -XOverloadedStrings
06:45:50 <boxscape> fishooter that means String literals can be interpreted as Text and other types as well
06:45:53 <fendor> it says it happens it does not have an instance, but it looks like there is an instance for all Data? https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
06:46:07 <__monty__> fishooter: String is a linked list of utf-8 (or 16) encoded characters (or is it codepoints?). I think it takes two 64 bit words per character stored?
06:46:10 <fendor> and Exp is Data as well
06:46:39 <boxscape> > logBase 2 $ fromIntegral (ord (maxBound :: Char))
06:46:42 <lambdabot>  20.087461546321563
06:46:54 <boxscape> 20 bits?
06:47:13 <boxscape> I do believe it is code points __monty__
06:47:56 <int-e> > showHex (ord (maxBound :: Char)) ""
06:47:59 <lambdabot>  "10ffff"
06:48:15 <__monty__> boxscape: I'm not sure the range of Char reflects the number of bits required for its storage, String is not a packed format afaik? And you're not counting the pointers for the list part.
06:48:20 <boxscape> ah, true
06:49:32 <boxscape> apparently "Following the ISO-10646 standard, maxBound :: Char in GHC is 0x10FFFF", fwiw
06:50:39 <__monty__> I guess that's the range for UTF-16?
06:50:52 <tdammers> String is most certainly not utf-8 encoded. It's literally [Char], and because a Char represents a codepoint, that means String is a linked list of Unicode code points
06:51:04 <tdammers> not utf-8, not utf-16, not utf-anything
06:51:14 <tdammers> it's not encoded at all, it's a linked list of raw code points
06:52:05 <tdammers> all the utf-something encodings are specifications telling you how to take a raw, storage-agnostic stream of code points and convert it into a portable sequence of octets
06:52:06 <int-e> boxscape: Yes, that's where the number comes from.
06:53:46 <__monty__> tdammers: Thanks for the correction.
06:54:10 <tdammers> __monty__: it's important, because this distinction is probably the #1 source of confusion with all things unicode
06:54:18 <tdammers> or with strings in general, really
06:54:32 <int-e> ghc actually uses whole machine words to store code points. Plus the usual header, so a Char can take up 16 bytes on the heap.
06:54:46 <__monty__> All this being said, I'm not sure fishooter wants to use strict Text. They mentioned lazy reading.
06:54:55 <boxscape> int-e how large is the usual header?
06:55:02 <__monty__> tdammers: There was no sarcasm in my message.
06:55:36 <tdammers> __monty__: none was assumed.
06:56:06 <tdammers> anyway, if you want lazy reading, lazy text is probably not the cleanest solution. nor is String.
06:56:22 <int-e> boxscape: Usually one word (a pointer to an info table) for evaluated data, two (a pointer to an info table and one word for locking) for thunks.
06:56:42 <tdammers> the problem with these lazy types is that if you combine them with lazy I/O for purposes of streaming, you're in for some nasty surprises
06:56:45 <boxscape> I see, thanks
06:57:58 <__monty__> Kinda amazing String is at all useful : )
06:58:40 <tdammers> because if you do something like: open file; read file -> var; close file; process var; then the code looks like you should have read all of the file's contents into var by the time you close the file - but you haven't because the read was lazy, you have in fact only read the first buffer, and then halfway through your processing, you ask for the next buffer, but oh dear, the file has already been closed
06:59:11 <merijn> __monty__: GHC doesn't used UTF-16 internally
06:59:33 <merijn> __monty__: Also, UTF-16 and UTF-16 (and really all the UTFs) have the same number of codepoints, so that wouldn't even make sense :p
07:00:03 <fendor> for anyone interested, you have to import `Data.Generics.Uniplate.Data`
07:00:10 <int-e> boxscape: The real story is more complicated; look how StgHeader and StgThunkHeader are defined in https://gitlab.haskell.org/ghc/ghc/blob/master/includes/rts/storage/Closures.h
07:00:59 <__monty__> merijn: Yes, tdammers made the distinction clear. I did try to make it clear in my message that I'm not a unicode expert.
07:01:25 <int-e> merijn: It does make sense, because the defined UTF-16 encoding has a hard upper limit at 0x10FFFF.
07:02:09 <merijn> int-e: That's not a utf-16 upper limit, that's the upper limit of any unicode codepoint per the current unicode standard
07:02:36 <merijn> int-e: So by that logic UTF-32 and UTF-8 also have "a hard upper limit at 0x10FFFF"
07:02:52 <int-e> merijn: Yes but if you wanted to increase it, you could do so without affecting UTF-8 or UTF-32; only UTF-16 would need to be changed.
07:03:02 <merijn> what
07:03:26 <merijn> That comment doesn't parse
07:04:10 <merijn> The notion of "increasing the upper limit of UTF-16 without affecting UTF-8/UTF-32" is nonsensical to me
07:04:43 <int-e> merijn: UTF-8 would have room up to 0x1FFFFF with the currend encoding.
07:04:58 <int-e> *current.
07:05:25 <fishooter> ah, so Text is like a more efficient implementation of String, and {-# LANGUAGE OverloadedStrings #-} makes them being the same?
07:05:37 <tdammers> not quite
07:05:45 <fishooter> I'm implementing this: https://wyag.thb.lt/#org8f9d097
07:05:46 <Taneb> fishooter: OverloadedStrings just makes string literals polymorphic
07:05:50 <tdammers> Text is a "proper" string type, as opposed to String, which is just a linked list of characters
07:05:51 <nshepperd1> utf-16 can't represent numbers larger than 0x10FFFF i guess
07:05:53 <fishooter> this is what I have so far https://repl.it/repls/FortunatePiercingSemicolon
07:05:54 <merijn> fishooter: No, OverloadedStrings (as the name implies) makes string literals in your source overloaded (via the IsString typeclass)
07:05:58 <tdammers> but OverloadedStrings doesn't make them the same
07:06:03 <nshepperd1> it uses that weird surrogate pair thing
07:06:14 <tdammers> it just means that a string literal "foo" is automatically converted to fromString "foo"
07:06:15 <int-e> nshepperd1: Yes that's what I'm trying to say.
07:06:17 <tdammers> :t fromString
07:06:18 <merijn> fishooter: That can be used to write string literals "as if" they're Text, but it doesn't make Text and String equal
07:06:19 <lambdabot> IsString a => String -> a
07:06:36 <tdammers> which means that you can now write values of any types that has an IsString instance as string literals
07:06:48 <tdammers> including Text, but, due to unfortunate historical accident, also ByteString
07:07:10 <merijn> tdammers: Only if you import the vilest of evil modules
07:07:34 <fishooter> ok makes sense
07:07:49 <tdammers> merijn: oh, so Data.ByteString is now the vilest of evil modules?
07:08:04 <fishooter> what would you do differently here? https://repl.it/repls/FortunatePiercingSemicolon
07:08:07 <merijn> tdammers: Data.ByteString doesn't export the instance, afaik
07:08:14 <fishooter> I need to use ByteString because of zlib
07:08:29 <tdammers> merijn: it does.
07:08:32 <tdammers> https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/src/Data.ByteString.Internal.html#line-179
07:08:52 <merijn> gh
07:08:53 <merijn> ugh
07:09:13 <merijn> fishooter: Data.Text.Encoding has methods for encoding Text into ByteString
07:09:34 <fishooter> I rather need it the other way around
07:09:42 <merijn> fishooter: That too ;)
07:09:42 <tdammers> it has that too
07:09:55 <merijn> fishooter: decodeUtf8' :: ByteString -> Either UnicodeException Text
07:09:56 <fishooter> ok :)
07:10:05 <merijn> (Assuming UTF-8, but it has others too)
07:10:05 <fishooter> yes, that's what I've used before :)
07:10:40 <fishooter> so If I use the compiler header, then I can use `elem` on that list, correct?
07:10:51 <__monty__> No
07:10:53 <fishooter> *compiler flag, I mean {-# LANGUAGE OverloadedStrings #-}
07:11:08 <__monty__> It's a LANGUAGE pragma.
07:11:19 <fishooter> ok
07:11:27 <tdammers> OverloadedStrings does not magically turn Text and String into the same type
07:11:31 <__monty__> But you would end up with a Text literal or a ByteString literal, etc.
07:11:40 <fishooter> that's why I have the UTF8.toString, otherwise I'd use the decodeUTF8
07:11:49 <tdammers> it just changes the type of string literals from String to IsString a => a
07:11:53 <__monty__> Hmm, literal isn't even quite the correct term, just value I guess.
07:12:21 <__monty__> But if you have a Text value you can only use functions that operate on Text values.
07:15:34 <reallymemorable> i have a sensor that puts values in a postgres table and im using postgresql-simple to read them out in my `main :: IO ()` function with `return queryResult` after `queryResult <- mapM_ print =<< (query_ conn "select sensor1 from lightbool" :: IO [Only String])`
07:15:59 <reallymemorable> i need to convert these values with another function (‚ÄúlightBoolHandler‚Äù)
07:16:31 <reallymemorable> basically it needs to take the contents of a query and produce a list of haskell bools
07:16:59 <reallymemorable> i guess i need to go lightBoolHandler :: [Only String] -> [Bool]
07:17:30 <reallymemorable> how can i make the contents/result of that IO action availble to other parts of the .hs file?
07:18:35 <anon136> hi. im trying to follow this guide here https://haskell-at-work.com/episodes/2018-11-13-gtk-programming-with-haskell.html to make a simple gui. its my first time trying to use dependencies. it calls for gi-gtk and haskell-gi-base as dependencies in the .cabal. the guide doesnt explain anything about using those dependencies. i supposed i needed to
07:18:36 <anon136> do something like cabal install gi-gtk in the command line. but that isnt working. 
07:20:41 <anon136> am i on the right track and need to fix cabal? or is that not even the right idea for how to get dependencies like that?
07:21:24 * hackage heatitup-complete 0.5.4.1 - Find and annotate ITDs with assembly or read pair joining.  https://hackage.haskell.org/package/heatitup-complete-0.5.4.1 (GregorySchwartz)
07:22:15 <geekosaur> probably v1-install or sandboxes, since it's not expecting v2 cabal install which is intended for complete programs
07:22:33 <geekosaur> I don't recommend v1-install, it's a good way to make messes.
07:23:01 <geekosaur> cabal sandbox init, then use v1-install in the sandbox
07:23:45 <anon136> by "in the sand box" you just mean be in the directory it creates when i do it?
07:24:09 <geekosaur> the directory you ran "cabal sandbox init" in
07:24:20 <anon136> okay ill give that a try
07:24:57 <geekosaur> th right way to do this is to find instructions for new-style cabal which manages all this stuff for you :)
07:27:00 <anon136> well im certainly not far into this project
07:27:30 <anon136> any advise for learning to make a simple gui the simplest most understandable way for a dummy?
07:29:40 <merijn> Honestly, I don't think there really are any "simple ways" to make GUIs in haskell right now. With, maybe,  the exception of deech's ftlkhs, but that doesn't make the prettiest GUIs
07:30:35 <anon136> perhaps I could just use qt with pyton or w/e to make all the surface level stuff, and use haskell just to do some heavy lifting
07:30:44 <kquark> Hi, I am new to Haskell, got a doubt on syntax seen in yesod example . 
07:31:18 <kquark> What does   ' type Content a  mean in following code ? 
07:31:24 <kquark> class SafeHead a where
07:31:24 <kquark>     type Content a
07:31:24 <kquark>     safeHead :: a -> Maybe (Content a)
07:31:34 <geekosaur> it''s an associated type synonym
07:31:58 <geekosaur> this isn't part of standard Haskell, type families and associated types are an extension
07:32:02 <kquark> so is it like Content is a synoym for a  ? 
07:32:09 <kquark> Ok 
07:32:24 <geekosaur> when defining an instance, you'd have to specify a type for Content
07:32:28 <kquark> so type families are not type  classes ?  I am right ? 
07:32:39 <geekosaur> they are not
07:33:04 <kquark> i got confused initially  .  Thanks buddy 
07:34:07 <kquark> geekosaur++ 
07:34:21 <kquark> back to reading yesod  docs .
07:37:18 <geekosaur> yesod might not be the best starting point; it uses a lot of advanced features
07:43:13 <kquark> suggest something for web ; i want to write everything in haskell ; need dynamic pages also.
07:43:48 <kquark> looked into miso , reflex-frp etc . miso looks cool. what do u think ? 
07:44:01 <dminuoso> kquark: I'd recommend not starting with the web.
07:44:48 <kquark> yeah, but i am in position . web is a requirement ; not an option ; 
07:44:49 <dminuoso> Web applications by design inherit a lot of complexity because of the many moving parts, using different technologies, requiring different abstractions. If you mix this while learning a new language that creates changing how you think about programming, it might create additional hurdles.
07:45:08 <dminuoso> *that requires changing how you think
07:45:29 <kquark> i am exposed to FP , did some erlang stuff  
07:46:25 <dminuoso> The cross section of what erlang considers functional programming and what Haskell does is rather slim.
07:46:30 <kquark> also went thru Elm  then to purescript and i am here at Haskell 
07:47:02 <merijn> :q
07:47:18 <merijn> Apparently, this is not vim ;)
07:47:21 <kquark> yes , erlang is more into actor stuff.  Haskell's laziness makes things entirely different ; also the type system 
07:47:54 <dminuoso> kquark: How familiar are you with PureScript and/or Elm?
07:48:36 <kquark> Elm -> Just read the docs almost all in the site ;  Richard Feldman videos etc ; no real code  
07:49:00 <kquark> Purecript -> We thru the book ; midway realized that there is Haskell 
08:00:24 * hackage heatitup-complete 0.5.5.0 - Find and annotate ITDs with assembly or read pair joining.  https://hackage.haskell.org/package/heatitup-complete-0.5.5.0 (GregorySchwartz)
08:34:23 * hackage monad-bayes 0.1.0.0 - A library for probabilistic programming.  https://hackage.haskell.org/package/monad-bayes-0.1.0.0 (curiousleo)
09:33:42 <altern> Hi all
09:33:56 <altern> I am having 'problem' with zipWith
09:34:08 <altern> > zipWith ($) [isJust, isNothing] [Just 1, Nothing]
09:34:08 <altern> [True,True]
09:34:10 <lambdabot>  [True,True]
09:34:48 <altern> zipWith ($) [isJust, isNothing] [Just 1]
09:35:07 <altern> > zipWith ($) [isJust, isNothing] [Just 1]
09:35:10 <lambdabot>  [True]
09:35:59 <altern> how do I make it return the result of the same length as a length of functions list?
09:36:30 <altern> for example zipWith ($) [isJust, isNothing] [Just 1] -> [True, False]
09:37:09 <altern> I want function to return False if there is no argument
09:37:56 <berndl> altern: Extend the list with Falses at the end?
09:38:12 <altern> @berndl: yep, smth like that
09:38:13 <lambdabot> Unknown command, try @list
09:48:22 <altern> found the solution
09:48:33 <altern> > zipWith ($) listOfBoolFunctions list ++ (replicate (length listOfBoolFunctions - length list) False)
09:48:36 <lambdabot>  error:
09:48:36 <lambdabot>      Variable not in scope: listOfBoolFunctions :: [a0 -> Bool]error:
09:48:36 <lambdabot>      ‚Ä¢ Variable not in scope: list :: [a0]
09:49:26 <dminuoso> Why is it, that IO everywhere is so easy, whereas thinking algebraic seems harder initially? Im staring code that is, essentially, just pretty printing some large structure - and the author decided to just traverse everything and then step-by-step print the whole thing, rather than say constructing a large prettyprinter document.
09:49:38 <altern> > let listOfBoolFunctions = [isJust, isNothing]; let list = [Just 1]; zipWith ($) listOfBoolFunctions list ++ (replicate (length listOfBoolFunctions - length list) False)
09:49:41 <lambdabot>  <hint>:1:169: error:
09:49:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:50:07 <dminuoso> And trying to remove all the ad-hoc print mess seems to require far more effort.
09:50:50 <berndl> dminuoso: algebra is hard
09:53:53 * hackage hpath-directory 0.13.2 - Alternative to 'directory' package with ByteString based filepaths  https://hackage.haskell.org/package/hpath-directory-0.13.2 (maerwald)
09:56:56 <tabaqui1> % ($) <$> [isJust, isNothing] <*> [Just 1]
09:56:56 <yahb> tabaqui1: [True,False]
09:57:10 <tabaqui1> Applicative returns you n*m values
09:57:15 <tabaqui1> % ($) <$> [isJust, isNothing] <*> [Just 1, Nothing]
09:57:15 <yahb> tabaqui1: [True,False,False,True]
09:58:30 <tabaqui1> cycle maybe be usefull here
09:58:36 <tabaqui1> % take 10 $ cycle [2,3,4]
09:58:36 <yahb> tabaqui1: [2,3,4,2,3,4,2,3,4,2]
09:59:10 <tabaqui1> altern: ^
10:40:59 <dsal> Yay, I finally have one deployed thing built with ghc 8.8.  Many of my most useful things require sqlite, which has a fail.
10:42:48 <__monty__> dsal: I think merijn talked about having fixed some persistence-sqlite problems for 8.8 and 8.10 as well I think.
10:43:33 <dsal> I'm using sqlite-simple.  The bug's been open for a while, but maybe getting some attention now that it can't be used with stackage lts.
11:17:46 <tabaqui1> uh
11:17:56 <tabaqui1> what is the status of HDBC-sqlite in that case?
11:18:14 <tabaqui1> *HDBC-sqlite3
11:23:07 <remexre> any hints for getting n properly in scope? https://p.acm.umn.edu/XBUmcjFWQAE=
11:23:26 <remexre> (alternatively https://repl.it/repls/BowedKnottyTriangles if you prefer it)
11:40:47 <d34df00d> megaparsec doesn't do left factoring of the grammar does it?
11:45:53 <Franciman> it don't
11:46:07 <Franciman> cuz it would become an infinite loop
11:46:27 <Franciman> it don't have preprocessing, i think
11:46:49 <Franciman> since you directly write the grammar as fucnctions
11:47:18 <d34df00d> On the other hand, megaparsec is stateful, so I can probably use the state to mark the first entry to the corresponding rule and then fail immediately on subsequent states.
11:47:23 <d34df00d> s/states/entries/
11:47:41 <d34df00d> Wonder how ugly that is.
11:49:29 <reallymemorable> i want to write a function that takes two lists as arguments and chooses the longer one
11:49:50 <reallymemorable> i figure i neeed to run `length list` on both
11:50:23 <Clint> "need" seems strong
11:50:44 <reallymemorable> but i dont understand the mechanism to then choose the longer list itself
11:50:51 <reallymemorable> not just the Int value of its length
11:51:38 <hseg> Is there some library implementing functions with finite support? (ie 0 on all but finitely many inputs)
11:52:24 <hseg> would then want to say that Map implements such a class
11:52:42 <hseg> motivation: writing f * g = \m -> sum [f k * g l | k <- dom f, l <- dom g, k+l=m]
11:53:15 <hseg> (the k+l=m filter isn't enough since the index spaces of f,g can be infinite)
11:53:40 <hseg> (eg consider f,g :: Num a => Integer -> a here)
12:04:10 <reallymemorable> somethiing like this identifies the largest list `largestList x y = max (length x) (length y)`
12:04:32 <reallymemorable> but i want to return the list itself ‚Äî not the value of it‚Äôs length
12:05:52 <hseg> :t on
12:05:54 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:06:09 <hseg> :t max `on` length
12:06:11 <lambdabot> Foldable t => t a -> t a -> Int
12:06:27 <hseg> :/ not exactly what we want
12:07:40 <hseg> reallymemorable: btw, what should largestList [0,1] [2,3] be?
12:08:42 <reallymemorable> good point ‚Äî this is part of a larger operation where another function grabs the head of a list and keeps using `head`s value until a longer list shows up, so then it swaps in the new `head`
12:08:58 <reallymemorable> so for my purposes, i dont think that case really matters
12:09:19 <reallymemorable> the lists are sensor readings from one sensor
12:09:27 <maerwald> has anyone seen this: hPutBuf: invalid argument (illegal buffer size (-949))
12:09:38 <hseg> right, you can decide arbitrarily
12:09:44 <reallymemorable> yeah
12:09:47 <hseg> well
12:09:53 <hseg> :t compare `on` length
12:09:55 <lambdabot> Foldable t => t a -> t a -> Ordering
12:10:33 <hseg> so if you can find some generalization of if that takes an ordering and does what you want, you're golden
12:11:15 <hseg> a quick hoogle suggests Control.Conditional.if' but this is specific enough i'd recommend writing your own
12:14:01 <hseg> any ideas re finitely-supported functions?
12:14:50 <reallymemorable> ok so i guess i could use `compare` and if the result is GT, use that value, else use the old one
12:15:20 <idnar> :t maximumBy (comparing length)
12:15:23 <lambdabot> (Foldable t1, Foldable t2) => t1 (t2 a) -> t2 a
12:16:23 <reallymemorable> idnar: that looks close to what i want
12:16:29 <reallymemorable> but i dont want the max value of the list
12:16:37 <reallymemorable> i just want the `head` of the llarger list
12:17:15 <hseg> idnar: good catch
12:17:56 <hseg> reallymemorable: then postcompose the above with head
12:18:02 <idnar> :t head . maximumBy (comparing length)
12:18:03 <lambdabot> Foldable t => t [c] -> c
12:18:23 <hseg> > maximumBy (comparing length) [0,4,5,6] [1,3]
12:18:26 <lambdabot>  error:
12:18:26 <lambdabot>      ‚Ä¢ Could not deduce (Foldable ((->) [a0]))
12:18:26 <lambdabot>        from the context: (Foldable ((->) [a]), Num a, Num ([a] -> t))
12:18:31 <idnar> :t first . maximumBy (comparing length)
12:18:33 <lambdabot> (Arrow a, Foldable t, Foldable (a b)) => t (a b c) -> a (b, d) (c, d)
12:18:46 <idnar> oh no
12:19:05 <hseg> hrm. am i misremembering lambdabot's ghci syntax?
12:19:25 <ChaiTRex> hseg: I don't think maximumBy takes two lists.
12:19:36 <hseg> oh, right
12:19:43 <hseg> > maximumBy (comparing length) [[0,4,5,6],[1,3]]
12:19:46 <lambdabot>  [0,4,5,6]
12:20:18 <hseg> reallymemorable: ^
12:20:26 <hseg> > maximumBy (comparing length) [[0,4],[1,3]]
12:20:30 <lambdabot>  [1,3]
12:21:34 <hseg> q: reading https://gist.github.com/Icelandjack/aecf49b75afcfcee9ead29d27cc234d5, what is this syntax:   fmap f (MkBuild as) = MkBuild (if | Yoneda yo <- as -> yo f)
12:22:16 <reallymemorable> ah
12:22:18 <reallymemorable> yes
12:22:21 <reallymemorable> thank you
12:22:22 <hseg> ( newtype Build :: ((k -> Type) -> Constraint) -> (k -> Type) where { MkBuild :: (forall zz. cls zz => zz a) -> Build cls a } )
12:32:42 <hseg> any explanations for this syntax?
12:35:53 * hackage base16 0.1.0.0 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.1.0.0 (topos)
12:36:09 <idnar> hseg: `if |` is MultiWayIf
12:36:32 <koala_man> I remember seeing some idiom for defining an Ord 'compare' instance that compares multiple fields of a record lexicographically, but now I can't find it. Does anyone know what I could be thinking of?
12:36:40 <idnar> I think
12:37:04 <topos> @ hvr ^ here's the base16 replacement
12:37:12 <topos> i'll have optics up later today
12:37:23 <topos> only one more encoding lib to go \o/
12:37:36 <hseg> ty
12:38:53 <merijn> Life pro-tip: Don't take coding advice/snippets from Iceland_Jack unless you like pain and confusion :p
12:40:00 <hseg> so (if | Yoneda yo <- as -> yo f) is just another way of writing (\(Yoneda yo) -> yo f) as ?
12:40:30 <hseg> merijn: fair. but those snippets are sometimes too cool to pass up
12:41:06 <koz_> merijn: Makes for fascinating viewing though!
12:54:15 <solonarv> koankeeper: yes - you can use <> to combine Ordering's lexicographically
12:54:54 <solonarv> additionally you might be able to use the Semigroup instance for functions to write it all in point-free fashion, like so:
12:55:07 <merijn> Ah, we're talking about the best monoid instance!
12:55:11 <solonarv> data Foo = Foo { fooA, fooB :: ... }
12:55:23 <solonarv> instance Ord Foo where compare = comparing fooA <> comparing fooB
12:55:55 <koz_> merijn: I thought that was (a -> m) where m is a Monoid?
12:56:01 <merijn> koz_: Yes
12:56:13 <merijn> koz_: Which is what solonarv's using there in his example ;)
12:56:23 <koz_> merijn: LOL, I guess I should read more carefully.
12:56:30 <merijn> :t comparing
12:56:32 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:57:20 <merijn> > EQ <> LT
12:57:23 <lambdabot>  LT
12:57:27 <merijn> > EQ <> GT
12:57:29 <lambdabot>  GT
12:58:00 <solonarv> instance Semigroup Ordering where EQ <> y = y; x <> _ = x
12:58:03 <merijn> koala_man: Basically, the monoid on Ordering returns the "left-most non-EQ Ordering" (EQ being the identity)
12:58:48 <merijn> koala_man: So mappend'ing multiple ends up ordering by the left most Ordering first, then the 2nd, etc.
12:59:50 <merijn> koala_man: Which combines nicely with the best Monoid instance: "instance Monoid m => Monoid (a -> m) where mempty = const mempty; mappend f g = \x -> f x <> g x"
13:00:30 <merijn> koala_man: (Which applies recursively, so since Ordering is a Monoid "b -> Ordering" is one and since that's a Monoid, so is "b -> b -> Ordering")
13:00:56 <solonarv> oh oops, I pinged the wrong person..
13:09:01 <nschoe> Hi everyone. I'm getting a "renameFile:renamePath:rename: unsupported operation (Invalid cross-device link)" error when using `renameFile` to move a file from '/run/user/1000/' to, say my home '/home/nschoe/' (app crashes), but it works fine with `copyFile` and `removeFile`. Is there a reason (and a fix)?
13:10:06 <merijn> nschoe: Looks like /run is a different file system than /home and you can't rename across mountpoint
13:11:12 <hseg> Is there some library implementing functions with finite support? (ie 0 on all but finitely many inputs)
13:11:23 <hseg> would then want to say that Map implements such a class
13:11:24 <nschoe> merijn, yes indeed, /run is on tmpfs
13:11:57 <nschoe> merijn, but how come `mv` from the cmdline works?
13:16:18 <nschoe> (thanks btw ^^)
13:19:04 <merijn> nschoe: Maybe it uses copy if rename fails?
13:21:24 * hackage base16 0.1.1 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.1.1 (topos)
13:24:24 * hackage base16-lens 0.1.0.0 - Optics for the Base16 library  https://hackage.haskell.org/package/base16-lens-0.1.0.0 (topos)
13:25:09 <koala_man> merijn: that's the one, thanks!
13:26:30 <merijn> koala_man: Note that if you have a lot of different functions to combine you can use lists + mconcat because of the monoid :)
13:27:35 <reallymemorable> is there a way to perpetually/periodically run a function after a certain time delay?
13:28:24 * hackage frisby 0.2.3 - Linear time composable parser for PEG grammars  https://hackage.haskell.org/package/frisby-0.2.3 (BenGamari)
13:29:45 <solonarv> reallymemorable: sure, there are several
13:30:06 <solonarv> the most basic is: forkIO . forever $ do myFunction; threadDelay someAmountOfTime
13:32:20 <solonarv> I wrote a library for this but it's somewhat half-baked and I haven't touched it in a while
13:32:41 <berndl> I'm getting confused between Alternative and MonadPlus in the context of parsers. Should <|> and mplus be the same or different? I've seen both in the wild.
13:32:42 <solonarv> you can get arbitrarily fancy with retry policies, persistence, and so on
13:32:54 * hackage aura 2.1.0 - A secure package manager for Arch Linux and the AUR, written in Haskell.  https://hackage.haskell.org/package/aura-2.1.0 (fosskers)
13:32:54 <dminuoso> berndl: They should be the same.
13:33:22 <dminuoso> berndl: I think Stephen Diel might partially be responsible for it, as he wrote a tutorial long time ago about parser combinators in which he wrote conflicting implementations.
13:34:14 <berndl> dminuoso: Yeah, that is one of the examples I have in mind: nanoparsec
13:35:22 <dminuoso> berndl: Perhaps it's a relict from pre-AMP times?
13:35:49 <dminuoso> Back then, coherence between MonadPlus and Alternative might not have been that obvious.
13:36:26 <berndl> But then what should p <|> q be exactly? Should it be the "parse with p first and if that fails parse with q" or should it be "parse with p and q and return both of their results"?
13:36:57 <solonarv> it should be: parse with p; if that fails, backtrack and parse with q
13:37:07 <solonarv> at least that's the usual meaning
13:37:10 <reallymemorable> solonarv: `forever` from Control.Monad?
13:37:16 <solonarv> reallymemorable: yes
13:37:17 <berndl> OK. Then what should the other one be?
13:37:24 <dminuoso> solonarv: Why *should* it be that?
13:37:27 <dminuoso> solonarv: It
13:37:38 <dminuoso> solonarv: It's at best what you'd expect based on what parser libaries have been doing.
13:37:44 <solonarv> dminuoso: because that's what all the parser combinator libraries I'm familiar with are doing
13:37:57 <dminuoso> solonarv: So obligation by familiarity?
13:38:04 <solonarv> and also, I can't really think of any other sensible semantics
13:38:40 <dminuoso> berndl: At best, `empty <|> u = u` and `u <|> empty = u` seem like reasonable laws
13:38:45 <solonarv> (also, I'm disregarding parsers like s -> [(a, s)] )
13:39:12 <merijn> solonarv: I don't think backtrack is "the usual" behaviour, else parsec and others wouldn't have explicit try ;)
13:39:12 <dminuoso> Well the semantic of failure/backtracking fits with non-deterministic parsers too
13:39:23 <dminuoso> Whether or not you backtrack is irrelevant Id say
13:39:37 <merijn> dminuoso: It is, since at least one parser (parsec) doesn't
13:40:04 <solonarv> merijn: if you don't wrap the left arg in 'try', you get to the "backtrack" step and go "whoops, can't backtrack, guess I'll die"
13:40:09 <dminuoso> solonarv: So?
13:40:10 <merijn> I'm not sure whether megaparsec does "auto-backtrack"
13:40:21 <dminuoso> solonarv: Why would it die?
13:40:28 <Tuplanolla> Only sometimes, merijn.
13:40:31 <dminuoso> Perhaps the other choice can resume on the already consumed stream.
13:40:33 <merijn> solonarv: Wrapping the left in a try is an anti-pattern :p
13:40:46 <dminuoso> merijn: If it doesnt backtrack maybe not.
13:40:50 <solonarv> dminuoso: it can, but I struggle to think of a scenario where you'd want that
13:40:54 <merijn> solonarv: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
13:41:15 <merijn> dminuoso: What would try do in a non-backtracking parser?
13:42:13 <solonarv> oh, merijn: in megaparsec a few primitives (including, importantly, 'string') auto-backtrack, but that's all
13:42:41 <dminuoso> Oh whats with the selective parsing combinator library presented at Haskell eXchange 2019? I dont think I ever saw it being published.
13:43:40 <maerwald> What's the best way to produce a ByteString with a non-zero offset?
13:44:01 <dminuoso> Ohh hooray, skillsmatter is back alive!
13:45:13 <nschoe> merijn, maybe, that's what I did in any case. Thanks for your (quick) answer :)
13:46:22 <solonarv> maerwald: 'slice' (or 'drop') on a larger bytestring?
13:47:46 <maerwald> yeah, drop works nicely
13:47:55 <shapr> Is there some way to have hackage pages automatically fold the typeclass instances? perhaps a handy cookie I can set?
13:49:31 <solonarv> maerwald: now I'm curious why you needed that specificallly
13:49:44 <maerwald> solonarv: https://github.com/psibi/streamly-bytestring/pull/9/
13:49:52 <maerwald> memory bugs testing
13:51:14 <maerwald> it was quite hard to reproduce, since most bytestrings don't have large offsets
13:51:55 <maerwald> pointer arithmetic still causing bug in 2020, even in haskell :)
13:52:37 <solonarv> ah, I figured it'd be something like that
13:56:08 <hseg> Is there some library implementing functions with finite support? (ie 0 on all but finitely many inputs)
13:56:17 <hseg> feels like it must have come up before
14:02:03 <jle`> hseg: i feel like the typical way of doing that in haskell would be to rewrite the function to have a different input finite input type
14:02:08 <jle`> and then 'parse' into that type with Maybe
14:03:18 <lyxia> what do you want to use that for
14:04:36 <hseg> implementing laurent polynomials (so negative powers of indeterminates are accepted)
14:05:05 <hseg> modeling them as Vector n Integer -> r where r is some type of coefficient
14:05:13 <hseg> but ofc (->) is wrong here
14:05:26 <hseg> bc i actually want functions of finite support
14:05:39 <hseg> this can be ignored until you try to implement multiplication
14:06:06 <hseg> where you really want to say f * g = \m -> sum [f k * g l | k <- dom f, l <- dom g, k+l=m]
14:06:39 <hseg> and while you might hack around this for normal polynomials by realizing that k,l large enough cannot possibly sum to m
14:07:02 <hseg> for k,l,m :: Integer this no longer holds, and you explicitly need dom to be finite
14:28:17 <hseg> ... from lack of responses, guess I'll have to code it up myself. oh well
14:43:44 <dminuoso> Is there a dirty hack I can use to stuff a function `Value -> Parser a` into a dictionary and satisfy a FromJSON constraint?
14:43:53 * hackage tar-bytestring 0.6.1.3 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.1.3 (maerwald)
14:44:21 <dminuoso> More generally, Im trying to figure out whether I can use the top level eitherDecode without being tied to a typeclass instance..
15:17:53 * hackage base16 0.1.2 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.1.2 (topos)
16:08:24 <jackdk> dminuoso: I saw an experimental library go past the other week called first-class-instances
16:13:53 * hackage rings 0.0.3.1 - Ring-like objects.  https://hackage.haskell.org/package/rings-0.0.3.1 (cmk)
16:13:54 <remexre> ugh, what solver do I need to get GHC to solve (1 <= (n + 1)) (with GHC.TypeLits)
16:14:23 <jackdk> mumble mumble ghc plugin?
16:14:55 <remexre> yeah, I've got Extra, KnownNat, and Normalise in scope
16:15:23 * jackdk shrugs
16:15:30 <dminuoso> jackdk: "To avoid possibly breaking assumptions author of class may have made about it's instances, you can only create representation for class in current module." :(
16:15:50 <dminuoso> Oh, I'm saved! There is an `unsafeMkInst :: Name -> Q [Dec]`
16:16:02 <dminuoso> Yeah, that's exactly the kind of dirt I was looking for!
16:16:29 <dminuoso> Unsafe template haskell, all to avoid writing a single newtype..
16:17:21 <jackdk> dminuoso: eeek. Can I suggest you write a single newtype?
16:17:35 <Axman6> I feel like Csongor Kiss did a post related to this https://kcsongor.github.io
16:18:42 <jackdk> Also, I think ToJSON and FromJSON classes are a mistake. they have no laws, and tying serialisation to instances means that serialisation - a concern which is often tied to API versioning on the fringes of your application - is now buried in the definition of core data types
16:19:18 <jackdk> Last time I worked with aeson for that sort of thing, I found good value in defining `newtype V1 a = V1 a` near my API code and hanging all my *JSON instances off it
16:19:32 <dminuoso> jackdk: Honestly I wouldn't mind if it provided an alternative means. Like, postgresql-simple provides `_with` functions allowing you to specify the dictionary function directly instead.
16:19:37 <dminuoso> Thereby giving you the full control over what you do.
16:19:53 <dminuoso> I think aeson could easily just expose it, it's just a matter of exposing some encodeWith/decodeWith sort of functions
16:20:01 <jackdk> and then wrote and used the ban-instance packge to prevent people from accidentally defining aeson instances in the guts of the program
16:20:14 <dminuoso> Heh
16:20:40 <jackdk> dminuoso: you mean like https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Parser.html#v:decodeWith
16:21:27 <jackdk> I'm not kidding, it worked well for me (we were using servant, which forced the use of typeclasses to select serialisation)
16:22:05 <dminuoso> jackdk: Argh hold on, what the heck!
16:22:11 <dminuoso> How is this suddenly there.
16:22:15 <dminuoso> It wasn't all evening when I checked.
16:22:23 <jackdk> Data.Aeson**.Parser**
16:22:25 <jackdk> ?
16:22:50 <jackdk> also interesting: servant-waargonaut uses a tag parameter to distinguish instances http://hackage.haskell.org/package/servant-waargonaut-0.7.0.0/docs/Servant-API-ContentTypes-Waargonaut.html
16:23:08 <dminuoso> jackdk: Ohh wow! I just looked at Data.Aeson, expecting this to be such a core functionality...
16:23:22 <dminuoso> Also I seriously didn't expect serialization routines to be in a module called Something.Parser
16:23:36 <jackdk> anyway, there you go. sorry, but you don't have to resort to black magic any more. }:->
16:23:48 <dminuoso> jackdk: I'll use that library just out of spite, then.
16:23:51 <dminuoso> Thank you!
16:25:22 <jackdk> rip dminuoso , slain by summoned daemons
16:28:56 <dmwit> ...go team &?
16:32:16 <dmwit> If you click on the Parser type, you'll also see the tools you would need to build decodeWith yourself. parse, parseEither, parseMaybe in https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Types.html
16:38:21 * dmj` wonders why disabling idle time gc is not the default
16:43:06 <dminuoso> dmwit: I chased it but ended up with primitives residing in non-exposed modules
16:44:28 <dminuoso> Ah well, perhaps not. But relying on internal modules either way is not right.
16:48:28 <remexre> what ghc-options: do I want in my cabal file to get useful stack traces on error?
16:49:33 <remexre> I tried -fprof-auto -g but got a one-line stack trace; I tried the same w/ -prof and was told it was unnecessary
16:49:47 <remexre> (and the build failed with it, possibly related to https://gitlab.haskell.org/ghc/ghc/issues/11293 ?)
16:59:49 <dmj`> remexre: -xc , but it needs profiling -fprof-auto-all iirc
17:00:33 <remexre> dmj`: ghc: unrecognised flag: -fprof-auto-all (I'm on 8.6.5, if that matters)
17:01:08 <dmj`> remexre: ghc --show-options | grep --color prof 
17:01:25 <dmj`> remove the -all I guess
17:02:02 <remexre> er yeah, I already had that then; -xc gets me
17:02:04 <remexre> "the flag -xc requires the program to be built with -prof"
17:02:14 <remexre> but adding -prof tells me that -prof is unnecessary :|
17:02:25 <remexre> (and fails to compile as noted above)
17:04:59 <dmj`> remexre: do you have -Werror?
17:05:16 <remexre> no; should I?
17:07:19 <dmwit> remexre: Don't -prof; instead tell cabal --library-profiling or --executable-profiling or something. Consult cabal --help to get the exact right option name.
17:07:32 <dmwit> Cabal will tell ghc.
17:09:14 <dmwit> dminuoso: ? parseMaybe is exposed from a non-internal module
17:13:35 <dminuoso> dmwit: Im really not sure about the intended ergonomics of any of this.
17:14:14 <dmwit> Haha, oh man.
17:14:20 <remexre> dmwit: with --profiling all-functions, it still claims "-xc requires the program to be built with -prof" :/
17:14:26 <dmwit> Yeah, the ergonomics are not great.
17:14:47 <dminuoso> dmwit: It seems as if https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Parser.html#v:eitherDecodeWith is the intended entry point.
17:14:48 <dmwit> I've gotten strange looks more than once in here telling people they can just write an aeson parser without making it an instance.
17:15:01 <dmwit> It's just such an uncommon thing to do that people completely forget it's possible.
17:15:29 <remexre> oh wait, that's possibly a red herring options
17:16:16 <dminuoso> dmwit: So far my experience was, you need an instance for decode to latch onto, but the rest can be typeclass-less without a problem.
17:16:38 <dmwit> Just... don't use decode, then?
17:16:42 * dmwit touches his forehead
17:17:05 <dminuoso> Heh
17:17:12 <dminuoso> At the end it boils down to https://hackage.haskell.org/package/aeson-1.4.6.0/docs/src/Data.Aeson.Types.Internal.html#iparse being internal
17:17:25 <dminuoso> If this was made public, you could easily use eitherDecodeWith
17:17:30 <dminuoso> But that module is not exposed
17:17:39 <dmwit> but like...
17:17:51 <dmwit> I showed you the exact, exposed functions to use instead.
17:18:01 <dminuoso> Er...
17:18:56 <dminuoso> Just out of curiosity. How does aeson expect me to fit a bytestring in there?
17:19:25 <dmwit> decode* to a Value first
17:19:34 <dmwit> (This is what aeson itself does anyway.)
17:19:53 <dminuoso> Ohh. Okay, that was not obvious at all.
17:20:57 <dmwit> I can understand that point of confusion. I'll have to remember it for future explanations.
17:28:40 <remexre> okay, --profiling all-functions --enable-profiling does a great big rebuild, then gives me a two-item stack trace
17:28:44 <remexre> -fprof-cafs it is
17:29:00 <remexre> also, why does --profiling not imply --enable-profiling :|
17:31:09 <dminuoso> dmwit: Thank you, this is much better now. 
17:32:22 <dmwit> yay!
17:32:38 <remexre> oh, neat, I now get like 200M of exception
17:32:47 <dmwit> O_o
17:33:14 <remexre> I *may* be trying to debug an exception in a QuickCheck test
17:33:55 <remexre> time to make a "debugging" subcommand of the executable...
17:34:03 <dmwit> (Oh, neat hypothesis. What are the competing possibilities?)
17:34:28 <remexre> :P
17:34:34 <dmwit> =D
17:58:42 <parsnip> Can #haskell help me understand OOP's Builder pattern?
17:59:35 <dmwit> Maybe we are capable. But this isn't really the right place.
18:00:16 <dmwit> You could take it to one of the off-topic channels if for some reason you are hoping to get this particular audience's answer; or a forum devoted to a language that uses it frequently.
18:03:02 <monochrom> I can, however, demonstrate Haskell's return-type polymorphism. >:)
18:14:51 <parsnip> okay, will cross post to #haskell-offtopic
18:17:55 <remexre> ugh, no chance there's something that lets me figure out how a specific value was constructed?
18:18:24 <remexre> I've got a type that uses the smart constructor pattern, and I'm somehow ending up with one in an invalid state after a lot of operations
18:30:50 <heatsink> remexre: Can you add code to check if the data is valid after every operation?
18:31:22 <remexre> heatsink: there's only one place where the non-smart constructor is being called, which has a check...
18:31:58 <remexre> I am using Data.Typeable.cast, but that shouldn't be capable of violating the invariant, if I understand it correctly
18:32:38 <heatsink> cast will do a dynamic type check
18:33:55 <remexre> but it should still respect compile-time types, right?
18:34:14 <remexre> like I shouldn't be able to cast ([] :: [Int]) to ([] :: [Word]), for example
18:39:07 <remexre> okay, threw a check around the cast, and that's not it
18:45:20 <hololeap_> maybe your data type allows for too much complexity and can be "shrunk down" to fit the problem better? :/
18:46:26 <remexre> the runtime representation is a newtype around Natural...
18:47:23 <remexre> er wait, it's data + !, not a newtype
18:47:39 <remexre> regardless
18:49:28 <hololeap_> what i really meant was making the range of possible values smaller, which would incidentally make the type signature more complex (potentially)
18:51:32 <hololeap_> but it's almost impossible to make any good recommendations with such a broad question as "why is it giving an incorrect answer?" and no code
18:54:05 <remexre> was looking for more of a tool recommendation
18:54:26 <remexre> hoping ghci had a --ludicrously-ram-hungry-debugging flag or smth that'd track that
18:54:31 <hololeap_> but if you're having to ask, it could be that you've broken the problem down in such a way that it's hard to reason about... or you're not leveraging the type system as effectively as you could.
18:54:51 <remexre> I mean, the constraints on the value are there via GHC.TypeLits
18:55:16 <remexre> and the runtime invariant is that the value must be in range according to the typelit arguments
18:56:47 <hololeap_> well, you could write some simple tests, and it would at least give the added value of double-checking all of your constraints
18:57:27 <remexre> yeah, that's the bizarre thing
18:57:31 <remexre> I've got a bunch of quickchecked properties
18:58:14 <hololeap_> and all your tests pass?
18:58:32 <remexre> the only failure is on checking the Show of the result of some business logic
18:58:43 <remexre> at which point the invariant the smart constructor maintains is violated
18:59:00 <remexre> and if I put the same test the smart constructor uses into show, it agrees that it's violated
18:59:40 <remexre> so I put a test to check the show during the smart constructor's execution
18:59:55 <remexre> and it still doesn't fail until after the business logic
19:00:10 <remexre> which isn't using unsafeCoerce or anything (as far as grep knows)
19:01:26 <remexre> it's maddening
19:22:24 * hackage connections 0.0.3 - Partial orders, Galois connections, and lattices.  https://hackage.haskell.org/package/connections-0.0.3 (cmk)
19:33:32 <boxscape> How do class instances with associated type/data families get turned into dictionaries? Do the associated families just become non-associated families in the process?
19:38:49 <lyxia> That sounds about right
19:40:00 <boxscape> okay, thanks
19:40:59 <glguy> Type families wouldn't make sense in dictionaries; they aren't runtime things
19:41:42 <boxscape> (whoops disconnected but I saw your message in the logs)
19:48:24 * hackage matrix-static 0.3 - Type-safe matrix operations  https://hackage.haskell.org/package/matrix-static-0.3 (wchresta)
20:14:57 <dmj`> boxscape: ghc turns associated type families into open type families
20:15:13 <boxscape> okay, ty
20:15:54 * hackage base32 0.1.1.1 - RFC 4648-compliant Base32 encodings/decodings  https://hackage.haskell.org/package/base32-0.1.1.1 (topos)
20:24:53 * hackage base16 0.1.2.1 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.1.2.1 (topos)
20:26:45 <topos> doc fixes :^)
20:32:57 <dmj`> topos: be careful, you might get yelled at for uploading packages for things like that
20:33:33 <topos> ??? wait... can you just upload doc changes directly?
20:33:44 <topos> if so i'm a complete idiot
20:34:02 <dmj`> topos: yea, might be possible through the gui, but it was broken last time I saw
20:34:17 <dmj`> topos: lens repo had some bash scripts to do it iirc, might want to look there
20:34:45 <topos> thx for the tip i'll definitely check it out. I hate minor-minor version bumps for docs
20:35:16 <dmj`> topos: personally, I'm fine with it, its your package you have liberty to do with it what you want.
20:35:20 <topos> oh shi it's just `cabal upload --publish -d <doc tar>`
20:35:34 <topos> yeah, but i'd rather not pollute hackage with too many versions if i can avoid it
20:35:48 <dmj`> hackage should be able to handle it
20:35:53 <dmj`> it's not your fault
20:36:10 <topos> 5 years from now, some user will be like "well, what versions should i set my lower bound" and they'll have more work to do :)
20:36:25 <topos> the solver has more too
20:44:21 <remexre> hololeap_: if you're interested, I found the call that was causing it... it's a call to the smart constructor, and for the life of me I don't know why it doesn't error out
20:45:03 <remexre> it makes it through multiple tests, and as soon as the function returns it, it immediately violates the properties asserted by those tests
20:45:17 <hololeap_> maybe something to do with laziness?
20:46:30 <remexre> if either test fails, it should evaluate to error, though; but it makes it thru to the Show instance, and proceeds to get Shown invalidly
20:47:12 <remexre> this is perhaps time to reach for alcohol and vacation time :|
20:47:55 <dmj`> remexre: might be time for pizza too
20:52:02 <remexre> okay wait actually hold up
20:52:04 <remexre> https://silo.remexre.xyz/screenshots/149ac42786195e3f0df4a85e98e3f847932c1847.png
20:52:09 <remexre> does :reload not do what I think it does
20:53:17 <remexre> okay, at least that makes all the actual tests outside of ghci fail
21:00:36 <remexre> ...the REPL still uses the old definition after a "cabal v2-clean"
21:01:34 <remexre> like is my machine actually haunted, or is this the classic symptom of forgetting some step in something
21:02:19 <remexre> oh, the exception fires when the KnownNat isn't 0
21:03:52 <hololeap_> maybe your brain is haunted
21:06:14 <remexre> I'm deeply considering making this a coworker's problem instead
21:07:49 <hololeap_> is sleeping on it an option?
21:08:13 <remexre> eh, I guess, but I'll be up for a while annoyed by it
21:09:03 <remexre> f***, never mind, lexi-lambda figured it out in #ghc, my Show instance is lazy
21:09:41 <hololeap_> ha yeah laziness can be a bitch sometimes
21:10:14 <remexre> ugh, why can't we just have lazy codata and strict data......
21:12:53 <hololeap_> i have to question why your tests are hinging on what show returns
21:13:10 <hololeap_> unless it's a test specific to the Show instance
21:13:18 <remexre> the tests ensure that the values are OK wrt the syntax of an external tool
21:13:42 <remexre> it's basically an integration test for the smallest possible feature
21:14:19 <remexre> and yeah, I probably should define my own serialization typeclass instead of reusing Show, but everyone working on this program knows the external tool
21:18:47 <remexre> okay, cool, all the failing tests now fail on the test in the smart ctor
21:18:51 <remexre> bleugh
21:55:35 <dmj`> merijn: ping
21:56:04 <dmj`> merijn: so you said before that you'd rather use postgresql-simple and your own generics code, instead of persistent, right
22:01:24 * hackage HsWebots 0.1.1.2 - Webots bindings for Haskell  https://hackage.haskell.org/package/HsWebots-0.1.1.2 (junjihashimoto)
23:50:25 <dminuoso> Is there an idiomatic trick for getting the "successor" of a ADT (containing just nullary data constructors) in a cyclic manner?
23:52:15 <iqubic> I feel like there's something clever you can do with deriving enum and using succ and pred, but IDK.
23:53:31 <dminuoso> iqubic: enum would give me finite cycles at best.
23:54:09 <dminuoso> But.. perhaps the idea is not bad. 
23:54:15 <justsomeguy> Like 'data Letter = A | B | C deriving (Eq, Enum, Show); succ A; pred B'?
23:54:41 <iqubic> dminuoso: I have very little experience with this.
23:56:08 <dibblego> @type cycle [minBound .. maxBound]
23:56:10 <lambdabot> (Bounded a, Enum a) => [a]
23:56:35 * justsomeguy shouldn't have said anything, since he's a noob.
23:58:49 <dminuoso> dibblego: Mmm, and you propose I implement succ by `succ e = next e letters where letters = [minBound .. maxBound]; next e (x:y:xs) | x == 'e' = y | otherwise next e (y:ys)`?
23:59:27 <dibblego> sorry I didn't have the context; only the last question
23:59:37 <dibblego> what is the context?
23:59:56 <dminuoso> dibblego: Oh Im just trying to find an elegant way to obtain the successor of an enumerable data type in a cyclic manner.
