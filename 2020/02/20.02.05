02:25:20 <zincy> Is there a convenient method of testing functions which run postgres-simple sql queries?
02:25:35 <merijn> zincy: Convenient in what sense?
02:25:37 <zincy> I don't know if something like monad-mock would help with that
02:26:12 <zincy> In the sense of not having to rewrite my application in mtl style
02:26:34 <zincy> I could do it but just wondering if I have to
02:26:55 <merijn> I mean, you can just, you know, run them against an actual server...
02:27:20 <merijn> Crazy outlandish idea, I know
02:27:25 <zincy> haha
02:27:37 <zincy> you mean a real server whoa
02:28:04 <zincy> Would the speed be ok?
02:28:14 <merijn> zincy: There's even https://hackage.haskell.org/package/postgres-tmp to speed up setting up tests
02:29:02 <zincy> Oh nice! Thanks
02:30:17 <merijn> zincy: tbh, I'm not a big believer in "mocking things", it just introduces a bunch of extra-code (i.e. more bug opportunities) for no good reason. "Ah, but now my tests also goes wrong if there's a bug in something other than my code!" <- that sounds like a bonus free test, to me...
02:30:43 <merijn> Like, what point is there to your code being correct if the dependency you rely on breaks it...
02:33:31 <zincy> Yeah that is a good point actually
02:33:41 <zincy> gotta go, be back on later, thanks for the help
02:34:41 <Athas> Is other-modules in .cabal files also needed for executables, or only for libraries?
02:35:13 <merijn> Athas: Also for executables
02:37:02 <jackdk> is there an established and common lib for total maps from k to a ?
02:37:32 <merijn> there's a few libraries, but I don't think there's anything too common
02:38:54 <__monty__> merijn: How about a situation like tests run on Github Actions but ncurses, which the tests rely on, isn't available there? Would you be ok with mocking then?
02:39:15 <jackdk> merijn: I have seen total-map and total-maps but neither look especially mature
02:39:27 <jackdk> thanks for confirming that's the state of play
02:39:30 <merijn> __monty__: Seems easier to just use the Github Action docker stuff to run tests in a container with ncurses
02:40:04 <merijn> jackdk: There's also the Ghosts of Departed Proofs approach, the paper discusses safe maps, but I'm not sure if that's packaged somehow/somewhere
02:40:53 <jackdk> IIRC that's less about the map being total and more about having proofs about what keys are present?
02:41:23 <merijn> Sure, but what is a total map if not a map where you know all keys are present? :)
02:42:14 <merijn> jackdk: How many keys do you have?
02:42:24 <jackdk> What is a map? A miserable little pile of secrets!
02:42:41 <jackdk> merijn: seven
02:43:10 <merijn> jackdk: Ok, big brain solution
02:43:21 <merijn> jackdk: Why not write a function?
02:43:59 <merijn> Or do you update the values at runtime?
02:44:12 <jackdk> merijn: I'm writing (de)serialisation code and want to be able to do updates once I've read in the structure
02:44:30 <merijn> ah
02:44:37 <jackdk> and it's marginally more annoying to do that over functions. but it's not a bad idea
02:45:26 <merijn> Unrelated question: Can someone give the executive summary of why hedgehog exists? i.e. what's the motivation for using it over QuickCheck?
02:46:41 <jle`> merijn: i sort of use it like quickcheck without the typeclass
02:46:46 <jle`> so i pass in explicit generators
02:47:03 <jle`> for example if i had a data type `data Person = P { pName :: String, pAge :: Int }
02:47:10 <jle`> and i wanted to test for reasonable names and ages
02:47:17 <jackdk> merijn: https://www.youtube.com/watch?v=AIv_9T0xKEo ; automatic shrinks, not as typeclass-heavy
02:47:29 <merijn> jackdk: But quickcheck also does shrinking
02:47:35 <jle`> i would have to restructure this type as data Person = P { pName :: ValidNameString, pAge :: IntegerBetweenZeroAndOneHundred }
02:47:48 <jle`> in order to get the automatically derived generator instance
02:47:58 <jackdk> only if the person writing the Arbitrary instance remembers to implement shrink; otherwise your list of shrinks is []
02:47:59 <jle`> so playing around with newtype wrappers and stuff
02:48:08 <jackdk> hedgehog trades some stuff away to get integrated shrinks for free
02:48:21 <jle`> so with hedgehog you don't really need to do any newtype munging, you just always explicitly provide generators
02:48:48 <jackdk> https://www.well-typed.com/blog/2019/05/integrated-shrinking/
02:48:52 <jle`> as it turns out there isn't really too much practical benefit to having 'canonical' generators for types
02:49:05 <jle`> except for generic-enough types like [a] and Maybe a, maybe
02:50:06 <jle`> so having a typeclass based method works really well in situations where you have Arbitrary a => Arbitrary (Maybe a)
02:50:35 <jle`> but what if you wanted to generate a Maybe-value with contents that don't necessarily have to match the Arbitrary instance for a?
02:50:48 <jle`> with explicit generators you have something like maybeGen :: Gen a -> Gen (Maybe a)
02:51:17 <jle`> the only way to utilize the built-in Arbitrary Maybe for your own custom sub-type generators is with newtype wrappers
02:53:54 * hackage fusion-plugin 0.1.0 - GHC plugin to make stream fusion more predictable.  https://hackage.haskell.org/package/fusion-plugin-0.1.0 (pranaysashank)
03:01:48 <phaazon_> someone give me the unicode of >>= please :3
03:01:53 <phaazon_> I can‚Äôt find it
03:01:59 <phaazon_> and =<<, if it exists?
03:03:24 <phaazon_> actually I‚Äôll use something else, thanks nevertheless :D
03:31:51 <sicklorkin> Are there any hasekll packages that compare to IxSet? 
03:32:13 <sicklorkin> and IxSet.Typed doesn't count :)
03:45:11 <merijn> sicklorkin: Compare how?
03:49:34 <phadej> phaazon_: there aren't
03:49:52 <phaazon_> no problem
03:51:48 <merijn> phadej: It's been ages since I looked at haskell-ci's internals, is there a sort of central config/setup from which the Travis yaml is generated? I've been doing some Github Actions stuff (for C/C++ at work), so I thought I might finally look into addressing that, but that depends on how much time I'd need to invest to get something basic going
03:52:02 * phaazon_ uploaded an image: Screenshot 2020-02-05 at 12.51.12.png (19KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/YxuGrfEpZmyTVbdYzJSvlIch >
03:52:06 <phaazon_> it‚Äôs good enough with a Œª üòè
04:37:54 * hackage kubernetes-webhook-haskell 0.2.0.0 - Create Kubernetes Admission Webhooks in Haskell  https://hackage.haskell.org/package/kubernetes-webhook-haskell-0.2.0.0 (amarrella)
04:51:48 <phadej> merijn: kind of. See Travis module.
04:57:02 <merijn> phadej: Eh, you seem to have accidentally committed a temp file ;)
04:57:05 <merijn> phadej: https://github.com/haskell-CI/haskell-ci/blob/master/src/HaskellCI/.Travis.hs.swo
04:58:21 <merijn> phadej: hmm, looks like a lot of the shell script stuff there would be largely the same for everything, no?
05:00:37 <phadej> if you want crap github actions setup, than yes, you can do it so
05:01:06 <phadej> otherwise, if you want take advantage of github actions features, some refactoring is needed
05:01:40 <phadej> e.g. separate steps in jobs
05:02:12 <phadej> (more granular than travis' "before_install", "install" and "build/test")
05:07:53 <jonathan_> <jackdk>: The Ghost of departed proofs approach applied to maps: https://github.com/matt-noonan/justified-containers
05:11:59 <merijn> phadej: I think step one is "get something working", step 2 "improve incrementally" ;)
05:12:30 <merijn> phadej: I just meant that a lot of the "unzip, sdist, compile, test" etc. scripts are probably the same in terms of shell commands
05:13:03 <phadej> they are, but there's _a lot_ of travis specific stuff
05:13:04 <merijn> Then again, maybe I should just start independently and unify functionality as needed/logical
05:13:06 <phadej> e.g. TRAVIS_OS_NAME
05:13:10 <phadej> to begin with
05:13:36 <phadej> I tried to do "MVP" of github actions, and right now I think that raw copy pasting is the best first step
05:13:53 <phadej> but I won't accept such PR, as then it's high risk that I'd be one doing the refactoring later.
05:14:10 <phadej> I'm really sorry, but I don't trust anyone to have time to do OSS-follow-ups.
05:14:28 <phadej> (not even myself lately)
05:14:55 <merijn> ;)
05:15:23 <merijn> This is long term anyway
05:15:33 <merijn> (Or medium, I guess on how you define long)
05:18:06 <phadej> feel free to do stuff and experiments, but for such big feature I won't accept barely working functionality into haskell-ci repository
05:19:14 <phadej> big both "public image" as well codewise.
05:19:47 <merijn> phadej: Relatedly, since there's a config file for haskell-ci now, does it already account for CI provider specific flags/options?
05:20:22 <phadej> depends on how you view it, one is free to ignore not applicable config options
05:20:51 <phadej> but e.g. folds
05:21:22 <phadej> but I don't remember there were anything particularly travis specific
05:21:42 <phadej> even distribution makes sense for say GitHub actions, if you run in docker containers
05:21:57 <merijn> I guess
05:22:50 <kuribas> merijn: isn't hedgehog easier when testing with effects?
05:23:06 <kuribas> I read that was one of the reasons for creating hedgehog
05:23:43 <merijn> kuribas: I don't know, hence why I'm asking
05:24:20 <sicklorkin> merijn: I use IxSet's indicies to query various parts of state. I like that Typed gurantee types are checked at compile time.  I'm starting to think about how to add primary keys to ensure up[dates are performed, instead of silently ignored.
05:25:52 <sicklorkin> it's fast enough fro my purpose; however, it would parobalby do smeothing better to avoid recreating entires seats for each perofmred query.
05:26:27 <sicklorkin> entire *sets* each query..
05:27:19 <sicklorkin> maybe acid state has some features that shouldn't be ignored, such as offline state
05:27:45 <merijn> sicklorkin: Honestly sounds like you should just use SQLite :p
05:28:09 <sicklorkin> IxSet is much nicer to work with
05:28:28 <merijn> How so?
05:28:31 <sicklorkin> I have a DB for daat I care about.
05:29:26 <merijn> sicklorkin: Sounds like your on the way to reinventing a DB on top of IxSet, though
05:31:35 <sicklorkin> merijn: IxSet's use case was to replace the Map i had in my state
05:31:51 <sicklorkin> several map*s* actually
05:32:33 <sicklorkin> and I need it to be fast - DB is really slow
05:33:15 <merijn> sicklorkin: Why would SQLite be too slow? What are you doing with the data?
05:34:13 <sicklorkin> the data is used to make decisions about pricing..
05:35:23 <sicklorkin> i may look at 200k products in a loop and decide which i want to buy, which ai want to reprice, which I no longer need set..
05:36:31 <sicklorkin> so one IxSet would be an order book, anotther would be product databases for geting current prices.
05:36:47 <merijn> Not really sure why IxSet would be any faster
05:37:19 <sicklorkin> I have lots of threads
05:37:32 <merijn> So?
05:38:05 <sicklorkin> well, sqlite needs Wal mode for this (iirc)
05:38:27 <merijn> You say SQLite would be too slow, but IxSet is just a list with a bunch of Map's. I fail to see how that would be any faster
05:38:54 <merijn> sicklorkin: SQLite doesn't need WAL mode for multithreading, it just speeds up/reduces locking if you have multiple writers
05:39:02 <sicklorkin> my  bench markes showed some improvemens.. upto 10sx
05:39:47 <merijn> Anyway, the short answer is "I doubt anything like IxSet exists, but different exists, because by the time someone needs that they'll generally just use a database"
05:40:54 * hackage dmcc 1.1.0.2 - AVAYA DMCC API bindings and WebSockets server for AVAYA  https://hackage.haskell.org/package/dmcc-1.1.0.2 (DmitryDzhus)
05:40:55 <sicklorkin> merijn: gotcha..
05:48:53 <merijn> Aww...that well typed post doesn't have comments
05:49:21 <merijn> I was wondering how their argument against a Monad instance ties into Selective
05:51:54 * hackage tasty-hunit-compat 0.1.0 - Tasty integration with the existing HUnit package.  https://hackage.haskell.org/package/tasty-hunit-compat-0.1.0 (martoon)
06:25:34 <haskelllisp[m]> Œª >u
06:25:34 <haskelllisp[m]> URI {uriScheme = Scheme {schemeBS = "http"}, uriAuthority = Just (Authority {authorityUserInfo = Nothing, authorityHost = Host {hostBS = "www.example.org"}, authorityPort = Nothing}), uriPath = "/foo", uriQuery = Query {queryPairs = [("bar","baz")]}, uriFragment = Just "quux"}
06:26:04 <haskelllisp[m]> How to find the value of `bar`?
06:33:58 <sshine> haskelllisp[m], not like this? (lookup "bar" . queryPairs . uriQuery) u
06:35:22 <haskelllisp[m]> sshine: 
06:35:47 <sshine> haskelllisp[m], if you're using the network-uri package there's also a Network.Uri.Lens library for something like this.
06:35:57 <haskelllisp[m]> How to use `queryL`
06:36:26 <sshine> haskelllisp[m], what's queryL? is this related to lenses?
06:37:22 <haskelllisp[m]> queryL :: Lens' (URIRef a) Query
06:39:01 <haskelllisp[m]> I need to learn `lenses` first. thanks
06:42:04 <Taneb> haskelllisp[m]: you don't need lenses, they just make things easier here
06:43:51 <sshine> haskelllisp[m], I'd just go without lenses and use the record field deconstructors as exemplified above. this should be fine.
06:44:39 <haskelllisp[m]> yes, I now use `(lookup "bar". QueryPairs. UriQuery) u`
06:45:03 <hyperisco> I have been using Shelly to make running shell commands pleasant. However, Shelly is now causing me too many problems such as with locating executables on the path. Any recommendations?
06:45:16 <sshine> haskelllisp[m], I assume the wrong capitalization is caused by your input method, like a phone?
06:45:59 <hyperisco> I just need to target Windows, by the way.
06:47:51 <haskelllisp[m]> @ss
06:47:51 <lambdabot> Maybe you meant: wn v src rc pl msg id do bf ask @ ? .
06:47:57 <haskelllisp[m]> I noticed that the input method automatically converted the first letter. thanks for your reminder. sshine 
06:48:05 <sshine> haskelllisp[m], lenses become particularly useful if you wanted to e.g. *modify* the "baz" part. without lenses that'd be a pretty horrible expression.
06:50:01 <haskelllisp[m]> yes, lens is as convenient as the `set` function in `java`
06:50:51 <hyperisco> Has anyone tried shellmate?
07:23:10 <vivit> how come  logBase 10 1000  makes a rounding error? I'm getting 2.999...6
07:23:42 <tabaqui1> vivit: Python returns the same answer
07:24:04 <tabaqui1> I guess, that math.h would do the same
07:24:44 <vivit> Alright then
07:25:05 <boxscape> > 0.2 + 0.1
07:25:07 <lambdabot>  0.30000000000000004
07:25:18 <boxscape> vivit the problem is that Floating point numbers are stored in binary, not decimal
07:25:19 <hyperisco> All the cool shell libraries depend on the unix package‚Ä¶ drat
07:25:22 <c_wraith> simple answer: because floating-point must always be treated as approximate, even when the inputs and outputs can be exactly recommended
07:25:40 <c_wraith> err.  exactly represented
07:25:40 <hyperisco> How am I to get something sane on Windows?
07:25:46 <tabaqui1> I dunno, if I implement the log function, then I would make a conversion from logarithm with base 2
07:25:54 <c_wraith> hyperisco: wsl :P
07:26:00 <hyperisco> But I have to call exes
07:26:12 <tabaqui1> and never ever compare floats with equality
07:26:14 <c_wraith> Not really a serious suggestion.
07:26:15 <boxscape> > logBase 2 1000 / logBase 2 10
07:26:17 <lambdabot>  2.9999999999999996
07:26:57 <c_wraith> right.  just because the inputs and outputs of a function might be exactly representable, it doesn't mean the intermediate values it uses are.
07:26:58 <hyperisco> Okay, two processes that communicate over a socket
07:27:17 <hyperisco> One lives in WSL so I can run my Haskell program, the other lives in Windows so I can run other stuff
07:27:54 <c_wraith> what sort of shell stuff do you want?
07:28:24 <hyperisco> Make directories and files, move files, delete files and directories, run programs with arguments
07:28:36 <hyperisco> Just trying to make a build script
07:30:09 <hyperisco> I wrote it already with Shelly but it requires me to do silly things like alias my executables with .cmd because of the way it does path lookups
07:30:27 <hyperisco> Which seems like the least resistance way to actually get something done here
07:30:31 <c_wraith> Hmm.  it's worth looking at how shake handles all that stuff
07:30:42 <hyperisco> I have used Shake before and wasn't a fan
07:30:51 <hyperisco> Maybe if I spent a few months becoming a Shake expert
07:30:58 <c_wraith> since it has some things specifically for working with windows
07:32:09 <vivit> boxscape: number base by itself shouldn't cause a rounding error
07:33:43 <hyperisco> Maybe I can get the other programs for Linux‚Ä¶ then just built it all on WSL or w/e
07:34:15 <vivit> Is there any way to have the same function operate differently on diferent types? For example, for it to give different results for  f 1  and  f 1.0
07:34:27 <mniip> that's what typeclasses are for
07:37:55 <np356> Hello there, I'm having trouble getting my code to compile. Could you please help with the the type signature for "sink"? https://gist.github.com/karim-agha/ca0ced73c4003c7518f5da8dbc45a193
07:38:11 <boxscape> vivit do you want it to return a result of the same type in both cases or of different types?
07:38:42 <np356> essentially I want a component of my conduit pipeline to print all values to stdout, and not use the C.print library function
07:38:47 <np356> I'm trying to learn this library
07:42:16 <tabaqui1> mniip: yeah, I get to know the difference betwee ad-hoc and parametric polymorphism
07:42:24 <tabaqui1> just recently
07:43:07 <merijn> np356: The type is wrong becuase putStrLn has type "String -> IO ()", not "MonadIO m => String -> m ()"
07:43:19 <tabaqui1> Type system in Haskell has much complex math than just type classes and ADT
07:43:27 <merijn> np356: So you're conduit should be "Show a => ConduitT a Void IO ()"
07:43:36 <merijn> np356: Or you should manually wrap putStrLn with liftIO
07:43:54 <boxscape> tabaqui it's mostly System F afaik
07:44:35 <tabaqui1> plus let-syntax
07:44:47 <tabaqui1> (System F isn't Turing complete)
07:45:54 <np356> merijn: thank you. this now is giving me this error: https://gist.github.com/karim-agha/3579805f936e7f1d9630b772378f95b0
07:46:35 <merijn> np356: Check the type of runConduitRes 
07:47:42 <boxscape> hm, a quick cursory read of the Hindley-Milner type system page suggests that the reason for Let-polymorphism is that type inference in System F isn't decidable, rather than it not being turing complete. Though I'm unsure atm how exactly it solves the undecidability
07:49:17 <boxscape> mostly because I can't quite tell what exactly is disallowed in HM vs System F
07:50:00 <boxscape> oh
07:50:11 <lortabac> boxscape: AFAIK System F is impredicative
07:50:12 <boxscape> lambda bound variables aren't polymorphic
07:51:16 <boxscape> hm does that refer to the same thing as -XImpredicativeTypes lortabac ?
07:51:53 <lortabac> for example the 'a' in forall a. a -> a can itself be a polymorphic type
07:51:59 <vivit> When I try to query the kind of  Eq a => a -> a, GHCi tells me that type variable 'a' is not in scope. I'm confused -- doesn't the  Eq a  bring it into scope?
07:52:25 <boxscape> I see lortabac
07:52:29 <lortabac> boxscape: I'm not familiar with -XImpredicativeTypes, so I don't know if impredicativity has the same meaning in GHC
07:52:45 <glguy> No, Eq is not a quantifier and doesn't introduce bindings
07:53:28 <glguy> Try adding "forall a."  to the beginning
07:55:54 <vivit> "Illegal symbol '.' in type; perhaps you intended to use RankNTypes or a similar language extension to enable explicit-forall syntax: forall <tvs>. <type>"
07:56:47 <boxscape> You'll need to at least type `:seti -XExplicitForall` to enable the syntax; -XRankNTypes is another extension that enables -XExplicitForall among other things
07:56:48 <lortabac> boxscape: as far as I know there are inference algorithms up to rank-2-types
07:56:51 <glguy> You'll have to enable that
07:57:49 <boxscape> lortabac I've heard that, but I'm sure that it's relevant? After all, haskell needs let-polymorphism even with Rank 1 types
07:58:15 <vivit> So what I'm trying to do is define an instance of my typeclass on all instances of the Integral typeclass.
07:58:46 <vivit> What's the syntax for that?
07:58:47 <boxscape> lortabac iow it seems like System F cannot have type inference even with just rank 1 types
08:00:06 <boxscape> vivit: instance Integral a => YourClass a where ... is what I think you're asking for
08:00:33 <lortabac> boxscape: in my understanding System F cannot have inference because it allows rank-n-types
08:02:45 <vivit> boxscape: "Illegal instance declaration for ‚ÄòPrettyNum a‚Äô (All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head. Use FlexibleInstances if you want to disable this.)"
08:03:59 <boxscape> lortabac hm, okay
08:04:45 <boxscape> vivit: I suppose you need {-# LANGUAGE FlexibleInstances #-} at the top of your file to enable that extension
08:07:19 <lortabac> boxscape: at least that's what I understood when I read TAPL
08:07:31 <boxscape> I'm planning to do that
08:08:32 <vivit> What does FlexibleInstances do?
08:09:07 <boxscape> vivit there's some unnecessary restrictions on what sort of instances are allowed in the language standard, and FlexibleInstances lifts these restrictions
08:09:30 <rain1> hi
08:10:28 <boxscape>  vivit if you want details, they are here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances
08:14:23 <boxscape> % let !x | x == 0 = 1 in ()
08:14:23 <yahb> boxscape: ()
08:14:31 <boxscape> hm, why doesn't this result in an infinite loop?
08:14:38 <boxscape> % let !x | x == 0 = 1 in x -- considering this does
08:14:43 <yahb> boxscape: [Timed out]
08:15:08 <boxscape> I would've expected the bang to force evaluation
08:15:33 <rain1> perhaps it is optimized out
08:15:37 <Taneb> boxscape: that is odd
08:15:40 <rain1> since x is not used
08:16:00 <boxscape> rain1 optimizations typically aren't allowed to alter semantics
08:16:54 <rain1> maybe looking at the Core could illuminate
08:17:03 <boxscape> possibly, I'll give it a try
08:17:23 <boxscape> hm what was the flag for that again?
08:17:24 <AWizzArd> DataKinds.  So  'True is a type of kind Bool and has no runtime representation. But:  Proxy 'True  _does_  exist at runtime?
08:17:41 <boxscape> ah, -ddump-simpl
08:20:18 <boxscape> % let !x | !_ <- x = () in ()
08:20:23 <yahb> boxscape: [Timed out]
08:20:28 <boxscape> % let !x | _ <- x = () in ()
08:20:29 <yahb> boxscape: ()
08:20:31 <boxscape> interesting
08:21:03 <boxscape> maybe that makes more sense than the last one I'm not sure
08:21:22 <boxscape> AWizzArd yes, but Proxy# does not
08:21:29 <nshepperd2> AWizzArd: Proxy 'True is also a type
08:21:36 <boxscape> ah, true
08:22:43 <mniip> Proxy @True is just a box that contains no information
08:23:01 <boxscape> so `Proxy :: Proxy 'True` exists at runtime, `Proxy 'True` is a type and therefore doesn't, and `proxy# :: Proxy# 'True` does not, afaict
08:23:03 <mniip> proxy# @True actually takes up no space and doesn't exist on the heap
08:23:47 <AWizzArd> What is    proxy#   with that # sign?
08:24:01 <AWizzArd> And is  @True the same as  @'True?
08:24:21 <boxscape> proxy# is the only non-bottom member of `Proxy# a`
08:24:45 <hyperisco> Any strict functional intermediate languages for which an optimiser exists?
08:24:54 <boxscape> and yes, you can omit the ' in most places, AWizzArd
08:25:11 <boxscape> in fact it may be deprecated at some point, but at this time -Wall has a warning if you omit it
08:25:56 <boxscape> AWizzArd the only places where you can't omit it is when there's ambiguity between types and terms, for example with something like `data A = A`, or [], (), [Int]
08:28:50 <AWizzArd> boxscape: I can go without the ' here because True alone already is unique in this context.  For things such as   data Foo = Foo   it would be necessary to go with the tick, si?
08:28:59 <boxscape> correct
08:29:48 <boxscape> How is something like `let x@0 = 1 in x` desugared to obtain something that uses (==)?
08:29:53 <boxscape> (I assume that's what ghc does, anyway)
08:31:19 <mniip> let x@y | y == 0 = 1 in x
08:32:51 <boxscape> % let x@0 = 1 in x
08:32:52 <yahb> boxscape: *** Exception: <interactive>:1:5-11: Non-exhaustive patterns in x@0
08:32:57 <boxscape> % let x@y | y == 0 = 1 in x
08:33:02 <yahb> boxscape: [Timed out]
08:33:02 <boxscape> mniip 
08:33:31 <boxscape> they are different
08:34:26 <mniip> ah
08:34:34 <mniip> value bindings are lazy
08:34:48 <mniip> % let ~(x@y) | y == 0 = 1 in x
08:34:54 <yahb> mniip: [Timed out]
08:34:56 <mniip> hm
08:35:16 <mniip> odd, now I'm surprised as well
08:42:31 <nshepperd> 'let x@0 = 1 in x' is pattern matching 1 against 0 and binding the result as x
08:42:48 <kuribas> mniip: that's bottom
08:43:00 <kuribas> mniip: y cannot be 0 and one at the same time
08:43:17 <nshepperd> 'let x@y | y == 0 = 1 in x' is binding a variable called y to something that checks that y is 0 before evaluating to 1
08:43:24 * hackage tidal 1.4.8 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.8 (AlexMcLean)
08:43:39 <boxscape> % let x@0 = 1 in x
08:43:39 <yahb> boxscape: *** Exception: <interactive>:2:5-11: Non-exhaustive patterns in x@0
08:43:44 <boxscape> % :t let x@0 = 1 in x
08:43:44 <yahb> boxscape: (Eq a, Num a) => a
08:43:58 <boxscape> nshepperd but it requires Eq so presumably there's some way to write it with (==)?
08:45:45 <boxscape> % let rhs = 1; y = 0; x | y == rhs = rhs in x
08:45:45 <yahb> boxscape: *** Exception: <interactive>:5:21-38: Non-exhaustive patterns in function x
08:45:47 <boxscape> how about thsi
08:45:49 <boxscape> this
08:46:31 <boxscape> % let rhs = 1; x | 0 == rhs = rhs in x -- or this even
08:46:32 <yahb> boxscape: *** Exception: <interactive>:7:14-31: Non-exhaustive patterns in function x
08:47:21 <nshepperd> seems right
08:47:25 <boxscape> okay
08:48:51 <boxscape> kuribas they're all bottom, but some result in an error message and others in an infinite loop
08:51:24 <boxscape> my original thing apparently has something to do with polymorphism
08:51:25 <kuribas> % let x@y = (1, fst y) in x
08:51:25 <yahb> kuribas: (1,1)
08:51:33 <boxscape> % let !x | x == 0 = 1 in ()
08:51:33 <yahb> boxscape: ()
08:51:37 <boxscape> let !x | x == '0' = '1' in ()
08:51:41 <boxscape> % let !x | x == '0' = '1' in ()
08:51:46 <yahb> boxscape: [Timed out]
08:52:04 <kuribas> % let x@y = (1, fst x) in y
08:52:05 <yahb> kuribas: (1,1)
08:53:58 <ph88> how do i clear the haskell dependencies that have been build to rebuild them ?
08:54:17 <rain1> % let !x | x == (0 :: Int) = 1 in ()
08:54:18 <heatsink> Are you building a package using cabal?
08:54:23 <yahb> rain1: [Timed out]
08:56:40 <boxscape> % let !x | x == (Proxy :: Proxy Int) = (Proxy :: Proxy Int) in x -- and yet??
08:56:40 <yahb> boxscape: Proxy
08:56:57 <heatsink> ph88, it depends on how you were managing dependencies.  What did you do to build the dependencies?
08:59:21 <boxscape> Oh I think it's because (==) is non-strict in both arguments for Proxy
09:02:33 <glguy> boxscape: What bang patterns behavior are you trying to work out?
09:03:36 <boxscape> glguy there's three expressions that are either bottom or not:
09:03:44 <boxscape> % let !x | x == 0 = 0 in x
09:03:49 <yahb> boxscape: [Timed out]
09:03:50 <boxscape> % let !x | x == 0 = 0 in ()
09:03:51 <yahb> boxscape: ()
09:03:57 <boxscape> % let !x | x == (0 :: Int) = 0 in ()
09:04:02 <yahb> boxscape: [Timed out]
09:04:16 <boxscape> glguy to add to that, the second one is bottom as well if it's written in a file and given a top-level name
09:04:48 <Taneb> boxscape: hmm, is it because Integer is boxed?
09:05:19 <boxscape> oh, because monomorphismrestriction?
09:05:22 <Taneb> ...no, it's not
09:05:41 <Taneb> boxscape: yeah, I was thinking in example 2 x would be an integer by default
09:06:04 <boxscape> Taneb I do think that explains why it's bottom in a file but not in ghci
09:06:45 <boxscape> yeah, turning off DMR at least makes the behavior consistent across those
09:07:18 <boxscape> I don't really understand why it should matter whether it's polymorphic though
09:09:05 <Taneb> % let x :: (Eq a, Num a) => a; !x | x == 0 = 0 in ()
09:09:06 <yahb> Taneb: ()
09:09:13 <Taneb> % let x :: Integer; !x | x == 0 = 0 in ()
09:09:18 <yahb> Taneb: [Timed out]
09:10:08 <sim590> Why isn't `infinity = read "Infinity"` defined in Prelude or some more official package?
09:10:24 <boxscape> I think the answer is probably similar to what the answer here was https://gitlab.haskell.org/ghc/ghc/issues/17343
09:10:52 <boxscape> (though the fix to that didn't change this behavior)
09:12:50 <Taneb> boxscape: ah, bang patterns have no effect on polymorphic stuff
09:13:01 <boxscape> oh, I see
09:13:13 <boxscape> That seems counterintuitive
09:13:59 <Taneb> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#recursive-and-polymorphic-let-bindings
09:14:34 <boxscape> I'll read through that, thanks
09:23:25 <nshepperd> a polymorphic value with a constraint is actually a function
09:23:35 <nshepperd> so evaluating it with ! might not do anything
09:23:41 <boxscape> ah, right
09:23:47 <boxscape> that makes sense, actually
09:30:29 <boxscape> just for good measure, here's an example illustrating that you need a constraint and polymorphism alone is not enough:
09:30:38 <boxscape> % let !x | !_ <- x = (undefined :: Eq a => a) in ()
09:30:39 <yahb> boxscape: ()
09:30:48 <boxscape> % let !x | !_ <- x = (undefined :: a) in ()
09:30:53 <yahb> boxscape: [Timed out]
09:31:42 <Taneb> This feels like an implementation detail that shouldn't be exposed in this way :(
09:32:05 <boxscape> true
09:33:12 <glguy> boxscape: Maybe remove the bang pattern to remove some of the confusion? let x | x == 0 = 0 in seq x ()
09:33:49 <boxscape> % let !x | !_ <- x = (undefined :: forall a . a) in ()
09:33:49 <glguy> It seems obvious that that should loop, right? You can't know if x will be 0 without already knowing if it is zero
09:33:55 <yahb> boxscape: [Timed out]
09:34:10 <boxscape> glguy indeed, I would have expected all of them to be loops
09:34:27 <ph88> heatsink, stack build 
09:37:02 <ph88> i put {-# OPTIONS_GHC -Wdeprecations #-}  in a file and i still get an warning about a deprecation .. what am i doing wrong ?
09:37:13 <heatsink> ph88, stack should be able to detect if dependencies need to be rebuilt.  If you want to restart from scratch, delete .stack-work
09:37:19 <glguy> -Wno-deprecations ?
09:37:26 <ph88> thank you heatsink 
09:37:49 <ph88> that works, thanks glguy 
09:38:50 <boxscape> glguy actually I'm not sure why `let x | x == 0 = 0 in seq x ()` behaves differently from `let !x | x == 0 = 0 in ()` still but maybe I'll figure it out if I look at the dymanic semantics of bang patterns more
09:41:59 <Cale> That... seems like a bug to me, but then, the ability of bang patterns to affect pattern bindings in let at all kind of does too.
09:42:25 <Cale> Their mysterious ability to transform let into case is a bit weird.
09:43:16 <boxscape> Will i suppose you can also transform case into let with ~
09:43:21 <glguy> boxscape: with optimizations those both compile directly to undefined
09:43:46 <Cale> Yeah, it's just that pattern bindings in let are normally all implicitly prefixed with ~
09:44:01 <Cale> But that obviously can't happen in the case of bang patterns
09:44:09 <boxscape> glguy uh does that mean the optimization changes the semantics?
09:44:31 <sm[m]> heatsink ph88: I think there‚Äôs a stack.yaml option to rebuild when ghc options change
09:44:37 <glguy> boxscape: and with GHCi those both loop indefinitely as long as you fix the type to Int
09:44:43 <glguy> What type are you trying to consider them at?
09:45:22 <glguy> the behavior of the two is the same with or without optimizations, GHC just doesn't simplify as much without them
09:45:50 <boxscape> Hm, on my phone atm, I'll have top look into this when I'm home 
09:46:24 <boxscape> It seemed to me that one was bottom and one was not but maybe ghci defaulting at play or something
09:47:51 <Cale> > let !x | x == 0 = 0 in ()
09:47:53 <lambdabot>  ()
09:48:04 <Cale> ^^ that's not undefined... somehow
09:48:23 <ph88> heatsink, deps are not being rebuilded even after removing .stack-work
09:49:09 <boxscape> Because bang patterns don't have an effect on values of with constrained types, because they're functions. But not sure why that doesn't apply for both cases
09:49:35 <glguy> Cale: It is when you put it in a module and load that module in GHCi
09:49:41 <Cale> Interesting
09:49:43 <glguy> the behavior is specific to the ghci repl
09:49:50 <boxscape> Because of DMR
09:50:08 <boxscape> Turn off mono. Restr. In the file
09:50:46 <Cale> You're probably right, the bang pattern is causing the function of the type class dictionary to be seq'ed rather than its result
09:50:59 <Cale> (but that itself is a little funny)
09:51:02 <glguy> boxscape: Better to leave it on and make things explicit with a type signature
09:51:18 <Cale> > let x :: Integer; !x | x == 0 = 0 in ()
09:51:19 <glguy> let x :: Num a => a; !x | x == 0 = 0 in ()
09:51:21 <lambdabot>  *Exception: <<loop>>
09:51:54 <boxscape> √∑ let x :: Num a => a; !x | x == 0 = 0 in ()
09:52:13 <glguy> % let x :: Num a => a; !x | x == 0 = 0 in ()
09:52:14 <yahb> glguy: ()
09:52:37 <boxscape> (Thanks phone -.-)
09:52:41 <Cale> > let x :: Num a => a; x = undefined in x `seq` ()
09:52:43 <lambdabot>  *Exception: Prelude.undefined
09:53:01 <Cale> There's no way normally to seq just the function of the type class dictionary
09:53:10 <glguy> That code also produces () compiled with or without optimizations
09:53:31 <Cale> So bang patterns let you do something which you normally couldn't do
09:53:59 <Cale> I wonder if we can somehow concoct an instance which is undefined... :)
09:54:05 <boxscape> Well, not really, because the bang pattern in this case behaves like omitting it
09:54:08 <Cale> er, I guess that's not even it
09:55:15 <boxscape> Anyway, i have to go, I'll check the logs later to see if anything more was said on the subject
09:56:17 <Cale> hmm
09:56:41 <Cale> Maybe we can show off the difference by unsafeCoercing some functions to be Num a => a values
09:59:03 <d34df00d> More performance questions here. So I have `class Statistic a where compute = ...` where compute does a single step of a statistics computation for a single bit of the input, a few base instances like `instance Statistic 'Words ...` and same for 'Bytes, 'Lines and what not. Then I also have `instance (Statistic a, Statistic b) => Statistic (a '::: b) where ...` (::: is basically a pair) that combines statistics computation st
09:59:29 <Cale> your message was cut off at "that combines statistics computation s"
09:59:38 <d34df00d> ...steps.
09:59:40 <d34df00d> Thanks.
09:59:53 <d34df00d> And I also have `wc :: Statistic a => Input -> ResultOf a` that runs this over the input.
10:00:15 <d34df00d> Why could it be that when I do `wc @'Words` it runs _slower_ than `wc @('Words '::: 'Bytes)`?
10:00:38 <Cale> weird
10:00:38 <d34df00d> I guess it's some inlining or something, but I tried looking at the Core and it wasn't that insightful for me.
10:01:35 <d34df00d> This stuff is on github https://github.com/0xd34df00d/hwc/blob/master/src/Data/WordCount.hs if you have some time to play around.
10:03:11 <tomjaguarpaw> What's the status of TypeInType?  Should I be using it with careless abandon, or should I be avoiding it?
10:03:52 <Cale> Probably neither of those two things?
10:04:57 <Cale> It's new and probably hasn't seen all that much real-world use yet, so I would only really put it through its paces in a real project if I felt like what I was trying to accomplish couldn't be done otherwise.
10:05:29 <Cale> oh, wait
10:05:38 <Cale> TypeInType is deprecated?
10:06:01 <Cale> Maybe it was just absorbed into the nature of the compiler, in which case, you have basically no choice :D
10:06:30 <tomjaguarpaw> Hmm
10:06:55 <tomjaguarpaw> Where are you seeing it deprecated?  Is it on by default, or what?
10:08:57 <Cale> It's deprecated in 8.6.x, it became a synonym for PolyKinds and DataKinds
10:09:17 <tomjaguarpaw> I see.  So all three of those extensions mean the same thing?
10:09:29 <fendor> windows question: should cabal work in cmd if it is installed with `choco install haskell-dev`?
10:09:30 <Cale> Well, TypeInType switches on the latter two
10:09:38 <tomjaguarpaw> OK, thanks.
10:09:52 <tomjaguarpaw> And either of those switches on TypeInType?
10:10:13 <Cale> Well, you can't observe TypeInType's effect without those
10:10:41 <Cale> So I think TypeInType itself is possibly always on now
10:10:58 <Cale> It's just that you need those extensions to be able to tell that it is
10:11:37 <tomjaguarpaw> I see.  Thanks Cale.
10:11:52 <geekosaur> TypeInType is always on now, as I understand it
10:12:08 <heatsink> yes
10:12:24 <hseg> Hi. I'm trying out backpack. Want to construct a module exporting a list of records of the sig implementations, but am unclear on how to write the mixin stanza
10:12:48 <hseg> complicating things is that i want the sig name and the implementation name to differ
10:13:24 <__monty__> So you want to *un*backpack a package? : >
10:13:53 <hseg> No, have implementations impl1,...,impln of a signature, want to export [impl1,...,impln]
10:14:16 <hseg> that way I can e.g. test that all implementations give the same values
10:14:37 <Cale> tomjaguarpaw: As for those extensions... they're okay, but also things I'd use sparingly. GHC's type errors surrounding PolyKinds can be really frustrating (particularly where you have a downstream module which has PolyKinds switched off but is trying to use stuff that was defined with PolyKinds, you can get errors that are nonsense)
10:14:39 <hseg> (implementations should only differ in efficiency and range of inputs on which they're valid)
10:15:17 <__monty__> hseg: Which is semantically identical to unbackpacking, hence the joke.
10:15:25 <hseg> ah
10:16:43 <Cale> DataKinds works fine, but it's an easy route to getting yourself into trouble by overreaching with the type system -- it becomes tempting to attempt full on dependently-typed programming techniques, when Haskell's piecemeal extensions will not always make that entirely pleasant, even if they make it possible.
10:18:05 <Cale> So just go easy with those ones -- there are cases where they make good things possible, but if you don't really need them, it's probably better to avoid them.
10:20:13 <hseg> (so have signature Method(method,domain), implementations {SL,O,Sp}.{Stolz,Weyl,Raines,Known,Conjencture}, want to write {SL,O,Sp}.Index exporting eg (psuedocode) [(M.method,M.domain) | M <- SL.{Stolz,Weyl,...}]
10:21:38 <hseg> (btw, I suppose there's no better way of writing that psuedocode than an explicit enumeration, right? modules are second-class)
10:25:38 <hseg> hrm. deleting the mixin stanza seems to fix things
10:26:23 <hseg> though that means my design isn't *actually* using backpack, afaict
10:27:00 <hseg> ... is there a way to make cabal check that a library implements a signature?
10:28:32 <hseg> on further thought, makes sense -- encapsulating instances in an index already forces them to implement the signature
10:28:36 <hseg> oh well
10:45:57 <AWizzArd> I once talked with ertes about using dependent types to have much confidence in a web server system, to ensure by the type system that users can only access resources which they have a permission for.
10:46:03 <maerwald> https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
10:46:12 <AWizzArd> Back then he told me that we need dependent types for this. But I was now thinking about DataKinds and having a  data Permission = CanCreateUser | CanSeeCustomerData | ... 
10:46:18 <AWizzArd> And now I would change my handlers in such a way that they take an additional argument:  Proxy 'CanChangeOwnPW
10:46:23 <AWizzArd> In this case it is guaranteed at compile time, that the caller _really_ has such a Proxy. So, wouldn't that already allow to have this protection I mentioned earlier? Or could ertes have had something else in mind, that is missing, and can't be done with today‚Äôs Haskell (yet)?
10:46:25 <maerwald> What do people think about Exceptt Foo IO a being an anti pattern? 
10:47:03 <maerwald> I think MonadThrow isn't much better, especially because it's Exception under the hood 
10:47:30 <maerwald> You could use ExceptT similarly (or just Monad Error) 
10:47:53 <geekosaur> I think the main sticking point is that ExceptT isn't in base, so all the IO functions in base can't use it?
10:48:59 <maerwald> I don't think they should use it 
10:49:28 <geekosaur> but I personally think most of the I/O "exceptions" shouldn't be exceptions, which are inherently asynchronous in some sense. if openFile is going to fail, it should usually return a failure, not throw. 
10:49:40 <maerwald> I also don't see a problem of IO leaving ExceptT. That's the whole point. 
10:50:13 <maerwald> I put handable stuff in exceptt. If I need functions to never crash, I have to do more work anyway 
10:51:18 <maerwald> That's an interesting thought. So everything synchronous should not be an exception? 
10:52:24 <tabaqui1> is there any writer-like transformer with "runWriterT (tell [1] >> _|_) = (_
10:52:29 <tabaqui1> is there any writer-like transformer with "runWriterT (tell [1] >> _|_) = (_|_, [1])"
10:52:54 <tabaqui1> ?
10:53:33 <[exa]> tabaqui1: well you could certainly get at least (undefined, 1:undefined)
10:54:07 <geekosaur> in general, I do believe that. exceptions should be exceptional, basically. FileNotFound isn't all that exceptional, and I should have to handle it somehow; ExceptT makes it more likely that I do so, vs. just letting the program (not) catch a fatal exception
10:54:17 <geekosaur> same reasoning behind disliking partial functions 
10:54:55 <geekosaur> granting that you can catch exceptions in IO, but that's more scaffolding/noise to use the exception approach
10:56:30 <tabaqui1> [exa]: how
10:57:07 <tabaqui1> btw, monad-logger provides similar monad, but it collects IO actions and evaluate them as soon as they come
10:57:31 <maerwald> Sure, but that being said, MonadThrow makes it only worse then. 
10:57:34 <tabaqui1> geekosaur: have you read Error vs Exception article?
10:58:04 <geekosaur> I may have, do you have a pointer?
10:58:35 <tabaqui1> geekosaur: https://wiki.haskell.org/Error_vs._Exception
10:59:25 <geekosaur> I'm thinking more generally than Haskell, although Haskell (to my annoyance) has a type system that enables doing the right thing then doesn't do so
10:59:44 <geekosaur> oh, that's not quie the same thing since they regard e.g. Maybe values as exceptions
10:59:46 <tabaqui1> it states that developers should consider exception just as additional return value, but error as a real unexpected case
11:00:32 <geekosaur> right, but Haskell exceptions are fundamentally different from e.g. Maybe values.
11:00:59 <geekosaur> they're unconfusing one part of the question but making another part more confusing
11:02:04 <geekosaur> which is part of the problem; it goes beyond errors vs. exceptions, it's also about synchronous vs. asynchronous exceptional conditions. I tend to think Haskell exceptions better model asynchronous exceptional conditions than synchronous ones, which are better handled with ExceptT or the like
11:03:36 <[exa]> tabaqui1: in fact normal writer works in that case, you must just take care not to touch the undefined. e.g.:
11:03:41 <[exa]> > head . snd . runWriter $ ( tell [1] >> undefined )
11:03:44 <lambdabot>  1
11:04:22 <maerwald> I don't mind two different exception semantics. ExceptT level to me are things that may affect control flow. Uncaught IO exceptions from the inner monad should bubble up and at best trigger a recovery mechanism on a higher level. 
11:04:24 * [exa] regrets that parenthesis
11:04:42 <tabaqui1> [exa]: sort of
11:04:44 <tabaqui1> > let (a, b) = runWriter $ ( tell [1] >> undefined ) in b
11:04:46 <lambdabot>  [1*Exception: Prelude.undefined
11:06:10 <[exa]> tabaqui1: which isn't going to help you much, because if you know how many things to take from the list, you could just have halted the Writer before it reaches undefined
11:06:38 <tabaqui1> allright, it is actually an XY-problem
11:06:48 <tabaqui1> I'm trying to simulate defers from go
11:07:05 <tabaqui1> with "type DeferT m a = WriterT (Seq (IO ()) m a"
11:10:31 <[exa]> well, that could also let you have some 'bracket'-like stuff inside which allows you to run deferred functions upon actually exiting from a code block, not after the monad terminates
11:11:00 <[exa]> like withDefers $ do { defer $ print 123 ; ... }
11:11:10 <[exa]> if you want it to survive undefined, look at the implementation of bracket
11:11:13 <tabaqui1> it seems so, I didn't think about this
11:11:35 <tabaqui1> I could do it in monad-logger-like way
11:11:46 <solonarv> also have a look at ResourceT, which seems very similar to what you are trying to do
11:12:19 <tabaqui1> where "defer = writeChan..." and runDeferT will load the actions from the Chan and evaluate 'em
11:13:43 <[exa]> that might be an overkill, I think IORefs should suffice
11:14:00 <solonarv> yes, in fact you only need a single IORef!
11:14:10 <tabaqui1> solonarv: I'm not sure, if "void $ register $ print 1" shouldn't shoot right after the call because of GC
11:14:29 <solonarv> GC has nothing to do with when IO actions are executed
11:14:34 <tabaqui1> (sorry for the grammar)
11:14:44 <tabaqui1> solonarv: register returns an ReleaseKey object
11:15:02 <solonarv> yes, the only use for that is releasing a resource *early*
11:15:15 <tabaqui1> and I guess, that the action will shot instantly when GC discard the object
11:15:28 <solonarv> your guess is wrong and I would like to know what makes you think so
11:16:23 <solonarv> the only use for a ReleaseKey is calling 'release' (or 'unprotect', I suppose)
11:16:33 <solonarv> nothing happens when it is GCed
11:16:52 <tabaqui1> ah, I see, ReleaseKey doesn't store an actual IO action
11:17:00 <tabaqui1> but just the pointer on the action in ReleaseMap structure
11:17:05 <tabaqui1> ok, then
11:17:38 <hseg> OK, so I still need backpack here. cabal file posted at http://ix.io/2aQl. trace-{stolz,conjencture,known}'s exposed modules should implement Math.Trace.Method, want trace-index to have all of them available and asserting that they all implement the signature
11:17:39 <tabaqui1> yes, thanks, it looks like resourcet can solve the issue
11:17:54 <hseg> but am unclear on how to write the mixin stanza
11:18:33 <hseg> So e.g. want to say Math.Trace.O.Stolz implements Math.Trace.Method and is available in trace-index as Math.Trace.O.Stolz
11:19:27 <hseg> (trace-index will then export the list of implementations to be consumed by the trace-methods test suite)
11:33:24 * hackage patch 0.0.3.0 - Infrastructure for writing patches which act on other types.  https://hackage.haskell.org/package/patch-0.0.3.0 (JohnEricson)
11:58:56 <hseg> Hi, need help writing a backpack mixin stanza
11:59:22 <hseg> cabal file at https://ix.io/2aQl
12:00:38 <hseg> want trace-index to say basically "I'm depending on 3 implementations of signature Math.Trace.Method, specifically trace-stolz:Math.Trace.O.Stolz (available as Math.Trace.O.Stolz), ..."
12:02:54 * hackage uuid-bytes 0.1.0.1 - UUID parsing using byteverse packages  https://hackage.haskell.org/package/uuid-bytes-0.1.0.1 (goolord)
12:09:54 <davean> go bol
12:09:58 <davean> er, sorry
12:29:55 * hackage bioinformatics-toolkit 0.9.2 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.9.2 (kaizhang)
12:41:31 <tomjaguarpaw> Is there such a thing as a newtype GADT?
12:42:21 <Cale> no
12:42:26 <tomjaguarpaw> It seems like one need not generate a constructor when the GADT type parameters can never overlap, equivalently, when every case statement of the GADT needs only one branch
12:43:09 <tabaqui1> well, it would be sane, if each record has unique resulting type
12:43:16 <tabaqui1> without overlaps
12:43:26 <Cale> You might be able to define newtypes with GADT syntax, but you can't make an actual GADT which is a newtype, because you'll at least have some additional type equality constraint witnesses.
12:43:58 <tabaqui1> yes, it wouldn't be sane
12:44:29 <tabaqui1> you hide the type with another gadt like "data Wrapper where Wrapper :: SomeGADT a -> Wrapper"
12:44:39 <tabaqui1> *you can hide
12:44:41 <Cale> Maybe there are some extra cases which ought to be allowed. We cheated a bit with "Some" here https://hackage.haskell.org/package/dependent-sum-0.6.2.0/docs/Data-Some.html
12:44:56 <Cale> https://hackage.haskell.org/package/dependent-sum-0.6.2.0/docs/src/Data.Some.html#Some
12:45:01 <tomjaguarpaw> data A a where { A1 :: A (), A2 :: A Bool }
12:45:08 <tomjaguarpaw> Why do I need a run time tag for that?
12:45:14 <Cale> It's a newtype together with a pattern synonym that unsafeCoerces :)
12:45:27 <tabaqui1> tomjaguarpaw: because you hide it with the Wrapper above
12:45:29 <tomjaguarpaw> data A a where { A1 :: Float -> A (), A2 :: Int -> A Bool }, to make it more realistic
12:45:42 <tomjaguarpaw> Because I?
12:45:45 <tabaqui1> and use case expression to unwrap it later
12:45:49 <tabaqui1> *you can hide
12:46:02 <tomjaguarpaw> Then SomeGADT needs a tag, but not A, surely?
12:46:08 <Cale> tomjaguarpaw: Suppose you have a value of type x :: A a, and you're pattern matching on it. You need the runtime tag to be able to tell you which of the two cases you're matching.
12:46:20 <tabaqui1> wrapped = Wrapper (A1 0.0)
12:46:37 <Cale> So that, having matched one tag or the other, you know which type a is
12:46:40 <tomjaguarpaw> s/SomeGADT/Wrapper/
12:46:42 <tabaqui1> and later "case wrapped of Wrapper (A1 _) -> ; Wrapper (A2 _) -> "
12:47:11 <Cale> tomjaguarpaw: huh?
12:47:16 <Cale> You mean like Some A?
12:47:22 <tabaqui1> like Some A
12:47:53 <Cale> tomjaguarpaw: Consider this:
12:47:58 <Cale> data Some f where
12:48:06 <Cale>   Some :: f a -> Some f
12:48:24 <tomjaguarpaw> Yes, I see. I can write 'myFunc :: A a -> Int; myFunc = \case { A1 f -> truncate f; A2 i -> i }'
12:48:37 <Cale> If you have a GADT like A, you can consume a value of type Some A, pattern matching to recover knowledge of which type A a you have
12:48:44 <Cale> yes
12:48:45 <tabaqui1> tomjaguarpaw: I'm not sure if you can
12:48:58 <Cale> That's the point of GADTs after all
12:49:06 <tabaqui1> type of myFunc will be derived later
12:49:22 <ChaiTRex> .
12:49:55 <tabaqui1> allright, you can :)
12:49:58 <Cale> The whole point of using GADTs is that pattern matching on GADT data constructors recovers information about the type index.
12:50:20 <Cale> That's why it's not a type parameter
12:50:28 <tomjaguarpaw> Well I wouldn't say that's the whole point.  At least part of the point is that the type parameter tells you something about what is inside.
12:51:35 <Cale> If you didn't need that, you could just use separate types.
12:52:21 <Cale> Though maybe in some cases, it's just a nice way to organise a phantom type.
12:52:59 <Cale> But yeah, you don't really need the GADTs extension unless you want to recover type-level information at runtime
12:53:03 <Cale> via the type index
13:02:25 <fresheyeball> Can I contramap a Setter' s a? I want to do something like (b -> a) -> Setter' s a -> Setter' s b
13:05:05 <tomjaguarpaw> No, because the a is used in both positive and negative position
13:06:36 <fresheyeball> tomjaguarpaw: I don't understand
13:06:49 <fresheyeball> If I can set A on record B
13:06:58 <fresheyeball> and I have a C and a C -> A
13:07:14 <fresheyeball> can't I therefore use the C to set the A on record B?
13:10:29 <tomjaguarpaw> Setter also implies that you can modify in place
13:10:44 <tomjaguarpaw> for some reason
13:10:56 <tomjaguarpaw> Setter' s a is '(a -> a) -> s -> s'
13:11:13 <tomjaguarpaw> You can't get a '(b -> b) -> s -> s' out of that with just a 'b -> a'
13:11:24 * hackage ghc-lib-parser 8.8.2.20200205 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.8.2.20200205 (shayne_fletcher)
13:12:24 * hackage ghc-lib 8.8.2.20200205 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.8.2.20200205 (shayne_fletcher)
13:23:11 <eutampieri> I'm trying to deploy [Facebook's duckling](https://github.com/facebook/duckling) on Heroku but I'm failing. [These](https://github.com/facebook/duckling/issues/438#issuecomment-581147805) are the details. Can anybody point me towards the solution? Thanks in advance!
13:30:40 <ddellacosta> is there some clever way to generate a list of 2-valued tuples from a list of values?
13:31:01 <ddellacosta> like [a] -> [(a,a)]
13:31:22 <ddellacosta> with each successive pair in the original list becoming a tuple in the returned list
13:31:37 <ddellacosta> it seems like I should be able to write some kind of fold but I'm drawing a blank
13:33:04 <iqubic> It's "map (\x -> (x,x))" that you want.
13:33:05 <pavonia> What if there's an odd number of values?
13:33:18 <iqubic> Oh, wait. Not that.
13:33:22 <iqubic> What you want is.
13:33:33 <yushyin> more like chunksOf?
13:33:43 <tomjaguarpaw> zip as (tail as)?
13:33:53 <ddellacosta> yeah I'm hand-waving over the possibility of there being odd number of values, probably just throw away the extra one for now
13:33:58 <iqubic> @let pairs = zip as (tail as)
13:33:59 <lambdabot>  .L.hs:162:13: error:
13:33:59 <lambdabot>      ‚Ä¢ Variable not in scope: as :: [a]
13:33:59 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
13:34:10 <iqubic> @let pairs as = zip as (tail as)
13:34:12 <lambdabot>  Defined.
13:34:19 <iqubic> pairs [1..5]
13:34:25 <iqubic> > pairs [1..5]
13:34:27 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
13:34:31 <iqubic> So, that?
13:35:11 <ddellacosta> iqubic, tomjaguarpaw nice, that's what I was looking for
13:35:31 <ddellacosta> I actually looked at zip too and drew a blank before
13:35:33 <iqubic> Cool. You say how I defined it there, with that let statemnet.
13:35:33 <ddellacosta> thanks
13:35:47 <iqubic> *saw
13:35:50 <ddellacosta> yep
13:36:45 <iqubic> > compose [(+1), (*2), (^2)] 1
13:36:47 <lambdabot>  error:
13:36:47 <lambdabot>      ‚Ä¢ Variable not in scope:
13:36:47 <lambdabot>          compose :: [Integer -> Integer] -> Integer -> t
13:37:06 <iqubic> Looks like someone undefined the compose I defined the other day.
13:37:30 <ddellacosta> oh wait actually that's not what I want lol
13:37:33 <ddellacosta> it's clever though
13:38:09 <ddellacosta> instead of [1,2,3,4] giving me [(1,2),(2,3),(3,4)] I want [(1,2),(3,4)]
13:38:34 <iqubic> Ah. I see.
13:38:38 <eutampieri> Does anybody know how to use Facebook‚Äôs duckling https://github.com/facebook/duckling on Heroku?
13:38:52 <eutampieri> https://github.com/facebook/duckling/issues/438#issuecomment-581147805 Here is my configuration
13:39:05 <tomjaguarpaw> So you want to take every other element.
13:39:23 <iqubic> Sure.
13:39:34 <ddellacosta> yeah
13:40:58 <ChaiTRex> ddellacosta: f (a:b:xs) = (a, b):f xs; f _ = []
13:41:12 <iqubic> Yeah. That works. That's the best way of doing it.
13:41:17 <ChaiTRex> > let f (a:b:xs) = (a, b):f xs; f _ = [] in f [1 .. 7]
13:41:19 <lambdabot>  [(1,2),(3,4),(5,6)]
13:41:26 <ddellacosta> yeah, seems like
13:41:30 <ddellacosta> okay thanks ChaiTRex 
13:41:35 <ChaiTRex> ddellacosta:  Note that if the list is odd-length, the last element is left off
13:41:48 <ddellacosta> ChaiTRex: yeah, that's reasonable behavior I figure
13:42:02 <iqubic> ddellacosta: What is the being used for?
13:42:34 <iqubic> *this
13:43:51 <ddellacosta> iqubic: nothing important, just exploration--while I was going through some fold exercises in Chris Penner's book "Optics by Example" there was a problem that made me wonder if there was a better way to do that
13:44:39 <iqubic> What problem was this in particular?
13:45:05 <tomjaguarpaw> > let f as = mapMaybe (\(c, r) -> if c then Just r else Nothing) $ zip (cycle [True, False]) (zip as (tail as)) in f [1..10]
13:45:07 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
13:45:24 <iqubic> I have the book. No need to type the entire problem here. Just tell me the section and the number of the problem.
13:45:56 <ddellacosta> I think it was [1, 2, 3, 4] ^.. <- fill in the blank, where you've got to produce [Left 1, Right "one", Left 2, Right "two"]. One solution that occurred to me was generating tuples which are easy to work with with lens and then re-flattening them at the end...anyways
13:46:00 <ddellacosta> tomjaguarpaw: interesting
13:46:09 <ddellacosta> iqubic: oh whoops haha
13:46:19 <ddellacosta> um section 6.2 exercises
13:46:37 <ddellacosta> one of the ones in the second set of exercises from that section
13:47:52 <ddellacosta> tomjaguarpaw: is that somehow using the nondeterminacy monad?
13:48:06 <tomjaguarpaw> ddellacosta: No, nothing monadic in there.
13:48:31 <ddellacosta> oh I misunderstood what the cycle was doing, gotcha
13:49:11 <iqubic> the mapMaybe bit is removing every other element.
13:49:35 <iqubic> > let f as = zip as (tail as) in f [1..7]
13:49:38 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)]
13:50:02 <iqubic> He's taking that and removing the elements in the odd positions with the mapMaybe and the cycle.
13:50:25 <iqubic> Err. Actually, removing the even positions.
13:53:07 <hseg> So I'm running tests with cabal new-test, and GHC complains that "output was redirected with -o, but no output will be generated"
13:53:11 <hseg> why is this?
13:53:43 <hseg> set main-is for the test-suite to http://ix.io/2aRn
13:54:17 <hseg> so it can't be that it can't find main
13:58:25 <dmwit> Hm, I haven't seen that one. It's almost certainly a bug in either cabal or ghc. Could you run cabal with enough verbosity that we can see how it's invoking GHC, then show us: 1. the exact cabal invocation, 2. the exact GHC invocation that cabal made as a result, and 3. the exact error GHC prints?
13:59:58 <dmwit> :t zipWithM
14:00:00 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:00:35 <dmwit> > zipWithM ($) (cycle [pure, const []]) . ap zip tail $ [1..5]
14:00:39 <lambdabot>  []
14:00:46 <dmwit> Oh, right.
14:01:22 <dmwit> > concat . zipWith ($) (cycle [pure, const []]) . ap zip tail $ [1..5]
14:01:25 <lambdabot>  [(1,2),(3,4)]
14:01:31 <hseg> cabal new-test gives output posted at http://ix.io/2aRq
14:03:59 <dmwit> Weird. There's no main-is argument to GHC. What's the main-is block in your cabal file look like? (Is the test-suite stanza short enough that you could post the whole thing?)
14:08:16 <dmwit> Anyway, you should make it say `module Main where ...` at the top of your Test.hs.
14:08:30 <dmwit> That will almost certainly fix it, and will be quicker than figuring out whether cabal should behave differently.
14:08:57 <hseg> ... wait, what?
14:09:08 <hseg> don't modules need to be named according to the file?
14:09:27 <hseg> have module Test(test) where ... in Test.hs
14:09:48 <dmwit> Under normal circumstances, yes. But Main (and main-is) is special.
14:10:30 <hseg> ... and now ghc complains of the absence of Main.main
14:10:50 <dmwit> Makes sense to me.
14:10:55 <hseg> Right...
14:11:18 <hseg> all i want is to run some quickcheck properties on cabal new-test though
14:11:36 <dmwit> Why is "though" an appropriate ending to that sentence?
14:11:43 <hseg> fair
14:12:09 <hseg> thought ix.io/2aRz would suffice
14:12:37 <tomjaguarpaw> What's the lambdabot command that gives the applicative version of any command?
14:12:59 <hseg> ah, misread docs
14:13:10 <hseg> needed to use detailed testsuite
14:14:34 <uglyoldbob> I want to maintain a list of value pairs (I am currently using a list of tuples [(Int,Int)]. I want to replace/insert elements into this list, keeping the first element of the tuples unique. replace [(1,2),(3,4),(4,4)] (3,5) should return [(1,2),(3,5),(4,4)]. I've got a solution that works but it is super slow
14:15:25 <uglyoldbob> I am also doing a replace with a list instead of a single element (using foldl)
14:15:49 <hseg> Success!
14:16:04 <dmwit> ?hackage containers uglyoldbob
14:16:05 <lambdabot> http://hackage.haskell.org/package/containers uglyoldbob
14:16:29 <dmwit> See IntMap
14:17:04 <ChaiTRex> uglyoldbob: Use Data.IntMap or Data.Map.
14:18:24 <uglyoldbob> ah thank you. i knew there had to be a better way
14:20:01 <iqubic> i
14:28:59 <jle`> tomjaguarpaw: what sort of commands are you thinking of?
14:29:24 * hackage ghc-lib-parser 0.20200205 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200205 (shayne_fletcher)
14:30:24 * hackage ghc-lib 0.20200205 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200205 (shayne_fletcher)
14:33:42 <guest88> can u do type declaration in the intepreter?
14:35:02 <ChaiTRex> guest88: Yes.
14:35:15 <ChaiTRex> > let x :: Int; x = 5
14:35:19 <lambdabot>  <no location info>: error: not an expression: ‚Äòlet x :: Int; x = 5‚Äô
14:35:20 <ChaiTRex> > let x :: Int; x = 5 in x
14:35:22 <lambdabot>  5
14:35:53 <ChaiTRex> guest88: You just do something like: let f x :: Int -> Int; f 0 = 0; f x = x + 1
14:36:21 <guest88> oooo
14:36:38 <guest88> so when you define a function you must specify its type on the same line
14:37:45 <guest88> whats wrong with this addNumbers x1 x2 = x1 + x2 :: Num a => a -> a -> a
14:39:25 <ChaiTRex> guest88: Well, in GHCi, that's the easy way of doing it (all on one line)
14:39:51 <ChaiTRex> guest88: In general, no, you don't have to do it all on one line. In a file, you can do it on multiple lines. In GHCi, you can enable multiline mode.
14:40:25 <ChaiTRex> guest88: :: is the type of the entire expression before it. The entire expression before that is x1 + x2, which is just Num a => a.
14:42:23 <guest88> ChaiTRex how about f x1 x2 :: (Num a) => a -> a -> a; f x1 x2 = x1+x2
14:43:12 <guest88> When I try to run ur code defining f above i get an error
14:43:16 <guest88> <interactive>:18:5: error:
14:45:27 <rareman> https://diamonds.capital/en/join/?ref=LbVs1s
14:47:36 <ChaiTRex> Guest3521: The type of f x1 x2 is the type of f after two arguments are applied.
14:47:47 <ChaiTRex> Guest3521: You want the type of f itself.
14:47:58 <ChaiTRex> Sorry, wrong person.
14:51:32 <monochrom> It's  f :: Num a => a -> a -> a
15:19:10 <quazimodo> hey does haskell support narrowing of nested algebraic types using either top level attributes or deeper attributes
15:20:45 <quazimodo> i'm running into the problem in typescript where having nested objects prevents the ts engine from narrowing down to a specific discriminated type if the object is nested (is nested in a big piece of website page state). I solved literally by `const nestedObj = state.here.there.theActualObj; if (nestedObj.__typename === "blabl" ....`
15:21:35 <quazimodo> the comments in the TS issue tracker suggest that they have performance issues handling this because you need to look at a tree of data potentially, each time
15:25:46 <Axman6> I don't know what narrowing is
15:26:12 <iqubic> today I learned that the Lens library has a forall in the type synonym for Iso. So whenever you write a function that has an Iso as a parameter, you need to enable Rank2Types/RankNTypes
15:26:37 <yushyin> cool
15:27:08 <Axman6> mosat of the lens types need RankNTypes. this IIRC is why the AnIso, ALens, APrism types etc. exist
15:27:13 <Axman6> most*
15:27:30 <iqubic> Oh?
15:27:55 <Axman6> https://hackage.haskell.org/package/lens-4.19/docs/Control-Lens-Lens.html#t:ALens
15:29:29 <iqubic> If I switch from using "Iso' a m" to "AnIso' a m" then I get wierd errors relating to Exchange and such.
15:34:48 <iqubic> I just wrote a lens operation to first filter a list, and then mconcat the rest of the things. Except that it does it in one pass.
15:38:21 <cole> can i define a class instance for a specific instantiation of a parametric type, e.g. Show for Maybe String?
15:38:41 <cole> ghc suggests I use flexibleinstances
15:38:56 <cole> is this an X/Y problem or should I use that extension?
15:39:10 <cole> (*is this likely to be an X/Y problem)
15:40:09 <guest88> I have pattern matched for input chars 'a', 'b', 'c'. But I want to ask the user to input a correct character if they put in anything else, like 'j', 'r' or even numbers 123 or whatever. Can I do this with a catch all pattern match?
15:42:27 <iqubic> Yes. Easily.
15:42:45 <Axman6> If you just deal with strings you can, you can do something like do ...; response <- getLine; case response of "a" -> do a thing; "b" -> do another thing; _ -> handle everything else
15:44:11 <guest88> by 'handle everything else' I told it to just run the function again but it gets stuck in the catch all definition on the next input.
15:44:39 <Axman6> can you share the code? I don't understand what you mean
15:47:08 <erisco> What is the GHC channel?
15:47:19 <guest88> I think using cases actually fixes it
15:47:27 <guest88> example :: Char -> IO ()
15:47:34 <guest88> this gets stuck at the bottom
15:47:42 <guest88> but with cases it checks for 'a' 'b' again each time
15:47:46 <iqubic> erisco: It's #ghc
15:47:52 <erisco> thanks
15:47:54 <guest88> I got it Axman6
15:49:32 <quazimodo> Axman6: if you have an algebraic data type composed of a union of 3 separate types with a common attribute as the discriminator, such as the attribute 'typename' where for each type could have a potential value 'foo' 'bar' or 'baz', but all other attributes being different on those 3 types, then if you test for 'typename' being equal to 'foo' then you can then directly access the 'foo' version of the 
15:49:36 <ChaiTRex> guest88: With regard to your earlier question, you need f :: a -> b -> c. If you have f x y ::, the type after that is going to be not the type of f, but the type of f x y.
15:49:38 <quazimodo> algebraic type's other attributes directly without checking to see that they exist, or casting the type
15:49:53 <quazimodo> i'm not sure how relevant to haskell this even is, really
15:50:23 <quazimodo> but basically that conditional is going to narrow down which one of the members of the algebraic type you're dealing with
15:51:31 <quazimodo> do we have this concept in haskell?
15:53:42 <Axman6> quazimodo: that sounds like ghetto sum types - we'd define data TheThings = Foo Foo'sThing |
15:54:09 <Axman6>  data TheThings = Foo Foo'sThing | Bar Bar'sThing | Baz Baz'sThing
15:54:29 <quazimodo> yeah ok so it's a more sophisticated approach
15:54:47 <Axman6> these all have the same yupe but contain different data - you can inspect which constructor you have using pattern matching
15:56:09 <Axman6> yes - what's you're describing is often known as tagged unions in other languages, it gives the same ability to collect alternative possibilities into one type, but requires careful programming to ensure you never break the invariant that if you have a foo in the type that the tag is also 'foo'
15:56:35 <quazimodo> right
15:57:40 <quazimodo> so that consideration I understand. But tagged unions seem to have a perfromance implication in TS where if you're relying on the tag to discriminate, then you could cause the type checker to have to traverse either up or down a data structure to see which version of that structure you're talking about based on the tag
15:57:57 <quazimodo> does that make sense (and I apologise if I'm not eloquent, the language of types is still somewhat new to me)
15:58:56 <Axman6> that sounds very painful
16:00:57 <guest88> hey Axman6, What's wrong with this? 
16:00:58 <guest88> example :: Char -> IO ()
16:01:45 <quazimodo> Axman6: in haskell that wouldn't happen?
16:01:45 <Axman6> there's no definition?
16:02:05 <Maxdamantus> quazimodo: in TS, the semantics there is really a form of "flow typing"
16:02:12 <guest88> Axman6: What do you mean?
16:02:18 <iqubic> guest88: That's literally not enough information to tell what's wrong.
16:02:22 <Axman6> quazimodo: no, we have a sensible type system, TS's is pretty crazy as you expect from trying to bolt one onto a weakly typed language like JS
16:02:37 <iqubic> guest88: That's just a type signature. We need the definition of that function.
16:02:52 <Axman6> guest88: you've just given me a type, where't he function? (This is probably what the compiler is also telling you)
16:03:01 <Axman6> where's*
16:03:24 <guest88> maybe it didnt print right on IRC
16:03:33 <Maxdamantus> quazimodo: so you have an assumption like `x: T`, then if you do `if(x.foo == "bar"){ .. }`, within the `if` block you have the assumption `x: T & { foo: "bar" }`
16:03:39 <guest88> https://pastebin.com/yPjqAM91
16:04:34 <Axman6> looks fine to me. are you getting an error?
16:04:36 <iqubic> That looks fine. Where are you calling that code from?
16:05:06 <guest88> <interactive>:26:1: error:
16:05:24 <iqubic> That's not the full error.
16:05:38 <Maxdamantus> quazimodo: and if `T` is actually something like `{ foo: "bar", x: string } | { foo: "baz", y: number }`, then you end up with `T & { foo: "bar" } = { foo: "bar", x: string }` through fairly straightforward type-level evaluation.
16:05:39 <Axman6> "My car is broken" is a really terrible way to get your break lights fixed. "My break light doesn't work" at least gives the mechanic something to work with. We're just mechanics, help us out
16:05:42 <ChaiTRex> guest88: Use pastebins
16:05:57 <guest88> https://pastebin.com/3MM0kQhy
16:06:12 <guest88> wrote it in a .hs and loaded it in in GHCi
16:06:16 <Axman6> you didn't give example a Char
16:06:41 <iqubic> Like I said earlier: "That looks fine. Where are you calling that code from?"
16:07:25 <guest88> omg lol
16:07:29 <Axman6> I don't understand why you've decided that it needs a Char to begin with though
16:07:30 <guest88> i didnt give it a char
16:07:53 <guest88> I was just typing 'example' without an input.
16:08:11 <guest88> I went from my other example which involved a getLine
16:08:15 <guest88> got confused
16:08:43 <Axman6> getChar >>= example
16:08:59 <Axman6> would also work, you'll just have to enter a char at the command line
16:10:23 <iqubic> I feel like this might be easier to understand: http://dpaste.com/2NEG9W6
16:10:54 * hackage ghc-lib-parser-ex 0.20200205.0.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200205.0.0 (shayne_fletcher)
16:11:46 <Maxdamantus> quazimodo: also note that in the `else` branch, you get an assumption like `x: T - { foo: "bar" }` (I'm not sure TS has an actual syntax for exclusion) which you can similarly evaluate fairly trivially to `x: { foo: "baz", y: number }`
16:12:52 <Maxdamantus> s/exclusion/difference/ # couldn't think of the word for a minute
16:13:02 <quazimodo> Maxdamantus: yeah there is an exclusion there
16:13:30 <quazimodo> the type is algebraic type is still narrowed, but to the remaining subset of possible types
16:14:23 <Maxdamantus> It's only really conventionally an "algebraic data type". The type system doesn't really think of it as such.
16:14:56 <Maxdamantus> I'd say it's just a way of emulating a limited form of ADTs
16:15:15 <quazimodo> Maxdamantus: you have the assumption `x: T & { foo: "bar" }` is that withitn typescript's interpretation? because in TS the checker would give you x: { foo: "bar", x:string }
16:15:30 <Maxdamantus> quazimodo: yes.
16:16:13 <quazimodo> doesn't T & { foo: "bar" } resolve to { foo: "bar", x: string } | { foo: "bar", y: number } ?
16:16:57 <quazimodo> i need to spend time on learning type theory properly
16:17:03 <Maxdamantus> in TS, the type term `({ foo: "bar", x: string } | { foo: "baz", y: number }) & { foo: "bar" }` just evaluates to `{ foo: "bar", x: string }`
16:17:05 <quazimodo> it's interesting language
16:17:20 <quazimodo> Maxdamantus: really? i didn't expect that at all
16:17:28 <quazimodo> i didn't experiment with that at all tbh,
16:17:40 <Maxdamantus> quazimodo: because it excludes the right branch of the `|`
16:18:07 <quazimodo> wow i thought it would override the night branche's foo
16:18:38 <Maxdamantus> quazimodo: (X | { foo: "bar", ...z }) & { foo: "baz" } = T
16:19:07 <quazimodo> yeah so  interesting
16:19:09 <quazimodo> it excludes it
16:19:26 <Maxdamantus> quazimodo: the right branch of the sum is just incompatible with the intersection it's being merged into, and that's fairly easy to determine.
16:19:43 <Maxdamantus> er, s/T/X/
16:20:01 <quazimodo> yeah that makes sense, i think perhaps i'm thinking too imperatively whereas this stuff is all about sets
16:22:42 <Guest_92> Hello
16:26:58 <Maxdamantus> Actually, my last type equivalence statement wasn't quite correct. I'll fix it.
16:27:19 <Maxdamantus> quazimodo: (X | { foo: "bar", ...z }) & { foo: "baz" } = X & { foo: "baz" }
16:27:39 <guest88> is there any way I can read in a string of different types and interpret them? Like if I write "55 L 0" I get back [55, 'L', 0]? I know read plays a part but cant figure it out.
16:27:43 <Maxdamantus> since you can't drop that constraint without knowing what `X` is.
16:30:10 <iqubic> guest88: You can't have [55, 'L', 0] like that. Lists can only contain one type of value. That list has Int, 55 and 0, and a char 'L'.
16:30:49 <guest88> ah yeah true
16:32:07 <guest88> how about "55 L 0" -> (55, 'L', 0)
16:33:29 <dsal> Is there a convenient way to get a from   Either a a   ?
16:33:46 <dsal> Oh, I guess that's either
16:34:25 <ChaiTRex> guest88: You're going to have to write a parser for that. If you want to use read, your input has to be the same as a Haskell literal, like read "(55, 'L', 0)" = (55, 'L', 0)
16:34:48 <MarcelineVQ> dsal:  either id id   yeah
16:35:20 <dsal> Giving that a shorter name is probably harder than just doing 'either id id'
16:36:23 <MarcelineVQ> it would be hard to be more clear in as many chars, as long as the reader knows what either is
16:36:33 <quazimodo> Maxdamantus: makes perfect sense
16:53:37 <d34df00d> MarcelineVQ: hey, remember that little application of mine from a couple of days ago that performed worse with a GADT-wrapped function as opposed to unwrapped function and that you couldn't reproduce?
16:54:51 <d34df00d> I played around with it a little more, and turns out if you instantiate the typeclass-based worker function with a class that implies that more work needs to be done (but that is of the form `instance (C a, C b) => C (a, b)` as opposed to `instance C T`)
16:55:03 <d34df00d> s/with a class/with a type/
16:55:18 <d34df00d> then it actually performs faster than a hand-written (specialized?) one.
16:55:41 <d34df00d> So my conclusion is that I don't know anything about Haskell performance and can't reason about what compiler does to my code.
16:56:02 <d34df00d> And just thought worth sharing as you might find it curious since you've already looked at the code sort of.
16:57:13 <MarcelineVQ> d34df00d: that's the common experience and one of the things holding haskell back as far as being mainstream goes
16:57:48 <MarcelineVQ> "amazing things can be done with this code, uh, how do we get them to be done?"
16:58:01 <d34df00d> Haha, yeah.
16:58:13 <d34df00d> Or "they can be done in finite time, now how can we make it computationally feasible"
16:58:30 <d34df00d> Also I learned that sort-of-dependently-typed code with promotion of run-time values to types doesn't play nicely with performance.
16:59:02 <d34df00d> Since it's just type erasure, and now the runtime has to carry around all the vtables... sorry, class dictionaries, and can't inline/fuse/etc them .
16:59:36 <d34df00d> (or, at least, type erasure in my particular case, as I used the pattern of `data SomeFoo where MkSomeFoo :: SomeFooClass a => proxy a -> SomeFoo`)
17:01:18 <d34df00d> And I also realized I don't really have a good intuition about how my compiled code would look if I were to write it in a fully dependently typed language like Idris. What if you compute a type from user's input? What does it get compiled to?
17:02:21 <MarcelineVQ> or it can but you have to wiggle things just right, which is what I'm talkin about that's holding things back, both having to know the wiggle or having to figure it out from the varieous scatterd blogs
17:02:36 <MarcelineVQ> re: "doesn't play nicely with performance."
17:03:54 <MarcelineVQ> d34df00d: it's not really different, things needed at runtime are present at runtime, and things that aren't aren't
17:04:12 <d34df00d> But if you eventually do `runStuff (MkSomeFoo (_ :: proxy s)) = runStuff' @s`, how the compiler can ever have the chance of doing all of the optimizations it can do if it were just `runStuff' @s` with an `s` known at compile time?
17:04:56 <d34df00d> If I understand correctly, the former is just a fancy notation of "give me the array of pointers to functions that a haskeller would call the dict for the type class that SomeFoo wraps`?
17:04:58 <MarcelineVQ> e.g. you have a  Vect n a  and you want the length,  length1 : Vect n a -> Nat; length1 {n} _ = n   is going to get you the length right away, but we also have to carry it at runtime.  length2 : Vect n a -> Nat; length2 [] = 0; (_::xs) = 1 + length2 xs  has to compute it at runtime but we don't have to carry the size information
17:07:03 <d34df00d> I was about to write a question like what if I have `foo : Bool -> Type ; foo True = Int ; foo False = String" and then I try to do something with a binding of type `foo <user input>`
17:07:32 <d34df00d> But I realized that I probably just could do something like untagged union, and the metatheory of DTs guarantees that I don't have to do run time checks, it will all play out nicely.
17:08:16 <d34df00d> (that is, allocate a chunk of max(sizeof(Int), sizeof(Bool) if it were on the stack)
17:08:19 <d34df00d> Maybe I'm speaking nonsense.
17:14:54 * hackage scheduler 1.4.2.2 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.4.2.2 (lehins)
17:25:54 * hackage Color 0.1.2 - Color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.1.2 (lehins)
17:29:53 <MarcelineVQ> d34df00d: I don't think I follow, what is  foo <user input>  doing?
17:31:13 <d34df00d> Computing a type from a Boolean that's, say, read from command line.
17:32:12 <MarcelineVQ> then what?
17:33:01 <d34df00d> Precisely! While thinking about that I realized there's no problem.
17:36:21 <MarcelineVQ> ideally, types that aren't used as values don't make it into the compiled program. e.g. In length1 we explicitly have used n, so it must exist in the compiled program. in length2 we never explicitly work with n, so n is free to be erased entirely during compilation, and as long as we only use n in types it will remain free to be erased.
17:40:26 <MarcelineVQ> say if I ‚Äãhad a   lengthGT1 : Vect (1+n) a -> Nat; lengthGT1 (x :: []) = 1; lengthGT1 (x :: y :: xs) = 1 + lengthGT1 (y :: xs)
17:41:02 <MarcelineVQ> we're definitely using n, but we're only using it in the type of lengthGT1 not the definition, so it restricts how we're allowed to write lengthGT1 but it doesn't force n to be required at runtime, we still don't have any use of n in the definition
17:41:39 <MarcelineVQ> idk if this is useful info but I'm done anyway hehe, this is just in an idea world, real type erasure is p. hairy
17:42:27 <d34df00d> I like how Idris 2 approaches this, making this more explicit with its QTT.
17:42:48 <d34df00d> If you have like (0 n : Nat) -> ... this means you can use n in types, but not in terms.
17:43:08 <d34df00d> Which probably helps the compiler to erase things, as well as ensures you don't accidentally use what you didn't want to use.
17:48:16 <d34df00d> Is it possible to have a constraint on an associated type family declaration in the class declaration?
17:48:49 <d34df00d> I have `type Something a :: Type` and I want to express that all instances of the class shall have `Eq (Something a)`.
17:55:08 <MarcelineVQ> d34df00d: can place the instance requirement on the instance methods?
17:55:19 <MarcelineVQ> *class methods
17:56:42 <d34df00d> MarcelineVQ: nope, those requirements are actually used elsewhere, so right now I have to write `nonClassMethod :: (Foobar a, Eq (Something a)) => ...`
18:07:22 <MarcelineVQ> d34df00d: idk hehe  type Foobar' a = (Foobar a, Eq (Something a))
18:07:33 <d34df00d> That works!
18:07:36 <d34df00d> One more extension to add, yay!
18:08:26 <MarcelineVQ> FoobarEq maybe, anyway seems weird, I would much prefer the explicit version
18:09:04 <d34df00d> I'm heavy with questions today, so here's one more.
18:09:40 <d34df00d> Is there a way to generate smth like a lookup table at compile time without any runtime overhead for all the laziness/thunks/etc? Like what you'd have in C by declaring a global const static table = { 0, 1, 0, ... };
18:09:44 <d34df00d> table[] = .. that is.
18:10:13 <d34df00d> If I understand correctly, just having `table = V.fromList [ ... ]` will still have runtime overhead.
18:10:25 <d34df00d> Even if it's a top-level binding.
18:39:32 <Axman6> d34df00d: what sort of runtime overhead do you think that will have?
18:40:13 <d34df00d> Axman6: at least one indirection.
18:40:33 <d34df00d> (one extra, that is)
18:41:54 <Axman6> you might find this useful: https://github.com/emilypi/base64/blob/master/src/Data/ByteString/Base64/Internal.hs
18:44:06 <d34df00d> writeNPlainForeignPtrBytes
18:44:07 <d34df00d> Hmm.
18:44:08 <d34df00d> Interesting.
18:44:12 <d34df00d> Axman6: good pointer, thanks!
19:00:24 * hackage stratosphere 0.49.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.49.0 (jdreaver)
19:17:54 * hackage patch 0.0.3.1 - Infrastructure for writing patches which act on other types.  https://hackage.haskell.org/package/patch-0.0.3.1 (JohnEricson)
21:01:19 <cads> what is the fundamental theorem of monads?
21:01:32 <koz_> "Don't follow monad tutorials."
21:01:44 <koz_> A close second is "You don't need to understand monads to use IO."
21:01:46 <d34df00d> "Eat burritos instead of unwrapping them"
21:04:44 <koz_> d34df00d: Nom nom.
21:15:05 <cads> I feel it should be something about representability or preserving limits
21:18:47 <cads> "a monad is just the ‚Äúshadow‚Äù cast by some adjunction on the 
21:18:48 <cads> category appearing as the codomain of the right adjoint"
21:21:34 <jle`> 'fundamental theorems' usually are you some sort of decomposition into fundamental parts
21:21:59 <jle`> so maybe it might be related to how monads and comonads arise from adjunctions?
21:22:02 <cads> yeah, I'm not satisfied with this, so I'm continuing to skim reihl's chapter on monads
21:22:12 <koz_> jle`: I am some sort of decomposition into fundamental parts. :P
21:23:42 <jle`> for example if you have an adjunction F -| G, then G.F is a monad, and F.G is a comonad. so maybe fundamental theorem might be decomposing a monad into the adjunctions that give rise to it
21:23:48 <jle`> koz_: aren't we all :)
21:23:54 <parsnip> Are pure functions more difficult in other languages, based on "call by name", or w/e?
21:24:09 <jle`> parsnip: what do you mean by 'more difficult'?
21:24:11 <koz_> jle`: I guess, if we get right down to it.
21:24:36 <jle`> parsnip: for example i can write a function f(x,y) { return x+y }
21:24:50 <iqubic> That's pure.
21:24:57 <jle`> which isn't too difficult if x and y are integers
21:25:31 <parsnip> Well, I was telling someone one should not put a call for UniqueKey() in a redux.dart reducer, because it's not pure, then they started saying that well two strings are not even the same object, etc.
21:25:43 <jle`> ah
21:25:47 <jle`> that's probably because of the impure data structures
21:25:49 <jle`> they are using
21:26:12 <jle`> if you use pure/persistent data structures in most languages, you wouldn't have those problems
21:26:22 <parsnip> Yeah, I think they had to stretch and say there's some `identical` library which considers them not the same.
21:26:22 <jle`> but mutable data structures in haskell also have those similar issues
21:26:39 <jle`> i don't think it's a property of the language, but different languages have different cultures
21:26:53 <iqubic> jle`: Does your Mutable package suffer from these issues?
21:26:55 <jle`> and maybe their cultures encourage ephemeral/mutable data structurs instead of persistent/pure ones
21:27:21 <parsnip> I see a lot of `const`, etc, in Dart, I think the community generally appreciates.
21:27:54 * hackage servant-auth-server 0.4.5.1 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.4.5.1 (domenkozar)
21:27:55 <jle`> iqubic: using mutable values in general you have to worry about references and stuff like that
21:28:05 <parsnip> Mostly my lacking for not knowing how to draw the line in the sand.
21:28:09 <jle`> that's sort of 'the point' actually, kind of
21:28:20 <jle`> you switch to mutable values if you want pass-by-reference
21:30:09 <jle`> but you just have to be aware you're PBR and not PBV
21:31:19 <koz_> Don't get it twisted - you're either a hipster beer, or you're not.
21:31:25 <koz_> (sorry, I'm in a rather silly mood)
21:31:40 <jle`> time to start a parody beer business
21:31:59 <iqubic> When I see const, I just think of the function "const x _ = x"
21:32:02 <koz_> Yep, three flavours: Pass By Value, Pass By Reference, and Pass By Name.
21:32:19 <iqubic> Which one does Haskell use?
21:32:43 <guest88> "mo nads mo problems" is the fundamental theorem of monads
21:33:02 <iqubic> I guess haskell can use either pass by value (pure) or pass by reference (mutable)
21:34:01 <koz_> iqubic: Yeah, this question is a bit tricky. Do you mean Haskell-the-language-according-to-standard, or Haskell-the-language-as-GHC-implements?
21:34:58 <iqubic> I'm asking about how it works in the second instance. I don't really care about what the standard states.
21:35:36 <jle`> haskell sort of just fakes PBR.  you pass a reference as a value
21:35:52 <jle`> so the reference is just a normal data type
21:35:54 <koz_> Similar to C ironically.
21:36:05 <koz_> (since pointers are passed as values, but are actually references)
21:36:07 <iqubic> Is #haskell-cafe a thing, or does that have a different name, like #haskell-offtopic?
21:36:13 <parsnip> https://dart.dev/guides/language/language-tour#final-and-const
21:36:40 <iqubic> Isn't an MVector basically a pointer/
21:36:41 <iqubic> ?
21:37:21 <parsnip> The differences are subtle, but basically it's when do you have a Dart object that you'll never mutate, or want compiler to treat as constant.
21:37:22 <jle`> it depends on what you mean by 'is'
21:37:24 <jle`> and 'basically'
21:37:33 <jle`> synechodche
21:37:48 <jle`> but yeah the actual MVector value is a pointer/reference
21:38:19 <parsnip> Why the heck did they call it "Redux"?
21:38:28 <parsnip> Are they alluding to reducer, aka, fold?
21:38:36 <parsnip> but that takes a function and a list to a value.
21:38:57 <parsnip> are they suggesting a list of actions, and a state, result in a state?
21:39:06 <parsnip> Or did they just want a cool name?
21:39:33 <ricky_clarkson> iqubic: I think the point is you can't tell the difference between PBV or PBR given immutability.
21:39:55 <parsnip> (For reference, this was an effort to take ideas from Facebook's Flux, and Elm's update thing.)
21:45:30 <jle`> ricky_clarkson: ah, that's a good point
21:45:42 <jle`> it's usually really obvious in Haskell when you are PBV vs. PBR
21:45:47 <jle`> but in other languages the distinction is obscured
21:46:27 <jle`> so maybe it is really harder, like parsnip originally asked
21:47:56 <parsnip> Right, now I'm more aware how careful I have to be in attempting to obey the Redux contract.
21:48:18 <parsnip> In practice, will be difficult, but I'm once aware.
21:48:37 <parsnip> "Aware in theory"‚Ñ¢Ô∏è
21:53:42 <ricky_clarkson> jle`: Hmm, I'm missing something - e.g., foo (Just 1) - how can I observe whether Haskell passes that Just 1 to foo by value or by reference?
21:54:27 <jle`> ricky_clarkson: by PBR i mean things like mutable references
21:54:34 <jle`> like IORef, MVar, MVector, etc.
21:54:54 * hackage simple-cmd-args 0.1.5 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.5 (JensPetersen)
21:54:55 <jle`> you 'know' you are passing by reference because the only way you can *use* the values they point to is in IO or ST
21:55:23 <jle`> you're never going to accidentally think a PBR (like getting an IORef Int) is PBV because you can't use IORef Int except in IO
21:55:41 <jle`> er, you can't use the `Int` that the IORef points to
21:57:32 <iqubic> :t unsafePerformIO
21:57:34 <lambdabot> error: Variable not in scope: unsafePerformIO
21:57:55 <ricky_clarkson> In a monad I guess that's true - in ordinary expressions it sounds like GHC could decide differently each time and I'd never know.
21:57:59 <iqubic> Well, that function exists.
21:58:03 <guest88> can ya return a tuple?
21:58:16 <iqubic> Sure. That's a simple thing to do.
21:58:46 <iqubic> You can return any haskell data type that exists. A tuple is an example of one such.
21:58:49 <ricky_clarkson> > (\x -> (x, x)) 3
21:58:51 <lambdabot>  (3,3)
21:59:07 <iqubic> Now, what is it you are trying to do? This seems like an XY problem.
21:59:09 <guest88> oh damn
21:59:21 <jle`> ricky_clarkson: right, you effectively have to treat everything as PBV
21:59:45 <jle`> ricky_clarkson: every argument to any function is PBV, but semantically we can simulate/emulate PBR by passing a reference as a value that can be used in IO or ST or something like that
22:03:41 <guest88> iqubic: When I'm returning a tuple it actually returns IO tuple
22:05:51 <ricky_clarkson> jle`: I think you're equating PBR with mutability.
22:06:08 <int-e> ricky_clarkson: Closer to the truth: We are in a pure language so it doesn't matter whether we use PBV or PBR; the values are immutable. And in fact, most arguments tend to be passed by reference in practice; some get unboxed and passed by value.
22:06:23 <parsnip> you cannot escape IO
22:06:48 <parsnip> guest88: you can't get out once you're in. what put you in the IO?
22:07:05 <parsnip> guest88: with bind, you can sort of get at the tuple.
22:07:19 <parsnip> but the end result will still be IO.
22:07:54 <ricky_clarkson> int-e: jle`: wikipedia for once has a useful paragraph
22:07:55 <ricky_clarkson> In purely functional languages there is typically no semantic difference between the two strategies (since their data structures are immutable, so there is no possibility for a function to modify any of its arguments), so they are typically described as call by value even though implementations frequently use call by reference internally for the efficiency benefits.
22:08:07 <guest88> parsnip: https://pastebin.com/R6NkUQrt
22:08:19 <guest88> this has type checkSame :: String -> IO ([Char], [Char])
22:08:41 <guest88> but I want it to be just ([Char], [Char])
22:09:00 <Axman6> I'm sorry Dave, I can't do that
22:09:15 <parsnip> haha
22:09:27 <parsnip> til IO is pod bay doors
22:09:40 <guest88> what
22:09:50 <parsnip> a joke was told
22:09:52 <guest88> i get ur reference but not in the context of IO
22:10:00 <jakalx> guest88: what exactly do you want to achieve?
22:10:19 <guest88> I just want to return a tuple if some condition holds, if the condition doesnt hold i want to run the function again
22:10:20 <parsnip> guest88: trying to get something out of IO is being compared to opening the pod bay doors.
22:10:28 <Axman6> guest88: you can't do that directly, but if you are already using IO, then you can do: do theTuple <- checkSame "some string"; doSomethingWith theTuple
22:10:46 <jakalx> then write a pure function that is not in IO
22:10:52 <parsnip> guest88: what does the input look like?
22:10:54 <int-e> ricky_clarkson: I guess that's a bit more precise than what I wrote :)
22:11:12 <jackdk> pretty much. I think many people see `IO ([Char], [Char])` and go "ah, I want to use my function to that accepts a `[Char]`. This means I need to get something "out from under the `IO`" <-- this thought is common and wrong
22:13:24 * hackage cabal-rpm 2.0.1 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.1 (JensPetersen)
22:15:03 <jackdk> the way to achieve the goal is to use the tools provided by do-notation and the Functor/Applicative/Monad typeclasses
22:16:26 <parsnip> the recursion is what worries me.
22:17:51 <jackdk> in what way is it worrying you?
22:17:51 <jle`> ricky_clarkson: i'm talking about *literal* pass by reference in the sense that you pass a reference
22:18:17 <jle`> ricky_clarkson: so pass by reference isn't really a part of the language, but rather it's something built within the language
22:18:22 <jle`> it has semantic meaning, not built-in meaning
22:18:45 <jle`> like 'Maybe' has the meaning of a 'nullable object' as something built within haskell
22:18:56 <jle`> as opposed to other languages where 'all' values are nullable implicitly
22:19:31 <jle`> you can "emulate" what other languages have as PBR by literally passing a reference, just like how you can "emulate" what other languages have as null pointers by using Maybe
22:19:50 <jle`> so haskell does have 'null pointers', but not as a part of the language, but rather as a specific thing you can build in user-space
22:20:01 <ricky_clarkson> My point is mostly that I can't tell if in foo (Just 5) we're copying the value/object Just 5 to foo, or sending a pointer to some Just 5 value.
22:21:05 <ricky_clarkson> and ghc is free to do what it wants, as the programmer doesn't get to dictate that, unlike in most languages.
22:21:16 <jle`> yeah, operationally it might be a pointer, but semantically within the language it resembels the semantics of pass by value
22:21:35 <jle`> i guess i'm talking about the semantics of argument passing in the language haskell
22:21:58 <jle`> but i would argue that PBV vs. PBR are issues of language semantics, not of implementation
22:22:40 <jle`> people don't care about PBV vs. PBR because they care about the bit flipping on the RAM.  they care about it because of what sort of semantics and behaviors are guaranteed
22:27:40 <dibblego> ricky_clarkson: g'day
22:36:19 <ricky_clarkson> Blast from the past there, Tony. How's it going?
22:36:26 <dibblego> well mate! you?
22:36:36 <dibblego> and yeah blast from the very ol' past
22:39:33 <ricky_clarkson> I'm ok, jobwise still Java, learning Rust and Idris in my spare time. Idris seems nice, all those things that looked crazy and needed extensions in Haskell are simple there.
22:39:45 <dibblego> heh yeah
22:39:47 <ricky_clarkson> dibblego: Are you still hovering somewhere between Scala and Haskell?
22:39:56 <dibblego> nah, haven't written scala in years
22:40:12 <dibblego> almost all haskell these days
22:43:07 <dibblego> also do two other not-programming jobs
22:43:55 <ricky_clarkson> is warning drivers about hidden speed traps one of them?
22:44:03 <dibblego> lol I lost that video
22:44:49 <parsnip> oh no? police said you were going to slow?
22:45:43 <dibblego> no in 2007, I held a sign displaying "Speed trap ahead", and was charged, and I went to trial, and won
22:46:02 <dibblego> (by their withdrawal)
22:46:26 <dibblego> and it was on television
22:47:01 <dibblego> I do flight instruction and lecturing
22:48:24 <dminuoso> dibblego: Which country was that in?
22:48:30 <parsnip> i would hold a sign, "this asshole is speeding"
22:48:38 <dibblego> Australia
23:05:05 <jneira_> hi! there is a way to make `Coercible` `data x y`, being `x = f  y` (without create any other type definition)?
23:05:58 <iqubic> You cannot write Coercible instances yourself.
23:07:10 <dminuoso> jneira_: I could not make sense of what you are trying to do.
23:07:10 <dminuoso> jneira_: What does "data x y", "being x = f y", mean exactly?
23:13:40 <jneira_> that x is directly determined by y applying f? the type was `newtype X = X Text` and now is `data X = X !Int !Text`, but `x :: Int = hash (y :: Text)` and it lost `Coercible`
23:15:23 <iqubic> That doesn't make much sense either.
23:16:33 <jneira_> iqubic: "that" is trying to make the new type definiton Coercible?
23:17:43 <monochrom> Let's just say "no" and call it a day.  This is very messed up.
23:17:54 <dminuoso> jneira_: Coercibile is not about a general "can I go from one type to another". It's about being to interpret one thing as another.
23:18:36 <monochrom> Even "interpret" is vague and people are going to use confirmation bias to bend it to their will.
23:18:45 <dminuoso> jneira_: Coercible is about things that are provably safe to unsafeCoerce between.
23:19:06 <jneira_> aha, and you can't introduce the `x = hash y` in that interpretation cause it is implicit, i guess
23:19:13 <monochrom> A necessary condition for Coercible is that the low-level bitwise representations are identical.
23:19:39 <dminuoso> jneira_: No, it's more than just interpret as. Coercible is about two things having the same exact runtime representation.
23:19:39 <dminuoso> You could think of: `coerce :: Coercible a b => a -> b; coerce = unsafeCoerce`
23:20:05 <dminuoso> So it's an unsafeCoerce that only works if there's some proof that `Coercible a b` holds
23:20:34 <monochrom> also, s/their will/their fantasy/
23:23:00 <iqubic> I'm more advanced and think of this in terms of roles. I don't think that this is the right way to think about it when learning it.
23:23:09 <dminuoso> Now it should be said, that users cannot supply that proof. You depend on GHC somehow knowing this
23:24:23 <iqubic> It has to do with Roles. But GHC just magically finds the proof.
23:24:38 <jneira_>  > that users cannot supply that proof. 
23:24:55 <jneira_> i thought that maybe it can be done
23:25:12 <iqubic> jneira_: That's correct. You cannot write your own instance of Coercible.
23:25:32 <jneira_> i see, thanks!
23:26:20 <dminuoso> jneira_: coerce is, essentially, just a mechanism to switch a type for another. It doesn't actually do anything beneaht.
23:26:20 <dminuoso> This of course only works if the two types you switch between them have the same underlying representation
23:27:05 <dminuoso> jneira_: Coercible is not a typeclass.
23:27:41 <iqubic> No. It's a constraint, but not a typeclass.
23:27:49 <dminuoso> jneira_: It just appears that way for some technical reasons I suppose. But morally, Coercible is just a constraint-level constraint.
23:27:59 <dminuoso> *constraint-level primitive
23:28:13 <dminuoso> 08:25:57        jneira_ | i thought that maybe it can be done
23:28:21 <dminuoso> jneira_: well even if you could, what you are thinking of is something different
23:28:23 <jneira_> aha, i was hoping that `instance Coercible b b' => Coercible (D a b c) (D a b' c')` could hold in this case, via type roles, but i dont fully understand them
23:29:17 <iqubic> Actually, it's due to type roles that this CANNOT hold.
23:29:28 <dminuoso> jneira_: `Coercible T R` means that T and R have the exact same runtime representation.
23:29:33 <dminuoso> jneira_: Not that you can somehow "convert between them"
23:29:53 <dminuoso> jneira_: coerce/unsafeCoerce exists on the type level only. They dont define any action on the values themselves.
23:30:09 <dminuoso> coerce/unsafeCoerce just say "Here I have this thing. Lets pretend now it has a different type"
23:30:31 <iqubic> jneira_: What exactly are you trying to do? This seems an awful lot like an XY problem.
23:30:46 <jneira_> so we would need promote (f x = y) to the type level or somethin alike?
23:31:07 <iqubic> You can't do that promotion.
23:31:13 <dminuoso> jneira_: No, what you are asking is some typeclass `class Convert f t | f -> t where convert f t`
23:31:17 <dminuoso> Err
23:31:26 <dminuoso> % class Convert f t | f -> t where convert :: f -> t
23:31:26 <yahb> dminuoso: 
23:31:33 <dminuoso> jneira_: ^- that you can write and implement as you like.
23:31:40 <dminuoso> But Coercible straight up means something different entirely.
23:31:45 <iqubic> jneira_: What exactly are you trying to do?
23:32:31 <jneira_> aha, well i just want to avoid change the code where `data X`lives but it is solvable with a simple ToJSON instance for it
23:33:10 <jneira_> (and avoid orphan instances)
23:33:34 <iqubic> What datatype are you working with?
23:34:24 <jneira_> https://github.com/alanz/haskell-lsp/blob/master/haskell-lsp-types/src/Language/Haskell/LSP/Types/Uri.hs#L28
23:34:44 <jneira_> `data NormalizedUri = NormalizedUri !Int !Text`
23:34:47 <iqubic> I see.
23:34:55 <iqubic> And what are you trying to do with this?
23:35:14 <jneira_> and the client code: 
23:35:17 <jneira_> instance Data.Aeson.ToJSON Diagnostics where  toJSON (Diagnostics d) = Data.Aeson.toJSON    (Map.mapKeys coerce d :: Map.Map T.Text (Set.Set Diagnostic))
23:35:50 <jneira_> being `newtype Diagnostics = Diagnostics (Map.Map NormalizedUri (Set.Set Diagnostic))`
23:36:11 <iqubic> And what exactly are the errors you run into?
23:36:56 <jneira_> `Map.mapKeys coerce d` does not compile anymore
23:37:25 <jneira_> Uploaded file: https://uploads.kiwiirc.com/files/25ce50a3acabfdc5f34d1202b5078625/pasted.txt
23:37:34 <jneira_> the error is ^^
23:38:30 <iqubic> So you're trying to create a toJSON instance for a NormalizedUri?
23:39:33 <jneira_> yeah i simply was trying to not change haskell-lsp-types and i dont want orphan instances
23:39:55 <jneira_> but well, it seems it is the right way
23:40:23 <iqubic> Well here's the thing. You can't call coerce on a NormalizeUri. It won't ever work.
23:40:37 <iqubic> But yeah. An orphan instance here shold be fine.
23:41:43 <dminuoso> jneira_: Use newtypes.
23:42:07 <iqubic> dminuoso: How do you think that would help?
23:42:13 <dminuoso> jneira_: Or, just dont use aeson instances. You can do most in aeson without going through typeclasses.
23:43:18 <jneira_> dminuoso: mmm that could be a simple solution, but i guess other libraries will need them so maybe it is better to fix it upstream
23:43:43 <dminuoso> jneira_: I think the fundamental problem is abusing typeclasses for json instances.
23:43:44 <iqubic> jneira_: What makes you think other libraries will need it?
23:43:55 <dminuoso> jneira_: Most things dont have a single authorititative JSON representation.
23:44:12 <dminuoso> jneira_: Since typeclasses have an open world assumption, its a bad fit.
23:44:17 <dminuoso> Or well, instances do.
23:44:23 <jneira_> ghcide, dhall... other packages using haskell-lsp
23:44:47 <iqubic> I'd like to learn about GHC.Generics. What learning resources are there?
23:46:06 <jneira_> dminuoso: mmm i think in that case the canonical representation could be ignore the hash, cause it is completely dtermined by the text, no?
23:46:30 <jneira_> use another hash would break things
23:48:44 <iqubic> Do dhall and ghcide actually need a ToJSON instance?
23:49:07 <jneira_> not sure tbh
23:49:26 <jneira_> i can write now in client code and move upstream only if needed, for sure
23:50:09 <iqubic> As dminuoso said, most aeson operations don't actually need this instance.
23:51:03 <jneira_> iqubic dminuoso: thanks again, i'll follow the simple path :-)
