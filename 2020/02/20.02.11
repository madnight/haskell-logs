00:09:53 * hackage risc-v 0.0.1.0 - RISC-V  https://hackage.haskell.org/package/risc-v-0.0.1.0 (MatthewFarkasDyck)
00:30:23 * hackage ix 0.1.1.0 - Indexed monads  https://hackage.haskell.org/package/ix-0.1.1.0 (MatthewFarkasDyck)
00:33:53 * hackage risc-v 0.0.2.0 - RISC-V  https://hackage.haskell.org/package/risc-v-0.0.2.0 (MatthewFarkasDyck)
00:34:50 <idnar> @pl f' o = fmap one <$> f o
00:34:50 <lambdabot> f' = (fmap one <$>) . f
00:35:41 <idnar> @pl f' o = fmap (:[]) <$> f o
00:35:41 <lambdabot> f' = (fmap return <$>) . f
00:47:54 <blackbart> I'm using Graphics.OpenSCAD and I have a model consisting of various 3d shapes that have been translated, rotated, unioned, interesected, etc. Is there a way for me to figure out what is the furthest point my model reaches on, e.g., the x axis (short of keeping keeping track while I was doing all that translate rotate union mumbo jumbo)?
00:57:54 <dibblego> @src fix
00:57:54 <lambdabot> fix f = let x = f x in x
01:07:23 * hackage fusion-plugin 0.1.1 - GHC plugin to make stream fusion more predictable.  https://hackage.haskell.org/package/fusion-plugin-0.1.1 (pranaysashank)
01:12:03 <merijn> Eh...so...better start preemptively changing all your uses of makeLens >.>
01:12:13 <dibblego> why?
01:12:20 <dibblego> also, does this exist? \n -> foldr (.) id . replicate n
01:12:35 <MarcelineVQ> dibblego: sconcat meb
01:12:48 <dibblego> @type meb
01:12:49 <merijn> dibblego: Because apparently GHC 8.10 will resolve typeclasses instance "per top level group"
01:12:50 <lambdabot> error: Variable not in scope: meb
01:13:01 <MarcelineVQ> ah meb is short for maybe :>
01:13:03 <dibblego> merijn: wtf?
01:13:15 <merijn> dibblego: So if you have "data Foo = ..; makeLens ''Foo; instance Show Foo" it won't compile
01:13:36 <merijn> "No instance Show for Foo"
01:14:15 <dibblego> wait, why is there no instance?
01:14:25 <merijn> dibblego: Because it doesn't look past the TH splice
01:14:26 <MarcelineVQ> dibblego: oh no, it's called stimes
01:15:17 <dibblego> MarcelineVQ: yeah, with Endo, unEndo
01:15:18 <MarcelineVQ> stimes for Endo
01:43:53 * hackage hyraxAbif 0.2.3.21 - Modules for parsing, generating and manipulating AB1 files.  https://hackage.haskell.org/package/hyraxAbif-0.2.3.21 (andrevdm)
01:57:53 * hackage tasty-test-reporter 0.1.0.0 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.0.0 (stoeffel)
02:05:53 * hackage tasty-test-reporter 0.1.0.1 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.0.1 (stoeffel)
02:18:53 * hackage rv 0.0.1.0 - RISC-V  https://hackage.haskell.org/package/rv-0.0.1.0 (MatthewFarkasDyck)
02:23:23 * hackage tasty-test-reporter 0.1.0.2 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.0.2 (stoeffel)
02:29:53 * hackage tasty-test-reporter 0.1.0.3 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.0.3 (stoeffel)
02:32:53 * hackage dl-fedora 0.7.3 - Fedora image download tool  https://hackage.haskell.org/package/dl-fedora-0.7.3 (JensPetersen)
04:08:23 * hackage tasty-test-reporter 0.1.1.0 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.1.0 (stoeffel)
04:36:16 <haskeldjiq> hi guys
04:36:19 <haskeldjiq> using this channel
04:36:20 <haskeldjiq> https://hackage.haskell.org/package/unagi-chan-0.4.1.3/docs/Control-Concurrent-Chan-Unagi-Bounded.html
04:36:38 <haskeldjiq> is there a way to read a chunk of entries, say the last 1000
04:36:57 <haskeldjiq> I tried to do take 1000 <$> getChanContents but that simply blocks
04:38:09 <tabaqui1> haskeldjiq: it looks like, you have to combine "foldM" with "tryReadChan", good luck!
04:38:47 <haskeldjiq> tabaqui1: thanks! let me try that
04:41:54 <haskeldjiq> tabaqui1: I can't seem to figure out what the fold operation would look like
04:42:05 <haskeldjiq> tabaqui1: and what if the chan has less than a 1000 entries
04:42:31 <haskeldjiq> tabaqui1: oh there's tryRead
05:06:12 <tabaqui1> haskeldjiq: also, consider using functions from monad-loops library
05:06:41 <tabaqui1> it has usefull combinators
05:06:46 <tabaqui1> % :t iterateUntilM
05:06:47 <yahb> tabaqui1: ; <interactive>:1:1: error: Variable not in scope: iterateUntilM
05:06:55 <tabaqui1> % import Control.Monad.Loops
05:06:55 <yahb> tabaqui1: ; <no location info>: error:; Could not find module `Control.Monad.Loops'; Perhaps you meant; Control.Monad.Co (from kan-extensions-5.1); Control.Monad.Cont (from mtl-2.2.2); Control.Monad.List (from mtl-2.2.2)
05:08:18 <haskeldjiq> tabaqui1: I couldn't get it to work sadly
05:08:33 <haskeldjiq> tabaqui1: what I'm hoping to accomplish is having a loop that
05:08:55 <haskeldjiq> tabaqui1: takes the first N channel entries (if there are less, take less or an empty list)
05:09:06 <haskeldjiq> tabaqui1: do whatever with those, sleep 1 second and do it again
05:09:16 <haskeldjiq> tabaqui1: it turned out much harder than I anticipated though lol
05:10:01 <tabaqui1> decompose the task, annotate everything
05:10:46 <tabaqui1> use foldM on ([RetDatum], Counter, GetNextAction)
05:11:00 <tabaqui1> I hope, that you can achieve it in this way
05:11:53 * hackage hkgr 0.2.4.1 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.4.1 (JensPetersen)
05:14:19 <tabaqui1> heh, but not with foldM actually, because you don't fold the stream :)
05:14:32 <tabaqui1> common tail recursion will do the thing
05:15:21 <haskeldjiq> tabaqui1: I tried with foldM but yeah, it didn't work lol
05:22:53 * hackage cobot-io 0.1.2.7 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.7 (zmactep)
05:25:24 <haskeldjiq> tabaqui1: well I arrived at this freakishly ugly mess which, unsurprisingly, doesn't work lol
05:25:26 <haskeldjiq> tabaqui1: liftIO $ replicateM 5 (tryRead . fst <$> tryReadChan outEventsChan) >>= liftIO . mapMaybeM id
05:26:11 <haskeldjiq> tabaqui1: I mean, it does kind of do the job but for some reason lots of events simply get lost
05:27:37 <tabaqui1> sure, because you force evalutaion 5 times
05:27:57 <tabaqui1> try to stop after the first block
05:28:15 <tabaqui1> *first tryRead -> Nothing
05:29:22 <tabaqui1> and I suggest you to avoid point-free notation before you get the correct function
05:29:34 <tabaqui1> use do-syntax before you get it right
05:29:46 <tabaqui1> s/before/until
06:10:16 <hseg> hrm. want to use backpack to be able to switch between numeric preludes
06:11:06 <hseg> so eg i want a signature exporting a class Ring a where { (+),(-),(*),negate,fromInteger } that j
06:11:18 <hseg> that can be implemented by setting Ring=Num
06:11:24 <hseg> or Ring=algebra.Ring
06:12:46 <hseg> or Ring=numhask.Ring
06:15:19 <hseg> (note that these have wildly differing superclasses)
06:23:51 <hseg> so i can either leave Ring abstract, and just have implementations set type Ring=Num etc. con: can't access members of Ring since they're abstract 
06:24:23 <hseg> (so i'd need to have the module export a global f :: Ring r => ... instead of a class Ring r where { f :: ... })
06:24:49 <hseg> or i can have Ring be concrete, in which case i need to copy the implementation across all implementations
06:41:29 <dminuoso> Wow, what a disgusting GHC bug. If you use an illegal record syntax, GHC is erroring out on "not in scope" when you use the record fields, but the illegal record syntax is masked.
06:41:32 <dminuoso> So much headache and disbelief.
06:48:25 <lortabac> dminuoso: what do you mean by "illegal syntax"?
06:48:36 <dminuoso> % data F a = F a { f :: a }; t = F { f = 'c' }
06:48:36 <yahb> dminuoso: ; <interactive>:79:36: error: Not in scope: `f'
06:48:42 <dminuoso> % data F a = F a { f :: a };
06:48:42 <yahb> dminuoso: ; <interactive>:80:16: error:; * Record syntax is illegal here: {f :: a}; * In the type `{f :: a}'; In the definition of data constructor `F'; In the data declaration for `F'
06:49:28 <lortabac> weird
06:50:31 <lortabac> dminuoso: I guess 'data F a = F a { f :: a }' is parsed as 'data F a = F a ( f :: a )'
06:50:38 <lortabac> because {} are overloaded
06:50:59 <dminuoso> lortabac: The { and } are part of the actual grammar according to the haskell report.
06:51:03 <dminuoso> This should be rejected at parse time
06:53:05 <dminuoso> constr -> on [!] atype_1 ... [!]atype_k (aritycon = k , k ≥ 0)
06:53:05 <dminuoso>       | (btype | !atype) conop (btype | !atype) 
06:53:17 <dminuoso>         | con { fielddecl_1, ..., fielddecl_n }   
07:00:40 <hseg> hrm. ok, so i can get the type Ring=Num niceness i wanted, at the cost of having to explicitly import/export the class members
07:00:47 <hseg> fair enough
07:01:46 <hseg> ... with the problem that i cannot define instances
07:01:48 <hseg> :headdesk:
07:04:27 <ski> hm, i suppose one can't `import Blah (Ring (..))' ?
07:04:57 <hseg> ski:?
07:05:49 <ski> one cannot treat a synonym of a type class as a class itself, wrt import and export lists, is what i'm assuming
07:06:03 <hseg> yeah, that's also biting me
07:08:25 <hseg> what i'm trying to do: create a signature for the numeric hierarchy that can either be instantiated to Prelude's Num, Fractional, Integral, or algebra's Ring, Field, Euclidean, or numhask's Ring, Field, Integral
07:10:03 <hseg> in particular, i'd want the implementations to be along the lines of instance Num a => Ring a where { (+) = (+); (-) = (-) ... }
07:11:47 <hseg> redesign idea: could break out the unified hierarchy in its own package, have signature require modules to implement Ring', Field', Euclidean' with instances Ring' a => Ring a
07:12:20 <hseg> and then have the packages needing to define an instance just depend on the unified hierarchy
07:12:53 <ski> hm. interesting kind of redesign problem
07:13:01 <berndl> hseg: That would be nice. Good luck.
07:13:08 <hseg> ... would want the required instance to be sth like instance Ring' a => Ring (Proj a) with Proj a newtype, to avoid overlap. then could use DerivingVia
07:13:40 <hseg> main motivation here is that i have a bunch of code written around algebra that i want to isolate, since it's causing me inference trouble
07:13:52 <hseg> using numhask to keep myself honest
07:51:02 <noctux> hmm, excuse the stupid question, but are there any fixed terms when talking about the lefthandside and righthandside of (>>=) in actual speech? As in: descriptive names?
07:51:49 <merijn> noctux: Not really
07:51:54 <tdammers> nope
07:52:03 <merijn> noctux: "action" maybe for left, but even that is hardly that common
07:52:12 <noctux> pitty, thanks
07:52:15 <merijn> I mean the the righ hand side has a clear name "a function" :p
07:52:19 <Iceland_jack> noctux: the second argument.. you can say continuation if you need to say something
07:52:24 <tdammers> you will sometimes encounter a terminology where the LHS is called an "action", and the RHS a "function", but those names aren't really specific to the >>= operator
07:52:56 <tdammers> that's like saying the names for the LHS and RHS of the addition operator are "number" and "number"
07:53:04 <berndl> I've seen the rhs called a callback sometimes.
07:53:11 <Iceland_jack> callback yeah
07:53:16 <tdammers> I wouldn't use those names though
07:53:18 <tdammers> they're misleading
07:53:41 <tdammers> "callback" suggests that something gets "called", but Haskell doesn't really have a notion of "calling" things, the execution model works differently
07:53:42 <Iceland_jack> lol according to Wiktionary addition/summation: (augend) + (addend) = (summand) + (summand) = (sum, total)
07:54:21 <berndl> (>>=) is like function application: you have a function and a argument and (>>=) "calls" that function on the argument.
07:54:44 <berndl> Except the argument is on the lhs and the function is on the rhs.
07:54:45 <tdammers> function application /= call
07:54:59 <tdammers> (because (Haskell) function /= "function" (procedure))
07:55:51 <tdammers> "continuation" kind of works if you squint a lot, but I'm not sure the term is more helpful than just "the RHS operand"
07:55:54 <berndl> It's a good analogy though.
07:56:40 <dminuoso> noctux: A well defined term for the right hand side (`a -> m b` for some fixed m, a and b) is Kleisli arrow.
07:56:59 <dminuoso> Whether its a useful or good term depends on who you talk to though.
07:57:00 <hseg> ... wait - suppose I set RebindableSyntax and let fromInteger :: C a => Integer -> a. Must I have an instance C Integer for fromInteger 0 to be legal?
07:57:22 <tdammers> I don't think it's a very helpful analogy
07:57:41 <merijn> @quote category.of.analogies
07:57:41 <lambdabot> No quotes match. Take a stress pill and think things over.
07:57:43 <merijn> aww
07:57:58 <hseg> nm, can just avoid that fromInteger call
07:58:02 <tdammers> > ['a2,3] >>= replicate 2
07:58:04 <lambdabot>  error:
07:58:04 <lambdabot>      • Syntax error on 'a2
07:58:04 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
07:58:06 <tdammers> bleh
07:58:10 <hseg> merijn: what about analogies?
07:58:14 <tdammers> > ['a', 'b', 'c'] >>= replicate 2
07:58:16 <lambdabot>  "aabbcc"
07:58:29 <merijn> tdammers: Of course has a notion of calling things, it just doesn't have a notion of "when"
07:58:32 <tdammers> calling "replicate 2" a "continuation" here isn't very helpful in understanding what's going on
07:58:35 <dminuoso> noctux: This choice of term is reflected in the base documentation for (<=<) and (>=>), which our haddock page calls right-to-left and left-to-right Kleisli arrow composition.
07:59:08 <tdammers> merijn: I prefer the interpretation that "calling things" is an implementation detail that is (almost) sufficiently hidden from the programmer
08:00:44 <noctux> ok, thanks, I had expected that naming was difficult here. but searching for (>>=) is not that easy :). But yeah Kleisli Arrow sounds precise, even though I think confusing for people not that deep into the field
08:01:08 <tdammers> (>>=) is commonly called the "bind operator" though, or "monadic bind"
08:01:25 <tdammers> it's the arguments that are difficult to find names for
08:01:44 <dminuoso> noctux: Part of the problem is that monad is a highly generic abstraction with no particular purpose.
08:02:13 <noctux> tdammers: yepp, I know at least that much :)
08:02:15 <dminuoso> noctux: Any attempt at giving it a less abstract name is just some bias which distracts from monads true goal, to abstract away from any particular details
08:02:55 <dminuoso> noctux: Monad is not about IO or list or Maybe. It's about capturing the common pattern, which is basically just the shape of (>>=) and some laws. Whatever names you are left with, are just completely non-descriptive
08:02:57 <noctux> dminuoso: yeah, but "lhs" and "rhs" are even more abstract than (>>=)
08:03:11 <noctux> dminuoso: because I could use that term for things that are no monads
08:03:21 <codedmart> How do you represent a null byte with ByteString?
08:03:54 <dminuoso> codedmart: Data.ByteString.Char8.singleton '\0'
08:04:05 <tdammers> noctux: fortunately, we don't usually have to talk about monadic code all that much in this much detial
08:04:19 <noctux> dminuoso: I was just wondering whether anyone came up with terms. I mean, in academic writing, people often are picky about their naming and have to reference specific "objects"...
08:04:21 <noctux> tdammers: :)
08:04:55 <berndl> In academic writing, people use single letter identifiers.
08:05:02 <dminuoso> noctux: So most of academia in this area has focused on the Kleisli category.
08:05:09 <solonarv> codedmart: Data.ByteString.singleton 0
08:05:33 <solonarv> the elements of a ByteString are Word8, which has a Num instance
08:05:35 <dminuoso> noctux: Or from other exotic perspectives. All of them dont talk about (>>=). They all focus on join or <=< as the principle action
08:05:51 <merijn> dminuoso: >:(
08:05:58 <noctux> berndl: yeah. If they suffice :p
08:05:59 <solonarv> that's because the laws are much prettier when written in terms of <=< or join, tbh
08:06:02 <dminuoso> solonarv: Ah indeed, that's better :)
08:06:06 <merijn> dminuoso: Don't gratuitously hand people Char8 >.<
08:06:27 <dminuoso> solonarv: I dont think its about laws being prettier, you dont get anything nice and symmetric from (>>=)
08:06:40 <noctux> Anyways, thanks for clearing that up a bit for me!
08:07:09 <merijn> >=> is far prettier in terms of laws than >>=
08:07:11 <berndl> dminuoso: it looks more symmetric in do notaiton.
08:07:15 <solonarv> dminuoso: that is exactly what I mean by "prettier"
08:07:23 * hackage intmap-graph 1.1.0.0 - A graph library that allows to explore edges after their type  https://hackage.haskell.org/package/intmap-graph-1.1.0.0 (TillmannVogt)
08:07:47 <merijn> >=> lets you just say "return is left and right identity for Kleisli composition" writing the same for >>= is ugly as sin
08:07:57 <dminuoso> solonarv: My point is, the join perspective is useful for category theorists who consider monad as a monoid. >=> is nice for category theorists who consider a kleisli category.
08:08:04 <dminuoso> solonarv: Im not talking about how to visualize laws in Haskell
08:08:38 <dminuoso> berndl: Sure, but do-notation is not a field that has received broad interest in category theory. :)
08:09:08 <berndl> It's not fair to compare >=> and >>= though. >>= is just the flipped version of the extension operator defining a Kleisli triple.
08:09:19 <dminuoso> berndl: Hold on! Can you elaborate on that?
08:10:06 <berndl> dminuoso: The extension operator (usually a superscript *) takes a morphism a -> m b and turns it into m a -> m b.
08:10:19 <dminuoso> berndl: Oh! I stand correct then!
08:10:25 <dminuoso> That's just =<<
08:11:23 <dminuoso> berndl: When you say superscript, does that mean `t^*` assumes `t` to be some morphism `a -> m b`?
08:11:47 <dminuoso> (for some choices of a, m and b)
08:12:00 <berndl> Yes: https://en.wikipedia.org/wiki/Kleisli_category#Extension_operators_and_Kleisli_triples
08:12:46 <dminuoso> Mmm. How were monads discovered anyway? What motivation was behind their discovery?
08:13:16 <codedmart> dminuoso solonarv Thanks I thought that.
08:13:32 <merijn> Moggi thought "hey, isn't this stuff applicable to programming languages" and then Wadler heard his ideas and went "yoink!"
08:13:44 <merijn> That's the gist of it, as far as I can tell :p
08:14:04 <codedmart> Anyone familiar with the haskell dbus package? I am trying to debug why auth fails on freebsd. It works fine on my linux boxes.
08:14:17 <dminuoso> merijn: Im not talking about their advent in Haskell, but their origins in mathematics
08:14:49 <berndl> dminuoso: I think they were discovered in some area of algebraic topology.
08:15:57 <dminuoso> berndl: Ah that helped. A quick google suggests Godement came up with "a standard construction of a flabby sheaf embedding" in 1958 in fact.
08:17:23 * hackage apecs 0.9.0 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.9.0 (jonascarpay)
08:18:11 <hseg> Right. https://ncatlab.org/nlab/show/monad+in+algebraic+geometry gives some more context, especially the last couple lines
08:18:21 <hseg> ... ofc, context needs context
08:18:23 * hackage apecs-gloss 0.2.4, apecs-physics 0.4.4 (jonascarpay): https://qbin.io/gonna-polo-9twb
08:19:23 * hackage apecs-stm 0.1.3 - STM stores for apecs  https://hackage.haskell.org/package/apecs-stm-0.1.3 (jonascarpay)
08:45:24 * hackage stack-templatizer 0.1.0.0 - Generate a stack template from a folder.  https://hackage.haskell.org/package/stack-templatizer-0.1.0.0 (lysergia)
08:52:53 * hackage generic-optics 2.0.0.0, generic-lens-core 2.0.0.0 (kcsongor): https://qbin.io/duty-after-gm7b
08:53:53 * hackage generic-lens 2.0.0.0 - Generically derive traversals, lenses and prisms.  https://hackage.haskell.org/package/generic-lens-2.0.0.0 (kcsongor)
09:06:58 <dsal> Are consulting offices open?  I was making a tiny program to do a tiny thing last night and ran into a conflict.  I was trying to use a ReaderT IO to pass my arguments around, but I'm also using AWST (amazon AWS) which led to confusion.  Wrapping it inside my ReaderT, I couldn't get to what it wanted.  The other way around, I couldn't get my args.
09:07:02 <dsal> What's the right way to compose these things?
09:07:31 <dsal> (note: the AWS library uses the class mechanism for accessing parameters, if that makes a difference)
09:08:37 <heatsink> Does AWST wrap IO?
09:09:51 <dsal> I can get IO at the bottom in either case.
09:10:03 <heatsink> ok
09:10:20 <dsal> runAWST :: HasEnv r => r -> AWST' r m a -> m a
09:10:43 <dsal> It's this thing:  https://hackage.haskell.org/package/amazonka-1.6.1/docs/Control-Monad-Trans-AWS.html
09:10:44 <heatsink> One way to do it is to instantiate HasEnv for ReaderT
09:11:32 <heatsink> I'm assuming HasEnv is the AWS library class you referred to
09:11:40 <heatsink> instance HasEnv m => HasEnv (ReaderT r m)
09:11:55 <dsal> Hmm...  That doesn't sound awful.  For some reason, I assumed I'd need all of the methods of env, but it's got a single wrapper method that might not be that bad.
09:12:54 <dsal> So I could put the AWS env in my env and do all the wrapping in one place.  The names aren't awesome, but I might give that a shot.
09:15:01 <heatsink> r is the environment type.  It wouldn't be HasEnv (ReaderT r m) then
09:15:52 <heatsink> Looks like HasEnv is designed to work with an extensible environment.  One that has AWST's data and other data.
09:19:30 <dsal> Yeah.  Thanks for the pointers.  I think I can see how it might work.
09:20:02 <dsal> Not quite as easy since I'm passing around my commandline options directly, but just for the educational value, I can complicate things slightly and pass a bit more.
09:27:53 <statusfailed> Is it possible to declare an instance of Category where the type has constraints on the domain/codomain types?
09:28:14 <statusfailed> something like this--  data C a b; instance (Eq a, Eq b) => Category (C a b)
09:28:38 <dmwit> I don't understand why AWST was designed as it was.
09:28:40 <dmwit> It seems bad.
09:28:47 <statusfailed> I also tried declaring C as a GADT (data C where C :: (Eq a, Eq b) => ...)
09:29:00 <dmwit> You should make your own AWST that does MonadAWS but passes through the MonadReader bit.
09:29:30 <dmwit> s/should/could/
09:30:08 <gaurish108> d
09:30:11 <gaurish108> 
09:30:25 <dmwit> statusfailed: Not really. You need a different class for that.
09:30:42 <statusfailed> shiiiiet
09:31:08 <statusfailed> I thought that's what this was for: https://gitlab.haskell.org/ghc/ghc/issues/2893
09:31:11 <statusfailed> but maybe not?
09:31:25 <dmwit> mmmm
09:31:31 <dmwit> I think that's a bit different, yeah.
09:32:29 <berndl> statusfailed: Ever heard of constrained categories?
09:33:04 <statusfailed> berndl: nope
09:33:16 <dmwit> But like... what do you actually lose by not having a Category instance? There's almost no interesting operations which are Category-polymorphic.
09:33:47 <statusfailed> well it's nice to have (.) as composition without overloading it again
09:34:25 <statusfailed> and I really do have a category, so it would be nice if I could make it an instance of Category
09:34:48 <statusfailed> if it's not possible it's no real biggie though
09:34:55 <statusfailed> I can just have a "compose" function and get on with it :D
09:35:05 <dmwit> class StatusFailedCategory c where type CId c a; type CComp c x y z; id :: CId c a => c a a; (.) :: CComp c i o => c y z -> c x y -> c x z
09:35:27 <statusfailed> stlil have to overload (.) there
09:35:42 <statusfailed> as you say, there's not much point creating a new class to do it
09:35:44 <dmwit> instance StatusFailedCategory (->) where type Cid c a = (); type CComp c x y z = (); id x = x; (f . g) x = f (g x)
09:36:41 <dmwit> There may even be a package lying around with this class in it already.
09:36:45 <berndl> statusfailed: https://hackage.haskell.org/package/constrained-categories
09:37:31 <statusfailed> oh this is kinda nice
09:37:39 <statusfailed> dmwit: indeed there is :D
09:38:24 <statusfailed> berndl: cheers, looks like I could use it!
09:39:42 <berndl> I don't think it's that nice. Ultimately the problem is that Haskell doesn't have dependent types (yet), so you cannot define the Category abstraction properly.
09:40:25 <statusfailed> Yeah it's a bit clunky compared to say idris
09:40:28 <statusfailed> but I'm not ready to rewrite :D
09:40:40 <statusfailed> thanks for the link though
09:50:30 <dsal> Actual code I just wrote and now feel kind of stupid about:     Yes . Right . whatever
09:51:05 <phadej> :D
10:01:25 <jle`> dsal: self-documenting code
10:20:53 * hackage universal 0.0.1.0 - Universal  https://hackage.haskell.org/package/universal-0.0.1.0 (MatthewFarkasDyck)
10:31:14 <boxscape> Hm, since a few days ago if I download the nix package for ghc 8.6.5 (but not any other version), running ghc or ghci instantly segfaults. Is there a way to debug this?
10:39:23 * hackage parameterized-utils 2.0.2 - Classes and data structures for working with data-kind indexed types  https://hackage.haskell.org/package/parameterized-utils-2.0.2 (KevinQuick)
10:46:53 * hackage libarchive 2.2.1.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.1.0 (vmchale)
11:04:53 * hackage language-sygus 0.1.1.2 - A parser and printer for the SyGuS 2.0 language.  https://hackage.haskell.org/package/language-sygus-0.1.1.2 (WilliamHallahan)
11:21:25 <sm> boxscape: how about turning on all verbosity/debug flags, and also running with strace
11:23:00 <sm> and contacting the ghc nix package maintainer or nix package issue tracker ? I know these may not exist, I'm curious
11:26:06 <boxscape> verbosity flags don't seem to do anything but strace info could be useful I suppose
11:26:27 <boxscape> there's an issue tracker for all nix packages taken together, not sure if they individually have maintainers assigned
11:42:17 <__monty__> boxscape: On which platform and distro? Works for me on macOS.
11:43:01 <boxscape> __monty__ x86 64bit nixos. It works on my phone too.
11:44:30 <boxscape> (luckily I can use 8.8 for what I'm doing at the moment)
11:44:45 <__monty__> What channel?
11:45:21 <boxscape> unstable. I suppose I could try one of the other ones
11:47:18 <boxscape> seems to be the same package for other channels though, unless I'm missing a step between adding the channel with name "nixos" and running nix-shell -p ghc
11:49:12 <boxscape> I did miss something, I have to update the channel
11:55:25 <boxscape> hm ghc 8.6.5 in the 19.09 channel works
11:55:51 <maerwald> amazonka API... full of type families and respond type resolution, but status code is a full Int :)
12:49:53 * hackage hmatrix-vector-sized 0.1.3.0 - Conversions between hmatrix and vector-sized types  https://hackage.haskell.org/package/hmatrix-vector-sized-0.1.3.0 (jle)
13:12:04 <aviD> cabal v2-configure keeps spiting out Cabal-2.4.1.0, but in my .cabal file I have Cabal >= 3.0. Why?
13:14:43 <yushyin> aviD: cabal 3.0 does not support version ranges anymore, I think. try 'cabal-version: 3.0'
13:15:31 <merijn> I think he's talking about dependency on Cabal the library
13:15:46 <yushyin> oh
13:15:46 <merijn> cabal-version is unrelated
13:16:02 <yushyin> i misread, sorry.
13:16:03 <merijn> aviD: Can you pastebin the cabal file?
13:16:26 <aviD> I should have been more specific, Cabal >= 3.0 is a build dependency.
13:17:04 <merijn> aviD: Well, one issue I can think of: Did you run v2-update yet? (i.e. does your local index even have Cabal >= 3.0)
13:17:48 <aviD> I added a `constraints: Cabal == 3.0` to cabal.project and now it's at least erroring . I'll paste it if I'm unable to fix the error.
13:21:03 <aviD> I did not know this was possible, with the constraint in cabal.project it wants to build two versions?
13:21:03 <aviD>  - Cabal-2.4.1.0 (lib) (requires build)
13:21:03 <aviD>  - Cabal-3.0.0.0 (lib) (requires download & build)
13:21:52 <monochrom> should not be possible
13:23:11 <phadej> custom setup setup-depends can use different Cabal than the main install plan
13:23:14 <phadej> "normal"
13:23:46 <aviD> The repo uses backpack, might that be related?
13:26:21 <aviD> Anyone know a good way of finding out why cabal needs a package?
13:26:34 <aviD> cabal-db no  longer builds?
13:26:50 <monochrom> Blindfolded? I say no.
13:27:56 <solonarv> I think cabal-plan can draw you a graph, maybe that would help
13:29:00 <phadej> as I said, some packages' custom-setup asks for older Cabal
13:29:43 <phadej> try with `constraints: any.Cabal ==3.0.*`
13:29:51 <phadej> (==3.0 won't match any version)
13:34:51 <aviD> :phadej that did make cabal let me know where 2.4 came from. Thanks
13:35:11 <aviD> what does `any.` do?
13:35:37 <dsal> :t any .
13:35:39 <lambdabot> error:
13:35:39 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:35:43 <dsal> :t (any .)
13:35:44 <lambdabot> Foldable t => (a1 -> a2 -> Bool) -> a1 -> t a2 -> Bool
13:36:10 <dsal> Heh.  That's probably not the same any.
13:36:14 <geekosaur> any.Cabal means any component with a dependency on Cabal library
13:36:23 * hackage mutable 0.1.0.1 - Automatic piecewise-mutable references for your types  https://hackage.haskell.org/package/mutable-0.1.0.1 (jle)
13:36:39 <geekosaur> as opposed to being a direct dependency
13:37:15 <aviD> geekosaur Thanks
13:37:53 <phadej> the constraint syntax is undocumented and not so logical and only half-expressive; so better not to try to remember it too hard
13:38:52 <phadej> c.f. allow-newer syntax, which is similar but completely different 
13:39:10 <phadej> those are messy bits, which I hopefully get to at some point
13:39:57 <phadej> you can only imagine how many unspecified grammars/parsers there are in Cabal
13:44:48 <msvan> Is it possible to write a function taking two arguments which pattern matches on data constructor equality?
13:44:51 <msvan> eg something like
13:44:55 <msvan> f (C _) (C _) = True
13:44:57 <msvan> f _ _ = False
13:45:17 <phadej> that's valid yes.
13:45:32 <solonarv> well, you are matching specifically on the constructor C
13:45:36 <msvan> wait, that's valid as-is?
13:45:39 <solonarv> you are not matching on "the same constructor, twice"
13:46:50 <msvan> right, I want to match on some constructor C, not C specifically
13:46:50 <geekosaur> also that's only valid if the constructor takes a single parameter
13:47:12 <geekosaur> no, you can't check that two parameters have the same constructor with a pattern match
13:47:15 <glguy> To not worry about how many fields the constructor has you can use: C{}
13:47:42 <msvan> @glguy convenient
13:47:42 <lambdabot> Unknown command, try @list
13:47:44 <Nolrai> Is there a term for monoids where "a <> b == mempty" implies "a == mempty && b == mempty"
13:48:10 <glguy> To do something for any two arbitrary constructors you'd either have to write something to pick out which constructor something was and compare for equality on that or dive into GHC internals and use something like GHC.Base.getTag
13:48:46 <geekosaur> nolrai: monoid? (think about the monoid laws)
13:49:03 <msvan> I could just write it out manually for all of the constructors, but I was hoping there'd be a shortcut
13:49:15 <solonarv> geekosaur: this definitely does not hold in every monoid
13:49:27 <solonarv> for example, it doesn't hold in (Z, +) but it does hold in (N, +)
13:49:46 <Nolrai> geekosaur: proper monoid I guess? Its basicly just means it _not_ a group.
13:50:01 <merijn> Not a group is not sufficient
13:50:09 <solonarv> not a groups means *some* inverses don't exist, what you want is "no inverses exist"
13:50:14 <merijn> Groups requires every element has an inverse
13:50:17 <solonarv> (other than mempty^-1 = mempty)
13:50:26 <merijn> But your theory already sinks if a single inverse exists
13:50:44 <Nolrai> Oh right, its distribuivity that forces inverses to be all or nothing.
13:51:57 <Nolrai> I think I will call it "unsigned".
13:52:40 <Nolrai> Even if its not quite the same thing.
14:00:52 <jle`> msvan: you can use some generic programming tools that GHC offers to accomplish that
14:01:04 <jle`> like Data.Data (easiest)
14:01:20 <jle`> @let sameConstr x y = toConstr x == toConstr y
14:01:21 <lambdabot>  Defined.
14:01:27 <jle`> > sameConstr Nothing Nothing
14:01:29 <lambdabot>  error:
14:01:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘sameConstr’
14:01:29 <lambdabot>        prevents the constraint ‘(Data a0)’ from being solved.
14:01:45 <jle`> > sameConstr (Just True) (Just False)
14:01:47 <lambdabot>  True
14:01:55 <jle`> > sameConstr (Just True) (Nothing :: Maybe Bool)
14:01:57 <lambdabot>  False
14:02:03 <jle`> > sameConstr (Nothing :: Maybe Bool) (Nothing :: Maybe Bool)
14:02:05 <lambdabot>  True
14:02:20 <jle`> msvan: so you can use this with guards i suppose
14:02:38 <jle`> msvan: f x y | toConstr x == toConstr y = ...; | otherwise = ...
14:02:56 <monochrom> If your monoid is a group, then x<>y=mempty does not imply x=mempty or y=mempty, they could be inverses of each other.
14:03:14 <jle`> it's possible to do this with ghc generics as well though it is a little trickier
14:03:29 <jle`> or a bit less out-of-the-box, at least
14:04:43 <msvan> jle`: well that looks handy
14:05:49 <jle`> msvan: it's not necessarily doing anything magical, it's the same sort of trick as Typeable
14:06:40 <jle`> basically like having a class `class ToConstr a where toConstr :: a -> String`, and then auto-deriving instances like `instance ToConstr (Maybe a) where toConstr Nothing = "Nothing"; toConstr (Just _) = "Just"
14:07:00 <jle`> except into a type slightly more structured than String
14:09:08 <zq> hi
14:09:58 <zq> does the right zero MonadFail law imply that IO cannot be an instance?
14:10:30 <zq> right zero law is: forall v s. v >> fail s = fail s -- from https://wiki.haskell.org/MonadFail_Proposal
14:10:45 <solonarv> well, IO *is* an instance in practice
14:10:56 <jle`> zq: yeah, IO doesn't satisfy that law
14:11:11 <jle`> but note that that law wasn't actually adopted by MonadFail
14:11:13 <jle`> https://hackage.haskell.org/package/base/docs/Control-Monad-Fail.html
14:11:35 <jle`> the only canonical law is left zero
14:11:45 <msvan> jle`: it works. thanks!
14:11:46 <zq> ok
14:11:53 <jle`> msvan: np :))
14:17:23 * hackage extra 1.6.19 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.19 (NeilMitchell)
14:27:46 <WinchellsM> Is there a way to specify a dependency on a Haskell lib in the form of a *.so file (as opposed to an archive/git repo/hackage location)?
14:27:55 <WinchellsM> In stack.yaml or even cabal file?
14:33:12 <monochrom> Something about extra-libraries: and pkg-config
14:35:45 <monochrom> s/and/or/
14:36:04 <monochrom> in the case of pkg-config, something about pkgconfig-depends:
14:55:24 * hackage clist 0.3.0.1 - Counted list  https://hackage.haskell.org/package/clist-0.3.0.1 (MatthewFarkasDyck)
14:58:04 <Guest_79> I can't get my terminal to connect to module
14:58:34 <jackdk> your query is unclear, Guest_79 
14:59:07 <monochrom> Is that generated by a markov chain?!
14:59:18 <Guest_79> I just started Haskell, I have everything downloaded, but when I try to load 
14:59:37 <sm> try flipping the hyperspace phase stabiliser
15:00:06 <dminuoso> Must be the comcast connection. Half of the message just didn't survive the transport. Not even TCP could fix this.
15:00:44 <monochrom> [Obligatory TCP joke omitted]
15:00:47 <sm> I *told* them...
15:03:22 <dminuoso> monochrom: Please repeat your joke, it didn't come through.
15:03:35 <monochrom> :)
15:05:14 <sm> so, here we all are, minus one Guest.. has anybody else got a problem ? Preferably an easier one ?
15:05:46 <monochrom> I am looking for a solitaire game, simple enough for students to code up.
15:06:07 <maerwald> pick one from pysolfc
15:06:27 <maerwald> can check the implementations there as well
15:06:39 <sm> does it have to be solitaire ? what about this variant of tic tac toe I just read about, where you have at most three pieces and have to reuse them 
15:07:09 <maerwald> https://github.com/shlomif/PySolFC/tree/master/pysollib/games
15:07:34 <glguy> sm: I made a version of that game when I was younger. I played it with my family using sugar packets at restaurants. The extra bit of fun was that there was no defined board, the placed pieces just needed to fit within a 3x3 grid
15:07:38 <glguy> but that grid could move as pieces moved
15:08:08 <sm> heh. The article seemed to say variants like this have more interesting strategy ?
15:09:03 <glguy> monochrom: You could do something like this: https://boardgamegeek.com/boardgame/173090/game
15:09:43 <glguy> simple game and it makes sense with one player or multiple
15:09:58 <glguy> 4 stacks, 2 count up, 2 count down, cards from 1 to 100
15:10:23 <glguy> extra trick that you can reverse order if the card is exactly ten in the reverse direction
15:11:03 <glguy> There's also a bunch of solitaire games in the Zachtronics series of games that might be worth considering
15:11:12 <Nolrai> So hspec is running the tests I've marked pending. Am I missing some flag or something?
15:11:38 <sm> cools stuf at https://www.smithsonianmag.com/science-nature/best-board-games-ancient-world-180974094 too (shields up, engage reader mode)
15:12:15 <Nolrai> I've thought about making AIs for the Zachtronics games.
15:14:24 <Nolrai> Okay so "pending" works as expected, but xit seems to behave identically to it.
15:14:29 <Nolrai> I am confused.
15:17:26 <Nolrai> Anyone here understand hspec?
15:21:29 <sm> if you can rearrange that into an english word, I'll throw magic pixie dust at it
15:23:59 * sm has failed to think of one.. wow I must be bored
15:29:44 <sm> so Nolrai: "Changing it to xit marks the corresponding spec item as pending. This can be used to temporarily disable a spec item.". Everything's fine.
15:30:04 <Nolrai> Right, but it isn't disabling it.
15:30:53 <sm> "During a test run a pending spec item is: 1. not executed 2. reported as pending".. those aren't working ?
15:31:15 <Nolrai> xit is behaving the same as it afaict.
15:31:33 <Nolrai> "xit" and "it
15:31:35 <Nolrai> "
15:32:12 <Nolrai> If I manually replace the test with "pending" that works.
15:34:04 <sm> xit does before_ pending_ ...
15:35:20 <sm> pending_ is pending without a callstack or test location
15:37:12 <sm> before_ is http://hackage.haskell.org/package/hspec-core-2.7.1/docs/Test-Hspec-Core-Hooks.html#v:before_
15:37:50 <sm> time to bug your kindly package author
15:39:24 * hackage tree-sitter-php 0.3.0.1 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.3.0.1 (aymannadeem)
15:40:53 * hackage refractor 0.0.1.0 - See README for more info  https://hackage.haskell.org/package/refractor-0.0.1.0 (MatthewFarkasDyck)
16:06:36 <wolfcomm> i know this is a haskell channel but does anyone know if there's a way to make this function pointfree using the ramda library? (a, b) => f(a)(b)
16:08:07 <dminuoso> @pl \f -> \(a,b) -> f a b
16:08:07 <lambdabot> (`ap` snd) . (. fst)
16:08:49 <dminuoso> wolfcomm: The canonical way would be to uncurry f
16:08:52 <dminuoso> :t uncurry
16:08:53 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:09:25 <dminuoso> Ramda appears to have uncurryN, which gives you that exactly.
16:10:26 <wolfcomm> yeah that was the first thing i tried. it seemed pretty obvious
16:16:55 <wolfcomm> here's the ramda repl: https://bit.ly/2SjYSd6
16:17:06 <wolfcomm> i can provide the whole link but it's long
16:22:14 <Nolrai> Huh, somehow Hspec.SmallCheck.property is causing the xit's 'before_' to not trigger.
16:27:03 <dminuoso> wolfcomm: Honestly, I can't stand this poor attempt of giving you the impression and hipster feeling of functional programming without a type system.
16:27:18 <dminuoso> wolfcomm: ramda is just not worth it.
16:28:03 <dminuoso> Even with flow-typed inference just breaks all over the place
16:29:03 <hololeap> :t (<*> snd) . (. fst)
16:29:05 <lambdabot> error: lexical error at character '\EOT'
16:29:11 <hololeap> :t (<*> snd) . (. fst)
16:29:12 <lambdabot> error: lexical error at character '\EOT'
16:29:16 <wolfcomm> lol
16:29:20 <hololeap> :t (<*> snd) . (. fst)
16:29:21 <lambdabot> (a1 -> a2 -> b) -> (a1, a2) -> b
16:29:33 <wolfcomm> :t ramda
16:29:33 <dminuoso> wolfcomm: Actually it works, its just javascript being weird.
16:29:34 <lambdabot> error: Variable not in scope: ramda
16:29:40 <Axman6> a.k.a uncurry
16:29:55 <dminuoso> wolfcomm: Just explicitly use console.log
16:35:59 <wolfcomm> dminuoso: i tried the same code in my terminal node repl. it just returns a function. i think uncurryN expects an explicitly curried n function
16:39:02 <dminuoso> wolfcomm: *shrugs*
16:41:17 <wolfcomm> dminuoso: would you happen to know if folktale is any good?
16:41:47 <dminuoso> wolfcomm: Im convinced it cant be.
16:42:10 <wolfcomm> dminuoso: ok
16:42:13 <dminuoso> wolfcomm: Functional programming relies on high degrees of compositionality. Without a type system it's an uphill battle you can't win.
16:42:52 <dminuoso> If you have any non-trivial program, the lack of a type system will leave you just experimenting and figuring out why and even where your code blew up.
16:43:09 <wolfcomm> dminuoso: gotcha, i wanted to learn haskell anyway
16:43:26 <dminuoso> wolfcomm: If you do want to stay close to the browser, you can also consider PureScript by the way.
16:43:32 <dminuoso> It's relatively close to Haskell
16:44:41 <wolfcomm> dminuoso: thanks i'll check it out
17:00:24 * hackage tree-sitter-php 0.4.0.0 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.4.0.0 (aymannadeem)
17:19:39 <zeta_0> could you guys give me a hint on how to solve this, i am not sure how to traverse threw the array while comparing the elements to see if they match: https://www.hackerrank.com/challenges/sock-merchant/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=warmup
17:21:39 <zeta_0> nevermind, i'll try again later
17:26:53 <[itchyjunk]> i dont assume there is an inbuild eulers number right?
17:28:04 <ChaiTRex> > exp 1
17:28:06 <lambdabot>  2.718281828459045
17:28:12 <ChaiTRex> [itchyjunk]: ^
17:28:17 <[itchyjunk]> ah
17:28:43 <[itchyjunk]> i have a formula e^-lambda * lambda^k / k! . now k goes from 1 to 6 and i know everything else
17:28:55 <[itchyjunk]> i was trying to think of a way to use map but maybe that won't do
17:29:53 <ChaiTRex> [itchyjunk]: What is lambda?
17:29:54 <[itchyjunk]> oh wait!
17:30:13 <[itchyjunk]> lambda is 10 in my case, its the parameter to the poisson mass function
17:30:24 <[itchyjunk]> ah crap
17:30:46 <[itchyjunk]>  f k =(2.718281828^(-10) * 10^k) / [1..k]
17:30:51 <[itchyjunk]> thought this might have worked
17:31:01 <[itchyjunk]> i was then planning to map f [1..6]
17:31:27 <ChaiTRex> [itchyjunk]: Use exp (-10)
17:31:51 <[itchyjunk]> oh right you just told me about exp
17:31:55 <ChaiTRex> [itchyjunk]: Do you sum the results?
17:32:10 <[itchyjunk]> yes i need to 1 - (sum of those)
17:32:17 <[itchyjunk]> but i was gonna do the rest manually 
17:32:23 <[itchyjunk]> still non type-variable error
17:33:00 <[itchyjunk]> i think it doesn't like exp(-10) is floating but k is integral
17:33:14 <ChaiTRex> > (* (exp (-10))) . sum . map (\ k -> 10^k / product [1 .. k]) [1 .. 6]
17:33:17 <lambdabot>  error:
17:33:17 <lambdabot>      • Couldn't match expected type ‘a -> [c]’ with actual type ‘[b0]’
17:33:17 <lambdabot>      • Possible cause: ‘map’ is applied to too many arguments
17:33:26 <ChaiTRex> > (* (exp (-10))) . sum . map (\ k -> 10^k / product [1 .. k]) $ [1 .. 6]
17:33:28 <lambdabot>  error:
17:33:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M225424042073...
17:33:28 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:33:53 <ChaiTRex> > (* (exp (-10))) . sum . map (\ k -> 10^k / product [1 .. k]) $ [1 .. 6 :: Double]
17:33:55 <lambdabot>  error:
17:33:55 <lambdabot>      • No instance for (Integral Double) arising from a use of ‘^’
17:33:55 <lambdabot>      • In the first argument of ‘(/)’, namely ‘10 ^ k’
17:34:03 <ChaiTRex> > (* (exp (-10))) . sum . map (\ k -> 10**k / product [1 .. k]) $ [1 .. 6 :: Double]
17:34:06 <lambdabot>  0.1300960209527205
17:34:57 <[itchyjunk]> can i tell my thing to be double? i'd like to see it work
17:35:21 <ChaiTRex> [itchyjunk]: What is your thing?
17:35:36 <[itchyjunk]> f k =(exp(-10) * 10^k) / [1..k]
17:35:58 <[itchyjunk]> i wanna mke this f work but i think it doesn't like Integral k
17:36:15 <ChaiTRex> [itchyjunk]: f :: Double -> Double
17:36:56 <[itchyjunk]> ah is this something i can't do in ghci?
17:37:12 <ChaiTRex> [itchyjunk]: let f :: Double -> Double; f = ...
17:37:53 <[itchyjunk]> • Couldn't match expected type ‘Double’ with actual type ‘[Double]’
17:38:13 <ChaiTRex> [itchyjunk]: That's because your denominator is a list.
17:38:19 <ChaiTRex> > [1 .. 6]
17:38:21 <lambdabot>  [1,2,3,4,5,6]
17:38:35 <ChaiTRex> [itchyjunk]: You probably want product [1 .. k]
17:38:38 <[itchyjunk]> ah right .. dang, i was trying to do factorial but did a list
17:38:53 <[itchyjunk]> foldl * 1 [1..k] ?
17:38:59 <[itchyjunk]> oh product might be easier
17:39:48 <MarcelineVQ> good intution though, to use  foldl (*) 1
17:39:49 <[itchyjunk]> • No instance for (Integral Double) arising from a use of ‘^’
17:40:04 <ChaiTRex> [itchyjunk]: You probably want **
17:40:23 <ChaiTRex> :t (^)
17:40:27 <lambdabot> (Integral b, Num a) => a -> b -> a
17:40:27 <ChaiTRex> :t (**)
17:40:27 <[itchyjunk]> i thought if k is int .. oh i am changing it to double
17:40:29 <lambdabot> Floating a => a -> a -> a
17:41:22 <[itchyjunk]> i can't believe this
17:41:35 <[itchyjunk]>  1 - sum(map f [0..6])
17:41:35 <[itchyjunk]> 0.8698585791175171
17:41:51 <[itchyjunk]> actually got correct answer. this is way more fun than manually churning the numbers
17:41:53 <[itchyjunk]> hhahahahaha
17:47:25 <[itchyjunk]> I reused the code for next problem /0\
17:47:27 <[itchyjunk]> sum(map f [7..13]) / (1 - sum(map f [0..6]))
17:47:27 <[itchyjunk]> 0.8441866521358086
17:47:41 <[itchyjunk]> https://imgur.com/a/zJkvlu3 so insane
18:19:54 * hackage symbiote 0.0.5 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.5 (athanclark)
18:37:23 * hackage Ritt-Wu 0.1.0.0 - Parallel implementation of Ritt-Wu's algorithm.  https://hackage.haskell.org/package/Ritt-Wu-0.1.0.0 (jsrqv)
19:29:03 <koz_> For 'foldr f z xs', is there a name for functions like f in this case? I'm thinking 'folder', but it doesn't seem right.
19:29:12 <koz_> SO like, the function that does the combining as part of the fold.
19:29:28 <Welkin> the accumulator
19:29:39 <Welkin> no
19:29:43 <Welkin> the accumulating function
19:29:46 <Welkin> orthe folding function
19:29:58 <koz_> Welkin: OK, makes sense.
19:30:03 <Welkin> the accumulator is the value
19:30:08 <koz_> The 'accumulator' I believe is one of the arguments to said function.
19:30:31 <mniip> it's the algebra
19:30:40 <mniip> of the ListF functor
19:31:14 <koz_> mniip: Yeah, I suppose in the full generality of it, is _is_ an algebra.
19:31:29 <koz_> (just of a more restricted form that those for recursion schemes generally)
19:31:33 <mniip> foldr evidences that [a] is the initial algebra of ListF by mapping every algebra of ListF to an algebra homomorphism from [a]
19:32:12 <texasmynsted> maybe not the place, but... There does not appear to be a haskell pandoc filter for replacing "variables" in body text with metadata from the AST.
19:32:55 <texasmynsted> This sounds like a job for a parser. I know there are many parsers available but would appreciate some guidance.
19:33:52 <texasmynsted> What would be the simplest way to implement a simple replacing parser for pandoc body text. I see something like a mustache pandoc filter but it is python...
19:34:11 <Welkin> I can't think of anything but Texas Toast when you see your name texasmynsted 
19:34:20 <koz_> Welkin: Me neither.
19:34:21 <texasmynsted> hhe
19:34:24 <koz_> ANd that's making me hungry.
19:34:32 <texasmynsted> well okay then
19:34:56 <Welkin> I prefer french toast myself
19:35:36 <koz_> French toas is great. Croque monsieur is even better.
19:35:42 <koz_> s/toas/toast/
19:35:54 <koz_> (wtf is toas, some kind of new syntax representation?)
19:36:32 <texasmynsted> I have had this nick for a while. Sorry it makes you hungry.
19:36:52 <texasmynsted> Just had TexMex a bit ago. Mmm
19:54:53 <dsal> I still don't think I'm doing this AWST thing right.   I've got   type Uploader = ReaderT MyEnv (AWST (ResourceT IO))
19:55:11 <dsal> MyEnv is a copy of the AWS env and my options, with a lens to make the AWS stuff happy.
19:55:16 <dsal> So I end up with this:  runResourceT . runAWST env $ runReaderT (mapM_ uploadFiles paths) (MyEnv env o)
19:55:47 <dsal> But none of my code needs the aws env, and aws doesn't need my stuff.  I'd hope I could just get the ReaderT out of the picture when I need to make an AWS call, but I don't see any helpful lift mechanism.
19:56:17 <Welkin> use MonadReader instead
19:56:36 <Welkin> typeclasses instead of an explicit monad transformer stack
19:58:15 <dsal> hmm...  This is a good project for trying different things.
20:24:37 <iqubic> The tagless final approach is a good one.
20:43:14 <Welkin> iqubic: what does that mean?
20:45:29 <dmj`> dsal: what are you trying to upload
20:45:53 * hackage uuid-bytes 0.1.1.0 - UUID parsing using byteverse packages  https://hackage.haskell.org/package/uuid-bytes-0.1.1.0 (goolord)
21:39:58 <dsal> dmj`: just pushing video bits up to s3.
21:40:41 <monochrom> "Pirate River Basin" :)
21:41:02 <monochrom> ("River Basin" instead of "Bay" because Amazon :) )
21:44:23 <monochrom> On more serious note, I just read the probability monad paper from Ramsey and Pfeffer.  Very surprised that the expected value monad is exactly Cont Double.  I.e., very surprised that Cont's >>= is expected value monad's >>=.
21:45:55 <ski> nqCPS ?
21:46:15 <monochrom> dunno
21:47:37 <monochrom> I think it's simpler.  Consider "e(X) = ..." as "e = lambda X. ...".  Now e :: (SampleSpace -> Real) -> Real.
21:48:18 <monochrom> But it's horrifying that its >>= goes on to behave like CPS.
21:48:31 <ski> yes, but presumably that wouldn't work with `Codensity'
21:48:45 <monochrom> It is easier to first see that its fmap and liftA2 behave like CPS.
21:49:04 <monochrom> Right this is not codensity.
21:49:16 <ski> yea, hence my nqCPS question
21:49:31 <monochrom> I don't know nqCPS, and too late night to want to know!
21:49:43 <ski> "not-quote-CPS"
21:49:45 <ski> er
21:49:49 <ski> "not-quite-CPS"
21:49:58 <monochrom> Um I don't think CPS presupposes codensity
21:50:05 <ski> just means that sometimes you don't tail call the continuation parameter
21:50:27 <Welkin> is ctags (emacs) for haskell just broken?
21:50:46 <Welkin> I generate the TAGS file, but it never works for "go-to-definition"
21:51:25 <monochrom> No I don't think CPS always tail-calls either.
21:51:57 <ski> depends on which constructs you transform
21:52:20 <ski> if it's just the basic constructs, it's always tail calls
21:52:38 <ski> if you include control operators, then no
21:56:50 <Welkin> do I need to use hasktags?
21:57:01 <Welkin> this is weird, universal-ctags doesn't generate any tags for haskell
21:57:10 <Welkin> but it works fine for elm
21:57:29 <Welkin> is hasktags the preferred way to generate ctags?
22:00:54 <Welkin> well damn, ctags doesn't support haskell. How odd.
22:01:00 <Welkin> it supports much less popular languages
22:06:01 <monochrom> bwahahaha I have just discovered https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html and it's giving me ideas for the next assignment!  (Basically I want to inflict a particular free monad on the students.)
22:06:24 <monochrom> To rub salt into insult, they have just done Huffman tree for the previous assignment!
22:27:50 <Welkin> awesome
22:27:53 <Welkin> hasktags works great
22:28:00 <Welkin> although I had to compile ig from source
22:52:28 <dmj`> dsal: why not just use the aws CLI tool
22:52:55 <dmj`> dsal: I had a whole project for signing s3 urls that I spent weeks on that was replaced in a single call to aws s3 sign
22:53:05 <dmj`> so now I just shell out to it :)
23:02:33 <dsal> dmj`: this program with amazonka is tiny and works well.  I'm mainly just trying to figure out how to compose stuff a little better.
23:03:36 <dsal> More of the code is finding and naming files than anything else.  Uploading is one line to get the aws env, one line to runaws and one to upload.
23:12:41 <turq> When is it valid to use trace from Debug.Trace?
23:13:24 <DaisyNewTownGirl> can you guys help me to debug it ? https://bit.ly/2SB5gvu
23:13:25 <Axman6> when debugging
23:13:57 --- mode: ChanServ set +o shachaf
23:14:00 <Axman6> DaisyNewTownGirl: can youy give us a non bit.ly URL? there's no way I'm clicking that
23:14:02 --- mode: shachaf set +b *!*fourroot3@2409:4052:80c:bb72:f833:25d6:90c4:*
23:14:02 --- kick: DaisyNewTownGirl was kicked by shachaf (DaisyNewTownGirl)
23:14:05 --- mode: shachaf set -o shachaf
23:14:08 <Axman6> thanks shachaf
23:53:19 <ddk> Hello all, a question about postgres-simple : is there any way we can use sql scripts within Haskell ?
23:54:50 <tdammers> "sql scripts"?
23:55:28 <ddk> tdammers: yes I mean a sql file containing commands 
23:56:03 <tdammers> those commands are just queries, no?
23:57:02 <ddk> yes like creating tables / triggers and all contained in one place :)  
23:57:19 <Solonarv> ddk: the query functions just have you write SQL and spit it at the DB without any processing, so this should certainly be possible
23:57:47 <dmj`> turq: whenever you want
23:58:27 <ddk> Solonarv: yeah that's why I'm looking 
