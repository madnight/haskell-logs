00:18:55 <dmwit> alc: Pfft, seven lines is way too many.
00:20:15 <dmwit> % data Expr = App Expr Expr | Lambda (Expr -> Expr); eval :: Expr -> Expr; eval (App f x) = case eval f of Lambda g -> eval (g x); eval x = x
00:20:16 <yahb> dmwit: ; <interactive>:104:130: error: Parse error in pattern: eval
00:20:36 <dmwit> % data Expr = App Expr Expr | Lambda (Expr -> Expr); eval :: Expr -> Expr; eval (App f x) = case eval f of {Lambda g -> eval (g x)}; eval x = x
00:20:36 <yahb> dmwit: 
00:20:49 <dmwit> four lines oughta be enough for anybody
00:37:16 <mniip> dmwit, that's not a strictly positive datatype
01:18:24 * hackage fcf-containers 0.2.0 - Data structures and algorithms for first-class-families  https://hackage.haskell.org/package/fcf-containers-0.2.0 (gspia)
01:25:32 <gspia> Hi, I just uploaded a package to hackage and when I look the examples of a module, only the last one is shown (even though many functions contain examples)
01:26:21 <gspia> Do you know how to solve that problem? Here is a direct link showing the problem: http://hackage.haskell.org/package/fcf-containers-0.2.0/docs/Fcf-Data-Set.html
02:06:20 <matheus23> I have a functor `F a` with an instance `instance Monoid a => Monoid (F a)`. How do I call `F`? Is it a monoid homomorphism? No, right?
02:23:25 <mniip> matheus23, endofunctor on Mon
02:23:40 <mniip> (The category of monoids)
02:33:53 <matheus23> mniip: Huh. 'Mon' was the category that only contained 1 object with lots of arrows between them, right? And endofunctor then means that it maps this one object to the other single object, while arrows are mapped from Mon to the other Mon, right?
02:34:00 <matheus23> Kind of hand-wavey my description...
02:34:09 <mniip> No
02:34:41 <mniip> Mon is the category whereobjects are monoids
02:36:18 <mniip> Its a subcategory of Set (generally Mon(C) is a subcategory of C)
03:11:37 <matheus23> mniip: ok! Thanks
03:28:04 <phadej> gspia: seems like it's a bug in haddock
03:29:12 <phadej> if i try to expand any Examples section, the last section (for ToList) is expanded, this cannot be right
03:29:43 <phadej> I don't know if it's fixed already in haddock which is bundled with ghc-8.8 or ghc-8.10; as hackage uses 8.6
03:29:56 <gspia> phadej: thanks for checking and telling this! Eventually, it probably will be fixed. Now I'm hesitating a bit between removing the example folding from all or just leaving
03:30:35 <gspia> ah, ok, so if it is possible that is already fixed, then maybe I won't touch the docs 
03:30:53 <gspia> s/that is/that it is/
03:30:53 <phadej> gspia: try locally :)
03:31:24 <gspia> hmm, ok, I'd like to. I have been able to use 881 ghc and ghci and cabal when testing the lib
03:32:02 <gspia> but how to test the docs? Hmm, maybe include the hoogle, start hoogle server and then look at the lib
03:32:35 <gspia> (my dev env is behind ssh so this is a bit clumsy, execpt that ssh -X could do also)
03:34:54 * hackage hw-rankselect 0.13.3.2 - Rank-select  https://hackage.haskell.org/package/hw-rankselect-0.13.3.2 (haskellworks)
03:41:32 <sourjo_> chat pog
03:41:53 <gspia> phadej: looks like it is fixed, tried with midori browser and the examples folded just as they should (and I did re-compile the docs with newer cabal)
03:42:43 <phadej> gspia: you can `cabal v2-haddock --haddock-for-hackage` and upload the doc-tarball manually
03:42:58 <sourjo_> pog
03:42:59 <phadej> somewhere from https://hackage.haskell.org/package/fcf-containers/maintain
03:43:18 <phadej> (the link in Maintainer's Corner of package page)
03:43:30 <phadej> ah, you did upload docs yourself
03:43:45 <gspia> phadej: ok, that all that I have done this far (I mean, only downloaded the docs manually, no idea how to enable the automatic doc building)
03:43:59 <gspia> s/that all/that's all/
03:44:06 <phadej> gspia: docs are built automatically if you don't upload them
03:44:14 <phadej> there's ~10..60min delays though
03:44:26 <phadej> depends on docbuilder state and queue
03:44:32 <gspia> ah ok, I haven't had enough patience then
03:44:49 <phadej> ~all my packages have docs autobuilt
03:44:53 <sourjo_> pog
03:51:18 <gspia> phadej: looks like I was able to fix some of the modules. For some reason the Fcf.Data.Set looks different compared to the other modules
03:55:45 <gspia> phadej: hmm, maybe browser caches, now it looks ok as well
03:55:54 <gspia> thanks for your help!
04:00:24 * hackage erd 0.2.1.0 - An entity-relationship diagram generator from a plain text description.  https://hackage.haskell.org/package/erd-0.2.1.0 (mmzx)
04:28:10 <Axman6> Who runs lambdabot these days?
04:30:35 <phadej> gspia: you're welcome
04:32:30 <MarcelineVQ> Axman6: int-e i think
04:34:19 <Axman6> int-e: Hey, if you're responsible for lambdabot, would you be able to remove it from #macosx?
04:40:24 * hackage neat-interpolation 0.5.0.1 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.5.0.1 (NikitaVolkov)
04:53:24 * hackage niv 0.2.13 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.13 (nmattia)
05:00:37 <muesli4> Hi, for cabal install I could use '--ghc-options=-dynamic'. What is the corresponding command for cabal new-install?
05:07:05 <snyp> Monad transformers seem a bit ad hoc.  MaybeT a is a m (Maybe a), but ReaderT is r -> (m a) not m (r -> a). Why?
05:08:21 <snyp> I mean `MaybeT` is `m (Maybe a)`. While `ReaderT` is `r -> (m a)` not `m (r -> a)`
05:08:40 <merijn> snyp: Because the latter is rather pointless
05:09:04 <merijn> snyp: You want the monadic action to depen/use 'r' (presumably, anyway) which you can't in the second formulation
05:09:54 <snyp> What's depen?
05:10:02 <merijn> *depend
05:11:21 <snyp> I see.. sort of
05:11:43 <snyp> I can see that the former does make more sense.
05:12:37 <merijn> Vice versa, if MaybeT was "Maybe (m a)" you'd just have Maybe
05:13:13 <merijn> So you couldn't use it as "run the underlying monad until failure"
05:14:46 <maerwald> is there a way to print the help message manually in optparse-applicative, because of more fine-grained validity-checking of arguments?
05:14:53 <maerwald> (since the parser isn't monadic)
05:15:06 <merijn> maerwald: You mean after the parser has run?
05:15:09 <maerwald> yes
05:15:18 <snyp> merijn: But here `Maybe` is the underlying monad.
05:15:21 <merijn> maerwald: You can, but I don't directly recall how
05:15:27 <maerwald> I have a flag that is mandaotiry if another flag is not set
05:15:31 <snyp> m is the first layer.
05:15:41 <maerwald> can't do that with applicative
05:16:18 <merijn> maerwald: https://hackage.haskell.org/package/optparse-applicative-0.15.1.0/docs/Options-Applicative-Help-Core.html
05:16:48 <merijn> maerwald: It needs some docs (and actually some more features, imo, which is somewhere down on my todo list to contribute at some point)
05:17:37 <snyp> I see.. if I mentally switch `underlying` with `monad you want to augment`, it makes sense.
05:17:40 <merijn> maerwald: I think you can, though?
05:18:11 <merijn> maerwald: Can you just combine flag' with <|> ?
05:18:53 <merijn> maerwald: Since flag' produces empty if the flag is not set
05:19:46 <merijn> maerwald: So "flag' foo <|> flag' bar" would only work if either foo *or* bar is set
05:19:51 <maerwald> merijn: well, it's basically '--stdin True' vs '--file foo'
05:19:55 <maerwald> I think I could make it an Either
05:20:06 <merijn> maerwald: Isn't that example literally in the readme?
05:20:11 <maerwald> lol is it?
05:20:34 <merijn> maerwald: https://github.com/pcapriotti/optparse-applicative#alternative
05:20:48 <merijn> maerwald: Their stdin flag doesn't have an argument, but still...
05:21:15 <maerwald> yeah, that should do
05:22:01 <merijn> maerwald: The only thing you can't do is having flag presence depend on the *value* of another flag/option
05:26:32 <maerwald> alternative works nicely
05:27:31 <maerwald> convenient github gist pasting from cli :)
05:45:25 <asheshambasta> anyone seeing that ghcid fails to pick up file changes when running with `-W`? 
05:56:56 <alc> 3x - sinx is limit?
06:08:24 <solonarv> alc: what? limit of what?
06:36:41 <alc> solonarv: it's bounded?
06:36:58 <alc> 3x - sinx is a bounded function?
06:38:32 <Ferdirand> alc: what do you think ?
06:39:08 <alc> its derivative functionis 3 - cosx
06:39:22 <alc> so it's bounded, right?
06:39:57 <alc> I forget my high school math totally...
06:54:14 <solonarv> alc: taking the derivative is not particularly useful for checking whether a function is bounded
06:54:45 <solonarv> and in fact 3x - sin x is unbounded
06:56:58 <dminuoso> A function f is bounded iff ∀x∃t.|f(x)| =< t
06:57:39 <solonarv> you got those quantifiers backwards
06:57:54 * hackage hlint 2.2.10 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.10 (NeilMitchell)
07:01:40 <solonarv> exists y. forall x. |f(x)| <= y
07:01:45 <mniip> dminuoso, by your definition all functions are biunded
07:05:29 <alc> solonarv: dminuoso can we prove that in haskell?
07:05:36 <alc> 3x - sinx is bounded?
07:06:54 <charms> Sorry on what domain?
07:07:07 <Ferdirand> alc: what do you think bounded means ?
07:07:45 <alc> Ferdirand: near to a value?
07:08:24 <alc> I'm not good at express math term  with English
07:09:29 <charms> alc, suppose f(x) : X -> R then we say that f is bounded above by M if for all x in D, f(x) <= M.
07:09:37 <alc> English terms on Math and Chemistry are totally new language to me
07:09:43 <Ferdirand> what value would 3x - sin x be near to ?
07:10:10 <alc> I'd like to say near to 3x
07:10:43 <Ferdirand> 3x is not a value, it's a function
07:10:57 <Ferdirand> but you can bound a function by another function
07:11:47 <Ferdirand> but that is not what we would understand first, if you just say "bounded"
07:12:17 <ski> ⌜3⋅x⌝ is not a function
07:14:49 <ski> (assuming ⌜x⌝ is a number, it is a number. one could say ⌜3⋅x⌝ is a number, depending on the number ⌜x⌝. otoh, ⌜x ↦ 3⋅x⌝, aka ⌜λ x. 3⋅x⌝ (or `\x -> 3*x' in Haskell), is a function)
07:15:46 <MarcelineVQ> flexing that unicode :>
07:16:47 <charms> What language is '⌜' from?
07:16:53 <ski> (but alc can't attempt to bound the function ⌜f⌝ with ⌜3⋅x⌝, since there is no ⌜x⌝ in that context ("not even wrong"). and if you introduce one, it has nothing to do with the ⌜x⌝ that might appear in the definition of ⌜f⌝, or in the definition of "bounded")
07:17:20 <ski> english, charms
07:18:16 <ski> <https://en.wikipedia.org/wiki/Quine_quotes>
07:20:01 <charms> Thank you, ski. Possibly a better way of expressing 'near to' alc would be the metric space (C[a,b], d) where d(f,g) = sup |f(x)-g(x)| then say it is close because it is in the closed ball centered at x |-> 3x with radius 1.
07:21:24 <charms> it being x |-> 3x - sin x
07:22:41 <alc> can haskell do proof assistant?
07:23:24 * hackage shake 0.18.5 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.18.5 (NeilMitchell)
07:23:28 <solonarv> technically yes, but it's not a very good one
07:23:31 <alc> there're some level 1 kata on codewars, is about math
07:24:09 <solonarv> many statements require dependent types to express (which haskell can't do) or a weaker form of DT (which is possible, but clunky)
07:24:46 <solonarv> then there is the fact that infinite loops and undefined exist, so you have to actually evaluate your proff terms to check for that
07:25:30 <solonarv> finally Haskell's type system corresponds to (roughly) intuitonistic logic, which means no LEM (law of excluded middle)
07:25:57 <alc> https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it
07:27:28 <alc> solonarv: why dependent types is so important?
07:27:51 <alc> and why haskell doesn't support it...
07:28:24 <alc> system F is lambda-2, why not to choose lambda-P2?
07:28:57 <solonarv> Haskell doesn't support DT because it was not initially designed to do so and adding them after the fact is very hard (it is a work in progress, but a slow one)
07:29:36 <charms> alc, Coq is a lot better than Haskell if you would like a proof assistant albeit ugly
07:30:24 <alc> charms: I'm afraid of that language is beyond my comprehension :(
07:31:01 <geekosaur> idris might be a better choice since it's haskell-like
07:31:21 <solonarv> proving this sort of thing in Haskell is frankly an exercise in frustration
07:31:32 <alc> it almost takes me one year to learn haskell, and I'm still a newbie
07:31:43 <solonarv> especially if the exercise sticks you with ghc 7.10 and ancient crusty type-level data
07:31:54 <alc> there're still lots of haskell knowlege I don't know
07:32:13 <merijn> The solution is to stop worrying about not knowing things
07:32:23 <solonarv> yes. you will never know everything.
07:32:56 <alc> those concepts take me lots of time to understand
07:33:16 <alc> sometimes I think I'm learning Math again
07:34:43 <alc> when I'm learning python or javascript even scheme, I can copy codes and paste codes, I can write them and make do something what I want, but learning haskell, lots of concepts I don't understand, and if I don't understand I barely can write codes...
07:35:20 <maka1970> ciao
07:35:26 <maka1970> !list
07:35:26 <monochrom> maka1970: http://hackage.haskell.org/packages/
07:35:42 <charms> I've always found Haskell translates a lot easier from my ideas on paper to the computer whereas Python I find gets a bit confusing.
07:35:57 <charms> Though I guess it is up to your style, I do most of my programming on a whiteboard or paper at first.
08:06:12 <madnight> Is contravariance always expressed as function precomposition in Haskell or does contravariance also exist for non-function types?
08:07:03 <solonarv> madnight: I think (->) is the only source of contravariance in Haskell
08:07:30 <solonarv> obviously other types can be contravariant as well, but that will be because they have a (->) somewhere inside
08:09:15 <dmwit> solonarv: Array?
08:09:37 <dmwit> (Which is a lot like (->). But also a lot unlike it.)
08:10:02 <solonarv> array is contravariant? that's news to me
08:10:09 <dmwit> :t ixmap
08:10:11 <lambdabot> (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
08:10:20 <solonarv> huh, indeed
08:10:33 <solonarv> although I would argue this is not proper contrvariance
08:10:47 <solonarv> you could do something similar for e.g. Map
08:11:00 <dmwit> ???
08:11:08 <dmwit> Why does the possibility of doing it for other types make it not contravariance?
08:11:37 <solonarv> I wasn't saying that
08:11:44 <madnight> nice, I started a discussion :)
08:12:23 <solonarv> I was bringing up Map as another example of that almost-but-not-entirely contravariance
08:12:43 <solonarv> notice how you have to specify the bounds of the output array
08:12:56 <dmwit> Yeah.
08:13:08 <solonarv> that is my quibble here
08:13:16 <dmwit> It's contravariant on the Finite subcategory of Hask. ;-)
08:14:35 <reactormonk> How do I parse "at least 2 uppercase characters" with megaparsec?
08:14:51 <dmwit> liftA2 (:) upper (some upper)
08:15:17 <dmwit> liftA2 (++) (replicateM 2 upper) (many upper)
08:15:30 <dmwit> Probably the second one expresses your English more clearly.
08:15:50 <reactormonk> upperChar I guess?
08:15:57 <dmwit> I don't know. I made up a name.
08:16:04 <dmwit> I assumed you knew how to parse exactly one uppercase character.
08:16:10 <solonarv> whatever it's called, I'm sure it exists already
08:16:23 <merijn> hmmm
08:16:31 <dmwit> upper = satisfy isUpper -- or something like that
08:17:20 <merijn> If I have "Monad m => Maybe (m a)" can I somehow conveniently turn it into "m (Maybe a)"?
08:17:24 <dmwit> Oh, yeah, megaparsec does have it and call it upperChar, as you say.
08:17:32 <merijn> (with Nothing -> return Nothing)
08:17:35 <solonarv> merijn: sequence(A) ?
08:17:53 <reactormonk> dmwit, looks nice, thanks
08:18:14 <solonarv> % :t sequence @Maybe
08:18:15 <yahb> solonarv: Monad m => Maybe (m a) -> m (Maybe a)
08:18:31 <merijn> solonarv: oh, I thought of sequence first, then though "this should be possible with traverse" and then I got stuck there and forgot to backtrack to sequence :p
08:18:41 <dmwit> :t traverse @Maybe id
08:18:43 <lambdabot> error:
08:18:43 <lambdabot>     Pattern syntax in expression context: traverse@Maybe
08:18:43 <lambdabot>     Did you mean to enable TypeApplications?
08:18:48 <dmwit> % :t traverse @Maybe id
08:18:49 <yahb> dmwit: Applicative f => Maybe (f b) -> f (Maybe b)
08:18:51 <solonarv> of course it is possible with traverse, sequenceA = traverse id
08:19:44 <merijn> Oh, even better, I don't need any of these because the Alternative instance of Compose works out :>
08:19:59 <solonarv> heh, nice
08:20:18 <solonarv> I can never remember which one that is
08:20:29 <merijn> solonarv: Alternative on the outer Functor
08:20:42 <solonarv> thanks, I will probably forget again by tomorrow ;)
08:20:50 * solonarv doesn't use Compose often enough to remember that
08:20:55 <merijn> solonarv: Basically, I had "Parser (MyMonad a)" and needed to wrap the 'a' with optional
08:23:42 <madnight> so there is only (->) and the rest is: "almost-but-not-entirely contravariant" ?
08:24:39 <solonarv> technically there is also phantom, where the argument is just not used at all ;)
08:25:24 <dmwit> ultravariance
08:25:49 <dmwit> ultramap :: (a -> b) -> f c -> f d
08:26:00 <madnight> what is ultravariance?
08:26:49 <madnight> how is that even possible
08:27:35 <solonarv> instance Ultramap Proxy where ultramap _ Proxy = Proxy -- ;
08:27:41 <solonarv> )
08:27:51 <dmwit> % class Ultravariant f where ultramap :: (a -> b) -> f c -> f d
08:27:51 <yahb> dmwit: 
08:28:04 <dmwit> % instance Ultravariant Proxy where ultramap _ Proxy = Proxy -- what solonarv said
08:28:04 <yahb> dmwit: 
08:28:11 <solonarv> really this is just phantom-in-a-trenchcoat
08:28:30 <dmwit> Yes. This was a joke I made up to enjoy solonarv's brilliance in suggesting phantom types.
08:29:45 <ski> hm, iirc, there's a free functor from any set (of "indeterminates") to the commutative polynomial ring (in those indeterminates) (with coefficients in some given commutative ring), which is covariant ?
08:29:48 <merijn> Damn Haskell's refactorability and the siren song of wasting too much time refactoring stuff to be reliable and understandable instead of just finishing my shit >.>
08:30:04 * ski . o O ( <https://en.wikipedia.org/wiki/Monoid_ring> )
08:30:39 <solonarv> ski: sounds right to me
08:30:50 <dmwit> Anyway, I maintain that Array is contravariant in a very real sense, not just "almost-but-not-entirely contravariant".
08:30:57 <ladyfriday> how do I make Text.Regex.PCRE play nicely with unicode inputs? I get really weird results the second there are any unicode characters in my input
08:31:58 <ski> (apropos `Array' and `Map')
08:32:48 <dmwit> ladyfriday: I think text-icu
08:33:15 <madnight> Could someone explain why one might think that Array contravariance is not "real"?
08:33:17 <geekosaur> ladyfriday, that depends on the C PCRE library. IIRC on Debian you must install the system version of PCRE with UTF8 support instead of the standard one
08:33:20 <dmwit> But you will need to use Text and not use regex-pcre. =P
08:33:32 <ski> (iirc, there's a coend `exists n : |N. R^(n) * R^n', which MacLane mentions, where `R^(n)' is covariant in `n', while `R^n' is contravariant in `n' ?)
08:34:18 <geekosaur> debian or derivatives like ubuntu or mint
08:35:09 <merijn> I would argue the simplest fix is "not using regex"
08:44:45 <ladyfriday> I figured it out, fwiw - instead of `"input =~ "pattern"`, use `let r = makeRegexOpts compUTF8 defaultExecOpts "pattern"; match r "input"`
09:03:58 <nshepperd2> madnight: because there's no contramap for it. only something that looks vaguely like contramap if you squint and ignore all the additional arguments
09:06:45 <ladyfriday> weird, it works, but only in ghci, doesn't seem to work in the actual program :\
09:07:26 <madnight> Well if I can't implement contramap for a type then I would rather tend to say that it's not a contravariant
09:09:16 <madnight> :t contramap
09:09:18 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
09:09:22 <nshepperd2> Map is just a fancy [(k,v)] so it being 'contravariant' in k is a hallucination caused by the api of Map
09:10:23 <madnight> nshepperd2, thx for clarification
09:15:33 <nshepperd2> i guess you could quantify the sorta-contravariantness of it by asking how much of the api you can implement when it is wrapped in contravariant Coyoneda
09:16:07 <ChaiTRex> Is fgl limited to only Int nodes? I don't mean the label, I mean the node type.
09:17:06 <reactormonk> I'm trying to parse this text with the idea on "new Quality whenever there's two uppercase letters" - but it fails at parsing https://gist.github.com/reactormonk/24557074dd59f3ba7b6b9a1d5138e521
09:17:09 <nshepperd2> data CMap k v = CMap (k -> c) (Map c v)
09:17:22 <reactormonk> TrivialError 231765 (Just EndOfInput)
09:18:11 <nshepperd2> The answer is 'almost none' because the (Ord c) constraint is missing
09:18:32 <nshepperd2> so let's stuff a Dict (Ord c) in there too
09:24:06 <monochrom> Yes ChaiTRex
09:30:17 <ChaiTRex> monochrom: Thanks
09:38:24 * hackage first-class-instances 0.1.0.0 - First class typeclass instances  https://hackage.haskell.org/package/first-class-instances-0.1.0.0 (TheMatten)
09:44:54 * hackage mailbox-count 0.0.4 - Count mailboxes in a SQL database.  https://hackage.haskell.org/package/mailbox-count-0.0.4 (MichaelOrlitzky)
10:01:20 <tam1138> good morning
10:02:45 <madnight> :t invmap
10:02:47 <lambdabot> error:
10:02:47 <lambdabot>     • Variable not in scope: invmap
10:02:47 <lambdabot>     • Perhaps you meant one of these:
10:03:47 <ChaiTRex> tam1138: hello
10:03:51 <madnight> tam1138, good evening (GMT+1)
10:08:33 <justsomeguy> Cool, the person behind Liquid Haskell put out a new paper ... https://nikivazou.github.io/publications.html
10:10:29 <Philonous> Hmm, I'm using Haskell for most of my more complex projects and I've ended up using bash for most of my scripting because of practically zero set up and start up cost. Also it was just there. Now I'm regretting it, because bash. But I'm wondering what to replace it with. Preferably something that doesn't require an entire rain dance to write a simple script (e.g.  Haskell), but scales a _little_ better than sh 
10:13:51 <justsomeguy> What do your bash scripts typically do?
10:15:14 <d34df00d> Oh, ByteString.count is sloooow.
10:15:23 <d34df00d> Doesn't get the effects of SIMD stuff, it seems.
10:15:31 <nshepperd_> resource usage proofs in liquid haskell huh
10:15:55 <justsomeguy> Seems so. Way out of my depth, but very cool.
10:16:24 <nshepperd_> i guess that might be progress toward being able to write cryptographic algorithms in haskell
10:17:09 <Philonous> justsomeguy, All sorts of typical script things. But if I had to categorize, I would maybe say curl, orchestrating docker containers, copying files around and (maybe surprisingly) sqlite 
10:22:49 <infinisil> Philonous: I don't like python, but it's probably a good compromise for this sort of thing
10:23:20 <justsomeguy> This is a pretty typical use case for python.
10:23:56 <justsomeguy> Honestly I haven't found any sane language / library that fits the same use case that shell currently does for me.
10:24:10 <cdunklau> Philonous: python
10:24:12 <Philonous> Do people still write perl?
10:24:15 <merijn> Philonous: Why surprisingly? SQLite is great :>
10:24:35 <infinisil> Though if I had infinite time I'd rather improve the haskell ecosystem to make scripting easier than to use python :)
10:24:40 <cdunklau> justsomeguy: the shell would be great, if the language wasn't so godawful
10:25:07 <infinisil> Well, even if i didn't have infinite time, I'd avoid python still
10:25:19 <cdunklau> infinisil: you're hurting my feelings
10:25:20 <cdunklau> :D
10:25:26 <[exa]> infinisil: wrangle not to the easy path
10:26:04 <thongpv8718> Can I ask xmonad question here?
10:26:11 <monochrom> To me it's shell script or haskell or C.
10:26:52 <cdunklau> i mean, bash is at least not entirely awful for really simple stuff, but once i have to do more than a couple conditionals i should really just be writing ...well, anything else
10:27:00 <madnight> Philonous: For, n := Lines of code; case n < 11: bash, case n < 501: python, else haskell
10:27:26 <justsomeguy> I feel like there's some room for Haskell to encroach on the shell scripting use cases... but I haven't figured out how to do that effectively yet. (Turtle tries to do this. I'm not sure I like it. https://hackage.haskell.org/package/turtle-1.5.14/docs/Turtle-Tutorial.html)
10:28:13 <tam1138> in my mind, it's not the length of the program, but the type (as it were) of logic involved.  if it's a bunch of text processing and executing commands, even if it ends up being 1000 lines long, shell is my preferred choice (unless/until speed becomes a limiting factor)
10:28:35 <monochrom> Yeah, it's the logic involved.
10:28:59 <tam1138> which is why i agree with monochrom: shell, haskell, and C are each suited for different kinds of logic
10:29:33 <justsomeguy> One thing that happens with my scripts is that I'll have something that's 90% just running commands, but then I'll want to conditionally call some subset of commands if an element is exclusively a member of one set.
10:29:57 <Philonous> madnight, That seems to be the worst of all 3 worlds. I'd have to rewrite the script _twice_ as it grows from "ah, it's only 3 lines, let's hack something up in bash" to an actual program with failure handling and tests
10:31:30 <Philonous> merijn, I agree. Except I'm suspicious about it's "weak typing" idea
10:31:38 <monochrom> I have a colleague who uses Matlab for what should be a shell script.  It's a Matlab-for-loop containing: system ("cp " + xxx + " " + yyy).  :)
10:31:48 <tam1138> justsomeguy: if the set consists of strings, won't grep work for something like that?  (I don't mean to undermine your representative example by addressing its particulars, mind you)
10:34:27 <merijn> Philonous: Yeah, that's kinda annoying, but it's just too solid to get too upset
10:34:47 <justsomeguy> tam1138: Kind of. I'm usually working with file paths, which are a more like a stream of bytes. The only disallowed characters are the nul byte and /. So I can use flags to text filtering utilities that let me split on the nul byte, instead. So it works, but it's all very awkward.
10:35:05 <madnight> Philonous: rewriting a script as it grows is a process that I would consider as normal, but if you want a consistent middle ground language that just does the job, just go with python (at least that's what I do at work)
10:35:40 <merijn> justsomeguy: That's only on linux/BSD, though. On Windows and macOS paths are unicode text (actually macOS "it depends")
10:36:32 <monochrom> On macOS what does it depend on?
10:36:42 <madnight> if in if in doubt, you can even add somewhat types to your python script for stability as your script grows
10:37:15 <Philonous> madnight, Hmm, maybe I should really look more into python. Guess having it on my CV doesn't really hurt much either. 
10:37:49 <merijn> monochrom: The old HFS is always unicode, in the new Apple FS the paths are "just bytes" in the FS layer, but the Cocoa framework enforces a certain unicode representation on paths (so they're unicode in cocoa/native apps), but the raw posix API (on the new FS) is just bytes
10:37:54 <cdunklau> Philonous: python is pretty strongly typed, fwiw
10:38:29 <merijn> cdunklau: Not by any definition of "typed" that is in common use here or in academia
10:38:33 <cdunklau> i mean, 1 + '2' is a runtime error of course, but it's an error
10:39:03 <cdunklau> merijn: yeah, strong/weak vs static/dynamic is the usual thing we talk about in python land
10:39:11 <Philonous> You could call it "sorted" if you didn't want to call it "typed" 
10:39:15 <merijn> cdunklau: Types and type checking are syntactic, offline operations (i.e. they are done without running a program). Python just has runtime tag checking
10:39:51 <cdunklau> merijn: fair enough
10:40:04 <monochrom> Thanks merijn.
10:40:39 <monochrom> strong typing is orthogonal to static typing
10:40:50 <Philonous> merijn, What does Cocoa do when it encounters invalid unicode paths? 
10:41:01 <merijn> Philonous: No clue
10:41:45 <monochrom> But IMO every language that auto-converts non-boolean values to booleans is not strong enough.
10:43:06 <justsomeguy> Philonous: Just so you know, probably the only parts of Python you'll need to know for rewriting shell scripts are os.run(), how to iterate through a collection, and possibly argparse or sys. At least for a first revision, before error checking and stuff.
10:43:30 <madnight> more strength is better
10:45:58 <Philonous> Now that I think about it, I can probably stick python libraries in shell.nix, that makes the whole idea much more palatable. 
10:46:13 <Philonous> Dependencies, I mean
10:46:51 <reactormonk> How exactly do try/lookAhead and manyTill interact? I've got this parser failing at line 14, which shouldn't be happening (?) https://gist.github.com/reactormonk/24557074dd59f3ba7b6b9a1d5138e521
10:47:44 <madnight> https://news.ycombinator.com/item?id=22212338 tldr, don't
10:48:11 <jjhoo> justsomeguy: what os.run() ?
10:51:46 <madnight> https://xon.sh (python shell)
10:54:36 <tam1138> i object to their comparison.  "fish" totally has a pun in its name.
10:57:48 <madnight> warning pun intended
11:17:05 <tam1138> i've been out of the loop for a while.  ghcup/cabal now seems like a pretty compelling alternative to stack.  any important tradeoffs i should know about?
11:17:47 <suzu> stack works and i've been able to not care about these developments and continue using it to great success
11:18:41 <Philonous> Yeah, it's hard to beat "just works". 
11:18:42 <suzu> switching off stack is not a high priority to me
11:19:00 <tam1138> does ghcup/cabal not "just work" ?
11:19:31 <suzu> i don't know. but if it doesn't that's time of mine being wasted off of moving off something which already does just work
11:19:33 <suzu> :P
11:19:47 <suzu> like i can't find a compelling reason to invest the time to stop using stack
11:19:52 <suzu> sooo i still use it
11:19:54 <suzu> /shrug
11:20:39 <tam1138> makes sense.  i've never put in that time, however, and ghcup/cabal feels like fewer layers of abstraction, and i tend to prefer that sort of thing.
11:21:34 <solonarv> my compelling reason was that I kept wanting to use packages that aren't in any stackage snapshot (or where the new version isn't in any snapshot)
11:21:54 <suzu> that's a good reason
11:22:04 <tam1138> because cabal goes right to hackage whereas stack is release-based(ish)?
11:22:09 <suzu> yeah
11:22:28 <Philonous> tam1138, I find that stack requires very little investment. All you need to do is tell it which snapshot to use (and even that it can figure out for you). And from that point on it Just Works™
11:23:26 <madnight> depends, there are frameworks like https://github.com/dmjio/miso (which I have used successfully in the past), that don't work (good) with stack
11:23:39 <Philonous> Even with packages outside the snapshots I find it easy enough to just add it as an extra dependency. 
11:23:50 <Cale> Anything with ghcjs, you should almost certainly be using nix
11:23:55 <madnight> basically everytime you want todo something with ghcjs
11:24:14 <governorbaloyi> What is the best way to learn Haskell for a beginner? [No experience at all in functional programming, only experience in imperative programming]
11:24:59 <ChaiTRex> governorbaloyi: Get an e-book like learn you a haskell
11:25:05 <Cale> governorbaloyi: I'm not sure if it's the best way, but Graham Hutton's book is pretty good.
11:25:51 <madnight> cabal + nix >= cabal + stack
11:26:22 <tam1138> thanks for the insight, everybody
11:26:53 <governorbaloyi> Thanks guys. I hope I approach this learning the best way.
11:27:26 <suzu> approaching it just with an okay way works too
11:27:36 <madnight> governorbaloyi: http://learnyouahaskell.com
11:28:04 <Philonous> madnight, I've had a terrible time getting cabal + nix to work. 
11:28:58 <suzu> i've had a terrible time with nix just in general and have thrown all of it away
11:29:07 <governorbaloyi> madnight, thanks.
11:29:24 <suzu> i tried really hard to like it but the language is full of footguns and nixpkgs is a hellscape
11:30:23 <madnight> Philonous: well, I would recommend just stick to stack until you are forced otherwise (ghcjs and the like), then try nix + cabal
11:31:18 <governorbaloyi> madnight, can these stacks you are discussing be related to some concept in C++?
11:31:49 <Philonous> governorbaloyi, No, the "stack" we are talking about is a package management tool for Haskell 
11:32:12 <Cale> Nix is really good for extending the hash-based repeatable build stuff that stack does to all the underlying system libraries and so on. It eliminates pretty much all the "works for me" sort of bugs, where only some developers, or only production sees a bug.
11:32:38 <Cale> But yeah, there are many things about the language and the conventions that people use in it which are annoying.
11:33:29 <solonarv> "the hash-based repeatable build stuff that stack does" - did you mean cabal? because that is basically the whole point of v2
11:33:54 <Cale> solonarv: Yeah, and cabal now ;)
11:33:58 <madnight> Cale, could you elaborate on what exactly is annoying?
11:34:24 <Philonous> I love how nix can decouple the environment from the user and the system. Nix-shell + direnv means I can have all the stuff I need for a specific project within a directory without affecting anything else. But nix the language is abysmal. 
11:34:50 <Cale> Nix is a pure functional language, but at every turn, they sort of undermine most of the benefit of pure functional programming, by passing around giant attrsets of everything in the universe that are massaged in various ways such that it's hard to find the definition of anything in them.
11:35:05 <Cale> (It could be anywhere, it could be spread out through many files)
11:35:43 <Cale> The benefit of pure functional programming is that it's possible to understand the meaning of a program by looking at its definition, but that doesn't work if you can't locate the definition
11:36:22 <tam1138> one of the philosophical hurdles i have yet to get over with regards to both stack and ghcup is the idea of having large software installations in my home directory
11:36:35 <Philonous> madnight, Every sub-part of nixpkgs has its own conventions how to automatize things, everything seems to be coming implicitly from somewhere else, you have no good tracing feature or static types to keep it on the rails, the documentation often boils down to "read this github comment" or even just "read the code"
11:36:37 <tam1138> which i realize is solved by nix
11:36:46 <merijn> tam1138: You can also just install the GHC binary distributions wherever you like
11:37:17 <merijn> tam1138: https://www.haskell.org/ghc/download.html
11:37:17 <Cale> tam1138: Well, but then you have a large software installation in /nix
11:37:25 <Cale> but yeah
11:37:26 <solonarv> tam1138: you can actually tell stack/ghcup to put them wherever you like
11:37:27 <Philonous> madnight, It's a maze of abstractions layered over abstractions, all alike. 
11:37:28 <tam1138> merijn: all the documentation i see says it goes in .ghcup or .stack.  or is that just the tutorials meant to be easy and there are config params that let me change it?
11:37:37 <solonarv> it's configurable
11:37:54 <merijn> tam1138: No, I mean that you can just install GHC itself and use ./configure to install it wherever you like
11:37:57 <tam1138> Cale: that's different, because it's outside my homedir, in a place specifically intended for program files, like /usr
11:38:08 <merijn> tam1138: cabal-install doesn't care where it is, as long as it is in your path
11:38:12 <tam1138> merijn: does that not circumvent the entire benefit of ghcup?
11:38:21 <monochrom> tam1138: I put ghcup in /usr/local.  Its shell script has a config variable for that near the beginning. :)
11:38:28 <geekosaur> you can install multiple versions in multiple places
11:38:42 <merijn> tam1138: Sure, I guess, but I don't really see that many benefits in ghcup anyway
11:38:46 <geekosaur> ghcup's only benefit in that case is selecting one to be default, which you could do manually by setting PATH
11:39:05 <Cale> You can theoretically move nix's installation to another place, but you'd break all the binary caches, which would be kind of intolerable.
11:39:09 <monochrom> It still likes to go "/usr/local/.ghcup" but maerwald reminded me "you can add your own symlink" :)
11:39:27 <madnight> philonous: I meant Haskell is also criticized for the lack of documentation... “just read the type definition"
11:39:39 <madnight> *mean
11:39:44 <tam1138> intewestink
11:39:54 <tam1138> i think i need to experiment
11:39:54 <Philonous> madnight, And it's a fair criticism. Except in Haskell you can always ask ghci what the type of somethign is, and that helps a lot. 
11:40:32 <Cale> madnight: The problem in nix's case is that there isn't a type system to help in that regard. But even if there were, I think it wouldn't help as much as it ought to, because in Haskell, we don't put all the definitions in our entire program into a gigantic record that we pass to literally everything.
11:40:38 <Philonous> madnight, nix-repl has some reflection featuers that _should_ tell you things, except they've never helped me
11:40:51 <ChaiTRex> Philonous: In GHCi 8.6 or later, you can do ':doc f' if the function has Haddock documentation.
11:41:52 <ChaiTRex> Who runs yahb?
11:42:16 <glguy> Chai
11:42:23 <glguy> ChaiTRex: /whois yahb
11:42:38 <ChaiTRex> glguy: Thanks
11:45:07 <Cale> madnight: It's sort of like in nix, they end up encoding a gigantic imperative state explicitly as a value, consisting of all the definitions of everything in nixpkgs, and they manipulate those values as they're being explicitly passed around. In order to understand what some piece of nix code does, you're going to end up wanting to know the contents of the attrset you've been passed, but there's typically thousands of things in there, 
11:45:07 <Cale> and they ultimately come from all over.
11:46:20 <Cale> You might only be interested in one or two of them, but in order to be really sure of their values, you have to walk back through the callers and make sure they weren't overridden.
11:46:45 <Cale> and then when they *were* overridden, it's often involving some crazy fixed point construction
11:47:24 <Cale> So it becomes almost impossible to understand the definition of any single thing -- you grep and hope to find something sensible
11:48:16 <Philonous> And it's even more fun when you realise that the Haskell maintainers have a different system than the rust people etc. So even if you invest the time to understand how it works for one part you don't know the others
11:48:16 <Cale> That's my main complaint about nix, but I still can't deny that it's the best thing at what it does
11:49:12 <ChaiTRex> :doc head
11:49:51 <solonarv> % :doc head
11:49:52 <yahb> solonarv: ghc: Can't find any documentation for Data.Text.; This is probably because the module was compiled without '-haddock',; but it's also possible that the module contains no documentation.; Try re-compiling with '-haddock'.
11:50:03 * solonarv scratches their head
11:50:10 <solonarv> gorram unqualified imports
11:50:17 <solonarv> % :doc Prelude.head
11:50:18 <yahb> solonarv: ghc: Can't find any documentation for GHC.List.; This is probably because the module was compiled without '-haddock',; but it's also possible that the module contains no documentation.; Try re-compiling with '-haddock'.
11:50:21 <solonarv> huh
11:50:44 <ChaiTRex> solonarv: Brought it up with yahb's owner. They said to remind them in a few days, so I will.
11:50:51 <madnight> Cale: fair enough, are you aware of any alternatives to nix (that tries to provide a solution for the same problem domain)?
11:51:09 <Cale> A simple module system which was in some way tied to the filesystem would help my day-to-day usage of nix immensely. It seems like such a trivial thing, but, well, Haskell isn't even particularly good about this, but at least in Haskell, if I manage to figure out that some definition foobar comes from Data.Foo, and I manage to find out what package Data.Foo lives in, then I know where in the filesystem to look for it.
11:51:50 <Cale> Most things aren't really trying to be anything like nix -- people use Docker a bunch, I guess.
11:51:59 <Philonous> Maybe guix? 
11:52:14 <Cale> Yeah, there's that guix thing... I should take a closer look at it at some point
11:53:01 <Philonous> I think guix is just nix with guile as a replacement language and a stronger focus on free software 
11:53:32 <maerwald> unless they made the configuration language non-turing complete, it can't be much different
11:54:20 <Philonous> maerwald, You can encourage readable code without neutering the language completely 
11:54:34 <maerwald> that's not gonna solve it :)
11:54:58 <Cale> I would settle for just not undermining the primary benefits of pure functional programming
11:55:14 <merijn> Cale: Picky, picky...
11:55:16 <Cale> I can deal with learning people's libraries for building different kinds of stuff
11:55:39 <maerwald> the confusion of "user" and "packager" is what makes nix simply a time sink
11:56:18 <monochrom> I think programmers have learned to never learn, rather just do genetic algorithm by hand.
11:56:24 <maerwald> in fact, my distro does the same, but that's why I never recommended it to any user
11:56:29 <justsomeguy> All package ecosystems are a time sync, unless there's a huge human effort by other people to curate things for you.
11:56:36 <Philonous> maerwald, Depends on what you mean by "it". 
11:56:42 <Philonous> maerwald, Are you on gentoo?
11:56:46 <maerwald> exherbo
11:56:58 <maerwald> we don't like non-devs as users.
11:57:11 <maerwald> so it's not user friendly
11:57:27 <maerwald> nix is the same, but it's advertised as user friendly
11:57:47 <Cale> Wait, nix is advertised as user friendly?
11:57:55 <maerwald> by the fanboys ;)
11:57:57 <Cale> I wouldn't go that far :D
11:58:13 <mniip> Intresting
11:58:16 <Philonous> I'm honestly considering moving back from NixOs to Arch + nix at this point 
11:58:31 <madnight> hmm yes guix might be a thing in the future or maybe ... not ... really related: but has someone tried Dhall (e.g. as yaml replacement)?
11:58:35 <mniip> Im with k loeri rn ;)
11:58:45 <maerwald> I don't mind using non-userfriendly things, but the time I invest in it must either be spent very well or because I was incredibly bored
11:58:59 <solonarv> I'm strongly considering (tm) dhall for my game's level definitions right now
11:59:04 <Cale> Philonous: heh, you could try to use Arch's Haskell packages ;)
11:59:22 <Philonous> Cale, why would I want to do that?
11:59:29 <Cale> Philonous: suffering
11:59:35 <maerwald> he figured you like pain ;D
11:59:40 <Philonous> Cale, Ah, right. 
12:00:08 <maerwald> mniip: huh?
12:00:33 <Philonous> Wasn't dhall the language where you could import stuff from random URLs? 
12:00:52 <mniip> maerwald, we're having noodles
12:00:55 <maerwald> lolo
12:00:57 <mniip> In brussels
12:00:59 <hseg> ?
12:01:45 <madnight> Philonous: I'm on arch for 5+ years now and see distros like NixOS or Void but I'm just to comfortable in arch. From your experience, what is better in NixOS compared to Arch, other than the obvious (package management).
12:02:23 <maerwald> mniip: if you want to pick a fight... ask him why cross was never merged :P
12:02:49 <hseg> maerwald: you're on exherbero? remember hearing about it a *while* back, you're the first user I've heard of
12:02:52 <Philonous> madnight, I _really_ liked the idea that I could put my system configuration in a git repository and whenever I'm on a fresh machine I could just git clone <repo> && nixos-rebuild switch and have everything working 
12:03:22 <maerwald> hseg: yes, mainly because its package manager works better, but it's also heavily undermaintained, so you can't expect anyone to do anything for you
12:03:39 <madnight> Philonous: the author said (in a podcast) that he fixed the random url imports issue .. afaik
12:03:49 <mniip> maerwald, he'a sighing a lot
12:03:53 <maerwald> loool
12:04:10 <hseg> in what way is the package manager better?
12:04:20 <maerwald> compared to gentoo ofc
12:04:22 <mniip> Also something about the maintainer of the package manager refusing to merge it
12:04:25 <hseg> ah
12:04:35 <hseg> compared to nix?
12:04:39 <maerwald> hseg: https://paludis.exherbo.org/faq/stricter.html
12:04:47 <farmfromjakestat> Curious what you guys think of my beginners Riemann sum integral estimator
12:04:47 <farmfromjakestat> do_integral :: (Ord p, Num p, Fractional p) => (p -> p) -> p -> p -> p -> p
12:04:48 <farmfromjakestat> do_integral f start end dx
12:04:48 <farmfromjakestat>   | end <= start = 0
12:04:50 <farmfromjakestat>   | otherwise = (height * dx) + do_integral f (start + dx) end dx
12:04:50 <farmfromjakestat>     where
12:04:51 <maerwald> those are just a few of hundreds of things
12:04:52 <farmfromjakestat>       height = f (start + (dx / 2))
12:04:59 <maerwald> that portage does wrong and paludis doesn't
12:05:09 <solonarv> farmfromjakestat: please use some sort of pastebin instead of pasting that much code directly into irc
12:05:19 <hseg> Am on arch for ~7y now, am enjoying it, but have been looking over at nix from time to time
12:05:21 <farmfromjakestat> My bad, kinda new to IRC hold on
12:05:37 <solonarv> @where paste
12:05:38 <lambdabot> https://gist.github.com
12:05:41 <solonarv> hm
12:05:47 <tam1138> the only thing Arch doesn't do to my satisfaction is support haskell, hence my questions about ghcup and stack earlier
12:05:49 <solonarv> I thought that would have some alternatives
12:05:56 <mniip> Im on arch because Im lazy and dont have time to mess with my computer
12:06:01 <hseg> ^
12:06:11 <ChaiTRex> You should see Clear Linux. Its Haskell package can't compile anything.
12:06:18 <maerwald> hseg: I've been gento deving for 4 years before I burnt out from politics and rage. Going to nix will just make it worse, looking at the quality of their packaging...
12:06:22 <Philonous> hseg, You can install nix on Arch and reap most of its benefits without having to switch to NixOS
12:06:25 <hseg> nix looks cool in having entire system declaratively config'd
12:06:36 <mniip> I used to use gentoo in like 2015
12:06:38 <maerwald> yes, in theory
12:06:44 <hseg> Philonous: Oh?
12:06:55 <hseg> Philonous: Do you have a writeup somewhere?
12:07:00 <maerwald> distros are about their packaging quality, then about their package manager. If one of them sucks, it's going down
12:07:01 <farmfromjakestat> Here you go https://gist.github.com/jakevossen5/ae3321742556e53d40b7585469c740d5
12:07:11 <mniip> maerwald, we actually had a really interesting discussion about nix vs paludis
12:07:28 <maerwald> well, paludis cannot handle haskell packages in any meaningful way
12:07:30 <Philonous> hseg, You won't get declarative system configuration, but you can still install packages, have per-project environemtns with direnv and I think(?) home-manager works on arch
12:07:32 <maerwald> so hard to compare
12:07:54 <madnight> maerwald: how do you manage the compile times?
12:07:56 <mniip> Regarding language specific repos and distro repos and how nix manages to understand cabal/hackage packages
12:08:20 <hseg> Philonous: right, but that's user-level only? so it doesn't take care of the rest of the tree
12:08:25 <maerwald> mniip: we can create arbitrary slots of a haskell package on exherbo, but we cannot install it multiple times for different GHCs...
12:08:39 <hseg> Philonous: still, useful for dev work
12:08:54 <hseg> or basically any project-specific-tooling work
12:09:27 <maerwald> so you can make every version a separate slot, which means you can install all versions of a package, without uninstalling any. But one such slot can only ever be tied to one GHC version
12:09:34 <Philonous> hseg, Yes. You can also just have a bare-bones system and then pull in your user-level packages via nix. 
12:09:45 <maerwald> madnight: binary packages
12:09:51 <maerwald> I have a server that compiles
12:10:22 <hseg> Hrm. Wonder if a PKGBUILD->Nix layer could help
12:11:20 <d34df00d> Alright, I'm playing around with the foldl package with bytestrings, and looks like it has some overhead due to the conversion of lazy bytestrings to strict bytestrings.
12:11:21 <madnight> maerwald: so you basically build your own arch :)
12:11:22 <tam1138> i started working on a pandoc-like thing for various distributions' packaging formats a while ago
12:11:22 <justsomeguy> Personally I like the approach of having a NixOS container per project, and using a regular Linux distro as the host os.
12:11:37 <d34df00d> I was able to reproduce this as follows:
12:11:49 <Philonous> hseg, Honestly, the biggest benefits I'm getting from nix is nix-shell + direnv + script that caches builds so I don't have to wait an hour every time I change directories
12:12:34 <d34df00d> This code: https://bpaste.net/X7FA (with {-# LANGUAGE Strict #-} runs in about 1.3 secs on a test file of mine. This one ( https://bpaste.net/CSEA ) runs in 1.5 secs.
12:12:44 <d34df00d> Is it possible to avoid this overhead?
12:12:56 <d34df00d> I guess what Fold from foldl does for bytestrings is sort of analogous to this.
12:13:06 <hseg> justsomeguy: An entire container? Why not just a different nix-shell
12:13:24 <merijn> d34df00d: 0.2 seconds sounds like measurement noise
12:13:38 <merijn> d34df00d: Did you profile to see where the hotspots are?
12:13:39 <d34df00d> merijn: those are fairly stable results.
12:13:58 <hseg> Philonous: the system config is not that comfortable?
12:14:09 <d34df00d> merijn: if I build with profiling, this starts taking enormous amounts of RAM for some reason.
12:14:14 <d34df00d> So I don't think profiling is relevant.
12:15:32 <Philonous> hseg, Whenever I want to configure something I have to figure out how to translate into nix first, so 99% of all resources on ther internet become almost useless. And then it turns out that it's much harder than anticipated to make the same configuration work on multiple machines and keeping it in sync 
12:15:46 <hseg> Ugh
12:16:38 <hseg> Yeah, seems like the basic design (store + symlinks + repro builds) is OK, but the implementation is lacking
12:17:04 <merijn> hseg: Conceptually I think Nix is brilliant. From what I've seen/seen discussed/etc. the actual execution sucks donkey balls
12:17:14 <maerwald> Maintaining configuration abstraction is hard and needs a lot of coordination between packages. Nix packaging is just a lot of enthusiasm, but little such coordination.
12:17:24 <hseg> Right
12:17:24 <justsomeguy> hseg: I don't understand Nix very well yet, and wanted to keep a separation between it and the host os. I hope to do more with nix-shell in the future.
12:17:34 <d34df00d> Yeah, I just cannot wait till profiling finishes in about a couple of minutes now.
12:17:35 <d34df00d> :(
12:18:33 <maerwald> e.g. when gentoo tried to support both openssl and libressl, that was a huge coordination effort that took half a year. Same for X and wayland and anything else that is non-trivial. Nix takes that to a completely different level, because of the expressivity, but when you try to figure out what policies they follow
12:18:38 <maerwald> Er, what policies
12:19:03 <Philonous> hseg, Rollbacks sounds like a great idea, except I already had them with btrfs snapshots (or even lvm) and never needed them. Partial upgrades do come in handy sometimes, but not that often. Auditing packages for security vulnerabilities becomes a nightmare, because there's no strong notion of having a package or even particular version "installed" on your system any more 
12:20:06 <maerwald> Philonous: but there is a tool that can check against known vulnerable versions right?
12:20:11 <maerwald> (Not that that is enough, but...)
12:21:20 <Philonous> Oops, I just realized I'm in #haskell and I've been spamming the channel with OT stuff for ages. So I appologize. But it's your guys fault for being the one community on the web (that I found) you can have an actual intelligent discussion with.
12:21:21 <hseg> Hm. Frankly the main appeal to me is being able to abstract my local installation as a delta over some list of packages. If I just had that part (eg with a package store system) I don't think I'd even look at nix
12:22:06 <hseg> my rule of thumb re OT is that as long as it's not actively blocking someone from asking on-topic questions it's fine
12:22:40 <maerwald> judging from how often you see 'nix' in haskell job descriptions (or mentioned in interviews), it's maybe not that OT?
12:23:23 <maerwald> or dmj` fanboying over it ;P
12:23:56 <int-e> Axman6: I've removed #macosx from lambdabot's channel list.
12:24:14 <maerwald> Philonous: https://github.com/flyingcircusio/vulnix
12:24:34 <Philonous> maerwald, Oh, thanks a bunch!
12:24:40 <madnight> I think Docker solves the: you want to run something in different environments problem, but it is bad in reproducibility. Build the same Dockerfile twice (after some time) and it often leads to different images.
12:25:04 <maerwald> madnight: true, but usually you build the docker image during CI and distribute it to everywhere
12:25:09 <maerwald> you don't need the reproducibility
12:25:23 <maerwald> it's a made a problem for moste scenarios
12:25:26 <maerwald> *made up
12:25:36 <monochrom> :)
12:26:16 <maerwald> if, for some reason, all you can or want to share is *configuration*, then docker is definitely not enough
12:26:24 <madnight> I make a code change, build it in CI and then somehow a library inside of the Docker base image has changed and my resulting image is broken ..
12:26:47 <maerwald> you run your end to end tests on the produced docker image ;)
12:27:27 <Philonous> Wasn't the whole appeal of docker that the result is the same on the dev machine as it is on the CI server as it is in production?
12:27:44 <solonarv> if you use the same *image*, sure
12:28:04 <maerwald> the point of docker is to not build images locally....
12:29:03 * solonarv has never used docker
12:29:30 <madnight> Philonous: this is what many people think it does, but unfortunately it does not ... maybe we need docker + nix
12:29:51 <maerwald> docker + nix + stack... oh wait, stack already provides docker and nix integration
12:29:59 <monochrom> docker = more monopolized exe
12:30:03 <MarcelineVQ> iiuc nix already has docker + nix
12:30:08 <maerwald> heh
12:30:38 <maerwald> monochrom: ghc exes are already so huge, no one notices the difference
12:30:52 <maerwald> here you have an entire distro... and your exe...
12:31:05 <monochrom> actually even further, docker = control freak's exe
12:31:31 <Philonous> maerwald, You're jesting, but with alpine the distro really often is the smaller part
12:31:53 <maerwald> Philonous: nah, if you really want to deploy something with docker, you make a proper busybox image
12:32:03 <maerwald> abolute minimum
12:32:08 <madnight> maerwald: well alpine is just 5 mb, I think that is okay for the kind of abstraction it has to offer
12:33:00 <maerwald> yeah, and musl
12:33:24 <madnight> maerwald: nowadays you would use multi stage builds with FROM scratch at the end
12:33:25 <maerwald> and https://wiki.musl-libc.org/functional-differences-from-glibc.html#Name-Resolver/DNS
12:33:47 <hseg> alpine?
12:34:11 <ChaiTRex> hseg: https://alpinelinux.org/
12:34:32 <hseg> ty
12:35:45 <madnight> scratch < alpine < debian-slim < ubuntu
12:36:36 <hseg> scratch as in https://en.wikipedia.org/wiki/Scratch_(programming_language) ?
12:36:45 <ChaiTRex> madnight: scratch is you building Linux from scratch?
12:38:07 <Philonous> Docker containers from scratch, rather
12:38:40 <madnight> "FROM scratch" means the empty linux "distro", with no files under / in the context of Docker images
12:39:29 <reactormonk> With megaparsec, how do I parse lines from a file until a certain token on the next line?
12:42:35 <maerwald> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char.html#v:newline
12:44:09 <reactormonk> maerwald, that's the easy part, I'm trying to figure out how to use lookAhead to finish parsing lines.
12:46:53 <infinisil> reactormonk: That doesn't look like something you'd want to use a parser for, or is there more to the story?
12:47:27 <infinisil> Well not sure actually, but the full store would certainly help
12:55:16 <fragamus> sometimes I want to write xs ++ $ some expression
12:55:46 <hseg> fragamus: (xs++) $ exrp
12:55:47 <erisco> (xs ++) $ some expression
12:55:53 <reactormonk> infinisil, https://gist.github.com/reactormonk/24557074dd59f3ba7b6b9a1d5138e521
12:56:14 <solonarv> I'm very confused as to why you would need that
12:56:21 <Cale> You could also typically write   xs ++ some expression
12:56:35 <solonarv> does 'some expression' include some other infix operators which bind less tightly than (++) ?
12:57:18 <maerwald> maybe create an operator ++$ :D
12:57:18 <fragamus> more tightly
12:57:32 <infinisil> reactormonk: Yeah that doesn't look like something for a parser. Just use some transformer functions
12:57:41 <solonarv> if it binds *more* tightly than ++ then you don't need to do anything
12:58:03 <infinisil> reactormonk: Split it into segments separated by "\n\n" with Text.split or so
12:58:20 <reactormonk> infinisil, doesn't always have "\n\n"... but I could edit the source a bit.
12:59:11 <reactormonk> Or rather, I'd not. It's quite a bit :-(
12:59:15 <infinisil> reactormonk: Then split it by 2 or more newlines
13:00:29 <infinisil> Or split it into lines, then find SOME IMPORTANT TEXT lines and separate by those
13:00:34 <reactormonk> infinisil, looks more like: https://gist.github.com/reactormonk/9362f95ac3e2ae3547fd02871a2f79fe
13:00:42 <reactormonk> Hmm, good point.
13:02:02 <infinisil> Or regex is an alternative too (I personally prefer regex-applicative as I don't have to mess with regex strings like that)
13:02:57 <reactormonk> it's all line-based, so operating on it as a list grouping operation should be easier
13:07:24 * hackage git-annex 7.20200202.7 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20200202.7 (JoeyHess)
13:07:42 <hseg> Hrm. So I want to write a class instance for Vector n a inductively. GHC complains the induction step calls an overlapping instance
13:08:27 <hseg> However, implementing the instance with a fold also seems impossible, due to the types changing along the way
13:09:01 <hseg> (current version here: http://ix.io/291K)
13:09:12 <hseg> (can extract into a buildable version if desired)
13:10:32 <solonarv> just slap an overlap pragma on one of the instances
13:10:36 <solonarv> that's what they are for
13:10:40 <hseg> (BTW, what's up with GHC forbidding instance KnownNat n => Partitionable (Vector (n+1) a) but being fine with (KnownNat n, KnownNat m, n~(m+1)) => Partitionable (Vector m a)
13:10:42 <hseg> ?
13:11:04 <solonarv> what error message are you getting for the first one?
13:11:09 <hseg> solonarv: Doesn't work, instance resolution depends on instantiation of instance variables
13:11:43 <solonarv> hseg: it will work for statically known 'n'
13:12:06 <hseg> http://ix.io/291M
13:12:38 <solonarv> huh
13:12:53 <solonarv> no idea why it's trying to solve that constraint so early
13:12:59 <hseg> Yeah
13:14:09 <hseg> BTW, IIUC if I could use Peano literals for Nats I wouldn't have an overlap problem, right?
13:14:26 <hseg> (bc Vector Z a and Vector (S n) a would be different types)
13:14:52 <solonarv> yeah, I was going to suggest peano naturals next
13:15:13 <hseg> Yeah, except I'm using vector-sized
13:15:18 <hseg> and am not about to reimplement it
13:17:12 <solonarv> ah :(
13:17:39 <solonarv> this is unfortunately one of the pain points of Nat
13:18:12 <hseg> Could newtype it and use derivingVia, but that's one hell of a yak shave
13:19:34 <hseg> ... Am half-tempted to go on a refactoring binge dropping the entirety of the 'algebra' dependency and replacing the code with a Num instance for my polynomials
13:20:20 <hseg> (the Partitionable instance for the vectors is to be able to say fg=sum_{i+j=k}f_ig_jx^ix^k
13:20:33 <hseg> (for sufficiently general i,j,k,x)
13:30:33 <dmwit> KnownNat n does not imply KnownNat (n+1)
13:30:56 <hseg> ... why?
13:31:08 <dmwit> Nobody has done the engineering work needed.
13:31:16 <dmwit> But also the space of solvers for type-level nats is large.
13:31:22 <dmwit> There are plugins that can help.
13:31:40 <dmwit> https://hackage.haskell.org/package/ghc-typelits-knownnat
13:31:46 <hseg> typelits-normalize and knownnat-solver installed
13:32:01 <hseg> lemme write a scratch file so we can avoid this dance
13:37:52 <hseg> http://ix.io/291W is the complete file
13:38:23 <hseg> http://ix.io/291X is the errror
13:45:24 * hackage coinbase-pro 0.8.0.0 - Client for Coinbase Pro  https://hackage.haskell.org/package/coinbase-pro-0.8.0.0 (mdunnio)
13:47:41 <nshepperd_> oh cool, cabal new-repl works outside of a project in 3.0
13:48:36 <nshepperd_> oh, it was cabal new-exec which didn't (and still doesn't :()
13:50:13 * nshepperd_ pushes v3.0.0.0 update of cabal-static aur pkgbuild
13:50:39 <hseg> oh, nice. thanks nshepperd_ 
13:51:20 <hseg> Any ideas how to fix this overlap? http://ix.io/291W http://ix.io/291X
13:55:30 <maerwald> nshepperd: new-exec mainly changes PATH based on the current project. I don't see how it would make sense outside of one
14:02:10 <nshepperd_> maerwald: it also sets ghc environment?
14:02:23 <nshepperd_> or should, anyway, for it to make sense
14:18:24 * hackage mapalgebra 0.2.1 - Efficient, polymorphic Map Algebra.  https://hackage.haskell.org/package/mapalgebra-0.2.1 (fosskers)
14:23:09 <d34df00d> How can I force `stack` to use a version of bytestring package from my fork at github?
14:23:33 <d34df00d> I tried adding that to extra-deps, but I'm not sure that version is actually used (especially given that it didn't seem to get rebuilt).
14:23:50 <ChaiTRex> d34df00d: Have your code explode and see if using it explodes.
14:23:54 * hackage lzlib 1.0.0.2 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.0.2 (vmchale)
14:24:08 <d34df00d> I'm pretty sure it should explode but it doesn't.
14:24:08 <ChaiTRex> d34df00d: Or test for whatever you changed.
14:24:28 <d34df00d> So I'm pretty much convinced that the "upstream" version is used right now.
14:26:28 <MarcelineVQ> d34df00d: sooo how did you add it to extra-deps?
14:26:47 <d34df00d> - github: 0xd34df00d/bytestring
14:26:47 <d34df00d>   commit: afef68b581d4a407771b6d0c38bdcdc16f5ed83f
14:26:49 <d34df00d> MarcelineVQ: ^
14:27:03 <d34df00d> That seemed to work with some other libraries some time ago.
14:37:49 <siers> > 1
14:37:51 <lambdabot>  1
14:37:53 <siers> > foldM (\a b -> if b `mod` 2 == 0 then Nothing else Just (a + b)) 0 [3,5,2,7]
14:37:56 <lambdabot>  Nothing
14:38:23 <siers> does this really short-circuit in terms of # of operations done?
14:38:33 <siers> > foldM (\a b -> if b `mod` 2 == 0 then Nothing else Just (a + b)) 0 [3,5,7]
14:38:35 <lambdabot>  Just 15
14:41:02 <jle`> siers: one way to find out
14:41:07 <siers> jle`, ha, true
14:41:17 <siers> > foldM (\a b -> if b `mod` 2 == 0 then Nothing else Just (a + b)) 0 [1..]
14:41:19 <jle`> > foldM (\a b -> if b `mod` 2 == 0 then Nothing else Just (a + b)) 0 [1..]
14:41:19 <lambdabot>  Nothing
14:41:21 <lambdabot>  Nothing
14:41:22 <jle`> ah beat me to it
14:41:32 <siers> didn't think of it
14:42:06 <jle`> > foldM (\a b -> if b `mod` 2 == 0 then Nothing else Just (a + b)) 0 [2,undefined]
14:42:07 <reactormonk> When I show the Text I extracted from a utf-8 file, I get a bunch of escape characters - am I doing something wrong here?
14:42:08 <lambdabot>  Nothing
14:42:22 <jle`> reactormonk: what else would you expect from showing it?
14:42:36 <dmwit> reactormonk: What does "show" mean to you, exactly?
14:42:38 <jle`> 'show' gives the literal that you would type into a haskell source file to get that text
14:42:55 <reactormonk> jle`, and I guess you can't have UTF8?
14:43:09 <jle`> it's just one way to type it into a source file
14:43:20 <reactormonk> via deriving Show. I guess I'd need some other way to print it?
14:43:21 <jle`> its 'show' is normalizing, i suppose
14:43:33 <dmwit> reactormonk: Just... don't call `show`, then?
14:43:34 <jle`> reactormonk: do you want to display the text it represents to the screen/terminal?
14:43:36 <ChaiTRex> reactormonk: There should be some putStrLn or something in Text.
14:43:38 <jle`> then use putStrLn or T.putStrLn
14:43:45 <jle`> yeah, in Data.Text.IO
14:43:50 <jle`> or you can T.unpack and putStrLn too
14:43:50 <reactormonk> Aye, will do
14:43:59 <jle`> fwiw this is the same behavior with strings too
14:44:05 <jle`> > show "hello"
14:44:07 <lambdabot>  "\"hello\""
14:44:13 <jle`> % putStrLn "hello"
14:44:14 <yahb> jle`: hello
14:44:22 <reactormonk> > show "hellö"
14:44:24 <lambdabot>  "\"hell\\246\""
14:44:29 <siers> jle`, it's because it's folding inside result >>= (result >>= result >>= end), so if most outer-one fails, it stops
14:44:31 <ChaiTRex> reactormonk: Just remember that show (almost) always shows the Haskell source code version.
14:44:46 <siers> or that's what would make sense at least
14:44:58 <jle`> % putStrLn "hellö"
14:44:58 <yahb> jle`: hellö
14:45:06 <jle`> reactormonk: remember 'show' isn't really for things you want to display to a user
14:45:09 <jle`> it's mostly for debugging
14:45:16 <jle`> and development
14:45:27 <jle`> in a production setting you probably wouldn't be using it at all except for debug or logs or something
14:45:57 <jle`> it's sort of like 'inspect' in python, if you're familiar with it
14:46:38 <jle`> er, ruby
14:46:38 <d34df00d> Alright, once I bumped the package version on github and added a constraint in my package.yaml so that only the bumped package matches, it started using the package from my fork..
14:46:45 <d34df00d> MarcelineVQ: ^ in case you're curious.
14:48:09 <MarcelineVQ> p. weird, it should prefer extra-deps already regardless of version, consider making an issue about it, especially if it's reproducable
14:49:04 <d34df00d> MarcelineVQ: maybe the problem is that the new bytestring also needs lots of other packages, so I had to add like 5 more entries to my extra-deps to satisfy that.
14:49:20 <d34df00d> So build planner naturally chooses to stay with the older version, where no further extra-deps are necessary.
14:49:28 <d34df00d> Do you think it's still issue-worthy given that?
14:49:31 <MarcelineVQ> that sounds like an error to me
14:49:56 <maerwald> jle`: yeah, show on strings always gives cancer
14:51:54 <d34df00d> Dang, now everything gets rebuilt including cabal.
14:52:01 <d34df00d> Hacking on `bytestring` is PITA.
14:52:48 * d34df00d just wanted to make BS.count use memchr instead of an explicit one-byte-at-a-time loop.
14:53:00 <maerwald> d34df00d: how about sandbox?
14:53:25 <d34df00d> maerwald: I'm already using stack, and after I managed to get stack use my own bytestring it apparently rebuilds everything depending on it. And that's a lot of pacakges.
14:53:35 <maerwald> yes, how about sandbox
14:53:58 <d34df00d> Dunno, I cannot into cabal.
14:54:09 <maerwald> why
14:54:33 <d34df00d> Too complicated. I failed at trying to build my custom bytestring for testing.
14:54:46 <d34df00d> It shouted something beyond my understanding back at me: https://bpaste.net/J2CA
14:55:05 <d34df00d> (so I just quickly threw up a really simple stack.yaml and did `stack test` instead, and it worked like a charm)
14:56:53 <maerwald> did you try disabling tests?
14:58:49 <d34df00d> But I wanted tests! I wanted to make sure my changes didn't break bytestring.
14:59:23 <d34df00d> Speaking of which, once I open a PR to the bytestring package, what should I do for somebody to take care of it? Assign reviewers, throw a link into the maillist? Or just let it lie there and somebody will pick it up?
15:29:54 * hackage lzlib 1.0.1.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.1.0 (vmchale)
15:42:25 <ChrisPenner[m]> New optics on the market: https://chrispenner.ca/posts/kaleidoscopes
15:43:40 <Philonous> ChrisPenner[m], Loved your book btw! 
15:44:53 <ChrisPenner[m]> Philonous: Thanks! Glad you like it!
15:47:28 <Axman6> I've also enjoyed what I've read so far, its really nicely written - most of what I've seen I already knew but still learned new ways to think about things
15:48:10 <Philonous> It's the intro to optics I wish I had a year ago. Still got a lot out of if, though. 
15:49:54 * hackage algebraic-graphs 0.5 - A library for algebraic graph construction and transformation  https://hackage.haskell.org/package/algebraic-graphs-0.5 (snowleopard)
16:02:50 <jle`> ChrisPenner[m]: sounds very ... comonadic
16:07:07 <ChrisPenner[m]> jle`: pretty sure there's an optic for comonads hiding out there somewhere; I've found a few variations, but nothing "beautiful" quite yet!
16:09:27 <jle`> ChrisPenner[m]: i suppose i mean that the way you use it feels similar to the general patterns in using comonadic interfaces maybe
16:09:33 <jle`> maybe it can replace the comonad abstraction completely
16:09:35 <jle`> :o
16:13:25 <ChrisPenner[m]> Haha, that might exist but I don't think this is it!
16:21:51 <ChrisPenner[m]> jle`: but if you can figure out how that works I'd love to see it!
16:22:35 <farmfromjakestat> Anyone want to give me feedback on a short script I wrote? New to haskell. Does a Remann sum to estimate an integral https://gist.github.com/jakevossen5/ae3321742556e53d40b7585469c740d5
16:24:21 <ChaiTRex> farmfromjakestat: Looks fine.
16:24:56 <farmfromjakestat> Any improvements a more experienced haskeller would make?
16:26:47 <ChaiTRex> farmfromjakestat: Well, you can use [(start + dx/2), (start + 3*dx/2) .. end]
16:27:00 <ChaiTRex> farmfromjakestat: That gives you a list of all the midpoints.
16:27:08 <ChaiTRex> farmfromjakestat: Then you can do map f on that.
16:27:13 <ChaiTRex> farmfromjakestat: Then you can do sum on that.
16:27:25 <farmfromjakestat> Ah that is a good idea.
16:28:27 <farmfromjakestat> <ChaiTRex> I was running into stack overflow if I used to small of a dx, I bet this would prevent that
16:28:46 <ChaiTRex> farmfromjakestat: This also has the benefit that, as long as dx is positive, that list is [] and the sum is zero. So you don't need the guards.
16:29:08 <farmfromjakestat> Alright I am going to update that quick
16:29:34 <ChaiTRex> > let start = 5; end = 2; dx = 0.25 in [(start + dx/2), (start + 3*dx/2) .. end]
16:29:36 <lambdabot>  []
16:32:35 <farmfromjakestat> <ChaiTRex> Why the +3? Should that be a +2?
16:32:46 <farmfromjakestat> Or am do I need to think about how Remann sums think differently
16:32:55 <ChaiTRex> farmfromjakestat: Well, start + dx/2 + dx = start + 3*dx/2.
16:33:16 <farmfromjakestat> Ah you are right my bad
16:34:36 <ChaiTRex> farmfromjakestat: If it's clearer to you, then it might be clearer to others as well to just write (start + dx/2 + dx)
16:34:47 <ChaiTRex> farmfromjakestat: This can make the code easier to read.
16:39:01 <ChaiTRex> farmfromjakestat: Another alternative is this: sum . map f . takeWhile (<= end) . iterate (+ dx) $ start + dx/2
16:39:42 <farmfromjakestat> <ChaiTRex> How does this look?
16:39:45 <farmfromjakestat> do_integral f start end dx = sum ( map (\x -> (f x) * (dx/2)) [(start + dx/2), (start + 2*(dx/2)) .. end])
16:40:13 <farmfromjakestat> I am not very good at knowing when I can use . and when I can use $ 
16:40:44 <ChaiTRex> farmfromjakestat: Well, h . g . f $ x starts with x, then it applies f to it, then it applies g to it, then it applies h to it.
16:40:59 <ChaiTRex> farmfromjakestat: It's the same as h (g (f (x)))
16:41:07 <ChaiTRex> farmfromjakestat: Just with less parentheses.
16:41:45 <ChaiTRex> farmfromjakestat: I think in the map you need * dx rather than * dx/2.
16:41:53 <farmfromjakestat> ChaiTRex: Is that equal to h (g (f x))
16:41:56 <ChaiTRex> farmfromjakestat: The width of one of these things is dx.
16:41:59 <ChaiTRex> farmfromjakestat: Yep.
16:42:07 <farmfromjakestat> The dx was causing it to be double what the answer should be
16:42:24 <ChaiTRex> farmfromjakestat: Ahh, your list is wrong.
16:42:34 <farmfromjakestat> Isn't the width dx/2
16:42:40 <ChaiTRex> farmfromjakestat: [(start + dx/2), (start + 2*(dx/2)) .. end]
16:43:00 <ChaiTRex> farmfromjakestat: The distance between the first midpoint and the second is only dx/2 with that rather than dx.
16:43:20 <ChaiTRex> farmfromjakestat: It's better to write [(start + dx/2), (start + dx/2 + dx) .. end]
16:43:29 <ChaiTRex> farmfromjakestat: That's easier to read and easier to know it's correct.
16:44:16 <farmfromjakestat> I did not know Haskell was that good at figuring out how to enumerate
16:44:22 <farmfromjakestat> Very impressed 
16:44:44 <ChaiTRex> Here's what I'd use: (* dx) . sum . map f . iterate (+ dx) $ start + dx/2
16:44:57 <ChaiTRex> Oh, wait.
16:45:05 <ChaiTRex> Here's what I'd use: (* dx) . sum . map f . takeWhile (<= end) . iterate (+ dx) $ start + dx/2
16:45:14 <ChaiTRex> There, now it stops when it reaches end.
16:45:41 <farmfromjakestat> Alright give me a second to digest that I might have some questions
16:46:03 <ChaiTRex> The benefit of this is that it instead of (dx * f x1 + dx * f x2 + dx * f x3 + ...), you use the distributive property to get dx * (f x1 + f x2 + f x3 + ...)
16:46:09 <ChaiTRex> Much less multiplication that way.
16:46:50 <ChaiTRex> With the list syntax, it's: (* dx) . sum . map f $ [(start + dx/2), (start + dx/2 + dx) .. end]
16:47:43 <farmfromjakestat> Why do you need the $ between the f and [
16:47:55 <ChaiTRex> Without ($), it's dx * sum (map f [(start + dx/2), (start + dx/2 + dx) .. dx])
16:48:18 <ChaiTRex> farmfromjakestat: You have the composed functions with dots between them, then a $, then the value they all apply to.
16:48:26 <ChaiTRex> farmfromjakestat: h . g . f $ x.
16:48:40 <farmfromjakestat> As you can tell I am a noob here
16:48:40 <ChaiTRex> farmfromjakestat: h . g . f $ x
16:48:47 <farmfromjakestat> So if I have a . am I always going to have a $?
16:49:05 <ChaiTRex> farmfromjakestat: You can also do (h . g . f) x
16:49:16 <ChaiTRex> farmfromjakestat: The $ just surrounds both sides with parentheses.
16:49:36 <farmfromjakestat> Does (h . g . f) x == h . g . f $ x.
16:49:59 <Cale> yes
16:50:00 <ChaiTRex> farmfromjakestat: Yep. $ surrounds both sides with parentheses, so h . g . f $ x = (h . g . f) (x)
16:50:23 <ChaiTRex> farmfromjakestat: But without the complication of $,
16:50:29 <ChaiTRex> Without ($), it's dx * sum (map f [(start + dx/2), (start + dx/2 + dx) .. dx])
16:50:40 <Cale> f $ x = f x, but $ has really low precedence (it binds to its arguments as weakly as possible for an infix operator)
16:50:48 <farmfromjakestat> So I am sure this is a bit of a style thing, but when should I use $ and when should I use parentheses?
16:51:04 <ChaiTRex> farmfromjakestat: Use $ to avoid an overload of parentheses.
16:51:22 <ChaiTRex> farmfromjakestat: Or to make it clear that you're applying a sequence of functions.
16:51:33 <Cale> Yeah, if it's annoying to find the place where the appropriate matching paren should go, $ can be nice
16:51:39 <ChaiTRex> farmfromjakestat: h . g . f $ x makes it clear you're applying those three functions in sequence.
16:52:08 <Cale> It's really nice in cases where the argument is really long and split over multiple lines or pages of code
16:52:27 <farmfromjakestat> Got it
16:52:33 <Cale> withSomeResource $ \res -> do
16:52:34 <Cale>   ...
16:52:41 <ChaiTRex> farmfromjakestat: Just be careful, because . applies the function on the right first. It goes in backwards reading order.
16:52:41 <Cale> That kind of thing is super-common
16:52:58 <ChaiTRex> farmfromjakestat: h . g . f applies f then g then h.
16:53:04 <ChaiTRex> farmfromjakestat: Like in math.
16:53:11 <Cale> Well, be careful about "first"
16:53:14 <farmfromjakestat> Haha I was just going to ask if it is reasonable for me to read what you sent me right to left 
16:53:21 <Cale> It actually evaluates left to right
16:53:59 <Cale> (h . g . f) x -> h ((g . f) x)
16:54:17 <Cale> and then h is applied to that argument, and it'll only be evaluated if h pattern matches on it
16:54:28 <Cale> So, "first" is a little weird :)
16:55:41 <Cale> > head $ ((1:) . error "oops!") []
16:55:44 <lambdabot>  1
16:55:49 <Cale> > ((1:) . error "oops!") []
16:55:51 <lambdabot>  [1*Exception: oops!
16:56:21 <ChaiTRex> Come on, lambdabot, get the comma out first.
16:56:47 <Cale> haha
16:57:24 <Axman6> it can't though, what if the next thing was []
16:57:48 <Cale> Right
16:58:16 <ChaiTRex> Ahh, good point.
16:59:09 <ChaiTRex> It should do a comma and then use ^H characters to go back if it's [].
16:59:13 <Cale> lol
16:59:39 <Axman6> haha, yeah that would be optimally lazy
16:59:50 <Cale> Or maybe draw "..." and then backspace over it :D
17:12:28 <Axman6> that'd be great
17:27:14 <mniip> maerwald, btw he said it should definitely be possible but no one ever made such a request so it's not implemented
17:27:58 <mniip> re: installing multiple copies of the same version of a package but with different dependencies (in paludis)
17:45:47 <ezzieyguywuf> I'd like to allow my data type to be multiplied by any `Num`. I've made an `instance (Num a) => MyData a where..` and defined `*` for it, but this only allows for `mydata1 * mydata2`. What do I need to do to allow for, say, `10 * mydata`?
17:46:21 <ChaiTRex> ezzieyguywuf: Did you define fromInteger?
17:46:40 <ezzieyguywuf> ChaiTRex: yes I did the entire minimum required set for `Num`
17:47:01 <ski> does it make sense to multiply a value of your data type with a complex number ? with a square matrix (of some dimension) ?
17:47:04 <Axman6> we don't have a class for combining arbitrary number types
17:47:11 <ChaiTRex> ezzieyguywuf: OK, then 10 as a literal will be converted to 10 :: MyData a
17:47:47 <ChaiTRex> ezzieyguywuf: Or whatever the type is.
17:48:15 <d34df00d> ChrisPenner[m]: sup.
17:48:23 <d34df00d> Thanks for your post on making wc in haskell!
17:48:43 <ezzieyguywuf> hm. so I must be doing something wrong. `MyData` is a vector, so the actual definition is `data Vector a = Vector a a a`, and I've written a QuickCheck Property to test for the communative law in scalar multiplication, i.e. `a * (b * vec) = (a * b) * vec`, but I'm getting a type error
17:49:44 <d34df00d> Made me write mine :] https://0xd34df00d.me/posts/2020/02/destroying-c-with-20-lines-of-haskell.html
17:50:41 <ezzieyguywuf> hm, tha was pretty confusing. In short, I have `prop_vectMultAssoc :: Vector Rational -> Rational -> Rational -> Bool` and it's defined as `prop_vectMultAssoc v a b = a * (b * v) == (a * b) * v` but the type error specifies that it cannot multiply a Rational by a Vector Rational
17:50:53 <ski> ezzieyguywuf : did you mean `fromInteger a * (fromInteger b * vec) == fromInteger (a * b) * vec' ?
17:51:07 <ski> @type fromRational
17:51:09 <lambdabot> Fractional a => Rational -> a
17:51:16 <ski> s/fromInteger/fromRational/
17:51:33 <ezzieyguywuf> ski: hrm, perhaps I did...
17:51:45 <ezzieyguywuf> but I haven't defined fromRational for Vector, only fromInteger
17:52:09 <ski> yet you're wanting to multiply with a `Rational'
17:53:12 <ezzieyguywuf> ah. I think I need to make Vector an instance of Rational
17:53:13 <ezzieyguywuf> :)
17:53:14 <ski> how have you defined `(*)' ? point/coordinate -wise ?
17:53:34 <ezzieyguywuf> ski: I have - I made Vector an instance of Num and defined (*) as you've described
17:53:57 <ski> itym s/instance of Rational/instance of Fractiona/
17:54:23 <ezzieyguywuf> ski: I probably did mean that, I still get those two confused
17:54:33 <ezzieyguywuf> and Ratio
17:55:01 <ski> `Rational' and `Ratio' are types. `Fractional' is a type class
17:55:13 <ski> @src Rational
17:55:13 <lambdabot> type Rational = Ratio Integer
17:56:01 <ezzieyguywuf> ahh. Ratio can be a Ratio of any `a` then
17:58:56 <ezzieyguywuf> huzzah that did it! thanks for the help everyone
18:01:59 <ski> np :)
18:48:24 * hackage decidable 0.3.0.0 - Combinators for manipulating dependently-typed predicates.  https://hackage.haskell.org/package/decidable-0.3.0.0 (jle)
18:50:00 <Axman6> does decidable have anything to do with the Decidable typeclass jle`?
18:52:20 <jle`> Axman6: from what package?
18:53:38 <iqubic> https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html#t:Decidable
18:53:48 <iqubic> I assume he's talking about that Decidable.
18:53:50 <Axman6> yeah that one
18:53:52 <jle`> ah, no, not that one
18:54:32 <jle`> it's not too related
18:54:43 <jle`> the closest thing to the common libraries is TestEquality from base
18:59:44 <iqubic> What exactly is a dependently typed predicate?
19:01:53 <jle`> hm, i guess the description is a little innaccurate/outdated
19:02:03 <jle`> it should be 'dependent types' predicate
19:03:13 <jle`> it's roughly something `k -> Type` that is 'true' if inhabited, and 'false' if uninhabited
19:03:39 <jle`> for example `data IsBool :: Type -> Type; YesItsABool :: IsBool Bool`
19:03:51 <jle`> `IsBool Bool` is "true" because it is inhabited, by YesItsABool
19:03:58 <jle`> `IsBool Int` is "false" because it's not inhabited
19:05:11 <Axman6> is IsBool a something you can sensibly write? I'm not even sure what I'm asking, but wondering what things return False
19:05:48 <jle`> i'm not too sure what you're asking either, since i just wrote it :)
19:06:07 <iqubic> How do you even check if a type is uninhabited?
19:06:32 <jle`> that's basically what the Decidable typeclass (in the library) does
19:06:50 <jle`> if a predicate is an instance of Decidable, it means it's possible to check if the predicate is true or false
19:07:05 <jle`> ie if MyPred MyType is inhabited or uninhabited
19:07:14 <jle`> it's not possible in general
19:07:17 <iqubic> But how do you write a sensible instance of Decidable?
19:07:20 <jle`> it's basically only true if a predicate is 'decidably true'
19:07:30 <jle`> er, a predicate is 'decidable'
19:08:09 <jle`> class Decidable p where decide :: Sing a -> Maybe (p a)   -- essentially
19:08:20 <jle`> test for a predicate 'p' if 'p a' is true or not
19:08:43 <iqubic> Oh, it uses Singletons.
19:08:46 <jle`> translated to the Type kind that becomes decide :: TypeRep a -> Maybe (IsBool a)
19:08:47 <iqubic> I see.
19:09:15 <iqubic> Sure.
19:09:15 <jle`> so you can write
19:09:41 <jle`> decideIsBool :: Typeable a => Maybe (IsBool a)
19:09:42 <jle`> essentially
19:09:57 <jle`> and it will be Nothing for types where IsBool a is false (so, any non-bool) and Just for types where IsBool a is true (so, only Bool)
19:11:37 <jle`> so these sorts of predicates are all useful on their own and you don't need a typeclass to work with them
19:12:01 <jle`> but a typeclass is useful (and so the 'decidable' library) if you want to do things like, compose and combine predicates and have generic predicate combinators
19:49:54 * hackage language-ats 1.7.7.1 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.7.1 (vmchale)
19:53:51 <toriningen> Hello. I'm new to Haskell, learning it, and had just stumbled upon the need to somehow compose two predicates. E.g. as in `comp f g x = (f x) || (g x)`. Is it possible to get rid of `x`?
19:55:20 <Axman6> yes! though a little unexpected: liftA2 (||) f g
19:56:05 <Axman6> :t (\f g -> liftA2 (||) f g) `asAppliedTo` even
19:56:07 <lambdabot> Integral a => (a -> Bool) -> (a -> Bool) -> a -> Bool
19:56:33 <Axman6> > liftA2 (||) even (<10) 5
19:56:35 <lambdabot>  True
19:56:40 <Axman6> > liftA2 (||) even (<10) 12
19:56:42 <lambdabot>  True
19:56:44 <Axman6> > liftA2 (||) even (<10) 13
19:56:46 <lambdabot>  False
19:57:13 <toriningen> aha, yeah, that's exactly what I need!
19:57:16 <toriningen> thank you a lot
19:59:02 <Axman6> you can also write that as (||) <$> f <*> g if you prefer, but this is exactly equivalent to liftA2 (||) f g. what this all means is that comp = liftA2 (||)
20:05:12 <toriningen> that's a lot to read, thanks! experimenting now
20:30:53 <ChaiTRex> @pl \ x -> f x || g x
20:30:54 <lambdabot> liftM2 (||) f g
20:31:39 <ChaiTRex> toriningen: @pl like just above can get rid of arguments for you
20:32:22 <oats> I'm curious, why do some packages on hackage have different styling for their documentation pages?
20:32:30 <oats> eg
20:32:34 <oats> https://hackage.haskell.org/package/lens-csv-0.1.0.0/docs/Data-Csv-Lens.html
20:32:44 <oats> vs https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons.html
20:34:15 <Cale> Because they generated the documentation with different stylesheets/haddock options
20:34:23 <oats> ah, ok
20:34:31 <oats> can we switch everything to the second style? :P
20:35:26 <Cale> I think that is the newer default in any case
20:36:43 <MarcelineVQ> it's got some horizontal scroll issues on my browser, namely that there is a horizontal scroll at all
20:37:06 <Cale> yeah, and it also wastes a lot of space unless the window is quite narrow
20:37:09 <toriningen> @unpl liftM2 (||) f g
20:37:09 <lambdabot> (f >>= \ x1 -> g >>= \ x2 -> return (x1 || x2))
20:37:10 <oats> oh heh, how about that
20:37:18 <ChaiTRex> hackage is horrible on iOS browsers
20:37:36 <MarcelineVQ> Cale: also weirdly wasted space on instances, hmm
20:37:44 <Cale> Well, the horizontal scroll can be somewhat forgiven, that module is intensely pathological
20:38:13 <Cale> type Apply (ZipWith7Sym0 :: TyFun (a6989586621680096223 ~> (b6989586621680096224 ~> (c6989586621680096225 ~> (d6989586621680096226 ~> (e6989586621680096227 ~> (f6989586621680096228 ~> (g6989586621680096229 ~> h6989586621680096230))))))) ([a6989586621680096223] ~> ([b6989586621680096224] ~> ([c6989586621680096225] ~> ([d6989586621680096226] ~> ([e6989586621680096227] ~> ([f6989586621680096228] ~> ([g6989586621680096229] ~> 
20:38:13 <Cale> [h6989586621680096230]))))))) -> Type) (a6989586621680097757 :: a6989586621680096223 ~> (b6989586621680096224 ~> (c6989586621680096225 ~> (d6989586621680096226 ~> (e6989586621680096227 ~> (f6989586621680096228 ~> (g6989586621680096229 ~> h6989586621680096230)))))))
20:38:20 <oats> oh yeah, there's some cursed stuff in there
20:38:24 <oats> maybe that's a poor example
20:38:42 <MarcelineVQ> well maybe, but one can choose some whitespace to br on
20:39:02 <Cale> Yeah, it would be nicer if it attempted to prettyprint it
20:39:10 <Cale> or just line wrap
20:39:57 <ChaiTRex> > maxBound :: Word64
20:39:59 <lambdabot>  18446744073709551615
20:40:04 <oats> seriously though, what the heck is that type
20:40:52 <jle`> oats: the type variables are generated with template haskell
20:40:58 <jle`> so the variables are kind of funky
20:40:59 <ChaiTRex> Seems like TH used random numbers or something
20:41:06 <jle`> but also zipWith7 is an ugly type no matter how you write it
20:41:10 <jle`> :t zipWith7
20:41:12 <lambdabot> (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
20:42:21 <Cale> If you find yourself using the singletons package, you've gone too far with the fancy types and should probably turn back immediately
20:43:10 <MarcelineVQ> or the exact opposite... [this is untrue, marcy has told another lie]
20:43:13 <jle`> ah another issue is that haddock/ghc doesn't appreciate associativity in type operators
20:43:20 <jle`> so there are a lot of extra parentheses
20:44:06 <jle`> type Apply (ZipWithSym0 :: (a ~> b ~> c) ~> [a] ~> [b] ~> [c])
20:44:17 <jle`> is how that type signature could look like with better printing on haddock/ghc/th
20:44:21 <jle`> not sure exactly who to blame
20:44:35 <jle`> basically the type of zipWith but switching the ->'s with ~>'s
20:44:37 <jle`> :t zipWith
20:44:39 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:44:51 <MarcelineVQ> you're full of beans tonight
20:44:55 <Cale> I use a fair amount of reasonably fancy types, but I think the place where I draw the line in Haskell is actually needing to do "real" computation at the type level. I try to avoid type level lists because you almost always want to concatenate them eventually, and then you end up wanting to prove associativity of concatenation to make types check, for example.
20:45:25 <Cale> I do a lot of stuff with GADTs and DMap and DSum
20:45:31 <jle`> i think there is some line where singletons would be 'useful' for what you want, but not necessary
20:45:38 <Cale> But I don't try to compute with the indices
20:45:38 <jle`> for example singletons simplifies a lot of DSum usage
20:45:55 <Cale> and basically always have hand-defined key types
20:45:59 <jle`> s/line/blurry zone
20:47:47 <jle`> i hand-define keys a lot but at some point it's like what's the point
20:47:53 <jle`> although singletons does take a long time to build admittedly
20:48:03 <jle`> if only there was some sort of super-lean version
20:48:08 <Cale> Well, depends what your keys look like
20:48:33 <Cale> In my case, the key types usually specify things which a client can request from a server
20:48:58 <MarcelineVQ> jle`: super lean singletons, hmm.... hmmmmm.... https://github.com/Zambonifofex/agda-magic hhmmmm...
20:49:58 <jle`> Cale: ah, i see, GADTs like that
20:50:08 <Cale> So it's a reasonably natural abstraction over the contents of the application's database, and hand-writing them doesn't seem too onerous most of the time (especially since this sort of mechanism tends to be replacing big explicit record types that needed to have a dozen or so instances of various classes maintained every time you added a new thing)
20:50:16 <jle`> MarcelineVQ: hah
20:50:36 <MarcelineVQ> jle`: https://i.imgur.com/hDbNpnv.jpg
20:50:52 <jle`> i wonder what i did the last time i did that sort of thing
20:53:06 <jle`> Cale: i agree i usually don't find myself doing any sort of type-level programming, but even things like phantom [Symbol] can be useful if you enver do any list manipulation
20:54:27 <jle`> hm
20:54:30 <Cale> deriving via allows some rather cute things
20:54:56 <Cale> Just turning type level constants for "here's the one extra parameter you'll need to know which instance I want"
20:57:02 <jle`> but i think that one major issue is that as you get deeper into these sorts of things, the language starts to work against you, not with you
20:58:41 <Cale> Yeah, you end up wanting full dependent types, and Haskell can only kinda-sorta approximate those -- and sometimes expressing all that stuff at the type level is annoying in a dependently typed language as it is
21:00:11 <Cale> It's important to figure out if you're really eliminating an actual source of bugs
21:03:07 <d34df00d> Uh, speaking of GADTs and all that.
21:03:23 <d34df00d> I wrapped something into a GADT and now I'm having a significant performance degradation.
21:03:31 <jle`> ah, i pulled up the last time i did something like typed channels. i had a data type where you could "request" a `TestResult '["test1","test2","test3"]`, and get back a 3-tuple with the appropriate results in the appropriate slots
21:03:53 <jle`> so a bit more safe than a list because you ensure the right number of items
21:04:06 <jle`> and a bit more safe than a fixed-length vector because you ensure the right 'order' of the items
21:04:32 <jle`> but to send a request over network you had to also keep a type-level witness for those three tests, so ... a singleton for [Symbol]
21:05:08 <Cale> d34df00d: GADTs shouldn't be much worse than similarly-sized and shaped ordinary data types (when you account for the extra fields they have for dictionaries / type equality witnesses)
21:05:31 <Cale> d34df00d: Did a newtype become something which isn't a newtype perhaps?
21:05:47 <d34df00d> This is the version that's working perfectly: https://github.com/0xd34df00d/hwc/blob/master/src/Data/WordCount.hs (say, 1.1 secs on a test input).
21:05:59 <d34df00d> Once I changed that to be rather like https://bpaste.net/27EQ , it got up to 1.5 secs per test input.
21:06:17 <d34df00d> (I'm calling the Statisic 'Words version in both case)
21:07:10 <d34df00d> Cale: so I think it's just a matter of the compiler not being able to inline something anymore.
21:07:15 <d34df00d> I'm doing unwrapping just once anyway.
21:07:35 <d34df00d> That is, in runCompute.
21:07:54 <Cale> hmm, yeah, if it missed a constructor specialisation or stopped inlining, that might explain it
21:08:28 <d34df00d> Is there any good way to debug/investigate this?
21:09:41 <Cale> Is the GADT here really all that helpful? Maybe just moving the last step of runCompute into the type class methods would be better?
21:10:28 <Cale> Well, the way to debug it would be to start looking at core
21:10:35 <Cale> -ddump-simpl
21:11:08 <d34df00d> So I want to express that certain statistics (say total input length or line count) can process chunks of input data at once (say just calling BS.length or BS.count respectively), but some need to look at each consecutive byte.
21:12:01 <d34df00d> So my plan would then be to combine different statistics so that I can still process the input in one go, and process it as chunks if all the statistics support that (say if only line count and total length is requested), but falls back to looking at individual bytes otherwise.
21:12:25 <Cale> ahh, I see
21:12:33 <d34df00d> So some stats provide two functions if they support both chunks and byte-by-byte computations, and some only provide byte-by-byte stuff.
21:13:05 <d34df00d> So I'll have `instance (Statistic a, Statistic b) => Statistic (a, b) where ...` with some clever combination of those.
21:13:28 <d34df00d> ...but I'm not there yet as I'm trying to not degrade performance-wise in the process.
21:24:07 <Axman6> d34df00d: have you seen foldl, and the foldl-statistics package I wrote?
21:25:07 <d34df00d> Axman6: yep, and I actually gave it a shot! But looks like the performance degraded a bit in my case — indeed, if I'm going through one giant mmap'ed bytestring, the foldl machinery will boil down to doing as many passes over it as I have "atomic" folds.
21:25:09 <d34df00d> Or how do you call that.
21:26:21 <d34df00d> Freaking wow. Having a method in a type class that never gets called degrades performance _a lot_.
21:27:03 <Axman6> yeah it's certainly more general than something which would allow for specialised chunk at a time processing
21:36:05 <d34df00d> Cale: looking at core is killing my brain :( How do you do that?
21:37:55 <Cale> Very carefully, I guess?
21:38:36 <heatsink> d34df00d, it helps if you orient by finding features that don't get optimized away
21:39:31 <MarcelineVQ> -dsuppress-all  helps
21:45:00 <Cale> ah, yeah, that tends to be an option I only remember once I start debugging core ;)
21:47:09 <d34df00d> Hmm, interesting.
21:47:19 <d34df00d> Even the types of the functions that get called from `main` are different.
21:48:07 <d34df00d> It's this for the fast version: https://bpaste.net/EKGA
21:48:36 <d34df00d> And this for the slow one: https://bpaste.net/JMEQ
21:48:46 <d34df00d> Where do I need to look further?
21:49:38 <Cale> can we see the rest of the function?
21:50:19 <Cale> It looks like the fast version has fused the I/O into the rest of the computation being done
21:51:04 <Cale> So indeed, it might be an additional inlining happening at the top level
21:51:09 <d34df00d> Sure, sorry. Fast one: https://bpaste.net/UB4Q , slow one: https://bpaste.net/JVNQ 
21:51:27 <d34df00d> I just noticed slow one also jumps to something involving IO at the end.
21:51:31 <ChaiTRex> why is the slow one doing foreignptr stuff?
21:51:40 <d34df00d> Ah, that's something inside that function.
21:52:08 <d34df00d> ChaiTRex: they both take bytestrings. I guess the compiler is able to peel it off for the fast one.
21:53:21 <Cale> It hadn't occurred to me before this just how annoying code that involved ByteString would look :P
21:54:48 <Cale> also the explicit join points are a new thing
22:00:10 <d34df00d> Cale: I stared at this core for a little more, and isn't this jump to the $wgo_s3Vd has effectively the same semantics as the fused stuff in the fast version?
22:00:49 <Cale> actually, yeah
22:01:19 <Cale> They're both doing somewhat trivia I/O and then abstracting over it (probably due to an unsafePerformIO)
22:01:44 <Cale> It's mostly readWord8OffAddr#
22:01:59 <Cale> and you'll see at the very bottom of the slow one
22:02:03 <Cale> ghc-prim-0.5.3:GHC.Prim.realWorld#
22:02:08 <Cale> it's passing in realWorld#
22:02:31 <Cale> which is just a 0-width token that the compiler passes around to keep I/O operations in line
22:03:33 <Cale> The fast version's wgo is taking a RealWorld from elsewhere, but maybe it's still not actually the real one from main
22:04:00 <Cale> (it's probably getting passed in somewhere else)
22:04:21 <d34df00d> Well, the fast main is calling that wgo.
22:04:30 <d34df00d> The slow main is calling this function.
22:05:21 <d34df00d> Also do these jumps to joinrec compile to the same code as calls of a top-level function (like wgo)?
22:07:16 <Cale> That I'm not entirely sure about
22:07:35 <d34df00d> And I really don't see much of a difference between these two functions (the recursive parts) other than in handling ghc-prim-0.5.3:GHC.Prim.eqAddr# result being equal to 1 (which I guess is the "loop exit condition").
22:07:41 <d34df00d> But it probably shouldn't matter since it only happens once.
22:07:49 <Cale> Yeah, they do look rather similar from here
22:09:06 <d34df00d> I think that's bad cause otherwise we'd have a good suspect.
22:11:00 <Cale> It's interesting that the fast one is the one *without* the fancy join point shenanigans
22:14:23 <Cale> It's not even as if it has to keep track of one fewer argument or something...
22:16:02 <Cale> Even the fast one is explicitly passing ww3_s3Yo around when it never changes
22:16:50 <Cale> (though maybe that gets optimised away later)
22:36:55 <d34df00d> Uh, looks like gadt is really to blame.
22:37:40 <d34df00d> If I do smth like https://bpaste.net/BKUA , it works just as fast as that fast version.
22:38:28 <d34df00d> If I instead unpack-repack the step function like https://bpaste.net/HI7Q , it degrades.
22:50:24 * hackage hedis-envy 0.1.0.0 -   https://hackage.haskell.org/package/hedis-envy-0.1.0.0 (igrep)
23:02:24 <Athas> Is there an automated way to update the bounds in a .cabal file to whatever I am actually using?
23:02:59 <Athas> Freeze files don't apply to packages on Hackage, but my life is too short to go around adjusting numbers by hand, so I want to pin (within PVP) to something I know will work.
23:07:30 <yushyin> Athas: https://hackage.haskell.org/package/cabal-bounds maybe?
23:11:13 <Athas> Thanks, that seems like what I'm looking for.
