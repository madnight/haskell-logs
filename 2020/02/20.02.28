00:11:25 <jlamothe> I'm having some trouble reaching Hoogle at the moment.  Does anyone happen to now if there's a function with this type signature: Monad m => Maybe a -> (a -> m ()) -> m ()
00:13:17 <jlamothe> Something that would work along the lines of \x f -> maybe (return ()) f
00:13:52 <jlamothe> I feel there should be a where-ish function to do this.
00:14:03 <[Leary]> % :t for_ @Maybe
00:14:03 <yahb> [Leary]: Applicative f => Maybe a -> (a -> f b) -> f ()
00:14:42 <jlamothe> yahb: You're awesome!  Thanks.
00:19:27 <fog> state evolution of a datatype that is essentially a partitioned vector of doubles can be linearlised to having transfer matricies over this state vector in Rn
00:20:14 <fog> signal reproduction tunes the state evolution matrix, and is obtained as the kalman filter
00:20:24 * hackage JuicyPixels 3.3.5 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.3.5 (VincentBerthoux)
00:20:49 <jlamothe> ...I meant Leary, you're awesome.
00:21:02 <fog> relaxing the linearity condition allows for transfer via computation other than matrix multiplication, and leads to the extended kalman filter for nonlinear system identification
00:21:06 <fog> http://papers.nips.cc/paper/101-training-multilayer-perceptrons-with-the-extended-kalman-algorithm.pdf
00:21:33 <fog> this can be used as a fast alternative to backpropegation for training MLP's
00:21:55 <fog> here, the NN weights are the identified state vector
00:33:23 <idnar> :t (>>)
00:33:25 <lambdabot> Monad m => m a -> m b -> m b
00:33:35 <idnar> :t (*>)
00:33:37 <lambdabot> Applicative f => f a -> f b -> f b
00:34:09 <idnar> @hoogle Monad m => m a -> m b -> m a
00:34:10 <lambdabot> Net.PacketParsing ( #! ) :: (Functor m, Monad m) => m b -> m a -> m b
00:34:10 <lambdabot> Prelude (<*) :: Applicative f => f a -> f b -> f a
00:34:10 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
00:34:20 <idnar> meh
00:34:50 <fog> which isnt quite, transfer matricies replaced by a learned network, since here, the network is assumed fixed as an unchanging internal state vector, as opposed to a network used to update a state vector...
00:35:04 <idnar> I don't think <* sequences the side-effects the way I want
00:36:50 <lhurttila> fog I understand a word here and there but that sound's really interesting 
00:37:25 <fog> the problem is calculating and keeping track of an updated covarience of the involution error, when the state update is performed by something other than a matrix 
00:37:52 <fog> like, extending the NN's for nonlinear functions, or arbitrary function evluation as per Haskell functions
00:38:21 <lhurttila> fog The paper is from 1989. Any idea why the method hasn't been used more widely? or has it?
00:38:24 <fog> then, maybe to do with automatic differentiation of haskell programs could replace this covarience 
00:39:00 <fog> lhurtilla: https://www.spiedigitallibrary.org/conference-proceedings-of-spie/1710/0000/Recurrent-network-training-with-the-decoupled-extended-Kalman-filter-algorithm/10.1117/12.140113.short?SSO=1
00:39:50 <fog> it leads to some strong improvements when they to UD factorization on something like covnets with reduced connectivity expressed as blocks   
00:43:03 <fog> basically the argument they use in "extending" the kalman filter, is that as the transfer function becomes nonlinear, it doesnt matter much
00:43:39 <fog> ie they just put strain on the existing optimality in the linear setting
00:44:10 <fog> but still, the relience on keeping track of an updated covarience means the type we can use is still limeted
00:45:10 <fog> we can extend from just having matrix multiplications, to nonlinear functions, but not to arbitrary lambda/haskell functions, unless we can calculate this covarience update, which seems like a strange Constraint 
00:45:46 <fog> then, this could be combined with existing approaches to the kalman filter written in haskell using Automatic Differentiation
00:48:30 <fog89> http://hackage.haskell.org/package/estimator-1.2.0.0
00:51:26 <fog89> which could give rise to an extended class types which have transfer functions that can be identified by Kalman filtering
00:52:47 <fog89> for instance, it shouldnt matter how i partition up a vector of doubles among various datatypes used in a type, and the program that is used to update this, if linear (ie could be written as a matrix over the values it stores if they were in a simple vector)
00:53:07 <fog89> should be identifiable  
00:53:37 <fog89> so i just want to be able to write an instance for this datatype so I can retrieve it by filtering
00:54:42 <fog89> eg, if i know the state of my system is a deck of cards, then the update functions of how this evolves under some proceadure would typically have an API other than matrix multiplication, like, cut and shuffle
00:55:41 <fog89> treating the situation as a kalman filtering problem, we have some limeted observation, eg, the top cards numeric value, and the fact it is a deck of cards as the hidden variable is unknown
00:57:39 <fog_> still, by using knowledge that this *is* the real underlying system, if we can express the update function API like shuffle as a matrix multiplication, then we could use a time seriese of observations to infer this hidden shuffling proceadure expressed as a matrix
00:58:20 <fog_> the point is that by introducing this class of what extended types we can infer, is that it would not force us to have to express the opperation as a matrix multimplication
01:00:47 <fog_> where the idea is to relate the "differentiability" or "linearity" of programs using AD, to system identification problems with tractable covarience tracking as filtering 
01:03:02 <fog_> finally, there are other approaches to "extended" nonlinear filtering situations using eg FIR, but that what we are building this approach on is the simplicity of the kalmans utilization of covariance tracking
01:05:23 <fog> here the remarkable property sought is that of function implementations that can be inferred by a sequence of observations
01:06:59 <fog> where instead of these being "function approximations" in the form of neural nets for example, by extending these to be all functions in Haskell belonging to a particular class, that this greatly extends the potential implementation details, from matricies to haskell functions 
01:07:43 <fog> and we can have a notion over members of this class, of approximation, and similarity between functions 
01:08:08 <fog> eg, producing some test inputs to a function, and approximatley infering the function from these results
01:12:19 <kuribas> interesting use of lazy IO: http://informatikr.com/2012/redis-pipelining.html
01:13:05 <kuribas> It's only sending the request to redis when the values get evaluated, so it can batch requests together.
01:17:54 * hackage bencode 0.6.1.1 - Parsers and printers for bencoded data.  https://hackage.haskell.org/package/bencode-0.6.1.1 (PeterSimons)
01:27:38 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/6aa41a1288e8e5a2ee31d65a2511f5bf/pasted.txt
01:28:17 <lhurttila> Could someone help me with this a bit? I'm kinda lost with the types and don't know the correct way to build and combine those functions
01:29:18 <kuribas> lhurttila: you want composition?
01:30:13 <lhurttila> If I understand composition right, then yes :)
01:30:27 <kuribas> :t (.)
01:30:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:32:24 <kuribas> lhurttila: or do you want monadic composition?
01:32:28 <kuribas> :t (>=>)
01:32:30 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:33:12 <kuribas> :t (.) :: ([[typeX]] -> [[typeX]]) -> ([[typeX]] -> [[typeX]]) -> ([[typeX]] -> [[typeX]])
01:33:14 <lambdabot> ([[typeX]] -> [[typeX]]) -> ([[typeX]] -> [[typeX]]) -> [[typeX]] -> [[typeX]]
01:33:47 <kuribas> so you can do modTypeXListList2 . modTypeXListList
01:33:54 * hackage hanabi-dealer 0.7.0.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.7.0.0 (SusumuKatayama)
01:36:14 <lhurttila> I don't think i'll need modTypeXListList2 . modTypeXListList. I'm a total beginner so I'm this is kind of over my skill level. The point is to keep all the structure of [[Typex]] unchanged and only change the values. The trickier question is how to implement those a,b and c references when they are dependent of the structure of [[Typex]] given to
01:36:14 <lhurttila> the function
01:37:02 <lhurttila> and also dependent on the Typex being modified
01:41:10 <lhurttila> modTypeXListList does work and type check but it doesn't have all the functionality I need because of those missing references for a,b,c and x in the last where block
01:43:30 <dminuoso> Sigh. Can we just take away the unsafe functions from base?
01:43:33 <dminuoso> cabal-rpm: Maybe.fromJust: Nothing
01:46:27 <boxscape> I suspect if we did that some people would still use incomplete uni patterns to accomplish the same
01:46:38 <boxscape> (not that I'm against it)
01:47:35 <dminuoso> That library has quite a few mentions of fromJust and read...
01:47:53 * dminuoso consider changing careers to become a barista
01:48:03 <kuribas> boxscape: don't use fromJust, use fromMaybe (error "impossible"), or something
01:48:15 <dminuoso> kuribas: That doesn't improve anything.
01:48:24 <kuribas> dminuoso: it improves the error message
01:48:31 <dminuoso> kuribas: The problem isn't even the error message.
01:49:36 <dminuoso> You can't sensibly catch this error, which means you cant give sensible diagnostics.
01:49:49 <dminuoso> The code path I tripped into is definitely not impossible
01:50:06 <dminuoso> Im guessing there's some cabal field that cabal-rpm cares greatly about
01:50:12 <kuribas> dminuoso: oh right, you should add some information there for sure
01:51:16 <boxscape> spoon . fromJust :)
01:51:46 <kuribas> dminuoso: I had this problem with cassava
01:51:52 <dminuoso> boxscape: that package description reads almost as if it belongs to ACME
01:52:11 <dminuoso> This breaks Haskell semantics by the way
01:52:17 <dminuoso> Simon has a great deal to say about this
01:52:38 <kuribas> dminuoso: it uses vector indexing.  And while it could perfectly easily give a meaningful error message, it just crashes with no information at all.
01:57:34 <kuribas> dminuoso: it's beyond me how that's acceptable in the most popular haskell csv library.
02:11:54 * hackage mu-schema 0.2.0.0 - Format-independent schemas for serialization  https://hackage.haskell.org/package/mu-schema-0.2.0.0 (FlavioCorpa)
02:19:54 * hackage mu-rpc 0.2.0.0 - Protocol-independent declaration of services and servers.  https://hackage.haskell.org/package/mu-rpc-0.2.0.0 (FlavioCorpa)
02:21:53 * hackage mu-optics 0.2.0.0 - Optics for @mu-schema@ terms  https://hackage.haskell.org/package/mu-optics-0.2.0.0 (FlavioCorpa)
02:24:54 * hackage mu-avro 0.2.0.0 - Avro serialization support for Mu microservices  https://hackage.haskell.org/package/mu-avro-0.2.0.0 (FlavioCorpa)
02:25:53 * hackage compendium-client 0.2.0.0 - Client for the Compendium schema server  https://hackage.haskell.org/package/compendium-client-0.2.0.0 (FlavioCorpa)
02:37:24 <boxscape> it seems confusing to me that both undefined and Void are called bottom. They seem like fairly different concepts
02:37:45 <Rembane> Isn't Void called Top? 
02:37:47 <shachaf> They are at the bottom of different lattices.
02:38:01 <boxscape> Rembane that's ()
02:38:04 <boxscape> shachaf ah, I see
02:38:25 <__monty__> Wait, what? How is () Top?
02:39:03 <dminuoso> hvr: Out of curiosity, how up-to-date is the guide on hackage-mirror in the hackage-server README.md? Because I can't for my life get it to mirror hackage entirely when the source mirror uses secure.
02:40:24 <boxscape> __monty__ can view () as the type that's trivially only inhabited by (), which makes it the proposition "True" in curry-howard, and Void as the type that's not inhabited, making it "False". And so these are also called top and bottom
02:40:38 <boxscape> __monty__ (ignoring the bottom value undefined)
02:40:54 <boxscape> (which inhabits Void in haskell)
02:42:52 <Rembane> Is () Top in both lattices?
02:44:01 <nvd> Rembane: what's the other lattice?
02:44:22 <boxscape> presumably the lattice where undefined is bottom and the lattice where Void is bottom
02:44:43 <nvd> I think the one where undefined is bottom is only a semilattice
02:44:45 <Rembane> nvd: undefined (), and Void (). 
02:45:18 <shachaf> Probably not, unless you mean undefined :: (), in which case the value () happens to be the top of that lattice.
02:45:48 <shachaf> If people say Void is bottom, my best guess is that they're thinking of some sort of subtyping thing, where Void means (forall a. a), which can be instantiated at any type.
02:46:05 <shachaf> And () means (exists a. a) so any type can be used as it.
02:46:22 <shachaf> My second-best guess is that they mean a category and they're saying "bottom" to mean "initial object".
02:46:54 * hackage mu-protobuf 0.2.0.0 - Protocol Buffers serialization and gRPC schema import for Mu microservices  https://hackage.haskell.org/package/mu-protobuf-0.2.0.0 (FlavioCorpa)
02:48:04 <shachaf> Ironically these two bottoms can't exist in the same system, probably.
02:48:30 <shachaf> The thing that makes Void initial is that it's uninhabited, but then it doesn't have a bottom value.
02:48:38 <boxscape> the wikipedia article on "bottom type" also seems somewhat confused, but maybe it's just confusingly written
02:48:55 <boxscape> it says both that the bottom type is the empty type and that it's the natural type for null
02:49:31 <boxscape> ah wait
02:49:47 <boxscape> it actually says that this doesn't fulfill all properties because that means it's not uninhabited
02:50:15 <__monty__> I don't by the () is Top thing tbh. If "being trivially inhabited" is enough to be Top then Bool and Int, etc. are all Top.
02:50:53 * hackage mu-persistent 0.2.0.0 - Utilities for interoperation between Mu and Persistent  https://hackage.haskell.org/package/mu-persistent-0.2.0.0 (FlavioCorpa)
02:51:35 <shachaf> Then you can buy one of the other things I said: (exists a. a) is a top in the subtyping sense, and () is a terminal object.
02:56:09 <__monty__> Can you differentiate between (exists a. a) and (forall a. a) in haskell?
02:58:24 * hackage mmsyn7s 0.6.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.0.0 (OleksandrZhabenko)
02:58:58 <dminuoso> __monty__: Differentiate in what sense?
02:59:23 <dminuoso> __monty__: skolem/metavariable checking ensures you can't mix that up.
02:59:50 <__monty__> dminuoso: Well, the syntax is identical, right? So can you specify such types?
02:59:57 <dminuoso> The syntax is not.
03:00:23 <dminuoso> We don't have `exists`, so you can't really specify it.
03:00:51 <__monty__> I thought the syntax for existential types was forall too?
03:01:23 <dminuoso> Say if you have `data Foo where forall a. Show a => a -> Foo`, and you do something like `case f of Foo t -> ...`, then you can't say `case f of Foo (t :: exists t. Show t => t) -> ...`
03:01:36 <dminuoso> Yes but it's at a different location, you can't mix those up
03:01:50 <dminuoso> Or it's scoped differently in case of GADTs
03:04:54 * hackage mmsyn7s 0.6.1.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.1.0 (OleksandrZhabenko)
03:05:07 <dminuoso> __monty__: c.f. `newtype Imp = Imp (forall t. Show t => t)` with `data Exi = forall t. Show t => Exi t`
03:05:23 <dminuoso> The keyword is the same, but syntactically its not
03:07:24 * hackage mu-grpc-common 0.2.0.0 - gRPC for Mu, common modules for client and server  https://hackage.haskell.org/package/mu-grpc-common-0.2.0.0 (FlavioCorpa)
03:07:39 <__monty__> Ok, thanks, have never needed such a type so I'm not too familiar.
03:08:50 <dminuoso> __monty__: It's actually easy to step into this. Say you have multiple types conforming to a typeclass interface, and you want to have a sort of heteregenous list out of all things that fit that interface...
03:08:54 * hackage hsinspect 0.0.11 - Inspect Haskell source files.  https://hackage.haskell.org/package/hsinspect-0.0.11 (tseenshe)
03:08:55 <dminuoso> Say a list of showable things
03:09:27 <dminuoso> % data Showable = forall t. Show t => Showable t
03:09:27 <yahb> dminuoso: 
03:10:00 <dminuoso> % showAll :: [Showable] = foldMap (\Showable e -> show e)
03:10:01 <yahb> dminuoso: ; <interactive>:57:35: error:; * The constructor `Showable' should have 1 argument, but has been given none; * In the pattern: Showable; In the first argument of `foldMap', namely `(\ Showable e -> show e)'; In the expression: foldMap (\ Showable e -> show e)
03:11:54 * hackage mu-grpc-client 0.2.0.0 - gRPC clients from Mu definitions  https://hackage.haskell.org/package/mu-grpc-client-0.2.0.0 (FlavioCorpa)
03:13:23 * hackage mmsyn7s 0.6.2.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.2.0 (OleksandrZhabenko)
03:16:23 * hackage mu-grpc-server 0.2.0.0 - gRPC servers for Mu definitions  https://hackage.haskell.org/package/mu-grpc-server-0.2.0.0 (FlavioCorpa)
03:17:09 <__monty__> % [Showable 5, Showable 'a', Showable True] :: [Showable]
03:17:10 <yahb> __monty__: ; <interactive>:58:1: error:; * No instance for (Show Showable) arising from a use of `print'; There are instances for similar types:; instance [safe] Show Ghci9.Showable -- Defined at <interactive>:25:1; instance [safe] Show Ghci12.Showable -- Defined at <interactive>:29:1; instance [safe] Show Ghci15.Showable -- Defined at <interactive>:35:1; * In a stmt of an inte
03:17:37 <__monty__> % :t [Showable 5, Showable 'a', Showable True]
03:17:37 <yahb> __monty__: [Showable]
03:17:45 <__monty__> TIL
03:18:07 <yushyin> ;)
03:19:24 * hackage mmsyn7s 0.6.3.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.3.0 (OleksandrZhabenko)
03:22:38 <kuribas> is there a package to create a servant API from swagger?
03:34:33 <boxscape> __monty__ `(exists x. p x) -> q` is equivalent to `forall x. (p x -> q)` and `exists n . (P n)` is equivalent to `forall r . (forall n . P n -> r) -> r`
03:35:30 <boxscape> (assign no significance to the capitalization of p/P)
03:43:29 <boxscape> so `exists a . a` is equivalent to `forall r . (forall a . a -> r) -> r`
03:45:58 <kuribas> anyone got lsp-ui-doc-mode working in emacs?
03:46:21 <kuribas> I would like to have a documentation frame instead of the sideline.
03:48:54 * hackage text-show 3.8.5 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.8.5 (ryanglscott)
04:00:13 <jonatan> Is there any reason why I might not want to use quickcheck for general purpose random generation? Seems to me like it has a much more convenient interface than System.Random. Is it unsuitable for non-testing purposes?
04:12:14 <ski> boxscape : yes, and also to `()' (so not particularly useful)
04:12:54 <boxscape> right, that makes sense
04:14:38 <boxscape> ski oh I suppose forall r . (forall a . a -> r) -> r is just the Church encoding of () isn't it
04:15:15 <ski> rather `forall r. r -> r'
04:15:36 <boxscape> ah, right
04:16:08 <dminuoso> In the sense that only one function satisfies that type?
04:16:59 <boxscape> I'm not sure statement that question refers to
04:18:24 * hackage logic-TPTP 0.5.0.0 - Import, export etc. for TPTP, a syntax for first-order logic  https://hackage.haskell.org/package/logic-TPTP-0.5.0.0 (MasahiroSakai)
04:24:56 <lhurttila> Could someone take look at this? I got the original question pretty much solved but the referencing is still an open question. https://stackoverflow.com/questions/60428086/how-to-modify-a-list-value-in-a-nested-custom-datatype
04:25:43 <ski> (well, considering `()' as being defined as `data () = ()' there's one data constructor, with zero components, which yields `forall r. r -> r'. similarly, for `(a,b)' being defined as `data (a,b) = (a,b)' with two components of the constructor, you get `forall r. (a -> b -> r) -> r')
04:27:06 <dminuoso> lhurttila: Generally packages like lens/optics solve the problem of working with (deeply) nested data types equivalently
04:27:13 <dminuoso> *elegantly!
04:33:38 <lhurttila> dminuoso I was kinda hoping there would be a simpler way to get that done, but I guess I'll have to start learning lenses then.
04:33:48 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/df435d369076b9ca95b8000aea01b1ce/Haskell%20learning%20curve.jfif
04:34:18 <dminuoso> lhurttila: On second thought, maybe I misunderstood your problem
04:34:32 <lhurttila> As a beginner that learning curve doesn't seem too tempting '=D 
04:35:15 <boxscape> I wouldn't necessarily agree with that learning curve - lens is a huge library, and the underlying encoding (and errors you can get) can be daunting, but actually using it is pretty straightforward
04:35:53 <dminuoso> Be sure to also consider optics, especially as a beginner. The newtypes make using it a much less daunting experience.
04:36:18 <dminuoso> (As, unlike with lens, compiler errors will actually be easily decodable and meaningful )
04:37:53 <boxscape> (also strictly following the axes the image seems to indicate that after just spending a little time coding with lenses you become an expert, which is amusing)
04:39:15 <lhurttila> yeah actualy it does.. ok here's hoping it was originally meant as encouraging
04:58:52 <zincy__> If you have a function which takes three Maybe's is there a slick way of collecting all the Nothings in a list and printing them as missing params
04:59:12 <zincy__> I am thinking guards
05:16:39 <dminuoso> zincy__: Is it just an odd single case? Or is this a recurring pattern for you?
05:27:32 <zincy__> dminuoso: Odd single case
05:33:17 <absence> can a view pattern match multiple values? something like case myTuple3 of; (a, b, c) -> ... where i want to pass a and b to the view
05:37:52 <dminuoso> absence: It matches a single value. :)
05:38:49 <dminuoso> That is, `(1,2,3)` already is a single value
05:40:03 <Putonlalla> The `acts` package defines the unique element induced by a semigroup action as `<--`. Does this arrow have a name?
05:40:39 <Putonlalla> If not, would people laugh at me if I called it the torsion of the group?
05:43:05 <absence> dminuoso: hmm... maybe (a, b, view b -> res) -> will do the trick
05:43:21 <absence> er.. that was b and c, not a and b, but you get the idea
05:48:07 <Solonarv> eugh, just use pattern guards instead tbh
05:48:31 <Solonarv> (a, b, c) | res <- view b c -> -- much clearer
05:48:37 <Solonarv> (probably add some newlines in there)
05:50:21 <absence> Solonarv: didn't know about pattern guards, thanks!
05:51:18 <absence> or well, i didn't know they could be used like that. is that normal syntax, or an extension?
05:51:30 <boxscape> Used to be an extension but integrated in Haskell2010
05:51:31 <Solonarv> I think it's part of Haskell2010, actually
05:54:40 <absence> cool, it works like a charm
05:55:04 <dminuoso> Pattern guards are really great :)
05:56:21 <AWizzArd> Haskell-IDEs and Nix: I can create a nix-shell with all my dependencies. Now some IDEs want to start some program, such as the language server. Is there some mechanism in Nix that can ensure that the shelled LS gets started? Or does this have to be resolved at the level of the IDE plugin?
05:57:19 <dminuoso> AWizzArd: So I simply start emacs out of the nix-shell...
05:57:34 <dminuoso> That addresses all problems. It's far from pretty, but it's far less hackier than the alternatives
05:58:12 <dminuoso> I tend to work on single projects for prolonged times, so the weight of not leveraging projectile isn't that great.
05:59:43 <AWizzArd> dminuoso: this emacs outside of nix-shell ... would it assume that the dependencies of the project are available?
06:00:14 <dminuoso> AWizzArd: Well I just put ghcid into buildInputs to every shell.nix... ;)
06:00:16 <AWizzArd> dminuoso: currently I use stack to run a docker container in which I placed the postgres drivers. Works. But indeed very hacky.
06:00:28 <dminuoso> AWizzArd: Or postgres
06:00:53 <AWizzArd> dminuoso: yes, the postgres stuff would have to land in the shell/environment right?
06:02:06 <AWizzArd> But if I now load a .hs file this will trigger Emacs to start the language server. Emacs will expect it to be installed on my system. That language server doesn't know about my nix environment, in which it can find the postgres drivers.
06:02:18 <dminuoso> AWizzArd: I dont believe that fighting so hard to gain perfect separation for databases is worth it. Every project needing a database gets its own database and user, but I just run a single postgres 9.6 here.
06:02:18 <dminuoso> So the postgres buildInput is just for making headers and libraries available
06:02:36 <dminuoso> Ah I dont know about language server, really.
06:02:49 * dminuoso uses raw ghcid with compilation mode
06:03:54 <AWizzArd> And that ghcid is running in the nix env.
06:03:57 <AWizzArd> si?
06:04:58 <dminuoso> AWizzArd: Well its started from emacs, which itself is started from inside the nix-shell.
06:05:19 <AWizzArd> Oh okay, then I misunderstood. I thought you are running an emacs outside of that shell.
06:05:32 <dminuoso> Sorry I misphrased.
06:05:55 <AWizzArd> So your strategy is to embed the IDE(s) inside the shell as well.
06:07:04 <dminuoso> Not as much "embed" as merely "invoke it from there"
06:07:08 <__monty__> I don't think they're saying emacs is installed in the shell. Just run from inside the shell so it finds the right commands on the PATH.
06:07:18 <Solonarv> AWizzArd: perhaps you can leave a small script on your path as 'ghcid' (or whatever you use) which starts a nix shell and then runs ghcid (or whatever) from inside that shell
06:07:29 <Solonarv> if you don't want to start the IDE from within the shell, that is
06:09:42 <AWizzArd> Solonarv: could also be a plausible approach. I wouldn’t mind though to place the IDE in the environment. But then there really has to be some machinery on the outside, so that every dev gets his own ide and his own configuration.
06:10:34 <AWizzArd> Btw, what speaks against making a very minimal Nix env, which just contains Cabal (or Stack) and zero Haskell deps, but all the OS dependencies, such as Postgres? And then, inside this env, just use cabal/stack as you would have done without nix.
06:11:04 <__monty__> AWizzArd: That's fine IME.
06:11:08 <__monty__> At least for development.
06:11:49 <AWizzArd> __monty__: my hope would be that some stack LTS version will stay pretty stable, and should provide reasonably reproducible builds.
06:11:54 <boxscape> absence btw, guards are a superset of pattern guards. "pattern guard" specifically refers to this syntax, controlled by -XPatternGuards
06:13:16 <boxscape> (except that ghc still accepts them even with -XNoPatternGuards, albeit with a warning)
06:16:45 <AWizzArd> __monty__: and for production? Would you switch to all dependencies in Nix, plus switching from Stack to Cabal?
06:23:35 <__monty__> AWizzArd: Probably yeah.
06:46:43 <absence> boxscape: good to know
06:54:23 <maerwald> Why use nix at all? You have 20 remote devs with different setups and lots of system dependencies? 
06:55:07 <maerwald> Write a README
06:55:09 <maerwald> :p
07:01:06 <Solonarv> README contents: "use nix" ;)
07:03:28 <boxscape> hmm in git bash on windows if I type getLine, backspace works like I would expect. In the windows subsystem for linux, it instead inserts \DEL characters. What's responsible for this difference?
07:03:55 <boxscape> if I type after calling getLine in ghci, rather
07:04:21 <boxscape> hmm I guess you can't really call it since it's not a function
07:04:25 <__monty__> boxscape: Do the terminal emulators differ? Sometimes bs sends ^H and sometimes it sends ^?.
07:05:02 <boxscape> __monty__ they are different terminal emulators, yeah. I suppose that's probably it then.
07:05:21 <__monty__> I'm not sure what the difference between them is though. Both those escapes function like BS in my irssi.
07:05:40 <boxscape> hmm cmd on windows works too, interesting
07:05:51 <boxscape> I would expect the subsystem terminal emulator to be similar to cmd
07:05:54 * hackage urbit-hob 0.3.2 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.3.2 (JaredTobin)
07:06:27 <maerwald> Solonarv: *contributer moves on*
07:08:30 <boxscape> __monty__ hmm interestingly typing Ctrl-H in the subsystem produces \b and Ctrl-? produces \US, whereas backspace produces \DEL
07:09:39 <boxscape> oh but Ctrl-/ also produces \US, so it probably just ignores shift in that context
07:14:54 <rindolf> Hi all! maerwald : hi, are you there?
07:15:09 <__monty__> maerwald: That's silly. For those who use nix it's literally trivial to get set up. For those who don't, nix requires explicitly declaring *all* dependencies so they should have an easier time finding out the dependencies needed than with a rarely up-to-date and even rarerly complete README.
07:16:05 <fishooter> what's the name of the function which does this?
07:16:05 <fishooter> xxx? [+2, *2, -2] [1,2,3]
07:16:06 <fishooter> [3,4,5,  2,4,6,  -1,0,1]
07:16:20 <Solonarv> tbf, someone who doesn't use nix might well not *know* that a .nix file also acts as a readable specification of all the dependencies
07:16:34 <Solonarv> fishooter: looks like <*> to me
07:16:46 <Putonlalla> > ap [(+ 2), (* 2), (subtract 2)] [1, 2, 3]
07:16:48 <lambdabot>  [3,4,5,2,4,6,-1,0,1]
07:17:12 <Solonarv> (ap and <*> are the same thing)
07:17:16 <__monty__> Solonarv: Sure but your README contents was a joke and maerwald seems to be arguing for ditching the nix expression and only having a README>
07:17:29 <fishooter> alright :) I thought it was something like that
07:17:30 <fishooter> thanks!
07:17:40 <Putonlalla> Prefer using `<*>`.
07:17:48 <boxscape> :t ap
07:17:50 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:18:29 <Solonarv> my approach (if I used nix) would probably be to have the README point out something like: "if you have nix, use it; otherwise the nix file contains a readable-enough list of the dependencies needed, install them using apt or whatever"
07:19:44 <__monty__> Solonarv: I'd go the extra step listing the deps but pointing out where they can find the actual deps if the list is outdated is a great idea.
07:26:33 <maerwald> rindolf: sup
07:27:42 <rindolf> maerwald: i want to release a new version of PySol: https://github.com/shlomif/PySolFC/issues/151
07:28:41 <rindolf> maerwald: i am also contemplating to translate the solution of https://projecteuler.net/problem=630 to C++ to see how fast it will be
07:30:35 <maerwald> Cool, not sure what the correlation to haskell is though 
07:40:48 <fishooter> is there a convenient way to do
07:40:49 <fishooter> xxx? [*2, +2] [(1,'a'), (2,'b'), (3,'c')]
07:40:49 <fishooter> [(2,'a'), (4,'b'), (6,'c'),    (3,'a'), (4,'b'), (5,'c')]
07:40:55 <fishooter> with <*> ? :)
07:48:48 <[Leary]> % Data.Bifunctor.first <$> [(*2), (+2)] <*> [(1,'a'), (2,'b'), (3,'c')]
07:48:48 <yahb> [Leary]: [(2,'a'),(4,'b'),(6,'c'),(3,'a'),(4,'b'),(5,'c')]
07:51:22 <boxscape> ^ fishooter
07:55:19 <rindolf> maerwald: we worked on a ghc version of the code that is currently slower than cpython3
07:55:26 <fishooter> oh, awesome :) so that's how they can be used
07:55:37 <fishooter> I have
07:55:45 <fishooter> f (a, b)
07:55:51 <fishooter> how can I make it into 
07:55:52 <fishooter> f a b
07:55:53 <fishooter> ?
07:55:57 <rindolf> maerwald: see https://github.com/hasufell/euler630-mniip
07:56:15 <maerwald> Ah
07:56:15 <fishooter> I tried  f . curry
07:56:43 <boxscape> fishooter have you tried curry f
07:56:54 <boxscape> assuming you mean that f :: (a, b) -> c
07:57:57 <fishooter> boxscape: it's the other way around, I have f :: a -> b -> c
07:58:10 <fishooter> and I want to use f, but I have (a,b) at my disposal
07:58:20 <fishooter> of course I can unbox the tuple
07:58:39 <fishooter> but I was wondering if I can make it simpler
07:58:49 <ski> fishooter : `uncurry f (a,b)' ?
07:59:19 <fishooter> ah, I'm stupid ! :) thanks
08:29:52 <maerwald> I wasn't aware that if you enable -XStrict, and have a foo=undefined function in a where clause that is not even used anywhere, it gets evaluated
08:37:31 <davean> maerwald: it would have to, otherwise you'd have to expect something to be lazy?
08:37:49 <davean> The interesting part is the compiler isn't optimizing it out
08:37:51 <maerwald> Yes, but it's a where clause. 
08:38:07 <davean> maerwald: its define, the fact it exists is what matters I think
08:38:56 <davean> otherwise strict definitions would be somewhat pointless
08:38:59 <maerwald> If you write a top level function foo=undefined it does not evaluate it
08:39:07 <davean> right
08:39:14 <davean> but a where is like a let
08:39:18 <davean> you entered the closure
08:39:25 <davean> you never entered the closure of that top level function
09:14:57 <oisdk> If I want to get nice diagrams (ideally animated) depicting the evaluation of Haskell expressions, what are some good options out there? I especially would like to be able to demonstrate laziness clearly
09:19:59 <MarcelineVQ> there's ghc-vis and another like it I can't remember the name of, also http://www.well-typed.com/blog/2017/09/visualize-cbn/ but it's not a diagram, though one might be able to make a diagram using it
09:23:20 <oisdk> I actually use visualize-cbn a little at the moment, but I'll have to give ghc-vis another try
09:24:21 <fragamus> hi I'm using the latest version of stack and I got a lot of "has no symbols" errors
09:26:24 <fragamus> It seems like maybe my XCode is not the right version
09:28:33 <MarcelineVQ> What is a has no symbols error?
09:37:17 <sm[m]> oisdk_: no diagram, but there
09:37:22 <sm[m]> 's https://tech.fpcomplete.com/blog/teaching-haskell-with-duet
09:37:38 <sm[m]> also, trace is pretty good for demonstrating laziness
09:56:31 <rindolf> maerwald: this C++ code is somewhat faster than pypy3 (3.8s instead of 4.3s ) which in turn is faster than cpython3 and which is faster than our ghc code: https://paste.debian.net/1132742/
10:01:29 <mlugg> Hey, I'm writing a basic feed-forward neural network in Haskell. I need to have a frontend (simple terminal command-based interface) which can be used even while the network is training. I also need the frontend and training code to be able to communicate; i.e. the frontend sends commands to the backend. What would be the best way to achieve
10:01:29 <mlugg> something like this? I've tried using forkIO to spawn a worker thread, and using a STM TQueue to send commands; however, this seems to have performance issues, which I'm guessing is due to Haskell threads not yielding (although I might be wrong).
10:05:27 <solonarv> mlugg: yielding happens at allocations and when you explicitly call 'yield'
10:05:41 <solonarv> (and probably also when waiting on some IO)
10:05:45 <solonarv> so, quite frequently
10:06:24 <solonarv> could you detail the performance issues? is the frontend unresponsive, or is the NN taking longer than expected to compute, or what?
10:11:48 <mlugg> Afaict, both
10:11:53 <mlugg> The frontend is definitely unresponsive
10:12:08 <mlugg> At times, it can take 3 or 4 seconds to respond to input
10:12:31 <mlugg> But I think the training was running faster when I tried hardcoding it into main too
10:12:34 <mlugg> Let me check quickly
10:29:47 <sm[m]> a nice discussion of Go's leaky abstractions.. I wonder how we'd do on these examples. https://news.ycombinator.com/item?id=22443363
10:29:59 <sm[m]> s/discussion/rant/
10:30:11 <sm[m]> well, both
10:32:04 <maerwald> nice
10:32:50 <maerwald> I like the "it's a miracle anything works at all" part lol
10:34:33 <sm[m]> oh he's just getting started, read on... :)
10:34:45 <hyperisco> sm[m], I have never used Go. Why is a file system API relevant to the Go language?
10:35:17 <hyperisco> There are nonsense file system APIs for many languages. As the author says, Node.js being one
10:35:57 <maerwald> sm[m]: the rant about file abstraction applies to haskell too
10:36:19 <remexre> is there a way to get GHC to dump the typeclass contraints solved for that apply to any type variable?
10:38:50 <sm[m]> hyperisco: they argue it's a symptomatic of a general failing of Go, as you'll see in the article
10:38:57 <maerwald> and the rant about filepaths applies even moreso to haskell
10:42:44 <maerwald> I don't really understand his point too much about filepaths. The decision is correct for unix. Might have negative impact on non-unix systems only.
10:43:24 <maerwald> so yes, it's a unix-leaning stdlib
10:45:20 <maerwald> not much language-specific things in the rant though, it's more about stdlib/libs
10:47:13 <hyperisco> sm[m], the time story is horrifying
10:47:57 <maerwald> time itself is!
10:48:01 <geekosaur> ^
10:49:01 <hyperisco> they are separable concepts
10:49:30 <hyperisco> to unilaterally declare everyone who wanted the *system time* as wrong is absurd
10:50:08 <hyperisco> on top of that you have this conflated object which is two concepts of time at once
10:50:51 <maerwald> https://gist.github.com/timvisee/fcda9bbdff88d45cc9061606b4b923ca hehehe
10:51:37 <maerwald> "You can determine the time zone from the city/town." lolo
10:52:08 <hyperisco> and retroactively restricts the year range to 1950-2222 my lord
10:55:18 <srid> Does this function exist? `DSum f Identity -> Some f`? 
11:02:43 <jle`> srid: are you asking if it is possible, or asking if it exists in the dependent-sum library?
11:04:45 <srid> jle`: whether it is possible.
11:06:36 <MarcelineVQ> not just possible but should be straightforward, assuming this does what I think it does:  foo :: DSum tag f -> Some tag; foo (g :=> r) = Some g
11:08:30 <srid> Ah, nice. Didn't know why I assumed it was tricky
11:19:31 <remexre> is there a way to get https://repl.it/repls/HarmoniousLividTitle to typecheck, only changing len? I thought Haskell could normally use the => on the LHS of instances, though maybe DataKinds is tripping it up
11:19:50 <maerwald> is there an interpolation lib that allows me to define which function is run on the variables (e.g. something different than *show*)?
11:20:11 <remexre> pastebin for ppl who dislike repl.it: https://p.acm.umn.edu/XCNPWkfcsAA=
11:20:21 <maerwald> e.g. I'd rather have it use Doc stuff, so I can pretty-print it
11:24:08 <mmachenry> I'm having trouble running a script in stack. I'm getting a 404 from the server. Anyone know what I'm doing wrong? https://gist.github.com/mmachenry/8f49165befe1cc6c88ac2bec52cdd05c
11:24:45 <mmachenry> I am pretty sure I copied this appropriately from the stackage website.
11:26:23 <remexre> okay, a non-datakinded version (using tuples as conses, nil as nil) gets the same error
11:26:31 <maerwald>  /fpco/lts-haskell/master//lts-15.1.yaml -- this kinda looks like a variable after 'master' is empty
11:27:09 <MarcelineVQ> maerwald: hmm  14.27 exists on that path
11:29:02 <mmachenry> maerwald: Are you suggesting that particular resolver is broken?
11:30:36 <mmachenry> maerwald: Oh gosh, I didn't even consider that and 14.27 works just fine. Hm... I assumed I was misremembering how to do stack scripting but I think 15.1 is broken.
11:31:21 <MarcelineVQ> probably not broken since there's a 15.0 that also not loading from that path, it's unlikely they'd release 2 lts in a row no one could use. This is the second time I've seen someone with this issue with a 15.* resolver though. mmachenry: what version of stack do you have?
11:31:53 <mmachenry> 1.91
11:31:56 <mmachenry> 1.9.1
11:32:24 <MarcelineVQ> try an upgrade then,  stack upgrade   note where it puts the executable it makes
11:33:00 <MarcelineVQ> I have 2.1.3 and don't have an issue using 15.0
11:33:49 <mmachenry> The upgrade fixed it.
11:33:54 <sm[m]> indeed it seems missing from https://github.com/commercialhaskell/lts-haskell
11:34:13 <mmachenry> So resolver 15.1 doesn't work with stack versions as old as 1.9.1. Makes sense. 
11:34:17 <remexre> ok, did smth gross w/ ConstraintKinds+Rank2Types to fix mine https://repl.it/repls/JollySlipperyAlgorithms :|
11:34:39 <MarcelineVQ> mmachenry: well idk, give it a try and we'll see :>
11:34:52 <MarcelineVQ> oh you said it fixed hehe
11:36:17 <mmachenry> Does anyone have any recomendations for how to structure a Dockerfile running a small Haskell script alongside the main server? I have considered a temp Docker image which compiles the code and copy to the new image... I also am considering installing stack and running stack script, but the first execution will always take a long time.
11:36:49 <mmachenry> I could run stack install package1 package2 in my Docker file, but then if my script has the packages in the script heading, I've duplicated my package list.
11:36:56 <MarcelineVQ> https://www.stackage.org/blog/2020/02/discontinuing-legacy-snapshots
11:36:56 <sm[m]> I guess recent stack gets resolvers from https://github.com/commercialhaskell/stackage-snapshots instead
11:37:24 <mmachenry> Maybe there's a simple way to run a command to download all packages for a script without running the script?
11:37:56 <sm[m]> nice
11:38:54 <sm[m]> mmachenry: you'd have to change the stack command line at the top - s/script/build --only-dependencies/ or something
11:39:21 <mmachenry> Oh hm...
11:39:42 <sm[m]> or manually run that
12:03:38 <wildtrees> what are some general uses of foldM? 
12:06:06 <jle`> are you really asking for general uses, or are you looking for specific usages?
12:10:51 <wildtrees> I see it in use for some n-queens code, and was just wondering if there are any common uses or nice cute idioms with it, for me to wrap my head around foldM, I don't think I have ever used it that much 
12:14:37 <AWizzArd> If I wanted to use an ultra simple Nix setup to create a dev environment with Cabal – do I then need any nix expressions? Couldn’t I start with a simple shell script which calls `nix-shell` with Cabal and a few OS dependencies?
12:20:18 <MasseR> AWizzArd a super *super* simple setup is to `cabal2nix ./. --shell > shell.nix` to get a dev environment. You can then probably add your system-level dependencies there
12:21:17 <AWizzArd> MasseR: why use cabal2nix? Inside the shell I can use ordinary cabal to build my software.
12:22:05 <MasseR> To create a dev environment with cabal. Or did I miss something? It creates a shell.nix in which you have all the dependencies that are defined in the cabal file (and hopefully cabal-install as well)
12:22:34 <AWizzArd> MasseR: I thought about creating a nix-shell and just put cabal + ghc inside, and some OS deps, such as postgres drivers.
12:22:56 <AWizzArd> The job of Nix is only to provide this shell. Nothing else. The rest is done as if I used cabal outside.
12:22:58 <MasseR> That's what the cabal2nix --shell does IIRC. It just does it for you automatically
12:23:26 <AWizzArd> So cabal2nix is the same as `nix-shell --packages cabal ghc`?
12:23:53 <MasseR> AWizzArd not quite. Your command doesn't quite do enough
12:24:09 <MasseR> It provides you with a ghc and a pretty barebones ghc-pkg
12:24:26 <AWizzArd> MasseR: I would need a big load more of dependencies? gcc? zlib?
12:24:30 <MasseR> Oh, right, you *want* to use cabal to handle dependencies for you?
12:24:43 <iqubic> Yeah. If you need any haskell deps, that command will not install them.
12:24:44 <AWizzArd> MasseR: yes, Nix will be doing nothing in this setup.
12:25:02 <AWizzArd> All Haskell deps will be handled by Cabal, as if Nix wouldn't even exist.
12:25:34 <AWizzArd> Nix will only provide the 1-2 OS deps that I might need, such as the postgres drivers so that I can use the simple-pg package from Hackage.
12:25:52 <MasseR> Disregard my comments then
12:26:03 <MasseR> Is there a reason you don't want to use nix to handle the deps?
12:26:29 <AWizzArd> MasseR: simplicity, to start with Nix. That means that I keep Nix in the background at first.
12:26:48 <AWizzArd> Also I don’t see how it would hurt. Cabal’s purpose in a way IS to download Haskell deps.
12:27:00 <jle`> :t foldM
12:27:01 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
12:27:20 <jle`> wildtrees: i think it's not too much of a fundamental leap from foldl in general
12:27:21 <MasseR> "simplicity, to start with nix", I would almost argue that you're teaching yourself bad habits with that when it comes to nix
12:27:33 <jle`> wildtrees: for example let's say you want to fold results from different files in IO
12:27:46 <jle`> you can use foldM blahblah ["file1.txt", "file2.txt"]
12:27:52 <iqubic> MasseR: I have to agree with you.
12:28:02 <jle`> wildtrees: and you want to use readFile or something
12:28:28 <jle`> wildtrees: basically it's just foldl with a monadic accumulator function, so it's the same reasons why you would, say, use 'map' vs. 'mapM'
12:28:34 <jle`> (if you're familiar with that difference)
12:29:04 <wildtrees> yea I understand map and mapM(_) quite well 
12:29:10 <wildtrees> :t mapM 
12:29:12 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:29:25 <wildtrees> think I mostly use mapM_ though 
12:30:23 <MasseR> wildtrees In practice, I don't think I have ever used `foldM` in production code. Not that I wouldn't use it if it would fit the problem, but so far the `foldl'`, `foldr` and `foldMap` have proven to be more useful
12:31:09 <remexre> is there a way to do the extension trait pattern (from Rust) in Haskell, without UndecidableInstances?
12:31:14 <wildtrees> can't say I use foldMap that much or see it either 
12:33:04 <remexre> alternatively (and separately, I guess), is there some way to pattern-match on a DataKinded type parameter, without (ab)using the typeclass system to do so?
12:33:25 <MasseR> Makes me feel better if I see my problem can be stated as a monoid. Or some other structure with laws. Less stuff to reason about
12:36:21 <jle`> wildtrees: so it's pretty much mapM vs. map
12:36:39 <jle`> if sometimes you think 'i want to use a map, but i return IO Int instead of Int', then you use mapM and not Map
12:36:53 <jle`> wildtrees: so similarly if you think 'i want to use foldl, but i return IO Int instead of Int', you use foldM and not foldl
12:38:24 * hackage data-compat 0.1.0.1 - Define Backwards Compatibility Schemes for Arbitrary Data  https://hackage.haskell.org/package/data-compat-0.1.0.1 (TravisWhitaker)
12:39:01 <jle`> wildtrees: it's not a particularly 'deep' revelation, imo
12:42:24 <jle`> at least not on the level that foldl/foldr are
12:56:55 <boxscape> am I understanding it correctly that polymorphic recursion isn't something you can do with fix?
12:58:53 <solonarv> boxscape: sounds correct to me
12:59:03 <boxscape> ok, thanks
12:59:16 <solonarv> seems to me like it would require impredicativity
12:59:18 <ski> you'd need `ImpredicativeTypes', i think
13:00:15 <boxscape> I see
13:00:19 <boxscape> that makes sense
13:02:07 <koz_> _Working_ ImpredicativeTypes, at that.
13:03:27 <boxscape> would you need to change the definition of fix or the callsite?
13:03:39 <boxscape> (i.e. use Impredicative types there)
13:04:10 <ski> the callsite (assuming `ImpredicativeTypes' worked)
13:04:14 <boxscape> ok
13:07:01 <solonarv> and it actually is not powerful enough for all forms of polymorphic recursion
13:07:11 <koz_> What would such a fix's type be?
13:07:14 <koz_> :t fix
13:07:16 <lambdabot> (a -> a) -> a
13:07:44 <solonarv> example: data ETree a = Tip a | Branch (ETree (a,a))
13:08:06 <solonarv> infTree :: forall a. ETree a; infTree = Branch infTree
13:08:50 <solonarv> this looks like 'fix Branch', but 'Branch :: ETree (a,a) -> ETree a' - there is no way to match that with the 'a -> a' in fix's type
13:09:01 <boxscape> hm, interesting
13:10:58 <boxscape> could there in principle be something like fix that allowed this? I.e. a function that would make language support for explicit recursion unnecessary
13:12:21 <ski> @let fix1 :: forall f. ((forall a. f a) -> (forall a. f a)) -> (forall a. f a); fix1 f = x where x :: forall a. f a; x = f x
13:12:23 <lambdabot>  Defined.
13:12:32 <ski> @let data PBBT a = Elems a | Double (PBBT (a,a))
13:12:33 <lambdabot>  Defined.
13:12:35 <solonarv> should be possible in principle, but I'm not sure how fancy a type system you would need for this
13:12:42 <ski> @let data Leaves a = MkLeaves {unLeaves :: PBBT a -> [a]}
13:12:43 <lambdabot>  Defined.
13:12:52 <ski> @let leaves :: forall a. PBBT a -> [a]; leaves = unLeaves (fix1 leave) where leave :: (forall a. Leaves a) -> (forall a. Leaves a); leave (MkLeaves leaves) = MkLeaves (\case Elems x -> [x]; Double t -> concatMap (\(x0,x1) -> [x0,x1]) (leaves t))
13:12:54 <lambdabot>  Defined.
13:13:45 <ski> @let infTree :: forall a. PBBT a; infTree = Double infTree
13:13:47 <lambdabot>  Defined.
13:15:17 <ski> @let infTree' :: forall a. PBBT a; infTree' = fix1 inf where inf :: (forall a. PBBT a) -> (forall a. PBBT a); inf infTree = Double infTree
13:15:18 <lambdabot>  Defined.
13:16:15 <boxscape> nice
13:18:54 <ski> oh hm, you could already do this, with the usual `fix', and `PolymorphicComponents' (now usurped into `RankNTypes'), i think
13:20:04 <ski> @let newtype Leaves' = MkLeaves' {unLeaves' :: forall a. PBBT a -> [a]}
13:20:06 <lambdabot>  Defined.
13:20:20 <boxscape> :t infTree = Double infTree
13:20:21 <lambdabot> error:
13:20:21 <lambdabot>     parse error on input ‘=’
13:20:21 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
13:20:29 <boxscape> :t Double infTree
13:20:30 <lambdabot> PBBT a
13:20:38 <boxscape> uhm no
13:20:42 <boxscape> :t \infTree -> Double infTree
13:20:43 <lambdabot> PBBT (a, a) -> PBBT a
13:20:44 <ski> @let leaves' :: forall a. PBBT a -> [a]; leaves' = unLeaves' (fix leave) where leave :: Leaves' -> Leaves'; leave (MkLeaves' leaves) = MkLeaves' (\case Elems x -> [x]; Double t -> concatMap (\(x0,x1) -> [x0,x1]) (leaves t))
13:20:46 <lambdabot>  Defined.
13:21:27 <ski> @let newtype InfTree'' = MkInfTree'' {unInfTree'' :: forall a. PBBT a}
13:21:29 <lambdabot>  Defined.
13:22:10 <ski> @let infTree'' :: forall a. PBBT a; infTree'' = fix inf where inf :: InfTree'' -> InfTree''; inf (MkInfTree'' infTree) = MkInfTree'' (Double infTree)
13:22:12 <lambdabot>  .L.hs:198:13: error:
13:22:12 <lambdabot>      • Couldn't match expected type ‘PBBT a’
13:22:12 <lambdabot>                    with actual type ‘InfTree''’
13:22:31 <ski> oh
13:22:39 <ski> @let infTree'' :: forall a. PBBT a; infTree'' = unInfTree'' (fix inf) where inf :: InfTree'' -> InfTree''; inf (MkInfTree'' infTree) = MkInfTree'' (Double infTree)
13:22:41 <lambdabot>  Defined.
13:26:26 * ski . o O ( <http://ars.userfriendly.org/cartoons/?id=19990926&mode=classic> )
13:27:26 * ski laments the lack of local type definitions ..
13:27:41 <boxscape> well there is a proposal at least
13:34:35 <ski> do you remember the link to it ?
13:37:43 <boxscape> ski https://github.com/treeowl/ghc-proposals/blob/local-types/proposals/0000-local-types.md
13:40:03 <ski> ty
13:43:24 * hackage cpkg 0.2.4.6 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.4.6 (vmchale)
13:43:39 <ski> "but their kind signatures may not mention local type variables" -- hm, that's the other thing i want them for, to avoid having to repeat a whole host of local tyvars
13:48:43 <boxscape> I wished I had a type-level let-expression a couple hours ago, for similar reasons
13:49:19 <ski> "the instance head of a locally defined instance must mention a local type declared in the same let or where" -- mm, i've thought the same
13:49:34 * ski nods
14:02:44 <WASD> I'm new to type level programming. Is it possible write a pattern match like "let [x,y] = [1,2]" that would not compile if the lists have different sizes?
14:05:38 <ski> if you use not ordinary lists, but length-indexed vectors, something like that would be possible
14:06:23 <WASD> so the vec library?
14:06:28 <[itchyjunk]> what happens if you let [x,y] = [1,2,3] then call [x,y] ?
14:06:51 <WASD> Exception: Non-exhaustive patterns
14:07:18 <[itchyjunk]> Hm, it would not compile right?
14:07:39 <[itchyjunk]> or is this technically considered using length indexed vector?
14:07:46 <[itchyjunk]> sorry if my questions dont make sense
14:08:21 <WASD> it does compile for ordinary lists
14:09:06 <[itchyjunk]> ah
14:11:41 <maerwald> oh boy, quasiquotes really increase build time a lot
14:14:51 <fragamus> what's the hip and happening http client to use
14:17:58 <maerwald> fragamus: https://hackage.haskell.org/package/http-io-streams
14:18:43 <maerwald> one of the few (or only?) that uses openssl bindings
14:19:19 <fragamus> ooh wreq looks nice
14:19:41 <WASD> I ended up doing a system call to wget because I found no lightweight library
14:19:56 <maerwald> WASD: did you check http-io-streams?
14:20:16 <WASD> no, I don't remember it. But that list of dependencies is not small
14:20:48 <WASD> I remember trying http-conduit but it made my project twice as big or something like that
14:29:28 <maerwald> Well, I don't mind the dependencies. I just don't want a web stack that's build on top of a tls implementation that has never seen an audit.
14:29:51 <sm[m]> fragamus: or req
14:57:34 <hugbubby_> how do I get the iotut
15:04:57 <day> what is the right syntax to do this in 'one line'? f <- readFile "file.txt"; let decData = decodeLatin1 f
15:05:43 <day> im thinking something along the line of (decodeLatin1 . readFile) "file.txt"; which ofc. doesnt work because readFile returns an 'IO ByteString' and not a 'ByteString'
15:06:31 <maerwald> >>=
15:06:41 <jle`> decData <- decodeLatin1 <$> readFile "file.txt"
15:06:41 <day> ah. i tried <<= :D
15:06:46 <boxscape> @undo do f <- readFile "file.txt"; let decData = decodeLatin1 f
15:06:46 <lambdabot> <unknown>.hs:1:58:Parse error: Last statement in a do-block must be an expression
15:06:56 <boxscape> @undo do f <- readFile "file.txt"; let decData = decodeLatin1 f; pure ()
15:06:56 <lambdabot> <unknown>.hs:1:67:Parse error: EOF
15:06:59 <jle`> it should be <$>, since you're applying a 'pure' function to the result
15:07:07 <hpc> (<=<) if you want to write something that looks like it uses (.)
15:07:22 <maerwald> he made it a let, so I assume he's doing something else with it afterwards
15:07:28 <day> ty. i go with <$> as ive encountered that one before ^.^
15:07:35 <day> yes
15:07:46 <jle`> doing do f <- readFIle "file.txt"; decData <- decodeLatin1; ..., then you would use =<<
15:07:56 <jle`> but if you use let decData = decodeLatin1 f, then would be <$>
15:08:32 <day> why would i use <- decodeLatin? i thought the <- is used for IO operations :|
15:08:39 <day> i memorized it as an 'IO' remover
15:09:42 <day>  the moment when #haskell shrieked in terror
15:09:48 <solonarv> this was a hypothetical alternative 'decodeLatin1' which returns something in IO ;)
15:10:03 <day> ah
15:11:11 <boxscape> day heh I kind of did internally
15:20:39 <jle`> ~>
15:20:56 <jle`> whoops, wrong window
15:21:13 <jle`> day: yeah, i meant that is how you would be able to tell if you use <$> vs. =<<
15:21:22 <jle`> day: <$> for things you might let later, and =<< for things you might <- later :)
15:22:22 <day> let decData = decodeLatin1 <$> BS.readFile "text.txt" <- this still comes out as "IO ..." :?
15:22:36 <Cale> day: Slightly better than "IO remover" would be to think of v <- x as meaning "execute the action x, and name whatever its result is v" -- well, also do-syntax works with any monad, not just IO, but that explanation generalises :)
15:23:45 <Cale> yes
15:24:12 <Cale> decData = ...  defines decData to be equal to whatever is on the right, which is an IO action.
15:24:15 <day> but how can that be. shouldnt everything that goes in and comes out od decodeLatin1 be 'pure'?
15:24:21 <Cale> So decData will be an IO action
15:24:36 <Cale> f <$> x = do v <- x; return (f v)
15:25:40 <Cale> So decodeLatin1 <$> BS.readFile "text.txt"  will be an action that first reads the file, and then applies decodeLatin1 to whatever the result of that is.
15:38:03 <jle`> day: decData <- decodeLatin1 <$> BS.readFile "text.txt"
15:49:24 * hackage libarchive 2.2.2.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.2.0 (vmchale)
15:57:05 <ski> @undo do f <- readFile "file.txt"; let {decData = decodeLatin1 f}; return ()
15:57:05 <lambdabot> readFile "file.txt" >>= \ f -> let { decData = decodeLatin1 f} in return ()
15:57:43 <ski> day : think of `decodeLatin1 <$> ...' more as "bringing the `decodeLatin1' inside the `IO'"
16:00:25 <Cale> Yeah, it transforms an IO action so that it applies the decodeLatin1 function to whatever its result would have been
16:00:35 * ski . o O ( "Mahomet cald the Hill to come to him. And when the Hill stood still, he was neuer a whit abashed, but said; If the Hill will not come to Mahomet, Mahomet wil go to the hil." <https://www.phrases.org.uk/meanings/if-the-mountain-will-not-come-to-muhammad.html> )
16:02:29 <ski> day : what're ya doing after the `let' ?
16:03:40 <day> the goal is csv file -> sanitization -> csv decode -> some more sanitization -> csv output 
16:04:31 <day> but now i realized cassava wants ByteStrings but i have a Text.Text D:
16:11:23 <ski> it's possible you could use `=<<' and `.' (and maybe `<=<' ?), in place of `<$>', depending on what comes after
16:11:51 <day> i need to read up on all these magic operators :P
16:12:15 <day> it's a wonder i managed to write a working piece of software without knowing any of them 
16:15:33 <Profpatsch> day: There’s just a few of them
16:16:09 <Profpatsch> >>=, <$> and (.) being the most-used ones in normal code I guess
16:18:32 <ski> @src (=<<)
16:18:32 <lambdabot> f =<< x = x >>= f
16:18:48 <ski> also
16:19:21 <ski>   f <=< g = g >=> f
16:19:42 <ski>   (g >=> f) x = g x >>= f
16:20:16 <day> i mean. i managed to write a working supermemo flashcard learningtool with only one <$> :D https://pastebin.com/iEAjw6RH
17:00:17 <ski> day : the type ascriptions in `decodeCard' are redundant. (also the brackets around `Show' in the `deriving' clause, around calls to `fromIntegral',`c_front',`c_back', in `(c_reviews c) + 1',`c_dueDate c /= (-1)',`c_dueDate c == (-1)',`c_dueDate  = (-1)', around the cons in `(x,z,(y:ys))' and `((x:xs),y,z)', i'd write `(show $ c_eFactor x)' as `show (c_eFactor x)' (ditto for next three lines))
17:00:53 <Alex61> Hello All, I'm new to this and I have a question. I had two functions like (a -> Int), (a -> Int) and I wanted a function that would apply them both to the same argument and add the result. I made a semigroup instance for functions like this and everything, and then noticed I could just do (+) <$> func1 <*> func2. Only thing is I have no idea how
17:00:54 <Alex61> to figure out what instance of applicative I'm using when I do this 
17:01:35 <Alex61> I don;t think it's (->) but not sure what else it'd be. and anyways I'd like to know how to get ghci to tell me that
17:01:38 <Alex61> thanks for any help
17:02:34 <shachaf> It's (r ->)
17:03:07 <shachaf> You can figure it out by just unifying the types, which you probably did.
17:03:15 <Alex61> err is that -> applied to one type?
17:03:21 <ski> day : is there a point to doing `read' right after `show' ? also, in case the reading fails, perhaps you'd like to give `Nothing' ? you could say `case decodeCard x of' directly. do you want to stop as soon as you get `Nothing' ? or rather, maybe, abort (so not outputting the previous `Just'ed results) ?
17:03:54 <ski> yes, Alex61
17:04:35 <ski> `(rho ->) a' (by which we mean `(->) rho a') is `rho -> a'
17:05:17 <Alex61> ah so that's why you write it on the left 
17:05:18 <Alex61> thx
17:05:25 <Guest_53> Hey everyone, 
17:06:23 <Guest_53> I am trying to uninstall haskell, I found this https://gist.github.com/gatlin/3862648 but I have also noticed that if I do ghcup rm 8.6(..) it removes some folders that are not listed with that link. Is there a proper way to remove haskell from a Mac OS system?
17:07:23 <Guest_53> I have installed haskell a few months back using https://www.haskell.org/ghcup/
17:07:43 <maerwald> ~/.ghcup ~/.ghc and ~/.cabal should do
17:15:05 * dmj` mutters something about nix
17:19:35 <maerwald> how to remove nix?
17:36:01 <ski> day : the special cases in `interval' could be done with pattern-matching, like `interval 0 _ _  = 1'. in `updateCard' you can use "record update" syntax. instead of `Card {...}' write `c {...}', then you can skip specifying the fields from `c' that you just copy over. perhaps you can do `splitDeck' with `partition' ? `getInt' is not a function, but an action. the type ascription on `readMaybe' is also redundant
17:38:38 <ski> day : i'd like to factor out the repeated `ord'. adjacent `let' commands in `do' can be replaced with a single `let', having multiple bindings (aligned). instead of writing `foo $ bar $ baz $ x', i'd suggest writing `foo . bar . baz $ x' (or even `(foo . bar . baz) x')
17:46:53 <dmj`> maerwald: hah
18:45:12 <taylskid> I am looking at a an app example that has an excerpt like `data Env (m :: Type -> Type) = Env {..}`. I know that you need `KindSignatures` but I can't figure out what you need for `Type`
18:52:29 <lyxia> import Data.Kind (Type)
18:55:31 <taylskid> lyxia (IRC): okay thanks. That's no where in this example app so I was confused/wondering if it was comfing from somewhere else
19:23:23 * hackage arduino-copilot 1.5.1 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.5.1 (JoeyHess)
19:26:46 <Flonk> Free Monoid = List. Free X = Tree, solve for X. Is there a notion of that?
19:27:40 <koz_> Flonk: What do you mean by 'Tree' here? Like, a rose tree, a binary tree, some other kind?
19:28:20 <Flonk> I guess in general any recursive(?) datastructure but sure, lets go for binary trees
19:28:29 <shachaf> Sure, depending on what kind of tree you have.
19:28:55 <shachaf> If you just remove the equations from a monoid and you'll get a kind of tree.
19:29:28 <Flonk> Wait what equation
19:35:32 <Flonk> I guess a function `(a, a) -> a -> (a, a)` gives a "fanning out" behaviour if I apply it over and over
19:35:55 <Flonk> no.
19:36:52 <Flonk> a -> a -> (a, a)
19:39:10 <Flonk> and a -> a -> [a] yields rose trees
19:39:35 <Flonk> cool.
19:41:03 <Flonk> and a -> a -> F a probably does all sorts of crazy stuff.
19:44:43 <Flonk> Well I'm content. Back to sleep, I woke up at 4am to ask that
19:48:30 <shachaf> Flonk: The laws, if you prefer.
19:48:50 <shachaf> You get a free thing in universal algebra by generating all the possible expressions and quotienting by the laws.
19:49:02 <shachaf> Or what do you mean when you say "free"?
19:50:43 <shachaf> mappend is already "tree-like", because you have (a <> b) <> (c <> d) and so on.
19:51:04 <shachaf> The monoid laws require that to be equal to a <> (b <> (c <> d)), which flattens it out.
19:51:25 <Flonk> humm the free Monoid is maximal or initial or whatever in the sense that there exists a something from it to any other monoid of the same type
19:51:53 <Flonk> Oh that does make sense, so removing associativity gives the tree type!
19:56:35 <Flonk> So I was thinking, Trees (being a Free X), are initial in the sense that there exists a morphism between it and any other X 
19:57:04 <Flonk> but what is X.
19:57:57 <Flonk> But I suppose you just answered that
19:58:21 <lyxia> Binary trees are free magmas.
19:58:52 <Flonk> awesome.
20:00:39 * dmwit jots down "Binary trees are free magmas." in his little black book of facts
20:03:53 * MarcelineVQ scribes the sigil of blood and summons the pedestal the book rests on when not collecting arcane knowlege.
20:11:27 <koz_> So what is X in 'Free X = rose tree'?
20:14:16 <Flonk> Must be some set with an operation [a] -> a that is non-associative, right?
20:23:49 <Flonk> and a free commutative monoid is a multiset! (a list but order does not matter)
20:46:36 <shachaf> You can just write down the constructors of your type if there are no laws, and make some kind of free thing based on that.
20:46:49 <shachaf> Recognizing that a thing is free can be more useful.
21:07:24 * hackage fakedata 0.6.1 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.6.1 (psibi)
21:13:56 <shachaf> For example the strictly positive naturals are the free commutative monoid generated by the primes. That's a useful fact about arithmetic.
21:14:39 <iqubic> What does that even mean?
21:15:09 <iqubic> Is that just saying that every positive natural has a unique prime factorization?
21:23:05 <Flonk> I guess every natural number can be represented as a multiset containing its prime factors, that checks out.
21:33:24 * hackage hkgr 0.2.5 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.5 (JensPetersen)
21:42:43 <hugbubby> Can someone explain to me why my function is infinitely looping and not evaluating lazily?
21:43:53 <hugbubby>  $ maximumBy (\(x, y) (x2, y2) -> if y > y2 then GT else if y2 == y then EQ else LT) (zip cGrid childrenPosterior)
21:43:56 <hugbubby>   146
21:43:57 <hugbubby> srry
21:44:12 <hugbubby> https://pastebin.com/raw/bRGnDYZv
21:44:35 <hugbubby> Ignore the above; my expectation is for it to print the first "sampled" value and exit, but it keeps running 
21:49:29 <MarcelineVQ> if  rand_dub is never < prob then there's we never produce a result
21:51:23 <MarcelineVQ> and your 'then' case is recursive on the same arguments it started with, so one failure at the start is enough to never produce anything
21:51:35 <MarcelineVQ> *else case
21:51:48 <MarcelineVQ> sample' seed xs = if ... then ... else sample' seed xs
21:55:47 <hugbubby> I see, I need to generate new random numbers each time
21:56:07 <hugbubby> forgot about that
22:20:40 <hugbubby> Does haskell ever "optimize" these linked lists by representing it all as a contiguous chunk of memory or does it actually have pointers for every one of these items
22:29:25 <heatsink> Each list item is a separate object.  To store items contiguously, use Vector
22:32:24 * hackage hkgr 0.2.5.1 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.5.1 (JensPetersen)
22:49:50 <pdxleif> There was a cabal command to launch a repl with a given package as an in-scope dep, e.g. `cabal repl --with-dep=lens`, but I can't seem to find it, now.
22:50:38 <MarcelineVQ> -b
22:53:41 <pdxleif> Hey, that works, thanks! I seem to remember using a long-form variant of that command, but that's easier.
23:08:07 <pdxleif> Curious that you can get a dhall-to-yaml-ng exe from the dhall-yaml package, and a dhall-to-yaml exe from the dhall-json package.
23:58:18 <jsomedon> what does it mean that a function is polymorphic? for example "`compose` is polymorphic, so whether `(g x)` in `compose f g x = f (g x)` is a function or data is not statically determinded" 
23:58:58 <c_wraith> at the simplest, a function is polymorphic if its type has type variables in it.
23:59:36 <c_wraith> It means the function can be used as different concrete types.
23:59:55 <c_wraith> However, that example doesn't make sense.
