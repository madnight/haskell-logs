00:08:52 <int-e> remexre: Hmm, so there's an actual problem with that (the Foo x y constraint doesn't help), but also a shortcoming of ghc -- it doesn't know that if you know x and 1 + x + y, then that determines y uniquely.
00:10:43 <remexre> int-e: is there some solver plugin for this? I have KnownNat, Extra, and Normalise, but they aren't sufficient
00:12:46 <int-e> remexre: I've changed the type signature of lift to  lift :: forall f x y. (KnownNat y, Foo f x y) => FreeFoo x (1 + x + y) -> Bar f x (1 + x + y)  and that type-checks, but ideally the  KnownNat y  constraint shouldn't be required.   And sorry, but I don't know anything about plugins for this (except that they exist).
00:15:20 <remexre> int-e: Hm, I'll try that, I think that ought to be sufficient; thanks
01:34:53 * hackage jsonpath 0.2.0.0 - Library to parse and execute JSONPath  https://hackage.haskell.org/package/jsonpath-0.2.0.0 (axeman)
01:44:54 * hackage cursor 0.3.0.0 - Purely Functional Cursors  https://hackage.haskell.org/package/cursor-0.3.0.0 (Norfair)
01:45:54 * hackage cursor-gen 0.3.0.0 - Generators for Purely Functional Cursors  https://hackage.haskell.org/package/cursor-gen-0.3.0.0 (Norfair)
01:49:54 * hackage hoogle 5.0.17.15 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.15 (NeilMitchell)
02:17:30 <charms> Hi does anyone know any algorithms for implementing factorisation in quadratic integer rings that are also unique factorisation domains?
02:17:56 <charms> so e.g. gaussian integers, eisenstein integers etc but mostly interested in the other ones
02:22:53 <__monty__> charms: Maybe ask in #numerical-haskell too.
02:23:09 <charms> thank you monty, will do
04:45:04 <muesli4> Hi, I'm looking for a library for events because I want to avoid callback hell in GUI programming. Basically, what I need is: a thread-safe way to send input events, an event handler thread that handles input events/mutates state/produces output events, the ability to dynamically add new event senders (input to model) and/or receivers (output from model)
04:47:05 <muesli4> Could be that some FRP library provides this but I don't know a lot (aside from the concepts).
04:47:46 <ysangkok> you can do it with reflex, it has tutorials available
04:48:41 <merijn> muesli4: You could use an FRP library, but depending on what you're writing that may not be worth the effort
04:49:17 <merijn> muesli4: Because it sounds like your problems could also just work with "a few threads and a channel for communication" or STM :)
04:49:40 <muesli4> merijn: Yes, maybe that would be good enough.
04:51:28 <merijn> muesli4: There's a huge number of different channel types around for threadsafe communication (Control.Concurrent.Chan, various Control.Concurrent.STM channels) I wrote my own channel type for use with dynamically spawned event listeners too
04:51:37 <muesli4> merijn: Actually I was using the mvc library by Gabriel Gonzalez. I think it uses STM for exactly this purpose.
04:51:42 <merijn> muesli4: There's also the async library for spawning concurrent jobs
05:00:12 <Netsu> hello. What could be considered as a current, modern enough, suggested common way to derive Aeson instances of regular records, constrained by custom field labels if necessary (e.g. id, type, etc)? I guess, it should use generic and overloaded labels, any such library/example available?
05:08:18 <merijn> Netsu: I think the usual approach is to just define them by hand if you have restrictions like that
05:12:17 <Netsu> merijn: sounds not fine to me. Even in OCaml I can mark records in "ppx" to force deriving in preffered way.
05:15:09 <Netsu> maybe, generics-sop could be useful as intermediate representation, not sure...
05:18:05 <Netsu> like deriving via (custom SOP representation). But not sure would such labels be considered as nominal index of datatype, not representational one? 
05:19:11 <Netsu> *to let deriving prove that representation is the same
05:19:39 <Netsu> could it work?
05:28:12 <Netsu> Oh, I see the TH solution (deriveJSON (defaultOptions ...), but that don't look such clean, as with generics
05:32:31 <tomjaguarpaw> Does anyone know how I can ask Hedgehog to run more than 100 of each test?
06:43:22 <kosmikus> Netsu: I think using deriving-via / generics-sop should work (and I've been using it for some purposes like this). But it depends on what you need exactly, and I'm not aware of any library that offers this out of the box.
06:50:17 <Netsu> kosmikus: thanks. Just curious, could record fields renaming be more convenient for generic instances (like Aeson ones) derivation. 
06:51:32 <Netsu> maybe "type surgery" could help here. Didn't use derivingVia yet, so not sure about limitations.
06:56:27 <Netsu> there's should be type constructor for such deriving strategy that accept type list of Symbol pairs to rename, I guess
06:57:31 <Netsu> *and target type, for sure
07:16:02 <dbqp> hello guys
07:16:07 <dbqp> doing a haskell course at uni
07:16:12 <dbqp> the book is hutton
07:16:19 <dbqp> any opinions before I dive in?
07:17:48 <sm[m]> good book
07:17:59 <dminuoso> dbqp: Practice, practice, practice.
07:18:55 <comerijn> dbqp: Forget everything you know about programming :)
07:19:02 <comerijn> At least for the start :p
07:19:38 <[exa]> hm, is there some good shortcut function for checking the result of a monadic action and throwing a specified exception if it's wrong?
07:20:07 <dminuoso> [exa]: whenM
07:20:22 <[exa]> e.g. (very roughly): check (=="test") (SomeException "aaaa") $ read4bytes
07:21:44 <dminuoso> [exa]: Honestly I'd just use bind and when
07:22:11 <dminuoso> do { r <- a; when (p r) err; ... }
07:22:15 <[exa]> hm looking at that the second time it really is whenM, except I was too lazy to write 'throw' to the last argument
07:22:19 <[exa]> ok thanks
07:23:17 <dminuoso> [exa]: Or, this is what I actually do right now, you can write `(<*=) :: Monad m => m a -> (a -> m b) -> m a`
07:23:45 <dminuoso> [exa]: And then have some `assertFoo :: a -> M T`
07:24:41 <dminuoso> So you could have `let assertIsTest t = when (t == "text") (throwIO (SomeException "aaa")) in read4bytes <*= assertIsTest`
07:25:57 <dminuoso> Or maybe use it as: `do r <- read4bytes <*= assertIsTest`, perhaps even `let read4bytesCheck in read4bytes <*= assertIsTest in do { r <- read4bytesCheck; ... }`
07:27:07 <[exa]> the left pointer looks great thb
07:27:16 <[exa]> *tbh
07:28:16 <charms> in haskell, is there a speed advantage to use features like type families instead of if statements where possible or does the compiler not optimise it (GHC)?
07:28:47 <dminuoso> charms: Hold on, how would you use a type family in place of if?..
07:29:03 <dminuoso> charms: Also, we dont have statements, they are expressions. :)
07:30:55 <charms> dminuoso say we have { a + b sqrt(d) : a,b in Z} for some d which is a ring. we may show this differently depending on the discriminant
07:31:36 <dminuoso> charms: I dont understand that pseudocode
07:31:42 <Uniaika> charms: https://www.vidarholen.net/contents/blog/?p=859
07:32:10 <Uniaika> The shellcheck guy noticed a 10% performance overhead when translating explicit argument passing to a ReaderT
07:32:23 <Uniaika> I do not know if it's a generality though
07:32:43 <dminuoso> Uniaika: im confident you read it wrong
07:32:54 <dminuoso> Uniaika: ReaderT is, if anything, slower.
07:33:56 <Uniaika> dminuoso: yeah that's what I said
07:34:02 <Uniaika> performance overhead
07:34:03 <charms> ahh so it is faster to not pass parameter arguments
07:34:22 <Uniaika> no, it's faster to pass explicit arguments ;)
07:34:25 <Uniaika> ReaderT is slower
07:35:23 <charms> that's so bizarre. i would have thought in some cases there is no comparison checking when not passing explicit arguments
07:36:08 <geekosaur> it's still being passed, just behind the scenes. that behind the scenes has overhead
07:36:15 <Uniaika> yep
07:36:33 <geekosaur> and it's passed when it doesn't need to be, whereas when being explicit you can just leave it out where you don't need it
07:36:51 <geekosaur> flip side you don't have to rewrite if you decide you do need it later
07:37:53 <geekosaur> it's a tradeoff, convenience vs. overhead, in multiple ways. some of writing haskell is judging when it's appropriate to make that tradeoff
07:38:08 <charms> ahh i meant that if you parametrise based on type, I expected in some cases the compiler does the behind the scenes comparison though I guess this doesn't happen
07:38:32 <dminuoso> charms: Can you elaborate more on that?
07:38:41 <dminuoso> charms: I honestly dont understand what you are asking about.
07:38:53 <charms> okay one minute
07:46:53 * hackage geodetics 0.1.2 - Terrestrial coordinate systems and geodetic calculations.  https://hackage.haskell.org/package/geodetics-0.1.2 (PaulJohnson)
07:54:23 * hackage joint 0.1.6 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.6 (iokasimovmt)
08:39:03 <tomjaguarpaw> Whoever implemented the links in the Haddock source view is a true friend to humanity
08:39:21 <maerwald> geekosaur: ReaderT is the most unnecessary of all though
08:39:53 <maerwald> What I'm more curious about is... whether it gives performance penalty when you already have a transformer, like ExceptT
08:40:36 <maerwald> like, do you pay the price once?
08:46:33 <charms> dminuoso i can't get it to compile i'll come back in a week or 3
09:10:11 <zincy_> If you have two kinds of `User` product types say `UserAdmin` and `UserClient`, each defined in their own module. Am I right in saying its a bad practice to then define a newtype wrapper for a field in each of these modules with the same name, `UserId`?
09:11:01 <zincy_> I mean what reason could there be for not having both a AdminUserId and a ClientUserId
09:11:07 <tomjaguarpaw> In Hedgehog, if I did `do { n <- Range.int r; list (Range.singleton n) element }` instead of `list r element` what would I be missing out on?  The former is much more natural to me.
09:11:57 <tomjaguarpaw> (modulo the Range.singleton)
09:41:06 <johnjay> is one of the principles of functional programming to not change a variable once it is set?
09:42:20 <zincy_> johnjay: Yes it is called immutability
09:43:55 <johnjay> ok. i'd heard about the only using parameters and return values thing.
09:44:16 <johnjay> but like, how would you write a loop like (for i=0; i<n; i++) without mutability?
09:44:22 <dbqp> you don't 
09:44:23 <dbqp> lol
09:44:48 <dbqp> use recursion
09:45:15 <johnjay> so every loop would change to some kind of accumulator thing?
09:46:12 <dbqp> well, say you want to add elements of a list [1,2,3,4,5], instead of looping and changing a variable "sum" that keeps adding ...
09:46:12 <glguy> for_ [0 .. n-1] (\i -> ...)
09:46:40 <dbqp> rather say (1 + (2 + (3 + (4 + 5))))
09:46:50 <dbqp> forgot + 0 but ya
09:47:40 <johnjay> so for(i=0;i<5;i++) becomes f(0) which does a computation and returns f(1) etc up to f(5)?
09:49:17 <WilliamHamilton> is anyone using a tool to build a function call graph of a (fairly large) codebase?
09:49:21 <dbqp> that loop construct doesnt exist in FP johnjay
09:49:29 <dbqp> forget everything you know
09:49:33 <dbqp> start from scratch
09:49:36 <dbqp> learn recursion
09:49:41 <johnjay> i just gave an example of recursion
09:49:57 <WilliamHamilton> googling I found `SourceGraph` but I can't tell if it's maintained
09:50:22 <dbqp> yeah so then I guess ya sort of
09:51:12 <dbqp> but rather give a concrete example
09:51:54 <dbqp> look at factorial in haskell vs java or c
09:51:59 <dbqp> and then look at fibonnaci
09:52:03 <dbqp> its a little more interesting
09:55:47 <monochrom> @quote monochrom fibonacci
09:55:48 <lambdabot> monochrom says: the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
10:30:53 * hackage icepeak 0.7.1.0 - A fast JSON document store with push notification support.  https://hackage.haskell.org/package/icepeak-0.7.1.0 (rkrzr)
10:50:58 <mlugg> Hey, are there any unofficial Cabal APT repos / deb files? (Since the repos at http://downloads.haskell.org/debian/ aren't yet available for Debian) And if not, what's the best way to get Cabal 3 working on Debian?
10:51:11 <mlugg> available for Debian Buster*
11:12:42 <hshabbi> \quit
11:14:01 <zincy_> dbqp: I think you technically can but you really shouldn't
11:14:10 <zincy_> I mean you access pointers in Haskell right
11:14:44 <dbqp> zincy_: I should have put a disclaimer, I only started doing haskell tutorials recently
11:14:51 <dbqp> So it was one noob helping another there
11:14:54 <dbqp> I don't really know
11:14:56 <dbqp> ;)
11:15:15 <dbqp> but good to know you can access pointers
11:15:43 <dbqp> I've done C++ pointers, know all about pointers :P
11:16:44 <heatsink> The only reason to use pointers is interacting with C or C++ code
11:18:23 * hackage dobutok 0.1.0.0 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutok-0.1.0.0 (OleksandrZhabenko)
11:20:24 * hackage dobutok 0.1.0.1 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutok-0.1.0.1 (OleksandrZhabenko)
11:30:53 * hackage dobutok 0.1.0.2 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutok-0.1.0.2 (OleksandrZhabenko)
11:36:54 * hackage dobutokO 0.1.0.0 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutokO-0.1.0.0 (OleksandrZhabenko)
11:39:11 <prog13> dbqp: are you using the FFI?
11:40:53 <prog13> mlugg: did you try: nix-env --install cabal-install ?
11:41:02 <dbqp> prog13, nope
11:41:07 <dbqp> prog13, I'm a beginner
11:41:21 <prog13> how are you accessing C pointers then?
11:41:35 <prog13> isnt that basically unparadigmatic haskell?
11:41:38 <dbqp> I'm not
11:41:45 <dbqp> I was just saying that I know what pointers are 
11:41:48 <dbqp> coz I know C++
11:41:50 <mlugg> prog13 I'm on Debian, not NixOS
11:41:52 <dbqp> was just a side joke
11:42:37 <prog13> mlugg: I think you can install nix and get cabal that way, otherwise maybe stack has a clean way to get cabal3
11:43:53 <prog13> the steps to get nix using curl here should work, though they were originally for ubuntu on LSW https://github.com/astk-hs/hello-nix
11:44:21 <monochrom> side joke for a side effect? >:)
11:45:23 * hackage protobuf 0.2.1.3 - Google Protocol Buffers via GHC.Generics  https://hackage.haskell.org/package/protobuf-0.2.1.3 (YorickLaupa)
11:46:51 <prog13> I want to implement a "mixture of experts net"
11:47:57 <prog13> here, instead of having a pdf being sampled to choose actions to interact with some system, instead many "experts" are chosen from, which can use the API provided
11:49:16 <prog13> the idea is then to stochastically update the weighting of the experts, as assigned as implementation of a "decision system", with metropolis hastings accept/reject for benificial updates to these weights
11:50:26 <prog13> hopefully, by making this a deep network, choosing between nested mixtures of experts as individual experts, that a learning process can be generated regardless of the actual models being updated at the leafs
11:53:18 <jonathan_> I'm using https://hackage.haskell.org/package/hspec-wai-0.10.1/docs/Test-Hspec-Wai.html to test a stateful app, using the "with" function (with :: IO Application -> SpecWith ((), Application) -> Spec)
11:53:21 <prog13> the idea is that these weights are more natural parameters to update than the internal working of the leaf systems, which might not train well under stochastic update
11:53:39 <jonathan_> I want to always do a cleanup after the tests are done, which works fine when they succeed
11:53:51 <jonathan_> when they fail, however, the code is short circuited
11:54:12 <jonathan_> I'm struggling to find a way to solve this (i.e. always do the cleanup)
11:54:35 <jonathan_> I assume the root problem is some kind of exception, but how do I catch it in this case?
11:55:03 <prog13> isnt the garbage collection going to take place as long as there are no let bound variables being refered to that store these values?
11:55:14 <jonathan_> (headed to bed after long time of searching, will look at answers/reply tomorrow)
11:55:43 <d34df00d> Is there a ready-made type family for unboxable values? I want smth like Unboxed Int = I#, Unboxed Word = W#, and so on.
11:55:57 <d34df00d> Plus maybe a corresponding function to unbox/box values.
11:56:03 <geekosaur> doesn't Vector have Unbox ?
11:56:20 <d34df00d> Good idea!
11:57:37 <d34df00d> Although it seems like it doesn't give all the stuff I need (in particular, the underlying representation).
11:58:14 <prog13> you mean as a class?
11:58:43 <prog13> so you can implement it yourself, or at least, plum the interface to the conversion into this common API
12:01:04 <juri_> wheee. I'm going to pull the lulzbot taz logo off of my 3d printer, and replace it with a haskell logo. it's earned it.
12:01:36 * juri_ now has a haskell based 3d modeler, AND a haskell based slicer!
12:02:04 <prog13> what 3d modeling haskell program is this!/
12:02:07 <prog13> ?
12:02:40 <juri_> prog13: ImplicitCAD. I'm getting first-prints out of my slicer, HSlice.
12:04:07 <prog13> does it do ray tracing with occlusion?
12:06:32 <prog13> oh right, its just a 2d slice viewed using JuicyPixels? 
12:07:24 <juri_> prog13: it's a raytrace, with stl output.
12:08:08 <juri_> I make things with it. printer parts, mostly.
12:08:21 <juri_> I am studying the fixed point of 3d printer.
12:09:31 <d34df00d> So let's say I'm trying to write a type class that defines an associated type of the unboxed kind corresponding to this class. In other words, I want something like:
12:10:00 <d34df00d> class Unboxable a where type ArgRep a :: RuntimeRep ; type UnboxedType a :: TYPE (ArgRep a)
12:10:03 <d34df00d> How do I do this properly?
12:10:23 <d34df00d> The above gives me error     • Type constructor ‘ArgRep’ cannot be used here (it is defined and used in the same recursive group)
12:11:08 <prog13> juri_ : i cant see where is the stl dependency?
12:11:34 <juri_> prog13: it doesn't use an STL library.
12:12:55 <prog13> can you point to where the ray tracing is taking place?
12:13:47 <hseg> Why is i ambiguous in http://ix.io/2bOz ?
12:14:01 <hseg> ... unless "ambiguous" in this context means "cannot be inferred from the context in which the class methods are called"?
12:14:21 <hseg> a la having a class method not mention a parameter
12:14:29 <prog13> can you use pastebin instead hseg? that link throws an error on chrome
12:14:40 <hseg> that is a pastebin
12:15:06 <hseg> what error are you getting? opens fine here on a chrome-based browser
12:15:20 <prog13> no i mean literally, pastebin.org, its like at the top of this irc page as the favored paste site 
12:15:38 <hseg> :( dislike pastebin.org. too heavyweight
12:15:41 <hseg> will gist it
12:15:51 <prog13> oh, well, it used to be, now they advocate gist.github.com
12:16:22 <juri_> prog13: for STL generation, we're actually using marching cubes instead. see: https://github.com/colah/ImplicitCAD/blob/master/Graphics/Implicit/Export/Render.hs
12:16:26 <prog13> hseg: pastebin has an option to link raw text which is quite readable
12:16:52 <hseg> https://gist.github.com/89892c6be54f3ae48e371466a60e621b better? added context
12:17:05 <hseg> ambiguity errors are in Class.hs
12:17:24 <prog13> juri_: wow, nice!
12:17:38 <d34df00d> Ah I see, https://gitlab.haskell.org/ghc/ghc/issues/12612
12:17:57 <hseg> prog13: still don't like pastebin.com
12:17:59 <prog13> i was trying to do delauny triangulation on the 2d boundary to the 3d object 
12:18:50 <juri_> prog13: just steal our engine. it's fine. :)
12:19:49 <prog13> yeah, it seems awesome, just, needs plenty of reading to understand how to use it...
12:20:07 <juri_> ImplicitCAD contains a SCAD engine, which i've been working hard on seperating from the rest of it... to the point that i re-used it in my slicer, to parse command line options.
12:20:53 <hseg> btw, what i'm *trying* to do is abstract over the common shape of Prelude's { numerator, denominator :: Ratio a -> a; (%) :: Integral a => a -> a -> Ratio a } and algebra's { numerator, denominator :: Fraction a -> a; (%) :: GCDDomain a => a -> a -> Fraction a }
12:20:58 <juri_> so now when you pass key=value stuff on the command line to the slicer, it's actually key=expression... and has SCAD types.
12:21:37 <prog13> hseg: is it the Fraction class? seems ambiguous through its mention of `f' and `r'
12:21:42 <hseg> yep
12:21:54 <prog13> cant you just use AllowAmbiguousTypes and ImplicitParams?
12:21:58 <hseg> the f and r are red herrings
12:22:05 <hseg> ... sure, could do that
12:23:00 <prog13> juri_: right, i can see mention of OpenSCAD: https://hackage.haskell.org/package/implicit-0.3.0.1/docs/Graphics-Implicit-ExtOpenScad.html
12:23:23 <prog13> hseg: are you sure the class needs to mention these ambiguous variables?
12:23:32 <hseg> ?
12:23:53 <hseg> btw, note the use of Backpack here -- i'm not planning on using Fraction from Class.hs as-is
12:24:09 <juri_> prog13: my documentation is a MESS. I should apologise profusely for that.
12:25:20 <hseg> but afaict Backpack can't express "this module exports F :: * -> *, I :: * -> Constraint, class Fraction { n, d :: F a -> a; (%) :: I a => a -> a -> F a }"
12:25:35 <juri_> I got implicitCAD 'good enough' and have started on a slicer. when it's good enough, i may start on a gcode interpreter...
12:25:44 <juri_> Haskell all of the things.
12:26:33 <hseg> (this is besides the point that Backpack, by piggybacking on the .hs-boot format, is incapable of expressing "this module exports a class with these members")
12:27:06 <prog13> whats gcode for? its commonly used for CAD specs?
12:27:19 <hseg> (note that trying to do it will force you to define the class in all implementations)
12:27:46 <prog13> right, classes and backpack seems redundant
12:27:50 <juri_> prog13: for 3d printing. I'm slowly working my way down the stack. first scad->stl, then stl->gcode, then gcode->motors_moving.
12:28:10 <hseg> not really. classes have better ergonomics
12:28:19 <hseg> similar tools, different use-cases
12:28:38 <prog13> but why make signatures containing classes that would be redefined by instances!?
12:28:57 <hseg> ?
12:29:26 <prog13> seems like backbacked modules naturally should not contain classes, as they are almost an alternative to them
12:30:02 <hseg> well, take my usecase for example. want to parametrize over numeric hierarchies
12:30:21 <prog13> either you implement a class with an instance, you you implement a signature with a module, how does it make sense to have a signature contain a class!?
12:30:24 <hseg> so that my code can use Prelude's classes as well as ekmett's algebra, and possibly numhask
12:31:31 <hseg> again, similar tools, differing details. class instance is inferred, is globally unique, is infectious. modules are explicit, multiple instances can be juggled
12:32:00 <hseg> so you see that various parts might be better modeled with one or the other
12:32:23 * hackage squeather 0.2.0.0 - Use databases with the version 3 series of the SQLite C library  https://hackage.haskell.org/package/squeather-0.2.0.0 (OmariNorman)
12:32:26 <prog13> yeah, i get the case for backpack vs classes, just not for signatures containing classes
12:35:44 <hseg> basically the => vs -> design question
12:36:01 <hseg> i.e. do you define your function as :: C => b or :: a -> b
12:36:08 <hseg> where C has a member :: a
12:36:29 <hseg> sometimes you want a mix
12:38:08 <prog13> it seems like a class should be made of functions types, and not left to be defined, only to be instantiated. backpack signatures and classes seem like orthogonal interfaces and I cant understad how you seem to state that "sometimes you want a mix"
12:39:00 <prog13> ie, you want to be able to say "C has a member :: a" which you cant if its left abstract in a signature
12:39:47 <prog13> so it seems like the classes should not go into signatures, so you can be sure of what the types and names are of the values they bring into scope
12:41:52 <hseg> re mixing, see the other classes there -- i'm abstracting eg over the choice of Prelude.Num vs algebra.Ring
12:42:24 <hseg> but yeah, you're right in that the mechanisms are mostly orthogonal
12:42:44 <hseg> still can be used together though
12:43:43 <hseg> more fundamentally, though, i think my problem is that a type _ -> Constraint is only implementable as a class taking _ as a parameter, not as a function returning a class
12:43:48 <hseg> whatever that would even mean
12:56:47 <hseg> ugh. could desugar the setup as a data Fraction e i = Fraction {..} and have the signature export some triple (E,I, _ :: Fraction E I), but that's gonna be a pain to work with
12:58:46 <hseg> ... hrm. or I could just give up on the class. lemme see what kind of an impact that has
12:59:26 <hseg> lightweight enough, cutting
13:01:51 <hseg> only annoyance is that i'll need to move some utilities to a module depending on the signature in order to be able to depend on the terms the signature defines
13:05:23 * hackage dobutokO 0.1.0.1 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutokO-0.1.0.1 (OleksandrZhabenko)
13:10:23 * hackage dobutokO 0.1.0.2 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutokO-0.1.0.2 (OleksandrZhabenko)
13:12:11 <tabaqui2> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#map
13:12:52 <tabaqui2> why `map` function here is not a tail recursive?
13:12:53 <tabaqui2> ^
13:13:08 <tabaqui2> (sorry for the word order)
13:14:00 <monochrom> What would "tail recursion" buy you?  Don't just recite the party line.
13:14:07 <tabaqui2> is it even possible to write tail recursive map?
13:14:24 <monochrom> Yes for quadratic blowup.
13:14:51 <glguy> You could do it with a reversed accumulator and then an extra reverse pass at the end
13:14:58 <tabaqui2> % :t deepseq
13:14:59 <yahb> tabaqui2: ; <interactive>:1:1: error: Variable not in scope: deepseq
13:15:09 <glguy> It would be worse, but you could do it
13:15:13 <monochrom> Actually infinite-time blowup too if the input list is infinite.
13:15:37 <monochrom> Exercise: Implement map such that "take 1 (map id (repeat 0))" takes finite time.
13:15:40 <hseg> and much worse strictness semantics
13:15:52 <monochrom> And you will learn that "tail recursion" is a pessimization.
13:16:06 <monochrom> So much for conventional wisdom.
13:16:50 <tabaqui2> ok, can you explain, please, why "deepseq (map succ [1..100000000]) 1" doesn't cause stack overflow?
13:17:34 <monochrom> I should put that on my term test.
13:17:37 <hseg> not sure whether this is even a good idea, or whether i'll need it, but does Backpack have a way of saying "the module exports type constructor F :: * -> * and types Q,Z such that we have the equality Q ~ F Z"?
13:18:14 <monochrom> No, explain why you thought it would.
13:18:31 <monochrom> Discover that you were not using lazy evaluation.
13:18:31 <hseg> ... suppose I could export a term :: Q :~: F Z
13:19:51 <hseg> and then have clients use gcastWith
13:20:38 <tabaqui2> monochrom: because I'm too tired or stupid for today :) I forget that we don't evaluate "regular" value but lazy structure
13:20:53 <tabaqui2> so it doesn't require knowing the whole list to return first elements
13:23:50 <roconnor> IIRC in lazy languages you push a stack frame when entering a case expression and exit when you hit a constructor.
13:38:59 <Ste1891> Hi.  I'm trying to compile a project with GHC profiling enabled and have run into a problem at the linker stage.  I've posted this on Stackoverflow, which explains it in more detail: https://stackoverflow.com/questions/60241805/ghc-linker-cannot-find-lhssemigroups.
13:39:04 <Ste1891> If anyone has an idea how this might be fixed help would be appreciated.
13:41:14 <glguy> Ste1891: you're using the legacy build system due to having an old cabal executable. The new system avoids the trouble with reinstalls
13:44:31 <Ste1891> glguy: Yes, I have to admit I've been lazy and not learned the new system yet.  However, I don't think
13:45:25 <hseg> ... weird that ghc flags {class C; instance C T} in a module signature as being orphan
13:45:35 <hseg> (where the implementation of C is left abstract
13:46:09 <hseg> (idea being to require the implementing signature to at least ensure T is an instance of C, not to actually declare an instance)
13:46:42 <Ste1891> ...the reinstalls are the problem, as the build gets all the way through the compilation and fails at the linker stage.  I'll try using the new approach as a next step though.
13:58:51 <hseg> ... wait, is newtype Proj a = Proj { getProj :: a } not eligible for Functor deriving?
14:00:12 <hseg> (supposed to be isomorphic to Identity)
14:01:02 <hseg> also, why doesn't DeriveAnyClass imply DeriveFunctor?
14:02:59 <heatsink> DeriveAnyClass is for wrapper types
14:03:07 <hseg> oh, wait. that's just for classes defining a generic instance
14:03:07 <hseg> *sigh*
14:05:06 <hseg> ugh. there must be a better way to do this
14:06:30 <hseg> given two classes C and D not under my control s.t. D => C via renaming some fields and dropping others, what is the recommended way to be able to use D where C is expected?
14:07:48 <hseg> could define a newtype, have an instance D a => C (Proj a), and use DerivingVia on a case-by-case basis
14:07:59 <hseg> cons: boilerplate
14:09:01 <hseg> could try to construct a witness of the entailment D => C and unpack it everywhere
14:09:21 <hseg> cons: heavy, decentralized change
14:09:57 <hseg> ... well, unless i write all my code to use C, then substitute in D at the top-level
14:11:12 <hseg> but i'd need to write a function D a => Dict (C a), which is unpleasant
14:11:22 <hseg> could write an overlapping instance D a => C a
14:11:48 <hseg> cons: can't define other instances, unless i deal with overlaps
14:12:09 <hseg> ideas?
14:24:32 <prog81> hseg: you can have a datatype with records with the same type as the class function
14:24:47 <prog81> function types*
14:24:51 <hseg> ?
14:25:10 <hseg> no, i'm not going to replace my classes with records
14:25:12 <prog81> and then have the dictionary as a constraint of the datatype constructor 
14:25:21 <prog81> no, you keep the classes
14:25:30 <hseg> ok...
14:26:00 <prog81> its just that you can put calls to the functions of C or D in a constructed value of that datatype 
14:27:21 <hseg> not clear on what you're suggesting
14:29:55 <prog81> you dont want to make the overlapping instance D a => C a, so instead, by having a datatype that can be constructed by the functions of C, which can be implemented instead as functions of D
14:30:15 <prog81> basically giveing you a place other than that overlapping instance to write these implementations
14:30:41 <prog81> since the records of the datatype can be used in the same way as calls to the members of C
14:32:17 <hseg> ok, but then i still need to pass that record around
14:32:26 <hseg> instead of having instance resolution do it for me
14:34:38 <prog81> well your still stuck trying to tell it which overlapping instance to use
14:37:20 <hseg> point
14:37:35 <hseg> ok, yeah, the derivingvia approach is probably for the best
14:37:53 <prog81> the constructor to the value eg newC_:: C a => C_a;newC_ = C_ (cFuncs, ...), or  newD_:: D a => C_a;newD_ = C_ (dFuncs, ...)
14:38:27 <prog81> can be called as its in top scope, and only needs the corresponding constraint, while providing the functionality of the Constraint C
14:39:16 <prog81> s/C_a/C_ a
14:39:36 <hseg> :/ nah, can swallow the derivingVia pill
14:39:41 <hseg> thanks though
14:41:52 <prog81> i dont see why it shouldnt be reasonable to expect that a function exists that takes the types provided by a class as arguments
14:42:21 <prog81> the datatype just wraps these up into one argument
14:44:05 <prog81> which via top scope adds the corresponding constraint, as if it were an overlapping instance, which you couldnt resolve via the typechecker anyway, and by naming constructors to the datatype wrapping the class, you make an interface to specify the information that cant be provided to the typechecker otherwise
14:45:19 <hseg> dislike the solution, is invasive and nonscalable imo. still, thanks
14:47:09 <prog81> it naturally fits with reification, basically making local instances possible
14:48:09 <hseg> yeah, but in my use case, i'm basically writing a compatibility layer for the intersection of several classes
14:48:20 <prog81> then you can return a constraint continuation over C from a reifying constructor of C_ only requiring the D constraint
14:48:38 <hseg> so i don't want to wrap/unwrap things so much
14:49:21 <prog81> C_ (dFunctions, .. ) :: D a => ((C a => r) ->r)
14:49:40 <prog81> oh, forgot the reifying call
14:50:55 <prog81> also needs an instance for C overlappingly implemented by the existence of a value of the datatype C_ as a constraint for a Default instance over C_
14:51:15 <prog81> which is maybe a problem for multiparameter typeclasses?
14:52:19 <prog81> is C_ and C both taking many parameters, as then the overlapping instance is like; Default (C a b c) => C a b c
14:52:36 <prog81> Default (C_ .... 
14:54:09 <prog81> ie you define all such classes to be with only one overlapping instance implemented by the corresponding class wrapping datatype, which you expect to be reified into scope
14:54:25 <prog81> and then instead of writing instances you just make values of this datatype and reify them
14:55:10 <prog81> which should be reasonable if ever there is need to "direct choice between overlapping instances"
14:57:19 <prog81> then, either your D a => C a overlapping instance is ok, since it is the only instance of C, or you have need to direct choice between overlapping instances, where then reification is the relavent machinery to use local instances, as provided by the various versions of this datatype corresponding to the different "instances" 
15:03:08 <prog81> actually, in your use case this seems perfect, since if there are common functions between classes, and you want then a subclass that these can all overlappingly instantiate, then this should be achieved by making this "compatibility layer for the intersection" locally instantiated by making this class reifiable, by writing the corresponding
15:03:08 <prog81> datatype wrapper
15:04:31 <prog81> i dont see how DerivingVia could do that
15:05:28 <prog81> only that it would make writing the extra instance (C) trivial
15:06:03 <hseg> create a newtype per class, write instances Ci a => Cintersect (NTi a), then say deriving via Cintersect NTi a instance Cintersect Ti
15:06:51 <hseg> you need to explicitly enumerate the types you want instances for, but it's a single line per instance, so not too bad
15:09:08 <hseg> iiuc, your solution is to reify my intersection class as a record :: Cintersect a, have constructors di :: Ci a => Cintersect a, and have consumers take either a Cintersect a or an explosion thereof?
15:09:23 <prog81> instead of having functions to return constraint continuations, one for each sufficient superclass
15:09:30 <hseg> don't quite understand the continuation part of this solution
15:09:53 <prog81> that after reification you are returned an environment in which the Constraint is instantiated
15:09:59 <prog81> as a constraint continuation
15:10:27 <prog81> using C_ (dFunctions, .. ) :: D a => ((C a => r) ->r)
15:11:16 <prog81> that thing at the end is the constraint continuation, a place where things that have a C constraint can be evaluated
15:11:36 <hseg> yeah, just unclear on how you'd construct it
15:13:16 <prog81> https://pastebin.com/raw/QcP0wMJA
15:13:37 <prog81> not a perfect presentation but it has everything necessary 
15:14:10 <prog81> using :: forall p a. ReifiableConstraint p => Def p a -> (p a => a) -> a
15:17:59 <hseg> that's the code from reflection, isn't it?
15:19:19 <prog81> I think i got it from here; https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
15:19:45 <hseg> hrm. that's a very different direction from where i'm taking things, but a useful idea nonetheless
15:19:47 <hseg> ty
15:20:24 * hackage wavefront 0.7.1.4 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.7.1.4 (DimitriSabadie)
15:20:25 <hseg> ... weird (working on sth else in parallel). can't destruct a Data.Ratio.Ratio
15:20:25 <prog81> Its not a bad idea to consider refection instead of overlapping instances. but deriveVia also seems good 
15:20:54 <prog81> i cant understand which approach is better for different situations 
15:21:32 <hseg> (i.e. importing Data.Ratio (Ratio(..)) doesn't permit writing explode (x :% y) = (x,y)
15:22:07 <d34df00d> Let's say I have this code: https://bpaste.net/ZA7Q . Why do I get this error? https://bpaste.net/MRNA
15:22:53 <hseg> but looking at https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Real.html#Ratio, the constructor doesn't appear to be hidden
15:23:01 <d34df00d> And why does it go away if I make `UnboxedType` depend on both `a` and `rep`, like https://bpaste.net/NAOQ ?
15:24:13 <d34df00d> It seems like the typechecker can't evaluate `UnboxedType Int`, but why?
15:24:20 <hseg> d34df00d: sorry, above my paygrade
15:25:51 <hseg> :facepalm: haddock, for all its goodness, misled me here
15:27:01 <hseg> The #source link for Ratio sent me to the original definition, but that hides the fact that by the time the type gets exported, the constructor is hidden
15:31:53 <Cale> d34df00d: I'm not sure, but trying to replace your functional dependency there with an additional associated type family seems to lead to a complaint that it can't be immediately used in the same recursive group
15:32:12 <Cale> d34df00d: So this might be a weird failure of fundeps and type families to interact nicely.
15:33:07 <d34df00d> Cale: yep, I had that too. I originally solved it as https://bpaste.net/DNKA , but it didn't occur to me that it might also manifest here as you just mentioned.
15:33:26 <d34df00d> Also https://gitlab.haskell.org/ghc/ghc/issues/12612 might be a good chance for me to start hacking on ghc :)
15:34:01 <Cale> However, separating the type family out makes that approach work
15:34:08 <Cale> i.e. if I define something like
15:34:12 <Cale> type family Representation a :: RuntimeRep
15:34:16 <Cale> type instance Representation Int = 'IntRep
15:34:27 <Cale> and have  type UnboxedType a :: TYPE (Representation a)
15:34:43 <Cale> (and make AsmArg just have the one parameter)
15:34:46 <d34df00d> Yeah yeah yeah, that's how I approached it!
15:34:52 <d34df00d> But without fundeps originally.
15:35:14 <d34df00d> Turns out fundeps don't really help in my case cause I cannot reliably use them anyway, but that's a whole different story.
15:37:45 <d34df00d> Crap, type families don't play nicely with overlappable instances either.
15:39:25 <phadej> in short: you cannot abstarct over classes with overlappable instances
15:39:35 <phadej> you'll run into all kind of nastiness
15:40:49 <d34df00d> So what I essentially want to do is to turn Int -> Double -> Int into Int# -> Double# -> Int#.
15:41:24 <d34df00d> The problem is that the kind of fully satisfied arrow (like Double# -> Int#) is *, which is different from the kind of Double# which is different from the kind of Int#.
15:41:47 <d34df00d> So I cannot just have https://bpaste.net/NMVA
15:42:12 <d34df00d> Neither can I have https://bpaste.net/U73Q
15:42:32 <d34df00d> The latter results in:  Expected a type, but ‘UnboxedFunTyRep a’ has kind ‘RuntimeRep’
15:42:36 <d34df00d> So what can I do?
15:43:23 <d34df00d> Ah, sure, because it should be :: TYPE (UnboxedFunTyRep a)
15:44:38 <d34df00d> But then if I do https://bpaste.net/UYSA , I still get • Expected kind ‘TYPE (UnboxedFunTyRep a)’, but ‘UnboxedType a’ has kind ‘TYPE (ArgRep a)’
15:44:42 <d34df00d> Which sort of makes sense to me.
15:45:03 <d34df00d> But I'm not sure how to work around this.
16:22:23 * hackage massiv 0.5.0.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.0.0 (lehins)
16:23:24 * hackage massiv-test 0.1.3 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.3 (lehins)
16:36:53 * hackage cpkg 0.2.4.5 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.4.5 (vmchale)
17:28:53 * hackage generic-data 0.8.0.0 - Deriving instances with GHC.Generics and related utilities  https://hackage.haskell.org/package/generic-data-0.8.0.0 (lyxia)
18:36:53 * hackage inline-asm 0.1.0.0 - Inline some Assembly in ur Haskell!  https://hackage.haskell.org/package/inline-asm-0.1.0.0 (0xd34df00d)
19:02:53 * hackage gsasl 0.3.7 - Bindings for GNU libgsasl  https://hackage.haskell.org/package/gsasl-0.3.7 (StephenWeber)
19:03:54 <d34df00d> :r
19:06:32 <glguy> Ok, no modules loaded.
19:07:45 <d34df00d> Yea, cause I got an error.
19:09:05 <d34df00d> So let's say I have this: https://bpaste.net/7XIQ
19:09:32 <koz_> d34df00d: Woo, inline asm.
19:09:33 <crestfallen> hello for the boolean monoid, is mempty = False ?
19:09:36 <d34df00d> Why would it consider the last rebox function as levity-polymorphic?
19:09:37 <d34df00d> https://bpaste.net/NKVA
19:09:43 <d34df00d> koz_: because I can!
19:09:58 <koz_> d34df00d: It could be useful.
19:09:59 <solonarv> crestfallen: depends which boolean monoid you pick, there are 4 of them I think
19:10:01 <koz_> Something something SIMD.
19:10:17 <solonarv> crestfallen: and for this reason, there isn't a 'Monoid Bool' instance in abse
19:10:19 <solonarv> * base
19:10:48 <d34df00d> koz_: so I should probably consider this less of a joke then and invest some time into say proper docs.
19:10:59 <crestfallen> it would be for mappend does that help?
19:11:02 <koz_> d34df00d: Yes, this.
19:11:12 <solonarv> crestfallen: no, it does not help at all!
19:11:22 <solonarv> crestfallen: the whole problem is that there are four possible choices for mappend
19:11:37 <solonarv> (they are: &&, ||, ==, /=)
19:12:23 <crestfallen> The example has deriving (Eq, Show) so  I guess (==)
19:12:35 <d34df00d> koz_: as you can see, for now I cannot even return multiple values from asm yet.
19:12:37 <crestfallen> let me post it
19:12:41 <d34df00d> Cannot rebox tuples back.
19:12:42 <crestfallen> paste*
19:12:52 <koz_> d34df00d: I wish you all the luck.
19:12:55 <solonarv> yes, please do - I am getting more confused with every message you send
19:14:54 <crestfallen> solonarv, https://termbin.com/1dsu  line 5 is in question
19:15:10 <crestfallen> sorry it doesn't show line numbers :)
19:15:52 <crestfallen> though glad termbin is working it was down last fall..
19:16:39 <crestfallen> the program compiles without instantiation for mempty but I get a warning
19:18:52 <crestfallen> solonarv, hope it makes sense
19:19:40 <crestfallen> the warning is missingMethods
19:20:47 <MarcelineVQ> Did you have a question about the warning?
19:22:14 <crestfallen> thanks MarcelineVQ wondering why haskellbook does not include mempty in the example; I get a warning just trying to implement mempty in that program
19:22:47 <crestfallen> it works like this: mempty = False' but is that what we want?
19:23:35 <crestfallen> what is the desired result of mempty; I thought its something like mempty x = x
19:26:06 <crestfallen> *in this case
19:30:50 <solonarv> crestfallen: no, 'mempty x = x' doesn't even typecheck most of the time (certainly not in your case)
19:31:19 <solonarv> now that I see you're *defining* your own Bool type and a Monoid instance for it, your question makes a lot of sense!
19:31:30 <crestfallen> phew
19:31:47 <xavo[m]> (not related to this case, but isn't that the mempty for Endo modulo newtype wrappers?)
19:31:48 <solonarv> the rules you have to follow are: 'mappend x mempty == x' and 'mappend mempty x == x'
19:31:48 <crestfallen> its a book example 'tis all
19:31:55 <solonarv> xavo[m]: correct
19:32:00 <xavo[m]> ah nice ty
19:32:16 <solonarv> crestfallen: so, just check whether those rules hold
19:32:53 <MarcelineVQ> What example? What full warning? You should know by now to include the things you ask about, only you can see your computer screen. I happen to have the book but most won't. The example isn't about writing a proper Monoid instance and it's not intended to be a complete one, it just happens to use Monoid since that's what we've been using so far. The example is just about showing that we don't require constraints on type variables we 
19:32:53 <MarcelineVQ> never use the values of.
19:33:39 <MarcelineVQ> It doesn't have mempty because it's not integral to the example, but it is a little silly to omit it I agree.
19:36:28 <crestfallen> the example was what I pasted sans the mempty line. I was trying to add it since I was getting the (full) warning:
19:37:47 <crestfallen> https://pastebin.com/aw9LTGVc
19:37:48 <MarcelineVQ> When I say the example I mean the text above it explaining it as well, context in other words, questions should be asked with context
19:38:08 <solonarv> yeah, this makes total sense now
19:38:14 <crestfallen> ok copy that
19:38:38 <solonarv> I'm guess the book is a bit old because "Monoid without mempty" is exactly what the somewhat-recently-added Semigroup class is for
19:39:54 <MarcelineVQ> Semigroup is handled in that chapter as well a little later on, I'm not sure why later on instead of before though.
19:40:04 <crestfallen> so how to define mempty if its possible
19:40:39 <solonarv> well, you figure out if there is a value that satisfies the following: for all x, mempty <> x = x and x <> mempty = x
19:42:25 <xavo[m]> <> is mappend, btw, just as an operator
19:42:53 <crestfallen> well, I don't think logically a Bool can be appended to mempty
19:43:10 <solonarv> "mappend" was not a great choice of name
19:44:30 <crestfallen> am I correct to assume that? ^
19:45:06 <crestfallen> solonarv, ^
19:45:12 <solonarv> well, it so happens that 'mappend'ing Bools isn't allowed, but that's just because there is no 'Monoid Bool' instance
19:45:24 <solonarv> "logically" has nothing to do with it
19:45:43 <solonarv> and anyway we are not talking about Bool, we are talking about this 'Booly a' type
19:46:24 <crestfallen> that's why I used logic; so I guess I'm confused once again
19:47:56 <solonarv> and your logic led you to "mappend mempty x is impossible"
19:48:02 <solonarv> how did you come to that conclusion?
19:48:42 <crestfallen> in the case of Bool/Bool like types
19:49:14 <crestfallen> solonarv, thanks not sure what the lesson is, but thanks
19:49:26 <solonarv> crestfallen: the lesson is not complete yet!
19:50:10 <solonarv> you came to an incorrect conclusion, I'm asking how you got there so that we can fix whatever misunderstanding caused you to do that
19:51:16 <crestfallen> mappend mempty is not impossible, but in the case of Bool I believe it is
19:52:29 <crestfallen> If I don't think of the example as Bool-like, I don't know how to think about it solonarv 
19:55:40 <crestfallen> thanks ALL the cafe is closing. pax
19:56:54 <solonarv> crestfallen: I know you are only talking about Bool (and similar types), you don't need to repeat that
19:57:25 <solonarv> but your conclusion is still incorrect; I will show that with an example:
19:57:42 <solonarv> % instance Semigroup Bool where (<>) = (&&)
19:57:43 <yahb> solonarv: 
19:57:51 <solonarv> % instance Monoid Bool where mempty = True
19:57:52 <yahb> solonarv: 
19:58:01 <solonarv> % mappend mempty True
19:58:02 <yahb> solonarv: True
19:58:06 <solonarv> see? it worked!
19:58:38 <crestfallen> thanks kindly I gotta go solonarv the cafe is closing. appreciated!
20:11:41 <d34df00d> Let's say I have an TH's Exp. Is it possible to ask the type checker its type?
20:17:00 <glguy> d34df00d: I don't think so
20:17:32 <d34df00d> That slightly complicates things, but not that much. Thanks!
20:18:53 * hackage lens-family-core 2.1.0 - Haskell 2022 Lens Families  https://hackage.haskell.org/package/lens-family-core-2.1.0 (RussellOConnor)
20:19:54 * hackage lens-family 2.1.0 - Lens Families  https://hackage.haskell.org/package/lens-family-2.1.0 (RussellOConnor)
20:56:59 <solonarv> d34df00d: I vaguely recall someone else was bemoaning this and was thinking about writing a separate typechecker
21:12:53 * hackage streamly-bytestring 0.1.1 - Library for streamly and bytestring interoperation.  https://hackage.haskell.org/package/streamly-bytestring-0.1.1 (psibi)
21:51:54 * hackage pandoc-citeproc 0.17 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.17 (JohnMacFarlane)
22:08:11 <d34df00d> Oh, good luck supporting all of modern haskell!
22:53:11 <Cale> d34df00d: This is something that I really really wish you could do. Maybe one of the most important things that TH needs to be more convenient to use in practice.
22:53:32 <Cale> d34df00d: So much of my TH code is just figuring out which constraints I need to put on the instances that I'm generating.
22:55:05 <Cale> d34df00d: I don't know if solonarv was thinking about me with that comment, but while I haven't implemented a separate typechecker, I've implemented bits and pieces of one.
22:57:07 <Cale> One of the problems you run into in trying to determine which constraints need to be imposed on a generated instance is that reifyInstances will give you all the instances which *unify* with the type that you give. So if there are type variables, you'll get all sorts of instances that are probably completely irrelevant to you.
22:57:49 <Cale> So, before I figured out a trick for dealing with that, I implemented the better part of unification with rigid type variables myself (but it was janky and I'm pretty sure there was a bug somewhere)
22:59:00 <Cale> I realised I could walk over the types and apply a type family with no instances to all the variables (kinda turning them into Skolem variables)
22:59:28 <Cale> Well, all the variables I want to hold rigid because they occur in the instance head, anyway :)
23:00:01 <Cale> But then you still end up using that a bunch and doing constraint solving by hand
23:00:08 <Cale> It's annoying.
23:10:24 * hackage fakedata 0.6.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.6.0 (psibi)
23:26:44 <idnar> https://pb.codehash.net/4ca9b4373e2a44cda22c217dbb5bad21 this type error is confusinng me, where is String -> Splitter a0 from?
23:31:30 <idnar> oh nm that whole thing is nonsense
23:37:56 <idnar> `intercalate " " . split (keepDelimsR . dropInitBlank . whenElt $ isUpper)`
23:41:48 <aviD> How do you get/to an `a` out of `L1`? My default implementation is `foo a = gFoo1 (from a)`.
23:46:54 <aviD> I am not quite sure how to use `Generic1`?
23:51:59 <aviD> I should have used a different letter, since I'm not looking for a as in`foo a` I'm looking for the type under the constructor `L1`.
