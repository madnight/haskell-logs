00:00:15 <dibblego> is that not what the above does?
00:00:30 <dminuoso> Sure, just hadn't thought of [minBound .. maxBound] yet :)
00:00:32 <dibblego> oh wait, you mean :: a -> a ?
00:00:40 <dibblego> deriving Enum will do it
00:01:00 <dminuoso> Not in a cyclic manner
00:01:14 <dibblego> then the function above?
00:01:42 <dibblego> data Hi = A | B | C | D | E deriving (Eq, Enum); hiii = cycle [minBound .. maxBound]
00:02:55 <glguy> if x == maxBound then minBound else succ x?
00:03:12 <dibblego> @type \a -> if a == maxBound then minBound else succ a
00:03:13 <lambdabot> (Eq p, Bounded p, Enum p) => p -> p
00:03:15 <dibblego> or that?
00:03:59 <dminuoso> Ah, its actually simpler. :)
00:04:01 <dminuoso> Thanks
00:05:50 <iqubic> dminuoso: does that work for you?
00:07:54 <koz_> :t both
00:07:56 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
00:10:13 <iqubic> koz_: That's just traverse but being applied to a bitraversable.
00:10:17 <iqubic> :t traverse
00:10:19 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:10:32 <koz_> iqubic: Thanks, I thought I recalled such a function, but not what it did.
00:11:07 <iqubic> Yeah. I'm just guessing what it does, based on the type signature.
00:17:57 <koz_> Someone with some lens-fu: I currently have 'fmap (bimap (bimap (view iso1) (view iso2)) (bimap (view iso1) (view iso2))' - is there a more concise, lens-y way to say this?
00:19:16 <glguy> Does bimapping help?
00:19:32 <koz_> :t bimapping
00:19:34 <lambdabot> (Bifunctor f1, Bifunctor g, Profunctor p, Functor f2) => AnIso s t a b -> AnIso s' t' a' b' -> p (f1 a a') (f2 (g b b')) -> p (f1 s s') (f2 (g t t'))
00:19:48 <koz_> That's actual genius - thank you!
00:33:09 <koz_> OK, so now that's become *deep breath* 'fmap (view (bimapping (bimapping iso1 iso2) (bimapping iso1 iso2)))'.
00:33:15 <koz_> So much bimapping.
00:45:40 <zceejkr> Hello everyone, a question if I may. I want to define a polynomial over a ring as a typeclass. The idea is that a polynomial over a ring is anything that can give a coefficient for any power and it can give it's degree. So I found the MultiParamTypeClassses extension and enabled it. I then did this: class Ring r => Poly p r where
00:45:40 <zceejkr>   coeff :: p -> Int -> r
00:45:40 <zceejkr>   degree :: p -> Int
00:45:40 <zceejkr> , but then I get the following error: Could not deduce (Poly p r0)
00:45:43 <zceejkr>       from the context: Poly p r
00:45:46 <zceejkr>         bound by the type signature for:
00:45:49 <zceejkr>                    degree :: forall p r. Poly p r => p -> Int The type variable ‘r0’ is ambiguous
00:45:53 <zceejkr>     • In the ambiguity check for ‘degree’
00:45:56 <zceejkr> Could anyone help me figure out what the problem is?
00:46:27 <zceejkr> class Ring r => Poly p r where
00:46:27 <zceejkr>          coeff :: p -> Int -> r
00:46:27 <zceejkr>          degree :: p -> Int
00:46:30 <zceejkr> *formatting
00:48:00 <ski> `degree :: p -> Int' is ambiguous, it doesn't mention `r'
00:48:16 <haskeldjiq> hey guys, can anyone help with a deriving clause?
00:48:18 <haskeldjiq> https://pastebin.com/JJDAQVA8
00:48:32 <ski> perhaps you meant to add an FD `p -> r', zceejkr ?
00:48:50 <zceejkr> What is a PD?
00:48:54 <zceejkr> FD*
00:49:09 <phadej> functional dependency
00:49:49 <ski> sounds like you need an instance, `MonadConc (KatipContextT IO)', haskeldjiq
00:50:02 <zceejkr> Ah. First time hearing about this. Will take a look. Thanks. 
00:50:04 <ski> zceejkr : also, why are you making a type class for this ?
00:50:54 <haskeldjiq> ski: yeah, but is there not a way to avoid the orphan and all of the boilerplate associated with it?
00:51:03 <haskeldjiq> ski: the minimal definition of MonadConc has like 20 functions
00:51:16 <ski> orphan ?
00:51:27 <haskeldjiq> ski: yes, KatipContextT is coming from the katip logging library
00:51:42 <zceejkr> Don't know but seems fun :). Also seems like a good way to learn haskell. If I just defined a polynomial as a list of Ring elements I would never have come accross MultiParameterTypeClasses and "FDs" apparently :)
00:51:48 <zceejkr> ski
00:51:52 <ski> if you need something like `instance MonadConc m => MonadConc (KatipContextT m)' or whater, you need it
00:52:44 <ski> zceejkr : do you have at least two different types that you want to use to represent polynomials over the same ring `r' ?
00:53:09 <zceejkr> ski: But more generally, when does one model things as typeclasses and when does one use data?
00:53:21 <zceejkr> ski: I have 2 in mind at the moment. 
00:54:17 <ski> generally, you should have at least two different types in mind to make into instances of a type class. also, you'd normally also want to write an operation which is (constrained) polymorphic over instances of that type class
00:54:30 <ski> that's what type classes are for
00:54:31 <zceejkr> ski: But I also want to do it beacuse I want my polynomial addition be independent of data represenation. So I can swap polynomial representation and habe addition/multiplication work still.
00:54:57 <ski> if you don't want both of these things, i'd probably just go with a data type, at least to begin with
00:55:12 <ski> it's relatively seldom that one wants to make new type classes
00:55:27 <ski> mhm
00:55:58 <ski> also, i guess you're only doing single-variable polynomials ?
00:56:11 <ski> (also, not formal power series ..)
00:56:51 <zceejkr> at the moment yes. But will look into generalizing further in the future. What do you mean about power series?
00:57:04 <ski> anyway, if you isolate the innards of the data representation, iow make an ADT, you should get such independence
00:57:28 <ski> i mean like e.g. `1 + x + x^2 + x^3 + ...', having infinite degree
00:58:20 <ski> do you want to hear why it was complaining above ?
00:59:33 <zceejkr> ah. Well the idea with coeff being a function that just gives a coefficient for each power is that you can then think of every polynomial as having a coefficient at each power (up to infinity), but most are 0.
00:59:36 <ski> (you might also, at some point, look into Backpack, if you want to investigate another way in which to get more flexibility with swapping out representations)
00:59:40 <zceejkr> ski: yes, I would like to hear :)
01:00:20 <ski> well, say you have two rings. maybe `RectComplex' and `PolComplex', two different representations of complex numbers
01:00:58 <ski> and then you define `ComplexPoly', polynomials in complex coefficient, but you for some reason decide to hide the internal representation of the coefficients
01:01:01 <ski> and you do
01:01:16 <ski>   instance Poly ComplexPoly RectComplex
01:01:18 <ski> and also
01:01:21 <ski>   instance Poly ComplexPoly PolComplex
01:01:38 <ski> now, you try to use `degree :: p -> Int', where `p' is `ComplexPoly'
01:01:57 <ski> how is Haskell supposed to know whether you meant the `degree' in the first or the second instance ?
01:02:04 <ski> that's what it was complaining about
01:02:15 <zceejkr> I see. Thanks! Great explanation.
01:02:45 <ski> however, if you add an FD `p -> r' to `Poly p r', read "`p' (functionally) determines `r'", then you're disallowed from making both of these instances
01:02:55 <ski> for each `p' there can be at most one `r'
01:03:51 <ski> logically, the FD in `class Ring r => Poly p r | p -> r' says `forall p. unique r. Poly p r', which is the same as`forall p r0 r0. (Poly p r0,Poly p r1) => r0 = r1'
01:04:49 <ski> the second thing, apart from disallowing instances like above to be simultaneously in scope, is to allow it to deduce that if `Poly p r0' and also `Poly p r1', then `r0' must be equal to `r1'
01:05:24 <ski> and that will force `r' and `r0' from your ambiguity error message to be equal, avoiding the ambiguity
01:05:48 <ski> zceejkr : makes sense ?
01:06:08 <zceejkr> Very much. Thank you so much.
01:06:49 <ski> if you ever run into relational data base theory, you'll note they also have a concept of "functional dependency", which is basically the samem thing
01:07:02 <ski> (although used a bit differently)
01:07:50 <ski> <zceejkr> ah. Well the idea with coeff being a function that just gives a coefficient for each power is that you can then think of every polynomial as having a coefficient at each power (up to infinity), but most are 0.
01:07:57 <ski> yea, a function with finite support
01:09:38 <zceejkr> ski: My database knowledge is very limited, but I would like to dig deeper one day. So "function with finite support" a term for the genral case where you define a function over an inifinite type, but provide a default value on most cases?
01:10:32 <ski> well, having a default value for all but finitely many cases. that default value usually being a "zero" element of some monoid
01:10:56 <ski> however, one can also consider permutations, and i think the term "finite support" may also be used then
01:11:02 <ski> consider a bijection over the naturals
01:11:50 <ski> now consider those bijections which are the identity on all but finitely many elements. these are the ones which can be generated as compositions of (binary) transpositions
01:12:11 <ski> i think i may have seen these being referred to as "permutations with finite support" as well
01:13:05 <ski> (also, i'd say "arbitrary type", rather than "infinite type". it's not like it doesn't make sense for finite types. it's just that all such functions have finite support automatically, so it's boring, trivial)
01:13:07 <zceejkr> I see. So this second one would always be a -> a, have the same type
01:13:16 <ski> yeap
01:17:04 <ski> polynomials (over a ring `R') in a set of indeterminates `X' can be thought of as living in some kind of function ring `|N^(X) >---> R', where `|N^(X)' is the monoid of functions from `X' to `|N' with finite support (in Haskell, one might try to use `Map X Int' assuming a default of `0' for absent values)
01:18:27 <ski> er, also the functions in `|N^(X) >---> R' ought to have finite support
01:18:40 <StillerHarpo> Hi, I`am trying to debug a core to core plugin.  It it takes to way to long for simple function.  We suppose that it is because of inlineing.  Is there a way to run the core to core passes of the plugin before inlineing?
01:19:08 <ski> hm, iirc, this `|N^(X) >---> R' is equivalent to a monoid ring `R[|N^(X)]'
01:21:44 <ski> another way to think of polynomials here is in terms of "evaluating at a point", so `R^X >---> R', or even `forall S : Ring,i : R >---> S. S^X >---> S' allowing to interpret the polynomial in any other ring `S' that one can map the coefficients `R' into
01:21:51 <zceejkr> ski: Ok, you finally lost me :D. But one of the representation I had in mind for the polynomials was indeed a map from Int (the power) to a Ring element, and return empty when map is empty. Not sure if this is related to what you were saying though.
01:22:26 <ski> <https://en.wikipedia.org/wiki/Monoid_ring>
01:23:15 <ski> zceejkr : well, let's say you have infinitely many indeterminates, `x_0',`x_1',`x_2',...
01:23:38 <ski> each term in the polynomial involves only finitely many indeterminates, multiplied with each other
01:24:21 <ski> in other words, each term is identified by giving a (natural number) exponent for each indeterminate, however giving zero too all but finitely many indeterminates
01:24:40 <ski> so, we could identify terms by something like `Map X Int'
01:25:21 <ski> then, there's only finitely many terms, so the whole polynomial type could be modelled as `Map (Map X Int) R'
01:25:38 <ski> (a bit fun, having maps as keys in another map. a "higher-order" map)
01:25:41 <zceejkr> I see. So it's kind of like what I want to do to the coefficient to a single variable polynomial, but now do the same thing to the powers of (inifinitely many) variables.
01:26:08 <ski> however, you'll need to wrap `Map X Int' into a newtype, to identify maps which include extra entries, mapping to zero
01:26:26 <ski> s/infinitely/arbitrarily/
01:27:24 <ski>   eval :: Poly p r => p -> (r -> r)
01:27:43 <ski>   eval :: (Poly p r,Ring s) => (r -> s) -> p -> (s -> s)
01:27:53 * hackage binary-strict 0.4.8.5 - Binary deserialisation using strict ByteStrings  https://hackage.haskell.org/package/binary-strict-0.4.8.5 (DominicSteinitz)
01:28:11 <ski>   eval :: MultiPoly p x r => p -> ((x -> r) -> r)
01:28:25 <ski>   eval :: (MultiPoly p x r,Ring s) => (r -> s) -> p -> ((x -> s) -> s)
01:29:00 <ski> those latter would be sketches of what one could attempt, converting from the coefficient representation to the "evaluation" "representation"
01:29:15 <ski> makes any sense, zceejkr ?
01:29:59 <ski> (the first two `eval's are for the single-variable case. the second of them is the more general "interpret in another ring" case)
01:30:12 <ski> (the second two `eval's are for the multiple-variable case. the second of them is the more general "interpret in another ring" case)
01:30:29 <ski> oh, and the rings in question here ought to be commutative rings ! 
01:31:12 <zceejkr> ski: Makes sense up to a point, but I am still missing some context. But I am saving this chat and I will go over this in detail later. Thanks so much for this. Basically got a free lecture in haskell/algerba :D
01:32:14 <ski> one example of interpreting in another ring is to take some kind of characteristic polynomial, related to a matrix, with coefficients being from the scalar ring. and then inserting the matrix itself into the polynomial (so the ring `s' might be the (commutative) subring of the matrix ring, generated by this matrix)
01:33:38 <ski> yea .. the thoughts about the more abstract math view with `R^(|N^(X))' and `R^X >---> R' or `forall S : Ring,i : R >---> S. S^X >---> S' are half-baked thoughts, something which i'm not done thinking about ..
01:33:57 <ski> (.. attempting to relate it to category theory)
01:34:21 <ski> zceejkr : but hopefully the implementation ideas ought to be more or less clear
01:35:22 <zceejkr> Oh you have given me plenty of ideas about where to head next. 
01:36:19 <ski> if you look at the monoid ring link above, what i was doing here was choosing the monoid to be used to be the "free monoid" over the set of indeterminates `X'
01:36:47 <ski> (hrm, more specifically, the "free commutative/abelian monoid")
01:37:38 <ski> the free monoid over `X' is, in Haskell terms, the type `[X]' of (finite) lists (ignore infinite lists)
01:38:40 <ski> however, the free commutative monoid over `X' would more be like `Bag X', a type of (finite) (sub)bags of `X'
01:38:45 <ski> (bags aka multisets)
01:39:30 <ski> we have a bag of indeterminates, for each term, not a list, since they're not ordered (since multiplication in our rings are commutative. we're only considering commutative rings here)
01:40:16 <ski> and `Bag X' can be represented roughly as `Map X Natural', or `Map X Int', cutting corners
01:40:45 <ski> hm, i think i'll stop here
01:43:20 <zceejkr> Haha, well you got way ahead of me towards the end. But I have this chat saved and I will try to understand what was said later on. I will get back to coding now. Again, many thanks. 
01:45:38 <berndl> Does it make sense to view MonadPlus as an MTL-style typeclass for the "try this first and if that fails, try the alternative" effect?
01:49:27 <ski> @wiki MonadPlus
01:49:27 <lambdabot> https://wiki.haskell.org/MonadPlus
01:49:30 <ski> @wiki MonadPlus reform proposal
01:49:31 <lambdabot> https://wiki.haskell.org/MonadPlus_reform_proposal
01:49:32 <berndl> Also, is there an MTL-style type class for the effect "run these two computations are return the first one that finishes"?
01:50:55 <Rembane> berndl: I think the async package should do what you want.
01:51:02 <Rembane> @hackage async 
01:51:02 <lambdabot> http://hackage.haskell.org/package/async
01:51:23 <berndl> ski: I'm noticing that the left-distribution law is the "algebraicity property" that "Monad Transformers and Modular Algebraic Effects" talks about.
01:51:24 <Rembane> berndl: Depending on what you want of course. 
01:52:56 <berndl> Rembane: Nice. So basically what I'm looking for is a typeclass with the method race.
01:53:38 <ski> "return the first one that finishes" also reminds me of "parallel or"
01:54:31 <ski> hm, and i suppose i often tend to prefer having left distribution
01:54:36 <ski> (e.g. in parsing)
01:54:57 <ski> (cf. left-factoring of grammars)
01:55:44 <Rembane> berndl: Why do you specifically need it in a typeclass? Are you doing some mtl shenanigans?
01:56:52 * ski would presume so
01:58:18 <berndl> Rembane: well, I want to classify the effect with a typeclass somehow.
01:58:31 <ski> @hackage logict
01:58:31 <lambdabot> http://hackage.haskell.org/package/logict
01:58:35 <Rembane> berndl: Got it. 
01:59:40 <berndl> The Decidable class has a choosen method (https://hackage.haskell.org/package/contravariant-1.5.2/docs/Data-Functor-Contravariant-Divisible.html#t:Decidable). Maybe that's what I'm looking for.
02:01:05 <berndl> Hmm... maybe not.
02:02:28 * ski . o O ( <https://hackage.haskell.org/package/logict-0.7.0.2/docs/src/Control.Monad.Logic.Class.html#ifte> )
02:12:00 <merijn> dmj`: Well in my case it'd be sqlite-simple, but yeah, I'd probably take either of the -simple libraries over it
02:17:03 <tabaqui1> % sum a b = trace "1" $ a + b
02:17:03 <yahb> tabaqui1: 
02:17:08 <tabaqui1>  % foo a b = seq (sum a b) (sum a b)
02:17:15 <tabaqui1> % foo a b = seq (sum a b) (sum a b)
02:17:15 <yahb> tabaqui1: 
02:17:17 <tabaqui1> % foo 2 3
02:17:17 <yahb> tabaqui1: 1; 1; 5
02:17:52 <tabaqui1> sometimes this example prints "1" only once
02:18:06 <tabaqui1> I guess, it depends on GHC optimizations, right?
02:18:17 <mniip> ghci doesn't do any
02:20:08 <tabaqui1> right, "stack ghc" returns a binary that prints twice, while "stack ghc -- -O" - once
02:20:11 <dmj`> merijn: really tempted to use sqlite ... think it would be cool to give every customer their own sqlite database, then you could be very concurrent. But would hard to do aggregate queries across all of the sqlite dbs
02:20:57 <dmj`> guess you can attach multiple db's though
02:22:29 <tabaqui1> @quote not a bug
02:22:30 <lambdabot> No quotes for this person. Maybe you made a typo?
02:22:39 <tabaqui1> @quote unsafePerformIO
02:22:39 <lambdabot> kmc says: head [] = unsafePerformIO . peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
02:22:41 <tabaqui1> @quote unsafePerformIO
02:22:41 <lambdabot> ManuelChakravarty says: After all, you can import any C function with a pure type which also allows you to wreak arbitrary havoc.  We enable the user to disguise arbitrary machine code as a Haskell
02:22:42 <lambdabot> function of essentially arbitrary type.  In comparison, `unsafePerformIO' seems angelic.
02:22:48 <tabaqui1> @quote unsafePerformIO not a bug
02:22:49 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
02:25:22 <zceejkr> If I have a function like so: assoc :: (Ring r, Eq r) => r -> r -> r -> Bool, how do I get a value of type where r is replaced by a concrete type? assoc :: Int does not work (and it has a Ring and Eq instance).
02:26:36 <tabaqui1> zceejkr: -TypeApplications
02:26:40 <tabaqui1> assoc @Int
02:27:10 <zceejkr> Thank you.
02:27:32 <tabaqui1> welcome
02:29:33 <merijn> dmj`: You could attach to multiple databases, but I don't think that's very great. How much concurrency do you expect that that's an issue?
02:29:48 <merijn> dmj`: If you really need a lot of concurrency postgres is probably the way to go
02:31:06 <dmj`> merijn: yea, I'm currently using PostgresSQL and connecting RDS, but I think sqlite is a simpler database since it's just a single file, would like to use it.
02:32:34 <merijn> dmj`: How often do you need to do aggregate queries across all databases and how up to date do they need to be?
02:33:02 <merijn> tabaqui1: you need . for spaces :)
02:33:08 <merijn> @quote not.a.bug
02:33:08 <lambdabot> cdsmith says: Yeah, that's weird... but it's documented, so it's not a bug. :)
02:33:18 <merijn> pfft, wrong one xD
02:33:25 <tabaqui1> @quote unsafePerformIO not.a.bug
02:33:26 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
02:33:30 <tabaqui1> @quote not.a.bug
02:33:30 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
02:33:32 <tabaqui1> @quote not.a.bug
02:33:32 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
02:33:38 <tabaqui1> hay!
02:34:00 <tabaqui1> merijn: thx :)
02:35:21 <dmj`> merijn: I'm not sure yet, but having a view of all users would be nice, seems hard to do if they're all spread out.
02:35:34 <dmj`> merijn: unless I had a separate db for sessions
02:35:48 <boxscape> > System.Info.compilerVersion
02:35:50 <lambdabot>  error:
02:35:50 <lambdabot>      Not in scope: ‘System.Info.compilerVersion’
02:35:50 <lambdabot>      No module named ‘System.Info’ is imported.
02:35:51 <zceejkr> Does anyone have an idea why ghci would not recongnize -TypeApplications? "Some flags have not been recognized: -TypeApplications". I have 2 other extensions working fine.
02:35:54 <boxscape> is there way to do this with lambdabot?
02:35:55 <merijn> dmj`: I ask because recently they added things like exporting/importing database diffs 
02:36:02 <boxscape> zceejkr it's -XTypeApplications
02:36:25 <ski> @let import qualified System.Info
02:36:27 <zceejkr> Ok, it works now. Thanks.
02:36:29 <lambdabot>  Defined.
02:36:30 <ski> > System.Info.compilerVersion
02:36:33 <lambdabot>  Version {versionBranch = [8,6], versionTags = []}
02:36:33 <dmj`> merijn: oo sounds fancy
02:36:35 <boxscape> ah, thanks ski
02:36:45 <merijn> dmj`: And functionality for dumping snapshots from live databases, I think
02:39:23 * hackage lattices 2.0.2 - Fine-grained library for constructing and manipulating lattices  https://hackage.haskell.org/package/lattices-2.0.2 (phadej)
02:51:02 <dmj`> merijn: so tempting
02:51:19 <dmj`> merijn: single file databases, so nice
02:52:22 <dibblego> topos: ♥ base-{2^n}-lens ♥
02:54:41 * ski idly wonders whether there's any package(s) with support for working with (say finitely generated) submonoids, subrings, and perhaps also factor monoids, factor rings
02:59:43 <zceejkr> ski: if I have my polynomials defined as Ring r => Poly p r, with coeff and degree functions defined, I can also define the functions add and mul, using the Ring opertations and the degree and coeff functions. This means that every (Poly p r) is itself a Ring. How do I express this in Haskell?
03:02:16 <ski> fyi, you probably don't mean `Ring r => Poly p r', but rather "`Poly p r', where `Ring r' holds" (this is not the same thing)
03:02:51 <phadej> i guess it's class Ring r => Poly p r | p -> r where ...
03:03:15 <ski> one could try `instance Poly p r => Ring p', and this wouldn't work without that FD
03:03:33 <phadej> that won't work
03:03:37 <phadej> Ring p is catch all instance
03:03:44 <ski> yea
03:03:52 <phadej> you can define newtype RingPoly p r with instance Poly p r => Ring (RingPoly p) and use deriving via to avoid poilerplate
03:04:01 * ski was about to say :)
03:04:40 <phadej> i.e. if P has instance Poly P Int; then yo ucan wwrite deriving via (RingPoly P) innstance (Ring P)
03:04:52 <ski> zceejkr : fwiw, i still think it's slightly weird to have this `Poly' class
03:04:56 <phadej> (I don't remember exact syntax though)
03:05:46 <phadej> especially for StandaloneDeriving
03:06:13 * ski idly ponders using existentials to simulate ADTs
03:06:32 <zceejkr> I see, thanks.
03:13:06 <ski> hm, something like
03:14:23 <ski>   data PolyRep r = forall p. Ring p => MkPolyRep {coeff :: p -> Int -> r,degree p -> Int}
03:15:26 <phadej> ski: it's essentially a final encoding
03:15:32 <ski> zceejkr : oh, and btw, you could maybe change `class Ring r => Poly p r | p -> r' to `class (Ring r,Ring p) => Poly p r', which would enforce having to have addition, multiplication, &c. defined on `p'
03:15:57 <phadej> newtype PolyRep q = PolyRep { forall p. Poly p r => (q -> p) -> p }
03:16:09 <ski> anyway, the point here is that you can have two different operations, resulting in a `PolyRep r', using different representations
03:16:17 <zceejkr> ski: but I wanted to define addition in terms of degree and coeff (which are Poly functions)
03:16:36 <ski> btw, this isn't using existentials to simulate OO, but rather to simulate ADTs (see TaPL)
03:16:56 <ski> zceejkr : yes ? .. is there a problem ?
03:17:10 <zceejkr> What are exsistentials, OO and ADT?
03:17:28 <zceejkr> Is ADT algebraic data type?
03:17:57 <ski> zceejkr : hm, maybe you meant you wanted to make the `Ring p' instance generically, in terms of `Ring r' and `Poly p r', rather than one time for each `p'
03:17:58 <dibblego> generally yes
03:18:01 <ski> no
03:18:11 <ski> "Abstract Data Type", in this context
03:18:16 <dibblego> oh yes sorry
03:18:19 <ski> and "OO" is "Object-Orientation"
03:18:25 <zceejkr> ski: yes this is what I wanted.
03:18:38 <ski> yah, i just realized you probably did
03:21:10 <zceejkr> So what are exsistentials?
03:21:32 <ski> i could go into a rant/tutorial explaining them, if you wanted to
03:21:39 <ski> (i've done it many times before)
03:21:48 <zceejkr> Im down for it :)
03:22:32 <ski> hm, pondering whether to preemptively move to #haskell-overflow, or to keep it in here
03:23:18 <zceejkr> I am new here, so I am not sure about the rules.
03:23:22 <ski> i'd like to first go over polymorphism and universals a little bit, to reinforce, compare and contrast. e.g. to bring up higher-rank, 
03:24:06 <ski> well, this channel isn't that active at the moment, and perhaps others would like to lurk ior interject, as well
03:24:34 <ski> however, it might take, hm, i dunno. half an hour, an hour, an hour and a half ?
03:24:44 <ski> do you have some time to kill ?
03:24:44 <zceejkr> I have time.
03:25:10 <ski> (we could always continue another time, if you find you have to dash, or if you've had enough for one sitting)
03:25:39 <zceejkr> Great :).
03:26:05 <ski> hm, so polymorphism
03:26:09 <ski> consider
03:26:15 <ski>   length :: [a] -> Int
03:26:24 <ski>   take :: Int -> [a] -> [a]
03:26:43 <ski>   zip :: [a] -> [b] -> [(a,b)]
03:26:47 <ski> and so on
03:27:01 <ski> also
03:27:10 <ski>   Nothing :: Maybe a
03:27:20 <ski>   exitSuccess :: IO a
03:27:28 <ski>   undefined :: a
03:27:57 <ski> these are all polymorphic operations/values (they don't have to be functions, as in the latter cases. hence i say "operations")
03:28:05 <ski> what does "polymorphic" mean ?
03:28:17 <ski> well, take `take'
03:28:22 <zceejkr> :)
03:28:27 <ski>   take :: Int -> [a] -> [a]
03:29:16 <ski> this really means that, whatever concrete, specific, type we use in place of the type variable `a', `take' can be used as having the resulting, specific, type
03:29:21 <ski> so, in particular we have
03:29:28 <ski>   take :: Int -> [Int] -> [Int]
03:29:38 <ski>   take :: Int -> [[Bool]] -> [[Bool]]
03:30:15 <zceejkr> So it's like a map from type -> type?
03:30:17 <ski>   take :: Int -> [String -> Maybe String] -> [String -> Maybe String]
03:30:19 <ski> and so on
03:30:38 <ski> `take' doesn't care about what the element type is
03:30:47 <ski> however, we can't have
03:30:52 <ski>   take :: Int -> [[Bool]] -> [Int]
03:30:58 <boxscape> You can write `data Foo a where` as `data Foo :: Type -> Type` instead. Is there another way to write `data instance Foo Int where`?
03:31:08 <ski> we have to use the same type for `a', consistently, in a given use of `take'
03:31:32 <boxscape> (assume it has to be GADT syntax)
03:31:33 <ski> zceejkr : hm, can you elaborate your question ?
03:31:52 <zceejkr> Sorry it is not a question. Just some rambling. Please continue.
03:32:07 <berndl> boxscape: "data instance" ?
03:32:20 <boxscape> berndl that makes an instance of a data family
03:32:35 <ski> you can, very roughly, think of it as, given the type `Int', you get type `Int -> [Int] -> [Int]', given type `[Bool]', you get type `Int -> [[Bool]] -> [[Bool]]', and so on
03:32:56 <boxscape> berndl https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#data-instance-declarations
03:32:57 <ski> so, given any type `a', you get `Int -> [a] -> [a]'. this would be a "type function"
03:33:40 <ski> zceejkr : and that's a bit relevant, here. but it's not the same as polymorphism. `take' is polymorphic. but `take' is not a type function (but a type function is somehow involved in the type of `take')
03:33:58 <ski> zceejkr : let's leave it at that, atm, unless you have any further comment/question on that
03:34:21 <zceejkr> We can continue.
03:34:27 <ski> consider again
03:34:32 <ski>   take :: Int -> [a] -> [a]
03:34:51 <ski> actually, this is a (context-dependent) shorthand notation
03:35:00 <ski> what we really mean here is
03:35:06 <ski>   take :: forall a. Int -> [a] -> [a]
03:35:19 <ski> one way to think of this logically is :
03:35:22 <ski>   forall a.
03:35:26 <ski>     take :: Int -> [a] -> [a]
03:35:49 <ski> iow, for all types `a', `take' has type, or can be used as having type, `Int -> [a] -> [a]'
03:36:33 <ski> zceejkr : a value which has a type of shape `[...]' is a list. a value whose type has shape `... -> ...' is a function. a value whose type has shape `forall a. ..a..' is a "polymorphic value"
03:37:17 <ski> zceejkr : polymorphic values are exactly those, whose type looks like `forall a. ..a..' (obviously the name of the, locally bound, type variable `a' can vary)
03:37:33 <zceejkr> So it's actually Nothing :: forall a. Maybe a etc.
03:37:38 <ski> yep
03:38:08 <ski> this means that, strictly speaking, `take' is not a function. it's a polymorphic value (which when specialized yields a function), or "polymorphic function" for short
03:38:18 <boxscape> % :set -fprint-explicit-foralls
03:38:18 <yahb> boxscape: 
03:38:27 <boxscape> % :t +v Nothing
03:38:28 <yahb> boxscape: forall a. Maybe a
03:38:47 <zceejkr> nice
03:39:04 <ski> however, when going from `take :: Int -> [a] -> [a]' to `take :: Int -> [Integer] -> [Integer]', note that there's no explicit notation for this specialization step. we write just `take' in the source code, in both cases
03:39:52 <ski> so, we tend therefore to blur the distinction between a polymorphic value, and the value that it specializes to, when we replace the type variable `a' with some specific type
03:39:59 <ski> so, to summarize, we really go from
03:40:05 <ski>   take :: forall a. Int -> [a] -> [a]
03:40:06 <ski> to
03:40:15 <ski>   take :: Int -> [Integer] -> [Integer]
03:40:30 <ski> (removing the `forall', while consistently replacing the tyvar with a specific type)
03:41:04 <ski> similarly, when we define a polymorphic operation, there's no explicit notation for the generalization
03:41:07 <ski> consider
03:41:16 <ski>   elem :: forall a. Eq a => a -> [a] -> Bool
03:41:44 <ski>   elem x0 = elem_x0
03:41:46 <ski>     where
03:41:53 <ski>     elem_x0 :: [a] -> Bool
03:42:00 <ski>     elem_x0 [    ] = False
03:42:07 <ski>     elem_x0 (x:xs) = x0 == x
03:42:19 <ski>                   || elem_x0 x
03:42:45 <ski> `elem' is polymorphic, but `elem_x0' is not (it's monomorphic)
03:43:01 <ski> there is (and should not be) any `forall' in the signature of `elem_x0'
03:43:04 <Taneb> (this requires ScopedTypeVariables to write)
03:43:08 <ski> indeed
03:43:31 <Taneb> But without that extension you can omit the type signature and elem_x0 still has that type
03:43:43 <zceejkr> Did you miss xs at the end there? Or am I missing something?
03:44:08 <ski> er, sorry, should be `elem_x0 xs' at the end. apparently the `s' didn't take it
03:44:35 <ski> there is actually an extension to write polymorphic specialization
03:44:37 <ski> so, from
03:44:38 <zceejkr> Ah so elem_x0 binds the x0 so to speak
03:44:43 <ski>   take :: forall a. Int -> [a] -> [a]
03:44:46 <ski> one'd get
03:44:58 <ski>   take @Integer :: Int -> [Integer] -> [Integer]
03:45:15 <boxscape> An extension that isn't implemented yet, though
03:45:20 <boxscape> wait
03:45:22 <ski> explicitly indicating the specialization type `Integer' in the source code, writing `take @Integer'
03:45:25 <boxscape> I'm thinking of the opposite
03:45:29 <ski> @type take @Integer
03:45:32 <lambdabot> error:
03:45:32 <lambdabot>     Pattern syntax in expression context: take@Integer
03:45:32 <lambdabot>     Did you mean to enable TypeApplications?
03:45:40 <ski> % :t take @Integer
03:45:40 <yahb> ski: Int -> [Integer] -> [Integer]
03:45:48 <boxscape> I thought you meant `elem @a x0 = ...`
03:45:48 <ski> coming to that, boxscape :)
03:45:52 <ski> i was about to :)
03:46:02 <boxscape> sorry :)
03:46:14 <ski> if we imagine a corresponding extension for polymorphic generalization, we'd have
03:46:23 <ski>   elem @a x0 = elem_x0
03:46:39 <ski> but we'd still have the same definition of `elem_x0', since that's monomorphic
03:47:12 <ski> when we have picked the particular type `a' we want to use with `elem', then that's the type that's to be used with `elem_x0' as well. there is no further choice
03:47:50 <zceejkr> " if we imagine a corresponding extension for polymorphic generalization,"
03:48:02 <ski> within, inside, the definition of `elem', we think of `a' as a specific (but unknown to `elem') type. and there's no choice of type in `elem_x0', it's always the same `a'
03:48:10 <zceejkr> Corresponding to which externsion. TypeApplications?
03:48:13 <ski> yes
03:48:24 <ski> `TypeAbstractions', one could imagine it being called
03:48:27 <ski> so one could write
03:49:16 <ski>   threeNothings :: forall a. [Maybe a]
03:49:18 <ski>   threeNothings @a = [Nothing @a,Nothing @a,Nothing @a]
03:49:27 <ski> alternatively defining it something like
03:49:52 <ski>   threeNothings = \@a -> [Nothing @a,Nothing @a,Nothing @a]
03:50:09 <ski> just as
03:50:26 <ski>   replicateThreeInts :: Int -> [Int]
03:50:34 <ski>   replicareThreeInts x = [x,x,x]
03:50:37 <ski> can be defined as
03:50:42 <ski>   replicareThreeInts = \x -> [x,x,x]
03:50:51 <zceejkr> How would one implement threeNothing in vanila haskell? Can it be done?
03:50:59 <ski> just as `x' there binds a value. `a' previous binds a type
03:51:07 <ski> simply write
03:51:17 <ski>   threeNothings = [Nothing,Nothing,Nothing]
03:51:55 <zceejkr> I see.
03:52:15 <zceejkr> Actually, what is the difference between the two?
03:52:16 <ski> the three `Nothing's will be specialized to `a', then the whole `threeNothings' will get generalized on that `a' (adding `forall a.' outermost to the type)
03:52:56 <ski> without extensions, you're implicitly specializing the polymorphic `Nothing's, and also implicitly generalizing `threeNothings', so that it, in turn, becomes polymorhic
03:53:24 <ski> with the extensions (one of them imagined), you'd explicitly be specializing and generalizing
03:53:55 <zceejkr> So you decide at which point you want to get rid of the forall.
03:53:59 <ski> specializing is going from a value of type `forall a. ..a..' to a value of type `..T..' for some particular type `T' that we picked
03:54:19 <zceejkr> I think I understand now.
03:54:36 <ski> generalizing is going from a value of type `..a..', where `a' is a type variable that is not used anywhere else, to a value of type `forall a. ..a..'
03:55:52 <zceejkr> so if I had a value of type [Maybe Int], I could write something and get a value of type forall a. Maybe a?
03:56:13 <ski> the main point i want to drie home here is that just as there are lists, functions, pairs, &c. there are also polymorphic values. and just as a value is a function whenever its type looks like `... -> ...', a value is polymorphic whenever its type looks like `forall a. ..a..' (for some tyvar `a')
03:56:39 <ski> probably not in the way you think of it, no, since `Int' is not a type variable
03:56:47 <ski> one can only generalize on type variables
03:56:54 <ski> at first, one may hear that
03:56:59 <ski>   reverse :: [a] -> [a]
03:57:15 <ski> being polymorphic has to do with there being type variables (here `a') in its type
03:57:24 <ski> however, it's really that, in 
03:57:29 <ski>   reverse :: forall a. [a] -> [a]
03:57:51 <ski> there's a `forall', at the very front/top, and this is what indicates `reverse' is polymorphic
03:59:05 <ski> shall i continue ?
03:59:05 <zceejkr> Ok I think I understand. So basically there is a difference between (a -> a) and (forall a.a -> a). The second thing is what is polyorphic
03:59:32 <ski> yes
03:59:33 <zceejkr> sure, continue. I am with you.
04:00:28 <ski> although the type `forall a. a -> a' is not polymorphic. it's the values of that type which are polymorphic
04:00:48 <zceejkr> Got it.
04:01:55 <ski> (there are also polymorphic types, please don't confuse this with them. unfortunately, many people (including researchers) call types like `forall a. a -> a' "polymorphic". my personal opinion is that we should reserve that term for the values in this situation. there are dissenting opinions. i call types of the shape `forall a. ..a..', "universal types" or "`forall'-types")
04:02:37 <ski> (`take' is "polymorphic" ("many shaped") because it can "assume many shapes", can be used with lists of `Integers', with lists of lists of `Bool'eans, &c.)
04:04:32 <ski> (also, people sometimes call types like `Maybe', or `Maybe a' (involving a type variable) "polymorphic". i also consider this an abuse of terminology. `Maybe' is a parametric data type, a particular kind of type function (not function type). and `Maybe a' is a(n open) type (expression) (not a (type) function), depending on the type variable `a')
04:04:42 <ski> anyway, let's move on from these asides
04:05:22 <ski> hm, pondering whether to cover existentials, or higher-rank, first
04:06:15 <zceejkr> Up to you, I know nothing about both.
04:06:19 <ski> one could probably do either. "higher-rank" is a "complication" on uses of `forall'. while "existentials" introduce the "dual" notion of `exists'
04:06:34 <ski> i think i'll go higher-rank first
04:06:41 <zceejkr> cool.
04:06:53 <ski> hm, i suppose i could mention one more basic thing, before
04:06:55 <ski> consider
04:07:05 <ski>   sort :: Ord a => [a] -> [a]
04:07:09 <ski> which really means
04:07:12 <ski>   sort :: forall a. Ord a => [a] -> [a]
04:07:45 <ski> just as there's an implicit specialization, when using `sort', to specify which type `T' to use in place of the variable / placeholder `a'
04:08:08 <ski> there's also an implicit providal of evidence for the resulting `Ord T' constraint
04:08:15 <ski> so, one can imagine something like
04:08:18 <ski>   sort :: forall a. Ord a => [a] -> [a]
04:08:50 <ski>   sort @Integer :: Ord Integer => [Integer] -> [Integer]
04:09:34 <ski>   sort @Integer @{dictOrdInteger} :: [Integer] -> [Integer]
04:09:52 <ski> where `dictOrdInteger' is an internal name for the `instance Ord Integer where ...' declaration
04:10:18 <ski> generally, a declaration like
04:10:23 <ski>   sort :: forall a. Ord a => [a] -> [a]
04:10:34 <ski> is probably internally translated into something like
04:10:45 <ski>   sort :: forall a. DictOrd a -> [a] -> [a]
04:10:55 <ski> (note i replaced `=>' by `->')
04:11:02 <ski> where
04:11:28 <zceejkr> I guess this is why you can only have one instance in a context at a given time correct? So that ghc knows which one to use?
04:12:15 <ski>   data DictOrd a = MkDictOrd { compare :: a -> a -> Ordering
04:12:33 <ski>                              , (<=),(<),(>=),(>) :: a -> a -> a
04:12:36 <ski>                              , min,max :: a -> a -> a
04:12:39 <ski>                              }
04:12:43 <ski> @src Ord
04:12:44 <lambdabot> class (Eq a) => Ord a where
04:12:44 <lambdabot>     compare              :: a -> a -> Ordering
04:12:44 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:12:44 <lambdabot>     max, min             :: a -> a -> a
04:13:03 <ski> well, it should also include a `superEq :: DictEq a' field, actually
04:13:12 <ski> yes, zceejkr
04:13:50 <ski> so, type class constraints, in general, gets translated into passing a dictionary argument (sortof "vtable", if you want, although there are some differences)
04:13:57 <ski> this is called the "dictionary translation"
04:14:42 <ski> anyway, you can imagine how my definition of `elem' above would look, with explicit propagation of dictionaries for `Eq a'
04:15:00 <zceejkr> yes
04:15:28 <ski> i'll not delve any further into this, atm, unless you want to ask/say something about it. but this will be slightly relevant also for existentials, which is why i'm bringing it up
04:16:17 <ski> hm, so higher-rank
04:17:24 <ski> consider the following function
04:18:12 <ski>   experiment f = (f [False,True,False],f "True")
04:18:29 <ski> what could an appropriate type signature of `experiment' be ?
04:18:52 <ski> (this is quite openended, btw)
04:19:39 <zceejkr> sorry went to grab coffee. One moment
04:19:41 <ski> for concreteness, consider
04:19:55 <ski> > experiment reverse
04:19:58 <lambdabot>  ([False,True,False],"eurT")
04:19:59 <ski> > experiment sort
04:20:02 <lambdabot>  error:
04:20:02 <lambdabot>      • No instance for (Ord a) arising from a use of ‘sort’
04:20:02 <lambdabot>        Possible fix:
04:20:20 <ski> ah, that one doesn't work, right :)
04:20:26 <ski> > experiment (take 2)
04:20:29 <lambdabot>  ([False,True],"Tr")
04:21:19 <zceejkr> I guess f :: forall b.[a] -> b
04:21:27 <zceejkr> This would be my first guess
04:21:33 <zceejkr> Wait
04:21:34 <zceejkr> No
04:22:02 <zceejkr> forall a b.[a] -> b
04:22:09 <zceejkr> Something like this?
04:22:39 <ski> in my case, `f' always has to return a list, because of the type signature i used. however, one could imagine other signatures, with the same implementation of `experiment'
04:23:12 <ski> `forall a b. [a] -> b' is as useful as `forall a. [a] -> ()', iow hardly useful at all
04:23:53 <Nolrai> @pl (\ f -> g $ h . f)
04:23:53 <lambdabot> g . (h .)
04:24:12 <ski> anyway, the interesting thing to note here is that, in one case, `f' is applied to a list of `Bool'eans, while in the other case to a `String', iow a list of `Char'acters
04:24:21 <ski> zceejkr : you see this ?
04:24:39 <ski> looks legit, Nolrai
04:25:19 <zceejkr> Yes, so I guess we must find the "intersection" of properties of Bool and Char, this is the most tight type we can give to f?
04:25:51 <ski> so, what type of value is `f', here ?
04:26:21 <ski> e.g. `f' is not a list, `f' is not a pair, ...
04:26:23 <ski> what is `f' ?
04:26:26 <zceejkr> A polymorphic function value
04:26:30 <ski> yes !
04:26:46 <ski> this means that the signature of `experiment' ought to look something like
04:27:09 <ski>   experiment :: (forall a. [..a..] -> ..a..) -> ...
04:27:23 <ski> the specific signature that i used was
04:27:46 <ski> well, in fact, we can first say it must be something like
04:27:51 <ski>   experiment :: (forall a. [..a..] -> ..a..) -> (...,...)
04:27:52 <ski> even
04:28:02 <ski> the specific one i used was
04:28:06 <ski>   experiment :: (forall a. [a] -> [a]) -> ([Bool],String)
04:28:18 <ski> note that `experiment' here is not polymorphic !
04:28:29 <ski> (despite its signature involving a tyvar `a' !)
04:28:52 <ski> it's not `experiment' itself, but its argument (named `f' in the definition), which is polymorphic !
04:29:21 <zceejkr> I see.
04:29:25 <ski> we say that `experiment' is a "higher-rank" operation, in particular a "rank-two" operation
04:29:37 <Nolrai> @pl \ btor -> cf $ ca . (btor .)
04:29:38 <lambdabot> cf . (ca .) . (.)
04:30:37 <ski> `take' is polymorphic. the caller (or user) of `take' will decide which specific type to pick/choose. `take' itself has no say in the matter, has to be satisfied with, work for, any particular type that is chosen (and it can't determine which was chosen, either. it's agnostic in the element type)
04:31:51 <ski> similarly, the callee `sort' (or its implementor/producer) will have to work for any type that is picked, as long as it's an instance of `Ord' (that's the sole thing it can know about type chosen type)
04:32:57 <ski> otoh, in the case of `experiment', it is the callee (the implementation) which gets to pick `a', while the caller (/user/consumer) will have to produce a callback function that will have to accept any `a' that is chosen
04:34:20 <zceejkr> Right.
04:34:46 <ski> so, by having the `forall', not at the outside/front/top of a function arrow `->', as in `forall a. (..a.. -> ...)'; but rather having it to the left, inside, a function arrow `->', as in `(forall a. ..a..) -> ...', we've swapped who of the caller/user/consumer and the callee/implementor/producer gets to pick and choose `a', and who must make do with whatever choise is made
04:35:12 <ski> a value of type `forall a. ..a..' is rank one
04:35:21 <ski> a value of type `(forall a. ..a..) -> ...' is rank two
04:35:30 <ski> a value of type `((forall a. ..a..) -> ...) -> ...' is rank three
04:35:53 <ski> and so on. rank counts the (maximum) number of left-nestings, inside `->', until we reach a `forall'
04:36:33 <ski> `forall's indicating odd rank means the caller chooses. `forall's indicating even rank means the callee chooses
04:36:38 <zceejkr> So at rank3, is it again the caller that picks the a? 
04:36:55 <zceejkr> Yes I see.
04:37:07 <ski> moving inside, to the left of, `->', flips the rôles of caller/user/consumer with those of callee/implementor/producer
04:37:45 <ski> rank two is not that common. rank three is even more rare. i'm not sure i've seen rank four, but i imagine it might've been used
04:38:14 <zceejkr> What would be a simple example of rank2?
04:38:14 <ski> higher-rank is not something one reaches for that often. but sometimes one really needs it !
04:38:21 <ski> `experiment' above
04:38:25 <ski> i'll give another example
04:38:43 <ski>   turnAround :: (forall a. [a] -> [a]) -> ([String] -> [String])
04:38:57 <ski>   turnAround f = f . map f
04:39:08 <ski> @let turnAround :: (forall a. [a] -> [a]) -> ([String] -> [String]); turnAround f = f . map f
04:39:11 <lambdabot>  Defined.
04:40:06 <ski> > turnAround reverse ["This","is","a","dream"]
04:40:10 <lambdabot>  ["maerd","a","si","sihT"]
04:40:12 <ski> > turnAround (take 2) ["This","is","a","dream"]
04:40:16 <lambdabot>  ["Th","is"]
04:40:49 <ski> btw, can you figure out what signature to give to `experiment', in order to make also the `experiment sort' example to work ?
04:41:29 <ski> hm, i should say one more thing about rank two
04:42:04 <ski> as you saw, when we want to use an argument (typically, but not always, a function argument, a callback function) at more than one type, we need rank two
04:42:23 * hackage apecs 0.9.1 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.9.1 (jonascarpay)
04:42:42 <ski> but, one can also use it for information hiding
04:42:49 <ski> instead of having
04:42:59 <ski>   foo :: (..A..) -> ...
04:43:19 <ski> where `A' is an implementation detail, that one doesn't want to leak out into the interface, one can possibly use
04:43:27 <ski>   foo :: (forall a. ..a..) -> ...
04:43:31 <kuribas> so welsh is just english in reverse
04:44:09 <ski> that way, the caller can't mess around with the internals of the type `A', in the argument (possibly a callback), must treat `a' abstractly
04:44:32 <zceejkr>  experiment :: (forall a. Ord a => [a] -> [a]) -> ([Bool],String)
04:44:39 <ski> good, zceejkr :)
04:44:49 <ski> of course, one could continue to add stuff
04:45:16 <ski>   experiment :: (forall a. (Ord a,Enum a,Bounded a,..a..) => [a] -> [a]) -> ([Bool],String)
04:46:14 <ski> which makes `experiment' itself more general (can be applied to more functions). but the implementation becomes more restricted (`f' can only be used at types having all those instances)
04:46:41 <zceejkr> I see.
04:46:42 <ski> so, it's curious that, by adding detail to a type signature, one doesn't get a more specific operation, but rather a more general one
04:47:06 <ski> oh, i should also add that types of higher rank operations can't be inferred (in general)
04:47:18 <ski> so, you have to figure out the type signature you want, and write it yourself
04:47:55 <ski> (rank two can actually be inferred, but iirc it's a bit complicated, and GHC doesn't attempt to do this)
04:48:07 <ski> (rank three, however, can't be inferred)
04:48:25 <ski> also, one could easily have a version of `turnAround', like
04:48:41 <ski>   turnAround :: (forall a. [a] -> [a]) -> (forall a. [[a]] -> [[a]])
04:48:46 <ski>   turnAround f = f . map f
04:49:11 <ski> that both has one `forall' at rank two, and one at rank one
04:49:30 <ski> we still say this `turnAround' is rank two, taking the maximum
04:49:32 <ski> also note that
04:49:36 <ski>   turnAround :: (forall a. [a] -> [a]) -> (forall a. [[a]] -> [[a]])
04:49:40 <ski> is the same thing as
04:49:51 <ski>   turnAround :: forall a. (forall a. [a] -> [a]) -> ([[a]] -> [[a]])
04:49:57 <ski> or, for clarity, renaming into
04:50:05 <ski>   turnAround :: forall b. (forall a. [a] -> [a]) -> ([[b]] -> [[b]])
04:50:07 <zceejkr> I see. So this is why it is rank 1
04:50:25 <zceejkr> Got it.
04:50:43 <ski> iow, this version of `turnAround' is polymorphic (and also higher-rank), while `experiment' above wasn't polymorphic (only rank two)
04:50:59 <ski> `turnAround' is still rank two (we take the maximum)
04:51:45 <ski> in general, `... -> (forall a. ..a..)' is equivalent to `forall a. (... -> ..a..)' (where `a' is assumed not to occur (free) in `...', otherwise we run into scoping problems)
04:51:55 <ski> consider
04:52:04 <ski>   foo :: ... -> (forall a. ..a..)
04:52:13 <ski>   foo x @a = ..a..x..
04:52:15 <ski> vs.
04:52:25 <ski>   foo :: forall a. (... -> ..a..)
04:52:32 <ski>   foo @a x = ..a..x..
04:53:13 <ski> if we don't mention `a' in the body `..a..x..', then if we elide the (imagined) explicit `TypeAbstraction' syntax, both of these implementations becomes
04:53:18 <ski>   foo x = ..x..
04:53:32 <ski> hence why i say `... -> (forall a. ..a..)' is equivalent to `forall a. (... -> ..a..)'
04:54:03 <ski> they only differ in the relative order of the value argument `x' and the type argument `a'. and, normally, type arguments aren't written explicitly
04:54:50 <ski> (a polymorphic value of type `forall a. ..a..' can be thought of sortof as a function, except it doesn't take a value as input, but rather a type, call it `a', and then has to return a value of type `..a..')
04:55:19 <zceejkr> right
04:56:09 <ski> (in the typical implementation, nothing will actually be passed at run-time, for this type `a' (hence `take' can't figure out what `a' is, at run-time). however, one could imagine an implementation that passed some info. e.g. the size of, and maybe description of layout of, values of type `a')
04:57:34 <ski> so, having a `forall' in the return type, like `... -> (forall a. ..a..)' is "trivial", "nothing new", in the sense that this behaves just like `forall a. (... -> ..a..)', an ordinary universal type, type of polymorphic values
04:58:15 <ski> while, having a `forall' in the argument type, like `(forall a. ..a..) -> ..." is "nontrivial", is "something new". is higher-rank (rank two in this case)
05:00:33 <ski> hm, i was looking around if i could find a somewhat simple example of using rank two for information hiding .. but i can't seem to find it atm
05:00:49 <ski> (it was on <lpaste.net>, but that's dead now ..)
05:01:05 <zceejkr> :(
05:01:23 <ski> hm, i could perhaps sketch it from memory
05:01:43 <Nolrai> @pl \ c -> mk $ \ a_to_r -> run c $ \ c' -> run c a_to_r
05:01:43 <lambdabot> mk . liftM2 (.) run ((const .) . run)
05:01:48 <ski> i was exploring ideas for instrumenting code to give a kind of evaluation log
05:02:02 <ski> as an example, i had
05:02:11 <ski>   fib :: Integer -> Integer
05:02:17 <Nolrai> @pl \ c -> mk $ \ a_to_r -> run c $ \ c' -> run c' a_to_r
05:02:17 <lambdabot> mk . (. flip run) . run
05:02:22 <ski> computing fibonacci numbers, recursively, like so
05:02:24 <ski>   fib 0 = 0
05:02:27 <ski>   fib 1 = 1
05:02:34 <ski>   fib n = fib (n-1) + fib (n-2)
05:03:07 <ski> and i wanted to build a call tree, showing the structure of the recursive calls (with association of input to output at each call)
05:03:13 <ski> so, i had something like
05:03:24 <ski>   data Tree a = Node a [Tree a]
05:03:50 <ski> and wanted to use `Tree (Input,Output)' as a trace of a call to a function of type `Input -> Output'
05:03:57 <ski> so, in this case i wanted to get
05:04:17 <ski>   tracedFib :: Integer -> (Integer,Tree (Integer,Integer))
05:04:19 <ski> or, defining
05:04:30 <ski>   type Traced i o = (i,Tree (i,o))
05:04:39 <ski> we can just say
05:04:50 <ski>   tracedFib :: Integer -> Traced Integer Integer
05:04:55 <ski> makes sense, zceejkr ?
05:05:14 <zceejkr> yes
05:05:23 <hpc> you want (o, Tree (i,o)) i think
05:05:30 <ski> yea, i do, ty
05:05:35 <hpc> neat
05:05:47 <zceejkr> yes was just thinking of this
05:05:47 <ski> so, i wanted to "intercept" recursive calls
05:05:53 <hpc> i think that only traces recursive calls
05:06:00 <ski> or "instrument recursion"
05:06:13 <ski> yes, hpc. that's what i had in mind
05:06:24 <zceejkr> hpc?
05:06:29 <hpc> imagine two mutually recursive things
05:06:34 <ski> only recursive calls of `fib', in fact (so no mutual recursion, or recursion inside recursion (double recursion))
05:06:39 <hpc> like some/many in parsers
05:06:45 <hpc> that'd be a nice extension of this
05:06:54 <ski> this is just a toy example, to explore the idea
05:07:20 <ski> so, the obvious (?) thing to try would be to do something with `fix'
05:07:22 <Ianulus> What happened to `stack solve` and `stack solver` as described in the haskellstack.org docs? I don't have these commands available (stack v2.1.3.1).
05:07:27 <ski>   fix :: (a -> a) -> a
05:07:32 <ski>   fix f = x
05:07:34 <ski>     where
05:07:37 <ski>     x = f x
05:08:25 <ski> if we define
05:08:40 <ski>   fibThen :: (Integer -> Integer) -> Integer -> Integer
05:08:45 <ski>   fibThen fib 0 = 0
05:08:47 <ski>   fibThen fib 1 = 1
05:08:56 <ski>   fibThen fib n = fib (n - 1) + fib (n - 2)
05:09:06 <ski> then we can redefine the original `fib' as
05:09:12 <ski>   fib = fix fibThen
05:09:26 <ski> so the recursion happens in `fix', not in `fibThen'
05:09:42 <merijn> ski: I think that's less confusing if you don't name the new binding and function variable the same ;)
05:09:46 <ski> makes sense, zceejkr ? have you seen `fix' before ?
05:09:59 <merijn> Ianulus: Stack solve was removed in stack 2.0
05:10:24 <ski> well, perhaps, merijn. but the idea was that the actual meat of the implementation (moved to `fibThen') should be changed as little as possible
05:10:41 <zceejkr> I have seen fix before, but I am a little confused here.
05:11:06 <zceejkr> So fix takes a function and applies it to itself?
05:11:08 <ski> `fibThen' is just "one layer of `fib'". it expects to be passed "the real `fib'" as argument
05:11:28 <ski> and, we get "the real `fib'", by passing "the real `fib'" as argument to `fibThen'
05:11:38 <ski> we could also define "the real `fib'" as
05:11:42 <ski>   fib = fibThen fib
05:11:43 <ski> or
05:11:46 <ski>   fib n = fibThen fib n
05:11:50 <ski> bypassing `fix'
05:12:15 <ski> > fix (\xs -> 0 : 1 : 2 : xs)
05:12:18 <lambdabot>  [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1...
05:12:43 <ski> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
05:12:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:13:23 <ski> > fix (\fib n -> case n of 0 -> 0; 1 -> 1; _ -> fib (n - 1) + fib (n - 2))
05:13:27 <lambdabot>  <Integer -> Integer>
05:13:29 <gentauro> > :t fix
05:13:29 <ski> > fix (\fib n -> case n of 0 -> 0; 1 -> 1; _ -> fib (n - 1) + fib (n - 2)) 12
05:13:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:13:33 <lambdabot>  144
05:13:37 <ski> @type fix
05:13:39 <lambdabot> (a -> a) -> a
05:13:48 <gentauro> % :t fix
05:13:48 <yahb> gentauro: forall {a}. (a -> a) -> a
05:13:56 <gentauro> % :i fix
05:13:56 <yahb> gentauro: fix :: forall a. (a -> a) -> a -- Defined in `Data.Function'
05:14:00 <Ianulus> merijn: thanks
05:14:01 <ski> > fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 12
05:14:02 <gentauro> yahb: thx
05:14:03 <lambdabot>  479001600
05:15:29 <gentauro> 14:11 < ski> > fix (\xs -> 0 : 1 : 2 : xs)
05:15:33 <gentauro> looks like magic
05:15:38 <gentauro> ski: can you explain it?
05:16:08 <ski> > fix (\fibs -> listArray (0,12) [case n of 0 -> 0; 1 -> 1; _ -> fibs ! (n - 1) + fibs ! (n - 2) | n <- range (0,12)]) ! 12
05:16:11 <lambdabot>  144
05:16:27 <gentauro> how does it become an ∞ inf (cycle) of [0 .. 2]
05:16:44 <ski> zceejkr : that last ^ is an example of (top-down) "dynamic programming". recursively constructing an array in terms of itself
05:17:12 <ski>      fix (\xs -> 0 : 1 : 2 : xs)
05:17:14 <merijn> Ianulus: If you relied on stack solve a lot you could consider just switching to v2-build
05:17:27 <Ianulus> @mer
05:17:27 <lambdabot> Maybe you meant: vera msg more metar let arr
05:17:31 <ski>   =  xs  where  xs = (\xs -> 0 : 1 : 2 : xs) xs
05:17:37 <ski>   =  xs  where  xs = 0 : 1 : 2 : xs
05:17:44 <ski>   =  0 : 1 : 2 : xs  where  xs = 0 : 1 : 2 : xs
05:17:49 <ski>   =  0 : 1 : 2 : 0 : 1 : 2 : xs  where  xs = 0 : 1 : 2 : xs
05:17:56 <ski>   =  0 : 1 : 2 : 0 : 1 : 2 : 0 : 1 : 2 : xs  where  xs = 0 : 1 : 2 : xs
05:18:21 <Ianulus> merijn: thanks, but I'm learning & just working through the stack guide for now.
05:19:37 <gentauro> ski_: thx
05:20:12 <niko> ski__: i removed the kline
05:20:32 <ski> sorry, back
05:21:03 <niko> ski__: if you want to use the unkline command of Sigyn you must be opped on the channel when you call it
05:21:06 <ski> ty, niko
05:21:13 <ski> yea, i just remembered that
05:22:15 <ski> (this has, occasionally, happened before. also for other users. fortunately, it's relatively rare)
05:22:46 <ski> (in any case, i wasn't about to continue that explanation of that `fix' example)
05:23:00 <ski> gentauro : makes sense, now ?
05:25:16 <zceejkr> ski: I have to depart now. Thank you for the lecture. If you will have time in the future, I would like to hear about exsistentials.
05:26:34 <ski> zceejkr : sure
05:26:36 <zceejkr> Also, do you accept donations? I can post a public-key to encrypt your ethereum address (if you have it) and send it back. I would like to donate some change :)
05:27:05 <ski> i have no so thing set up, no
05:27:16 <ski> zceejkr : i was basically done with higher-rank
05:27:23 <ski> zceejkr : so, next time, we can start with existentials
05:27:48 <zceejkr> ski: awesome. Looking forward. Goodbye everyone.
05:37:16 <gentauro> 14:22 < ski> gentauro : makes sense, now ?
05:37:23 <gentauro> yes, that's why I wrote thx :)
05:42:23 <ski> oh, sorry, i missed that, gentauro
05:43:50 <gentauro> ski: no probs :)
05:43:57 <gentauro> thanks again for the `mindblowing` xD
05:44:16 <ski> yw :)
05:46:38 <ski> hm, i guess i wasn't quite done with the implementation hiding example of rank two. but i suppose i'll maybe continue with that next time, with zceejkr
06:15:41 <fishooter> hi, how can I apply an operation instead a "double" monad?
06:16:02 <fishooter> I have a type of x=IO (Maybe Int)
06:16:20 <fishooter> and I'd like to turn it into y=IO (Maybe (Int, String))
06:16:29 <mmaruseacph2> :t lift
06:16:32 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
06:16:41 <mmaruseacph2> :t fmap
06:16:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:16:54 <mmaruseacph2> hints above, fishooter 
06:17:28 <berndl> fishooter: two fmaps should do it.
06:20:34 <int-e> :t fmap fmap fmap
06:20:36 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
06:21:14 <lyxia> :t fmap fmap fmap fmap fmap fmap
06:21:16 <lambdabot> (Functor f1, Functor f2) => (a1 -> a2 -> b) -> f1 a1 -> f1 (f2 a2 -> f2 b)
06:21:43 <merijn> fishooter: So your question has multiple answers
06:22:38 <int-e> lyxia: basically it's just a reminder that (.) = fmap = liftM from the reader monad.
06:22:38 <hyperisco> :t flip fmap flip fmap flip fmap flip fmap flip fmap
06:22:38 <merijn> fishooter: 1) you could do double fmap (as suggested), 2) 2 nested functors/applicatives are automatically also a functor/applicative, so there is a newtype you can use (Data.Functor.Compose), 3) monad transformers, because your example maps too "MaybeT IO Int"
06:22:40 <lambdabot> b -> (a -> c) -> (b -> a) -> c
06:22:54 <merijn> fishooter: Which of these is most convenient depends on the context
06:23:10 <merijn> @let import Data.Functor.Compose (Compose(..))
06:23:12 <lambdabot>  Defined.
06:23:51 <merijn> > getCompose $ (,) <$> Compose (Just [1,2]) <*> Compose (Just [3,4])
06:23:53 <lambdabot>  Just [(1,3),(1,4),(2,3),(2,4)]
06:24:04 <merijn> > getCompose $ (,) <$> Compose (Just [1,2]) <*> Compose Nothing
06:24:08 <lambdabot>  Nothing
06:24:11 <hyperisco> :t fmap flip fmap flip fmap flip
06:24:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:24:40 <merijn> fishooter: Where "newtype Compose f g a = Compose { getCompose :: f (g a) }"
06:24:54 <hyperisco> Could we have a bot that just occasionally prints weird cycles like this?
06:25:07 <hyperisco> Like, whenever it gets quiet, it just pops one out
06:25:17 <fishooter> uh, that makes my head hurt a little. Is it bad to just unwrap the value from IO and then just return?
06:25:31 <merijn> fishooter: Naah, that's fine :)
06:26:08 <fishooter> I'm implementing show-ref command from git
06:26:09 <fishooter> https://repl.it/@sustrmic/BigTwinSandbox
06:26:11 <merijn> fishooter: Stuff like Compose/MaybeT is only worth it if you have a lot of code like this
06:26:25 <fishooter> what I was asking about was the parseRefEntry part
06:26:40 <fishooter> I just used the hash <- ... return
06:26:56 <fishooter> because there is too many things going on at once
06:27:01 <merijn> fishooter: What it's doing is basically: "instance (Functor f, Functor g) => Functor (Compose f g) where fmap f (Compose gInF) = Compose (fmap (fmap f) gInF)"
06:27:39 <boxscape> > do {x <- Just 5; return (succ 6) }
06:27:42 <lambdabot>  Just 7
06:27:44 <boxscape> > fmap succ (Just 5)
06:27:47 <lambdabot>  Just 6
06:27:52 <boxscape> uh okay I messed that up a bit
06:27:55 <int-e> lyxia: It's kind of funny that the sequence  fmap, fmap fmap, fmap fmap fmap, ... eventually runs into a cycle... with 10 fmaps doing the same as 6.
06:28:25 <merijn> fishooter: Oh, you can make that simpler/cleaner :)
06:28:43 <fishooter> the code I've sent?
06:28:58 <merijn> fishooter: If you change hashRefTuple to return a list, so: "hashRefTuple hash = [(hash, ref)]"
06:29:20 <merijn> fishooter: Then you can do "maybe [] hashRefTuple <$> refResolve repo ref"
06:29:25 <merijn> :t maybe
06:29:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:29:45 <fishooter> ah ok
06:30:56 <merijn> fishooter: "maybe" and "fromMaybe" are your friends if you want to turn "Maybe a" into "something that's not Maybe" :)
06:30:58 <fishooter> IMHO it's good to have just 2-3 things going on in one statement, the maybe has too many of them :)
06:31:32 <boxscape> hm, I don't think haskell has statements
06:31:56 <fishooter> /statement/line of code/
06:32:40 <merijn> fishooter: You can put it in a separate line of the where
06:34:27 <merijn> Or keep the "hash <- ..." and change the last line to "return $ maybe [] hashRefTuple hash"
06:41:06 <fishooter> ok
06:48:43 <int-e> lyxia: which is a fun equational reasoning exercise: http://paste.debian.net/1130980/
06:49:55 <boxscape> now the next question is can you prove it *in haskell* using https://hackage.haskell.org/package/equational-reasoning ;)
06:51:53 <int-e> boxscape: Ugh, as if interactive theorem proving wasn't hard enough in the tools actually made for that purpose.
06:52:25 <boxscape> heh, I find it kind of enjoyable in haskell precisely because it means pushing it to its limits
06:53:16 <int-e> (and without looking I'd be worried about the first and last steps, which need type checking (and which I didn't explain because I just replaced fmap by (.) in ghci as long as it didn't change the inferred type)
06:54:38 <int-e> boxscape: It's probably okay as long as you a) keep to proving simple things and b) do that as a hobby.
06:55:03 <boxscape> yes I wouldn't want to rely on it
06:55:06 <boxscape> for something that matters
06:55:29 <merijn> This sounds like the TIS-100 of theorem proving :p
06:55:57 <merijn> That might actually be a good Zachtronics competitor :p
06:56:46 <boxscape> I've started going through TAPL while trying to prove the theorems in it in haskell, so far after a few days I'm only on page thirty-something but hey at least I've discovered a ghc bug in the process
06:56:51 <int-e> merijn: Do you remember The Incredible Proof machine?
06:57:00 <merijn> int-e: No?
06:57:08 <boxscape> I remember that
06:57:33 <boxscape> http://incredible.pm/
07:13:28 <fishooter> I have bunch of code like this https://repl.it/@sustrmic/OrdinaryKeenCopyrightinfringement
07:13:40 <fishooter> how can I make it so that I don't repeat the repo check all the time?
07:13:48 <fishooter> I thought I could pass a lambda with no arguments
07:13:53 <fishooter> but im not sure how to write it
07:14:08 <fishooter> how to do it in a **simple way** ? :)
07:14:24 <fishooter> I read about reader monad, but I don't want to get into that yet
07:16:29 <sshine> fishooter, since your 'Nothing' cases have a string that explains the error, using Either might be a better approach here.
07:20:44 <Cale> There are a whole bunch of approaches you can take. One would be to make up some exception types and throw them, since it seems like you're just printing error messages here, and I'm not sure if/how your program continues from that point. As sshine mentions, it might be also be best to use Either String to deal with the errors, so you'd either get Left of some error message or Right of the objectData string (and then 
07:20:44 <Cale> handle printing of things outside of this)
07:21:52 <Cale> If you're constantly doing this same  repo <- cwdRepo; case repo of ... thing
07:22:27 <Cale> You might write a function  withCwdRepo :: (Repo -> IO ()) -> IO ()
07:22:30 <Cale> which just does that bit
07:22:47 <Cale> So that you could write  withCwdRepo $ \repo -> do ...
07:23:02 <Cale> and withCwdRepo will deal with the potential failure
07:23:31 <sshine> fishooter, here's another example of something you could do: https://gist.github.com/sshine/558ad5a682ff6057f7e3dacf47154927
07:24:16 <sshine> I didn't see Cale's suggestion of withCwdRepo, but that sounds even better. :)
07:24:34 <sshine> but this was my take on how you might avoid nested case-ofs, since this smells of wanting to abstract out error handling.
07:26:04 <Cale> Yeah, EitherT is an option, though introducing a transformer is usually something I hesitate to do until I have a sense of a larger amount of the stuff that's going on. There's a lot of stuff which is made more awkward as soon as you leave IO proper, so your first monad transformer is not always worth it (but your second usually is :)
07:30:54 * hackage network-uri 2.6.3.0 - URI manipulation  https://hackage.haskell.org/package/network-uri-2.6.3.0 (EzraCooper)
07:31:32 <fishooter> hmm I think I'll stick to locally thrown exceptions
07:34:43 <fishooter> and withCwdRepo
07:35:05 <texasmynsted> why use locally thrown exceptions?
07:35:10 <fishooter> maybe later ill try to use the EitherT, but it seems a bit complicated
07:36:04 <fishooter> I'm not sure, is that the best way to just print error message and quit program?
07:36:19 <merijn> fishooter: Well, you can do just that :p
07:36:45 <fishooter> so I just use: error "messge"
07:36:46 <merijn> fishooter: System.Exit has "exitFailure :: IO a" which exits the program with an error return
07:36:48 <fishooter> right?
07:37:03 <merijn> fishooter: error is an awful function best avoided
07:37:10 <fishooter> :D
07:37:22 <texasmynsted> fishooter: There is value in modeling your types in a way that includes the idea that they may not produce what you want. 
07:37:42 <fishooter> definitely
07:37:47 <merijn> fishooter: I mean I literally do just: putStrLn "My error message" >> exitFailure
07:37:58 <fishooter> I try to use Maybe types
07:38:07 <fishooter> so I have things like IO Maybe Whatever
07:38:18 <merijn> texasmynsted: Sometimes there's also lots of value in *not* doing that ;)
07:38:21 <fishooter> ah ok
07:38:53 <solonarv> merijn: if you want to be more correct, you should print to stderr instead of stdout
07:39:09 <merijn> solonarv: Sure, or even better use some form of systematic logging
07:39:10 <solonarv> also, that's already packaged up as a handy 'die' function in System.Exit
07:39:11 <texasmynsted> Maybe try it both ways and see which you like better (after you refine your code)
07:39:22 <merijn> solonarv: in reality I use "logError" but that doesn't help beginners :p
07:39:34 <solonarv> 'die' is about as simple as it gets, tbh
07:40:13 <solonarv> 'die :: String -> IO a ' - Write given error message to stderr and terminate with exitFailure.
07:44:31 <fishooter> yes, die seems better
07:58:29 <texasmynsted> :-)
08:05:02 <ysangkok> apropos 'die', first time haskell gives me a perl flashback :O
08:13:50 <unclechu> hi. is there any way to write a data type which contains some few polymorphic functions?
08:13:50 <unclechu> like this `data F = F (forall m. SomeMonad m => Int -> m Int) (forall m. SomeMonad m => m Bool)`?
08:14:30 <merijn> unclechu: With RankNTypes that should "just work"?
08:17:04 <unclechu> merijn: sry, i mean i can easily define it, but using it is not that obvious to me
08:17:32 <unclechu> because i'm getting "ambiguous type variable" errors in the module i'm trying to use those functions
08:17:48 <merijn> unclechu: Do you have a minimal example?
08:20:47 <boxscape> @djinn ((a -> b) -> a) -> a
08:20:48 <lambdabot> -- f cannot be realized.
08:20:51 <boxscape> hmm
08:21:23 <Taneb> :t calCC
08:21:25 <lambdabot> error:
08:21:25 <lambdabot>     • Variable not in scope: calCC
08:21:25 <lambdabot>     • Perhaps you meant ‘callCC’ (imported from Control.Monad.Cont)
08:21:29 <Taneb> :t callCC
08:21:30 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
08:22:42 <dminuoso> Mmm, I recall there was another monad transformer that could be used instead of ContT to avoid deeply nested callbacks. Which one was that?
08:23:07 <merijn> dminuoso: Managed?
08:23:08 <boxscape> thing is, I think the general function should exist because it looks to me like the statement "((a => b) => a)" is equivalent to the statement "a", but I haven't been able to prove it in http://incredible.pm/, so I was hoping djinn could just show me a proof
08:23:19 <dminuoso> merijn: Mmm no. It was some category-fu thing.
08:25:01 <dminuoso> merijn: Oh hold on, Managed is just Codensity.
08:25:27 <dminuoso> Yeah, Codensity was it.
08:26:25 <boxscape> might be that it's not possible to prove with intuitionistic type theory, the prove I think I have uses the law of the excluded middle. Though it looks to me like the task in incredible.pm requires it to be provable
08:26:42 <boxscape> s/the prove/the proof
08:27:48 <Taneb> It's equivalent to the axiom of exlcuded middle I think
08:28:47 <boxscape> Ah turns out I missed something really obvious in the task, so I don't have to prove that after all
08:28:54 <boxscape> interesting Taneb
08:28:59 <Taneb> https://en.wikipedia.org/wiki/Peirce%27s_law
08:29:12 <boxscape> thansk
08:29:32 <boxscape> oh the wiki page even mentions call/cc
08:44:13 <boxscape> :t \(p, join -> q) -> q (p q)
08:44:15 <lambdabot> ((t1 -> t2) -> t1, t1 -> t1 -> t2) -> t2
08:44:21 <boxscape> this is what I actually had to prove
08:48:06 <boxscape> % lemma = \(p, join -> q) -> q (p q)
08:48:07 <yahb> boxscape: 
08:48:21 <boxscape> % lemma @Int @String (\f -> length (f 24)) ((show .) . (,))
08:48:21 <yahb> boxscape: ; <interactive>:81:1: error:; * Cannot apply expression of type `((t10 -> t20) -> t10, t10 -> t10 -> t20) -> t20'; to a visible type argument `Int'; * In the expression: lemma @Int @String (\ f -> length (f 24)) ((show .) . (,)); In an equation for `it': it = lemma @Int @String (\ f -> length (f 24)) ((show .) . (,))
08:48:27 <boxscape> ah, right
08:48:31 <boxscape> need a typesig
08:48:43 <boxscape> % lemma (\f -> length (f 24)) ((show .) . (,))
08:48:44 <yahb> boxscape: ; <interactive>:82:8: error:; * Couldn't match expected type `((t10 -> (() -> () -> String) -> t) -> t10, t10 -> t10 -> (() -> () -> String) -> t)' with actual type `(Integer -> [a0]) -> Int'; * The lambda expression `\ f -> length (f 24)' has one argument,; but its type `((t10 -> (() -> () -> String) -> t) -> t10, t10 -> t10 -> (() -> () -> String) -> t)' has none; In the first arg
08:50:02 <boxscape> % let lemma :: ((t1 -> t2) -> t1, t1 -> t1 -> t2) -> t2; lemma = \(p, join -> q) -> q (p q) in lemma (\f -> length (f 24), (show .) . (,))
08:50:02 <yahb> boxscape: "(7,7)"
08:57:09 <boxscape> somehow I find it fairly difficult to follow what this function actually oes
08:57:12 <boxscape> s/oes/does
08:57:52 <heatsink> you mean call/cc?
08:58:21 <boxscape> I mean \(p, join -> q) -> q (p q) but from a cursory glance at call/cc it looks more difficult to understand
09:01:06 <deni> is there a MonadLogger Instance for Servant's Handler somewhere that I can use for inspiration?
09:05:25 <e> w 51
09:05:26 <e> oops
09:05:56 <dminuoso> deni: Just use hoistServerWithContext
09:06:33 <deni> dminuoso: I'm already using that for auth and readerT
09:06:34 <dminuoso> deni: If you bury ServantError into IO exceptions (and recatch them in your natural transformation), you can get a lightweight LoggingT handler :)
09:06:46 <dminuoso> deni: Great, bury a LoggingT in your monad stack then
09:07:15 <deni> dminuoso: like so ` type AppM = ReaderT Config (LoggingT Handler)` that's what I already have
09:07:17 <dminuoso> deni: Just ensure its ontop of IO no Handler.
09:07:25 <dminuoso> deni: Yeah that wont work
09:07:59 <dminuoso> deni: Make it so its `ReaderT Config (LoggingT IO)` and feed the ServantError through IO exceptions. Then your stack is MonadUnliftable and you get MonadLogger for free.
09:08:08 <dminuoso> *MonadUnliftIOable
09:08:22 <deni> yeah I'm trying to run it like so runStdoutLoggingT $ runReaderT app cfg but that doesn't work because there's not MonadLogger instance for IO
09:08:56 <dminuoso> deni: Let me show you :)
09:09:10 <dminuoso> deni:  https://gist.github.com/dminuoso/cc799cae264c45538fc8b3a2d4cc6e8d
09:09:11 <deni> yeah I'm a bit lost in the whole monad transformer stack...
09:09:45 <dminuoso> deni: This is for some `newtype FreyjaM a = FreyjaM { runFreyjaM :: ReaderT Env (LoggingT IO) a }`
09:10:10 <dminuoso> deni: Note that: 170:catchRemEx :: forall a. FreyjaM a -> FreyjaM (Either ServerError a)
09:10:27 <dminuoso> (That's the trick you need, and then just ensure you throwIO your servant errors)
09:11:10 <dminuoso> deni: There's other techniques you could do though. You can make a custom MonadLogger instance, with the appropriate logging function buried in your environment.
09:11:39 <deni> dminuoso: I was hopping to make a MonadLogger Handler instance but I'm lost as to how to get everything aligned
09:12:01 <deni> to be frank this is precisely why I don't like monad tranformers... it's too hard to follow when I have more than one or two layers
09:12:19 <dminuoso> deni: If you have just ReaderT and LoggingT, things remain simple. :)
09:12:30 <merijn> deni: Note that MonadLogger and LoggingT are mostly orthogonal
09:12:43 <deni> dminuoso: why can't I just add an orhpan instance for MonadLogger Handler?
09:12:52 <merijn> deni: LoggingT exists to give you an easy things to dump in there 
09:12:59 <dminuoso> deni: Because Handler has no logging capabilities.
09:13:09 <merijn> deni: Just newtype your monad stack and define a MonadLogger for your newtype?
09:13:11 <dminuoso> deni: Unless you like having global variables carrying the logger.
09:13:43 <dminuoso> deni: I suppose my motivation is rather that Handler is not MonadUnliftIO-able, which makes it just *suck* the moment you have functions with IO in negative positions.
09:13:50 <dminuoso> (All the rest is derived from that)
09:15:19 <deni> dminuoso: hmmm I'll need to think about this a bit more.... not sure what the quickest solution is right now
09:15:40 <deni> merijn: "just" is the keyword here
09:17:17 <deni> it appears to me that fastlogger has a much nicer integration with servant... from the docs at least
09:17:45 <deni> probably because it's just IO and then logging in handlers is just a matter of liftIO 
09:18:00 <unclechu> merijn: now it's working with polymorphic functions, it seems previously i did something wrong and somehow misguided myself
09:18:08 <merijn> unclechu: \o/
09:19:14 <unclechu> maybe because i was trying to use two layers of `ReaderT`
09:20:28 <unclechu> later i realized it's not possible due to functional dependency between `r` and `m`
09:20:51 <unclechu> i mean it's not possible to use `MonadReader` with more than one layer of `ReaderT`
09:21:16 <merijn> unclechu: If you want multiple ReaderT you probably want to just define your own newtype with a convenient interface and use that instead
09:21:47 <merijn> I'm getting more and more convinced that any form of MonadReader/MonadState/etc. in your code are just pain points waiting to happen
09:22:52 <unclechu> merijn: i just defined my own additional type class to solve it. what would you do instead?
09:23:20 <xavo[m]> > \(p, join -> q) -> q (p q)
09:23:20 <xavo[m]> boxscape: bit late but what's that syntax? haven't seen it before 
09:23:23 <lambdabot>  error:
09:23:23 <lambdabot>      • No instance for (Typeable t0)
09:23:23 <lambdabot>          arising from a use of ‘show_M435671881888946291611975’
09:23:34 <xavo[m]> oops lol
09:24:04 <xavo[m]> @type \(p, join -> q) -> q (p q)
09:24:06 <lambdabot> ((t1 -> t2) -> t1, t1 -> t1 -> t2) -> t2
09:24:14 <Taneb> xavo[m]: ViewPatterns I think
09:24:15 <xavo[m]> i don't see how this tysig happens at all
09:24:37 <Taneb> :t (\((*2) -> x) -> x)) 4
09:24:39 <lambdabot> error: parse error on input ‘)’
09:24:46 <Taneb> > (\((*2) -> x) -> x) 4
09:24:49 <lambdabot>  8
09:25:05 <xavo[m]> ohh, tt
09:25:16 <xavo[m]> s/t$/y/
09:25:26 <merijn> unclechu: Defining a typeclass with a specific purpose is what I would do (well and an explicit newtype to hide the ReaderT implementation details)
09:31:52 <deni> dminuoso: merijn I'm going to punt on the issue for now. In the future I'll likely just add another layer to the custom AppT transformer and somehow add an instance for it. But for now I just needed a way to my upstream exception alerting to have a fallback to basically putStrLn...so ¯\_(ツ)_/¯
09:36:24 * hackage dzen-dhall 1.0.2 - Configure dzen2 bars in Dhall language  https://hackage.haskell.org/package/dzen-dhall-1.0.2 (klntsky)
09:52:24 * hackage amqp-utils 0.4.4.0 - Generic Haskell AMQP tools  https://hackage.haskell.org/package/amqp-utils-0.4.4.0 (woffs)
09:53:53 * hackage profunctor-arrows 0.0.0.3 - Profunctor arrows  https://hackage.haskell.org/package/profunctor-arrows-0.0.0.3 (cmk)
10:09:30 <hexo_> hi folks, i'm having troubles with acid-state: Data.Acid.Log: Failed reading: Invalid hash
10:10:06 <hexo_> i believe it got corrupted on ENOSPC
10:10:56 <hexo_> so, please, do you have any idea how to recover it?
10:13:16 <hexo_> i also had a checkpointing and archiving thread running, so i think that actual data could be ok
10:13:54 * hackage profunctor-optics 0.0.1 - An optics library compatible with the typeclasses in 'profunctors'.  https://hackage.haskell.org/package/profunctor-optics-0.0.1 (cmk)
10:14:19 <hexo_> i've run into this situation before, and didn't solve it, so i've just deleted DB and went fresh
10:15:13 <hexo_> but that wouldn't be possible in production
10:16:15 <geekosaur> if you're running out of space in production, you have bigger problems
10:16:40 <geekosaur> (also put the log somewhere less likely to do so)
10:17:10 <hexo_> i'd say, on ENOSPC it should just stop writing and not get corrupted
10:17:54 <hexo_> i don't want to seem mean or anything
10:18:08 <hexo_> but you know... this is wierd
10:18:38 <hexo_> burn all my data instead of not writing some
10:18:53 <d34df00d> Ugh, sometimes I regret haskell doesn't have mixfix operators out of the box.
10:18:55 <d34df00d> And emulating them is pita.
10:19:18 <monochrom> Emulate s-expressions instead :)
10:22:43 <boxscape> well, at least as a compromise we got *one* mixfix operator
10:22:46 <boxscape> if-then-else
10:23:12 <monochrom> That is like the worst of both worlds because it's the least needed mixfix operator :)
10:23:30 <boxscape> I agree
10:23:47 <glguy> Which is the most needed?
10:24:08 <amalloy> philosphically, is case/of an operator?
10:24:45 <monochrom> That one is beyond mixfix operator :)  Like mixfix but variable length.
10:25:12 * glguy fires up the butterfly meme macro
10:26:37 <boxscape> if variable length is the only thing preventing case/of from counting as a mixfix operator then I suppose \ ... -> should also count
10:27:11 <boxscape> and forall ... . on the type level
10:27:19 <hexo_> aaaand ( ... ) ?
10:27:42 <hexo_> eh, no
10:28:09 <boxscape> (then again, forall isn't part of the standard)
10:28:15 <monochrom> Hahaha I googled for "butterfly meme" and while there are the standard guy-and-butterfly-and-"is this a pigeon" pictures, there is also the dual: a girl-and-pigeon-and-"is this a butterfly" picture
10:28:47 <d34df00d> glguy: right now I could definitely use a ternary operator to express "this parser on this input yields this output".
10:29:04 <d34df00d> I can't even have partially applied backticked functions, meh.
10:29:21 <d34df00d> Like "foo" `parse myParser` FooAST
10:29:37 <boxscape> "foo" & parse myParser $ FooAST
10:29:45 <d34df00d> Hmm.
10:29:47 <d34df00d> Dammit.
10:29:48 <d34df00d> Right.
10:30:15 <d34df00d> Yes, as I said above, emulating mixfix ops in Haskell is extremely hard, and this totally proves it.
10:31:14 <boxscape> d34df00d here's some unicode fun with partially applied backticked functions https://reddit.com/r/haskelltil/comments/dhc7vj/nested_backticks_a_b_c_d_e_f_g/
10:35:47 <d34df00d> Haha, that's cunning!
10:36:54 <boxscape> anyone happen to know how I can find the essay where dijkstra talked about how he wants haskell to have ; as function application operator?
10:44:08 <boxscape> found it http://www.the-magus.in/Publications/ewd.pdf
10:47:54 * hackage co-log-polysemy 0.0.1.1 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-polysemy-0.0.1.1 (shersh)
10:50:18 <remexre> ugh, does alpine linux's GHC silently not support plugins or something?
10:53:42 <boxscape> (oops I was wrong - he wanted dot to be application, and semicolon to be composition)
11:00:48 <boxscape> (also I'm not actually sure if Dijkstra actually wrote this, hmm)
11:15:38 <iptq> sad
11:29:16 <sim590> Am I forced to use -XFlexibleContents with an MArray ?
11:30:54 <dmwit> Hm. I don't know the non-FlexibleContexts rule for multiparameter typeclasses. It seems like the natural one would apply to most of the unboxed MArray instances but none of the boxed instances.
11:31:19 <remexre> okay, no, reproduced with the haskell:8.6.5 docker image
11:31:23 <dmwit> (What I think is the natural one: each parameter is of the standard "Constructor variable1 variable2 variable3 ..." form.)
11:31:42 <dmwit> Is there a reason you want to avoid FlexibleContexts?
11:32:19 <remexre> with GHC.TypeList.{Extra.Solver,KnownNat.Solver,Normalise}, GHC can't solve (1 <= 1 + (Max a b - a)) inside Docker, but does so fine outside...
11:33:13 <remexre> with alpine:edge's GHC and haskell:8.6.5's in Docker, and ghcup's on Gentoo outside; gonna try ghcup on Debian in Docker next, but >:(
11:33:34 <sim590> dmwit: I just don't know why I should use it actually. But more precisely, There is some instruction that when written in some inner do block then it complains, but if I move it in some outter do block, thne it's fine (according I provide a literal parameter as index).
11:33:54 <sim590> I'm a bit confused why I need it in a first case, but not in the second case.
11:34:34 <dmwit> What is an "inner do block"?
11:35:10 <dmwit> At a guess, you have a type generalization boundary (e.g. a `let` or `where` binding site) in between the two blocks, and so the deeper one is attempting to be more polymorphic.
11:35:46 <sim590> Yeah. I think so!
11:36:11 <dmwit> Similar to how `3 + 3 :: Int` lets you know both `3`s are `Int`s, but `let x = 3 in x + 3 :: Int` doesn't because in fact `x :: Num a => a`.
11:37:39 <dmwit> Anyway, of all the extensions, FlexibleContexts and FlexibleInstances are probably two of the least controversial.
11:37:57 <dmwit> There are syntax extensions that I would squint harder at than those two.
11:38:28 <sim590> OK, I get it. Otherwise, I would have to set the type of the expression myself, right?
11:38:58 <dmwit> It is often but not always possible to avoid those extensions with manual type annotations.
11:40:53 * hackage semirings 0.5.3 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.5.3 (chessai)
11:40:55 <sim590> Oh right. Since my type is polymorphic, then it would resolved to some other polymorphic type. More precisely, at first I have ST s, then it would be resolved to ST s1 which is not the same, right? For clarity, here's the code: https://paste.debian.net/1131021/ the line in question is line 13.
11:41:32 <sim590> if I comment line 13, I'm fine.
11:41:56 <sim590> well, I also have to comment line 20 and put some `return empty`
11:42:49 <sim590> and comment everything related to `unvisited` variable.
11:43:18 <dmwit> I suspect it is not possible in current GHC to give `visitedNode` a correct and fully explicit type annotation.
11:43:34 <dmwit> No matter what extensions you turn on.
11:44:24 <dmwit> A correct but slightly incomplete annotation should be possible with PartialTypeSignatures.
11:45:11 <dmwit> Hm. I am a bit surprised that the type annotation on line 6 is accepted. If it is, perhaps I am wrong.
11:45:47 <dmwit> Ah, no, I understand why it is accepted. How deceptive.
11:45:57 <sim590> Line 6 was a test.
11:46:08 <sim590> And yeah, it's the line that I worte in the outter do block.
11:46:33 <sim590> But I used FlexibleContents and now it's fine.
11:47:10 <dmwit> It's conte*x*ts, not conte*n*ts.
11:47:36 <sim590> Oh right, yes!
11:47:43 <sim590> I was wondering if I was doing something wrong. Now, I understand that FlexibleContexts is just unaboidable sometimes.
11:53:22 <dasli> I'm writing a two-column article with a proof of equivalence between two expressions. The intermediate expressions get too large for the column. Is there a standard thing to do about this?
11:54:33 <dasli> Word-wrap the expressions? Single-column appendix? I'm submitting to the Haskell Symposium; do they have their own convention?
11:55:34 <geekosaur> word-wrapping is what I usually see, fwiw, but I don't know conventions for the Symposium
11:56:18 <lyxia> "exercise for the reader" fits in one column
11:56:49 <dasli> "It can be shown that"
12:19:47 <remexre> okay, yeah, took a while to build the image, but debian+ghcup is also unable to compile it :|
12:20:21 <maerwald> what image
12:20:38 <remexre> debian:10-slim + ghcup + my runtime deps
12:20:45 <remexre> er, docker image
12:21:08 <maerwald> still too vague
12:22:24 * hackage github 0.25 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.25 (phadej)
12:22:45 <remexre> as to the code? It's a work thing so I can't link to the repo, but I give some details above; basically, with GHC.TypeList.{Extra.Solver,KnownNat.Solver,Normalise}, GHC can't solve (1 <= 1 + (Max a b - a)) inside Docker, but it does so fine on multiple machines outside of Docker
12:23:03 <remexre> er, TypeLits*
12:24:19 <remexre> I'm making a minimal reproducable example rn
13:12:00 <maerwald> man, I'm starting to like haskus Excepts
13:32:21 <remexre> okay, hah, finally reproduced it
13:34:02 <remexre> https://git.sr.ht/~remexre/lt-docker/tree/master/Main.hs
13:35:52 <remexre> both host machine and Docker ctr say "Build profile: -w ghc-8.6.5 -O1", but the host machine can build and exec it correctly, while the Docker container gets https://silo.remexre.xyz/screenshots/9a33e933ee33b9cf3ec31c1882309a05abb0b98e.png
13:59:53 * hackage gi-gio 2.0.26 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.26 (inaki)
14:07:54 * hackage diagrams-graphviz 1.4.1.1 - Graph layout and drawing with GraphViz and diagrams  https://hackage.haskell.org/package/diagrams-graphviz-1.4.1.1 (BrentYorgey)
14:08:13 <slack1256> maerwald: Excepts is like Except but with open variants?
14:08:20 <maerwald> yeah
14:08:52 <maerwald> needs more operators for convenience (e.g. converting from Either, Maybe etc), but then works fine
14:10:26 <slack1256> I like open variants & extensible records. I just wish a single library "won" so we can all back that up.
14:10:42 <slack1256> I am using the `row-types` package and liking a lot.
14:10:53 <maerwald> that probably happens when people have settled on a single effects library *chuckle*
14:11:28 <slack1256> ;_;
14:13:04 <jle`> someone likened this current era to how the streaming combinators debate was back in like 2013ish
14:14:17 <slack1256> Anyways, what is haskus? their tutorial talks about open varians and extensible records, then jumps on to how to modify the linux kernel with haskell.
14:14:41 <maerwald> lolo, no idea
14:25:48 <slack1256> On the `row-types` package, how do I create a `Var` with the `IsJust` pattern?
14:28:18 <zeta_0> what are the -d* flags in this code? https://hastebin.com/mulomagaji.cpp https://hastebin.com/oqeyoqikuy.cpp
14:31:43 <dmwit> Have you looked in the fine manual?
14:34:10 <maerwald> slack1256: looks a bit over-complicated. I only gave Excepts a chance, because it isn't too weird
14:35:21 <slack1256> I solved how to create `Var`s.
14:37:29 <maerwald> It we will never know how :>
15:34:16 <iqubic> Anyone here?
15:35:15 <lyxia> nope
15:36:03 <iqubic> Darn. Looks like it truely is a ghost town here in #haskell.
15:37:01 <koala_man> you get activity if you ask a question because the channel is lazily evaluated
15:38:31 <jle`> none of us exist until you try to evaluate us
15:39:17 <iqubic> I see. So when I'm not actively looking at this channel, it just ceases to exist?
15:39:18 <Axman6> Would asking this questions be considered asking a question about Haskell?
15:39:24 <Axman6> question*
15:39:48 <iqubic> Is the truthful answer to this question no?
15:45:59 <Tops2> no
15:52:17 <zeta_0> i am trying to move the -d* flags from dynamic_flags_deps to dFlagsDeps, could you guys help me out, i have never done this before? https://hastebin.com/mulomagaji.cpp https://hastebin.com/oqeyoqikuy.cpp
15:52:53 <zeta_0> i am not sure exactly what it need to move?
15:56:38 <zeta_0> i'm reading the documentation now, i feel a little bit lost
15:57:15 <zeta_0> zeta waits patiently for response
15:57:19 <slack1256> I been reading the gtk declarative documentation. Looks great
15:57:40 <slack1256> What I don't understand, how do I deal with intermediate state such as an "opening file" dialog?
16:20:23 * hackage egison 3.10.3 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.10.3 (SatoshiEgi)
17:02:34 <ezzieygu1wuf> can anyone help me figure out what I'm doing wrong here? http://dpaste.com/3SBDAW8#line-33
17:03:24 <ezzieygu1wuf> the error message is very clear but I don't know how to resolve it
17:04:11 <Clint> ezzieygu1wuf: what's line 37 supposed to do?
17:04:20 <jle`> what's the error message?
17:04:39 <ezzieygu1wuf> it's the beginning of an instance declaration for `Arbitrary`
17:05:08 <ezzieygu1wuf> jle`: Couldn't match expected type ‘Gen Integer’ with actual type ‘Int’
17:05:18 <ezzieygu1wuf> In a stmt of a 'do' block: n <- 1 + length vs
17:05:29 <jle`> try `let n = 1 + length vs` instead
17:05:38 <ezzieygu1wuf> then there's a second: Couldn't match type ‘Array Integer’ with ‘Gen’....In a stmt of a 'do' block: vs' <- listArray (0, n) (v : vs)
17:05:39 <jle`> since what you're doing here is an alias
17:05:47 <jle`> not a Gen action
17:06:02 <jle`> and probably same for that one as well
17:06:08 <jle`> let vs' = listArray (0, n) (v:vs)
17:06:23 <jle`> you're aliasing vs' as listArray (0, n) (v:vs)
17:06:40 <jle`> you're not sequencing a Gen action
17:07:06 <ezzieygu1wuf> can you explain what you mean by "alias"?
17:07:10 <ezzieygu1wuf> or point me to a reference?
17:07:58 <jle`> alias is like, "when you see n, replace it with (1 + length vs)"
17:08:07 <jle`> like, 'naming'
17:08:19 <jle`> 'n' is an alias/name/shorthand notation for 1 + length vs
17:08:42 <jle`> also known as 'defining' i suppose, in this context
17:09:50 <jle`> basically it's unreadable to write `listArray (0, 1 + length vs) (v:vs)`
17:09:56 <jle`> so you can say oh let's say that n = 1 + length vs
17:10:04 <jle`> give a name to 1 + length vs
17:10:09 <jle`> then you can write `listArray (0, n) (v:vs)`
17:10:13 <jle`> and people will know what you mean
17:10:33 <jle`> since you just said "that n there? it's 1 + length vs, i just gave it a name so it's easier to read"
17:12:04 <jle`> if you've evern programmed in C/CPP, it's like writing `#define PI = 3` at the top of your file, you alias PI to the number 3
17:12:16 <jle`> so if you ever write PI in your file, it's replaced with 3
17:18:47 <MarcelineVQ> ezzieygu1wuf: you can learn about do noation (an IO as a bonus) here http://www.vex.net/~trebla/haskell/IO.xhtml  which will explain why  n <- 1 + length vs  doesn't make sense once you've considered it using >>=
17:20:24 <slack1256> Can I use reflex with gi-gtk? or reactive-banana?
17:20:41 <slack1256> I remember there was an effort for using reactive-banana with the old gtk2hs project.
17:21:20 <solonarv> I don't know if anyone's made a reflex wrapper around gi-gtk, but it's certainly possible
17:22:12 <Axman6> jackdk: hey you know what would be cool? A gi-gtk-reflex package :P
17:26:35 <julianleviston> Does anyone know if there’s a way - other than dbg - to get Megaparsec to spit out the stacktrace of parses as context it had while it was parsing before it got an error?
17:29:50 <Axman6> I doubt it without you exoplicitly adding some support for that - does megaparsed have a state parameter? you could add a stack of parses to your parser relatively easily
17:30:18 <solonarv> it does have a state parameter, IIRC
17:30:23 <julianleviston> It’s on top of a transformer, so yeah could do that. Good idea. Thankyou :)
17:31:18 <solonarv> of course, I don't know what happens to the state when you backtrack or take another branch of a <|>
17:31:58 <Axman6> to make your life easier you could add a function which you can wrap other functions with which takes some symbol for signifying what's being parsed, and annotates that with the location, and also checks that once the function has returned that the expected state is on the stack of states
17:33:12 <julianleviston> I would have thought <?> does that, but I have no idea what that does “under the hood"
17:35:24 <julianleviston> Also it seems it has facility for “custom error components” so I’ll look into that.
17:36:24 <solonarv> it *might* make more sense to use Reader instead of State, and "update" the stack using 'local'
17:36:44 <julianleviston> Looks like it has massive support for custom errors. https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Error.html#t:ParseError
17:49:30 <edmundnoble> IIRC *parsec* can do what you asked for, tracing the stack of the parse tree
17:49:39 <edmundnoble> In combination with <?>
17:51:16 <julianleviston> with https://github.com/sleepomeno/parsec-trace#readme ?
17:57:04 <ezzieygu1wuf> jle`: thanks for the explanation that helps a lot! 
18:38:24 * hackage bech32 1.0.2 - Implementation of the Bech32 cryptocurrency address format (BIP 0173).  https://hackage.haskell.org/package/bech32-1.0.2 (JonathanKnowles)
18:41:12 <dyamito> hi all, i have a data type which takes 4 integers, what is the haskell way of constructing it from a list of 4 integers?
18:41:26 <dsal> A list?
18:41:28 <dyamito> in python land it would be someobject(*mylist)
18:42:07 <dsal> A list can have between 0 and an infinite number of items.  You could take 4 and then apply those, but that'd be partial.  You can't really safely do that with a list.
18:42:15 <Axman6> mkFoo [a,b,c,d] = Just (Foo a b c d); mkFoo _ = Nothing
18:46:23 * hackage bech32-th 1.0.2 - Template Haskell extensions to the Bech32 library.  https://hackage.haskell.org/package/bech32-th-1.0.2 (JonathanKnowles)
18:49:16 <iqubic> I think that there's a logical fallacy going on here. Haskell is a much different language than Python. In keeping with idiomatic Haskell, I don't think I'd ever write a partial function like that. I'd most just use the data constructor itself and not even bother with such a constructor function like that.
18:50:54 <iqubic> Now, if I were doing some sort of data validation at the same time as making a Foo, then I'd be write that. This form of doing data validation and construction of a value is called a smart constructor.
18:52:24 * hackage streamly-bytestring 0.1.2 - Library for streamly and bytestring interoperation.  https://hackage.haskell.org/package/streamly-bytestring-0.1.2 (psibi)
18:52:25 <dyamito> interesting. i'm new to haskell and i'm writing a script to validate bounding boxes, as a toy
18:52:37 <dyamito> and i was thinking of having a ParsedBox which is 4 integers, but could be invalid 
18:52:45 <dyamito> and then a Box which is the valid form of the box
18:55:22 <dyamito> this wiki page on smart constructors is interesting though
18:55:59 <dsal> dyamito: you wouldn't use a list to store four integers.
18:56:10 <dsal> probably not in python either, a tuple or more specific type would be better in either.
18:57:59 <dyamito> i'm basically taking a line from a text file "1 2 3 4" and trying to put them into my data structure which is Box = Box Int Int Int Int
19:00:33 <iqubic> That's totally possible. I wouldn't convert that into a list ever.
19:00:59 <dsal> `map read . words ` is a bit tempting
19:01:09 <dsal> But I tend to reach for megaparsec early.  heh
19:21:16 <iqubic> Me too.
19:37:06 <MarcelineVQ> an article I really like on parsing and why/how types help you  https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/  
19:53:54 * hackage indexed-containers 0.1.0.0 - Simple, no-frills indexed lists.  https://hackage.haskell.org/package/indexed-containers-0.1.0.0 (zliu41)
20:04:01 <monochrom> "validate the input string and then separately convert validated string to internal data" is a serious case of boolean blindness.
20:05:00 <monochrom> i.e., taking the deficient natural language idiom "is it valid? if yes, what does it stand for?" way too seriously.
20:05:13 <monochrom> So a serious case of Sapir-Worf too.
20:16:50 <iqubic> That's why I like parser combinator libraries.
20:17:29 <iqubic> I can parse the data to make sure it's valid, and turn it into an ADT at the same time.
20:19:25 <glguy> s/ combinator librarie//
20:22:37 <d34df00d> Oh, speaking of which.
20:23:23 <d34df00d> How fragile is handling left recursion via remembering the input position in the combinator and comparing it to the previously saved position (if any is present), and failing if they are equal (that is, if no progress has been made)?
20:24:01 <d34df00d> My only concern is that it might break with some sort of backtracking, but I can't prove it's always good or easily build a counterexample that'll break it.
20:25:40 <d34df00d> What I mean is smth along the lines of https://bpaste.net/5EKQ (note the recursive path parseTy -> parseArrow -> parseTy).
20:34:08 <boxscape> % data Ʇ
20:34:09 <yahb> boxscape: 
20:34:11 <boxscape> nice
20:36:28 <iqubic> NO..
20:37:09 <boxscape> in other words, (nice -> Ʇ)
20:37:35 <monochrom> d34df00d: Does it actually pass test cases?  Because I have trouble seeing how it accepts "Int->Int" (assume "Int" is accepted by parseBaseRT").  I can only see it accepting the beginning "Int" and declaring that the rest "->Int" is leftover garbage.
20:40:04 <monochrom> Err nevermind I see how it works.  In the call chain ty->arrow->ty->(arrow | parenthesized | base) the second arrow fails, but the first one is fine.
20:41:42 <monochrom> I can't think of how to break this approach, but if it survives the poster-boy "T ::= T->T | (T) | Base" it probably is good enough.
21:03:03 <lokesh1197> Hi, I am learning haskell right now and I have a doubt in `kinds`
21:03:15 <lokesh1197> For example: data Funny f a = Funny a (f a)
21:03:29 <lokesh1197> Prelude> :k FunnyFunny :: (* -> *) -> * -> *
21:04:02 <lokesh1197> kind of Funny is (*->*) -> * -> *
21:04:41 <heatsink> Do you understand why it has that kind?
21:04:43 <lokesh1197> but in `Funny a (f a)` kind of a is *
21:05:00 <lokesh1197> because f is a type constructor right?
21:05:10 <monochrom> But you put "a" second in "data Funny f a".
21:05:11 <heatsink> the kind of Funny is describing the type on the left-hand side
21:05:31 <lokesh1197> oh and what about the right hand side?
21:05:44 <glguy> lokesh1197: "type constructor" doesn't come up when discussion kinds
21:05:45 <heatsink> The right hand side is defining a data constructor
21:05:45 <Axman6> @let data Funny f a = FunnyConstr a (f a)
21:05:48 <lambdabot>  Defined.
21:05:53 <Axman6> @kind Funny
21:05:55 <lambdabot> (* -> *) -> * -> *
21:06:04 <heatsink> So the data constructor Funny is a value, and it has a type
21:06:06 <Axman6> > :t FunnyConstr
21:06:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
21:06:16 <monochrom> Follow Axman6. Use a different name for the data constructor.
21:06:17 <Axman6> :t FunnyConstr
21:06:18 <jle`> @let deriving instance (Show a, Show (f a)) => Show (Funny f a)
21:06:20 <lambdabot> a -> f a -> Funny f a
21:06:21 <lambdabot>  Defined.
21:06:28 <jle`> :t FunnyConstr 3 (Just 4)
21:06:30 <lambdabot> Num a => Funny Maybe a
21:06:30 <monochrom> Name clash is the #1 cause of beginner confusion.
21:06:48 <jle`> :t FunnyConstr "hi" ["ok","bye"]
21:06:50 <lambdabot> Funny [] [Char]
21:07:02 <jle`> :t FunnyConstr "hello" getLine
21:07:04 <lambdabot> Funny IO [Char]
21:07:21 <monochrom> Although, I would s/FunnyConstr/MkFun/
21:07:23 <Axman6> lokesh1197: yi ou're getting fused by the fact that Funny is a name for both a _type_ constructor and a _value_ constructor
21:07:25 <lokesh1197> oh I get it now 
21:07:40 <Axman6> for out, where did those letters go
21:07:55 <lokesh1197> so using different names for them is what I should have done
21:08:09 <lokesh1197> I got confused because both had the same names
21:08:33 <Axman6> it's copmmon for them to have the same name by convention, but if you're not used to it you should use different names
21:09:15 <lokesh1197> if they have same names then is there a way to differentiate between value constructor and type constructor?
21:09:52 <Axman6> they live in different namespaces so they can't actually be used in the same places in programs (though that's not true with DataKinds enabled)
21:09:55 <glguy> lokesh1197: The only place that it gets confusing which is being referred to is in export lists
21:10:02 <monochrom> Yes. If you're looking at a type expression, you see type constructors. If you're looking at a term expression, it's a value constructor.
21:10:05 <lokesh1197> thanks a lot Axman6, monochrom, lambdabot, jle`
21:11:50 <jle`> happy haskelling :)
21:23:00 <d34df00d> monochrom: it pass a bit of test cases that I've thrown at it.
21:23:08 <d34df00d> But I'm not sure if that's enough to, well, be sure it works.
21:24:29 <d34df00d> https://bpaste.net/FDXA that's my test.
21:24:30 <d34df00d> tests
22:29:44 <aviD> I'm wondering about the laziness of Generic representations? Is `Rep a` in normal form when a is in normal form? What about types like `:+:`? Does M1 add laziness?
23:00:15 <glguy> aviD: I don't know what normal form means, and yes Rep can add laziness, but it shouldn't matter because the ideal is that the generic reps don't exist at runtime
23:05:57 <jle`> aviD: M1 is a newtype 
23:07:18 <aviD> glguy https://wiki.haskell.org/Weak_head_normal_form
23:08:40 <aviD> thanks I don't know why I didn't notice it's a newtype.
23:09:01 <glguy> The types can't be in normal form, if that's the definition you're asking about
23:11:20 <aviD> I'm wondering about the term result of `from`
23:12:02 <glguy> in that case no, if x is in WHNF then   from x   won't necessarily be
23:13:33 <glguy> But again none of that matters because when you're using generics you're trying eliminate all the generic representation values with GHC's optimizations
23:15:13 <aviD> I have a very strange use case where it may become important.
23:35:24 * hackage tls 1.5.4 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.5.4 (KazuYamamoto)
23:42:11 <aviD> Before I go digging in generic-optics is there a standard way to use a Type that is buried in a Rep?
23:42:11 <aviD> In other words a way to get a `Rep (Maybe a) p` while traversing a `Rep [Maybe a] p`?
