00:07:52 <dmj`> cole-k: NOTE: Semigroup is a superclass of Monoid since base-4.11.0.0.
00:23:57 <albet70> https://en.wikipedia.org/wiki/Matrix_calculus
00:24:12 <albet70> what's the name of that symbol in it?
00:24:27 <albet70> upside down 9
00:26:05 <int-e> https://en.wikipedia.org/wiki/%E2%88%82#Names_and_coding
00:26:12 <MarcelineVQ> it doens't neccesarily have a name, in latex it's called 'partial'  as in  https://en.wikipedia.org/wiki/Partial_derivative
00:31:40 <albet70> ok
00:43:23 * hackage HsWebots 0.1.0.1 - Webots bindings for Haskell  https://hackage.haskell.org/package/HsWebots-0.1.0.1 (junjihashimoto)
00:55:23 * hackage hostaddress 0.1.0.0 - Network Host Addresses  https://hackage.haskell.org/package/hostaddress-0.1.0.0 (larsk)
01:33:41 <hoppfull> Anyone know if there is a sql backend mock for persistent to unit test my db interaction?
01:34:18 <merijn> hoppfull: Why mock rather than just test against a database?
01:34:51 <dminuoso> Mocking is good when you want to get high on the leaderboard for test coverage without actually testing something.
01:35:08 <merijn> dminuoso: Mocking is good for bad technology :p
01:35:33 <dminuoso> While admittedly, there are some things mocking is sensible for, databases generally are not that.
01:35:36 <jackdk> or when you can't trust the function your code-under-test will call, so just pretend you called it
01:35:41 <dminuoso> Say APIs that are completely out of your control.
01:35:47 <dminuoso> (Then you cant do much else)
01:35:50 <merijn> jackdk: But that's pointless
01:35:59 <dminuoso> But databases are not out of your control :)
01:36:06 <merijn> jackdk: If the function you call is broken, you want to know that it's broken
01:36:31 <merijn> "But if the code I call is broken my test for X also breaks!" <- well, that just seems like a bonus. Two tests for the price of one!
01:36:43 <jackdk> or it's too much of a tangled mess of side-effects that you need to draw a line somewhere
01:36:57 <merijn> jackdk: But this is Haskell, so that argument doesn't hold
01:37:01 <jackdk> and getting the mock in meant you made some headway taming the beast
01:37:02 <dminuoso> jackdk: Well, perhaps refactoring into a more testable architecture is a better approach.
01:37:12 <jackdk> yeah sure, I'm talking more generally
01:37:16 <dminuoso> The only argument I accept for mocking, is when there is an interface completely out of your control
01:37:21 <dminuoso> Say some external API
01:38:05 <merijn> hoppfull: Anyway, even if you can't use a real database in your test you could just use persistent-sqlite and run the tests against an in memory SQLite database or something
01:39:26 <merijn> Or just ditch persistent entirely >.>
01:39:43 <hoppfull> I'm not sure if mocking is the right solution. I am using Haskell in production and what I do know is that it's important that it's easy to write tests and the tests should run fast. I also have a manager who is a bit of a duct tape programmer and just sort of throws things together. I managed (thank to the effect system in haskell) seperate large
01:39:44 <hoppfull> parts of the pure logic from the actual side effects such that I can run regression tests on our api. These are easy to write and run fast so people write them in practice. Our smoke tests (effectfull) haven't been touched in six months.
01:41:33 <hoppfull> But alright, I get the sense that this is the wrong approach. I'll see if I can solve this in another way. Thanks for the help! :)
01:41:54 * hackage typed-uuid 0.0.0.1 - Phantom-Typed version of UUID  https://hackage.haskell.org/package/typed-uuid-0.0.0.1 (Norfair)
01:42:17 <merijn> hoppfull: If your database isn't super big than SQLite also has the bonus that you can easily spin up independent database for each (set of) tests to speed things up ;)
01:42:53 <dminuoso> merijn: Interesting, so my first instinct was "this should be easy on postgres too with nested transactions"
01:42:54 * hackage genvalidity-typed-uuid 0.0.0.1 - Generators for Phantom-Typed version of UUID  https://hackage.haskell.org/package/genvalidity-typed-uuid-0.0.0.1 (Norfair)
01:43:06 <dminuoso> And then I remembered that MVCC has weak consistency because it allows write skews..
01:43:32 <merijn> dminuoso: Yeah, but then you need to actually have a postgres server setup which can be non-trivial from within your test-suite, so know you have moving parts/services to maintain
01:44:37 <merijn> dminuoso: Where as you can spin up as many SQLite databases right from the test code without extra maintenance. Additionally, since he's using persistent persistent-sqlite should be mostly drop-in replacement for postgres or whatever, all he needs to do is write some boilerplate setup once to select between which backend to use
01:56:20 <ziman> i found a script that runs postgres in userspace, it's almost as easy as running sqlite (except that you have to have to keep one process running while you do your business)
01:57:14 <__monty__> merijn: Isn't testing code that'll run against postgress against sqlite just an advanced sort of mocking?
01:58:29 <merijn> __monty__: You're still running the same application code, granted you might not trigger bugs in the postgres bindings that way
01:58:57 <merijn> __monty__: I would recommend testing against postgres if you use it, yes. But if that's not practical then this approach at least avoids handwriting any mocking :p
01:59:08 <ziman> i just run "pglocal" from a command line and it sets up a pg datadir in the current directory (if it does not exist) and then runs postgres in it in the foreground; and the script is not even complicated, it just sets two environment variables and checks if it needs to run initdb
01:59:39 <ziman> so i don't use sqlite in dev environments anymore :)
02:01:56 <dmj`> ziman: only in prod environments? :)
02:04:45 <ziman> yolo :)
02:05:23 * hackage HsWebots 0.1.1.0 - Webots bindings for Haskell  https://hackage.haskell.org/package/HsWebots-0.1.1.0 (junjihashimoto)
02:22:10 <Gurkenglas_> Looking for a function a -> IO Bool which returns whether a is in WHNF
02:25:03 <Gurkenglas_> As an ansatz towards writing a weaken or daemonize :: a -> a which produces a pointer to a which makes it so anyone who tries to evaluate it will wait until someone with the original pointer brings a to whnf
02:26:23 <__monty__> Gurkenglas_: https://stackoverflow.com/questions/28687384/test-if-a-value-has-been-evaluated-to-weak-head-normal-form
02:31:33 <Gurkenglas_> ah so I should use Control.Concurrent.Async and combine it with unsafePerformIO if I'm feeling frisky
02:33:46 <Gurkenglas_> unsafePerformIO lets you write nonmonotonic functions. Is there an interface to it that gives you all its power which does not let you write nonmonotonic functions?
02:35:57 <Gurkenglas_> (Keep replying, it'll show up in the logs)
03:10:24 * hackage barbies-th 0.1 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0.1 (FumiakiKinoshita)
03:30:54 * hackage fallible 0.1.0 -   https://hackage.haskell.org/package/fallible-0.1.0 (matsubara0507)
04:00:23 * hackage mergeless 0.2.0.1 -   https://hackage.haskell.org/package/mergeless-0.2.0.1 (Norfair)
04:25:25 <Amras> is there a safe way to coerce, say, a RealFrac?
04:25:29 <Amras> realToFrac exists, but I'd like something that doesn't make me lose Ord
04:26:24 <Amras> I'm not asking for a universal solution to Num, but it should be possible to compare a Double to a Float
04:26:53 * hackage typed-uuid 0.0.0.2 - Phantom-Typed version of UUID  https://hackage.haskell.org/package/typed-uuid-0.0.0.2 (Norfair)
04:27:29 <Amras> wait, ignore that. realToFrac doesn't lose ord
04:27:53 * hackage mergeless 0.2.0.2 -   https://hackage.haskell.org/package/mergeless-0.2.0.2 (Norfair)
04:41:32 <[itchyjunk]> wat
04:41:35 <[itchyjunk]> http://www-cs-students.stanford.edu/~blynn/haskell/brain.html
04:59:25 <lembot> Hello! When compiling with stack is it possible to pass cpp options to modules imported from hackage? For example I want to import module A as if -SOMEDEF was set at compile time.
04:59:59 <fendor> lembot, iirc, you can do this via the stack.yaml file
05:00:40 <fendor> lembot, https://docs.haskellstack.org/en/stable/yaml_configuration/#flags
05:00:48 <merijn> sm[m]: I find this question highly questionable >.>
05:00:51 <merijn> eh
05:00:57 <merijn> s/sm[m]://
05:01:48 <lembot> fendor: Thanks!
06:39:53 * hackage acts 0.1.0.0 - Semigroup actions, groups, and torsors.  https://hackage.haskell.org/package/acts-0.1.0.0 (sheaf)
06:53:01 <ddk> Hello All, I'm fairly new to servant and web workflow, I have written a servant api, which I'm calling through react frontend, I want to test the api, for now it is returning 400 bad request, please suggest me what is the workflow to debug this type of problem, as I am also developing the frontend error can be anywhere, but at first I want to be
06:53:02 <ddk> sure about haskell backend, my post data is huge otherwise I could use curl, actually I want to know the workflow of servant development. Thanks in advance.
06:56:18 <ddk> surely I could use something like this ```curl -H "Content-Type: application/json" --data @body.json http://localhost:8080/ui/webapp/conf``` but I'm not sure about the workflow
06:56:58 <phadej> that looks like a good start
06:57:37 <ddk> phadej: servant client for this ?
06:57:55 <phadej> I wouldn't, if the API is that simple
06:58:32 <phadej> https://hackage.haskell.org/package/servant-swagger-ui is nice for APIs with a lot of stuff, as you get UI you can just click around
06:59:17 <ddk> API is simple for now, aim is to learn the production work flow.... I want to know about best practice followed in Industry when you build a web app with Haskell
06:59:58 <phadej> I'd say there is no "industry"
07:00:18 <phadej> few developers here and there who occasionally share their experiences in blogs and conferences
07:00:34 <phadej> at least no industry to form "best practices"
07:00:52 <ddk> no industry is best reply I have got ever :)  
07:01:33 <ddk> swagger looks like an overkill 
07:02:50 <phadej> not really, its only needs few lines to add to the application (if you don't pay too much attention to have perfect schemas for your typs)
07:04:25 <ddk> In the sense I need to learn the ecosystem, for now I want to first deliver something
07:06:56 <phadej> Haskell optimises for "do it right" not "do it fast"
07:07:10 <phadej> or at the very least, servant
07:10:32 <fishooter> Hello, I'm a Haskell beginner. I've just set up stack with intellij idea plugin "intellij-haskell". Everything seems to work fine, I just come across minor issues. For example, I'd like to navigate to code definitions of existing packages like Control.Applicative, but I keep getting a message that it cannot find sources for it. Another packages that I've installed via stack seem to work fine. How can I 
07:10:38 <fishooter> get the sources for the "core" files?
07:11:24 <ddk> phadej: Yeah I'm a supporter too but the requirement is to produce ☺️
07:16:51 <charms> hi, are there any good books on haskell type programming with modern extensions like type families and scoped type variables, partial type signatures etc?
07:17:48 <lyxia> Thinking With Types
07:19:04 <Cale> fishooter: I don't know anything about intellij-haskell, but you can find the source of the base package on hackage by first going here: https://hackage.haskell.org/package/base
07:19:29 <Cale> If you click on a module, you'll see the documentation for it, and if you find the function you want the source of, there's a source link on the far right
07:19:59 <Cale> e.g. https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Applicative
07:20:12 <Cale> (or other thing you want the source of, in this case, a class)
07:23:17 <fishooter> Cale: that link is helpful, thank you! :)
07:23:35 <charms> Thanks lyxia, I saw that online but hadn't had any recommendations. I'll try it.
07:24:22 <adamCS> I've got an app that does logging by creating a thread, then sending messages via an STM TChan.  The logging thread "waits" with readTChan, gets an ADT with either a message to log or the command to exit. That all works.  But I just had a situation where the main thread, which will eventually send the "Done" command, died, but I never saw the main thread issue because I got the "STM: blocked indefinitely" error instead. It
07:24:22 <adamCS>  makes sense, no one left to issue the "Done" command.  But annoying for debugging.  Any way around this?    
07:25:04 <merijn> Any way around what?
07:25:24 <merijn> The crash? The message?
07:25:32 <adamCS> merijn: Sorry!  Any way to be able to see the exception that actually killed the main thread.
07:25:39 <adamCS> Crash is fine
07:25:51 <adamCS> But it took me a loooong time to find it...
07:26:02 <merijn> adamCS: Something must be swallowing it, because normally it is printed
07:26:18 <geekosaur> that's an odd sequence of events, since the main thread should throw and then the whole program exits, so it shouldn't reach the STM exception
07:26:23 <merijn> adamCS: Alternatively, is your main thread *actually* the main thread? Or was it forked off
07:26:46 <merijn> geekosaur: I think he is fibbing and talking about his application's main thread, which might be different from the *actual* main thread ;)
07:26:57 <adamCS> I think it's my main thread...But I guess I could think harder about that.
07:27:05 <adamCS> Not fibbing!  But maybe wrong.
07:28:05 <geekosaur> or there's a catch or etc. eating the main thread's exception and the subthread throws when the STM channel goes out of scope in the main thread
07:28:28 <geekosaur> in which case, fix the catch / other exception handler
07:28:33 <merijn> adamCS: Anyway the options are 1) your main thread isn't running in the main thread and it's exception is getting lost somewhere, 2) some overzealous "catch SomeException" is swallowing your exception, 3) you spawned a main thread without exception handler that prints, 4) the simultaneous exceptions are racing and you keep getting unlucky
07:29:12 <adamCS> merijn: Thanks!  That gives me lots to look for to improve the situation.
07:30:13 <geekosaur> again I don't think 4 can happen, the main thread being killed by exception should prevent the STM exception from ever happening because the main thread is special and all other threads go away when the main thread does
07:30:33 <geekosaur> anyway, +RTS -xc might be of help
07:31:06 <geekosaur> (forces a stack trace on any exception, including caught ones)
07:31:12 <adamCS> I had thought about a catch and I don't think there is.  But it's all happening in an effects stack (Polysemy) and I haven't looked into the run functions for the built-in effects in the stack.  That might mean I am misunderstanding the threads.
07:32:14 <adamCS> geekosaur: Thanks!
07:32:59 <geekosaur> may need to compile with profiling to get useful information; it depends, things have changed with the CallStack stuff
07:33:11 <dminuoso> Is there some cheap trick to figure out where an exception is caught without recompiling your program with profiling and running it with +RTS xc?
07:33:22 <geekosaur> which may mean annotating some things with HasCallStack to make it more useful
07:33:26 <dminuoso> Reason Im asking is, I really want to avoid recompiling GHC for 30 minutes if I can avoid it...
07:34:09 <geekosaur> you're debugging ghc itself? anyway, see what I said about HasCallStack
07:34:15 <adamCS> Yeah.  This particular app takes a long time to re-compile (Pandoc is involved) but in retrospect that would've been worth it.  So maybe I'll kick off the profiling build overnight...
07:34:38 <geekosaur> you may be able to drop some HasCallStack => ... in key places
07:35:33 <geekosaur> this said, if you arent catching but you're using polysemy then you probably don 't want to have to rebuild polysemy with callstacks, you might s well just go for a profiling build in that case
07:36:53 <dminuoso> geekosaur: Ah, HasCallstack might actually work nicely! Thank you.
07:37:14 <geekosaur> oh, I managed to mix both of you together, sorry
07:37:22 <dminuoso> geekosaur: Though.. that on its own wont help me figure out where its caught, no?
07:38:04 <geekosaur> depends on how close you can get to the catcher
07:38:16 <dminuoso> I honestly have no idea where that catcher is.
07:38:23 <dminuoso> Not even remotely. :/
07:38:31 <geekosaur> you should, if you annotate the right things, get at least a partial path to whatever does the catch, which should let you drill down
07:39:59 <dminuoso> Mmm, perhaps I should just recompile with profiling and run with +RTS xc after alll...
07:40:00 <dminuoso> It's more effective and guaranteed to produce a correct answer. :)
07:40:33 <geekosaur> um, oe of the points there was that if you have calstacks they print with +RTS -xc even without profiling
07:40:43 <geekosaur> which is how you get that at least partial call stack
07:41:18 <dminuoso> geekosaur: Yeah, but the time spend in generating callstack annotations might be just as long as just recompiling :P
07:41:44 <geekosaur> only if you don't also have to recompile your dependencies with call stacks :)
07:42:05 <geekosaur> profiling is all or nothing, callstacks let you pick and choose
07:42:16 <dminuoso> Can you throw bottom?
07:42:29 <geekosaur> I have no idea
07:43:24 <geekosaur> it wouldn't surprise me if exceptions were strict, though
07:44:57 <geekosaur> huh
07:45:21 <dminuoso> geekosaur: Wonderful! They are properly lazy, you can throw them.
07:45:40 <geekosaur> yeh, I just found that in lb although I needed to pick an exception type
07:46:04 <dminuoso> But hold on.. the cast mechanism won't work as expected. It won't blow up on casting, naturally.
07:49:59 <dminuoso> Sigh, recompiling with prof causes shake errors...
07:55:30 <dminuoso> 16:40:11 geekosaur | um, oe of the points there was that if you have calstacks they print with +RTS -xc even without profiling
07:55:47 <dminuoso> The RTS complains that -xc requires the binary to have been compiled with profiling 
08:35:13 <hc> hi all, i have a package on hackage that I consider of interest to not too many people, but certainly not >300 per month. how does the download count algorithm on hackage work?
08:43:39 <tdammers> badly
08:43:58 <tdammers> if you wipe a project and reinstall all dependencies from scratch, it'll count them again
08:44:11 <tdammers> if cabal can pull dependencies from the local build cache, they don't count as downloads
08:44:24 <tdammers> CI systems are notorious for triggering a lot of redownloads, for example
08:44:35 <tdammers> there isn't really much to be done about this though
08:44:47 <tdammers> it's just a very very rough proxy for popularity
08:50:07 <AWizzArd> Is there something like modifyIORef for TVars?
08:51:52 <boxscape> luckily we have the hackage voting system as another proxy for popularity ;)
08:52:02 <boxscape> all of 26 people have voted on the base library!
09:19:33 <tdammers> modifyTVar?
09:19:43 <tdammers> https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TVar.html#v:modifyTVar
09:29:53 * hackage monky 2.2.1.1 - A system state collecting library and application  https://hackage.haskell.org/package/monky-2.2.1.1 (ongyerth)
09:38:53 * hackage nonlinear-optimization 0.3.12 - Various iterative algorithms for optimization of nonlinear functions.  https://hackage.haskell.org/package/nonlinear-optimization-0.3.12 (FelipeLessa)
10:11:53 * hackage language-ecmascript 0.19.0.1 - JavaScript parser and pretty-printer library  https://hackage.haskell.org/package/language-ecmascript-0.19.0.1 (DavidJohnson)
10:27:25 <Tuplanolla> Does Python have anything like Haskell's `show`? My attempt to print a thing was met with `<__main__.Transaction object at 0x7ff25e5f7048>`.
10:27:58 <solonarv> Tuplanolla: it does, that's what str() and repr() are supposed to be for
10:28:09 <solonarv> the default implementations just aren't particularly helpful
10:28:51 <solonarv> str() is meant to produce "pretty" output, repr() is meant to produce correct output that is ideally valid Python to reproduce the same value
10:29:19 <Tuplanolla> I have to derive them by hand?
10:29:32 <solonarv> but for a number of reasons - including how easy it is to observe object identity, and mutability - repr() is far less useful than show, most of the time
10:29:46 <solonarv> I'm not aware of anything that auto-derives them for you
10:30:04 <solonarv> someone has probably written a decorator or something which does this
10:31:11 <Tuplanolla> Death is suddenly starting to look appealing.
10:33:49 <davean> Tuplanolla: Don't kill yourself! Use haskell!
10:34:14 <Tuplanolla> That's the kind of marketing we need.
10:34:34 <davean> "Haskell, an alternative to suicide"
10:34:42 <davean> Yah, I think not.
10:38:16 <tabaqui1> Tuplanolla: you have to implement __str__ and __repr__ magic methods
10:38:56 <tabaqui1> And solonarv is probably right, there should be class decorator for this
10:49:55 <Tuplanolla> Okay, thanks for the hints.
10:53:59 <idnar> solonarv: https://www.attrs.org/en/stable/
10:56:53 * hackage bugsnag-haskell 0.0.3.1 - Bugsnag error reporter for Haskell  https://hackage.haskell.org/package/bugsnag-haskell-0.0.3.1 (PatrickBrisbin)
11:05:33 <Tuplanolla> Looks like newer versions even have "data classes" that look like Haskell records.
11:12:15 <yushyin> java too is getting data classes/records! :D
11:17:17 <Tuplanolla> Absolutely heretical.
11:19:00 <d34df00d> Do they get lenses?
11:20:02 <d34df00d> On a side note, it's hilarous how trying to make a fast wc substitute derailed me into hacking on ByteString's count function for a few days and, in particular, spending second day in a row writing some C code to properly dispatch the call to the right SIMD-optimized version.
11:21:23 * hackage profunctors 5.5.2 - Profunctors  https://hackage.haskell.org/package/profunctors-5.5.2 (ryanglscott)
11:21:44 <d34df00d> C is meh.
11:26:23 * hackage lens 4.19.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.19.1 (ryanglscott)
11:26:47 <yushyin> d34df00d: no lenses.
11:27:25 <oats> I once found a python "lens" library
11:27:31 <oats> it was… interesting
11:28:10 <yushyin> but with sealed types they can emulate something like ADTs, wow! 
11:28:44 <merijn> Honestly, ADTs are so underrated...
11:29:08 <merijn> Everyone is all hyped about Rust's resource management and stuff. I'm just hyped there's an imperative language with ADTs...
11:30:20 <d34df00d> merijn: was in C++ in 2014 as Mach7 library.
11:30:48 <yushyin> kotlin also has sealed types and data classes so can emulate ADTs like java will be
11:31:18 <merijn> Emulating ADTs is possible in any language. But if it's too much hassle it loses all the benefits
11:33:09 <yushyin> yeah it is not that super smooth as in haskell, you can see the usage here https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html if you scroll down to 'Pattern matching and records'
11:59:25 <flatmap> I am trying to execute „stack hoogle“ and get: https://gist.github.com/pertl/f46534bdcf3ebb46fa8dc4b30c83856a
11:59:35 <flatmap> any recommendation on how to handle this?
11:59:51 <flatmap> allow-never feels fragile / dangerous
12:00:22 <flatmap> I wonder why I even get this error when using stack with an LTS resolver … shouldn’t hoogle be kind of a working standard?
12:00:50 <flatmap> stack 2.1.3 - LTS = lts-14.25
12:12:21 <Cale> flatmap: Typically, if allow-newer isn't going to work, you're going to find out pretty quickly. It's theoretically fragile, but the consequences are usually not too dire.
12:12:48 <Cale> But yeah, as for stack, I've never really used it, so I don't know why it's not making better decisions about which hoogle to try to install
12:13:15 <flatmap> I had the impression stack makes everything easier
12:13:17 <flatmap> :-)
12:13:24 <merijn> Cale: In theory things are even better if everyone uses caret bounds ;)
12:13:28 <flatmap> when reading blogs and such
12:13:36 <merijn> flatmap: Opinions...differ
12:13:38 <maerwald> flatmap: no
12:13:52 <flatmap> is there a reason to stick to cabal only?
12:13:54 <merijn> flatmap: I would say stack vs cabal-install is roughly 50-50
12:14:21 <maerwald> stack also has no backwards compatible format, cabal has, afaik
12:14:28 <merijn> flatmap: Is there a reason to stick to stack? :p (Well, stack also takes care of installing GHC, so that's a reason, but imo not a big enough reason to switch for me)
12:14:37 <maerwald> so newer versions of stack may fail to parse your old stack files 
12:14:41 <merijn> maerwald: Do you mean forward compatible?
12:14:46 <maerwald> err
12:14:48 <maerwald> ...
12:15:14 <merijn> as in, old file stay valid in newer versions (as opposed to older version being able to parse newer formats)
12:15:37 <flatmap> is the reommended way to install GHC without stack by downloading an installer from haskell.org?
12:15:39 <maerwald> so now some repos need to download newer stack during CI, but then guess what... newer stack deprecated fetching remote repos by tags... because apparently tags are not reproducible
12:15:44 <maerwald> so snoyman made that choice for me
12:15:45 <merijn> flatmap: A hopefully reasonably fair summary: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
12:15:57 <merijn> flatmap: Lots of people like ghcup these days
12:16:21 <merijn> flatmap: Personally I'm a grumpy "I want to manually control things" person, so I just install the GHC binary distributions directly
12:16:51 <maerwald> if you want control, stack is definitely not your thing
12:16:59 <merijn> maerwald: Exactly :p
12:17:29 <maerwald> Every time I invoke it somewhere, it downloads a new ghc 80% of the time
12:17:31 <flatmap> so is the resolver thing a stack feature (namely „lts-14.25“) or not?
12:17:41 <merijn> flatmap: Yes
12:18:01 <maerwald> kinda, but that can be used from cabal too (stackage package sets)
12:18:17 <flatmap> so not using stack will leave you in dependency hell? (offensive question, I know :-) )
12:18:21 <maerwald> no
12:18:25 <merijn> flatmap: Define dependency hell
12:18:43 <flatmap> having several libs that need non-compatible version of one library
12:18:45 <maerwald> if it builds with stack, it will build with cabal too
12:18:54 <merijn> flatmap: In "ye olde days" cabal-install wouldn't cope very well with working on many different projects, because it only allowed a single global install
12:19:02 <maerwald> http://hackage.haskell.org/package/stack2cabal
12:19:18 <merijn> flatmap: In the modern v2-build world order you can have infinitely many parallel installs of basically everything
12:19:26 <flatmap> so the main thing is having a virtual project dir so solve issues?
12:19:32 <merijn> flatmap: Of course, if your project has (internally) conflicting dependencies you're still hosed
12:19:36 <maerwald> so even if you have an ancient executable project and it has a stack file... you can convert the stack stuff into a cabal project with the same dependency resolution
12:20:22 <flatmap> actually I like control, too, so I will try to do my stuff with cabal.. though I still have to finish haskellbook :-)
12:20:27 <merijn> flatmap: The solution borrows from Nix. Every installed package is tagged with a hash of its transitive dependencies/flags/config/etc. so if two separate projects require different version (or even the same version with different flags or transitive dependencies) they can be installed in parallel
12:20:50 <merijn> flatmap: If two projects happen to need versions that have the same hash, that can be reused
12:20:51 <flatmap> chapter 22… and still work to do
12:21:04 <merijn> flatmap: See also here: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
12:21:19 <flatmap> nice … I like nix … even though it currently does not work on os x catalina 
12:21:46 <merijn> flatmap: I like Nix's ideas, execution not so much ;) But the v2-build stuff works great
12:21:49 <flatmap> apple ruined it by mounting / read-only
12:22:14 <maerwald> you can install nix into home too
12:22:21 <roberti42> flatmap: I use nix on catalina, and it works, you need to create a volume and tell the OS to mount it to /nix on boot
12:22:36 <flatmap> so synthetic.conf does work?
12:22:48 <roberti42> flatmap: yes
12:22:54 <merijn> flatmap: Now you've woken up the Nix hive xD
12:22:55 <flatmap> glad to hear that
12:23:06 <koz_> merijn: Lol, 'hive'.
12:23:10 <flatmap> sry guys
12:23:18 <flatmap> ;-)
12:23:52 <d34df00d> Let's say I want to contribute some C bits to the bytestring library.
12:23:56 <d34df00d> Which compilers should I care about?
12:24:01 <d34df00d> Obviously gcc and clang. What else?
12:24:12 <merijn> koz_: Like bees, mostly buzzing around harmlessly doing their own thing, presumably useful in their own way. But when you agitate the hive you get drowned in well meaning but...best run away ;)
12:24:32 <merijn> d34df00d: I'm not sure GHC can even really use anything else. But why would the compiler matter if it's standard C?
12:24:53 <d34df00d> merijn: it's C11 first of all, and then it also uses some SIMD intrinsics.
12:25:20 <d34df00d> So I'm curious how much should I care about, say, intrinsics not being available or C11 features not being available.
12:25:22 <merijn> d34df00d: Can't you do it directly in Haskell? GHC exposes SIMD intrinsics (although I'm not sure they work without the LLVM backend)
12:25:51 <d34df00d> merijn: uh, I don't really know, although it'd be cool. What do you think about https://github.com/0xd34df00d/counting-chars/blob/master/impls.h ?
12:25:57 <merijn> d34df00d: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#g:29
12:25:57 <d34df00d> That's basically for ByteString's count function.
12:26:20 <merijn> d34df00d: You might also wanna join #numerical-haskell and bug carter, he's probably most up to date/interested in GHCs SIMD support :)
12:26:21 <d34df00d> Is it worth trying doing that purely in Haskell?
12:26:36 <d34df00d> Ok I'll ask there too.
12:27:15 <merijn> d34df00d: Well, I'd say it's worth it doing purely in Haskell, if only to see where the SIMD support is lacking :p
12:27:23 <koz_> d34df00d: I would say that unless counting the length of ByteStrings is a bottleneck for you, it's probably not worth chasing.
12:27:34 <koz_> It's a clever trick, and _can_ be very useful, but I somehow doubt this is a bottleneck for you.
12:27:47 <merijn> koz_: Optimisation for optimisation's sake is fun!
12:27:55 <koz_> merijn: Agreed. I'm a _fan_ of SIMD hackery.
12:27:56 <shachaf> That doesn't look like a header file to me.
12:28:15 <koz_> (in fact, back when I was still doing my PhD, it's exactly this that allowed me to get like, a 256-fold speed-up on something)
12:28:16 <d34df00d> koz_: that's the char count, and it's a bottleneck.
12:28:23 <shachaf> But I'm glad you're at least trying to optimize the C as well as the Haskell.
12:28:35 <koz_> d34df00d: I'm curious what you're trying to do that has this as a bottleneck.
12:28:41 <d34df00d> koz_: count new lines in a file!
12:28:54 <merijn> koz_: I think he's working on a souped up Haskell "wc -l" ;)
12:28:58 <d34df00d> 1 sec vs 0.130 sec — that's a fairly significant difference.
12:29:04 <d34df00d> merijn: true.
12:29:19 <koz_> Ah, well, in that case, go right ahead.
12:29:37 <koz_> I would second merijn's suggestion to use the SIMD stuff in GHC and LLVM backend.
12:29:38 <d34df00d> shachaf: that's a PoC for me to play around and demonstrate the idea. It's by no means a ready-made library. And, in fact, I'm trying to optimize Haskell :]
12:29:50 <koz_> I'm guessing that you're on x86, so it should work.
12:29:56 <merijn> d34df00d: Basically, I'd love to see using this stuff in Haskell come more accessible, and the best way to get it there is to try and roll these things directly in Haskell and polish the bits where stuff gets stuck
12:31:48 <koz_> The translation from intrinsics to GHC SIMD stuff should be fairly straightforward.
12:31:58 <koz_> (modulo the bizarre naming for intrinsics)
12:32:14 * koz_ thinks back to that tweet about how PQLMULQDQ is pronounced)
12:32:25 <koz_> (or maybe it was PCLMULQDQ, I forget)
12:32:45 <koz_> (something something EIEIO)
12:33:34 <d34df00d> Peek-you'll-mul-qudie-q
12:33:49 <koz_> d34df00d: The suggested rendition in said tweet was 'pickle milk dick'.
12:33:56 <koz_> https://www.felixcloutier.com/x86/pclmulqdq <-- for the morbidly curious
12:34:55 <koz_> This is particularly true in the accent I'm used to hearing (NZ), because short 'i' in words like 'milk' becomes 'squashed' to more like a short 'u' sound (so 'mulk') in the local accent due to vowel swallowing.
12:35:52 <MarcelineVQ> there's no explanation for the NZ version of egg however
12:36:12 <koz_> MarcelineVQ: There probably is, I just don't know it because I'm not a linguist. Cunning or otherwise.
12:36:42 <koz_> Counter-point: In an Australian accent (at least to me), it would sound more like 'meelk'.
12:37:29 <d34df00d> I have a terrible russian accent so all that works for me.
12:37:47 <koz_> d34df00d: As in, full-on 'bear, vodka, balalaika'?
12:37:56 <koz_> Or, perhaps more accessibly, full-on Life of Boris?
12:38:00 <koz_> If so, _hell yes_.
12:38:02 <MarcelineVQ> There's two auz and two nz accents anyway. The high and the low.
12:39:04 <d34df00d> Sort of. Living in in English-speaking countries for a few years now but still didn't get rid of it.
12:39:31 <koz_> d34df00d: It's a tricky accent to smooth out. Spoken as someone who's taught English as a foreign language for like, several years.
12:39:50 <d34df00d> Although it saved my ass once when I accidentally got into a bad neighborhood — the guy who tried to mug me or smth immediately softened and tried to be friends when he recognized eastern european accent and learned I'm russian lol.
12:39:57 <koz_> LOL
12:40:11 <koz_> There was some comedy sketch about this kind of situation.
12:40:27 <koz_> Basically all I can remember is the comedian puts on a thick Russian accent and says "You think this is bad neighbourhood?".
12:40:42 <koz_> (with like, rolled R and hard H)
12:40:48 <koz_> (and downward inflection)
12:40:51 <d34df00d> Really? Haha, so that sketch might have some grounds yes.
12:41:56 <koz_> Less pleasant are situations like 'Oh, you're Russian? Do you drink vodka for breakfast?'.
12:42:01 <koz_> (I HAVE LITERALLY SEEN THIS)
12:42:38 <MarcelineVQ> did they?
12:42:43 <koz_> No.
12:43:12 <koz_> It's not exactly a common practice anywhere.
12:43:40 <d34df00d> I once was in a taxi where the driver (who also had a visible accent, but something asian I think) started asking something about "faka" once he learned my origins. It took me a while to figure out he pronounces "vodka" that way.
12:43:45 <MarcelineVQ> how can you be sure?
12:43:56 <koz_> MarcelineVQ: Because I knew said person pretty damn well.
12:44:05 <d34df00d> Can't say it was unpleasant — contrarily, it was quite fun! Maybe I'm just thick-skinned.
12:44:05 <MarcelineVQ> how can you be sure it's not a common practise anywhere
12:44:36 <koz_> MarcelineVQ: Depending on how you define 'anywhere', I'd be willing to assume.
12:44:45 <koz_> Since I doubt most of the population are raging alcoholics.
12:45:05 <maerwald> Vodka was a currency in russia once (in practice), maybe that's partly where those jokes come from
12:45:08 <MarcelineVQ> depends more on what vodka for breakfast entails
12:45:19 <d34df00d> maerwald: it still is in more rural areas.
12:45:23 <maerwald> yeah
12:45:25 <MarcelineVQ> If you mean downing a bottle then I'd agree it'd be pretty darn uncommon
12:46:28 <maerwald> vodka doesn't go well with haskell, but I figured wine goes well with Java (and is mandatory to bear it)
12:46:41 <koz_> maerwald: I think you need something a bit stronger.
12:46:44 <maerwald> lol
12:47:11 <merijn> maerwald: Whiskey ;)
12:47:12 <koz_> I now have this mental image of a wine mom Java programmer.
12:47:13 <MarcelineVQ> wine gives a worse hangover, you see
12:48:21 <maerwald> merijn: with Java? :/
12:48:28 <merijn> maerwald: No, Haskell :p
12:48:37 <koz_> merijn: Secret to your success?
12:48:42 <maerwald> right, makes your mind clear... right before the crash
12:48:42 <merijn> koz_: Yes
12:48:47 <merijn> koz_: Also for paper writing :p
12:49:07 <koz_> merijn: That second one I totally understand. It brings out our inner SPJ.
12:49:17 <merijn> Write drunk, edit sober
12:49:19 <koz_> Before you know it, everything is in Comic Sans and you're a GHC contributor. :P
12:49:34 <merijn> koz_: Nah, you just stop second guessing your writing continually while drunk, so you get more written
12:49:45 <merijn> And rewriting/editing/making text suck less is easier than writing
12:52:17 <d34df00d> merijn: cpuid isn't exposed by ghc is it?
12:52:30 <merijn> No idea, tbh :)
12:52:41 <merijn> d34df00d: Try asking in #ghc?
12:52:47 <d34df00d> So many channels.
12:53:07 <d34df00d> https://hackage.haskell.org/package/cpuid right.
12:53:31 <merijn> d34df00d: #ghc was also have the people you wanna ask SIMD-y details of, so :)
12:54:00 <d34df00d> But how do I do cpuid just once and save the right function somewhere where I could access it without living in IO or a bunch of unsafe* functions that I can't reason about?
12:54:31 <merijn> Why can't you reason about unsafe functions?
12:54:45 <d34df00d> Lack of experience with them mostly.
12:55:26 <merijn> d34df00d: I mean, unsafePerformIO is, honestly, pretty easy. Basically "You can't know whether this is run 0, 1, or more times", but if you don't care about that (because it doesn't matter), then it's fine
12:56:09 <d34df00d> But what if I care from the performance stand point?
12:56:38 <merijn> d34df00d: I mean, it's unlikely that it'll be executed a lot and then there's pragmas like NOINLINE, etc.
12:57:34 <d34df00d> On the other hand I've learned that neither I can't reason about the performance of pure and safe code, so there's no big difference here.
12:58:05 <merijn> d34df00d: How do you think people become experts at this? They mess around like you and stubbornly keep going :p
12:58:46 <maerwald> but it depends so much on GHC internals
13:01:06 <merijn> hmmm, I can't have a where block for guards in a case-of, can I?
13:02:47 <shachaf> You get one where for the case pattern, not one for each guard. Same as function definitions.
13:10:24 * hackage finito 0.1.0.0 - Constraint Solver for Finite Domains  https://hackage.haskell.org/package/finito-0.1.0.0 (MichaelSzvetits)
13:11:57 <dminuoso> 22:07:24      merijn | [20:55:04] d34df00d: I mean, unsafePerformIO is, honestly, pretty easy. Basically "You can't know whether this is run 0, 1, or more times", but if you don't care about that (because it doesn't matter), then it's fine
13:12:02 <dminuoso> merijn: I recently learned that this is not true.
13:13:18 <dminuoso> It detaches it from imposed sequentiality. For instance, it can lead to let-floating, which if you're talking about IORefs can have some pretty hairy results.
13:14:43 <geekosaur> merijn was talking in the context of something idempotent like cpuid, though
13:16:26 <dminuoso> geekosaur: By the way, did you have something else in mind earlier regarding -xc? Because it seems you cant specify that flag without profiling enabled unless there's some other option I'm missing.
13:16:35 <merijn> shachaf: My question was whether I could have one on a pattern in case-of at all
13:17:02 <geekosaur> I had thought they'd changed that, based on a discussion of the multiple kinds of stacks in ghc. misinterpretation, more or less. :(
13:17:09 <dminuoso> merijn: Yes you can
13:17:16 <merijn> :>
13:17:37 <dminuoso> I see. Well it's not changed on GHC HEAD at least.
13:18:05 <shachaf> > case 1 of 1 -> x where x = 2
13:18:07 <lambdabot>  2
13:18:55 <dminuoso> I learned that from monochrom's haskell resources infact. :)
13:19:40 <d34df00d> > [15:27:56] merijn: d34df00d: Well, I'd say it's worth it doing purely in Haskell, if only to see where the SIMD support is lacking :p
13:19:42 <lambdabot>  <hint>:1:34: error: parse error on input ‘,’
13:19:46 <d34df00d> I think there's no cmpestrm instruction exposed.
13:19:49 <d34df00d> So here it's lacking.
13:20:22 <d34df00d> So no nice fast SSE4.2 implementation (although smth based on _mm_cmpeq_epi8 might be not that slower).
13:20:33 <tabaqui1> if one is using free monads, how would be look like bracket-like function and corresponding data?
13:20:43 <merijn> d34df00d: Be the change you want to see in the world ;)
13:20:53 <tabaqui1> so I want a function "withContext :: Free Context -> (Context -> Free a) -> Free a"
13:21:04 <koz_> d34df00d: Does this compile down to https://www.felixcloutier.com/x86/pcmpestrm ?
13:21:22 <tabaqui1> how should I implement "WithContext :: ... FreeF next", and withContext itself?
13:21:29 <d34df00d> merijn: I don't think it fits nicely into the paradigm ghc tries to follow. They seem to be willing to expose more high-level primitives that "just" operate on vectors, abstracting a bit from the specific machine instructions.
13:21:31 <d34df00d> koz_: yes.
13:21:43 <d34df00d> koz_: hold on, what do you mean by "it"?
13:21:47 <d34df00d> Or "this"
13:21:54 * d34df00d pretends to be javascript.
13:21:59 <koz_> d34df00d: The missing intrinsic.
13:22:02 <d34df00d> Ah yes.
13:22:14 <koz_> I always ask, because some intrinsics don't 'translate down' straightforwardly.
13:22:40 <tabaqui1> err, Free is a bad type name, let it be Machine and MachineF
13:24:02 <koz_> d34df00d: I'd say 'try writing the equivalent with the intrinsics you have and see what the LLVM backend vomits'.
13:24:19 <koz_> Make sure you inform it in no uncertain terms that SSE4.2 is OK.
13:24:21 <koz_> It might just do it anyway.
13:24:32 <koz_> Turn the optimization to the nines as well to help it along.
13:25:05 <d34df00d> How do I do the latter?
13:25:05 <tabaqui1> ok, nevermind, the issue doesn't require special data field
13:25:17 <tabaqui1> it's just "withContext get run = get >>= run" :)
13:25:21 <d34df00d> I had some bad time trying to pass flags to opt and whatever else there is.
13:25:34 <tabaqui1> so stupid :)
13:26:16 <koz_> d34df00d: I dunno - maybe someone in #ghc might?
13:26:20 <koz_> Or here, possibly.
13:26:57 <tabaqui1> not quite, still
13:27:04 <tabaqui1> nevermind, anyway
13:28:02 <d34df00d> I should definitely ask in ghc next time.
13:28:09 <MarcelineVQ> d34df00d, koz_: something I saw recently that you might care about https://personal.cis.strath.ac.uk/james.wood.100/blog/html/VecMat.html
13:28:40 <d34df00d> I'm glad I went through VFPA and can finally read some Agda.
13:29:16 <koz_> MarcelineVQ: Interesting. From reading just the first few lines, it sounds like they're going with pull arrays. :P
13:30:22 <MarcelineVQ> it's rather about how to work with / think of the proofs nicer
13:30:25 <koz_> d34df00d: I'm sure there's a way to pass options to the LLVM back-end, I've just never done it in this context.
13:30:37 <koz_> If this were clang, then I'd know exactly what to yeet at it.
13:31:12 <d34df00d> koz_: I was trying to make llvm to do effectively what clang does with -march=native, but it had no performance effect on my code (which is quite unlikely given it was quite numeric, in a sense).
13:31:26 <d34df00d> http://0xd34df00d.me/posts/2020/01/fast-edit-distance.html if you wonder (no click bait this time).
13:32:19 <koz_> d34df00d: Interesting.
13:44:29 <merijn> d34df00d: #ghc is more lively during EU office hours generally, so that'd help, because stuff like the LLVM backend are a bit niche (which means that more users/testing == great!)
13:47:27 <dmj`> I really hope the Asterius backend gets merged into GHC proper
13:47:45 <dmj`> maintaining a ghc fork seems to be a lost cause in the long run
13:48:22 <koz_> dmj`: What's the Asterius back-end?
13:48:43 <dmj`> koz_: WASM
13:50:46 <dmj`> koz_: it's a fork of GHC though
13:54:27 <koz_> Ah.
14:05:05 <hseg> hrm. i want a class C f r with the constraint that instances must satisfy f ~ F r, for F fixed, injective. is there some way of convincing GHC the params of this typeclass determine each other?
14:05:52 <hseg> ... or, well, i want instances C (t (F r)) (t r)
14:06:15 <hseg> (i.e. i want C f r | f -> r, r -> f
14:06:17 <hseg> )
14:07:17 <hseg> ideally, this'd be in a backpack-compatible manner
14:13:54 <hseg> idea: have F :: * -> * -> Fk and have C :: Fk -> Constraint with type families Fst, Snd :: Fk -> *
14:24:48 <jackdk> hseg: got a concrete instance?
14:25:02 <jackdk> I'm trying to sketch this but cannot think of an instance
14:28:48 <merijn> I think hseg is doing advanced hasochism ;)
14:29:22 <jackdk> I can write `class f ~ F r => HSeg f r | f -> r, r -> f where { type F r }` but then I'm not sure what to do with it.
14:29:50 * jackdk shrugs
14:30:29 <jackdk> welcome back hseg. Did you miss any messages?
14:31:04 <hseg> missed last 15m
14:31:11 <hseg> since my post re an idea
14:31:37 <jackdk> hseg: got a concrete instance in mind? I can write `class f ~ F r => HSeg f r | f -> r, r -> f where { type F r }` but then I'm not sure what to do with it.
14:34:42 <hseg> hrm - logs seem to cut off
14:35:11 <hseg> specifically, am trying to encode the concept of the fraction field of an integral domain
14:35:54 <hseg> want class f ~ ConcreteFraction r => Fraction f r where { numerator, denominator :: f -> r; (%) :: r -> r -> f } 
14:36:21 <hseg> in particular, want fundeps to say f and r determine each other
14:37:40 <hseg> ... actually, looking at my code, all i need is Fraction (Ext f r) with some maps Ext f r |-> f, Ext f r |-> r
14:38:04 <hseg> don't need fundep fanciness
14:38:51 <jackdk> the fundeps would be `| f -> r, r -> f`. the end
14:39:20 <hseg> righ
14:39:22 <hseg> right
14:40:02 <hseg> ... can avoid fundeps by restriction Fraction to only accept instances of kind '(_,_)
14:40:11 <hseg> (or sth iso to that)
14:40:38 <jackdk> hseg https://www.irccloud.com/pastebin/73eneCvb/Fraction.hs
14:40:47 <jackdk> do with this what you will.
14:42:15 <nh> i did about 14k in billable work in 2 hours the other night in front of the telly
14:42:19 <nh> oof wrong chan
14:42:33 <jackdk> hopefully billed to the correct client ;-)
14:43:19 <nh> unfortunately it wasn't haskell, i wish it was
15:11:34 <koz_> :t (=<<)
15:11:36 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:59:56 <guest88> what's the best workflow for haskell? I have visual studio code open to write, along with a separate GHCI window to run my script but this approach feels so clunky
16:02:42 <glguy> I prefer an editor window and then ghcid (it's like ghci but it automatically reloads on file save and has some other useful options)
16:03:27 <zeta_0> guest88: i'd recommend setting up ghcid with that workflow(but i use emacs instead of visual studio). That's for large projects, but for interacting with small haskell programs i'd recommend ihaskell(it's very interactive)
16:05:35 <zeta_0> could you guys send me a link that shows a bunch of simple and practical examples of parallelism and concurrency in haskell?
16:09:09 <zeta_0> guest88: i forgot to mention ghcide, that has great ide support and is currently being integrated with haskell-ide-engine, also, i'd recommend using either the nix or guile package managers, they will save you from dependency hell
16:11:17 <guest88> zeta_0: thanks for the suggestions!
16:11:43 <zeta_0> guest88: your welcome
16:27:43 <jackdk> zeta_0: there is a book called parallel and concurrent programming in haskell.
16:34:04 <zeta_0> jackdk: ok, thanks
16:37:45 <dsal> concurrency in haskell is really nice.  Parallelism doesn't come up as much for me.  It's theoretically also nice, though.
16:42:44 <hpc> yeah, i think i like concurrency better than parallelism in haskell, even if parallelism is theoretically nicer
16:42:58 <hpc> because it's so easy to do concurrent stuff that would be absolute misery in another language
16:43:22 <hpc> you can write a worker thread in three lines of code
16:43:37 <hpc> make a Chan (IO ()), then forkIO a loop of read from chan and execute
16:44:17 <hpc> handles closures correctly, the syntax for passing an action to the other thread is super clean, and i can make hundreds of these threads if i felt like
16:44:42 <dsal> I pretty much just go straight to the async package.
16:44:49 <hpc> that too
16:45:09 <hpc> but i mean, that's even more illustrative
16:45:36 <hpc> i am not even doing it the "easy" way
16:45:51 <jle`> the fact that async is a relatively clean package wrapping up common usage patterns vs. something that is built into the language is pretty nice
16:46:55 <d34df00d> Do you folks know of any packages that use AVX assembly/C intrinsics? I'd like to take a look how they do it.
16:47:16 <d34df00d> I did something myself for bytestring, and now the tests sometimes don't terminate, with backtraces in RTS, not in my C code.
16:47:23 <d34df00d> So I wonder if I messed something up.
16:49:27 <koz_> d34df00d: HaskellWorks has a bunch of them.
16:49:43 <koz_> So basically, check all the stuff on Hackage prefixed hw-, and you'll find one pretty fast.
16:49:51 <d34df00d> Haha cool, will do.
16:57:37 <dmj`> hpc: the fact we can just pass around a function let sendWork :: msg -> IO (); sendWork = writeChan chan; is so nice
16:58:07 <dmj`> #blessed
17:00:20 <hpc> i attribute it more to the types
17:00:32 <hpc> MVar/Chan/etc just have a very nice api
17:00:45 <hpc> i don't think i ever really understood concurrency until i looked at those types
17:00:51 <hpc> then it all fell into place
17:02:11 <Axman6> well undersrtanding concurrency is significant;y simpler when you have limited or no mutation - I guess having good types for ther things which are explicitly mutable helps a lot
17:03:58 <dsal> stm still amazes me every time I use it.  I feel like it just shouldn't work.  TChan is simultaneously magic and trivial.
17:06:19 <d34df00d> koz_: well, I don't think they do anything super fancy.
17:06:24 <d34df00d> So dunno.
17:06:53 * hackage lumberjack 0.1.0.0 - Trek through your code forest and make logs  https://hackage.haskell.org/package/lumberjack-0.1.0.0 (KevinQuick)
17:08:23 <d34df00d> Anyway, I'd be grateful if somebody could take a look at https://github.com/haskell/bytestring/pull/202/files
17:08:36 <d34df00d> bytestring is quite a foundational library and I really don't want to mess it up.
17:20:03 <koz_> d34df00d: That's a sick patch you've got. Nice!
17:21:58 <d34df00d> koz_: beating c with haskell, y'know.
17:22:00 <d34df00d> Thanks!
17:26:57 * koz_ wonders if ByteString has something like popcount.
17:28:41 <jackdk> Axman6 Axman6 Axman6 Axman6 Axman6
17:29:24 <koz_> jackdk: Wow, you must want their attention bad.
17:29:35 <d34df00d> Should've repeated 6 times.
17:29:41 <jackdk> I live to disappoint
17:29:52 <koz_> He's now going to appear behind you. With his axe.
17:30:07 <jackdk> He likes making things go fast, so I think he'd like that patch
17:30:35 <d34df00d> Ah.
17:30:37 <d34df00d> Thanks then!
17:31:32 <jackdk> e.g. https://github.com/text-utf8/text-utf8/pull/1
17:31:46 <jackdk> don't think he has merge privs for bytstring, I just know that he likes speed
17:32:36 <d34df00d> That's great cause it quite improves the speed (especially the AVX2 version).
17:32:45 <koz_> Is text-utf8 even live at this stage?
17:33:02 <koz_> One of these days, I'm gonna hammer out some NEON stuff for this. :P
17:33:43 <d34df00d> I wish I could get my hands on NEON, but the only chance for me is either qemu (which I don't think is representative) or amazon ec2 arm machines (which I'm lazy to learn).
17:34:39 <koz_> d34df00d: I only have ARMv7 devices handy, and getting GHC to even function on those is a small nightmare.
17:34:52 <koz_> I've been thinking of getting an ARMv8 microserver, which I might just use for this very purpose.
17:35:12 <d34df00d> Haha, some folks managed to get ghc going on SPARC/SunOS and PowerPC/AIX.
17:35:14 <koz_> Because I clearly don't spend _enough_ on electronic gadgetry.
17:35:24 <koz_> d34df00d: Believe me, I have _tried_ to get GHC up on ARMv7.
17:35:25 <d34df00d> I was present at local meetings, let's just say they were quite tired.
17:35:29 <koz_> It did not end... well.
17:35:44 <d34df00d> I mean, that was at my previous job.
17:35:46 <koz_> Speaking as someone who ported Gentoo to such a device.
17:35:55 <d34df00d> Lol, I use gentoo too.
17:41:21 <koz_> What's that list-like thing with cheap(er) concatenations?
17:41:53 <ChaiTRex> koz_: Seq?
17:42:10 <koz_> ChaiTRex: Yeah, that one.
17:42:13 <koz_> Thanks.
17:43:02 <ChaiTRex> koz_: No problem.
17:58:23 * hackage brick 0.52 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.52 (JonathanDaugherty)
18:07:14 <hololeap> gentoo!
18:07:24 <koz_> hololeap: Yep, former Gentooligan right here.
18:07:49 <hololeap> it's been my main os for like 10 years now
18:09:18 <hololeap> to the point that i turn my nose up at other distros because they're not gentoo-ey enough for me
18:13:09 <hololeap> of course, i know now that taking the time to compile everything allows cosmic rays to mystically embue themselves into the resulting binaries, not just increasing speed but also warding off malware
18:13:38 <koz_> hololeap: There is a reason I have an intimate familiarity with GCC compile speeds. :P
18:13:43 <koz_> (and LLVM compile speeds)
18:14:58 <hololeap> did you ever install haskell packages through portage?
18:16:13 <hololeap> it can be hours of fun, depending on how much needs to rebuild after a dependency gets upgraded
18:17:03 <koz_> hololeap: Nope, never had that fun.
18:29:19 <d34df00d> I used portage to setup up the environment for my haskell stuff quite a lot before I learned about stack a few years ago.
18:30:07 <d34df00d> And frankly that was one of the primary reasons of using gentoo for me, but lately I started questioning whether it makes sense to run gentoo on at least some of the machines that I own (like my laptop).
18:30:52 <d34df00d> Another one is habit and sort-of-understanding what's going on in the system. I'm too lazy to learn stuff (like new distros) that's neither fun nor rewarding in terms of filling the gap to some more fun later.
19:26:57 <justsomeguy> Argh, I keep on trying to learn Haskell, and then failing hard.
21:11:36 <jackdk> I found that nixos gave me the control of gentoo with proper binary caches and I've never been happier
21:12:43 <jackdk> Question: my cabal v2-build is failing with `ghc-pkg: {handle: /[...]/dist-newstyle/packagedb/ghc-8.6.5/package.cache.lock}: hLock: resource exhausted (No locks available)`. How can I diagnose the cause? A websearch did not turn up anything useful
21:18:31 <happycoder> Is there anyway to do `let foo = getFoo in ..` if getFoo is of existential type `SFoo a`. For example `data SFoo a where {SFooInt :: SFoo Int; SFooString :: SFoo String}`
21:20:19 <jackdk> What is the type of `getFoo`?
21:20:49 <happycoder> SFoo a
21:20:58 <jle`> what happens when you try it?
21:21:06 <jle`> is it forall a. SFoo a ?
21:21:10 <happycoder> yes
21:21:22 <jle`> and you want *foo* to also be polymorphic ?
21:21:47 <happycoder> please hold on, let me upload a gist
21:21:51 <jle`> ah, so you mean 'polymorphic type', not existential type, right?
21:25:47 <happycoder> This is what I'm trying to do: https://gist.github.com/happycoder97/d430633bb43ce49fba6da461bf7f3e15
21:26:45 <koz_> In unordered-containers, Data.HashMap.Lazy says it evaluates keys to WHNF (which I assume means values are evaluated on demand), but Data.HashMap.Strict says nothing.
21:27:01 <koz_> Am I right in assuming that Data.HashMap.Strict evaluates both keys and values to WHNF?
21:27:19 <koz_> (and yes, I mentally sound it as 'wuhh-nuff')
21:29:43 <Cale> koz_: It almost certainly evaluates keys to more than WHNF, it's usually hard to compute hashes of keys without fully evaluating them
21:30:17 <Cale> WHNF just means to the point that it's a constructor applied to arguments, or any lambda (but that's irrelevant here)
21:30:22 <koz_> Cale: I assume you're referring to Data.HashMap.Strict? If this is the case, that's a documentation bug.
21:30:25 <Cale> Yeah
21:30:44 <koz_> https://hackage.haskell.org/package/unordered-containers-0.2.10.0/docs/Data-HashMap-Lazy.html#g:1
21:30:50 <Cale> I mean, it's not wrong, in that WHNF is the least it could possibly evaluate them
21:30:53 <koz_> That's the text in question.
21:31:11 <koz_> Sorry, that's in Data.HashMap.Lazy.
21:31:19 <koz_> Data.HashMap.Strict just straight-up says nothing.
21:31:19 <Cale> It's just that unless you have broken Hashable instances, probably it's going to evaluate more than that
21:31:26 <Cale> I'm sure it'll be the same
21:31:37 <Cale> Pretty much, you can assume the keys get evaluated
21:31:37 <koz_> So I guess the difference is how they treat values?
21:31:39 <Cale> Yeah
21:31:56 <koz_> I'm guessing that .Lazy means 'I don't evaluate values unless you ask me to', and .Strict means 'WHNF even on values'.
21:32:16 <Cale> Also, I don't think the datatypes they expose are different, only the functions are
21:32:45 <Cale> The .Strict module having functions that will incidentally force the evaluation of values they touch
21:33:12 <koz_> OK, thanks, that makes sense.
21:41:57 <happycoder> If I have a type `data SDataType (t :: DataType) where <..snip>` The only way to have a function return it is by either using a wrapper type to hide the type variable or by providing a continuation function right?
21:42:33 <mac10688> Hi all, I am trying to tidy my code up but I have a problem. My case statement returns a lens but the last one is of a different type but I feel there is something I can do
21:42:35 <mac10688> https://pastebin.com/MQTaV7DP
21:43:03 <mac10688> otherwise I have to write the same code in each case and it's very duplicated
21:44:00 <jackdk> the main problem is that you have an enum whose keys correspond to lenses?
21:44:09 <mac10688> yes
21:45:11 <mac10688> I want to get the lens and then let the application framework (brick) handle the event
21:47:24 <jackdk> what if you made the enum a GADT and then made a function from the tag to the lens?
21:49:49 <mac10688> Ok I'll consider that. It seems unlikely that I can do that because that enum is used by the application framework to look up fields
21:50:07 <Cale> happycoder: Not necessarily...
21:50:34 <happycoder> is there any other way?
21:50:53 <Cale> happycoder: Well, you could fix the value of the type index
21:51:11 <happycoder> okay without fixing that :D
21:51:13 <Cale> e.g. if X :: DataType, then you could have foo :: ... -> SDataType X
21:51:28 <Cale> Or, the function might have an argument which is also indexed on DataType
21:51:39 <happycoder> oh right
21:51:47 <happycoder> that's also possible
21:51:53 <Cale> bar :: A t -> SDataType t
21:52:07 <happycoder> any other way?
21:52:25 <Cale> SDataType might define a constructor which is polymorphic
21:52:42 <Cale> (but its name does suggest that it's a singleton type, so it probably won't ;)
21:53:52 <happycoder> how does that work? 
21:54:23 <jackdk> mac10688:  https://www.irccloud.com/pastebin/x8U01vb0/RecLens.hs
21:54:24 <Cale> You can always have something like
21:54:27 <Cale> data Foo a where
21:54:32 <Cale>   MkFoo :: a -> Foo a
21:54:35 <Cale> right?
21:54:39 <happycoder> right
21:54:42 <Cale> But also, if G is some other GADT
21:54:50 <Cale> you could have a constructor like
21:54:54 <jackdk> Question: my cabal v2-build is failing with `ghc-pkg: {handle: /[...]/dist-newstyle/packagedb/ghc-8.6.5/package.cache.lock}: hLock: resource exhausted (No locks available)`. How can I diagnose the cause? A websearch did not turn up anything useful
21:54:58 <Cale>   IncludeG :: G a -> Foo a
21:55:52 <Cale> This is handy in the case that the values of your GADT represent labels for pieces of information, indexed on the type of the information that would go with it
21:55:58 <Cale> Like, you might have something like:
21:56:03 <Cale> data Employee a where
21:56:08 <Cale>   Name :: Employee Text
21:56:20 <Cale>   Address :: Address a -> Employee a
21:56:42 <Cale>   Salary :: Employee Integer
21:56:48 <Cale> data Address a where
21:57:02 <Cale>   StreetAddress :: Address Text
21:57:18 <Cale>   Country :: Address CountryCode
21:57:24 <Cale> etc. you get the idea
21:57:38 <happycoder> okay
21:57:51 <happycoder> I kinda get it, I'll work on it
21:58:03 <Cale> You can use this kind of thing along with DMap to collect key/value pairs of varying types together
21:58:24 <Cale> and DSum to represent single appropriately-typed key/value pairs
21:58:41 <happycoder> DMap? is it in base?
21:58:41 <Cale> data DSum f g where
21:58:48 <Cale> no, it's in dependent-map
21:58:56 <Cale> and DSum is in dependent-sum
21:59:03 <Cale> (kind of silly that they're separate...)
21:59:09 <happycoder> yeah
21:59:25 <jackdk> especially given that Data.Dependent.Map re-exports DSum anyway
21:59:34 <Cale> haha, yeah
22:00:40 <Cale> values of type DSum f g are values of the form k :=> v where k :: f a and v :: g a
22:00:45 <jackdk> btw, constraints-extras has some useful stuff in it for working the GADT of keys
22:01:06 <mac10688> Thanks jackdk, I didn't think of coding like this. I'll try to make this happen
22:01:21 <jackdk> things like "ask that every possible a mentioned by the key type has an instance for some class c"
22:01:58 <Poscat[m]> Is it possible to generate servant code from swagger.yaml?
22:02:02 <Cale> So, e.g. a value of type DSum Employee Identity will consist of one of those "field labels" and a correspondingly typed value, like Address StreetAddress :=> Identity "456 Grover Line"
22:02:49 <Cale> (often the g will be Identity, but occasionally other things are useful as well)
22:03:06 <Axman6> Poscat[m]: yes, editor.swagger.io (IIRC) will generate both the client and server for you. it usually needs some work done to it after generation but it goes a long way
22:03:10 <Cale> DMap is like an efficient way to store many of these key/value pairs together
22:03:27 <Cale> (so, like, all the information you have about an Employee, for example)
22:04:24 <Cale> This way of carving up data types isn't always the nicest to work with, but sometimes if you have a very large number of potential fields and lots of partial data, it can help manage
22:05:01 <jackdk> it's pretty nice for JSON
22:05:11 <Poscat[m]> Axman6: Thanks, this is exactly what I wanted.
22:05:22 <jackdk> when you want to have known types at each key but not necessarily stand up a bunch of custom types to do it
22:06:10 <Cale> Yeah, JSON like some non-Haskellers like to make where random subsets of the fields might be missing :)
22:06:38 <Cale> (in particular)
22:07:36 <Axman6> a.ka. pure madness
22:08:22 <Axman6> a.k.a.*
22:08:32 <Cale> Pure madness is when they tell you the fields have certain types, e.g. that something will be an array of things, and then sometimes it's just a single one of those things not in an array
22:08:48 <Axman6> (really hoping some bot out there is having a good time evaluating that regex)
22:09:04 <Axman6> Cale: I hear you, god I hate that crap
22:10:19 <Cale> haha, we have some data types in a client project that are parametrised over multiple functors to be able to deal with all the stupid inconsistencies of an external db
22:10:59 <Cale> (but hey, at least there's a way to cope!)
22:11:17 <Cale> Also, a bunch of rather funny functors for that purpose
22:11:49 <Cale> Explaining all the things that typically go wrong with each field
22:29:21 <Axman6> data Bonkers a = BonkersMissing | BonkersNull | BonkersJustOne a | BonkersMany [a] | BonkersUWotM8 Value
22:32:28 <mac10688> https://pastebin.com/YRNsFt6X
22:32:39 <mac10688> jackdk: I ended up solving my problem with a helper function
22:32:52 <mac10688> but I did have to specify the type signature
23:00:07 <harry_t> lambdabot: help
23:00:29 <harry_t> lambdabot: let f x = x + 1
23:00:40 <Axman6> Help me lambdabot kleisli, you're our only hope!
23:00:56 <Axman6> > let f x y = x^2 + y in f 6 3
23:00:59 <lambdabot>  39
23:59:13 <idnar> Cale: oh! I was trying to do something with type-level-sets the other day but dependent-map is probably what I wanted
