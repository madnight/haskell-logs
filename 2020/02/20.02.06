00:24:48 <maralorn[m]> dminuoso: Will probably now yell at me. But this feels to me like a moment where an orphan instance might be fine.^^
00:28:49 <blackbart> I want to do some 3d modeling and hoping for some suggestings on libraries towards that purpose. For example, I'd like to be able to display a sphere with the ability to zoom/pan. SceneGraph appears to be an option, but seems outdated.
00:38:33 <dminuoso> maralorn[m]: A better fit is to just not use the typeclass interface at all.
00:38:47 <dminuoso> maralorn[m]: You can just write `fooToJson :: Foo -> Value` and then just use that.
00:38:55 <dminuoso> maralorn[m]: Voila, no orphan instances necessary.
00:39:56 <dminuoso> maralorn[m]: The only parts of aeson that needs ToJSON instances is if you want generically derived instances and the top-level encode/decode functions. For the former its trivial and most likely more desirable to write it yourself.
00:41:00 <dminuoso> And the latter it's easy to just newtype it.
00:42:02 <maralorn[m]> dminuoso: Yeah, I know. ^^
00:43:06 <alanz> jneira_: you can always make a PR on haskell-lsp-types
00:43:16 <maralorn[m]> dminuoso: But I am a bit fuzzy in the last part. How'd you get a derived instance via a newtype?
00:44:29 <maralorn[m]> If the grander structure you are trying to derive for is not polymorphic over the type you are missing the instance for?
00:45:42 <maralorn[m]> alanz: Is ghcide always going to be a submodule of haskell-language-server or is that a temporary arrangement? 
00:46:23 <alanz> maralorn[m]: its already gone in master
00:46:41 <alanz> But likely to come and go during dev
00:48:47 <maralorn[m]> Oh, okay. ^^
00:58:50 <albet70> can we use guards syntax in do notation?
00:59:24 <olligobber> albet70, can you provide an example of what you mean?
00:59:40 <olligobber> you can use the guard function in Control.Monad
01:01:16 <albet70> sayMe x | x < 3 = "less than 3" | x == 3 = "equal with 3"
01:01:41 <albet70> what if sayMe x :: IO ()?
01:02:48 <albet70> or x :: Maybe Int
01:02:56 <olligobber> you could do something like f x | x < 3 = print "less" | x == 3 = print "equal", there's no do notation there so it's fine
01:03:16 <albet70> x :: Maybe Int?
01:04:40 <olligobber> in that case you would need something like f (Just x) = ...; f Nothing = ...
01:05:07 <albet70> what about do notation?
01:05:15 <albet70> get x from Just x
01:05:40 <albet70> can 'guard' work within do notation?
01:05:49 <albet70> '|' I mean
01:06:54 <albet70> sayMe x = do y <- x ; if y < 3 then print "less than 3" ...
01:07:18 <merijn> albet70: That works (assuming you also provide else, winsce it's mandatory)
01:07:18 <albet70> x :: IO Int
01:07:40 <merijn> albet70: As for the Maybe case, then you can just use case-of
01:08:17 <dminuoso> What is the most efficient way to extract an Integer 12 out of `"swp12" :: Text`?
01:08:18 <albet70> merijn I just want to know what its looks like when | work within do notation
01:08:24 <merijn> albet70: Like "case x of Just y -> ...; Nothing -> ..."
01:08:31 <albet70> ...
01:08:39 <olligobber> I don't think you can put | in do notation
01:08:42 <merijn> albet70: You can't use | in do notation
01:08:45 <albet70> can we have '|' in it?
01:08:49 <albet70> ok
01:08:51 <merijn> albet70: You can use | in case, yes
01:09:09 <merijn> albet70: "case x of Just y | y > 3 -> ...; _ -> ..." is perfectly fine
01:09:13 <olligobber> I don't even know what a guard in do notation would mean
01:09:39 <albet70> just like what case or if-else mean
01:09:41 <merijn> > case Just 5 of { Just x | x > 3 -> "Yay"; _ -> "Boo" }
01:09:43 <lambdabot>  "Yay"
01:09:49 <merijn> > case Just 2 of { Just x | x > 3 -> "Yay"; _ -> "Boo" }
01:09:52 <lambdabot>  "Boo"
01:10:48 <dminuoso> Mmm, also, why doesn't containers supply a type for infinite lazy sets? :<
01:11:21 <merijn> dminuoso: What would you even use those for?
01:11:31 <merijn> dminuoso: That seems like a super obscure/niche use case
01:11:49 <albet70> there're always a bunch of if-then-else in my code, and it's really ugly
01:12:21 <merijn> albet70: If you use "let" inside your do block you can attach guards to those
01:12:28 <olligobber> albet70, wanna link your code so we can suggest ways to clean it up a bit?
01:13:30 <dminuoso> merijn: Well I have an infinite sorted list and I want test things whether they are a member of that list without paying O(n)
01:13:54 <merijn> dminuoso: How would an infinite set improve that?
01:14:03 <merijn> dminuoso: That'd be super expensive to build
01:14:46 <dminuoso> merijn: I have no idea whether it is expensive to build, perhaps there exists an efficient construction for it?
01:15:27 <albet70> olligobber https://paste.ubuntu.com/p/hrnWkKvs2F/
01:18:16 <merijn> albet70: On line 155 the case with if inside you can put the if as guard on the case like I showed
01:18:57 <merijn> So instead of "Just x -> do" make it "Just latestId | not (latestId == upId) -> do"
01:24:59 <day> dminuoso: if the list is sorted, wouldnt it be O(log(n))? you can divide and conquer
01:25:13 <dminuoso> day: How do you divide/conquer an infinite list?
01:25:34 <dminuoso> I mean I get it, that I need to pay O(n) on first lookup.
01:25:38 <day> just check infinite/2 D:
01:27:27 <tdammers> you could of course have a Set API on top of predicates and predicate combinators
01:27:35 <tdammers> I've experimented with that idea a little
01:27:50 <boxscape> I imagine the way you would do binary search on an infinite data structure is by starting by looking at element k, and if that element is larger than the one you're looking for, look at k/2, otherwise, look at k*2
01:28:15 <tdammers> the idea being that if lists represent iterations, then sets could represent predicates
01:28:32 <tdammers> essentially, newtype Set a = Set { member :: a -> Bool }
01:29:16 <dminuoso> boxscape: With lists that wont work. To even access element `k` you pay O(n) already.
01:29:17 <tdammers> an interesting requirement for infinite sets, however, is that their domain must be infinite too
01:29:30 <dminuoso> boxscape: So you're giving me something like n*log n
01:29:38 <tdammers> you can have an infinite list of ints, but you can't have an infinite set of ints
01:29:49 <boxscape> dminuoso yes, you'd need a different data structyure
01:31:05 <boxscape> ...though I can't think of any structure that would give you O(log(n)) for arbitrarily large n, actually
01:31:27 <dminuoso> boxscape: Set is that, already.
01:31:52 <dminuoso> boxscape: Remember that complexity is about asymptotics.
01:32:27 <__monty__> Would a hashset be?
01:32:33 <dminuoso> In my case its not arbitrarily large, its infinitely large.
01:33:04 <boxscape> oh right you're not trying to find an element you're trying to find out whether it's a member
01:33:15 <dminuoso> __monty__: Interesting. Are you thinking of a lazy memoizing hashset?
01:33:30 <davve> infinitely larges things are better represented as sparse data structures :p
01:33:50 <__monty__> dminuoso: Gods no. Just of hash functions with a limited range.
01:34:03 <olligobber> albet70, https://gist.github.com/olligobber/bbcc71112b87a06a09f67ce3fd798e3b
01:34:17 <dminuoso> __monty__: Well wouldn't that idea work though if we did a lazy memoizing hashset with cockoo hashing?
01:35:04 <dminuoso> Although I suppose that would give me back into O(n) territory 
01:38:07 <__monty__> dminuoso: As I read it a cuckoo hash table is still finite. Hence you'd still run into problems when the table fills up?
01:38:28 <albet70> yeah
01:40:47 <boxscape> have you seen that a lazyset package exists dminuoso?
01:41:39 <dminuoso> boxscape: Judging from the implementation it's still O(n)
01:42:05 <boxscape> hmm
01:42:36 <olligobber> albet70, if you broke some of the bigger functions into smaller parts it might look a bit neater
01:42:40 <fobarbaer> Hi, I could use some help trying to fix 'ghc-cabal: error while loading shared libraries:'
01:42:43 <boxscape> the docs say the performance for `member` is "O(m)=log m" which seems like an odd statement to make
01:44:34 <dminuoso> boxscape: That implementation is just a list of consecutive "ascending" sets (in the sense that if you turned them all back into lists and concat'ed them, you'd have the original list), where the sets get increasingly larger
01:45:11 <albet70> olligobber there're a bunch of if-else in relayIRC2Tele that's really ugly
01:45:34 <albet70> and also recvMsg
01:45:52 <albet70> case of in recvMsg
01:46:11 <tdammers> so suppose you have an infinitely large set of values, and you hash those - wouldn't that mean that you need either infinitely many hashes, or you'd get infinitely many collisions?
01:46:25 <dminuoso> boxscape: It seems that the initial access is O(n^2), with consecutive accesses being O(log(n))
01:46:32 <albet70> I wonder is there is skill can avoid those if else or case of
01:46:58 <dminuoso> boxscape: Because the set size grows exponentially.
01:47:09 <fobarbaer> He is the log. The lib does exist, but is not found. https://gist.github.com/gitter-bioinf/597550e52539464dae3546e3098c33d6
01:47:10 <albet70> can Maybe monad or other monads can help
01:47:29 <dminuoso> albet70: Decompose into more bindings.
01:47:46 <boxscape> dminuoso that makes sense, yeah
01:48:53 <dminuoso> boxscape: Actually its worse than O(log(n))
01:49:20 <dminuoso> I think? 
01:49:45 <boxscape> hm, I'm not the best at complexity analysis
01:51:05 <albet70> can Either Monad to help?
01:51:37 <albet70> like that a bunch of case of, they just check Bool value
01:51:38 <boxscape> it looks like it makes a lookup in each set smaller than the one you want? So an O(log(n)) for each of those sets
01:51:49 <boxscape> and you have O(log(n)) of those sets I think
01:51:57 <boxscape> so O(log(n)^2)?
01:52:07 <boxscape> but I might be completely wrong
01:52:10 <albet70> if create a monad like either, then there're two forks can run
01:52:24 <dminuoso> albet70: Decompose into bindings first. Tools to deal with bool/if/then/else include `when`, pattern guards, ...
01:53:21 <boxscape> since these are constructed from an ordered list it seems like it should be possible to keep track of upper and lower bounds for each of the little sets and do member for one of those in O(1), resulting in O(log(n)) for member overall
01:54:34 <olligobber> albet70, I updated my gist with a few more things to neaten it up
01:54:39 <dminuoso> fobarbaer: what does `ldconfig -v` give you?
01:55:07 <boxscape> with something like `data LazySet a = LazySet [(a, NSet.Set a)]`, where the a is the smallest member of that set
01:55:23 * hackage binary-strict 0.4.8.4 - Binary deserialisation using strict ByteStrings  https://hackage.haskell.org/package/binary-strict-0.4.8.4 (DominicSteinitz)
01:55:53 <albet70> new link?
01:56:01 <olligobber> albet70, https://gist.github.com/olligobber/bbcc71112b87a06a09f67ce3fd798e3b
01:56:26 <fobarbaer> @diminuoso I will run it before stack setup and paste a new gist
01:56:26 <lambdabot> Unknown command, try @list
01:56:45 <olligobber> lol
02:10:04 <fobarbaer> Ok, I am running it again to make sure its a clean build, but I think that ldconfig -v does not show libgmp.so.10, however listing PREFIX/lib does list that file
02:10:31 <fobarbaer> I will post a full log in a few mins
02:29:26 <fobarbaer> Ok here it is (ghc-cabal: error while loading shared libraries: libgmp.so.10: cannot open shared object file: No such file or directory) https://gist.github.com/gitter-bioinf/e5f6f9474881d18ac2bbfd906e8fed4a
02:32:11 <__monty__> fobarbaer: How'd you install ghc or cabal? It looks like you're missing an install of GMP, which should usually be handled for you afaik.
02:35:58 <fobarbaer> Here are the recipes: https://gist.github.com/gitter-bioinf/cec5589b784d07aba342b098e3bfeb40
02:36:43 <__monty__> I have no experience nor interest in reading this conda log, sorry.
02:36:45 <dminuoso> fobarbaer: I recommend you do not install a package manager supplied version of GHC.
02:38:05 <dminuoso> fobarbaer: At best this is a conda problem.
02:42:23 * hackage hpqtypes 1.8.0.1 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.8.0.1 (arybczak)
02:44:44 <fobarbaer> Which I am attempting to fix haha. Ok, so the first thing to do with haskell is the stack recipe which is super simple. It requires some version of gmp and then we download https://github.com/commercialhaskell/stack/releases/download/v{{ version }}/stack-{{ version }}-linux-x86_64.tar.gz where version is 1.9.3. After this things should be under my
02:44:45 <fobarbaer> control and in my recipe for sequencetools. I attempt to run stack setup to get lts-14.1.
02:54:13 <rain1> hi
02:57:31 <fobarbaer> Hi
02:59:22 <adalricus> hi
03:15:07 <ph88^> is there any way to make this work for old GHC?  unknown flag in  {-# OPTIONS_GHC #-} pragma: -Wno-deprecations  
03:16:36 <Phyx-> fendor: yes it should. but you either have to re-open the window, or call refreshenv
03:17:01 <Phyx-> fendor: If it isn't do let me know
03:19:32 <fendor> Phyx-, cool! maybe I messing something up, but I still get the following error message: https://gist.github.com/fendor/861ff63930472d408674058f8059312b
03:20:04 <fendor> I tried to start from an empty environment, e.g. removed all previous attempts to install stuff with choco and, removed haskell plattform, stack, cabal, etc...
03:20:41 <merijn> fendor: Well, do you have MinGW+MSYS or Cygwin?
03:20:54 <fendor> merijn, hopefully, I removed either
03:20:58 <fendor> *both
03:21:16 <fendor> but I almost definitely have remnants of a previous installation
03:21:56 <fendor> cygwin still seems to be installed, at least I can find it in the starting menu
03:23:23 * hackage ghc-typelits-natnormalise 0.7.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.7.1 (ChristiaanBaaij)
03:24:53 * hackage hasql-th 0.4.0.4 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.4 (NikitaVolkov)
03:54:08 <olligobber> albet70, happy?
04:00:47 <albet70> olligobber do you know MultiWayIf?
04:00:57 <olligobber> no
04:02:34 <albet70> olligobber that seems more intuitive
04:03:01 <olligobber> yeah, looks like it would suit your code well
04:03:34 <albet70> olligobber it combines if with guard
04:03:44 <olligobber> yeah, I googled it
04:03:50 <albet70> more intuitive actually
04:04:36 <absence> with the text-show library, i can derive a TextShow instance that just converts the result of "show" to Text like this "deriving via FromStringShow HttpException instance TextShow HttpException", but how can i do this for a constrained type, like all Exceptions? i can't figure out the syntax
04:05:20 <olligobber> you could achieve the same effect by splitting it up into more functions, and some would argue that would result in more readable code
04:05:58 <amy_monnet> Hey guys hope everyones doing well
04:06:44 <olligobber> hi amy_monnet, I hope you're doing well too
04:07:28 <albet70> yeah,
04:16:46 <Phyx-> fendor: did you have a cabal that existed before that?
04:17:25 <Phyx-> fendor: if you had an existing haskell installation and the config file was around the installer won't touch it.
04:19:07 <Phyx-> fendor: you coud fix this by doing `cabal user-config init -f` followed by `choco install -y --reinstall cabal`
04:19:32 <Phyx-> I should probably make the package emit a warning if it didn't touch an existing config with an error in it
04:19:53 <fendor> Phyx-, possibly, I deleted everything I could fine. Will try it. not `choco install -y --reinstall haskell-dev`?
04:20:26 <Phyx-> fendor: no, you don't need to force a reinstall of everything, only the cabal package which is what is making the configuration for cabal :)
04:20:38 <fendor> ok, trying rn!
04:29:08 <fendor> Phyx-, seems like it is working now, thank you very much!
04:32:30 <japans> https://www.youtube.com/watch?v=sQgMnFhmc50 world talking about it
04:38:19 <amy_monnet> has anyone deployed a site on digital ocean before?
04:38:37 <amy_monnet> got a dockerised webapp that serves static html files using servant
04:38:56 <amy_monnet> and I can fire it up and access it on localhost but don't know what to do with digital ocean
04:39:05 <amy_monnet> on the actual server machine
04:39:53 <adalricus> amy_monnet: you could setup some webserver like nginx to reverse proxy that webapp 
04:40:24 <adalricus> user -> nginx :80 or :443 -> webapp :port
04:40:48 <amy_monnet> so when I run my docker container if I went
04:41:12 <amy_monnet> docker run -p 443:8081 my-web-app
04:41:16 <amy_monnet> would that work?
04:41:33 <boxscape> % 5 = _
04:41:34 <yahb> boxscape: ; <interactive>:1:1: error:; GHC internal error: `Ghci5.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
04:41:41 <boxscape> ah, right
04:41:46 <boxscape> I forgot that yahb doesn't do holes
04:41:55 <adalricus> amy_monnet: i don't know what that docker command does
04:42:13 <boxscape> anyway ghci says `Found hole: _ :: Integer` and I was curious why it defaults there
04:42:15 <amy_monnet> it publishes the port from your docker container to the 443 port on your machine
04:42:22 <boxscape> why not give me the more general type with Eq and Num
04:42:37 <amy_monnet> so it essentially listens to any requests on 443. In my haskell code I deploy the web app on port 8081
04:42:39 <adalricus> yeah then it should work, amy first try 80:8081 and accesses it locally
04:42:48 <amy_monnet> yep can do that
04:42:57 <tdammers> if it literally just serves a bunch of files, then why not just use nginx
04:43:01 <amy_monnet> but can't access it via a url
04:43:03 <adalricus> i'm not sure if itts safe though
04:43:04 <tdammers> or apache, or lighttpd, or whatever
04:43:21 <amy_monnet> well it will do more eventually just playing around with haskell and elm web stack
04:43:41 <tdammers> k
04:44:05 <tdammers> I'd probably still use one of those, configure it as a reverse proxy for the dynamic stuff, and have it serve static files directly
04:44:06 <adalricus> have you configured that domain thing correctly? or maybe some firewall is blocking incoming connections?
04:44:22 <tdammers> there's simply no way you can do static files more efficiently with servant than any of those servers do it
04:44:23 <amy_monnet> double checking that now
04:50:46 <amy_monnet> Yep but I'm trying to do with servant and will add more things to the app later on
04:52:04 <adalricus> its fine, use other webserver and reverse proxy when deploying in prod though
04:54:18 <amy_monnet> Probably a stupid questions so apologies in advance since I don't know much about web dev. Why do we need another webserver like nginx when servant uses warp
04:55:50 <adalricus> you dont need, you could run whatever that servant thing is but then you'll have to configure https and other stuff in there, reverse proxying with other webserver and configuring stuff there is much easier
04:56:13 <adalricus> and with servant thing, only that can listen on :80, what if you want to run 2 webapps. how will you do that?
04:57:50 <adalricus> say app.domain for webapp1 and app2.domain for webapp2, if you setup a webserver to listen on :80 then you can ask it to do this. if you run webapp1 and let it capture :80 then you wont be able to run webapp2 on :80
05:01:24 <lortabac> boxscape: what does '5 = _' mean? It doesn't seem to serve any practical purpose
05:02:09 <hpc> amy_monnet: if you think like the people at say, cloudflare, you'd call nginx configured in that way a "layer 7 router"
05:02:21 <dminuoso> lortabac: It's one character less than `x :: _`
05:02:40 <albet70> f x = if | x == Just y -> print y | otherwise print "Nothing"
05:03:07 <lortabac> dminuoso: I don't understand
05:03:09 <albet70> how to pattern match Just v in guard syntax?
05:03:23 <albet70> case x of Just y is ok
05:03:34 <dminuoso> albet70: You cant do pattern matching/guards inside if.
05:03:37 <albet70> but with guard, how to match?
05:03:58 <dminuoso> albet70: You can use pattern guards
05:04:14 <dminuoso> albet70: f t | Just x <- t, x > 10 = ...
05:04:16 <albet70> dminuoso even enable MultiWayIf
05:04:26 <albet70> ?
05:04:31 <Phyx-> fendor: np. I need to make this clearer during install. or just blow away people's configs. But I don't wanna do that
05:05:58 <fendor> Phyx-, yeah makes sense, but it is difficult, choco on its own is already overloaded with text you often dont understand, I can imagine that most still dont read it
05:07:10 <lortabac> > let 5 = 4 in 5
05:07:12 <lambdabot>  5
05:07:22 <lortabac> strange
05:07:55 <boxscape> lortabac it's just like
05:08:00 <boxscape> % let True = False in ()
05:08:01 <yahb> boxscape: ()
05:08:25 <boxscape> except that it uses (==) instead of true pattern matching
05:08:27 <tabaqui1> % let x@True = False in x
05:08:28 <yahb> tabaqui1: *** Exception: <interactive>:22:5-18: Non-exhaustive patterns in x@True
05:12:00 <boxscape> hm, I hadn't actually realized until now that the left side in an as-pattern can only be a variable, not a pattern
05:30:06 <[itchyjunk]> Hey.
05:30:30 <[itchyjunk]> I didn't know theorem provers were written in functional programming languages. COQ is writtten in Ocaml.
05:32:12 <tdammers> why wouldn't they
05:32:31 <tdammers> given the typical audience for both, I'd expect them to
05:36:23 * hackage ghc-typelits-knownnat 0.7.2 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.7.2 (ChristiaanBaaij)
05:40:34 <dminuoso> [itchyjunk]: Well there's Agda.
05:41:27 <[itchyjunk]> That is the haskell one right?
05:42:12 <dminuoso> [itchyjunk]: Agda is written in Haskell, yes.
05:42:17 <dminuoso> Or at least the reference implementation is.
05:42:27 <dminuoso> (No idea whether there are alternative implementations)
05:48:26 <haskeldjiq> hey guys, brain fried, can anyone help?
05:48:30 <haskeldjiq> I've got a SomeMonadM { runSomeMonadM :: ReaderT Config (ExceptT DomainError (KatipContextT IO)) a }
05:48:36 <haskeldjiq> how do I get a MonadUnliftIO instance for that
05:49:16 <dminuoso> haskeldjiq: You dont.
05:49:26 <haskeldjiq> fuck
05:49:28 <dminuoso> haskeldjiq: Get rid of ExceptT, move it into IO exceptions.
05:49:34 <dminuoso> haskeldjiq: Then you can have MonadUnliftIO
05:49:56 <haskeldjiq> damn
05:50:11 <haskeldjiq> thanks!
05:50:27 <dminuoso> haskeldjiq: Alternatively you could use MonadBaseControl I suppose.
05:50:33 <dminuoso> With all the headaches that brings.
05:50:48 <haskeldjiq> well I'm not really familiar with those and the deadline is approaching quickl
05:50:49 <haskeldjiq> quickly
05:50:50 <dminuoso> But if switching ExceptT for IO is too much work, MonadBaseControl could be an option
05:51:00 <boxscape> % "\SO\ \H"
05:51:00 <yahb> boxscape: "\SO\&H"
05:51:04 <dminuoso> haskeldjiq: MonadBaseControl is basically the more complicated form of MonadUnliftIO
05:51:12 <boxscape> seems like they really needn't have added \& to the language but okay
05:51:13 <dminuoso> haskeldjiq: It lets you do the exact same thing but in more scenarios.
05:51:25 <dminuoso> In a less principled way, with some subtleties in bracket
05:52:39 <dminuoso> haskeldjiq: So instead of `withRunInIO $ \io -> ...` you would write `control $ \run -> ...`
05:53:03 <dminuoso> The interface ergonomic are the same, and you can GeneralizeNewtypeDerive the MBC instance
05:53:05 <haskeldjiq> yeah thing is the MonadUnliftIO constraint comes from a library
05:53:09 <dminuoso> Ah.
05:53:26 <dminuoso> haskeldjiq: Well what you could do locally unwrap your computation, pattern match on the Either...
05:54:05 <haskeldjiq> well I'm afraid I'm too much of a novice to understand what that means lol
05:54:33 <haskeldjiq> wait, I figured it out
05:54:48 <haskeldjiq> well.. I just migrated to async form forkIO
05:54:55 <haskeldjiq> now I'm going back lol
05:55:03 <haskeldjiq> someday I'll refactor, pinky promise
05:55:21 <dminuoso> haskeldjiq: Well you could write some `unlift :: YourMonad m -> IO m` that places the ExceptT into an IO exception.. 
05:56:15 <haskeldjiq> I just did a git reset --hard
05:56:27 <haskeldjiq> thank you!
05:56:33 <haskeldjiq> maybe next week when I'm cleaning up this mess
05:56:38 <haskeldjiq> I'll beg for help again lol
05:58:35 <xwinus> Hello, I'm trying to upload package to Hackage for the first time. I uploaded the package candidate here - https://hackage.haskell.org/package/headroom-0.1.0.0/candidate but for some reason the Haddock documentation is not generated. Should Hackage generate Haddock for candidates? I'd like to know if this is just a "feature" of Hackage, or there's
05:58:35 <xwinus> something wrong with my configuration.
05:59:06 <phadej__> haddocks are not generated for candidates
06:00:34 <xwinus> hm that's unfortunate, as the meaning of candidate should be to check that everything is fine before publishing to main index (I know I can do this locally but still...)
06:00:42 <boxscape> can I get cabal to show the error messages with pretty colors even if I'm passing the output to a file? Presumably I have to pass some flag to ghc?
06:01:22 <boxscape> wait it's literally the second entry on the ghc flags page
06:01:29 <boxscape> I searched --show-options but couldn't find it
06:03:33 <boxscape> hm well `cabal bench --ghc-options -fdiagnostics-color=always 2>&1 | less` compiles but it still doesn't show the error messages in color :/
06:05:57 <merijn> boxscape: cabal-install v3.0?
06:06:12 <merijn> boxscape: Oh, ha, I know what the issue is :)
06:06:21 <merijn> boxscape: It's my fault :p
06:06:41 <merijn> boxscape: And you should be glad!
06:06:49 <boxscape> I see
06:07:01 <merijn> boxscape: Basically, v2-build uses a hash to check the configuration and whether something has to be recompiled
06:07:30 <merijn> boxscape: This hash includes the GHC options. This sucked balls, because adding -fdiagnostics-color=always would recompile and reinstall *all* dependencies
06:07:59 <boxscape> hm, okay
06:08:07 <merijn> boxscape: So like a year or 2 ago I fixed the hash to ignore GHC flags that don't affect the generated binary/library (like warnings)
06:08:23 * hackage lightstep-haskell 0.6.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.6.0 (DmitryIvanov)
06:08:31 <merijn> boxscape: So if your code is already compiled it will just use the already compiled benchmarks
06:09:28 <boxscape> merijn hm, that sounds reasonable, but if it recompiles after changes it still shows the errors without color
06:09:31 <merijn> boxscape: oh, wait I misunderstood, it was already compiling?
06:09:38 <merijn> boxscape: less strips colour codes out :p
06:09:45 <boxscape> rude :(
06:09:49 <merijn> Well, *all* terminal codes
06:09:57 <boxscape> I suppose there's probably some flag there
06:09:59 <merijn> boxscape: Try "less -R"
06:10:00 <boxscape> that changes that
06:10:27 <boxscape> hm, no, -R doesn't seem to do it
06:10:47 <Taneb> You might need a flag on the previous step as well, "--color=always" maybe?
06:11:02 <boxscape> I have -fdiagnostics-color=always Taneb
06:11:35 <Taneb> Hmm
06:11:37 <boxscape> though -R does sound like it should do it
06:15:11 <boxscape> it's not less, if I do `cabal bench --ghc-options -fdiagnostics-color=always >1.txt 2>2.txt`, 2.txt will not have ANSI escape sequences
06:20:47 <boxscape> also, passing =never doesn't get rid of the color if I don't write it into a file
06:21:12 <merijn> boxscape: Are the colours from GHC or from cabal?
06:22:22 <boxscape> merijn almost certainly from ghc, i.e. ghc generates the exact same colors on error messages if run directly. But let me check if the flag works if I use it on ghc directly...
06:23:08 <boxscape> it does
06:23:33 <boxscape> so for some reason cabal doesn't seem to properly pass it to ghc, but if I pass a flag that doesn't exist through cabal, ghc does complain about it
06:24:59 <boxscape> hold on
06:25:05 <boxscape> I think it *is* the hash after all
06:25:22 <boxscape> except it *does* recompile, but with the old settings, if nothing in the config changed
06:25:27 <boxscape> even if the source code changed
06:26:14 <merijn> boxscape: I've heard a complaint like this in the past, but never got reproducing instructions
06:26:36 <boxscape> I suppose I can try to make some
06:27:15 <boxscape> merijn where is the hash stored?
06:27:29 <merijn> boxscape: No clue :p
06:27:35 <boxscape> fair enough
06:27:48 <merijn> dist-newstyle/config or something, probably
06:28:16 <boxscape> so if I have the same package in a different directory with the same settings, it shouldn't interfere, right?
06:28:34 <merijn> Right
06:28:37 <boxscape> okay
06:31:01 <boxscape> merijn well, darn. I can't reproduce it anymore
06:31:44 <merijn> boxscape: I think the issue might be due to bench/test having slightly wonky recompilation logic (for...complicated reasons)
06:31:58 <boxscape> after I changed a setting in the cabal file it now seems to always compile with the color set how I tell it to
06:32:03 <dminuoso> % (🤣) = (+)
06:32:03 <yahb> dminuoso: ; <interactive>:48:2: error: lexical error at character '\129315'
06:32:06 <boxscape> ah, that makes sense
06:32:16 <dminuoso> So I wonder, why is the lexer choking?
06:32:34 <boxscape> > generalCategory '🤣'
06:32:36 <lambdabot>  <hint>:1:18: error:
06:32:36 <lambdabot>      lexical error in string/character literal at character '\129315'
06:32:43 <merijn> boxscape: (because --enable-tests and --enable-benchmarks can change the solver plan and you don't want it to pingpong all the time)
06:32:50 <boxscape> I see
06:32:51 <dminuoso> boxscape: It's a lexer error, it doesn't even parse.
06:32:53 <merijn> dminuoso: Supported unicode version to old?
06:34:20 <dminuoso> % (🂡) = (+)
06:34:20 <yahb> dminuoso: 
06:35:09 <dminuoso> merijn: Perhaps. I think Ill file a bug report.
06:36:54 <boxscape> I believe the problem is that Nothing is produced here, though I don't know why. atEnd makes it sounds like that's what happens when the end of input is reached, rather than some unexpected char https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/parser/Lexer.x#L2319
06:37:25 <boxscape> or wait
06:37:33 <boxscape> no I stick by it
06:38:22 <dminuoso> boxscape: Heh, did you read [Unicode in Alex]
06:38:33 <boxscape> i didn't
06:38:41 <boxscape> though actually I think I may be wrong after all
06:38:53 <boxscape> I think I missed that lit_error is used all over the place rather than just once
06:39:16 <dminuoso> boxscape: Alex uses --latin1 behavior and has received hacks to trick it into parsing unicode.
06:39:45 <dminuoso> Let me do some bisect, see if its just related to some unicode version
06:40:41 <dminuoso> It seems the support only goes until 5.2
06:45:23 * hackage provenience 0.1.0.1 - Computations that automatically track data dependencies  https://hackage.haskell.org/package/provenience-0.1.0.1 (olf)
06:53:33 <absence> my haskell program won't quit, it just hangs after finishing main. i guess there's some kind of resource/thread tying it up, how can i debug this? is there something i can print?
06:55:23 * hackage ghc-typelits-extra 0.3.3 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.3.3 (ChristiaanBaaij)
06:57:19 <[exa]> absence: is there something you do with threads or so?
06:57:50 <[exa]> absence: (it usually helps to try to find a minimal example of the program that hangs this way)
06:59:41 <absence> [exa]: there's quite a bit going on yes, web server, database, kafka, etc. it's a bit of a pain to narrow down, but if there aren't any other tricks, i'll have to try
07:00:36 <[exa]> absence: you might want to log a termination message in each thread. Also, strace -f helps a lot
07:00:43 <sshine> what's it called if 'a * b => not (b * a)'?
07:01:28 <[exa]> anticommutativity?
07:01:40 <solonarv> yeah, I guess
07:01:40 <sshine> sounds good, thanks!
07:01:51 <solonarv> I was confused by the choice of names for the operations
07:01:52 <boxscape> what if a and b are the same? I guess `a * a` has to be false for all a for that to work?
07:01:56 <sshine> solonarv, yeah, I'm tired.
07:02:16 <solonarv> I don't think booleans are the right analogy for this
07:02:28 <sshine> boxscape, which incidentally is true. (this is rock-paper-scissors.)
07:02:42 <boxscape> I see
07:02:50 <sshine> (...-lizard-spock.)
07:03:38 <boxscape> sshine though apparently according to wikipedia the name anticommutativity is already taken for a * b = -(b * a)
07:03:57 <sshine> boxscape, ok.
07:04:55 <sshine> wikipedia'ing around, antisymmetric sounds almost right.
07:05:13 <sshine> but not actually. well, never mind.
07:05:41 <[exa]> binary relations are symmetric, binary functions are commutative
07:06:10 <[exa]> *doom voice:* choose wisely
07:07:48 <Taneb> It's anticommutative if your truth values are -1 and 1 (with 0 for a tie! :D)
07:08:45 <Taneb> If you do it as a relation it's antisymmetric and antireflexive
07:09:41 <sshine> does Hedgehog have something like QuickCheck's conjoin :: Testable prop => [prop] -> Property?
07:09:57 <sshine> Taneb, thanks :)
07:13:51 <happycoder> When using DataKinds extension, is there any way to get the type constructor back from a type constructor promoted to type?
07:15:25 <solonarv> not built-in, but that's what the Demote class in singletons is for
07:16:02 <boxscape> Demote is a type family
07:16:17 <solonarv> ah yeah, I misremembered
07:16:21 <boxscape> it's to get a base *type* from a promoted *kind*
07:16:30 <dminuoso> boxscape: With TypeInType, the difference is what? :p
07:16:47 <solonarv> SingKind is the class
07:16:48 <boxscape> dminuoso well, types and kinds are the same, but I think happycoder wants a value
07:16:55 <happycoder> yes, I want a value
07:17:33 <lortabac> solonarv: you probably meant the 'demote' function
07:17:54 <happycoder> what I am trying to do is build a compiler, where during parsing I encode in the AST that a variable is declared before it is assigned: https://gist.github.com/happycoder97/cd7bc5ba9b384d38c764c4fc05077737#file-foo-hs-L37
07:18:06 <boxscape> ah, yeah I was going to suggest fromSing sing, but the docs say "demote = fromSing sing"
07:18:54 <solonarv> lortabac: I just remembered "there is a thing like this in singletons, it's probably called something like demote"
07:21:23 <boxscape> happycoder by the way what you want then is actually a data constructor, rather than a type constructor. `Maybe` is a type constructor, `Just` is a data constructor.
07:23:11 <happycoder> boxscape, do you mean in the above gist I should use Var instead of VarChecked inside the AST?
07:23:35 <boxscape> happycoder no, I mean originally you said "is there any way to get the type constructor back"
07:23:48 <happycoder> oh okay
07:24:19 <boxscape> happycoder the thing you want to demote is the state?
07:24:26 <happycoder> yes
07:25:23 <remexre> hm, is there a non-TH-heavy way to do an arrow-like DSL (for a type that isn't actually an arrow) ?
07:25:27 <boxscape> happycoder if you don't want to pull in the whole singletons library you could conceivably make your own singleton types for State
07:25:44 <boxscape> happycoder let me see if I can figure out how to best explain that
07:26:25 <lortabac> the best way is probably to point to a singletons tutorial
07:26:30 <boxscape> possibly
07:26:45 <boxscape> https://blog.jle.im/entry/introduction-to-singletons-1.html
07:28:17 <Cale> Maybe you just want a GADT for variables?
07:28:17 <happycoder> thanks! let me check this out
07:28:32 <boxscape> happycoder at the moment unfortunately this is something isn't particularly convenient to use for because type information is erased at runtime (and you're trying to get information from the state type at runtime), so there's a couple of hoops to jump through. There's ongoing efforts to make it more streamlined in the future
07:28:48 <happycoder> okay
07:29:05 <boxscape> I meant to say "at the moment this is something Haskell isn't particularly convenient to use for"
07:29:13 <Cale> Honestly, if the solution is singletons, I say whatever you're trying to encode probably isn't worth encoding at the type level (at least in Haskell)
07:29:28 <Cale> But you might be able to do better than singletons here
07:29:48 <Cale> Instead of using a phantom type, perhaps use a GADT
07:29:55 <happycoder> if I don't put the State in type information inside AST, wherever I use the AST, say in codegen, I have to do case analysis again
07:30:56 <lortabac> Cale: if the values come from an external source, it would probably still be hard to refine them to a GADT
07:31:50 <lortabac> that's the reason why I almost stopped using DataKinds in real code
07:32:07 <Cale> data Var s where VarUndeclared :: String -> Var 'Undeclared; VarDeclared :: String -> Var 'Declared; VarInitialised :: String -> Var 'Initialised
07:32:36 <Cale> and then in cases where you don't know which of the three you have, you can use Some Var
07:33:03 <happycoder> But then I won't be able to store them in a list like `vars :: [Var]` right?
07:33:16 <Cale> You can have a list like [Some Var]
07:33:17 <happycoder> Some Var? how does that work?
07:33:36 <Cale> data Some f where Some :: f a -> Some f
07:33:52 <Cale> It's in the dependent-sum package
07:34:11 <happycoder> just found it on hackage :D
07:34:34 <happycoder> this looks interesting, this might be what I want
07:34:36 <Cale> Yeah, the actual definition is hackier than the one I gave in order to save you the runtime cost of the constructor
07:35:54 <happycoder> If I don't mind the runtime cost, the above `data Some..` definition is all there to it? How to pattern match on it?
07:36:24 <happycoder> ie, if I have vars :: [Some Var], how to check if an element is Var 'Declared or not?
07:37:34 <Cale> You would match on (Some (VarDeclared x))
07:37:49 <happycoder> okay
07:38:01 <happycoder> let me try this out, thanks!
07:38:43 <Cale> Note that you may want to do better than I've done with this Var type
07:38:57 <Cale> and actually include the proof that the variable has been declared or initialised
07:39:45 <Cale> Because at present, there's nothing which stops someone who is meant to produce a Some Var from producing the wrong type of Var.
07:40:10 <Cale> So it's kind of like "boolean blindness", except three-valued
07:40:19 <happycoder> right
07:43:32 <dminuoso> So is there a mind model how to visualize how fix lets me create cyclic structure? For some reason there's a mental barrier in the way.
07:44:07 <dminuoso> I mean the problem is not how fix is implemented, or how to use it - I just dont really understand why this works from a runtime point of view.
07:45:50 <happycoder> oops, the GADT doesn't scale if I also want to encode type of the variable into the VarChecked type.
07:46:29 <happycoder> I was thinking I could do away with data Var s = Var {varName::String}, then do Var @'Declared "foo", but then I won't be able to do pattern match on it because there is only one constructor
07:48:55 <Cale> dminuoso: stare at this for a moment:
07:49:09 <Cale> > fix (\fib n -> if n == 0 then 1 else n * fib (n-1)) 10
07:49:11 <lambdabot>  3628800
07:50:13 <Cale> It gives your lambda the thing to be recursively defined, and the body of that lambda gives the definition :)
07:50:51 <Cale> dminuoso: Or you mean how it lets you tie knots in data structures?
07:51:33 <dminuoso> Cale: Well I understand how it lets me tie knots from a "how do I write this" perspective. Perhaps its just that I dont understand the runtime implementation well enough to see how/why this works.
07:51:59 <dminuoso> @src fixc
07:51:59 <lambdabot> Source not found. :(
07:52:01 <dminuoso> @src fix
07:52:01 <lambdabot> fix f = let x = f x in x
07:52:41 <Cale> Maybe an example like x = 1 : x ?
07:52:51 <Cale> which is the result of fix (1:)
07:53:19 <dminuoso> Cale: Well the `x = 1 : x` is obvious. But it's that function application that unsettles me
07:53:53 <Taneb> fix (1 :) reduces to let x = (1 :) x in x
07:54:06 <Taneb> By the definition of fix
07:56:03 <geekosaur> here the function is a partially applied constructor. it may also be a partially applied function of some other kind
07:56:10 <sarahzrf> > fix$scanl1(+).(1:)
07:56:11 <dminuoso> Presumably the fact that I let-named x means there's a thunk. And argument passing is presumably implemented by passing a reference to that thunk?
07:56:12 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:56:28 <sarahzrf> oops no wait
07:56:34 <merijn> dminuoso: Maybe this example helps? https://gist.github.com/merijn/b86649a6aa21bd140803
07:56:45 <sarahzrf> > fix$scanl(+)0.(1:)
07:56:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:57:06 <Cale> dminuoso: Yeah
07:57:34 <Cale> dminuoso: also the arguments to data constructors are always pointers to code
07:58:18 <Cale> (unless they're unpacked fields)
07:58:57 <dminuoso> Cale: Unrelatedly, but data constructors are internally unrelated to functions, right?
07:59:26 <dminuoso> Or perhaps this is related.
08:00:18 <dminuoso> Ah I found it. It seems data constructors and functions are different closure types
08:03:20 <happycoder> boxscape, i read the singleton tutorial but this won't work if I have two type parameters like `VarChecked (s::State) (t::DataType)` right?
08:04:17 <Cale> It depends on your definition of "work". The more computation you end up wanting to do on those representations of states and data types at the type level, the more horribly awkward things are going to get.
08:05:26 <Cale> It's very unusual to maintain information about the types of terms being compiled at the type level in a compiler -- unless the type system for the compiled language is much weaker than the type system that the compiler is being written in, you tend to have problems with that.
08:06:30 <happycoder> okay
08:06:50 <happycoder> my language is a small subset of C
08:07:11 <Cale> Might be fine :)
08:08:54 <dminuoso> What guarantees do I get that let-binding will generate a thunk though? Couldn't GHC just untie my code?
08:09:42 <Cale> Well, GHC isn't going to try to inline a recursive definition in generael
08:09:44 <Cale> -e
08:10:21 <dminuoso> Cale: Sure, but the let/where binding is still necessary
08:10:49 <solonarv> there isn't really anything GHC can do to a 'let x = f x' binding
08:10:59 <dminuoso> I mean whether I write `cycle xs = xs' where xs' = xs ++ xs'` or `cycle xs = xs ++ (cycle xs)` makes no difference from a denotational point of view 
08:11:09 <Cale> sure
08:11:19 <Cale> It would be within its rights to do so denotationally
08:11:35 <Cale> But it wouldn't, because it worsens space performance a lot of the time
08:12:23 <dminuoso> Cale: Ah. My  flaw is, it would not invalidate the circular structure - the difference is just space efficiency
08:12:36 <lortabac> happycoder: I suggest you to have a look at glambda or Stitch by Richard Eisenberg, they are quite similar to what you are trying to achieve
08:12:39 <dminuoso> It's still knot-tied either way.
08:13:08 <Cale> dminuoso: Well, it would turn a circular structure into an infinite one
08:13:20 <Cale> But as far as you can observe, those are the same thing
08:13:25 <dminuoso> Right
08:13:50 <dminuoso> fsvo of "observe", because you can clearly observe the difference in memory
08:14:20 <happycoder> okay
08:14:45 <Cale> Yeah, let's not count IO :)
08:14:54 <lortabac> happycoder: however I would not suggest this approach for a production compiler
08:14:56 <Cale> You can't observe it via expression evaluation
08:15:20 <lortabac> happycoder: it can be a funny exercise though
08:15:32 <happycoder> the exercise is definitely fun :D
08:16:21 <nshepperd2> you can observe it via makeStableName
08:21:36 <blackandblue> anyone here using ubuntu / mint as main OS
08:21:43 <blackandblue> what package do you use for haskell
08:22:45 <dsal> blackandblue: I just used stack.  No packages
08:23:00 <blackandblue> dled stack from apt?
08:23:07 <adalricus> dsal: https://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu
08:23:15 <solonarv> blackandblue: I'm using mint as my OS
08:23:40 <solonarv> I grab GHC and cabal via ghcup, haven't actually used stack since I started using this PC I think
08:23:51 <adalricus> oops wrong ping, sorry dsal, 
08:23:52 <blackandblue> solonarv, nice. dual booting?
08:24:00 <adalricus> blackandblue:
08:24:28 <dsal> They're are different ways to do it, but I'd expect any that used system packages would be sad.
08:24:33 <solonarv> blackandblue: nope, pure linux
08:24:45 <blackandblue> solonarv, so nothing from apt?
08:24:47 <geekosaur> I used hvr's PPA, for what it's worth
08:24:59 <blackandblue> geekosaur, on mint too?
08:25:07 <geekosaur> yes, I'm on mint
08:25:18 <blackandblue> geekosaur, I see. dual booting? 
08:25:26 <blackandblue> or just mint only
08:25:33 <geekosaur> just mint
08:25:35 <blackandblue> planning to dual boot nixOS for haskell lol
08:26:05 <dsal> Running more than one os on a computer seems painful.
08:26:08 <solonarv> I considered using the PPA, but there is something comfortable IMO about software living entirely inside one or two directories in ~
08:26:12 <blackandblue> dsal, true
08:26:45 <blackandblue> solonarv, so you dled ghcup from apt?
08:26:50 <blackandblue> or ppa
08:26:53 <geekosaur> I have nix installed but sandboxed away from everything else (instead of running the nix setup in .profile, I have an alias defined that does it and marks the shell as nix-ified)
08:27:03 <solonarv> no, I just downloaded the script directly and ran it
08:27:10 <solonarv> (ghcup is a shell script)
08:27:14 <geekosaur> and I'm reasonably happy with stuff that is walled off even if not in ~
08:27:21 <geekosaur> (/nix, /opt)
08:27:29 <blackandblue> solonarv, drawback is updating it manually everytime
08:27:38 <blackandblue> apt would do it painlessly
08:29:36 <solonarv> ghcup can upgrade itself, so that's fairly painless as well
08:29:51 <blackandblue> oh really
08:29:55 <blackandblue> nice then
08:30:04 <merijn> blackandblue: *shrug* I rarely want the package manager to decide when I upgrade GHC
08:30:29 <blackandblue> merijn, hehe. especially if you are on arch. are you?
08:30:52 <merijn> No, on macOS, but homebrew has this stupid-ass "bleeding edge at all cost" approach to packaging...
08:32:59 <blackandblue> TIL brew is bleeding edge
08:33:06 <blackandblue> like pacman
08:34:35 <tdammers> well, there are two sane approaches to packaging a distro: 1) compile a curated list of compatible package versions, pin them down, and ship only feature-equivalent security patches and bugfixes (the Debian way), and 2) forward the latest upstream as-is (the Arch way)
08:34:45 <tdammers> the latter is basically "bleeding edge" by definition
08:35:41 <blackandblue> tdammers, you on 1) or 2)?
08:36:50 <tdammers> blackandblue: 1)
08:36:54 <tdammers> literally Debian
08:36:58 <blackandblue> stable ?
08:37:02 <tdammers> yes
08:37:03 <blackandblue> or  testing
08:37:08 <tdammers> testing is for testing
08:37:12 <blackandblue> cool. dual booting?
08:37:23 <tdammers> dual booting what? and for what purpose?
08:37:38 <Putonlalla> All the cool guys dual wield Debians.
08:37:56 <blackandblue> tdammers, no windows? :D
08:37:58 <blackandblue> nice
08:39:04 <dsal> Is Windows assumed?  I've only used it professionally for about a bit over 20 years ago.  It was pretty awful.
08:39:25 <Cale> I haven't used Windows since around 1999-2000 ish
08:39:58 <blackandblue> dsal, silicon valley is using macOS or windows. linux are a minority there
08:40:00 <blackandblue> :D
08:40:04 <dsal> Er, I left out "a couple weeks".  It was a failed experiment
08:40:06 <blackandblue> Cale, macOSn ow?
08:40:10 <tdammers> I jumped ship a bit later, but basically haven't run Windows on metal since ~2006 on any machine I own
08:40:12 <Cale> No, Linux
08:40:20 <blackandblue> Cale, distro?
08:40:28 <Cale> Mint at the moment
08:40:32 <tdammers> not because I am fundamentally opposed to it, but rather because I haven't had a need for it
08:40:35 <dsal> blackandblue: I've been in silicon valley since the 90s.  Rarely seen Windows anywhere
08:40:47 <blackandblue> dsal, yea 90% are macOS
08:40:54 <iptq> rich kids
08:40:57 <tdammers> at some point I booted my Windows partition for an office LAN party, and realized that I was a year and a half behind with updates
08:40:59 <blackandblue> hehe^
08:41:18 <tdammers> so I did the logical thing and nuked that partition, and I simply never had a reason to resurrect it
08:41:29 <blackandblue> iptq, do you use linux as well? or windows
08:41:32 <geekosaur> overy so often I boot the windows vm and let it update
08:41:33 <iptq> yea the rule with windows updates is u either always stay up to date or u never update it ever
08:41:35 <geekosaur> *every
08:41:38 <tdammers> and ever since Windows 10, whenever I try to do anything on Windows, I'm basically lost.
08:41:47 <blackandblue> tdammers, trueee
08:41:47 <iptq> im on manjaro on my desktop, arch on laptop, and windows at work :/
08:42:00 <geekosaur> there's also a native windows install only because the bios on this machine is stupid and insists on the original windows install being around
08:42:02 <tdammers> only thing I do with it is build some haskell stuff for people who want windows binaries
08:42:13 <tdammers> and for that, the "browser testing" images from MS are good enough
08:42:22 <Cale> I started out dual-booting Debian unstable alongside Windows for a month or so, and then realised that whenever I was booted into Windows, my machine was practically inaccessible, so I dropped my Windows partition.
08:42:23 <tdammers> load them into a VM, do the thing, nuke everything
08:42:32 <blackandblue> tdammers, :D haha
08:43:25 <blackandblue> Cale, LMDE?
08:43:32 <Cale> ?
08:43:47 <blackandblue> linux mint debian edition
08:43:48 <blackandblue> :P
08:43:52 <geekosaur> mint's debian-based distro
08:43:52 <Cale> Oh, no
08:44:10 <Cale> Just the usual Mint, I think it's based on Ubuntu (which is in turn based on Debian anyway)
08:44:20 <blackandblue> geekosaur, there are 2 versions of mint actually
08:44:26 <geekosaur> yeh, lmde's directly on deian unstable
08:44:32 <blackandblue> yea
08:44:39 <blackandblue> stable I guess
08:44:40 <geekosaur> mre than two, anyway
08:44:41 <blackandblue> not unstable
08:45:13 <geekosaur> I run the mate-based release (fork of gnome 2) instead of the cinnamon-based one (gnome 3-ish)
08:45:15 <dsal> In any case, stack is a good package manager for Haskell. You get to decide when to update what parts on a per-project basis.
08:45:19 <Cale> Yeah, same here
08:45:43 <Cale> Gnome 2 was good, I don't know why they had to screw it up :P
08:46:03 <blackandblue> Cale, but you use mint based on cinnamon DE :D
08:46:08 <Cale> No
08:46:13 <Cale> I'm using Mate
08:46:19 <blackandblue> ohk
08:46:48 <blackandblue> do we download mate or just installing mate de package would do fine? in existing linux mint cinamon edition
08:46:58 <blackandblue> mate edition*
08:47:33 <Cale> I'm not sure if there's any material difference. Maybe you'll miss out on some default configuration shenanigans.
08:47:45 <blackandblue> yea :(
08:48:07 <blackandblue> also heard in mint its difficult to upgrade to newer editions.. you have to re install. is it true?
08:48:13 <geekosaur> I had that one one past install. it takes more space to install mate separately but doesn't behave significantly differently
08:48:19 <blackandblue> f.e. LTS 18.04 to LTS 20.04 in future
08:48:31 <geekosaur> it used to be true, because of issues with ubuntu
08:48:39 <blackandblue> now its fine?
08:48:46 <blackandblue> or do we need to re install 
08:48:48 <geekosaur> the last few upgrades I did were fairly painless
08:48:58 <blackandblue> Wow nice to hear that
08:49:17 <geekosaur> there's an upgrade menu item in the edit menu of the update manager
08:51:19 <blackandblue> geekosaur, thanks! thats comforting to hear
08:51:25 <blackandblue> moving from windows 10 to mint :)
08:51:36 <blackandblue> its so hectic to work in  wsl
08:51:38 <blackandblue> or vm
09:08:53 * hackage sparse-tensor 0.2.1.3 - typesafe tensor algebra library  https://hackage.haskell.org/package/sparse-tensor-0.2.1.3 (nalex)
09:25:23 * hackage safe-decimal 0.2.0.0 - Safe and very efficient arithmetic operations on fixed decimal point numbers  https://hackage.haskell.org/package/safe-decimal-0.2.0.0 (lehins)
09:56:23 * hackage th-abstraction 0.3.2.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.3.2.0 (ryanglscott)
10:14:19 <dagadbm> ;bn2
10:15:08 <infandum> I don't really need an answer, but I'm curious: to split by multiple characters, I can do return "one1two2three" >>= T.splitOn "1" >>= T.splitOn "2", etc. What is a more elegant way to generalize this? Like T.splitOn ["1", "2", ...]
10:15:17 <infandum> I assume foldM is involved...
10:16:25 * dsal breaks out megaparsec
10:17:00 * sm[m] breaks out split.splitOneOf
10:17:28 <geekosaur> I think they want a sequence, not an "any of these"?
10:18:30 <sm[m]> so "one2two1three" shouldn't split ?
10:19:08 <infandum> nooooooo that's cheating!
10:19:25 <geekosaur> heh
10:19:53 <infandum> I'm curious about a non-already written way, with basic monad functions
10:19:58 <infandum> It seems like it should be simple
10:22:43 <oo_miguel> the doc for 'modifyMVar' states that there should be no other 'producer'. Just wanted to make sure if this means I can _not_ have any putMVar on that but it is fine to run multiple modifyMVar in parallel?
10:24:37 <cocreature> oo_miguel: exactly
10:25:21 <cocreature> basically as long as everyone follows "take then put" everything is fine. if you have something that only puts without first trying to take, you can end up with interleaved puts
10:25:37 <oo_miguel> cocreature: ok makes perfect sense, thank you
10:25:41 <infandum> I feel like it should be foldM (>>=) (return "one1two2three") $ fmap T.splitOn [":", "-"], but it expects a functions that return [[T.Text]] for the input list (the end)
10:26:12 <infandum> err ["1", "2"]
10:26:20 <infandum> oh
10:26:23 <infandum> I was overthinking it
10:26:33 <infandum> foldl is good enough
10:26:35 <infandum> foldl (>>=) (return "one1two2three") $ fmap T.splitOn ["1", "2"]
10:27:04 <infandum> It looks less elegant, but it's generalized
10:27:09 <infandum> ish
10:43:53 * hackage ribbit 1.0.0.0 - Type-level Relational DB combinators.  https://hackage.haskell.org/package/ribbit-1.0.0.0 (taphu)
10:49:35 <dmwit> :t foldM
10:49:36 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
10:49:53 * hackage haskell-lsp 0.20.0.1 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.20.0.1 (AlanZimmerman)
10:50:02 <dmwit> % :t T.splitOn
10:50:02 <yahb> dmwit: ; <interactive>:1:1: error:; Not in scope: `T.splitOn'; No module named `T' is imported.
10:50:08 <dmwit> % import qualified Data.Text as T
10:50:09 <yahb> dmwit: 
10:50:10 <dmwit> % :t T.splitOn
10:50:10 <yahb> dmwit: T.Text -> T.Text -> [T.Text]
10:51:12 <dmwit> % :t foldM T.splitOn (T.pack "one1two2three") [T.pack "1", T.pack "2", T.pack "3"]
10:51:12 <yahb> dmwit: [T.Text]
10:51:18 <dmwit> infandum: ?
11:52:23 <infandum> ooooooooh
11:52:38 <infandum> that's probably what I was missing...
11:52:58 <infandum> still a little mindbending for some reason, perhaps I didn't fully understand foldM
13:00:53 * hackage alex-meta 0.3.0.10 - Quasi-quoter for Alex lexers  https://hackage.haskell.org/package/alex-meta-0.3.0.10 (ArtemPelenitsyn)
13:24:28 <ooo_miguel> can I somehow easily get a list of all types that implement some specific class (as Eq for instance) ??
13:25:01 <geekosaur> :info in ghci, although it won't show types that haven't been loaded in that session
13:25:15 <geekosaur> 8.10 also has a command specific to that iirc
13:26:12 <ooo_miguel> ok will have a look, thank you!
13:26:44 <glguy> You can use :info! to get even more instances shown
13:26:56 <ooo_miguel> what about searching all the types searchable via hoogle?
13:26:57 <glguy> it won't help with packages that aren't currently loaded, but it will help with modules that aren't in scope
13:26:58 <geekosaur> "all types anywhere" is a bit difficult especially if it leads to conflicting modules etc.
13:27:30 <geekosaur> not sure if a search like "instance Eq" would work on hoogle.
13:27:37 * geekosaur again misses hayoo
13:28:22 <rareman> https://diamonds.capital/en/join/?ref=LbVs1s
13:28:44 * geekosaur assumes spam
13:39:01 <amalloy> it definitely took me multiple years before i realized hayoo was supposed to be a play on yahoo
13:45:20 <tdammers> it took me years to understand the burrito thing
13:46:18 <guest88> https://pastebin.com/qDVC9Sze
13:46:20 <guest88> why wont this work?
13:46:26 <dmj`> After my 400th burrito I finally understood it
13:46:29 <guest88> it keeps returning IO string
13:46:34 <dmj`> guest88: getLine is in IO
13:46:40 <dmj`> guest88: getLine :: IO String
13:46:47 <dmj`> guest88: once you're in IO, you can't get out of it
13:46:54 <guest88> But i'm trying to return the underlying string
13:47:19 <hyperisco> and the fly is trying to escape the web
13:47:24 <dmj`> guest88: then you have to bind it to a new function
13:47:50 <dmj`> guest88: getLine >>= \theString -> doSomeStuffAndReturnInIO theString
13:50:07 <prog56> how can I represent a multiplayer game in Haskell?
13:50:54 <hyperisco> prog56, I could imagine there being a whole book to answer that question. Could you ask something more specific?
13:51:26 <sm[m]> data MultiplayerGame
13:51:30 <sm[m]> sorry, couldn't resist
13:51:42 <hyperisco> No data constructors even, brutal
13:51:55 <guest88> dmj` i'm trying to check whether an input is valid 
13:52:09 <prog71> well, at the moment its obvious to use a "state" to model the way the datatype changes each turn
13:52:25 <guest88> so i do line<- getLine, then pass line into another function to check it's valid? if it's not I want the user to try input again..
13:52:26 <dmj`> guest88: what constitutes valid input
13:52:28 <prog71> and to have a list of players, possibly also with changing state...
13:52:33 <dsal> guest88: You're writing what appears to be an IO action, but you didn't declare it as such.
13:52:53 * hackage lightstep-haskell 0.6.1 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.6.1 (DmitryIvanov)
13:53:01 <hyperisco> prog71, Perhaps you should give it a go and see how it turns out.
13:53:03 <sm[m]> progNN, any multiplayer games to look at on Hackage ?
13:53:15 <dmj`> guest88: then make a function "getValidInput :: IO String; getValidInput = getLine >>= \str -> if isValid str then pure str else getValidInput"
13:53:38 <dmj`> guest88: and you define isValid :: String -> Bool
13:53:41 <dsal> guest88:   You could do something simple like    isValid :: String -> Bool    or perhaps    validate :: String -> Either String String
13:54:16 <dmj`> prog56: can use websockets / web server
13:56:16 <prog85> sm[m]: I'm not sure of the underlying types, I was wondering what approaches could be reasonable 
13:57:11 <guest88> dmj`
13:57:19 <guest88> that function still returns an IO string
13:57:21 <prog85> like, from an abstract perspective, I wouldnt expect Hackage to have that level of focus on the abstraction itself
13:57:36 <guest88> I want to use the string in a further manipulation after I check that it is valid
13:57:40 <dmj`> guest88: it returns a /valid/ String in IO
13:58:11 <dmj`> guest88: ok, so take the function I defined for you
13:58:33 <dmj`> guest88: main = do { validInput <- getValidInput; processValidInput validInput }
13:58:35 <prog85> hyperisco: I have some progress, it seems like several interacting signals, but with different types for the players and the thing they are interacting with, like the board or deck of cards or whatever
13:58:36 <sm[m]> in general, there'll be some overall game state which includes the state of each player, as you can imagine. Beyond that there's probably lots of variations. There are a few multiplayer games on Hackage whose source might give ideas (not too many though..) 
13:59:29 <hyperisco> prog85,  step :: PlayerInput -> GameState -> GameState; gameOver :: GameState -> Boolean; initialState :: GameState; render :: GameState -> IO ()
13:59:34 <prog85> as far as I can tell its some kind of coupled oscillator, or at least, that would be expressible using the same abstraction 
14:00:10 <hyperisco> readInput :: IO PlayerInput
14:00:24 <guest88> dmj` https://pastebin.com/rU2fxHFs
14:00:50 <sm[m]> prog, are you asking how to do it using some FRP framework ?
14:00:52 <prog85> hyperisco: more like (GameState,GameState -> (GameStateObservation,GameState))
14:01:05 <hyperisco> That's for you to figure out. More than one answer!
14:01:23 <prog85> sm[m], hmm, I hadnt thought of doing it with continuous signals, no. I think the descritisation in "steps" is more natural here
14:01:33 <dmj`> guest88: processValidInput :: String -> IO ()
14:01:35 <solonarv> discrete FRP exists as well
14:01:53 <solonarv> *discrete-time
14:01:56 <dmj`> processValidInput str = putStrLn str
14:01:58 <hyperisco> Talking about "a game" in a vacuum is a misstart, in my opinion.
14:02:06 <prog85> hyperisco: its interesting how you represent the evolution using an action rather than a state...
14:02:23 <hyperisco> What is a game? A game isn't clearly definable. What are the technical problems to solve?
14:02:33 * solonarv nods vigorously
14:02:37 <solonarv> these things matter!
14:02:40 <prog85> hyperisco: thats why I wanted to think about it in terms of interacting signals
14:02:44 <dmj`> prog85: you should use miso for your game framework, it has a very fast game loop and can take advantage of WebGL.
14:03:01 <solonarv> prog85: that does sound very much like FRP to me
14:03:08 <guest88> dmj` I'm not sue what you are getting at?
14:03:12 <prog85> but in a discrete setting
14:03:42 <solonarv> as I said, the term "FRP" alone makes no statement on whether time is discrete or continous
14:03:55 <dmj`> guest88: what would you like to do with the valid string?
14:03:57 <prog85> well, I dont think it needs to be differentiable
14:04:10 <guest88> dmj` I want to use words on it
14:04:17 <guest88> to decompose it into wods
14:04:24 <guest88> and return words
14:04:27 <prog85> probably difficult for it not to be though...
14:04:46 <prog85> so how would you represent coupled signals in FRP?
14:05:00 <prog85> or maybe this "signal" idea is a misnomer, and FRP is a red herring
14:05:15 <guest88> dmj` i got it
14:05:18 <guest88> dmj` thanks for ur help
14:05:27 <guest88> dmj` i just wasnt understanding types correctly
14:06:09 <dsal> guest88: processValidInput as you defined it, is literally just words, but with the wrong type signature.
14:06:10 <prog85> I thought the easiest way to do it was just to have these (a,a->(b,a)) and have them interacting somehow
14:06:10 <dsal> :t words
14:06:12 <lambdabot> String -> [String]
14:06:27 <prog85> thats probably my question really
14:06:34 <dsal> processValidInput validInput = words validInput  η-reduces to   processValidInput = words
14:06:54 <dmj`> guest88: mapM_ print =<< words <$> getValidInput 
14:07:02 <prog85> a compositional framework for states?
14:09:44 <prog85> can the State monad compose like that?
14:10:54 <prog85> like, combining states is monoidal, but idk if its monoidal in the category of endofunctors...
14:11:38 <prog85> probably not...
14:15:27 <prog85> i guess the issue is something like, if as a result you can concat the list of players activities, then you can have shared memory of their states used to determine the individuals action
14:15:54 <prog85> or maybe this is prevented by player privacy, and they can only observe the GasmeState
14:16:53 * hackage ribbit 1.0.0.1 - Type-level Relational DB combinators.  https://hackage.haskell.org/package/ribbit-1.0.0.1 (taphu)
14:18:32 <prog85> and then in full generality, there is this kind of privacy masking, and the possibly for further gamestate like things, ie not just playersState and gameState, with the corresponding privacy, but basically just a HList of different type states, and some way of describing the sharing of these types used as arguments in the various states
14:20:07 <prog85> and if there are n things interacting, that these can be pared into the actor and actee for each "turn"
14:20:25 <prog85> so basically then just having two signals interacting
14:21:11 <prog85> which is like the abstraction used to represent an adaptive timestep, which is determined from the state, and where the states evolution depends on the timestep
14:21:51 <prog85> where the problem then seems to be extending from pair to list using recursion
14:26:21 <prog85> ((s,dt),(s,dt)->((a,b),(s,dt))), from ((s,dt),(s,dt) -> (a,s)) + ((s,dt),(s,dt) -> (b,t))
14:26:46 <prog85> i guess then its something like "is a HList of States the same as a State over a HList" ?
14:27:09 <prog85> maybe thats how to express the problem as a type
14:28:04 <prog85> and that this is then the abstraction that should form the basis of a multiplayer game
15:24:53 * hackage heredocs 0.1.6 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.6 (KatsutoshiItoh)
15:59:14 <Axman6> d34df00d: Yo, I was looking at your hwc, it looks like you'rew doing a lot of things for processing that I've been thinking about for a long tiome but never had aneed for. It feels like a nice extension to a foldl (the library) style of stream processing
16:00:38 <MarcelineVQ> you two should hang out
16:01:02 <MarcelineVQ> get haskellworks in on it too
16:01:18 <Axman6> you mean newhoggy?
16:01:35 * Axman6 is a big fan of newhoggy's work
16:02:43 <MarcelineVQ> at least newhoggy, more if there's more people to hw :>
16:03:36 <Axman6> pretty sure it's just him
16:03:45 <MarcelineVQ> what a scamp
16:10:56 <newhoggy> There is also Alexey Raga who maintain Kafka, Avro and XML libraries.  😁
16:17:36 <MarcelineVQ> more importantly that name is pretty cool
16:28:41 <d34df00d> Axman6: yeah, I thought about factoring that out into a separate library once I get a feel of what realistic applications might need! Maybe like foldl-typelevel, dunno (although it'd be a bit of a misnomer). Or maybe it's worth adding straight to foldl.
16:29:53 * hackage prettyprinter-graphviz 0.1.1.0 - a prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-0.1.1.0 (GeorgeThomas)
16:32:49 <Axman6> I quite like the idea of exposing the internal state type. I once played with a similar idea in a statistics library which would automatically figure out how many passes over the data were needed based on the dependecies between different stats (many need mean to compute accurately, so require two passes). I feel like being able to share the same state between different statistics could be quite useful like if you're computing the lenght and 
16:32:49 <Axman6> average of something, then you probably don't want to compute the length for both, just do it once and reuse it
16:32:56 <Axman6> </braindump>
16:35:46 <d34df00d> Hmm, I currently rely on the compiler to do that.
16:36:15 <d34df00d> As you might've noticed, there is no support for explicitly sharing (parts of) state between different calculations (and I haven't thought how to express that).
16:36:39 <d34df00d> So I sort of rely on the compiler to optimize things away.
16:36:57 <d34df00d> And wc @('Words) works just as fast as wc @('Words '::: 'Words), so that's a well-founded hope.
16:37:14 <d34df00d> (in fact the latter works faster due to reasons beyond my understanding)
16:59:12 <newhoggy> d34df00d: Nice work!
17:16:37 <d34df00d> newhoggy: thanks! I'm curious if I'll be able to shape into something really reusable.
17:33:33 <Guest_72> Attempting to install Haskell on Mac. Received error message could not resolve host: g
17:35:05 <Axman6> how are you trying to install it?
17:37:12 <Guest_72> typed "curl --proto '=https' --tlsv1.2 -sSf https://g"
17:38:18 <Axman6> where did you get that from? that doesn't look like it would install haskell
17:38:53 <Axman6> there's definitely a lot missing from the end of that command
17:41:01 <Guest_72> Got it from "http://hackage.haskell.org/platform/" as way to install haskell on macos
17:42:02 <Axman6> I can't see those instructions anywhere on that page
17:42:24 <Axman6> "curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh" is the whole command that you use to install ghcup
17:43:12 <Axman6> you can copy and paste that into the terminal
17:43:26 <Cale> Maybe they went here https://www.haskell.org/ghcup/ and didn't notice the horizontal scrollbar?
17:43:33 <Axman6> yeah
17:46:53 <Guest_72> I did not notice a horizontal scrollbar. I will try it again with that info. Thank you all for the prompt responses. Have a wonderful rest of the day.
17:47:55 <Axman6> I have submitted https://gitlab.haskell.org/haskell/ghcup/issues/133
18:58:53 * hackage massiv-io 0.2.0.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.2.0.0 (lehins)
19:07:23 * hackage happy-meta 0.2.0.10 - Quasi-quoter for Happy parsers  https://hackage.haskell.org/package/happy-meta-0.2.0.10 (ArtemPelenitsyn)
19:36:23 * hackage alex-meta 0.3.0.11 - Quasi-quoter for Alex lexers  https://hackage.haskell.org/package/alex-meta-0.3.0.11 (ArtemPelenitsyn)
19:40:53 * hackage network-byte-order 0.1.4.0 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.4.0 (KazuYamamoto)
20:57:23 <GreyFaceNoSpace> hi. whats wrong here? https://pastebin.pl/view/bc7b2627
20:58:03 <monochrom> Yeah! What's wrong?
20:58:14 <GreyFaceNoSpace>     Couldn't match expected type ‘IO ()’ with actual type ‘[Char]’
20:58:22 <monochrom> which line?
20:58:32 <Axman6> looks like you neex to indent lines 8-12
20:58:33 <monochrom> Could we agree to not abridge?
20:58:43 <GreyFaceNoSpace> line 5
20:58:56 <monochrom> Need parentheses.
20:59:18 <GreyFaceNoSpace> where?
20:59:24 <GreyFaceNoSpace> or $ ?
20:59:29 <monochrom> putStr ("..." ++ show a)
20:59:35 <monochrom> Please never use $
20:59:46 <monochrom> $ stands for cargo culting.
21:00:03 <GreyFaceNoSpace> still not working
21:00:04 <GreyFaceNoSpace> https://pastebin.pl/view/13fbe29e
21:00:18 <GreyFaceNoSpace> line 5
21:00:25 <monochrom> <monochrom> putStr ("..." ++ show a)
21:00:30 <GreyFaceNoSpace> Couldn't match expected type ‘IO ()’ with actual type ‘[Char]’
21:00:51 <GreyFaceNoSpace> still after the parantheses
21:01:02 <monochrom> OK I'm done with this.
21:01:09 <GreyFaceNoSpace> what?
21:01:34 <Axman6> you haven't told us which line that error is referring to
21:02:00 <Axman6> oh line 5, yeah that should be putStr ("Number of Mistakes = " ++ show a)
21:02:09 <GreyFaceNoSpace>  in line 4: No instance for (Num a0) arising from a use of ‘loop’
21:02:22 <GreyFaceNoSpace> after i did this: ("Number of Mistakes = " ++ show a)
21:02:36 <GreyFaceNoSpace> this is the new error: line 4  No instance for (Num a0) arising from a use of ‘loop’
21:03:59 <Axman6> you probably need to add some tyoes, add loop :: Int -> Int -> IO Int and it should be happy
21:04:30 <Axman6> types*
21:04:46 <GreyFaceNoSpace> should i add this after the where binding?  loop :: Int -> Int -> IO Int
21:05:45 <Axman6> yeah, above the first clause of loop
21:06:32 <GreyFaceNoSpace> yea it compiles
21:06:42 <GreyFaceNoSpace> thanks
21:07:48 <Axman6> the type that GHC inferred for loop was previously: loop :: (Num a, Random a) => a -> a -> IO a I think, which means it didn't know which a it should use
21:09:04 <GreyFaceNoSpace> it doesn't terminate although the loop should stop at n == 0
21:09:55 <Axman6> what makes you say it doesn't terminate?
21:10:10 <GreyFaceNoSpace> it should only ask for input 5 times
21:10:18 <GreyFaceNoSpace> because i initialized loop with 5
21:10:26 <MarcelineVQ> you're shadowing n
21:10:31 <GreyFaceNoSpace> ah shit
21:10:34 <GreyFaceNoSpace> you're right
21:10:35 <GreyFaceNoSpace> thanks
21:10:56 <Axman6> it's worth noting that by default, putStr won't print anything until you print a new line, it's line buffered. you might want to change the buffering mode of stdout
21:11:04 <Axman6> good catch MarcelineVQ
21:13:17 <GreyFaceNoSpace>     No instance for (Eq a0) arising from a use of ‘/=’ ... does this mean that its not iterpretting my readLn output as an integer?
21:14:18 <MarcelineVQ> you need to include your full errors along with all the code that produces them when asking about an error
21:14:33 <GreyFaceNoSpace> https://pastebin.pl/view/59b95a4d
21:14:42 <GreyFaceNoSpace> i changed the n that was shadowed to an x
21:14:58 <nshepperd> you haven't specified the type of m, n or res
21:14:59 <GreyFaceNoSpace> line 14: 47:20:
21:14:59 <GreyFaceNoSpace>     No instance for (Eq a0) arising from a use of ‘/=’
21:14:59 <GreyFaceNoSpace>     The type variable ‘a0’ is ambiguous
21:15:15 <GreyFaceNoSpace> randomRIO returns an int
21:15:21 <MarcelineVQ> does it?
21:15:36 <nshepperd> no, randomRIO can return a variety of different things
21:15:49 <Axman6> you haven't actually told your program that it is an Int
21:15:56 <GreyFaceNoSpace> m <- randomRIO (0,1000)
21:16:08 <GreyFaceNoSpace> can't the compiler infer that m is an int here?
21:16:57 <nshepperd> no
21:17:04 <Axman6> no, there's nothing anywhere telling it it should be an Int
21:17:07 <olligobber> oh no: https://gist.github.com/olligobber/f3faf51a6c9bc4f8b0d993b58a5b067e
21:17:20 <GreyFaceNoSpace> ok...so where should i specify that? 
21:17:29 <Axman6> because the readLn also isn't constrained to be an Int, it's any type which can be read
21:17:35 <mac10688> Anyone know what function applies a value to each function in an array?
21:17:54 <olligobber> mac10688, fmap?
21:17:56 <Axman6> if you use randomIOR (0,1000) :: IO Int you'll be ok
21:17:56 <GreyFaceNoSpace> ok...so how can i specify the types? only way i know of is the function signature
21:18:13 <mac10688> oh fmap does that? Thanks! I'll give that a try olligobber 
21:18:28 <Axman6> mac10688: do you mean each element of an array?
21:18:32 <olligobber> I assume an Array would be a functor
21:18:49 <Axman6> olligobber: is there anything wrong with your code?
21:19:01 <GreyFaceNoSpace> randomRIO ::(Int,Int ) -> IO Int
21:19:07 <olligobber> Axman6, purescript doesn't compile it, condition1 is not defined when it is used
21:20:06 <Axman6> is the where associated only with the second guard?
21:20:27 <Axman6> is it fine if you shift the where clause more to the left than the guard?
21:20:38 <nshepperd> GreyFaceNoSpace: you can add type annotations to expressions as well as signatures
21:20:44 <MarcelineVQ> GreyFaceNoSpace: more simply you can affix the type of the literals you're using, e.g.   randomRIO (0,1000 :: Int) :: IO Int
21:20:59 <MarcelineVQ> just   randomRIO (0,1000 :: Int)  I meant
21:21:12 <olligobber> Axman6, it doesn't work if I move the where up to the first guard or indent the where further, no
21:21:27 <GreyFaceNoSpace> but randomRIO already returns IO Int with out me specifying. or am i missing something here?
21:21:51 <nshepperd> GreyFaceNoSpace: 'm <- randomRIO (0,1000) :: IO Int' would say that this instance of 'randomRIO (0,1000)' has type IO Int 
21:21:56 <MarcelineVQ> :t randomRIO -- no Int here
21:21:58 <lambdabot> Random a => (a, a) -> IO a
21:22:05 <GreyFaceNoSpace> ok
21:22:11 <GreyFaceNoSpace> i understand now
21:23:00 <olligobber> I'm gonna join the purescript slack and ask about it there
21:23:02 <GreyFaceNoSpace> i just thought the compiler is smart at inferring things.
21:23:09 <GreyFaceNoSpace> its working fine now
21:23:32 <nshepperd> it's very smart
21:23:35 <MarcelineVQ> It is, it has inferred as far as it can, just picking Int for everything isn't inferring it's defaulting
21:24:09 <MarcelineVQ> m + n /= res  doesn't imply Int  because + can be defined for many types, and so can /=
21:24:19 <GreyFaceNoSpace> yes
21:24:20 <GreyFaceNoSpace> but
21:24:27 <GreyFaceNoSpace> randomRIO (0,1000)
21:24:30 <GreyFaceNoSpace> this is an int
21:24:32 <MarcelineVQ> :t 0
21:24:34 <Axman6> no it's not
21:24:34 <lambdabot> Num p => p
21:24:36 <mac10688> That wasn't it olligobber, but it did inspire me to hoogle it with the definition and I found that lens had the function I was looking for. ?? :: f (a -> b) -> a -> f b
21:24:48 <Axman6> it an (Num a, Random a) => IO a
21:24:54 <Axman6> it's an*
21:24:58 <GreyFaceNoSpace> ok...just so i can get this clear. 1 is a Num
21:25:03 <nshepperd> instead of Int you could have used Integer, Float, Double, Int16, Int32, Int64, Word, Word16, Word32
21:25:05 <GreyFaceNoSpace> :t 1.0
21:25:07 <lambdabot> Fractional p => p
21:25:11 <olligobber> mac10688, that looks like the type of fmap
21:25:19 <nshepperd> :t 1
21:25:20 <lambdabot> Num p => p
21:25:27 <GreyFaceNoSpace> why isnt 1 an Int if 1.0 is a fractional?
21:25:43 <GreyFaceNoSpace> :t 1.77712131
21:25:45 <lambdabot> Fractional p => p
21:25:52 <Axman6> "1" really means fromInteger (1 :: Integer) - fromInteger is a function in the Num class
21:26:06 <Axman6> @src Num
21:26:07 <lambdabot> class Num a where
21:26:07 <lambdabot>     (+), (-), (*)       :: a -> a -> a
21:26:07 <lambdabot>     negate, abs, signum :: a -> a
21:26:07 <lambdabot>     fromInteger         :: Integer -> a
21:26:40 <Axman6> this allows us to write 1 and get an Int, or an Integer, or a Double, or a Float, or an Expression or...
21:27:09 <Axman6> which is super useful, but sometimes this makes it so that the compiler can't possibly know which oner of those you wanted, like in your case
21:27:12 <mac10688> olligobber: fmap :: (a -> b) -> f a -> f b, I needed f (a -> b) -> a -> f b or [(a -> b)] -> a -> [b]
21:27:30 <GreyFaceNoSpace> ok.. forgive me if this sounds stupid. but wouldn't it be much better to keep things simpler? and just have different operations for different types of number. so you can infer the type easier?
21:27:58 <olligobber> mac10688, oh I see, that's called (<@>) in purescript, not sure what it's called in Haskell
21:28:14 <nshepperd> there are a lot of number types
21:28:28 <nshepperd> you'd end up with a billion conflicting operaters
21:29:19 <Axman6> Cale: that sounds like it would be very painful to write generic code though
21:29:24 <GreyFaceNoSpace> the way i see it you only need three types, complex, ints and floats, since everything else is a subclass of those types
21:29:24 <Axman6> uh, GreyFaceNoSpace
21:29:38 <Axman6> GreyFaceNoSpace: that's very much not true
21:29:45 <Axman6> :t 1 :: Expr
21:29:47 <lambdabot> Expr
21:29:58 <Axman6> > f 7 + 31 :: Expr
21:30:00 <lambdabot>  f 7 + 31
21:30:01 <GreyFaceNoSpace> Axman6, ok....i give up
21:30:03 <nshepperd> types don't have subclasses in haskell
21:30:39 <olligobber> mac10688, hoogle is good for looking up these sorts of things
21:30:52 <GreyFaceNoSpace> yeah...ok .. i just used ocaml for a while. and its alot different. so takes a while to get used to this
21:31:11 <Axman6> yeah it does, and it is certainly occasionally confusing
21:31:20 <GreyFaceNoSpace> Axman6, yeah
21:31:58 <Axman6> but that is because it is also incredibly powerful
21:32:11 <GreyFaceNoSpace> Axman6, yeah....i really liked the lazy evaluation
21:32:21 <GreyFaceNoSpace> looks really really really powerful
21:32:25 <nshepperd> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num here is an incomplete list of all the number types in haskell
21:32:58 <GreyFaceNoSpace> nshepperdthank you sir
21:33:29 <GreyFaceNoSpace> while we're on topic
21:33:41 <nshepperd> other packages add more, things like vectors and matrices and symbolic calculus thingies
21:33:43 <GreyFaceNoSpace> do any of you guys formally verify the code you write 
21:33:51 <GreyFaceNoSpace> ?
21:34:03 <Axman6> nah
21:34:17 <MarcelineVQ> a little
21:34:28 <GreyFaceNoSpace> ok...im actually doing this as part of a verification course
21:34:38 <GreyFaceNoSpace> its really fun
21:34:49 <Axman6> ha, sorry, I'm sure some do, but I think most aim to make as many foreseeable errors impossible to represent. that's a lot less work than full formal verification of things
21:35:37 <Axman6> like, how do you ever formally verify something which deals with Strings? if you're happy working with Strings, then you're happy working with the Mandarin translation of War and Peace
21:35:55 <GreyFaceNoSpace> i thought it might be useful since if you wanna change some function with a newer more efficient one. then you don't have to test the new function. just prove that they are equivillant and you are good to go
21:36:03 <GreyFaceNoSpace> but it might be different in practice ofc
21:36:22 <GreyFaceNoSpace> Axman6, induction?
21:36:40 <GreyFaceNoSpace> strings are just lists of chars at the end of the day
21:36:41 <nshepperd> formal verification sounds great as long as someone else has to do the work
21:37:25 <Axman6> but they're also infinite - and depending on what you're doing induction may not work. you can probably prove that a parser parses a given language though
21:37:56 <GreyFaceNoSpace> Axman6, can you give an example where induction will not work?
21:39:10 <GreyFaceNoSpace> the way i understood it. that since haskell is strongly typed and a pure functional language. everything you write in haskell can be argued about in a mathematical manner
21:39:20 <GreyFaceNoSpace> meaning you can prove everything you write
21:39:48 <Axman6> you can write PHP in any language though, - by which I mean just because it facilitates doing that doesn't mean it is always done
21:45:45 <mac10688> Hi all, I want to use lens to traverse my structure. I think I almost have the very basics but now I am faced with a problem where I need to apply a function to get the state of my form so I can continue traversing
21:45:48 <mac10688> https://pastebin.com/3GmED8jp
21:46:26 <mac10688> how can I go from myForm -> FormState -> WsOne ?
21:46:48 <mac10688> I need to apply the brick function formState to myForm to get the FormState out of it
21:53:27 <jackdk> mac10688: I don't know brick but the `to` function lifts a function into a `Getter`
21:54:02 <jackdk> `blah ^. myForm . to formState . wsOne`, perhaps?
21:54:22 <Axman6> :t to
21:54:24 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
21:54:26 <mac10688> let me give that a shot
21:55:40 <jackdk> :info Optic'
21:55:46 <mac10688> I've been studying lenses for a while now and they barely make sense to me ><
21:57:07 <jackdk> treat a lens as an abstract data type, and don't worry about the implementation. You've started in the right place: nested record accessors. Just nibble at the library a bit at a time and you'll get there
22:08:24 <iqubic> I know how lenses work at a basic level.
22:09:13 <iqubic> Well, I mean... I know how the Van Laarhoven encoding works.
22:13:47 <iqubic> Twas Twan Van Laarhoven that came up with this.
22:14:48 <jackdk> iqubic: there is a reason for the extra f in the p a (f b) -> p s (f t) formulation, but I forget what it is. I remember something about unifying with the type of traverse but that's not the main reason
22:14:52 <jackdk> do you recall?
22:15:27 <iqubic> No. I don't.
22:15:42 <jackdk> thanks anyway
22:15:46 <iqubic> Most lenses just use the (->) profunctor there.
22:16:17 <iqubic> Ah, but you were asking about the f.
22:16:44 <iqubic> Lenses use f ~ Functor. Traversals use f ~ Applicative.
22:17:06 <iqubic> In order to have multiple focus points you need applicative.
22:17:35 <iqubic> The difference between lens and traversal is like the difference between fmap and liftA2.
22:17:41 <jackdk> I'm cool with that bit, but you can hide that inside the p if you're going full profunctor optics and have p a b -> p s t
22:18:14 <iqubic> Yes. Correct.
22:18:47 <jackdk> there's a specific reason this is not done for haskell's lenses in particular, and it has something to do with library ergonomics or something and it bugs me that I forget what it is
22:18:55 <shachaf> jackdk: The reason is compatibility with the library function "traverse".
22:19:06 <iqubic> If you want to look into that, you can take a look at this: https://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor.html#t:Star
22:19:34 <jackdk> shachaf: thanks. I mentioned that a little way in the scrollback, and when I mention it in the past I've been told that's a reason but not the primary one. I wish I could remember
22:20:03 <iqubic> "p a b -> p s t" is the same as "p a (f b) -> p s (f t)" if you let p ~ Star in the former.
22:20:11 <jackdk> indeed
22:20:11 <shachaf> That is the primary reason as far as I know (and I'm the person who came up with profunctor lenses originally).
22:20:29 <shachaf> There are some other reasons that having the f there can be more convenient sometimes but you can work around them.
22:20:51 <jackdk> in that case I'll take your word for it; thanks.
22:21:14 <iqubic> shachaf: What is Forget good for in profunctor optics?
22:21:24 <shachaf> It's good for getting. That's why it's called "For get".
22:21:42 <shachaf> I called it that as a joke and somehow the name stuck.
22:21:46 <iqubic> Oh. Is that true?
22:21:51 <shachaf> Yep.
22:22:08 <iqubic> I thought it was called Forget because is forgets the third parameter.
22:22:15 <jackdk> that's as bad as Biff and Tannen in bifunctors `:-)`
22:22:20 <shachaf> jackdk: The main other reason I remember is a unification issue when you're using indexed optics, so you have p a b -> q u v and p' u v -> q' s t, and you need to unify q and p'.
22:22:52 <shachaf> And you have to do some trick or something to make it work. I don't remember exactly, it's been a while.
22:22:59 <iqubic> I actually haven't seen Back To The Future, so I only figured out why those names are what they are last month.
22:23:06 <jackdk> fair enough. thanks
22:23:48 <iqubic> "type (:->) p q = forall a b. p a b -> q a b" exists.
22:24:04 <iqubic> Why would you ever need a natural transformation over profunctors?
22:24:32 <shachaf> Sounds like a dinatural transformation.
22:24:46 <jackdk> maybe some abstract representation of a function, and q ~ (->)?
22:25:17 <iqubic> I guess.
22:26:13 <jackdk> I was wondering if someone had packaged up free arrows, and it seems as though there's something like it in package free-category
22:26:38 <iqubic> so, I just found the blog post where Twan Van Laarhoven introduced the world to his Var Laarhoven encoding of lenses: https://www.twanvl.nl/blog/haskell/cps-functional-references
22:27:28 <iqubic> And then along comes this: http://r6.ca/blog/20120623T104901Z.html
22:28:00 <iqubic> Which lets us go from Lens' s a to Lens s t a b
22:29:02 <shachaf> Of coure you can do that with any representation of lenses.
22:29:09 <shachaf> Lens s t a b = s -> (a, b -> t)
22:29:09 <iqubic> That last blog post comes from Russell O'Conner
22:29:20 <iqubic> That's the store based encoding.
22:29:57 <iqubic> You can also implement lenses with a Pretext.
22:30:31 <shachaf> Yes, Pretext a b t = (a, b -> t)
22:31:35 <iqubic> No, actually: newtype Pretext p a b t = Pretext { runPretext :: forall f. Functor f => p a (f b) -> f t }
22:31:43 <iqubic> As defined in the Lens library.
22:32:17 <shachaf> OK, Pretext (->) a b t is isomorphic to (a, b -> t)
22:32:33 <iqubic> And then there's the Bazaar, which is the same, but with an applicative constraint.
22:37:17 <texasmynsted> Is there a commonly accepted format/syntax for describing ideas like Monad and Applicative functor (the versions as used in Haskell) with math, diagrams, pictures or something other than haskell code?
22:37:57 <iqubic> No. I can't say there is.
22:38:09 <texasmynsted> Any suggestions?
22:39:18 <texasmynsted> I have seen burritos and boxes for Monads to represent the context but those do not seem _right_ to me.
22:40:18 <iqubic> No. That's right.
22:40:49 <shachaf> Please don't use burritos and boxes. They are nonsense.
22:40:59 <texasmynsted> ^ 
22:41:42 <shachaf> I don't know what a syntax for describing them with diagrams would be, unless you mean commutative diagrams or string diagrams.
22:41:49 <texasmynsted> There must be some relaxed or informal math way right?
22:42:40 <shachaf> I don't know what that would mean.
22:42:41 <texasmynsted> Hm. String diagrams might work
22:43:47 <jle`> texasmynsted: there's this post from like seven years ago http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
22:44:03 <jle`> texasmynsted: but be aware i don't like the intuition that those images invoke
22:44:15 <shachaf> Don't do what that post does.
22:44:21 <shachaf> Those diagrams only make things more confusing.
22:44:23 <jle`> since it sort of suggests that 'functors are boxes'
22:44:38 <jle`> yes it is big doodoo
22:44:51 <texasmynsted> I am just looking for some abstraction that identifies the ideas free of syntactical misdirection 
22:45:31 <jle`> honestly the type of bind already is visually powerful in a meaningful way
22:45:36 <jle`> m a
22:45:38 <jle`> a -> m b
22:45:40 <jle`> m b
22:45:50 <jle`> it even has little ascii arrows and everything
22:46:03 <iqubic> I love ascii arrows.
22:46:07 <shachaf> There are enough abstractions already. You don't need to abstract monads more.
22:46:29 <texasmynsted> Those diagrams are okay but they emphasize operation semantics
22:46:38 <jle`> m a  ,  a -> m b
22:46:43 <texasmynsted> s/operation/operational/
22:47:12 <jle`> m a  ,  a -> m b
22:47:13 <jle`> ---------------
22:47:16 <jle`>      m b
22:47:28 <shachaf> The box diagrams don't emphasize operational anything.
22:47:31 <dminuoso> jle`: The type is only powerful to a user who has a rough understanding of how type variables work and parametricity 
22:47:35 <shachaf> There are no boxes, operationally.
22:47:44 <jle`> it's already very visual
22:47:49 <jackdk> texasmynsted: maybe something like this will help? https://i.imgur.com/vnGK668.jpg
22:48:54 <texasmynsted> okay... jackdk where did those come from?
22:49:05 <jackdk> texasmynsted: my notepad, a couple of seconds ago
22:49:11 <jle`> dminuoso: capitalize the M and the distinction between parametricity and variables goes away, which might make it less confusing
22:49:12 <texasmynsted> Heh
22:49:22 <jle`> M a  ,  a -> M b
22:49:24 <jle`> ----------------
22:49:27 <jle`>       M b
22:49:52 <texasmynsted> jackdk: You wrote that out during this irc chat?
22:49:56 <jackdk> texasmynsted: yes
22:51:23 <texasmynsted> okay I am warming to both syntax and boxes... 
22:51:32 <jle`> don't use boxes
22:51:34 <jle`> D:
22:51:51 <jackdk> drawing a similar diagram for `(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c` might help too.
22:52:04 <dminuoso> texasmynsted: An alternative way, is to think of Monad as being equipped with `join :: m :.: ~> m` and `pure :: Identity ~> m`
22:52:14 <texasmynsted> yeah the capitals provides a logical and visual distinction.  Nice
22:52:35 <dminuoso> texasmynsted: Once you go from functions to natural transformations, the representation becomes more intuitive to some people.
22:52:49 <dminuoso> It also avoids what me and jle` just talked about from a different angle
22:53:13 <dminuoso> Oh shoot, I missed an m. That should have read: join :: m :.: m ~> m
22:53:46 <shachaf> Diagrams like https://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition are good but probably not for people who want to figure out what monads in Haskell are like.
22:54:01 <jle`> i mean if you understand the concept of functor composition ... you already pretty much at the point where monads are obvious
22:54:11 <dminuoso> texasmynsted: Mind my asking.. why are you asking at all?
22:54:12 <jackdk> in no case do you "drop down" from "one level of m-ness", and you can start to see how you could write any of `(>>=)`, `join` and `(>=>)` in terms of any of the others. `join` and `(>=>)` in particular have nicer representations of the monad laws, so you can get a grip on them
22:54:31 <shachaf> Mostly I think the right thing to do is to give the definition -- no analogies -- and to give a bunch of examples (not necessarily in that order).
22:54:39 <jle`> which is why talking about m :.: m, or m^2 ... understanding what those mean, you already are pretty much all the way there
22:54:40 <jackdk> ^
22:54:51 <shachaf> You can also motivate the definition. But don't motivate it with boxes or burritos, only with true things.
22:55:06 <jle`> yeah, none of the discussion here or the things we have mentioned would be of any use to someone learning how to understand monads in haskell
22:55:15 <jle`> they're really only useful for people who already have a grasp of monads
22:55:15 <dminuoso> texasmynsted: Am I right in my assumption that you intend to write some resource for teaching someone else about these things?
22:55:20 <jle`> and maybe want to recontextualize it
22:55:51 <jackdk> shachaf: I agree. I've assisted with a bunch of teaching and the most success I've seen comes from "write a bunch of instances using type holes", followed by "using only the monad typeclass, write some useful functions (like `when`, `unless`, `(>=>)`, `join`, ...)"
22:58:29 <joeyh> I have something with a type similar to fmap, but not quite a functor: (Stream a -> Stream b) -> f (Stream a) -> f (Stream b) ... is there some functor-like concept that could be used for this?
22:58:32 <texasmynsted> because I have an simple article I am writing to describe how functions applied to parameters within a potentially effectful context work differently with Applicative and Monad....
22:59:23 <dminuoso> texasmynsted: Is your audience one who does not understand monads yet
22:59:34 <texasmynsted> My first shot took monads, functors and applicatives apart. Describing what they are and how they work. It was too operational.
22:59:45 <dminuoso> texasmynsted: I invite you to give this a thorough read https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
22:59:48 <jle`> joeyh: it depends on what you want to do with the concept
22:59:54 <jackdk> joeyh: if you have `Functor f`, then it collapses to fmap once you set `c ~ Stream a` and `d ~ Stream b`: then it's `(c -> d) -> f c -> f d`
23:00:49 <joeyh> I don't have Functor f unfortunately (because there's no Functor Stream)
23:00:54 <jle`> joeyh: if you want to use the concept to do static analysis/code reuse/refactoring ... we'd have to know more about Stream
23:01:11 <jackdk> joeyh: you don't need Functor Stream
23:01:27 <jle`> jackdk: Stream is not the Functor here, 'f' is potentially the Functor
23:01:34 <jackdk> jle`: yes
23:01:37 <joeyh> hmm, I just tried to write it and seemed I'd need that, or maybe my jetlag just got too high
23:01:43 <texasmynsted> Specifically related to some handy apply syntax, in Scala, that works with what is referred to there as Semigroupal.
23:01:48 <jle`> jackdk: er sorry it was meant for joeyh 
23:01:57 <jle`> joeyh: er, how polymorphic is that?
23:02:01 <jackdk> jle`: :-)
23:02:05 <jle`> joeyh: is it written to work for all f's? and all a's and all b's?
23:02:09 <texasmynsted> My expectation is that the audience knows Monad well
23:02:11 <jle`> or only for specific f
23:02:15 <joeyh> jle`: not fully polymorphic
23:02:27 <jle`> so which parts are polymorphic, and which parents aren't
23:02:30 <joeyh> it's Stream from copilot
23:02:56 <joeyh> which is constrained to be inhavbited by some common C types
23:03:21 <jle`> Stream is already completely constrained
23:03:23 <jle`> to be exactly Stream
23:03:41 <jle`> it's also not inhabited :o it's of kind `k -> Type` apparently
23:03:44 <texasmynsted> would be nice if type wholes worked well in Scala
23:03:56 <dminuoso> texasmynsted: If they know monads well, then I recommend the `join :: m :.: m ~> m` approach
23:04:01 <jle`> joeyh: are you trying to say that 'a' and 'b' are constrained?
23:04:09 <joeyh> yes
23:04:14 <jle`> but 'f' is not?
23:04:19 <jackdk> a pastebin would be helpful here, I think
23:04:32 <texasmynsted> hmm that is good.
23:04:56 <dminuoso> texasmynsted: From that you can jump *right* to category theory diagrams for monad laws if you want.
23:05:03 <texasmynsted>  I wonder if using Haskell syntax would be a nice compromise for a Scala article 
23:05:16 <joeyh> actually I think you only need to see one line of code: data TypedStream p t = TypedStream (Stream t)
23:05:21 <dminuoso> Because if you grasp that join signature above, you should be able to make sense of the associativity/identity diagrams even without any category theory knowledge.
23:05:27 <joeyh> TypedStream is what I would like to be a functor
23:05:50 <jle`> hm, how does TypedStream relate to what you wrote before
23:05:54 <jle`> ah, is that what 'f' is supposed to be?
23:05:54 <joeyh> goal being to get some better data types than the C ones..
23:06:13 <jle`> (Stream a -> Stream b) -> TypedStream (Stream a) -> TypedSTream (Stream b) ?
23:06:18 <joeyh> nod
23:06:19 <jle`> so like doubly-nested streams?
23:06:31 <jle`> a TypedStream (Stream a) is a Stream (Stream a)
23:06:39 <joeyh> not nested, only with an added phantom type param
23:06:50 <jle`> right but your function returns a TypedStream (Stream a)
23:06:55 <jle`> which is a doubly-nested stream, as you have defined it
23:07:04 <jle`> TypedStream p (Stream a) ~ Stream (Stream a)
23:07:10 <joeyh> oh, right, so that's the bit I had wrong
23:07:43 <joeyh> (Stream a -> Stream b) -> TypedStream p a -> TypedStream p b
23:07:59 <jle`> that sounds like just myFunc f (TypedStream x) = TypedStream (f x)
23:08:23 <jle`> hm, are you saying that you want to conceptualize TypedStream in some sort of abstraction
23:08:30 <joeyh> tis, but then you want more parameters
23:08:37 <texasmynsted> Okay thank you all. :-)
23:08:40 <joeyh> I want applicative, basicallu
23:08:46 <jle`> and what does that mean?
23:08:58 <jle`> TypedStream p b q a ?
23:09:11 <joeyh> (Stream a -> Stream b -> Stream c) -> ... etc
23:09:46 <jle`> hm. i think you might have the cause and effect of this backwards maybe. i wouldn't say you 'want functor' or you 'want applicative'
23:09:56 <jle`> something is a functor or applicative because of what it inherently is
23:10:00 <jle`> it's not something you can change about something
23:10:08 <jle`> but you can talk about the specific sort of functions you want to write specifically for it
23:10:13 <joeyh> well, I do because writing liftT liftT2 etc gets old pretty quick
23:10:31 <jle`> you don't want Applicative literally necessarily, you want some sort of multi-arity abstraction
23:10:45 <jle`> would anything work that would let you do arbitrary arity lifting?
23:10:49 <jle`> or does it *have* to be Applicative ?
23:10:55 <joeyh> I don't think it's quite functor or applicative, no, but it's doing something very similar isn't it?
23:11:49 <jle`> there are some similarities in the usage patterns yeah, but i guess saying you 'want Applicative' can be misleading
23:11:58 <jle`> or take you down weird paths and dead ends
23:12:06 <jle`> when all you wanted was a way to do arbitrary arity lifting
23:12:12 <joeyh> fair enough
23:13:01 <jle`> in this case i'm not sure there is a nice way to do this
23:13:04 <jle`> you want to be able to unite
23:13:14 <jle`> (Stream a -> Stream b) -> TypedStream p a -> TypedStream p b
23:13:25 <jle`> (Stream a -> Stream b -> Stream c) -> TypedStream p a -> TypedStream p b -> TypedStream p c
23:14:08 <jle`> you can't quite do the partial application trick that Applicative does because this is constrained to only certain a's and b's, right?
23:14:44 <jle`> there are some hacky was using typeclasses (like how Quickcheck does it) or hlists maybe, but i'm not sure there's a nice normal-haskell way
23:15:19 <joeyh> hmm, the kind of typeclass hacks that printf also uses I think?
23:15:55 <jle`> it's similar, yeah
23:16:05 <joeyh> I'm ok with getting a little wacky, so guess I'll look into those
