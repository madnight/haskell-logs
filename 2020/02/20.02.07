00:55:23 * hackage hedis-envy 0.1.0.1 -   https://hackage.haskell.org/package/hedis-envy-0.1.0.1 (igrep)
01:03:53 * hackage hledger-flow 0.13.0.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.13.0.0 (apauley)
01:07:06 * haskelllisp[m] uploaded an image: image.png (34KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/FRnhsPcKibIwjkukfrtEwAXr >
01:07:36 <haskelllisp[m]> What does `subdirs` do?
01:09:06 <shachaf> It looks like it gets a red rounded rectangle around it.
01:14:25 * haskelllisp[m] uploaded an image: image.png (170KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/qDFOnDAqBMAdsAGUjouwxwmD >
01:15:39 <haskelllisp[m]> @shachaf Are you familiar with `MakeFile config`? The following three packages were added by me, but they do not work..
01:15:56 <shachaf> Now the red rectangle has moved down a little below the subdirs.
01:16:24 <shachaf> You should really give more context if you're asking questions, instead of a screenshot of part of a YAML file. Haskell isn't made of YAML.
01:16:26 <lambdabot> Unknown command, try @list
01:19:02 <haskelllisp[m]> https://github.com/limengyu1990/amazonka/blob/master/Makefile 
01:19:02 <haskelllisp[m]> Sorry, my English typing is slow .. This is the `MakeFile` configuration link that depends on the package.
01:21:28 <haskelllisp[m]> I want to know if the `MakeFile` is configured correctly? Can I correctly reference `amazonka-elb / amazonka-elb / amazonka-route53` via `subdirs` in the current project
01:22:04 <alc> why there's no word in Data.ByteString?
01:22:10 <alc> `word'
01:23:35 <shachaf> What's a word, a machine word?
01:24:07 <alc> shachaf: Data.List.word
01:25:15 <jackdk> % :info Data.List.word
01:25:15 <yahb> jackdk: ; <interactive>:1:1: error: Not in scope: `Data.List.word'
01:26:08 <jackdk> alc: do you mean Data.List.words? that's because ByteString is a chunk of bytes, not text. It is not safe in general to treat a ByteString as if it contained text.
01:26:09 <alc> ok, find it here https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Char8.html#v:words
01:26:16 <alc> jackdk: yeah, words
01:26:48 <jackdk> Data.ByteString.Char8 has a words function yeah, because it's trusting that you know the ByteString a string with only those codepoints
01:26:58 <alc> jackdk: it's not safe, then why we have OverloadedStrings
01:27:00 <jackdk> Data.Text has a words function too, that works on the Text type
01:27:48 <jackdk> OverloadedStrings does exactly one thing: lets GHC automatically convert string *literals* into other types where it makes sense
01:27:58 <jackdk> e.g., writing Text.pack "foo" everywhere would get really old really quick
01:28:19 <jackdk> OverloadedStrings does *not* mean anything that's stringy can be converted to any other string type. it's for literals only
01:29:25 <alc> ok
01:32:02 <jackdk> actually, I tell a little lie; OverloadedStrings also lets you use string literals in patterns, where it does an equality check. See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals
01:46:56 <oisdk> Is there a recursion scheme for `foldl`?
01:47:21 <oisdk> (As in, does it have a name)
01:48:54 <Franciman> one of catamorphism or anamorphism?
01:49:03 <oisdk> catamorphism
01:49:07 <Franciman> not sure if it pertains
02:01:48 <shachaf> Named recursion schemes are silly anyway.
02:02:02 <shachaf> But foldl isn't particularly structural, it's just a thing you can do to a list.
02:02:57 <Rembane> oisdk: Nope, cata is foldr. You need to do the CPS-trick with cata to get a foldl.
02:03:06 <Franciman> is list the ultimate model of recursion?
02:06:07 <oisdk> Rembane right, but I'm wondering if there's a general name for the CPS trick on a catamorphism. 
02:06:24 <absence> my haskell program won't quit, it just hangs after finishing main. i'm guessing it's related to ffi and threads. is it possible to print all threads or something? someone suggested using strace, but i can't get it working inside the docker image
02:06:35 <Rembane> oisdk: I haven't seen one so far. 
02:41:23 * hackage eccrypto-ed25519-bindings 0.1.0.0 - provides "ed25519" API using "eccrypto"  https://hackage.haskell.org/package/eccrypto-ed25519-bindings-0.1.0.0 (MarcelFourne)
02:44:54 <hc> hui
03:14:21 <dminuoso> absence: Use gdb/lldb?
03:22:13 <siers> you can get an fmap/functor instance if you've got a monad instance, is that correct?
03:24:09 <tomjaguarpaw> What do you mean my "can get"?
03:24:25 <siers> can derive
03:24:58 <tomjaguarpaw> To write a Monad instance someone already needs to have written the Functor instance
03:25:06 <tomjaguarpaw> so I'm not sure what you mean "can derive"
03:25:31 <tomjaguarpaw> If you're in a function of type "Monad m => ..." then you can use fmap of values of type "m a".  Is that what you wanted?
03:25:49 <shachaf> You can write "instance Monad M where { ... }; instance Functor M where { fmap = liftM }"
03:25:50 <siers> ah, having a monad requires that already.
03:26:03 <shachaf> Where liftM is defined in terms of Monad.
03:26:46 <__monty__> siers: fmap f x = x >>= return . f, so yes, Monad *would* be sufficient.
03:27:27 <siers> :) cool
03:34:48 <Taneb> Does anyone know a good way to find all lazy patterns in a codebase?
03:38:33 <davve> git grep is useful
03:39:01 <davve> (maybe not for your case, still a haskell noob, not sure what lazy patterns look like)
03:39:14 <Taneb> davve: it picks up more than it should, is the issue
03:39:17 <dminuoso> Taneb: I wonder, is there some identifiable artifact in core/stg?
03:39:21 <davve> ah
03:39:34 <Taneb> e.g. type equality constraints, and lens's .~ operator
03:39:46 <shachaf> Is that like grep except it only works if you're using git?
03:39:59 <davve> shachaf: yeah
03:40:18 <davve> it will go through whichever folder you are in recursively
03:40:26 <shachaf> Many "lets" are also lazy patterns, depending on what you're looking for.
03:40:59 <Taneb> I'm specifically looking for lazy patterns in do notation that was added by my coworkers and possibly also by me to work around the monadfail changes in GHC 8.6
03:41:41 <absence> dminuoso: gdb also doesn't work for the same reason as strace (permissions, even though i run as root and have disabled ptrace_scope in /proc)
03:43:23 <__monty__> Taneb: Doesn't `~[^ ]` work?
03:44:24 <boxscape> hm, some primitive operations like tagToEnum# are defined as "tagToEnum# = let x = x in x", and others, like dataToTag#, are defined as "dataToTag# = dataToTag#". Strange little inconsistency.
03:45:19 <Taneb> __monty__: seems like it does, thank you
03:45:30 <__monty__> np
03:55:34 <boxscape> % (unsafeCoerce (\a -> a) :: Functor a => a Int)
03:55:34 <yahb> boxscape: [Segmentation fault]
03:55:40 <boxscape> fair enough
03:55:44 <boxscape> didn't terminate in my ghci
03:56:53 * hackage aeson-match-qq 1.1.0 - Declarative JSON matchers.  https://hackage.haskell.org/package/aeson-match-qq-1.1.0 (MatveyAksenov)
04:00:38 <mpickering> Does anyone know what instances you need for the `Show` instance for `dependent-map`?
04:00:50 <mpickering> I can't work out what instances I have to define for the keys and values
04:08:01 * haskelllisp[m] uploaded an image: image.png (83KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/WuPDMeWGthKzxilxValYRKrS >
04:08:30 <haskelllisp[m]> Does `stack install` have detailed error logs?
04:21:27 <tabaqui1> haskelllisp[m]: "-v"?
04:21:39 <jakov> Hi ! How could i convert a (Data.Vector.Vector Word16) to a (Numeric.LinearAlgebra.Vector Word16) ? 
04:24:14 <Taneb> jakov: Data.Vector.convert I think should owrk
04:30:24 <jakov> thank you Taneb ! 
04:31:02 <Taneb> jakov: the Vectors in Numeric.LinearAlgebra are the same type as Data.Vector.Storable, if this helps you
04:37:06 <boxscape> % let a = pure undefined in a
04:37:06 <yahb> boxscape: 
04:37:18 <boxscape> kind of interesting that this works
04:38:37 <Rembane> I think it only evaluates the Applicative part of the value and then is done with it. 
04:40:00 <tomjaguarpaw> Then try 'seq it ()'
04:40:19 <boxscape> % seq it ()
04:40:19 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:3:14 in interactive:Ghci4
04:40:26 <boxscape> hm, indeed
04:41:06 <boxscape> % let a = pure undefined in a
04:41:06 <yahb> boxscape: 
04:41:08 <boxscape> % :t it
04:41:08 <yahb> boxscape: GHC.Exts.Any
04:42:45 <tomjaguarpaw> GHCi won't try to show anything it doesn't have a Show instance for, and it doesn't have one for Any
04:43:02 <tomjaguarpaw> That's why it doesn't blow up until you force the return value
04:43:18 <boxscape> you mean for something like `IO Any`?
04:43:45 <tomjaguarpaw> Yes
04:43:53 <boxscape> okay
04:45:25 <mniip> % let a = traceShow (typeOf a) $ pure undefined in a
04:45:25 <yahb> mniip: ; <interactive>:7:1: error:; * No instance for (Typeable f0) arising from a use of `it'; * In a stmt of an interactive GHCi command: print it
04:45:25 <tomjaguarpaw> Oh, well, I mean there is no Show Any, rather than there is no Show (IO Any) [even though that is true too]
04:45:35 <mniip> rip
04:46:42 <boxscape> right but `undefined :: Any` will result in an error message, whereas `pure undefined :: IO Any` will result in nothing being printed
04:47:13 <tomjaguarpaw> Yes, GHCi treats expressions of type IO a specially
04:47:25 <tomjaguarpaw> It runs them and then if there is a Show instance for a it shows the result
04:47:31 <boxscape> I see
04:48:05 <tomjaguarpaw> If there is no Show instance it doesn't force them at alls
04:48:13 <tomjaguarpaw> For other types it forces first, then tries to Show
04:49:11 <tomjaguarpaw> Oh, no it seems that it doesn't force, but it does try find a Show instance 
04:50:08 <boxscape> except for
04:50:09 <boxscape> % pure undefined :: IO ()
04:50:09 <yahb> boxscape: 
04:51:15 <boxscape> % unsafeCoerce (pure undefined :: IO String) :: IO (Proxy ())
04:51:15 <yahb> boxscape: Proxy
04:51:33 <boxscape> (that's not part of the exception, just a non-strict show on Proxy)
04:56:05 <tomjaguarpaw> % data A = A; instance Show A where show A = undefined
04:56:05 <yahb> tomjaguarpaw: 
04:56:10 <tomjaguarpaw> % pure A
04:56:10 <yahb> tomjaguarpaw: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:22:44 in interactive:Ghci13
04:56:17 <tomjaguarpaw> % pure undefined
04:56:17 <yahb> tomjaguarpaw: 
04:56:25 <tomjaguarpaw> The difference is the Show instance
04:57:31 <tomjaguarpaw> % pure (undefined :: GHC.Exts.Any)
04:57:32 <yahb> tomjaguarpaw: 
04:57:37 <tomjaguarpaw> % pure (undefined :: Int)
04:57:37 <yahb> tomjaguarpaw: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:31:7 in interactive:Ghci18
05:02:30 <Netsu> Hello, what is the stack syntax to add multi-package project to extra-deps?
05:02:41 <Netsu> e.g. this one https://github.com/Simspace/servant-websockets
05:10:41 <Netsu> Oh, got it, it require explicit subdirs for some reason
05:13:03 <haskelllisp[m]> ~/.stack/loaded-snapshot-cache/x86_64-linux/ghc-8.4.3/custom-wire-1.0-2WoJ7G-x0xyy.cache
05:13:04 <haskelllisp[m]> What files are in the `loaded-snapshot-cache` directory? Can I delete and regenerate them automatically?
05:47:25 <prog16> i cant tell why bs0 is ambiguous here; https://pastebin.com/raw/v3DDHNs8
05:51:36 <lyxia> prog16: bs only occurs as a parameter of the Connections type family
05:52:14 <lyxia> prog16: it's actually unused in Player bs l s a, because it only goes in Phantom bs (Update ...)
05:52:42 <lyxia> type Phantom a b = b    does nothing useful
05:54:53 * hackage hpqtypes-extras 1.10.2.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.10.2.0 (arybczak)
05:55:31 <dminuoso> What mechanism controls -O flags on dependencies? Is that just the respective cabal files (with `optimization` or `ghc-options`), or does cabal have mechanisms to recompile dependencies with optimization flags, like it would with profiling?
05:56:53 <merijn> dminuoso: The cabal config optimisation setting affects dependencies, as does --ghc-options on the commandline
05:57:12 <merijn> dminuoso: -O is included in the hash for the Nix store, so changing it will trigger recompiles, yes
05:57:54 <dminuoso> merijn: Ah. Im pleasantly surprised then, because that indicates every single package in my dependency tree is compiled with -O2 already.
05:58:22 <prog16> lyixia: thanks
05:58:24 <dminuoso> I just tried it, and it just rebuilt my local package but no dependencies. I was worried the dependencies weren't compiled with -O2.
05:58:34 <dminuoso> What's the most elegant way to look and find out what flags a registered package has been compiled with?
05:59:02 <prog16> i guess it needs to be a newtype with some extra matching
06:01:38 <merijn> prog16: oof...those types...
06:06:58 <prog16> :-D
06:08:09 <prog16> it should have it so that the bools at each player specify the position in the multiplayers (
06:08:13 <prog16> list of players)
06:08:21 <prog16> where the inputs are located
06:08:46 <prog16> its the "privacy masking" idea i was describing yesterday 
06:09:18 <prog16> they kind of mutually rely on each other to generate the update to the whole system
06:09:47 <prog16> its just a way to have the updates to each players value depend on only a subset of all the other players values
06:10:43 <prog16> then, the type the update function takes (puting all the args curried into a HList) isnt quite enough
06:11:00 <prog16> as the location of where to get this type is also required, hence the bools
06:11:18 <prog16> each of the update functions for each player*
06:11:48 <prog16> I'll post it when its done
06:12:12 <boxscape> % type family Fam (t :: k)
06:12:12 <yahb> boxscape: 
06:12:14 <boxscape> %:k Fam
06:12:21 <boxscape> % :k Fam
06:12:21 <yahb> boxscape: Fam :: k -> *
06:12:25 <boxscape> hmm
06:12:29 <boxscape> it prints a forall for me
06:12:32 <boxscape> or wait
06:13:14 <boxscape> % type family Fam (t :: k a)
06:13:14 <yahb> boxscape: 
06:13:18 <boxscape> % :k Fam
06:13:18 <yahb> boxscape: Fam :: forall k1 (k2 :: k1 -> *) (a :: k1). k2 a -> *
06:13:39 <boxscape> this one prints forall, even though -fprint-explicit-forall is not on
06:14:11 <boxscape> seems kind of strange, would it not mean the same if you were to write Fam :: k2 a -> *?
06:14:56 <Solonarv> currently that is not the same thing
06:15:23 <Solonarv> oh wait, I misunderstood
06:17:40 <boxscape> (notably it is slightly different if the flag is on, s/k1/{k1}, because k1 is inferred)
06:19:56 <dminuoso> Any suggestions for alternate operator names? (>$>=) :: Monad m => m a -> (a -> m b) -> m a
06:20:51 <dminuoso> I played with the idea of naming it `<*=` to hint at (<*) from applicative
06:20:54 <Solonarv> what does it do? m >$>= f = m >>= \x -> x <$ f x
06:21:06 <merijn> Solonarv: Yes
06:28:36 <dminuoso> I think Im sticking with <*=, it's basically a version of (<*). If we think of >>= as a version of >> that turns the right hand side into a matching arrow, then <*= is a better fit.
06:30:01 <Solonarv> it reminds me of the lens operator <*=, idk if that is a good thing
06:30:06 <ne2k> coming back to Haskell after many years of procedural programming, more out of curiosity than anything else. when I used it before I never got onto real-world interaction, it was a teaching language. I'm currently trying to fully understand functors, applicatives and monads WITHOUT any syntactic sugar. I thought I understood what a functor was, but then the explanations of the next parts all use things like <- and >>=, and I
06:30:06 <ne2k>  really could do with an explanation of what those really are, like a symbol by symbol walkthrough
06:31:09 <Solonarv> >>= is not syntactic sugar, it is simply an operator (much like say > or +)
06:31:12 <dminuoso> Solonarv: Well lens has every conceivable operator starting with < already overloaded.
06:31:23 <Solonarv> this means it is simply a function that is written infix
06:31:46 <dminuoso> Solonarv: but that's exactly what operators are! syntactic sugar for functions.
06:31:55 <dminuoso> Solonarv: Operators are grammatically different.
06:32:29 <ne2k> Solonarv, ok, so >>= is a regular function. and how about <$> and <*>? are they just functions too? (infix style)
06:32:34 <Solonarv> yup
06:32:36 <ne2k> and where are they defined?
06:32:43 <Solonarv> (and <$> is just an alias for fmap)
06:33:12 <merijn> ne2k: >>= is defined in the Prelude
06:33:17 <Solonarv> >>= belongs to Monad, <*> to Applicative, <$> to Functor - so they're defined wherever those are
06:33:27 <merijn> ne2k: You can define your own operators too
06:33:41 <Solonarv> "officially" that's in Control.Monad, Control.Applicative, and Data.Functor respectively
06:33:58 <ne2k> merijn, yep, I think you just put () around the function name at the type declaration, right?
06:34:03 <merijn> > let x ☃ y = x * x + y * y in 2 ☃ 3
06:34:05 <lambdabot>  13
06:34:15 <merijn> ne2k: You can define them infix too (like above)
06:34:33 <merijn> > let (☃) x y = x * x + y *y in 2 ☃ 5 --this works too
06:34:35 <lambdabot>  29
06:35:06 <ne2k> merijn, do you have to use let ... in ... to do anything with the bot?
06:35:10 <Solonarv> you need to surround them in () to give the type signature, but really the important part s that their name is made of punctuation symbols ( <>=-+ and so on) instead of letters+numbers+_
06:35:19 <merijn> ne2k: You can directly define things in the bot, no
06:35:37 <ne2k> merijn, can't?
06:35:41 <Solonarv> ne2k: let ... in ... is just convenient so you don't clutter the namespace
06:35:46 <merijn> ne2k: Eh, can't, yeah
06:36:02 <Solonarv> actually you can
06:36:12 <ne2k> > let (bomb) x y = x * x + y * y in 2 bomb 5 
06:36:14 <lambdabot>  error:
06:36:14 <lambdabot>      • Could not deduce (Num a0)
06:36:14 <lambdabot>        from the context: (Num a, Num t, Num ((a -> a -> a) -> t -> t1))
06:36:17 <Solonarv> @let frobnizicate = "hello"
06:36:19 <lambdabot>  Defined.
06:36:21 <merijn> ne2k: Also, wrapping with () isn't sufficient operators can only consist of operator characters (so all the usual ASCII suspect and any unicode symbol that is a symbol)
06:36:22 <Solonarv> > frobnizicate
06:36:25 <lambdabot>  "hello"
06:36:34 <merijn> > generalCategory '☃'
06:36:36 <lambdabot>  OtherSymbol
06:36:44 <merijn> Unicode snowman is a symbol and thus allowed
06:37:29 <merijn> > filter (\c -> generalCategory c == OtherSymbol) . take 256 $ ['\0'..]
06:37:31 <lambdabot>  "\166\169\174\176"
06:37:36 <merijn> oh, helpful...
06:37:46 <merijn> > text . filter (\c -> generalCategory c == OtherSymbol) . take 256 $ ['\0'..]
06:37:47 <lambdabot>  ¦©®°
06:37:59 <merijn> What was the other operator category, then?
06:38:04 <merijn> > generalCategory '+'
06:38:06 <lambdabot>  MathSymbol
06:38:08 <merijn> ah
06:38:34 <merijn> > text . filter (Data.Char.isSymbol) . take 256 $ ['\0'..]
06:38:36 <ne2k> I have ghc installed on linux, is the Prelude available to browse as a file somewhere? /usr/lib/ghc has a load of random-named cack in it
06:38:37 <lambdabot>  $+<=>^`|~¢£¤¥¦¨©¬®¯°±´¸×÷
06:38:49 <merijn> ne2k: hackage has docs for the prelude
06:38:53 <Solonarv> it should be *somewhere*, yes
06:38:58 <Solonarv> but I don't remember where
06:39:02 <merijn> ne2k: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html
06:39:26 <Solonarv> you can also browse the source code, but be aware that most things exported from the Prelude aren't defined there
06:39:28 <merijn> ne2k: It should be local too, but no clue where ;)
06:39:57 <ne2k> merijn, sorry for all the noob questions. I have GHCi 7.10.3, is this current(ish)?I preusme i got it from Ubuntu. what is the verson 4.12.0 in the doc you linked?
06:40:24 <Solonarv> no, it is quite old
06:40:29 <merijn> ne2k: Anyway, to rewind to your original question <- and do notation are indeed syntactic sugar, which turns into combinations of >>= and >> (which are just regular functions, albeit from a specific typeclass)
06:40:49 <Solonarv> 4.12 is the version of the 'base' library; it is tied directly to the GHC version
06:40:52 <merijn> ne2k: 4.12 is the version of "base" (i.e. the standard lib shipping with GHC)
06:40:58 <Solonarv> base-4.12 corresponds to ghc-8.6
06:41:15 <merijn> ne2k: GHC 7.10 has base 4.8, but 7.10 is also quite old
06:41:35 <ne2k> please tell me it's a coindicence that base-x.y maps to ghc-x*2.y/2
06:41:40 <merijn> ne2k: hvr maintains a PPA for Ubuntu with more recent GHC versions: https://launchpad.net/~hvr/+archive/ubuntu/ghc
06:41:44 <merijn> ne2k: Yes :p
06:41:52 <merijn> ne2k: https://wiki.haskell.org/Base_package
06:42:01 <Solonarv> you can also use ghcup if you would prefer for everything to live in your home directory:
06:42:03 <Solonarv> @where ghcup
06:42:04 <lambdabot> https://www.haskell.org/ghcup/
06:48:49 <ne2k> > generalCategory '.'
06:48:51 <lambdabot>  OtherPunctuation
06:49:19 <merijn> ne2k: The exact rules are given here: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
06:49:36 <dminuoso> merijn: By the way, turns out GHC 8.6 has an old unicod database. Emojis work just fine in 8.8.1 :)
06:49:36 <dminuoso> So you were right.
06:50:23 <merijn> dminuoso: Whoo!
06:50:45 <ne2k> what is . ?
06:50:56 <dminuoso> ne2k: It too is an operator, so its a function.
06:51:03 <dminuoso> :t (.)
06:51:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:51:38 <dminuoso> Like any operator, it takes two arguments - which need to be functions of type `b -> c` and `a -> b` respectively, and it returns a function of type `a -> c`
06:51:40 <merijn> ne2k: Somewhere slightly up you'll see that operators are defined as "ASCII operator OR unicode operator" with ascii operators explicitly defined as one of: ! # $ % & ⋆ + . / < = > ? @ \ ^ | - ~ :
06:51:54 <dminuoso> Oh shoot
06:51:58 <dminuoso> nvm me
06:53:10 <merijn> dminuoso: "like any operator it takes two arguments" <- operators are not restricted to that, although (admittedly) writing valid expression with operators that take more arguments becomes awkward :p
06:53:31 <ne2k> dminuoso, is it customary when discussing Haskell functions to say that they can have multiple parameters? (because afaik, a -> a -> a means it takes an a and returns a function that takes an a and returns an a)
06:53:38 <ne2k> i.e. currying
06:54:00 <merijn> ne2k: Yeah, people often handwave their definitions and talk about "taking 3 arguments"
06:54:12 <Solonarv_> yes, it's a useful verbal and mental shortcut
06:54:28 <merijn> ne2k: Which, if we're pedantic, is nonsense, but it turns out that it's a useful shortcut for non-robots ;)
06:55:07 <Solonarv_> well, turns out GHC cares about this too for optimization reasons :P
06:55:46 <merijn> Completely unrelated question
06:56:04 <merijn> Is there a less ugly way of writing "fmap (>>=f)"?
06:58:37 <Solonarv_> :t \f -> fmap (>>=f)
06:58:38 <lambdabot> (Monad m, Functor f) => (a -> m b) -> f (m a) -> f (m b)
06:59:28 <Solonarv_> hm, can't think of one
06:59:44 <Solonarv_> maybe I slightly prefer fmap (f =<<) in some situations
07:00:34 * ski prefers `filter (n >)' over `filter (< n)'
07:00:47 <ski>   (f =<<) <$> ...  -- ?
07:01:30 <ski> @type (<$>) . (=<<)
07:01:30 <sshine> ski, makes sense.
07:01:31 <lambdabot> (Monad m, Functor f) => (a -> m b) -> f (m a) -> f (m b)
07:01:54 <ski> merijn : is this related to that `Parser (T -> IO U)' stuff ?
07:02:07 <merijn> ski: No
07:02:23 * ski was thinking about that, today
07:02:28 <shapr> this is strangly on topic: http://dirk.rave.org/combinatris/
07:02:37 <shapr> ski: ski combinator tetris!
07:02:37 <merijn> ski: Well, maybe it is too, but that wasn't my actual issue now ;)
07:02:59 <ski> haha, shapr ! :D
07:03:02 <merijn> ski: That idea is shelved for later, since "the option parser is ugly" is not on the critical path for finishing my thesis ;)
07:03:14 * ski boings up and down on chair
07:04:19 <ski> okay, merijn
07:08:56 <ne2k> Solonarv_, what does the \f here mean? :t \f -> fmap (>>=f)
07:09:11 <ne2k> and the -> for that matter
07:09:44 <merijn> ne2k: \ -> is lambda syntax
07:09:48 <Solonarv_> that's the syntax for lambda ( \ was chosen as a symbol because it looks sort of like a lambda, if you cut off the "leg")
07:10:06 <merijn> ne2k: In, for example, python "\f -> foo f" would be "lambda f: foo(f)"
07:10:17 <merijn> :t \x -> x
07:10:19 <lambdabot> p -> p
07:10:22 <merijn> :t \x -> even x
07:10:23 <lambdabot> Integral a => a -> Bool
07:11:47 <ne2k> how is => read? it specifies types classes in a definition, it seems, but is there a way to pronounce it?
07:12:46 <Solonarv_> I usually read those type signatures by inserting the normally-implicit forall
07:12:54 <ski> "implies", maybe ?
07:13:04 <Solonarv_> so that type becomes "for all a, given Integral a, a to Bool"
07:13:15 <merijn> ne2k: I recommend beginners treat it as "If". i.e. "foo :: Num x => x -> Bool" is "IFF type 'x' is an instance of Num THEN foo :: x -> Bool ELSE type error"
07:13:40 <ne2k> and is forall a keyword?
07:13:43 * ski would just skip the else part
07:13:54 <merijn> ski: I used to do that, but it confuses people
07:13:56 <ski> ne2k : `forall' is a keyword, in a language extension
07:14:11 <ski> merijn : then they need to get that confusion corrected, imho
07:14:13 <merijn> See, this is why I don't explain using forall ;)
07:14:29 <merijn> ski: But unsatisfied constraints *are* a type error
07:15:08 <ski> yea, but i think it's better for them to get more used to implications, rather than conflating them with conditionals
07:15:26 <ski> one doesn't have to say "everything"
07:16:10 <merijn> ski: What's the difference between a conditional and an implication?
07:16:59 <merijn> Hell, can you name any scenario where the conditional leads to a wrong intuition...because I can't really think of one
07:18:43 <ski> `if foo then bar else baz' is a conditional. `Foo -> Bar' is an implication
07:20:35 <ski> conditional expresses what happens/results, both in case `foo' holds, and in case it fails
07:20:48 <ski> implication only speaks about the first part
07:21:27 <merijn> But that's not an example of the former intuition going wrong
07:22:53 <ski> people are often not that used to reasoning about implications. and especially if they've already seen programming before, they may immediately associate "if" with conditionals. i want them to get some more practice with implications
07:25:19 <merijn> ski: Then your goal is directly opposed to my goal :p
07:25:30 <lyxia> In the present context of type class constraints, the difference is nullified by the fact that instance search doesn't backtrack, or that overlap is not allowed/restricted.
07:25:33 <ski> hehe, okay :)
07:25:43 <merijn> My goal is to give people the "best" (i.e. least wrong) intuition for the smallest amount of effort
07:26:04 <merijn> Considering I can't really think of a case where the "if/then/else" intuition goes wrong, I think it satisfies that goal
07:26:25 <ski> "best", for the present place in their learning, or also considering likely continued travelling ?
07:26:57 <ski> i'm not even sure what you mean by "intuition goes wrong". i just think they're different things, both important, shouldn't be conflated
07:27:26 <merijn> ski: I think they're only different on the meta level
07:27:57 <ski> conditionals tend to be used causally. implications can be anti-causal
07:28:25 <ski> (reasoning from consequences to causes)
07:29:15 <merijn> ski: Perhaps, but that's the kinda thing you don't encounter that quickly when trying to learn Haskell and by the time you *do* encounter it, it's already reasonably self-explanatory
07:31:27 <ski> i don't really want them to associate "=>" with "if-then-else"
07:40:53 <rain1> hey
07:40:59 <rain1> what are the best haskell and related blogs?
07:41:59 <rain1> is  the monad reader finished?
07:42:42 <phaazon_> I highly recommend typeclasses.com
07:42:55 <texasmynsted> rain1: You could read through something like https://haskellweekly.news/newsletter.html
07:43:04 <texasmynsted> and find blogs that way.
07:43:19 <phaazon> if you have a better idea about what you are looking for
07:43:33 <phaazon> you should also have a look at Gabriel Gonzales blog posts (they’re ace)
07:43:34 <rain1> thanks
07:44:23 <texasmynsted> typeclasses.com :-) Julie and Chris have good stuff.
07:45:08 <phaazon> damn yes
07:45:08 <texasmynsted> The good thing about the newsletter is you can find articles that interest you and discover blogs.
07:47:12 <texasmynsted> just search through the archives
07:51:12 <texasmynsted> rain1: If you like vlogs, check out https://haskell-at-work.com/
07:52:19 <texasmynsted> Oskar has not put out a video in a while. I suppose he is busy "at-work".
07:56:45 <boxscape> we wouldn't need let-polymorphism if it weren't for type inference, right?
07:58:34 <merijn> I also scan /r/haskell every day, interesting thing usually end up there eventually
07:58:52 <merijn> rain1: The haskell-cafe mailing list is also quite nice
08:06:22 <Athas> boxscape: I'm not sure I follow.
08:06:53 <Athas> I think you can technically have let-polymorphism without type inference, but I don't know of any such language.
08:07:19 <mac10688> Anyone know how to extend a sum type with another sum type. E.g. data Test1 = No | Way; data Test2 = Yes | Test1; ?
08:07:27 <boxscape> Athas I'm wondering if the reason we *need* it is because we want type inference - it makes sense to me that we could still have it otherwise
08:08:29 <Athas> boxscape: if you didn't have let-polymorphism, you wouldn't have *any* polymorphism, would you?
08:08:45 <Athas> (Barring higher-ranked types; not sure where they fit in the taxonomy.)
08:09:03 <mac10688> I need to get ready for work so I'll be afk for a few minutes in case someone answers or asks questions while I'm afk
08:09:05 <boxscape> I was about to give a rank-2 example :)
08:09:19 <texasmynsted> Darn now I am distracted with computerphile. Graham Hutton's explanations are outstanding.
08:10:29 <Athas> let-polymorphism is just about being allowed to insert the 'forall's.  If you have an even more flexible mechanism for inserting the 'forall's, you don't need let-polymorphism.  Or rather, let-polymorphism is just a special case of that more general mechanism.
08:10:48 <texasmynsted> grrr then it will be numberphile and the day will be shot.
08:10:56 <boxscape> Athas System F has foralls without let-polymorphism but I'd have to think for a bit how that relates to rank n types
08:11:04 <Athas> I guess maybe you could have an exotic type systemwhere *only* rank>1 types are allowed.  Not sure what that would look like.
08:11:26 <Athas> boxscape: but isn't let-polymorphism just about permitting 'forall' outermost at let-bindings, and nowhere else?
08:11:55 <Athas> I.e. it's a subset of what System F allows.
08:12:04 <boxscape> afaik, yes
08:14:07 <remexre> is there a fixed-length vector-like type of kind Vec :: Nat -> (Nat -> *) -> *, such that e.g. Vec 3 f is isomorphic to (f 2, f 1, f 0)?
08:18:21 <merijn> remexre: There's a sized wrapper around regular vector, but I don't think that quite matches your description?
08:18:44 <remexre> merijn: right, my elements' types depend on their index
08:19:46 <remexre> I usually call this an IDVec (index-dependent) in Idris, but hadn't seen a canonical name for it there, either
08:20:24 <merijn> Sounds like a good way to nerd snipe your own productivity in Haskell :p
08:20:25 <lyxia> remexre: vinyl and sop-core sound relevant.
08:20:51 <remexre> merijn: I promise they're actually useful!
08:20:55 <remexre> lyxia: I'll take a look, thanks
08:21:03 <merijn> remexre: Oh, I'm not saying they're not useful
08:21:27 <merijn> remexre: The question is: "Does their usefulness outweight the amount of Hasochism you need to inflict on yourself?"
08:22:19 <remexre> merijn: heh, in the particular narrow case I'm in, I think so; on the other hand, if Idris had fewer compiler bugs, this wouldn't be a Haskell project /shrug
08:24:05 <lortabac> remexre: have you considered Agda?
08:24:29 <remexre> lortabac: taking a class on it currently, actually; I'm not familiar enough with it to recommend it for a work project, though
08:24:44 <berndl> Agda is awesome... most of the time.
08:26:43 <Rembane> Proof by auto <3 
08:28:01 <boxscape> I realize that the type system doesn't let you use them quite as freely, but am I right in thinking that the S and K combinators are basically <*> and pure for Reader?
08:28:53 <remexre> lyxia: oh, sop-core looks awesome! even if it doesn't have this construct, there's a mess of generic code that I think can be wholly replaced by this
09:05:39 <Cheery> trying to build a functor from (Functor f) => f (Complex a) -> Complex (f a)
09:06:01 <Cheery> I wonder how that'd go.
09:07:23 * hackage hpc-codecov 0.1.0.0 - Generate codecov report from hpc data  https://hackage.haskell.org/package/hpc-codecov-0.1.0.0 (AtsuroHoshino)
09:07:38 <Cheery> Does that mean I should have a way to convert f (Complex a) -> f (Complex b) to Complex (f a) -> Complex (f b) ?
09:23:10 <stevenxl> Hi folks. 
09:23:25 <stevenxl> I am trying to enable TypeApplications in the ghci repl but I get an error
09:23:42 <Taneb> stevenxl: how are you trying to enable it?
09:23:44 <Taneb> ghci
09:24:10 <stevenxl> https://usercontent.irccloud-cdn.com/file/Byk1qDCu/Screen%20Shot%202020-02-07%20at%2011.23.24%20AM.png
09:24:24 <geekosaur> uppercase X
09:24:26 <Taneb> stevenxl: you need a capital X
09:24:36 <stevenxl> thank you geekosaur and Taneb 
09:24:53 * hackage raven-haskell 0.1.4.0 - Haskell client for Sentry logging service.  https://hackage.haskell.org/package/raven-haskell-0.1.4.0 (AlexanderBondarenko)
09:30:30 <ooo_miguel> How am I supposed to use MonadFail. I can call fail in any Monad it seems
09:30:34 <ooo_miguel> ?
09:31:07 <glguy> ooo_miguel: What version of GHC are you using?
09:31:34 <ooo_miguel> 8.6.5
09:33:39 <happycoder> hi I just discovered that instead of passing the type witness singleton explicitly, or using typeclasses to make it kinda implicit, we can also store it in the data type itself: https://gist.github.com/happycoder97/fef27541180e5482df0135d70df7684f
09:36:38 <happycoder> my original question was how to convert type level things to term level and vice versa. It seems I can keep both type level and term level information separately and have the compiler ensure they are consistent :)
09:37:28 <stevenxl> ooo_miguel: You can fail in any monad that is an instance of MonadFail. What it means to fail depends on the monad itself. For example, in the concrete case where your monad is a Maybe, then failing just reduces to Nothing.
09:37:58 <stevenxl> in ghci, you can try "Control.Monad.Fail.fail "Hello" :: Maybe Int"
09:38:12 <stevenxl> and you will see that that expression just evaluates to a value "Nothing" of type "Maybe Int"
09:38:22 <ooo_miguel> yeah but why can I fail in a function with the siganature: testFail :: (Monad m) => m () 
09:38:49 <ooo_miguel> I assumed this should not work, since it is not guaranteed that m is an instance of MonadFail
09:39:01 <stevenxl> ooo_miguel: You are likely using Prelude.fail
09:39:07 <stevenxl> Not Control.Monad.Fail.fail
09:39:42 <ooo_miguel> aaah, ok yeah guess this is the problem, thank you stevenxl!!
09:40:11 <stevenxl> ooo_miguel:  No problem. And just to be explicity, fail is a method of the Monad typeclass.
09:40:38 <stevenxl> It is considered bad practice to use it, because most of the time it is just an exception
09:55:57 <unclechu> hi. can i somehow expand type aliases when i use `:i` inside a `ghci` repl?
09:56:44 <happycoder> Why does this give stackoverflow? https://gist.github.com/happycoder97/e0f6adfad0e238cd21859dda0931b605
09:58:38 <unclechu> i have complex servant api like this one: `type FooAPI = BarAPI :<|> BazAPI; type BarAPI = "bar" :> Get '[JSON] (); type BazAPI = "baz" :> Get '[JSON] ()`
09:58:49 <happycoder> nvm, I put `instance Show` instead of `deriving instance Show`
09:59:07 <unclechu> i want to expand `BarAPI` and `BazAPI` when i do `:i FooAPI`, is it possible?
10:09:41 <alp> unclechu, have you tried :kind! FooAPI ?
10:10:47 <unclechu> alp: how is it supposed to help? kind of a servant api is just `*` or `Type`
10:11:36 <unclechu> alp: i just tried, it returns `FooAPI :: * = FooAPI`
10:19:39 <alp> unclechu, sometimes it does reduce things a bit, IIRC. anyway, I wrote a GHC proposal for this, but never got around to implementing it so far https://github.com/ghc-proposals/ghc-proposals/pull/79
10:26:45 <unclechu> alp: what reduces things? `:kind`? but i don't need to reduce, i kind of need to get result as verbose as possible
10:36:11 <lyxia> unclechu: "kind!" with the bang should normalize your type
10:37:33 <nshepperd2> i vaguely remember there being a bug where that didn't work for type synonyms
10:39:07 <lyxia> that seems to be what the link just above is about
10:43:53 * hackage persistent-template 2.8.2.2 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.2.2 (parsonsmatt)
11:02:24 * hackage git-brunch 1.1.2.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.1.2.0 (andys8)
11:05:48 * eslo sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/qSIeIZVBpQeUJzAaNqzZmhAh >
11:05:51 <eslo> Am I just doing something simple wrong?
11:08:28 * eslo sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/IVpuvTqqfhEMbfMCftUPnYTE >
11:09:12 <glguy> eslo: type synonyms (things introduced with the 'type' keyword) don't get instances. You'll need to write an instance for all Fix types along with a helper class that Numeric' could be an instance of
11:09:43 <glguy> That class could be http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Classes.html#t:Show1
11:16:05 <eslo> Do I need to do something similar if I want to derive Functor and Foldable as well?
11:16:07 <prog52> can anyone tell why these types are ambiguous? https://pastebin.com/raw/Zq3RM1nN
11:17:58 <eslo> One of the points why I was introduced to Fix was becasue deriving type classes was supposed to be easier, but I currently don't seem to recall how.
11:20:16 <glguy> eslo: Fix can't be a Functor or a Foldable
11:20:25 <glguy> It's got the wrong kind for that
11:23:22 <prog52> ok nvm, this works
11:23:23 <prog52> https://pastebin.com/raw/DCJvJKc9
11:23:47 <prog52> not sure about using classes to recurse of SNat's thought
11:23:51 <prog52> as in UpdatePlayer
11:24:01 <prog52> is there a better way of doing that?
11:24:51 <prog52> it ends up giving many constraints which all should be satisfied since the instances are provided...
11:29:50 <prog52> there was an undefined in the previous paste, this one is complete; https://pastebin.com/raw/FbLR1REi
11:30:02 <prog52> (no test yet though)
11:30:33 <prog52> it has the same idea with recursive classes for "payerAt"
11:31:13 <prog52> only reason it seems necessary is because the recursion over the descending SNat is a call to the same function but with a different type
11:31:23 <prog52> i guess its the only way then...
11:32:02 <prog52> but the "PlayerAt n ps" constraint cant be removed, despite all the cases being covered...
11:32:16 <prog52> in "takeTurn"
11:32:39 <jle`> prog52: you shouldn't need to do the recursion
11:32:47 <jle`> you can write it as a normal function, not in a typeclass
11:32:55 <jle`> and make it a polymorphic function
11:33:00 <prog52> hmm
11:33:05 <jle`> updatePlayer :: SNat (n :: Nat) -> s -> Multiplayer ps -> Multiplayer ps 
11:33:14 <jle`> er, you shouldn't need to do the recursive typeclass instance
11:33:19 <jle`> you can just use normal recursion as a normal function
11:33:35 <jle`> since that type signature is already polymorphic
11:34:12 <jle`> prog52: the base case would be matching on n %~ SNat @0
11:34:29 <jle`> that's the point of using singletons -- so you can branch on what the type is, without needing typeclass stuff
11:34:46 <jle`> updatePlayer n = case n %~ SNat @0 of
11:34:52 <comerijn> This sounds like code that should be written in Idris :p
11:35:00 <jle`>   Proved Refl ->   -- .. in this branch, n ~ 0
11:35:11 <jle`>   Disproved _ ->  -- in this branch, we don't have that n ~ 0, so it's not 0
11:35:13 <prog52> aha
11:35:23 <prog52> i was getting an error; Eq (SNat n)) arising from the literal `0' * In the pattern: 0
11:35:46 <jle`> prog52: yeah, you have to do a dependent match (like on Refl) to get the proof in scope
11:35:48 <prog52> I hadnt seen this %~ before
11:35:59 <jle`> prog52: it's an equality test
11:36:06 <jle`> merijn: i won't argue too much there :)
11:36:14 <jle`> merijn: the only problem with doing it in idris is it's hard to call out to existing haskell libraries
11:36:27 <MarcelineVQ> jle`: agda then :>
11:37:07 <MarcelineVQ> though if you give your haskell lib a c inteface idris shouldn't have much trouble
11:37:09 <jle`> prog52: https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons-Decide.html
11:37:25 <jle`> MarcelineVQ: not hard for idris. hard for you :p
11:37:27 <prog52> thanks
11:38:25 <jle`> prog52: with other singletons you can just pattern match on like STrue or SNil or something, it's just for SNat there isn't a pattern you can match on for the different values
11:38:39 <jle`> unfortunately
11:38:45 <jle`> so %~ is the only way
11:39:05 <jle`> note that you can also use %~ for other singletons as well, it's just that we like to pattern match when we can, to avoid 'decidable blindness'
11:39:35 <prog52> normally I write my own Nat and SNat
11:39:42 <prog52> and wouldnt have this problem
11:40:01 <jle`> yeah, in that case you'd have actual constructors/patterns you can match on
11:40:24 <prog52> still, guess its better to learn the "proper" way...
11:41:17 <jle`> i don't think there is anything wrong with ousing your own Nat and SNat. i use it myself in a lot of situations, i call it N and SN to avoid ambiguity
11:41:24 <jle`> it's good if you want to do structural/inductive proofs
11:41:45 <jle`> the only reason you would ever use Nat/SNat from GHC.TypeLits is if you don't care about doing those sort of proofs
11:41:52 <prog52> hmm, maybe i was just being lazy trying to use the singletons lib, i dont really like TH
11:42:13 <jle`> basically if you want to treat every Nat as completely separate, not related inductively
11:42:17 <jle`> then you would use GHC.TypeLits
11:42:22 <jle`> in any other case they are the wrong tool
11:42:24 <prog52> ah, more like Strings
11:42:37 <jle`> like Text/symbols, yeah
11:43:07 <prog52> the only thing is then I end up with 2 different Nats depending on if I use '[()] or 'Nonempty ()
11:43:19 <prog52> for indexing over HList or HNonempty
11:43:35 <jle`> well don't you want two different index types?
11:43:40 <prog52> and I wasnt sure if I should have the multiplayer game being nonempty...
11:44:28 <prog52> jle` : I tend to trust that the compiler makes good things happen for a reason, so I guess its better to have two
11:45:14 <prog52> but I would have to locate old code from the depths of a disorganized mess 
11:45:23 <prog52> so I thought id try the version on Hackage
11:45:44 <prog52> I guess one day I might put something on Hackage to make it easier 
12:10:03 * eslo sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/nIOTFydwrRiBUersmOMVAbIC >
12:20:00 <MarcelineVQ> eslo: matrix does this super annoying thing where it'll just stick a link to a paste containing your message instead of sending your message if it's too long
12:20:14 <MarcelineVQ> so glguy probably doesn't know you're talking to him
12:20:54 <eslo> aa ok. That was not at all apparent from my end
12:21:18 <MarcelineVQ> yeah it's really lame, all people see is:  * eslo sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/nIOTFydwrRiBUersmOMVAbIC >
12:22:08 <iptq> yikes
12:22:10 <MarcelineVQ> if they're on a matrix client it might exapand that for them, dunno though
12:23:23 * hackage Color 0.1.3 - Color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.1.3 (lehins)
12:23:31 <eslo> well his name was mentioned so He might receive a notification already. And I don't really need a response this time. I just said that because it maybe clears things up for him about what I meant.
12:24:56 <geekosaur> it was mentioned inside the link. he'd need a client that auto-opened such links
12:25:14 <geekosaur> auto-open tends to be a bad idea on IRC
12:25:32 <MarcelineVQ> geekosaur: eslo probably means because I mentioned glguy
12:25:51 <eslo> I meant Marceline Mentioned him.
12:25:54 <eslo> yeah
12:26:27 <solonarv> I really wish the matrix bridge didn't just silently do that, tbh - it could maybe display a warning, or at least include the start of the long messag
12:26:29 <merijn> geekosaur: The glorious age of goatse and similar on IRC >.> Old school rickroll, but grosser >.>
12:47:23 * hackage tree-sitter 0.9.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.9.0.0 (aymannadeem)
12:51:53 * hackage tree-sitter-python 0.9.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.9.0.0 (aymannadeem)
12:55:14 <djanatyn_> are there any good resources to help understand the distinction between the Functor typeclass and the Traversable typeclass? i see Functor introduced as something that can be mapped over, and Traversable introduced as something that can be walked across
12:55:43 <merijn> djanatyn_: Traversable lets you *effectfully* walk across something
12:55:48 <merijn> :t traverse
12:55:50 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:55:53 * hackage tree-sitter-ruby 0.5.0.0 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.5.0.0 (aymannadeem)
12:56:07 <djanatyn_> i understand that the difference can be understood solely in terms of the typeclasses themselves (not all Functors are Applicative, for example), but I see a lot of Haskell programmers talk about this experience of realizing "aha! it was just traverse all along!" and I don't think I get that experience
12:56:21 <merijn> djanatyn_: So given a function returning an Applicative, you walk the Traversable collecting the Applicative effects
12:56:51 <merijn> djanatyn_: Consider the simplest case of "print"
12:56:52 <merijn> :t print
12:56:54 <lambdabot> Show a => a -> IO ()
12:57:16 <merijn> djanatyn_: If I do "fmap print" I get "something with an IO action in it"
12:57:27 <merijn> :t fmap print `asAppliedTo` []
12:57:28 <lambdabot> Show a => [a] -> [IO ()]
12:57:43 <merijn> Now, consider traverse
12:57:50 <djanatyn_> mhmm, following so far
12:57:50 <merijn> :t traverse print `asAppliedTo` []
12:57:52 <lambdabot> Show a => [a] -> IO [()]
12:58:15 <merijn> djanatyn_: Do you know/see the use of mapM?
12:58:27 <djanatyn_> yeah, i use it frequently
12:58:30 <merijn> (as opposed to map)
12:58:45 <merijn> djanatyn_: traverse is equivalent to a generalised mapM :)
12:58:47 <merijn> :t mapM
12:58:49 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:58:50 <merijn> :t traverse
12:58:52 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:59:02 <djanatyn_> this helps, thank you
12:59:15 <merijn> djanatyn_: Note that nowadays mapM is actually using Traversable (instead of only working for lists like in the past)
13:00:27 <merijn> djanatyn_: So Traversable basically says "you can map an effectful function over me, gathering up the effects and getting back a new Traversable" (like lists, Map's, etc.) as opposed to Functor which just says "you can map a function over me (but not necessarily gather up the effects)
13:00:52 <djanatyn_> yeah, i realize now that i've been using fmap and doing some ugly things to gather up the effects
13:01:42 <djanatyn_> i often end up with a function returning [IO a] and there's this constant feeling i've done something wrong, but it's hard to identify where
13:01:47 <merijn> djanatyn_: Notice that Traversable has Functor as a superclass, so everything Traversable *must* also be a Functor (although, I can't think of a non-Traversable Functor of the top of my head)
13:01:50 <eslo> I made this example about traversible a while ago for myself
13:01:52 * eslo sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/NlutmjTXVekYVPoSHSQAxbCK >
13:01:53 <djanatyn_> usually i end up switching to mapM in that case
13:02:30 <merijn> djanatyn_: Often you want that, yeah. Although the ability to store IO actions in data structures is actually one of my favourite things about IO :>
13:03:08 <merijn> I'm sure someone who has had less beer can probably come up with a non-Traversable functor :p
13:05:25 <merijn> Ooh..parsers, maybe?
13:06:08 <merijn> None of them seem to have Traversable instances and that'd make sense when looking at the type of traverse
13:06:39 <merijn> I'm not entirely sure, though
13:06:43 <phadej> IO is non-traversable Functor
13:07:23 <merijn> For the same reason as Parser, I suppose. They're kinda similar in that regard
13:07:25 <glguy> Functions
13:07:45 <phadej> they are less often used with `Functor` interface
13:08:00 <phadej> fmap:ing over IO is however quite common
13:08:37 <merijn> djanatyn_: Anyway, those are two good examples to ponder what traverse/mapM would even mean: IO and Parsers
13:09:14 <djanatyn_> yeah, i'll think on it! thank you :)
13:10:23 * hackage tree-sitter-python 0.9.0.1 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.9.0.1 (aymannadeem)
13:12:31 <phadej> don't think that "Functor is type-class for containers"; it's more abstract than that
13:13:06 <solonarv> Traversable is closer to a "type class for containers", really
13:13:53 <solonarv> I think Traversable ends up being some sort of polynomial functor thingy
13:15:32 <djanatyn_> phadej: yeah, i think that distinction dissolved for me when i saw that ((->) r) was a Functor
13:15:55 <djanatyn_> finally got a grap on contravariant functors when i started using the colog library :)
13:16:08 <djanatyn_> and also just defining Predicate types
13:19:08 <solonarv> yeah, contravariant functors all look the same in Haskell
13:24:23 * hackage tree-sitter-ruby 0.5.0.1 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.5.0.1 (aymannadeem)
13:25:24 * hackage Color 0.1.3.1 - Color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.1.3.1 (lehins)
13:28:23 <tabaqui1> uhm
13:28:35 <tabaqui1> getPOSIXTime returns local posix time, right?
13:28:57 <tabaqui1> and posixSecondsToUTCTime is a pure function that converts POSIX time to UTCTime?
13:29:30 <tabaqui1> and how in the hell I see universal time when I call "posixSecondsToUTCTime <$> getPOSIXTime"?
13:30:06 <tabaqui1> I don't see sufficient unsafe calls, but it knows my time zone
13:30:26 <dsal> getPOSIXTime :: IO POSIXTime    -- there's no "local" concept here.  It's just time.
13:30:38 <merijn> tabaqui1: POSIX time is timezone free, so local is a nonsensical concept
13:31:40 <merijn> incidentally, UTC time is *also* timezone free (or rather, it's in the UTC timezone) so why would it need unsafe calls to know your timezone?
13:32:15 <tabaqui1> I dunno, it seems to me that getPOSIXTime returns seconds in my local time zone
13:32:39 <tabaqui1> I mean, that it is hours ahead of your getPOSIXTime return value
13:32:54 <merijn> tabaqui1: posix time is always relative to UTC
13:33:15 <tabaqui1> % getPOSIXTime
13:33:15 <merijn> So if you're not in UTC and getting back your local time, then it sounds like your system clock is wrong
13:33:15 <yahb> tabaqui1: ; <interactive>:37:1: error: Variable not in scope: getPOSIXTime
13:33:25 <tabaqui1> % import Data.Time.Clock.POSIX
13:33:25 <yahb> tabaqui1: 
13:33:28 <tabaqui1> % getPOSIXTime
13:33:29 <yahb> tabaqui1: 1581111187.014717254s
13:34:10 <tabaqui1> I want to convert some timestamp generated by Python script
13:34:45 <tabaqui1> and somehow the Python timestamp is 3 hours behind of my getPOSIXTime (I'm in UTC +3 now)
13:35:32 <Clint> you want to convert a UTC timestamp to what?
13:35:55 <merijn> tabaqui1: POSIX time is seconds since the epoch (in UTC)
13:36:08 <tabaqui1> datetime.utcnow().timestamp() -> Data.Time.Clock.UTCTime
13:36:18 <tabaqui1> Int -> UTCTime, basically
13:37:04 <tabaqui1> allright, it seems, that Python freaks here
13:37:17 <geekosaur> python's using local time, POSIX time is UTC
13:39:30 <tabaqui1> don't get it still:
13:39:47 <tabaqui1> "$ date +%s" = 1581111513
13:39:56 <tabaqui1> (posix universal time)
13:39:59 <geekosaur> yes, now try it with -u and see you get the same thing
13:40:14 <tabaqui1> "python datetime.utcnow().timestamp() = 1581100720"
13:40:16 <geekosaur> because %s forces UTC (read its description carefully)
13:40:25 <tabaqui1> ~3 Hours behind
13:40:53 <tabaqui1> "$ date +%s -u" ~=1581111513
13:41:01 <tabaqui1> nothing changed
13:41:19 <geekosaur> right because %s is always in utc
13:41:25 <tabaqui1> right
13:41:42 <geekosaur> although, if python is 3 hours behind utc then it sounds like it's doing its date math wrong
13:41:53 <geekosaur> or incorrectly assuming utc on a local time value
13:41:56 <tabaqui1> I just don't understand how Python could even return something 3 Hours behind UTC time, if I'm living in East Europe
13:42:26 <geekosaur> which bug is not uncommon
13:42:26 <tabaqui1> it should be equal or 3 hours ahead
13:43:20 <tabaqui1> ok, I'll go on #python now :)
13:43:21 <tabaqui1> thanks, guys
13:43:27 <geekosaur> so it's getting a local time, incorrectly assuming utc, and converting it to local time and losing 3 hours in the process
13:43:40 <geekosaur> which is probbly an application level bug, not python itself
13:44:03 <tabaqui1> it's just python -e "import datetime; datetime.utcnow().timestamp()"
13:44:31 <tabaqui1> *from datetime import datetime
13:44:54 <geekosaur> I'd check if the system clock is correctly in utc; sometimes it's not because of windows dual boot or etc.
13:45:18 <tabaqui1> ah, maybe, maybe
13:45:39 <Maxdamantus> I observe that behaviour in Python too.
13:45:53 * hackage tree-sitter-go 0.5.0.0 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.5.0.0 (aymannadeem)
13:45:56 <Maxdamantus> I suspect it's just a weird design in Python's datetime library.
13:46:00 <tabaqui1> did you hear that? I'm not crasy!
13:46:07 <tabaqui1> *z
13:46:08 <amalloy> the docs (https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp) say 
13:46:19 <amalloy> Naive datetime instances are assumed to represent local time
13:46:20 <geekosaur> neither of my pythons do -e fwiw
13:46:35 <Maxdamantus> because it looks like `datetime.datetime.utcnow()` returns a date without a timezone.
13:46:42 <geekosaur> (have both 2.7 and 3.6)
13:46:45 <amalloy> and utcnow says "Return the current UTC date and time, with tzinfo None. [...] as a naive datetime object"
13:46:59 <Maxdamantus> so when you interpret it again to turn it into a timestamp, it will interpret it as a local time.
13:47:13 <geekosaur> naive sounds like asking to treat it as local time, yeh.
13:47:17 <amalloy> datetime.now() says it is preferred over utcnow, because it cares about timezones
13:47:20 <geekosaur> untyped languages, feh :p
13:47:23 * hackage hs2ps 0.1.0.0 - Translate Haskell types to PureScript  https://hackage.haskell.org/package/hs2ps-0.1.0.0 (WilliamRusnack)
13:47:29 <Maxdamantus> I'm guessing it's just an old API that wasn't thought out very well.
13:47:33 <amalloy> geekosaur: the message before that explicitly says that naive means local
13:47:36 <tabaqui1> geekosaur: sorry, try "python -c"
13:47:52 * Maxdamantus isn't particularly familiar with Python.
13:49:23 * hackage tree-sitter-php 0.3.0.0 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.3.0.0 (aymannadeem)
13:50:40 <tabaqui1> hah, I see
13:51:12 <tabaqui1> datetime.timestamp() = dt - datetime(1970, 1, 1, tzino=timezone.utc)
13:51:25 <tabaqui1> and in case of utcnow().timestamp()
13:51:46 <tabaqui1> dt is UTC time, while the second value is computed in local timezone
13:51:53 * hackage tree-sitter-json 0.7.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.7.0.0 (aymannadeem)
13:52:07 <tabaqui1> 0 - (+3) = -3
13:52:46 <geekosaur> yep.more or less what I described, due to an unfortunate API decision
13:52:53 * hackage tree-sitter-java 0.7.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.7.0.0 (aymannadeem)
13:53:03 <tabaqui1> Maxdamantus, geekosaur: thanks
13:53:38 <Maxdamantus> If I were designing a date library, I would expect such an operation converting a "local time" (ie, a time like "2020-02-08 10:52") into a timestamp to require a timezone/region.
13:53:53 * hackage hs2ps 0.1.1.0 - Translate Haskell types to PureScript  https://hackage.haskell.org/package/hs2ps-0.1.1.0 (WilliamRusnack)
13:54:11 <geekosaur> the mistake is returning a UTC timestamp as a "naive" (local) timestamp
13:54:32 <Maxdamantus> I don't think that's necessarily an issue. It makes sense to have local timestamps.
13:54:38 <geekosaur> hence my snark about untyped
13:54:49 <Maxdamantus> The problem is that the conversion to an actual timestamp requires a timezone.
13:54:49 <geekosaur> sure. when they are, and not uutc in disguise
13:54:53 * hackage tree-sitter-typescript 0.5.0.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.5.0.0 (aymannadeem)
13:55:49 <Ethan> Does anyone ave any advice on how to deal with not in scope errors with code errors when trying to build a downloaded (unmodified) package from cabal?
13:56:01 <Maxdamantus> But that doesn't really relate to untypedness. It could just be an error to convert such a time (without a timezone) to a timestamp.
13:56:10 <Ethan> i get that error for a few different packages
13:56:19 <Maxdamantus> so `datetim.utcnow().timestamp()` should just throw an error
13:56:32 <Ethan> is my install broken or do people use stack instead of cabal?
13:57:20 <solonarv> Ethan: without seeing your exact error message (and what you tried to to), I don't know
13:57:23 * hackage tree-sitter-haskell 0.3.0.0 - Tree-sitter grammar/parser for Haskell (with GHC extensions)  https://hackage.haskell.org/package/tree-sitter-haskell-0.3.0.0 (aymannadeem)
13:58:00 <geekosaur> not in scope sometimes means you're using too new (or too old) ghc version, depending on the exact error
13:58:32 <Ethan> solonarv: when I try to go through the dollar tutorial (https://github.com/nboldi/haskell-tools/blob/master/documentation/development/tutorials/dollar-app.md) I need to install Refactor 
13:58:53 * hackage tree-sitter-tsx 0.5.0.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.5.0.0 (aymannadeem)
13:59:07 <Ethan> solonarv: I get the following error using cabal install haskell-tools-refactor
13:59:22 <Ethan> [ 1 of 21] Compiling Language.Haskell.Tools.BackendGHC.GHCUtils ( Language/Haskell/Tools/BackendGHC/GHCUtils.hs, dist/build/Language/Haskell/Tools/BackendGHC/GHCUtils.o )
13:59:24 <Ethan> Language/Haskell/Tools/BackendGHC/GHCUtils.hs:35:30: error:
13:59:25 <solonarv> if it's long, please use pastebin or something similar
13:59:25 <Ethan>     Not in scope: type constructor or class ‘XCFieldOcc’
13:59:27 <Ethan>     Perhaps you meant one of these:
13:59:28 <Ethan>       ‘FieldOcc’ (imported from GHC), ‘LFieldOcc’ (imported from GHC)
13:59:30 <Ethan>    |
13:59:31 <Ethan> 35 |   fieldOccToId :: RdrName -> XCFieldOcc name -> IdP name
13:59:33 <Ethan>    |                              ^^^^^^^^^^
13:59:39 <Ethan> well thats part of it, sorry i will do in the future
13:59:49 <gentauro> is there a `hPutOctet` or `hPutByte` in `base`? -> https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hPutChar
13:59:56 <Ethan> ill post all of it in pastpbin one sec
14:00:34 <geekosaur> relying on ghc internals is a good way to run into incompatibilities with different ghc versions\
14:00:56 <solonarv> yeah, my guess is someone's using GHC as a library and set too-loose version bounds on it
14:01:26 <Ethan> https://pastebin.com/Qw3kvwuU
14:01:53 <Ethan> ok so how would i rectify this? change ghc versions?
14:01:55 <geekosaur> gentauro, not as such. you need to hSetEncoding to binary, then hPutChar . chr
14:02:10 <solonarv> hm yup, seems like that's the problem
14:02:19 <Ethan> ok thank you all for the help!
14:02:24 <solonarv> you could perhaps try to find an older GHC version that this package still works with, sure
14:02:28 <dsal> That looks like the kind of thing that would be fairly ghc-specific.
14:02:34 <solonarv> but using an older GHC version has downsides, too
14:03:12 <solonarv> from most libraries, you can reasonably expect support for the latest 3 major GHC versions (as a common rule of thumb)
14:04:12 <solonarv> so you might end up stuck on an old snapshot of the Haskell ecosystem, so to speak
14:04:47 <Ethan> so i am using ghc-8.4.4 and it requires >+8.4 and <=8.7
14:04:52 <Ethan> how would i go back father?
14:04:59 <Ethan> or should i use a newer version?
14:05:11 <solonarv> "it" requires? what is "it"?
14:05:22 <Ethan> the package i am trying to install
14:05:27 <solonarv> hmm, that is odd
14:05:59 <gentauro> 23:01 < geekosaur> gentauro, not as such. you need to hSetEncoding to binary, then hPutChar . chr
14:06:02 <gentauro> thx
14:06:07 <Ethan> would using stack help to avoid this type of error?
14:06:38 <solonarv> perhaps it would build, sure
14:06:45 <dsal> If the project were built with stack, you might not have that problem.
14:07:14 <Ethan> ok, ill learn stack and try it
14:07:17 <solonarv> hmm, actually are you sure you linked the right repository?
14:07:44 <solonarv> the repository you linked appears to be a fork of the actual package and hasn't been touched in 2 years
14:07:58 <Ethan> hmm
14:08:26 <solonarv> oh, even odder
14:08:27 <dsal> It looks like it's a stack project already.
14:08:35 <dsal> fork of fork?
14:08:45 <solonarv> that is actually the official repository according to hackage
14:09:00 <solonarv> but a clearly newer version was uploaded about a year ago
14:09:34 * solonarv is very confused
14:09:39 <Ethan> so i go to (https://github.com/haskell-tools/haskell-tools) and click on the tutorials link which brings me to (https://github.com/haskell-tools/haskell-tools/blob/master/documentation/development/tutorials.md) and then i click on the Dollar application tutorial (https://github.com/haskell-tools/haskell-tools/blob/master/documentation/development/tutorials/dollar-app.md)
14:10:33 <solonarv> okay, I admit I have no idea what is going on. apparently the maintainership juggled around a bunch, I guess?
14:10:38 <d34df00d> Let's say I want to write a TH function that, given a name of an enumeration, say, `data Foo = A | B | C`, would create smth like `\case [A, B, C] -> bar @('A, 'B, 'C); [A, B] -> bar @('A, 'B); ...` — that is, for every subset of `[minBound .. maxBound]` of said enum call a function with the corresponding type.
14:10:46 <solonarv> it is not clear to me where the code on hackage even comes from
14:10:58 <d34df00d> Can TH's quasiquoters like [p||] and so on help me here, or do I literally have to construct the right Exp?
14:11:15 <Ethan> ok, should i open an issue of github about this?
14:11:35 <Ethan> or is this a problem on my end?
14:11:36 <solonarv> the thing I don't even know which github repo you should address that issue to
14:11:45 <solonarv> I guess you can try
14:11:54 <Ethan> ok fair enough
14:12:02 <Ethan> thank you for looking into it
14:15:21 <dsal> d34df00d: I generally find the qq useful for figuring out the thing I need, but I've not been able to use the qq stuff directly anywhere.
14:16:42 <d34df00d> I've had much luck using [| qq |] stuff to embed something computed at compile time, but I'm not sure how to apply it here.
14:16:47 <d34df00d> I generally have very little experience with TH.
14:21:17 <dsal> I have always needed to programmatically create my exprs for things that I was doing.  e.g., for something like you'r case, I'd use the qq to see what an expr would look like and then write a function that generates all those expressions.
14:22:00 <d34df00d> You mean like literally printing [| \case [A, B, C] ... |] in repl?
14:29:23 * hackage hvega 0.5.0.0 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.5.0.0 (DouglasBurke)
14:32:06 <dsal> d34df00d: Yeah, I do that kind of junk in ghci and then build from there.
14:32:20 <dsal> Though some of the things it prints out aren't compilable.  It gets me close.
14:33:40 <d34df00d> That's a brilliant idea that never occurred to me!
14:33:42 <d34df00d> Thanks :)
14:34:42 <solonarv> it's unfortunate that we can't quasiquote/antiquote arbitrary bits of syntax
14:38:21 <d34df00d> Yeah, I really could use smth like
14:39:10 <d34df00d> matches <- forM powerset $ \subset -> [| $(subset) -> foo @($(toTicked <$> subset)) |]
14:40:49 <stevenxl> if i have a script that uses opt-parse, how can I run it and pass in the command line options?
14:41:33 <solonarv> a script, as in: a single Haskell file with a 'main' function?
14:42:07 <solonarv> you can add a shebang in the first line, GHC respects those (i.e. it will not throw up a syntax error)
14:42:44 <stevenxl> oh - i see
14:42:47 <solonarv> so if all the dependencies are already available, you can add #!/usr/bin/env runghc as the shebang
14:42:52 <stevenxl> make it executable instead of tryibng to use stack t run it
14:42:56 <stevenxl> got it
14:42:57 <stevenxl> thanks
14:42:58 <solonarv> yup
14:43:15 <solonarv> ah, you can also use stack (or cabal) as an interpreter, they both support it
14:43:32 <solonarv> this allows you to specify other packages which your script depends on
14:43:49 <stevenxl> solonarv:  but even with the shebang, if i run "stack hs-script.hs --u hello", stack things i am passing the options to it, not to the script
14:43:54 <solonarv> for stack: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
14:43:54 <stevenxl> i just deleted all my work 
14:44:36 <wildtrees> stevenxl, by accident?
14:45:23 * hackage arduino-copilot 1.5.0 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.5.0 (JoeyHess)
14:45:42 <stevenxl> wildtrees: yea
14:45:45 <stevenxl> but it is a small script
14:45:51 <stevenxl> will take 10 min to get it back
14:46:41 <d34df00d> Does anybody know how RTS measures MUT time? I'm trying to benchmark some C code I'll later suppose to merge to bytestring and I learned that POSIX times() works up to the kernel scheduler granularity, which is 100 HZ on my machine (too high).
14:46:54 <d34df00d> Too low that is.
14:47:05 <d34df00d> Or whatever. Too coarse that is.
14:47:24 <d34df00d> But RTS seems to be able to measure with more precision than that.
14:48:47 <wildtrees> stevenxl, might want to start using a version control system, something like git maybe? 
14:49:10 <solonarv> ah, looks like cabal run/repl fixed its little cwd problem
14:49:14 <solonarv> good!
14:49:29 <solonarv> that means I can with good conscience recommend cabal's script support as well
14:50:18 <solonarv> docs: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-run
14:51:07 <GreyFaceNoSpace> @src foldr
14:51:07 <lambdabot> foldr f z []     = z
14:51:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:51:15 <GreyFaceNoSpace> @src foldl
14:51:15 <lambdabot> foldl f z []     = z
14:51:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:53:53 * hackage language-ats 1.7.7.2 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.7.2 (vmchale)
14:54:15 <solonarv> stevenxl: oh, you can use -- to tell stack "your options end here, pass the rest along verbatim"
14:58:04 <stevenxl> solonarv: ah let me give that a shot
14:59:12 <stevenxl> hm.. I am using "stack hs-bkwatch.hs -- --username hello", but i get an error
14:59:21 <solonarv> what's the error?
14:59:47 <stevenxl> https://usercontent.irccloud-cdn.com/file/LjSB3nte/Screen%20Shot%202020-02-07%20at%204.58.57%20PM.png
15:00:22 <solonarv> uhhh, okay I have no idea.
15:00:23 <stevenxl> this is my script
15:00:24 <stevenxl> http://paste.ubuntu.com/p/GTYrkvRtg4/plain/
15:00:50 <solonarv> can't view that, maybe you set it to private?
15:01:17 <solonarv> (I'm redirected to a login page for Ubuntu One)
15:01:33 <stevenxl> how is this
15:01:34 <stevenxl> https://paste.ubuntu.com/p/GTYrkvRtg4/
15:01:48 <solonarv> works!
15:01:56 <stevenxl> ty
15:02:35 <solonarv> huh, I'm surprised you didn't have to pass --package text,optparse-applicative to stack
15:02:40 <solonarv> oh well, it clearly compiles
15:03:03 <solonarv> I guess you could try compiling it to a binary and seeing if that has the same problem
15:03:46 <solonarv> stack ghc --resolver blah yourfile.hs should work
15:04:30 <stevenxl> hm.. getting pinged from coworkers
15:04:34 <stevenxl> but solonarv thank you
15:04:40 <stevenxl> i'm going to come back to this with fresh eyes
15:05:26 <monochrom> Wait a second, password on the command line is a very vulnerable idea. :)
15:07:47 <MarcelineVQ> solonarv: if optparse-applicative has been used in a particular snapshot it will be available for commands that use that same snapshot
15:12:29 <MarcelineVQ> funny though, stack's claimed goal is reproducable builds and it seems like a reproducability issue to me to be allowed to omit your scripts required packages
15:14:54 <hpc> build failures are reproducible
15:15:23 * hackage describe 0.4.0.2 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.4.0.2 (riuga)
15:25:23 * hackage ihaskell-hvega 0.2.2.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.2.2.0 (DouglasBurke)
15:26:23 * hackage mmsyn7ukr 0.12.0.5 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.12.0.5 (OleksandrZhabenko)
15:57:48 <phadej> a/wg 34
16:32:53 * hackage influxdb 1.7.1.2 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.7.1.2 (MitsutoshiAoe)
16:33:53 * hackage describe 0.4.0.3 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.4.0.3 (riuga)
16:36:53 * hackage ghc-lib-parser-ex 8.8.5.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.0 (shayne_fletcher)
16:37:25 <phaazon> hey
16:37:31 <phaazon> why >>= looks like what it looks? :)
16:37:34 <phaazon> anyone knows?
16:39:05 <suzu> it's just made up i think
16:39:11 <suzu> i think philip wadler made it
16:39:21 <phaazon> ah thanks! :)
16:40:53 * hackage lifted-async 0.10.0.5 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.10.0.5 (MitsutoshiAoe)
16:45:06 <solonarv> I guess it looks sort of a thing feeding into some kind of pipe
16:45:17 <ricky_clarkson> phaazon: Maybe because it's vaguely arrowish.
16:45:54 <phaazon> :)
16:48:53 * hackage describe 0.4.0.4 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.4.0.4 (riuga)
16:52:47 <sm> MarcelineVQ, solonarv: I see that with stack scripts too, using the runghc command - it sees installed packages, so you forget to add --package lines before shipping. https://docs.haskellstack.org/en/stable/GUIDE/#writing-independent-and-reliable-scripts says ghc's -hide-all-packages flag prevents this, and so does stack's script command. So it's a bit surprising this example worked
16:53:14 <sm> I remember stack doing some autodetection of packages from imports, but this doc seems to say that's disabled with script
16:54:59 <sm> indeed, that script fails to find those imports here
16:55:22 <sm> as it should
17:04:28 <jle`> phaazon: it was chosen because it resembles the haskell logo
17:04:56 <phaazon_> yeah but the Haskell logo resembles >>= :D
17:05:00 <jle`> hehe
17:05:00 <phaazon_> it’s a fix point problem! :P
17:05:36 <jle`> the logo also inspired the greeks for the shape of lowercase lambda
17:17:53 * hackage persistent-template 2.8.2.3 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.2.3 (parsonsmatt)
17:23:01 <zq> i tried bootstrapping cabal from git master and got Configuring HTTP-4000.3.12...
17:23:04 <zq> Setup: Encountered missing or private dependencies:
17:23:06 <zq> base >=4.3.0.0 && <4.13
17:23:29 <zq> i'm on a fresh install of ghc-8.8.2 that includes base-4.13
17:23:44 <zq> so, is cabal from git not supposed to work with 8.8.2?
17:26:54 * hackage describe 0.4.0.5 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.4.0.5 (riuga)
17:43:01 <zq> cool
18:39:21 <GreyFaceNoSpace> @src (!!)
18:39:21 <lambdabot> xs     !! n | n < 0 = undefined
18:39:21 <lambdabot> []     !! _         = undefined
18:39:21 <lambdabot> (x:_)  !! 0         = x
18:39:21 <lambdabot> (_:xs) !! n         = xs !! (n-1)
20:29:49 <shafox> In cabal 3.0, repl, new-repl, v2-repl all are same ? 
20:41:00 <dmwit> yes
20:44:01 <shafox> thank you
21:17:08 <dmj`> haskell haskell haskell 
21:26:51 <MarcelineVQ> yeah?
21:27:47 <dmj`> yea, I think so
21:28:04 <MarcelineVQ> ye
21:31:26 <jackdk> y
21:42:48 <mac10688> I have an issue where I have a domain sum type that makes sense, when I want to display to the UI (using brick in a list view), I want to extend it with an extra sum type.
21:43:21 <mac10688> It doesn't seem to be possible in haskell to write data Test = Yes | No; data Test1 = MaybeSo | Test;
21:44:00 <mac10688> Anyone know of a way I can compose sum types in this manner without introducing a constructor that takes a type of Test
21:44:04 <mac10688> I like to keep it flat
21:51:37 <pavonia> I don't think you can. What would be the type of Yes or No in this case?
21:53:10 <mac10688> yeah I don't know
21:53:24 <mac10688> I was thinking there isn't another way while I was at work
21:53:32 <mac10688> but I just wanted a second opinion
21:55:53 * hackage store 0.7.2 - Fast binary serialization  https://hackage.haskell.org/package/store-0.7.2 (MichaelSloan)
22:09:26 <iqubic> open sums like this can be done at the type level, but it's ugly.
22:21:13 <jackdk> depending on what exactly mac10688 is trying to achieve, classy prisms may be an option too
22:22:28 <iqubic> I suppose so.
22:29:56 <mac10688> classy prisms sounds fancy. I think I have a primitive work around but I'll be around the lens library for a while and I'll be on the look out
22:30:04 <mac10688> thanks jackdk 
22:30:24 <mac10688> and you guys call this open sums type
22:30:25 <mac10688> nice
22:30:34 <mac10688> just being able to put a word on what I want to do is a big help
22:30:41 <iqubic> No. Classy Prisms are not the same as Open Sums.
22:30:45 <jackdk> https://www.youtube.com/watch?v=GZPup5Iuaqw shows the technique in the context of an MTL program, where it's used to collate errors
22:30:54 <iqubic> Classy Prisms are the easier thing to understand.
22:31:26 <mac10688> i didn't mean to say they were the same, I figured they were different ideas. But I figure I was originally asking how to make open sums
22:31:48 <mac10688> and Classy Prisms was an alternative
22:32:23 <iqubic> Yes. You were. But Open Sums like the ones you want require difficult type level programming shenanigans to work properly
22:32:40 <mac10688> yeah I don't want to get into anything complicated for that
22:32:56 <mac10688> I doubt I would like the end result if it was complicated
22:33:01 <mac10688> I like to keep it simple and clean
22:34:24 <iqubic> Classy Prisms are complicated to implement, but using them is quite straightforward.
