00:01:04 <tdammers> the only thing you may need to do is manually split them into individual queries
00:01:42 <tdammers> other than that, execute_ is probably what you want
00:02:07 <ddk> tdammers: yeah that's what I'm trying to avoid, it will be long ... lot of tables, triggers, procedures etc
00:04:09 <ddk> its like `execute_ :: Connection -> Query -> IO Int64` 
00:05:11 <tdammers> you don't have to do the splitting and querying manually, you know. computers are pretty good at that.
00:06:32 <dminuoso> ddk: By the way, you can use the sql quasiquoter to embed large SQL commands into haskell source files easily.
00:07:10 <dminuoso> It also simplifies a few things, since you just have a single fat binary, rather than having to ship sql files that could be modified under your nose.
00:07:57 <Solonarv> it looks like the API of postgresql-simple does not let you vomit an arbitrary ByteString at the DB (which is good!), but there is 'Database.PostgreSQL.Simple.Internal.exec'
00:08:14 <Solonarv> I don't think I would recommend that, though: dminuoso has a good point
00:08:32 <Solonarv> you can even embed external SQL scripts into your program at compile time
00:09:16 <ddk> my hack is I used (Query mycontentWhichIReadFile) now this type checks and works but I don't know whether its okay to be used in production or not
00:10:12 <Solonarv> oh, that constructor's exported? nice
00:10:23 <tdammers> another approach would be to manage schema updates outside of the application itself, and instead make them part of your deployment scripting
00:10:31 <dminuoso> ddk: And if you really insist on moving it onto separate files, just create a haskell module exporting a single binding, which internally uses the sql quasiquoter.
00:10:34 <tdammers> you can basically just pipe raw SQL into the psql command
00:10:57 <tdammers> this has the added advantage that your application never needs to know about any credentials giving DDL access to the database
00:14:02 <ddk> tdammers: yeah I was also thinking of this too, so basically my Haskell app only have to do write and select query and all other SQL related things are being done separately
00:15:49 <tdammers> if you do it like this, you can even make it such that the DDL credentials are never stored on the application server at all
00:16:55 <tdammers> run the deployment script from a dev machine; first, you ssh into the DB machine, run the upgrade; then ssh into the application server, upload your code and kick it. Credentials are stored only on the dev server, and forwarded as environment over SSH when connecting to the DB server
00:20:13 <ddk> tdammers: great thanks a lot!
00:33:59 <ddk> btw I'm looking for a remote haskell role, mid level 2 year + working exp in Haskell (worked for 1.6 years in IOHK) please let me know if there is anything, based in INDIA 
00:35:43 <dmj`> ddk: https://www.vacationlabs.com/
00:35:56 <dmj`> based in india
00:36:25 <ddk> dmj`: Thanks a lot I know about them :)  
00:36:36 <Uniaika> Shame that Eta went down
00:37:00 <dmj`> Uniaika: this https://eta-lang.org/ ?
00:37:04 <dmj`> ddk: cool :)
00:37:32 <Uniaika> dmj`: yeah
00:37:44 <dmj`> up for me ... 
00:39:35 <Uniaika> Well the website is obviously still up, but the company behind the project has shut down, if I am not mistaken
00:39:37 <Arahael> dmj`: What would you say is a typical starting salary in india? (Just curious - I'm in Australia)
00:39:51 <Uniaika> the CTO works in NYC and I can't recall what the CEO does
00:40:21 <Uniaika> oh, she's still head of the company
00:40:31 <Uniaika> just moved to NYC too 
00:41:51 <Uniaika> but it seems that there's quite a community of functional programmers in India, especially near Bengaluru
00:42:25 <Uniaika> it's nice to see geographic areas that are not Paris/London/NYC/LA
00:45:18 <tdammers> ddk: monitor haskell-cafe, /r/haskell, and this channel; also, if you can afford it, consider attending zurihac, probably the most intense haskell networking event in the world
00:46:43 <ddk> tdammers: yeah I'm monitoring both, attending zurihac is not an option for me now
00:47:32 <Uniaika> yeah .ch is quite expensive
00:51:54 <lortabac> ddk: there is Hasura too
00:52:35 <ddk> lortabac: yeah they want senior level, I contacted them too
00:53:35 <ddk> I'm not looking, just in India but yes remote anywhere 
00:53:47 <Uniaika> ddk: Should you be willing to relocate to Europe / Hamburg, I just got an offer on LinkedIn for a haskell job
00:55:06 <ddk> Uniaika: Thanks for asking, actually I can't relocate for always but maybe for 3-4 months is okay, I need to be in home to see my parents, they need me.
00:55:23 <lortabac> there are several companies that hire remotely in Europe, but the different timezone might be an issue
00:57:25 <ddk> European timezone is not problematic, as I have worked for IOHK for about 1.7 years there we were all remote from different timezones, so its manageable 
00:57:38 <Uniaika> ddk: yeah I understand that
01:03:04 <ddk> I didn't have experience with Web development so in the mean time I took a project to build a proper web App, I choose React for frontend, servant and Postgres, I learnt react and was glad in the way Haskell helped in getting things actually fp mindset :)  
01:07:30 <Uniaika> :)
01:15:44 <boxscape> anyone know if this "Opaque" type is used anywhere? It looks to me like it's not, seeing as it's not exported by the module https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Opaque
01:16:28 <boxscape> possibly it's used for some compiler magic though
01:18:20 <MarcelineVQ> it is exported tho isn't it, export list include GHC.Base
01:18:46 <boxscape> Oh yeah I missed that line
01:21:08 <albet70> what is "parser"?
01:22:06 <MarcelineVQ> boxscape: I don't see it actually being used anywhere in libraries that come wth ghc fwiw
01:22:20 <Solonarv> albet70: are you asking for a dictionary definition, or..?
01:23:38 <albet70> Solonarv in programming language
01:23:55 <Solonarv> right
01:26:14 <ocharles> What's the "correct" way to pass `-j` to `ghc --make` from Cabal? By default, `cabal build --jobs=4` only seems to apply `-j4` to Cabal itself, and doesn't pass it to `ghc` (as seen with `cabal build -v`)
01:26:57 <Solonarv> broadly speaking a "parser" is a program (or part of a program) that takes any text as input, and if that text conforms to a certain format, the parser produces a data structure representing the information in the input more abstractly
01:28:37 <phadej> ocharles: --ghc-options="-j4"
01:28:39 <phadej> ocharles: --ghc-options="-j"
01:29:04 <ocharles> phadej: ok, so I would put that in my cabal.project if I wanted it default? I'm under the impression that -O* and -j stuff shouldn't be in ghc-options in .cabal files
01:29:22 <phadej> yes
01:29:28 <ocharles> sweet, thank you!
01:29:30 <phadej> or even ~/cabal/config 
01:29:43 <phadej> if you don't ever use GHCs which don't know -j
01:30:13 <ocharles> I think I want it in cabal.project so the rest of my team gets this without having to do anything special
01:30:16 <albet70> Solonarv so can we say Data.Text.words is a parser?
01:30:18 --- mode: ChanServ set +o Sigyn
01:30:21 <phadej> (7.8 iirc was the first one to learn that)
01:30:21 <MarcelineVQ> ocharles: you can speficy ghc options in your .cabal file as well
01:30:31 <ocharles> MarcelineVQ: you can, but afaik that's bad practice now
01:30:33 <Solonarv> albet70: yes! a very simple one
01:30:50 <phadej> it's always been
01:31:16 <phadej> (and even previously you could put cabal.config next to your pkg.cabal file)
01:32:03 <albet70> Solonarv I find there's a parser called happy , what it used for?
01:32:21 <phadej> it's a parser generator, think yacc/bison
01:32:24 <albet70> and any others?
01:32:49 <albet70> what is a parser generator?
01:33:09 <Solonarv> albet70: that's more properly a parser *generator*; you write code in some special-purpose language ( I think it's a superset of Haskell? ), and happy produces ordinary Haskell code which implements a parser
01:34:02 <albet70> Solonarv related to Temple Haskell?
01:34:26 <Solonarv> "Temple Haskell" is not a thing, you probably meant "template haskell"
01:34:36 <albet70> yeah
01:34:51 <albet70> Solonarv yes
01:34:52 <Solonarv> it's not really directly related, no - the only similarity is that both generate Haskell code
01:35:25 <albet70> Solonarv related to DSL?
01:36:06 <Solonarv> sure, the language you describe your parser with (i.e. the input to happy) is a DSL
01:37:29 <albet70> Solonarv related to FFI?
01:37:44 <Solonarv> no, not really
01:38:16 <merijn> hmm, does anyone know if it's possible in cabal.project to specify some configuration conditionally (say, for specific GHC versions) or do I need on project file per GHC version?
01:53:44 <Taneb> I wonder if this is useful enough for it to exist in some library: data Unique a = Unique a | Multiple; instance Semigroup (Unique a) where _ <> _ = Multiple
01:54:26 <Taneb> You can use foldMap @(Maybe (Unique a)) to determine if there's a single element which matches a predicate
01:55:28 <merijn> Taneb: Couldn't you easily do the same with Sum Int? :p
01:55:44 <Taneb> merijn: you can get info about what matches the predicate, too
01:56:23 <merijn> Taneb: Hell, you could just foldMap to [a] too and get a list of all matching values?
01:56:47 <Taneb> I guess?
02:01:47 <kuribas> is hedgehog the best library to test properties with effects?
02:02:22 <kuribas> for example fetching random objects from a REST API, then doing various tests on them
02:30:45 <merijn> Any shake users? Do you always use the runhaskell approach or properly build the shake executable? If the latter, how do you detect when the Shake executable is out of date?
02:54:58 <Uniaika> hey, does anyone know if I can pass RTS options to stack?
02:55:28 <Uniaika> I'd like to limit the RTS's 1.0TB allocation so I can properly use ulimit.
02:56:22 <statusfailed> hmmm, does ghc-typelits-knownnat let me tell ghc that (a + b) + c = a + (b + c) somehow?
02:56:53 <merijn> Uniaika: Why do you want to ulimit virtual memory? Just ulimit RES?
03:00:01 <Uniaika> merijn: I'm working on a Forth interpreter and sometimes I do some ugly stuff with recursion, which may or may not end up with no RAM left live :P
03:00:58 <Uniaika> and last time I tried to use ulimit, it automatically said something along the lines of "I can't execute that, you're trying to take a terabyte of memory"
03:01:00 <kuribas> In hedgehog, I can select a random element from a list using the "element" combinator.  However if the list is generated using an effect (for example fetching it from a database), it will refetch the list every time, right?  Is there a way to memoize this list?
03:01:09 <Uniaika> but I'm not an expert in memory on OSs
03:02:53 <kuribas> Or do I need to generate this list before creating the property, then create a property from the list?
03:36:44 <boxscape> statusfailed I haven't used it, but maybe this is helpful to you https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.7.1
03:52:10 <boxscape> is `a -> Void` a proof that `a` is false or a proof that `a` is unprovable?
03:52:33 <boxscape> I assume the latter?
03:52:48 <boxscape> s/is/is a value of type
03:54:28 <Solonarv> depends which logic you're working with
03:54:49 <Solonarv> formally, 'a -> Void' is how we write 'Not a'
03:55:14 <boxscape> hm, okay
03:55:23 <merijn> Uniaika: ulimit (at least on macOS) has separate restrictions for virtual memory and wired/RES memory
03:55:27 <Solonarv> but (because bottoms such as 'undefined' or 'fix id' exist) the logic corresponding to Haskell's type system is inconsistent
03:55:34 <boxscape> right, that makes sense
03:55:36 <Solonarv> meaning you can prove both 'a' and 'Not a'
03:56:15 <merijn> Uniaika: Note that you can control the ulimits from your executable directly, so you could always limit allocations that way (and also pretty sure the RTS lets you limit memory size too)
03:57:54 <merijn> Uniaika: -M RTS option suggests you can indeed limit the heap size that way
03:58:34 <merijn> Uniaika: Seems like it'd be easier to limit memory use that way directly, rather than limiting virtual memory and using ulimit
04:02:26 <[exa]> So I'm going to start a bit of sci-style computing project in haskell. what's the current best practice for storing matrix data?
04:02:34 <[exa]> (like in numpy)
04:02:59 <merijn> [exa]: Not an answer, but you might want to join #numerical-haskell ;)
04:03:19 <merijn> [exa]: There's a bunch of matrix libraries, depends a bit on what you need/do
04:03:42 <Gurkenglas_> Is (.) actually associative given all the type shenanigans that might be involved?
04:03:44 <merijn> hmatrix and hblas
04:04:23 <Solonarv> Gurkenglas_: huh, what type shenanigans do you mean?
04:04:35 <Solonarv> the levity polymorphism shouldn't impede associativity
04:04:46 <Gurkenglas_> % :t toListOf $ _Right . members . asIndex
04:04:47 <yahb> Gurkenglas_: Either c Value -> [Text]
04:05:02 <merijn> Gurkenglas_: How is that type level shenanigans?
04:05:24 <Gurkenglas_> members is an indexed traversal, _Right is a traversal, asIndex composes with an indexed traversal to make a traversal
04:05:52 <merijn> Gurkenglas_: (.) isn't magically overloaded or anything
04:05:54 <Gurkenglas_> and if (.)'s associativity doesn't care about such unification orders then that would be good to know
04:06:28 <[exa]> merijn: #numerical-haskell seems centered about the core numerical haskell library, which might be an overkill. I just need to load matrices and not suffer very much when trying to compute stuff on them
04:06:47 <Gurkenglas_> merijn, I didn't say it was. I also don't know if associativity would hold if I used a custom-defined copy of (.)
04:06:56 <merijn> [exa]: #numerical-haskell is meant for everyone who wants to (performant) numerical stuff :)
04:07:35 <Gurkenglas_> but I take this as "Yes, associativity holds regardless of the higher-rank types involved in the multiple (.) applications."
04:08:12 <Solonarv>  >  I also don't know if associativity would hold if I used a custom-defined copy of (.)
04:08:12 <Solonarv> well, that would of course depend on your custom-defined (.)
04:08:59 <Gurkenglas_> Solonarv, its sourcecode would copy that of (.) while I import prelude hiding (.) <.<
04:09:12 <Solonarv> ah, that would still be associative
04:09:24 <Solonarv> (.) actually doesn't have any special magic IIRC
04:09:46 <Gurkenglas_> yes, that is what I already implicitly believed when I asked my question :P
04:11:18 <Gurkenglas_> Understand my question like you would "If I want to make sure nobody has access to my value, I can just return it in IO, right?" -> "Well, technically some madman might use unsafePerformIO"
04:12:02 <Solonarv> ah, I see
04:12:08 <[exa]> merijn: well ok, will try
04:12:41 <Solonarv> I guess it might not strictly be associative when you take bottoms into account and distinguish _|_ from \ _ -> _|_
04:12:52 <merijn> [exa]: Anyway, hmatrix and hblas are probably the most common matrix libraries, which use BLAS and LAPACK for matrix operations
04:13:10 <Solonarv> but I don't feel like working that out in detail at the moment, so it's nothing more than a vague hunch
04:13:16 <fendor> does ghc-lib-parser expose an API to create an TH Q Exp from a String?
04:13:52 <[exa]> merijn: ok, thanks a lot
04:14:12 <merijn> [exa]: Presumably numpy just uses BLAS and LAPACK too :p
04:14:34 <[exa]> yeah
04:15:46 <[exa]> so I guess it will be FFI friendly, that would be cool, I have some library code in c/c++ already
04:19:21 <[exa]> mmmm, repa has ForeignPtr conversions
04:21:36 <isovector1> anyone have bindings for writing to uinput handy?
04:27:52 <Gurkenglas_> Is there any difference between undefined and const undefined?
04:28:15 <Taneb> > const undefined `seq` ()
04:28:17 <lambdabot>  ()
04:28:19 <Taneb> > undefined `seq` ()
04:28:21 <lambdabot>  *Exception: Prelude.undefined
04:28:33 <Gurkenglas_> ah. hmm that doesnt seem right
04:28:41 <merijn> > snd $ fmap undefined (True, False)
04:28:43 <lambdabot>  *Exception: Prelude.undefined
04:28:54 <merijn> > fst $ fmap (const undefined) (True, False)
04:28:56 <lambdabot>  True
04:29:10 <Gurkenglas_> ah, yes that's better
04:29:13 <merijn> I messed up the first one, although I'm not sure that actually fails
04:29:17 <merijn> > fst $ fmap undefined (True, False)
04:29:19 <lambdabot>  True
04:29:22 <merijn> Rats
04:29:23 <Gurkenglas_> :(
04:29:36 <shachaf> It's the thing Taneb said.
04:29:46 <shachaf> That's the only difference, and it's kind of a sketchy one.
04:30:23 <Gurkenglas_> Is there a variant of seq that doesn't distinguish undefined from const undefined?
04:30:52 <Gurkenglas_> like one that doesnt stop at \_ -> _ terms but inserts undefined
04:31:08 <shachaf> You can imagine not having seq built into the language.
04:31:32 <shachaf> Then you couldn't distinguish those two.
04:31:43 <shachaf> You could write seq for specific types, but not for functions.
04:32:17 <Gurkenglas_> Is there an f with f () _|_ = f _|_ () = f () () = (), but f _|_ _|_ = _|_?
04:32:37 <Gurkenglas_> <shachaf> You could write seq for specific types, but not for functions. <- not me, whoever wrote seq
04:35:18 <boxscape> Gurkenglas_ IIRC there was a hackage library that offered such a function using, I believe, unsafePerformIO hackery, to return whichever argument finished computing first
04:35:31 <boxscape> s/computing/evaluating
04:35:37 <Gurkenglas_> makes sense
04:36:59 <Gurkenglas_> \a b -> either id id $ unsafePerformIO $ race (evaluate a) (evaluate b)
04:37:38 <merijn> cocreature: Sad news, something is still wonky in the world of TH, even with mpickering's new branch :)
04:37:47 <shachaf> Gurkenglas_: I'm talking about you.
04:38:17 <Gurkenglas_> shachaf, I couldn't write seq, so I couldn't expect to be able to write a variant of seq
04:38:48 <shachaf> You sure can.
04:38:50 <Gurkenglas_> Presumably, seq runs at a low enough level that polymorphism has no power
04:38:53 <shachaf> case b of False -> False; True -> True
04:39:05 <shachaf> Uh, not that.
04:39:17 <shachaf> I mean case a of False -> b; True -> b
04:39:47 <Gurkenglas_> yea but that's for specific types, I'm talking about a variant of "polymorphic" seq as we know it
04:43:37 <boxscape> how about... `class Seqable a where seq' :: a -> b -> b` and `instance {-# OVERLAPPABLE #-} Seqable a where seq' = seq`, `instance Seqable (a -> b) where seq' = undefined`
04:44:26 <merijn> boxscape: That class existed and it was called NFData :p
04:44:42 <boxscape> but NFData is for deepseq, isn't it?
04:44:54 <merijn> boxscape: It is *now*
04:45:02 <boxscape> oh, I see
04:45:04 <merijn> boxscape: Because seq was built into the runtime
04:45:16 <boxscape> okay
04:45:23 <boxscape> interesting
04:46:05 <merijn> The typeclass based seq has the problem that annotating something nested deeply meant propagating the constraint out everywhere which is a lot of work for an otherwise local optimisation
04:46:21 <boxscape> makes sense
04:47:56 <Gurkenglas_> boxscape, I'm not that interested in actually implementing it, I just want to know whether the theory would be neat if anyone, like GHC, did it
04:49:32 <Gurkenglas_> this reminds me of choosing between the least fixed point of a definition and the highest common lower bound of all maximal fixed points
04:52:06 <Gurkenglas_> > many (Just 2) -- the highest common lower bound of all maximal fixed points is Just (repeat 2)
04:52:09 <lambdabot>  *Exception: <<loop>>
04:54:26 <Gurkenglas_> Could we build the compiler such that it always gave us the highest common bound of all maximal fixed points, such as by detecting that all cases of many end up at Just and therefore factoring it out?
04:55:00 <Uniaika> good bot
05:10:02 <lyxia> It doesn't seem easy to work around the fact that it is an undecidable problem.
05:40:01 <boxscape> is there a paper somewhere or something on how to automatically convert expressions into pointfree style? (the source of the pointfree program is a nice start, tbf)
05:41:25 <berndl> boxscape: that sounds hard. It would depend on the functions that you have available for the conversion.
05:42:29 <boxscape> hm, that makes sense
05:43:22 <boxscape> I suppose one way would be to just use SKI combinators which has pretty good literature
05:43:35 <boxscape> s/has/have
05:49:15 <berndl> boxscape: that will work for pure lambda terms. I don't know how that would in a more complicated setting like a term of type IO ().
05:49:27 <berndl> *how that would work
05:51:19 <boxscape> hm, I can't really see a reason for why it wouldn't, but maybe
05:53:20 <berndl> The problem with point-free style is that it doesn't scale.
05:53:54 <berndl> But maybe that's a good thing. It prevents devs from writing 100+ line functinos.
05:54:51 <boxscape> I don't really have an alternative here; I'm thinking about perhaps writing a small library to convert type level lambdas into point-free style via TH (because type-level lambdas aren't a thing yet)
05:54:59 <__monty__> Yeah, anything over a line is a hard sell in pointfree style.
05:55:13 <boxscape> though I suppose making type families is an alternative
05:57:44 <idnar> I usually try to get things into a point-mostly-free style; if it won't fit nicely, I don't force it, but I take it as a possible hint to restructure things
06:00:11 <Solonarv> actually, if you just want to convert lambdas to something point-free then SK is enough
06:00:30 <Solonarv> but that's not very useful, because you can't partially apply type families and synonyms either
06:01:14 <boxscape> as I understand it it's useful for dependent pairs
06:01:29 <boxscape> at least that's what got me to this idea in the first place
06:06:29 <boxscape> and I think you could use singletons defunctionalization tools to apply it partially in other contexts
06:08:44 <dmj`> Arahael: no idea
06:34:23 * hackage nonlinear-optimization-ad 0.2.3 - Wrapper of nonlinear-optimization package for using with AD package  https://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.3 (MasahiroSakai)
07:08:32 <AWizzArd> What backing newtype would you use to test code (e.g. handlers in a server) with a sig such as  (MonadLogger m, ThreadM m) => ...  ?  There are log calls and a threadDelay. I am thinking about having a newtype over a Writer, which accumulates the log messages and one threadDelay call.
07:08:44 <AWizzArd> Writer?  Reader over a TVar?
07:10:53 <merijn> Writer is notoriously bad performing, tbh
07:11:07 <Poscat[m]> why is there a flipped catch (handle) but no flipped catches (should be called handles)?
07:11:33 <merijn> Poscat[m]: "because"
07:11:54 <tabaqui1> be a hero, and send the PR
07:12:02 <merijn> Poscat[m]: I don't think there's a comprehensive rationale, I think it was just a matter of "handle is very common"
07:12:06 <merijn> Naah
07:12:29 <AWizzArd> merijn: what do you mean by bad performing? As in not CPU-efficient?
07:12:34 <merijn> Seems way below the Fairbairn threshold
07:12:45 <AWizzArd> merijn: or challenges with memory leaks?
07:12:46 <merijn> AWizzArd: Space leaks, iirc
07:12:56 <AWizzArd> merijn: but is that an issue for unit tests?
07:13:19 <merijn> You tell me? :p
07:13:34 <AWizzArd> merijn: what about using State as a writer?
07:13:54 <tabaqui1> it's just the same
07:13:59 <AWizzArd> thought so
07:14:45 <AWizzArd> Are the leaks a matter of principle? Is there no "safe" implementation?
07:14:54 <AWizzArd> I.e. a strict writer that won’t leak?
07:15:01 <johnw> that's called State :)
07:15:40 <tabaqui1> Control.Monad.Writer.Strict?
07:15:45 <johnw> AWizzArd: for more info: https://blog.infinitenegativeutility.com/2016/7/writer-monads-and-space-leaks
07:16:59 <AWizzArd> tabaqui1: I had that in mind, si.
07:17:03 <AWizzArd> johnw: thx, will read
07:24:49 <uglyoldbob> what might be a good way of splitting a list into a list of consecutive numbers. -> [[1,2,3],[5,6,7],[10,11],[13]] ?
07:25:39 <johnw> uglyoldbob: you need to be fast, or do you just care about the answer?
07:25:53 <uglyoldbob> just the answer
07:25:55 <johnw> if speed doesn't matter, all you need is a predicate on lists to indicate whether all elements are ascending
07:26:28 <johnw> then take the subset of the list of all groups where this predicate holds for each member list
07:27:05 <johnw> this will be a bit ridiculously slow, but mathematically it should meet the criterion
07:27:47 <uglyoldbob> i'm guessing that fast would be much complicated?
07:27:47 <johnw> a fast option would be to create a custom binary tree structure where you can easily identify "gaps", and you render the tree into multiple lists separated by gaps
07:27:49 <dminuoso> uglyoldbob: Just do a simple recursion style function `groupAscending f = go f [] where go (x:xs) [] = ...`
07:28:17 <dminuoso> That would perform nicely in O(n) for list of n
07:29:22 <uglyoldbob> johnw: thank you
07:29:30 <uglyoldbob> dminuoso: thank you
07:34:23 <johnw> another function that would make this easy is if we had a version of splitWhen (from the 'split' package) called maybe splitBetween that takes a test between too elements (a -> a -> Bool), and splits wherever that relation holds.
07:34:41 <johnw> then you could implement as: groupAscending f = splitBetween f . sort
07:35:25 <johnw> I meant: groupAscending = splitBetween (\x y -> abs (x - y) > 1)  . sort
07:35:25 <ChaiTRex> > let f xs = zipWith (*) (scanl (*) 1 xs) (scanr1 (*) xs) in f [1 .. 4]
07:35:30 <lambdabot>  [24,24,24,24]
07:36:19 <ChaiTRex> > let f xs = zipWith (*) (scanl (*) 1 xs) (scanr (*) 1 (tail xs)) in f [1 .. 4]
07:36:21 <lambdabot>  [24,12,8,6]
07:36:31 <johnw> dminuoso: for a list that's not sorted, I'm not able to see how you can do this in O(n)
07:38:24 <dminuoso> johnw: Why does it matter whether it's sorted?
07:38:42 <dminuoso> johnw: Ah I was just assuming we only associate adjacent consecutive numbers together
07:38:44 <johnw> oh, you're right
07:39:18 <dminuoso> johnw: And even then we might even be able to do something funky with kmetts discrimination
07:40:19 <dminuoso> Actually not even funky, as you could pre-sort it with discrimination and then do my algorithm.
07:40:25 <dminuoso> It'd still be in O(n)
08:01:22 <johnw> how is sorting O(n)?
08:01:29 <johnw> or do you just mean your part of it
08:09:25 <idnar> johnw: https://www.reddit.com/r/haskell/comments/742b55/discrimination_package_sorts_in_linear_time_but/dnvhl3d
08:12:23 * hackage llvm-tf 9.1.1 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-9.1.1 (HenningThielemann)
08:14:30 <dminuoso> johnw: https://hackage.haskell.org/package/discrimination
08:15:46 <dminuoso> It appears to be a little known fact that sorting can be done in linear time in most cases.
08:16:55 <kuribas> wasn't there a functional pearl to do this?
08:17:08 <kuribas> I remember it was in pearls of functional design
08:20:32 <dminuoso> kuribas: I wouldnt call it a functional pearl, the internals are somewhat complex.
08:21:18 <dminuoso> kuribas: The original idea is a radix sort.
08:21:46 <kuribas> ah no, it was a slightly different problem: http://typeocaml.com/2015/02/20/pearl-no-2-the-max-number-of-surpassers/
08:30:05 <dminuoso> merijn: prettyprinter is missing an elegant combinator to do something like `vsep [ foo, bar, mwhen t quux ]` without generating that last empty line. :(
08:30:36 <merijn> dminuoso: mconcat . intersperse ? :p
08:31:00 <merijn> You just need to figure out the line separator for intersperse
08:31:37 <dminuoso> merijn: That wont help though.
08:32:06 <dminuoso> merijn: You'd need something like `filter isNotMempty`
08:32:37 <dminuoso> `mwhen :: Monoid m => Bool -> m -> m` of course
08:32:39 <dminuoso> with the obvious semantics
08:35:46 <uglyoldbob> doMath x = map snd $ map unzip $ split (whenElt ((> 1) . fst)) $ zip (1:(zipWith (-) (tail x) x)) x
08:35:53 <merijn> dminuoso: oh, right
08:36:00 <uglyoldbob> x must already be sorted
08:36:12 <dminuoso> what Ive been doing right now is some: mayWhen :: Monoid m => m -> Maybe m; (<?>) :: Monoid m => m -> Maybe m -> m; [foo, bar] <?> mayWhen t quux
08:37:26 <dminuoso> Or, if the amount of things that might not exist is larger, I'd use wither 
08:40:24 * hackage mergeless 0.2.0.0 -   https://hackage.haskell.org/package/mergeless-0.2.0.0 (Norfair)
08:41:23 * hackage genvalidity-mergeless 0.1.0.0 -   https://hackage.haskell.org/package/genvalidity-mergeless-0.1.0.0 (Norfair)
08:50:23 * hackage pretty-relative-time 0.2.0.0 - Pretty relative time  https://hackage.haskell.org/package/pretty-relative-time-0.2.0.0 (Norfair)
08:51:50 <monadplus> How is Haskell for data science/data mining stuff ? 
08:52:26 <AWizzArd> Is there a way to discover that `fromQuery` exists without clicking on "Code" and without hoogling for  "Query -> ByteString"?    https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple.html#t:Query
08:52:45 <AWizzArd> Instead of "Code" I meant "# Source"
08:55:14 <dminuoso> monadplus: Well, what particular features are you looking for exactly?
08:55:49 <dminuoso> monadplus: Haskell is a general purpose programming language that is equipped for writing robust, maintainable, high performance programs of any kind in.
08:56:30 <dminuoso> monadplus: Haskell is not so good for low level/close-to-hardware/embedded programming, and not so good for hard realtime applications that cant survive stop-the-world allocators. For everything else Haskell is just great.
08:57:15 <monadplus> I am looking for libraries with built-ins for data mining like: kNN, k-means, SVM, AdaBoost, Naive Bayes, etc
08:58:30 <dminuoso> monadplus: It's mostly spread around in different libraries. You can also ffi if you have some favourite native library you like that can do all of that already.
08:59:46 <monadplus> I have to choose between haskell which I am fluent and R/Python (better support/libraries)
09:00:19 <monadplus> so I may try haskell for that and if I see that I need to do a lot of coding to get it done, I will probably use R/Python (what a pain..)
09:01:34 <dminuoso> monadplus: You might want to ask on the haskell mailing list. There's a better chance you might get some secret tip about libraries because data science in Haskell is a bit of a niche
09:10:24 * hackage fuzzy-time 0.1.0.0 -   https://hackage.haskell.org/package/fuzzy-time-0.1.0.0 (Norfair)
09:11:23 * hackage fuzzy-time-gen 0.1.0.0 -   https://hackage.haskell.org/package/fuzzy-time-gen-0.1.0.0 (Norfair)
09:11:59 <AWizzArd> monadplus: there is also this integration lib between Haskell and R.  https://www.tweag.io/posts/2015-09-08-programming-r-at-native-speed-in-haskell.html
09:12:34 <AWizzArd> monadplus: And you can use  https://www.datahaskell.org/  as a starting point too.
09:14:58 <monadplus> I didn't know about datahaskell *.* thanks AWizzArd 
09:21:24 <CasualFriday> quit
09:21:27 <CasualFriday> oops, sorry
09:29:54 * hackage stack-templatizer 0.1.0.1 - Generate a stack template from a folder.  https://hackage.haskell.org/package/stack-templatizer-0.1.0.1 (lysergia)
09:34:46 <AWizzArd> What could a Typeable instance of simple-pg’s `Only` type look like?
09:35:02 <Cale> You're not meant to write Typeable instances by hand
09:35:13 <Cale> The compiler derives them for you
09:35:38 <AWizzArd> Cale: okay I see.
09:36:26 <Cale> So it might look like  deriving instance Typeable Only
09:36:53 * hackage cantor-pairing 0.2.0.1 - Convert data to and from a natural number representation  https://hackage.haskell.org/package/cantor-pairing-0.2.0.1 (identicalsnowflake)
09:36:53 <Cale> (using StandaloneDeriving)
09:37:24 <AWizzArd> Cale: yes that worked, thx.
09:37:50 <Cale> It might be a good idea to upstream that
09:38:20 <AWizzArd> Cale: you mean to patch simple-pg so that it derives Typeable?
09:38:40 <Cale> I haven't needed Typeable instances on any of those types in postgresql-simple before, but yeah, there's no particular reason they shouldn't exist
09:39:54 <AWizzArd> Cale: I only need it for testing code that would query the real DB for the given monad, but which uses mock data in my test case.
09:56:44 <nshepperd2> isn't the compiler supposed to magic up Typeable instances without even deriving them
09:57:27 <nshepperd2> maybe that's only newer ghc
09:59:06 <lyxia> yes
10:05:48 <uglyoldbob> last function was wrong. doMath x = map snd $ map unzip $ split (keepDelimsL $ whenElt ((> 1) . fst)) $ zip (1:(zipWith (-) (tail x) x)) x
10:12:22 <dmwit> nshepperd2: Yes. But you still need Typeable constraints for type the caller may choose; perhaps that is what's tripping you up.
10:12:51 <dmwit> e.g. `funny :: a -> String; funny x = show (typeRep x)` is no good, but `funny :: Typeable a => a -> String; funny x = show (typeRep x)` is fine.
10:13:08 <dmwit> (typeRep? typeOf? I can't keep the API straight. You know what I mean.)
10:13:20 <nshepperd2> Cale was talking about using StandaloneDeriving to give things Typeable instances
10:13:38 <dmwit> Ah, I didn't read enough context. My bad.
10:18:25 <nshepperd2> the new type-indexed version of Typeable in Type.Reflection is pretty cool
10:18:47 <nshepperd2> typeRep :: Typeable a => TypeRep a
10:19:52 <nshepperd2> comes with pattern synonyms for decomposing types
10:20:23 * hackage unexceptionalio-trans 0.5.1 - A wrapper around UnexceptionalIO using monad transformers  https://hackage.haskell.org/package/unexceptionalio-trans-0.5.1 (StephenWeber)
10:22:24 * hackage pretty-diff 0.1.0.0 - Pretty printing a simple diff of two values.  https://hackage.haskell.org/package/pretty-diff-0.1.0.0 (stoeffel)
11:51:53 * hackage tasty-test-reporter 0.1.1.1 - Producing JUnit-style XML test reports.  https://hackage.haskell.org/package/tasty-test-reporter-0.1.1.1 (stoeffel)
11:58:58 <merijn> Man...I hate when a line is *just* over 80 characters with no nice way to split >.<
11:59:24 <__monty__> Kill it with fire.
11:59:51 <merijn> __monty__: Well, the alternative is to switch to RecordWildCards instead of NamedFieldPuns, but that feels bad too
12:00:19 <maerwald> 80 is a random number
12:00:32 <__monty__> Such a nice number though.
12:00:54 * hackage pretty-diff 0.2.0.0 - Pretty printing a diff of two values.  https://hackage.haskell.org/package/pretty-diff-0.2.0.0 (stoeffel)
12:01:19 <merijn> maerwald: It's the number that lets me fit 3 columns side by side on my screen + line numbering
12:01:45 <maerwald> buy 2 screens
12:02:04 <merijn> maerwald: Also, not all THAT random, tbh. Research on reading suggests that saccades of more than 66-76 characters make for uncomfortable reading, which is why TeX and newspapers use lines that are about that long
12:02:36 <maerwald> on reading natural languages I would bet
12:02:42 <maerwald> not programming ones
12:02:52 <__monty__> Sure but it's useful for both.
12:03:12 <maerwald> it can impact readability negatively as well ;)
12:03:16 <__monty__> Otherwise you'd have to switch between multiple terminal widths.
12:04:04 <merijn> maerwald: Literally everything has the potential to negatively affect readability
12:46:26 <dsal> merijn: That statement affected me emotionally and now I'm sad and having a hard time reading code.
12:46:53 * hackage hs-pattrans 0.1.0.1 - DSL for musical patterns and transformation, based on contravariant functors.  https://hackage.haskell.org/package/hs-pattrans-0.1.0.1 (omelkonian)
12:47:08 <merijn> dsal: I can show you some C++ code and make you even sadder :p
12:47:16 <dsal> haha.  yes
12:47:32 <dsal> I don't even understand how I feel about c++, though.
12:47:43 <merijn> "It's complicated"
12:47:51 <dsal> haha.  That explains my relationship well.
12:47:52 <merijn> (the language and my feelings...)
12:47:56 <__monty__> Classic Stockholm.
12:48:32 <merijn> __monty__: Every time I open these files there's this "this 1000 line monstrosity would've been 200 at most in Haskell and then I'd have errors mortals could understand"
12:48:49 <dsal> But it's super fast, probably.
12:49:00 <merijn> dsal: Not to compile >.>
12:49:09 <dsal> Also, don't touch it.  If you need to make changes, just make a new one.
12:49:22 <merijn> dsal: But at least no GC collection pauses!
12:49:26 <maerwald> 1000 lines to 200 lines sounds like the 200 would be more golfed and harder to understand
12:49:39 <merijn> maerwald: the 200 lines would be a ton easier
12:50:02 <dsal> We don't need GC.  We have smart pointers.
12:50:04 <merijn> maerwald: You just need A LOT of hoops and verbosity to do what I wanted
12:50:21 * dsal still needs to find a reason to use rust for something
12:50:40 <merijn> dsal: Well, that was the reason for not using haskell from the get-go, GC pause messing up my measurements. In hindsight fighting GC pauses would've been less work than fighting C++ >.>
12:51:13 <dsal> This is why you're supposed to pick your battles.
12:51:23 <merijn> dsal: I didn't know :(
12:51:38 <tdammers> there's another reason for the 80-character thing that isn't mentioned often
12:51:45 <tdammers> screen space efficiency
12:52:18 <zeta_0> hello there, could you guys give me some hints on this algorithm that i am trying to solve with haskell: https://www.hackerrank.com/challenges/reverse-shuffle-merge/problem?h_l=interview&playlist_slugs%5B%5D=hackerrank
12:52:22 <tdammers> no matter what limit you set, the distribution of line lengths in your code will not be uniform; there will be more short lines than long ones
12:52:32 <dsal> I worked with a guy who hated line breaks.  It's one thing to argue about what the right terminal width is.  It's another to have to scroll all the context off the screen in order to see what's going on.
12:52:58 <merijn> tdammers: That too
12:53:06 <zeta_0> so i could use the reverse function, but i am not sure what functions to use for shuffle and merge?
12:54:17 <dsal> I think you're supposed to write that.
12:54:31 <dsal> Merge is rather interesting because it looks like it could blow up in complexity.
12:54:41 <maerwald> dsal: fix your editor
12:54:45 <merijn> s/interesting/annoying
12:55:15 <dsal> maerwald: The alternative is to have the editor wrap, which didn't really help.  I think a linebreak on occasion is fine.  :)
12:55:17 <merijn> maerwald: If you're gonna have your linewrap long lines you may as well just do it right away and control the wrap so it looks good
12:55:36 <merijn> s/your linewrap/your editor linewrap/
12:55:50 <zeta_0> i am just asking for some tips, not the solution
12:55:50 <maerwald> Long lines are fine if your editor makes it visible properly and distinguishable 
12:56:04 <dsal> I work in a couple languages that have different standards here.  One suggests shorter symbols and allows for arbitrary long lines.  Another has an 80 character hard limit, but suggests your symbols should generally be longer.  For "readability"
12:56:14 <dsal> :t inits -- zeta_0 
12:56:16 <lambdabot> [a] -> [[a]]
12:56:27 <dsal> :t tails -- or maybe this?
12:56:29 <lambdabot> [a] -> [[a]]
12:57:22 <dsal> You want every way you can take two sequences and put them together while maintaining an individual sequence's order in the output.
12:58:33 <dsal> Another way to think of it is generating the output sequence via coin toss.  You are effectively zipping two lists together, except at every intersection, you have one result that took a and one result that took b.
12:58:40 <zeta_0> dsal: does haskell have a built-in intersperse function? i could use that for the merging
12:58:47 <dsal> :t intersperse
12:58:48 <lambdabot> a -> [a] -> [a]
12:59:43 <dsal> I wouldn't think the goal would be "find the function that solves this problem" as much as it is "write code to solve this problem."
12:59:49 <amalloy> dsal: that sounds like go and...c++?
13:00:00 <zeta_0> dsal: what module is that in, i don't see it in prelude?
13:00:12 <amalloy> :i intersperse
13:00:13 <dsal> The merge specification seems particularly... not generally useful.
13:00:37 <MarcelineVQ> Data.List where many useful list things can be found
13:00:44 <zeta_0> dsal: i want to use the builtin functions 1st, then when i get a good feel, i'll reinvent the wheel, and write the functions from scratch
13:01:11 <dsal> amalloy: Yeah, or like, python sometimes.  Similar problem.  Write very long identifiers.  OMG, why is this line so long?  I have some similar javascript woes currently.  "This tiny-scoped local variable needs at least a three word name." (not direct quote)
13:01:36 <dsal> zeta_0: Using built-in functions is fine.  There aren't, unfortunately, built-in functions for every problem you encounter.
13:01:47 <dsal> e.g., intersperse doesn't do what you want.
13:02:08 <dsal> > intersperse '?' "does this help"
13:02:10 <lambdabot>  "d?o?e?s? ?t?h?i?s? ?h?e?l?p"
13:05:08 <dsal> The function you want is   [a] -> [a] -> [[a]]   such that it drains all of both arguments in every order.
13:05:09 <zeta_0> dsal: ok understood, i am just trying to get a good feel for this problem
13:05:09 <acertain> `unsafePerformIO f` creates a thunk that runs f once, right? is there any way to do like `unsafeRepeatPerformIO f`  that is like a getter, i.e. runs f every time it's demanded?
13:07:45 <dmwit> acertain: `f` does that
13:07:55 <dmwit> Or: you're doing it wrong.
13:08:01 <dmwit> (Seriously.)
13:08:58 <AWizzArd> I would like to create a value of this type:   newtype DbPg = DbPg (forall q r. (Typeable q, Typeable r) => Query -> q -> [r])
13:09:45 <AWizzArd> This is supposed to be used in a unit test. The live code is running in my AppT monad and expects that the DB returns a  [Only ...]   value.
13:09:51 <MarcelineVQ> theres also no gurantee that it's run only once, that's a big part of the reason it's unsafe. in particular if it's inlined the IO might happen many times.  https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO-Unsafe.html#v:unsafePerformIO
13:10:22 <AWizzArd> Now I wonder how I could do this, as this signature promises any return value, and not a concrete list of Only.
13:12:19 <zeta_0> dsal: so the function reverseShuffleMerge needs to take a String, reverse it's letters, take another String, rearrange it's letters, lastly return a functions that intersperses the 2 Strings together?
13:12:21 <acertain> yes, i know what i ask for is terrifying
13:14:21 --- mode: weber.freenode.net set +o ChanServ
13:14:29 <dsal> zeta_0: Maybe.  I didn't read the whole problem, just a couple bits.  Part of the solution is permutations, but not in its raw form, as it'll likely generate a lot of duplicates.
13:14:40 <dsal> > permutations "egg"
13:14:42 <lambdabot>  ["egg","geg","gge","gge","geg","egg"]
13:15:44 <zeta_0> dsal: ok, i am going to implement each function individually then try to compose them
13:15:59 <dsal> That's programming!  :)
13:16:00 <jackdk> AWizzArd: you're misreadnig it; those type variables are existential. Let me put together a sketch. Do you have a link to the module that introduces that type?
13:16:25 <Tuplanolla> It's best to assume that there are no guarantees for how many times the argument of `unsafePerformIO` is evaluated, acertain.
13:17:00 <zeta_0> dsal: thanks, struggling, but i will keep trying
13:17:41 <jackdk> AWizzArd: ah, hm...
13:18:09 <Tuplanolla> You can get some guarantees with `NOINLINE` and friends, but that requires care and reading of the GHC user guide.
13:20:28 <AWizzArd> jackdk: I can give you the signature of the  query  method
13:22:04 <AWizzArd> class (Monad m) => MonadReadDB m where query :: (ToRow q, FromRow r, Typeable q, Typeable r) => Query -> q -> m [r]
13:24:11 <AWizzArd> In my function I have     rolelist <- runTransaction $ query "SELECT ..." (Only username)      and then    pure $ S.fromList $ map fromOnly rolelist
13:24:43 <AWizzArd> So the type of rolelist is [Only Rolename]
13:24:45 <MarcelineVQ> acertain: It's not scary but the motive needs to be checked, dmwit is serious when he says that f does this already, f = getCurrentTime for example will give you a different time each exection. We can make sure that this can happen safely by restricting it the IO type which is used to enforce an ordering to the execution.
13:25:13 <jackdk> AWizzArd: okay sure but then where did the definition of DbPg come from?
13:25:21 <Uniaika> (off-topic, but I love this channel since I've activated ligatures in my terminal. Everything looks so beautiful)
13:25:27 <AWizzArd> jackdk: It's in one of my modules.
13:25:55 <MarcelineVQ> So the thing for the room to ask is, if your intent is to have  unsafeRepeatPerformIO :: IO a -> a   why do feel you need this?
13:26:10 <AWizzArd> jackdk: along with   newtype TestM a = TestM (Reader DbPg a) deriving (Functor, Applicative, Monad)
13:26:44 <AWizzArd> And a    newtype TestTransaction a = TestTransaction (Reader DbPg a) deriving (Functor, Applicative, Monad)
13:27:05 <jackdk> AWizzArd: who put it there? Was it you, or did you find it? Can you talk to him or her? I can dispatch on `q` by using `Data.Typeable.cast` but do not see how to get the result into whatever `r` the caller is asking for
13:27:23 <jackdk> AWizzArd: this is getting to the point where you should think about putting a pastebin together
13:27:37 <zincy_> How can you express relationships between fields in product types?
13:27:41 <AWizzArd> jackdk: I can try to reach the original author, yes.
13:27:59 <AWizzArd> jackdk: and yes, the [r] part is also my problem here, because cast seems not to help.
13:28:55 <zincy_> Say you had a two fields, Bool and List and you want bool value to always express whether the list is empty or not?
13:29:32 <amalloy> then the bool shouldn't be a field
13:30:00 <jackdk> zincy_: either what amalloy said, or put your type in a separate module, do not export the constructor, and provide functions that maintain your invariant.
13:30:50 <zincy_> amalloy: I actually agree
13:32:34 <amalloy> but, suppose you wanted some more-expensive property. say it's a [String], and you want to also record whether "admin" is present in the list
13:33:21 <amalloy> that would be expensive to recompute over and over, so you'd lift it to a field in the record, and hide the constructor so that nobody can build an instance with an incorrect cache, as jackdk says
13:33:22 <zincy_> Yeah
13:34:09 <amalloy> (but don't make it a strict field, in case nobody ever looks at the cached result)
13:34:52 <jackdk> AWizzArd: if the return value was existential, maybe you could do something (but I'm tripping up on other type errors when I try). I really do not see how you can write values of the type you provided
13:34:58 <jackdk> AWizzArd: I'm tapping out, sorry
13:35:07 <zeta_0> dsal: ok so i figured out the first 2 functions, now i just need to figure out the merge function
13:36:02 <AWizzArd> jackdk: thx for having a look.
13:37:23 * hackage hs-pattrans 0.1.0.2 - DSL for musical patterns and transformation, based on contravariant functors.  https://hackage.haskell.org/package/hs-pattrans-0.1.0.2 (omelkonian)
13:37:35 <zeta_0> it looks like haskell has a builtin merge function, nice
13:38:36 <hololeap>  what's the canonical way to do something like isSuffixOf using parsec, or something like the regex, "(.*)somestring$"
13:39:05 <zeta_0> which module should import merge from? https://hoogle.haskell.org/?hoogle=merge
13:39:13 <zeta_0> hoogle is confusing me
13:39:18 <dsal> zeta_0: Having the same name as the name of the thing you think you might need doesn't mean it does something useful for you.
13:40:15 <dmwit> zeta_0: What do you think merge does? What do you want merge to do?
13:40:54 <amalloy> hololeap: it's kinda hard to ever have something like .* in a parser, because it's kinda declaring bankruptcy: "i have no idea what token this character is a part of, until i scan an unknown distance through the input to find some other anchor"
13:41:11 <zeta_0> dmwit: i am trying to implement merge the way it's done in this algorithm problem: https://www.hackerrank.com/challenges/reverse-shuffle-merge/problem?h_l=interview&playlist_slugs%5B%5D=hackerrank
13:41:37 <zeta_0> hoogle has a bunch of merge functions, wow
13:42:28 <dmwit> Okay. 1. I do not believe that operation comes standard anywhere. 2. It's not even clear to me that solving the problem given there involves implementing merge anyway.
13:42:29 <dsal> zeta_0: This tells you that "merge" isn't a very descriptive word.
13:43:38 <zeta_0> dsal: agreed, i need to intersperse the 2 strings while maintaining the order
13:43:53 <hololeap> well, there has to be some way to do it
13:44:01 <dmwit> There is a way to do it, yes.
13:44:30 <zeta_0> is it this one? https://hackage.haskell.org/package/sbv-8.6/docs/Documentation-SBV-Examples-BitPrecise-MergeSort.html#v:merge
13:44:43 <dmwit> Almost certainly no.
13:44:45 <dsal> zeta_0: shop less, program more
13:45:01 <dmwit> First of all: this "function" is nondeterministic.
13:45:22 <dmwit> So you need to choose how you want to represent nondeterminism.
13:45:41 <dmwit> Anything you find whose return type doesn't indicate that it can be interpreted as nondeterministic is *definitely* not what you want.
13:45:43 <hololeap> something like Knuth–Morris–Pratt algorithm in parsec?
13:46:38 <dmwit> Second of all: this is such an unusual operation, that it would be quite surprising indeed for it to come prerolled somewhere.
13:47:16 <dmwit> So anything you find should be considered with great skepticism, and its source consulted carefully, to be sure it is actually doing what you need it to do.
13:47:53 <dmwit> Third of all: the operation isn't that hard to write. This means it is almost certainly going to be cheaper to write it yourself than to do the due diligence needed to check whether some other implementation does what you want.
13:49:38 <dmwit> (And all of this is subject to the caveat I said first, which is that implementing this operation probably isn't even a subtask of solving the hackerrank problem you pointed us at anyway.)
13:51:12 <zeta_0> dmwit: i have the shuffle and reverse functions done, i just need to figure out the merge function then i can compose all three together
13:51:46 <maerwald> phadej: https://github.com/haskell/cabal/issues/6528 opinions?
13:52:08 <dmwit> But composing the three does not solve the problem. You know that, right?
13:52:15 <dmwit> Just to make sure.
13:52:18 <phadej> use `ln -s`
13:52:31 <maerwald> what?
13:53:36 <maerwald> we're not talking about the same repo.
13:54:20 <phadej> I'm really not keen to think about anything which involves network
13:54:26 <phadej> sorry
13:54:33 <phadej> if you need it, try to write a patch
13:54:54 <maerwald> Yeah, I think I might. But not if there is not interest and it will be rejected ;)
13:56:20 <phadej> well, in general I'm not excited; yet people want some way to specify "package sets", and there are dozens of ideas to how to start with that
13:56:37 <phadej> e.g. includes to cabal.project files
13:57:27 <maerwald> well, people invented microservices and now you have a few awkward options: 1. mono repo (best idea imo), 2. repo with submodules and cabal.project files, 3. manually syncing
13:58:21 <phadej> or more specifically, I suspect that any option trying to extend what cabal.project files do is extremely painful
13:58:29 <phadej> so I'd rather make that process less painful
13:58:40 <maerwald> hooks? :>
13:59:01 <phadej> I meant more "make hacking on cabal-install nicer"
13:59:06 <phadej> not outside extension
13:59:24 <phadej> I'm really not humorous when it comes to feature request in Cabals, there is 1298 open issues
13:59:42 <maerwald> so many options, exciting!
14:00:23 <phadej> (and I actually concentrate on bug fixing, not making new features, except if the features fix bugs; this one doesn't)
14:01:20 <phadej> I also don't want to be an authority who decies on the features, so I'm conservative and by default reject everything :(
14:01:26 <zeta_0> dsal dmwit : here's what i have so far: https://hastebin.com/uqojabejez.sql
14:01:56 <dsal> zeta_0: The specification suggests that it can't return a string.
14:02:45 <maerwald> phadej: I think a less intrusive hack might be to have a cabal wrapper script that adds --index-state=... to cabal install and friends and have people invoke that instead.
14:03:19 <phadej> you can add index-state to cabal.project, or is it what you want to prevent from copy-pasting?
14:03:26 <maerwald> yeah
14:03:42 <maerwald> the wrapper script could fetch the index state stanza from some gist or so
14:03:50 <phadej> ln -s ~/code/centralconfigrepo/cabal.project.freeze cabal.project.freeze
14:04:02 <phadej> I was serious about ln -s
14:04:05 <maerwald> ln -s doesn't work into the internet
14:04:11 <maerwald> :>
14:04:17 <phadej> FWIW. cabal won't either
14:04:22 <phadej> internet is too slow for interactive use
14:04:29 <phadej> so it would update it once, and be done
14:04:33 <zeta_0> dsal: well i'm stuck then
14:04:46 <phadej> except when you change some hash argument, or something
14:04:54 <phadej> => manual intevention
14:05:20 <zeta_0> dsal: is my merge function at least close?
14:05:56 <dsal> zeta_0: It doesn't return the correct type.
14:06:00 <dmj`> does anyone have any thoughts about language-javascript vs. language-ecmascript
14:06:46 <dsal> zeta_0: It looks like you're writing zip, except it only returns its first argument.
14:06:51 <dsal> Did you try it?
14:08:41 <zeta_0> dsal: it's throwing the error: warning overlapping patterns
14:09:11 <dsal> Well, yes.  Your patterns overlap.  But if you disable that warning, your function ~ const.
14:09:40 <dsal> It's conceptually incorrect, though.  If it only returns one possible arrangement, then it's not returning all possible arrangements.
14:10:04 <zeta_0> dsal: yes it's returning the 1st String, so i guess i am way off
14:11:22 <dsal> I think you meant [] instead of _, but your problem starts on the first line.
14:12:35 <zeta_0> dsal: here's what i have so far: https://hastebin.com/rosuduxusa.sql
14:13:31 <dsal> Line 1 is still wrong.
14:13:34 <dsal> Start on line 1.  :)
14:13:53 <zeta_0> dsal: when i run the function the result is always the same:
14:13:58 <zeta_0> *Main> merge "abc" "def"
14:13:58 <zeta_0> "adbecf"
14:14:02 <dsal> That's the definition of function.
14:14:32 <dsal> If it weren't always the same, this would be #python or something.
14:16:05 <zeta_0> dsal: i thought i needed to take 2 Strings's merge them and then return the merged String?
14:16:46 <zeta_0> dsal: so what do i need to change line 1 to?
14:16:59 <dsal> I gave you the answer several minutes ago.  Scroll up.  :)
14:18:25 <zeta_0> dsal: so my merge function is supposed to return a list of strings?'
14:18:31 <zeta_0> dsal: [String]
14:18:37 <dsal> That's an easy way to do it.
14:19:12 <dsal> There's not one valid merge, there are many.
14:20:12 <zeta_0> dsal: ghci threw an error so i need to fix the implementation: https://hastebin.com/miyiqadafi.sql
14:20:31 <dsal> What does "threw an error" mean?
14:20:55 <dsal> Oh yeah, a function that returns [a] is not the same as the function that returns [[a]].
14:24:32 <zeta_0> ok, so do i need to fix the type signature or the implementation?
14:26:15 <zeta_0> this shouldn't be that hard, i don't know why i am struggling to solve this merge function
14:33:31 <dsal> The signature is fine.  You just have to implement it now
14:36:04 <remexre> tips for debugging an exception deep in a large codebase? I've read https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html , but the stack trace seems to stop at the IO boundary
14:37:42 <zeta_0> dsal: i think the base cases are correct, i just need to fix this part:
14:37:45 <zeta_0> merge (x:xs) (y:ys) = x : y : merge xs ys
14:38:23 <dsal> You want to throw away input?
14:39:08 <amalloy> dsal: is the signature fine? i would have expected [a] -> [a] -> [a], not a -> a -> [a]
14:39:44 <dsal> I suggested [a] -> [a] -> [[a]]    It should return all of the ways to combine its arguments.
14:40:45 <dsal> I didn't read the whole problem, though, just a couple of the definitions.
14:42:17 <dsal> Somehow I can't copy the definition, but it does say there's more than one possible result from merge.
14:43:56 <zeta_0> well this hackerrank problem is marked as advanced, that's probably why i am struggling so much
14:44:14 <zeta_0> lol
14:44:28 <amalloy> oh, apparently i read even less of the problem statement. the signature does indeed look right
14:45:41 <zeta_0> the instructions for this problem aren't very clear
14:47:54 <zeta_0> well the actual function is only supposed to take 1 String as input
14:48:13 <zeta_0> i am trying to figure out merge 1st
16:29:04 <boxscape> hm I'm wondering whether there's a way to write a helper function to avoid all those "Refl -> Refl"s https://i.imgur.com/h5N1xz8.png
16:29:09 <boxscape> (using the equational-reasoning package)
16:30:52 <boxscape> though I'm glad I figured out that you can use case expressions here like this, took me a while...
16:32:19 <Tuplanolla> Am I in #haskell?
16:32:36 <boxscape> this is now #agda-but-in-haskell ;-)
16:33:29 <Tuplanolla> I don't mind, at least as long as it is all ASCII.
16:34:00 <boxscape> yeah I'm staying away from non-ASCII
16:43:20 <jle`> Tuplanolla: lol you weren't joking
16:44:01 <jle`> boxscape: yeah, you can do something like a CPS transformation replace the refl-refl's
16:44:07 <boxscape> hmm, okay
16:44:18 <jle`> _ `by` case p of Refl -> Refl
16:44:22 <jle`> turns into:
16:44:42 <jle`> byCase x p = x `by` case p of Refl -> Refl
16:44:48 <jle`> hm, that wasn't even CPS-y
16:44:49 <boxscape> ah, interesting
16:44:52 <boxscape> thank you
16:44:52 <jle`> byCase _ p
16:44:59 <jle`> or _ `byCase` p
16:45:10 <jle`> the thing you have to be creative with is the type signature of byCase
16:45:18 <boxscape> I can imagine
16:45:21 <jle`> it'll be a rank-n
16:45:31 <jle`> er... maybe not
16:45:42 <jle`> there is a function with a very similar type/type signature in base
16:46:29 <phaazon> damn I’ve forgot
16:46:31 <jle`> boxscape: but yeah, i don't know the type of 'by' so i'm not sure what exactly would work for you
16:46:36 <phaazon> where is (->>) defined again?
16:46:37 <boxscape> is that gcastWith?
16:46:41 <phaazon> I thought it was in Control.Arrow
16:46:43 <phaazon> am I mistaken?
16:46:51 <phaazon> is that comonadic?
16:47:00 <Axman6> @hoogle (->>)
16:47:00 <lambdabot> Graphics.Svg.Attributes (->>) :: Text -> AttrTag -> Attribute
16:47:00 <lambdabot> Data.Active (->>) :: Semigroup a => Active a -> Active a -> Active a
16:47:00 <lambdabot> Data.Pattern.Base (->>) :: Pattern vars a -> Fun vars r -> Clause a r
16:47:03 <jle`> boxscape: but essentially you'd give both sides of :~: as diferent variables, (a :~: b) would be the type of the p argument i think ...
16:47:04 <phaazon> I swear it was defined with >-> and stuff
16:47:08 <jle`> boxscape: yeah, that sounds right
16:47:24 <boxscape> jle` okay, I'll give it a try, thanks
16:47:27 <phaazon> @hoogle (>->)
16:47:27 <lambdabot> Pipes (>->) :: Functor m => Proxy a' a () b m r -> Proxy () b c' c m r -> Proxy a' a c' c m r
16:47:27 <lambdabot> Network.Wai.Middleware.Static (>->) :: Policy -> Policy -> Policy
16:47:30 <phaazon> ah.
16:47:39 <phaazon> I guess it’s from pipes or netwire
16:47:57 <jle`> boxscape: gcastWith is essentially a 'case p of Refl -> Refl'
16:48:08 <jle`> sort of thing
16:48:25 <boxscape> I see
16:50:02 <boxscape> jle` yeah that's a good start, I can replace `case p of Refl -> Refl` with `gcastWith p Refl`
16:53:25 <jle`> ah yeah that works too :)
16:57:51 <eslo> I have a problem with stack. I get ambiguous module name for Data.Functor.Contravariant coming from both base and hs-functor.
16:58:04 <eslo> I don't quite know what to do about this.
16:58:44 <jle`> eslo: which one do you want to use?
16:59:29 <eslo> for contravariant doesnt matter but I need to have both packages as far as i can tell.
17:00:49 <eslo> I believe I use Data.Fix from hs-Functor
17:01:22 <jle`> you can use -XPackageImports to specify which package you want to import that module from
17:03:13 <jle`> the ghc manual has the syntax for that i think
17:03:17 <jle`> i always forget it heh
17:04:30 <eslo> Do you know which portion of the manual? Google fails to give me results it seems.
17:04:46 <eslo> never mind found search and it from manual
17:04:56 <jle`> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
17:05:13 <jle`> i would um
17:05:23 <jle`> file an issue with hs-functor, probably
17:05:35 <jle`> it's hard to justify having a module name that conflicts with a base module
17:05:50 <jle`> since base is pretty much always a package in scope
17:05:59 <jle`> it's impossible to use that module without packageimports
17:06:21 <jle`> mooost likely, hs-functor defined that module in an era before Data.Functor.Contravariant was added to base
17:06:34 <eslo> This seems like It should help. thanks a lot. I will try to see how to make a issue report for them.
17:07:35 <jle`> np
17:08:32 <jle`> although it looks like the last upload was less than a month ago so i'm kind of puzzled
17:09:44 <jle`> Data.Functor.Contravariant has been in base since 8.6, which came out mid 2018
17:10:37 <eslo> specific error is 
17:10:38 <eslo> Control.Hackbus.Trinary
17:10:38 <eslo> not that one 
17:10:44 * eslo sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/XvAMHeeaeGyWHaSRCBivxPXB >
17:10:45 <eslo> thisone
17:10:56 <jle`> and even long before then, the standard home of contravariant functors has been the contravariant library
17:11:13 <dmj`> phadej: ping
17:18:53 * hackage fast-logger 3.0.1 - A fast logging system  https://hackage.haskell.org/package/fast-logger-3.0.1 (KazuYamamoto)
17:29:56 <boxscape> jle` fwiw, the function I ended up with which works perfectly is "byCast :: forall a b x y proxy . (a ~ b => x ~ y) => proxy y -> (a :~: b) -> Reason (:~:) x y; eq `byCast` Refl | Refl <- (Refl :: x :~: y) = eq `by` Refl)"
17:30:33 <boxscape> glad we have QuantifiedConstraints
17:34:14 <boxscape> oh actually it's enough if I instead do "eq `byCast` Refl = eq `by` (Refl :: x :~: y)"
17:41:15 <acertain> anyone know how to manually create a non-updatable thunk? i'd like to use them to force re-computation of some unsafe IO code for reasons
17:42:27 <Axman6> that sounds like () -> a
17:43:09 <Axman6> but, like, don't do any of this, whatever your reasons are, they probably aren't good reasons
17:45:19 <acertain> probably requires some c, i'm just hoping to save some time searching through the rts :)
17:45:23 * hackage thread-supervisor 0.1.0.0 - A simplified implementation of Erlang/OTP like supervisor over thread  https://hackage.haskell.org/package/thread-supervisor-0.1.0.0 (nshimaza)
17:46:22 <dmj`> acertain: could use an MVar for this
17:46:23 * hackage rings 0.0.3 - Ring-like objects.  https://hackage.haskell.org/package/rings-0.0.3 (cmk)
17:48:04 <dmj`> put the unsafe IO action in a loop that blocks on reading a () out of an MVar, other threads can put the () as forcing the eval
17:48:48 <sicklorkin> Axman6: Got a sec?
17:53:19 <Cale> You can also put an IO action in an IORef
17:54:07 * sicklorkin preferred method ^
17:54:30 <Cale> and then to evaluate the thunk, you read the IORef, execute the IO action getting some result v, and write (return v) back into the IORef
17:54:38 <acertain> i don't think this works? like i need to be able to make an element of any type that runs some IO code every time it's evaluated, a la unsafePerformIO
17:55:04 <Cale> Oh, that's very different from what I thought. That's impossible.
17:55:12 <sicklorkin> acertain: looks at Tangles
17:55:18 <sicklorkin> *look*
17:55:38 <sicklorkin> HKD w/memoization and foo-magic
17:55:53 <Cale> But generally, you can expect that the body of a function will not be memoised
17:56:01 <Cale> Except when it is...
17:56:03 <sicklorkin> https://github.com/fumieval/tangle
17:56:07 <Cale> You'll have to ensure it's not inlined
17:56:22 <Cale> So, Axman6's suggestion is basically the idea
17:56:42 <Cale> But... why?
18:01:07 <acertain> so there's using unsafePerformIO to lazy deserialize, but i want to be able to drop/gc parts of the heap (that can be deserialized again if needed)
18:01:20 <acertain> https://github.com/grin-compiler/ghc-grin/blob/master/ghc-8.6.2/compiler/codeGen/StgCmmClosure.hs#L817 imilpes this might be possible
18:02:05 <sicklorkin> acertain: What'cha building over there?
18:02:39 <acertain> seeing if it's possible to have vcache but more magic
18:02:52 <acertain> (work better with existing datatypes)
18:03:28 <julianleviston> I’m mucking around with megaparsec, building up an understanding of its pieces. I wanted to build a parser that parses “hi” then at least one space, then “yay”. Seemed pretty simple to me. I used this… sc = MCL.space MC.space1 (MCL.skipLineComment "//") (MCL.skipBlockComment "/*" "*/") to define my space parser, then my lexeme as lexeme = MCL.lexeme sc and finally my test function as demo = M.parseTest $ 
18:03:28 <julianleviston> (lexeme "hi") >> (lexeme "yay")
18:04:00 <julianleviston> however… that lets me write demo “hiyay” and it succeeds.
18:04:03 <sicklorkin> acertain: fun
18:04:57 <jaja> anybody's hiring in turkey by any chance?
18:05:13 <sicklorkin> jaja: remote work, sure.. pm me
18:11:29 <julianleviston> Oh I see what the problem is… the space combinator is defined as space sp line block = skipMany $ choice [hidden sp, hidden line, hidden block]
18:12:10 <hololeap> in a wai Application, how would you handle an exception where you don't get a Response connection closed early or timeout? would it just be thrown to IO?
18:12:43 <julianleviston> I want one that uses skipSome. Thanks for being my rubber duck everyone :)
18:14:18 <julianleviston> hololeap: I think it’s handled on a different thread, from memory (at least, using Snap that’s been the case for me), so you have to handle it in the handler if you want to ahndle it.
18:15:27 <hololeap> ok that makes sense
18:15:49 <julianleviston> Actually, I don’t think Snap uses WAI by default, so disregard that.
18:17:37 <sicklorkin> hololeap: i tink it must work just liek http-cleint does =- look at the settings for conection, req/respose ( but in ur case aplication)
18:17:53 <julianleviston> This might help tho http://hackage.haskell.org/package/wai-middleware-catch-0.3.6/docs/Network-Wai-Middleware-Catch.html
18:17:54 <sicklorkin> https://hackage.haskell.org/package/warp-3.0.4/docs/Network-Wai-Handler-Warp.html
18:17:57 <julianleviston> and this https://github.com/haskell-servant/servant/issues/1192
18:24:27 <hololeap> oh, setOnException :: (Maybe Request -> SomeException -> IO ()) -> Settings -> Settings
18:24:35 <hololeap> thanks for pointing that out, sicklorkin
20:37:38 <chew2> hey everyone, I was trying to get GHC to infer a num literal to be the same type as what I specified in my type signature, but it wants to default it to Integral instead. Does anyone know how to solve this? I thought scoped type variables would be able to help here but it didn't seem to work https://gist.github.com/stevenfontanella/cc64ba7a761de9b0f715c76c782a365a
20:37:57 <chew2> sorry it wants to default it to Integer*
20:38:07 <chew2> I would like it to keep it as Integral instead
20:38:43 <glguy> Yes, scoped type variables would have helped there
20:40:02 <chew2> could you explain a bit more cause I tried that but I may be using it wrong
20:41:33 <glguy> You'll have to be explicit about your quantifier: distSq :: forall n. Integral n => [n] -> [n] -> n
20:42:08 <ephemient> :t (^)
20:42:09 <chew2> ok cool I'll try that
20:42:10 <lambdabot> (Integral b, Num a) => a -> b -> a
20:42:32 <ephemient> the type of exponent doesn't need to match the base anyway?
20:42:33 <chew2> ah wonderful that fixed it
20:42:38 <chew2> thanks glguy 
20:43:21 <chew2> ephemient: hmm I would think so but if I leave it as is, it wants to force the 2 to be Integer
20:43:30 <glguy> and that's just fine
20:43:58 <chew2> yeah maybe it is haha I didn't really think about it
20:44:03 <ephemient> you could write (2 :: Int) if you wanted
20:44:30 <chew2> I guess I wanted maximum generality even though it wouldn't make a performance difference or anything
20:44:32 <ephemient> or replace `^ 2` with `join (*)` :)
20:44:40 <chew2> lol true
20:44:52 <glguy> There's already a rewrite rule for ^2
20:44:53 <glguy> "^2/Integer"    forall x. x ^ (2 :: Integer) = let u = x in u*u
20:45:48 <chew2> I'm guessing that happens after type checking though?
20:47:25 <glguy> Yup, which means it will work in your case either way
20:49:19 <glguy> Oh, well actually if you didn't the scoped type variables solution then it wouldn't be as efficient
20:50:09 <chew2> because Integer is slower than Int?
20:50:31 <glguy> Because when you use scoped type variables you defer figuring out what type that will be
20:50:38 <glguy> so the rewrite rule won't apply
21:13:53 * hackage format-numbers 0.1.0.1 - Various number formatting functions  https://hackage.haskell.org/package/format-numbers-0.1.0.1 (AlexanderThiemann)
21:51:00 <jsomedon> if I want to ask for advice on grad programs(like looking for what schools in what country/area has what program, andcareer outcome after grad school etc) is this right place to ask, is there like mailing list/online forum/things-like-that that I can ask such questions
21:53:40 <heatsink> Are you enrolled in a school that has faculty with phds or a career center?
21:54:08 <jsomedon> nope I am not in school anymore I am working now
21:54:24 <heatsink> ok
21:56:20 <jsomedon> most programs I see are either in north america or europe, and that was ok for me, until right now my mom just got sick and now I am seriously considering if I should give up my passion on things like functional programming
21:56:51 <jsomedon> I live in asia so I don want to leave my mom alone here
21:58:11 <jsomedon> then I though maybe there are still researchers on this in asian schools, I just need to try find them, hence I am asking here
21:59:00 <heatsink> Functional programming as a research subject is quite a small topic
21:59:44 <heatsink> There used to be FP researchers in UNSW
22:00:20 <heatsink> that's closer than US and europe
22:00:28 <jsomedon> ah yes
22:00:35 <jsomedon> much closer
22:02:13 <mac10688> Hello, does anyone know what it means when a module exports another module? https://www.stackage.org/haddock/nightly-2020-02-13/vty-5.26/src/Graphics.Vty.Attributes.html#Attr
22:02:28 <mac10688> I want to use functions from the color module but cabal says it's hidden
22:03:23 <heatsink> mac10688: It re-exports everything from that module
22:04:21 <mac10688> if it rexports that module, I can I use funstions from it? I want to use the rgb function in particular
22:04:44 <heatsink> jsomedon: When looking for grad schools, you should look for faculty that are potential advisors
22:08:49 <heatsink> mac100688: Re-exports are just exports.  Attributes doesn't export Color.  It exports the things that Color exports.
22:09:23 <heatsink> mac100688: It lets you refer to all of Color's exports as if they were Attributes's exports
22:10:50 <mac10688> thanks heatsink, I just found my issue. In online documentation, it says it defines a function `rgb` but when I look at the source it only export `rgbColor`. So I was trying to use a function that wasn't exported
22:10:55 <jsomedon> heatsink: yep I should definitly do that
22:11:32 <mac10688> actually that's wrong too heatsink . there was no function `rgb`. Reading is hard
22:12:36 <heatsink> glad that's solved
22:13:03 <jsomedon> so for ICFP, how are the responsibilities of "Program Committee" and "External Review Committee" are different? I see some people located in asian institutes on both list
22:14:20 <heatsink> External reviewers review paper submissions, and that's all.
22:15:04 <heatsink> The program committee meets in person to make final decisions about what papers to accept.  I believe they have other administrative responsibilities too.
22:15:17 <jsomedon> oh
22:19:18 <jsomedon> So I guess people on either list are at least 1. experienced enough on this topic 2. still working on this topic these days
22:20:14 <jsomedon> I mean there is good chance that they could potentially be phd advisors?
22:26:53 * hackage bech32 1.0.1 - Implementation of the Bech32 cryptocurrency address format (BIP 0173).  https://hackage.haskell.org/package/bech32-1.0.1 (JonathanKnowles)
23:20:58 <cole-k> when was (<>) added to Prelude?
23:28:30 <iqubic> cole-k: A long while ago.
23:46:53 * hackage HsWebots 0.1.0.0 - Webots bindings for Haskell  https://hackage.haskell.org/package/HsWebots-0.1.0.0 (junjihashimoto)
