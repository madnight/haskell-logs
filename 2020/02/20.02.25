00:00:04 <monochrom> To be fair, in Haskell, you do have to use functions of types like Double->Double->Double and you still can make parameter order mistakes.
00:00:09 <koz_> nshepperd: If not >40.
00:00:40 <nshepperd> maybe even >40 is too optimistic
00:00:47 <koz_> Unfortunately.
00:00:50 <jol> yushyin: Don't think so. :P I'm making a CLI client like nmh, but there's still a long ways to go.
00:00:51 <refusenick> jle`: We have instant access to all of the world's info on the Internet and universal education as a pipeline to bring the most talented from the crowd to study math all day in universities. Maybe there's still much to be discovered, but it's probably too much for one human to handle.
00:01:01 <iqubic> While I do think it's good to worry about issues that might plauqe us in the future, I don't think this inquiry into what comes next after von Neumann architecture is going to be very productive. Quantum computers are still 20-30, maybe even 40 years away. Besides quantum and von Neumann architectures are not even mutually exclusive.
00:01:01 <refusenick> The low hanging fruit's gone.
00:01:04 <jle`> yea but i can handle it
00:01:20 <jle`> miss me with that pessimism
00:03:05 <iqubic> refusenick: We aren't giving you straightforward answers for because you haven't been very specific in what you are asking. Furthermore, none of us know the answers to these questions. It's still far far too early to even begin speculation on this topic.
00:03:11 <monochrom> Haha did jle` just declare he will be the next Gauss-like?  "i can handle it. challenge accepted"
00:03:16 <iqubic> s/for//
00:03:34 <koz_> monochrom: Let's support jle` into becoming Gauss-2.
00:04:10 <jle`> i'm only like 30 years behind gauss
00:04:13 <iqubic> I don't know what von Neumann is. Should I learn that?
00:04:15 <jle`> i can catch up
00:04:15 <nshepperd> he already is Gauss-2, we just don't know it yet
00:04:31 <jle`> iqubic: imagine gauss but he made the atom bomb
00:04:31 <nshepperd> or, i guess we do now since he told us
00:04:36 <refusenick> jle`: I'm 20 years old right now and wondering what computing (and everything else) will look like in my adult life. Moreover, I've grown up in a family of scientists and have seen the explosion in new approaches to computing at the lowest levels of physics and materials science within the past few years. Now is the time to consider what a world where vN arch isn't totally dominant will look like.
00:05:05 <koz_> refusenick: So what you're asking is 'can Haskell be part of my Anders Sanberg fantasy'?
00:05:06 <yushyin> jol: too bad, there are only two usable notmuch frontends. alot (in python) and astroid (in C++ but is a GUI frontend which uses webkit to render emails). Both are super slow to use and buggy too. I do would like a better frontend, hrhr.
00:05:28 <koz_> The answer to this is 'depends on the parameters of said Anders Sanberg fantasy'.
00:05:48 <koz_> This is a question _so far beyond_ what we deal with as a reality of Haskell that I don't think any of us can answer it.
00:05:56 <koz_> (also I may have spelled Anders' surname wrong)
00:06:01 <refusenick> Okay, here's a well-founded technical question:
00:06:11 <mjrosenb> refusenick: have you seen how Shor's algorithm works?
00:06:11 <iqubic> koz_: That was the right spelling.
00:06:15 <monochrom> Sandberg?  futurist and transhumanist?!
00:06:30 <koz_> iqubic: According to monochrom, not so much. :P
00:06:38 <refusenick> Has anyone given a proper construction of the category Hask and shown how it can be mapped to the category of stochastic relations?
00:06:39 <koz_> And since they _are_ a bot, they can't make spelling errors.
00:06:55 <iqubic> Right...
00:07:00 <koz_> Do stochastic relations _form_ a category?
00:07:06 <refusenick> koz_: yep
00:08:01 <iqubic> koz_: I don't think anyone can predict what computing will be like in 30 years.
00:08:17 <refusenick> If Haskell code can be shown to be safely executable on probabilistic architectures, that's something C++, Python, Go, Lisp, Smalltalk, etc can not and will not do.
00:08:28 <koz_> iqubic: Perhaps I should have said 'Anders Sandberg-style fantasy'.
00:08:44 <koz_> refusenick: What are the morphisms of said category?
00:08:53 <refusenick> probabilistic computing isn't that far-fetched. We're already making hardware accelerators for it.
00:09:18 <refusenick> koz_: https://www.thenewflesh.net/2020/02/12/algebra-of-POMDPs.html
00:10:44 <iqubic> Honestly, I feel like a lot of the indunstry is full of programming and computing buzz words intended to trick people into thinking that these changes are coming faster than they really are.
00:11:01 <koz_> THIS.
00:11:10 <iqubic> things are crawling along at a snail's pace. Maybe even slower than that.
00:11:42 <koz_> As for that link, I'm gonna let one of the category-theory-literate folks here field it.
00:12:04 <koz_> Since I know category theory like bears know vodka and balalaikas.
00:12:10 <refusenick> iqubic: You'll have to take me on my word for this and nothing more, but I've grown up around scientists. I can't give you the precise details of what will happen because no one can, but things are happening.
00:12:33 <refusenick> A materials scientist, to be specific.
00:12:39 <timCF> Hi guys! I have a question, probably noob, but I can't find answer in official docs. How I can compose 2 WAI applications? I'm looking for something like monoid instance for Wai.Application, or just function of type Application -> Application -> Application
00:13:07 <mjrosenb> refusenick: yes, and things have been "happening" since the 60's, and we really aren't moving any faster now than we have been at any point in the past 60 years.
00:13:26 <refusenick> Here's a hard number: clock speeds haven't gone up since the early 2000s.
00:13:42 <refusenick> As soon as that happened, research money started trickling in for new ideas.
00:14:18 <mjrosenb> which has given us great gains in parallel computing
00:14:23 <refusenick> Of course marketers making loud noises about "innovation" weren't going to do anything, but the numbers speak for themselves.
00:14:45 <dminuoso> timCF: Composing applications does not make sense, really.
00:14:49 <dminuoso> timCF: What does it mean to compose two applications?
00:15:12 <iqubic> refusenick: You said just now "I can't give you the precise details of what will happen because no one can" But it seems to me like you are asking us for our opinions on the future of computing. That seems rather contradictory to me.
00:15:19 <refusenick> mjrosenb: That's just the start. I don't know which experimental idea will turn out successful first, but for a lot of them, we don't have programming models yet.
00:15:21 <dminuoso> timCF: Is write and compose middlewares. Is that what you were thinking about?
00:15:30 <dminuoso> *You can write and compose
00:15:41 <timCF> dminuoso
00:16:01 <timCF> let's say I have some functionality which I want to share between different WAI apps
00:16:09 <refusenick> With neuromorphics, for example, we're at the stage where ENIAC was before von Neumann suggested storing the program in memory: rewiring the hardware for new programs.
00:16:33 <monochrom> @type ($) . ($)
00:16:35 <lambdabot> (a -> b) -> a -> b
00:16:43 <refusenick> The best bet is to have the most mathematically general language which can be mapped to the most execution models.
00:16:47 <iqubic> :t ($)
00:16:50 <lambdabot> (a -> b) -> a -> b
00:16:54 <iqubic> What?!?!
00:17:02 <refusenick> That means having the language which can most rigorously describe and prove its own properties.
00:17:24 <iqubic> I'm not sure why you claim that's the best bet.
00:17:58 <refusenick> iqubic: Everything else is a shot in the dark. What if you put all your eggs in the basket of quantum computing and DNA computing instead makes a resurgence?
00:18:19 <refusenick> (not that it will - that one probably won't, but who knows?)
00:19:53 <refusenick> It'd be a crying shame if an attempt at mathematical purity in the name of reliability and portability like Haskell was hamstrung by its dependence on a particular compiler for vN architectures with specific features like pipelining haphazardly tacked atop it.
00:20:49 <refusenick> Okay, I'm done.
00:20:57 <dminuoso> timCF: What kind of functionality is that?
00:21:00 <iqubic> I understand that you feel these are valid concerns. I really do. I just think that you have your time scale off. I don't think these issues are going to need to be addressed for at least 20-30 years.
00:21:25 <koz_> And frankly, _nobody_ knows the right answers to these questions.
00:22:03 <koz_> I care about Haskell because of what I have to deal with _now_. I'll leave speculation to the Anders Sandbergs of this world.
00:22:32 <iqubic> The right answer to these questions can only come after years of experiments and hundreds of failed attempts. Trying to get it right, and trying to do it fast is a complete folly.
00:22:43 <koz_> s/hundreds/thousands/
00:23:09 <iqubic> s/years/decades/
00:23:16 <refusenick> iqubic: It's commonly cited as a point of inspiration that Edison repeatedly tried and eventually succeeded despite sucking at math.
00:23:38 <refusenick> Tesla insulted him by saying that he could have avoided most of the work if he had used a little math.
00:24:01 <opticblast> ($) is just id, and id . id is id
00:24:29 <dminuoso> TO be fair, ($) is a specialized id. :)
00:24:33 <refusenick> If someone asked me "what's the point of Haskell?", that's roughly in the vein of what I'd argue.
00:24:35 <opticblast> (or rather it's id specialized to functions)
00:24:48 <dminuoso> % :t flip id
00:24:49 <yahb> dminuoso: forall {b} {c}. b -> (b -> c) -> c
00:24:49 <monochrom> Composing applications is therefore idempotent. >:)
00:25:07 <iqubic> % :t flip (flip id)
00:25:08 <yahb> iqubic: forall {b} {c}. (b -> c) -> b -> c
00:25:17 <iqubic> There. The exact same type signature.
00:25:25 <opticblast> % :t id
00:25:25 <yahb> opticblast: forall {a}. a -> a
00:25:38 <iqubic> a ~ (b -> c)
00:25:43 <opticblast> flip . flip isn't id?
00:25:49 <iqubic> Oh it is.
00:25:53 <koz_> :t flip . flip
00:25:55 <lambdabot> (b -> a -> c) -> b -> a -> c
00:26:17 <iqubic> It's a specialized form. But it's id nevertheless.
00:26:42 <refusenick> monochrom: http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm
00:26:53 * hackage rings 0.1.2 - Ring-like objects.  https://hackage.haskell.org/package/rings-0.1.2 (cmk)
00:26:55 <jle`> @. djinn type flip . flip
00:26:57 <lambdabot> f a = a
00:27:13 <iqubic> Also, it feels so good to be done waxing metaphysically about the future of computing and talking about actual haskell right now.
00:27:28 <refusenick> There are ways to compose functional programs. Unfortunately, most Haskell programs aren't functional because they have the IO monad at the edges.
00:27:35 <dminuoso> opticblast: Well it is id, but even further specialized.
00:28:03 <sQVe> What recommendations do you guys have for linting / formatting etc for Haskell? There's so many different applications for it.
00:28:06 <iqubic> refusenick: That headline looks so much like clickbait for the acquired programmer. I'm not going to read it.
00:28:07 <dminuoso> opticblast: If you play the unification game for `flip id`, it should be obvious why `(flip . flip) id` has the type it has.
00:28:17 <dminuoso> sQVe: Nothing at all.
00:28:32 <refusenick> iqubic: Do you know what it's referring to?
00:28:32 <dminuoso> sQVe: I use haskell-stylish just for ordering imports, and that's it. :)
00:28:43 <iqubic> refusenick: I do actually.
00:28:50 <opticblast> so id is not specialized, ($) is specialized to functions, and flip is specialized to functions of <1 arguments
00:28:52 <dminuoso> I think most tools that tell you "this looks non-idiomatic" are made for someone else.
00:29:06 <dminuoso> opticblast: all functions have just 1 argument.
00:29:07 <koz_> sQVe: I like HLint personally.
00:29:11 <opticblast> yes, currying
00:29:17 <iqubic> But I'm not going to read it, because it's attempting a question that I feel we aren't even ready to ask.
00:29:19 <dminuoso> opticblast: Not currying. It's just a fundamental truth.
00:29:20 <opticblast> I use hlint because otherwise my do-blocks look horrible
00:29:24 <refusenick> iqubic: Then you know that Backus, the creator of Fortran, despised it so much that he started the events that lead to Haskell.
00:29:33 <refusenick> I'm mostly echoing what he said.
00:29:39 <opticblast> flip doesn't work on uncurried functions
00:29:47 <dminuoso> Sure it does.
00:29:53 * hackage mmsyn7s 0.3.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.3.0.0 (OleksandrZhabenko)
00:29:54 <monochrom> sQVe: Haskell has the effect of improving your aesthetic sense.  Your best styling tool is yourself.
00:30:04 <dminuoso> opticblast: It's unrelated to the idea of currying.
00:30:07 <iqubic> :t flip (uncurry id)
00:30:09 <lambdabot> b1 -> (b2 -> b1 -> c, b2) -> c
00:30:09 <opticblast> so to be more precise, flip is specialized to functions which return functions
00:30:12 <monochrom> or rather s/yourself/your own judgment/
00:30:15 <dminuoso> opticblast: Currying is not about haskells type system, it's a way to encode a concept inside it.
00:30:21 <iqubic> There. I got it to work on an uncurried function.
00:30:33 <jle`> flip will not flip the arguments to a function taking a tuple
00:30:42 <jle`> it will only work if you curry that function
00:30:42 <sQVe> monochrom: I prefer to not think about formatting at all. I'm a bit too OCD for it.
00:31:10 <sQVe> What is the main difference between say hlint and hindent/stylish-haskell?
00:31:18 <jle`> @let myUncurriedFunction :: (Int, Int) -> Int; myUncurredFunction (x, y) = x - y
00:31:20 <lambdabot>  .L.hs:250:1: error:
00:31:20 <lambdabot>      The type signature for ‘myUncurriedFunction’
00:31:20 <lambdabot>        lacks an accompanying binding
00:31:20 <opticblast> hlint doesn't format anything
00:31:25 <jle`> @let myUncurriedFunction :: (Int, Int) -> Int; myUncurriedFunction (x, y) = x - y
00:31:29 <lambdabot>  Defined.
00:31:32 <opticblast> it just gives suggestions
00:31:33 <jle`> > flip myUncurriedFunction (1,2)
00:31:36 <lambdabot>  error:
00:31:36 <lambdabot>      • Couldn't match type ‘Int’ with ‘(Integer, Integer) -> c’
00:31:36 <lambdabot>        Expected type: (Int, Int) -> (Integer, Integer) -> c
00:31:37 <jle`> whoops, no good
00:31:52 <sQVe> opticblast: Gotcha. Thank you!
00:31:58 <opqdonut> > (myUncurriedFunction . uncurry (flip (,))) (1,2)
00:31:58 <monochrom> For example unlike C++ which makes it legal (though inadvisable) to write like "class Complex { Complex() { cout << "please enter the real part:"; ...", therefore there needs style guides to tell you "please don't do that".  In Haskell, that's downright illegal.
00:31:59 <jle`> > (. swap) myUncurriedFunction (1,2)
00:32:01 <dminuoso> opticblast: My point is, the notion of "currying/uncurrying" is not some fundamental truth about our type system. What the unification of flip is about, is rather about *polymorphism* and *type unification*
00:32:01 <lambdabot>  1
00:32:02 <lambdabot>  1
00:32:08 <opqdonut> oh right I forgot swap has a name these days
00:32:23 * hackage mmsyn7s 0.3.0.1 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.3.0.1 (OleksandrZhabenko)
00:32:27 <monochrom> (Based on a true story.  I have seen mediocre C++ students doing that.)
00:32:30 <dminuoso> opticblast: All of this is about type variables, polymorphism and type unification. It has absolutely nothing to do with currying or uncurrying. :)
00:33:06 <opticblast> Is this the unification you're talking about? http://dev.stephendiehl.com/fun/006_hindley_milner.html#unification
00:33:12 <timCF> dminuoso this functionality is pre-defined set or routes/controllers, for example **/health-check** which I want to embed to other apps, share it the way it will be embedded to routing schema of other apps and behave the same way
00:33:45 <iqubic> monochrom: Are they putting IO functions into a constructor?!?!
00:33:49 <dminuoso> timCF: I see.
00:33:52 <monochrom> Oh, formatting, that's easy, just go with https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md , I recommend this to my students too.
00:34:11 <monochrom> Yes iqubic, that's right, someone thought that constructor is where you ask users.
00:34:50 <opticblast> I don't understand how flip (uncurry id) typechecks. flip takes a function :: (a -> b -> c), and uncurry id is a function (b -> c, b) -> c
00:34:55 <Ferdirand> monochrom: that's a hilarious story
00:35:03 <monochrom> In fact, let me make it sound completely horrendous: constructor is where you hard code the logic of asking users.
00:35:53 <dminuoso> timCF: Do you need both to be WAI applications? That is, are they completely different applications?
00:36:31 <iqubic> My computer science professor from last quarter would take off points if he saw any IO at all in class definitions other than our main application class. Each project would have a list of classes where IO was allowed. Deviate from that and you lose a lot of points.
00:37:20 <dminuoso> "main application class"?
00:37:36 <opticblast> Java, maybe?
00:37:45 <dminuoso> Well "IO" ...
00:37:46 <iqubic> I meant class where the main method was. And this was in fact Java.
00:38:02 <dminuoso> Ah. So IO in the sense of what IO captures, rather the actual type IO
00:38:13 <monochrom> You need to write "I/O".
00:38:32 <dminuoso> % :t id
00:38:32 <yahb> dminuoso: forall {a}. a -> a
00:38:33 <dminuoso> % :t uncurry id
00:38:34 <yahb> dminuoso: forall {b} {c}. (b -> c, b) -> c
00:38:36 <iqubic> Yes. By IO I meant stuff like println and reading from a file and stuff.
00:38:38 <opticblast> % :t flip . flip $ uncurry id
00:38:38 <yahb> opticblast: forall {b} {a} {c}. (b -> a -> c, b) -> a -> c
00:38:49 <iqubic> Nice.
00:39:04 <dminuoso> opticblast: ^- Just stick to `uncurry id` - is that type clear so far?
00:39:04 <monochrom> Err what did you all do to yahb to make it be so curryful...?
00:39:15 <dminuoso> opticblast: And why it is that type?
00:39:19 <dminuoso> opticblast: Do the unification on paper.
00:39:46 <monochrom> % uncurry your type variables please
00:39:46 <yahb> monochrom: ; <interactive>:95:14: error: parse error on input `type'
00:40:05 <monochrom> Oh wait, I'm drunk, curry != curly
00:40:07 <timCF> dminuoso it might be something else, but I think Wai.Application is most common part between Haskell web infrastructure. Basically I want to write these **/health-check** style controllers using for example Scotty and share them in for example Yesod app. The simplest thing which Scotty and Yesod share is Wai.Application, so I was thinking it's
00:40:08 <timCF> possible to compose them as monoids. If it is stupid idea, sorry 😀
00:40:24 <dminuoso> timCF: No, the idea is perfectly valid.
00:40:30 <opticblast> % :t uncurly
00:40:31 <yahb> opticblast: ; <interactive>:1:1: error:; * Variable not in scope: uncurly; * Perhaps you meant `uncurry' (imported from Prelude)
00:40:32 <dminuoso> timCF: Just wanted to make sure that this is truly what you wanted.
00:40:34 <iqubic> monochrom: Weren't you high an hour ago?
00:40:51 <monochrom> I was?  I don't remember...
00:41:05 <monochrom> Where am I?
00:41:13 <iqubic> Oh. I thought you said something about programmers and coke.
00:41:59 <dminuoso> timCF: http://hackage.haskell.org/package/wai-lite-0.2.0.0/docs/Web-Simple-Router.html
00:42:07 <dminuoso> timCF: You can either take that library or take inspiration from it.
00:42:20 <timCF> dminuoso thanks!
00:43:15 <opticblast> % :t uncurry
00:43:16 <yahb> opticblast: forall {a} {b} {c}. (a -> b -> c) -> (a, b) -> c
00:43:22 <opticblast> dminuoso: a :: b -> c
00:43:37 <dminuoso> What is that supposed to mean?
00:44:05 <opticblast> when you apply uncurry to id, it forces a to have a certain relationship to b and c?
00:44:21 <opticblast> wait no a is a type not a variable
00:44:23 <dminuoso> Maybe its good practice to learn how unification works.
00:44:37 <dminuoso> Start by renaming type variables so they dont clash, this is just for your own sanity
00:45:07 <raymyname> I have a question. from the state monad chapter of haskell wikibook. why does 'evalState rollDie (mkStdGen 0)' work but not 'evalState $rollDie (mkStdGen 0)'  or 'evalState (rollDie (mkStdGen 0))'  ?
00:45:20 <Cale> opticblast: In uncurry :: (a -> b -> c) -> (a,b) -> c, the "a" is a type variable
00:45:41 <opticblast> I know how to find the types of expressions
00:45:41 <dminuoso> raymyname: What is the type signature of evalState?
00:45:55 <Cale> raymyname: because evalState takes two arguments
00:45:55 <opqdonut> raymyname: because `evalState rollDie (mkStdGen 0)` is `((evalState rollDie) (mkStdGen 0))`
00:46:03 <opticblast> I just haven't learned the way that people communicate that process to each other
00:46:35 <refusenick> Function composition is a lot like piping things in Unix (in no small part because Doug McIlroy lifted pipes from APL, which also inspired Backus's idea of functional programming and ultimately Haskell). Is Haskell a good candidate for a shell utility which processes external structured data (like JSON or XML) into plaintext commands?
00:46:39 <opticblast> I have a paper with circles and arrows, and the result is uncurry id :: (b -> c, b) -> c
00:46:41 <raymyname> ah okay yeah got it .. i got my associations wrongs. thanks Cale , opqdonut 
00:47:10 <refusenick> In other words, is there a purely-functional I/O solution for interacting with stdout?
00:47:17 <refusenick> (and stdin too)
00:47:31 <opticblast> is turtle relevant? https://hackage.haskell.org/package/turtle
00:47:44 <opticblast> or is this more of a theoretical question?
00:48:06 <refusenick> opticblast: practical
00:48:26 <opticblast> "turtle comes with built-in support for the standard text streams"
00:48:29 <refusenick> I'd like to start by writing some utilities before I try my hand at an interactive graphics DSL
00:48:37 <opticblast> https://hackage.haskell.org/package/turtle-1.5.16/docs/Turtle-Tutorial.html
00:48:58 <Cale> refusenick: Sure, there are a ton of libraries which might help depending on exactly what you're trying to do, but the I/O stuff in base is also fairly reasonable.
00:49:11 <monochrom> Haskell is a good candidate for processing structured data into structured data.  By the way you really don't want commands to be plain text.  The minimum, barely acceptable structure is list/array of text, and even that is only barely acceptable.
00:50:08 <opticblast> not a suggestion to use turtle so much as a demonstration that it can be done
00:50:12 <refusenick> monochrom: That's why I'm asking about purely functional I/O which doesn't end at program boundaries with the IO monad.
00:50:21 <Cale> I would say it depends on what your goal is... it can be fine to consume and produce text in different forms, but you may want some sort of intermediate representation which is not text...
00:50:39 <opticblast> What does "purely functional I/O" mean?
00:51:18 <opticblast> That the stdout is a pure function of stdin?
00:51:20 <Cale> Does the IO monad not count somehow?
00:51:42 <refusenick> opticblast: A way to do what Cale said. If a Haskell program can produce a final result or return structured data if it can't do the right thing and you get structured data, compose it with another pure program which does give a definitive result.
00:52:04 <Cale> You might be interested in functional reactive programming systems, though if you're a beginner at Haskell, that's a bit like diving off the deep end :D
00:52:08 <opticblast> IO can use system calls, so it doesn't make pure functions from stdin to stdout
00:52:58 <refusenick> Cale: That's what I was thinking. Of course, this is purely discrete, so perhaps something like the machinecell would work?
00:53:09 <Cale> https://github.com/reflex-frp/reflex-ghci Here's a wrapper for ghci that a coworker and I wrote, with a terminal UI interface that separates program output from ghci output
00:53:09 <refusenick> the machinecell library*
00:53:13 <opticblast> Maybe you want a library like streamly, using the IO monad to interface with stdin and stdout?
00:53:34 <Cale> and has a nice draggable splitter with scrollable panes
00:53:37 <opticblast> (where the stream function you write would then be pure)
00:53:42 <merijn> You can't even access stdin without doing system calls
00:53:58 <merijn> So I'm not sure how that could ever work
00:54:26 <opticblast> Observationally, most programs don't have a stdout that's a pure function of stdin
00:54:41 <opticblast> But such programs are possible to make. It's just that the IO monad doesn't enforce this
00:54:45 <refusenick> merijn: We can't formally prove that it's pure, but I imagine certain additional guarantees could be given under restricted conditions following from the POSIX standard.
00:55:13 <opticblast> If you use a thin IO wrapper which you can prove or convince yourself doesn't read files or anything, and connect that to a pure function
00:55:36 <refusenick> opticblast: That's kind of what I was thinking of. I'll take a look at streamly.
00:55:39 <Cale> In the process of writing that, we wrote reflex-vty (a terminal UI library) https://github.com/reflex-frp/reflex-process (a simple way to talk to an external process with reflex) and reflex-fsnotify (a way to get an event which reflects filesystem changes)
00:55:42 <opticblast> Then you can be reasonably certain that your program has an output which doesn't depend on anything except stdin, under normal operating conditions of course
00:56:17 <refusenick> What's that term for the minimal trusted code that they use in OS verification?
00:56:26 <refusenick> Or was it proof checkers?
00:56:27 <monochrom> Cale: I misread yours as "dagger and scroll" and this suddenly reminded me of medieval-themed RPGs
00:56:43 <Cale> haha
00:57:05 <Cale> https://github.com/reflex-frp/reflex-ghci/blob/develop/src/Reflex/Process/GHCi.hs -- here's what the meat of talking to GHCi interactively looks like
00:57:08 <opticblast> trusted computing base, maybe?
00:57:35 <refusenick> opticblast: That sounds right.
00:58:34 <refusenick> I guess if you're putting SeL4 on a microcontroller for a plane engine which has to work right, doing that for the whole OS makes sense, but I don't see how I could do better than this for shell utilities in Haskell.
00:59:12 <refusenick> Is there a standard way to compose programs otherwise? Merge them into one instead of piping output from one's IO monad to the other's?
00:59:26 <Cale> It's basically a state machine of sorts, there's a type Status which represents what our program thinks GHCi's status is, and you can search for holdUniqDyn to find the line where we define the dynamically changing thing that represents the current status in terms of a bunch of events.
00:59:45 <merijn> refusenick: Only if you're going to embed a type system in your OS/processes
01:00:14 <refusenick> merijn: Is there a way to declare to the type system "trust me, I know this is safe"?
01:00:51 <Cale> (maybe at some point we're rework this to use the GHC API, but for now, it just looks at the textual output of GHCi to determine what's going on)
01:00:55 <refusenick> Cale: Is it like AFRP?
01:01:00 <Cale> we'll*
01:01:08 <Cale> It's (non-A) FRP
01:03:15 <refusenick> Has FRP been used for signal processing or other kinds of non-UI analog data?
01:03:56 <Cale> I've used it to control AIs in a game world, if that counts
01:04:21 <Cale> also, to interpret multitouch input
01:04:29 <Cale> (though that's kinda UI-ish)
01:05:03 <refusenick> I have an upcoming project in my physics class (fluid mechanics) where we'll need to make an instrument and measure its resonance properties. Maybe it'd be a good demonstration of basic Fourier analysis?
01:05:16 <refusenick> (obviously I could throw Python at it, but that's no fun)
01:05:55 <Cale> I haven't done much audio signal processing with FRP (yet), but I actually intend to try some soon
01:07:19 <Cale> Just to see how it goes. It might go poorly, latency wise, but I don't really know for certain. Using Reflex for doing ByteString I/O with various processes has been going fairly well, and I have an audio processing project in mind, so that convinced me I should probably give it a shot.
01:08:53 <Cale> (We normally use Reflex for controlling frontends of web and mobile applications)
01:09:20 <iqubic> Is Reflex in hackage?
01:09:23 <Cale> Yeah
01:09:32 <iqubic> Is Reflex-DOM in hackage?
01:09:40 <Cale> https://hackage.haskell.org/package/reflex
01:09:42 <iqubic> Or will I need to use obelisk?
01:09:43 <refusenick> Doesn't the web side of it have its own package manager?
01:09:49 <Cale> https://hackage.haskell.org/package/reflex-dom
01:10:12 <Cale> But yeah, if you want to actually produce javascript, just get Obelisk, or at least reflex-platform
01:10:35 <Cale> Both of which will use nix to set you up with an environment where you have everything needed.
01:11:07 <refusenick> Is it like Stack's nix integration where you don't have to use nix directly?
01:11:15 <Cale> GHCJS is annoying to build and set up yourself, and if you ever want to turn your frontend into a mobile application, that's even more of a pain to do yourself
01:11:26 <Cale> Obelisk is, kinda
01:11:39 <iqubic> Which do you recommend?
01:12:14 <iqubic> I'm running NixOS, so using obelisk, or reflex platform would be simple.
01:12:21 <Cale> I would say start with Obelisk, and if you find that its opinions about what you're doing don't meet your needs for your web application, then reflex-platform will get you all the raw build infrastructure and you can do something else with it.
01:13:46 <Cale> Obelisk is sort of our more-opinionated web application framework, where we do stuff for you like picking how routes are going to be managed, and how the backend is going to serve the frontend and static files, and how static rendering with hydration will work, and things like that
01:13:57 <iqubic> Cale: Does Obelisk work with emacs?
01:14:16 * refusenick waits for the "no"
01:14:18 <Cale> Well, several of my coworkers use emacs, but I don't know what it means to work with emacs
01:14:22 <iqubic> I mean, will I be able to set it up so that I don't get a million errors?
01:14:50 <Cale> You should be able to run emacs from inside the shell that "ob shell" puts you in, and hopefully that will work with your setup
01:14:59 <iqubic> I like that.
01:15:19 <refusenick> iqubic: I can't get normal Haskell tooling to work without leaving Emacs without resorting to (the excellent but abandoned) hasky-stack
01:15:25 <Cale> I know that worked for some people using vscode
01:15:36 <Cale> My text editor setup is too simple to care about such things
01:15:48 <iqubic> I might also try to get direnv working, but that might be a hard thing to do.
01:16:01 <iqubic> Cale: What do you use for text editing?
01:16:17 <refusenick> I just run my terminal (vterm) in Emacs if direct integration doesn't work.
01:16:30 <Cale> Right now I'm using Sublime Text with very little apart from a hacked up ctags thing that works with hasktags
01:16:48 <Cale> Before that I used vim in a nearly default configuration
01:16:55 <iqubic> And does that work with obelisk?
01:17:11 <Cale> It... doesn't even make sense to ask the question. It edits text.
01:17:39 <refusenick> iqubic: Using Vim means using the shell + separate TUIs for what Emacs users would do inside Emacs.
01:17:51 <opticblast> well, vim does have plugins, if that's what you mean
01:18:28 <Cale> If you do "ob run" or "ob watch", you'll get an interactive report of errors/warnings in your code along with your backend's output
01:18:35 <iqubic> I see.
01:18:38 <Cale> (ob watch only does the first thing)
01:19:01 <iqubic> Cale: how hard would it be to set up direnv support for obelisk projects?
01:19:14 <Cale> What's direnv? I'll google it
01:19:21 <iqubic> No. It's fine.
01:19:28 <iqubic> I'll figure it out on my own.
01:19:33 <opticblast> It's possible to set a key shortcut to run ob watch and then display the results in your vim window
01:20:11 <opticblast> not sure how difficult it is, but I use a vim package that gives me such shortcuts for latex
01:20:27 <Cale> I guess what you can do is copy the environment variables you get from the shell that ob shell puts you in, but then you'll be responsible for maintaining that
01:20:30 <refusenick> Cale: It restricts your shell environment's scope ($PATH variables and the like) to the cwd
01:20:46 <Cale> ob shell will take the current dependencies of your project into account
01:21:07 <_d0t> ohai! I have this problem with a piece of code (https://gist.github.com/greydot/a545eb234faf44419ab0214ac1334ee2) How can I convince GHC that it's properly typed?
01:21:09 <Cale> (it just gives you a particular nix-shell)
01:21:19 <iqubic> Cale: How does ob shell work?
01:22:48 <iqubic> If obelisk is going to be added to nixpkgs someday, it will need to compete with this for naming rights of the package: https://github.com/lelio-brun/obelisk
01:23:01 <refusenick> iqubic: I think he means Org Babel blocks for shell scripts.
01:23:01 <Cale> I think it's pretty much equivalent to nix-shell -A shells.ghc
01:23:15 <refusenick> never mind, I'm dumb and tired
01:23:57 <iqubic> Cale: Does obelisk read from cabal files to fetch dependencies?
01:24:08 <opticblast> dminuoso: Ah. I did the unification on paper like you said, and I found that flip . flip $ uncurry id specializes uncurry id to the type (a -> b -> c, a) -> b -> c
01:24:10 <Cale> Creating process runNixShellAttr: 'nix-shell' '-A' 'shells.ghc' -- yes it is ;)
01:24:10 <merijn> refusenick: Those two things are often closely linked ;)
01:24:28 <Cale> iqubic: The nix behind it does
01:24:37 <refusenick> merijn: :(
01:24:51 <opticblast> dminuoso++
01:25:08 <Cale> iqubic: and there's a default.nix which you can edit if you want to change how it satisfies the deps
01:25:17 <opticblast> that is the way to give someone points for good advice, right?
01:25:29 <iqubic> Cale: Ah good. That's what I like to hear.
01:26:25 <opticblast> (I assume that something is parsing these messages and storing the points, as opposed to it just being a social ritual)
01:26:37 <iqubic> I'll set this up when it isn't 1:00am.
01:26:45 <Cale> There's an ob thunk pack/unpack which you can use as well to pack git repos that point at something with a default.nix into a thunk that is basically a reference to the repo/hash with a default.nix that does a fetchgit and import
01:27:07 <Cale> We end up doing that with a lot of our dependencies ;)
01:27:50 <Cale> It's much nicer than writing a fetchgit into the nix source
01:28:32 <Cale> We should probably split ob thunk out into its own tool
01:28:42 <iqubic> Nice. Sounds awesome.
01:28:54 * hackage language-avro 0.1.1.0 - Language definition and parser for AVRO files.  https://hackage.haskell.org/package/language-avro-0.1.1.0 (FlavioCorpa)
01:32:03 <iqubic> Cale: I just found this. https://github.com/jyp/dante/pull/93
01:32:20 <iqubic> This is literally Obelisk support for the Emacs package I use.
01:32:56 <Cale> iqubic: cool
01:33:21 <iqubic> I have no idea if this will work. But I hope it does.
01:34:35 <iqubic> Oh, and it was closed on January 11 of this year for being too ad-hoc.
01:34:41 <iqubic> I'll see what I can do here.
01:35:16 <opticblast> joke: Hang.onJust a moment
01:36:04 <opticblast> :: (a -> b) -> b
01:37:04 <opticblast> https://hackage.haskell.org/package/overhang-1.0.0/docs/Overhang.html#v:onJust
01:39:12 <monochrom> haha
01:43:28 <iqubic> now I have Phoenix Wright's classic "Hang On" catchphrase stuck on loop in my head.
01:49:58 <opticblast> 9+
01:50:07 <opticblast> https://youtu.be/V7JWhzTVlng?t=9
01:50:40 <iqubic> Yes. That.
02:06:54 * hackage ghc-api-compat 8.6 - GHC-API compatibility helpers  https://hackage.haskell.org/package/ghc-api-compat-8.6 (SylvainHenry)
02:11:58 <AWizzArd> About lenses: I have blocks that contain sensors that contain data. In JSON the structure looks like this: {"blocks": [{"sensors": [{"sensorId": "Error"}, ...]}, {"sensors": [...]}]}
02:12:04 <AWizzArd> Now I want to know if anywhere in this structure there is a   sensorId == "Error".  Currently I am doing it like this:
02:12:07 <AWizzArd> any (== "Error") $ map sensorId $ concatMap sensors $ blocks
02:12:57 <Taneb> Something like anyOf (_blocks.folded._sensors.folded._sensorId) (== "Error")
02:13:27 <iqubic> Taneb: That looks good.
02:17:22 <Taneb> It's longer than what AWizzArd had but I think it's cleaner
02:22:21 <iqubic> Same.
02:24:32 <AWizzArd> Thx!
02:43:17 <iqubic> Cale: I have two questions about obelisk. 1) How does obelisk detect if the current directory is in an obelist project? 2) How can I open a repl in an obelisk project?
02:45:09 <Cale> 1) It looks for .obelisk/impl (which is meant to be a thunk for an obelisk that your global ob command will hand off responsibility to)
02:45:22 <Cale> 2) You should be able to use  ob repl
02:45:55 <iqubic> cool. I should be able get my emacs integration working with that info.
02:53:05 <fishooter> in cabal configuration, how can I make test-suite to depend on the same things as executable + additional testing libs?
02:53:49 <merijn> fishooter: Use a common stanza to define the shared dependencies for the executable and tests
02:54:12 <merijn> fishooter: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-section-common-common
03:04:47 <Io> Is it a common thing to use stack instead of plain cabal?
03:05:06 <Io> Are there any downsides to using stack?
03:06:14 <__monty__> Io: It used to be. Since cabal-install 3.0 there's much less incentive to. Stack has its own set of quirks.
03:06:20 <opqdonut> I'd say stack is pretty common yeah. Haven't bumped into any downsides myself but some people tend to hate it and say that cabal is enough these days
03:06:25 <fishooter> does it happen to you that you get AccessDenied from hackage? https://s3.amazonaws.com/hackage.fpcomplete.com/
03:06:32 <yushyin> I used to use stack but missing feature drove me back to cabal
03:06:37 <fishooter> <Error>
03:06:37 <fishooter> <Code>AccessDenied</Code>
03:06:38 <fishooter> <Message>Access Denied</Message>
03:06:39 <fishooter> ...
03:07:16 <fishooter> is there some mirror? :/
03:08:46 <fishooter> merijn: thanks :) just had to update cabal for that
03:08:46 <yushyin> like stack repl does not support mixins, duh.
03:09:39 <Io> Would it make more sense for me to learn without stack then? In your opinion.
03:11:00 <yushyin> ghcup+cabal is ok to use so far.
03:15:56 <__monty__> Io: Since some stack issues need cabal knowledge to deal with it's not a waste of time to learn cabal first.
03:16:49 <__monty__> Io: If you work on more than a few haskell projects you'll need to learn to use both tools anyway. Though some stack projects are courteous and check the generated cabal file into the repo.
03:17:03 <fishooter> hmm. How do I make stack to upgrade Cabal to be >=2.2? I have Cabal-1.24.2.0 and Stack 2.1.3
03:17:36 <Io> I see your points. Thank you all very much.
03:52:35 <merijn> Io_: I would say stack vs cabal-install has always been kinda 50-50 split
03:53:37 <merijn> __monty__: This is why I always tell people to avoid hpack when using stack, that way everyone can work however they like
03:55:17 <merijn> Io_: Also, "plain cabal" is a bit confusing due to the number of things people refer to with cabal, see: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
04:04:18 <Io_> merijn, That was helpful
04:05:40 <Io_> I was already using hPack. What would you recommend for beginners?
04:05:58 <merijn> I guess I should amend that to point out that stack also installs GHC, whereas cabal-install can only use a GHC you installed manually
04:06:21 <boxscape> you can use hpack with cabal as well though, right? Just need to run hpack as an intermediate step
04:06:58 <merijn> Io_: tbh, the cabal file format is extremely simple. You can use "cabal init" to generate a initial/beginner file (although I usually just copy one of my existing cabal files and adjust the fields as necessary)
04:07:44 <zincy_> If you use forkIO to spawn a thread and an exception occurs in it is it cleaned up?
04:07:55 <zincy_> Or will the thread keep running?
04:08:19 <merijn> boxscape: Yes, but you shouldn't, because you're just introducing unnecessary dependencies for basically no reason
04:08:27 <boxscape> that makes sense
04:08:29 <merijn> zincy_: If not caught the exception will kill the thread
04:10:03 <zincy_> merijn: Is it correct to say that you should always use async over forkIO to guarantee clean up?
04:10:22 <merijn> boxscape: I mean, the main "reason" for hpack seems to be "why use a custom file format instead of an existing one?", and then blissfully ignoring the fact that, while YAML already exists it's 1) a needlessly complex format, 2) you're defining a new ad hoc custom schema on top of YAML and thus not really getting any advantages, and 3) gratuitously adding extra dependencies
04:10:32 <zincy_> For context say you are doing a thread delay and then making a request to another api in your child thread
04:10:35 <merijn> zincy_: Well, async solves more complicated problems
04:11:02 <merijn> zincy_: For example, what if you want an unhandled exception to not only kill the child thread, but *also* the thread that spawned the child?
04:11:14 <merijn> zincy_: And "if the parent thread dies, should the child keep alive?"
04:13:45 <zincy_> merijn: So generally prefer async over forkIO because concurrency is never simple
04:13:58 <zincy_> and you want to generally do it on a high level
04:14:15 <merijn> zincy_: Right. I've done my own resource/exception handling for threads, but it is *hard* to get right
04:15:35 <merijn> Sometimes you have to because async doesn't do quite what you want, but if you can get away with it, better to rely on something like async, because Simon Marlow is almost certainly better at implementing these things than you are ;)
04:16:43 <zincy_> Right!
04:29:16 <fishooter> hi, how can I transpose Data.Array? is ixmap the right way to go?
04:33:09 <iamlearning> Hey! I'm trying to use SDL2 and SDL2-gfx on Windows with Stack. Got everything building and working through executable, however ghci fails with ghc.exe: unable to load package `sdl2-gfx-1.0.0'
04:33:13 <iamlearning> Any tips? :)
04:46:23 <fishooter> fishooter: yes it is :)
05:02:46 <zincy_> Is it a bad sign if you have a system composed of a couple of APIs and they call each others endpoints?
05:03:08 <zincy_> Because to me I cannot see how that could ever be a good thing
05:03:45 <tdammers> why?
05:06:50 <opqdonut> zincy_: that would usually require a good reason IMO
05:07:00 <opqdonut> I prefer acyclic (call) graphs whenever possible
05:08:23 <phadej> if you end up with cycles, maybe you want some message-bus system to make it into a star
05:08:51 <Cale> zincy_: Is the purpose of the system expressly to be distributed?
05:15:04 <Cale> (Because if it doesn't matter that the two programs communicating with one another are on different machines, having the code just be part of the same executable seems nicer)
05:18:04 <zincy_> Cale: I am not entirely sure :/
05:18:49 <zincy_> tdamers: It seems like coupling? I mean fair enough if you are calling an external API but if you need to call another one of your own APIs shouldnt they be merged?
05:35:41 <boxscape> Do instance resolution failures technically qualify as type errors?
05:36:03 <Cale> Sure
05:36:15 <boxscape> hm, okay
05:36:39 <MarcelineVQ> insofar as a type wasn't resolved
05:36:54 <Cale> I suppose they're different from most in that writing an instance can maybe clear them up
05:38:27 <boxscape> -fdefer-type-errors catches them so I suppose that also confirms that from a ghc (user facing) perpective they qualify
05:39:08 <Cale> hmm...
05:39:41 <Cale> I wonder if you can compile a module that would have missing instance errors, put the instances in a module which imports that one, and have the code not fail at runtime.
05:40:00 <Cale> I mean, compile the first module with -fdefer-type-errors
05:40:15 <merijn> Cale: oh god, I hope not
05:40:26 <boxscape> I strongly suspect you'd still get the same error
05:40:34 <Cale> Yeah, I suspect you would as well
05:41:30 <Cale> I thought all it did was take anything that would have been a type error and replace it with something like error "...", but I haven't actually looked at what it does
05:42:53 <boxscape> Cale that is what the paper suggests
05:43:30 <boxscape> well, sort of
05:43:58 <boxscape> if two types don't match it generates a term let (a :: Int ~ Bool) = error "Couldn't match..." in <erroneous code>
05:44:05 <boxscape> or, well, not quite
05:45:03 <boxscape> let (a :: Int ~ Bool) = error "Couldn't match..." in cast <erroneous code> a
05:48:41 <boxscape> Cale for instances they instead bind the instance dictionary to an error expression
05:48:57 <boxscape> so it would use that instead of the newly defined one
05:49:56 <timCF> Hi guys! Today earlier I asked help about composing different Network.Wai.Application. After reviewing different approaches I wrote this code. Does it make sense, will it work as I expect? What do you think about it? Code is here: https://gist.github.com/tim2CF/e0600e68d375b95bbe4c6d66fc436506
06:02:03 <Cale> timCF: It'll probably do exactly what it says it does. I'm not sure how I feel about it beyond the fact that's a really weird way of using coerce
06:02:31 <Cale> I'd probably have just defined the type  newtype WaiApp = WaiApp { unWaiApp :: Application }
06:05:22 <Cale> Other things to think about: Is it just 404's you want to fall through on? What happens with redirects?
06:05:56 <Cale> also, you may just be looking for something like this? https://hackage.haskell.org/package/wai-extra-3.0.29.1/docs/Network-Wai-UrlMap.html
06:06:51 <Cale> (I have no idea why they chose not to expose the ToApplication class)
06:08:17 <Cale> (also, despite the "Map" in the name, why they didn't actually use Data.Map to obtain better asymptotics)
06:09:36 <opqdonut> maybe ordering matters?
06:09:53 <Cale> It probably does, the way they have it there.
06:10:36 <Cale> In that, it'll be left-biased
06:11:47 <Cale> But that just means you can include multiple handlers for the same path, and only the first will be used
06:12:14 <Cale> (when probably what you really want is an error on server startup at least)
06:20:06 <fendor_> when using swagger2 and a custom impl for json, do I have to manually mirror ToSchema and ToJSON?
06:23:53 * hackage tasty-hunit-compat 0.2 - Tasty integration with the existing HUnit package.  https://hackage.haskell.org/package/tasty-hunit-compat-0.2 (martoon)
06:40:23 * hackage parsix 0.2.2.0 - Parser combinators with slicing, error recovery, and syntax highlighting  https://hackage.haskell.org/package/parsix-0.2.2.0 (OlleFredriksson)
06:49:24 <dminuoso> Is there an open sum implementation that works together with lens?
06:54:21 <MasseR> fendor_: afaik yes. If it's of any consolation, the servant-swagger library provides automated tests for you: https://hackage.haskell.org/package/servant-swagger-1.1.8/docs/Servant-Swagger.html#v:validateEveryToJSON
06:55:09 <fendor_> MasseR, Thank you! That is a *bit* better, but still not very nice.
06:56:25 <dminuoso> Oh well, here's an idea. I can just keep a `Map String Dynamic`, and then maintain an open type family `ValueTy :: Symbol -> Type`, and then just coerce+fromJust things!
06:57:29 <Taneb> dminuoso: there are certainly worse ideas, although none spring to mind
06:57:36 <sshine> haha
06:58:41 <sshine> it'd make for a good blog post on how you *could* model PHP embedded in Haskell, but not as easily the other way around.
07:00:01 <lyxia> dminuoso: that sounds like typerep-map
07:00:05 <merijn> sshine: What, you mean acme-php?
07:00:12 <merijn> @hackage acme-php
07:00:13 <lambdabot> http://hackage.haskell.org/package/acme-php
07:02:14 <sshine> merijn, oh. yes. heh. :)
07:15:04 <dminuoso> lambdabot: typerep-map could work as well.. I think Ill concoct something similar using type families, tysyms and tynats.
07:15:26 <dminuoso> Overall I dont think using Dynamic internally is a bad thing, as long as I maintain proof of whats inside in the type system
07:16:18 <__monty__> Sounds like rationalizing : )
07:17:58 <fendor_> MasseR, the validateEveryToJSON failing tests do not really help :D 
07:19:16 <fendor_> but they actually showed a mistake immediately
07:27:47 <ski> refusenick : nice conal blag, ty
07:30:43 <lyxia> dminuoso: that sounds like type-map
07:47:56 <maerwald> sinkFile from conduit deletes the file after you run runResourceT lol. Any way to pass the result (not the output) of a conduit to another conduit, thus forcing it? 
07:48:56 <merijn> maerwald: Move the runResourceT invocation further out
07:49:05 <maerwald> That's not easily possible 
07:49:10 <merijn> Why not?
07:50:02 <merijn> maerwald: ResourceT is explicitly a region delimiting resource validity, so yes when you exit cleanup is triggered, that's the entire point of it
07:50:09 <maerwald> Because I return a conduit that uses said file sometime later and its executed somewhere else
07:50:34 <merijn> maerwald: So? The ResourceT doesn't have be limited to your initial conduit invocation
07:51:54 * hackage cpphs 1.20.9 - A liberalised re-implementation of cpp, the C pre-processor.  https://hackage.haskell.org/package/cpphs-1.20.9 (MalcolmWallace)
07:55:00 <maerwald> The types don't align 
07:55:08 <merijn> huh?
07:55:30 <merijn> Can you sketch a minimal example?
07:59:24 * hackage aura 2.2.0 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-2.2.0 (fosskers)
08:00:05 <boxscape> % (unsafeCoerce (undefined:undefined)) :: Integer
08:00:10 <yahb> boxscape: GNU MP: Cannot allocate memory (size=15687216); [Aborted]
08:00:10 <boxscape> hm
08:02:43 <boxscape> oh I've found a better way to find out what version of ghc yahb is running
08:02:46 <boxscape> % ((unsafeCoerce [1..50]) :: x -> x) "hello"
08:02:47 <yahb> boxscape: "<interactive>: internal error: stg_ap_p_ret; (GHC version 8.6.0.20180620 for x86_64_unknown_linux); Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug; [Aborted]
08:02:56 <boxscape> that's actually unironically useful
08:04:34 <MarcelineVQ> neat, % :! ghci --version  is more direct, but that's the version on the path, not neccesarily the version running
08:04:39 <maerwald> merijn: https://gist.github.com/hasufell/95b67b761802f9e481a82344f39d3814 
08:05:08 <boxscape> ah, that's likely  better than System.Info.compilerVersion, which I was using before
08:05:24 <merijn> maerwald: Why does it have to be liftIO'd?
08:05:40 <ski> % System.Info.compilerVersion
08:05:40 <yahb> ski: Version {versionBranch = [8,6], versionTags = []}
08:05:55 <merijn> maerwald: Also, looks like you want toConsumer
08:06:10 <ski> oh
08:06:57 <merijn> maerwald: toConsumer generalises the Void of a sink into an arbitrary type (if you want to use a sink inside some other conduit)
08:09:23 <boxscape> % ((unsafeCoerce $ \x -> x + x) :: a -> a) ['a']
08:09:24 <yahb> boxscape: "<interactive>: internal error: ARR_WORDS object entered!; (GHC version 8.6.0.20180620 for x86_64_unknown_linux); Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug; [Aborted]
08:09:25 <boxscape> % ((unsafeCoerce $ \x -> x + x) :: a -> a) "a"
08:09:26 <yahb> boxscape: "*** Exception: heap overflow
08:09:29 <boxscape> that's really interesting
08:09:34 <boxscape> "a" is different from ['a']
08:09:54 <Taneb> :t "a"
08:09:56 <lambdabot> [Char]
08:09:58 <Taneb> % :t "a"
08:09:59 <yahb> Taneb: [Char]
08:10:06 <Taneb> Hmm, not OverloadedStrings
08:10:47 <geekosaur> unpackCString# somehow?
08:11:25 <boxscape> could be
08:12:20 <Ianulus> I have a problem with stack & hspec on VSCode & NixOS:
08:12:21 <Ianulus> "Could not execute: hspec-discover"
08:12:27 <Ianulus> I've found this issue, but I'm not fluent enough in nixos to implement the workaround:
08:12:27 <Ianulus> https://github.com/haskell/haskell-ide-engine/issues/1500
08:13:54 * hackage lhs2tex 1.23 - Preprocessor for typesetting Haskell sources with LaTeX  https://hackage.haskell.org/package/lhs2tex-1.23 (AndresLoeh)
08:17:14 <Ianulus> specifically, I'd need to know:
08:17:14 <Ianulus> - How do I find the path to "the executable installed by stack"?
08:17:15 <Ianulus> - How do I modify the path variable in a nix-shell (so that it's only temporary)?
08:20:40 <nshepperd2> maerwald: what the? sinkFile deletes the file?
08:21:32 <maerwald> Yes, the monad resource does
08:21:40 <maerwald> I find that terrible API
08:21:42 <maerwald> But well
08:22:12 <maerwald> If you run the conduit and the resourcet, you get back a filename of something that doesn't exist anymore 
08:22:14 <maerwald> :D
08:22:49 <nshepperd> shouldn't it be called sinkTmpFile if it does that
08:23:19 <jsomedon> any haskell library for making command line app?
08:24:22 <maerwald> nshepperd: that exists too, but the only difference is the file location 
08:24:44 <nshepperd> https://hackage.haskell.org/package/conduit-1.3.1.2/docs/src/Data.Conduit.Combinators.html#sinkFile at face value doesn't seem to have any deletion code 
08:29:53 <fishooter> I'm writing a QuickCheck example generation
08:29:55 <fishooter> I have following
08:29:59 <fishooter> data Player = PlayerX | PlayerO deriving (Eq, Show)
08:29:59 <fishooter> instance Arbitrary Player where
08:29:59 <fishooter>   arbitrary = do
08:29:59 <fishooter>     p <- choose (1,2)
08:29:59 <fishooter>     case p of 1 -> PlayerX
08:30:01 <fishooter>               2 -> PlayerO
08:30:10 <fishooter> however it does not typecheck
08:30:15 <fishooter> actual type Player
08:30:16 <boxscape> I kinda wish you could to something like `instance c [a] => c (Maybe a) via maybeToList`
08:30:23 <fishooter> expected type Gen Player
08:30:28 <fishooter> but if I put return there
08:30:38 <fishooter> it becomes an incomprehensible type error
08:30:43 <boxscape> fishooter please use a pastesite like pastebin etc. when you want to share multiple lines of code
08:31:08 <fishooter> boxscape: ok, sure, I just thought it's quite short
08:31:33 <fishooter> https://pastebin.com/iLXuhjLA
08:31:45 <boxscape> I remember reading more than 3 lines somewhere as rule of thumb though maybe I'm making that up
08:31:52 <Taneb> fishooter: you need a return either both before PlayerX and PlayerO, or you need to add "return $" before case
08:31:56 <ski> fishooter : `return PlayerX'
08:32:04 <fishooter> that's exactly what I did
08:32:50 <ski> both places, fishooter ?
08:33:31 <ski> boxscape : fwiw, i'm okay with it, when it's this short
08:33:40 <fishooter> ski: yes
08:33:41 <fishooter> https://pastebin.com/cRVwKB1G
08:33:47 <fishooter> this is the error
08:34:28 <ski> fishooter : `case p :: Int of'
08:34:57 <solonarv> "ambiguous type variable" means "GHC can't figure out what this type should be"
08:35:03 <solonarv> so you need to tell it the type!
08:35:07 <fishooter> ski: awesome! :)
08:35:20 <fishooter> I thought the type could have been inferred
08:35:35 <ski> fishooter : personally, i prefer `p :: Int <- choose (1,2)', but that requires an extension
08:35:42 <boxscape> huh shouldn't it default to Integer?
08:37:41 <fishooter> ski: makes sense, I'd rather do without extensions
08:37:53 <fishooter> how can I turn a
08:37:54 <fishooter> type Board = Array (Int, Int) Cell
08:38:02 <fishooter> into newtype Board = ?
08:38:43 <boxscape> you need to choose a constructor name, for example newtype Board = MkBoard (Array (Int, Int) Cell)
08:39:01 <boxscape> quite often the constructor name for newtypes will be the same as the name of the type, so "Board" in this case
08:39:53 <boxscape> (which is called "punning")
08:40:36 <fishooter> ah, ok, nevermind the question :)
08:40:49 <solonarv> fishooter: the reason the type can't be inferred is that literals are polymorphic; if you write '1' in suorce code, the type of this is not 'Int' or 'Integer' or anything like that instead it is 'forall a. Num a => a'
08:41:12 <boxscape> solonarv any idea why it's not defaulted to Integer?
08:41:31 <solonarv> yes: there is more aggressive defaulting in ghci
08:41:41 <boxscape> but Integer is defaulted even outside of ghci
08:42:02 <solonarv> I try not to rely on defaulting, and as a result I don't know exactly when it happens
08:42:07 <solonarv> sorry :P
08:42:22 <boxscape> (I only know it because you get a warning with -Wall every time it happens
08:42:24 <boxscape> )
08:42:55 * ski prefers not "punning" in that way
08:43:26 <boxscape> if https://github.com/ghc-proposals/ghc-proposals/pull/270 gets accepted there will be an optional warning against punning
08:44:41 <boxscape> and then hopefully we can drop -Wunticked-promoted-constructors from -Wall, it keeps annoying me
08:46:23 * hackage prosidy 1.5.0.1 - A simple language for writing documents.  https://hackage.haskell.org/package/prosidy-1.5.0.1 (jafc)
09:02:55 <turq> Is tree shaking an option for GHC?
09:06:19 <turq> Is tree shaking necessary for GHC?
09:06:44 <turq> i.e. does it do this for you automatically?
09:08:28 <fishooter> solonarv: thanks :)
09:08:48 <fishooter> is there a standard function that splits list into parts in following way?
09:08:54 <fishooter> x = "12345678"
09:09:13 <fishooter> split 2 x becomes ["12", "34", "56", "78"]
09:09:23 <fishooter> split 4 x becomes ["1234", "5678"]
09:09:56 <boxscape> @hoogle Int -> [a] -> [[a]]
09:09:57 <lambdabot> Data.List.Split chunksOf :: Int -> [e] -> [[e]]
09:09:57 <lambdabot> Data.List.Split.Internals chunksOf :: Int -> [e] -> [[e]]
09:09:57 <lambdabot> Hedgehog.Internal.Shrink removes :: Int -> [a] -> [[a]]
09:10:25 <boxscape> fishooter it exists, but in the split package, not in base
09:10:42 <boxscape> (i.e. chunksOf)
09:10:52 <fishooter> boxscape: thanks :)
09:17:08 <d34df00d> Hi!
09:17:36 <d34df00d> Let's say I have an integer denoting the total length of the input and an integer for the workers count.
09:18:02 <d34df00d> Is there any nice utility function that'll give me a list of positions in the input distributed more or less evenly according to the workers count?
09:18:19 <d34df00d> I'm writing this for the Nth time and figured I'm too lazy to do this again.
09:28:53 <__monty__> f i n u = [i,i+n..u] -- i is the worker's index 0..n, n is the number of workers, u is the upper bound on the index in the work queue.
09:29:11 <__monty__> 0..n-1
09:30:07 <d34df00d> Yay.
09:30:15 <ski> perhaps they want segments to differ in length at most by one
09:30:26 <d34df00d> That's a nice application of enumFromThenTo!
09:30:34 <d34df00d> ski: nah, this one is good enough.
09:44:02 <days> http://homepages.inf.ed.ac.uk/wadler/papers/multiparty/multiparty.pdf
09:45:19 <days> extends server function nests via coherence between several processes as mediated eg. via a global type 
09:59:28 <aviD> So I've been really addicted to the idea of making a Haskell inspired language that compiles to readable interoperable Rust. For unrelated reasons a few months ago I spent significant time researching and then designing a lockfree GC capable of Drop/finalizers.
09:59:28 <aviD> Has anyone else had this itch? Is there prior art I'm not aware of (not Gluon). In general does anyone have thoughts on the idea?
10:03:49 <dmwit> There used to be a via-c compiler pass in GHC. I would not describe the results as "readable".
10:06:24 <geekosaur> jhc?
10:06:43 <geekosaur> hasn't been maintained in a while, but generated supposedly readable C code
10:06:43 <aviD> I once inspected c output. It was not fun ;)
10:07:57 <geekosaur> also unregisterised is still in ghc although you need to build the compiler specially to get it. not sure it's any more readable (it generates vanilla portable ANSI C, but nobody promised readable or performant)
10:12:42 <maerwald> how do you run a conduit that has a resource and feed the result into another conduit, so that the resource is released when the other conduit finishes? Afais, the types don't align
10:17:27 <aviD> Compiling real Haskell to readable rust or any readable language is a monumental task. I'm more interested in a Haskell inspired approach. I don't see a way to ever make even Haskell 98 behave well with rust's ownership model. Lazy by default, does not play well with my GC or the borrow checker. Explicit laziness cuts down on evaluation and allow my GC to optimize tracing and drop.
10:18:03 <zincy__> In your api handlers is there an alternative to case statements for throwing errors on Left . I know there is ExceptT but is there anything else?
10:29:23 <ski> @quote mangler
10:29:23 <lambdabot> Pseudonym says: All hail the Evil Mangler!
10:39:06 <hyperisco> aviD, I think compiling Core to readable Haskell would be a monumental challenge
10:40:48 <geekosaur> I think they meant they want a haskell-inspired language with features that might compile more easily to something else
10:41:18 <geekosaur> so this is more the realm of elm or purescript maybe
10:43:43 <aviD> Yes, I'm thinking about a language analogous to a rusty purescript.
10:44:45 <hyperisco> I wonder if the Rust creators are disappointed that their language is only cited for the borrow checker
10:48:51 <d34df00d> Idris 2?
10:48:58 <d34df00d> Uniqueness types, compiling to Scheme, stuff like that.
10:49:07 <d34df00d> Also dependent types.
10:51:24 * hackage http-client-restricted 0.0.2 - restricting the servers that http-client will use  https://hackage.haskell.org/package/http-client-restricted-0.0.2 (JoeyHess)
10:51:44 <aviD> Preserve naming. Specialize HKTs to a various generic rust representations with meaningful suffixes. In debug builds naively wrap all values in `GC<T>`.
10:59:27 <aviD> Idris 2 is extremely intriguing, but I'm a little less ambitious than Edwin (not to mention my relative intelligence deficit) and the killer feature I want is seamless interop with the rust ecosystem. Selling a switch from Rust to Idris or Haskell is allot harder than selling a generated rust module.
10:59:28 <d34df00d> Is it dangerous to extract a ForeignPtr from a ByteString and then convert it to a Ptr, extracting the Addr# component and passing it to a `foreign import prim`'ed function?
11:00:05 <d34df00d> I don't know if it'll cause the finalizer for the BS to run earlier than needed.
11:04:22 <hololeap> maerwald: isn't that what ResourceT is for?
11:11:09 <__monty__> Looking for FilePath normalisation. System.FilePath.Posix.normalise doesn't drop dir from dir/../something.
11:12:24 <maerwald> hololeap: yes, but it deletes the file when you run the resource
11:12:36 <maerwald> in order to get the result, you must run the conduit at least
11:14:16 <maerwald> I haven't figured out how have the consuming conduit inside the runResourceT, since that gives type errors
11:14:44 <aviD> hyperisco I think Rust's creators are frilled, that the borrow checker became so famous. For what it's worth, they made a dam fine standard library and ecosystem as well. Rust has been the most loved language for years now, and partially as a result it's the only FP/ML inspired language to go mainstream corporate.
11:14:44 <aviD> Core Rust members express differing views on more advanced type system features,  even GAT is years behind schedule and I doubt HKTs will ever make it into Rust proper.
11:15:29 <hyperisco> What about Scala
11:15:35 <d34df00d> Please no.
11:15:37 <d34df00d> Uncanny valley.
11:16:06 <d34df00d> On a somewhat related note, I'm going through register mappings in GHC, and what does "YES" mean here? https://github.com/ghc/ghc/blob/master/includes/stg/MachRegs.h#L129-L156
11:16:14 <maerwald> Scala: because there are 5 ways to write an enum and all are confusing
11:17:44 <solonarv> d34df00d: it's safe as long as you make sure the ForeignPtr isn't garbage collected too early
11:17:58 <solonarv> I think there's a withForgeignPtr wrapper which takes care of that
11:18:18 <solonarv> has a type like: ForeignPtr a -> (Ptr a -> IO b) -> IO b
11:18:34 <d34df00d> solonarv: yeah, I thought about withForeignPtr, but it's a bit unhandy in the context I'm using all this.
11:18:56 <d34df00d> (I'm writing a library for inline assembly code, and this is a TH-generated wrapper between a Haskell function with boxed types and a prim function with unboxed ones)
11:20:59 <hololeap> maerwald: runConduitRes is the normal way. i think that you could use bracketP for your problem
11:21:18 <maerwald> hololeap: nah, the conduit already has an inner bracketP that deletes the file
11:21:22 <aviD> hyperisco: What about Scala?
11:21:23 <maerwald> anyway, I think I solved it :P
11:21:39 <maerwald> it was just a random 'lift' somewhere... love transformers
11:22:26 <maerwald> hololeap: the point is to exactly not run the resource, but only the conduit, then pass the result into another conduit
11:22:30 <maerwald> but for that you need to lift
11:22:35 <int-e> d34df00d: compare to https://www.uclibc.org/docs/psABI-x86_64.pdf page 21... it's basically the "preserved across function calls" column.
11:23:12 * hololeap starts to wonder about composing two `bracket`s
11:23:18 <merijn> maerwald: How else could resource management ever guarantee cleanup if not at the end of the section that handles resource cleanup
11:23:44 <d34df00d> int-e: ah, I see, that makes sense! Thanks!
11:24:01 <maerwald> merijn: btw... the function you mentioned led to the same typeerror (toConsumer)
11:24:25 <merijn> maerwald: The type error you showed (which can't be from the snippet you pasted) would've been solved by toConsumer
11:24:40 <maerwald> I tried exactly that
11:25:20 <merijn> maerwald: Anyway, the reason why you're having to unwrap the ResourceT is due to the liftIO but it was unclear why the liftIO was even there
11:25:52 <maerwald> lift (runConduit writeToSomeTempFileWithResourceT) >>= \filepath -> someOtherConduit filepath
11:26:12 <maerwald> so runResourceT was the wrong path
11:27:23 * hackage launchdarkly-server-sdk 1.0.0 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-1.0.0 (launchdarkly)
11:32:06 <fendor> is there experience with using polysemy with webstacks? Integration with servant, for example, looks complicated
11:32:51 <hyperisco> aviD, has functional inspirations, is also "corporate mainstream"
11:33:25 <maerwald> add a lambda keyword to your language, such functional
11:33:32 <maerwald> many monads
11:33:45 <hyperisco> I thought you became a functional language once you could map an array with a callback
11:34:14 <maerwald> merijn: regardless of these lesser hoops, do you like the conduit API? :>
11:35:30 <merijn> maerwald: I have no idea what hoops you're referring to, so I have no idea
11:35:47 <maerwald> well, then minus the hoops
11:36:29 <solonarv> d34df00d: back now - you can also unsafeForeignPtrToPtr to get out the Ptr, and arrange to call touchForeignPtr later
11:36:54 * hackage mmsyn7s 0.3.1.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.3.1.0 (OleksandrZhabenko)
11:36:54 <merijn> It works well enough for all the things I'm doing. Also, I just realised another question raised by your issue: Why are you trying to create a sink twice, rather than just having both upstream steaming to the same sink, then the entire problem goes away...
11:37:22 <maerwald> constant memory
11:37:49 <merijn> I fail to see how that's relevant?
11:37:50 <maerwald> some things are unfortunately forcing a file into memory (e.g. because length needs to be known)
11:37:59 <maerwald> yes, you can't see it from my posted code
11:38:30 <maerwald> or I don't know what you mean :>
11:38:30 <merijn> How would the lifetime of the sink affect the memory usage?
11:39:23 <merijn> maerwald: Right now you're doing 'someStuff .| sinkFile "/path/to/file"' and later wanting to append to that same file from a different conduit, right?
11:39:34 <hololeap> runConduitRes $ bracketP mkTempFile rmTempFile (\f -> toConsumer (writeToSomeTempFile f) .| someOtherConduit f)
11:39:39 <aviD> Hyperisco: your right Scala does sort of meet those criteria, God help us.
11:39:40 <maerwald> merijn: not append
11:39:50 <maerwald> the later function needs to know the size of the entire file
11:40:02 <merijn> maerwald: Then I don't even understand wtf you're trying to do?
11:40:10 <hololeap> maerwald: ^ not 100% sure that works, but something to consider
11:40:51 <maerwald> merijn: downloading a tar file in constant memory, writing it to disk, get the size, do some tar stuff to it, pass it onto some other conduits
11:40:54 * hackage mmsyn7s 0.3.1.1 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.3.1.1 (OleksandrZhabenko)
11:41:00 <maerwald> although conduit is used, it is not constant memory
11:41:09 <merijn> maerwald: Why not compute the size as you are writing to disk?
11:41:41 <merijn> Well, did you profile where the memory is actually growing?
11:42:10 <maerwald> I know which functions cause it yes
11:42:45 <d34df00d> solonarv: yeah, since this is quite a low-level piece, that's probably the best approach!
11:42:47 <d34df00d> Thanks!
11:42:48 <merijn> And how do those relate to the conduit?
11:43:28 <hololeap> actually, maybe someone can confirm: does `runConduit ((toConsumer a) .| b)` behave like `runConduit a *> runConduit b` ?
11:44:43 <solonarv> hololeap: I wouldn't expect it to
11:45:25 <maerwald> merijn: as I said, one problem is length calculation
11:46:42 <solonarv> a = replicateM 3  (liftIO (putStrLn "a") *> yield ()); b = replicateM 3 (await *> liftIO (putStrLn "b"))
11:46:45 <solonarv> hololeap: try those
11:46:48 <merijn> "one problem is length calculation" <- that's vague enough that I don't have no possible way of commenting on what you should be doing
11:47:07 <maerwald> Yeah, unfortunately
11:47:40 <solonarv> runConduit (toConsumer a .| b) should output "a b a b a b", runConduit a *> runConduit b should output "a a a b b b"
11:48:53 <lhurttila> In general, what issues can cause an imported module not to be found while loading a file to ghci?
11:49:17 <MarcelineVQ> not having the package the module is from installed/in scope
11:51:04 <maerwald> merijn: but I appreciate your relentless support :>
11:51:08 <MarcelineVQ> in your case the package is called   streamly  https://hackage.haskell.org/package/streamly
11:53:48 <alp> fendor, servant will be happy as long as you provide a way to go from your handler's monad to servant's 'Handler' monad.
11:54:30 <hololeap> solonarv: your example doesn't quite make sense because `runConduit a` (using your `a`) doesn't typecheck
11:55:23 <hololeap> but it looks like (so far) `runConduit (a *> b)` behaves like `runConduit a *> runConduit b`, so it's simpler than i thought
11:55:33 <fendor> alp, ok, thank you! I've seen some working example, it just looked rather complex
11:56:16 <hololeap> (i was trying to think of a way to turn `runConduit a *> runConduit b` into something with one `runConduit`)
11:56:17 <lhurttila> MarcelineVQ That's the one I'm trying to get working. Being in the src directory, stack ls dependencies gives me a list that has streamly 0.7.1 in it. Doesn't this already tell it's installed?
11:57:16 <merijn> lhurttila: GHC will only see packages you tell it to see
11:57:40 <alp> fendor, it all boils down to https://docs.servant.dev/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers / https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html - just applied to whatever monads you end up working with using polysemy (I haven't used it yet, so I can't help on that front)
11:57:42 <merijn> lhurttila: So if you don't use "ghci -package foo" or "stack repl"/"cabal repl" (which do so for you) it won't see them
11:58:33 <hololeap> perhaps that falls out from the monad transformer laws? (runSomeT a *> runSomeT b) === (runSomeT (a *> b))
11:59:48 <fendor> alp, ok, thank you! will give it a try
12:00:02 <Cale> hololeap: Usually that kind of thing is vaguely true, but consider runStateT s for some fixed s, it won't be right.
12:00:40 <MarcelineVQ> lhurttila: I've not really used stack ls so idk what promises there are about what it tells you exactly. is streamly listed in your project's build dependencies in your cabal file? and you're writing  import Streamly  after running stack ghci in your project's root?
12:01:36 <Cale> (In the case of conduit, it wouldn't surprise me, but I'm uncertain)
12:04:51 <solonarv> hololeap: oh, I misread the type signature
12:05:34 <hololeap> ok... i wonder what property ensures that (runSomeT a *> runSomeT b) === (runSomeT (a *> b))
12:05:50 <solonarv> runConduit in particular appears to be a monad morphism
12:05:59 <solonarv> (which means it commutes with 'pure' and '>>=')
12:06:24 <solonarv> but this isn't generally true for any "run***" function
12:08:19 <lhurttila> MarcelineVQ Streamly is listed in my .cabal file. In build-depends parts of library and executable. stack ghci in project's root shows two problems "The following GHC options are incompatible with GHCi and have not been passed to it: -threaded" and "unknown symbol `clock_gettime'ghc.exe: unable to load package `streamly-0.7.1'"
12:08:31 <hololeap> solonarv: right... monad homomorphisms. can't remember the details... need to brush up on that stuff
12:10:47 <lhurttila> merijn ghci -package streamly command in src directory gives back "<command line>: cannot satisfy -package streamly"
12:11:31 <Cale> lhurttila: ah, okay, so it's trying to load streamly and unable to because I guess dynamic linking is failing
12:11:46 <Cale> Let's focus on the: unknown symbol `clock_gettime'
12:13:15 <Cale> There's apparently a function by that name in librt
12:13:22 <zincy__> I understand that a free monad builds up a nested series of computations without evaluating them, what is the use case of that?
12:13:46 <Cale> zincy__: Being able to decide after the fact how those computations are to be interpreted
12:14:03 <zincy__> Is it nested contexts or computations
12:14:10 <zincy__> I call the inner value a computation 
12:14:27 <lhurttila> One cause for problems could be the following warnings I get  with stack ghci "Stack has not been tested with GHC versions above 8.6, and using 8.8.2, this may fail" and "Stack has not been tested with Cabal versions above 2.4, but version 3.0.1.0 was found, this may fail" but I don't know how to check it those can cause issues
12:14:28 <Cale> Well, maybe I should just show an example to give a good sense for what Free is about
12:14:52 <Cale> lhurttila: I think you might be missing an underlying C library that streamly expects you to have
12:15:11 <zincy__> I am seeing uses where you have an interpreter style Free Monad and you can lift in different types of computations
12:15:17 <zincy__> but the underlying machinery is the same
12:15:38 <Cale> zincy__: Let's imagine that IO doesn't exist, and begin to reinvent it
12:15:54 <Cale> So we'll start with just trying to represent terminal I/O
12:16:24 <Cale> If I have an action of type IO a, either it's already finished, with some result of type a
12:16:39 <Cale> data IO a = Done a | ...
12:17:08 <Cale> Or it starts off by printing some character to the terminal, followed by some way of continuing of type IO a
12:17:22 <Cale> data IO a = Done a | PutChar Char (IO a) | ...
12:17:41 <zincy__> Yep
12:17:51 <Cale> Or it starts off by getting a character from the user, followed by some way of continuing which might depend on that character, a function of type Char -> IO a
12:17:52 <maerwald> carter: hi
12:18:00 <carter> hello!
12:18:01 <Cale> data IO a = Done a | PutChar Char (IO a) | GetChar (Char -> IO a)
12:18:09 <zincy__> Ah
12:18:26 <zincy__> Maybe I am jumping the gun
12:19:00 <Cale> So, this is a perfectly good algebraic data type, whose values merely say what action ought to be performed, it doesn't actually say how to do anything
12:19:08 <zincy__> but by building up a series of computations you dont have to evaluate them sequentially?
12:19:59 <Cale> Well, if we write an interpreter for this small IO, let's rename it MyIO, just to avoid conflicting with the existing one
12:20:14 <Cale> data MyIO a = Done a | PutChar Char (MyIO a) | GetChar (Char -> MyIO a)
12:20:19 <Cale> execute :: MyIO a -> IO a
12:20:25 <Cale> execute (Done a) = return a
12:20:44 <Cale> execute (PutChar c x) = do putChar c; execute x
12:21:00 <Cale> execute (GetChar k) = do c <- getChar; execute (k c)
12:21:22 <Cale> We could build variations on that interpreter
12:21:31 <Cale> Maybe we'd rather read and write some other handle
12:22:18 <zincy__> What is a handle?
12:22:32 <Cale> One of the things you get from opening a file or network socket
12:23:01 <zincy__> Ok
12:23:12 <Cale> So, even if this is kind of unrealistic, by interpreting this differently, maybe instead of doing terminal I/O, we talk to a user that's connected over the network
12:23:54 <Cale> (usually you'd want to write it so that you can do more than a character at a time, but this is theoretically good enough)
12:24:25 <Cale> But let's generalise a little
12:24:30 <zincy__> Quick question
12:24:36 <Cale> sure
12:24:51 <Cale> You can imagine writing many different monads in this style, with different basic operations
12:25:09 <Cale> Free is going to generalise that pattern of defining monads
12:25:10 <zincy__> What has the interpreter given us over having just a function for each data constructor representing an IO action
12:25:43 <Cale> Well, it's given us some way of taking this data structure we build, and actually causing it to have some effect in the real world
12:26:06 <zincy__> Ah ok so is has allowed MyIO to actually behave like IO
12:26:25 <Cale> You can sort of imagine that IO itself is something like this, and there's some part of the Haskell runtime which takes apart the data structure and actually carries out the operations it describes at a low level
12:26:43 <Cale> (it turns out this is not really how it works, but in principle there's no reason it couldn't work that way)
12:28:03 <zincy__> I understand the parts but I feel like the gist of the idea hasn't clicked
12:28:38 <Cale> lhurttila: maybe try: export LD_PRELOAD=/lib/x86_64-linux-gnu/librt.so.1 -- or check and see if you have a librt.so.1 somewhere on your system
12:28:56 <merijn> zincy__: The idea is to separate "evaluation" (things that can be observed within the pure haskell world) from "running" (side-effects that you want in programs)
12:29:13 <zincy__> I guess the idea is adding effects to our data type which looks like a functor and can have a monad embedded inside
12:29:25 <merijn> zincy__: side-effect can only make things impure if they can be observed, because, if they can't be observed how could they affect you?
12:29:47 <zincy__> merijn: Ah ok
12:30:09 <Cale> So yeah, in case you're not already super-familiar with how IO works in Haskell (I probably shouldn't assume, but usually people don't get to asking about free monads before that), the point of having an IO type at all is so that we can separate the processes of evaluation and execution
12:30:20 <merijn> zincy__: One way of viewing this is a (conceptual) interpreter that evaluates our "purely functionally computed" data structure
12:30:21 <Cale> Evaluation meaning the process by which expressions turn into values
12:30:34 <Cale> and execution referring to carrying out the actions that are described by IO actions
12:31:02 <merijn> zincy__: It is (hopefully) clear from Cale's examples that all the bits that construct these MyIO (or IO) values are pure, right?
12:31:29 <Cale> and yeah, the reason why we want to do that is that we'd like evaluation to behave better than execution -- in particular, evaluating the same expression should always produce the same value
12:31:30 <zincy__> Yes
12:31:42 <merijn> zincy__: Now, executing the resulting IO computation *isn't*, but that execution isn't visible from within our pure language and thus can't ruin anything
12:31:52 <zincy__> making more sense now
12:32:01 <merijn> Because we can't ever directly observe the execution happening
12:32:02 <zincy__> I see that MyIO has only pure values
12:32:10 <Cale> Yeah, GetChar (\c -> PutChar c (Done ())) is always the same value
12:32:18 <zincy__> yet through the interpreter it can do things which are effectful
12:32:24 <Cale> regardless of the fact that the user might type a different character each time it's executed
12:33:05 <merijn> zincy__: Now, clearly actually implementing things this way would be horribly inefficient, but as long as the actual implementation adheres to our defined interface, purity stays intact
12:33:17 <zincy__> Right same value on each evaluation
12:33:22 <Cale> I suppose since we started by talking about the fact that this is a monad, but I haven't proved that by writing an instance of Monad
12:33:35 <merijn> zincy__: One way of thinking of it is "Haskell as purely functional language for computing imperative programs"
12:33:52 <Cale> So, to get closer to an explanation for why Free exists, let's just write the Monad instance
12:33:57 <zincy__> merijn: Would a free monad be efficient enough for say normal web apps to run everything in.
12:34:32 <Cale> zincy__: You do pay a significant penalty that you probably wouldn't want to, but there might be reasons to do it
12:34:32 <merijn> zincy__: That question has a lot of hidden assumptions in it that make it hard to answer :)
12:34:34 <zincy__> merijn: Right because the imperative programs happen at runtime
12:35:08 <Cale> and once you do care about performance, there are ways of getting better performance out of Free-monad-like constructions
12:35:28 <merijn> zincy__: In reality the code GHC produces interleaves the execution of IO and evaluation of pure Haskell, but we can't observe this, so we can pretend we're working with the simple abstraction Cale presented)
12:35:36 <lhurttila> Cale why did you suspect a missing c- library? and try export LD_PRELOAD=/lib/x86_64-linux-gnu/librt.so.1 where? I definetly don't have librt.so.1 anywhere.
12:35:42 <carter> state monad party!
12:35:55 <Cale> lhurttila: Well, I googled for undefined symbol: clock_gettime
12:36:00 <merijn> Cale: You mean the part where people start mumbling about Codensity transforms? ;)
12:36:08 <carter> lhurttila:  are you on mac?
12:36:17 <Cale> lhurttila: and it seems like people who get that message are usually missing librt
12:36:31 <Cale> (or it's not in their library path)
12:36:31 <carter> Cale:  or built their own ghc with the wrong flags for older OSX?
12:36:43 <Cale> carter: Seems plausible! :)
12:36:56 <Cale> merijn: Or freer/other effect systems
12:37:11 <zincy__> So all the code you have written there is pure. Which impure effects are we separating from it?
12:37:20 <carter> the doing of the things
12:37:31 <carter> doing a thing and describing it are different
12:37:32 <zincy__> Maybe the answer is all of it
12:37:33 <Cale> zincy__: The actual carrying out of the effects that these data structures describe
12:37:34 <merijn> zincy__: Reading/writing files, network access, etc.
12:37:38 <carter> interepreter vs AST
12:37:56 <carter> i wrote an AST, the interpreter/CPU/intern runs it
12:37:57 <merijn> zincy__: Yes, the main complaint about IO is that it doesn't reall distinguish "effects" at a more granular level
12:38:08 <zincy__> Ahh
12:38:17 <zincy__> This is starting to make a lot more sense
12:38:22 <carter> but theres a cost to making things more precise
12:38:24 <merijn> zincy__: There are some other abstractions, though. For example the ST monad only allows "mutable memory access"
12:38:27 <Cale> Actual IO actions in Haskell can do anything your computer can do
12:38:31 <carter> maerwald:  i like STE :) 
12:38:39 <merijn> zincy__: Which is why "ST a -> a" exists, but "IO a -> a" doesn't
12:38:41 <carter> merijn:  more should use STE
12:38:59 <carter> maerwald:  (forall s . ST s a -> a )
12:39:00 <merijn> zincy__: We have sneaky ways of hiding mutable memory away
12:39:02 <carter> errr
12:39:04 <carter> autocompletee
12:39:07 <carter> safely
12:39:20 <merijn> carter: I know, but let's not overcomplicate things right away :p
12:39:24 <carter> ok
12:39:35 <lhurttila> Cale  I noticed that I've set the dependency for the newest streamly version 0.7.1 while stackage page shows Distribution 0.6.1. Also dependency list has everything that's listed on stackage, except for semigroups (==0.18.*).
12:39:36 <carter> lhurttila:  WHAT os?
12:39:52 <maerwald> More streamly! 
12:39:55 <carter> lhurttila:  linux mac or what
12:39:58 <lhurttila> carter win 10
12:40:00 <carter> ok
12:40:18 * carter wonders if AndreasK  can fix windows stuff
12:40:24 <carter> ;)
12:40:29 <merijn> zincy__: Because if an (otherwise pure) function can only mutate memory internally, then the result is still pure (same input -> same output) and external code can't observe the mutation
12:40:35 <AndreasK> Can or will?
12:40:59 <zincy__> So I guess you get functorial operations made available on your Free Monad since you have a kind of interpreter
12:41:00 <lhurttila> AndreasK hopefully both ;)
12:41:29 <zincy__> merijn: interesting
12:41:39 <Cale> lhurttila: I looked for github issues on streamly related to windows, and it looks like they're at least *trying* to support windows...
12:41:42 <Cale> https://github.com/composewell/streamly/issues/171
12:41:59 <Cale> In particular, they provide their own clock_gettime for windows
12:42:08 <Cale> but I have no idea what's happening :)
12:42:16 <merijn> zincy__: See this paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.3718&rep=rep1&type=pdf
12:42:28 <merijn> zincy__: Which explains how it works :)
12:42:39 <Cale> zincy__: Well, we can implement Functor
12:42:44 <zincy__> merijn: cheers
12:42:47 <Cale> instance Functor MyIO where
12:42:57 <Cale>   fmap f (Done x) = Done (f x)
12:43:09 <Cale>   fmap f (PutChar c x) = PutChar c (fmap f x)
12:43:11 <AndreasK> What's the Windows issue of the day?
12:43:29 <Cale>   fmap f (GetChar k) = GetChar (\c -> fmap f (k c))
12:43:49 <Cale> and Monad:
12:43:54 <Cale> instance Monad MyIO where
12:43:59 <Cale>   return = Done
12:44:21 <Cale>   (Done x) >>= f = f x
12:44:46 <Cale>   (PutChar c x) >>= f = PutChar c (x >>= f)
12:44:47 <zincy__> yay
12:45:01 <Cale>   (GetChar k) >>= f = GetChar (\c -> k c >>= f)
12:45:10 <Cale> This is fairly mechanical
12:45:28 <zincy__> Generalisation coming?
12:45:44 <Cale> yeah, so Free is the generalisation of this style of defining a monad
12:46:23 <Cale> data Free f a = Done a | Step (f (Free f a))
12:46:53 <Cale> It turns out that if f is any instance of Functor, we get Monad (for free!)
12:47:26 <Cale> for example, the functor corresponding to MyIO from before would look like:
12:47:51 <Cale> data MyIOF act = PutChar c act | GetChar (Char -> act)
12:48:07 <subleq> I found operational to be much easier to understand than free
12:48:20 <Cale> and then  Free MyIOF  would be the "same thing" as MyIO from before
12:49:05 <Cale> and all we have to do is write its Functor instance, and I'll be able to show how that translates into getting a Functor and Monad instance
12:50:28 <zincy__> :)
12:51:16 <Cale> instance Functor MyIOF where fmap f (PutChar c x) = PutChar c (f x); fmap f (GetChar k) = GetChar (\c -> f (k c)) -- note that these are slightly simpler than the ones for MyIO because they don't recurse
12:51:39 <Cale> instance Functor f => Functor (Free f a) where
12:51:50 <Cale>   fmap f (Done x) = Done (f x)
12:51:54 * hackage inline-asm 0.3.1.0 - Inline some Assembly in ur Haskell!  https://hackage.haskell.org/package/inline-asm-0.3.1.0 (0xd34df00d)
12:53:02 <Cale>   fmap f (Step s) = ...
12:53:10 <Cale> Let's take stock of what we have here:
12:53:13 <Cale> f :: a -> b
12:53:21 <Cale> s :: f (Free f a)
12:53:32 <Cale> We want to produce something of type Free f b
12:53:48 <Cale> obviously it's not going to be Done, so let's use Step:
12:53:54 <Cale>   fmap f (Step s) = Step ...
12:54:04 <Cale> now we need something of type f (Free f b)
12:54:46 <Cale> Well, we know f is a functor, so if we had some function of type  Free f a -> Free f b  we could apply fmap to it and be done
12:55:14 <Cale> (i.e. we'd get something of type f (Free f a) -> f (Free f b) which we could apply to s
12:55:16 <Cale> )
12:55:24 * hackage ghc-lib-parser-ex 8.8.5.3 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.3 (shayne_fletcher)
12:55:28 <Cale> But of course, the function we're writing has that type
12:55:40 <Cale> So, we just recurse
12:56:05 <Cale>   fmap f (Step s) = Step (fmap (fmap f) s)
12:56:18 <maerwald> carter: what's your opinion on open variant libraries for ExceptT
12:56:39 <maerwald> I tried haskus-variant, it's a bit awkward. There seem to be a few others, but nothing popular
12:56:43 <Cale> Similarly, we can write a Monad instance
12:56:44 <carter> maerwald: you mean open sums on the fail ?
12:56:57 <maerwald> carter: https://docs.haskus.org/variant/excepts.html
12:57:00 <maerwald> for example
12:58:07 <maerwald> I think matt wrote one too
12:58:59 <maerwald> https://github.com/i-am-tom/oops another one
12:59:09 <carter> i did a thing for that in this old work code a while ago https://github.com/hopper-lang/hopper-v0/blob/master/src/Hopper/Internal/LoweredCore/EvalClosureConvertedANF.hs#L51
12:59:50 <zincy__> Cale: So Free generalises this collapsing action which hinges on f being a functor?
13:00:29 <carter> maerwald:  the problem is, open/extensible  sums are really painful
13:02:13 <Cale> zincy__: Yeah, so Free generalises this pattern of defining data types that represent computations by having data constructors for each of the first things they might do (or representing a finished computation with its result)
13:02:18 <maerwald> I get a lot of trouble on the catching side. It can't infer anything, because the things are "liftable" to each other, so I have to specify the type even if I catch just one particular exception type
13:02:37 <carter> maerwald:  https://github.com/hopper-lang/hopper-v0/commit/99be6c8d3a0643dad02e447c6468fd19fb5888ea#diff-4d7cdba6f40fb7bfc6a28efec6ca8915 is the patch where whe changed from a sum to a existenstional
13:02:40 <carter> yeah
13:02:42 <carter> agreed
13:02:56 <carter> maerwald:  you wind up having inference problems with extensible name sums
13:03:12 <maerwald> And catching is the whole point of it :>
13:03:17 <carter> yeah
13:03:33 <carter> we actually briefly had a hilarous crash
13:04:10 <Cale> zincy__: and yeah, just assuming that f is a functor is enough to guarantee that Free f is a monad
13:04:22 <Cale> Maybe we should see that
13:04:29 <zincy__> Cale: Great thanks for clearing everything up
13:04:33 <Cale> instance Functor f => Monad (Free f) where
13:04:38 <Cale>   return = Done
13:04:40 <zincy__> Merijn: Thanks for helping
13:04:54 <Cale>   (Done v) >>= f = f v
13:05:24 <Cale>   (Step x) >>= f = Step (fmap (>>= f) x)
13:06:02 <Cale> (we could also have started with this and just wrote  instance Functor f => Functor (Free f) where fmap = liftM )
13:06:28 <carter> i had a putatively safe unsafe coerce to allow polymoprhic extension of an open sum
13:06:35 <carter> but where i did the associativity wrong!
13:07:26 <carter> Cale:  maerwald  https://github.com/hopper-lang/hopper-v0/commit/6cb9174eb32f714a965df999d1ea113a1b6f7686#diff-f98b8bf046b2655c54e6216d4cf0c318R28-R33 those highlighted lines for your enjoyment
13:07:52 <Cale> zincy__: I don't often use free monads in production, but it's sometimes kind of nice to have a bunch of things like this, particularly when prototyping and experimenting with how something might turn out
13:08:09 <carter> https://github.com/hopper-lang/hopper-v0/commit/6cb9174eb32f714a965df999d1ea113a1b6f7686#diff-f98b8bf046b2655c54e6216d4cf0c318R28-R43 is probably the full thing
13:08:39 <Cale> zincy__: Usually it ends up being worthwhile to just write code which does the things directly, rather than defers how everything is going to be interpreted until later, but it's nice to have that option regardless.
13:09:15 <zincy__> Thanks for your help Cale
13:09:18 <zincy__> got to head off
13:09:32 <carter> maerwald:  that was my "lets have good inference" api 
13:09:39 <carter> for open explicit errors
13:09:50 <carter> has better inference than some of the other designs
13:09:53 <carter> but still a pain
13:16:36 <lhurttila> Cale I talked with the guy who writes streamly and he thought my issue might be with stack ghci. Just using cabal v2-update and cabal v2-repl --build-depends streamly==0.7.1 I can use streamly imports and it works just fine in the terminal
13:17:07 <carter> cabal is nice
13:17:59 <maerwald> lhurttila: on cabal-3.0.0.0 you can omit the -v2
13:19:58 <lhurttila> maerwald good to know. I'm still using 2.4.1.0 and I have no idea why '=D 
13:20:06 <maerwald> just update!
13:24:39 <Cale> lhurttila: Good to hear you got it figured out
13:25:11 <carter> maerwald:  so the shorter answer is "a good haskell library should have good type infeence in both directiosn whenever possible", and its really hard to get that for those open sums
13:25:18 <carter> in the ways we know how to encode them
13:25:33 <maerwald> Is there another idea to make ExceptT suck less?
13:27:08 <carter> maerwald:  well, depends on what you wanna do
13:27:35 <carter> i think for a given application, you can do a SomeErrorFamily type class that pops in something like SOmeException
13:27:39 <carter> but specifc to your code
13:27:58 <lhurttila> Cale I didn't. At least not with stack. I'm updating cabal to 3.0.0.0 but I don't think that's my issue
13:28:13 <maerwald> carter: so mtl style?
13:28:29 <carter> maerwald:  https://github.com/hopper-lang/hopper-v0/commit/99be6c8d3a0643dad02e447c6468fd19fb5888ea#diff-b02f6b00448bef29d755e019374f8197R9-R23 
13:28:34 <carter> maerwald:  i wouldn't say mtl style
13:28:41 <carter> its compatible with doing it
13:28:46 <carter> but it could be with a different flavor
13:29:06 <carter> that said, i think its also useful to distinguish writing stuff as a library author vs app uthor
13:29:10 <carter> they should be complementary
13:29:23 <carter> but depending on the scope / range of users, there can be very real differnces
13:29:25 <carter> idk
13:29:42 <carter> step zero: whats humane to use and has good type errors / type inference
13:29:45 <carter> start with whatever that is
13:31:33 <carter> maerwald: for interpreters or solvers that can succeed or abort you might like my monad ste
13:31:35 <carter> On hackage
13:35:07 <maerwald> I want: 1. a way to remind myself what kind of errors I previously thought about when I wrote a function, 2. have a way to signal that I handled all errors I thought about, 3. also know when there are less errors than I thought about
13:36:17 <maerwald> I don't trust my tomorrow self
13:37:17 <carter> Ok.
13:37:31 <carter> So.  I have actually an idea for ghc
13:37:42 <carter> Which might be a sane patch for a motivated person
13:38:29 <carter> Step zero: add may throw info to definitions in the .hi files
13:38:41 <carter> Plus some pragmas to manipulate with this info
13:39:00 <carter> I’ve kicked it around for a while
13:39:17 <carter> maerwald: I assume we assume local only errors
13:39:25 <carter> Rather than top down
13:39:37 <carter> And in a sortah io setting?
13:39:40 <maerwald> yeah
13:40:03 <carter> Ok. First, as an aside have you looked at my monad-ste thing on hackage
13:40:13 <maerwald> yeah
13:40:19 <carter> It’s a fun little no dirty state cleanup thing
13:40:36 <carter> You’re wanting in the mix catch and keep on trucking
13:41:19 <carter> maerwald: ping me on Friday midday / afternoon your side and I’ll see about seeing if we can start a branch or something
13:41:48 <carter> It’s something I’ve suggested and shopped around a few times.
13:42:06 <maerwald> nice
13:42:12 <carter> maerwald: the problem with most effect / error tracking is everyone’s forced to opt in
13:42:44 <carter> Instead of being a thing that’s approximated everywhere you can ask to be enforced
13:42:57 <carter> Or you can assert to be some fact
13:43:23 <carter> maerwald: I like having infinite cake and no stomachache
13:43:34 <maerwald> lol
13:43:58 <carter> maerwald: and there’s lots of semantic features you might want to try to add to ghc where you kinda want to know might throw info.
13:44:22 <carter> You can’t really track may throw to/ asynch exceptions or rts signals
13:44:28 <carter> But
13:44:34 <carter> Etc etc.
13:45:07 <carter> maerwald: would helping hack on this or something scratch that nice things itch?
13:45:33 <maerwald> have never hacked on ghc :>
13:45:52 <carter> Who cares. It’s code
13:46:18 <carter> maerwald: your homework before Friday is clone master and get a build working
13:46:26 <maerwald> :P
13:46:30 <carter> Can be a quickest flavor
13:46:39 <carter> If you want nice things we can do it
13:46:44 <carter> But it takes patches
13:47:21 <carter> maerwald: like, magic effect set but built in and pervasively done for free by ghc invisible but opt in!
13:47:28 <carter> Rather than opt out
13:49:52 <carter> maerwald: quickest ghc flavor is slow but builds stage 2 fast
13:51:41 <ClaudiusMaximus> i made a stable topsort thing https://code.mathr.co.uk/barry/blob/HEAD:/barrence/TopSort.hs#l19 any suggestions for improving it?  (I tried fgl, but it seemed to shuffle the output order each time i added a new node-with-edges, maybe i was using it wrong?)
13:52:33 <carter> Hrmm
14:04:24 * hackage lzlib 1.0.3.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.3.0 (vmchale)
14:26:24 * hackage mmsyn7s 0.4.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.4.0.0 (OleksandrZhabenko)
14:50:43 <LysergicDreams> If I define a pure Data.Map.Strict value at the top-level with an expensive computation to generate the map, will that computation be run everytime I use the map, or only the first time?
14:51:15 <davean> Only the first time.
14:51:36 <davean> well, per program run of course
14:51:58 * glguy imagines a setting that writes thunks back to the executable
14:52:08 <LysergicDreams> Awesome, thanks!
14:54:26 <monochrom> That would be what the anthropomorphizer was looking for this morning (as in 3AM EST).
14:54:47 <monochrom> (I was there only because I was working on my midterm test and looking for distraction.)
14:56:28 <jle`> LysergicDreams: as long as it's not polymorphic
14:56:52 <jle`> LysergicDreams: so make sure it's not Num a => Map Int a, or anything
15:01:41 <dmwit> I think you could hack together that would let it happen just once even across program runs with the new compact region stuff.
15:02:10 <dmwit> Could be a fun project to work out how automated that could be made.
15:02:29 <dmwit> (Wouldn't it be neat if you could just write $(calculateOnce 'foo) or something like that?)
15:02:39 <davean> dmwit: I was thinking distributed closures
15:02:56 <dmwit> Sure, similar idea!
15:03:02 <davean> This is the one case where you're guarrented it'll be the same compilation reading the data back in!
15:03:04 <carter> You’d still have to version the cache against the build version.
15:03:14 <carter> Yes what Davean said
15:03:17 <{abby}> glguy: something like emacs unexec?
15:03:35 <carter> More like adding stuff to the object section of the object code file
15:03:39 <carter> Which could be tricky
15:04:06 <dmwit> carter: Why? (Like, if we're actually doing TH stuff here, why can't I just embed the actual right ByteString in the executable itself?)
15:04:21 <carter> You can
15:04:33 <carter> I thought you meant at runtime
15:04:53 * dmwit nods
15:05:07 <dmwit> I understand you now, and I think vice versa.
15:05:29 <davean> its trivial to embed data at compile time!
15:05:40 <davean> its having the executable that updates its self thats tricky
15:05:50 <jle`> i wouldn't say trivial
15:06:00 <jle`> but maybe just that there are less things to worry about
15:06:21 <davean> jle`: theres like a dozen ways to do it, and its all standard compiler/linker stuff used every day
15:06:42 <davean> the fact that your programs compile and run at all means you're already doing it
15:06:45 <jle`> what you described sounds like the opposite of trivial
15:06:52 <dmwit> davean: Oh, yeah, probably better to don't do that. Just eagerly compute the answer once at compile time, and emit the right answer from the start.
15:06:53 <jle`> dozens of different options
15:07:01 <jle`> access to standard compiler/linker stuff
15:07:15 <carter> dmwit: but now we need to cache that across compiles!!
15:07:17 <davean> jle`: Its *already* done
15:07:29 <jle`> now you're going to say that building a car is trivial
15:07:30 <dmwit> carter: aaah whoops
15:07:31 <jle`> because it's already done
15:07:36 <davean> dmwit: Yah, well, that wouldn't be a stupid way to do it, would it?
15:07:55 <davean> jle`: asking for the car your buying to be painted blue is trivial
15:08:10 <davean> when blue is one of the standard color options
15:08:16 <carter> There’s a funny yet interesting way that you can argue that th and other staged computation things are eager
15:08:28 <carter> At least on the result
15:09:05 <carter> Davean I want a fluorescing car 
15:09:08 <carter> That’s safe
15:09:27 <jle`> the act of asking is trivial, but wouldn't say painting a car blue is trivial
15:09:35 <carter> With the color changing commensurate with the uv index
15:09:39 <jle`> that seems more analogous to saying that embedding compile time data is trivial
15:09:51 <carter> It is way easier
15:10:00 <carter> Linkers are harder to deal with
15:10:03 <davean> jle`: I can do it, by hand, in ELF format, in like less than 5 minutes
15:10:05 <jle`> simple, a solved problem, etc. are ways i would describe it
15:10:24 <davean> And most of that 5 minutes is reviewing the magic numbers
15:10:30 <carter> It’s really really hard to change a widely used object code format on a major os
15:10:45 <davean> If I was good at this I could hand add data in less than a minute
15:10:50 <jle`> i guess we are just coming at it from dramatically differnet ideas of what constitutes as trivial
15:11:05 <jle`> that's fair
15:11:11 <jle`> that's why i said i specifically wouldn't call it trivial
15:11:17 <davean> jle`: I mean, anything I can do ever piece of by hand in less than a minute is probably trivial IMO, as long as its not a high skill thing.
15:11:33 <davean> jle`: I could teach a minimum wage worker to do it by hand I'm sure
15:11:37 <carter> Most in place code things need to also make sure the slots in the object code are padded enough for the update to fit
15:11:44 <davean> jle`: its a few numbers and dropping the data in
15:11:58 <davean> You hav to chagne some offsets
15:12:05 <carter> jle`: I think Davean means making it easy to abstract and do blindly yet always works securely is where it leaks
15:12:20 <carter> ?
15:23:59 <carter> Ok yeah. You need to know at “pad creation time” how much space you need to write back the answer. At least with ahead of time compilation
15:35:35 <davean> carter: no you don't
15:36:33 <davean> You just need top leave space for a header table entry to contain the data, which is fixed size, then concatonate the new data to the end of the file, write in the header, then update the count of headers
15:38:24 <davean> like elf is REALLY simple format.
15:38:35 <davean> I'm really confused as to why jle` thinks its so complicated
15:38:56 <davean> I've been able to write an elf file from memory in the past
15:41:05 <carter> Oh ok. I’m usually in mach o sad lands
15:41:11 <carter> That makes sense
15:41:44 <jle`> i don't think it's complicated
15:41:58 <jle`> i just had a different idea of what constitutes as trivial
15:44:20 <davean> carter: Even if you didn't leave space, its not a problem, you just have to slide a little data over and then update a few offsets - the more header entries thoguh the more annoying that is without a tool
15:49:21 <carter> I suppose you’re correct
15:50:31 <dminuoso> How safe is it to unsafeCoerce something to a completely different type and force it (without pattern matching on it)?
15:52:18 <iqubic> very very not safe.
15:52:32 <MarcelineVQ> it's exactly 12 safe
15:52:51 <dminuoso> That's two conflicting answers.
15:52:58 <dminuoso> 12 is far more than very very not.
15:53:08 <hpc> i would think it's in the name
15:53:25 <carter> It will eat your cat
15:53:26 <MarcelineVQ> it's exactly \f safe
15:53:44 <carter> I’m sure there’s a way to turn that into a cve if you’re careful
15:54:01 <dminuoso> Well let's say I have some `Int` and I unsafeCoerce it into (), put it into a map, and when I extract it, I unsafeCoerce it back to an Int.
15:54:23 <dminuoso> Let's for the sake of the argument ensure that I unsafeCoerce back correctly
15:54:25 <koz_> dminuoso: As a key or a value?
15:54:27 <dminuoso> koz_: value
15:55:47 <carter> The problem is there’s only one ()
15:55:52 <dminuoso> So?
15:55:55 <nshepperd> well, seq doesn't care what its first argument is
15:56:14 <nshepperd> doesn't care about its type, that is
15:56:14 <carter> Optimizer might do a thing
15:56:49 <dminuoso> carter: Can it do that, assuming I will never do any operations with that ()
15:56:58 <dminuoso> (We can replace it with some arbitrary `data Some = Some` if you prefer)
15:57:27 <dminuoso> Background: Im rigging up a version of typerep-map that doesn't use types as indices, but rather symbols (which map to types via say type families) as keys 
15:57:59 <carter> Use Any
15:58:28 <carter> dminuoso: look at how I define the box data type in monad-ste pkg
15:58:31 <dminuoso> Interesting, is Any some magic primitive?
15:59:08 <iqubic> Yes.
15:59:28 <jle`> i like to think of Any as an unsafe version of Dynamic
15:59:46 <jle`> it's like Dynamic without the typeable dict
15:59:56 <iqubic> https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#t:Any
16:00:01 <koz_> jle`: So, a black hole where type info goes to die? :P
16:00:07 <jle`> indeed
16:00:24 <jle`> in a lot of my usage of Any, I write everything with Dynamic first to make sure my code is correct
16:00:33 <jle`> then i convert to Any for performance
16:00:35 <iqubic> What's Dynamic do?
16:00:41 <jle`> although i wish there was a better way than that
16:00:54 <dminuoso> jle`: That's precisely what Im looking for!
16:01:04 <jle`> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Dynamic.html
16:01:08 <dminuoso> I want to unsafeCoerce lists of anys to lists of other things, without paying for it! :)
16:01:14 <iqubic> dminuoso: You saw my hackage link, right?
16:01:23 <dminuoso> Thank you carter and jle`!
16:01:53 <carter> dminuoso: my monad-ste has a small use of it
16:02:06 <carter> Trick is naming ;)
16:02:45 <dminuoso> carter: where about? Im not seeing it
16:03:21 <carter> In the source of the .internal at the bottom of the file
16:03:38 <carter> I mean the .unsafe file
16:03:51 <jle`> i use it really heavily in the backprop library
16:03:58 <jle`> for the wengert tape
16:04:12 <carter> https://hackage.haskell.org/package/monad-ste-0.1.0.0/docs/Control-Monad-STE-Internal.html
16:04:17 <carter> Look at the source
16:04:38 <carter> https://hackage.haskell.org/package/monad-ste-0.1.0.0/docs/src/Control.Monad.STE.Internal.html#Box
16:04:52 <iqubic> jle`: Is backprop a neural-net library?
16:05:00 <carter> Ummm. I didn’t use any I guess
16:05:02 <carter> Nvm
16:05:04 <carter> Same idea
16:05:08 <jle`> it's an automatic differentiation library
16:05:17 <jle`> you can use it to build neural networks if you want
16:05:25 <iqubic> Oh. I see.
16:05:40 <iqubic> I'm going to read the docs now.
16:05:47 <iqubic> https://backprop.jle.im/
16:06:14 <carter> dminuoso: so your original code is probably fine
16:06:22 <carter> It’s just good to isolate it somewhere
16:06:43 <carter> I think I did it this way so I don’t force the error by accident
16:07:37 <iqubic> AH...
16:08:02 <iqubic> https://backprop.jle.im/01-getting-started.html
16:08:21 <carter> dminuoso: notice my no unpack.  I think I did unit so I could get a legal typeable instance so I could do exception instance
16:08:51 <iqubic> jle`: What concrete numerical type is GHC selecting for myFunc there, when used with evalBP?
16:09:05 <iqubic> myFunc x = sqrt (x * 4)
16:09:15 <iqubic> evalBP myFunc 9
16:11:01 <jle`> (forall s. BVar s Double -> BVar s Double), although more detail is given later
16:11:09 <iqubic> Right.
16:11:11 <jle`> https://backprop.jle.im/02-a-detailed-look.html
16:11:15 <iqubic> What is the s there?
16:11:40 <jle`> a dummy type variable
16:11:49 <jle`> it's the same trick that runST uses mostly
16:12:16 <iqubic> Right. (Reifies s W => BVar s a -> BVar s b) is where the s comes from.
16:12:38 <iqubic> Nice: For the end user, one can just imagine Reifies s W as a required constraint on s that allows backpropagation to work.
16:14:33 <iqubic> This doesn't make sense: "funcOnList (sequenceVar->[x,y,z]) = sqrt (x / y) * z"
16:14:52 <iqubic> It looks like a view pattern, but I'm not sure there.
16:15:22 <jle`> it's a viewpattern
16:15:25 <dminuoso> carter: I'm planning to do something along these lines https://gist.github.com/dminuoso/0462229e83a7f1a5d128f64ac96b1187
16:15:49 <carter> Ok cool
16:15:57 <iqubic> jle`: And then somehow gradBP somehow returns a list of length 3. Why is that?
16:18:10 <jle`> gradient returns somethjing of the same type you pass in
16:18:17 <jle`> since you are computing the gradient of the input
16:18:20 <iqubic> Ah. I see.
16:18:25 <jle`> so if your function takes a 3-list, then the gradient is a 3-list
16:19:12 <disconsis> Hi guys. I've been hitting my head against this for a while.
16:19:26 <disconsis> https://gist.github.com/disconsis/da3389e6dd369a5596a04cf01d524d2e
16:19:27 <jle`> if you give it [x,y,z] and the result is r, it returns [dr/dx, dr/dy, dz/dy]
16:19:43 <disconsis> Using pipes with haskell is a pain in the ass, maybe because of lazy IO
16:19:45 <koz_> disconsis: What's the problem?
16:20:23 <disconsis> if I create a named pipe, open it and write to it, the writing doesn't take any effect until I close the handle
16:20:31 <jle`> afaik there is no lazy io happening in that code snippet
16:20:41 <jle`> i think you might be noticing buffering
16:20:57 <disconsis> oh shit that would make sense
16:21:09 <dminuoso> disconsis: also, hSetBuffering
16:21:25 <dminuoso> Ah, nevermind. Im too slow :(
16:21:28 <jle`> or hFlush
16:21:48 <jle`> the typical lazy io stuff only happens when reading from a handle i think
16:22:21 <disconsis> *correction: working with named pipes is a pain in the ass
16:22:31 <disconsis> jle`: that works
16:22:35 <disconsis> thanks so much
16:24:12 <jle`> np :)
16:24:41 <d34df00d> Ok, a quickcheck question.
16:24:45 <disconsis> dminuoso: you too :)
16:24:49 <d34df00d> I'm writing a test along the lines of
16:25:09 <d34df00d> property $ \(InfiniteList infList _) (NonNegative count) needle -> let bs = BS.pack $ take (count * 100) infList in countChars needle bs `shouldBe` BS.count needle bs
16:25:14 <dminuoso> Gah the more Im dwelling on this, the more Im convined what I really *need* is fully dependent types..
16:25:24 <d34df00d> And it hangs.
16:26:20 <d34df00d> That is, if I put `traceShow` into my countChars implementation, I see QuickCheck is calling it with larger and larger strings, and my function always terminates, but QC makes no progress.
16:26:22 <d34df00d> What am I doing wrong?
16:26:44 <d34df00d> countChars is currently incorrect, so I expect the test to fail and QC report a test case, but maybe it's trying to shrink forever or something?
16:27:38 <d34df00d> (the reason I'm not using ASCIIString or something is that QC generates too small strings for me — the function I'm testing starts showing interesting behaviour only with strings of a kilobyte or more)
16:29:56 <dminuoso> Is there a way to obtain all types belonging to a typeclass (as far as instances are concerned)? That is, some way that would give me `F :: Constraint -> '[*]`
16:30:24 <nshepperd2> davean, jle`: understanding linker formats? hah! https://zlkj.in:9000/uploads/217e151c9934dd4c/once.hs 
16:31:41 <nshepperd> just put a random string in your binary by mashing the keyboard, then replace that string with the computed value wherever it appears :D
16:32:32 <jle`> now there are two of them
16:32:35 <d34df00d> Ah, nope, it doesn't actually hang, it just takes a few minutes to complete. Wow.
16:32:48 <d34df00d> > Falsifiable (after 12 tests and 1088 shrinks)
16:32:51 <lambdabot>  error:
16:32:51 <lambdabot>      Data constructor not in scope: Falsifiable :: t0 -> terror:
16:32:51 <lambdabot>      • Variable not in scope:
16:33:01 <jle`> dminuoso: in ghci maybe, but not as a type family
16:33:05 <jle`> dminuoso: since it violates open world stuff
16:33:40 <carter> dminuoso: good type inference is best types
16:33:49 <dminuoso> jle`: I'd be perfectly fine with any such violation. Im trying to figure out a way whether I can use MPTC with fundeps to tack type level nats onto it, as to abuse typeclasses for a sort of global open dictionary
16:34:17 <d34df00d> dminuoso: let me know if you find a way. I faced a very similar issue that could be solved very similarly like yesterday.
16:34:40 <d34df00d> And I was also looking at MTPCs, fundeps, type-level symbols to make a global user-extensible dictionary of conversion functions.
16:34:43 <jle`> i'm not sure we are using the same understanding of the word vilation
16:34:46 <nshepperd> I've never used TemplateHaskell but I assume it should be fairly straightforward to make $(once 'foo) generate that random string using IO
16:35:00 <jle`> *violation
16:35:13 <d34df00d> nshepperd: in fact, you have a global (module-global, though) open dictionary with TH.
16:35:13 <jle`> i didn't mean that it breaks guarantees in code, i mean that it is logically inconsistent
16:35:14 <nshepperd> and insert it as a string literal
16:35:24 <d34df00d> jle`: but Haskell is already logically inconsistent!
16:35:28 <d34df00d> Type : Type, all that.
16:35:29 <dminuoso> Say `class Dict (s :: Symbol) (n :: Nat) | s -> n, n -> s; instance "A" 65; instance "B" 66` - and then look things up in that dictionary at runtime 
16:35:45 <dminuoso> d34df00d: I need it across modules
16:36:22 <dminuoso> Oops, that should read `instance Dict "A" 65; instance Dict "B" 66;` of course
16:36:25 <d34df00d> dminuoso: me too! So again I'd be really curious to see if you find a hack.
16:37:06 <dminuoso> d34df00d: I have some ideas involving overlapping instances.
16:38:04 <iqubic> I want full dependent types in haskell. Just shut up and take my money.
16:38:26 <Axman6> Shut up and take my commits a much more useful
16:39:00 <iqubic> Except that I'm too dumb to make commits to GHC proper.
16:39:02 <d34df00d> That escalated quickly.
16:39:27 <iqubic> Also, adding dependent types is going to be a major thing.
16:40:45 <dminuoso> jle`: well I dont care about logical consistency really. if you take the view of a typeclass as being a sort of "set" of types, it's not unreasonable to ask "what members are inside that set (and in scope)"
16:42:12 <jle`> hm, that's not quite the logical consistently i was talking about
16:42:23 <jle`> it was more like "a implies b, and a is true, and b is false"
16:42:27 <jle`> it doesn't make sense
16:42:51 <jle`> if you extrapolate the implications of what you are talking about, you run into nonsensical stuff
16:43:41 <jle`> it's the same sort of thing as a "IsNotAnInstanceOf" constraint
16:44:22 <jle`> foo :: NotInstanceOf Num a => a -> String
16:44:36 <jle`> (since you can implement notaninstanceof in terms of your F)
16:44:43 <jle`> so it carries all the same problems
16:46:24 <d34df00d> jle`: btw what are the problems of NotInstanceOf?
16:50:31 <jle`> it'll give you a different answer across modules
16:50:43 <jle`> which is a problem if you use the same value across modules
16:52:16 <jle`> or hm, i mean NotAnInstanceOf Num a ~ 'True => ..., more literally
16:52:24 <jle`> or IsAnInstanceOf Num a ~ 'False
17:08:02 <monochrom> Just say "just take my money". :)
17:28:58 <sm[m]> my parser ends with this line: char '%' >> someparser, so the result doesn't include the % character. What's a concise way to include it  ?
17:31:00 <ski>   liftA2 (:) (char '%') someparser  -- maybe ?
17:50:10 <sm[m]> ski, thanks. I think I'll stick to the boring way
17:51:12 <sm[m]> it has acquired some extra logic. Will remember that though
18:01:13 <d34df00d> jle`: ah, haven't thought about cross-module stuff for some reason. Thanks, that makes sense!
18:31:26 <koz_> I have a new-found appreciation for (micro)lenses.
18:36:12 <suzu> how come?
18:36:32 <koz_> suzu: Lots of stuff in MonadState and MonadReader involving... involved types.
18:38:04 <iqubic> koz_: Like what?
18:38:27 <walterclements[m> Is there a built-in function like `any` but with functions instead of items?
18:38:27 <walterclements[m> like `something :: Foldable t => t (a -> Bool) -> a -> Bool`
18:38:41 <koz_> iqubic: Like record types housing multiple environment or state thingies, because unfortunately MonadReader and MonadState have inference issues.
18:38:55 <koz_> (or rather, they have _rigidity_ issues, because otherwise their inference issues would be even worse)
18:39:00 <iqubic> Oh that's annoying.
18:39:39 <xavo[m]> @type \fs x -> any ($ x) fs
18:39:40 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
18:40:16 <xavo[m]> walterclements: not that I know of, but there's this
18:40:33 <koz_> @pl \fs x -> any ($ x) fs
18:40:33 <lambdabot> flip (any . flip id)
18:40:35 <koz_> :D
18:41:01 <xavo[m]> `flip id`...
18:41:19 <koz_> xavo[m]: Yeah, that's definitely unusual.
18:41:27 <xavo[m]> I know that's just (&) but it still looks funky
18:41:47 <koz_> :t (&)
18:41:49 <lambdabot> a -> (a -> b) -> b
18:41:58 <koz_> Oh yeah, sure.
18:44:51 <iqubic> :t (flip id id)
18:44:52 <lambdabot> ((a -> a) -> c) -> c
18:45:16 <xavo[m]> :t flip $ flip id id
18:45:18 <lambdabot> b -> ((a -> a) -> b -> c) -> c
18:45:24 * hackage antiope-es 7.5.0 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-es-7.5.0 (arbornetworks)
18:45:26 <iqubic> AH!!!
18:46:00 <walterclements[m> :t foldl (\f g x -> f x || g x) (const True)
18:46:01 <lambdabot> Foldable t1 => t1 (t2 -> Bool) -> t2 -> Bool
18:46:24 * hackage antiope-sqs 7.5.0, antiope-messages 7.5.0, antiope-dynamodb 7.5.0, antiope-contract 7.5.0, antiope-core 7.5.0, antiope-s3 7.5.0, antiope-sns 7.5.0, antiope-shell 7.5.0, antiope-athena 7.5.0, antiope-optparse-applicative 7.5.0 (arbornetworks)
18:47:19 <walterclements[m> not working :(
18:47:28 <koz_> walterclements[m: What's wrong with what xavo[m] suggested?
18:47:46 <walterclements[m> nothing
18:47:53 <walterclements[m> mine isn't working
18:49:18 <xavo[m]> tbh I've never understood the funky foldl-with-arg idiom
18:50:52 <ski> walterclements[m : s/True/False/
18:52:14 <ski> i'd probably use `foldr', as well
18:52:51 <xavo[m]> const True :: a -> Bool
18:52:51 <xavo[m]> liftA2 (||) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
18:52:51 <xavo[m]> foldl :: ((a -> Bool) -> (a -> Bool) -> a -> Bool) -> (a -> Bool) -> t (a -> Bool) -> a -> Bool
18:52:57 <xavo[m]> that's so visually noisy
18:53:34 <xavo[m]> I think I get it if I think in terms of Reader
18:54:00 <walterclements[m> >s/True/False/
18:54:00 <walterclements[m> that doesn't work with empty lists
18:54:01 <walterclements[m>  * > s/True/False/
18:54:01 <walterclements[m> that doesn't work with empty lists
18:55:47 <xavo[m]> do you expect it to return True for empty foldables?
18:56:23 <walterclements[m> True is identity of (||) so yes
18:56:37 <xavo[m]> it isn't
18:57:34 <walterclements[m> wait
18:57:34 <walterclements[m> yes it isn't
18:57:54 <xavo[m]> there's a monoid about this but I can't remember what it's called
18:58:15 <xavo[m]> oh, it's Any as wel
18:58:22 <xavo[m]> s/$/l/
19:00:29 <walterclements[m> so it works
19:00:30 <walterclements[m> thx
19:01:22 <xavo[m]> nice, np
19:05:25 <iqubic> false is the identity of (||)
19:06:00 <iqubic> > False || True
19:06:03 <lambdabot>  True
19:06:16 <iqubic> @check (\x -> False || x)
19:06:19 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
19:06:19 <lambdabot>  False
19:06:28 <iqubic> @check (\x -> False || x == x)
19:06:31 <lambdabot>  +++ OK, passed 100 tests.
19:06:43 <iqubic> @check (\x -> x || False == x)
19:06:43 <ski> needs more brackets
19:06:46 <lambdabot>  +++ OK, passed 100 tests.
19:07:00 <iqubic> @check (\x -> (x || False) == x)
19:07:03 <lambdabot>  +++ OK, passed 100 tests.
19:07:11 <iqubic> @check (\x -> (False || x) == x)
19:07:14 <lambdabot>  +++ OK, passed 100 tests.
19:07:29 <iqubic> Done. Proof that False is the identity.
19:07:37 <xavo[m]> @check (\(x) -> ((==) ((||) x (False)) (x)))
19:07:41 <lambdabot>  +++ OK, passed 100 tests.
19:08:01 <xavo[m]> oh wow the parens matched lmao
19:08:14 <xavo[m]> I should become a lisp programmer
19:08:17 <ski> @check (False || undefined) == undefined
19:08:20 <lambdabot>  *** Failed! Exception: 'Prelude.undefined
19:08:20 <lambdabot>  CallStack (from HasCallStack): error, called at libraries/base/GHC/Err.hs:78...
19:08:30 <ski> xavo[m] : redundant brackets detected
19:09:06 <xavo[m]> that's the idea, yes
19:09:18 <iqubic> @check (\x -> (==) ((||) x False) x)
19:09:21 <lambdabot>  +++ OK, passed 100 tests.
19:09:39 <iqubic> Everything is now prefix, with no redundant brackets.
19:09:40 <ski> (Lispers don't put in extra redundant brackets. every bracket has a meaning)
19:09:53 <iqubic> yeah.
19:10:12 <ski> well, you forgot the outer pair, but ok
19:10:46 <xavo[m]> @check liftA2 (==) (|| False) id
19:10:49 <lambdabot>  +++ OK, passed 100 tests.
19:10:59 <iqubic> Cool
19:11:30 <xavo[m]> ty lol
19:17:40 <ski> @check (==) <*> (|| False)
19:17:43 <lambdabot>  +++ OK, passed 100 tests.
19:20:52 <xavo[m]> ooh
19:34:52 <sheepduke> Quick question: Why "2.3 * 12" in the GHCI gave me a very strange result?
19:35:38 <ski> @where floating-point
19:35:38 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
19:35:38 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
19:36:40 <sheepduke> Oops. I thought Haskell could handle it..
19:36:59 <sheepduke> I will check it out. Thanks for help.
19:37:18 <Axman6> > 2.3 * 12
19:37:21 <lambdabot>  27.599999999999998
19:37:27 <Axman6> > 2.3 * 12 :: Rational
19:37:29 <lambdabot>  138 % 5
19:37:49 <ski> > 2.3 * 12 :: CReal
19:37:51 <lambdabot>  27.6
19:38:18 <Axman6> sheepduke:basically if you need that not to happen, you need to not use Doubles, since those are just IEEE-754 doubles and the language's hands are tied when it comes to how it can deal with them
19:39:08 <sheepduke> Hmmm...Any precise fractional arithmetic in Haskell? Like in Common Lisp?
19:39:13 <koz_> IEEE-754 is one of the many reason we can't have nice things. :P
19:39:20 <koz_> sheepduke: Rational is what you seek there.
19:39:38 <ski> > let nan = 0 / 0 in nan == nan
19:39:41 <lambdabot>  False
19:40:30 <sheepduke> IEEE-754 is soooo funny.
19:40:48 <sheepduke> Evaluating (2.3 :: Rational) * 12 gave 138 % 5
19:40:55 <sheepduke> and 138 / 5 gave 27.6
19:41:12 <sheepduke> but (2.3 :: Double) * 12 gave 27.599999....
19:41:47 <sheepduke> But Rational is slower, I suppose?
19:41:52 <Axman6> right, because that number is not exactly representable in a finite number of bits using IEEE-754 doubles
19:42:05 <Axman6> yes, Rational is a pair of Integers
19:42:41 <Axman6> so it can represent arbitrarily large or small fractional numbers but the maths will be significantly slower
19:43:49 <sheepduke> Understood. So in Haskell you got fast but not precise calculation by default, and you may trade for precision with performance if you want.
19:44:22 <sheepduke> So "so" is a user here...Every time we type "so", we are actually summoning him?
19:44:39 <jackdk> it must be a so-so experience for him.
19:44:44 <iqubic> Oh.
19:45:19 <Axman6> that's just the stack overflow bot being trained on our answers in here to synthesise answers to questions
19:46:10 <sheepduke> Axman6 Really?
19:46:39 <Axman6> no
19:46:50 <sheepduke> You got me.
19:47:28 <MarcelineVQ> :ok:
19:47:38 <Axman6> #gottem
19:58:18 <monochrom> I am the bot.
19:58:31 <monochrom> I am a dalek. Exterminate all humans!
19:58:57 <iqubic> I am a cyberman. All humans will be upgraded.
19:59:31 <monochrom> "Resistance is futile" from both of us. :)
20:00:13 <iqubic> Resistance is futile. You shall be upgraded.
20:32:48 <Axman6> Resistance is I/V
20:37:19 <MarcelineVQ> howdareyou.jpeg
21:04:31 <shiraeeshi> what if upgrade function is id?
21:04:41 <shiraeeshi> upgrade = id
21:12:28 <pavonia> shiraeeshi: Is there some context to that question?
21:13:11 <MarcelineVQ> dalek and cybermen jokes from earlier
21:14:53 * hackage typelits-printf 0.1.0.0 - Type-safe printf from parsing GHC TypeLits Symbol  https://hackage.haskell.org/package/typelits-printf-0.1.0.0 (jle)
21:20:59 <shiraeeshi> maybe it's something like this: upgrade = nextVersion . destroy . sleep
21:28:04 <shiraeeshi> upgrade = wakeup . createNextVersionOfWorld . destroyOldVersionOfWorld . sleep
21:29:30 <ski> hopefully those middle functions get fused together
21:30:28 <iqubic> ski: I'd hope so.
21:30:42 <iqubic> Is there an irc channel for obelisk?
21:49:25 <xacktm> iqubic: obelisk by obsidian?  #reflex-frp
21:49:35 <iqubic> Yeah. That's it.
21:50:38 <shiraeeshi> upgrade = resume . switchWorlds . createNextVersionOfWorld . pause
21:57:47 <mjrosenb> hello again, all.  I was hoping for a bit of help lensifying a non-lensy expression:
21:57:50 <mjrosenb> [c | Cell.Rogue (Cell {_character = Player _, _underlying = MC.MatchCell {MC._color=c}}) <- A.elems (ls ^. Model.grid)]
21:59:18 <xavo[m]> not the most experienced w/ optics but first thing I noticed is that you can use `traversed` directly since Array is Traversable
22:01:16 <mjrosenb> yes, I also got that far, but after that, it kinda falls apart, since I want to drill down based on one lens, but return a larger expression.
22:01:46 <mjrosenb> I think I had it up to ls ^. Models.grid . traversed . filtered
22:02:18 <jle`> looks like you're turning the elements into a list
22:02:27 <jle`> so it might be ^.. you are looking for
22:02:27 <xavo[m]> what do you mean by "based on one lens?"
22:02:31 <xavo[m]> also, is Cell.Rogue part of a sum type?
22:02:43 <mjrosenb> xavo[m]: it is.
22:02:56 <jle`> mjrosenb: so maybe ls ^.. Model.grid . folded . underlying . color
22:03:17 <jle`> or toListOf (Model.grid . folded . underlying . color) ls
22:03:33 <xavo[m]> you probably want a prism for the Cell.Rogue bit as well
22:03:40 <jle`> ah yeah that
22:03:59 <jle`> ls ^.. Model.grid . folded . _Rogue . underlying . color, perhaps?
22:04:20 <mjrosenb> the _character = Player pattern is quite important.
22:04:41 <xavo[m]> ohh, didn't notice that
22:05:17 <iqubic> You'd need to use filtering or filteredBy depending on what you want.
22:06:20 <jle`> hm, ls ^.. Model.grid . folded . _Rogle . filteredBy (_Player . character) . underlying . color, maybe
22:06:38 <jle`> or filtered ((== Player) . _character) instead of filteredBy
22:10:58 <mjrosenb> jle`: Player is a data constructor that takes one argument :-(
22:12:02 <jle`> mjrosenb: what is that in reference to?
22:12:04 <xavo[m]> let isPlayer = \case { Player _ -> True; _ -> False } in ...
22:12:09 <jle`> ah, i see
22:12:15 <jle`> mjrosenb: yeah, you can just use _Player in the iflteredBy
22:12:24 <jle`> or if you have teh prism already, xavo[m]'s isPlayer is `has _Player`
22:12:48 <jle`> > has _Just <$> [Nothing, Just 3, Just 5]
22:12:51 <lambdabot>  [False,True,True]
22:13:05 <jle`> er also i think i flipped the order in that fileteredBy
22:13:12 <xavo[m]> ooh that's neat
22:13:16 <xavo[m]> i need to learn more about prisms and folds really
22:13:38 <iqubic> jle`: Character is a sum type. We want to filter and keep the entries where Character is constructed with the Player constructor. So we can use has.
22:13:38 <jle`> has is just a Fold thing, yeah
22:13:55 <jle`> it's `null . toListOf p`, basically
22:14:05 <mjrosenb> the documentation for has kind of scared me.
22:14:11 <iqubic> What's the difference between isn't and hasn't?
22:14:30 <jle`> xavo[m]: a Fold lets you get a list of every targed item, and if you can get a list of every targeted item, you can check if there are any of them are not
22:14:43 <Cale> mjrosenb: Which has?
22:14:52 <iqubic> :t has
22:14:54 <lambdabot> Getting Any s a -> s -> Bool
22:14:57 <Cale> oh, that has
22:14:59 <Cale> okay :)
22:15:07 <iqubic> I'd assume that one, given the current conversation
22:15:09 <jle`> mjrosenb: if you understand toListOf, then has p = not . null . toListOf p
22:15:18 <xavo[m]> jle`: what's the difference between a Fold and a Traversal, then?
22:15:20 <Cale> Yeah, sorry, I just glanced over without context :)
22:15:26 <xavo[m]> oh nice job client
22:15:37 <iqubic> xavo[m]: Traversals allow you to change the data.
22:15:37 <jle`> xavo[m]: the same difference between Foldable and Traversable: a Traversal lets you modify an existing structure
22:15:43 <jle`> xavo[m]: but a Foldable/Fold is one-way
22:15:46 <xavo[m]> ohh
22:15:48 <Cale> I'm also responsible for something called has which has an interesting type
22:16:15 <jle`> xavo[m]: you only need a Fold to implement has, since you don't want to modify the value, you just want a one-way inspection of it
22:16:21 <xavo[m]> oh, wait, right, Traversable implies Foldable already
22:16:23 <jle`> to extract data from it and never put it back
22:16:24 <Cale> (the one from constraints-extras)
22:16:42 <xavo[m]> right
22:16:59 <iqubic> > [(1,2),(3,4),(5,6)] & traversed . each %~ (*3)
22:17:03 <lambdabot>  [(3,6),(9,12),(15,18)]
22:17:09 <iqubic> That's not possible with a fold.
22:17:16 <mjrosenb> jle`: this is my first foray into traversals, so I don't quite grok toListOf yet.
22:17:33 <jle`> mjrosenb: if you think of `Fold a b` as "i can get a list of every 'b' in the 'a'"
22:17:40 <jle`> the toListOf :: Fold a b -> a -> [b]
22:17:44 <iqubic> Folds only support getting the elements. Traversals support modifying the elemnets too.
22:17:46 <jle`> it gets the list of every 'b' in the 'a'
22:17:52 <jle`> and gets you just exactly that list
22:18:10 <xavo[m]> somewhat related: does optics have an equivalent of filteredBy?
22:18:15 <jle`> > toListOf _1 (3,4)
22:18:18 <lambdabot>  [3]
22:18:44 <jle`> here _1 :: Fold (a,b) a, it gets you every 'a' in the '(a, b)'
22:19:08 <iqubic> xavo[m]: I actually don't think so.
22:19:18 <jle`> i suppose i should be more clear, it's not "every", just "some", maybe
22:19:33 <jle`> `Fold a b` targets 0 or more b's inside an a
22:19:34 <mjrosenb> speaking of filteredBy, do I have to import something other than Control.Lens to get it?
22:19:37 <Axman6> :t having
22:19:40 <lambdabot> error:
22:19:40 <lambdabot>     • Variable not in scope: having
22:19:40 <lambdabot>     • Perhaps you meant one of these:
22:19:48 <Axman6> % :t having
22:19:49 <yahb> Axman6: ; <interactive>:1:1: error:; * Variable not in scope: having; * Perhaps you meant one of these: `hang' (imported from Text.PrettyPrint.HughesPJ), `taking' (imported from Control.Lens)
22:19:54 <iqubic> mjrosenb: Nope.
22:19:57 <xavo[m]> iqubic: damn, I've been liking the profunctor encoding lately and that seems like a nice one to have around
22:20:06 <jle`> mjrosenb: toListOf is ^.., the thing i used earlier
22:20:41 <jle`> mjrosenb: so basically (Model.grid . folded . _Rogue . ... . underlying . color) is a Fold (Array ...) Color
22:20:51 <jle`> it targets a bunch of Color's in an Array
22:20:58 <jle`> (0 or more)
22:21:13 <jle`> and you can use toListOf with that Fold, to get all the colors in that array
22:21:25 <jle`> er, Fold Grid Color
22:21:25 <mjrosenb> ghci is telling me that filteredBy is not in scope.
22:22:02 <xavo[m]> highly recommend importing it
22:22:19 <mjrosenb> Control.Lens is imported.
22:22:23 <mjrosenb> I have folded.
22:22:27 <xavo[m]> it's in Control.Lens.Combinators or Control.Lens.Fold, apparently
22:22:29 <mjrosenb> is my version of lens ancient?
22:22:42 <iqubic> No. I just gave you bad info.
22:22:55 <iqubic> mjrosenb: just import Control.Lens.Combinators
22:24:44 <mjrosenb> http://dpaste.com/224XDYE
22:25:58 <iqubic> at this point I'm going to recommend updating lens.
22:27:36 <mjrosenb> looks like I have 4.16.1, which the docs say has filteredBy.
22:27:40 <mjrosenb> err
22:27:49 <mjrosenb> no. I got redirected to 4.19.1
22:30:59 <mjrosenb> in which case, I need to figure out how to update lens, this could be exciting.
22:31:40 <jle`> should just be a bump in your package.yaml or cabal file
22:31:44 <jle`> or stackage resolver
22:31:56 <jle`> as soon as i wrote that out i regretted saying 'just'
22:32:29 <mjrosenb> some mistakes have been made in this project
22:32:44 <mjrosenb> such as assuming that I could figure out enough nix to actually use it.
22:33:30 <iqubic> mjrosenb: if you want to ask for help in #nixos, people would be willing to help you.
22:34:18 <mjrosenb> yeah, that is why I have a default.nix that works at all.
22:34:48 <mjrosenb> #nixos or just #nix?
22:35:06 <iqubic> #nixos.
22:35:39 <iqubic> But they are fine helping people who are only using nix and not full nixos.
22:47:55 <mjrosenb> it looks like that version was released in july 2018, is filteredBy that new?
22:49:40 <mjrosenb> ah, yup.
22:49:51 <mjrosenb> changelog says it was added in 4.18
23:05:04 <justsomeguy> Is there a better alternative to stack?
23:06:19 <justsomeguy> Oh, it's 2am. ...I should sleep.
23:09:21 <yushyin> justsomeguy: the alternatives are ghcup+cabal and/or nix
23:13:03 <justsomeguy> ghcup is a new one to me. It seems much simpler than stack. I think I'm probably going to have to learn nix.
23:41:24 * hackage deriving-aeson 0 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0 (FumiakiKinoshita)
