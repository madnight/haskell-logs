00:18:28 <zincy_> Teaching Haskell is hard!
00:18:46 <dminuoso> Teaching is hard.
00:18:50 <zincy_> It is easy to get confused and feel like an idiot :D
00:18:58 <zincy_> True true
00:19:08 <dminuoso> Or rather, teaching well is hard.
00:24:31 <idnar> why is/isn't a signature like `IO a -> IO b` better than `IO a -> IO Void`?
00:28:36 <[exa]> zincy_: take it as a challenge, show the students how to systematically get out of confusion!
00:28:49 * [exa] (doing that quite often)
00:30:15 <[exa]> idnar: "Void" says "this won't exist" much cleaner than an unbound type variable
00:30:48 <dminuoso> [exa]: It's not unbound.
00:31:22 <idnar> I guess Void isn't Haskell '98?
00:32:07 <dminuoso> idnar: It should be.
00:32:12 <arianvp> It's useful to have a type variable instead of Void in covariant positions
00:32:13 <[exa]> idnar: 'data Void' is perfectly okay declaration
00:32:19 <dminuoso> idnar: You can define it as `data Void` 
00:32:21 <arianvp> Because then you don't need to discharge void using absurd
00:32:40 <arianvp> Or contravariant... I always confuse the two
00:32:59 <dminuoso> idnar: Another consideration, is that Void is less composable. So it requires you sprinkle absurd left and right to interface with code.
00:33:16 <merijn> [exa]: Not in Haskell98 :p
00:33:19 <[exa]> dminuoso: well that's right, it's bound by forall... what's the correct name for that property, then?
00:33:21 <int-e> dminuoso: Haskell 98 has no empty data types, unless you count the odd newtype Void = Void Void thing.
00:33:23 <[exa]> merijn: oh noes
00:33:41 <dminuoso> int-e: That works for me.
00:33:42 <merijn> [exa]: The EmptyDataDecls extension was only added in the standard in Haskell2010
00:34:21 <int-e> (and that probably doesn't do what you want when pattern matching)
00:37:17 <dminuoso> [exa]: I dont know whether there is a name for it. But you could think of it as `f :: IO a -> (forall b. IO b)`
00:37:22 <idnar> I have some code where I couldn't decide between `Async Void` and `Async a` and I'm trying to tidy up now
00:37:41 <dminuoso> [exa]: It's just that by law you can float that forall to the left
00:38:03 <dminuoso> idnar: Just try it out with Void and see for yourself. :)
00:39:06 <idnar> I enjoyed writing `either throwIO absurd`
00:39:50 <dminuoso> idnar: You can use absurd whether you have Void there or not.
00:40:05 <idnar> yeah
00:42:44 <merijn> Extremely cursed: https://twitter.com/paf31/status/1228097036773281792
00:47:28 <int-e> Just don't.
00:48:07 <int-e> (Now, how does one run that screenshot in ghci?)
00:50:08 <Arahael> merijn: I'm depressed that that don'tn't made sense. :(
00:50:53 <[exa]> 'lAnGuAgE', why??!
00:51:23 <merijn> [exa]: I told you it was extremely cursed :p
00:51:31 <int-e> [exa]: I think it's expressing a sadistic streak
00:51:33 <phadej> LaNGuaGe
00:51:52 <phadej> I hope GHC would also accept LANGAUGE
00:51:53 <int-e> Or maybe sAdIsTiC
00:52:00 <merijn> Arahael: pfft, I'm used to much larger contractions
00:52:11 <merijn> phadej: I do know most extensions accept both US and UK spelling :p
00:52:34 <phadej> merijn: yes, they should also accept a spelling I personally write way too often :/
00:52:44 <[exa]> can't decide whether I'm deimpressed or imdepressed
00:52:47 <idnar> LANGOUGE
00:53:05 <phadej> as urban dictionary puts it:
00:53:06 <phadej> A word like Enlgish, recognizable only in print since its pronunciation is indistinguishable from its cognate, language. Often appears in important documents like resumes, cover letters and masters' theses. Usually found only after the document has been sent, but also found in many places on the Internet. Users curse themselves silently and swear they will only use the phone from now on.
00:53:12 <phadej> https://www.urbandictionary.com/define.php?term=langauge
00:53:34 <phadej> that don'tn't ever happened to me
00:55:04 <merijn> Arahael: I speak Dutch, so I'm used to arbitrarily long concatenations anyway that don'tn't doesn't seem that bad :p
00:55:20 <int-e> phadej: I was following that up to the point where it suggested phones as a solution...
00:56:01 <Arahael> merijn: Fair enough. I speak Australian, so we go the other way. ;)
00:56:04 <phadej> int-e: :)
00:56:13 <[exa]> phadej: please do not cause throwIO in people
00:57:03 <phadej> (really I just need to configure my editor to tab comple {-# LAN to proper spelling
00:57:17 <phadej> I often can concentrate for three letter
00:57:17 <phadej> s
00:57:29 <int-e> Haha
01:02:28 <tdammers> merijn: shouldn't you say "doesn'tn't soundn't too bad"?
01:03:22 <tdammers> personally, I'm proud enpough of myself just for making it past '{-#' in the first attempt
01:06:37 <boxscape> I always dread typing that first extension but hey after that you can just copy paste that line to enter more
01:09:53 <hololeap> jackdk: what did you mean by proper binary caches (referring to the nixos vs gentoo topic)?
01:10:49 <int-e> boxscape: you can put several extensions into the same LANGUAGE pragma, too, separated by commas. (Though somehow, I've stopped doing that. Not sure why exactly.)
01:10:51 <zincy_> [exa]: I like that approach!
01:11:30 <boxscape> int-e I'm aware but I prefer the one extension per pragma approach. Looks tidier.
01:11:47 <boxscape> Even though usually I avoid code duplication at all costs, hmmm
01:14:32 <merijn> boxscape: Also better/nicer diffs
01:14:48 <merijn> int-e: Because you get easier to grok diffs, probably :p
01:15:37 <boxscape> merijn well, you could still do one extension per line even if you wrote all of them into one pragma
01:15:55 <merijn> boxscape: But that looks ugly :(
01:15:59 <boxscape> that's true
01:16:21 <merijn> I wish more languages were designed to accommodate nice/pretty wrapping for every syntax construct
01:18:12 <__monty__> I'd be pretty similar to the prefix syntax for records though. Can you prefix the first extension with a comma?
01:18:37 <__monty__> *it
01:27:02 <hololeap> why would you prefix the first item in a list with a comma?
01:27:15 <boxscape> so that every line looks the same
01:27:25 <boxscape> i.e. every line begins with a comma
01:27:40 <boxscape> which means if you change the first item you don't mess up the diff
01:27:53 <hololeap> yeah, i guess that is the obvious answer
01:28:25 <hololeap> i've made that mistake occasionally
01:33:27 <[exa]> zincy_: kindof makes them better prepared for actually failing themselves I guess
01:41:11 <__monty__> hololeap: I wouldn't do it with normal lists or tuples but the pragma itself kinda looks like an item and the discussion was about syntax that looks nice when wrapping : )
01:41:18 <jonathan_> A few years ago, I did a lot of C# programming. One language feature I kinda miss is the nameof()-construct, where you turn variable/function names into strings at compile time. Is there a similar thing in haskell? Maybe some templatehaskell function?
01:43:24 <jonathan_> This is convenient for populating exceptions with text. Stupid example: "nameof(myDenominator) cant be zero!" is better than "myDenominator cant be zero!" since you are forced to update the exception text when you change the name of the variable/function mentioned
01:44:15 <jonathan_> *edit: I mean nameof(myDenominator) ++ " cant be zero!"
01:46:41 <__monty__> jonathan_: TH has some pretty printing.
01:47:03 <sshine> jonathan_, Lorimer?
01:49:51 <Taneb> $(pure . LitE . StringL $ show 'foo)
01:50:14 <sshine> jonathan_, I recall a fellow student at university who was into extending Standard ML with all sorts of preprocessing, including exceptions annotated by their (file, column, row). https://github.com/br0ns/PreML#annotate-fail-exceptions-with-a-file-position -- I think you can get to similar features using TH significantly faster. but I haven't seen it in use.
01:50:21 <sshine> oh, wow. nice.
01:50:57 <Poscat[m]> jonathan_: I cant understand how that is a problem, the error message should only depend on the meaning of the variable instead of the variable name.
01:51:24 <boxscape> plenty of Prelude error messages depend on the function name
01:51:27 <boxscape> > head []
01:51:30 <lambdabot>  *Exception: Prelude.head: empty list
01:51:33 <fishooter> Hi, I'm a beginner and I'm trying to implement something like https://wyag.thb.lt/ in Haskell. This is what I've come up with as an alternative to argparser: https://repl.it/@sustrmic/haskell-git could you give me some feedback please? :)
01:51:40 <boxscape> (though hard-coded of course)
01:52:10 <fishooter> obviously I didn't implement the commands yet.
01:53:54 <Taneb> $(stringE $ show 'id) is shorter
01:54:38 <sshine> fishooter, what kind of feedback would you like?
01:55:51 <Poscat[m]> I believe intellij will search for the variable name in comments and strings when renaming.
02:00:41 <fishooter> sshine: 1) is this how you would do the argument parsing? 2) are the type definitions meaningful? 3) can dispatch be simplified? (repeated usage of variables)
02:01:30 <merijn> fishooter: For argument parsing I'd say optparse-applicative
02:02:44 <merijn> Ah, wait, you were already using argparser
02:04:29 <boxscape> fishooter newtypes give you a lot more typesafety than type synonyms
02:12:45 <fishooter> merijn: is optparse-applicative somehow better?
02:13:35 <merijn> fishooter: It's slightly more verbose, but gives you far more detailed control over the parser you build
02:14:05 <fishooter> boxscape: you suggest using newtype for the GitCommand, correct? :)
02:14:31 <fishooter> merijn: ok I will give it a shot
02:14:53 <boxscape> fishooter I'm suggesting it for Commit, DoWrite, etc, i.e. all the types that are just String
02:15:11 <hc> nice :)
02:15:43 <boxscape> fishooter with "type" you can accidentally pass an ObjectName to a function when it expects a Commit for example, but with "newtypes" that is much less likely
02:17:20 <fishooter> ah, so "type" is more like an "alias", different name for the same thing (like typedef in C++), and "newtype" is treated as a completely different thing, even though it behaves the same?
02:17:38 <boxscape> exactly, it's called a "type synonym"
02:17:58 <fishooter> got it, thanks
02:18:11 <boxscape> and newtypes (as opposed to data) give you no performance penalty over using "type"
02:19:57 <fishooter> hmmm :) but then it cannot be used with the parser
02:20:20 <fishooter> because you need to have a way to transform String -> ObjectType for example
02:20:29 <fishooter> even though newtype ObjectType = ObjectType String 
02:21:21 <boxscape> if you write "newtype ObjectType = ObjectType String" then "ObjectType" is a function of type "String -> ObjectType"
02:32:08 <boxscape> fishooter you basically don't have to change anything in your program if you write this:
02:32:09 <boxscape> newtype ObjectType = ObjectType String deriving (Show, RawRead)
02:32:42 <boxscape> though you will have to import "System.Console.ArgParser.QuickParams" (because that's where RawRead is defined)
02:33:12 <boxscape> and enable the "GeneralizedNewType" Extension by putting {-# LANGUAGE GeneralizedNewtypeDeriving #-} at the top of your file
02:33:39 <boxscape> this is what allows you to derive RawRead the way it is defined on String for a newtype that wraps a String
02:34:04 <boxscape> And deriving RawRead like this means you can still use it with the Parser
02:34:33 <fishooter> awesome! :) you just read my thought
02:34:40 <fishooter> *thoughts
02:34:42 <boxscape> :)
02:55:46 <fishooter> I am a bit struggling, how do I make a sub-parser that doesn't accept any arguments?
02:55:55 <fishooter> I tried  ( "show-ref", mkDefaultApp (CommandShowRef) "show-ref")
02:56:00 <fishooter> but that doesn't work
02:58:23 * hackage acts 0.2.0.0 - Semigroup actions, groups, and torsors.  https://hackage.haskell.org/package/acts-0.2.0.0 (sheaf)
02:59:51 <nschoe> Hi everyone, does anyone know of some Haskell projects using qtah? I'd like to look at the source code to see how it's organized, etc. I've looked at qtah-example, but I'd like to have one or two more examples. Thanks.
03:05:47 <srk> fishooter: with pure?
03:08:24 <hexagoxel> with postgresql-query, is there a way to make use of ToRow instances inside sqlExp splices?
03:09:31 <hexagoxel> or sqlExp QQs rather
03:10:43 <jonathan_> __monty__: ty I'll check it out
03:11:42 <__monty__> jonathan_: Look into what Taneb shared as well. I think that was basically a literal solution.
03:12:52 <boxscape> % $(stringE $ show 'id)
03:12:53 <yahb> boxscape: "GHC.Base.id"
03:13:03 <jonathan_> okay, I'll make sure to
03:13:08 <jonathan_> Taneb: ty
03:13:28 <Taneb> :)
03:21:41 <jonathan_> Having never used TH before, I'm trying to wrap my head around "$(pure . LitE . StringL $ show 'foo)". I assume foo is the variable we want the name of. the '-prefix + show returns a string with the name, the StringL -> LitE converts the string to an "expression", and the pure raises it to whatever applicative $ needs in order to do its job
03:22:12 <happycoder> What is meant by "indexed data type"?
03:22:33 <happycoder> What does "indexed" mean in this context?
03:22:37 <phadej> jonathan_: the expression inside $(..) should be Q Exp
03:22:42 <phadej> LitE constructrs bare Exp
03:22:52 <phadej> so `pure` is to lift it into Q monad
03:23:09 <phadej> alternatively one could use `litE . stringL $ show 'foo`
03:23:20 <phadej> yet, I wonder why not just litE (stringL "foo")
03:23:40 <boxscape> or $(stringE $ show 'id) as Taneb mentioned
03:23:45 <Taneb> phadej: it's so you find out if the name changes so you can change your error message
03:23:50 <boxscape> s/'id/'foo
03:24:06 <phadej> Taneb: fair point
03:25:12 <jonathan_> I'll need to look into TH functions, would be nice to just rewrite it into $(nameof(foo))
03:25:19 <__monty__> There's no way to do `\x -> $(stringE (show 'x)`, returning the identifier you passed it rather than x?
03:25:58 <phadej> no
03:26:06 <Taneb> jonathan_: let nameof :: Name -> Q Exp; nameof = stringE . show
03:26:07 <phadej> you have write Name -> ExpQ function
03:26:15 <Taneb> Then you can do $(nameof 'foo)
03:26:43 <phadej> (fwiw, you probably want to extract the OccName part of Name to drop uniques/module, depends)
03:26:50 <jonathan_> Cool :)
03:26:58 <jonathan_> ty Taneb
03:27:34 <Taneb> Fun fact: this is the most template haskell code I've ever written
03:27:48 <phadej> % $(stringE $ case 'id of Name n _ -> show n)
03:27:48 <yahb> phadej: ; <interactive>:153:25: error:; * Not in scope: data constructor `Name'; * In the untyped splice: $(stringE $ case 'id of { Name n _ -> show n })
03:28:05 <phadej> % $(stringE $ case 'id of Language.Haskell.TH.Syntax.Name n _ -> show n)
03:28:05 <yahb> phadej: "OccName \"id\""
03:28:10 <phadej> % $(stringE $ case 'id of Language.Haskell.TH.Syntax.Name n _ -> pprint n)
03:28:10 <yahb> phadej: ; <interactive>:155:64: error:; * No instance for (Ppr Language.Haskell.TH.Syntax.OccName) arising from a use of `pprint'; * In the expression: pprint n; In a case alternative: Language.Haskell.TH.Syntax.Name n _ -> pprint n; In the second argument of `($)', namely `case 'id of { Language.Haskell.TH.Syntax.Name n _ -> pprint n }'
03:28:28 <phadej> % $(stringE $ case 'id of Language.Haskell.TH.Syntax.Name (Language.Haskell.TH.Syntax.OccName n) _ -> n)
03:28:28 <yahb> phadej: "id"
03:29:10 <phadej> vs. "GHC.Base.id"
03:48:32 <jonathan_> Taneb: test failed :/        expected: "varname"        but got: "varname_6989586621679088594"
03:48:46 <jonathan_> seems to be a bit trickier than expected
03:51:10 <jonathan_> replacing show with nameBase did the trick
04:22:24 * hackage HsWebots 0.1.1.1 - Webots bindings for Haskell  https://hackage.haskell.org/package/HsWebots-0.1.1.1 (junjihashimoto)
04:37:31 <fishooter> srk: I'm not sure how to make that work
04:37:36 <fishooter> I made a small example: https://repl.it/@sustrmic/ColdChartreuseWaterfall
04:37:45 <fishooter> how can I implement it for Y? :)
04:42:06 <subttle> hi all, I have a question regarding the `bool` function which is for case analysis of the `Bool` type. Does anybody know if there is a reason for the strange order of the arguments? Thanks
04:43:13 <srk> fishooter: parsedBy is just masked <$> from Control.Applicative
04:44:12 <__monty__> :t bool
04:44:14 <lambdabot> a -> a -> Bool -> a
04:44:15 <srk> fishooter: you can also use <|> from there for alternative (MyA <$> parserA) <|> (MyB <$> parserB)
04:44:41 <subttle> from the docs: Case analysis for the Bool type. bool x y p evaluates to x when p is False, and evaluates to y when p is True.
04:45:17 <subttle> oh I guess maybe because False < True
04:45:29 <srk> fishooter: to ignore arguments you can use const or pure .. (pure MyA <$> parserA)
04:45:35 <merijn> subttle: There's a reason yes, because it matches the "bool elimination rule"
04:45:59 <merijn> subttle: i.e. it follows the order of constructors used in the definition
04:46:59 <subttle> merijn: perfect, okay that's exactly what I wanted to know. I was trying to define case analysis function for `Ordering` type so I just wanted to make sure I used the same logic in the order of the arguments. Appreciate it!
04:47:05 <merijn> subttle: Which is consistent with "either :: (a -> c) -> (b -> c) -> Either a b -> c" (data Either a b = Left a | Right b) and "maybe :: b -> (a -> b) -> Maybe a -> b" (data Maybe a = Nothing | Just a)
04:53:10 <Cheery> My use-case isn't very exotic, but anybody knows whether there's a tree-sitter like incremental parsing library in Haskell?
04:54:07 <fishooter> srk: im not sure if I follow :/ I tried setting 
04:54:08 <fishooter> myTestParser = pure X
04:54:14 <fishooter> but I get match error
04:54:25 <fishooter>  Expected type: ParserSpec MyTest
04:54:31 <fishooter> Actual type: ParserSpec (String -> MyTest)
04:54:38 <[exa]> Cheery: there are haskell bindings to tree-sitter
04:55:41 <[exa]> Cheery: is there any advantage over using the normal monadic parsers?
04:58:09 <phadej> no need to codegen
04:58:17 <Cheery> [exa]: dunno. not even sure whether tree-sitter satisfies what I need.
04:58:38 <phadej> but then, tree-sitter is more declarative
04:59:02 <[exa]> Cheery: what's the desired usecase then? :]
04:59:05 <phadej> (and iirc able to parse incomplete/incorrect files)
04:59:24 <fishooter> src: omg, my mistake! it should've been 
04:59:26 <fishooter> pure Y 
04:59:30 <fishooter> now it works :)
05:01:46 <Cheery> [exa]: Building a rich-text editor on top of a plaintext editor, Text --> AST --> (Schema -> Layout) --> Picture
05:02:52 <Cheery> so you'd kind of do plaintext editing but it renders it like it was word document.
05:03:20 <subttle> =3
05:03:48 <subttle> sorry was meant to be "/3" :X
05:05:59 <[exa]> Cheery: with rich text it is usually much better to edit the high-level structure right away than to try guessing the size of affected edit neighborhoods and constantly update the output
05:06:30 <[exa]> you might like zipper pattern for doing that effectively in haskell
05:17:47 <fishooter> hi, I adjusted the parser for git client: https://repl.it/@sustrmic/haskell-git
05:18:05 <fishooter> is this "correct haskell" ? :)
05:22:59 <Cheery> [exa]: I want a system where you can edit it either way. Such tool needs to do error correction anyway.
05:23:19 <Cheery> when the intent is to stay backwards compatible with plaintext representation.
05:24:19 <Cheery> and incremental parsing seem to become relevant because that's the only way to do a proper IDE that isn't cheap and stupid.
05:24:47 <Cheery> well, incremental + error correction.. and I'm thinking tree-sitter probably isn't enough :)
05:25:41 <Cheery> but it's a start to that direction.
05:26:03 <[exa]> Cheery: well you need an _isomorphism_ between text and rich representation to stay "compatible", which is pretty easy in haskell, and does not put any requirements on the incrementality of parsing in fact
05:27:03 <Cheery> yup.
05:29:22 <[exa]> the other way is with one-way display function, which really requires you to be able to react to tiny changes in source. I have seen that done using a parser that returned exact text positions of the AST, which could be matched and checked to intermediate output of the parser
05:46:27 <srid-irccloud> Cale: Inspired by obelisk-route, I started using dependent-map to represent routes (in a statically generated site), but hit a roadblock, which led me to rewrite it using type families and data kinds. I wonder if I over complicated it, and if there is a simpler approach. Details: https://funprog.srid.ca/haskell/using-gadt-constructor-kinds-in-its-return-type.html
06:00:26 <boxscape> hm why do all my ideas end up requiring the singletons library at some point
06:01:04 <Taneb> Maybe you have something your subconscious wants to explore in that area, and because you haven't fulfilled it yet you keep coming back
06:01:12 <boxscape> possibly
06:01:52 <boxscape> I even implemented some singleton types in Java yesterday but turns out they didn't solve the problem with Java's type system I thought they might solve
06:02:48 <comerijn> fishooter: It looks reasonable at a glance
06:03:25 <boxscape> comerijn btw since we talked about one extension per line earlier, I think I actually kind of like this https://pastebin.com/ibytpqhp
06:03:40 <boxscape> Haskell2010 has special status as a Language extension so I don't mind it being on its own
06:03:45 <boxscape> unlikely to change in diffs
06:03:55 <boxscape> (though of course the only reason it's in there is because we can't have leading commas)
06:12:12 <boxscape> fishooter It's not necessarily better but in principle you could replace all of those newtypes with two types; `data ArgName = AnnotatedTag | Commit | DoWrite ...` and then `newtype Argument (a :: ArgName) = Argument String deriving (Show, RawRead)`
06:22:34 <fishooter> boxscape: do I understand it correctly that then I will need to write
06:22:52 <fishooter> 'Argument Commit' instead of 'Commit' everywhere?
06:24:47 <fishooter> or I'm not sure how to make this work
06:26:31 <boxscape> fishooter that's what you'd have to do, yes
06:27:02 <boxscape> again, not necessarily worth doing, just a potentially interesting option to avoid the repetetive newtype definitions
06:28:06 <fishooter> ok, makes sense, thanks
06:39:59 <fishooter> boxscape: could you have a look at ObjectType? https://repl.it/@sustrmic/haskell-git  I would like to make a custom parser for ArgParse
06:40:25 <fishooter> but rawParse is not a visible method of class RawRead
06:40:33 <fishooter> does this mean I can't make a custom parser? :/
06:43:52 <boxscape> fishooter Not sure if this is why you're getting that error message, but it looks like rawParse should get a String as argument, but by saying `rawParse (ObjectType s)`, you're saying that it should get an ObjectType
06:44:57 <boxscape> fishooter so instead of matching on (ObjectType s) and extracting s, you should match on the cases from the case expression directly
06:47:30 <fishooter> I updated https://repl.it/@sustrmic/haskell-git
06:47:48 <fishooter> boxscape: I still get  ‘rawParse’ is not a (visible) method of class ‘RawRead’
06:47:55 <fishooter> rawParse s = case s of
06:48:05 <fishooter> it has signature
06:48:08 <fishooter> class RawRead a where rawParse :: String -> Maybe (a, String)
06:50:20 <boxscape> fishooter hm, yeah, it looks like the module doesn't actually export the function rawParse... I imagine that means you're supposed to do it some other way, but I'm not really familiar with argparser
06:56:04 <fishooter> boxscape: hmm, so I guess I'll have to make my own parser?
06:56:31 <fishooter> by parser I mean ParserSpec
06:57:56 <boxscape> fishooter I imagine so, but I'm not sure
07:56:24 * hackage impure-containers 0.5.1 - Mutable containers in Haskell.  https://hackage.haskell.org/package/impure-containers-0.5.1 (andrewthad)
09:31:23 * hackage lumberjack 0.1.0.1 - Trek through your code forest and make logs  https://hackage.haskell.org/package/lumberjack-0.1.0.1 (KevinQuick)
09:40:54 * hackage keysafe 0.20200214 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20200214 (JoeyHess)
11:25:03 <d34df00d> Hi folks.
11:25:43 <d34df00d> What's the difference between `indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#` and `readInt8X16OffAddr# :: Addr# -> Int# -> State# s -> (#State# s, Int8X16##)` functions?
11:25:55 <d34df00d> I can see one lives in unboxed "state", while the other doesn't.
11:26:01 <d34df00d> But what implications does it have?
11:34:15 <d34df00d> I mean I understand that the state token can be used for sequencing the actions, but if I only read the array and nothing else modifies it concurrently, then what's the difference?
11:46:24 * hackage hs2ps 0.1.2.0 - Translate Haskell types to PureScript  https://hackage.haskell.org/package/hs2ps-0.1.2.0 (WilliamRusnack)
11:51:25 * hackage hs2ps 0.1.2.1 - Translate Haskell types to PureScript  https://hackage.haskell.org/package/hs2ps-0.1.2.1 (WilliamRusnack)
12:14:32 <d34df00d> Anyway, how do I compare two Word8X64# for (elementwise) equality?
12:14:38 <d34df00d> Can't find a primop for that.
12:17:38 <geekosaur> if it's a primitive in a machine word, it should be ==#
12:18:38 <geekosaur> hm, apparently not, given typechecking
12:18:40 <d34df00d> geekosaur: ==# is for Int#s isn't it?
12:18:44 <geekosaur> might need a coercion
12:18:47 <d34df00d> It's a SIMD register or something.
12:18:55 <d34df00d> I doubt it'll fit a Word# or Int#.
12:20:10 <d34df00d> And the point is to rely on, say, AVX2 instruction like vpcmpeqb if it's available (up to the codegen to select the right one).
12:20:30 <geekosaur> oh. try over in #ghc for SIMD stuff
12:20:47 <d34df00d> It said "for user questions ask #haskell" so I was scared.
12:20:49 <d34df00d> Will ask there.
12:21:45 <geekosaur> that's not really a user question as yet, it's all still in flux and all the experts are over there
12:25:09 <remexre> is there a GHC command to normalize a type?
12:25:20 <stepcut> `Either a b` is nice when you only have two choices -- 'a' and 'b'? But what about when you have 'n' choices? Perhaps there is something that uses type-level lists or sets? instead of Either3 you'd have EitherN '[Int, Char,Float] ?
12:25:29 <remexre> e.g. I've got a type Foo Bar, where Foo is a type family, and I want to see what it evaluates to
12:26:07 <d34df00d> remexre: :kind!
12:26:10 <d34df00d> Note the !
12:26:31 <remexre> oh, nice
12:26:37 <remexre> was about to say, :kind doesn't do that lol
12:42:19 <remexre> is there a way to curry type families?
12:42:25 <remexre> specifically, with Data.SOP.NP
12:51:24 <remexre> ah, a newtype around the type family does it
12:51:53 * hackage hs2ps 0.1.3.0 - Translate Haskell types to PureScript  https://hackage.haskell.org/package/hs2ps-0.1.3.0 (WilliamRusnack)
13:22:23 * hackage hs2ps 0.1.4.0 - Translate Haskell types to PureScript  https://hackage.haskell.org/package/hs2ps-0.1.4.0 (WilliamRusnack)
13:49:53 * hackage laop 0.1.0.5 -   https://hackage.haskell.org/package/laop-0.1.0.5 (bolt12)
14:05:46 <jle`> remexre: you can also curry them with type families
14:05:58 <jle`> and also with type synonyms as well
14:06:10 <jle`> type CurriedEither ab = Either (Fst ab) (Snd ab)
14:06:11 <remexre> I had a type family and got an error that it wanted 3 args but was provided 2
14:06:17 <jle`> oh, you meant partial application
14:06:23 <remexre> yeah
14:06:28 <jle`> er i guess i also was describing uncurry
14:06:46 <jle`> but you can curry with type synonyms as well, type CurriedFoo a b = Foo '(a,b)
14:30:10 <cole-k> can someone give me advice on installing ghcjs or point me to a guide?
14:31:11 <cole-k> are there any other ways to get a haskell program i've written on a webpage? (i know little about this sort of stuff)
14:31:52 <dminuoso> cole-k: Kind of depends on what your endgoal is.
14:32:01 <koz_> Yeah, what do you mean by a 'Haskell program' in this case?
14:33:57 <cole-k> i've written a documentation searcher similar to hoogle for another language and i would like to port it to a webapp - i was hoping to just get it running on js
14:34:56 <cole-k> i realize there might be better alternatives, but i was hoping to not have to write too much extra code 
14:35:31 <koz_> So basically, it's a web page with a search bar, which can output some search results?
14:35:41 <koz_> You can probably build something on top of servant which runs as a web app?
14:36:10 <dminuoso> cole-k: https://github.com/ghcjs/ghcjs contains a README.markdown that contains setup instructions.
14:37:21 <zeta_0> does anyone here have some experience with ghc development? where is the DynFlags module located? i need to get in there to move some -d* flags around
14:38:09 <zeta_0> i just started developing on ghc about a month ago, so i'm still trying to figure out where certain things are at
14:39:25 <zeta_0> nevermind i found the corresponding file that i need
14:40:05 <koz_> zeta_0: That's how it always goes with me - I ask a question, then ten seconds later, I realize what the answer is. :P
14:40:12 <koz_> #haskell-rubber-duckie
14:40:49 <cole-k> dminuoso: i saw that the readme is like a year old, so i did some looking around. a stack github issue on discontined support for ghcjs seemed to imply people were using nix to set up ghcjs.
14:41:15 <zeta_0> koz_: same here, lol
14:41:25 <cole-k> i've seen some people with difficulty setting it up in the past, so i was curious whether there were newer techniques
14:41:53 <cole-k> koz_: thanks for the suggestion, i'll look into servant - i will admit to not knowing the slightest about web development, especially in haskell...
14:41:58 <dminuoso> cole-k: Based on everything I have seen so far, I'd be more inclined to just use PureScript instead of ghcjs.
14:42:20 <zeta_0> am i going to have to use ghcjs for Yesod development? i am about 5 chapters into the Yesod book and haven't had to use it
14:42:47 <dminuoso> cole-k: It's, for the most part, a cleaner implementation. Until Asterius becomes more stable, I think PureScript is the cleaner approach.
14:44:02 <cole-k> dminuoso: have you had any experience porting haskell code to purescript? i was hoping to not have to change too much of the code i've already written.
14:44:31 <zeta_0> dminuoso: so what is the progress of webassembly integration with haskell? is there still a lot of work that needs to get done?
14:45:04 <dminuoso> zeta_0: The state web assembly is in currently makes it pretty hard to near impossible to implement garbage collectors.
14:45:10 <dminuoso> That's what I heard anyway.
14:46:39 <zeta_0> dminuoso: oh i see, so i guess for the short term i am going to stick with Yesod, and just deal with javascript for now
15:12:49 <spew> I'm trying to write some code using prettyprinter and in the documentation I see examples like "vsep ["hello", parens emptyDoc, "world"]"
15:13:22 <spew> but when I write something similar, the compiler is complaining that the strings are not Doc ann types
15:13:50 <spew> so is there some extension I am missing that automatically promotes those types to be a (for example) Doc [Char]
15:13:52 <[e^x]> hi
15:14:28 <dminuoso> spew: You misunderstood the error message. You need to enable OverloadedStrings.
15:14:36 <[e^x]> i want to check if a number is square. for some b, i guess i could take a list [1..b] , square each element and check if its equal to b
15:14:47 <[e^x]> i know going up to b is silly but just a rought idea
15:14:52 <[e^x]> right?
15:15:10 <dsal> Try it?
15:16:09 <dminuoso> spew: The annotation type is not about the string type, it's rather about being able to attach completely arbitrary information to documents.
15:16:10 <dminuoso> For example, if you define `data Color = Red | Green | Blue`, then `Doc Color` lets you annotate documents with colors.
15:16:12 <spew> dminuoso: thanks, though that only works for literal strings
15:16:27 <spew> so I still have to wrap variables with "pretty"
15:16:33 <spew> right?
15:16:44 <dminuoso> spew: Yes.
15:16:52 <dminuoso> spew: Indeed, you cant get around that.
15:17:00 <spew> okay thanks very much!
15:17:14 <Tuplanolla> There's a better way that's not any more complicated, [e^x].
15:17:41 <[e^x]> idk how, i am in ghci. g x = 
15:17:45 <[e^x]> hmm e^x?
15:17:52 <[e^x]> oh thats my name, haha
15:18:04 <[e^x]> i thought it was e^x in a list, sorry
15:18:13 <spew> is there a way to make an alias for pretty (like "p" for example) so that hindley-milner doesn't infer its type for all occurrences?
15:18:31 <dsal> [e^x]: is your question "how do I write code to do this?"
15:18:59 <spew> after I apply p to the first string, it won't apply p to an Int
15:20:30 <Tuplanolla> You can calculate the integer square root and square it. Now the only remaining question is the square root.
15:21:29 <dsal> If you have something you believe works, then you have something to compare against when you optimize.  :)
15:21:41 <zeta_0> i am currently contributing to ghc, and have it working with ghcide, but when i open a file, ghcide throws an error: no such file or directory, is this normal? those ghc files are massive(thousands of lines of code)'
15:21:41 <[e^x]> dsal, well, i have this so far, square x = x^2 and g x = map (square) [1..x]
15:22:05 <[e^x]> but i want the function g check if the value = x and tell me it :s
15:22:07 <[e^x]> if that makes sense
15:22:21 <dsal> isSquare :: Int -> Bool
15:22:43 <[e^x]> hmm you mean i should do this in a file and not ghci? :S
15:23:07 <dsal> Doing it in ghci is fine.  I'd probably do it in lambdabot since I don't have a ghci handy.
15:23:16 <dsal> > map (^2) [1..11]
15:23:18 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121]
15:23:31 <[e^x]> oh you can map it like that?
15:23:36 <dsal> But that's an example signature of what your type might be.
15:23:39 <dsal> :t (^2)
15:23:39 <[e^x]> i wrote a squaring function for no reason :s
15:23:40 <lambdabot> Num a => a -> a
15:23:49 <Tuplanolla> You can find the square root by iteratively solving the equation `y ^ 2 - x = 0`. Now you just need to implement Newton--Raphson iteration.
15:24:58 <spew> I figured it out
15:26:02 <dsal> [e^x]: perhaps `elem` will help you.
15:27:32 <dsal> You could also harness the power of `find` to simultaneously tell you whether it finds one *and* tell you what it is.
15:27:47 <dsal> (I'm not suggesting this is optimal, just walking you through the path of doing the thing you set out to do)
15:28:01 <[e^x]> hmm right
15:28:24 <Cale> For numbers of some sizes, it might be a good idea to test if you can find a Jacobi symbol (n/a) is -1 for some values of a coprime to n, at which point you immediately know the number is not square
15:28:39 <[e^x]> so |map (^2) [1..x] returns a list i suppose
15:29:11 <dsal> :t map (^2) [1..10]
15:29:12 <lambdabot> (Num b, Enum b) => [b]
15:29:15 <[e^x]> https://imgur.com/a/AmIx8qw
15:29:32 <Cale> (that's once your numbers get very large though)
15:29:35 <[e^x]> its a very simple factorization which i could do by hand. but using it as an excuse to learn a bit more programming :s
15:29:52 <dsal> Yeah, you're probably very close to learning something.  :)
15:31:19 <dminuoso> spew: Part of the original problem is that prettyprinter does not use a text representation. Instead documents are represented using an algebra of sorts, and pretty is the typeclass driven method of converting arbitrary things into such documents.
15:32:02 <[e^x]> does this sentence make any sense? 
15:32:04 <[e^x]> |my_element x (map (^2) [1..x]) == x = True
15:32:18 <dminuoso> spew: OverloadedStrings addresses part of it, by causing string literals to have the type `IsString p => p`, and there happens to be an `instance IsString (Doc ann)`
15:32:23 <[e^x]> hmm it doesnt'
15:32:58 <dminuoso> spew: Which is why you can flip that extension on, and write string literals in any place where some `Doc ann` is expected. But OverloadedStrings has a slightly misleading name, in that it overloads string *literals*, not all strings.
15:33:34 <dsal> [e^x]: You can break your problem into the things you know and the thing you don't.  You know your number.  You know the list of squares leading up to your number.  The thing you don't know is whether your number is in that list.  So all you have to do is ask if your number's in the list.
15:33:57 <[e^x]> right
15:34:02 <dsal> (again, this is a useful exercise for how to solve a problem at all.  not the right way to solve the problem for production)
15:34:05 <dsal> :t elem
15:34:06 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
15:34:31 <dsal> > '^' `elem` "[e^x]"
15:34:33 <lambdabot>  True
15:34:49 <[e^x]> ah i see
15:34:50 <spew> dminuoso: yeah, makes sense
15:35:14 <spew> maybe I'll switch to text-show instead, since I don't really need the extra formatting
15:35:22 <spew> I just want a nice way to get Text from a type
15:35:30 <spew> nice/composable
15:35:38 <Cale> [e^x]: you could also probably cut the list off once the square is larger than n at least
15:35:39 <[e^x]> |x `elem` (map (^) [1..x])
15:35:53 <dminuoso> spew: prettyprinter is nice in that you have pretty good formattring control with very nice performance, but if you just care about creating text things, it's probably the wrong pick.
15:35:56 <[e^x]> Cale, right. i figured i'd optimize it once it worked at all
15:36:02 <spew> yeah, seems like it
15:36:03 <Cale> x `elem` (takeWhile (<= n) (map (^2) [1..]))
15:36:11 <Cale> oops
15:36:21 <Cale> I used both x and n there, but you get the idea
15:36:24 <[e^x]> hmm how do i add an otherwise case those?
15:36:28 <[e^x]> |otherwise = False ?
15:36:31 <dsal> otherwise?
15:36:32 <Cale> hm?
15:36:45 <[e^x]> when i use guards i need otherwise i thought :s
15:36:47 <dsal> You've only described the need for one case.
15:36:53 * hackage ats-pkg 3.5.0.0 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.5.0.0 (vmchale)
15:36:56 <dsal> Why do you need a guard?
15:37:19 <[e^x]> thats the first think i remembered :D
15:37:24 <[e^x]> let me get rid of guard
15:37:26 <Cale> > let isSquare x = x `elem` takeWhile (<= x) (map (^2) [1..]) in isSquare 5734892507489057348905
15:37:32 <lambdabot>  mueval-core: Time limit exceeded
15:37:37 <Cale> slow :P
15:37:41 <dminuoso> spew: By the way, depending on the show instance, a plain `T.pack . show` is surprisingly efficient. As long as its not deriving generated show instances for non-trivial records.. :)
15:37:48 <Cale> Better to do a binary search of course
15:37:53 <dsal> Cale: What's wrong with O(n) square root?
15:37:59 <dsal> bin search a linked list?  :)
15:37:59 <dminuoso> spew: Say, converting Int to Text is quite efficient that way.
15:38:14 <Cale> dsal: Binary search the natural numbers
15:38:27 <dsal> Yeah.  The `find` mechanism allows for that.  But without the `find` part.
15:38:50 <dsal> Er, I guess I mean thinking about the problem that way leads you down that path.
15:39:34 <Cale> You can keep doubling a number until its square is larger than n, and then you know the square root is between k/2 and k
15:39:40 <Cale> and you can binary search from there
15:39:44 <spew> what I really need is the composability
15:39:59 <[e^x]> oh ohh
15:40:03 <dminuoso> spew: Composability in what sense?
15:40:45 <Cale> It's also possible to use Newton's method, but with integers, and quickly find your way down to a point where the last two iterations are within, say, 5 of one another
15:40:58 <Cale> and then just check everything to see if there's a square root
15:41:07 <Tuplanolla> Here's the slightly less silly way I suggested.
15:41:18 <Cale> It's possible to end up in a 2-cycle though, so be careful with that :)
15:41:30 <Cale> (it's not sufficient to wait for convergence)
15:41:38 <spew> dminuoso: i'm just tired and learning
15:41:39 <dsal> "this works" is a great starting point.  :)
15:41:49 <Tuplanolla> @let isSquare number = let isBest guess = guess ^ 2 <= number && number < (1 + guess) ^ 2 in let improve guess = (guess + number `div` guess) `div` 2 in let integerSqrt guess = if isBest guess then guess else integerSqrt (improve guess) in integerSqrt number ^ 2 == number
15:41:51 <lambdabot>  Defined.
15:41:51 <spew> I just need any typeclass I guess
15:42:24 <spew> like how I define a Pretty instance for a type and then that's used to define Pretty instances for types that compose that type
15:42:25 <spew> that's all
15:42:29 <Tuplanolla> > fmap (fromEnum . isSquare) [0 .. 16]
15:42:32 <lambdabot>  [1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1]
15:42:34 <dminuoso> When you think a typeclas is what you need, it likely is not.
15:42:45 <[e^x]> okay my code ran but it kept running
15:42:56 <[e^x]> maybe squaring to n is too many stuff?
15:43:08 <[e^x]> isSquare :: Int -> Bool
15:43:08 <[e^x]> isSquare x = x `elem` (map (^2) [1..x])
15:43:14 <spew> dminuoso: so how do I compose this kind of thing?
15:43:21 <spew> show composes
15:43:21 <[e^x]> is the code. and i tried (53357^2+1^2)
15:43:24 <spew> does this make sense?
15:43:51 <spew> like once you have show for each type of a type expression, then it's trivial to define a show for the whole type expression
15:43:54 <[e^x]> is this supposed to take minutes to compute? :s
15:44:02 <spew> that's a typeclass
15:44:07 <spew> how else would you do it in Haskell?
15:44:21 <Tuplanolla> > isSquare (53357 ^ 2 + 1)
15:44:22 <spew> I'm mostly an OCaml person trying to get up to speed with Haskell
15:44:23 <lambdabot>  False
15:44:40 <[e^x]> hmm which isSquare is that?
15:44:49 <Tuplanolla> The one I just explained and defined.
15:45:03 <dsal> @check \x -> isSquare (x*x)
15:45:06 <lambdabot>  +++ OK, passed 100 tests.
15:45:14 <[e^x]> ah
15:45:22 <[e^x]> i checked my code for smaller numbers and it works :s
15:45:45 <dsal> [e^x]: Yeah, so once you have something you know works, you can build something better and you have something to compare it against.  :)
15:45:46 <Tuplanolla> Such is time complexity.
15:46:11 <spew> dminuoso: "When you think a typeclas is what you need, it likely is not." could you by any chance explain what you meant by that?
15:46:20 <spew> I'm genuinely curious
15:46:34 <[e^x]> i dont think i've ever coded anything in my life that didn't immidately gave me an answer
15:46:42 * [e^x] wonders if he needs supercomputer or better code
15:47:21 <MarcelineVQ> why wonder, Tuplanolla just showed that one of those choices is the correct one
15:47:23 <[e^x]> okay maybe i'll let it run for 5 mins or something..
15:47:37 <[e^x]> let me try to understand his code while mine runs, then
15:48:50 <[e^x]> :s did he defined isBest inside isSquare or isBest something that already exists?
15:50:34 <Tuplanolla> Almost everything you need is defined right there.
15:50:50 <Tuplanolla> The only exception is integer arithmetic.
15:50:56 <dsal> It'd be pretty cool if Prelude had `isBest` defined.  isBest :: a -> Bool.  You just give it something and it tells you if it's the best.
15:51:03 <[e^x]> I didn't know you could define something inside something else like that
15:51:14 <Tuplanolla> We have a package for that, dsal.
15:51:17 <Tuplanolla> @hackage numberwang
15:51:17 <lambdabot> http://hackage.haskell.org/package/numberwang
15:51:23 <dsal> haha
15:51:39 <Tuplanolla> My bad.
15:51:42 <Tuplanolla> @hackage acme-colosson
15:51:42 <lambdabot> http://hackage.haskell.org/package/acme-colosson
15:52:44 <dsal> That's pretty great.  I checked the source just to make sure it had unsafePerformIO, but there were other joys within.
15:53:47 <[e^x]> hmm, i think my issue is that it's generating the entire square list ?
15:53:58 <dsal> No, it's not that.  Haskell is lazy.
15:53:59 <[e^x]> or does it generate a square , check etc?
15:54:04 <dsal> It's that you're *checking* the entire list.
15:54:08 <[e^x]> oh haskell is lazy without me doing anything?
15:54:18 <[e^x]> ah very nice
15:54:23 <dsal> Everything is lazy without you doing anything.
15:54:31 <[e^x]> going all the way up x was a bad idea
15:54:39 <dsal> But you could define the list as     map (^2) [1..]
15:54:43 <[e^x]> but using some inbuild sqrt function sounded weird
15:54:48 <dsal> As long as you don't try to check every value in it.
15:55:07 <[e^x]> heh, if its not a square, it never terminates
15:55:16 <dsal> If you're using elem, yeah.
15:55:22 <[e^x]> its still chugging along
15:55:26 <[e^x]> :<
15:55:33 <dsal> But if you're using elemUnlessIWentTooFarAndIKnowItCannotPossiblyBe then you're good.
15:55:47 <dsal> It's still O(n), but it's no longer O(∞)
15:56:01 <dsal> (also, you're in ghci, which is going to be slower)
15:56:01 <Tuplanolla> Infinite improvement!
15:56:12 <[e^x]> we covered O but it went over my head a bit
15:56:23 <[e^x]> is there O(oo) ?
15:56:34 <dsal> O(∞) is also called "bottom"
15:56:40 <[e^x]> ah
15:57:20 <dsal> If your algorithm requires infinite space or infinite time, it could probably benefit from some optimization.
15:57:40 <[e^x]> its finite i'm sure. just a large finite it seems
15:57:51 <ChaiTRex> takeWhile (<= n)
15:57:58 <[e^x]> so to check if x is a square, i have to go from 1 to ?
15:58:15 <dsal> Well, you don't have to go past x where x*x > n
15:58:20 <[e^x]> if its square root of N, i could just check if square root of x exists no?
15:58:21 * dsal confuses ns and xs
15:58:26 <[e^x]> oh!
15:58:49 <dsal> Which is why Cale and ChaiTRex recommended takeWhile
15:59:01 <[e^x]> ah
15:59:04 * [e^x] googles takeWhile
15:59:09 <dsal> :t takeWhile
15:59:11 <lambdabot> (a -> Bool) -> [a] -> [a]
15:59:43 <dsal> > takeWhile (\x -> x * x <= 9) [1..]
15:59:45 <lambdabot>  [1,2,3]
15:59:49 <dminuoso> spew: By writing functions.
16:00:01 <[e^x]> takeWhile (<x(x)) (map (^2) [1..x])
16:00:02 <[e^x]> ?
16:00:13 <dsal> I'm not sure what you were going for there.
16:00:18 <[e^x]> oops
16:00:27 <[e^x]> takeWhile (<x*x) (map (^2) [1..x])
16:00:28 <dsal> But if you're going to use takeWhile, you can just do [1..]
16:00:43 <[e^x]> takeWhile (<x*x) (map (^2) [1..])
16:00:45 <dsal> That's the wrong direction.
16:00:55 <dsal> (it's syntactically incorrect, but that's less interesting)
16:01:05 <dminuoso> spew: You can encode most things more cleanly and simpler with just ADTs or HOFs.
16:01:05 <dsal> So instead of terminating around the square root, you're terminating around the square.
16:01:18 <[e^x]> ah
16:01:30 <[e^x]> takeWhile (<x) (map (^2) [1..])
16:01:41 <dsal> That's the same as what you head with [1..x]
16:01:59 <[e^x]> yikes, ok let me think
16:02:11 <dsal> If you give up, you can also scroll up.  :)
16:03:56 <[e^x]> hmm but i have to figure out what your un sugared stuff means
16:03:59 <[e^x]> :s
16:04:08 <dsal> Sugar?
16:04:20 <dsal> The first argument to takeWhile is  (a -> Bool)
16:04:30 <dsal> So it takes a function that decides whether we should keep going or not.
16:04:55 <dminuoso> spew: With Pretty for instance, I'm fine with the typeclass existing for all the standard things like String, Text, Int, Integer, Natural, Char, and so forth - but the second you get into custom bits, just write `pprFoo` functions
16:04:58 <dsal> I just gave it a lambda.  You could name a function, but it'd be a little more awkward.
16:05:52 <[e^x]> hmm
16:07:49 <ChaiTRex> > mapf
16:07:52 <lambdabot>  error:
16:07:52 <lambdabot>      • Variable not in scope: mapf
16:07:52 <lambdabot>      • Perhaps you meant one of these:
16:07:58 <dsal> > let isNotGreaterThanSquareRootOf x y = x * x <= y in   takeWhile (`isNotGreaterThanSquareRootOf` 9) [1..]
16:08:00 <lambdabot>  [1,2,3]
16:08:14 <ChaiTRex> > map floorSqrt [0 .. 25]
16:08:17 <[e^x]> takeWhile (map from x to x^2 <= 9) ?
16:08:17 <lambdabot>  [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5]
16:08:22 <[e^x]> isn't that what it says?
16:08:23 * hackage persistent 2.10.5.2 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.5.2 (parsonsmatt)
16:09:06 <dsal> [e^x]: It's not mapping anything.  It's just saying, "yes, keep going" or "no, our condition is no longer true"
16:10:07 <dsal> :t floorSqrt
16:10:08 <lambdabot> Integral a => a -> a
16:10:12 <[e^x]> takeWhile (\x -> x * x <= N) [1..] ah its going till the square is \leq N i see
16:10:15 <dsal> Oh that's neat.  It's also ~the answer.
16:10:51 <[e^x]> i jsut take floorSqrt of N ?
16:11:03 <[e^x]> and square it and check if its equal to N?
16:11:04 <[e^x]> lol
16:11:22 <[e^x]> so the thing inside () is a lambda function?
16:11:23 * hackage persistent-sqlite 2.10.6.2 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.10.6.2 (parsonsmatt)
16:12:03 <dsal> The thing that starts with \ is a lambda function.
16:12:13 <[e^x]> ah
16:12:14 <Tuplanolla> That's what my suggestion did, [e^x].
16:12:14 <dsal> You parenthesize a bit more than I do. :)
16:12:37 <[e^x]> i was runnign into errors with not using enough previously
16:12:44 <Tuplanolla> The trick is in noticing that integer square roots are much easier to find than real ones.
16:13:18 <dsal> Where did this floorSqrt come from?
16:13:56 <Tuplanolla> Someone rolled their own or imported a number theory package.
16:14:49 <dsal> You can get close with    floor . sqrt . fromIntegral  I guess.
16:15:14 <[e^x]> so this takeWhile with lambda function shit signigicantly changed things
16:15:20 <[e^x]> like the result in instantanious
16:15:24 <dsal> It reduces the search space quite a bit.
16:15:29 * [e^x] doesn't fully grasps all this
16:15:39 <[e^x]> so my code was going way past N
16:15:45 <[e^x]> and kept squaring hmm
16:15:48 <dsal> It does nothing but reduce the search space.  Still O(n), just smaller n.
16:16:24 <dsal> O(sqrt(n)) I guess.
16:16:56 <[e^x]> oops i think my code isn't working :D
16:17:03 <[e^x]> testing 16 and says not square
16:17:54 <dsal> I think it should say yes.
16:17:57 <[e^x]> isSquare n = n `elem` takeWhile (\x ->x*x <= n) [1..]
16:18:00 <[e^x]> I think so too!
16:18:33 <dsal> > let isSquare n = n `elem` takeWhile (\x ->x*x <= n) [1..] in   zip [1..] (isSquare [1..])
16:18:35 <lambdabot>  error:
16:18:35 <lambdabot>      • Couldn't match expected type ‘[b]’ with actual type ‘Bool’
16:18:35 <lambdabot>      • In the second argument of ‘zip’, namely ‘(isSquare [1 .. ])’
16:18:57 <dsal> > let isSquare n = n `elem` takeWhile (\x ->x*x <= n) [1..] in   zip [1..] (map isSquare [1..])
16:18:59 <lambdabot>  [(1,True),(2,False),(3,False),(4,False),(5,False),(6,False),(7,False),(8,Fal...
16:19:23 <Tuplanolla> Using floating-point numbers works well with small numbers, but if you change the base to `3`, for example, they break almost immediately, dsal.
16:20:04 <dsal> [e^x]: you're checking to see if a number is in a list of numbers smaller than its square root.
16:20:06 <Tuplanolla> > (^ 3) . floor . cbrt $ 64
16:20:09 <lambdabot>  27
16:20:24 <[e^x]> i also realized i was testing a larger number with my oroginal code then i needed :D
16:20:24 <dsal> Math is hard.
16:20:28 <[e^x]> oh am i?
16:20:47 <[e^x]> less then or equal n right?
16:21:13 <dsal> You're filtering OK, but then you're not asking the question you mean to ask.
16:21:55 <[e^x]> ah
16:22:10 <[e^x]> so i can't ask if n is an element
16:22:24 <[e^x]> i need to ask if x such that x^2 = n is an element of that list
16:22:25 <[e^x]> hmm
16:22:35 <dsal> Or you can do what you were doing in the first place.
16:23:58 <[e^x]> hmmm
16:25:50 <[e^x]> so i had isSquare x = x `elem` (map (^2) [1..x]) but i want to takeWhile while that fancy lamda funcction thing is true
16:26:24 <dsal> What are you taking?
16:26:47 <[e^x]> well idk
16:27:58 <[e^x]> what did you mean by i can do what i was doing in the first place? :S
16:28:16 <dsal> You're not changing your algorithm, just reducing your search space.
16:29:35 <[e^x]> hmmmmmmmmmmmm
16:30:18 <dsal> What was your original search space?
16:30:59 <[e^x]> 1 to N
16:31:30 <dsal> How do you spell that in haskell?
16:32:03 <[e^x]> [1..N]
16:32:12 <dsal> (N would suggest a type)
16:32:19 <dsal> What is your new search space?
16:33:06 <[e^x]> 1 to x such that x^2 <= N
16:33:20 <dsal> Heh.  In haskell.  It's easier to read than English.  :)
16:33:29 <[e^x]> hmm
16:33:38 <[e^x]> [1..x] :s
16:35:07 <dsal> That's not very close.  :)
16:35:39 <dsal> You knew it a minute ago.
16:38:48 <[e^x]> i want to takeWhile codition but not from [1..] rather (map (^2) [1..]) ?
16:39:33 <dsal> ...but that's not your goal.
16:40:20 <dsal> That's kind of the opposite of your goal.  :)
16:40:46 <dsal> I think you are trying to skip a step and getting confused.  Try it without skipping a step.  :)
16:41:24 <[e^x]> what about i want to check if x is `elem` in (map(^2) list i get from takeWhile) ?
16:41:32 <dsal> That sounds right.
16:41:37 <[e^x]> hmm
16:41:39 <cjay-> is haskell.org down?
16:41:48 <dsal> cjay-: wfm
16:42:05 <cjay-> hmm 
16:43:19 <cjay-> of cause just as I do the traceroute I can reach it again
16:43:25 <dsal> you're welcome
16:43:53 <[e^x]> :O this seems to work :
16:43:54 <[e^x]> isSquare n = n `elem` (map (^2) (takeWhile (\x ->x*x <= n) [1..]))
16:44:12 <dsal> Looks right.  A bit lispy.  :)
16:45:01 <dsal> Alternatively, you could just produce a list of perfect squares immediately.
16:45:20 <dsal> > [x^2 | x <- [1..]]
16:45:22 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
16:45:31 <[e^x]> :O 
16:45:34 <ChaiTRex> [e^x]: Check if it works with filter isSquare [1 .. 100]
16:46:09 <[e^x]> ah ha, filter is cool
16:46:14 <[e^x]> i forgot about it
16:47:44 <ChaiTRex> [e^x]: one problem is isSquare 0
16:48:07 <dsal> > [x^2 | x <- [0..]]
16:48:10 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
16:48:26 <[e^x]> says 0 is not a square
16:48:32 <[e^x]> but i can live with that :s
16:57:33 <sm> any #haskell ops around ? The matrix bridge has been offline for a few days. If you'd like to re-enable it, thekyriarchy / thekyriarchy[m] can help
16:57:47 <sm> @where ops
16:57:49 <sm> @ops
16:59:19 <sm> @where lambdabot
17:00:34 <sm> lambdabot, dost sleep ? awake! to thy duty
17:02:52 <sm> @where ops
17:02:57 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
17:03:26 <glguy> sm: The matrix bridge is some network-wide thing. #haskell doesn't control it
17:03:49 <sm> I think the one for #haskell is different
17:04:22 <sm> thekyriarchy says "An irc mod will have to grab ops so we can re-request the bridge from them"
17:05:02 --- mode: ChanServ set +o glguy
17:05:17 * glguy begrudingly reapproves
17:07:55 <ChaiTRex> [_]: it's pretty easy to correct.
17:08:52 <ChaiTRex> [_]: you have the square roots of perfect squares on the right. just add the square root of zero to that.
17:09:27 <sm> there are pros and cons to bridging Haskell matrix room and #haskell IRC channel.. I'm not sure which I prefer, but I'd guess bridging them is probably best for the ecosystem long term
17:18:51 <glguy> sm: Even without the bridging you can connect yourself from matrix to #haskell on freenode iirc
17:19:02 <glguy> You just have to tell the appservice to connect you
17:19:49 <sm> glguy: that's interesting, I didn't know that
17:19:57 <glguy> trying on my own again
17:21:00 <glguy[m]> Hello, sm.
17:21:07 <glguy[m]> I'm on riot.im
17:21:35 <glguy> I had to tell "@appservice-irc:matrix.org" the command "!join chat.freenode.net #haskell"
17:23:39 <republican_devil> hey anyone using happstack.com? looks cool
17:24:23 <sm> glguy: ok.. what will be done about always-on general bridging ? 
17:24:56 <sm> was it ever decided, or more of an experiment ? 
17:27:23 <glguy> we agreed to do it at some point; I don't know why it stopped. I should poke the other ops and see what's up
17:28:03 <sm> ok, cool. I use riot as my main irc client, so of course it's handy for me. Either way it would be nice to get the status clarified
17:28:41 <sm> things were restarted, rooms were upgraded etc. on the matrix side which probably threw it off
17:29:19 <glguy> In the meantime let me know if you have trouble reconnecting like I said above and I'll try and reproduce any trouble you're having
17:29:25 <sm> (correction, forget the "handy for me" bit since you gave me a workaround - thanks)
17:29:34 <glguy> Given that sm[m] is still in the channel I don't quite understand the current situation
17:30:18 <sm> that is some kind of zombie. In my matrix client, IRC messages are not bridged, and vice versa, for the last few days
17:30:51 <sm> thekyriarchy: any idea ? In fact riot is a bit confused, there are hints of an old and new version of the room
17:31:38 <sm> thekyriarchy and maybe you can confirm if you are seeing these IRC messages, I have no idea
17:38:15 <sm> glguy: going to wait for a while before resorting to the personal bridging setup, so that I can monitor the general bridging situation. Probably this is not the best time of day. Thanks for the help so far
17:44:18 <sm[m]> well, I take that back.. I'd better try it to figure out what it does
17:44:59 <sm[m]> works great. It seems equivalent to the easier "/join #freenode_#haskell:matrix.org" in any matrix room (maybe Riot specific)
17:45:43 <glguy> Oh, that does sound easier
17:46:41 <glguy> I do think it's useful to have people know they are connecting to an IRC channel specifically and that it's not just a normal matrix channel
17:47:28 <glguy> It helps to know that things work work the same way: message editing spams, long messages turn into paste bin links, etc
17:48:18 <sm[m]> glguy: yes that is a plus
17:53:13 <sm[m]> meanwhile the Haskell room's description still says it's bridged to #haskell. If the situation persists, that should be updated. I wonder who can.
18:00:41 <sm> I asked @thekyriarchy to update the description, and to chat you directly glguy before retrying the reactivation. Afk a bit, good night o/
18:02:10 <remexre> tips for quickchecking a non-parametric function? (uses Generic to do some funny business)
18:03:37 <remexre> like I almost feel like I want quickcheck to generate a type as part of the test, but I don't think that's possible without extreme funny business
18:03:58 <dminuoso> remexre: What do you mean by "non-parametric function", exactly?
18:04:32 <remexre> it doesn't have theorems-for-free properties
18:04:43 <dminuoso> remexre: So?
18:05:03 <remexre> so I don't feel... comfortable? testing it on just a couple, fairly reasonable types
18:05:45 <remexre> Like if it works on (Bool, Bool) and Either Bool Bool, that doesn't really assume me that it'll work on some complicated user type
18:05:59 <dminuoso> remexre: Well Im not sure what you are looking for. Without free theorems, you either have a finite domain, or you have to just accept "reasonable examples
18:06:09 <dminuoso> But that's not really related to quickcheck, is it?
18:06:50 <remexre> was wondering if there was some quickcheck feature for quickchecking a function from types
18:08:35 <dminuoso> remexre: Well you can test anything that is a Testable
18:10:15 <dminuoso> remexre: With Property based tests, you can explore things like forAll/(==>) to describe certain things you expect to hold
18:10:32 <remexre> but I can't make a Gen *
18:10:33 <dminuoso> But still, that seems to be just quickcheck in general. 
18:10:42 <remexre> that I know of
18:11:05 <dminuoso> remexre: Why not?
18:11:21 <remexre> isn't that some sorta kind violation?
18:11:29 <dminuoso> can you give a concrete example?
18:11:32 <dminuoso> This is way too handwavy
18:12:37 <remexre> as an example of something not entirely dissimilar, imagine I wrote a declaration typeName :: Generic a => Proxy a -> String
18:12:58 <remexre> and I wanted to ensure the property "for all (a :: *), typeName (Proxy @a) has balanced parens"
18:13:36 <dminuoso> remexre: Generics work in both directions.
18:13:53 <dminuoso> Though.. I suppose this is getting hairy now.
18:14:21 <republican_devil> does haskell have any multi no databse kind of solution? could happstacks acidstate be multi node?
18:14:44 <republican_devil> like say scylladb.com?    I saw that timescaledb.com is a psotgresql multi node loosk itneresting
18:14:58 <dminuoso> remexre: But I see what you mean now.
18:16:23 <dminuoso> remexre: https://hackage.haskell.org/package/generic-arbitrary-0.1.0/docs/src/Test-QuickCheck-Arbitrary-Generic.html#genericArbitrary
18:16:25 <dminuoso> Deep black magic.
18:16:39 <dminuoso> Jokes aside, it seems fairly possible
18:17:40 <remexre> I see how that'd let me write a Generic a => Proxy a -> Property, but I don't see how to do the forall (a :: *)
18:18:01 <dminuoso> remexre: Ah heh, well though I dont think you can do this in the general way
18:18:37 <dminuoso> remexre: This might be the point where unpacking TemplateHaskell might be worthwhile.
18:19:01 <dminuoso> It would allow you to easily generate arbitrary algebraic data types
18:19:14 <remexre> hm, okay
18:19:41 <remexre> I'll see if using it would result in tests shorter / less complex than the actual code lol
18:19:44 <remexre> thanks for your help!
18:20:32 <dminuoso> remexre: The problem is, it cant work otherwise. The instantiation of all those generic choices would need to occur at the type level.
18:20:32 <iptq> remexre: no problem!
18:20:44 <remexre> iptq: wtf since when are you here
18:21:07 <dminuoso> remexre: So you'd need a sort of typelevel quickcheck generator.
18:21:26 <remexre> yeah, exactly
18:21:49 <dminuoso> remexre: TemplateHaskell is as close as it gets (unless you're really sadistic)
18:22:27 <remexre> hm, what are the high sadism options?
18:22:32 <dminuoso> remexre: doing it in the type level.
18:22:36 <dminuoso> It's turing complete..
18:23:00 <dminuoso> But no really, even template haskell would probably require high amounts of work, since you couldn't just make a generator and have all the shrinking.
18:23:18 <dminuoso> Since template haskell runs only one during parsing, everything it produces must be spliced already.
18:23:28 <remexre> I guess one really really really awful thing I could do
18:23:54 <remexre> would be to do quickcheck, where the property involved running ghci and trying the code there
18:24:36 <remexre> and my test suite's quickcheck is just generating the "data" declarations
18:24:40 <dminuoso> remexre: That involves IO though. From experience quickcheck gets unergonomic quickly when trying to do monadic things
18:25:06 <dminuoso> remexre: But in principle the idea is not bad
18:26:05 <remexre> yeah, I'll probably make a note in TODO.LONGTERM.md that if wacky stuff happens that seems like it's from this part of the code, that's a theoretically possible thing one could do
18:26:56 <dminuoso> remexre: I'd probably rather try and do this in templatehaskell
18:27:07 <remexre> yeah...
18:27:07 <dminuoso> And then generate edge cases
18:27:30 <dminuoso> remexre: Cant you just prove your thing mathematically?
18:27:47 <dminuoso> remexre: I mean whatever you do has to be a recursive algorithm right? Would just be a proof by induction.
18:28:03 <justsomeguy> So, I'm only on page 2 of haskellbook and I already fell down a rabbit hole looking things up on wikipedia... https://i.imgur.com/c2FDFVU.jpg Just bought a book on mathematical logic. This is great, but also -- what am I doing with my life?
18:28:27 * justsomeguy gets sidetracked very easily
18:28:32 <MarcelineVQ> idk how about you just read the book you already have :>
18:28:35 <remexre> dminuoso: ehhhhhh...... maybe. The actual function involves doing IO with another external tool
18:29:01 <dminuoso> remexre: hold on.. IO?
18:29:13 <justsomeguy> :D
18:29:14 <dminuoso> 03:12:15          remexre | as an example of something not entirely dissimilar, imagine I wrote a declaration typeName :: Generic a => Proxy a -> String
18:29:25 <dminuoso> Is that an unsafePerformIO Im smelling
18:29:25 <remexre> dminuoso: It's not entirely dissimilar!
18:29:28 <dminuoso> Heh
18:29:36 <remexre> No, thankfully
18:29:49 <remexre> I guess I should say, the property involves IO
18:30:22 <remexre> the functions I'm testing are related to interfacing w/ an external tool
18:31:12 <dminuoso> justsomeguy: Be careful not to chase the rabbit too deep. https://patrickmn.com/software/the-haskell-pyramid/
18:33:16 <justsomeguy> dminuoso: lol, It's too late for me. But yes, excellent advice. I should keep things simple.
18:34:03 <dminuoso> justsomeguy: Frequently in academic reading, it's useful to just skip things you don't understand rather than chasing everything for its definition, trying to fill in the gaps.
18:34:28 <dminuoso> Don't be scared if you miss out on half the things on your first pass. You an revisit it later.
18:34:35 <dminuoso> This is no different.
18:35:01 <dminuoso> It's much more time efficient that way.
19:17:29 <justsomeguy> Think I'll try to go with a three pass approach going forward (birds-eye, linear read, detailed re-creation and questioning), instead of reading in a depth-first way like I did with ch 1.
20:13:39 <d2ci8xc5> hello!
20:14:55 <ChaiTRex> d2ci8xc5: Hello.
20:40:27 <pagnol> There's a package I want to use (https://hackage.haskell.org/package/iCalendar) which lists Text.Calendar among its exposed modules, but GHC can't find it. How can I figure out why?
20:41:21 <glguy> pagnol: Either because you didn't install it or you didn't install the version corresponding to the documentation you're looking at
20:41:22 <pagnol> Using :modules on the repl I can see only one of the modules listed in the exposed-modules section
20:45:54 <ChaiTRex> pagnol: Text.ICalendar is listed, not Text.Calendar.
22:14:53 * hackage dhall-lsp-server 1.0.5 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.5 (GabrielGonzalez)
22:15:53 * hackage dhall-json 1.6.2 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.6.2 (GabrielGonzalez)
22:16:53 * hackage dhall-yaml 1.0.2 - Convert between Dhall and YAML  https://hackage.haskell.org/package/dhall-yaml-1.0.2 (GabrielGonzalez)
22:17:53 * hackage texmath 0.12.0.1 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.12.0.1 (JohnMacFarlane)
22:18:53 * hackage dhall-bash 1.0.28 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.28 (GabrielGonzalez)
22:39:41 <sicklorkin> Is it expected that `topLevelFun :: IO () = print Foo` should cause `Top-level binding with no type signature:`
22:40:16 <ChaiTRex> sicklorkin: You need topLevelFun :: IO (); topLevelFun = print Foo
22:40:27 <ChaiTRex> sicklorkin: Or on two lines in a file.
22:41:05 <sicklorkin> ChaiTRex: I know that, but if topLevelFun :: IO () = .. suyntax is supported does this invariant still make sense?
22:41:23 * hackage dhall-nix 1.1.12 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.12 (GabrielGonzalez)
22:41:32 <ChaiTRex> sicklorkin: I think you need an -XSomething option.
22:41:42 <ChaiTRex> > let x :: Int = 5
22:41:45 <lambdabot>  <no location info>: error: not an expression: ‘let x :: Int = 5’
22:41:49 <ChaiTRex> > let x :: Int = 5 in x
22:41:51 <lambdabot>  5
22:42:01 <ChaiTRex> Apparently turned on with lambdabot. Let me check.
22:42:16 <sicklorkin> ChaiTRex: I have the lang pragma enabled
22:42:23 * hackage dhall 1.30.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.30.0 (GabrielGonzalez)
22:42:34 <sicklorkin> which is why I can get away w/the above syntax.. 
22:44:03 <ChaiTRex> sicklorkin: Then the warning or whatever shouldn't come up, but I'd bet it doesn't take into account the possibility of that.
22:44:25 <sicklorkin> but.. for some things i.e. servant, it' would be nice to say soimeting like `myFun :: Text -> Free FooM () = client (Proxy :: Foo)` and not have to turn on ignore signatures.. 
22:44:51 <sicklorkin> ChaiTRex: Yes, you are right. It doesn't.. and now I'm wondering if it should or not?
22:45:50 <ChaiTRex> sicklorkin: It depends on whether it's enforcing idiomatic Haskell or explicit type signatures. If it's enforcing explicit type signatures, you could probably report a bug.
22:51:23 <sicklorkin> ChaiTRex: What's the difference between idiomatic Haskell and explicit type sigs? 
22:58:18 <sicklorkin> throw MyException `catch` \(e :: SomeException)-> print e -- is this idomatic or explicit?
22:59:41 <Poscat[m]> Is it possible to replace Proxy with explicit type applications?
23:00:00 <glguy> It is necessary to specify the types when using catch like that
23:00:46 --- mode: glguy set -o glguy
23:00:51 <Poscat[m]> sicklorkin: I don't think that will compile. \e -> print (e :: SomeException) is probably what you want
23:01:10 <glguy> It will compile using the right extension
23:01:48 <Poscat[m]> Hmm may I ask which extension?
23:02:10 <glguy> ScopedTypeVariables
23:02:31 <ChaiTRex> sicklorkin: The difference is the intent of the tool. Idiomatic means "using, containing, or denoting expressions that are natural to a native speaker". You have explicit type signatures, but you don't do it the 'natural' way of putting it on a separate line.
23:03:24 <glguy> Yes, you can get rid of Proxy using ScopedTypeVariables and TypeApplication
23:04:47 <glguy> And AllowAmbiguousTypes
23:11:40 <mac10688> glguy: What do you think about my haskell brick file? https://github.com/mac10688/FFXI-Skillchain-Calculator/blob/master/tui/Main.hs
23:11:57 <mac10688> Does it look sloppy or good at a glance?
23:13:08 <mac10688> I really appreciate the author of the brick library. I hope I get to thank him one day.
23:17:48 <glguy> We don't format our code the same way, I haven't used brick, and I don't like the Show instance for ChoosableWeaponType, but looking at the code from my phone it seems clean; sloppy didn't cross my mind :) 
23:18:08 <glguy> What are the six weapons?
23:18:32 <glguy> Are you equipping Goro?
23:19:25 <mac10688> lol, it's a tui tool to let a user pick up to 6 weapontypes to print out a combination of all possible skillchains. It's for ffxi.
23:19:47 <mac10688> the combinations can grow large and I know the domain so I was excited to make a tui for it
23:20:43 <Poscat[m]> https://cfp.vim-cn.com/cbf8V I can't seem to make it work :( 
23:20:47 <mac10688> took me 2 weeks of after work programming to finish the tui. I still have trouble working with lenses. I think I understand but then it doesn't compile when I try to do something better
23:20:59 <MarcelineVQ> glguy: it's vty based, like glirc afaik :>
23:22:23 <mac10688> I assume glguy knows the guy who made both libraries
23:22:36 <mac10688> so I assumed he knows them both
23:23:11 <glguy> Yeah, I work with him
23:24:42 <mac10688> Anyways, thanks for giving it a peak glguy. I'm heading to bed
23:38:34 <remexre> ugh, any clue why in https://repl.it/repls/EmbarrassedAquaWebpage , GHC can't figure out that y ~ (1 + a + b) ?
23:41:11 <int-e> I miss pastebins.
23:42:11 <remexre> Er yeah, I can pastebin it, I was extracting this from a larger codebase and wanted to make sure I was actually reproducing the error
23:43:46 <remexre> https://p.acm.umn.edu/XBHzSuOuwAE= plain text, curlable version
23:43:56 <sicklorkin> glguy: Thanks.. my original question was Is it expected that `topLevelFun :: IO () = print Foo` should cause `Top-level binding with no type signature:`
