00:10:54 <aviD> I appear to be thinking about this wrong.
00:29:36 <boxscape> Can someone explain to me why the forall here makes a difference? It seems to me like either both definitions should work, or the second one should complain that b is not in scope (which it doesn't, even if the constructor isn't there) https://pastebin.com/jUyTGcFM
00:48:00 <MarcelineVQ> boxscape: hmm, pretty mysterious
00:48:14 <boxscape> glad I'm not the only one thinking that :)
00:51:02 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-indexed-gadts  and  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#complete-kind-signatures  might have some explanation
00:51:20 <MarcelineVQ> n.b.  'the datatype G is used at different kinds in its body, and therefore that kind-indexed GADTs use a form of polymorphic recursion'
00:51:48 <MarcelineVQ> 'data T1 :: k -> Type            -- No CUSK: `k` is not explicitly quantified'   'data T2 :: forall k. k -> Type  -- CUSK: `k` is bound explicitly'
00:58:17 <boxscape> hm, but it still works if I enable -XNoCUSKs in 8.10
00:59:40 <boxscape> MarcelineVQ Still looks like the solution though, thanks
00:59:43 <MarcelineVQ> alas. but it does show that there's a deeper difference between the declarations than just whether the forall is explicit
00:59:50 <boxscape> yeah
01:01:00 <boxscape> luckily CUSKs are on the path to deprecation so I assume this won't matter at some point in the future
01:10:14 <sim590> I'm getting this error message: https://paste.debian.net/1130797/ which I can't understand properly. Here's the code snippet: https://paste.debian.net/1130795/. Is there a type that doesn't match? Can I not use `visited` inside the `go` function?
01:11:29 <sim590> According to what I want to do, `visited` should be a `MVector (PrimState m) Bool` as what is expected by ghc, but it somehow doesn't get that and I don't understand why. I don't understand where the `s` is coming from..
01:11:56 <sim590> The `s` in `MVector s Bool` that is somehow the resolution of the type.
01:26:50 <sim590> Wow... I just removed the signature for `go` and there's no more errors... Why?
01:29:33 <dmj`> sim590: the compiler inferred the correct one
01:29:54 * hackage reanimate-svg 0.9.5.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.5.0 (DavidHimmelstrup)
01:30:21 <boxscape> sim590 you could try replacing the signature of go with an underscore and see what ghc tells you it should be
01:30:24 <sim590> I guess that it had to do with the fact that I was making `go` depend on `PrimMonad` while it should have been something else relating to the usage of `runST` ?
01:30:45 <sim590> boxscape: Oh. I didn't know about that. Will try that
01:32:34 <sim590> It says `Tree (Either a (Int, Int)) -> ST s (Set (Set Int))`, but if I put that, I get the same error from before.
01:32:45 <sim590> more or less
01:33:38 <sim590> dmj`: Yeah, but I would like to understand how I could write the signature properly.
01:33:52 <sim590> I don't get what it wnats.
01:34:06 <sim590> `go :: Tree (Either a (Int, Int)) -> ST s (Set (Set Int))` this didn't work.
01:34:09 <boxscape> sim590 it's probably because the `s` that it needs is brought into scope somewhere without being given an explicit name so you can't actually access it in the type signature. You probably need -XScopedTypeVariables to write this signature, but not sure where exactly you have to explicitly bring s into scope
01:34:45 <dmj`> sim590: you need scoped type variables
01:35:51 <boxscape> probably a type signature for visitor would help?
01:35:54 <boxscape> uh
01:36:00 <boxscape> visited
01:36:22 <boxscape> I believe that's where the s can be brought into scope but I'm not sure
01:36:31 <sim590> I wasn't sure if I could make a type signature for a binding on the leftside of `<-`.
01:36:52 <boxscape> sim590 with ScopedTypeVariables you should be able to do (visited :: <type>) <- ... I think
01:40:02 <boxscape> (actually the parentheses aren't needed)
01:41:55 <sim590> well I'm not too sure how to write the type. I was looking to do this because in the process of debugging, writing the type of go (or visited) was a way to get more accurate error messages. However, when signatures get complicated, I see that it can hurt me back.
01:42:14 <boxscape> sim590 try the underscore for visited?
01:45:24 * hackage fcf-containers 0.4.0 - Data structures and algorithms for first-class-families  https://hackage.haskell.org/package/fcf-containers-0.4.0 (gspia)
01:59:56 <sim590> boxscape: I get: Found type wildcard ‘_’ standing for ‘w’
01:59:57 <sim590>       Where: ‘w’ is a rigid type variable bound by
01:59:59 <sim590>                the inferred type of <expression> :: w
02:00:01 <sim590>                at SPGraph.hs:97:14
02:00:31 <boxscape> huh. not sure what to make of that
02:04:01 <boxscape> % x | let = 4
02:04:01 <yahb> boxscape: 
02:04:04 <boxscape> didn't know that worked
02:04:36 <boxscape> (that technically means let can be used as a much shorter version of "otherwise" for fun, profit and confusion)
02:36:00 <muesli4> Hi, is there a library that generalizes Data.Tree to (more or less) arbitrary foldables? I don't know how far that's possible but I need it with Data.Seq
02:39:19 <jophish> Is there a shorter way of writing $(lift =<< [t|Some Type|])?
03:06:53 * hackage morley 0.7.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.7.0 (gromak)
03:08:23 * hackage morley 1.0.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.0.0 (gromak)
03:17:13 <merijn> muesli4: I'm confused what that would even mean?
03:19:06 <muesli4> merijn: I don't know what's necessary to implement all operations of Data.Tree. I was just guessing. However, I need a tree that supports a higher efficiency on index operations. Also Data.IntMap does not work because then I have to manually shift indices.
03:22:57 <__monty__> Higher efficiency retrieving values than a finger tree?
03:23:45 <muesli4> monty: Data.Tree does not use a finger tree. It is a rose tree with the forrest being a list.
03:24:28 <muesli4> Well, for the operations that I require it seems to work very well with Data.Seq: https://gist.github.com/muesli4/5ea7898b460f626fd5dda69bff0b1182
03:25:06 <muesli4> monty: Which internally uses a lot of finger trees.
03:29:54 * hackage logic-TPTP 0.4.7.0 - Import, export etc. for TPTP, a syntax for first-order logic  https://hackage.haskell.org/package/logic-TPTP-0.4.7.0 (MasahiroSakai)
04:06:23 * hackage groups-generic 0.1.0.0 - Generically derive Group instances.  https://hackage.haskell.org/package/groups-generic-0.1.0.0 (sheaf)
04:24:55 <albet70> is there a ghc version for 32 bit windows 10?
04:25:20 <albet70> I only find 64 bit for windows 10
04:26:54 * hackage acts 0.3.0.0 - Semigroup actions, groups, and torsors.  https://hackage.haskell.org/package/acts-0.3.0.0 (sheaf)
04:48:55 * hackage reanimate-svg 0.9.6.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.6.0 (DavidHimmelstrup)
05:19:24 * hackage extra 1.6.20 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.20 (NeilMitchell)
05:37:48 <Phyx-> albet70: 8.6.5 is the last released one, 8.8 and 8.10 need to be build from source till we sort out some release issues for it
06:20:37 <wordlesstuba> Hi everyone :)
06:31:53 * hackage hodatime 0.2.1.1 - A fully featured date/time library based on Nodatime  https://hackage.haskell.org/package/hodatime-0.2.1.1 (jason_j)
06:39:23 <boxscape> If you have something like "class Foo a where foo :: a", is foo still considered a "method"? Considering it's an associated value rather than an associated function
06:43:26 <boxscape> % data P (t :: k) (a :: t)
06:43:26 <yahb> boxscape: ; <interactive>:178:23: error:; * Expected a type, but `t' has kind `k'; * In the kind `t'
06:43:28 <boxscape> and why can't I do thiss
06:43:39 <boxscape> not that I expect it to be useful I suppose...
06:50:54 * hackage polysemy-zoo 0.7.0.0 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.7.0.0 (KingoftheHomeless)
06:54:51 <hexagoxel> boxscape: isn't that just the polykinded `data P (a :: k)` ? It is possible to use the k from the kind signature on the RHS, e.g. `data P (a :: k) = P k`
06:55:33 <c_wraith> Is that possible?  I guess it's possible with TypeInType
06:55:52 <boxscape> c_wraith PolyKinds
06:55:56 <hexagoxel> I tested on 8.8
06:56:25 <c_wraith> That can't work with only PolyKinds.  You need something to flatten types and kinds
06:56:34 <boxscape> c_wraith Type :: Type is always true
06:56:37 <geekosaur> TypeInType is always on
06:56:45 <boxscape> TypeInType is deprecated, or at least will be soon if it's not already
07:00:23 * hackage hOpenPGP 2.9.3 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.9.3 (ClintAdams)
07:00:25 <boxscape> hexagoxel that's actually a pretty interesting declaration, if I'm seeing this correctly you can construct values (like `P True`), but these values must necessarily have a polymorphic type
07:00:40 <boxscape> because there's no values of type True
07:01:57 <boxscape> % data P (a :: k) = P k
07:01:57 <yahb> boxscape: 
07:01:59 <boxscape> % :t P True
07:02:00 <yahb> boxscape: P a
07:02:34 <vshev4enko> Hi everyone
07:03:52 <hexagoxel> % :t P True :: P 'False
07:03:52 <yahb> hexagoxel: P 'False
07:03:59 <boxscape> oh, well, nevermind
07:04:02 <hexagoxel> well, if that is not confusing :D
07:04:16 <boxscape> oh, I see
07:05:07 <boxscape> of course `P k` means that the argument is a value of type k, not that the argument is k itself
07:06:24 * hackage debian 4.0.1 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-4.0.1 (ClintAdams)
07:07:20 <WzC> I've run into some weirdness using quickcheck. I'm trying to generate a random set of values of a given size (so all elements should be different). I wrote it like this https://gist.github.com/noinia/50354ff0db90958bf0b9ba8a67d7a767 but for some weird reason QC seems to genrate an infinite list of zero's when I use 'infiniteListOf arbitrary' rather than somethings ensible :S
07:07:30 <WzC> anyone an idea why that is happening? 
07:08:23 <WzC> (if I just use 'generate (setOf 5 arbitrary) >>= \(xs :: Set.Set Int) -> print xs ' I do get different values) 
07:11:40 <mlugg> I'm having a weird issue with the `binary_strict` package. I've added it to a project's build-depends in its cabal file, but when cabal attempts to build it, I get the following error: https://termbin.com/fi9q I would normally assume this is caused by a broken package, but binary-strict is a fairly ubiquitous package and I can't find any reference
07:11:40 <mlugg> to this issue online anywhere. Does anyone have any idea what I might be doing wrong?
07:20:53 * hackage pandoc 2.9.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.9.2 (JohnMacFarlane)
07:24:24 * hackage polysemy 1.3.0.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-1.3.0.0 (KingoftheHomeless)
07:25:23 * hackage polysemy-plugin 0.2.5.0 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.5.0 (KingoftheHomeless)
07:28:56 <lyxia> mlugg: on Hackage it fails to build with the same error on GHC 8.6 https://matrix.hackage.haskell.org/#/package/binary-strict/0.4.8.4/ghc-8.6.5@1580982864
07:29:16 <lyxia> so it looks like an issue with the package
07:30:12 <lyxia> It's also not really ubiquitous
07:31:29 <mlugg> Ah, okay. I assumed it was, since it's linked from the wiki and I've seen it referenced in several places and stuff
07:31:39 <mlugg> What should I use as an alternative?
07:32:15 <mlugg> My specific use case is parsing MNIST data; I want to do it strictly, since the program will need all the data eventually anyway so I figure there's no point doing it lazily
07:39:47 <lyxia> cereal is more common (it has 380 reverse dependencies vs 10 for binary-strict) https://packdeps.haskellers.com/reverse/cereal
07:43:53 <lyxia> WzC: sample runs your generator with varying values of size, including 0.
07:44:23 <lyxia> WzC: generate only uses a fixed size (20 or so)
07:46:28 <glguy> binary is the alternative to cereal. Binary isn't lazy like it used to be
07:47:29 <idnar> `A do-notation statement discarded a result of type ‘Void’` 🤦‍♀️
07:50:04 <solonarv> idnar: oh, but that's actually a useful warning!
07:50:07 <glguy> That warning is easy to turn off, or the code can be fixed to be polymorphic in its return type
07:50:15 <solonarv> it tells you that the rest of that 'do' block can't possibly run
07:51:37 <glguy> Probably doesn't*
07:52:16 <solonarv> well, okay, that statement could return bottom at some point
08:01:41 <nshepperd2> i think it does mean that the rest of the do block doesn't run
08:02:28 <nshepperd2> unless the monad is so trivial that there's no difference between running or not
08:04:07 <nshepperd2> ie. what are the effects of 'x >>= absurd'
08:06:57 <solonarv> well, it means that if you ignore bottoms
08:07:10 <WzC> lyxia: thanks, that helped me to fix the problem :D
08:07:55 <solonarv> % let voidy = (undefined :: Void) <$ putStrLn "returns void"; in do v <- voidy; putStrLn "still here"
08:07:55 <yahb> solonarv: returns void; still here
08:12:32 <nshepperd2> oh, true
09:33:54 * hackage verbosity 0.4.0.0 - Simple enum that encodes application verbosity.  https://hackage.haskell.org/package/verbosity-0.4.0.0 (PeterTrsko)
09:37:02 * sm[m] wonder's what that's all about
09:37:59 <sm[m]> for a simple enum, it's got a lot of packaging, maintenance and features
09:39:54 <sm[m]> but not enough documentation
09:47:52 <heatsink>  Is there a way to search for what depends on a given package?
09:47:59 <heatsink> in hackage
09:49:48 <solonarv> heatsink: not in hackage, but there is a third-party tool
09:49:53 * hackage base32 0.1.0.0 - RFC 4648-compliant Base32 encodings/decodings  https://hackage.haskell.org/package/base32-0.1.0.0 (topos)
09:50:18 <solonarv> heatsink: https://packdeps.haskellers.com/reverse or https://packdeps.haskellers.com/reverse/${PACKAGE_NAME}
09:50:31 <heatsink> thanks!
09:51:42 <topos> we now have a working base32 package in haskell. None of the alternatives worked properly save Memory, which was not encoding-specific
09:55:00 <__monty__> What do you mean?
09:56:00 <mniip> fsvo working
09:56:20 <juri_> aaw. no-one depends on my package. :(
09:59:40 <mniip> I have a package with 9 rev-deps pogchamp
10:03:23 * hackage base32 0.1.1 - RFC 4648-compliant Base32 encodings/decodings  https://hackage.haskell.org/package/base32-0.1.1 (topos)
10:08:54 * hackage base32-lens 0.1.0.0 - Optics for the Base32 library  https://hackage.haskell.org/package/base32-lens-0.1.0.0 (topos)
10:22:54 * hackage inline-asm 0.1.1.0 - Inline some Assembly in ur Haskell!  https://hackage.haskell.org/package/inline-asm-0.1.1.0 (0xd34df00d)
10:37:23 * hackage ghc-lib-parser-ex 8.8.5.2 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.2 (shayne_fletcher)
10:49:25 <joko> Hey, I've been experimenting with the typed-process library for the past hour and I'm wondering why 'runProcess_ $ "echo hi"' works, but not 'runProcess_ $ "echo " ++ "hi"'. Isn't the latter with the concatenation still considered a string? 
10:49:40 <mniip> probably the former isn't a String
10:49:54 <mniip> rather some type for which IsString has been defined
10:50:34 <mniip> c.f. https://hackage.haskell.org/package/typed-process-0.2.6.0/docs/System-Process-Typed.html#t:ProcessConfig
10:51:56 <joko> mniip: ah, I see... But still, why "echo " ++ "hi" 
10:52:19 <joko> isn't considered a string for the constructor?
10:52:39 <idnar> try <>
10:52:44 <geekosaur> because ++ isn't a string operator, it's a list operator. it happens that String itself is a list, but e.g. Text isn't
10:54:30 <joko> Ah, so the two strings are considered text and then the list operator ++ does a different "concatenation" than what I expected?
10:54:53 <joko> Text *
10:57:24 <Ianulus> Hi all!
10:58:16 <Ianulus> I was trying to build haskell-ide-engine via "stack .install.hs hie-8.6.5".
10:58:43 <Ianulus> It failed with "stack: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)"
10:59:04 <Ianulus> full output:
10:59:06 <Ianulus> [ben@nixos:~/haskell-ide-engine]$ stack ./install.hs hie-8.6.5
10:59:06 <Ianulus> [1 of 2] Compiling Main             ( /home/ben/.stack/setup-exe-src/setup-mPHDZzAJ.hs, /home/ben/.stack/setup-exe-src/setup-mPHDZzAJ.o )
10:59:07 <Ianulus> [2 of 2] Compiling StackSetupShim   ( /home/ben/.stack/setup-exe-src/setup-shim-mPHDZzAJ.hs, /home/ben/.stack/setup-exe-src/setup-shim-mPHDZzAJ.o )
10:59:07 <Ianulus> Linking /home/ben/.stack/setup-exe-cache/x86_64-linux-nix/tmp-Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5 ...
10:59:08 <Ianulus> # stack (for check)                 
10:59:08 <Ianulus> Error when running Shake build system:
10:59:09 <Ianulus>   at want, called at src/Development/Shake/Internal/Args.hs:83:69 in shake-0.18.3-K6N2eLzVtai6jtZeWAmEIo:Development.Shake.Internal.Args
10:59:09 <Ianulus> * Depends on: hie-8.6.5
10:59:10 <Ianulus>   at apply1, called at src/Development/Shake/Internal/Rules/Rerun.hs:41:5 in shake-0.18.3-K6N2eLzVtai6jtZeWAmEIo:Development.Shake.Internal.Rules.Rerun
10:59:10 <Ianulus> * Depends on: check
10:59:11 <Ianulus> * Raised the exception:
10:59:11 <Ianulus> stack: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
11:00:56 <topos> mniip that is the scariest IsString instance of them all I think
11:01:04 <topos> I remember seeing that at one point and shuddering
11:01:31 <mniip> joko, ++ is only defined for String
11:01:33 <mniip> or rather [a]
11:01:50 <d34df00d> Let's say I'm writing an expression quasiquoter that could be used like `foo x y = [myQQ| smth $(x) smth smth |]
11:01:50 <mniip> ProcessConfig is not [a]
11:02:03 <d34df00d> Can I reify `x` to know its type?
11:02:10 <d34df00d> Within the QQ, that is.
11:02:42 <mniip> if x is an arbitrary expression I don't think you can
11:02:47 <d34df00d> `lookupValueName "x"` works and returns something reasonable, but trying to reify that name results in • ‘x_aGPG’ is not in the type environment at a reify
11:02:57 <d34df00d> mniip: that's a pattern variable for the function.
11:03:05 <mniip> that's not gonna work
11:03:27 <d34df00d> Uh, that sucks.
11:03:55 <d34df00d> Means I'll have to repeat the types for the variables again in the QQ one way or another.
11:04:00 <mniip> this might help https://hackage.haskell.org/package/th-tc
11:04:14 * d34df00d writing an inline-asm quasiquoter, having done https://github.com/0xd34df00d/inline-asm
11:04:48 <d34df00d> mniip: I don't think there's enough local context to derive the type of `x` without looking at the signature of the surrounding function where the said quasiquoter is used.
11:05:52 <monochrom> A process-spawning library that promises to give you stronger typing than what comes with GHC. Then goes on to undermine it all with overloaded strings.
11:06:15 <fendor> Ianulus, are you using nixos or something like that?
11:06:42 <Ianulus> fendor: yes, I am
11:07:09 <geekosaur> that error looks like it's trying to run exec as a command, which won't work because it's a shell builtin
11:08:00 <monochrom> Hahaha "when inline C is too safe"
11:09:16 <fendor> Ianulus, then stack launches the process in a pure nix-shell, ironically where you have no access to the `stack` executable
11:10:01 <fendor> my recommendation is to either use all-hies (https://github.com/Infinisil/all-hies) or cabal (./cabal-hie-install.sh hie-8.6.5)
11:10:33 <Ianulus> fendor: I was under the impression stack and nixos were well integrated...
11:10:38 <fendor> or you can also compile the installation script into an executable. I think something like `stack ghc install.hs && ./install help` should work 
11:11:12 <fendor> Ianulus, yeah, but stack and nixos dont work well together and I never manage to make it work
11:11:38 <nshepperd2> instance IsString (IO ()) where fromString = executeJavascript
11:11:49 <phadej> evil
11:13:24 <fendor> so, if you are *eager* to make it work that way (stack ./install.hs hie-8.6.5), you will have to experiment with the `shake.yaml` yourself. I dont know the flags or config required to make it work
11:14:07 <fendor> maybe the stack-script feature was never considered to work with nixos? Maybe I just dont get it, or maybe it is a stack bug
11:23:35 <d34df00d> If I have a String with contents like "Int -> Int", is it possible to pass it through the same machinery as the [t| |] quote?
11:24:02 <d34df00d> I basically want smth like [t| $(str) |], but str is expected to be a Q Type already.
11:24:06 <Ianulus> fendor: I don't think I know enough about the inner workings of stack & nix.
11:25:34 <prog25> is there a haskell project doing audio or image "fingerprint" inference?
11:25:53 <prog25> ie. finding patches which characteristic features
11:26:25 <prog25> not sure if its a convolutional classifier... or maybe something that could be adapted into one?
11:27:16 <monochrom> d34df00d: You will need a haskell parser.  The common ready-made ones are haskell-src and haskell-src-ext.
11:27:24 <fendor> Ianulus, all-hies is probably the easiest approach :) Or cabal, but that takes a long time
11:29:58 <d34df00d> monochrom: thanks! That might work!
11:30:09 <Ianulus> fendor: Checking out all-hies now.
11:30:12 <d34df00d> Although I wonder why do they define their own types for everything. Where are my trees that grow?
11:30:46 <prog25> just use HSum of HLIst
11:30:46 <dmj`> prog25: there’s an echo nest client for Haskell
11:31:27 <prog25> oh, google says thats used by spotify, ill check
11:32:17 <prog25> hmm, no that just seems to be an API
11:32:18 <prog25> https://github.com/hawkish/echonestclient/blob/master/echonest.hs
11:32:26 <prog25> to eg look up song by artist
11:33:18 <prog25> i want to be able to eg, find common image patches in consecurive frames of a movie eg for 3d modeling 
11:33:46 <prog25> or, to detect impulses like how the echonest must work under the hood
11:34:31 <prog25> i can find accademic papers on the use of ANN and RNN's for this, but then I would need a sufficiently powerful NN lib in haskell
11:35:22 <prog25> and there are some "human expertise" guided approaches which could have a learning free approach I thought might have made it into a package or so
11:36:20 <prog25> something similar is used on market signals aswell
11:37:15 <prog25> ie your "feature detector" is some function over a historic interval, and there is a correlation drawn between the various options of measures used as feature detectors 
11:37:47 <juri_> prog25: I used to use gabor filters for that, umpteen years back.
11:38:08 <prog25> thats not really a statistic though
11:38:17 <prog25> more of an expanded space on which to run statistics
11:39:03 <prog25> eg. if you have a time frequency plot of a song, you could see when there is a bass drum and crash symbol, and you could detect the start of a bar
11:39:49 <prog25> where the "fingerprint" is just a crude measure like the distance between the two furthest blobs in time-freq space
11:40:17 <prog25> so the gabor to get the time freq is just a different space to look for features in
11:40:58 <prog25> and if a statistic used the gabor transform internally, it could be factored out
11:41:22 <prog25> differentiating coordinate transforms from actual feature detection
11:42:19 <prog25> though i guess you could just keep doing coordinate transforms until you have a really simple thing to use as a feature detector, like counting the number of nonzero basis vectors used or something 
11:43:19 <prog25> and then, these seem like they would need to be learned, and the hope of finding a lib in haskell is then just for an easily trained parametric learning model, which I have yet to find
11:43:47 <prog25> thought that the fingerprint problem might be common enough to have some alternative approaches to examine
11:45:06 <prog25> basically, thats phrasing it as a k-sparse dictionary learning or basis pursuit problem 
11:45:18 <prog25> im not sure if we actually have any compressed sensing packages
11:46:30 <prog25> like, you can just do crude stochastic monte carlo updates, adding noise to the dictionary/basis vectors/frame, and then finding the sparsest adequate superposition
11:47:08 <prog25> like, adding noise to the basis elements, and keeping the new and old versions, and projecting onto them to see which are used
11:47:33 <prog25> that seems like a pretty neat alternative to learning, as its in a convex optimisation setting
11:47:49 <prog25> though the stochastic dictionary updates could be slow to converge
11:48:00 <prog25> and again, no libraries
11:49:10 <prog25> and also, this is a "linear" decomposition, where "features" are actually coordinates on a nonlinear manifold
11:50:07 <prog25> ie, you would want them to be inputs to a function, such as a generative model which produces a picture of a dog with stripes, trained on pictures of dalmations and zebras
11:50:19 <prog25> you cant just "add the basis vectors"
11:51:16 <Ianulus> fendor: Do you know the executable for hie? vscode is complaining "hie executable missing"
11:51:33 <prog25> the words "dog" and "stripes" are taken by a "nonlinear function", and the whole manifold learning problem then seems totally beyond the realms of dictionary learning, which is essentially a linear algebra problem
11:52:27 <prog25> the "features" then seem like codewords to input to a neural network approximator of a nonlinear function representing the manifold 
11:53:07 <prog25> i cant even begin to understand how to gather what could be helpful from hackage to try and approach this
11:54:12 <fendor> Ianulus, did you install hie via all-hies? Does `hie` exist?
11:54:14 <prog25> i dont even think we have Locally Linear Embeding, or any of the industry standards for machine/manifold learning
11:55:22 <nshepperd2> the usual solution to these problems is to STACK MORE LAYERS
11:56:30 <Ianulus> fendor: I installed via "NixOs" instructions from hie's Readme.md. `hie` does not exist for either root or user.
11:57:44 <Ianulus> fendor: Wait, something seems to have gone wrong; trying again.
12:07:19 <joko> re: typed-process, I had to use the "shell" constructor, instead of blindly putting a String >_M
12:07:24 <joko> >_<
12:08:46 <maxsu> hey all, little math puzzle/riddle
12:09:54 * hackage tar-bytestring 0.6.1.2 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.1.2 (maerwald)
12:11:23 <maxsu> in vscode there's a code outline tool which gives you an alphabetical listing of all the variables, classes, methods etc in the code. This might reduce a 500 line file into say 30 items. Can we  model and estimate how much this might speed the process of code comprehension?
12:13:38 <maxsu> I feel like I used to have to read a lot of code to kind of jump into the file, but now I can just read the outline and jump directly to the functionality I want to work with
12:15:40 <heatsink> Some software engineering productivity studies try to measure effects by timing programming tasks
12:16:23 <maxsu> in proof theory we have all sorts of neat results based on how much some normalization shrinks things - so I'm wondering if we can think of the outlining step as a normalization and estimate its effect on average
12:16:26 <maxsu> in proof theory we have all sorts of neat results based on how much some normalization shrinks things - so I'm wondering if we can think of the outlining step as a normalization and estimate its effect on average
12:16:43 <heatsink> Its effect on average what?
12:16:48 <maxsu> ^ this might be even easier that watching users, because you can run it against a code base
12:17:39 <maxsu> like, find out how much outlining shrinks each file in a code base
12:18:06 <heatsink> You could measure that, but how is it a good proxy for programming productivity?
12:18:21 <heatsink> I could shrink file sizes even more, but no guarantees about whether it helps anyone
12:19:50 <maxsu> that's true
12:21:10 <maxsu> I would still be curious to see how the outline grows with code size, for instance
12:21:29 <maxsu> hopefully linearly?
12:24:00 <monochrom> How is outlining normalization?
12:28:14 <[exa]> maxsu: can I name the variables so that if you see their sorted list reads as a manual?
12:28:23 * hackage colourista 0.0.0.0 - Convenient interface for printing colourful messages  https://hackage.haskell.org/package/colourista-0.0.0.0 (vrom911)
12:32:09 <maxsu> monochrom, because it kind of preserves the semantics of the code and makes them easier to see?
12:32:25 <maxsu> [exa], hax!
12:39:42 <nshepperd2> seems like 
12:39:52 <nshepperd2> 'kind of' is doing a lot of work there
12:40:14 <nshepperd2> you can't execute a code outline
12:40:40 <monochrom> name != semantics
12:42:23 <monochrom> It means I probably need to update my tautology from "X is like Y" to "X is kind of like Y".
12:44:25 <monochrom> I also know first-hand of many programmers and many cases of choosing misleading names and trusting misleading names. Therefore in the wild west real world out there, name = anti-semantics.
12:44:47 <monochrom> Perhaps s/trusting/mistrusting/
12:49:23 <int-e> :t nub
12:49:25 <lambdabot> Eq a => [a] -> [a]
12:50:50 <siraben> I have a CSV file I'm using to analyze data, but reading from the file system causes IO to appear in the types. How do I avoid using unsafePerformIO to make a global?
12:51:24 <siraben> ReaderT?
12:52:31 <heatsink> One way is to lazily read the file into a list
12:52:39 <heatsink> or into a Text or ByteString
12:53:00 <heatsink> That way, the analysis code deals with a non-IO type
12:54:24 <heatsink> The other way is to write your own monad which encapsulates IO
12:54:38 <siraben> Also, I have a lot of duplication of code when I do the analysis, due to needing different "views" of the data, will lenses help with this?
12:55:10 <heatsink> I don't understand
12:56:20 <siraben> So once I have my data, I process it in different ways. But then I have to repeat the processing for different subsets of the data.
12:56:29 <[exa]> siraben: lenses help with lot of stuff but judging from the IO problem you will most likely want to change the way you access the CSV
12:56:39 <[exa]> siraben: do you have some code sample to start with?
12:57:24 * hackage streamly-posix 0.1.0.0 - Posix related streaming APIs  https://hackage.haskell.org/package/streamly-posix-0.1.0.0 (maerwald)
12:58:14 <[exa]> siraben: and directly to the IO problem, you can convert any function to IO-capable function by just "wrapping" the return argument with IO, and making the order of operations explicit using a 'do'
12:58:28 <siraben> [exa]:  https://paste.debian.net/1130869/
12:58:44 <siraben> Too much duplication
12:58:48 <geekosaur> main = do data <- read_the_CSV; {- various functions which can operate on the now pure "data" -}
12:58:59 <siraben> I see.
12:59:11 <geekosaur> @where iotut
12:59:12 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
12:59:28 <siraben> However I'm working mostly at the REPL, not writing a monolithic main.
12:59:41 <geekosaur> still works
12:59:53 <geekosaur> in fact you can do the data <- whatever without a do
13:00:08 <siraben> Hm.
13:00:17 <siraben> What about V.length data?
13:00:34 <siraben> V.length <$> data has to be written instead, because data has type IO ...
13:00:40 <geekosaur> so I have some puzzle solving utilities which I load into ghci, then dict <- loadDict
13:00:59 <siraben> [exa]: Can lenses alleviate that duplication?
13:01:03 <geekosaur> which loads the system dictionary into a Set for use by other utils
13:01:13 <geekosaur> no, it won't be IO
13:01:14 <[exa]> siraben: how big is the CSV?
13:01:31 <[exa]> like 100 rows, 10k rows, or a gzillion?
13:02:06 <siraben> [exa]:  59272 rows
13:02:08 <[exa]> also I'm a bit lost with e.g. dogName and teamID, these extract stuff from the CSV?
13:02:28 <[exa]> siraben: you don't need IO in the middle until like millions of rows, just load the whole table and work with it
13:03:08 <siraben> [exa]:  https://paste.debian.net/1130870/
13:06:10 <[exa]> siraben: and the type of dogName is IO Text?
13:06:36 <[exa]> oh no it's String->Bool
13:06:54 <siraben> [exa]:  Text -> Bool
13:06:58 <siraben> yeah
13:07:29 <siraben> it's difficult to repeat the analysis for different teams, because they each require a different "view" into the dataset
13:07:36 <siraben> Hence the massive duplication of functions
13:07:49 <[exa]> siraben: anyway the thing you want to do is basically to just count events of type 'pass' in buckets and then compute some stats on that, right?
13:08:04 <siraben> Should I consider using Reader so that the data is automatically filtered based on the environment?
13:08:24 <siraben> Reader (Data → Bool) a
13:08:43 <siraben> So that a only uses the parts of the data that satisfy the predicate?
13:08:55 <[exa]> so there are dog and oponnent teams right?
13:09:02 <siraben> Yes
13:09:06 <siraben> Multiple opponent teams
13:09:13 <siraben> like opponent1, opponent2, etc.
13:09:28 <siraben> doing V.filter everywhere hardly seems elegant
13:11:20 <[exa]> yeah
13:12:08 <[exa]> so anyway, the output is just the variance? why not filter the whole CSV first manually and compute the variance trivially from the rest?
13:13:36 <siraben> [exa]:  Yeah, so one of the many things I'm analyzing is variance. But now the requirements need that I do variance based on say different game halves, or specific teams
13:13:45 <[exa]> the complete CSV is stored as (Vector EventRow) right?
13:13:52 <siraben> Most of the functions so far are Int → Double, say, which return a statistic for a given game number.
13:13:54 <siraben> Yes
13:14:17 <siraben> But now the statistic needs to be computed for more granular views of the data
13:16:12 <[exa]> anyway you're trying to be super-generic which helps and is generally adviseable, but let's just make it simple and use SQL *cough* list comprehensions
13:18:56 <[exa]> something semantic, like dogPass d field = [field x | x <- V.toList d, eventType x == Pass, dog x]
13:19:32 <[exa]> from that you can easily compute mean&variance
13:20:14 <[exa]> I mean, transforming data to simpler data is basically free in this case, so why not simplify the situation
13:20:38 <siraben> Ah, I see.
13:20:46 <siraben> So, no need for lenses?
13:21:09 <[exa]> not yet
13:21:26 <[exa]> lenses are great for json-like stuff where you need to generalize a lot over the fields
13:21:42 <[exa]> this should be okay with normal field accessors
13:21:58 <siraben> Ah, lenses are good for nested records, I suppose?
13:22:06 <[exa]> yeah, irregular data
13:22:23 <siraben> That helps, thanks.
13:22:47 <[exa]> in this "SQL" case the lenses would look mostly like list comprehensions: roughly `filtered passEvent . filtered dogEvent`
13:23:02 <[exa]> probably not worth the machinery
13:23:30 <[exa]> anyway your posData is IO (Vector EventRow) ?
13:23:35 <siraben> Where filtered has what type?
13:23:47 <[exa]> some lensish disaster type
13:24:07 <siraben> Hm. That seems sort of elegant, no?
13:24:08 <[exa]> https://hackage.haskell.org/package/lens-4.19.1/docs/Control-Lens-Combinators.html#v:filtered
13:24:17 <siraben> Or should I just do V.filter f . V.filter g etc.
13:24:48 <[exa]> guards in the list comprehensions are shorter because you don't need to spill 'filter' everywhere
13:25:05 <[exa]> also gives you a nice chance to match pairs of events, by just binding it twice
13:25:07 <siraben> Ok. Thanks.
13:25:37 <[exa]> the second thing, get rid of the IO before it gets into these functions
13:26:15 <siraben> posData :: Int -> M.Map Text Int, actually
13:26:32 <[exa]> oh so it's not IO
13:26:33 <[exa]> okay
13:26:37 <siraben> but then it uses that int to index into the game events from the CSV
13:26:49 <siraben> Now if I want posData to work for subsets other than games...
13:26:54 <siraben> that's trickier
13:28:11 <[exa]> posData is something like PlayerID -> Map (what here?) Position ?
13:28:55 <siraben> it's more like GameID → Map PlayerID (V.Vector Point)
13:29:22 <[exa]> oh I see
13:29:30 <siraben> Are vectors even necessary here? Would lists work just as well?
13:29:44 <[exa]> vectors are good for quick indexing
13:29:59 <siraben> I'm barely indexing
13:30:08 <[exa]> if your algorithm needs frequent access to n-th elements of some lookup-like table, go for vectors
13:30:38 <[exa]> if the algorithm just traverses the structure in order, lists are usually best (they don't even have to materialize)
13:31:03 <[exa]> except for stuff like Strings where the list overhead may sometimes hurt
13:31:31 <siraben> Ah.
13:35:00 <siraben> Does cassava have a read to list option?
13:36:46 <phadej> yes
13:37:01 <phadej> if you mean list of lists
13:37:29 <siraben> phadej:  yes
13:38:02 <siraben> Which one?
13:38:19 <siraben> Which function*
13:39:00 <phadej> there is FromField a => FromRecord [a] instance
13:39:19 <monochrom> Recall that "decode" is bloodily polymorphic in codomain. Just add type annotations.
13:39:53 <monochrom> For example just ask for [[String]]
13:40:30 <phadej> Vector [a], but yes
13:41:01 <siraben> https://paste.debian.net/1130873/
13:41:19 <prog72> i was looking for descision trees in haskell and I found this; http://hackage.haskell.org/package/hinduce-classifier-decisiontree-0.0.0.1
13:41:46 <prog72> can anyone see how to use it?
13:41:49 <monochrom> Oops, you're right, the outer container has to be Vector.
13:42:23 <monochrom> Vector [String] then.
13:43:07 <siraben> Eh, but my data is V.Vector (EventRow)
13:43:33 <monochrom> What is EventRow?
13:44:15 <monochrom> I think we should see the actual code, too.
13:45:54 <siraben> http://ix.io/2bUi
13:46:22 <monochrom> And where is the code that the error message talks about?
13:46:36 <monochrom> And what is EventType?
13:47:23 <siraben> eventtype is just some enum
13:48:28 <monochrom> Do we know for sure that it's an instance of FromField?
13:48:29 <prog72> also, on what i was asking about before i found some terminology; perceptually important
13:50:54 <siraben> Yes,
13:51:15 <prog72> basically they are used to compress the input data to input to the NN, where like PCA or SVD these compressive measures are better than the frame expanding methods like wavelet transforms because they reduce rather than increase the required complexity of the net required to perform clasification over these inputs.
13:51:43 <lihslfijhv> @pl \xs -> 1 < length xs
13:51:43 <lambdabot> (1 <) . length
13:52:38 <prog72> you want to project down to a small feature space, rather than onto an overcomplete dictionary, which might be where layered sparse representation could be used to thin out the dictionary to make it less like a frame and more like a feature space
13:53:26 <prog72> basically, if you are stochastically updating weights of the net, its not going to be able to converge at each layer on something simple like a moving average of fft
13:54:13 <prog72> so normally the user will run the NN over "statistical indicators", as provided eg by the market forcasting literature
13:54:32 <prog72> to save the NN having to learn these common shemes as layers
13:55:12 <prog72> pointless getting it to rederive an fft or averaging scheme, but adding all these extra input connections massively increases the complexity of the learning task
13:56:16 <prog72> meaning that low dimensional feature identification, or basically, any effecient compression sheme to run over the indicators is then sought, hence the fingerprinting or PIP (perceptually important point)
13:58:02 <prog72> so we seek an inflationary measure or dimensionality preserving basis rotation, to be combined with a compressive scheme like principal component analysis 
13:58:48 <prog72> eg, projection to the time frequency space, and then gathering the center of masses of distinct blobs
14:00:09 <prog72> we could expect that eg, an autoencoder would have to do something similar, but when the user chooses these schemes it saves them having to be arrived at by learning
14:00:44 <prog72> ie since at the narrow bottleneck the autoencoder has to come up with some compression scheme 
14:01:50 <prog72> if you consider stacked autoencoders, then the preprocessing step is just a user defined version of an autoencoder component, the specification of which could massively reduce the training time
14:02:31 <prog72> ie, using "expert knowledge" the human can make input to avoid a large computational burden of training the net
14:03:11 <prog72> hence seeking a "fingerprit library" that does not feature learning
14:03:26 <prog72> no put intended on "feature learning"... 
14:04:09 <prog72> I guess the best i could hope for would be a good linear algebra package to define common numerical algorithms
14:04:57 <prog72> basically, part of it is a net, and thats not so interesting, but part of it is a function, like we might define using lambda calculus
14:05:24 <prog72> idk if maybe even a small restricted DSL could be used
14:07:27 <prog72> as basically the NN by having sigmoid activations is basically a really restricted dsl where you can just do floating point operations, and the various possible choices are learned by adjusting weights as doubles
14:07:58 <prog72> a better API that is perhaps less expressive, but can be more readily used to construct complex measures could be constructed
14:08:35 <prog72> eg providing different basis transformation as part of the library of composable functions as the kind of "prelude" of the dsl
14:09:17 <prog72> so eg, a moving average is expressed in a way that is more concise than just giving its corresponding NN weights 
14:10:26 <prog72> importantly, these different opperations can still be combined automaticall in a genetic algorithm, and so training and learning can be used to explore this design space just as with NN's
14:11:11 <prog72> then it seems to be something like a descision system designing queries in R
14:12:16 <prog72> in which case the library sought it some way to computationally generate statistical queries 
14:12:23 <prog72> do we have that at least?
14:21:15 <prog72> https://www.researchgate.net/profile/Sepp_Hochreiter/publication/13206493_Feature_extraction_through_LOCOCODE/links/5700e56508aea6b77469e25b/Feature-extraction-through-LOCOCODE.pdf
14:29:55 <Guest_64> New installation on macOS Catalina, via ghcup. Failing to update Cabal, build of "cabal-install" errors on Hackage.Security.Util.Lens, which it can't load as it's a "hidden module of package-security-0.6.0.0". How to proceed?
14:32:44 <phadej> Guest_64: are you trying to build `cabal-install` from source?
14:33:17 <phadej> there's no released version of cabal-install which supports hackage-security-0.6.0.0
14:38:48 <Guest_64> phadej no I don't. I installed Haskell via ghcup, then typed "cabal update", which worked. Then "cabal install Cabal cabal-install", which failed as I described. :-(
14:39:40 <monochrom> "cabal install Cabal cabal-install" means exactly "I want to build Cabal and cabal-install from source", no more no less.
14:39:54 <monochrom> And it is also completely unnecessary.
14:40:17 <monochrom> I wonder what XY problem led to this.
14:40:32 <maerwald> The assumption that cabal-install builds
14:41:21 <Guest_64> Ah... I was going to ask "how to I update GHCUP-installed Cabal v2.6.x.x to v3.0.0.0", but apparently somehow it got updated, as now it reports $ cabal --versioncabal-install version 3.0.0.0compiled using version 3.0.0.0 of the Cabal library
14:42:05 <monochrom> ghcup has defaulted to 3.0.0.0 for a long time...
14:42:05 <Guest_64> Still, when Cabal v3.1.0.0 or such is released - how do I update my installation? if I don't want to rebuild Cabal locally from sources?
14:42:23 <monochrom> Should you "update"?
14:42:33 <maerwald> Guest_64: yes, there's only one cabal-install at all times. ghcup install-cabal will just overwrite
14:43:29 <maerwald> 'ghcup install-cabal' is the equivalent of updating
14:43:33 <monochrom> IMO you should always stick to whichever version that GHC comes with. If you are not switching to a new GHC you should not switch to a new Cabal eitheer.
14:43:50 <maerwald> monochrom: but they are not really that in sync
14:44:22 <monochrom> But how many people actually need to stay absolutely bleeding edge for Cabal?
14:44:23 <Guest_64> Hmm... My system (which had a working Haskell installation) was re-imaged, then some stuff was restored from the backup. Possibly some Haskell remnants... It seems to make sense that I should wipe out ~/.cabal, ~/.local, ~/.ghcup - and redo the installation via ghcup from scratch?
14:44:39 <maerwald> monochrom: these days it sometimes ships crucial features, because v2 is still kinda shaky
14:44:47 <monochrom> Don't forget ~/.ghc
14:44:49 <Guest_64> And no, I don't feel like I must be on the Cabal bleeding edge.
14:45:04 <Guest_64> Oh yes, ~/.ghc. Thanks
14:45:21 <maerwald> be careful with wiping out ~/.local
14:45:24 <maerwald> :)
14:46:02 <MarcelineVQ> ye, would not reccomend a blind wipe of that one
14:46:38 <Guest_64> Why not? I am trying to reinstall from scratch, to ensure starting from a clean slate...?
14:47:08 <monochrom> ~/.local contains files for other software unrelated to Haskell.
14:48:21 <Guest_64> Ah. Thanks. Luckily, this is a re-imaged machine, nothing useful (yet!) in ~/.local. I'll be careful with ~/.config - already managed to put a few things in there... ;)
14:48:49 <Guest_64> BTW, is running "bootstrap-haskell" from ghcup directory (cloned from GitHub) the best way to start the installation?
14:49:09 <maerwald> It should work the same way
14:49:43 <maerwald> oh
14:49:45 <maerwald> not from github
14:49:52 <maerwald> that is a mirror (and often outdated)
14:50:24 * hackage dobutokO 0.1.0.3 - Creates the time intervals for CLI changing messages on the screen.  https://hackage.haskell.org/package/dobutokO-0.1.0.3 (OleksandrZhabenko)
14:50:42 <maerwald> Guest_64: https://www.haskell.org/ghcup/ usually has the latest bootstrap script
14:51:01 <Guest_64> Also, it seems that GHC-8.8.2 has been around for a while. I don't know how different it is from 8.6.5 - is there a reason to stick with 8.6.5, or better to go straight to 8.8.2?
14:51:08 --- mode: ChanServ set +o Sigyn
14:51:43 <maerwald> I think most things build with 8.8.2 now (except cabal-install :P)
14:53:26 <maerwald> whether you need the features... well, if you don't know, you probably don't
14:53:26 <Guest_64> Ha... cabal-install doesn't build with either 8.6.5 or 8.8.2, judging by my experience! ;)
14:54:36 <Guest_64> Features - I concur, probably I don't. But as whatever one does, it tends to pull a ****load of dependencies - I might be better off using 8.8.2? To avoid problems like mentioned above with cabal-install?
14:54:57 <merijn> what...
14:55:14 <merijn> Why would cabal-install not build with 8.6.5 or 8.8.2?
14:55:47 <maerwald> it should build with 8.6.5, but doesn't with 8.8.2 (no build plan afaik)
14:56:12 <Guest_64> merijn that I would like to know myself! But the fact is - at least on my machines it doesn't. macOS Catalina. One - has some previous Haskell installation, this one is clean (just re-imaged).
14:56:36 <Guest_64> [stepping out for a moment, will be back]
14:58:22 <Guest_64> Before I step out - a question: ghcup script from the www.haskell.org is about 75KB, while the one from the GitHub seems to be only 5KB???
14:58:53 <MarcelineVQ> That's not a question?
15:00:12 <maerwald> it should be 66.9kb
15:00:23 * hackage licensor 0.4.0 - A license compatibility helper  https://hackage.haskell.org/package/licensor-0.4.0 (jpvillaisaza)
15:00:55 <maerwald> you compared the bootstrap script with the ghcup one
15:00:59 <maerwald> those are not the same
15:01:38 <aviD> The foundation prelude looks tempting. What are all of your thoughts and experiences?
15:12:02 <merijn> aviD: My thoughts are that any prelude other than Prelude is a terrible idea
15:20:32 <maerwald> I don't understand the point of those "total" preludes. Haskell isn't total and you have to distrust everything anyway
15:21:01 <maerwald> I mean, if you have a hard requirement for your code to NEVER crash, a "total" prelude won't be enough anyway
15:21:19 <nshepperd2> safeFromJust :: Maybe a -> Maybe a
15:21:30 <maerwald> lol
15:25:45 <Cale> I've heard that some people have a positive experience with the alternative Preludes, but personally, I avoid them.
15:30:26 <suzu> it won't be enough but it is certainly helpful
15:54:21 <phadej> I/we have an own prelude in about each project
15:54:46 <phadej> but so far, I haven't found enough common things to seriously consider pulling them out into shared library
15:55:11 <phadej> prelude owned by a project feels to be a lot more flexible
15:55:22 <phadej> ... even things are repeated from project to project
15:56:18 <phadej> (these preludes are not redefining things, only collecting bits from existing libraries; and maybe adding some small things)
15:57:50 <phadej> on a project level, not re-exporting `head` is simple: try and see what breaks, if nothing breaks: profit :)
16:06:57 <dminuoso> phadej: By per project prelude, do you mean depending on base-noprelude and switching it out, or just having a per-project extra utility module?
16:07:11 <phadej> extra utility module
16:07:31 <phadej> NoImplicitPrelude works
16:08:16 <dminuoso> Ah I suppose you'd place that in default-extensions in your cabal file then.
16:09:24 * hackage reanimate-svg 0.9.7.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.7.0 (DavidHimmelstrup)
16:10:24 <phadej> yes
16:14:54 * hackage aura 2.0.5 - A secure package manager for Arch Linux and the AUR, written in Haskell.  https://hackage.haskell.org/package/aura-2.0.5 (fosskers)
16:19:39 <dmj`> nshepperd2: safeFromJust is the best function I've ever seen
16:19:45 <dmj`> made my day
16:23:36 <monochrom> @quote monochrom safeFromJust
16:23:37 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
16:23:43 <monochrom> (I was there first!)
16:23:46 <monochrom> Also...
16:23:54 <monochrom> @quote monochrom coerce
16:23:55 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
16:24:59 <ChaiTRex> Does unsafeCoerce just relabel the type while leaving the data alone?
16:24:59 <dmj`> safeId = Just  . id
16:25:12 <monochrom> Yes.
16:25:36 <monochrom> Or rather, tells the compiler to just ignore types.
16:26:10 <monochrom> Err actually relabel is more correct, e.g., there are consequences about instance selection.
16:49:47 <Guest_64> maerwald here's the listing for ghcup script:
16:49:49 <Guest_64> $ ll ~/ghcup ~/src/ghcup/ghcup ~/src/ghcup/bootstrap-haskell
16:50:01 <Guest_64> -rwxr-xr-x  1 ur20980  MITLL\Domain Users   5019 Feb 16 17:51 /Users/ur20980/ghcup*
16:50:08 <Guest_64> -rwxr-xr-x  1 ur20980  MITLL\Domain Users   5019 Feb 16 17:46 /Users/ur20980/src/ghcup/bootstrap-haskell
16:50:15 <Guest_64> -rwxr-xr-x  1 ur20980  MITLL\Domain Users  71363 Feb 16 17:46 /Users/ur20980/src/ghcup/ghcup*
16:51:14 <Guest_64> It looks like "ghcup" that one pulls via "curl" from Haskell.org/ghcup is about 5K, and it's the same as "bootstrap-haskell". I'm confused by the names.
16:54:23 <Guest_64> Also, if the "main" Haskell install was via "ghcup" - what's the best way to add Stack to it? From "haskellstack.org"? Or...?
16:55:13 <Guest_64> Also, does it make sense to do "ghcup install-cabal"? Would it add anything to the "normal" installation by "bootstrap-haskell"?
17:05:23 * hackage aura 2.0.6 - A secure package manager for Arch Linux and the AUR, written in Haskell.  https://hackage.haskell.org/package/aura-2.0.6 (fosskers)
17:27:23 <sclv> Guest_64: ghcup doesn't handle stack, you should do it independently
17:27:27 <sclv> they don't interact
17:27:38 <sclv> also the bootstrap already installs cabal afaik
17:30:25 <Guest_64> @sclv thanks, understood. Re. cabal - you mean, if I installed via bootstrap - the cabal version would be current, so I don't need to worry/upgrade?
17:30:25 <lambdabot> Unknown command, try @list
17:37:45 <monochrom> The script you got from "curl ... | sh" already does install-cabal for you.
17:38:04 <monochrom> Or rather, that command itself.
17:39:33 <monochrom> In fact I would think it has enough output messages to tell you that much.
17:39:53 <monochrom> Why can't people read when they're outside "chat rooms"?
17:41:13 <Guest_64> > Perhaps it's the matter of interpreting the output? Especially if the overall process aborts with errors?
17:41:15 <lambdabot>  <hint>:1:25: error: parse error on input ‘of’
17:41:43 <Guest_64>   Why can't people read when they're outside "chat rooms"?
17:41:49 <Guest_64> Perhaps it's the matter of interpreting the output? Especially if the overall process aborts with errors?L
17:42:43 <monochrom> Then you should have asked about that error in the first place.
17:44:30 <monochrom> Bah, I should not be so worked up on this.
17:44:34 <Guest_64> Oh, but I did - that was my first message here this evening.   Not to mention that the difficulty is compounded by the overall extreme fragility of the API, which causes the weirdest mix-and-match failure of installs that depend on multiple packages that in turn depend on multiple packages, and so on. 
17:47:24 * hackage net-mqtt 0.6.2.3 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.6.2.3 (dustin)
18:02:58 <Nolrai> If `op` is strict and associtive, do I want to use `foldr op empty` or `foldl' op empty`? Or does it not matter?
18:03:16 <monochrom> foldl' definitely.
18:03:49 <monochrom> foldr is best for non-strict-on-the-right operators such as (:)
18:04:43 <Nolrai> Thanks!
18:52:17 <boxscape> % class (A :: Constraint)
18:52:17 <yahb> boxscape: ; <interactive>:188:7: error: Malformed head of type or class declaration: (A :: Constraint)
18:52:18 <boxscape> but why
19:15:53 <ChaiTRex> C
19:15:55 <ChaiTRex> C
19:30:59 <koz_> In megaparsec, is there a way to say 'try this parser; if it works, return its result, otherwise, use this default value'?
19:32:53 * hackage libltdl 0.1.1.2 - FFI interface to libltdl  https://hackage.haskell.org/package/libltdl-0.1.1.2 (GeoffreyMainland)
19:33:04 <reallymemorable> i know i am doing something dumb, but I added `import Database.PostgreSQL.Simple` to a script and I am getting a “could not find module…” error
19:33:22 <koz_> reallymemorable: What do you mean by 'a script'?
19:33:27 <reallymemorable> a .hs file
19:33:34 <koz_> How are you compiling it?
19:33:38 <reallymemorable> stack ghci
19:34:01 <Axman6> have you also added postgresql-simple as a dependency?
19:34:02 <koz_> Do you have the library that module comes from in your cabal file?
19:34:11 <koz_> Axman6: I owe you an axe^Wsoda?
19:34:32 <Axman6> ?
19:34:47 <koz_> We said the same (or near enough the same) thing simultaneously.
19:34:51 <Axman6> why would you give me one of my own limbs? I am literally made of axes
19:35:06 <koz_> Don't you want more of yourself?
19:35:17 <reallymemorable> oh god
19:35:19 <Axman6> I go through keyboards like nobody's business
19:35:25 <koz_> Axman6: Chairs too I bet.
19:35:27 <reallymemorable> i deserve some mythical punishment
19:35:32 <reallymemorable> thank you
19:35:44 <koz_> reallymemorable: It's fine, I've done sillier things.
19:35:47 <Axman6> hacking is a much more litertal term for me and my kin
19:36:51 <koz_> Axman6: Lol.
19:37:03 <koz_> Code interviews must be real fun.
19:37:12 <Axman6> I'll never forget that guy
19:37:23 <Axman6> his name was reallymemorable
19:38:35 <Clint> how will you know if you've forgotten him?
19:38:50 <Axman6> forgotton who?
19:38:54 * Clint nods.
19:38:57 <Axman6> forgotten*
19:39:09 <Axman6> Thank you for playing along
19:39:13 <koz_> :D
19:41:23 * hackage network-protocol-xmpp 0.4.9 - Client library for the XMPP protocol.  https://hackage.haskell.org/package/network-protocol-xmpp-0.4.9 (StephenWeber)
20:14:47 <boxscape> % type family Foo (a :: forall t . t) where Foo a = Int
20:14:47 <yahb> boxscape: ; <interactive>:193:47: error:; * Expected kind `forall t. t', but `a' has kind `k0'; * In the first argument of `Foo', namely `a'; In the type family declaration for `Foo'
20:14:49 <boxscape> why?
20:14:54 <boxscape> can you not have higher rank type families?
20:25:13 <glguy> Box
20:25:28 <glguy> boxscape: what are you trying to do? I can't guess what that means
20:27:06 <boxscape> glguy well, I'm just trying to isolate the issue I have with a larger problem I'm trying to solve, which is writing an induction scheme for a certain type
20:29:26 <boxscape> glguy this is an example that's slightly closer to what I'm actually doing but I'm not sure if it's actually what I want 
20:29:37 <boxscape> % type family RuleFam (p :: forall t t' . Rule t t' -> Type) (r :: Rule t1 t1') :: Type
20:29:37 <yahb> boxscape: ; <interactive>:194:41: error: Not in scope: type constructor or class `Rule'; <interactive>:194:66: error: Not in scope: type constructor or class `Rule'
20:29:57 <boxscape> trying to make any instance of this type family will result in the same error
20:37:20 <sandman13> Hi, what is the memory requirement for haskell-ide-engine?
20:37:28 <Axman6> lots
20:37:47 <sandman13> I have 4GB of system memory and I am failing to build it
20:38:01 <boxscape> huh apparently I had a tab open about a ghc issue titled "Cannot use higher-rank kinds with type families", go figure
20:39:01 <Axman6> that;s probably not enough RAM
20:39:32 <sandman13> are there any lightweight alternatives?
20:39:55 <Axman6> ghcid maybe? not sure what the status of that is these days
20:41:38 <Axman6> but, compiling any non-trivial Haskell project usually requires a fair amount of RAM. 
20:41:46 <Axman6> 4GB is very small these days
20:43:21 <sandman13> why so much RAM usage?
20:45:28 <Axman6> because compiling programs is hard, and GHC is a very advanced compiler that does a lot of work.
20:46:31 <koz_> And it's not been written with memory use minimization in mind.
20:46:47 <koz_> Also, it's not necessarily GHC's fault - some Haskell projects are inherently more memory-hungry than others.
20:46:54 * koz_ looks at ShellCheck and Pandoc.
20:48:07 <sandman13> since I can't build it, I can't use it 
20:59:26 <sm[m]> 4G would normally be enough for most things I think. -j1 is one way to use less..
21:00:12 <sm[m]> But ghcid is probably what you need, anyway
21:00:54 <Axman6> often rurunning the build (possibly a few times) will let the compile finish, it should usually make some progress each time, unless it fails to link
21:01:29 <koz_> Depending on how little memory you have, you might have to rururururururun.
21:01:42 <Axman6> rerunning*
21:01:51 <sm[m]> @quote faq lowmem
21:01:51 <lambdabot> No quotes for this person. My brain just exploded
21:01:53 <koz_> Axman6: rurunning is better.
21:02:56 <MarcelineVQ> Axman6: that's fairly frustrating actually, and what I would assume is low hanging fruit, that you can build incrementally yourself for lower memory use each time but if you try to build all at once it won't neccesarily release memory for things that are completed
21:03:55 <Axman6> ¯\_______(ツ)_______/¯
21:05:20 <sandman13> okay
21:05:24 <sandman13> I will give it a shot
21:05:37 <sandman13> it == ghcid
21:25:43 <heath> this is the table i was asking about awhile ago https://gist.github.com/graninas/1b7961ccaedf7b5cb92417a1599fdc99
21:54:57 <olligobber> is there a class for categories where all morphisms are isomorphisms?
21:58:41 <olligobber> I guess I don't really need it
22:06:35 <sim590> Axman6: You might be interrested in https://github.com/sim590/emo.
22:10:10 <Axman6> (っ•́｡•́)♪♬
22:14:24 <Axman6> sim590: https://cutekaomoji.com/about/ might be useful for expanding the répertoire :)
22:18:38 <d12frosted> Hi everyone. Is it possible to implement a function of type (a -> f b) -> f (a -> b) (with some constraint on `f`)? I tried hoogling, but found only one irrelevant function assemble (from countable package).
22:22:04 <Axman6> @djinn (a -> Maybe b) -> Maybe (a -> b)
22:22:04 <lambdabot> f _ = Nothing
22:24:33 <sim590> Axman6: oh nice! There's a csv in the repository, so anyone can just append to it also! hehe. One drawback however is that if there's just too many emotes, the program cuts the list for now. ヾ(-_- )ゞ
22:24:42 <d12frosted> Axman6 what does that solution mean? :)  
22:25:35 <d12frosted> Does that mean that solution for Maybe is impossible?
22:25:47 <xavo[m]> I've actually tried to write this before (don't remember why) and I think it's generally impossible in an interesting way, you'd need to be able to get data from the `f` out before the function's actually called
22:26:03 <Axman6> d12frosted: looks like it :'(
22:26:07 <dibblego> f ~ Identity
22:26:19 <xavo[m]> agreed dibblego
22:26:39 <Axman6> f = coerce
22:26:39 <dibblego> or ((a -> f b) -> f a -> f b) -> (f (a -> b) -> f a -> f b)
22:26:50 <Axman6> (actually safe)
22:26:52 <dibblego> you probably want it because of entanglement with IO
22:28:03 <xavo[m]> or like something dumb, you could implement it for NonEmpty I guess (\f -> (head . f) :| [])
22:30:00 <d12frosted> xavo[m] yes, it feels like I need to extract data from `f` before passing it to the function. So I though using >>= will somehow help me. But not. It feels so familiar. Like we have <*> which can work with functions in the context. We have bind which also reminds about what I try to implement. 
22:30:27 <Axman6> you're basically asking to go from the power of Monad to the power of Applicative
22:31:21 <Axman6> in fact I think that if you could write that the you would be able to make any Applicative a Monad... but proving that is left as an exercise for the reader
22:31:23 <d12frosted> Yeah, because with bind I have (a -> f b) -> f a -> f b, so I want to go from f a -> f b to f (a -> b), which kind of reminds me of monoidal functors,...
22:31:51 <d12frosted> > but proving that is left as an exercise for the reader
22:31:54 <lambdabot>  error:
22:31:54 <lambdabot>      • Variable not in scope:
22:31:54 <lambdabot>          but
22:31:54 <d12frosted> haha, a good one
22:34:50 <Axman6> @djinn (a -> Reader String b) -> Reader String (a -> b)
22:34:51 <lambdabot> Error: Undefined type Reader
22:35:19 <Axman6> huh, that would just be flip (roughly)
22:36:31 <xavo[m]> interesting that you can go the other way freely, although that makes sense since Monad implies Applicative
22:37:08 <xavo[m]> % :t \f -> fmap (f $)
22:37:08 <yahb> xavo[m]: Functor f => (a -> b) -> f a -> f b
22:37:29 <xavo[m]> messed that up but it's something like that
22:38:29 <xavo[m]> oh, \ff x -> fmap ($ x) ff
22:38:48 <d12frosted> wow
22:38:55 <d12frosted> \ff x -> fmap ($ x) ff :: Functor f => f (a -> b) -> a -> f b
22:39:07 <dibblego> @type \x a -> x <*> pure a
22:39:09 <lambdabot> Applicative f => f (a -> b) -> a -> f b
22:39:47 <dibblego> @type sequence :: Traversable f => f (a -> b) -> (a -> f b)
22:39:49 <lambdabot> Traversable f => f (a -> b) -> a -> f b
22:40:02 <d12frosted> so many connecting dots :)  
22:40:56 <xavo[m]> oh, nice
22:44:54 <xavo[m]> (mine's `flap` in purescript's Data.Functor, btw, haven't seen it in haskell)
22:47:49 <d12frosted> in my understanding, there is not bijection between f (a -> b) and (a -> f b) :(  
22:48:13 <d12frosted> I mean, having \ff x -> fmap ($ x) ff you can't get it the other way around
22:49:14 <Axman6> I wonder what happens if f is a Comonad
22:50:21 <xavo[m]> lol you could do like
22:50:21 <d12frosted> extend :: (w a -> b) -> w a -> w b 
22:51:02 <xavo[m]> \wab a -> wab $> (extract wab) a
22:51:24 <xavo[m]> I guess ¯_(ツ)_/¯
22:52:04 <Poscat[m]> Does haskell-ide-engine support c2hs files ?
23:01:16 <d12frosted> Ok, I faced this problem while trying to put 'effectful' functions inside data type. E.g. `data SomeData = SomeData String (Int -> IO Bool)`. Having IO here is not good, as I want to limit it to specific operations. So I tried several approaches
23:02:17 <d12frosted> 1. `data SomeData = SomeData String (forall f. Constraint f => Int -> f Bool)` which creates problems when later because of quantification
23:02:46 <d12frosted> 2. `data SomeData f = SomeData String (Int -> f Bool)`, which means that all users now deal with f :(  which is not bad per-se, but noisy
23:03:37 <d12frosted> 3. `data SomeData = SomeData String (Int -> Bool)`, so with `(a -> f b) -> f (a -> b)` I can easily lift `SomeData` to `f SomeData` :)  
23:05:39 <xavo[m]> I'm confused on your last one, how is SomeData ~ a -> f b?
23:10:07 <d12frosted> well, if you implement someF :: Int -> IO Bool, then using this special lift you can fmap (or <*> with multiple such fields)
23:11:03 <d12frosted> So it's like SomeData "Hello" <$> lift someF, where someF :: Int -> IO Bool, lift :: (a -> f b) -> f (a -> b)
23:11:11 <d12frosted> Could be a decent trick lol
23:11:57 <xavo[m]> huh, ok
23:12:58 <xavo[m]> this also looks like a good use case for the free monad, but idk enough about it to say that for sure
23:13:12 <xavo[m]> in terms of you wanting to keep a limited set of ops, at least
23:15:06 <d12frosted> If I understand you properly, this is what I wanted to do. But using polysemy and semantics they provide
23:15:13 <d12frosted> I mean, semantics + effects
23:16:23 <d12frosted> But it seems that it's best to stick with (2) and provide 'constructors' that give the necessary constraints 
23:19:41 <xavo[m]> ah alright
23:26:45 <zincy_> Is it fair to say that type declarations do not by themselves affect runtime performance since types are erased at runtime.
23:27:19 <zincy_> Asking this because someone asked me if newtype declarations have a runtime impact on performance.
23:28:23 <xavo[m]> newtypes have the same runtime representation as the type they're wrapping, iirc
23:32:20 <xavo[m]> so just wrapping a type up shouldn't do anything unless you count the noops that come from wrapping and unwrapping
23:32:42 <xavo[m]> but don't quote me on that loo
23:32:43 <xavo[m]> *lol
23:34:46 <zincy_> Thanks
23:35:07 <boxscape>  zincy_ type declarations can have an impact on runtime performance - e.g. if you have something like "a = 1 + 2" then you can calculate it immediately if you know "a :: Int", but you can't if "a :: Num a => a"
23:35:37 <boxscape> or rather you only have to calculate it once if the type is monomorphic
23:35:44 <boxscape> that's the point behind the monomorphism restriction
23:37:12 <boxscape> that's because "a :: Num a => a" is, at runtime, a function that's takes a Num dictionary, but "a :: Int" is just a value
23:40:34 <boxscape> newtypes don't have a runtime impact, but I'm not sure how they relate to the question about type declarations
23:43:09 <dminuoso> boxscape: I think the for the core question that answer is misleading.
23:43:42 <boxscape> I suppose I'm not really sure what the core question is given that I can't see the connection between type declarations and newtypes here
23:44:03 <dminuoso> I suppose that's a fair point
23:44:14 <boxscape> or wait
23:44:30 <boxscape> I think I misinterpreted "type declaration" to mean "type annotation"
23:44:50 <xavo[m]> same here, at first
23:44:56 <xavo[m]> the bit about newtypes helped
23:49:49 <MarcelineVQ> there isn't quite a 'type declaration' in the first place. there's a data declaration, a newtype declaration, a type synonym declaration, a type signature declaration, etc...
23:51:09 <MarcelineVQ> here's some examples https://hackage.haskell.org/package/template-haskell-2.15.0.0/docs/Language-Haskell-TH.html#t:Dec
23:55:17 <zincy_> How do you write a function which matches any newtype and just operates on the value inside?
23:55:27 <zincy_> Is that just a functor?
23:55:27 <boxscape> MarcelineVQ if you look at the ghc source code rather than template haskell, there's a constructor for "type and class declarations" https://github.com/ghc/ghc/blob/master/compiler/GHC/Hs/Decls.hs#L142
23:55:38 <dminuoso> zincy_: You cant.
23:55:56 <dminuoso> zincy_: Or rather, well you can actually if you write it polymorphically over Coercible
23:56:19 <dminuoso> f :: Coercible a T => a -> U; f x = let x' = coerce x in ...
23:56:31 <dminuoso> But for so many reasons Id say this is a terrible idea
23:56:50 <zincy_> dminuoso: interesting
23:57:00 <zincy_> So what is it about other languages that allow this? 
23:57:06 <zincy_> What do they do differently
23:57:11 <boxscape>  other languages have newtypes?
23:58:04 <zincy_> boxscape: Not that I have heard of
23:58:41 <boxscape> zincy_ hm, then I'm not sure what your question is - you said "write a function that matches any newtype" and then "other languages that allow this"
23:59:01 <xavo[m]> purescript has Data.Newtype with a `Newtype t u` class + `wrap :: t -> u` and `unwrap :: u -> t`, but instances for that have to be written by hand, it's not automatic or anything
23:59:34 <xavo[m]> don't actually know why you would want that though lol
