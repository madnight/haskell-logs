00:00:19 <jsomedon> hmm okay
00:00:20 <c_wraith> g is being applied to a value.  That means it must be a function, and that's known statically.
00:00:30 <Axman6> hugbubby: That isb't an op[t9imisation that is done, we have a mkuch cooler optimisatio0n called deforre3station that makes the list disappear completely - the data in the list is only generated right as it is consumes
00:00:31 <jsomedon> that's how I understood too
00:00:34 <c_wraith> Oh, wait.
00:00:42 <c_wraith> It's talking about (g x), not g
00:00:49 <jsomedon> yeah
00:01:02 <c_wraith> (g x) can be any type at all, so long as f takes an argument with that type.
00:01:02 <jsomedon> so?
00:01:23 * hackage hkgr 0.2.5.2 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.5.2 (JensPetersen)
00:01:57 <jsomedon> hmm so u mean maybe (g x) turns out be another function
00:02:09 <c_wraith> :t let twice f x = f (f x) ; add x y = x + y in twice . add
00:02:10 <lambdabot> Num t => t -> t -> t
00:02:55 <c_wraith> > let twice f x = f (f x) ; add x y = x + y in (twice . add) 3 17
00:02:57 <lambdabot>  23
00:11:09 <jsomedon> hmm okay
00:19:26 <jsomedon> since haskell functions are lazily evaluated
00:19:52 <jsomedon> say if I have a function returning multiple values
00:20:13 <jsomedon> is that function essentially same as the generator functions in python/javascript?
00:21:10 <jsomedon> do haskell even need features like generator function
00:22:57 <jle`> jsomedon: yeah, haskell laziness works a lot like pure generators in python
00:23:09 <jle`> in many situations
00:23:39 <jle`> however laziness isn't as useful for 'effectful' generators, so sometimes we do use explicit generators for those
00:23:56 <jle`> like producing new items based on IO actions, like user input or data from disk
00:24:21 <jle`> but most usage of 'pure' generators in python, we would do it using lists probably
00:25:03 <jsomedon> I see, thank you :)
00:25:24 <jle`> @let fibGen = go 0 1 where go x y = (x+y) : go y (x+y)
00:25:27 <lambdabot>  Defined.
00:25:31 <jle`> > take 10 fibGen
00:25:34 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
00:25:46 <jle`> so that's a classic example of something you might write using generators in python
00:26:16 <jle`> here translated into a tail-recursive list producer
00:27:28 <jsomedon> I see
00:27:40 <jle`> in python you might write it as: def fibGen(): x = 0; y = 1; while true: yield (x+y); x,y = y,x+y
00:27:48 <jle`> me trying to crunch it into one line heh
00:27:55 <jsomedon> yeah hah
00:28:01 <jle`> but i hope the idea is clear
00:28:06 <jsomedon> yeah very clear
00:28:28 <jle`> by using 'take 10' we control how many elements we want to use
00:28:40 <jle`> or how many yielded items we want to extract
00:29:04 <jle`> but this falls apart when your 'yielded' items come from I/O or other sort of effects
00:29:17 <jle`> so there is still a role for explicit 'generators' in haskell
00:29:43 <jsomedon> what do u mean by explicit generator in haskell? I googled and nothing showed up
00:29:57 <jsomedon> a special syntax?
00:29:57 <jle`> basically i mean a generator-like data type
00:30:05 <jsomedon> oh
00:30:05 <jle`> a data type that represents a generator
00:30:12 <jle`> with specific yield/etc. structure
00:30:23 <jle`> as opposed to just using a lazily linked list, which can be considered an implicit generator
00:30:30 <jsomedon> can I have a simple example?
00:30:50 <jle`> well the fibGen above is what i wouild call an implicit generator.  it works like a generator but you never actually directly write yield
00:31:02 <jle`> it all works "magically" by the lazy (:)
00:31:07 <jsomedon> yeah
00:31:27 <jsomedon> so u mean `yield` is a valid syntax in haskell??
00:31:30 <jle`> but if you, say, want to yield lines you get from stdin
00:31:47 <jle`> jsomedon: ah no, i'm saying that it can be written within the language
00:31:53 <jle`> as a user-made construct
00:31:57 <jsomedon> okay
00:32:13 <jle`> like for example the 'conduit' library has a data type, Conduit
00:32:22 <jle`> that has a `yield` function
00:32:39 <jle`> so say, to define a generator that yields lines from stdin, you would write:
00:32:44 <jle`> linesFromStdin = do
00:32:51 <jle`>   x <- liftIO getLine
00:32:53 <jle`>   yield x
00:32:55 <jle`>   linesFromStdin
00:33:14 <jle`> or something similar ... like linesFromStdin = forever (do x <- liftIO getLine; yield x)
00:33:30 <jle`> here yield isn't a language keyword, it's just a normal function
00:33:36 <jsomedon> oh
00:33:40 <jle`> but the Conduit/Generator data type knows how to impliment it
00:33:43 <jle`> to give the desired behavior
00:34:05 <jle`> so it's not a built-in but a library-defined thing
00:34:30 <jle`> which is kind of the situation with a lot of things in haskell, heh
00:34:36 <jsomedon> I'm really curious how that's implemented, maybe using some language built ins that are already lazy, like (:)?
00:34:43 <jle`> it doesn't use laziness
00:34:51 <jle`> but most things like this use continuations
00:35:11 <jle`> also, remember (:) isn't necessarily a language built-in
00:35:20 <jle`> you can make your own list data type and it will behave no differently than the built-in list
00:35:23 <jle`> with lazy cons
00:35:36 <jle`> data List a = Nil | Cons a (List a)    -- has all the same laziness, with Cons vs. (:)
00:36:27 <jsomedon> uhm, so maybe I should say constructor is evaluated lazily therefore : is lazy
00:36:39 <jle`> but you can also implement effectful generators with recursive data types as well :) it's just a little more complicated than lists
00:38:19 <jle`> if you want to see a simple implementation of an effectul generator, check out the list-transformer library
00:38:24 * hackage laop 0.1.0.7 -   https://hackage.haskell.org/package/laop-0.1.0.7 (bolt12)
00:39:06 <jsomedon> this one? https://github.com/Gabriel439/Haskell-List-Transformer-Library
00:39:24 <jle`> https://hackage.haskell.org/package/list-transformer-1.0.6/docs/List-Transformer.html
00:39:30 <jle`> that might be it, yeah
00:39:38 <jle`> its interface is a little different than i wrote up there though
00:40:23 <jle`> you would write it as ... linesFromStdin = liftIO getLine <|> linesFromStdin, i think
00:40:24 <jsomedon> but this one also uses 'continuation'? btw what is continuation, another syntax?
00:40:35 <jle`> this one doesn't use continuations directly, it's just a recursive data type
00:41:33 <jle`> continuation here is a general term for 'using a function to handle the (future) result' kinda; it's a thing in all programming languages pretty much
00:41:56 <jsomedon> https://wiki.haskell.org/Continuation  <-- is this continuation the continuation we are talking about?
00:43:02 <jle`> hm, that one gets really specialized
00:43:12 <jle`> i'm talking about the general idea, like https://en.wikipedia.org/wiki/Continuation
00:43:29 <jsomedon> I was reading through this wiki, just the description looks very much like some low level stuff
00:45:09 <jle`> but don't worry about it too much if you're just getting started :)
00:45:18 <jle`> these are somewhat late intermediate/advanced topics
00:46:34 <jsomedon> haha alright
00:46:39 <opticblast> jms
00:47:49 <opticblast> huh. xmonad has a weird behavior when switching workspaces after moving the mouse
00:48:45 <opticblast> if you focus on the left window, then switch workspaces, move your mouse to the right, and switch back, you'll remain focused on the left window even if you jiggle the mouse over the right pane
00:49:25 <opticblast> greater than minimum astonishment imo, but maybe there's a good reason for it
00:55:53 <[Leary]> opticblast: Focus is intended to be controlled principally through the keyboard, and hence has little relation to pointer position. It would be very troubling if xmonad refocused every time the mouse jittered.
01:06:54 <MasseR> opticblast I'm not exactly following your example, but have you tried the `focusFollowsMouse` setting?
01:07:38 <opticblast> focusFollowsMouse is true in my config
01:09:25 <opticblast> Hm. I see. Whenever you use the keyboard to move focus away from the window over which the cursor is, jittering the mouse doesn't change that.
01:10:42 <opticblast> It wouldn't make any sense for workspace switching to violate that pattern.
01:39:18 <svipal> yo
01:39:26 <svipal> ran into a weird situation
01:39:28 <svipal> doing this
01:39:33 <svipal> https://www.codewars.com/kata/52423db9add6f6fc39000354/train/haskell
01:40:03 <svipal> I solved it, runs fine on my computer, but it's too slow to actually attempt on the server
01:41:02 <svipal> So, I tried to optimize it. Here's the code : https://pastebin.com/Se2b7JjV
01:41:21 <svipal> profiled it, most of the time is spent on lookup
01:42:09 <svipal> so I thought, let's replace my custom function (!.) which gives 1 when lookup gives nothing and the real value when lookup gives Just value, by the one provided by Map, findElemByValue
01:42:16 <svipal> findWithDefault*
01:42:32 <svipal> but when I do that, it becomes slow to a crawl. What gives ?
01:44:48 <svipal> woops
01:44:48 <svipal> https://pastebin.com/MDFeR4kN
01:44:58 <svipal> ^ this is the code that works in the browser
01:49:11 <svipal> Hahahah I found out
01:49:13 <svipal> nvl
01:49:47 <juri_> I've got something slightly more boring. how do i escape a bytestring so it becomes a javascript string?
01:49:58 <juri_> as in, escape the contents?
01:50:53 <svipal> (I was supplying the wrong default)
01:51:08 <LysergicDreams> juri_: Are you using aeson?
01:51:17 <juri_> LysergicDreams: nope.
01:51:36 <juri_> I'm a SNAP application that just converted away from Strings.
01:53:32 <LysergicDreams> juri_: Ah, well the easiest way is to just pass it to Data.Aeson.encode
01:55:51 <LysergicDreams> If you want to avoid the dependency, I think the 2nd easiest would be to work with a Text so you can use it's replace function to escape whatever needs escaping, then add the double-quote prefix & suffix, and then convert it into a bytestring.
02:00:11 <juri_> yeah, trying to make bytestring a member of ToJSON seems weird.
02:00:36 <merijn> Easy, just encode base64
02:01:18 <juri_> then my app would need to decode it. :P
02:01:32 <merijn> Well, yes
02:01:40 <merijn> Because you can't put bytestrings into JSON
02:01:57 <juri_> my app expects a quoted javascript string. not rocket science. :)
02:02:19 <merijn> juri_: That's wrong, though, since you can't put all bytestrings into JS strings
02:02:32 <LysergicDreams> Ah I just assumed there was a ByteString instance, sorry
02:03:46 <LysergicDreams> For non-text strings, I also base64 encode it :P
02:04:20 <juri_> I really don't want to write javascript today. :P
02:04:43 <LysergicDreams> I used Elm :D
02:05:27 <Rembane> juri_: Are your ByteStrings ever Text? 
02:06:27 <juri_> Rembane: no, but things sent along side them are Text.
02:06:53 <Rembane> juri_: Got it, can you use Text instead of ByteString? 
02:07:05 <juri_> Yes.
02:07:41 <Rembane> juri_: Then do that, Aeson works well with Text. 
02:08:10 <juri_> ... then don't i still have to do something to make Text a member of some aeson typeclass?
02:08:35 <LysergicDreams> Text already has ToJSON instance
02:08:51 <juri_> Oh. well then, i'll give that a shot.
02:09:53 <juri_> It's about time me and aeson make friends.
02:10:05 <jsomedon> are function arguments evaluated lazily as well? so say I only have line of code like `supposedToBe101 = incrementBy1 secretlyLaunchAtomBombThenReturnInteger100` then do the world get bombed?
02:10:39 <merijn> jsomedon: That can't happen, because secretely launch bombs would require IO :p
02:11:49 <jsomedon> ah yeah, I just wanna make sure if the argument gets evaluated on this line of code or not
02:12:47 <jsomedon> was trying to makeup some arg that prints something and return, so I could try that in repl, but not sure how to do that
02:12:47 <Cale> jsomedon: nothing gets evaluated by merely making a definition. If supposedToBe101 is evaluated, then incrementBy1 will be evaluated, and only if it pattern matches on its argument will secretlyLa... be evaluated, and that will be evaluated at most once.
02:13:03 <jsomedon> Cale: I see
02:13:40 <Cale> The one exception to let bindings causing evaluation is when they contain bang patterns
02:13:54 <Cale> let !foo = ...  will secretly turn into case foo of ...
02:14:04 <Cale> er, rather
02:14:08 <merijn> Cale: Pretty sure nothing requires it be evaluated at most once
02:14:08 <Cale> case ... of foo -> ...
02:14:32 <Cale> merijn: Well, under lazy evaluation, it would be evaluated at most once
02:14:43 <merijn> But Haskell isn't lazy :p
02:15:07 <Cale> GHC tends not to evaluate things more often than lazy evaluation would
02:15:32 <merijn> Sure, but let's clearly distinguish when we're talking about Haskell and "subtle implementation details regarding GHC" :)
02:15:44 <Cale> I suppose that's fair
02:16:09 <merijn> And even GHC isn't guaranteed to be lazy, since there's all sorts of support for evaluating stuff multiple times if it's deemed cheap enough
02:16:27 <merijn> The whole white/grey/black holing distinction, etc.
02:16:42 <jsomedon> is there anyway I can write a function f so that, f returns some value, but also does some side effect like print something?
02:17:09 <merijn> jsomedon: Yes, no, maybe. Depending on what you mean and how much you like making yourself suffer
02:17:21 <Cale> jsomedon: It's possible using unsafePerformIO / Debug.Trace.trace
02:17:42 <Cale> But that's not the normal way of doing things
02:17:57 <Cale> If you want to understand what's getting evaluated when, trace is useful though
02:18:03 <jsomedon> ah
02:18:08 <merijn> s/not the normal way/if you do thing this way, prepare for things to fuck up in confusing ways and it'll be your own fault
02:18:16 <jsomedon> what is that trace thing? Cale 
02:18:28 <Cale> :t Debug.Trace.trace
02:18:30 <lambdabot> String -> a -> a
02:18:53 <Cale> trace msg x  will evaluate to x  and when it is evaluated, prints msg
02:19:01 <jsomedon> oh
02:19:03 <jsomedon> nice
02:19:33 <Cale> A usual nice trick for using it is to add a False guard to the top of your function definitions
02:19:59 <Cale> foo x y z | trace (show ("foo",x,y,z)) False = undefined
02:20:18 <svipal> optimizing  is hard as balls
02:20:19 <jsomedon> uh, what is that | in between?
02:20:23 <Cale> That's a guard
02:20:34 <jsomedon> ah the one appears on second line?
02:20:44 <jsomedon> but here it's wrote on singline
02:20:54 <jsomedon> single line
02:21:01 <Cale> There's no requirement to have a newline before the guard, but yeah
02:21:21 <Cale> The idea here is that this guard always fails, but as it does so, it prints the arguments that foo was applied to
02:21:49 <Cale> handy trick if something is going wrong with a function but you're not certain what arguments it was applied to in the actual running program
02:22:22 <jsomedon> :t show
02:22:23 <Cale> (which lets you then go back to a more usual style of debugging by evaluating things by hand and seeing what's not producing the expected result)
02:22:24 <lambdabot> Show a => a -> String
02:22:54 * hackage ghc-check 0.1.0.0 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.1.0.0 (PepeIborra)
02:28:22 <jsomedon> Cale: so, in ur guard example, when this foo function gets called, the first guard predice `trace show... False` gets evaluate to False so the `undefined` never gets returned, but it still prints out the message, which is `"foo" x y z`?
02:28:39 <jsomedon> *predicate*
02:29:25 <svipal> is there anyway to parallelize mapWithKey ?
02:30:40 <svipal> doesn't seem so from it's definition, it's doubly recursive
02:30:48 <svipal> will try to use toList/fromList
02:33:13 <jsomedon> is 'thunk' another name of 'closure'?? 
02:33:19 <Cale> jsomedon: Yeah, it'll print out a tuple ("foo",x,y,z)
02:33:43 <Cale> jsomedon: Well, a thunk is a type of closure that's used to represent expressions that have yet to be evaluated at runtime
02:35:31 <jsomedon> so for a lazy language, a closure is a thunk, yes?
02:35:37 <Cale> In GHC, thunks are generally pointers to code that first rewrites the pointer to point at a short piece of code that (typically) throws an exception indicating that you're in an infinite loop, then computes the value of the given expression, and then rewrites the pointer to point at a short piece of code which will return the already computed value immediately
02:36:28 <jsomedon> ha
02:36:44 <Cale> Not all closures are thunks, there are several closure types in GHC
02:38:50 <Cale> It's uncommon to have to think at that level though. Usually, even when thinking about performance issues, I'm usually thinking in terms of expressions being rewritten, or at least expression-graphs being rewritten.
02:39:18 <jsomedon> was just curious :-p
02:40:16 <tomjaguarpaw> Does anyone else find the stackage.org Haddock docs extremely slow to load
02:40:44 <Cale> There are closure types for heap allocated functions, and partially applied functions, and special variations on these
02:41:12 <Cale> tomjaguarpaw: Yeah, I'm always annoyed whenever hackage is down and have to use them
02:43:09 <MasseR> `nix-shell -p "haskellPackages.ghcWithHoogle (h: [h.servant])" --run $SHELL` <3
02:46:12 <Cale> --run "hoogle server"
03:38:24 <svipal> I've reached a point where I can't optimize my code further...
03:38:55 <svipal> I'm aware of other approaches like using a comonad, but I wish I could just optimize my current solution since it just works
03:39:04 <svipal> if anyone's up for a challenge
03:39:15 <svipal> https://www.codewars.com/kata/52423db9add6f6fc39000354/train/haskell
03:39:31 <svipal> Or to help a poor soul that spent way too much time optimizing a code that works
03:39:32 <svipal> the code :
03:39:58 <svipal> https://pastebin.com/c4S5T20B
03:40:53 * hackage saltine 0.1.1.0 - Cryptography that's easy to digest (NaCl/libsodium bindings).  https://hackage.haskell.org/package/saltine-0.1.1.0 (amx)
04:41:48 <jsomedon> what's the difference between just typing `let a = 1` and `a = 1` in ghci?
04:42:38 <jsomedon> I thought `let` must come with `in` together
04:43:18 <Rembane> jsomedon: The difference is four characters: "let ". In ghci you are working in a monad with do-notation which is why you get the interesting syntax.
04:45:46 <jsomedon> okay
04:46:03 <jsomedon> so only in ghci, they behave the same way
04:46:16 <__monty__> Yeah, the latter's special cased in ghci.
04:56:26 <jsomedon> with just `x = 100` on ghci, when I `:sprint x` I get `x=_`; after typing `x` on ghci, I expect `:sprint x` to print `x=100` but it still prints `x=_`?
05:12:24 * hackage servant-subscriber 0.7.0.0 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.7.0.0 (eskimo)
05:18:51 <jgt> is there a way to derive a list of data constructors without using `enumFrom`?
05:19:58 <jgt> I basically just want to say "give me a list of some type's constructors" in whatever order
05:21:54 * hackage aeson-combinators 0.0.1.0 - Aeson combinators for dead simple JSON decoding  https://hackage.haskell.org/package/aeson-combinators-0.0.1.0 (MarekFajkus)
05:23:52 <jgt> oh, looks like I can use minBound
05:36:52 <zincy_> How do you write a Servant FromHTTPApiData instance for a sum type?
05:37:03 <zincy_> Which just has nullary data constructors
05:37:37 <zincy_> Would you just pattern match on the Text values which correspond to the name of the data constructors
05:44:53 <zincy_> Oh Data.Text has readEither, well that was easier than I thought!
05:45:13 <zincy_> Maybe I should have more confidence in myself :/
05:56:14 <jollygood2> hi. how can I avoid printing of this exception, that has no valuable information for the user? do I have to manually catch it? <stdin>: hGetLine: end of file
05:57:30 <Rembane> jollygood2: I don't think you can catch it, but you can check if you are at end of file before you run hGetLine. 
06:02:09 <jollygood2> I am just calling getLine once, which blocks. user can send EOF or press C-c after getLine already blocks. so I don't think check would do anything?
06:08:31 <Rembane> jollygood2: Got it, after reading what you asked once more and thinking a bit I found catch which lets you run an instruction and catch errors: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:catch
06:09:19 <Rembane> jollygood2: I think you want to catch an IOError.
06:10:43 <adamShimi> Hi everyone.
06:11:00 <adamShimi> I have a question about free theorems.
06:12:03 <__monty__> That'll cost you.
06:12:14 <adamShimi> Concretely, I'm trying to understand why Functor instances are unique. To do so, I read Wadler's paper "theorem for free". And I think I get how parametricity gives a theorem on the parametric function.
06:12:38 <adamShimi> But I don't understand how functors in general are viewed as relations in Wadler's approach.
06:13:04 <adamShimi> He gives it for lists, but I'm not sure how to generalize to functors in general.
06:13:32 <adamShimi> And without this interpretation, I don't understand how to derive the free theorem by hand.
06:13:43 <adamShimi> Which I would like to do.
06:13:55 <nshepperd> jsomedon: note that when you define x like that its type is Num a => a, and for instance you can write both (x :: Word) and (x :: Int) on subsequent lines. But there's nowhere for it to store both the 'Word version' and 'Int version' of the evaluated result so it doesn't store either
06:15:23 * hackage ghc-check 0.1.0.1 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.1.0.1 (PepeIborra)
06:16:19 <hexagoxel> jollygood2: `tryJust (guard . isEOFError) getLine` might be a short handler, and it lets you act on the EOF case.
06:17:39 <jollygood2> I like the fact that exception aborts my program, I just don't like the error message it provides to the user. so maybe I should catch and then rethrow a custom exception? or just catch, and exit
06:18:38 <jsomedon> nshepperd: huh, so I really need to specify type in this case
06:21:06 <hexagoxel> jollygood2: tryJust corresponds to the latter: if you get a Left (), you exit/stop your loop; if you get Right inputLine, you continue.
06:21:33 <nshepperd> jsomedon: ghci has NoMonomorphismRestriction set by default, which means it doesn't default to Integer
06:21:57 <nshepperd> unlike when you write x = 100 in a .hs file
06:29:39 <jollygood2> hexagoxel, is there an exception that throws without displaying any error? if not, can I make one? or should I just exit
06:32:41 <hexagoxel> I'd probably System.Exit.exitSuccess. What is the point of an exception that is not supposed to be caught or to display anything?
06:38:31 <hexagoxel> jollygood2: I wonder if `lines <$> getContents` would make things easier for you. Not sure if lazy IO has any caveats here, but it might just work for you.
06:48:25 <lyxia> adamShimi: for functors built with sums, products, and functions, you can construct that relation if you know how to interpret these three components as relations.
06:51:06 <adamShimi> lyxia : Thanks. That's how you write the relation for a specific functor; but is there an approach for describing the relation for any functor?
06:53:35 <tabaqui> How did it happen, that Applicative [] instance doesn't follow interchange law?
06:55:38 <tabaqui> I mean historical reasons
06:57:13 <lyxia> tabaqui: why doesn't it
06:58:05 <tabaqui> [f, g] <*> [a, b] = [11, 12, 21, 22]
06:58:49 <tabaqui> If you transpose it, then new list will have switched 'f b' and 'g a' values
06:59:46 <lyxia> In my mind the interchange law is   u <*> pure y = pure ($ y) <*> u   How is what you wrote a counterexample?
06:59:51 <tabaqui> % [ * 2, *3] <*> [10, 100]
06:59:52 <yahb> tabaqui: ; <interactive>:95:3: error: A section must be enclosed in parentheses thus: (* 2); <interactive>:95:8: error: A section must be enclosed in parentheses thus: (* 3)
07:00:27 <tabaqui> % [ (* 2), (*3)] <*> [10, 100]
07:00:27 <yahb> tabaqui: [20,200,30,300]
07:01:06 <tabaqui> % [ (* 2), (*3)] <**> [ ($ 10), ($ 100)]
07:01:06 <yahb> tabaqui: [20,200,30,300]
07:01:15 <tabaqui> Uh, wait a sec
07:01:43 <lyxia> adamShimi: What does it mean to describe it for any functor, if not to do it for any specific functor?
07:01:59 <tabaqui> % flip (<*>) [ (* 2), (*3)]  [ ($ 10), ($ 100)]
07:01:59 <yahb> tabaqui: [20,30,200,300]
07:02:03 <tabaqui> Here
07:02:12 <tabaqui> lyxia: ↑
07:02:28 <lyxia> that's not a violation of interchange
07:02:45 <tabaqui> Ah, there is no pure
07:02:52 <tabaqui> Sorry, forget about it
07:09:57 <adamShimi> lyxia: I meant "in one go", as in one derivation for all functors. But maybe that's just not possible, simply a shorthand for the individual derivations you propose.
07:42:54 * hackage typed-spreadsheet 1.1.5 - Typed and composable spreadsheets  https://hackage.haskell.org/package/typed-spreadsheet-1.1.5 (GabrielGonzalez)
07:50:24 * hackage nonlinear-optimization-ad 0.2.4 - Wrapper of nonlinear-optimization package for using with AD package  https://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.4 (MasahiroSakai)
08:03:53 * hackage nonlinear-optimization-backprop 0.2.4 - Wrapper of nonlinear-optimization package for using with backprop package  https://hackage.haskell.org/package/nonlinear-optimization-backprop-0.2.4 (MasahiroSakai)
08:10:13 <matheus23> So... I don't know what the best channel to ask this in, is. I'm half through watching the "Programming with Categories" lectures, but I'm wondering: The 'Hask' (almost) category is the category of haskell _types_, but is there also a category for haskell's _values_? This question is somewhat hand-wavey...
08:23:37 <matheus23> I feel like https://stackoverflow.com/questions/17380379/where-do-values-fit-in-category-of-hask answers many of the questions I had, if anyone else stumbles upon this
08:25:24 * hackage hookup 0.3.1.0 - Abstraction over creating network connections with SOCKS5 and TLS  https://hackage.haskell.org/package/hookup-0.3.1.0 (EricMertens)
08:26:07 <gentauro> not so long ago, somebody suggested that I begin to use `.cabal` files instead of `package.yaml`. I don't remember who it was.
08:26:33 <geekosaur> that's more or less what I guessed. there's also the view where a type is a set of its values, which gets you subsets of the category of sets, but that's not very useful
08:26:47 <gentauro> what I noticed is that I need to write all my libraries (modules) in the `.cabal` file, while in the `package.yaml` I don't. 
08:27:14 <gentauro> is there a way to auto-complete all submodules automatically in .cabal files based on `folder + files`?
08:30:02 <nshepperd> every value x :: A in haskell can be identified with the morphism const x :: () -> A
08:30:08 <nshepperd> so that's one way values show up
08:30:54 * hackage glirc 2.35 - Console IRC client  https://hackage.haskell.org/package/glirc-2.35 (EricMertens)
08:38:06 <polyphem> how can i patternmatch sumtype constructor that is a record without using RecordWildCards ? https://gist.github.com/polyrod/200a0ebd1f97f852311ee4447c6763b8
08:39:14 <lyxia> polyphem: if you don't use the fields you can write R{}
08:39:15 <geekosaur> R {a = x, b = y} = ...
08:39:39 <geekosaur> which gives you the values of a and b locally as x and y
08:40:07 <geekosaur> you can also use further patterns in place of x and y, not that it's useful with type ()
08:40:08 <polyphem> can i do r@R{} and then use the field accossor function like normal "a r" ?
08:40:24 <monochrom> Yes.
08:40:38 <polyphem> geekosaur: thats a reduced example ... :p
08:40:38 <monochrom> I don't like it though.
08:40:59 <geekosaur> yes, but in that case it may make more sense to use r and match the RS case earlier, as in your example
08:41:19 <geekosaur> snince the pattern at that point presumably only matches the R case anyway
08:41:54 <polyphem> ok , thanks for the ideas everyone ... i ll try it out 
08:42:10 <monochrom> Not sure whether this applies to you, but I am baffled by how much length people go to emulate "OOP getter methods" where there is none.
08:42:31 <geekosaur> also it's conventional to write that with parens, even though by precedence they're not needed; it's easier to read
08:42:38 <geekosaur> r@(R {})
08:43:20 <monochrom> Aww, I use lack of spaces for that. r@R{a=x} is clearly one group.
08:45:47 <polyphem> ok , code compiles .. so it *must* be right :)
08:45:59 <polyphem> thx
08:49:09 <maerwald> gentauro: no
08:49:27 <maerwald> that's a misfeature
08:53:45 <monochrom> You list who are exposed modules and who are hidden modules.  If you haven't made hidden modules you may not appreciate why.
08:55:25 <gentauro> monochrom: well aren't they usually marked as `.Internal`?
08:55:40 <gentauro> I mean, the module system in Haskell is pretty bad (they could learn a bit from OCamls)
08:56:03 <gentauro> where you can actually create "real" hidden modules by just making sub-modules
08:56:22 <gentauro> Internal modules can still be accessed amirite?
08:56:39 <gentauro> (even though they aren't supposed to)
09:08:18 <solonarv> gentauro: if they're not in exposed-modules then I don't think they are accessible
09:08:32 <solonarv> except maybe via unsafe TH shenanigans?
09:11:49 <monochrom> Hidden modules aren't even shown by haddock. You won't see hidden modules marked by a naming convention because you won't even see anything.
09:13:58 <monochrom> Inner module has the <sarcastic>benefit</sarcastic> that two outer modules cannot both see the same inner module.
09:18:05 <Wordlesstuba> hi
09:18:22 <Wordlesstuba> which ide for haskell should i choose on windows
09:18:50 <Wordlesstuba> vscode? leksah or eclipse fp? please guide me
09:21:33 <Wordlesstuba> anyone help?
09:24:22 <solonarv> Wordlesstuba: I'd just stick with some code editor (vscode, vim, emavs, whatever you like) and HIE or ghcide for fancy editor integration via LSP
09:25:04 <solonarv> last I checked leksah was really experimental and its recommended install method is Nix, which sounds like it'd be problematic on windows
09:25:23 <Wordlesstuba> i am totally new to this, there is no documentation or anything on how to get started with vs code
09:25:35 <solonarv> I haven't looked at eclipse FP at all, but IDEA's one working up-to-date haskell plugin only works with stack, which is not great
09:26:40 <solonarv> for vscode, you want the extensions "haskell syntax highlighting" and "ghcide" or "haskell language server"
09:27:02 <Wordlesstuba> okay will try right away and let you know
09:27:28 <Wordlesstuba> thank you so much, this really is a very helpful community like people said
09:28:48 <solonarv> note that you can also leave out the editor integration and just run ghci or ghcid in the terminal while you're editing
09:29:08 <solonarv> that works pretty well too, and if you do that it *really* doesn't matter what editor you use
09:29:24 <Wordlesstuba> oh okay , so use editor to edit code and run the code in terminal
09:29:26 <Wordlesstuba> okay
09:41:24 * hackage hakyll-shortcut-links 0.1.0.0 - Use shortcut-links in markdown file for Hakyll  https://hackage.haskell.org/package/hakyll-shortcut-links-0.1.0.0 (vrom911)
09:43:57 <Athas> Is there a good and simple prettyprinting library that can output terminal codes for colors/boldface/etc if available, but can otherwise fall back to plain text?
09:44:14 <Athas> My use case is mostly just dumping text on a console.
09:45:16 <glguy> Athas: You could use the prettyprinter and prettyprinter-ansi-terminal packages and then do a conditional check to use either the ansi backend or not
09:46:12 <Athas> glguy: does that have colour?
09:46:41 <Athas> Ah, so I would always use prettyprinter-ansi-terminal?
09:47:09 <glguy> Athas: The ansi colors and styles go in attributes on the pretty printed thing
09:47:16 <glguy> If you use the ansi backend then it would use those attributes
09:47:35 <glguy> if you take that same prettyprinter value and render it with the plaintext backend you'd get no colors
09:49:11 <Athas> I see.  Then I can write pure functions that just produce Docs using whatever color information they want, and then in the IO parts of the program I can use 'show' if I detect that output should be plain text file, or otherwise the putDoc function from prettyprinter-ansi-terminal.
10:08:11 <fragamus> can I get vim editing in the GHCI command prompt
10:09:54 * hackage primitive 0.7.0.1 - Primitive memory-related operations  https://hackage.haskell.org/package/primitive-0.7.0.1 (CarterSchonwald)
10:10:18 <MasseR> It uses the haskeline library which in theory supports vi mode, but I couldn't get it to work
10:13:17 <geekosaur> https://github.com/judah/haskeline/wiki/ViModeCompatibility suggests it needs to learn more about the difference between command and input mode before it'll be usable
10:20:24 * hackage monad-choice 0.1.0.0 - Monad, monad transformer, and typeclass representing choices.  https://hackage.haskell.org/package/monad-choice-0.1.0.0 (LouisH)
10:43:25 <coot> https://www.irccloud.com/pastebin/Z313knXl/
10:50:58 <jollygood2> re my earlier question, does this seem reasonable? getLine `catch` handleError where handleError :: IOError -> IO String handleError _ = exitFailure
10:51:25 <jollygood2> it does what I want, but I'm not sure if I would also catch things I didn't mean to
10:52:14 <geekosaur> that catches all IOErrors
10:53:03 <jollygood2> I want to catch EOF and ctrl+c
10:56:18 <solonarv> then you probably want to call 'isEOFError' to check what type of error it is
10:56:27 <solonarv> I don't remember what the error type for Ctrl-C is
10:58:04 <jollygood2> hmm, given the exception message, maybe EOF catches both. <stdin>: hGetLine: end of file
10:58:17 <jollygood2> I'm not sure if this is the same on different OSes
10:58:31 <cocreature> `UserInterrupt` is Ctrl-C
10:58:40 <cocreature> which is a value of type AsyncException
10:58:40 <solonarv> no, I think Ctrl-C actually isn't an IOError... ah there it is
10:58:44 <cocreature> https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:UserInterrupt
10:58:57 <jollygood2> it is on windows
10:59:10 <jollygood2> my handleError function above is catching it
10:59:17 <jollygood2> is it different on linux, os x?
10:59:30 <srk> jollygood2: https://paste.rs/szV.hs
10:59:33 <srk> possibly
10:59:57 <solonarv> I am on Linux and Ctrl-C does not produce an eof error (in ghci)
11:00:11 <geekosaur> this is one of those things that is likely to differ on POSIX vs. Windows
11:00:21 <srk> ghci installs its own crtl-c handler
11:00:44 <cocreature> pretty sure that UserInterrupt is cross-platform
11:00:44 <srk> so you can kill running programs inside repl
11:00:56 <srk> well, it's Posix :)
11:01:21 <geekosaur> it's cross-platform but the details of how it works may well not be
11:05:06 <ezzieyguywuf> if I have ghc and pals installed using ghcup, and I want to follow the instructions for installing stack here (https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2), do i need to undo the ghcup stuff first?
11:05:49 <jollygood2> how would I write a handler that handles both IOError and UserInterrupt? two catch calls?
11:06:40 <jollygood2> with two different handlers
11:08:04 <LysergicDreams> That's how I'd do it. Although if you want to catch UserInterrupt everywhere, I use installHandler & sigINT from the unix package
11:10:12 <jollygood2> IIRC it wouldn't even be needed on linux. I'm mainly annoyed by the odd error message [from the user's perspective] if user presses C-c or sends eof.  <stdin>: hGetLine: end of file in both cases
11:10:17 <jollygood2> IIRC it wouldn't even be needed on linux. I'm mainly annoyed by the odd error message [from the user's perspective] if user presses C-c or sends eof.  <stdin>: hGetLine: end of file in both cases
11:10:30 <geekosaur> given that the windows question already came up, the unix package is probably not an answer here
11:15:09 <ysangkok> how does Control-C even work on windows? i think EOF on windows is actually Control-Z somehow
11:16:33 <ysangkok> hmm seems like it is somehow a configuration option of cmd.exe https://superuser.com/q/955969/33303
11:17:12 <ysangkok> i never understood the windows console :O and now with powershell and Windows Terminal the question comes up a lot, if something is inherited from cmd.exe or not :O
11:17:19 <ysangkok> and conhost.exe 
11:18:02 <ezzieyguywuf> how do I install this package using cabal? https://hackage.haskell.org/package/pretty-simple
11:18:42 <ezzieyguywuf> the instructions are written using stack. I tried `cabal install pretty-simple`, but cabal issues a warning/error: 'cabal cannot build the executables in the package pretty-build'
11:19:24 * hackage preql 0.1 - experiments with SQL  https://hackage.haskell.org/package/preql-0.1 (bergey)
11:20:24 <topos> ezzieyguywuf it looks like the author hid buildability behind a flag
11:21:19 <MarcelineVQ> indeed, note the buildexe flag at https://hackage.haskell.org/package/pretty-simple
11:21:29 <topos> you'll need something like cabal install -fbuildexe exe:pretty-simple
11:22:06 <ezzieyguywuf> topos: I don't need the executable though, just the library
11:22:10 <MarcelineVQ> cabal install pretty-simple -f buildexe  is sufficient in this case
11:22:14 <ezzieyguywuf> do I have to install the executable to get the library itself?
11:22:18 <MarcelineVQ> no
11:22:42 <ezzieyguywuf> how do I install only the library?
11:22:58 <MarcelineVQ> if you want to play with the library you can write  cabal repl -b pretty-simple   if you want to use it in a project then add it to your project's build depends
11:23:49 <tomjaguarpaw> Is there such a thing as an indexed traversal but the index is a lens for getting back into that position?
11:23:53 <ezzieyguywuf> hm, so there's no way to just install a library such that when I ghci I can just have access to it?
11:28:20 <MarcelineVQ> you can, but it's not the reccomended workflow anymore
11:32:31 <xavo[m]> hey y'all, I have a `type M = WriterT [AST] (State Foo)` roughly
11:32:51 <xavo[m]> and in the AST adt there's a `Times Int [AST]` constructor
11:33:41 <maerwald> https://gist.github.com/hasufell/37dc7a595ad4805cb051599b1c2f89f1 I can't make this typecheck (Excepts variant)
11:34:35 <xavo[m]> and I'd like to write some `times :: Int -> M () -> M ()` such that the change on `Foo` is repeated but the Writer's state is repeated through `Times` instead
11:36:14 <maerwald> oh, I solved it xD
11:36:43 <maerwald> the ask on IRC effect
11:36:50 <xavo[m]> is that even possible? or more accurately, would it be possible to separate out the `Foo -> Foo` action from the state monad so i can `stimes n . Endo` on it and put it back together w/ `state` and `writer`
11:37:05 <xavo[m]> yuppp I hope that happens here too lol
11:40:50 <xavo[m]> ugh, I can `sequence_ . replicate n` and overwrite it with `censor . const` but that feels really hacky
11:43:39 <ezzieyguywuf> MarcelineVQ: got it, thank you
11:44:52 <xavo[m]> ah, nvm, ofc the `[AST]` would depend on the Foo lol
11:50:38 <maerwald> I think I'm going to abandon open variants for ExceptT
11:50:52 <maerwald> The lack of type inference is just really annoying
12:05:05 <d34df00d> Sup folks.
12:05:08 <d34df00d> I want something strange again.
12:05:39 <d34df00d> Let's say I'm writing a function that performs substitutions in a text template with a supplied function (like when it sees ${foo} it calls the function with the string "foo").
12:06:45 <d34df00d> So this top-level function should live in any monad that has a proper MonadError constraint, and I want it to accept any "lookup" function in an arbitrary monad.
12:07:03 <d34df00d> So it's along the lines of `substitute :: (Monad m, MonadTrans t, MonadError String (t m)) => (String -> m String) -> String -> t m String`
12:08:09 <d34df00d> So far so good, and the body of the function is https://bpaste.net/FTSQ
12:08:50 <d34df00d> But note that `subst` is only used applicatively, and I want to leverage this fact: in fact, I want to be able to use this with a lookup (`subst`) function living in ZipList (which is, as we all know, is an Applicative but not a Monad).
12:09:18 <d34df00d> So how can I express that?
12:11:39 <geekosaur> I din't think you can do that and simultaneously have a MonadTrans on top of it, because MonadTrans requires Monad, not Applicative? unless I am misunderstanding what you're looking for
12:12:51 <d34df00d> Yes, that's part of the problem!
12:13:01 <d34df00d> I could use smth like ApplicativeTrans here, dunno.
12:13:06 <d34df00d> Is there something like that?
12:13:35 <MarcelineVQ> applicatives compose nautrally
12:14:01 <MarcelineVQ> So I wonder if there's a need for a trans class there
12:15:06 <d34df00d> MarcelineVQ: so how would it look?
12:15:09 <MarcelineVQ> Or rather, the composition of two applicatives is an applicative, the composition of two monads isn't neccesarily a monad, so it's constrained by a typeclass
12:20:42 <d34df00d> Hmm, I'm still not sure how to express that then.
12:31:56 <hexagoxel> d34df00d: what type does ghc infer for your implementation? Does it involve MonadTrans at all? Also, MonadError alone requires Monad, so you probably have to use `-> Either String String`.
12:32:15 <monochrom> How do you compose two Applicatives? Is it simply, e.g., Maybe [a], if I compose Maybe and []?
12:33:29 <koz_> There's a couple of ways. Compose, Product, Sum.
12:33:43 <d34df00d> hexagoxel: yeah, it's a type that's isomorphic to what I've written. And it involves MonadTrans since I'm using `lift`.
12:33:52 <koz_> Well, not Sum, but the other two definitely.
12:34:21 <d34df00d> hexagoxel: and the function that I'm passing there doesn't necessarily need to have `MonadError`, it's just the `substitute` itself that surely sometimes errors out.
12:35:53 <solonarv> then... is the MonadError even needed? it's not clear to me why it would be
12:36:29 <d34df00d> The top substitute function does need it — hence MonadError (t m). The inner one indeed doesn't, and I don't need `MonadError m` at all here.
12:38:10 <hexagoxel> no, it just needs to be able to return a Left. `-> m (Either String String)`
12:38:24 <solonarv> hm, you can definitely write 'Applicative f => (String -> f String) -> String -> Either Error (f String)'
12:38:48 <solonarv> I'm not actually sure which ordering is correct
12:39:08 <d34df00d> It's probably up to the semantics.
12:39:20 <solonarv> yep, and I don't know which semantics you want
12:39:26 <d34df00d> But yeah, easing up on the transformers sounds like a good idea.
12:39:28 <d34df00d> Let me try that.
12:39:33 <boxscape> are functions like `Sing f -> Sing g -> Sing (f .@#@$$$ g)` (as opposed to `(%.) :: Sing f -> Sing g -> Sing x -> Sing (f @@ (g @@ x))`) not in the singletons library? So functions that produce defunctionalized functions. It's not hard to make, but it seems like the sort of thing that should be generated by TH automatically
12:41:28 <lyxia> haha ".@#@$$$" such beauty
12:41:42 <boxscape> indeed
12:42:08 <solonarv> I'm sure there is some system giving rise to that name, but holy shit is it ugly
12:42:35 <boxscape> @#@ suffix to make sure it doesn't clash with anything (I think), number of dollar signs minus 1 is the number of arguments the operator takes
12:42:35 <lambdabot>  suffix to make sure it doesn't clash with anything (I think), number of dollar signs minus 1 is the number of arguments the operator takes
12:43:16 <MarcelineVQ> @botsnack
12:43:16 <lambdabot> :)
12:45:24 * hackage mmsyn7s 0.6.4.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.4.0 (OleksandrZhabenko)
12:46:11 <lyxia> boxscape: there is a SingI instance for it, is that no good?
12:46:45 <boxscape> Ah, I suppose that can be used instead, right
12:47:11 <lyxia> there is withSingI to turn Sing into SingI
12:47:51 <boxscape> a little more convoluted than using a function like that directly but yeah it should work
12:53:02 <boxscape> I'm so looking forward to unsaturated type families
12:56:11 <iqubic> Me too. That's going to be great.
13:23:42 <fen> huh, what? unsaturated type families? where!?
13:24:02 <boxscape> fen .@#@$$$
13:24:04 <boxscape> whoops
13:24:05 <boxscape> wrong paste
13:24:10 <boxscape> fen https://github.com/ghc-proposals/ghc-proposals/pull/242
13:24:29 <fen> ah, damn! wake me up later when they are finished...
13:24:51 <solonarv> haha, that operator is so terrible you put it in your clipboard ^^
13:24:53 <boxscape> fen there is a prototype implementation but a few things will be different in the actual ghc version
13:25:10 <boxscape> solonarv tbh I don't quite remember why I did it but it had something to do with looking it up on hackage
13:38:40 <orzo> hello
13:39:11 <maerwald> hi
13:39:57 <orzo> i want to run some IO (only once, the first time) to provide a value use unsafePerformIO so that it appears as hardcoded data.
13:40:03 <orzo> i relize a lot of people will yell at me for that
13:40:19 <orzo> but just assuming that i want to do it, what's the best pattern/idiom to accomplish it?
13:41:05 <monochrom> Like this?  x = unsafePerformIO (readFile "/dev/urandom")
13:41:28 <orzo> well we'll need at least a NOINLINE pragma on that
13:41:34 <monochrom> Yes.
13:42:48 <orzo> is that sufficient?  I just assign the variable with the IO action and then put unsafe on there and a NOINLINE and it will behave the way I want without any more gotchas?
13:44:12 <monochrom> Yes.
13:44:20 <orzo> cool
13:44:28 <MarcelineVQ> there's an entry on the haskell wiki about the gotchas iirc.  what is the data you want to seem hardcoded?
13:44:47 <MarcelineVQ> 'cause depending on your use you could fetch a value with TH at compile time, so you don't type it in the code yourself but it is hardcoded
13:45:42 <orzo> i'm customizing default behaviors based on the path of the executable
13:48:12 <boxscape> what is the purpose of doing it with unsafePerformIO?
13:48:57 <orzo> cause i'm a willful sonofabich and i want my defaults to appear as hardcoded pure globals
13:50:38 <boxscape> fair enough
13:51:08 <MarcelineVQ> [x] strongly disagree
13:51:12 <maerwald> I found globals to be useful for tests.
13:59:24 <sm[m]> you go orzo. If it bites you please come back and tell us
14:01:43 <sm[m]> I do it for setting a global --debug level. Only gotcha so far is you have to reload the module in ghci to see a change
14:07:08 <xavo[m]> is there a generalized way to `traverse_` over a structure, inserting an action between each element but not one at the beginning or end? I can manage it by fmapping followed by foldl1 but that requires Functor which I'd wanna avoid if unnecessary
14:14:02 <solonarv> xavo[m]: you can probably cobble something together by traversing with 'StateT _ f' instead of 'f', and using the state to keep track of whether you're at the start/end
14:15:06 <jollygood2> > sequence_ . intersperse (putChar '-') . map putChar $ "foo"
14:15:09 <lambdabot>  <IO ()>
14:15:31 <solonarv> do it in yahb, it actually runs IO
14:15:41 <solonarv> % sequence_ . intersperse (putChar '-') . map putChar $ "foo"
14:15:41 <yahb> solonarv: f-o-o
14:16:02 <jollygood2> I keep forgetting about that bot
14:16:44 <solonarv> it is actually just a sandboxed GHCi taped to an IRC client
14:17:14 <solonarv> lambdabot is more complicated and in particular doesn't run IO and isn't backed by a GHCi session
14:20:59 <jollygood2> solonarv, neat. you made it?
14:23:12 <iqubic> No. It wasn't made by them.
14:23:55 <solonarv> no, I had nothing to do with those
14:27:47 <pyBlob> Is there a convenient way to define integer constants with big values e.g. something like `x = 500e3 :: Integer`?
14:28:08 <solonarv> there's a language extension that allows you to write exactly that
14:28:08 <boxscape> % x = 500e3 :: Integer
14:28:08 <yahb> boxscape: ; <interactive>:102:5: error:; * No instance for (Fractional Integer) arising from the literal `500e3'; * In the expression: 500e3 :: Integer; In an equation for `x': x = 500e3 :: Integer
14:28:14 <boxscape> % :set -XNumDecimals
14:28:14 <yahb> boxscape: 
14:28:14 <solonarv> I don't remember what it's calles
14:28:15 <boxscape> % x = 500e3 :: Integer
14:28:15 <yahb> boxscape: 
14:28:19 <solonarv> ah, there it is
14:28:24 <boxscape> % x
14:28:24 <yahb> boxscape: 500000
14:29:20 <boxscape> seems like a strange name for that extension actually
14:30:14 <boxscape> % x = 5.33e5 :: Integer -- pyBlob you can even write something like this
14:30:14 <yahb> boxscape: 
14:30:18 <boxscape> % x
14:30:18 <yahb> boxscape: 533000
14:31:07 <pyBlob> That should work, instead I should also be able to "rename" a function that casts from double to integer?
14:32:08 <iqubic> :t fromIntegral
14:32:10 <lambdabot> (Integral a, Num b) => a -> b
14:32:29 <boxscape> iqubic I think pyBlob is asking for the opposite?
14:32:41 <iqubic> Yeah.
14:32:43 <jollygood2> not sure why 500e3 isn't Num by default. oversight?
14:32:55 <iqubic> Also, Double isn't an integral.
14:33:01 <boxscape> jollygood2 I think it's pretty common in programming languages
14:33:17 <boxscape> pyBlob floor, ceiling and round let you go from Double to Integer
14:33:24 * hackage mmsyn7s 0.6.5.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.5.0 (OleksandrZhabenko)
14:33:36 <jollygood2> boxscape, generic numerical literals don't exist in most languages
14:33:58 <solonarv> but really, that's not what you're doing - you just want to write a big integer literal using scientific notation, right?
14:34:05 <solonarv> no casting or conversion is necessary
14:34:26 <boxscape> jollygood2 that's true, I guess what I meant is that if I had to guess I'd say that in C, 5e3 will be interpreted as a double literal rather than as an int literal, as 5000 would be
14:34:41 <boxscape> could be that 5e3 is just illegal and you have to write 5.e3 or something
14:34:44 <jollygood2> right. but in haskell, it could have been both
14:35:12 <solonarv> my guess is that either the people designig the spec didn't think of it, or they did think of it but decided to make the rule simpler
14:35:15 <boxscape> definitely could have been, yeah
14:35:39 <boxscape> % :t 5.3e2
14:35:39 <yahb> boxscape: Num p => p
14:35:43 <boxscape> % :t 5.333e2
14:35:43 <yahb> boxscape: Fractional p => p
14:36:00 <boxscape> I guess the difference in type for very similar looking literals can be perceived as confusing
14:36:02 <pyBlob> A right, just discovered that with that extension I can just put "500e3" to any function that expects Integers without the ":: Integer", and it will automatically be casted.
14:36:15 <solonarv> pyBlob: this is because no "casting" is happening
14:36:19 <pyBlob> Thanks, so the extension it will be =)
14:53:54 * hackage data-msgpack-types 0.0.3 - A Haskell implementation of MessagePack.  https://hackage.haskell.org/package/data-msgpack-types-0.0.3 (iphydf)
14:54:54 * hackage data-msgpack 0.0.13 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.13 (iphydf)
14:56:06 <iphy> cabal.exe: --enable-tests was specified, but tests can't be enabled in a remote package
14:56:10 <iphy> what does this mean?
15:17:24 * hackage mmsyn7s 0.6.5.1 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.5.1 (OleksandrZhabenko)
15:41:24 * hackage hledger-flow 0.13.1.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.13.1.0 (apauley)
15:44:24 * hackage zip 1.3.1 - Operations on zip archives  https://hackage.haskell.org/package/zip-1.3.1 (mrkkrp)
15:44:45 <maerwald> is there an option in brittany to keep imports on one line?
15:55:30 <chew2> hi, I was testing some memoization functions and I noticed that eta-expansion seems to make the memo function go much slower, does anyone know why this is, or where I can read more? https://gist.github.com/stevenfontanella/6e6f69af556d4737fec26b90f17617b9
15:57:24 <chew2> I'm assuming that the optimizer would probably take care of it, but I still thought that the definitions were equivalent
16:00:53 <solonarv> chew2: in theory the 'map f [0..]' can float out of the lambda in the eta-expanded definitions, but in practice that sort of thing doesn't happen very reliably
16:02:06 <solonarv> the first two definitions turn into something like: \f -> let xs = map f [0..] in (!!) xs
16:02:31 <chew2> solonarv: so it would become `let mapped = map f [0..] in \x -> mapped !! x`?
16:02:38 <solonarv> the other two turn into something like: \f x -> let xs = map f [0..] in (!!) xs x
16:02:46 <chew2> oh I got it wrong
16:03:12 <solonarv> this "let" can in principle float out of the inner '\x -> ' lambda to give what you posted
16:03:19 <chew2> ohh ok
16:03:36 <solonarv> but this does not seem to be happening
16:03:47 <chew2> yes I was running it from repl so no optimization
16:03:50 <maralorn> chew2: Even though it seems equivalent to you. The compiler does not know that "map f [0..] !!" does not depend on x.
16:04:08 <solonarv> maralorn: it can figure that out just fine, actually
16:04:23 <maralorn> But if you eta-reduce there is no "x" that could be used in "map f [0..] !!". So then it‘s obvious.
16:04:34 <chew2> maralorn: ok that makes sense, is the consequence of that that it's worse for sharing? or is that unrelated
16:04:50 <solonarv> but running in ghci will of course make sure no optimizations happen at all, which explains why you're not seeing the optimizer making your code better ^^
16:04:53 <ChaiTRex> I wish there was a way to give a default value to Map elements.
16:05:12 <solonarv> maralorn: ghc can see that x is not free in 'map f [0..]', so that binding can be floated out
16:05:23 <chew2> well of course I could optimize it, but I just wanted to know why these definitions aren't equivalent
16:06:07 <solonarv> if you want to find that out you really should compile with -O1 (the default outside of ghci) or -O2
16:06:21 <dmwit> ChaiTRex: You might like the total-map package. Then again you might not.
16:06:53 <chew2> ChaiTRex: maybe I'm missing something but don't many Map functions have support for default values i.e. insertWith
16:06:56 <hpc> i didn't like it
16:07:40 <hpc> getting maybe the value for a key and using (<|>) is better than total-map imo
16:08:17 <solonarv> don't you mean fromMaybe?
16:08:20 <ChaiTRex> chew2: I mean for memoizing, where you provide a function that takes the key and produces a thunk and then when you request the value at a key, you get the thunk.
16:08:34 <dmwit> hpc: Surely findWithDefault is better than rolling your own. =P
16:08:41 <ChaiTRex> dmwit: Is there anything like that where the default value can be a function that takes the key and produces a value?
16:08:42 <hpc> oh right, or that
16:09:12 <maralorn> chew2: My understanding is that eta-reduced code makes sharing more likely, but I don‘t know how much that matters if you enable all optimizations.
16:09:13 <maralorn> What is by the way the default optimization used by cabal build?
16:09:14 <dmwit> ChaiTRex: Yes, sure, check out one of the many trie-based memoization libraries.
16:09:25 <ChaiTRex> dmwit: OK, thanks.
16:09:29 <hpc> i have a bad habit of forgetting about convenience operations because the core operations are more memorable, then assuming that an api is anemic because of it
16:09:49 <solonarv> by default it passes no -O argument to ghc, which means ghc's default of -O1 is used
16:09:52 <dmwit> http://hackage.haskell.org/package/MemoTrie-0.6.10/docs/Data-MemoTrie.html for example
16:10:27 <chew2> maralorn: so is this a good argument for point-free code?
16:10:35 <solonarv> sometimes
16:10:42 <maralorn> solonarv: Any reason for me not to use -O2?
16:11:00 <solonarv> you don't really have to write in a point-free fashion, you can just manually float the 'let' out of the lambda
16:11:05 * maralorn is going of to the ghc manual comparing optimisation levels.
16:11:08 <solonarv> maralorn: compile times, that's it
16:13:31 <maralorn> chew2: I feel like solonarv understands it better than I do. In general I think you should be as point free as is readable. But in my experience it can get unreadable very quickly.
16:13:35 <solonarv> chew2: you could just as well write: memo f = \x -> vals !! x where vals = map f [0..]
16:13:58 <solonarv> this isn't point-free at all, but should be the same as your first two functions
16:14:35 <ChaiTRex> Is there a way to prevent sharing a value between two evaluations of it? For example, making `sum xs/length xs` compute xs twice.
16:14:55 <maralorn> Floating out calcualations which actually don‘t depend on innermost function arguments is not only more efficient but also more understandable.
16:15:12 <solonarv> at least, in ghci - with optimizations it might even get worse, as ghc might decide to inline 'vals'
16:15:18 <maralorn> ChaiTRex: Why would you want that?
16:15:34 <chew2> solonarv: I think that one is slower
16:15:38 <chew2> I can try in a minute though
16:15:42 <solonarv> easy: perhaps xs is some gigantic list that will never fit into memory
16:15:43 <ChaiTRex> maralorn: To avoid storing a very large number of elements in memory.
16:15:50 <chew2> I compiled with O2 and there was actually still a difference in speed
16:16:06 <solonarv> and yes, there is a way for that to happen ChaiTRex: xs simply has to get inlined
16:16:19 <maralorn> ChaiTRex: Ah, of course.
16:16:39 <ChaiTRex> solonarv: Ahh, thanks.
16:17:15 <bapa> Anyone know if there's a Discord server for Haskell? Little too lazy for IRC and prefer that platform, if possible. Thank ye kindly.
16:17:23 <solonarv> bapa: there is indeed
16:17:32 <solonarv> there's also a more general FP discord
16:17:46 <bapa> I tried joining the FP discord but the only link I could find was dead. RIP.
16:18:16 <bapa> It also seems that my chances of finding this mythical Haskell Discord server are about as likely as me as solidly grasping what the heck a Monad is.
16:18:26 <bapa> I get 100 points for making a predictable joke, btw.
16:19:44 <maralorn> solonarv: If I read https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html correctly the default is actually -O0?
16:20:07 <solonarv> well, here are links: (haskell) https://discord.gg/9VGcEYA ; (FP) https://discord.gg/K6XHBSh
16:20:11 <solonarv> bapa: ^
16:20:22 <bapa> Thank you, kind savior. I shall click them.
16:21:32 <solonarv> maralorn: hm, this doesn't actually go out and say that nothing => -O0
16:21:45 <maralorn> bapa: And also please don‘t very too much about what a Monad is. It‘s not as important as it looks from the outside.
16:22:13 <maralorn>     Means “turn off all optimisation”, reverting to the same settings as if no -O options had been specified.
16:22:14 <maralorn> solonarv:  -O0
16:22:19 <MarcelineVQ> optionally you can worry just enough to learn it
16:22:35 <chew2> solonarv: you were right, that one is fast
16:23:00 <iqubic> bapa: I don't think there's a haskell discord. We just hang out in IRC.
16:23:03 <chew2> I guess the main thing is that ghc needs to know that map f [0..] can be reused
16:23:03 <bapa> maralorn: I know it isn't, but I still like understanding things for the sake of it.
16:23:30 <solonarv> iqubic: you are wrong, as demonstrated by the Haskell discord I linked not five minutes ago :P
16:23:30 <bapa> Plus, I'm trying to get into finally learning discrete mathematics, and interleaving it with coding (ie Haskell) is sure to lead to some fun times.
16:23:46 <maralorn> bapa: Okay, then have fun. You‘ll get it eventually.
16:23:55 <iqubic> solonarv: I assume the IRC is way more active than the discord.
16:24:03 <bapa> "fun"? What is, this, Ocaml? We use backslashes here.
16:24:14 <solonarv> usually this IRC channel is more active, yes
16:25:05 <maralorn> ^ actually in comparision to most things.^^
16:28:51 <evelyn> and long may it stay so as opposed to proprietary platforms like discord
16:29:07 <evelyn> there is a tension there I think
16:29:24 <Rembane> Both communities seems healthy right now 
16:30:57 <bapa> I generally don't care if a chat platform is centralized or proprietary or whatever, but one pro that IRC communities have for technical discussion is that they actually have technical discussion. Most of the $lang Discord servers are 95% off-topic shirtposting, and spending time talking about coding instead of actually coding.
16:31:10 <evelyn> I thinkk the tension is concorning  whether discord will be around in 5 years or everyone will have moved to whatever's popular next. 
16:31:33 <bapa> Even if $chat_platform died and wasn't around, would it matter? Shouldn't be too hard to get everyone to move somewhere else.
16:31:40 <bapa> Espeically if it's something that only takes a few clicks to setup.
16:32:30 <bapa> Also, on-topic discussing coming up after I pastebin it.
16:33:06 <evelyn> it's not about how hard it is to set up but whether some critical mass of people moves to the other platform, and that's exactly how online communities go to die
16:33:18 <evelyn> w/e
16:41:48 <sm[m]> bapa: Riot and the matrix bridge also works great with the haskell channels
16:46:15 <bapa> Soo, this pastebin: https://pastebin.com/9Y0Ny1F5 . I want to define an `instance' of the typeclass I defined earlier, but I put in a (Num a) restriction thingy and I dunno how to work around that when I want to eventually create an `instance'.
16:46:41 <bapa> Error I get is: `No instance for (Num Dunno)`
16:46:54 <bapa> I have no practical use for this, but I'm trying to figure out how to work with Contraints and typeclasses/instances.
16:47:13 <solonarv> bapa: you have to also write a 'Num Dunno' instance
16:47:28 <bapa> RIP me because I am Haskell babby.
16:49:38 <bapa> solonarv: so, liek, ``instance SomeClass (Num Dunno) where`` ?
16:49:41 <bapa> Cuz that doesn't work.
16:49:49 <sm[m]> I suppose reading a book or tutorial is out of the question..
16:50:01 <ChaiTRex> bapa: instance Num Dunno where
16:50:32 <ChaiTRex> bapa: instance SomeClass Dunno where
16:50:53 <bapa> I have been following guides on typeclasses, 3 in fact. But the Constraint thing is tripping me up and I couldn't find a way around it, even with Uncle Google helping me.
16:50:57 <monochrom> Num is the class.
16:51:31 <bapa> I haven't felt like a coding babby since I learned C++ a bajillion years ago. Every lang has been easy since, but Haskell makes me cry. I want to be a big boy ;_;
16:52:02 <sm[m]> for some examples, you can go to https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num, scroll down to Instances and click the source links
16:53:29 <bapa> I'm also pretty sure I've tried that combination at some point, but the error I got was: ``No instance for (Num Dunno)  arising from the superclasses of an instance declartion''.
16:54:20 <bapa> Same with ``instance SomeClass dunno where''
16:54:44 <sm[m]> bapa: best thing is to show a complete reproducible example, otherwise we'll be guessing
16:54:51 <evelyn> http://book.realworldhaskell.org/read/using-typeclasses.html
16:54:58 <evelyn> an oldie but a goodie..
16:56:00 <bapa> I mean, I know how to use typeclasdses, just not with type constraints (eg, ``(Num whatever) => [...]`` in the calss definition.
16:56:17 <bapa> And yes, Real World Haskell has been a great resource.
16:57:10 <sm[m]> don't y'all wish we had an easy haskell pastebin running ghcid ?
16:57:48 <MarcelineVQ> i have a barebones script that curls into a tmp file and pops it into ghci for that sort of thing
16:57:58 <MarcelineVQ> But most peopel's pastes aren't self-contained enough for it to be useful
16:58:21 <sm[m]> it would be a step towards, at least
16:58:43 <MarcelineVQ> e.g.  lghci <url> package1 package2 package3
16:59:46 <solonarv> one issue is of course safet
16:59:50 <solonarv> safety
17:00:12 <sm[m]> there's repl.it
17:00:40 <bapa> Well this is why I like Discord, Ic an just inline Haskell - and syntax highling too, without having to use pastebin.
17:01:21 <bapa> Also what I pastebinned was the code, sm[m]. All you'd have to do is add `main :: IO () \nmain = do [...]`
17:01:27 <Rembane> This is why I dislike Discord, so much of the screen is filled with code. 
17:01:51 <MarcelineVQ> That's one of my particualr issues with discord, people can push the entire conversation off the screen with a single post like an image or some source code
17:02:18 <sm[m]> reproducible means exact source, commands typed, all important output..
17:02:20 <Rembane> And animated gifs make my brain implode 
17:02:40 <sm[m]> https://repl.it/repls/OvalImmenseBetatest shows a little more perhaps
17:02:47 <bapa> Hmm, I got an answer in the Discord. I think I might be able to figure it out now :O
17:11:13 <sm[m]> https://repl.it/repls/OvalImmenseBetatest working. Take that Discord
17:11:19 <ogkloo> How much does ghci optimize code used in it? I have a friend who was writing some code into ghci, and it looked like a very simple function traversing a list that should've gotten compiled down to a loop, but was significantly slower than a naive solution. I don't remember the specifics very well unfortunately. 
17:12:21 <solonarv> ogkloo: not at all
17:12:32 <solonarv> code in ghci is always compiled with -O0
17:12:37 <ogkloo> Ah, that explains it.
17:18:58 <Cale> ogkloo, solonarv: However, if .o and .hi files are available, ghci can load those instead.
17:19:47 <Cale> So you can compile your modules with optimisations and still test out the code if you like. You'll notice that it'll tell you whether it loaded the code in compiled or interpreted form.
17:21:56 <solonarv> IIRC you can also make it compile files you :load normally by passing -fobject-code
17:22:23 <solonarv> this allows you to have optimizations for files you :load, but stuff you type at the prompt is still -O0
17:25:50 <bapa> Yessssss
17:25:52 <bapa> Finally figured it out.
17:26:20 <bapa> I have to define *two* instances for `Dunno`. `instance Num Dunno where` *AND* `instance SomeClass Dunno`
17:26:28 <bapa> I was trying to do it all in just one.
17:27:51 <bapa> Yay for misinterpretting compiler error messages! :D
17:37:40 <bapa> Dat feel when my brain is stuck with certain assumptions willingly misinterprets things.
18:05:38 <habbah> is it possible to include dependencies needed for testing in the cabal freeze file?
18:17:08 <bapa> Also anyone got an opinion on: https://haskellbook.com/
18:17:42 <MarcelineVQ> I got a lot of learning done with it
18:18:14 <bapa> I mean, I'm getting alone okay from these free resources. But it never hurts to use more lube.
18:18:37 <bapa> MarcelineVQ: How much? It isn't in my local currency, so buying it will be expensive-ish for me.
18:19:25 <MarcelineVQ> It was worth the price for me, in particular because it's full of exercises that re-enforce what you're learning, especially if you don't skip them
18:23:11 <koz_> :t (>>=)
18:23:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:24:21 <bapa> speaking of which
18:24:50 <bapa> I was working through that very definition the other day, and seeing how doing `` m >>= return = m ``
18:25:14 <bapa> I worked through it on paper, and it looked like it should come out as `m m`. I am confused and scared.
18:25:55 <bapa> namely from this: https://wiki.haskell.org/All_About_Monads#The_three_fundamental_laws
18:26:48 <bapa> If you're passing an `m', aren't you then, as per the definition of `` :t (>>=) `` going to get back `m m` and not just `m`?
18:27:14 <bapa> (If you work out all the subsitutions on paper, that is.)
18:30:44 <MarcelineVQ> What are the substitution steps?
18:36:34 <solonarv> it might be a good idea to use different names for type variables and other variables, so yu don't mix them up
18:36:54 <MarcelineVQ> take care not to mix up types and values,   (>>=) :: Monad m => m a -> (a -> m b) -> m b   is the type of >>=    c :: d  means c has the type of d.
18:37:54 <MarcelineVQ> g >>= return  is an expression consisting of values, it is  (>>=) :: Monad m => m a -> (a -> m b) -> m b  applied to some value of  g :: m a   and the function  return :: a ->​ m a
18:40:05 <MarcelineVQ> return :: a -> m a   is causing the 'b' from >>= to also be an 'a', this is called unification (afaik)
18:41:20 <MarcelineVQ> Ask questions if that's just more confusing, people like to help here :>
19:20:37 <ogkloo> Is there a simple way to map by 2s over a list or a vector?
19:20:48 <ogkloo> or would it be easiest to define that recursively
19:20:53 <koz_> ogkloo: What do you mean by 'map by 2s'?
19:22:20 <ski> bapa : "I have to define *two* instances for `Dunno`. `instance Num Dunno where` *AND* `instance SomeClass Dunno`" -- heh, yea, as ChaiTRex already suggested before :)
19:24:36 <ski> > (concatMap reverse . chunksOf 2) [0 .. 7]
19:24:40 <lambdabot>  [1,0,3,2,5,4,7,6]
19:25:12 <ski> > (map sum . chunksOf 2) [0 .. 7]  :: [Expr]
19:25:15 <lambdabot>  [0 + 0 + 1,0 + 2 + 3,0 + 4 + 5,0 + 6 + 7]
19:25:27 <ogkloo> koz_ like summing every 2 elements in a list or something like that
19:25:42 <ogkloo> so like turning [1,2,3,4] into [3,7]
19:25:42 <ski> > (map (\[m,n] -> m + n) . chunksOf 2) [0 .. 7]  :: [Expr]
19:25:43 <dogcat1> :t zipWith
19:25:45 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:25:46 <lambdabot>  [0 + 1,2 + 3,4 + 5,6 + 7]
19:26:10 <dogcat1> and take the tail of one of the lists
19:26:11 <ski> > let ns = [0 .. 7] in zipWith (+) xs (tail xs)
19:26:14 <lambdabot>  error:
19:26:14 <lambdabot>      • Variable not in scope: xs :: [c]
19:26:14 <lambdabot>      • Perhaps you meant one of these:
19:26:20 <ski> > let ns = [0 .. 7] in zipWith (+) ns (tail ns)
19:26:22 <lambdabot>  [1,3,5,7,9,11,13]
19:26:24 * hackage status-notifier-item 0.3.0.5 - A wrapper over the StatusNotifierItem/libappindicator dbus specification  https://hackage.haskell.org/package/status-notifier-item-0.3.0.5 (eyevanmalicesun)
19:26:29 <ski> > let ns = [0 .. 7] in zipWith (+) ns (tail ns)  :: [Expr]
19:26:32 <lambdabot>  [0 + 1,1 + 2,2 + 3,3 + 4,4 + 5,5 + 6,6 + 7]
19:26:38 <koz_> Yeah, what ski said.
19:27:29 <ski> > (zipWith (+) `ap` tail) [0 .. 7]  :: [Expr]
19:27:31 <lambdabot>  [0 + 1,1 + 2,2 + 3,3 + 4,4 + 5,5 + 6,6 + 7]
19:28:13 <ski> @quote consecutive.numbers
19:28:14 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
19:32:34 <LysergicDreams> > let fun f = fst . foldr (\n (acc, prev) -> maybe (acc, Just n) (\p -> (f n p : acc, Nothing)) prev) Nothing in fun (+) [1..4]
19:32:36 <lambdabot>  error:
19:32:36 <lambdabot>      • Couldn't match expected type ‘([a1], Maybe t)’
19:32:36 <lambdabot>                    with actual type ‘Maybe a0’
19:33:27 <LysergicDreams> > let fun f = fst . foldr (\n (acc, prev) -> maybe (acc, Just n) (\p -> (f n p : acc, Nothing)) prev) ([], Nothing) in fun (+) [1..4]
19:33:30 <lambdabot>  [3,7]
19:52:24 * hackage xdg-desktop-entry 0.1.1.1 - Parse files conforming to the xdg desktop entry spec  https://hackage.haskell.org/package/xdg-desktop-entry-0.1.1.1 (eyevanmalicesun)
19:56:24 <mastarija> Is it possible to convert list into binary tree using only fold and no recursion or patternmatching?
19:56:50 <koz_> mastarija: Why do you ask?
19:56:55 <mastarija> I've been racking my brain with that for a while
19:56:56 <koz_> It seems a rather niche thing to want.
19:57:18 <mastarija> Supposedly it's possible, but I can't figure it out.
19:57:29 <koz_> mastarija: Is this homework or something?
19:57:34 <mastarija> Kindof
19:57:43 <koz_> So what's the specific question?
19:57:43 <mastarija> Something professor mentioned
19:58:18 <koz_> Ah, OK.
19:58:37 <koz_> I can see a way, assuming _any_ binary tree is acceptable and you're allowed to use partial functions.
19:58:47 <koz_> However, it's artificial and (in my opinion) very un-Haskelly.
19:58:54 <mastarija> hm...
20:04:39 <koz_> mastarija: There ya go, one (possible) solution fitting your criteria: https://gist.github.com/kozross/95db540df7f53e54dd0a849af9aa1993
20:04:45 <koz_> OK, almost.
20:05:16 <koz_> Now it should be correct.
20:05:40 <koz_> But to be honest, this is both artificial and makes me feel icky.
20:06:03 <mastarija> koz_, and it uses recursion which is forbidden :D
20:06:18 <koz_> Lol, so wait, no recursion, no pattern matching?
20:06:20 <koz_> Hmm.
20:06:52 <koz_> :t foldr
20:06:54 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:08:04 <mastarija> I'm thinking there has to be some clever way for fold to return some builder function or something
20:09:07 <koz_> https://gist.github.com/kozross/95db540df7f53e54dd0a849af9aa1993
20:09:13 <koz_> This is, by the way, even _more_ artificial.
20:10:03 <koz_> Oh wait, I pattern match here.
20:10:05 <koz_> Let me fix that. :P
20:10:22 <mastarija> hehe
20:10:32 <mastarija> But pretty interesting
20:10:36 <iqubic> What is MultiWayIf doing there?
20:10:42 <koz_> Nothing _now_.
20:10:57 <iqubic> I see.
20:11:15 <koz_> mastarija: Check now.
20:11:26 <koz_> Also, to please iqubic, MultiWayIf is gone.
20:11:34 <iqubic> Thanks.
20:11:39 <koz_> Argh, never mind, typo.
20:11:49 <iqubic> I don't like unused language pragmas.
20:11:53 <koz_> Better now.
20:12:05 <koz_> Again, the artificiality of this is over 9000.
20:12:05 <mastarija> totally
20:12:23 <mastarija> Well, it's a thought exercise anyway :D
20:12:33 <koz_> The thing is, I don't even consider it _interesting_.
20:12:36 <iqubic> How does that work?
20:12:40 <koz_> This is not educational, and serves no useful purpose.
20:12:52 <koz_> iqubic: Any list is a binary tree if you keep inserting on one side.
20:13:03 <koz_> I'll draw an ASCII diagram in the gist to show you.
20:13:31 <iqubic> So we're converting from a list constructed with (:) and [] to something constructed with Internal and Leaf?
20:13:39 <koz_> Yes.
20:13:43 <iqubic> Ah. I see.
20:14:09 <mastarija> Oh, wait.. this is not ordered?
20:14:23 <iqubic> No. This isn't ordered at all.
20:14:31 <mastarija> Damn, always forget the most important detail
20:14:33 <mastarija> :D
20:14:48 <koz_> Uhh, yeah, you kinda sorta should have mentioned that.
20:15:16 <mastarija> Hehe, sorry. It's 4 am, I'm up all night
20:15:28 <koz_> iqubic: Check the gist now - there's a nice diagram there for you.
20:15:32 <mastarija> Couldn't go to sleep, this was annoying me
20:15:42 <koz_> mastarija: So what do you mean by 'ordered' in this case?
20:16:03 <iqubic> do you have (Ord a => [a]) as the type of the list?
20:16:11 <mastarija> Node left value right
20:16:20 <mastarija> left <= value
20:16:25 <mastarija> right > value
20:16:49 <iqubic> But how do you define (<=) and (>) for the values in your list?
20:16:54 <koz_> So, you're saying you want a BST with values at leaves and internal nodes.
20:17:04 <mastarija> Yes :D
20:17:14 <iqubic> How are you ordering your values?
20:17:14 <koz_> OK, _that_ changes things considerably.
20:17:24 <mastarija> Sorry
20:17:28 <koz_> iqubic: By the order of the list elements, I'm guessing.
20:17:31 <mastarija> I'm dead atm
20:17:48 <mastarija> By comparison
20:17:59 <koz_> You can actually cheat recursion back in using fix.
20:18:10 <koz_> But I'm going to assume we're not allowed that.
20:18:16 <mastarija> yes :)
20:18:26 <koz_> I'm also guessing we're not allowed effects either?
20:18:41 <koz_> Like, no IO, no State, nothing like that?
20:18:43 <iqubic> mastarija: Right, but not all things can be ordered. What do you do if the list is full of things that don't have a given ordering?
20:18:48 <mastarija> nope
20:19:06 <mastarija> iqubic, we assume they do have ordering
20:19:16 <koz_> So, purely construct, from a list of values which are an instance of Ord, a BST with values at the nodes and leaves, gotcha.
20:19:27 <mastarija> Yep
20:19:28 <iqubic> Yes. That is what we need.
20:19:28 <koz_> _That_, admittedly, is an actual challenge.
20:20:00 <iqubic> first step is realizing that this is the wrong data structure: "data Tree a = Leaf a | Internal (Tree a) (Tree a)"
20:20:16 <koz_> iqubic: No offence or anything, but I can read. :P
20:20:20 <iqubic> Because that can't store any data at the nodes.
20:20:34 <koz_> I didn't have these parameters in the first instance, which is why I went for a leaf tree.
20:20:43 <iqubic> koz_: I was pointing that out for mastarija, and not for you.
20:20:47 <koz_> iqubic: Ah.
20:20:58 <koz_> Well, I wrote the structure, so mastarija requires no credit. :P
20:20:58 <mastarija> data Tree a = Leaf a | Node (Tree a) a (Tree a)
20:21:27 <iqubic> koz_: You've been around here long enough to know the basics of haskell. I'll assume you can come up with something here.
20:21:33 <koz_> iqubic: Lol.
20:21:49 <koz_> I'm actually trying to think how I'd attempt this.
20:21:55 <iqubic> My thought would be to download a library to do this for me, because I don't want to put in the mental effort to do it myself.
20:22:00 <mastarija> Oh shit
20:22:12 <mastarija> Wait, my brain is messed up atm
20:22:27 <mastarija> I was actually thinking of iterator, not fold
20:23:01 <koz_> I think there's an Applicative-based sorting shindig that lets you sort any Traversable.
20:23:06 <koz_> This _should_ work here I think.
20:23:24 <koz_> (although it's kinda silly, since traverse over lists is defined with recursion anyway I think)
20:23:33 <mastarija> itTree :: m -> (m -> a -> m -> m) -> Tree a -> m
20:23:38 <mastarija> this function
20:23:40 <iqubic> searching hoogle for Tree, gives me a lot of different libraries exporting leaf trees.
20:23:58 <iqubic> mastarija: What is that function supposed to do?
20:24:07 <mastarija> first argument is return value for when we have leaf
20:24:24 <mastarija> and second is for when we have left tree, value and right tree
20:24:56 <mastarija> so basically itTree does patternmatching for us to check if we have leaf or node
20:25:17 <mastarija> oh, shit
20:25:19 <iqubic> That has nothing to do with constructing trees from lists.
20:25:33 <mastarija> leaf also doesn't have a value
20:25:49 <mastarija> ok, nvm
20:25:52 <mastarija> I'm messed up
20:26:25 <koz_> mastarija: Lol, go get some sleep.
20:26:37 <mastarija> ye, see ya
21:20:50 <jsomedon> so my book says like, given `x = 100; z = (x,x)` then `:sprint z` on ghci should give `z = (_,_)` but when I do that I get `z = _` instead, I wonder what's going on
21:26:23 <koz_> jsomedon: Just checked, and this is indeed the case. What was the book in question?
21:26:45 <jsomedon> koz_: Parallel and Concurrent Programming in Haskell
21:27:16 <koz_> jsomedon: Page?
21:28:40 <jsomedon> koz_: uhm, I am reading ebook so not sure what page.. but it's on beginning part of Chapter 2 
21:29:15 <jsomedon> koz_: if you go here https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch02.html and search for "Let’s see what happens when a data structure is added:"
21:30:11 <jsomedon> koz_: and all the previous code examples involing `:sprint` works differently as the book says, kinda weird
21:30:38 <jle`> jsomedon: probably it's a polymorphism thing
21:30:53 <jle`> jsomedon: try x = 100 :: Int maybe?
21:30:54 <koz_> jsomedon: I just tried this example
21:31:00 <jle`> hm, actually that shouldn't matter
21:31:02 <koz_> let x = 1 + 2 :: Int
21:31:05 <koz_> let z = (x, x)
21:31:09 <koz_> :sprint z
21:31:13 <koz_> Did exactly what it said.
21:31:20 <koz_> Am I looking in the right place?
21:31:26 <jsomedon> yeah I think so
21:31:51 <koz_> I believe the polymorphism thing is exactly the issue here.
21:32:05 <koz_> Since the x in your example has type (Num a) => a, but in the book, Int.
21:32:22 <jsomedon> huh hold on, let me try to reproduce my error I had before
21:32:52 <jsomedon> ok
21:32:56 <jsomedon> so if I remove lt
21:32:59 <jsomedon> remove let
21:33:06 <jsomedon> I mean if I type
21:33:12 <jsomedon> x = 1 + 2
21:33:14 <jsomedon> no
21:33:19 <jsomedon> x = 1 + 2 :: Int
21:33:25 <jsomedon> z = (x,x)
21:33:29 <jsomedon> :sprint z
21:33:36 <jsomedon> then it's z = _ ??
21:34:24 <koz_> Not where I am.
21:34:38 <jsomedon> huh
21:34:47 <koz_> http://paste.debian.net/1132970/
21:35:14 <jsomedon> I am so confused
21:35:19 <koz_> I am also.
21:35:27 <koz_> Because I can't reproduce your error.
21:35:47 <jsomedon> yeah.. and if I add `let` it works like the book says
21:36:02 <koz_> jsomedon: What's your GHC version?
21:36:24 <jsomedon> 8.6.5
21:36:32 <koz_> jsomedon: Let me spin that up.
21:36:38 <iqubic> koz_: Did you finish that tree problem?
21:36:52 <koz_> iqubic: Nope.
21:37:13 <koz_> Ah-ha! Now I see the same thing you do.
21:37:26 <koz_> Let me try with let.
21:37:55 <iqubic> koz_: How many different GHC versions do you have, and how do you chose which one to run?
21:37:55 <jsomedon> :-S
21:37:59 <koz_> With 'let' it works correctly; without let, you get the answer you're seeing, but only on 8.6.5.
21:38:07 <jsomedon> :-S huh
21:38:10 <koz_> I never knew you could do something like this _without_ let.
21:38:26 <jsomedon> so some version specific bug?
21:38:43 <koz_> I don't even know what the difference between 'let x = 1 + 2 :: Int', and 'x = 1 + 2 :: Int' is.
21:38:47 <koz_> jle`: Any insights?
21:38:55 <jsomedon> I thought on ghci, with or without let make no difference?
21:39:19 <jle`> i'm on 8.8.2 and it is (_,_)
21:39:25 <jle`> so it might be a 8.6 bug
21:39:29 <jsomedon> okay
21:40:08 <koz_> I can try 8.4 if anyone's curious.
21:40:16 <jsomedon> please do :-S
21:40:39 <koz_> Confirmed on 8.4 also.
21:40:56 <jsomedon> what tools do u use to switch ghc versions? 
21:41:17 <koz_> jsomedon: Local copies of binary GHCs and cabal's -w argument.
21:41:21 <koz_> It's pretty handy.
21:41:42 <jsomedon> nice
21:41:57 <koz_> So it seems it showed up in 8.4, stuck around in 8.6, and went away in 8.8.
21:42:00 <koz_> I wonder why.
21:42:09 <iqubic> koz_: I'm using NixOS, and I can specify different GHC version fairly easisily too.
21:42:55 <jsomedon> iqubic: I use nix package manager on different distro and I don't know how to switch version?
21:43:01 <iqubic> Nice.
21:43:09 <iqubic> switching versions is kinda hard, I guess.
21:43:13 <koz_> iqubic: NixOS is kinda neat that way.
21:43:24 <iqubic> It's only simple for me, because I know how to do it already.
21:43:26 <koz_> jsomedon: There's a few Nix fans here, so they might be able to direct you.
21:44:21 <jsomedon> yeah hopefully someone reading this chat could help me with that
21:44:46 <koz_> But yeah, it is a very curious bug you've uncovered.
21:45:23 <jsomedon> and for this weird `let` issue, so technically they should make no difference, the let one and the other one, yes?
21:45:32 <jle`> they shouldn't, yeah
21:45:35 <jsomedon> okay
21:46:00 <jsomedon> I thought there is some very deep and low level difference that i dont know yet
21:46:06 <iqubic> But do they make a difference?
21:46:35 <koz_> iqubic: That's what we've been canvassing for the last little while.
21:46:53 <koz_> On at least two GHC versions, with regard to :sprint, whether you bind with let or without seems to affect the result.
21:46:57 <koz_> Even though it shouldn't.
21:47:18 <jle`> afaik there isn't supposed to be a difference
21:47:42 <jsomedon> as a side note, I am supprised to see that this book is freely available on oreilly 
21:48:28 <koz_> jle`: It's a bug whether it is or isn't; just depends on which version. :P
22:09:35 <jsomedon> iqubic: if I search for ghc on nix I only see 8.6.5, is it me or it's what it is on nix?
22:09:59 <iqubic> There are other ways to set compiler version.
22:10:05 <iqubic> But I'm not sure how to do it.
22:10:11 <jsomedon> okay..
22:10:37 <jsomedon> so the easiest way is to simple download binary from ghc's homepage I guess?
22:15:44 <arahael> jsomedon: Generally, yes, but on nix you may find that a bit trickier - generally on nix, you need to do things the nix way, which generally means using nix2cabal and/or stack.
22:16:57 <arahael> jsomedon: As for picking a different ghc, I think nix has a chapter in their manual about this. Keep in mind they have several different manuals.
22:17:12 <iqubic> https://nixos.org/nixpkgs/manual/#how-to-install-a-compiler-with-libraries.
22:17:19 <iqubic> That's the relevant section.
22:17:49 <jsomedon> ok, let me check that first
23:44:01 <ogkloo> I use stack, that worked for me well enough.
