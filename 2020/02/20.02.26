00:13:05 <mjrosenb> oompf, it looks like the lens release that added in filteredBy is newer than the latest nixpkgs release.
01:14:04 <boxscape> % case (unsafeCoerce (Dict @(Floating Double)) :: Dict (Floating Char)) of Dict -> cos 'a'
01:14:04 <yahb> boxscape: '\4607182418800017408'
01:14:09 <boxscape> % '\4607182418800017408'
01:14:09 <yahb> boxscape: ; <interactive>:20:9: error: numeric escape sequence out of range at character '2'
01:14:10 <boxscape> neat
01:16:38 <boxscape> % case (unsafeCoerce (Dict @(Fractional Double)) :: Dict (Floating Char)) of Dict -> 'a' / 'b'
01:16:38 <yahb> boxscape: '\-9223372036854775807'
01:16:43 <boxscape> even better, a negative character
01:17:23 * hackage egison-pattern-src 0.1.1.0 - Manipulating Egison patterns: abstract syntax, parser, and pretty-printer  https://hackage.haskell.org/package/egison-pattern-src-0.1.1.0 (coord_e)
01:17:33 <Cale> yahb lets you unsafeCoerce? That seems... dangerous.
01:17:47 <boxscape> yahb let's you do whatever you want, basically
01:17:50 <boxscape> %! ls
01:17:51 <yahb> boxscape: LensSplice.dyn_hi; LensSplice.hi; LensSplice.hs; THTest.hs; a.c; fdsfgf; foo; foo.txt; ghci; slkfhl.hs; test.lua; urmom
01:18:02 <dminuoso> Its unsafe because it potentially you break out of GHCi
01:18:04 <boxscape> s/let's/lets
01:18:04 <Cale> ah, fun
01:18:24 * hackage egison-pattern-src-th-mode 0.1.1.0, egison-pattern-src-haskell-mode 0.1.1.0 (coord_e): https://qbin.io/logic-source-e25m
01:18:30 <dminuoso> boxscape: Huh.
01:21:44 <boxscape> it also has a lua interpreter but I forget how to access its help to see the command for it
01:40:21 <maerwald> How do you install the profiling version of GHC from the hvr ppa? It says there is a package ghc-<ver>-prof, but there isn't 
01:43:43 <maerwald> Oh, it seems an Ubuntu dist upgrade trashed half of my config :) 
01:48:14 <maerwald> https://gist.github.com/hasufell/29657b320e35fcd12f47049f0e041348 now it fails with integer-gmp, which I'm not even using
01:50:01 <opqdonut> hmph why don't any of the TH types have Lift instances?
01:51:33 <opqdonut> or even Data instances (which would give me Lift instances)
01:53:11 <opqdonut> I need like 50 "deriving instance Lift Foo" lines to get a "deriving instance Lift Dec"
01:53:33 <opqdonut> I just want to write some quickcheck tests that use the structure of the data type
01:53:47 <opqdonut> I guess generics would be the right way...
01:54:02 <opqdonut> but I'm already invested in TH so I thought I wouldn't need two hammers
01:54:17 <fishooter> hi, how can I write something like this?
01:54:18 <fishooter> (Monad m, Traversable t) => t (a -> f a) -> f a
01:54:42 <fishooter> I prepare a list of transformations that I would like to apply
01:55:21 <fishooter> so I start with initial a, then make f a, extract second a, ... and continue
01:55:59 <fishooter> sorry, I mean
01:56:00 <fishooter> (Monad f, Traversable t) => t (a -> f a) -> f a
01:56:36 <boxscape> hm I don't think that type signature is realizable in general? Imagine if you gave the function the list [Just, Just, Just], which is `t (a -> f a)` for t ~ [] and f ~ Maybe; what would you expect it to return?
01:56:43 <dminuoso> % :t foldM
01:56:43 <yahb> dminuoso: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
01:56:47 <dminuoso> fishooter: I think you are looking for this.
01:57:23 <dminuoso> It's just a fold that admits monadic affects
01:57:39 <fishooter> yes, I think that should work
01:59:42 <boxscape> (okay I chose a bad example actually because it could return Nothing)
02:00:20 <dminuoso> boxscape: I think it can be implementable in terms of MonadFix
02:00:43 <boxscape> that could be
02:00:47 <dminuoso> At least something similar
02:03:04 <boxscape> % :t mfix . foldr (flip (<=<)) pure
02:03:04 <yahb> boxscape: (MonadFix m, Foldable t) => t (a -> m a) -> m a
02:05:07 <fishooter> :t forM
02:05:09 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
02:05:17 <fishooter> that's what I've been looking for :)
02:05:44 <fishooter> no, it's actually not
02:06:36 <dminuoso> fishooter: Your types might not be right yet. What are you trying to do?
02:07:31 <dminuoso> fishooter: Based on your description, Im confident that foldM is what you are looking for. ;)
02:23:25 <maerwald> https://github.com/haskell/cabal/issues/5930#issuecomment-591350729 any ideas? 
02:24:26 <fishooter> dminuoso: foldM was the right thing :) I was just confused
02:24:28 <fishooter> :: (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
02:24:29 <dminuoso> maerwald: Use the --profiling* flags :)
02:24:33 <fishooter> what I needed was
02:24:36 <dminuoso> maerwald: And pass them to cabal
02:24:42 <fishooter> :: (Monad m, Foldable t) => (b -> m b) -> b -> t a -> m b
02:24:55 <maerwald> dminuoso: that's what I did. See the config
02:25:19 <dminuoso> fishooter: Are you sure about that? You're ignoring the contents of your foldable?
02:26:02 <dminuoso> fishooter: It seems to me, that you just need its length, and then some kind of `selfReplM :: a -> Int -> (a -> m a) -> m a`
02:26:09 <fishooter> dminuoso: basically I have a large tic-tac-toe board game, and I'm trying to generate valid random instances of the board, i.e. ones that can arise from actual play. So I fill cells of the board one by one
02:26:13 <fishooter> foldM fillCell empty [1 .. moves]
02:26:19 <fishooter> this is the code I have
02:26:24 <fishooter> and fillCell :: Game -> Int -> Gen Game
02:26:36 <fishooter> but I ignore the int, because it doesn't matter which move number it is
02:26:57 <dminuoso> Couldn't you just use traverse?
02:27:11 <dminuoso> I mean you already have the index of the list, so you know everything already
02:28:04 <fishooter> I don't think traverse is what I want
02:28:47 <fishooter> why can't I use bang on list?
02:28:50 <fishooter> [1,2,3] ! 0
02:28:58 <fishooter> Variable not in scope: (!) :: [Integer] -> Integer -> t
02:29:46 <ski> fishooter : it is for arrays, not lists
02:29:52 <fishooter> ah, it's !! for lists
02:29:55 <fishooter> I forgot :)
02:30:27 <maerwald> Seems profiling doesn't work well with cabal
02:30:34 <boxscape> though typically if you need !!, lists might not be the right data structure
02:30:54 <fishooter> dminuoso: https://pastebin.com/8d98vXFy
02:31:00 <fishooter> this is what I've come up with
02:31:13 <maerwald> Back to stack then. 
02:31:58 <fishooter> basically I would just like to drop the -> Int from fillCell
02:33:32 <__monty__> maerwald: What do you mean profiling doesn't work with cabal? Sounds like you're giving up pretty quickly.
02:33:56 <maerwald> Check the linked issue
02:34:19 <maerwald> Already wasted half an hour going through 4 years old tickets ;) 
02:44:06 <fendor> I also had bad experiences with cabal and profiling. Mainly with cabal install, though, it does not seem to honour ghc flags
02:44:12 <fendor> or at least some
02:44:44 <maerwald> Yes, I'm installing the binary
02:45:36 <maerwald> When I do cabal run, it wants to rebuild everything... 
02:45:46 <maerwald> That indicates something is broken
02:48:55 <__monty__> maerwald: Are you sure you want to pass the rts options to ghc? Shouldn't you be passing those to the program you want to profile?
02:49:29 <maerwald> Doesn't matter if I remove it or not
02:53:11 <__monty__> maerwald: What exact steps are you performing?
02:53:25 <maerwald> cabal install
02:54:47 <__monty__> And why are you expecting profiling output from that?
02:55:42 <fendor> cabal install --enable-profiling doesnt work, either
02:55:44 <maerwald> Because I configured my executables to be built with profiling
02:55:56 <maerwald> Why would it not work? 
02:55:58 <maerwald> ??? 
02:56:55 <__monty__> You should pass the rts options to produce profiling output to that executable.
02:58:06 <maerwald> I did
02:58:17 <maerwald> Works on stack as expected, not on cabal. 
03:02:36 <__monty__> And have you tried v2-run -- +RTS -p?
03:03:24 <maerwald> I want to run the executable without cabal
03:05:44 <__monty__> But have you tried?
03:06:29 <LehAxe2> Hello everybody!
03:09:00 <jsomedon> what is this `:|` in `data Stream a = a :| Stream a`
03:10:50 <Taneb> jsomedon: it's a data constructor
03:11:06 <yushyin> usually the infix constructor of non empty lists
03:11:07 <Taneb> Similar to "Just" (but of course a different type)
03:11:12 <Taneb> It's one that happens to be an operator
03:11:34 <Taneb> (like (:))
03:11:42 <ski> @src []
03:11:42 <lambdabot> data [] a = [] | a : [a]
03:13:32 <jsomedon> ok so you guys are saying the code above essentially is: data Stream a = (:|) a (Stream a)
03:19:58 <dminuoso> jsomedon: Right.
03:20:29 <dminuoso> jsomedon: The only subtle difference is say, the deriving generated show instances will place (:|) in prefix position in the latter, and in infix position in the former case.
03:32:06 <jsomedon> ok so I am really confused, how can I write a valid Stream value of such type
03:32:30 <ski> jsomedon : `repeat' is one simple example
03:32:41 <boxscape> @src repeat
03:32:41 <lambdabot> repeat x = xs where xs = x : xs
03:32:51 <ski> @type repeat
03:32:53 <lambdabot> a -> [a]
03:33:09 <ski> @type enumFrom
03:33:11 <lambdabot> Enum a => a -> [a]
03:33:20 <ski> would be another one you could try
03:33:42 <ski> @type unfoldr
03:33:43 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:33:54 <ski> something like that could also be done (albeit a simpler version)
03:35:52 <ski> then you can write `map',`filter`,`partition',`tail',`drop',`dropWhile',`take',`takeWhile',`splitAt',`span',`break',`concat',`chunksOf',..
04:10:36 <boxscape> % f :: Bool -> Void -> a; f a b = case (a, b) of
04:10:36 <yahb> boxscape: ; <interactive>:19:33: warning: [-Wincomplete-patterns]; Pattern match(es) are non-exhaustive; In a case alternative: Patterns not matched: (_, _)
04:10:37 <boxscape> :(
04:10:41 <boxscape> it is complete though
04:13:04 <dminuoso> boxscape: The pattern match exhaustiveness checks are really adhoc and super error prone.
04:13:14 <dminuoso> There have been so many bug reports about it..
04:13:37 <dminuoso> SPJ gave an interesting talk during last haskell exchange about it, and how it's going to be addressed properly in the future
04:13:58 <dminuoso> Once skillscasts are up again, you can take a look at it. Hopefully within the next few weeks
04:14:09 <ski> > case (False,undefined :: Void) of !_ -> ()
04:14:11 <lambdabot>  ()
04:14:22 <boxscape> dminuoso yeah, I saw the talk :)
04:14:29 <ski> > case undefined :: Void of
04:14:29 <boxscape> (the recording of it)
04:14:32 <lambdabot>  <hint>:3:23: error: parse error on input ‘}’
04:14:36 <ski> % case undefined :: Void of
04:14:37 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:25:6 in interactive:Ghci12
04:15:19 <dminuoso> I dont recall whether nullary data types were covered in that desugaring though
04:15:32 <dminuoso> (nullary? maybe I should call them Void types)
04:15:33 <boxscape> well, it works if it's not inside a tuple
04:15:46 <dminuoso> % f :: Bool -> Void -> a; f a b = case (b, a) of
04:15:46 <yahb> dminuoso: ; <interactive>:26:33: warning: [-Wincomplete-patterns]; Pattern match(es) are non-exhaustive; In a case alternative: Patterns not matched: (_, _)
04:16:00 <dminuoso> % data Pair a b = Pair a b
04:16:00 <yahb> dminuoso: 
04:16:06 <boxscape> % absurd :: Void -> a; absurd = \case
04:16:07 <yahb> boxscape: 
04:16:07 <dminuoso> % f :: Bool -> Void -> a; f a b = case Pair a b of
04:16:08 <yahb> dminuoso: ; <interactive>:29:33: warning: [-Wincomplete-patterns]; Pattern match(es) are non-exhaustive; In a case alternative: Patterns not matched: (Pair _ _)
04:17:01 <ski> iiuc, a branch-less `case' forces its scrutinee
04:17:22 <boxscape> yes
04:17:22 <dminuoso> boxscape: Come to think of it, I dont think an empty case is a valid thing to do here.
04:17:31 <boxscape> oh
04:17:34 <boxscape> right
04:17:43 <ski> (so as to expose the fake "proof" of the empty type, assuming it's empty, rather than the matching being inexhaustive=
04:17:46 <ski> )
04:17:49 <boxscape> % f :: Bool -> Void -> a; f a b = case (# a, b #) of
04:17:49 <yahb> boxscape: ; <interactive>:30:33: warning: [-Wincomplete-patterns]; Pattern match(es) are non-exhaustive; In a case alternative: Patterns not matched: (_, _)
04:18:03 <boxscape> I don't know if an unboxed tuple is any better from that perspective
04:18:07 <ski> however, forcing `(False,undefined :: Void)' won't "expose" `undefined' there
04:18:18 <ski> interesting
04:18:28 <boxscape> % case (# (), undefined #) of (# a, b #) -> a
04:18:28 <yahb> boxscape: ()
04:18:39 <ski> yea
04:18:47 <boxscape> okay well, never mind I suppose
04:18:49 <dminuoso> Indeed, that example with an unboxed tuple should not error out.
04:18:54 <ski> you'd need a tuple with strict components
04:19:18 <dminuoso> % data Pair a a = Pair (!a) (!a)
04:19:19 <yahb> dminuoso: ; <interactive>:32:11: error:; Conflicting definitions for `a'; Bound at: <interactive>:32:11; <interactive>:32:13
04:19:25 <dminuoso> % data Pair a b = Pair (!a) (!b)
04:19:26 <yahb> dminuoso: ; <interactive>:33:23: error:; * Unexpected strictness annotation: !a; strictness annotation cannot appear nested inside a type; * In the type `(!a)'; In the definition of data constructor `Pair'; In the data declaration for `Pair'
04:19:38 <boxscape> no parens?
04:19:43 <dminuoso> % data Pair a b = Pair !a !b
04:19:43 <yahb> dminuoso: 
04:19:47 <dminuoso> Huh.. strange..
04:20:07 <boxscape> % f :: Bool -> Void -> a; f a b = case Pair a b of
04:20:08 <yahb> boxscape: ; <interactive>:35:33: warning: [-Wincomplete-patterns]; Pattern match(es) are non-exhaustive; In a case alternative: Patterns not matched: (Pair _ _)
04:20:31 <dminuoso> boxscape: I think its cases like this (no pun intended!) that SPJ were talking about, when he mentioned all these bizarre edge cases.
04:20:38 <boxscape> makes sense
04:21:21 <boxscape> % case Pair () undefined of Pair a b -> a
04:21:21 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:36:14 in interactive:Ghci20
04:22:03 <dminuoso> Just out of curiosity, you're not really wanting to write some `absurdSnd :: (a, Void) -> b`, right?
04:22:25 <boxscape> Oh, no, I'm just thinking about this in the context of multi-pattern case expressions
04:22:32 <boxscape> working on refining this https://github.com/ghc-proposals/ghc-proposals/pull/302
04:22:43 <boxscape> and allowing 0 clauses isn't part of it but is an alternative
04:24:08 <boxscape> (well, technically multi-clause lambda expressions, not multi-pattern case)
04:24:21 <ski> that proposal looks nice :)
04:24:30 <boxscape> thanks :)
04:24:50 <ski> (haven't looked at the details yet, though)
04:25:43 <ski> (in SML, `case <scrutinee> of <pattern> => <expression> | ...' is defined in terms of `(fn <pattern> => <expression> | ...) <scrutinee>')
04:25:50 <dminuoso> boxscape: Oh interesting, that name looks suspiciously German.
04:25:59 <boxscape> dminuoso it might just be
04:26:23 <dminuoso> boxscape: Are you going to come to bobkonf this Friday?
04:26:35 <boxscape> I'm afraid I'm not aware of bobkonf :(
04:26:45 <dminuoso> boxscape: https://bobkonf.de/2020/de/
04:27:16 <boxscape> thanks, I'll take a look but probably a bit late now
04:27:22 <ski> (however, i think `fn' in SML is only single-argument)
04:28:16 <ski> (also cf. designated initializers in C, and table expressions in GF)
04:28:59 <boxscape> what is GF?
04:29:27 <ski> @where GF
04:29:27 <lambdabot> Grammatical Framework, dependently typed FPL, categorial grammar formalism, supporting multilingual grammar applications for e.g. natural language processing, at <http://www.grammaticalframework.org/
04:29:27 <lambdabot> >. (An old `Alfa' interface is at <http://web.archive.org/web/*/http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>)
04:29:34 <boxscape> I see
04:29:39 <dminuoso> Oh, I was trying to make sense what table expressions have to do with galois fields.
04:29:46 <ski> also see channel #gf
04:31:32 <ski> (probably also some kind of array initializers in SAC)
04:34:20 <Cale> A fun rule of thumb that I've used for a while but the statement of which just became clear in my head: If you have a data type with n constructors but in your entire program, it is pattern matched on m < n times, then you're often better off replacing the data type with one which is a record of the conclusions of those pattern matches, and simply defining appropriate constants of that record type.
04:34:38 <__monty__> I'm looking for a thorougher path normalisation function than the one in `filepath`. `System.FilePath.normalise` doesn't eliminate `dir/..` from `dir/../rest/of/path`. Does anything come to mind?
04:35:05 <ski> that's cute, Cale :)
04:36:03 <maerwald> __monty__: that is not a filepath function. That's is IO. Check Unix package for realpath
04:36:20 <reactormonk> How would you calculate the log 2 of a very large Integer? doing it incrementally doesn't seem to go over very well and I don't see anything on gmp I could use.
04:36:22 <ski> Cale : now i'm wondering about a refactoring action to effect such a switch ..
04:36:41 <sshine> reactormonk, tables?
04:36:57 <Cale> There must be a way to get the bit size...
04:37:19 <Cale> https://hackage.haskell.org/package/integer-gmp-0.5.1.0/docs/GHC-Integer-Logarithms.html
04:37:22 <sshine> reactormonk, log(a*b) = log(a)+log(b)?
04:37:32 <__monty__> maerwald: What do you mean? Why would it require IO?
04:37:52 <reactormonk> Cale, ah duh, thanks.
04:38:45 <__monty__> maerwald: Is it because of symlinks?
04:41:38 <dminuoso> What's the most simplistic library to provide a single HTTP endpoint that merely accepts a file and responds with a static string?
04:42:15 <maerwald> __monty__: I think so
04:44:18 * ski idly wonders why `..' simply doesn't retrace back the symlink
04:46:06 <dminuoso> Ah well screw it, Ill just make it a servant-server. Dependencies be damned.
04:46:25 <lortabac> dminuoso: warp
04:46:38 <Cale> dminuoso: Isn't scotty smaller?
04:46:43 <__monty__> ski: By retrace do you mean the posix or windows behavior?
04:47:00 <Cale> oh, yeah, that just uses warp
04:47:17 <sshine> scotty is on top of warp
04:47:20 <sshine> spock is on top of scotty
04:47:22 <maerwald> ski: why would it? 
04:47:32 <maerwald> .. Is a file
04:47:48 <maerwald> And it points to a parent. It has nothing to do with filepaths per se
04:47:54 <dminuoso> Cale: At first glance the dependency footprint looks similar.
04:48:01 <maerwald> How would it know where you came from
04:48:17 <dminuoso> But you are right, perhaps scotty is a bit less hassle.
04:48:23 <dminuoso> It's a good idea, thanks.
04:48:38 <ski> __monty__ : i mean so that entering `foo', followed by `...', would always be (effectively) a noop
04:48:59 <Cale> dminuoso: Just pointing out that I noticed that it just depends on warp, so you could probably use warp directly
04:49:10 <ski> maerwald : i know. i'm wondering what would be the ramifications, if that wasn't the case
04:49:17 <Cale> Another option is to use snap-server
04:49:53 <ski> if `..' was more a property of your traversal of the file-system, than an actual part of it
04:50:15 <Cale> quickHttpServe :: Snap () -> IO ()
04:50:23 <maerwald> ski: that would mean .. to not be a file, but a shellism
04:50:42 <Cale> writeBS :: MonadSnap m => ByteString -> m ()
04:50:46 <maerwald> Like ~
04:50:48 <Cale> put those two things together :)
04:50:53 <ski> maerwald : yes
04:51:03 <__monty__> ski: Sounds like the windows behavior.
04:51:16 <Cale> oh, you want to accept a file upload?
04:51:23 <dminuoso> Yeah.
04:51:24 * ski is not familiar with the windows behavior
04:51:33 <dminuoso> Nothing more, no data. Just the raw file upload.
04:51:42 <Cale> https://hackage.haskell.org/package/snap-core-1.0.4.1/docs/Snap-Util-FileUploads.html -- that's more involved, but doable in snap...
04:51:50 <maerwald> ski: and then what do you do if there is a .. File? That problem already exists with ~
04:51:50 <Cale> Haven't looked at how to do it with warp
04:52:22 <ski> maerwald : either disallow it, or provide some escape
04:52:54 * hackage lorentz 0.1.0 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.1.0 (gromak)
04:52:59 <maerwald> You want to disallow filenames because of your shell implementation? 
04:53:13 <Cale> lol, but the snap code for pretty much exactly what you're trying to write is immediately there in the documentation
04:53:26 <maerwald> It's all hairy 
04:53:34 <ski> i haven't said anything about wanting
04:54:27 <ski> (but thank you for the objection)
04:54:34 <dminuoso> Nah, I dont even need to render any HTML pages. It's just some third party wanting to regularly transmit files to us.
04:54:59 <Cale> dminuoso: In that case, you can just delete that handler
04:55:08 <Cale> and just keep the do-upload one, I guess
04:58:03 <__monty__> ski: The documentation for canonicalizePath states if `L -> R/P`, Posix: `L/..` == `R` Windows: `L\..` == `.`
04:58:45 <ski> i see
04:58:53 <ski> ty
05:03:54 * hackage rebase 1.6 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.6 (NikitaVolkov)
05:09:23 * hackage rerebase 1.6 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.6 (NikitaVolkov)
05:09:37 <jsomedon> hey guys, was afk and back now, I am still confused that given definiton `data Stream a = a :| Stream a` what a valid value of Stream type look like. For example, for type `Stream Bool`, that should be like `True:|False:|True:|...(endless so I can't really write it out)`. I tried using `repeat`, and this is what can come up: foldr \s->\b->b:|s someStream (repeat True) but here I have same problem,
05:09:39 <jsomedon> I don't know what `someStream` should look like..
05:11:29 <boxscape> jsomedon rather than using the existing repeat on lists, the idea was to implement a new repeat function for streams
05:11:38 <boxscape> I think, at least
05:12:09 <boxscape> :t repeat
05:12:10 <lambdabot> a -> [a]
05:12:17 <boxscape> so the function should be `repeat :: a -> Stream a`
05:12:27 <jsomedon> ah
05:13:38 <jsomedon> so like `repeatStream a = a:|(repeatStream a)`
05:13:41 <fishooter> I have a list of length m. I'd like to make a "modulus" accessor of elements of the list. For example, if m=3, xs=[0,1,2] then I can use i `mod` 3 to wrap around accessing. This works for positive i. What is a suitable way to make it work for negative values as well? ie i = -1 should be mapped to 2.
05:13:49 <boxscape> jsomedon exactly
05:14:23 <jsomedon> boxscape: okay, so I guess it's impossible to write a valid value out by hand?
05:15:09 <ski> jsomedon : here's one valid value, written by hand :
05:15:28 <ski>   let repeatStream a = a :| repeatStream in repeatStream False
05:15:56 <boxscape> also possible without the function call; `let s = 'a' :| s in s` is an expression that has type `Stream Char`.
05:16:04 <ski> > (-1) `mod` 3  -- fishooter
05:16:07 <lambdabot>  2
05:16:29 <jsomedon> ah I see
05:16:37 <ski> > let ones = 1 : ones in ones
05:16:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:16:41 <jsomedon> makes perfect sense now
05:16:50 <ski> > fix (1 :)
05:16:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:17:11 <boxscape> jsomedon any function that can, on some inputs, produce an infinite list, should be adjustable to produce a Stream instead
05:17:34 <ski> jsomedon : next, define `fibs :: Stream Integer' to contain the fibonacci sequence, starting with `[0,1,1,2,3,5,8,13,...]'
05:17:46 <ski> jsomedon : you can also define `primes :: Stream Integer', if you want to
05:18:11 <fishooter> ski: omg, I forgot to use parenthesis :) that's why it didnt' work properly
05:18:15 <fishooter> thanks
05:18:18 <boxscape> @quote is.incorrect
05:18:19 <lambdabot> xahlee says: It says: "A curried function is a function which returns a function as its result." LOL. That is incorrect.
05:18:21 <boxscape> is it reallt?
05:18:27 <boxscape> s/t/y
05:20:35 <ski> @palomer
05:20:36 <lambdabot> They're telling you lies!
05:20:37 <merijn> Can't say, I always forget which way is curried and which way isn't :p
05:21:29 <ski> curried is the way which is not tupled
05:31:23 * hackage deriving-aeson 0.1 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.1 (FumiakiKinoshita)
05:36:10 <jsomedon> ski : huh it's hard :-(
05:37:10 <ski> which ?
05:37:31 <ski> jsomedon : can you make a version of `enumFrom', for `Stream', at first, perhaps ?
05:37:38 <jsomedon> ski : so I have `fib::Int->Int` defined, so like `fib 0 = 0; fib 1 = 1; etc`, and I have no idea how to use that to make `fibs`
05:38:24 <ski> well .. that definition of `fib' should only (at most) serve as some inspiration
05:38:58 <ski> (iow, i'm not suggesting you actually go and call this `fib', when defining `fibs')
05:39:24 * hackage deriving-aeson 0.1.1 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.1.1 (FumiakiKinoshita)
05:39:32 <jsomedon> so more like the recursion is defined inside `fibs` itself u mean?
05:39:56 <ski> however, maybe (or maybe not) it could help if you first defined a version of `fib' which didn't have exponential complexity ?
05:40:09 <ski> something like that, yes, jsomedon
05:40:47 <ski> but i think it might also help to do `enumFrom' first
05:41:02 <jsomedon> okay i will try enumFrom first
05:41:03 <ski> (do it for just `Integer's, if you prefer)
05:41:09 <ski> > enumFrom 23
05:41:12 <lambdabot>  [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,...
05:41:31 <jsomedon> so basically each new one is +1 on previous one
05:41:36 <ski>   fromStream :: Integer -> Stream Integer
05:41:54 <ski> hm, maybe that would better be named `streamFrom' ?
05:42:17 <ski> (`fromStream' sounds like it's converting a stream to something, i just realized)
05:42:32 <lhurttila> Is is possible to define a custom data type with a changing contructor amount?
05:42:48 <ski> (you could say `streamUpFrom', if you prefer that)
05:43:08 <ski> what does "changing constructor amount" mean ?
05:43:10 <jsomedon> lol okay
05:43:48 <ski> each `data' type definition has a definite number of data constructors
05:45:37 <lhurttila> ski I mean makin a type with Data Typex = Typex Int, Int, ... , Int with variable amount of Ints in this case
05:45:57 <boxscape> so one constructor with a variable number of parameters?
05:46:02 <lhurttila> yes
05:46:12 <ski> not possible
05:46:16 <asheshambasta> Does anyone know of any resources on how to compose multiple Servant AuthHandlers? 
05:46:23 <ski> you can make it take a list or something, though
05:46:49 <alp> asheshambasta, what do you mean by "compose" here?
05:47:21 <ski> (array or vector might be better, depending)
05:47:42 <asheshambasta> alp: I mean something like chaining multiple auth. handlers, I have 1 AuthHandler Request User  and I'd like another one AuthHandler User AdminUser, and I'd like to chain the two.
05:47:42 <lhurttila> so Data Typex = Typex [Int, Int, ... , Int] should work with practically any number of Ints?
05:48:22 <ski> lhurttila : `data Typex = MkTypex [Int]' would
05:49:25 <lhurttila> That's what i meant :P  thanks
05:49:39 <ski> np
05:50:05 <ski> lhurttila : if there's only one data constructor, with only one component, you could use `newtype' in place of `data'
05:50:37 <jsomedon> `s=1:|s` vs `let s=1:|s in s` how are they different?
05:51:00 <jsomedon> in the context of my Stream definition
05:51:01 <ski> the former isn't an expression (it's a definition). the latter is (an expression)
05:51:10 <jsomedon> ah
05:51:20 <alp> asheshambasta, hah, well I guess servant could offer a function for this, but you can write it too! composeAuth :: AuthHandler a b -> AuthHandler b c -> AuthHandler a c; composeAuth (AuthHandler fab) (AuthHandler fbc) = AuthHandler $ \a -> ... -- fill in the blanks. let me know if you have trouble figuring it out :-) but ghci and typed holes should be of help here
05:51:25 <jsomedon> then both gives me same value for `s` right? ski
05:51:33 <jsomedon> *give*
05:51:41 <ski> both defines the same `s', yes
05:52:32 <lhurttila> ski right. I think one is enough here so newtype it is
05:53:08 <asheshambasta> alp: yeah, that was the route I was going as well, but I was feeling I was missing something. Does this also mean I can nest `AuthProtect`'s as well at my API type?
05:53:17 <jsomedon> ski then I guess `streamFrom a = a:|(streamFrom (a+1))`
05:53:46 <ski> good, jsomedon :)
05:53:54 <asheshambasta> That is, something on the lines of: ```AuthProtect "AuthReq2User" :> AuthProtect "User2Admin" ... ``` etc. 
05:53:59 <ski> (although some redundant brackets)
05:54:12 <maerwald> Does someone remember why ImplicitParameters are unpopular? 
05:54:13 <asheshambasta> and what will the "context" type look like in hoistServerWithContext? and serveWithContext? 
05:54:18 <ski> jsomedon : now, a linear-complexity version of `fib' ?
05:54:45 <asheshambasta> I guess what I'm also trying to ask is: can the same API provide multiple types of AuthHandler's? 
05:55:19 <alp> asheshambasta, I think you can do that yes. you should check, but I'm thinking that would work, or could be made to if it doesn't already.
05:57:08 <alp> asheshambasta, the context would have to contain an auth "handler" per "AuthProtect" in the API type. I guess one constraint though is that the 'AuthHandler's must have different types
05:57:33 <alp> (because we lookup 'AuthHandler's in the context based on their type.)
05:58:19 <alp> (well, we lookup anything in contexts based on their types. we do have some machinery for named things, but it's not used by existing combinators IIRC)
06:01:16 <alp> but there's otherwise nothing standing in the way of using several 'AuthProtect's in an API type, even on the same endpoints. I just checked and the router doesn't drop previous auth checks when you add one, so they should all occur just fine and the handlers should receive one argument per AuthProtect. as long as the "user type" is different this will work.
06:02:40 * ski idly glances at zceejkr
06:02:45 <asheshambasta> ah okay, composing multiple AuthHandlers is rather trivial actually; and it falls into place nicely: https://gist.github.com/asheshambasta/cfc4273ad13b1a36170501dbd6a2ef72
06:02:48 <int-e> maerwald: I'm inclined to say that they just don't solve any actual problem (explicit parameters aren't a huge burden, and you can always use a reader monad if you prefer that). And the syntax is ugly and makes the flow of information harder to understand.
06:03:12 <zceejkr> hi ski
06:03:23 <zceejkr> Free to continue?
06:04:37 <int-e> :t [()] ++ ?a -- they have a use similar to typed holes, here.
06:04:39 <lambdabot> (?a::[()]) => [()]
06:05:39 <ski> yea, zceejkr
06:06:11 <int-e> maerwald: There's also the namespace problem that means you can't mix two functions that both have a named parameter called 'foo' but with different meaning.
06:06:34 <int-e> (can't --> can't easily)
06:06:48 <ski> zceejkr : to recap, last time, we finished up that rank-two for implementation hiding example, also talking a bit about `fix', polymorphic recursion, and irregular `data' types
06:06:51 <alp> asheshambasta, even if you need the same user type, you could play a tiny trick or two to make things work, tweaking your user type ever so slightly. e.g: data User (auth :: Symbol) = User { ... normal def ... }; type instance AuthServerData "auth1" = User "auth1"; type instance AuthServerData "auth2" = User "auth2"; type API = AuthProtect "auth1" :> AuthProtect "auth2" :> ...; 
06:08:19 <alp> asheshambasta, that'd be enough to make the types of the auth handlers differ. one would lookup a `User "auth1"` value, the other a `User "auth2"`. and most of your functions would simply be polymorphic in that 'auth' tag
06:08:42 <alp> anyway, that's probably more than enough for you to proceed =)
06:09:53 * hackage lean-peano 0.1.1.0 -   https://hackage.haskell.org/package/lean-peano-0.1.1.0 (oisdk)
06:10:20 <asheshambasta> hmmm, actually, I'm quite lost on what context to supply to hoistServerWithContext when using authentication contexts that are nested.
06:11:09 <asheshambasta> and it seems like I'm missing an instance: https://gist.github.com/asheshambasta/341d61c28ee6cf54d1f10ac598525c16
06:11:17 <asheshambasta> I'm not really sure why.
06:12:20 <dminuoso> Mmm, should hackage-mirror upload packaged while it's collecting from the source hackage? Or does it upload them to the local after it has fetched all packages?
06:13:56 * ski looks at zceejkr
06:14:04 <zceejkr> sorry ski
06:14:12 <zceejkr> i had a phonecall
06:14:20 <zceejkr> one moment
06:17:19 <ski> np
06:18:08 <zceejkr> okay, i am done now. So last thing I remember was perfectly balanced binary trees. Tree a = Leaf a | Tree (a, a).
06:18:18 <zceejkr> Something like this.
06:18:55 <ski> yea
06:19:23 <zceejkr> These are irregular data types - where the type on the right of the equation is not the same as on the left (i.e. a vs (a,a))
06:19:28 <zceejkr> Correct?
06:19:42 <ski> it was an example of an irregular `data' type, and recursion over those are almost always polymorphic recursion
06:20:12 <zceejkr> I see.
06:20:29 <ski> where the parameters used in the "recursive call" of the data type aren't the same as the parameters used in the definiendum ("to the left"), yes
06:21:01 <ski> hm, perhaps i should clarify one more thing about monomorphic vs. polymorphic recursion
06:21:35 <ski> (while we're on this topic, i mean)
06:21:50 <ski> relating it to the explicit type-passing view of polymorphism
06:22:37 <ski> consider `map'
06:22:55 <ski>   map :: forall a. forall b. (a -> b) -> ([a] -> [b])
06:23:09 <ski>   map _ [    ] = [            ]
06:23:19 <ski>   map f (x:xs) = f x : map f xs
06:23:34 <ski> where `forall a. forall b.' would normally be abbreviated as `forall a b.'
06:24:47 <ski> now, let's say we want to use the `TypeApplications' extension, and also the imagined corresponding extension that allows "the same thing", also in patterns (so not only in expressions)
06:25:27 <ski> then, the direct/obvious way to make the type-passing relating to the polymorphism in `map' explicit, would be to make the definition be
06:25:33 <ski>   map :: forall a. forall b. (a -> b) -> ([a] -> [b])
06:26:03 <ski>   map @_ @_ _ [    ] = [                  ]
06:26:18 <ski>   map @a @b f (x:xs) = f x : map @a @b f xs
06:26:25 <ski> is this clear, zceejkr ?
06:26:32 <zceejkr> yep. 
06:27:05 <ski> now, if we write it like this, this would, technically speaking, actually be polymorphic recursion
06:27:23 <ski> to make it into monomorphic recursion, we could change the definition into
06:27:27 <ski>   map :: forall a. forall b. (a -> b) -> ([a] -> [b])
06:27:45 <ski>   map @a @b = map_a_b
06:27:47 <ski>     where
06:27:57 <ski>     map_a_b :: (a -> b) -> ([a] -> [b])
06:28:19 <ski>     map_a_b _ [    ] = [                ]
06:28:37 <ski>     map_a_b f (x:xs) = f x : map_a_b f xs
06:29:21 <ski> now we clearly see that `map_a_b' is monomorphic (using the specific, unknown, types, that `map' has received from its caller)
06:29:39 <ski> in fact, since the `f' parameter doesn't change either, we could make this into
06:29:43 <ski>   map :: forall a. forall b. (a -> b) -> ([a] -> [b])
06:29:51 <ski>   map @a @b f = map_a_b_f
06:29:59 <ski>     where
06:30:07 <zceejkr> so (map @Int @Bool) would only work on (Int -> Bool) and [Int] in this definition
06:30:08 <zceejkr> ?
06:30:09 <ski>     map_a_b_f :: [a] -> [b]
06:30:26 <ski>     map_a_b_f [    ] = [                ]
06:30:36 <ski>     map_a_b_f (x:xs) = f x : map_a_b_f xs
06:31:01 <ski> so that not only is `a' and `b' used as nonlocals, in the definition of the inner (recursive) operation, but also `f'
06:31:51 <ski> zceejkr : yes, for `map @Int @Bool', the particular `map_a_b' being used would have type `(Int -> Bool) -> ([Int] -> [Bool])'. `map_a_b' would be monomorphic
06:33:04 <zceejkr> I see.
06:33:27 <ski> however, let's consider again
06:33:36 <ski>   data PBBT a = Elems a
06:33:54 <ski>               | Double (PBBT (a,a))
06:34:08 <ski> (`PBBT' abbreviating `PerfectlyBalancedBinaryTree'´)
06:34:21 <ski> now, let's write
06:34:37 <ski>   mapPBBT :: forall a b. (a -> b) -> (PBBT a -> PBBT b)
06:34:51 <ski> would you like to give it a try ?
06:35:03 <zceejkr> sure
06:35:46 <zceejkr> mapPBBT f = mapPBBT'
06:35:57 <zceejkr> where 
06:36:11 <ski> (we could have done a `mapBinaryTree' for the usual kind of `data BinaryTree a = Leaf a | Branch (BinaryTree a) (BinaryTree a)' first. but i think you probably see how that would work, and how that would also be monomorphically recursive)
06:37:02 <zceejkr> mapPBBT' (Elems a) = Elems (f a)
06:37:24 <zceejkr> (I think I already made a mistake but let me try the last one anyway)
06:37:31 <ski> (yes)
06:39:35 <zceejkr> mapPBBT' (Double tree) = Double (mapPBBT f tree)
06:40:13 <ski> yes ?
06:40:42 <zceejkr> So this is okay?
06:40:48 <ski> do you see any problem here ? or should it work, you think ?
06:40:55 <zceejkr> Let me think.
06:41:43 <zceejkr> So when f is used in Double (mapPBBT f tree), if it's still polymorphic f this is okay/
06:41:56 <zceejkr> But if it has been "monomorhped" it is not.
06:42:19 <ski> `f' is never polymorphic, here
06:42:40 <zceejkr> ah, right. map is polymorphic
06:42:54 <ski> `f' has type `a -> b'. it does not have a type looking like `forall x. ..x..'
06:43:26 <zceejkr> So I think there is a problem.
06:43:34 <ski> where ?
06:43:40 <zceejkr> In Elems (f a) i am appying f to type a.
06:43:50 <ski> to a value of type `a', yes
06:44:17 <zceejkr> In (mapPBBT f tree) it will be applied to values of type (a, a) (or even more nested).
06:44:38 <zceejkr> But f has type (a -> a). 
06:44:51 <ski>   f :: a -> b  -- rather
06:44:58 <ski> what's the type of `tree', there ?
06:45:10 <zceejkr> PBBT (a, a)
06:45:25 <zceejkr> Ah
06:45:27 <zceejkr> Wait
06:46:10 <zceejkr> mapPBBT' (Double tree) = Double (mapPBBT (\(a, b) -> (f a, f b)) tree)
06:46:51 <ski> (if you prefer to, after we've "stepped inside" the `forall a b.', you could refer to the types as `?a' and `?b', in order to make it clear that e.g. `f :: a -> b' doesn't mean `f :: forall a b. a -> b'. so writing `f :: ?a -> ?b' instead. or else, we can just keep in mind that `a' and `b' here are to be regarded as specific, abstract, unknown, forgotten, hidden, opaque types)
06:47:13 <ski> (yes, that's the type of `tree' here)
06:47:28 <ski> that would work fine, zceejkr :)
06:47:51 <zceejkr> :)
06:47:52 <ski> however, if you want to, you can now inline  mapPBBT'  into  mapPBBT
06:48:02 <ski> (since the former isn't (directly) recursive)
06:48:18 <ski> doing that, we arrive at
06:48:38 <ski>   mapPBBT :: forall a. forall b. (a -> b) -> (PBBT a -> PBBT b)
06:49:12 <ski>   mapPBBT f (Elems a)    = Elems (f a)
06:49:44 <ski>   mapPBBT f (Double tree) = Double (mapPBBT (\(a,b) -> (f a,f b)) tree)
06:50:02 <ski> (agree ?)
06:50:06 <zceejkr> yes
06:50:29 <ski> now, if you were to insert explicit type-passing, how would this definition look like, then ?
06:50:58 <zceejkr> mapPBBT :: forall a b. (a -> b) -> (PBBT a -> PBBT b)
06:52:21 <zceejkr> mapPBBT @a @b = mapPBBT_a_b
06:52:23 <zceejkr> where
06:53:27 <zceejkr> mapPBBT_a_b f (Elems x) = Elems (f x)
06:54:06 <zceejkr> let me start over
06:54:15 <zceejkr> mapPBBT :: forall a b. (a -> b) -> (PBBT a -> PBBT b)
06:54:32 <zceejkr> mapPBBT @a @b f (Elems x) = Elems (f x)
06:55:29 <zceejkr> mapPBBT @a @b f (Double tree) = Double (mapPBBT @(a, a) @b f tree) 
06:55:45 <zceejkr> Now there is a problem again
06:55:46 <zceejkr> with f
06:55:59 <ski> you're not quite there, but close
06:56:15 <ski> (you already solved the `f' problem, before)
06:56:35 <zceejkr> I am wondering if it is possible to do it without touching f
06:56:44 <zceejkr> Just by this type application @(a, a)
06:57:15 <zceejkr> mapPBBT @a @b f (Double tree) = Double (mapPBBT @(a, a) @b (\(j,k) -> (f j, f k)) tree)
06:57:45 <ski>   mapPBBT @(a,a) :: forall b. ((a,a) -> b) -> (PBBT (a,a) -> PBBT b)
06:58:17 <ski> since `f' has type `a -> ...', you can't pass `f' to `mapPBBT @(a,a)', since `a' doesn't match `(a,a)'
06:58:32 <ski> zceejkr : almost there :)
06:58:59 <zceejkr> mapPBBT @a @b f (Double tree) = Double (mapPBBT @(a, a) @(b, b) (\(j,k) -> (f j, f k)) tree)
06:59:10 <ski> yes ! :D
06:59:36 <ski> the type of `f' depends on `a' and `b'. and since those are changing in each recursive call, you also have to change `f'
06:59:54 <zceejkr> I see.
07:00:16 <ski> and, since `a' and `b' are changing, you can't, unlike the `map' case, make a local definition that just doesn't pass `a' and `b' around
07:00:27 <ski> so, this is true polymorphic recursion
07:01:17 <ski> (unlike the `map' case, in which the first version (with explicit type-passing), was only technically polymophically recursive, since it was easy to change to just employ monomorphic recursion)
07:02:09 <zceejkr> right.
07:03:19 <ski> (also, note that not that many languages, which have (parametric) polymorphism, allows polymorphic recursion. e.g. the MLs don't. although, i think now OCaml has it as an extension, and possibly SML/NJ,Mlton and some more maybe, has it as extension as well (not sure). but in Haskell it's been in the language, since Haskell 98, at least. perhaps also in Haskell 1.4 or earlier ? (not sure))
07:03:56 <zceejkr> nice :)
07:05:02 <ski> (iirc, if you try it with C++ templates, it would amount to generate infinitely many copies of the code. hm, maybe you can do it with generics in Java and C# ? i don't recall. however, iirc, in these cases you always pass the types explicitly)
07:05:51 <ski> yea, so it's good to notice here that we can't bound the types used by the program, at compile-time. how complicated types we use may depend also on run-time input
07:06:03 <ski> and the same holds for instances of type classes
07:06:10 <ski> remember my earlier example
07:06:22 <ski>   silly :: forall a. Show a => [a] -> [String]
07:06:24 * hackage pandoc-crossref 0.3.6.2 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.6.2 (lierdakil)
07:06:38 <ski>   silly [    ] = []
07:07:02 <ski>   silly (x:xs) = show x : silly (map (: []) xs)
07:07:37 <ski> this constructs new instances of `Show', at run-time, using `forall a. Show a => Show [a]' (the list instance)
07:08:12 <ski> so, it's not possible to inline all type class dictionaries, at compile-time
07:09:15 <ski> (we'll see another way in which types, and type class instances, used by the program, can't be bounded at compile-time, in the next section)
07:09:25 <ski> zceejkr : makes sense ?
07:11:07 <zceejkr> Hmmm. A couple questions. "Inlining a type class disctionary" means "copy-pasting" the correct instance into call-site?
07:12:17 <ski> yes
07:12:23 * hackage shell-monad 0.6.9 - shell monad  https://hackage.haskell.org/package/shell-monad-0.6.9 (JoeyHess)
07:12:53 <ski> so, if you call
07:12:55 <zceejkr> So if we a function f :: Show a => ..., and we call f 3, inlining would mean we past the Int Show instance here. 
07:13:07 <ski>   sum :: forall a. Num a => [a] -> [a]
07:13:35 <fishooter> is there a function like a fold, which start with an element, applies the element to itself, and has a predicate which tells it when to stop?
07:13:41 <fishooter> (a -> a) -> (a -> Bool) -> a -> [a]
07:13:45 <fishooter> something like this
07:14:00 <ski> with `a' being `Int', instead of repeatedly extracting the `(+)' method out of the `Num Int' dictionary (using the generic/polymorphic code), you'd generate a specialized
07:14:16 <ski>   sum_Int :: [Int] -> Int
07:14:38 <ski> in which you inline the `(+)' method, so that the call to it will hopefully be just a couple of instructions
07:15:03 <ski> @type until
07:15:05 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
07:15:16 <ski> fishooter : not quite what you're shooting for. try `unfoldr' ?
07:15:36 <ski> @hoogle (a -> Bool) -> (a -> a) -> a -> [a]
07:15:37 <lambdabot> No results found
07:16:23 <zceejkr> So why is it not possible to inline in the silly example?
07:16:55 <ski> because you don't know the length of the list you get at run-time
07:17:18 <fishooter> ski: bit of context: I have a function which starts with some element a, then I give it a transformation function. I'd like to keep collecting results of the sequential transformation until the predicate holds.
07:17:28 <ski> if you call `silly' with `a' being `Int', you'd need to inline `Show Int',`Show [Int]',`Show [[Int]]',`Show [[[Int]]]',&c.
07:17:37 <ski> you'd get
07:18:02 <ski>   silly_Int :: [Int] -> [String]
07:18:10 <ski>   silly_Int [    ] = []
07:18:11 <zceejkr> oh yeah, remember now. I see.
07:18:41 <fishooter> ski: until looks good, I also want to collect the partial results, not the final one
07:19:08 <ski>   silly_Int (n:ns) = show @Int n : silly_List_Int (map @Int @[Int] ((:) @Int ([] @Int)) ns)
07:19:17 <ski>   silly_List_Int :: [[Int]] -> [String]
07:19:24 * hackage brainfuck-monad 0.5.2 - BrainFuck monad  https://hackage.haskell.org/package/brainfuck-monad-0.5.2 (JoeyHess)
07:19:25 <ski>   silly_List_Int [      ] = []
07:20:03 <ski>   silly_List_Int (ns:nss) = show @[Int] ns : silly_List_List_Int (map @[Int] @[[Int]] ((:) @[Int] ([] @[Int])) nss)
07:20:06 <ski> and so on
07:20:51 <ski> fishooter : i can't recall it offhand, but some extra library might have it (search Hayoo as well ?). otherwise define it manually, or use `unfoldr' ?
07:22:58 <jsomedon> ski : so I came up with these: 1) a helpler function `fib a b = (a+b):|(fib b (a+b))` and 2) the fibs we want `fibs = 0:|1:|(fib 0 1)`
07:23:25 <ski> that's good, jsomedon :)
07:23:38 <ski> did you also do a linear-complexity `fib' ?
07:24:20 <jsomedon> uh, isn't this linear time?
07:24:21 <ski> jsomedon : if you wanted to, you could avoid doing addition, twice
07:24:33 <ski> (DRY, "Don't Repeat Youtself")
07:25:04 <ski> jsomedon : yes it is. but i meant a linear time version of `fib :: Integer -> Integer', to compare with this `fibs :: Stream Integer'
07:25:44 <ski> (sorry, just noticed you also called the helper function above, of type `Integer -> Integer -> Stream Integer', `fib')
07:26:07 <jsomedon> oh you mean like a `fib n = something` and this guy should run linear time
07:26:36 <ski> yea, just for comparision with the stream version you just did
07:27:01 <ski> (do you see how to do the DRY thing ?)
07:27:09 <ski> zceejkr : so, shall we continue then ?
07:27:25 <jsomedon> for DRY thing, I think I should somehow cache the a+b
07:27:29 <ski> zceejkr : actually onto existentials, that is :)
07:27:46 <zceejkr> sure :)
07:27:58 <ski> (you also have some redundant brackets, jsomedon)
07:29:18 <ski> zceejkr : i'll first do a conceptual overview, and explanation, which is partly in pseudo-Haskell code. only after that will i go into how to actually do it, in present Haskell, with present language extensions, okay ?
07:29:30 <zceejkr> ok.
07:30:05 <jsomedon> maybe `let cache=a+b in fib a b = cache:|(fib b cache)` and for extrac (), I am still struggling to memorize the priority rules of operators and functions :-p ski
07:30:31 <ski> (i happen to think it's clearer to reason about, and think about it, at least often, from this pseudo-Haskell POV, than to dive into the (sometimes a bit ugly) representation. especially as there's two main different ways, in which we can represesent existentials=
07:30:33 <merijn> jsomedon: Simple: prefix always has higher precedence than operators :)
07:31:05 <jsomedon> ah thanks merijn 
07:31:36 <merijn> jsomedon: operators can have fixity 0-9 (or 1-9? I forget...), prefix function application has fixity 10, record syntax has fixity 11
07:31:47 <merijn> higher == binds stronger
07:31:49 <fishooter> ski: yes, unfoldr looks good, thank you!
07:32:05 <jsomedon> ah I see merijn 
07:32:10 <ski> jsomedon : well, (unfortunately) you can't put a `let ... in' around a declaration (it's possible in SML, known as `local <decls> in <decls> end', as opposed to the usual `let <decls> in <expr> end', i wish Haskell had this)
07:32:41 <solonarv> it turns out there's a closed-form formula for fibonacci numbers: fib n = (phi^n - psi^n) / sqrt 5 -- logarithmic complexity, even!
07:32:48 <ski> jsomedon : the "invisible juxtaposition function application operator" binds more tightly than all user-defined operators
07:33:07 <solonarv> (assuming a nice logarithmic integer exponentiation implementation, of course)
07:33:15 * ski idly notes that `sqrt 5 = phi - psi'
07:33:18 <jsomedon> huh, that logarithm one looks crazy
07:33:23 * hackage reactive-banana-automation 0.5.3 - home (etc) automation using reactive-banana  https://hackage.haskell.org/package/reactive-banana-automation-0.5.3 (JoeyHess)
07:33:43 * ski also thinks the recursive expression is "closed-form"
07:34:27 <jsomedon> ski that invisible crazy stuff, do you mean like the space ` ` in code like `function arg`?
07:34:40 <solonarv> yes, exactly
07:34:58 <solonarv> "juxtaposition" is a fancy word for "putting things next to each other", btw
07:35:16 <solonarv> ...and hopefully you know what "function application" means :D
07:35:51 <jsomedon> thanks solonarv I guess I know :-p
07:36:13 <ski> jsomedon : the only exception to this are some "syntactic operators" (not being functions at all, but rather other notation which looks like operators". namely, `@'-patterns, `~'-patterns, `!'-patterns, and record construction and update (the ultimate only in expressions, the penultimate both in expressions and patterns). oh, also type-applications
07:36:50 <ski> jsomedon : however, it's not always whitespace. e.g. `(f)(x)' is a valid function application
07:36:58 <zceejkr> what about $?
07:37:05 <ski> merijn : including zero
07:37:14 <zceejkr> Is $ also sytactic operator?
07:37:17 <ski> `$' is an ordinary user-defined operator
07:37:22 <ski> no
07:37:36 <zceejkr> I see.
07:37:37 <ski> (and i generally prefer using it as little as possible)
07:38:55 <solonarv> there is a little bit of special magic in the typechecker to make $ more general, but apart from that it is an ordinary user-defined operator
07:38:59 <jsomedon> ok to summarize what u guys just said, operators are 0-9, prefix function application(which includes juxtapostion stuff and that (f)(x) stuff??yes?) is 10, record syntax is 11, and 
07:39:11 <solonarv> and its source code is: f $ x = f x
07:39:17 <merijn> solonarv: I don't see much value in bringing that up to beginners
07:39:29 <solonarv> I guess, just being needlessly thoruogh
07:39:41 <merijn> Or really, anyone who is not asking "why is my ST code not compiling when I remove $?"
07:40:12 <boxscape> :i (->) says that (->) has precedence -1
07:40:17 <boxscape> but of course that only works on the type level
07:40:31 <merijn> boxscape: It works on the kind level too ;)
07:40:36 <boxscape> that's the same level
07:40:52 <merijn> boxscape: No
07:41:05 <boxscape> hmm how are they different?
07:41:16 <ski> zceejkr : so, review, for comparision : a value of type `forall a. ..a..', is a polymorphic value, it can be used/consumed as if having type `..T..', for any specific type `T' that the user/consumer/"caller" wants to pick/choose in place of `a'. but the implementor/definer/producer/"callee", otoh, has to work for any choice of `a', must treat `a' as abstract/unknown/opaque/hidden/forgotten, a type about which nothing is known
07:41:18 <merijn> The fact that GHC internally implements it as such and we have TypeInType nonsense is not the same as "Haskell"
07:41:28 <boxscape> okay, well, fair I suppose
07:41:39 <merijn> TypeInType is an abomination and I refuse to acknowledge it's existence
07:41:56 <boxscape> luckily -XTypeInType is being deprecated :)
07:42:01 <jsomedon> ski : I just see u saying $ is user defined, isn't that part of language?
07:42:04 <boxscape> of course that just means Type :: Type is always true
07:42:12 <ski> jsomedon : nope
07:42:16 <boxscape> (as it has been since 8.0 iirc)
07:42:16 <jsomedon> uh
07:42:17 <ski> @src ($=
07:42:17 <lambdabot> Source not found.
07:42:18 <ski> @src ($)
07:42:18 <lambdabot> f $ x = f x
07:42:19 <merijn> jsomedon: It's defined in the base library
07:42:28 <ski>   infixl 0 $
07:42:53 <ski> oh, sorry, s/infixl/infixr/
07:43:34 <solonarv> jsomedon: the haskell report says something like "the operator $ must be in the prelude", and in the GHC ecosystem (which is the only one in wide use) this is accomplished by having that 'f $ x = f x' definition somewhere in the 'base' library
07:43:37 <merijn> jsomedon: Very few things are actually defined "in the language" (aka in the compiler), lots of things are instead defined in the prelude, which is "just Haskell code". It's special in the sense that Prelude is automagically imported everywhere, but you could just as easily implement it yourself
07:43:57 <shafox> So via stack latest lts, I cant install cabal-install. I am on archlinux.
07:44:07 <boxscape> merijn from that point of view - does (->) really work on the kind level? Considering kind signatures are also a ghc extension
07:44:17 <dminuoso> jsomedon: Take the type Bool with its values True and False for instance. It's not a built-in primitive. There actually exists a Haskell module that defines `data Bool = True | False` :)
07:44:22 <merijn> boxscape: Ideally you'd have a different symbol, yes
07:45:09 <__monty__> dminuoso: Isn't that a bad example? It's kinda part of the language because of guards, no?
07:45:09 <jsomedon> dminuoso uh so boolean type is not part of langauge is that what you mean
07:45:13 <merijn> boxscape: I, personally, find infinite universe stratification much easier to think about/reason with than TypeInType and it's more logically sound too
07:45:15 <uglyoldbob> I have a function; parseCommand :: SomeThing -> [Char] -> IO SomeThing. I currently use foldM parseCommand initialThing contents. I want to add a [1..] element alongside the contents variable. How might I do this?
07:45:19 <ski> dminuoso : actually in the other order :)
07:45:34 <dminuoso> ski: Is the order relevant?
07:45:35 <boxscape> merijn yeah given my extremely limited knowledge it seems preferable
07:45:48 <ski> dminuoso : for `Enum',`Bounded',`Ord',`Ix'
07:45:59 <__monty__> Do alternative preludes have to define $? And do the special cases in the compiler work for those?
07:46:00 <merijn> uglyoldbob: "zip [1..] contents"? :p
07:46:16 <boxscape> __monty__ they usually import ($) from base
07:46:19 <dminuoso> jsomedon: Well it is in the sense that the haskell report (which acts as the haskell standard) states "this thing must exist". But it's not a magic primitive that exists out of nothing, it's bootstrapped from Haskell itself.
07:46:21 <solonarv> __monty__: they probably just reexport the same $ as base:Prelude
07:46:34 <solonarv> (indeed Prelude itself has no definitions IIRC, it's all reexports)
07:47:14 <jsomedon> hmm vewy interesting
07:47:26 <merijn> Hell, even Int is defined in a library :p
07:47:47 <__monty__> And the special casing wouldn't work for a different definition of $?
07:47:57 <jsomedon> so all these numerical literals 1 2 3 4 5 6...
07:47:59 <dminuoso> And to be fair, ($) is very special if you look closely. :-p
07:48:01 <merijn> "data Int = I# Int#" (Int#, otoh, is built into the compiler)
07:48:01 <jsomedon> they are from library?
07:48:17 <boxscape> no, but once quick-look impredicativity is implemented you could likely make it work __monty__
07:48:19 <dminuoso> jsomedon: They are indeed a magic primitive in Haskell at least.
07:48:31 <ski> jsomedon : some syntactic sugar hooks into things that are defined in a library
07:48:40 <boxscape> __monty__ i.e. you wouldn't need special casing anymore
07:48:43 <merijn> jsomedon: Here's where a lot of the magic is defined: https://hackage.haskell.org/package/ghc-prim-0.4.0.0
07:49:05 <dminuoso> jsomedon: But only very few things are builtin primitives. Almost most things you know are just defined with regular Haskell. 
07:49:06 <jsomedon> dminuoso: okay, then the type for these magical primitive numerical literal is?
07:49:20 <boxscape> technically I think it'd be accurate to say that things in the Prelude defined by the report are "part of the language"?
07:49:21 <dminuoso> jsomedon: `5 :: Num a => a`
07:49:34 <merijn> jsomedon: Numerical literals are Integer which gets converted to whatever type via fromInteger
07:49:36 <dminuoso> jsomedon: It's a weird type because its overloaded, this allows us to use 5 as an Int, Integer, Word32, Double, etc...
07:49:45 <jsomedon> ...
07:49:56 <ski> jsomedon : e.g. `if <condition> then <consequent> else <alternate>' amounts to `case <condition> of True -> <consequent>; False -> <alternate>', hooking into `data Bool = False | True'. also there's guards ..
07:50:39 <ski> (the numeral / numeric literal `5' is overloaded. its type isn't)
07:50:43 <jsomedon> ski so u mean if then else is just syntax sugar
07:50:48 <ski> yes
07:50:48 <dminuoso> jsomedon: But lets take our lists for example. You can imagine that lists are definable yourself as `data List a = Cons a (List a) | Nil` - and in fact that is pretty much what GHC does for [], except because it wants to give you a visually pleasing syntax, its a builtin.
07:51:11 <ski> @src []
07:51:11 <lambdabot> data [] a = [] | a : [a]
07:51:15 <jsomedon> dminuoso: hm yeah
07:51:22 <ski> is just a nice conceptual view of it
07:51:54 <ski> (that syntax isn't actually allowed. because you can't declare data constructors, nor type constructors, named `[]'. `:' is fine, though)
07:51:59 <dminuoso> jsomedon: And, if we ignore certain optimization rules, the actual data representation is comparable, so my `List` data type is not less efficient either.
07:52:18 <merijn> ski: It's not fine, because : is explicitly reserved ;)
07:52:27 <ski> yea, there is that
07:52:33 <boxscape> % data A = (:)
07:52:33 <yahb> boxscape: ; <interactive>:40:10: error: Not a data constructor: `:'
07:52:38 <ski> (but imagining that out of existence ;)
07:53:05 <boxscape> % data (:)
07:53:05 <yahb> boxscape: ; <interactive>:41:6: error: Malformed head of type or class declaration: (:)
07:53:08 <boxscape> hm
07:53:27 <ski> (so, i guess what i ought to have said, is that there's an explicit provision that makes the `:' not fine)
07:54:08 <dminuoso> jsomedon: Now with that in place, assume that Char are magic primitives... "foo" is just syntactic sugar for: 'f' : 'o' : 'o' : [], or Cons ('f' (Cons 'o' (Cons 'o' Nil))) using my version.
07:54:28 <dminuoso> jsomedon: So even String is user definable, assuming we have Char already - it's just a usage of list.
07:54:38 <ski> @src String
07:54:38 <lambdabot> type String = [Char]
07:54:51 <jsomedon> yeah that makes perfect sense
07:56:41 <ski> zceejkr : now, a value of type `exists a. ..a..', let's call it an "abstracted value" (for lack of a better term), is such that the definer/implementor/producer/"callee" gets to pick `a' (as some concrete `T'). while the user/consumer/"caller" must treat `a' as abstract/forgotten/hidden/opaque/unknown
07:58:05 <ski> zceejkr : so. `Nothing' has type `forall a. Maybe a'. therefore `Nothing' (or `Nothing @Integer' in the explicit version) also has type `Maybe Integer', and also (`Nothing @Bool') has type `Maybe Bool'
07:58:14 <dminuoso> jsomedon: Now, in order to be fair, ($) is not a proper user-defined operator in GHC. There exists a special hack for it to allow it to be used in spots that you, otherwise, couldn't use it.
07:58:33 <dminuoso> jsomedon: That being said, this hack is only relevant for code using language extensions.
07:59:02 <boxscape> % unsafeCoerce (1 `Cons` 2 `Cons` 3 `Cons` Nil) :: [Integer]
07:59:02 <yahb> boxscape: [1,2,3]
07:59:15 <ski> zceejkr : otoh. `[False,True,False]' has type `[Bool]'. therefore, it also has type `exists a. [a]'. there exists some type `a' such that `[False,True,False]' has type `[a]'
07:59:20 <uglyoldbob> is it possible to convert {do let smack = ["ow","ow","ow"] print head smack} into a one liner?
07:59:24 <dminuoso> boxscape: Did you segfault it the first time or not? :P
07:59:34 <dminuoso> (that is, did you get the constructor order right the first time?)
07:59:35 <boxscape> dminuoso I didn't :P
07:59:39 <dminuoso> heh
07:59:49 <dminuoso> uglyoldbob: use parens
08:00:03 <merijn> uglyoldbob: eh, delete the let and replace "smack" with that list? >.>
08:00:24 <ski> uglyoldbob : fixing the type error, you can say `print (head (replicate 3 "ow"))'
08:01:06 <uglyoldbob> but i really wanted a one liner that said "head smack" in it
08:01:23 <ski> uglyoldbob : well, you can still say
08:01:33 <merijn> uglyoldbob: Alternatively, you can put an in after the let and delete the line break :p
08:01:34 <ski>   do let smack = ["ow","ow","ow"]; print (head smack)
08:01:36 <ski> or
08:01:48 <ski>   let smack = ["ow","ow","ow"] in print (head smack)
08:01:51 <ski> or
08:01:53 <merijn> > let smack = ["ow","ow","ow"] in print (head smack)
08:01:56 <merijn> eh
08:01:56 <lambdabot>  <IO ()>
08:02:00 <merijn> % let smack = ["ow","ow","ow"] in print (head smack)
08:02:00 <yahb> merijn: "ow"
08:02:01 <ski>   print (let smack = ["ow","ow","ow"] in head smack)
08:02:03 <ski> or
08:02:17 <ski>   print (head (let smack = ["ow","ow","ow"] in smack))
08:02:52 <ski> uglyoldbob : oh, and when i said `;' here, i meant a semi-colon, not a line-break-with-indentation
08:03:40 <uglyoldbob> ski: i like let smack = ["ow", "ow", "ow"] in print (head smack). thank you
08:04:39 <ski> uglyoldbob : in case this is the whole definiens/body of a defining equation, you could also try `where'
08:04:57 <zceejkr>  ski: so I gues we can do this trick with any value of type (a b), where a is (* -> *)
08:05:56 <ski> zceejkr : well, consider `("False",reverse,id)', considered to have type `(String,String -> String,String -> String)'
08:07:48 <ski> using `exists', we could abstract away as much or as little details as we wanted, from this type
08:07:51 <ski> e.g.
08:08:11 <ski>   ("False",reverse,id) :: exists a. (a,a -> a,a -> String)
08:08:14 <ski> but also
08:08:20 <ski>   ("False",reverse,id) :: exists a. (a,a -> a,a -> a)
08:08:37 <ski>   ("False",reverse,id) :: exists a. (String,String -> String,String -> String)
08:09:06 <ski> or any other combination of hiding some usages of `String' behind the abstract `a', while exposing some others, not hiding them
08:09:19 <ski>   ("False",reverse,id) :: exists a b. (a,b -> a,a -> b)
08:09:38 <ski> where we've (also) forgotten that `a' and `b' are actually the same type
08:09:51 <zceejkr> i see.
08:10:18 <ski> of course, since `String' is `[Char]', we could elect to forget some uses of `Char' behind an existentially bound type variable
08:10:39 <ski> and `[Char]' is `[] Char', so we could hide `[]' behind a variable `f'
08:10:48 <ski> and similarly with `(,,)'
08:10:51 <jsomedon> dminuoso: I see
08:11:10 <ski> we just have to make sure that all the types we hide behind the same type variable were actually the same type, before hiding them
08:11:19 <ski> now, what's this good for ?
08:11:30 <ski> well, let's make another silly example
08:11:50 <ski>   mystery :: Bool -> exists a. (a,a -> a,a -> String)
08:12:14 <ski>   mystery False = ("False",reverse,id  )
08:12:34 <ski>   mystery True  = ( True  ,succ   ,show)
08:12:56 <ski> here, we select, at run-time, which type `a' will stand for, depending on run-time input
08:14:07 <ski> given a value of type `exists a. (a,a -> a,a -> String)', the only thing we can really do, since we don't know what type `a' is (and we have no way of discovering it), is to feed the first component, of type `a', zero or more times, through the middle component, finally passing that result to the last component, getting a `String' back (which we can inspect)
08:14:49 <zceejkr> I see. 
08:15:52 <zceejkr> I guess we can also have typeclass constraints on a?
08:16:09 <ski> if `mystery' was recursive, we could also construct new types (from existing types, like constructing `[Int]',`[[Int]]',`[[[Int]]]',&c. as with `silly' above, from `Int' and `[]'), to be used by the program depending on run-time input
08:16:43 <ski> (and also, like in the `silly' example, new type class instances, like `Show [Int]',`Show [[Int]]',`Show [[[Int]]]',&c.)
08:16:50 <ski> yes
08:17:11 <ski> let me first give a somewhat more realistic example of `exists'
08:18:05 <ski>   type QueueOps a = exists q. ({- empty -} q,{- enqueue -} a -> q -> q,{- dequeue -} q -> Maybe (q,a))
08:19:33 <ski> a value of type `QueueOps a' is supposed to encapsulate one particular implementation of queues of `a's (in particular). you could think of such a value as "a module implementing the queue interface", more or less. `q' would correspond to an Abstract Data Type
08:20:07 <ski> so, you could e.g. define
08:20:24 <ski>   listQueue :: forall a. QueueOps a
08:20:45 <ski>   listQueue = (empty,enqueue,dequeue)
08:20:47 <ski>     where
08:20:56 <ski>     empty :: [a]
08:21:02 <ski>     empty = []
08:21:11 <ski>     enqueue :: a -> [a] -> [a]
08:21:16 <ski>     enqueue = (:)
08:21:41 <ski>     dequeue :: [a] -> Maybe ([a],a)
08:21:48 <ski>     dequeue [] = Nothing
08:22:01 <ski>     dequeue xs = Just (init xs,last xs)
08:22:06 <ski> this is obviously inefficient
08:22:22 <ski> here, we're selecting `q' to be `[a]'
08:23:09 <zceejkr> nods
08:23:24 * hackage concurrency 1.9.0.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.9.0.0 (barrucadu)
08:23:33 <ski> note that, since the type of `listQueue' is `forall a. exists q. (q,a -> q -> q,q -> Maybe (q,a))', our selection of `q' is allowed to depend on `a'. that would not be the case, if we had had `exists q. forall a. (q,a -> q -> q,q -> Maybe (q,a))'
08:24:24 * hackage dejafu 2.1.0.2 - A library for unit-testing concurrent programs.  https://hackage.haskell.org/package/dejafu-2.1.0.2 (barrucadu)
08:25:31 <ski> there is a well-known "folklore" implementation of queues, where we'd pick `q' as `([a],[a])', a pair of the front and the back of the queue, arbitrarily split at some point. also the `back' is represented in reverse order. that way, `dequeue' can (in most cases) easily access the last element of the queue, only sometimes do we need to move over the front, reversing it, making `dequeue' amorticized constant time, only
08:25:55 <ski> i'll leave the details of how to do that (it's not hard) to you, in case you're curious
08:26:49 <kuribas> ski: why "folklore"?
08:26:55 <kuribas> ski: it's quite useful
08:27:10 <ski> anyway, a user of `QueueOps a' would begin by "opening" the "module", getting some unknown/abstract/opaque/forgotten/hidden type `q' into scope, and then work directly with values of type `q', passing them to the "ADT module operations"
08:27:23 <dmwit> Besides which, there's a published text to refer to, which elevates it from "folklore" to "literature". ^_^
08:27:52 <dmwit> (Okasaki's thesis describes and analyzes it in detail.)
08:27:53 * hackage headroom 0.1.1.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.1.1.0 (xwinus)
08:28:07 <ski> kuribas : of course it's useful. i just don't recall having seen a publication where the idea was initially introduced publicly
08:28:30 <ski> dmwit : i know, but iirc it's been floating around for some time before that
08:28:35 <ski> (wg 10
08:28:52 <dmwit> I guess you mean something different by "folklore" than I do, then.
08:30:07 <dmwit> For me, folklore are the bits that everybody agrees are great but just haven't been forced through the peer review process yet. I guess for you folklore is something everybody agrees is great but nobody can figure out whose fault it is.
08:31:26 <ski> heh, i guess something like that :)
08:31:59 <ski> zceejkr : anyway, are you following the example, so far ?
08:32:09 <zceejkr> yes. 
08:34:57 <ski> zceejkr : so, this is one usage of existentials, here written with `exists' : to simulate Abstract Data Types, nonetheless in a first-class fashion (you can easily make a function that takes one "ADT module" as input, and computes a new one. to do that with actual modules, you need something like the ML module system (as in SML,OCaml, but, alas, not in F#) .. which is (was ?) being worked at, for Haskell, in the form of "Backpack" : parameterizing a module 
08:35:27 <ski> (hrm, that might have gotten cut off near the end : ".. : parameterizing a module over module parameters, and being able to instantiate such module \"functors\", at compile-time, at least)")
08:36:23 <ski> there is another, somewhat related, usage of existentials
08:36:38 <merijn> ugh
08:36:46 <merijn> why do we not have foldMapM?
08:37:04 <ski>   type QueueObj a = exists q. ({- state -} q,{- enqueue -} a -> q -> q,{- dequeue -} q -> Maybe (q,a))
08:37:12 <dminuoso> merijn: Do you mean foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w?
08:37:20 <merijn> yeah
08:37:59 <ski> zceejkr : note that, this type is actually equal to `QueueOps a'. the difference being that i renamed the comment for the first component from `empty' to `state'
08:38:26 <zceejkr> noted.
08:39:44 <ski> zceejkr : the idea being that, instead of, once, opening a `QueueOps a', and then working directly with values of type `q', using the `empty',`enqueue',`dequeue' operations, we instead intend to use the first component to keep the "current state" of a queue, immediately rewrapping it, with `enqueue' and `dequeue', and the `exists', after accessing and modifying it
08:39:49 <ski> iow, we define wrappers
08:40:10 <ski>   enqueue :: forall a. a -> QueueObj a -> QueueObj a
08:40:37 <ski>   enqueue x (q,enq,deq) = (enq x q,enq,deq)
08:40:50 <ski>   dequeue :: forall a. QueueObj a -> Maybe (QueueObj a,a)
08:41:12 <ski>   dequeue (q,enq,deq) = case deq q of
08:41:35 <ski>     Nothing     -> Nothing
08:41:51 <ski>     Just (q,x) -> Just ((q,enq,deq),x)
08:42:18 <ski> and then we define a "class" / "class constructor"
08:42:40 <ski>   emptyListQueue :: forall a. QueueObj a
08:43:04 <ski>   emptyListQueue = (empty,enqueue,dequeue)
08:43:06 <ski>     where
08:43:26 <ski>     ..as in the definition of `listQueue' above..
08:43:43 <ski> (perhaps renaming `empty' to `state' or something ..)
08:44:10 <ski> zceejkr : so, this amounts to simulating Object-Orientation
08:44:32 <zceejkr> I see. Also seems to simulate mutability
08:44:59 <zceejkr> I guess that is assumed in object-oriaetation. 
08:45:45 <ski> of course, our class constructor could easily be parameterized, if we wanted to. and, it would also be possibly to call out to a "super constructor", replacing some "methods" with ones of our own (possibly referring back the the ones we replaced). we could even take "super" as an input (cf. "mixins")
08:47:12 <ski> however, if we want late-binding, so that a not-replaced method will call the one we replaced, we have to do a little more work (parameterizing the class on `this'/`self', of the same type. and then use `fix', when we actually want to instantiate a new object (cf `new' in e.g. Java))
08:48:09 <zceejkr> Can one also think of (Maybe Int) as a subtype of (exists a. Maybe a).
08:48:11 <ski> zceejkr : yes, instead of mutating the object, in-place, we can have the methods (some of them), return a new copy of the object, with some parts changed
08:49:33 <zceejkr> I recall in object-oriented languages, one has subtypes and co-/contra- variance. Which as I understand does not show up in Haskell.
08:50:03 <ski> this (specializing a polymorphic/general/generic `forall'-typed-value into a (possibly) monomorphic one, and abstracting a (more) specific/concrete value into an `exists'-typed-one) is not subtyping
08:50:22 <ski> well, not directly, at least not in that way
08:50:40 <zceejkr> I see.
08:51:41 <ski> we still talk about covariant vs. contravariant functors, and, by extension, of an occurance of a type subexpression, in some larger type expression, to be a positive/negative occurance, or occur covariantly/contravariantly
08:52:15 <ski> so, i'd say it's a relevant concept. but we don't have subtyping. what happens with `forall' and `exists' is distinct from that
08:52:51 <zceejkr> TBH besides knowing contravariance and covariance exist, I know next to nothing about them, just to be clear :)
08:53:05 <ski> also, if we really want mutability in our objects, that's easy to do. simply have (some) methods have result types like `IO Foo' or `ST s Bar'
08:54:08 <ski> then, they can read and write mutable cells referenced by `IORef Bleh'/`STRef s Blah', and also the corresponding mutable array types, &c.
08:54:21 <zceejkr> I know (exists covariance . "covariance is a thing in OO").
08:54:43 <dminuoso> Is there a name/term for a module Foo, whose sole purpose it is to import from Foo.Bar, Foo.Quux and so forth and re-export those modules?
08:54:57 <ski> (fwiw, it turns out to by highly nontrivial to try to have both subtyping and parametric polymorphism (being, mostly, type inferred), in a language)
08:55:22 <ski> dmwit : maybe "wrapper" or "reexporter" ?
08:56:52 <dminuoso> Mm, reexporter works I guess.
08:58:00 <ski> zceejkr : hm, also, i should say that `QueueObj a' (the OO version) is actually equivalent to defining `data QueueObj a = MkQObj {enqueue :: a -> QueueObj a,dequeue :: Maybe (QueueObj a,a)}'
08:59:19 <ski> zceejkr : instead of storing `state' alonside `enqueue' and `dequeue' in the "method tuple/record/table" ("vtable"), we can simply partially apply all the methods on the current state
09:02:10 <ski> zceejkr : this works because all the components take exactly one `q' as input, except the single `state' field. in general, `exists x. (x,x -> ..x..)' (where `x' occurs covariantly/positively in `..x..') can be replaced by a type `NuFoo' defined as `data NuFoo = MkNuFoo (..NuFoo..)'
09:03:09 <zceejkr> i see.
09:04:37 <ski> zceejkr : however, it's not that uncommon, in an Abstract Data Type, to have operations like `merge :: pq -> pq -> pq' (where `pq' stands for "priority queue", say). such "binary methods" are problematic to handle, in an OO setting, at least if you want to be able to access the innards of both objects (perhaps cf. CLOS multimethods in the Lisp world, hmm ??). also "clone methods" also tend to present typing problems, correctly typing (interface) inheritance
09:05:00 <ski> (however, OCaml seems to have a solution to both those typing problems)
09:05:18 <rindolf> maerwald: hi, sup? https://github.com/hasufell/euler630-mniip 's ghc code is still slower than cpython3. Should we give up?
09:05:25 <ski> hm, now i wonder whether you've seen some "type algebra" yet, zceejkr ?
09:06:03 <zceejkr> I know why sum types are called sum types and ditoo for product
09:06:13 <zceejkr> And I know functions are exponential types
09:06:23 <zceejkr> and I think I also understand why
09:06:54 * hackage typelits-printf 0.1.1.0 - Type-safe printf from parsing GHC TypeLits Symbol  https://hackage.haskell.org/package/typelits-printf-0.1.1.0 (jle)
09:07:33 <ski> you know that sometimes, we write `Either a b' as `a + b' (when reasoning about it, conceptually), yes ?
09:07:45 <zceejkr> Yes. 
09:07:49 <ski> and, instead of the type `(a,b)', we can write `a * b'
09:08:14 <ski> and, instead of `a -> b', we may write `b^a', although `a -> b' is still common to use with "type algebra"
09:09:23 <ski> and the rationale is that, at least for finite types, the number of values/inhabitants (ignoring "bottoms", and partial(ly defined) elements), the number of inhabitants of `Either a b', its cardinality/numerosity/potency is the sum of the cardinalities of `a' and `b'
09:09:39 <zceejkr> right.
09:10:02 <ski> and, likewise, for `(a,b)', we get the product. in math, the type/set `a * b' is known as the cartesian product of the types/sets `a' and `b'
09:11:05 <ski> and `a + b' is known as the "disjoint union" of `a' and `b' (not to be confused with the more commonly encountered union of (sub)sets. the cardinality of the union is merely at most that of the sum of the cardinalities of the two summand (sun)sets)
09:11:24 <ski> and `b^a' is known as the "function set/space"
09:12:40 <ski> e.g. `|R^2' is the set of pairs of real numbers, taking `|R' to be the set/type of real numbers. we can either think of this as a shorthand for `|R * |R' .. or we can take `2' here to mean the set `{0,1}', so a pair of real numbers is a function that, given `0' will give one component, and, given `1', will give the other component
09:13:10 <ski> in Haskell, `data Bool = False | True' would be modelled, in "type algebra" as `Bool = 1 + 1'
09:13:53 <ski> while `()', the empty tuple type, would be `1'. one can (with extension), define an empty data type, having zero data constructors, `data Void', which would be written as `0'
09:14:24 <jsomedon> whenever my friends ask me why monad is useful/what value it brings, I always find it difficult to explian that in simple words
09:14:29 <ski> and, now such identities such as the commutative laws, associative laws, for `+' and `*', also holds for types
09:14:43 <zceejkr> I see.
09:15:07 <zceejkr> So they give us a Ring over types? * and + I mean
09:15:27 <ski> and the distributive law, `a * (b0 + b1)' corresponds to the type `(a,Either b0 b1)' expressing the same information as ("is isomorphic to") `Either (a,b0) (a,b1)'
09:15:51 <ski> zceejkr : a "Rig", a ring without Negation
09:16:35 <zceejkr> So no inverse for (+)? (+) does not give us a Group over types?
09:17:49 <ski> jsomedon : cutting down on some common forms of boiler-plate code, capturing some software pattern in library operations. being able to write generic library code, working for any "implementation" of such an "abstract data type" (cf. priority queues). also more clealy separating effects from non-effectful code
09:17:58 <ski> no inverse, zceejkr
09:18:06 <Io_> I'm starting to find the common pattern that whenever I use a Either or Maybe, it starts to propagate all the way up the stack. Would that be an indicative of a code smell? *beginner here*
09:18:07 <zceejkr> I see.
09:19:05 <ski> (iirc, there's some theorem that if there's an inverse, then the category is trivial in some sense (thin, possibly). possibly under some extra assumptions, like presence of products, perhaps exponentials. i don't recall details, atm)
09:19:50 <zceejkr> No worries, I am yet to start learning category theory :)
09:19:59 <ski> Io_ : maybe. depends on specifics. if you no longer need to handle the "exceptional" cases (i assume that's what you're doing with those ?), you should get rid of those types, at that middle point
09:20:01 <zceejkr> So no idea what you just said :D
09:20:49 <ski> yea, and so i don't think it helps, atm, to go into that, without explaining some basic category theory (especially since i don't recall the specifics of the result atm, so would have to recall/reinvent it, or else look it up) ;)
09:22:38 <Io_> I see, but what if I want to log a message based on an outcome of a Maybe that is buried deep in the stack.
09:24:51 <ski> zceejkr : anyway, other useful identities (when reasoning about, or refactoring, types) are `1^b = 1',`(a0 * a1)^b = a0^b * a1^b',`a^1 = a',`a^(b0 * b1) = (a^b0)^b1',`a^0 = 1',`a^(b0 + b1) = a^b0 * a^b1', and finally `0^a = 0' where `a' is inhabited ("non-empty") (while `0^0 = 1', per previous law)
09:24:55 <jsomedon> ski : Rig, is that named by removing "n" from "Ring", hence "Ring without n(egation)" ?
09:25:49 <ski> zceejkr : you should (at some point), make sure you understand what all these means, in terms of types (possibly writing conversions functions, for both directions, which should be pairwise inverse). one of those have to do with currying/uncurrying, e.g.
09:25:54 <ski> yes, jsomedon
09:26:25 <ski> aka "semiring"
09:26:38 <ski> <https://en.wikipedia.org/wiki/Rig_(mathematics)>
09:27:12 <jsomedon> ah I thought it was just a funny name u made up right nah
09:27:39 <ski> nah, it is sortof joke term, but it's used seriously ;)
09:27:45 <ski> (the best kind of joke)
09:29:01 <jsomedon> I see the origin of rig, I also see rng, huh I have seen rng here and there and I thought rng was abbr of random number generator
09:29:41 <phadej> it is
09:29:56 <phadej> there's finite collection of three letter "words" :)
09:30:07 <ski> see "Seven trees in one" by Andreas R. Blass in 1995 at <http://www.math.lsa.umich.edu/~ablass/cat.html> (also see John Baez' "This Weeks Finds in Mathematical Physics", week 202, at <http://math.ucr.edu/home/baez/week202.html> (scroll down a bit), for some more discussion of that)
09:30:17 <phadej> so overlap is expected
09:31:30 <ski> (also see "Searching for a Video Proof of \"Seven Trees in One\"" at The n-Category Café in 2009-07-16 at <https://golem.ph.utexas.edu/category/2009/07/searching_for_a_video_proof_of.html>)
09:32:02 <ski> that Blass paper is actually not that hard to get something of value out of, that i recall ..
09:33:55 <ski> finally, "Objects of Categories as Complex Numbers" by Marcelo Fiore,Tom Leinster in 2002-12-30 at <https://arxiv.org/abs/math/0212377> has some examples of using, what would appear to be illegitimate operations on types (such as subtraction, division, radicals/roots), in order to derive useful results
09:36:05 <zaifir> ski: Thanks for the references!
09:36:52 <zceejkr> ski: indeed, thank you. I will save them for when I level up :)
09:37:47 <ski> well, i should also add a reference to "The Derivative of a Regular Type is its Type of One-Hole Contexts" by Conor McBride at <https://personal.cis.strath.ac.uk/conor.mcbride/pub/>, for computing derivatives of types ! :D (useful for "zippers", a way to get constant-time local access, when traversing a data-structure)
09:38:17 <mniip> hmm
09:38:23 <mniip> that gives me a very general meta-idea
09:38:46 <mniip> if you have algebraic theories with a forgetful functor inbetween
09:38:55 <ski> (hm, which year did Conor start to circulate that ("unpublished", but still very influential) paper ?)
09:39:01 <mniip> you can sometimes pullback a statement along the free/forgetful adjunction
09:40:44 <mniip> though the seven trees in one paper in particular deals with algebraic fields
09:40:49 <mniip> which are amusingly not algebraic theories
09:41:58 <ski> zceejkr : anyway, in the `QueueObj a' example, `exists q. (q,a -> q -> a,q -> Maybe (q,a))' is isomorphic to `exists q. (q,q -> (a -> q,Maybe (q,a)))', hence we can rewrite to the `data QueueObj a = MkQObj (a -> QueueObj a,Maybe (QueueObj a,a))' form, using the general rewrite from `exists x. x * (x -> ..x..)' to `data X = MkX (..X..)' that i suggested (without arguing for that much)
09:42:39 <zceejkr> Speaking of theories, I once tried to learn something about model theory on YT. Would it be a fair analogy to say that in haskell, a typeclass defines a thoery and an instance is a model of that theory (usin the wors theory and model in model-theoretic sense).
09:42:43 <zceejkr> ?
09:42:54 <ski> (which was my motivation for bringing up "type algebra", here)
09:43:10 <solonarv> I know very little about model theory but that sounds like it might be vaguely the right idea
09:43:11 <mniip> a theory in the F-algebra sense perhaps
09:43:16 <mniip> you can't state axioms using typeclasses
09:43:36 <ski> although typeclasses are commonly taken as, informally, come with laws/axioms
09:44:56 <ski> zceejkr : there's some more fun "type algebra" (not really corresponding much to something you might recognize from ordinary algebra), that can be had with `forall' and `exists'. but perhaps a later time
09:45:02 <lyxia> interface (classes/theories) vs implementation (instances/models)
09:45:58 <zceejkr> ski: i see.
09:46:15 <ski> zceejkr : if you still have some time to kill, i could now go on to reinforce `exists', and its behaviour a bit more, and also (hopefully) get to the two ways to actually represent it in current Haskell (so you could go off and have some fun coding)
09:46:40 <ski> (also getting into interaction with type classes, which you hinted at, previously)
09:47:28 <mniip> ski, you about to whip out the integral sign?
09:47:37 <ski> nah
09:47:42 <zceejkr> I have to leave in 15 mins. So if it is okay with you, let pause here and continue in future? I very much enjoy these lectures BTW, thanks a lot for your time.
09:47:45 <ski> no ends or coends, today
09:47:58 <mniip> wish that's what forall/exists were
09:48:00 <mniip> but they are not!
09:48:09 <ski> ok, sounds fine, zceejkr
09:48:21 * ski bows
09:48:55 <mniip> they're wedges for sure but they might not be universal
09:48:58 <zceejkr> ski: cool :)
09:49:11 <ski> zceejkr : if you have some meantime, perhaps you could contemplate and practice on those type algebra equations i gave you (in addition to the more obvious commutativity, associativity, and neutrasl element laws)
09:49:41 <mniip> which reminds me
09:49:44 <mniip> topos, any update?
09:50:04 <zceejkr> ski: will try with concrete examples like you suggested. 
09:50:15 <topos> mniip on?
09:50:27 <mniip> the parametricity thing :o
09:50:42 <topos> oh, yeh i'm basically finished interviewing with stuff. I can get back into it
09:51:53 <ski> zceejkr : perhaps you could also try giving the seven trees paper a look, see how much you can follow (don't be afraid to skip sections or paragraphs you don't understand)
09:52:17 <topos> mniip want to sync up this weekend?
09:52:19 <ski> (i'm not intending to build on it, but it might be fun to have a look at)
09:52:23 * hackage hakyll 4.13.1.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.13.1.0 (JasperVanDerJeugt)
09:52:51 <zceejkr> ski: will do.
09:52:57 <mniip> topos, sure
09:53:07 <mniip> topos, though this weekend might be pretty packed for me
09:53:18 <topos> ah, well, whenever you're free-ish :)
09:53:36 <topos> I have to reread the freyd paper and I don't think i've read reynolds' 
09:53:52 <mniip> well I'm slowly coqing through reynold's paper
10:01:43 <jsomedon> this hitchhiker's guide is hillarious
10:07:02 <fishooter> hi :) I've spent the past couple days implementing an assignment for students to learn haskell, and I made a reference solution. Could you please take a look at it? I'm also learning haskell (phd life...) and I was tasked to do this project. The repository is temporarily located at https://github.com/michalsustr/haskell_gomoku If you can add comments via issues I would absolutely grateful!
10:17:53 <dmwit> :t \f -> foldMap (Ap . f)
10:17:55 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> Ap f a1
10:17:59 <dmwit> merijn: ^
10:19:48 <dmwit> And yes, I think it would be handy to have an agreed-upon library/name for this.
10:21:01 <solonarv> I wonder what a good name for this would be
10:21:24 <solonarv> 'traverseFold' because it's the same as 'fmap fold . traverse f' ?
10:21:33 <solonarv> (well, it's more general, of course)
10:21:47 <Iceland_jack> lambdabot doesn't support type applications still?
10:21:59 <MarcelineVQ> Iceland_jack: correct, afaik
10:22:13 <hyperisco> PRs welcomed I hear
10:22:41 <Iceland_jack> :t \f -> foldMap ((Ap :: f a -> Ap f (a :: *)) . f)
10:22:43 <lambdabot> (Foldable t, Applicative f, Monoid a1) => (a2 -> f a1) -> t a2 -> Ap f a1
10:24:20 <jle`> Iceland_jack: we use yahb for type applicationy stuff
10:25:15 <dmwit> Is kind application a thing?
10:25:19 <Iceland_jack> It is now
10:25:24 <Iceland_jack> jle`: How do you invoke?
10:25:34 <dmwit> % :t \f -> foldMap (Ap @Type . f)
10:25:34 <yahb> dmwit: ; <interactive>:1:20: error:; * Expected kind `k0 -> *', but `Type' has kind `*'; * In the type `Type'; In the first argument of `(.)', namely `Ap @Type'; In the first argument of `foldMap', namely `(Ap @Type . f)'; * Relevant bindings include f :: a -> * (bound at <interactive>:1:2)
10:26:18 <dmwit> % :t \f -> foldMap (Ap @(_ :: Type -> _) . f)
10:26:18 <yahb> dmwit: (Foldable t, Applicative w, Monoid a1) => (a2 -> w a1) -> t a2 -> Ap w a1
10:26:34 <dmwit> oo
10:26:40 <dmwit> % :t \f -> foldMap (Ap @(_ :: _ Type) . f)
10:26:40 <yahb> dmwit: forall k (t :: * -> *) (w :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap w a1)) => (a2 -> w a1) -> t a2 -> Ap w a1
10:27:19 <dmwit> Huh. Why didn't that work?
10:27:31 <Iceland_jack> I'd rather not use getAp / Ap directly
10:32:38 <dmwit> % foo :: forall t f m a. (Foldable t, Applicative f, Monoid m) => (a -> f m) -> t a -> f m; foo = coerce (foldMap @t @(Ap f m) @a)
10:32:38 <yahb> dmwit: 
10:32:45 <dmwit> look ma, no getAp/Ap!
10:33:08 <dmwit> Nice on the user, kinda rough on the implementor.
10:33:36 <Iceland_jack> :))
10:33:49 <Iceland_jack> *chefkiss*
10:34:10 <Iceland_jack> now do fold ~
10:35:29 <solonarv> without type applications: foo = (getAp .) #. foldMap .# (Ap .)
10:37:11 <topos> oh hey it's Iceland_jack hello bröther
10:37:42 <Iceland_jack> hi topos!
10:38:17 <topos> i never catch you when you're on how've things been
10:38:19 <jle`> Iceland_jack: i still attempt to tab complete your name every once in a while but get sad when it doesn't work
10:38:35 <solonarv> % :t (getAp .) #. foldMap .# (Ap .)
10:38:35 <yahb> solonarv: forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Ap f a1)) => (a2 -> f a1) -> t a2 -> f a1
10:39:10 <Iceland_jack> topos jle` oh crap, I agree I miss IRC and I haven't been on barely at all
10:41:07 <Iceland_jack> things have been good, kind of up and down but I'm feeling a dip in motivation
10:47:42 <jle`> after your push for derivingvia, feel free to rest on your laurels :)
10:50:06 <boxscape> Does the concept of singleton types for functions make sense?
10:50:39 <jle`> boxscape: yes
10:50:55 <jle`> matchable functions, at least
10:51:09 <boxscape> ah, I think I'm asking about unmatchable ones
10:51:48 <boxscape> just trying to encode a proposition like "exists (f :: a -> b) . P f", and Sigma from singletons expects a singleton for the variable when constructing it
10:52:27 <jle`> sigma from singletons only works for 'matchable' functions
10:52:31 <boxscape> I see
10:52:47 <iqubic> I wish we had proper dependent types in Haskell.
10:52:57 <jle`> which is implented as defunctionalization tokes
10:53:11 <jle`> s/tokes/symboles
10:53:17 <Iceland_jack> jle`: I would like help to think through -XApplyingVia, foldMap @_ @(via Ap)
10:53:22 <boxscape> I was going to try encoding it in a different way (with two foralls) but I'm not sure yet if I can get away without a singletonized f there
10:53:29 <Iceland_jack> but thank you zzz z
10:53:55 <iqubic> @quotes jle`.getSum
10:53:55 <lambdabot> No quotes match. I am sorry.
10:54:07 <iqubic> @quotes getSum sleep
10:54:08 <lambdabot> No quotes for this person. You untyped fool!
10:54:15 <iqubic> @quotes zzz
10:54:15 <lambdabot> erg0t says: <erg0t> sebazzz, me plagias mi vida
10:54:21 <boxscape> @quote jle` getSum
10:54:21 <lambdabot> jle` says: let sleep = pure "zzz" in getSum sleep
10:54:30 <iqubic> Nice. That's what I was looking for.
10:54:36 <iqubic> I love that jle` quote.
10:54:52 <Iceland_jack> haha
10:55:56 <jle`> > let sleep = pure "zzz" in getSum sleep
10:55:59 <lambdabot>  "zzz"
10:56:05 <iqubic> It works.
10:56:35 <iqubic> TIL that the Sum newtype wrapper has an applicative instance.
10:56:55 <Iceland_jack> deriving via Identity :>
10:57:23 <iqubic> I don't understand how deriving via works.
10:57:41 <Iceland_jack> we already have: instance Appliative Identity
10:57:48 <Iceland_jack> Sum and Identity are identical (at runtime)
10:58:06 <Iceland_jack> you basically coerce the Applicative Identity dictionary to get Applicative Sum 
10:59:10 <iqubic> Well, except that Sum is a specialized Identity. Sum only accepts types with a Num instance. Identity accepts any type at all.
10:59:52 <Iceland_jack> oope
11:00:13 <Uniaika> Iceland_jack: you missed a sentence
11:00:14 <Uniaika> < iqubic> Well, except that Sum is a specialized Identity. Sum only accepts types with a Num instance. Identity accepts any type at all.
11:00:33 <iqubic> Technically that's 3 sentences.
11:00:46 <Uniaika> you're technically right
11:00:57 <boxscape> % (coerce (Dict @(Num Int))) :: Dict (Num (Sum Int))
11:00:57 <yahb> boxscape: ; <interactive>:75:2: error:; * Couldn't match type `Int' with `Sum Int' arising from a use of `coerce'; * In the expression: (coerce (Dict @(Num Int))) :: Dict (Num (Sum Int)); In an equation for `it': it = (coerce (Dict @(Num Int))) :: Dict (Num (Sum Int))
11:00:59 <boxscape> hm
11:01:13 <iqubic> What does Dict do?
11:01:31 <boxscape> it wraps a constraint in a data constructor
11:01:40 <boxscape> and you can get it back by matching on it
11:02:08 <iqubic> Does it require ConstraintKinds?
11:02:17 <{abby}> aye
11:03:52 <boxscape> you can do fun things like
11:03:53 <boxscape> % case (unsafeCoerce (Dict @(Num Int))) :: Dict (Num Bool) of Dict -> True + False
11:03:53 <yahb> boxscape: False
11:04:06 <iqubic> What's that doing?
11:04:14 <Iceland_jack> again missing sentences
11:04:24 <boxscape> I suppose that's the same as just unsafeCoercing the Bools to Ints, adding them, and unsafeCoercing the result back
11:04:37 <boxscape> iqubic it asserts that the Num instance for Int applies to Bools
11:04:41 <iqubic> But how do you get False as the answer?
11:04:47 <boxscape> I don't really know
11:05:03 <boxscape> % unsafeCoerce (unsafeCoerce True + unsafeCoerce False) :: Bool
11:05:04 <yahb> boxscape: *** Exception: heap overflow
11:05:11 <boxscape> uh, well, it's not the same after all
11:05:13 <iqubic> What!?!
11:05:41 <boxscape> makes some sense, Int only has one constructor, Bool has two
11:06:16 <mniip> that's defaulting to Integer
11:06:24 <iqubic> How does Int only have one constructor?
11:06:25 <boxscape> oh, right
11:06:34 <mniip> one of the constructors of Integer contains ByteArray#'s
11:06:39 <geekosaur> @src Int
11:06:39 <lambdabot> data Int = I# Int#
11:06:59 <Uniaika>  /22
11:07:02 <Uniaika> (aw)
11:08:18 <boxscape> % unsafeCoerce (unsafeCoerce @Bool @Int True + unsafeCoerce False) :: Bool
11:08:18 <yahb> boxscape: False
11:08:23 <boxscape> there we go
11:10:23 * hackage taskwarrior 0.1.2.2 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.1.2.2 (maralorn)
11:10:34 <Iceland_jack> https://www.reddit.com/r/haskell/comments/qadwm/improbable_uses_of_unsafecoerce/
11:11:40 <geekosaur> @quote monochrom unsafeCoerce.*unsafeCoerce.*unsafeCoerce
11:11:40 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
11:12:46 <Iceland_jack> lol weird
11:24:43 <jle`> iqubic: you can use Sum for non-Num instances
11:24:45 <jle`> > Sum True
11:24:48 <lambdabot>  Sum {getSum = True}
11:25:07 <iqubic> But doesn't that invalidate the monoid instance?
11:25:15 <jle`> Sum Bool has no Monoid instace
11:25:48 <iqubic> Or does the monoid instance look like this: "instance Num a => Sum a where ..."
11:26:40 <jle`> so i wouldn't say Sum is a restricted Identity, but rather it's Identity with an alternative Monoid instance
11:28:26 <iqubic> Right. That makes sense.
11:28:38 <Iceland_jack> in the future you could write it
11:28:38 <Iceland_jack>  newtype Sum a = Sum a
11:28:38 <Iceland_jack>   deriving (Semigroup, Monoid) via Mon (+) 0
11:28:38 <Iceland_jack>   deriving (Eq, Ord, ..) via Identity a
11:28:41 <Iceland_jack>   deriving (Foldable, Functor, Applicative, Monad) via Identity
11:28:48 <Iceland_jack> Maybe deriving Comonad/Traversable/Distributive as well
11:29:06 <maralorn[m]> wow, in my vim something (I guess an update) has changed the syntax highlighting for Haskell. Feels like a new language.
11:29:38 <dmwit> ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
11:29:40 <lambdabot>  .L.hs:252:10: error:
11:29:40 <lambdabot>      Duplicate instance declarations:
11:29:40 <lambdabot>        instance [safe] Num Bool -- Defined at .L.hs:252:10
11:29:50 <dmwit> > Sum True <> Sum False
11:29:53 <lambdabot>  Sum {getSum = True}
11:29:58 <maralorn[m]> Now Type declarations are in bold pink.^^
11:30:10 <Iceland_jack> Fierce!
11:33:59 <fendor> trying to mix servant, swagger-ui and polysemy hurts my brain
11:34:42 <maerwald> yes, because you can never have enough complexity
11:34:55 <maerwald> Your job is done when you barely understand your own code, but it still runs
11:35:11 <fendor> using servant and swagger-ui is complex enough
11:37:23 <fendor> maerwald, what would be a simpler stack for rest-api with database access? I mean, I can think of servant with raw IO, but I like *some* abstraction
11:37:36 <boxscape> % unsafeCoerce unsafeCoerce unsafeCoerce :: Bool
11:37:36 <yahb> boxscape: True
11:39:20 <maerwald> fendor: https://github.com/PostgREST/postgrest
11:40:10 <fendor> maerwald, that is a cool library, but eventually there will be *some* business logic
11:40:12 <fendor> Still same route?
11:40:24 <fendor> would be sensible, I suppose
11:40:37 <maerwald> you can put business logic in postgresql too
11:41:33 <fendor> lol, a project in sql?
11:42:08 <boxscape> can you write a guy in sql?
11:42:11 <boxscape> gui*
11:42:40 <maerwald> https://boingboing.net/2019/10/10/raytracing-with-mysql.html
11:42:49 <boxscape> oh, neat
11:42:55 <dmj`> boxscape: you can put the values of GUI components in the DB, and have the GUI just be  a rendering engine for this
11:43:09 <boxscape> true
11:43:26 <dmj`> a wise man once said, "Lean heavily on the database"
11:43:40 <sm[m]> https://github.com/aquametalabs/aquameta
12:58:54 * hackage xmobar 0.33 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.33 (JoseAntonioOrtegaRuiz)
13:06:03 <topos> Iceland_jack i like cooking. Feel free to ask cooking questions :P
13:09:48 <MarcelineVQ> maralorn: that's the color I use for comments
13:12:53 * hackage filepattern 0.1.2 - File path glob-like matching  https://hackage.haskell.org/package/filepattern-0.1.2 (NeilMitchell)
13:33:24 * hackage mmsyn7s 0.5.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.5.0.0 (OleksandrZhabenko)
14:12:24 * hackage mmsyn7s 0.5.0.1 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.5.0.1 (OleksandrZhabenko)
14:13:54 * hackage mmsyn7s 0.5.0.2 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.5.0.2 (OleksandrZhabenko)
14:44:54 * hackage git-annex 7.20200226 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20200226 (JoeyHess)
15:03:52 <Iceland_jack> topos: I see that now
15:04:35 <Iceland_jack> I will, I've eaten like a pound (ehem kg) of butter in the form of caramel now
15:10:53 <topos> if you like edible caramel, just make dulce de leche!
15:12:23 * hackage git-annex 8.20200226 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200226 (JoeyHess)
15:28:51 <walterclements[m> How to install haskell-ide-engine?
15:29:44 <walterclements[m> I've been running ./install.hs for 20 minutes now and it didn't orint any output
15:31:35 <Axman6> Probably because it needs to install all the dependencies for shake before it can run
15:31:50 <Axman6> so behind the scenes stack will be installing a lot of stuff
15:39:43 <walterclements[m> > cabal: unrecognised command: v2-run (try --help)
15:39:43 <walterclements[m> how to fix this
15:39:46 <lambdabot>  <hint>:1:49: error:
15:39:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:52:22 <solonarv> walterclements[m: I suspect you have a very old cabal version
15:52:27 <solonarv> try running: cabal --version
16:05:53 * hackage typelits-printf 0.2.0.0 - Type-safe printf from parsing GHC TypeLits Symbol  https://hackage.haskell.org/package/typelits-printf-0.2.0.0 (jle)
16:06:19 <walterclements[m> solonarv: cabal-install version 1.24.0.2
16:06:19 <walterclements[m> compiled using version 1.24.2.0 of the Cabal library 
16:11:06 <iqubic> yeah. That's quite old.
16:11:58 <walterclements[m> how to install a new one?
16:11:58 <walterclements[m> `cabal install cabal` doesn't work
16:12:55 <walterclements[m> i'll try `cabal install Cabal`
16:13:18 <walterclements[m> since it says youProbablyWantCapitalCabal
16:14:03 <Axman6> cabal install cabal-install
16:14:15 <Axman6> cabal is the library
16:14:36 <walterclements[m> ok
16:14:53 <MarcelineVQ> *Cabal is the library   :>
16:15:37 <MarcelineVQ> the cabal-install package provides the 'cabal' executable
16:16:46 <iqubic> It's a weird weird world.
16:22:10 <dmj`> iqubic: you can say that again
16:25:52 <iqubic> It's a weird weird world.
16:26:08 <iqubic> I can, and will say it again.
17:58:48 <walterclements[m> Why does cabal use http by default
18:15:36 <solonarv> walterclements[m: I'm not sure, but the downloads are checked against hashes
18:16:06 <solonarv> so there is no possibility of tampering (or rather switching to https wouldn't add much to that)
18:16:18 <solonarv> it might just be showing its age
18:17:08 <walterclements[m> ok but if hackage supports https why not use it in default settings?
18:17:32 <solonarv> the website supports https, but I don't know if the back-end does
18:18:02 <solonarv> you can try asking in #hackage, perhaps you'll find someone knowledgeable there - I don't really know what I'm talking about
18:18:29 <walterclements[m> it works if i change it in `~/.cabal/config`
18:45:54 * hackage antiope-dynamodb 7.5.1 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-dynamodb-7.5.1 (arbornetworks)
18:46:54 * hackage antiope-messages 7.5.1, antiope-sns 7.5.1, antiope-shell 7.5.1, antiope-core 7.5.1, antiope-contract 7.5.1, antiope-athena 7.5.1, antiope-s3 7.5.1, antiope-sqs 7.5.1, antiope-es 7.5.1, antiope-optparse-applicative 7.5.1 (arbornetworks)
19:22:32 <rotaerk> hmm i'm writing bindings to a C library for which at least one of the headers appears to be generated by cmake when building it...
19:22:53 <rotaerk> how am I supposed to create bindings to something with a variable, configurable header file used to build it?
19:25:12 <solonarv> rotaerk: first, ew, sucks that you have to deal with this
19:25:31 <solonarv> second... I guess you could just bless one specific configuration?
19:25:43 <solonarv> that's probably the lowest-effort approach
19:27:51 <rotaerk> I'm currently resolving the assimp library through nixpkgs, and if I go to the nix store where the bin/lib folder are, I see an include folder which does contain the headers
19:28:35 <rotaerk> but I didn't intend to require people who use my binding to resolve it in the same way ... or heck, to hard-build my binding against a specific version of nixpkgs (another one might produce a different config.h)
19:32:40 <kost> If 2 IO actions are executed in this way `mask_ actionA >> mask_ actionB` can I get an async exception between the two actions?
19:32:57 <rotaerk> think I really just need to dig into the generation of this config.h and understand what exactly might vary
19:33:04 <rotaerk> might be nothing material to my bindings...
19:46:56 <koz_> I have a list of inputs for computations to functions of the form '(MonadError Err m) => a -> m b'. How would I have it return me the _first_ computation that succeeds, or an error if they _all_ fail?
19:47:34 <rotaerk> solonarv, looks like the ways in which the config can vary does matter, and does impact the bindings
19:47:52 <rotaerk> e.g. one build of assimp may use floats where another might use doubles
19:48:02 <rotaerk> so to support either, I'd need to make my bindings also configurable or something
19:48:31 <koz_> traverse won't do what I want, since it nopes out at the first error of trouble.
19:49:26 <koz_> (setting aside the obvious fact it's give me m [b], not m b)
19:50:46 <koz_> So, in short, I'm after '(MonadError Err m) => (a -> m b) -> [a] -> m b', which is the first successful result, or an error if they _all_ fail.
19:50:49 <koz_> How do?
19:51:18 <koz_> (assume empty list is 'all fail')
19:51:43 <rotaerk> it should return the result of the first success; should it also stop processing the rest after a success?
19:51:59 <koz_> rotaerk: Ideally, but not a huge deal if not.
19:54:57 <rotaerk> if you did want it to process them all, but ignore all but only the first successful result ...
19:55:15 <koz_> That would be fine.
19:55:33 <rotaerk> then that sounds similar to the Monoid instance for First
19:56:01 <koz_> How does that help in this context though? I don't have a Maybe handy.
19:56:19 <koz_> I'm in 'some hellstack with MonadError Err capabilities'.
19:57:27 <rotaerk> there's probably not a generalized function for that; don't see one anyway
19:57:34 <rotaerk> would have to write one probably
19:57:41 <koz_> What would that look like though?
19:57:44 <rotaerk> hmm
19:57:48 <koz_> I only have catchError to build on.
19:59:26 <koz_> I guess I could wrap in StateT (Maybe b), drag that through catching _everything_, and then check what state I got?
19:59:34 <koz_> And throw on Nothing?
20:00:09 <rotaerk> well first, let's say they all fail... each will throw their own error
20:00:16 <rotaerk> if they all fail, what should be the error that's thrown at the end?
20:00:24 <koz_> I can handle this problem.
20:00:38 <koz_> (the error that needs to be thrown in such a case isn't related to any of the errors the individuals could throw)
20:00:48 <koz_> (aside from being an inhabitant of Err)
20:01:05 <koz_> I might just try that StateT (Maybe b) trick.
20:01:38 <koz_> Or just a foldM even?
20:01:41 <koz_> Over Maybe b.
20:01:42 <rotaerk> given this:  blah :: (MonadError Err m) => Err -> (a -> m b) -> [a] -> m b
20:02:44 <rotaerk> blah finalError f [] = throwError finalError; blah finalError f (a:as) = catchError (f a) (\e -> blah finalError f as)
20:02:55 <rotaerk> might be simplifiable with a fold though
20:03:10 <koz_> Yeah, that's _basically_ a foldM with a maybe glued to it.
20:03:20 <koz_> Thanks - that's exactly the guidance I needed!
20:04:24 <rotaerk> (note this will stop after the first success)
20:04:34 <koz_> Would foldM _not_ do this>
20:04:40 <koz_> ?
20:04:49 <rotaerk> I think a fold goes all the way to the end always
20:04:58 <rotaerk> well, except when dealing with a lazy output...
20:05:02 <koz_> Let me sketch and see.
20:05:52 <koz_> :t foldM
20:05:54 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
20:06:54 * hackage cabal-rpm 2.0.4 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.4 (JensPetersen)
20:10:05 <rotaerk> koz_, https://hackage.haskell.org/package/extra-1.6.20/docs/Control-Monad-Extra.html#v:firstJustM
20:10:12 <rotaerk> seems very close to that, but generalized beyond Maybe
20:10:45 <koz_> That's basically what I'm sketching lol.
20:10:46 <rotaerk> they define it recursively rather than in terms of a fold
20:11:04 <koz_> Might just borrow that instead.
20:25:08 <rotaerk> I think I have to add flags to my package
20:25:50 <rotaerk> flags aren't that annoying, I guess, at least with cabal.project
20:32:43 <dsal> I'm trying to write a program, but I don't know what I want it to do.  This is making things difficult.
20:34:11 <MarcelineVQ> Have you tried asking it?
20:43:21 <MarcelineVQ> koz_: import Data.Semigroup (First(..)) import Data.Monoid (Alt(..))  \f -> fmap getFirst . getAlt . foldMap (Alt . fmap First . f)   idk how to test mtl stuff easily but this was a bit of a fun build in ghci while exploring your query. importantly this is First of Semigroup not Monoid
20:44:58 <MarcelineVQ> i.e.  (\f -> fmap getFirst . getAlt . foldMap (Alt . fmap First . f)) :: (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
20:45:06 <MarcelineVQ> No Maybe required
20:46:21 * ski would wish docs would stop writing laws as if `==' was semantic equality
20:47:15 <hololeap> % :t \f -> runMaybeT . getAlt . mconcat . fmap (Alt . MaybeT . f)
20:47:15 <yahb> hololeap: ; <interactive>:1:7: error: Variable not in scope: runMaybeT :: f0 a0 -> c; <interactive>:1:50: error:; * Data constructor not in scope: MaybeT :: b -> f0 a0; * Perhaps you meant variable `maybe' (imported from Prelude)
20:47:17 <MarcelineVQ> Neat but also probably not relevant since MonadError doesn't say anything about Alternative so it might 'just happen' to be the case that 'empty' and an error coincide, or not, idk hehe
20:47:35 <hololeap> % import Control.Monad.Trans.Maybe
20:47:35 <yahb> hololeap: 
20:47:37 <hololeap> % :t \f -> runMaybeT . getAlt . mconcat . fmap (Alt . MaybeT . f)
20:47:37 <yahb> hololeap: Monad m => (a1 -> m (Maybe a2)) -> [a1] -> m (Maybe a2)
20:48:38 <ski> @let import qualified Data.Semigroup as DS
20:48:40 <lambdabot>  Defined.
20:48:44 <ski> @type \f -> fmap DS.getFirst . getAlt . foldMap (Alt . fmap DS.First . f)
20:48:45 <lambdabot> (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
20:57:24 * hackage deriving-aeson 0.1.2 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.1.2 (FumiakiKinoshita)
21:00:43 <MarcelineVQ> koz_: but I did notice that every instance (except Either) for MonadError I looked at had an Alternative instance
21:04:08 <hololeap> empty doesn't take an argument, so it doesn't make sense for Either
21:04:43 <MarcelineVQ> Yes there's no sane default there
21:05:54 <hololeap> unless it was instance Monoid e => Alternative (Either e)
21:06:07 <MarcelineVQ> I was more remarking on the abundance of Alternative instances likely to be available with MonadError. As opposed to something like Monoid, where you're more limited, maybe just IO has that as-is
21:07:44 <hololeap> any Alternative could "fit" into MonadError (), but not the other way around
21:09:14 <hololeap> just want to point out that: foldMap (Alt . fmap DS.First . f) === foldMap @(MaybeT _) (Alt . f)
21:13:36 <hololeap> actually, foldMap (Alt @(MaybeT _) . f)
21:14:24 <hololeap> the Alternative behavior for MaybeT is to return the first `m (Just a)`, so the First is redundant if you use that
21:17:17 <MarcelineVQ> What would that look like, as a complete example compared to   \f -> fmap getFirst . getAlt . foldMap (Alt . fmap First . f)
21:18:12 <hololeap> % :t \f -> getAlt . foldMap (Alt @(MaybeT _) . f)
21:18:12 <yahb> hololeap: (Foldable t, Monad w) => (a1 -> MaybeT w a2) -> t a1 -> MaybeT w a2
21:18:16 <hololeap> or
21:18:23 <hololeap> % :t \f -> runMaybeT . getAlt . foldMap (Alt . MaybeT . f)
21:18:23 <yahb> hololeap: (Foldable t, Monad m) => (a1 -> m (Maybe a2)) -> t a1 -> m (Maybe a2)
21:20:54 <MarcelineVQ> Oh you meant literally that, I thought you might have been doing something extra to elide having to deal with the Maybe
21:22:24 <hololeap> oh, i guess i didn't realize that Semigroup.First doesn't take a Maybe
21:22:39 <hololeap> so yeah, yours is more general
21:23:02 <MarcelineVQ> ah ye that's the reason I used that one, Maybe is so last decade :>
21:25:18 <heatsink> How do you get an editor to agree with hindent/brittany/ormolu on how to indent things?
21:27:03 <MarcelineVQ> sometimes such tools come with editor configs  https://github.com/lspitzner/brittany/#editor-integration
21:30:03 <viraltaco_> Hi
21:30:22 <heatsink> hi
21:30:54 <heatsink> thanks MarcelineVQ
21:35:31 <MarcelineVQ> heatsink: I suspect it's not quite what you mean anyway, having looked closer. You're wanting it so that if you hit enter the editor will indent now to where ormolu would have indented if it was prettified? Not sure if that's a thing or not, seems like it'd be hard to do without running the prettifier in the first place to make sure the rest of the code is in-place.
21:36:13 <hololeap> i'm confused:
21:36:50 <hololeap> @ (fmap DS.getFirst . getAlt . foldMap (Alt . fmap DS.First . f)) [Nothing, Just 3, Just 4, Nothing]
21:37:00 <hololeap> % (fmap DS.getFirst . getAlt . foldMap (Alt . fmap DS.First . f)) [Nothing, Just 3, Just 4, Nothing]
21:37:00 <yahb> hololeap: ; <interactive>:11:7: error:; Not in scope: `DS.getFirst'; No module named `DS' is imported.; <interactive>:11:50: error:; Not in scope: data constructor `DS.First'; No module named `DS' is imported.
21:37:12 <hololeap> > (fmap DS.getFirst . getAlt . foldMap (Alt . fmap DS.First . f)) [Nothing, Just 3, Just 4, Nothing]
21:37:15 <lambdabot>  error:
21:37:15 <lambdabot>      • Ambiguous type variables ‘f0’,
21:37:15 <lambdabot>                                 ‘b0’ arising from a use of ‘show_M11051398065...
21:37:29 <hololeap> meh
21:37:44 <MarcelineVQ> your f also isn't in scope
21:38:01 <hololeap> sorry i was pasting the wrong thing
21:38:25 <hololeap> > foldMap (Alt . fmap First) [Nothing, Just 3, Just 4, Nothing]
21:38:27 <lambdabot>  error:
21:38:28 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_134’
21:38:28 <lambdabot>      • In the expression: e_134
21:38:38 <hololeap> > foldMap (Alt . fmap DS.First) [Nothing, Just 3, Just 4, Nothing]
21:38:41 <lambdabot>  Alt {getAlt = Just (First {getFirst = 3})}
21:38:46 <hololeap> there we go
21:38:55 <hololeap> > foldMap (Alt . fmap DS.Last) [Nothing, Just 3, Just 4, Nothing]
21:38:57 <lambdabot>  Alt {getAlt = Just (Last {getLast = 3})}
21:38:59 <heatsink> MarcelineVQ, yes, that's what I wanted.  "editor integration" sounded like what I was looking for
21:39:13 <hololeap> so changing DS.First to DS.Last doesn't do anything
21:40:01 <MarcelineVQ> hololeap: because the Alt is Maybe I guess
21:40:42 <hololeap> > foldMap (Alt . fmap DS.First) [[], [3], [4], []]
21:40:46 <lambdabot>  Alt {getAlt = [First {getFirst = 3},First {getFirst = 4}]}
21:41:18 <hololeap> hm ok
21:43:27 <MarcelineVQ> but it does highlight that the versoin I was looking at isn't really making use of First either
21:43:50 <hololeap> yeah that's what i was thinking too
21:45:44 <hololeap> > foldMap Alt [Nothing, Just 3, Just 4, Nothing]
21:45:47 <lambdabot>  Alt {getAlt = Just 3}
21:45:57 <hololeap> > foldMap (DS.Dual . Alt) [Nothing, Just 3, Just 4, Nothing]
21:46:00 <lambdabot>  Dual {getDual = Alt {getAlt = Just 4}}
21:50:04 <hololeap> % :t \f -> getAlt . foldMap (Alt . f)
21:50:04 <yahb> hololeap: forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Alt f a1)) => (a2 -> f a1) -> t a2 -> f a1
21:50:38 <sm[m]> a 200 line function.. that's just too big, isn't it
21:51:06 <hololeap> % :t (\f -> getAlt . foldMap (Alt . f)) :: (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
21:51:06 <yahb> hololeap: (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
21:51:46 <hololeap> that's as good as it gets. it would work as expected, assuming the Alternative follows the laws for unit and whatnot
21:55:21 <hololeap> assuming that's the case, it would work like First. if you (for whatever reason) wanted it to work like Last, you could wrap the Alt in DS.Dual
21:56:00 <viraltaco_> does everyone here agree that haskell is weird af?
21:56:00 <hololeap> til :)
21:56:23 <viraltaco_> Maybe it's just me… Can't be just me
21:56:40 <iqubic> Haskell's not that weird.
21:56:48 <hololeap> it's different from other languages, for sure. those differences are part of what people like about it.
21:57:28 <viraltaco_> k
21:57:32 <viraltaco_> i leave now
21:57:48 <Axman6> what a prediction!
21:58:10 <MarcelineVQ> It only works like First when the Alternative is Maybe. As a point of interest what you have there is also   asum . fmap f     The goal we're after here is "<koz_> So, in short, I'm after '(MonadError Err m) => (a -> m b) -> [a] -> m b', which is the first successful result, or an error if they _all_ fail."
21:58:57 <hololeap> nah, it works like First as long as the unit laws hold: f <|> empty = f ; empty <|> f = f
21:59:24 <hololeap> actually `empty <|> f = f` would suffice
21:59:48 <MarcelineVQ> consider the List Alternative
22:01:10 <hololeap> hm, true
22:01:46 <hololeap> > [1,2] <|> [3,4]
22:01:48 <lambdabot>  [1,2,3,4]
22:03:42 <hololeap> > DS.First [1,2] <|> DS.First [3,4]
22:03:45 <lambdabot>  error:
22:03:45 <lambdabot>      • Could not deduce (Alternative DS.First)
22:03:45 <lambdabot>          arising from a use of ‘<|>’
22:04:06 <hololeap> > Alt (DS.First [1,2]) <|> Alt (DS.First [3,4])
22:04:08 <lambdabot>  error:
22:04:09 <lambdabot>      • Could not deduce (Alternative DS.First)
22:04:09 <lambdabot>          arising from a use of ‘<|>’
22:04:19 <hololeap> lol nvm i'm tired
22:08:09 <MarcelineVQ> That's about where I'm at too :>
22:28:04 <hololeap> @type catchError
22:28:06 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
22:28:56 <hololeap> @let foo _ []  = pure Nothing ; foo f (x:xs) = catchError (Just <$> f x) (\_ -> foo f xs)
22:28:59 <lambdabot>  Defined.
22:29:03 <hololeap> @type foo
22:29:05 <lambdabot> MonadError e f => (t -> f a) -> [t] -> f (Maybe a)
22:29:42 <hololeap> i don't know how you would define that with a fold, although i'd bet it could be done
22:32:17 <hololeap> @let onlyOdd = foo (\x -> if odd x then pure x else throwError "not odd")
22:32:20 <lambdabot>  Defined.
22:32:31 <hololeap> > onlyOdd [1..5]
22:32:34 <lambdabot>  error:
22:32:34 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M569873979756...
22:32:34 <lambdabot>        prevents the constraint ‘(Show
22:32:59 <hololeap> @let onlyOdd = runExcept . foo (\x -> if odd x then pure x else throwError "not odd")
22:33:01 <lambdabot>  .L.hs:262:1: error:
22:33:01 <lambdabot>      Multiple declarations of ‘onlyOdd’
22:33:01 <lambdabot>      Declared at: .L.hs:260:1
22:33:14 <hololeap> @let onlyOdd' = runExcept . foo (\x -> if odd x then pure x else throwError "not odd")
22:33:17 <lambdabot>  Defined.
22:33:21 <hololeap> > onlyOdd' [1..5]
22:33:24 <lambdabot>  Right (Just 1)
22:33:31 <hololeap> > onlyOdd' [2..5]
22:33:34 <lambdabot>  Right (Just 3)
22:33:39 <hololeap> > onlyOdd' [2,4,6,8]
22:33:42 <lambdabot>  Right Nothing
22:35:24 * hackage shwifty 0.0.2.0 - Generate swift types from haskell types.  https://hackage.haskell.org/package/shwifty-0.0.2.0 (chessai)
22:35:38 * hololeap poops on the floor
22:36:10 <iqubic> Why?!?!
22:36:39 <hololeap> it's a shwifty thing...
22:41:43 <Axman6> Awww yeah, let's get shwifty
22:42:36 <Axman6> chessai: love it
23:39:04 <fishooter> hi :) I've spent past couple days implementing an assignment for students to learn Haskell, and I made a reference solution. Could you please take a look at it? I was tasked to do this project (phd life...) and I'm also a Haskell beginner. The repository is temporarily located at https://github.com/michalsustr/haskell_gomoku
23:39:12 <fishooter> If you can give me some feedback I would be absolutely grateful!
23:39:18 <fishooter> dminuoso: merijn: Taneb: solonarv: MarcelineVQ: maralorn[m]:  thank you for your help :)
23:43:31 <mniip> fishooter, `zip (range indexRange) (repeat Nothing)` a list comprehension would be conceptually simpler here
23:43:39 <mniip> idk how "beginner" your students are
23:44:44 <mniip> also the Game module has some graphics (?) code that should probably be separated out
23:45:23 <koz_> Non-Haskell questions: should I order two pizzas?
23:45:27 <mniip> instead of `chunksOf ... elems` I'd use groupBy the y coordinate
23:45:34 <dminuoso> fishooter: I'd avoid the use of type aliases in general. 
23:45:48 <mniip> koz_, let x :: Bool = x in x
23:46:05 <koz_> mniip: Isn't that divergent?
23:47:21 <mniip> fishooter, and while we probably don't care about the exact format of your showGame function as it's only used for debugging, readBoard needs a comment explaining the expected input
23:47:38 <mniip> also it's not good style to use Show for pretty-printing, but for educational purposes I guess that's fie
23:48:13 <mniip> again in the Logic module you're mixing "IO" code with the core logic
23:48:37 <dminuoso> Indeed, comments in general are rather lacking.
23:49:59 <mniip> yeah in Logic I see a lot of functions with similar names and unclear purpose
23:50:32 <mniip> (as an experienced haskeller I can read the implementation and deduce what it's doing, but your students might be unable to)
23:50:36 <dminuoso> fishooter: Regarding type aliases. Type aliases are poor barriers. They lead to confusing diagnostics (because at times aliases are expanded, at times they are not), and they lead to accidents (Because when you define `type Money = Int` for instance, any Int is admissable, you're not leveraging the benefits of a typesyste mhere)
23:50:55 <dminuoso> A newtype is almost always the better choice, even if it feels a bit annoying at the barriers where you need to unwrap/rewrap.
23:51:14 <mniip> also I think your win condition checking is too complicated
23:52:07 <dminuoso> Add findK to the "too complicated" lit.
23:53:05 <dminuoso> It's readable to the experienced Haskeller, but even I have to spend time figuring it out what it even does on an abstract level
23:54:18 <dminuoso> fishooter: Furthermore, you're a bit inconsistent. Sometimes you use ($) everywhere in an area, in other places you just use parens everywhere. I recommend sticking to one convention mostly, the latter if possible. 
23:54:52 <dminuoso> Reading code with ($) comfortably requires some experience in order to quickly scan how code associates, parens are likely to be easier to read by inexperienced students.
23:59:34 <lumiere> hey i'm a total haskell newb and been trying to learn it i wanted to try my hand at a parser https://gist.github.com/anooppoommen/670b6e4daf5c094d8d8a556d375fea56 could someone please help me debug this i get an error stating that toS is not defined in scope 
