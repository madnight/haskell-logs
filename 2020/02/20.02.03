00:04:24 * hackage envy-extensible 0.2.0.0 - Provides FromEnv in envy instance for Record of extensible.  https://hackage.haskell.org/package/envy-extensible-0.2.0.0 (igrep)
00:09:35 <glguy> There's a gen-bounds command on cabal
00:56:57 <dminuoso> Athas: An alternate solution might be to extend your life.
01:00:45 <siers> what's scan useful for?
01:01:32 <Athas> siers: all kinds of things!  In particular for computing offsets.
01:02:00 <siers> hmm, I can't picture what that entails
01:02:53 <Athas> If you have a bunch of sequences of various sizes, and you want to pack them to a flat sequence, you can use a scan to compute the start offset of each original sequence in the flattened sequence.
01:03:03 <Athas> You would scan the list of lengths of the original sequences.
01:03:52 <Athas> > concat [[1], [2,3], [4,5,6]]
01:03:54 <lambdabot>  [1,2,3,4,5,6]
01:03:57 <Athas> > scanl (+) 0 [[1], [2,3], [4,5,6]]
01:04:00 <lambdabot>  error:
01:04:00 <lambdabot>      ‚Ä¢ No instance for (Num [Integer])
01:04:00 <lambdabot>          arising from a use of ‚Äòe_10123456‚Äô
01:04:05 <Athas> Urk.
01:04:09 <Athas> > scanl (+) 0 (map length [[1], [2,3], [4,5,6]])
01:04:11 <lambdabot>  [0,1,3,6]
01:04:29 <siers> hm! that's nice
01:04:44 <siers> elegant
01:04:55 <Athas> But the most wonderful property of scan, which you can't really exploit in Haskell, is that it somewhat surprisingly can be computed efficiently in parallel.
01:05:09 <Athas> It's a fundamental parallel building block, and the key to parallelising things that don't seem parallel at first glance.
01:09:47 <siers> but doesn't it require previous values to compute next ones?
01:17:02 <dminuoso> Is there some idiomatic way to pattern match on "unordered pairs" without a big mess of continuations?
01:18:27 <dminuoso> Right now I have a large set of pattern matches `f Foo x = ...; f x Foo = ...;` but its getting to the point where it's hard to argue when thing will actually pattern match
01:22:08 <dminuoso> The closest idea I had was doing something like `sortTuple :: Ord a => (a, a) -> (a, a)`, but then I would have to manually assure that pattern matchers are specified in the correct order
01:27:11 <opqdonut> dminuoso: I've used a pattern like `f Foo x = ...; f Bar x = ...; f x y = f y x`
01:27:34 <opqdonut> but that's a bit dangerous since the compiler can't help you prove exhaustiveness, and you risk a loop if you're not exhaustive
01:33:30 <Athas> siers: in general yes, but for associative operators you can do clever things.
01:34:34 <merijn> dminuoso: You can newtype and first compare the min element of each tuple and then the max element?
01:36:06 <merijn> dminuoso: "newtype Unordered a = Unordered (a, a); instance Ord a => Ord (Unordered a) where compare (Unordered (x1, y1)) (Unordered (x2, y2)) = compare (min x1 y1) (min x2 y2) <> compare (max x1 y1) (max x2 y2)"?
01:38:42 <dminuoso> merijn: The problem with that is specifying pattern matches sensibly. You cant have wildcard matches with that or even binding patterns.
01:39:15 <dminuoso> Of course I could set up an entire DSL for this, but the ability to bind patterns essentially introduces continuations.
01:39:54 <Philonous> You could still sort the pair before matching, then at least you only need to look at the upper triangle 
01:40:00 <dminuoso> I suppose in some sense a pattern `Just x -> ...` can be thought of as a continuation `\x -> ...` tied to some pattern match information Just.
01:40:03 <Philonous> Although it has the same problem as opqdonut's solution
01:40:30 <dminuoso> Philonous: Right, because then you have to manually assert that you always order the patterns correctly.
01:40:42 <dminuoso> When writing initial code that is easy, but when you refactor or add a pattern later, that's just a recipe for bugs
01:41:04 <merijn> dminuoso: You can write a pattern synonym that forces sorting on the pair
01:41:10 <merijn> (using view patterns)
01:41:44 <merijn> Then you can't forget (although you pay overhead for sorting each time0
01:41:46 <jackdk> % (4, 1, 3, 2, 5) partsOf each %~ sort
01:41:46 <yahb> jackdk: ; <interactive>:119:1: error:; * Couldn't match expected type `(Traversing (->) f1 s0 t0 a0 a0 -> LensLike f1 s0 t0 [a0] [a0]) -> ((a1 -> f0 b0) -> s1 -> f0 t1) -> ASetter s t [()] [()]' with actual type `(Integer, Integer, Integer, Integer, Integer)'; * The function `(4, 1, 3, 2, 5)' is applied to two arguments,; but its type `(Integer, Integer, Integer, Integer, Integer)' has none; 
01:41:53 <Philonous> dminuoso, I think this continuation view is exactly how constructors are defined formally, by it's introduction and elimination rules, and that's just the elimination rule 
01:41:56 <dminuoso> merijn: You cant sort the pattern though, can you?
01:42:00 <jackdk> % (4, 1, 3, 2, 5) & partsOf each %~ sort
01:42:00 <yahb> jackdk: (1,2,3,4,5)
01:42:06 <merijn> dminuoso: Why not?
01:42:11 <jackdk> dminuoso: do you like lenses?
01:42:23 <merijn> dminuoso: You can do it in a viewpattern and you can use those in pattern synonyms
01:45:14 <dminuoso> merijn: Say you want to express something like `(Left x, y) | x < 0 -> err (show x <> " cant be negative and left")`
01:45:25 <dminuoso> In a way that it matches both (Left x, y) and (y, Left x)
01:48:41 <merijn> https://paste.debian.net/1128971/
01:48:45 <merijn> <- Mad skillz
01:49:17 <dminuoso> Wait uh what. Okay. 
01:49:37 <dminuoso> merijn: Yeah, I think that's exactly the expressivity I was looking for.
01:49:52 <merijn> Like I said, you pay the ordering cost every time you match, but that whether that matters or not depends
01:49:54 <Philonous> That hides the explicit call to sort, but your still lose exhaustiveness checking
01:50:02 <merijn> Philonous: How?
01:51:34 <dminuoso> merijn: Hold on, if I specify `Pair (Just x) y` and `Pair y (Just x)`, will that give me the *same* exact pattern?
01:51:37 <Philonous> case x of (Pair Left{} Right{}) -> ...; (Pair Left{} Left{}) -> ...; (Pair Right{} Right{}) -> ; -- no Right Left because it's impossible 
01:51:57 <Philonous> GHC will tell you the pattern isn't exhaustive
01:52:34 <dminuoso> merijn: It doesn't address the core issue that you need to manually assure that your pattern match descriptions are sorted correctly.
01:54:33 <boxscape> I remember there being a way to have a Constraint that is fulfilled if one of two Constraints are (like an Either for Constraints), anyone happen to have a link to that?
01:54:36 <dminuoso> If you specified `Pair Nothing (Just 'a')` it would never even match
01:54:49 <dminuoso> Because such a pair would be ordered `(Just 'a', Nothing)`
01:54:52 <boxscape> s/are/is
01:55:32 <merijn> I propose an alternate solution: Stop wanting impossible things ;)
01:57:00 <Philonous> I think this is exactly the sort of thing you'd want https://gitlab.haskell.org/ghc/ghc/issues/3919 for 
01:57:04 <dminuoso> boxscape: Were you thinking of https://hackage.haskell.org/package/constraints-extras-0.3.0.2/docs/Data-Constraint-Extras.html perhaps?
01:59:55 <boxscape> dminuoso not exactly what I remembered but it might do. I'm mostly interested in how to make it work in general rather than requiring a specific package, so thanks.
02:00:25 <boxscape> s/mostly/purely, if I'm being honest
02:04:37 <dminuoso> boxscape: Well the problem is that the constraint solver doesn't understand coproducts.
02:04:45 <dminuoso> boxscape: So GADTs is the best you can do.
02:05:02 <boxscape> I see
02:06:28 <boxscape> actually coproduct is the search term I needed to find what I was thinking of https://github.com/rampion/constraint-unions#readme
02:06:49 <dminuoso> boxscape: So what you are looking for is essentially constraints-extras.
02:12:57 <__monty__> aa/wg 14
02:14:39 <__monty__> woops
02:20:39 <merijn> hmmm, there's no convenient conduit combinator for turning a stream of elements into a stream of chunks? That seems a weird oversight...
02:21:48 <merijn> Ah, no, haddock search is just failing me
02:39:09 <jonathan_> Can anyone give me an intuition for reflexivity? I'm looking into the GDP module
02:41:05 <dminuoso> jonathan_: Do you mean reflexivity in general?
02:49:26 <jonathan_> yes!
02:49:57 <haskelllisp[m]> http://hackage.haskell.org/package/amazonka-1.6.1/docs/Control-Monad-Trans-AWS.html#t:Region   not support `Hong Kong` ?
03:15:38 * ski 's sometimes done what opqdonut suggested
03:16:32 <ski> jonathan_ : reflexivity of a binary relation ?
03:17:29 <dminuoso> opqdonut, ski: sadly it wouldn't work for me since I need a default case to begin with.
03:18:05 <dminuoso> But.. I suppose I could move it it into a helper function and use a Bool binary counter..
03:18:36 <dminuoso> Something like `f x y = go x y False where ... go x y True = default; go x y False = go y x`
03:18:54 <dminuoso> That might not be too bad at all.
03:19:44 <ski> would that help with exhaustivity ?
03:19:59 <dminuoso> ski: Well it would always be exhaustive anyway since I have a default case.
03:20:16 <opqdonut> heh that's a nice trick
03:20:19 <opqdonut> I wonder if it'll optimize away
03:21:42 <dminuoso> ski: https://gist.github.com/dminuoso/ad38b946b3a2b20c0855d48b281c7aa4
03:22:34 <jonathan_> ski: yes
03:22:45 <ski> i'm reminded of expressing symmetric closure in Prolog
03:23:33 <dminuoso> opqdonut: With that slight modification I actually love it. Thank you!
03:24:01 <ski> jonathan_ : well, if `R' is a binary relation, and we write `x R y' to mean that the `R' relation holds between `x' and `y' (in that order); then to say that `R' is a reflexive relation means that, for all `x', `x R x' holds. "everything is related to itself"
03:25:35 <jonathan_> ski: my intuition is that it's a 2 argument function, taking two arguments, producing a bool. If the arguments are equal, the function always returns True
03:25:59 <jonathan_> is that a reasonable programming approximation, jargon aside?
03:26:20 <ski> jonathan_ : yes. if we represent a relation as a function computing a `Bool', that's what reflexivity would mean, in those terms
03:26:25 <jonathan_> Otherwise, please define "is related to"
03:26:37 <jonathan_> ok
03:26:39 <jonathan_> great
03:26:46 <ski> jonathan_ : consider a graph
03:27:07 <ski> say we have cities, and direct railroad links between them
03:27:44 <dminuoso> jonathan_: A relation R between two sets A and B is a subset of AxB. For two elements x and y out of A and B respectively, we say that `x` and `y` are related if (x,y) is an element of R.
03:28:04 <ski> so, we could have a binary relation `directlyLinked', that holds of two cities, in case there a direct link between them
03:28:15 <dminuoso> Or, you might say `x` and `y` are related by R if they are an element of R.
03:28:25 <dminuoso> Or rather, if (x,y) is an element of R. :)
03:28:26 <ski> one way to represent `directlyLinked' would be as a function `directlyLinked :: City -> City -> Bool'
03:29:22 <ski> makes sense, jonathan_ ?
03:29:40 <jonathan_> Go on. I think I'll have to sort out the two explanations in order to parse them mentally. Got a bit confusing until I noticed that there are two ppl talking to me
03:29:51 <ski> yea
03:30:42 <ski> well, if we have a list (or set) of all cities, this could be workable. we can pick (somehow) two cities, and ask whether they're directly connected, by calling this `directlyLinked' function on them
03:30:54 <jonathan_> makes sense so far
03:31:32 <ski> if we want to find all neighbouring cities of a city, we could then also simply run through all cities, and ask whether, each in turn, is directly linked to the current one
03:32:02 <ski> however, if there's many cities, and most are not directly linked to each other, this could be a bit inefficient
03:32:55 <ski> an alternative is to try to take what dminuoso said at face value. considering `directlyLinked' as a subset of the set of all possible pairs of two cities
03:34:15 <ski> in Haskell, that could be `directlyLinked :: Set (City,City)'. or, if we simplify things a bit (making it easier to grasp perhaps, but not as nice), `directlyLinked :: [(City,City)]'. so a list of all the pairs of cities which are directly linked
03:35:31 <ski> so, given a specific pair of two cities, we can ask whether it's in this (sub)set (or in this list)
03:36:29 <ski> yet another representation would be, for each city, to tell which cities are its neighbours. that would be `directlyLinked :: City -> Set City'. that might perhaps be more efficient in the many-cities scenario
03:36:52 <ski> jonathan_ : my point is that there's several different ways to represent the same relation
03:36:58 <dminuoso> Or, slightly more formally, a relation R over some set A is, again, a subset of AxA. That relation is said to be reflexive if, for all x out of A, (x,x) is a memebr of R. That is, every element is related to itself.
03:37:55 <ski> jonathan_ : "is that a reasonable programming approximation, jargon aside?" -- so, what you said about having a binary function producing a `Bool' is *one* possible programming approximation
03:38:05 <jonathan_> ah
03:38:11 <jonathan_> I see what you're getting at
03:39:27 <dminuoso> jonathan_: Another common example for reflexive relationships is the greater-or-equal relationship in natural numbers. Every number is clearly greater-or-equal with itself, so every natural number is related by itself by (>=)
03:39:33 <ski> jonathan_ : concretely, reflexivity would mean different (but related) things, in each of these different representations of the relation
03:40:23 <dminuoso> jonathan_: And, if a relationship is not reflexive its said to be irreflexive. For instance the greater-than relationship, no natural number is greater than itself.
03:40:25 <ski> jonathan_ : in the `directlyLinked :: City -> City -> Bool' case, reflexivity means `forall city. directlyLinked city city = True'
03:40:54 <dminuoso> jonathan_: So the greater-than relationship over natural numbers is irreflexive, but the greater-or-equal relationship is reflexive. :)
03:40:55 <ski> jonathan_ : in the `directlyLinked :: Set (City,City)' case, reflexivity means `forall city. member (city,city) directlyLinked = True'
03:41:18 <ski> jonathan_ : in the `directlyLinked :: City -> Set City' case, reflexivity means `forall city. member city (directlyLinked city) = True'
03:41:39 <jonathan_> Thank you
03:41:40 <jonathan_> :)
03:41:46 <ski> jonathan_ : but in all cases, we're representing the same abstract concept of the relation expressed being reflexive
03:41:47 <jonathan_> I ge tit it I think
03:41:56 <jonathan_> enough to start building intuition
03:42:48 <ski> of course, `directlyLinked' would probably be an irreflexive relation, not a reflexive one
03:43:48 <ski> but if we define a `linked' relation, that allowed any (finite) length of links between cities, then presumably we'd also allow length zero. so every city is (trivially/obviously) linked to itself. so that would be a reflexive relation
03:44:27 <jonathan_> :D
03:44:47 <jonathan_> if the links are transitive 
03:44:58 <jonathan_> anyway, I'll need to brb now
03:44:58 <ski> for a reflexive relation `R', `x R x' holds for all `x'. for an irreflexive relation `R', `x R x' holds for no `x' at all. it is also possible for a relation `R' to be neither reflexive, nor irreflexive, so that `x R x' holds for some `x', and also doesn't hold for some (other) `x'
03:45:01 <jonathan_> thanks for the help
03:45:07 <ski> no problem :)
03:45:22 <jonathan_> hm, weird naming
03:45:29 <jonathan_> why not anti-reflexive
03:45:38 <jonathan_> guess you didn't have any part in that though
03:45:44 <ski> (reflexive and irreflexive are two extremes, so to speak)
03:45:47 <ski> heh, yea ..
03:45:50 <jonathan_> ye, I get it
03:49:22 <merijn> hmm, so does anyone have any nice patterns for mixing Monad in an Applicative? i.e. I'm parsing a commandline argument via optparse-applicative and need to run some validation in a Monad FooM on that, so I'd have "Parser (FooM a)" I also have another commandline argument whose validation depends on the value 'a', so "Parser (a -> FooM b)" I feel like there should be a nice way to compose these things, but 
03:49:28 <merijn> I keep getting stuck trying to formulate
03:50:46 <merijn> Naively it seems like I'd want "Compose Parser FooM", but that breaks down when mixing those two. The logic itself works out fine, since it's really just "(>>=) <$> aParser <*> bParser" but for more complex expressions it quickly becomes a horrific mess
03:52:59 <merijn> There's a nice abstraction lurking in here somewhere, but what...
03:53:10 <ski> hm, mixing, how ?
03:53:55 <N3RGY> merijn: The point of making arg parsers applicative and not monadic is specifically that you cannot do that, yes?
03:54:05 <merijn> ski: In that if you work with "Compose Parser FooM" for convenient use of 'a' you can't use "Parser (a -> FooM b)" since the compose doesn't line up
03:54:50 <merijn> N3RGY: Not quite, you can't do "Parser a -> (a -> Parser b)" because the Applicative doesn't allow the parser to depend on previous values
03:55:03 <merijn> N3RGY: But note that in my example the parser does *not* depend on 'a'
03:55:20 <N3RGY> Oh gotcha
03:56:05 <merijn> It's merely the FooM validation that depends on the 'a', which is fine as shown by "(>>=) <$> aParaser <*> bParser"
03:58:59 <ski> mm
03:59:13 <MasseR> can I get cabal new-build print out *why* it *really* wants to update a dependency?
03:59:16 <merijn> Selective seems relevant somehow too
03:59:16 <ski> i think i'd like to see some example code, i suppose
03:59:29 <merijn> MasseR: Did you run v2-update?
03:59:57 <MasseR> yeah
04:00:06 <merijn> MasseR: There's your answer.
04:00:30 <merijn> MasseR: The new solver *always* picks the latest allowed dependency, so build plans are more predictable and stable
04:00:43 <MasseR> How is that more predictable?
04:00:45 <merijn> MasseR: Unlike the original solver which would prefer things that were already installed.
04:01:08 <merijn> MasseR: Because it means you will always get the same build plan on ever machine you run it, regardless of what's currently installed
04:01:51 <merijn> MasseR: If you want to fix dependencies to the current version you want to either specify a hackage snapshot or use a freeze file
04:02:00 <MasseR> I'm not getting the same build plan on even the same machine with two consecutive runs if I do cabal v2-update in between
04:02:31 <merijn> MasseR: If you want stable buildplans across time (i.e. across multiple updates) you need to fix the Hackage snapshot or use a freeze file
04:03:38 <MasseR> now that's going to be difficult. I'm using nix for the actual dependency management, but want to use cabal new-build for compiling all the local packages (or rather ghcid -c 'cabal new-repl foo')
04:03:57 <merijn> MasseR: Nix doesn't really support v2-build atm, afaik
04:04:33 <MasseR> Yeah. Unless it accidentally happens to provide the same plan
04:04:52 <merijn> MasseR: You'd somehow need Nix to give you the hackage snapshot or freeze file for the dependencies it picked
04:06:32 <MasseR> Assuming I get the hackage snapshot, how would I provide it to cabal?
04:07:12 <merijn> MasseR: Specify index-state in a cabal.project file: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-index-state
04:07:37 <merijn> MasseR: That will act like it's using the exact Hackage snapshot from that UTC time
04:08:31 <merijn> MasseR: Alternatively, there are freeze files which specify an exact build-plan to use: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-freeze
04:08:52 <MasseR> Yeah I would ideally use a freeze-file, but I have a feeling, I might the the snapshot more easily
04:09:00 <merijn> MasseR: So you could try to generate a freeze file from the Nix configuration, dump it into cabal.project.freeze and that'd work too
04:11:02 <MasseR> Hmm... I wonder what happens if I call cabal v2-freeze within a nix derivation
04:11:08 <MasseR> it shouldn't use my local hackage snapshot
04:12:21 <MasseR> Then again, it might not have a snapshot available at all
04:13:23 <MasseR> In the index-state, the timestamp it refers to, is it some timestamp from upstream hackage, or a timestamp from my machine locally?
04:14:12 <merijn> MasseR: The hackage index has timestamps when packages are updated/added, so it basically only considers packages that were added to the index before that timestamp
04:14:38 <merijn> (At least, I'm extrapolating *how* it works from what it does... :p)
04:15:39 <MasseR> hrm. Thanks. I *think* I have enough information to think something out
04:15:55 <merijn> MasseR: So v2-update fetches everything on hackage now (so that's the only thing in your local index), running v2-update might pull in additional stuff (with later timestamps), index-state just tells it to ignore things added afterwards
04:19:54 <MasseR> You know, I'm leaning towards option 3. using 'reject-unconstrained-dependencies' (the next field in the docs you linked)
04:20:16 <MasseR> might be better in the long run to define the constraints
04:21:30 <MasseR> Ideally, that way I wouldn't need to care if new-build (or just build in v3.0) selects a different package
04:21:49 <MasseR> In practice .. there are some packages we use that are pinned to a specific hash
04:34:09 <MasseR> Or! I can take ghc-pkg list and sed it into a freeze file
04:42:22 <boxscape> If I'm understanding this correctly if you have a type family Fam then Fam(..) will export it and its equations. Does it make a difference whether or not you export its equations? (Aside from them showing up in docs)
04:43:42 <opqdonut> I think you can only make new instances of the family if it's exported as (..)
04:44:33 <boxscape> I see. What about if it's a closed family? Any difference then?
04:45:33 <sshine> hiya MasseR :)
04:46:23 <opqdonut> boxscape: no idea
04:46:29 <boxscape> hm, okay
04:46:55 <MasseR> sshine: from exercism, right?
04:46:59 <opqdonut> boxscape: did you read the manual? https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#import-and-export
04:47:10 <boxscape> that sounds like a good idea
04:48:44 <boxscape> seems like it just talks about data families but not type families
04:48:49 <boxscape> which I'm guessing means there is no difference
04:51:54 * hackage lens 4.19 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.19 (ryanglscott)
04:52:54 * hackage bytes 0.17 - Sharing code for serialization between binary and cereal  https://hackage.haskell.org/package/bytes-0.17 (ryanglscott)
04:53:55 * hackage constraints 0.12, ad 4.4 (ryanglscott): https://qbin.io/src-dh-8bvq
04:54:25 <sshine> MasseR, yup!
04:57:55 <dminuoso> merijn: I wonder whether optparse-applicative could be implemented to work with selective functors, perhaps.
04:58:02 <dminuoso> An optparse-selective, if you want.
05:00:24 * hackage taskell 1.9.2.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.9.2.0 (smallhadroncollider)
05:00:32 <dminuoso> You would have the freedom to select effects dynamically, while keeping the static analyzability for optparse to work right.
05:02:43 <dminuoso> https://github.com/haskell-works/optparse-selective seems to have been explored even :)
05:03:22 <merijn> dminuoso: There's already an issue wondering that
05:10:51 <MasseR> Yesh. Ended up doing `ghc-pkg list | sed all the things > cabal.project.freeze` in the shellHook
05:14:19 <merijn> dminuoso: The only big problem with making optparse selective is that it'd have to be renamed ;)
05:43:54 * hackage linear 1.21 - Linear Algebra  https://hackage.haskell.org/package/linear-1.21 (ryanglscott)
06:01:03 <Gurkenglas> select (and branch) has the wrong argument order :( (for making branch pointfree in the f (Either a b))
06:15:54 * hackage envy 2.1.0.0 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-2.1.0.0 (DavidJohnson)
06:41:14 <ezzieyguywuf> lol, linear 1.21. Meanwhile, I'm over here just making up my own implementation...for science :-P
06:45:24 * hackage aeson-default 0.9.0.0 - Applying default value to FromJSON instacnes' Maybe fields  https://hackage.haskell.org/package/aeson-default-0.9.0.0 (gqk007)
06:47:54 * hackage log-elasticsearch 0.10.2.0 - Structured logging solution (Elasticsearch back end)  https://hackage.haskell.org/package/log-elasticsearch-0.10.2.0 (arybczak)
07:21:51 <zincy> So the instance FromEnv PostmarkSettings  here is an orphan instance ... how can I best avoid that https://pastebin.com/vL2QNs4x
07:23:00 <dminuoso> zincy: Newtype the data type or live with the orphan instance.
07:23:12 <dminuoso> zincy: It is my opinion, that if you write executable software, orphan instances don't matter. 
07:24:26 <dminuoso> zincy: Alternatively, just don't use FromEnv.
07:29:37 <zincy> Ok so in this case the orphan instance is fine?
07:30:20 <zincy> Ill just leave it then, thanks :)
07:31:09 <dminuoso> zincy: An orphan instance is problematic because it can lead to incoherent instances. It means that two parts of some code might see different instances for the same type.
07:31:23 <dminuoso> zincy: The reason this can occur is that, while we pretend there's this open world assumption, it is not implemented that way. 
07:31:46 <inkbottle> I'm puzzled by the axioms for existence of "currying adjunction", because afaik "universal properties" are expressed with existential quantifiers http://paste.debian.net/1128997/
07:32:34 <dminuoso> zincy: If you have module MT that defines a type T, and module MC that defines a typeclass MC, but some remote module MO defines an instance for T on MC, then a third user importing from MT or MC will *not* see/know about this instance.
07:32:48 <dminuoso> zincy: So they too could define a (conflicting) instance.
07:33:32 <zincy> Thanks, that makes sense now
07:33:44 <dminuoso> Whops that was a big fuzzy, so I should correct myself
07:35:13 <dminuoso> zincy: If you play this scenario out in your head, you could have this situation where two parts of your program are using an C instance for T, but they happen to be *different* (= incoherent) instances.
07:35:30 <dminuoso> This is mainly an issue if you define an orphan instance and then provide your code as a library
07:37:13 <inkbottle> Paterson says "Indeed, it can be shown that a natural currying isomorphism exists if and only if such an arrow app exists and satisfies the axioms". But I've never seen such axioms for adjunctions
07:42:07 <zincy> Also, here would it be messy to connect to the db inside this module https://pastebin.com/vL2QNs4x
07:42:11 <boxscape> dminuoso if you try to import and use both of those instances, do you get an error about overlapping instances?
07:42:58 <ski> inkbottle : hm, i think probably you can think of it in terms of `exists app :: Œ± (Œ± Œ≥ Œ¥, Œ≥) Œ¥. ..app..'
07:43:09 <zincy> I have a DBConfig and the resulting Env should include a Connection so I need to first parse the DBConfig from my environment variables and then connect to the db
07:43:16 <zincy> two separate IO actions
07:43:37 <ski> inkbottle : "[currying] Œ± (Œ≤, Œ≥) Œ¥ ‚âÖ Œ≤ ‚Üí Œ±Œ≥Œ¥  (This is an example of what category theorists call an adjunction.)" -- this looks a bit dubious to me (that expressing an adjunction)
07:43:39 <dminuoso> boxscape: Yes.
07:44:18 <zincy> But would it be better to keep as is with Env including the DBConfig and then define a function elsewhere which does Env -> Conf
07:44:36 <boxscape> dminuoso is the only potential danger from orphan instances compile time errors then? Or are there cases where it could be more insidious?
07:44:51 <zincy> where the type Conf is the same as Env but has a Connection instead of the DBConfig as one of its fields
07:45:00 <ski> (i'd had expected to see something like "[currying] Œ± (Œ≤,Œ≥) Œ¥ ‚âÖ Œ± Œ≥ (Œ≤ ‚Üí Œ¥)", rather. perhaps abstracting over `‚Üí')
07:45:20 <dminuoso> boxscape: Think of a program A that depends on package B and C. Package B defines its own orphan instance and package C defines its own orphan instance.
07:45:38 <inkbottle> ski: reading you (with a pen)
07:45:45 <dminuoso> boxscape: Now, if you pass that type T between B and C you have a real problem because you are no longer assured that they use the same instances.
07:46:01 <dminuoso> boxscape: Your program is an incoherent mess now.
07:46:23 <dminuoso> There's probably other versions that dont require separate packages, but that's at least one way of constructing problems.
07:46:28 <boxscape> Ah, because B and C are compiled separately?
07:46:43 <dminuoso> Yes.
07:46:45 <boxscape> I see
07:47:41 <inkbottle> I have A \times B -> C \equiv A -> B^C. Is that different from what paterson says?...
07:48:48 <inkbottle> ski: paterson formulation seems ok to me
07:49:12 <ski> different, yes
07:49:23 <inkbottle> okay...
07:49:39 <dminuoso> boxscape: In practice its somewhat hard to have a conflict, but one big problem is that don't get any help from GHC telling you that you have incoherent instances.
07:49:46 <boxscape> okay
07:49:57 <dminuoso> boxscape: For cases like Ord it can have disastrous effects, obviously.
07:50:01 <boxscape> right
07:50:26 <ski> your `->' presumably corresponds to Paterson's `Œ±', no ?
07:50:34 <ski> also, did you mean `C^B' ?
07:50:35 <inkbottle> yes
07:51:17 <inkbottle> hang on bor the C^B
07:51:22 <inkbottle> for*
07:51:47 <inkbottle> yes, C^B is more like it
07:52:17 <inkbottle> meaning functions from B to C
07:52:35 <dminuoso> boxscape: My rule is, if its an application - go right ahead, they are not an issue. If its an internal library, its probably not an issue. But if you publish on hackage, orphan instances are a no-go. :)
07:52:45 <boxscape> that makes sense
07:52:52 <inkbottle> A \times B -> C \equiv A -> C^B
07:53:29 <ski> the usual adjunction, expressed as an isomorphism, characterizing exponentials, that you see is between `Hom(A * B,C)' and `Hom(A,C^B)'
07:54:26 <ski> where `*' is categorical product. if you replace it with any monoidal functor, you get into monoidal closed categories here
07:54:42 <ski> (rather than cartesian closed)
07:54:51 <inkbottle> or... `Hom(A * B,C)' and `Hom(A,B->C)'
07:55:15 <ski> if `B -> C' denotes the exponential object, sure
07:55:19 <inkbottle> and that looks like Œ± (Œ≤, Œ≥) Œ¥ ‚âÖ Œ≤ ‚Üí Œ±Œ≥Œ¥ ?
07:55:27 <ski> no
07:55:52 <inkbottle> isn't that the same order of letters?
07:56:10 <mniip> The definition of the isomorphism depends on the category
07:56:51 <mniip> Also you cant really use lambda calculus to defone it because it is used to define lambda calculus
07:57:35 <inkbottle> ski: if you remove the \alpha, the sequences seems identical to me?
07:58:05 <ski> if you replace ‚åúHom(X,Y)‚åù with ‚åúŒ± X Y‚åù, ‚åúA * B‚åù with ‚åú(Œ≤,Œ≥)‚åù, and ‚åúB -> C‚åù with ‚åúŒ≥ ‚Üí Œ¥‚åù, you get ‚åúŒ± (Œ≤,Œ≥) Œ¥ ‚âÖ Œ± Œ≤ (Œ≥ ‚Üí Œ¥)‚åù, not ‚åúŒ± (Œ≤,Œ≥) Œ¥ ‚âÖ Œ≤ ‚Üí Œ± Œ≥ Œ¥‚åù
07:58:14 <inkbottle> mniip: it's from pat03 http://paste.debian.net/1128997/
07:59:21 <mniip> Theres a paper on free cartesian closed categories
07:59:42 <inkbottle> ski: I can see your point...
07:59:50 <mniip> I found a satisfactory (algebraic) definition of a ccc there
08:00:05 <inkbottle> really?
08:00:27 <inkbottle> where is "there"
08:00:31 <inkbottle> ?
08:03:00 <mniip> "Embedding of a free cartesian-closed category into the category of sets"
08:03:31 <maralorn[m]> dminuoso: Would the example with the packages A, B and C that you describe above even be a problem? I mean if code from module B where to use the instance from module B and code from module C the instance from module C, wouldn‚Äòt that lead to the expected Code behavior?
08:04:06 <maralorn[m]> dminuoso: Or does the instance used depend on the module the constructor is executed in?
08:04:28 <inkbottle> ski: I agree with what you said, I sure had overlooked that point initially, but your equations are mirroring the diagram I've drawn
08:04:35 <merijn> maralorn[m]: It's not specified
08:04:45 <merijn> maralorn[m]: So the behaviour is fundamentally unpredictable
08:05:06 <merijn> maralorn[m]: The problems are also not directly obvious
08:06:24 <merijn> maralorn[m]: Consider package A creating "Set Foo" using some Ord instance for Foo. That's returned to your program, which then calls code from package B on "Set Foo", but package B has a different Ord instance in scope for Foo. You are now, well and truly hosed.
08:06:41 <ski> inkbottle : part of the point of the categorical language is to distinguish between exponential objects and homs. CT is in some sense a language of first-order functions
08:06:56 <inkbottle> mniip: thanks, I'll give it a look (https://www.sciencedirect.com/science/article/pii/S0022404996001375)
08:07:46 <zincy> Is the comment on the final function correct? Or am I lying to myself https://pastebin.com/FYfTDm4R
08:08:07 <zincy> I guess a runtime error is a good thing if you actually dont want the program to continue
08:08:47 <inkbottle> ski: I completely agree about the "first order function" and the "distinguish between exponential objects and homs" (nice)
08:08:57 <merijn> zincy: I would argue that even if you do want a runtime error (which seems reasonable) you only want those that you explicitly create/throw yourself
08:09:56 <zincy> merijn: Is that too implicit a throwing ? :)
08:10:08 <merijn> zincy: If you wrap that bit with ExceptT then you keep the same clean logic and throw some nicely formatted error message
08:10:36 <maralorn[m]> merijn: How bad does it get? Could that undefined behavior even lead to a compiler crash or something like that?
08:10:50 <inkbottle> ski: you "fold" the hom into exponential... keeping things first order
08:11:04 <merijn> maralorn[m]: Your program state is now corrupted. How bad that is depends on how bad it is that your program doesn't do what was specified
08:11:47 <inkbottle> ski: and in paterson, hom and exponential where inverted...
08:12:05 <zincy> Here is what I see on failure: server-exe: user error (Pattern match failure in do expression at src/Env.hs:71:3-21)
08:12:11 <zincy> Yeah not good :D
08:12:20 <merijn> zincy: Right, that's generally not what you want users to see :p
08:12:26 <zincy> hehe
08:12:40 <zincy> I dont know why I thought it would give a good message
08:13:06 <maralorn[m]> merijn: But I always get a compiling program?
08:13:06 <zincy> I am not sure about how do compute the chain of eithers best with nice err msgs
08:13:38 <maralorn[m]> Are there at least ghc developers who could tell me the rule when which instance is used?
08:13:39 <merijn> maralorn[m]: Yes, which will then corrupt/crash/go wrong at runtime
08:14:01 <merijn> maralorn[m]: Possibly, but the simpler solution is "avoid orphans, always"
08:14:07 <inkbottle> ski: what "editor" did you use to type all those symbols so quickly and accurately?
08:14:19 <maralorn[m]> merijn: I do. I am just curious.
08:14:31 <dminuoso> maralorn[m]: Consider you stuff a balanced tree into package B and get it back and you stuff it into C.
08:14:34 <merijn> zincy: Something like: https://paste.debian.net/1129002/
08:15:01 <dminuoso> maralorn[m]: By *mere* instance decoherence (for your Ord) you are no longer guaranteed that the tree is still balanced.
08:15:24 <merijn> zincy: Then you just need "Either Error Env -> IO Env" (something like "either throwIO return", that throws a proper error or returns Env)
08:15:28 <dminuoso> maralorn[m]: Depending the API of that balanced tree, it could have any number of disastreous effects if everything assumes that all API functions ensure the tree is balanced.
08:15:51 <inkbottle> ski: it took me ages to manage inferior result with emacs
08:15:57 <merijn> maralorn[m]: The problem is that GHC might not even realise there are multiple instances in the program, so there isn't always a deterministic choice by the compiler
08:16:48 <maralorn[m]> dminuoso: Oh, that also works for Ord and Map, right? I could have different Ord instances, which leads to an unordered Map, which could e.g. mean I insert a value and cannot retrieve it after that.
08:16:59 <merijn> maralorn[m]: Yes
08:17:11 <dminuoso> merijn: Sure. Map is just a size balanced tree internally. :)
08:17:17 <maralorn[m]> Still curious when/where and how the lookup table get‚Äôs constructed.
08:18:00 <dminuoso> maralorn[m]: So by swapping out instances transparently all preconditions get invalidated. You'd have to look at the implementation very deeply to know what even happens. Perhaps Data.Map.* functions will just give you plain "wrong/buggy" results.
08:18:38 <ski> inkbottle : "you \"fold\" the hom into exponential" -- hm, i suppose i'd say it the opposite way. perhaps i misunderstood what you meant, though
08:19:25 <ski> inkbottle : .. copy&paste ?
08:19:37 * ski glances sideways
08:19:41 <dminuoso> maralorn[m]: Consider an extreme example, where the conflicting instance considers *all* things to be equal to another. If both B and C use Map functions, and assuming they dont error out based on internal checks that the tree is no longer balanced, you'd instantly collapse your entire map into a single key. 
08:20:08 <maralorn[m]> Like: Is the instance determined at compile time or at run time? Does it depend on if the instance got inlined or not?
08:20:12 <Cale> dminuoso, maralorn[m] -- if there are conflicting orphans, you won't get to the point of being able to run the program though
08:20:46 <Cale> (though maybe I'm missing some subtlety of what you're discussing)
08:20:49 <dminuoso> Cale: Huh? If the orphans are in remote packages sure you would.
08:21:24 <dminuoso> Cale: The assumption is that you have a program A linked to separately compiled packages B and C, both defining an Ord orphan instance for some type T.
08:22:08 <inkbottle> ski: B^A folded version of A->B; A->B is the "working" version, and B^A is the stored version
08:22:22 <zincy> merijn: thanks
08:22:25 <inkbottle> you say differently?
08:22:45 <Cale> Right, so you import modules from both B and C, and as soon as you bring both those orphan instances into scope, neither one is usable.
08:22:59 <dminuoso> Cale: You are not the one using them. B and C are.
08:23:29 <Cale> How does the result of the program depend on it then?
08:23:46 <Cale> I'm thinking of a scenario e.g. like trying to use a Set from B in some function from C
08:24:55 <ski> inkbottle : i'd normally use `B^A' and `A -> B' interchangably (both for the exponential object). rather using `Hom(A,B)',`Mor(A,B)',`A >---> B' for the hom
08:25:59 <inkbottle> ski: you compose f and g from a->b and b->c; but you need "eval" to use a member of c^b (to "unfold")
08:26:12 <inkbottle> ski: okay
08:26:32 <ski> inkbottle : replacing your `->' by `>--->', i suppose perhaps "A>--->B is the \"working\" version, and B^A is the stored version" makes some sense, since one could think of points in `B^A' as "names" of morphisms in `A >---> B'
08:27:03 <ski> inkbottle : still not sure about "B^A folded version of A>--->B", though
08:27:03 <inkbottle> I agree
08:28:59 <ski> inkbottle : "you \"fold\" the hom into exponential... keeping things first order" -- when reading that, i was rather there thinking of going from right side to left side in ‚åúŒ± (Œ≤,Œ≥) Œ¥ ‚âÖ Œ± Œ≤ (Œ≥ ‚Üí Œ¥)‚åù as "folding the exponential into the hom", which seemed to be the opposite of what you were saying, hence i was confused by it
08:30:01 <ski> (going from left to right, it would rather be "separating / unfolding the exponential out of the hom" (you keep the hom around). (not "folding hom into exponential", from the way i was interpreting it))
08:30:12 <inkbottle> well, "folded" as in "name of", there is an isomorphism provided by the adjunction, but really things stay "first order"
08:30:13 <ski> but now i suppose you had something else in mind with "fold" ?
08:31:19 <ski> mm
08:32:22 <dminuoso> Cale: Let me construct a proper example.
08:33:55 <Cale> dminuoso: Ah, it's okay, I see what you mean, we can make an entirely monomorphic value of type Set T for example
08:35:00 <Cale> and then with different instances in scope, write a function Set T -> ...
08:35:02 <ski> inkbottle : from an internal language in a topos perspective, morphisms correspond to expressions (with possibly free variables), while points in an exponential object correspond to expressions such as lambda expressions
08:35:33 <inkbottle> agree
08:35:35 <Cale> and then import both and apply the function, and there's no explicit conflict, because we're not using the instances directly at all
08:35:57 <topos> cats can have a little salami
08:36:18 <topos> that's my perspective
08:36:39 <Taneb> topos: closed cartesian salami?
08:37:02 <topos> i make a good product
08:38:19 <ski> can premice be captured nicely by cats ?
08:38:49 <dminuoso> Cale: Right. If B and C use it internally because they themselves are calling into Data.Map/Set respectively, they each select their local instance. But they could hand *you* the container back.
08:38:49 <dminuoso> Cale: So if you pass that map forth and back between B and C, you transitively end up using incoherent instances
08:38:53 <inkbottle> ski: where did you get the '>-->' symbol from?
08:39:42 <ski> long arrow is often used as morphism arrow, in books, papers
08:40:01 <Cale> ski: haha, nice question
08:40:42 <inkbottle> ski: of course, long arrows
08:43:34 <hseg> So I've decided to refactor my code to avoid using 'algebra's numeric hierarchy (am having too many troubles with it), but want to keep the old approach around for another try in the future
08:44:01 <hseg> Is there a way I can e.g. use backpack to be able to switch between Prelude and algebra's numeric hierarchies?
08:45:12 <hseg> (idea would be that the signature I'd depend on would be some constraint Ring that supplies certain functions, then have both Prelude and algebra implement that signature)
08:46:00 <ski> inkbottle : people often use `--->' (‚åú‚ü∂‚åù, or ‚åú‚Üí‚åù for short) for arbitrary morphism, `--->>' (‚åú‚Ü†‚åù for short) for epimorphism, `>--->'/`c--->' (‚åú‚Ü£‚åù/‚åú‚Ü™‚åù for short) for monomorphism (the latter of those being an inclusion / subset / (converse) containment sign ‚åú‚äÇ‚åù, at the end of the arrow)
08:46:29 <ski> inkbottle : i tend to use `>--->' for morphism arrow, `>--->>' for epi, `>>--->' for mono
08:47:17 <Cale> ski: More seriously, I actually sometimes wonder just how much of that sort of model-theoretical set theory will/would translate nicely into something like HoTT. Obviously you could still talk about models of ZF with HoTT, but it's kind of hard to say if that really captures the spirit of that branch of research...
08:47:46 <hseg> Cale: Oh?
08:48:10 <Cale> You'd presumably want to end up talking about cardinals in HoTT somehow.
08:48:51 <hseg> Can't you define a set of intros/elim rules for them?
08:49:00 <ski> different models would be the objects in some category ?
08:49:13 <ski> hm, HoTT ..
08:49:57 <ski> hseg : intros and elims for being a hereditary/ZF set ?
08:50:26 <hseg> Yeah... though that probably leads you to ETCS + some axioms
08:50:35 <Cale> hseg: There's an approach to defining cardinals in The Book, but once you get into translating deeper questions about them from classical set theory, things get a bit weird to think about.
08:51:09 <hseg> hrm. need to read the book someday,
08:52:53 <Cale> You can define Card as the 0-truncation of the type Set, which is rather nice.
08:54:12 <hseg> Right
08:56:32 <dminuoso> Cale, maralorn[m]: Here is a simple example of how incoherent instances can exist https://gitlab.com/dminuoso/incoherent-orphan-instances
08:58:44 <dminuoso> In more elaborate cases stuff like this can outright crash libraries, provoking error calls or violating internal invariants...
09:05:53 <mniip> I just realised something
09:06:06 <mniip> Err, wrong ch
09:09:01 <tdammers> yeah, we don't do epiphanies here
09:10:00 <heatsink> only anaphanies and cataphanies
09:11:25 <Cale> dminuoso: Yeah, orphans are a problem in libraries, but rarely an issue a final executable so long as you pick one instance. You don't technically need separate packages to make problems occur, but you'd pretty much have to be trying to make something go wrong to have a problem like that happen in that case.
09:13:50 <dminuoso> tdammers: If we cant have ephiphanies, can we have monophanies?
09:13:54 * hackage yaml-light-lens 0.3.3.6 - Lens interface to yaml-light.  https://hackage.haskell.org/package/yaml-light-lens-0.3.3.6 (AnthonyCowley)
09:18:54 * hackage brok 0.2.0.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.2.0.0 (smallhadroncollider)
10:04:17 <ezzieyguywuf> how do I take the square root of a Rational?
10:04:27 <ezzieyguywuf> from what I can tell, `sqrt` is intended to be used with `Float`
10:04:58 <ezzieyguywuf> or really, I'd rather find `sqrt (Fractional a) => a -> a`
10:13:50 <ski> ezzieyguywuf : how would it work for `a = Rational' ?
10:22:13 <reactormonk> Is there a startsWith for Text somewhere?
10:23:21 <dmj`> reactormonk: isPrefixOf
10:25:31 <solonarv> ezzieyguywuf: should sqrt 2 be 3%2, or 7%5, or 17%12, or 41%29, or...? (these are successively better approximations)
10:25:44 <Philonous> ezzieyguywuf, Since square roots of rationals aren't necessarily rational, sqrt :: Rational -> Rational is impossible. Instead, you have to convert to your target repesentation first and then take the square root 
10:26:23 <solonarv> well, and also: Double can't generally exactly represent the square root either
10:26:38 <solonarv> but Double already has a built-in maximum precision
10:26:48 <solonarv> which makes for a sensible cutoff point
10:27:02 <solonarv> Rational has no such thing: when you have a Rational, it is unboundedn-precision
10:27:14 <e> that reasoning feels kind of meh
10:27:19 <Cale> Yeah, you expect Double to approximate pretty much everything, but for Rational to be exact.
10:27:24 <Philonous> I think the usual interpretation of floating point is finite-percision real, not rational
10:27:34 <e> i'm happier thinking that all doubles are inexact, whereas rationals are presumed to be exact
10:27:46 <solonarv> so if you were to take its square root it would not be clear at all where to stop
10:27:51 <solonarv> e: exactly!
10:48:04 <ovitus> how do you roll back a package with Cabal?
10:48:09 <dminuoso> Cale: Oh yeah, absolutely. Hence my original opinion "orphans are fine in executables, probably fine in internal libraries and not a good idea in public libraries"
10:48:28 <dminuoso> ovitus: By using v2-* mechanisms.
10:48:45 <hseg> dminuoso: don't see what you're replying to?
10:48:45 <phadej>  they are not fine in internal libraries
10:48:49 <phadej> they will leak from there
10:49:02 <phadej> if there's public library using an internal one
10:49:19 <dminuoso> phadej: Sorry perhaps "internal" was the wrong term. I meant internal in the sense of "private".
10:49:27 <dminuoso> Such as company internal
10:49:51 <dminuoso> Didn't realize it had a meaning already in cabal
10:50:12 <ovitus> @dminuoso can you elaborate?
10:50:12 <lambdabot> Unknown command, try @list
10:50:20 <ovitus> I have a package installed, can I uninstall and install an older version?
10:50:32 <dminuoso> ovitus: With v2- you don't need to worry about that.
10:50:45 <dminuoso> ovitus: You just specify the versions your package needs in your cabal file, and cabal will take care of the rest.
10:51:20 <ovitus> basically I have this:
10:51:21 <ovitus> * tidal    Synopsis: Pattern language for improvised music    Default available version: 1.4.7
10:51:42 <ovitus>  Installed versions: 1.4.7
10:52:16 <Cale> dminuoso: It's common to have modules named like Foo.Bar.Internal for people who want to access the internal implementation of otherwise-abstract data structures and which are typically regarded as more volatile in terms of interface.
10:53:07 <dminuoso> Cale: Internal modules is yet another topic. I was talking about packages you don't intend on ever putting on hackage.
10:53:14 <Cale> yeah
10:53:49 * dminuoso just defined ToJSON/Show instances for `IORef a` because.. convenience
10:54:30 <solonarv> ...but what do they do? unsafePerformIO?
10:55:29 <dminuoso> solonarv: Heh, no. If I keep doing this, Ill probably do just that. But then again I was punished hard by unsafePerformIO the other day.
10:55:32 <Cale> serialise pointers for transmission over the wire, to make exploits easier to write
10:56:01 <solonarv> dminuoso: so what do they do instead? just a blank "<IORef>"?
10:56:05 <dminuoso> solonarv: Right.
10:56:26 <dminuoso> This is just internal debug dump modes, I dont mind.
10:56:55 <solonarv> oh I don't have a problem with that sort of thing
10:57:09 <maerwald> I want a FromJSON :(
10:57:23 <dminuoso> maerwald: In combination with Cale's idea?
10:57:31 <ezzieyguywuf> hm, I get it, the square root of a given number may have an infinite number of signifigant figures, and as such taking the square root of an exact representation doesn't make sense
10:57:51 <maerwald> dminuoso: right, and send back anything that is in memory :D
10:57:54 <ezzieyguywuf> it is an inherently "lossy" computation - I guess I'd be better off either finding a way to work around needing to take the sqrt, or allowing my user to specify some allowable tolerance
10:58:21 <solonarv> the most practical answer is to simply convert to Double first
10:58:30 <Cale> ezzieyguywuf: Yeah, square roots of rational numbers often aren't rational (unless both the numerator and denominator are squares)
10:58:52 <[exa]> ezzieyguywuf: it would make sense if the exact representation would be e.g. a list of digits that can be generated on demand
10:59:07 <[exa]> which is not the case ofc.
10:59:19 <solonarv> continued fractions :P
10:59:43 <ezzieyguywuf> hm, represent a Float as a "head" and "tail", i.e. digits before/after the decimal
10:59:56 <solonarv> how does that help?
11:00:01 <ezzieyguywuf> then the trailing digits can be as you said, an infinite list that is generated on-demand to the desired tolerance
11:00:07 <solonarv> ah
11:00:20 <solonarv> you don't really need to separate into before/after decimal, then
11:00:35 <ezzieyguywuf> hm, I guess you're right, just "digits"
11:00:41 <ezzieyguywuf> any one of which can be the decimal
11:01:04 <Cale> > decodeFloat (pi :: Double)
11:01:04 <solonarv> no, now you can suddenly represent weird stuff like 0.123.6.24 which surely isn't right
11:01:06 <lambdabot>  (7074237752028440,-51)
11:01:28 <ezzieyguywuf> keyword "one" in "any one"
11:01:32 <solonarv> ah
11:01:47 <Cale> > 7074237752028440 * 2^^(-51)
11:01:50 <lambdabot>  3.141592653589793
11:01:55 <solonarv> just a list of digits and an int(eger) that says where the decimal point is
11:02:21 <Cale> That's basically what a float is, except usually in binary
11:02:42 <solonarv> yup
11:02:45 <ezzieyguywuf> interesting conversation. I got around the need for sqrt for now, so :)
11:02:46 <ezzieyguywuf> lol
11:03:46 <ezzieyguywuf> c++ has the GMP library that does something like this
11:03:48 <ezzieyguywuf> btw
11:04:00 <ezzieyguywuf> https://en.wikipedia.org/wiki/GNU_Multiple_Precision_Arithmetic_Library
11:04:16 <solonarv> GHC's standard library actually uses GMP by default
11:04:27 <solonarv> for Integer, to be precise
11:04:31 <ezzieyguywuf> hm, or maybe I'm thinking of https://en.wikipedia.org/wiki/GNU_MPFR
11:04:34 <solonarv> (and more recently Natural)
11:04:56 <ezzieyguywuf> solonarv: didn't know that. But it does not do it for Float or Double though?
11:05:19 <solonarv> ezzieyguywuf: Float and Double are just the usual machine 32/64-bit floats
11:05:26 <solonarv> why would you need GMP for that>
11:05:27 <solonarv> ?
11:05:59 <Cale> Well, it might be nice to have a multiprecision floating point representation available
11:06:37 <ezzieyguywuf> solonarv: I think I was talking about MPFR. I seem to recall that one of those two allowed "exact" floating point representation
11:06:39 <Cale> https://hackage.haskell.org/package/hmpfr
11:07:22 <ezzieyguywuf> at the end of the day, I doubt I'll require that level of precision. More likely is that I need to re-think my approach
11:07:32 <jle`> ezzieyguywuf: if all you care about are exact square roots of rational numbers, then you can maybe make a numeric type that is an extension of Rational to include only square roots
11:09:12 <solonarv> well, and square roots of square roots, and ...
11:09:38 <jle`> right that's why i specified if they only care about exact square roots of rational numbers heh
11:09:52 * solonarv is taking an abstract algebra course this semester
11:09:59 <solonarv> it's exciting!
11:10:13 <jle`> :D
11:10:19 <ezzieyguywuf> hah nice.
11:10:29 <ezzieyguywuf> I got so confused by the time I got to the end of calc III
11:10:36 <ezzieyguywuf> diff was just a blur
11:10:38 <ezzieyguywuf> :-P
11:10:46 <ezzieyguywuf> er, diff eq, i.e. differential equations
11:11:19 <ezzieyguywuf> I took an engineering curriculum though, so I was much more interested in all the "practical" engineery stuff than the weird math stuff
11:12:06 <ezzieyguywuf> Cale: I think hmpfr would be what I'd use if I ended up going down that path
11:12:14 <hseg> solonarv: enjoy!
11:12:22 <jle`> basically i think you can do this by making data ExtendedQ = EQ { q0 :: Rational, q1 :: Map Rational Rational }
11:12:39 <ezzieyguywuf> I guess there's no getting around the question of precision/tolerance when dealing with geometry, specifically whether or not two geometric entities intersect
11:12:53 <jle`> sqrtRational q = EQ 0 (M.singleton q 1)
11:13:07 <jle`> which would be Rational -> ExtendedQ
11:13:08 <hseg> ezzieyguywuf: yeah, had a similar issue where I was trying to get Complex numbers to work, only to realize I was only using expressions of form (rational/i)^2 ...
11:13:11 <jle`> EQ is an unfortunate constructor name
11:13:34 <jle`> that data type should contain all of the exact square roots of rational numbers
11:13:44 <ezzieyguywuf> but, you know, in real life, we can determine _precicely_ whether two things intersect. You set the equations equal to each other or something
11:13:58 <ezzieyguywuf> therefore, there _must_ be a way to do so programatically
11:14:01 <hseg> jle`: you'd need to deal with the fact that sqrt(2)sqrt(3)=sqrt(6) though
11:14:16 <hseg> ezzieyguywuf: Depends on your surfaces, but yes
11:14:17 <jle`> there is some redundancy with normalization
11:14:18 <karetsu> but computers don't count the way that we do
11:14:19 <jle`> hseg: yeah, you can do that
11:15:00 <jle`> or well, there would be some redundancy
11:15:08 <ezzieyguywuf> hseg: if you have an exact representation of the surface or curve, then it shouldn't matter right? i.e. a straight line and a plane. or a nurbs surface
11:15:26 <jle`> sqrt 2 * sqrt 3 would naively have a different representation than sqrt 6 but it would represent the same result when normalized
11:15:37 <jle`> multiplication involves foiling out all the terms
11:15:40 <hseg> Right... except your points of intersection might be unrepresentable
11:15:49 <ezzieyguywuf> hseg: how do you mean
11:16:16 <jle`> er actually you need an extra map or two
11:16:26 <hseg> ezzieyguywuf: for algebraic surfaces, you only need to be able to extract large enough roots
11:16:36 <jle`> or infinite. darn
11:17:41 <hseg> ezzieyguywuf: e.g. x^2-y=0 intersects y-2=0 at (+-sqrt 2,2)
11:18:22 <hseg> replacing this with more complex stuff, you can get into serious trouble - e.g. x^k-y /\ y-f(x)
11:18:39 <ezzieyguywuf> If anyone is up for it, since I'm so new to Haskell I'd be really interested to hear feedback on this small library I'm developing: in general, I have no sense for if I'm doing things "the functional way" or not, coming from a OOP background. Further, I don't know if I'm missing out on opportunities to simplify my code due to unfamiliarity with Haskell. any feedback is welcome! 
11:18:45 <ezzieyguywuf> https://gitlab.com/ezzieyguywuf/mycad/tree/haskell/src_haskell/HaskellCAD
11:19:10 <hseg> these types of caculations are in the realm of numeric algebraic geometry, and are (for the moment) above my paygrade
11:19:38 <hseg> jle`: Well, your terms will always have finite support, so multiplication will always terminate
11:20:04 <ezzieyguywuf> hseg: `y-2=0` is not a point. Rather, the question would be "does Point 2 2 intersect the parabola described?" the answer would be yes
11:20:24 <hseg> ezzieyguywuf: I'm intersecting a line and a parabola
11:20:32 <ezzieyguywuf> doh!
11:20:35 <Cale> ezzieyguywuf: When you get to the point of caring about performance, you might find you want to replace some of these lists with something else.
11:20:44 <ezzieyguywuf> in which case you'd want to know about both intersection points
11:20:51 <Cale> xs !! n necessarily takes O(n) steps
11:21:01 <hseg> the coordinates of the resulting points of intersection might be unrepresentable by your numeric datatype
11:21:12 <ezzieyguywuf> Cale: thanks for the tip! I'll definitely keep that in mind when I get around to "caring about performance" (as I eventually will)
11:21:34 <hseg> (you'd need to guarantee closure under arbitrary root extraction, to begin with)
11:21:49 <hseg> (and in general, the solution of any possible polynomial in those coefficients)
11:22:01 <ezzieyguywuf> hah, now this stuff sounds above my paygrade
11:22:08 <hseg> (aka you need the numeric type to be "algebraically closed")
11:22:14 <Cale> (also, it's just sort of a dangerous operation in general, since your program dies uncontrollably if the index is out of bounds, but that can be remedied as well)
11:22:31 <ezzieyguywuf> Cale: I thought it was iffy to use `!!` at all
11:22:47 <hseg> Right, which is why I'm saying A) you'd need roots to begin with and B) this gets expensive *fast* if you insist on exact arithmetic
11:23:16 <hseg> (in general, working exactly involves juggling polynomials, for which you'll want to look into Grobner base algorithms)
11:23:48 <hseg> jle`: you're guaranteed termination since you're dealing with functions of finite support
11:24:02 <hseg> jle`: but yes, normalization is hard
11:24:16 <ezzieyguywuf> Cale: ah, `addClosedEdge` is a very naive implementation indeed, and is definitely going to evolve with time
11:24:35 <jle`> maybe not too bad because you can check for 'perfect' squares and normalize w.r.t that?
11:24:57 <jle`> but also you can just not care since the way to go 'out' of it, like ExtendedQ -> Double, would be self-normalizing
11:25:04 <hseg> Right
11:25:12 <jle`> but you do have to care if you want to implement (==)
11:25:25 <hseg> But computation with unnormalized terms can get expensive
11:25:39 <hseg> OTOH, you might deliberately want to unnormalize things
11:26:01 <hseg> e.g. replace asqrt2 + bsqrt3 by (3a+2b)sqrt6
11:26:42 <hseg> ... indeed, you should be able to get some sort of a normalization analogous to that of fractions, but just wrt roots
11:28:12 <hseg> (this only works for square roots though -- with cube roots you'd need to juggle the real and complex parts, afaict)
11:28:48 <solonarv> it's probably best to rip off the band-aid and adjoin i as well right away, tbh
11:29:07 <solonarv> that way you don't have to do extra work to keep out negative arguments to sqrt
11:29:26 <kuribas> ezzieyguywuf: well, if you use !! to replace array indexing in a imperative language, you are definitely not using functional idioms.
11:30:15 <solonarv> that gets you Q[X] / {X^2-q | q in Q}
11:30:16 <hseg> Well, actually negative sqrts work ok in this construction -- you basically have the normalization rule asqrt(p)+bsqrt(q)=(aq+bp)sqrt(pq)
11:30:31 <ezzieyguywuf> kuribas: yes, this is a good point. I've been brainstorming how I might change the algorithms in `Topology` to get away from these `!!` that I'm using
11:30:50 <hseg> the quadratic closure (basically your Q[X] up there) is easy-ish to construct and work with
11:31:14 <ezzieyguywuf> It may come down to rethinking the whole approach, and perhaps educating myself a bit on topology and set theory in general
11:31:15 <hseg> because you can basically ignore the ambiguity of square roots
11:31:31 <solonarv> yeah, the quadratic closure is what I meant - I just felt like giving a more explicit construction of it
11:31:55 <hseg> but what about eg cube roots? now you need to distinguish b/w cube roots of unity
11:32:14 <hseg> hrm. actually it isn't that bad
11:32:21 <solonarv> those are already in this field, funnily enough
11:32:26 <hseg> right
11:32:37 <hseg> (1+-sqrt(3))/2
11:32:41 <kuribas> ezzieyguywuf: minor nitpick: I would write isSpheroid (Spheroid _ ) = True; isSpheroid _ = False
11:32:48 <hseg> iirc
11:33:10 <solonarv> well, you missed an i, but yes
11:33:16 <hseg> right
11:34:27 <kuribas> ezzieyguywuf: you could use vector, it has more efficient indexing: https://hackage.haskell.org/package/vector
11:34:43 <dminuoso> +1 on vector.
11:34:49 <hseg> actually, on further thought you can do the same trick for the radical closure of Q (i.e. Q(q^{-k}) | q in Q, k in Z)
11:35:03 <solonarv> a representation might be something like: newtype QuadClosureQ = QCQ { q1 :: Rational, qn :: Map Natural Rational }
11:35:31 <solonarv> (the q1 field is actually not necessary but should make working with purely rational numbers easier)
11:35:34 <ezzieyguywuf> kuribas: regarding the nitpick, you mean using your version rather than the `case` statement?
11:35:40 <kuribas> ezzieyguywuf: yes
11:35:43 <solonarv> er, wait, s/Rational/(Complex Rational)/
11:36:04 <ezzieyguywuf> kuribas: also, I recently (i.e. a few hours ago) came across vector and started looking into it. I'll definitely spend more time looking at that.
11:36:23 <solonarv> normalizing to a sum of (a+bi)(sqrt n) terms, basically
11:36:48 <hseg> ... that should be q^{1/k}, obvs
11:37:39 <solonarv> yeah, but I think there is no equally nice way to represent that
11:37:40 <solonarv> hmm...
11:38:02 <solonarv> well, you end up having to do a bunch of normalization
11:38:30 <hseg> yeah. idea is the same as naive rationals
11:38:45 <hseg> make it all have a common factor, and work there
11:39:27 <hseg> ofc, you'll want some normalization steps that take (mn^k)^{1/k} -> nm^{1/k}, but that's another story
11:41:04 <solonarv> actually I just realized mine needs normalization as well, since I am just adjoining all square roots of integers as distinct elements
11:41:10 <solonarv> even though sqrt 4 = 2, for example
11:41:25 <hseg> you'd also need to have some implementation of cyclotomic rationals in mine
11:41:37 <hseg> so, doable, but one hell of an effort
11:42:10 <hseg> and probably best avoided if possible (e.g. by working with the polynomials these things are roots of instead)
11:46:28 <solonarv> that still sounds kind of annoying, tbh
11:46:57 <solonarv> especially since roots are generally not unique, and on top of that quotienting by an infinite family of polynomials sounds hard
11:47:22 <hseg> Yeah, but is better-behaved -- iiuc that's what grobner base algorithms are for
11:47:47 <hseg> and besides, you can get away with working of the splitting field of whatever polynomials you're dealing with
11:47:54 * hackage fast-digits 0.3.0.0 - Integer-to-digits conversion.  https://hackage.haskell.org/package/fast-digits-0.3.0.0 (Bodigrim)
11:47:58 <hseg> so you're not quotienting by an infinite family, usually
11:48:30 <remexre> anyone familiar with GHC.TypeLits.Nat? I'm trying to get something like https://wiki.haskell.org/GHC.Generics#A_generic_function working, with a length given by Nat
11:48:57 <remexre> so I'm using GHC.TypeLits.Extra.Max in the :+: case
11:49:03 <hseg> remexre: a little, what's the question?
11:49:26 <remexre> but GHC can't figure out how to solve (1 + Max lhsLen rhsLen) ~ (1 + n1 + lhsLen)
11:49:32 <remexre> where n1 should be instantiable to any Nat
11:49:44 <remexre> and KnownNat lhsLen, KnownNat rhsLen are in scope
11:49:55 <hseg> :-) welcome to my hell of the last month
11:50:08 <remexre> I'm using the GHC.TypeLits.Extra.Solver and GHC.TypeLits.KnownNat.Solver plugins
11:50:17 <remexre> oof
11:51:04 <hseg> you're going to either want to prove the equation holds to GHC, "prove" it holds (using unsafeCoerce), or find a good enough solver to prove it works
11:51:28 <remexre> do you know one of the latter, or a way to do the former?
11:52:00 <hseg> went with the middle option for a lack of time
11:52:03 <Cale> remexre: That equality doesn't even seem true, unless you only need that there exists n1?
11:52:06 <remexre> rip
11:52:15 <remexre> Cale: I need that it exists, and its value
11:52:25 <Cale> ah, okay
11:52:34 <hseg> for the former, you want https://hackage.haskell.org/package/base/docs/Data-Type-Equality.html and friends
11:52:49 <Cale> Sounds like exactly the kind of thing Haskell's type system isn't good enough at to attempt
11:53:06 <remexre> I need the value to know how many padding 0 bits to insert, so I need both, sadly
11:53:13 <hseg> so basically, you want ghc to figure out that Max l r ~ (k + l) for some k?
11:53:30 <Cale> It's probably possible, but I'd probably try to move more information to runtime vs. compile time
11:54:06 <remexre> hseg: yeah
11:54:20 <remexre> Cale: yeah... don't love needing to do that though
11:54:41 <solonarv> perhaps directly using (Max l r - l) would work
11:54:48 <solonarv> worth a shot at least
11:56:16 <hseg> you'll probably want some term :: forall k. Either (l :~: Max l r, r :~: k+l) (r :~: Max l r, l :~: k+r) 
11:56:18 <remexre> solonarv: oh sweet, that works
11:56:28 <solonarv> yay!
11:56:34 <remexre> though I need to reformat my code severly to make it not be a 200char line lol
11:56:38 <hseg> ignore what I said, simple solutions are better!
11:56:57 <hseg> heh, still annoyed brittany doesn't format instance decls
11:57:33 <remexre> oof, vim thought that the - being the leading char meant I was doing a bulleted list or smth
11:57:40 <remexre> and inserted an extra - when I newline'd
11:57:51 <solonarv> :(
11:57:52 <hseg> heh. check :set ft
11:58:15 <remexre> haskell
11:58:23 <hseg> hrm
11:58:25 <hseg> odd
11:58:47 <hseg> vim's syntax file for haskell is ok
11:58:49 <remexre> yeah... my vimrc is mega-cursed tho
11:58:54 <hseg> ah
11:59:07 <remexre> so it's totally plausible to me it thinks it's a dual-syntax haskell+markdown file or smth
11:59:14 <hseg> :(
11:59:15 <remexre> because of some lhs thing I tried months ago
11:59:21 <remexre> or something equally cursed
12:00:16 <hseg> brb, dinner
12:01:13 <[exa]> remexre: {- comment may have - as a line continuation perhaps?  (like in C with the vertical line of *'s)
12:01:26 <remexre> oh, plausible, yeah
12:02:21 <Cale> If you feel like confusing the shit out of people's syntax highlighters, try naming an infix operator -->
12:03:19 <remexre> https://silo.remexre.xyz/screenshots/cd8c692c0a227c357c62bc352727a2699a140fd1.png
12:03:21 <remexre> unfortunate
12:03:50 <Cale> remexre: That sounds like something you can work around more easily though...
12:03:54 <remexre> yeah
12:04:50 <Cale> actually that's just associativity involving subtraction
12:05:28 <remexre> the Extra and KnownNat solvers should be able to take care of that already tho, right?
12:05:51 <Cale> I don't really know where their limits are
12:05:56 <remexre> ditto...
12:06:59 <Cale> But yeah, you just need some lemma like (a - b) + c ~ a + (c - b), along with b - b ~ 0 and a + 0 ~ a, the latter two of which I'd expect it to handle
12:07:49 <remexre> yeah... tbh just gonna try adding arbitrary solver plugins :itsfineman:
12:08:07 <Cale> Or even just add an axiom using unsafeCoerce on Refl or something
12:08:29 <Cale> I doubt it's easy to know when to apply a rule like that, but you can apply it explicitly
12:08:47 <Cale> (i.e. by pattern matching on an appropriate Refl)
12:10:53 <nshepperd2> natnormalise can handle that
12:11:31 <nshepperd2> i think
12:12:03 <nshepperd2> i guess the possibility that (x - b) is less than 0 is a problem for (x - b) + b = x
12:12:51 <Cale> Ahh
12:13:40 <remexre> okay sweet, NatNormalise works
12:13:54 <remexre> only took me 5 minutes to figure out normaliZe vs normaliSe
12:14:04 <remexre> thanks all!
12:28:57 <tom__> Is it better to use a ReaderT to thread an Env through server handlers or should I just pass it directly as a parameter?
12:31:14 <dmj`> tom__: probably equivalent. Less repetition with the former, depends on how many handlers you have, might not be worth it
12:32:19 <hseg> wtf https://github.com/goldfirere/singletons/issues/357#issuecomment-454136107
12:32:54 <hseg> i'm continually surprised by how seemingly semantically-equivalent terms can have different behaviours in ghc
12:33:06 <hseg> tbf, though, this usually happens with deep typery
12:33:06 <tom__> dmj`: Yeah have maybe 25 handlers, so not really convinced yet its worth it
12:33:44 <dmj`> tom__: you'd still have to `ask` for it anyways 
12:33:59 <dmj`> could make a function over that defined in terms of MonadReader though
12:35:58 <dminuoso> tom__: The value of ReaderT is not as much how many handlers you have, but it's rather how deep you need to feed the environment towards.
12:36:12 <dminuoso> If you need to fiddle it through many functions and mostly need it at the leafs, ReaderT becomes more valuable
12:36:37 <merijn> Especially in the exploratory parts of a project
12:38:17 <tom__> dminuoso: Yeah good point
12:40:06 <merijn> Consider, for example, stuff like logging
12:40:37 <merijn> Using ReaderT (or something isomorphic) for that is great, because it's easy to change your mind on how it should actually be implemented later
12:42:54 * hackage bytesmith 0.3.4.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.3.4.0 (andrewthad)
12:43:26 * dminuoso has also become a fan for ReaderT over IORef filled environments
12:43:36 <dminuoso> It's the better StateT, especially because of the free MonadUnliftIO
12:43:43 <tom__> merijn: Ah yeah
12:45:04 <tom__> If you arent using ReaderT ... Should you pass a whole Env record to handlers as a parameter or just the fields that are actually used?
12:45:23 <merijn> tom__: Incidentally, I would argue that ReaderT should never be publically visible
12:45:25 <tom__> As in   getProfile _dbConn vs getProfile env 
12:45:27 <dminuoso> tom__: Either.
12:45:44 <tom__> Ok maybe I need to stop worrying 
12:45:47 <merijn> tom__: It should be newtyped with something function specific
12:46:12 <merijn> tom__: If you look at, for example, both LoggingT and ResourceT you'll see that they're just ReaderT in a newtyped disguise
12:47:11 <dminuoso> I also have a ContextT which too is just a newtyped ReaderT :)
12:47:30 <merijn> tom__: If anything you should do "class MonadEnv m where getProfile :: m Conn" and use a newtype around ReaderT to implement it
12:47:42 <merijn> I have like 3 or 4 newtypes like that in my codebase :p
12:48:32 <dminuoso> Alternatively you can also use lens together with MonadReader
12:49:02 <merijn> dminuoso: Relying on MonadReader leads to clashing, though
12:49:40 <hseg> q: where can i see the implementation progress on a ghc proposal?
12:49:54 <merijn> hseg: Gitlab, presumably?
12:50:12 <hseg> sure, but how do i map from proposal id to gitlab issue?
12:51:59 <hseg> well, a quick search brought it up, but it would be nice to have a link in the proposal
12:51:59 <merijn> hseg: No clue, I guess the person working on it should mention it in the proposal
12:52:47 <merijn> Presumably you can just look up the submitters username on gitlab?
12:52:53 <tom__> merijn: What is that for?
12:53:13 <merijn> tom__: So you don't have to support/expose MonadReader
12:53:41 <tom__> I am new to mtl
12:53:44 <merijn> tom__: MonadReader has to be unique, so using it would clash with anyone who wants to use your stuff together with their own ReaderT
12:53:57 <tom__> Is this akin to the three layer cake where the second layer has typeclasses for capabilities
12:54:02 <tom__> which makes mocking easy
12:54:28 <merijn> I have no clue what 3 layer cake is
12:54:40 <merijn> Presumably not actual cake...
12:54:52 <solonarv> yeah, sounds about righ
12:54:54 <solonarv> t
12:55:16 <tom__> solonarv: was that a reply to me?
12:55:21 <tom__> merijn: :D
12:55:25 <hseg> hrm. dammit, github doesn't track renames, so I can't do an effective git blame without cloning the ghc-proposals repo...
12:55:29 <solonarv> tom__: it was
12:55:33 <solonarv> merijn: https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
12:55:39 <solonarv> TL;DR it's exactly what you were describing
12:56:15 <tom__> So is that a pragmatic approach to designing your app
12:56:16 <solonarv> with an extra splash of "business logic should be pure and not have MonadIO involved at all")
12:56:26 <solonarv> it seems pretty sensible to me
12:56:39 <solonarv> but I haven't actually made an app in Haskell in a while
12:57:27 <tom__> You just make apps when you need money to fun the non app stuff
12:57:46 <solonarv> well, the "non app stuff" I want to make includes a game, which is technically sort of an app
12:57:55 <tom__> :)
12:58:17 <hseg> ok, commenting on the issue
12:58:17 <solonarv> but I'm using an extra fancy framework because of, uh, reasons
12:58:28 <tom__> so a game in Haskell?
12:59:24 <solonarv> yup! currently it's not even really started, because of uni taking up too much of my productive time
12:59:27 <tom__> the mtl approach looks nice but I am afraid the guy learning Haskell on my codebase will be a bit overwhelmed
13:00:06 <tom__> Making games for fun sounds fun
13:00:50 <tom__> I made this game https://github.com/therewillbecode/ten-poker
13:01:03 <tom__> However turns out poker servers have a lot of state
13:01:56 <tom__> Haskell obviously :)
13:03:15 <merijn> tom__: You don't need to write everything all polymorphic in the approach I suggested, though. I mostly use 1 specific monad for 90% of things
13:05:15 <Athas> How much as Backpack been used so far?  I see some movements towards trying it out in vector, which I think will be the first time it'll see usage in a really popular library.
13:05:36 <merijn> Athas: edwardk has been using it a bit, I think
13:05:43 <fresheyeball> so I want to try out the Selda library
13:05:44 <merijn> Athas: Also, I wouldn't be so sure :p
13:05:50 <fresheyeball> because it looks small and nice
13:05:52 <fresheyeball> https://hackage.haskell.org/package/selda-0.5.1.0/docs/Database-Selda-SqlType.html
13:06:04 <fresheyeball> and I would like to derive and instance for this from a newtype
13:06:04 <Athas> merijn: sure, and it's on Hackage and all, but it seems it was mostly for experimental things.
13:06:09 <fresheyeball> but I can't seem to
13:06:10 <Athas> It's not like he put Backpack on lens, is it?
13:06:13 <merijn> Athas: I was the one who brought backpack up for vector which immediately got shot down by someone else, but now carter's asking around ;)
13:06:16 <fresheyeball> I think Typeable is stopping this from working
13:06:26 <fresheyeball> I even tried deriving via to no avail
13:06:45 <fresheyeball> Really I would like to understand why Typeable makes this non-derivable 
13:06:48 <fresheyeball> it seems silly
13:07:24 * hackage mailbox-count 0.0.5 - Count mailboxes in a SQL database.  https://hackage.haskell.org/package/mailbox-count-0.0.5 (MichaelOrlitzky)
13:08:23 <carter> merijn: I stumbled into in independently from how to keep good type inference for newbs while shedding complexity. I‚Äôm not sure if backpack quite lets me to do it.
13:08:58 <merijn> carter: tbh, my original idea was just to have copy paste exports for all the generic stuff with a monomorphised signature :p
13:09:31 <carter> But if I can get it to work the way i want it should have way better ux than the cpp or th
13:09:37 <carter> You mean cpp or th?
13:09:49 <merijn> carter: Good old copy paste originally :p
13:10:10 <carter> Isn‚Äôt that just cpp done poorly ?
13:10:35 <merijn> Arguably CPP is CPP done poorly :p
13:10:35 <carter> Honestly I‚Äôd be down for cpp if need be. It would be slightly gross but not hard
13:10:43 <carter> True
13:10:53 <merijn> carter: I kinda hate CPP like that because it makes source links on hackage near useless
13:10:58 <merijn> See, for example, conduit
13:11:09 <merijn> Half the links go to some opaque CPP macro
13:11:22 <carter> New enough cabal can run a custom preprocessing until
13:11:26 <carter> Until
13:11:29 <carter> Util
13:11:57 <merijn> I suppose...
13:13:03 <carter> We can write our own horrible custom crap
13:13:07 <carter> And everyone suffers. 
13:13:14 <carter> Let‚Äôs just patch ghc
13:13:43 <merijn> But I'm scared of yaks >.>
13:15:52 <merijn> carter: Do you really want to accommodate old cabal? I mean, I can see supporting old GHCs, but cabal-install 2.4-3.x support GHCs way back into the 7.x range
13:17:24 <carter> Lol.  I think there‚Äôs not even a good reason to use older tha. 2.4
13:18:33 <merijn> And if someone really, REALLY needs that <2.4 cabal-install support, I can give them by bank number :p
13:21:38 <carter> Honestly if something that crusty is valuable to a person and they‚Äôre of sound mental health, there‚Äôs money and laziness involved.  And not the fun haskell laziness
13:24:11 <[itchyjunk]> I forgot the trick to have negative exponent again :(
13:24:26 <merijn> [itchyjunk]: Parentheses? :p
13:24:30 <[itchyjunk]> a^^(-b) isn't it. it was using something other than ^ 
13:24:34 <[itchyjunk]> hmm
13:24:39 <merijn> > 5 ^ (-2)
13:24:42 <lambdabot>  *Exception: Negative exponent
13:24:44 <[itchyjunk]> was it just parentheses?
13:24:46 <merijn> > 5 ** (-2)
13:24:49 <lambdabot>  4.0e-2
13:24:54 <merijn> :t (^)
13:24:56 <lambdabot> (Integral b, Num a) => a -> b -> a
13:24:59 <merijn> :t (**)
13:25:00 <lambdabot> Floating a => a -> a -> a
13:25:13 <[itchyjunk]> >5 ** (-1)
13:25:14 <hseg> :t pow
13:25:16 <lambdabot> error: Variable not in scope: pow
13:25:25 <merijn> [itchyjunk]: ** is the slower, more general exponent function
13:26:00 <[itchyjunk]> it doesn't return an integet thought? wanted to feed to result to mod
13:26:01 <hseg> wait... (^) accepts an integral exponent, but fails at negative powers?
13:26:09 <hseg> > 5.0 ^ (-2)
13:26:12 <lambdabot>  *Exception: Negative exponent
13:26:14 <[itchyjunk]> yes 
13:26:32 <merijn> > 5 ^^ (-2)
13:26:34 <lambdabot>  4.0e-2
13:26:50 <hseg> ... ok
13:26:59 <merijn> ^ is integral, non-negative, ^^ is any integral, ** is any floating
13:28:13 <[itchyjunk]> ^^ returns integers? i got an "ambigious type variable "a0" when i passed result to mod
13:28:22 <merijn> :t (^^)
13:28:24 <lambdabot> (Fractional a, Integral b) => a -> b -> a
13:28:27 <remexre> are there any good approaches for (having nice syntax while) encoding a mapping between two finite types as a first-class value?
13:28:46 <merijn> [itchyjunk]: It's ambiguous because 'b' can't be inferred from context
13:29:02 <remexre> like I've got a term like (\case Just 0 -> Red | Just _ -> Green | Nothing -> Blue) that I'd like to be able to analyze, or use as a function
13:29:04 <[itchyjunk]> :<
13:29:09 <merijn> remexre: Eh...functions? ;)
13:29:41 <remexre> merijn: the analysis requirement is the problem :(
13:30:33 <hseg> remexre: what are your requirements of such a syntax?
13:30:42 <hseg> remexre: eg what should it look like
13:30:55 <remexre> just something not wholly awful
13:31:13 <[itchyjunk]> if i wanted "36^^(-5) `mod` 96" in ghci, it there any way to tell it that i want 36^^(-5) to be integer?
13:31:28 <remexre> like my boundary would probably be "I specify a pattern and an expression in some datatype, using de brujin indices" ?
13:32:04 <hseg> [itchyjunk]: ... :: Integer
13:33:01 <hseg> remexre: would something like flip lookup [(Just 0, Red), (Just 1, Green), (Nothing, Blue)] be acceptable?
13:33:04 <[itchyjunk]> ah
13:33:14 <hseg> (unsure of what you dislike, what you're looking for)
13:33:22 <[itchyjunk]> wait where do i put that?
13:33:32 <[itchyjunk]> i am not defining functions in a file, i'm using ghci
13:33:46 <hseg> > 36^^(-5) :: Integer
13:33:49 <lambdabot>  error:
13:33:49 <lambdabot>      ‚Ä¢ No instance for (Fractional Integer) arising from a use of ‚Äò^^‚Äô
13:33:49 <lambdabot>      ‚Ä¢ In the expression: 36 ^^ (- 5) :: Integer
13:34:11 <remexre> hseg: yes, except if the type is actually (Just Word64 -> RGB), it'd ideally fit in memory :)
13:34:20 <hseg> unless you mean the exponent needs to be integral?
13:34:29 <hseg> > 36 ^^ (-5 :: Integer)
13:34:31 <lambdabot>  1.65381716879202e-8
13:35:08 <hseg> remexre: Ah. How are you computing Word64 -> RGB?
13:35:48 <remexre> It's specified in my source code, but I'd like to be able to interpret the same term in a few different ways
13:36:00 <hseg> ?
13:36:06 <remexre> both "just run this on the CPU," and I want to try some compiling-with-categories exotica
13:36:30 <remexre> like the (\case Just 0 -> Red | Just _ -> Green | Nothing -> Blue) term literally appears in Haskell code (for now, at least)
13:36:34 <hseg> Again, still unclear. Can you gist the source?
13:36:42 <[itchyjunk]> (36 ^^ (-5 ::Integer)) `mod` 96 is still giving me errors about ambigious type variable
13:36:52 <hseg> :t mod
13:36:54 <lambdabot> Integral a => a -> a -> a
13:36:54 <remexre> I'm not sure what precisely you're asking, and the full codebase is huge
13:37:46 <Bad_K4rMa> [itchyjunk] whats the question?
13:37:46 <hseg> [itchyjunk]: no way that will typecheck -- the result of (36 ^^ (-5)) is fractional, but mod wants an integral input
13:38:04 <hseg> [itchyjunk]: are you trying to do modular inversion?
13:38:30 <jle`> `/b 1
13:38:32 <[itchyjunk]> Bad_K4rMa, i want to solve 36^(-5) = x (mod 96)
13:38:51 <remexre> like I guess I want tagless final for patterns?
13:38:52 <[itchyjunk]> hseg, something like that
13:39:06 <hseg> remexre: don't understand what you have and what you want
13:39:56 <hseg> [itchyjunk]: impossible with base instances
13:40:04 <remexre> hseg: I have basically nothing; I want a way to specify a DSL that contains pattern-matching, in a way that's friendly to the same sorts of term analysis one can do w/ tagless final style
13:40:12 <Bad_K4rMa> so x = 36^(-5)/(mod 96) ?
13:40:12 <[itchyjunk]> hmm i dont understand
13:40:31 <[itchyjunk]> there was a way to raise integer to negative integer and get an integer back
13:40:54 * hackage uuid-bytes 0.1.0.0 - UUID parsing using byteverse packages  https://hackage.haskell.org/package/uuid-bytes-0.1.0.0 (goolord)
13:41:07 <hseg> [itchyjunk]: besides, consider the flow of data here -- you somehow want 36^^(-5) to be of type m -> Mod m where m is your modulus
13:41:26 <hseg> remexre: don't know tagless final, sorry
13:41:59 <remexre> hseg: mentioning it might've been a red herring, sorry; just in some way that supports analysis of the function
13:42:13 <hseg> So you want a first-order lookup table?
13:42:33 <remexre> yes, but a literal table is too inefficient
13:42:40 <remexre> er, though I don't know what you mean by first-order
13:42:56 <hseg> as in, is a value that can be passed around
13:43:05 <remexre> yeah
13:43:42 <remexre> that would be sufficient, if there were some way to "compress" it such that having Word64 as the domain would work
13:44:26 <hseg> Hrm. you're reminding me of https://www.oilshell.org/blog/2016/12/27.html
13:45:19 <remexre> oh, that's unrelatedly useful-sounding for a completely different project
13:45:28 <hseg> what mappings do you have that you're trying to encode?
13:45:52 <hseg> Word64 -> (RGB ~ Word8^3) ?
13:46:19 <remexre> RGB = Red | Green | Blue; that was basically my example one
13:46:32 <Bad_K4rMa> [itchyjunk] does number**(power)
13:46:40 <remexre> like if this scheme can handle (Maybe Word64 -> RGB), it can do anything else I'd want
13:46:43 <hseg> OK, so you're trying to compress a map of type Word64 -> 3?
13:46:57 <remexre> yeah
13:47:16 <hseg> hrm. what kind of case analysis do you want to do on this?
13:47:41 <hseg> e.g. would compiling into bitmasks for red, green and blue separately be ok?
13:47:44 <remexre> stuff like "does the mapping cover the entire domain"
13:47:50 <hseg> ah
13:48:08 <remexre> or "give me an arbitrary value for each branch in the pattern match"
13:48:16 <hseg> nice
13:48:18 <hseg> hrm
13:48:36 <MarcelineVQ> [itchyjunk]: mod needs a integral number but ^^ results in a Fractional number so you need to do the rounding yourself if you want an Integer back, e.g using round
13:48:56 <hseg> so you want an efficient coding of a set of Word64 with quick membership and equality testing
13:49:51 <remexre> that sounds like it's getting further away; the range is potentially larger than 3, I just chose a huge domain for the example since the problem shows up faster that way
13:50:00 <remexre> since the problem of a table* shows up faster
13:51:00 <hseg> your analyses only seem to worry about the preimage sets, though
13:51:39 <hseg> anyway, have you considered a list of (preimage, value) pairs, where preimage :: IntSet?
13:52:06 <hseg> iirc uses patricia trees to compress
13:52:25 <MarcelineVQ> [itchyjunk]: I'd be inclined to use ** and round, if you need an Integer, or use http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#v:mod-39-  if the only reason you wanted an Integer was because mod needed it
13:52:26 <hseg> beyond that, am unsure how to help
13:52:54 <ezzieyguywuf> That's weird. `import SomeModule as S` compiles just fine and lets me access the functions is `SomeModule` fully unqualified
13:53:02 <remexre> hseg: I'm unfamiliar with patricia trees, I'll take a look at them
13:53:10 <ezzieyguywuf> now, I get that I left off the `qualified` keyword, but I'd expect that to be a syntax error
13:53:14 <dmwit> ezzieyguywuf: Why is that weird?
13:53:16 <hseg> MarcelineVQ: afaict, [itchyjunk] wants (n**k) `mod` m to give the modular exponent
13:53:21 <MarcelineVQ> mostly because ** composes better than ^^,  e.g.  12 ** (-3) ** (-4)
13:53:22 <hseg> MarcelineVQ: even for k negative
13:53:24 <remexre> oh, radix trees
13:53:33 <ezzieyguywuf> dmwit: because I'd expect it to be a syntax error. unless I misunderstand what the `as` keyword is doing
13:53:41 <dmwit> ezzieyguywuf: You probably did misunderstand, then.
13:53:58 <dmwit> "as" changes the qualification prefix. "qualified" prevents the unqualified name from being defined.
13:54:03 <dmwit> They're completely orthogonal.
13:54:22 <dmwit> I have some writing that may help clarify it somewhat, one moment.
13:54:35 <hseg> ... are there any uses for 'as' without 'qualified'?
13:55:04 <remexre> hm, actually, if I can TemplateHaskell a LambdaCase into a radix tree, that would be ideal
13:55:08 <dmwit> ezzieyguywuf: The start of this answer: https://stackoverflow.com/a/8331995/791604
13:55:13 <ezzieyguywuf> dmwit: actually that makes perfect sense
13:55:27 <ezzieyguywuf> as without `qualified` I was able to access the module either qualified OR unqualified
13:55:42 <ezzieyguywuf> so `as` just gives you a nickname, `qualified` forces you to use it
13:55:50 <dmwit> You always get a nickname.
13:55:54 <dmwit> as changes the nickname.
13:56:01 * ezzieyguywuf nods
13:56:22 <solonarv> [itchyjunk]: check out arithmoi, that has a bunch of modular arithmetic stuff including what you seem to be looking for
13:56:23 <hseg> remexre: could work. but why do that when IntMap gives you it already?
13:56:27 <ezzieyguywuf> that's why `qualified` works without `as`
13:56:34 <dmwit> hseg: Sure, when most stuff is unambiguous and so you want to use it unqualified, but there's one or two name conflicts and you want a short disambiguation name.
13:56:43 <hseg> ah, right
13:57:09 <[itchyjunk]> solonarv, ah i see
13:57:20 <hseg> most of my experience with ambiguity was with numeric preludes, which makes operators ambiguous
13:57:33 <hseg> and qualifying operators is Not Fun
13:57:42 <[itchyjunk]> i shifted -5 to (-5+96) = 91. bigger number to take power off but i guess the computer doesn't mind
13:57:49 <remexre> hseg: for the nicer syntax :P
13:57:53 <dmwit> Is it really bad?
13:58:01 <hseg> No, just ugly
13:58:04 <dmwit> P.+ -- seems not that bad
13:58:12 <dmwit> ok =)
13:58:22 <hseg> tastes differ, i guess
13:59:24 * solonarv doesn't remember if that actually work
13:59:31 <hseg> [itchyjunk]: yeah, it suffices to add a high enough multiple of the totient to the exponent. but you probably want to take moduli during multiplication to avoid blowing the size of the integer
13:59:34 <hseg> remexre: fair
13:59:47 <solonarv> ah right the totient not the modulus
14:00:08 <hseg> solonarv: good old torsion groups
14:00:28 <solonarv> apparently phi(96)=32, so you want to add a multiple of that
14:00:44 <dmwit> hseg: sounds painful
14:01:20 <solonarv> ah, but I found the functions in arithmoi!
14:01:46 <[itchyjunk]> hseg, take a moduli during multiplication? i dont understand
14:01:46 <hseg> 96=2^5*3, so phi(96)=(2-1)2^(5-1)(3-1)=2^5*2=32
14:01:57 <hseg> dmwit: ?
14:02:24 <hseg> [itchyjunk]: ab mod m = (a mod m)(b mod m), and a mod m is guaranteed to lie in [0,m)
14:02:43 <solonarv> powMod @96 36 (-5) -- I think this should work
14:03:01 <hseg> [itchyjunk]: so especially if a,k are large, a^k mod m is usually best implemented taking moduli at each multiplication
14:03:12 <[itchyjunk]> oh
14:03:18 <[itchyjunk]> what would be considered large?
14:03:39 <dmwit> relevant: http://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-Class.html#v:-94--37-
14:04:05 <hseg> (where we implement n^k = (if odd k then (n*) else id) (n^(k `div` 2) `mod` m) ** 2 or the like)
14:04:12 <dmwit> And powSomeMod later, too, I guess, depending on how you're picking your modulus.
14:04:58 <hseg> Don't know. anything where a^k >> maxBound @Int ?
14:06:01 <a1tern> is there a way to define type that would be alias for several other types?
14:06:02 <solonarv> ah dangit, powMod throws an error on negative exponents ;-;
14:06:17 <hseg> a1tern: ?
14:06:47 <solonarv> aha! invertMod @96 $ powMod 36 5 -- result: Nothing
14:06:50 <solonarv> so there is no solution
14:07:22 <dmwit> a1tern: I don't think so. What do you want to do that makes you think that's a good idea?
14:07:30 <hseg> too bad powMod doesn't compute invertMod . powMod
14:07:38 <solonarv> yeah, that would be nice
14:07:44 <dmwit> It can't, with the type it's given.
14:07:51 <dmwit> Sorry.
14:07:52 <solonarv> I guess they take "drop-in replacement for ^" very literally
14:07:58 <dmwit> It *shouldn't*, with the type it's given.
14:08:03 <a1tern> hseg: for example I have the same implementation of function for different types in typeclass instance
14:08:15 <a1tern> hseg: I want to avoid code duplication
14:08:18 <solonarv> then perhaps it should have a different type T_T
14:08:27 <hseg> i guess. but then they should have a version of **
14:08:29 <dmwit> a1tern: You could give that class method a default implementation.
14:08:35 <hseg> ... that should be ^^
14:08:44 <remexre> does ghc-datasize work? and if so, why is (force $ sum [1..100]) so big?
14:09:03 <remexre> I get 1336 bytes...
14:09:21 <hseg> a1tern: still unclear. you have multiple instances of a class and want to give them signatures?
14:09:31 <dmwit> :t force
14:09:32 <lambdabot> error: Variable not in scope: force
14:09:38 <solonarv> oh, actually ^^ just works on Mod values
14:09:42 <hseg> remexre: what type is it inferring for the Num instance?
14:09:47 <solonarv> but of course in this case it calls 'error'
14:09:52 <dmwit> hseg: Probably you aren't forcing right.
14:10:07 <hseg> dmwit: ?
14:10:18 <dmwit> You need something like ```let x = sum [1..100] in force x `seq` dataSize x` or so.
14:10:31 <hseg> dmwit: you want remexre 
14:10:35 <dmwit> `dataSize (force (sum [1..100]))` won't cut the mustard.
14:10:39 <dmwit> hseg: Yes, I do. Sorry about that.
14:10:41 <dmwit> remexre: ^
14:10:41 <solonarv> [itchyjunk]: using arithmoi: 36 ^^ (-5) :: Mod 96
14:11:21 <dmwit> remexre: In fact, you probably need to give `x` a monomorphic type signature, too.
14:11:29 <remexre> oh, yeah, it's totally a huge polymorphic type
14:12:24 <a1tern> hseg: https://gist.github.com/altern/d042fc99eb932e04e7da793a91a2b5ec
14:13:08 <dmwit> a1tern: `class LoadFromFile a where loadFromFile :: FilePath -> IO a; default loadFromFile :: FromJSON a => FilePath -> IO a; loadFromFile = fmap (...) (B.readFile ...)`
14:13:17 <remexre> dmwit: wait, why (wrt needing force+seq)
14:13:54 <dmwit> I dunno. I sort of assume that `dataSize` explicitly chooses not to force its argument.
14:13:58 <remexre> tho it certainly does work
14:14:04 <remexre> oh, that makes sense, yeah
14:14:08 <dmwit> Am I wrong? I don't even know if it's called dataSize. Haven't played with the library before.
14:14:12 <remexre> so the size includes the thunk for force itself
14:14:13 <remexre> recursiveSize
14:14:28 <remexre> I'm getting 16 now, which makes more sense
14:14:30 <solonarv> the contract of `force` is that if `force x` is in whnf, it is in fact in nf (and it is equal to x, so that is also in nf)
14:14:38 <dmwit> So if recursiveSize doesn't force its argument, then the `force` never even happens.
14:14:48 <solonarv> yes, that
14:15:05 <solonarv> 16 should be the size for an Int
14:15:14 <solonarv> 8 bytes tag + 8 bytes for the value, I think?
14:15:24 <hseg> or using DerivingVia, construct newtype JSONParseable a = JP a; instance FromJSON a => LoadFromFile (JSONParseable a); deriving via (JSONParseable Repository) instance LoadFromFile Repository 
14:15:46 <dmwit> Ooo, yep, DerivingVia is a nice solution, too.
14:15:58 <solonarv> this is slightly more verbose but has the big advantage that you can have multiple such "default implementations"
14:17:15 <dmwit> fromJust -_-
14:17:44 <dmwit> (If you're in IO already, at least use throwIO.)
14:18:21 <a1tern> dmwit: wow! that simple! I didn't know about possibility to declare default implementation with the `default` keyword.. thanks a lot
14:19:21 <solonarv> yes, it's quite handy
14:21:21 <remexre> oh, grr, IntMap is (Int -> a), not (Integer -> a)
14:22:01 <dmwit> (Precision: it is possible to declare default implementations without the default keyword. The default keyword is needed only when the type of the default implementation is not as general as the type of the method.)
14:22:15 <MarcelineVQ> if Int isn't large enough one can use Map Integer
14:22:44 <remexre> then I can't store enormous numbers of keys
14:23:10 <solonarv> that is not the problem anyway
14:23:20 <remexre> though actually, I might need to implement my own anyway, since I think I need to read the structure of the radix tree
14:23:30 <dmwit> Is the IntMap-style trie really fixing that problem, though?
14:23:55 <dmwit> Unless the data you're associating with each key is very small, it seems like "lots of keys" also means "lots of values".
14:24:06 <remexre> I can share values, no?
14:24:12 <dmwit> Depends how they're computed.
14:24:13 <dmwit> Maybe.
14:24:30 <remexre> oh, I guess that'd need to be an optimization I do on insert or IntMap would need to do itself
14:24:47 <remexre> but I've got a relatively small (smaller than #words in ram, at least) set of values
14:24:56 <remexre> set of distinct* values
14:24:56 <solonarv> an IntMap with n entries surely takes at least n*8 bytes, so there is no way you will ever have a "full" intmap
14:25:14 <remexre> then I want a custom trie
14:25:15 <solonarv> unless you can somehow scrounge up on the order of 2^64 bytes of memory
14:25:46 <dmwit> There are implementations on Hackage for lazily-populated tries that support Integer.
14:26:04 <solonarv> sure! but I was talking about IntMap specifically, which is not one of those.
14:26:39 <dmwit> http://hackage.haskell.org/package/MemoTrie-0.6.10/docs/Data-MemoTrie.html e.g.
14:27:55 <remexre> hm, neither of those look like they'd let me do the "get a set of keys that expand to every value in the tree" operation efficiently
14:28:16 <jle`> ezzieyguywuf, hseg: the https://hackage.haskell.org/package/quadratic-irrational library is nice for situations with exact roots of rationals :)  as long as you only ever take the square root of one item
14:28:40 <hseg> nice
14:28:58 <remexre> yeah, just gonna do my own
14:29:09 <dmwit> remexre: That... seems very hard in principle.
14:29:21 <dmwit> e.g. if your function was a hash that would be a preimage attack.
14:29:47 <dmwit> ...ish?
14:29:55 <remexre> dmwit: these functions generally have, uh, low entropy? (metaphorically)
14:30:04 <remexre> like the domain is waaaaaaay bigger than the codomain
14:30:10 <remexre> and they're total maps
14:30:51 <dmwit> The function "is this dmwit's password?" has a domain waaaaaay bigger than the codomain, but it's still hard to compute the preimage of True.
14:31:17 <remexre> if I had a trie handed to me that computed it, I don't think it (sh|w)ould be?
14:31:26 <remexre> a reasonably minimal trie*, I guess?
14:31:39 <dmwit> Do... we have the same definition of trie?
14:31:47 <remexre> uh
14:31:54 <hseg> remexre: i reiterate -- given that all you've asked for is an encoding of Int -> a for which one can ask "is a function total" and preimages, a reasonable encoding would either be an IntMap a or a [(IntSet, a)]
14:31:55 <remexre> it's been a while since I've taken an algorithms class
14:32:10 <remexre> hseg: IntMap doesn't work, since my keys are potentially larger than Int
14:32:11 <dmwit> ...are you looking for a DFA library? ^_^
14:32:24 <hseg> remexre: how many keys do you have?
14:32:32 <BirdDown> Is there a way to pretty render a Lucid HTML to the command line?
14:32:41 <hseg> are they perhaps ranges?
14:32:55 <remexre> hseg: largest one I know of in this program is smth like Word800
14:33:09 <hseg> ... as in there's 2^800 keys?
14:33:11 <remexre> and the mappings can be efficiently described with ranges, I'm assuming
14:33:14 <remexre> yeah
14:33:19 <dmwit> Oh, then you want an IntervalMap.
14:33:58 <dmwit> http://hackage.haskell.org/package/IntervalMap
14:34:22 <dmwit> ...maybe
14:34:26 <remexre> hm, I'll see if I can get that to work
14:34:46 <a1tern> dmwit: ‚Ä¢ No instance for (LoadFromFile RequirementsHistory)
14:34:46 <a1tern>         arising from a use of ‚ÄòloadFromFile‚Äô
14:34:56 <dmwit> A decision tree might work, too. But I think the question of "what is an efficient decision tree for this function" is hard?
14:35:16 <a1tern> dmwit: I am getting this for some reason when trying to use in a context
14:35:19 <remexre> dmwit: the functions I'm doing are reasonably simple pattern-matching functions
14:35:26 <dmwit> Perhaps you can make that the problem of the person making the decision tree, though.
14:35:45 <hseg> ... ok, i need to bow out. remexre, you look to be in good hands
14:35:47 <dmwit> a1tern: You know the rules. Minimal code sample needed.
14:36:16 <remexre> hseg: thanks! (tho too late to actually send, darn)
14:36:39 <remexre> dmwit: yeah, I think I see how to efficiently make the decision tree
14:39:26 * dmwit ponders data DecisionTree a = DecisionTree { negInf :: Bool, boundaries :: Set a }
14:39:54 * hackage daemons 0.3.0 - Daemons in Haskell made fun and easy  https://hackage.haskell.org/package/daemons-0.3.0 (AlexandruScvortov)
14:40:27 * dmwit starts pondering data DecisionTree a b = DecisionTree { negInf :: b, boundaries :: Map a b } instead
14:41:56 <dmwit> semantics: if (a, b) is in the map, and (a', b') is the next biggest key, then all values between a (inclusive) and a' (exclusive) have value b.
14:42:03 <dmwit> Values below the smallest key have value negInf.
14:43:16 <remexre> hm, more efficient than the tree I'm thinking of
14:43:27 <dmwit> Getting a representative set of inputs is relatively easy (just keysSet . boundaries) with the single possible exception of getting a representative for the smallest range.
14:43:36 <remexre> yeah
14:43:43 <dmwit> minBound or pred could potentially be used for the last mile there.
14:46:54 <dmwit> Inserting ranges seems mildly tricky.
14:48:02 <dmwit> (Inserting closed-open ranges is easy, but other shapes of ranges seem harder.)
14:48:19 <remexre> I *think* I know the full set of values ahead of time
14:48:28 <remexre> i.e. I don't really need insert, just fromTree or w/e
14:48:42 <dmwit> That's nice. =)
14:49:59 <remexre> yeah, this thing has been carving out the thin slices of tractability in the problem
14:50:19 <a1tern> dmwit: smth like that: https://gist.github.com/altern/d042fc99eb932e04e7da793a91a2b5ec
14:50:50 <dmwit> Tongue half-in-cheek: use SBV, SBV Word800 -> SBV OutputType. Ask SAT-solver for all unique inputs.
14:51:15 <dmwit> Captures ranges, but also many many other fun patterns that are complicated to specify as ranges.
14:51:25 <nshepperd2> dmwit: make it Map a (b,b)
14:51:47 <dmwit> nshepperd2: semantics?
14:51:52 <dmwit> a1tern: You still need to declare the instance.
14:51:59 <nshepperd2> First b represents value at a, second b represents value after a
14:52:04 <remexre> dmwit: then I need to be able to encode my function in a SMT-solver-friendly DSL, right?
14:52:12 <dmwit> a1tern: For example use DeriveAnyClass and `data RequirementsHistory = ... deriving LoadFromFile`.
14:52:36 <dmwit> remexre: Yes, that is the meaning of the type SBV Word800 -> SBV OutputType.
14:53:08 <dmwit> nshepperd2: Not bad!
14:53:39 <dmwit> a1tern: ...you will need to derive FromJSON, too, of course.
14:53:52 <dmwit> (Or write an instance by hand. Or whatever. Anyway you need an instance.)
14:56:03 <dmwit> remexre: (Certainly range bounds, if those are the most natural representation of your function, are easily expressed in sbv.)
14:57:22 <remexre> hm, idk; seems overkill :P
14:57:33 <iqubic> What is SBV?
14:57:50 <remexre> https://hackage.haskell.org/package/sbv
14:57:56 <dmwit> You'll come crawling back when you realize you want all the odd inputs to have a special output value, you'll see.
14:58:30 <remexre> :P
15:04:41 <GreyFaceNoSpace> can i use pattern matching on fractions
15:05:17 <GreyFaceNoSpace> ie. test a | a == _ % 1 = true
15:05:30 <Axman6> if it's a Rational, then yes
15:05:35 <Axman6> @src Rational
15:05:35 <lambdabot> type Rational = Ratio Integer
15:05:42 <Axman6> @src Ratio
15:05:42 <lambdabot> data (Integral a) => Ratio a = !a :% !a
15:06:32 <Axman6> > let isWholeNumber (_ :% 1) = True; isWholeNumber _ = False in isWholeNumber 2.5
15:06:35 <lambdabot>  error:
15:06:35 <lambdabot>      Not in scope: data constructor ‚Äò:%‚Äô
15:06:35 <lambdabot>      Perhaps you meant one of these:
15:06:57 <Axman6> > let isWholeNumber (_ % 1) = True; isWholeNumber _ = False in isWholeNumber 2.5
15:07:00 <lambdabot>  <hint>:1:20: error: Parse error in pattern: _ % 1
15:07:10 <Axman6> hmm, ok not sure why that's not working
15:07:40 <ph88> can a typeclass defined in one package be extended by an instance from another package ?
15:07:44 <Axman6> a == _ % 1 isn't a pattern though, it's just an expression which doesn't make sense
15:10:21 <GreyFaceNoSpace> how do i match a fraction with (a % 1) where a is any number ?
15:10:47 <nshepperd2> @let import Data.Ratio
15:10:49 <GreyFaceNoSpace> i just care about the denominator 
15:10:49 <lambdabot>  Defined.
15:11:04 <nshepperd2> :t (:%)
15:11:06 <lambdabot> error:
15:11:06 <lambdabot>     ‚Ä¢ Data constructor not in scope: :%
15:11:06 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
15:11:17 <GreyFaceNoSpace> :t (%)
15:11:18 <lambdabot> Integral a => a -> a -> Ratio a
15:12:26 <nshepperd2> oh, it doesn't export the constructor
15:12:51 <GreyFaceNoSpace> i want to match my rational with _ % 1
15:12:56 <GreyFaceNoSpace> how can i do that?
15:13:36 <GreyFaceNoSpace> in standard ml i would write  : test x = match x with _ % 1 -> true    for exmaple
15:13:47 <GreyFaceNoSpace> i thin k
15:13:53 <GreyFaceNoSpace> i am not an expert in sml
15:14:04 <GreyFaceNoSpace> i just wanna make sure that the denominator is 1
15:14:24 <nshepperd2> you can use 'denominator' 
15:14:31 <nshepperd2> :t denominator
15:14:33 <lambdabot> Ratio a -> a
15:14:57 <GreyFaceNoSpace> oh
15:15:03 <GreyFaceNoSpace> let x = 12 % 17
15:15:20 <GreyFaceNoSpace> nice
15:15:25 <GreyFaceNoSpace> denominator x
15:19:51 <a1tern> dmwit: still does not work with your latest recommendations: https://gist.github.com/altern/d042fc99eb932e04e7da793a91a2b5ec
15:22:41 <GreyFaceNoSpace> how do you convert from integral to integer
15:22:42 <GreyFaceNoSpace> ?
15:23:13 <Guest60619> Hey guys, what's the best IDE to use when getting started with Haskell?
15:23:46 <subleq> GreyFaceNoSpace: fromIntegral
15:23:54 <bgamari> Guest60619, many people use vim or emacs
15:24:06 <bgamari> Guest60619, I have heard good things about VS Code
15:24:21 <bgamari> although none of these are really IDEs
15:24:41 <Guest60619> VS code probably is my best shot then
15:24:45 <fdem> well, they asked for an IDE
15:25:25 <MarcelineVQ> any editor you're comfortable with haskell code coloring and ghci open next to it will get you very far, no need to get complicated when you're still learning the language
15:26:17 <maerwald> vs code is pretty good currently with haskell, yes
15:26:41 <maerwald> that's pretty much the only environment where hie kinda works
15:26:42 <Guest60619> Fair enough MarcelineVQ. Thanks bgamari. I'll give VS code a go with ghci open
15:26:56 <Guest60619> thanks!
15:27:17 <bgamari> Guest60619, there are quite active efforts to implement IDE functionality
15:27:33 <bgamari> via the language server protocol
15:28:22 <maerwald> not sure that was a good idea tbh... LSP just adds mor complexity, json and overhead... for something I will ever only run on the same machine :>
15:30:13 <bgamari> sure
15:30:30 <bgamari> I still generally use GHCi, myself
15:32:13 <maerwald> ghc-mod worked very well back when it still worked (with ghc-8.0 or something), no LSP needed. The problem wasn't a protocol or editor integration problem, twas just unmaintainable legacy code and too fast ghc api development
15:33:41 <GreyFaceNoSpace> is this constant converting between number types the norm in haskell? or am i doing it wrong? its working fine. just wondering how i can write it better? https://pastebin.pl/view/0c653e87
15:41:42 <jle`> GreyFaceNoSpace: being explicit with what sort of numbers you're working with is normal, but it's usually not necessarily messy
15:41:49 <jle`> GreyFaceNoSpace: in your case there is a lot of duplicated stuff going on
15:44:20 <jle`> GreyFaceNoSpace: this is how i'd write it maybe
15:44:21 <jle`> https://pastebin.pl/view/608446ec
15:45:40 <jle`> https://pastebin.pl/view/587538f3 is a version with tabs fixed
15:45:48 <Gurkenglas> GreyFaceNoSpace, you were right to hope for a better way https://pastebin.pl/view/ad7a7eb2
15:46:01 <GreyFaceNoSpace> jle`, thank you for your suggestion. i didnt know that i can define more than one variable in a where binding
15:47:03 <jle`> Gurkenglas: ah neat, i didnt' realize :% was a thing
15:47:10 <GreyFaceNoSpace> Gurkenglas, ah. this case of looks like the classic pattern matching from sml
15:47:18 <Gurkenglas> (replace ((p :% q):xs) with (x@(p :% q):xs) or x with p:%q ._.)
15:47:25 <GreyFaceNoSpace> also i gotta look up :% and divMod
15:47:45 <GreyFaceNoSpace> danke Gurkenglas
15:47:51 <Gurkenglas> I just thought it ought to be a thing so looked up how denominator is implemented
15:47:52 <jle`> this makes my version a little cleaner
15:47:53 <jle`> https://pastebin.pl/view/9e995b61
15:48:48 <jle`> i guess the lesson of the story is don't think of things as 'converting' between number types, but instead just use the strutural properties of each type
15:48:53 <jle`> since they are unique things
15:49:01 <jle`> and it doesn't really make sense to 'convert' between the two
15:49:33 <Gurkenglas> "How do I get String out of IO String?"
15:49:41 <jle`> for example i used `n % 1` instead of `fromIntegral n` because conceptually i don't imagine 'converting' between Integer and Rational
15:49:48 <jle`> but i think 'what Rational do i want to make from n?'
15:59:10 <koz_> In Megaparsec, how do I phrase 'parse up 1 to newline, but ignore it either way'?
15:59:19 <koz_> s/1 to/to 1/
16:00:04 <koala_man> is that the same as "optionally skip 1 linefeed"?
16:00:49 <Gurkenglas> koz_, "try newline"?
16:01:03 <koz_> Gurkenglas: Oh, that simple huh. Thanks!
16:04:14 <Gurkenglas> Anyone got a ham filter that detects when people ask questions here?
16:04:41 <koala_man> I imagine 'optional newline' is more efficient
16:05:27 <koz_> Gurkenglas: That gave me a mental image of someone putting their ear against a giant ham on the bone and listening.
16:05:53 <Axman6> '\?' <-  regex to detect if someone is asking a question
16:06:28 <ChaiTRex> Gurkenglas: let f ('h':'a':'m':xs) = True; f _ = False in any f . tails $ xs
16:06:40 <ChaiTRex> :t any
16:06:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:07:23 <Gurkenglas> Where is the source for optional o.o? https://hackage.haskell.org/package/megaparsec-4.4.0/docs/Text-Megaparsec.html doesn't link it
16:08:47 <Axman6> @hoogle optional
16:08:47 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
16:08:47 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:08:47 <lambdabot> Text.Parsec optional :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m ()
16:08:48 <Gurkenglas> Axman6, Ctrl-F suggests there will be a bunch of false positives
16:09:16 <koz_> Gurkenglas: What are some examples of said false positives?
16:10:25 <Gurkenglas> I would not for example want "<Gurkenglas> koz_, "try newline"?" to summon me to the IRC client
16:10:51 <jle`> optional x = (Just <$> x) <|> pure Nothing
16:11:00 <koz_> Hmm.
16:11:08 <ph88> are there some flags i can pass to stack to turn on all ghc warnings ?
16:11:12 <jle`> guaranteed to succeed becuase of the pure on the rhs of <|>
16:11:46 <ChaiTRex> ph88: -Wall?
16:12:08 <jle`> -Wall is a ghc flag, not a stack flag, i think. but also it doesn't turn on all ghc warnings
16:12:40 <ChaiTRex> -Weverything for GHC
16:13:57 <Gurkenglas> koala_man, why do you expect that? Looking at https://hackage.haskell.org/package/megaparsec-4.4.0/docs/src/Text-Megaparsec-Prim.html , I don't see evidence for that in pTry vs pPlus
16:15:50 <koala_man> maybe it doesn't matter when the "lookahead" is strictly 1
16:17:14 <astk> is there any way to get projects deployed to a server to reuse a closure?
16:17:46 <ph88> thx ChaiTRex 
16:17:53 <ph88> what to use instead of http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-List.html ??
16:17:58 <astk> to save it having to copy things over repeatedly which is slow...
16:18:29 <Gurkenglas> koala_man, I don't see how that matters
16:19:22 <koz_> ph88: Is your goal non-determinism?
16:19:53 <ph88> koz_, my goal is just to fix a deprecation warning, i don't know what the code is doing
16:20:08 <koz_> ph88: Yeah... that's not really that simple, for good reason.
16:20:30 <Gurkenglas> ph88, may I see the code?
16:21:33 <ChaiTRex> ph88: What function is deprecated?
16:22:05 <Gurkenglas> ChaiTRex, the whole list monad transformer is deprecated, see the red writing at the top of http://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-List.html
16:22:08 <koala_man> Gurkenglas: Maybe it doesn't. I generally try to avoid designing parsers based on 'try' because generated errors get worse and performance suffers when there's a lot of backtracking. I don't know whether there's an inherent difference if the latter is not the case
16:22:12 <ph88> Gurkenglas, https://github.com/snoyberg/monad-logger/blob/master/Control/Monad/Logger.hs#L137
16:22:25 <ph88> ChaiTRex, the entire module seems to be deprecated
16:22:32 <ChaiTRex> ph88: Ahh
16:23:16 <jle`> ph88: https://hackage.haskell.org/package/list-transformer gives a 'true' list monad transformer
16:23:23 <jle`> ph88: but the answer to 'what to use' depends on your situation
16:23:40 <Gurkenglas> ph88, it looks like that page only mentions ListT to lift the MonadLogger instance through it
16:23:53 <ph88> yes
16:24:04 <Gurkenglas> Which seems fine to me even if the module is deprecated - the user can decide whether they want to use it anyway
16:27:47 <Gurkenglas> I can understand your urge to clean the warning, though. What's the official stance on supporting deprecated code?
16:28:05 <GreyFaceNoSpace> ok...sorry for bothering you guys again. can someone please slowly explainn  to me the difference between foldr and foldl ?
16:28:14 <Gurkenglas> @src foldr
16:28:14 <lambdabot> foldr f z []     = z
16:28:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:28:16 <Gurkenglas> @src foldl
16:28:16 <lambdabot> foldl f z []     = z
16:28:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:28:20 <jle`> if you want to suppress the warning then you can just suppress that specific warning
16:28:24 <jle`> within that file
16:28:48 <Gurkenglas> > foldr f x [a,b,c,d]
16:28:50 <lambdabot>  f a (f b (f c (f d x)))
16:28:57 <Gurkenglas> > foldl f x [a,b,c,d]
16:28:59 <lambdabot>  f (f (f (f x a) b) c) d
16:29:04 <Gurkenglas> GreyFaceNoSpace, makes sense?
16:29:16 <GreyFaceNoSpace> so whats wrong here ? compose xs = foldr (head xs) (last xs) xs     for example?
16:29:19 <jackdk> GreyFaceNoSpace: http://data.tmorris.net/talks/list-folds/b30aa0fdff296c731bc5b1c824adf1d02b3b69d9/list-folds.pdf
16:29:24 <GreyFaceNoSpace> xs is a list of functions
16:29:40 <jle`> GreyFaceNoSpace: 'last xs' is also a list of functions
16:29:53 <GreyFaceNoSpace> is it not the last function in the list?
16:29:56 <GreyFaceNoSpace> its last not tail
16:29:57 <jle`> ah, sorry
16:29:58 <Gurkenglas> GreyFaceNoSpace, the first and second argument to foldr have different types, (head xs) and (last xs) have the same type
16:29:59 <jle`> you're right
16:30:15 <jle`> GreyFaceNoSpace: the first argument is how you want to 'process' each item
16:30:42 <jle`> GreyFaceNoSpace: if you want to see why it is wrong, simply expand the definition of foldr
16:30:47 <GreyFaceNoSpace> yes i want the the first function of the list. to be applied to the rest
16:30:50 <jle`> this is the way that will always work
16:31:27 <jle`> foldr (head xs) (last xs) (y:ys) = head xs y (foldr (head xs) (last xs) ys)
16:31:45 <jle`> do you see why that second thing doesn't really make sense?
16:32:29 <jle`> GreyFaceNoSpace: try writing your function using normal recursion on lists first
16:32:34 <jle`> GreyFaceNoSpace: that will help you figure out "what you really mean"
16:32:37 <GreyFaceNoSpace> jle` ok
16:32:43 <jle`> then, after that, we can see how to translate that into a fold
16:32:45 <jle`> compose [] = ???
16:32:50 <jle`> compose (f:fs) = ???
16:32:55 <GreyFaceNoSpace> compose :: [(a -> a)] -> a -> a
16:33:09 <jle`> neat, so start with that template
16:33:10 <GreyFaceNoSpace> gonna write it and come back
16:33:15 <jle`> what should it do for []? what should it do for (f:fs) ?
16:33:17 <jle`> etc.
16:33:27 <jle`> doing that will help you figure out what it is you actually want to do
16:33:39 <jle`> then after that it will be a little easier to translate into a fold
16:35:22 <GreyFaceNoSpace> jle`, is there a way such that my function does nothing
16:35:23 <GreyFaceNoSpace> ?
16:36:05 <GreyFaceNoSpace> jle`, srry let me think abit
16:37:16 <jle`> it might help to have the argument too
16:37:18 <jle`> compose [] x = ???
16:37:22 <jle`> compose (f:fs) x = ???
16:37:32 <jle`> GreyFaceNoSpace: but also, think about what you would want `compose [] 5` to do
16:37:37 <jle`> what should it return?
16:37:44 <jle`> 7? 9? pi?
16:37:52 <GreyFaceNoSpace> yes exactly
16:37:52 <jle`> the options are limitless
16:37:57 <jle`> but think about which one would make the most sense
16:37:59 <GreyFaceNoSpace> thats what i am thinking about now
16:38:21 <jle`> you are applying no functions to 5, so the result is .... ?
16:38:23 <GreyFaceNoSpace> @src id
16:38:24 <lambdabot> id x = x
16:38:37 <GreyFaceNoSpace> compose f [] = id
16:38:50 <GreyFaceNoSpace> compose f (x:xs) = f (compose f xs)
16:38:57 <jle`> no wait, your list is the functions
16:39:00 <jle`> not the items
16:39:04 <jle`> compose [] x = x
16:39:09 <jle`> since compose [] 5 = 5, right?
16:39:15 <GreyFaceNoSpace> ye
16:39:28 <jle`> so `compose [] x = x`
16:39:34 <jle`> now think about `compose (f:fs) x = ???`
16:40:29 <ph88> how do i run test-suite with cabal ?
16:40:43 <jle`> GreyFaceNoSpace: again, try to think of it with an example
16:40:53 <jle`> GreyFaceNoSpace: of what f, fs, and x could be
16:41:02 <GreyFaceNoSpace> just a sec because i got confused. my list (x:xs) has functions which i want to apply to each other right ? 
16:41:11 <GreyFaceNoSpace> or atleast this is what i understood from the signature
16:41:22 <GreyFaceNoSpace> and exercise
16:41:23 <jle`> ph88: does 'cabal test' work?
16:41:33 <jle`> GreyFaceNoSpace: you don't want to apply functions to functions
16:41:37 <jle`> GreyFaceNoSpace: you want to apply functions to values
16:41:43 <GreyFaceNoSpace> compose :: [(a -> a)] -> a -> a such that compose [f 1 , . . . , f n ] = f 1 (. . . (f n (¬∑) . . . )
16:42:03 <jle`> oh er, that one doesn't make much sense
16:42:08 <jle`> i was thinking that you wanted to do something like
16:42:19 <GreyFaceNoSpace> yeah i am confused by the question
16:42:24 <jle`> compose [(+1), (*2), negate] 5   = negate 5 * 2 + 1
16:42:29 <jle`> my question?
16:42:37 <GreyFaceNoSpace> nono the exercise's question
16:42:39 <GreyFaceNoSpace> is confusing
16:42:48 <jle`> does the exercise give any example inputs/outputs?
16:42:52 <GreyFaceNoSpace> nope
16:42:57 <GreyFaceNoSpace> just that one liner i pasted
16:42:59 <jle`> what is teh actual wording of the exercise?
16:43:07 <GreyFaceNoSpace> exactly what i pasted
16:43:08 <GreyFaceNoSpace> lol
16:43:17 <jle`> what did you paste?
16:43:24 <GreyFaceNoSpace> Using foldr, implement the following functions:
16:43:24 <GreyFaceNoSpace> 1. compose :: [(a -> a)] -> a -> a such that compose [f 1 , . . . , f n ] = f 1 (. . . (f n (¬∑) . . . ).
16:43:45 <jle`> ah, maybe they mean like
16:43:59 <jle`> compose [f1, f2 ... fn] = f1 . f2 . ... . fn
16:44:30 <ph88> yes works, thx jle` 
16:44:33 <jle`> yeah, so think about what sort of things that would give, when used with actual functions
16:44:41 <GreyFaceNoSpace> which is why my solution was : compose xs = foldr (head xs) (last xs) (tail xs)
16:44:46 <jle`> GreyFaceNoSpace: compose [(+1), (*2), negate] = (+1) . (*2) . negate
16:44:55 <iqubic> I know how I'd implement this.
16:45:01 <jle`> so compose [(+1) . (*2) . negate] 1 = ((negate 1) * 2) + 1)
16:45:08 <jle`> GreyFaceNoSpace: does that make sense?
16:45:14 <GreyFaceNoSpace> yea it does
16:45:25 <GreyFaceNoSpace> but i wanted to implement it with out (.)
16:45:37 <jle`> so your list has functions, but you don't apply those functions to each other
16:45:40 <jle`> you compose their applications to values
16:45:59 <jle`> so compose [f,g] x = f (g x)
16:46:06 <jle`> compose [f,g,h] x = f (g (h x))
16:46:13 <jle`> do you see, you aren't applying f to g or h
16:46:20 <jle`> you're applying f to (g (h x)), and g to (h x)
16:46:28 <GreyFaceNoSpace> aah
16:46:33 <jle`> you don't apply the functions to other functions, you're applying them to the a's
16:46:38 <GreyFaceNoSpace> ok
16:46:40 <GreyFaceNoSpace> i see
16:46:44 <GreyFaceNoSpace> thank you
16:46:46 <GreyFaceNoSpace> makes sense now
16:47:01 <jle`> so you want an example where compose [] = x, compose [f] x = f x, compose [f,g] x = f (g x), etc.
16:47:12 <jle`> er, that first one is compose [] x = x
16:47:24 <jle`> but you should be able to define this inductively/recursively, using only the two cases, [] and f:fs
16:47:38 <iqubic> Without saying what the definition is, I defined this:
16:47:39 <iqubic> > compose [(+1), (*2), negate] 1
16:47:41 <lambdabot>  -1
16:47:57 <iqubic> So you can test out the function and see how it works.
16:48:03 <iqubic> :t compose
16:48:04 <lambdabot> Foldable t => t (b -> b) -> b -> b
16:49:11 <iqubic> > compose [reverse, (++ "H"), reverse] "ello World!"
16:49:14 <lambdabot>  "Hello World!"
16:49:56 <GreyFaceNoSpace> compose [] y = y
16:49:56 <GreyFaceNoSpace> compose [x] y = x y
16:49:56 <GreyFaceNoSpace> compose (x:xs) y = x (compose xs y) 
16:50:52 <jle`> does that work?
16:50:55 <GreyFaceNoSpace> yeah
16:51:01 <GreyFaceNoSpace> it compiles
16:51:03 <iqubic> Nice.
16:51:07 <jle`> does it do what you want it to do?
16:51:12 <iqubic> Does it have the desired effect?
16:51:24 <jle`> does it accomplish the stated goal?
16:51:28 <iqubic> You can use my two examples as test cases.
16:51:53 <iqubic> > compose [reverse, (++ "H"), reverse] "ello World!"
16:51:55 <lambdabot>  "Hello World!"
16:52:04 <iqubic> > compose [(+1), (*2), negate] 1
16:52:06 <lambdabot>  -1
16:52:09 <GreyFaceNoSpace> yeah works
16:52:21 <GreyFaceNoSpace> its working
16:52:34 <iqubic> This is using my own definition of compose. I'm not sharing how it works.
16:52:57 <jle`> GreyFaceNoSpace: okay, so now to write it in terms of a fold
16:53:03 <jle`> GreyFaceNoSpace: note that your [x] case is actually redundant
16:53:29 <jle`> since compose (x:[]) y = x (compose [] y) = x y
16:53:37 <GreyFaceNoSpace> yea
16:53:39 <GreyFaceNoSpace> just noticed
16:53:40 <shachaf> That's some serious technology you've got there.
16:53:41 <jle`> GreyFaceNoSpace: so the whole thing works if you eliminate the [x] case, since it's covered by the (x:xs) case
16:53:57 <shachaf> Maybe you should patent your definition of compose and collect licensing fees?
16:53:58 <ph88> does someone know where the code repo is of this package? http://hackage.haskell.org/package/hscolour-1.24.4 
16:54:27 <jle`> GreyFaceNoSpace: okay, note also that the implementations of foldr and fold all take the lists as the last argument, so maybe we can do that here to
16:54:33 <jle`> compose [] = \y -> y
16:54:43 <jle`> compose (x:xs) = \y -> x (compose xs y)
16:55:11 <jle`> and now that form looks a looooot like foldr
16:55:15 <jle`> @src foldr
16:55:15 <lambdabot> foldr f z []     = z
16:55:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:55:51 <jle`> see if you can pick 'f' and 'z' so that `foldr f z` gives you the same behavior
17:01:36 <GreyFaceNoSpace> compose' xs a = foldr (id) a (xs)
17:01:58 <iqubic> Does that work?
17:02:00 <GreyFaceNoSpace> it works
17:02:02 <GreyFaceNoSpace> but wtf
17:02:31 <iqubic> I'm not sure why that works.
17:02:33 <GreyFaceNoSpace> i was looking for a way to do nothing
17:02:37 <GreyFaceNoSpace> hence the id function
17:02:40 <iqubic> Sure.
17:03:01 <GreyFaceNoSpace> i guess
17:03:05 <GreyFaceNoSpace> this would work too
17:03:17 <iqubic> I have no idea why that works.
17:03:21 <GreyFaceNoSpace> compose xs a = foldr (\x -> x) a xs
17:03:41 <iqubic> Sure.
17:03:56 <iqubic> > compose [(+1), (*2), negate] 1
17:03:59 <lambdabot>  -1
17:04:53 <iqubic> @let compose' xs a = foldr (\x -> x) a xs
17:04:54 <lambdabot>  Defined.
17:05:05 <iqubic> > compose' [(+1), (*2), negate] 1
17:05:07 <lambdabot>  -1
17:05:44 <iqubic> > compose' [reverse, (++ "H")] "ello World!"
17:05:47 <lambdabot>  "H!dlroW olle"
17:06:05 <iqubic> > compose' [reverse, (++ "H"), reverse] "ello World!"
17:06:08 <lambdabot>  "Hello World!"
17:06:45 <iqubic> > compose' [reverse, (++ "H")] == compose [reverse, (++ "H")]
17:06:47 <lambdabot>  error:
17:06:47 <lambdabot>      ‚Ä¢ No instance for (Eq ([Char] -> [Char]))
17:06:47 <lambdabot>          arising from a use of ‚Äò==‚Äô
17:07:18 <iqubic> > compose' [reverse, (++ "H")] "ello World!" == compose [reverse, (++ "H")] "ello World!"
17:07:21 <lambdabot>  True
17:07:27 <iqubic> Oh. I see.
17:07:34 <iqubic> We do have the same function.
17:07:41 <GreyFaceNoSpace> yeah
17:07:57 <GreyFaceNoSpace> its just i implemented it in a very stupid way i think
17:08:12 <iqubic> I came up with a different way of writing the function. I also used a fold.
17:08:21 <GreyFaceNoSpace> show me please
17:08:50 <iqubic> compose xs a = foldr (.) id xs a
17:08:54 * hackage shwifty 0.0.1.0 - Generate swift types from haskell types.  https://hackage.haskell.org/package/shwifty-0.0.1.0 (chessai)
17:09:20 <GreyFaceNoSpace> yeah makes sense
17:09:45 <ph88> When i replace  Sink ByteString m ()  by  ConduitT (ByteString m ()) Void  from http://hackage.haskell.org/package/conduit-1.3.1.2/docs/Data-Conduit.html#t:Sink i get  Expecting two more arguments to `ConduitT (ByteString m ()) Void' Expected a type, but `ConduitT (ByteString m ()) Void' has kind `(* -> *) -> * -> *'    why can't i replace it like that ?
17:09:47 <iqubic> I have no idea how your function actually works.
17:10:12 <iqubic> You can. You just have an extra set of parenthesis.
17:10:48 <iqubic> type Sink i = ConduitT i Void
17:11:04 <iqubic> type Sink i m r = ConduitT i Void m r
17:12:00 <iqubic> Since you have Sink ByteString m () you'll need to replace it with ConduitT ByteString Void m ()
17:12:12 <ph88> oh i see
17:12:41 <ph88> thank you iqubic 
17:12:55 <iqubic> I'm literally just taking the type signature you have, and the type synonym that exists, and doing a direct substitution.
17:22:10 <ezzieyguywuf> is there a more succinct way to check if a list of Bool is all True other than `all id [True,True,False]`?
17:23:02 <MarcelineVQ> :t and -- slightly
17:23:04 <lambdabot> Foldable t => t Bool -> Bool
17:24:50 <ezzieyguywuf> *shrug* cool, just wondering if there was a prebuild `allTrue [True,True,False]`
17:25:19 <MarcelineVQ> yes it's called  and
17:26:28 <ezzieyguywuf> lol oh
17:26:37 <ezzieyguywuf> I misunderstood the type signature
17:26:41 <ezzieyguywuf> (I'm still learning this stuf...)
17:27:11 <ezzieyguywuf> sure enough, it's two up from "any" on hackage, I just didn't "get it" when I skimmed over it
17:27:42 <MarcelineVQ> I probably should have gave an example input instead of a comment
17:38:57 <koz_> @pl \s -> (name s, s)
17:38:57 <lambdabot> (,) =<< name
17:39:00 <koz_> Woah.
17:41:02 <MarcelineVQ> www
17:41:50 <iqubic> WHAT!?!?!
17:42:42 <koz_> iqubic: Chill, lol.
17:42:42 <MarcelineVQ> liftA2 (,) name id  if you want to be cute in another way
17:43:08 <iqubic> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-436
17:43:12 <koz_> MarcelineVQ: You mean (,) <$> name <*> id amirite? :P
17:43:38 <iqubic> Oh, that's using the Reader Monad
17:43:59 <iqubic> :t \f -> (,) =<< f
17:44:01 <lambdabot> (b -> a) -> b -> (a, b)
17:44:19 <iqubic> Or something. I don't understaand that.
17:49:32 <MarcelineVQ> koz_: id bugging me  first name . join (,)
17:50:51 <haskelllisp[m]> I rely on the `aws` package in my project, but the error messages are not printed out in the` aws` package. How do I modify the contents of the `aws` package?
17:52:24 <MarcelineVQ> koz_: wait, I've got it!
17:52:28 <MarcelineVQ> \s -> (name s, s)
17:55:29 <iqubic> :t join (,)
17:55:30 <lambdabot> b -> (b, b)
17:55:34 <iqubic> How?!?
17:56:06 <MarcelineVQ> (->) r  instance, like you suspected earlier, you can write the instance yourself to see how
17:56:30 <MarcelineVQ> That is to say it's instructive to do so
17:56:58 <iqubic> It's not using the ((,) a) instance?
17:57:34 <MarcelineVQ> it's not
17:57:55 <MarcelineVQ> :t (,)
17:57:56 <lambdabot> a -> b -> (a, b)
17:57:59 <MarcelineVQ> ->
17:58:10 <MarcelineVQ> :t join `asAppliedTo` (,)
17:58:11 <lambdabot> (b -> b -> (b, b)) -> b -> (b, b)
17:58:22 <iqubic> I see.
17:58:58 <iqubic> join f x = f x x -- right?
17:59:11 <iqubic> :t join
17:59:12 <lambdabot> Monad m => m (m a) -> m a
17:59:21 * slack1256 mindblown
17:59:32 <slack1256> dup is not redundant
17:59:36 <iqubic> Ah. So it's "join f = \x -> f x x" instead.
17:59:37 <slack1256> now*
18:03:24 <MarcelineVQ> "<iqubic> join f x = f x x -- right?" in fact there's no other way to write that join usefully, f needs two arguments and we only have one, so it must be used twice
18:04:37 <iqubic> Right. But then you have to do a little rewritting, because join only takes one argument.
18:05:16 <MarcelineVQ> you don't have to
18:05:33 <iqubic> Oh. Right. I guess not.
18:05:37 <MarcelineVQ> join f = \x -> f x x   is equivalent to   join f x = f x x
18:06:38 <iqubic> Yeah. I get that now.
18:06:43 <slack1256> > join (\a b c -> (a, b, c)) 'a' "animal"
18:06:45 <lambdabot>  ('a','a',"animal")
18:07:04 <slack1256> I guess this can be combined with pointfree notation to do some great spaguetti.
18:07:16 <iqubic> I wish that Haskell let us write Monads with either join or (>>=).
18:07:43 <slack1256> I teached a class on haskell and introduced monads that way
18:07:48 <slack1256> Made lots of sense.
18:07:52 <iqubic> taught.
18:07:58 <slack1256> Taught!
18:08:01 <slack1256> Thanks
18:08:28 <iqubic> Also, (join + return) is how category theorists view monads.
18:08:51 <AwoL[m]> Maybe not.
18:08:54 <AwoL[m]> Wroops, wrong window.....sorry.
18:09:07 <slack1256> Also join makes the "sequencing" clearer. You have to unwrap the out layer first to get the the inner one.
18:09:50 <slack1256> I guess today it's easier as every kid knows flatMap
18:10:49 <MarcelineVQ> ryan has a nice post on the topic https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/
18:13:19 <iqubic> flatMap is a shit name for (>>=)
18:16:01 <slack1256> iqubic: What about concatMap?
18:16:17 <koz_> Or mapCat as some folks would have it.
18:16:43 <iqubic> concatMap makes sense for lists only.
18:19:58 <nshepperd2> mapMeow
18:20:34 <slack1256> flatMap usually is only used on lists (or observables on swift).
18:20:57 <slack1256> You can see optionals as list of either 0 or 1 elements (I do).
18:35:45 * koz_ is disappointed that there's no insertWithM.
18:39:31 <iqubic> Me too.
18:39:40 <iqubic> I've wanted that before.
18:40:31 <MarcelineVQ> koz_: a very emmy M? there is an alterF 
18:41:41 <koz_> MarcelineVQ: alterF is actually excellent.
18:41:48 <koz_> (you can define insertWithM based on it)
18:42:29 <koz_> It only needs Functor even, sikk.
18:42:34 <koz_> (my draft needed Applicative)
18:42:56 <koz_> :t foldM
18:42:57 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
18:54:02 <amy_monnet> Hey everyone hope every ones doing well
18:54:17 <koz_> amy_monnet: Thanks!
18:54:25 <amy_monnet> I've got a questions about using Docker with Haskell
18:54:32 <koz_> amy_monnet: Ask away.
18:55:22 <amy_monnet> Currently building a web app using Docker, Stack (not using Docker under the hood, using docker to create our own images explicitly), and servant/servant-server
18:56:13 <amy_monnet> Is there any particular benefit between using the fpco/stack-build docker image over the official haskell image?
18:57:52 <amy_monnet> One thing I noticed is that when using the official haskell docker image is that it looks for a .cabal file even when a package.yaml file is present.
18:58:07 <amy_monnet> So the following breaks 
18:58:09 <amy_monnet> FROM haskell:8.6
19:01:00 <Axman6> what is "it" that breaks?
19:01:14 <amy_monnet> It is trying to look for a .cabal file that wouldn't be there
19:01:34 <iqubic> @undefine
19:01:34 <lambdabot> Undefined.
19:01:37 <amy_monnet> One thing to point out is that the stack version in the official image is 1.93
19:01:47 <amy_monnet> whilst in the fpco image its 2.something
19:02:19 <ezzieyguywuf> does the syntax for a typeclass definition shown here require the MultiParamTypeClasses extnension? https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/type-class-extensions.html I don't see `{-# LANGUAGE MultiParamTypeClasses #-} in the source https://hackage.haskell.org/package/hgeometry-combinatorial-0.10.0.0/docs/src/Data.Intersection.html#IsIntersectableWith
19:03:13 <amy_monnet> is hpack in stack only something in version 2 and above?
19:04:34 <Axman6> ezzieyguywuf: look at default-extensions in https://hackage.haskell.org/package/hgeometry-combinatorial-0.10.0.0/hgeometry-combinatorial.cabal - this exactly the reason why most people recommend against using default-extensions
19:05:44 <ezzieyguywuf> Axman6: ah hah! did not know about that cabal option. and yes, I can see why it is recommended not to use it. very confusing!
19:06:10 <ph88> does someone know where the code repo is of this package? http://hackage.haskell.org/package/hscolour-1.24.4 
19:06:45 <Axman6> darcs get http://code.haskell.org/~malcolm/hscolour
19:07:30 <ezzieyguywuf> dead link
19:07:48 <Axman6> also looks like a relatively dead package too
19:08:18 <Clint> still has revdeps
19:12:01 <ezzieyguywuf> dang, is it just me or is hoogle down?
19:12:25 <ezzieyguywuf> https://hoogle.haskell.org/
19:12:32 <ezzieyguywuf> https://www.isitdownrightnow.com/hoogle.haskell.org.html
19:12:35 <ezzieyguywuf> dang, it's not just me
19:13:38 <iqubic> It was working for me just this morning.
19:14:01 <ezzieyguywuf> it was working like 10 min ago
19:49:09 <iqubic> Hoogle is back up.
19:50:01 <suzu> yay
19:53:29 <dmj`> I never use hoogle (><)
19:57:07 <sm[m]> amy_monnet: not sure, stack ‚Äîversion should show if it‚Äôs built in. Hope you‚Äôre not using an old stack though
20:18:13 <guest88> I've just used elemIndex 4 [1,2,2,4] to give me the index 3, but it returns an expression of type 'Just'. I'm not sure how to interpret this. I wanted to use this index but i get an error  Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòMaybe Int‚Äô
20:19:03 <Axman6> :t elemIndex
20:19:04 <lambdabot> Eq a => a -> [a] -> Maybe Int
20:19:09 <Axman6> @src Maybe
20:19:09 <lambdabot> data Maybe a = Nothing | Just a
20:19:50 <guest88> yeah I get a Maybe Int back
20:19:56 <guest88> but I just want an Int
20:20:19 <Axman6> let terribleElemIndex :: Eq a => a -> [a] -> Int; terribleElemIndex a xs = case elemIndex a xs of Nothing -> error "booo"; Just i -> i
20:20:33 <Axman6> what Int should you get back if the element isn't there?
20:20:51 <guest88> okay I see what you are saying
20:20:56 <monochrom> It uses Maybe because in case of elemIndex 3 [1,2,2,4] there is no correct answer other than Nothing.
20:21:12 <guest88> what's the appropriate way to use a returned value if it's a maybe?
20:21:40 <monochrom> Depends on what you use it for and what happens if you run into elemIndex 3 [1,2,2,4].
20:21:57 <guest88> I want to reference the element say we go index = elemIndex 4 [1,2,2,4] and we get "Maybe 3". I want to grab [1,2,2,4] !! index
20:22:05 <monochrom> But 90% of the use cases you just use patten matching.
20:22:09 <Axman6> -1 is a bad answer, since negatice indices don't make sense, maxBound is also a terrible answer because usually the list won't be that long - there is _no_ sensible Int to return, which is why we use MaybeInt, for the case where there is no valid index
20:22:33 <monochrom> What? Then why not find?
20:23:15 <Axman6> you need to handle the Maybe using something like a case statement - you're performing a computation which might fail, so you need to handle the failure case as well as the success. what should your cod edo when the element isn't present in the list?
20:23:35 <Axman6> yeah definitely sounds like you want find
20:23:37 <Axman6> :t find
20:23:39 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
20:23:52 <monochrom> Even elem to just tell you True and False, because you already have the candidate element.
20:23:55 <guest88> yeah okay, completely get the just / maybe framework
20:24:10 <guest88> find is what i want!
20:28:35 <jle`> sentinel values are great until you run the code
20:28:38 <guest88> how do i interpret what input is required to pass into the 'find' function?
20:28:46 <guest88> when i type :t find
20:28:58 <jle`> find expects a predicate to test each item, and then the list of items
20:28:59 <guest88> It's quite hard to interpret what it would like
20:29:02 <jle`> > find even [1..10]
20:29:03 <lambdabot>  Just 2
20:29:09 <guest88> ohhh!
20:29:10 <jle`> here `even :: Int -> Bool`
20:29:15 <jle`> and [1..10] :: [Int]
20:29:30 <jle`> so if you have a list of a's, then it takes an (a -> Bool) function
20:29:45 <jle`> so if you have a list of Chars, it takes a (Char -> Bool) function
20:29:52 <jle`> > find isUpper "hello World"
20:29:54 <lambdabot>  Just 'W'
20:31:00 <jle`> > find (\str -> length str > 3) ["hi", "bye", "hello", "goodbye"]
20:31:00 <lambdabot>  Just "hello"
20:31:31 <guest88> is there any other similar function that finds all occurences rather than just the leftmost element
20:33:58 <amy_monnet> sm[m] tried it again and it works now. Not sure what happened last time..
20:34:18 <Axman6> filter?
20:34:52 <Axman6> > filter (\str -> length str > 3) ["hi", "bye", "hello", "goodbye"] 
20:34:55 <lambdabot>  ["hello","goodbye"]
20:40:59 <d34df00d> How would removing an instance that never gets used affect performance of the compiled code?
20:41:06 <d34df00d> I'm back at debugging yesterday's stuff.
20:41:22 <d34df00d> I'm removing an instance that's never used and performance drops about 15%.
20:41:46 <d34df00d> Damn, I can't even post a good question here or on SO cause I cannot come up with a reasonable minimal reproducing example.
20:42:29 <suzu> if it truly never gets used
20:42:39 <suzu> then it won't make a difference on the runtime
20:42:46 <suzu> but it could on the compile-time
20:42:47 <d34df00d> Yeah, it doesn't.
20:42:56 <d34df00d> I guess the compiler fails to inline something for some reason.
20:42:58 <d34df00d> But I don't see why.
20:43:45 <MarcelineVQ> fwiw a git repo can be enough here, it's more important that you have something someone can try than just that it's minimal
20:46:10 <d34df00d> Ok, this is the repo, branch `modularize`: https://github.com/0xd34df00d/hwc/tree/modularize
20:46:39 <d34df00d> There's a commented function https://github.com/0xd34df00d/hwc/blob/modularize/src/Data/WordCount.hs#L73-L81 that's 25% faster than the uncommented one, although I'd expect their performance to be exactly the same.
20:47:10 <d34df00d> Just feed it with some large textual file. I used http://eforexcel.com/wp/wp-content/uploads/2017/07/1500000%20Sales%20Records.zip this file concatenated with itself 10 times.
20:48:01 <d34df00d> Moreover, if you replace the definition of the commented function with this, it also becomes slower:
20:48:03 <d34df00d> wc s = extractState $! (\(ByteOnlyComputer step') -> BS.foldl' step' (initState :: StateOf 'Words) s) (ByteOnlyComputer step)
20:48:08 <d34df00d> So there's something with GADTs, yeah.
20:53:15 <MarcelineVQ> uh, what instance are you removing?
20:53:26 <d34df00d> The one for 'Lines.
20:54:07 <d34df00d> So if you comment the current implementation of `wc` and uncomment the other one, and then compare its performance against that very same code compiled without the instance for 'Lines, it's gonna be a tad slower.
20:54:38 <d34df00d> But it's probably a red herring. I'm ultimately interested in making the currently uncommented version as fast as the commented one.
20:54:51 <d34df00d> Why solve the problem of making a MRE if we can solve the original problem? :)
20:54:55 <d34df00d> And thanks for taking a look!
21:00:37 <MarcelineVQ> How are you testing/timing this?
21:02:07 <d34df00d> Just `stack build` and then `stack exec -- hwc-exe /path/to/big/file.txt +RTS -sstderr` and looking at the RTS dump.
21:02:19 <d34df00d> The file should preferably be on tmpfs or something similar to avoid any IO stuff.
21:02:50 <d34df00d> The file should be big otherwise the noise is too high. I'd be happy to put out a file somewhere but it is, well, big.
21:10:59 <hololeap> anyone know what algorithm haskell uses internally for float exponents?
21:18:43 <MarcelineVQ> d34df00d: hmm, on a sufficiently large (randomly generated) file I see no difference in performance at all when removing the instance, and the commented wc is only 6-7% faster
21:19:09 <d34df00d> MarcelineVQ: interesting. It's 1.2 secs vs 1.55 secs between the commented and uncommented ones on my machine with 1.8 gig file.
21:19:57 <d34df00d> MarcelineVQ: you're building with stack and/or with the same compiler and options? That is, ghc 8.8.2, -O2, -fllvm?
21:20:59 <MarcelineVQ> cabal, ghc 8.6.5, whatever options your package.yaml set
21:21:20 <guest88> How do i use a "Just" value in my next calculation?
21:21:21 <d34df00d> Hmm, the only difference is ghc version.
21:21:55 <MarcelineVQ> d34df00d: we might have different llvm versions as well
21:22:01 <d34df00d> 9.0.1 in my case.
21:22:05 <MarcelineVQ> same
21:24:19 <d34df00d> Just tried reproducing on a different machine ‚Äî that's 1.16 secs vs 0.98 secs on average.
21:24:25 <d34df00d> Interesting.
21:24:34 <d34df00d> Let me try with ghc 8.6 to see if it persists.
21:26:19 <d34df00d> Yeah, can reproduce on 8.6.
21:26:48 <d34df00d> I literally just commented the current wc and uncommented the other one, as well as removed the type application in Main, and I definitely see a difference.
21:27:54 <MarcelineVQ> d34df00d: running your hwc on the file seems to be caching the result somehow here, so my results are useless it seems like, it takes much longer on a fresh file but barely any run once or twice more
21:28:29 <d34df00d> MarcelineVQ: yeah, I think the OS does caching! I had to do this on a file on a ramdisk to get stable results.
21:30:45 <d34df00d> No, this stuff is ridiculous. I rewrote the code to avoid GADTs and hopefully make it more clear to the compiler, adding this:
21:31:07 <d34df00d> https://bpaste.net/OQGQ
21:31:32 <monochrom> guest88: Depends on what you will do if you receive "Nothing"?  Because then you just use pattern matching for both.
21:31:34 <d34df00d> This works as fast as the other function. But, if I eta-reduce the equations for `run` in the instances, it gets slow.
21:32:37 <d34df00d> (‚îõ‡≤†_‡≤†)‚îõÂΩ°‚îª‚îÅ‚îª
21:34:09 <MarcelineVQ> odd that shouldn't be a CAF or anything, presence/absence of eta can affect the monorphism restriction but this has an explicit signatue already :/
21:35:08 <d34df00d> And if I un-eta-reduce `wc` (writing wc s = extractState $ run s), it also gets slow.
21:35:20 <d34df00d> I don't know anything at all anymore.
21:35:40 <nshepperd2> eta reduction can also affect inlining
21:36:39 <d34df00d> But then even if I manage to achieve reasonable performance here, what guarantees are there that subsequent compiler versions wouldn't have different inliner logic, thus breaking all of these microoptimizations?
21:36:52 <monochrom> First-order approximation: The compiler computes an MD5 hash of you code, then selects an optimization level based on the last digit of the hash. :)
21:37:10 <nshepperd2> iirc only saturated calls are inlined
21:37:11 <d34df00d> And I wouldn't call it optimizations really at all, it's just hacking to make it fit a specific version
21:37:53 <Axman6> monochrom: which means Haskell is vulnerable to length extension attacks
21:38:36 <monochrom> It's an eta reduction attack and an instance omission attack.
21:38:50 <Axman6> "I made my code much faster by adding 'where a7s882374hnj87nf87 = a7s882374hnj87nf87' to the end of it"
21:39:01 <nshepperd2> it's an art attack...
21:39:06 <d34df00d> Come on folks.
21:39:12 <Axman6> Man I miss Art Attack
21:39:46 <nshepperd2> staple of my childhood
21:40:20 <guest88> monochrom: how do I handle pattern matching? I've made a little example trying to do it:
21:40:26 <guest88> findEvens [a] = find even [a]
21:40:34 <guest88> findEvens Nothing = "nothing here"
21:40:43 <monochrom> Where is the "Just"?
21:40:46 <guest88> do I need to specify something for all Nothing values?
21:40:56 <guest88> not sure how to make it work
21:41:09 <monochrom> Learn pattern matching properly.
21:41:17 <monochrom> Every book has it.
21:41:59 <monochrom> Most books put it under "algebraic data types".
21:42:37 <Axman6> pattern matching is Haskell 101, you need to know this
21:47:12 <guest88> pattern matching is for level 99 wizards holy sh*t
21:47:28 <monochrom> Are you trolling us?
21:47:47 <guest88> nope, i genuinely just learned about it
21:47:54 <int-e> level inflation
21:48:11 <monochrom> Then stop exaggerating.
21:48:38 <monochrom> New concept yes, hardly deep or profound or difficult.
21:49:19 <d34df00d> Dependent pattern matching is for 99 lvl wizs.
21:49:46 <MarcelineVQ> hey now, people are allowed to be excited :>
21:49:58 <MarcelineVQ> it's fairly profound the first time
21:50:00 <d34df00d> (do wizard levels form a hierarchy of universes?)
21:50:24 <monochrom> Haha, Wizard :: Wizard
21:50:29 <guest88> I think exaggeration is hardly objective
21:50:34 <d34df00d> Inconsistent wizardry.
21:51:03 <monochrom> Or just bad notation for Wizard_n :: Wizard_n+1
21:53:02 <guest88> is 'case' just another way of specifying pattern matching?
21:53:09 <monochrom> Yes.
21:54:44 <guest88> its just a way of specifying it in the function definition where the 'maybe' type is being used?
21:55:17 <monochrom> I don't understand the question.
21:57:50 <jle`> > case find even [1..10] of Just i -> "found " ++ show i; Nothing -> "nope, nothing"
21:57:52 <lambdabot>  "found 2"
21:58:15 <jle`> > case find even [1,3,5,7] of Just i -> "found " ++ show i; Nothing -> "nope, nothing"
21:58:17 <lambdabot>  "nope, nothing"
22:01:24 * hackage envy-extensible 0.2.0.1 - Provides FromEnv in envy instance for Record of extensible.  https://hackage.haskell.org/package/envy-extensible-0.2.0.1 (igrep)
22:15:41 <guest88> jle` is there any way to use case to return the value? your example was to print it
22:15:54 <jle`> i returned a string
22:16:00 <jle`> > :t case find even [1,3,5,7] of Just i -> "found " ++ show i; Nothing -> "nope, nothing"
22:16:02 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
22:16:06 <jle`> :t case find even [1,3,5,7] of Just i -> "found " ++ show i; Nothing -> "nope, nothing"
22:16:08 <lambdabot> [Char]
22:16:09 <jle`> ^ guest88 
22:16:12 <jle`> you can return anything you want
22:16:29 <jle`> :t case find even [1,3,5,7] of Just i -> i * 100000; Nothing -> 8952738945
22:16:30 <lambdabot> Integral p => p
22:16:34 <jle`> > case find even [1,3,5,7] of Just i -> i * 100000; Nothing -> 8952738945
22:16:36 <lambdabot>  8952738945
22:16:45 <jle`> > case find even [1..10] of Just i -> i * 100000; Nothing -> 8952738945
22:16:47 <lambdabot>  200000
22:17:03 <guest88> ohhh okay
22:17:05 <jle`> but yeah, my example didn't print anything, my example just returned a stirng
22:17:30 <jle`> just like the second example just returns an Int
22:17:40 <guest88> case find even [1,3,5,7] of Just i -> i; Nothing -> "no evens"
22:17:44 <guest88> how come this doesn't work
22:18:24 <Axman6> the types don't match
22:18:39 <Axman6> what is the type of i? what is the type of "no events"?
22:19:02 <jle`> guest88: remember that what you just gave is an *expression*
22:19:12 <jle`> it has to have a type
22:19:24 <jle`> it's not printing anything, it's basically the thing *is* the result
22:19:28 <guest88> Oh right, the types of each case needs to be the same
22:21:54 <guest88> To me its intuitive to print some message when Nothing comes up, and printing the actual value when the value comes up is intuitive
22:22:14 <guest88> so intuitive i wrote it twice
22:23:40 <guest88> I think i need to call error and then throw a message up
22:23:48 <guest88> then there's no return type conflict
22:24:08 <Axman6> we don't do that around 'ere :P
22:24:54 <guest88> >case find even [1,3,5,7] of Just i -> i; Nothing -> error "there's no even number here"
22:25:24 <guest88> Is that not an appropriate way to deal with these kinds of issues?
22:25:26 <Axman6> yeah we don't do that
22:25:41 <guest88> well hot diggity
22:26:18 <Axman6> no, not at all - exceptions come from _exceptional_ circumstances - your network connection was unexpectedly disconnected, your printer is on fire etc. looking for a value in a list and not finding it is completely predictable, and the types tell us that
22:27:01 <jle`> guest88: i guess i would shift your thinking to "what do i want to do?" to "what do i have"
22:27:43 <jle`> if the program is meant to irrecovably fail then error isn't too bad really, but really more importantly think about what you want to do with the result of 'find'
22:27:55 <jle`> guest88: so, what do you want to use 'find' to do?
22:28:00 <jle`> guest88: the answer will guide you in how to use a Nothing
22:28:17 <jle`> it's not "what to do", it's what you "have" as the result of finding something
22:28:31 <shachaf> Network connections being disconnected isn't predictable?
22:31:28 <guest88> jle` you're right. If there's no evens, then I should return 0. But this is a dummy example so I need to apply that line of thinking to my real problem. you have been upgraded to a level 99.5 wizard, thanks.
22:31:53 <jle`> guest88: yeah what you 'should' do depends on what you want to do with the result of 'find' in the first place
22:32:21 <Axman6> jle` is already a level 9000 wizard
22:33:44 <d34df00d> I wonder if it's normal that I sorta understand dependent types metatheory and can have fun programming in idris, but all this singletonized haskell stuff makes me cringe?
22:33:53 <jle`> it all sort of loops around after a while, jeremy bearimy style
22:34:13 <jle`> d34df00d: a big part of it probably is that haskell works against you when trying to do dependent types stuff
22:34:16 <jle`> instead of working with you
22:34:37 <d34df00d> Yep.
22:34:38 <jle`> so similar to, say, trying to write good functional code in python or C
22:34:45 <d34df00d> "against you" is an excellent choice of words.
22:34:58 <jle`> it's not like it's not possible, it's just the language doesn't do you any favors, and sometimes tries its best to stop you
22:35:03 <jle`> or make life as difficult as possible
22:35:26 <jle`> some languages are more suited to certain styles of programming/expression than others
22:58:25 <guest88> can ya handle multiple occurences in case?
22:59:09 <guest88> Like if im checking for occurences of a letter, I dont care if its uppcase or lower case
22:59:44 <Rembane> guest88: case c of 'a' -> ...; 'A' -> ...; Or you can lower it first. 
22:59:59 <guest88> like case 'a' of 'A',a' -> print "blah"
23:00:22 <yushyin> we don't have or-patterns
23:00:36 <jle`> case toLower c of 'a' -> ...
23:00:46 <jle`> but if you just want to check if something is in a group, you can use `elem`
23:00:58 <jle`> > 'c' `elem` "hello"
23:01:00 <lambdabot>  False
23:01:01 <jle`> > 'c' `elem` "hellocoptor"
23:01:03 <lambdabot>  True
23:01:31 <jle`> so, if c `elem` "Aa" then ... else ...
23:01:35 <guest88> so i can say case c of c `elem` ['A',a'] -> print "blah"
23:01:51 <jle`> you'd use guards or if/then/else, not casing ont he result
23:02:02 <jle`> remember you case match with patterns, not bools
23:02:18 <jle`> a nice way to write this cleanly would be something like multi-way if
23:02:28 <jle`> if | c `elem` "AaBb" -> ...
23:02:35 <jle`>    | c `elem` "CcDd" -> ....
23:02:47 <jle`> which is sugar for case and guards, pretty much
23:55:20 <Jophish__> Hi all
23:55:34 <Jophish__> I'm trying to coerce singletons into 
23:56:48 <Jophish__> - doing something it probably wasn't designed for. I'm trying to get it to generate a type family as well as its singleton, but the singleton version depends on a hand written member function
23:57:03 <Jophish__> This might explain best:  https://gist.github.com/expipiplus1/be532d5db19728528429f7cdd73725d1
