00:17:12 * hackage fuzzy-parse 0.1.2.0 - Tools for processing unstructured text data  https://hackage.haskell.org/package/fuzzy-parse-0.1.2.0 (voidlizard)
00:17:47 <shafox> jackdk, thanks. was looking for personal projects usage. 
00:18:39 <jackdk> I like my personal style more than any autoformatter that I've tried, but I appreciate not having to argue formatting with colleagues. So you can wire ormolu in as a before-save-hook, but I have it set to `C-c C-f`
00:30:12 <dminuoso> I like stylish haskell configured to only format imports, pragmas and align things like function bindings/case-of. :)
00:30:41 <dminuoso> The rest I rather control myself, but those are boilerplatey and best left to such a tool.
00:30:57 <dminuoso> It depends on whether its a solo project as well.
00:31:06 <dminuoso> Once you start collaborating, auto formatting tools become an annoyance
00:32:29 <typetetris> dminuoso: Auto formatting tools have been extremly valuable in teams I worked with. Everybody just configured it to run on save and we had a git commit hook. Nobody wanted it gone and all the talk about how to layout/format stuff just went away.
00:34:21 <dminuoso> The problem with Haskell is that its whitespace sensitive, so a large variety of formatting tools can actually change the meaning of code or straight up break it.
00:35:54 <typetetris> dminuoso: True. Never experienced it myself with ormolu (using it since 0.1.2.0).
00:36:44 <dmj`> In teams people have their own style, Haskell isn't a good language to hold to strong aesthetic, maybe if you were writing go or java, but there's just a million ways to express the same thing in Haskell. Formatters are nice for dealing with deeply nested lists though, since that's annoying.
00:37:56 <dminuoso> But if it works for you, that's great. Tell your success story.
00:39:09 <dmj`> Haskell is the best language in the world for bikeshedding
00:39:51 <dmj`> style formatters really can't solve that problem either
00:45:11 <Uniaika> o/
00:51:31 <dmj`> Uniaika: \o
01:02:12 * hackage connections 0.1.0 - Orders, Galois connections, and lattices.  https://hackage.haskell.org/package/connections-0.1.0 (cmk)
01:10:59 <Uniaika> heya dmj` :)
01:11:04 <Uniaika> how are you faring?
01:11:16 <dmj`> Uniaika: can't complain, how about yourself
01:11:48 <Uniaika> sunny morning here, might actually have a decent day
01:12:35 <dmj`> Uniaika: that's great, supposed to be rainy most of the week though :( 
01:17:11 <Uniaika> ah, that sucks
01:17:16 <Uniaika> dmj`: where do you live?
01:17:30 <dmj`> Uniaika: I meant in NL, I'm in NYC rn
01:18:12 <Uniaika> two places that are pretty far apart :D
01:24:55 <dmj`> Uniaika: just over the pond, not too bad :)
01:25:30 <Uniaika> hahaha
01:26:12 <bewakes> Hi all, I am on a stack project with resolver lts-16.4. I can't import `Data.Numeric`, should not it be available in the base package? The package.yaml has `base >= 4.7 && < 5`.
01:26:54 <MarcelineVQ> it's just called Numeric
01:27:11 <Uniaika> yeah this one isn't under the Data. namespace
01:27:11 <MarcelineVQ> idk why
01:27:41 <bewakes> MarcelineVQ: thanks!!
01:28:02 <bewakes> very weird though, I spent about half an hour figuring this out and googling.
01:29:11 <MarcelineVQ> you can see what base has here http://hackage.haskell.org/package/base
01:30:10 <shafox> I cannot install implicit-hie package via cabal. Getting error: goals I've had most trouble fulfilling: implicit-hie. I have ran, cabal update as well. 
01:30:54 <shafox> Sorry for the noise. It worked. 
02:12:12 * hackage hsinspect-lsp 0.0.4 - LSP interface over the hsinspect binary.  https://hackage.haskell.org/package/hsinspect-lsp-0.0.4 (tseenshe)
02:18:28 <Bish> whats the "right" way to indent when having multiple if statements
02:19:11 <yushyin> switching to multiwayif :D
02:21:44 <Bish> but i am not using it on the same "variable"
02:21:56 <Bish> don't think that really helps
02:22:10 <Bish> it's not that my value can have many possible values that i want to check
02:23:41 <Bish> rather that i want to check another variable inside the else case or then whatver
02:24:08 <fendor> Bish, something like guards could be helpful. MultiWayIf is a convenient way to have some guards 
02:24:32 <fendor> otherwise, define a function with nice name for it. Then you can have guards as well
02:25:34 <fendor> or, in my opinion not very pretty alternative: `case () of _ | x == 3 -> print "Found"`
02:25:48 <MarcelineVQ> he's asking how one might prefer to write nested ifs
02:26:09 <fendor> ah, I see
02:26:24 <fendor> misread twice, sorry
02:28:12 * hackage futhark 0.16.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.16.1 (TroelsHenriksen)
02:31:17 <MarcelineVQ> for me it depends how they happen to fit where I'm writing them and I don't happen to have a hard rule on it
02:31:39 <MarcelineVQ> other than I tend to give then and else the same indentation
02:34:16 <Bish> http://dpaste.com/03R8130
02:34:19 <Bish> this would be my example
02:38:41 <MarcelineVQ> Bish: seems fine, I might kill some of that indentation thus http://dpaste.com/2M8PPMF
02:39:22 <MarcelineVQ> or even move the = down with the if which I meant to do there
02:39:49 <Bish> hm okay!
02:40:55 <MarcelineVQ> that's just a style choice, doesn't really affect anything
02:41:58 <Bish> yeah i figured, but my vim plugin does weird stuff when i let it run over it
02:42:21 <Bish> so the developer that wrote that thingie had something different in mind
02:44:58 <Guest95> Hi all! Does any body know how to define a local package (from a parent directory) in a cabal file? I currently try "packages: ../localPackage" but it does not work. Thank you :)
02:45:25 <Guest95> I read this in https://cabal.readthedocs.io/en/latest/cabal-project.html#specifying-the-local-packages
02:46:47 <merijn> Guest95: That's talking about cabal.project files, not .cabal files
02:47:09 <Guest95> Ohh okay what is the difference?
02:47:38 <Guest95> Is there a way to specify local packages in a .cabal file?
02:48:01 <merijn> Guest95: "foo.cabal" defines/specifies the package "foo" and how to build it, cabal.project specifies how to build a local (set) of packages
02:48:04 <merijn> Guest95: No
02:50:16 <Guest95> And what can I do, if my package foo depends on a local package foo1 which is in the parent directory of foo?
02:50:26 <Guest95> merijn: already thank you!
02:52:18 <merijn> Guest95: .cabal packages specify a package "in the abstract", you can't depend on "local" packages, because there's no real notion of "where a package comes from" in the .cabal format
02:53:10 <merijn> Guest95: cabal.project is a file for configuring/specifying the specific build setup, allowing you to override the defaults such as "where does a package come from?" to point to local packages, git commits, etc.
02:54:16 <Guest95> So I could specify my local package in a cabal.project file?
02:55:23 <Guest95> or do I completely mix up these things?
02:57:59 <merijn> Guest95: You specify your package using the .cabal file and you just write "build-depends: foo" to depend on your package foo. Then you make a cabal.project with "packages: ../../foo/foo.cabal" to point your package to the local directory that has your foo package
02:59:40 <Guest95> Okay, thank you very much. I will try that!
03:08:27 <xsperry> hi. why is line not in scope in the second catch block? https://pastebin.com/LmfJRMuR
03:09:44 <Cale> xsperry: The `catch` is taking the entire first do-block as an argument
03:10:06 <xsperry> yes, that's what I want
03:10:19 <Cale> line is defined *inside* that do-block
03:10:27 <xsperry> oh, *first* do block
03:12:06 <xsperry> adding space before `catch` made it work
03:14:13 <xsperry> it looks a bit weird, though. maybe I shouldn't use infix catch. https://pastebin.com/V3bX3YZc
03:15:38 <Cale> What even goes wrong during the putStrLn?
03:16:06 <xsperry> nothing, it was a test case to show compilation error
03:16:34 <Cale> It often makes more sense to use handle rather than catch
03:16:46 <Cale> if you have a separate handler like that especially
03:19:03 <xsperry> handle handleError $ do
03:19:15 <xsperry> that looks nicer
03:35:12 * hackage shake-plus 0.2.0.1 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.2.0.1 (locallycompact)
03:51:04 <monaaraj> Hi, I'm a haskell begineer and I learned from learnyouahaskell, but I'm still confused about function composition with (.) and ($), sorry if this is an idiotic question :).
03:52:43 <Entroacceptor> :t (.)
03:52:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:52:48 <Entroacceptor> :t ($)
03:52:49 <lambdabot> (a -> b) -> a -> b
03:54:00 <dmj`> monaaraj: what part do you find most confusing
03:54:24 <dmj`> monaaraj: like what is the difference, or when to use one or the other
03:54:44 <monaaraj> kind of how to stitch together the arguments of the functions using the point-free style is pretty difficult for me
03:54:55 <koz_> monaaraj: There isn't any need to pointfree.
03:55:08 <koz_> If you prefer to explicitly bracket everything and pass all arguments, this is 100% fine.
03:55:16 <monaaraj> Ah, I sse
03:55:23 <monaaraj> Thank you so much 
03:56:52 <maerwald> pointfree is a performance optimisation. Rule of thumb is: use it for function definitions, but not as partial application arguments to eg fmap
03:57:56 <maerwald> `fmap (\x -> some x)` is better than `fmap some`, at least possibly
03:58:33 <ski> monaaraj : i normally prefer using either brackets, or `.', to `$'. e.g. `(foo . bar x y . baz z) (blah bleh)' or just `foo (bar x y (baz z (blah bleh)))'
03:58:40 <merijn> That sounds like a terrible rule of thumb
03:58:57 <maerwald> merijn: if you want stuff to inline it is correct
03:59:17 <merijn> The rule of thumb is: "Don't think about it until you 1) know compilation details of GHC enough to understand why you're doing this and 2) have profiled to determine whether it matters"
03:59:17 <monaaraj> Hmmm, I see
03:59:36 <monaaraj> Thank you! I'll remember that
03:59:50 <merijn> maerwald: Telling this sorta thing to beginners is one of the most unhelpful things you could possibly do, since they have 0 frame of reference to understand why you might even say that
04:00:06 <ski> (please don't write like `frob (foo $ bar x y $ baz z $ blah bleh)')
04:02:30 <maerwald> merijn: you missed the part where I said it's a performance optimisation
04:04:00 <maerwald> as in: caring about pointfree vs non-pointfree is only relevant for performance
04:04:19 <ski> how about readability ?
04:04:31 <maerwald> ski: that's personal
04:04:36 <ski> yes
04:04:37 <merijn> maerwald: But why would you say that to someone who just started learning and doesn't even have the difference between (.) and ($) internalised?
04:05:04 <maerwald> merijn: would you rather have me lie?
04:05:15 <merijn> maerwald: No, I'd rather you not mention it at all
04:05:18 <ski> (but i still care about my personal taste of aesthetics. i don't see why you'd say it wouldn't be relevant)
04:05:27 <maerwald> merijn: well, I disagree
04:05:27 <merijn> maerwald: And also yes
04:05:37 <merijn> Lying has great educational value
04:05:48 <maerwald> I disagree on that too
04:06:01 <maerwald> But education is too complex to debate
04:06:56 <merijn> You don't tell people about things they don't need nor understand until they reach a point where they need to know it or have context to place that knowledge. Else you're, at best, planting useless trivia in their brain, or at worst, causing them to write bad code for years because someone once told them "this was faster"
04:07:14 <MarcelineVQ> tipping the scale slightly: sometimes adding more arguments has a performance improvement since you avoid closure allocation to capture names you're referring to
04:07:21 <maerwald> I always had huge problems with breadth first approach
04:07:39 <merijn> That's how you end up with PR making all your foreign imports "unsafe", because a blogpost said it was faster
04:07:49 <MarcelineVQ> I'm all for not mentioning any of that to someone saying ". confuses me"
04:08:22 <merijn> Performance considerations at that level of detail need a nuanced understanding of both Haskell *and* how GHC compiles it, it's really not a topic that helps beginners
04:08:58 <maerwald> Again, I disagree
04:09:54 <merijn> maerwald: I've been writing Haskell for a decade, I understand enough of GHCs compilation to understand your argument and it still hasn't come up more than once in my entire Haskell carreer
04:11:42 <maerwald> yes, depends on the software you write, but it's important to understand that both representations are not fully isomorphic, before ppl start applying hlint suggestions blindly 
04:12:35 <maerwald> and it comes up often enough that it is written down in https://github.com/quchen/articles/blob/master/fbut.md
04:13:01 <merijn> I think the importance of that is marginal, and most relevant when people start looking into "how do I make things faster?" not when they're figuring out how to write syntactically correct code
04:13:23 <maerwald> It's a useful footnote
04:13:45 <merijn> You didn't provide it as a footnote, though. You provided it as a generalised rule
04:14:00 <maerwald> no
04:17:55 <dminuoso> I'd never consider "XYZ optimizes a bit better" a good reason for XYZ as a general rule of thumb. Expressivity should be important for beginners.
04:18:15 <dminuoso> Not only are most users not even concerned with writing high performance code, it's not even remotely in the scope of beginners. 
04:18:54 <dminuoso> And if it is, its because they are implementing a program poorly, leading them back to us "how can I make this program go faster" - that's where discussions about "Use XYZ because it optimizes better" fits.
04:20:59 <dminuoso> And indeed, lying is really important to beginners, because it helps them keep on track whats in front of them.
04:21:18 <dminuoso> Of course an experienced user might think "well this subtlety is important", but its only important because you can juggle it in your head.
04:35:47 <boxscape> Is there any significant advantage in having types not derive Show when compiling for production?
04:36:39 <boxscape> It feels kind of weird to leave it when you don't explicitly need it for anything but at the same time I suppoes there's probably not anything wrong with it?
04:37:02 <merijn> Slightly faster compilation? ;)
04:37:36 <boxscape> right, hence "significant" :) I'm guessing the difference in compilation speed isn't really noticeable, though, for all I know I might be wrong
05:04:42 * hackage Aoide 0.1.0.0 - A simple music library with the capability of generating .ly and .mid files.  https://hackage.haskell.org/package/Aoide-0.1.0.0 (Liisi_Kerik)
05:12:13 * hackage containers-unicode-symbols 0.3.1.2 - Unicode alternatives for common functions and operators  https://hackage.haskell.org/package/containers-unicode-symbols-0.3.1.2 (RoelVanDijk)
05:17:29 <zibad> hello, can anyone confirm if this HashTable is threadsafe? (Can concurrent threads update the key/values) - https://hackage.haskell.org/package/hashtables-1.2.3.4/docs/Data-HashTable-IO.html
05:24:22 <Uniaika> zibad: I have no answer but "shoot an email to the authors"
05:38:01 <zibad> Uniaika: thank you!
05:52:32 <watanabe> hello :)  I've made it to page 411 of Haskell from First Principles, and plan on finishing the book. I got an email the other day about James Bowen's Haskell video courses (Practical Haskell and Haskell from Scratch) being on sale and I'm wondering if anyone has any recommendations for/against either or both of these courses. I feel like they may
05:52:32 <watanabe> help supplement my learning as I've done a few programming Udemy courses for Python/Flutter and they've helped me grasp and clarify topics I either didn't understand or incorrectly understood...
05:54:13 * ski hasn't seen either of them
05:54:26 <ski> perhaps you could have some use of
05:54:36 <ski> @where CIS194
05:54:36 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
05:54:39 <ski> though ?
05:58:53 <watanabe> Thanks, I'm sort of interested in having some video/audio resources to supplement the reading I'm doing. Last week I came across Tsoding's youtube channel and it helped me in ways my several years of on and off again self-directed study of haskell haven't been able to achieve
06:01:29 <solonarv> zibad: a quick look through the source tells me none of the hash tables (there are three different implementations) are thread safe
06:02:49 <solonarv> all of their 'insert' functions look like: blah <- readSTRef ref; let { blah' = doSomeCalculations blah }; writeSTRef ref blah'
06:03:18 <solonarv> this is not thread safe because another thread could also touch the ref between the readSTRef and writeSTRef
06:06:12 * hackage Aoide 0.1.0.1 - A simple music library with the capability of generating .ly and .mid files.  https://hackage.haskell.org/package/Aoide-0.1.0.1 (Liisi_Kerik)
06:06:38 <walla> I am trying to install hindent by using the command "cabal install hindent", and I am getting this error: https://pastebin.com/GyLJD9fi
06:07:14 <walla> I get the same error when using "stack install hindent"
06:07:29 <ski> oh, `stToIO'
06:08:02 <ski> @hoogle atomicModifySTRef
06:08:03 <lambdabot> No results found
06:08:05 <Bish> can i use typeclasses in constructors?
06:08:21 <Bish> data Pattern = Pattern { nw :: (Num a => a -> a)} ?
06:08:31 <ski> Bish : what do you want to achieve ?
06:08:43 * hackage freer-indexed 0.1.0.0 - Freer indexed monad for type-level resource-aware effectual operations.  https://hackage.haskell.org/package/freer-indexed-0.1.0.0 (epoberezkin)
06:09:22 <ski>   data Pattern = MkPattern {nw :: forall a. Num a => a -> a}  -- is possible
06:09:37 <ski> but i'm not sure whether you want this
06:10:06 <ski>   data Pattern a = MkPattern {nw :: a -> a}  -- is another possibility. then when you use `Pattern a', you can have a constraint `Num a'
06:10:18 <sm[m]> walla: what hindent versions are cabal and stack trying to install ?
06:10:44 <ski> in the former case, a `Pattern' stores a polymorphic functions, that works for all numeric types `a'
06:10:57 <walla> sm[m]: How can I check that?
06:11:09 <ski> in the latter case, a `Pattern a' stores a (monomorphic) function, that works specifically on the type `a'
06:11:25 <walla> I have cabal version 3.2 and stack 2.3.1
06:11:29 <sm[m]> you’ll see hindent-X.Y mentioned in their output probably. If not try adding -v
06:12:21 <walla> sm[m]: hindent-5.3.1
06:12:40 <ski> it's also possible to have a type `Pattern', that stores a function that works for some particular type `a' .. this is called an "existential type" (or rather "existential data constructor"). but it didn't sound like you wanted this here, Bish
06:13:01 <sm[m]> that’s the latest, good. It seems hindent has not been updated for the version of ghc you’re using
06:13:39 <walla> oh ok. I can live without it. So I should just wait and one day it might work?
06:13:41 <sm[m]> You could force cabal/stack to use an older ghc, or look for newer code in the hindent repo, or report the bug
06:14:00 <sm[m]> Probably not, I don’t think hindent is actively maintained
06:14:27 <walla> ok. How do I force cabal/stack to use an older version?
06:14:47 <walla> I did use ghcup
06:15:31 <sm[m]> stack install hindent-5.3.1 —resolver lts-14 or cabal install hindent-5.3.1 -w ghc-8.6.5
06:18:21 <sm[m]> the related issue: https://github.com/chrisdone/hindent/pull/555
06:20:36 <walla> the stack command worked. Thanks. Is this only possible because I have ghcup? I installed it because people here said it is capable of using different versions of ghc.
06:20:57 <solonarv> stack doesn't care about ghcup, it manages its own GHC installations
06:21:12 * hackage Aoide 0.1.0.2 - A simple music library with the capability of generating .ly and .mid files.  https://hackage.haskell.org/package/Aoide-0.1.0.2 (Liisi_Kerik)
06:21:14 <sm[m]> no, stack installed the required ghc for you. ghcup handles that for cabal users.
06:21:24 <walla> oh ok thanks
06:23:48 <Bish> ski: thanks
06:23:52 <Bish> yeah that's what i asked
06:24:30 <ski> which of them did you want, if any ?
06:24:53 <Bish> how the forall thingie
06:24:57 <ezzieyguywuf> i'm trying to decide how to sample a curve in order to make it look smooth. I was thinking something along the lines of "more curvature = more samples", with a bounnd of "zero curvature (straight line) = two samples" and some sort of upper bound as well.
06:25:01 <ezzieyguywuf> are there any well known/heavily used algorithms for accomplishing this?
06:25:07 <Bish> well, i don't know actually
06:25:13 <ezzieyguywuf> I guess that's not really a haskell-specific question...
06:25:18 <Bish> i tried the second one, i guess
06:25:54 <Bish> if i have a constructor, how could "add" pure so i can use it with >>=
06:26:08 <ezzieyguywuf> ah, to whoever was asking about stack/cabal yesterday, _thats_ the reason I went to stack. I found it too cumbersome to manage ghc installations using ghcup
06:26:34 <ezzieyguywuf> although I *really* like the ghcup TUI, it has this little area that scrolls and when it's done it goes away and it's like it was never there
06:27:23 <maralorn> Can someone point me to a blog post/literature that explains the "the Haskell type system is unsound anyways so we don‘t need termination proofs for dependend types" argument?
06:27:47 <maralorn> Similarly for Type-in-Type.
06:28:04 <Bish> got it already
06:32:14 <maerwald> ezzieyguywuf: next release will have a real TUI
06:32:28 <maerwald> ezzieyguywuf: https://gitlab.haskell.org/haskell/ghcup-hs/-/merge_requests/20
06:32:56 <maerwald> not sure if that solves your issues?
06:35:13 <ski> Bish : you have any code you might want to show ?
06:36:12 <ski> maralorn : sounds not that related ?
06:37:59 <maralorn> ski: Well, I am looking for something to solve my confusion. That‘s why I sound confused.
06:38:24 <maralorn> ski: But I resolved to watch a few Talks by richard and look at some papers. I think my understand of a lot of this has become much better than the last time I tried, so hopefully, I can grasp it this time.
06:38:45 <merijn> maralorn: Dependent types don't need to guarantee termination, that's an orthogonal property
06:39:00 <merijn> maralorn: Dependent types just means that types can refer to runtime values
06:39:31 <merijn> maralorn: Now, if you don't guarantee termination, then that means your type checking *might* never finish, since it's relying on some non-terminating value level computation
06:39:47 <merijn> maralorn: Whether you consider this a problem depends on your definition of "problem"
06:41:17 <maralorn> merijn: So when Idris requires typelevel computations to be provable total they just do that because a hanging compiler is uncool?
06:41:40 <dminuoso> maralorn: Well they rather do it so that Idris can be leveraged as a sound theorem prover.
06:41:52 <merijn> maralorn: Well, there's lots of arguments to be made in favour of total languages, "decidability of type checking" is just one of them
06:42:14 <merijn> maralorn: Note, that even guaranteeing termination is kinda pointless
06:42:15 <boxscape> https://www.cis.upenn.edu/~sweirich/papers/eisenberg-thesis.pdf has a couple of paragraphs on Type :: Type in 4.4.1
06:42:44 <merijn> maralorn: If a computation is total, but takes 10 years to compute then your typechecking is "technically" decidable, but for all practical purposes it might as well be non-terminating
06:42:51 <boxscape> also 4.4.5 Running proofs on termination
06:43:08 <merijn> Type-In-Type is an abomination
06:43:40 <merijn> "Your scientists were so pre-occupied by whether or not they could, they didn't stop to think whether they should..."
06:43:47 <maralorn> merijn: But you can do that in idris, right?
06:43:58 <merijn> I don't know what Idris does
06:44:06 <merijn> Coq and Agda use stratification
06:44:17 <merijn> Which is a lot more sensible to my mere human brain
06:44:28 <maralorn> I mean there are no type system features to guarantee that a program terminates "quickly".^^
06:44:39 <merijn> maralorn: Oh, the termination bit
06:44:41 <merijn> maralorn: Yeah
06:44:54 <maralorn> merijn: Stratification is the infinite layer of Set, Class, etc.
06:45:08 <maralorn> ?
06:45:09 <merijn> maralorn: Which is why "totality to guarantee termination of type checking" is a kinda lame argument 
06:45:24 <maralorn> i.e. Type, Kind, ...
06:46:11 <merijn> maralorn: They basically have like "Type_0" (Type), "Type_1" (kinds), "Type_2" (sorts), ..., Type_n (ad infinitum)
06:46:51 <maralorn> merijn: Yeah, I always thought that be nicer.
06:47:16 <boxscape> and IIRC agda uses polymorphism over n in Type_n, whereas Idris uses subtyping
06:48:41 <merijn> boxscape: iirc a solution to this is explained in "Extended Calculus of Constructions" by Luo
06:49:32 <Bish> ski: nah, i don't even need it, i was just curious
06:49:37 <Bish> i already threw away the code that needed it
06:49:40 <boxscape> merijn btw goldfirere's thesis also says that Type :: Type has been proven type-safe in some languages
06:49:43 <ski> fair enough, Bish :)
06:50:02 <merijn> boxscape: My objection isn't soundness or type safety
06:50:06 <boxscape> fair enough
06:50:14 <merijn> boxscape: My objection is that I can't understand/follow WTF is going on
06:54:26 <walla> ok I am back. Turns out that I must install hindent with cabal. The problem is that when I run "cabal install hindent-5.3.1 -w ghc-8.6.5", I get this error:  "cabal: Cannot find the program 'ghc'. User-specified path 'ghc-8.6.5' does notrefer to an executable and the program is not on the system path."
06:54:47 <solonarv> this error is telling you that ghc 8.6.5 is not installed
06:55:17 <merijn> Well, *technically* it's telling him no executable named ghc-8.6.5 is found on his path
06:55:26 <merijn> Whether or not GHC 8.6.5 is installed is orthogonal :p
06:55:44 <solonarv> okay, sure, but the likely cause is GHC 8.6.5 not being installed ;)
06:56:02 <ezzieyguywuf> maerwald: nice! I've been meaning to transition my project to brick
06:57:07 <walla> cabal install ghc-8.6.5 throws me this error: https://pastebin.com/XQXhryAh
06:57:16 <merijn> walla: You can't cabal install ghc
06:57:42 <merijn> How did you get ghc/cabal?
06:57:47 <walla> ghcup
06:58:08 <merijn> walla: Then presumably you didn't install/select 8.6.5 via ghcup
06:59:04 <walla> I just copied and pasted the curl command on the ghcup site.
06:59:21 <merijn> walla: That, presumably, installs a much newer ghc
07:00:17 <walla> so how do I install a different version?
07:02:31 <solonarv> like so: ghcup install 8.6.5
07:03:13 <walla> wow thats easy
07:04:40 <mrnort> Hi, I just finished reading Programming in Haskell, and I really enjoyed it. I now feel much better equipped to configure XMonad :-)  But lacking other places to use Haskell personally, I thought I'd use some of that beginner knowledge and contribute to some free software. I can just search around on Github to see if there's anything that interests
07:04:40 <mrnort> me, but thought I'd pop in here if you can recommend any projects needing some (beginner) help? :)
07:06:17 <merijn> mrnort: pandoc? shellcheck? ghc? (not even joking, there's a push on improving the documentation in base, so even just proofreading/commenting as a beginner helps)
07:06:56 <dminuoso> mrnort: It helps to contribute to projects you actually use and like.
07:07:07 <dminuoso> Perhaps contribute to XMonad, seeing as you appear to be a user for that already.
07:08:04 <sm[m]> walla, you are learning some good stuff. After installing it with stack, what made you need to install hindent again with cabal ? 
07:08:05 <merijn> dminuoso: Hey, if someone wants to write tests for my code without using it, that sounds great ;)
07:08:43 <sm[m]> mrnort: hledger welcomes new contribs too
07:10:00 <mrnort> Cool! Yeah, things that interest me is of course the best, but it is still hard to decide. But thanks for the suggestions, I'll note them down and take a look
07:11:52 <dminuoso> merijn: Can do. Will you pay?
07:12:11 <merijn> dminuoso: haha
07:12:31 <merijn> Sure, in pennies per test :p
07:12:40 <dminuoso> Ill cook up some template haskell for sure.
07:12:51 * dminuoso will be rich
07:13:13 <Uniaika> if you can sell auto-generated code, yes TH will make you rich :P
07:13:29 <dminuoso> merijn: Oh oh I know! Ill just write `many yourTestsuite` and then Ill have an infinite amount of money!
07:13:43 <merijn> dminuoso: Joke's on you
07:13:48 <merijn> I don't have a test suite :p
07:14:13 <dminuoso> Uniaika: Cisco can do worse, they sell non-operational code.
07:18:52 <sm[m]> incidentally (mrnort), here are the top haskell projects on github by stars: https://github.com/search?o=desc&p=1&q=language%3AHaskell+stars%3A%3E%3D1000&ref=searchresults&s=stars&type=Repositories
07:19:17 <sm[m]> and (all) there has been some big news in haskelldom. The mighty pandoc has finally been unseated from #1!
07:20:34 <sm[m]> it turns out haskell's killer app is.. checking bash scripts  ?
07:22:25 <dminuoso> @remember sm[m] it turns out haskell's killer app is.. checking bash scripts
07:22:25 <lambdabot> Done.
07:23:13 <sm[m]> oops
07:24:08 <sm[m]> immortalised as a crazy haskell hater :)
07:25:55 <Cheery> Is there a replacement to cron that uses haskell module as crontab?
07:27:42 <ph88> i'm using stack. How can i compile a source file directly with GHC ? i want to compile with -prof but without -prof-auto
07:30:19 <ph88> Cheery, there is no direct replacement for cron that is a command line tool written in haskell. But there is a related library https://hackage.haskell.org/package/cron 
07:34:16 <sm[m]> ph88: guessing: stack ghc --ghc-options='-prof' Main.hs ?
07:35:42 * hackage zipper-extra 0.1.3.1 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.3.1 (locallycompact)
07:35:46 <ph88> sm[m], stack does not allow you to do that
07:36:02 <sm[m]> stack exec -- ghc -prof Main.hs ?
07:36:11 <ph88> ah like that
07:36:18 <ph88> thanks i will give it a try
07:55:42 * hackage aeson-with 0.1.1.1 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.1.1 (locallycompact)
07:58:23 <hseg> hi. playing around with some design parameters, trying to get memory usage down. main problem is my usage of a type that's basically Map (Vector Integer) r. i guess i need some kind of unboxed vector?
07:58:46 <hseg> but i don't know how to get eg Foldable, Functor instances for Vector.Unboxed
07:59:32 <merijn> hseg: You can't
07:59:37 <hseg> :(
07:59:40 <merijn> Well, Foldable you can, I guess
07:59:47 <merijn> But Functor and Traversable can't
08:00:02 <hseg> bc fmap and traverse would need constrained inputs?
08:00:15 <hseg> a la why Set isn't a Functor?
08:00:19 <merijn> hseg: yeah
08:00:36 <merijn> "Unbox a" instead of "Ord a", but same idea
08:01:00 <hseg> ok, and i suppose the same is true for all variants (storable, prim)?
08:01:55 <merijn> yeah, except for the boxed one you already have :p
08:02:44 <hseg> :/
08:03:29 <hseg> how much of a difference would refactoring for this make? trying to cost-benefit this
08:04:47 <hseg> also, is it worth my time to convert to using a hashmap instead?
08:05:46 <ph88> hseg, use for what ?
08:06:03 <hseg> storing monomial->coefficient maps for a polynomial
08:06:39 <ph88> sm[m], i tried that command, ghc can't find the dependencies by itself ..
08:07:07 <ph88> hseg, what benefit are you looking for ?
08:07:40 <hseg> ph88: ? currently, my quickcheck test suite regularly OOMs
08:07:57 <hseg> want to reduce memory usage to avoid this
08:08:31 <hseg> and my first choice is to improve memory rep'n instead of limiting the sampling regime
08:12:37 <ph88> hseg, that's an excellent idea ! i have no idea how a monomial to coefficient map looks like though
08:12:41 <dminuoso> hseg: do you need the actual intsances anyhow?
08:13:18 <hseg> ph88: I'm using Map (Vector n Integer) r, where r is the type of coefficients
08:13:37 <hseg> dminuoso: no, but i like my code to use generic apis
08:13:40 <ph88> what's n ?
08:13:46 <hseg> number of variables
08:13:56 <hseg> (and am permitting negative exponents)
08:14:10 <hseg> dminuoso: but will convert to specialized versions if necessary
08:14:16 <ph88> data Map k a    why do you have 3 terms ?
08:14:29 <hseg> using vector-sized
08:14:52 <hseg> so Vector 2 a ~~ (a,a)
08:14:55 <hseg> eg
08:14:58 <ph88> So it's Map ((Vector n) Integer) ?
08:15:14 <hseg> no, Map (Vector n Integer) r
08:15:25 <hseg> note Vector n Integer :: Type
08:15:31 <ph88> ah i see
08:16:04 <ph88> and where does the memory go ?
08:16:17 <hseg> ?
08:16:45 <sm[m]> ph88: it'll need -package options then
08:17:23 <hseg> i'm guessing that that's when qc tests multiplication between polynomials s.t. the sums of the exponents have very little overlap
08:17:57 <hseg> (in that case |support f*g|~|support f||support g|)
08:18:12 * hackage path-extensions 0.1.1.0 - Enumeration of common filetype extensions for use with the path library.  https://hackage.haskell.org/package/path-extensions-0.1.1.0 (locallycompact)
08:18:51 <hseg> ok, this is weird. was trying to figure out what the pathological cases were that triggered OOM, so i passed --quickcheck-verbose. suddenly, i'm seeing no memory getting freed, and the specific test case that i'm diagnosing never finishes
08:20:42 <shadow__> hello everyone, gm
08:23:15 <ph88> sm[m], i'm not sure what to pass for -package when i look at the verbose output of stack it's passing package-db
08:24:23 <hseg> hrm... ok, so i specialized to Vector 1 Integer to try and avoid problems from there. still pathological
08:24:36 <ph88> hseg, sounds like you could do with some memory profiling. And then i would suggest to run just 1 single case and not go through multiple cases with QC. Maybe you can capture one more complicated input structure and then profile that
08:25:24 <hseg> right, so am running with +RTS -h -RTS, but that doesn't give me the pathological cases
08:25:33 <hseg> only tells me which functions are to blame
08:26:03 <hseg> which is a start, but i don't know which inputs are killing it
08:27:18 <hseg> ... why is it that quickcheck-verbose prevents ghc from gc'ing the testcase inputs?
08:32:00 <sm[m]> ph88 that sounds good then
08:32:35 <ph88> sm[m], it did to me too .. just that i get the same errors as before that dependencies could not be found
08:32:59 <sm[m]> if you run stack's full ghc command, it works, right ?
08:38:39 <hseg> (´益`) my quickcheck generator generated dense polynomials with high-denominator coefficients
08:38:51 <hseg> of course it would be slow
08:40:12 * hackage mutable 0.2.1.0 - Automatic piecewise-mutable references for your types  https://hackage.haskell.org/package/mutable-0.2.1.0 (jle)
08:44:14 <hseg> how much heavier are Rationals on memory than Ints?
08:44:32 <hseg> or even Integers?
08:44:45 <Taneb> hseg: they're precisely as heavy as two Integers
08:45:24 <hseg> hrm. ok, so that would only double the memory burden of my map
08:46:53 <dolio> Operations on rationals can easily involve much larger integers, though.
08:47:13 <hseg> right
08:47:23 <hseg> which is basically the problem
08:48:15 <dolio> Like, adding two integers takes at most one bit more than the larger integer, but adding two rationals could take twice as many bits for the denominator.
08:48:30 <hseg> right
08:48:42 * hackage devtools 0.0.2 - Haskell development tool agregate  https://hackage.haskell.org/package/devtools-0.0.2 (mbj)
08:48:43 <dolio> Or, it could require the sum of the bits, I guess.
08:54:26 <hseg> ok, reducing max size to 10 avoids the too-large maps, which helps
08:55:22 <hseg> hrm. will want to check if i can't avoid the use of rationals in my code
08:56:42 <asheshambasta> Is there a way to define something on the lines of foo :: String -> SomeType sym; where sym is symbol that changes depending on the String argument?
08:56:50 <hseg> that and limiting testcase size to small samples will avoid blowing up memory too much
08:57:09 <hseg> asheshambasta: so you basically want to lift the string to the typelevel?
08:57:17 <asheshambasta> hseg: correct
08:58:18 <hseg> possibly https://hackage.haskell.org/package/reflection may be of use
08:58:38 <hseg> but don't know enough about your use case to be sure
08:59:30 <hseg> cf reifySymbol there
08:59:43 <asheshambasta> well; I'm trying to define a servant api type that has a particular header/query param being read: the name of which should vary based on the string value.
08:59:56 <hseg> dunno enough about servant to help
09:00:08 <hseg> but this might work
09:00:44 <hseg> gtg, though, will be back in ~1h
09:02:05 <asheshambasta> type level programming starts getting into the weeds fast :-)
09:07:27 <lordgrenville> Hi all, I have a line like this: localMaxima (x:y:z) = if y > x & y > z then [y] else []
09:08:10 <lordgrenville> and hlint suggests I change it to [y | y > x & y > z]
09:09:11 <dsal> You don't have to listen to hlint if you don't want to.
09:09:30 <lordgrenville> (Sorry, thought I was getting an error message after making the change, but it was something else. So embarassing)
09:10:08 <lordgrenville> dsal I know but it's like robot code review, I just started using it and I'm loving it
09:10:21 <dsal> I think it's a little weird to use a list comprehension for that type of thing, but I do it sometimes.
09:10:27 <dsal> Yeah, hlint has showed me a lot of useful things.
09:12:26 <lordgrenville> Wait, I *am* getting the error again: "Variable not in scope: (&) :: Bool -> Bool -> Bool |11 | localMaxima (x:y:z) = [y | y > x & y > z] |"
09:12:47 <lordgrenville> How can & not be in scope?
09:13:22 <byorgey> lordgrenville: try &&
09:17:30 <lordgrenville> byorgey gives me a different error: that z is type Integer instead of [Integer] 
09:17:55 <ja> the z is a list
09:17:58 <hseg> asheshambasta: yep. it's so tempting though
09:18:03 <ja> the last element of a list constructor will be a list
09:18:18 <ja> if you have a:b, a is an element and b is the rest (a list)
09:18:20 <lordgrenville> byorgey (also I think this is your homework assignment! If so wow, thank you so much, it's gruelling but really mindblowing)
09:19:06 <ja> lordgrenville: do you understand the error now that i gave you that hint?
09:19:12 <lordgrenville> ja I see that. So how would I distinguish between "a list of at least three elements" and "a list of more than three elements"?
09:19:57 <lordgrenville> ja I was doing  myFunc (x:y:z) .... and then myFunc (x:y:z:zs) 
09:20:12 <lordgrenville> ja but I guess those are actually the same
09:20:19 <hseg> asheshambasta: rn, am tempted to break out type-level lists in order to be able to create a family of ordered types U = O | I [Type] | NI [Type] s.t. I's are ordered by containment, NI's are ordered by reverse containment 
09:20:46 <ja> lordgrenville: those are not the same since the first will not match if there are four elements
09:20:54 <hseg> .. but it feels like a huge overkill
09:21:04 <byorgey> lordgrenville: hah, you're welcome, glad you're learning =)
09:21:22 <ChaiTRex> lordgrenville: No, they aren't the same.
09:21:33 <ja> a list of at least three elements is matched by a:b:c:d
09:21:43 <ChaiTRex> lordgrenville: myFunc (x:y:z) is better written myFunc (x:y:zs).
09:21:46 <ja> patterns after that will only be reached if the first doesn't match
09:22:07 <ChaiTRex> lordgrenville: The third variable gets a list rather than an element.
09:22:34 <ja> better say "the last" so the statement is valid for any amount of list constructors
09:23:25 <hseg> hrm. in my application can get away with I limited to length 1 and 2, NI limited to 0 and 1...
09:27:43 <jumper149> If you look at the first few instances of MonadBaseControl, is there a reason these are done with explicit monads (like Maybe) instead of one instance `MonadBaseControl b b`?
09:28:10 <jumper149> https://hackage.haskell.org/package/monad-control-1.0.2.2/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl
09:28:12 <lordgrenville> ChaiTRex how could I match a list of *exactly* 3 elements?
09:28:22 <dsal> lordgrenville: [a,b,c]
09:28:31 <dsal> But that seems like you're doing something wrong.
09:29:34 <EvanR> probability of doing something wrong: 41%
09:29:36 <lordgrenville> dsal well the context is "local maxima". Given a list, return only the numbers greater than number to their left and number to their right
09:30:10 <ph88> sm[m], i don't see the direct ghc command from the stack verbose output... it seems to be calling Cabal instead
09:30:14 <dsal> A function that requires a list of exactly three elements is a function that wants a tuple, but with less efficiency and more dynamic failures.
09:30:17 <lordgrenville> dsal so I thought I'd first match the case of exactly 3, then anything more would recurse, finally anything less returns empty list
09:30:27 <ja> lordgrenville: sorry, my statement "those are not the same since the first will not match " is wrong
09:31:12 <dsal> I find that local maxima thing confusing.
09:32:05 <EvanR> give the middle number from all the moving windows of 3 numbers a b c where a < b, c < b
09:32:39 <EvanR> maybe homework
09:33:02 <ChaiTRex> It's a bit more complex than that since the first element of the whole list can be a local maximum and the last element.
09:33:30 <sm[m]> ph88: not sure what command you ran, the build or ghc commands should definitely run ghc
09:33:38 <ph88> sm[m], i think i found it .. if i pass --cabal-verbose i can see the actual call to ghc
09:33:41 <EvanR> that's just edge cases :)
09:33:49 <sm[m]> you might need.. yeah
09:33:56 <ph88> sm[m], stack build --cabal-verbose
09:34:01 <sm[m]> Confusing, these combinations of tools
09:34:02 <ph88> thanks for the help !
09:37:03 <lordgrenville> EvanR yes it's a homework assignment
09:37:25 <lordgrenville> ChaiTRex no, if there aren't 3 numbers then no local maximum
09:38:01 <lordgrenville> loMa [2,4] = []
09:38:19 <ChaiTRex> lordgrenville: What about [1000, 2, 1]?
09:38:31 <ChaiTRex> lordgrenville: The left one will be a local maximum or not?
09:39:06 <lordgrenville> ChaiTRex not
09:39:42 <ChaiTRex> lordgrenville: OK, then the problem is simple. You just need to loop over all the windows of three elements.
09:43:37 <lordgrenville> ChaiTRex good idea, thanks! I managed to fix my recursive solution, but part of the goal of the HW is to do it as briefly as possible, so I think your approach will be bettter
09:44:03 <lordgrenville> localMaxima x@(a:b:c:d) = [b | b > a && b > c] ++ localMaxima (tail x)
09:44:14 <dsal> If it is really a list of chunked maxima, `[a] -> [(a,a,a)]` would be a good building block.
09:44:15 <lordgrenville> localMaxima _ = []
09:44:26 <dsal> Oh, it's a sliding window?
09:44:51 <ChaiTRex> lordgrenville: That's pretty good, though I'd put s on the end of any list variable (`ds`, `xs`).
09:45:14 <dsal> Or just name the last element _
09:45:53 <ChaiTRex> lordgrenville: Another trick is `localMaxima (a:xs@(b:c:ds)) = [b | b > a && b > c] ++ localMaxima xs`
09:46:05 <ChaiTRex> lordgrenville: Then you don't need to call `tail`.
09:46:18 <dsal> Is that tail call elimination?
09:46:26 <ChaiTRex> Haha
09:46:49 <lordgrenville> :)
09:47:16 <lordgrenville> ChaiTRex good ideas, thank you!
09:47:30 <lordgrenville> dsal thanks also!
09:47:56 <dsal> Heh, I've misunderstood the specification and just added confusion, afaict.
09:47:57 <lordgrenville> btw does anyone know why hlint would suggest single & instead of && ?
09:48:18 <dsal> & means something else.
09:48:23 <dsal> :t (&)
09:48:24 <lambdabot> a -> (a -> b) -> b
09:48:55 <lordgrenville> ah, logical and. I see
09:49:06 <dsal> No, it's unrelated to 
09:49:08 <dsal> "and"
09:49:13 <dsal> It's just flipped $
09:49:18 <ChaiTRex> lordgrenville: No, it's just reordering the syntax. `f x` becomes `x & f`.
09:49:54 <ChaiTRex> lordgrenville: You can apply a bunch of functions like this: `x & f & g & h` and it'll work like `h (g (f x))`
09:50:11 <lordgrenville> ok. Yeah logical and would be a -> b -> Bool I guess
09:50:30 <dsal> :t (&&)
09:50:31 <lambdabot> Bool -> Bool -> Bool
09:50:56 <dsal> `a -> b -> Bool` isn't really implementable in any useful way.
09:51:17 <lordgrenville> ah right...
09:51:49 <lordgrenville> still getting the hang of things
09:52:05 <dsal> :t (.&.) -- there's this thing
09:52:06 <lambdabot> Bits a => a -> a -> a
09:52:54 <lordgrenville> what does that mean?
09:53:06 <ChaiTRex> It's bitwise and.
09:53:13 <dsal> It's a bitwise and for types that support bit access.
09:53:17 <ChaiTRex> Like in Java or C or whatever.
09:54:05 <lordgrenville> oh i see
09:54:28 <lordgrenville> x & y
09:54:38 <dsal> > 74 .|. 47
09:54:39 <lambdabot>  111
09:55:02 <dsal> > 111 & show
09:55:04 <lambdabot>  "111"
09:55:35 <frdg> what is the difference between `stack repl` and `stack ghci`?
09:56:10 <maerwald> ezzieyguywuf: let me know if you have ideas/thoughts on the brick ui
10:03:44 <Athas> It's not exactly intuitive, but it turns out you can indeed put images in Hackage package descriptions: http://hackage.haskell.org/package/futhark
10:04:31 <solonarv> :t \xs -> zipWith3 (,,) xs (tail xs) ((tail . tail) xs)
10:04:33 <lambdabot> [c] -> [(c, c, c)]
10:05:05 <ezzieyguywuf> maerwald: I will, I planned to start digging into it in the next week or so.
10:05:07 <joncol> What tooling do people use for Haskell work in Emacs these days? I've used Intero before, but it seems discontinued. Does this get asked all the time?
10:05:14 <solonarv> frdg: none, AFAIK - they're aliases for each other
10:06:47 <frdg> I see. Thanks. In that case I would think there would be a `cabal ghci`.
10:06:54 <Athas> joncol: I find that plain haskell-mode works fairly reliable now.
10:07:07 <Athas> But mostly I've been burnt so much on bad tooling that I don't use much these days.
10:08:59 <joncol> Athas: OK, I see. There seems to be some ongoing work on this: https://mpickering.github.io/ide/posts/2020-05-08-state-of-haskell-ide.html
10:11:12 <Athas> I am reluctant to use tooling that has to be compiled against a specific version of GHC.  But I think that problem is due to fundamental poor design in GHC, so it's likely unavoidable.
10:11:29 <Athas> In practice, I rarely use anything more fancy than ghcid.
10:12:00 <ChaiTRex> :t \ xs -> zip3 xs (drop 1 xs) (drop 2 xs)
10:12:01 <lambdabot> [c] -> [(c, c, c)]
10:12:13 * hackage ixset-typed-conversions 0.1.0.0 - Conversions from ixset-typed to other containers.  https://hackage.haskell.org/package/ixset-typed-conversions-0.1.0.0 (locallycompact)
10:36:20 <baris> Hi, I could not find much info about this error `Could not deduce (MonadFail m) arising from a use of ‘fail’`
10:36:33 <baris> that is what I am getting while trying to compile cabal-install.
10:37:12 <baris> Also another project gave me a similar error. I support it is because of base v4.13 
10:37:20 <baris> s/support/suppose
10:37:46 <baris> how can I get over it?
10:38:19 <ChaiTRex> baris: Not sure. Are you compiling a version of Cabal compatible with the version of GHC?
10:39:44 <baris> ChaiTRex: I am really puzzled on that. It should be compatible. How can I be sure of it?
10:40:51 <baris> I do not get any error regarding version.
10:41:52 <ChaiTRex> baris: Hmm, looks like that may be a known issue: https://github.com/haskell/cabal/issues/6327
10:42:01 <ChaiTRex> baris: They recommend compiling with GHC 8.6.5.
10:42:10 <sm[m]> yup, it's a common error that affects every project built for GHC <8.8 and lacking proper upper bounds on base
10:43:05 <baris> I am trying to compile Cabal-install 3.2.0. I could be able to compile it with 8.10, but 8.10 is incompatible for another project ... 
10:43:28 <ChaiTRex> baris: You can compile Cabal and then use it with a different GHC version, I think.
10:43:39 <baris> and that another project used to be suggesting 'stack' now suggest 'cabal'. 
10:44:20 <dcoutts> Yes, each cabal version should work with a range of ghc versions
10:44:39 <baris> ChaiTRex: I think that works, I have my previous cabal binaries compiled on GHC 8.10, but running with GHC 8.8 as well, but I thought that was problematic.
10:50:25 <ChaiTRex> baris: Looks like once you compile it, it supports everything later than GHC 7.4 ("Drop support for GHC 7.4, since it is out of our support window (and has been for over a year!)"). https://github.com/haskell/cabal/blob/master/Cabal/ChangeLog.md
10:52:15 <ChaiTRex> baris: Or, more exactly, they support "base >= 4.6 && < 5," https://github.com/haskell/cabal/blob/master/Cabal/Cabal.cabal
10:52:42 <ja> remexre: oooh controversial bounds :O
10:52:53 <ja> remexre: ooops that was not for you :)
10:53:11 <remexre> heh
10:53:26 <remexre> I did find instructions on how to get iserv working, they're just out of date for ghc 8.10.1
10:53:35 <ja> interesting!
10:53:40 <ChaiTRex> baris: And here is base versions to GHC versions conversion table: https://wiki.haskell.org/Base_package
10:53:47 <remexre> and they're a huge pain
10:53:49 <remexre> and as a result I have given up and I'm just building everything in qemu :P
10:54:07 <ja> aww damn
10:54:21 <ja> you're just trying to cross-compile ormolu, right?
10:54:36 <remexre> yeah
10:54:50 <ja> i should try it after work...
10:54:50 <baris> ChaiTRex: thanks, I think I would go way of remexre to use a vm using a distroy with 'compatible version'
10:54:58 <remexre> and then later ghcide, but that seems not to support ghc 8.10.1 at all
10:55:09 <ja> remexre: where are the instructions for iserv with ghc 8.8?
10:55:40 <ChaiTRex> baris: No problem.
10:55:54 <remexre> https://medium.com/@zw3rk/the-haskell-cabal-and-cross-compilation-e9885fd5e2f , https://medium.com/@zw3rk/cross-compiling-template-haskell-7e38c00c2914
10:56:03 <ja> thanks
10:56:13 <remexre> (you need a script from the former for the latter)
10:56:34 <LCRERGO> I'm trying to extract a variable name from an alternative but I'm having problems with it
10:56:53 <dsal> LCRERGO: What does that mean?  What have you done?
10:57:28 <LCRERGO> myBrowser <- lookupEnv "BROWSER" <|> Just "firefox"
10:58:10 <remexre> :t fromMaybe
10:58:11 <ChaiTRex> LCRERGO: browser, maybe.
10:58:12 <lambdabot> a -> Maybe a -> a
10:59:03 <remexre> :t fromMaybe "firefox" <$> lookupEnv "BROWSER"
10:59:04 <lambdabot> error:
10:59:04 <lambdabot>     Variable not in scope: lookupEnv :: [Char] -> f (Maybe [Char])
10:59:15 <remexre> rip, well, you get the point
10:59:53 <LCRERGO> lookupEnv from System.Environment
11:00:43 <ChaiTRex> % :doc System.Environment.lookupEnv
11:00:43 <yahb> ChaiTRex:  Return the value of the environment variable @var@, or @Nothing@ if; there is no such value.; For POSIX users, this is equivalent to 'System.Posix.Env.getEnv'.; @since 4.6.0.0
11:00:59 <ChaiTRex> % :t System.Environment.lookupEnv
11:00:59 <yahb> ChaiTRex: String -> IO (Maybe String)
11:01:10 <remexre> :t fromMaybe "firefox" <$> System.Environment.lookupEnv "BROWSER"
11:01:11 <lambdabot> IO [Char]
11:02:14 <ChaiTRex> browser <- fromMaybe "firefox" <$> lookupEnv "BROWSER"
11:03:01 <fog> https://github.com/fog-hs/clock-scanner
11:03:25 <fog> traverse cannot be performed lazily on monadic lists
11:03:31 <fog> so scanners are used instead
11:09:55 <LCRERGO> Interesting thx
11:11:10 <LCRERGO> I wasn't uderstanting why <$> would work in this case but then I realized it was because of fromMaybe
11:11:54 <ChaiTRex> LCRERGO: <$> with IO means to apply the function on the left to the `a` in `IO a` on the right.
11:11:59 <dsal> <$> is pushing your lookupEnv into IO
11:12:47 <ChaiTRex> LCRERGO: So, it applies the function `fromMaybe "firefox"` to whatever `Maybe String` `lookupEnv "BROWSER"` produces.
11:13:17 <ChaiTRex> LCRERGO: You can use it whenever you want to apply a function to your result just before `<-` is done.
11:14:47 <ezzieyguywuf> how do I know if this is part of a standard haskell installation or not? https://hackage.haskell.org/package/control-bool-0.2.1
11:15:10 <ChaiTRex> LCRERGO: uppercaseInput <- map toUpper <$> getContents
11:16:06 <ChaiTRex> LCRERGO: `getContents` gets all the input as a `String` from stdin. Then you `map toUpper` onto it. Gives you the uppercase version of all the input.
11:17:43 <ChaiTRex> ezzieyguywuf: Try importing it into `ghci` (not `stack ghci` or whatever). I think.
11:18:18 <kleisli> anyone know if it's possible to give a type operator lower precedence than -> ? something like this https://paste.ee/p/tDiTg
11:18:33 <dsal> ezzieyguywuf: It doesn't say "base"
11:18:49 <ezzieyguywuf> dsal: where would it say base if that was the case?
11:19:05 <dsal> ezzieyguywuf: https://hackage.haskell.org/package/base
11:19:46 <dsal> I don't consider that stuff at all, though.  If I want things, I just add dependencies.  If I want something super trivial (e.g., `whenM`) I just write it.
11:20:12 * hackage nvim-hs 2.1.0.4 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-2.1.0.4 (saep)
11:20:40 <ChaiTRex> kleisli: Looks like the fixity of (->) is -1: https://gitlab.haskell.org/ghc/ghc/-/issues/15235
11:21:12 <dsal> Is Control.Bool.bool the same as Data.Bool.bool but returning the other argument?  That's just evil.
11:22:24 <kleisli> interesting, thanks ChaiTRex 
11:22:25 <dolio> dsal: No, the documentation is wrong.
11:22:36 <ChaiTRex> kleisli: No problem.
11:22:57 <ezzieyguywuf> dsal: lol, how'd you know I was looking at `whenM`
11:23:25 <dolio> Stop using booleans.
11:23:27 <dsal> ezzieyguywuf: It was a random thing from a recent conversation.  I didn't even notice whenM was in there until afterwards.  heh
11:23:46 <ezzieyguywuf> dolio: and do what instead?
11:24:06 <hseg> q: given types l :: Nat -> Type -> Type with phantom Nat index, i want to construct a type nz :: Type -> Type that's a subtype of l n for all n. is this even possible?
11:24:23 <dsal> "@bool a b@ is a function that returns a if the argument is True, otherwise returns 'b'."   ->  bool _ y True = y
11:24:32 <dsal> ezzieyguywuf: see: boolean blindness
11:24:58 <ezzieyguywuf> dsal: ok I will. As it stands, I'm relying on this to determine when to exit a loop - not sure if this is "boolean blindess" or not, but I'm not sure how to work around it. https://hackage.haskell.org/package/GLFW-b-3.3.0.0/docs/Graphics-UI-GLFW.html#v:windowShouldClose
11:25:18 <hseg> (i'm trying to encode the fact that the group of units of a number field contains the groups of units of all the localizations of its ring of integers away from some element)
11:25:32 <dsal> ezzieyguywuf: It's not the worst example.
11:25:38 <dsal> In particular, it's not your code.  :)
11:25:47 <hseg> (e.g. Q^x contains Z[1/n] for all n)
11:25:57 <dolio> Well, if it's something like that, there's not much you can do.
11:26:06 <ezzieyguywuf> dsal: hah, true.
11:26:11 <dolio> In that case, stop looking for random libraries to golf your code slightly.
11:26:19 * ezzieyguywuf nods
11:27:36 <hseg> ... that should be Q^x contains (Z[1/n])^x
11:28:03 <dsal> ezzieyguywuf: Even knowing about boolean blindness, I've done dumb stuff like returning a boolean indicating whether a session is new or resumed.
11:28:43 <dsal> https://github.com/dustin/mqtt-hs/commit/dd1fdf46d36f4f2f2ffd3889b3992cdf84459322 <-- if you have to look at your code every time to figure out whether `True` means `NewSession` or `ExistingSession` maybe you should've just called them that.  :)
11:29:03 <ezzieyguywuf> dsal: I find myself making these sorts of refactors
11:29:14 <ezzieyguywuf> I'm still pretty new to things though, so I bet there's all kinds of dumb stuff in my code, lol.
11:29:37 <hseg> heh. what a coincidence -- just read about an instance of boolean blindness a couple hours ago https://stackoverflow.com/a/38221146
11:29:41 <dsal> I think it's reasonable to use a helper for clarity.  Writing `whenM` would make your code easier to understand, I assume.  That `bool` definition in the library is both silly and unnecessary.
11:30:30 <hseg> note that there, it's a matter of duplicated work, which is an even better motivator than decreasing confusion
11:32:21 * ezzieyguywuf considers class-prelude
11:32:49 <dsal> I don't think I've ever used the `bool` function.  I don't like `if`, but `bool` seems differently silly.
11:33:15 <hseg> well, it is useful when writing point-freely
11:33:44 <dsal> And there's a place where I've used it...
11:34:18 <dsal> I'm sure it added clarity here:  `same = bool LT GT . (== Right oe)`
11:34:38 <Rembane> LambdaCase + >>> works quite well instead of bool or if'.
11:35:12 <hseg> Rembane: ?
11:36:42 <ezzieyguywuf> is >>> an "arrow" thing? 
11:36:46 <ezzieyguywuf> I still don't know arrow
11:36:51 <hseg> dsal: point taken. you have a more idiomatic way of writing that than \case {(Right oe) -> LT; _ -> GT} ?
11:37:09 <dolio> It's just composition in the opposite order.
11:37:14 <Rembane> hseg: Like this: fileExists >>> \case; True -> putStrLn "File exists"; _ -> error "Exiting early."
11:37:29 <Rembane> hseg: And I typoed, I was meaning to write >>=
11:37:32 <dsal> Heh, this code is part of my gopro project.   GoPro has a metadata format you can extract as a stream neatly from a video file.  I wanted to do something similar for EXIF data in images, but that's not as nice.  So I just binary search the prefix of the file to find the shortest thing that the EXIF parser I'm using can use to reconstruct the same EXIF data.
11:37:40 <hseg> nice!
11:37:58 <Rembane> ezzieyguywuf: You can think of >>> as a dot but in the other direction 
11:38:07 <ChaiTRex> :t either
11:38:08 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:38:40 <Rembane> hseg: case don't work very well with function composition the right way around imo, so >>> is a real life saver there, but that's mostly because that I don't like reading programs from the bottom up. 
11:38:49 <ChaiTRex> @hoogle Either a b -> (a -> c) -> (b -> c) -> c
11:38:50 <lambdabot> Overhang onRight :: Either a b -> (a -> c) -> (b -> c) -> c
11:38:58 <hseg> fair
11:40:15 <hseg> q: trying to puzzle around how to implement discrete log (and in particular, what constraints i need for it). ie want dlog p p^k = Just k, dlog p _ = Nothing, where k :: Integer
11:40:55 <ezzieyguywuf> hrm, . in the opposite direction...
11:40:57 <ezzieyguywuf> g . f
11:40:57 <ChaiTRex> :t either (const GT) (const LT)
11:40:58 <lambdabot> Either b1 b2 -> Ordering
11:41:02 <ezzieyguywuf> or g >>> f
11:41:23 <hseg> ezzieyguywuf: g >>> f = f . g
11:41:29 <ezzieyguywuf> interesting
11:44:22 <hseg> hrm. problem is my usecases for discrete log involve p invertible, in which case there is no unique solution
11:44:46 <hseg> (bc a = p^k * m = p^(k+1) * (m/p))
11:50:33 <Rembane> hseg: Are there a finite number of solutions? 
11:50:42 <hseg> infinitely many
11:50:51 <hseg> unless p is a root of unity
11:51:03 <Rembane> Got it, then you need a solution that isn't bad. :)
11:51:07 <hseg> :)
11:56:12 * hackage safe-tensor 0.1.0.0 - Dependently typed tensor algebra  https://hackage.haskell.org/package/safe-tensor-0.1.0.0 (nalex)
11:59:34 <hseg> basically am trying to encode at the type level that certain elements are guaranteed to be invertible in a ring
11:59:58 <hseg> (in particular, want 2 `DivisibleIn` a to be a valid constraint)
12:00:40 <hseg> that way, since my code only divides by a small number of primes, i get logarithmic savings in memory usage
12:01:21 <hseg> (since instead of needing to store the complete denominator, i can store log_{product p} of the denominator)
12:01:33 <hseg> which will usually be much smaller
12:03:04 <hseg> however, my current model is to define a data family Unit :: Type -> Type and insist on having a Group (Unit r) constraint, as well as maps Unit r -> r, r -> Maybe (Unit r)
12:03:29 <hseg> and while i know how to write Unit r -> r here, writing r -> Maybe (Unit r) is a little more tricky
12:24:10 <dminuoso> Im looking for a streamly/conduit friendly way for a sort of bounded FIFO that forgets the oldest message. I can probably roll my own, just wondering whether this is up on hackage somewhere already.
12:25:35 <boxscape> I'm trying to make a heterogeneous Map-ish container - any ideas how to fix this error? https://gist.github.com/JakobBruenker/e7ee5ce1fcab5b11535a091d37158cd4
12:28:16 <dmj`>  Delete k (p ': ps) ps
12:29:04 <boxscape> as in, add an apostrophe?
12:29:54 <sm[m]> https://github.com/antirez/kilo is the nifty 1000LOC visual editor built with no libraries. I am spamming it around today in the hope someone will feel like porting the terminal control bits to haskell, so we can build simple TUIs on windows, without ncurses, etc.
12:30:16 <sm[m]> and I found https://viewsourcecode.org/snaptoken/kilo/ , which seems like a fantastic porting guide
12:30:24 <boxscape> hm actually the last instance header may in fact be wrong though I don't think that's why...
12:32:26 <boxscape> oh, got it
12:32:49 <boxscape> I needed `Delete k ps ps' => Delete k (p:ps) (p:ps')`
12:33:01 <dmj`> If you want to do typeclass induction on a type level list you need to use type level cons afaik
12:33:16 <dmj`> which means ': instead of :
12:33:25 <boxscape> dmj` there's no difference between ': and : at the type level
12:33:37 <dminuoso> boxscape: I suppose there could be if DataKinds is enabled.
12:33:53 <dminuoso> (Dunno whether ': is actually the lifted : or a separate construct)
12:34:05 <sm[m]> ack: "...interacts with the terminal at a low level using the <termios.h> header, which isn’t available on Windows...". Back to the drawing board. :)
12:34:15 <boxscape> hm, I haven't run into a situation with a difference but I suppose there could be weird edge cases
12:51:57 <maerwald> sm[m]: I can live with that
12:57:36 <remexre> hm, is there a workaround for https://github.com/sakshamsharma/ffi-hs-testing/tree/master/library-archive-linking nowadays?
13:00:19 <merijn> remexre: GHC should use the system linker nowadays
13:01:18 <remexre> merijn: I still can't uses a relative path in extra-lib-dirs though; are you saying -L in LDFLAGS should work? or is ther some other flag I need to put somewhere?
13:04:12 * hackage odd-jobs 0.2.2 - A full-featured PostgreSQL-backed job queue (with an admin UI)  https://hackage.haskell.org/package/odd-jobs-0.2.2 (saurabhnanda)
13:04:48 <merijn> remexre: Maybe I didn't see what the issue you meant with that link was? That one talked about linking static archives?
13:10:56 <hseg> ok, found a solution -- have the user provide the decomposition a=p^k themselves
13:11:58 <remexre> merijn: yeah, extra-lib-dirs doesn't work with relative paths
13:12:11 <hseg> one ergonomics problem remains though: how do i define a pattern synonym for what's essentially Tagged (n::Nat) Integer so I can write Exp @2 r for Tag @(T 2) r ?
13:12:30 <remexre> which is a problem when you wanna link to a static archive
13:12:37 <solidus-river> hey all, i've been out of haskell development for a while and never really needed any effect system. I'm suprised to find a lot of options now
13:12:50 <solidus-river> There is tagless final / free monads (which i don't grok yet but am looking at)
13:12:56 <solidus-river> and the classic transformer pattern
13:13:16 <hseg> am being unclear, sorry
13:13:53 <solidus-river> I've read about performance concerns with free monads, are they hard for the compiler to optimize compared to transformers? I'm sure this happens all the time but I'd love to hear some more insight on these tradeoffs
13:13:53 <dminuoso> solidus-river: Note that effect systems are used not out of need, but rather out of desire. :)
13:14:35 <solidus-river> for context I've worked with haskell before and am fairly comfortable with it, i'm about 75% of the way down the typeclassopedia which I can't believe I didn't find a reference to sooner
13:14:50 <hseg> rephrasing: have F :: Nat -> Type, T :: Type -> Type :: Type, C :: forall t a. a -> T t a. I want to write a pattern synonym P :: forall n a. a -> T (F n) a
13:14:53 <hseg> is this possible?
13:17:05 <dmj`> boxscape: TIL, thanks
13:17:41 <boxscape> solidus-river in a lot of applications the performance of the effects system won't matter that much, but there is a proposal to add primitives to ghc that can make effects systems much more competitive in that area
13:17:49 <merijn> solidus-river: I've never used effects systems in ~10 years of Haskell, so... ;)
13:17:59 <remexre> solidus-river: yeah, there's a presentation by lexi-lambda about this, I'll try and find it
13:19:09 <dminuoso> solidus-river: Effect systems have been about a trade off, where most of the time you dont mind the small performance impact but gain visibility of what goes on and sometimes improved testability.
13:19:19 <remexre> solidus-river: https://www.youtube.com/watch?v=0jI-AlWEwYI
13:19:19 <dminuoso> Especially in case of free monads or tagless final
13:19:36 <solidus-river> interesting, if you don't use effect systems then do you use monad stacks and transformers?
13:20:16 <merijn> solidus-river: monad stacks and transformers are the same thing ;)
13:20:33 <dminuoso> solidus-river: You dont have to use any of it.
13:20:39 <oats> are there any good articles/blog posts/whatever that lay out and explain all the alternatives to monad transformers?
13:20:51 <dminuoso> monad transformers are not *necessary* to solve any problem, they are just convenience tools :)
13:21:04 <dminuoso> You can write everything in IO (that needs to have IO), and be done with it.
13:21:33 <solidus-river> the reason i'm trying to get my head around the options finally is I'm embarking on doing some performance intensive stream processing in a webserver that I think will need an effect system or a stack, I'll likely need some State, some db access, and some concurrency communication primitives within a context with access to a socket
13:21:53 <dminuoso> solidus-river: Keep IORefs for state, done! :)
13:22:09 <dminuoso> Drag some environment around with IORefs, TVars, TQueues, etc..
13:22:19 <merijn> solidus-river: Stream processing -> conduit -> done ;)
13:22:21 <dminuoso> Point being, you dont need an effect system to gain all of that.
13:22:42 <merijn> solidus-river: Well, it depends, but for IO-bound tasks conduit is quite nice
13:22:42 <solidus-river> so maybe I can colapse it all down and organize well enough that I don't even need to worry about any of it? That sounds really cool
13:22:59 <dminuoso> solidus-river: Yes. Though conduit is a really cool way to deal with stream processing :)
13:23:00 <solidus-river> Interesting, so maybe instead of worrying so much about that I should delay a choice untill my hands are dirtier with a prototype
13:23:11 <merijn> solidus-river: Yes
13:23:27 <solidus-river> I was looking at streamly since it looks like it has some better performance characteristics and has compatability layers with pipes that zeromq has bindings too
13:23:45 <solidus-river> but I'm worried about the perf of trying to combine those and if its even that reasonable vs just goign with pipes-zmq
13:23:46 <dminuoso> solidus-river: This is something that many resources dont really get into, but when you sit inside IO, with IORefs and all these things in your hand, you can program like you can do in *any* traditional language.
13:24:01 <merijn> solidus-river: tbh, all the "better performance" claims of streamly, etc. only apply if you have like super tight pure streams
13:24:29 <merijn> solidus-river: If there's any form of IO bottle-necking the input of your stream, conduit's overhead is going to be utterly negligible
13:24:37 <solidus-river> dminuoso, then whats the advantage of these effect systems? clearer callouts of exaclty what effects your using :?
13:24:43 <dminuoso> Yes.
13:25:13 <dminuoso> And for some like tagless final or free monads, improved testing since you can reuse the same code but run with different actual effect implementations.
13:25:35 <solidus-river> that sounds desirable enough to want ot use them but aybe i'm over complicating this in my head
13:26:15 <merijn> solidus-river: I stream a couple million rows from an sqlite database into a conduit pipeline to do aggregation stuff and conduit barely even shows up in the profiling report, tbh
13:26:18 <solidus-river> i keep reading that free monads have a high perf impact since its harder for ghc to reason about collapsing them? is this the same deal with tagless final or am I at the point where I should shh until doing some more rtfm'ing
13:26:33 <dminuoso> One of the problem with effect systems and transformers, is that your code quickly becomes non-composable with half of hackage.
13:27:05 <dminuoso> solidus-river: tagless final can impede inlining because GHC needs to see unfoldings to specialize
13:27:20 <dminuoso> (because typeclass polymorphic code is, under the hood, implemented as a function taking a dictionary)
13:27:58 <dminuoso> You can address this with building everything with -fexpose-all-unfoldings, but that likely drives up compilation a lot.
13:28:51 <dminuoso> really most of the time this is not your bottleneck though
13:31:16 * ski . o O ( "Des règles de la logique à la logique des règles" by Jean-Yves Girard in 2014-04-04 at <https://www.youtube.com/watch?v=Nc3pgZxU-Cg> ; cf. "Locus Solum : From the rules of logic to the logic of rules" by ibid in 2001 at <http://girard.perso.math.cnrs.fr/0.pdf> )
13:32:04 <solidus-river> interesting, thats some really awesome insight, the part where it breaks composition with existing libraries is pretty scary
13:33:03 <solidus-river> the ability to test is also usefull though, i wanna get through all the reading available on things like what i wish i knew about haskell and the typeclassopedia before bugging anyone more here
13:33:08 <dminuoso> solidus-river: As a simple example, the second you have a transformer over your IO, everything that has IO in negative position becomes useless the library author has written their primitive specifically in terms of MonadUnliftIO or MonadBaseControl
13:33:13 <edwardk> there's also the approach of just using backpack and locking down the monad at the end by implementing the signature
13:33:40 <edwardk> this has sort of the best of all worlds going for it, except you have to implement the actual monad at the end and wire everything up to it
13:34:07 <solidus-river> edwardk, are there any posts about this approach?
13:34:09 <edwardk> but there is no overhead from the abstraction, because you get compiled directly at the type for each use
13:34:10 <Rembane> edwardk: I have never seen that approach, do you know of an example somewhere?
13:34:33 <edwardk> solidus-river: no. it is just something i've been using on a bunch of private projects lately
13:35:14 <solidus-river> if possible it would be awesome to see some basic example of that style of monad composition
13:35:28 <edwardk> scrap the 'free monad' pattern and just write the module signature with the methods you need parameterized on some abstract 'data M a' in the signature that has all the instances you want and which maybe has a bunch of concrete methods associated with it
13:35:44 <edwardk> then compile against whatever modules you want to use
13:36:28 <edwardk> now you've separately compiled, like using SPECIALIZE at all the final usage monads, but you don't have to deal with the inversion of control that SPECIALIZE would normally imply (where it has to be written with the method, but the monad might come later)
13:36:46 <edwardk> and there's no dictionaries flopping around because most of this is in top level methods in the module signature
13:37:42 <edwardk> downside is that its annoying when dealing with big composite monads and monad transformers, and you may need to do something  like data M s a     to plumb a region parameter through yourself  for things like ST s    or when onee of the parts of the type is parametric
13:38:03 <edwardk> the other approach i use is more evil
13:38:19 <edwardk> and causes veteran haskellers to cry in their beer and curse my name
13:38:40 <edwardk> (more so than lens)
13:40:19 <edwardk> if you aree always going to be working with some kind of stack based on ST s or IO, then using something like https://github.com/ekmett/codex/blob/master/engine/src/Engine/Shader/Include.hs#L69 -- you can use implicit parameters to pass around environments or IORefs of state, this is basically the 'ReaderT design pattern' but using implicit parameters to make the set of arguments smaller when you call code that doesn't use the argument
13:40:49 <solidus-river> parsing o_o
13:40:57 <edwardk> this actually yields more efficient code than piling on one big ReaderT (at least at low optimization levels) because the environment gets cut up into whatever little pieces you need
13:41:16 <edwardk> haderPathToRealPath :: GivenShaderDir => FilePath -> FilePath -- looks like a normal function
13:41:29 <edwardk> type GivenShaderDir = (?shaderDir :: FilePath)
13:41:52 <edwardk> no monad sugar, no round trip through the monad stack to 'ask' for the environment to get the variable
13:42:11 <edwardk> need several of these?
13:42:14 <edwardk> deps :: (GivenIncludeCache, GivenShaderDir, GivenDirectoryWatcher, MonadIO m) => Body -> m (IOThunk IncludeMap)
13:42:48 <edwardk> now what is interesting is what this lets you do when you want to set things up and tear them down
13:42:53 <dminuoso> Ah so with implicit params you optimize unused arguments away?
13:43:01 <dminuoso> as opposed to ReaderT
13:43:05 <edwardk> the backpack story gave you a way to compile for your particular monad, this story is a bit different
13:43:06 <edwardk> yeah
13:43:41 <edwardk> here we're working in the monad you already had (IO or ST s) and are adding 'effects' by using little CPS'd handlers that introduce the GivenWhatever constraints
13:44:00 <edwardk> https://github.com/ekmett/codex/blob/master/engine/src/Engine/Shader/Include.hs#L145
13:44:19 <edwardk> what is nice about this is that you can work directly in IO, and all the unlifted crap that is all over base just works
13:44:38 <edwardk> https://github.com/ekmett/codex/blob/master/engine/src/Engine.hs#L48 -- has a HORRIFYING type
13:44:47 <edwardk> withEngine :: MonadUnliftIO m => (GivenSetupInfo => ((GivenFrameInfo => m a) -> m ()) -> m ()) -> m ()
13:44:51 <edwardk> but using it is easy
13:45:08 <edwardk> https://github.com/ekmett/codex/blob/master/engine/example.hs#L4
13:45:36 <ski> rank-four :o
13:45:40 <edwardk> the user is picking up two layers of effects in there, basically i set up a bunch of stuff at the app start, that provides it access to the shader cache, window, etc.
13:45:56 <edwardk> then i give you a callback function you can use once you've made all the assets you need using those things
13:46:11 <edwardk> and i'll call your function in a loop every frame until you exit
13:46:22 <dsal> I find it refreshing that haskell has so many abstractions that are easy to use but hard to understand.
13:46:53 <edwardk> so in that 'main' i wrote, you can write code in IO in all 3 of those sections, but have access to different GivenFoos at each point
13:48:07 <edwardk> this pattern is useful for ReaderT's that don't use local out of the box, you can also use them with State (just using an IORef/STRef holding the data), and you can model Readers that do change state by putting it in the reference, and using the 'emulate reader with state' tricks, same with emulating writer with state
13:48:30 <edwardk> so now you have composable 'effects' for things like reader, writer, state which TBH is most of what the 'effect system' world offers you anyways
13:49:15 <edwardk> and everything is compiled concretely against IO, and when you have a branch of code that isn't using one of those 'effects' the compiler doesn't pass the  GivenShaderDir parameter down that branch at all
13:49:28 <edwardk> so 99% of my code doesn't pick pay anything
13:49:39 <Lycurgus> 'effect system world' = non FP programming?
13:50:08 <edwardk> doubling down on this approach, you may need to have some of this depend on particular values on hand
13:50:19 <edwardk> fortunately the 'reflection' library has you covered for that
13:50:31 <edwardk> i use something like this for the parser that is in that first module i linked
13:50:32 <edwardk> https://github.com/ekmett/codex/blob/master/engine/src/Engine/Shader/Include.hs#L180
13:51:06 <edwardk> "KnownBase s" is used to access the information about byte offset, and to access the origiinal bytestring but most of the parsers there work without access to those
13:51:33 <Lycurgus> https://hackage.haskell.org/package/fused-effects et. al igess
13:52:20 <edwardk> so in all of that parser code, the only thing that pays for the 'KnownBase" argument being passed to it is the directives combinator that passes it along, and the one that parses include directives
13:52:30 <edwardk> so 'directives include' doesn't pay for it almost anywhere
13:53:09 <edwardk> Lycurgus:  effects aren't really non-functional, they are just a different school of thought of how to handle things colloquially called 'effects' than just relying on monads and monad transformers
13:53:16 <Lycurgus> and https://en.wikipedia.org/wiki/Effect_system but in essence a yes to the original query
13:53:19 <edwardk> there are arguments for and against a 'simpler' system based on efefects
13:54:14 <edwardk> you can find er..... rants... by me explaining the differences and difficulties in saying that effect systems replace the mtl, but i'm perfectly happy for folks to use them for the subset of functionality they cover
13:54:19 <Lycurgus> so taking hs type fp further than monads to the wild but coloring within the lines
13:54:47 <edwardk> sort of 'at right angles' to the monad story
13:55:35 <edwardk> complicate the type theory and try to cover all the things we do with monad transformers. i say at right angles because some of the effect system work is modeled as a monad, some isn't, some decorate the arrows in your type theory with the bag of effects they use, etc.
13:55:42 * hackage fused-effects 1.1.0.0 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-1.1.0.0 (robrix)
13:56:12 <edwardk> then there is the issue that not all effect 'handlers' commute past each other (most do not) and so sometimes the layering matters so the bag model is perhaps too naive
13:56:57 <edwardk> then there are issues about how State s in haskell is lazier than any request/response based effect system _can_ be, and folks taking either side about if that is a good idea or not
13:57:38 <edwardk> similarly the fact that you get the same environment every time you ask a reader 'effect' for it, is a matter of convention, not types, so the compiler can have a MUCH harder tiime optimizing that sort of thing away
13:58:02 * ski . o O ( "Computational effects and operations: an overview" by Gordon Plotkin,John Power in 2002-03-07 at <http://homepages.inf.ed.ac.uk/gdp/publications/Overview.pdf> )
13:58:18 <edwardk> there are graded effect systems that mitigate some of the layering issues i complain about above
13:58:28 <edwardk> and compiler plugins to try to reduce the weight
13:58:37 <edwardk> so its very much not a 'settled' story
13:58:47 <MarcelineVQ> -XModalHaskell
13:58:56 <edwardk> just trying to give a broad (if admittedly uncharitable) view of the design landscape
13:58:58 <ski> perhaps there should be an ordered logic of effects, where some things commute
13:59:46 <edwardk> the other thing is that there are lots of 'effects' we commonly use in monad transformer stacks that aren't 'algebraic effects' -- like continuation passing
14:00:16 <edwardk> so you have to choose to enlarge your theory of effects enough to handle that or just accept the fact that you are now playing in a smaller  sandbox
14:01:16 <edwardk> (but if you do enlarge the sandbox enough to handle that, then some 'effects' you could previously deal sanely with (e.g. writer) don't work if you handle them in the wrong order (well, they don't pass any of the laws you'd expect, and you don't get anything telling you you screwed up)
14:01:21 * ski . o O ( indexed state & indexed composable continuations )
14:02:26 <edwardk> the above two tricks i mentioned (the backpack trick and the io-with-implicit parameters trick) are both limited as well, don't get me wrong, but they have a benefit in terms of computational cost that is hard to refute
14:02:49 <edwardk> ski: re partial ordering /commuting rules, i'm all for it
14:03:26 <edwardk> mind you we sort of have that with mtl, and the commuted versions usually don't have the same meaning, especially when the commuting is only allowed in one direction
14:03:37 <edwardk> e.g. State over EitherT
14:04:27 <ski> @unmtl ContT o (ReaderT rs m) a
14:04:27 <lambdabot> (a -> rs -> m o) -> rs -> m o
14:04:27 <ski> @unmtl StateT rs (ContT o m) a
14:04:28 <lambdabot> rs -> (a -> rs -> m o) -> m o
14:04:38 <edwardk> i kind of want a language of monad monomorphisms to allow you to 'shrink' down to the smallest monad you need to run a bit of code in a principled way, but plumbing them is a pain in the neck
14:05:40 <ski> i kinda want to be able to given names/labels to what's currently the transformer layers
14:05:58 <remexre> fused-effects has that, doesn't it?
14:06:20 <edwardk> so i've been heading in the  direction of writing most of my code mtl style until i KNOW it matters performance wise, then considering moving to one of those other systems i mentioneed, or building a concrete monad with just the right operations and specializing to that and using the monomorphism to embed it
14:06:39 <edwardk> i haven't used fused-effects, but that is how it is sold, yes
14:06:54 <ski> (and then those needs to kept track of in a (in general) ordered environment, but with some commutations, ideally)
14:07:09 <remexre> er I meant that at ski, but I think it applies to yours too
14:07:44 <edwardk> ski: i used to want that, but over time i've sort of drifted away from it, it means type inference goes to hell the moment you have anything remotely polymorphic and i don't really want to be sitting there putting @(SomeBigCrazy Complicated Type s) everywhere in my code to compensate
14:08:04 <ski> edwardk : "monomorphism" here referring to a monic monad morphism ?
14:08:09 <edwardk> yeah
14:08:36 <edwardk> lift is a monad monic morphism for all monad transformers except ProxyT
14:08:44 <ski> mm, okay
14:09:05 <edwardk> data ProxyT m a = ProxyT -- is a really boring monad transformer
14:09:21 <ski> hm, is it terminal ?
14:09:27 <edwardk> yes
14:11:56 <edwardk> this has the same flavor of 'put' for a Lens is either trivial (s is unihabited) or it is injective, similarly 'get' is trivial or surjective -- replace with monic/epic in more categorical lens formulations
14:12:16 <ski> are there some kind of "composable store comonad" operations, possibly some kind of dual thing to `shift' and `reset' ?
14:12:22 <edwardk> theres a couple of talks i gave a few years back that dive into the lens-like connection
14:12:39 <lexi-lambda> edwardk: If you treat non-algebraic operations like `local` as “scoped” effect handlers (i.e. a local handler that is chosen by the enclosing Writer handler), then you can enlarge the sandbox without giving up on the nice laws.
14:13:12 <edwardk> monadic warsaw had a talk about monad transformer homomorphisms and lenses in that category of monad transformers, and then zurihac at google iin zurich had a talk on monic monad morphisms
14:13:36 <edwardk> lexi-lambda: yeah that was what i mentioned about grading the effect system resolving a lot of the issues here
14:14:02 <edwardk> nick wu sold me on that at one point
14:14:08 <lexi-lambda> Aha, I missed that comment while catching up.
14:14:56 <edwardk> nothing in my off-the-cuff explanation here should be too new to you in particular
14:15:31 <lexi-lambda> Perhaps not, but I think we come at things from different perspectives, so it’s always nice to see things from another POV. :)
14:19:09 <lexi-lambda> I think your earlier point about lazy State is a good one, and it’s one I’ve thought about a little bit (but don’t have any answer to). It’s not important very often, so it doesn’t keep my up at night or anything, but it’s a good example of where the continuation-manipulation model breaks down.
14:20:04 <edwardk> most of what i do right now is work in some overarching CPS'd monad, for handling backtracking, and then layer on state-like and reader-like effects using the awful GivenFoo trick I mention above. This has the benefit of being very lightweight in terms of runtime cost and letting me add 'effects' a layer at a time and only pay for the code branches where they get used.
14:20:11 <remexre> ugh, does --extra-lib-dirs not work the same way for cabal v2-repl?
14:20:27 <edwardk> this is admittedly because a lot of what i've been doing lately is work on things that feel like guanxi
14:20:27 <remexre> finally got my static lib working with v2-build and now ghcid is broken :(
14:21:05 <remexre> (user specified .o/.so/.DLL could not be loaded)
14:21:15 <edwardk> no the various given foo tricks are mostly about installing some kind of final acceptance check and some library of propagators specific to a particular domain
14:21:28 <edwardk> er so
14:22:14 <edwardk> i need to push a new version of guanxi fully switched over to this style up to github sometime soon i think 
14:22:34 <lexi-lambda> Yeah, one nice thing about the `eff` approach is that it’s representationally just ReaderT over IO, and handler lookup is O(1), so code that doesn’t need particular effects certainly doesn’t pay for them. Which is to say it’s very similar to what you describe, but tucked behind an effect system interface, and without the need to CPS the program.
14:24:37 <remexre> ugh, okay, cabal v2-repl needs --extra-lib-dirs /and/ LD_LIBRARY_PATH
14:24:40 * remexre sighs...
14:25:24 <lexi-lambda> Another nice thing is that this means it’s possible to mask async exceptions in eff without some elaborate trampolining strategy, since the primops cooperate with the RTS. So you can still have safe resource handling (which is very hard to do with a CPS’d approach).
14:25:52 <remexre> oh, no, ghcid still fails, but the plain repl works
14:26:25 <monochrom> remexre: A little ugly detail about the *.so system. It wants you to specific it once at build time, and once again at execution time, and the two are under different command line options and envvar names.
14:26:28 <lexi-lambda> The main downside is that eff does not provide a monad transformer, so you can’t just stack it on top of some arbitrary monad and call it a day. So the interop story is less pleasant.
14:26:55 <monochrom> "cabal repl" doing both building and launching, it is toasted naturally. :)
14:27:01 <remexre> monochrom: ugh, that'd do it; is the --extra-lib-dirs the compilation one?
14:27:10 <monochrom> yes
14:27:56 <remexre> hm, quick grepping thru --help didn't find the execution one; do you know it off the top of your head?
14:28:46 <monochrom> I learned it kind of the hard way, but I was merely doing pre-writing research for http://www.vex.net/~trebla/haskell/so.xhtml so fewer moving parts were involved and things were easier to discover.
14:29:04 <monochrom> execution relies on LD_LIBRARY_PATH
14:29:26 <remexre> oh, okay; that's what I've already got working, but ghcid still isn't working right
14:31:40 <edwardk> the cpsing of the program here is a rather essential bit of kit because, i'm using it to deliberately replay parts of the continuation in modified contexts
14:32:22 <edwardk> basically i'm just using a sort of hacked together effect system over a 'base effect' that is rather large by most standards
14:32:42 <lexi-lambda> Right, but eff uses new primops (currently in a GHC proposal, not yet accepted, but it looks like it will be) to do continuation manipulation at the RTS level. So you can capture and reply continuations without the need to CPS. :)
14:33:03 <lexi-lambda> err, *replay continuations, rather.
14:33:14 <edwardk> that should work for my usecase
14:33:29 <edwardk> there was a branch of scala (for all i know there still is) that could do that as well
14:33:40 <edwardk> and it was sufficient for a much much older version of this idea
14:34:20 <ski> edwardk : hm, encoding other effects via nqCPS ?
14:34:51 <lexi-lambda> It was surprisingly easy to implement. It turned out the RTS already did something very similar for saving work-in-progress on thunks when receiving an async exception. I ended up not sharing any code with that pathway, but the important invariants were already mostly in place.
14:34:54 <edwardk> pretty close to it anyways, but without any real formal design process at the time
14:34:58 <ski> (a la Andrzej Filinski)
14:35:07 <edwardk> lexi-lambda: makes a ton of sense really
14:35:13 <edwardk> ski: yeah
14:35:36 <lexi-lambda> Yes, it does, I just hadn’t considered the implications!
14:35:40 <edwardk> ski: but in particular they had a whole bunch of code for serializable continuations in the branch in question
14:35:50 <ski> who ?
14:36:01 <edwardk> a guanxi that could run with primitive stack capture could be really nice
14:37:21 <lexi-lambda> In theory, CPS could have better performance than native stack capturing if you do an enormous amount of continuation-manipulation, since the captured continuations are more “persistent” in the sense that you get more sharing. The primops have to copy entire stack chunks between the stack and heap on each invocation. But there are ways to mitigate that cost, and the constant factors are so much lower.
14:37:59 <lexi-lambda> (And avoiding CPS exposes a lot more compiler optimizations, so CPSing has an opportunity cost.)
14:44:09 <edwardk> i'll definitely be benchmarking
14:45:11 <edwardk> anyways, get me a compiler extension and you'll have a loud ally with a very strange set of usecases on hand
14:45:28 <lexi-lambda> I will be very interested to see your benchmarks. :)
14:58:55 <edwardk> now if we can only get a graal/truffle like framework i can do all my coding in ghc ;)
14:59:55 <ski> what's that ?
15:01:13 <edwardk> github.com/ekmett/cadenza is the project in question
15:01:59 <edwardk> but graal is basically rebuilding the jit for the jvm in java itself rather than c++, and truffle is a sort of toolkit for hooking into that jit for your own interpreted languages, which sort of turns it into a jit for your language, futamura style
15:03:39 <edwardk> in particular that cadenza thing is about trying to use its ability to write all the slow path stuff in java (well, kotlin) and figuring out how to get the jvm to run functional code (dependent or not) in a fast way
15:05:15 <edwardk> pipe dream is  that it'd be fast enough to compete with a real compiler (it might be but the rampup times are long), and the fact that it works as a jit would let it be used to speed up _compilation_ times when used on a dependent type checker
15:05:23 <infinisil> lexi-lambda: Just watched your eff talk at ZuriHac, awesome work! Am very excited for the future of effects in haskell :)
15:06:27 <ski> hm, interesting
15:06:45 <edwardk> and (going further down the chain of possibilities to smaller and smaller odds) if it was fast enough for evaluating something that felt like ghc core, maybe i could just run that on top of it, and use it as way to lift over a bunch of haskell code to run on top of it, so i could write most of the compiler in haskell, jus a few typechecking bits in more laborious java/kotlin and get a fast dependent type checker for a fraction of the 
15:06:45 <edwardk> effort
15:08:03 <edwardk> in practice? the kotlin stuff turned out to be a bit more effort than i'd hoped, and its really hard to debug some of the graph rewrite stuff you want to have happen, and the tooling is designed for languages like python, ruby, javascript more than haskell, so i had to do a lot of work to try to make it usable (acertain popped up part way through the project and did the yeoman's work to actually get it to run anything interesting)
15:08:35 <remexre>  oh wait, wtf, just realized
15:08:46 <remexre> the linker errors are coming from the actual haskell code I'm running
15:08:51 <remexre> does ghci lazy-load libraries?
15:11:11 <monochrom> yes
15:11:30 <remexre> bleugh
15:12:50 <remexre> so yeah, looks like --extra-lib-dirs and LD_LIBRARY_PATH are insufficient
15:13:00 <remexre> because at some point ld.gold is being called without -L
15:13:12 <remexre> and LDFLAGS=-L$(LD_LIBRARY_PATH) is insufficient
15:17:07 <hseg> q: is there a way to reorder tyvars in class method signatures?
15:17:36 <infinisil> hseg: You can explicitly forall
15:17:45 <hseg> eg say class P a b where forall b a. P a b => b -> a
15:18:17 <hseg> ghc seems to think that makes the method independent of the actual tyvars at which the class is instantiated
15:18:21 <ski> that won't work, i'm pretty sure
15:18:24 <ski> yes
15:18:45 <ski> it would talk about different `a' and `b', making the method itself polymorphic
15:18:45 <infinisil> Hm..
15:18:47 <hseg> http://ix.io/2r9C
15:19:07 <ski> you can define a separate overloaded operation which has reordered
15:19:29 <infinisil> hseg: Maybe `forall bb aa . (a ~ bb, b ~ aa) => bb -> aa
15:19:36 <infinisil> Nasty though
15:19:39 <ski> hm, creative
15:20:03 <hseg> :/ all i want is to be able to double-check my intuition of the tyvar order against ghc's
15:20:25 <hseg> which i do by inserting otherwise unnecessary quantifiers and seeing if things change
15:22:03 <hseg> welp. a quick ghci session with -fprint-explicit-foralls is enough, but it's annoying that i can't document all my expectations to ghc
15:26:48 <jumper149> When you mismatch types GHC often says: "cannot construct the infinite type: a0 ~ (a0,b)" or something similar. What does infinite type actually mean here?
15:27:37 <hseg> bloody hell. the fact that p :: b -> a is a member of the class P a b means that ghc infers the order p :: forall {a} {b}. P a b => b -> a. in contrast, if p were toplevel, ghc would infer p :: forall {b} {a}. b -> a
15:27:54 <hseg> cue a wall-full of type errors
15:28:43 <hpc> jumper149: so you know how you can make an infinite list by writing something like "let ones = 1 : ones"? the exact same thing is happening with the type
15:28:45 <ski> jumper149 : you're mixing up a pair with a component of a pair
15:28:50 <MarcelineVQ> jumper149: that if we try to unify  a0  and  (a0,b)  we'll end up with infinite steps of ((a0,b),b)   (((a0,b),b),b)  etc
15:28:53 <boxscape> jumper149 you can look at a ~ (a, b) as an equation, and then you can substitute the right side of the equation for a, and (a, b) becomes ((a, b), b). Then you can do it again, and get (((a, b), b), b), and so on, ad infinitum
15:29:00 <boxscape> well, I'm too late
15:29:22 <hpc> majestic stereo at its finest
15:29:41 <rand809809> Is there a haskell tool where I can highlight a value, and it'll infer the type for me?
15:30:01 <ski> jumper149 : most likely, you've either forgotten to extract the first component (with `fst' or pattern-matching) of a pair you're using, or else you're forgetting to pair up the first component with a corresponding second one, somewhere
15:30:14 <dsal> rand809809: flycheck does that for me.
15:30:52 <ski> jumper149 : if you show you're code, we'd probably be able to give better diagnostics than just guessing from the type error
15:30:57 <ski> s/you're/your/
15:31:39 <jumper149> ski: I don't have any problem. I am just trying to understand where "infinite type" comes from here.
15:31:56 <rand809809> hmm, so what is an editor with good support for haskell? I've been using vscode with hlint.
15:31:58 <jumper149> What is the type inference ghc uses called?
15:32:04 <ski> @quote reading.scrollback
15:32:04 <lambdabot> hpc says: here in #haskell we are aware that reading scrollback is hard, that's why we always answer in majestic stereo
15:32:31 <hpc> heh
15:33:07 <hpc> jumper149: (~) is sort of type-level equality
15:33:16 <hpc> so you have n equation, a0 = (a0, b)
15:33:50 <ski> jumper149 : types are inferred from usage of values. in your case, the inferred type would be `((((...,b),b),b),b)', an infinite type, which is almost surely a mistake, due to a mixup like what i mentioned. another common "infinite type" situation is `a = [a]', leading to `[[[[...]]]]', which stems from using a list element where a list was expected, or vice versa
15:33:50 <hpc> and the solution to that is that a0 = ((((((..., b), b), ...)
15:33:56 <hpc> which is infinitely large
15:34:06 <hpc> and it's just a rule that you can't have that in ghc
15:34:08 <monochrom> jumper149: There are type systems (not adopted in practice) that allows infinite types. Look for "equirecursive types" and/vs "isorecursive types". All practical languages including Haskell go with isorecursive types, it is easier to reason about.
15:34:11 <lexi-lambda> jumper149: re, the type inference GHC uses, the word you might be looking for is “unification”
15:34:52 <ski> (in case it's not a mistake, you'll have to define your own recursive type. preferably using `newtype'. but this is common, which is (one reason) why the type system doesn't allow such "infinite types")
15:35:07 <boxscape> another keyword re: type inference is "Hindley-Milner type system", which is what Haskell's type system is based on and has a few properties that lend themselves particularly well to inference
15:35:17 <boxscape> jumper149
15:35:31 <ski> (if someone wants to play with equirecursive types, they can try `ocaml -rectypes')
15:36:17 <jumper149> Hey guys, I appreciate all the help you are trying to give me to solve a problem, but I do totally understand how to fix this common issue. The concept of an infinite type that could be infered this way is just something I don't understand yet^^
15:37:02 <lexi-lambda> monochrom: I don’t think it’s true that “all practical languages go with isorecursive types”; I think TypeScript supports a form of equirecursive types
15:37:08 <jumper149> monochrom: ill read into that a little :)
15:38:22 <rand809809> If I wanted to write a tool(vs code plugin), which allows me to infer types on highlighting, how would I go about it?
15:39:00 <rand809809> Coming from someone who doesn't know anything about type inference
15:39:06 <lexi-lambda> jumper149: it’s not clear to me if you’re asking “I don’t understand what an ‘infinite type’ is” or “I don’t understand why the compiler would attempt to infer an infinite type”
15:39:20 <monochrom> I am glad I decided not to spend time on TypeScript. :)
15:40:43 <ski> lexi-lambda : and OCaml
15:41:41 <ski> (but in the case of OCaml, cycles must go through at least one object type (unless you enable `-rectypes'))
15:42:41 <jumper149> lexi-lambda: The latter. Something like `type A = (Int,A)` doesn't exist in haskell. Is the compiler actually trying to infer a fitting type?
15:42:44 <boxscape> hm a type like (a, (a, (a, ....))) seems fairly similar to Stream a, where Stream is defined as Stream a = Cons a (Stream a)
15:43:13 <ski> jumper149 : yes, it's trying to infer something like that, but detects the would-nbe cycle, and not having it
15:43:16 <jumper149> boxscape: is Stream data or type synonym?
15:43:30 <boxscape> jumper149 whoops, data
15:43:47 <boxscape> jumper149 though I don't know if they're actually related in a meaningful way
15:43:51 <lexi-lambda> ski: yes, but I like that TypeScript now has a bunch of fancy type system features now, too, since nobody can say “okay but nobody actually uses TypeScript”
15:44:07 <lexi-lambda> ski: yes, but I like that TypeScript now has a bunch of fancy type system features now, too, since nobody can say “okay but nobody actually uses TypeScript”
15:44:36 <ski> lexi-lambda : i wonder whether the reason for it in TypeScript is also because of cyclic object/record types .. various "duck typing" stuff
15:45:04 <boxscape> oh I had wondered if things like that were compatible with typescripts type system
15:45:22 <boxscape> or rather I had assumed they weren't, but thought about how that's interesting, I guess
15:46:39 <lexi-lambda> (Oops, my client double-sent that, apparently. Sorry.)
15:47:25 <monochrom> Naturally, there is also strong correlation between liking structural typing and liking equirecursive, between liking nominal typing and liking isorecursive.
15:48:11 <ski> yes
15:51:19 <lexi-lambda_> jumper149: Suppose you write a function like `f (Identity x) = f x`. GHC will now try to infer f’s type. It knows it must have a type like `Identity t1 -> t2` because it clearly takes an Identity as an argument. But what is t1?
15:52:39 <lexi-lambda_> jumper149: To find out, GHC looks at the body of f. It finds a call `f x`, and it knows the argument to `f` must have to have type `Identity t1`. But it also knows that x has type t1, since it’s what was inside the Identity wrapper.
15:53:19 <lexi-lambda_> So GHC concludes that t1 must be equal to `Identity t1`. It’s the only possible solution to those constraints.
15:53:44 * ski . o O ( polymorphic recursion )
15:53:45 <hseg> hrm. ghc complains about unused-top-binds for a type i'm using as a type-level tag. is there some other way i'm _supposed_ to write that code?
15:54:11 <lexi-lambda_> But if we take `t1 := Identity t1` and substitute the result back into `Identity t1`, we get `Identity (Identity t1)`. And that still has a t1 in it. Which is a problem, because we can keep substituting forever.
15:55:16 <lexi-lambda_> So we’d end up with an infinitely-large type. And that’s not allowed.
15:55:46 <ski> @type let subst :: Monad m => (var0 -> m var0) -> m var0 -> m var1; subst env exp = do var <- expr; subst env (env var) in subst
15:55:48 <lambdabot> error:
15:55:48 <lambdabot>     • Couldn't match type ‘var2’ with ‘Expr’
15:55:48 <lambdabot>       ‘var2’ is a rigid type variable bound by
15:56:00 <ski> @type let subst :: Monad m => (var0 -> m var0) -> m var0 -> m var1; subst env exp = do var <- exp; subst env (env var) in subst
15:56:00 <lexi-lambda_> ski: I’ve been working with -XMonoLocalBinds for so long I no longer remember if GHC infers polymorphic recursion without it (I seem to remember it does not, but I could be wrong)
15:56:01 <lambdabot> Monad m => (var0 -> m var0) -> m var0 -> m var1
15:56:07 <jumper149> lexi-lambda_: ty, that seems like a solid explanation :)
15:56:12 <ski> lexi-lambda_ : it doesn't
15:56:12 * hackage hextra 0.3.0.3 - Generic and niche utility functions and more for Haskell.  https://hackage.haskell.org/package/hextra-0.3.0.3 (anselmschueler)
15:56:29 <lexi-lambda_> Okay, good, I’m not that forgetful :)
16:00:37 <lexi-lambda_> ski: Also, to answer your earlier question, the answer is yes, it’s used for inductive record type definitions like `type JSON = number | boolean | string | [JSON] | { [string]: JSON }` (syntax might be wrong; I don’t actually write TS)
16:01:48 <ski> that sounds like it's more variant rather than record, judging from that example
16:02:25 <lexi-lambda_> well, it’s both, since the last case is a recursive record (well, I guess it’s a dictionary, but in TS they’re largely the same thing)
16:02:30 <lexi-lambda_> (I don’t believe TS actually has syntax for equirecursive mu, it’s just inferred from recursive alias definitions)
16:04:20 <ski> mm. i was more thinking of the "record of methods" stuff
16:05:06 <lexi-lambda_> Ah, I see. I think that’s less common, since TS generally uses nominal interfaces to describe which methods things have.
16:05:59 <lexi-lambda_> (I think Flow is more structural, so it might matter more there, but I think TS has officially “won,” so Flow is not all that relevant anymore)
16:06:20 <boxscape> lexi-lambda_ re: syntax IIRC JSON[] would be an array and [JSON] would be the type of tuples with one element
16:06:41 <lexi-lambda_> Ah, thanks. I couldn’t remember if it was JSON[] or [JSON] or Array<JSON>.
16:13:26 <ski> lexi-lambda_ : did you ever look into the object system of OCaml ?
16:13:48 <lexi-lambda_> no, I’m not very familiar with it, I’m afraid
16:13:55 <boxscape> it seems strange to give Void# a name that's rather reminiscent of Void, when Void# does, in fact, have a non-bottom element (namely void#)
16:14:20 * ski nods
16:14:33 <ski> it can express "binary methods" and "clone methods"
16:14:54 <ski> boxscape : `Void#' ?
16:15:01 <boxscape> ski it's in GHC.Exts
16:15:22 <boxscape> % :t GHC.Exts.void#
16:15:22 <yahb> boxscape: Void#
16:15:37 <boxscape> % :k GHC.Exts.Void#
16:15:37 <yahb> boxscape: TYPE ('TupleRep '[])
16:16:17 <ski> is it something like an empty unboxed tuple ?
16:16:39 <lexi-lambda_> boxscape: I think it’s intended to evoke the fact that it has no runtime representation, but I agree the inconsistency with Data.Void.Void is unfortunate
16:16:41 * ski 's still waiting for `Control.Monad.void' to be renamed ..
16:16:47 <boxscape> I see
16:16:51 <ski> hello crestfallen
16:16:56 <lexi-lambda_> ski: Yes, (# #) has the same kind
16:17:13 <boxscape> presumably (# #) really doesn't have any elements?
16:17:18 <crestfallen> hi ski !
16:17:38 <lexi-lambda_> boxscape: No, (# #) inhabits (# #), just as () inhabits ()
16:17:49 <boxscape> oh, right
16:17:50 <ski> yep
16:21:20 <boxscape> I guess empty unboxed sums would qualify though? But as far as I can tell there isn't even syntax for an empty unboxed sum, only inhabited ones
16:22:00 <ski> hm, i think i have a different idea of what "unboxed sum" is supposed to mean
16:22:03 <lexi-lambda_> Yes, I don’t believe there exists any unlifted uninhabited type
16:22:27 <boxscape> okay
16:23:23 <lexi-lambda_> I guess `Int ~# Bool` is an uninhabited unlifted type :)
16:24:52 <boxscape> seems like https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0265-unlifted-datatypes.rst should also make it possible to declare them though I'm a bit confused by "BoxedRep"
16:25:45 <lexi-lambda_> BoxedRep is part of https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0203-pointer-rep.rst
16:25:53 <boxscape> Ah, thanks
16:26:04 <ezzieyguywuf> I'm a bit confused about STM. Till now, I've been using the functions and `atomically` together when already in IO. But let's say I have a pure function, `myFunc :: TQueue a -> TQueue a` -> all I want to do is use writeTQueue to add an item. But of course, writeTQueue returns an STM, so maybe my function is `TQueue a -> STM (TQueue a)`, but writeTQueue returns `STM ()`, so...do I just return back my 
16:26:10 <ezzieyguywuf> original TQueue?
16:26:11 <ezzieyguywuf> or am I misusing STM here?
16:26:53 <slack1256> Is there a combineLatest operator for the Pipes ecosystem? This operator exists on RxSwift for example.
16:26:59 <solonarv> yes, you are - you can't run an STM computation purely
16:27:14 <solonarv> 'atomically :: STM a -> IO a' is the only way
16:27:20 <lexi-lambda_> ezzieyguywuf: TQueues are mutable, so there’s no reason to return a TQueue at all
16:27:22 <ezzieyguywuf> ok, that makes sense
16:27:44 <solonarv> you can add unsafePerformIO to that, but obviously that's unsafe and requires a great deal of thought first
16:28:25 <ezzieyguywuf> but, for example, I can build a chain of State computations up ahead of time, to runState later, i.e. ` makeState1 >>= makeState2 >>= makeState3` etc... and I can just pass around `MyState` until I finally actually need the state, and I issue `runState chainOfState someInitialState`
16:28:30 <ezzieyguywuf> is STM meant to be used similarly or nah?
16:28:32 <lexi-lambda_> `atomically` inside of `unsafePerformIO` is even more deeply unsafe than `unsafePerformIO` is in general (the docs for `atomically` explain)
16:28:50 <lexi-lambda_> ezzieyguywuf: it’s possible you want ST, not STM
16:29:10 <lexi-lambda_> (the names are confusingly similar but are unrelated)
16:29:32 <ezzieyguywuf> pretty sure I want STM, I was just trying to draw an analogue between the two
16:29:49 <ezzieyguywuf> so is it expected to _always_ use an STM function with atomically?
16:29:58 <ezzieyguywuf> i.e. I'mm not expected to pass around an `STM a`?
16:30:06 <lexi-lambda_> you can build up an STM computation the same way you can build up a State computation; that’s fine
16:30:33 <lexi-lambda_> but the only way to run it in the end is to pass it to atomically, which must be in IO
16:30:44 <ezzieyguywuf> ok, that makes sense
16:32:04 <lexi-lambda_> the major difference is that a State computation doesn’t have any state “inside” it; it’s a function that transforms some state to be provided later
16:32:29 <lexi-lambda_> but a TVar, TQueue, etc. is itself a mutable reference, which really does hold state inside it
16:32:36 <ezzieyguywuf> so my function needs to either return an STM or an IO
16:33:06 <ezzieyguywuf> hrm, yea conceptually I consider a State as "here's a series of function to run on some State"
16:33:33 <ezzieyguywuf> I guess I really need to consider whether it even amkes any sense to defer the evaluation of the STM operation.
16:33:35 <lexi-lambda_> yes, if you want to use STM, you must be in the STM monad or in IO (so you can enter the STM monad via atomically)
16:33:52 <ezzieyguywuf> thank you for the help.
16:34:25 <lexi-lambda_> you can think of an `STM a` computation as an imperative procedure that accepts no arguments and modifies some mutable state transactionally
16:34:54 <lexi-lambda_> so it makes sense to “defer the evaluation of an STM operation” if you would pass around a procedure and invoke it later in an imperative context, too
16:35:29 <lexi-lambda_> but it doesn’t get you any additional purity; it’s just waiting to do the imperative thing later
16:35:36 <ezzieyguywuf> yes, I get that
16:35:40 <ezzieyguywuf> :) thanks again!
16:50:47 <monochrom> The reason STM ≠ IO is that e.g. atomically (step1 >> step2) ≠ (atomically step1) >> (atomically step2)
16:51:13 <monochrom> Also STM avails orElse that can't be done in IO.
16:51:13 <ezzieyguywuf> monochrom: I get why `atomically` is needed ad why STM <fancy symbol> IO
16:51:19 <ezzieyguywuf> ≠
16:51:20 <ezzieyguywuf> hey I did it!
16:52:21 <monochrom> Java people etc try to do software transaction memory too. The problems they run into all trace back to not having a separate STM type like we do.
16:53:01 <ezzieyguywuf> have you all ever used rust? this is anectodal, but it seems to me that many long time haskellers eventually end up using rust instead for some reason.
16:53:13 <ezzieyguywuf> I've been very happy with haskell so far - it's fun
16:53:19 <monochrom> I end up not using Rust. :)
16:53:31 <ezzieyguywuf> I'm just trying to understand why - it seems - that people eventually end up with rust
16:53:43 <ezzieyguywuf> monochrom: have you noticed any such trend, or am I maybe reading into things
16:53:47 <dolio> Sometimes people who have been writing Haskell for 10 years like to learn something new.
16:53:55 <monochrom> I made the mistake of "I want to learn Rust, so let me learn Rust by coding up linked lists". That failed utterly.
16:54:26 <jumper149> ezzieyguywuf: One thing I dislike about haskell is that the community can't decide anything. So there are always different approaches which are only more or less compatible with each other.
16:54:43 <ezzieyguywuf> jumper149: I can see that getting frustrating
16:54:45 <monochrom> I think Haskellers respect Rust more than they respect other imperative languages.
16:55:26 <ezzieyguywuf> I also think that's part of what makes it what it is - I've seen a video of one of the haskell founder dudes who said something along teh lines of "we just...do what we want. and sometimes it breaks backwards compatibility, and people adjust. But it's let us get to where we are now."
16:56:44 <ski> @quote we.failed
16:56:44 <lambdabot> Baughn says: "<dpratt71> so I read somewhere that the unofficial  motto of Haskell was \"avoid success at all costs\"...<Baughn> dpratt71: Yeah. We failed."
16:56:58 <ezzieyguywuf> hah, yea something like that.
16:58:43 <ski> (btw, iirc that's meant to be parsed (/grouped/bracketed/associated) as "avoid (success at all costs)" rather than as "(avoid success) at all costs" ? but perhaps it's also been some of the latter ? that is, keep the door open for more, possibly backward-compatibility-breaking, experimentation, with the language)
16:59:21 <monochrom> I think it's a joke, and part of the joke is the pun, the ambiguity.
16:59:48 <dolio> I think people who say it's the former are revising history.
16:59:59 <ezzieyguywuf> I read it as (success at all costs)
17:01:52 <monochrom> You look at titles like "how to add laziness to a strict language without even being odd" and you know these people are always going for ambiguity and they always mean both.
17:02:36 <ski> yes, we need more jokes in research papers ;)
17:02:45 <ezzieyguywuf> lol, "even being odd"
17:04:53 <boxscape> Just saw "the separation of Church from state" today
17:06:55 <ezzieyguywuf> hm, I have two `TQueue`, let's call them `qA` and `qB`. If either is not empty, then I want to do two things: (1) execute a few IO, specific to each, i.e. `doA :: IO a` or `doB :: IO b`, and finally `ifEitherAorB :: IO ()`. I can't think of a good way to do this other than something like `checkA <- atomically $ isEmptyTQueue qA; checkB <- atomically $ isEmptyTQueue qB; when checkA do:; when checkB 
17:07:01 <ezzieyguywuf> doB; when (checkA || checkB) ifEitherAorB`
17:07:17 <ezzieyguywuf> s/do:/doA/
17:07:49 <ski> @quote separation
17:07:49 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
17:07:50 <lambdabot> state.
17:08:42 <ski> @quote church.and.state!
17:08:42 <lambdabot> shapr says: Haskell separates Church and state!
17:08:57 <ski> @quote are.dual
17:08:57 <lambdabot> ski says: I'd rather say that in Haskell, Church and State are dual
17:09:25 <boxscape> church and cochurch?
17:10:30 <ski> Church encoding of `mu r. ..r..' as `forall r. (..r.. -> r) -> r' vs. State encoding of `nu s. ..s..' as `exists s. (s,s -> ..s..)'
17:10:45 <nil> <sclv> A student asks master wadler, what is the nature of a recursive type? Wadler replies: Mu.
17:10:50 <nil> i can't believe that one isn't in the bot
17:10:52 <ski> haha
17:10:56 <ski> it ought to be
17:11:02 <nil> couldn't find it
17:11:07 <ski> @remember sclv A student asks master wadler, what is the nature of a recursive type? Wadler replies: Mu.
17:11:07 <lambdabot> It is forever etched in my memory.
17:11:19 <monochrom> ezzieyguywuf: If it's important that sometimes you want both doA and doB to happen, I think it's as good as it gets.
17:11:37 * ezzieyguywuf nods "Thanks for giving it a look monochrom"
17:11:57 * ski was almost fearing
17:11:59 <ski> @quote majestic.stereo!
17:11:59 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
17:29:11 <solonarv> you can write an STM computation that checks both queues at once, and returns the IO action to perform
17:31:03 <ezzieyguywuf> hrm...
17:31:25 <ezzieyguywuf> `checkQueues :: TQueue a -> TQueue b -> STM (IO ())`, something like that?
17:31:29 <solonarv> yup
17:31:53 <solonarv> writing a gist right now
17:33:50 <ezzieyguywuf> well, trying to decide if that would be any better (i.e. more readable, more maintainable) then the current solution (it's incomplete but you get the picture) https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/MyCAD/GUI/GL_Renderer.hs#L105
17:35:46 <solonarv> ezzieyguywuf: https://gist.github.com/Solonarv/b5c32b2a97132594178f98698c8b02bc
17:37:20 <solonarv> with your approach you are reading from the queues multiple times, in different 'atomically' blocks
17:37:27 <solonarv> so they could change between one read and the next
17:37:47 <solonarv> (if there is another thread writing to the TQueue for example)
17:38:01 <ezzieyguywuf> ah hah, this is a good point
17:39:23 <ezzieyguywuf> solonarv: very nice, thanks for the gist!
17:47:24 <ezzieyguywuf> neat, so traverse_/for_ is like fmap . sequence_ (but not really: but kind of!)
17:48:07 <solonarv> you've got it backwards, but yes
17:48:16 <solonarv> traverse_ f = sequence_ . fmap f
17:48:46 <ezzieyguywuf> handy!
17:49:03 <solonarv> yes, for_ and traverse_ are quite handy for this sort of code
17:49:11 <solonarv> (note, mapM_ is the same thing as traverse_)
17:49:32 <ezzieyguywuf> I had it in that order at first, but checked the types in ghci and it didn't match
17:49:37 <monochrom> This is why we keep mixing up traverse_ and sequence_.
17:49:58 <dexterfoo> how can i easily run a single quickcheck test on all of my cpu cores?
17:53:31 <ezzieyguywuf> solonarv: what is getTQueue?
17:54:13 <ezzieyguywuf> (and tryGetTQueue)
17:54:40 <ezzieyguywuf> maybe flushTQueue and tryReadTQueue?
17:55:24 <ezzieyguywuf> wow! `optional` is new to me too, seems helpful.
17:56:10 <ezzieyguywuf> nvm, lol tryGetTQueue is one of teh functions you defined, but getTQueue is not.
17:57:17 <solonarv> getTQueue is part of the TQueue API
17:57:42 <solonarv> it's exported from Control.Concurrent.STM.TQueue (which is reexported from Control.Concurrent.STM)
17:58:15 <ezzieyguywuf> ah, I'm looking at Classy-STM for some reason
17:58:17 <ezzieyguywuf> wrong documentation
17:58:17 <solonarv> you could just flushTQueue and then check whether the list you get is empty
17:58:42 <ezzieyguywuf> nope, don't see it here either: https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TQueue.html
17:58:57 <ezzieyguywuf> solonarv: or isEmptyTQueue will tell me if its empty.
17:59:05 <solonarv> oh wow I am tired
17:59:16 <fosterite> Does anyone remember a recent article comparing newtypes with the miranda method, where certain functions have a different type in some scopes?
17:59:19 <solonarv> I meant readTQueue, and of course tryReadTQueue already exists as well
18:00:36 <ezzieyguywuf> solonarv: ah, no problems, I appreciate your help!
18:01:42 <fosterite> miranda called them abstypes
18:07:56 <fosterite> It was Wadler's Abstract Data Types Without the Types
18:10:11 <ski> fosterite : `abstype' is in SML
18:11:20 <ezzieyguywuf> solonarv: in your gist, this would only process a single item from the TQueue, correct, not the whole deal?
18:11:27 <fosterite> ski: does it work like miranda? my real goal was the papers about how it interacts with typeclasses, which are Yallop 2008, 2010 fwiw
18:11:39 <ski> fosterite : also cf. "Restricted Type synonyms" in Hugs <https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.3.5>
18:11:41 <solonarv> ezzieyguywuf: yes correct
18:11:51 <ski> i don't recall seeing this in Miranda
18:12:07 <ski> if augustss was here, i'd bet he could answer ..
18:12:20 <fosterite> ski: oh neat thanks for the hugs tip
18:12:54 <fosterite> ski: the wadler paper says miranda has them with very similar syntax to the hugs syntax (probably where hugs got it)
18:13:05 <ski> (i'd like something like this, or some other mechanism for exporting a type synonym abstractly, in GHC ..)
18:13:13 <ski> mhm, i see
18:13:47 <solonarv> ezzieyguywuf: updated the gist
18:13:58 <solonarv> as you can see it's not much different
18:14:16 <solonarv> ski: I think backpack might be able to do something like that?
18:14:31 * ezzieyguywuf nods
18:15:34 <ezzieyguywuf> hah, there's lots I must still learn, I learned a lot today about Applicative and Foldable, i.e. traverse, null
18:16:12 <ski> solonarv : mm. i ought to have checked, i suppose
18:18:17 <ezzieyguywuf> solonarv: thanks again for the gist, i've learned so much :)
19:21:31 <L29Ah> okay, bikeshedding time
19:21:39 <L29Ah> i think (&) is better than ($)
19:22:00 <L29Ah> * it's natural for programmers who come from OOP languages where . is used likewise
19:22:58 <L29Ah> * it is comfortable to use with IDEs that, after you write your value and &, can suggest you some sensible functions that can be applied to the value of a known type, unlike with $ that won't give much useful cues
19:24:05 <Axman6> optimising for the benefit of OOP programmers seems antithetical to avoiding success at all costs to me
19:24:05 <L29Ah> so, are there advantages of ($)?
19:31:14 <Axman6> it's consistent with how functions are defined in the language and the idioms that have been developed by the community. that doesn't mean either is better, they are both style choices rather than having some inherent technical advantage. you'll find we use & a lot in certain types of code like lens heavy code, because it maps quite well to the OOP style that is invoked by the idioms of the library
19:33:30 <OmegaDoug> Can anyone point to an example cabal file that includes c libraries? I have libraries which I can use with the D compiler but not with GHC 8.10. I'd first like to check that I have the cabal file configured correctly as I haven't tried cabal before this.
19:33:54 <L29Ah> OmegaDoug: check gtk3 on hackage
19:34:02 <Axman6> also the benefits from IDEs in HAskell tend to be less because we tend tp have much more general functions and providing good suggestions is hard because of this - if I write x & and wait for the IDE to tell me usefull suggestiopns, I will always get id, const, flip, etc
19:35:09 <L29Ah> just ban nonspecific types and it should be good
19:35:22 * L29Ah never used a haskell IDE tho
19:35:38 <OmegaDoug> L29Ah I'll take a look there, thanks
19:35:44 <dolio> There's just no reason that & is better than $ for IDE suggestions.
19:35:49 <Axman6> what's a non specific type?
19:36:22 <L29Ah> Axman6: that's a type variable not bound by any constraints
19:37:15 <Axman6> do we suggest pure? what about traverse? show?
19:37:17 <L29Ah> dolio: you're writing code from left to right, and if you use $, you'll have to jump backwards every time to get a hint from IDE
19:37:32 <L29Ah> no, pure takes a
19:37:55 <L29Ah> traverse and show are ok // probably should have a function-by-function blacklist indeed (:
19:38:51 <Axman6> what about myAwesomeFunction :: Monad m => m a -> m a; myAwesomeFunction m = m >> m?
19:38:58 <Axman6> nothing there is specific
19:39:11 <Axman6> but I probably want to use traverse more often than I want to use myAwesomeFunction
19:39:21 <L29Ah> dolio: also i won't be surprised if IDEs don't expect you to want them to generate code to the left of a piece of your code, and don't implement such stuff
19:39:32 <L29Ah> s/generate/suggest/
19:40:23 <dolio> It sounds like these IDEs aren't very good.
19:40:43 <L29Ah> Axman6: you know traverse, and it can be typed easily, so you don't need suggestions of it; i'm mostly concerned about unknown libraries that you import and then switch from haddock to editor and back a hundred of times before getting done with your simple use case
19:40:56 <dolio> But there could be a good IDE instead.
19:40:59 <Axman6> I use TabNine, it doesn't expect anything, it uses Machine Learning(TM)
19:41:11 <Axman6> it's insanely good at knowing what I want to write next
19:41:20 <Axman6> like, scary good
19:41:31 <L29Ah> Axman6: but is it good at reading and presenting haddock?
19:41:59 <Axman6> that has nothing to do with what TabNine does, it's a completion plugin
19:42:15 <L29Ah> tabnine seems badass, i need to give it a try
19:42:16 <Axman6> VS Code can show thise things just fine though
19:42:26 <Axman6> those*
19:42:29 <L29Ah> there's a vim plugin even
19:44:22 <L29Ah> ouch, it's closed source :/
20:27:44 <jle`> :\
20:48:34 <iqubic`> Perhaps a haskell constraint logic programming library for haskell.
20:50:56 <iqubic> Internet cut out momentarily. Did I miss any responses to my query?
20:51:24 <L29Ah> there was no query
20:51:51 <iqubic> In this case, query means question.
20:52:22 <iqubic> And sent a message about prolog and my newfound love of it, ending with this line: "Is there anyway I can get the best of both worlds?"
20:53:24 <iqubic> Or did that not get sent?
20:54:34 <L29Ah> it didn't
20:57:30 <iqubic> I'm currently really enjoying Prolog because of theconstraint logic programming. However, I'm missing          the statically typed nature of Haskell. Is there          anyway I can get the best of both worlds?
20:57:36 <iqubic> Sorry for the spacing there.
21:07:58 <dibblego> Control.Monad.Logic
21:12:49 <L29Ah> > [1,2,3,4] >> [1,3]
21:12:51 <lambdabot>  [1,3,1,3,1,3,1,3]
21:20:38 <iqubic> How does Control.Monad.Logic work?
21:20:56 <iqubic> Are there any guides on it?
21:21:08 <dibblego> yes, linked in the documentation
21:22:25 <iqubic> Cool
21:27:50 <L29Ah> dibblego: i hope you don't mean the Oleg's paper
21:28:28 <iqubic> That's what it looks like.
21:29:14 <L29Ah> probably i'm too stupid to utilize constraint logic programming
21:29:35 <dibblego> if I can teach a class of undergrads from zero-haskell to LogicT, in one semester, … 
21:30:09 <L29Ah> https://github.com/Bodigrim/logict/blob/master/test/Test.hs T_T
21:30:30 <iqubic> Is MonadPlus supposed to be like a Monoid with side-effects?
21:30:49 <L29Ah> @info MonadPlus
21:30:49 <lambdabot> MonadPlus
21:31:05 <L29Ah> @src MonadPlus
21:31:05 <lambdabot> class Alternative m => MonadPlus m where
21:31:05 <lambdabot>     -- Note: Alternative wasn't a superclass before GHC 7.10
21:31:05 <lambdabot>     mzero :: m a
21:31:05 <lambdabot>     mplus :: m a -> m a -> m a
21:31:16 <L29Ah> @src Monoid
21:31:16 <lambdabot> class Monoid a where
21:31:16 <lambdabot>     mempty  :: a
21:31:16 <lambdabot>     mappend :: a -> a -> a
21:31:16 <lambdabot>     mconcat :: [a] -> a
21:31:39 <iqubic> https://wiki.haskell.org/MonadPlus
21:32:00 <L29Ah> > mplus [1,2] [3,4]
21:32:02 <lambdabot>  [1,2,3,4]
21:33:19 <iqubic> and there's also msum :: [m a] -> m a, which functions like mconcat.
21:34:15 <iqubic> > msum [[1,2], [3,4]]
21:34:17 <lambdabot>  [1,2,3,4]
21:34:57 <iqubic> That's just "msum = foldr mzero mplus" or something similar.
21:36:55 <L29Ah> https://medium.com/twelve-days-of-monad/day-8-logict-a-list-transformer-a03dabba79cf okay great, LogicT for the stupid
21:38:04 <iqubic> I'm finding Oleg's paper tractable.
21:38:05 <bewakes> Hi all, I have a data `data LReal = LInteger Integer | LFloat Float | LRational Rational`. How can I make `LReal` an instance of `Num` easily given that all it wraps are the Num instances.
21:38:36 <iqubic> I'm not sure you can.
21:39:28 <L29Ah> bewakes: you can't as you'll have to deal with conversions when you do, say, (LInteger 1) + (LFloat 2)
21:39:47 <L29Ah> and i don't even know which constructor you want as a result, and you can't even specify it in your type
21:39:55 <bewakes> L29Ah: Ah, I see.
21:40:04 <iqubic> What should the result of "(LInteger 5) + (LFloat 5.5)" be? Haskell isn't smart enough to automatically figure out how to do the constructor conversion there.
21:40:19 <bewakes> totally makes sense. Thanks
21:40:34 <iqubic> Sorry to be killjoys
21:40:53 <L29Ah> [dependent types advertisment]
21:42:04 <iqubic> How would that help here/
21:43:04 <L29Ah> probably you could have had instances for individual constructors then
21:58:33 <MarcelineVQ> idk if there's a full on dependent route, you could accomplish making constructors match with a GADT though. idr what the haskell synax is, but it'd be close to this  https://gist.github.com/MarcelineVQ/938d795a9ad9d6628ca95f264bdd101b
21:59:28 <MarcelineVQ> so when one writes   Num (LReal a)    the 'a' must be the same for both x and y in x + y
22:00:24 <liiae`> f :: Int -> Int; f(0) = 0; f(1) = 1; f(n) = f(n-1) + f(n-2); f(42) will take a long time, is there a way could change it?
22:00:27 <MarcelineVQ> I don't think it's really a route a person shoudl prefer tho
22:11:28 <dmwit> liiae`: Certainly all the usual tricks from other languages apply.
22:11:40 <dmwit> liiae`: Additionally there is a standard Haskell idiom for it.
22:11:54 <liiae`> dmwit: what's its name?
22:11:55 <dmwit> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
22:11:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:12:02 <dmwit> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 42
22:12:04 <lambdabot>  267914296
22:12:19 <liiae`> dmwit: oh, I mean without change the code, 
22:12:42 <dmwit> No, you must change the code to get different code.
22:12:43 <liiae`> enable some language extensions stuff to speed it up
22:13:12 <dmwit> GHC will not change your algorithm for you.
22:13:49 <dmwit> Hm. That is too strident. Anyway, the answer to your question is no. If you want it to go significantly faster, you must write different code.
22:13:53 <liiae`> but ghc can do TCO for tail call codes
22:14:27 <dmwit> 1. GHC does not do TCO as far as I know. 2. TCO would not be enough to repair this code.
22:14:40 <c_wraith> huh?
22:14:42 <dmwit> (It's not even a tail call!)
22:14:47 <c_wraith> GHC guarantees tail call elimination
22:14:53 <c_wraith> like, in every single case
22:15:22 <dmwit> Hm. You're pretty smart, so that makes me nervous. But: are you sure?
22:15:26 <c_wraith> (still only applies when there's a tail call being done)
22:15:34 <c_wraith> yes.  It's part of the calling convention.
22:17:02 <c_wraith> the thing is, that's usually irrelevant because tail calls are usually irrelevant :)
22:17:13 <liiae`> haskell the language doesn't ask to implement TCO? ghc doesn't do TCO?
22:17:28 <dmwit> Haskell the language definitely does not specify that TCO must happen.
22:17:53 <liiae`> and ghc does not do it too?
22:17:54 <c_wraith> yeah, Haskell the language is pretty non-prescriptive on operational details
22:18:07 <c_wraith> GHC does.  Every tail call is a jump in GHC-generated code
22:18:24 <dmwit> Anyway, like I said, it doesn't matter. The code you wrote doesn't have any tail calls anyway.
22:18:25 <c_wraith> It's just usually not really relevant.
22:18:41 <liiae`> right
22:19:06 <dmwit> ...and the inefficient bit isn't the call costs, it's the exponential asymptotics of the algorithm you picked.
22:19:34 <liiae`> I just wrote it like a high-school student
22:19:42 <dmwit> Yes, don't do that. ^_^
22:19:59 <liiae`> it's the natural way to define a fibonacci sequence in high-school math
22:20:20 <c_wraith> funny thing, it's not how a high school student would actually calculate the 10th fibonacci number.
22:20:31 <liiae`> actually I'm surpprised that haskell support this syntax
22:20:48 <c_wraith> They'd memoize results
22:40:28 <L29Ah> > seq undefined 666
22:40:30 <lambdabot>  *Exception: Prelude.undefined
22:40:59 <iqubic> Yeah. I'd calculate it by just writting out the terms in a list. 1,1,2,3,5,... How do I calculate the next number? Just add the furthest right two terms, then write the next term at the end, all the way on the right of the list.
22:41:38 <L29Ah> > f(0) = 0; f(1) = 1; f(n) = f(n-1) + f(n-2); f 5
22:41:40 <lambdabot>  <hint>:1:6: error: parse error on input ‘=’
22:41:45 <jchia1> Does stack care about the metadata revisions on hackage or does it just take the dependencies from the cabal file?
23:01:50 <int-e> > fix ((0:) . scanl (+) 1) -- time for an old favorite
23:01:51 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:05:07 <shachaf> "fibs = 1 : scanl (+) 1 fibs" is almost readable.
23:05:17 <iqubic> I love that so much.
23:05:49 <iqubic> > fix ((1:) . scanl (*) 2) -- Powers of two will emerge
23:05:51 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,618970019642690...
23:05:59 <iqubic> Hm?
23:06:21 <shachaf> Those are all powers of 2.
23:06:42 <iqubic> Yes, but the 2 was repeated.
23:06:54 <iqubic> Why was it?
23:07:17 <iqubic> @scr scanl
23:07:17 <lambdabot> Maybe you meant: src rc arr
23:07:25 <iqubic> @src scanl
23:07:25 <lambdabot> scanl f q ls = q : case ls of
23:07:25 <lambdabot>     []   -> []
23:07:25 <lambdabot>     x:xs -> scanl f (f q x) xs
23:07:38 <iqubic> Oh. I see.
23:08:16 <iqubic> > 1 : fix ((2:) . scanl (*) 2)
23:08:18 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,618970019642690...
23:08:24 <iqubic> Hmm?!?!
23:08:46 <iqubic> > 1 : tail . fix ((2:) . scanl (*) 2)
23:08:48 <lambdabot>  error:
23:08:48 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘a0 -> [a1]’
23:08:48 <lambdabot>      • Probable cause: ‘(.)’ is applied to too few arguments
23:08:51 <int-e> > fix ((1:) . map (*2))
23:08:52 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
23:09:03 <iqubic> How did you remove the second 2?
23:09:13 <int-e> iqubic: that's what you want. scanl accumulates on top of mapping
23:09:40 <iqubic> But how does fix work there?
23:09:56 <int-e> > fix ((1:) . scanl (*) 2) -- still entirely different
23:09:57 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,618970019642690...
23:10:27 <iqubic> Yeah. That has a repeated two for some reason.
23:11:03 <int-e> > fix ((2:) . scanl (*) 4) -- that would eliminate the second 2, but it's still not all powers of 2
23:11:05 <lambdabot>  [2,4,8,32,256,8192,2097152,17179869184,36028797018963968,6189700196426901374...
23:11:45 <int-e> The upshot is that scanl is not map.
23:12:35 <int-e> > scanl (+) 0 [1..] -- have some triangular numbers
23:12:36 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
23:13:49 <iqubic> > fix ((1:) . map (*2))
23:13:51 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
23:14:07 <iqubic> I like triangle numbers.
23:14:15 <int-e> > iterate (scanl (+) 0) (repeat 1) !! 5 -- or some binomial coefficients: C(k,5)
23:14:17 <lambdabot>  [0,0,0,0,0,1,6,21,56,126,252,462,792,1287,2002,3003,4368,6188,8568,11628,155...
23:14:33 <iqubic> What is that doing???
23:14:44 <int-e> Hmm. C(k,6), evidently. I picked the wrong starting value, should've been 1 : repeat 0 instead of repeat 1.
23:15:03 <int-e> scanl (+) 0  takes a list and produces the list of partial sums
23:15:11 <int-e> > scanl (+) 0 [a,b,c]
23:15:13 <lambdabot>  [0,0 + a,0 + a + b,0 + a + b + c]
23:15:23 <ptrcmd> :t a
23:15:25 <lambdabot> Expr
23:15:44 <ptrcmd> @src Expr
23:15:45 <lambdabot> Source not found. stty: unknown mode: doofus
23:16:06 <iqubic> @define binCoeff = iterate (scanl (+) 0) (1 : repeat 0)
23:16:07 <lambdabot>  Defined.
23:16:19 <iqubic> @undefine
23:16:19 <lambdabot> Undefined.
23:16:31 <iqubic> @define binCoeffs = iterate (scanl (+) 0) (1 : repeat 0)
23:16:32 <lambdabot>  Defined.
23:16:38 <int-e> ptrcmd: https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Expr.html
23:16:42 <iqubic> > binCoeffs !! 5
23:16:44 <lambdabot>  [0,0,0,0,0,1,5,15,35,70,126,210,330,495,715,1001,1365,1820,2380,3060,3876,48...
23:17:02 <ptrcmd> int-e: thanks
23:17:04 <iqubic> I'm not sure that's right.
23:17:31 <iqubic> But is that an infinite list filled with infinite lists?
23:17:33 <int-e> iqubic: my mistake, I meant C(k, 5)
23:17:47 <iqubic> @src binCoeffs
23:17:47 <lambdabot> Source not found. You untyped fool!
23:18:04 <int-e> iqubic: and that means I actually had it right :-/
23:18:15 <iqubic> @undefine
23:18:16 <lambdabot> Undefined.
23:18:36 <int-e> (Because C(6,5) = 6... somehow I wanted a 5 there.)
23:18:42 <iqubic> @define binCoeffs = iterate (scanl (+) 0) (repeat 1)
23:18:43 <lambdabot>  Defined.
23:19:10 <iqubic> So, how does that generate binomial coefficients? Is it just creating Pascal's triangle somehow?
23:19:28 <iqubic> > binCoeffs !! 1
23:19:30 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:19:45 <iqubic> That looks right.
23:19:55 <int-e> C(k+1,n) = C(k,n) + C(k,n-1) + ... + C(k,0)
23:20:05 <iqubic> Oh. I see.
23:20:21 <int-e> grrr
23:20:25 <int-e> I keep doing this.
23:20:32 <iqubic> What's wrong now?
23:20:39 <int-e> C(n,k+1) = C(n,k) + C(n-1,k) + ... + C(0,k)
23:20:50 <iqubic> ? binCoeffs !! 0
23:20:58 <iqubic> > binCoeffs !! 0
23:21:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:21:17 <iqubic> Why is that just a list of 1s?
23:21:32 <int-e> Because there's 1 way to select 0 elements no matter how many you have.
23:21:41 <int-e> C(n,0) = 1
23:22:02 <int-e> C(n,k) is binCoeffs !! k !! n, that's part of the confusion
23:22:56 <iqubic> Right. I see.
23:22:59 <int-e> > transpose binCoeffs !! 3 -- this may look more familiar
23:23:01 <lambdabot>  [1,3,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:23:38 <iqubic> Did you just transpose an N*M list where both M and N are infinity?!?!? WHAT THE BLOODY HELL!?!?
23:23:47 <int-e> lazy
23:23:51 <iqubic> s/list/2d list/
23:24:11 <iqubic> But yeah, this is just Pascal's triangle.
23:24:12 <int-e> > map (!!3) binCoeffs
23:24:14 <lambdabot>  [1,3,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:24:32 <iqubic> > map (!!1) binCoeffs
23:24:34 <lambdabot>  [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:24:43 <iqubic> > map (!!2) binCoeffs
23:24:45 <lambdabot>  [1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:24:50 <iqubic> > map (!!3) binCoeffs
23:24:52 <lambdabot>  [1,3,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:25:01 <iqubic> It's just pascal's triangle.
23:25:30 <iqubic> Fun math fact. It's also powers off eleven.
23:25:58 <iqubic> > map (11**) [1..3]
23:26:00 <lambdabot>  [11.0,121.0,1331.0]
23:26:28 <iqubic> > 11**4
23:26:30 <lambdabot>  14641.0
23:26:42 <int-e> Yeah, up to a point. This is the binomial theorem in disguise, (x+1)^n = sum of C(n,k)*x^k.
23:27:06 <iqubic> Yeah. And powers of eleven show up too, which I find bizarre.
23:27:22 <int-e> 11_x = x+1
23:27:33 <iqubic> Right.
23:28:53 <iqubic> And what freaks me out if you take Pascal's triangle, and remove all the odd numbers, the remaining numbers positions resemble Sirpenski's triangle.
23:30:03 <mac10688> Anyone able to get vim intellisense on nixos?
23:30:26 <int-e> iqubic: if you do that carefully modulo p, you may end up with https://en.wikipedia.org/wiki/Lucas%27_theorem
23:31:21 <iqubic> mac10688: I think this is the wrong channel for that question. That's mainly a NixOS question. I'd try asking in #nixos. But do mention that you're working with Haskell when you ask the question there.
23:31:26 <int-e> iqubic: (The Sierpinsky triangle pattern can be derived from that theorem if you take p=2)
23:32:25 <mac10688> ok thanks iqubic 
