00:00:10 <kuribas> anyway thanks, the package itself is quite nice.
00:00:28 <Axman6> it's generally used when you have an error type which wraps another error type
00:01:40 <Axman6> data DBError = ConnectionError | NetworkDisconnected; data AppError = DBError DBError | AuthError AuthError; do someDBThhingWhichCanReturnEitherDBErrorOrA <%?> DBError
02:01:54 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
02:01:54 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
03:33:19 * hackage haskoin-store-data 0.35.2 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.35.2 (jprupp)
03:34:19 * hackage haskoin-store 0.35.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.35.2 (jprupp)
03:54:12 <nil> say i have two maps m1 :: Map K A, m2 :: Map K B, and i want to merge their keys into a list, but i stubbornly insist on doing it with ((<>) `on` Map.keys). it seems like i can't, because the resulting function has a type like a -> a -> b, but m1 and m2 have different types; is there a way to accomplish this, maybe with RankNTypes? i think a solution might be (exists a. Map K a), but i don't think
03:54:14 <nil> haskell supports this
03:56:56 <dminuoso> nil: "merge their keys into a list" what is that supposed to mean?
03:57:03 <dminuoso> Do you just care about the keys?
03:57:07 <nil> yes
03:57:18 <dminuoso> Data.Map.keys ?
03:57:19 <nil> get the keys from m1, followed by the keys from m2, in a list
03:57:30 <dminuoso> `keys m1 <> keys m2` ?
03:57:48 <nil> "but i stubbornly insist on doing it with ((<>) `on` Map.keys)"
03:57:53 <nil> this is a theoretical question
03:57:59 <dminuoso> Ah.
03:58:20 <fog> can anyone explain how () is used to "prevent effects from leaking from a monadic environment" ?
03:59:10 <nil> not without more context
04:04:19 <fog> hmm, i guess i cant give any without trying to explain it 
04:04:34 <fog> i saw it in a blog post, just trying to remember where
04:05:02 <fog> i think it was to do with the "with" pattern
04:05:11 <fog> ill see if i can find it, hang on
04:06:27 <fog> it was not a blog post! it is a package called Managed here;
04:06:28 <fog> https://hackage.haskell.org/package/managed-1.0.7/docs/Control-Monad-Managed.html
04:06:41 <fog> it says;
04:06:42 <fog> NOTE: Managed may leak space if used in an infinite loop like this example:
04:07:01 <fog> and then gives an example where, because it does not return () in the monadic return type
04:07:45 <fog> that this could be used to return eg. an open file handle
04:07:57 <fog> erm, no, a file handle that had already been closed
04:08:38 <fog> like, you want to be able to allow something to be returned, but its like a "bracket" environment, where the handle is opened and closed on either side of the action 
04:08:51 <fog> but that, allowing things to returned from the environment available to this action
04:09:08 <fog> which includes the handle (that is open *during* this action)
04:09:43 <fog> allows the handle to be *returned*.... which would escape where it is valid/open
04:10:00 <fog> it says;
04:10:02 <fog> "... so only use with if you know what you are doing and you're returning a value that is not a resource being managed."
04:10:25 <fog> and then just below this says;
04:10:28 <fog> runManaged :: Managed () -> IO () Run a Managed computation, enforcing that no acquired resources leak
04:10:56 <fog> giving the idea that "() is used to prevent things leaking from a monadic environment" 
04:11:35 <Profpatsch> So I can’t export qualified modules from my Prelude file
04:11:44 <fog> basically, im thinking that when folding a monadic list, only returning m () is "safe" in this way, forcing all "effects" to be embedder into the monadic environment and none to leak
04:12:02 <Profpatsch> Can I fore my users to use Text.pack somehow (instead of pack without qualifier)?
04:12:18 <Profpatsch> s/fore/force
04:12:31 <nil> effects don't leak, values do. () is the "no information" type, hence if you return () you're not "leaking" any information, although if you have access to IO you could just as well store a value in an IORef and leak it that way
04:12:52 <fog> thats the point!
04:13:05 <Logio_> nil: isn't the problem there that the implicit "forall a" in "forall a. Map k a -> [k]" gets applied to both instances of keys, even though it strictly speaking shouldn't be?
04:13:07 <fog> i want the "effects" to be stored in the monad, not the value
04:13:54 <fog> Profpatsch: hmm, idk, im guessing you tried and it doesnt work...
04:14:26 <nil> Logio_: yeah, that type can be rewritten as (forall k. (exists a. Map k a) -> [k]), and instantiating that with K should preserve the existential, but haskell doesn't do this
04:15:15 <fog> nil: basically, i have foldr const (), which is completely pointless in a pure fold, but seems to serve this purpose perfectly, of preventing any information from leaking except through the monadic environment. i was thinking of calling it "embed"
04:15:51 <nil> % :t void
04:15:51 <yahb> nil: Functor f => f a -> f ()
04:15:54 <nil> fog: ^
04:16:14 <fog> (FoldableM t,Monad m) => t m a -> m ()
04:16:32 <fog> % void [1]
04:16:32 <yahb> fog: [()]
04:16:56 <fog> nil, yeah, i guess its kind of like that, except with Foldable instead of Functor
04:17:14 <nil> % :t sequence_
04:17:14 <yahb> nil: (Foldable t, Monad m) => t (m a) -> m ()
04:17:56 <fog> FoldableM :: ((Type -> Type) -> Type -> Type) -> Constraint 
04:18:30 <merijn> Profpatsch: Not via the compiler, no
04:19:07 <Profpatsch> merijn: Even simple stuff like Text.unlines and ByteString.unlines is impossible :(
04:19:11 <merijn> Profpatsch: Your options for forcing are limited to the usual out-of-band options of naming & shaming, public stoning, etc.
04:19:11 <nlhowell> :w
04:19:45 <merijn> Profpatsch: Well, you can name them textUnlines and byteStringUnlines and have the same effect as forcing "Text.unlines" :p
04:19:52 <Profpatsch> lol
04:19:56 <Profpatsch> elisp here we go
04:20:09 <Profpatsch> Thinking about maybe having hlint rules?
04:22:17 <Profpatsch> Ah, you just cannot export any module namespaces from a module
04:22:31 <Profpatsch> You can just collapse them into different modules
04:40:54 <fog> ok! i have an example of the idea
04:42:07 <fog> https://gist.github.com/fog-hs/0ac6533875b68508ec35da55c160c4f1
04:42:57 <fog> the central function is;
04:42:58 <fog> embed :: (FoldableM t, Monad m) => (a -> m x) -> t m a -> m ()
04:43:46 <fog> which seems more like map in its type, but its actually a fold, where the accumulating value is just ()
04:43:58 <fog> which only really works in a monadic context
04:44:20 <fog> because the `x' is discarded using >>
04:44:47 <fog> embed f = foldrM (\a -> f a >> (return (\() -> return ())))  (return ()) 
04:45:06 <fog> which seems pretty bizarre! 
04:45:58 <fog> but its basically saying "folding without carrying anything" 
04:46:11 <fog> forcing everything to be "embeded" into the monad
04:47:31 <fog> in the example, print is used as the function supplied to embed, allowing the "effects" to be "embeded" into stdIO and printed to the ghci prompt  
05:00:53 <frdg````> If I enter `print "hello" ++ "\n" ++ "world"` into Stack ghci, should I be returned "hello\nworld"?
05:00:53 <frdg````>  
05:01:13 <frdg````> wtf erc
05:02:08 <frdg````> or should I be return "hello"; "world" ?
05:03:01 <yushyin> % print $ "hello" ++ "\n" ++ "world"
05:03:01 <yahb> yushyin: "hello\nworld"
05:03:39 <sm[m]> frdg````: you should get an error I think
05:03:44 <yushyin> % putStrLn $ "hello" ++ "\n" ++ "world"
05:03:45 <yahb> yushyin: hello; world
05:03:57 <merijn> frdg````: print first runs show on your string
05:04:08 <merijn> frdg````: So it will add quotes and escape characters
05:05:15 <frdg````> ok I see the problem thanks
05:35:49 * hackage hzenity 0.4 - Haskell interface to Zenity dialogs  https://hackage.haskell.org/package/hzenity-0.4 (EmilAxelsson)
05:42:19 <dminuoso> Is there a library that lets me manipulate cabal files in such a way to preserve existing indentation/whitespace?
05:43:32 <phadej> I'm not aware of one
05:45:33 <maralorn> Profpatsch: There are at least 2 GHC proposals which tackle the problem of reexporting qualified modules. https://github.com/ghc-proposals/ghc-proposals/pull/283, https://github.com/ghc-proposals/ghc-proposals/pull/295
05:45:39 <maralorn> Sadly they both kinda got lost in the design space and the authors haven‘t found the time to find a way back home …
05:46:27 <nlhowell> is it possible to put constraints on a "type instance" declaration?
05:47:01 <Profpatsch> maralorn: yeah :(
05:47:14 <nlhowell> I have a Nat-indexed collection of types, data Transducer (n :: Nat)
05:47:27 <Profpatsch> sounds like a good feature, but the haskel module system is already quite complex
05:47:34 <Profpatsch> *haskal
05:47:45 <nlhowell> and a heterogeneous list of them data Transducers (l :: [*])
05:47:46 <Profpatsch> Especially with the GHC extension zoo
05:48:05 <nlhowell> and i want to be able to take "Transducers xs" and compute the sum of all the "n"s
05:48:09 <nlhowell> at the type-level
05:48:39 <dminuoso> phadej: Fair enough. I guess Ill just do a hacky `unlines . process . lines <$> readFile` then. :)
05:48:59 <nlhowell> I tried writing a type family to do this, but I don't seem to be able to get it to work
05:49:06 <maralorn> Profpatsch: I feel like it should be possible to make it simpler and more feature rich at the same time. But likely not without breaking backwards compatibility.
05:49:35 <Profpatsch> yeah
05:49:37 <Profpatsch> stuck with it
05:56:21 <merijn> dminuoso: cabal-edit?
05:56:33 <merijn> I saw that get announced on twitter/reddit recently
05:57:22 <dminuoso> merijn: Doesnt that just use Cabal?
05:57:34 <merijn> I guess that's a tool, not a library, though
05:57:44 <dminuoso> Ah. It just feeds it all into cabal-fmt
05:58:09 <dminuoso> I just want a very simple tool to automate the process of "bumping the cabal version and creating a git tag" :P
06:08:44 <maralorn> dminuoso: I use "releaser" for that.
06:09:42 <maralorn> It is _really simple_. E.g. the error handling is not great. But it beats doing the release by hand.
06:09:57 <LambdaDuck> Has anyone thought of applying church encoding in reverse as a way of interpreting parametricity and theorems for free? I assume it doesn't generalize to all cases, but it is a nice way of viewing simpler examples like (foral a. a -> a) must be id etc.
06:13:20 <Darwin226> Hey guys, is there a way to use unsafePerformIO in a top level value but make the IO action get executed every time the value wants to get evaluated?
06:13:41 <merijn> Darwin226: No
06:13:46 <fog> ok, so there is a reason, just realised, that this folding with const () in a monadic setting is so enticing 
06:14:04 <merijn> Darwin226: If you care about how often/when IO happens, then unsafePerformIO is *always* wrong
06:14:13 <fog> the pattern, with the clock, emitting (), and then "embed" folding with a carry of ()
06:14:32 <fog> basically defers all the work to the scanner
06:14:37 <merijn> Darwin226: unsafePerformIO is equivalent to swearing to the compiler that you don't care if or how many times it gets run and don't care when it gets run either
06:14:56 <fog> its not exactly a "push oriented patter", since the fold is required to consume all the values
06:15:07 <merijn> Darwin226: What are you trying to do?
06:15:22 <fog> otherwise the clock could be seen as synchronising everything, when really, it can only add a delay
06:15:37 <Darwin226> merijn: A library takes a Text that I load from a file and I'd like it to reload every time it's used. The library doesn't let me provide an IO action in place of the Text value, and I'd only use this for convenience so I don't need to restart my program
06:15:41 <Darwin226> when developing
06:15:43 <fog> withholding the values in a blocking way 
06:15:51 <frdg> is there anyway to perform IO in a shakespearan template?
06:16:55 <fog> then, with the source and the sink, in the example, as clock and embed, basically doing nothing except ()
06:17:14 <merijn> Darwin226: I suspect there's probably better ways of doing that, but it depends on what that library does and what you do with its result
06:17:48 <fog> so that the scanner models the simulation of all data from an initial condition, sort of like an unfold, except "scanning" over the stream of () emitted by the clock
06:18:05 <fog> and that "embed" then consumes the output data and embeds it in the monadic context
06:18:34 <Darwin226> merijn: the function call doesn't return. Concretely, it's a web server. 
06:18:57 <fog> basically then, all the processing of data for any iterative program performed using a scanner
06:19:05 <Darwin226> Ok then, I thought maybe there was some GHC hackery to mark a value as "reevaluate always"
06:19:49 <Darwin226> Though I get how that might not be feasible since the library might save that value in a local variable
06:19:55 <Darwin226> and then what
06:20:18 <merijn> Darwin226: Is it a template? Or just like static assets?
06:20:52 <Darwin226> static asset I guess
06:21:03 <merijn> Darwin226: I mean, you could just write an IO action that checks the file for modification and kills/restarts the server when that happens
06:21:06 <Darwin226> It's concur-replica so serving static assets isn't it's primary function
06:21:18 <merijn> Alternatively, you could host the static asset on a separate webserver for testing
06:21:46 <Darwin226> yeah, I might do that
06:21:49 <Darwin226> thanks
06:22:22 <fog> i guess the strength of this approach is that by streaming over a "monadic list" that this can be thought of as a lazy partial traversal 
06:22:28 <merijn> Darwin226: I mean, assuming you have "Text -> IO ()" to start the server and "IO ()" to shut it down, then simply write a loop that detects modification and kills/restarts as needed
06:22:49 <Darwin226> I lose all the in memory state like that
06:22:55 <fog> where a "shape index" can be factored into the monad, so subsuming previous approaches involving seti/geti
06:24:13 <fog> this allows also for the modelling of scenarios in an IO context to be simulated in the Identity monad, which is much faster than having multiple interacting programs interacting via ports
06:24:38 <fog> allowing then for concurrent agent based modelling simulations to be run in one program
06:24:43 <fog> in a pure setting
06:25:01 <fog> using the same approach as if the communication were handled in the IO monad between several programs
06:25:43 <fog> which could be good for parellisation, and the emulation of clusters of interacting processes in a message passing framework 
06:26:45 <dminuoso> maralorn: I dont release to hackage. I just care about the `bump cabal version, create git tag and push tag` :P
06:27:21 <merijn> dminuoso: I just do it manually, like a savage
06:27:54 <maralorn> dminuoso: Oh.^^ Well, Would be easy to fork and comment out that lines …
06:28:18 <maralorn> But not sure if that's worth it.
06:28:36 <fog> i guess ill have to learn about monad transformer stacks now
06:29:03 <fog> since if one monad is supposed to be used for the shape of a tree, and the other is supposed to handle IO, then they should be combined together
06:29:43 <fog> i wonder if more complex datatypes, that are traversable by construction, can then be represented as monadic transformer stacks in streaming setting
06:29:59 <fog> idk what you could call this, something like transformer streams or something
06:30:52 <fog> "scanners for dataflow processing"
06:32:04 <fog> probably its no coincidence that this works, following moggi and the idea of monads as means of representing computational workflow 
06:33:13 <fog> its kind of annoying that i cant get this to work for traversable, but there is something intrinsic about the lack of commutability of the applicative with the monad that makes scanners a thing 
06:33:51 <fog> where this problem does not appear in the pure setting since Identity commutes with everything
06:34:47 <fog> so two things appear, when going from pure to monadic streaming. scanners, and embeded effects, as a result of the bizzare type of foldrM
06:35:05 <fog> here is the accompanying blog post again; https://gist.github.com/fog-hs/0ac6533875b68508ec35da55c160c4f1
06:35:09 <fog> peace! 
06:43:00 <nlhowell> OK, I got most of this past the type checker
06:43:14 <nlhowell> now I have a new question
06:43:32 <nlhowell> I have the heterogenous list "data Transducers' [*]"
06:44:51 <nlhowell> and at a call site, i have "compose :: forall ss (t :: Transducers' ss). (All IsTransducer ss) => Transducers' ss -> Maybe (Transducer' (Len t))
06:46:00 <nlhowell> IsTransducer is just a type class with associated family allowing me to compute length
06:46:49 <nlhowell> and there could be other adversarial implementations of it
06:46:59 <ezzieyguywuf> I've seriously been considering just blocking fog
06:47:21 <nlhowell> is there some way I can strengthen the constraint?
06:47:21 <ezzieyguywuf> b/c all I even see from fog is a stream-of-consiousness that isn't really helpful, and makes it difficult to keep track of the real conversations
06:47:35 <merijn> ezzieyguywuf: You are not alone
06:47:47 <merijn> ezzieyguywuf: He's been told to "get a blog" before
06:47:48 <ezzieyguywuf> glad it's not just me
06:48:36 <nlhowell> he seems not to have completely gotten the message
06:48:47 <nlhowell> since he just appended the link to his blog
06:49:41 <ezzieyguywuf> lol
06:51:08 <ezzieyguywuf> done, /ignore fog
06:55:08 <maralorn> ezzieyguywuf: I have to admit, I have done the same.
07:02:55 <nlhowell> OK, even further past the type checker
07:04:35 <nlhowell> maybe someone can help with my latest error? I feel ghc should be able to prove this..
07:04:37 <nlhowell> https://dpaste.com/AC5V5VACB
07:05:37 <nlhowell> and here is the relevant code: https://dpaste.com/FBVSCCMXD
07:07:13 <nlhowell> i can experiment with Len type family, and ghc is correctly computing simple examples
07:07:45 <nlhowell> e.g. ":kind! Len (Transducer' 3 :# Transducer' 4 :# NoTransducers)" gives "7 :: Nat" 
07:07:47 <frdg> I am trying to install yesod-table and am getting this error: https://dpaste.org/tiGL . It seems to me that cabal can see that this library exists
07:09:19 <merijn> frdg: Stack only supports packages that are part of it's resolver snapshots. If you need a package (or version) that's not part of that you need to explicitly add that dependency to your stack config
07:10:35 <sm[m]>  like it says in the message :)
07:10:49 <frdg> ok thanks
07:11:52 <sm[m]> I find this useful while working out such build plan errors and warnings: stack build --fast --dry-run --file-watch
07:18:46 <frdg> If I add the line to my Stack.yaml will I have to use the package.yaml file instead of my .cabal file?
07:18:56 <merijn> No
07:19:04 <merijn> package.yaml is entirely optional
07:19:12 <merijn> And I'd advise not using it, tbh
07:23:11 <frdg> For some reason I can't figure out the syntax for doing this. I have tried every combination of what is shown in the paste. https://dpaste.org/L9Bp
07:24:00 <hc> tbh I'd wish for a more unified build system in haskell, like cargo does for the rust world
07:24:26 <hc> allowing multiple package versions in one binary is key to a smooth experience
07:27:33 <merijn> hc: We had one, until stack forked the community instead of contributing to cabal-install...
07:28:13 <dolio> I think GHC can support linking multiple versions of a package. I'm not sure where cabal is at on taking advantage of that.
07:28:15 <merijn> frdg: Which file is that, though
07:28:30 <merijn> dolio: Doesn't support it, afaik
07:29:50 <dolio> Orchestrating it seems complicated.
07:49:19 * hackage hsinspect-lsp 0.0.6 - LSP interface over the hsinspect binary.  https://hackage.haskell.org/package/hsinspect-lsp-0.0.6 (tseenshe)
07:51:44 <chaseries> so i'm kind of new to writing "real" haskell programs, and i'm stumped about how to structure the types in one. it's a websockets messaging server, essentially, but users of it can have two distinct roles (customer or employee). it's kind of impossible to generalize them into a "user" or "client" type because they have distinct roles (and different databse models with ids that can collide), and the 
07:51:50 <chaseries> browser client needs to know which is which, so the messaging server does, too
07:53:09 <chaseries> writing aeson parseJSON instances is particularly tricky, since i get raw JSON data that may be typed differently in the application depending on what it is (customer/employee)
07:54:48 <chaseries> i first tried to do it with something akin to `data Client = Customer Text | Employee Text`, but since their functions overlap in some instances and don't in others, pattern matching throughout the application involved substantial boilerplate
07:55:10 <ezzieyguywuf> hm, so I document most (if not all) of my functions using the haddock stuff. is there a way to tell haddock to generate all documentation, even for non-exported stuff?
07:55:24 <merijn> chaseries: Split the shared fields of into a separate part?
07:55:44 <merijn> chaseries: "data Client = Customer ... SharedClientData | Employee .. SharedClientData"
07:56:03 <merijn> chaseries: Then you can share the logic by operating on the shared bits
07:56:04 <chaseries> my latest attempt is this: https://pastebin.com/dR57xstf and i guess i'm just wondering if it smells ok
07:56:30 <ddellacosta> chaseries: what's the problem with a generic user that has a field or something identifying their role?
07:57:00 <merijn> ezzieyguywuf: Yes, but I don't remember how :p
07:57:07 <merijn> ezzieyguywuf: Consult the docs?
07:57:09 <ezzieyguywuf> merijn: lol, good to know it's possible
07:57:23 <ezzieyguywuf> I did a cursory readthrough of haddock --help, but perhaps I need to dig deeper
07:57:49 <merijn> ezzieyguywuf: https://www.haskell.org/haddock/doc/html/index.html
07:59:00 <merijn> hmm, those look like they're actually pretty old
07:59:14 <ezzieyguywuf> maybe --haddock-internal
07:59:20 <merijn> oh, google is just indexing old stuff again
07:59:35 <merijn> https://haskell-haddock.readthedocs.io/en/latest/index.html
08:00:08 <chaseries> ddellacosta: actually, that was the original idea and it "works," but it just doesn't feel like i'm using haskell the way it should be used. some data structures will never have a customer, for instance, so an errant request for information on some client that should only ever be requested on an employee requires a pattern match that shouldn't exist in the first place, if that makes sense
08:01:16 <merijn> ezzieyguywuf: See the module attributes specifically
08:02:03 <chaseries> like an employee may have a backlog of customers to attend to (`Transfers`), but handling a request for GetTransfers (Client RoleCustomer id) is nonsensical
08:02:12 <merijn> chaseries: The current approach seems reasonable, but there's a slippery slope of adding more and more type level stuff until you have a type-level death machine that gets very unwieldy to work with/refactor
08:02:27 <ezzieyguywuf> merijn: thanks
08:02:34 <merijn> chaseries: Your original idea doesn't have that issue
08:03:11 <chaseries> merijn: i don't mean to abuse your time, but does this then seem more sensible: https://pastebin.com/qNexf9km  ?
08:03:31 <merijn> chaseries: Sometimes just giving up and making it a runtime check and relying on ADTs/complete pattern matches can be easier to work with in the long run
08:03:49 <merijn> chaseries: Out of context both seem reasonable
08:04:04 <merijn> chaseries: Just be careful that you don't start incurring too much type level complexity
08:05:14 <ski> chaseries : `Show' is incorrect. you could define `showsPrec p (Customer iD) = showParen (p > 10) $ showString "Customer " . showsPrec 11 iD' (and similarly for the other case) .. although i think that's what you'd get if you derive it (if you don't run into some trouble doing that)
08:06:48 <ski> (with your current instance, you'll incorrectly show values of type `Maybe (Client a)', e.g.)
08:06:48 <chaseries> merijn: noted, as the problem i stumbled into instancing the former example with Aeson felt intractable
08:08:05 <chaseries> ski: looking into this, thank you!
08:08:07 <merijn> chaseries: Right, trying to go from external data to the GADT representation is...very painful :)
08:08:28 <L29Ah> can i expect haskell containers returning an existing contained value as opposed to copying it?
08:08:54 <merijn> L29Ah: Everything goes by reference in haskell, since it's immutable anyway
08:09:19 <merijn> (well, the compiler might decide to copy stuff as optimisation for stuff like integers or whatever)
08:09:43 <phadej> boxed stuff goes by reference, unboxed stuff is copied
08:09:56 <L29Ah> and if it's a thunk, it's only evaluated at most once?
08:10:06 <phadej> yes
08:10:10 <L29Ah> thanks
08:10:11 <Cale> In fact, what you usually have are not exactly pointers to values, but pointers to code which returns values, and which become pointers to shorter code that returns the computed value immediately after the first time the code for computing the value is run.
08:10:16 <merijn> L29Ah: Yes*
08:10:18 <ski> chaseries : usually, it's best to derive `Show'. there can be cases where don't do that (either because the deriving machinery can't generate an instance for your, or you don't want the one that is generated). e.g. if you want to hide the internal representation, you could provide a custom instance that describes how to generate an equivalent value, using the publicly exported operations
08:11:04 <nlhowell> f/buff14
08:11:12 <Cale> There are various cases where that indirection can be skipped over even if the machinery is still there (there's pointer tagging which uses the low order bits of the pointer to encode which constructor it evaluated to, for example)
08:11:15 <merijn> L29Ah: There's a whole bunch of optimisation logic and heuristics that can change these things and the language doesn't specify what happens. But *in principle* you can pretend/assume it's all by reference and evaluated once
08:11:54 <ski> chaseries : in any case, `Show' (and `Read') are intended to operate with string representations of Haskell code (they're not for any custom format, not saying you were making this mistake here). and they're intended to be "team players", work together with other instances. for all but the most trivial cases, you should define `showsPrec'/`readsPrec'
08:11:55 <phadej> L29Ah: I would strongly recommend not too think (too hard) about evaluation stuff
08:12:39 <phadej> the previous knowledge of impertive languages will make you write poor Haskell
08:12:44 <Cale> If you *do* need to think about evaluation, then usually thinking of it in terms of expression rewriting or graph rewriting will do, while lower-level reasoning is of limited actual usefulness.
08:12:52 <L29Ah> ok, well, i want to convert a bunch of hashmaps into a complex interlinked cyclic structure made from half a dozen data types, so i don't want any copying
08:13:06 <ski> @where lazy
08:13:06 <lambdabot> "Lazy Evaluation of Haskell" by monochrom at <http://www.vex.net/~trebla/haskell/lazy.xhtml>; "The Incomplete Guide to Lazy Evaluation (in Haskell)" by apfelmus in 2015-03-07 at <https://apfelmus.
08:13:06 <lambdabot> nfshost.com/articles/lazy-eval.html>; "Laziness, strictness, guarded recursion" by bitemyapp at <https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md#user-content-laziness-
08:13:06 <lambdabot> strictness-guarded-recursion>
08:13:20 <ski> L29Ah : see e.g. the first article there ^
08:13:29 <L29Ah> and on the other hand i probably want the converter to force its output to avoid a huge volume\ of thunks hanging around
08:13:45 <Cale> L29Ah: The hard part will more likely be avoiding "copying" after you do get the cyclic data structure, since it's kind of impossible to discern infinite structures from cyclic ones.
08:13:56 <L29Ah> ("Bar -> !Foo" ?)
08:14:41 <Cale> i.e. if you start processing a cyclic structure, you won't likely end up with another cyclic structure, but instead, the original thing which is cyclic in memory will look infinite to the code which is recursing over it, and you'll get an infinite output
08:14:42 <L29Ah> Cale: what's so hard about that?
08:15:00 <L29Ah> ah yeah
08:15:03 <ski> L29Ah : no pointer/reference equality
08:15:04 <phadej> Haskell doesn't have reference equality
08:15:04 <Cale> So you have to take care to avoid that
08:15:21 <L29Ah> yeah i have everything carrying id's
08:15:44 <L29Ah> as i need to reference the objects somehow while communicating with an external entity
08:15:50 <phadej> L29Ah: you might be interested in https://osa1.net/posts/2020-02-21-knot-tying-why-how-opinions.html
08:16:19 <phadej> which TL;DR "it might be not as good idea as you think it is"
08:16:32 <ski> sometimes i wonder whether something like `ivar-simple' could be used for sharing and cycles
08:18:17 <L29Ah> i don't understand the first problem; the second problem is irrelevant as my structure is immutable; and i never plan to traverse the structure, only poke it here and there, utilizing the local context of nodes
08:20:25 <phadej> (Just 'a', Just 'a') and let x = Just 'a' in (x,x) -- are different in memory (assuming compiler doesn't do any optimizations)
08:20:37 <phadej> latter takes less space
08:21:15 <merijn> phadej: possibly
08:21:31 <phadej> imagine `Just 'a'` is actually BIG value
08:21:46 <merijn> oh, wait, you already said assuming no optimisations, reading is hard :)
08:23:19 <phadej> ... but in haskell you cannot tell these apart
08:24:28 <dminuoso> merijn: Fun story, so after 3 months Ive completely forgotten how my CSR adjacency matrix even works. :(
08:24:39 <solonarv> (you can try in GHC Haskell, but it is a bit tricky)
08:25:24 <solonarv> % reallySame (!x, !y) = isTrue# (reallyUnsafePtrEquality# x y)
08:25:25 <yahb> solonarv: 
08:25:40 <solonarv> % let x = Just 'a' in reallySame (x,x)
08:25:40 <yahb> solonarv: True
08:25:49 <solonarv> % reallySame (Just 'a', Just 'a')
08:25:49 <yahb> solonarv: False
08:26:07 <phadej> again. latter might change to True
08:26:09 <phadej> you cannot know
08:26:34 <solonarv> do you mean that optimizations might rewrite the latter to the former?
08:26:43 <phadej> yes
08:26:54 <phadej> CSE is a thing
08:27:37 <solonarv> oh of course, I was responding to your "are (possibly) different in memory byt you cannot tell them apart"
08:27:53 <merijn> dminuoso: How?
08:28:09 <merijn> dminuoso: There's not much to even forget...
08:28:15 <solonarv> you might be able to use this to detect cyclic structures, but it sounds really brittle and I don't think it would work well
08:28:19 <phadej> solonarv: my point is that if you try to (e.g. with a trick you showed) your thing probably won't work
08:29:28 <phadej> i.e. try to think of less hacky way to do what you do :)
08:29:41 <solonarv> yeah I agree
08:30:57 <solonarv> only legitimate use of reallyUnsafePtrEquality# I've seen is the sharing improvements in containers, and that has a bunch of careful engineering on top - not just pointer equality sprinkled all over the place
08:31:49 <dminuoso> merijn: Afaik I maintain one vector with data, and then a (flat) edge vector consisting of (conceptual) slices of indices into the data vector, and the vertex vector contains indices into the edge vector, denoting the boundaries of the slices of edges connected to the current vertex. That right?
08:31:49 * hackage chessIO 0.3.1.2 - Basic chess library  https://hackage.haskell.org/package/chessIO-0.3.1.2 (mlang)
08:32:10 <dminuoso> I think the representation is not enough for me. I need to label the edges on both sides. :(
08:33:07 <dminuoso> Though, supposedly, I could change the edge vector from V.Vector Int to `V.Vector (Int, Label, Label)`
08:33:26 <merijn> dminuoso: You have one array of V+1 elements that map vertex ids to offsets in the second array
08:33:45 <merijn> The second array is E elements long and holds the destination for each edge
08:34:40 <dminuoso> Right
08:34:54 <merijn> See here if you need inspiration: https://github.com/merijn/Belewitte/blob/master/GraphRep.hpp ;)
08:35:07 <dminuoso> So right now that second array contains Int that are offsets into a data array that contains information about the vertices.
08:35:19 <dminuoso> Im thinking to turn this into (Int, Text, Text) because I need labels on the edges
08:35:56 <merijn> If you need data for edges you can trivially just have a 2nd (3rd, 4th, etc.) vector of E elements holding the data for each corresponding edge
08:36:29 <dminuoso> Ah, so 2 vectors (where the first would contain "from" labels and the second would contain "to" labels)
08:36:43 <dminuoso> Mmm that would work I guess
08:36:56 <ezzieyguywuf> dminuoso: sounds like a graph
08:37:03 <ezzieyguywuf> i only just stepped into the convo though
08:37:19 <merijn> dminuoso: The from is usually implicit
08:37:22 <dminuoso> ezzieyguywuf: This is a CSR representation of an adjacency matrix to represent an undirected graph :)
08:37:26 <merijn> dminuoso: What operations do you need to do?
08:37:50 <dminuoso> merijn: I want to derive a dot graph from this, and it turns out I need the edges connected to *ports* rather than *nodes*
08:37:53 <merijn> i.e. why do you need to know the origin of the edge, rather than accessing it implicitly
08:37:57 <dminuoso> (So my edges need to include port information)
08:38:01 <dminuoso> on both sides
08:38:53 <dminuoso> so I want something like "foo":"swp1" -- "bar":"swp1"
08:39:15 <dminuoso> (where "foo" and "bar" are vertices, and "swp1" are sort of a label of the edge
08:39:18 <ezzieyguywuf> or you could have your nodes hold a `data NodeType = Port | Node`, and the edges would now only have adjacency information between these
08:40:11 <dminuoso> merijn: Not necessarily the origin, rather a "label". Concretely, think of switches connected with cables. I not just need to track which devices are connected with each other, but at some point I need to know which *ports* in the devices they are connected to.
08:40:47 <dminuoso> But creating an additoinal vector to hold edge labels works fine I guess
08:40:57 <merijn> dminuoso: You seem to be making things very confusing by conflating ideas of the *graph* with ideas about the data it represents
08:42:09 <dminuoso> merijn: Huh? 
08:42:50 <merijn> At least, *I* am lost what part is referring to your representation and which parts of your problem refer to what it represents
08:45:02 <xe4> is there a version of "these" which supports more than 2 arguments or is there a way use "these" which allows it handle more than 2?
08:46:13 <dminuoso> merijn: Consider the question differently. If I wanted to store weights of edges, would I just maintain another vector of weights, parallel to the vector containing destinations for each edge.
08:46:25 <solonarv> xe4: it's not pretty, but nesting them works
08:46:41 <solonarv> e.g. 'These a (These b c)' is basically 'These3 a b c'
08:47:46 <ezzieyguywuf> i agree with merijn 
08:47:50 <merijn> dminuoso: Yes, or put them in the same vector, those options are isomorphic
08:50:50 <xe4> solonarv: that's an idea
08:53:33 <solonarv> you can even make it a bit prettier by using infix notation: 'a `These` b `These` c'
08:57:30 <L29Ah>     • Unexpected strictness annotation: !a
08:57:31 <L29Ah>       strictness annotation cannot appear nested inside a type
08:57:32 <L29Ah>     • In the type ‘!a’
08:57:33 <L29Ah>       In a pattern type signature: !a
08:57:34 <L29Ah>       In the pattern: makeList :: !a
08:57:36 <L29Ah> wat
08:58:19 <solonarv> what part of this error text confuses you?
08:58:20 <monochrom> The compiler is right.
08:59:06 <L29Ah> i don't see anything nested there
08:59:38 <monochrom> Not very deep nesting, but it is still nesting.
09:06:48 <pera> Hi, last night I was playing a bit with pattern matching and I was wondering if someone could explain why this is a "valid" Haskell program: main = let [x] = [] in x
09:07:17 <ja> pera: because [] is a data constructor
09:07:21 <pera> ("valid" as in typechecks and compiles, but produces a non-exhaustive pattern exception)
09:07:35 <ja> pera: are you asking why it compiles?
09:07:36 <monochrom> "does the value actually match the pattern?" is not cared at compile time.
09:07:50 <pera> ja: yes
09:08:06 <monochrom> Only syntax and types are cared.
09:08:10 <ja> pera: how would haskell know that you shouldn't be able to match on the [] constructor in this case?
09:08:11 <pera> monochrom: interesting
09:08:23 <solonarv> pera: what specific thing do you think the compiler should complain about?
09:08:52 <pera> too many questions, and i don't know the answer haha
09:09:01 <pera> solonarv: I am not sure to be honest
09:10:11 <solonarv> well, as monochrom said: it's syntactically correct and it typechecks, which means compilation succeeds
09:10:16 <pera> first, [x] = [] seems to me equivalent to head [], but I guess this is not correct
09:10:29 <solonarv> it's equivalent to 'x = head []', yes
09:10:33 <ja> @src head
09:10:34 <lambdabot> head (x:_) = x
09:10:34 <lambdabot> head []    = error "Prelude.head: empty list"
09:10:58 <monochrom> It includes head []. It also includes tail x matching [].
09:11:03 <solonarv> (well, the exact error message is different)
09:11:04 <pera> I know that's why I was saying that xD
09:11:11 <monochrom> But head [] isn't statically rejected either.
09:11:21 <pera> oh I thought it was
09:11:38 <solonarv> nope
09:12:04 <ja> if the amount of elements is not in the type, how could it be rejected?
09:12:05 <solonarv> maybe a linter would warn you, and maybe there should be a warning for this sort of thing (there could be, but there isn't)
09:12:40 <pera> ja: you are right
09:15:33 <pera> for whatever reason I thought that [] would be a special case in the compiler
09:15:59 <monochrom> Too much work. They didn't bother.
09:16:06 <pera> haha right
09:16:38 <monochrom> Also if they provided that, users would get greedy and ask for more special cases. It's a rabbit hole.
09:17:20 <ja> but [] is a special case right? but only a special case of syntax
09:17:27 <frdg> merijn: sorry I lost internet when you were helping me earlier. Here is a rundown of the issue https://dpaste.org/0xLw
09:17:47 <ja> like, how do you define a data constructor that takes its argument in the middle like [...] does?
09:18:20 <ja> @src []
09:18:21 <lambdabot> data [] a = [] | a : [a]
09:18:26 <monochrom> "of syntax" is redundant because the computer does everything syntactically, i.e. formally, i.e. symbolically.
09:19:32 <ja> but how do you describe the fact that the list data constructor cannot be defined for your own list type?
09:19:57 <ja> in a way that makes it look the same, taking the argument in the middle
09:20:04 <monochrom> If you recall the technique of "constant folding" in code optimization, the compiler actually has machinary for a large class of these cases, though too late in the compiler pipeline.
09:21:32 <monochrom> For example "let 4 = sin 0" could also be caught, because the optimizer should be statically discovering sin 0 = 0 anyway.
09:21:32 <ja> too late? wouldn't it be too early, since it is opaque to a programmer?
09:22:08 <monochrom> too late because static errors are supposed to have been filtered out before you do code optimization.
09:22:09 <davean> ja: the term is "syntactic sugar"
09:22:51 <ja> davean: if "of syntax" is redundant, then surely "syntactic sugar" must also somehow be :O
09:22:54 <monochrom> code optimizer probably don't have line-number information to produce a half-decent error message.
09:23:19 <monochrom> "syntactic sugar" is syntax-to-syntax transformation
09:25:02 <monochrom> The term "syntax sugar" is for humans. Humans don't just have syntax, so you have to remind them this sugar is for syntax.
09:25:20 <dolio> `let 4 = sin 0 in ...` doesn't do anything different than `...`, so it wouldn't make much sense to statically rule it out.
09:25:25 <monochrom> But "special case of syntax" for the compiler is simply "special case". It knows nothing else.
09:26:28 <monochrom> Sure, but users may like a warning and contemplate feasibility. Then users get greedy and -Werror
09:26:32 <pera> ja: I'm not sure if I understand your question but most grammars I know define some sort of (recursively defined) list of terms that can be empty, so your parser will find a [ and then expects either an element of a list or nothing, followed by a list or a ]
09:27:09 <monochrom> If you conclude that users don't make much sense, I won't disagree. :)
09:28:27 <ja> > let [] = [1] in []
09:28:27 <pera> anyways, thanks everyone for the explanations :)
09:28:29 <lambdabot>  []
09:29:57 <ja> pera: i do agree with monochrom, like, if you know the syntax for lists, and you know how matching works, the question you asked is no different from a question regarding any other datatype where matching can fail
09:30:29 <ja> pera: so that leads me to think that your confusion must be regarding the syntax of lists
09:30:53 <AWizzArd> Coding in Haskell style can mean to create trees at runtime (i.e. nested values) and write an interpreter to execute code. How much slower is approach in your experience?
09:31:24 <pera> ja: "and you know how matching works" <- I don't actually hahaha that's why I was doing some experiments
09:32:15 <ja> this got me thinking, when haskell sees a [, does it know upon seeing that symbol whether this is a pattern match, a value, or a type?
09:33:23 <ja> in the let example above, is the it "pattern match", "value", "value"? is this a wrong distinction to make?
09:33:48 <dolio> In my experience, it's actually annoying when compilers try to do these kind of semantic checks on trivial stuff.
09:34:41 <pera> dolio: really? why?
09:34:44 <ja> dolio: so you're saying that you're ok with my let example being permissible?
09:34:45 <dolio> Like, I think visual studio complains if you do `if false`, because it's 'dead code', but that prevents you from toggling logic for debugging purposes.
09:35:22 <dolio> So you actually have to do more complicated editing to debug your logic.
09:35:33 <pera> oh that, yeah I agree
09:35:35 <dolio> And the checks don't actually catch any interesting cases.
09:36:49 <ja> but if i have an unreachable pattern match, would you like it to complain about that?
09:36:55 <pera> but for instance statically checking for something like [a,b,c,d,e,f]=[1,2,3,4,5] doesn't seem a bad thing to me
09:37:05 <ja> dolio: it is the same situation, just on type level, no?
09:38:40 <ja> pera: checking what? everything is already checked. the types are just not as expressive as you'd like. if you like dependent types, they won't be first-class in haskell for quite a while
09:39:01 <dolio> It's fine to run those checks on, like, CI builds, and it really sucks to not be able to turn it off.
09:39:18 <pera> I mean, it doesn't need to be part of the typechecker
09:40:18 <ja> pera: aaah is this regarding literals? you would haskell to special case literals and have more matches on those?
09:40:22 <pera> yeah
09:40:24 <dolio> SQL is another example. There are all kinds of cases where 'trivial' queries are ruled out as being syntactically inadmissable.
09:41:03 <ja> pera: but they equational reasoning breaks down, no? ;)
09:41:48 <ja> pera: probably 'pragmatic' languages like f# already do as you wish... i think most people appreciate that in haskell, equational reasoning works better
09:42:31 <pera> dolio: I think warnings are good for thos kind of cases but erroing and stopping compilation (like Go does for the most trivial thing) is extremely anoying when you are debugging stuff
09:42:38 <pera> ja: right xD
09:44:05 <ja> pera: if you wanna maximize complexity, maybe go for constexpr in c++, maybe they will write a few chapters in their standards for you about the inferenence a compiler is required to do to catch the case you talk about ;) "now detects errors in up to  5 nested constexpr bindings!" ;)
09:44:17 <ski> dolio : i suppose it's a case of the dogma "include trivial cases"
09:44:27 <pera> I mean I understand it could be confusing, maybe those sort of errors should be marked in such a way so programmers understand why they were statically checked in the first place
09:44:45 <pera> lol
09:45:25 <ski> pera : `(a,b,c,d,e,f) = (1,2,3,4,5)' ?
09:45:54 <pera> that's different though
09:46:10 <pera> and it makes sense for the typechecker to fail I believe
09:48:32 <pera> (uh I mean for the typechecker to produce an error for that code)
09:49:45 <ja> pera: haskell's syntax is becoming more and more flexible (see QualifiedDo)... so that means the concept of 'literal' starts to break down
09:50:31 <ja> like, haskell is already kinda unique in having the Num typeclass right? at least compared to interpretation-oriented languages
09:50:44 * pera is reading about QualifiedDo
09:51:10 <dolio> The problem with the C# thing I'm talking about, and ruling out `let [] = [1]` is that it's only catching trivial stuff, because catching any similar non-trivial cases is too difficult.
09:51:53 <ja> dolio: yeah, makes sense. and my argument is that if you try to bolt on that stuff later, it'll be like c++
09:54:39 <ja> i wonder how much of the complexity of a modern c++ compiler is about weird things bolted on, and how much is the optimization everybody appreciates so much. that ratio should be different in ghc, right?
09:55:21 <ski> ja : "interpretation-oriented languages" being ?
09:56:03 <ja> ski: languages where you can start from the top and just start executing... perl, for example, i believe? some dynamic langauges have macro systems and AST's, so that's why i didn't say dynamic
09:58:07 <ja> but i guess in perl, you may be able to override the number literal parser mid-execution :O
10:00:55 <dsal> erlang has those mechanisms, but crashing is kind of an important thing there.
10:02:32 <ski> mhm
10:06:55 <ezzieyguywuf> hm, let's say I have `type MyState = State.State [Char]`, and `getVal :: Int -> MyState Char`. What's a sane way of dealing with the case where `getVal` is called with an index that is out-of-bounds? Do I need to go as far as using an ExceptT monad? Or should I instead `getVal :: Int -> MyState (Maybe Char)`?
10:07:15 <ezzieyguywuf> this seems like it should be a common enough problem, I feel like I'm just missing the forest for the trees
10:07:30 <ski> what's `getVal' for ?
10:08:00 <ezzieyguywuf> specifically, if I have `useVal :: Char -> MyState ()`, I want to be able to `getVal >>= useVal`, though maybe i'm misusing (or abusing?) the State monad now?
10:08:22 <ezzieyguywuf> `getVal n = gets (!!)`
10:08:39 <ezzieyguywuf> hrm, don't think that syntax is correct...but it just returns the nth element in the list
10:10:09 <ski> but what is it for, why have you defined it ?
10:11:26 <ski> @type gets . flip (!!)
10:11:27 <lambdabot> MonadState [a] m => Int -> m a
10:12:25 <ezzieyguywuf> ski: because my user may need to interrogate/manipulate a specific value in the list
10:12:41 <ezzieyguywuf> (the [Char] is a simplified data type I'm using here for the sake of discussion)
10:15:48 <ski> ezzieyguywuf : and they're referring to them, by index ?
10:16:24 <ezzieyguywuf> ski: for the purposes of this example yes.
10:17:12 <ezzieyguywuf> ...although this conversation has me rethinking the utility/need for getVal at all...
10:18:17 <ezzieyguywuf> maybe 'hasVal :: Char -> MyState Bool' is what I'm after, but nonetheless I know I'm going to need something like `useVal :: Char -> MyState ()`, where the operation can't work if the `[Char]` does not contain the value passed in
10:18:44 <ezzieyguywuf> perhaps I should work up an example
10:19:12 <ski> is passing an incorrect `Int' a programming error ?
10:19:33 <ski> (or a run-time error)
10:19:44 <ezzieyguywuf> runtime error
10:20:26 <ezzieyguywuf> although this does get to the fundamental question I have: is it feasible to turn this into a programming error?
10:20:29 <ski> i mean, does it indicate an error in the code, or just a condition that may legitimately appear, and that you need to handle ?
10:20:35 <ezzieyguywuf> i.e. catch it at compile time
10:20:42 <ezzieyguywuf> I doubt it
10:30:49 * hackage free-category 0.0.4.2 - efficient data types for free categories and arrows  https://hackage.haskell.org/package/free-category-0.0.4.2 (coot)
10:37:58 <AWizzArd> I am trying out to use cabal with nix. I did a verbose `cabal -v update` and noticed how it stores the info at ~/.cabal/packages/hackage.haskell.org/01-index.cache  —  which seems to be a pretty global place, no?
10:38:59 <AWizzArd> Shouldn't there be a per-project location? So I can pin different projects to different nixpkgs versions.
11:14:19 <dmj`> AWizzArd: when using nix w/ cabal you never rely on cabal's resolver, so commands like install and update have no effect
11:14:47 <dmj`> AWizzArd: nix provides to you a ghc-pkg list and cabal sees it doesn't need to use its resolver and just builds
11:17:06 <ja> but what prevents cabal from installing a dependency outside nix if it is missing?
11:17:07 <maerwald> AWizzArd: pinning different index states doesn't require mulitiple index files
11:17:28 <maerwald> you just tell you index state in cabal.project
11:20:52 <dmj`> ja: it will install it locally, it might try to use two ghc-pkg lists to build your project
11:21:15 <dmj`> ja: which is approaching the hell of cabal
11:21:23 <dmj`> you'll begin to smell the sulfur
11:21:30 <dmj`> and the ashes
11:21:51 <dmj`> as the fires of cabal hell rage loudly
11:22:26 <ja> i never had that many problems with cabal, but i only really started using it with version 3 :D    i still have nightmares from nixpkgs though ;)
11:31:29 <dmj`> ja: I've had the opposite experience
11:32:10 <davean> Yah I have no idea what this cabal hell thing is
11:33:07 <jle`> is uh... the name of the type in 'GHC.Generics.Rep' ever going to disagree with the 'Show' instance for 'Data.Typeable.typeOf'
11:33:33 <solonarv> uhh... I sure hope not
11:33:36 <dolio> It doesn't even rhyme.
11:33:40 <solonarv> actually, someone could handwrite a bad Generic instance
11:33:50 <jle`> yeah, i suppose i'm talking about derived instances
11:33:53 <jle`> for both
11:36:01 <solonarv> you can't handwrite bad Typeable instances, as far as I can tell
11:36:17 <solonarv> there is nothing exposed that would allow you to construct a bad TypeRep
11:36:24 <ja> dmj`: my experience from nixpkgs comes from trying to port some packages to freebsd when there was still no standard environment for that in nixpkgs. so all kinds of essential packages would have all sorts of linux specific hacks. so probably not the common experience of nixpkgs, but i think the problems i encountered were manifestations of the way it is built... this was years ago, i don't know if the 
11:36:27 <jle`> hm. so i...can hope it'll be safe?
11:36:29 <jle`> heh heh
11:36:30 <ja> debugging experience has improved
11:38:06 <hseg> just noticed i'm running on old ghc and decided to move to system-provisioned ghc. any caveats i should be aware of? (arch linux)
11:38:37 <hseg> idea is to have ghc+cabal managed by system, and have cabal manage whatever libs i'm using
11:39:03 <yushyin> I just use ghcup
11:39:05 <MarcelineVQ> you should really prefer ghcup ime
11:39:06 <solonarv> hseg: common advice is "don't"
11:39:07 <solonarv> use ghcup
11:39:24 <dmj`> ja: yea just use nix, 60% of the time it works every time
11:39:33 <ja> hahaha :P
11:39:36 <glguy> hseg: Using system-managed GHC is a bad idea for development because it ties you to your system's timeline for version upgrades
11:39:45 <yushyin> ^ this
11:39:54 <hseg> yes? but i want the shiny?
11:40:05 <glguy> system-managed compilers are better for compiling system-managed packages for you
11:40:12 <hseg> ah
11:40:18 <ja> hseg : ghcup can give you shiny ;)
11:40:23 <solonarv> ghcup should have new GHC versions ~immediately; does your system package manager?
11:40:47 <hseg> sufficiently closely for my tastes
11:40:55 <hseg> (am on arch)
11:41:03 <solonarv> well, arch ships a weird GHC/cabal/libs configuration that is kind of broken by default
11:41:17 <solonarv> there is a steady trickle of (usually new) haskell users asking for help here because of that problem
11:41:24 <glguy> If your GHC needs are sufficiently minimal that using whatever GHC you happen to be upgraded to by your distro then that might be OK
11:41:31 <hyiltiz> How common is it to use an alternative Prelude (which one? Protolude? Rio?), or it is generally frowned upon?
11:41:35 <glguy> but it's not suitable for most serious dev
11:41:35 <hseg> ok
11:41:39 <MarcelineVQ> iirc you can get a working ghc by installing ghc and ghc-static but any system installed haskell libs are going to be trouble
11:41:50 <ja> hseg: looks like arch doesn't ship 8.8. that could be a problem since many packages don't work with 8.10.
11:42:19 <MarcelineVQ> ghcup is on the AUR fwiw
11:42:21 <glguy> 8.10 has pretty good coverage by now; it depends on what corner of Hackage you live in
11:43:04 <maerwald> MarcelineVQ: and it's even recent
11:43:06 <solonarv> jle`: okay I checked more thoroughly, without unsafeCoerce you can't produce a bad TypeRep
11:43:26 <maerwald> surprising
11:43:29 <solonarv> its constructors are defined in Data.Typeable.Internal, are not exported, and that module itself is not exposed
11:43:56 <yushyin> another good reason to prefer ghcup, multiple ghc installations are easy.
11:44:24 <solonarv> I also personally like that it lives entirely in ~/.ghcup
11:45:01 <dmj`> nix entirely lives in /nix
11:45:13 <glguy> That's what wrong with it; it doesn't live in ~/.ghcup
11:45:27 <solonarv> yes, and nix wants root for that - this annoys some people
11:45:37 <solonarv> (not me, because I don't really use nix anyway :p)
11:45:40 <hseg> ok. so recommended path is to get ghcup, get ghc+cabal from there, and go on from there?
11:45:41 <jle`> yeah, i'm more concerned about the tyConName being different than what would be found in GHC.Generics.Rep
11:45:51 <yushyin> hseg: yes
11:46:05 <solonarv> jle`: I don't think that will happen unless someone handwrites a bad Generic instance
11:47:04 <jle`> hm, thanks :) i wonder if there is any sort of  mention of this in ghc docs
11:47:04 <dmj`> glguy: lol
11:47:36 <dmj`> I bet you could put nix into ~/.ghcup somehow
11:47:40 <dmj`> :P
11:47:46 <solonarv> jle`: that I don't know, maybe #ghc knows?
11:47:48 <maerwald> then the cache breaks, no?
11:48:11 <solonarv> maybe you could symlink /nix to ~/.ghcup/nix :p
11:48:51 <maerwald> upcoming: `ghcup install nix`
11:48:52 <jle`> wouldn't hurt to drop by i suppose
11:49:10 <hseg> ok. can keep my static stack build around for packaging whatever tools i need
11:49:24 <hseg> and then this will provision my daily toolchain
11:49:26 <hseg> can live with that
11:52:09 <dolio> dmj`: Apparently there are fundamental design decisions that mean that nix has to put things in /nix (at least, I've heard that recently).
11:52:46 <maerwald> dolio: I think it's actually just the cache
11:53:04 <ja> do dynamic objects not have hardcoded paths that point to /nix?
11:53:04 <dolio> Yeah, it has to do with the build caching.
11:53:10 <dmj`> dolio: yea, wouldn't surprise me.
11:53:11 <maerwald> e.g. they were considering using a different location on macOS
11:54:05 <dmj`> maerwald: the cache is just a mapping of .drv's to store paths. I guess the .drv's do include absolute paths to the store
11:54:13 <ja> solonarv: you cannot symlink /nix, i tried, nix complains. i did a bind mount instead
11:54:46 <maerwald> bind mounts are nice to get infinite recursive copy operations :p
11:55:28 <dolio> dmj`: I think the problem is that the executables include the absolute path, and you can't patch them with any paths that replace "/nix" with a longer string.
11:55:29 <solonarv> just make sure your filesystem is at least a DAG, what's the problem :p
11:55:55 <maerwald> solonarv: I've tried a couple of file managers, most don't check for this condition
11:56:05 <maerwald> although it's possible to check it
11:57:38 <maerwald> I think I messed up a recursive deletion once due to bind mounts, since then I don't like them anymore
12:00:59 <ja> dolio: but nix already has patchelf which will often end up making a much longer path, since it has to include the hash, no? so if you build from source, surely it shouldn't be the problem. of course binary caches don't work, since you probably can't patchelf a built package
12:01:41 <dolio> If you build everything yourself from source it probably isn't a problem.
12:05:35 <dmj`> dolio: yea rebuilding the nix binary to use a new path would hopefully work, but it wouldn't surprise me if "/nix" was hardcoded somewhere
12:06:09 <ezzieyguywuf> hm, I have a data type that I'm considering making an instance of Applicative, however I really only want the `pure` behaviour, I don't really thing <*> makes sense for it
12:06:13 <ezzieyguywuf> is there a different typeclass that would be a better fit?
12:06:36 <monochrom> I think it's called Pointed.
12:07:04 <dmj`> whatever happened to the monad of no return proposal? 
12:07:18 <monochrom> It's somewhere on Hackage. Or you can just define your own, it's just two lines.
12:07:51 <monochrom> Or don't use any class at all, if you have only one instance anyway.
12:08:09 <ezzieyguywuf> yea, no problem defining my own, I just wasn't sure if there was a good reason it wasn't already in prelude
12:08:15 <ezzieyguywuf> i.e. maybe I'm thinking about things wrong
12:08:15 <dmj`> @package pointed
12:08:15 <lambdabot> https://hackage.haskell.org/package/pointed
12:08:17 <dmj`> https://wiki.haskell.org/Why_not_Pointed%3F
12:08:21 <ezzieyguywuf> nah I have 3
12:08:37 <dmj`> ezzieyguywuf: can you show us what your data type looks like
12:09:33 <dmj`> ezzieyguywuf: for list, for example, 'pure' is just \x -> [x]. So making it an instance of anything might not be worth it. Same with Maybe, pure is just Just
12:10:06 <ezzieyguywuf> dmj`: my data type is `newtype Vertex = Vertex Int`, and then the same for Edge and Face
12:10:27 <dmj`> ezzieyguywuf: well that isn't even a Functor
12:10:45 <dmj`> ezzieyguywuf: you could factor out the Int to be 'a'
12:11:04 <dmj`> ezzieyguywuf: then you could derive Functor, Applicative, etc. w/ GNTD
12:11:27 <ezzieyguywuf> this way, I can have something like `makeEdge :: Vertex -> Vertex -> MyState Edge` and prevent user from trying to make an Edge with two Edge
12:11:56 <ezzieyguywuf> dmj`: but I don't need Functor, that's why I stopped short of defining an Applicatie instance
12:12:51 <dmj`> ezzieyguywuf: wouldn't a Vertex be (Int, Int, Int)
12:13:02 <dmj`> ezzieyguywuf: assuming you're on a 3D plane
12:13:22 <ezzieyguywuf> nah, this is a "Topological" Vertex, i.e. it's relational information
12:13:34 <dmj`> ah, ok
12:13:39 <ezzieyguywuf> "A Vertex is an entity that can be connected to one or more Edges" etc. that kind of thing
12:15:29 <ezzieyguywuf> the reason I was looking for `pure` is so that I could do something like `addData :: Pointed a => Which -> State a` where `data Which = Vertex | Edge | Face`, or something along these lines
12:16:46 <monochrom> I think you have a kind error.
12:17:00 <ezzieyguywuf> ehrm, more likely `data Which = WhichVertex | WhichEdge | WhichFace`
12:17:06 <monochrom> You are looking for Default, which is worse.
12:17:10 <ezzieyguywuf> monochrom: yea, i named my data types poorly there.
12:17:19 <ezzieyguywuf> monochrom: worse than what?
12:17:28 <monochrom> Default is worse than Pointed.
12:17:56 <ezzieyguywuf> is Pointed bad?
12:18:09 <monochrom> Pointed, being * -> * and having some relation with fmap and <*> whenever they exist, at least enjoys one law.
12:18:44 <ezzieyguywuf> in fact, Pointed does seem to be what I'm looking for
12:18:59 <monochrom> Pointed is somewhat good but not good enough compared to the mental cost of learning so many classes, like what Kmett said in a link above.
12:19:13 <ezzieyguywuf> I'm usually hesitant to use obscure things like this, though, lest I don't really know what I'm doing.
12:19:24 <monochrom> But Default, it doesn't even have one law. It's just DWIM.
12:19:53 <monochrom> I also realize you have a forall-vs-exist error.
12:20:07 <dmj`> ezzieyguywuf: it's impossible to make an instance of Pointed for Which, Vertex, Edge, etc.
12:20:17 <koz_> DWIM?
12:20:50 <monochrom> "forall a. Pointed a => Which -> State a" implies that the caller can choose a=Edge, despite giving you the parameter WhichFace.
12:20:56 <monochrom> "do what I mean"
12:21:18 <monochrom> or rather, forall a. Default a => Which -> State a
12:21:37 <ezzieyguywuf> monochrom: hrm, not sure if I follow
12:21:51 <monochrom> OK, based on a true story.
12:21:52 <ezzieyguywuf> the value of Which will determine which `a` is produced
12:22:05 <dmj`> Pointed :: (* -> *) -> Constraint, Vertex :: * 
12:22:29 <monochrom> A beginner writes this wrong code and can't believe it's wrong: "f :: a -> a; f n = n+1".  How would you explain to the beginner?
12:23:04 <monochrom> The beginner's belief is: "since 'a' can be any type, I'm choosing Int. why is that wrong?"
12:24:44 <ezzieyguywuf> hm, I can tell that it hould be `f :: Int -> Int`, but "why is that wrong?"....
12:24:50 <dmj`> I'd ask what is 1's type
12:25:01 <ezzieyguywuf> what dmj` said
12:25:03 <dmj`> is 1 too specific?
12:25:06 <dmj`> etc.
12:25:26 <monochrom> OK, "g :: a -> a; g _ = True". No Num polymorphism.
12:26:07 <monochrom> or boiling away the non-essential, "myval :: a; myval = ()"
12:26:08 <ezzieyguywuf> again I can tell this is nonsensical intuitively, b/c it is always Bool so what need is there for the polymorphic type
12:26:14 <ezzieyguywuf> indeed what need is there for the argument at all
12:26:49 <monochrom> But why is it illegal? You can always do silly things and the compiler will accept if legal. Why is this one not even accepted?
12:27:02 <ezzieyguywuf> monochrom: in this case, it's pretty obvious why it's wrong. How can the type be both () and 'a' at the same time?
12:27:20 <monochrom> OK, let me ramp it up.
12:27:35 <dmj`> to play devil's advocate, "can't 'a' be () since 'a' is any type?"
12:27:36 <ezzieyguywuf> based on that, I could write `1 + myval` or `(:) myval []`
12:27:40 <monochrom> "myord :: Ord a => a; myord = True". Why is it also illegal?
12:28:21 <monochrom> dmj`: And the beginner reply: "since 'a' is any type, I can choose any type, I'm choosing () now"
12:28:34 <monochrom> err you're saying that :)
12:28:46 <monochrom> forgot what "devil's advocate" means :)
12:28:51 <ezzieyguywuf> lol
12:29:00 <dmj`> it's a very good question, by the student
12:29:08 <dmj`> very valid
12:29:23 <monochrom> If you can crack myord, it's the same issue as addData.
12:29:32 <ezzieyguywuf> indeed. it seems the answer should be something along the lines of "you're thinking about things backwards"
12:30:25 <monochrom> Perhaps hint: Two-person game. Programming is a dialectic class struggle between the user and the implementer.
12:31:01 <ezzieyguywuf> myord = True is firmly stating that `myord :: Bool`
12:31:07 <monochrom> Allow me to go overboard and add: My Freedom Is Your Slavery. Your Ignorance Is My Strength. (Not sure how to butcher Love Is Hate.)
12:31:12 <ezzieyguywuf> so `myord :: a` is wrong
12:31:29 <dmj`> you can call 'g' with 'True', but you can't define 'g' with 'True', because the arguments of 'g' should be a value that represents all types, not just 'True'.
12:31:33 <ezzieyguywuf> ∴
12:32:01 <monochrom> (Oh, I think I have one. I Love What You Hate.)
12:33:52 <ezzieyguywuf> if `newtype Vertex = Vertex Int; newtype Edge = Edge Int`, and I want to have `myData :: [a]` such that 'a' is _only_ a Vertex or Edge, how would I go about that?
12:34:10 <monochrom> Right, you can't.
12:34:40 <hyperisco> monochrom, what is your success with the other actor explanation, i.e. it isn't you who is choosing, it is someone else, and you've told them they can choose any type
12:34:52 <ezzieyguywuf> I could obviously do `data Entity = Vertex Int | Edge Int`, but then this leads to the problem in `addEdge :: Entity -> Entity -> MyState Entity`, where the user could request to add an Edge btween two Edges
12:35:03 <ezzieyguywuf> monochrom: right. I can't
12:35:08 <monochrom> 100% perfect success.
12:35:25 <monochrom> No further confusion from students.
12:35:59 <ezzieyguywuf> but since I can't...perhaps I haven't framed the problem correctly
12:36:43 <hyperisco> an example of a successful analogy at last? :)
12:37:04 <monochrom> In fact I now have questions on exams like "g :: (a -> a) -> a -> (a,a), I tested it with g (\x -> x++"aa") "x", I got such and such answer, can you predict what g (2 +) 3 does?" and many students answer correctly.
12:37:27 <monochrom> It is not an analogy, it is reality.
12:37:42 <monochrom> You give me a polymorphic function, I really choose its type.
12:39:10 <koz_> That's them implicit foralls.
12:39:30 <koz_> In reality, the type 'a -> b' means 'forall a b . a -> b'.
12:40:59 <ezzieyguywuf> "forall" meaning "for any type"?
12:41:26 <monochrom> both "for all" and "exist" carry "can by anything". That has never been the contention.
12:41:43 <monochrom> The contention has always been: OK, so who has the final say?
12:41:53 <monochrom> user? implementer? big dfference.
12:42:03 <monochrom> My Freedom Is Your Slavery.
12:42:27 <monochrom> If I (user) am the one who makes the choice, you (implementer) obey.
12:42:43 <slack1256> I had a great post on that subject but I did it on spanish ;_;
12:42:56 <ezzieyguywuf> slack1256: I know spanish
12:42:58 <monochrom> In "myval :: a", the implementer has no freedom to choose Bool. That freedom belongs to the user.
12:43:15 <slack1256> Nice I will look it up
12:43:39 <monochrom> (this is what "for all" is trying to say. "exists" says the implementer has freedom, the user doesn't.)
12:43:58 <ezzieyguywuf> what is "exists'?
12:44:20 <monochrom> (this is why OOP is mostly existential types, at odds with Haskell's implicit for-all types.)
12:46:45 <ezzieyguywuf> hm, I'm still not convinced my `addData` is a lost cause though. If I know ahead of time (as the implementer) that `WhichVertex should produce a Vertex, WhichEdge should produce an Edge`, then I should be able to code that up, right?
12:46:46 <slack1256> forall, exists and bare types are in a hierarchy of definitness at term level.
12:46:54 <slack1256> ezzieyguywuf: https://pastebin.com/y7rYnvQw maybe it is your interest.
12:47:00 <monochrom> "`addData :: Pointed a => Which -> State a" can't be done because the implementer wants the right to choose a=Vertex or a=Edge etc.
12:47:19 <monochrom> But gladly this can't be done on the count of XY problem, really.
12:48:42 <ezzieyguywuf> monochrom: I finally see. This would allow for something like `needsVertex (addData WhichEdge)` where `needsVertex :: Vertex -> Blah`
12:48:50 <monochrom> The XY problem is that the user request Vertex vs Edge via the Which parameter, then the implementer has freedom to choose Vertex or Edge, but the implementer uses this freedom to obey the user.
12:49:13 <hyperisco> monochrom, I think it carries extra baggage by suggesting choosing as a human action, and me versus someone else, but I do agree it is a tight fitting analogy
12:49:18 <monochrom> The real problem is the user chooses Vertex vs Edge. So, simply Point a => State a.
12:49:45 <ezzieyguywuf> 😮
12:49:50 <monochrom> For an edicational example, consider the Bounded class and its minBound, maxBound methods.
12:49:52 <hyperisco> okay so type theory question
12:50:31 <ezzieyguywuf> monochrom: I see how `Point a => State a` could accomplish what I'm after. but after reading that wiki page linked, I'm wondering if I should prefer to avoid Pointed altogether
12:50:37 <monochrom> hyperisco: which subset of the following is extra baggage? {human action, me, someone else}.
12:51:11 <monochrom> which subset doesn't happen in reality?
12:51:13 <hyperisco> it seems possible to me to have a system in which forall types 'a', 'id' has the type 'a -> a'. it also seems possible to have a system in which 'id' has the type 'forall a. a -> a'... does this distinction have a name?
12:52:09 <dolio> It's not particularly clear what you mean.
12:52:10 <unclechu> hey, stackage.org is extremely slow to me, i'm looking there to see packages per specific snapshot. does anyone has the same experience?
12:52:10 <hyperisco> monochrom, I am presupposing a mathematical description is the true description, and talking about people choosing things is an analogy of the mathematics
12:52:11 <monochrom> the latter is parametric polymorphism. the former is ad hoc polymorphism, even generics. Java does the former, even with its generics, really.
12:52:41 <unclechu> and are there any mirrors, i don't know. when it responds so slowly (it can take 30 seconds for a response) it really slows down the work
12:52:42 <hyperisco> I don't think deciding whether this is really an analogy or not is all that important though
12:53:00 <dsal> unclechu: It's basically a github repo
12:53:08 <monochrom> How to tell the difference: Ask the non-uniformity question. "Can I code up this function? if the parameter is int, add one; if the parameter is bool, negate; otherwise, identity function"
12:53:25 <monochrom> Java Generics allows you to instanceOf the hell out of it and do that.
12:53:28 <unclechu> dsal: do you mean a snapshot is just a github repo or what?
12:53:31 <monochrom> Haskell forbids.
12:53:37 <dsal> unclechu: https://github.com/commercialhaskell/stackage-snapshots
12:53:46 <dsal> (sorry, took me a sec to find it)
12:53:57 <monochrom> OK so Platonism vs formalism.
12:54:02 <hyperisco> monochrom, makes sense, thanks
12:54:19 <monochrom> I am a formalist. The math model serves me. I am the centre.
12:54:24 <hyperisco> I'd have to study Platonism
12:54:42 <ezzieyguywuf> plato? plate?
12:54:47 <ezzieyguywuf> 🤣
12:54:54 <monochrom> I am not some imperfect symptom of the math "real plane"
12:55:26 <hyperisco> suffering from the human condition? you may have math
12:55:37 <monochrom> So it is the math model that's the analogy.
12:55:54 <ezzieyguywuf> I suppose I'm down to `addVertexData :: State Vertex`, `addEdgeData :: State Edge`, though this seems unnecessarily repetitive
12:56:07 <ezzieyguywuf> though I guess not....
12:56:14 <hyperisco> okay so Platonism is the existence of abstracts like the concept of the number 2
12:56:22 <hyperisco> reading on wikipedia and trying to remember my epistemology 101
12:56:44 <dolio> hyperisco: I'm not sure the answer you got really makes any sense. For instance, simply typed lambda calculus may be an example of your first situataion, depending on how you make what you asked precise.
12:56:54 <dolio> But it has no 'intanceOf'.
12:56:58 <ezzieyguywuf> hyperisco: isn't epistemology something that happens during birth?
12:57:02 <AWizzArd> dmj`: what about 'cabal build'?
12:57:06 <monochrom> Yes, exactly what you said about math description being the real thing, my circular DVD being an analogy of the "real circle".
12:57:25 <AWizzArd> I don’t want to run `nix-build`, as it builds everything from scratch, very slowly.
12:57:31 <hyperisco> monochrom, I was more thinking in terms of which description is authoritative, rather than talking about existence
12:57:42 <dmj`> AWizzArd: nix-shell --run 'cabal build'
12:57:52 <AWizzArd> dmj`: exactly.
12:57:59 <AWizzArd> So is that the only command you run?
12:58:29 <hyperisco> monochrom, authoritative in a human sense, not a cosmic one :)
12:58:37 <monochrom> In that case the two-person game story is on equal footing with the natural deduction story.
12:59:16 <hyperisco> okay too many weeds
12:59:30 <monochrom> But one of them has the advantage of being more relatable to programmers.
13:00:52 <unclechu> dsal: thanks but i can't find here `base` pick here https://github.com/commercialhaskell/stackage-snapshots/blob/master/lts/14/27.yaml
13:01:03 <unclechu> is there a reason for this?
13:03:57 <dsal> unclechu: I'm not exactly sure how it works.  Something has to put the other pieces together.
13:04:00 <hyperisco> dolio, maybe it suffices to say ad-hoc polymorphism is an example of the first system
13:04:19 <dolio> Simply typed lambda calculus doesn't have polymorphism at all.
13:04:44 <hyperisco> so it is a different example, or are you rejecting ad hoc polymorphism as an example of the first system?
13:05:11 <monochrom> Perhaps having a type variable in the object language is important.
13:05:33 <hyperisco> alright lets ask this another way
13:05:41 <unclechu> `git grep ' base-[0-9]'` gives nothing for the whole *stackage-snapshots* repo
13:06:00 <dolio> Well, I also don't think the ad-hocness really has anything to do with quantified types being first class.
13:06:02 <hyperisco> in the first system it seems types do not have variables, so rather it is a meta-variable
13:06:12 <hyperisco> whereas in the second system it seems types clearly do have variables
13:06:50 <hyperisco> is there a name for that distinction? I suppose you could say the first is an algebra and the second is a calculus, though that seems a bit vague
13:07:46 <dolio> I don't think there's a proper name, but you can talk about whether variables are meta or object (or whatever names you choose for that distinction).
13:08:17 <dolio> However, you can also have object variables without quantifiers, for instance.
13:08:19 * hackage data-fix 0.3.0 - Fixpoint data types  https://hackage.haskell.org/package/data-fix-0.3.0 (AntonKholomiov)
13:09:10 <monochrom> When the object language doesn't have type variables, I think we say "not polymorphic at all". :)
13:09:14 <dolio> Hindley-Milner has schematic types that contain variables which are not meta variables, but a type schema is not itself a type.
13:09:27 <hyperisco> I feel like there is something to be said about a system that has no variables versus a system that has variables that can be instantiated with itself
13:11:15 <AWizzArd> dmj`: out of all available cabal commands: which of them do you run inside a nix shell?  Is it only cabal build?
13:11:23 <hyperisco> when does a separate theory and meta-theory no longer suffice?
13:11:59 <hyperisco> in other words, the theory has no variables, the meta-theory does have variables… when is a unified theory with variables required?
13:13:13 <dolio> If the theory has no variables, but you are always using variables when talking about it, you are arguably not really using the theory.
13:14:17 <monochrom> Right, not using, instead studying.
13:14:37 <hyperisco> okay, makes sense
13:15:20 <monochrom> But studying is more fun than using. Just look at number theory. :)
13:17:22 <dolio> I think it would be fair to say that almost no one ever really uses simple typd lambda calculus, they just make meta theoretic arguments about things that could be done.
13:17:51 <dolio> Because the theory itself is like C, there you have to write a different identity function for each type if you want it.
13:18:32 <hyperisco> C has variables, but anyways an example of what I am saying is there is C and there is the C preprocessor. The C preprocessor's theory of C is a string.
13:18:40 <dolio> C doesn't have type variables.
13:18:42 <ezzieyguywuf> slack1256[m]: thanks for posting that.
13:19:15 <hyperisco> The C preprocessor has string variables (macros)
13:20:01 <hyperisco> you might want to talk about a unified theory of C and the C preprocessor (which, granted, sounds horrific)
13:20:38 <ja> slack1256[m]: i saw you are not in #haskell.es and you don't have +w. are there any spanish language freenode channels you can recommend?
13:20:53 <dolio> I might want to end this conversation.
13:21:20 <hyperisco> are you imagining github repos popping up with this in mind? :P
13:26:38 <unclechu> dsal: i think i realized why “base” package isn’t shown in a packages list of a stackage snapshot. it’s because “base” packages comes with specific ghc version, ghc provides it
13:27:41 <dsal> unclechu: Sure, but it'd be nice to have that specified in data somewhere.
13:29:09 <unclechu> dsal: i’m trying to find such a list
13:29:28 <unclechu> dsal: and i think i found it: https://wiki.haskell.org/Base_package
13:31:49 <ja> unclechu: it was missing 8.10/4.14, i added it
13:32:45 <unclechu> it's also missing 8.8.2 and 8.8.3
13:32:57 <unclechu> so this list is incomplete at all
13:34:49 <ja> but according to the gitlab wiki, those use the same base version
13:35:05 <unclechu> it seems ghc repo doesn't have any git-tags of it’s versions: https://gitlab.haskell.org/ghc/ghc/-/releases
13:35:39 <ja> oh, the gitlab wiki is missing 8.8.4 too
13:36:57 <sm[m]> unclechu: viewing stackage.org is abnormally slow here too right now
13:37:26 <sm[m]> https://www.fosskers.ca/en/blog/base is another page you might want
13:38:13 <unclechu> there’s issue about this https://github.com/commercialhaskell/stackage/issues/5529
13:40:04 <maerwald> unclechu: ghcup has such a list
13:40:16 <ja> sm[m]: why doesn't that page list lts 16 in the ghc 8.8 row?
13:42:50 <Guest_75> I've just run curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh in terminal on my Mac running El Capitan but it didn't work.  The errors I get are: dyld: lazy symbol binding failed: Symbol not found: _futimens  Referenced from: /Users/Lisa/.ghcup/bin/ghcup (which was built for Mac OS X 10.13)  Expected in:
13:42:50 <Guest_75> /usr/lib/libSystem.B.dylibdyld: Symbol not found: _futimens  Referenced from: /Users/Lisa/.ghcup/bin/ghcup (which was built for Mac OS X 10.13)  Expected in: /usr/lib/libSystem.B.dylibsh: line 24: 29781 Trace/BPT trap: 5       ghcup "$@""_eghcup --cache install ghc recommended" failed! 
13:43:39 <ja> maerwald: ^ look
13:43:52 <maerwald> yes, mac :(
13:44:06 <unclechu> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history
13:45:18 <Guest_75> I've clicked on that link but I don't know how that helps, I don't understand what's on that page.
13:45:31 <maerwald> Guest_75: https://github.com/haskell/ghcup-hs/releases/tag/v0.1.8 can you try to download both binaries there and test if either of them works?
13:45:35 <ja> sm[m]: i sent colin a mail about it
13:45:56 <maerwald> 10.13 should definitely work, ghcup is built on 10.13
13:46:28 <Guest_75> What are binaries?
13:46:39 <maerwald> or wait, what's your mac version?
13:47:08 <ja> Guest_75: the two first items in the github link, with package icons , those are binaries
13:47:24 <Guest_75> El Capitan is 10.11
13:47:31 <maerwald> hmm
13:47:57 <monochrom> My students are wanting to ask me "what are binary files?" too, now that I'm giving them a unix course assignment of using C fread and fwrite on a binary (or byte) data file.
13:48:18 <Guest_75> I've got a new RPi, would it run on Raspbian?
13:48:34 <maerwald> Guest_75: what's the xcode version?
13:48:43 <maerwald> 8?
13:48:49 <sm[m]> ja: it's like any blog post, a generally unmaintained historical snapshot
13:49:27 <ja> sm[m]: but it was updated two months after posting. so now i gather he wants to maintain it forever
13:49:40 <Guest_75> I've downloaded the binaries but when I click on them, the Mac says it doesn't know how to open them, how do you run them?
13:49:46 <sm[m]> he'll try, but he won't :)
13:50:18 <sm[m]> it's a great doc, but the wiki page is more valuable because more central and collaborative and memorable
13:50:45 <sm[m]> but, thanks for that
13:51:42 <maerwald> Guest_75: make them executable
13:52:00 <ja> can it be done with finder, or only with terminal?
13:52:35 * ja has never used Mac OS X
13:53:02 <sm[m]> finder ? we're not savages, ja
13:53:19 <Guest_75> How do I find the xcode version?
13:53:39 <sm[m]> (I don't know, just kidding around :)
13:54:29 <ja> sm[m]: hahaha i thought that was what apple users used in place of WINFILE.exe :P
13:54:56 <ja> oh my, it's even open source now! https://github.com/Microsoft/winfile
13:55:03 <maerwald> blergh
13:57:54 <maerwald> wonder how stack deals with this, they also have only one mac binary no?
13:59:19 <maerwald> cabal doesn't run on El Capitan either: https://travis-ci.org/github/haskell/ghcup-hs/jobs/710890978#L1096
13:59:50 <maerwald> Referenced from: /Users/travis/.ghcup/bin/cabal (which was built for Mac OS X 10.13)
13:59:57 <maerwald> gg
14:01:57 <ja> oh no, she left
14:02:06 <ja> i wanted to talk about virtual machines
14:02:30 <hseg> wtf? upgraded cabal and am getting -Wunused-packages errors re components of my project not needing the entire project?
14:02:31 <maerwald> maybe this is a stupid question, but... mac users cannot just upgrade?
14:02:58 <hseg> http://ix.io/28LW
14:03:31 <maerwald> hseg: disable -Werror
14:03:57 <maerwald> and read https://flameeyes.blog/2009/02/25/future-proof-your-code-dont-use-werror/
14:04:02 <maerwald> :p
14:04:48 <ja> maerwald: maybe she ran out of disk space or something? or work machine? i think my ex-girlfriends mac didn't bug her after she said no initiallly, being afraid it would get slower. the upgrade took a half a day. many reasons to be scared to upgrade, i think
14:05:31 <hseg> sure, but why is it complaining about -Wunused-packages ?
14:07:27 <hseg> maerwald: also, am using -Werror in development, not production
14:08:15 <dmj`> AWizzArd: all of them except install
14:11:51 <monochrom> w00t 8.8.4 recommended now :)
14:12:16 <monochrom> What's new in 0.1.8?
14:13:19 <maerwald> monochrom: a bugfix and you can now install arbitrary bindists (from custom locations)
14:13:55 <monochrom> haha but I have to write a bloody json string
14:14:01 <maerwald> yes
14:14:24 <ja> maybe a dhall schema exists for the json ;)
14:14:35 <monochrom> it's OK, doesn't affect me
14:15:24 <maerwald> ja: I tried that first in fact, but gave up bc it doesn't have maps
14:15:34 <maerwald> was too complicated for my taste
14:16:06 <ja> oh, surprised to hear that! usually gabriels stuff is simpler than the comparison
14:16:18 <maerwald> https://github.com/dhall-lang/dhall-lang/issues/234
14:17:38 <maerwald> https://stackoverflow.com/a/55995787
14:17:40 <maerwald> meh
14:19:50 <ja> yeah i wouldn't have come up with that :O
14:21:22 <ja> but you did see that the toMap issue was closed?
14:21:35 <maerwald> just now :p
14:21:52 <monochrom> Is it closed as "wontfix"? :)
14:29:22 <frdg> is it normal to pass IO as an argument to a function?
14:29:38 <glguy> Sure, sometimes that's what you mean to do
14:29:49 <maerwald> https://github.com/dhall-lang/dhall-lang/pull/575
14:30:19 <frdg> glguy: ok I had never come across a situation where it made sense before
14:30:34 <monochrom> @sequenceA
14:30:34 <lambdabot>  Sequence not found.
14:30:37 <monochrom> err
14:30:39 <monochrom> @type sequenceA
14:30:41 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:30:59 <monochrom> That one even takes a whole list of IO's. (Let t=[], f=IO.)
14:31:30 <monochrom> @type bracket
14:31:31 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:31:41 <monochrom> That one takes quite a few.
14:32:08 <frdg> alright I guess I'm gonna try to make it work
14:32:50 <hpc> frdg: every time you do one IO action after another, you're doing exactly that
14:32:50 <maerwald> frdg: you're reading a file line by line and want to do something on every line... you can writh somthing like: perLine :: FilePath -> (String -> IO b) -> IO [b]
14:32:52 <hpc> :t (>>=)
14:32:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:33:42 <mniip> perLine ~ mapM ~ sequenceA
14:33:46 <mniip> it's all one example :)
14:33:47 <frdg> hpc: I had never considered that
14:34:01 <hpc> there's also forkIO, and the exception handling functions
14:34:06 <hpc> it's pretty much everywhere
14:34:26 <AWizzArd> dmj`: k
14:36:18 <hpc> frdg: now if you really want to have fun, store IO actions in a data structure
14:36:49 <hpc> Map String [IO ()] might be how you keep track of event handlers in a framework
14:37:09 <hpc> or Chan (IO a) for passing stuff off to other threads
14:37:10 <frdg> that is where traverse may come in right?
14:37:19 <hpc> it might
14:37:44 <monochrom> traverse is mapM
14:37:54 <monochrom> and closely related to sequenceA
14:42:43 <mniip> I've used IO (IO a) at times and I could see a reason to use something like Free IO
14:43:59 <monochrom> Free IO is very difficult to think about.
14:44:33 <mniip> if you have some sort of message passing system then you could have `send :: Request -> IO (IO Response)`
14:44:50 <mniip> do { receive <- send req; ... ; resp <- receive }
14:45:42 <mniip> yeah on a second thought Free IO is probably useless because you can't really specify which level of the action does that
14:45:44 <mniip> does what*
14:46:09 <mniip> and if you only ever intend to use the counit of the adjunction then just IO would do
14:46:29 <monochrom> I do have IO (IO X) and more generally IO (record type full of IO X's)
14:46:36 <mniip> mhmm
14:46:43 <mniip> sometimes you do need recursion though
14:46:56 <mniip> but that's probably best done with custom recursive datatypes
14:47:36 <monochrom> I am also fond of STM (IO X), and once it atomically it, it's IO (IO X).
14:47:53 <monochrom> s/once it/once you/
14:49:24 <monochrom> data ListTIO a = ... | Node a (IO (ListTIO a)) would be one of those recursive cases.
14:50:38 <dmj`> IO for Free? sounds like a paper
14:51:25 <monochrom> That would be Free (Λr. (a, IO r))
14:51:50 <monochrom> Err, no, the "..." is Nil, not "Pure a".
14:57:39 <maerwald> I use: FilePath -> IO (SerialT IO (Array Word8)) -- acquiring the resource is in the outer IO. Resource closing is a GC hook
14:58:42 <maerwald> linear types to the rescue... maybe
15:22:12 <dmj`> or everyone just ditches haskell for rust
15:23:23 <monochrom> I won't.
15:26:41 <dolio> Maybe people will figure out that it's okay to use more than one programming language when appropriate.
15:27:31 <monochrom> People don't want to because the FFI bridging is extra work.
15:27:53 <monochrom> And worse, extra learning of alien concepts.
15:28:26 <monochrom> And worse squared, the process of learning that exposes how much they have been lying to themselves about low level things.
15:29:52 <dolio> They don't even need to use them on a single project, just figure out that they can use Rust for some projects and Haskell for others if necessary, not just only use one ever.
15:30:15 <hpc> or someday, maybe FFI between haskell and rust
15:30:19 <monochrom> Ah, then yes.
15:30:29 <hpc> (with types inferred!)
15:31:08 <monochrom> People really religionize programming languages.
15:35:16 <fresheyeball> I just learned my app has a runtime dependency on GHC
15:35:23 <fresheyeball> why would that be?
15:35:26 <fresheyeball> how can I fix that?
15:36:04 <dsal> Write it in tcl.
15:36:53 <monochrom> Did you use the GHC API? Directly? Indirectly via libraries that use the GHC API?
15:37:31 <dsal> i.e., would need to know more about your app.
15:37:49 <fresheyeball> monochrom: I see no reason it should have a runtime dep on GHC
15:38:04 <monochrom> And yet, it does.
15:38:13 <fresheyeball> I think I need to figure out static linking. This is going into a docker container, and GHC is huge
15:38:13 <monochrom> It's your judgment against the computer's judgment now.
15:39:03 <monochrom> GHC and cabal-install already does static linking by default for Haskell code. You would have to go out of your way to override, and you would know if you did.
15:39:33 <monochrom> Then again maybe you're on archlinux.
15:41:28 * sm[m] wonders what fresheyeball means by a runtime dependency
15:43:17 <fresheyeball> I mean something that is linked with the output from GHC
15:43:17 <ski> slack1256[m] : no need to appeal to general recursion for `(forall a. a) -> b'
15:47:25 <maerwald> fresheyeball: what does it link against
15:47:56 <maerwald> are you on arch linux?
15:47:58 <sm[m]> fresheyeball: excuse me but I still don't understand, do you mean you're seeing something unexpected in "ldd myapp" ?
15:48:15 <fresheyeball> I am using nix on nixos
15:48:26 <fresheyeball> and I can see without ldd that it's linked together
15:48:43 <fresheyeball> I am trying with --ghc-option=optl=-static
15:48:49 <fresheyeball> but it causes linking to fail
15:49:02 <fresheyeball> relocation R_X86_64_32 against hidden symbol `__TMC_END__' can not be used when making a shared object
15:49:19 <maerwald> nixos, gl :)
15:49:31 * sm[m] steps back carefully 
15:50:08 <maerwald> self-inflicted pain :p
15:50:33 <justsomeguy> What you call self-inflicted pain I call "full immersion learning". :)
15:50:59 <monochrom> It is not learning if you don't change your mind.
15:51:05 <maerwald> interesting semantics don't justify non-exisent erognomics
15:51:13 <monochrom> if you don't discard your old beliefs
15:51:57 <justsomeguy> fresheyeball: https://github.com/nh2/static-haskell-nix
15:52:00 <fresheyeball> maerwald: without nix I wouldn't even know there was a problem
15:52:11 <fresheyeball> justsomeguy: I just saw, that. Trying those options now
15:52:19 <sm[m]> and that would be.. bad ?
15:52:37 <maerwald> justsomeguy: I tried that too, it didn't work ;)
15:52:50 <fresheyeball> same error
15:52:51 <monochrom> I think their "pain" refers to nixos not nix.
15:53:17 <monochrom> I know people who use nix on macos and their pain is yet less.
15:53:34 <monochrom> some of them are right here
15:53:47 <fresheyeball> well this is not a nix problem
15:54:13 <maerwald> monochrom: nixpgks is part of NixOS... you're using NixOS regardless of whether you installed it as a desktop system
15:54:34 <monochrom> Ah
15:54:39 <maerwald> if you install gentoo in a chroot... it's still gentoo
15:56:28 <sm[m]> fresheyeball: you could try #ghc too. But it's a quiet time.
15:58:42 <nh2> Equating NixOS and nixpkgs is a strong oversimplification. The nixpkgs parts that you can use on other Linux distros / OSX, and the NixOS parts that make NixOS what it is (system services, app settings, bootloader-level rollback) are quite distinct.
15:59:26 <maerwald> nh2: you can also install gentoo packages on non-gentoo distros
15:59:38 <maerwald> those are still gentoo packages :)
15:59:55 <nh2> fresheyeball: You haven't told us the details yet though. What *exactly* do you see a link against, do you see it in ldd, or only in the closure of the nix store path (e.g. with nix-store -qR)?
16:00:20 <fresheyeball> nh2: I see GHC with whydepends
16:00:28 <fresheyeball> sorry
16:00:37 <fresheyeball> I see GHC with nix-store -qR
16:01:53 <dsal> What is whydepends ?
16:02:05 <dmj`> dsal: it shows you why a derivation depends on another derivation
16:02:12 <dsal> Ah.
16:02:15 <dmj`> I love how #haskell has turned into #nix
16:02:22 <dmj`> my work here is done
16:03:16 <nh2> fresheyeball: Check if you have any GHC stuff directly in the ldd output. If not, then the chances are highest that some library you use pulls in GHC via some functionality (e.g. cabal-defined data files and similar), and those transitive dependencies are checked by essential "grep" for store paths, and your binary may work perfectly fine without the GHC store paths. In that case, it is a nix-specific problem.
16:03:46 <Axman6> I'm not convinced that nix isn't an elaborate nerd snipe made by the FSB to distract intelligent people from voting in elections
16:04:54 <justsomeguy> You sound frustrated.
16:05:14 <monochrom> What is FSB?
16:05:31 <nh2> fresheyeball: As a concrete example, if some library encodes something some `--version` style output like "I'm library foo and was built by /path/to/ghc/.../bin/ghc", and that path is a nix store path, then nix will add the dependency as nix-store dependency.
16:06:08 <dmj`> Axman6: Nix is a CIA psyop
16:06:31 <aldum> Axman6: >implying voting makes a difference
16:06:37 <dmj`> to subvert Haskell programmers into pure builds
16:06:43 <aldum> monochrom: formerly known as KGB
16:07:43 <monochrom> The best of both worlds: nix is a FSB-CIA joint project. \∩/
16:07:58 <dmj`> well, it would be CIA-Mossad, since those two are one in the same these days
16:08:05 <nh2> fresheyeball: This of course isn't desirable, and it's usually a bug / unintended behaviour in the upstream software, but nix will definitely make you aware of it, and if fits squarely into the type of "closure size problem" that nixpkgs regularly investigates (and people will appreciate if you file an issue for what you found).
16:08:57 <jvsg> hi! I'm having a bit difficulty in finding out whether I can build ghc on ubuntu or not. It requires me to have ghc>=8.8 but the universe repository has 8.2 as the latest
16:09:28 <jvsg> I guess debian packages it is then?
16:09:57 <aldum> or: ditch the repos and use ghcup
16:10:38 <nh2> fresheyeball: for example, `pandoc` regularly accidentally pulls GHC into its closure, you can find a recent related fix here: https://github.com/NixOS/nixpkgs/pull/86194/files. The added comment explains both the reason (in this case, the Cabal `Paths_` module), and the solution (the `remove-references-to` script).
16:10:57 <monochrom> Do you really need to build ghc, or is it just a false dichotomy of "either ubuntu repo or build from source"?
16:11:02 <jle`> solonarv: i found a counter-example
16:11:08 <jle`> are you ready for it :)
16:11:34 <nh2> fresheyeball: So, most likely you will not need to build statically to solve this problem, and a `remove-references-to` may do it.
16:11:35 <sm[m]> fresheyeball, you lucked out
16:11:47 <jvsg> I actually did need to build from source
16:11:51 <monochrom> And yes ghcup will do fine in terms of "what if I want to uninstall one day".
16:12:19 <jvsg> I'll try that
16:12:35 <dsal> jvsg: or stack.  Using system stuff from debians is always sad.
16:13:09 <monochrom> ubuntu's ghc is this old precisely because it tracks debian's ghc
16:13:22 <Axman6> monochrom: I could believe the FSB-CIA joint project
16:13:27 <aldum> it's also sad on Arch :c
16:13:41 <dsal> I've never heard anything happy about arch.
16:13:44 <monochrom> Only ghcup is not sad now.
16:13:56 <monochrom> Even chocolatey is sad.
16:14:37 <davean> Theres also an ubuntu PPA for GHC
16:14:44 <davean> that includes HEAD and such
16:14:45 <dsal> I like nix, but it was building ghc for me on mac.
16:14:51 <maerwald> https://launchpad.net/~hvr/+archive/ubuntu/ghc
16:14:56 <dsal> for some version.  I have too many projects.
16:15:10 <monochrom> But different reason. Mainly on count of: 1. "Step 1, sign up our mailing list", 2. some people don't want to touch powershell.
16:18:36 <AWizzArd> Is there a way to see what exact versions nix presents to cabal? Inside a nix shell maybe?
16:18:54 <AWizzArd> (versions of dependencies)
16:19:15 <nh2> AWizzArd: of Haskell packages? If you're in the nix-shell build environment of the package, just `ghc-pkg --list`
16:20:08 <manta97> Hi guys, quick question, how long do you think it would take me, a 2nd (going into 3rd) year CS student who took Haskell in 2nd year to implement a markdown to HTML compiler?
16:20:09 <AWizzArd> nh2: okay it works, only that it displays the wrong versions.
16:20:23 <manta97> I'm not looking for an exact number, just whether it's hours, days or weeks etc
16:20:48 <Axman6> manta97: about 5 minutes, just install pandoc :)
16:20:50 <nh2> AWizzArd: wrong like "not what you desire", or like "you know that that's not what your build sees"?
16:21:20 <manta97> Axman6 My final year project supervisor has suggested it as a possible project 
16:21:47 <manta97> Which is worth 40 credits, i.e. 33% of the final year grade i.e. 25% of the entire degree mark
16:22:22 <Axman6> markdown is notoriously complicated - it looks simeple but actually getting it right is quite tough. you could get something quite markdown like quite easily
16:22:49 <nh2> manta97: how much did your course teach, did it cover Monads, parsers and IO?
16:23:03 <manta97> Yeah towards the end
16:23:30 <manta97> nh2 It's been two years since I took the course, I've recently gone through the latter section of learnyouahaskell to refresh though
16:24:00 <AWizzArd> nh2: inside the nix shell I see a wrong version listed. Outside the shell, doing nix-build it seems to not complain about that. It seems as if nix-build sees other versions than the nix-shell.
16:24:09 <manta97> Axman6 "you could get something quite markdown like quite easily" what do you mean by this?
16:24:16 <nh2> manta97: do you have the freedom to choose how much of Markdown you want to be able to implement (e.g. what flavour, whether it's OK to error out in certain situations, and so on)?
16:24:42 <manta97> nh2 I think I've got quite a lot of freedom yeah
16:24:59 <dsal> markdown is a bit underspecified as well.
16:25:06 <manta97> nh2 so to clarify, it's not too limited in scope/would require enough work to be project-worthy?
16:25:09 <dsal> It's like, a superset of HTML.
16:25:19 <Axman6> Like I said, Markdown is _very_ compllicated (https://spec.commonmark.org/0.29/) but you could probably implement something that does a subset of markdown pretty easily
16:25:41 <manta97> Axman6 okay thank you for clarifying
16:26:04 <nh2> manta97: Markdown does not have an official specification, it's originally "defined by example" and whatever people's implementations of it produced, only more recently did people actually make specs for it (like the mentioned CommonMark), that's where "something quite markdown like" comes from
16:27:07 <Axman6> commonmark is the best effort in fully specifying markdown, and IIRC it's hundreds of pages long. 
16:27:12 <nh2> AWizzArd: do `ghc-pkg list` as part of your nix-build (e.g. in `preConfigure`) and check whether it shows different ghc-pkg database paths than appear in the equivalent in `nix-shell`, that may give a hint
16:27:20 <dsal> Parsing something that's a bit more designed would be easier.
16:27:21 <AWizzArd> What could be the reason that nix-build can successfuly build a project, but inside a nix shell "cabal build" wouldn’t work?
16:27:42 <justsomeguy> restructuredText is similar to markdown, but has a specification. It's kind of a big markup language, though. I'm not sure whether it's simpler to implement or not.
16:28:21 <Axman6> a yaml -> HTML or JSON -> HTML project could be fun.
16:28:46 <AWizzArd> nh2: will try that preConfigure thing, thanks
16:28:49 <Axman6> particularly if you don't use any existing libraries for either format
16:28:52 <nh2> manta97: so, if the project acceptance criteria are "successfully parse/convert common things people use in Markdown, like bold, italic, lists, code blocks, etc", then it's definitely doable as such a project; if it is "Implement specification-correct CommonMark", then it is likely not.
16:30:47 <manta97> nh2 I've had friends achieve high marks for projects that didn't achieve what they set out to, I think a lot of the marks are for demonstrating how you'd approach the task rather, as well as the actual final result
16:31:49 <manta97> I've got a zoom call with my supervisor tomorrow to discuss but you guys have been very helpful
16:32:20 <nh2> manta97: that sounds fine then, if you want to show "look, I can teach myself to do parsing and data transformation in Haskell, and I'm using a structured and disciplined approach, and I use some parts of Markdown as my examle", then it should be OK. Just be sure to agree with him on that and write it into the project description.
16:32:52 <dmj`> dsal: it should be cached, were you using nixpkgs-unstable?
16:32:57 <nh2> manta97: In terms of what you need to know, if you find learnyouahaskell easy, read the parsing chapter of Real World Haskell: http://book.realworldhaskell.org/read/using-parsec.html. If you're happy with that, you can definitely take on the task, and finish it within a month or so of normal "university final year project time".
16:33:20 <dsal> dmj`: Maybe.  It was an 8.8.x on macos.
16:33:25 <sm[m]> manta97: this project would have the advantage (?) of a lot of existing code that does just this. But maybe you'd rather do something else ?
16:33:39 <nh2> manta97: the RWH details are outdated, and today you would probably want to use different libraries (e.g. megaparsec), but the general approach of parser combinators remains the same.
16:33:40 <dsal> (it used an existing package on nixos)
16:34:09 <manta97> if I could finish it in a month then I would probably try to build my own note taking app using my compiler
16:34:35 <manta97> something to make taking notes on lecture slides easier with a keyboard, I use OneNote right now but it's not great
16:35:46 <nh2> manta97: what sm[m] says is a good point, including the question mark: For some final year projects it's required/desirable that they do something novel or at least something that wasn't done this way. If you implement Markdown->HTML in Haskell, and that was already done many times, including in a a state-of-the-art library (pandoc), ...
16:36:02 <nh2> manta97: ... people may claim that it's an "easy task" and that you could just look at what those projects do and copy it, and thus you may get less marks for it not being ambitious.
16:36:45 <manta97> nh2 yeah that is one of my concerns
16:36:52 <dmj`> AWizzArd: when you call nix-build nix copies everything that passes the source filter into a temp directory (/tmp on nixos) and executes a large bash script to build your project. When you call nix-shell --run 'cabal build' it doesn't apply the source filter and you might need to cabal clean as well, since dist might have old object files, or your configuration might be incorrect
16:37:04 <sm[m]> right. And personally I would find it demotivating knowing that pandoc is out there.
16:37:40 <manta97> I'll check with my supervisor, personally I have no problems with doing something that's been done before as long as I can still get credit
16:37:54 <sm[m]> ie there's no chance my code will be used by anyone
16:38:32 <manta97> sm[m] that's fine by me for the purposes of getting my degree haha
16:38:34 <nh2> manta97: but again, that depends on what the goals are and what types of projects are common for your uni program. In the uni I went to (I also did multiple longer Haskell projects as part of it, including my final year project), the general rule was that if it's a Bachelor's project, it's about "I can build practical stuff"
16:38:36 <nh2> manta97: and if it's a Master's project, it's about "I can build researchy stuff that hasn't really been done this way".
16:38:42 <AWizzArd> dmj`: I just tried `cabal clean` followed by a `cabal build`. It says that   cabal: Encountered missing dependencies: HaskellNet-SSL -any
16:38:55 <sm[m]> but then again "my supervisor suggested it" :)
16:39:28 <manta97> my backup project is a drag and drop propositional logic proof tree builder
16:39:52 <AWizzArd> dmj`: at the same time I see that ghc-pkg list shows me HaskellNet-SSL-0.5.2 (which is wrong, because I pinned nixpkgs 19.03, an older version, on purpose, which contains an older version of that lib)
16:39:52 <manta97> I've started on it, in Java, but I just find Java more tedious than FP
16:40:07 <dmj`> AWizzArd: try nix-shell --pure
16:40:14 <dmj`> AWizzArd: your old PATH is being used and its polluting the build
16:40:15 <AWizzArd> dmj`: I did.
16:40:25 <dmj`> AWizzArd: well then delete all other GHC installations
16:40:31 <dmj`> cabal clean
16:40:56 <dmj`> AWizzArd: there is no way nix-build works then either
16:41:14 <dmj`> AWizzArd: nix-shell will use the same ghc-pkg list that nix-build does
16:41:19 <AWizzArd> Okay, will try and find some old cabal stuff which might be stored globally somewhere in my home.
16:41:25 <dmj`> AWizzArd: assuming you're not doing anything fancy with .env
16:41:39 <dmj`> AWizzArd: nix-shell --run 'ghc-pkg list' does that show multiple ?
16:42:01 <nh2> manta97: That also sounds good. You could build that in Haskell. Less parsing, more GUI building, and you can implement the checking of the logic or something nice like automatic generation of some parts of the tree, or a solver.
16:42:46 <nh2> manta97: you could choose to learn the Haskell GTK bindings, or implement it in something simpler like `gloss`, see e.g. https://stackoverflow.com/questions/15867671/getting-mouse-coordinates-in-glosshaskell
16:43:08 <manta97> I lost motivation trying to implement the GUI in JavaFX
16:43:34 <manta97> I was representing the trees using a mess of VBoxes and HBoxes and it turned me off GUI programming a bit
16:44:11 <nh2> manta97: in any case, pick something that you also have enthusiasm for, because that makes it much easier to put time into your project and thus get a good result
16:44:27 <sm[m]> 1000 times this
16:44:34 <manta97> nh2 I'm quite enthusiastic about the compiler to be honest
16:44:50 <AWizzArd> dmj`: not doing anything with .env
16:44:55 <manta97> I was baffled by parsing when we first covered it but it looked really interesting
16:45:06 <dmj`> AWizzArd: do you have a shell.nix ?
16:45:29 <AWizzArd> dmj`: yes
16:45:30 <manta97> I was thinking I could make use of the curry-howard correspondence in my proof tree builder but I think I was barking up the wrong (proof) tree
16:45:37 <dmj`> AWizzArd: what does it look like
16:46:05 <AWizzArd> dmj`: the shell.nix file is:    (import ./release.nix).releaseEnv.env
16:46:23 <dmj`> AWizzArd: ok that might be right
16:46:28 <AWizzArd> releaseEnv being a name that I provided, in a fiel that I called release.nix
16:47:05 <AWizzArd> dmj`: and I call the shell via:    nix-shell --pure -A releaseEnv release.nix
16:47:25 <dmj`> AWizzArd: you shouldn't have to do that, nix-shell should be enough
16:47:31 <dmj`> nix-shell release.nix
16:48:35 <AWizzArd> dmj`: stil doesn’t work. Also it *should* work with the pure call as well.
16:48:59 <dmj`> AWizzArd: can you paste the output of `nix-shell release.nix --run 'ghc-pkg list'`
16:49:21 <nh2> manta97: Then it sounds good with the parser. Ask your supervisor specifically about whether the project might be perceived as too easy given that such parsers exist and are implemented in Haskell, and whether it can be addressed with stretch goals or by some other means
16:49:23 <nh2> manta97: (for example, you could make your project to write a _tutorial_ that teaches others how to write such a thing in Haskell step-by-step, which would automatically make clear that you understand every step of it and did not just copy an existing solution).
16:49:49 <manta97> nh2 that's an interesting idea
16:50:28 <manta97> before I go to bed
16:50:43 <koz_> Is there a way I can convert a UTCTime into the number of _milli_seconds since the unix epoch?
16:50:45 <manta97> What's a good setup for developing Haskell
16:50:58 <koz_> manta97: I use Neovim with ALE.
16:51:03 <manta97> I've got hie installed with VSCode but I'm not in love with it haha
16:51:03 <koz_> It works OK,
16:51:23 <koz_> (before anyone asks why - gory legacy interop)
16:51:23 <dmj`> manta97: all you really need is ghcid
16:51:35 <dmj`> manta97: everything else is just candy
16:51:35 <maerwald> haskell-language-server
16:51:41 <sm[m]> ghcid
16:51:53 <maerwald> codex
16:52:50 <AWizzArd> dmj`: yes, one sec
16:53:33 <manta97> Okay
16:53:38 <nh2> manta97: Today I would start with just a simple terminal-based build tool, e.g. getting your packages with stack and working iteratively in ghcid, and then after you get into productive routine with that, you can see what editor integration you like best and if you want any (this can be a big time sink so you should definitely decouple your project success from that).
16:53:55 <manta97> Okay
16:54:09 <nh2> manta97: sorry, I meant "working iteratively in ghci", not ghcid; you may want to look into ghcid as one such tool as the followup
16:54:57 <AWizzArd> dmj`: https://paste.ofcode.org/aMvynBuFW9xXbamXdLFdbY
16:55:53 <manta97> nh2 at uni we just used ghci, didn't ever look at stack. I've got stack and ghcidE set up now, before I go back to uni I think I'm gonna do a fresh install of macOS and set up everything from there
16:56:41 <nh2> manta97: as an example of "time sink", I at some point got so obsessed with editor integration that I became maintainer of SublimeHaskell, and put multiple months of free time into improving that. For my 5 years as Haskell consultant up til today I use something much simpler (just ghci / ghcid), and in the future I may into the haskell-language-server setup again.
16:57:22 <AWizzArd> dmj`: but I have a file  nix/pinnedNixPkgs.json  in which I list    "rev": "34c7eb7545d155cc5b6f499b23a7cb1c96ab4d59"   which is here: https://github.com/NixOS/nixpkgs/tree/34c7eb7545d155cc5b6f499b23a7cb1c96ab4d59
16:57:33 <dmj`> AWizzArd: /home/wiz/.ghc/x86_64-linux-8.6.4/package.conf.d
16:57:42 <dmj`> rm -rf ~/.ghc
17:00:48 <AWizzArd> dmj`: this changed the error message to    cabal: Encountered missing dependencies: HaskellNet-SSL -any, mime-mail -any
17:01:05 <AWizzArd> So there were really some bad remains.
17:01:19 <AWizzArd> But both of those are specified in my .cabal file.
17:01:41 <dmj`> AWizzArd: are you using callCabal2nix or did you generate the derivation with cabal2nix
17:01:58 <AWizzArd> dmj`: in the pinned nixpkgs I navigate to   https://raw.githubusercontent.com/NixOS/nixpkgs/34c7eb7545d155cc5b6f499b23a7cb1c96ab4d59/pkgs/development/haskell-modules/hackage-packages.nix     and search for "HaskellNet-SSL"
17:02:02 <dmj`> AWizzArd: can you paste all your nix
17:02:12 <AWizzArd> dmj`: yeah okay, will paste all files
17:02:19 <nh2> koz_: I believe I once made a pull request to `time` that addresses this very topic, see https://github.com/haskell/time/issues/106
17:02:20 <dmj`> AWizzArd: or if there is a repo
17:02:54 <koz_> nh2: Awesome, thank you!
17:02:55 <dmj`> AWizzArd: you'll find all the functions in pkgs.haskell.lib very useful
17:03:14 <nh2> koz_: so it should be in the main `time` haddocks how to do that
17:07:11 <nh2> AWizzArd dmj`: In case it is useful, in my project I make `nix-shell`load my Nix Haskell package's `.env` attribute, e.g. I do something like `if pkgs.lib.inNixShell then haskellPackages.mypackage.env else haskellPackages.mypackage`. I don't know if that is still necessary, this project was started a while ago.
17:07:47 <AWizzArd> dmj`: No repo yet (just learning nix), but I think I’ve pasted all required files here:  https://paste.ofcode.org/6p6maQNsibFvDAtLNNvCHu
17:09:41 <AWizzArd> dmj`: btw fun fact: I had to fight hours to get curl into my --pure nix shell. There is a Haskell package named "curl" and it was using that one all the time. Until I imported pkgs and used curl from there.
17:10:16 <dmj`> AWizzArd: hah, yea a lot of name shadowing between haskellPackages and top level pkgs
17:10:57 <dmj`> nh2: that sounds very useful for combining default.nix and shell.nix into one file
17:11:48 <dmj`> AWizzArd: there's nothing immediately obvious to me that anything is wrong. If you call nix-build what happens
17:18:03 <AWizzArd> dmj`: this is the nix-build output:   https://paste.ofcode.org/EzVUwFgiW8phPAhiDRH2st
17:18:16 <AWizzArd> There it totally selects the right versions.
17:21:12 <dmj`> nix-shell -A releaseEnv.env release.nix --run 'cabal clean && cabal build'
17:22:17 <AWizzArd> dmj`: that did indeed work.
17:22:32 <dmj`> AWizzArd: maybe it was just some dist/ residue
17:22:52 <AWizzArd> dmj`: even with --pure it works.
17:23:05 <dmj`> AWizzArd: did you remove ~/.ghc ?
17:23:29 <AWizzArd> dmj`: I removed it.
17:23:31 <dmj`> AWizzArd: does nix-shell --run 'cabal clean && cabal build' work as well?
17:23:51 <AWizzArd> dmj`: But dayum, when I "go into" the nix shell and run    cabal clean && cabal build  it won’t work!
17:24:16 <dmj`> AWizzArd: nix-shell needs to target .env
17:24:25 <dmj`> if it doesn't do that, you won't get a ghc-pkg list in the shell
17:24:34 <dmj`> and you'll forever wonder why
17:24:58 <dmj`> AWizzArd: what is the error?
17:25:35 <AWizzArd> dmj`: also    nix-shell --run 'cabal clean && cabal build'    works
17:26:07 <dmj`> AWizzArd: then that is identical to going into the nix-shell and calling cabal build
17:26:15 <dmj`> AWizzArd: it was just an issue where you needed to clean I think
17:27:42 <AWizzArd> dmj`: inside the nix shell it will give that error from above, about packages not being found.
17:28:21 <dmj`> AWizzArd: if nix-shell --run 'cabal clean && cabal build' works, then it shouldn't give an error about that package not being found
17:29:00 <dmj`> AWizzArd: can you paste all of that, including the command you're invoking to produce the error
17:30:42 <AWizzArd> dmj`: now i see the difference between what you wrote and what I do all the time.
17:31:02 <dmj`> I'm on the edge of my seat
17:31:07 <dmj`> what was it
17:31:16 <dmj`> it was the .env wasn't it
17:31:34 <AWizzArd> it was the .env!
17:31:48 <dmj`> Ah-hah !
17:31:55 <AWizzArd> nix-shell --pure -A releaseEnv.env release.nix
17:31:55 <dmj`> well glad we got to the bottom it
17:31:57 <AWizzArd> vs
17:31:59 <AWizzArd> nix-shell --pure -A releaseEnv release.nix     (mine, doesn’t work)
17:32:27 <dmj`> ah, yea that .env is tricky, and that is specific to haskell packages infra as well
17:32:55 <dmj`> nix-shell --pure -A releaseEnv.env release.nix --run 'ghc-pkg list' vs. nix-shell --pure -A releaseEnv release.nix --run 'ghc-pkg list'
17:33:20 <dmj`> in the first you will see a pkg list that has your deps. the second will just the pkg list ghc ships with (only the boot pkgs)
17:33:23 <AWizzArd> dmj`: thanks for helping out on this.
17:33:27 <dmj`> AWizzArd: for sure
17:33:45 <AWizzArd> dmj`: this gave me some hours of frustration
17:33:58 <dmj`> AWizzArd: nix is harder to learn than Haskell
17:34:18 <AWizzArd> dmj`: I like nix, but it certainly has some very rough edges.
17:34:20 * dminuoso idly recalls having warned AWizzArd
17:34:21 <jumper149> dmj`: But only because the documentation sucks in comparison
17:34:23 <dmj`> Haskell actually makes sense, dynamically typed languages are always opaque, hard to introspect. 
17:34:29 <AWizzArd> dminuoso: yeah!
17:34:42 <dmj`> AWizzArd: one thing that is super helpful is nix repl
17:34:55 <dmj`> AWizzArd: then you can tab your way down the package set to glory
17:35:01 <AWizzArd> dmj`: I thought that because I specified this releaseEnv in my release.nix I no longer needed the .env thing.
17:35:25 <dminuoso> AWizzArd: So right now we have this issue of "how do we ship this damn haskell binary with native libraries in a sensible manner"
17:35:29 <dmj`> AWizzArd: ah
17:35:53 <dminuoso> Every time we approached it, we came to the conclusion "if we want to do this right, we use nix. if we want less work, we toss docker at it"
17:35:58 <dmj`> AWizzArd: there is also another deep nix secret that is helpful for learning
17:36:05 <dminuoso> (Because building statically linked haskell binaries seems to be a PITA)
17:36:19 <maerwald> dminuoso: why
17:36:32 <dmj`> dminuoso: building statically linked binaries in Haskell with nix is very easy to do now
17:36:34 <AWizzArd> I got confused, and the  .env has “devolved” into releaseEnv
17:36:45 <maerwald> it's even easier with alpine
17:36:48 <AWizzArd> That must be it. I constantly saw the Env, but it was part of my made up name.
17:36:49 <dmj`> AWizzArd: it's very common error
17:37:05 <dmj`> AWizzArd: just check ghc-pkg list, and if it looks empty, you're probably missing .env
17:37:14 <AWizzArd> Finally it all makes sense.
17:38:23 <AWizzArd> My very first nix project. A nightmare. Everything that could go wrong did go wrong. Finally all has been resolved :)
17:38:46 <dminuoso> dmj`: Well, if its built with nix I wouldn't have to care. I just want to deploy an alone ELF binary to a server. Now of course I could build it in nix, patchelf it to work with a plain old ld, but then I have all the headache of nix back.
17:38:48 <dmj`> AWizzArd: great work
17:39:01 <dminuoso> I kind of wish I could just enable `--enable-static-executable` and things *just* *work*
17:39:02 <dminuoso> But they dont.
17:39:32 <dmj`> dminuoso: just install nix on the remote machine and nix-copy-closure
17:39:46 <AWizzArd> dminuoso: We also use docker, also on AWS. It’s great as a runtime container service, nice isolation and such. But I came to like the idea of creating the env itself via Nix.
17:39:47 <dminuoso> dmj`: I think I dont even need nix on the remote machine for that to work, no?
17:40:44 <dmj`> dminuoso: you'll want nix-env around to install it into the environment most likely
17:40:58 <AWizzArd> dminuoso: One of my next steps is to get this mini email lib into a docker image, but without doing much work in the dockerfile. I want to use Nix and have a simplistic dockerfile. Possibly with a "from scratch" at the beginning.
17:41:21 <dmj`> dminuoso: if you run NixOS then you should define a systemD module with nix and import the set you export from default.nix
17:42:13 <dmj`> AWizzArd: you can place haskell binaries into docker files with nix and then load them into docker
17:42:30 <dmj`> docker load < $(nix-build -A myDockerImage)
17:42:36 <dminuoso> dmj`: My main concern with nix is that it introduces many additional moving parts. One early show stopper was my frequent annoyance by packages with broken tests. Having to constantly fix-up those packages was annoying, because it felt like you need to be a nix wizzard to accomplish basics tasks.
17:43:15 <dminuoso> And nix is too exotic for my taste that I intuitively understand nix overlays - maybe that would change if I use nix very heavily, but I dont want to.
17:43:28 <dminuoso> replace nix with nixos in all the necessary spots.
17:43:39 <ezzieyguywuf> I see that Data.Map has query methods `lookup` and `(!)`, the first return `Maybe a` and the latter `a`. Per the documentation, `(!)` will call `error` if the key does not exist. This makes sense of course. My question: is this a typical design approach, e.g. to provide a 'proper' lookup function with a Maybe answer, but to also present a version that may error-out at runtime?
17:44:01 <dmj`> dminuoso: you really only need to fix them once, after that, it will always work due to pinning
17:44:04 <ezzieyguywuf> the `(!)` seems to be paired with `member`, so that the combo can be used in place of `Maybe` should the user decide
17:44:08 <AWizzArd> dmj`: that’s what I’m going to do in the next phase. Getting the basic lib to compile is essentially done. But next thing is I wanna make the haskell language server available in this env, so I can start emacs from within the shell, so that emacs knows the LS.
17:44:14 <solonarv> ezzieyguywuf: it sure seems to be pretty common
17:44:17 <dminuoso> dmj`: Sure, but that incurs additional maintenance work every time you want to bump bounds.
17:44:26 <dmj`> ezzieyguywuf: checkout "lookup"
17:44:43 <dminuoso> ezzieyguywuf: typical is hard to say, it depends a bit on the authors.
17:44:45 <solonarv> but you should approximately never use 'member' followed by '(!)' on the same key - just use 'lookup' and pattern match!
17:45:11 <dmj`> dminuoso: depends how often you need to upgrade
17:45:18 <ezzieyguywuf> I guess I'm just wondering if it's somehow "wrong" to provide `(!)` at all
17:45:35 <dmj`> dminuoso: I just doJailbreak and things are fine
17:45:40 <ezzieyguywuf> (I'm not one to comment on Data.Map itself, which is venerable, just trying to figure out my own API)
17:45:59 <dmj`> dminuoso: you'll still need that maintenance whether you use nix or not
17:46:07 <ezzieyguywuf> dmj`: which `lookup`? there are a few, lol.
17:46:16 <dmj`> ezzieyguywuf: Data.Map.lookup
17:46:25 <ezzieyguywuf> dmj`: oh yea, I already mentioned that.
17:46:28 <dminuoso> dmj`: Sure. I mean I have a long list of issues I have with nix, another big one is the complete lack of documentation about most moving parts. Unless you're keen on "copy pasting things you found", you have to dive into nixpkgs for pretty much anything. Like, you talked about callCabal2Nix. This is not documented anywhere, you just have to use the source to even figure out what its semantics are,
17:46:29 <dminuoso> what it expects as arguments, etc.
17:46:37 <dminuoso> (And this is not about callCabal2Nix in particular, but about most primitives)
17:47:23 <dminuoso> Well no, I dont need that maintenance. This "disable tests just so I can depend on it" is because nix builds the tests by default. When I depend on it via cabal, the tests need not be compilable on my local mcahine.
17:47:24 <ezzieyguywuf> sticking with the Data.Map example, is there a feasible to way wrap it (maybe in a State?) that will guarantee whichever argument is passed to lookup is a valid key?
17:48:41 <dminuoso> Ah. doJailbreak, same story. what does it even do? >:)
17:48:42 <dmj`> dminuoso: you'll definitely have to read source, but nix does have a lot of documentation, nixpkgs manual, nixos manual, nix language manual, and it becomes easier to understand the more you use nix
17:49:28 <dmj`> dminuoso: If you choose docker and kubernetes, you're choosing an even more black box solution
17:49:59 <AWizzArd> dmj`: why?
17:50:22 <solonarv> ezzieyguywuf: you *can* do that, but it's not as simple as just slapping it in a state monad
17:50:24 <dmj`> dminuoso: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/lib.nix#L79-L92 <- doJailbreak
17:50:26 <solonarv> and not very practical
17:51:07 <ezzieyguywuf> solonarv: I'm not surprised it's not simple
17:51:19 <ezzieyguywuf> how do you mean 'not very practical'?
17:51:21 <dminuoso> dmj`: Like I said, I wish I could just produce a static binary out of a plain old non-nix with cabal. But flipping on `--enable-static-executable` is a great way to produce linking errors.
17:51:33 <ezzieyguywuf> solonarv: or if you could give me some links or search terms, I"m happy to do my own research
17:51:42 <solonarv> ezzieyguywuf: don't have any links, sorry
17:52:06 <solonarv> mostly, it's a bit cumbersome to do and in the end you still end up with 'Maybe's in pretty much the same places
17:52:18 <dmj`> dminuoso: right, there's a lot of reasons that's going to happen, one being that glibc isn't made for static linking, you need something musl. Nix makes it very easy to override the toolchain without needing an entirely new operating system
17:52:19 <dminuoso> But you're definitely right regarding the "even more black box solution"
17:52:25 <dmj`> that's not going to happen*
17:53:04 <maerwald> dminuoso: have you tried alpine in a docker container to build your static executables?
17:54:10 <dminuoso> Cant say I have.
17:54:22 <solonarv> ezzieyguywuf: aha! https://hackage.haskell.org/package/justified-containers
17:54:52 <ezzieyguywuf> solonarv: ooh, I'll check it out!
17:55:21 <dmj`> dminuoso: are you on linux right now?
17:55:42 <dminuoso> dmj`: Perhaps there's an argument to be made to buid a static execuable with nix, and then patchelf it back to whatever elf loader standard linux has.
17:55:52 <dminuoso> Yes.
17:55:57 <dmj`> dminuoso: do you have nix installed
17:55:59 <maerwald> dminuoso: I build ghcup static exes in alpine docker, it is trivial
17:56:01 <dminuoso> nixos in fact (Im a hypocrite, arent I)
17:56:08 <dmj`> dminuoso: yes, yes you are
17:56:13 <AWizzArd> dminuoso: lol
17:56:14 <dmj`> dminuoso: nix-build -A pkgs.pkgsStatic.haskell.packages.ghc865.pandoc
17:56:27 <dmj`> dminuoso: nix-build <nixpkgs> -A pkgs.pkgsStatic.haskell.packages.ghc865.pandoc
17:56:34 <AWizzArd> dminuoso: srly? You are on NixOS?
17:56:39 <dmj`> dminuoso: should get you a statically linked pandoc
17:56:46 <dmj`> dminuoso: or your money back
17:57:25 <dminuoso> I mean once its statically linked, there's no system dependencies other than the hardcoded elf loader, is there?
17:57:53 <dminuoso> dmj`: I see. Presumably that uses a musl wrapped GHC behind the scenes?
17:58:19 <dminuoso> (does GHC willingly use musl if present, or do I need to convince it with wrappers?)
17:59:32 <dmj`> dminuoso: yes, https://github.com/NixOS/nixpkgs/pull/48803/files
17:59:44 <dmj`> dminuoso: GHC does not willingly use musl if present
18:02:08 <ezzieyguywuf> solonarv: nice find, though a cursory glance seems to confirm what you already pointed out - cumbersome and not that practical. It seems to simply (although quite cleverly!) shift the Maybe from `lookup` to `member`, but I struggle to see the actual net-gain
18:02:25 <solonarv> yep, that was exactly my point
18:02:38 * ezzieyguywuf nods
18:02:41 <ezzieyguywuf> thanks for the help!
18:02:57 <ezzieyguywuf> truly, Maybe is quite powerful in its own right, forcing us to be honest about our return types
18:03:20 <dminuoso> `ezzieyguywuf | I guess I'm just wondering if it's somehow "wrong" to provide `(!)` at all` -- well, if an unsafe accessor provides prominent performance benefits, then that's a good reason to expose it.
18:03:49 <ezzieyguywuf> dminuoso: nice point. I'll leave it out until profiling suggests that it may be beneficial to add.
18:03:50 <nh2> AWizzArd: ha, that's a funny mistake to make, naming a variable so that it suggests that it already contains the solution, when it doesn't. Glad you found it!
18:04:31 <AWizzArd> nh2: exactly, it must have happened at some point, because I renamed this thing in an earlier phase of my experimentation, and then I forgot about it.
18:04:50 <nh2> "Perhaps there's an argument to be made to buid a static execuable with nix, and then patchelf it back to whatever elf loader standard linux has." <- wait, does that make sense? Did you mean dynamic on the left hand side? Because I don't think you can patchelf a dynamic loader into a static exe, or can you?
18:04:59 <nh2> dminuoso: ^
18:05:16 <dminuoso> nh2: No I meant static.
18:05:25 <AWizzArd> dmj`: do you use the haskell language server?
18:05:27 <ezzieyguywuf> woah. nixos. is the whole cabal/nix conversation related at all to nixos and its packge manager nix?
18:05:37 <dmj`> AWizzArd: no, that's just candy imo
18:06:00 <dmj`> ezzieyguywuf: not related to nixos, just nix pkg mgr
18:06:22 <AWizzArd> dmj`: now that intero is no longer maintained and the whole world is moving towards the LS... why you think it’s just candy?
18:06:24 <ezzieyguywuf> dmj`: interesting.
18:06:48 <dmj`> AWizzArd: Haskell doesn't benefit from an IDE like OOP languages do (Java/C# which are almost unusable w/o IDEs)
18:07:00 <dminuoso> nh2: when I said elf loader I should have said elf interpreter
18:07:11 <dminuoso> Pardon me for my careless choice of words.
18:07:43 <nh2> dminuoso: So you can turn a static exe into a dynamic one with patchelf? If that is possible, I would love to know how
18:08:21 <AWizzArd> dmj`: Have you ever used intero?
18:08:27 <dmj`> AWizzArd: yes
18:08:54 <dmj`> AWizzArd: haskell-mode and ghcid are more than enough for me
18:09:18 <AWizzArd> dmj`: those type sigs are ultra useful, I can mark parts of calls and get that sig. Auto completion for imports, etc. There is so much that could be done.
18:10:07 <dminuoso> nh2: No. The idea is to build it statically with nix - however you cant transport the resulting binary onto a different linux because nix hardwires the ELF interpreter into the binary. patchelf is a nixos util to modify the ELF interpreter (amongst other things)
18:10:30 <nh2> I find these things "nice small convenience", but there are some more powerful IDE features that I think Haskell would greatly benefit from for production code. For example, "show me all call paths from this function to that function", so that you can check them. 
18:10:33 <dmj`> AWizzArd: I have snippets for all my imports, ghcid tells me type signatures, as does haskell-interactive
18:11:03 <AWizzArd> nh2: agreed. There is a whole world of powerful tools that could become available for Haskell devs.
18:13:20 <nh2> dminuoso: Ah, then you're not talking about fully-static executables, but statically linking Haskell libraries plus dynamically linking system libs.
18:14:04 <dminuoso> nh2: For other reasons, every program (even statically linked programs) have to be loaded through the ELF interpreter. You can think of the ELF interpreter to be the real entry point of a program. execve(2) essentially tranfers control to the elf interpreter, which in turn is responsible for locating and loading shared libraries (if necessary), resolving undefined symbols, and then executing the
18:14:06 <dminuoso> elf executable
18:14:23 <dminuoso> even if there's no shared libraries.
18:15:30 <dminuoso> Its possible that it was envisioned that an elf interpreter without those capabilities for static artifacts could exist.
18:16:00 <dminuoso> https://lwn.net/Articles/631631/ is a good read
18:16:53 <dminuoso> or hmmm
18:17:01 <dminuoso> maybe I grossly misunderstand something here. Im tired. good night
18:18:20 <dminuoso> If PT_INTERP is not specified, I suppose that process is skipped?
18:18:28 <nh2> dminuoso: thanks for the article, it's appreciated, I'll surely check it out. Let me know once you are confident in the result. But one thing I am sure is wrong in the above:
18:19:38 <nh2> dminuoso: "The idea is to build it statically with nix - however you cant transport the resulting binary onto a different linux because nix hardwires the ELF interpreter into the binary" <- if you build a fully static executabled (such that `ldd` says "not a dynamic executable"), then you can for sure use it on different Linux, because the only interface between the OS and your exe will then be system calls.
18:20:09 <nh2> dminuoso: (that's one of static-haskell-nix's key reasons for existence, Linux forward-and-backward portability)
18:23:10 <dminuoso> nh2: how can I simply test this? What nix invocation would I have to do to end up with a static binary out of pkgStatic in my hand?
18:24:15 <nh2> dminuoso: I think dmj` provided one above, just before "or your money back"
18:24:28 <dmj`> nh2: :)
18:24:51 <dminuoso> I want my money back, then!
18:24:54 <dmj`> dminuoso: nix-build <nixpkgs> -A pkgs.pkgsStatic.haskell.packages.ghc865.pandoc
18:25:39 <dminuoso> Ah yes, probably should put quotes around that.
18:25:52 <dminuoso> Do I still get my money back?
18:26:01 <dmj`> dminuoso: depends
18:26:12 <dmj`> dminuoso: did you run it?
18:26:15 <dminuoso> Yes.
18:26:21 <dmj`> dminuoso: what happeend
18:26:39 <dminuoso> dmj`: zsh: no such file or directory: nixpkgs
18:26:41 <dminuoso> :p
18:26:51 <dmj`> dminuoso: nix-build '<nixpkgs>' -A pkgs.pkgsStatic.haskell.packages.ghc865.pandoc
18:26:54 <dmj`> try again
18:27:17 <dminuoso> dmj`: Like I said, just needed quotes around it. Ignore me, was just trying to make a funny remark about the getting my money back.
18:27:27 <dminuoso> Oh hah. Indeed. I should get my money bac
18:27:36 <dminuoso> configure: error: cannot run C compiled programs.
18:27:36 <dmj`> dminuoso: you won't get your money back this time, I'm sorry.
18:27:47 <dminuoso> cannot build derivation '/nix/store/pmknl0qxb7nql4x2rj2n0hc5j8dsb7ab-pandoc-2.7.3-x86_64-unknown-linux-musl.drv': 1 dependencies couldn't be built
18:27:57 <dmj`> dminuoso: can you paste it all
18:29:07 <dminuoso> https://gist.github.com/dminuoso/16c93f7db930c875c870ca2f1a783024
18:30:03 <nh2> dminuoso: You can also try it on a pre-built static haskell exe. For example, the latest dhall release, https://github.com/dhall-lang/dhall-haskell/releases/download/1.33.1/dhall-1.33.1-x86_64-linux.tar.bz2
18:30:34 <nh2> dminuoso: if I try to run `patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 bin/dhall` on a static exe like that, I get `cannot find section .interp`
18:30:57 <dmj`> dminuoso: maybe try nix-channel --update
18:30:57 <nh2> this is what I remembered, and why I was very curious whether that would work (if this is what you had in mind)
18:32:02 <dminuoso> nh2: I probably understand it not even half as good as I should. I was under the false assumption that the ELF interpreter was necessary always.
18:32:10 <dminuoso> Presumably its only specified if dynamic loading is necessary
18:33:59 <nh2> dminuoso: that is possible, but I haven't read your article yet, so I cannot confirm nor deny. So far I mainly build static exes, and haven't looked into how they are run (because the running part has always been easy for me)
18:35:57 <nh2> dminuoso dmj` : The issue above is this one https://github.com/NixOS/nixpkgs/issues/84670; it seems fixed only on nixpkgs master (I assume you're running 20.03)
18:36:41 <dminuoso> dmj`: still fails with the same errors
18:37:17 <dminuoso> now I definitely want my money back
18:37:29 <nh2> dminuoso: well the question is which channel you're updating there
18:38:00 <dminuoso> nixpkgs https://nixos.org/channels/nixos-20.03
18:40:24 <ezzieyguywuf> is there a neater way to do something like `do x <- getVal; y <- getVal; useVals x y`?
18:41:11 <nh2> dminuoso: that's the reason then, this is only fixed on `unstable`/`master`, not in 20.03. I just asked here to confirm: https://github.com/NixOS/nixpkgs/pull/84741#issuecomment-662780010
18:41:32 <dminuoso> nh2: ah this is bleeding edge stuff
18:42:14 <nh2> dminuoso: well they broke it in February accidentally by enabling gold as the linker, 20.03 was released in March, and this was fixed in April
18:42:27 <dminuoso> ezzieyguywuf: `join (useVals <$> getVal <*> getVal)` ?
18:43:20 <ezzieyguywuf> dminuoso: got ol' applicative. I always seem to forget about that. I'll see if that does what I want thanks
18:43:39 <dminuoso> Equivalently, you can cook up a bind2 function `bind2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c; bind2 f v1 v2 = do { s <- v1; t <- v2; f s t }`
18:43:45 <nh2> ezzieyguywuf: if it doesn't, somebody broke the law
18:43:54 <ezzieyguywuf> lol
18:44:17 <dminuoso> ezzieyguywuf: well the key part is the `join` here
18:44:42 <dminuoso> ezzieyguywuf: Personally Id just write it as you've written it. It's clearer I think
18:44:51 <ezzieyguywuf> yea I was mostly curious
18:45:21 <ezzieyguywuf> ah, yes, `join`. The `getVal <*> getVal` was stumping me
18:47:39 <ezzieyguywuf> hm, my use-case is actually `do x <- getVal; y <- getVal; useVal x y; pure (x, y)`, so probably this is the cleanest way anyway
18:48:16 <ezzieyguywuf> I just don't like that I have to give the x and y a different name when i "catch" it, otherwise I get a -Wall error about shadowing
18:48:52 <dminuoso> ezzieyguywuf: adding a ' can be helpful
18:49:44 <ezzieyguywuf> dminuoso: indeed. I'm leaning towards `_x..._y`
18:50:03 <ezzieyguywuf> because to me ' means "I've modified this in some way"
18:50:29 <monochrom> You can consider not using -Wall. :)
18:50:43 <ezzieyguywuf> hah, I like it though.
18:50:51 <ski> ezzieyguywuf : `infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> (m a -> m b); mamb <*>> ma = join (mamb <*> ma)', then use `useVals <$> getVal <*>> getVal' (in general, `f <$> x <*>> y',`f <$> x <*> y <*>> z',`f <$> x <*> y <*> z <*>> w',&c.)
18:51:06 <monochrom> Most shadowing confuses readers. Normally you try not to have not too many anyway.
18:51:32 <nh2> dminuoso: here you go https://github.com/NixOS/nixpkgs/pull/93687. Do I now get dmj`'s money?
18:51:45 <ezzieyguywuf> ski: ah, you made up a new operator
18:51:56 <ski> ezzieyguywuf : years ago
18:52:20 <dminuoso> nh2: Just curious, are you just tired or is 20.30 a thing? You mentioned it in the previous issue and this PR...
18:52:24 <ezzieyguywuf> nicely done, I tend to avoid this though b/c while it makes code easier for me to write it tends to make it more difficult to read/maintain
18:52:55 <dminuoso> ski: what does &c. denote here?
18:53:05 <ski> "et cetera"
18:53:25 <ski> "u.s.w.","un so weiter". "and so on"
18:53:28 <dmj`> dminuoso: nh2 gets the money
18:53:34 <nh2> dminuoso: oops, thanks
18:53:43 <nh2> also thanks for finding that nobody had backported it yet
18:53:48 <monochrom> Yes, some kinds of "easier" to write has long-term costs. When "easier" means "short-term more convenient".
18:54:58 <monochrom> When there is this conflict, I try to lean towards long-term benefits, because we programmers always underestimate code lifetime.
18:55:44 <monochrom> Unless I really will delete that code two hours later.
18:56:45 <MarcelineVQ> monochrom: long suffering line of the trades is "there's nothing more permanent than a temporary solution"
18:56:47 <nh2> dminuoso: with a bit of delay to the previous conversation, everybody complains about the nix documentation but nobody sits down and adds it. The real solution, if you use it in an org that makes money, is to just allocate 20 hours to it and tell somebody who understands it to comment every single `haskell.lib` function with what it does, and this topic will be dealt with for good. I'll gladly merge any such PR.
18:57:00 <monochrom> heheh
18:57:58 <dminuoso> nh2: When get get a haddock equivalent I just might. Even if things are documented, it then quickly becomes a discoverability problem.
18:58:17 <dminuoso> Don't get me wrong, I want the ergonomics to be right. I'm not opposed to nix.
18:58:21 <dmj`> dminuoso: nix repl is good for discoverability
18:58:48 <dminuoso> dmj`: Err huh? Discovering what primitives exist and their documentation?
18:59:58 <nh2> dminuoso: it is well understood though that the current 2 places for docs are code comments and the manual; that's where people look. I would not hold my breath for a Haddock equivalent, and I also don't think it is as critical to have it
19:00:21 <nh2> so I mean that if you add docs for things in either of these 2, pretty much everybody will find them
19:03:30 <dmj`> dminuoso: pkgs.<pkg>.meta.position
19:03:32 <nh2> dminuoso dmj`: Also on the previous conversation (now that we have the technical parts solved, haha), I had the same questions about whether using nix in my org is worth it. We made the switch and 4 years of that we are very glad about it (it did cost significant initial effort, but 1 expert to understand it very well is enough to quickly bring an org up to speed)
19:04:25 <dminuoso> nh2: Perhaps if your org is developer heavy. We're an ISP, it's somewhat uncommon to have inhouse development at all. :)
19:05:22 <dmj`> nh2: I used nix in a team of 5, where I was the "expert" and we never had a build problem or a "works on my machine" problem. Used it with 5 languages, and even docker too
19:05:28 <nh2> dminuoso: it's definitely developer heavy (three 10-years Haskellers)
19:06:16 <dminuoso> nh2: Out of random curiosity, do you have a hydra running?
19:06:30 <dminuoso> (And if so, where is your source code stored and how is hydra triggered?)
19:07:00 <nh2> dminuoso: no, we use Jenkins on a NixOS machine with a 4 TB disk, that is set up as binary cache for all developers.
19:07:40 <nh2> source is stored on Github, if that's still relevant
19:07:56 <dmj`> dminuoso: we just used an s3 bucket for the cache, used travis w/ it
19:08:11 <dmj`> fetching the deps took longer than actually running the build
19:08:14 <dmj`> closure size was 8gb
19:09:28 <nh2> "fetching the deps" is the key reason why we switched from hosted stateless CI services to self-hosted Jenkins. It turns any network fetching into a no-op, allowing for super fast builds. Also the machine is 20 times faster for a fraction of the price
19:10:57 <dminuoso> We're currently opted into gitlab with its gitlab-ci, to a lot of dismay.
19:11:03 <dmj`> nh2: smart move, I advocated for gitlab CI and colocating a server but "the cloud" and "serverless" was considered "better". Then Travis and GitHub starting going down more frequently, but I never said, "told ya so"
19:11:14 <dminuoso> From what I gather, there's no nice way to have gitlab play nice with hydra. :(
19:11:35 <nh2> Also, Jenkins allows to do some things in addition to normal nix builds that Hydra cannot do. I care a lot about fast CI feedback, so before the normal `nix-build` (which takes 5 minutes for our Haskell package), I run an incremental `Setup.hs build` in nix shell, resuming from the content of the last build of that branch. That makes that only the actual files changed by the last commit are recompiled. That way we get 
19:11:36 <nh2> feedback in 20 seconds.
19:11:46 <dminuoso> nh2: but when you say jenkins, that's still with hydra right?
19:11:47 <dmj`> dminuoso: hydra really sucks, it's a perl monstrosity and not good for private projects, better for what its used for, distributing a binary cache
19:11:49 <dminuoso> oh
19:11:56 <dminuoso> I see
19:12:14 <nh2>  (That was after I did the whole "linking Haskell with gold" thing, because before that only the executable link time already exceeded 1 minute for our 8 exes).
19:12:19 <dminuoso> so what would your jenkins actually do? just build things in its nix store?
19:12:28 <dminuoso> *in its host systems
19:12:37 <nh2> dminuoso: right, it just runs `nix-build` in the Jenkinsfile
19:13:09 <dminuoso> Do you copy closure things out of that then?
19:13:31 <dmj`> nh2: did you use nixops?
19:13:52 <nh2> dminuoso: that happens automatically; all production and developer machines have that Jenkins machine set up as a binary cache, so what the Jenkins built, nobody else has to build again
19:14:36 <dminuoso> Fair enough, probably need to understand how jenkins works.
19:14:59 <nh2> dmj`: Yes, we use nixops, and I also built a thing that runs our entire multi-server NixOps deployment in VMs on every commit, so that I can see whether any nixops config change would break our production systems
19:15:28 <dmj`> nh2: was that using the nixos testing framework
19:16:25 <dmj`> nh2: 40TB sounds great
19:16:27 <nh2> dminuoso: it really has Nothing to do with Jenkins at this point, I just tell it that if somebody pushes to github, to run the same `nix-build` that a dev would run, and that's it. Anything in the CI machine's nix store will be transparently fetched when any other machine tries to build that thing.
19:16:38 <dmj`> er, 4TB :P
19:16:46 <liiae> how to define a binary function with two lambdas as parameters?  f (\k -> k R) (\kr -> \k -> k $ G kr) = \k -> k $ G (k R)
19:16:47 <ezzieyguywuf> new question: https://dpaste.com/EW6KWWZNV in `myState`, is there a way to do this in a single do-block? would this be any more readable or succinct?
19:17:02 <nh2> dmj`: it's ultra cheap, a 4 TB Hetzner server costs 20 EUR/month
19:17:10 <dmj`> wow
19:17:28 <nh2> dmj`: We also have a 256 GB ram machine for 58 EUR/month
19:18:24 <liiae> that R and G should be free
19:18:28 <liiae> not
19:18:30 <dmj`> nh2: and its bare metal? that's what I hated about travis, no hardware acceleration when running QEMU, so nixos tests always timed out the build
19:18:47 <liiae> how I define that f?
19:19:00 <nh2> dmj`: Yes, all bare metal. Drag the RAM slider on this page: https://www.hetzner.com/sb?country=us&ram_from=11&ram_to=13. We also have GPU machines
19:19:23 <dminuoso> ezzieyguywuf: You could use MaybeT
19:19:32 <ezzieyguywuf> dminuoso: ah hah, ofc
19:19:51 <ezzieyguywuf> but would it be worth the extra overhead
19:20:26 <dmj`> that exceptional german engineering
19:20:50 <nh2> dminuoso: because any SSH machine with nix on it can be a substitutor, we just have a `./mynix` script for all devs that adds `--option extra-substituters ssh://jenkins.company.example.com` to all nix invocations, done
19:20:55 <dminuoso> ezzieyguywuf: https://gist.github.com/dminuoso/2836ded25aed09ba708bbed53c927ddf
19:21:02 <dminuoso> ezzieyguywuf: Does this look like much overhead? :)
19:21:43 <ddellacosta> damn it never occurred to me to use MaybeT like that. Not who you intended that for but thanks dminuoso 
19:21:44 <dminuoso> ezzieyguywuf: Oh, I think those first lifts are off. But we can fix that..
19:21:54 <nh2> dmj`: I wrote a bit about it here: https://news.ycombinator.com/item?id=21468506
19:22:25 <ezzieyguywuf> dminuoso: actually seems pretty straightforward...
19:22:34 <ezzieyguywuf> I think I just need to get more comfortable with monat transformers
19:23:06 <nh2> dmj`: about your other question: No, the NixOps VM testing does not use the NixOS VM tests infrastructure, because while that can simulate multiple machines, it cannot simulate `nixops` being run against multiple machines, and I wanted the CI to also catch bugs in nixops itself (e.g. when it invokes switch-to-configuration to reload our Haskell webserver).
19:24:02 <dminuoso> nh2: Ah I see. In that case, it should be trivial to adopt it to gitlab-ci with a simple shell executor.
19:24:25 <ezzieyguywuf> dang, but MaybeT is in transformers, not mtl. I already have an mtl dependency, a shame to add transformers...
19:24:35 <dminuoso> ezzieyguywuf: You very likely depend on it transitively anyway.
19:24:44 <ezzieyguywuf> hrm, good point
19:24:48 <ddellacosta> ezzieyguywuf: if you have mtl you have transformers
19:24:58 <infinisil> nh2: Damn, that's impressive!
19:26:19 <dminuoso> nh2: How do you expose those artifacts to nixops? Is that jenkins server provided as a channel?
19:26:24 <nh2> dminuoso: yes, gitlab can do it. When we started, its CI wasn't so built-out yet, and Jenkins had just added what we needed (a proper language to define multi-stage + parallel builds in the Jenkinsfile, and a pretty UI with blue ocean)
19:27:05 <fog> its not obvious to me how to define fmapM and foldrM in terms of scannerM; https://pastebin.com/raw/rqiavXrr
19:27:07 <dminuoso> Or well. I suppose you dont actually care about channels if you deploy straight from that same server.
19:27:42 <dmj`> nh2: wow
19:28:17 <nh2> dminuoso: The bastion server that we deploy _from_ (run nixops on) is the Jenkins server (if it wasn't, it would still work transparently with the `extra-substitutors` from above). And the servers that we deploy _to_ also have the `extra-substitutors` set (but in the global nix config), so they, too, fetch from it if they want a build output
19:28:50 <dminuoso> ezzieyguywuf: Ah. So you need to double lift those map lookups. Took me a while because I didnt sleep much. :)
19:29:18 <fog> i cant tell if some of the functions types would have to change slightly, and if this would affect how they function
19:29:18 <ski> liiae : doesn't make sense to me
19:29:37 <dminuoso> ezzieyguywuf: So I'd probably write `lift2 = lift . lift` as a separte binding, and then write it as `runMaybeT $ do { x <- lift2 $ ...; y <- lift2 $ ...; lift (useData x y)`
19:31:21 <ski> "<fog> ski: what is all this madness?" -- hahah ! :)
19:31:38 <liiae> ski: if I'd like to implement a function like Promise.then in haskell, then it will look like (\k -> k R).then(\kr -> \gkr -> gkr $ G kr)
19:32:31 <liiae> and that gkr and k should be the same, R and G are not free, R is a normal value like 3, G is normal unary function like (+2_
19:32:35 <ski> why do you think it should result in `\k -> k (G (k R))', though ?
19:32:36 <liiae> (+2)
19:32:37 <ezzieyguywuf> dminuoso: trying that now.
19:32:39 <etherealemb5> Does Haskell have any libraries for composing gremlin queries?
19:32:39 <nh2> infinisil dmj`: I started out with "ok, if you wanted to devops well and had full choice on the tech, how would you do it?" and this is what we use for years now.
19:32:54 <dminuoso> ezzieyguywuf: Ah.. I think this wont work because that's not a StateT..
19:32:58 <liiae> ski: gkr and k share the same input
19:33:05 <etherealemb5> Basically gremlex for haskell 
19:33:19 <ski> liiae : what does that mean ?
19:33:51 <dmj`> nh2: greenfield ventures are best
19:33:55 <dmj`> nh2: status cake ay?
19:34:02 <nh2> infinisil dmj`:  I actually got into nix not via Haskell, but via Ansible, thinking "this can't be the end of it", 10 minute deployment for an nginx config change sucks, and I wanted to do it in 5 seconds
19:34:13 <ezzieyguywuf> dminuoso: yup, still stumbling through it
19:34:19 <ezzieyguywuf> dminuoso: but it does seem like the correct direction.
19:34:29 <etherealemb5> Nm found a few on hackage
19:34:31 <liiae> ski: (\k -> k R).then(\kr -> \gkr -> gkr $ G kr) == \gkr -> gkr $ G kr
19:34:34 <dmj`> nh2: what are your thoughts on kubernetes ?
19:34:54 <ezzieyguywuf> dminuoso: but I think I would have to use StateT perhaps...
19:35:03 <dminuoso> ezzieyguywuf: That wont help you
19:35:10 <infinisil> nh2: 5 seconds only for copying closure + activating I guess right?
19:35:14 <ski> liiae : so `R' is ignored ?
19:35:21 <liiae> ski: kr is k R, k is gkr
19:35:24 <nh2> infinisil: yes, that's for the nginx config change
19:35:50 <liiae> ski: \gkr -> gkr $ G kr   =   \k -> k $ G (k R)                     
19:35:52 <infinisil> That's pretty damn fast
19:35:59 <ski> liiae : it seems to me that the type of `k' would be different from the type of `gkr'
19:36:12 <nh2> dmj`: I had to have quite a bit of patience with StatusCake, they had way less reliability than us, repeatedly telling us that we were down when it was them who were down. But they were the only ones I found that could easily test at high frequency from multiple geo locations, and they did fix all my bug reports eventually
19:36:15 <ski> (also, would you please stop using `$' ?)
19:36:29 <dminuoso> ezzieyguywuf: Mmm. is `lift . pure` actually the right way? I think os.
19:36:30 <ezzieyguywuf> dminuoso: I don't think the return type of runMaybeT matches though
19:36:38 <liiae> ski: why you don't like $?
19:36:43 <ski> it's ugly
19:36:49 <liiae> ski: you perfer .? or ()?
19:36:54 <ski> yes
19:37:00 <dmj`> nh2: well that's nice of them
19:37:02 <nh2> infinisil: is it? It should be just as fast for anyone doing `nixos-rebuild switch --fast` for a simple config change
19:37:03 <dmj`> nh2:  and how did you test deploys w/ nixops in QEMU ?
19:37:27 <dminuoso> @unmtl MaybeT StateT Text
19:37:27 <lambdabot> err: `StateT (Maybe Text)' is not applied to enough arguments, giving `/\A B. Maybe Text -> A (B, Maybe Text)'
19:37:27 <liiae> ski: but if I use . , then $ still show up in the last
19:37:29 <dminuoso> @unmtl MaybeT State Text
19:37:29 <lambdabot> err: `State (Maybe Text)' is not applied to enough arguments, giving `/\A. Maybe Text -> (A, Maybe Text)'
19:37:41 <dminuoso> @unmtl MaybeT State Data Text
19:37:41 <lambdabot> Maybe Data -> (Text, Maybe Data)
19:37:50 <ski> i normally prefer `(f x . g . h y z) blah' over `f x . g . h y z $ blah'. but `f x (g (h y z blah))' is also fine
19:38:01 <ski> liiae : not if you use brackets
19:38:07 <liiae> ski: or (f . g) x
19:38:43 <infinisil> nh2: Well, copying closure is often slower for remote machines at least. And activation time can be pretty bad with many tmpfiles, many services or slow disk/devices
19:39:29 <dmj`> nh2: are you worried that this experience has now ruined you because all future configurations will be expressly worse than what you currently have
19:39:32 <infinisil> But yeah I guess it's not too far off for standard Nix machines :)
19:39:34 <ski> a few, sparse, uses of `$' may be okay. but i think it's just ugly to see people use it to "spare" one or two pairs of brackets, in various spots all over the place. i'd much prefer seeing honest brackets
19:39:52 <liiae> ok
19:40:14 <nh2> dmj`: yes, I first used nixops's nixops's containers backend (which uses systemd-nspawn), fixed a ton of bugs in that, and then to nixops's libvirt backend, and then fixed bugs in that (I had to switch from containers to VMs because it was, interestingly, faster:
19:40:16 <nh2> dmj`: We run consul, which does a lot of fsync()s per second, and you cannot disable fsyncs with the nobarrier mount option for bind mounts, so I had to use real VMs to use nobarrier, and libeatmydata LD_PRELOAD doesn't work for Go binaries like Consul because Go does  syscalls directly, not via libc)
19:40:18 <dminuoso> ezzieyguywuf: Mmm, you are right. I was thinking of `StateT MyData Maybe Text`
19:40:39 <ezzieyguywuf> dminuoso: which would require changing up my data type altogether - again "is it worth the overhead"
19:40:41 <dminuoso> But that wouldn't be right either
19:40:47 <ski> if you have a pair of brackets that otherwise would span multiple lines, then it may be okay to use `$'
19:40:54 <dminuoso> ezzieyguywuf: Let me ponder about this. Im confident there's a concise way here
19:41:32 <ski> (but if it's just two or three lines, then it's probably not worth it)
19:41:46 <ski> liiae : what is the type of your `f' ?
19:42:47 <dminuoso> ezzieyguywuf: By the way, `x >>= pure . f` is just `f <$> x`
19:42:50 <nh2> infinisil: ah, but an nginx config change doesn't need to copy much closure, as the services configs sit so high up the dependency tree, and it's just a couple KB. We dont' have many services, mainly nginx, Ceph, Consul, postgres, Stolon, smokeping, tinc, SSH, and our monolithic Haskell server
19:43:07 <ezzieyguywuf> dminuoso: it sure is. thanks for pondering it, ping me if you come up with something I'm heading to bed
19:43:25 <ezzieyguywuf> dminuoso: I always forget about that identity, hasn't quite cemented itself in my head
19:43:43 <dminuoso> ezzieyguywuf: Do you use useData naywhere else?
19:44:04 <infinisil> nh2: Ah yeah, makes sense
19:44:29 <ski> liiae : earlier you said `f (\k -> k R) (\kr -> \k -> k $ G kr) = \k -> k $ G (k R)', and i was wondering about the nested call to `k' in the result
19:44:39 <liiae> ski: if f (\k -> k R) (\kr -> \k -> k $ G kr) = \k -> k $ G (k R) exist, then f :: ((a->b)->b) ->   (b->(a->b)->b)  ->    b
19:44:40 <ezzieyguywuf> dminuoso: useData is outward-facing, i.e. it's part of the API
19:45:03 <nh2> dmj`: not too worried, because I'm quite OK at convincing people (especially if you can show systems that work, and the amount of stuff you managed with a small team), and if this works out, I'll hopefully be on the employer side for the rest of my life anyway :D
19:45:32 <liiae> ski: that's not sense?
19:45:41 <dminuoso> ezzieyguywuf: Huh maybe Im really too tired. The code with runMaybeT should be right.
19:46:14 <fog> here is a "test" that should still work if the definitions of fmapM and foldrM are changed to be defined in terms of scannerM
19:46:15 <fog> https://pastebin.com/raw/cBJLmxeV
19:46:16 <dminuoso> @unmtl MaybeT (State Data) Text
19:46:16 <lambdabot> Data -> (Maybe Text, Data)
19:46:45 <liiae> ski: like f :: c -> (b -> c) -> b
19:46:55 <fog> i only think this should be possible because something similar works with fmap and foldr being defined in terms of traverse
19:47:25 <ski> liiae : also, you said `R' and `G' should not be free. so where would they be bound ? also, what're their types ?
19:47:26 <fog> but the definitions in the library use coerce which is difficult to translate to this setting
19:47:28 <dminuoso> ezzieyguywuf: https://gist.github.com/dminuoso/8e97b072da322d287a038583d53628a4
19:47:31 <liiae> ski: oh, not like, sorry
19:48:20 <ski> liiae : from that signature of `f', it seems like `R :: a'
19:48:25 <liiae> ski: R :: a,
19:48:45 <dminuoso> ezzieyguywuf: Or.. ah. I think it should be `MaybeT` rather than `lift` in liftP
19:48:48 <ski> liiae : however, the result type of `f' looks incorrect ?
19:48:50 <fog> the main problem seems to be that if foldrM is redefined, maybe it wont work for forcing the evaluation of the scanner
19:49:03 <fog> which is how embed currently works
19:49:05 <ski> liiae : and the type of the second parameter also looks dubious (the same `b' ?)
19:49:06 <dmj`> nh2: sounds very ideal :) 
19:50:07 <dmj`> nh2: did you use any of the npm ecosystem with nix ? I found that to be sorely lacking, and downright broken at times. Python, C++, Haskell, even R were great.
19:50:08 <fog> previous attempts have made changing the type of foldrM to be with less monads in its type, have broken this functionality by making it more, or less lazy
19:50:19 <liiae> ski: same 'b'
19:50:37 <liiae> ski: since kr is k R 
19:50:50 <ski> why ?
19:51:03 <ezzieyguywuf> dminuoso: `MaybeT $ Just (useData x y)` still results in a `Maybe (Maybe Text)`
19:51:12 <nh2> dmj`: on Kubernetes, I've used it a bit, I think it's useful for large deployments (if you benefit from the design goals Google had for Borg, running N jobs on M machines, where N > 1000 and M > 100), but for most small/medium-sized ventures it's overkill to have a cluster manager, and the complexity it comes with is significant.
19:51:16 <nh2> dmj`: NixOS is much easier, and more importantly, allows you to understand your whole stack with a single-person's few months time investment (I'm confident to modify the code of any OSS component form the Haskell server down to and excluding the systemd and the kernel, and for many components did that to fix bugs). With Kubernetes this is not possible, there is just too much code.
19:51:22 <dminuoso> ezzieyguywuf: No wrong spot
19:51:25 <ski> wouldn't it make more sense to have `kr' become `R' itself ?
19:51:28 <dminuoso> ezzieyguywuf: Im talking about `liftP = MaybeT . lift`
19:51:45 <dminuoso> Or..
19:51:50 <dminuoso> ezzieyguywuf: ah. liftP = MaybeT . pure
19:51:56 <dminuoso> This is hard without a compiler in your hand.
19:52:01 <ezzieyguywuf> hrm, maybe `pure . runMaybeT`....
19:52:06 <dminuoso> ezzieyguywuf: no.
19:52:07 <fog> im not even sure if its possible since they seem to work in opposite directions
19:52:19 <dminuoso> ezzieyguywuf: https://gist.github.com/dminuoso/8e97b072da322d287a038583d53628a4 this should be fine now
19:52:27 <fog> like, to be lazy, scanner needs to scan from the left
19:52:42 <ezzieyguywuf> MaybeT . pure compiles!
19:52:44 <fog> thats why its not called, scannerL 
19:53:04 <dminuoso> ezzieyguywuf: the idea is as follows: `Map.lookup 0 myData :: Maybe Text`, you stuff that into State with `pure` - now the type matches and just needs the MaybeT newtype wrapper.
19:53:05 <nh2> dmj`: Yes, we used one of the node-to-nix tools (there are multiple ones with the same name) for a while, and rebuilds took forever (add a new package, wait 10 minutes, more than our Haskell builds, pretty ridiculous for a scripting ecosystem); at some point we switched to yarn and yarn2nix and that insta-solved those problems.
19:53:05 <fog> because the scannerR would not work for infinite streams
19:53:21 <dmj`> nh2: completely agree on it being overkill for almost everything but a search engine, or something that needs high availability. 80% of the internet is word press blogs anyways. 20% is FAANG. Totally on board with modifying any part of the stack using nix's overrides and now overlays
19:53:22 <liiae> > let f = \k -> k 3; g = \kr -> \gkr -> gkr $ (+2) kr; z = f >>= g in z (+5)   ^ ski 
19:53:24 <lambdabot>  error: Variable not in scope: ski :: Integer
19:53:31 <dminuoso> ezzieyguywuf: The other `lift` is to hoist the (State s) action into a MaybeT (State s) action
19:53:38 <liiae> > let f = \k -> k 3; g = \kr -> \gkr -> gkr $ (+2) kr; z = f >>= g in z (+5) -- ski
19:53:40 <dminuoso> And the runMaybeT gives you shortcircuiting semantics
19:53:41 <lambdabot>  15
19:54:09 <liiae> ski: R is 3, G is (+2)
19:54:18 <fog> i guess the first thing then is to see if embed still works with foldlM
19:54:33 <ezzieyguywuf> dminuoso: I understand most of that!
19:54:54 <ezzieyguywuf> it's definitely more succinct, and seems more readable (though it does challenge my understanding of transformers and lift)
19:55:12 <dmj`> nh2: yea, I switched to yarn2nix as well, but still ran into issues with projects (like facebook's docasaurus for example) that used lerna https://github.com/lerna/lerna
19:55:28 <dminuoso> ezzieyguywuf: lift is nothing fancy. It's a sort of `pure` equivalent for transformers
19:55:32 <ski> liiae : did you really mean to use `Monad (Integer ->)' there ?
19:56:07 <fog> actually wait, im confused, why does it work for foldrM at all!?
19:56:10 <ezzieyguywuf> dminuoso: yea, I mostly understand the concept, it's just the mechanics that haven't quite clicked in my head fully
19:56:11 <ski> > let f = \k -> k 3; g = \kr -> \gkr -> gkr $ (+2) kr; z = runCont (cont f >>= cont . g) in z (+5) -- liiae
19:56:13 <lambdabot>  10
19:56:19 <fog> is foldr lazy?
19:56:26 <dminuoso> ezzieyguywuf: So if you have a computation in `Foo s`, lift turns it into some `T Foo s` where `T` is some transformer of your chosing.
19:56:34 <dmj`> nh2: very interesting the VMs were faster than NixOS containers
19:56:34 <dminuoso> ezzieyguywuf: One example you've been using this probably somewhere, is liftIO.
19:56:47 <ezzieyguywuf> dminuoso: I have not actually used liftIO :-P
19:56:51 <dminuoso> ezzieyguywuf: liftIO is a specialized lift, with the additional power that it doesnt lift a single layer, but arbitrary layers.
19:56:52 <nh2> dmj`: that said, I do believe that Kubernetes can be an improvement for many companies, especially if switching them to Nix is just out of scope (it's a bit all-or-nothing buy-in most of the time), and because it introduces structure into what usually previously is completely unorganised desaster. Like, many companies build one-off .deb packages and then hand that to a sysadmin to install.
19:56:52 <dminuoso> Ah.
19:57:05 <ski> `foldr f' may be non-strict, if `f' is
19:57:25 <fog> but how does it reach the end of the list?
19:57:29 <liiae> ski: yes
19:57:31 <ezzieyguywuf> dminuoso: how'd you get away without importing the MaybeT stuff?
19:57:34 <dminuoso> nh2: I found that kubernetes is anything but an improvement for many companies.
19:57:38 <fog> oh, i guess it still does tail recursion...
19:57:38 <ski> liiae : which result would you expect to get here ? `15' ? `10' ? something else ?
19:57:50 <dminuoso> ezzieyguywuf: What do you mean?
19:58:17 <liiae> > let f = \k -> k 3; g = \kr -> \gkr -> gkr $ (+2) kr; z = f >>= g in z id
19:58:17 <dminuoso> Oh, I didnt bother to modify the import lists. I just edited the source file in gist
19:58:19 <lambdabot>  5
19:58:22 <dmj`> nh2: yea but as you say, it is overkill, and now all these small / medium sized business or even large businesses w/o the need for uptime have this giant black box bazooka and dockerfiles strewn about
19:58:26 <ezzieyguywuf> dminuoso: ah gotcha.
19:58:29 <dminuoso> I assumed you'd pick up on the error and fix it yourself.
19:58:36 <liiae> > let f = \k -> k 3; g = \kr -> \gkr -> gkr $ (+2) kr; z = runCont (cont f >>= cont . g) in z id
19:58:37 <lambdabot>  5
19:58:39 <dminuoso> nh2: I found that kubernetes is anything but an improvement for many companies.
19:59:06 <liiae> ski: I don't know, what's the diffrent 
19:59:07 <fog> how else would you do thread handling?
19:59:14 <ezzieyguywuf> dminuoso: thanks for the help! I may even add a `getData :: Int -> State MyData Text`. for my own sake, as this will help me understand what's going on
19:59:18 <nh2> dminuoso: Well, as I mentioned it depends on what they use otherwise. The example I'm talking about is when you have sysadmin Joe who you have make build your software into .debs and then SCP it onto the server, and if Joe isn't in the office, nobody can deploy.
19:59:26 <dminuoso> Especially because the problem k8s addresses is not one that many have. It not only is a large stack of black boxes, but it changes the semantics of your applications, so not only do your traditional sysadmin powers become useless, your traditional programmer powers become useless sa well.
19:59:31 <dmj`> nh2: what are your thoughts on haskell.nix
19:59:55 <dmj`> nix makes everybody a joe 
19:59:59 <fog> without kuberneties how would you limit the amount of resource allocated to several simultaniously running haskell programs?
20:00:12 <dminuoso> okay useless is a bit harsh here, but the k8s mindset revolves around writing small stateless containers that can be spooled up, moved around, or randomly die. and your application must be fine with it
20:00:12 <fog> thats what i was aiming for with the "clock" idea
20:00:16 <dmj`> nh2: how did you handle the nixops state file, did you encrypt it?
20:00:22 <ski> liiae : one distributes a function. the other uses CPS
20:00:47 <fog> the whole point was to emulate interacting servers, but if they are in kuberneties, then you need some way also to emulate the resource allocation
20:00:59 <dminuoso> nh2: doesnt the same hold true for any tech? I mean if you dont understand k8s/docker, you cant deploy or maintain it.
20:01:07 <dminuoso> if you dont understand nix/nixos/nixops, you cant deploy or maintain it
20:01:35 <liiae> ski: the former is like Reader?
20:01:35 <fog> so you would have the pure version, replacing IO of the interacting servers with Identity, synchronized by the clock, as there is no forkIO
20:01:44 <ski> yes
20:01:51 <nh2> dminuoso: yes, I think all you say is true. But at least it makes people write their configs down in code, and put it into version control, which is already a huge improvement over what may companies in industry do, even if this means they have to learn other new, and difficult, stuff
20:01:57 <dmj`> dminuoso: yea but k8s / docker isn't reproducible like nix
20:02:04 <fog> but then you have a problem which is if each of the processes recieving () actually takes a different amount of time to run
20:02:09 <liiae> ski: the diffrence is Reader and Cont in function level?
20:02:22 <liiae> ski: I mean use function to express them 
20:02:25 <dminuoso> nh2: this is precisely why Im trying to have our infrastructure guys change from "clicking in vsphere" to using terraform. :<
20:02:29 <ski> i dunno what you mean by "function level", but i think the answer is likely "no"
20:03:03 <fog> eg in an adversarial setting, a lightweight rapid response advantage could not be realised in comparison to a heavyweight computation
20:03:34 <fog> since both would take one clock cycle to complete, as scheduled in the pure setting by being synchronised with () clock signals
20:03:42 <nh2> dmj`: haskell.nix is, too new for my judgment, I was in codygman's stream on ZuriHac where he tried it out and we found a couple of issues and he documented lots of things about it. I think the engineers involved in it are competent and understand the underlying stuff
20:04:21 <liiae> ski: I mean represent them in dynamic languages by using functions, without type constructors
20:04:38 <fog> then you end up needing to know "how many clock cycles to wait" before doing a computation again, in order to emulate containerised parallelism 
20:05:05 <fog> which can be determined empirically via benchmarking
20:05:42 <nh2> dmj`: the state file just sits on the bastion machine, it lives in the same security context as the CI (if something compromises our CI for the software we run, it's just as good as good as owning access to the hardware that runs it)
20:06:05 <fog> i think avoiding the overhead of kubernetties in this way, by simulating IO opperations of interacting server networks, in a pure setting, could be a very serious saving
20:06:43 <dmj`> nh2: so you had a dedicated build / deploy machine in the hetzner cloud that had the state file live?
20:08:00 <fog> the main difficulty is the slightly different build process when converting between emulated parallel containers in non-IO monadic lists - and then for deploying to a real containerised setting
20:08:43 <nh2> The main deployment doesn't use Hetzner Cloud (that's the name of their VM offering), just Hetzner dedicated servers. The Jenkins + deploy bastion machine is a dedi, and it has the state file on it
20:09:42 <nh2> fog: "without kuberneties how would you limit the amount of resource allocated to several simultaniously running haskell programs" <- systemd + the underlying cgroups (same kernel mechanism Docker / Kubernetes) use allow to do resource control
20:09:59 <ski> liiae : lots of things can be represented as functions, so that says very little
20:10:28 <fog> nh2: oh wow, so we actually have an avenue to replace kuberneties for haskell
20:10:41 <ski> liiae : one can argue that, even in dynamic languages, people have (some form of) types in their heads
20:10:55 <dmj`> nh2: ah ok I see, so its on the dedi CI, cool. Did successful builds of master auto deploy?
20:11:09 <fog> i remember looking into cgroups but i cant remember if i found an adiquate haskell lib
20:11:50 <fog> i think there was something that was OS dependent about it, and im not sure if there was an FFI issue
20:12:15 <nh2> fog: cgroups work for anything on Linux, not only Haskell (and I wasn't talking about a Haskell lib for them, I was just saying that where you might define resource limits in a Kubernetes config, you may also use the systemd config for the service to achieve very similar outcomes, as long as they are on the same machine)
20:12:37 <fog> im on windows, and there was some windows support which i think is quite recent
20:12:50 <fog> but thats the OS issue i was meaning
20:12:57 <nh2> dmj`: just for clarity on the VMs vs containers topic, the containers were faster on every axis except when the super-heavy fsync()s came into play.
20:13:47 <nh2> fog: cgroups are certainly a Linux-specific thing, I have no idea bout resource control on Windows, and no experience with Windows server deployments
20:13:59 <fog> nh2: yeah they will always be on the same machine, otherwise there is no "resource competition" issue, which i guess is the main kuberneties thing for actors based simulations
20:14:30 <fog> hmm, i guess running on linux isnt such a setback
20:14:39 <fog> especcially with WSL
20:15:08 <fog> though im not sure if thats a totally efficient setting for running performant simulations
20:15:47 <nh2> WSL is just Linux in a VM, so you can expect the performance of just that. Some things will be fast in it, others less so
20:15:58 <fog> not sure if also it could be worth considering AWS Lambda 
20:16:34 <fog> nh2: yeah, i mean, whats the deal with the llvm backend targeting multiple cores?
20:16:54 <fog> my graphics card isnt nvidia so i cant use Accelerate for that
20:18:06 <fog> but i think the OS threading might be enough to get at the multicore processors anyway, with accelerate really only being for parallelism within one program - not this kuberneties type thing where multiple threads should probably end up being shared over the cores by the OS
20:18:26 <nh2> dmj`: no, we considered auto-deploy, but decided against it, because human mistakes in configuration or newly-added features are the most common source of stuff breaking, so if we want to have a high-quality service, a human must always sanity-check the service after deployment anyway (and our product is a graphical 3D thing, very difficult to test fully automatically), so we might as well have them run a `./deploy` that 
20:18:26 <nh2> runs nixops and look at it while it's doing it.
20:19:08 <dmj`> that's cool, yea there is that --dry-run also
20:19:33 <dmj`> nh2: 4TB you probably never had to GC :)
20:20:15 <nh2> dmj`: I actually did a couple weeks ago, for the first time after 5 years
20:20:32 <dmj`> haha, how much was freed?
20:21:21 <nh2> dmj`: I think 1 TB, I kept everything younger than 1 or 2 years
20:22:51 <nh2> dmj`: I do think deploy-by-branch-push is great, and we've set it up successfully for many companies in my day job, especially for stateless services that are easier to test, but for the hard state stuff (Ceph, database, consensus servers), it's better to have a human eyeball the rolling deployment.
20:25:25 <nh2> dmj`: also, a big risk factor is some very commonly used OSS software just failing. For example, I found a bug in busybox's ext4 fsck (which is copy-pasted from some older ext4 version in the kernel), which led to servers not coming back from reboot. Similarly, I've found bugs in Consul, Ceph, glibc, and all kinds of things 
20:27:15 <nh2> because of this, I find human deployment being quite good, and if you've made it so fast that it takes only seconds, it doesn't take much more time than "git push" itself
20:28:08 <dmj`> nh2: it's amazing anything works, and to think how difficult it would be for someone to detect and fix that w/o nix. Much less make the fix and redeploy right there.
20:28:43 <dmj`> nh2: I'm surprised the deploy was that fast. But I suppose you had already built the machines w/ CI
20:30:09 <dmj`> nh2: did you deploy to all servers at once, or --include separately
20:33:13 <fog> considering how developed the haskell tooling is, its surprising more big banks arent on it 
20:34:35 <fog> i figure its cheaper for them to employ one dude pushing 60 that knows where all the mallocs are, than to streamline to a more efficient language
20:35:06 <fog> woe
20:37:51 <nh2> dmj`: yes, it's always built by CI before deploying, because CI must first show that the tests are green
20:38:40 <nh2> dmj`: the way I found many issues was to just, for any significant change, deploy 100 times in a loop to the VMs or to small AWS throwaway machines. That turns up bugs with higher probability
20:39:17 <nh2> dmj`: --include separately, for a rolling deploy. That's primitive, but works well enough (and one of the things where Kubernetes definitely does more than NixOps)
20:40:33 <nh2> but then again, for stateful services like a DB, the auto-rollback that Kubernetes can do may just not be safe, e.g. you may not be able to downgrade a major-version Postgres update, and you certainly cannot downgrade Consul. So that wouldn't be possible anyway
20:41:08 <nh2> infinisil: btw, I still owe you that t-shirt, I haven't forgotten that. You should tell me what should be on it and we'll get it done :D
20:44:01 <nh2> dmj`: I need to sleep now, it was fun discussing, have a good time!
21:16:24 <ddellacosta> why it's not your fault
21:16:31 <ddellacosta> d'oh, sorry
21:44:39 <caseof> Does something like this works? https://pastebin.com/JXgP5HYC
21:45:38 <caseof> Basically I'm trying to find a function that reads message from a list of TChan
21:56:11 <ja> would it be wrong to add Witherable to Typeclassopedia?
21:57:21 <fragamus_> do we have a library to read svg files
21:59:01 <ja> fragamus_: xml is tricky to parse if you want to parse every single thing
21:59:51 <ja> fragamus_: i think the usual approach is to go the other way, generate an AST and then serialize that to a subset of svg
22:00:21 <fragamus_> there is some content in a file that I need
22:00:51 <ja> fragamus_: if you can make some assumptions about the structure of the file, you could probably use any of the xml parsers
22:01:42 <ja> but they probably won't understand things like SVG definitions (making a names object that can be pasted multiple times over the canvas)
22:02:46 <ja> *named
22:03:06 <fragamus_> yeah 
22:05:26 <ja> fragamus_: did you see mkImage in reanimate? http://hackage.haskell.org/package/reanimate-0.3.3.0/docs/Reanimate.html#v:mkImage
22:06:01 <fragamus_> I'll take a look at that thanks!
22:06:06 <ja> i don't know how well it parses, i am not using that function
22:06:27 <ja> i wouldn't be surprised if it is missing a lot of stuff... since it is mainly focused at generating new animations
22:53:57 <dminuoso> 06:55:49          ja | would it be wrong to add Witherable to Typeclassopedia?
22:54:16 <dminuoso> I think it'd fit well in there
22:54:33 <dminuoso> Witherable is something I regularly sorely miss in base. :)
22:54:38 <kiwi_76> Ola  culiamos
22:54:51 <dminuoso> Once I've discovered it, it's surprising how much I started using it left and right.
22:55:07 <dminuoso> It's a rather common theme that I worked around earlier by roundtripping through lists with mapMaybe far too often.
22:55:29 <iqubic> what is Witherable?
22:56:16 <dminuoso> filterable traversables
22:56:28 <iqubic> Oh, I see. Sounds good.
22:56:48 <dminuoso> The signature method is `mapMaybe :: Witherable f => (a -> Maybe b) -> f a -> f b` where Traversable is a superclass of Witherable
22:57:08 <dminuoso> Err hold on sorry
22:57:36 <dminuoso> `wither :: (Witherable t, Applicative f) => (a -> f (Maybe b)) -> t a -> f (t b)`
22:57:44 <dminuoso> That's the signature method. I was miscopypasting.
22:58:00 <dminuoso> c.f.:
22:58:03 <dminuoso> % :t traverse
22:58:03 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:58:17 <koz_> Does it follow some laws?
22:58:20 <dminuoso> (So you while traversing you can decide to "drop" an element")
22:58:24 <dminuoso> Yes
22:58:32 <dminuoso> wither (fmap Just . f) ≡ traverse f
22:58:36 <dminuoso> Compose . fmap (wither f) . wither g ≡ wither (Compose . fmap (wither f) . g)
22:58:40 <dminuoso> t . wither f ≡ wither (t . f)
22:58:52 <dminuoso> (The last one is for free because parametricity)
22:59:11 <koz_> Hmm, interesting.
22:59:49 <dminuoso> Equivalently there's a Filterable class with equivalent lwas
23:00:55 <koz_> dminuoso: Is that from a different package?
23:01:06 <koz_> I know of Witherable, but not Filterable.
23:01:52 <dminuoso> https://hackage.haskell.org/package/witherable-0.3.5/docs/Data-Witherable.html#t:Filterable
23:02:11 <dminuoso> (Think of Witherable as Traversable with Filterable)
23:02:29 <koz_> Ah.
23:02:58 <koz_> The fusion law is cute.
23:03:21 <dminuoso> Do you mean `mapMaybe f . mapMaybe g ≡ mapMaybe (f <=< g)` ?
23:03:32 <koz_> Yep!
23:03:32 <dminuoso> I suppose that's what `Formally, the class Filterable represents a functor from Kleisli Maybe to Hask.` means
23:03:42 <koz_> Yeah, I don't know cat theory. :P
23:03:53 <koz_> (I tried learning it several times, and got nowhere each time)
23:04:50 <dminuoso> Im not quite sure what "Kleisli Maybe" means in this context.
23:05:03 <dminuoso> It
23:06:40 <koz_> I wonder if it has a RULE for that.
23:17:13 <Cale> dminuoso: So Kleisli Maybe is a Category instance, right?
23:18:36 <dminuoso> Cale: Oh.
23:18:48 <Cale> A functor from one category to another consists of a mapping on objects (which in this case is the identity, since these are categories on the collection of Haskell types), together with a mapping on arrows, which in this case will be mapMaybe
23:19:52 <Cale> oh, not the identity
23:19:56 <Cale> hah, it's f
23:20:38 <Cale> So, we're mapping a value of type Kleisli Maybe a b, that is a -> Maybe b to a value of type f a -> f b
23:21:18 <Cale> and then we have the conditions on a functor, that it (1) preserve identities, and (2) preserve compositions
23:21:56 <Cale> The identity arrows in a Kleisli category are provided by return for the corresponding monad
23:22:19 <Cale> So, mapMaybe return = id
23:23:08 <Cale> and then composition in the Kleisli category corresponds to the fish (<=<), so we should have
23:23:28 <Cale> mapMaybe (f <=< g) = mapMaybe f . mapMaybe g
23:23:46 <Cale> and they just write that one pretty much the same as I did
23:23:49 * hackage github-webhooks 0.15.0 - Aeson instances for GitHub Webhook payloads.  https://hackage.haskell.org/package/github-webhooks-0.15.0 (onrock_eng)
23:30:51 <jchia> Did anyone else notice that stackage.org is quite slow these days when querying resolver content? e.g. https://www.stackage.org/nightly
23:40:23 <liiae> can I think monad is about structure?
23:41:03 <liiae> cont lift a function into a Cont structure, runCont extract a function from a Cont structure?
23:41:07 <dminuoso> liiae: Monad is not about anything but its interface.
23:41:31 <koz_> And its laws.
23:41:54 <liiae> > let f = \k -> k 3; g = \kr -> \gkr -> gkr $ (+2) kr; z = runCont (cont f >>= cont . g) in z (+5)
23:41:57 <lambdabot>  10
23:42:36 <liiae> dminuoso: I don't understand this (cont f >>= cont .g) shouldn't be cont $ \x -> x 10?
23:42:56 <dminuoso> I do not understand the question.
23:43:13 <liiae> cont f >>= cont . g :: m b, right?
23:43:25 <dminuoso> Cale: Yeah that makes sense. I sometimes have trouble with these "from sub-hask to hask" functors, especially since I tend to expect functors to go between very different categories.
23:54:19 * hackage tasty-expected-failure 0.12 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.12 (JoachimBreitner)
