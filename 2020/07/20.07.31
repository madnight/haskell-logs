00:06:05 <hyiltiz> haskell.love is now live on https://www.twitch.tv/konfycare
00:18:52 <Taneb> (haskell.love has two rooms, the other is at https://www.twitch.tv/konfycare2 )
00:20:10 <Taneb> (first one is a talk about lens, second about graphql)
00:20:19 <Uniaika> hurray
00:35:41 <Viraxor> https://discord.gg/sKNdFhj
01:42:57 <typetetris> With Hspec, trying to use `beforeAll_` I get weird errors about `Spec` not the same as `SpecWith (Arg a)`.
01:57:08 <sshine> typetetris, Spec = SpecWith (). beforeAll_ :: IO () -> SpecWith a -> SpecWith a. so perhaps the second thing you feed beforeAll_ isn't a Spec?
01:58:12 <sshine> typetetris, if you drop some code in a pastebin maybe it will be more clear.
02:03:24 <typetetris> I essentially have `hspec $ beforeAll_ someAction $ describe "text" $ it "text" $ liftIO $ putStrLn "Hello World!"`
02:06:50 <typetetris> seems like `liftIO` didn't specify the type of the action enough, adding a ` shouldBe 1 1 ` solved it.
02:10:54 <sshine> ooh, nice.
02:18:32 <typetetris> How to specify a build-tool-depends in a cabal file, which isn't a haskell binary but a sytem binary?
02:52:49 <dhananjay> I am trying to write an Arbitrary instance like instance Arbitrary FancyText where arb = FancyText <$> arbitrary. 
02:53:17 <dhananjay> but I want to limit them to only generarte non-empty text
02:54:09 <dhananjay> how can I do that? is there something like NonEmptyList that I can use here?
02:55:30 <edwardk> the haskell.love talks are great, i just wish i'd managed my energy level better, didn't plan on attending talks at 3am =)
03:08:56 <kuribas> dhananjay: Data.List.NonEmpty?
03:10:26 <jil> hello
03:11:00 <jil> How can I get the ghc 3.8.5 for deb10 ?
03:11:36 <jil> Sorry I mean 8.6.5
03:13:56 <aldum> ghcup?
03:15:06 <dhananjay> kuribas: Test.QuickCheck.Modifiers.NonEmptyList
03:15:46 <fog> i have a tree where each of the branches has a lens/lookup over a tuple
03:15:57 <fog> its supposed to be a cyclic graph
03:16:16 <fog> the tuples are "shared" among several branches. 
03:16:42 <fog> which is supposed to be like a node, with several branches leading *into* it
03:17:16 <fog> but where i can direct different data up each of these branches, by placing it in a different part of the tuple
03:17:37 <fog> having calculated this tuple based on each of the input edges leading into the branch node from below
03:17:53 <fog> but i dont know how i can represent this as a GADT
03:18:40 <fog> i can have downwards forking branches easily in a tree, where each node has branches as a list of trees 
03:19:33 <fog> but these lenses looking up over the tuples of nodes below, as forking *upwards* i cant seem to represent 
03:20:52 <MarcelineVQ> Only you in the entire world knows what forking upwards means
03:20:53 <fog> then, i seem to need another lens, and a thing to lookup over, that is all of the available nodes below some depth - assuming there is some kind of partial order or lemilattice
03:21:12 <MarcelineVQ> So you'll want to explain terms like that when you use them
03:21:15 <fog> MarcelineVQ: i just explained it!
03:23:21 <fog> normally, the haskell "environment" means i get to ignore the issue. i can use let bound variables to construct the cyclic tree, with *several references to the same variable* being the same thing as "forking upwards" - to explain it by analogy 
03:23:45 <jil> aldum, I though about ghcup but since the ghc version I want is not listed in  downloads.haskell.org/~ghc I'm not sure it will be helpfull
03:24:39 <fog> which is why i think i need this lensing, to resolve it in from within "the environment that is in scope" at each stage/per node
03:25:04 <fog> i can have an edge to any node below
03:25:38 <fog> it is the fact that several upper nodes can refer to the same node below, that gives rise to the "forking upwards" idea
03:26:26 <MarcelineVQ> That particular last line conveys the idea well to me
03:27:11 <fog> basically, its thought of as a dataflow processing situation, where, folding up the branches (thinking of a function at each node - taking all of the edges that fork downwards, from the nodes below, as arguments to this function - and returning a tuple, that can be lensed over by the edges leading out from this node upwards) 
03:27:19 <MarcelineVQ> But you'd be right in that we're now more of a graph than a tree when that is allowed
03:27:36 <fog> yeah, i cant seem to do it with a GADT
03:27:49 <jil> ho well ghcup is downloading the ghc 3.6.5 for deb9 while Im' using deb10.  I guess it should work
03:28:07 <fog> but i thought that maybe by keeping track of the "scope" that i could do it that way
03:28:09 <MarcelineVQ> Have you looked into fgl the library? its approach to functional graphs is pretty interesting
03:28:29 <fog> i saw that approach, and the version using algebraic graphs
03:28:59 <fog> i thought it uses Data.Map
03:29:07 <MarcelineVQ> IntMap in the case of fgl ye
03:29:19 <fog> "An efficient implementation of Graph using big-endian patricia tree (i.e. Data.IntMap)."
03:29:25 <MarcelineVQ> But that's just an implementation detail, the api is something else
03:29:27 <fog> from;
03:29:28 <fog> https://hackage.haskell.org/package/fgl-5.7.0.2/docs/Data-Graph-Inductive-PatriciaTree.html
03:29:38 <fog> im concerned with the implementation
03:29:47 <fog> i have a Tree, that is a Free []
03:30:06 <MarcelineVQ> That's the interesting part in fact, that an inductive-looking graph with inductive-style algorithms can be created with something different behind it
03:30:18 <fog> https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e#file-pair-hs-L130
03:30:23 <fog> thats the problem^
03:30:33 <MarcelineVQ> So if implementation interests you it's a good candidate to examine closesly
03:30:33 <fog> its "hetrogenous free"
03:30:57 <fog> but i need type hetroginaity
03:31:07 <fog> so i was using HFree
03:31:15 <fog> which is fine for making a regulat HTree
03:31:19 <fog> regular*
03:31:36 <fog> which i have here; https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e#file-pair-hs-L136
03:32:22 <fog> (it kind of, uses To to generate the Hetrogenous version of [], which is passed in as a "label")
03:32:42 <fog> ie [] is the label specifying HList
03:33:20 <fog> i *guess* i could use HIntMap to make a HGraph...
03:33:35 <fog> but then all the HFree machinery is not useful
03:34:21 <fog> i thought if instead, i could limit the environment that the branches could be drawn from, and have the new nodes added to the environment as a lattice
03:35:07 <fog> i dont need to work with hetrogenous data for now, but since thats the overall goal... just showing why fgl isnt immediately applicable
03:36:16 <fog> the entire aim is to have a version of graphs which is written using a GADT and a scoped environment as a lattice - but i cant reconcile those concepts
03:52:13 <fog> hmm, i guess it does seem like IntMap
03:52:37 <fog> where then "lensing" over the growing environment is done using an Int lookup
03:53:11 <fog> but i still cant understand how to propegate the environment through the tree
03:53:39 <fog> and have each layer have its datatype somehow parametrised over by what branches are available for it to contain 
03:59:59 <fog> I can write something like this;
04:00:00 <fog> https://pastebin.com/raw/UVXHvTz8
04:00:23 <fog> where maybe open data families can be used for the environment scope
04:00:48 <fog> but that seems to make haskell modules per graph...
04:02:36 <fog> and in not sure how that would work
04:03:08 <fog> actually... the regular Tree seems to work fine. the problem is just about multiple references to the same node
04:03:31 <fog> like, you can do that with a regular tree, i just dont think you get type information to keep track of that
04:04:36 <fog> maybe i could have every tree that exists have a Symbol, to name it like a variable
04:04:50 <fog> and have some way of making sure there are no repeated names
04:06:39 <fog> you wouldnt need to "lookup" the tree, in the list of branches, by its name. you just have it stored as a list of trees in the GADT as usual, but because there can be no repeated names, it would enforce the node sharing in descendants 
04:07:21 <fog> and you could have operations over the tree that could detect where names were mentioned in different places
04:07:32 <fog> ie, you could "detect the cycles"
04:07:44 <fog> which is the problem with the regular GADT approach 
04:08:01 <fog> using let bound variables as the branches
04:08:47 <fog> the only thing i can think of in haskell that would get the typechecker to complain about duplicate names would be OverlappingInstances
04:09:49 <fog> which would be a class, i guess, which just resolved the name to the tree it refers to 
04:11:21 <fog> then i guess you could do things with having the HList for each of the branches have type level constraints over the names 
04:11:56 <fog> eg. "every layer of branches must have the first edge referring to the top of the tree"
04:21:36 * [exa] thinks about backreferences in the context in functional data structures
04:46:11 <fog> here something like this; https://pastebin.com/raw/s2U3Csui
04:46:23 <fog> [exa]: whats backreferences in the context in functional data structures?
04:46:43 <fog> oh i forgot to do the OverlappingInstances thing...
04:51:21 <fog> here, like this; https://pastebin.com/raw/FuJxGJQ8
04:54:02 <fog> now i should be able to "fold up the branches" by storing a function that takes all the branches as an input
04:54:11 <fog> and then, i dont just need to have it produce one output
04:54:18 <fog> i can have it produce a HList of outputs
04:54:31 <fog> and have the nodes above it lens into particular positions of this
04:55:12 <fog> but i would probably need another uniqueness mechanism to ensure the edges are not able to refer to the same part of the output tuple at each node
04:56:59 <fog> there would have to be soem type safety then, that the tree stored at a branch, not just having its name, but also the lookup over which of the output edges of this node, and that these are in bounds, like i cant say, "at this branch is tree called x, and we want its nth output edge"
04:57:10 <fog> if n is out of bounds wrt x
05:03:28 <fog> [exa] backtracking is with shift/reset right? is it some kind of type level continuation?
05:19:26 <[exa]> fog: why backtracing?
05:19:35 <[exa]> *backtracking
05:19:56 <[exa]> anyway, you can backtrack with anything you like, even with lists
05:37:53 <charms> hi, when I try to compile haskell ide engine with stack -j 24 ./install.hs hie-8.8.3 it goes really fast then slows to a crawl. my ram usage also remains constant (about 14.5gb/16gb) so I think WSL may have allocated as much as possible. is this normal?
05:38:23 <charms> when i don't do -j 24 it doesn't run out of ram but i would like to use all my threads
05:38:38 <charms> do i need to buy more ram or am i doing something wrong?
05:39:41 <[exa]> charms: 14.5/16 is "full", did you check your swap usage?
05:39:44 <merijn> charms: Eh, -j 24 will end up running 24 separate GHC compilation processes and GHC is quite memory hungry
05:40:07 <merijn> charms: With 16 GB you *definitely* don't have the RAM needed to run 24 parallel instances of GHC :)
05:40:14 <charms> is 32gb enough?
05:40:21 <charms> my motherboard mini itx maxes out at that
05:41:15 <sureyeaah> charms: any reason why you wouldn't want to use the pre built haskell-language-server binaries btw?
05:41:18 <merijn> with 32GB I'd say you can do *maybe* 16 instances and even that's probably not worth it, 8-10 seems more reasonable
05:43:06 <[exa]> charms: why hurry though? :D
05:44:31 <charms> this is really odd but the weather
05:44:47 <charms> i'll use the prebuilt binaries thanks sureyeaah i didn't think of that
05:45:05 <charms> i'll get some more RAM and just use 12 threads, one per core thanks
05:45:35 <charms> bye guys!
05:52:14 <[exa]> how long does hie take to build btw?
05:52:46 <kuribas> Is there a flipped foldmap?
05:52:51 <kuribas> or operator?
05:53:01 <kuribas> :t foldMap
05:53:02 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:53:15 <kuribas> @hoogle (Foldable t, Monoid m) => t a -> (a -> m) -> m
05:53:16 <lambdabot> Prelude foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:53:16 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:53:16 <lambdabot> Test.Hspec.Discover foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:57:06 <merijn> kuribas: "flip foldMap"? :p
05:59:57 <kuribas> merijn: I made an operator @?
06:00:31 <kuribas> since I am mostly using it with records fields which can be a Maybe 
06:01:57 <kuribas> or maybe I should name it .? ...
06:02:29 <fendor_> [exa], long
06:03:16 <[exa]> fendor_: with my post-gentoo-syndrome, a bit of compilation doesn't scare me!
06:03:24 <[exa]> like a week?
06:03:27 <fendor_> no :)
06:03:38 <fendor_> but like up to an hour if your cache is cold
06:04:00 <fendor_> but since hie uses like half of hackage, I do not expect that you have a cold cache
06:04:11 <fendor_> hie itself takes like less thn five minutes, I would say
06:04:21 <fendor_> or about five minutes. 
06:04:35 <[exa]> that's not much
06:04:36 <fendor_> but I would recommend hls over hie
06:04:58 <[exa]> I'm not going to use an ide anytime soon tbh, just curious :]
06:05:02 <fendor_> it is for most users not used to it. Also, older installation methods were like: install hie for every stack version that is supported
06:05:09 <fendor_> that can easily take 3 hours
06:05:13 <[exa]> lol
06:05:17 <fendor_> *stack ghc version
06:20:52 <thblt> nix users: is there a way to create a GC root with ghc, stdenv, and the like, so stack doesn't have to re-download everything all the time?
06:24:39 <merijn> thblt: It should only download things if you switch to a different snapshot
06:27:30 <thblt> merijn: my understanding is that nix garbage collection will remove everything since `stack` isn't a permanent root.
06:27:51 <thblt> And I have enabled automatic garbage collection.
06:28:48 <merijn> Oh, wait, I missed the Nix bit
06:40:35 <fendor_> I think the only thing that gets removed is ghc, not the pacakges built by stack
06:41:07 <frdg> is there a way to search a library by type signature from either ghci or haskell-mode in emacs?
06:41:34 <merijn> frdg: You can have a local Hoogle and presumably someone has made emacs support for that
06:43:04 <thblt> fendor_: yes of course, but the GHC download is big.  I have pretty fast internet at home so it's not a big deal, but it may be in other locations.
06:44:15 <frdg> merijn: ok thanks
06:44:16 <ezzieyguywuf> fendor_: another gentooligan?! welcome!
06:45:20 <fendor_> ezzieyguywuf, no no, fake news! I am a nixos user ;D 
06:46:38 <ezzieyguywuf> womp womp
06:47:03 <ezzieyguywuf> how do I use stack to install, say, hoogle 'globally' (i.e. I guess in ~/.local/bin) rather than project-specific?
06:47:14 <ezzieyguywuf> or do I just used cabal directly for that?
06:49:27 <fog> [exa] oh sorry, you said backreferencing, i thought backtracking
06:49:34 <fog> whats backreferencing?
06:50:01 <frdg> when using cabal-install what does `(all, legacy fallback)` mean? `Completed    asn1-parse-0.9.5 (all, legacy fallback)`
06:54:32 <phadej> frdg: it emans that ans1-parse either has old `cabal-version: ...` or it uses `build-type: Custom`
06:55:17 <phadej> shortly, cabal have to configure (and build) the whole package
06:55:35 <phadej> when package has 20 executables, this is bad
06:56:00 <phadej> that's why some packages have (still) flags to disable executable building.
06:56:17 <phadej> they don't need to, cabal-install is smart enough
06:58:34 <frdg> phadej: is all of this information in the cabal user guide, or is there a more in depth manual?
06:59:15 <phadej> unfortunately, I think this bit is missing
07:00:31 <frdg> I was just making sure there wasnt another manual I was missing because you people know a lot of information about cabal that I can't find in the user guide
07:02:19 <kuribas> is there a way to do a foldMap over a Foldable, then check if the result is empty?
07:02:22 <kuribas> maybe a newtype?
07:03:43 <sm[m]> ezzieyguywuf: cd; stack install hoogle-LATESTVER
07:04:29 <sm[m]> g’day all
07:06:46 <phadej> pull requests to improve cabal's users guide are most welcome ones
07:06:58 <thblt> kuribas: empty = mzero?
07:07:31 <kuribas> thblt: this monoid has no Eq instance
07:07:41 <kuribas> hmm, I can use First.
07:07:46 <sm[m]> phadej: what about the website :)
07:07:48 <kuribas> I only case about the first result anyway
07:08:08 <phadej> sm[m]: I cannot comment about website, I'm not touching it :)
07:08:39 <thblt> (Sorry I meant mempty.)
07:08:54 <sm[m]> update on my journey FYI: tibbe doesn’t remember creating the repo and doesn’t haskell any more, he directed me to some team which looks like you and hvr
07:09:12 <sm[m]> so I guess I’m off to see hvr next
07:09:32 <merijn> sm[m]: You're off to see the wizard? ;)
07:10:04 <sm[m]> I literally feel like I’m in Oz
07:11:03 <sm[m]> hvr you’re not here are you ?
07:12:49 <sm[m]> reminder: https://haskell.love day 1 is in progress
07:13:26 <solonarv> kuribas: if you just want to check whether the Foldable contains any elements, 'null' works
07:13:29 <solonarv> : tnull
07:13:31 <solonarv> :t null
07:13:32 <lambdabot> Foldable t => t a -> Bool
07:13:41 <kuribas> ah neat
07:13:50 <kuribas> I had now: foldr (\v _acc -> f v) unbound x
07:14:03 <kuribas> but null is clearer
07:14:39 <solonarv> null = getAny . foldMap (\_ -> Any True) -- it's just a foldMap
07:16:55 <kuribas> :t foldr (const (const True)) False
07:16:56 <lambdabot> Foldable t => t b -> Bool
07:18:06 <thblt> kuribas: I may have misunderstood. You're just trying to determine if that Foldable is empty?
07:18:16 <kuribas> thblt: no
07:18:38 <kuribas> if it's empty, I return "unbound", otherwise I apply the function
07:42:28 <ezzieyguywuf> 😍 i installed hoogle locally
07:42:54 <ezzieyguywuf> sm[m]: `cd` is critical in that step I believe. I didn't do "-LATESTVER" though, is that a bd?
07:43:45 <sm[m]> ezzieyguywuf: it’s often not necessary but without it there’s a chance you could get an older version
07:44:33 <sm[m]> hoogle —version will tell you
07:44:48 <ezzieyguywuf> 5.0.17.15
07:45:09 <sm[m]> and then you check the latest on hackage
07:45:54 <sm[m]> close enough maybe
07:48:08 <ezzieyguywuf> good enough for government work
07:48:14 <ezzieyguywuf> can I make my hoogle print out documentation?
07:48:29 <ezzieyguywuf> i.e. if I want to see the documentation for readTVarIO
07:49:03 <ezzieyguywuf> hrm, --help does not list all the flags
07:53:53 <fog> is there any way to have a value that is impossible to reuse?
07:54:17 <fog> or is that prohibited by a "functional" language - by violating equational reasoning?
07:54:46 <fog> and if so, how can i encode edges in a tree that are not reused?
07:55:31 <fog> the way i have a graph is just to have a tree, where some upper part of the tree can appear in a subtree as a value
07:55:43 <fog> but then i cant limit the number of times it can appear...
07:57:12 <fog> i have a HList of outputs, like a tuple, and i want each output (of a function over the input edges at each node where the tree branches) 
07:57:27 <fog> to be used by exactly one of the upper nodes
07:57:35 <__monty__> fog: Sounds like linear types.
07:57:41 <fog> oooh whats that
08:05:45 <fog> here is a picture of what i mean;
08:05:46 <fog> https://pasteboard.co/JkdeOS2.png
08:06:18 <fog> thats supposed to be a node in a graph
08:07:05 <fog> with a function on the input edges returning a tuple of outputs, that are the input edges to the nodes above
08:07:30 <fog> heres the code i have so far;
08:07:30 <fog> https://pastebin.com/raw/FuJxGJQ8
08:12:39 <ezzieyguywuf> 😍 hlint is so neat
08:19:15 <sm[m]> ezzieyguywuf: agreed !
08:19:39 <sm[m]> along those lines, so is shellcheck
08:20:09 <ezzieyguywuf> I'll have to check it out
08:20:15 <ezzieyguywuf> I like how hlint is helpful and pretty, lol colors
08:20:30 <merijn> I find too many of hlint's opinions to be fairly questionable, personally
08:20:44 <merijn> ezzieyguywuf: shellcheck is basically a bash/posix shell linter written in Haskell, it's pretty cool
08:21:09 <c_wraith> sometimes I case on a Bool instead of using if/then/else because it's better in that context, hlint!
08:22:09 <merijn> I'd argue more extremely that if/then/else is always an anti-pattern that should be either a guard of a case-of :p
08:23:25 <ezzieyguywuf> i was just pondering this very issue
08:23:51 <alehander92> ohh
08:23:54 <ezzieyguywuf> started with a case (after spending minutes considering if this was an 'anti-pattern'), switched to an if-then-else per hlints suggestion, but still not sure if I'm happy
08:24:01 <alehander92> so hlint might be nice
08:24:22 <ezzieyguywuf> s/might/is/
08:24:45 <merijn> ezzieyguywuf: hlint is extremely opinionated, following its authors opinions, you should feel free to ignore/disable recommendations you find stupid
08:25:55 <ezzieyguywuf> merijn: absolutely. but I find it helpful as a new user of haskell and FP in general to read through some more experienced programmers' opinions
08:26:02 <c_wraith> if/then/else is nice for small lambdas.  But that's the only place where I don't feel bad about using it.
08:26:04 <alehander92> is there something more like a formatter
08:26:11 <ezzieyguywuf> this type of thing is inherently opinionated though
08:26:12 <alehander92> e.g. for indentation / spacing
08:26:22 <ezzieyguywuf> alehander92: yes.
08:26:35 <alehander92> how is it called?
08:26:38 <ezzieyguywuf> it has a name like a whale  Ithink..
08:26:44 <ezzieyguywuf> orca, orka, orcu...
08:26:50 <ezzieyguywuf> lol, ormolu
08:27:01 <merijn> alehander92: There's tons of them, tbh
08:27:12 <thblt> Is Ormolu a whale?
08:27:39 <thblt> Ho it's a gilding technique https://en.wikipedia.org/wiki/Ormolu
08:28:05 <ezzieyguywuf> sounds like a whale to me
08:30:12 <thblt> According to wikipedia it comes from the French “or moulu”, litt. ground gold (adj, as in “to grind”, not from the ground)
08:32:23 <ezzieyguywuf> Oui, l'or moulu c'est tres delicieuse
08:32:49 <alehander92> thanks ezzieyguywuf  ,!
08:33:03 <alehander92> i really have to name my haskell libs on bulgarian words
08:33:26 <alehander92> that would bring some cool new vocabulary
08:44:22 <reactormonk> Can I poke hedgehog to give me the actual exception when it's failing a property?
08:44:35 <sm[m]> hlint isn’t “hlint’s default recommendations” remember.. I often see the two treated as one
10:00:04 <johnnyboy[m]> I'm using Data.Vector. Unboxed to represent base-n numbers. What would be a good way to generate first k vectors?
10:01:13 <johnnyboy[m]> I think I can do it for lists by repeating a simple increment function
10:01:34 <johnnyboy[m]> would it be a good idea to produce a list of lists and map it into a list of vectors?
10:10:16 <isovector1> is there a quickcheck combinator like `within`, but which discards slow tests rather than failing them?
10:18:23 <sm[m]> success: https://haskell.org/cabal links all now lead to the up to date stable cabal docs (actually, 3.4 because 3.2 weren't good, but in future it should be the current release). Thanks phadej & co for your help
10:21:45 <johnnyboy[m]> I guess implementing Enum would be one option
10:27:10 <dsal> An Enum instance sounds like the question you're asking.  :)
10:31:46 <johnnyboy[m]> the only problem is that I don't want a vector of all numbers, but a list (or vector) of all vectors representing numbers
10:33:54 <dsal> Enum just knows how to get the next value from a given value.
10:34:40 <dsal> (well, and the previous)
10:35:25 <dsal> I guess the Int conversions are also interesting.
10:36:09 <dsal> In any case, it's not expected you produce all possible values up front.  unbounded enums don't do that.
10:38:08 <johnnyboy[m]> oh, right
10:38:16 <johnnyboy[m]> I meant "all numbers up to n"
10:38:33 <johnnyboy[m]> i mean k
10:41:19 <isovector1> phadej: got a sec? i'm a bit confused by some quickcheck internals
11:08:21 <maerwald> sm[m]: nice
11:17:00 <sm[m]> "Idk I think the haskell elephant in the room is the poor beginner and intermediate resources,poor tooling,lack of libraries and poor documentation but maybe that's just me" - ouch :)
11:21:59 <maerwald> elephants are extremely smart and socialable ppl, not something I can say about the discussion >:)
11:23:51 <sm[m]> it seems pretty civilized, from what I hear of cryptocurrency communities..
11:23:58 <maerwald> haha
11:24:29 * sm[m] just read the entire reddit & HN threads & is still in one piece
11:25:05 <sm[m]> except for that one rude person I quoted above, obviously
11:25:28 <maerwald> they might be the only person speaking the truth :p
11:26:50 <koala_man> Any ideas what kind of documentation they're talking about? I've found the Haskell API docs to be excellent, unlike e.g. the Python API docs
11:27:15 <maerwald> what?? Python API docs are excellent
11:27:52 <sm[m]> (of course they're being unfair too.. but at least they're not calling out people for collaborating with the evil haskell IDE projects)
11:28:17 <koala_man> They have a strong tendency to only describe the happy case, and don't mention any edge cases, specific semantics, runtime complexities, etc that are the main reason why I read API docs to begin with
11:29:28 <maerwald> koala_man: most IO-heavy functions I read in haskell are also only documented wrt happy case... I have to run it against odd input to figure out the exception types
11:29:30 <sm[m]> koala_man: I think it's the big picture. There are too many docs and websites, most of them are out of date, there are divisions over which tools to recommend, usability and user experience isn't prioritised, etc.
11:29:34 <monochrom> "lack of libraries" is false.
11:29:42 <sm[m]> agreed
11:30:16 <monochrom> "no longer batteries included" is true but "batteries included" is a yesteryear attitude.
11:30:32 <monochrom> Even the python people no longer believe in it.
11:30:45 <sm[m]> lack of really good usable libraries could be true. Always room for improvement!
11:31:50 <maerwald> sm[m]: yes... here's a simple one... create a very long filepath, run `cabal sidst` and examine the result
11:32:19 <maerwald> then go to the haskell/tar issue tracker and get a heart attack
11:35:07 <maerwald> and no one seems to be bohtered of the state of that library and that it's used by cabal
11:35:48 <sm[m]> koala_man: perhaps each of the comment's points are false, and what they are really feeling is a 1. lack of curation 2. user experience not prioritised 3. complexity and holes in our tools
11:38:58 <ezzieyguywuf> I'm trying to refactor the logic in this function to be a bit more readable. Here's what I got, but I don't think it is much better. Do you all have any suggestions? https://gitlab.com/ezzieyguywuf/mycad/-/compare/37958f...b2420f#1d5db57cb7498781601ad36d9d50f88315be8368_53_53
11:39:20 <Cheery> yes, and I haven't even opened the link yet
11:39:35 <ezzieyguywuf> Cheery: lol great, I'm all ears
11:41:21 <Cheery> I abandoned Haskell long while ago and then got back to it because of curry howard correspondence
11:41:40 <Cheery> it's a big deal that language corresponds to logic.
11:41:43 <marked> Hello, I am learning haskell and I found strange bug. It is about higher order functions and partial application. Example: applyTwice f x = f (f x)  and then calling applyTwice (3+) 1, applyTwice (+3) 1, applyTwice (3-) 1 works but not applyTwice (-3) 1
11:41:49 <marked> I don't get it.
11:42:37 <Cheery> marked: that's syntactic quirk
11:42:42 <Cheery> :t (-3)
11:42:42 <ezzieyguywuf> :t (-3)
11:42:43 <lambdabot> Num a => a
11:42:43 <lambdabot> Num a => a
11:42:48 <ezzieyguywuf> :t (3-)
11:42:49 <lambdabot> Num a => a -> a
11:43:10 <ezzieyguywuf> :t (`-`) 3
11:43:12 <lambdabot> error: parse error on input ‘-’
11:43:13 <ezzieyguywuf> dang
11:43:19 <Cheery> :t (-) 3
11:43:20 <lambdabot> Num a => a -> a
11:43:21 <marked> Why is -3 a number but not partialy applied function?
11:43:25 <Cheery> :t negate
11:43:27 <lambdabot> Num a => a -> a
11:43:28 <hyperisco> :t (+ -3)
11:43:29 <lambdabot> error:
11:43:29 <lambdabot>     The operator ‘+’ [infixl 6] of a section
11:43:29 <lambdabot>         must have lower precedence than that of the operand,
11:43:31 <ezzieyguywuf> :t -3
11:43:32 <lambdabot> Num a => a
11:43:36 <hyperisco> fascinating
11:43:43 <hyperisco> :t (+ (-3))
11:43:45 <lambdabot> Num a => a -> a
11:44:17 <Cheery> marked: it's ambiguous, and ambiguity is resolved in certain way.
11:45:42 <Cheery> > (\f, x -> f (f x)) (+3) 1
11:45:44 <lambdabot>  <hint>:1:4: error: parse error on input ‘,’
11:46:11 <marked> Hmmm... If it was partially applied function then problem would just move somewhere else right? Then we would be missing negative numbers and 0 - 3 would be mandatory right?
11:46:50 <Cheery> > (\f x -> f (f x)) (\a -> a-3) 7
11:46:50 <monochrom> That's right.
11:46:52 <lambdabot>  1
11:47:13 <monochrom> SML's take on this is ~3 for negative three.
11:47:51 <solonarv> if you want (\x -> x - 3) you can write (subtract 3)
11:48:03 <monochrom> Haskell people decided not to do that. Instead, (-3) is still negative three. For (\x -> x - 3), use "subtract 3".
11:48:17 <marked> Oh... that was question I would like to ask.. 
11:49:20 <marked> Hmm... thank you guyz.. Is there any document with all quirks?
11:49:44 <monochrom> No. But there are documents for systematic learning.
11:50:01 <marked> I have found also .. in ranges as problematic without spaces. Or with I cannot remember.
11:50:16 <solonarv> sometimes you need spaces, yes
11:50:44 <marked> Cool thank you all for help :)
11:55:09 <Cheery> ezzieyguywuf: Am looking at this text. so this program  is exactly doing what?
11:55:45 <Cheery> TMVar (Entity p) -> HL.InputT IO ()
11:57:03 <Cheery> that result seems like a monad transformer
11:57:17 <marked> Hmm.. and what about applyTwice (:[]) 1 ??  It is supposed to be 1:(1:[]) which is 1:1:[] 
11:57:44 <monochrom> yes except type error.
11:57:51 <Cheery> incorrect
11:57:54 <monochrom> err no
11:58:26 <Cheery> :t (\f x -> f (f x)) (:[]) 1
11:58:28 <lambdabot> error:
11:58:28 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ [t]
11:58:28 <lambdabot>       Expected type: t -> t
11:58:32 <monochrom> (1:[]):[]  if in dynamically typed language
11:58:53 <Cheery> :t (:[])
11:58:54 <lambdabot> a -> [a]
11:59:10 <Cheery> :t (\f x -> f (f x))
11:59:12 <lambdabot> (t -> t) -> t -> t
11:59:14 <marked> How can I be so blind.
11:59:25 <Cheery> :t (\f x -> f (f x)) (:[])
11:59:26 <lambdabot> error:
11:59:26 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ [t]
11:59:26 <lambdabot>       Expected type: t -> t
12:00:12 <marked> My mistake... sorry.. That was dumb question :D
12:00:14 <Cheery> (a -> [a]) tries to be (t -> t)
12:00:44 <ezzieyguywuf> Cheery: the part in questing uses haskeline's getInputLine to get input from the user. If "Nothing" is returned, it should exit the program, otherwise, "Just str" is next passed to a parser with returns "Either Error Command". The only time this step should quit the program is if "Command == Quit", otherwise it should keep looping
12:01:18 <ezzieyguywuf> Cheery: I've been staring at this for hours trying to figure out a way to disentangle all the logic and make it more clear what is happening where, but I think I'm having trouble seeing the trees for the forest
12:01:42 <ezzieyguywuf> Perhaps my issue stems from mixing Maybe with Either
12:01:53 <Cheery> abstract syntax forest
12:02:45 <hyperisco> :t Forest
12:02:46 <lambdabot> error:
12:02:46 <lambdabot>     • Data constructor not in scope: Forest
12:02:46 <lambdabot>     • Perhaps you meant one of these:
12:02:57 <monochrom> "Forest" is a type alias.
12:03:08 <hyperisco> ghci will lie about it
12:03:11 <monochrom> so no corresponding data constructor
12:03:17 <hyperisco> :k Forest
12:03:19 <lambdabot> * -> *
12:03:33 <monochrom> That is not a lie.
12:03:38 <hyperisco> sure it is
12:03:45 <monochrom> OK, how?
12:03:52 <hyperisco> also does it stop caring about :t or :k once you have TypeInType? :)
12:04:23 <Cheery> ezzieyguywuf: I didn't see the whole program.. that loop seems clean.
12:04:52 <ezzieyguywuf> Cheery: I was asking specifically about the loop, thanks for taking a look.
12:05:02 <hyperisco> monochrom, because of the inference rule for application
12:05:05 <ezzieyguywuf> Cheery: do you mean it seems clean before or after the changes? i.e. with the nested case or without?
12:05:21 <monochrom> Perhaps sometimes when you get to 4th level of indentation you just feel that it's unclear.
12:06:00 <hyperisco> monochrom, if I have  T :: (* -> *) -> *  for example then  T Forest :: *
12:06:14 <Cheery> https://gitlab.com/ezzieyguywuf/mycad/-/blob/b2420f6867e103fe972fedd67b5c793ada3aed31/MyCAD/app/TUI/LaunchTUI.hs
12:07:09 <ezzieyguywuf> Cheery: 👍 thanks again for taking a loog.
12:07:11 <ezzieyguywuf> *look
12:08:13 <Cheery> what do you call an Entity?
12:08:27 <Cheery> lets see if I can find out
12:09:08 <Cheery> https://gitlab.com/ezzieyguywuf/mycad/-/blob/b2420f6867e103fe972fedd67b5c793ada3aed31/Entity/src/Entity.hs
12:09:39 <ezzieyguywuf> Cheery: yes, that is an Entity.
12:11:27 <Cheery> are all entities valid?
12:12:12 <ezzieyguywuf> I'm thinking of changing `handleError` and `handleCommand` to return a `Bool`, and then using that to figure out whether or not to keep looping. This still seems non-ideal, as there is already a check beforehand based on the output of getInputLine
12:12:29 <ezzieyguywuf> Cheery: yes, all entities are valid
12:13:24 <ezzieyguywuf> the plus-side of making that change to handleError and handleCommand is I could take out the `TMVar` from their type signatures, as it's only needed in order to loop again
12:15:26 <Cheery> I read the types first.
12:37:50 <ezzieyguywuf> Cheery: I was able to clean it up some more. I think I was trying to do too much in the monad, that's probably why I was getting so confused. https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/MyCAD/app/TUI/LaunchTUI.hs#L52
12:38:46 <Cheery> ezzieyguywuf: yup, looks cleaner
12:38:49 <ezzieyguywuf> I ended up with an if-then-else, but I learned that using a `when` to loop merely defers any subsequent lines rather than skipping them altogether
12:38:56 <ezzieyguywuf> I'm so proud of me! lol
12:42:37 --- mode: ChanServ set +o glguy
12:42:38 --- mode: glguy set -bbbb *!*@2001:999:12:56c2:49bb:6018:e19d:cad3 *!*@2001:999:70:d03b:4166:a154:1f23:706b *!*@2001:999:70:d03b:a502:81d8:f405:b8df *!*@38.132.120.71
12:42:38 --- mode: glguy set -bbbb *!*@cpe-24-211-225-57.nc.res.rr.com *!*@gateway/web/cgi-irc/kiwiirc.com/ip.109.123.74.179 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.178.62.200.75 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.70.124.161.118
12:42:38 --- mode: glguy set -bbbb *!*@lstlambert-656-1-44-4.w92-154.abo.wanadoo.fr *!*@ool-4572d12d.dyn.optonline.net *!*fourroot3@2409:4052:80c:bb72:f833:25d6:90c4:* *!Sexylady88@87.70.83.*
12:42:38 --- mode: glguy set -o glguy
12:44:49 <HoolaBoola> So, I have this class Operation1 with three possible fields: Add1 Int Int, Multiply1 Int Int and Substract1 Int Int. Then I have function compute1 :: Operation1 -> Int
12:45:02 <HoolaBoola> How can I turn each operation sensibly into a String?
12:45:24 <HoolaBoola> so show1 (Multiply1 2 3) == "2*3"?
12:45:46 --- mode: ChanServ set +o glguy
12:45:47 --- mode: glguy set -bbo $a:azathoth99 $a:^5 glguy
12:45:55 <monochrom> "class"? "data"?
12:46:08 <HoolaBoola> Um yes, sorry
12:46:09 <HoolaBoola> data
12:46:44 <monochrom> I think you write your own function Operation1 -> String for this. Have you tried?
12:47:22 <thblt> or maybe better, you can manually derive Show
12:47:24 <Cheery> HoolaBoola: you have to learn how to read abstract data types here.
12:47:46 <HoolaBoola> Yes, that's the idea. show1 :: Operation1 -> String. I have no idea how I could do this, though. I mean, I guess with different functions for each possibility?
12:47:48 <thblt> implement, not derive.
12:48:08 <Cheery> HoolaBoola: so lets be specific.. you got..
12:48:09 <monochrom> No, one function is sufficient. Use pattern matching.
12:48:30 <Cheery> data Operation1 = Add1 Int Int | Multiply1 Int Int | Subtract1 Int Int
12:48:47 <Cheery> HoolaBoola: you understand what this means? It means that Operation1 is something that can be constructed in three ways
12:48:54 <HoolaBoola> So I just should do show1 (Multiply1 i j) = show i ++ "*" ++ show j?
12:49:06 <monochrom> Yes
12:49:18 <Cheery> show1 i ++ "*" ++ show1 j
12:49:37 <monochrom> No, show is right for i and j.
12:49:46 <monochrom> show1 is for Operation1, not Int
12:49:58 <Cheery> yep. to destroy item that's constructed in three ways, you got to prepare for destroying one of three possible ways it was constructed.
12:50:32 <Cheery> so three equations.
12:50:38 <Cheery> ohwait.. yes. :)
12:50:51 <Cheery> yup, it's show1, I missed what i was.
12:51:04 <HoolaBoola> I guess it's not really possible to do something like this: show1 (Operation1 i j) = show i ++ getOperator (dunno?) ++ show j? 
12:51:28 <HoolaBoola> Where I would have to do that only once with the operator being different?
12:51:28 <monochrom> It is neither possible nor meaningful.
12:51:32 <HoolaBoola> Okay
12:51:39 <Cheery> does haskell have that extension to retrieve tag of a structure?
12:52:04 <Cheery> it'd be meaningful, but Haskell doesn't do it.
12:52:18 <HoolaBoola> I guess I'm stuck in my OOP ways... But anyway, thanks for clearing it up :)
12:52:34 <Cheery> you can do it youkrself
12:52:53 <monochrom> An extension plus a library. The extension is "DeriveGeneric". The library is GHC.Generic.
12:52:53 <Cheery> data Operation1Tag = Add1Tag | Multiply1Tag | Subtract1Tag
12:53:13 <Cheery> then getTag :: Operation1 -> Operation1Tag
12:53:31 <monochrom> I may also miss an "s" in "Generic".
12:53:49 <Cheery> well you seem to also want to generalize over binary operations
12:53:54 <Cheery> it may be simpler to just do
12:54:16 <thblt> or maybe more common, isAddition :: Operation1 -> Bool
12:54:19 <Cheery> data Operation2 = BinOp Int Operation1Tag Int
12:54:32 <thblt> isAddition (Addition _ _) = True \n isAddition _ = False
12:54:36 <monochrom> That design has pros and cons.
12:55:20 <HoolaBoola> Thanks :=
12:55:28 <HoolaBoola> * :)
12:58:14 <monochrom> pros when in every way you care you treat Operation2 values uniformly regardless of the operator.
12:58:42 <monochrom> cons when sometimes you have to use completely different logics for different operators.
12:59:21 <monochrom> Example of cons is when you have a division operator and you check for divide-by-zero for it but there is no check for all other operators.
13:00:35 <monochrom> In that case you pay the price of writing the longer "BinOp x Div y", "BinOp x Add y", etc, without the benefit of refactoring, because there is nothing to refactor.
13:01:52 <Cheery> badd x y = BinOp x Add y
13:02:20 <monochrom> No, I mean when you're writing an evaluator and you write those two patterns in pattern matching.
13:02:40 <Cheery> there was extension for that.
13:03:06 <Cheery> but yeh. there may bo some point to that.
13:03:47 <Cheery> I'm a programming language designer so I may be the worst asshole to ask about structure.
13:05:47 <Cheery> you give me binary operators, I ask you what's the type for those binary operators.
13:07:14 <ezzieyguywuf> HoolaBoola: why not do something like `opToString :: Operation1 a b -> String; opToString (Addition _ _) = "+"; opToString (Subtraction _ _) = "-";` etc...
13:10:15 <ezzieyguywuf> HoolaBoola: I imagine you're parsing a string to construct an Operation. Another option is to do something like `data OperationLabel = PlusLabel | MinusLabel | etc...` and `data Operation a b = Operation OperationLabel a b`, and then you could `Map OperationLabel String` and use `Map.lookup` to find the appropriate string
13:12:09 <ezzieyguywuf> hah nvm that's what Cheery said.
14:58:16 <ADG1089> how to define triplet: https://hastebin.com/upinagozuc.bash
14:58:49 <ADG1089> as an instance of Num with (+) (-) and (*) as dot product ?
14:59:49 <solonarv> (*) as dot product? not possible
15:00:23 <solonarv> in 'instance Num Triplet', you have '(*) :: Triplet -> Triplet -> Triplet'
15:00:40 <solonarv> i.e. the result has to be the same type as the input
15:00:47 <solonarv> for a dot product this is not the case
15:02:21 <ADG1089> ok can i define it as elementwise product
15:02:28 <ADG1089> i want to know what syntax will work
15:05:14 <solonarv> sure, you can define it as elementwise product
15:05:26 <solonarv> it will look very similar to the definitions for + and -
15:05:30 <solonarv> (as you might expect)
15:14:46 <monochrom> https://medium.com/better-programming/monads-are-just-fancy-semicolons-ffe38401fd0e will be on my exam.  I.e., why Counter's >>= breaks monad laws!
15:27:17 <MarcelineVQ> I wonder if it'd be possible to use the same space used to explain why it's a semicolon to instead explain typeclasses
15:31:02 <Cheery> oh no. I already got OOP medium article in my teeth
15:31:15 <monochrom> haha
15:31:30 <monochrom> The road to hell is paved with well intentions.
15:32:25 <MarcelineVQ> monochrom: Is there something about >>= specifically that breaks the laws or are you referring to not having Applicative/Functor ?
15:32:54 <solonarv> one of the laws is 'f >>= return = f'
15:33:22 <monochrom> Yeah, then >>= goes on to bump up the counter.
15:33:23 <solonarv> but 'Counter n x >>= return = Counter (n+1) x'
15:34:20 <MarcelineVQ> aha I was curious about that, in particular wondering why a counter wouldn't have pure give 1 already in an item counting monad
15:34:43 <ADG1089> given xss :: [[a]] = [[a11,a12...], [a21,a22,..], ...]  how to get [aij `op1` akl, i/=k] ++ [aij `op2` akl, i/=k] using foldM ? 
15:35:06 <solonarv> this would be a valid Monad instance if it was changed to 'return x = Counter (-1) x', amusingly
15:35:27 <ADG1089> I'm thinking foldM (liftM2 (\x y -> [x`op1`y, x`op2`y])) ident xss
15:35:29 <monochrom> hahaha
15:45:32 <thblt> The doc is almost clear, but: TypeSynonymInstances allows to use a synonym in an instance declaration, but the result is strictly the same as if you used the real type, correct?  
15:52:35 <Cheery> Anyone remember where pillars of OOP came from?
15:52:58 <Cheery> inheritance, encapsulation, deleganion, ploymorhism
15:53:18 <Cheery> that is, who coined this?
15:58:02 <Cheery> oh. grady booch's book
16:03:12 <solonarv> thblt: yes, that's right
16:04:00 <thblt> solonarv: thanks
16:44:09 <ddellacosta> So, let's say you're using req (https://hackage.haskell.org/package/req) for a kinda hacky thing and you need a monad that has MonadThrow and MonadFail in addition to everything req needs. Would you use the Req monad that comes with it and somehow augment that, or create your own new monad and add MonadHttp as is also suggested in the docs, or something else entirely?
16:47:33 <ddellacosta> or, maybe I should just use wreq lol
16:55:54 <monochrom> I am a bit inspired by "newtype Req a = Req (ReaderT HttpConfig IO a)", except that this detail is not exported. But at least it looks like MonadThrow and MonadFail still make sense for it.
17:00:11 <monochrom> Adding MonadFail should be easy because it's just liftIO (fail s), using IO's fail.
17:01:13 <monochrom> What are the MonadThrow methods again? Does it just have throw? Does it also have catch?
17:02:19 <monochrom> catch may be doable through MonadBaseControl
17:04:25 <pmwhite> Feels dumb that I can't figure this out, but how do I add a Word8 to an Int?
17:04:37 <monochrom> fromIntegral
17:04:51 <Cheery> it works both ways right?
17:04:58 <monochrom> yes
17:06:20 <pmwhite> monochrom: thanks.
17:30:49 <ddellacosta> monochrom: interesting, thank you!
17:32:18 <ddellacosta> I'm guessing you already figured this out but just throwM (for MonadThrow)
17:32:42 <ddellacosta> MonadCatch has MonadThrow as a constraint though
17:34:59 <ddellacosta> I only need it 'cause I'm parsing URLs with mkURI, as that's what Req uses (Text.URI). Not sure I need that honestly
17:36:02 <solonarv> you could perhaps just use the instance for 'Maybe'
17:36:14 <ddellacosta> oooh interesting
17:36:42 <ddellacosta> thanks solonarv 
17:39:10 <ddellacosta> that's nice, I can just shunt that off to a small function
17:39:18 <ddellacosta> yay I can be lazy lol
17:51:23 <ddellacosta> hmm, doesn't work the way I thought. Ah well
17:53:50 <ddellacosta> er, actually I forgot to remove a constraint
17:57:27 <xsperry> can you fetch an element at Nth position with Foldable? I don't care about efficiency. I could write my own with foldr but I was wondering if it already exists
17:58:46 <solonarv> yes you can
17:58:55 <solonarv> the simple way: toList xs !! n
17:59:29 <xsperry> right, even simpler
18:02:10 <xsperry> I know I said I didn't care about efficiency, maybe Foldable is wrong class for this? is there a class for this, where fetching an element is O(1) for arrays, vectors, etc
18:03:21 <solonarv> somewhat unsurprisingly, lens has a class for this
18:03:52 <MarcelineVQ> I'd be inclined to just use  !!  or  !?  over a class since most containers will implement this by this name, or lookup if not
18:04:24 <solonarv> if you're already using lens then Ixed is the typeclass I meant
18:04:37 <solonarv> not worth picking up the dependency just for that though
18:04:44 <ddellacosta> Is that reliably O(1)? I never have understood how to figure out lens performance
18:05:06 <xsperry> yeah. what's the class name in lens?
18:05:13 <monochrom> No type class ever comes with a law about cost.
18:05:23 <ddellacosta> yeah point taken
18:05:34 <ddellacosta> xsperry: solonarv wrote it above, it's Ixed
18:05:41 <xsperry> ok I missed it
18:06:09 <ddellacosta> np just acknowledging
18:12:12 <crestfallen> hi I'm learning state in haskellbook with System.Random module. This warning is returned: In the use of ‘next’ (imported from System.Random, but defined in System.Random.Internal): Deprecated: "No longer used"     
18:12:19 <crestfallen> while running:  $ next (mkStdGen 0) 
18:13:24 <crestfallen> what can I use to substitute for "next"  ?
18:13:58 <crestfallen> I looked for errata or updates of the textbook
18:18:27 <monochrom> To minimize digression, you should press on and use "next" for now.
18:18:56 <crestfallen> good call will do  .. thanks monochrom 
18:20:11 <tabemann> hey crestfallen 
18:20:28 <tabemann> du heißt crest?
18:20:40 <crestfallen> come again?
18:20:49 <tabemann> okay, you're not crest
18:20:55 <kraeXen> > max 1 2
18:20:57 <lambdabot>  2
18:21:01 <kraeXen> +1
18:21:11 <crestfallen> no I'm better looking then crest tabemann :)
18:21:14 <tabemann> wait, I'm in #haskell, not #forth
18:23:54 <crestfallen> > mkStdGen 0
18:23:56 <lambdabot>  1 1
18:27:43 <crestfallen> monochrom, that is the same output on a mac. with a slightly older version of ghc I get the output:   StdGen {unStdGen = SMGen 0 16294208416658607535}   is it that radically different?
18:28:23 <crestfallen> that is ghc 8.8.4
18:29:06 <crestfallen> correction the mac version is older: 8.8.3
18:32:14 <crestfallen> anyone pls explain the huge difference in output? I'm trying to follow a book
18:33:18 <crestfallen> ..  > mkStdGen 0
18:33:21 <crestfallen> StdGen {unStdGen = SMGen 0 16294208416658607535}
18:33:59 <crestfallen> > mkStdGen 0
18:34:01 <lambdabot>  1 1
18:36:25 <crestfallen> > next (mkStdGen 0)
18:36:27 <lambdabot>  (2147482884,40014 40692)
18:36:51 * ski thinks `StdGen's `Show' instance ought to be amended
18:37:22 <dolio> Why does the `show` output for a random number generator matter for what's in the book?
18:38:45 <ski> perhaps wanting to check whether they got the right answer ?
18:39:27 <crestfallen> bloody confusing
18:40:52 <crestfallen> why would one output be 1 1 ? and the other 
18:40:58 <crestfallen> StdGen {unStdGen = SMGen 0 16294208416658607535}   ??
18:47:28 <mmaruseacph2> it should not matter
18:47:44 <mmaruseacph2> :t mkStdGen
18:47:45 <lambdabot> Int -> StdGen
18:48:24 <mmaruseacph2> > map mkStdGen [0, 0, 0]
18:48:26 <lambdabot>  [1 1,1 1,1 1]
18:48:54 <xsperry> crestfallen, I think Show instance is showing seed value of the pseudo random generator
18:48:55 <mmaruseacph2> it always has to produce the same result when called with the same argument; what the result is depends on the internal implementation
18:49:08 <mmaruseacph2> xsperry is right
18:49:17 <glguy> The internal numbers of the generator you get back with mkStdGen don't matter
18:49:24 <mmaruseacph2> :i mkStdGen
18:49:31 <glguy> You shouldn't try to understand them or match them up with your book
18:50:00 <crestfallen> thanks ALL let me show you the output of 
18:50:17 <crestfallen> > map mkStdGen [0,0,0]
18:50:20 <lambdabot>  [1 1,1 1,1 1]
18:50:51 <crestfallen> [StdGen {unStdGen = SMGen 0 16294208416658607535},StdGen {unStdGen = SMGen 0 16294208416658607535},StdGen {unStdGen = SMGen 0 16294208416658607535}]
18:51:21 <crestfallen> that is 8.8.4 on a debian machine
18:51:46 <glguy> What's your question?
18:53:38 <crestfallen> it makes me paranoid, when the same input on 8.8.3 on a macbook returns [1 1, 1 1, 1 1]  , as does lambdabot
18:54:58 <glguy> crestfallen: Different versions of the library are likely to have different behaviors. You don't need to be nervious
18:59:12 <crestfallen>  there's no consistency between the machines , the book, the behavior. just maddening. what am I missing? thanks kindly glguy
18:59:56 <glguy> Different versions of the library changed the way the random number generator works. Since all it has to do is be random it doesn't matter that it's different
19:01:20 <crestfallen> glguy, just maddening, but I appreciate your help
19:04:06 <ski> xsperry : it ought not to use non-Haskell syntax, though
19:06:38 <mmaruseacph2> crestfallen: random-1.1 and before used this definition: https://hackage.haskell.org/package/random-1.1/docs/src/System.Random.html#mkStdGen
19:06:49 <mmaruseacph2> but random-1.2 use a different one: https://hackage.haskell.org/package/random-1.2.0/docs/src/System.Random.Internal.html#mkStdGen
19:08:20 <crestfallen> << see moniker    thanks mmaruseacph2 
19:20:34 <crestfallen> btw thanks ski 
20:12:49 <fresheyeball> hey out there
20:13:00 <fresheyeball> I am going to try megaparsec
20:13:05 <fresheyeball> and I have no clue about this api
20:13:30 <fresheyeball> anyone know how to say... get all the things on a given line we can parse?
20:14:06 <fresheyeball> also what is a token?
20:14:16 <fresheyeball> like what defines it in parsing?
20:33:22 <ddellacosta> hey fresheyeball this is a little hard to find but I think it'll answer your questions and help you get going: https://markkarpov.com/tutorial/megaparsec.html
20:58:14 <fresheyeball> ddellacosta: what if I want to say "so long as it's not between { and }"?
20:58:34 <fresheyeball> as in I only want to parse the token if it's not between curles
21:12:46 <sm[m]> you could try to parse for a thing on curlies first, and as an alternative if that fails try to parse the other thing
21:14:13 <sm[m]> using <|> to combine alternative parsers
21:16:26 <fresheyeball> sm[m]: I found `skipBlockComment "{" "}"`
21:26:04 <fresheyeball> sm[m]:http://ix.io/2sQd
21:26:08 <fresheyeball> this is what I have so far
21:26:25 <fresheyeball>  λ.parseTest selectors sample
21:26:28 <fresheyeball> ["bar","fo:o/3","baz","qux","0121"]
21:26:38 <fresheyeball> I am trying to get it to omit the last one
21:27:18 <fresheyeball> but so far it keeps finding it
22:30:31 <fresheyeball> http://ix.io/2sQn
22:30:47 <fresheyeball> now megaparsec is doing _exactly_ want I want
22:30:59 <fresheyeball> except for the damn hex inside the {}
22:42:37 <hololeap> what would be a good way to use Crypto.Random.getRandomBytes, which returns a ByteArray, and turn this into an Int?
22:43:35 <hololeap> this is for no reason other than curiosity. i don't need cryto-strength randomness for this
22:43:52 <hololeap> so i can switch back to System.Random if need be
22:44:52 <hololeap> i can turn the ByteArray into [Word8]
22:57:24 <ezzieyguywuf> whoot, my cad app is coming along! https://gitlab.com/ezzieyguywuf/mycad/-/tree/master
23:00:53 <hololeap> % import qualified Crypto.Random as CR
23:00:53 <yahb> hololeap: ; <no location info>: error:; Could not find module `Crypto.Random'; It is not a module in the current program, or in any known package.
23:01:28 <c_wraith> hololeap: you could use a library like binary or cereal...  Or if you don't want to mess with that, you could use some bitshifts and ors
23:15:39 <tintinthong> Hi I dont know why I get this. It is unusual
23:15:43 <tintinthong> Could not load module ‘Control.Lens’ It is a member of the hidden package ‘lens-4.18.1’. You can run ‘:set -package lens’ to expose it. (Note: this unloads all the modules in the current scope.) Use -v (or `:set -v` in ghci) to see a list of the files searched for. (haskell-stack-ghc)
23:16:11 <tintinthong> My cabal is library  exposed-modules:      Lib  other-modules:      Paths_haskell_playground  hs-source-dirs:      src  build-depends:      base >=4.7 && <5      , mtl      , lens 
23:16:20 <tintinthong> ```library  exposed-modules:      Lib  other-modules:      Paths_haskell_playground  hs-source-dirs:      src  build-depends:      base >=4.7 && <5      , mtl      , lens ```
23:16:45 <dsal> Pasting a file is a bit better.
23:18:52 <tintinthong> Must I perhaps :set within a .ghci file? 
23:20:21 <dsal> Oh, you're not using `cabal repl` or similar?
23:20:41 <tintinthong> Im using stack so I just `stack build` and `stack ghci`
23:22:06 <tintinthong> I feel this stack and cabal thing is so confusing 4 me 
23:25:23 <dsal> Do you have a package.yaml?  Can you show what the actual files look like in a pastbin?
23:29:00 <tintinthong> dsal 
23:29:05 <tintinthong> cabal file: https://pastebin.com/akg403GJ
23:29:46 <tintinthong> No I dont have a pacakge.yaml file 
23:29:55 <dsal> That says it was generated by package.yaml
23:30:29 <tintinthong> oh wait i do 
23:31:23 <tintinthong> pacakge.yaml https://pastebin.com/E1KgGzjJ
23:31:39 <dsal> So, add lens to dependencies at the top.
23:31:58 <dsal> Then try `stack repl`
23:34:58 <tintinthong> oooh naise it worked
23:35:21 <tintinthong> Does that mean I should not  manually add to my cabal file and only update my package.yaml?? dsal
23:35:39 <dsal> Yeah, your cabal file is autogenerated.
23:40:37 <MarcelineVQ> one or the other basically, just use package.yaml or just use the .cabal file
23:42:38 <tintinthong> Ahh I see. Thanks MarcelineVQ and dsal. I had no notion of the package.yaml file. Ive been modifying cabal file all this time. 
23:43:38 <MarcelineVQ> if that's your preference you can delete the package.yaml
23:46:10 <dsal> The nice thing about standards....
