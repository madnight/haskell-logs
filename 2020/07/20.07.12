00:00:50 <ja> FindTeh: maybe #r_netsec ?
00:01:04 <FindTeh> ok thanks
00:01:38 <FindTeh> is this a joke? lol
00:02:35 <ja> no, i am just guessing. but you're asking in a haskell channel, i dunno why you would think someone would be knowledgable about that here
00:02:39 <Cale> FindTeh: We could ask the same thing, you're asking a channel about a functional programming language about where to get wifi hacking tips for some reason.
00:03:30 <FindTeh> well, we all have to start somewhere
00:04:16 <FindTeh> well anyways, if anyone has good channes to recommend, please dm them to me
00:04:21 <FindTeh> channels*
00:06:58 <FindTeh> should i even be in freenode?
00:08:21 <ja> i am playing with zippers, and i noticed that Zipped is a type family. how do i work with that, how can i make my tree such that it can be 'rezip'd into?
00:10:05 <Cale> Ah, the actual package named "zippers"
00:10:13 <Cale> not just zippers generally
00:10:37 <Cale> You can write type instances for your own types
00:11:56 <ja> is 'data instance' distinct from 'type instance'?
00:12:09 <Cale> Yeah, they're different
00:12:33 <Cale> data instance is used with data families, type instance with type families
00:13:19 <Cale> The difference is that, like the difference between data and type,  data instance defines new data constructors that are specific to the instance
00:13:52 <Cale> while type instance just specifies which type the thing evaluates to in that instance
00:14:43 <ja> ah, so it a type has a type instance, it can "be" that type?
00:14:53 <ja> so that is why Zipped needs an instance from me? 
00:15:00 <kiwi_45> Does anyone here have developed a web app using Haskell’s Servant and ReactJs for frontend ?
00:15:40 <ja> if i write "type instance Zipped MyType", haskell will allow "MyType" to be used in place of a Zipped, right?
00:16:34 <Cale> You'd need the other parameter, and you need a right hand side
00:17:04 <Cale> But you could say something like type instance Zipped MyType a = MyOtherType
00:17:26 <ja> ooh interesting :O
00:17:46 <ja> but that is nice, then i can put all the logic implementing the "type instance" in a separate type
00:18:52 <ja> i will play with the syntax...
00:19:00 <ja> thanks
00:20:08 <Cale> Just in case it's not obvious, this is a really weird library
00:23:14 <kiwi_45> Does anyone here have developed a web app using Haskell’s Servant and ReactJs for frontend ?
00:24:40 <Cale> kiwi_45: I've mostly developed web apps using Snap or Obelisk backends, and Reflex-dom frontends.
00:26:26 <kiwi_45> Cale: I tried to develop my first web app using Haskell, servant and reactJS, almost done but now stuck with cors problem while Authentication with servant-auth-server =(  It's been more than 2 week and yet I can't solve the issue
00:27:59 <kiwi_45> anyone having experience would be really helpful for me 
00:28:55 <Cale> It may help to describe the problem you're having anyway
00:29:21 <Cale> It's the middle of the night in the US, so you might also want to try at a different time of day if you don't get a response
00:29:51 <kiwi_45> sure
00:33:09 <kiwi_45> problem is not simple to even describe, but I get CORS Error : `Cors Missing Allow Origin` error when I hit an endpoint after authentication, this is my code snippet btw https://gist.github.com/DeepakKapiswe/2b1934e8de9b431ffd04dd8deb620446
01:01:08 <zceejkr> I have a problem, if anyone would like to help out: I am using Network.Socket to connect to an IRC server, and then I use sokcetToHandle with ReadWriteMode to get a Handle out of the socket. I am able to connect to freenode fine with this, bot read and write messages. But when I try to connect to a diffferent IRC server (Twitch chat), I get the socket and the handle just fine, and it allows me to write data to it just fine. But I am not
01:01:09 <zceejkr> receiving any data back from the server, and I know I should given the messages I write to the handle. It is also not a routing issue I don't think, since the exact bot written in Rust has no problems. It is as if there is some problem with the socket, but no runtime information about anything going wrong. Any ideas how to debug this?
01:08:49 <c_wraith> twitch is not actually IRC.  it's similar, but the differences are enough to break things.
01:14:33 <zceejkr> But it is very strange, that I replicated the exact same sequence of actions in Rust, and I was able to get data from the socket. How does one generally debug this sort of issue?
01:16:39 <Graypup_> zceejkr, try wireshark
01:26:06 <zceejkr> OK, so I tried looking at the Rust and Haskell version in Wireshark. In Haskell, the connection starts with me sending PING (I am not doing this explicitly in code) and the server sends back a PONG. In Rust it starts with me sending a SYN. Is this what the problem could be?
01:26:53 <zceejkr> I guess in haskell I do not see the whole SYN, SYN/ACK, ACK sequence.
01:29:38 <zceejkr> To be percise, I do not see the instead of SYN -> SYN/ACK -> ACK, I get PING -> PONG -> ACK
01:41:06 <xacktm> zceejkr: see if you are sending a bytestring vs plain text
01:41:24 <xacktm> I had a similar twitch issue with websockets/ghcjs
01:41:42 <xacktm> and I believe that was it
02:27:42 * hackage language-python 0.5.8 - Parsing and pretty printing of Python code.  https://hackage.haskell.org/package/language-python-0.5.8 (BerniePope)
02:28:42 * hackage language-python-test 0.5.8 - testing code for the language-python library  https://hackage.haskell.org/package/language-python-test-0.5.8 (BerniePope)
02:52:19 <kiwi_45> I tried to develop my first web app using Haskell, servant and reactJS, almost done but now stuck with cors problem while Authentication with servant-auth-server =(  It's been more than 2 week and yet I can't solve the issue, anybody having experience developing a servant backend for react JS 
03:11:28 <bradparker> kiwi_45: i think we had some CORS _stuff_ that needed doing when integrating a servant backend with a reflex front end. Does this diff look helpful https://github.com/bradparker/servant-beam-realworld-example-app/pull/3/files?
03:33:24 <_xor> Hello :) Trying to build a haskell project and not too familiar with the ecosystem/toolchain (aside from cursory review of the language docs).
03:34:03 <_xor> It's failing due it needing base 4.14.  From what I've gathered so far, to get a newer version of base you need to upgrade the compiler.  I have ghc 8.8.3.
03:34:05 <_xor> Is that the case?
03:35:06 <_xor> To get base 4.14, do I need to have ghc 8.10?  If so, then I might have to roll up my sleeves a bit, as I'm on FreeBSD and it looks like the port is at 8.8.3.
03:38:36 <fendor> _xor, yes that is correct. On the project, you could also try to lower the lower bound on the `base` library
03:40:26 <_xor> I guess I'll have to decide whether to do that or try to update the port to 8.10.
03:41:02 <_xor> The latter would be preferable, but I only have a couple of hours to spare right now & my hunch is that it'll take a bit longer to do that.
03:42:56 <xacktm> you'd also have to make sure that all your project's deps accept base 4.14 
03:43:12 <phadej> depends what your project is, but it's quite unluckily it uses anything demanding GHC-8.10
03:43:19 <phadej> 8.8.3 is just fine
03:44:36 <_xor> It's hasura/graphql-engine.
03:44:41 <_xor> Yup, that's what I'm doing right now.
03:44:59 <_xor> Dropping version, building, resolving error, rinse & repeat...
03:45:19 <phadej> otoh, https://www.haskell.org/ghcup/ iirc had freebsd versions
03:45:43 <phadej> I'd recommend that (or some other non-system-package-manager) installation of different GHC versions
03:45:53 <_xor> Oh, I'll have to check it out in a minute.  Didn't realize that was there.
03:46:12 <_xor> Also, does the haskell ecosystem generally follow semver or something to that effect?
03:46:23 <phadej> https://pvp.haskell.org/
03:46:24 <_xor> Asking because one of the deps listed is 0.6.0, but I only have 0.5.3.
03:46:42 <phadej> first two digits are "major" part
03:46:48 <_xor> Makes sense.
03:46:50 <phadej> c.f. base 4.14
03:47:18 <phadej> (fyi, pvp predates semver)
03:48:41 <_xor> I'm assuming ghcup is the same idea as rustup?
03:48:58 <phadej> kind-of
03:49:40 <phadej> (I find rustup more friendly for "I have no idea what I'm doing people" - i.e. myself in Rust world)
03:49:58 <phadej> otoh, I haven't tried latest ghcup iterations, so cannot say for sure :)
03:51:41 <NewToHaskell> Any website more than https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems I can find relatively easy problems for beginners? =)
03:54:11 <_xor> phadej: Cool
03:54:24 <_xor> Hmm, just tried `ghcup install 8.10.1` and it's telling me it can't find that version.
03:54:31 <_xor> list shows it though, maybe platform issue?
03:55:46 <_xor> Oh nevermind
03:56:28 <_xor> Nope, still didn't work :/
03:57:19 <_xor> Are the docs stale or am I doing something wrong?  I tried `ghcup install 8.10.1`, then `ghcup install ghc 8.10.1` based off of the README, and it complained about 8.10.1 being an unrecognized argument.
03:57:35 <_xor> Then I tried to `ghcup tui` (like from README), and it didn't recognize that either.
04:02:39 <fendor> _xor, I think the README contains the latest documentation. Not sure if the TUI is already published
04:05:35 <_xor> The readme isn't versioned with the release?
04:05:41 <_xor> Oh, it's on master.
04:26:03 <kiwi_45> bradparker : I already did that, but no luck
04:31:38 <gentauro> NewToHaskell: try to solve code katas not aimed at FP languages
04:32:01 <gentauro> that way you will see why/how FP are usefull (and where they are not)
04:32:38 <kiwi_45> I tried to develop my first web app using Haskell, servant and reactJS, almost done but now stuck with cors problem while Authentication with servant-auth-server =(  It's been more than 2 week and yet I can't solve the issue, anybody having experience developing a servant backend for react JS 
04:33:11 <gentauro> NewToHaskell: try to solve the task in an idiomatic/pure way (I would recommend Okasakis "Purely Functional Data Structures" https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf)
04:33:45 <gentauro> once you realize that Haskell isn't what you expect, you will need to learn "how to bend it" in order to comply with your own sense of soundness and correctness
04:35:35 <gentauro> NewToHaskell: I just posted a snippet on my blog where I tried to implement `min-max heaps` by using a `pairing-head` -> http://blog.stermon.com/articles/2020/07/12/haskell-safe-min-max-heaps-only-depending-on-prelude.html
04:42:10 <kiwi_45> here is my code snippet : https://gist.github.com/DeepakKapiswe/2b1934e8de9b431ffd04dd8deb620446
04:47:39 <maerwald> _xor: what distro
04:48:48 <maerwald> the only platform lacking 8.10.1 is freebsd
04:49:28 <maerwald> the `ghcup install ghc` subcommand doesn't exist in the current version
05:22:01 <NewToHaskell> Could someone help me? I am trying to install GHC on my mac, I've followed all the steps on https://github.com/haskell/ghcup.
05:22:16 <NewToHaskell> When I type `export PATH="$HOME/.cabal/bin:$HOME/.ghcup/bin:$PATH"`
05:22:25 <ksevelyar> Hi all! I'am trying to integrate Polybar with Xmonad: https://github.com/ksevelyar/idempotent-desktop/blob/master/home/.xmonad/xmonad.hs#L108-L118
05:22:29 <NewToHaskell> into my terminal, it all works, but its temporary.
05:22:48 <maerwald> NewToHaskell: add that to your .bashrc
05:22:51 <gentauro> NewToHaskell: do you use `stack`?
05:22:52 <NewToHaskell> when I close terminal and open it up ghci doesnt work again, how do I add it permanent to my path?
05:23:04 <maerwald> gentauro: they're using ghcup
05:23:27 <gentauro> maerwald: is that new?
05:23:36 <maerwald> NewToHaskell: if you use bash shell, add that line to your ~/.bashrc
05:24:01 <maerwald> NewToHaskell: also, that repo is old
05:24:08 <NewToHaskell> `~/.bashrc PATH="$HOME/.cabal/bin:$HOME/.ghcup/bin:$PATH"` ?
05:24:21 <maerwald> NewToHaskell: Just follow https://www.haskell.org/ghcup/
05:26:08 <gentauro> maerwald: oh, https://gitlab.haskell.org/haskell/ghcup-hs#usage, so it's a `global` installation. Fair enough 
05:26:46 <maerwald> gentauro: user-wide
05:27:29 <gentauro> maerwald: hehe, until people get better and need some packages that depend on a given GHC version and then another project depends on a previous GHC
05:27:52 <maerwald> gentauro: it allows managing multiple GHCs
05:27:57 <gentauro> that's the reason I use `stack` + `cabal` files, so I can specify GHC + LTS
05:28:07 <maerwald> you can do the same with it
05:28:47 <gentauro> maerwald: hmmmm
05:28:59 <maerwald> cabal build -w ghc-8.10.1
05:29:24 <maerwald> or with-compiler in cabal.project
05:29:29 <gentauro> maerwald: and package version? (LTS)
05:29:38 <maerwald> you use freeze files for that
05:29:54 <maerwald> you can create a freez file from a stackage lts
05:30:31 <gentauro> will I normally just add `resolver: lts-14.27` in my `stack.yaml`
05:30:45 <maerwald> https://hackage.haskell.org/package/stack2cabal
05:31:06 <maerwald> https://www.stackage.org/lts-14.27/cabal.config
05:33:39 <gentauro> Hmmm, I might not get it. I need to make a `stack.yaml` file, but then use another tool to convert it to `something` so I can then use `cabal`/`ghcup`?
05:33:48 <maerwald> gentauro: no
05:34:24 <maerwald> just create cabal.project and download that lts cabal.config as cabal.project.freeze
05:34:58 <maerwald> and the bonus is: you still have access to non-stackage packages
05:36:15 <gentauro> maerwald: like `local`? Cos that sounds interesting :o
05:36:33 <maerwald> local?
05:37:50 <gentauro> yeah, I have a folder on my laptop with a lot of POC's projects. Sometime I need them for others, but since they aren't on `hackage`, I end up doing `symbolic linking` to files, which is pretty bad
05:38:33 <gentauro> so I would like to specify somewhere: this project depends on package A which is placed at `~/foo/bar/projectA` and not on some online git repo
05:38:44 <gentauro> I haven't managed to do that with `stack`
05:40:24 <maerwald> gentauro: you just add it to packages
05:42:34 <MarcelineVQ> gentauro: you just add ~/foo/bar/projectA to extra-deps
05:43:07 <ksevelyar> I'm trying to make Xmonad workspaces clickable with wmctrl: https://gist.github.com/ksevelyar/d057c305557951b96e0a3317a4f744f9
05:43:47 <ksevelyar> Is it possible to pass <workspace-id> to dynamicLogWithPP `wrap`?
05:45:13 <ksevelyar> something like, ppHidden = wrap("%{A1:wmctrl -s" ++ <workspace-id> ++ "}") "{A}"
05:46:53 <gentauro> maerwald: and MarcelineVQ oh, you are right
05:47:51 <gentauro> I didn't notice that it doesn't like `~/` path. So it either has to be fullpaths `/home/…` (bad) or relative `../foo/bar/projectA` (better)
05:48:03 <MarcelineVQ> extra-deps is the correct section to add it to if it's a dependency instead of some additional component of your project
05:48:56 <maerwald> cabal has an optional-packages option which doesn't cause an error if the directories don't exist
05:49:07 <maerwald> basically for vendoring
05:49:09 <MarcelineVQ> tbh it's not really clear to me what the packages section is even for in a stack.yaml
05:49:54 <MarcelineVQ> Since it's never been the right section to add something to when I've needed to add something
05:49:54 <gentauro> MarcelineVQ: I normally just live it like this: `packages: - .`
05:50:14 <gentauro> MarcelineVQ: maybe they should `deprecate` it?
05:50:34 <maerwald> they deprecat a lot of stuff and break backwards compat :p
05:50:50 <maerwald> and still, the file format is confusing
05:51:09 <gentauro> it looks like it's legacy and they are moving forward to `extra-deps` -> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#packages
06:32:00 <charms> Hello, how could I define a left associative backwards alternative to '->' so e.g. plus :: Nat <-- Nat <-- Nat equivalent to plus :: Nat -> Nat -> Nat
06:32:29 <charms> for context, i'm reading a book that uses this alternative syntax so it is easier to think this way
06:40:39 <nick8325> charms: "type a <-- b = b -> a" (you will need {-# LANGUAGE TypeOperators #-})
06:40:44 <nick8325> charms: then you can do infixl 0 <--
06:42:21 <charms> nick8325 thank you, that works perfectly and is so simple.
07:03:00 <fcortesi> Hello. I'm having an issue, tried to ask in haskell-beginners but I had no answer.
07:04:09 <dmj`> fcortesi: What is your issue?
07:06:07 <fcortesi> mkTable :: Field b => [Column a b] -> [a] -> Text
07:06:39 <fcortesi> Basically I have this functions wich renders records of type a. I also give it a list of the Column's I want to render.
07:07:15 <ptrcmd> there is no constraint on a
07:07:41 <dmj`> fcortesi: what is the error you are receiving
07:07:48 <fcortesi> It works fine
07:07:57 <fcortesi> but only for fields of `a` of the same type
07:08:05 <fcortesi> I need to abstract it more.
07:08:16 <fcortesi> kTable [ Column textField1  "Column 1 title", Column textField2  "Column 2 title"] list_of_records 
07:08:24 <fcortesi> this works fine for example
07:08:54 <fcortesi> But if I put a Double and a Text in the column list, it fails.
07:10:36 <fcortesi> So I don't know if I need to use RankN2Type or what. I can make a different Column constructor for each type of field (TextColumn, DoubleCoumn, etc) but it's quite ugly.
07:11:59 <ptrcmd> what's the definition of Column?
07:12:05 <dmj`> fcortesi: yea the types need to be homogenous, so you'd need a sum type to differentiate the columns
07:12:10 <dmj`> fcortesi: can you paste your code?
07:12:15 <fcortesi> data Column a b = Column {cfield :: (a -> b) , ctitle :: Text}
07:12:35 <fcortesi> Later I'll add more parameters there.
07:13:20 <fcortesi> So you mean I can't avoid writing a specific Column constructor for each type of field?
07:14:57 <dmj`> fcortesi: yes because the type of list is [a]
07:14:57 <ptrcmd> fcortesi: FYI, https://wiki.haskell.org/Heterogenous_collections
07:15:28 <KN0DE5> Hey all. Does anyone have the book From Mathematics to Generic Programming? I don't know enough Haskell yet to tell, nor perhaps enough wise deeper principles, but was wondering if the C++-oriented stuff in that book would be translatable into Haskell given enough Haskell proficiency.
07:15:31 <dmj`> fcortesi: you don't want to use existentials or dynamic types for this
07:17:20 <ptrcmd> dmj`: how about HList?
07:17:22 <dmj`> KN0DE5: probably not, you'd be better served by just programming in Haskell and reading the typeclassopedia, implementing typeclass instances and equationally reasoning about the laws for intuition
07:17:49 <dmj`> ptrcmd: nah, it's overkill
07:18:35 <dmj`> ptrcmd: GHC.Generics could help, since this is essentially boilerplate
07:20:17 <dmj`> I don't understand why you need an a -> b in the definition of Column
07:20:31 <fcortesi> It's the type of the function
07:20:41 <KN0DE5> dmj`: nice. Thank you for that
07:20:43 <fcortesi> *feld function
07:21:01 <dmj`> KN0DE5: https://wiki.haskell.org/Typeclassopedia
07:21:21 <dmj`> fcortesi: why is the type a function
07:21:38 <dmj`> KN0DE5: np
07:23:23 <fcortesi> Hmm. Because the cfield record contains the field function of a. 
07:23:56 <fcortesi> * cfield field
07:34:54 <kiwi_45> I tried to develop my first web app using Haskell, servant and reactJS, almost done but now stuck with cors problem while Authentication with servant-auth-server =(  It's been more than 2 week and yet I can't solve the issue, anybody having experience developing a servant backend for react JS 
07:34:58 <kiwi_45> here is my code snippet : https://gist.github.com/DeepakKapiswe/2b1934e8de9b431ffd04dd8deb620446
07:39:12 <fcortesi> Sorry for the delay. Thanks dmj/ptrcmd. I'll check Hlist and Generics.
07:43:45 <dminuoso> 18:38:20           dolio | I don't really understand what some of the people in that thread are saying. Below the 'trivial' remark, there are people going on about how you need different structure to have 'interesting' comonads. What makes all of the comonads you can define in Haskell 'uninteresting'?
07:44:13 <dminuoso> dolio: I suppose its because most things yielding valid Comonad instances tend to be various flavours of `Store s`.
07:47:01 <dminuoso> But indeed, I cant follow the reasoning there either.
07:47:34 <sm[m]> Good morning all!
07:49:01 <sm[m]> MarcelineVQ: how can you be confused about packages: ? It’s the list of local packages to build as part of this project. The same as In cabal.project.
07:49:34 <MarcelineVQ> That's not a thing I've needed to do so far
07:49:52 <MacSlow> Greetings everybody!
07:49:54 <MarcelineVQ> that being to have more than one package in a, package
07:50:24 <sm[m]> It’s literally the reason project files were needed
07:50:26 <sm[m]> Multi package projects
07:50:30 <dminuoso> I mean I admit, when you say "there aren't many interesting comonoids" then you have to be careful to not conflate some hypothetical `class Comonoid w where split :: w -> (w, w); destroy :: s -> ()` with `class Functor f => EFComonoid t i f where duplicate :: f ~> f `t` f; extract :: f ~> i`
07:50:37 <dminuoso> I did that mistake.
07:50:55 <dminuoso> (That is there's two separate, albeit related, notions of the word comonoid)
07:51:38 <sm[m]> (so no, it’s not being deprecated gentauro)
07:51:42 <dolio> Right, the 'set' comonoid.
07:52:13 <dolio> Even though types aren't sets.
07:52:44 <dminuoso> Well the kind of squinting, accepting Hask as a subcategory of set, is generally accepted, no?
07:53:58 <kiwi_45> dminuoso: hello can you help me to solve cors issue with authenticated endpoints in servant ?
07:54:00 <dolio> I guess it depends. A category 'like' set might be more accurate.
07:54:49 <kiwi_45> anyone here worked for servant backend and react frontend ? I need help please.
07:55:18 <dminuoso> kiwi_45: You can use wai-cors to insert CORS headers into your WAI application.
07:55:51 <dolio> I'm pretty sure the 'all coalgebras in a Cartesian monoidal category are trivial' line is just wrong.
07:56:37 <dolio> I remembered another example. You can categorize the internal presheaves in a topos as a coalgebra (which, again, is certainly Cartesian monoidal). https://ncatlab.org/toddtrimble/published/Three+topos+theorems+in+one#eq:ttt2
07:57:08 <dolio> You have to get pretty broad with your definition of 'trivial' for that.
07:57:25 <kiwi_45> dminuoso: I used that here is my code snippet https://gist.github.com/DeepakKapiswe/2b1934e8de9b431ffd04dd8deb620446, but its not working, I mean I can authenticate with login endpoint but after that when I try to hit protected endpoint, the preflight OPTIONS call fails with `CORS No Allow Credential` error
07:58:43 <dminuoso> kiwi_45: https://hackage.haskell.org/package/wai-cors-0.2.7/docs/Network-Wai-Middleware-Cors.html#t:CorsResourcePolicy
07:59:04 <dminuoso> kiwi_45: It's documented there, and it's standard CORS behavior. So you can read it on say MDN as well.
07:59:53 <kiwi_45> I read first, but not getting where I'm missing :)  
08:00:46 <kiwi_45> if its not working then why I can properly authenticate which also uses cors and OPTIONS preflight
08:00:48 <dminuoso> `A value of Nothing indicates unrestricted cross-origin sharing and results in * as value for the Access-Control-Allow-Origin HTTP response header. Note if you send *, credentials cannot be sent with the request.`
08:01:02 <dminuoso> read the entire field description.
08:02:49 <MarcelineVQ> kiwi_45: did you catch this last time you spoke to dmj` ? you dc'd at the end so I was wondering  https://gist.github.com/MarcelineVQ/7ad5ecf82be812575975424e9cd216b4
08:03:10 <dolio> Oh, but also not that that is 'just' a dependently typed store. So you also can't really use that as a criterion for being interesting, or else you're going to overlook a lot of stuff.
08:03:40 <kiwi_45> dminuoso: I have doubt in same , and actually I was reading the same field's doc, I'm confused that what I can put there ? what value of origin specifically
08:03:59 <dminuoso> dolio: Well, there's certainly truth in "there dont appear to be any interesting comonoids in the category of endofunctors equipped with composition as its tensor.
08:04:06 <dminuoso> (Hask specific!)
08:04:44 <dolio> Why? Why isn't Store interesting?
08:04:58 <dolio> You know that lenses are Store coalgebras, right? I guess lenses aren't interesting.
08:05:02 <dminuoso> dolio: What other than Store do you really get? :)
08:05:22 <dminuoso> You dont pull much weight from a typeclass, if there's only a handful of *similar* instances.
08:06:07 <dminuoso> Im not saying store is not interesting, but you just dont get many other versions of it. Let's ignore Tree/NonEmpty like things, because we can pretend they're just Store in disguise.
08:07:04 <kiwi_45> MarcelineVQ: actually I didn't followed his advice and went with servant auth only, now I am in the middle and I don't know what should be done to overcome this 
08:07:58 <dminuoso> Though thats circular reasoning, since the point of that thread is to explain why that is.
08:08:38 <kiwi_45> MarcelineVQ: btw I think I even didn't read those msg I left the chat for some or other reason
08:11:32 <kiwi_45> is it is not doable with servant-auth ?
08:13:32 <dminuoso> kiwi_45: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
08:13:39 <dminuoso> I urge you to give this a thorough read. Understand it.
08:13:57 <dminuoso> Once you do, go back to the wai-cors documentation and configure it accordingly. :)
08:14:49 <kiwi_45> Thanks dminuoso: I will read it for sure
08:15:48 <dminuoso> (Alternatively you can avoid all the CORS if you just serve the API from the same origin you serve the webpage from)
08:16:18 <dminuoso> But, understanding CORS is useful if you're getting into dealing with websites anyhow.
08:16:20 <kiwi_45> I am serving the webpage with react
08:16:42 <kiwi_45> yeah I have to deal with websites anyhow
08:17:27 <kiwi_45> is there anyoption I can skip CORS for now, as this is my first web project but I need to build a production grade
08:17:41 <dminuoso> kiwi_45: No Im saying that if you access the webpage from `foo.bar`, and you serve the api from `foo.bar` as well (same origin), then CORS is not needed.
08:18:39 <dminuoso> (You can use nginx location matchers for instance to serve everything under /api from a different upstream, and then serve the SPA directly)
08:19:59 <kiwi_45> I want to stick to Haskell only
08:20:09 <dminuoso> Is servant serving the react code as well?
08:20:40 <kiwi_45> I don't know how I can use servant to serve react code too... but I would like if its possible
08:21:17 <dminuoso> You probably shouldn't. :)
08:21:25 <kiwi_45> but servant server is running at different port and react program is running at different port
08:22:11 <dminuoso> Personally I'd just get up to speed with CORS. You only need to make a small modification to your code. If you couldn't understand what to fix from the wai-cors documentation, you should really give the MDN article I linked a read.
08:24:14 <kiwi_45> sure, actually i guessed that I should not put `corsOrigins = Nothing` in corsOrigins :: !(Maybe ([Origin], Bool)) but I am not sure what to put in fst of maybe tuple
08:27:37 <dolio> @define data W a = forall e. W (forall r. (r -> e) -> a)
08:27:38 <lambdabot>  Defined.
08:28:07 <dolio> @type \(W w) -> w id
08:28:08 <lambdabot> W p -> p
08:28:27 <dolio> @type \(W e) -> W (\f -> W (\g -> e (f . g)))
08:28:28 <lambdabot> W a -> W (W a)
08:33:08 <L29Ah> how do i cross compile from amd64 to older amd64?
08:33:23 <L29Ah> my awesome binary misses some instructions on the target machine
08:33:40 <L29Ah> ghc: unrecognised flag: -march=generic
08:37:09 <maerwald> L29Ah: did you run with -v3 and check if it puts native somewhere?
08:37:43 <maerwald> maybe need to overwrite it with -optc and -optl, but I'm not sure
08:39:11 <L29Ah> maerwald: no, it says nothing about native
08:39:20 <L29Ah> probably gcc is native by default, lemme check
08:39:58 <maerwald> then -optc/-optl might help
08:41:18 <halogenandtoast> Can anyone help me with this quantification issue: https://gist.github.com/halogenandtoast/0e90c84946d30ace6d88bb61dd59b840
08:41:31 <monochrom> Cross compile C? Cross compile Haskell?  Because GHC doesn't generate C code at all.
08:42:30 <L29Ah> maerwald: no luck; probably the libraries were miscompiled also
08:42:32 <L29Ah> monochrom: haskell
08:42:59 <monochrom> GHC code generator probably doesn't have options for choosing instruction set.
08:44:22 <ja> i thought -fvia-C was still supported?
08:45:06 <halogenandtoast> I can't figure out how to make the b there not ambiguous (That is should be the same b all the way through really).
08:45:33 <merijn> ja: Not in any of the shipped compilers
08:45:39 <halogenandtoast> I can probably hard-code it but then I have an import cycle, which I guess I can solve with hs-boot, but I was hoping to make it polymorphic somehow.
08:45:41 <ja> L29Ah: i think if you build ghc on an old amd64 machine (or in a qemu with fancy instructions disabled), your new ghc would not use fancy instructions
08:45:50 <merijn> ja: The code exists for bootstrapping new platforms, but it's disabled in the normal GHC builds
08:45:59 <L29Ah> -fvia-C didn't help
08:46:13 <merijn> L29Ah: That's because (for all practical purposes) it doesn't exist
08:47:27 <ja> is the easiest way to get an old distro, run it in qemu with limited instructions enabled, and build a couple of newer ghc's with each other?
08:47:53 <ja> i tried redhat 9 when i wanted to see if i could build ghc without ghc (failed)
08:47:53 <monochrom> I don't know if -fllvm gives you back control or it is an XY problem.
08:48:52 <infinisil> halogenandtoast: You probably need a functional dependency for RunMessage
08:49:12 <infinisil> halogenandtoast: See https://wiki.haskell.org/Functional_dependencies
08:49:21 <ja> i don't know how the llvm backend works, but it is an interesting suggestion! like, llvm must definitely allow selection instruction set, right?
08:49:27 <ja> it has to support march-generic
08:49:31 <infinisil> halogenandtoast: Probably | a -> b
08:50:14 <infinisil> Or the other way, not sure
08:50:44 <infinisil> But also, explicit type annotations can help
08:50:55 <infinisil> With existential quantification
08:51:15 <L29Ah> fvia-C actually works (well, at least it actually calls gcc), but the problem seems to reside in the dependenciesw
08:51:38 <monochrom> ghc always calls gcc. but for unrelated purposes.
08:51:41 <L29Ah> so i'll probably have to start from a clean toolchain
08:51:49 <L29Ah> monochrom: well it wasn't
08:51:53 <halogenandtoast> infinisil: I think I have an easier way, I changed runMessage to class RunMessage a where runMessage :: forall m b. (MonadIO m, HasQueue b) => Message -> a -> ReaderT b m a
08:52:41 <halogenandtoast> The compiler has at least moved on to complaining about different (mostly unrelated) things
08:53:44 <infinisil> Well that's something I guess
08:57:41 <halogenandtoast> infinisil: it did indeed seem to resolve my issue, as it now compiles, and runs correctly, thanks for rubber ducking with me.
08:58:09 <halogenandtoast> (I had tried functional dependencies before, but there was not a unique relation between the types which caused things to blow up)
09:01:06 <sheepfleece> What are actual uses for polymorphic recursion? 
09:01:18 <sheepfleece> I've seen some examples but they were .. pretty strange.
09:01:32 <monochrom> perfect binary tree
09:01:38 <dolio> It's often necessary when using nested types.
09:02:40 <sheepfleece> And I'm also not sure how Haskell generates new dictionaries for it. On the fly at runtime? 
09:07:53 <dolio> Instances like `(Show a, Show b) => Show (a,b)` are dictionary functions.
09:08:42 <sheepfleece> So GHC just applies a dictionary function over a dictionary and passes that?
09:08:52 <NewToHaskell> I want to add 1 to the end result, like this `sqrtSums = ( length . takeWhile (<1000) . scanl1 (+) . map sqrt $ [1..] ) + 1 `, can I do it any other way without the parentheses?
09:09:23 <dolio> It knows how to build the dictionaries for the recursive call from the dictionaries that it has.
09:09:26 <monochrom> ( (+ 1) . length . ...
09:09:35 <dolio> That is statically resolved.
09:10:30 <NewToHaskell> monochrom, cheers. :)  
09:11:16 <sheepfleece> dolio: Yep, thank you!
09:12:27 <sheepfleece> I also wonder whether GHC can somehow use levity-polymorphism to implement the kind of polymorphism implemented here. https://github.com/ollef/sixten
09:13:15 <sheepfleece> I wonder how it might interact with laziness and type erasure
09:13:42 <NewToHaskell> Why does their example 
09:14:18 <NewToHaskell> nvm. =)  
09:20:00 <BosonCollider> I've been playing around with Smalltalk images & thinking for a bit, about whether or not a runtime that dynamic actually could be achieved in a functional language with strong static typing
09:24:19 <BosonCollider> I actually think strong static typing with no distinction between runtime types and compile-time types makes a number of things easier
09:25:43 <BosonCollider> since with type erasure generics it becomes very easy to hotswap in new function implementations that have the same type signature
10:25:32 <c_wraith> BosonCollider: the obstacle is data types.  What happens when you change a data type definition?
10:26:53 <BosonCollider> right, that's what I've been thinking about, and for a persistent VM its a tooling issue
10:27:11 <c_wraith> especially when it's an important nominal change that doesn't have a representational change?
10:27:13 <BosonCollider> for a concrete data type the VM could ask you to write a function from the old type to the new one
10:27:32 <BosonCollider> for a typeclass update, it gets trickier
10:31:25 <BosonCollider> Which kind of led me towards thinking about first class modules, and implementing other type system features as macros on top of modules
10:38:57 <dminuoso> BosonCollider: So hotswapping Haskell code is done at facebook at large scale.
10:40:01 <BosonCollider> huh, that's interesting
10:40:12 <dminuoso> https://hackage.haskell.org/package/ghc-hotswap
10:41:46 <dminuoso> BosonCollider: There was a talk at Haskell eXchange 2018 about it, which discusses how it works and what limitations it has.
10:42:40 <dminuoso> https://skillsmatter.com/skillscasts/11654-keynote-how-to-deploy-your-haskell-code-hundreds-of-times-a-day
10:44:25 <justsomeguy> BosonCollider: I recently read Alan Kays paper "The Early History of Smalltalk", and it almost sounded like he was talking about FP. (He mentions trying to get rid of assignment, and representing algebras, and an emphasis of message passing between objects as opposed to objects as records with getters/setters.) It's kind of interesting to think about.
10:44:29 <dminuoso> This is of course GHC specific.
10:48:12 * hackage lambdabot-xmpp 0.1.0.5 - Lambdabot plugin for XMPP (Jabber) protocol  https://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.5 (SergeyAlirzaev)
10:54:05 <BosonCollider> Yeah, the toughest thing seems to be how to handle interfaces
10:54:34 <dminuoso> Well for hotswapping code you dont.
10:55:09 <BosonCollider> right, it's easy to do hotswaps by just forcing everything to have the same type signature as before
10:56:12 <BosonCollider> while actually doing a larger refactor is harder, and Smalltalk handles that by simply letting the user handle the tough parts and adding tooling/IDE support
10:57:42 <dminuoso> to be fair, we have builtin support for dynamic types
10:58:23 <dminuoso> That can get you quite far, even in case of "changing interfaces" as long as you dont mind generational data types, where a modification would result in a new data type.
10:58:37 <BosonCollider> but it should still be possible to update types & do a major refactor live on a VM if you are forced to update everything that gets affected
10:58:38 <BosonCollider> huh
11:00:28 <dminuoso> Both Typeable and Dynamic explore various dimensions.
11:06:10 <BosonCollider> ended up with some reading material and projects to look at lol, thanks
11:21:11 <kuribas> Why does the Header type in servant-client generates a Maybe value, while in servant-server it is mandatory?
11:21:19 <kuribas> https://hackage.haskell.org/package/servant-server-0.17/docs/Servant-Server.html
11:23:02 <kuribas> https://hackage.haskell.org/package/servant-client-core-0.17/docs/Servant-Client-Core-HasClient.html#t:HasClient
11:24:29 <kuribas> hmm, maybe the documentation is just wrong
11:24:55 <kuribas> type Client m (Header' mods sym a :> api) = RequiredArgument mods a -> Client m api
11:24:55 <kuribas>  
11:33:42 * hackage fused-effects-random 1.1.0.0 - Random number generation for fused-effects.  https://hackage.haskell.org/package/fused-effects-random-1.1.0.0 (robrix)
12:20:36 <kuribas> Nope, it's not a documentation error
12:22:34 <Uniaika> . :)
12:23:25 <maerwald> lol
12:29:55 <kuribas> ah no, it's also Maybe in the server
12:33:30 <kuribas> Header' '[Required, Strict] does the job :-)
12:33:46 <kuribas> So I can get rid of servant-auth which is to  much magick
12:34:39 <EvanR> haskell is often confused with alien tech. The 's everywhere reinforces it
12:36:51 <kuribas> I need to randomly put primes inside identifiers. l'oginn upc'ase
12:41:29 <kuribas> or better: upk'asze
12:42:02 <operand> Isn't that closer to Elvish rather than alien? :)
12:42:12 <kuribas> hmm true
12:42:37 <kuribas> well, star gate does this trick often
12:42:49 <operand> damnit, i can't find the tweet i saw once about "The Elven prince came from such a royal bloodline, he had 11 apostrophes in his surname"
12:43:09 <kuribas> klingon as well
13:08:41 * hackage servant-seo 0.1.1 - Generate Robots.txt and Sitemap.xml specification for your servant API.  https://hackage.haskell.org/package/servant-seo-0.1.1 (swamp_agr)
13:41:38 <hseg> still trying to get my term algebra code working. current wip at http://ix.io/2rtj, errors in the bottom comment
13:42:48 <hseg> oh wait
13:43:04 <hseg> oh wait
13:46:03 <hseg> nm, forgot i needed to lift the cata
13:46:48 <infinisil> That's some pretty bad naming
13:47:05 <infinisil> But maybe intentional I guess
13:47:58 <hseg> ?
13:50:07 <hseg> ok, got it working mod incomplete pattern matches http://ix.io/2rtp 
13:50:26 <hseg> am unsatisfied with result -- surely there's a less hacky way of doing this?
13:52:42 * hackage protocol 0.1.0.0 - Model distributed system as type-level multi-party protocol  https://hackage.haskell.org/package/protocol-0.1.0.0 (epoberezkin)
14:00:17 <L29Ah> sounds badass
14:09:37 <L29Ah> is there a way to avoid writing all those `liftIO`s in my ReaderT IO code?
14:12:59 <dminuoso> L29Ah: Only if the primitives you are using are monadio polymorphic
14:13:25 <dminuoso> If you frequently use a certain set of API functions, you could wrap them in liftIO and thus make them MonadIO polymorphic for your code
14:13:42 * hackage hie-bios 0.6.0 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.6.0 (fendor)
14:15:36 <hseg> any recommendations on how to improve my extensible free universal algebra?
14:16:19 <hseg> ... probably should've gone for lower-powered options, i guess
14:20:00 <hseg> basically, want: cata :: (f a -> a) -> mu f -> a, sum :: (f a -> a) -> (g a -> a) -> ((f+g) a -> a)
14:21:31 <hseg> :facepalm:
14:21:34 <hseg> sum = either
14:23:48 <hseg> could just have sgp a=a^2, (mon-sgp) a=1, (grp-mon) a=a, write algebras for these, then take Sgp = mu sgp, Mon = mu (sgp+(mon-sgp)), Grp = mu (sgp+(mon-sgp)+(grp-mon))
14:26:57 <hseg> problem with this approach is the explicit sums
14:28:11 <hseg> would need a smart constructor for the algebra for each subset of the function symbols
14:28:41 * hackage protocol 0.1.0.1 - Model distributed system as type-level multi-party protocol  https://hackage.haskell.org/package/protocol-0.1.0.1 (epoberezkin)
14:28:42 <hseg> as well as a unified way of accessing the right indeces
14:29:04 <_xor> maerwald: FreeBSD :/
14:29:18 <maerwald> _xor: lol
14:29:37 <maerwald> _xor: you should be able to install 8.10.1 at least
14:29:46 <_xor> maerwald: Any idea what the biggest hurdle is in porting from 8.8.3 -> 8.10.1?  I'd give it a shot if there's a chance it's <2-3 hours.
14:29:53 <maerwald> 8.8.3 too, but I'm not sure if it works
14:29:57 <maerwald> I built it manually
14:30:02 <_xor> 8.8.3 is what I have now, the port works fine.
14:30:08 <maerwald> what?
14:30:13 <_xor> Hasura upgraded to 8.10.1 though.
14:30:24 <maerwald> I'm talking about the ghcup versions only
14:30:43 <_xor> `ghcup install 8.10.1` failed for me last night.
14:30:46 <_xor> I'll try again in a bit.
14:30:53 <_xor> Gotta finish making this chili first :D
14:31:05 <_xor> Yes yes, I know, y'all are jealous.  It's ok.
14:32:54 <_xor> Oh, it appears to be working now. What sourcery is this? Was it made available in the past 12 hours or something?
14:35:18 <maerwald> yes
14:35:59 <hseg> ... of course, could dually go the tagless-final route and just write a class for each function symbol, with instances giving the various algebras
14:36:00 <_xor> Sweet!
14:37:43 <hseg> unclear how to parametrize these algebras though. pretty printer is easy to parametrize -- just cps the result on the parameters 
14:39:16 <hseg> but how would you tagless-final the evaluator algebra for the term algebra on a binary operator, parametrized on the particular operator? 
14:39:32 <hseg> extensibly, i mean?
14:43:12 <hseg> hrm... dualizing the trick i've been using for initial algebras, could write newtype W p a = W (p -> a), and then have instance _Sym (W (p, r) a) pick off the p parameter
14:43:41 <hseg> this would imply an ordering to the parameters, which i would be ok with
15:41:21 <hseg> ok, so here's a quick-and-dirty finally-tagless approach http://ix.io/2rtM
15:42:53 <hseg> i like this style. haskell 98ish, pretty transparent. only annoyance is how this version forces me to encode my parameter list as a nested sequence of pairs
15:44:27 <hseg> ... ofc, i *could* use van Laarhoven's inhomogeneous recursion trick to push down the parameters...
15:45:11 <maerwald> I see
15:47:10 <hseg> i.e. do sth like Magma (Tree p pa a) => UMagma (Tree a (p->pa) a)
15:47:34 <hseg> (where i keep a phantom a parameter to track the carrier)
15:48:39 <hseg> ofc, that adds layers of wrapping/unwrapping, but at least this is relatively transparent
15:49:47 <hseg> ... indeed, instead of reinventing my own hierarchy, could reuse the group/ring hierarchies i'm cloning here
15:50:04 <maerwald> right
15:50:18 <hseg> nice
15:51:05 <hseg> am i missing a hidden cost or caveat here?
15:51:52 <hseg> looks like for all that initial algebras are touted as a solution to the expression problem, this finally tagless approach solves my problem with relatively transparent boilerplate
15:53:04 <hseg> raises question if a) the approaches are equivalent and b) what the conversion costs are
15:53:40 <hseg> initial algebra approach looks theoretically nicer, but finally tagless looks more practical so far
16:09:03 <hseg> ok, thanks!
16:10:46 <maerwald> basically
16:25:12 * hackage country 0.2.1 - Country data type and functions  https://hackage.haskell.org/package/country-0.2.1 (chessai)
17:36:12 <curiousgeorge> could someone please tell me
17:36:22 <curiousgeorge> why this works fine
17:36:24 <curiousgeorge> takeWhile (<10000) $ map (^2) [1,3..]
17:36:37 <curiousgeorge> but this never terminates
17:36:38 <curiousgeorge> filter (<10000) $ map (^2) [1,3..]
17:36:39 <curiousgeorge>  ?
17:36:43 <curiousgeorge> whats the difference
17:38:21 <frdg> I am trying to import `Database.Persist.Postgresql` but keep getting a cannot find import error. What is strange to me is that I am able to successfully import both `Database.Persist` and `Database.Persist.TH`. Looking on hackage it appears that I have taken the proper steps. Am I missing something?
17:43:10 <jchia> curiousgeorge: Those two programs do different things, even for finite lists
17:43:22 <dolio> They left.
17:50:20 <xsperry> takeWhile stops when the predicate returns false, filter doesn't
17:54:42 * hackage heredocs 0.2.0.0 - Heredocument on Haskell  https://hackage.haskell.org/package/heredocs-0.2.0.0 (KatsutoshiItoh)
17:54:46 <frdg> When I add persistent-postgresql to my .cabal file and compile I get this error: https://pastebin.com/5DddN0P9
17:55:35 <frdg> normally If I have an import error I am told by the compiler potential packages to add to my cabal file but I have not this time.
17:55:41 * hackage trek-db 0.1.0.0 - A PostgreSQL Database Migrator  https://hackage.haskell.org/package/trek-db-0.1.0.0 (JonathanFischoff)
17:56:42 * hackage massiv 0.5.3.2 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.3.2 (lehins)
18:00:12 <frdg> is it just a coincidence that right under my last post is the hackage bot showing a postgresql migrator?
18:17:42 * hackage trek-app 0.1.0.0 - A PostgreSQL Database Migrator  https://hackage.haskell.org/package/trek-app-0.1.0.0 (JonathanFischoff)
18:35:15 * dsal slightlycuriousgeorge
18:41:42 * hackage xml-types 0.3.8 - Basic types for representing XML  https://hackage.haskell.org/package/xml-types-0.3.8 (StephenWeber)
19:18:19 <jackdk> Does anyone know of a good package which provides `class Monoidal f where { unit :: f () ; (>*<) :: f a -> f b -> f (a, b) }`? The one in `invertible` is no good to me; I want to abstract over both `Applicative` and `Divisible`. I could see myself adding it to either `invariant` or `semigroupoids` (with corresponding `class SemiMonoidal`).
19:22:35 <Cale> jackdk: Isn't that just Applicative with a different basis?
19:22:59 <Cale> Applicative could just be exactly that
19:23:49 <Faye> it doesn't have pure Cale 
19:23:58 <Cale> pure v = fmap (const v) unit
19:24:00 <jusss> what Yoneda lemma is used for?
19:24:14 <Faye> ahh yeah
19:24:16 <Faye> hm
19:24:38 <jusss> and Howard-Curry stuff
19:24:51 <Cale> mf <*> mx = fmap (\(f,x) -> f x) (mf >*< mx)
19:26:28 <Cale> and going the other way, you have  unit = pure ()  and  x >*< y = liftA2 (,) x y
19:26:54 <Faye> yeah. You don't get fmap though so Monoidal is not necessarily a functor
19:27:11 <Faye> I think the idea is that (Contravariant f, Monoidal f) = Divisibile f
19:27:20 <Faye> and (Functor f, Monoidal f) = Applicative f
19:27:37 <Faye> so jackdk wants to abstract over any monoidal, regardless of it's variance
19:27:39 <Cale> Oh, I see
19:28:22 <Faye> yeah
19:29:00 <Faye> although idk how powerful such abstraction would be, since the tools are very limited w/o fmap and contramap
19:30:00 <Faye> it would be nice if Haskell had a way to be polymorphic over whether we're doing work over Hask or Hask^op
19:30:18 <Faye> so you could express these concepts cleanly
19:30:18 <Cale> Seems like an unusual thing to want though.
19:30:32 <Faye> yeah but I'm a mathematician not a programmer :P
19:31:10 <Faye> I try not to make comments about what's practical for use. This is just something that I'd like to play around with
19:31:36 <Faye> I also wish that Haskell had a way to express "Oh I have this associated type family for this type class. I also require an instance definition of this form to go with the type class / family"
19:32:00 <Faye> Out of my desire to express "This arbitrary category C is monoidal
19:32:05 <Faye> " using Haskell type-classes
19:32:38 <Faye> where the categories can be very weird (for example the functor category [Hask, Hask])
19:32:44 <Cale> I kind of feel like figuring out a way to repurpose the new linearity polymorphism and make it more usable by letting you pick different categories. On the other hand, I don't know why you wouldn't just quantify over the arrow itself.
19:33:08 <Faye> That would be interesting yeah
19:33:22 <Faye> cool stuff ^^
19:33:26 <Faye> anyway I should take a bath
19:33:40 <Cale> I can think of lots of uses for repurposing the lambda calculus syntax for other categories, but not many of them are even linear.
19:33:50 <Cale> and linear (->) doesn't really excite me
19:37:42 <jackdk> The reason I want this thing is I'm playing around with applicative (possibly monadic) decoders/parsers and divisible encoders. I want to do useful things when I have the corresponding encoder/decoder paired in a "var", at which point I only have an invariant functor `class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b` and the `Monoidal` described above.
19:38:03 <jackdk> (in fact, should `Invariant` be a superclass of `Monoidal`?)
19:43:28 <Cale> jackdk: ahhh, hmm
19:46:57 <Cale> We ended up with a library for a monoidal category of things which encode and decode simultaneously -- aimed at encoding/parsing URLs for web applications, but really it's more general than that. You might be interested in it though. Frankly it can be a bit awkward sometimes, but it does help guarantee that the encoding is injective (so that it'll be reversible)
19:47:58 <Cale> https://github.com/obsidiansystems/obelisk/blob/develop/lib/route/src/Obelisk/Route.hs -- this shenanigans
19:48:39 <Cale> Apologies for that actually being like two or three separate ideas going on in that module. Maybe I should pull it apart so it would make more sense.
19:49:32 <Cale> But maybe what you're doing would provide a nice way to decompose the internals of our category.
19:50:53 <jackdk> so I think the guts I'm most interested in are teh Control.Category.Monoidal instances?
19:51:13 <Cale> yeah
19:51:20 <Cale> maybe :)
19:51:57 <Cale> But I don't know, maybe this suggestion is a bit of a nonsequitur
19:52:52 <jackdk> possibly. You have the encoder and decoder baked into the same structure. My actual goal is to build applicative and divisible decoding/encoding machinery for environment variables, because I don't like the existing libraries I've seen.
19:54:07 <Cale> and frankly, this route library can be a bit of a pain to actually use sometimes, because figuring out what pieces are possible to build when everything is required to be injective can be kind of tricky
19:54:28 <jackdk> Once you have those, you can wire them up with StateVar to get a nice interface, but if you want a full statevar you need to glue them together. While it's possible to build the encoder and decoder in parallel, it would be nice to have a way to use the invariant/monoidal class machinery so you know that roundtripping is preserved by construction
19:55:37 <Cale> Well, the round-tripping-by-construction is kind of the problem that this thing does tackle...
19:56:30 <Cale> But yeah, if you come up with something you think is both easy to program and maintains those guarantees, I'll also be interested, since in my experience, it comes at a cost in awkwardness.
19:59:25 <jackdk> I think I'll find that my usecase is much simpler than yours, and won't need as sophisticated machinery. If I make something good, I will let you know.
20:00:20 <jackdk> I should've been clear at the start: the reason why the `Monoidal` class in `invertible` is no good to me is because it has a `Functor` superclass constraint.
23:16:59 <rand809809> If I have two megaparsec parsers, let's say string and char, and I chain them like char ' ' <*> string "what", if this parser fails on the letter 'w', will it backtrack to before 'w'?
23:17:21 <rand809809> I know char ' ' doesn't back track and string does
23:18:13 <rand809809> I have this https://gist.github.com/bananabrick/c565412e87c7644bb3f853c8a4dea686
23:18:26 <rand809809> and the parser fails to match the string " wtf"
23:18:33 <rand809809> but matched "wtf" and " huh"
23:19:18 <rand809809> strSp is essentially strSp s = space $ string s
23:19:35 <rand809809> Does anyone here know what's up
23:22:03 <hololeap> you have a choice combinator which returns the first parser that succeeds
23:22:15 <hololeap> with ' huh' the first one succeeds
23:22:30 <hololeap> the second one succeeds with 'wtf'
23:22:50 <hololeap> none of them succeed with ' wtf'
23:24:12 <Cale> hololeap: Why wouldn't strSp match that?
23:24:27 <rand809809> why doesn't ' wtf' succeed?
23:24:32 <rand809809> is my question
23:24:49 <rand809809> strSp is defined as strSp s = space $ string s
23:24:53 <Cale> rand809809: I think the problem is indeed that the first choice matches the ' ', and megaparsec commits to it.
23:25:28 <Cale> Try swapping the two choices, and see if it now matches " wtf" and doesn't match " huh"
23:26:09 <hololeap> or try wrapping the first combinator in `try`
23:26:16 <Cale> Well, yeah, that'll be the solution :)
23:26:33 <rand809809> yea i did a choice $ map try [..
23:26:42 <rand809809> but I was trying to figure out why exactly this is happening
23:26:50 <hololeap> i think Cale nailed it
23:28:02 <Cale> As soon as a (non-try) parser eats a single character, all the other branches of the choice get discarded -- this is done for efficiency's sake. Once you know you'll never have to backtrack, the earlier parts of the string can be discarded
23:28:40 <hololeap> the first parser consumes " h" and then fails, leaving a string that will not get matched further down
23:28:52 <rand809809> when I swap the two, both " wtf" and " huh" get matched
23:29:12 <Cale> Oh, interesting
23:29:24 <Cale> haha, let me go look at the definition of spaces
23:29:26 <hololeap> that
23:29:34 <hololeap> is the expected result
23:30:17 <Cale> Doesn't that imply that space is already wrapped in try?
23:30:56 <rand809809> oh nvm
23:31:04 <rand809809> i forgot that i had wrapped the whole thing in try
23:31:10 <rand809809> my bad
23:31:22 <hololeap> Cale: good point
23:31:43 <Cale> Yeah, without any try, when you swap them, it should swap which one actually works
23:32:04 <rand809809> okay, now I have this https://gist.github.com/bananabrick/c565412e87c7644bb3f853c8a4dea686
23:32:15 <rand809809> and " wtf" works but " huh" fails
23:32:23 <Cale> yep
23:32:36 <Cale> So that confirms that it's what I thought
23:33:19 <Cale> You might also just want to move the matching of spaces outside of the choice
23:33:21 <rand809809> but I have string "wtf", and string "huh" without try then both "wtf" and "huh" match
23:33:35 <Cale> They start with different letters
23:33:51 <Cale> If it was string "what" and string "wtf"
23:33:57 <Cale> then they could trample each other
23:34:04 <rand809809> hmm
23:34:14 <Cale> It commits to the parser as soon as a single character is matched
23:34:30 <Cale> (unless it's wrapped in try, which hides the parser's consumption)
23:35:10 <rand809809> https://gist.github.com/bananabrick/c565412e87c7644bb3f853c8a4dea686
23:35:12 <rand809809> this matched both
23:35:42 <Cale> Interesting
23:36:18 <rand809809> Also, why would moving spaces outside of the choice fix it?
23:36:40 <Cale> Because then the whitespace will be eaten before you get to the choice
23:37:01 <Cale> and so the parsers inside won't have the opportunity to commit just by eating whitespace
23:37:13 <Cale> It won't help if they still overlap
23:37:15 <rand809809> oh right
23:37:42 <rand809809> I think I read that string backtracks on failure, but I guess chaining string with space gets rid of that property?
23:37:52 <Cale> However, maybe megaparsec is doing something a little subtler when it comes to string if both of those work
23:38:07 <Cale> Maybe string is all-or-nothing still
23:38:14 <Cale> which would make sense, that would be convenient
23:38:25 <rand809809> I think it is. But then why was it ever failing?
23:38:48 <Cale> ahh!
23:39:13 <Cale> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:chunk
23:39:25 <Cale> er no, this one: https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:tokens
23:39:38 <Cale> "Note that beginning from Megaparsec 4.4.0, this is an auto-backtracking primitive, which means that if it fails, it never consumes any input."
23:39:52 <Cale> string :: MonadParsec e s m => Tokens s -> m (Tokens s)
23:39:52 <Cale> string = chunk
23:40:04 <Cale> chunk = tokens (==)
23:40:16 <Cale> and that comment about tokens explains it
23:40:35 <Cale> So it's like each occurrence of string is individually wrapped in try
23:41:08 <rand809809> Right, but then why was it failing if string was indeed backtracking
23:41:26 <Cale> Because the matching of spaces wasn't part of the argument to string
23:41:30 <Cale> it was a separate parser
23:41:42 <Cale> If you'd written  string " wtf"
23:41:47 <Cale> that would be all-or-nothing
23:42:35 <rand809809> when I have " wtf", the failure point is the 'w', so I was expecting the parser to be at position, 'w' when it tried the strSp "huh" parser
23:42:38 <Cale> So it's not true that  liftA2 (++) (string x) (string y)  is the same as  string (x ++ y)
23:43:27 <rand809809> since string failed and I was expecting it to backtrack to just after the space
23:43:53 <hololeap> looking at it from my end and it does seem a bit unintuitive
23:44:09 <Cale> It's like each parser has the option to say "okay, I'm going ahead, you can cancel all the alternatives, and if I fail, the whole parse fails"
23:44:17 <hololeap> parseMaybe (choice [string "foob", string "foo"]) "foo"  ==>  Just "foo"
23:44:27 <Cale> and when it signals that will depend on the parser in question
23:44:33 <hololeap> parseMaybe (choice [string "foo", string "foob"]) "foob"  ==>  Nothing
23:45:37 <rand809809> parseMaybe (choice [string "foo", string "foob"]) "foob"  ==>  Nothing, this is cause "foo" succeeded
23:45:41 <Cale> They apparently changed it in Megaparsec 4.4.0 so that string (and any other stuff based on the 'tokens' primitive) now only signals that once it has fully succeeded
23:46:16 <rand809809> okay, so the idea is that "space" is signalling as soon as it starts?
23:46:39 <Cale> Even if space only signals it once it finishes, that's still before you start matching the next bit
23:46:58 <hololeap> so `string "foo"` succeeds, it doesn't backtrack, but the overall `choice` fails?
23:47:13 <rand809809> choice doesn't go to the next one on success
23:47:17 <Cale> Like, if you have space *> string "foo", and the space succeeds, it's going to say "okay, cancel all the other choices now"
23:48:18 <Cale> Or if you have string "foo" *> string "bar" and the string "foo" succeeds, it'll cancel the alternatives as well
23:48:45 <Cale> But now if you just hit an 'f', it won't commit to the string "foo" like it would in earlier versions.
23:48:58 <rand809809> yea, the cancelling all other choices part is odd. In my opinion, all other choices should only be cancelled if the current choice succeeds
23:49:23 <Cale> Well, consider the case where the choice determines how to parse the entire rest of the file, or some very large chunk of it
23:49:38 <Cale> If you don't commit, then the whole file will have to remain in memory
23:50:05 <Cale> You won't be able to begin garbage collecting the start of the file, because you always *might* backtrack
23:50:20 <Cale> and there's no way of knowing until you're done the whole parse
23:51:21 <Cale> So, this is an annoying optimisation to make sure that the initial part of the input string becomes garbage as soon as possible
23:52:03 <rand809809> Interesting
23:52:15 <rand809809> I still don't understand the part about "signalling"
23:52:22 <rand809809> consider, Var <$> strSp "huh" <|> Var <$> strSp " wtf"
23:52:36 <rand809809> This parser fails to match " wtf"
23:52:47 <Cale> There are ways of making it run both parsers simultaneously, so that it can collect the start of the file, but at the cost of usually wasting work.
23:52:52 <rand809809> what is the "signalling" here?
23:53:12 <rand809809> Since the first one failed and we got `Nothing` why doesn't it try the second one?
23:53:31 <hololeap> intuitively, i would think that `parseMaybe (choice [a, string s]) s` would always succeed, but apparently that's not the case
23:53:36 <Cale> Because the space inside strSp succeeded
23:54:06 <hololeap> because of this heuristic
23:54:20 <Cale> and as soon as that happened, the running parser effectively became  Var <$> strSp "huh"
23:54:25 <Cale> i.e. without the <|>
23:55:06 <rand809809> How is that even possible? Wouldn't that depend on the definition of <|> for this parser?
23:56:02 <rand809809> <|> only understands its left argument as a single parser. It doesn't know about space and string. So, how does it even know that space "succeeded"
23:56:40 <rand809809> Shouldn't it only know whether the entire parser failed or succeeded. How is it inspecting the internals of the parser?
23:56:42 * hackage HaskellAnalysisProgram 0.1.0 - Haskell source code analysis program  https://hackage.haskell.org/package/HaskellAnalysisProgram-0.1.0 (BastiaanHeeren)
23:57:00 <Cale> I guess we have to actually look at the definition of ParsecT and <|> and various other primitives to see how that works
23:57:54 <Cale> When a parser runs, there are essentially 4 possibilities
23:58:07 <Cale> It can succeed consuming input
23:58:12 <Cale> It can fail consuming input
23:58:20 <Cale> It can succeed without consuming input
23:58:28 <Cale> Or it can fail without consuming input
23:58:49 <Cale> try makes a parser into one which, when it fails, it fails as if it never consumed any input
23:58:52 <rand809809> I guess fail consuming input implies don't try the second alternative?
23:59:07 <rand809809> yea, I can buy that. Thanks!
23:59:10 <Cale> x <|> y will run x, and if it fails without consuming input, will try y instead
