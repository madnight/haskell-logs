00:06:19 * hackage smtp-mail 0.3.0.0 - Simple email sending via SMTP  https://hackage.haskell.org/package/smtp-mail-0.3.0.0 (typetetris)
00:45:48 * hackage reliable-io 0.0.1 - Bindings to the low-level reliable.io library.  https://hackage.haskell.org/package/reliable-io-0.0.1 (Mokosha)
01:10:16 <L29Ah> is there a library implementing an interface between a socket and the binary's Get, allowing incremental parsing?
01:14:50 <merijn> binary-conduit? :)
01:15:26 <merijn> Assuming you mean to parse a stream of records or some such
01:15:47 <L29Ah> yeah, thanks
01:16:13 <L29Ah> in fact it's a msgpack-based rpc
01:23:21 <merijn> ...
01:24:00 <merijn> Did I seriously just read a "Haskell competency matrix" that lists "lenses" as intermediate knowledge, but parameterised types as "advanced/senior"?
01:24:39 <merijn> https://i.imgur.com/CIr7TvC.jpg
01:26:12 <Taneb> merijn: are not-parametric lenses a thing that even make sense?
01:28:34 <lortabac> as far as I understand the matrix mentions "parametrized types" in general as advanced
01:29:18 <merijn> lortabac: Yes, Taneb's point was that all useful lenses are parameterised too
01:29:23 <merijn> So it's doubly weird
01:29:27 <lortabac> oh I see
01:29:30 <lortabac> haha
01:33:48 <Taneb> Parametric types are so core to Haskell they should be late beginner at the latest
01:36:30 <lortabac> haha kinds are in the "intermediate" column
01:37:05 <lortabac> maybe they mean something else by "parametrized types"
01:39:16 <Taneb> Maybe DataKinds type things?
01:43:01 <kittivelae> hello all. Is there an up to date place I can search past logs? the wiki suggests http://ircbrowse.net/browse/haskell but that just points to a parked url
01:44:48 <merijn> The link in the topic? Although that doesn't really have search
01:46:22 <kittivelae> yeah im using that, no worries if thats all there is, ill just download them all later, cheers
01:49:24 <L29Ah> https://i.imgur.com/YbQtlXm.png
01:55:47 <kittivelae> can I pick up a language like this by doing and just banging my head against the documentation when I don't get something, or is there a tutorial out there that has a more learn-as-you-do while working on a small project approach? I have a genuinely awful attention span and struggle with most typical programming tutorials
01:57:29 <kittivelae> ignore me, i just found the tutorials page on the wiki
01:57:50 <merijn> In theory a good "learn-as-you-do" thing could exist, but I'm not really aware of one and certainly not any free ones
01:58:11 <merijn> There's a bunch of books, but I think a lot of those also are pretty heavy on the reading
01:58:58 <kittivelae> i found this: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
01:59:21 <kittivelae> ive tried to learn in the past but havent managed just due to other uni commitments
02:01:04 <L29Ah> kittivelae: have you poked Real World Haskell?
02:03:54 <kittivelae> butn im coming back to it now because my masters project is written in java, on top of code written by about 5 other students, and its all really bad oop. I've spent 2 months basically repaying their technical debt with no progress on thesis and i have like a month left. The conclusion I have is that I really dont like OOP as a paradigm and no I havent but I will thank-you!
02:04:06 <kittivelae> oops that was a tangent
02:04:09 <kittivelae> sorry
02:43:19 * hackage gotta-go-fast 0.3.0.0 - A command line utility for practicing typing  https://hackage.haskell.org/package/gotta-go-fast-0.3.0.0 (callum_oakley)
02:44:29 <dminuoso> merijn: Hold on, so Maybe is an advanced/senior feature?
02:45:37 <Arahael> merijn: Nobody is pointing out that the senior avoids haskell, that's the remarkably *uncontroversal* outcome I'm seeing with all this. ;)
02:46:49 * hackage regex-applicative 0.3.4 - Regex-based parsing with applicative interface  https://hackage.haskell.org/package/regex-applicative-0.3.4 (RomanCheplyaka)
02:54:05 <maerwald> merijn: I think these things give ppl more anxiety, although the idea was with positive motivation. What's more useful is listing all those topics and showing what their *dependencies* are. That allows you to learn more strategically
02:55:56 <maerwald> no point in having instagram style images of haskell programmers
02:56:14 * maerwald puts on his mighty lenses...
03:07:06 <merijn> maerwald: Yeah, that's what I was getting at, a lot of these lists make things seem way more daunting than they are
03:07:31 <jumper149> When exactly can you write numeric literals for a type?
03:07:34 <merijn> Like, I'm not even convinced lenses are needed for advanced/senior haskell, let alone intermediate...that depends entirely on what kinda stuff you do
03:07:39 <nil> with haskeline, is there a way to implement catchError for `MonadError e m => MonadError e (InputT m)` ?
03:14:13 <nil> apparently it's just a stack of ReaderT's so it should be doable, but the module doesn't export the InputT constructor...
03:16:53 <solonarv> jumper149: if the literals are integers, you need a Num instance. if the literals are fractional, you need a Fractional instance.
03:17:56 <merijn> jumper149: You can easily check :)
03:17:58 <merijn> :t 1
03:17:59 <lambdabot> Num p => p
03:18:02 <merijn> :t 1.0
03:18:03 <lambdabot> Fractional p => p
03:18:22 <jumper149> merijn: That was smooth ^^
03:18:42 <jumper149> but it does make sense
03:19:22 <merijn> Although I would caution against making types that don't represent numbers instances of those classes
03:19:40 <solonarv> there is a GHC extension (NumDecimals) that relaxes this a little: if a fractional literal is actually an integer (like 1.0, or 1e100) then it only requires Num
03:20:06 <merijn> NumDecimals is amazing and should go into the next report (you know, circa 2050 or something >.>)
03:20:12 <solonarv> heh
03:20:36 <solonarv> it makes the rule very simple: if the literal's value is an integer, then you need Num. otherwise you need Fractional.
03:21:46 * enikar thinks: why not an Integral instance for integers?
03:22:15 <merijn> electrostat: Because then you couldn't write "1" for Double
03:22:23 <merijn> s/electrostat/enikar
03:22:57 <enikar> ok
03:23:02 <enikar> ty
04:11:49 * hackage streamly-archive 0.0.1 - Stream data from archives using the streamly library.  https://hackage.haskell.org/package/streamly-archive-0.0.1 (shlok)
04:39:25 <carbolymer> ok, what happened here: https://bpa.st/6VZA - why bar . foo isn't a -> b -> c ?
04:41:37 <L29Ah> @type seq
04:41:38 <lambdabot> a -> b -> b
04:41:41 <noname> question: release candidates in hackage are compiled ?
04:41:42 <L29Ah> @type length
04:41:43 <lambdabot> Foldable t => t a -> Int
04:41:54 <L29Ah> @type length . seq
04:41:55 <lambdabot> error:
04:41:55 <lambdabot>     ‚Ä¢ No instance for (Foldable ((->) a0))
04:41:55 <lambdabot>         arising from a use of ‚Äòlength‚Äô
04:44:47 <etherealemb87> I'm considering a job offer at a start up. Their production code is written exclusively in Haskell...does anyone have any thoughts on whether this is something to be concerned about? 
04:47:13 <L29Ah> we aren't concerned about this so just toss the offer to us ;)
04:48:28 <maerwald> merijn: with a better record system in haskell, lenses will be even more of a special use case
04:50:13 <L29Ah> https://idris2.readthedocs.io/en/stable/reference/records.html ;]
04:51:49 * hackage transient 0.7.0.0 - composing programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.7.0.0 (AlbertoCorona)
04:55:40 <maerwald> most top-level lenses ppl have is really just the lensified records...
05:06:49 <Lycurgus> telling that the hs shop would  make an offer to someone with no hs
05:10:25 <Lycurgus> but I guess a "startup" is short of a "shop"
05:15:13 <kuribas> maerwald: lenses handle deeply nested data.
05:15:20 <kuribas> records cannot solve this.
05:15:34 <maerwald> depends
05:15:42 <maerwald> on the record system
05:15:44 <kuribas> I find with the recordWildCards extension I don't really need lenses just for records.
05:17:43 <Orbstheorem> Can I have stack use nix for its transitive dependencies, instead of downloading and compiling them over?
05:22:21 <phadej> as far as I understand you can use haskell.nix to build stack projects too. https://input-output-hk.github.io/haskell.nix/tutorials/getting-started/
05:23:42 <phadej> but I have no idea if you can drop into a shell where `stack` won't try to rebuild anything, it's tricky with cabal, and I think it's at least as tricky with stack
05:23:49 * hackage gemini-router 0.1.0.0 - A simple Happstack-style Gemini router  https://hackage.haskell.org/package/gemini-router-0.1.0.0 (fgaz)
05:24:49 * hackage language-gemini 0.1.0.0, gemini-textboard 0.1.0.0, gemini-server 0.1.0.0 (fgaz): https://qbin.io/trends-venice-p6jd
05:25:57 <maerwald> embrace cabal-cache
05:28:28 <Orbstheorem> I'm working on stack projects on NixOS. I can't make them nix projects because I'm the only one using Nix. Most of the time it works, but when I upgrade my system and old versions of ghc and other native dependencies get garbage-collected, I get ENOFILE linker errors and I have to nuke my stack user cache "unpredictably".
05:31:09 <maerwald> Orbstheorem: https://github.com/fpco/cache-s3
05:31:30 <maerwald> you can also cache with stack
05:31:50 <L29Ah> Orbstheorem: can't you pin concrete libraries and their versions in nix?
05:32:37 <Orbstheorem> maerwald: I fail to see how that would solve my native library problems.
05:32:59 <phadej> pin your nixpkgs version per each project you work with
05:33:06 <phadej> i.e. don't use system wide dependencies
05:33:13 <Orbstheorem> :(
05:33:15 <maerwald> Orbstheorem: that wasn't your original question
05:33:22 <Orbstheorem> (Solves my issue, but grumble.)
05:33:28 <maerwald> nix does not compile your native deps
05:33:33 <maerwald> err
05:33:36 <maerwald> stack
05:34:00 <phadej> Orbstheorem: that's not different from any other distro
05:34:25 <phadej> if you upgrade say libtinfo5 -> 6, you probably need to compile half of your system
05:34:28 <ezzieyguywuf> I've had folks in #gentoo-chat say things like "haskell is only good for maths and proofs and stuff, not really production-code.". So far that doesn't seem true to me. But after spending like an hour reading through Learn You Agda, I kind of want to say that about agda ü§£
05:35:12 <Orbstheorem> Hum, I was certain that if I were to pull (e.g. the haskell postgresql client) derivation it would already contain the native dependencies and my program could just link againts it.
05:35:19 <maerwald> haskell isn't that good for proofs
05:35:23 <maerwald> that's a myth
05:35:45 <ezzieyguywuf> maerwald: I can see that, especially after reading about some of the comparisons to idris and agda
05:36:06 <kuribas> ezzieyguywuf: pretty sure it's the opposite way.  It's good for production -code, not so good for maths and proofs and stuff.
05:36:08 <Orbstheorem> ezzieyguywuf: I write haskell web services for food and we use it in production.
05:36:15 <Uniaika> Orbstheorem: \o/
05:36:20 <phadej> Haskell is quicker to dismiss propositions which aren't true :)
05:36:29 <phadej> e.g. QuickCheck to find counterexamples
05:36:30 * Orbstheorem is unhappy haskell is not total
05:36:39 <phadej> vs. finding it by other means in Agda
05:36:56 <proteusguy> phadej, that's not true!  (See how fast that happened! ;-) )
05:37:14 <kuribas> ezzieyguywuf: yes, agda, coq, idris, etc... are all better for that.
05:37:15 <Orbstheorem> ezzieyguywuf: But yeah, the type-system is more expressive than most programming languages and the compiler can check (prove) more properties of your code (you can see your code as a theorem).
05:37:32 * Orbstheorem 's lost love is idris.
05:37:37 <ezzieyguywuf> as it stands (and again, recall I've spent roughly an hour reading about agda) I con't fathom at all how one would do something as simple as "Hello, world!" in agda
05:37:42 * Orbstheorem wants a dragon plushie.
05:37:57 <kuribas> IMOI you don't really prove stuff in haskell, you just use the type system in a way that you don't need to prove stuff :)
05:38:05 <phadej> ezzieyguywuf: you are reading wrong pages then :) https://agda.readthedocs.io/en/v2.6.0.1/getting-started/hello-world.html
05:38:11 <maerwald> haskell is probably one of the few general purpose programming language where you can reasonably do without actual proofs and still have high confidence
05:38:56 <kuribas> For example: you wouldn't prove that a number is odd, but you could make a newtype of odd numbers, with a smart constructor.
05:39:22 <phadej> kuribas: why not. data Odd = One | PlusTwo Odd
05:39:31 <ezzieyguywuf> phadej: ah
05:39:33 <kuribas> phadej: performance?
05:40:00 <Orbstheorem> I think we're missing pi types to go full dependent? x)
05:40:06 <phadej> kuribas: nah. pick one, proofs or performance
05:40:33 <Orbstheorem> Idris does both, not very well :P
05:40:43 <kuribas> phadej: you can have both, see f*
05:40:49 <maerwald> yep
05:40:54 <kuribas> which can compile to C
05:40:57 <maerwald> F* is awesome
05:41:03 <maerwald> and ocaml
05:41:07 <maerwald> and F#
05:41:34 <ezzieyguywuf> lol, 'performance'
05:41:42 <ezzieyguywuf> but isn't haskell 'generally' slower than, say, c++?
05:41:55 <phadej> no
05:41:57 <Orbstheorem> phadej: I'm looking how to use an optional request body in servant and found your PR #873 x)
05:41:58 <kuribas> ezzieyguywuf: that's a bad comparison
05:42:05 <phadej> agda compiles to Haskell too
05:42:16 <phadej> and one can define abstract (fast) type for odd numbers too
05:42:17 <kuribas> ezzieyguywuf: because you don't write C++ the same way you write haskell.
05:42:21 <phadej> but it would be more painful to work with
05:42:29 <phadej> hence, performance or proofs
05:42:39 <merijn> ezzieyguywuf: Define generally and slower
05:42:39 <phadej> (i mean at least more painful to prove things about)
05:42:55 <kuribas> ezzieyguywuf: you could write very abstract code in C++, and I am sure ghc would do a better job to get performance out of it.
05:43:22 <phadej> Orbstheorem: I'm not working on servant anymore, it's very unluckily I'll come back to any (still) open pr of mine.
05:43:34 <merijn> ezzieyguywuf: The problem with "language" speed is that it's a complete nonsense thing. Performance is a matter of "how good is the compiler at making things fast?" and "how good are you at writing code such that the compiler can make it fast?"
05:44:10 <Orbstheorem> phadej: It's merged ^^
05:44:18 <Orbstheorem> I'm just trying to figure out how to use it xD
05:44:24 <phadej> at least C++ and GHC compiler performance could both be better
05:44:26 <merijn> ezzieyguywuf: Like, if I write a super-tight numeric inner-loop, g++/clang++ will probably be faster than GHC, since there's not a lot of effort put into GHC and making auto-vectorisation stuff work (but via the LLVM backend you might still get it)
05:45:08 <kuribas> merijn: this.  And any language that allows inline assembly is by definition equally fast.
05:45:12 <merijn> Incidentally, did someone link Ryan's Haskell talk at the C++ conference yet? Which talks exactly about things like high-level code and low level performance
05:45:14 <phadej> merijn: yes, so I understood that llvm backend produces faster code for numeric-heavy code
05:45:38 <phadej> at the expense for even slower compilation :P
05:45:53 <ezzieyguywuf> I guess my impression was, let's say I write up a 3D snake program - it thought this would more performant in c++, i.e. more fps on the same hardware
05:45:55 <merijn> phadej: to the best of my knowledge the GHC LLVM backend produces better code for numerical stuff, but the native codegen still beats it for "normal" Haskell, yes
05:46:14 <merijn> ezzieyguywuf: That depends on how well you write the program in both languages
05:46:31 <ezzieyguywuf> that's a fair point
05:46:40 <ezzieyguywuf> I guess my assumption was that you wrote the program th same way in both languages
05:47:06 <merijn> ezzieyguywuf: There are some things that make *GHC* Haskell less suited to that sorta thing than C++, but that's due to lack of engineering/manpower more than due to the language
05:47:09 <ezzieyguywuf> but I guess your point is - c++ lends itself to a particular programming style, and if you try to shoehorn something else in the performance will suffer. ditto haskell
05:47:20 <merijn> ezzieyguywuf: What does "the same in both languages" even mean? :)
05:47:41 <kuribas> ezzieyguywuf: people usualy don't write their own 3D engines anyway.
05:47:56 <merijn> ezzieyguywuf: My point was more that "getting good performance" is the same in ALL languages, but some make it harder to write code amenable to that
05:48:03 <merijn> ezzieyguywuf: Anyway, this might be interesting: https://www.youtube.com/watch?v=lC5UWG5N8oY
05:48:11 <merijn> ezzieyguywuf: Haskell keynote at a C++ conference :)
05:48:13 <phadej> when 3D snake program is complicated enough to contain a buggy implementation of common lisp, I'd bet that Haskell version could be less buggy, and C++ and Haskell implementations would be comparably slow
05:48:17 <ezzieyguywuf> merijn: both languages use glfw for rendering in opengl, both languages use a poll-act-render loop, both languages use a 32-bit Int to store the score, etc.
05:48:43 <ezzieyguywuf> merijn: nice! I 'll have to check that out.
05:49:39 <phadej> in other words, comparing mini projects is not meaningful, as there is definitely opportunity for a particular paradigm/implementation to shine
05:49:57 <Orbstheorem> phadej: Arf: there's a note in the docs that ReqBody' is always Required :(
05:50:29 <phadej> I'd find it very wasteful to write "data shoveling into/from db webservices" in C++
05:50:46 <phadej> but I guess someone does that too (and also in Rust)
05:51:14 <ezzieyguywuf> hm, so this leads me to the existential question - where do I draw the line in my project? what part should be haskell and what part should be c++?
05:51:17 <phadej> add just a bit of internal state to that webservice and comparison starts to be a lot more interesting
05:51:21 <ezzieyguywuf> or just don't sweat it, do it all haskell
05:51:59 <phadej> if you have (library) C++ code, than it doesn't make sense to rewrite it
05:52:03 <merijn> ezzieyguywuf: Well, what is your project? 3D snake?
05:52:10 <ezzieyguywuf> 3D CAD
05:52:22 <kuribas> ezzieyguywuf: no part should be C++
05:52:28 <merijn> ezzieyguywuf: Honestly, for CAD I'd say "all Haskell" should be fine
05:52:51 <Orbstheorem> +1
05:52:51 <kuribas> ezzieyguywuf: you probably use some engine for rendering the 3D, right?
05:52:56 <ezzieyguywuf> hooray that's what I was thinking
05:53:01 <ezzieyguywuf> kuribas: nah I'm building it from scratch
05:53:04 <ezzieyguywuf> using glfw
05:53:05 <merijn> ezzieyguywuf: The biggest issues you'd run into with GHC Haskell is that it's not ideal for realtime systems, GC latency might lag your videogame and that pisses people off
05:53:26 <merijn> ezzieyguywuf: However, in a CAD program some small latency is probably barely noticeable
05:53:35 <ezzieyguywuf> eventually I want to do something like OnShape, where you can access the CAD from multiple devices concurrently
05:54:07 <merijn> ezzieyguywuf: Unrelated suggestion: You should use SQLite as your CAD file implementation :)
05:54:36 <ezzieyguywuf> merijn: I considered it.
05:55:34 <ezzieyguywuf> i may still do that actually - currently the industry "standard" seems to be step, but the step specification is (1) not free, and (2) a friggin nightmare
05:55:41 <Orbstheorem> ezzieyguywuf: You may want to take a look at this: https://github.com/ocharles/zero-to-quake-3
05:55:48 <merijn> ezzieyguywuf: Anyway, I don't see a reason why you couldn't get adequate performance from Haskell (besides, fixable bugs/mistakes, that is)
05:56:10 <ezzieyguywuf> at the expense of getting 927'd, it really does seem like there is room for one, good, open standard
05:56:11 <Orbstheorem> ezzieyguywuf: (streams: https://www.youtube.com/playlist?list=PL4LfyUoOOL7RABGQbmjLDCK00YL8t0HDG)
05:56:19 <merijn> ezzieyguywuf: I know there's at least one 3D modelling/CAD tool that uses SQLite :p
05:56:28 <maerwald> performance in haskell is hard, if you have something that is peformance demanding by nature
05:56:30 <ezzieyguywuf> merijn: which?
05:56:32 <merijn> (I forgot which, though)
05:56:35 <ezzieyguywuf> dang
05:57:44 <merijn> ezzieyguywuf: The SQLite website explicitly lists CAD file formats as a good usecase :p
05:58:05 <merijn> maerwald: s/performance in haskell is hard/performance is hard/
05:59:01 <maerwald> merijn: especially hard in haskell
05:59:13 <maerwald> reasoning about performance is easier in other langs
05:59:34 <ezzieyguywuf> seems there's already some precedence, autocad seems to support some sort of sqlite import
05:59:49 * hackage rocksdb-haskell-jprupp 2.1.3 - Haskell bindings for RocksDB  https://hackage.haskell.org/package/rocksdb-haskell-jprupp-2.1.3 (jprupp)
06:02:49 <merijn> ezzieyguywuf: I've been using SQLite as file format for my own stuff and I'm increasingly convinced that it's an absolutely brilliant format to use
06:04:17 <merijn> Don't have to deal with messy filesystem interfaces (that's all handled by SQLite), atomic reads/updates and transactions for all your operations, open and portable file format supported on literally every platform, easy to handle versioning/migrations...
06:05:22 <merijn> ezzieyguywuf: I support migrations from old versions to the latest format and it's amazing to be able to just wrap the migration in a transaction and if anything goes wrong with my migration logic, it just aborts the transactions and rolls back to the user's old version. <3
06:05:56 <merijn> Bindings in literally every language too :p
06:07:13 <maerwald> what about using it as an alternative to json and then let an app download an sqlite file instead?
06:07:47 <ezzieyguywuf> "Bentley Systems uses SQLite as the application file format for their Microstation CAD/CAM product. "
06:09:18 <phadej> Is sqlite format audible, i.e. can you verify that opening it wouldn't accidentally require 1TB of RAM
06:09:33 <ezzieyguywuf> anywho, I'm not close to the point of worrying about a file format yet.
06:09:46 <phadej> i.e. there√§s difference about using something for internal vs. external formats
06:09:47 <merijn> maerwald: Honestly, I've had this idea before and I've argued at work that we should push hard to make SQLite our data exchange format instead of JSON
06:10:03 <ezzieyguywuf> phadej: I thought all database stuff was more or less memory "neutral" until you make a query
06:10:09 <merijn> maerwald: (We deal with lots of data science-y people serialising their datasets as JSON, so SQLite would be very appropriate)
06:10:33 <ezzieyguywuf> i.e. it's just a file handle until then
06:10:45 <phadej> ezzieyguywuf: so is opening json file
06:10:48 <merijn> phadej: Well, SQLite doesn't load the file into memory, so I don't see why that would ever happen
06:10:55 <phadej> ezzieyguywuf: until you hit 1e10000000 literal
06:11:22 <merijn> phadej: Now, if you write a query that materialises the entire dataset into memory and run it on untrusted/malicious input, you can run out of memory, sure
06:11:45 <merijn> phadej: That said, I believe you can limit the memory SQLite is allowed to use
06:12:04 <ezzieyguywuf> lol, little bobby drop tables
06:12:12 <phadej> merijn: I'm thinking more of use case where your sqlite file is say few kilobytes, but doing some (simple) select would use gigabytes of memory
06:12:16 <merijn> phadej: Yeah, there's a sqlite3_hard_heap_limit64
06:12:19 * hackage haskoin-store 0.37.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.37.0 (jprupp)
06:12:40 <merijn> phadej: I don't think that's possible without as of yet unknown bugs in SQLite
06:12:48 <phadej> merijn: k
06:13:08 <merijn> phadej: Assuming all your query/extension code is trusted (i.e. not running arbitrary external queries or loading untrusted extensions)
06:13:19 * hackage haskoin-store-data 0.37.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.37.0 (jprupp)
06:13:20 <phadej> anyway, I wouldn't use it as external format. even the sqlite code is open, it's still (AFAIU) defined through the implementation
06:13:34 <ezzieyguywuf> my only qualm with using my own sqlite scheme for storing the cad data is that it is not incompatible with any other cad/3d software
06:13:40 <merijn> phadej: Because all table data has finite size and since you can hard limit the memory consumption of sqlite, that seems easy enough
06:13:54 <phadej> for internal needs, where you can say "don't do that", it's fine
06:14:02 <merijn> phadej: The US library of congress lists it as one of the recommended long term archival formats
06:14:11 <ent> can't you do something like cross-products of a table with itself though?
06:14:17 <merijn> phadej: And application file format is one of it's direct intended use cases :)
06:14:33 <merijn> ent: Sure, but the danger here was malicious *databases*, not malicious queries
06:14:41 <merijn> ent: You control the program (and thus the queries)
06:15:00 <merijn> ent: The solution to "stupid queries running you out of resources" is "fix your stupid queries"
06:15:05 <ent> hmm, sqlite doesn't have stored procedures or similar?
06:15:10 <ent> or views
06:15:50 <merijn> ent: I think you can disable views from code and there's no stored procedures (you can load additional functions into SQLite from your code, but not from the database)
06:16:02 <ent> ah
06:16:43 <merijn> phadej: The file format specification itself is also open and portable across platforms
06:16:49 <phadej> merijn: are there not libsqlite implementation of sqlite data format_
06:17:00 <phadej> complete ones?
06:17:06 <merijn> Possibly? I don't know
06:17:59 <phadej> there's plenty you can name for JSON ;)
06:18:14 <merijn> phadej: But what alternative do you propose? The only "real" alternative is "serialise to JSON/XML/whatever", but that's not quite the same
06:18:52 <phadej> merijn: for external format? serialize to JSON or CBOR or ...
06:18:54 <merijn> phadej: Most of those JSON ones are buggy as shit, though ;)
06:19:02 <phadej> you can then convert from/to sqlite for internal use, if you want
06:19:23 <phadej> merijn: spotting bugs in them is easier
06:19:31 <merijn> phadej: But, concretely, for an application like a CAD program, wat is the advantage of that?
06:19:42 <phadej> merijn: as I said, for internal use there aren't
06:19:45 <merijn> Seems like it'll just make load times a billion times slower
06:19:47 <phadej> but as external exchange format, there is
06:20:05 <phadej> internal format can (and should) be optimized for your application
06:20:08 <merijn> phadej: I don't understand your external/internal distinction then, I think
06:20:24 <phadej> PNG is extenral format
06:20:29 <phadej> PSD is internal for photoshop
06:20:30 <ezzieyguywuf> wouldn't internal be "in memory"?
06:20:36 <ezzieyguywuf> ah, or that
06:21:05 <L29Ah> why do people choose conduit over streaming?
06:21:10 <ezzieyguywuf> if that's the case, though, I don't see any advantage of using sqlite for CAD, as it is not like PNG, i.e. universally known/understood/parseable
06:21:24 <merijn> phadej: Well, since we were talking about "application file formats" we were already implicitly talking about "internal" (per your definition) format
06:22:11 <phadej> merijn: yes, but your application is ought to support some "external" format, if it's in a space where data exchange happens
06:22:17 <merijn> ezzieyguywuf: He's talking about an entirely orthogonal discussion than we were having
06:22:19 * hackage sequence-formats 1.5.0 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.5.0 (stephan_schiffels)
06:22:24 <phadej> e.g. photoshop can open and write PNG files
06:23:03 <merijn> L29Ah: Conduit is older, has more ecosystem support, simpler API (imo)
06:23:15 <phadej> so if STEP is the format for CAD, you'd eventually need to implement that
06:23:43 <phadej> but if your app has some extra stuff to save, than obviously you need your own format, and then you can choose whatever you want
06:24:01 <merijn> L29Ah: The microbenchmarks streaming shows are, well, microbenchmarks. And like nearly all microbenchmarks they are effectively useless
06:24:01 <phadej> and sqlite is definitely better than "read/write all at once" formats like JSON-based ones
06:24:39 <phadej> for IO bound computations, I couldn't measure difference between pipes, machines or conduit
06:24:44 <phadej> IIRC I tried also streaming
06:24:49 <merijn> phadej: Yeah, that's what I was getting at
06:25:16 <merijn> All the streaming library micro benchmarks are 100% pure code, which is just silly masturbation, since 95% of the usecases are IO bound
06:25:28 <Orbstheorem> (about SQLite): minetest uses SQLite for millions of blocks \o/
06:26:10 <phadej> yet, I have a library where you can optimize virtually all the plumbing stuff away, if you really want.
06:26:15 * L29Ah looks at conduit types and shivers
06:26:25 <phadej> it's a level harder to use than conduit though
06:26:39 <merijn> L29Ah: Why shiver?
06:26:50 <merijn> "ConduitT input output monad result"
06:27:59 <L29Ah> "result of a conduit" being distinct from its output seems counterintuitive to me
06:28:45 <phadej> that's API design choice (which I don't like either)
06:28:51 <phadej> e.g. machines don't have it
06:28:57 <phadej> and using them is still fine
06:36:49 * hackage sequence-formats 1.5.1 - A package with basic parsing utilities for several Bioinformatic data formats.  https://hackage.haskell.org/package/sequence-formats-1.5.1 (stephan_schiffels)
06:38:58 <george_____t> Hi guys, I'm getting some odd behaviour where my Haskell code disagrees with `ls -l` or `stat` about permissions. For example, `fmap (flip showOct "" . fileMode) . getFileStatus` suggests that read permissions aren't set for the group, while `stat` says they are
06:39:23 <george_____t> (using functions from the `unix` package)
06:40:02 <george_____t> This is particularly odd since `getFileStatus` seemingly just calls `stat`
06:40:28 <george_____t> Anything obvious that could cause this?
06:47:16 <GreyFaceNoSpace> what does this type mean? g :: (Floating a, Integral b, RealFrac a) => a -> b
06:47:43 <GreyFaceNoSpace> a can be a Float or Integral or RealFrac ?
06:48:19 <hyperisco> GreyFaceNoSpace, it means  a  must be both Floating and RealFrac and  b  must be Integral
06:48:28 <Uniaika> GreyFaceNoSpace: Floating is a subclass of Fractional that brings the trig functions
06:48:33 <GreyFaceNoSpace> so
06:48:41 <Uniaika> (=> https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Floating )
06:48:47 <GreyFaceNoSpace> if i call with g 5.0
06:48:53 <GreyFaceNoSpace> it must work correct?
06:49:05 <hyperisco> as far as type checking is concerned, yes
06:49:41 <Uniaika> I have no idea of the logic behind that function, but type-wise yes, it is correct
06:50:33 <ezzieyguywuf> but is 5.0 a Double or Float?
06:51:04 <hyperisco> it is a CReal
06:51:07 <GreyFaceNoSpace> https://pastebin.com/Eaub0urD
06:51:11 <GreyFaceNoSpace> whats wrong here?
06:51:54 <hyperisco> GreyFaceNoSpace, I don't know, what does the compiler say is wrong?
06:51:57 <Uniaika> GreyFaceNoSpace: idk, what's the error? :P
06:52:26 <GreyFaceNoSpace> https://pastebin.com/0zcDqyXY
06:52:30 <GreyFaceNoSpace> this is the error
06:52:47 <ezzieyguywuf> i think the indentation is off isn't it?
06:53:07 <hyperisco> it means you have to tell the compiler which type you want, such as Double or Float
06:53:27 <GreyFaceNoSpace> so i should change it to f (exp::Float)
06:53:28 <GreyFaceNoSpace> ?
06:53:46 <hyperisco> I think you have to say what the type of  f exp  is
06:54:09 <hyperisco> but maybe what the type of  15.0  is‚Ä¶ not sure myself how to read the error that precisely
06:54:37 <ezzieyguywuf> GreyFaceNoSpace: it may help to add type signatures to your functions
06:54:49 <hyperisco> the basic problem is like this
06:54:56 <hyperisco> > show bottom
06:54:58 <lambdabot>  error: Variable not in scope: bottom :: ()
06:55:07 <hyperisco> oh what is it in Haskell
06:55:21 <hyperisco> > show minBound
06:55:23 <lambdabot>  "()"
06:55:26 <GreyFaceNoSpace> f :: Float a -> Integral b
06:55:39 <GreyFaceNoSpace> problem_16.hs:3:6:
06:55:39 <GreyFaceNoSpace>     ‚ÄòFloat‚Äô is applied to too many type arguments
06:55:39 <GreyFaceNoSpace>     In the type signature for ‚Äòf‚Äô: f :: Float a -> Integral b
06:55:39 <GreyFaceNoSpace> Failed, modules loaded: none
06:55:41 <hyperisco> okay‚Ä¶ well‚Ä¶ Haskell also has this thing called default instances‚Ä¶
06:56:31 <hyperisco> GreyFaceNoSpace,  Float a  is not a type, it is a constraint, and  ->  requires types
06:56:38 <ezzieyguywuf> GreyFaceNoSpace: I think you want `f :: Float -> Integral`, though that type signature doesn't make much sense to me...
06:56:56 <ezzieyguywuf> I guess so, i.e. `howManyDigitsAfterTheDecimal :: Float -> Integral`
06:57:20 <GreyFaceNoSpace> problem_16.hs:3:15:
06:57:21 <GreyFaceNoSpace>     Expecting one more argument to ‚ÄòIntegral‚Äô
06:57:21 <GreyFaceNoSpace>     Expected a type, but ‚ÄòIntegral‚Äô has kind ‚Äò* -> GHC.Prim.Constraint‚Äô
06:57:21 <GreyFaceNoSpace>     In the type signature for ‚Äòf‚Äô: f :: Float -> Integral
06:57:21 <GreyFaceNoSpace> Failed, modules loaded: none.
06:57:36 <ezzieyguywuf> whoops, s/Integral/Int/
06:57:42 <hyperisco> > show (fromIntegral (5 :: Int))
06:57:43 <lambdabot>  "5"
06:57:44 <ezzieyguywuf> (or Integer, but Integer uses more memory or something)
06:57:52 <hyperisco> oh lambdabot‚Ä¶ you're helping me too much
06:57:58 <hyperisco> :t fromIntegral
06:57:59 <lambdabot> (Integral a, Num b) => a -> b
06:58:09 <hyperisco> what is the Num default oO
06:58:25 <GreyFaceNoSpace> i don't understand
06:58:32 <GreyFaceNoSpace> i should get an Int at the end
06:58:53 <GreyFaceNoSpace> why is Float -> Integer failing?
06:58:58 <hyperisco> GreyFaceNoSpace, okay then  f :: A -> Int  then and you still have to figure out  A
06:59:34 <GreyFaceNoSpace> a is a number that has to be float since i am multiplying it with a float
06:59:40 <hyperisco> GreyFaceNoSpace, I don't know, why does the compiler say  f :: Float -> Integer  is failing?
07:00:05 <GreyFaceNoSpace> problem_16.hs:3:15:
07:00:05 <GreyFaceNoSpace>     Expecting one more argument to ‚ÄòIntegral‚Äô
07:00:05 <GreyFaceNoSpace>     Expected a type, but ‚ÄòIntegral‚Äô has kind ‚Äò* -> GHC.Prim.Constraint‚Äô
07:00:05 <GreyFaceNoSpace>     In the type signature for ‚Äòf‚Äô: f :: Float -> Integral
07:00:05 <GreyFaceNoSpace> Failed, modules loaded: none.
07:00:15 <ezzieyguywuf> GreyFaceNoSpace: Integer, not Integral
07:00:23 <ezzieyguywuf> (or Int)
07:01:22 <GreyFaceNoSpace> wow
07:01:26 <GreyFaceNoSpace> that was annoying
07:01:26 <GreyFaceNoSpace> lol
07:01:55 <ezzieyguywuf> GreyFaceNoSpace: hah, but it would be worthwhile to understand why you had the problem
07:02:04 <GreyFaceNoSpace> i still dont understand tbh
07:02:08 <GreyFaceNoSpace> can someone explain it?
07:02:28 <ezzieyguywuf> GreyFaceNoSpace: "Integral a" is a type constraint - it says "a must be a Type with an instance of Integral"
07:02:34 <GreyFaceNoSpace> why did the compiler fail at inferring that exp must be float since i am multiplying it with a float
07:02:35 <GreyFaceNoSpace> ?
07:02:40 <ezzieyguywuf> two examples of such a Type are Int and Integer
07:03:26 <GreyFaceNoSpace> ok
07:03:44 <ezzieyguywuf> so you could easily write our function `f :: (Integral a) => Float -> a`
07:04:33 <ezzieyguywuf> but then if you defined it as `f _ = 1`, the compiler wouldn't know _which_ Integral to use for `1`. Should it be an Int? An Integer? Something else?
07:05:11 <ezzieyguywuf> so instead, you'd have to be explicit: `f _ = 1 :: Int`, but really that's no better than just defining `f :: Float -> Int; f _ = 1`
07:06:17 <int-e> > let f :: (Integral a) => Float -> a; f _  = 1 in f 0.1
07:06:19 <lambdabot>  1
07:06:54 <nij> (Sorry to interrupt) As a cabal user, how would I deal with stack packages?
07:08:08 <L29Ah> nij: do you mean "hpack packages"?
07:09:07 <GreyFaceNoSpace> ezzieyguywuf, i know this is a dumb question. but this seems stupid to me. Why have so many types for numbers when float,Int and maybe fractional are sufficient
07:09:34 <GreyFaceNoSpace> wouldn't it then be easier to infer the type from the operation/function applied to the value?
07:09:40 <Uniaika> nij: what do you mean by "stack packages"? the `package` stanza in stack.yaml?
07:09:58 <ezzieyguywuf> GreyFaceNoSpace: that question goes above my ability to understand, but I'm pretty confident that there's good reasons, i.e. relating to memory usage and precision
07:10:03 <L29Ah> GreyFaceNoSpace: because they aren't sufficient
07:10:14 <ezzieyguywuf> s/ability to understand/ability to explain/
07:10:19 <GreyFaceNoSpace> L29Ah, in what way?
07:10:56 <L29Ah> GreyFaceNoSpace: adding to ezzieyguywuf's answer, it's about predictable overflow and exception semantics
07:11:17 <GreyFaceNoSpace> i see
07:11:36 <L29Ah> Int is "at least 30 bits signed integer"
07:11:51 <L29Ah> Word64 is "64-bit unsigned integer"
07:12:15 <L29Ah> Integer is "arbitrarily big integer"
07:12:36 <L29Ah> all with their own costs and benefits
07:12:42 <GreyFaceNoSpace> "arbitrarily big integer"
07:12:44 <GreyFaceNoSpace> ...
07:12:49 <GreyFaceNoSpace> what does that mean
07:12:50 <GreyFaceNoSpace> lol
07:13:13 <L29Ah> > 25014761243089578 * 4313515124315 :: Integer
07:13:15 <lambdabot>  107901550953195584981350889070
07:13:18 <GreyFaceNoSpace> is it a virtual number?
07:13:24 <L29Ah> > 25014761243089578 * 4313515124315 :: Int
07:13:26 <lambdabot>  -1835446422127364498
07:13:31 <L29Ah> > 25014761243089578 * 4313515124315 :: Word8
07:13:31 <GreyFaceNoSpace> i.e. is it not directly computed on the processor?
07:13:33 <lambdabot>  110
07:13:43 <jumper149> GreyFaceNoSpace: memory gets allocated dynamically similar to a linked list
07:13:47 <L29Ah> GreyFaceNoSpace: check `gmp` library about how it works
07:15:07 <oats> arbitrarily large integer => "lol you want integers I'll heckin give you some integers"
07:15:30 <orion> Anyone have experience with acid-state?
07:16:11 <int-e> can't resist: does acid-state depend on base?
07:17:10 <ezzieyguywuf> ü§¶‚Äç‚ôÇÔ∏è
07:18:07 <nij> >L29Ah I see stack.yaml in its repo.
07:18:14 * mmaruseacph2 used acid-state around 6 years ago
07:18:25 <nij> L29Ah, I see stack.yaml in the repo.. so I call it stack package.
07:18:46 <nij> L29Ah: I see stack.yaml in the repo.. so I call it stack package.
07:19:16 <mmaruseacph2> nij: you can ignore `stack.yaml` if you're using cabal
07:19:23 <nij> Uniaika: I see stack.yaml in the repo, so I assume it requires stack, and call it a stack package. For example:
07:19:41 <orion> int-e: Ha!
07:20:00 <fog> "Anything that the Jordan decomposition can do, the Schur decomposition can do better!" (Van Loan)
07:20:05 <fog> http://hackage.haskell.org/package/hmatrix-0.15.2.0/docs/Numeric-LinearAlgebra-Algorithms.html
07:20:08 <fog> is wrong!
07:20:13 <oats> > 2 ^ (2 ^ 37) :: Integer
07:20:22 <lambdabot>  mueval: ExitFailure 1
07:20:24 <oats> :D
07:20:50 <fog> lapack and cblas as bindings under hmatrix should give jordan decomposition
07:20:52 <Uniaika> nij: okay so, `stack.yaml` is here to tune stuff *for* stack
07:21:08 <nij> mmaruseacph2: For example, in this repl, how would I use cabal to make it run? (https://github.com/timbod7/haskell-chart)
07:21:12 <L29Ah> > 2 ^ (2 ^ 15) :: Integer
07:21:13 <lambdabot>  1415461031044954789001553027744951601348130711472388167234385748272366634240...
07:21:21 <orion> I have a very small service I would like to write, akin to an API to manage my church's bake sale. Normally, my go-to for a database is postgres. However, I am saddened by the extra schema complexity involved in being able to represent sum types. As a result, I'd like to be able to serialize native Haskell data structures directly to disk.
07:21:26 <nij> Uniaika: For example, in this repl, how would I use cabal to make it run? (https://github.com/timbod7/haskell-chart)
07:21:42 <fog> if i want the generalised spectral decomposition, a common linear algebra subroutine, where can i find it?
07:21:55 <orion> (i.e. no one's life will depend on this small service whose dataset will completely fit in to memory)
07:22:04 <sm[m]> nij: if the repo contains only a single package (.cabal file) you can just build that with cabal as usual. If it contains multiple packages and also contains a cabal.project file, you can build them all with cabal as usual. Otherwise you can install stack and build with that, or you can try cabal build ./pkg1 ./pk2 ...
07:22:10 <Orbstheorem> What's the name of the function I can give a record constructor and writes the instance for me? genericParse<something?>
07:22:15 <fog> i need to find the generalised eigenvalues of a defective matrix
07:22:19 <Uniaika> nij: well there are several packages here
07:22:28 <Uniaika> but the wiki mentions cabal: https://github.com/timbod7/haskell-chart/wiki#download-and-installation :)
07:22:35 <mmaruseacph2> nij: cabal build for each one of them?
07:22:41 <L29Ah> Orbstheorem: which instance?
07:22:47 <sm[m]> nij: that one has a cabal.project file, so "cabal build"
07:22:54 <nij> Oh.. I didn't know they are "severel packages"..
07:23:08 <maerwald> Uniaika: that looks like v1 instructions
07:23:16 <Orbstheorem> L29Ah: FromJSON, sorry
07:23:19 <oats> orion: you prefer plain-text formats or binary?
07:23:46 <L29Ah> Orbstheorem: probably it's enough to have `deriving Generic` and then just `instance FromJSON Foo`
07:23:48 <Orbstheorem> L29Ah: I mean, I still have to write the instance myself, I just don't have to do the applicative where I list all the records.
07:23:51 <orion> oats: No preference. I want to be able to represent and query sum types though.
07:24:16 <Orbstheorem> L29Ah: My type has multiple constructors and some logic ("member" foo) to choose a constructor.
07:24:22 <oats> orion: tried aeson? json should be able to do the trick
07:24:27 <nij> I see.. there are many packages here.
07:24:38 <sm[m]> orion should probably just write and read Show output, right ?
07:24:39 <nij> Thanks for your help!!
07:25:02 <orion> Ha. I am embarrassed to say that I haven't actually considered JSON.
07:25:05 <nij> In general, will there be packages that's only going to work for stack users but not cabal users?
07:25:14 <nij> :Uniaika In general, will there be packages that's only going to work for stack users but not cabal users?
07:25:20 <L29Ah> Orbstheorem: consider splitting types that the language can produce proper generic instances for and those where you need to write them manually
07:25:39 <Orbstheorem> :(
07:25:46 <Orbstheorem> Type is trivial xD
07:25:54 <L29Ah> orion: just grab binary
07:25:58 <Orbstheorem> I'm implementing an OpenAPI allOf xD
07:26:20 <oats> orion: https://www.schoolofhaskell.com/user/Geraldus/algebraic-data-types-adts-with-aeson
07:26:24 <L29Ah> if you don't need encoding type metadata, it magically encodes and decodes everything for you utilizing Generic
07:26:27 <sm[m]> nij: not really. You might find a rare project that includes package.yaml files but not .cabal files, those are a little inconvenient for cabal users, since they have to run "hpack"
07:26:57 <nij> sm[m]: That's quite useful. I will have to look for ".cabal" files in the future :)
07:27:00 <fog> i can find geigSH' which says; Generalized symmetric positive definite eigensystem Av = lBv, for A and B symmetric, B positive definite (conditions not checked).
07:27:01 <nij> Thank you :))
07:27:14 <fog> but i cant tell if thats Jordan form
07:27:29 <Orbstheorem> L29Ah: But they are overlapping. One object is a superset of another one, how does it choose?
07:27:51 <L29Ah> it doesn't choose anything
07:28:12 <L29Ah> Œª> encode "foobar"
07:28:13 <L29Ah> "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ACKfoobar"
07:28:14 <L29Ah> Œª> (decode $ encode "foobar") :: String
07:28:15 <L29Ah> "foobar"
07:28:16 <L29Ah> Œª> (decode $ encode "foobar") :: Int
07:28:17 <L29Ah> 6
07:29:03 <Orbstheorem> > let data Foo = Foo1 { a :: Integer } | Foo2 { a :: Integer, b :: Integer } deriving (Show, ToJSON, Generic)
07:29:05 <lambdabot>  <hint>:1:5: error: parse error on input ‚Äòdata‚Äô
07:29:12 <Orbstheorem> > data Foo = Foo1 { a :: Integer } | Foo2 { a :: Integer, b :: Integer } deriving (Show, ToJSON, Generic)
07:29:14 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äòdata‚Äô
07:29:38 <Orbstheorem> How do I teach lambdabot a type? :D
07:30:17 <L29Ah> ah, you mean sum types; yes, it encodes them and then chooses the constructor itself
07:30:43 <fog> Orbstheorem; use yahb
07:30:44 <L29Ah> but i'm talking about Binary and other related packages like msgpack and cbor
07:30:51 <L29Ah> not sure about your chosen json parser
07:31:04 <Orbstheorem> aeson :)
07:31:23 <Orbstheorem> foo what is yahb?
07:31:30 <fog> I can find the jordan decompostion on matlab here https://www.mathworks.com/help/symbolic/sym.jordan.html
07:31:46 <fog> % data Foo = Foo1 { a :: Integer } | Foo2 { a :: Integer, b :: Integer } deriving (Show, ToJSON, Generic)
07:31:46 <yahb> fog: ; <interactive>:162:88: error: Not in scope: type constructor or class `ToJSON'; <interactive>:162:96: error:; Not in scope: type constructor or class `Generic'; Perhaps you meant one of these: `G.Generic' (imported from GHC.Generics), `G.Generic1' (imported from GHC.Generics)
07:31:47 <ezzieyguywuf> I use package.yaml, didn't realize it was so rare...
07:32:19 <Orbstheorem> Oh, I didn't know about yahb ^^
07:33:03 <sm[m]> ezzieyguywuf: I was speaking of projects which provide only package.yaml, and don't commit the corresponding .cabal file. 
07:36:11 <ezzieyguywuf> sm[m]: that's what I do
07:36:26 <ezzieyguywuf> because the .cabal file deltas pollute my git history
07:36:41 <ezzieyguywuf> but maybe I aught to just add it back...
07:36:54 <merijn> ezzieyguywuf: Simple solution, just ditch the package.yaml and only use the cabal file :p
07:37:07 <ezzieyguywuf> merijn: lol, but package.yaml is easier...
07:37:09 <ezzieyguywuf> (I think)
07:37:15 <merijn> Define "easier"
07:37:21 <ezzieyguywuf> automatically does stuff for me
07:37:50 <merijn> If by easier you mean "ad hoc, incomplete, underdocumented custom YAML format type encoding a subset of the cabal spec", then yes
07:38:03 <ezzieyguywuf> yikes
07:39:29 <L29Ah> % data Foo = Bar | Baz deriving Generic
07:39:29 <yahb> L29Ah: ; <interactive>:163:31: error:; Not in scope: type constructor or class `Generic'; Perhaps you meant one of these: `G.Generic' (imported from GHC.Generics), `G.Generic1' (imported from GHC.Generics)
07:39:37 <L29Ah> % data Foo = Bar | Baz deriving G.Generic
07:39:37 <yahb> L29Ah: 
07:39:41 <davean> ezzieyguywuf: why would you think package.yaml is easier than cabal?
07:39:45 <fog> here is the paper; https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19730013830.pdf
07:39:46 <L29Ah> % Bar
07:39:46 <yahb> L29Ah: ; <interactive>:165:1: error:; * No instance for (Show Foo) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
07:40:15 <fog> AN ALGORITHM FOR CALCULATION OF THE JORDAN CANONICAL FORM OF A MATRIX B. Sridhar D. Jordan
07:40:16 <merijn> The main argument I've seen in favour of YAML (which is a terrible format anyway) is that "it's better to use widely available formats so people can use reusable tools", but that argument ignores the fact that you'd *still* define a custom schema/spec *on top* of YAML to get a working file format, and somehow people believe that that spec on top of YAML would magically just always work without schema 
07:40:19 <L29Ah> % instance Binary Foo
07:40:19 <yahb> L29Ah: ; <interactive>:166:10: error: Not in scope: type constructor or class `Binary'
07:40:22 <merijn> validation or anything?
07:40:26 <L29Ah> % import Data.Binary
07:40:26 <yahb> L29Ah: 
07:40:29 <L29Ah> :(
07:40:32 <L29Ah> % instance Binary Foo
07:40:32 <yahb> L29Ah: 
07:40:34 <sm[m]> ezzieyguywuf: for private/in-house projects where you know only stack will ever be used, that's fine. But otherwise it makes cabal people unhappy
07:40:44 <L29Ah> % encode Bar
07:40:44 <yahb> L29Ah: "\NUL"
07:40:47 <L29Ah> cool
07:40:52 <merijn> sm[m]: It also makes the stack people unhappy ;)
07:40:54 <L29Ah> % encode Baz
07:40:54 <yahb> L29Ah: "\SOH"
07:41:03 <ezzieyguywuf> well, if I ever get around put pushing my stuff to hackage I'll add it
07:41:09 <merijn> sm[m]: See Snoyman and his pantry work :p
07:41:15 <ezzieyguywuf> or maybe I"ll just add it anyway so that I don't alienate potential contributors
07:41:36 <sm[m]> merijn: not committing cabal files was a problem for stack somehow ?
07:41:50 <davean> ezzieyguywuf: I'd suggest you'll probably end up regretting package.yaml in the long term
07:41:56 <davean> sm[m]: yep
07:41:59 <L29Ah> merijn: i like hpack stuff because it doesn't force me to write `other-modules` madness!
07:42:04 <davean> for ocvious reasons
07:42:24 <davean> L29Ah: Haha, theres a good reason those get writen
07:42:38 <davean> L29Ah: that will 100% no chance to avoid it bite you
07:42:41 <merijn> sm[m]: Snoyman was working on pantry, their new package store and started running into same issues cabal had and now recommends always comitting the cabal file
07:42:47 <L29Ah> if you say so
07:43:10 <merijn> L29Ah: Also, people always claims that writing those other modules is some sort of major hassle
07:43:14 <ezzieyguywuf> hrm, I think I started using package.yaml b/c I didn't understand enough about how stuff worked to get a .cabal file working right
07:43:18 <ezzieyguywuf> maybe I should try again
07:43:26 <merijn> Like, you don't add/remove files that frequently for it to be a major pain
07:43:51 <sm[m]> merijn: thanks. Yes I remember that, but I don't know what problem not committing it would cause for a private project that will never use cabal
07:44:05 <ezzieyguywuf> i think other-modules was my motivator as well, until I did something where hpack's auto-generated other-modules did something I didn't want, so I ended up hand-writing it anyway
07:44:07 <L29Ah> i don't add/remove containers that frequently for writing in C to be a major pain!
07:45:14 <merijn> ezzieyguywuf: It helps to understand the goal of cabal files, which is to unambiguously *correctly* specify what is/isn't part of a distribution and as you've apparently noticed yourself, there's a reason why having an explicit, unambiguous spec for that is important ;)
07:45:20 <L29Ah> well it's a little overboard, but i hope you get the idea
07:45:22 <sm[m]> ezzieyguywuf: package.yaml is a bit of a religious issue, and also quite dependent on the type of project. For certain projects it can still be quite helpful, but not all will agree
07:45:58 * L29Ah personally only uses .cabal files, but is pissed about some points
07:46:10 <merijn> "But it's verbose boilerplate!" <- over time I've come to appreciate safety enforcing boilerplate more and more :)
07:47:13 <merijn> L29Ah: *shrug* I have code with 80 lines of modules/other-modules and so far it hasn't been any significant hassle, there've been far more annoying issues
07:47:31 <merijn> I'm looking at you, GHC's woefully inadequate support for circular imports...
07:47:39 <dolio> The C analogy doesn't make any sense at all to me.
07:47:58 <ezzieyguywuf> i also started using stack because plain cabal was tough for me to manage
07:48:16 <ezzieyguywuf> i.e. ghcup, ghc versions, package versions, etc etc.
07:48:30 <ezzieyguywuf> the stack snapshots took care of all of that
07:49:02 <sm[m]> ezzieyguywuf: same for a lot of people, and it's another religious issue. 
07:49:08 <davean> stack snapshots are efficient for building on the community provided stuff (fall appart quickly when you want to improve it, but thats different)
07:49:17 <L29Ah> dolio: the more you work on boilerplate and the associated problems, the less you work on complex logic, and you can't even comprehend it as you don't have time to invent better and higher level concepts
07:49:42 <davean> L29Ah: still not making sense.
07:49:53 * L29Ah resigns
07:49:58 <sm[m]> this "fall apart quickly" is a myth, davean
07:50:31 <merijn> L29Ah: How much time are you spending managing modules, I add/rename/remove, like a handful every few weeks, max
07:50:34 <davean> sm[m]: I'm saying that from personal experience
07:50:43 <ezzieyguywuf> i see the stack/cabal thing sort of like ubuntu/gentoo. I don't mind my personal computer running gentoo with bleeding-edge versions of packages and the occasional issues that come with that. But I want my software projects to build dependably every time - which seems to be one of the goals of stack
07:50:46 <davean> sm[m]: Its not a myth, its my expence
07:50:55 <gentauro> `mapM` is equivalent to `sequence . map`?
07:50:57 <merijn> sm[m]: working on HEAD of various core packages is a pain with stack's approach
07:50:59 <ezzieyguywuf> I don't want to deal with "oh no, such and such library updated and now this or the other doesn't work as expected"
07:51:00 <merijn> gentauro: Yeah
07:51:05 <gentauro> merijn: nice
07:51:05 <gentauro> :)
07:51:08 <davean> merijn: thats exacrtly what I just said
07:51:22 <sm[m]> davean: I hear that, could you explain what "falls apart" meant ?
07:51:50 <merijn> ezzieyguywuf: If you set upperbounds new releases don't matter
07:52:10 <davean> sm[m]: Ok, so I'm working on X, I want to update it to using a feature of newer Y, but thats ahead of the snapshot, so I need ... but since I'm working forward its more work to jump to newest immediately, ...
07:52:26 <davean> sm[m]: and I end up with a worse version of specifying all my dependencies explicitely
07:52:32 <davean> basicly instantly
07:52:42 <davean> esp on like GHC update cleaning passes
07:52:50 <merijn> ezzieyguywuf: That's the entire point of having the PVP and upperbounds :)
07:53:13 <sm[m]> davean: obviously cabal is a much better tool for certain needs, eg finding a tricky install plan. But that doesn't mean stack snapshots fall apart quickly when you need to go outside them, which is often repeated in here. Most of the time it's very easy to pull in extra stuff from hackage.
07:53:22 <ezzieyguywuf> true, but with stack I don't have to manually specify the version for each dependency
07:53:43 <ezzieyguywuf> *shrug* I could be convinced otherwise, but like I said, I had a hard time making things work in cabal. and when I started using stack things "just worked"
07:53:53 <davean> ezzieyguywuf: you can just set cabal to the current version you're using exactly BTW 
07:54:05 <merijn> ezzieyguywuf: I just pick "the latest one that's out when I start the project and then update via PVP"
07:54:08 <davean> I would say the stack snapshots are an easier starting point
07:54:32 <ezzieyguywuf> i did something like "oh, I need this new dependency, but something is out of date, sure `cabal update`, oh wait, now my package doesn't build"
07:54:49 <davean> ezzieyguywuf: that means you didn't specify the version you were using at all
07:54:55 <dolio> Because you didn't put version numbers on anything?
07:54:59 <ezzieyguywuf> I recognize the stack thing as a sort of "training wheels" but it's one I'm happy to live with
07:55:02 <ezzieyguywuf> (for now)
07:55:08 <ezzieyguywuf> dolio: *shrug* dunno
07:55:20 <davean> I mean thats only a behavior you get when you didn't put versions
07:55:28 <ezzieyguywuf> that's probably what happened then
07:55:29 <davean> (Which you can get put in for you)
07:55:40 <ezzieyguywuf> (but I didn't know that. or how to do it)
07:55:46 <ezzieyguywuf> the cabal v1 vs v2 stuff confused me
07:55:49 <merijn> ezzieyguywuf: If you put version bounds on it, updating shouldn't affect things (because that just updates which hackage releases cabal knows about)
07:55:49 <davean> I take it you didn't read the docs :)
07:55:57 <ezzieyguywuf> I still dunno whan the nix thing is (nixOS?)
07:56:04 <davean> Actually, I'm curious how you found out how to put them in WITHOUT reading about that
07:56:09 <ezzieyguywuf> davean: lol, I tried!
07:56:18 <merijn> davean: To be fair, last I checked the docs the intro to v2-build was...a bit out of the way
07:56:39 <davean> merijn: we're talking cabal file format here, not either build approach thouygh 
07:56:49 <ezzieyguywuf> seems we're talking about both :)
07:56:56 <ezzieyguywuf> which btw stack uses cabal to build anyway
07:56:57 <ezzieyguywuf> right?
07:57:03 <davean> sorta
07:57:04 <maerwald> ezzieyguywuf: you can use stackage snapshots with cabal
07:57:11 <maerwald> it's not a "stack feature" per se
07:57:27 <ezzieyguywuf> i couldn't understtand cabal sanboxes, which stack seems to do automatically
07:57:32 <davean> ezzieyguywuf: where did you learn to write a cabal file from?
07:57:39 <ezzieyguywuf> davean: the docs I think
07:57:44 <merijn> ezzieyguywuf: cabal sandboxes are basically entirely obsolete and you can forget they exist
07:57:48 <ezzieyguywuf> this was months ago
07:58:17 <davean> ezzieyguywuf: I'm certain the docs for cabal include versions constantly and why :) The default auto-generated cabal file from init even comes with them
07:59:24 <davean> It has too long a section to up front about various operators for manipulating their ranges IMO
07:59:34 <sm[m]> cabal docs were until recently horribly out of date and confusing, davean
07:59:39 <ezzieyguywuf> and at the very beginning of my haskell journey
07:59:52 <ezzieyguywuf> so it's entirely possible I was just being dumb
08:00:13 <ezzieyguywuf> sm[m]: how recently?
08:00:27 <davean> sm[m]: for the cabal tool defintely. The file format though, esp the "how to" section hasn't changed much as I recall, essentially just additions of the extra new operators.
08:00:39 <sm[m]> ezzieyguywuf: I got haskell.org to link to the current docs only in the last week or two
08:00:44 <merijn> sm[m]: Well, more so the haskell.org mirror of the docs was horribly out of date and google prefers that
08:00:50 <sm[m]> updates are still needed. which reminds me, who would be the person to merge my https://github.com/haskell/cabal-website/pulls ? phadej ?
08:00:56 <merijn> sm[m]: But I dunno who's in charge of that mirror
08:01:44 <sm[m]> haskell.org/cabal/user-guide redirects to cabal.readthedocs.io now
08:03:32 <ezzieyguywuf> neato, maybe I'll give cabal another whirl in the near future
08:04:01 <ezzieyguywuf> though I have other things on the docket, like transitioning to bricks for my tui, and I haven't even started on that...
08:04:03 <sm[m]> ..or the links have been updated, or something, I can't keep track. Those PRs need merging.
08:05:43 <phadej> sm[m]: someone who could also deploy, afaik it's only 23Skidoo/refold or maybe HVR
08:05:51 <phadej> maybe *also
08:06:30 <sm[m]> phadej thanks. Would you be able to merge the PRs, as a step forward ?
08:09:08 <phadej> I'd rather not take any more responsibilities
08:09:17 <phadej> neither imply I could
08:11:53 <sm[m]> ok. For someone trying to help, it's hard to know who does what and who is responsible for what, and you seemed to be Mr. cabal. cabal-website has very few committers, but I'll try to contact 23Skiddo.
08:12:58 <phadej> sm[m]: I'm not Mr. cabal, I'm just happen to be paid by a WT client to work on it
08:13:08 <phadej> I don't like this set up.
08:14:16 <sm[m]> I see. Maybe a findable page describing people and roles and what they want to hear about can help
08:14:46 <phadej> maybe, I'm not starting discussion about project governance, as there's high risk to become "mr. cabal"
08:15:59 <sm[m]> does anyone want to be mr./ms. cabal ? is there any active maintenance ?
08:16:54 <dolio> It seems like someone being paid to work on it is active maintenance.
08:17:26 <sm[m]> https://github.com/haskell/cabal/graphs/contributors?from=2019-08-04&to=2020-07-24&type=c
08:17:48 <phadej> dolio: I'm actively trying to avoid acquiring any more responsibilities with Cabal
08:18:05 <phadej> the fact there is only single person working on it actively is just not good
08:18:26 <phadej> say, I want to have a 3-6 months sabbatical
08:19:36 <ezzieyguywuf> what is WT
08:19:42 <davean> Well Typed
08:19:51 <ezzieyguywuf> a Well Typed client?
08:20:15 <dolio> I don't think I said that only having one person actively maintaining it was good.
08:21:07 <davean> ezzieyguywuf: Well Typed is a haskell consultancy
08:21:18 <ezzieyguywuf> ah, interesting
08:21:32 <ezzieyguywuf> I've always wondered how consulting firms actually make money
08:21:43 <ezzieyguywuf> "Hey, you need some advice? I got some for a price!"
08:22:37 <kuribas> companies like when there is commercial support.
08:23:16 <phadej> companies also like when someone else is paying for it :)
08:23:38 <kuribas> what do you mean?
08:23:53 <kuribas> we often hire consultants, and they aren't free.
08:23:53 <ezzieyguywuf> i've considered starting an engineering consultancy (I'm a mechanical engineer by training), but I always get stuck at "why in the world would anybody trust me over anyone else to give them advice?"
08:24:02 <kuribas> well, not me but my company.
08:24:39 <kuribas> ezzieyguywuf: networking is important, if you have some positive clients, they will spread the word.
08:25:04 <ezzieyguywuf> kuribas: sure, but how do you get those first few clients? you know?
08:25:09 <davean> ezzieyguywuf: reputation
08:25:17 <ezzieyguywuf> reputation doing what?
08:25:19 <davean> ezzieyguywuf: By starting with them
08:25:22 <ezzieyguywuf> giving talks at conferences?
08:25:29 <ezzieyguywuf> *shrug* maybe I'm too introverted.
08:25:45 <kuribas> ezzieyguywuf: that can help
08:26:07 <kuribas> ezzieyguywuf: there are courses you can take to improve networking skills.
08:26:19 <ezzieyguywuf> nah, I'm fine at networking and social interaction.
08:26:23 <ezzieyguywuf> I just don't like to do it :-P
08:26:47 <ezzieyguywuf> most people actually think I'm extroverted based on how I interact with them and others
08:29:54 <phadej> kuribas: but projects like cabal need constant support. E.g. to someone to review and merge patches, produce releases etc.
08:30:21 <kuribas> phadej: If I ever manage to get a haskell project running, you guys could consult when I am away?
08:30:42 <phadej> kuribas: I don't understand that question
08:31:32 <kuribas> phadej: I mean, my team lead is afraid that I'll be the only one with haskell knowledge on the project, but I could point him to you guys if necessary?
08:31:36 <kuribas> (paid of course)
08:33:50 <kuribas> phadej: for example, a library that I created http://hackage.haskell.org/package/named-servant-0.0.1/docs/Servant-Named.html
08:33:59 <phadej> kuribas: yes, https://www.well-typed.com/services/ 
08:34:20 <kuribas> great
08:35:28 <kuribas> For example, we spend money on writing tests for our REST API, which was done in postman by some indian guys.  It turned out my colleage had to fix most of these tests.
08:35:46 <kuribas> I would think money is better spend on a good haskell consultant.
08:35:58 <kuribas> Even if they are more expensive than an indian guy.
08:36:21 <kuribas> The value for money is much higher.
08:36:32 <sm[m]> what about a good Indian haskell consultant.
08:38:04 <phadej> in fact, there are indian haskellers
08:38:12 <phadej> not sure whether any of them work as consultant though
08:38:39 <kuribas> I know a good indian haskeller.  He actually works not for from us, in another Belgian company.  He doesn't do consulting though.
08:38:46 <sm[m]> phadej I hope business is good for WT. Haskell seems to be succeeding in industry, bit by bit
08:44:42 <kuribas> Not all indian guys are bad, we have a good infra consultant.  He is also more expensive.
08:45:35 <phadej> I'd say outsourcing "do the boring type-in 1000 things tasks" is just doomed to fail
08:46:03 <phadej> whether you outsource it to india, eastern europe or silicon valley
08:46:12 <monochrom> I am only a bit discontent that most Indian students say "I have a doubt" when for us it's "I have a question".
08:46:59 <kuribas> monochrom: cultural thing?
08:47:05 <phadej> there are cultural difference though, some people do say "this doesn't make any sense", where others are happy do work on nonsense too
08:47:21 <sm[m]> kuribas: you realize it‚Äôs a bit insulting to imply all Indian guys could be bad :)
08:47:46 <monochrom> I say it's a dialectic difference.
08:48:00 <kuribas> sm[m]: that's why I said they aren't?
08:48:06 <sm[m]> and that all Indian engineers are guys. Well I‚Äôll leave it there.
08:48:09 <monochrom> culture is right, but too broad. :)
08:48:30 <monochrom> err, perhaps better s/dialectic/dialect/
08:48:33 <kuribas> sm[m]: it could mean that only the guys are bad, the gals are terrific :)
08:48:51 * monochrom doesn't want to get into a dialectic class struggle!  >:)
08:49:00 <phadej> but otoh, some companies seems to be happy to pay to others companies to do nonsense, and don't want to hear that their specifications are not even wrong
08:49:32 <phadej> so if both parties are happy, ¬Ø\_(„ÉÑ)_/¬Ø
08:50:38 <ja> no, you have a duty to inform people when they are wrong, to prevent them from wasting their lives
08:50:58 <monochrom> But that wastes your life.
08:51:22 <ja> it is very quick to say that
08:51:27 <kuribas> ja: also the internet, you have to prove that the internet is wrong.
08:51:38 <monochrom> https://xkcd.com/386/
08:53:11 <monochrom> My experience (especially with science and pseudoscience) is that it's very quick to be wrong, it's very expensive to explain why that's wrong and what's right. But I guess that's different from talking to your subcontractor.
08:54:44 <kuribas> What we saw with some indian consultancies is that they don't ask questions.  They just do what they are told, and even if they are unsure.
08:54:46 <merijn> If you take informing people they're wrong as your duty, you're opening yourself open to a DDoS :)
08:55:29 <kuribas> merijn: that's how conspiracy theorists work.  They don't win by rational argument, but by numbers.
08:55:57 <kuribas> and it works
08:56:28 <ja> what do you mean "it works"? people who are commonly deemed conspiracy theorists don't have the respect of the average person?
08:56:52 <phadej> ja: I don't know, I do tell that some ideas are "not good", and increasingly leaning towards keeping that to myself
08:56:58 <monochrom> And I explained why they can afford to overwhelm by numbers: being wrong is cheap. You don't see overwhelmingly many more scientists: being a responsible scientist is expensive.
08:57:10 <phadej> ja: it's different when consultancy is asked to "solve a problem" or "produce particular solution"
08:57:27 <nosewings> i'd say >50% of people believe at least one thing that is essentially a conspiracy theory belief
08:58:44 <monochrom> I know one group of conspiracy theorists respected by average mothers. Anti-vaccination.
08:58:51 <kuribas> phadej: I now think it's better to nod, but do the right thing yourself.
08:58:59 <monochrom> s/mothers/parents/
08:59:28 <monochrom> Right? Flat-earthing doesn't really get traction because there is no stake either way for most people.
08:59:47 <monochrom> But vaccination, ah, there is a high stake, therefore FUD is super-easy.
08:59:53 <phadej> kuribas: yes, but consultancies who do that are usually more expensive ;)
08:59:56 <maerwald> some conspiracy theories turned out to be true btw ;)
09:00:17 <kuribas> phadej: like WT?
09:00:19 <davean> phadej: so how expensive a consultancy is WT? ;)
09:02:19 <phadej> davean: I honestly don't know
09:02:31 <davean> phadej: no one I know who works at WT does
09:03:05 <phadej> I have no idea compared to Tweag e.g.
09:03:20 <phadej> or other consultancies
09:03:59 <phadej> but in absolute terms, I wouldn't say WT is expensive
09:04:49 * hackage ngx-export-tools-extra 0.5.3.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.5.3.0 (lyokha)
09:05:13 <NewToHaskell> Hello! I want to create the init function using folds and I am struggling a bit with lambdas, can someone help me? =)  `initFold = foldr (\x acc -> x:acc) []` my idea here is to use foldr and throw away the first (last) element.
09:05:34 <NewToHaskell> but I don't know how to throw it away >:
09:06:21 <ja> NewToHaskell: you can create a pattern match that matches N times on the list constructor
09:06:46 <ja> NewToHaskell: so if you know how to detect where there is only one element left, surely you also know how to discard that element?
09:08:27 <ja> NewToHaskell: the function you pass to foldr currenly has no case splits. if you want it to "not do the same thing" for every element (foldr calls it on every element), you need a case split there. makes sense?
09:08:40 <kuribas> NewToHaskell: does it need to be lazy?
09:09:13 <kuribas> NewToHaskell: is this a homework assignment?  A fold isn't so useful for this.
09:09:24 <Cale> Note that just casing on the rest of the list might not be enough here. If the function you give to foldr as the replacement for (:) produces an empty list when trying to add an element to an empty list, then the list will never become nonempty:
09:09:24 <NewToHaskell> nope, I just want to learn.
09:09:27 <lally> Hi, I'm hitting a ghci-only (8.6.5), panic on a C symbol I have from `c-sources`.  Does anyone know if the bug's been fixed in a later rev, or if there's a way I can set a cabal flag to (a) skip my c-sources and (b) set a CPP symbol that I can #ifdef around and make the call site = 'undefined' instead of the C function I call now?
09:09:34 <Cale> > foldr (\x xs -> case xs of [] -> []; _ -> (x:xs)) [] [1..10]
09:09:36 <lambdabot>  []
09:10:05 <Cale> There are some sneakier things we could do though.
09:10:19 <ja> shift/reset ? :D
09:11:06 <ja> ok i guess my advice kinda sucks given what Cale said
09:14:01 <ja> but in theory still true, no? because the problem description calls for using foldr at the other layer, so where can case splits possibly happen? only in the passed function, right? by folding over something else than a list, surely it becomes possible.
09:14:51 <ja> is this another opportunity to push Witherable ? :D hahaha
09:14:56 <dmwit> NewToHaskell: If you must do it with a fold, then your fold will have to keep track of whether it has thrown an element away or not yet.
09:15:12 <dmwit> NewToHaskell: e.g. you could make your accumulator be a pair of how many elements you want to throw away and a list, like this:
09:15:41 <dmwit> > foldr (\x (n, xs) -> if n <= 0 then (n, x:xs) else (n-1, xs)) (1, []) "abcde"
09:15:43 <lambdabot>  (0,"abcd")
09:16:10 <dmwit> NewToHaskell: If you do not need to do it with a fold, there is a standard-ish trick to turn `drop` into `dropFromEnd`:
09:16:13 <NewToHaskell> Guess I don't have the knowledge for that yet then, still reading LYAH. =)
09:16:35 <dmwit> > (\xs -> zipWith const xs (drop 1 xs)) "abcde"
09:16:37 <lambdabot>  "abcd"
09:17:01 <dmwit> NewToHaskell: If you say which bit you feel you don't have the knowledge for yet, we could help you fill in your knowledge gap.
09:17:27 <monochrom> If you can implement init by your own recursion, you can tell very easily how it is a foldr, or how not.
09:17:52 <NewToHaskell> I did these 'head' = foldr1 (\x _ -> x)' and 'last' = foldl1 (\_ x -> x) ' and thought to myself how I would go about making tail and init with folds and lambdas
09:18:15 <dmwit> monochrom: Dunno. The standard way of implementing init by your own recursion makes it a bit unclear to me how to convert to a fold, because it has two pattern matching base cases but foldr has only one.
09:18:37 <ja> > foldl1 (\_ x -> x) [1,2,3]
09:18:39 <dmwit> monochrom: `init [] = []; init [x] = [] {- this one isn't obviously foldr-like -}; init (x:xs) = x:init xs`
09:18:40 <lambdabot>  3
09:18:45 <monochrom> This particular pattern matching is why you can't use foldr.
09:19:21 <dmwit> ...but I showed above how to use foldr (+snd) to do it. So...???
09:19:35 <monochrom> For a function f to be a foldr, it has to do two things blindly:
09:20:06 <monochrom> 1. it's always "f [] = ..." and "f (x:xs) = ...".
09:20:47 <monochrom> 2. In "f (x:xs) = ..." the RHS has to be "g x (f xs)".  No exception.  init requires an exception here based on xs.
09:21:37 <monochrom> Your foldr is one step away from init. You added an injection and a projection.
09:22:57 <dmwit> I think your demands are too strident. The question just said "I'd like to use foldr". It doesn't demand "and nothing else".
09:23:47 <ja> NewToHaskell: do you already have tail?
09:23:51 <dmwit> ...and I think "I'd like to use foldr" is a good exercise, because it shows how to deal with it when you can't do "and nothing else". =P
09:25:31 <NewToHaskell> ja: I have neither tail or init.
09:26:48 <ja> NewToHaskell: did you understand dmwit's solution?
09:28:16 <NewToHaskell> ja: 'foldr (\x (n, xs) -> if n <= 0 then (n, x:xs) else (n-1, xs)) (1, []) "abcde"'  nope, where is the accumulator in this case?
09:28:32 <NewToHaskell> `foldr (\x (n, xs) -> if n <= 0 then (n, x:xs) else (n-1, xs)) (1, []) "abcde"`
09:28:46 <Cale> NewToHaskell: It's best not to think of foldr as having an "accumulator", I think
09:28:50 <Cale> foldl, sure
09:29:04 <dmwit> If you must think of there being an accumulator, than all the tuples are the accumulators.
09:29:42 <Cale> But yeah, we're using the foldr to construct a pair of... in this case a number (could also just be a Bool) and a list
09:30:05 <dmwit> (1, []) is the starting one. The (n, xs) pattern in the input to the function takes the current one. The (n, x:xs) and (n-1, xs) in the if-then-else branch describe how to update the accumulator in each step.
09:30:06 <ja> NewToHaskell: maybe it would help you to understand it if you extracted the inline lambda to a real defition and gave it type annotations and did some tests on it
09:30:06 <monochrom> At the very least you need a way to tell you "if I don't add an injection and projection, foldr alone can't do it".
09:31:27 <dmwit> (Is "accumulator" a good name? I don't know. It seems fine here to me. Cale disagrees, and he's got a pretty good intuition for pedagogy. Call it what you want, and I'll follow your lead.)
09:32:07 <ja> if accumulator is bad, "state" would be bad too, right?
09:32:13 <Cale> Well, I don't know, it feels weird to me because you're sort of accumulating from the wrong end in a way
09:33:00 <Cale> I suppose it could be fine, but if you think of that thing as an accumulator, it might be very hard to understand why this can work at all:
09:33:13 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
09:33:15 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
09:33:20 <gentauro> is there any reason Haskell doesn't have `anonymous records`? I've never been a fan of them, but I have been coding a bit in PS and I can see why I would preferen them to `tuples`. For example a pair in Haskell it's easy to work with cos of `fst` and `snd`, but what if you have a triple? In PS it would just be: `{fst:‚Ä¶,snd:‚Ä¶,trd:‚Ä¶}` which can be deconstructed anywhere :)
09:33:53 <Cale> We're passing in a list that doesn't end, and so the "accumulation" can never "begin", and yet a result is being produced
09:34:03 <bitmapper> haskell supports accessing individual items of a record by name?
09:34:03 <dmwit> gentauro: I suspect the main issue is with typing record update syntax.
09:34:21 <dmwit> bitmapper: Sure, when you define a record you give a name to each field, which becomes an accessor function.
09:34:40 <bitmapper> i'm used to this being heavily discouraged 
09:34:44 <Cale> gentauro: In cases that really warrant it, I've sometimes used DMap in recent times for that
09:34:45 <dmwit> gentauro: Other than update syntax I don't see much of a reason not to have them.
09:34:47 <bitmapper> from writing standard ml
09:35:41 <NewToHaskell> `foldr (\x (n, xs) -> if n <= 0 then (n, x:xs) else (n-1, xs)) (1, []) "abcde"` isn't n always equal to 1?
09:35:46 <Cale> In fact, using GADTs to define the sets of possible labels in records is such a nice thing that I wish the GHC proposals surrounding records were more aware of it as a possible direction.
09:36:29 <dmwit> NewToHaskell: No: in the else branch, it becomes 0.
09:37:31 <ja> NewToHaskell: if you open up GHCi and type "import Debug.Trace" and then prepend "trace (show n) $ " inside the lambda, you can have every n printed
09:37:33 <Cale> One thing which is really bad about anonymous records a lot of the time is that even if the information about which labels are present and what types the corresponding fields have, there's no guarantee that coincidences are not happening with regard to field name/type pairs, since the labels are not defined externally.
09:37:37 <maralorn> Is it possible, that #if __GLASGOW_HASKELL__ >= 801 not does what it looks like?
09:38:07 <Cale> So, two records might both have a field named x which has type Int, but those Ints could mean two very different things
09:38:11 <maralorn> i.e. I have a built that behaves on ghc 8.0.2 like that condition evaluates to false.
09:38:19 <gentauro> Cale: good point
09:38:40 <gentauro> also Haskell record accessor field functions as dmwit mentions, need to have unique names
09:38:45 <Cale> One thing which could help fight this is the introduction of types that specify universes of possible labels, and implicitly, what those labels mean
09:38:51 <gentauro> for example in OCaml/F#, this is not the case
09:38:51 <dmwit> maralorn: 801 means 8.1.x
09:39:19 <dmwit> maralorn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/intro.html#ghc-version-numbering-policy
09:39:38 <maralorn> ooooh
09:39:48 <maralorn> thaaaaat explains a lot.
09:39:55 <Cale> So that you might end up with labels having the same name, but they won't really be the same because those data constructors were defined in different modules.
09:40:49 <gentauro> I think the syntax for F# to access a field on a record is something like this: `{ Foo.fieldA ‚Ä¶; fieldB ‚Ä¶ }`. Only need to do it for the first one so the compiler knows what it has do deal with
09:40:54 <kuribas> gentauro: there is DuplicateRecordFields
09:40:58 <Cale> Also, that would open up the door for labels which have more structure than just being tags
09:41:21 <maralorn> dmwit: Thank you!
09:41:26 <ja> gentauro: how is that accessing a field on a record? you're making a new record, right?
09:41:35 <Cale> So that you can sort of have a whole compositional language for what fields might be present in a record
09:41:36 <gentauro> kuribas: I guess there is always a GHC extension for everything ;) (like the "Simpsons did it")
09:41:41 <ja> gentauro: in f#, you already have recordDotSyntax, no?
09:42:14 <gentauro> ja: it's been a while since I have coded any F# so
09:42:17 <gentauro> maybe
09:42:36 <fendor> is there a recent report how Cabal the Library can be used to compile a package?
09:42:40 <dmwit> maralorn: I guess this also looks like it could be helpful to you: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#standard-cpp-macros
09:42:54 <Cale> Note, we sort of actually have all the stuff I'm talking about today, in the form of DMap, which is quite nice, but maintains no information about which fields are *actually* present, and it's possible to define a type class that ordinary record types fit into which associates GADT labels to their fields
09:43:16 <ja> the f# syntax for updating records: let myRecord3 = { myRecord2 with Y = 100; Z = 2 }
09:43:24 <Cale> The thing I'm really thinking of will need GADT promotion to work, and that's a little spooky
09:43:26 <gentauro> ja: yes, you are correct
09:44:06 <ezzieyguywuf> how can I change the way that hspec prints out my variables when something fails?
09:44:27 <Cale> But *if* we're going to the trouble of extending the record system in a new direction and complicating the language, I think the benefits of using GADTs to define universes of labels gives us a shot at actually improving things enough that the change is worthwhile.
09:44:32 <gentauro> Cale: iirc Idris has somekind of map with labels to handle records right?
09:44:52 <Cale> I think a lot of the proposals about the record system lately have been pretty pointless and just complicate the language for almost no real benefit.
09:45:06 <gentauro> Cale: good point
09:46:18 <ja> Cale: does that mean you don't like RecordDotSyntax?
09:46:25 <Cale> It absolutely means that
09:46:48 <Cale> RecordDotSyntax is absolutely awful
09:47:17 <gentauro> how does `RecordDotSyntax` co-exist with the `composition` operator? (`.`)
09:47:30 <Cale> There was a point in the proposal process at which there were like 4 or 5 axes along which people couldn't decide about how various expressions should be disambiguated
09:48:11 <Cale> Rather than coming to some consensus, there was a ranked vote which was used to come to some sort of compromise about which solution to pick
09:48:15 <ja> gentauro: https://github.com/ghc-proposals/ghc-proposals/blob/a2f5c4c9fabfaf3ef1e3bfda1b3b4dcc46602b40/proposals/0000-record-dot-syntax.md#231-lexer
09:48:25 <remexre> hm, I'm trying to define a carrier for an effect with fused-effects that allows registering and calling hooks, but this seems weirdly hard
09:48:57 <gentauro> speaking of horrible code, what do you think of my way of piping in Haskell? -> https://pastebin.ubuntu.com/p/3hjWcZDq55/
09:48:59 <ja> gentauro: it looks like it depends on the spacing
09:49:01 <remexre> the effect looks like data Hooks m k where AddHook :: (h -> m ()) -> Hooks m (); CallHook :: h -> Hooks m ()
09:49:02 <Cale> If nobody can decide which of these many disambiguations is the right one, we should be worried about how unintuitive it's going to be
09:49:35 <ja> Cale: good point. maybe the extension can be removed in 10 years if it fails to get traction :P
09:49:38 <remexre> with a Typeable bound on the h in practice, using a TypeRepMap in the carrier to store the functions given to AddHook
09:49:39 <gentauro> I have recently seen that many are trying to port the F#/Elm/Ocaml pipe operator to Haskell
09:49:42 <gentauro> :S
09:49:47 <Cale> ja: Yeah, that would be the best result
09:50:35 <Cale> I almost feel like forking GHC and ripping a bunch of features out, just so that we can make PRs to various repos that say "Added support for BHC" rather than "removed the use of foolish language extension X"
09:50:45 <remexre> but when I try to define an Algebra instance, I run into the issue that it doesn't look like monad it runs in is the same?
09:51:21 <ja> gentauro: i don't like it, there is already (&). to call it "pipe operator" is also misleading, people think it is some magic thing like a shell pipe
09:51:38 <davean> ja: Extensions rot, they don't leave
09:52:02 <Cale> The problem right now is that Haskell has become a monoculture with GHC being the only compiler, so as soon as an extension happens in GHC, nearly everyone feels entitled to use it, even if it was experimental and might not be a good idea in the long run.
09:52:20 <Cale> and yeah, it's really really hard to remove language extensions
09:52:29 <gentauro> ja: F# code goes from top-down and left-to-right
09:52:40 <davean> I personally feel we're being far too accepting of new langauge params
09:52:48 <Cale> We succeeded in the case of linear implicit parameters
09:52:51 <gentauro> and that's how you are supoused to write code cos it's the only way to help the compiler
09:53:09 <remexre> we could just do the Rust thing, and gate some extensions to a special not-recommended, sometimes-buggy build of the compiler
09:53:11 <Cale> and... is that maybe it?
09:53:19 * hackage intensional-datatys 0.2.0.0 - A GHC Core plugin for intensional datatype refinement checking  https://hackage.haskell.org/package/intensional-datatys-0.2.0.0 (eddiejones)
09:54:23 <davean> People proposing extensions clearly have the view "its just an extension" but other people have to deal with all the extensions regularly.
09:54:39 <davean> I don't think 'its just an extension' is working as an arguement
09:54:47 <davean> perhaps gating them somehow would help
09:54:54 <ja> gentauro: what makes you say that? f# has (<|) (dolla sign in haskell) and (|>). which one is not "left-to-right"?
09:54:56 <davean> They leak EVERYWHERE as soon as they show up
09:55:01 <Cale> We're also going down the LinearHaskell road now, for which the best possible future I can imagine is one where essentially nobody touches that thing
09:55:05 <davean> one MUST know every extension to be a general haskeller
09:56:00 <gentauro> ja: if you had ever wrote any F# code, you would know that in order for the compiler to be able to infer (most) types, you need to use the pipe operator heavily
09:56:11 <gentauro> it's not for better readability, it's cos of a limitation of the compiler
09:56:29 <Cale> But we all know that's not going to happen, and we're going to get a bunch of linear libraries with unsafePerformIO'ed safe effects that look like they'll do various jobs and then you'll have to catch an exception and be totally boned.
09:56:49 <gentauro> but since then, as a side-effect (badum tsh) other languages have copy/pasta the operator cos they argue that it makes code more readable
09:57:00 * gentauro Elm, Elixir, Ocaml, ‚Ä¶
09:57:25 <davean> Cale: How would you feel about two build releases of a compiler, one with features marked "in testing" and turned on, the other not? I feel like it would devolve into people using the "in testing" version
09:57:45 <ja> gentauro: is haskell without quick look imprecativity is also "left-to-right", given that ($) can't always be used over parens?
09:58:01 <Cale> Maybe that could work. I mean, I don't really see a distinction between that and just... not putting LinearHaskell into GHC. It already had an implementation.
09:58:17 <Cale> But maybe collectively, that would minimise the amount of additional maintenance work?
09:58:20 <dolio> ja: It is probably a much more annoying limitation than that.
09:58:54 <Cale> To some degree it doesn't really help with one of the biggest issues with these extensions which is that they're greatly complicating the implementation of the language in ways which will likely persist even if the extension goes away
09:59:58 <sm[m]> Cale you or someone should totally make a remixed "simple GHC", such experiments would be valuable
10:00:08 <davean> Cale: Oh I agree. I don't think LH is a good example here, but I do feel theres a lot of extensions people propose that their only reasonable result is Haskell Report inclusion
10:00:11 <davean> but one wants testing first
10:00:26 <davean> I think the LinearHaskell stuff is not ready
10:00:34 <davean> but thats a different type of extension IMO
10:00:44 <Cale> sm[m]: Yeah, I don't know if I really have the spoons for that, but maybe if Obsidian gets large enough, it would make sense for us to have our own compiler implementation.
10:01:21 <Cale> There are a bunch of things I'd like to see as well, which have little to do with the actual frontend of the language
10:01:28 <gentauro> ja: I would argue that `($)` read right-to-left: `‚Ä¶ $ map fst $ zip [0..] $ map id xs` while F# `(|>)` reads from left-to-right: `xs |> Seq.map (fun x -> x) |> ‚Ä¶`
10:02:00 <Cale> and so maybe those efforts could be combined: a simplification of the frontend and potentially the internals of GHC, and at the same time, a better backend/driver
10:02:01 <sm[m]> what changes in GHC would make building and maintaining such variants cheaper ?
10:02:17 <Cale> Factoring GHC into sensible libraries would help
10:02:27 <Cheery> The hierarchical-free-monad -guy made his next move and published a Haskeller competency matrix in r/haskell
10:02:40 <Cale> Like, right now, you have DynFlags which is just a gigantic horrifying pile of mutable state which gets passed everywhere
10:02:45 <davean> Cale: Isn't there already a project for that?
10:02:56 <Cale> and yeah, people are gradually reducing that problem
10:03:19 <Cale> and there's efforts in that direction generally -- the module structure is finally hierarchical
10:03:29 <ja> does haskell treat ($) and (&) the same? that is, can i always switch between them and it still compiles?
10:03:53 <Cale> I really really really wish that GHC devs would stop naming things by writing a sentence describing them and then deleting 80-90% of the letters from it
10:03:58 <Cheery> ja: um.. no?
10:04:05 <Cale> The names in GHC are *so* bad
10:04:19 * hackage rdf4h 4.0.2 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-4.0.2 (RobStewart)
10:04:22 <sm[m]> interesting
10:04:40 <sm[m]> "naming is hard" I guess
10:04:53 <ja> Cheery: of course i assume you also swap the arguments. given that ($) doesn't work everywhere parens do (because of lacking impredicativity) , i can't assume the answer
10:05:06 <davean> ja: HAHAHAA
10:05:37 <dolio> ja: $ does work. It's special cased.
10:05:46 <dolio> (&) is probably not special cased.
10:06:21 <ja> all right. maybe f# were inspired be that then, if what gentauro says is correct
10:07:02 <dolio> F# doesn't have higher rank polymorphism, I think.
10:11:20 <davean> the ACTUAL type for ($) is horrid
10:11:37 <Cheery> :t ($)
10:11:38 <lambdabot> (a -> b) -> a -> b
10:11:47 <Cheery> ohwait..
10:12:11 <Cheery> yeah. I've read something about that. The type shown there is not the exact one.
10:12:44 <dolio> Does the 'real' type even cover the impredicativity? I think that's an additional special case.
10:13:32 <dolio> And is a niche issue that is unlikely to have any influence on most other languages.
10:15:11 <dolio> Sometimes it's just that questionable simplifying assumptions are made. For instance, Scala at least used to do a bunch of left-to-right type checking, where putting arguments to functions in different orders would determine whether or not it was able to infer things.
10:15:44 <dolio> Also having separate parameter groups would influence it. So `f(x)(y)` might allow inference, but `f(x,y)` would not.
10:16:48 <ja> those are problems you're less likely to have with a good spec, right? especially if it comes with a test suite
10:17:04 <ezzieyguywuf> Cale: that's either the second time I've heard you say that in here, or just the second time I've heard it in here. can you show an example of this ghc naming thing I'm super curious
10:17:59 <ja> ezzieyguywuf: if you see goldfirere's talk from zurihac, you can get a taste
10:18:13 <ja> (richard eisenberg)
10:18:21 <Cale> You can just open the GHC source code anywhere and see stuff like tcInstSuperSkolTyVarsX
10:18:42 <ezzieyguywuf> oh, now I understand
10:18:44 <Cale> mkTcUnbranchedAxInstCo
10:18:51 <ezzieyguywuf> that is so bad!
10:19:01 <ja> ooh maybe that is the source of Axman6's name!
10:20:22 <Cheery> ja: something something.. type inference in system F is undecidable
10:21:42 <ja> Cheery: so if i have type annotations all over the place, there are no problems with ($)?
10:21:54 <Cale> ezzieyguywuf: It's really brutal when you're trying to make some change which introduces a new data constructor or changes some data type, and you run into all these functions which have names that are just complete gibberish, and their implementation isn't very clear, and then also they don't have nearby comments about what it is they're trying to compute...
10:22:17 <Cheery> ja: I'm not sure because Haskell uses the algorithm to typecheck it.
10:22:21 <Cale> and then they also often have fallthrough cases which means that the compiler will actually build without warning
10:22:24 <ezzieyguywuf> Cale: yikes! sounds brutal af trying to improve upon ghc
10:22:35 <Cale> and then just fail when it hits your case
10:22:49 <hyperisco> sounds like any organically grown software I have ever seen
10:22:52 <ezzieyguywuf> sounds like someone needs to write a competitive haskell compiler üò¨
10:23:33 <Cheery> there's interesting stuff about typeclasses. I'm not sure but shouldn't everything be a typeclass?
10:23:51 <Cheery> and then if you did that way, you'd have a bit different language than Haskell.
10:24:25 <Cale> So you just spend a lot of time staring at how things get used and trying to decipher it, and if you do nonfunctional refactors to try to clean it up, (1) there will be push-back and (2) be prepared to spend in some cases weeks shepherding your PR along
10:24:55 <Cale> The CI system randomly fails (it's literally nondeterministic)
10:25:41 <ja> you could also see it as IDE usage motivation, since comments from the function you hover become even more useful :P
10:26:02 <Cale> I've been getting paid to add some features I don't personally care much about to GHC lately, and it's been pretty exhausting.
10:26:08 <Cale> Oh, also, haddock.
10:26:22 <ezzieyguywuf> Cale: what's wrong with haddock?
10:26:27 <Cale> Haddock is a git submodule of GHC
10:26:34 <Cale> But it's intimately dependent on the GHC internals
10:26:39 <amf> using aeson, is there a way to get an objects key when i don't know the name? eg `{ "some-random-number" : { } }`
10:26:50 <Cale> and typically a given hash of haddock will not build without a specific hash of GHC
10:27:01 <ezzieyguywuf> oh lawd
10:27:02 <Cale> but there's nothing in the haddock repo to tell you which GHC you need to build it
10:27:10 <ja> amf: convert it to a map and list the keys?
10:27:18 <Cale> The reference goes in the wrong direction
10:27:29 <Cale> and really these things should not be in separate repos at all right now
10:27:33 <ezzieyguywuf> this type of stuff is so sad: such a great overall end-product, but executed so poorly that it's difficult to volunteer contributions
10:27:39 <ezzieyguywuf> especially given the pushback you mentioned
10:27:56 <amf> ja: ah ha! thats one way, I'll try that, thanks!
10:28:33 <niso> hi, newbie here trying to get started with the Turtle library, by chance someone could explain this error to me? http://paste.debian.net/1157692/
10:29:37 <Cheery> niso: you supplied (ExitCode, Text), but context expected for Text
10:30:15 <niso> Cheery: procStrict should evaluate to (ExitCode, Text), where am i supplieing it?
10:31:27 <ezzieyguywuf> neat, this is the first I've heard of turtle
10:32:41 <Cale> ezzieyguywuf: Oh, right, I bet the reason *why* the reference between GHC and Haddock is not in the opposite direction instead is that GHC's use of git is intensely focused on everything being rebased all the time
10:32:49 <Cheery> niso: I'm not sure. It's hard to track what's going on there.
10:33:37 <Cheery> niso: you want to exec something per file, then apply it to multiple things there?
10:33:59 <Cale> Which also makes it really hard, at least for me, to understand what's going on most of the time, and has caused some consternation lately when someone has a really long rebase on the go, and git just has no way for them to share their work.
10:34:01 <Cheery> so you get the exitcode and response text for each command
10:34:33 <niso> Cheery: i want to exec 1 command on N files, and return a list of N elements with (ExitCode, stdout :: Text)
10:34:36 <Cheery> niso: that's actually.. not necessarily happening because shell commands do not work this way.
10:35:02 <Cheery> but it seems you're close to making it work
10:35:15 <Cheery> shell commands can be interactive.
10:35:36 <Cheery> so your program only works on noninteractive shell commands.
10:35:37 <niso> Cheery: i'm tyring to get this to work for a couple of hours now, glad i got close :P
10:35:47 <niso> Cheery: exactly, my test command is "cat"
10:36:55 <niso> only non-interactive commands will be executed, order doesn't matter
10:37:10 <sm[m]> Cale, you're not calling for a return to darcs are you ? :)
10:37:14 <Cheery> niso: so would it be cat file1 file2 file3, or cat file1, then cat file2, then cat file3 ?
10:37:41 <niso> Cheery: the second option
10:37:41 <Cale> sm[m]: No, I just hate git rebase
10:37:49 <niso> Cheery: cat file1, cat file2 ...
10:37:49 <sm[m]> gotcha
10:38:03 <Cheery> niso: your type gets Shell [Text] as argument, is this intended?
10:38:27 <sm[m]> do you by any chance have a blog ? Your GHC peeves would be a good reference 
10:38:32 <Cale> sm[m]: I think the world needs a VCS which handles extremely granular information about chains of changes in a much better way
10:38:39 <niso> Cheery: yes, it's the result of another function
10:38:51 <Cale> Like, to the point that you could store your editor's undo history in it without being overwhelmed
10:39:08 <Cheery> niso: what is a Shell? It's at least a functor, is it a monad as well?
10:39:16 <Cale> I don't at this point
10:39:23 <niso> Cheery: to give you some context, the other functions: http://paste.debian.net/1157693/
10:39:38 <niso> Cheery: yes, it's a functor / monad / applicative / IO
10:39:52 <niso> Cheery: https://hackage.haskell.org/package/turtle-1.5.19/docs/Turtle-Shell.html#g:1
10:40:06 <Cheery> niso: in that case, you can make it into Text -> [Text] -> Shell [(ExitCode, Text)]
10:40:14 <ezzieyguywuf> Cale: noooooo rebased things should not be pushed to a public repository! at lest not lightly!
10:40:51 <Cale> ezzieyguywuf: There are no merges in this repo
10:41:31 <Cheery> niso: ok.. so lets see.. what's the type of procStrict ?
10:41:58 <ezzieyguywuf> "there are no merges in this repo"
10:42:01 <niso> Cheery: https://hackage.haskell.org/package/turtle-1.5.19/docs/Turtle-Prelude.html#g:5
10:42:06 <ezzieyguywuf> ezziey: "Then....how do you....wait....what?!"
10:42:18 <niso> Cheery: oh, sorry thought it'd link to the correct line
10:42:41 <niso> Cheery: MonadIO io => Text -> [Text] -> Shell Line -> io (ExitCode, Text)
10:43:12 <Cale> ezzieyguywuf: Everything gets rebased into a revised linear history all the time
10:43:18 <ja> ezzieyguywuf: how do you do pull requests without rebasing during review?
10:44:12 <ja> ezzieyguywuf: are you using darcs? if you change a patch you mailed because of feedback, does that not count as rebasing?
10:44:44 <ezzieyguywuf> i use git. I hardly ever rebase: I'll rebase --interactive once before merging a branch into main, but that's only to squash up some few commits
10:45:00 <ezzieyguywuf> I'd never rebase master and push to the repository, or at least not lightly
10:45:21 <ezzieyguywuf> Cale: whyyyyyyyyy.
10:45:22 <ja> ezzieyguywuf: but what if master evolves during the process of PR review?
10:45:27 <ezzieyguywuf> "At least the git history looks nice!"
10:45:37 <ezzieyguywuf> ja: git merge master
10:45:44 <ezzieyguywuf> fix any issues/conflicts
10:45:50 <ezzieyguywuf> then get merge myFeature
10:46:01 <ezzieyguywuf> ofc, right now, it's *just* me, working on one feature at a time
10:46:05 <ezzieyguywuf> so....you know, ymmv, lol
10:46:17 <ja> ezzieyguywuf: but then PR reviewers have to look at your merges? what is the point?
10:46:34 <Cale> The point is not destroying information about what happened
10:46:54 <ezzieyguywuf> ja: I'm no expert. like I said, I'm only working on my own now, so I haven't had a need to do these things in any sort o 'big' way.
10:47:23 <Cale> How that information is presented to reviewers of PRs is one thing -- it might not be necessary for them to look at the merges -- usually they could focus on the overall diffs
10:47:31 <ezzieyguywuf> ja: but my understanding of git is that if I merge master into my current branch, it does nothing more than sync master's history to what I've been working on, making for painless merge into master afterwards
10:47:45 <dsal> ezzieyguywuf: I've seen people make this argument, but I don't understand it.  Your repository shouldn't be an infinite undo history, but a list of changes that you make that are meaningful and well thought out.  This usually happens after you do a bunch of dumb stuff that neither you nor anyone else will ever need to think about again.
10:47:51 <ezzieyguywuf> if something i master changes that affects my feature, I may need to 'cherry pick' that, but again I've never had to do that yet
10:48:05 <Cheery> niso: First drop the 'Shell' from the argument, or do you have rationale for why it should be there?
10:48:05 <sm[m]> this debate is as old as git...
10:48:06 <Cale> Honestly, they ought to be able to select any pair of points in the history of the branch which is about to be merged and visualise the difference, but gitlab/github don't really do that
10:48:28 <dsal> sm[m]: I used mercurial queues before I started using git.  :)
10:48:33 <Cheery> niso: if Shell is a monad, you don't need that unless there's some reason for it.
10:48:46 <Cheery> so your type would be
10:48:48 <Cale> and so people end up with strange opinions based on the limitations of these tools
10:48:58 <ezzieyguywuf> dsal: here's what I know - I spent some time (a few hours at least) reading up on git workflows and different ideas on whats good/bad etc and ultimately landed on where I am now
10:48:59 <Cheery> execOnFiles :: Text -> [Text] -> Shell [(ExitCode, Text)]
10:49:07 <ezzieyguywuf> whether it's right or wrong I can't say, but it does make sense to me.
10:49:26 <Cheery> :t mapM
10:49:28 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
10:49:41 <Cheery> niso: see where this is going to?
10:49:47 <Cale> Like, there's not really any reason in principle to lose the information about what happened to the contents of the repository, except that that information is being presented poorly and it's overwhelming
10:49:59 <hyperisco> some people treat revision control as a backup utility rather than a documenting utility
10:50:18 <Cheery> niso: look at the m (t b), think that it's Shell [(ExitCode, Text)]
10:50:24 <niso> Cheery: alright, will drop it. i had it there since that way i could just pipe it to the previous function. But you are right, removing it results in a cleaner interface
10:50:26 <dsal> ezzieyguywuf: Sure.  There's this weird thing where lots of people don't understand things the way I do (correctly) and are wrong.  I see it everywhere.  I'm always amazed about how people can be wrong about all these things that I know the right answers to.  :)
10:50:39 <Cale> I want a VCS where my entire editor history goes into version control, so I can scroll through everything I ever typed
10:50:40 <ezzieyguywuf> dsal: ü§£
10:50:49 <hyperisco> dsal, would you agree with that?
10:51:05 <ja> Cale: so, darcs with a mailing list with an archive? :P
10:51:05 <Cale> and then whenever I compile the repo and it succeeds, the state gets marked as compiling
10:51:07 <Cheery> niso: so 't' ends up being a list, the 'm' ends up being 'Shell'
10:51:23 <dsal> hyperisco: Yeah, I agree that that happens, but it's really unfortunate.  I *do* things like that, but then I clean them up to publish them after I figure out what I was actually trying to do.
10:51:30 <kuribas> But git actually keeps the complete history, even if you rebase, ammend, etc...
10:51:31 <Cale> ja: no, this is way crazier than anything darcs ever did
10:51:33 <ezzieyguywuf> dsal: srsly though, I can say that I've worked on projects before where I wanted to know "what in the world is the history of this function? How did it end up like this?" but because folks were so cute about rebasing and squashing and stuf I was unable to find any useful info
10:51:49 <Cheery> niso:  mapM (\y -> procStrict cmd [y] empty) files
10:51:59 <hyperisco> dsal, I am so forward looking that personally I'm not much interested in either use :P
10:52:04 <Cale> and then when I reach any kind of milestone, I can raise the importance level of a state to one of a number of values
10:52:29 <ezzieyguywuf> Cale: git tag v0.0.2
10:52:36 <Cale> (and I can comment on any state, like a commit message, but commits are continuous and automatic)
10:52:44 <dsal> ezzieyguywuf: These concepts aren't mutually exclusive, though.  There should be a small commit that introduces a change.  You don't need to know the entire history of the editor states that got there, but the thing that's published should be well thought-out, but as small as possible.
10:52:45 <sm[m]> somebody should give Cale a grant to build his shiny stuff
10:52:48 <ezzieyguywuf> git tag v0.0.2 -m "This improved soething"
10:52:50 <niso> Cheery: are you using mapM because you want it to result it in a Shell monad?
10:53:16 <Cale> You shouldn't have to explicitly commit things
10:53:21 <Cale> That should just be happening constantly
10:53:32 <Cale> Everything should be going into version control
10:53:33 <hyperisco> now there's a big brain take
10:53:39 <ja> but then what about things that can't be tested, like docs?
10:54:02 <ezzieyguywuf> dsal: there's a definite art to writing "good" commit messages. `git commit -a -m 'Fixed some stuff'` is hardly useful. I've seen this polluting various projects
10:54:12 <sm[m]> Cale: you'd need a pause button, sometimes you want privacy
10:54:29 <hyperisco> I definitely did not type a disparaging comment about upper management and then delete it
10:54:31 <Cale> I mean, sure there are reasons that you might want to revise history
10:54:35 <ja> and how to integrate PR review in this system?
10:54:35 <dsal> ezzieyguywuf: Yeah, that's a terrible thing.  I'm not happy about lots of my commits, but when I remember to be good at things, I do pretty well.
10:54:41 <sm[m]> that's what this boils down to, where's the line between developer's private work and immortal public record
10:54:57 <Cheery> niso: mapM maps the list of text elements into list of Shell (ExitCode, Text)
10:55:15 <Cale> and you might not want to waste the time and space on pushing unimportant states across to the public repo either
10:55:15 <dsal> Cale: I rewrote all of the memcached commit history after manually going back and figuring out the actual person who wrote each patch that got thrown into cvs or subversion or whatever back in the day.
10:55:42 <hyperisco> if the only measure of importance is yes/no compiles, I think you'll end up with a lot of otherwise unimportant revisions
10:55:43 <Cale> So just pushing everything above a particular importance level should be a thing you can do
10:55:43 <ezzieyguywuf> dsal: I'll tend to just commit any time something changes, making sure that the commit message is instructive as to what changed.
10:55:54 <hyperisco> adding a comment is compiling
10:56:00 <Cale> and you get to keep your unimportant changes locally then if you want
10:56:10 <Cheery> niso: then it sequences them, the result is that traversable "falls" inside the monad.
10:56:13 <Cheery> :t sequence
10:56:14 <ezzieyguywuf> dsal: I read an article somewhere that advocated this, with a `git rebase -i master` prior to merging into master, and doing "post-production" on your git history preparing it for the merge
10:56:15 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
10:56:41 <Cheery> niso: list of actions turns into list of results after the actions have been sequenced in order.
10:56:48 <dsal> ezzieyguywuf: Sure, keep doing that.  But if you send me a PR that's adds a small feature with a hundred commits of all the ways that didn't work, I'm going to ask you to fix that.  :)
10:56:57 <ezzieyguywuf> e.g. when they're shooting film for a movie, they camera is rolling a lot more often than is needed, and afterwards some guy/gal goes back and cuts it together into the feature film
10:57:10 <ezzieyguywuf> dsal: ofc! as well you should
10:57:21 <ezzieyguywuf> although i tend to skip the 'post production' step b/c I'm lazy....lol
10:57:23 <Cale> I should be able to say -- push all the changes which are importance level 2 or higher, or which have a compiling flag set.
10:57:35 <niso> Cheery: would it be valid to fmap the function, and sequence it in the end?
10:57:35 <dsal> We're all lazy.  That's why we're in #haskell
10:57:41 <ezzieyguywuf> lol.
10:57:57 <Cale> The compiling flag would be really nice for being able to bisect of course
10:58:02 <hyperisco> are going to go through this ultimately verbose change history Cale and tag importance levels?
10:58:09 <Cheery> niso: fmap takes (a -> b), then turns m a to m b
10:58:13 <ezzieyguywuf> dsal: however, I would push back if you wanted me to squash into one monolithic commit that touches 10's or 100's of loc
10:58:16 <ja> Cale: should the system be integrated with bug tracking? should the system be federated so that you can track upstream bugs? ;)
10:58:24 <Cale> hyperisco: I'm thinking that's something you usually do at the times that you would normally "commit" something in git
10:58:28 <ezzieyguywuf> I think there's value to breaking down the changes into chunks with descriptive commit messages to each.
10:58:36 <Cheery> niso: so if you fmap the function into the list, then yup.
10:58:40 <Cale> You raise the importance level of the state of the repo, add a comment to it
10:58:52 <Cale> and do a build to make sure it's compiling, which will set the compiling flag :)
10:59:17 <Cheery> niso: I guess you'd get your Shell [Text] working wit this style as well.
10:59:23 <hyperisco> Cale, so what you're doing is you're deconflicting motives for committing
10:59:25 <dsal> ezzieyguywuf: It depends.  But yeah, the important things are that they should be meaningful.  One thing I do as part of rewriting swaths of commits is verify that they always compile.   I have this thing: https://github.com/dustin/bindir/blob/master/git-test-sequence which I run across a series of commits I want to send.  They all need to compile.  If they don't, I'm going to have a bad time bisecting.
10:59:32 <Cale> hyperisco: yeah
10:59:37 <Cheery> niso: types communicate intent though.
10:59:41 <niso> Cheery: alright, but then why would you prefer mapM? i think i read somewhere in the wiki that it's recommended to use the "lower" typeclass if possible
10:59:44 <Cale> hyperisco: and removing the excuses for losing history
10:59:46 <ezzieyguywuf> Cale: sounds like your volunteering to start hgit
10:59:46 <sm[m]> decomplecting
11:00:10 <Cale> hyperisco: One of the main reasons that people rebase is to be able to bisect more reliably
11:00:14 <hyperisco> Cale, such as, am I committing "WIP" because I want to back this up in case my drive fails overnight, or am I committing this because I want to pull it up on a coworker's machine, or am I committing this because I have finished a feature that needs to be pulled back into the dev branch
11:00:14 <dolio> This is all based on the assumption that you want the repository contents to be the exact state of everything you've edited or something, which is wrong.
11:00:28 <Cheery> :t mapM
11:00:30 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
11:00:31 <Cheery> :t sequence
11:00:32 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
11:00:41 <Cale> But if you can go through and bisect every state of the repo which ever compiled, surely that's better than only having the states which people explicitly put in rebases
11:00:46 <ezzieyguywuf> dsal: that's good! I don't :-P but I do give myself commits like "Changed such-and-such, this tests fails", and then the next few commits will lead to "this test now passes", which would be an obvious squash of someone were forcing me to
11:01:03 <Cheery> niso: the overall result is similar, you need the same stuff to do it.
11:01:06 <Cale> dolio: Well, that's what *I'd* personally like to have
11:01:19 <dsal> ezzieyguywuf: I've spent enough time doing bisection that it's very important to me that everything "works" for some degree of works.
11:01:25 <ezzieyguywuf> hyperisco: why would you commit in those cases?
11:01:27 <Cheery> niso: it's not a wrong advice to use lower typeclass.
11:01:31 <ja> Cale: but 'importance' is a function of the job you're trying to solve. so should it be one-dimesional?
11:01:40 <hyperisco> ezzieyguywuf, because it works to solve the problem. What might you do?
11:02:11 <ezzieyguywuf> dsal: i believe you! I'm not really a coder, I just do this for fun, so I haven't had to deal with a bunch of the gnarly stuff that comes up when you do things forrill
11:02:36 <Cale> ja: There probably should be a bunch of user-definable metadata that can be added, but I think a one-dimensional importance field would be a good help to user interfaces that have to display the history
11:02:56 <ezzieyguywuf> Cheery: it's not he use-case of version control.
11:03:01 <Cale> ja: and then you can have additional things like "did the tests pass?"
11:03:33 <ezzieyguywuf> Cheery: I would `git checkout -b myNewFeature` and commit often, as I've been describing here. that way I don't have to worry about stuff crashing overnight etc, it's easy to share with friends
11:03:42 <ezzieyguywuf> hyperisco: ^ that was meant for you
11:03:43 <sm[m]> And what was the performance change
11:03:48 <xsperry> niso, you're not using 'lower typeclass'
11:03:52 <xsperry> :t sequence
11:03:54 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
11:04:00 <ezzieyguywuf> hyperisco: and then in the end, I would `git rebase -i master` and squash any silly things that shouldn't go to the main branch
11:04:18 <dsal> It looks like someone's talking about #haskell here.
11:04:22 <ezzieyguywuf> true
11:04:24 * ezzieyguywuf shuts up
11:04:35 <niso> xsperry: oh, you are right
11:04:36 <dolio> Merging doesn't put them in the main branch, though. There's still a fork in the graph.
11:05:13 <dsal> directs to #haskell-offtopic
11:05:57 <xsperry> hmm, actually, wouldn't Applicative be good enough for sequence? 
11:08:34 <ja> that's why there is
11:08:37 <ja> :t sequenceA
11:08:39 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
11:09:18 <niso> Cheery: i think i got your line of thinking - thanks a lot for your help, i'll write a proof of concept to doublecheck :)
11:10:22 <niso> means with sequenceA using sequence would indeed be the prefered solution?
11:10:53 <Cheery> :t sequenceA
11:10:54 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
11:11:06 <Cheery> I don't remember them all. hm.. yeah, I guess.
11:11:10 <xsperry> ja, they change the type from list to Traversable, odd that they also didn't change Monad to Applicative
11:11:11 <niso> resulting in: execOnFiles cmd files = sequenceA $ (\y -> procStrict cmd [y] empty) <$> files
11:12:00 <niso> Cheery: mapM looks cleaner/shorter though
11:12:12 <xsperry> I'd just use mapM
11:12:25 <Cheery> I wonder if there's difference.
11:12:31 <xsperry> unless you have a specific reason not to, for example:
11:13:07 <niso> i assume the only difference is that the compiler could further constrain the function for optimization
11:16:06 <xsperry> :t sequence_ . intersperse (putStrLn "") . map putStrLn $ ["one", "two", "three"]  -- maybe not the best example, but I found it useful a couple of times to insert an action in between a list of actions, before sequencing them all together
11:16:07 <lambdabot> IO ()
11:17:00 <ezzieyguywuf> hah, nice, `intersperse (putStrLn "")`
11:17:34 <niso> xsperry: looks indeed useful, thanks
11:20:46 <ja> i just use forM_ when in IO :O the stuff i have in main is just for testing
11:21:21 <ja> and do notation all over the place :P
11:22:19 <ja> also , i got myself used to doing "snd $ flip runState initial $ do". is there a better way?
11:22:49 * hackage commonmark-extensions 0.2.0.1 - Pure Haskell commonmark parser.  https://hackage.haskell.org/package/commonmark-extensions-0.2.0.1 (JohnMacFarlane)
11:23:14 <ChaiTRex> :t (execState, evalState, runState)
11:23:15 <lambdabot> (State s1 a1 -> s1 -> s1, State s2 a2 -> s2 -> a2, State s3 a3 -> s3 -> (a3, s3))
11:23:39 <ja> aaah, thanks!
11:23:49 * hackage language-dickinson 1.1.0.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.1.0.0 (vmchale)
11:29:07 <ja> seems like i still need the flip
11:31:33 <Cheery> niso: I'm writing a book, would you like to review a chapter in exchange to help?
11:31:50 <Cheery> http://boxbase.org/unpublished/book/eq_reasoning.html
11:46:27 <niso> Cheery: will do, i'm too tired now to give some constructive feedback, i'll send you a pm tomorrow
12:01:08 <NewToHaskell> Any tips on other programming languages that are popular and got concise, compact solutions like Haskell? My exams are coming up and Haskell was fun to learn.=)  
12:02:31 <dgpratt> NewToHaskell: such languages would probably be popular here https://codegolf.stackexchange.com/
12:03:08 <tomsmeding> NewToHaskell: for example, I remember someone created https://github.com/barbuz/Husk/ a while ago
12:03:43 <infinisil> dgpratt: Beat me to it
12:03:53 <infinisil> NewToHaskell: I would've suggested https://github.com/Adriandmen/05AB1E :P
12:15:21 <dgpratt> I see questions that don't actually require any real Haskell knowledge as my specialty (especially in this forum)
12:18:40 <Cheery> oh. I just realised could have told him about microkanren.
12:19:00 <Cheery> it's a logic programming language you can embed into haskell.
12:33:27 <ADG1089_> how to convert 200+ files to UnicodeSyntax
12:33:45 <L29Ah> sed
12:33:56 <int-e> don't?
12:34:02 <L29Ah> ^
12:34:05 <yushyin> I second int-e
12:34:44 <Cheery> from what syntax?
12:35:53 <Cheery> first figure it out for one file, then generalize for any file, then mapM
12:36:41 <Cheery> also I suppose you don't want the originals to be lost, you produce new file with the desired properties.
12:38:08 <monochrom> I'm pretty sure it is not a Haskell question.
12:38:15 <ezzieyguywuf> Œª lol, I typed a lambda
12:39:52 <Cheery> ... oh right. he wants UnicodeSyntax in there.
12:40:26 <Cheery> plus translation of symbols.. right.
12:40:41 <Cheery> completely missed the point.
12:42:06 <Cheery> needs utility for reading and writing haskell files then.
12:46:16 <ADG1089_> from normal haskell
12:46:52 <Cheery> yup, I get what you mean. Is there an autoformatter for haskell? is your question.
12:48:22 <Cheery> https://www.google.com/search?safe=off&q=gofmt+for+haskell
12:49:07 <Cheery> well not exactly, but.. ideally a well-equipped autoformatted would be able to do that.
12:59:13 <davean> There are a number of autoformaters
12:59:29 <Cheery> yeah, does any of them are able to convert to unicode?
13:00:30 <davean> why would you search for "gofmt" though there?
13:00:43 <davean> I'm curious why you think using *that* would find you a haskell code formater
13:00:48 <davean> instead of ruin your resulrs
13:02:14 <Cheery> just a brainfart of thinking searching with popularized keyword would result in different results.
13:03:26 <davean> Personally I think of what you're talking about more as refactoring, and there are tools like HaRE for that
13:04:41 <monochrom> Nice! From Haskell Weekly News yesterday: "generalized church is the curry-howard of naster-tarski" is pretty neat. Why didn't I think of that?
13:04:53 <davean> https://engineering.fb.com/open-source/retrie/
13:06:36 <davean> Cheery: theres probably better tools but its an option
13:06:49 * hackage graphql 0.9.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.9.0.0 (belka)
13:26:41 <monochrom> onoes, GHC 8.12 coming, and new Windows I/O manager.
13:27:41 <davean> monochrom: I mean how is that a bad thing?
13:27:46 <maerwald> brace for impact
13:27:57 <monochrom> I mean oyes :)
13:28:47 <monochrom> When you win the lottery you may go "noo... that's can't be true... omg this is not happening" :)
13:29:20 <monochrom> you may also break into tears
13:30:15 <davean> I mean someone is still supporting windows, which is a wonder, but apparently they are!
13:30:21 <koz_> monochrom: No record dot proposal though. :(
13:30:27 <davean> koz_: good! :-p
13:31:00 <monochrom> The new one is a lot of years' work and looks amazing.
13:31:18 <davean> Yah I just don't think it gives enough to be worth having yet-another-thing
13:31:28 <monochrom> But haha: "Some highlights:" "* Drops Windows Vista support"
13:31:52 <davean> I mean, I'd want to actually gain something for "yet another"
13:32:36 <monochrom> I think I would not mind a "record # syntax". But please not dot.
13:33:03 <davean> Yah, that fact that its . is what upsets me
13:33:10 <monochrom> I think I would positively vote for a "record $ syntax" just so to annoy people who cargo-cult $.
13:33:54 <davean> The RecordDot stuff really upsets me actually because of the horrid place in the syntax it occupies
13:35:54 <Cale> monochrom: More people speaking up about how they don't like that one would be appreciated. It might be "too late", but I dunno.
13:36:27 <davean> Cale: I don't care if it ends up in the report, it should NEVER be too late.
13:37:15 <monochrom> Where where?
13:37:59 <Cale> https://github.com/ghc-proposals/ghc-proposals/pull/282 -- I guess here?
13:38:58 <Cale> I don't know if people will still get notifications for that, but hopefully.
13:39:07 <Cale> Maybe we should immediately make a proposal to remove it
13:39:37 <Uniaika> or just make a proposal to make it optional
13:39:38 <Uniaika> (oh wait)
13:39:41 <Cale> But given that the original proposal went through, I don't know if it'd be worth anything trying to just revert
13:39:47 <davean> Cale: I 100% support a proposal to remove
13:39:53 <Cale> It is optional, the problem though is that no language extension is truly optional
13:40:19 <davean> It would be different if the language had been designed for it
13:40:19 <Cale> Once something is in GHC, people will use it, and users will have to know about it and deal with it
13:41:02 <davean> Somehow the votes aren't against it yet I know a lot of people who don't like it.
13:41:11 <davean> I feel theres something missing in that entire process
13:41:44 <c_wraith> Same thing as happened with Linear haskell.  Only people for something are incentivized to speak up.
13:41:49 <c_wraith> Everyone else just gets yelled at.
13:41:58 <davean> c_wraith: No, no, people DEFINATELY spoke up LOUDLY against LH
13:42:13 <davean> Thats when I gave up on the process
13:42:22 <davean> to my knowlege the issues raised were never addressed
13:42:27 <Cale> I lost my goddamn mind for 3 or 4 days burning social capital and shouting at people over Linear Haskell and it did no good
13:42:51 <davean> Right, and you weren't the only one
13:43:31 <Uniaika> what was the issue with LH?
13:45:02 <Cale> It's a very heavyweight change, it was already implemented in a separate branch of GHC, which should be enough for the kinds of experimentation required to demonstrate that such a giant change to the language and its implementation would be valuable, and yet the examples of how it might be useful are, at least from my perspective, quite unconvincing toys.
13:45:38 <Cheery> I wonder how to access LH
13:45:39 <c_wraith> there's also the thing where exceptions break the guarantees it provides.
13:45:43 <Cale> Often with caveats that would mean extending those toy programs to a real world setting would be impossible -- often because they preclude handling I/O exceptions in the midst of the computations.
13:45:54 <Cheery> but got no idea if there's enough in it that I could implement the stuff I'm interested about.
13:46:11 <Cale> Like, they gave this example of a linear thing for dealing with sockets
13:46:41 <monochrom> Ah, exceptions totally will happen with sockets. Left right and centre.
13:46:43 <Cale> If some beginner picked that up and tried to actually use it, they might be extremely frustrated with the inability to catch exceptions without taking down their entire server
13:47:12 <monochrom> Like, why don't they just stick with Wadler's array example :)
13:47:20 <monochrom> s/with/to/
13:47:21 <davean> I mean it talked about a question asked but litterly never answered it
13:47:28 <davean> and they were like "see, we responded!"
13:47:36 <Uniaika> monochrom: data Everywhere a b c = Left a | Center b | Right c
13:47:38 <davean> but ... no, the question was more specific than that and they ignored it
13:47:47 <Cale> Yeah, I felt like people totally did not get what I was asking for
13:47:57 <Uniaika> I see
13:48:09 <c_wraith> there's also the social factor that I have yet to see addressed: how does this not split the library ecosystem in a way no other extension has?
13:48:17 <Cale> When I was asking for one real worked example use case of linear types
13:48:30 <monochrom> Wadler's array example is convincing. And I thought their I/O story solved exceptions too.
13:48:48 <Uniaika> I never quite got the attraction for linear types in the domain space where Haskell evolves, but it would be neat if it led to performance gains in the RTS
13:48:56 <Cale> In the end, there were a couple of things related to pure parsing/transformation type problems, using linear types to make some unsafePerformIOs safer
13:49:05 <Cale> that weren't completely bullshit
13:49:09 <davean> monochrom: they claimed it, but what they pressented didn't as I recall?
13:49:33 <Cale> But (1) I'm still not certain those libraries couldn't just be written in a slightly different style, using a Category instance
13:49:59 <Cale> and (2) if that's all we get, I doubt the whole thing is worth its weight
13:50:32 <frdg> liftIO is my favorite function
13:50:40 <Cale> Uniaika: That's the thing, LinearHaskell does nothing for performance, except making it slightly worse at the time being
13:50:50 <Uniaika> wait really?
13:50:50 <monochrom> haha
13:51:02 <Cale> It's *just* a restriction on the code you can write
13:51:13 <Uniaika> like, there's no optimisation due to the fact that stuff is statically certain to be used only once?
13:51:17 <Cale> right
13:51:23 <Cale> It's not uniqueness typing
13:51:40 <Cale> So they don't even get the same ability to optimise that uniqueness typing would have granted us
13:51:45 <Uniaika> well I don't mind restrictions that prevent fits of idiocy from the devs
13:51:52 <davean> Uniaika: And if you look at the non-marketing, its clear
13:52:16 <Uniaika> but I came to understand that there was some pressure relief from the runtime in the context of linear types (outside of Haskell I mean)
13:52:26 <Cale> So yeah, if there were real problems where, hey we have lots of bugs that are arising from people using the parameters to functions more than once, that would be one thing
13:52:57 <Cale> But we've worked out styles of programming which sidestep the need for that most of the time, and maintain type safety nonetheless.
13:53:51 <Cale> The best example cases of LinearHaskell thus far are just using linear types and unsafePerformIO with mutable references to give ST with less-imperative-ish syntax
13:54:01 <Uniaika> damn, I'm really disappointed
13:54:04 <Cale> and no support for handling exceptions
13:54:15 <monochrom> Does someone get to publish a paper to brag about Linear Haskell if it is added to GHC? That would explain it all.
13:54:16 <Cheery> you could use linear types to represent rules in interactions.
13:54:19 * hackage algebra-driven-design 0.1.0.0 - Companion library for the book Algebra-Driven Design by Sandy Maguire  https://hackage.haskell.org/package/algebra-driven-design-0.1.0.0 (isovector)
13:54:21 <davean> Uniaika: the marketing vs. the tech were massively different
13:54:27 <Cale> monochrom: That paper exists, yeah
13:54:48 <Cale> monochrom: But that paper would have existed even if they didn't merge the whole experiment into mainline GHC
13:54:56 <Uniaika> davean: well I was not very receptive to the marketing because I don't do Linear Types in the Real World
13:55:02 <Uniaika> I mean, that's just a bonus for me
13:55:10 <Uniaika> but clearly the bonus can't come half-assed
13:58:06 <Cale> Cheery: What do you mean by "rules in interactions"?
13:59:38 <Cale> Cheery: The trouble is, whenever you have linear variables flowing through something, you're hamstringing yourself a bit because any future control flow you might need to handle an exceptional case becomes basically impossible unless you're okay with discarding all the linear stuff. It's one thing if you lose the ability to handle exceptions because you didn't design that into your combinator library.
14:00:12 <Cale> It's another if it comes from the fundamentals of how the type system works, and you pretty much can't work around it.
14:01:08 <Cheery> Well the basic idea is that you get resources you're obliged to act on, and you get this idea of presenting and giving choices.
14:02:28 <Cale> The other thing is that only (->) gets refined here -- there's no way to use any of it to get lambda notations for other categories, and if we did *that*, then linearity would have been expressible simply by constraining our category with fewer type classes.
14:02:57 <Cale> (also many other substructural things which are more interesting to me than linearity)
14:04:05 <Cale> and so all the most compelling examples of linear types tend to also use unsafePerformIO to at least make (->) a little more interesting
14:04:09 <Cale> but that's super ugly
14:04:33 <Cheery> Instead of getting IO, you can get Console, then that Console may change and progress depending on how you manipulate it, indicating what you can do with it at each step and enforcing those rules..
14:04:52 <Cale> Sure, but we could already do all of that with indexed monads
14:05:01 <Cale> Right?
14:05:17 <Cheery> hmm..
14:06:49 * hackage cut-the-crap 1.3.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-1.3.0 (Jappie)
14:06:51 <Cheery> I'll read up on indexed monads, they may be useful for what I'm doing.
14:07:59 <Cheery> But anyway the point is, you could abstract over some interaction bit like you can abstract over natural numbers now.
14:08:27 <Cale> You mean at the type level?
14:09:29 <Cale> The idea of indexed monads is basically that you can have your actions have types like  m i j a  where m is your monad, i is some type representing the state that the computation needs to be in initially, and j is the resulting state.
14:09:39 <Cale> and then a is obviously the type of the result
14:09:41 <Cheery> yeah. Things like "this thing represents some service that reacts in this way when you interact with it"
14:09:47 <Cale> So you have return :: a -> m i i a
14:10:03 <Cheery> or a type representing environment where a program is in.
14:10:04 <Cale> and (>>=) :: m i j a -> (a -> m j k b) -> m i k b
14:10:35 <Cheery> ok.
14:10:48 <Cheery> so you construct a monoidal category from a monad, sort of.
14:10:56 <Cheery> ?
14:12:00 <Cale> This one is kind of like there's an additional thin category which partitions the actions of what would otherwise be a monad
14:12:34 <Cale> If you had full on dependent types, the more general thing to do would be to put arbitrary arrows in a category as type parameters
14:12:43 <Cale> and you'd have
14:13:36 <Cale> (>>=) :: { f :: i -> j } -> { g :: j -> k } -> m f a -> (a -> m g b) -> m (g . f) b
14:13:53 <Cale> (where you'd want the curly braced things to be implicit if possible)
14:14:12 <Cale> so you compose the arrows together
14:14:28 <Cale> this is also a generalisation of a different kind of indexed monad
14:14:43 <Cale> where you index things by a monoid, and there's multiplication going on
14:14:52 <Cale> (at the type level)
14:24:35 <Boarders> Does anyone here have an example of doing syntax highlighting with brick?
14:24:48 <Boarders> would I just need to store the reg exp state in the editor state?
14:30:30 <sm[m]> Boarders: I guess so, or rehighlight on every redraw
14:31:19 <Boarders> ah like pass the whole text off to the reg exp and then get back the highlighted text and redraw that?
14:32:27 <sm[m]> Yes, as part of your brick draw routine, run your text through the highlighter
14:32:52 <sm[m]> If it‚Äôs slow, then you can get more fancy
14:33:56 <d34df00d> Hi!
14:33:58 <Boarders> I bet you can incrementalise that so I think it is a great solution, thanks!
14:34:13 <d34df00d> Am I terribly confusing something or there was a package using dual numbers to keep track of the precision?
14:34:21 <d34df00d> (precision of computations, that is)
14:34:44 <Boarders> https://hackage.haskell.org/package/uncertain
14:36:30 <d34df00d> Boarders: yay, thanks!
14:37:33 <moet> does anyone here know how to use the pkg `cmdargs` to define two modes with _nearly the same_ arguments but different defaults? .. it seems like you'd need to duplicate all the fields in two separate constructors?
14:38:06 <moet> i've tried something like `data Args = Mode1 Opts | Mode2 Opts` but just get a weird runtime failure
14:38:19 * hackage noli 0.1.1.0 - A static site generator  https://hackage.haskell.org/package/noli-0.1.1.0 (EndiSukaj)
14:38:37 <moet> or, what cmd-line arg parser do you prefer? :)
14:39:38 <moet> followup question: the `cmdargs` module doesn't actually display the default value of arguments .. this seems broken?
14:39:56 <moet> that's not a question, but maybe i'm misunderstanding things..?
14:46:19 * hackage algebra-driven-design 0.1.0.1 - Companion library for the book Algebra-Driven Design by Sandy Maguire  https://hackage.haskell.org/package/algebra-driven-design-0.1.0.1 (isovector)
15:16:58 <justsomeguy> What's the go-to combination of utilities to get ide support?
15:18:31 <dmj`> justsomeguy: vscode, haskell-ide ?
15:19:08 <justsomeguy> A while ago I'd installed every version of haskell I could get my hands on, along with a ton of plugins for vim, and somehow a franken-ide was born that could do this stuff. Now that I've switched to only having ghc install through stack, I got confused over whether I should use haskell-ide-engine, or haskell-language-server, or ghcide
15:20:12 <justsomeguy> I have the haskell-ide plugin installed in vscode, but it can't talk to the LSP. Not sure which of those I should use to provide it.
15:25:54 <d34df00d> hie eats memory in my experience.
15:26:14 <d34df00d> I just decided to switch to Idea (community edition will do) and Intellij-haskell ‚Äî that one is awesome, things _just work_.
15:26:35 <sm[m]> <hollow laugh>
15:26:51 <shapr> Yeah, haskell-language-server takes several GB of RAM on this 200kloc repo
15:27:08 <shapr> but golly I love the instant typechecks that don't require saving the file
15:27:17 <d34df00d> hie took several (5-10) gigs of ram on a 1-2kloc repo for me.
15:27:24 <d34df00d> Although that is after a few days of use, not immediately.
15:27:44 <d34df00d> Also using idea brings that enterprisey feel and makes you think you're living the dream world where enterprise is using haskell for real.
15:27:59 <sm[m]> justsomeguy: ask #haskell-ide-engine for their current favourite branch, that's the nerve center right now
15:28:26 <d34df00d> But maybe I shall give hie or whatever it's called now another shot, I know things are evolving there quite steadily.
15:28:58 <dsal> I just use haskell-mode.  I'm oldschool.
15:29:07 <dsal> My last attempt to use HIE went poorly.
15:30:10 <monochrom> If the space consumption pushes me into swap space, it's as bad as saving the file before type-checking.
15:30:12 <shapr> d34df00d: I think my employer has ~50 haskell devs, is that enterprisey?
15:30:14 <fendor> HLS is the latest thing to use. HIE is pretty much not updated
15:30:33 <shapr> dsal: try out haskell-language-server 0.2
15:31:03 <shapr> dsal: I can help you setup HLS for emacs if you like
15:31:31 <dsal> Hmm...  I'll give it a shot at some point.  I can't even remember want went wrong last time.
15:46:09 <moet> transformers or mtl for new projects?
15:46:33 <moet> i don't need the classy stuff that mtl provides, because i'm just going to wrap in a explicit newtype and provide one operation
15:46:44 <Rembane> moet: Go for transformers
15:46:52 <d34df00d> shapr: that's a lot! Who's your employer and are you hiring?
15:47:01 <moet> Rembane: sgtm
15:47:26 <sm[m]> to be clear, #haskell-ide-engine isn't a dead channel for the old HIE project, it's where ghcide & hls devs chat
15:48:19 <sm[m]> and you kind of need their help to pick the latest, because it's all highly in flux
16:03:00 <ezzieyguywuf> if i have "data MyData" without any exported constructors, how might i go about parsing a string and returning a MyData? is my only choice to create and export ToString and FromString within the same module?
16:04:12 <Cale> ezzieyguywuf: Your only choice is to export some operations which create values of type MyData
16:04:26 <Cale> They don't necessarily have to convert from strings directly
16:05:06 <monochrom> and operations to expose enough information in MyData values
16:05:52 <ezzieyguywuf> seems reasonable. thought i would ask in case i was missing something
16:06:37 <monochrom> Take Int for example. You were never given its real representation (a data constructor and the bits).
16:07:07 <monochrom> But you have 0, 1, and +. That allows you to convert from/to a unary notation.
16:07:39 <ezzieyguywuf> it seems a bit weird though: i don't expose the constructors because i want to say "hey, beware, this should not be constructed lightly"  but now i'm exposing a function thst makes it trivial to construct
16:07:40 <monochrom> You also have 10, *, and divMod. That allows you to convert from/to a decimal notation.
16:08:29 <monochrom> Trivial for user? Or trivial for implementer?
16:09:24 <ezzieyguywuf> hrm
16:09:38 <ezzieyguywuf> I guess trivial in general. "fromString :: String -> Maybe MyData"
16:10:02 <monochrom> That's trivial for user, therefore hair-loss for implementer.
16:10:13 <ezzieyguywuf> monochrom: I don't follow
16:10:30 <monochrom> The user just have to issue one simple short function call.
16:10:31 <ezzieyguywuf> his seems like it should be a common problem, though, so I'm sure there are idiomatic ways of solving it
16:10:41 <monochrom> The implementer writes like 100 lines of code to support it.
16:10:43 <ezzieyguywuf> (perhaps not the proper use of the word "idiomatic"
16:10:56 <ezzieyguywuf> monochrom: I'd rather invert that
16:11:14 <ezzieyguywuf> the user should have to work to get a MyData from a String
16:11:20 <monochrom> Inverting that requires trusting users to not make mistakes.
16:11:32 <ezzieyguywuf> well that's not possible
16:11:33 <ezzieyguywuf> lol
16:12:00 <ezzieyguywuf> well, `newtype MyData = MyData Int`, so the implementation itself is trivial.
16:12:18 <monochrom> Is every Int value legal for MyData?
16:12:57 <ezzieyguywuf> but I'm thinking of something like `fromString :: Int -> Map MyData a -> Maybe MyData` where you only get a value back if the Int is a valid key
16:12:59 <monochrom> If yes then it's safe to expose to users.
16:13:20 <ezzieyguywuf> monochrom: it's not. the Map analogy is a good one here.
16:58:49 * hackage predicate-typed 0.7.2.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.7.2.0 (gbwey)
17:12:47 <NemesisD> i'm having some trouble with ApplicativeDo. it seems like in this example if i need to bind 2 product types at the end of the monad, i can't unless i explicitly put them in applicative format despite them not being sequential or interdependent https://gist.github.com/MichaelXavier/06b32bc2bca25114c9e74192c7482fdb
17:47:35 <shachaf> NemesisD: Hmm, strictness thing forcing it to be in Monad?
17:47:49 <pie_> given that despite all my aspirations otherwise, currently i seem to do more or less all of my programming in python, do you guys have any book recommendations?
17:47:50 <shachaf> Does using ~(i2, i3), ~(b2, b3) fix it?
17:47:56 <pie_> (yes i know this is haskell)
17:50:13 <dsal> pie_: are you asking for python books?
17:50:22 <pie_> yes
17:50:43 <dsal> Have you asked any python programmers?  I've never read a python book.
17:51:08 <pie_> no. but i respect haskellers more :P
17:51:50 <pie_> im not sure its correct but i would expect haskellers to have a better idea about how to programming than pythoners, and on that path to have done python
17:51:57 <pie_> but maybe thats misguided
17:52:31 <dsal> I've written python before, but I don't ever do it on purpose anymore.  Perhaps you should just write more haskell code?
17:53:43 <mmaruseacph2> there is Language.Python 
17:53:47 <pie_> thats hard right now
17:53:57 <dsal> It gets easier with practice.
17:54:20 <pie_> im saying i dont have the spare time to invest the necesary investment before i run out of some deadlines right now :P
17:54:54 <pie_> though i guess really what i need to learn more about isnt necessarily python the language, but how to design stuff so that they dont suck, so uhhh....
17:56:00 <ezzieyguywuf> I was tutoring a friend last night on python - it was so hard! lol. "So, this function takes a value, and he have to...assume that it's of the appropraite type. ü§¶‚Äç‚ôÇÔ∏è"
17:57:34 <pie_> the curse of learning how to simplify :P you notice how complicated everything is and you start going crazy
18:06:55 <dsal> ezzieyguywuf: Also, it returns a value of some type.  Or it doesn't.  Good luck!
18:12:56 <hyiltiz> or sometimes it does and sometimes it doesn't, even depending on the output...
18:13:31 <moet> why do the arguments of transformer run functions not tend to have the action as the last argument.. eg. `runReaderT action env` .. i would expect the action to be last to facilitate doing `runReaderT env $ do ...` ..
18:13:58 <moet> is there some reason they tend not to have the action last?
18:14:21 <moet> when designing a new one, is it best not to put the action last?
18:14:43 <hyiltiz> one of the most subtle bugs I've seen was the polyfit() function in Matlab: it fit polynomials, and returned the fit coefficients. But depending on the number of outputs, it did something completely different (rescaled the *input* based on the output then fit it and produced polynomial coefficients)
18:15:00 <hyiltiz> purely horrible design (and still remains in Matlab)...
18:20:59 <jumper149> moet: That's one thing I also always ask myself. When building my own newtype TransformerStackT I always put the `t m a` as the last argument of the runner.
18:53:19 * hackage apply-refact 0.8.2.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.8.2.0 (zliu41)
19:17:27 --- mode: orwell.freenode.net set +o Sigyn
19:17:27 --- mode: orwell.freenode.net set +o ChanServ
19:19:30 --- mode: orwell.freenode.net set +o Sigyn
19:20:14 --- mode: orwell.freenode.net set +o ChanServ
21:22:20 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
21:22:20 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
21:34:13 <hyiltiz> Can anyone see this msg.? Quassel seem to be having connection issues to the Core 
21:35:31 <MarcelineVQ> ye
21:36:28 <hololeap> a list is a free monoid in haskell. is there anything that would be a free group?
21:51:02 <hololeap> something like this? https://dpaste.com/6ZEAUQLY8
21:54:44 <dsal> What's a free monoid?
21:55:48 <edwardk> hololeap: technically because haskell is lazier than Set, lists aren't quite the free monoid here.
21:56:31 <edwardk> this is relevant because it gives an easy way to construct a free group.
21:57:02 <edwardk> Your free group there isn't free. as it assumes you can commute negative and positive elements.
21:57:57 <edwardk> a^-1bc^-1  = a^-1bc^-1 doesn't hold in general
21:58:06 <edwardk> er
21:58:19 <edwardk> a^-1bc^-1 = a^-1c^-1b doesn't hold i mean
21:58:28 <edwardk> you can't just split up elements like that
21:58:55 <edwardk> :t foldMap
21:58:56 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:59:14 <edwardk> but we can squint at foldMap and actually see a 'better' free monoid in haskell
21:59:17 <edwardk> :t flip foldMap
21:59:18 <lambdabot> (Foldable t, Monoid c) => t a -> (a -> c) -> c
21:59:59 <edwardk> :t newtype FreeMonoid a = FreeMonoid { runFreeMonoid :: forall m. Monoid m => (a -> m) -> m }
22:00:00 <lambdabot> error: parse error on input ‚Äònewtype‚Äô
22:00:05 <edwardk> er no :t
22:02:20 <edwardk> why is this better than list? well, you have the axiom (x <> y) <> z = x <> (y <> z) -- which lets you replace any one left associated <> with a right associated <>, so by induction you can do that at least finitely many times. But unlike Set, you don't get to know that your lists are finite in length. I can construct infinitely long chains of _left_ associated <>s.     crap = crap <> singleton x
22:03:23 <edwardk> and list doesn't let you compute everything you could compute from that. I can come up with a monoid for computing the Last element that is lazy in the right way that when fed 'crap' it works
22:04:11 <edwardk> even though there is no monoid that when fed to foldMap on an infinite list will yield the 'last' element, there is a problem with that framing.
22:04:28 <edwardk> On the otherhand I can make an expression in FreeMonoid above that works just fine
22:04:58 <edwardk> so why do i say this gives an easy way to build free groups?
22:05:21 <edwardk> you can move the constraint on m to be a type parameter of kind Type -> Constraint
22:05:38 <edwardk> newtype Free p a = FreeMonoid { runFreeMonoid :: forall m. p m => (a -> m) -> m }
22:05:50 <edwardk> and work with Free Monoid, Free Group, Free Semigroup, Free Magma, etc.
22:05:57 <edwardk> er
22:06:10 <edwardk> newtype Free p a = Free { runFree :: forall m. p m => (a -> m) -> m }
22:06:17 <edwardk> it is boring, but free constructions generally are
22:06:41 <edwardk> hololeap: does that help?
22:20:54 <hololeap> negate a <> b <> negate c = negate a <> negate c <> b
22:21:03 <hololeap> edwardk: this needs to hold for a group?
22:22:41 <edwardk> hololeap: not unless the group is abelian
22:23:35 <edwardk> what i'm saying is for your data structure there that equation does hold, but for a proper free group is doesn't in general
22:24:25 <hololeap> i see
22:25:54 <hololeap> i'm also not sure how to interpret `(a -> b) -> b` in general. where do you get the `a` from?
22:26:27 <edwardk> let's write 'singleton' for this list
22:26:36 <edwardk> singleton a = FreeMonoid $ \k -> k a
22:26:47 <edwardk> pair a b = FreeMonoid $ \k -> k a <> k b
22:27:35 <edwardk> mappend (FreeMonoid m) (FreeMonoid n) = FreeMonoid $ \k -> m k <> n k
22:27:50 <edwardk> mempty = FreeMonoid $ \_ -> mempty
22:28:10 <edwardk> i recommend working through the types for those
22:28:53 <edwardk> then the fact that foldMap exists shows you can take a list and convert to this representation.
22:30:39 <edwardk> taking a step back if you work with forall r. (a -> r) -> r -- the only way that thing can exist is if you give back a bottom (boo, hiss) or if you call the function from (a -> r) you are given with some a you have lying around, and get an r.      There is no other sources of r.      When we put constraints on the r, then we can do more.    forall r. Monoid r => (a -> r) -> r   --- now we have mempty :: r lying around so we could use 
22:30:39 <edwardk> that, or if we had two rs we could combine them with mappend.            And we can get rs from any 'a's we have.
22:31:26 <edwardk> So our FreeMonoid a, which looks like forall r. Monoid r => (a -> r) -> r -- is any function that takes a function and then calls it on whatever a's it wants, and glues together the results with mappends and memptys
22:31:59 <edwardk> singleton 1234     is one such function,     pair 'x' 'y'  is another such function
22:45:46 <hololeap> edwardk: ok, i see your point
22:49:49 * hackage hal 0.4.3 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.4.3 (nikeoss)
22:52:02 <nshepperd2> does that Free construction with (a -> m) -> m have something directly to do with the forgetful functors thing 
22:56:20 <nshepperd2> Free Monad a = Free (Monad m => (a -> m b) -> m b) -- this is codensity, right
22:57:50 <nshepperd2> hm no it's different because the m is quantified
22:58:22 <nshepperd2> i guess a free monad over nothing is pretty boring
22:58:30 <edwardk> nshepperd2:  yes, it has to do with a forgetful functor.  take a category of sets, and the category of monoids, using the forgetful functor U that maps a monoid to its underlying set.    Now we need to show F a -> m        is isomorphic to a -> U m -- which is to say if you give me _any_ arrow from a to the carrier set of some monoid m, I'll give you a monoid homomorphism from the freemonoid containing 'a's to m.
22:58:47 <edwardk> and vice versa
22:59:09 <nshepperd2> ah
22:59:11 <edwardk> every monoid homomorphism from F a -> m    for any monoid m, is determined uniquely by a function from a to the carrier set of the monoid m.
23:00:48 <nshepperd2> so i guess 'Monoid m => (a -> m) -> (t a -> m)' witnesses that isomorphism?
23:01:19 <edwardk> :t foldMap
23:01:20 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:01:34 <edwardk> yeah it takes the function and gives you the monoid homomorphism
23:02:43 <edwardk> now construct the inverse
23:03:40 <edwardk> given any monoid homomorphism f : FreeMonoid a -> m we can reconstruct the function from a -> m    -- what we do is feed your monoid homomorphism "singleton a"
23:04:42 <edwardk> then you can go through and mechanically check that this yields an equivalent function to the one you fed foldMap.
23:05:20 <edwardk> and you can show that there are no monoid homomorphisms that aren't able to be constructed in this fashion
23:05:37 <edwardk> er monoid homomorphisms from this free monoid that is
23:07:03 <nshepperd2> that's kind of cool
23:10:27 <nshepperd2> hm, so the free monoid is sort of defined as being equal to its own proof that it is the free monoid
23:10:28 <edwardk> and since foldMap here is 'id' with some newtype noise, its pretty easy to show that isn't doing any damage, unlike say, using foldMap (\x -> [x]) and then foldmapping on the result of that, which can induce nontermination in cases where just folding in the target monoid yields a result
23:11:15 <edwardk> more or less. i find this style of 'free' whatever to be pretty easy to write. write down the universal property you want, then see if you can get the thing you are describing on its own in the definition on the left or right of the arrow.
23:11:32 <edwardk> you can do the same thing to build Mu from the definition of catamorphism, or Nu from the definition of an anamorphism
23:13:42 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a    -- flip cata :: Functor f => Mu f -> forall a. (f a -> a) -> a  -- now we have it alone. newtype Mu f = Mu { runMu :: forall a. (f a -> a) -> a } -- which means cata = flip runMu
23:13:54 <edwardk> then check that it actually works
23:14:04 <edwardk> its a supply of candidate definitions
23:14:38 <edwardk> such that if anything exists that has the property, this will have it (it may not be the best operational implementation of the idea, but damnit, it'll pass the laws if anything can)
23:15:02 <edwardk> The kan-extensions library has a few more examples along these lines
23:34:11 <hololeap> edwardk: can you give any good examples for building an intuition for kan extensions? i've read through bartosz milewski's book but didn't really understand his last two chapters on (co)ends and kan extensions
23:44:02 <fog> i think if i dont have converging branches moving down in a tree, then i can represent a graph just *as* a tree
23:44:40 <fog> where then, variable reuse, as reference to let bound values, can emulate cyclic graphs, but with no extra structure than a tree
23:44:45 <fog> does that seem right?
23:49:04 <jle`> is there a way in ghci to find out where a given instance is defined?>
23:50:20 <jle`> i can check for all instances of a typeclass and all typeclasses a type is an instance for, but the list is a little log for me to scan through :|
23:50:23 <jle`> maybe i can pipe to grep
23:50:35 <MarcelineVQ> jle`: :info MyType doesn't mention the instance source?
23:51:07 <MarcelineVQ> ah ok :>
23:56:43 <edwardk> hololeap: die you see my old comonad.com articles on them?
23:56:50 <edwardk> er did
