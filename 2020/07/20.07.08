00:11:01 <sicklork1n> mniip: lol doge memes are everywhere!
01:12:39 <liiae`> how to describe Maybe's effect?
01:12:54 <liiae`> or what's the effect or Maybe?
01:13:54 <liiae`> in Java, null has any type, if we implement Maybe in it, what's the benifit?
01:14:27 <liiae`> concret arbitrary type to one type?
01:14:50 <veverak> huh
01:15:09 <veverak> 'Maybe a' -> data that can just contain 'a' or contains nothing
01:15:42 <veverak> so, data that optionally contains value
01:17:07 <liiae`> > fmap (div 9) [0,1,2]
01:17:08 <lambdabot>  [*Exception: divide by zero
01:17:32 <stefan-_> data Maybe a = Nothing | Just a
01:17:40 <stefan-_> there are two constructors
01:23:42 * hackage hsinspect-lsp 0.0.5 - LSP interface over the hsinspect binary.  https://hackage.haskell.org/package/hsinspect-lsp-0.0.5 (tseenshe)
01:28:03 <liiae`> > fmap (Just (div 9) <*>) [Nothing, Just 1, Just 2]
01:28:05 <lambdabot>  [Nothing,Just 9,Just 4]
01:30:29 <liiae`> I forget how to lift a to m a
01:30:41 <liiae`> <$> Just ? Just <$> ?
01:32:58 <L29Ah> pure
01:56:18 <dminuoso> liiae`: Maybe is an exception effect.
01:56:18 <L29Ah> https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-GHCi.html#t:NoIO dafuq
01:56:36 <dminuoso> That is, with Maybe you can have a series of computation and shortcircuit the rest by throwing a (conceptual) exception.
01:56:55 <dminuoso> `Either e` otoh gives you named exceptions, where you can tell "what went wrong"
02:10:56 <liiae`> dminuoso: like that `fmap (div 9) [0,1,2]`, how to use Maybe to it?
02:14:15 <liiae`> > fmap (Just (div 9) <*>) [Nothing, Just 1, Just 2]
02:14:17 <lambdabot>  [Nothing,Just 9,Just 4]
02:14:27 <liiae`> but this need turn 0 to Nothing, 
02:19:50 <frobnicator> :t div
02:19:51 <lambdabot> Integral a => a -> a -> a
02:20:28 <frobnicator> you need to have a div that supports effects
02:21:04 <frobnicator> mdiv x 0 = Nothing; mdiv x y = Just (div x y)
02:21:15 <frobnicator> mdiv <$> 9 <*> 0
02:22:55 <liiae`> right, this 0 should be specified
02:28:21 <liiae`> @let mdiv x 0 = Nothing; mdiv x y = Just (div x y) in fmap (mdiv 9) [0,1,2]
02:28:21 <lambdabot>  Parse failed: Parse error: in
02:28:38 <liiae`> > let mdiv x 0 = Nothing; mdiv x y = Just (div x y) in fmap (mdiv 9) [0,1,2]
02:28:40 <lambdabot>  [Nothing,Just 9,Just 4]
02:33:37 <liiae`> > Nothing <*> Just 3
02:33:39 <lambdabot>  Nothing
02:33:53 <liiae`> > Left (+1) <*> Right 3
02:33:54 <lambdabot>  Left <Integer -> Integer>
02:34:22 <liiae`> why this can't?
02:35:20 <liiae`> f (a -> b), when f ~ Either a, so f must be Right _?
02:35:44 <liiae`> in Applicative
02:39:00 <dminuoso> liiae`: Because the point of Left is to be an exception.
02:39:08 <dminuoso> Conceptually if you think about it:
02:39:26 <dminuoso> `<someException> <*> Right 3` would never apply the 3 to the left thing, because you're short-circuiting 
02:39:54 <dminuoso> The fact that you placed a function in it is misleading. While it can be useful, think of it rather as:
02:40:04 <dminuoso> > Left "Something bad happened" <*> Right 3
02:40:06 <lambdabot>  Left "Something bad happened"
02:41:04 <liiae`> but Nothing can 
02:41:28 <liiae`> Nothing shoudn't be an exception too?
02:41:45 <dminuoso> It is.
02:41:53 <liiae`> > Just (+1) <*> Just 3
02:41:55 <lambdabot>  Just 4
02:42:00 <dminuoso> The only difference between Nothing and Left is that Nothing cant tell you any details about the exception.
02:42:04 <dminuoso> Left can.
02:42:05 <liiae`> > Nothing <*> Just 3
02:42:07 <lambdabot>  Nothing
02:42:08 <dminuoso> Indeed!
02:42:34 <dminuoso> Nothing is equivlaent to Left ()
02:42:42 <dminuoso> Or equivanelty:
02:42:50 <dminuoso> `Either ()` is equivalent to Maybe
02:43:05 <dminuoso> `Either () Int` is pretty much equivalent to `Maybe Int`
02:43:20 <liiae`> and Nothing?
02:43:22 <liiae`> Left ()?
02:43:26 <dminuoso> Right.
02:43:35 <dminuoso> The reason is: You cant encode any more information into `Left ()` than you can into `Nothing`
02:43:38 <random> guys, anyone using servant-client?
02:43:40 <dminuoso> Yes.
02:43:47 <liiae`> but you see, Either () and Maybe both are type
02:43:54 <random> so we have the following "issue"
02:44:00 <liiae`> Right and Just both are value constructors
02:44:04 <random> I'm not sure it can be solved but I'll ask anyhow
02:44:13 <random> we have a bunch of services built using Servant
02:44:19 <random> and some client apps for those
02:44:44 <random> the problem is that in order to access the API definition inside a service
02:44:50 <random> we need to depend on the whole service
02:44:56 <random> which makes the build times absurdly slow
02:45:15 <random> could there be a way of just depending on a single module?
02:45:22 <dminuoso> random: yes. 
02:45:28 <dminuoso> Move the API into a separate *package*
02:45:39 <dminuoso> So you have foo-server, foo-client and foo-api
02:45:43 <random> dminuoso: oh my fucking god we are retards!
02:45:51 <random> dminuoso: I have no idea how that slipped my mind
02:45:54 <random> lol....
02:46:00 <random> thank you man!
02:46:11 <dminuoso> You're welcome.
02:55:59 <liiae`> I'm tring to put Just f to a sequence operations, (+)  <$> ((+) <$> Just 3 <*> Just 3) <*> Just 3
02:56:09 <liiae`> but this is ugly
02:56:54 <liiae`> pass Just f to Just g, then get Just (g . f)
03:03:05 <Rembane> > (sum . catMaybes) [Just 3, Just 3, Just 3]
03:03:07 <lambdabot>  9
03:03:18 <Rembane> liiae`: Lists can help you there 
03:03:45 <liiae`> Just (+1) -> f -> g -> h -> Just result
03:03:49 <liiae`> Nothing -> f -> g -> h -> Nothing
03:03:58 <liiae`> I don't know how to express this with code...
03:06:59 <liiae`> another interesting thing is Just (+1) <*> Just 3    here it's Just 4, you can't <*> and <$>, because it's in the right parameter position
03:07:36 <liiae`> Just 4 <*>     or     Just 4 <$>     are wrong
03:07:43 <liiae`> but Just 4 >>=    is ok
03:08:00 <Rembane> > (,,) <$> Just 3 <*> Just 4 <*> Just 5
03:08:02 <lambdabot>  Just (3,4,5)
03:08:12 <liiae`> :t <$>
03:08:13 <lambdabot> error: parse error on input ‘<$>’
03:08:18 <liiae`> :t (<$>)
03:08:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:08:25 <liiae`> :t (<*>)
03:08:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:08:30 <liiae`> :t (>>=)
03:08:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:08:56 <Rembane> liiae`: Put () around them
03:08:59 <Rembane> :t (<$>)
03:09:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:09:01 <liiae`> Functor and Applicative, the first parameter are (a -> b) or f (a -> b)
03:09:13 <liiae`> but Monad's first parameter is m a
03:10:00 <liiae`> that's why we use >>= to concat a sequence calls stuff?
03:10:05 <Rembane> YEs
03:10:11 <Rembane> OTOH, look at this: 
03:10:14 <Rembane> :t (>=>)
03:10:15 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:12:06 <liiae`> use <$> or <*> to chain will be ugly, (+)  <$> ((+) <$> Just 3 <*> Just 3) <*> Just 3
03:12:28 <liiae`> it's like h(g(f(a)))
04:21:42 * hackage bech32 1.1.0 - Implementation of the Bech32 cryptocurrency address format (BIP 0173).  https://hackage.haskell.org/package/bech32-1.1.0 (JonathanKnowles)
04:54:15 <Entroacceptor> Another  one.
05:01:03 <ezzieyguywuf> so I have `myFunc :: MyData -> MoreData -> IO MyData`, and a `[MoreData]`. I would like to sequentially call `myFunc` with each `MoreData`, each time taking the result and using it in the next call. This _seems_ like a job for one of the `fold` functions, but I'm getting tripped up because of the `IO MyData`. Do I need to change my function to `myFunc2 :: IO MyData -> MoreData -> IO MyData`?
05:11:57 <dminuoso> % :t foldM
05:11:58 <yahb> dminuoso: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
05:12:20 <dminuoso> ezzieyguywuf: ^-
05:12:57 <dminuoso> There's no foldM1, so you have to deal with the initial MyData yourself. :)
05:13:08 <dminuoso> Err, MoreData.
05:13:12 <dminuoso> Quite confusing names here
05:13:21 <dminuoso> Or no, MyData.
05:14:23 <ezzieyguywuf> dminuoso: I think that's it thank you!
05:15:28 <dminuoso> ezzieyguywuf: Note that you might also be interested in traverse over `StateT MyData IO`
05:16:19 <dminuoso> (I dont know the details of what you're doing, but it might be more expressive)
05:18:16 <ezzieyguywuf> dminuoso: I'll definitely consider that.
05:18:33 <ezzieyguywuf> I was starting to ask myself if I have some State that I'm passing around
05:18:43 <ezzieyguywuf> (the answer is yes)
05:26:44 <dminuoso> ezzieyguywuf: In addition, you can also use IORefs to maintain state. :)
05:27:22 <dminuoso> I found IORefs were kept from me for far too long when learning Haskell, nowadays I use them a bunch when I have need for mutable state in some of my projects
05:27:28 <ezzieyguywuf> `MyData` is already holding some TQueue
05:27:49 <ezzieyguywuf> *shrug* don't sweat it, I think I can probably figure it out
05:27:52 <dminuoso> ezzieyguywuf: Are you just modifying those TQueues?
05:29:53 <ezzieyguywuf> nope, it's something like `data Renderer = Renderer [ThingsToRender] (TQueue ThingsToRender)`, so that I only render the screen whenever there is something in the TQueue to render. the function in question is `processQueue :: Renderer -> ThingsToRender -> IO Renderer`, which moves the `ThingsToRender` from the TQueue to the list in Renderer
05:39:47 <dminuoso> That sounds a bit weird
06:08:05 <dminuoso> Mmm, is there a way to have some global `foo.hs` in some directory depending on `bar` that I can just run with cabal v2-*? Or do I have to setup a cabal package for it with build-depends: bar ?
06:08:45 <hseg> just realized my type constructor is functorial in its _first_ argument. *sigh*
06:12:54 <L29Ah> dminuoso: or just use ghc --make?
06:14:10 <L29Ah> btw cabal got a regression from 2 to 3
06:14:38 <L29Ah> it used to account for changes to and rebuild modules that weren't present in other-modules in the cabal file, now it doesn't
06:14:56 <dminuoso> L29Ah: Mmm, but then I'd have to manage package databases
06:14:58 <L29Ah> probably stack/hpack zealots got in and messed things up to get more followers
06:15:06 <dminuoso> Ideally I want to `cabal v2-install` something and just use it for scripts.
06:24:03 <merijn> L29Ah: I don't see how "buggy behaviour changed" is a regression, tbh
06:24:40 <merijn> dminuoso: You can use .ghc.environment files for that, but it's a bit underdocumented
06:36:40 <fog> i have a question about traverse being "lazy"
06:36:45 <fog> in a monadic list
06:36:51 <fog> i have; https://github.com/fog-hs/clock-scanner/blob/master/LinearM.hs
06:37:17 <fog> with the default given here; https://github.com/fog-hs/clock-scanner/blob/master/StackM.hs#L69
06:37:42 <fog> but i cant get it to work for an infinite stream
06:38:01 <fog> the only way i can get mapAccum to work is to reimplement it as a "scanner"
06:38:30 <fog> because trying to use the StateL/StateR applicative does not work
06:39:20 <fog> something about reconstructing the list within the applicative (fmaping the partially applied set, to the most recent head element) 
06:39:30 <fog> is making it try to evaluate the tail
06:40:01 <fog> i cant understand if "some applicative are lazy" or how it might work to still be able to lazily access the head
06:40:07 <fog> from within the applicative
06:40:24 <fog> but something seems to make me think that in order for the applicatives to combine together
06:40:48 <fog> so that they can commute with the monadic list list, like in the type of sequence;
06:40:50 <fog> :t sequence
06:40:51 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
06:41:00 <dminuoso> merijn: All .ghc.environment files is with that regard is a sort of package database specification.
06:41:26 <dminuoso> Not in the mood of figuring out the package ids manually. All I want is write a small script that depends on some dependency and have it working, without having to set up an entire directory with a cabal file.
06:41:33 <fog> that all of the applicatives are combined together, like, forcing the evaluation of the tail recursion
06:41:39 <dminuoso> Perhaps I should use v1- then, but that will disappear at some point
06:41:41 <fog> does anyone know if thats right?
06:41:48 <fog> can traverse be lazy?
06:42:02 <merijn> dminuoso: Right, but there's a way to "cabal install" into a specific environment file to get one without doing it manually or making a proper package
06:43:22 <fog> i cant tell if the workaround using scanner is actually theoretically sound, or to do with me having implemented traverse wrong so it isnt lazy
06:44:24 <fog> basically making something like scan a valid superclass of traverse, that, by avoiding the use of applicative to implement mapAccum, allows it to be lazy
06:44:47 <dminuoso> Do you mean like `cabal v2-intsall --lib foo --package-env .` ?
06:45:06 <dminuoso> Oh well, or a named package env even. That might be preferrable
06:45:18 <dminuoso> Mmm, that could be usable enough
06:46:06 <dminuoso> The interface is sadly a bit broken though, since adding packages later on most likely ends up in `cabal: Could not resolve dependencies:
06:46:34 <merijn> dminuoso: Make sure to write down how it actually works if you figure it out, so I can link that ;)
06:46:43 * hackage universum 1.7.0 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.7.0 (gromak)
06:46:53 <dminuoso> Presumably if you first do `cabal v2-install --lib foo --package-env .` followed by `cabal v2-intsall --lib bar --package-env .`
06:47:33 <fog> if you compare the implementations on lines 75 and 58 of; https://github.com/fog-hs/clock-scanner/blob/master/StackM.hs
06:47:44 <dminuoso> And you still have to use it somehow. Mmm.
06:48:52 <dminuoso> merijn: Actually yes! plain `cabal v2-install --lib foo` does the right thing!
06:48:55 <frobnicator> where can I find the implementation of the generic machinery behind show
06:49:04 <dminuoso> It adds it to the package environment at `~/.ghc/$ARCH-$OS-$GHCVER/environments/default`
06:49:09 <dminuoso> and that gets picked up by `runghc`
06:49:12 <dminuoso> That's perfect!
06:49:13 <frobnicator> many GShow's show up when searching for gshow
06:49:30 <dminuoso> So I get sort of v1- behavior with it
06:49:45 <fog> here is an example of "scannerM" being used on an IOList; https://github.com/fog-hs/clock-scanner/blob/master/ListT.hs#L66
06:50:10 <fog> so that despite it being an infinite stream, it can still be folded over after scanning over it
06:50:28 <fog> whereas if it were traversed over, it would try and evaluate the whole infinite list
06:50:34 <fog> (i think)
06:51:24 <fog> again, the question is, can traverse be lazy? because if not, then this scanner thing could be pretty cool for streaming with
06:53:07 <fog> % take 10 $ traverse (return @[]) [1..]
06:53:09 <yahb> fog: *** Exception: heap overflow
06:53:35 <fog> % take 10 $ traverse (return @Identity) [1..]
06:53:36 <yahb> fog: ; <interactive>:69:11: error:; * Couldn't match type `Identity' with `[]'; Expected type: [[b]]; Actual type: Identity [b]; * In the second argument of `($)', namely `traverse (return @Identity) [1 .. ]'; In the expression: take 10 $ traverse (return @Identity) [1 .. ]; In an equation for `it': it = take 10 $ traverse (return @Identity) [1 .. ]
06:53:39 <fog> argh!
06:54:29 <fog> % take 10 <$> traverse (return @Identity) [1..]
06:54:29 <yahb> fog: Identity [1,2,3,4,5,6,7,8,9,10]
06:54:37 <fog> damn
06:55:00 <fog> i must have just implemented traverse wrong :(
06:55:18 <fog> it seems "some applicative are lazy"
06:55:41 <fog> i wonder if the StateL/StateR used for mapAccuL/R are
06:57:02 <fog> % let scanner =  ((snd .) .) . mapAccumL
06:57:02 <yahb> fog: 
06:57:07 <fog> % :t scanner
06:57:08 <yahb> fog: Traversable t => (a -> b -> (a, c)) -> a -> t b -> t c
06:58:44 <fog> % take 10 $ scanner (\ a b -> (a*b,a+b)) 0  [1..]
06:58:44 <yahb> fog: [1,2,3,4,5,6,7,8,9,10]
06:59:53 <fog> % take 3 $ scanner (\ a b -> (a*b,a+b)) 1  [1..]
06:59:53 <yahb> fog: [2,3,5]
07:00:53 <fog> % take 3 $ (((snd .) .) . mapAccumR)  (\ a b -> (a*b,a+b)) 1  [1..]
07:00:59 <yahb> fog: [[Timed out]
07:01:14 <fog> so StateL seems lazy, but not StateR
07:01:20 <oats> ]
07:08:01 <fog> hmmm
07:08:05 <fog> checking here;
07:08:06 <fog> http://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Traversable.html#line-230
07:08:17 <fog> there is an INLINE pragma
07:08:40 <fog> so im not sure if its actually just achieving this lazyness via fusion
07:11:04 <fog> % let traverse' f = foldr cons_f (pure []) where cons_f x ys = liftA2 (:) (f x) ys
07:11:05 <yahb> fog: 
07:11:20 <fog> % take 10 <$> traverse' (return @Identity) [1..]
07:11:20 <yahb> fog: Identity [1,2,3,4,5,6,7,8,9,10]
07:11:44 <fog> seems not to be due to the inline pragma, unless yahb inserts it
07:12:03 <fog> seems strange that it can do this when folding from the right over an infinite list
07:14:55 <fog> still not sure if this means it should work for the monadic versions as in the repo above
07:15:26 <fog> the issue with the implementation is commuting the applicative through that monad
07:23:03 <dminuoso> ski: I recall you gave me an ancient paper (80s perhaps) that talked about abstractions and trade offs vs performance gains, displaying the history how we've been moving away from all-powerful primitive operations to limited abstractions in languages.
07:23:07 <dminuoso> Do you know what paper that was?
07:29:02 <ski> oh
07:29:18 <dminuoso> Ah I found it again
07:29:20 <dminuoso> It was Denning
07:29:41 <ski> yes, i was just about to say
07:29:59 <dminuoso> It's definitely a great paper. :)
07:30:01 <ski> "Sacrificing the calf of flexibility on the altar of reliability" by Peter J. Denning in 1976 at <http://dl.acm.org/ft_gateway.cfm?id=807704&type=pdf>
07:37:02 <dminuoso> Merci
07:48:42 * hackage o-clock 1.2.0 - Type-safe time library.  https://hackage.haskell.org/package/o-clock-1.2.0 (gromak)
08:07:40 <reactormonk> I'm trying to call some C macros from Haskell. Apparently the default FFI doesn't do includes anymore? https://wiki.haskell.org/Foreign_Function_Interface So I tried inline-c, which just fails with unexpected identifier  RUNNING_ON_VALGRIND on • In the quasi-quotation: [C.exp| RUNNING_ON_VALGRIND |]
08:08:23 <dminuoso> Where is that quasiquoter from?
08:08:53 <reactormonk> inline-c
08:43:16 <solonarv> reactormonk: I suppose you could write a C file with contents like #include <someheader>\n const int RUNNING_ON_VALGRIND_ = RUNNING_ON_VALGRIND; and then import that
08:43:43 <solonarv> oh! you don't even need to do that
08:44:32 <solonarv> just this will work: foreign import capi "header.h RUNNING_ON_VALGRIND" runningOnValgrind :: CInt
08:44:38 <solonarv> reactormonk: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#the-capi-calling-convention
08:50:25 <reactormonk> solonarv, how do I tell that to use <valgrind.h> instead of "valgrind.h"?
08:54:16 <ja> reactormonk: you have use  "includes:"  in your cabal file to include a specific .h. i do that, and it works
08:55:29 <ja> *you can
08:55:48 <reactormonk> Neato, thanks!
08:56:32 <ja> other relevant cabal things to use: include-dirs, extra-libraries, extra-lib-dirs, ld-options
08:57:24 <ja> i am probably not doing it the ideal way because i need LD_LIBRARY_PATH on runtime... to tell the runtime linker about the extra-lib-dirs 
08:57:39 <ja> but you only talk about includes, so maybe you don't have any custom library to link with...
08:58:17 <reactormonk> I'll cross that brige when I get there, first stitching the nix expression to properly include the .h files in the final package
09:00:34 <frdg> I am using yesod/shakespearean template code. I am confused about why the `searchBarCss` is not picking up on the `topnav` class. https://pastebin.com/t3DHxb33
09:01:22 <ja> monochrom: do you if there is an elegant way to get the full paths of the libraries specified using extra-libraries and extra-lib-dirs baked into the binary?
09:01:58 <ja> *do you know
09:06:12 <frdg> to be clear the getHomeR function is working as intended.
09:15:37 <merijn> ja: That's...not a very portable thing to do :)
09:15:50 <merijn> ja: Why do you need to do that?
09:15:57 <monochrom> ja: Something about "rpath". I have some information here: http://www.vex.net/~trebla/haskell/so.xhtml#search
09:16:22 <monochrom> But I don't know how to tell cabal to add it for you.
09:17:12 <ja> merijn: so that i can't forget to add LD_LIBRARY_PATH when i run it with e.g. gdb . it is just super weird to have an executable that doesn't run with the right environment variables. i am not a big fan of environment variables
09:17:32 <monochrom> Well, I know how to tell cabal to tell ghc "-optl-Wl,-rpath=foo", we all know that. I don't know how to say "replace foo by the appropriate value determined automatically by reading the extra-libs field"
09:17:32 <ja> thanks monochrome
09:17:34 <ja> -e
09:18:03 <ja> yeah , i guess i have to resort to that rpath magic
09:18:26 <ja> need to remind myself of my teenage years when obscure command line parameters were the height of excitement
09:21:06 <ja> pretty soon somebody is gonna suggest i use docker so that i can install it in /usr/lib without root :O oooh the calamity!
09:25:43 <ja> i like that you're using the xhtml extension. almost forgot about that
09:31:12 * hackage interpolator 1.1.0 - Runtime interpolation of environment variables in records using profunctors  https://hackage.haskell.org/package/interpolator-1.1.0 (MossPrescott)
09:45:43 * hackage binaryen 0.0.2.0 - Haskell bindings to binaryen  https://hackage.haskell.org/package/binaryen-0.0.2.0 (terrorjack)
10:10:50 <frdg> I am using yesod and I am unable to understand why my `searchBarCss` funtion is not picking up on the `getHomeR` code. I have tried many syntactical variations but have not been able to get anything to work. https://pastebin.com/A1uxTF23
10:23:30 <fog> i still cant get this lazy traversal to work for monadic lists
10:23:46 <fog> no matter what i try i end up having to try and commute the monad through the applicative
10:27:30 <fog> is that ever something that works?
10:28:21 <fog> if so, then it would make sense to just have a superclass constraint 
10:28:39 <fog> for the user to define how to commute the monads
10:29:04 <fog> but i dont know if thats a good idea
10:29:24 <fog> or of it makes more sense that you just cant have lazy traversal for monadic lists
10:32:24 <fog> i seem to remember something about reader and writer monads in a monad transformer stack being commutable
10:32:30 <byorgey> fog: yes, monads that commute/distribute is a standard thing that holds for some monads.
10:33:16 <byorgey> when there is a distributive law for monads m and n, then you can make their composite m.n into a monad too.
10:33:18 <fog> so if i had that as a class then i could make the implementation of traverseM depend on this
10:33:38 <byorgey> sure. It might even exist as a class somewhere already though I'm not sure where.
10:33:58 <fog> the problem is that doesnt really make sense to me
10:34:09 <fog> i cant understand how thats a requisite of monadic traversal
10:34:26 <byorgey> what's the type of the traversal you're trying to write?
10:34:37 <fog> i cant understand why it needs the applicative and the monad of the MList to commute, and what this implies
10:35:35 <fog> byorgey. here; https://github.com/fog-hs/clock-scanner/blob/master/StackM.hs#L68
10:36:34 <fog> (StackM t, Monad m, Applicative f) => (a -> f b) -> t m a -> m (f (t m b))
10:36:53 <fog> oh, thats got the stack constraint because its a default in terms of getM and setM
10:37:02 <fog> the actual class function is here;
10:37:03 <fog> https://github.com/fog-hs/clock-scanner/blob/master/LinearM.hs#L32
10:37:18 <fog> traverseM :: (Monad m, Applicative f) => (a -> f b) -> t m a -> m (f (t m b))
10:38:32 <fog> setM :: (SetM f, Monad m) => m (Maybe (a, f m a)) -> f m a
10:38:55 <fog> (that should be a 1t' instead of an `f' really)
10:39:51 <fog> the problem is that needs the monad next to the t m b, but it always ends up with the applicative there instead
10:40:47 <fog> the whole way its supposed to be lazy is by having this setM opperation acting on a pair, where the snd is where the tail recursion is called
10:41:12 <fog> so that getM then does not need to evaluate this to get the head
10:41:23 <fog> just giving the fst.
10:42:07 <fog> but i cant get that to work with the applicative f, it gets in the way, and it seems to end up always forcing the tail to be recursed over
10:43:15 <fog> the only way round that would be to demand that the f and m commute, but then, i cant see what that implies for most monads and applicatives
10:43:35 <fog> and i cant see if that would enable the lazyness either
10:44:05 <fog> at the moment im just using scanner, which by avoiding using applicative for the StateL of mapAccumL defined in terms of traverse
10:44:14 <fog> allows lazy scanning
10:44:21 <fog> for monadic streams
10:44:34 <fog> in a pure setting, i can get the same behaviour from traverse itself
10:44:44 <fog> but i cant seem to get that to work for MList
10:44:51 <fog> or ListT done right
10:46:57 <fog> basically, if it does make sense, this thing about the monad and the applicative having to commute, then we can have lazy monadic traversal - and then ScannerM does not warrent being a class
10:47:26 <fog> but if it *doesnt* make sense to demand the applicative and monad to commute, and there is no other way to implement traverseM lazily
10:47:42 <fog> then scannerM becomes motivated
10:48:45 <fog> basically putting mapAccumL into its own class, since for monadic lists, this seems to require strictly less of the monad, not needing it to be commutable through StateL
10:50:02 <fog> calling it "scanner" because its kind of like scan, as a fold that is recorded as it encounters each new element, except that it returns the final carried state as well, like mapAccumL
10:51:19 <fog> so, the fact that traverse is lazy for regular lists, but not for monadic lists
10:51:29 <fog> means this "scanner" pattern could have been overlooked
10:51:55 <fog> where for monadic streaming people are usually working with pipes etc
10:52:55 <fog> so unless im wrong, and that traverseM has some way to work without this commutation issue (which im not even sure could work for StateL and IO) 
10:53:20 <fog> then ScannerM should be a valid class, just less demanding that TraverseM
10:53:42 <fog> and provides an idiomatic alternative to other approaches to steaming 
10:54:53 <fog> see lines 34 and 43; https://github.com/fog-hs/clock-scanner/blob/master/Clock.hs
10:56:08 <fog> eg; scannerIO :: (s -> IO (b, s)) -> s -> IOList a -> IO (IOList b, s)
10:56:35 <fog> erm, wait, thats missing an argument... 
10:57:25 <fog> oh right, the idea for clocks was just to stream (), and then run scanners over them, so then it just seems like a monadic state
10:58:51 <fog> well, nobody has interjected with any comment, so i guess either this is incomprehensible, or its totally right, or if its wrong, its impossible to tell
10:59:31 <fog> but im not doing anything else so ill stick around for a while and see if anybody can make anything of this madness 
11:02:14 <fog> what i really want to know is if ScannerM is well motivated, or if there is a way to get TraverseM to work lazily 
11:05:42 * hackage shakebook 0.9.1.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.9.1.0 (locallycompact)
11:12:13 * hackage lucid-cdn 0.1.0.0 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.1.0.0 (locallycompact)
11:14:53 <fog> perhaps the reason traverse works lazily is because Identity commutes with all Applicatives
11:15:34 <fog> however IO does not seem to commute as easily. 
11:16:26 <fog> so for TraverseableM for IO, eg for IOList (ListT IO) 
11:16:55 <fog> it would make sense to use scanners instead of traverse for doing mapAccumL lazily
11:17:06 <fog> scanner*
11:17:12 * hackage lucid-cdn 0.1.0.1 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.1.0.1 (locallycompact)
11:17:20 <fog> scannerM*
11:18:48 <javran> does anyone familiar with reactive-banana? I'm wondering if it's possible to construct an Event when a Behavior got changed in some way, or in general, given `diff :: a -> a -> Maybe b`, `bFoo :: Behavior a`, I want to build a `eDiff :: Event b`
11:28:41 <emmanuel`> Hello there
11:29:14 <emmanuel`> How do you guys deal with coworkers that make unfair criticisms of Haskell? (In my case, the guy is simply misinforemed and is actually a project manager of all things)
11:30:11 <ezzieyguywuf> javran: I"m not, but I'm not reading about reactive-banana, thanks for the tip :)
11:30:30 <maerwald> emmanuel`: what specifically
11:30:31 <polux2001> Hello, lens question: I have a fold that I want to "group by f" into a map. The best I've found so far is to do     toMapOf (folded . [...] . reindexed f selfIndex) e
11:30:46 <polux2001> is there a simpler or more readable way to do that?
11:31:19 <polux2001> I could also do     (e ^.. folded . [...]) & map (f &&& id) & Map.fromList
11:31:49 <polux2001> but I was wondering if maybe there was something like indexedBy instead of using   reindexed f selfIndex
11:33:31 <hc> emmanuel`: sounds like that manager is unqualified
11:37:32 <ezzieyguywuf> sickburn
11:37:42 * hackage os-release 1.0.0 - /etc/os-release helpers  https://hackage.haskell.org/package/os-release-1.0.0 (maerwald)
11:37:48 <fog> emmanuel` you can be very patient and explain why haskell is awesome, and if they persist despite reason, then you can be sure they are just winding you up and not bother wasting your time with them
11:38:35 <giovani> Hello guys, I've just started to learn Haskell and I'm having trouble making a function similtar to length, this is what I've tried but it's generating an error: https://pastebin.com/raw/VMWT3K0F
11:39:02 <ja> giovani: do you understand the error message?
11:39:09 <maerwald> :t null
11:39:10 <lambdabot> Foldable t => t a -> Bool
11:39:11 <fog> null should be allied to the list, not its head
11:39:16 <fog> % null []
11:39:17 <yahb> fog: True
11:39:18 <maerwald> > null 1
11:39:19 <lambdabot>  error:
11:39:19 <lambdabot>      • No instance for (Num [a0]) arising from the literal ‘1’
11:39:19 <lambdabot>      • In the first argument of ‘null’, namely ‘1’
11:39:28 <giovani> Ohh
11:39:46 <fog> % head []
11:39:46 <yahb> fog: *** Exception: Prelude.head: empty list
11:40:02 <giovani> Thanks, gonna fiddle with it a little more
11:40:19 <ja> giovani: i recommend using pattern matching instead of if..then..else
11:40:22 <giovani> I though the error was in the definition of my function
11:40:31 <fog> it is
11:40:33 <giovani> Yeah, I'll refactor it after I get the hand of it
11:40:50 <javran> I'm usually too lazy to defend Haskell XD - I don't preach anything and only talk more to those that shows interest in FP.
11:41:18 <ja> javran: you're wasting your life. life is much better with religion and zealotry
11:41:19 <fog> well, its worth making the case to proponents of other languages too
11:41:40 <emmanuel`> fog: He constantly badgers me about haskell memory's consumption
11:41:48 <fog> haha
11:41:55 <emmanuel`> specifically during compilation and sometimes during runtime
11:42:10 <giovani> I can't find a way to create a counter inside my function, without having to pass it as an parameter... Any tips?
11:42:22 <maerwald> preachers are likely eithe emotionally invested sometimes (bias) or just inexperienced
11:42:31 <maerwald> both opinions are not useful
11:42:50 <giovani> I'm trying to learn Haskell by following the Real World Haskell book, but I still has tons of doubts about how things should world.
11:43:02 <ja> usefulness is a mirage. value is subjective
11:43:03 <giovani> work*
11:43:13 <maerwald> emmanuel`: and he's right maybe
11:43:14 <fog> just randomly approaching you, on the edge of despair, desperately engaging in panicked pestering... "but... but.. its memory consumption!!!"
11:43:18 <ezzieyguywuf> giovani: I tihnk that would typically be done using the State monad
11:43:24 <emmanuel`> Actually, I had a ghc process running today that took 1.0T in virtual memory. He thought was absolutely the worse.
11:43:29 <ezzieyguywuf> which is the same as passing the counter as a parameter
11:43:30 <emmanuel`> (And maybe it is)
11:43:33 <maerwald> emmanuel`: so tell him how to fix memory issues
11:43:46 <giovani> Haven't seen monads yet.
11:43:59 <fog> giovani: you need a "where" section
11:44:14 <giovani> I though about it, but wont the value of the where be fixed?
11:44:23 <fog> then you can have the top of the function not take the length argument
11:44:29 <ezzieyguywuf> giovani: value of the where?
11:44:36 <javran> I won't say he is wrong though, as I do have a habit myself to kill ghcide when my OS memory uilization seems high
11:44:38 <ezzieyguywuf> oh nvm
11:45:22 <fog> anyway, you shouldnt need to increment a counter passed as an argument
11:45:31 <maerwald> ppl complain about debug driven development in other languages... but when it's about performance... haskell is also purely debug driven
11:45:32 <emmanuel`> Yeah, unfortunately this is the same guy who wants to rewrite an inherited Haskell codebase (that a software consultant wrote).
11:45:36 <fog> you just increment the tail recursion
11:45:49 <fog> length = 1+ length of the tail
11:46:24 <maerwald> emmanuel`: and sometimes that can be a right decision, business wise
11:46:36 <maerwald> Things are not black and white
11:47:09 <emmanuel`> I am not totally agaist a rewrite. But the reasons I've been given so far indicate a seveer lack of understanding and poor business sense.
11:47:10 <fog> %let length' xs = case null xs of; True -> 0; False -> 1+ (length' $ tail xs)
11:47:14 <emmanuel`> severe*\
11:47:14 <fog> % let length' xs = case null xs of; True -> 0; False -> 1+ (length' $ tail xs)
11:47:15 <yahb> fog: 
11:47:27 <fog> % length' [1,2,3]
11:47:28 <yahb> fog: 3
11:48:27 <giovani> Hmm... I think I understand now.
11:48:29 <giovani> Let me try
11:48:54 <fog> emmanuel` well, if there are no devs to maintain the haskell code, then wouldnt having code in the language the devs use be a good move business wise?
11:49:41 <emmanuel`> That would make sense, but we have three haskell devs (including me)
11:49:42 <fog> giovani: try the pattern matching version
11:49:54 <ja> emmanuel`: the 1.0T says nothing about the actual memory allocation. on linux, malloc will almost never fail, so if the GHC runtime allocates 1 terabyte as it apparently tends to do; what does that tell you? nothing
11:50:04 <giovani> I did with the if, it worked, now I'll try the pattern matching
11:50:09 <fog> haha, he sounds like a total maniac bent on destroying your lives
11:50:10 <ja> it's called overcommitting, i believe
11:50:53 <maerwald> being a manager is not easy, don't be too harsh
11:51:23 <maerwald> more stressing than programming for sure
11:51:45 <emmanuel`> They don't seem to want to leverage that. Also, they hired me specifically because they needed a Haskell dev to help them take ownership of the product the software consultant created.
11:52:15 <fog> ah, to get you to write yourself out of a job
11:52:16 <fog> nice
11:52:19 <giovani> I think i got it: https://pastebin.com/raw/FhTSRXUQ
11:52:38 <fog> no, now you dont need the null
11:52:46 <fog> you know its not null by the pattern match
11:52:56 <javran> try to pattern match on `xs`
11:53:06 <giovani> _:xs?
11:53:15 <fog> oh, yeah
11:53:20 <javran> yes, `case xs of ...`
11:53:49 <fog> well, the pattern is matched at the function definition on its arguments, so you dont need the case expression at all
11:54:49 <emmanuel`> maerwald: Have you been a manager?
11:54:55 <maerwald> emmanuel`: yes
11:55:00 <fog> emmanuel` maybe they would prefer to write it into a language like fortran that nobody would be able to translate it from, as a form of security
11:55:36 <maerwald> half a year... I think I never burnt out that quickly
11:55:56 <maerwald> Worrying about your own code is one thing
11:56:09 <maerwald> About the entire team or product... ugh
11:56:38 <maerwald> stress makes ppl become less pleasant and less agreeable
11:57:13 <maerwald> need to figure out a way how to commuinicate with him efficiently
11:57:24 <fog> cant you just use that workflow code that ocharles presented at munihack?
11:57:39 <ja> javran: having two branch splits is too much. you only need one. split functions are also branch splits...
11:57:52 <fog> it solved a graph problem to do with planning
11:58:00 <fog> seems like a project managers dream
11:58:14 <ja> giovani: that was for you
11:58:17 <ja> javran: sorry
11:58:29 <javran> I forgot that function have two branches
11:58:35 <maerwald> emmanuel`: the one killer argument for haskell is ... refactoring is easier... that means you can go way more "agile". He'll understand that for sure
11:58:46 <fog> its also more legible
11:58:49 <giovani> myLength xs = 1 + myLength (tail xs)
11:59:02 <emmanuel`> There are actually two product managers that I'm dealing ith.
11:59:03 <emmanuel`> with
11:59:04 <giovani> It's all I need since I already use the parttern with [], right?
11:59:07 <fog> by leveraging higher order functions
11:59:13 <javran> as I don't like to repeat the function name, I'll usually LambdaCase that, but that's a bit too far for beginners
11:59:19 <fog> difficult to do without using a functional programing language
11:59:31 <ja> giovani: you don't need to call tail if you pattern match before the =
11:59:49 <ja> > tail []
11:59:50 <lambdabot>  *Exception: Prelude.tail: empty list
11:59:54 <maerwald> figure out the non-functional requirements... is it a maintenance heavy product? if not... why use haskell?
11:59:59 <giovani> Oh, right
12:00:09 <fog> emmanuel` the first pass is to give the most brief argument "there are reasons that its better"
12:00:35 <giovani> myLength x:xs = 1 + myLength (xs)
12:00:41 <ja> yes i like that
12:00:43 <giovani> I could use _:xs
12:00:47 <fog> not much point going into those reasons if they are going to dispute that "reasons its better" isnt convincing 
12:00:48 <ja> but you don't need the parens
12:00:48 <maerwald> fog: sales ppl start such sentence always with a loud and long BECAUSE
12:00:59 <maerwald> fog: much more psychological effect
12:01:15 <fog> only if its their *job* to be convincing 
12:01:26 <maerwald> much to learn from them 
12:01:40 <ja> 'be-a-cuase' as Axman6 would say
12:02:12 <fog> they are on the offensive, if your in a position of comfort, simply defending a case, then there is no point exhausing yourself, especially if the opponent is trying to draw you out
12:02:48 <maerwald> Or you start with "that's a good question, really smart" and then you move on destroying it one by one
12:02:54 <demon_in_a_jar> @pl \f (a,b) -> (fmap f a, f b)
12:02:54 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .) . fmap)
12:03:05 <fog> "its better, you dont care why, so im not going to try and convince you"
12:03:05 <emmanuel`> Yeah, I see what you guys are saying.
12:03:20 <emmanuel`> So I've already sent one of the product managers detailing why I think a rewrite is a bad idea.
12:03:33 <ja> passive agressiveness, i love it! but it will get you nowhere
12:03:37 <emmanuel`> I've also invited him to a discussion about the topci
12:03:42 <ezzieyguywuf> I'm a product manager!
12:03:43 <maerwald> I had a prof who would always say "you're absolutely right", but would then completely dismantle your arguments
12:03:45 <ezzieyguywuf> but not for software
12:03:47 <ezzieyguywuf> lol
12:03:49 <emmanuel`> ja: Am I being passive aggressive?
12:03:52 <Clint> maerwald: that's quite a trick
12:03:55 <Uniaika> maerwald: oof :D
12:04:06 <ja> emmanuel`: i think maerwalds suggestion is passive-agressiveness, no?
12:04:10 <maerwald> It makes you listen
12:04:11 <emmanuel`> oh lol
12:04:11 <fog> emmanuel` no, i was being facetious 
12:04:12 <Uniaika> the guy did *not* want to argue at all
12:04:31 <maerwald> All nice psycho tricks
12:04:42 <maerwald> work well on managers
12:04:58 <fog> actually there is a pretty decent spiel most haskellers can rattle off with varying degrees of enthusiasm 
12:05:54 <ja> maerwald: yeah, all managers have exactly the same personality type, and you can use whatever definition of "psycho trick"  you want, they will definitely fall for it and assume their inferior position!
12:06:09 <maerwald> emmanuel`: or you could ask his opinion from time to time on irrelevant things... things that don't matter to you. He'll think you value his opinion. But the trick is that YOU decide what to ask about
12:06:32 <maerwald> ja: lol
12:06:44 <fog> type safety avoids runtime errors. lazy evaluation makes handling of infinite containers possible, promoting recursive definitions - which was part of the motivation for the language borrowing from mathematical proofs of induction - being close to mathematical syntax makes it more maintainable and better for teaching
12:06:49 <maerwald> I'm humoring a bit, obviously
12:08:32 <fog> the killer argument is for mission critical code, type safety is actually a must
12:08:59 <maerwald> mission critical, AI, big data
12:09:37 <fog> there was some talk someone gave when they were talking about using SAT solvers to brute force a black box controler for a flight system
12:09:45 <Henson> emmanuel`: what other issues, other than memory consumption, does your manager have with Haskell?
12:09:53 <maerwald> be careful, or he'll call haskell snakeoil and then you lost
12:10:00 <fog> to ensure it had literally no undesired responses  
12:10:24 <Henson> emmanuel`: I don't think using 1T of virtual memory during compilation is a valid complain.  As long as it compiles, and your machine doesn't need 1 TB of physical RAM to accomplish the task, what does it matter?
12:10:37 <Henson> emmanuel`: if it were using 1 TB of physical RAM during runtime, then yes that would definitely be a problem.
12:10:58 <fog> jessus, what are you typechecking!?
12:11:15 <maerwald> Henson: it tried on some WLS versions, no?
12:11:28 <maerwald> that was a fun tickeht
12:11:53 <ja> Henson: 'physical RAM' cannot really be measured I think, so that would be unlikely. and he even mentioned it was virtual memory
12:12:29 <ja> or she!
12:12:40 <fog> basically, you can factor down some 80,000 line code for some important system, into something that becomes human readable
12:13:08 <fog> features such as exhastiveness checking also help prevent unforseen corner cases
12:13:21 <maerwald> Henson: https://github.com/microsoft/WSL/issues/1671
12:13:25 <Henson> ja: right.  There's a difference between being concerned about the number displayed by the computer during compilation, and the costs of that number.  Does it use up all the memory in your computer and cause it to crash, or use up 1 TB of swap space and take 5 hours to compile?  Hopefully not.
12:13:48 <fog> and, because of the "common parlance" that the higher order functions provide, devs dont go around reinventing the wheel
12:13:55 <fog> and can read each others code
12:14:06 <fog> which i think was the "agile" point made above
12:15:00 <Henson> maerwald: what is WSL?
12:15:21 <maerwald> winows subsystem for linux
12:15:22 <fog> foldrMDefault f b xs = getM xs >>= maybe (return b) (\(x,xs)->f x >>= \g -> foldrMDefault f b xs >>= g) 
12:15:28 <fog> see! how legible is that!
12:15:42 <Henson> emmanuel`: was the manager concerned about the number, or did it really take a huge amount of physical and/or virtual memory to compile?
12:16:07 <ja> emmanuel`: that link has a branch of ghc you could try if you don't wanna discuss overcomitting :O
12:16:28 <ja> precompiled by herbert
12:16:41 <maerwald> yes, trick your manager!
12:16:47 <emmanuel`> Henson: That wasn't during compilation.
12:17:02 <ja> maerwald: the manager would argue that virtual memory is the trick ;)
12:17:02 <emmanuel`> Henson: That was during the runtime. Also it was 1.0T of virtual memory
12:17:17 <fog> Henson: he was probably champing at the bit for an excuse to worry the haskellers 
12:17:33 <emmanuel`> Henson: The manager's main complaints seem to be resource usage during compilation.
12:17:50 <emmanuel`> Henson: He also doesn't like the long build times (while ignoring why the build times are long)
12:17:55 <Henson> emmanuel`: but is that just the virtual address space size, or did it really swap 1 TB of stuff out to the swap space?
12:18:08 <emmanuel`> Henson: It was virtual memory for sure.
12:18:15 <emmanuel`> He thought this was a big deal.
12:18:15 <Henson> emmanuel`: ok
12:18:32 <ja> emmanuel`: teach him about JITs. teach him how in some systems, compilation NEVER STOPS :O
12:18:51 <emmanuel`> Henson: This same manager claimed that Haskell doesn't have dead code elimination.
12:18:59 <emmanuel`> I corrected him.
12:19:01 <Henson> emmanuel`: how long is a typical build time?
12:19:04 <maerwald> Look, he's probably waking up at midnight worrying about the platform going down due to memory issues
12:19:10 <maerwald> have you thought of that
12:19:23 <emmanuel`> So, we are using nix to do builds (I still need to set up our CI also)
12:19:30 <Henson> emmanuel`: by dead code elimination do you mean garbage collection?
12:19:47 <emmanuel`> The builds on my machine (when nix caching doesn't kick) can take at least an hour.
12:20:05 <emmanuel`> However, nix caching tends to resolve that time to something much smaller in subsequent builds.
12:20:27 <fog> he might have convinced himself that all these "reasons" put forwards by the astute devs are actually a conspiracy to corner him into some language induced hell 
12:20:38 <maerwald> emmanuel`: or just use cabal-cache
12:20:47 <Henson> emmanuel`: that's after all of the Haskell dependencies have been built already, and it's just compiling your code?  I can see the Haskell dependencies taking a long time, but you must have one heck of a big program if it takes an hour to compile just your code.
12:20:48 <emmanuel`> Henson: He thought that since Haskell binary sizes are large (with no definition of what is acceptably large) that there must be dead code in the binary
12:20:54 <emmanuel`> Which is horrible reasoning
12:21:06 <fog> meybe they are "beyond reason" 
12:21:13 <Henson> emmanuel`: ohh, I see, "when nix caching doesn't kick"
12:21:14 <maerwald> emmanuel`: tell him bout split-sections
12:21:21 <ja> nuke him from orbit. only way to be sure
12:21:31 <emmanuel`> split-sections
12:21:42 <emmanuel`> I'll have to look that up.
12:21:54 <maerwald> emmanuel`: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--split-sections
12:22:12 <maerwald> that with stripping makes haskell binaries ordinary
12:22:19 <Henson> emmanuel`: yes, the trick is to keep the Haskell dependencies in your nix store so you don't have to rebuild them every time.  I use NixOS and Haskell for a bunch of my stuff, and I think these build time complaints are valid.  But there are ways of mitigating the problem.
12:22:41 <ja> just run everything in ghci
12:22:47 <fog> oh yeah, if you are using nix-copy closure that takes ages...
12:22:52 <Henson> emmanuel`: the problem is not that haskell's build times are huge, it's that the way the software system is structure is you're building and rebuilding a ton of extra code that you really should only have to build once.
12:23:19 <fog> ah, fast hotswapping
12:23:27 <maerwald> Henson: they are huge :p
12:23:31 <fog> so, tell him facebook opted for haskell to *solve* that issue
12:23:53 <maerwald> why is facebook not contributing to ghc
12:23:55 <maerwald> or are they
12:23:56 <monochrom> "All is true."
12:24:43 <Henson> maerwald: what are huge?
12:24:43 <fog> well simon marlow is there, i think he did some ghc stuff, but i guess they are more concerned with the haskellers not devoting all the resources to developing their compiler!
12:24:52 <maerwald> Henson: build times
12:24:53 <fog> strange though that MS research do...
12:25:01 <fog> or do they get everything from well-typed?
12:25:08 <monochrom> Oh! maerwald, I tried ghcup on WSL ubuntu 20.04, it's fine. :)
12:25:20 <maerwald> waaaag
12:25:42 <Henson> maerwald: in the context of Nix builds with unbuildtdependencies, or Haskell build times are huge just in general?
12:25:49 <maerwald> glguy posted this https://gitlab.haskell.org/haskell/ghcup-hs/-/issues/32
12:26:00 <maerwald> Henson: in general
12:26:36 <monochrom> Oh, that one is simply your webpage javascript being a smartass and go "if Windows I recommend Haskell Platform".
12:26:46 <maerwald> I fear it will cause a sudden spike of windows users seeking tech support here
12:26:58 <fog> some of the uses of haskells type safety are pretty wild - like, trying to design type safe manifold learning for compositional approximators
12:26:59 <Henson> maerwald: I would say I've never noticed them to be a problem, but I think that's because I've never worked on a sufficiently large project for them to become a problem :-)
12:27:01 <monochrom> heh
12:27:02 <maerwald> I'll have to write a tutorial with  screenshots then
12:27:48 <maerwald> Henson: 330 modules monolith here
12:27:59 <maerwald> 16gb ram was barely enough
12:28:07 <fog> having things traditionally thought of as networks of interacting black bokes in the mean field limit - instead being haskell programs
12:28:08 <monochrom> My opinion (some people call it elitist but I think I disagree) is that this is one of those things you should let the reader decide for themselves.
12:28:10 <Henson> maerwald: to compile!?
12:28:13 <maerwald> if you switch branches... boom
12:28:39 <monochrom> (The elitist part is: if they are not competent to make that decision, what are they doing in programming at all?)
12:29:02 <fog> drinking too much coffee and doubting themselves?
12:29:19 <maerwald> competence is overrated.. just need swift decisions ppl are happy with... no one will ever know if they were good
12:29:40 <fog> nah, haskell people try to do things right
12:29:48 <monochrom> It is very simple and robust to state: "this is for linux, macos, and WSL". It is not robust, as empirically proved, to use javascript to auto-detect OS.
12:31:09 <maerwald> I read about a manager recently arguing that it doesn't matter at all to him what language his engineers are using... only that they are happy with it. Because motivation is gold and if that motivates them, let them have it
12:31:33 <monochrom> I agree with that actually.
12:32:10 <emmanuel`> That sounds like a good managere.
12:32:21 <emmanuel`> s/managere/manager
12:32:23 <maerwald> Using prolog for GUI programming since then...
12:32:25 <maerwald> xD
12:32:38 <monochrom> Because, again empirically proved, the norm of managers reading buzzword magazines and dictating languages to engineers fails.
12:32:52 <Rembane> Prolog for GUI programming sounds fun. 
12:33:00 <maerwald> exactly
12:33:11 <dolio> I don't know if it's specifically an elitist concern.
12:33:22 <maerwald> Also, imagine the anxiety attack the next junior dev will experience
12:34:15 <ja> junior people should have as much anxiety as possible. more job security
12:34:20 <maerwald> lol
12:34:45 <dolio> There seems to be quite a few people who focus on that kind of unnecessary style thing. Like, 'the website should automatically pick the right thing for me, even though I'm capable of selecting it from a list.'
12:34:48 <merijn> I did a GUI program in prolog in university!
12:34:59 <Rembane> merijn: Was it fun? 
12:35:16 <maerwald> it has gtk support even, no?
12:36:01 <glguy> I find the automatic OS detection websites like to do now just creates more work for me
12:36:05 <merijn> Rembane: I remember mostly confusion :p
12:36:22 <Rembane> merijn: That sounds like my whole university education. :D
12:36:31 <glguy> Just because I'm using a Mac browser doesn't mean I'm not targeting an Ubuntu terminal window I'm working in
12:36:33 * Henson chuckles
12:36:50 <Henson> glguy: haha
12:37:00 <maerwald> glguy: it allows you to see all options though
12:37:19 <monochrom> But it's fine print.
12:37:29 <glguy> I'm taking in general. It's just annoying to have to go looking for the actual list
12:37:32 <maerwald> can  make it monochrom bold
12:37:57 <merijn> monochrom: The problem is that "robust and reliable tools" can't automate everything, but people seem to prefer "does 100% of the work 90% of the time" over "reliably does 90% of the work 100% of the time"
12:38:01 <ja> glguy: but your browser sent that header itself. your complaint is like people who would dismiss monochrom's website for using the 'default font'
12:38:28 <maerwald> glguy: https://github.com/haskell-infra/www.haskell.org/pull/14
12:38:38 <monochrom> List of options waiting for human choice should be in the prominent foreground. Auto-detection suggestions should be the fine print.
12:38:40 <maerwald> heavy discussion there
12:39:17 <maerwald> if we figure that ticket out, there might be no reason to have a dedicated ghcup site
12:39:19 <glguy> "Click here if you don't know what kind of computer you have"
12:39:45 <maerwald> now we have ~4 dl pages?
12:39:48 <maerwald> or more
12:39:55 <maerwald> and all cross-redirecting
12:39:59 <monochrom> merijn, actually I think that both kinds have use cases. But it's tricky and takes empirical evidence to find out which one is better for what.
12:40:54 <maerwald> merijn: managers sell not the reliability, but the feature set :p
12:41:09 <fog> oh yeah, what does anyone think of the scanners idea?
12:41:10 <merijn> monochrom: Yeah, but automating the remaining 10% is much easier of the 90% is reliable
12:41:21 <merijn> monochrom: It is not in the other case :)
12:41:42 <maerwald> MVP and so (all features working half of the time)
12:42:10 <merijn> I prefer MVPs with half the features working all the time :p
12:42:37 <maerwald> merijn: but that's not good for decision making
12:42:41 <demon_in_a_jar> is anyone aware why most examples of dynamorphisms seem to be about the catalan numbers? I mean considering that catalan numbers can also be solved with histomorphisms. 
12:43:00 <monochrom> I side with the economists in estimating how much human time multiplied by hourly wages would be spent on the 10% failure cases.
12:43:57 <maerwald> I went into the world thinking at least financial institutions must agree with you merijn ... I was wrong
12:44:31 <monochrom> and of course, compared to the cost of getting 100% reliable. (usually 90%+delta reliable has cost exponential to delta)
12:44:47 <monochrom> also, one-time cost vs cost per year.
12:44:59 <hseg> *facepalm* of course iso-deriving will loop if you define your instance in terms of itself
12:45:25 <merijn> monochrom: tbh, I find the economic cost in terms of time saved a reductionist perspective
12:45:42 <merijn> monochrom: Some tasks are worth automating even if the time spend is never recouped in time saved
12:46:00 <merijn> Because the impact of unautomated tasks is greater than merely "the time spent doing them manually"
12:46:06 <maerwald> annoyance is not measurable, indeed
12:46:09 <merijn> There's also disruption of other work, irritation, etc.
12:49:40 <monochrom> In that case I feel a conservation of annoyance here.
12:50:17 <monochrom> Someone has to be annoyed. You can only choose: you annoyed vs your users annoyed.
12:51:45 <ja> i think the usual approach is to try to trick users into thinking they are not annoyed. many people used to watching ads would probably say that ads do not annoy them
12:52:46 <fog> do we have adds in science? "try this new theory, good for all your conceptual needs - now with free monads"
12:53:26 <monochrom> Yes, it's called "the Popular Science Magazine" :)
12:54:47 <ja> science has peer review, which is a trade. you cite me, i cite you.
12:54:48 <fog> i thought it was supposed to be about doing stuff correctly, not pushing some self serving ego gratification 
12:55:15 <Henson> monochrom: I used to love that magazine when I was a kid.  Now that I look back at it, it was just one giant advertisement.
12:56:20 <Shiranai> Everytime I do stack setup, it downloads another ghc even if I already have one with the same version downloaded; is there no way to tell stack "look, I already have it"?
12:56:22 <ja> also, look at all the universities teaching java because it is 'useful'. is that not an ad? they get more money from companies if they teach something companies like
12:56:23 <monochrom> I think it gets better: you cite me, I approve your paper for publication :)
12:56:50 <fog> sounds like something out of rick and morty, like, "heres what we used to do, done differently, for no reason, with new packaging" except its all lazers and time travel 
12:57:39 <Uniaika> monochrom: smart move
12:57:48 <monochrom> I think that one also gets better. If you don't teach Java, we won't hire your students. I don't even have to fund you.
12:58:57 <fog> oh god, that sounds like some kind of existential crisis of marxist alienation in a post-work society. learning java just to while away an otherwise meaningless existence, with the deceived sense of purpose 
12:59:04 <ja> the government can one-up that one with UBI though
12:59:21 <fog> get back to digging holes you
12:59:35 <monochrom> Remember what I thought of large companies open-sourcing the libraries/frameworks/languages/whatever?  What they gain is you people learning their way on your own time, at your own expense, so they don't have to pay for your training if they decide to hire you.
13:00:26 <monochrom> And remember the zero sum game: Every minute you spend learning Facebook's library is a minute not spend learning Facebook's competitor's way. (OK not that they have competitors.)
13:00:41 <ja> they do, it is IRC! muahahahaha
13:01:49 <fog> monochrom oh no! the attention wars
13:02:03 <fog> we own your time
13:02:55 <maerwald> open source as brain washing methodology: an analysis
13:03:49 <monochrom> I wouldn't call it brainwashing. Just like what the con people rightfully say: I didn't rob you, you gave it to me.
13:04:24 <monochrom> So I would say it's con.
13:05:14 <fog> unless you reverse engineered all their subliminal messaging 
13:05:24 <fog> using adversarial learning
13:05:37 <ja> but they call it 'abuse' when i steal their brain and put it in a vat...
13:05:56 <Rembane> Bah! They are so conservative! 
13:06:07 <fog> sue the matrix!
13:06:21 <monochrom> Oh we all already know that every imperative library carries imperative sublimal messages. We already know it as Sapir-Worf.
13:07:15 <fog> all avatars appearing in this simulation that resemble real users likeness is purely coincidental. facebook accepts no responsibility for having imprisoned your soul
13:08:32 <ja> fog: "adversarial learning" is scary because what if they learn faster than you? 
13:08:56 <fog> then you need better nets!
13:09:22 <fog> i figure thats why they still teach backprop
13:10:38 <fog> haha! they shal calculate the gradients when none are better
13:11:11 <fog> and then they rob all the money they put on their startup fintech firms opening gambit 
13:12:30 <ja> i am out of my depth here. backpropagation is outdated? backpropagation makes you calculate gradients?
13:12:44 <fog> yeah, hessian free ftw
13:13:12 <fog> or something langevin 
13:13:32 <fog> i cant remember what its called, like adaboost or adam or something
13:14:37 <fog> stochastic gradient descent etc. still advocated by google, i bet they are making a killing of all the misdirected trading algos
13:14:58 <fog> tensorflow, now with numpy and pandas
13:15:08 <fog> cackles
13:15:29 <fog> students wasting hours with runtime errors
13:15:47 <fog> ending up with things they can barely train on the school supercomputer
13:16:27 <ja> sounds like a conspiracy! i'm in!
13:19:10 <fog> cool, now what i need you to do is write me a typesafe convolutional denoising autoencoder
13:20:27 <fog> and run it with an adversarial noise - to construct a generative stochastic network for model inference 
13:21:23 <fog> then we need to use a loopy belief propagation network for Bayesian convergence guaranties  
13:21:55 <fog> which needs a cyclic stencil zipper on free tensor nets
13:23:08 <fog> which we will use as a pole placement / sliding mode controller over 1000 haskell coding monkeys 
13:23:36 <fog> and they can derive the higher order functions needed for the most succinct implementation
13:26:09 <fog> except we cant let them simulate themselves or we could end up trapped inside their typewriters!
13:29:53 <Shiranai> Hello, I am having trouble with the fgl. I think I am misunderstanding something, in this example what does `Gr` mean? https://hackage.haskell.org/package/fgl-5.6.0.0/docs/Data-Graph-Inductive-Example.html
13:30:46 <Shiranai> Looks like a data constructor but I haven't seen anything like that be defined, there's only the Graph typeclass in https://hackage.haskell.org/package/fgl-5.6.0.0/docs/Data-Graph-Inductive-Graph.html
13:30:51 <dmwit> `Gr a b` is the type of graphs whose nodes are labeled by values of type `a` and whose edges are labeled by values of type `b`.
13:30:52 <c_wraith> Did you click on it?
13:31:15 <c_wraith> It's one particular implementation of the Graph class
13:31:51 <ezzieyguywuf> ooh, another fgl user?!
13:31:53 <Shiranai> god my bad, didn't know you could click on it
13:32:16 <Shiranai> I am currently trying to figure how to use fgl because I am studying posets and wanted to do some computations :)
13:32:30 <ezzieyguywuf> Shiranai: I found a nice blog post that walked through it ...decently
13:32:35 <Shiranai> read Erwin's paper, really nice thing
13:32:39 <ezzieyguywuf> and I can share with you my code that uses fgl.
13:32:40 <Shiranai> ohhh please share it
13:32:44 <dmwit> Yes, the original paper is excellent.
13:33:15 <ezzieyguywuf> Shiranai: this is the blog post https://mmhaskell.com/blog/2017/6/21/graphing-it-out
13:33:35 <Shiranai> @dmwit: Yeah it's amazing, I had tried for some days to do some inductive data structure but couldn't figure it out
13:33:35 <lambdabot> Unknown command, try @list
13:34:23 <Shiranai> Thanks for sharing! Since you've already played with it, do you know how can I visualize the graph?
13:35:40 <fog> is fgl the approach that uses algebraic graphs?
13:36:41 <fog> something about preserving a traversable instance...
13:36:54 <ddellacosta> fog: are you talking about https://hackage.haskell.org/package/algebraic-graphs ?
13:37:37 <Shiranai> I do not know what you mean by algebraic graph but basically constructs the graph node by node, adding with each new node the set of arrows that come into it and come from it
13:38:57 <ezzieyguywuf> Shiranai: Here's my code that uses it - https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/Topology/src/Topology.hs#L69
13:39:13 <ezzieyguywuf> excuse the messiness, I've been focusing elsewhere and have not refactored/cleaned up this module
13:40:05 <ezzieyguywuf> Shiranai: regarding visualizing it - for me personally, it helped to thing about "Node" (i.e. a data-storing thing) and "Bridges" (i.e. a relationship between nodes), but that's because I'm using the graph to store Vertex and Edge information so the traditional nomenclature was confusing things for me
13:40:44 <ezzieyguywuf> Shiranai: It helped me to forget about the "Label" at first, and instead work on just adding nodes and making connections between them.
13:41:27 <ezzieyguywuf> Shiranai: heck, even working on making a pretty printer for my graph was helpful too, and in the end useful as it gives me a clear visual of the current state.
13:51:08 <fog> ddellacosta: thanks
13:51:35 <fog> cant really grok the difference between "inductive" and "algebraic" though
13:52:18 <fog> is it supposed to imply that somehow you could build a graph thats "wrong" (doesnt fit in the algebra of graphs) with fgl?
13:54:06 <fog> the paper is here btw; http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
13:57:43 <fog> there is also;
13:57:44 <fog> Functional Programming with Graphs https://dl.acm.org/doi/pdf/10.1145/258949.258955
13:59:05 <ddellacosta> fog: I was just reviewing the paper that goes along with the hackage link I posted, and the intro talks about fgl and containers a bit https://dl.acm.org/doi/pdf/10.1145/3122955.3122956
13:59:23 <ddellacosta> I'll take a look at the papers you posted
14:00:02 <fog> there is a version of that here;
14:00:03 <fog> https://eprint.ncl.ac.uk/file_store/production/239461/EF82F5FE-66E3-4F64-A1AC-A366D1961738.pdf
14:00:18 <fog> Algebraic Graphs with Class (Functional Pearl) Andrey Mokhov
14:00:26 <ddellacosta>  oh yeah, same author I think
14:00:58 <ddellacosta> oh same paper haha
14:01:01 <fog> huh, its the same paper, just not paywalled
14:01:15 <fog> lol
14:01:18 <ddellacosta> oh sorry, I didn't realize my link was paywalled
14:01:31 <ddellacosta> in any case yeah, that :-D
14:02:09 <fog> its probably not a persistent link, so i included the title
14:02:42 <fog> actually, it seems to be from the newcastle server so i can feel ok about bypassing the paywall
14:03:46 <fog> the real problem that i have with the inductive version is that it uses Ints to encode edges
14:04:29 <fog> if you use Free Nonempty instead, then its all done with tail references 
14:05:06 <fog> and then there is some deluge of arguments about direct or higher order memory access, but whatever
14:05:37 <fog> yada yada "idiomatic haskell"
14:07:25 <fog> i guess its performance vs type safety at the end of the day
14:07:44 <fog> sometimes you want fast access, sometimes you want provability about the graphs
14:08:11 <fog> there is probably some voodoo workaround that gives the best of both of these properties
14:08:40 <fog> but some things, eg. mollecular structures, you want to have some kind of certainty about them being fully connected or something
14:08:58 <fog> so you need to have this guarantied by construction
14:09:17 <fog> i guess thats part of the algebraic approach
14:10:11 <fog> the thing thats good about the Free Nonempty version is that it can be infinite and lazy - good for unrolling programs onto
14:10:33 <fog> but damn those cyclic references
14:11:54 <fog> some people might question why you would use graphs to represent molecules anyway... but i guess there is some abstract features that you want them to satisfy  
14:12:05 <fog> like their being (co)monads
14:12:40 <fog> so then thats the property you want your graphs to preserve by construction 
14:13:25 <fog> and you can get that eg, like Foldable Alternative implies Monad
14:13:43 <fog> so then you want them to retain their foldable instance by construction
14:14:06 <fog> and then you have them concatenable via "Linear" instances
14:14:18 <fog> get and set, giving functor foldable and traversable
14:14:35 <fog> and Alternative, and so Monad
14:15:10 <fog> and again, the Free Nonempty version of graphs *does* have this preserved during construction
14:15:56 <fog> ie algebraically preserving monadicity by being tail matchable
14:16:15 <fog> (and nicely lazy as a result too)
14:16:55 <fog> and then there is some hellishness to do with trying to break off branches for something like split - thinking of the comonad thing
14:17:19 <fog> where really you want to be able to extract contiguous subregions 
14:17:54 <fog> which gives something like "shaped construction" with the cons needing a shape index
14:18:02 <monochrom> You need a blog account.
14:18:40 <fog> for this i had Traversable_i, and seti and geti; https://gist.github.com/fen-hs/6bb03486008a8a31b9edf95f8bd35f46
14:19:02 <fog> monochrom: thats what you say before you ban me
14:19:49 <fog> infact, even the word "blog" is starting to fill me with dread 
14:20:29 <monochrom> I'm not doing anything today. Still, other ops are getting even more impatient than me.
14:20:37 <merijn> Chat channels with 1000+ people aren't really the place to go on monologues so long that my entire backlog is just you talking on your own, though
14:21:41 <fog> i was kind of hoping that one of them might be one of the researchers that does these actual funded explorations of functional graphs
14:22:08 <fog> im not trying to invalidate the other approaches
14:22:43 <fog> but this version, while well motivated, isnt going to be of any use to anybody as long as im the only person doing it
14:23:09 <fog> im not trying to excuse spaming up the channel. i forget
14:23:21 <fog> appologies
14:24:12 * hackage simple-smt 0.9.5 - A simple way to interact with an SMT solver process.  https://hackage.haskell.org/package/simple-smt-0.9.5 (IavorDiatchki)
14:25:29 <fog> still, thats my entire thesis in 15 mins
14:26:17 <fog> would take longer to read a whitepaper
14:26:21 <fog> and to write!
14:26:38 <fog> whatever, i dont mean to be rude or take liberties 
14:26:43 <fog> i shall bid you a dew
14:32:43 * hackage lucid-cdn 0.1.1.0 - Curated list of CDN imports for lucid.  https://hackage.haskell.org/package/lucid-cdn-0.1.1.0 (locallycompact)
14:38:25 <koz_> Is there some particular reason why you can't standalone derive multiple things in one line? Something like 'deriving stock instance (Show, Read, Eq, Ord) Foo'?
14:41:12 * hackage safe-tensor 0.2.0.0 - Dependently typed tensor algebra  https://hackage.haskell.org/package/safe-tensor-0.2.0.0 (nalex)
14:52:42 <Waldkauz> koz_: The standalone syntax is different from the simple one, it's much like a normal instance declaration
14:53:08 <koz_> Waldkauz: Let me rephrase my question a bit then. Is there anything stopping us _other than syntactic decisions_ from having something like that?
14:54:14 <Waldkauz> I guess not
14:59:47 <dminuoso> koz_: Well I think DerivingStrategies is not useful without at least some other extension. At least cant I come up with something from the top off my head
15:00:26 <koz_> dminuoso: ... I'm not really sure what DerivingStrategies has to do with what I'm asking? I can rephrase my example without using an explicit strategy.
15:00:28 <dminuoso> Say GND, or DeriveAnyClass
15:00:35 <koz_> It's more 'I wanna one-line derive multiple standalone things'.
15:00:57 <koz_> (you're not wrong, honestly, but it's kinda orthogonal)
15:01:02 <dminuoso> Oh I think I misunderstood then.
15:02:34 <koz_> dminuoso: Sorry - I guess I kinda muddied the question.
15:02:36 <dminuoso> koz_: Yeah I think the argument about "looking like normal instance declarations" is important here.
15:02:42 <dminuoso> Consider something like
15:03:04 <dminuoso> deriving instance Foo a => Bar a
15:03:30 <dminuoso> It should show that this is more about "looking like an instance declaration" rather than a "deriving clause"
15:06:00 <koz_> dminuoso: Yeah, I see your point.
16:48:12 * hackage language-dickinson 0.1.1.2 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-0.1.1.2 (vmchale)
16:50:39 <etherealemb> Hey all, I'm new to Haskell
16:54:51 <Cale> Hey etherealemb -- let us know if you have any questions :)
16:58:02 <etherealemb> Cale have you used any of the http & xml parsing modules and if so do you have any recommendations on which is the most user-friendly?
16:59:02 <Cale> You're parsing the http protocol directly?
16:59:17 <Cale> Or you mean http and (xml parsing) :)
17:01:07 <Cale> It's been a long time since I last did any xml parsing...
17:01:16 <Henson> etherealemb: what language are you most familar with / do you enjoy the most?
17:01:22 <Cale> If your needs are very simple, you might just use this: https://hackage.haskell.org/package/xml
17:01:30 <etherealemb> Python
17:01:31 <Henson> etherealemb: I've used HXT to parse GPX files (from a GPS receiver)
17:01:59 <etherealemb> @Henson did you find it to be well documented and easy to use?
17:01:59 <lambdabot> Unknown command, try @list
17:02:00 <Cale> https://hackage.haskell.org/package/http-conduit-2.3.7.3/docs/Network-HTTP-Simple.html -- this bit of http-conduit tends to do a decent job of simple HTTP tasks
17:02:18 <Cale> (and the rest of the library is not bad if what you're doing is a little fancier)
17:03:39 <etherealemb> thank you guys
17:29:57 <texasmynsted> For shell scripty things there are many options Hsh, hsshellscript, turtle, shelly, and others. For some reason this seems related to choice of streaming library
17:31:07 <texasmynsted> Streamly looks nice for streaming
17:33:49 <texasmynsted> I have tried to pick a shell lib before and every time I end up thinking it is a great solution to a problem I likely do not have. Anybody here using a shell scripting lib?
17:34:25 <texasmynsted> shell-conduit looks nice but feels like that would not align nicely with streamly
17:38:25 <jackdk> texasmynsted: I have not. Notice that most stream libs have ways to interop with each other. Here's streamly's section on interop with conduit: https://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly-Tutorial.html#g:39
17:45:14 <sm[m]> texasmynsted: I don’t think it had d any special streaming support, but I like Shake.Cmd
17:46:07 <sm[m]> I mean https://hackage.haskell.org/package/shake-0.19.1/docs/Development-Shake-Command.html
17:49:12 <sm[m]> I think these things are for when you have haskell that needs to run shell
18:05:51 <ezzieyguywuf> man. gui stuff is complicated. lol.
18:07:34 <cohn> hi, is there a "Data.Text" equivalent to the read function in Prelude?
18:08:25 <Shadorain> ezzieyguywuf, yeh gui not gud
18:08:32 <Shadorain> tui ftw
18:08:46 <ezzieyguywuf> hah, actually I think an UI is difficult.
18:08:50 <ezzieyguywuf> but TUI is easier than GUI
18:08:59 <ezzieyguywuf> there's just so much to manage and think about.
18:09:07 <Shadorain> i def could agree with that
18:09:19 <Shadorain> one example i can think of: display managers
18:09:25 <Shadorain> like tty is 100x easier
18:09:31 <Shadorain> + faster
18:20:58 <chaseries> relatively new haskeller here with a problem. i have a server using the websockets package that has a type more or less like `data Client conn = Client Id Meta conn UTCTime`
18:21:47 <chaseries> now there's also a collection of these types representing multiple `Client conn` connections
18:22:41 <chaseries> (`conn` is just a general placeholder for the connection type, in my case Ws.Connection)
18:23:18 <Henson> cohn: basic-prelude has one with type "Read a => Text -> a" but under the hood it's just "Prelude.read . Text.unpack"
18:23:21 <chaseries> it makes sense to me to have the container for these types be a set, but Data.Set requires an Ord and an Eq instance, and frankly i can't come up with a good notion for how to write either
18:24:03 <cohn> Henson: ok, thanks! I wound up just using Text.unpack. *shrug*
18:24:30 <Henson> cohn: yeah, that's what it really is under the hood.
18:25:46 <chaseries> i actually would like them *ordered* based on the time they arrived so that i can create a meaningful queue of them, but equality based on a timestamp of two `Client conn` would be meaningless; in that case, it would be the `Id` type that would need to be compared (because users can get disconnected and re-connect)
18:25:51 <Henson> chaseries: are all of the subtypes of Client instances of Ord and Eq?  If so, you can just auto-derive Ord and Eq for your Client
18:26:46 <chaseries> Henson: well, `conn` in practice wouldn't be, since it's really `Ws.Connection` and websockets doesn't implement an Ord for that
18:27:38 <Henson> chaseries: hmm.  Does Ws.Connection implement Eq?
18:27:57 <chaseries> i guess my biggest hangup is that a meaningful instance of Ord for a Client would be over a different type than a meaningful instance of Eq
18:28:02 <chaseries> Henson: i don't believe so
18:28:37 <chaseries> which is actually another, parallel question, because i can write in instance of Eq or Ord over client that ignores Ws.Connection, but is this bad practice?
18:29:06 <orion> Hi. I am compiling GHC 8.8.3 from source on FreeBSD 12.1-RELEASE. I am getting the following error: https://gitlab.haskell.org/snippets/1654 Anyone know how to best alleviate this?
18:31:30 <Henson> chaseries: well, since Ws.Connection doesn't implement either of those, you'd have to figure out some way of distinguishing your connections from each other (Eq), and of arranging them in some order (Ord).  It doesn't look like Connection implements anything, so whatever you end up doing for your Client Eq and Ord instances must necessarily ignore Ws.Connection.  Looking at the constructor for...
18:31:55 <Henson> chaseries: Ws.Connection, it doesn't look like it contains anything useful for uniquely identifying the connection anyway.
18:33:43 <chaseries> Henson: my issue i guess is that 1. the only meaningful way in my mind to compare equality is to compare users by their ID (they're authenticated in principal and have a PK associated with them)
18:34:29 <chaseries> but 2. this is not a meaningful way to order them -- in that case, for my purposes, anyway, it makes more sense to look at when they arrived
18:35:24 <solonarv> the order doesn't have to be particularly meaningful if you're just using it so they can be keys in a Map or something
18:35:25 <chaseries> should I write Eq and Ord over each user's unique ID and then implement a `toList` function that orders them by arrival timestamp?
18:35:50 <Henson> solonarv: true
18:36:26 <solonarv> for example, there's an Ord instance for complex numbers in base, even though there is no ordering of C that interacts nicely with the arithmetic operations
18:37:18 <Henson> chaseries: do you actually need to use Eq and Ord for anything other than being able to put them into a Set or other data structure that requires deriving Ord and Eq?
18:37:37 <chaseries> Henson: nope
18:37:41 <kiwi_45> Hello all
18:38:12 <chaseries> Henson: i mean, i would like to preserve the order that they arrived
18:38:29 <chaseries> Henson: but with a timestamp, i've already got that and can just sort them
18:39:23 <chaseries> Henson: (my OG implementation didn't include a timestamp and just put them into a list, which actually works to, but then i found myself writing what were basically set operations over those lists and thought "gee, maybe i should just use a real Set")
18:39:31 <chaseries> too*
18:40:02 <Henson> chaseries: correct.  Using UTCTime may be sufficient.  If there's a tie you could always extend Eq and Ord to use the UUID next or any of the other data types other than Ws.Connection.
18:41:08 <chaseries> Henson: thank you for restoring my sanity :P
18:41:17 <Henson> chaseries: :-)
18:41:18 <chaseries> solonarv: you, too !
18:42:36 <Henson> chaseries: the only reason Set (or Map) needs those to have Ord and Eq is because of how the data is stored.  If you were to use a List it wouldn't have that requirement, but then you couldn't tell any of the Clients apart without an Eq instance.
18:42:43 <kiwi_45> I need help with servant authentication part of my haskell web app, I am able to follow the tutorial and with help of guys here I have written this https://github.com/DeepakKapiswe/Gyan-Lahari-Backend/blob/redisIntegration/src/App.hs but I'm unable to work with browsers, i.e I can't access my endpoints from browser, earlier it was working! , please
18:42:43 <kiwi_45> help me I could not find anything helpful on internet or even I don't know what to look for, maybe I'm missing some thing, btw I'm totally new to web dev
18:44:10 <Henson> kiwi_45: what changed from when it was working to when it wasn't?
18:45:37 <kiwi_45> Henson : when I introduced Authentication code following this tutorial : https://github.com/haskell-servant/servant-auth#readme, I can't access endpoints from browser which earlier was working without authentication code
18:46:09 <Henson> kiwi_45: so it was working without authentication, but when you added authentication then it stopped working?
18:47:10 <chaseries> Henson: that makes sense, so i'll just write Ord over the UUIDs and when i serialize that data i'll just convert & sort it by timestamp
18:48:03 <kiwi_45> Henson: actually program is compiling and I can see with curl, when I do login it sets some Headers, jwt which I use for next request but then it does not behaves correctly i.e  no data is returned even if I gave bearer token, while nothing is accessible with browser
18:49:05 <Henson> chaseries: sure
18:50:25 <Henson> kiwi_45: hmm, unfortunately I'm not familiar enough with servant's auth library to help you past this point, but it seems like you're on the right track.
18:53:58 <kiwi_45> Henson: Thanks a lot, I managed to travel here but now I need help to get out of it :)
18:54:51 <Henson> kiwi_45: just keep trying and investigating, you'll eventually figure it out.  And come back and ask again at a later time, maybe somebody else will be on who can help you.
19:09:25 <kiwi_45> anyone else ?
19:39:42 * hackage curve25519 0.2.5 - Fast implementations of the curve25519 elliptic curve primitives.  https://hackage.haskell.org/package/curve25519-0.2.5 (AdamWick)
19:58:42 * hackage dataflower 0.2.2.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.2.2.0 (jessekempf)
20:16:12 * hackage dhall-docs 0.0.1 - Generate HTML docs from a dhall package  https://hackage.haskell.org/package/dhall-docs-0.0.1 (GabrielGonzalez)
21:16:38 <texasmynsted> thank you jackdk. sm[m] Yes, I do like Shake quite a bit. I have used it for making a build system. I never thought to use it to make a shell script. Good idea.
21:51:03 <dmj`> who wants to see my permutations function
21:56:48 <dmj`> https://gist.github.com/dmjio/8ae058d9f1ea807f4c8737fd87b9b028
21:56:59 <mapf0ld> I do. What's your salespoint? Efficient enough for practical use or something?
22:01:12 * hackage coya 0.1.0.1 - Coya monoids  https://hackage.haskell.org/package/coya-0.1.0.1 (chessai)
22:02:12 * hackage ring-buffers 0.1.0.2 - mutable ring buffers with atomic updates in GHC Haskell  https://hackage.haskell.org/package/ring-buffers-0.1.0.2 (chessai)
22:04:43 * hackage fib 0.1.0.1 - fibonacci algebra  https://hackage.haskell.org/package/fib-0.1.0.1 (chessai)
22:04:58 <mapf0ld> Checked. It's elegant. Whenever I see append I would deforestate and remove it though. Any idea for improvement?
22:17:32 <mac10688> I'm curious who here programs in haskell with excellent intellisense
22:19:11 * hackage casa-abbreviations-and-acronyms 0.0.8 - CASA Abbreviations and Acronyms  https://hackage.haskell.org/package/casa-abbreviations-and-acronyms-0.0.8 (TonyMorris)
22:36:17 <dmj`> mapf0ld: it's aesthetically pleasing, haven't benchmarked against Data.List's permutations
22:36:34 <dmj`> mapf0ld: has a nice bottom up construction
22:38:47 <dmj`> mapf0ld: not sure it can be improved
22:39:43 <c_wraith> You can get faster than Data.List.permutations, but to do so you'll have to give up the amount of laziness it provides
22:41:41 <c_wraith> dmj`: length is a performance killer
22:48:22 <mapf0ld> c_wraith: And append (worst O(N^2) I asssume) with carrying around all the thunks are possible source of performance killer, too.
22:48:52 <c_wraith> the appending is..  not great, but not a huge problem
22:50:25 <dmj`> we might be able to get rid of the call to length
22:51:17 <c_wraith> I suppose the does add an O(n) factor, but that is hard to observe when the size of the output is O(n!) anyway, and it's only the last elements that will be getting the worst hit from the appending.
22:56:04 <liiae`> [0,1,3,7,9] how to get the sequence of any two element's sum? like [0+1, 0+3, 0+7, 0+9, 1+3, 1+7, 1+9, 3+7...]
22:59:59 <c_wraith> liiae`: but you want to exclude 0+0 and 1+1 ?
23:00:13 <mapf0ld> liiae`: Naive way would be using Applicative, [a+b | a <- lst, b <- lst, not (a == b)].
23:00:14 <liiae`> c_wraith: yes
23:00:33 <liiae`> c_wraith: it should be [1,3,7,9,4,8,10,10...]
23:00:47 <liiae`> c_wraith: I use that to describe what I'd like to do
23:01:02 <liiae`> mapf0ld: could you express it without list comprehension?
23:02:39 <dmj`> > do { let lst = [0,1,3,7,9]; a <- lst; b <- lst; guard (a /= b); pure (a + b) }
23:02:41 <lambdabot>  <hint>:1:31: error:
23:02:41 <lambdabot>      parse error on input ‘<-’
23:02:41 <lambdabot>      Perhaps this statement should be within a 'do' block?
23:04:25 <c_wraith> dmj`: the semicolon was interpreted as belonging to the let, not the do
23:04:38 <int-e> > do { let { lst = [0,1,3,7,9] } ; a <- lst; b <- lst; guard (a /=  b); pure (a + b) }
23:04:40 <lambdabot>  [1,3,7,9,1,4,8,10,3,4,10,12,7,8,10,16,9,10,12,16]
23:04:46 <dmj`> ah, thanks
23:05:07 <dmj`> > let { lst = [0,1,3,7,9] } in do { a <- lst; b <- lst; guard (a /=  b); pure (a + b) }
23:05:09 <lambdabot>  [1,3,7,9,1,4,8,10,3,4,10,12,7,8,10,16,9,10,12,16]
23:05:15 <liiae`> int-e: just use functions from Data.List, could it express?
23:05:58 <liiae`> liftA2?
23:06:07 <c_wraith> dmj`: also, if you haven't seen it before, a classic way to implement your own permutations is to have fun with a helper function:  select :: [a] -> [(a, [a])]
23:06:35 <int-e> > map (uncurry (+)) . filter (uncurry (/=)) . join (liftM2 (,)) $ [0,1,3,7,9]
23:06:36 <lambdabot>  [1,3,7,9,1,4,8,10,3,4,10,12,7,8,10,16,9,10,12,16]
23:06:50 <dmj`> c_wraith: I'm in the market for a subsequences that generates longest length lists first
23:06:54 <int-e> (note that the join is in the reader monad)
23:07:00 <dmj`> > subsequences [1..3]
23:07:02 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
23:07:08 <dmj`> I'd prefer this reversed
23:07:24 <c_wraith> > filterM (const [True, False]) [1..3]
23:07:25 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
23:07:32 <c_wraith> not quite
23:07:33 <liiae`> int-e: what about we replace this + with get any two element's list?
23:07:39 <int-e> > subsequences [1..]
23:07:40 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
23:07:48 <int-e> c_wraith: that's why it's not reversed
23:08:02 <liiae`> [0,1,3,7,9] to be [[0,1],[0,3],[0,7],[0,9],[1,3]...]
23:08:14 <dmj`> int-e: I guess I mean sorted descending by length
23:08:23 <int-e> liiae`: if you drop the map in front you get pairs
23:08:32 <int-e> dmj`: which doesn't make sense for infinite lists
23:08:57 <dmj`> int-e: sure, but this won't be an infinite list
23:09:33 <int-e> dmj`: This is about `subsequences` which I'm pretty sure was designed with infinite lists in mind.
23:10:33 <dmj`> int-e: that's fair, I'm looking for a variant that is ordered by length, and doesn't necessarily need to be designed with infinite lists in mind
23:11:21 <liiae`> int-e: wait, it suppose to be [1,3,7,9,4,8,10,10,12,16] not [1,3,7,9,1,4,8,10,3,4,10,12,7,8,10,16,9,10,12,16]
23:12:21 <liiae`> <liiae`> [0,1,3,7,9] how to get the sequence of any two element's sum? like [0+1, 0+3, 0+7, 0+9, 1+3, 1+7, 1+9, 3+7...]
23:14:53 <int-e> > let f [] = [[[]]]; f (x:xs) | xss <- f xs = zipWith' (++) (map (map (x:)) xss) ([] : xss); zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys; zipWith' _ _ ys = ys in concat . f $ [1,2,3]
23:14:55 <lambdabot>  [[1,2,3],[1,2],[1,3],[2,3],[1],[2],[3],[]]
23:15:16 <dmj`> > filter (>0) $ (\x y -> if x == y then 0 else x + y) <$> [0,1,3,7,9] <*> tail [0,1,3,7,9]
23:15:18 <lambdabot>  [1,3,7,9,4,8,10,4,10,12,8,10,16,10,12,16]
23:15:20 <int-e> probably not the best :)
23:15:44 <dmj`> > filter (>0) $ zipWith (\x y -> if x == y then 0 else x + y) [0,1,3,7,9] (tail [0,1,3,7,9])
23:15:46 <lambdabot>  [1,4,10,16]
23:16:25 <int-e> But I've found that arranging for the lists to be produced ordered by length is surprisingly awkward.
23:16:46 <int-e> (The above is one of the less messy ways I've found.)
23:18:01 <int-e> > let f [] = [[[]]]; f (x:xs) | xss <- f xs = zipWith' (++) (map (map (x:)) xss) ([] : xss); zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys; zipWith' _ _ ys = ys in f $ [1,2,3] -- actually the key idea is to produce the lists *grouped* by length
23:18:03 <lambdabot>  [[[1,2,3]],[[1,2],[1,3],[2,3]],[[1],[2],[3]],[[]]]
23:18:12 <dmj`> wow
23:18:40 <dmj`> that is quite the function
23:20:28 <int-e> > let f [] = [[[]]]; f (x:xs) | xss <- f xs = zipWith (++) (map (map (x:)) xss ++ [[]]) ([] : xss) in f [1,2,3] -- I guess `zipWith` works too if you want it. And this can be written as a fold but I'll leave it as an exercise; it wouldn't make the code any clearer.
23:20:30 <lambdabot>  [[[1,2,3]],[[1,2],[1,3],[2,3]],[[1],[2],[3]],[[]]]
23:30:31 <iqubic> Are we doing powerset here?
23:30:34 <MarcelineVQ> <liiae`> [0,1,3,7,9] how to get the sequence of any two element's sum? like [0+1, 0+3, 0+7, 0+9, 1+3, 1+7, 1+9, 3+7...]       [ map (+x) xs | (x:xs) <- tails [0,1,3,7,9]]
23:34:34 <antalsz> I just updated GHC to 8.10.1 with Homebrew (macOS 10.13.6), and now I can’t update cabal-install – Homebrew installed cabal-install 3.2.0.0, but trying to `cabal install cabal-install` fails to find a compatible dependency set
23:35:32 <antalsz> Any ideas to work around that?
23:35:58 <dmj`> int-e: thanks, I will try this function on for size
23:39:53 <hololeap> i just realized that mapM_ is basically fold but using the "action" as the monoid instead of a value
23:42:07 <dmj`> > fold [print "hey", print "foo"]
23:42:09 <lambdabot>  <IO ()>
23:42:16 <hololeap> guess i meant foldMap
23:42:19 <dmj`> like sequence
23:42:58 <dmj`> hololeap: almost, we need foldMapM 
23:43:15 <hololeap> wait `IO ()` is a valid monoid in haskell?
23:43:21 <dmj`> hololeap: yes
23:43:49 <dmj`> > print "hey" <> print "there"
23:43:51 <lambdabot>  <IO ()>
23:44:30 <dmj`> mconcat, fold, sequence kind all act the same on IO
23:44:38 <dmj`> kind of*
23:44:45 <dmj`> IO () *
23:44:52 <hololeap> instance Monoid a => Monoid (IO a) -- Defined in ‘GHC.Base’
23:44:55 <hololeap> there it is
23:45:02 <hololeap> didn't know that before now
23:45:14 <dmj`> doubt its used often
23:46:33 <hololeap> well, just getting back to the point of mapM_ being similar to foldMap, think about mapM using Writer as the Monad
23:47:21 <hololeap> it's basically foldMap over the `w' argument
23:54:29 <hololeap> it also explains why traverse_ only requires a Foldable constraint... it's exactly same as mapM_, without the unnecissary constraints
23:59:55 <dminuoso> instance Semigroup a => Semigroup (IO a)
