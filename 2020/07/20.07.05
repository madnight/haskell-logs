01:01:30 <Taneb> Is there any library providing orphan Hashable instances for containers?
01:17:28 <c_wraith> they look like one-liners. instance Hashable S.Set where hashWithSalt = hashUsing S.toList
01:17:44 <c_wraith> But I'd be surprised if they're in packages anywhere - hashing a container is sort of weird.
01:23:13 <[exa]> c_wraith: tell it to bitcoin people... :]
01:24:11 <c_wraith> a Merkle tree is a lot more interesting than hashing a static container.
03:12:59 <bibek> Hi there, how do you guys develop haskell in vim? I am having a hard time setting up nvim for haskell.
03:19:08 <Rembane> bibek: I'm running it without problem, what's your setup? 
03:20:20 <__monty__> bibek: Basically just with ghcid running in a tmux split.
03:22:07 <bibek> Rembane: I am using coc.nvim and hie. nvim is stuck at "starting LS Languageserver.Haskell"
03:25:25 <Rembane> bibek: Got it, I don't use either of them. :)
03:26:11 <bibek> Rembane: what's your setup?
03:26:32 <Rembane> bibek: Can you activate some debug mode and get the verbose output from hie? 
03:26:57 <bibek> Rembane: I'll try that.
03:28:37 <bibek> Rembane: cann you tell me what's your setup?
03:28:48 <Rembane> bibek: I'm using syntax highlighting, ALE with hlint and ghcid in another window
03:31:35 <fendor> bibek, in your project root directory, you can do `hie --debug .`, then hie attempts to load every file in your project
03:41:51 <bibek> fendor: it says "Setup.hs" is not supported. I am investigating it
03:42:00 <fendor> bibek, that is fine
03:42:20 <fendor> Setup.hs is a special Cabal file that can not be loaded by ghcide/hie/hls
03:44:35 <bibek> fendor: i was going throught github issue and there is a user named fendor, I suppose that's you. :) The issue is: https://github.com/haskell/haskell-ide-engine/issues/1650
03:45:56 <fendor> bibek, yeah that's me :) Indeed, you may just ignore this file. Does the rest work?
03:47:49 <bibek> fendor: no, i've not yet got that working
03:48:30 <bibek> This is the error: LSP[hie] "cannot satisfy -package-id mendelbrot-0.1.0.0-KcjpyQEzfYdAshRcApJ6Nx\n    (use -v for more information)"
03:49:13 <fendor> bibek, can you explain your project a bit? Cabal, stack, etc... ?
03:50:46 <bibek> it's a stack project, uses package.yml. I started it by `stack new mendelbrot`
03:52:57 <fendor> bibek, and then you tried to open a file in `src/` or `app/`?
03:55:01 <bibek> fendor: in app/
03:55:07 <bibek> Main.hs
03:55:31 <bibek> I have OpenGL and GLUT as dependencies in the project.
03:56:09 <fendor> bibek, the problem is this issue: https://github.com/haskell/haskell-ide-engine/issues/1616
03:56:33 <bibek> fendor: thanks, I'll look into it.
03:56:40 <fendor> the work around is to add a file named `hie.yaml` to the root of your project with this content `cradle: {stack: {}}`
03:57:17 <fendor> with this file, we essentially use `stack repl` to load the project. If this command works for your project, hie should be able to load it
04:00:33 <bibek> okay
04:02:05 <bibek> fendor: thanks, it seems to work !!
04:03:27 <fendor> bibek, yay, happy to hear it :) BTW, be sure to give hls(https://github.com/haskell/haskell-language-server) a try, it is still in an early stage, but it already works pretty well, and is the successor of hie
04:04:00 <fendor> if you have a hie.yaml, you can use it as a drop-in replacement of hie, you can even use the same editor plugins
04:04:18 <bibek> fendor: yes, I was about to give it a try. but then I thought why not ask about the current issue here.
04:05:20 <fendor> bibek, makes sense. The issue with Setup.hs exists there, too, though. 
04:06:50 <bibek> fendor: okay.
04:07:46 <timCF> Hi guys! I don't understand one thing about Generics and Show class deriving. For example, in "base" source code there is a line `deriving instance Show RuntimeRep`. But if I'm trying to do the same trick with my own class which have default implementation based on GHC.Generics - it just not working.. Complier says `Could not deduce (Generic
04:07:46 <timCF> RuntimeRep)`. But how it can work for `Show` then?
04:38:47 <kuribas> timCF: you need to add a Generic instance to RuntimeRep
04:39:00 <kuribas> timCF: also, Show is builtin, not Generic
04:39:37 <timCF> kuribas so there is some built-in deriving magic which I can't reuse for my own classes?
04:41:08 <timCF> `Show` deriving somehow works for any type regardless does type implement `Generic` class or not
04:41:15 <kuribas> timCF: there is built-in magic for Show, also for Functor and Applicative with extensions.
04:41:36 <kuribas> timCF: but for your own data you need to use Generics
04:42:06 <kuribas> timCF: in order to use Generics, your data type must have a Generic instance.
04:42:32 <kuribas> for example: data MyData = MyCons Blah Foo Bar deriving (Show, Generic, ...)
04:42:43 <timCF> Ok, I got it, thanks. Maybe I will go with bunch of local Generic orphan instances, I guess nothing is wrong with it
04:43:05 <kuribas> you mean RuntimeRep is not in your code?
04:43:17 <timCF> yes, it's in Base I. guess
04:44:39 <kuribas> well using Generics with RuntimeRep looks very dodgy indeed
04:44:59 <kuribas> why do you need RuntimeRep anyway?
04:47:14 <timCF> kuribas I'm basically re-implementing Show class with some improvements I do prefer Show class should have (but don't have in Base). It is based on Generics, and my initial idea was to re-derive everything which standard Show have. Works for most types, but not for all. I don't need `RuntimeRep`, I just found that it has Show instance, so I wanted
04:47:14 <timCF> to support it in my own class as well)
04:47:59 <kuribas> erm, why?
04:48:37 <timCF> just because I think Show from base is not good enough :)
04:48:38 <kuribas> Generics doesn't work with anything, just with instance of Generic
04:49:02 <kuribas> perhaps you are using Show wrongly?
04:49:28 <timCF> Yes, I see. I just though that base Show is using Generics as well, but seems like it's some other magic (TH?)
04:49:35 <kuribas> like in, using it for something that Show wasn't made for?
04:49:51 <kuribas> timCF: no, it's implemented in the compiler
04:52:36 <timCF> kuribas I just making it better - polymorphic Renderer instead of ShowS which is hardcoded with inefficient String type
04:52:42 <timCF> kuribas https://github.com/tkachuk-labs/show-safe/blob/693b7778c4c57dd2e447bcb40d275704493e89c2/src/ShowSafe/Data.hs#L27-L33
04:53:46 <kuribas> there is test-show: https://gist.github.com/kuribas/34d5b57e4225e2fc6b3e21bb1fafea95
04:54:08 <kuribas> wrong link...
04:54:18 <kuribas> https://hackage.haskell.org/package/text-show
04:54:34 <kuribas> IMO should just bite the pain
04:54:43 <kuribas> use Text.pack when necessary
04:54:56 <kuribas> anyway Show isn't for generic conversion to text
04:55:09 <kuribas> it's just a printable representation of types
05:01:41 <timCF> kuribas yeah, I have seen this package - it's cool. In my case I forgot to mention that there is one more property of my class - it suppose to stop accidental leaks of secrets to logs, because for basic "blind" types like Text, ByteString, String etc it will use this combinator
05:01:42 <timCF> https://github.com/tkachuk-labs/show-safe/blob/693b7778c4c57dd2e447bcb40d275704493e89c2/src/ShowSafe/Combinator.hs#L37-L51 which will show harmless hash of data. In most cases (at least my case) in actual business logic values are usually wrapped in newtypes, and if it's safe to show some particular newtype as raw text - this will be just
05:01:42 <timCF> implemented explicitly, otherwise will be derived as this harmless hashed output
05:02:49 <joecordingley> Hi. If I want to do long computations and race them against timeouts asyncronously, how do I wrap a normal function in IO to use it with async? Are there any recommended resources to read up on such things?
05:07:03 <maerwald> :t race
05:07:04 <lambdabot> error: Variable not in scope: race
05:09:12 <kuribas> timCF: IMO it's already a mistake to show logs to the user
05:09:55 <Arahael> Depends on the user.  An Admin? Fine. A Dev? Obviously. Anyone else? Nup.
05:10:26 <kuribas> Arahael: yeah, I mean enduser
05:10:43 <kuribas> timCF: also show might not be the best thing for logging
05:14:50 <timCF> Arahael kuribas but in general you want to show data in logs somehow. Manually coerce every time is very inconvenient, especially with nested product types, so I want generic solution for that. In general I think default Show is bad especially in terms of security, so usually I just don't implement it for my data and newtypes. But I still want
05:14:51 <timCF> convenient way to **safely** show data in logs. By logs I mean just stdout which is recorded to file or kibana
05:15:28 <Arahael> timCF: In my line of work, we *don't* want to show data in logs.  We only want to show the current operation that the code is doing, and almost never the data itself.
05:16:27 <Arahael> timCF: So actually, this looks to be what you mean by stopping "accidental leaks of secrets to logs".
05:17:04 <Arahael> timCF: You must be dealing with backend services, I expect.
05:19:55 <timCF> Arahael but how you investigate incidents when something is going wrong? Logs are useful, and data in logs is useful as well. I just think that blindly show all scalars (like Text) in raw is not secure, and decision how it should be shown should be explicit for every newtype, and totally restricted for raw blind types like Text. Harmless hash still
05:19:56 <timCF> might be useful for investigations, DevOps will have access to hash salt and will be able to identify this data in some cases
05:20:43 <timCF> Arahael yes, I'm working with backend services mostly
05:21:38 <Arahael> Good luck. :)
05:21:54 <timCF> Thanks ðŸ˜€
05:24:41 * hackage QuickCheck 2.14.1 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.14.1 (NickSmallbone)
06:18:41 * hackage vado 0.0.13 - Runs commands on remote machines using ssh  https://hackage.haskell.org/package/vado-0.0.13 (HamishMackenzie)
06:22:58 <kuribas> how can you use your own libraries with stack?
06:23:04 <kuribas> do you need to put the together in a project?
06:24:31 <kuribas> ah, there is packages: in stack.yaml
06:31:42 * hackage language-dickinson 0.1.1.0 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-0.1.1.0 (vmchale)
07:46:56 <siraben> What is usually used to work with CSV in Haskell? csv-conduit or cassava?
07:58:53 <[exa]> siraben: whatever best fits the rest of the program
07:59:39 <siraben> Also, any way that ToField and FromField can be derived? I keep having to write things such as http://ix.io/2qXB
07:59:55 <siraben> [exa]:  In what sense?
08:00:33 <[exa]> siraben: if you're going with conduit, use conduit, if not I'd go with cassava
08:00:46 <[exa]> also kinda depends on the complexity of the formatting in the CSV
08:00:46 <siraben> Also, looks like csv-conduit is failing to work with cabal
08:00:59 <siraben> http://ix.io/2qXE
08:01:10 <siraben> Fails to find Data.Conduit.Attoparsec
08:01:48 <[exa]> siraben: btw your deriving should be solved by just saying `instance FromField YN`, like the docs say
08:03:21 <siraben> [exa]:  I get warnings about no explicit implementation for parseField
08:03:28 <siraben> And it fails
08:03:57 <[exa]> wtf, docs say that it has to work :]
08:04:14 <[exa]> can you extract a minimal failing example?
08:04:17 <siraben> Indeed, it's been like this for months now
08:05:39 <[exa]> oh noes I mistaken that with FromRecord
08:06:11 <siraben> data YN = Yes | No deriving (Generic, Show)
08:06:12 <siraben> instance FromField YN
08:06:12 <siraben> foo = runParser (parseField "Yes" :: Parser YN)
08:06:13 <siraben> minimal example
08:06:32 <siraben> FromRecord and ToRecord can be derived thankfully, but fields no.
08:10:31 <[exa]> hm, perhaps make oneline instances that derive it from show/read?
08:13:35 <siraben> I'll try that.
08:14:05 <siraben> Anyone able to get documentation strings from packages installed with cabal? I get "This is probably because the module was compiled without '-haddock'," when I attempt to do say, :doc traversed
08:14:09 <siraben> in the REPL
09:21:39 <frdg> the only thing that I have in the build-depends portion of .cabal file is `yesod >=1.6 && <1.7`. I am unable to run `cabal repl` without getting this message: `After searching the rest of the dependency tree exhaustively, these were the goals I've had most trouble fulfilling: project, yesod`. I have also tried not specifying the version and got the same error.
09:22:55 <Athas> frdg: have you done 'cabal update'?
09:23:09 <Athas> Otherwise my best guess is that you don't have the right version of GHC.
09:23:16 <ezzieyguywuf> how can I track down a segfault? in c++ I would launch in gdb and then `backtrace` to see what was going on at the time. is there something similar in ghc?
09:23:35 <frdg>  
09:23:35 <frdg> ya I did that yesterday being dumb and not realizing what it does
09:23:48 <Uniaika> ezzieyguywuf: weep https://gitlab.haskell.org/ghc/ghc/-/wikis/debugging/compiled-code
09:25:18 <ezzieyguywuf> oh lawd
09:25:21 <ezzieyguywuf> ðŸ˜­
09:25:34 <ezzieyguywuf> I know the error is do to forkIO'ing something
09:25:39 <ezzieyguywuf> maybe I can just logic my way through it
09:26:11 <Uniaika> you may
09:27:56 <ezzieyguywuf> honesty a backtrace wouldn't really help me here. the problem seems to go away when I place putStrLn in strategic locations, so this is obviously some sort of threading/syncing issue
09:30:38 <ezzieyguywuf> yikes, now I can't even reproduce the crashe. *sigh*. this is why I avoid threading, lol.
09:57:32 <maerwald> yeah, one thing haskell doesn't really solve ;)
10:04:46 <Uniaika> ezzieyguywuf: come to Erlaaaaaang~
10:11:06 <c_wraith> you know you can go into gdb and use the backtrace command with haskell code, too?
10:11:14 <c_wraith> I've debugged segfaults that way
10:11:37 <c_wraith> Most of them come from misusing native bindings anyway, so the native code often shows up in the backtrace
10:16:29 <c_wraith> Though the worst segfaults to debug are the result of memory corruption from specifying argument types of the wrong size in FFI calls
10:18:04 <Uniaika> :/
10:18:09 <Uniaika> these are a pain
10:30:07 <sm[m]> frdg: you could show the full cabal output
10:39:02 <frdg> sm[m]: I managed to fix it
10:39:23 <sm[m]> great
10:43:50 <frdg> I have a new issue though. GHCID is telling me that it cannot find a module which is specified in my .cabal file. What is stranger is that I am able to open a cabal repl and run functions from the library just fine.
10:50:52 <dmj`> frdg: are you using cabal new-repl with ghcid
10:52:25 <frdg> dmj: What I did to start it was `ghcid "--command=ghci File.hs"`
10:53:09 <dmj`> ghcid "--command=ghci -isrc File.hs"
10:54:08 <MarcelineVQ> y not   ghci -c 'cabal repl'
10:54:24 <maerwald> ghci /= cabal repl
10:54:25 <MarcelineVQ> *ghcid -c
10:59:49 <fragamus> ok I need to ask a ghcjs question and no one is answering in #ghcjs
11:02:36 <sm[m]> frdg: +1 to MarcelineVQ, have you tried ?
11:05:24 <frdg> the cabal repl took a while to load. So ghci -isrc did not work. MarcelineVQ's solution seemed to work but even when I have errors in the file I am working on and save I still am told "all good".
11:08:35 <MarcelineVQ> is the module from a different component? like do you have a library and executable section and the file you're working on is from the executable section?
11:11:20 <frdg> The library that was not being detected earlier is specified in the executable session. The module that I am working on is not mentioned anywhere in my .cabal file.
11:11:32 <frdg> section not session*
11:13:27 <sm[m]> frdg: stack/cabal don't make it easy to start a ghci with multiple components in scope, but you can look at the ghci command they run and modify it to include all your packages. make ghcid in the hledger project does this
11:14:52 <sm[m]> I guess it's as simple as adding -i options, eg stack exec -- ghci -iSUBDIR1 -iSUBDIR2 ... PATH/TO/Main.hs
11:15:54 <frdg> sm[m]: Sorry I am not quite understanding what I need to do.
11:17:06 <sm[m]> frdg I'd better not give more advice without understanding your setup
11:17:14 <MarcelineVQ> I'm not sure exactly about trying to work with a module that isn't in your project as though it was in your project, but you could try something like   ghcid -c 'cabal repl foodir/Blah.hs'
11:17:17 <maerwald> when trying to install chs-deps under freebsd, I get: alex: src/Language/Haskell/CHs/Deps.x: openFile: inappropriate type (is a directory)
11:17:26 <maerwald> except: it is not a directory
11:18:03 <MarcelineVQ> mind that you should test these things without ghcid first so you can see what they're doing
11:18:43 <monochrom> Generally, principle of fewer moving parts.
11:18:59 <frdg> MarcelineVQ: I am not at all opposed to having this module included in my project. I am extremely ignorant about how cabal works. I am just starting my first actual project.
11:19:23 <frdg> I do not know how to add a module to a project.
11:20:09 <MarcelineVQ> aha then that's step one to look into, let us know when you've got that one worked out :>
11:21:42 <monochrom> If exe, add module name to "other-modules:"
11:22:46 <sm[m]> a bit more help because it's hard to find the current cabal user guide: https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-other-modules
11:23:54 <MarcelineVQ> fwiw https://cabal.readthedocs.io/en/stable/developing-packages.html is hit 2 on a google search, but I'll admit you have to know that's a result you want hehe
11:24:05 <sm[m]> ah, better: https://cabal.readthedocs.io/en/latest/cabal-package.html#modules-and-preprocessors
11:24:41 <sm[m]> MarcelineVQ, I'm referring to https://github.com/haskell/cabal-website/issues/8, which isn't yet resolved
11:25:37 <operand_> What's the recommended way to get Cabal on arch?
11:26:54 <monochrom> MarcelineVQ: Yeah, sometimes it's hard to tell that hit #1 is not the best.
11:27:10 <frdg> Ok I got the module into my .cabal file. I am still having the same issue though in which I get "all good" from ghcid even though there are errors
11:27:11 <MarcelineVQ> operand: ghcup imo
11:27:30 <monochrom> I agree about ghcup.
11:28:32 <MarcelineVQ> operand: iirc I installed ghcup via AUR, haven't checked if its on official repos but I would doubt
11:33:12 * hackage math-programming 0.4.0 - A library for formulating and solving math programs.  https://hackage.haskell.org/package/math-programming-0.4.0 (prsteele)
11:34:12 * hackage miso-examples 1.7.1.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.7.1.0 (DavidJohnson)
11:34:57 <sm[m]> frdg: when you start frdg, it should print all the modules it's loading. Do you see your module with the errors in there ?
11:35:04 <sm[m]> when you start ghcid, rather
11:35:12 * hackage miso 1.7.1.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.7.1.0 (DavidJohnson)
11:35:23 <boxscape> what lattice is undefined the bottom element of?
11:36:05 <jchia_> operand_: Whatever you do, don't install Haskell-related packages from the Arch distro. You can download cabal-install here: https://www.haskell.org/cabal/download.html
11:36:58 <jchia_> You'll probably have to also download and install the ghc binaries, too, e.g. from here: https://www.haskell.org/ghc/download_ghc_8_10_1.html
11:37:38 <jchia_> I just put the executable files in my /usr/local/bin/
11:39:52 <frdg> sm[m]: I do not. The way I added the module to my .cabal was that I put it in the other modules section of the executables portion.
11:40:27 <operand> MarcelineVQ: thanks, I'll look into it
11:40:30 <sm[m]> try moving it to exposed-modules: ?
11:41:26 <monochrom> boxscape: The denotational semantic domain of Haskell values. But it is only a join semilattice.
11:41:36 <boxscape> I see, thanks
11:42:53 <monochrom> Actually one more thing. A separate join semilattice for each type. We don't usually mix values from different types.
11:43:09 <boxscape> Ah, I see
11:43:47 <fragamus> can anyone here answer a ghcjs question
11:44:01 <frdg> sm[m]: when I do that I get this error : https://pastebin.com/dQVck2fc
11:44:04 <boxscape> fragamus generally the advice in IRC is "don't ask to ask, just ask"
11:44:23 <boxscape> you'll find out whether someone can answer a ghcjs question once you've asked it :)
11:44:36 <sm[m]> or WILL you...
11:44:48 <fragamus> what does ghcjs do when compiling a module that has some file IO in it
11:45:07 <monochrom> Online asking and answering are full of the Byzantine Generals problem. :)
11:45:14 <sm[m]> frdg, if you like: also paste your cabal file, and the command you're running 
11:45:27 <fragamus> I do not propose to actually call the functions that do the forbidden file IO
11:45:43 <fragamus> I just want to call other functions that do pure stuff
11:45:57 <sm[m]> frdg: and perhaps the output of "tree", showing your files
11:46:39 <MarcelineVQ> sm[m], frdg: afaik by default cabal repl loads the library stanza if there is one. if you have a library section but you want to load modules from the executable you need to specify that section, e.g.  cabl repl :executablename
11:47:49 <MarcelineVQ> that's called a target and takes this form  https://cabal.readthedocs.io/en/latest/cabal-commands.html?highlight=target#cabal-v2-build
11:48:00 <frdg> https://pastebin.com/viahGxNu
11:48:21 <frdg> this is the current state of the .cabal file where I get the error I just posted
11:49:34 <sm[m]> frdg, is this actually a stack project ?
11:50:04 <frdg> yes
11:51:16 <sm[m]> frdg: I'll give stack commands then, since that's easier for me. Where is the file with errors, that ghcid is not seeing ?
11:51:20 <MarcelineVQ> sm[m]: That's not a big deal (imo) for just checking modules since the cabal file would be valid for either, using the same .cabal file with stack and cabal-install is only an issue if you're getting version conflicts
11:52:15 <frdg> sm[m]: the module is in the directory for the project
11:53:21 <sm[m]> frdg: and what's its name
11:54:17 <frdg> It is called Modules.hs. I renamed it FirstModule in the pastebin I gave you just for clarity
11:54:43 <frdg> the name really makes no sense but thats another story
11:57:30 <sm[m]> frdg: here's the kind of command that works best for me. It will load your Main file, and see changes in both the library and executable: ghcid -c 'stack exec -- ghci -isrc -iapp app/Main.hs'
11:58:11 * hackage math-programming-tests 0.4.0 - Utility functions for testing implementations of the math-programming library.  https://hackage.haskell.org/package/math-programming-tests-0.4.0 (prsteele)
11:59:24 <sm[m]> frdg: also: we suggested adding modules to your cabal file above, because we didn't know this was a stack project. In a stack project like yours with a package.yaml, this is unnecessary and not recommended; probably you will need to delete the cabal file now so stack can recreate it from package.yaml.
12:00:41 * hackage cronus 0.1.0.0 - Another bloated standard library  https://hackage.haskell.org/package/cronus-0.1.0.0 (sgschlesinger)
12:05:22 <frdg> sm[m]: So I deleted the cabal file. I ran the command you just gave me. It confirmed that It compiled Main. When I edit Main and put in an error and save I am told "all good" from ghcid
12:06:50 <frdg> If I make this a cabal project will I have a better chance of this working?
12:09:21 <MarcelineVQ> I wouldn't say so, this is more a matter of figuring out the project rather than the tool you're using, since they're very similar in this use
12:09:27 <sm[m]> frdg: no
12:10:21 <sm[m]> could we see your command and the full output, up to after you have saved the file with an error
12:11:36 <sm[m]> frdg, could we see your command and the full output, up to after you have saved the file with an error
12:11:50 <sm[m]> it sounds like something simple is wrong
12:11:54 <MarcelineVQ> You might also want to give the output from running without ghcid as well, to see what ghci is trying to load
12:12:42 * hackage curl-runnings 0.14.0 - A framework for declaratively writing curl based API tests  https://hackage.haskell.org/package/curl-runnings-0.14.0 (aviaviavi)
12:12:43 <sm[m]> the ghcid command shows that I believe, MarcelineVQ 
12:12:57 <sm[m]> the one I gave, at least
12:13:03 <MarcelineVQ> yeah just depends how its captured since ghcid will erase the screen
12:13:26 <sm[m]> ah true, I am always running in an emacs shell so I just scroll up
12:13:45 <frdg> One moment I am starting over from scratch and will give a detailed outline of every step I take.
12:14:05 <sm[m]> frdg, or, we can give you steps, might save some time
12:14:46 <sm[m]> like Marceline just said: what's the output of stack exec -- ghci -isrc -iapp app/Main.hs ? Or the command you are running, if different (and show it)
12:15:30 <frdg> I apologize I killed it already. I'll try to be quick.
12:20:06 <sm[m]> Remote troubleshooting of haskell tools can be pretty hard. We have been working on this 1.5h (just since I joined in), and also on other days (last thursday at least). I wonder what's a better way.
12:21:03 <sm[m]> better tools, obviously, but what's a faster way to support the current tools
12:26:42 <frdg> sm[m]: Im very sorry but I forgot the `ghcid stack command` you gave me and lost it from my bash history cause I accidentally killed my emacs. Here is what I got though: https://pastebin.com/9WzVz5Fm
12:31:20 <sm[m]> frdg: no problem. Here's a working example: https://termbin.com/3cje
12:31:31 <monochrom> sm[m]'s command was: ghcid -c 'stack exec -- ghci -isrc -iapp app/Main.hs'
12:33:56 <sm[m]> frdg: and if I want to add yesod: I add it to dependencies: in package.yaml; I kill the ghcid command; I run stack build --dry-run to regenerate the cabal file and install yesod; then I re-run the ghcid command
12:35:50 <sm[m]> I usually add a Makefile like https://termbin.com/78lj so it's just "make ghcid" or "make ghcid"
12:36:03 <sm[m]> or "make ghci"
12:38:01 <frdg> im here. Just working through what you gave  me.
12:40:34 <frdg> sm[m]: IT WORKED. You are amazing. Cant thank you enough for spending all this time to help me.
12:40:57 <sm[m]> team effort. Great.
12:43:04 <frdg> True. Thanks everyone
12:43:35 <sm[m]> moral of the story: stack (and cabal, even more so IMHO) make a lot of things easy once you know how, but they really need you to understand what you're doing or it's easy to wander forever in not-working-space
12:44:24 <sm[m]> second, pasting full details (relevant files, a full transcript) early and often saves a boatload of time
12:47:08 <sm[m]> frdg: on the upside, not many people have this simple but highly effective setup, so you are ahead of the game! :)
12:48:59 <frdg> huh no way!
13:04:59 <boxscape> monochrom: I could easily be wrong here, but do haskell values really form _join_ semilattices? I can easily see how, e.g. 1 :: Integer and 2 :: Integer have the greatest lower bound, i.e. meet, in bottom, but I cannot see how they have a join
13:07:11 * hackage alfred-margaret 1.0.0.0 - Fast Aho-Corasick string searching  https://hackage.haskell.org/package/alfred-margaret-1.0.0.0 (rkrzr)
13:11:10 <boxscape> ah, well
13:11:16 <boxscape> n-lab says that join semilattices have bottoms
13:11:23 <boxscape> so I must be getting confused somewhere
13:21:41 * hackage math-programming-glpk 0.4.0 - A GLPK backend to the math-programming library.  https://hackage.haskell.org/package/math-programming-glpk-0.4.0 (prsteele)
13:38:33 --- mode: tolkien.freenode.net set +o ChanServ
13:38:33 --- mode: tolkien.freenode.net set +o Sigyn
13:41:12 <freeman42x[m]> > :t when
13:41:12 <freeman42x[m]> or I can use discard pattern and return (), but I am sure there is better option
13:41:14 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
13:42:19 --- mode: tolkien.freenode.net set +o ChanServ
13:54:48 <superstar64> are there any fix point combinators that only work with tail recursion?
13:57:31 <sm[m]> freeman42x: void $ when ... sounds good
13:58:16 <freeman42x[m]> sm[m]: don't you mean when $ void ... ?
13:58:58 <sm[m]> Uh possibly, Iâ€™m confused, ignore me
13:59:32 <sm[m]> No I donâ€™t mean either of those, I mean the right answer
14:02:30 <MarcelineVQ> freeman42x[m]: what is the question?â€‹ :>
14:03:32 <freeman42x[m]> MarcelineVQ: how can I use when with IO Text ? it requires IO () . Do I need to discard the value using void? or is there another function which works with IO a ? or I can use discard pattern and return (), but I am sure there is better option
14:03:47 <boxscape> hmm, could it be that haskell values of a type only form a partially ordered set with a lower bound rather than a join semilattice? Still confused about what the join of something like 1 :: Integer and 2 :: Integer would be...
14:04:59 <boxscape> except the corresponding diagrams *do* look like a semilattice, but it looks like they have meets rather than joins :-/ Basically I'm still just confused about the whole thing I suppose
14:06:06 <boxscape> (diagrams like this one https://properlyspecified.files.wordpress.com/2015/08/haskell-semilattices-2.png )
14:06:24 <boxscape> the title of the image even says "semilattice", actually
14:08:48 <MarcelineVQ> freeman42x[m]: when foo (void iotextthing)  is pretty straightforward compare to other ways to write it, do you really not care about the possible Text result?
14:13:50 <freeman42x[m]> MarcelineVQ: "do you really not care about the possible Text result?" not at this point in the dev process
14:14:50 <boxscape> okay, I think haskell values form and unbounded meet semilattice
14:14:54 <boxscape> s/and/an
14:15:10 <MarcelineVQ> then void seems like a fine option
14:15:53 <rand8098099> Does anyone who's read the types and programming languages book know the prereqs for it? Just in the introduction it talks about "general recursion", which hasn't been defined formally in the book yet, and how every type contains at least one value, "x=x", if we allow general recursion which also doesn't make sense to me. Then it talks about
14:15:54 <rand8098099> partial/total correctness which I only know about cause I took a logic course.
14:20:19 <boxscape> rand8098099 the book has a page on required background
14:20:25 <boxscape> rand8098099 are you reasonably familiar with haskell?
14:21:43 <rand8098099> I haven't written tens of thousands of lines of haskell, but I know the basics(I wouldn't freak out if I see a bunch of <*> in the code like I did when I first started learning)
14:21:49 <rand8098099> lol
14:22:53 <boxscape> rand8098099 so basically, x=x just means you could define Haskell's `undefined :: forall a . a` as `undefined = undefined`, and you can use that as a value for any type
14:23:17 <boxscape> (or define it for each type individually, like `undefined_Integer :: Integer; undefined_Integer = undefined_Integer`, etc.
14:23:58 <boxscape> you need general recursion for this because otherwise you couldn't simply call the function (or value, technically) itself in its own definition
14:25:40 <rand8098099> that certainly type checks lol. Still kinda off
14:25:42 <rand8098099> odd*
14:26:20 <evanhilaa> I am trying to do `runhaskell Main.hs` but I am getting an error for could not find module parsec. I am able to run a cabal repl though and load Main. Parsec is specified in the build depends in the .cabal file in the executable section.
14:27:39 <boxscape> rand8098099 in fact, it's the only definition that typechecks for this (unless you get into functions like "error", which are equivalent from a denotational semantics point of view)
14:28:08 <superstar64> this there a name for this? https://pastebin.com/4iZ5nbHa
14:29:39 <boxscape> s/get into/allow
14:29:44 <rand8098099> I guess whenever I see a type definition like val :: Int, I considered val to be the name given to the value of the type, and not a value itself
14:29:51 <rand8098099> boxscape
14:31:04 <boxscape> rand8098099 I looking at it as a name is a correct way of looking at it - the value that "undefined" has here is technically called "bottom", which is also the value of any other expression that errors out or results in an infinite loop
14:31:15 <boxscape> s/I looking/I think looking
14:37:38 <evanhilaa> I am trying to do `runhaskell Main.hs` but I am getting an error for could not find module parsec. I am able to run a cabal repl though and load Main. Parsec is specified in the build depends in the .cabal file in the executable section. 
14:39:02 <boxscape> evanhilaa runhaskell doesn't use cabal, you probably want to do "cabal run"
14:40:32 <evanhilaa> when I use cabal run I get this error:https://pastebin.com/a7Sfep7U
14:41:23 <boxscape> ah, right, you have to do "cabal run executable", where executable is the name you have given your executable in the cabal file, I believe
14:43:54 <evanhilaa> boxscape: that error was from "cabal run Main.hs". If I simply run "cabal run" from the directory I get this error, https://pastebin.com/ZxzNMGMq
14:44:17 <boxscape> evanhilaa try "cabal run test-exe"
14:47:44 <evanhilaa> boxscape: That gives me this error: https://pastebin.com/tKFbQMpn
14:49:20 <boxscape> er my best guess is that the TryParser.hs file doesn't exist or isn't where it should be, but I'm not sure
14:50:14 <evanhilaa> it is imported into main and does exist. It is in the same project directory
14:50:45 <boxscape> are your .hs files in a src directory?
14:51:08 <evanhilaa> no
14:51:15 <boxscape> it seems that's where cabal expects them
14:51:23 <boxscape> so make a src directory in your project direcotry
14:51:26 <boxscape> and put them in there
14:51:31 <evanhilaa> ok
14:53:05 <boxscape> evanhilaa actually though it might help if you post your .cabal file
14:59:57 <evanhilaa> https://hatebin.com/mfkapmtymf
15:00:22 <evanhilaa> boxscape: Somehow got shut out of pastebin go figure
15:00:58 <evanhilaa> moving the files to src did not work by the way
15:01:16 <boxscape> evanhilaa okay, so, TryParser is part of your library, which has src as "hs-source-dirs", so TryParser.hs should be in src. Your executable consists of Main.hs, and since it has app as "hs-src-dirs", Main.hs should be in an app directory
15:01:31 <evanhilaa> ok
15:03:13 <boxscape> similarly, Lib.hs should be in src, if it exists
15:04:30 <evanhilaa> boxscape I moved Main.hs to app. I moved TryParser to src. I ran cabal run test-exe from the projects root directory and I still got the error for couldnt find parsec.
15:04:34 <evanhilaa> Lib is in src
15:05:24 <evanhilaa> I also ran "cabal run Main.hs" from in app and had no luck
15:06:34 <boxscape> hm I assume the same happens when you run "cabal v2-run Main.hs"
15:06:58 <boxscape> it's been a while since I've used cabal on its own...
15:07:22 <boxscape> evanhilaa
15:07:44 <evanhilaa> oh I definetly should have mentioned it is a stack project
15:07:49 <evanhilaa> sorry
15:08:09 <boxscape> ohh
15:08:12 <evanhilaa> I never touched my package.yaml
15:08:20 <boxscape> try "stack run test-exe"
15:08:30 <boxscape> or actually the syntax for stack might be different
15:09:16 <boxscape> (haven't used stack in a while either, I've been using cabal with nix :P)
15:09:20 <boxscape> might just be "stack run"
15:09:25 <evanhilaa> stack run test-exe gave me the same error where It cannot find parsec
15:09:34 <boxscape> erm
15:10:19 <boxscape> "stack build" does the same?
15:10:42 <evanhilaa> yes
15:10:52 <boxscape> have you run "stack setup" at some point?
15:11:17 <evanhilaa> no
15:11:46 <evanhilaa> ran it then got the same import error
15:12:07 <boxscape> okay, so actually, I just realized, since it's a stack project, you should edit the package.yaml, not the .cabal file
15:12:43 <boxscape> it should have a dependencies section where you can add parsec
15:13:11 * hackage cborg 0.2.4.0 - Concise Binary Object Representation (CBOR)  https://hackage.haskell.org/package/cborg-0.2.4.0 (BenGamari)
15:13:52 <evanhilaa> same import error
15:14:25 <evanhilaa> tried stack setup again but no luck
15:14:37 <boxscape> can you post your package.yaml file too?
15:14:56 <evanhilaa> yes
15:15:16 <freeman42x[m]> I am sorry.. https://i.imgur.com/NDxF3Gc.png WAT?!
15:16:03 <boxscape> freeman42x[m] try adding spaces around the $
15:16:48 <freeman42x[m]> oh, wow, I don't... what... why?! I am confused. Is $ valid in identifiers?
15:16:53 <boxscape> evanhilaa generally speaking you only have to run "stack setup" if you change your "stack.yaml" rather than "package.yaml", IIRC
15:17:21 <evanhilaa> https://hatebin.com/dqjnjobfur
15:17:27 <Cheery> http://boxbase.org/entries/2020/jul/6/how-to-read-code/
15:17:34 <boxscape> freeman42x[m] I think if you have -XTemplateHaskell enabled it means that whatever follows is a TH splice
15:18:22 <boxscape> evanhilaa hmm that looks good to me I think. "stack build" also still throws the error?
15:18:41 <evanhilaa> yes
15:18:57 <boxscape> can you paste the exact error?
15:19:04 <freeman42x[m]> @karma+ boxscape oh, that is probably it, I am using TH and I am pretty sure spaces were not needed when I was playing Clash of Code shortest code mode
15:19:04 <lambdabot> boxscape's karma raised to 6.
15:21:08 <evanhilaa> https://hatebin.com/kipersyjde
15:22:34 <boxscape> evanhilaa can you try adding parsec to the "dependencies" section of test-exe in package.yaml, in addition to where you already have it further up?
15:22:48 <evanhilaa> sure
15:23:01 <boxscape> though I'm not sure if that's the correct solution
15:24:37 <monochrom> Have you ever considered competing on shortest code contests by huffman-compressing your identifiers?
15:25:38 <evanhilaa> boxscape: no luck
15:25:59 <monochrom> For example suppose your code uses only these 3 identifiers: foo, bar, quartz.  foo occurs 1 time, bar occurs 40 times, quartz occurs 100 times.
15:26:35 <boxscape> evanhilaa hm, hold on
15:26:49 <monochrom> Then it stands to reason that you rename quartz to a shorter name, bar to a medium-length name, foo can be a bit longer.
15:27:18 <monochrom> If quartz is from a library, then your code begins with q=quartz, then you use q.
15:27:52 <boxscape> evanhilaa run "stack clean" and then "stack build" again?
15:28:14 <boxscape> evanhilaa I can't see something that's obviously wrong at this point
15:28:17 <evanhilaa> same error
15:28:22 <boxscape> hmm...
15:28:56 <evanhilaa> at this point though I need to leave. I am quite sorry. Thanks for the help.
15:29:28 <boxscape> okay, see you
15:29:34 <freeman42x[m]> monochrom: I never needed more than 1 letter identifiers in Clash of Code
15:29:51 <monochrom> I wonder if it all began with "import Parsec" which was the root cause and could be simply fixed with "import Text.Parsec".
15:30:25 <boxscape> huh
15:30:36 <monochrom> parsec comes with GHC so any "runhaskell doesn't have parsec" is very strange.
15:31:56 <boxscape> oh, whoops - I thought it was only part of the packages needed to build ghc, didn't know it was shipped with it
15:32:25 <monochrom> freeman42x[m]: Yes, but have you also considered doing e.g. a "f = filter" header so you don't have to spell out the full "filter" in case you use it twice?
15:32:52 <monochrom> I think GHC itself doesn't use parsec at all.
15:33:01 <boxscape> oh, right, it uses happy and alex
15:33:30 <monochrom> I don't know why they included it but one day I woke up and found a new GHC version that started including it.
15:34:19 <monochrom> While before and after that, they certainly dropped a few other libraries.
15:34:24 <boxscape> though interesting that "parsec" apparently has a hidden module called "Parsec" (without Text.)
15:35:41 * hackage math-programming-glpk 0.4.1 - A GLPK backend to the math-programming library.  https://hackage.haskell.org/package/math-programming-glpk-0.4.1 (prsteele)
15:35:57 <boxscape> er that's wrong
15:36:05 <boxscape> it's a hidden module, not a hidden package
15:36:11 <boxscape> er
15:36:18 <boxscape> hidden package, not hidden module
15:39:23 <ADG> Hello I am trying to merge infinite infinite lists [[a]]
15:39:45 <ADG> This is my merge function:
15:39:47 <ADG> merge :: Ord a => [a] -> [a] -> [a]merge xs [] = xsmerge [] ys = ysmerge (x : xs) (y : ys)  | x <= y    = x : merge xs (y : ys)  | otherwise = y : merge (x : xs) ys
15:40:07 <monochrom> What does "merge" mean? Could you give a concrete example?
15:40:16 <ADG> as in case of mergesort
15:40:29 <ADG> combining two sorted lists into a single sorted list
15:41:11 <monochrom> That doesn't meaningfully extend from "2 input lists" to "infinitely many input lists".
15:41:51 <monochrom> This is why I asked for a bloody concrete example.
15:42:01 <monochrom> My litmus test for BS.
15:42:12 <ADG> merge [1,3..] [2,4..] = [1,2,3,4..]
15:42:43 <ADG> merge [1,4,6,8] [2,4] = [1,2,4,4,6,8]
15:43:01 <boxscape> are you saying you want to change merge so that it has type [[a]] -> [a] rather than [a] -> [a] -> [a]?
15:43:10 <monochrom> OK so what is "[[a]]" doing there in your opening sentence.
15:43:12 <ADG> I am using foldl1 merge for [[a]]
15:43:47 <ADG> when use take 20, it is stuck in an infinite loop
15:43:50 <ADG> see: https://hastebin.com/afiwevaqar.apache
15:44:22 <monochrom> I mean concrete example for "merge infinite infinite lists [[a]]".
15:45:38 <ADG> ok, here is an example: merge [[2^3, 2^4, ...] , [3^3, 3^4], ...] .... [11^3, 11^4, ...]]
15:46:01 <ADG> so merge :: [a] -> [a] -> [a]
15:46:01 <monochrom> How many lists are there?
15:46:07 <ADG> infinite
15:46:33 <monochrom> Can't be done. One of those undecidable problems.
15:46:33 <ADG> if I can do for two lists I can use foldl1
15:46:52 <monochrom> If you can do 2, you can do 1 million. Still doesn't mean you can do infinite.
15:47:13 <ADG> I mean we can lazily evaluate them and take 20 from init
15:47:16 <monochrom> It's the same question as: I have infinitely many numbers, can you find the minimum in finite time.
15:47:38 <ADG> your reasoning makes sense
15:48:37 <boxscape> ADG let's say the first list starts with 1, and every other list starts with 2. How can you know that in the result, your list should start with [1,2], and that there isn't a list somewhere in the infinite tail that has another 1 that needs to come first?
15:49:04 <boxscape> though I guess that's just a rephrasing of a point already made
15:51:20 <ADG> finite inifinite lists will work then 
15:51:30 <boxscape> seems like they should
15:52:59 <ADG> do you use vscode and hie?
15:53:17 <boxscape> I'm sure some people here do, I don't
15:53:27 <ADG> what do you use as dev env?
15:53:38 <boxscape> I just use vim
15:54:06 <monochrom> https://www.youtube.com/watch?v=FyCYva9DhsI&feature=youtu.be&t=1858
15:57:49 <ADG> i was eventually going to ask any solution to frequent memory leaks from hie and false positive warnings/errors
15:59:38 <boxscape> you could always try ghcide instead of hie but I don't know if it's any better
15:59:52 <ADG> sure thanks
16:00:20 <ADG> so after taking your suggestions I was finally able to get my code working: https://hastebin.com/kecukiruyu.js
16:01:41 <ADG> takes >5mins using -O2 -fllvm
16:01:56 <ADG> I am solving project euler problem #694
16:02:39 <ADG> i have seen people using Data.List.Ordered and getting answer in 30 sec with 5 lines of haskell *wondering*
16:05:30 <c_wraith> are you essentially building a priority-queue seive for it?
16:06:14 <monochrom> I think every time project euler is done in #haskell it is essentially brute-forcing it.
16:06:26 <c_wraith> well, it's sort of the opposite of a seive.  You want to return the numbers caught, not the numbers missed.
16:07:11 <monochrom> Because by selection bias, if someone actually knows a better algorithm, they wouldn't need to come here to ask about code optimization.
16:12:10 <ADG> c_wraith kind of
16:12:38 <ADG> monochrom not most of the times
16:13:34 <ADG> just to be sure i checked his algorithm and he is also using a recursive strategy 
16:14:16 <ADG> instead of my solve he is doing `cfs = 1:(unionAll[unionAll[map (*pp) cfs | pp<-[p^i|i<-[3..]]] |p <- ps])`
16:14:55 <ADG> compared with my `solve (x : xs) = foldl1 merge [ map (* a) rest | a <- as ] where rest = solve xs as = let lp = floor $ (logBase `on` fromIntegral) x n in 1 : [ x ^ k | k <- [3 .. lp] ]`
16:15:51 <ADG> so there has to be a difference in using language constructs
16:42:41 * hackage path-like 0.2.0.1 - PathLike, FileLike and DirLike type classes for the Path library.  https://hackage.haskell.org/package/path-like-0.2.0.1 (locallycompact)
17:02:41 * hackage language-dickinson 0.1.1.1 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-0.1.1.1 (vmchale)
17:40:24 <hololeap> i'm looking for something like `a -> Lens' (a -> b) b` ... anyone know of something like this in the lens library?
17:45:33 <c_wraith> You can have a getter like that, but I don't think that can be a lens - how do you write back into it?
17:45:54 <c_wraith> :t mapped
17:45:56 <lambdabot> (Settable f1, Functor f2) => (a -> f1 b) -> f2 a -> f1 (f2 b)
17:46:49 <c_wraith> ok, that's not relevant.  :)
17:52:30 <hololeap> well, i don't know how to explain it formally, but it seems like if you have an `a' and `a -> b', it's the same as having a `b'
17:53:18 <c_wraith> Well, I guess you could write back into it as long as you have an Eq a constraint.
17:53:30 <c_wraith> But performance will suffer greatly
17:53:54 <dibblego> this is more commonly called Store
17:54:08 <dibblego> data Store a b = Store (a -> b) b
17:54:13 <hololeap> i'm not sure i understand why you would need an Eq a constraint
17:54:30 <dibblego> it is a comonad, and "getting the b" is the extract operation
17:55:18 <hololeap> (Store a) is also a functor, which means you can "set" it... right?
17:55:26 <dibblego> yes, all comonads are functors
17:55:52 <dibblego> actually, I have that definition above wrong
17:55:56 <dibblego> data Store a b = Store (a -> b) a
17:56:09 <c_wraith> ok, that makes it actually apply.  I was wondering
17:56:25 <dibblego> sorry
17:56:42 <dibblego> lens can be written in terms of Store
17:56:51 <dibblego> data Lens a b = a -> Store b a
17:57:30 <superstar64> https://hackage.haskell.org/package/comonad-5.0.6/docs/Control-Comonad-Store.html#t:Store
17:59:00 <hololeap> i have a structure like `newtype Foo m = Foo { _foo :: Bar -> m Baz }` and i want to operate on `m Baz` with a lens
17:59:19 <hololeap> given that i have a Bar
18:00:13 <dibblego> that would be fmap/(>>=) if you parameterised it
18:00:38 <dibblego> newtype Foo m baz = Foo { _foo :: Bar -> m baz }; instance Functor m => Functor (Foo m); instance Monad m => Monad (Foo m)
18:01:18 <hololeap> and then i could just use `mapped` ?
18:01:28 <dibblego> just fmap will do
18:01:44 <hololeap> i'm specifically looking for something in the lens library
18:01:57 <hololeap> it's fine if it doesn't exist... but that would be the most convenient for me
18:02:06 <dibblego> can you perhaps write out the code without lens i.e. how you are using it, then go from there?
18:03:19 <hololeap> i wrote a Getter for my specific use case:
18:03:22 <hololeap> getApply :: Contravariant f => a -> LensLike' f (a -> b) b
18:03:30 <hololeap> getApply a = to ($ a)
18:04:08 <hololeap> but this seems like something i will run into in the future, and i may want to be able to set `b' as well
18:05:02 <hololeap> dibblego: i could write it without using lenses, but being able to compose them is sooo convenient
18:05:21 <dibblego> I understand, but it's unclear (to me at least), how your setter will work.
18:09:12 <c_wraith> still think it needs an Eq a constraint
18:13:07 <hololeap> something along the lines of (\s a -> a <$ s)
18:14:49 <c_wraith> Hmm.  I suppose that replaces the function with const a
18:15:00 <c_wraith> If you're willing to do that, sure.
18:15:39 <hololeap> meh... this seemed to make sense in my head, but now i'm not so sure
18:15:48 <dibblego> :)
18:16:41 <xsperry> @hoogle Monad m => m Bool -> m () -> m ()
18:16:42 <lambdabot> Control.Monad.Extra whenM :: Monad m => m Bool -> m () -> m ()
18:16:42 <lambdabot> Control.Monad.Extra unlessM :: Monad m => m Bool -> m () -> m ()
18:16:42 <lambdabot> Extra whenM :: Monad m => m Bool -> m () -> m ()
18:16:51 <xsperry> is there something like this in base?
18:17:19 <hololeap> just `when`
18:17:58 <c_wraith> there was an m on the Bool
18:18:03 <xsperry> yes
18:18:29 <hololeap> that's the closest thing that exists in base
18:18:34 <hololeap> that i know of
18:18:35 <dibblego> @type liftA2 bool
18:18:36 <lambdabot> Applicative f => f a -> f a -> f (Bool -> a)
18:18:43 <dibblego> @type liftA3 bool
18:18:45 <lambdabot> Applicative f => f d -> f d -> f Bool -> f d
18:19:04 <xsperry> @type liftA3 when
18:19:05 <lambdabot> Applicative f => f Bool -> f (c -> ()) -> f c -> f ()
18:19:15 <dibblego> >>= with when
18:19:25 <c_wraith> :t (. flip when) . (>>=)  -- isn't it pretty?
18:19:26 <lambdabot> Monad f => f Bool -> f () -> f ()
18:20:09 <int-e> sections of (.) are never pretty.
18:21:02 <int-e> (and using `flip` is usually a bad sign too)
18:21:15 <hololeap> :t \mb f -> mb >>= (\b -> when b f)
18:21:16 <lambdabot> Monad m => m Bool -> m () -> m ()
18:21:53 <hololeap> easy to write in do notation as well
18:23:43 <superstar64> there really should be a version of `bool` that takes the boolean argument first
18:25:17 <dibblego> disagree :)
18:32:20 <OmegaDoug> What's the easiest way to use c-libraries.
18:32:46 <OmegaDoug> I've seen inline-c and a C/FFI
18:33:32 <ja> OmegaDoug: i like hsc2hs
18:34:32 <ja> i am not sure what the advantage of inline-c is supposed to be if you're making bindings
18:34:46 <ja> for example, you'd wanna test the headers independently of haskell
18:34:57 <ja> if the headers are inline, that wouldn't work
18:35:09 <OmegaDoug> I haven't seen hsc2hs before. That's a new one.
18:35:23 <ja> it's somehow half built in to cabal 
18:35:34 <ja> at least, cabal automatically knows how to build those files, which is convenient
18:35:55 <ja> i just use it so that i don't have to hard code sizes
18:36:10 <ja> somebody in this channel told me to use it but i can't remember who...
18:38:05 <OmegaDoug> This is new territory for me so I'm not sure of the pros/cons of each approach. I'd naturally prefer the approach that won't make me pull my hair out. 
18:38:36 <ja> maybe just start with raw FFI, that is the minimal approach i'd say
18:39:06 <ja> when you start implementing Storable, you'll need to implement alignment and sizeOf, that's where hsc came in handy for me
18:41:11 <OmegaDoug> Ok. I'll look into that first and see how it looks. It'll be well-documented which is a point in its favour
18:41:15 <ja> all my stuff is just foreign declarations and storage instances. then you can make some 'pure' wrappers in haskell using unsafePerformIO (ooh, i said a dirty word!) and peek/poke, alloca. and there are some functions in Data.ByteString to read from Ptr to ByteString
18:44:34 <ja> oh, and if you wanna pass your foreign things around between functions, you'll need ForeignPtr, which you can construct so that it automatically frees the C struct when GHC thinks its time
18:44:48 <ja> i thought that was pretty neat, kinda like __del__ in python
18:45:38 <superstar64> FFI is one of the main reasons I'm not that big of a fan of garbage collection
18:46:34 <dsal> That seems backwards.  Collecting garbages is one of the reasons I don't like doing FFI.  :)
18:46:41 <dsal> that and it's not very safe and there's call overhead.
18:47:02 <dsal> And some degree of impedance mismatch.  But when you need it, it's pretty nice.
18:47:03 <ja> garbage collection likes to own things, why is that so bad? if you're writing python FFI stuff that crashes in a non-reference counted runtime, isn't that a problem with your bindings in the end?
18:48:02 <dsal> Things aren't meant be owned.  Memory is meant to be free!
18:50:03 <superstar64> It's every language that has garbage collection can't bind with other garbage collected languages
18:50:10 <superstar64> unless they share a garbage collector
18:50:37 <superstar64> I want languages to play nicer which each other
18:50:50 <ja> i am writing haskell bindings for a go library right now :P i made it work by declaring c structs and having go copy into them, and then haskell can read from there :D
18:51:17 <superstar64> hope you don't corrupt memory
18:52:04 <ja> i have "ld-options: -fsanitize=address" in my cabal file ;)
18:53:02 <hololeap> wait... impedance mismatch?
18:53:29 <int-e> superstar64: Java, Scala, Kotlin
18:53:55 <superstar64> ok, jvm is a special case of a bunch of languages sharing a garbage collector
18:54:05 <superstar64> and there's eta too
18:54:29 <safinaskar> i see cool animations on home page of liquid haskell: https://ucsd-progsys.github.io/liquidhaskell-blog/
18:54:34 <int-e> superstar64: More abstractly, GC and mutation (computation) tend to be intimately coupled and have language-specific trade-offs, so unless you target a common JVM I don't see how several languages would end up being compatible on that level.
18:54:39 <safinaskar> what is this IDE?
18:54:56 <int-e> superstar64: Oops, I meant to type "VM".
18:55:09 <safinaskar> liquid haskell installation guide suggests installing configs for vim and emacs
18:55:16 <safinaskar> so that animations from vim or emacs?
18:55:35 <Axman6> you might find mu vm interesting, it aims to provide something which is more like LLVM as a target for language implementers, but can provide infrastructure like the GC and threads (IIRC) to the language so they don't need to be reimplemented by each language
18:56:08 <superstar64> i want my own language to not have a garbage collector, similar to rust
18:58:25 <hololeap> "LH checks that functions terminate"... whoa
18:58:58 <hololeap> impossibru!
18:58:59 <superstar64> how are liquid types different from dependent types?
18:59:18 <int-e> superstar64: And lazy evaluation is a particularly niche case with its update-at-most once type of mutation.
18:59:52 <xsperry> that's not mutation, that's initialization
19:00:17 <dolio> No, it's mutation.
19:00:31 <xsperry> what was the initial value, then?
19:00:39 <superstar64> Can't you still have things be lazy if everything is linear?
19:00:48 <superstar64> *without gc
19:00:49 <dolio> The information on what computation should be run.
19:00:50 <int-e> There's pure, strict languages which require just initialization. There's lazy evaluation where you have at most one update. And then there's the mutating languages which update all over the place.
19:01:21 <xsperry> dolio, that's implementation detail
19:01:37 <int-e> Reconciling all three in a single GC framework is going to hurt two of the three ;)
19:02:02 <xsperry> mutation happens in implementation, replacing pointer to thunk with a value, but it does not happen at haskell level
19:02:08 <ezzieyguywuf> is it "safe" to putStrLn in a forkIO thread?
19:02:10 <dolio> We're talking about implementation details.
19:02:14 <superstar64> Another point against garbage collection
19:02:26 <int-e> xsperry: It's more than that. It allows Haskell implementations to turn  let xs = 1:xs in xs  into a proper cyclic list at runtime, something that strict pure languages cannot accomplish.
19:02:58 <xsperry> int-e right. I still wouldn't call it mutation
19:03:27 <int-e> I think I stressed the fact that there's at most one update enough in what I wrote.
19:06:03 <superstar64> do you guys think haskell's type system will ever get fancy enough that we can write things without garbage collection?
19:06:29 <int-e> (Oh, it's not just the update-at-most one that's special. It's also that purity allows some liberties with read and write barriers.)
19:06:30 <dolio> No.
19:06:41 <superstar64> haskell already has unboxed types
19:06:50 <superstar64> and linear types are in the works
19:07:19 <superstar64> all we need now is rust's borrowing
19:07:44 <ja> how many languages do you wanna stuff into this syntax? ;)
19:07:47 <int-e> lazy evaluation severely restricts what you can accomplish by local reasoning.
19:08:08 <int-e> computations are suspended and leave their originating scope all the time
19:08:23 <superstar64> i'm sure there exist typing rules that solve this
19:09:05 <xsperry> I'm not sure what's the to solve. I'd guess most people who use haskell like the fact that it has GC, and that they don't have to worry about memory management, or objects lifetime
19:09:21 <int-e> If you make a pure, strict language, you might get somewhere.
19:09:26 <ja> it seems like hardly a day goes by without somebody wishing haskell wasn't lazy, i don't get it! it started out lazy, it has always been lazy, there is no indication that it will stop being lazy 
19:09:34 <superstar64> that's what my goal is int-e
19:09:45 <c_wraith> Laziness is so good.
19:09:58 <c_wraith> I don't understand why people write such bad code in order to dodge its benefits
19:10:00 <int-e> Well it won't be Haskell.
19:10:02 <superstar64> https://github.com/Superstar64/aith/ need to get around to rewriting this in haskell eventually
19:10:43 <int-e> Laziness is great... but also kind of expensive, and sometimes hard to reign in.
19:10:58 <int-e> rein
19:11:10 <superstar64> i kinda wanna learn rust so i can model lazyness in it
19:11:36 <c_wraith> you really can't
19:11:51 <c_wraith> the borrowing system prevents most uses of it
19:11:53 <ja> superstar64: or you can just use Idris, where there is some Lazy type constructor , iirc
19:12:12 <superstar64> doesn't idris also use garbage collection?
19:12:24 <dolio> Yeah, it's a good language. :P
19:12:32 <ja> it compiles to scheme, so it depends on your scheme implementation :)
19:12:36 <Shadorain> test
19:12:41 <Shadorain> WOAH it works!
19:12:49 <ja> No such command or file name
19:12:55 <superstar64> Shadorain try it again, i'm not sure it worked
19:12:59 <Shadorain> ;)
19:13:02 <dolio> Is there a scheme that doesn't use garbage collection?
19:13:12 <MarcelineVQ> the current targets of idris2 have garbage collection
19:13:13 <Shadorain> sorry sorry first time on irc, dont know the ins and outs yet
19:13:50 <Shadorain> yall use xmonad?
19:13:52 <int-e> And here I thought we were finally beyond the point where we considered GC to be a problem... outside of small systems and real time applications.
19:14:04 <superstar64> https://dl.acm.org/doi/abs/10.1145/142137.142162
19:14:33 <dolio> That's not a scheme implementation.
19:14:59 <int-e> "it occupies a twilight zone between functional languages and imperative languages"
19:15:23 <superstar64> that's kinda the goal with my language too
19:16:03 <xsperry> Shadorain, hi. some of us do. there's also a specific channel for xmonad, #xmonad
19:16:07 <superstar64> int-e, i also don't like garbage collection's non determinism and the extra memory usage
19:16:15 <Shadorain> oh cool thats prob what im lookin for
19:16:22 <Shadorain> much appreciated man
19:16:28 <xsperry> type /join #xmonad
19:16:32 <Shadorain> but ima stick around here too for some haskell
19:16:37 <Shadorain> cuz im looking to learn it 
19:17:19 <xsperry> yeah go ahead. don't know what's your irc client, but they can all be in more than one channel at once
19:17:35 <Shadorain> im on irssi
19:17:48 <Shadorain> i think its called like window splits or something
19:17:56 <Shadorain> guess like vim 
19:18:43 <ja> you can use Alt-Left/Right or Alt-0123456789
19:19:36 <Shadorain> ooh ur right!
19:19:40 <Shadorain> thanks man :D
19:19:55 <Shadorain> irc is really cool, wish i checked it out before :/
19:20:13 <spiderbubble> Can someone point me in the right direction for representing this Swift code in Haskell? https://hastebin.com/adujeqitoc.cs
19:20:16 <spiderbubble> So far this is what Iâ€™ve come up with, but itâ€™s bugged https://hastebin.com/xafuxezuqe.sql. Initially I thought I could get away with using zip for looking at entries, but that obviously only works with pairs. Not sure how to write this without mutability as done in the Swift version
19:20:40 <spiderbubble> Background: attempting to make a contribution to a tool written in Haskell - no prior Haskell experience
19:21:17 <ja> spiderbubble: so the issue is with the groupMatchers function?
19:21:21 <superstar64> why does hastebin always get the language wrong
19:21:57 <spiderbubble> ja: yeah
19:22:42 <spiderbubble> Oh, the comment is out of date. The output actually isn't right for the haskell version
19:23:47 <ja> how can the output be incorrect if the haskell version doesn't exist yet?
19:24:05 <spiderbubble> https://hastebin.com/enabaqurag.sql
19:24:49 <ja> spiderbubble: what does & mean in the comment? FieldMatcher And?
19:24:53 <spiderbubble> I wrote a draft that doesn't work quite right yet
19:26:23 <spiderbubble> ja: It means that it has an `And` prefix, yeah. That's the syntax in the tool I'm contributing to
19:27:58 <ja> it is not clear to me what your current problem is. does the code type check currently?
19:28:00 <spiderbubble> This example could probably be narrowed down a bit
19:28:02 <spiderbubble> Yes
19:28:15 <ja> it type checks, but it returns the wrong result?
19:29:59 <spiderbubble> Yeah, this is the output of the haskell version: `[["A","B"],["C"],["D"],["D","E"]]` ("D" is included twice)
19:31:30 <spiderbubble> But more importantly, it won't work for joined entries with counts greater than 2, e.g. `A & B & C`
19:32:21 <ja> if you remove A B and C from that example, is it still broken?
19:32:29 <spiderbubble> The swift version does since it iterates over the array and mutates the prior result, but not sure how to do the equivalent of that in haskell
19:33:22 <spiderbubble> ja: yes
19:34:10 <ja> if i remove A, B and C, I get [["D"],["E"]]. the correct result would be [["D","E"]]?
19:36:11 <spiderbubble> ja: I get `[["D", "E"]]` when I run it, which is correct
19:36:42 <ja> but you just claimed before that it was still broken
19:37:19 <falconair> hi, I'm setting up my windows laptop for Haskell. According to official instructions, I did 'choco install haskell-dev' but that doesn't seem to have install stack. I thought it did. Apparently I need stack to get VS Code configured. Ideas?
19:37:21 <spiderbubble> Oh sorry I misread. No, that example works
19:37:32 <ja> when i removed A, B, C, i did that by removing the first three items in 'matchers'
19:38:12 <spiderbubble> Yeah, that should work. Is there an online haskell repl somewhere we can paste into?
19:38:39 <justsomeguy> falconair: I've had success installing stack, directly, without choco. https://docs.haskellstack.org/en/stable/README/#how-to-install
19:39:06 <spiderbubble> https://repl.it/repls/ImpassionedFrenchMining
19:39:07 <ja> spiderbubble: https://repl.it/languages/haskell
19:39:41 <falconair> justsomeguy I was hoping to follow official instructions as closely as possible. I'll just do a manual install.
19:39:46 <falconair> thx
19:39:48 <ja> spiderbubble: if you have some state, you can often turn that state into an argument of a recursive helper function
19:40:24 <Shadorain> haskell is in theory a "compiled" language am i right? i know there is an interactive ability but in essence it is compiled i think right?
19:40:38 <ja> so you could make groupMatchers call a helper function that has an extra argument, that stores the state that you wanna save from 'iteration' to 'iteration' (in recursion you may not wanna call it iteration)
19:41:23 <ja> Shadorain: i don't know what you mean by 'in essense', but ghci interprets, otherwise it is compiled, yes
19:41:37 <Shadorain> ok thats what i was trying to get at
19:41:45 <Shadorain> good i dont like int langs
19:41:58 <Shadorain> cuz im a weirdo :joy: dont ask me my reasoning lols
19:42:08 <Shadorain> crap this isnt discord
19:42:08 <ja> shallow! it's not so black and white
19:42:25 <Shadorain> hehe im just an extremist in most cases
19:43:00 <Axman6> GHC produces genuine compiled code
19:43:03 <Shadorain> anyone use haskell on linux?
19:43:11 <ja> yahb does
19:43:14 <Shadorain> Axman6 yeh thats what i thought
19:43:22 <Shadorain> yahb: good man good man
19:43:28 <ja> % readFile "/proc/self/cmdline" -- hehe
19:43:29 <yahb> ja: "/srv/sandbox/root/usr/lib/ghc-8.10.1/bin/ghc\NUL-B/srv/sandbox/root/usr/lib/ghc-8.10.1\NUL--interactive\NUL-v0\NUL-ghci-script\NUL/srv/sandbox/root/usr/lib/run/ghci-init\NUL-tmpdir\NUL/srv/sandbox/root/data/tmp/\NUL-odir\NUL/srv/sandbox/root/data/tmp/\NUL-hidir\NUL/srv/sandbox/root/data/tmp/\NUL-ignore-dot-ghci\NUL+RTS\NUL-M200M\NUL-V0\NUL-C0\NUL-K100M\NUL"
19:43:35 <Shadorain> was wondering if u use vim as well? @yahb
19:43:48 <ja> Shadorain: yahb only speaks haskell
19:43:48 <dsal> I don't think yahb uses vim.
19:43:51 <justsomeguy> What's your question, Shadorain?
19:43:55 <spiderbubble> ja: hm ok, will have to wrap my head around how on earth to do that here ha
19:44:02 <Axman6> % 3^2748
19:44:02 <yahb> Axman6: 1346504997546749053947577869358871974503126448542153312226405060659949109528707433241728487222070647797175559489027698132981611960320289042149266155207630732924276341078335310201751254918874478894254529080327469820095986422873386578733696343918970647227871102543278964527929033179820138539553299845070225786558393002958472337134398379376715005614959676514420199936130904190486967765353762745941831144
19:44:06 <dsal> I do all my haskell in emacs.
19:44:07 <Shadorain> aw man, just would like to find a good LSP for it
19:44:12 <parsnip> bare minimum RAM for cabal new-install hledger-iadd?
19:44:32 <Shadorain> oh noice, i am going to move a lil into emacs soon once my xmonad is more setup
19:45:17 <justsomeguy> Shadorain: I installed the coc plugin, hlint, and ghcide. I didn't even intent for it to work together, but it did.
19:45:18 <Axman6> VS Code support for Haskell is getting really good
19:45:36 <Shadorain> emacs have a good lsp for haskell? @dsal
19:45:44 <dsal> I don't use an LSP, though.
19:46:00 <Shadorain> @justsomeguy, oh i couldnt find one in coc? oh thats all for vim??
19:46:00 <lambdabot> Unknown command, try @list
19:46:35 <spiderbubble> Shadorain: there's lsp-mode and eglot
19:46:37 <Shadorain> @dsal oh gotcha, yeh i dont as of now cuz i dont have one :joy: for haskell i mean
19:46:38 <lambdabot> Maybe you meant: keal eval
19:46:40 <justsomeguy> Shadorain: Right, it's for vim. I think that ghcide provided a LSP, and coc automatically detected it and used it. Same thing for hlint.
19:46:54 <Shadorain> oh baby ima have to check those out
19:47:00 <Shadorain> guess i didnt do enough digging!
19:47:15 <ja> spiderbubble: i think list comprehensions can be a bit terse since you are just beginning. without list comprehensions, you are forced to give things a name, and you can give them a descriptive name. that can help your thinking
19:48:48 <ja> spiderbubble: maybe i am stupid, but i didn't really understand your code, and you must only be asking here because you don't understand it yourself either. so break it down, make it more stupid, make some test cases
19:49:33 <ja> i know that changing the syntax will not fix your problem, it is just a sign that triggered me ;)
19:51:09 <spiderbubble> ja: did you understand the swift version?
19:51:23 <ja> never did swift, so no :O
19:51:49 <spiderbubble> ha fair enough
19:52:36 <ja> spiderbubble: but the "result[result.endIndex - 1]" is easy to do in haskell. you can match on the result of the recursive call
19:53:04 <ja> oh wait, i meant "result.last"
19:53:26 <spiderbubble> including assigning to that result?
19:54:09 <ja> no no, the assignment of course wouldn't be appropriate for you to do in haskell since it would use state and the point of the exercise is to learn to do it without mutating state
19:55:09 <ja> i am just trying to give you some hints, like, you can construct the list in reverse order. so when you do result.append(x) in swift, that can be "x : recursiveCall ..." in haskell
19:56:30 <spiderbubble> yeah constructing it in reverse might make sense. thanks for the pointers
19:56:48 <ja> and then, because it is in reverse order, result.last becomes "case recursiveCall ... of | x:_ -> ... | _ -> error "i expected an element in the recursive call""
19:57:28 <ja> i think i saw an incomplete pattern match in your code too, that is a code smell too, it would be better to explicitly have a catch all with an error call like i just have shown
19:57:53 <ja> and then you refactor the types to make that situation impossible
20:07:11 <dsal> Shadorain: I didn't notice you had code there.  I don't quite understand what you're trying to do with `groupedMatchers`, but it looks pretty complicated.  heh
20:07:24 <dsal> e.g., what is the `do` block for?
20:08:50 <ja> dsal: do you not mean to talk to spiderbubble?
20:08:59 <fresheyeball> so I am going to impliment overlays for node2nix
20:09:11 <dsal> ja, spiderbubble oh yeah, too many s names. heh
20:09:17 <fresheyeball> I recall there was an article on the overlay pattern that included it's defintion
20:09:18 <dsal> Sorry, Shadorain 
20:09:28 <fresheyeball> anyone know where I could find it?
20:09:51 <Shadorain> dsal: lol sorry for what 
20:11:23 <spiderbubble> dsal: the idea i'm trying to express is: iterate over each matcher and combine any that are marked as `&`
20:11:32 <spiderbubble> as `And`*
20:12:19 <Shadorain> dsal: oh i see i see hahah no need to be sorry, its hard to read all this text well
20:12:42 <spiderbubble> the `do` block doesn't do that correctly, though, was just my first attempt/draft
20:14:23 <dsal> spiderbubble: The core of what you're doing is `groupBy`
20:15:03 <dsal> > groupBy (==) "ABBBCDEFGHHI"
20:15:05 <lambdabot>  ["A","BBB","C","D","E","F","G","HH","I"]
20:15:58 <dsal> Not that there's anything wrong with implementing it yourself.
20:16:09 <dsal> @src groupBy
20:16:09 <lambdabot> groupBy _  []     = []
20:16:09 <lambdabot> groupBy eq (x:xs) = (x:ys) : groupBy eq zs
20:16:09 <lambdabot>     where (ys, zs) = span (eq x) xs
20:19:45 <ja> what is an elegant way in haskell to express binary trees where you can go up/down?
20:20:25 <ja> currently i have them in an arrow with functions that calculate indices for parent/children, but i thought i'd like to have some richer types and use optics and shit
20:21:04 <Axman6> sounds like zippers to me
20:21:25 <Axman6> which you can get for free if you have optics
20:21:29 <ja> oh, i meant "array" instead of "arrow"
20:21:55 <ja> Axman6: so you're saying i should just implement some optics for my existing datatype?
20:22:08 <dsal> Is it traversable already?
20:22:23 <Shadorain> oh idk if i can scroll up :E
20:22:36 <ja> dsal: no, not yet
20:23:03 <dsal> You get a lot of stuff for free by implementing a few typeclasses 
20:23:05 <spiderbubble> dsal: thanks! that's really close, only in my example the equality test isn't associative, e.g. `[None "A", And "B", None "C"]` becomes `[["A", "B"], ["C"]]`
20:23:34 <Axman6> https://hackage.haskell.org/package/zippers-0.3/docs/Control-Zipper.html
20:23:47 <ja> yeah, but i just feel like storing binary trees in arrays is so weird in haskell, you always see people having recursive ADT's for it
20:24:20 <ja> Axman6: thanks, i heard about those but never checked it out. will read now
20:24:32 <dsal> Graphs are often arrays
20:25:10 <Axman6> I've never actually had a need for the sippers package, but what you're describing sounds like it's exactly what you want
20:25:21 <spiderbubble> @src span
20:25:21 <lambdabot> span _ xs@[]                  = (xs, xs)
20:25:21 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
20:25:21 <lambdabot>                   | otherwise = ([],xs)
20:25:55 <ja> dsal: what do you mean by that? arrays can store only one data type, but graphs have nodes and edges. isn't it awkward trying to put them in arrays?
20:26:05 <dsal> For a structure like that, functor, foldable, applicative, and traversable takes care of a lot for you.  There are a couple lens-specific ones I've added, too.
20:26:17 <dsal> ja: check out Data.Graph
20:28:10 <dsal> The first line of span src is kind of weird, but I guess it's consistent.
20:31:52 <spiderbubble> Does `groupBy` work for unsorted lists?
20:33:24 <spiderbubble> n/m, I see now
20:34:05 <Axman6> yes, but it doesn't do what you expect
20:34:31 <Axman6> think of groupby as the run length encoding function, not the SQL group by statement
20:36:48 <dsal> > let m _ (And _) = True; m _ _ = False in groupBy m [None "A", And "B", None "C"]
20:36:49 <lambdabot>  [[None "A",And "B"],[None "C"]]
20:37:30 <Axman6> :(
20:39:34 <dsal> Not sure what we're talking about. Just haskelling on the phone. Heh
20:41:06 <spiderbubble> dsal: how does that code work?
20:41:11 <Axman6> > let m (And _) (And _) = True; m (And _) _ = False; m _ (And _) = False; m _ _ = True in groupBy m [None "A", And "B", None "C"]
20:41:13 <lambdabot>  [[None "A"],[And "B"],[None "C"]]
20:41:20 <spiderbubble> when i run it in my repl it throws an error
20:41:39 <Axman6> > let m (And _) (And _) = True; m (And _) _ = False; m _ (And _) = False; m _ _ = True in groupBy m [None "A", And "B", And "C", None "D", And "E"]
20:41:41 <lambdabot>  [[None "A"],[And "B",And "C"],[None "D"],[And "E"]]
20:42:08 <dsal> spiderbubble: I defined a type to use here based on yours
20:42:37 <Axman6> dsal's being sneaky in the background
20:42:40 <spiderbubble> Where?
20:42:43 <spiderbubble> Oh, hah
20:42:47 <Axman6> :t And
20:42:48 <lambdabot> a -> Thing a
20:42:51 <dsal> > let val (None x) = x; val (And x) = x; m _ (And _) = True; m _ _ = False in fmap val <$> groupBy m [None "A", And "B", None "C", And "D"]
20:42:53 <lambdabot>  [["A","B"],["C","D"]]
20:42:59 <Axman6> @src Thing -- probably won't work
20:42:59 <lambdabot> Source not found. Whoa.
20:43:06 <dsal> (I couldn't remember what it was called)
20:43:40 <dsal> I also don't know the desired semantics. Just looking at example input and output
20:44:51 <ja> spiderbubble: to use multi-line statements in ghci, you can use {: and then end with :}
20:45:16 <dsal> You don't end with :}, you end with regrets
20:45:54 <ja> with a tiny beard like that you have regrets already :P
20:46:15 <dsal> Can't be that much worse than using lambdabot as a ghci from my phone's irc client
20:48:55 <spiderbubble> dsal: what is let doing in this example? defining a function?
20:51:15 <fresheyeball> ok so I used makeOverridable to get it going atleast
20:51:26 <fresheyeball> and... it's not overriding
20:52:20 <fresheyeball> https://hastebin.com/bomaqicoga.bash
20:52:24 <fresheyeball> here is the relevant bit
20:58:30 <dsal> spiderbubble: let names a thing. The thing I'm naming is a function, yeah.
20:59:23 <dsal> You had a top-level function for what I called "val", but it was easier to write `m` as a named function than lambda
21:03:52 <spiderbubble> What does this error mean? `Expected kind `* -> *', but `Matcher' has kind `*'`
21:03:53 <spiderbubble> https://repl.it/repls/BitterDisloyalEditor
21:04:22 <c_wraith> It means you typo'd the type signature on line 20
21:04:44 <c_wraith> By writing "Matcher Matcher -> Bool", you made it expect a higher-kinded type.
21:05:52 <fresheyeball> oh I sorta see the problem
21:06:10 <spiderbubble> c_wraith: what's the typo?
21:06:28 <c_wraith> it should just be Matcher -> Bool
21:06:42 * hackage vulkan 3.6 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.6 (jophish)
21:06:57 <c_wraith> oh, no
21:07:04 <c_wraith> It should be Matcher -> Matcher -> Bool
21:07:16 <c_wraith> Missed the argument count you had there
21:07:19 <spiderbubble> Ahh
21:07:42 * hackage VulkanMemoryAllocator 0.3.4 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.4 (jophish)
21:15:14 <spiderbubble> Wait so it's just this? https://hastebin.com/bulezoqebu.sql
21:15:56 <spiderbubble> That's .. a lot more elegant than expected :)
21:16:15 <c_wraith> I don't trust that use of groupBy
21:16:37 <spiderbubble> c_wraith: how so?
21:16:54 <c_wraith> It's only required to work correctly when the function you give it describes an equivalence relation
21:18:01 <spiderbubble> oh, like irrespective of order?
21:18:38 <c_wraith> The implementation isn't malicious of course, and does something predictable.  It's just that you're technically only using it correctly if the function is reflexive, transitive, and commutative
21:19:01 <c_wraith> None of which are possible with that implementation as it only ever looks at one of its arguments
21:25:31 <spiderbubble> Good point, I see that here now https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Eq.html#t:Eq
21:26:12 * hackage mutable 0.2.0.0 - Automatic piecewise-mutable references for your types  https://hackage.haskell.org/package/mutable-0.2.0.0 (jle)
21:34:52 <spiderbubble> c_wraith: how would you go about implementing this then? redefine `groupBy`?
21:36:22 <c_wraith> Given the way you're using it, you don't need all of its power anyway.  You could probably write something that does the job you need more precisely.
21:37:39 <dsal> spiderbubble: `do` doesn't mean whatever you think it means.  :)
21:39:25 <dsal> spiderbubble: e.g., it doesn't do anything in matcherPrefix, but the case is also unnecessary there. https://www.irccloud.com/pastebin/N1R2N7Mn/matcherPrefix.hs
21:42:48 <dsal> But you should remove it from the places you're using it, because it doesn't do anything.
21:43:52 <spiderbubble> Oh ha
21:44:42 * hackage file-embed 0.0.13.0 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-0.0.13.0 (MichaelSnoyman)
21:45:41 * hackage yesod-static 1.6.1.0 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.6.1.0 (MichaelSnoyman)
21:46:35 <spiderbubble> Yeah I have no idea what I'm doing here. Was slowly working through the haskell book but attempting this contribution just jumped me straight to the last chapter lol
21:47:10 <dsal> `do` is syntax sugar for monading
21:47:20 <dsal> @undo do {a; b; c}
21:47:20 <lambdabot> a >> b >> c
21:47:24 <dsal> @undo do a
21:50:21 <hololeap> haha u broke it
21:50:30 <spiderbubble> Yeah I'm still at the "don't understand what a monad is" level of haskell
21:53:06 <c_wraith> that's fine.  It's not an obstacle to learning :)
21:53:13 <hololeap> it's a type class that requires one function, (>>=) :: Monad m => m a -> (a -> m b) -> m b, and some laws also need to hold
21:56:14 <hololeap> and `return :: a -> m a` needs to be defined as well, but that responsibility gets taken on by Applicative with the `pure` functio
21:58:03 <hololeap> spiderbubble: have you looked at the wiki article called Typeclassopedia yet? it might help
22:00:10 <spiderbubble> hololeap: I haven't, thank you
22:11:50 <dminuoso> spiderbubble: There's a generally good approach to typeclasses, they are just *interfaces* (in the sense of traits/concepts/protocols from other languages). For some, like monad, it's difficult to see what it's abstracting over, however, every single particular instance is easy to grasp for even a beginner.
22:15:41 <dminuoso> Understanding monad is mostly useful for people who are writing monad polymorphic code themselves, but as someone who is *using* monad polymorphic code, it's as simple as saying "I want m ~ []", then you can look at how `(>>=) :: [a] -> (a -> [b]) -> [b]` and `return :: a -> [a]` are implemented, then you'd realize that's just "flatMap" or "concatMap" (as some languages call it) and some "put a
22:15:43 <dminuoso> value into a list". You don't even need to care about the other instances.
22:16:35 <dminuoso> With this pattern you quickly arrive at "I dont even care what monad is", and at some experience level you might start looking at all the instances and realize there's some common theme/pattern to what you already know. And then you'd have an "aha" moment.
22:18:53 <dminuoso> We could have gotten away by making all these separate functions `concatMap :: [a] -> (a -> [b]) -> [b]`, `ioThen :: IO a -> (a -> IO b) -> IO b`, `maybeThen :: Maybe a -> (a -> Maybe b) -> Maybe b`, people wouldn't have complained about "understanding what all these are" at all. All we did is put all these into a common typeclass and call those functions (>>=). :)
22:19:51 <liiae> when a type need to be an instance of Applicative or Monad?
22:21:38 <jle`> liiae: the only time you'd 'need' it is if you want to take advantage of a function that someone wrote that works for all Applicative/Monad
22:21:47 <jle`> and you want that type to work for that useful function
22:21:52 <hololeap> that's kind of like asking when a type needs to be an instance of Show... it needs to be an instance of a typeclass when you want the functionality of that typeclass
22:22:41 * hackage project-template 0.2.1.0 - Specify Haskell project templates and generate files  https://hackage.haskell.org/package/project-template-0.2.1.0 (MichaelSnoyman)
22:23:04 <jle`> a really useful function polymorphic over all Applicative, for example, is `replicateM_ :: Applicative f => f a -> f ()`
22:23:07 <jle`> er
22:23:17 <jle`> `replicateM_ :: Applicative f => Int -> f a -> f ()`
22:23:24 <jle`> it just says "do this action n times"
22:23:33 <dminuoso> fsvo of "action"
22:23:36 <jle`> so you can only use that useful function if `f` has an instance of `Applicative`
22:24:47 <liiae> that f couldn't be Functor?
22:24:58 <dminuoso> It has to be Functor if its Applicative
22:25:08 <dminuoso> Or rather, if its Applicative its naturally Functor as well.
22:25:16 <jle`> liiae: well, it depends on the function specifically
22:25:20 <jle`> some functions only work for Applicatives
22:25:25 <jle`> some functions only work for Monads
22:25:27 <jle`> etc.
22:25:28 <dminuoso> liiae: Generally, you could say a type T needs to be an instance of Monad (or equivalently Applicative) if you happen to have/be able to write some functions `a -> T a` and `T a -> (a -> T b) -> T b` following some laws. Whether you actually *implement* that instance or not is up to you.
22:25:47 <dminuoso> If you dont write that instance, the more advanced power users might be annoyed slightly, but fundamentally it doesn't matter.
22:26:05 <jle`> you don't necessarily need to understand the specifics of 'why' necessarily, you just need to know the type signature of that function
22:26:48 <liiae> there're also other typeclasses, why Applicative and Monad are so famous? 
22:26:52 <dibblego> in practice, not writing a Monad instance, when it is otherwise possible, leads to regrets
22:26:58 <dibblego> because they are useful
22:27:08 <dminuoso> Sure, but it's mostly just convenience.
22:27:32 <dibblego> "not repeating work, sometimes a lot of work" is convenience
22:27:35 <liiae> like how I feel Functor, fmap can give me power to access the value in the functor context
22:28:04 <dsal> That's a weird way to look at it.  I don't think of a functor as giving you access to a value in a context.
22:28:13 <dminuoso> liiae: The usefulness of Functor extends that slightly, namely that `fmap can let you manipulate some values inside *without* changing the structure of the thing.
22:28:46 <dibblego> not writing this over and over, when it is otherwise the same function, already done, is why. https://gist.github.com/tonymorris/30b0858bfef81a163041aeb12d118a97
22:29:01 <dminuoso> That last one is described by `fmap id = id` which says "if you fmap with id over the thing, the entirety remains unchanged" - that is, fmap doesn't "add" or "delete" things in some rough sense. If you fmap over a list, the shape of the list remains unchanged.
22:29:24 <jle`> liiae: i think Applicative and Monad do get a lot of undeserved glory/popularity :)
22:29:27 <dminuoso> And that's getting to the core of these abstract typeclasses, its the laws that make them so useful, its being able to reason about what code can do, and what it cant do
22:36:45 <liiae> there's monad transformer, is there functor transformer?
22:36:57 <c_wraith> Doesn't need to be.  Functors compose.
22:37:04 <c_wraith> So there's Data.Functor.Compose
22:37:16 <liiae> but monad doesn't compose
22:37:21 <dminuoso> liiae: That's the point of monad transformers.
22:37:28 <dminuoso> They exist precisley because monads dont compose.
22:37:54 <dminuoso> You cant arbitrarily combine monad effects by composing them.
22:38:08 <hololeap> well, *some* monads compose, but they do not not in general
22:38:11 * hackage hasql-queue 1.2.0.0 - A PostgreSQL backed queue  https://hackage.haskell.org/package/hasql-queue-1.2.0.0 (JonathanFischoff)
22:38:27 <dminuoso> Right, I was trying to hint at that with "arbitrarily" :)
22:38:53 <c_wraith> is there an IdentityT I can use?  :P
22:39:08 <dminuoso> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Identity.html#t:IdentityT
22:39:12 <dminuoso> Jokes on you.
22:39:27 <c_wraith> So it is!
22:40:11 * hackage hasql-queue 1.2.0.1 - A PostgreSQL backed queue  https://hackage.haskell.org/package/hasql-queue-1.2.0.1 (JonathanFischoff)
22:41:25 <ErichHyuuga> Just ate a burger at a sleezy joint
22:41:27 <ErichHyuuga> Now I got to take a shit, get to the point
22:41:29 <ErichHyuuga> Sittin on the toilet, my ass is a blast
22:41:31 <ErichHyuuga> fire smelly diarrhea out of my ass
22:41:32 <ErichHyuuga> no fucking paper
22:41:34 <ErichHyuuga> hey baby lick my ass till your face turns blue!
22:42:28 --- mode: ChanServ set +o dibblego
22:42:30 --- mode: dibblego set +b *!*@li685-54.members.linode.com
22:42:32 --- mode: ChanServ set -o dibblego
22:45:45 <liiae> when I need to operate on `f a` with `(a -> b)` and return `f b`, I should make it as an instance of Functor,
22:46:04 <c_wraith> If you can lawfully.
22:46:12 <liiae> when I need to operate on two `f a` or more, I should make it as instance of Applicative
22:46:52 <liiae> but I don't know when I should make it as instance of Monad
22:47:04 <dsal> When you need an `f a` to operate on `f b` you need applicative.
22:47:14 <fresheyeball> makeOverridable is making no sense
22:47:31 <dsal> :t (>>=) -- you need a monad when you need to do things like this.
22:47:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:47:33 <c_wraith> You make something a Monad if you have a use for >>=.
22:47:46 <c_wraith> ... Or if someone else reports a use for it
22:48:04 <liiae> :t liftA2
22:48:05 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:48:14 <liiae> this is how I can feel Applicative
22:49:03 <liiae> some people said Applicative can'd do that if-else
22:49:09 <dsal> @src liftA2
22:49:09 <lambdabot> liftA2 f a b = f <$> a <*> b
22:49:11 <liiae> Monad can
22:49:20 <liiae> more dynamic
22:49:25 <liiae> flex
22:50:36 <c_wraith> that's captured in the types.
22:50:41 <c_wraith> :t (>>=)
22:50:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:51:00 <c_wraith> :t flip (<*>)
22:51:01 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
22:51:13 <c_wraith> very similar, but different in one key way
22:51:51 <c_wraith> for applicative, the function being applied must be blind to the applicative context.  It's an (a -> b) function inside there.
22:52:03 <c_wraith> for monad, the function is (a -> m b)
22:52:28 <c_wraith> So you get to make decisions about what `m b` value to produce based on the `a` value.
22:52:31 <dibblego> when you have a dependency on the previous action value
22:54:02 <liiae> monad can make `m b` based on `a`, applicative can't?
22:54:22 <dminuoso> liiae: look at the type signatures
22:54:26 <dminuoso> % :t (<*>)
22:54:26 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
22:54:28 <dminuoso> % :t (>>=)
22:54:28 <yahb> dminuoso: Monad m => m a -> (a -> m b) -> m b
22:54:36 <dminuoso> If we dub `m/f` "effects"
22:54:58 <dminuoso> Then with monad you can decide an effect based on the result of an effect (a -> m b)
22:55:00 <dminuoso> With applicative you cant.
22:55:31 <dminuoso> I think the confusing part is that Applicative and Monad are largely orthogonal.
22:55:53 <dminuoso> It just so happens that Monads induce lawful Applicative instances.
22:58:51 <dminuoso> (And then the Applicative has the monad effects, so this might give the impression that Applicative and Monad are similar)
23:01:12 <hololeap> another way to think about it is that Applicative allows you to combine multiple effects
23:01:31 <hololeap> :t \fa fb -> (,) <$> fa <*> fb
23:01:32 <lambdabot> Applicative f => f a1 -> f a2 -> f (a1, a2)
23:01:56 <hololeap> and gives a way to lift something into a default "effectless" effect
23:01:58 <hololeap> :t pure
23:01:59 <lambdabot> Applicative f => a -> f a
23:02:40 <hololeap> while Monad allows you to take a "double-wrapped effect" and make it into a regular effect
23:02:45 <hololeap> :t (>>= id)
23:02:46 <lambdabot> Monad m => m (m b) -> m b
23:03:05 <dminuoso> I like to think of monads as being about "sequencing" and applicatives as being about "branching off and joining together in a diamond"
23:03:27 <dminuoso> (The fact that you get sequencing in applicatives can be imagined by "sequencing the left and right branches of the diamond onto each other, somewhat senselessly"
23:03:33 <c_wraith> I like to think of them as being about what their types and laws do.  :P
23:03:37 <dibblego> Functor does liftA1, Applicative does liftA[0..N], Monad does (<=<)
23:03:51 <dminuoso> c_wraith: well there's some pretty deep reasons for my mind model, they are not based on "what instances commonly do"
23:04:13 <dminuoso> The sequencing of monads is embedded deep in the theory
23:04:14 <c_wraith> I didn't say instances!  Instances are very limited.
23:04:46 <Cale> The Applicative operations are often just as much about sequencing as the Monad operations are though.
23:04:53 <liiae> dminuoso: "dynamic sequencing" "static sequencing"?
23:05:05 <Cale> Though I suppose in the case of (>>=), there's essentially no way to cheat
23:05:22 <dminuoso> Cale: Right, but they are usually just sequencing for no reason other than "being the monad (sequencing) induced instance"
23:05:34 <dibblego> liiae: have you ever used do-notation?
23:06:02 <dminuoso> liiae: That's definitely one way to think about it.
23:06:48 <dminuoso> liiae: There's actually work being done on parsers using selective functors (you can think of it as mix between monad and applicative) which have *decidability* of effects but statically analyzable
23:07:03 <liiae> dibblego: yes
23:07:22 <dibblego> liiae: have you ever used a value that was named on the left of <- on the right of <- ?
23:07:45 <liiae> dibblego: sorry, I don't understand
23:08:01 <liiae> do a <- Just 3?
23:08:18 <dibblego> do a <- x; b <- f a; ... -- here, a is named on the left of <- and then used on the right of <- in the following expression
23:08:32 <liiae> yeah?
23:08:35 <dminuoso> select :: Selective f => f (Either a b) -> f (a -> b) -> f b 
23:08:47 <dibblego> liiae: you needed monad for that, applicative is not enough
23:08:51 <dminuoso> Can you see how this is a mix between Monad and Applicative? :)
23:09:15 <dminuoso> (The idea is, the first effect can produce Left or Right, and if its a *Left* then the second effect is run)
23:09:41 <dminuoso> So you have sort of "dynamic" decidability which effects should be run, but statically analyzable (since you can just look at the tree and combine all the possible effects)
23:09:49 <liiae> dibblego: "do a <- x; b <- f a; ... -- here, a is named on the left of <- and then used on the right of <- in the following expression" that sounds like let* in scheme
23:10:14 <dibblego> not really, you just had a dependency
23:10:30 <rand809809> Hi, I have a bunch of parsers I wrote using megaparsec here https://gist.github.com/bananabrick/1bd000b9188314a69e38fbe6ca30ad74. I want to fail the variable parser when the variable is a some keyword. I looked it up but I can't seem to figure it out
23:12:13 <rand809809>  https://gist.github.com/bananabrick/1bd000b9188314a69e38fbe6ca30ad74
23:12:17 <rand809809> updated link
23:12:24 <hololeap> :t \e f -> either <$> f <*> pure id <*> e
23:12:25 <lambdabot> Applicative f => f (Either a b) -> f (a -> b) -> f b
23:12:43 <hololeap> dminuoso: how is it different than this?
23:13:57 <dminuoso> hololeap: It carries extra laws, I dont think they are naturally satisfied.
23:14:25 <dminuoso> hololeap: Also, this always runs the second effect. doesn't it?
23:15:14 <dminuoso> The point of selective is that the first effect can decide whether or not to take the second effect, you dont get that power with applicative
23:15:23 <hololeap> oh, i see
23:16:18 <dminuoso> I think during last haskell exchange there was a presentation about selective parser combinators with a load of TH to statically analyze and optimize parsers.
23:16:27 <dminuoso> Couldn't do that with monad strength parsers
23:16:47 <dminuoso> The package was supposed to be published, but it never was. :(
23:17:10 <hololeap> dminuoso: https://hackage.haskell.org/package/selective ?
23:17:13 <dminuoso> https://mpickering.github.io/papers/parsley-icfp.pdf
23:17:15 <dminuoso> Ah there it is!
23:17:25 <dminuoso> hololeap: No I meant `parsley`
23:17:53 <MarcelineVQ> mpickering's a busy boy
23:18:04 <dminuoso> How does he manage? :<
23:19:10 <dminuoso> The presentation was by Jamie Willis I think.
23:19:21 <dminuoso> https://github.com/J-mie6/ParsleyHaskell
23:19:24 <dminuoso> There it is :)
23:23:30 <iqubic> Well, my code isn't loading up in GHCi.
23:27:24 <iqubic> I first ran `cabal repl` I then tried to load up a file called Day07.hs. Runner.hs loads just fine, as that's a local file that I wrote myself. Then we get to the imports and things fail.
23:27:37 <iqubic> GHCi errors: http://dpaste.com/29XXA95
23:28:20 <iqubic> Current cabal file: http://dpaste.com/29XXA95
23:29:02 <MarcelineVQ> relink
23:29:18 <iqubic> Relink what?
23:29:25 <MarcelineVQ> one of your links
23:29:29 <iqubic> Which one?
23:29:33 <MarcelineVQ> the wrong one :>
23:29:59 <iqubic> Right. This is my current Cabal file: http://dpaste.com/0EFJRQ8
23:30:36 <iqubic> I don't see what's causing these errors.
23:33:13 <iqubic> Basically `:l Day07` fails.
23:33:42 <MarcelineVQ> interesting, you're typing  cabal repl  in the directory that .cabal file is in?
23:34:01 <iqubic> Yes I am.
23:35:07 <iqubic> If I wasn't, then Day07.hs wouldn't be found.
23:36:11 <iqubic> And Runner.hs, a file I created and wrote, has been found propely.
23:38:13 <MarcelineVQ> Once you've loaded up cabal repl can you import the things yourself? e.g. cabal repl    then    import Advent  ?
23:40:14 <iqubic> No, because of this error: http://dpaste.com/0ZC7NC0
23:41:21 <MarcelineVQ> something else is wrong then since I can do that with just your .cabal file
23:41:30 <iqubic> Alright. Thanks.
23:42:23 <MarcelineVQ> try a  cabal clean  and  cabal build  and see what you get but repl should have done anything build would have done with that file so idk
23:43:21 <iqubic> No, actually I suspect this is a nix issue.
23:44:27 <iqubic> Because I'm using cabal2Nix to turn my cabal.nix into a nix file, and then using that to set up my dev environment.
23:47:30 <liiae> > liftA2 (+) [1,2,3] [2,5]
23:47:32 <lambdabot>  [3,6,4,7,5,8]
23:47:41 <liiae> > liftA (+1) [1,2,3]
23:47:43 <lambdabot>  [2,3,4]
23:47:52 <liiae> > [1,2,3] >>= (\x -> if x == 1 then return x else return (x+2))
23:47:53 <lambdabot>  [1,4,5]
23:48:10 <liiae> now I see
23:52:06 <siraben> How can I get haddock documentation when I install packages via cabal?
23:52:41 * hackage control-monad-exception 0.11.3 - Explicitly typed, checked exceptions with stack traces  https://hackage.haskell.org/package/control-monad-exception-0.11.3 (PepeIborra)
23:55:11 * hackage control-monad-exception 0.11.4 - Explicitly typed, checked exceptions with stack traces  https://hackage.haskell.org/package/control-monad-exception-0.11.4 (PepeIborra)
23:56:19 <liiae> Functor and Applicative, do the same behavior on the value inside a context without change their structures
23:56:39 <liiae> Monad, can do different behavior
23:57:05 <liiae> right?
23:57:20 <dibblego> it is quite exactly the difference discussed earlier
23:57:23 <dibblego> that dependency
