00:03:39 <iqubic> MarcelineVQ: What's strange is that running `:m Data.Text` and `:m Advent` in my cabal repl both work fine. It's just trying to load up Day07.hs that fails.
00:05:21 <iqubic> Wait... I think I fixed this by running cabal update.
00:13:31 <typetetris> What's a good solution for validating request bodies in servant? Do I need to roll my own with a new content types
00:19:01 <dminuoso> What kind of validation are you thinking about?
00:20:42 <typetetris> dminuoso: Email address valid, Password at least 8 Characters, stuff like that
00:20:57 <dminuoso> typetetris: Generally you'd encode that logic into your handlers, rather.
00:21:15 <dminuoso> You can write a custom ContenType and implement MimeUnrender I suppose, but I think you're barking up the wrong tree here.
00:22:03 <dminuoso> One simple way to encode it (and gain guarantees), is by using phantom types.
00:23:23 <dminuoso> Say you have some `data Form (s :: ValidationState) = Form { formName :: Text, formPassword :: Text }` with some lifted `data ValidationState = Validated | NotValidated`
00:23:30 <dminuoso> (Or you could tag the individual fields with it)
00:24:02 <dminuoso> If you insist on proving with your type system that you validated some input, anyhow. Or just assume you do it in your handlers.
00:24:39 <typetetris> dminuoso: Thanks for the suggestion. Yes, I want to have some kind of guaranties, so I don't forget validating, when I create new endpoints.
00:24:54 <dminuoso> typetetris: Then the phantom type way is effective.
00:25:54 <typetetris> dminuoso: So I wouldn't export the data constructors and field accessor functions and implement functions for that, that require the correct phantom type and just export them? Or what would you suggest for that.
00:26:22 <dminuoso> typetetris: Id just write up `handleForm :: Form Validated -> T ()`
00:27:14 <dminuoso> And then ensure that in my API I'd have some `"foo" :> Post '[JSON] (Form Unvalidated)`
00:28:16 <dminuoso> Perhaps, if you carefully manage your exports, you could ensure that in your API module you only see the kind `Unvalidated`, avoiding accidentally tagging user input as Validate.
00:29:04 <dminuoso> typetetris: And equivalently, you can write custom field accessors with `s` pinned to Validated
00:29:26 <dminuoso> So `_formName :: Form Validated -> Text = formName` for instance, and dont export the field accessor.
00:29:48 <typetetris> dminuoso: Maybe I go that route, I have to think about it, if I want to manage my exports, if that is really worth it :
00:30:25 <dminuoso> well if the entire codebase is under your control, it's all going to be just honor based anyway.
00:30:39 <dminuoso> The controlled exports is just for reducing the likelihood of breaking the honor contract.
00:31:29 <dminuoso> There's other guards you could put into place. Say a pre-commit git hook that just ensures your API files dont contain any mention of `Validated`
00:40:36 <iqubic> Is the binary-search package broken for anyone else?
01:58:00 <siraben> Any way to make this use of lens smaller? g x = (x^.table.val, x^.sum.val)
02:39:23 <dminuoso> % :t lensProduct
02:39:24 <yahb> dminuoso: ; <interactive>:1:1: error:; * Variable not in scope: lensProduct; * Perhaps you meant `getProduct' (imported from Control.Monad.RWS)
02:39:40 <dminuoso> % import Control.Lens.Unsound
02:39:41 <yahb> dminuoso: 
02:39:42 <dminuoso> % :t lensProduct
02:39:43 <yahb> dminuoso: Functor f => ALens' s a -> ALens' s b -> ((a, b) -> f (a, b)) -> s -> f s
02:40:17 <dminuoso> siraben: ^- the unsound module should give you a strong indicator to read the documentation.
02:40:34 <dminuoso> (I dont think the code becomes smaller though)
02:41:05 <dminuoso> g x = x ^. (table.val `lensProduct` sum.val)
02:55:22 <dminuoso> Mmm, if I have `newtype F = F Word64`, how can I GND derive Read for Word64?
02:55:30 <dminuoso> (Rather than GHC deriving it)
03:04:38 <int-e> dminuoso: There's this, deriving newtype instance Read A
03:05:03 <int-e> (F, not A)
03:06:24 <dminuoso> int-e: Interesting, so I have to use DerivingStrategies?
03:06:53 <int-e> I believe so
03:18:16 <maerwald> https://github.com/judah/pier -- hmm, seems abandoned
04:05:22 <pagnol> How do you Int -> ByteString?
04:05:28 <pagnol> can't find anything
04:08:04 <Taneb> pagnol: what semantics do you want for that?
04:09:55 <pagnol> Taneb: basically like 'enodeUtf8 . pack . show'
04:10:03 <pagnol> so not binary
04:10:37 <Taneb> pagnol: what's wrong with what you've just written?
04:10:51 <pagnol> going through the String type seems... wrong
04:10:53 <pagnol> I don't know
04:11:22 <Taneb> There's also Data.ByteString.Builder.intDec which might be useful for you
04:11:32 <pagnol> ah, I'll take a look, thank you
04:11:38 <merijn> pagnol: What are you trying to do?
04:12:01 <merijn> pagnol: Output an int as, like, 8 bytes?
04:12:06 <pagnol> yes
04:12:23 <pagnol> to ascii
04:12:24 <merijn> pagnol: Right, then ignore all those string/intDec suggestions, those are just printing it as ascii
04:12:30 <merijn> pagnol: That's not the same thing
04:12:41 <merijn> Do you want text? Or do you want binary data?
04:12:45 <pagnol> text
04:13:17 <merijn> Then the stuff in Numeric or Data.Text to build a text and then at the end encode it
04:14:30 <pagnol> I was surprised hoogling Int->Text doesn't yield anything suitable
04:15:09 <merijn> There's the builder stuff in Data.Text.Builder, or just "T.pack (show i)"
04:15:32 <merijn> Several packages for numeric values to Text exist too, I think, but I generally don't bother
04:18:25 <Infin> рш
04:18:29 <Infin> hi
04:18:54 <Infin> :O 
04:20:08 <Infin> рш
04:20:10 <Infin> hi
04:20:19 <Infin> is anyone here?
04:20:38 <Infin> is anyone here?
04:21:03 <koz> Infin: Lots of folks are.
04:34:01 <pagnol> I can now occasionally use Haskell at work... feeling quite lucky
04:35:23 <Uniaika> pagnol: \o/ yay
04:35:29 <Uniaika> what's the usecase?
04:38:36 <maerwald> pagnol: only as long as you're the most experienced haskell dev
04:38:39 <maerwald> ;p
04:39:04 <maerwald> wait until you get type level anxiety
04:39:51 <pagnol> Uniaika: a bunch of smaller services
04:39:59 <Uniaika> pagnol: that's pretty cool
04:41:17 <pagnol> it's mostly just data to and from Postgres, rabbitmq, and interacting with various rest APIs
04:41:50 <maerwald> pagnol: https://github.com/PostgREST/postgrest
04:41:58 <pagnol> we're using that ;-)
04:42:05 <pagnol> have been for over two years in production
04:42:22 <maerwald> how is the experience
04:42:29 <maerwald> does it scale?
04:42:31 <pagnol> pretty good
04:42:53 <maerwald> optimizing queries etc
04:43:11 <maerwald> or do you have low load/small data set
04:43:17 <pagnol> we're using it for an in-house application which is important but doesn't have a lot of users (just my coworkers)
04:43:25 <maerwald> ah
04:43:25 <pagnol> so scaling is not something I've had to deal with
04:43:43 <maerwald> that's where most ideas break down :p
04:44:21 <maerwald> blockchain -- yayy... scale blockchain -> 50 papers
04:44:51 <pagnol> learning how to use it effectively is an ongoing experience 
04:45:00 <pagnol> do you know the postgrest-starter-kit?
04:46:06 <maerwald> no
04:46:10 <pagnol> take a look at it
06:00:34 <carbolymer> has anyone tried to mirror hackage & stackage to have 100% offline builds?
06:00:51 <carbolymer> offline i.e. only using intranet mirror
06:10:11 * hackage dobutokO-effects 0.6.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.6.0.0 (OleksandrZhabenko)
06:44:47 <dminuoso> carbolymer: Yes.
06:45:17 <dminuoso> carbolymer: skete was made for precisely that reason :)
06:45:36 <dminuoso> https://code.xkrd.net/skete/skete-haskell/-/tree/master
06:48:13 <carbolymer> thanks! will look into it
06:52:05 <carbolymer> dminuoso, will it work with stack? I heard from my team member that stack has some issues with http instead of https
06:53:39 <dminuoso> carbolymer: No idea, probably not.
07:18:25 <jumper149> Is there a better way to represent multiple types with one type without a type parameter, than just making it a sum type?
07:23:09 <Rembane> jumper149: Assume this is a X/Y, what are you trying to do?
07:27:10 <jumper149> I already wrote a sum type `data Sum = ARep A | BRep B` but I don't know how to write an arbitrary constructor and deconstructor like `constr :: Summable a => a -> Sum` and `deconstr :: Summable a => Sum -> a`
07:27:11 * hackage reactive-banana-gi-gtk 0.4.1.0 - Simple reactive programming with GTK GObject Introspection  https://hackage.haskell.org/package/reactive-banana-gi-gtk-0.4.1.0 (miscyb)
07:27:59 <jumper149> Maybe I should use something like Aeson, but I think there might be something more fitting here.
07:29:07 <jumper149> A and B have instances for the made up Summable class btw.
07:29:21 <Cheery> what are you trying to do
07:57:31 <jumper149> I will just write constr and deconstr as class methods of Summable. Maybe I can avoid boilerplate in the future with some TH, but I guess it will do for now.
08:03:45 <maerwald> anyone has experience with statically linking ncurses with brick? Afair, ncurses is one of those libraries that depends on runtime fils
08:04:01 <maerwald> so even if you statically link it, you're not off the hook
08:15:03 <frdg> if I am not mistaken, `mkYesod` is a function that takes a string and is able to magically create all the instances needed to make a route?
08:19:15 <dmj`> frdg: yea, its a quasiquoter
08:19:33 <dmj`> frdg: generates haskell types 
08:21:44 <frdg> dmj: Huh thats extremely convienent
08:22:49 <sm[m]> frdg: agreed!
08:25:37 <maerwald> how to do tables in brick
08:26:39 <dmj`> frdg: yea, but TH has a cost to it
08:28:03 <sarahzrf> what flag do i pass to ghc to get it to dump the final version of the Core it works on
08:28:23 <sarahzrf> there are a bunch of flags for different passes and it's not clear to me if any means "the overall phase of operating on Core"
08:28:30 <frdg> dmj: What cost? I had watched a talk a long time back that Haskell was amazing for template programming?
08:33:51 <Shiranai> Should I learn cabal-install or stack? Currently reading haskell programming from first principles and they use cabal
08:34:35 <dmj`> frdg: cross compilation for one, splices must always be compiled on the target, not host, even if its pure code. Compilation time can increase dramatically as well
08:36:49 <frdg> ok I will keep this in mind
08:37:19 <dmj`> frdg: and "programming" in a quasi quoter isn't really Haskell, its some sub language 
08:37:54 <dmj`> GHC.Generics can eclipse a lot of the benefits of TH
08:40:18 <sm> maerwald: there's this: https://www.reddit.com/r/haskell/comments/a30ebh/brick_rendering_a_navigatable_table/
08:44:40 <sm> Shiranai: opinions are divided, but it's best to learn the basics of both
08:45:01 <Shiranai> aight, thanks
08:45:39 <frdg> Shiranai: Also I believe that HPFFP actually uses stack
08:48:56 <Shiranai> just uses it some places but has a whole chapter mostly on how to use it
08:49:41 * hackage within 0.2.0.0 - A value within another path.  https://hackage.haskell.org/package/within-0.2.0.0 (locallycompact)
09:10:21 <maerwald> Shiranai: learn cabal
09:13:19 <maerwald> sm: looks all custom and complicated
09:43:32 <sm[m]> maerwald: yes, but it's all there is alas
09:43:32 <sm[m]> I need that oo
09:43:35 <sm[m]> too
09:48:06 <maerwald> sm[m]: or simpler... how to give a widget a minimum horizontal size
09:56:24 <hseg> hi. whatever happened to https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1075&context=compsci_pubs ?
09:56:37 <hseg> (constrained type families)
09:58:33 <phadej> hseg: https://github.com/ghc-proposals/ghc-proposals/pull/177
09:58:54 <hseg> ty, my google-fu failed me
09:59:22 <phadej> tl;dr authors didn't pursue addition of a feature to GHC proposal
09:59:40 <phadej> published paper doesn't imply a feature will be in GHC :)
09:59:47 <phadej> (e.g. ever)
10:00:07 <hseg> ofc
10:00:48 <hseg> but reasons for these counterexamples vary, and this seemed a natural enough proposal that the reason was probably "unforseen technicalities"
10:00:59 <hseg> so i was trying to figure out what was wrong with it
10:02:46 <hseg> gtg, thx tho
10:12:24 <noteness> Is there any learn by doing tutorials for haskell?
10:13:49 <[exa]> noteness: ghci? :]
10:14:10 <[exa]> noteness: anyway, it depends a lot on your programming background
10:14:58 <noteness> [exa], I would say I am kinda proficient in Python?
10:17:56 <[exa]> noteness: do you remember the simplest stuff you did when starting python? porting that to haskell is the best way forward usually
10:18:17 <[exa]> you already know the solution to the problem, just need to encode it in a very different mindset
10:19:11 <[exa]> there are various minor problems (mostly the missing straightforward "for" and the actual types of IO) but these can get easily solved by asking here
10:19:57 <noteness> My intro to python was through codecademy.com. hence the learn by doing question :)
10:20:22 <[exa]> anyway to the original question -- many books have exercises (haskell book, real world haskell, etc.)
10:20:54 <[exa]> a n y w a y
10:21:26 <noteness> My first python real project was an irc bot, lol. but that was because I had an example bot to look at. Anyway, i'll try doing something and pester you guys with questions :p
10:21:31 <[exa]> the most practical approach for starting up is probably getting Gloss to work, and doing some graphics
10:21:51 <noteness> s/(python) (real)/\2 \1/
10:22:00 <[exa]> IO (with the IRC bot) will naturally come next
10:23:33 <noteness> [exa], Thank you! wow! You guys are really n00b friendly :) Not only telling me the how, but the why also :D
10:24:43 <[exa]> noteness: right here https://hackage.haskell.org/package/gloss-1.13.0.1/docs/Graphics-Gloss.html
10:25:08 <[exa]> noteness: btw I guess you already stumbled across cabal?
10:27:30 <noteness> [exa], cabal is like a package manager?
10:28:24 <[exa]> noteness: very remotely like pip
10:29:10 <[exa]> there may be minor setup problems depending on where you get GHC from, but nothing serious.
10:29:43 <noteness> :o
10:29:52 <[exa]> just like with pip... :]
10:29:54 <maerwald> sm[m]: brick seems to crash a lot at runtime
10:32:37 * noteness is reading https://wiki.haskell.org/Introduction atm
10:33:17 <sm[m]> maerwald: not for me!
10:33:33 <sm[m]> what have you done
10:33:53 <sm[m]> shenanigans I bet
10:34:36 <spiderbubble> c_wraith: what do you think of this? https://hastebin.com/letotigulo.sql
10:35:04 <c_wraith> I like that.  span is a good choice
10:35:50 <spiderbubble> It feels a little weird since I basically just copied the definition of `groupBy`, but it more closely satisfies the definition of `Eq`
10:36:39 <c_wraith> well, it's definitely true that it no longer relies on unspecified implementation details
10:37:01 <c_wraith> also, it's really not more code.
10:38:14 <c_wraith> Oh, speaking of which - are you familiar with providing multiple function definitions instead of using a case expression? you could shorten matcherPrefix a bit that way. Would be functionally identical, but maybe a bit more idiomatic Haskell.
10:41:13 <spiderbubble> Oh right, like this? https://hastebin.com/qiledijinu.sql
10:41:16 <spiderbubble> That does clean it up a bit
10:41:26 <c_wraith> exactly what I was thinking
10:43:48 <dsal> spiderbubble: copying core bits isn't bad since they're typically good reference.
10:44:13 <dsal> Though I'd still use `groupBy`.
10:44:26 <c_wraith> dsal: even though groupBy isn't specified to work correctly for that use case?
10:45:56 <dsal> Yeah, it's kind of a grey area.  Using it in the obvious way does seem to get the right answer.  Copying the implementation doesn't seem to be much better.   It's not that complicated, though.
10:46:51 <c_wraith> that's a very underspecified function, fwiw.  The only thing the report or GHC's docs say is that it's the implementation for group.
10:47:37 <dsal> "The groupBy function is the non-overloaded version of group." is pretty bad documentation.
10:48:24 <c_wraith> Normally I say complaints about Haskell documentation are overblown, but that one justifies any complaints it gets.
10:48:29 <dsal> I interpreted the input specification as "group when the second operand is And"  i.e.,    `groupBy const (3 ==)`
10:48:45 <dsal> er, missing a dot
10:49:25 <dsal> Or parens.  I should go back to sleep.  *sigh*
10:49:40 <sm[m]> activate the bat signal for #haskell-docs 
10:50:22 <sm[m]> I wonder how we could do that, other than pinging Uniaika which seems less good
10:50:41 <dsal> Is Uniaika the one who owns all the documentation?
10:51:17 <sm[m]> is leading a fine charge to improve it, at least!
10:52:11 <sm[m]> since doc weaknesses and proposed new docs are likely to come up here often, it would be great to have an efficient way to forward them into #haskell-docs' queue
10:53:57 <dsal> `groupBy` is one of those things I'd have a hard time writing an English specification for that is easier to read than the implementation.
10:55:46 <c_wraith> You could at least specify the requirements for the input function's behavior to get specified output behavior.
10:56:20 <c_wraith> the funny thing is that group actually has a decent specification
10:57:50 <dsal> Hmm...  Yes, reading the `group` documentation, it's clearer to me why you wouldn't want to use something similar to it for this task.
10:58:59 <dsal> I guess you could write something similar, but "where `f a b` is `True`" or something.
10:59:08 <ezzieyguywuf> hm, I find myself doing `someIO >>= (flip when doSomeOtherStuff)` rather often - am I "doing it wrong"? I find that the call signatures in prelude are typically very toughtfully arranged, and the fact that I'm always flipping this one suggests to me that maybe I'm being weird
11:00:51 <sm[m]> I don't think using when in that way would be all that common
11:01:25 <ezzieyguywuf> hah
11:01:30 <ezzieyguywuf> so I _am_ being weird
11:01:45 <sm[m]> but there are times when flip is handy, at least it's short
11:02:39 <sm[m]> it's not necessarily bad style
11:03:12 <dsal> ezzieyguywuf: you could try hlint.
11:04:30 <dsal> hlint often suggests not using flip.  But I don't even know about that thing.
11:05:09 <sm[m]> can't we pipe things into hlint from here ?
11:12:22 <ezzieyguywuf> dsal: good idea. I keep meaning to integrate hlint into my workflow and my lazy butt just hasn't done it yet.
11:12:53 <dsal> I don't know that integrating is great.  It sometimes suggests I do things I don't want to do.  But running it now and then is helpful for me.
11:13:04 <electricityZZZZ> so, what is a type? it seems like types are a vehicle to provide constraints at compile time,... and then more generally i guess types represent compile-time programs... am i wrong?
11:13:36 <dsal> e.g., it'll suggest you use a string instead of a list of chars.  Sometimes I want a [Char] (which is a very different type from `"x"` and that leads to other issues)
11:17:11 * hackage shake-plus 0.2.0.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.2.0.0 (locallycompact)
11:17:20 <ezzieyguywuf> dsal: [Char] is different from "x"?
11:17:30 <dsal> % :t "x"
11:17:31 <yahb> dsal: [Char]
11:17:40 <dsal> % :set -XOverloadedStrings
11:17:40 <yahb> dsal: 
11:17:41 <dsal> % :t "x"
11:17:42 <yahb> dsal: IsString p => p
11:20:11 * hackage selective 0.4.1.1 - Selective applicative functors  https://hackage.haskell.org/package/selective-0.4.1.1 (snowleopard)
11:22:55 <ezzieyguywuf> dsal: ah, if you're using OverloadedStrings
11:25:50 <dsal> Yeah, and it's kind of silly not to use OverloadedStrings
11:26:38 <dsal> But even without it, sometimes you just really mean "this list of characters" and it's kind of weird to put them in a string just because.
11:26:55 <ezzieyguywuf> ahh, `mapM_` instead of `sequence_ . fmap`, that's a nice find hlint!
11:27:34 <ezzieyguywuf> it didn't have any thoughts on the `flip` that I was asking y'all about though.
11:28:02 <dsal> Huh.  It often suggests not to use flip.
11:28:02 <ezzieyguywuf> I guess I could just `check <- someIO; when check doSomething`
11:28:17 <dsal> @hoogle ifM
11:28:18 <lambdabot> Control.Monad.Extra ifM :: Monad m => m Bool -> m a -> m a -> m a
11:28:18 <lambdabot> Extra ifM :: Monad m => m Bool -> m a -> m a -> m a
11:28:18 <lambdabot> Protolude ifM :: Monad m => m Bool -> m a -> m a -> m a
11:28:54 <ezzieyguywuf> is that an extra dependency though?
11:29:00 <dsal> @hoogle whenM
11:29:00 <lambdabot> Control.Monad.Extra whenM :: Monad m => m Bool -> m () -> m ()
11:29:01 <lambdabot> Extra whenM :: Monad m => m Bool -> m () -> m ()
11:29:01 <lambdabot> Protolude whenM :: Monad m => m Bool -> m () -> m ()
11:29:19 <dsal> Maybe.  Or you just write it because it reads better.
11:29:46 * ezzieyguywuf nods
11:30:22 <dsal> I have a similar helper I wrote in one of my projects: `justM :: Monad m => (a -> m ()) -> Maybe a -> m ()`
11:30:32 <dsal> The implementation is:  `justM = traverse_`  heh
11:32:10 <dsal> It's a little backwards, but it works for me.
12:00:02 <ezzieyguywuf> it suggested it on another line, but `someIO >>= (`when` doSomething)`
12:00:05 <ezzieyguywuf> not altogether that bad
12:04:00 <ezzieyguywuf> although I guess it doesn't quite read as nice.
12:04:57 <dolio> Maybe you should ask why you have so manay `IO Bool` things going on.
12:05:46 <xsperry> is that uncommon?
12:06:30 <xsperry> half a dozen of functions returning IO Bool in System.Directory alone
12:07:08 <dolio> The ones that cause race conditions? :)
12:07:35 <xsperry> I'd be glad to hear for the alternative that doesn't :)
12:08:13 <dolio> I think the usual answer is to try something and catch if it doesn't work.
12:09:05 <dolio> Because if you test the boolean, it still might not work.
12:10:19 <dsal> IO Bool ~= "is there a point in the past where this was true?"
12:13:02 <ezzieyguywuf> hrmqqaaoeuhrm, A fair point...
12:13:57 <ezzieyguywuf> that was supposed to say "hrm"
12:14:55 <ezzieyguywuf> I'm checking a TQueue every time I loop around in my main loop. If it's empty, I do nothing. If it's not empty, I flush it and do something with the data
12:15:01 <monochrom> "It is better to have loved^H^H^H^H^Hopened and failed, than to have never tried just because a boolean function told you obsolete information." :)
12:15:28 <ezzieyguywuf> so the IO Bool is the check for whether or not the TQueue is empty
12:15:31 <ezzieyguywuf> b/c I don't want to block
12:15:37 <dsal> ezzieyguywuf: "checking"?  What do you mean?  Just wait for it to not be empty.
12:15:49 <Rembane> ezzieyguywuf: Why don't you want to block?
12:16:11 <ezzieyguywuf> Rembane: because I need to periodically poll for input, i.e. mouse/keyboard stuff
12:16:16 <monochrom> If you already use STM, you may as well use <|> or orElse for your plan B in case of queue empty.
12:17:00 <monochrom> In fact "is it empty?" is precisely implemented by dequeue <|> pure It'sEmpty
12:17:57 <monochrom> "is it empty?" makes sense iff you really don't have a plan B expressible in STM.
12:18:01 <ezzieyguywuf> I'm not quite sure I understand how <|> works
12:18:20 <dsal> > Nothing <|> Jus t3
12:18:22 <lambdabot>  error:
12:18:22 <lambdabot>      • Data constructor not in scope: Jus :: t0 -> Maybe a
12:18:22 <lambdabot>      • Perhaps you meant ‘Just’ (imported from Data.Maybe)error:
12:18:22 <ezzieyguywuf> my plan B is "keep looping and checking for input, which would fill up the TQueue"
12:18:26 <dsal> > Nothing <|> Just 3
12:18:28 <lambdabot>  Just 3
12:18:52 <monochrom> It works as: retry <|> foo = foo,  foo <|> retry = foo.  dequeue contains retry when empty.  retry is why you see blocking.
12:19:08 <dsal> If plan b is to keep looking, then you probably should just use `check`
12:19:33 <monochrom> dsal, but possibly this "keep looping" is in IO not in STM.
12:19:57 <monochrom> never trust informal descriptions.
12:20:19 <dsal> Heh.  Right.
12:20:39 <ezzieyguywuf> hm, I understand orElse, that documentation is very clear
12:20:48 <monochrom> <|> = orElse
12:20:52 <ezzieyguywuf> "keep looping" is in IO
12:22:25 <frdg> can shakespearean template code be directly put into .hs files? I am using yesod.
12:23:07 <sm[m]> frdg: yes, have a look in the yesod book or the package's documentation to see how
12:23:26 <frdg> ok thanks
12:24:28 <sm[m]> there's an example: https://www.yesodweb.com/book/shakespearean-templates#shakespearean-templates_interpolation
12:24:59 <hseg> so i was reading the simple constrained type families discussion, and antc2 implicitly had an interesting suggestion (https://github.com/ghc-proposals/ghc-proposals/pull/177#issuecomment-430462699) it seems like the difference bw tyfams and tycons can be reduced by splitting tyfams into function-like and pattern-like tyfams
12:25:08 <hseg> has anyone done research in this direction?
12:25:22 <frdg> sm[m]: appreciate it.
12:25:52 <hseg> (to use jargon -- it seems matchable tyfams = lifted pattern syns)
12:26:15 <hseg> (whereas our current tyfams act more like smart constructors, which is why they're unmatchable)
12:45:55 <hseg> on further thought, the matchable fragment of haskell seems pretty ill-supported. all we had for the longest time were just types and constructors, then we got pattern synonyms 6 years ago.
12:46:16 <hseg> but we still have no way of extending the typelevel with matchable terms
12:50:19 <dminuoso> monochrom: orElse suggests a left bias, which <|> does not have. This notion can trip you up badly in parser combinators.
12:52:33 <dsal> Well now I'm a bit confused.  I thought <|> had a left bias.
12:54:45 <c_wraith> it certainly does in parsec-like models
12:55:06 <c_wraith> But some models use unbiased choice
12:55:58 <dminuoso> The important part is that you don't get the bias guarantee from (<|>) alone. It's just that some instances happen to have left bias.
13:17:19 <dsal> Yeah, that makes sense.
13:18:04 <dsal> I've not had a problem in *parsec, but I may just not have sufficiently exhaustive tests.  I assume, apart from ambiguity, `try` might be a problem.
13:18:26 <dsal> Which I guess is where some kind of asum + fmap try thing makes sense even when you're trying to be clever in avoiding the final try.
13:19:25 <dsal> Things that look like they work even when used incorrectly are the worst.  I was told if my code compiles, it's correct.
13:19:42 <dsal> `main = undefined` -- code complete
13:25:38 <merijn> dsal: "main = _" :p
13:25:52 <merijn> undefined should be banned now that we have typed holes :p
13:26:13 <dsal> Does it actually compile?  I always thought it was just a useful error.  That's how I treat it anyway.
13:26:25 <merijn> dsal: If you want
13:26:46 <merijn> dsal: -fdefer-types-holes :)
13:26:49 <dsal> Oh neat.  Then yeah, that does make sense.  I've never written an undefined I didn't regret.
13:27:31 <merijn> dsal: That turns them into runtime errors in case you wanna test, but then you can remove -fdefer-typed-holes for final builds before releasing to make sure you don't forget :)
13:29:24 <dsal> That's pretty good.  I like not having errors in general.
13:49:03 <Uniaika> hi
13:49:20 <dminuoso> Uniaika: The answer is likely to be found in the kmettiverse. Keep looking!
13:49:33 <Uniaika> damnit, you're probably right
13:49:45 <Uniaika> that being said, it seems that sm[m] and dsal mentionned me earlier
13:49:51 <ja> the problem with the kmettiverse is that the answer is formulated using an abstraction you never knew applied to you :O
13:50:01 <ja> so how do you find it?
13:50:17 <dminuoso> I could draw you a diagram.
13:50:19 <merijn> You annoy Edward into explaining it to you :p
13:51:00 <dsal> Uniaika: Sorry to bother.  There was confusion around what `groupBy` does because the documentation mostly just leans on `group` and makes people uncomfortable in using it creatively.
13:51:33 <dsal> Someone mentioned you were responsible for all documentation.
13:51:37 <Uniaika> no worries, I'm not bothered, I'm the documentation mistress because it's my joy to be "bothered" by such things
13:52:11 <merijn> That's how these things work ;)
13:52:16 <Uniaika> ;)
13:52:34 <merijn> If you make a PR for some trivial thing to edward's stuff he'll sneakily make you a maintainer :p
13:53:05 <Uniaika> dsal: do you wish to submit a merge request to the documentation?
13:54:50 <dsal> Uniaika: I think I could do something based on the `group` documentation.  The only issue is that anything other than the code sounds verbose and imprecise.  The code is perhaps too overspecified, though.  Documentation is hard.
13:55:19 <dsal> Can't we just complain about how bad something is and why other people don't fix it without having to acknowledge it's also hard?
13:55:20 <Uniaika> it is hard indeed
13:55:32 <Uniaika> I suggest we take this conversation on the #haskell-docs channel
14:02:10 * hackage glpk-headers 0.4.1 - Low-level Haskell bindings to GLPK.  https://hackage.haskell.org/package/glpk-headers-0.4.1 (prsteele)
14:21:11 * hackage shakebook 0.9.0.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.9.0.0 (locallycompact)
14:35:42 <des7996> dear all: n00b here. i have a single-file module "Katex.Katexify" and want to import & use it in a tiny project. i'm using stack. where do i put this file, does its name matter, and how to tell the build system about it?
14:35:47 <NemesisD> if you've got `splitLens :: Iso' a [a]`  and `pris :: Prism' a b`, how could you get a `Prism' a [b]`? in other words, applying a prism over each element and failing the whole thing if any one of them fail?
14:36:19 <des7996> ... i'm trying to reproduce this Hakyll + Latex site https://ifazk.com/blog/2018-11-20-JavaScript-free-Hakyll-site.html
14:36:20 <merijn> des7996: It depends how you wanna treat it
14:36:47 <merijn> des7996: You can either treat it as an external package/library that's just one module (in which case, you'd make a cabal package out of it)
14:37:02 <merijn> des7996: Alternatively, you can treat it as "just a single module that's part of your project"
14:37:16 <merijn> des7996: In which case, just copy it into your current project and import it
14:37:18 <des7996> simpler would be #2?
14:37:43 <merijn> des7996: Where the name has to map to the module name with all the dots replaced with directoryn separators
14:37:56 <merijn> so "Foo/Bar/Baz.hs" has the module Foo.Bar.Baz
14:38:14 <des7996> ah, so inside my project dir: katex/katexify.hs ?
14:38:29 <des7996> thank you, will try that !!
14:38:35 <merijn> des7996: Yeah, except with proper capitalisation :)
14:38:52 <des7996> thanks!
14:39:39 <ja> NemesisD: maybe ask in #haskell-lens if you get no answer here
14:40:35 <des7996> stack build                                               (base) 16:38:59
14:40:35 <des7996> Exception while reading snapshot from ./katexify:
14:40:35 <des7996> InvalidYaml (Just (YamlException "Yaml file not found: /Users/desmond/Documents/code/web-sites/katex-blog/katexify"))
14:40:40 <des7996> merijn: some progress, but now get this 
14:41:22 <merijn> des7996: Sounds like the code is trying to read a file that's not on your system :)
14:42:32 <mleone> does anyone know how/if I can generate haddock for my cabal project along with the local dependencies only? I'm finding that when I run `cabal v2-haddock --enable-documentation` it halts when it can't build docs for a non-local dependency. wondering if I'm approaching this the wrong way...cabal 3.2
14:43:36 <merijn> mleone: tbh I just put "documentation: True" in ~/.cabal/config to globally enable building docs always (which isn't particularly helpful in solving your problem, I guess...)
14:43:59 <merijn> Also, sidenote. in 3.2 (or anything >3.0, really) the v2- prefix is optional since they're the default :)
14:46:51 <monochrom> >=3.0
14:47:31 <merijn> monochrom: Originally I was going to type 3.0+ :)
14:48:00 <mleone> ah good to know
14:48:00 <monochrom> --enable-documentation is most effective at "cabal configure" time
14:48:02 <merijn> Changing my mind about sentences halfway leading to fuck ups is very me :p
14:48:17 <monochrom> especially for dependencies
14:48:18 <merijn> monochrom: Except that cabal configure is now mostly a no-op :p
14:48:32 <merijn> monochrom: All it does is persist the argument flags for you
14:48:51 <merijn> monochrom: configuring with --enable-documentation should be the same as building/haddock with that flag
14:48:54 <monochrom> It is a yes-op. It resets cabal.project.local.
14:49:28 <monochrom> "cabal haddock" time is too late for dependency docs.
14:49:51 <mleone> from what I've seen while attempting this, just `cabal haddock` produces docs for the project and only the project. then when I add the enable flag it dives into dependencies, but I only want the local ones, especially if the third-parties are going to break
14:50:58 <mleone> so I need to be building with docs enabled then and just forgo the haddock command altogether?
14:51:35 <monochrom> You still need "cabal haddock" to kick cabal into building your package's doc
14:51:48 <merijn> mleone: Is there any specific reason to "not want third party docs"?
14:52:52 <monochrom> This workflow is a relic of the v1 era. It made sense for v1.
14:53:22 <maerwald> kicking cabal is always a good idea
14:54:12 <mleone> if they generate okay and is seamless to include then I'm fine with that, nothing against having the working links there. but it errors on basement-0.0.11 and prettyprinter-ansi-terminal-1.1.1.2 for some reason
14:54:35 <merijn> mleone: oh, but I know the life hack for that :)
14:54:58 <monochrom> What is your life hack for that?
14:55:20 <merijn> mleone: Ok, so basically as mentioned before "documentation: True" in ~/.cabal/config builds docs by default, then if you run into broken docs of dependencies you can override "documentation:True" via cabal.project
14:55:52 <merijn> mleone: So if you put "package basement\n  documentation: False" in cabal.project or cabal.project.local you're disabling it for just that package
14:55:56 <merijn> monochrom: ^^
14:56:22 <monochrom> that's nice
14:56:26 <merijn> The nice thing of the new cabal.project stuff is that you can selectively change/override the global config for specific dependencies :)
14:56:42 <mleone> hmm interesting
14:56:55 <merijn> That's how I usually fix it :)
14:59:55 <mleone> so if I wanted to be strict, theoretically I could put that expression for each of my non-local build-depends
15:00:12 <merijn> You could, you can even do "package *"
15:01:07 <mleone> and then pair that with a "package foo\n documentation: True" for the couple local ones that I want?
15:01:26 <mleone> or can you not False all and then True a few
15:03:16 <merijn> You can
15:03:26 <mleone> nice
15:03:26 <merijn> But documentation being broken is fairly rare
15:03:34 <merijn> So, I tend to just default to True
15:03:51 <mleone> yeah, I wasn't going to go down that road but was more just curious how/if that would work
15:04:36 <mleone> giving it a try  with that hack and we'll see how it goes!
15:18:17 <egigs> What are the exact effects of GHC.IO.Handle.hDuplicate?  I have a situation where i have a Handle open to an input stream and i want to feed the input stream as-is to multiple threads that take Handle input
15:18:54 <egigs> So, if I read some bytes in the first thread, i should also be able to read them in the second thread
15:21:37 <dsal> It looks like it's just dup
15:22:03 <egigs> i don't really understand what dup is for either
15:23:45 <egigs> when would i want to use hDuplicate?
15:23:46 <monochrom> 2nd thread won't see the same data.
15:24:20 <monochrom> file redirection is when you want to dup
15:25:21 <monochrom> or pipelining
15:26:00 <dsal> If you want multiple threads to see the same data, it makes more sense to do it at the application level.  TChan has a broadcast mechanism that probably does what you want.
15:27:16 <egigs> i want to multiplex code that is written for Handle and I expect one thread to fail quickly
15:27:56 <monochrom> "multiplex" is the opposite of "broadcast".
15:28:31 <monochrom> If two threads race to read from the same Handler, they end up doing multiplexing.
15:28:36 <dmwit> My advice: rewrite the code to not be written for Handle.
15:32:09 <egigs> hm, well thanks
15:33:29 <dsal> I do wish pread were a thing, though.  I think I did find one that sort of worked, but it was after I'd worked around it.
15:34:43 * hackage noli 0.1.0.0 - A static site generator  https://hackage.haskell.org/package/noli-0.1.0.0 (EndiSukaj)
15:49:43 * hackage noli 0.1.0.1 - A static site generator  https://hackage.haskell.org/package/noli-0.1.0.1 (EndiSukaj)
16:00:12 * hackage noli 0.1.0.2 - A static site generator  https://hackage.haskell.org/package/noli-0.1.0.2 (EndiSukaj)
16:04:42 * hackage noli 0.1.0.3 - A static site generator  https://hackage.haskell.org/package/noli-0.1.0.3 (EndiSukaj)
16:05:21 <boxscape> back in the day I used to think that the hackage bot just picks random packages to promote in IRC every once in a while
16:05:53 <Rembane> Randomness is very deterministic nowadays.
16:06:33 <koz> What does '-w' even do as an option to GHC?
16:08:45 <monochrom> disable all warnings
16:08:56 <koz> monochrom: Thanks!
16:09:08 <monochrom> kind of opposite of -W : enable normal warnings
16:21:02 <dmj`> :t bimapM_
16:21:03 <lambdabot> error:
16:21:03 <lambdabot>     • Variable not in scope: bimapM_
16:21:03 <lambdabot>     • Perhaps you meant one of these:
16:21:20 <koz> dmj`: I wonder if that's a thing.
16:21:31 <dmj`> :t bifor_
16:21:32 <lambdabot> error:
16:21:33 <lambdabot>     • Variable not in scope: bifor_
16:21:33 <lambdabot>     • Perhaps you meant one of these:
16:21:40 <dmj`> bimapM is
16:21:41 <koz> Wouldn't you need like, Biapplicative around for that?
16:22:30 <solonarv> :t bitraverse
16:22:31 <lambdabot> error:
16:22:31 <lambdabot>     • Variable not in scope: bitraverse
16:22:31 <lambdabot>     • Perhaps you meant one of these:
16:22:41 <solonarv> :t Data.Bitraversable.bitraverse
16:22:42 <lambdabot> (Data.Bitraversable.Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
16:22:54 <dmj`> there's a pattern I always use when dealing with IO (Either error result) types, ususally either handleLeft handleRight =<< action, but it seems bifor_ would handle that nicer
16:23:00 <solonarv> that's the one
16:23:15 <solonarv> yes, that would work too
16:23:25 <solonarv> % import Data.Bitraversable as Bi
16:23:25 <yahb> solonarv: 
16:23:45 <koz> solonarv: :D
16:24:42 * hackage libarchive 2.2.5.1 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.5.1 (vmchale)
16:28:13 * hackage hasql-queue 1.2.0.2 - A PostgreSQL backed queue  https://hackage.haskell.org/package/hasql-queue-1.2.0.2 (JonathanFischoff)
16:31:34 <mleone> monochrom shouldn't the `documentation: True` expression in the cabal.project file replace the need for the --enable-documentation flag at the command line?
16:44:06 <monochrom> I think yes.
17:16:42 * hackage requirements 0.6.0.0 - Abstraction to manage user defined Type Errors  https://hackage.haskell.org/package/requirements-0.6.0.0 (jpgarcia)
17:28:42 * hackage poly-rec 0.6.0.0 - Polykinded extensible records  https://hackage.haskell.org/package/poly-rec-0.6.0.0 (jpgarcia)
17:35:42 * hackage AspectAG 0.6.0.0 - Strongly typed Attribute Grammars implemented using type-level programming.  https://hackage.haskell.org/package/AspectAG-0.6.0.0 (jpgarcia)
17:40:19 <dsal> Wait, I've been writing documentation all this time, and all I've got to do is write `documentation: True` somewhere?
17:47:26 <sm[m]> dangit!
17:48:07 <koz> How does :*: associate?
17:52:48 <Shadorain> dsal: what do u write docs for? u write ur own haskell libs?
17:53:04 <dsal> Shadorain: Yeah.  Some people apparently even use them, as they complain about them.
17:53:21 <Shadorain> bruh :facepalm: haha why the complaints?
17:53:28 <Shadorain> what are they i might check em out!
17:53:43 <dsal> What kinds of things are you into?  I've written a few different things.
17:53:49 <Shadorain> sup cebola
17:54:02 <sm[m]> dsal, how did you get someone to read your docs ??
17:54:08 <Shadorain> mainly just now xmonad for haskell but i want to make projects with it too!
17:54:09 <dsal> Someone suggested a weird  situation with my mqtt client that doesn't make any sense and I can't reproduce the issue.
17:54:28 <Shadorain> ooh a mobile app?
17:54:29 <dsal> sm[m]: I'm not 100% sure anyone's read my docs.  But they have been useful to *me*.  :)
17:54:43 <dsal> Only mobile mqtt stuff I use is a thing someone else wrote.
17:54:44 <Shadorain> hahahah writing docs takes a lotta time
17:55:06 <Shadorain> u have a bunch of libs?
17:55:10 <sm[m]> same here. I have the impression the only time anyone else reads them is if I answer their question with a docs link (only!)
17:55:19 <Shadorain> gg
17:55:26 <Shadorain> they easy to find?
17:55:36 <Shadorain> sometimes it can be hard to find some docs
17:55:55 <dsal> A few.  I've got a bunch of IoT stuff.  mqtt client, mqtt broker, mqtt bridge, bridges to and from influxdb.  Tesla API and app.  GoPro API and app.  Those are the things I've spent the most time in/use the most.
17:56:00 <sm[m]> (if you also explain, the link is nullified :)
17:56:37 <Shadorain> u really like mqtt haha
17:56:44 <Shadorain> all in haskell?
17:58:25 <dsal> I also added mqtt v5 support to a C library and modified a node.js app to allow me to specify mqtt properties.  That was kind of horrifying.
17:58:29 <dsal> mqtt's pretty great, though.
17:58:38 <Shadorain> C and haskell <3 best things out there lols
17:58:53 <dsal> C should quite nearly not exist, but I was doing some embedded stuff.
17:59:18 <dsal> e.g., my gate opener and power and environmental monitoring stuff I've built.
17:59:20 <Shadorain> bro if u can embed C with Haskell
18:00:32 <dsal> https://usercontent.irccloud-cdn.com/file/lUCZtDi8/packet%20loss <-- that's my network monitor that tells me the status of my internet connection and VPN to my other house.  (it also monitors a UPS I built for my main computer here, measures temp and humidity in this room, and speaks a custom LoRa-based protocol to various junk)
18:01:45 <dsal> I've done a bit of work on proto-lens because I used it at work.  I wrapped a custom filesystem and custom file format libraries at work to present fairly pleasant haskell interfaces.
18:01:50 <dsal> But I don't like FFIing much.
18:01:56 <dsal> My mqtt stuff is all spec -> .hs
18:01:57 <Shadorain> u on *nix>
18:02:00 <Shadorain> ?*
18:02:00 <lambdabot> Maybe you meant: v @ ? .
18:02:26 <dsal> I wrote most of my mqttd on a hacked up chromebook running nixos.  heh
18:02:59 <dsal> It's good, though.  I have features mosquitto doesn't have.  Found some bugs in one of my things.
18:03:09 <Shadorain> i meant linux* lols
18:03:29 <Shadorain> i am not used to not being able to edit messages lols
18:06:28 <dsal> My main server here is a little 64-bit orange pi running armbian.  I've got another that's 32-bit.  Getting nixos on these things is hard.
18:06:40 <dsal> I might just run nix on armbian as a compromise.
18:07:27 <dsal> The latest feature I finished on my mqttd was on my Mac, but for no particular reason.
18:07:36 <dsal> Just work with whatever is near.
18:07:44 <Shadorain> thats awesome tho
18:07:51 <Shadorain> i love that haskell just works with everything
18:07:56 <Shadorain> except the deps tho...
18:08:03 <Shadorain> my poor poor pkg count :joy:
18:08:23 <dsal> Try building my gopro app.  heh
18:08:42 <dsal> http://dustin.sallings.org/2020/04/29/gopro-plus.html <-- I wrote a thing about it.  It will pull in the internet.
18:09:19 <Shadorain> oh goodness haha
18:09:43 <Shadorain> u put ur stuff up with just a binary right just so people dont have to grab all the deps
18:11:38 <liiae> dsal: on arm, haskell code can compile with static lined?
18:11:44 <liiae> linked
18:13:02 <Shadorain> sup merijn
18:13:27 <Shadorain> sup sMuNix
18:18:01 <Shadorain> i wonder how well ncurses can work with haskell
18:18:05 <Shadorain> i might have to check it out
18:18:16 <Shadorain> making ncurses tui stuff is what im most into , dsal
18:20:59 <dsal> liiae: I don't know.  I just do regular builds.
18:22:21 <dsal> Shadorain: I don't know curses that well, but I end up doing this kind of thing for AoCs: https://asciinema.org/a/288367
18:23:39 <Shadorain> dsal, ooh ive never seen something like that, its called AoC?
18:23:58 <dsal> It's the most wonderful time of the year:  https://adventofcode.com/
18:23:59 <Shadorain> looks like some ascii type thing
18:24:11 <dsal> That's just a visualization I did of my solution.
18:24:23 <Shadorain> ohhh thats awesomeeee
18:24:40 <dsal> AoC is an annual funtime.  Some of the puzzles beg for visualization.
18:24:45 <Shadorain> thats pretty cool, i didnt know there was stuff like that out there
18:25:29 <dsal> Some are really hard to capture: https://www.youtube.com/watch?v=R04l7DfyMq4
18:26:20 <dsal> For that particular one, you have a fairly complicated map (though only two dimensions) and an arbitrary number of things moving around them until they collide.
18:26:56 <dsal> You just get a puzzle each day and get to solve it.  Last year there were a few three (or more) dimensional mazes you had to solve.  Some of those are pretty hard to visualize.
18:27:09 <dsal> (visualization isn't part of the problem, just gets fun sometimes)
18:30:32 <dsal> For most of last year's problems, you had to build a computer emulator and then write things that ran programs written for that virtual machine and then things that interacted with those programs to solve problems.  e.g., for this one, you get a game of breakout and your computer has to run the game, but you have to know how the memory state of the machine relates to overall game state and send commands in to manipulate it
18:30:32 <dsal> https://asciinema.org/a/287652
18:30:40 <dsal> That's a dumb solution, but it works.
18:32:09 <dsal> I also did a variant where I'd just manipulate the game state such that the ball was always headed towards a block -- saved a bunch of time:  https://asciinema.org/a/287988  -- But if you don't have anything particularly interesting to work on in Haskell, start doing one of these a day.  You'll learn a lot of stuff really fast.  :)
18:34:07 <desmond> Kind peeps: this n00b is back ... Any pointer to repo for a Hakyll + LaTex + MathML site much appreciated. Struggling to grok modules + .cabal + Haskell + ... to get a static blog site up :) 
18:35:15 <Shadorain> dsal, can u solve with any lang that u want?
18:35:27 <dsal> Some people do it on paper.
18:35:32 <Shadorain> no way :joy:
18:36:09 <dsal> There's a dude who goes through all the things in excel every year.  People do weird things.  All you need is to give the right answer.  Nobody looks at your code.
18:37:24 <Shadorain> thtas pretty awesome thoooo
18:37:31 <Shadorain> i hate excel so much haha
18:37:34 <Shadorain> but thats so nuts
18:38:03 <dsal> Some of the graph problems get pretty tedious.  There's one each year where it takes all day for dumb reasons.  Either because the problem is trivially solvable, but not in a scaleable way, or because some of the rules are complicated.  E.g., there was a battle game from a couple years ago that took lots of people a whole day to get all the rules properly encoded into.
18:38:27 <dsal> There's always someone who solves every problem in a couple minutes, but those people don't count.
18:40:07 <dsal> A lot of the solutions are so easy in Haskell, though, you'll tend to solve them without even writing a program.  I tend to go back and write something just because I like writing unit tests.
18:40:46 <Shadorain> bruh those people so annoying :joy:, i do CTFs so i get it :/
18:40:55 <Shadorain> hahaha thats nuts
18:42:51 <dsal> Haskell is super easy, so it feels like a cheat code to the whole thing, but the problems are still fun.
18:43:12 <liiae> except stack, are there other tools to build haskell envrionment? haskell on archlinux sucks
18:43:50 <liiae> that a bunch of archlinux dynaic libraries
18:43:57 <dsal> Just don't use arch.
18:44:05 <Shadorain> oof i use arch
18:44:12 <dsal> arch ruines lives.
18:44:15 <Shadorain> :(
18:44:22 <Shadorain> arch brought be back to life
18:44:33 <Shadorain> atleast my summer
18:44:46 <liiae> pacman is the most powerful package manager I ever seen
18:44:46 <dsal> nixos is the only linux I've run that I've actually liked.
18:44:57 <Shadorain> pacman is suppper noice
18:45:03 <Shadorain> id go void tho tbh
18:45:10 <Shadorain> if i wanted to re set up everything
18:45:15 <liiae> I hate to config something...
18:45:25 <dsal> liiae: I can run six different versions of the same package on nixos in a way that doesn't conflict so I can work on different projects without having to worry about up/downgrading dependencies.  And without having to like... write things.
18:45:31 <Shadorain> bruh u must not run a wm, liiae
18:45:35 <dsal> I can install apps that are only installed until my shell exits, when I want to try things.
18:45:39 <Shadorain> yall run twm?
18:45:48 <dsal> I run xmonad on nixos.
18:45:50 <Shadorain> YESSSS
18:45:55 <Shadorain> my boy!!
18:45:56 <liiae> Shadorain: fvwm forever!
18:46:09 <Shadorain> never even heard of it :joy:, liiae
18:46:13 <Shadorain> older one?
18:46:32 <liiae> fvwm based on twm
18:46:45 <Shadorain> by twm i meant "tiling window manager"
18:46:46 <liiae> very powerful and beautiful
18:46:56 <dsal> I used to run fvwm, twm, etc...  xmonad does the thing pretty well.
18:46:58 <liiae> yes, I know it
18:47:10 <Shadorain> i meant in general "tiling window managers haha"
18:47:15 <liiae> dsal: xmonad is just another i3-wm to me
18:47:18 <liiae> nothing fancy
18:47:20 <Shadorain> NOOO
18:47:22 <Shadorain> not tru!
18:47:24 <Shadorain> i3 sucks
18:47:33 <Shadorain> dwm/xmonad/bsp are my 3
18:47:38 <dsal> I don't know i3.  xmonad is just a monad called X in a library you can write a window manager in.
18:47:47 <liiae> fvwm and twm can iconfy windows to icons, that's cool! just like android or iOS
18:47:59 <Shadorain> ok thats pretty cool
18:48:04 <Shadorain> ill have to look into it
18:48:17 <Shadorain> but can u make ur own layouts, that can literally do anything lol?
18:48:23 <dsal> I don't iconify stuff.  I just have a few virtual desktops with accordions and stuff.
18:48:25 <Shadorain> thats what is still selling me bout xmonad
18:49:45 <dsal> I don't do much with xmonad, though.  It's basically the thing that shuttles me among tmux, emacs, and a browser.
18:50:00 <Shadorain> yikes why tmux on a twm?
18:50:05 <Shadorain> emacs i have to get more into
18:50:09 <Shadorain> im a vim guy for now tho
18:50:20 <liiae> tmux is another version of screen?
18:50:54 <liiae> Shadorain: aha, I thought that all haskell users are also emacs users
18:50:55 <ezzieyguywuf> if I have a `myFunc :: IO (IO ())`, is there any other way to execute then `toRun <- myFunc; toRun`?
18:51:09 <Shadorain> im very new to haskell so not yet!
18:51:11 <Shadorain> hehe
18:51:12 <ezzieyguywuf> liiae: yes to tmux
18:51:17 <xsperry> :t sequence
18:51:18 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
18:51:20 <Shadorain> vim bindings for everything tho all the way
18:51:20 <ezzieyguywuf> liiae: I use vim.
18:51:31 <Shadorain> ezzieyguywuf, good man!
18:51:50 <xsperry> :t join (undefined :: IO (IO ()))
18:51:51 <lambdabot> IO ()
18:51:51 <ezzieyguywuf> Shadorain: ☺
18:51:58 <xsperry> :t join
18:52:00 <lambdabot> Monad m => m (m a) -> m a
18:52:09 <ezzieyguywuf> xsperry: I think that's it! thank you
18:52:10 <liiae> ezzieyguywuf: I use vim on the terminal, and emacs on X
18:52:14 <xsperry> np
18:52:18 <dsal> tmux is a window manager for text
18:52:32 <ezzieyguywuf> Terminal MultiplUXer
18:52:34 <xsperry> > join [[1,2,3],[4,5,6]]
18:52:36 <lambdabot>  [1,2,3,4,5,6]
18:52:40 <ezzieyguywuf> er, Termin MUltipleXer
18:52:44 <ezzieyguywuf> well..you get it
18:52:57 <liiae> dsal: never heard of that
18:53:01 <dsal> Shadorain: outgrowing vi made my life a lot better.  :)
18:53:07 <Shadorain> bruh
18:53:09 <Shadorain> vi sucks
18:53:12 <Shadorain> nvim
18:53:28 <dsal> vi sucks, here's a slight variation that works the same way.
18:53:28 <liiae> Shadorain: how about ed, ex? haha
18:53:38 <Shadorain> no no
18:53:44 <Shadorain> u ever use plugins on vim
18:53:46 <Shadorain> ?*
18:53:46 <lambdabot> Maybe you meant: v @ ? .
18:54:04 <ezzieyguywuf> yikes, dunno if #haskell is the best place for a text editor war...
18:54:33 <sm[m]> tmux sucks, dtach + emacs rules!
18:54:35 <dsal> heh.  yes, let's get back to window managers....
18:54:53 <liiae> sm[m]: right! bro
18:54:57 <dsal> Shadorain: but seriously, just start going through one of the AoC years... good stuff.
18:55:17 <liiae> dsal: what is AoC? another codewars?
18:55:32 <dsal> https://adventofcode.com/
18:55:37 <ezzieyguywuf> I've considered dtach plus....dunno
18:56:00 <ezzieyguywuf> ah, dvtm maybe
18:56:46 <Shadorain> i def will check it out 
18:56:52 <Shadorain> whenever it happens next
18:57:04 <Shadorain> for now i gotta focus on getting good at haskell 
18:57:12 <dsal> I started using tmux a couple of years ago.   Got angry at myself for not doing it before.   Same with mosh.  Spent too much of my youth being dumb.
18:57:19 <sm[m]> dtach plus mosh plus htop...
18:57:52 <sm[m]> ...is good for checking in on those slow vps haskell builds
18:58:45 <ezzieyguywuf> mosh over ssh?
18:58:51 <ezzieyguywuf> hrm, I've never heard of mosh till now...
18:59:13 <liiae> I prefer ssh over kcptun
18:59:21 <liiae> very fast!
18:59:59 <dsal> ezzieyguywuf: mosh is the best thing I'm angry at myself for not trying.  You can read about it, but it doesn't make sense until you try it.
19:00:21 <Shadorain> yeh thats one thing that bugs me bout haskell
19:00:29 <Shadorain> the build times are just so heavy lol
19:00:36 <dsal> mosh+tmux changes lives.  I log into machines from my laptop ~once per reboot.
19:00:51 <dsal> Shadorain: yes, the language allows for extremely complicated builds.
19:00:53 <Shadorain> like ghcide took over a half hour ( i need it for vim lsp)
19:00:56 <sm[m]> Shadorain: set up ghcid right away to minimize that hassle
19:01:03 <Shadorain> HAHAH exactlyy!!!
19:01:13 <dsal> I solved one of the AoC problems with an O(1) search build doing it all at compile time.
19:01:19 <ezzieyguywuf> dsal: I'm addding it to my todo.
19:01:25 <ezzieyguywuf> +1 ghcid
19:02:14 <dsal> An hour... that's cute.  I've built ghc for arm to build somewhat complex apps on arm with ghc.
19:03:25 <Shadorain> ur just torturing urself with that haha
19:03:42 <ezzieyguywuf> Shadorain: don't confuse ghcide with ghcid
19:03:52 <dsal> Or ghci or ghc
19:04:01 <ezzieyguywuf> tru
19:04:20 <Shadorain> oh how are they diff ezzie?
19:04:26 <Shadorain> haha ik that one: dsal
19:04:57 <Shadorain> i thought u just typo'd ezzie
19:05:05 <dsal> > ["ghc" <> x | x <- inits "ide"]
19:05:07 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
19:05:27 <dsal> They're different in the lengths of their names and their function.
19:05:32 <ezzieyguywuf> Shadorain: ghcid is a simple daeman (the d) that runs ghci and displays any errors to you. it has some other configurability
19:05:44 <ezzieyguywuf> it's very easy to setup, it's very light, and very useful
19:06:08 <Shadorain> oh crap so i guess i should get it
19:06:39 <Shadorain> should i use stack or cabal btw?
19:06:45 <Shadorain> they seem to be the same to me lols
19:06:54 <Shadorain> stack just seems to be more containerized?
19:06:54 <dsal> Shadorain: Back on the OS/package manager war.  The UI of my GoPro app requires make and and elm compiler.  I "install" them using "cd":  https://asciinema.org/a/JHriuadYzwls1aEYKDLG6lj1r
19:07:17 <dsal> stack vs. cabal is another war.   I use stack because I haven't figured out how to replace my stuff with cabal.
19:07:18 <Shadorain> ur just nuts :joy:
19:07:29 <Shadorain> i have both lols
19:07:45 <Shadorain> and use both when one doesnt work LOL
19:07:46 <Axman6> everyone has both
19:07:52 <Shadorain> my haskell packages are all fked up
19:08:07 <dsal> (oh, and uglifyjs which requires node.js and npm and a bunch of other stuff I don't want globally installed)
19:08:17 <Shadorain> yikes web stuff
19:08:31 <ezzieyguywuf> I started with cabal then started using stack for a very specific reason
19:08:35 <ezzieyguywuf> ...can't remember that reason
19:09:57 <koz> I use stack at work, Cabal for personal.
19:10:04 <koz> (they'll see eye to eye with me yet)
19:11:24 <Axman6> I tend to write more apps than libraries, so use stack more often, the startup time for a new project (has historically been) is lower, but I haven't had the time to look at new cabal, I'm sure things have improved a lot. I also miss the nostalgia of using cabal
19:11:52 <koz> I basically end up using cookiecutter to scaffold new projects regardless.
19:11:55 <Shadorain> oh ok so stack is more for like projects right?
19:12:01 <koz> Because stack's support for this is _super_ lacking IMHO.
19:12:08 * Axman6 /nick CommaMan6
19:12:15 <koz> It more or less amounts to 'great if you're Snoyman, terrible if you're me'.
19:13:00 <ja> what does the Ax mean Axman6?
19:13:12 <koz> ja: The thing you hit people over the head with in horror films.
19:13:23 <dsal> ja: he had all the answers
19:13:56 <sm[m]> I don’t think that’s fair, stack has a great project template system you can contribute to
19:14:11 <koz> sm[m]: I speak only for myself.
19:14:22 <koz> I don't consider it 'great' in any sense, based on the times I've tried to use it.
19:14:23 <Shadorain> wb for libraries tho
19:14:37 <koz> (since I'm literally using a Python thing to do its own job, in my opinion better)
19:14:40 <Shadorain> so like if i was to make emacs haskell libs, that would make more sense to be cabal right?
19:14:45 <Shadorain> for example ^
19:15:07 <koz> Your mileage can, and will likely, judging by your responses, vary.
19:15:14 <koz> It does not mean that mine is any less valid.
19:15:16 <dsal> sm[m]: I use my own template
19:16:25 <ja> i thought maybe it was short for axiom
19:16:25 <sm[m]> koz, ok! I'm just curious, what do you miss from stack's project scaffolding system ?
19:16:32 <sm[m]> good project templates ?
19:16:58 <koz> sm[m]: It was a long time ago (I first started using stack probbo about 4 years back). I don't recall my specific gripes at this time.
19:17:05 * ezzieyguywuf wonders how to use a template other than project (or w/e the default one is)
19:17:08 <koz> I'm sure I could recover said gripes if I were to try using it today.
19:17:21 <koz> I don't think I'm motivated to do so, considering that I have a solution that has no such gripes right now.
19:17:23 <sm[m]> ok, four year old gripes noted :)
19:17:51 <MarcelineVQ> ja: it's short for axolotl, the man is short for manfield, the 6 is just 9 someone tipped over as a joke
19:18:20 <ja> ah cool i love nahuatl too
19:19:05 <liiae> stack put everything on AWS, that's why I don't like it
19:19:21 <liiae> and cabal has v1, v2, v3...
19:20:06 <ezzieyguywuf> nixMode
19:20:10 <ezzieyguywuf> windows mode...
19:20:13 <ezzieyguywuf> (bsd?)
19:21:10 <ja> yeah, they put some of bsd in windows for the tcp/ip stack afaik
19:21:34 <liiae> and lsp-server that's another stupid stuff, there's never a binary release
19:21:57 <Axman6> ja: it's a family name, here's a video about one of my siblings. He's definitely not the brightest of the bunch: https://www.youtube.com/watch?v=4Z2Z23SAFVA
19:21:58 <liiae> I hate to compile that, it takes too much time
19:22:23 <ja> > isRickroll "4Z2Z23SAFVA"
19:22:25 <lambdabot>  error:
19:22:25 <lambdabot>      Variable not in scope: isRickroll :: [Char] -> t
19:22:30 <ezzieyguywuf> didn't they put ubuntu in windows too?
19:22:39 <liiae> ezzieyguywuf: wsl, yes
19:23:08 <liiae> but their windows terminal sucks
19:23:41 <liiae> not all the terminal behaviors just like xterm's
19:23:45 <Axman6> ja: that should definitely be a thing.  it is a not a Rick Astley video. if you're about my age it should being some good nostalgia feels from a better time on the internet
19:23:52 <ja> hahah a charming video actually :D
19:24:52 <Shadorain> ima head out yall
19:24:56 <Shadorain> thanks for the fun!
19:25:16 <Shadorain> :q
19:25:18 <Shadorain> oml
19:25:30 * Axman6 /quit
19:25:36 <Shadorain> ah
20:45:09 <remexre> Hm, how do I get a package that uses alex (e.g. ormolu) to cross-compile?
20:45:37 <remexre> It looks like it downloads a copy of alex and builds it for the target machine instead of the build machine
20:48:44 <remexre> ig option 2 is to native-build it under qemu, but ew
20:49:03 <ja> yes, would be sad if you needed an emulator
20:49:27 <ja> how do you know ormulu uses alex? i can't find it in github: https://github.com/tweag/ormolu/search?q=alex&unscoped_q=alex
20:49:59 <remexre> because it yells at me about alex when I try to build it :P
20:50:04 <remexre> I think it's thru its haskell parser
20:50:53 <remexre> build logs in a sec
20:50:56 <ja> hmm, the first step is to find out where the problem is, i guess. cross compiling is not all broken, right? so maybe it is just a package with a wonky cabal file or something
20:51:14 <remexre> https://p.acm.umn.edu/XMnZbYXVMAA=
20:51:32 <remexre> yeah, I was able to cross-compile cabal using this cmdline
20:52:13 <dmj`> it doesn't use alex
20:54:20 <ja> remexre: maybe it would be useful for debugging to use cabal-plan https://hackage.haskell.org/package/cabal-plan#description
20:55:21 <ja> need to figure out what specifies alex as a dependency to find out why it is built for the wrong target
20:55:34 <remexre> ok, will try in a sec
20:59:26 <ja> ps awesome that you're in minnesota, reminds me i gotta get back to watching Fargo ;)
21:30:17 <remexre> ja: heh, I haven't seen the show; loved the movie though, grew up pretty close to the dealership
21:32:51 <remexre> and ghc-lib-parser depends on alex and happy
21:33:28 <remexre> which ormolu depends on directly
21:34:15 <ja> ah, i just noticed your command line and i saw that you just specify the path to the ghc to use directly
21:34:33 <ja> but how would cabal know that you are cross-compiling? you're not telling cabal about the target architecture
21:35:47 <ja> i would imagine that you'd need --host for autotools https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html
21:35:58 <ja> something like that
21:38:32 <remexre> so wait do I need like... cabal v2-configure --something?
21:39:21 <ja> the flags you pass are probably already passed to configure
21:39:52 <ja> i think a problem may be that --with-ghc is overriding the compiler for all stages, but you don't wanna overrider the compiler for executables that are not to be run on the target
21:40:35 <ja> so maybe --with-ghc is not the right option? but OTOH, i didn't see proof that it tried running a cross-compiled alex on your build machine, so i don't know if that is actually a problem for you?
21:40:49 <ja> did you see this? https://cabal.readthedocs.io/en/stable/installing-packages.html?highlight=with-ghc#cmdoption-setup-configure-with-prog
21:41:08 <ja> the --with-prog syntax can be used to override more than just ghc
21:42:25 <remexre> $ file /home/nathan/.cabal/store/ghc-8.10.1/alex-3.2.5-6b5b728d96c96083e5a9d5c836b894f620fc09d2a1d119a30072937076a49320/bin/alex
21:42:27 <remexre> /home/nathan/.cabal/store/ghc-8.10.1/alex-3.2.5-6b5b728d96c96083e5a9d5c836b894f620fc09d2a1d119a30072937076a49320/bin/alex: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, with debug_info, not stripped
21:42:29 <remexre> I did not
21:43:33 <ja> cabal should group binaries by target architecture... i wonder if nix does this correctly...
21:44:06 <remexre> oh, --with-alex and --with-happy
21:44:08 <remexre> works
21:44:37 <ja> ok, so now you're overriding the alex to point at one that is not cross-compiled?
21:44:45 <remexre> yeah
21:44:54 <ja> i am happy it works for you but ... yeah, you know what i think :P
21:45:12 <remexre> that I should use nix?
21:46:31 <ja> heh, that is the nuclear option. well, i would hope it was possible to cross compile in a way where you don't need to explicitly provide the path of every build tool needed along the way. instead of overriding the wrong alex, it would be better to simply only specify the ghc used for the target ghc, so that alex isn't ever built for the wrong architecture!
21:47:09 <ja> it's like making a soup with flies in it and then fishing them out ;) better not have flies in the first place :P
21:47:26 <remexre> I mean, it's like make CC=aarch64-linux-gnu-gcc :P
21:49:17 <ja> ok, according to this post autotools cannot distingush between compilers for targets and compilers for earlier stages: https://stackoverflow.com/questions/8738086/what-is-the-sense-of-the-word-host-in-hostcc-and-configure-host
21:49:45 <ja> well, we should be able to do better than autotools anyway
21:50:26 * ja wonders how many people put autotools frustration on their gravestones
21:50:28 <remexre> idk, I'm kinda on team "the system should have two binaries, the kernel and the JIT-compiler, and every binary should be compiled on first use"
21:53:07 <ja> hmm, the world may be headed in that direction... except it's a stack of JIT compilers, not just one :O
21:53:32 <remexre> yeah, my preferred vehicle for this is Forth, which... doesn't seem to be making a comeback
21:53:50 <remexre> but you can do lambda calc -> categorical abstract machine -> Forth pretty easily
21:54:17 <ja> i never understood the appeal of forth! isn't it like pointless programming in haskell? doesn't it get cryptic without names?
21:54:29 <remexre> lol, I'm a big pointfree fan too
21:54:51 <remexre> if you split things up into small, well-chosen definitions, then it's usually not a problem in practice
21:55:06 <remexre> tho most of my forth time is spent refactoring
21:55:37 <remexre> and having the stack instead of named variables is kinda-sorta-almost like linear types
21:55:45 <remexre> (in that you need to explicitly clone things, at least)
21:56:06 <remexre> which makes memory management mistakes /way/ less likely than C
21:59:47 <ja> yeah, it must be fast also, if you can express it in that way
22:00:07 <remexre> ugh, now ormolu is complaining, "this operation requires -fexternal-interpreter" when compiling Main; regardless of whether I pass that to cabal or not
22:00:26 <remexre> ig there's probably some --ghcflags
22:00:45 <remexre> eh, depends pretty heavily on if your implementation is smart enough to map the stack to registers
22:01:04 <ja> are you running cabal with --verbose=2 ? 
22:01:30 <remexre> (which most "proper" ones are, but the ones I make usually just keep the top stack item or two in registers, and everything else in memory)
22:01:33 <remexre> nope
22:01:56 <ja> maybe it would print the full ghc invocation path and you can see why it fails or something?
22:01:59 <ja> like V=1 for make
22:02:51 <remexre> yeah, it doesn't pass the arg
22:04:24 <ja> remexre: you can also use cabal.project to override ghc-options: https://cabal.readthedocs.io/en/stable/nix-local-build.html#package-configuration-options
22:09:08 <remexre> ugh, with ghc-iserv it wants to use is aarch64, and --with-ghc-iserv isn't a thing... time for ghc --help ig
22:15:17 <ja> it's getting hairy with the interpreter, i am out of my depth (._.)
22:36:12 * hackage postgresql-simple-opts 0.6.0.1 - An optparse-applicative and envy parser for postgres options  https://hackage.haskell.org/package/postgresql-simple-opts-0.6.0.1 (JonathanFischoff)
22:53:43 * hackage haskell-to-elm 0.3.1.0 - Generate Elm types and JSON encoders and decoders from Haskell types  https://hackage.haskell.org/package/haskell-to-elm-0.3.1.0 (OlleFredriksson)
22:56:23 <remexre> tbh, just gonna try replacing the binary with the x86_64 one and see what breaks
22:57:31 <Rapeseed> Eat my diarrhea
22:57:38 <Rapeseed> Just...
22:57:40 <Rapeseed> Just ate a burger at the sleazy joint
22:57:41 <Rapeseed> Now I gotta take a shit, get to the point
22:57:43 <Rapeseed> Sittin' on the toilet, my ass is a blast
22:57:45 <Rapeseed> Runnin' smelly diarrhea outta my ass
22:57:48 <Rapeseed> No f*ckin' paper
22:57:49 <Rapeseed> Hey baby lick my ass 'til your face turns blue
22:57:51 <Rapeseed> You're finished rimmin' me and you want some more
22:57:53 <Rapeseed> Ya say ya don't flush but your out the door
22:57:55 <Rapeseed> I'm back in the...with a cup
22:57:57 <Rapeseed> Scoop it outta the toilet 'cause you wanna slurp it up
22:58:00 <Rapeseed> Eat my diarrhea you're chuggin' it down
22:58:01 <Rapeseed> You're suckin' my ass and your lips are all brown
22:58:05 <Rapeseed> Since we've gone back to the hamburger place
22:58:07 <Rapeseed> I'm gonna stick my ass right on your face
22:58:09 <Rapeseed> I'm gonna shit in your mouth
22:58:11 <Rapeseed> I'm gonna shit in your face, your mouth
22:58:15 <Rapeseed> And I wanna shit on your mother
22:58:18 <Rapeseed> I'm gonna shit on you and your mother
22:58:19 <Rapeseed> Diarrhea
22:58:22 <Rapeseed> I gotta take a shit
22:58:23 <Rapeseed> Gotta bottle a Ex-Lax, gonna take it
22:58:25 <Rapeseed> I'm gonna take me a lumpy shit
22:58:27 <Rapeseed> Gonna throw it at you, I hope I hit you
22:58:29 <Rapeseed> I hope it splats in your face there too
22:58:31 <Rapeseed> It's comin' out my ass all drippin' wet
22:58:35 <Rapeseed> It's comin' out my ass all drippin' wet
22:58:37 <Rapeseed> I want you to suck up all of it
22:58:39 <Rapeseed> Lick my ass and eat it too
22:58:44 <Rapeseed> Cause diarrhea is good for you
22:58:44 <Rapeseed> Ya eat it, eat it, eat
22:58:46 <Rapeseed> Eat it, eat it, eat
22:58:48 <dmj`> @where ops
22:58:48 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
22:58:48 <Rapeseed> Diarrhea
22:58:49 --- mode: ChanServ set +o Cale
22:58:50 <Rapeseed> Eat my f*ckin' shit
22:58:54 --- mode: Cale set +b *!*@71.19.249.95
22:59:14 --- mode: Cale set -o Cale
22:59:23 <materiyolo> lol
23:15:57 <remexre> ...anyway
23:16:23 <remexre> replacing ghc-iserv did not work
23:25:29 <ja> remexre: i am very curious about it, if you ask a well-written StackOverflow question i can put a large bounty on it
23:27:11 <remexre> okay, might write that up tomorrow
23:27:18 <remexre> thanks for your help!
23:28:14 <ja> no problem, irc'ing in the night is awesome!
23:28:16 <jle`> is stackage.org down for anyone else?
23:28:30 <ja> jle`: down for me too
23:28:46 <jle`> :'(
23:29:16 <ja> according to https://downforeveryoneorjustme.com/ also down
23:30:03 <jle`> hm, is there a status page or anywhere for this?
23:30:26 <jle`> all i want to do is check what ghc versions are associated with each LTS :(
23:32:04 <ja> jle`: you can use google cache https://webcache.googleusercontent.com/search?q=cache:wVkkZ-Ss-hYJ:https://www.stackage.org/+&cd=2&hl=en&ct=clnk&gl=mx
23:32:24 <shafox> which formatter you use while working on projects in emacs ?
23:33:33 <jle`> ja: thanks, that's perfect :)
23:41:12 * hackage matrix-lens 0.1.0.0 - Optics for the "matrix" package  https://hackage.haskell.org/package/matrix-lens-0.1.0.0 (lgastako)
23:50:32 <jackdk> shafox: personal projects: my own sense of style. work projects: ormolu
23:56:42 * hackage monad-logger 0.3.34 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.34 (MichaelSnoyman)
